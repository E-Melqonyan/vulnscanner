- diff_content:
  - "--- a/src/remote/remote_daemon_dispatch.c\n+++ b/src/remote/remote_daemon_dispatch.c\n\
    @@ -2291,6 +2291,10 @@ remoteDispatchDomainGetSchedulerParameters(virNetServer\
    \ *server G_GNUC_UNUSED,\n     if (!conn)\n         goto cleanup;\n \n+    if\
    \ (args->nparams < 0) {\n+        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\"\
    , _(\"nparams must be non-negative\"));\n+        goto cleanup;\n+    }\n    \
    \ if (args->nparams > REMOTE_DOMAIN_SCHEDULER_PARAMETERS_MAX) {\n         virReportError(VIR_ERR_INTERNAL_ERROR,\
    \ \"%s\", _(\"nparams too large\"));\n         goto cleanup;\n@@ -2339,6 +2343,10\
    \ @@ remoteDispatchDomainGetSchedulerParametersFlags(virNetServer *server G_GNUC_UNUS\n\
    \     if (!conn)\n         goto cleanup;\n \n+    if (args->nparams < 0) {\n+\
    \        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"nparams must be non-negative\"\
    ));\n+        goto cleanup;\n+    }\n     if (args->nparams > REMOTE_DOMAIN_SCHEDULER_PARAMETERS_MAX)\
    \ {\n         virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"nparams too large\"\
    ));\n         goto cleanup;\n@@ -2497,6 +2505,10 @@ remoteDispatchDomainBlockStatsFlags(virNetServer\
    \ *server G_GNUC_UNUSED,\n         goto cleanup;\n     flags = args->flags;\n\
    \ \n+    if (args->nparams < 0) {\n+        virReportError(VIR_ERR_INTERNAL_ERROR,\
    \ \"%s\", _(\"nparams must be non-negative\"));\n+        goto cleanup;\n+   \
    \ }\n     if (args->nparams > REMOTE_DOMAIN_BLOCK_STATS_PARAMETERS_MAX) {\n  \
    \       virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"nparams too large\"\
    ));\n         goto cleanup;\n@@ -2717,6 +2729,14 @@ remoteDispatchDomainGetVcpuPinInfo(virNetServer\
    \ *server G_GNUC_UNUSED,\n     if (!(dom = get_nonnull_domain(conn, args->dom)))\n\
    \         goto cleanup;\n \n+    if (args->ncpumaps < 0) {\n+        virReportError(VIR_ERR_INTERNAL_ERROR,\
    \ \"%s\", _(\"ncpumaps must be non-negative\"));\n+        goto cleanup;\n+  \
    \  }\n+    if (args->maplen < 0) {\n+        virReportError(VIR_ERR_INTERNAL_ERROR,\
    \ \"%s\", _(\"maplen must be non-negative\"));\n+        goto cleanup;\n+    }\n\
    \     if (args->ncpumaps > REMOTE_VCPUINFO_MAX) {\n         virReportError(VIR_ERR_INTERNAL_ERROR,\
    \ \"%s\", _(\"ncpumaps > REMOTE_VCPUINFO_MAX\"));\n         goto cleanup;\n@@\
    \ -2811,6 +2831,11 @@ remoteDispatchDomainGetEmulatorPinInfo(virNetServer *server\
    \ G_GNUC_UNUSED,\n     if (!(dom = get_nonnull_domain(conn, args->dom)))\n   \
    \      goto cleanup;\n \n+    if (args->maplen < 0) {\n+        virReportError(VIR_ERR_INTERNAL_ERROR,\
    \ \"%s\", _(\"maplen must be non-negative\"));\n+        goto cleanup;\n+    }\n\
    +\n     /* Allocate buffers to take the results */\n     if (args->maplen > 0)\n\
    \         cpumaps = g_new0(unsigned char, args->maplen);\n@@ -2858,6 +2883,14\
    \ @@ remoteDispatchDomainGetVcpus(virNetServer *server G_GNUC_UNUSED,\n     if\
    \ (!(dom = get_nonnull_domain(conn, args->dom)))\n         goto cleanup;\n \n\
    +    if (args->maxinfo < 0) {\n+        virReportError(VIR_ERR_INTERNAL_ERROR,\
    \ \"%s\", _(\"maxinfo must be non-negative\"));\n+        goto cleanup;\n+   \
    \ }\n+    if (args->maplen < 0) {\n+        virReportError(VIR_ERR_INTERNAL_ERROR,\
    \ \"%s\", _(\"maxinfo must be non-negative\"));\n+        goto cleanup;\n+   \
    \ }\n     if (args->maxinfo > REMOTE_VCPUINFO_MAX) {\n         virReportError(VIR_ERR_INTERNAL_ERROR,\
    \ \"%s\", _(\"maxinfo > REMOTE_VCPUINFO_MAX\"));\n         goto cleanup;\n@@ -3096,6\
    \ +3129,10 @@ remoteDispatchDomainGetMemoryParameters(virNetServer *server G_GNUC_UNUSED,\n\
    \ \n     flags = args->flags;\n \n+    if (args->nparams < 0) {\n+        virReportError(VIR_ERR_INTERNAL_ERROR,\
    \ \"%s\", _(\"nparams must be non-negative\"));\n+        goto cleanup;\n+   \
    \ }\n     if (args->nparams > REMOTE_DOMAIN_MEMORY_PARAMETERS_MAX) {\n       \
    \  virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"nparams too large\"));\n\
    \         goto cleanup;\n@@ -3156,6 +3193,10 @@ remoteDispatchDomainGetNumaParameters(virNetServer\
    \ *server G_GNUC_UNUSED,\n \n     flags = args->flags;\n \n+    if (args->nparams\
    \ < 0) {\n+        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"nparams\
    \ must be non-negative\"));\n+        goto cleanup;\n+    }\n     if (args->nparams\
    \ > REMOTE_DOMAIN_NUMA_PARAMETERS_MAX) {\n         virReportError(VIR_ERR_INTERNAL_ERROR,\
    \ \"%s\", _(\"nparams too large\"));\n         goto cleanup;\n@@ -3216,6 +3257,10\
    \ @@ remoteDispatchDomainGetBlkioParameters(virNetServer *server G_GNUC_UNUSED,\n\
    \ \n     flags = args->flags;\n \n+    if (args->nparams < 0) {\n+        virReportError(VIR_ERR_INTERNAL_ERROR,\
    \ \"%s\", _(\"nparams must be non-negative\"));\n+        goto cleanup;\n+   \
    \ }\n     if (args->nparams > REMOTE_DOMAIN_BLKIO_PARAMETERS_MAX) {\n        \
    \ virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"nparams too large\"));\n\
    \         goto cleanup;\n@@ -3277,6 +3322,10 @@ remoteDispatchNodeGetCPUStats(virNetServer\
    \ *server G_GNUC_UNUSED,\n \n     flags = args->flags;\n \n+    if (args->nparams\
    \ < 0) {\n+        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"nparams\
    \ must be non-negative\"));\n+        goto cleanup;\n+    }\n     if (args->nparams\
    \ > REMOTE_NODE_CPU_STATS_MAX) {\n         virReportError(VIR_ERR_INTERNAL_ERROR,\
    \ \"%s\", _(\"nparams too large\"));\n         goto cleanup;\n@@ -3339,6 +3388,10\
    \ @@ remoteDispatchNodeGetMemoryStats(virNetServer *server G_GNUC_UNUSED,\n \n\
    \     flags = args->flags;\n \n+    if (args->nparams < 0) {\n+        virReportError(VIR_ERR_INTERNAL_ERROR,\
    \ \"%s\", _(\"nparams must be non-negative\"));\n+        goto cleanup;\n+   \
    \ }\n     if (args->nparams > REMOTE_NODE_MEMORY_STATS_MAX) {\n         virReportError(VIR_ERR_INTERNAL_ERROR,\
    \ \"%s\", _(\"nparams too large\"));\n         goto cleanup;\n@@ -3514,6 +3567,10\
    \ @@ remoteDispatchDomainGetBlockIoTune(virNetServer *server G_GNUC_UNUSED,\n\
    \     if (!conn)\n         goto cleanup;\n \n+    if (args->nparams < 0) {\n+\
    \        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"nparams must be non-negative\"\
    ));\n+        goto cleanup;\n+    }\n     if (args->nparams > REMOTE_DOMAIN_BLOCK_IO_TUNE_PARAMETERS_MAX)\
    \ {\n         virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"nparams too large\"\
    ));\n         goto cleanup;\n@@ -5081,6 +5138,10 @@ remoteDispatchDomainGetInterfaceParameters(virNetServer\
    \ *server G_GNUC_UNUSED,\n \n     flags = args->flags;\n \n+    if (args->nparams\
    \ < 0) {\n+        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"nparams\
    \ must be non-negative\"));\n+        goto cleanup;\n+    }\n     if (args->nparams\
    \ > REMOTE_DOMAIN_INTERFACE_PARAMETERS_MAX) {\n         virReportError(VIR_ERR_INTERNAL_ERROR,\
    \ \"%s\", _(\"nparams too large\"));\n         goto cleanup;\n@@ -5301,6 +5362,10\
    \ @@ remoteDispatchNodeGetMemoryParameters(virNetServer *server G_GNUC_UNUSED,\n\
    \ \n     flags = args->flags;\n \n+    if (args->nparams < 0) {\n+        virReportError(VIR_ERR_INTERNAL_ERROR,\
    \ \"%s\", _(\"nparams must be non-negative\"));\n+        goto cleanup;\n+   \
    \ }\n     if (args->nparams > REMOTE_NODE_MEMORY_PARAMETERS_MAX) {\n         virReportError(VIR_ERR_INTERNAL_ERROR,\
    \ \"%s\", _(\"nparams too large\"));\n         goto cleanup;"
  identifiers: CVE:["CVE-2024-2494"],CWE:["CWE-789"]
  overview: Affected versions of this package are vulnerable to Uncontrolled Resource
    Consumption due to improper validation of user-supplied input leading to a negative
    `g_new0` length. An attacker can cause unbounded memory allocation by supplying
    a crafted input.
  references:
    GitHub Commit: https://github.com/libvirt/libvirt/commit/8a3f8d957507c1f8223fdcf25a3ff885b15557f2
    Patch: https://lists.libvirt.org/archives/list/devel@lists.libvirt.org/thread/BKRQXPLPC6B7FLHJXSBQYW7HNDEBW6RJ/
    RedHat Bugzilla Bug: https://bugzilla.redhat.com/show_bug.cgi?id=2270115
  title: Uncontrolled Resource Consumption
- diff_content:
  - "--- a/lib/nettle/int/dsa-compute-k.c\n+++ b/lib/nettle/int/dsa-compute-k.c\n\
    @@ -31,29 +31,37 @@\n #include \"mpn-base256.h\"\n #include <string.h>\n \n-#define\
    \ BITS_TO_LIMBS(bits) (((bits) + GMP_NUMB_BITS - 1) / GMP_NUMB_BITS)\n+/* For\
    \ mini-gmp */\n+#ifndef GMP_LIMB_BITS\n+#define GMP_LIMB_BITS GMP_NUMB_BITS\n\
    +#endif\n \n-/* The maximum size of q, chosen from the fact that we support\n\
    - * 521-bit elliptic curve generator and 512-bit DSA subgroup at\n- * maximum.\
    \ */\n-#define MAX_Q_BITS 521\n-#define MAX_Q_SIZE ((MAX_Q_BITS + 7) / 8)\n-#define\
    \ MAX_Q_LIMBS BITS_TO_LIMBS(MAX_Q_BITS)\n+static inline int is_zero_limb(mp_limb_t\
    \ x)\n+{\n+\tx |= (x << 1);\n+\treturn ((x >> 1) - 1) >> (GMP_LIMB_BITS - 1);\n\
    +}\n+\n+static int sec_zero_p(const mp_limb_t *ap, mp_size_t n)\n+{\n+\tvolatile\
    \ mp_limb_t w;\n+\tmp_size_t i;\n \n-#define MAX_HASH_BITS (MAX_HASH_SIZE * 8)\n\
    -#define MAX_HASH_LIMBS BITS_TO_LIMBS(MAX_HASH_BITS)\n+\tfor (i = 0, w = 0; i\
    \ < n; i++)\n+\t\tw |= ap[i];\n \n-int _gnutls_dsa_compute_k(mpz_t k, const mpz_t\
    \ q, const mpz_t x,\n+\treturn is_zero_limb(w);\n+}\n+\n+int _gnutls_dsa_compute_k(mp_limb_t\
    \ *h, const mp_limb_t *q, const mp_limb_t *x,\n+\t\t\t  mp_size_t qn, mp_bitcnt_t\
    \ q_bits,\n \t\t\t  gnutls_mac_algorithm_t mac, const uint8_t *digest,\n \t\t\t\
    \  size_t length)\n {\n \tuint8_t V[MAX_HASH_SIZE];\n \tuint8_t K[MAX_HASH_SIZE];\n\
    \ \tuint8_t xp[MAX_Q_SIZE];\n \tuint8_t tp[MAX_Q_SIZE];\n-\tmp_limb_t h[MAX(MAX_Q_LIMBS,\
    \ MAX_HASH_LIMBS)];\n-\tmp_bitcnt_t q_bits = mpz_sizeinbase(q, 2);\n-\tmp_size_t\
    \ qn = mpz_size(q);\n \tmp_bitcnt_t h_bits = length * 8;\n \tmp_size_t hn = BITS_TO_LIMBS(h_bits);\n\
    \ \tsize_t nbytes = (q_bits + 7) / 8;\n@@ -62,14 +70,15 @@ int _gnutls_dsa_compute_k(mpz_t\
    \ k, const mpz_t q, const mpz_t x,\n \tmp_limb_t cy;\n \tgnutls_hmac_hd_t hd;\n\
    \ \tint ret = 0;\n+\tmp_limb_t scratch[MAX_Q_LIMBS];\n \n \tif (unlikely(q_bits\
    \ > MAX_Q_BITS))\n \t\treturn gnutls_assert_val(GNUTLS_E_INVALID_REQUEST);\n \t\
    if (unlikely(length > MAX_HASH_SIZE))\n \t\treturn gnutls_assert_val(GNUTLS_E_INVALID_REQUEST);\n\
    \ \n \t/* int2octets(x) */\n-\tmpn_get_base256(xp, nbytes, mpz_limbs_read(x),\
    \ qn);\n+\tmpn_get_base256(xp, nbytes, x, qn);\n \n \t/* bits2octets(h) */\n \t\
    mpn_set_base256(h, hn, digest, length);\n@@ -93,12 +102,12 @@ int _gnutls_dsa_compute_k(mpz_t\
    \ k, const mpz_t q, const mpz_t x,\n \t\t\tmpn_rshift(h, h, hn, shift % GMP_NUMB_BITS);\n\
    \ \t}\n \n-\tcy = mpn_sub_n(h, h, mpz_limbs_read(q), qn);\n+\tcy = mpn_sub_n(h,\
    \ h, q, qn);\n \t/* Fall back to addmul_1, if nettle is linked with mini-gmp.\
    \ */\n #ifdef mpn_cnd_add_n\n-\tmpn_cnd_add_n(cy, h, h, mpz_limbs_read(q), qn);\n\
    +\tmpn_cnd_add_n(cy, h, h, q, qn);\n #else\n-\tmpn_addmul_1(h, mpz_limbs_read(q),\
    \ qn, cy != 0);\n+\tmpn_addmul_1(h, q, qn, cy != 0);\n #endif\n \tmpn_get_base256(tp,\
    \ nbytes, h, qn);\n \n@@ -174,12 +183,8 @@ int _gnutls_dsa_compute_k(mpz_t k,\
    \ const mpz_t q, const mpz_t x,\n \t\tif (tlen * 8 > q_bits)\n \t\t\tmpn_rshift(h,\
    \ h, qn, tlen * 8 - q_bits);\n \t\t/* Check if k is in [1,q-1] */\n-\t\tif (!mpn_zero_p(h,\
    \ qn) &&\n-\t\t    mpn_cmp(h, mpz_limbs_read(q), qn) < 0) {\n-\t\t\tmpn_copyi(mpz_limbs_write(k,\
    \ qn), h, qn);\n-\t\t\tmpz_limbs_finish(k, qn);\n+\t\tif (!sec_zero_p(h, qn) &&\
    \ mpn_sub_n(scratch, h, q, qn))\n \t\t\tbreak;\n-\t\t}\n \n \t\tret = gnutls_hmac_init(&hd,\
    \ mac, K, length);\n \t\tif (ret < 0)\n@@ -203,3 +208,24 @@ int _gnutls_dsa_compute_k(mpz_t\
    \ k, const mpz_t q, const mpz_t x,\n \n \treturn ret;\n }\n+\n+/* cancel-out dsa_sign's\
    \ addition of 1 to random data */\n+void _gnutls_dsa_compute_k_finish(uint8_t\
    \ *k, size_t nbytes, mp_limb_t *h,\n+\t\t\t\t  mp_size_t n)\n+{\n+\t/* Fall back\
    \ to sub_1, if nettle is linked with mini-gmp. */\n+#ifdef mpn_sec_sub_1\n+\t\
    mp_limb_t t[MAX_Q_LIMBS];\n+\n+\tmpn_sec_sub_1(h, h, n, 1, t);\n+#else\n+\tmpn_sub_1(h,\
    \ h, n, 1);\n+#endif\n+\tmpn_get_base256(k, nbytes, h, n);\n+}\n+\n+void _gnutls_ecdsa_compute_k_finish(uint8_t\
    \ *k, size_t nbytes, mp_limb_t *h,\n+\t\t\t\t    mp_size_t n)\n+{\n+\tmpn_get_base256(k,\
    \ nbytes, h, n);\n+}"
  - "--- a/lib/nettle/int/ecdsa-compute-k.c\n+++ b/lib/nettle/int/ecdsa-compute-k.c\n\
    @@ -29,38 +29,38 @@\n #include \"dsa-compute-k.h\"\n #include \"gnutls_int.h\"\
    \n \n-static inline int _gnutls_ecc_curve_to_dsa_q(mpz_t *q, gnutls_ecc_curve_t\
    \ curve)\n+int _gnutls_ecc_curve_to_dsa_q(mpz_t q, gnutls_ecc_curve_t curve)\n\
    \ {\n \tswitch (curve) {\n #ifdef ENABLE_NON_SUITEB_CURVES\n \tcase GNUTLS_ECC_CURVE_SECP192R1:\n\
    -\t\tmpz_init_set_str(*q,\n+\t\tmpz_init_set_str(q,\n \t\t\t\t \"FFFFFFFFFFFFFFFFFFFFFFFF99DEF836\"\
    \n \t\t\t\t \"146BC9B1B4D22831\",\n \t\t\t\t 16);\n \t\treturn 0;\n \tcase GNUTLS_ECC_CURVE_SECP224R1:\n\
    -\t\tmpz_init_set_str(*q,\n+\t\tmpz_init_set_str(q,\n \t\t\t\t \"FFFFFFFFFFFFFFFFFFFFFFFFFFFF16A2\"\
    \n \t\t\t\t \"E0B8F03E13DD29455C5C2A3D\",\n \t\t\t\t 16);\n \t\treturn 0;\n #endif\n\
    \ \tcase GNUTLS_ECC_CURVE_SECP256R1:\n-\t\tmpz_init_set_str(*q,\n+\t\tmpz_init_set_str(q,\n\
    \ \t\t\t\t \"FFFFFFFF00000000FFFFFFFFFFFFFFFF\"\n \t\t\t\t \"BCE6FAADA7179E84F3B9CAC2FC632551\"\
    ,\n \t\t\t\t 16);\n \t\treturn 0;\n \tcase GNUTLS_ECC_CURVE_SECP384R1:\n-\t\t\
    mpz_init_set_str(*q,\n+\t\tmpz_init_set_str(q,\n \t\t\t\t \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\"\
    \n \t\t\t\t \"FFFFFFFFFFFFFFFFC7634D81F4372DDF\"\n \t\t\t\t \"581A0DB248B0A77AECEC196ACCC52973\"\
    ,\n \t\t\t\t 16);\n \t\treturn 0;\n \tcase GNUTLS_ECC_CURVE_SECP521R1:\n-\t\t\
    mpz_init_set_str(*q,\n+\t\tmpz_init_set_str(q,\n \t\t\t\t \"1FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\"\
    \n \t\t\t\t \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\"\n \t\t\t\t \"FFA51868783BF2F966B7FCC0148F709A\"\
    \n@@ -73,19 +73,3 @@ static inline int _gnutls_ecc_curve_to_dsa_q(mpz_t *q, gnutls_ecc_curve_t\
    \ curve)\n \t\t\tGNUTLS_E_UNSUPPORTED_SIGNATURE_ALGORITHM);\n \t}\n }\n-\n-int\
    \ _gnutls_ecdsa_compute_k(mpz_t k, gnutls_ecc_curve_t curve, const mpz_t x,\n\
    -\t\t\t    gnutls_mac_algorithm_t mac, const uint8_t *digest,\n-\t\t\t    size_t\
    \ length)\n-{\n-\tmpz_t q;\n-\tint ret;\n-\n-\tret = _gnutls_ecc_curve_to_dsa_q(&q,\
    \ curve);\n-\tif (ret < 0)\n-\t\treturn gnutls_assert_val(ret);\n-\n-\tret = _gnutls_dsa_compute_k(k,\
    \ q, x, mac, digest, length);\n-\tmpz_clear(q);\n-\treturn ret;\n-}"
  - "--- a/lib/nettle/pk.c\n+++ b/lib/nettle/pk.c\n@@ -103,10 +103,16 @@ static void\
    \ rnd_nonce_func(void *_ctx, size_t length, uint8_t *data)\n \t}\n }\n \n-static\
    \ void rnd_mpz_func(void *_ctx, size_t length, uint8_t *data)\n+static void rnd_datum_func(void\
    \ *ctx, size_t length, uint8_t *data)\n {\n-\tmpz_t *k = _ctx;\n-\tnettle_mpz_get_str_256(length,\
    \ data, *k);\n+\tgnutls_datum_t *d = ctx;\n+\n+\tif (length > d->size) {\n+\t\t\
    memset(data, 0, length - d->size);\n+\t\tmemcpy(data + (length - d->size), d->data,\
    \ d->size);\n+\t} else {\n+\t\tmemcpy(data, d->data, length);\n+\t}\n }\n \n static\
    \ void rnd_nonce_func_fallback(void *_ctx, size_t length, uint8_t *data)\n@@ -1403,7\
    \ +1409,10 @@ static int _wrap_nettle_pk_sign(gnutls_pk_algorithm_t algo,\n \t\
    \tstruct dsa_signature sig;\n \t\tint curve_id = pk_params->curve;\n \t\tconst\
    \ struct ecc_curve *curve;\n-\t\tmpz_t k;\n+\t\tmpz_t q;\n+\t\t/* 521-bit elliptic\
    \ curve generator at maximum */\n+\t\tuint8_t buf[(521 + 7) / 8];\n+\t\tgnutls_datum_t\
    \ k = { NULL, 0 };\n \t\tvoid *random_ctx;\n \t\tnettle_random_func *random_func;\n\
    \ \n@@ -1447,17 +1456,32 @@ static int _wrap_nettle_pk_sign(gnutls_pk_algorithm_t\
    \ algo,\n \t\t\tnot_approved = true;\n \t\t}\n \n-\t\tmpz_init(k);\n+\t\tmpz_init(q);\n\
    +\n \t\tif (_gnutls_get_lib_state() == LIB_STATE_SELFTEST ||\n \t\t    (sign_params->flags\
    \ & GNUTLS_PK_FLAG_REPRODUCIBLE)) {\n-\t\t\tret = _gnutls_ecdsa_compute_k(\n-\t\
    \t\t\tk, curve_id, pk_params->params[ECC_K],\n+\t\t\tmp_limb_t h[DSA_COMPUTE_K_ITCH];\n\
    +\n+\t\t\tret = _gnutls_ecc_curve_to_dsa_q(q, curve_id);\n+\t\t\tif (ret < 0)\n\
    +\t\t\t\tgoto ecdsa_cleanup;\n+\n+\t\t\tret = _gnutls_dsa_compute_k(\n+\t\t\t\t\
    h, mpz_limbs_read(q), priv.p,\n+\t\t\t\tecc_size(priv.ecc), ecc_bit_size(priv.ecc),\n\
    \ \t\t\t\tDIG_TO_MAC(sign_params->dsa_dig), vdata->data,\n \t\t\t\tvdata->size);\n\
    \ \t\t\tif (ret < 0)\n \t\t\t\tgoto ecdsa_cleanup;\n+\n+\t\t\tk.data = buf;\n\
    +\t\t\tk.size = (ecc_bit_size(priv.ecc) + 7) / 8;\n+\n+\t\t\t_gnutls_ecdsa_compute_k_finish(k.data,\
    \ k.size, h,\n+\t\t\t\t\t\t       ecc_size(priv.ecc));\n+\n \t\t\trandom_ctx =\
    \ &k;\n-\t\t\trandom_func = rnd_mpz_func;\n+\t\t\trandom_func = rnd_datum_func;\n\
    \ \t\t} else {\n \t\t\trandom_ctx = NULL;\n \t\t\trandom_func = rnd_nonce_func;\n\
    @@ -1476,7 +1500,7 @@ static int _wrap_nettle_pk_sign(gnutls_pk_algorithm_t algo,\n\
    \ \tecdsa_cleanup:\n \t\tdsa_signature_clear(&sig);\n \t\tecc_scalar_zclear(&priv);\n\
    -\t\tmpz_clear(k);\n+\t\tmpz_clear(q);\n \n \t\tif (ret < 0) {\n \t\t\tgnutls_assert();\n\
    @@ -1488,7 +1512,9 @@ static int _wrap_nettle_pk_sign(gnutls_pk_algorithm_t algo,\n\
    \ \t\tstruct dsa_params pub;\n \t\tbigint_t priv;\n \t\tstruct dsa_signature sig;\n\
    -\t\tmpz_t k;\n+\t\t/* 512-bit DSA subgroup at maximum */\n+\t\tuint8_t buf[(512\
    \ + 7) / 8];\n+\t\tgnutls_datum_t k = { NULL, 0 };\n \t\tvoid *random_ctx;\n \t\
    \tnettle_random_func *random_func;\n \n@@ -1515,19 +1541,27 @@ static int _wrap_nettle_pk_sign(gnutls_pk_algorithm_t\
    \ algo,\n \t\t\thash_len = vdata->size;\n \t\t}\n \n-\t\tmpz_init(k);\n \t\tif\
    \ (_gnutls_get_lib_state() == LIB_STATE_SELFTEST ||\n \t\t    (sign_params->flags\
    \ & GNUTLS_PK_FLAG_REPRODUCIBLE)) {\n+\t\t\tmp_limb_t h[DSA_COMPUTE_K_ITCH];\n\
    +\n \t\t\tret = _gnutls_dsa_compute_k(\n-\t\t\t\tk, pub.q, TOMPZ(priv),\n+\t\t\
    \t\th, mpz_limbs_read(pub.q),\n+\t\t\t\tmpz_limbs_read(TOMPZ(priv)), mpz_size(pub.q),\n\
    +\t\t\t\tmpz_sizeinbase(pub.q, 2),\n \t\t\t\tDIG_TO_MAC(sign_params->dsa_dig),\
    \ vdata->data,\n \t\t\t\tvdata->size);\n \t\t\tif (ret < 0)\n \t\t\t\tgoto dsa_fail;\n\
    -\t\t\t/* cancel-out dsa_sign's addition of 1 to random data */\n-\t\t\tmpz_sub_ui(k,\
    \ k, 1);\n+\n+\t\t\tk.data = buf;\n+\t\t\tk.size = (mpz_sizeinbase(pub.q, 2) +\
    \ 7) / 8;\n+\n+\t\t\t_gnutls_dsa_compute_k_finish(k.data, k.size, h,\n+\t\t\t\t\
    \t\t     mpz_size(pub.q));\n+\n \t\t\trandom_ctx = &k;\n-\t\t\trandom_func = rnd_mpz_func;\n\
    +\t\t\trandom_func = rnd_datum_func;\n \t\t} else {\n \t\t\trandom_ctx = NULL;\n\
    \ \t\t\trandom_func = rnd_nonce_func;\n@@ -1544,7 +1578,6 @@ static int _wrap_nettle_pk_sign(gnutls_pk_algorithm_t\
    \ algo,\n \n \tdsa_fail:\n \t\tdsa_signature_clear(&sig);\n-\t\tmpz_clear(k);\n\
    \ \n \t\tif (ret < 0) {\n \t\t\tgnutls_assert();"
  - "--- a/lib/x509/common.c\n+++ b/lib/x509/common.c\n@@ -1725,7 +1725,15 @@ unsigned\
    \ int _gnutls_sort_clist(gnutls_x509_crt_t *clist,\n \tbool insorted[DEFAULT_MAX_VERIFY_DEPTH];\
    \ /* non zero if clist[i] used in sorted list */\n \tgnutls_x509_crt_t sorted[DEFAULT_MAX_VERIFY_DEPTH];\n\
    \ \n-\tassert(clist_size <= DEFAULT_MAX_VERIFY_DEPTH);\n+\t/* Limit the number\
    \ of certificates in the chain, to avoid DoS\n+\t * because of the O(n^2) sorting\
    \ below.  FIXME: Switch to a\n+\t * topological sort algorithm which should be\
    \ linear to the\n+\t * number of certificates and subject-issuer relationships.\n\
    +\t */\n+\tif (clist_size > DEFAULT_MAX_VERIFY_DEPTH) {\n+\t\t_gnutls_debug_log(\"\
    too many certificates; skipping sorting\\n\");\n+\t\treturn 1;\n+\t}\n \n \tfor\
    \ (i = 0; i < DEFAULT_MAX_VERIFY_DEPTH; i++) {\n \t\tissuer[i] = -1;"
  - "--- a/lib/x509/verify-high.c\n+++ b/lib/x509/verify-high.c\n@@ -25,7 +25,7 @@\n\
    \ #include \"errors.h\"\n #include <libtasn1.h>\n #include \"global.h\"\n-#include\
    \ \"num.h\" /* MAX */\n+#include \"num.h\" /* MIN */\n #include \"tls-sig.h\"\n\
    \ #include \"str.h\"\n #include \"datum.h\"\n@@ -1361,7 +1361,8 @@ int gnutls_x509_trust_list_verify_crt2(\n\
    \ \tint ret = 0;\n \tunsigned int i;\n \tsize_t hash;\n-\tgnutls_x509_crt_t sorted[DEFAULT_MAX_VERIFY_DEPTH];\n\
    +\tgnutls_x509_crt_t *cert_list_copy = NULL;\n+\tunsigned int cert_list_max_size\
    \ = 0;\n \tgnutls_x509_crt_t retrieved[DEFAULT_MAX_VERIFY_DEPTH];\n \tunsigned\
    \ int retrieved_size = 0;\n \tconst char *hostname = NULL, *purpose = NULL, *email\
    \ = NULL;\n@@ -1421,16 +1422,28 @@ int gnutls_x509_trust_list_verify_crt2(\n \t\
    \t}\n \t}\n \n-\tmemcpy(sorted, cert_list, cert_list_size * sizeof(gnutls_x509_crt_t));\n\
    -\tcert_list = sorted;\n+\t/* Allocate extra for retrieved certificates. */\n\
    +\tif (!INT_ADD_OK(cert_list_size, DEFAULT_MAX_VERIFY_DEPTH,\n+\t\t\t&cert_list_max_size))\n\
    +\t\treturn gnutls_assert_val(GNUTLS_E_INVALID_REQUEST);\n+\n+\tcert_list_copy\
    \ = _gnutls_reallocarray(NULL, cert_list_max_size,\n+\t\t\t\t\t      sizeof(gnutls_x509_crt_t));\n\
    +\tif (!cert_list_copy)\n+\t\treturn gnutls_assert_val(GNUTLS_E_MEMORY_ERROR);\n\
    +\n+\tmemcpy(cert_list_copy, cert_list,\n+\t       cert_list_size * sizeof(gnutls_x509_crt_t));\n\
    +\tcert_list = cert_list_copy;\n \n \trecords = gl_list_nx_create_empty(GL_LINKEDHASH_LIST,\
    \ cert_eq,\n \t\t\t\t\t  cert_hashcode, NULL, false);\n-\tif (records == NULL)\n\
    -\t\treturn gnutls_assert_val(GNUTLS_E_MEMORY_ERROR);\n+\tif (records == NULL)\
    \ {\n+\t\tret = gnutls_assert_val(GNUTLS_E_MEMORY_ERROR);\n+\t\tgoto cleanup;\n\
    +\t}\n \n-\tfor (i = 0; i < cert_list_size &&\n-\t\t    cert_list_size <= DEFAULT_MAX_VERIFY_DEPTH;)\
    \ {\n+\tfor (i = 0; i < cert_list_size;) {\n \t\tunsigned int sorted_size = 1;\n\
    \ \t\tunsigned int j, k;\n \t\tgnutls_x509_crt_t issuer;\n@@ -1442,8 +1455,7 @@\
    \ int gnutls_x509_trust_list_verify_crt2(\n \n \t\tassert(sorted_size > 0);\n\
    \ \n-\t\t/* Remove duplicates. Start with index 1, as the first element\n-\t\t\
    \ * may be re-checked after issuer retrieval. */\n+\t\t/* Remove duplicates. */\n\
    \ \t\tfor (j = 0; j < sorted_size; j++) {\n \t\t\tif (gl_list_search(records,\
    \ cert_list[i + j])) {\n \t\t\t\tif (i + j < cert_list_size - 1) {\n@@ -1495,13\
    \ +1507,15 @@ int gnutls_x509_trust_list_verify_crt2(\n \n \t\tret = retrieve_issuers(\n\
    \ \t\t\tlist, cert_list[i - 1], &retrieved[retrieved_size],\n-\t\t\tDEFAULT_MAX_VERIFY_DEPTH\
    \ -\n-\t\t\t\tMAX(retrieved_size, cert_list_size));\n+\t\t\tMIN(DEFAULT_MAX_VERIFY_DEPTH\
    \ - retrieved_size,\n+\t\t\t    cert_list_max_size - cert_list_size));\n \t\t\
    if (ret < 0) {\n \t\t\tbreak;\n \t\t} else if (ret > 0) {\n \t\t\tassert((unsigned\
    \ int)ret <=\n-\t\t\t       DEFAULT_MAX_VERIFY_DEPTH - cert_list_size);\n+\t\t\
    \t       DEFAULT_MAX_VERIFY_DEPTH - retrieved_size);\n+\t\t\tassert((unsigned\
    \ int)ret <=\n+\t\t\t       cert_list_max_size - cert_list_size);\n \t\t\tmemmove(&cert_list[i\
    \ + ret], &cert_list[i],\n \t\t\t\t(cert_list_size - i) *\n \t\t\t\t\tsizeof(gnutls_x509_crt_t));\n\
    @@ -1517,8 +1531,10 @@ int gnutls_x509_trust_list_verify_crt2(\n \t}\n \n \tcert_list_size\
    \ = shorten_clist(list, cert_list, cert_list_size);\n-\tif (cert_list_size <=\
    \ 0)\n-\t\treturn gnutls_assert_val(GNUTLS_E_INTERNAL_ERROR);\n+\tif (cert_list_size\
    \ <= 0) {\n+\t\tret = gnutls_assert_val(GNUTLS_E_INTERNAL_ERROR);\n+\t\tgoto cleanup;\n\
    +\t}\n \n \thash = hash_pjw_bare(cert_list[cert_list_size - 1]->raw_issuer_dn.data,\n\
    \ \t\t\t     cert_list[cert_list_size - 1]->raw_issuer_dn.size);\n@@ -1661,10\
    \ +1677,13 @@ int gnutls_x509_trust_list_verify_crt2(\n \t}\n \n cleanup:\n+\t\
    gnutls_free(cert_list_copy);\n \tfor (i = 0; i < retrieved_size; i++) {\n \t\t\
    gnutls_x509_crt_deinit(retrieved[i]);\n \t}\n-\tgl_list_free(records);\n+\tif\
    \ (records) {\n+\t\tgl_list_free(records);\n+\t}\n \treturn ret;\n }\n "
  - "--- a/tests/sign-verify-deterministic.c\n+++ b/tests/sign-verify-deterministic.c\n\
    @@ -198,7 +198,7 @@ void doit(void)\n \t\t\t\t\t\t &tests[i].msg, &signature);\n\
    \ \t\tif (ret < 0)\n \t\t\ttestfail(\"gnutls_pubkey_verify_data2\\n\");\n-\t\t\
    success(\" - pass\");\n+\t\tsuccess(\" - pass\\n\");\n \n \tnext:\n \t\tgnutls_free(signature.data);"
  identifiers: CVE:["CVE-2024-28834"],CWE:["CWE-200"]
  overview: Affected versions of this package are vulnerable to Information Exposure
    due to the use of the `GNUTLS_PRIVKEY_FLAG_REPRODUCIBLE` flag. An attacker can
    exploit deterministic behavior in cryptographic operations to observe a noticeable
    step in nonce size from 513 to 512 bits, leading to potential timing side-channel
    information leaks.
  references:
    Advisory: https://lists.gnupg.org/pipermail/gnutls-help/2024-March/004845.html
    GitHub Commit: https://github.com/gnutls/gnutls/commit/4a4cefef6c194f8fbbffd7fb19651219421b085b
    RedHat Bugzilla Bug: https://bugzilla.redhat.com/show_bug.cgi?id=2269228
  title: Information Exposure
- diff_content:
  - "--- a/xen/drivers/passthrough/pci.c\n+++ b/xen/drivers/passthrough/pci.c\n@@\
    \ -1488,11 +1488,10 @@ static int assign_device(struct domain *d, u16 seg, u8\
    \ bus, u8 devfn, u32 flag)\n \n     pdev->fault.count = 0;\n \n-    if ( (rc =\
    \ iommu_call(hd->platform_ops, assign_device, d, devfn,\n-                   \
    \       pci_to_dev(pdev), flag)) )\n-        goto done;\n+    rc = iommu_call(hd->platform_ops,\
    \ assign_device, d, devfn, pci_to_dev(pdev),\n+                    flag);\n \n\
    -    for ( ; pdev->phantom_stride; rc = 0 )\n+    while ( pdev->phantom_stride\
    \ && !rc )\n     {\n         devfn += pdev->phantom_stride;\n         if ( PCI_SLOT(devfn)\
    \ != PCI_SLOT(pdev->devfn) )\n@@ -1503,8 +1502,24 @@ static int assign_device(struct\
    \ domain *d, u16 seg, u8 bus, u8 devfn, u32 flag)\n \n  done:\n     if ( rc )\n\
    -        printk(XENLOG_G_WARNING \"%pd: assign (%pp) failed (%d)\\n\",\n-    \
    \           d, &PCI_SBDF(seg, bus, devfn), rc);\n+    {\n+        printk(XENLOG_G_WARNING\
    \ \"%pd: assign %s(%pp) failed (%d)\\n\",\n+               d, devfn != pdev->devfn\
    \ ? \"phantom function \" : \"\",\n+               &PCI_SBDF(seg, bus, devfn),\
    \ rc);\n+\n+        if ( devfn != pdev->devfn && deassign_device(d, seg, bus,\
    \ pdev->devfn) )\n+        {\n+            /*\n+             * Device with phantom\
    \ functions that failed to both assign and\n+             * rollback.  Mark the\
    \ device as broken and crash the target domain,\n+             * as the state\
    \ of the functions at this point is unknown and Xen\n+             * has no way\
    \ to assert consistent context assignment among them.\n+             */\n+   \
    \         pdev->broken = true;\n+            if ( !is_hardware_domain(d) && d\
    \ != dom_io )\n+                domain_crash(d);\n+        }\n+    }\n     /*\
    \ The device is assigned to dom_io so mark it as quarantined */\n     else if\
    \ ( d == dom_io )\n         pdev->quarantine = true;"
  identifiers: CVE:["CVE-2023-46839"],CWE:["CWE-284"]
  overview: Affected versions of this package are vulnerable to Improper Access Control
    due to the assignment of phantom functions to incorrect contexts. An attacker
    can gain unauthorized access to sensitive information by exploiting the misassignment.
  references:
    Advisory: https://xenbits.xenproject.org/xsa/advisory-449.html
    GitHub Commit: https://github.com/xen-project/xen/commit/cb4ecb3cc17b02c2814bc817efd05f3f3ba33d1e
    RedHat Bugzilla Bug: https://bugzilla.redhat.com/show_bug.cgi?id=2270533
  title: Improper Access Control
- diff_content:
  - "--- a/src/mms/iso_mms/server/mms_file_service.c\n+++ b/src/mms/iso_mms/server/mms_file_service.c\n\
    @@ -871,11 +871,19 @@ mmsServer_handleFileCloseRequest(\n \n     MmsFileReadStateMachine*\
    \ frsm = getFrsm(connection, frsmId);\n \n-    FileSystem_closeFile(frsm->fileHandle);\n\
    -    frsm->fileHandle = NULL;\n-    frsm->frsmId = 0;\n+    if (frsm) {\n+   \
    \     FileSystem_closeFile(frsm->fileHandle);\n+        frsm->fileHandle = NULL;\n\
    +        frsm->frsmId = 0;\n \n-    mmsMsg_createFileCloseResponse(invokeId, response);\n\
    +        mmsMsg_createFileCloseResponse(invokeId, response);\n+    }\n+    else\
    \ {\n+        if (DEBUG_MMS_SERVER)\n+            printf(\"MMS_SERVER: Unused\
    \ file ID %i\\n\", frsmId);\n+\n+        mmsMsg_createServiceErrorPdu(invokeId,\
    \ response, MMS_ERROR_FILE_OTHER);\n+    }\n }\n \n "
  identifiers: CVE:["CVE-2024-28286"],CWE:["CWE-476"]
  overview: Affected versions of this package are vulnerable to NULL Pointer Dereference
    in the `mmsServer_handleFileCloseRequest()` function in `src/mms/iso_mms/server/mms_file_service.c`.
    An attacker can cause a segmentation fault and crash.
  references:
    GitHub Commit: https://github.com/mz-automation/libiec61850/commit/cee97f7676ee4b6b87cc5e2cddc7971d12cf1ee7
    GitHub Issue: https://github.com/mz-automation/libiec61850/issues/496
  title: NULL Pointer Dereference
- diff_content:
  - "--- a/src/cpp/rtps/messages/MessageReceiver.cpp\n+++ b/src/cpp/rtps/messages/MessageReceiver.cpp\n\
    @@ -843,8 +843,20 @@ bool MessageReceiver::proc_Submsg_Data(\n     if (dataFlag\
    \ || keyFlag)\n     {\n         uint32_t payload_size;\n-        payload_size\
    \ = smh->submessageLength -\n-                (RTPSMESSAGE_DATA_EXTRA_INLINEQOS_SIZE\
    \ + octetsToInlineQos + inlineQosSize);\n+        const uint32_t submsg_no_payload_size\
    \ =\n+                RTPSMESSAGE_DATA_EXTRA_INLINEQOS_SIZE + octetsToInlineQos\
    \ + inlineQosSize;\n+\n+        // Prevent integer overflow of variable payload_size\n\
    +        if (smh->submessageLength < submsg_no_payload_size)\n+        {\n+  \
    \          EPROSIMA_LOG_WARNING(RTPS_MSG_IN, IDSTRING \"Serialized Payload avoided\
    \ overflow \"\n+                    \"(\" << smh->submessageLength << \"/\" <<\
    \ submsg_no_payload_size << \")\");\n+            ch.serializedPayload.data =\
    \ nullptr;\n+            ch.inline_qos.data = nullptr;\n+            return false;\n\
    +        }\n+\n+        payload_size = smh->submessageLength - submsg_no_payload_size;\n\
    \ \n         if (dataFlag)\n         {"
  - "--- a/test/blackbox/common/BlackboxTestsSecurity.cpp\n+++ b/test/blackbox/common/BlackboxTestsSecurity.cpp\n\
    @@ -27,6 +27,7 @@\n #include \"PubSubWriter.hpp\"\n #include \"PubSubWriterReader.hpp\"\
    \n #include \"PubSubParticipant.hpp\"\n+#include \"UDPMessageSender.hpp\"\n \n\
    \ #include <fastdds/dds/log/Log.hpp>\n #include <fastdds/rtps/common/EntityId_t.hpp>\n\
    @@ -89,32 +90,6 @@ class Security : public testing::TestWithParam<communication_type>\n\
    \ \n };\n \n-struct UDPMessageSender\n-{\n-    asio::io_service service;\n-  \
    \  asio::ip::udp::socket socket;\n-\n-    UDPMessageSender()\n-        : service()\n\
    -        , socket(service)\n-    {\n-        socket.open(asio::ip::udp::v4());\n\
    -    }\n-\n-    void send(\n-            const CDRMessage_t& msg,\n-         \
    \   const Locator_t& destination)\n-    {\n-        std::string addr = IPLocator::toIPv4string(destination);\n\
    -        unsigned short port = static_cast<unsigned short>(destination.port);\n\
    -        auto remote = asio::ip::udp::endpoint(asio::ip::address::from_string(addr),\
    \ port);\n-        asio::error_code ec;\n-\n-        socket.send_to(asio::buffer(msg.buffer,\
    \ msg.length), remote, 0, ec);\n-    }\n-\n-};\n-\n class SecurityPkcs : public\
    \ ::testing::Test\n {\n public:"
  - "--- a/test/blackbox/common/BlackboxTestsTransportUDP.cpp\n+++ b/test/blackbox/common/BlackboxTestsTransportUDP.cpp\n\
    @@ -29,6 +29,7 @@\n #include \"DatagramInjectionTransport.hpp\"\n #include \"\
    PubSubReader.hpp\"\n #include \"PubSubWriter.hpp\"\n+#include \"UDPMessageSender.hpp\"\
    \n \n using namespace eprosima::fastrtps;\n using namespace eprosima::fastrtps::rtps;\n\
    @@ -555,6 +556,104 @@ TEST(TransportUDP, DatagramInjection)\n     deliver_datagram_from_file(receivers,\
    \ \"datagrams/20140.bin\");\n }\n \n+TEST(TransportUDP, MaliciousManipulatedDataOctetsToNextHeaderIgnore)\n\
    +{\n+    // Force using UDP transport\n+    auto udp_transport = std::make_shared<UDPv4TransportDescriptor>();\n\
    +\n+    PubSubWriter<UnboundedHelloWorldPubSubType> writer(TEST_TOPIC_NAME);\n\
    +    PubSubReader<UnboundedHelloWorldPubSubType> reader(TEST_TOPIC_NAME);\n+\n\
    +    struct MaliciousManipulatedDataOctetsToNextHeader\n+    {\n+        std::array<char,\
    \ 4> rtps_id{ {'R', 'T', 'P', 'S'} };\n+        std::array<uint8_t, 2> protocol_version{\
    \ {2, 3} };\n+        std::array<uint8_t, 2> vendor_id{ {0x01, 0x0F} };\n+   \
    \     GuidPrefix_t sender_prefix{};\n+\n+        struct DataSubMsg\n+        {\n\
    +            struct Header\n+            {\n+                uint8_t submessage_id\
    \ = 0x15;\n+#if FASTDDS_IS_BIG_ENDIAN_TARGET\n+                uint8_t flags =\
    \ 0x04;\n+#else\n+                uint8_t flags = 0x05;\n+#endif  // FASTDDS_IS_BIG_ENDIAN_TARGET\n\
    +                uint16_t octets_to_next_header = 0x30;\n+                uint16_t\
    \ extra_flags = 0;\n+                uint16_t octets_to_inline_qos = 0x2d;\n+\
    \                EntityId_t reader_id{};\n+                EntityId_t writer_id{};\n\
    +                SequenceNumber_t sn{100};\n+            };\n+\n+            struct\
    \ SerializedData\n+            {\n+                uint16_t encapsulation;\n+\
    \                uint16_t encapsulation_opts;\n+                octet data[24];\n\
    +            };\n+\n+            Header header;\n+            SerializedData payload;\n\
    +        }\n+        data;\n+\n+        uint8_t additional_bytes[8] {0xFF, 0xFF,\
    \ 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF};\n+\n+    };\n+\n+    UDPMessageSender fake_msg_sender;\n\
    +\n+    // Set common QoS\n+    reader.disable_builtin_transport().add_user_transport_to_pparams(udp_transport)\n\
    +            .history_depth(10).reliability(eprosima::fastrtps::RELIABLE_RELIABILITY_QOS);\n\
    +    writer.history_depth(10).reliability(eprosima::fastrtps::RELIABLE_RELIABILITY_QOS);\n\
    +\n+    // Set custom reader locator so we can send malicious data to a known\
    \ location\n+    Locator_t reader_locator;\n+    ASSERT_TRUE(IPLocator::setIPv4(reader_locator,\
    \ \"127.0.0.1\"));\n+    reader_locator.port = 7000;\n+    reader.add_to_unicast_locator_list(\"\
    127.0.0.1\", 7000);\n+\n+    // Initialize and wait for discovery\n+    reader.init();\n\
    +    ASSERT_TRUE(reader.isInitialized());\n+    writer.init();\n+    ASSERT_TRUE(writer.isInitialized());\n\
    +\n+    reader.wait_discovery();\n+    writer.wait_discovery();\n+\n+    auto\
    \ data = default_unbounded_helloworld_data_generator();\n+    reader.startReception(data);\n\
    +    writer.send(data);\n+    ASSERT_TRUE(data.empty());\n+\n+    // Send malicious\
    \ data\n+    {\n+        auto writer_guid = writer.datawriter_guid();\n+\n+  \
    \      MaliciousManipulatedDataOctetsToNextHeader malicious_packet{};\n+     \
    \   malicious_packet.sender_prefix = writer_guid.guidPrefix;\n+        malicious_packet.data.header.writer_id\
    \ = writer_guid.entityId;\n+        malicious_packet.data.header.reader_id = reader.datareader_guid().entityId;\n\
    +        malicious_packet.data.payload.encapsulation = CDR_LE;\n+\n+        CDRMessage_t\
    \ msg(0);\n+        uint32_t msg_len = static_cast<uint32_t>(sizeof(malicious_packet));\n\
    +        msg.init(reinterpret_cast<octet*>(&malicious_packet), msg_len);\n+  \
    \      msg.length = msg_len;\n+        msg.pos = msg_len;\n+        fake_msg_sender.send(msg,\
    \ reader_locator);\n+    }\n+\n+    // Block reader until reception finished or\
    \ timeout.\n+    reader.block_for_all();\n+}\n+\n // Test for ==operator UDPTransportDescriptor\
    \ is not required as it is an abstract class and in UDPv4 is same method\n //\
    \ Test for copy UDPTransportDescriptor is not required as it is an abstract class\
    \ and in UDPv4 is same method\n "
  - "--- a/test/blackbox/utils/data_generators.cpp\n+++ b/test/blackbox/utils/data_generators.cpp\n\
    @@ -277,3 +277,24 @@ std::list<KeyedData1mb> default_keyeddata300kb_data_generator(\n\
    \ \n     return returnedValue;\n }\n+\n+std::list<UnboundedHelloWorld> default_unbounded_helloworld_data_generator(\n\
    +        size_t max)\n+{\n+    uint16_t index = 1;\n+    size_t maximum = max\
    \ ? max : 10;\n+    std::list<UnboundedHelloWorld> returnedValue(maximum);\n+\n\
    +    std::generate(returnedValue.begin(), returnedValue.end(), [&index]\n+   \
    \         {\n+                UnboundedHelloWorld hello;\n+                hello.index(index);\n\
    +                std::stringstream ss;\n+                ss << \"HelloWorld \"\
    \ << index;\n+                hello.message(ss.str());\n+                ++index;\n\
    +                return hello;\n+            });\n+\n+    return returnedValue;\n\
    +}"
  identifiers: CVE:["CVE-2024-28231"],CWE:["CWE-122"]
  overview: Affected versions of this package are vulnerable to Heap-based Buffer
    Overflow in `MessageReceiver.cpp`, due to the handling of the `payload_size` in
    a DATA Submessage packet. An attacker can crash the process by passing in a negative
    number.
  references:
    GitHub Commit: https://github.com/eProsima/Fast-DDS/commit/355706386f4af9ce74125eeec3c449b06113112b
  title: Heap-based Buffer Overflow
- diff_content:
  - "--- a/lib/nettle/int/dsa-compute-k.c\n+++ b/lib/nettle/int/dsa-compute-k.c\n\
    @@ -31,29 +31,37 @@\n #include \"mpn-base256.h\"\n #include <string.h>\n \n-#define\
    \ BITS_TO_LIMBS(bits) (((bits) + GMP_NUMB_BITS - 1) / GMP_NUMB_BITS)\n+/* For\
    \ mini-gmp */\n+#ifndef GMP_LIMB_BITS\n+#define GMP_LIMB_BITS GMP_NUMB_BITS\n\
    +#endif\n \n-/* The maximum size of q, chosen from the fact that we support\n\
    - * 521-bit elliptic curve generator and 512-bit DSA subgroup at\n- * maximum.\
    \ */\n-#define MAX_Q_BITS 521\n-#define MAX_Q_SIZE ((MAX_Q_BITS + 7) / 8)\n-#define\
    \ MAX_Q_LIMBS BITS_TO_LIMBS(MAX_Q_BITS)\n+static inline int is_zero_limb(mp_limb_t\
    \ x)\n+{\n+\tx |= (x << 1);\n+\treturn ((x >> 1) - 1) >> (GMP_LIMB_BITS - 1);\n\
    +}\n+\n+static int sec_zero_p(const mp_limb_t *ap, mp_size_t n)\n+{\n+\tvolatile\
    \ mp_limb_t w;\n+\tmp_size_t i;\n \n-#define MAX_HASH_BITS (MAX_HASH_SIZE * 8)\n\
    -#define MAX_HASH_LIMBS BITS_TO_LIMBS(MAX_HASH_BITS)\n+\tfor (i = 0, w = 0; i\
    \ < n; i++)\n+\t\tw |= ap[i];\n \n-int _gnutls_dsa_compute_k(mpz_t k, const mpz_t\
    \ q, const mpz_t x,\n+\treturn is_zero_limb(w);\n+}\n+\n+int _gnutls_dsa_compute_k(mp_limb_t\
    \ *h, const mp_limb_t *q, const mp_limb_t *x,\n+\t\t\t  mp_size_t qn, mp_bitcnt_t\
    \ q_bits,\n \t\t\t  gnutls_mac_algorithm_t mac, const uint8_t *digest,\n \t\t\t\
    \  size_t length)\n {\n \tuint8_t V[MAX_HASH_SIZE];\n \tuint8_t K[MAX_HASH_SIZE];\n\
    \ \tuint8_t xp[MAX_Q_SIZE];\n \tuint8_t tp[MAX_Q_SIZE];\n-\tmp_limb_t h[MAX(MAX_Q_LIMBS,\
    \ MAX_HASH_LIMBS)];\n-\tmp_bitcnt_t q_bits = mpz_sizeinbase(q, 2);\n-\tmp_size_t\
    \ qn = mpz_size(q);\n \tmp_bitcnt_t h_bits = length * 8;\n \tmp_size_t hn = BITS_TO_LIMBS(h_bits);\n\
    \ \tsize_t nbytes = (q_bits + 7) / 8;\n@@ -62,14 +70,15 @@ int _gnutls_dsa_compute_k(mpz_t\
    \ k, const mpz_t q, const mpz_t x,\n \tmp_limb_t cy;\n \tgnutls_hmac_hd_t hd;\n\
    \ \tint ret = 0;\n+\tmp_limb_t scratch[MAX_Q_LIMBS];\n \n \tif (unlikely(q_bits\
    \ > MAX_Q_BITS))\n \t\treturn gnutls_assert_val(GNUTLS_E_INVALID_REQUEST);\n \t\
    if (unlikely(length > MAX_HASH_SIZE))\n \t\treturn gnutls_assert_val(GNUTLS_E_INVALID_REQUEST);\n\
    \ \n \t/* int2octets(x) */\n-\tmpn_get_base256(xp, nbytes, mpz_limbs_read(x),\
    \ qn);\n+\tmpn_get_base256(xp, nbytes, x, qn);\n \n \t/* bits2octets(h) */\n \t\
    mpn_set_base256(h, hn, digest, length);\n@@ -93,12 +102,12 @@ int _gnutls_dsa_compute_k(mpz_t\
    \ k, const mpz_t q, const mpz_t x,\n \t\t\tmpn_rshift(h, h, hn, shift % GMP_NUMB_BITS);\n\
    \ \t}\n \n-\tcy = mpn_sub_n(h, h, mpz_limbs_read(q), qn);\n+\tcy = mpn_sub_n(h,\
    \ h, q, qn);\n \t/* Fall back to addmul_1, if nettle is linked with mini-gmp.\
    \ */\n #ifdef mpn_cnd_add_n\n-\tmpn_cnd_add_n(cy, h, h, mpz_limbs_read(q), qn);\n\
    +\tmpn_cnd_add_n(cy, h, h, q, qn);\n #else\n-\tmpn_addmul_1(h, mpz_limbs_read(q),\
    \ qn, cy != 0);\n+\tmpn_addmul_1(h, q, qn, cy != 0);\n #endif\n \tmpn_get_base256(tp,\
    \ nbytes, h, qn);\n \n@@ -174,12 +183,8 @@ int _gnutls_dsa_compute_k(mpz_t k,\
    \ const mpz_t q, const mpz_t x,\n \t\tif (tlen * 8 > q_bits)\n \t\t\tmpn_rshift(h,\
    \ h, qn, tlen * 8 - q_bits);\n \t\t/* Check if k is in [1,q-1] */\n-\t\tif (!mpn_zero_p(h,\
    \ qn) &&\n-\t\t    mpn_cmp(h, mpz_limbs_read(q), qn) < 0) {\n-\t\t\tmpn_copyi(mpz_limbs_write(k,\
    \ qn), h, qn);\n-\t\t\tmpz_limbs_finish(k, qn);\n+\t\tif (!sec_zero_p(h, qn) &&\
    \ mpn_sub_n(scratch, h, q, qn))\n \t\t\tbreak;\n-\t\t}\n \n \t\tret = gnutls_hmac_init(&hd,\
    \ mac, K, length);\n \t\tif (ret < 0)\n@@ -203,3 +208,24 @@ int _gnutls_dsa_compute_k(mpz_t\
    \ k, const mpz_t q, const mpz_t x,\n \n \treturn ret;\n }\n+\n+/* cancel-out dsa_sign's\
    \ addition of 1 to random data */\n+void _gnutls_dsa_compute_k_finish(uint8_t\
    \ *k, size_t nbytes, mp_limb_t *h,\n+\t\t\t\t  mp_size_t n)\n+{\n+\t/* Fall back\
    \ to sub_1, if nettle is linked with mini-gmp. */\n+#ifdef mpn_sec_sub_1\n+\t\
    mp_limb_t t[MAX_Q_LIMBS];\n+\n+\tmpn_sec_sub_1(h, h, n, 1, t);\n+#else\n+\tmpn_sub_1(h,\
    \ h, n, 1);\n+#endif\n+\tmpn_get_base256(k, nbytes, h, n);\n+}\n+\n+void _gnutls_ecdsa_compute_k_finish(uint8_t\
    \ *k, size_t nbytes, mp_limb_t *h,\n+\t\t\t\t    mp_size_t n)\n+{\n+\tmpn_get_base256(k,\
    \ nbytes, h, n);\n+}"
  - "--- a/lib/nettle/int/ecdsa-compute-k.c\n+++ b/lib/nettle/int/ecdsa-compute-k.c\n\
    @@ -29,38 +29,38 @@\n #include \"dsa-compute-k.h\"\n #include \"gnutls_int.h\"\
    \n \n-static inline int _gnutls_ecc_curve_to_dsa_q(mpz_t *q, gnutls_ecc_curve_t\
    \ curve)\n+int _gnutls_ecc_curve_to_dsa_q(mpz_t q, gnutls_ecc_curve_t curve)\n\
    \ {\n \tswitch (curve) {\n #ifdef ENABLE_NON_SUITEB_CURVES\n \tcase GNUTLS_ECC_CURVE_SECP192R1:\n\
    -\t\tmpz_init_set_str(*q,\n+\t\tmpz_init_set_str(q,\n \t\t\t\t \"FFFFFFFFFFFFFFFFFFFFFFFF99DEF836\"\
    \n \t\t\t\t \"146BC9B1B4D22831\",\n \t\t\t\t 16);\n \t\treturn 0;\n \tcase GNUTLS_ECC_CURVE_SECP224R1:\n\
    -\t\tmpz_init_set_str(*q,\n+\t\tmpz_init_set_str(q,\n \t\t\t\t \"FFFFFFFFFFFFFFFFFFFFFFFFFFFF16A2\"\
    \n \t\t\t\t \"E0B8F03E13DD29455C5C2A3D\",\n \t\t\t\t 16);\n \t\treturn 0;\n #endif\n\
    \ \tcase GNUTLS_ECC_CURVE_SECP256R1:\n-\t\tmpz_init_set_str(*q,\n+\t\tmpz_init_set_str(q,\n\
    \ \t\t\t\t \"FFFFFFFF00000000FFFFFFFFFFFFFFFF\"\n \t\t\t\t \"BCE6FAADA7179E84F3B9CAC2FC632551\"\
    ,\n \t\t\t\t 16);\n \t\treturn 0;\n \tcase GNUTLS_ECC_CURVE_SECP384R1:\n-\t\t\
    mpz_init_set_str(*q,\n+\t\tmpz_init_set_str(q,\n \t\t\t\t \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\"\
    \n \t\t\t\t \"FFFFFFFFFFFFFFFFC7634D81F4372DDF\"\n \t\t\t\t \"581A0DB248B0A77AECEC196ACCC52973\"\
    ,\n \t\t\t\t 16);\n \t\treturn 0;\n \tcase GNUTLS_ECC_CURVE_SECP521R1:\n-\t\t\
    mpz_init_set_str(*q,\n+\t\tmpz_init_set_str(q,\n \t\t\t\t \"1FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\"\
    \n \t\t\t\t \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\"\n \t\t\t\t \"FFA51868783BF2F966B7FCC0148F709A\"\
    \n@@ -73,19 +73,3 @@ static inline int _gnutls_ecc_curve_to_dsa_q(mpz_t *q, gnutls_ecc_curve_t\
    \ curve)\n \t\t\tGNUTLS_E_UNSUPPORTED_SIGNATURE_ALGORITHM);\n \t}\n }\n-\n-int\
    \ _gnutls_ecdsa_compute_k(mpz_t k, gnutls_ecc_curve_t curve, const mpz_t x,\n\
    -\t\t\t    gnutls_mac_algorithm_t mac, const uint8_t *digest,\n-\t\t\t    size_t\
    \ length)\n-{\n-\tmpz_t q;\n-\tint ret;\n-\n-\tret = _gnutls_ecc_curve_to_dsa_q(&q,\
    \ curve);\n-\tif (ret < 0)\n-\t\treturn gnutls_assert_val(ret);\n-\n-\tret = _gnutls_dsa_compute_k(k,\
    \ q, x, mac, digest, length);\n-\tmpz_clear(q);\n-\treturn ret;\n-}"
  - "--- a/lib/nettle/pk.c\n+++ b/lib/nettle/pk.c\n@@ -103,10 +103,16 @@ static void\
    \ rnd_nonce_func(void *_ctx, size_t length, uint8_t *data)\n \t}\n }\n \n-static\
    \ void rnd_mpz_func(void *_ctx, size_t length, uint8_t *data)\n+static void rnd_datum_func(void\
    \ *ctx, size_t length, uint8_t *data)\n {\n-\tmpz_t *k = _ctx;\n-\tnettle_mpz_get_str_256(length,\
    \ data, *k);\n+\tgnutls_datum_t *d = ctx;\n+\n+\tif (length > d->size) {\n+\t\t\
    memset(data, 0, length - d->size);\n+\t\tmemcpy(data + (length - d->size), d->data,\
    \ d->size);\n+\t} else {\n+\t\tmemcpy(data, d->data, length);\n+\t}\n }\n \n static\
    \ void rnd_nonce_func_fallback(void *_ctx, size_t length, uint8_t *data)\n@@ -1403,7\
    \ +1409,10 @@ static int _wrap_nettle_pk_sign(gnutls_pk_algorithm_t algo,\n \t\
    \tstruct dsa_signature sig;\n \t\tint curve_id = pk_params->curve;\n \t\tconst\
    \ struct ecc_curve *curve;\n-\t\tmpz_t k;\n+\t\tmpz_t q;\n+\t\t/* 521-bit elliptic\
    \ curve generator at maximum */\n+\t\tuint8_t buf[(521 + 7) / 8];\n+\t\tgnutls_datum_t\
    \ k = { NULL, 0 };\n \t\tvoid *random_ctx;\n \t\tnettle_random_func *random_func;\n\
    \ \n@@ -1447,17 +1456,32 @@ static int _wrap_nettle_pk_sign(gnutls_pk_algorithm_t\
    \ algo,\n \t\t\tnot_approved = true;\n \t\t}\n \n-\t\tmpz_init(k);\n+\t\tmpz_init(q);\n\
    +\n \t\tif (_gnutls_get_lib_state() == LIB_STATE_SELFTEST ||\n \t\t    (sign_params->flags\
    \ & GNUTLS_PK_FLAG_REPRODUCIBLE)) {\n-\t\t\tret = _gnutls_ecdsa_compute_k(\n-\t\
    \t\t\tk, curve_id, pk_params->params[ECC_K],\n+\t\t\tmp_limb_t h[DSA_COMPUTE_K_ITCH];\n\
    +\n+\t\t\tret = _gnutls_ecc_curve_to_dsa_q(q, curve_id);\n+\t\t\tif (ret < 0)\n\
    +\t\t\t\tgoto ecdsa_cleanup;\n+\n+\t\t\tret = _gnutls_dsa_compute_k(\n+\t\t\t\t\
    h, mpz_limbs_read(q), priv.p,\n+\t\t\t\tecc_size(priv.ecc), ecc_bit_size(priv.ecc),\n\
    \ \t\t\t\tDIG_TO_MAC(sign_params->dsa_dig), vdata->data,\n \t\t\t\tvdata->size);\n\
    \ \t\t\tif (ret < 0)\n \t\t\t\tgoto ecdsa_cleanup;\n+\n+\t\t\tk.data = buf;\n\
    +\t\t\tk.size = (ecc_bit_size(priv.ecc) + 7) / 8;\n+\n+\t\t\t_gnutls_ecdsa_compute_k_finish(k.data,\
    \ k.size, h,\n+\t\t\t\t\t\t       ecc_size(priv.ecc));\n+\n \t\t\trandom_ctx =\
    \ &k;\n-\t\t\trandom_func = rnd_mpz_func;\n+\t\t\trandom_func = rnd_datum_func;\n\
    \ \t\t} else {\n \t\t\trandom_ctx = NULL;\n \t\t\trandom_func = rnd_nonce_func;\n\
    @@ -1476,7 +1500,7 @@ static int _wrap_nettle_pk_sign(gnutls_pk_algorithm_t algo,\n\
    \ \tecdsa_cleanup:\n \t\tdsa_signature_clear(&sig);\n \t\tecc_scalar_zclear(&priv);\n\
    -\t\tmpz_clear(k);\n+\t\tmpz_clear(q);\n \n \t\tif (ret < 0) {\n \t\t\tgnutls_assert();\n\
    @@ -1488,7 +1512,9 @@ static int _wrap_nettle_pk_sign(gnutls_pk_algorithm_t algo,\n\
    \ \t\tstruct dsa_params pub;\n \t\tbigint_t priv;\n \t\tstruct dsa_signature sig;\n\
    -\t\tmpz_t k;\n+\t\t/* 512-bit DSA subgroup at maximum */\n+\t\tuint8_t buf[(512\
    \ + 7) / 8];\n+\t\tgnutls_datum_t k = { NULL, 0 };\n \t\tvoid *random_ctx;\n \t\
    \tnettle_random_func *random_func;\n \n@@ -1515,19 +1541,27 @@ static int _wrap_nettle_pk_sign(gnutls_pk_algorithm_t\
    \ algo,\n \t\t\thash_len = vdata->size;\n \t\t}\n \n-\t\tmpz_init(k);\n \t\tif\
    \ (_gnutls_get_lib_state() == LIB_STATE_SELFTEST ||\n \t\t    (sign_params->flags\
    \ & GNUTLS_PK_FLAG_REPRODUCIBLE)) {\n+\t\t\tmp_limb_t h[DSA_COMPUTE_K_ITCH];\n\
    +\n \t\t\tret = _gnutls_dsa_compute_k(\n-\t\t\t\tk, pub.q, TOMPZ(priv),\n+\t\t\
    \t\th, mpz_limbs_read(pub.q),\n+\t\t\t\tmpz_limbs_read(TOMPZ(priv)), mpz_size(pub.q),\n\
    +\t\t\t\tmpz_sizeinbase(pub.q, 2),\n \t\t\t\tDIG_TO_MAC(sign_params->dsa_dig),\
    \ vdata->data,\n \t\t\t\tvdata->size);\n \t\t\tif (ret < 0)\n \t\t\t\tgoto dsa_fail;\n\
    -\t\t\t/* cancel-out dsa_sign's addition of 1 to random data */\n-\t\t\tmpz_sub_ui(k,\
    \ k, 1);\n+\n+\t\t\tk.data = buf;\n+\t\t\tk.size = (mpz_sizeinbase(pub.q, 2) +\
    \ 7) / 8;\n+\n+\t\t\t_gnutls_dsa_compute_k_finish(k.data, k.size, h,\n+\t\t\t\t\
    \t\t     mpz_size(pub.q));\n+\n \t\t\trandom_ctx = &k;\n-\t\t\trandom_func = rnd_mpz_func;\n\
    +\t\t\trandom_func = rnd_datum_func;\n \t\t} else {\n \t\t\trandom_ctx = NULL;\n\
    \ \t\t\trandom_func = rnd_nonce_func;\n@@ -1544,7 +1578,6 @@ static int _wrap_nettle_pk_sign(gnutls_pk_algorithm_t\
    \ algo,\n \n \tdsa_fail:\n \t\tdsa_signature_clear(&sig);\n-\t\tmpz_clear(k);\n\
    \ \n \t\tif (ret < 0) {\n \t\t\tgnutls_assert();"
  - "--- a/lib/x509/common.c\n+++ b/lib/x509/common.c\n@@ -1725,7 +1725,15 @@ unsigned\
    \ int _gnutls_sort_clist(gnutls_x509_crt_t *clist,\n \tbool insorted[DEFAULT_MAX_VERIFY_DEPTH];\
    \ /* non zero if clist[i] used in sorted list */\n \tgnutls_x509_crt_t sorted[DEFAULT_MAX_VERIFY_DEPTH];\n\
    \ \n-\tassert(clist_size <= DEFAULT_MAX_VERIFY_DEPTH);\n+\t/* Limit the number\
    \ of certificates in the chain, to avoid DoS\n+\t * because of the O(n^2) sorting\
    \ below.  FIXME: Switch to a\n+\t * topological sort algorithm which should be\
    \ linear to the\n+\t * number of certificates and subject-issuer relationships.\n\
    +\t */\n+\tif (clist_size > DEFAULT_MAX_VERIFY_DEPTH) {\n+\t\t_gnutls_debug_log(\"\
    too many certificates; skipping sorting\\n\");\n+\t\treturn 1;\n+\t}\n \n \tfor\
    \ (i = 0; i < DEFAULT_MAX_VERIFY_DEPTH; i++) {\n \t\tissuer[i] = -1;"
  - "--- a/lib/x509/verify-high.c\n+++ b/lib/x509/verify-high.c\n@@ -25,7 +25,7 @@\n\
    \ #include \"errors.h\"\n #include <libtasn1.h>\n #include \"global.h\"\n-#include\
    \ \"num.h\" /* MAX */\n+#include \"num.h\" /* MIN */\n #include \"tls-sig.h\"\n\
    \ #include \"str.h\"\n #include \"datum.h\"\n@@ -1361,7 +1361,8 @@ int gnutls_x509_trust_list_verify_crt2(\n\
    \ \tint ret = 0;\n \tunsigned int i;\n \tsize_t hash;\n-\tgnutls_x509_crt_t sorted[DEFAULT_MAX_VERIFY_DEPTH];\n\
    +\tgnutls_x509_crt_t *cert_list_copy = NULL;\n+\tunsigned int cert_list_max_size\
    \ = 0;\n \tgnutls_x509_crt_t retrieved[DEFAULT_MAX_VERIFY_DEPTH];\n \tunsigned\
    \ int retrieved_size = 0;\n \tconst char *hostname = NULL, *purpose = NULL, *email\
    \ = NULL;\n@@ -1421,16 +1422,28 @@ int gnutls_x509_trust_list_verify_crt2(\n \t\
    \t}\n \t}\n \n-\tmemcpy(sorted, cert_list, cert_list_size * sizeof(gnutls_x509_crt_t));\n\
    -\tcert_list = sorted;\n+\t/* Allocate extra for retrieved certificates. */\n\
    +\tif (!INT_ADD_OK(cert_list_size, DEFAULT_MAX_VERIFY_DEPTH,\n+\t\t\t&cert_list_max_size))\n\
    +\t\treturn gnutls_assert_val(GNUTLS_E_INVALID_REQUEST);\n+\n+\tcert_list_copy\
    \ = _gnutls_reallocarray(NULL, cert_list_max_size,\n+\t\t\t\t\t      sizeof(gnutls_x509_crt_t));\n\
    +\tif (!cert_list_copy)\n+\t\treturn gnutls_assert_val(GNUTLS_E_MEMORY_ERROR);\n\
    +\n+\tmemcpy(cert_list_copy, cert_list,\n+\t       cert_list_size * sizeof(gnutls_x509_crt_t));\n\
    +\tcert_list = cert_list_copy;\n \n \trecords = gl_list_nx_create_empty(GL_LINKEDHASH_LIST,\
    \ cert_eq,\n \t\t\t\t\t  cert_hashcode, NULL, false);\n-\tif (records == NULL)\n\
    -\t\treturn gnutls_assert_val(GNUTLS_E_MEMORY_ERROR);\n+\tif (records == NULL)\
    \ {\n+\t\tret = gnutls_assert_val(GNUTLS_E_MEMORY_ERROR);\n+\t\tgoto cleanup;\n\
    +\t}\n \n-\tfor (i = 0; i < cert_list_size &&\n-\t\t    cert_list_size <= DEFAULT_MAX_VERIFY_DEPTH;)\
    \ {\n+\tfor (i = 0; i < cert_list_size;) {\n \t\tunsigned int sorted_size = 1;\n\
    \ \t\tunsigned int j, k;\n \t\tgnutls_x509_crt_t issuer;\n@@ -1442,8 +1455,7 @@\
    \ int gnutls_x509_trust_list_verify_crt2(\n \n \t\tassert(sorted_size > 0);\n\
    \ \n-\t\t/* Remove duplicates. Start with index 1, as the first element\n-\t\t\
    \ * may be re-checked after issuer retrieval. */\n+\t\t/* Remove duplicates. */\n\
    \ \t\tfor (j = 0; j < sorted_size; j++) {\n \t\t\tif (gl_list_search(records,\
    \ cert_list[i + j])) {\n \t\t\t\tif (i + j < cert_list_size - 1) {\n@@ -1495,13\
    \ +1507,15 @@ int gnutls_x509_trust_list_verify_crt2(\n \n \t\tret = retrieve_issuers(\n\
    \ \t\t\tlist, cert_list[i - 1], &retrieved[retrieved_size],\n-\t\t\tDEFAULT_MAX_VERIFY_DEPTH\
    \ -\n-\t\t\t\tMAX(retrieved_size, cert_list_size));\n+\t\t\tMIN(DEFAULT_MAX_VERIFY_DEPTH\
    \ - retrieved_size,\n+\t\t\t    cert_list_max_size - cert_list_size));\n \t\t\
    if (ret < 0) {\n \t\t\tbreak;\n \t\t} else if (ret > 0) {\n \t\t\tassert((unsigned\
    \ int)ret <=\n-\t\t\t       DEFAULT_MAX_VERIFY_DEPTH - cert_list_size);\n+\t\t\
    \t       DEFAULT_MAX_VERIFY_DEPTH - retrieved_size);\n+\t\t\tassert((unsigned\
    \ int)ret <=\n+\t\t\t       cert_list_max_size - cert_list_size);\n \t\t\tmemmove(&cert_list[i\
    \ + ret], &cert_list[i],\n \t\t\t\t(cert_list_size - i) *\n \t\t\t\t\tsizeof(gnutls_x509_crt_t));\n\
    @@ -1517,8 +1531,10 @@ int gnutls_x509_trust_list_verify_crt2(\n \t}\n \n \tcert_list_size\
    \ = shorten_clist(list, cert_list, cert_list_size);\n-\tif (cert_list_size <=\
    \ 0)\n-\t\treturn gnutls_assert_val(GNUTLS_E_INTERNAL_ERROR);\n+\tif (cert_list_size\
    \ <= 0) {\n+\t\tret = gnutls_assert_val(GNUTLS_E_INTERNAL_ERROR);\n+\t\tgoto cleanup;\n\
    +\t}\n \n \thash = hash_pjw_bare(cert_list[cert_list_size - 1]->raw_issuer_dn.data,\n\
    \ \t\t\t     cert_list[cert_list_size - 1]->raw_issuer_dn.size);\n@@ -1661,10\
    \ +1677,13 @@ int gnutls_x509_trust_list_verify_crt2(\n \t}\n \n cleanup:\n+\t\
    gnutls_free(cert_list_copy);\n \tfor (i = 0; i < retrieved_size; i++) {\n \t\t\
    gnutls_x509_crt_deinit(retrieved[i]);\n \t}\n-\tgl_list_free(records);\n+\tif\
    \ (records) {\n+\t\tgl_list_free(records);\n+\t}\n \treturn ret;\n }\n "
  - "--- a/tests/sign-verify-deterministic.c\n+++ b/tests/sign-verify-deterministic.c\n\
    @@ -198,7 +198,7 @@ void doit(void)\n \t\t\t\t\t\t &tests[i].msg, &signature);\n\
    \ \t\tif (ret < 0)\n \t\t\ttestfail(\"gnutls_pubkey_verify_data2\\n\");\n-\t\t\
    success(\" - pass\");\n+\t\tsuccess(\" - pass\\n\");\n \n \tnext:\n \t\tgnutls_free(signature.data);"
  identifiers: CVE:["CVE-2024-28835"],CWE:["CWE-248"]
  overview: Affected versions of this package are vulnerable to Uncontrolled Resource
    Consumption ('Resource Exhaustion') via the `certtool --verify-chain` command.
    An attacker can induce an application crash by attempting to verify a specially
    crafted .pem bundle.
  references:
    GitHub Commit: https://github.com/gnutls/gnutls/commit/4a4cefef6c194f8fbbffd7fb19651219421b085b
    GitLab Issue: https://gitlab.com/gnutls/gnutls/-/issues/1525
    RedHat Bugzilla Bug: https://bugzilla.redhat.com/show_bug.cgi?id=2269084
    Release Notes: https://lists.gnupg.org/pipermail/gnutls-help/2024-March/004845.html
  title: Uncontrolled Resource Consumption ('Resource Exhaustion')
- diff_content:
  - "--- a/Drivers/Postgre7.1/info.c\n+++ b/Drivers/Postgre7.1/info.c\n@@ -1779,14\
    \ +1779,14 @@ char *table_name;\n char index_name[MAX_INFO_STRING];\n short fields_vector[8];\n\
    \ char isunique[10], isclustered[10];\n-SDWORD index_name_len, fields_vector_len;\n\
    +SQLLEN index_name_len, fields_vector_len;\n TupleNode *row;\n int i;\n HSTMT\
    \ hcol_stmt;\n StatementClass *col_stmt, *indx_stmt;\n char column_name[MAX_INFO_STRING],\
    \ relhasrules[MAX_INFO_STRING];\n char **column_names = 0;\n-Int4 column_name_len;\n\
    +SQLLEN column_name_len;\n int total_columns = 0;\n char error = TRUE;\n ConnInfo\
    \ *ci;\n@@ -2136,7 +2136,7 @@ HSTMT htbl_stmt;\n StatementClass *tbl_stmt;\n char\
    \ tables_query[STD_STATEMENT_LEN];\n char attname[MAX_INFO_STRING];\n-SDWORD attname_len;\n\
    +SQLLEN attname_len;\n char pktab[MAX_TABLE_LEN + 1];\n Int2 result_cols;\n "
  identifiers: CVE:["CVE-2024-1013"],CWE:["CWE-823"]
  overview: Affected versions of this package are vulnerable to Use of Out-of-range
    Pointer Offset due to an improper pointer-to-integer types conversion on 64-bit
    architectures, where the caller expects to write 4 bytes but the callee writes
    8 bytes. This discrepancy may not cause issues on little-endian architectures
    but can lead to significant problems on big-endian architectures. An attacker
    can exploit this flaw to perform out-of-bounds stack writes, potentially leading
    to arbitrary code execution or denial of service.
  references:
    GitHub Commit: https://github.com/lurcher/unixODBC/commit/249bfcc511e89431b910ce2c62ae0b62bb9cc214
    GitHub PR: https://github.com/lurcher/unixODBC/pull/157
    RedHat Bugzilla Bug: https://bugzilla.redhat.com/show_bug.cgi?id=2260823
  title: Use of Out-of-range Pointer Offset
- diff_content:
  - "--- a/src/scene_manager/swf_parse.c\n+++ b/src/scene_manager/swf_parse.c\n@@\
    \ -322,7 +322,7 @@ static char *swf_get_string(SWFReader *read)\n \twhile (1)\
    \ {\n \t\tif (i>=read->size) {\n \t\t\tread->ioerr = GF_NON_COMPLIANT_BITSTREAM;\n\
    -\t\t\tname[read->size-1] = 0;\n+\t\t\tname[read->size ? read->size-1 : 0] = 0;\n\
    \ \t\t\tbreak;\n \t\t}\n \t\tname[i] = swf_read_int(read, 8);"
  identifiers: CVE:["CVE-2024-28318"],CWE:["CWE-787"]
  overview: Affected versions of this package are vulnerable to Out-of-bounds Write
    via the `swf_get_string` function in `scene_manager/swf_parse.c`. An attacker
    can cause a denial of service or expose information by providing a malicious SWF
    file.
  references:
    GitHub Commit: https://github.com/gpac/gpac/commit/ae831621a08a64e3325ce532f8b78811a1581716
    GitHub Issue: https://github.com/gpac/gpac/issues/2764
  title: Out-of-bounds Write
- diff_content:
  - "--- a/shlr/grub/fs/sfs.c\n+++ b/shlr/grub/fs/sfs.c\n@@ -159,6 +159,9 @@ grub_sfs_read_extent\
    \ (struct grub_sfs_data *data, unsigned int block,\n     return 0;\n \n   treeblock\
    \ = grub_malloc (data->blocksize);\n+  if(!treeblock){\n+    return grub_error(GRUB_ERR_OUT_OF_MEMORY,\
    \ \"Failed to allocate memory for treeblock\");\n+  }\n \n   next = grub_be_to_cpu32\
    \ (data->rblock.btree);\n   tree = (struct grub_sfs_btree *) treeblock;"
  identifiers: CVE:["CVE-2024-26475"],CWE:["CWE-476"]
  overview: Affected versions of this package are vulnerable to NULL Pointer Dereference
    in the `grub_sfs_read_extent` function in `sfs.c`, which allows an attacker to
    cause undefined behavior or a crash when accessing a tree_block.
  references:
    GitHub Commit: https://github.com/radareorg/radare2/commit/8419d7d0cbe61c687dcb8a35de0acccb2ee4c220
    Vulnerability Report: https://github.com/TronciuVlad/CVE-2024-26475
  title: NULL Pointer Dereference
- diff_content:
  - "--- a/subsys/net/ip/ipv4.c\n+++ b/subsys/net/ip/ipv4.c\n@@ -272,6 +272,11 @@\
    \ enum net_verdict net_ipv4_input(struct net_pkt *pkt, bool is_loopback)\n \t\t\
    \tNET_DBG(\"DROP: localhost packet\");\n \t\t\tgoto drop;\n \t\t}\n+\n+\t\tif\
    \ (net_ipv4_is_my_addr(&hdr->src)) {\n+\t\t\tNET_DBG(\"DROP: src addr is %s\"\
    , \"mine\");\n+\t\t\tgoto drop;\n+\t\t}\n \t}\n \n \tif (net_ipv4_is_addr_mcast(&hdr->src))\
    \ {"
  identifiers: CVE:["CVE-2023-7060"],CWE:["CWE-754"]
  overview: Affected versions of this package are vulnerable to Improper Check for
    Unusual or Exceptional Conditions in handling IP packets that arrive on an external
    interface with a source address equal to 127.0.0.1 or a destination address. This
    allows attackers to send malicious packets that evade filtering and cause a crash.
  references:
    GitHub Commit: https://github.com/zephyrproject-rtos/zephyr/commit/32748c69b898aa387687abafd6b30702696ac15b
  title: Improper Check for Unusual or Exceptional Conditions
- diff_content:
  - "--- a/src/media_tools/dash_client.c\n+++ b/src/media_tools/dash_client.c\n@@\
    \ -6368,7 +6368,7 @@ static GF_Err gf_dash_setup_period(GF_DashClient *dash)\n\
    \ \t\t\t\tdisabled = 1;\n \t\t\t\tbreak;\n \t\t\t}\n-\t\t\tif (!strcmp(mpd_desc->scheme_id_uri,\
    \ \"urn:mpeg:dash:srd:2014\")) {\n+\t\t\tif (mpd_desc && mpd_desc->scheme_id_uri\
    \ && !strcmp(mpd_desc->scheme_id_uri, \"urn:mpeg:dash:srd:2014\") && mpd_desc->value)\
    \ {\n \t\t\t\tu32 id, w, h, res;\n \t\t\t\tw = h = 0;\n \t\t\t\tres = sscanf(mpd_desc->value,\
    \ \"%d,%d,%d,%d,%d,%d,%d\", &id, &group->srd_x, &group->srd_y, &group->srd_w,\
    \ &group->srd_h, &w, &h);"
  identifiers: CVE:["CVE-2024-28319"],CWE:["CWE-125"]
  overview: Affected versions of this package are vulnerable to Out-of-bounds Read
    via the `gf_dash_setup_period` function in `media_tools/dash_client.c:6374`. An
    attacker can trigger an out of boundary read condition by manipulating the input
    data to the function.
  references:
    GitHub Commit: https://github.com/gpac/gpac/commit/cb3c29809bddfa32686e3deb231a76af67b68e1e
    GitHub Issue: https://github.com/gpac/gpac/issues/2763
  title: Out-of-bounds Read
- diff_content:
  - "--- a/src/mms/iso_mms/server/mms_named_variable_list_service.c\n+++ b/src/mms/iso_mms/server/mms_named_variable_list_service.c\n\
    @@ -130,16 +130,22 @@ mmsServer_handleDeleteNamedVariableListRequest(MmsServerConnection\
    \ connection,\n \t\tgoto exit_function;\n \t}\n \n-\tif ((mmsPdu->present == MmsPdu_PR_confirmedRequestPdu)\
    \ &&\n-\t\t(mmsPdu->choice.confirmedRequestPdu.confirmedServiceRequest.present\n\
    -\t\t== ConfirmedServiceRequest_PR_deleteNamedVariableList))\n-\t{\n-\t\trequest\
    \ = &(mmsPdu->choice.confirmedRequestPdu.confirmedServiceRequest.choice.deleteNamedVariableList);\n\
    -\t}\n-\telse {\n-\t\tmmsMsg_createMmsRejectPdu(&invokeId, MMS_ERROR_REJECT_INVALID_PDU,\
    \ response);\n-\t\tgoto exit_function;\n-\t}\n+    if ((mmsPdu->present == MmsPdu_PR_confirmedRequestPdu)\
    \ &&\n+        (mmsPdu->choice.confirmedRequestPdu.confirmedServiceRequest.present\n\
    +        == ConfirmedServiceRequest_PR_deleteNamedVariableList))\n+    {\n+  \
    \      request = &(mmsPdu->choice.confirmedRequestPdu.confirmedServiceRequest.choice.deleteNamedVariableList);\n\
    +    }\n+    else {\n+        mmsMsg_createMmsRejectPdu(&invokeId, MMS_ERROR_REJECT_INVALID_PDU,\
    \ response);\n+        goto exit_function;\n+    }\n+\n+    if (request->listOfVariableListName\
    \ == NULL)\n+    {\n+        mmsMsg_createMmsRejectPdu(&invokeId, MMS_ERROR_REJECT_INVALID_PDU,\
    \ response);\n+        goto exit_function;\n+    }\n  \n \tlong scopeOfDelete\
    \ = DeleteNamedVariableListRequest__scopeOfDelete_specific;\n "
  identifiers: CVE:["CVE-2024-26529"],CWE:["CWE-400"]
  overview: Affected versions of this package are vulnerable to Denial of Service
    (DoS) due to a triggerable segmentation fault in the `mmsServer_handleDeleteNamedVariableListRequest`
    function in `src/mms/iso_mms/server/mms_named_variable_list_service.c`.
  references:
    GitHub Commit: https://github.com/mz-automation/libiec61850/commit/cf94d64206cf53298edf4799a75b31657bb7cbb3
    GitHub Issue: https://github.com/mz-automation/libiec61850/issues/495
    commons-fileupload:commons-fileupload: SNYK-JAVA-COMMONSFILEUPLOAD-30082
    npm <code>ws</code> package: https://snyk.io/vuln/npm:ws:20171108
  title: Denial of Service (DoS)
- diff_content:
  - '--- a/tests/nixos/ca-fd-leak/sender.c

    +++ b/tests/nixos/ca-fd-leak/sender.c

    @@ -0,0 +1,65 @@

    +#include <sys/socket.h>

    +#include <sys/un.h>

    +#include <stdlib.h>

    +#include <stddef.h>

    +#include <stdio.h>

    +#include <unistd.h>

    +#include <fcntl.h>

    +#include <errno.h>

    +#include <string.h>

    +#include <assert.h>

    +

    +int main(int argc, char **argv) {

    +

    +    assert(argc == 2);

    +

    +    int sock = socket(AF_UNIX, SOCK_STREAM, 0);

    +

    +    // Set up a abstract domain socket path to connect to.

    +    struct sockaddr_un data;

    +    data.sun_family = AF_UNIX;

    +    data.sun_path[0] = 0;

    +    strcpy(data.sun_path + 1, argv[1]);

    +

    +    // Now try to connect, To ensure we work no matter what order we are

    +    // executed in, just busyloop here.

    +    int res = -1;

    +    while (res < 0) {

    +        res = connect(sock, (const struct sockaddr *)&data,

    +            offsetof(struct sockaddr_un, sun_path)

    +              + strlen(argv[1])

    +              + 1);

    +        if (res < 0 && errno != ECONNREFUSED) perror("connect");

    +        if (errno != ECONNREFUSED) break;

    +    }

    +

    +    // Write our message header.

    +    struct msghdr msg = {0};

    +    msg.msg_control = malloc(128);

    +    msg.msg_controllen = 128;

    +

    +    // Write an SCM_RIGHTS message containing the output path.

    +    struct cmsghdr *hdr = CMSG_FIRSTHDR(&msg);

    +    hdr->cmsg_len = CMSG_LEN(sizeof(int));

    +    hdr->cmsg_level = SOL_SOCKET;

    +    hdr->cmsg_type = SCM_RIGHTS;

    +    int fd = open(getenv("out"), O_RDWR | O_CREAT, 0640);

    +    memcpy(CMSG_DATA(hdr), (void *)&fd, sizeof(int));

    +

    +    msg.msg_controllen = CMSG_SPACE(sizeof(int));

    +

    +    // Write a single null byte too.

    +    msg.msg_iov = malloc(sizeof(struct iovec));

    +    msg.msg_iov[0].iov_base = "";

    +    msg.msg_iov[0].iov_len = 1;

    +    msg.msg_iovlen = 1;

    +

    +    // Send it to the othher side of this connection.

    +    res = sendmsg(sock, &msg, 0);

    +    if (res < 0) perror("sendmsg");

    +    int buf;

    +

    +    // Wait for the server to close the socket, implying that it has

    +    // received the commmand.

    +    recv(sock, (void *)&buf, sizeof(int), 0);

    +}'
  - '--- a/tests/nixos/ca-fd-leak/smuggler.c

    +++ b/tests/nixos/ca-fd-leak/smuggler.c

    @@ -0,0 +1,66 @@

    +#include <sys/socket.h>

    +#include <sys/un.h>

    +#include <stdlib.h>

    +#include <stddef.h>

    +#include <stdio.h>

    +#include <unistd.h>

    +#include <assert.h>

    +

    +int main(int argc, char **argv) {

    +

    +    assert(argc == 2);

    +

    +    int sock = socket(AF_UNIX, SOCK_STREAM, 0);

    +

    +    // Bind to the socket.

    +    struct sockaddr_un data;

    +    data.sun_family = AF_UNIX;

    +    data.sun_path[0] = 0;

    +    strcpy(data.sun_path + 1, argv[1]);

    +    int res = bind(sock, (const struct sockaddr *)&data,

    +        offsetof(struct sockaddr_un, sun_path)

    +        + strlen(argv[1])

    +        + 1);

    +    if (res < 0) perror("bind");

    +

    +    res = listen(sock, 1);

    +    if (res < 0) perror("listen");

    +

    +    int smuggling_fd = -1;

    +

    +    // Accept the connection a first time to receive the file descriptor.

    +    fprintf(stderr, "%s\n", "Waiting for the first connection");

    +    int a = accept(sock, 0, 0);

    +    if (a < 0) perror("accept");

    +

    +    struct msghdr msg = {0};

    +    msg.msg_control = malloc(128);

    +    msg.msg_controllen = 128;

    +

    +    // Receive the file descriptor as sent by the smuggler.

    +    recvmsg(a, &msg, 0);

    +

    +    struct cmsghdr *hdr = CMSG_FIRSTHDR(&msg);

    +    while (hdr) {

    +        if (hdr->cmsg_level == SOL_SOCKET

    +          && hdr->cmsg_type == SCM_RIGHTS) {

    +

    +            // Grab the copy of the file descriptor.

    +            memcpy((void *)&smuggling_fd, CMSG_DATA(hdr), sizeof(int));

    +        }

    +

    +        hdr = CMSG_NXTHDR(&msg, hdr);

    +    }

    +    fprintf(stderr, "%s\n", "Got the file descriptor. Now waiting for the second
    connection");

    +    close(a);

    +

    +    // Wait for a second connection, which will tell us that the build is

    +    // done

    +    a = accept(sock, 0, 0);

    +    fprintf(stderr, "%s\n", "Got a second connection, rewriting the file");

    +    // Write a new content to the file

    +    if (ftruncate(smuggling_fd, 0)) perror("ftruncate");

    +    char * new_content = "Pwned\n";

    +    int written_bytes = write(smuggling_fd, new_content, strlen(new_content));

    +    if (written_bytes != strlen(new_content)) perror("write");

    +}'
  identifiers: CVE:["CVE-2024-27297"],CWE:["CWE-754"]
  overview: Affected versions of this package are vulnerable to Improper Check for
    Unusual or Exceptional Conditions due to fixed-output derivations on Linux being
    able to send file descriptors to files in the Nix store to another program running
    on the host via Unix domain sockets in the abstract namespace. This allows the
    output of fixed-output derivations to be modified from their expected content.
  references:
    Additional Information: https://hackmd.io/03UGerewRcy3db44JQoWvw
    GitHub Commit: https://github.com/NixOS/nix/commit/f8170ce9f119e5e6724eb81ff1b5a2d4c0024000
  title: Improper Check for Unusual or Exceptional Conditions
- diff_content:
  - "--- a/src/interface/interface_backend_udev.c\n+++ b/src/interface/interface_backend_udev.c\n\
    @@ -23,6 +23,7 @@\n #include <dirent.h>\n #include <libudev.h>\n \n+#include \"\
    virlog.h\"\n #include \"virerror.h\"\n #include \"virfile.h\"\n #include \"datatypes.h\"\
    \n@@ -40,6 +41,8 @@\n \n #define VIR_FROM_THIS VIR_FROM_INTERFACE\n \n+VIR_LOG_INIT(\"\
    interface.interface_backend_udev\");\n+\n struct udev_iface_driver {\n     struct\
    \ udev *udev;\n     /* pid file FD, ensures two copies of the driver can't use\
    \ the same root */\n@@ -354,11 +357,20 @@ udevConnectListAllInterfaces(virConnectPtr\
    \ conn,\n         const char *macaddr;\n         g_autoptr(virInterfaceDef) def\
    \ = NULL;\n \n-        path = udev_list_entry_get_name(dev_entry);\n-        dev\
    \ = udev_device_new_from_syspath(udev, path);\n-        name = udev_device_get_sysname(dev);\n\
    +        if (!(path = udev_list_entry_get_name(dev_entry))) {\n+            VIR_DEBUG(\"\
    Skipping interface, path == NULL\");\n+            continue;\n+        }\n+  \
    \      if (!(dev = udev_device_new_from_syspath(udev, path))) {\n+           \
    \ VIR_DEBUG(\"Skipping interface '%s', dev == NULL\", path);\n+            continue;\n\
    +        }\n+        if (!(name = udev_device_get_sysname(dev))) {\n+        \
    \    VIR_DEBUG(\"Skipping interface '%s', name == NULL\", path);\n+          \
    \  continue;\n+        }\n         macaddr = udev_device_get_sysattr_value(dev,\
    \ \"address\");\n-        status = STREQ(udev_device_get_sysattr_value(dev, \"\
    operstate\"), \"up\");\n+        status = STREQ_NULLABLE(udev_device_get_sysattr_value(dev,\
    \ \"operstate\"), \"up\");\n \n         def = udevGetMinimalDefForDevice(dev);\n\
    \         if (!virConnectListAllInterfacesCheckACL(conn, def)) {\n@@ -964,9 +976,9\
    \ @@ udevGetIfaceDef(struct udev *udev, const char *name)\n \n     /* MTU */\n\
    \     mtu_str = udev_device_get_sysattr_value(dev, \"mtu\");\n-    if (virStrToLong_ui(mtu_str,\
    \ NULL, 10, &mtu) < 0) {\n+    if (!mtu_str || virStrToLong_ui(mtu_str, NULL,\
    \ 10, &mtu) < 0) {\n         virReportError(VIR_ERR_INTERNAL_ERROR,\n-       \
    \         _(\"Could not parse MTU value '%1$s'\"), mtu_str);\n+              \
    \  _(\"Could not parse MTU value '%1$s'\"), NULLSTR(mtu_str));\n         goto\
    \ error;\n     }\n     ifacedef->mtu = mtu;\n@@ -1089,7 +1101,7 @@ udevInterfaceIsActive(virInterfacePtr\
    \ ifinfo)\n        goto cleanup;\n \n     /* Check if it's active or not */\n\
    -    status = STREQ(udev_device_get_sysattr_value(dev, \"operstate\"), \"up\"\
    );\n+    status = STREQ_NULLABLE(udev_device_get_sysattr_value(dev, \"operstate\"\
    ), \"up\");\n \n     udev_device_unref(dev);\n \n"
  identifiers: CVE:["CVE-2024-2496"],CWE:["CWE-476"]
  overview: Affected versions of this package are vulnerable to NULL Pointer Dereference
    in `udevConnectListAllInterfaces` function. An attacker can cause a denial of
    service by exploiting this vulnerability.
  references:
    GitLab Commit: https://gitlab.com/libvirt/libvirt/-/commit/2ca94317ac642a70921947150ced8acc674ccdc8
  title: NULL Pointer Dereference
- diff_content:
  - "--- a/programs/pluto/ikev2_auth.c\n+++ b/programs/pluto/ikev2_auth.c\n@@ -862,7\
    \ +862,7 @@ stf_status submit_v2AUTH_generate_initiator_signature(struct ike_sa\
    \ *ike, struct\n \t\t\t\t\t\t       &signed_octets);\n \t\tif (d != NULL) {\n\
    \ \t\t\tllog_diag(RC_LOG_SERIOUS, ike->sa.logger, &d, \"%s\", \"\");\n-\t\t\t\
    return false;\n+\t\t\treturn STF_FATAL;\n \t\t}\n \n \t\tif (DBGP(DBG_CRYPT))\
    \ {"
  identifiers: CVE:["CVE-2024-2357"],CWE:["CWE-400"]
  overview: 'Affected versions of this package are vulnerable to Resource Exhaustion
    due to a misconfiguration in the handling of `PreSharedKeys` for `IKEv2` connections.
    An attacker can cause the service to restart under certain retransmit scenarios,
    leading to repeated crashes, resulting in a denial of service. '
  references:
    GitHub Commit: https://github.com/libreswan/libreswan/commit/cb9e1047d33fde695d63a95854c2bc2470a476c8
  title: Resource Exhaustion
- diff_content:
  - "--- a/controller/bfd.c\n+++ b/controller/bfd.c\n@@ -235,6 +235,9 @@ bfd_run(const\
    \ struct ovsrec_interface_table *interface_table,\n         if (mult) {\n    \
    \         smap_add(&bfd, \"mult\", mult);\n         }\n+        /* `check_tnl_key`\
    \ must always be set to \"true\" to avoid processing of\n+         * BFD control\
    \ messages originating from a logical port. */\n+        smap_add(&bfd, \"check_tnl_key\"\
    , \"true\");\n     }\n \n     /* Enable or disable bfd */"
  identifiers: CVE:["CVE-2024-2182"],CWE:["CWE-346"]
  overview: Affected versions of this package are vulnerable to Origin Validation
    Error due to insufficient validation of BFD packets. In clusters where BFD is
    used between hypervisors for high availability, an attacker can inject specially
    crafted BFD packets from inside unprivileged workloads, including virtual machines
    or containers, that can trigger a denial of service.
  references:
    GitHub Commit: https://github.com/ovn-org/ovn/commit/4fdfb2ba84dbc05492a4e37efc1e7af62185ed05
    RedHat Bugzilla Bug: https://bugzilla.redhat.com/show_bug.cgi?id=2267840
    Vulnerability Advisory: https://mail.openvswitch.org/pipermail/ovs-announce/2024-March/000346.html
  title: Origin Validation Error
- diff_content:
  - "--- a/src/utils.cpp\n+++ b/src/utils.cpp\n@@ -109,6 +109,8 @@ const struct vmlinux_location\
    \ vmlinux_locs[] = {\n   { nullptr, false },\n };\n \n+constexpr std::string_view\
    \ PROC_KHEADERS_PATH = \"/sys/kernel/kheaders.tar.xz\";\n+\n static bool pid_in_different_mountns(int\
    \ pid);\n static std::vector<std::string>\n resolve_binary_path(const std::string\
    \ &cmd, const char *env_paths, int pid);\n@@ -700,6 +702,22 @@ bool is_dir(const\
    \ std::string& path)\n   return std_filesystem::is_directory(buf, ec);\n }\n \n\
    +bool file_exists_and_ownedby_root(const char *f)\n+{\n+  struct stat st;\n+ \
    \ if (stat(f, &st) == 0)\n+  {\n+    if (st.st_uid != 0)\n+    {\n+      LOG(ERROR)\
    \ << \"header file ownership expected to be root: \"\n+                 << std::string(f);\n\
    +      return false;\n+    }\n+    return true;\n+  }\n+  return false;\n+}\n\
    +\n namespace {\n   struct KernelHeaderTmpDir {\n     KernelHeaderTmpDir(const\
    \ std::string& prefix) : path{prefix + \"XXXXXX\"}\n@@ -736,14 +754,14 @@ namespace\
    \ {\n #else\n     std_filesystem::path path_prefix{ \"/tmp\" };\n #endif\n-  \
    \  std_filesystem::path path_kheaders{ \"/sys/kernel/kheaders.tar.xz\" };\n+ \
    \   std_filesystem::path path_kheaders{ PROC_KHEADERS_PATH };\n     if (const\
    \ char* tmpdir = ::getenv(\"TMPDIR\")) {\n       path_prefix = tmpdir;\n     }\n\
    \     path_prefix /= \"kheaders-\";\n     std_filesystem::path shared_path{ path_prefix.string()\
    \ + utsname.release };\n \n-    if (std_filesystem::exists(shared_path, ec))\n\
    +    if (file_exists_and_ownedby_root(shared_path.c_str()))\n     {\n       //\
    \ already unpacked\n       return shared_path.string();\n@@ -767,7 +785,10 @@\
    \ namespace {\n \n     KernelHeaderTmpDir tmpdir{path_prefix};\n \n-    FILE*\
    \ tar = ::popen((\"tar xf /sys/kernel/kheaders.tar.xz -C \" + tmpdir.path).c_str(),\
    \ \"w\");\n+    FILE *tar = ::popen((\"tar xf \" + std::string(PROC_KHEADERS_PATH)\
    \ + \" -C \" +\n+                         tmpdir.path)\n+                    \
    \        .c_str(),\n+                        \"w\");\n     if (!tar) {\n     \
    \  return \"\";\n     }"
  - "--- a/tests/utils.cpp\n+++ b/tests/utils.cpp\n@@ -363,6 +363,28 @@ TEST(utils,\
    \ get_pids_for_program)\n   ASSERT_EQ(pids.size(), 0);\n }\n \n+TEST(utils, file_exists_and_ownedby_root)\n\
    +{\n+  std::string tmpdir = \"/tmp/bpftrace-test-utils-XXXXXX\";\n+  std::string\
    \ file1 = \"/ownedby-user\";\n+  std::string file2 = \"/no-exists\";\n+  if (::mkdtemp(tmpdir.data())\
    \ == nullptr)\n+  {\n+    throw std::runtime_error(\"creating temporary path for\
    \ tests failed\");\n+  }\n+\n+  int fd;\n+  fd = open((tmpdir + file1).c_str(),\
    \ O_CREAT, S_IRUSR);\n+  close(fd);\n+  ASSERT_GE(fd, 0);\n+\n+  EXPECT_FALSE(file_exists_and_ownedby_root((tmpdir\
    \ + file1).c_str()));\n+  EXPECT_FALSE(file_exists_and_ownedby_root((tmpdir +\
    \ file2).c_str()));\n+  EXPECT_TRUE(file_exists_and_ownedby_root(\"/proc/1/maps\"\
    ));\n+\n+  EXPECT_GT(std_filesystem::remove_all(tmpdir), 0);\n+}\n+\n } // namespace\
    \ utils\n } // namespace test\n } // namespace bpftrace"
  identifiers: CVE:["CVE-2024-2313"],CWE:["CWE-284"]
  overview: 'Affected versions of this package are vulnerable to Improper Access Control.
    An attacker can exploit this vulnerability by forcing the loading of compromised
    Linux headers. '
  references:
    GitHub Commit: https://github.com/bpftrace/bpftrace/commit/338fb98d794bbe4f265ad94e56ffb4227920ada3
    GitHub PR: https://github.com/bpftrace/bpftrace/pull/3033
    RedHat Bugzilla Bug: https://bugzilla.redhat.com/show_bug.cgi?id=2269014
  title: Improper Access Control
- diff_content:
  - "--- a/anon.c\n+++ b/anon.c\n@@ -84,7 +84,10 @@ static bool guc_anon_transparent_dynamic_masking;\n\
    \ /*\n  * Internal Functions\n  */\n+\n+static bool   pa_check_function(char *\
    \ expr);\n static bool   pa_check_masking_policies(char **newval, void **extra,\
    \ GucSource source);\n+static bool   pa_check_value(char * expr);\n static char\
    \ * pa_get_masking_policy_for_role(Oid roleid);\n static void   pa_masking_policy_object_relabel(const\
    \ ObjectAddress *object, const char *seclabel);\n static bool   pa_has_mask_in_policy(Oid\
    \ roleid, char *policy);\n@@ -94,6 +97,7 @@ static char * pa_cast_as_regtype(char\
    \ * value, int atttypid);\n static char * pa_masking_value_for_att(Relation rel,\
    \ FormData_pg_attribute * att, char * policy);\n static char * pa_masking_expressions_for_table(Oid\
    \ relid, char * policy);\n Node *        pa_masking_stmt_for_table(Oid relid,\
    \ char * policy);\n+Node *        pa_parse_expression(char * expr);\n \n /*\n\
    \  * Hook functions\n@@ -181,12 +185,30 @@ pa_masking_policy_object_relabel(const\
    \ ObjectAddress *object, const char *seclab\n            errmsg(\"'%s' is not\
    \ a valid label for a table\", seclabel)));\n       }\n \n+      /* SECURITY LABEL\
    \ FOR anon ON COLUMN t.i IS 'MASKED WITH FUNCTION $x$' */\n+      if ( pg_strncasecmp(seclabel,\
    \ \"MASKED WITH FUNCTION\", 20) == 0 ) {\n+          char * substr=malloc(strnlen(seclabel,PA_MAX_SIZE_MASKING_RULE));\n\
    +          strncpy(substr, seclabel+21, strnlen(seclabel,PA_MAX_SIZE_MASKING_RULE));\n\
    +          if (pa_check_function(substr)) return;\n+          ereport(ERROR,\n\
    +            (errcode(ERRCODE_INVALID_NAME),\n+            errmsg(\"'%s' is not\
    \ a valid masking function\", seclabel)));\n+          break;\n+      }\n+\n \
    \      /* SECURITY LABEL FOR anon ON COLUMN t.i IS 'MASKED WITH VALUE $x$' */\n\
    -      if ( pg_strncasecmp(seclabel, \"MASKED WITH FUNCTION\", 20) == 0\n-   \
    \     || pg_strncasecmp(seclabel, \"MASKED WITH VALUE\", 17) == 0\n-        ||\
    \ pg_strncasecmp(seclabel, \"NOT MASKED\", 10) == 0\n-      )\n-        return;\n\
    +      if ( pg_strncasecmp(seclabel, \"MASKED WITH VALUE\", 17) == 0) {\n+   \
    \       char * substr=malloc(strnlen(seclabel,PA_MAX_SIZE_MASKING_RULE));\n+ \
    \         strncpy(substr, seclabel+18, strnlen(seclabel,PA_MAX_SIZE_MASKING_RULE));\n\
    +          if (pa_check_value(substr)) return;\n+          ereport(ERROR,\n+ \
    \           (errcode(ERRCODE_INVALID_NAME),\n+            errmsg(\"'%s' is not\
    \ a valid masking value\", seclabel)));\n+          break;\n+      }\n+\n+   \
    \   /* SECURITY LABEL FOR anon ON COLUMN t.i IS 'NOT MASKED' */\n+      if ( pg_strncasecmp(seclabel,\
    \ \"NOT MASKED\", 10) == 0 ) return;\n \n       ereport(ERROR,\n         (errcode(ERRCODE_INVALID_NAME),\n\
    @@ -549,12 +571,27 @@ anon_get_function_schema(PG_FUNCTION_ARGS)\n     raw_parsetree_list\
    \ = raw_parser(query_string);\n     #endif\n \n+    /* accept only one statement\
    \ */\n+    if ( list_length(raw_parsetree_list) != 1 ) {\n+      ereport(ERROR,\n\
    +        (errcode(ERRCODE_INVALID_NAME),\n+        errmsg(\"'%s' is not a valid\
    \ function call\", function_call)));\n+    }\n+\n     /* walk throught the parse\
    \ tree, down to the FuncCall node (if present) */\n     #if PG_VERSION_NUM >=\
    \ 100000\n     stmt = (SelectStmt *) linitial_node(RawStmt, raw_parsetree_list)->stmt;\n\
    \     #else\n     stmt = (SelectStmt *) linitial(raw_parsetree_list);\n     #endif\n\
    +\n+    /* accept only one target in the statement */\n+    if ( list_length(stmt->targetList)\
    \ != 1 ) {\n+      ereport(ERROR,\n+        (errcode(ERRCODE_INVALID_NAME),\n\
    +        errmsg(\"'%s' is not a valid function call\", function_call)));\n+  \
    \  }\n+\n     restarget = (ResTarget *) linitial(stmt->targetList);\n     if (!\
    \ IsA(restarget->val, FuncCall))\n     {\n@@ -573,6 +610,27 @@ anon_get_function_schema(PG_FUNCTION_ARGS)\n\
    \     PG_RETURN_TEXT_P(cstring_to_text(\"\"));\n }\n \n+/*\n+ * pa_check_function\n\
    + *   validate if an expression is a correct masking function\n+ *\n+ */\n+static\
    \ bool\n+pa_check_function(char * expr)\n+{\n+    FuncCall * fc = (FuncCall *)\
    \ pa_parse_expression(expr);\n+\n+    if (fc == NULL) return false;\n+\n+    if\
    \ (! IsA(fc, FuncCall)) return false;\n+\n+    /* if the function name is not\
    \ qualified, we cant check the schema */\n+    if ( guc_anon_restrict_to_trusted_schemas\n\
    +    && list_length(fc->funcname) != 2 ) return false;\n+\n+    return true;\n\
    +}\n+\n \n /*\n  * pa_check_masking_policies\n@@ -608,6 +666,18 @@ pa_check_masking_policies(char\
    \ **newval, void **extra, GucSource source)\n   return true;\n }\n \n+/*\n+ *\
    \ pa_check_value\n+ *   validate if an expression is a correct masking value\n\
    + *\n+ */\n+static bool\n+pa_check_value(char * expr)\n+{\n+    Node * val = pa_parse_expression(expr);\n\
    +    if (val == NULL) return false;\n+    return IsA(val, ColumnRef) || IsA(val,A_Const);\n\
    +}\n \n /*\n  * pa_has_mask_in_policy\n@@ -700,6 +770,60 @@ pa_masking_stmt_for_table(Oid\
    \ relid, char * policy)\n   return (Node *) linitial_node(RawStmt, raw_parsetree_list)->stmt;\n\
    \ }\n \n+/*\n+ * pa_parse_expression\n+ *   use the Postgres parser to check a\
    \ given masking expression\n+ *   returns the parsetree if the expression is valid\n\
    + *   or NULL if the expression is invalid\n+ */\n+Node *\n+pa_parse_expression(char\
    \ * expr)\n+{\n+    char query_string[1024];\n+    List  *raw_parsetree_list;\n\
    +    SelectStmt *stmt;\n+    ResTarget  *restarget;\n+    FuncCall   *fc;\n+\n\
    +    if ( expr == NULL || strlen(expr) == 0)  {\n+      return NULL;\n+    }\n\
    +\n+    PG_TRY();\n+    {\n+      /* build a simple SELECT statement and parse\
    \ it */\n+      query_string[0] = '\\0';\n+      strlcat(query_string, \"SELECT\
    \ \", sizeof(query_string));\n+      strlcat(query_string, expr, sizeof(query_string));\n\
    +      #if PG_VERSION_NUM >= 140000\n+      raw_parsetree_list = raw_parser(query_string,RAW_PARSE_DEFAULT);\n\
    +      #else\n+      raw_parsetree_list = raw_parser(query_string);\n+      #endif\n\
    +    }\n+    PG_CATCH ();\n+    {\n+      return NULL;\n+    }\n+    PG_END_TRY();\n\
    +\n+    /* accept only one statement */\n+    if ( list_length(raw_parsetree_list)\
    \ != 1 ) return NULL;\n+\n+    /* walk throught the parse tree, down to the FuncCall\
    \ node (if present) */\n+    #if PG_VERSION_NUM >= 100000\n+    stmt = (SelectStmt\
    \ *) linitial_node(RawStmt, raw_parsetree_list)->stmt;\n+    #else\n+    stmt\
    \ = (SelectStmt *) linitial(raw_parsetree_list);\n+    #endif\n+\n+    /* accept\
    \ only one target in the statement */\n+    if ( list_length(stmt->targetList)\
    \ != 1 ) return NULL;\n+\n+    restarget = (ResTarget *) linitial(stmt->targetList);\n\
    +    return (Node *) restarget->val;\n+}\n+\n /*\n  * Post-parse-analysis hook:\
    \ mask query\n  * https://github.com/taminomara/psql-hooks/blob/master/Detailed.md#post_parse_analyze_hook\n"
  identifiers: CVE:["CVE-2024-2338"],CWE:["CWE-89"]
  overview: 'Affected versions of this package are vulnerable to SQL Injection via
    the implementation of dynamic masking, which allows complex expressions to be
    provided as a value. These expressions are later used to create masked views,
    leading to an exploit where a user who owns a table can elevate their privileges
    to superuser after the label is created. '
  references:
    GitLab Commit: https://gitlab.com/dalibo/postgresql_anonymizer/-/commit/f55daadba3fa8226029687964aa8889d01a79778
  title: SQL Injection
- diff_content:
  - "--- a/src/interface/interface_backend_udev.c\n+++ b/src/interface/interface_backend_udev.c\n\
    @@ -222,7 +222,7 @@ udevListInterfacesByStatus(virConnectPtr conn,\n         g_autoptr(virInterfaceDef)\
    \ def = NULL;\n \n         /* Ensure we won't exceed the size of our array */\n\
    -        if (count > names_len)\n+        if (count >= names_len)\n          \
    \   break;\n \n         path = udev_list_entry_get_name(dev_entry);"
  identifiers: CVE:["CVE-2024-1441"],CWE:["CWE-193"]
  overview: Affected versions of this package are vulnerable to Off-by-one Error in
    `udevListInterfacesByStatus`. An attacker can cause a denial of service by exploiting
    this flaw.
  references:
    GitHub Commit: https://github.com/libvirt/libvirt/commit/c664015fe3a7bf59db26686e9ed69af011c6ebb8
    RedHat Bugzilla Bug: https://bugzilla.redhat.com/show_bug.cgi?id=2263841
  title: Off-by-one Error
- diff_content:
  - "--- a/anon.c\n+++ b/anon.c\n@@ -28,6 +28,7 @@\n #include \"catalog/pg_namespace.h\"\
    \n #include \"catalog/namespace.h\"\n #include \"miscadmin.h\"\n+#include \"nodes/nodeFuncs.h\"\
    \n #include \"optimizer/planner.h\"\n #include \"tcop/utility.h\"\n #include \"\
    utils/acl.h\"\n@@ -91,6 +92,8 @@ static bool   pa_check_value(char * expr);\n\
    \ static char * pa_get_masking_policy_for_role(Oid roleid);\n static void   pa_masking_policy_object_relabel(const\
    \ ObjectAddress *object, const char *seclabel);\n static bool   pa_has_mask_in_policy(Oid\
    \ roleid, char *policy);\n+static bool   pa_has_untrusted_schema(Node *node, void\
    \ *context);\n+static bool   pa_is_trusted_namespace(Oid namespaceId, char * policy);\n\
    \ static void   pa_rewrite(Query * query, char * policy);\n static void   pa_rewrite_utility(PlannedStmt\
    \ *pstmt, char * policy);\n static char * pa_cast_as_regtype(char * value, int\
    \ atttypid);\n@@ -624,13 +628,65 @@ pa_check_function(char * expr)\n \n     if\
    \ (! IsA(fc, FuncCall)) return false;\n \n+    elog(DEBUG1,\"expr is a function\"\
    );\n+\n     /* if the function name is not qualified, we cant check the schema\
    \ */\n-    if ( guc_anon_restrict_to_trusted_schemas\n-    && list_length(fc->funcname)\
    \ != 2 ) return false;\n+    if ( guc_anon_restrict_to_trusted_schemas) {\n+\n\
    +      if (list_length(fc->funcname) != 2 ) return false;\n+\n+      elog(DEBUG1,\"\
    expr is qualified\");\n \n+      if (pa_has_untrusted_schema((Node *)fc,NULL))\
    \ return false;\n+    }\n     return true;\n }\n \n+static bool\n+pa_has_untrusted_schema(Node\
    \ *node, void *context)\n+{\n+  if (node == NULL) return false;\n+\n+  if (IsA(node,\
    \ FuncCall))\n+  {\n+    FuncCall * fc = (FuncCall *) node;\n+    Oid namespaceId;\n\
    +\n+    // the function is not qualified, we cannot trust it\n+    if ( list_length(fc->funcname)\
    \ != 2 ) return true;\n+\n+    namespaceId = get_namespace_oid(strVal(linitial(fc->funcname)),false);\n\
    +\n+    // Returning true will stop the tree walker right away\n+    // So the\
    \ logic is inverted: we stop the search once an unstrusted schema\n+    // is\
    \ found.\n+    if ( ! pa_is_trusted_namespace(namespaceId,\"anon\") ) return true;\n\
    +  }\n+\n+  return raw_expression_tree_walker(node,\n+                       \
    \             pa_has_untrusted_schema,\n+                                    context);\n\
    +}\n+\n+\n+/*\n+ * pa_schema_is_trusted\n+ *  checks that a schema is declared\
    \ as trusted\n+ *\n+ */\n+static bool\n+pa_is_trusted_namespace(Oid namespaceId,\
    \ char * policy)\n+{\n+  ObjectAddress namespace;\n+  char * seclabel = NULL;\n\
    +\n+  if (! OidIsValid(namespaceId)) return false;\n+\n+  ObjectAddressSet(namespace,\
    \ NamespaceRelationId, namespaceId);\n+  seclabel = GetSecurityLabel(&namespace,\
    \ policy);\n+\n+  return (seclabel && pg_strncasecmp(seclabel, \"TRUSTED\",7)\
    \ == 0);\n+}\n \n /*\n  * pa_check_masking_policies\n"
  identifiers: CVE:["CVE-2024-2339"],CWE:["CWE-20"]
  overview: 'Affected versions of this package are vulnerable to Improper Input Validation
    via the implementation of a masking function for a column that allows malicious
    code insertion. An attacker can execute arbitrary code and potentially escalate
    privileges by defining a malicious masking function that is executed when privileged
    users apply masking rules using static masking or the anonymous dump method. '
  references:
    GitLab Commit: https://gitlab.com/dalibo/postgresql_anonymizer/-/commit/e517b38e62e50871b04011598e73a7308bdae9d9
  title: Improper Input Validation
- diff_content:
  - "--- a/src/osdp_cp.c\n+++ b/src/osdp_cp.c\n@@ -639,6 +639,10 @@ static int cp_decode_response(struct\
    \ osdp_pd *pd, uint8_t *buf, int len)\n \t\tret = osdp_file_cmd_stat_decode(pd,\
    \ buf + pos, len);\n \t\tbreak;\n \tcase REPLY_CCRYPT:\n+\t\tif (sc_is_active(pd)\
    \ || pd->cmd_id != CMD_CHLNG) {\n+\t\t\tLOG_EM(\"Out of order REPLY_CCRYPT; has\
    \ PD gone rogue?\");\n+\t\t\tbreak;\n+\t\t}\n \t\tif (len != REPLY_CCRYPT_DATA_LEN)\
    \ {\n \t\t\tbreak;\n \t\t}\n@@ -654,6 +658,10 @@ static int cp_decode_response(struct\
    \ osdp_pd *pd, uint8_t *buf, int len)\n \t\tret = OSDP_CP_ERR_NONE;\n \t\tbreak;\n\
    \ \tcase REPLY_RMAC_I:\n+\t\tif (sc_is_active(pd) || pd->cmd_id != CMD_SCRYPT)\
    \ {\n+\t\t\tLOG_EM(\"Out of order REPLY_RMAC_I; has PD gone rogue?\");\n+\t\t\t\
    break;\n+\t\t}\n \t\tif (len != REPLY_RMAC_I_DATA_LEN) {\n \t\t\tbreak;\n \t\t\
    }"
  - "--- a/src/osdp_pd.c\n+++ b/src/osdp_pd.c\n@@ -621,7 +621,7 @@ static int pd_decode_command(struct\
    \ osdp_pd *pd, uint8_t *buf, int len)\n \t\tif (sc_is_active(pd)) {\n \t\t\tpd->reply_id\
    \ = REPLY_NAK;\n \t\t\tpd->ephemeral_data[0] = OSDP_PD_NAK_SC_COND;\n-\t\t\tLOG_WRN(\"\
    Out of order CMD_SCRYPT; has CP gone rogue?\");\n+\t\t\tLOG_EM(\"Out of order\
    \ CMD_SCRYPT; has CP gone rogue?\");\n \t\t\tbreak;\n \t\t}\n \t\tmemcpy(pd->sc.cp_cryptogram,\
    \ buf + pos, CMD_SCRYPT_DATA_LEN);"
  identifiers: CVE:[],CWE:["CWE-20"]
  overview: 'Affected versions of this package are vulnerable to Improper Input Validation
    in the `osdp_phy.c` and `osdp_cp.c` components. '
  references:
    GitHub Commit: https://github.com/goToMain/libosdp/commit/298576d9214b48214092eebdd892ec77be085e5a
  title: Improper Input Validation
- diff_content:
  - "--- a/src/osdp_common.c\n+++ b/src/osdp_common.c\n@@ -120,7 +120,7 @@ const char\
    \ *osdp_reply_name(int reply_id)\n \t\treturn \"INVALID\";\n \t}\n \tname = names[reply_id\
    \ - REPLY_ACK];\n-\tif (name[0] == '\\0') {\n+\tif (!name) {\n \t\treturn \"UNKNOWN\"\
    ;\n \t}\n \treturn name;"
  identifiers: CVE:[],CWE:["CWE-476"]
  overview: 'Affected versions of this package are vulnerable to NULL Pointer Dereference
    in `osdp_reply_name`. An attacker can cause a crash and achieve a denial of service
    by sending an undefined reply id within a certain range, which leads to accessing
    a null pointer as if it were valid memory. '
  references:
    GitHub Commit: https://github.com/goToMain/libosdp/commit/24409e98a260176765956ec766a04cb35984fab1
  title: NULL Pointer Dereference
- diff_content:
  - "--- a/src/filters/dmx_dash.c\n+++ b/src/filters/dmx_dash.c\n@@ -1136,8 +1136,8\
    \ @@ GF_Err dashdmx_io_on_dash_event(GF_DASHFileIO *dashio, GF_DASHEventType dash_evt\n\
    \ \t\t\t\tif (! gf_dash_group_enum_descriptor(ctx->dash, i, GF_MPD_DESC_ESSENTIAL_PROPERTIES,\
    \ j, &desc_id, &desc_scheme, &desc_value))\n \t\t\t\t\tbreak;\n \t\t\t\tj++;\n\
    -\t\t\t\tif (!strcmp(desc_scheme, \"urn:mpeg:dash:srd:2014\")) {\n-\t\t\t\t} else\
    \ if (!strcmp(desc_scheme, \"http://dashif.org/guidelines/trickmode\")) {\n+\t\
    \t\t\tif (desc_scheme && !strcmp(desc_scheme, \"urn:mpeg:dash:srd:2014\")) {\n\
    +\t\t\t\t} else if (desc_scheme && !strcmp(desc_scheme, \"http://dashif.org/guidelines/trickmode\"\
    )) {\n \t\t\t\t} else {\n \t\t\t\t\tplayable = GF_FALSE;\n \t\t\t\t\tbreak;"
  - "--- a/src/media_tools/dash_client.c\n+++ b/src/media_tools/dash_client.c\n@@\
    \ -6330,6 +6330,11 @@ static GF_Err gf_dash_setup_period(GF_DashClient *dash)\n\
    \ \n \t\tfor (j=0; j<gf_list_count(group->adaptation_set->essential_properties);\
    \ j++) {\n \t\t\tGF_MPD_Descriptor *mpd_desc = gf_list_get(group->adaptation_set->essential_properties,\
    \ j);\n+\t\t\tif (!mpd_desc->scheme_id_uri) {\n+\t\t\t\tGF_LOG(GF_LOG_WARNING,\
    \ GF_LOG_DASH, (\"[DASH] AdaptationSet with unrecognized EssentialProperty (no\
    \ uri) - ignoring because not supported\\n\"));\n+\t\t\t\tdisabled = 1;\n+\t\t\
    \t\tbreak;\n+\t\t\t}\n \t\t\tif (!strcmp(mpd_desc->scheme_id_uri, \"urn:mpeg:dash:srd:2014\"\
    )) {\n \t\t\t\tu32 id, w, h, res;\n \t\t\t\tw = h = 0;"
  identifiers: CVE:["CVE-2023-46427"],CWE:["CWE-476"]
  overview: Affected versions of this package are vulnerable to NULL Pointer Dereference
    due to a null pointer dereference in the `gf_dash_setup_period` component in media_tools/dash_client.c.
    An attacker can execute arbitrary code, cause a denial of service, and obtain
    sensitive information by sending a crafted input to the affected component.
  references:
    GitHub Commit: https://github.com/gpac/gpac/commit/ed8424300fc4a1f5231ecd1d47f502ddd3621d1a
    GitHub Issue: https://github.com/gpac/gpac/issues/2641
  title: NULL Pointer Dereference
- diff_content:
  - "--- a/src/scene_manager/swf_parse.c\n+++ b/src/scene_manager/swf_parse.c\n@@\
    \ -2082,7 +2082,7 @@ static GF_Err swf_def_bits_jpeg(SWFReader *read, u32 version)\n\
    \ \tif (version!=3)\n \t\tfile = gf_fopen(szName, \"wb\");\n \n-\tif (version==1\
    \ && read->jpeg_hdr_size) {\n+\tif (version==1 && read->jpeg_hdr_size >= 2) {\n\
    \ \t\t/*remove JPEG EOI*/\n \t\tif (gf_fwrite(read->jpeg_hdr, read->jpeg_hdr_size-2,\
    \ file)!=read->jpeg_hdr_size-2)\n \t\t\treturn GF_IO_ERR;"
  identifiers: CVE:["CVE-2023-46426"],CWE:["CWE-122"]
  overview: Affected versions of this package are vulnerable to Heap-based Buffer
    Overflow due to improper handling in the `gf_fwrite` component at utils/os_file.c.
    An attacker can execute arbitrary code and cause a denial of service by sending
    specially crafted input to the affected component.
  references:
    GitHub Commit: https://github.com/gpac/gpac/commit/14ec709a1ffae23ad777c37320290caa0a754341
    GitHub Issue: https://github.com/gpac/gpac/issues/2642
  title: Heap-based Buffer Overflow
- diff_content:
  - "--- a/expat/lib/xmlparse.c\n+++ b/expat/lib/xmlparse.c\n@@ -7787,14 +7787,18\
    \ @@ copyString(const XML_Char *s, const XML_Memory_Handling_Suite *memsuite)\
    \ {\n \n static float\n accountingGetCurrentAmplification(XML_Parser rootParser)\
    \ {\n+  //                                          1.........1.........12 =>\
    \ 22\n+  const size_t lenOfShortestInclude = sizeof(\"<!ENTITY a SYSTEM 'b'>\"\
    ) - 1;\n   const XmlBigCount countBytesOutput\n       = rootParser->m_accounting.countBytesDirect\n\
    \         + rootParser->m_accounting.countBytesIndirect;\n   const float amplificationFactor\n\
    \       = rootParser->m_accounting.countBytesDirect\n             ? (countBytesOutput\n\
    \                / (float)(rootParser->m_accounting.countBytesDirect))\n-    \
    \        : 1.0f;\n+            : ((lenOfShortestInclude\n+                + rootParser->m_accounting.countBytesIndirect)\n\
    +               / (float)lenOfShortestInclude);\n   assert(! rootParser->m_parentParser);\n\
    \   return amplificationFactor;\n }"
  - "--- a/expat/tests/acc_tests.c\n+++ b/expat/tests/acc_tests.c\n@@ -378,6 +378,63\
    \ @@ START_TEST(test_helper_unsigned_char_to_printable) {\n     fail(\"unsignedCharToPrintable\
    \ result mistaken\");\n }\n END_TEST\n+\n+START_TEST(test_amplification_isolated_external_parser)\
    \ {\n+  // NOTE: Length 44 is precisely twice the length of \"<!ENTITY a SYSTEM\
    \ 'b'>\"\n+  // (22) that is used in function accountingGetCurrentAmplification\
    \ in\n+  // xmlparse.c.\n+  //                  1.........1.........1.........1.........1..4\
    \ => 44\n+  const char doc[] = \"<!ENTITY % p1 '123456789_123456789_1234567'>\"\
    ;\n+  const int docLen = (int)sizeof(doc) - 1;\n+  const float maximumToleratedAmplification\
    \ = 2.0f;\n+\n+  struct TestCase {\n+    int offsetOfThreshold;\n+    enum XML_Status\
    \ expectedStatus;\n+  };\n+\n+  struct TestCase cases[] = {\n+      {-2, XML_STATUS_ERROR},\
    \ {-1, XML_STATUS_ERROR}, {0, XML_STATUS_ERROR},\n+      {+1, XML_STATUS_OK},\
    \    {+2, XML_STATUS_OK},\n+  };\n+\n+  for (size_t i = 0; i < sizeof(cases) /\
    \ sizeof(cases[0]); i++) {\n+    const int offsetOfThreshold = cases[i].offsetOfThreshold;\n\
    +    const enum XML_Status expectedStatus = cases[i].expectedStatus;\n+    const\
    \ unsigned long long activationThresholdBytes\n+        = docLen + offsetOfThreshold;\n\
    +\n+    set_subtest(\"offsetOfThreshold=%d, expectedStatus=%d\", offsetOfThreshold,\n\
    +                expectedStatus);\n+\n+    XML_Parser parser = XML_ParserCreate(NULL);\n\
    +    assert_true(parser != NULL);\n+\n+    assert_true(XML_SetBillionLaughsAttackProtectionMaximumAmplification(\n\
    +                    parser, maximumToleratedAmplification)\n+               \
    \ == XML_TRUE);\n+    assert_true(XML_SetBillionLaughsAttackProtectionActivationThreshold(\n\
    +                    parser, activationThresholdBytes)\n+                == XML_TRUE);\n\
    +\n+    XML_Parser ext_parser = XML_ExternalEntityParserCreate(parser, NULL, NULL);\n\
    +    assert_true(ext_parser != NULL);\n+\n+    const enum XML_Status actualStatus\n\
    +        = _XML_Parse_SINGLE_BYTES(ext_parser, doc, docLen, XML_TRUE);\n+\n+ \
    \   assert_true(actualStatus == expectedStatus);\n+    if (actualStatus != XML_STATUS_OK)\
    \ {\n+      assert_true(XML_GetErrorCode(ext_parser)\n+                  == XML_ERROR_AMPLIFICATION_LIMIT_BREACH);\n\
    +    }\n+\n+    XML_ParserFree(ext_parser);\n+    XML_ParserFree(parser);\n+ \
    \ }\n+}\n+END_TEST\n+\n #endif // XML_GE == 1\n \n void\n@@ -390,6 +447,8 @@ make_accounting_test_case(Suite\
    \ *s) {\n   tcase_add_test(tc_accounting, test_accounting_precision);\n   tcase_add_test(tc_accounting,\
    \ test_billion_laughs_attack_protection_api);\n   tcase_add_test(tc_accounting,\
    \ test_helper_unsigned_char_to_printable);\n+  tcase_add_test__ifdef_xml_dtd(tc_accounting,\n\
    +                                test_amplification_isolated_external_parser);\n\
    \ #else\n   UNUSED_P(s);\n #endif /* XML_GE == 1 */"
  identifiers: CVE:["CVE-2024-28757"],CWE:["CWE-776"]
  overview: Affected versions of this package are vulnerable to Improper Restriction
    of Recursive Entity References in DTDs ('XML Entity Expansion'). An attacker can
    cause a denial of service by submitting specially crafted XML content.
  references:
    GitHub Commit: https://github.com/libexpat/libexpat/commit/5026213864ba1a11ef03ba2e8111af8654e9404d
    GitHub Issue: https://github.com/libexpat/libexpat/issues/839
    RedHat Bugzilla Bug: https://bugzilla.redhat.com/show_bug.cgi?id=2268766
  title: Improper Restriction of Recursive Entity References in DTDs ('XML Entity
    Expansion')
- diff_content:
  - "--- a/lustre/llite/rw26.c\n+++ b/lustre/llite/rw26.c\n@@ -243,11 +243,7 @@ static\
    \ ssize_t ll_get_user_pages(int rw, struct iov_iter *iter,\n \tsize_t start;\n\
    \ \tsize_t result;\n \n-\t/*\n-\t * iov_iter_get_pages_alloc() is introduced in\
    \ 3.16 similar\n-\t * to HAVE_DIO_ITER.\n-\t */\n-\tresult = iov_iter_get_pages_alloc(iter,\
    \ pages, maxsize, &start);\n+\tresult = iov_iter_get_pages_alloc2(iter, pages,\
    \ maxsize, &start);\n \tif (result > 0)\n \t\t*npages = DIV_ROUND_UP(result +\
    \ start, PAGE_SIZE);\n \n@@ -979,12 +975,12 @@ static int ll_write_end(struct\
    \ file *file, struct address_space *mapping,\n }\n \n #ifdef CONFIG_MIGRATION\n\
    -static int ll_migratepage(struct address_space *mapping,\n-\t\t\t  struct page\
    \ *newpage, struct page *page,\n-\t\t\t  enum migrate_mode mode)\n+static int\
    \ ll_migrate_folio(struct address_space *mapping,\n+\t\t\t    struct folio_migr\
    \ *newpage, struct folio_migr *page,\n+\t\t\t    enum migrate_mode mode)\n {\n\
    -        /* Always fail page migration until we have a proper implementation */\n\
    -        return -EIO;\n+\t/* Always fail page migration until we have a proper\
    \ implementation */\n+\treturn -EIO;\n }\n #endif\n \n@@ -1015,6 +1011,6 @@ const\
    \ struct address_space_operations ll_aops = {\n \t.write_begin\t\t= ll_write_begin,\n\
    \ \t.write_end\t\t= ll_write_end,\n #ifdef CONFIG_MIGRATION\n-\t.migratepage\t\
    \t= ll_migratepage,\n+\t.migrate_folio\t\t= ll_migrate_folio,\n #endif\n };"
  identifiers: CVE:["CVE-2023-51786"],CWE:["CWE-284"]
  overview: Affected versions of this package are vulnerable to Improper Access Control
    in handling user/group IDs with greater permissions than the individual user who
    holds them. A user can access files accessible to the client that they should
    not be authorized to access.
  references:
    GitHub Commit: https://github.com/lustre/lustre-release/commit/a9ac77e9fcf75c4aac11a3c61852d4f7d5dda835
    Vulnerability Advisory: http://lists.lustre.org/pipermail/lustre-announce-lustre.org/2024/000270.html
  title: Improper Access Control
- diff_content:
  - "--- a/util/data/msgencode.c\n+++ b/util/data/msgencode.c\n@@ -886,6 +886,9 @@\
    \ ede_trim_text(struct edns_option** list)\n \t\t\t\tcurr->opt_len = 2;\n \t\t\
    \t\tprev = curr;\n \t\t\t\tcurr = curr->next;\n+\t\t\t} else {\n+\t\t\t\tprev\
    \ = curr;\n+\t\t\t\tcurr = curr->next;\n \t\t\t}\n \t\t} else {\n \t\t\t/* continue\
    \ */"
  identifiers: CVE:["CVE-2024-1931"],CWE:["CWE-835"]
  overview: Affected versions of this package are vulnerable to Loop with Unreachable
    Exit Condition ('Infinite Loop') due to improper EDE message size check. An attacker
    can cause a denial of service condition by sending a specially crafted message
    that triggers an infinite loop.
  references:
    GitHub Commit: https://github.com/NLnetLabs/unbound/commit/5b37cd6e4cf1aafe0cce4de792c42bc5a0fcdf57
  title: Loop with Unreachable Exit Condition ('Infinite Loop')
- diff_content:
  - "--- a/src/rule.c\n+++ b/src/rule.c\n@@ -880,8 +880,10 @@ zlog_rule_t *zlog_rule_new(char\
    \ *line,\n \t\t}\n \t\tbreak;\n \tcase '$' :\n-\t\tsscanf(file_path + 1, \"%s\"\
    , a_rule->record_name);\n-\t\t\t\n+\t\t// read only MAXLEN_PATH characters from\
    \ the file_path + 1\n+\t\tstrncpy(a_rule->record_name, file_path + 1, MAXLEN_PATH);\n\
    +\t\ta_rule->record_name[MAXLEN_PATH] = '\\0';\n+\t\t\n \t\tif (file_limit) {\
    \  /* record path exists */\n \t\t\tp = strchr(file_limit, '\"');\n \t\t\tif (!p)\
    \ {"
  identifiers: CVE:["CVE-2024-22857"],CWE:["CWE-122"]
  overview: Affected versions of this package are vulnerable to Heap-based Buffer
    Overflow due to improper handling of a configuration file when creating a new
    rule that is already defined, in the `zlog_rule_s` structure. A regular user can
    achieve arbitrary code execution.
  references:
    Additional Information: https://www.cybersecurity-help.cz/vdb/SB2024022842
    GitHub Commit: https://github.com/HardySimpson/zlog/commit/c47f781a9f1e9604f5201e27d046d925d0d48ac4
    Vulnerable Code: https://github.com/HardySimpson/zlog/blob/1a7b1a6fb956b92a4079ccc91f30da21f34ca063/src/rule.h#L30
  title: Heap-based Buffer Overflow
- diff_content:
  - "--- a/portable/ARMv8M/non_secure/port.c\n+++ b/portable/ARMv8M/non_secure/port.c\n\
    @@ -472,6 +472,15 @@ portDONT_DISCARD void vPortSVCHandler_C( uint32_t * pulCallerStackAddress\
    \ ) PRIV\n #endif /* configENABLE_MPU == 1 */\n /*-----------------------------------------------------------*/\n\
    \ \n+#if ( ( configENABLE_MPU == 1 ) && ( configUSE_MPU_WRAPPERS_V1 == 0 ) &&\
    \ ( configENABLE_ACCESS_CONTROL_LIST == 1 ) )\n+\n+/**\n+ * @brief This variable\
    \ is set to pdTRUE when the scheduler is started.\n+ */\n+    PRIVILEGED_DATA\
    \ static BaseType_t xSchedulerRunning = pdFALSE;\n+\n+#endif\n+\n /**\n  * @brief\
    \ Each task maintains its own interrupt status in the critical nesting\n  * variable.\n\
    @@ -1651,6 +1660,12 @@ BaseType_t xPortStartScheduler( void ) /* PRIVILEGED_FUNCTION\
    \ */\n     /* Initialize the critical nesting count ready for the first task.\
    \ */\n     ulCriticalNesting = 0;\n \n+    #if ( ( configENABLE_MPU == 1 ) &&\
    \ ( configUSE_MPU_WRAPPERS_V1 == 0 ) && ( configENABLE_ACCESS_CONTROL_LIST ==\
    \ 1 ) )\n+    {\n+        xSchedulerRunning = pdTRUE;\n+    }\n+    #endif\n+\n\
    \     /* Start the first task. */\n     vStartFirstTask();\n \n@@ -1931,3 +1946,98\
    \ @@ BaseType_t xPortIsInsideInterrupt( void )\n \n #endif /* #if ( ( configASSERT_DEFINED\
    \ == 1 ) && ( portHAS_BASEPRI == 1 ) ) */\n /*-----------------------------------------------------------*/\n\
    +\n+#if ( ( configENABLE_MPU == 1 ) && ( configUSE_MPU_WRAPPERS_V1 == 0 ) && (\
    \ configENABLE_ACCESS_CONTROL_LIST == 1 ) )\n+\n+    void vPortGrantAccessToKernelObject(\
    \ TaskHandle_t xInternalTaskHandle,\n+                                       \
    \  int32_t lInternalIndexOfKernelObject ) /* PRIVILEGED_FUNCTION */\n+    {\n\
    +        uint32_t ulAccessControlListEntryIndex, ulAccessControlListEntryBit;\n\
    +        xMPU_SETTINGS * xTaskMpuSettings;\n+\n+        ulAccessControlListEntryIndex\
    \ = ( ( uint32_t ) lInternalIndexOfKernelObject / portACL_ENTRY_SIZE_BITS );\n\
    +        ulAccessControlListEntryBit = ( ( uint32_t ) lInternalIndexOfKernelObject\
    \ % portACL_ENTRY_SIZE_BITS );\n+\n+        xTaskMpuSettings = xTaskGetMPUSettings(\
    \ xInternalTaskHandle );\n+\n+        xTaskMpuSettings->ulAccessControlList[ ulAccessControlListEntryIndex\
    \ ] |= ( 1U << ulAccessControlListEntryBit );\n+    }\n+\n+#endif /* #if ( ( configENABLE_MPU\
    \ == 1 ) && ( configUSE_MPU_WRAPPERS_V1 == 0 ) && ( configENABLE_ACCESS_CONTROL_LIST\
    \ == 1 ) ) */\n+/*-----------------------------------------------------------*/\n\
    +\n+#if ( ( configENABLE_MPU == 1 ) && ( configUSE_MPU_WRAPPERS_V1 == 0 ) && (\
    \ configENABLE_ACCESS_CONTROL_LIST == 1 ) )\n+\n+    void vPortRevokeAccessToKernelObject(\
    \ TaskHandle_t xInternalTaskHandle,\n+                                       \
    \   int32_t lInternalIndexOfKernelObject ) /* PRIVILEGED_FUNCTION */\n+    {\n\
    +        uint32_t ulAccessControlListEntryIndex, ulAccessControlListEntryBit;\n\
    +        xMPU_SETTINGS * xTaskMpuSettings;\n+\n+        ulAccessControlListEntryIndex\
    \ = ( ( uint32_t ) lInternalIndexOfKernelObject / portACL_ENTRY_SIZE_BITS );\n\
    +        ulAccessControlListEntryBit = ( ( uint32_t ) lInternalIndexOfKernelObject\
    \ % portACL_ENTRY_SIZE_BITS );\n+\n+        xTaskMpuSettings = xTaskGetMPUSettings(\
    \ xInternalTaskHandle );\n+\n+        xTaskMpuSettings->ulAccessControlList[ ulAccessControlListEntryIndex\
    \ ] &= ~( 1U << ulAccessControlListEntryBit );\n+    }\n+\n+#endif /* #if ( (\
    \ configENABLE_MPU == 1 ) && ( configUSE_MPU_WRAPPERS_V1 == 0 ) && ( configENABLE_ACCESS_CONTROL_LIST\
    \ == 1 ) ) */\n+/*-----------------------------------------------------------*/\n\
    +\n+#if ( ( configENABLE_MPU == 1 ) && ( configUSE_MPU_WRAPPERS_V1 == 0 ) )\n\
    +\n+    #if ( configENABLE_ACCESS_CONTROL_LIST == 1 )\n+\n+        BaseType_t\
    \ xPortIsAuthorizedToAccessKernelObject( int32_t lInternalIndexOfKernelObject\
    \ ) /* PRIVILEGED_FUNCTION */\n+        {\n+            uint32_t ulAccessControlListEntryIndex,\
    \ ulAccessControlListEntryBit;\n+            BaseType_t xAccessGranted = pdFALSE;\n\
    +            const xMPU_SETTINGS * xTaskMpuSettings;\n+\n+            if( xSchedulerRunning\
    \ == pdFALSE )\n+            {\n+                /* Grant access to all the kernel\
    \ objects before the scheduler\n+                 * is started. It is necessary\
    \ because there is no task running\n+                 * yet and therefore, we\
    \ cannot use the permissions of any\n+                 * task. */\n+         \
    \       xAccessGranted = pdTRUE;\n+            }\n+            else\n+       \
    \     {\n+                xTaskMpuSettings = xTaskGetMPUSettings( NULL ); /* Calling\
    \ task's MPU settings. */\n+\n+                ulAccessControlListEntryIndex =\
    \ ( ( uint32_t ) lInternalIndexOfKernelObject / portACL_ENTRY_SIZE_BITS );\n+\
    \                ulAccessControlListEntryBit = ( ( uint32_t ) lInternalIndexOfKernelObject\
    \ % portACL_ENTRY_SIZE_BITS );\n+\n+                if( ( xTaskMpuSettings->ulTaskFlags\
    \ & portTASK_IS_PRIVILEGED_FLAG ) == portTASK_IS_PRIVILEGED_FLAG )\n+        \
    \        {\n+                    xAccessGranted = pdTRUE;\n+                }\n\
    +                else\n+                {\n+                    if( ( xTaskMpuSettings->ulAccessControlList[\
    \ ulAccessControlListEntryIndex ] & ( 1U << ulAccessControlListEntryBit ) ) !=\
    \ 0 )\n+                    {\n+                        xAccessGranted = pdTRUE;\n\
    +                    }\n+                }\n+            }\n+\n+            return\
    \ xAccessGranted;\n+        }\n+\n+    #else /* #if ( configENABLE_ACCESS_CONTROL_LIST\
    \ == 1 ) */\n+\n+        BaseType_t xPortIsAuthorizedToAccessKernelObject( int32_t\
    \ lInternalIndexOfKernelObject ) /* PRIVILEGED_FUNCTION */\n+        {\n+    \
    \        ( void ) lInternalIndexOfKernelObject;\n+\n+            /* If Access\
    \ Control List feature is not used, all the tasks have\n+             * access\
    \ to all the kernel objects. */\n+            return pdTRUE;\n+        }\n+\n\
    +    #endif /* #if ( configENABLE_ACCESS_CONTROL_LIST == 1 ) */\n+\n+#endif /*\
    \ #if ( ( configENABLE_MPU == 1 ) && ( configUSE_MPU_WRAPPERS_V1 == 0 ) ) */\n\
    +/*-----------------------------------------------------------*/"
  - "--- a/portable/Common/mpu_wrappers.c\n+++ b/portable/Common/mpu_wrappers.c\n\
    @@ -50,6 +50,10 @@\n \n #if ( ( portUSING_MPU_WRAPPERS == 1 ) && ( configUSE_MPU_WRAPPERS_V1\
    \ == 1 ) )\n \n+    #if ( configENABLE_ACCESS_CONTROL_LIST == 1 )\n+        #error\
    \ Access control list is not available with this MPU wrapper. Please set configENABLE_ACCESS_CONTROL_LIST\
    \ to 0.\n+    #endif\n+\n     #if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )\n\
    \         BaseType_t MPU_xTaskCreate( TaskFunction_t pvTaskCode,\n           \
    \                          const char * const pcName,"
  - "--- a/portable/Common/mpu_wrappers_v2.c\n+++ b/portable/Common/mpu_wrappers_v2.c\n\
    @@ -338,6 +338,76 @@\n     }\n /*-----------------------------------------------------------*/\n\
    \ \n+    #if ( configENABLE_ACCESS_CONTROL_LIST == 1 )\n+\n+        void vGrantAccessToKernelObject(\
    \ TaskHandle_t xExternalTaskHandle,\n+                                       \
    \  int32_t lExternalKernelObjectHandle ) /* PRIVILEGED_FUNCTION */\n+        {\n\
    +            int32_t lExternalTaskIndex;\n+            TaskHandle_t xInternalTaskHandle\
    \ = NULL;\n+\n+            if( IS_EXTERNAL_INDEX_VALID( lExternalKernelObjectHandle\
    \ ) != pdFALSE )\n+            {\n+                if( xExternalTaskHandle ==\
    \ NULL )\n+                {\n+                    vPortGrantAccessToKernelObject(\
    \ xExternalTaskHandle, CONVERT_TO_INTERNAL_INDEX( lExternalKernelObjectHandle\
    \ ) );\n+                }\n+                else\n+                {\n+     \
    \               lExternalTaskIndex = ( int32_t ) xExternalTaskHandle;\n+\n+  \
    \                  if( IS_EXTERNAL_INDEX_VALID( lExternalTaskIndex ) != pdFALSE\
    \ )\n+                    {\n+                        xInternalTaskHandle = MPU_GetTaskHandleAtIndex(\
    \ CONVERT_TO_INTERNAL_INDEX( lExternalTaskIndex ) );\n+\n+                   \
    \     if( xInternalTaskHandle != NULL )\n+                        {\n+       \
    \                     vPortGrantAccessToKernelObject( xInternalTaskHandle,\n+\
    \                                                            CONVERT_TO_INTERNAL_INDEX(\
    \ lExternalKernelObjectHandle ) );\n+                        }\n+            \
    \        }\n+                }\n+            }\n+        }\n+\n+    #endif /*\
    \ #if ( configENABLE_ACCESS_CONTROL_LIST == 1 ) */\n+/*-----------------------------------------------------------*/\n\
    +\n+    #if ( configENABLE_ACCESS_CONTROL_LIST == 1 )\n+\n+        void vRevokeAccessToKernelObject(\
    \ TaskHandle_t xExternalTaskHandle,\n+                                       \
    \   int32_t lExternalKernelObjectHandle ) /* PRIVILEGED_FUNCTION */\n+       \
    \ {\n+            int32_t lExternalTaskIndex;\n+            TaskHandle_t xInternalTaskHandle\
    \ = NULL;\n+\n+            if( IS_EXTERNAL_INDEX_VALID( lExternalKernelObjectHandle\
    \ ) != pdFALSE )\n+            {\n+                if( xExternalTaskHandle ==\
    \ NULL )\n+                {\n+                    vPortRevokeAccessToKernelObject(\
    \ xExternalTaskHandle, CONVERT_TO_INTERNAL_INDEX( lExternalKernelObjectHandle\
    \ ) );\n+                }\n+                else\n+                {\n+     \
    \               lExternalTaskIndex = ( int32_t ) xExternalTaskHandle;\n+\n+  \
    \                  if( IS_EXTERNAL_INDEX_VALID( lExternalTaskIndex ) != pdFALSE\
    \ )\n+                    {\n+                        xInternalTaskHandle = MPU_GetTaskHandleAtIndex(\
    \ CONVERT_TO_INTERNAL_INDEX( lExternalTaskIndex ) );\n+\n+                   \
    \     if( xInternalTaskHandle != NULL )\n+                        {\n+       \
    \                     vPortRevokeAccessToKernelObject( xInternalTaskHandle,\n\
    +                                                             CONVERT_TO_INTERNAL_INDEX(\
    \ lExternalKernelObjectHandle ) );\n+                        }\n+            \
    \        }\n+                }\n+            }\n+        }\n+\n+    #endif /*\
    \ #if ( configENABLE_ACCESS_CONTROL_LIST == 1 ) */\n+/*-----------------------------------------------------------*/\n\
    +\n     #if ( configUSE_TIMERS == 1 )\n \n         static void MPU_TimerCallback(\
    \ TimerHandle_t xInternalHandle ) /* PRIVILEGED_FUNCTION */\n@@ -409,18 +479,24\
    \ @@\n         BaseType_t MPU_xTaskAbortDelayImpl( TaskHandle_t xTask ) /* PRIVILEGED_FUNCTION\
    \ */\n         {\n             BaseType_t xReturn = pdFAIL;\n+            BaseType_t\
    \ xCallingTaskIsAuthorizedToAccessTask = pdFALSE;\n             TaskHandle_t xInternalTaskHandle\
    \ = NULL;\n             int32_t lIndex;\n \n             lIndex = ( int32_t )\
    \ xTask;\n \n             if( IS_EXTERNAL_INDEX_VALID( lIndex ) != pdFALSE )\n\
    \             {\n-                xInternalTaskHandle = MPU_GetTaskHandleAtIndex(\
    \ CONVERT_TO_INTERNAL_INDEX( lIndex ) );\n+                xCallingTaskIsAuthorizedToAccessTask\
    \ = xPortIsAuthorizedToAccessKernelObject( CONVERT_TO_INTERNAL_INDEX( lIndex )\
    \ );\n \n-                if( xInternalTaskHandle != NULL )\n+               \
    \ if( xCallingTaskIsAuthorizedToAccessTask == pdTRUE )\n                 {\n-\
    \                    xReturn = xTaskAbortDelay( xInternalTaskHandle );\n+    \
    \                xInternalTaskHandle = MPU_GetTaskHandleAtIndex( CONVERT_TO_INTERNAL_INDEX(\
    \ lIndex ) );\n+\n+                    if( xInternalTaskHandle != NULL )\n+  \
    \                  {\n+                        xReturn = xTaskAbortDelay( xInternalTaskHandle\
    \ );\n+                    }\n                 }\n             }\n \n@@ -449,6\
    \ +525,7 @@\n         UBaseType_t MPU_uxTaskPriorityGetImpl( const TaskHandle_t\
    \ pxTask ) /* PRIVILEGED_FUNCTION */\n         {\n             UBaseType_t uxReturn\
    \ = configMAX_PRIORITIES;\n+            BaseType_t xCallingTaskIsAuthorizedToAccessTask\
    \ = pdFALSE;\n             int32_t lIndex;\n             TaskHandle_t xInternalTaskHandle\
    \ = NULL;\n \n@@ -462,11 +539,16 @@\n \n                 if( IS_EXTERNAL_INDEX_VALID(\
    \ lIndex ) != pdFALSE )\n                 {\n-                    xInternalTaskHandle\
    \ = MPU_GetTaskHandleAtIndex( CONVERT_TO_INTERNAL_INDEX( lIndex ) );\n+      \
    \              xCallingTaskIsAuthorizedToAccessTask = xPortIsAuthorizedToAccessKernelObject(\
    \ CONVERT_TO_INTERNAL_INDEX( lIndex ) );\n \n-                    if( xInternalTaskHandle\
    \ != NULL )\n+                    if( xCallingTaskIsAuthorizedToAccessTask ==\
    \ pdTRUE )\n                     {\n-                        uxReturn = uxTaskPriorityGet(\
    \ xInternalTaskHandle );\n+                        xInternalTaskHandle = MPU_GetTaskHandleAtIndex(\
    \ CONVERT_TO_INTERNAL_INDEX( lIndex ) );\n+\n+                        if( xInternalTaskHandle\
    \ != NULL )\n+                        {\n+                            uxReturn\
    \ = uxTaskPriorityGet( xInternalTaskHandle );\n+                        }\n  \
    \                   }\n                 }\n             }\n@@ -486,16 +568,22\
    \ @@\n             eTaskState eReturn = eInvalid;\n             TaskHandle_t xInternalTaskHandle\
    \ = NULL;\n             int32_t lIndex;\n+            BaseType_t xCallingTaskIsAuthorizedToAccessTask\
    \ = pdFALSE;\n \n             lIndex = ( int32_t ) pxTask;\n \n             if(\
    \ IS_EXTERNAL_INDEX_VALID( lIndex ) != pdFALSE )\n             {\n-          \
    \      xInternalTaskHandle = MPU_GetTaskHandleAtIndex( CONVERT_TO_INTERNAL_INDEX(\
    \ lIndex ) );\n+                xCallingTaskIsAuthorizedToAccessTask = xPortIsAuthorizedToAccessKernelObject(\
    \ CONVERT_TO_INTERNAL_INDEX( lIndex ) );\n \n-                if( xInternalTaskHandle\
    \ != NULL )\n+                if( xCallingTaskIsAuthorizedToAccessTask == pdTRUE\
    \ )\n                 {\n-                    eReturn = eTaskGetState( xInternalTaskHandle\
    \ );\n+                    xInternalTaskHandle = MPU_GetTaskHandleAtIndex( CONVERT_TO_INTERNAL_INDEX(\
    \ lIndex ) );\n+\n+                    if( xInternalTaskHandle != NULL )\n+  \
    \                  {\n+                        eReturn = eTaskGetState( xInternalTaskHandle\
    \ );\n+                    }\n                 }\n             }\n \n@@ -520,6\
    \ +608,7 @@\n             int32_t lIndex;\n             TaskHandle_t xInternalTaskHandle\
    \ = NULL;\n             BaseType_t xIsTaskStatusWriteable = pdFALSE;\n+      \
    \      BaseType_t xCallingTaskIsAuthorizedToAccessTask = pdFALSE;\n \n       \
    \      xIsTaskStatusWriteable = xPortIsAuthorizedToAccessBuffer( pxTaskStatus,\n\
    \                                                                       sizeof(\
    \ TaskStatus_t ),\n@@ -537,11 +626,16 @@\n \n                     if( IS_EXTERNAL_INDEX_VALID(\
    \ lIndex ) != pdFALSE )\n                     {\n-                        xInternalTaskHandle\
    \ = MPU_GetTaskHandleAtIndex( CONVERT_TO_INTERNAL_INDEX( lIndex ) );\n+      \
    \                  xCallingTaskIsAuthorizedToAccessTask = xPortIsAuthorizedToAccessKernelObject(\
    \ CONVERT_TO_INTERNAL_INDEX( lIndex ) );\n \n-                        if( xInternalTaskHandle\
    \ != NULL )\n+                        if( xCallingTaskIsAuthorizedToAccessTask\
    \ == pdTRUE )\n                         {\n-                            vTaskGetInfo(\
    \ xInternalTaskHandle, pxTaskStatus, xGetFreeStackSpace, eState );\n+        \
    \                    xInternalTaskHandle = MPU_GetTaskHandleAtIndex( CONVERT_TO_INTERNAL_INDEX(\
    \ lIndex ) );\n+\n+                            if( xInternalTaskHandle != NULL\
    \ )\n+                            {\n+                                vTaskGetInfo(\
    \ xInternalTaskHandle, pxTaskStatus, xGetFreeStackSpace, eState );\n+        \
    \                    }\n                         }\n                     }\n \
    \                }\n@@ -575,6 +669,7 @@\n         {\n             int32_t lIndex;\n\
    \             TaskHandle_t xInternalTaskHandle = NULL;\n+            BaseType_t\
    \ xCallingTaskIsAuthorizedToAccessTask = pdFALSE;\n \n             if( pxTaskToSuspend\
    \ == NULL )\n             {\n@@ -594,11 +689,16 @@\n \n                     if(\
    \ IS_EXTERNAL_INDEX_VALID( lIndex ) != pdFALSE )\n                     {\n-  \
    \                      xInternalTaskHandle = MPU_GetTaskHandleAtIndex( CONVERT_TO_INTERNAL_INDEX(\
    \ lIndex ) );\n+                        xCallingTaskIsAuthorizedToAccessTask =\
    \ xPortIsAuthorizedToAccessKernelObject( CONVERT_TO_INTERNAL_INDEX( lIndex ) );\n\
    \ \n-                        if( xInternalTaskHandle != NULL )\n+            \
    \            if( xCallingTaskIsAuthorizedToAccessTask == pdTRUE )\n          \
    \               {\n-                            vTaskSuspend( xInternalTaskHandle\
    \ );\n+                            xInternalTaskHandle = MPU_GetTaskHandleAtIndex(\
    \ CONVERT_TO_INTERNAL_INDEX( lIndex ) );\n+\n+                            if(\
    \ xInternalTaskHandle != NULL )\n+                            {\n+           \
    \                     vTaskSuspend( xInternalTaskHandle );\n+                \
    \            }\n                         }\n                     }\n         \
    \        }\n@@ -616,16 +716,22 @@\n         {\n             int32_t lIndex;\n\
    \             TaskHandle_t xInternalTaskHandle = NULL;\n+            BaseType_t\
    \ xCallingTaskIsAuthorizedToAccessTask = pdFALSE;\n \n             lIndex = (\
    \ int32_t ) pxTaskToResume;\n \n             if( IS_EXTERNAL_INDEX_VALID( lIndex\
    \ ) != pdFALSE )\n             {\n-                xInternalTaskHandle = MPU_GetTaskHandleAtIndex(\
    \ CONVERT_TO_INTERNAL_INDEX( lIndex ) );\n+                xCallingTaskIsAuthorizedToAccessTask\
    \ = xPortIsAuthorizedToAccessKernelObject( CONVERT_TO_INTERNAL_INDEX( lIndex )\
    \ );\n \n-                if( xInternalTaskHandle != NULL )\n+               \
    \ if( xCallingTaskIsAuthorizedToAccessTask == pdTRUE )\n                 {\n-\
    \                    vTaskResume( xInternalTaskHandle );\n+                  \
    \  xInternalTaskHandle = MPU_GetTaskHandleAtIndex( CONVERT_TO_INTERNAL_INDEX(\
    \ lIndex ) );\n+\n+                    if( xInternalTaskHandle != NULL )\n+  \
    \                  {\n+                        vTaskResume( xInternalTaskHandle\
    \ );\n+                    }\n                 }\n             }\n         }\n\
    @@ -697,6 +803,7 @@\n             configRUN_TIME_COUNTER_TYPE xReturn = 0;\n \
    \            int32_t lIndex;\n             TaskHandle_t xInternalTaskHandle =\
    \ NULL;\n+            BaseType_t xCallingTaskIsAuthorizedToAccessTask = pdFALSE;\n\
    \ \n             if( xTask == NULL )\n             {\n@@ -708,11 +815,16 @@\n\
    \ \n                 if( IS_EXTERNAL_INDEX_VALID( lIndex ) != pdFALSE )\n    \
    \             {\n-                    xInternalTaskHandle = MPU_GetTaskHandleAtIndex(\
    \ CONVERT_TO_INTERNAL_INDEX( lIndex ) );\n+                    xCallingTaskIsAuthorizedToAccessTask\
    \ = xPortIsAuthorizedToAccessKernelObject( CONVERT_TO_INTERNAL_INDEX( lIndex )\
    \ );\n \n-                    if( xInternalTaskHandle != NULL )\n+           \
    \         if( xCallingTaskIsAuthorizedToAccessTask == pdTRUE )\n             \
    \        {\n-                        xReturn = ulTaskGetRunTimeCounter( xInternalTaskHandle\
    \ );\n+                        xInternalTaskHandle = MPU_GetTaskHandleAtIndex(\
    \ CONVERT_TO_INTERNAL_INDEX( lIndex ) );\n+\n+                        if( xInternalTaskHandle\
    \ != NULL )\n+                        {\n+                            xReturn\
    \ = ulTaskGetRunTimeCounter( xInternalTaskHandle );\n+                       \
    \ }\n                     }\n                 }\n             }\n@@ -732,6 +844,7\
    \ @@\n             configRUN_TIME_COUNTER_TYPE xReturn = 0;\n             int32_t\
    \ lIndex;\n             TaskHandle_t xInternalTaskHandle = NULL;\n+          \
    \  BaseType_t xCallingTaskIsAuthorizedToAccessTask = pdFALSE;\n \n           \
    \  if( xTask == NULL )\n             {\n@@ -743,11 +856,16 @@\n \n           \
    \      if( IS_EXTERNAL_INDEX_VALID( lIndex ) != pdFALSE )\n                 {\n\
    -                    xInternalTaskHandle = MPU_GetTaskHandleAtIndex( CONVERT_TO_INTERNAL_INDEX(\
    \ lIndex ) );\n+                    xCallingTaskIsAuthorizedToAccessTask = xPortIsAuthorizedToAccessKernelObject(\
    \ CONVERT_TO_INTERNAL_INDEX( lIndex ) );\n \n-                    if( xInternalTaskHandle\
    \ != NULL )\n+                    if( xCallingTaskIsAuthorizedToAccessTask ==\
    \ pdTRUE )\n                     {\n-                        xReturn = ulTaskGetRunTimePercent(\
    \ xInternalTaskHandle );\n+                        xInternalTaskHandle = MPU_GetTaskHandleAtIndex(\
    \ CONVERT_TO_INTERNAL_INDEX( lIndex ) );\n+\n+                        if( xInternalTaskHandle\
    \ != NULL )\n+                        {\n+                            xReturn\
    \ = ulTaskGetRunTimePercent( xInternalTaskHandle );\n+                       \
    \ }\n                     }\n                 }\n             }\n@@ -800,6 +918,7\
    \ @@\n         {\n             TaskHandle_t xInternalTaskHandle = NULL;\n    \
    \         int32_t lIndex;\n+            BaseType_t xCallingTaskIsAuthorizedToAccessTask\
    \ = pdFALSE;\n \n             if( xTask == NULL )\n             {\n@@ -811,11\
    \ +930,16 @@\n \n                 if( IS_EXTERNAL_INDEX_VALID( lIndex ) != pdFALSE\
    \ )\n                 {\n-                    xInternalTaskHandle = MPU_GetTaskHandleAtIndex(\
    \ CONVERT_TO_INTERNAL_INDEX( lIndex ) );\n+                    xCallingTaskIsAuthorizedToAccessTask\
    \ = xPortIsAuthorizedToAccessKernelObject( CONVERT_TO_INTERNAL_INDEX( lIndex )\
    \ );\n \n-                    if( xInternalTaskHandle != NULL )\n+           \
    \         if( xCallingTaskIsAuthorizedToAccessTask == pdTRUE )\n             \
    \        {\n-                        vTaskSetApplicationTaskTag( xInternalTaskHandle,\
    \ pxTagValue );\n+                        xInternalTaskHandle = MPU_GetTaskHandleAtIndex(\
    \ CONVERT_TO_INTERNAL_INDEX( lIndex ) );\n+\n+                        if( xInternalTaskHandle\
    \ != NULL )\n+                        {\n+                            vTaskSetApplicationTaskTag(\
    \ xInternalTaskHandle, pxTagValue );\n+                        }\n           \
    \          }\n                 }\n             }\n@@ -833,6 +957,7 @@\n      \
    \       TaskHookFunction_t xReturn = NULL;\n             int32_t lIndex;\n   \
    \          TaskHandle_t xInternalTaskHandle = NULL;\n+            BaseType_t xCallingTaskIsAuthorizedToAccessTask\
    \ = pdFALSE;\n \n             if( xTask == NULL )\n             {\n@@ -844,11\
    \ +969,16 @@\n \n                 if( IS_EXTERNAL_INDEX_VALID( lIndex ) != pdFALSE\
    \ )\n                 {\n-                    xInternalTaskHandle = MPU_GetTaskHandleAtIndex(\
    \ CONVERT_TO_INTERNAL_INDEX( lIndex ) );\n+                    xCallingTaskIsAuthorizedToAccessTask\
    \ = xPortIsAuthorizedToAccessKernelObject( CONVERT_TO_INTERNAL_INDEX( lIndex )\
    \ );\n \n-                    if( xInternalTaskHandle != NULL )\n+           \
    \         if( xCallingTaskIsAuthorizedToAccessTask == pdTRUE )\n             \
    \        {\n-                        xReturn = xTaskGetApplicationTaskTag( xInternalTaskHandle\
    \ );\n+                        xInternalTaskHandle = MPU_GetTaskHandleAtIndex(\
    \ CONVERT_TO_INTERNAL_INDEX( lIndex ) );\n+\n+                        if( xInternalTaskHandle\
    \ != NULL )\n+                        {\n+                            xReturn\
    \ = xTaskGetApplicationTaskTag( xInternalTaskHandle );\n+                    \
    \    }\n                     }\n                 }\n             }\n@@ -871,6\
    \ +1001,7 @@\n         {\n             int32_t lIndex;\n             TaskHandle_t\
    \ xInternalTaskHandle = NULL;\n+            BaseType_t xCallingTaskIsAuthorizedToAccessTask\
    \ = pdFALSE;\n \n             if( xTaskToSet == NULL )\n             {\n@@ -882,11\
    \ +1013,16 @@\n \n                 if( IS_EXTERNAL_INDEX_VALID( lIndex ) != pdFALSE\
    \ )\n                 {\n-                    xInternalTaskHandle = MPU_GetTaskHandleAtIndex(\
    \ CONVERT_TO_INTERNAL_INDEX( lIndex ) );\n+                    xCallingTaskIsAuthorizedToAccessTask\
    \ = xPortIsAuthorizedToAccessKernelObject( CONVERT_TO_INTERNAL_INDEX( lIndex )\
    \ );\n \n-                    if( xInternalTaskHandle != NULL )\n+           \
    \         if( xCallingTaskIsAuthorizedToAccessTask == pdTRUE )\n             \
    \        {\n-                        vTaskSetThreadLocalStoragePointer( xInternalTaskHandle,\
    \ xIndex, pvValue );\n+                        xInternalTaskHandle = MPU_GetTaskHandleAtIndex(\
    \ CONVERT_TO_INTERNAL_INDEX( lIndex ) );\n+\n+                        if( xInternalTaskHandle\
    \ != NULL )\n+                        {\n+                            vTaskSetThreadLocalStoragePointer(\
    \ xInternalTaskHandle, xIndex, pvValue );\n+                        }\n      \
    \               }\n                 }\n             }\n@@ -906,6 +1042,7 @@\n\
    \             void * pvReturn = NULL;\n             int32_t lIndex;\n        \
    \     TaskHandle_t xInternalTaskHandle = NULL;\n+            BaseType_t xCallingTaskIsAuthorizedToAccessTask\
    \ = pdFALSE;\n \n             if( xTaskToQuery == NULL )\n             {\n@@ -917,11\
    \ +1054,16 @@\n \n                 if( IS_EXTERNAL_INDEX_VALID( lIndex ) != pdFALSE\
    \ )\n                 {\n-                    xInternalTaskHandle = MPU_GetTaskHandleAtIndex(\
    \ CONVERT_TO_INTERNAL_INDEX( lIndex ) );\n+                    xCallingTaskIsAuthorizedToAccessTask\
    \ = xPortIsAuthorizedToAccessKernelObject( CONVERT_TO_INTERNAL_INDEX( lIndex )\
    \ );\n \n-                    if( xInternalTaskHandle != NULL )\n+           \
    \         if( xCallingTaskIsAuthorizedToAccessTask == pdTRUE )\n             \
    \        {\n-                        pvReturn = pvTaskGetThreadLocalStoragePointer(\
    \ xInternalTaskHandle, xIndex );\n+                        xInternalTaskHandle\
    \ = MPU_GetTaskHandleAtIndex( CONVERT_TO_INTERNAL_INDEX( lIndex ) );\n+\n+   \
    \                     if( xInternalTaskHandle != NULL )\n+                   \
    \     {\n+                            pvReturn = pvTaskGetThreadLocalStoragePointer(\
    \ xInternalTaskHandle, xIndex );\n+                        }\n               \
    \      }\n                 }\n             }\n@@ -983,6 +1125,7 @@\n         \
    \    UBaseType_t uxReturn = 0;\n             int32_t lIndex;\n             TaskHandle_t\
    \ xInternalTaskHandle = NULL;\n+            BaseType_t xCallingTaskIsAuthorizedToAccessTask\
    \ = pdFALSE;\n \n             if( xTask == NULL )\n             {\n@@ -994,11\
    \ +1137,16 @@\n \n                 if( IS_EXTERNAL_INDEX_VALID( lIndex ) != pdFALSE\
    \ )\n                 {\n-                    xInternalTaskHandle = MPU_GetTaskHandleAtIndex(\
    \ CONVERT_TO_INTERNAL_INDEX( lIndex ) );\n+                    xCallingTaskIsAuthorizedToAccessTask\
    \ = xPortIsAuthorizedToAccessKernelObject( CONVERT_TO_INTERNAL_INDEX( lIndex )\
    \ );\n \n-                    if( xInternalTaskHandle != NULL )\n+           \
    \         if( xCallingTaskIsAuthorizedToAccessTask == pdTRUE )\n             \
    \        {\n-                        uxReturn = uxTaskGetStackHighWaterMark( xInternalTaskHandle\
    \ );\n+                        xInternalTaskHandle = MPU_GetTaskHandleAtIndex(\
    \ CONVERT_TO_INTERNAL_INDEX( lIndex ) );\n+\n+                        if( xInternalTaskHandle\
    \ != NULL )\n+                        {\n+                            uxReturn\
    \ = uxTaskGetStackHighWaterMark( xInternalTaskHandle );\n+                   \
    \     }\n                     }\n                 }\n             }\n@@ -1018,6\
    \ +1166,7 @@\n             configSTACK_DEPTH_TYPE uxReturn = 0;\n            \
    \ int32_t lIndex;\n             TaskHandle_t xInternalTaskHandle = NULL;\n+  \
    \          BaseType_t xCallingTaskIsAuthorizedToAccessTask = pdFALSE;\n \n   \
    \          if( xTask == NULL )\n             {\n@@ -1029,11 +1178,16 @@\n \n \
    \                if( IS_EXTERNAL_INDEX_VALID( lIndex ) != pdFALSE )\n        \
    \         {\n-                    xInternalTaskHandle = MPU_GetTaskHandleAtIndex(\
    \ CONVERT_TO_INTERNAL_INDEX( lIndex ) );\n+                    xCallingTaskIsAuthorizedToAccessTask\
    \ = xPortIsAuthorizedToAccessKernelObject( CONVERT_TO_INTERNAL_INDEX( lIndex )\
    \ );\n \n-                    if( xInternalTaskHandle != NULL )\n+           \
    \         if( xCallingTaskIsAuthorizedToAccessTask == pdTRUE )\n             \
    \        {\n-                        uxReturn = uxTaskGetStackHighWaterMark2(\
    \ xInternalTaskHandle );\n+                        xInternalTaskHandle = MPU_GetTaskHandleAtIndex(\
    \ CONVERT_TO_INTERNAL_INDEX( lIndex ) );\n+\n+                        if( xInternalTaskHandle\
    \ != NULL )\n+                        {\n+                            uxReturn\
    \ = uxTaskGetStackHighWaterMark2( xInternalTaskHandle );\n+                  \
    \      }\n                     }\n                 }\n             }\n@@ -1167,6\
    \ +1321,7 @@\n             int32_t lIndex;\n             TaskHandle_t xInternalTaskHandle\
    \ = NULL;\n             BaseType_t xIsPreviousNotificationValueWriteable = pdFALSE;\n\
    +            BaseType_t xCallingTaskIsAuthorizedToAccessTask = pdFALSE;\n    \
    \         BaseType_t xAreParamsReadable = pdFALSE;\n \n             if( pxParams\
    \ != NULL )\n@@ -1199,15 +1354,20 @@\n \n                         if( IS_EXTERNAL_INDEX_VALID(\
    \ lIndex ) != pdFALSE )\n                         {\n-                       \
    \     xInternalTaskHandle = MPU_GetTaskHandleAtIndex( CONVERT_TO_INTERNAL_INDEX(\
    \ lIndex ) );\n+                            xCallingTaskIsAuthorizedToAccessTask\
    \ = xPortIsAuthorizedToAccessKernelObject( CONVERT_TO_INTERNAL_INDEX( lIndex )\
    \ );\n \n-                            if( xInternalTaskHandle != NULL )\n+   \
    \                         if( xCallingTaskIsAuthorizedToAccessTask == pdTRUE )\n\
    \                             {\n-                                xReturn = xTaskGenericNotify(\
    \ xInternalTaskHandle,\n-                                                    \
    \          pxParams->uxIndexToNotify,\n-                                     \
    \                         pxParams->ulValue,\n-                              \
    \                                pxParams->eAction,\n-                       \
    \                                       pxParams->pulPreviousNotificationValue\
    \ );\n+                                xInternalTaskHandle = MPU_GetTaskHandleAtIndex(\
    \ CONVERT_TO_INTERNAL_INDEX( lIndex ) );\n+\n+                               \
    \ if( xInternalTaskHandle != NULL )\n+                                {\n+   \
    \                                 xReturn = xTaskGenericNotify( xInternalTaskHandle,\n\
    +                                                                  pxParams->uxIndexToNotify,\n\
    +                                                                  pxParams->ulValue,\n\
    +                                                                  pxParams->eAction,\n\
    +                                                                  pxParams->pulPreviousNotificationValue\
    \ );\n+                                }\n                             }\n   \
    \                      }\n                     }\n@@ -1320,6 +1480,7 @@\n    \
    \         BaseType_t xReturn = pdFAIL;\n             int32_t lIndex;\n       \
    \      TaskHandle_t xInternalTaskHandle = NULL;\n+            BaseType_t xCallingTaskIsAuthorizedToAccessTask\
    \ = pdFALSE;\n \n             if( uxIndexToClear < configTASK_NOTIFICATION_ARRAY_ENTRIES\
    \ )\n             {\n@@ -1333,11 +1494,16 @@\n \n                     if( IS_EXTERNAL_INDEX_VALID(\
    \ lIndex ) != pdFALSE )\n                     {\n-                        xInternalTaskHandle\
    \ = MPU_GetTaskHandleAtIndex( CONVERT_TO_INTERNAL_INDEX( lIndex ) );\n+      \
    \                  xCallingTaskIsAuthorizedToAccessTask = xPortIsAuthorizedToAccessKernelObject(\
    \ CONVERT_TO_INTERNAL_INDEX( lIndex ) );\n \n-                        if( xInternalTaskHandle\
    \ != NULL )\n+                        if( xCallingTaskIsAuthorizedToAccessTask\
    \ == pdTRUE )\n                         {\n-                            xReturn\
    \ = xTaskGenericNotifyStateClear( xInternalTaskHandle, uxIndexToClear );\n+  \
    \                          xInternalTaskHandle = MPU_GetTaskHandleAtIndex( CONVERT_TO_INTERNAL_INDEX(\
    \ lIndex ) );\n+\n+                            if( xInternalTaskHandle != NULL\
    \ )\n+                            {\n+                                xReturn\
    \ = xTaskGenericNotifyStateClear( xInternalTaskHandle, uxIndexToClear );\n+  \
    \                          }\n                         }\n                   \
    \  }\n                 }\n@@ -1362,6 +1528,7 @@\n             uint32_t ulReturn\
    \ = 0;\n             int32_t lIndex;\n             TaskHandle_t xInternalTaskHandle\
    \ = NULL;\n+            BaseType_t xCallingTaskIsAuthorizedToAccessTask = pdFALSE;\n\
    \ \n             if( uxIndexToClear < configTASK_NOTIFICATION_ARRAY_ENTRIES )\n\
    \             {\n@@ -1375,11 +1542,16 @@\n \n                     if( IS_EXTERNAL_INDEX_VALID(\
    \ lIndex ) != pdFALSE )\n                     {\n-                        xInternalTaskHandle\
    \ = MPU_GetTaskHandleAtIndex( CONVERT_TO_INTERNAL_INDEX( lIndex ) );\n+      \
    \                  xCallingTaskIsAuthorizedToAccessTask = xPortIsAuthorizedToAccessKernelObject(\
    \ CONVERT_TO_INTERNAL_INDEX( lIndex ) );\n \n-                        if( xInternalTaskHandle\
    \ != NULL )\n+                        if( xCallingTaskIsAuthorizedToAccessTask\
    \ == pdTRUE )\n                         {\n-                            ulReturn\
    \ = ulTaskGenericNotifyValueClear( xInternalTaskHandle, uxIndexToClear, ulBitsToClear\
    \ );\n+                            xInternalTaskHandle = MPU_GetTaskHandleAtIndex(\
    \ CONVERT_TO_INTERNAL_INDEX( lIndex ) );\n+\n+                            if(\
    \ xInternalTaskHandle != NULL )\n+                            {\n+           \
    \                     ulReturn = ulTaskGenericNotifyValueClear( xInternalTaskHandle,\
    \ uxIndexToClear, ulBitsToClear );\n+                            }\n         \
    \                }\n                     }\n                 }\n@@ -1463,6 +1635,17\
    \ @@\n                 if( xInternalTaskHandle != NULL )\n                 {\n\
    \                     MPU_StoreTaskHandleAtIndex( lIndex, xInternalTaskHandle\
    \ );\n+\n+                    #if ( configENABLE_ACCESS_CONTROL_LIST == 1 )\n\
    +                    {\n+                        /* By default, an unprivileged\
    \ task has access to itself. */\n+                        if( ( uxPriority & portPRIVILEGE_BIT\
    \ ) == 0 )\n+                        {\n+                            vPortGrantAccessToKernelObject(\
    \ xInternalTaskHandle, lIndex );\n+                        }\n+              \
    \      }\n+                    #endif\n+\n                     xExternalTaskHandle\
    \ = ( TaskHandle_t ) CONVERT_TO_EXTERNAL_INDEX( lIndex );\n                 }\n\
    \                 else\n@@ -1628,6 +1811,16 @@\n                 {\n         \
    \            MPU_StoreTaskHandleAtIndex( lIndex, xInternalTaskHandle );\n \n+\
    \                    #if ( configENABLE_ACCESS_CONTROL_LIST == 1 )\n+        \
    \            {\n+                        /* By default, an unprivileged task has\
    \ access to itself. */\n+                        if( ( pxTaskDefinition->uxPriority\
    \ & portPRIVILEGE_BIT ) == 0 )\n+                        {\n+                \
    \            vPortGrantAccessToKernelObject( xInternalTaskHandle, lIndex );\n\
    +                        }\n+                    }\n+                    #endif\n\
    +\n                     if( pxCreatedTask != NULL )\n                     {\n\
    \                         *pxCreatedTask = ( TaskHandle_t ) CONVERT_TO_EXTERNAL_INDEX(\
    \ lIndex );\n@@ -1664,6 +1857,16 @@\n                 {\n                    \
    \ MPU_StoreTaskHandleAtIndex( lIndex, xInternalTaskHandle );\n \n+           \
    \         #if ( configENABLE_ACCESS_CONTROL_LIST == 1 )\n+                   \
    \ {\n+                        /* By default, an unprivileged task has access to\
    \ itself. */\n+                        if( ( pxTaskDefinition->uxPriority & portPRIVILEGE_BIT\
    \ ) == 0 )\n+                        {\n+                            vPortGrantAccessToKernelObject(\
    \ xInternalTaskHandle, lIndex );\n+                        }\n+              \
    \      }\n+                    #endif\n+\n                     if( pxCreatedTask\
    \ != NULL )\n                     {\n                         *pxCreatedTask =\
    \ ( TaskHandle_t ) CONVERT_TO_EXTERNAL_INDEX( lIndex );\n@@ -1909,36 +2112,42\
    \ @@\n         QueueHandle_t xInternalQueueHandle = NULL;\n         BaseType_t\
    \ xReturn = pdFAIL;\n         BaseType_t xIsItemToQueueReadable = pdFALSE;\n+\
    \        BaseType_t xCallingTaskIsAuthorizedToAccessQueue = pdFALSE;\n       \
    \  UBaseType_t uxQueueItemSize, uxQueueLength;\n \n         lIndex = ( int32_t\
    \ ) xQueue;\n \n         if( IS_EXTERNAL_INDEX_VALID( lIndex ) != pdFALSE )\n\
    \         {\n-            xInternalQueueHandle = MPU_GetQueueHandleAtIndex( CONVERT_TO_INTERNAL_INDEX(\
    \ lIndex ) );\n+            xCallingTaskIsAuthorizedToAccessQueue = xPortIsAuthorizedToAccessKernelObject(\
    \ CONVERT_TO_INTERNAL_INDEX( lIndex ) );\n \n-            if( xInternalQueueHandle\
    \ != NULL )\n+            if( xCallingTaskIsAuthorizedToAccessQueue == pdTRUE\
    \ )\n             {\n-                uxQueueItemSize = uxQueueGetQueueItemSize(\
    \ xInternalQueueHandle );\n-                uxQueueLength = uxQueueGetQueueLength(\
    \ xInternalQueueHandle );\n+                xInternalQueueHandle = MPU_GetQueueHandleAtIndex(\
    \ CONVERT_TO_INTERNAL_INDEX( lIndex ) );\n \n-                if( ( !( ( pvItemToQueue\
    \ == NULL ) && ( uxQueueItemSize != ( UBaseType_t ) 0U ) ) ) &&\n-           \
    \         ( !( ( xCopyPosition == queueOVERWRITE ) && ( uxQueueLength != ( UBaseType_t\
    \ ) 1U ) ) )\n-                    #if ( ( INCLUDE_xTaskGetSchedulerState == 1\
    \ ) || ( configUSE_TIMERS == 1 ) )\n-                        && ( !( ( xTaskGetSchedulerState()\
    \ == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) )\n-               \
    \     #endif\n-                    )\n+                if( xInternalQueueHandle\
    \ != NULL )\n                 {\n-                    if( pvItemToQueue != NULL\
    \ )\n+                    uxQueueItemSize = uxQueueGetQueueItemSize( xInternalQueueHandle\
    \ );\n+                    uxQueueLength = uxQueueGetQueueLength( xInternalQueueHandle\
    \ );\n+\n+                    if( ( !( ( pvItemToQueue == NULL ) && ( uxQueueItemSize\
    \ != ( UBaseType_t ) 0U ) ) ) &&\n+                        ( !( ( xCopyPosition\
    \ == queueOVERWRITE ) && ( uxQueueLength != ( UBaseType_t ) 1U ) ) )\n+      \
    \                  #if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS\
    \ == 1 ) )\n+                            && ( !( ( xTaskGetSchedulerState() ==\
    \ taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) )\n+                  \
    \      #endif\n+                        )\n                     {\n-         \
    \               xIsItemToQueueReadable = xPortIsAuthorizedToAccessBuffer( pvItemToQueue,\n\
    -                                                                            \
    \      uxQueueGetQueueItemSize( xInternalQueueHandle ),\n-                   \
    \                                                               tskMPU_READ_PERMISSION\
    \ );\n-                    }\n+                        if( pvItemToQueue != NULL\
    \ )\n+                        {\n+                            xIsItemToQueueReadable\
    \ = xPortIsAuthorizedToAccessBuffer( pvItemToQueue,\n+                       \
    \                                                               uxQueueGetQueueItemSize(\
    \ xInternalQueueHandle ),\n+                                                 \
    \                                     tskMPU_READ_PERMISSION );\n+           \
    \             }\n \n-                    if( ( pvItemToQueue == NULL ) || ( xIsItemToQueueReadable\
    \ == pdTRUE ) )\n-                    {\n-                        xReturn = xQueueGenericSend(\
    \ xInternalQueueHandle, pvItemToQueue, xTicksToWait, xCopyPosition );\n+     \
    \                   if( ( pvItemToQueue == NULL ) || ( xIsItemToQueueReadable\
    \ == pdTRUE ) )\n+                        {\n+                            xReturn\
    \ = xQueueGenericSend( xInternalQueueHandle, pvItemToQueue, xTicksToWait, xCopyPosition\
    \ );\n+                        }\n                     }\n                 }\n\
    \             }\n@@ -1955,16 +2164,22 @@\n         int32_t lIndex;\n         QueueHandle_t\
    \ xInternalQueueHandle = NULL;\n         UBaseType_t uxReturn = 0;\n+        BaseType_t\
    \ xCallingTaskIsAuthorizedToAccessQueue = pdFALSE;\n \n         lIndex = ( int32_t\
    \ ) pxQueue;\n \n         if( IS_EXTERNAL_INDEX_VALID( lIndex ) != pdFALSE )\n\
    \         {\n-            xInternalQueueHandle = MPU_GetQueueHandleAtIndex( CONVERT_TO_INTERNAL_INDEX(\
    \ lIndex ) );\n+            xCallingTaskIsAuthorizedToAccessQueue = xPortIsAuthorizedToAccessKernelObject(\
    \ CONVERT_TO_INTERNAL_INDEX( lIndex ) );\n \n-            if( xInternalQueueHandle\
    \ != NULL )\n+            if( xCallingTaskIsAuthorizedToAccessQueue == pdTRUE\
    \ )\n             {\n-                uxReturn = uxQueueMessagesWaiting( xInternalQueueHandle\
    \ );\n+                xInternalQueueHandle = MPU_GetQueueHandleAtIndex( CONVERT_TO_INTERNAL_INDEX(\
    \ lIndex ) );\n+\n+                if( xInternalQueueHandle != NULL )\n+     \
    \           {\n+                    uxReturn = uxQueueMessagesWaiting( xInternalQueueHandle\
    \ );\n+                }\n             }\n         }\n \n@@ -1979,16 +2194,22\
    \ @@\n         int32_t lIndex;\n         QueueHandle_t xInternalQueueHandle =\
    \ NULL;\n         UBaseType_t uxReturn = 0;\n+        BaseType_t xCallingTaskIsAuthorizedToAccessQueue\
    \ = pdFALSE;\n \n         lIndex = ( int32_t ) xQueue;\n \n         if( IS_EXTERNAL_INDEX_VALID(\
    \ lIndex ) != pdFALSE )\n         {\n-            xInternalQueueHandle = MPU_GetQueueHandleAtIndex(\
    \ CONVERT_TO_INTERNAL_INDEX( lIndex ) );\n+            xCallingTaskIsAuthorizedToAccessQueue\
    \ = xPortIsAuthorizedToAccessKernelObject( CONVERT_TO_INTERNAL_INDEX( lIndex )\
    \ );\n \n-            if( xInternalQueueHandle != NULL )\n+            if( xCallingTaskIsAuthorizedToAccessQueue\
    \ == pdTRUE )\n             {\n-                uxReturn = uxQueueSpacesAvailable(\
    \ xInternalQueueHandle );\n+                xInternalQueueHandle = MPU_GetQueueHandleAtIndex(\
    \ CONVERT_TO_INTERNAL_INDEX( lIndex ) );\n+\n+                if( xInternalQueueHandle\
    \ != NULL )\n+                {\n+                    uxReturn = uxQueueSpacesAvailable(\
    \ xInternalQueueHandle );\n+                }\n             }\n         }\n \n\
    @@ -2008,31 +2229,37 @@\n         QueueHandle_t xInternalQueueHandle = NULL;\n\
    \         BaseType_t xReturn = pdFAIL;\n         BaseType_t xIsReceiveBufferWritable\
    \ = pdFALSE;\n+        BaseType_t xCallingTaskIsAuthorizedToAccessQueue = pdFALSE;\n\
    \         UBaseType_t uxQueueItemSize;\n \n         lIndex = ( int32_t ) pxQueue;\n\
    \ \n         if( IS_EXTERNAL_INDEX_VALID( lIndex ) != pdFALSE )\n         {\n\
    -            xInternalQueueHandle = MPU_GetQueueHandleAtIndex( CONVERT_TO_INTERNAL_INDEX(\
    \ lIndex ) );\n+            xCallingTaskIsAuthorizedToAccessQueue = xPortIsAuthorizedToAccessKernelObject(\
    \ CONVERT_TO_INTERNAL_INDEX( lIndex ) );\n \n-            if( xInternalQueueHandle\
    \ != NULL )\n+            if( xCallingTaskIsAuthorizedToAccessQueue == pdTRUE\
    \ )\n             {\n-                uxQueueItemSize = uxQueueGetQueueItemSize(\
    \ xInternalQueueHandle );\n+                xInternalQueueHandle = MPU_GetQueueHandleAtIndex(\
    \ CONVERT_TO_INTERNAL_INDEX( lIndex ) );\n \n-                if( ( !( ( ( pvBuffer\
    \ ) == NULL ) && ( uxQueueItemSize != ( UBaseType_t ) 0U ) ) )\n-            \
    \        #if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS ==\
    \ 1 ) )\n-                        && ( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED\
    \ ) && ( xTicksToWait != 0 ) ) )\n-                    #endif\n-             \
    \       )\n+                if( xInternalQueueHandle != NULL )\n             \
    \    {\n-                    xIsReceiveBufferWritable = xPortIsAuthorizedToAccessBuffer(\
    \ pvBuffer,\n-                                                               \
    \                 uxQueueGetQueueItemSize( xInternalQueueHandle ),\n-        \
    \                                                                        tskMPU_WRITE_PERMISSION\
    \ );\n+                    uxQueueItemSize = uxQueueGetQueueItemSize( xInternalQueueHandle\
    \ );\n \n-                    if( xIsReceiveBufferWritable == pdTRUE )\n+    \
    \                if( ( !( ( ( pvBuffer ) == NULL ) && ( uxQueueItemSize != ( UBaseType_t\
    \ ) 0U ) ) )\n+                        #if ( ( INCLUDE_xTaskGetSchedulerState\
    \ == 1 ) || ( configUSE_TIMERS == 1 ) )\n+                            && ( !(\
    \ ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait !=\
    \ 0 ) ) )\n+                        #endif\n+                        )\n     \
    \                {\n-                        xReturn = xQueueReceive( xInternalQueueHandle,\
    \ pvBuffer, xTicksToWait );\n+                        xIsReceiveBufferWritable\
    \ = xPortIsAuthorizedToAccessBuffer( pvBuffer,\n+                            \
    \                                                        uxQueueGetQueueItemSize(\
    \ xInternalQueueHandle ),\n+                                                 \
    \                                   tskMPU_WRITE_PERMISSION );\n+\n+         \
    \               if( xIsReceiveBufferWritable == pdTRUE )\n+                  \
    \      {\n+                            xReturn = xQueueReceive( xInternalQueueHandle,\
    \ pvBuffer, xTicksToWait );\n+                        }\n                    \
    \ }\n                 }\n             }\n@@ -2055,30 +2282,36 @@\n         BaseType_t\
    \ xReturn = pdFAIL;\n         BaseType_t xIsReceiveBufferWritable = pdFALSE;\n\
    \         UBaseType_t uxQueueItemSize;\n+        BaseType_t xCallingTaskIsAuthorizedToAccessQueue\
    \ = pdFALSE;\n \n         lIndex = ( int32_t ) xQueue;\n \n         if( IS_EXTERNAL_INDEX_VALID(\
    \ lIndex ) != pdFALSE )\n         {\n-            xInternalQueueHandle = MPU_GetQueueHandleAtIndex(\
    \ CONVERT_TO_INTERNAL_INDEX( lIndex ) );\n+            xCallingTaskIsAuthorizedToAccessQueue\
    \ = xPortIsAuthorizedToAccessKernelObject( CONVERT_TO_INTERNAL_INDEX( lIndex )\
    \ );\n \n-            if( xInternalQueueHandle != NULL )\n+            if( xCallingTaskIsAuthorizedToAccessQueue\
    \ == pdTRUE )\n             {\n-                uxQueueItemSize = uxQueueGetQueueItemSize(\
    \ xInternalQueueHandle );\n+                xInternalQueueHandle = MPU_GetQueueHandleAtIndex(\
    \ CONVERT_TO_INTERNAL_INDEX( lIndex ) );\n \n-                if( ( !( ( ( pvBuffer\
    \ ) == NULL ) && ( uxQueueItemSize != ( UBaseType_t ) 0U ) ) )\n-            \
    \        #if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS ==\
    \ 1 ) )\n-                        && ( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED\
    \ ) && ( xTicksToWait != 0 ) ) )\n-                    #endif\n-             \
    \       )\n+                if( xInternalQueueHandle != NULL )\n             \
    \    {\n-                    xIsReceiveBufferWritable = xPortIsAuthorizedToAccessBuffer(\
    \ pvBuffer,\n-                                                               \
    \                 uxQueueGetQueueItemSize( xInternalQueueHandle ),\n-        \
    \                                                                        tskMPU_WRITE_PERMISSION\
    \ );\n+                    uxQueueItemSize = uxQueueGetQueueItemSize( xInternalQueueHandle\
    \ );\n \n-                    if( xIsReceiveBufferWritable == pdTRUE )\n+    \
    \                if( ( !( ( ( pvBuffer ) == NULL ) && ( uxQueueItemSize != ( UBaseType_t\
    \ ) 0U ) ) )\n+                        #if ( ( INCLUDE_xTaskGetSchedulerState\
    \ == 1 ) || ( configUSE_TIMERS == 1 ) )\n+                            && ( !(\
    \ ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait !=\
    \ 0 ) ) )\n+                        #endif\n+                        )\n     \
    \                {\n-                        xReturn = xQueuePeek( xInternalQueueHandle,\
    \ pvBuffer, xTicksToWait );\n+                        xIsReceiveBufferWritable\
    \ = xPortIsAuthorizedToAccessBuffer( pvBuffer,\n+                            \
    \                                                        uxQueueGetQueueItemSize(\
    \ xInternalQueueHandle ),\n+                                                 \
    \                                   tskMPU_WRITE_PERMISSION );\n+\n+         \
    \               if( xIsReceiveBufferWritable == pdTRUE )\n+                  \
    \      {\n+                            xReturn = xQueuePeek( xInternalQueueHandle,\
    \ pvBuffer, xTicksToWait );\n+                        }\n                    \
    \ }\n                 }\n             }\n@@ -2098,24 +2331,30 @@\n         QueueHandle_t\
    \ xInternalQueueHandle = NULL;\n         BaseType_t xReturn = pdFAIL;\n      \
    \   UBaseType_t uxQueueItemSize;\n+        BaseType_t xCallingTaskIsAuthorizedToAccessQueue\
    \ = pdFALSE;\n \n         lIndex = ( int32_t ) xQueue;\n \n         if( IS_EXTERNAL_INDEX_VALID(\
    \ lIndex ) != pdFALSE )\n         {\n-            xInternalQueueHandle = MPU_GetQueueHandleAtIndex(\
    \ CONVERT_TO_INTERNAL_INDEX( lIndex ) );\n+            xCallingTaskIsAuthorizedToAccessQueue\
    \ = xPortIsAuthorizedToAccessKernelObject( CONVERT_TO_INTERNAL_INDEX( lIndex )\
    \ );\n \n-            if( xInternalQueueHandle != NULL )\n+            if( xCallingTaskIsAuthorizedToAccessQueue\
    \ == pdTRUE )\n             {\n-                uxQueueItemSize = uxQueueGetQueueItemSize(\
    \ xInternalQueueHandle );\n+                xInternalQueueHandle = MPU_GetQueueHandleAtIndex(\
    \ CONVERT_TO_INTERNAL_INDEX( lIndex ) );\n \n-                if( ( uxQueueItemSize\
    \ == 0 )\n-                    #if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) ||\
    \ ( configUSE_TIMERS == 1 ) )\n-                        && ( !( ( xTaskGetSchedulerState()\
    \ == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) )\n-               \
    \     #endif\n-                    )\n+                if( xInternalQueueHandle\
    \ != NULL )\n                 {\n-                    xReturn = xQueueSemaphoreTake(\
    \ xInternalQueueHandle, xTicksToWait );\n+                    uxQueueItemSize\
    \ = uxQueueGetQueueItemSize( xInternalQueueHandle );\n+\n+                   \
    \ if( ( uxQueueItemSize == 0 )\n+                        #if ( ( INCLUDE_xTaskGetSchedulerState\
    \ == 1 ) || ( configUSE_TIMERS == 1 ) )\n+                            && ( !(\
    \ ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait !=\
    \ 0 ) ) )\n+                        #endif\n+                        )\n+    \
    \                {\n+                        xReturn = xQueueSemaphoreTake( xInternalQueueHandle,\
    \ xTicksToWait );\n+                    }\n                 }\n             }\n\
    \         }\n@@ -2134,25 +2373,31 @@\n             TaskHandle_t xMutexHolderTaskExternalHandle\
    \ = NULL;\n             int32_t lIndex, lMutexHolderTaskIndex;\n             QueueHandle_t\
    \ xInternalQueueHandle = NULL;\n+            BaseType_t xCallingTaskIsAuthorizedToAccessQueue\
    \ = pdFALSE;\n \n \n             lIndex = ( int32_t ) xSemaphore;\n \n       \
    \      if( IS_EXTERNAL_INDEX_VALID( lIndex ) != pdFALSE )\n             {\n- \
    \               xInternalQueueHandle = MPU_GetQueueHandleAtIndex( CONVERT_TO_INTERNAL_INDEX(\
    \ lIndex ) );\n+                xCallingTaskIsAuthorizedToAccessQueue = xPortIsAuthorizedToAccessKernelObject(\
    \ CONVERT_TO_INTERNAL_INDEX( lIndex ) );\n \n-                if( xInternalQueueHandle\
    \ != NULL )\n+                if( xCallingTaskIsAuthorizedToAccessQueue == pdTRUE\
    \ )\n                 {\n-                    xMutexHolderTaskInternalHandle =\
    \ xQueueGetMutexHolder( xInternalQueueHandle );\n+                    xInternalQueueHandle\
    \ = MPU_GetQueueHandleAtIndex( CONVERT_TO_INTERNAL_INDEX( lIndex ) );\n \n-  \
    \                  if( xMutexHolderTaskInternalHandle != NULL )\n+           \
    \         if( xInternalQueueHandle != NULL )\n                     {\n-      \
    \                  lMutexHolderTaskIndex = MPU_GetIndexForTaskHandle( xMutexHolderTaskInternalHandle\
    \ );\n+                        xMutexHolderTaskInternalHandle = xQueueGetMutexHolder(\
    \ xInternalQueueHandle );\n \n-                        if( lMutexHolderTaskIndex\
    \ != -1 )\n+                        if( xMutexHolderTaskInternalHandle != NULL\
    \ )\n                         {\n-                            xMutexHolderTaskExternalHandle\
    \ = ( TaskHandle_t ) ( CONVERT_TO_EXTERNAL_INDEX( lMutexHolderTaskIndex ) );\n\
    +                            lMutexHolderTaskIndex = MPU_GetIndexForTaskHandle(\
    \ xMutexHolderTaskInternalHandle );\n+\n+                            if( lMutexHolderTaskIndex\
    \ != -1 )\n+                            {\n+                                xMutexHolderTaskExternalHandle\
    \ = ( TaskHandle_t ) ( CONVERT_TO_EXTERNAL_INDEX( lMutexHolderTaskIndex ) );\n\
    +                            }\n                         }\n                 \
    \    }\n                 }\n@@ -2173,6 +2418,7 @@\n                          \
    \                            TickType_t xBlockTime ) /* PRIVILEGED_FUNCTION */\n\
    \         {\n             BaseType_t xReturn = pdFAIL;\n+            BaseType_t\
    \ xCallingTaskIsAuthorizedToAccessQueue = pdFALSE;\n             int32_t lIndex;\n\
    \             QueueHandle_t xInternalQueueHandle = NULL;\n             UBaseType_t\
    \ uxQueueItemSize;\n@@ -2181,15 +2427,20 @@\n \n             if( IS_EXTERNAL_INDEX_VALID(\
    \ lIndex ) != pdFALSE )\n             {\n-                xInternalQueueHandle\
    \ = MPU_GetQueueHandleAtIndex( CONVERT_TO_INTERNAL_INDEX( lIndex ) );\n+     \
    \           xCallingTaskIsAuthorizedToAccessQueue = xPortIsAuthorizedToAccessKernelObject(\
    \ CONVERT_TO_INTERNAL_INDEX( lIndex ) );\n \n-                if( xInternalQueueHandle\
    \ != NULL )\n+                if( xCallingTaskIsAuthorizedToAccessQueue == pdTRUE\
    \ )\n                 {\n-                    uxQueueItemSize = uxQueueGetQueueItemSize(\
    \ xInternalQueueHandle );\n+                    xInternalQueueHandle = MPU_GetQueueHandleAtIndex(\
    \ CONVERT_TO_INTERNAL_INDEX( lIndex ) );\n \n-                    if( uxQueueItemSize\
    \ == 0 )\n+                    if( xInternalQueueHandle != NULL )\n          \
    \           {\n-                        xReturn = xQueueTakeMutexRecursive( xInternalQueueHandle,\
    \ xBlockTime );\n+                        uxQueueItemSize = uxQueueGetQueueItemSize(\
    \ xInternalQueueHandle );\n+\n+                        if( uxQueueItemSize ==\
    \ 0 )\n+                        {\n+                            xReturn = xQueueTakeMutexRecursive(\
    \ xInternalQueueHandle, xBlockTime );\n+                        }\n          \
    \           }\n                 }\n             }\n@@ -2207,18 +2458,24 @@\n \
    \        BaseType_t MPU_xQueueGiveMutexRecursiveImpl( QueueHandle_t xMutex ) /*\
    \ PRIVILEGED_FUNCTION */\n         {\n             BaseType_t xReturn = pdFAIL;\n\
    +            BaseType_t xCallingTaskIsAuthorizedToAccessQueue = pdFALSE;\n   \
    \          int32_t lIndex;\n             QueueHandle_t xInternalQueueHandle =\
    \ NULL;\n \n             lIndex = ( int32_t ) xMutex;\n \n             if( IS_EXTERNAL_INDEX_VALID(\
    \ lIndex ) != pdFALSE )\n             {\n-                xInternalQueueHandle\
    \ = MPU_GetQueueHandleAtIndex( CONVERT_TO_INTERNAL_INDEX( lIndex ) );\n+     \
    \           xCallingTaskIsAuthorizedToAccessQueue = xPortIsAuthorizedToAccessKernelObject(\
    \ CONVERT_TO_INTERNAL_INDEX( lIndex ) );\n \n-                if( xInternalQueueHandle\
    \ != NULL )\n+                if( xCallingTaskIsAuthorizedToAccessQueue == pdTRUE\
    \ )\n                 {\n-                    xReturn = xQueueGiveMutexRecursive(\
    \ xInternalQueueHandle );\n+                    xInternalQueueHandle = MPU_GetQueueHandleAtIndex(\
    \ CONVERT_TO_INTERNAL_INDEX( lIndex ) );\n+\n+                    if( xInternalQueueHandle\
    \ != NULL )\n+                    {\n+                        xReturn = xQueueGiveMutexRecursive(\
    \ xInternalQueueHandle );\n+                    }\n                 }\n      \
    \       }\n \n@@ -2240,24 +2497,30 @@\n             QueueSetMemberHandle_t xSelectedMemberInternal\
    \ = NULL;\n             QueueSetMemberHandle_t xSelectedMemberExternal = NULL;\n\
    \             int32_t lIndexQueueSet, lIndexSelectedMember;\n+            BaseType_t\
    \ xCallingTaskIsAuthorizedToAccessQueueSet = pdFALSE;\n \n             lIndexQueueSet\
    \ = ( int32_t ) xQueueSet;\n \n             if( IS_EXTERNAL_INDEX_VALID( lIndexQueueSet\
    \ ) != pdFALSE )\n             {\n-                xInternalQueueSetHandle = MPU_GetQueueSetHandleAtIndex(\
    \ CONVERT_TO_INTERNAL_INDEX( lIndexQueueSet ) );\n+                xCallingTaskIsAuthorizedToAccessQueueSet\
    \ = xPortIsAuthorizedToAccessKernelObject( CONVERT_TO_INTERNAL_INDEX( lIndexQueueSet\
    \ ) );\n \n-                if( xInternalQueueSetHandle != NULL )\n+         \
    \       if( xCallingTaskIsAuthorizedToAccessQueueSet == pdTRUE )\n           \
    \      {\n-                    xSelectedMemberInternal = xQueueSelectFromSet(\
    \ xInternalQueueSetHandle, xBlockTimeTicks );\n+                    xInternalQueueSetHandle\
    \ = MPU_GetQueueSetHandleAtIndex( CONVERT_TO_INTERNAL_INDEX( lIndexQueueSet )\
    \ );\n \n-                    if( xSelectedMemberInternal != NULL )\n+       \
    \             if( xInternalQueueSetHandle != NULL )\n                     {\n\
    -                        lIndexSelectedMember = MPU_GetIndexForQueueSetMemberHandle(\
    \ xSelectedMemberInternal );\n+                        xSelectedMemberInternal\
    \ = xQueueSelectFromSet( xInternalQueueSetHandle, xBlockTimeTicks );\n \n-   \
    \                     if( lIndexSelectedMember != -1 )\n+                    \
    \    if( xSelectedMemberInternal != NULL )\n                         {\n-    \
    \                        xSelectedMemberExternal = ( QueueSetMemberHandle_t )\
    \ ( CONVERT_TO_EXTERNAL_INDEX( lIndexSelectedMember ) );\n+                  \
    \          lIndexSelectedMember = MPU_GetIndexForQueueSetMemberHandle( xSelectedMemberInternal\
    \ );\n+\n+                            if( lIndexSelectedMember != -1 )\n+    \
    \                        {\n+                                xSelectedMemberExternal\
    \ = ( QueueSetMemberHandle_t ) ( CONVERT_TO_EXTERNAL_INDEX( lIndexSelectedMember\
    \ ) );\n+                            }\n                         }\n         \
    \            }\n                 }\n@@ -2281,19 +2544,27 @@\n             QueueSetMemberHandle_t\
    \ xInternalQueueSetMemberHandle = NULL;\n             QueueSetHandle_t xInternalQueueSetHandle\
    \ = NULL;\n             int32_t lIndexQueueSet, lIndexQueueSetMember;\n+     \
    \       BaseType_t xCallingTaskIsAuthorizedToAccessQueueSet = pdFALSE;\n+    \
    \        BaseType_t xCallingTaskIsAuthorizedToAccessQueueSetMember = pdFALSE;\n\
    \ \n             lIndexQueueSet = ( int32_t ) xQueueSet;\n             lIndexQueueSetMember\
    \ = ( int32_t ) xQueueOrSemaphore;\n \n             if( ( IS_EXTERNAL_INDEX_VALID(\
    \ lIndexQueueSet ) != pdFALSE ) &&\n                 ( IS_EXTERNAL_INDEX_VALID(\
    \ lIndexQueueSetMember ) != pdFALSE ) )\n             {\n-                xInternalQueueSetHandle\
    \ = MPU_GetQueueSetHandleAtIndex( CONVERT_TO_INTERNAL_INDEX( lIndexQueueSet )\
    \ );\n-                xInternalQueueSetMemberHandle = MPU_GetQueueSetMemberHandleAtIndex(\
    \ CONVERT_TO_INTERNAL_INDEX( lIndexQueueSetMember ) );\n+                xCallingTaskIsAuthorizedToAccessQueueSet\
    \ = xPortIsAuthorizedToAccessKernelObject( CONVERT_TO_INTERNAL_INDEX( lIndexQueueSet\
    \ ) );\n+                xCallingTaskIsAuthorizedToAccessQueueSetMember = xPortIsAuthorizedToAccessKernelObject(\
    \ CONVERT_TO_INTERNAL_INDEX( lIndexQueueSetMember ) );\n \n-                if(\
    \ ( xInternalQueueSetHandle != NULL ) && ( xInternalQueueSetMemberHandle != NULL\
    \ ) )\n+                if( ( xCallingTaskIsAuthorizedToAccessQueueSet == pdTRUE\
    \ ) && ( xCallingTaskIsAuthorizedToAccessQueueSetMember == pdTRUE ) )\n      \
    \           {\n-                    xReturn = xQueueAddToSet( xInternalQueueSetMemberHandle,\
    \ xInternalQueueSetHandle );\n+                    xInternalQueueSetHandle = MPU_GetQueueSetHandleAtIndex(\
    \ CONVERT_TO_INTERNAL_INDEX( lIndexQueueSet ) );\n+                    xInternalQueueSetMemberHandle\
    \ = MPU_GetQueueSetMemberHandleAtIndex( CONVERT_TO_INTERNAL_INDEX( lIndexQueueSetMember\
    \ ) );\n+\n+                    if( ( xInternalQueueSetHandle != NULL ) && ( xInternalQueueSetMemberHandle\
    \ != NULL ) )\n+                    {\n+                        xReturn = xQueueAddToSet(\
    \ xInternalQueueSetMemberHandle, xInternalQueueSetHandle );\n+               \
    \     }\n                 }\n             }\n \n@@ -2313,16 +2584,22 @@\n    \
    \     {\n             int32_t lIndex;\n             QueueHandle_t xInternalQueueHandle\
    \ = NULL;\n+            BaseType_t xCallingTaskIsAuthorizedToAccessQueue = pdFALSE;\n\
    \ \n             lIndex = ( int32_t ) xQueue;\n \n             if( IS_EXTERNAL_INDEX_VALID(\
    \ lIndex ) != pdFALSE )\n             {\n-                xInternalQueueHandle\
    \ = MPU_GetQueueHandleAtIndex( CONVERT_TO_INTERNAL_INDEX( lIndex ) );\n+     \
    \           xCallingTaskIsAuthorizedToAccessQueue = xPortIsAuthorizedToAccessKernelObject(\
    \ CONVERT_TO_INTERNAL_INDEX( lIndex ) );\n \n-                if( xInternalQueueHandle\
    \ != NULL )\n+                if( xCallingTaskIsAuthorizedToAccessQueue == pdTRUE\
    \ )\n                 {\n-                    vQueueAddToRegistry( xInternalQueueHandle,\
    \ pcName );\n+                    xInternalQueueHandle = MPU_GetQueueHandleAtIndex(\
    \ CONVERT_TO_INTERNAL_INDEX( lIndex ) );\n+\n+                    if( xInternalQueueHandle\
    \ != NULL )\n+                    {\n+                        vQueueAddToRegistry(\
    \ xInternalQueueHandle, pcName );\n+                    }\n                 }\n\
    \             }\n         }\n@@ -2338,16 +2615,22 @@\n         {\n           \
    \  int32_t lIndex;\n             QueueHandle_t xInternalQueueHandle = NULL;\n\
    +            BaseType_t xCallingTaskIsAuthorizedToAccessQueue = pdFALSE;\n \n\
    \             lIndex = ( int32_t ) xQueue;\n \n             if( IS_EXTERNAL_INDEX_VALID(\
    \ lIndex ) != pdFALSE )\n             {\n-                xInternalQueueHandle\
    \ = MPU_GetQueueHandleAtIndex( CONVERT_TO_INTERNAL_INDEX( lIndex ) );\n+     \
    \           xCallingTaskIsAuthorizedToAccessQueue = xPortIsAuthorizedToAccessKernelObject(\
    \ CONVERT_TO_INTERNAL_INDEX( lIndex ) );\n \n-                if( xInternalQueueHandle\
    \ != NULL )\n+                if( xCallingTaskIsAuthorizedToAccessQueue == pdTRUE\
    \ )\n                 {\n-                    vQueueUnregisterQueue( xInternalQueueHandle\
    \ );\n+                    xInternalQueueHandle = MPU_GetQueueHandleAtIndex( CONVERT_TO_INTERNAL_INDEX(\
    \ lIndex ) );\n+\n+                    if( xInternalQueueHandle != NULL )\n+ \
    \                   {\n+                        vQueueUnregisterQueue( xInternalQueueHandle\
    \ );\n+                    }\n                 }\n             }\n         }\n\
    @@ -2364,16 +2647,22 @@\n             const char * pcReturn = NULL;\n        \
    \     QueueHandle_t xInternalQueueHandle = NULL;\n             int32_t lIndex;\n\
    +            BaseType_t xCallingTaskIsAuthorizedToAccessQueue = pdFALSE;\n \n\
    \             lIndex = ( int32_t ) xQueue;\n \n             if( IS_EXTERNAL_INDEX_VALID(\
    \ lIndex ) != pdFALSE )\n             {\n-                xInternalQueueHandle\
    \ = MPU_GetQueueHandleAtIndex( CONVERT_TO_INTERNAL_INDEX( lIndex ) );\n+     \
    \           xCallingTaskIsAuthorizedToAccessQueue = xPortIsAuthorizedToAccessKernelObject(\
    \ CONVERT_TO_INTERNAL_INDEX( lIndex ) );\n \n-                if( xInternalQueueHandle\
    \ != NULL )\n+                if( xCallingTaskIsAuthorizedToAccessQueue == pdTRUE\
    \ )\n                 {\n-                    pcReturn = pcQueueGetName( xInternalQueueHandle\
    \ );\n+                    xInternalQueueHandle = MPU_GetQueueHandleAtIndex( CONVERT_TO_INTERNAL_INDEX(\
    \ lIndex ) );\n+\n+                    if( xInternalQueueHandle != NULL )\n+ \
    \                   {\n+                        pcReturn = pcQueueGetName( xInternalQueueHandle\
    \ );\n+                    }\n                 }\n             }\n \n@@ -2971,16\
    \ +3260,22 @@\n             void * pvReturn = NULL;\n             TimerHandle_t\
    \ xInternalTimerHandle = NULL;\n             int32_t lIndex;\n+            BaseType_t\
    \ xCallingTaskIsAuthorizedToAccessTimer = pdFALSE;\n \n             lIndex = (\
    \ int32_t ) xTimer;\n \n             if( IS_EXTERNAL_INDEX_VALID( lIndex ) !=\
    \ pdFALSE )\n             {\n-                xInternalTimerHandle = MPU_GetTimerHandleAtIndex(\
    \ CONVERT_TO_INTERNAL_INDEX( lIndex ) );\n+                xCallingTaskIsAuthorizedToAccessTimer\
    \ = xPortIsAuthorizedToAccessKernelObject( CONVERT_TO_INTERNAL_INDEX( lIndex )\
    \ );\n \n-                if( xInternalTimerHandle != NULL )\n+              \
    \  if( xCallingTaskIsAuthorizedToAccessTimer == pdTRUE )\n                 {\n\
    -                    pvReturn = pvTimerGetTimerID( xInternalTimerHandle );\n+\
    \                    xInternalTimerHandle = MPU_GetTimerHandleAtIndex( CONVERT_TO_INTERNAL_INDEX(\
    \ lIndex ) );\n+\n+                    if( xInternalTimerHandle != NULL )\n+ \
    \                   {\n+                        pvReturn = pvTimerGetTimerID(\
    \ xInternalTimerHandle );\n+                    }\n                 }\n      \
    \       }\n \n@@ -3000,16 +3295,22 @@\n         {\n             TimerHandle_t\
    \ xInternalTimerHandle = NULL;\n             int32_t lIndex;\n+            BaseType_t\
    \ xCallingTaskIsAuthorizedToAccessTimer = pdFALSE;\n \n             lIndex = (\
    \ int32_t ) xTimer;\n \n             if( IS_EXTERNAL_INDEX_VALID( lIndex ) !=\
    \ pdFALSE )\n             {\n-                xInternalTimerHandle = MPU_GetTimerHandleAtIndex(\
    \ CONVERT_TO_INTERNAL_INDEX( lIndex ) );\n+                xCallingTaskIsAuthorizedToAccessTimer\
    \ = xPortIsAuthorizedToAccessKernelObject( CONVERT_TO_INTERNAL_INDEX( lIndex )\
    \ );\n \n-                if( xInternalTimerHandle != NULL )\n+              \
    \  if( xCallingTaskIsAuthorizedToAccessTimer == pdTRUE )\n                 {\n\
    -                    vTimerSetTimerID( xInternalTimerHandle, pvNewID );\n+   \
    \                 xInternalTimerHandle = MPU_GetTimerHandleAtIndex( CONVERT_TO_INTERNAL_INDEX(\
    \ lIndex ) );\n+\n+                    if( xInternalTimerHandle != NULL )\n+ \
    \                   {\n+                        vTimerSetTimerID( xInternalTimerHandle,\
    \ pvNewID );\n+                    }\n                 }\n             }\n   \
    \      }\n@@ -3026,16 +3327,22 @@\n             BaseType_t xReturn = pdFALSE;\n\
    \             TimerHandle_t xInternalTimerHandle = NULL;\n             int32_t\
    \ lIndex;\n+            BaseType_t xCallingTaskIsAuthorizedToAccessTimer = pdFALSE;\n\
    \ \n             lIndex = ( int32_t ) xTimer;\n \n             if( IS_EXTERNAL_INDEX_VALID(\
    \ lIndex ) != pdFALSE )\n             {\n-                xInternalTimerHandle\
    \ = MPU_GetTimerHandleAtIndex( CONVERT_TO_INTERNAL_INDEX( lIndex ) );\n+     \
    \           xCallingTaskIsAuthorizedToAccessTimer = xPortIsAuthorizedToAccessKernelObject(\
    \ CONVERT_TO_INTERNAL_INDEX( lIndex ) );\n \n-                if( xInternalTimerHandle\
    \ != NULL )\n+                if( xCallingTaskIsAuthorizedToAccessTimer == pdTRUE\
    \ )\n                 {\n-                    xReturn = xTimerIsTimerActive( xInternalTimerHandle\
    \ );\n+                    xInternalTimerHandle = MPU_GetTimerHandleAtIndex( CONVERT_TO_INTERNAL_INDEX(\
    \ lIndex ) );\n+\n+                    if( xInternalTimerHandle != NULL )\n+ \
    \                   {\n+                        xReturn = xTimerIsTimerActive(\
    \ xInternalTimerHandle );\n+                    }\n                 }\n      \
    \       }\n \n@@ -3091,6 +3398,7 @@\n             TimerHandle_t xInternalTimerHandle\
    \ = NULL;\n             int32_t lIndex;\n             BaseType_t xIsHigherPriorityTaskWokenWriteable\
    \ = pdFALSE;\n+            BaseType_t xCallingTaskIsAuthorizedToAccessTimer =\
    \ pdFALSE;\n             BaseType_t xAreParamsReadable = pdFALSE;\n \n       \
    \      if( pxParams != NULL )\n@@ -3116,15 +3424,20 @@\n \n                  \
    \   if( IS_EXTERNAL_INDEX_VALID( lIndex ) != pdFALSE )\n                     {\n\
    -                        xInternalTimerHandle = MPU_GetTimerHandleAtIndex( CONVERT_TO_INTERNAL_INDEX(\
    \ lIndex ) );\n+                        xCallingTaskIsAuthorizedToAccessTimer\
    \ = xPortIsAuthorizedToAccessKernelObject( CONVERT_TO_INTERNAL_INDEX( lIndex )\
    \ );\n \n-                        if( xInternalTimerHandle != NULL )\n+      \
    \                  if( xCallingTaskIsAuthorizedToAccessTimer == pdTRUE )\n   \
    \                      {\n-                            xReturn = xTimerGenericCommand(\
    \ xInternalTimerHandle,\n-                                                   \
    \         pxParams->xCommandID,\n-                                           \
    \                 pxParams->xOptionalValue,\n-                               \
    \                             pxParams->pxHigherPriorityTaskWoken,\n-        \
    \                                                    pxParams->xTicksToWait );\n\
    +                            xInternalTimerHandle = MPU_GetTimerHandleAtIndex(\
    \ CONVERT_TO_INTERNAL_INDEX( lIndex ) );\n+\n+                            if(\
    \ xInternalTimerHandle != NULL )\n+                            {\n+          \
    \                      xReturn = xTimerGenericCommand( xInternalTimerHandle,\n\
    +                                                                pxParams->xCommandID,\n\
    +                                                                pxParams->xOptionalValue,\n\
    +                                                                pxParams->pxHigherPriorityTaskWoken,\n\
    +                                                                pxParams->xTicksToWait\
    \ );\n+                            }\n                         }\n           \
    \          }\n                 }\n@@ -3175,16 +3488,22 @@\n             const\
    \ char * pcReturn = NULL;\n             TimerHandle_t xInternalTimerHandle = NULL;\n\
    \             int32_t lIndex;\n+            BaseType_t xCallingTaskIsAuthorizedToAccessTimer\
    \ = pdFALSE;\n \n             lIndex = ( int32_t ) xTimer;\n \n             if(\
    \ IS_EXTERNAL_INDEX_VALID( lIndex ) != pdFALSE )\n             {\n-          \
    \      xInternalTimerHandle = MPU_GetTimerHandleAtIndex( CONVERT_TO_INTERNAL_INDEX(\
    \ lIndex ) );\n+                xCallingTaskIsAuthorizedToAccessTimer = xPortIsAuthorizedToAccessKernelObject(\
    \ CONVERT_TO_INTERNAL_INDEX( lIndex ) );\n \n-                if( xInternalTimerHandle\
    \ != NULL )\n+                if( xCallingTaskIsAuthorizedToAccessTimer == pdTRUE\
    \ )\n                 {\n-                    pcReturn = pcTimerGetName( xInternalTimerHandle\
    \ );\n+                    xInternalTimerHandle = MPU_GetTimerHandleAtIndex( CONVERT_TO_INTERNAL_INDEX(\
    \ lIndex ) );\n+\n+                    if( xInternalTimerHandle != NULL )\n+ \
    \                   {\n+                        pcReturn = pcTimerGetName( xInternalTimerHandle\
    \ );\n+                    }\n                 }\n             }\n \n@@ -3204,16\
    \ +3523,22 @@\n         {\n             TimerHandle_t xInternalTimerHandle = NULL;\n\
    \             int32_t lIndex;\n+            BaseType_t xCallingTaskIsAuthorizedToAccessTimer\
    \ = pdFALSE;\n \n             lIndex = ( int32_t ) xTimer;\n \n             if(\
    \ IS_EXTERNAL_INDEX_VALID( lIndex ) != pdFALSE )\n             {\n-          \
    \      xInternalTimerHandle = MPU_GetTimerHandleAtIndex( CONVERT_TO_INTERNAL_INDEX(\
    \ lIndex ) );\n+                xCallingTaskIsAuthorizedToAccessTimer = xPortIsAuthorizedToAccessKernelObject(\
    \ CONVERT_TO_INTERNAL_INDEX( lIndex ) );\n \n-                if( xInternalTimerHandle\
    \ != NULL )\n+                if( xCallingTaskIsAuthorizedToAccessTimer == pdTRUE\
    \ )\n                 {\n-                    vTimerSetReloadMode( xInternalTimerHandle,\
    \ uxAutoReload );\n+                    xInternalTimerHandle = MPU_GetTimerHandleAtIndex(\
    \ CONVERT_TO_INTERNAL_INDEX( lIndex ) );\n+\n+                    if( xInternalTimerHandle\
    \ != NULL )\n+                    {\n+                        vTimerSetReloadMode(\
    \ xInternalTimerHandle, uxAutoReload );\n+                    }\n            \
    \     }\n             }\n         }\n@@ -3230,16 +3555,22 @@\n             BaseType_t\
    \ xReturn = pdFALSE;\n             TimerHandle_t xInternalTimerHandle = NULL;\n\
    \             int32_t lIndex;\n+            BaseType_t xCallingTaskIsAuthorizedToAccessTimer\
    \ = pdFALSE;\n \n             lIndex = ( int32_t ) xTimer;\n \n             if(\
    \ IS_EXTERNAL_INDEX_VALID( lIndex ) != pdFALSE )\n             {\n-          \
    \      xInternalTimerHandle = MPU_GetTimerHandleAtIndex( CONVERT_TO_INTERNAL_INDEX(\
    \ lIndex ) );\n+                xCallingTaskIsAuthorizedToAccessTimer = xPortIsAuthorizedToAccessKernelObject(\
    \ CONVERT_TO_INTERNAL_INDEX( lIndex ) );\n \n-                if( xInternalTimerHandle\
    \ != NULL )\n+                if( xCallingTaskIsAuthorizedToAccessTimer == pdTRUE\
    \ )\n                 {\n-                    xReturn = xTimerGetReloadMode( xInternalTimerHandle\
    \ );\n+                    xInternalTimerHandle = MPU_GetTimerHandleAtIndex( CONVERT_TO_INTERNAL_INDEX(\
    \ lIndex ) );\n+\n+                    if( xInternalTimerHandle != NULL )\n+ \
    \                   {\n+                        xReturn = xTimerGetReloadMode(\
    \ xInternalTimerHandle );\n+                    }\n                 }\n      \
    \       }\n \n@@ -3258,16 +3589,22 @@\n             UBaseType_t uxReturn = 0;\n\
    \             TimerHandle_t xInternalTimerHandle = NULL;\n             int32_t\
    \ lIndex;\n+            BaseType_t xCallingTaskIsAuthorizedToAccessTimer = pdFALSE;\n\
    \ \n             lIndex = ( int32_t ) xTimer;\n \n             if( IS_EXTERNAL_INDEX_VALID(\
    \ lIndex ) != pdFALSE )\n             {\n-                xInternalTimerHandle\
    \ = MPU_GetTimerHandleAtIndex( CONVERT_TO_INTERNAL_INDEX( lIndex ) );\n+     \
    \           xCallingTaskIsAuthorizedToAccessTimer = xPortIsAuthorizedToAccessKernelObject(\
    \ CONVERT_TO_INTERNAL_INDEX( lIndex ) );\n \n-                if( xInternalTimerHandle\
    \ != NULL )\n+                if( xCallingTaskIsAuthorizedToAccessTimer == pdTRUE\
    \ )\n                 {\n-                    uxReturn = uxTimerGetReloadMode(\
    \ xInternalTimerHandle );\n+                    xInternalTimerHandle = MPU_GetTimerHandleAtIndex(\
    \ CONVERT_TO_INTERNAL_INDEX( lIndex ) );\n+\n+                    if( xInternalTimerHandle\
    \ != NULL )\n+                    {\n+                        uxReturn = uxTimerGetReloadMode(\
    \ xInternalTimerHandle );\n+                    }\n                 }\n      \
    \       }\n \n@@ -3286,16 +3623,22 @@\n             TickType_t xReturn = 0;\n\
    \             TimerHandle_t xInternalTimerHandle = NULL;\n             int32_t\
    \ lIndex;\n+            BaseType_t xCallingTaskIsAuthorizedToAccessTimer = pdFALSE;\n\
    \ \n             lIndex = ( int32_t ) xTimer;\n \n             if( IS_EXTERNAL_INDEX_VALID(\
    \ lIndex ) != pdFALSE )\n             {\n-                xInternalTimerHandle\
    \ = MPU_GetTimerHandleAtIndex( CONVERT_TO_INTERNAL_INDEX( lIndex ) );\n+     \
    \           xCallingTaskIsAuthorizedToAccessTimer = xPortIsAuthorizedToAccessKernelObject(\
    \ CONVERT_TO_INTERNAL_INDEX( lIndex ) );\n \n-                if( xInternalTimerHandle\
    \ != NULL )\n+                if( xCallingTaskIsAuthorizedToAccessTimer == pdTRUE\
    \ )\n                 {\n-                    xReturn = xTimerGetPeriod( xInternalTimerHandle\
    \ );\n+                    xInternalTimerHandle = MPU_GetTimerHandleAtIndex( CONVERT_TO_INTERNAL_INDEX(\
    \ lIndex ) );\n+\n+                    if( xInternalTimerHandle != NULL )\n+ \
    \                   {\n+                        xReturn = xTimerGetPeriod( xInternalTimerHandle\
    \ );\n+                    }\n                 }\n             }\n \n@@ -3314,16\
    \ +3657,22 @@\n             TickType_t xReturn = 0;\n             TimerHandle_t\
    \ xInternalTimerHandle = NULL;\n             int32_t lIndex;\n+            BaseType_t\
    \ xCallingTaskIsAuthorizedToAccessTimer = pdFALSE;\n \n             lIndex = (\
    \ int32_t ) xTimer;\n \n             if( IS_EXTERNAL_INDEX_VALID( lIndex ) !=\
    \ pdFALSE )\n             {\n-                xInternalTimerHandle = MPU_GetTimerHandleAtIndex(\
    \ CONVERT_TO_INTERNAL_INDEX( lIndex ) );\n+                xCallingTaskIsAuthorizedToAccessTimer\
    \ = xPortIsAuthorizedToAccessKernelObject( CONVERT_TO_INTERNAL_INDEX( lIndex )\
    \ );\n \n-                if( xInternalTimerHandle != NULL )\n+              \
    \  if( xCallingTaskIsAuthorizedToAccessTimer == pdTRUE )\n                 {\n\
    -                    xReturn = xTimerGetExpiryTime( xInternalTimerHandle );\n\
    +                    xInternalTimerHandle = MPU_GetTimerHandleAtIndex( CONVERT_TO_INTERNAL_INDEX(\
    \ lIndex ) );\n+\n+                    if( xInternalTimerHandle != NULL )\n+ \
    \                   {\n+                        xReturn = xTimerGetExpiryTime(\
    \ xInternalTimerHandle );\n+                    }\n                 }\n      \
    \       }\n \n@@ -3467,6 +3816,7 @@\n         EventBits_t xReturn = 0;\n     \
    \    EventGroupHandle_t xInternalEventGroupHandle = NULL;\n         int32_t lIndex;\n\
    +        BaseType_t xCallingTaskIsAuthorizedToAccessEventGroup = pdFALSE;\n  \
    \       BaseType_t xAreParamsReadable = pdFALSE;\n \n         if( pxParams !=\
    \ NULL )\n@@ -3489,15 +3839,20 @@\n \n                 if( IS_EXTERNAL_INDEX_VALID(\
    \ lIndex ) != pdFALSE )\n                 {\n-                    xInternalEventGroupHandle\
    \ = MPU_GetEventGroupHandleAtIndex( CONVERT_TO_INTERNAL_INDEX( lIndex ) );\n+\
    \                    xCallingTaskIsAuthorizedToAccessEventGroup = xPortIsAuthorizedToAccessKernelObject(\
    \ CONVERT_TO_INTERNAL_INDEX( lIndex ) );\n \n-                    if( xInternalEventGroupHandle\
    \ != NULL )\n+                    if( xCallingTaskIsAuthorizedToAccessEventGroup\
    \ == pdTRUE )\n                     {\n-                        xReturn = xEventGroupWaitBits(\
    \ xInternalEventGroupHandle,\n-                                              \
    \         pxParams->uxBitsToWaitFor,\n-                                      \
    \                 pxParams->xClearOnExit,\n-                                 \
    \                      pxParams->xWaitForAllBits,\n-                         \
    \                              pxParams->xTicksToWait );\n+                  \
    \      xInternalEventGroupHandle = MPU_GetEventGroupHandleAtIndex( CONVERT_TO_INTERNAL_INDEX(\
    \ lIndex ) );\n+\n+                        if( xInternalEventGroupHandle != NULL\
    \ )\n+                        {\n+                            xReturn = xEventGroupWaitBits(\
    \ xInternalEventGroupHandle,\n+                                              \
    \             pxParams->uxBitsToWaitFor,\n+                                  \
    \                         pxParams->xClearOnExit,\n+                         \
    \                                  pxParams->xWaitForAllBits,\n+             \
    \                                              pxParams->xTicksToWait );\n+  \
    \                      }\n                     }\n                 }\n       \
    \      }\n@@ -3516,18 +3871,24 @@\n         EventBits_t xReturn = 0;\n       \
    \  EventGroupHandle_t xInternalEventGroupHandle = NULL;\n         int32_t lIndex;\n\
    +        BaseType_t xCallingTaskIsAuthorizedToAccessEventGroup = pdFALSE;\n \n\
    \         if( ( uxBitsToClear & eventEVENT_BITS_CONTROL_BYTES ) == 0 )\n     \
    \    {\n             lIndex = ( int32_t ) xEventGroup;\n \n             if( IS_EXTERNAL_INDEX_VALID(\
    \ lIndex ) != pdFALSE )\n             {\n-                xInternalEventGroupHandle\
    \ = MPU_GetEventGroupHandleAtIndex( CONVERT_TO_INTERNAL_INDEX( lIndex ) );\n+\
    \                xCallingTaskIsAuthorizedToAccessEventGroup = xPortIsAuthorizedToAccessKernelObject(\
    \ CONVERT_TO_INTERNAL_INDEX( lIndex ) );\n \n-                if( xInternalEventGroupHandle\
    \ != NULL )\n+                if( xCallingTaskIsAuthorizedToAccessEventGroup ==\
    \ pdTRUE )\n                 {\n-                    xReturn = xEventGroupClearBits(\
    \ xInternalEventGroupHandle, uxBitsToClear );\n+                    xInternalEventGroupHandle\
    \ = MPU_GetEventGroupHandleAtIndex( CONVERT_TO_INTERNAL_INDEX( lIndex ) );\n+\n\
    +                    if( xInternalEventGroupHandle != NULL )\n+              \
    \      {\n+                        xReturn = xEventGroupClearBits( xInternalEventGroupHandle,\
    \ uxBitsToClear );\n+                    }\n                 }\n             }\n\
    \         }\n@@ -3545,18 +3906,24 @@\n         EventBits_t xReturn = 0;\n    \
    \     EventGroupHandle_t xInternalEventGroupHandle = NULL;\n         int32_t lIndex;\n\
    +        BaseType_t xCallingTaskIsAuthorizedToAccessEventGroup = pdFALSE;\n \n\
    \         if( ( uxBitsToSet & eventEVENT_BITS_CONTROL_BYTES ) == 0 )\n       \
    \  {\n             lIndex = ( int32_t ) xEventGroup;\n \n             if( IS_EXTERNAL_INDEX_VALID(\
    \ lIndex ) != pdFALSE )\n             {\n-                xInternalEventGroupHandle\
    \ = MPU_GetEventGroupHandleAtIndex( CONVERT_TO_INTERNAL_INDEX( lIndex ) );\n+\
    \                xCallingTaskIsAuthorizedToAccessEventGroup = xPortIsAuthorizedToAccessKernelObject(\
    \ CONVERT_TO_INTERNAL_INDEX( lIndex ) );\n \n-                if( xInternalEventGroupHandle\
    \ != NULL )\n+                if( xCallingTaskIsAuthorizedToAccessEventGroup ==\
    \ pdTRUE )\n                 {\n-                    xReturn = xEventGroupSetBits(\
    \ xInternalEventGroupHandle, uxBitsToSet );\n+                    xInternalEventGroupHandle\
    \ = MPU_GetEventGroupHandleAtIndex( CONVERT_TO_INTERNAL_INDEX( lIndex ) );\n+\n\
    +                    if( xInternalEventGroupHandle != NULL )\n+              \
    \      {\n+                        xReturn = xEventGroupSetBits( xInternalEventGroupHandle,\
    \ uxBitsToSet );\n+                    }\n                 }\n             }\n\
    \         }\n@@ -3578,6 +3945,7 @@\n         EventBits_t xReturn = 0;\n      \
    \   EventGroupHandle_t xInternalEventGroupHandle = NULL;\n         int32_t lIndex;\n\
    +        BaseType_t xCallingTaskIsAuthorizedToAccessEventGroup = pdFALSE;\n \n\
    \         if( ( ( uxBitsToWaitFor & eventEVENT_BITS_CONTROL_BYTES ) == 0 ) &&\n\
    \             ( uxBitsToWaitFor != 0 )\n@@ -3590,11 +3958,16 @@\n \n         \
    \    if( IS_EXTERNAL_INDEX_VALID( lIndex ) != pdFALSE )\n             {\n-   \
    \             xInternalEventGroupHandle = MPU_GetEventGroupHandleAtIndex( CONVERT_TO_INTERNAL_INDEX(\
    \ lIndex ) );\n+                xCallingTaskIsAuthorizedToAccessEventGroup = xPortIsAuthorizedToAccessKernelObject(\
    \ CONVERT_TO_INTERNAL_INDEX( lIndex ) );\n \n-                if( xInternalEventGroupHandle\
    \ != NULL )\n+                if( xCallingTaskIsAuthorizedToAccessEventGroup ==\
    \ pdTRUE )\n                 {\n-                    xReturn = xEventGroupSync(\
    \ xInternalEventGroupHandle, uxBitsToSet, uxBitsToWaitFor, xTicksToWait );\n+\
    \                    xInternalEventGroupHandle = MPU_GetEventGroupHandleAtIndex(\
    \ CONVERT_TO_INTERNAL_INDEX( lIndex ) );\n+\n+                    if( xInternalEventGroupHandle\
    \ != NULL )\n+                    {\n+                        xReturn = xEventGroupSync(\
    \ xInternalEventGroupHandle, uxBitsToSet, uxBitsToWaitFor, xTicksToWait );\n+\
    \                    }\n                 }\n             }\n         }\n@@ -3612,16\
    \ +3985,22 @@\n             UBaseType_t xReturn = 0;\n             EventGroupHandle_t\
    \ xInternalEventGroupHandle = NULL;\n             int32_t lIndex;\n+         \
    \   BaseType_t xCallingTaskIsAuthorizedToAccessEventGroup = pdFALSE;\n \n    \
    \         lIndex = ( int32_t ) xEventGroup;\n \n             if( IS_EXTERNAL_INDEX_VALID(\
    \ lIndex ) != pdFALSE )\n             {\n-                xInternalEventGroupHandle\
    \ = MPU_GetEventGroupHandleAtIndex( CONVERT_TO_INTERNAL_INDEX( lIndex ) );\n+\
    \                xCallingTaskIsAuthorizedToAccessEventGroup = xPortIsAuthorizedToAccessKernelObject(\
    \ CONVERT_TO_INTERNAL_INDEX( lIndex ) );\n \n-                if( xInternalEventGroupHandle\
    \ != NULL )\n+                if( xCallingTaskIsAuthorizedToAccessEventGroup ==\
    \ pdTRUE )\n                 {\n-                    xReturn = uxEventGroupGetNumber(\
    \ xInternalEventGroupHandle );\n+                    xInternalEventGroupHandle\
    \ = MPU_GetEventGroupHandleAtIndex( CONVERT_TO_INTERNAL_INDEX( lIndex ) );\n+\n\
    +                    if( xInternalEventGroupHandle != NULL )\n+              \
    \      {\n+                        xReturn = uxEventGroupGetNumber( xInternalEventGroupHandle\
    \ );\n+                    }\n                 }\n             }\n \n@@ -3641,16\
    \ +4020,22 @@\n         {\n             EventGroupHandle_t xInternalEventGroupHandle\
    \ = NULL;\n             int32_t lIndex;\n+            BaseType_t xCallingTaskIsAuthorizedToAccessEventGroup\
    \ = pdFALSE;\n \n             lIndex = ( int32_t ) xEventGroup;\n \n         \
    \    if( IS_EXTERNAL_INDEX_VALID( lIndex ) != pdFALSE )\n             {\n-   \
    \             xInternalEventGroupHandle = MPU_GetEventGroupHandleAtIndex( CONVERT_TO_INTERNAL_INDEX(\
    \ lIndex ) );\n+                xCallingTaskIsAuthorizedToAccessEventGroup = xPortIsAuthorizedToAccessKernelObject(\
    \ CONVERT_TO_INTERNAL_INDEX( lIndex ) );\n \n-                if( xInternalEventGroupHandle\
    \ != NULL )\n+                if( xCallingTaskIsAuthorizedToAccessEventGroup ==\
    \ pdTRUE )\n                 {\n-                    vEventGroupSetNumber( xInternalEventGroupHandle,\
    \ uxEventGroupNumber );\n+                    xInternalEventGroupHandle = MPU_GetEventGroupHandleAtIndex(\
    \ CONVERT_TO_INTERNAL_INDEX( lIndex ) );\n+\n+                    if( xInternalEventGroupHandle\
    \ != NULL )\n+                    {\n+                        vEventGroupSetNumber(\
    \ xInternalEventGroupHandle, uxEventGroupNumber );\n+                    }\n \
    \                }\n             }\n         }\n@@ -3867,6 +4252,7 @@\n      \
    \   StreamBufferHandle_t xInternalStreamBufferHandle = NULL;\n         int32_t\
    \ lIndex;\n         BaseType_t xIsTxDataBufferReadable = pdFALSE;\n+        BaseType_t\
    \ xCallingTaskIsAuthorizedToAccessStreamBuffer = pdFALSE;\n \n         if( pvTxData\
    \ != NULL )\n         {\n@@ -3880,11 +4266,16 @@\n \n                 if( IS_EXTERNAL_INDEX_VALID(\
    \ lIndex ) != pdFALSE )\n                 {\n-                    xInternalStreamBufferHandle\
    \ = MPU_GetStreamBufferHandleAtIndex( CONVERT_TO_INTERNAL_INDEX( lIndex ) );\n\
    +                    xCallingTaskIsAuthorizedToAccessStreamBuffer = xPortIsAuthorizedToAccessKernelObject(\
    \ CONVERT_TO_INTERNAL_INDEX( lIndex ) );\n \n-                    if( xInternalStreamBufferHandle\
    \ != NULL )\n+                    if( xCallingTaskIsAuthorizedToAccessStreamBuffer\
    \ == pdTRUE )\n                     {\n-                        xReturn = xStreamBufferSend(\
    \ xInternalStreamBufferHandle, pvTxData, xDataLengthBytes, xTicksToWait );\n+\
    \                        xInternalStreamBufferHandle = MPU_GetStreamBufferHandleAtIndex(\
    \ CONVERT_TO_INTERNAL_INDEX( lIndex ) );\n+\n+                        if( xInternalStreamBufferHandle\
    \ != NULL )\n+                        {\n+                            xReturn\
    \ = xStreamBufferSend( xInternalStreamBufferHandle, pvTxData, xDataLengthBytes,\
    \ xTicksToWait );\n+                        }\n                     }\n      \
    \           }\n             }\n@@ -3908,6 +4299,7 @@\n         StreamBufferHandle_t\
    \ xInternalStreamBufferHandle = NULL;\n         int32_t lIndex;\n         BaseType_t\
    \ xIsRxDataBufferWriteable = pdFALSE;\n+        BaseType_t xCallingTaskIsAuthorizedToAccessStreamBuffer\
    \ = pdFALSE;\n \n         if( pvRxData != NULL )\n         {\n@@ -3921,11 +4313,16\
    \ @@\n \n                 if( IS_EXTERNAL_INDEX_VALID( lIndex ) != pdFALSE )\n\
    \                 {\n-                    xInternalStreamBufferHandle = MPU_GetStreamBufferHandleAtIndex(\
    \ CONVERT_TO_INTERNAL_INDEX( lIndex ) );\n+                    xCallingTaskIsAuthorizedToAccessStreamBuffer\
    \ = xPortIsAuthorizedToAccessKernelObject( CONVERT_TO_INTERNAL_INDEX( lIndex )\
    \ );\n \n-                    if( xInternalStreamBufferHandle != NULL )\n+   \
    \                 if( xCallingTaskIsAuthorizedToAccessStreamBuffer == pdTRUE )\n\
    \                     {\n-                        xReturn = xStreamBufferReceive(\
    \ xInternalStreamBufferHandle, pvRxData, xBufferLengthBytes, xTicksToWait );\n\
    +                        xInternalStreamBufferHandle = MPU_GetStreamBufferHandleAtIndex(\
    \ CONVERT_TO_INTERNAL_INDEX( lIndex ) );\n+\n+                        if( xInternalStreamBufferHandle\
    \ != NULL )\n+                        {\n+                            xReturn\
    \ = xStreamBufferReceive( xInternalStreamBufferHandle, pvRxData, xBufferLengthBytes,\
    \ xTicksToWait );\n+                        }\n                     }\n      \
    \           }\n             }\n@@ -3942,16 +4339,22 @@\n         BaseType_t xReturn\
    \ = pdFALSE;\n         StreamBufferHandle_t xInternalStreamBufferHandle = NULL;\n\
    \         int32_t lIndex;\n+        BaseType_t xCallingTaskIsAuthorizedToAccessStreamBuffer\
    \ = pdFALSE;\n \n         lIndex = ( int32_t ) xStreamBuffer;\n \n         if(\
    \ IS_EXTERNAL_INDEX_VALID( lIndex ) != pdFALSE )\n         {\n-            xInternalStreamBufferHandle\
    \ = MPU_GetStreamBufferHandleAtIndex( CONVERT_TO_INTERNAL_INDEX( lIndex ) );\n\
    +            xCallingTaskIsAuthorizedToAccessStreamBuffer = xPortIsAuthorizedToAccessKernelObject(\
    \ CONVERT_TO_INTERNAL_INDEX( lIndex ) );\n \n-            if( xInternalStreamBufferHandle\
    \ != NULL )\n+            if( xCallingTaskIsAuthorizedToAccessStreamBuffer ==\
    \ pdTRUE )\n             {\n-                xReturn = xStreamBufferIsFull( xInternalStreamBufferHandle\
    \ );\n+                xInternalStreamBufferHandle = MPU_GetStreamBufferHandleAtIndex(\
    \ CONVERT_TO_INTERNAL_INDEX( lIndex ) );\n+\n+                if( xInternalStreamBufferHandle\
    \ != NULL )\n+                {\n+                    xReturn = xStreamBufferIsFull(\
    \ xInternalStreamBufferHandle );\n+                }\n             }\n       \
    \  }\n \n@@ -3966,16 +4369,22 @@\n         BaseType_t xReturn = pdFALSE;\n   \
    \      StreamBufferHandle_t xInternalStreamBufferHandle = NULL;\n         int32_t\
    \ lIndex;\n+        BaseType_t xCallingTaskIsAuthorizedToAccessStreamBuffer =\
    \ pdFALSE;\n \n         lIndex = ( int32_t ) xStreamBuffer;\n \n         if( IS_EXTERNAL_INDEX_VALID(\
    \ lIndex ) != pdFALSE )\n         {\n-            xInternalStreamBufferHandle\
    \ = MPU_GetStreamBufferHandleAtIndex( CONVERT_TO_INTERNAL_INDEX( lIndex ) );\n\
    +            xCallingTaskIsAuthorizedToAccessStreamBuffer = xPortIsAuthorizedToAccessKernelObject(\
    \ CONVERT_TO_INTERNAL_INDEX( lIndex ) );\n \n-            if( xInternalStreamBufferHandle\
    \ != NULL )\n+            if( xCallingTaskIsAuthorizedToAccessStreamBuffer ==\
    \ pdTRUE )\n             {\n-                xReturn = xStreamBufferIsEmpty( xInternalStreamBufferHandle\
    \ );\n+                xInternalStreamBufferHandle = MPU_GetStreamBufferHandleAtIndex(\
    \ CONVERT_TO_INTERNAL_INDEX( lIndex ) );\n+\n+                if( xInternalStreamBufferHandle\
    \ != NULL )\n+                {\n+                    xReturn = xStreamBufferIsEmpty(\
    \ xInternalStreamBufferHandle );\n+                }\n             }\n       \
    \  }\n \n@@ -3990,16 +4399,22 @@\n         size_t xReturn = 0;\n         StreamBufferHandle_t\
    \ xInternalStreamBufferHandle = NULL;\n         int32_t lIndex;\n+        BaseType_t\
    \ xCallingTaskIsAuthorizedToAccessStreamBuffer = pdFALSE;\n \n         lIndex\
    \ = ( int32_t ) xStreamBuffer;\n \n         if( IS_EXTERNAL_INDEX_VALID( lIndex\
    \ ) != pdFALSE )\n         {\n-            xInternalStreamBufferHandle = MPU_GetStreamBufferHandleAtIndex(\
    \ CONVERT_TO_INTERNAL_INDEX( lIndex ) );\n+            xCallingTaskIsAuthorizedToAccessStreamBuffer\
    \ = xPortIsAuthorizedToAccessKernelObject( CONVERT_TO_INTERNAL_INDEX( lIndex )\
    \ );\n \n-            if( xInternalStreamBufferHandle != NULL )\n+           \
    \ if( xCallingTaskIsAuthorizedToAccessStreamBuffer == pdTRUE )\n             {\n\
    -                xReturn = xStreamBufferSpacesAvailable( xInternalStreamBufferHandle\
    \ );\n+                xInternalStreamBufferHandle = MPU_GetStreamBufferHandleAtIndex(\
    \ CONVERT_TO_INTERNAL_INDEX( lIndex ) );\n+\n+                if( xInternalStreamBufferHandle\
    \ != NULL )\n+                {\n+                    xReturn = xStreamBufferSpacesAvailable(\
    \ xInternalStreamBufferHandle );\n+                }\n             }\n       \
    \  }\n \n@@ -4014,16 +4429,22 @@\n         size_t xReturn = 0;\n         StreamBufferHandle_t\
    \ xInternalStreamBufferHandle = NULL;\n         int32_t lIndex;\n+        BaseType_t\
    \ xCallingTaskIsAuthorizedToAccessStreamBuffer = pdFALSE;\n \n         lIndex\
    \ = ( int32_t ) xStreamBuffer;\n \n         if( IS_EXTERNAL_INDEX_VALID( lIndex\
    \ ) != pdFALSE )\n         {\n-            xInternalStreamBufferHandle = MPU_GetStreamBufferHandleAtIndex(\
    \ CONVERT_TO_INTERNAL_INDEX( lIndex ) );\n+            xCallingTaskIsAuthorizedToAccessStreamBuffer\
    \ = xPortIsAuthorizedToAccessKernelObject( CONVERT_TO_INTERNAL_INDEX( lIndex )\
    \ );\n \n-            if( xInternalStreamBufferHandle != NULL )\n+           \
    \ if( xCallingTaskIsAuthorizedToAccessStreamBuffer == pdTRUE )\n             {\n\
    -                xReturn = xStreamBufferBytesAvailable( xInternalStreamBufferHandle\
    \ );\n+                xInternalStreamBufferHandle = MPU_GetStreamBufferHandleAtIndex(\
    \ CONVERT_TO_INTERNAL_INDEX( lIndex ) );\n+\n+                if( xInternalStreamBufferHandle\
    \ != NULL )\n+                {\n+                    xReturn = xStreamBufferBytesAvailable(\
    \ xInternalStreamBufferHandle );\n+                }\n             }\n       \
    \  }\n \n@@ -4040,16 +4461,22 @@\n         BaseType_t xReturn = pdFALSE;\n   \
    \      StreamBufferHandle_t xInternalStreamBufferHandle = NULL;\n         int32_t\
    \ lIndex;\n+        BaseType_t xCallingTaskIsAuthorizedToAccessStreamBuffer =\
    \ pdFALSE;\n \n         lIndex = ( int32_t ) xStreamBuffer;\n \n         if( IS_EXTERNAL_INDEX_VALID(\
    \ lIndex ) != pdFALSE )\n         {\n-            xInternalStreamBufferHandle\
    \ = MPU_GetStreamBufferHandleAtIndex( CONVERT_TO_INTERNAL_INDEX( lIndex ) );\n\
    +            xCallingTaskIsAuthorizedToAccessStreamBuffer = xPortIsAuthorizedToAccessKernelObject(\
    \ CONVERT_TO_INTERNAL_INDEX( lIndex ) );\n \n-            if( xInternalStreamBufferHandle\
    \ != NULL )\n+            if( xCallingTaskIsAuthorizedToAccessStreamBuffer ==\
    \ pdTRUE )\n             {\n-                xReturn = xStreamBufferSetTriggerLevel(\
    \ xInternalStreamBufferHandle, xTriggerLevel );\n+                xInternalStreamBufferHandle\
    \ = MPU_GetStreamBufferHandleAtIndex( CONVERT_TO_INTERNAL_INDEX( lIndex ) );\n\
    +\n+                if( xInternalStreamBufferHandle != NULL )\n+             \
    \   {\n+                    xReturn = xStreamBufferSetTriggerLevel( xInternalStreamBufferHandle,\
    \ xTriggerLevel );\n+                }\n             }\n         }\n \n@@ -4064,16\
    \ +4491,22 @@\n         size_t xReturn = 0;\n         StreamBufferHandle_t xInternalStreamBufferHandle\
    \ = NULL;\n         int32_t lIndex;\n+        BaseType_t xCallingTaskIsAuthorizedToAccessStreamBuffer\
    \ = pdFALSE;\n \n         lIndex = ( int32_t ) xStreamBuffer;\n \n         if(\
    \ IS_EXTERNAL_INDEX_VALID( lIndex ) != pdFALSE )\n         {\n-            xInternalStreamBufferHandle\
    \ = MPU_GetStreamBufferHandleAtIndex( CONVERT_TO_INTERNAL_INDEX( lIndex ) );\n\
    +            xCallingTaskIsAuthorizedToAccessStreamBuffer = xPortIsAuthorizedToAccessKernelObject(\
    \ CONVERT_TO_INTERNAL_INDEX( lIndex ) );\n \n-            if( xInternalStreamBufferHandle\
    \ != NULL )\n+            if( xCallingTaskIsAuthorizedToAccessStreamBuffer ==\
    \ pdTRUE )\n             {\n-                xReturn = xStreamBufferNextMessageLengthBytes(\
    \ xInternalStreamBufferHandle );\n+                xInternalStreamBufferHandle\
    \ = MPU_GetStreamBufferHandleAtIndex( CONVERT_TO_INTERNAL_INDEX( lIndex ) );\n\
    +\n+                if( xInternalStreamBufferHandle != NULL )\n+             \
    \   {\n+                    xReturn = xStreamBufferNextMessageLengthBytes( xInternalStreamBufferHandle\
    \ );\n+                }\n             }\n         }\n "
  - "--- a/portable/GCC/ARM_CM23/non_secure/port.c\n+++ b/portable/GCC/ARM_CM23/non_secure/port.c\n\
    @@ -472,6 +472,15 @@ portDONT_DISCARD void vPortSVCHandler_C( uint32_t * pulCallerStackAddress\
    \ ) PRIV\n #endif /* configENABLE_MPU == 1 */\n /*-----------------------------------------------------------*/\n\
    \ \n+#if ( ( configENABLE_MPU == 1 ) && ( configUSE_MPU_WRAPPERS_V1 == 0 ) &&\
    \ ( configENABLE_ACCESS_CONTROL_LIST == 1 ) )\n+\n+/**\n+ * @brief This variable\
    \ is set to pdTRUE when the scheduler is started.\n+ */\n+    PRIVILEGED_DATA\
    \ static BaseType_t xSchedulerRunning = pdFALSE;\n+\n+#endif\n+\n /**\n  * @brief\
    \ Each task maintains its own interrupt status in the critical nesting\n  * variable.\n\
    @@ -1651,6 +1660,12 @@ BaseType_t xPortStartScheduler( void ) /* PRIVILEGED_FUNCTION\
    \ */\n     /* Initialize the critical nesting count ready for the first task.\
    \ */\n     ulCriticalNesting = 0;\n \n+    #if ( ( configENABLE_MPU == 1 ) &&\
    \ ( configUSE_MPU_WRAPPERS_V1 == 0 ) && ( configENABLE_ACCESS_CONTROL_LIST ==\
    \ 1 ) )\n+    {\n+        xSchedulerRunning = pdTRUE;\n+    }\n+    #endif\n+\n\
    \     /* Start the first task. */\n     vStartFirstTask();\n \n@@ -1931,3 +1946,98\
    \ @@ BaseType_t xPortIsInsideInterrupt( void )\n \n #endif /* #if ( ( configASSERT_DEFINED\
    \ == 1 ) && ( portHAS_BASEPRI == 1 ) ) */\n /*-----------------------------------------------------------*/\n\
    +\n+#if ( ( configENABLE_MPU == 1 ) && ( configUSE_MPU_WRAPPERS_V1 == 0 ) && (\
    \ configENABLE_ACCESS_CONTROL_LIST == 1 ) )\n+\n+    void vPortGrantAccessToKernelObject(\
    \ TaskHandle_t xInternalTaskHandle,\n+                                       \
    \  int32_t lInternalIndexOfKernelObject ) /* PRIVILEGED_FUNCTION */\n+    {\n\
    +        uint32_t ulAccessControlListEntryIndex, ulAccessControlListEntryBit;\n\
    +        xMPU_SETTINGS * xTaskMpuSettings;\n+\n+        ulAccessControlListEntryIndex\
    \ = ( ( uint32_t ) lInternalIndexOfKernelObject / portACL_ENTRY_SIZE_BITS );\n\
    +        ulAccessControlListEntryBit = ( ( uint32_t ) lInternalIndexOfKernelObject\
    \ % portACL_ENTRY_SIZE_BITS );\n+\n+        xTaskMpuSettings = xTaskGetMPUSettings(\
    \ xInternalTaskHandle );\n+\n+        xTaskMpuSettings->ulAccessControlList[ ulAccessControlListEntryIndex\
    \ ] |= ( 1U << ulAccessControlListEntryBit );\n+    }\n+\n+#endif /* #if ( ( configENABLE_MPU\
    \ == 1 ) && ( configUSE_MPU_WRAPPERS_V1 == 0 ) && ( configENABLE_ACCESS_CONTROL_LIST\
    \ == 1 ) ) */\n+/*-----------------------------------------------------------*/\n\
    +\n+#if ( ( configENABLE_MPU == 1 ) && ( configUSE_MPU_WRAPPERS_V1 == 0 ) && (\
    \ configENABLE_ACCESS_CONTROL_LIST == 1 ) )\n+\n+    void vPortRevokeAccessToKernelObject(\
    \ TaskHandle_t xInternalTaskHandle,\n+                                       \
    \   int32_t lInternalIndexOfKernelObject ) /* PRIVILEGED_FUNCTION */\n+    {\n\
    +        uint32_t ulAccessControlListEntryIndex, ulAccessControlListEntryBit;\n\
    +        xMPU_SETTINGS * xTaskMpuSettings;\n+\n+        ulAccessControlListEntryIndex\
    \ = ( ( uint32_t ) lInternalIndexOfKernelObject / portACL_ENTRY_SIZE_BITS );\n\
    +        ulAccessControlListEntryBit = ( ( uint32_t ) lInternalIndexOfKernelObject\
    \ % portACL_ENTRY_SIZE_BITS );\n+\n+        xTaskMpuSettings = xTaskGetMPUSettings(\
    \ xInternalTaskHandle );\n+\n+        xTaskMpuSettings->ulAccessControlList[ ulAccessControlListEntryIndex\
    \ ] &= ~( 1U << ulAccessControlListEntryBit );\n+    }\n+\n+#endif /* #if ( (\
    \ configENABLE_MPU == 1 ) && ( configUSE_MPU_WRAPPERS_V1 == 0 ) && ( configENABLE_ACCESS_CONTROL_LIST\
    \ == 1 ) ) */\n+/*-----------------------------------------------------------*/\n\
    +\n+#if ( ( configENABLE_MPU == 1 ) && ( configUSE_MPU_WRAPPERS_V1 == 0 ) )\n\
    +\n+    #if ( configENABLE_ACCESS_CONTROL_LIST == 1 )\n+\n+        BaseType_t\
    \ xPortIsAuthorizedToAccessKernelObject( int32_t lInternalIndexOfKernelObject\
    \ ) /* PRIVILEGED_FUNCTION */\n+        {\n+            uint32_t ulAccessControlListEntryIndex,\
    \ ulAccessControlListEntryBit;\n+            BaseType_t xAccessGranted = pdFALSE;\n\
    +            const xMPU_SETTINGS * xTaskMpuSettings;\n+\n+            if( xSchedulerRunning\
    \ == pdFALSE )\n+            {\n+                /* Grant access to all the kernel\
    \ objects before the scheduler\n+                 * is started. It is necessary\
    \ because there is no task running\n+                 * yet and therefore, we\
    \ cannot use the permissions of any\n+                 * task. */\n+         \
    \       xAccessGranted = pdTRUE;\n+            }\n+            else\n+       \
    \     {\n+                xTaskMpuSettings = xTaskGetMPUSettings( NULL ); /* Calling\
    \ task's MPU settings. */\n+\n+                ulAccessControlListEntryIndex =\
    \ ( ( uint32_t ) lInternalIndexOfKernelObject / portACL_ENTRY_SIZE_BITS );\n+\
    \                ulAccessControlListEntryBit = ( ( uint32_t ) lInternalIndexOfKernelObject\
    \ % portACL_ENTRY_SIZE_BITS );\n+\n+                if( ( xTaskMpuSettings->ulTaskFlags\
    \ & portTASK_IS_PRIVILEGED_FLAG ) == portTASK_IS_PRIVILEGED_FLAG )\n+        \
    \        {\n+                    xAccessGranted = pdTRUE;\n+                }\n\
    +                else\n+                {\n+                    if( ( xTaskMpuSettings->ulAccessControlList[\
    \ ulAccessControlListEntryIndex ] & ( 1U << ulAccessControlListEntryBit ) ) !=\
    \ 0 )\n+                    {\n+                        xAccessGranted = pdTRUE;\n\
    +                    }\n+                }\n+            }\n+\n+            return\
    \ xAccessGranted;\n+        }\n+\n+    #else /* #if ( configENABLE_ACCESS_CONTROL_LIST\
    \ == 1 ) */\n+\n+        BaseType_t xPortIsAuthorizedToAccessKernelObject( int32_t\
    \ lInternalIndexOfKernelObject ) /* PRIVILEGED_FUNCTION */\n+        {\n+    \
    \        ( void ) lInternalIndexOfKernelObject;\n+\n+            /* If Access\
    \ Control List feature is not used, all the tasks have\n+             * access\
    \ to all the kernel objects. */\n+            return pdTRUE;\n+        }\n+\n\
    +    #endif /* #if ( configENABLE_ACCESS_CONTROL_LIST == 1 ) */\n+\n+#endif /*\
    \ #if ( ( configENABLE_MPU == 1 ) && ( configUSE_MPU_WRAPPERS_V1 == 0 ) ) */\n\
    +/*-----------------------------------------------------------*/"
  - "--- a/portable/GCC/ARM_CM23_NTZ/non_secure/port.c\n+++ b/portable/GCC/ARM_CM23_NTZ/non_secure/port.c\n\
    @@ -472,6 +472,15 @@ portDONT_DISCARD void vPortSVCHandler_C( uint32_t * pulCallerStackAddress\
    \ ) PRIV\n #endif /* configENABLE_MPU == 1 */\n /*-----------------------------------------------------------*/\n\
    \ \n+#if ( ( configENABLE_MPU == 1 ) && ( configUSE_MPU_WRAPPERS_V1 == 0 ) &&\
    \ ( configENABLE_ACCESS_CONTROL_LIST == 1 ) )\n+\n+/**\n+ * @brief This variable\
    \ is set to pdTRUE when the scheduler is started.\n+ */\n+    PRIVILEGED_DATA\
    \ static BaseType_t xSchedulerRunning = pdFALSE;\n+\n+#endif\n+\n /**\n  * @brief\
    \ Each task maintains its own interrupt status in the critical nesting\n  * variable.\n\
    @@ -1651,6 +1660,12 @@ BaseType_t xPortStartScheduler( void ) /* PRIVILEGED_FUNCTION\
    \ */\n     /* Initialize the critical nesting count ready for the first task.\
    \ */\n     ulCriticalNesting = 0;\n \n+    #if ( ( configENABLE_MPU == 1 ) &&\
    \ ( configUSE_MPU_WRAPPERS_V1 == 0 ) && ( configENABLE_ACCESS_CONTROL_LIST ==\
    \ 1 ) )\n+    {\n+        xSchedulerRunning = pdTRUE;\n+    }\n+    #endif\n+\n\
    \     /* Start the first task. */\n     vStartFirstTask();\n \n@@ -1931,3 +1946,98\
    \ @@ BaseType_t xPortIsInsideInterrupt( void )\n \n #endif /* #if ( ( configASSERT_DEFINED\
    \ == 1 ) && ( portHAS_BASEPRI == 1 ) ) */\n /*-----------------------------------------------------------*/\n\
    +\n+#if ( ( configENABLE_MPU == 1 ) && ( configUSE_MPU_WRAPPERS_V1 == 0 ) && (\
    \ configENABLE_ACCESS_CONTROL_LIST == 1 ) )\n+\n+    void vPortGrantAccessToKernelObject(\
    \ TaskHandle_t xInternalTaskHandle,\n+                                       \
    \  int32_t lInternalIndexOfKernelObject ) /* PRIVILEGED_FUNCTION */\n+    {\n\
    +        uint32_t ulAccessControlListEntryIndex, ulAccessControlListEntryBit;\n\
    +        xMPU_SETTINGS * xTaskMpuSettings;\n+\n+        ulAccessControlListEntryIndex\
    \ = ( ( uint32_t ) lInternalIndexOfKernelObject / portACL_ENTRY_SIZE_BITS );\n\
    +        ulAccessControlListEntryBit = ( ( uint32_t ) lInternalIndexOfKernelObject\
    \ % portACL_ENTRY_SIZE_BITS );\n+\n+        xTaskMpuSettings = xTaskGetMPUSettings(\
    \ xInternalTaskHandle );\n+\n+        xTaskMpuSettings->ulAccessControlList[ ulAccessControlListEntryIndex\
    \ ] |= ( 1U << ulAccessControlListEntryBit );\n+    }\n+\n+#endif /* #if ( ( configENABLE_MPU\
    \ == 1 ) && ( configUSE_MPU_WRAPPERS_V1 == 0 ) && ( configENABLE_ACCESS_CONTROL_LIST\
    \ == 1 ) ) */\n+/*-----------------------------------------------------------*/\n\
    +\n+#if ( ( configENABLE_MPU == 1 ) && ( configUSE_MPU_WRAPPERS_V1 == 0 ) && (\
    \ configENABLE_ACCESS_CONTROL_LIST == 1 ) )\n+\n+    void vPortRevokeAccessToKernelObject(\
    \ TaskHandle_t xInternalTaskHandle,\n+                                       \
    \   int32_t lInternalIndexOfKernelObject ) /* PRIVILEGED_FUNCTION */\n+    {\n\
    +        uint32_t ulAccessControlListEntryIndex, ulAccessControlListEntryBit;\n\
    +        xMPU_SETTINGS * xTaskMpuSettings;\n+\n+        ulAccessControlListEntryIndex\
    \ = ( ( uint32_t ) lInternalIndexOfKernelObject / portACL_ENTRY_SIZE_BITS );\n\
    +        ulAccessControlListEntryBit = ( ( uint32_t ) lInternalIndexOfKernelObject\
    \ % portACL_ENTRY_SIZE_BITS );\n+\n+        xTaskMpuSettings = xTaskGetMPUSettings(\
    \ xInternalTaskHandle );\n+\n+        xTaskMpuSettings->ulAccessControlList[ ulAccessControlListEntryIndex\
    \ ] &= ~( 1U << ulAccessControlListEntryBit );\n+    }\n+\n+#endif /* #if ( (\
    \ configENABLE_MPU == 1 ) && ( configUSE_MPU_WRAPPERS_V1 == 0 ) && ( configENABLE_ACCESS_CONTROL_LIST\
    \ == 1 ) ) */\n+/*-----------------------------------------------------------*/\n\
    +\n+#if ( ( configENABLE_MPU == 1 ) && ( configUSE_MPU_WRAPPERS_V1 == 0 ) )\n\
    +\n+    #if ( configENABLE_ACCESS_CONTROL_LIST == 1 )\n+\n+        BaseType_t\
    \ xPortIsAuthorizedToAccessKernelObject( int32_t lInternalIndexOfKernelObject\
    \ ) /* PRIVILEGED_FUNCTION */\n+        {\n+            uint32_t ulAccessControlListEntryIndex,\
    \ ulAccessControlListEntryBit;\n+            BaseType_t xAccessGranted = pdFALSE;\n\
    +            const xMPU_SETTINGS * xTaskMpuSettings;\n+\n+            if( xSchedulerRunning\
    \ == pdFALSE )\n+            {\n+                /* Grant access to all the kernel\
    \ objects before the scheduler\n+                 * is started. It is necessary\
    \ because there is no task running\n+                 * yet and therefore, we\
    \ cannot use the permissions of any\n+                 * task. */\n+         \
    \       xAccessGranted = pdTRUE;\n+            }\n+            else\n+       \
    \     {\n+                xTaskMpuSettings = xTaskGetMPUSettings( NULL ); /* Calling\
    \ task's MPU settings. */\n+\n+                ulAccessControlListEntryIndex =\
    \ ( ( uint32_t ) lInternalIndexOfKernelObject / portACL_ENTRY_SIZE_BITS );\n+\
    \                ulAccessControlListEntryBit = ( ( uint32_t ) lInternalIndexOfKernelObject\
    \ % portACL_ENTRY_SIZE_BITS );\n+\n+                if( ( xTaskMpuSettings->ulTaskFlags\
    \ & portTASK_IS_PRIVILEGED_FLAG ) == portTASK_IS_PRIVILEGED_FLAG )\n+        \
    \        {\n+                    xAccessGranted = pdTRUE;\n+                }\n\
    +                else\n+                {\n+                    if( ( xTaskMpuSettings->ulAccessControlList[\
    \ ulAccessControlListEntryIndex ] & ( 1U << ulAccessControlListEntryBit ) ) !=\
    \ 0 )\n+                    {\n+                        xAccessGranted = pdTRUE;\n\
    +                    }\n+                }\n+            }\n+\n+            return\
    \ xAccessGranted;\n+        }\n+\n+    #else /* #if ( configENABLE_ACCESS_CONTROL_LIST\
    \ == 1 ) */\n+\n+        BaseType_t xPortIsAuthorizedToAccessKernelObject( int32_t\
    \ lInternalIndexOfKernelObject ) /* PRIVILEGED_FUNCTION */\n+        {\n+    \
    \        ( void ) lInternalIndexOfKernelObject;\n+\n+            /* If Access\
    \ Control List feature is not used, all the tasks have\n+             * access\
    \ to all the kernel objects. */\n+            return pdTRUE;\n+        }\n+\n\
    +    #endif /* #if ( configENABLE_ACCESS_CONTROL_LIST == 1 ) */\n+\n+#endif /*\
    \ #if ( ( configENABLE_MPU == 1 ) && ( configUSE_MPU_WRAPPERS_V1 == 0 ) ) */\n\
    +/*-----------------------------------------------------------*/"
  - "--- a/portable/GCC/ARM_CM33/non_secure/port.c\n+++ b/portable/GCC/ARM_CM33/non_secure/port.c\n\
    @@ -472,6 +472,15 @@ portDONT_DISCARD void vPortSVCHandler_C( uint32_t * pulCallerStackAddress\
    \ ) PRIV\n #endif /* configENABLE_MPU == 1 */\n /*-----------------------------------------------------------*/\n\
    \ \n+#if ( ( configENABLE_MPU == 1 ) && ( configUSE_MPU_WRAPPERS_V1 == 0 ) &&\
    \ ( configENABLE_ACCESS_CONTROL_LIST == 1 ) )\n+\n+/**\n+ * @brief This variable\
    \ is set to pdTRUE when the scheduler is started.\n+ */\n+    PRIVILEGED_DATA\
    \ static BaseType_t xSchedulerRunning = pdFALSE;\n+\n+#endif\n+\n /**\n  * @brief\
    \ Each task maintains its own interrupt status in the critical nesting\n  * variable.\n\
    @@ -1651,6 +1660,12 @@ BaseType_t xPortStartScheduler( void ) /* PRIVILEGED_FUNCTION\
    \ */\n     /* Initialize the critical nesting count ready for the first task.\
    \ */\n     ulCriticalNesting = 0;\n \n+    #if ( ( configENABLE_MPU == 1 ) &&\
    \ ( configUSE_MPU_WRAPPERS_V1 == 0 ) && ( configENABLE_ACCESS_CONTROL_LIST ==\
    \ 1 ) )\n+    {\n+        xSchedulerRunning = pdTRUE;\n+    }\n+    #endif\n+\n\
    \     /* Start the first task. */\n     vStartFirstTask();\n \n@@ -1931,3 +1946,98\
    \ @@ BaseType_t xPortIsInsideInterrupt( void )\n \n #endif /* #if ( ( configASSERT_DEFINED\
    \ == 1 ) && ( portHAS_BASEPRI == 1 ) ) */\n /*-----------------------------------------------------------*/\n\
    +\n+#if ( ( configENABLE_MPU == 1 ) && ( configUSE_MPU_WRAPPERS_V1 == 0 ) && (\
    \ configENABLE_ACCESS_CONTROL_LIST == 1 ) )\n+\n+    void vPortGrantAccessToKernelObject(\
    \ TaskHandle_t xInternalTaskHandle,\n+                                       \
    \  int32_t lInternalIndexOfKernelObject ) /* PRIVILEGED_FUNCTION */\n+    {\n\
    +        uint32_t ulAccessControlListEntryIndex, ulAccessControlListEntryBit;\n\
    +        xMPU_SETTINGS * xTaskMpuSettings;\n+\n+        ulAccessControlListEntryIndex\
    \ = ( ( uint32_t ) lInternalIndexOfKernelObject / portACL_ENTRY_SIZE_BITS );\n\
    +        ulAccessControlListEntryBit = ( ( uint32_t ) lInternalIndexOfKernelObject\
    \ % portACL_ENTRY_SIZE_BITS );\n+\n+        xTaskMpuSettings = xTaskGetMPUSettings(\
    \ xInternalTaskHandle );\n+\n+        xTaskMpuSettings->ulAccessControlList[ ulAccessControlListEntryIndex\
    \ ] |= ( 1U << ulAccessControlListEntryBit );\n+    }\n+\n+#endif /* #if ( ( configENABLE_MPU\
    \ == 1 ) && ( configUSE_MPU_WRAPPERS_V1 == 0 ) && ( configENABLE_ACCESS_CONTROL_LIST\
    \ == 1 ) ) */\n+/*-----------------------------------------------------------*/\n\
    +\n+#if ( ( configENABLE_MPU == 1 ) && ( configUSE_MPU_WRAPPERS_V1 == 0 ) && (\
    \ configENABLE_ACCESS_CONTROL_LIST == 1 ) )\n+\n+    void vPortRevokeAccessToKernelObject(\
    \ TaskHandle_t xInternalTaskHandle,\n+                                       \
    \   int32_t lInternalIndexOfKernelObject ) /* PRIVILEGED_FUNCTION */\n+    {\n\
    +        uint32_t ulAccessControlListEntryIndex, ulAccessControlListEntryBit;\n\
    +        xMPU_SETTINGS * xTaskMpuSettings;\n+\n+        ulAccessControlListEntryIndex\
    \ = ( ( uint32_t ) lInternalIndexOfKernelObject / portACL_ENTRY_SIZE_BITS );\n\
    +        ulAccessControlListEntryBit = ( ( uint32_t ) lInternalIndexOfKernelObject\
    \ % portACL_ENTRY_SIZE_BITS );\n+\n+        xTaskMpuSettings = xTaskGetMPUSettings(\
    \ xInternalTaskHandle );\n+\n+        xTaskMpuSettings->ulAccessControlList[ ulAccessControlListEntryIndex\
    \ ] &= ~( 1U << ulAccessControlListEntryBit );\n+    }\n+\n+#endif /* #if ( (\
    \ configENABLE_MPU == 1 ) && ( configUSE_MPU_WRAPPERS_V1 == 0 ) && ( configENABLE_ACCESS_CONTROL_LIST\
    \ == 1 ) ) */\n+/*-----------------------------------------------------------*/\n\
    +\n+#if ( ( configENABLE_MPU == 1 ) && ( configUSE_MPU_WRAPPERS_V1 == 0 ) )\n\
    +\n+    #if ( configENABLE_ACCESS_CONTROL_LIST == 1 )\n+\n+        BaseType_t\
    \ xPortIsAuthorizedToAccessKernelObject( int32_t lInternalIndexOfKernelObject\
    \ ) /* PRIVILEGED_FUNCTION */\n+        {\n+            uint32_t ulAccessControlListEntryIndex,\
    \ ulAccessControlListEntryBit;\n+            BaseType_t xAccessGranted = pdFALSE;\n\
    +            const xMPU_SETTINGS * xTaskMpuSettings;\n+\n+            if( xSchedulerRunning\
    \ == pdFALSE )\n+            {\n+                /* Grant access to all the kernel\
    \ objects before the scheduler\n+                 * is started. It is necessary\
    \ because there is no task running\n+                 * yet and therefore, we\
    \ cannot use the permissions of any\n+                 * task. */\n+         \
    \       xAccessGranted = pdTRUE;\n+            }\n+            else\n+       \
    \     {\n+                xTaskMpuSettings = xTaskGetMPUSettings( NULL ); /* Calling\
    \ task's MPU settings. */\n+\n+                ulAccessControlListEntryIndex =\
    \ ( ( uint32_t ) lInternalIndexOfKernelObject / portACL_ENTRY_SIZE_BITS );\n+\
    \                ulAccessControlListEntryBit = ( ( uint32_t ) lInternalIndexOfKernelObject\
    \ % portACL_ENTRY_SIZE_BITS );\n+\n+                if( ( xTaskMpuSettings->ulTaskFlags\
    \ & portTASK_IS_PRIVILEGED_FLAG ) == portTASK_IS_PRIVILEGED_FLAG )\n+        \
    \        {\n+                    xAccessGranted = pdTRUE;\n+                }\n\
    +                else\n+                {\n+                    if( ( xTaskMpuSettings->ulAccessControlList[\
    \ ulAccessControlListEntryIndex ] & ( 1U << ulAccessControlListEntryBit ) ) !=\
    \ 0 )\n+                    {\n+                        xAccessGranted = pdTRUE;\n\
    +                    }\n+                }\n+            }\n+\n+            return\
    \ xAccessGranted;\n+        }\n+\n+    #else /* #if ( configENABLE_ACCESS_CONTROL_LIST\
    \ == 1 ) */\n+\n+        BaseType_t xPortIsAuthorizedToAccessKernelObject( int32_t\
    \ lInternalIndexOfKernelObject ) /* PRIVILEGED_FUNCTION */\n+        {\n+    \
    \        ( void ) lInternalIndexOfKernelObject;\n+\n+            /* If Access\
    \ Control List feature is not used, all the tasks have\n+             * access\
    \ to all the kernel objects. */\n+            return pdTRUE;\n+        }\n+\n\
    +    #endif /* #if ( configENABLE_ACCESS_CONTROL_LIST == 1 ) */\n+\n+#endif /*\
    \ #if ( ( configENABLE_MPU == 1 ) && ( configUSE_MPU_WRAPPERS_V1 == 0 ) ) */\n\
    +/*-----------------------------------------------------------*/"
  - "--- a/portable/GCC/ARM_CM33_NTZ/non_secure/port.c\n+++ b/portable/GCC/ARM_CM33_NTZ/non_secure/port.c\n\
    @@ -472,6 +472,15 @@ portDONT_DISCARD void vPortSVCHandler_C( uint32_t * pulCallerStackAddress\
    \ ) PRIV\n #endif /* configENABLE_MPU == 1 */\n /*-----------------------------------------------------------*/\n\
    \ \n+#if ( ( configENABLE_MPU == 1 ) && ( configUSE_MPU_WRAPPERS_V1 == 0 ) &&\
    \ ( configENABLE_ACCESS_CONTROL_LIST == 1 ) )\n+\n+/**\n+ * @brief This variable\
    \ is set to pdTRUE when the scheduler is started.\n+ */\n+    PRIVILEGED_DATA\
    \ static BaseType_t xSchedulerRunning = pdFALSE;\n+\n+#endif\n+\n /**\n  * @brief\
    \ Each task maintains its own interrupt status in the critical nesting\n  * variable.\n\
    @@ -1651,6 +1660,12 @@ BaseType_t xPortStartScheduler( void ) /* PRIVILEGED_FUNCTION\
    \ */\n     /* Initialize the critical nesting count ready for the first task.\
    \ */\n     ulCriticalNesting = 0;\n \n+    #if ( ( configENABLE_MPU == 1 ) &&\
    \ ( configUSE_MPU_WRAPPERS_V1 == 0 ) && ( configENABLE_ACCESS_CONTROL_LIST ==\
    \ 1 ) )\n+    {\n+        xSchedulerRunning = pdTRUE;\n+    }\n+    #endif\n+\n\
    \     /* Start the first task. */\n     vStartFirstTask();\n \n@@ -1931,3 +1946,98\
    \ @@ BaseType_t xPortIsInsideInterrupt( void )\n \n #endif /* #if ( ( configASSERT_DEFINED\
    \ == 1 ) && ( portHAS_BASEPRI == 1 ) ) */\n /*-----------------------------------------------------------*/\n\
    +\n+#if ( ( configENABLE_MPU == 1 ) && ( configUSE_MPU_WRAPPERS_V1 == 0 ) && (\
    \ configENABLE_ACCESS_CONTROL_LIST == 1 ) )\n+\n+    void vPortGrantAccessToKernelObject(\
    \ TaskHandle_t xInternalTaskHandle,\n+                                       \
    \  int32_t lInternalIndexOfKernelObject ) /* PRIVILEGED_FUNCTION */\n+    {\n\
    +        uint32_t ulAccessControlListEntryIndex, ulAccessControlListEntryBit;\n\
    +        xMPU_SETTINGS * xTaskMpuSettings;\n+\n+        ulAccessControlListEntryIndex\
    \ = ( ( uint32_t ) lInternalIndexOfKernelObject / portACL_ENTRY_SIZE_BITS );\n\
    +        ulAccessControlListEntryBit = ( ( uint32_t ) lInternalIndexOfKernelObject\
    \ % portACL_ENTRY_SIZE_BITS );\n+\n+        xTaskMpuSettings = xTaskGetMPUSettings(\
    \ xInternalTaskHandle );\n+\n+        xTaskMpuSettings->ulAccessControlList[ ulAccessControlListEntryIndex\
    \ ] |= ( 1U << ulAccessControlListEntryBit );\n+    }\n+\n+#endif /* #if ( ( configENABLE_MPU\
    \ == 1 ) && ( configUSE_MPU_WRAPPERS_V1 == 0 ) && ( configENABLE_ACCESS_CONTROL_LIST\
    \ == 1 ) ) */\n+/*-----------------------------------------------------------*/\n\
    +\n+#if ( ( configENABLE_MPU == 1 ) && ( configUSE_MPU_WRAPPERS_V1 == 0 ) && (\
    \ configENABLE_ACCESS_CONTROL_LIST == 1 ) )\n+\n+    void vPortRevokeAccessToKernelObject(\
    \ TaskHandle_t xInternalTaskHandle,\n+                                       \
    \   int32_t lInternalIndexOfKernelObject ) /* PRIVILEGED_FUNCTION */\n+    {\n\
    +        uint32_t ulAccessControlListEntryIndex, ulAccessControlListEntryBit;\n\
    +        xMPU_SETTINGS * xTaskMpuSettings;\n+\n+        ulAccessControlListEntryIndex\
    \ = ( ( uint32_t ) lInternalIndexOfKernelObject / portACL_ENTRY_SIZE_BITS );\n\
    +        ulAccessControlListEntryBit = ( ( uint32_t ) lInternalIndexOfKernelObject\
    \ % portACL_ENTRY_SIZE_BITS );\n+\n+        xTaskMpuSettings = xTaskGetMPUSettings(\
    \ xInternalTaskHandle );\n+\n+        xTaskMpuSettings->ulAccessControlList[ ulAccessControlListEntryIndex\
    \ ] &= ~( 1U << ulAccessControlListEntryBit );\n+    }\n+\n+#endif /* #if ( (\
    \ configENABLE_MPU == 1 ) && ( configUSE_MPU_WRAPPERS_V1 == 0 ) && ( configENABLE_ACCESS_CONTROL_LIST\
    \ == 1 ) ) */\n+/*-----------------------------------------------------------*/\n\
    +\n+#if ( ( configENABLE_MPU == 1 ) && ( configUSE_MPU_WRAPPERS_V1 == 0 ) )\n\
    +\n+    #if ( configENABLE_ACCESS_CONTROL_LIST == 1 )\n+\n+        BaseType_t\
    \ xPortIsAuthorizedToAccessKernelObject( int32_t lInternalIndexOfKernelObject\
    \ ) /* PRIVILEGED_FUNCTION */\n+        {\n+            uint32_t ulAccessControlListEntryIndex,\
    \ ulAccessControlListEntryBit;\n+            BaseType_t xAccessGranted = pdFALSE;\n\
    +            const xMPU_SETTINGS * xTaskMpuSettings;\n+\n+            if( xSchedulerRunning\
    \ == pdFALSE )\n+            {\n+                /* Grant access to all the kernel\
    \ objects before the scheduler\n+                 * is started. It is necessary\
    \ because there is no task running\n+                 * yet and therefore, we\
    \ cannot use the permissions of any\n+                 * task. */\n+         \
    \       xAccessGranted = pdTRUE;\n+            }\n+            else\n+       \
    \     {\n+                xTaskMpuSettings = xTaskGetMPUSettings( NULL ); /* Calling\
    \ task's MPU settings. */\n+\n+                ulAccessControlListEntryIndex =\
    \ ( ( uint32_t ) lInternalIndexOfKernelObject / portACL_ENTRY_SIZE_BITS );\n+\
    \                ulAccessControlListEntryBit = ( ( uint32_t ) lInternalIndexOfKernelObject\
    \ % portACL_ENTRY_SIZE_BITS );\n+\n+                if( ( xTaskMpuSettings->ulTaskFlags\
    \ & portTASK_IS_PRIVILEGED_FLAG ) == portTASK_IS_PRIVILEGED_FLAG )\n+        \
    \        {\n+                    xAccessGranted = pdTRUE;\n+                }\n\
    +                else\n+                {\n+                    if( ( xTaskMpuSettings->ulAccessControlList[\
    \ ulAccessControlListEntryIndex ] & ( 1U << ulAccessControlListEntryBit ) ) !=\
    \ 0 )\n+                    {\n+                        xAccessGranted = pdTRUE;\n\
    +                    }\n+                }\n+            }\n+\n+            return\
    \ xAccessGranted;\n+        }\n+\n+    #else /* #if ( configENABLE_ACCESS_CONTROL_LIST\
    \ == 1 ) */\n+\n+        BaseType_t xPortIsAuthorizedToAccessKernelObject( int32_t\
    \ lInternalIndexOfKernelObject ) /* PRIVILEGED_FUNCTION */\n+        {\n+    \
    \        ( void ) lInternalIndexOfKernelObject;\n+\n+            /* If Access\
    \ Control List feature is not used, all the tasks have\n+             * access\
    \ to all the kernel objects. */\n+            return pdTRUE;\n+        }\n+\n\
    +    #endif /* #if ( configENABLE_ACCESS_CONTROL_LIST == 1 ) */\n+\n+#endif /*\
    \ #if ( ( configENABLE_MPU == 1 ) && ( configUSE_MPU_WRAPPERS_V1 == 0 ) ) */\n\
    +/*-----------------------------------------------------------*/"
  - "--- a/portable/GCC/ARM_CM35P/non_secure/port.c\n+++ b/portable/GCC/ARM_CM35P/non_secure/port.c\n\
    @@ -472,6 +472,15 @@ portDONT_DISCARD void vPortSVCHandler_C( uint32_t * pulCallerStackAddress\
    \ ) PRIV\n #endif /* configENABLE_MPU == 1 */\n /*-----------------------------------------------------------*/\n\
    \ \n+#if ( ( configENABLE_MPU == 1 ) && ( configUSE_MPU_WRAPPERS_V1 == 0 ) &&\
    \ ( configENABLE_ACCESS_CONTROL_LIST == 1 ) )\n+\n+/**\n+ * @brief This variable\
    \ is set to pdTRUE when the scheduler is started.\n+ */\n+    PRIVILEGED_DATA\
    \ static BaseType_t xSchedulerRunning = pdFALSE;\n+\n+#endif\n+\n /**\n  * @brief\
    \ Each task maintains its own interrupt status in the critical nesting\n  * variable.\n\
    @@ -1651,6 +1660,12 @@ BaseType_t xPortStartScheduler( void ) /* PRIVILEGED_FUNCTION\
    \ */\n     /* Initialize the critical nesting count ready for the first task.\
    \ */\n     ulCriticalNesting = 0;\n \n+    #if ( ( configENABLE_MPU == 1 ) &&\
    \ ( configUSE_MPU_WRAPPERS_V1 == 0 ) && ( configENABLE_ACCESS_CONTROL_LIST ==\
    \ 1 ) )\n+    {\n+        xSchedulerRunning = pdTRUE;\n+    }\n+    #endif\n+\n\
    \     /* Start the first task. */\n     vStartFirstTask();\n \n@@ -1931,3 +1946,98\
    \ @@ BaseType_t xPortIsInsideInterrupt( void )\n \n #endif /* #if ( ( configASSERT_DEFINED\
    \ == 1 ) && ( portHAS_BASEPRI == 1 ) ) */\n /*-----------------------------------------------------------*/\n\
    +\n+#if ( ( configENABLE_MPU == 1 ) && ( configUSE_MPU_WRAPPERS_V1 == 0 ) && (\
    \ configENABLE_ACCESS_CONTROL_LIST == 1 ) )\n+\n+    void vPortGrantAccessToKernelObject(\
    \ TaskHandle_t xInternalTaskHandle,\n+                                       \
    \  int32_t lInternalIndexOfKernelObject ) /* PRIVILEGED_FUNCTION */\n+    {\n\
    +        uint32_t ulAccessControlListEntryIndex, ulAccessControlListEntryBit;\n\
    +        xMPU_SETTINGS * xTaskMpuSettings;\n+\n+        ulAccessControlListEntryIndex\
    \ = ( ( uint32_t ) lInternalIndexOfKernelObject / portACL_ENTRY_SIZE_BITS );\n\
    +        ulAccessControlListEntryBit = ( ( uint32_t ) lInternalIndexOfKernelObject\
    \ % portACL_ENTRY_SIZE_BITS );\n+\n+        xTaskMpuSettings = xTaskGetMPUSettings(\
    \ xInternalTaskHandle );\n+\n+        xTaskMpuSettings->ulAccessControlList[ ulAccessControlListEntryIndex\
    \ ] |= ( 1U << ulAccessControlListEntryBit );\n+    }\n+\n+#endif /* #if ( ( configENABLE_MPU\
    \ == 1 ) && ( configUSE_MPU_WRAPPERS_V1 == 0 ) && ( configENABLE_ACCESS_CONTROL_LIST\
    \ == 1 ) ) */\n+/*-----------------------------------------------------------*/\n\
    +\n+#if ( ( configENABLE_MPU == 1 ) && ( configUSE_MPU_WRAPPERS_V1 == 0 ) && (\
    \ configENABLE_ACCESS_CONTROL_LIST == 1 ) )\n+\n+    void vPortRevokeAccessToKernelObject(\
    \ TaskHandle_t xInternalTaskHandle,\n+                                       \
    \   int32_t lInternalIndexOfKernelObject ) /* PRIVILEGED_FUNCTION */\n+    {\n\
    +        uint32_t ulAccessControlListEntryIndex, ulAccessControlListEntryBit;\n\
    +        xMPU_SETTINGS * xTaskMpuSettings;\n+\n+        ulAccessControlListEntryIndex\
    \ = ( ( uint32_t ) lInternalIndexOfKernelObject / portACL_ENTRY_SIZE_BITS );\n\
    +        ulAccessControlListEntryBit = ( ( uint32_t ) lInternalIndexOfKernelObject\
    \ % portACL_ENTRY_SIZE_BITS );\n+\n+        xTaskMpuSettings = xTaskGetMPUSettings(\
    \ xInternalTaskHandle );\n+\n+        xTaskMpuSettings->ulAccessControlList[ ulAccessControlListEntryIndex\
    \ ] &= ~( 1U << ulAccessControlListEntryBit );\n+    }\n+\n+#endif /* #if ( (\
    \ configENABLE_MPU == 1 ) && ( configUSE_MPU_WRAPPERS_V1 == 0 ) && ( configENABLE_ACCESS_CONTROL_LIST\
    \ == 1 ) ) */\n+/*-----------------------------------------------------------*/\n\
    +\n+#if ( ( configENABLE_MPU == 1 ) && ( configUSE_MPU_WRAPPERS_V1 == 0 ) )\n\
    +\n+    #if ( configENABLE_ACCESS_CONTROL_LIST == 1 )\n+\n+        BaseType_t\
    \ xPortIsAuthorizedToAccessKernelObject( int32_t lInternalIndexOfKernelObject\
    \ ) /* PRIVILEGED_FUNCTION */\n+        {\n+            uint32_t ulAccessControlListEntryIndex,\
    \ ulAccessControlListEntryBit;\n+            BaseType_t xAccessGranted = pdFALSE;\n\
    +            const xMPU_SETTINGS * xTaskMpuSettings;\n+\n+            if( xSchedulerRunning\
    \ == pdFALSE )\n+            {\n+                /* Grant access to all the kernel\
    \ objects before the scheduler\n+                 * is started. It is necessary\
    \ because there is no task running\n+                 * yet and therefore, we\
    \ cannot use the permissions of any\n+                 * task. */\n+         \
    \       xAccessGranted = pdTRUE;\n+            }\n+            else\n+       \
    \     {\n+                xTaskMpuSettings = xTaskGetMPUSettings( NULL ); /* Calling\
    \ task's MPU settings. */\n+\n+                ulAccessControlListEntryIndex =\
    \ ( ( uint32_t ) lInternalIndexOfKernelObject / portACL_ENTRY_SIZE_BITS );\n+\
    \                ulAccessControlListEntryBit = ( ( uint32_t ) lInternalIndexOfKernelObject\
    \ % portACL_ENTRY_SIZE_BITS );\n+\n+                if( ( xTaskMpuSettings->ulTaskFlags\
    \ & portTASK_IS_PRIVILEGED_FLAG ) == portTASK_IS_PRIVILEGED_FLAG )\n+        \
    \        {\n+                    xAccessGranted = pdTRUE;\n+                }\n\
    +                else\n+                {\n+                    if( ( xTaskMpuSettings->ulAccessControlList[\
    \ ulAccessControlListEntryIndex ] & ( 1U << ulAccessControlListEntryBit ) ) !=\
    \ 0 )\n+                    {\n+                        xAccessGranted = pdTRUE;\n\
    +                    }\n+                }\n+            }\n+\n+            return\
    \ xAccessGranted;\n+        }\n+\n+    #else /* #if ( configENABLE_ACCESS_CONTROL_LIST\
    \ == 1 ) */\n+\n+        BaseType_t xPortIsAuthorizedToAccessKernelObject( int32_t\
    \ lInternalIndexOfKernelObject ) /* PRIVILEGED_FUNCTION */\n+        {\n+    \
    \        ( void ) lInternalIndexOfKernelObject;\n+\n+            /* If Access\
    \ Control List feature is not used, all the tasks have\n+             * access\
    \ to all the kernel objects. */\n+            return pdTRUE;\n+        }\n+\n\
    +    #endif /* #if ( configENABLE_ACCESS_CONTROL_LIST == 1 ) */\n+\n+#endif /*\
    \ #if ( ( configENABLE_MPU == 1 ) && ( configUSE_MPU_WRAPPERS_V1 == 0 ) ) */\n\
    +/*-----------------------------------------------------------*/"
  - "--- a/portable/GCC/ARM_CM35P_NTZ/non_secure/port.c\n+++ b/portable/GCC/ARM_CM35P_NTZ/non_secure/port.c\n\
    @@ -472,6 +472,15 @@ portDONT_DISCARD void vPortSVCHandler_C( uint32_t * pulCallerStackAddress\
    \ ) PRIV\n #endif /* configENABLE_MPU == 1 */\n /*-----------------------------------------------------------*/\n\
    \ \n+#if ( ( configENABLE_MPU == 1 ) && ( configUSE_MPU_WRAPPERS_V1 == 0 ) &&\
    \ ( configENABLE_ACCESS_CONTROL_LIST == 1 ) )\n+\n+/**\n+ * @brief This variable\
    \ is set to pdTRUE when the scheduler is started.\n+ */\n+    PRIVILEGED_DATA\
    \ static BaseType_t xSchedulerRunning = pdFALSE;\n+\n+#endif\n+\n /**\n  * @brief\
    \ Each task maintains its own interrupt status in the critical nesting\n  * variable.\n\
    @@ -1651,6 +1660,12 @@ BaseType_t xPortStartScheduler( void ) /* PRIVILEGED_FUNCTION\
    \ */\n     /* Initialize the critical nesting count ready for the first task.\
    \ */\n     ulCriticalNesting = 0;\n \n+    #if ( ( configENABLE_MPU == 1 ) &&\
    \ ( configUSE_MPU_WRAPPERS_V1 == 0 ) && ( configENABLE_ACCESS_CONTROL_LIST ==\
    \ 1 ) )\n+    {\n+        xSchedulerRunning = pdTRUE;\n+    }\n+    #endif\n+\n\
    \     /* Start the first task. */\n     vStartFirstTask();\n \n@@ -1931,3 +1946,98\
    \ @@ BaseType_t xPortIsInsideInterrupt( void )\n \n #endif /* #if ( ( configASSERT_DEFINED\
    \ == 1 ) && ( portHAS_BASEPRI == 1 ) ) */\n /*-----------------------------------------------------------*/\n\
    +\n+#if ( ( configENABLE_MPU == 1 ) && ( configUSE_MPU_WRAPPERS_V1 == 0 ) && (\
    \ configENABLE_ACCESS_CONTROL_LIST == 1 ) )\n+\n+    void vPortGrantAccessToKernelObject(\
    \ TaskHandle_t xInternalTaskHandle,\n+                                       \
    \  int32_t lInternalIndexOfKernelObject ) /* PRIVILEGED_FUNCTION */\n+    {\n\
    +        uint32_t ulAccessControlListEntryIndex, ulAccessControlListEntryBit;\n\
    +        xMPU_SETTINGS * xTaskMpuSettings;\n+\n+        ulAccessControlListEntryIndex\
    \ = ( ( uint32_t ) lInternalIndexOfKernelObject / portACL_ENTRY_SIZE_BITS );\n\
    +        ulAccessControlListEntryBit = ( ( uint32_t ) lInternalIndexOfKernelObject\
    \ % portACL_ENTRY_SIZE_BITS );\n+\n+        xTaskMpuSettings = xTaskGetMPUSettings(\
    \ xInternalTaskHandle );\n+\n+        xTaskMpuSettings->ulAccessControlList[ ulAccessControlListEntryIndex\
    \ ] |= ( 1U << ulAccessControlListEntryBit );\n+    }\n+\n+#endif /* #if ( ( configENABLE_MPU\
    \ == 1 ) && ( configUSE_MPU_WRAPPERS_V1 == 0 ) && ( configENABLE_ACCESS_CONTROL_LIST\
    \ == 1 ) ) */\n+/*-----------------------------------------------------------*/\n\
    +\n+#if ( ( configENABLE_MPU == 1 ) && ( configUSE_MPU_WRAPPERS_V1 == 0 ) && (\
    \ configENABLE_ACCESS_CONTROL_LIST == 1 ) )\n+\n+    void vPortRevokeAccessToKernelObject(\
    \ TaskHandle_t xInternalTaskHandle,\n+                                       \
    \   int32_t lInternalIndexOfKernelObject ) /* PRIVILEGED_FUNCTION */\n+    {\n\
    +        uint32_t ulAccessControlListEntryIndex, ulAccessControlListEntryBit;\n\
    +        xMPU_SETTINGS * xTaskMpuSettings;\n+\n+        ulAccessControlListEntryIndex\
    \ = ( ( uint32_t ) lInternalIndexOfKernelObject / portACL_ENTRY_SIZE_BITS );\n\
    +        ulAccessControlListEntryBit = ( ( uint32_t ) lInternalIndexOfKernelObject\
    \ % portACL_ENTRY_SIZE_BITS );\n+\n+        xTaskMpuSettings = xTaskGetMPUSettings(\
    \ xInternalTaskHandle );\n+\n+        xTaskMpuSettings->ulAccessControlList[ ulAccessControlListEntryIndex\
    \ ] &= ~( 1U << ulAccessControlListEntryBit );\n+    }\n+\n+#endif /* #if ( (\
    \ configENABLE_MPU == 1 ) && ( configUSE_MPU_WRAPPERS_V1 == 0 ) && ( configENABLE_ACCESS_CONTROL_LIST\
    \ == 1 ) ) */\n+/*-----------------------------------------------------------*/\n\
    +\n+#if ( ( configENABLE_MPU == 1 ) && ( configUSE_MPU_WRAPPERS_V1 == 0 ) )\n\
    +\n+    #if ( configENABLE_ACCESS_CONTROL_LIST == 1 )\n+\n+        BaseType_t\
    \ xPortIsAuthorizedToAccessKernelObject( int32_t lInternalIndexOfKernelObject\
    \ ) /* PRIVILEGED_FUNCTION */\n+        {\n+            uint32_t ulAccessControlListEntryIndex,\
    \ ulAccessControlListEntryBit;\n+            BaseType_t xAccessGranted = pdFALSE;\n\
    +            const xMPU_SETTINGS * xTaskMpuSettings;\n+\n+            if( xSchedulerRunning\
    \ == pdFALSE )\n+            {\n+                /* Grant access to all the kernel\
    \ objects before the scheduler\n+                 * is started. It is necessary\
    \ because there is no task running\n+                 * yet and therefore, we\
    \ cannot use the permissions of any\n+                 * task. */\n+         \
    \       xAccessGranted = pdTRUE;\n+            }\n+            else\n+       \
    \     {\n+                xTaskMpuSettings = xTaskGetMPUSettings( NULL ); /* Calling\
    \ task's MPU settings. */\n+\n+                ulAccessControlListEntryIndex =\
    \ ( ( uint32_t ) lInternalIndexOfKernelObject / portACL_ENTRY_SIZE_BITS );\n+\
    \                ulAccessControlListEntryBit = ( ( uint32_t ) lInternalIndexOfKernelObject\
    \ % portACL_ENTRY_SIZE_BITS );\n+\n+                if( ( xTaskMpuSettings->ulTaskFlags\
    \ & portTASK_IS_PRIVILEGED_FLAG ) == portTASK_IS_PRIVILEGED_FLAG )\n+        \
    \        {\n+                    xAccessGranted = pdTRUE;\n+                }\n\
    +                else\n+                {\n+                    if( ( xTaskMpuSettings->ulAccessControlList[\
    \ ulAccessControlListEntryIndex ] & ( 1U << ulAccessControlListEntryBit ) ) !=\
    \ 0 )\n+                    {\n+                        xAccessGranted = pdTRUE;\n\
    +                    }\n+                }\n+            }\n+\n+            return\
    \ xAccessGranted;\n+        }\n+\n+    #else /* #if ( configENABLE_ACCESS_CONTROL_LIST\
    \ == 1 ) */\n+\n+        BaseType_t xPortIsAuthorizedToAccessKernelObject( int32_t\
    \ lInternalIndexOfKernelObject ) /* PRIVILEGED_FUNCTION */\n+        {\n+    \
    \        ( void ) lInternalIndexOfKernelObject;\n+\n+            /* If Access\
    \ Control List feature is not used, all the tasks have\n+             * access\
    \ to all the kernel objects. */\n+            return pdTRUE;\n+        }\n+\n\
    +    #endif /* #if ( configENABLE_ACCESS_CONTROL_LIST == 1 ) */\n+\n+#endif /*\
    \ #if ( ( configENABLE_MPU == 1 ) && ( configUSE_MPU_WRAPPERS_V1 == 0 ) ) */\n\
    +/*-----------------------------------------------------------*/"
  - "--- a/portable/GCC/ARM_CM3_MPU/port.c\n+++ b/portable/GCC/ARM_CM3_MPU/port.c\n\
    @@ -252,6 +252,15 @@ BaseType_t xPortIsTaskPrivileged( void ) PRIVILEGED_FUNCTION;\n\
    \  * switches can only occur when uxCriticalNesting is zero. */\n static UBaseType_t\
    \ uxCriticalNesting = 0xaaaaaaaa;\n \n+#if ( ( configUSE_MPU_WRAPPERS_V1 == 0\
    \ ) && ( configENABLE_ACCESS_CONTROL_LIST == 1 ) )\n+\n+/*\n+ * This variable\
    \ is set to pdTRUE when the scheduler is started.\n+ */\n+    PRIVILEGED_DATA\
    \ static BaseType_t xSchedulerRunning = pdFALSE;\n+\n+#endif\n+\n /*\n  * Used\
    \ by the portASSERT_IF_INTERRUPT_PRIORITY_INVALID() macro to ensure\n  * FreeRTOS\
    \ API functions are not called from interrupts that have been assigned\n@@ -824,6\
    \ +833,12 @@ BaseType_t xPortStartScheduler( void )\n     /* Initialise the critical\
    \ nesting count ready for the first task. */\n     uxCriticalNesting = 0;\n \n\
    +    #if ( ( configUSE_MPU_WRAPPERS_V1 == 0 ) && ( configENABLE_ACCESS_CONTROL_LIST\
    \ == 1 ) )\n+    {\n+        xSchedulerRunning = pdTRUE;\n+    }\n+    #endif\n\
    +\n     /* Start the first task. */\n     __asm volatile\n     (\n@@ -1367,3 +1382,98\
    \ @@ BaseType_t xPortIsAuthorizedToAccessBuffer( const void * pvBuffer,\n \n #endif\
    \ /* configASSERT_DEFINED */\n /*-----------------------------------------------------------*/\n\
    +\n+#if ( ( configUSE_MPU_WRAPPERS_V1 == 0 ) && ( configENABLE_ACCESS_CONTROL_LIST\
    \ == 1 ) )\n+\n+    void vPortGrantAccessToKernelObject( TaskHandle_t xInternalTaskHandle,\n\
    +                                         int32_t lInternalIndexOfKernelObject\
    \ ) /* PRIVILEGED_FUNCTION */\n+    {\n+        uint32_t ulAccessControlListEntryIndex,\
    \ ulAccessControlListEntryBit;\n+        xMPU_SETTINGS * xTaskMpuSettings;\n+\n\
    +        ulAccessControlListEntryIndex = ( ( uint32_t ) lInternalIndexOfKernelObject\
    \ / portACL_ENTRY_SIZE_BITS );\n+        ulAccessControlListEntryBit = ( ( uint32_t\
    \ ) lInternalIndexOfKernelObject % portACL_ENTRY_SIZE_BITS );\n+\n+        xTaskMpuSettings\
    \ = xTaskGetMPUSettings( xInternalTaskHandle );\n+\n+        xTaskMpuSettings->ulAccessControlList[\
    \ ulAccessControlListEntryIndex ] |= ( 1U << ulAccessControlListEntryBit );\n\
    +    }\n+\n+#endif /* #if ( ( configUSE_MPU_WRAPPERS_V1 == 0 ) && ( configENABLE_ACCESS_CONTROL_LIST\
    \ == 1 ) ) */\n+/*-----------------------------------------------------------*/\n\
    +\n+#if ( ( configUSE_MPU_WRAPPERS_V1 == 0 ) && ( configENABLE_ACCESS_CONTROL_LIST\
    \ == 1 ) )\n+\n+    void vPortRevokeAccessToKernelObject( TaskHandle_t xInternalTaskHandle,\n\
    +                                          int32_t lInternalIndexOfKernelObject\
    \ ) /* PRIVILEGED_FUNCTION */\n+    {\n+        uint32_t ulAccessControlListEntryIndex,\
    \ ulAccessControlListEntryBit;\n+        xMPU_SETTINGS * xTaskMpuSettings;\n+\n\
    +        ulAccessControlListEntryIndex = ( ( uint32_t ) lInternalIndexOfKernelObject\
    \ / portACL_ENTRY_SIZE_BITS );\n+        ulAccessControlListEntryBit = ( ( uint32_t\
    \ ) lInternalIndexOfKernelObject % portACL_ENTRY_SIZE_BITS );\n+\n+        xTaskMpuSettings\
    \ = xTaskGetMPUSettings( xInternalTaskHandle );\n+\n+        xTaskMpuSettings->ulAccessControlList[\
    \ ulAccessControlListEntryIndex ] &= ~( 1U << ulAccessControlListEntryBit );\n\
    +    }\n+\n+#endif /* #if ( ( configUSE_MPU_WRAPPERS_V1 == 0 ) && ( configENABLE_ACCESS_CONTROL_LIST\
    \ == 1 ) ) */\n+/*-----------------------------------------------------------*/\n\
    +\n+#if ( configUSE_MPU_WRAPPERS_V1 == 0 )\n+\n+    #if ( configENABLE_ACCESS_CONTROL_LIST\
    \ == 1 )\n+\n+        BaseType_t xPortIsAuthorizedToAccessKernelObject( int32_t\
    \ lInternalIndexOfKernelObject ) /* PRIVILEGED_FUNCTION */\n+        {\n+    \
    \        uint32_t ulAccessControlListEntryIndex, ulAccessControlListEntryBit;\n\
    +            BaseType_t xAccessGranted = pdFALSE;\n+            const xMPU_SETTINGS\
    \ * xTaskMpuSettings;\n+\n+            if( xSchedulerRunning == pdFALSE )\n+ \
    \           {\n+                /* Grant access to all the kernel objects before\
    \ the scheduler\n+                 * is started. It is necessary because there\
    \ is no task running\n+                 * yet and therefore, we cannot use the\
    \ permissions of any\n+                 * task. */\n+                xAccessGranted\
    \ = pdTRUE;\n+            }\n+            else\n+            {\n+            \
    \    xTaskMpuSettings = xTaskGetMPUSettings( NULL ); /* Calling task's MPU settings.\
    \ */\n+\n+                ulAccessControlListEntryIndex = ( ( uint32_t ) lInternalIndexOfKernelObject\
    \ / portACL_ENTRY_SIZE_BITS );\n+                ulAccessControlListEntryBit =\
    \ ( ( uint32_t ) lInternalIndexOfKernelObject % portACL_ENTRY_SIZE_BITS );\n+\n\
    +                if( ( xTaskMpuSettings->ulTaskFlags & portTASK_IS_PRIVILEGED_FLAG\
    \ ) == portTASK_IS_PRIVILEGED_FLAG )\n+                {\n+                  \
    \  xAccessGranted = pdTRUE;\n+                }\n+                else\n+    \
    \            {\n+                    if( ( xTaskMpuSettings->ulAccessControlList[\
    \ ulAccessControlListEntryIndex ] & ( 1U << ulAccessControlListEntryBit ) ) !=\
    \ 0 )\n+                    {\n+                        xAccessGranted = pdTRUE;\n\
    +                    }\n+                }\n+            }\n+\n+            return\
    \ xAccessGranted;\n+        }\n+\n+    #else /* #if ( configENABLE_ACCESS_CONTROL_LIST\
    \ == 1 ) */\n+\n+        BaseType_t xPortIsAuthorizedToAccessKernelObject( int32_t\
    \ lInternalIndexOfKernelObject ) /* PRIVILEGED_FUNCTION */\n+        {\n+    \
    \        ( void ) lInternalIndexOfKernelObject;\n+\n+            /* If Access\
    \ Control List feature is not used, all the tasks have\n+             * access\
    \ to all the kernel objects. */\n+            return pdTRUE;\n+        }\n+\n\
    +    #endif /* #if ( configENABLE_ACCESS_CONTROL_LIST == 1 ) */\n+\n+#endif /*\
    \ #if ( configUSE_MPU_WRAPPERS_V1 == 0 ) */\n+/*-----------------------------------------------------------*/"
  - "--- a/portable/GCC/ARM_CM4_MPU/port.c\n+++ b/portable/GCC/ARM_CM4_MPU/port.c\n\
    @@ -277,6 +277,15 @@ BaseType_t xPortIsTaskPrivileged( void ) PRIVILEGED_FUNCTION;\n\
    \  * switches can only occur when uxCriticalNesting is zero. */\n static UBaseType_t\
    \ uxCriticalNesting = 0xaaaaaaaa;\n \n+#if ( ( configUSE_MPU_WRAPPERS_V1 == 0\
    \ ) && ( configENABLE_ACCESS_CONTROL_LIST == 1 ) )\n+\n+/*\n+ * This variable\
    \ is set to pdTRUE when the scheduler is started.\n+ */\n+    PRIVILEGED_DATA\
    \ static BaseType_t xSchedulerRunning = pdFALSE;\n+\n+#endif\n+\n /*\n  * Used\
    \ by the portASSERT_IF_INTERRUPT_PRIORITY_INVALID() macro to ensure\n  * FreeRTOS\
    \ API functions are not called from interrupts that have been assigned\n@@ -911,6\
    \ +920,12 @@ BaseType_t xPortStartScheduler( void )\n     /* Initialise the critical\
    \ nesting count ready for the first task. */\n     uxCriticalNesting = 0;\n \n\
    +    #if ( ( configUSE_MPU_WRAPPERS_V1 == 0 ) && ( configENABLE_ACCESS_CONTROL_LIST\
    \ == 1 ) )\n+    {\n+        xSchedulerRunning = pdTRUE;\n+    }\n+    #endif\n\
    +\n     /* Ensure the VFP is enabled - it should be anyway. */\n     vPortEnableVFP();\n\
    \ \n@@ -1538,3 +1553,98 @@ BaseType_t xPortIsAuthorizedToAccessBuffer( const void\
    \ * pvBuffer,\n \n #endif /* configASSERT_DEFINED */\n /*-----------------------------------------------------------*/\n\
    +\n+#if ( ( configUSE_MPU_WRAPPERS_V1 == 0 ) && ( configENABLE_ACCESS_CONTROL_LIST\
    \ == 1 ) )\n+\n+    void vPortGrantAccessToKernelObject( TaskHandle_t xInternalTaskHandle,\n\
    +                                         int32_t lInternalIndexOfKernelObject\
    \ ) /* PRIVILEGED_FUNCTION */\n+    {\n+        uint32_t ulAccessControlListEntryIndex,\
    \ ulAccessControlListEntryBit;\n+        xMPU_SETTINGS * xTaskMpuSettings;\n+\n\
    +        ulAccessControlListEntryIndex = ( ( uint32_t ) lInternalIndexOfKernelObject\
    \ / portACL_ENTRY_SIZE_BITS );\n+        ulAccessControlListEntryBit = ( ( uint32_t\
    \ ) lInternalIndexOfKernelObject % portACL_ENTRY_SIZE_BITS );\n+\n+        xTaskMpuSettings\
    \ = xTaskGetMPUSettings( xInternalTaskHandle );\n+\n+        xTaskMpuSettings->ulAccessControlList[\
    \ ulAccessControlListEntryIndex ] |= ( 1U << ulAccessControlListEntryBit );\n\
    +    }\n+\n+#endif /* #if ( ( configUSE_MPU_WRAPPERS_V1 == 0 ) && ( configENABLE_ACCESS_CONTROL_LIST\
    \ == 1 ) ) */\n+/*-----------------------------------------------------------*/\n\
    +\n+#if ( ( configUSE_MPU_WRAPPERS_V1 == 0 ) && ( configENABLE_ACCESS_CONTROL_LIST\
    \ == 1 ) )\n+\n+    void vPortRevokeAccessToKernelObject( TaskHandle_t xInternalTaskHandle,\n\
    +                                          int32_t lInternalIndexOfKernelObject\
    \ ) /* PRIVILEGED_FUNCTION */\n+    {\n+        uint32_t ulAccessControlListEntryIndex,\
    \ ulAccessControlListEntryBit;\n+        xMPU_SETTINGS * xTaskMpuSettings;\n+\n\
    +        ulAccessControlListEntryIndex = ( ( uint32_t ) lInternalIndexOfKernelObject\
    \ / portACL_ENTRY_SIZE_BITS );\n+        ulAccessControlListEntryBit = ( ( uint32_t\
    \ ) lInternalIndexOfKernelObject % portACL_ENTRY_SIZE_BITS );\n+\n+        xTaskMpuSettings\
    \ = xTaskGetMPUSettings( xInternalTaskHandle );\n+\n+        xTaskMpuSettings->ulAccessControlList[\
    \ ulAccessControlListEntryIndex ] &= ~( 1U << ulAccessControlListEntryBit );\n\
    +    }\n+\n+#endif /* #if ( ( configUSE_MPU_WRAPPERS_V1 == 0 ) && ( configENABLE_ACCESS_CONTROL_LIST\
    \ == 1 ) ) */\n+/*-----------------------------------------------------------*/\n\
    +\n+#if ( configUSE_MPU_WRAPPERS_V1 == 0 )\n+\n+    #if ( configENABLE_ACCESS_CONTROL_LIST\
    \ == 1 )\n+\n+        BaseType_t xPortIsAuthorizedToAccessKernelObject( int32_t\
    \ lInternalIndexOfKernelObject ) /* PRIVILEGED_FUNCTION */\n+        {\n+    \
    \        uint32_t ulAccessControlListEntryIndex, ulAccessControlListEntryBit;\n\
    +            BaseType_t xAccessGranted = pdFALSE;\n+            const xMPU_SETTINGS\
    \ * xTaskMpuSettings;\n+\n+            if( xSchedulerRunning == pdFALSE )\n+ \
    \           {\n+                /* Grant access to all the kernel objects before\
    \ the scheduler\n+                 * is started. It is necessary because there\
    \ is no task running\n+                 * yet and therefore, we cannot use the\
    \ permissions of any\n+                 * task. */\n+                xAccessGranted\
    \ = pdTRUE;\n+            }\n+            else\n+            {\n+            \
    \    xTaskMpuSettings = xTaskGetMPUSettings( NULL ); /* Calling task's MPU settings.\
    \ */\n+\n+                ulAccessControlListEntryIndex = ( ( uint32_t ) lInternalIndexOfKernelObject\
    \ / portACL_ENTRY_SIZE_BITS );\n+                ulAccessControlListEntryBit =\
    \ ( ( uint32_t ) lInternalIndexOfKernelObject % portACL_ENTRY_SIZE_BITS );\n+\n\
    +                if( ( xTaskMpuSettings->ulTaskFlags & portTASK_IS_PRIVILEGED_FLAG\
    \ ) == portTASK_IS_PRIVILEGED_FLAG )\n+                {\n+                  \
    \  xAccessGranted = pdTRUE;\n+                }\n+                else\n+    \
    \            {\n+                    if( ( xTaskMpuSettings->ulAccessControlList[\
    \ ulAccessControlListEntryIndex ] & ( 1U << ulAccessControlListEntryBit ) ) !=\
    \ 0 )\n+                    {\n+                        xAccessGranted = pdTRUE;\n\
    +                    }\n+                }\n+            }\n+\n+            return\
    \ xAccessGranted;\n+        }\n+\n+    #else /* #if ( configENABLE_ACCESS_CONTROL_LIST\
    \ == 1 ) */\n+\n+        BaseType_t xPortIsAuthorizedToAccessKernelObject( int32_t\
    \ lInternalIndexOfKernelObject ) /* PRIVILEGED_FUNCTION */\n+        {\n+    \
    \        ( void ) lInternalIndexOfKernelObject;\n+\n+            /* If Access\
    \ Control List feature is not used, all the tasks have\n+             * access\
    \ to all the kernel objects. */\n+            return pdTRUE;\n+        }\n+\n\
    +    #endif /* #if ( configENABLE_ACCESS_CONTROL_LIST == 1 ) */\n+\n+#endif /*\
    \ #if ( configUSE_MPU_WRAPPERS_V1 == 0 ) */\n+/*-----------------------------------------------------------*/"
  - "--- a/portable/GCC/ARM_CM55/non_secure/port.c\n+++ b/portable/GCC/ARM_CM55/non_secure/port.c\n\
    @@ -472,6 +472,15 @@ portDONT_DISCARD void vPortSVCHandler_C( uint32_t * pulCallerStackAddress\
    \ ) PRIV\n #endif /* configENABLE_MPU == 1 */\n /*-----------------------------------------------------------*/\n\
    \ \n+#if ( ( configENABLE_MPU == 1 ) && ( configUSE_MPU_WRAPPERS_V1 == 0 ) &&\
    \ ( configENABLE_ACCESS_CONTROL_LIST == 1 ) )\n+\n+/**\n+ * @brief This variable\
    \ is set to pdTRUE when the scheduler is started.\n+ */\n+    PRIVILEGED_DATA\
    \ static BaseType_t xSchedulerRunning = pdFALSE;\n+\n+#endif\n+\n /**\n  * @brief\
    \ Each task maintains its own interrupt status in the critical nesting\n  * variable.\n\
    @@ -1651,6 +1660,12 @@ BaseType_t xPortStartScheduler( void ) /* PRIVILEGED_FUNCTION\
    \ */\n     /* Initialize the critical nesting count ready for the first task.\
    \ */\n     ulCriticalNesting = 0;\n \n+    #if ( ( configENABLE_MPU == 1 ) &&\
    \ ( configUSE_MPU_WRAPPERS_V1 == 0 ) && ( configENABLE_ACCESS_CONTROL_LIST ==\
    \ 1 ) )\n+    {\n+        xSchedulerRunning = pdTRUE;\n+    }\n+    #endif\n+\n\
    \     /* Start the first task. */\n     vStartFirstTask();\n \n@@ -1931,3 +1946,98\
    \ @@ BaseType_t xPortIsInsideInterrupt( void )\n \n #endif /* #if ( ( configASSERT_DEFINED\
    \ == 1 ) && ( portHAS_BASEPRI == 1 ) ) */\n /*-----------------------------------------------------------*/\n\
    +\n+#if ( ( configENABLE_MPU == 1 ) && ( configUSE_MPU_WRAPPERS_V1 == 0 ) && (\
    \ configENABLE_ACCESS_CONTROL_LIST == 1 ) )\n+\n+    void vPortGrantAccessToKernelObject(\
    \ TaskHandle_t xInternalTaskHandle,\n+                                       \
    \  int32_t lInternalIndexOfKernelObject ) /* PRIVILEGED_FUNCTION */\n+    {\n\
    +        uint32_t ulAccessControlListEntryIndex, ulAccessControlListEntryBit;\n\
    +        xMPU_SETTINGS * xTaskMpuSettings;\n+\n+        ulAccessControlListEntryIndex\
    \ = ( ( uint32_t ) lInternalIndexOfKernelObject / portACL_ENTRY_SIZE_BITS );\n\
    +        ulAccessControlListEntryBit = ( ( uint32_t ) lInternalIndexOfKernelObject\
    \ % portACL_ENTRY_SIZE_BITS );\n+\n+        xTaskMpuSettings = xTaskGetMPUSettings(\
    \ xInternalTaskHandle );\n+\n+        xTaskMpuSettings->ulAccessControlList[ ulAccessControlListEntryIndex\
    \ ] |= ( 1U << ulAccessControlListEntryBit );\n+    }\n+\n+#endif /* #if ( ( configENABLE_MPU\
    \ == 1 ) && ( configUSE_MPU_WRAPPERS_V1 == 0 ) && ( configENABLE_ACCESS_CONTROL_LIST\
    \ == 1 ) ) */\n+/*-----------------------------------------------------------*/\n\
    +\n+#if ( ( configENABLE_MPU == 1 ) && ( configUSE_MPU_WRAPPERS_V1 == 0 ) && (\
    \ configENABLE_ACCESS_CONTROL_LIST == 1 ) )\n+\n+    void vPortRevokeAccessToKernelObject(\
    \ TaskHandle_t xInternalTaskHandle,\n+                                       \
    \   int32_t lInternalIndexOfKernelObject ) /* PRIVILEGED_FUNCTION */\n+    {\n\
    +        uint32_t ulAccessControlListEntryIndex, ulAccessControlListEntryBit;\n\
    +        xMPU_SETTINGS * xTaskMpuSettings;\n+\n+        ulAccessControlListEntryIndex\
    \ = ( ( uint32_t ) lInternalIndexOfKernelObject / portACL_ENTRY_SIZE_BITS );\n\
    +        ulAccessControlListEntryBit = ( ( uint32_t ) lInternalIndexOfKernelObject\
    \ % portACL_ENTRY_SIZE_BITS );\n+\n+        xTaskMpuSettings = xTaskGetMPUSettings(\
    \ xInternalTaskHandle );\n+\n+        xTaskMpuSettings->ulAccessControlList[ ulAccessControlListEntryIndex\
    \ ] &= ~( 1U << ulAccessControlListEntryBit );\n+    }\n+\n+#endif /* #if ( (\
    \ configENABLE_MPU == 1 ) && ( configUSE_MPU_WRAPPERS_V1 == 0 ) && ( configENABLE_ACCESS_CONTROL_LIST\
    \ == 1 ) ) */\n+/*-----------------------------------------------------------*/\n\
    +\n+#if ( ( configENABLE_MPU == 1 ) && ( configUSE_MPU_WRAPPERS_V1 == 0 ) )\n\
    +\n+    #if ( configENABLE_ACCESS_CONTROL_LIST == 1 )\n+\n+        BaseType_t\
    \ xPortIsAuthorizedToAccessKernelObject( int32_t lInternalIndexOfKernelObject\
    \ ) /* PRIVILEGED_FUNCTION */\n+        {\n+            uint32_t ulAccessControlListEntryIndex,\
    \ ulAccessControlListEntryBit;\n+            BaseType_t xAccessGranted = pdFALSE;\n\
    +            const xMPU_SETTINGS * xTaskMpuSettings;\n+\n+            if( xSchedulerRunning\
    \ == pdFALSE )\n+            {\n+                /* Grant access to all the kernel\
    \ objects before the scheduler\n+                 * is started. It is necessary\
    \ because there is no task running\n+                 * yet and therefore, we\
    \ cannot use the permissions of any\n+                 * task. */\n+         \
    \       xAccessGranted = pdTRUE;\n+            }\n+            else\n+       \
    \     {\n+                xTaskMpuSettings = xTaskGetMPUSettings( NULL ); /* Calling\
    \ task's MPU settings. */\n+\n+                ulAccessControlListEntryIndex =\
    \ ( ( uint32_t ) lInternalIndexOfKernelObject / portACL_ENTRY_SIZE_BITS );\n+\
    \                ulAccessControlListEntryBit = ( ( uint32_t ) lInternalIndexOfKernelObject\
    \ % portACL_ENTRY_SIZE_BITS );\n+\n+                if( ( xTaskMpuSettings->ulTaskFlags\
    \ & portTASK_IS_PRIVILEGED_FLAG ) == portTASK_IS_PRIVILEGED_FLAG )\n+        \
    \        {\n+                    xAccessGranted = pdTRUE;\n+                }\n\
    +                else\n+                {\n+                    if( ( xTaskMpuSettings->ulAccessControlList[\
    \ ulAccessControlListEntryIndex ] & ( 1U << ulAccessControlListEntryBit ) ) !=\
    \ 0 )\n+                    {\n+                        xAccessGranted = pdTRUE;\n\
    +                    }\n+                }\n+            }\n+\n+            return\
    \ xAccessGranted;\n+        }\n+\n+    #else /* #if ( configENABLE_ACCESS_CONTROL_LIST\
    \ == 1 ) */\n+\n+        BaseType_t xPortIsAuthorizedToAccessKernelObject( int32_t\
    \ lInternalIndexOfKernelObject ) /* PRIVILEGED_FUNCTION */\n+        {\n+    \
    \        ( void ) lInternalIndexOfKernelObject;\n+\n+            /* If Access\
    \ Control List feature is not used, all the tasks have\n+             * access\
    \ to all the kernel objects. */\n+            return pdTRUE;\n+        }\n+\n\
    +    #endif /* #if ( configENABLE_ACCESS_CONTROL_LIST == 1 ) */\n+\n+#endif /*\
    \ #if ( ( configENABLE_MPU == 1 ) && ( configUSE_MPU_WRAPPERS_V1 == 0 ) ) */\n\
    +/*-----------------------------------------------------------*/"
  - "--- a/portable/GCC/ARM_CM55_NTZ/non_secure/port.c\n+++ b/portable/GCC/ARM_CM55_NTZ/non_secure/port.c\n\
    @@ -472,6 +472,15 @@ portDONT_DISCARD void vPortSVCHandler_C( uint32_t * pulCallerStackAddress\
    \ ) PRIV\n #endif /* configENABLE_MPU == 1 */\n /*-----------------------------------------------------------*/\n\
    \ \n+#if ( ( configENABLE_MPU == 1 ) && ( configUSE_MPU_WRAPPERS_V1 == 0 ) &&\
    \ ( configENABLE_ACCESS_CONTROL_LIST == 1 ) )\n+\n+/**\n+ * @brief This variable\
    \ is set to pdTRUE when the scheduler is started.\n+ */\n+    PRIVILEGED_DATA\
    \ static BaseType_t xSchedulerRunning = pdFALSE;\n+\n+#endif\n+\n /**\n  * @brief\
    \ Each task maintains its own interrupt status in the critical nesting\n  * variable.\n\
    @@ -1651,6 +1660,12 @@ BaseType_t xPortStartScheduler( void ) /* PRIVILEGED_FUNCTION\
    \ */\n     /* Initialize the critical nesting count ready for the first task.\
    \ */\n     ulCriticalNesting = 0;\n \n+    #if ( ( configENABLE_MPU == 1 ) &&\
    \ ( configUSE_MPU_WRAPPERS_V1 == 0 ) && ( configENABLE_ACCESS_CONTROL_LIST ==\
    \ 1 ) )\n+    {\n+        xSchedulerRunning = pdTRUE;\n+    }\n+    #endif\n+\n\
    \     /* Start the first task. */\n     vStartFirstTask();\n \n@@ -1931,3 +1946,98\
    \ @@ BaseType_t xPortIsInsideInterrupt( void )\n \n #endif /* #if ( ( configASSERT_DEFINED\
    \ == 1 ) && ( portHAS_BASEPRI == 1 ) ) */\n /*-----------------------------------------------------------*/\n\
    +\n+#if ( ( configENABLE_MPU == 1 ) && ( configUSE_MPU_WRAPPERS_V1 == 0 ) && (\
    \ configENABLE_ACCESS_CONTROL_LIST == 1 ) )\n+\n+    void vPortGrantAccessToKernelObject(\
    \ TaskHandle_t xInternalTaskHandle,\n+                                       \
    \  int32_t lInternalIndexOfKernelObject ) /* PRIVILEGED_FUNCTION */\n+    {\n\
    +        uint32_t ulAccessControlListEntryIndex, ulAccessControlListEntryBit;\n\
    +        xMPU_SETTINGS * xTaskMpuSettings;\n+\n+        ulAccessControlListEntryIndex\
    \ = ( ( uint32_t ) lInternalIndexOfKernelObject / portACL_ENTRY_SIZE_BITS );\n\
    +        ulAccessControlListEntryBit = ( ( uint32_t ) lInternalIndexOfKernelObject\
    \ % portACL_ENTRY_SIZE_BITS );\n+\n+        xTaskMpuSettings = xTaskGetMPUSettings(\
    \ xInternalTaskHandle );\n+\n+        xTaskMpuSettings->ulAccessControlList[ ulAccessControlListEntryIndex\
    \ ] |= ( 1U << ulAccessControlListEntryBit );\n+    }\n+\n+#endif /* #if ( ( configENABLE_MPU\
    \ == 1 ) && ( configUSE_MPU_WRAPPERS_V1 == 0 ) && ( configENABLE_ACCESS_CONTROL_LIST\
    \ == 1 ) ) */\n+/*-----------------------------------------------------------*/\n\
    +\n+#if ( ( configENABLE_MPU == 1 ) && ( configUSE_MPU_WRAPPERS_V1 == 0 ) && (\
    \ configENABLE_ACCESS_CONTROL_LIST == 1 ) )\n+\n+    void vPortRevokeAccessToKernelObject(\
    \ TaskHandle_t xInternalTaskHandle,\n+                                       \
    \   int32_t lInternalIndexOfKernelObject ) /* PRIVILEGED_FUNCTION */\n+    {\n\
    +        uint32_t ulAccessControlListEntryIndex, ulAccessControlListEntryBit;\n\
    +        xMPU_SETTINGS * xTaskMpuSettings;\n+\n+        ulAccessControlListEntryIndex\
    \ = ( ( uint32_t ) lInternalIndexOfKernelObject / portACL_ENTRY_SIZE_BITS );\n\
    +        ulAccessControlListEntryBit = ( ( uint32_t ) lInternalIndexOfKernelObject\
    \ % portACL_ENTRY_SIZE_BITS );\n+\n+        xTaskMpuSettings = xTaskGetMPUSettings(\
    \ xInternalTaskHandle );\n+\n+        xTaskMpuSettings->ulAccessControlList[ ulAccessControlListEntryIndex\
    \ ] &= ~( 1U << ulAccessControlListEntryBit );\n+    }\n+\n+#endif /* #if ( (\
    \ configENABLE_MPU == 1 ) && ( configUSE_MPU_WRAPPERS_V1 == 0 ) && ( configENABLE_ACCESS_CONTROL_LIST\
    \ == 1 ) ) */\n+/*-----------------------------------------------------------*/\n\
    +\n+#if ( ( configENABLE_MPU == 1 ) && ( configUSE_MPU_WRAPPERS_V1 == 0 ) )\n\
    +\n+    #if ( configENABLE_ACCESS_CONTROL_LIST == 1 )\n+\n+        BaseType_t\
    \ xPortIsAuthorizedToAccessKernelObject( int32_t lInternalIndexOfKernelObject\
    \ ) /* PRIVILEGED_FUNCTION */\n+        {\n+            uint32_t ulAccessControlListEntryIndex,\
    \ ulAccessControlListEntryBit;\n+            BaseType_t xAccessGranted = pdFALSE;\n\
    +            const xMPU_SETTINGS * xTaskMpuSettings;\n+\n+            if( xSchedulerRunning\
    \ == pdFALSE )\n+            {\n+                /* Grant access to all the kernel\
    \ objects before the scheduler\n+                 * is started. It is necessary\
    \ because there is no task running\n+                 * yet and therefore, we\
    \ cannot use the permissions of any\n+                 * task. */\n+         \
    \       xAccessGranted = pdTRUE;\n+            }\n+            else\n+       \
    \     {\n+                xTaskMpuSettings = xTaskGetMPUSettings( NULL ); /* Calling\
    \ task's MPU settings. */\n+\n+                ulAccessControlListEntryIndex =\
    \ ( ( uint32_t ) lInternalIndexOfKernelObject / portACL_ENTRY_SIZE_BITS );\n+\
    \                ulAccessControlListEntryBit = ( ( uint32_t ) lInternalIndexOfKernelObject\
    \ % portACL_ENTRY_SIZE_BITS );\n+\n+                if( ( xTaskMpuSettings->ulTaskFlags\
    \ & portTASK_IS_PRIVILEGED_FLAG ) == portTASK_IS_PRIVILEGED_FLAG )\n+        \
    \        {\n+                    xAccessGranted = pdTRUE;\n+                }\n\
    +                else\n+                {\n+                    if( ( xTaskMpuSettings->ulAccessControlList[\
    \ ulAccessControlListEntryIndex ] & ( 1U << ulAccessControlListEntryBit ) ) !=\
    \ 0 )\n+                    {\n+                        xAccessGranted = pdTRUE;\n\
    +                    }\n+                }\n+            }\n+\n+            return\
    \ xAccessGranted;\n+        }\n+\n+    #else /* #if ( configENABLE_ACCESS_CONTROL_LIST\
    \ == 1 ) */\n+\n+        BaseType_t xPortIsAuthorizedToAccessKernelObject( int32_t\
    \ lInternalIndexOfKernelObject ) /* PRIVILEGED_FUNCTION */\n+        {\n+    \
    \        ( void ) lInternalIndexOfKernelObject;\n+\n+            /* If Access\
    \ Control List feature is not used, all the tasks have\n+             * access\
    \ to all the kernel objects. */\n+            return pdTRUE;\n+        }\n+\n\
    +    #endif /* #if ( configENABLE_ACCESS_CONTROL_LIST == 1 ) */\n+\n+#endif /*\
    \ #if ( ( configENABLE_MPU == 1 ) && ( configUSE_MPU_WRAPPERS_V1 == 0 ) ) */\n\
    +/*-----------------------------------------------------------*/"
  - "--- a/portable/GCC/ARM_CM85/non_secure/port.c\n+++ b/portable/GCC/ARM_CM85/non_secure/port.c\n\
    @@ -472,6 +472,15 @@ portDONT_DISCARD void vPortSVCHandler_C( uint32_t * pulCallerStackAddress\
    \ ) PRIV\n #endif /* configENABLE_MPU == 1 */\n /*-----------------------------------------------------------*/\n\
    \ \n+#if ( ( configENABLE_MPU == 1 ) && ( configUSE_MPU_WRAPPERS_V1 == 0 ) &&\
    \ ( configENABLE_ACCESS_CONTROL_LIST == 1 ) )\n+\n+/**\n+ * @brief This variable\
    \ is set to pdTRUE when the scheduler is started.\n+ */\n+    PRIVILEGED_DATA\
    \ static BaseType_t xSchedulerRunning = pdFALSE;\n+\n+#endif\n+\n /**\n  * @brief\
    \ Each task maintains its own interrupt status in the critical nesting\n  * variable.\n\
    @@ -1651,6 +1660,12 @@ BaseType_t xPortStartScheduler( void ) /* PRIVILEGED_FUNCTION\
    \ */\n     /* Initialize the critical nesting count ready for the first task.\
    \ */\n     ulCriticalNesting = 0;\n \n+    #if ( ( configENABLE_MPU == 1 ) &&\
    \ ( configUSE_MPU_WRAPPERS_V1 == 0 ) && ( configENABLE_ACCESS_CONTROL_LIST ==\
    \ 1 ) )\n+    {\n+        xSchedulerRunning = pdTRUE;\n+    }\n+    #endif\n+\n\
    \     /* Start the first task. */\n     vStartFirstTask();\n \n@@ -1931,3 +1946,98\
    \ @@ BaseType_t xPortIsInsideInterrupt( void )\n \n #endif /* #if ( ( configASSERT_DEFINED\
    \ == 1 ) && ( portHAS_BASEPRI == 1 ) ) */\n /*-----------------------------------------------------------*/\n\
    +\n+#if ( ( configENABLE_MPU == 1 ) && ( configUSE_MPU_WRAPPERS_V1 == 0 ) && (\
    \ configENABLE_ACCESS_CONTROL_LIST == 1 ) )\n+\n+    void vPortGrantAccessToKernelObject(\
    \ TaskHandle_t xInternalTaskHandle,\n+                                       \
    \  int32_t lInternalIndexOfKernelObject ) /* PRIVILEGED_FUNCTION */\n+    {\n\
    +        uint32_t ulAccessControlListEntryIndex, ulAccessControlListEntryBit;\n\
    +        xMPU_SETTINGS * xTaskMpuSettings;\n+\n+        ulAccessControlListEntryIndex\
    \ = ( ( uint32_t ) lInternalIndexOfKernelObject / portACL_ENTRY_SIZE_BITS );\n\
    +        ulAccessControlListEntryBit = ( ( uint32_t ) lInternalIndexOfKernelObject\
    \ % portACL_ENTRY_SIZE_BITS );\n+\n+        xTaskMpuSettings = xTaskGetMPUSettings(\
    \ xInternalTaskHandle );\n+\n+        xTaskMpuSettings->ulAccessControlList[ ulAccessControlListEntryIndex\
    \ ] |= ( 1U << ulAccessControlListEntryBit );\n+    }\n+\n+#endif /* #if ( ( configENABLE_MPU\
    \ == 1 ) && ( configUSE_MPU_WRAPPERS_V1 == 0 ) && ( configENABLE_ACCESS_CONTROL_LIST\
    \ == 1 ) ) */\n+/*-----------------------------------------------------------*/\n\
    +\n+#if ( ( configENABLE_MPU == 1 ) && ( configUSE_MPU_WRAPPERS_V1 == 0 ) && (\
    \ configENABLE_ACCESS_CONTROL_LIST == 1 ) )\n+\n+    void vPortRevokeAccessToKernelObject(\
    \ TaskHandle_t xInternalTaskHandle,\n+                                       \
    \   int32_t lInternalIndexOfKernelObject ) /* PRIVILEGED_FUNCTION */\n+    {\n\
    +        uint32_t ulAccessControlListEntryIndex, ulAccessControlListEntryBit;\n\
    +        xMPU_SETTINGS * xTaskMpuSettings;\n+\n+        ulAccessControlListEntryIndex\
    \ = ( ( uint32_t ) lInternalIndexOfKernelObject / portACL_ENTRY_SIZE_BITS );\n\
    +        ulAccessControlListEntryBit = ( ( uint32_t ) lInternalIndexOfKernelObject\
    \ % portACL_ENTRY_SIZE_BITS );\n+\n+        xTaskMpuSettings = xTaskGetMPUSettings(\
    \ xInternalTaskHandle );\n+\n+        xTaskMpuSettings->ulAccessControlList[ ulAccessControlListEntryIndex\
    \ ] &= ~( 1U << ulAccessControlListEntryBit );\n+    }\n+\n+#endif /* #if ( (\
    \ configENABLE_MPU == 1 ) && ( configUSE_MPU_WRAPPERS_V1 == 0 ) && ( configENABLE_ACCESS_CONTROL_LIST\
    \ == 1 ) ) */\n+/*-----------------------------------------------------------*/\n\
    +\n+#if ( ( configENABLE_MPU == 1 ) && ( configUSE_MPU_WRAPPERS_V1 == 0 ) )\n\
    +\n+    #if ( configENABLE_ACCESS_CONTROL_LIST == 1 )\n+\n+        BaseType_t\
    \ xPortIsAuthorizedToAccessKernelObject( int32_t lInternalIndexOfKernelObject\
    \ ) /* PRIVILEGED_FUNCTION */\n+        {\n+            uint32_t ulAccessControlListEntryIndex,\
    \ ulAccessControlListEntryBit;\n+            BaseType_t xAccessGranted = pdFALSE;\n\
    +            const xMPU_SETTINGS * xTaskMpuSettings;\n+\n+            if( xSchedulerRunning\
    \ == pdFALSE )\n+            {\n+                /* Grant access to all the kernel\
    \ objects before the scheduler\n+                 * is started. It is necessary\
    \ because there is no task running\n+                 * yet and therefore, we\
    \ cannot use the permissions of any\n+                 * task. */\n+         \
    \       xAccessGranted = pdTRUE;\n+            }\n+            else\n+       \
    \     {\n+                xTaskMpuSettings = xTaskGetMPUSettings( NULL ); /* Calling\
    \ task's MPU settings. */\n+\n+                ulAccessControlListEntryIndex =\
    \ ( ( uint32_t ) lInternalIndexOfKernelObject / portACL_ENTRY_SIZE_BITS );\n+\
    \                ulAccessControlListEntryBit = ( ( uint32_t ) lInternalIndexOfKernelObject\
    \ % portACL_ENTRY_SIZE_BITS );\n+\n+                if( ( xTaskMpuSettings->ulTaskFlags\
    \ & portTASK_IS_PRIVILEGED_FLAG ) == portTASK_IS_PRIVILEGED_FLAG )\n+        \
    \        {\n+                    xAccessGranted = pdTRUE;\n+                }\n\
    +                else\n+                {\n+                    if( ( xTaskMpuSettings->ulAccessControlList[\
    \ ulAccessControlListEntryIndex ] & ( 1U << ulAccessControlListEntryBit ) ) !=\
    \ 0 )\n+                    {\n+                        xAccessGranted = pdTRUE;\n\
    +                    }\n+                }\n+            }\n+\n+            return\
    \ xAccessGranted;\n+        }\n+\n+    #else /* #if ( configENABLE_ACCESS_CONTROL_LIST\
    \ == 1 ) */\n+\n+        BaseType_t xPortIsAuthorizedToAccessKernelObject( int32_t\
    \ lInternalIndexOfKernelObject ) /* PRIVILEGED_FUNCTION */\n+        {\n+    \
    \        ( void ) lInternalIndexOfKernelObject;\n+\n+            /* If Access\
    \ Control List feature is not used, all the tasks have\n+             * access\
    \ to all the kernel objects. */\n+            return pdTRUE;\n+        }\n+\n\
    +    #endif /* #if ( configENABLE_ACCESS_CONTROL_LIST == 1 ) */\n+\n+#endif /*\
    \ #if ( ( configENABLE_MPU == 1 ) && ( configUSE_MPU_WRAPPERS_V1 == 0 ) ) */\n\
    +/*-----------------------------------------------------------*/"
  - "--- a/portable/GCC/ARM_CM85_NTZ/non_secure/port.c\n+++ b/portable/GCC/ARM_CM85_NTZ/non_secure/port.c\n\
    @@ -472,6 +472,15 @@ portDONT_DISCARD void vPortSVCHandler_C( uint32_t * pulCallerStackAddress\
    \ ) PRIV\n #endif /* configENABLE_MPU == 1 */\n /*-----------------------------------------------------------*/\n\
    \ \n+#if ( ( configENABLE_MPU == 1 ) && ( configUSE_MPU_WRAPPERS_V1 == 0 ) &&\
    \ ( configENABLE_ACCESS_CONTROL_LIST == 1 ) )\n+\n+/**\n+ * @brief This variable\
    \ is set to pdTRUE when the scheduler is started.\n+ */\n+    PRIVILEGED_DATA\
    \ static BaseType_t xSchedulerRunning = pdFALSE;\n+\n+#endif\n+\n /**\n  * @brief\
    \ Each task maintains its own interrupt status in the critical nesting\n  * variable.\n\
    @@ -1651,6 +1660,12 @@ BaseType_t xPortStartScheduler( void ) /* PRIVILEGED_FUNCTION\
    \ */\n     /* Initialize the critical nesting count ready for the first task.\
    \ */\n     ulCriticalNesting = 0;\n \n+    #if ( ( configENABLE_MPU == 1 ) &&\
    \ ( configUSE_MPU_WRAPPERS_V1 == 0 ) && ( configENABLE_ACCESS_CONTROL_LIST ==\
    \ 1 ) )\n+    {\n+        xSchedulerRunning = pdTRUE;\n+    }\n+    #endif\n+\n\
    \     /* Start the first task. */\n     vStartFirstTask();\n \n@@ -1931,3 +1946,98\
    \ @@ BaseType_t xPortIsInsideInterrupt( void )\n \n #endif /* #if ( ( configASSERT_DEFINED\
    \ == 1 ) && ( portHAS_BASEPRI == 1 ) ) */\n /*-----------------------------------------------------------*/\n\
    +\n+#if ( ( configENABLE_MPU == 1 ) && ( configUSE_MPU_WRAPPERS_V1 == 0 ) && (\
    \ configENABLE_ACCESS_CONTROL_LIST == 1 ) )\n+\n+    void vPortGrantAccessToKernelObject(\
    \ TaskHandle_t xInternalTaskHandle,\n+                                       \
    \  int32_t lInternalIndexOfKernelObject ) /* PRIVILEGED_FUNCTION */\n+    {\n\
    +        uint32_t ulAccessControlListEntryIndex, ulAccessControlListEntryBit;\n\
    +        xMPU_SETTINGS * xTaskMpuSettings;\n+\n+        ulAccessControlListEntryIndex\
    \ = ( ( uint32_t ) lInternalIndexOfKernelObject / portACL_ENTRY_SIZE_BITS );\n\
    +        ulAccessControlListEntryBit = ( ( uint32_t ) lInternalIndexOfKernelObject\
    \ % portACL_ENTRY_SIZE_BITS );\n+\n+        xTaskMpuSettings = xTaskGetMPUSettings(\
    \ xInternalTaskHandle );\n+\n+        xTaskMpuSettings->ulAccessControlList[ ulAccessControlListEntryIndex\
    \ ] |= ( 1U << ulAccessControlListEntryBit );\n+    }\n+\n+#endif /* #if ( ( configENABLE_MPU\
    \ == 1 ) && ( configUSE_MPU_WRAPPERS_V1 == 0 ) && ( configENABLE_ACCESS_CONTROL_LIST\
    \ == 1 ) ) */\n+/*-----------------------------------------------------------*/\n\
    +\n+#if ( ( configENABLE_MPU == 1 ) && ( configUSE_MPU_WRAPPERS_V1 == 0 ) && (\
    \ configENABLE_ACCESS_CONTROL_LIST == 1 ) )\n+\n+    void vPortRevokeAccessToKernelObject(\
    \ TaskHandle_t xInternalTaskHandle,\n+                                       \
    \   int32_t lInternalIndexOfKernelObject ) /* PRIVILEGED_FUNCTION */\n+    {\n\
    +        uint32_t ulAccessControlListEntryIndex, ulAccessControlListEntryBit;\n\
    +        xMPU_SETTINGS * xTaskMpuSettings;\n+\n+        ulAccessControlListEntryIndex\
    \ = ( ( uint32_t ) lInternalIndexOfKernelObject / portACL_ENTRY_SIZE_BITS );\n\
    +        ulAccessControlListEntryBit = ( ( uint32_t ) lInternalIndexOfKernelObject\
    \ % portACL_ENTRY_SIZE_BITS );\n+\n+        xTaskMpuSettings = xTaskGetMPUSettings(\
    \ xInternalTaskHandle );\n+\n+        xTaskMpuSettings->ulAccessControlList[ ulAccessControlListEntryIndex\
    \ ] &= ~( 1U << ulAccessControlListEntryBit );\n+    }\n+\n+#endif /* #if ( (\
    \ configENABLE_MPU == 1 ) && ( configUSE_MPU_WRAPPERS_V1 == 0 ) && ( configENABLE_ACCESS_CONTROL_LIST\
    \ == 1 ) ) */\n+/*-----------------------------------------------------------*/\n\
    +\n+#if ( ( configENABLE_MPU == 1 ) && ( configUSE_MPU_WRAPPERS_V1 == 0 ) )\n\
    +\n+    #if ( configENABLE_ACCESS_CONTROL_LIST == 1 )\n+\n+        BaseType_t\
    \ xPortIsAuthorizedToAccessKernelObject( int32_t lInternalIndexOfKernelObject\
    \ ) /* PRIVILEGED_FUNCTION */\n+        {\n+            uint32_t ulAccessControlListEntryIndex,\
    \ ulAccessControlListEntryBit;\n+            BaseType_t xAccessGranted = pdFALSE;\n\
    +            const xMPU_SETTINGS * xTaskMpuSettings;\n+\n+            if( xSchedulerRunning\
    \ == pdFALSE )\n+            {\n+                /* Grant access to all the kernel\
    \ objects before the scheduler\n+                 * is started. It is necessary\
    \ because there is no task running\n+                 * yet and therefore, we\
    \ cannot use the permissions of any\n+                 * task. */\n+         \
    \       xAccessGranted = pdTRUE;\n+            }\n+            else\n+       \
    \     {\n+                xTaskMpuSettings = xTaskGetMPUSettings( NULL ); /* Calling\
    \ task's MPU settings. */\n+\n+                ulAccessControlListEntryIndex =\
    \ ( ( uint32_t ) lInternalIndexOfKernelObject / portACL_ENTRY_SIZE_BITS );\n+\
    \                ulAccessControlListEntryBit = ( ( uint32_t ) lInternalIndexOfKernelObject\
    \ % portACL_ENTRY_SIZE_BITS );\n+\n+                if( ( xTaskMpuSettings->ulTaskFlags\
    \ & portTASK_IS_PRIVILEGED_FLAG ) == portTASK_IS_PRIVILEGED_FLAG )\n+        \
    \        {\n+                    xAccessGranted = pdTRUE;\n+                }\n\
    +                else\n+                {\n+                    if( ( xTaskMpuSettings->ulAccessControlList[\
    \ ulAccessControlListEntryIndex ] & ( 1U << ulAccessControlListEntryBit ) ) !=\
    \ 0 )\n+                    {\n+                        xAccessGranted = pdTRUE;\n\
    +                    }\n+                }\n+            }\n+\n+            return\
    \ xAccessGranted;\n+        }\n+\n+    #else /* #if ( configENABLE_ACCESS_CONTROL_LIST\
    \ == 1 ) */\n+\n+        BaseType_t xPortIsAuthorizedToAccessKernelObject( int32_t\
    \ lInternalIndexOfKernelObject ) /* PRIVILEGED_FUNCTION */\n+        {\n+    \
    \        ( void ) lInternalIndexOfKernelObject;\n+\n+            /* If Access\
    \ Control List feature is not used, all the tasks have\n+             * access\
    \ to all the kernel objects. */\n+            return pdTRUE;\n+        }\n+\n\
    +    #endif /* #if ( configENABLE_ACCESS_CONTROL_LIST == 1 ) */\n+\n+#endif /*\
    \ #if ( ( configENABLE_MPU == 1 ) && ( configUSE_MPU_WRAPPERS_V1 == 0 ) ) */\n\
    +/*-----------------------------------------------------------*/"
  - "--- a/portable/IAR/ARM_CM23/non_secure/port.c\n+++ b/portable/IAR/ARM_CM23/non_secure/port.c\n\
    @@ -472,6 +472,15 @@ portDONT_DISCARD void vPortSVCHandler_C( uint32_t * pulCallerStackAddress\
    \ ) PRIV\n #endif /* configENABLE_MPU == 1 */\n /*-----------------------------------------------------------*/\n\
    \ \n+#if ( ( configENABLE_MPU == 1 ) && ( configUSE_MPU_WRAPPERS_V1 == 0 ) &&\
    \ ( configENABLE_ACCESS_CONTROL_LIST == 1 ) )\n+\n+/**\n+ * @brief This variable\
    \ is set to pdTRUE when the scheduler is started.\n+ */\n+    PRIVILEGED_DATA\
    \ static BaseType_t xSchedulerRunning = pdFALSE;\n+\n+#endif\n+\n /**\n  * @brief\
    \ Each task maintains its own interrupt status in the critical nesting\n  * variable.\n\
    @@ -1651,6 +1660,12 @@ BaseType_t xPortStartScheduler( void ) /* PRIVILEGED_FUNCTION\
    \ */\n     /* Initialize the critical nesting count ready for the first task.\
    \ */\n     ulCriticalNesting = 0;\n \n+    #if ( ( configENABLE_MPU == 1 ) &&\
    \ ( configUSE_MPU_WRAPPERS_V1 == 0 ) && ( configENABLE_ACCESS_CONTROL_LIST ==\
    \ 1 ) )\n+    {\n+        xSchedulerRunning = pdTRUE;\n+    }\n+    #endif\n+\n\
    \     /* Start the first task. */\n     vStartFirstTask();\n \n@@ -1931,3 +1946,98\
    \ @@ BaseType_t xPortIsInsideInterrupt( void )\n \n #endif /* #if ( ( configASSERT_DEFINED\
    \ == 1 ) && ( portHAS_BASEPRI == 1 ) ) */\n /*-----------------------------------------------------------*/\n\
    +\n+#if ( ( configENABLE_MPU == 1 ) && ( configUSE_MPU_WRAPPERS_V1 == 0 ) && (\
    \ configENABLE_ACCESS_CONTROL_LIST == 1 ) )\n+\n+    void vPortGrantAccessToKernelObject(\
    \ TaskHandle_t xInternalTaskHandle,\n+                                       \
    \  int32_t lInternalIndexOfKernelObject ) /* PRIVILEGED_FUNCTION */\n+    {\n\
    +        uint32_t ulAccessControlListEntryIndex, ulAccessControlListEntryBit;\n\
    +        xMPU_SETTINGS * xTaskMpuSettings;\n+\n+        ulAccessControlListEntryIndex\
    \ = ( ( uint32_t ) lInternalIndexOfKernelObject / portACL_ENTRY_SIZE_BITS );\n\
    +        ulAccessControlListEntryBit = ( ( uint32_t ) lInternalIndexOfKernelObject\
    \ % portACL_ENTRY_SIZE_BITS );\n+\n+        xTaskMpuSettings = xTaskGetMPUSettings(\
    \ xInternalTaskHandle );\n+\n+        xTaskMpuSettings->ulAccessControlList[ ulAccessControlListEntryIndex\
    \ ] |= ( 1U << ulAccessControlListEntryBit );\n+    }\n+\n+#endif /* #if ( ( configENABLE_MPU\
    \ == 1 ) && ( configUSE_MPU_WRAPPERS_V1 == 0 ) && ( configENABLE_ACCESS_CONTROL_LIST\
    \ == 1 ) ) */\n+/*-----------------------------------------------------------*/\n\
    +\n+#if ( ( configENABLE_MPU == 1 ) && ( configUSE_MPU_WRAPPERS_V1 == 0 ) && (\
    \ configENABLE_ACCESS_CONTROL_LIST == 1 ) )\n+\n+    void vPortRevokeAccessToKernelObject(\
    \ TaskHandle_t xInternalTaskHandle,\n+                                       \
    \   int32_t lInternalIndexOfKernelObject ) /* PRIVILEGED_FUNCTION */\n+    {\n\
    +        uint32_t ulAccessControlListEntryIndex, ulAccessControlListEntryBit;\n\
    +        xMPU_SETTINGS * xTaskMpuSettings;\n+\n+        ulAccessControlListEntryIndex\
    \ = ( ( uint32_t ) lInternalIndexOfKernelObject / portACL_ENTRY_SIZE_BITS );\n\
    +        ulAccessControlListEntryBit = ( ( uint32_t ) lInternalIndexOfKernelObject\
    \ % portACL_ENTRY_SIZE_BITS );\n+\n+        xTaskMpuSettings = xTaskGetMPUSettings(\
    \ xInternalTaskHandle );\n+\n+        xTaskMpuSettings->ulAccessControlList[ ulAccessControlListEntryIndex\
    \ ] &= ~( 1U << ulAccessControlListEntryBit );\n+    }\n+\n+#endif /* #if ( (\
    \ configENABLE_MPU == 1 ) && ( configUSE_MPU_WRAPPERS_V1 == 0 ) && ( configENABLE_ACCESS_CONTROL_LIST\
    \ == 1 ) ) */\n+/*-----------------------------------------------------------*/\n\
    +\n+#if ( ( configENABLE_MPU == 1 ) && ( configUSE_MPU_WRAPPERS_V1 == 0 ) )\n\
    +\n+    #if ( configENABLE_ACCESS_CONTROL_LIST == 1 )\n+\n+        BaseType_t\
    \ xPortIsAuthorizedToAccessKernelObject( int32_t lInternalIndexOfKernelObject\
    \ ) /* PRIVILEGED_FUNCTION */\n+        {\n+            uint32_t ulAccessControlListEntryIndex,\
    \ ulAccessControlListEntryBit;\n+            BaseType_t xAccessGranted = pdFALSE;\n\
    +            const xMPU_SETTINGS * xTaskMpuSettings;\n+\n+            if( xSchedulerRunning\
    \ == pdFALSE )\n+            {\n+                /* Grant access to all the kernel\
    \ objects before the scheduler\n+                 * is started. It is necessary\
    \ because there is no task running\n+                 * yet and therefore, we\
    \ cannot use the permissions of any\n+                 * task. */\n+         \
    \       xAccessGranted = pdTRUE;\n+            }\n+            else\n+       \
    \     {\n+                xTaskMpuSettings = xTaskGetMPUSettings( NULL ); /* Calling\
    \ task's MPU settings. */\n+\n+                ulAccessControlListEntryIndex =\
    \ ( ( uint32_t ) lInternalIndexOfKernelObject / portACL_ENTRY_SIZE_BITS );\n+\
    \                ulAccessControlListEntryBit = ( ( uint32_t ) lInternalIndexOfKernelObject\
    \ % portACL_ENTRY_SIZE_BITS );\n+\n+                if( ( xTaskMpuSettings->ulTaskFlags\
    \ & portTASK_IS_PRIVILEGED_FLAG ) == portTASK_IS_PRIVILEGED_FLAG )\n+        \
    \        {\n+                    xAccessGranted = pdTRUE;\n+                }\n\
    +                else\n+                {\n+                    if( ( xTaskMpuSettings->ulAccessControlList[\
    \ ulAccessControlListEntryIndex ] & ( 1U << ulAccessControlListEntryBit ) ) !=\
    \ 0 )\n+                    {\n+                        xAccessGranted = pdTRUE;\n\
    +                    }\n+                }\n+            }\n+\n+            return\
    \ xAccessGranted;\n+        }\n+\n+    #else /* #if ( configENABLE_ACCESS_CONTROL_LIST\
    \ == 1 ) */\n+\n+        BaseType_t xPortIsAuthorizedToAccessKernelObject( int32_t\
    \ lInternalIndexOfKernelObject ) /* PRIVILEGED_FUNCTION */\n+        {\n+    \
    \        ( void ) lInternalIndexOfKernelObject;\n+\n+            /* If Access\
    \ Control List feature is not used, all the tasks have\n+             * access\
    \ to all the kernel objects. */\n+            return pdTRUE;\n+        }\n+\n\
    +    #endif /* #if ( configENABLE_ACCESS_CONTROL_LIST == 1 ) */\n+\n+#endif /*\
    \ #if ( ( configENABLE_MPU == 1 ) && ( configUSE_MPU_WRAPPERS_V1 == 0 ) ) */\n\
    +/*-----------------------------------------------------------*/"
  - "--- a/portable/IAR/ARM_CM23_NTZ/non_secure/port.c\n+++ b/portable/IAR/ARM_CM23_NTZ/non_secure/port.c\n\
    @@ -472,6 +472,15 @@ portDONT_DISCARD void vPortSVCHandler_C( uint32_t * pulCallerStackAddress\
    \ ) PRIV\n #endif /* configENABLE_MPU == 1 */\n /*-----------------------------------------------------------*/\n\
    \ \n+#if ( ( configENABLE_MPU == 1 ) && ( configUSE_MPU_WRAPPERS_V1 == 0 ) &&\
    \ ( configENABLE_ACCESS_CONTROL_LIST == 1 ) )\n+\n+/**\n+ * @brief This variable\
    \ is set to pdTRUE when the scheduler is started.\n+ */\n+    PRIVILEGED_DATA\
    \ static BaseType_t xSchedulerRunning = pdFALSE;\n+\n+#endif\n+\n /**\n  * @brief\
    \ Each task maintains its own interrupt status in the critical nesting\n  * variable.\n\
    @@ -1651,6 +1660,12 @@ BaseType_t xPortStartScheduler( void ) /* PRIVILEGED_FUNCTION\
    \ */\n     /* Initialize the critical nesting count ready for the first task.\
    \ */\n     ulCriticalNesting = 0;\n \n+    #if ( ( configENABLE_MPU == 1 ) &&\
    \ ( configUSE_MPU_WRAPPERS_V1 == 0 ) && ( configENABLE_ACCESS_CONTROL_LIST ==\
    \ 1 ) )\n+    {\n+        xSchedulerRunning = pdTRUE;\n+    }\n+    #endif\n+\n\
    \     /* Start the first task. */\n     vStartFirstTask();\n \n@@ -1931,3 +1946,98\
    \ @@ BaseType_t xPortIsInsideInterrupt( void )\n \n #endif /* #if ( ( configASSERT_DEFINED\
    \ == 1 ) && ( portHAS_BASEPRI == 1 ) ) */\n /*-----------------------------------------------------------*/\n\
    +\n+#if ( ( configENABLE_MPU == 1 ) && ( configUSE_MPU_WRAPPERS_V1 == 0 ) && (\
    \ configENABLE_ACCESS_CONTROL_LIST == 1 ) )\n+\n+    void vPortGrantAccessToKernelObject(\
    \ TaskHandle_t xInternalTaskHandle,\n+                                       \
    \  int32_t lInternalIndexOfKernelObject ) /* PRIVILEGED_FUNCTION */\n+    {\n\
    +        uint32_t ulAccessControlListEntryIndex, ulAccessControlListEntryBit;\n\
    +        xMPU_SETTINGS * xTaskMpuSettings;\n+\n+        ulAccessControlListEntryIndex\
    \ = ( ( uint32_t ) lInternalIndexOfKernelObject / portACL_ENTRY_SIZE_BITS );\n\
    +        ulAccessControlListEntryBit = ( ( uint32_t ) lInternalIndexOfKernelObject\
    \ % portACL_ENTRY_SIZE_BITS );\n+\n+        xTaskMpuSettings = xTaskGetMPUSettings(\
    \ xInternalTaskHandle );\n+\n+        xTaskMpuSettings->ulAccessControlList[ ulAccessControlListEntryIndex\
    \ ] |= ( 1U << ulAccessControlListEntryBit );\n+    }\n+\n+#endif /* #if ( ( configENABLE_MPU\
    \ == 1 ) && ( configUSE_MPU_WRAPPERS_V1 == 0 ) && ( configENABLE_ACCESS_CONTROL_LIST\
    \ == 1 ) ) */\n+/*-----------------------------------------------------------*/\n\
    +\n+#if ( ( configENABLE_MPU == 1 ) && ( configUSE_MPU_WRAPPERS_V1 == 0 ) && (\
    \ configENABLE_ACCESS_CONTROL_LIST == 1 ) )\n+\n+    void vPortRevokeAccessToKernelObject(\
    \ TaskHandle_t xInternalTaskHandle,\n+                                       \
    \   int32_t lInternalIndexOfKernelObject ) /* PRIVILEGED_FUNCTION */\n+    {\n\
    +        uint32_t ulAccessControlListEntryIndex, ulAccessControlListEntryBit;\n\
    +        xMPU_SETTINGS * xTaskMpuSettings;\n+\n+        ulAccessControlListEntryIndex\
    \ = ( ( uint32_t ) lInternalIndexOfKernelObject / portACL_ENTRY_SIZE_BITS );\n\
    +        ulAccessControlListEntryBit = ( ( uint32_t ) lInternalIndexOfKernelObject\
    \ % portACL_ENTRY_SIZE_BITS );\n+\n+        xTaskMpuSettings = xTaskGetMPUSettings(\
    \ xInternalTaskHandle );\n+\n+        xTaskMpuSettings->ulAccessControlList[ ulAccessControlListEntryIndex\
    \ ] &= ~( 1U << ulAccessControlListEntryBit );\n+    }\n+\n+#endif /* #if ( (\
    \ configENABLE_MPU == 1 ) && ( configUSE_MPU_WRAPPERS_V1 == 0 ) && ( configENABLE_ACCESS_CONTROL_LIST\
    \ == 1 ) ) */\n+/*-----------------------------------------------------------*/\n\
    +\n+#if ( ( configENABLE_MPU == 1 ) && ( configUSE_MPU_WRAPPERS_V1 == 0 ) )\n\
    +\n+    #if ( configENABLE_ACCESS_CONTROL_LIST == 1 )\n+\n+        BaseType_t\
    \ xPortIsAuthorizedToAccessKernelObject( int32_t lInternalIndexOfKernelObject\
    \ ) /* PRIVILEGED_FUNCTION */\n+        {\n+            uint32_t ulAccessControlListEntryIndex,\
    \ ulAccessControlListEntryBit;\n+            BaseType_t xAccessGranted = pdFALSE;\n\
    +            const xMPU_SETTINGS * xTaskMpuSettings;\n+\n+            if( xSchedulerRunning\
    \ == pdFALSE )\n+            {\n+                /* Grant access to all the kernel\
    \ objects before the scheduler\n+                 * is started. It is necessary\
    \ because there is no task running\n+                 * yet and therefore, we\
    \ cannot use the permissions of any\n+                 * task. */\n+         \
    \       xAccessGranted = pdTRUE;\n+            }\n+            else\n+       \
    \     {\n+                xTaskMpuSettings = xTaskGetMPUSettings( NULL ); /* Calling\
    \ task's MPU settings. */\n+\n+                ulAccessControlListEntryIndex =\
    \ ( ( uint32_t ) lInternalIndexOfKernelObject / portACL_ENTRY_SIZE_BITS );\n+\
    \                ulAccessControlListEntryBit = ( ( uint32_t ) lInternalIndexOfKernelObject\
    \ % portACL_ENTRY_SIZE_BITS );\n+\n+                if( ( xTaskMpuSettings->ulTaskFlags\
    \ & portTASK_IS_PRIVILEGED_FLAG ) == portTASK_IS_PRIVILEGED_FLAG )\n+        \
    \        {\n+                    xAccessGranted = pdTRUE;\n+                }\n\
    +                else\n+                {\n+                    if( ( xTaskMpuSettings->ulAccessControlList[\
    \ ulAccessControlListEntryIndex ] & ( 1U << ulAccessControlListEntryBit ) ) !=\
    \ 0 )\n+                    {\n+                        xAccessGranted = pdTRUE;\n\
    +                    }\n+                }\n+            }\n+\n+            return\
    \ xAccessGranted;\n+        }\n+\n+    #else /* #if ( configENABLE_ACCESS_CONTROL_LIST\
    \ == 1 ) */\n+\n+        BaseType_t xPortIsAuthorizedToAccessKernelObject( int32_t\
    \ lInternalIndexOfKernelObject ) /* PRIVILEGED_FUNCTION */\n+        {\n+    \
    \        ( void ) lInternalIndexOfKernelObject;\n+\n+            /* If Access\
    \ Control List feature is not used, all the tasks have\n+             * access\
    \ to all the kernel objects. */\n+            return pdTRUE;\n+        }\n+\n\
    +    #endif /* #if ( configENABLE_ACCESS_CONTROL_LIST == 1 ) */\n+\n+#endif /*\
    \ #if ( ( configENABLE_MPU == 1 ) && ( configUSE_MPU_WRAPPERS_V1 == 0 ) ) */\n\
    +/*-----------------------------------------------------------*/"
  - "--- a/portable/IAR/ARM_CM33/non_secure/port.c\n+++ b/portable/IAR/ARM_CM33/non_secure/port.c\n\
    @@ -472,6 +472,15 @@ portDONT_DISCARD void vPortSVCHandler_C( uint32_t * pulCallerStackAddress\
    \ ) PRIV\n #endif /* configENABLE_MPU == 1 */\n /*-----------------------------------------------------------*/\n\
    \ \n+#if ( ( configENABLE_MPU == 1 ) && ( configUSE_MPU_WRAPPERS_V1 == 0 ) &&\
    \ ( configENABLE_ACCESS_CONTROL_LIST == 1 ) )\n+\n+/**\n+ * @brief This variable\
    \ is set to pdTRUE when the scheduler is started.\n+ */\n+    PRIVILEGED_DATA\
    \ static BaseType_t xSchedulerRunning = pdFALSE;\n+\n+#endif\n+\n /**\n  * @brief\
    \ Each task maintains its own interrupt status in the critical nesting\n  * variable.\n\
    @@ -1651,6 +1660,12 @@ BaseType_t xPortStartScheduler( void ) /* PRIVILEGED_FUNCTION\
    \ */\n     /* Initialize the critical nesting count ready for the first task.\
    \ */\n     ulCriticalNesting = 0;\n \n+    #if ( ( configENABLE_MPU == 1 ) &&\
    \ ( configUSE_MPU_WRAPPERS_V1 == 0 ) && ( configENABLE_ACCESS_CONTROL_LIST ==\
    \ 1 ) )\n+    {\n+        xSchedulerRunning = pdTRUE;\n+    }\n+    #endif\n+\n\
    \     /* Start the first task. */\n     vStartFirstTask();\n \n@@ -1931,3 +1946,98\
    \ @@ BaseType_t xPortIsInsideInterrupt( void )\n \n #endif /* #if ( ( configASSERT_DEFINED\
    \ == 1 ) && ( portHAS_BASEPRI == 1 ) ) */\n /*-----------------------------------------------------------*/\n\
    +\n+#if ( ( configENABLE_MPU == 1 ) && ( configUSE_MPU_WRAPPERS_V1 == 0 ) && (\
    \ configENABLE_ACCESS_CONTROL_LIST == 1 ) )\n+\n+    void vPortGrantAccessToKernelObject(\
    \ TaskHandle_t xInternalTaskHandle,\n+                                       \
    \  int32_t lInternalIndexOfKernelObject ) /* PRIVILEGED_FUNCTION */\n+    {\n\
    +        uint32_t ulAccessControlListEntryIndex, ulAccessControlListEntryBit;\n\
    +        xMPU_SETTINGS * xTaskMpuSettings;\n+\n+        ulAccessControlListEntryIndex\
    \ = ( ( uint32_t ) lInternalIndexOfKernelObject / portACL_ENTRY_SIZE_BITS );\n\
    +        ulAccessControlListEntryBit = ( ( uint32_t ) lInternalIndexOfKernelObject\
    \ % portACL_ENTRY_SIZE_BITS );\n+\n+        xTaskMpuSettings = xTaskGetMPUSettings(\
    \ xInternalTaskHandle );\n+\n+        xTaskMpuSettings->ulAccessControlList[ ulAccessControlListEntryIndex\
    \ ] |= ( 1U << ulAccessControlListEntryBit );\n+    }\n+\n+#endif /* #if ( ( configENABLE_MPU\
    \ == 1 ) && ( configUSE_MPU_WRAPPERS_V1 == 0 ) && ( configENABLE_ACCESS_CONTROL_LIST\
    \ == 1 ) ) */\n+/*-----------------------------------------------------------*/\n\
    +\n+#if ( ( configENABLE_MPU == 1 ) && ( configUSE_MPU_WRAPPERS_V1 == 0 ) && (\
    \ configENABLE_ACCESS_CONTROL_LIST == 1 ) )\n+\n+    void vPortRevokeAccessToKernelObject(\
    \ TaskHandle_t xInternalTaskHandle,\n+                                       \
    \   int32_t lInternalIndexOfKernelObject ) /* PRIVILEGED_FUNCTION */\n+    {\n\
    +        uint32_t ulAccessControlListEntryIndex, ulAccessControlListEntryBit;\n\
    +        xMPU_SETTINGS * xTaskMpuSettings;\n+\n+        ulAccessControlListEntryIndex\
    \ = ( ( uint32_t ) lInternalIndexOfKernelObject / portACL_ENTRY_SIZE_BITS );\n\
    +        ulAccessControlListEntryBit = ( ( uint32_t ) lInternalIndexOfKernelObject\
    \ % portACL_ENTRY_SIZE_BITS );\n+\n+        xTaskMpuSettings = xTaskGetMPUSettings(\
    \ xInternalTaskHandle );\n+\n+        xTaskMpuSettings->ulAccessControlList[ ulAccessControlListEntryIndex\
    \ ] &= ~( 1U << ulAccessControlListEntryBit );\n+    }\n+\n+#endif /* #if ( (\
    \ configENABLE_MPU == 1 ) && ( configUSE_MPU_WRAPPERS_V1 == 0 ) && ( configENABLE_ACCESS_CONTROL_LIST\
    \ == 1 ) ) */\n+/*-----------------------------------------------------------*/\n\
    +\n+#if ( ( configENABLE_MPU == 1 ) && ( configUSE_MPU_WRAPPERS_V1 == 0 ) )\n\
    +\n+    #if ( configENABLE_ACCESS_CONTROL_LIST == 1 )\n+\n+        BaseType_t\
    \ xPortIsAuthorizedToAccessKernelObject( int32_t lInternalIndexOfKernelObject\
    \ ) /* PRIVILEGED_FUNCTION */\n+        {\n+            uint32_t ulAccessControlListEntryIndex,\
    \ ulAccessControlListEntryBit;\n+            BaseType_t xAccessGranted = pdFALSE;\n\
    +            const xMPU_SETTINGS * xTaskMpuSettings;\n+\n+            if( xSchedulerRunning\
    \ == pdFALSE )\n+            {\n+                /* Grant access to all the kernel\
    \ objects before the scheduler\n+                 * is started. It is necessary\
    \ because there is no task running\n+                 * yet and therefore, we\
    \ cannot use the permissions of any\n+                 * task. */\n+         \
    \       xAccessGranted = pdTRUE;\n+            }\n+            else\n+       \
    \     {\n+                xTaskMpuSettings = xTaskGetMPUSettings( NULL ); /* Calling\
    \ task's MPU settings. */\n+\n+                ulAccessControlListEntryIndex =\
    \ ( ( uint32_t ) lInternalIndexOfKernelObject / portACL_ENTRY_SIZE_BITS );\n+\
    \                ulAccessControlListEntryBit = ( ( uint32_t ) lInternalIndexOfKernelObject\
    \ % portACL_ENTRY_SIZE_BITS );\n+\n+                if( ( xTaskMpuSettings->ulTaskFlags\
    \ & portTASK_IS_PRIVILEGED_FLAG ) == portTASK_IS_PRIVILEGED_FLAG )\n+        \
    \        {\n+                    xAccessGranted = pdTRUE;\n+                }\n\
    +                else\n+                {\n+                    if( ( xTaskMpuSettings->ulAccessControlList[\
    \ ulAccessControlListEntryIndex ] & ( 1U << ulAccessControlListEntryBit ) ) !=\
    \ 0 )\n+                    {\n+                        xAccessGranted = pdTRUE;\n\
    +                    }\n+                }\n+            }\n+\n+            return\
    \ xAccessGranted;\n+        }\n+\n+    #else /* #if ( configENABLE_ACCESS_CONTROL_LIST\
    \ == 1 ) */\n+\n+        BaseType_t xPortIsAuthorizedToAccessKernelObject( int32_t\
    \ lInternalIndexOfKernelObject ) /* PRIVILEGED_FUNCTION */\n+        {\n+    \
    \        ( void ) lInternalIndexOfKernelObject;\n+\n+            /* If Access\
    \ Control List feature is not used, all the tasks have\n+             * access\
    \ to all the kernel objects. */\n+            return pdTRUE;\n+        }\n+\n\
    +    #endif /* #if ( configENABLE_ACCESS_CONTROL_LIST == 1 ) */\n+\n+#endif /*\
    \ #if ( ( configENABLE_MPU == 1 ) && ( configUSE_MPU_WRAPPERS_V1 == 0 ) ) */\n\
    +/*-----------------------------------------------------------*/"
  - "--- a/portable/IAR/ARM_CM33_NTZ/non_secure/port.c\n+++ b/portable/IAR/ARM_CM33_NTZ/non_secure/port.c\n\
    @@ -472,6 +472,15 @@ portDONT_DISCARD void vPortSVCHandler_C( uint32_t * pulCallerStackAddress\
    \ ) PRIV\n #endif /* configENABLE_MPU == 1 */\n /*-----------------------------------------------------------*/\n\
    \ \n+#if ( ( configENABLE_MPU == 1 ) && ( configUSE_MPU_WRAPPERS_V1 == 0 ) &&\
    \ ( configENABLE_ACCESS_CONTROL_LIST == 1 ) )\n+\n+/**\n+ * @brief This variable\
    \ is set to pdTRUE when the scheduler is started.\n+ */\n+    PRIVILEGED_DATA\
    \ static BaseType_t xSchedulerRunning = pdFALSE;\n+\n+#endif\n+\n /**\n  * @brief\
    \ Each task maintains its own interrupt status in the critical nesting\n  * variable.\n\
    @@ -1651,6 +1660,12 @@ BaseType_t xPortStartScheduler( void ) /* PRIVILEGED_FUNCTION\
    \ */\n     /* Initialize the critical nesting count ready for the first task.\
    \ */\n     ulCriticalNesting = 0;\n \n+    #if ( ( configENABLE_MPU == 1 ) &&\
    \ ( configUSE_MPU_WRAPPERS_V1 == 0 ) && ( configENABLE_ACCESS_CONTROL_LIST ==\
    \ 1 ) )\n+    {\n+        xSchedulerRunning = pdTRUE;\n+    }\n+    #endif\n+\n\
    \     /* Start the first task. */\n     vStartFirstTask();\n \n@@ -1931,3 +1946,98\
    \ @@ BaseType_t xPortIsInsideInterrupt( void )\n \n #endif /* #if ( ( configASSERT_DEFINED\
    \ == 1 ) && ( portHAS_BASEPRI == 1 ) ) */\n /*-----------------------------------------------------------*/\n\
    +\n+#if ( ( configENABLE_MPU == 1 ) && ( configUSE_MPU_WRAPPERS_V1 == 0 ) && (\
    \ configENABLE_ACCESS_CONTROL_LIST == 1 ) )\n+\n+    void vPortGrantAccessToKernelObject(\
    \ TaskHandle_t xInternalTaskHandle,\n+                                       \
    \  int32_t lInternalIndexOfKernelObject ) /* PRIVILEGED_FUNCTION */\n+    {\n\
    +        uint32_t ulAccessControlListEntryIndex, ulAccessControlListEntryBit;\n\
    +        xMPU_SETTINGS * xTaskMpuSettings;\n+\n+        ulAccessControlListEntryIndex\
    \ = ( ( uint32_t ) lInternalIndexOfKernelObject / portACL_ENTRY_SIZE_BITS );\n\
    +        ulAccessControlListEntryBit = ( ( uint32_t ) lInternalIndexOfKernelObject\
    \ % portACL_ENTRY_SIZE_BITS );\n+\n+        xTaskMpuSettings = xTaskGetMPUSettings(\
    \ xInternalTaskHandle );\n+\n+        xTaskMpuSettings->ulAccessControlList[ ulAccessControlListEntryIndex\
    \ ] |= ( 1U << ulAccessControlListEntryBit );\n+    }\n+\n+#endif /* #if ( ( configENABLE_MPU\
    \ == 1 ) && ( configUSE_MPU_WRAPPERS_V1 == 0 ) && ( configENABLE_ACCESS_CONTROL_LIST\
    \ == 1 ) ) */\n+/*-----------------------------------------------------------*/\n\
    +\n+#if ( ( configENABLE_MPU == 1 ) && ( configUSE_MPU_WRAPPERS_V1 == 0 ) && (\
    \ configENABLE_ACCESS_CONTROL_LIST == 1 ) )\n+\n+    void vPortRevokeAccessToKernelObject(\
    \ TaskHandle_t xInternalTaskHandle,\n+                                       \
    \   int32_t lInternalIndexOfKernelObject ) /* PRIVILEGED_FUNCTION */\n+    {\n\
    +        uint32_t ulAccessControlListEntryIndex, ulAccessControlListEntryBit;\n\
    +        xMPU_SETTINGS * xTaskMpuSettings;\n+\n+        ulAccessControlListEntryIndex\
    \ = ( ( uint32_t ) lInternalIndexOfKernelObject / portACL_ENTRY_SIZE_BITS );\n\
    +        ulAccessControlListEntryBit = ( ( uint32_t ) lInternalIndexOfKernelObject\
    \ % portACL_ENTRY_SIZE_BITS );\n+\n+        xTaskMpuSettings = xTaskGetMPUSettings(\
    \ xInternalTaskHandle );\n+\n+        xTaskMpuSettings->ulAccessControlList[ ulAccessControlListEntryIndex\
    \ ] &= ~( 1U << ulAccessControlListEntryBit );\n+    }\n+\n+#endif /* #if ( (\
    \ configENABLE_MPU == 1 ) && ( configUSE_MPU_WRAPPERS_V1 == 0 ) && ( configENABLE_ACCESS_CONTROL_LIST\
    \ == 1 ) ) */\n+/*-----------------------------------------------------------*/\n\
    +\n+#if ( ( configENABLE_MPU == 1 ) && ( configUSE_MPU_WRAPPERS_V1 == 0 ) )\n\
    +\n+    #if ( configENABLE_ACCESS_CONTROL_LIST == 1 )\n+\n+        BaseType_t\
    \ xPortIsAuthorizedToAccessKernelObject( int32_t lInternalIndexOfKernelObject\
    \ ) /* PRIVILEGED_FUNCTION */\n+        {\n+            uint32_t ulAccessControlListEntryIndex,\
    \ ulAccessControlListEntryBit;\n+            BaseType_t xAccessGranted = pdFALSE;\n\
    +            const xMPU_SETTINGS * xTaskMpuSettings;\n+\n+            if( xSchedulerRunning\
    \ == pdFALSE )\n+            {\n+                /* Grant access to all the kernel\
    \ objects before the scheduler\n+                 * is started. It is necessary\
    \ because there is no task running\n+                 * yet and therefore, we\
    \ cannot use the permissions of any\n+                 * task. */\n+         \
    \       xAccessGranted = pdTRUE;\n+            }\n+            else\n+       \
    \     {\n+                xTaskMpuSettings = xTaskGetMPUSettings( NULL ); /* Calling\
    \ task's MPU settings. */\n+\n+                ulAccessControlListEntryIndex =\
    \ ( ( uint32_t ) lInternalIndexOfKernelObject / portACL_ENTRY_SIZE_BITS );\n+\
    \                ulAccessControlListEntryBit = ( ( uint32_t ) lInternalIndexOfKernelObject\
    \ % portACL_ENTRY_SIZE_BITS );\n+\n+                if( ( xTaskMpuSettings->ulTaskFlags\
    \ & portTASK_IS_PRIVILEGED_FLAG ) == portTASK_IS_PRIVILEGED_FLAG )\n+        \
    \        {\n+                    xAccessGranted = pdTRUE;\n+                }\n\
    +                else\n+                {\n+                    if( ( xTaskMpuSettings->ulAccessControlList[\
    \ ulAccessControlListEntryIndex ] & ( 1U << ulAccessControlListEntryBit ) ) !=\
    \ 0 )\n+                    {\n+                        xAccessGranted = pdTRUE;\n\
    +                    }\n+                }\n+            }\n+\n+            return\
    \ xAccessGranted;\n+        }\n+\n+    #else /* #if ( configENABLE_ACCESS_CONTROL_LIST\
    \ == 1 ) */\n+\n+        BaseType_t xPortIsAuthorizedToAccessKernelObject( int32_t\
    \ lInternalIndexOfKernelObject ) /* PRIVILEGED_FUNCTION */\n+        {\n+    \
    \        ( void ) lInternalIndexOfKernelObject;\n+\n+            /* If Access\
    \ Control List feature is not used, all the tasks have\n+             * access\
    \ to all the kernel objects. */\n+            return pdTRUE;\n+        }\n+\n\
    +    #endif /* #if ( configENABLE_ACCESS_CONTROL_LIST == 1 ) */\n+\n+#endif /*\
    \ #if ( ( configENABLE_MPU == 1 ) && ( configUSE_MPU_WRAPPERS_V1 == 0 ) ) */\n\
    +/*-----------------------------------------------------------*/"
  - "--- a/portable/IAR/ARM_CM35P/non_secure/port.c\n+++ b/portable/IAR/ARM_CM35P/non_secure/port.c\n\
    @@ -472,6 +472,15 @@ portDONT_DISCARD void vPortSVCHandler_C( uint32_t * pulCallerStackAddress\
    \ ) PRIV\n #endif /* configENABLE_MPU == 1 */\n /*-----------------------------------------------------------*/\n\
    \ \n+#if ( ( configENABLE_MPU == 1 ) && ( configUSE_MPU_WRAPPERS_V1 == 0 ) &&\
    \ ( configENABLE_ACCESS_CONTROL_LIST == 1 ) )\n+\n+/**\n+ * @brief This variable\
    \ is set to pdTRUE when the scheduler is started.\n+ */\n+    PRIVILEGED_DATA\
    \ static BaseType_t xSchedulerRunning = pdFALSE;\n+\n+#endif\n+\n /**\n  * @brief\
    \ Each task maintains its own interrupt status in the critical nesting\n  * variable.\n\
    @@ -1651,6 +1660,12 @@ BaseType_t xPortStartScheduler( void ) /* PRIVILEGED_FUNCTION\
    \ */\n     /* Initialize the critical nesting count ready for the first task.\
    \ */\n     ulCriticalNesting = 0;\n \n+    #if ( ( configENABLE_MPU == 1 ) &&\
    \ ( configUSE_MPU_WRAPPERS_V1 == 0 ) && ( configENABLE_ACCESS_CONTROL_LIST ==\
    \ 1 ) )\n+    {\n+        xSchedulerRunning = pdTRUE;\n+    }\n+    #endif\n+\n\
    \     /* Start the first task. */\n     vStartFirstTask();\n \n@@ -1931,3 +1946,98\
    \ @@ BaseType_t xPortIsInsideInterrupt( void )\n \n #endif /* #if ( ( configASSERT_DEFINED\
    \ == 1 ) && ( portHAS_BASEPRI == 1 ) ) */\n /*-----------------------------------------------------------*/\n\
    +\n+#if ( ( configENABLE_MPU == 1 ) && ( configUSE_MPU_WRAPPERS_V1 == 0 ) && (\
    \ configENABLE_ACCESS_CONTROL_LIST == 1 ) )\n+\n+    void vPortGrantAccessToKernelObject(\
    \ TaskHandle_t xInternalTaskHandle,\n+                                       \
    \  int32_t lInternalIndexOfKernelObject ) /* PRIVILEGED_FUNCTION */\n+    {\n\
    +        uint32_t ulAccessControlListEntryIndex, ulAccessControlListEntryBit;\n\
    +        xMPU_SETTINGS * xTaskMpuSettings;\n+\n+        ulAccessControlListEntryIndex\
    \ = ( ( uint32_t ) lInternalIndexOfKernelObject / portACL_ENTRY_SIZE_BITS );\n\
    +        ulAccessControlListEntryBit = ( ( uint32_t ) lInternalIndexOfKernelObject\
    \ % portACL_ENTRY_SIZE_BITS );\n+\n+        xTaskMpuSettings = xTaskGetMPUSettings(\
    \ xInternalTaskHandle );\n+\n+        xTaskMpuSettings->ulAccessControlList[ ulAccessControlListEntryIndex\
    \ ] |= ( 1U << ulAccessControlListEntryBit );\n+    }\n+\n+#endif /* #if ( ( configENABLE_MPU\
    \ == 1 ) && ( configUSE_MPU_WRAPPERS_V1 == 0 ) && ( configENABLE_ACCESS_CONTROL_LIST\
    \ == 1 ) ) */\n+/*-----------------------------------------------------------*/\n\
    +\n+#if ( ( configENABLE_MPU == 1 ) && ( configUSE_MPU_WRAPPERS_V1 == 0 ) && (\
    \ configENABLE_ACCESS_CONTROL_LIST == 1 ) )\n+\n+    void vPortRevokeAccessToKernelObject(\
    \ TaskHandle_t xInternalTaskHandle,\n+                                       \
    \   int32_t lInternalIndexOfKernelObject ) /* PRIVILEGED_FUNCTION */\n+    {\n\
    +        uint32_t ulAccessControlListEntryIndex, ulAccessControlListEntryBit;\n\
    +        xMPU_SETTINGS * xTaskMpuSettings;\n+\n+        ulAccessControlListEntryIndex\
    \ = ( ( uint32_t ) lInternalIndexOfKernelObject / portACL_ENTRY_SIZE_BITS );\n\
    +        ulAccessControlListEntryBit = ( ( uint32_t ) lInternalIndexOfKernelObject\
    \ % portACL_ENTRY_SIZE_BITS );\n+\n+        xTaskMpuSettings = xTaskGetMPUSettings(\
    \ xInternalTaskHandle );\n+\n+        xTaskMpuSettings->ulAccessControlList[ ulAccessControlListEntryIndex\
    \ ] &= ~( 1U << ulAccessControlListEntryBit );\n+    }\n+\n+#endif /* #if ( (\
    \ configENABLE_MPU == 1 ) && ( configUSE_MPU_WRAPPERS_V1 == 0 ) && ( configENABLE_ACCESS_CONTROL_LIST\
    \ == 1 ) ) */\n+/*-----------------------------------------------------------*/\n\
    +\n+#if ( ( configENABLE_MPU == 1 ) && ( configUSE_MPU_WRAPPERS_V1 == 0 ) )\n\
    +\n+    #if ( configENABLE_ACCESS_CONTROL_LIST == 1 )\n+\n+        BaseType_t\
    \ xPortIsAuthorizedToAccessKernelObject( int32_t lInternalIndexOfKernelObject\
    \ ) /* PRIVILEGED_FUNCTION */\n+        {\n+            uint32_t ulAccessControlListEntryIndex,\
    \ ulAccessControlListEntryBit;\n+            BaseType_t xAccessGranted = pdFALSE;\n\
    +            const xMPU_SETTINGS * xTaskMpuSettings;\n+\n+            if( xSchedulerRunning\
    \ == pdFALSE )\n+            {\n+                /* Grant access to all the kernel\
    \ objects before the scheduler\n+                 * is started. It is necessary\
    \ because there is no task running\n+                 * yet and therefore, we\
    \ cannot use the permissions of any\n+                 * task. */\n+         \
    \       xAccessGranted = pdTRUE;\n+            }\n+            else\n+       \
    \     {\n+                xTaskMpuSettings = xTaskGetMPUSettings( NULL ); /* Calling\
    \ task's MPU settings. */\n+\n+                ulAccessControlListEntryIndex =\
    \ ( ( uint32_t ) lInternalIndexOfKernelObject / portACL_ENTRY_SIZE_BITS );\n+\
    \                ulAccessControlListEntryBit = ( ( uint32_t ) lInternalIndexOfKernelObject\
    \ % portACL_ENTRY_SIZE_BITS );\n+\n+                if( ( xTaskMpuSettings->ulTaskFlags\
    \ & portTASK_IS_PRIVILEGED_FLAG ) == portTASK_IS_PRIVILEGED_FLAG )\n+        \
    \        {\n+                    xAccessGranted = pdTRUE;\n+                }\n\
    +                else\n+                {\n+                    if( ( xTaskMpuSettings->ulAccessControlList[\
    \ ulAccessControlListEntryIndex ] & ( 1U << ulAccessControlListEntryBit ) ) !=\
    \ 0 )\n+                    {\n+                        xAccessGranted = pdTRUE;\n\
    +                    }\n+                }\n+            }\n+\n+            return\
    \ xAccessGranted;\n+        }\n+\n+    #else /* #if ( configENABLE_ACCESS_CONTROL_LIST\
    \ == 1 ) */\n+\n+        BaseType_t xPortIsAuthorizedToAccessKernelObject( int32_t\
    \ lInternalIndexOfKernelObject ) /* PRIVILEGED_FUNCTION */\n+        {\n+    \
    \        ( void ) lInternalIndexOfKernelObject;\n+\n+            /* If Access\
    \ Control List feature is not used, all the tasks have\n+             * access\
    \ to all the kernel objects. */\n+            return pdTRUE;\n+        }\n+\n\
    +    #endif /* #if ( configENABLE_ACCESS_CONTROL_LIST == 1 ) */\n+\n+#endif /*\
    \ #if ( ( configENABLE_MPU == 1 ) && ( configUSE_MPU_WRAPPERS_V1 == 0 ) ) */\n\
    +/*-----------------------------------------------------------*/"
  - "--- a/portable/IAR/ARM_CM35P_NTZ/non_secure/port.c\n+++ b/portable/IAR/ARM_CM35P_NTZ/non_secure/port.c\n\
    @@ -472,6 +472,15 @@ portDONT_DISCARD void vPortSVCHandler_C( uint32_t * pulCallerStackAddress\
    \ ) PRIV\n #endif /* configENABLE_MPU == 1 */\n /*-----------------------------------------------------------*/\n\
    \ \n+#if ( ( configENABLE_MPU == 1 ) && ( configUSE_MPU_WRAPPERS_V1 == 0 ) &&\
    \ ( configENABLE_ACCESS_CONTROL_LIST == 1 ) )\n+\n+/**\n+ * @brief This variable\
    \ is set to pdTRUE when the scheduler is started.\n+ */\n+    PRIVILEGED_DATA\
    \ static BaseType_t xSchedulerRunning = pdFALSE;\n+\n+#endif\n+\n /**\n  * @brief\
    \ Each task maintains its own interrupt status in the critical nesting\n  * variable.\n\
    @@ -1651,6 +1660,12 @@ BaseType_t xPortStartScheduler( void ) /* PRIVILEGED_FUNCTION\
    \ */\n     /* Initialize the critical nesting count ready for the first task.\
    \ */\n     ulCriticalNesting = 0;\n \n+    #if ( ( configENABLE_MPU == 1 ) &&\
    \ ( configUSE_MPU_WRAPPERS_V1 == 0 ) && ( configENABLE_ACCESS_CONTROL_LIST ==\
    \ 1 ) )\n+    {\n+        xSchedulerRunning = pdTRUE;\n+    }\n+    #endif\n+\n\
    \     /* Start the first task. */\n     vStartFirstTask();\n \n@@ -1931,3 +1946,98\
    \ @@ BaseType_t xPortIsInsideInterrupt( void )\n \n #endif /* #if ( ( configASSERT_DEFINED\
    \ == 1 ) && ( portHAS_BASEPRI == 1 ) ) */\n /*-----------------------------------------------------------*/\n\
    +\n+#if ( ( configENABLE_MPU == 1 ) && ( configUSE_MPU_WRAPPERS_V1 == 0 ) && (\
    \ configENABLE_ACCESS_CONTROL_LIST == 1 ) )\n+\n+    void vPortGrantAccessToKernelObject(\
    \ TaskHandle_t xInternalTaskHandle,\n+                                       \
    \  int32_t lInternalIndexOfKernelObject ) /* PRIVILEGED_FUNCTION */\n+    {\n\
    +        uint32_t ulAccessControlListEntryIndex, ulAccessControlListEntryBit;\n\
    +        xMPU_SETTINGS * xTaskMpuSettings;\n+\n+        ulAccessControlListEntryIndex\
    \ = ( ( uint32_t ) lInternalIndexOfKernelObject / portACL_ENTRY_SIZE_BITS );\n\
    +        ulAccessControlListEntryBit = ( ( uint32_t ) lInternalIndexOfKernelObject\
    \ % portACL_ENTRY_SIZE_BITS );\n+\n+        xTaskMpuSettings = xTaskGetMPUSettings(\
    \ xInternalTaskHandle );\n+\n+        xTaskMpuSettings->ulAccessControlList[ ulAccessControlListEntryIndex\
    \ ] |= ( 1U << ulAccessControlListEntryBit );\n+    }\n+\n+#endif /* #if ( ( configENABLE_MPU\
    \ == 1 ) && ( configUSE_MPU_WRAPPERS_V1 == 0 ) && ( configENABLE_ACCESS_CONTROL_LIST\
    \ == 1 ) ) */\n+/*-----------------------------------------------------------*/\n\
    +\n+#if ( ( configENABLE_MPU == 1 ) && ( configUSE_MPU_WRAPPERS_V1 == 0 ) && (\
    \ configENABLE_ACCESS_CONTROL_LIST == 1 ) )\n+\n+    void vPortRevokeAccessToKernelObject(\
    \ TaskHandle_t xInternalTaskHandle,\n+                                       \
    \   int32_t lInternalIndexOfKernelObject ) /* PRIVILEGED_FUNCTION */\n+    {\n\
    +        uint32_t ulAccessControlListEntryIndex, ulAccessControlListEntryBit;\n\
    +        xMPU_SETTINGS * xTaskMpuSettings;\n+\n+        ulAccessControlListEntryIndex\
    \ = ( ( uint32_t ) lInternalIndexOfKernelObject / portACL_ENTRY_SIZE_BITS );\n\
    +        ulAccessControlListEntryBit = ( ( uint32_t ) lInternalIndexOfKernelObject\
    \ % portACL_ENTRY_SIZE_BITS );\n+\n+        xTaskMpuSettings = xTaskGetMPUSettings(\
    \ xInternalTaskHandle );\n+\n+        xTaskMpuSettings->ulAccessControlList[ ulAccessControlListEntryIndex\
    \ ] &= ~( 1U << ulAccessControlListEntryBit );\n+    }\n+\n+#endif /* #if ( (\
    \ configENABLE_MPU == 1 ) && ( configUSE_MPU_WRAPPERS_V1 == 0 ) && ( configENABLE_ACCESS_CONTROL_LIST\
    \ == 1 ) ) */\n+/*-----------------------------------------------------------*/\n\
    +\n+#if ( ( configENABLE_MPU == 1 ) && ( configUSE_MPU_WRAPPERS_V1 == 0 ) )\n\
    +\n+    #if ( configENABLE_ACCESS_CONTROL_LIST == 1 )\n+\n+        BaseType_t\
    \ xPortIsAuthorizedToAccessKernelObject( int32_t lInternalIndexOfKernelObject\
    \ ) /* PRIVILEGED_FUNCTION */\n+        {\n+            uint32_t ulAccessControlListEntryIndex,\
    \ ulAccessControlListEntryBit;\n+            BaseType_t xAccessGranted = pdFALSE;\n\
    +            const xMPU_SETTINGS * xTaskMpuSettings;\n+\n+            if( xSchedulerRunning\
    \ == pdFALSE )\n+            {\n+                /* Grant access to all the kernel\
    \ objects before the scheduler\n+                 * is started. It is necessary\
    \ because there is no task running\n+                 * yet and therefore, we\
    \ cannot use the permissions of any\n+                 * task. */\n+         \
    \       xAccessGranted = pdTRUE;\n+            }\n+            else\n+       \
    \     {\n+                xTaskMpuSettings = xTaskGetMPUSettings( NULL ); /* Calling\
    \ task's MPU settings. */\n+\n+                ulAccessControlListEntryIndex =\
    \ ( ( uint32_t ) lInternalIndexOfKernelObject / portACL_ENTRY_SIZE_BITS );\n+\
    \                ulAccessControlListEntryBit = ( ( uint32_t ) lInternalIndexOfKernelObject\
    \ % portACL_ENTRY_SIZE_BITS );\n+\n+                if( ( xTaskMpuSettings->ulTaskFlags\
    \ & portTASK_IS_PRIVILEGED_FLAG ) == portTASK_IS_PRIVILEGED_FLAG )\n+        \
    \        {\n+                    xAccessGranted = pdTRUE;\n+                }\n\
    +                else\n+                {\n+                    if( ( xTaskMpuSettings->ulAccessControlList[\
    \ ulAccessControlListEntryIndex ] & ( 1U << ulAccessControlListEntryBit ) ) !=\
    \ 0 )\n+                    {\n+                        xAccessGranted = pdTRUE;\n\
    +                    }\n+                }\n+            }\n+\n+            return\
    \ xAccessGranted;\n+        }\n+\n+    #else /* #if ( configENABLE_ACCESS_CONTROL_LIST\
    \ == 1 ) */\n+\n+        BaseType_t xPortIsAuthorizedToAccessKernelObject( int32_t\
    \ lInternalIndexOfKernelObject ) /* PRIVILEGED_FUNCTION */\n+        {\n+    \
    \        ( void ) lInternalIndexOfKernelObject;\n+\n+            /* If Access\
    \ Control List feature is not used, all the tasks have\n+             * access\
    \ to all the kernel objects. */\n+            return pdTRUE;\n+        }\n+\n\
    +    #endif /* #if ( configENABLE_ACCESS_CONTROL_LIST == 1 ) */\n+\n+#endif /*\
    \ #if ( ( configENABLE_MPU == 1 ) && ( configUSE_MPU_WRAPPERS_V1 == 0 ) ) */\n\
    +/*-----------------------------------------------------------*/"
  - "--- a/portable/IAR/ARM_CM4F_MPU/port.c\n+++ b/portable/IAR/ARM_CM4F_MPU/port.c\n\
    @@ -283,6 +283,15 @@ BaseType_t xPortIsTaskPrivileged( void ) PRIVILEGED_FUNCTION;\n\
    \  * variable. */\n static UBaseType_t uxCriticalNesting = 0xaaaaaaaa;\n \n+#if\
    \ ( ( configUSE_MPU_WRAPPERS_V1 == 0 ) && ( configENABLE_ACCESS_CONTROL_LIST ==\
    \ 1 ) )\n+\n+/*\n+ * This variable is set to pdTRUE when the scheduler is started.\n\
    + */\n+    PRIVILEGED_DATA static BaseType_t xSchedulerRunning = pdFALSE;\n+\n\
    +#endif\n+\n /*\n  * Used by the portASSERT_IF_INTERRUPT_PRIORITY_INVALID() macro\
    \ to ensure\n  * FreeRTOS API functions are not called from interrupts that have\
    \ been assigned\n@@ -787,6 +796,12 @@ BaseType_t xPortStartScheduler( void )\n\
    \     /* Initialise the critical nesting count ready for the first task. */\n\
    \     uxCriticalNesting = 0;\n \n+    #if ( ( configUSE_MPU_WRAPPERS_V1 == 0 )\
    \ && ( configENABLE_ACCESS_CONTROL_LIST == 1 ) )\n+    {\n+        xSchedulerRunning\
    \ = pdTRUE;\n+    }\n+    #endif\n+\n     /* Ensure the VFP is enabled - it should\
    \ be anyway. */\n     vPortEnableVFP();\n \n@@ -1262,3 +1277,98 @@ BaseType_t\
    \ xPortIsAuthorizedToAccessBuffer( const void * pvBuffer,\n \n #endif /* configASSERT_DEFINED\
    \ */\n /*-----------------------------------------------------------*/\n+\n+#if\
    \ ( ( configUSE_MPU_WRAPPERS_V1 == 0 ) && ( configENABLE_ACCESS_CONTROL_LIST ==\
    \ 1 ) )\n+\n+    void vPortGrantAccessToKernelObject( TaskHandle_t xInternalTaskHandle,\n\
    +                                         int32_t lInternalIndexOfKernelObject\
    \ ) /* PRIVILEGED_FUNCTION */\n+    {\n+        uint32_t ulAccessControlListEntryIndex,\
    \ ulAccessControlListEntryBit;\n+        xMPU_SETTINGS * xTaskMpuSettings;\n+\n\
    +        ulAccessControlListEntryIndex = ( ( uint32_t ) lInternalIndexOfKernelObject\
    \ / portACL_ENTRY_SIZE_BITS );\n+        ulAccessControlListEntryBit = ( ( uint32_t\
    \ ) lInternalIndexOfKernelObject % portACL_ENTRY_SIZE_BITS );\n+\n+        xTaskMpuSettings\
    \ = xTaskGetMPUSettings( xInternalTaskHandle );\n+\n+        xTaskMpuSettings->ulAccessControlList[\
    \ ulAccessControlListEntryIndex ] |= ( 1U << ulAccessControlListEntryBit );\n\
    +    }\n+\n+#endif /* #if ( ( configUSE_MPU_WRAPPERS_V1 == 0 ) && ( configENABLE_ACCESS_CONTROL_LIST\
    \ == 1 ) ) */\n+/*-----------------------------------------------------------*/\n\
    +\n+#if ( ( configUSE_MPU_WRAPPERS_V1 == 0 ) && ( configENABLE_ACCESS_CONTROL_LIST\
    \ == 1 ) )\n+\n+    void vPortRevokeAccessToKernelObject( TaskHandle_t xInternalTaskHandle,\n\
    +                                          int32_t lInternalIndexOfKernelObject\
    \ ) /* PRIVILEGED_FUNCTION */\n+    {\n+        uint32_t ulAccessControlListEntryIndex,\
    \ ulAccessControlListEntryBit;\n+        xMPU_SETTINGS * xTaskMpuSettings;\n+\n\
    +        ulAccessControlListEntryIndex = ( ( uint32_t ) lInternalIndexOfKernelObject\
    \ / portACL_ENTRY_SIZE_BITS );\n+        ulAccessControlListEntryBit = ( ( uint32_t\
    \ ) lInternalIndexOfKernelObject % portACL_ENTRY_SIZE_BITS );\n+\n+        xTaskMpuSettings\
    \ = xTaskGetMPUSettings( xInternalTaskHandle );\n+\n+        xTaskMpuSettings->ulAccessControlList[\
    \ ulAccessControlListEntryIndex ] &= ~( 1U << ulAccessControlListEntryBit );\n\
    +    }\n+\n+#endif /* #if ( ( configUSE_MPU_WRAPPERS_V1 == 0 ) && ( configENABLE_ACCESS_CONTROL_LIST\
    \ == 1 ) ) */\n+/*-----------------------------------------------------------*/\n\
    +\n+#if ( configUSE_MPU_WRAPPERS_V1 == 0 )\n+\n+    #if ( configENABLE_ACCESS_CONTROL_LIST\
    \ == 1 )\n+\n+        BaseType_t xPortIsAuthorizedToAccessKernelObject( int32_t\
    \ lInternalIndexOfKernelObject ) /* PRIVILEGED_FUNCTION */\n+        {\n+    \
    \        uint32_t ulAccessControlListEntryIndex, ulAccessControlListEntryBit;\n\
    +            BaseType_t xAccessGranted = pdFALSE;\n+            const xMPU_SETTINGS\
    \ * xTaskMpuSettings;\n+\n+            if( xSchedulerRunning == pdFALSE )\n+ \
    \           {\n+                /* Grant access to all the kernel objects before\
    \ the scheduler\n+                 * is started. It is necessary because there\
    \ is no task running\n+                 * yet and therefore, we cannot use the\
    \ permissions of any\n+                 * task. */\n+                xAccessGranted\
    \ = pdTRUE;\n+            }\n+            else\n+            {\n+            \
    \    xTaskMpuSettings = xTaskGetMPUSettings( NULL ); /* Calling task's MPU settings.\
    \ */\n+\n+                ulAccessControlListEntryIndex = ( ( uint32_t ) lInternalIndexOfKernelObject\
    \ / portACL_ENTRY_SIZE_BITS );\n+                ulAccessControlListEntryBit =\
    \ ( ( uint32_t ) lInternalIndexOfKernelObject % portACL_ENTRY_SIZE_BITS );\n+\n\
    +                if( ( xTaskMpuSettings->ulTaskFlags & portTASK_IS_PRIVILEGED_FLAG\
    \ ) == portTASK_IS_PRIVILEGED_FLAG )\n+                {\n+                  \
    \  xAccessGranted = pdTRUE;\n+                }\n+                else\n+    \
    \            {\n+                    if( ( xTaskMpuSettings->ulAccessControlList[\
    \ ulAccessControlListEntryIndex ] & ( 1U << ulAccessControlListEntryBit ) ) !=\
    \ 0 )\n+                    {\n+                        xAccessGranted = pdTRUE;\n\
    +                    }\n+                }\n+            }\n+\n+            return\
    \ xAccessGranted;\n+        }\n+\n+    #else /* #if ( configENABLE_ACCESS_CONTROL_LIST\
    \ == 1 ) */\n+\n+        BaseType_t xPortIsAuthorizedToAccessKernelObject( int32_t\
    \ lInternalIndexOfKernelObject ) /* PRIVILEGED_FUNCTION */\n+        {\n+    \
    \        ( void ) lInternalIndexOfKernelObject;\n+\n+            /* If Access\
    \ Control List feature is not used, all the tasks have\n+             * access\
    \ to all the kernel objects. */\n+            return pdTRUE;\n+        }\n+\n\
    +    #endif /* #if ( configENABLE_ACCESS_CONTROL_LIST == 1 ) */\n+\n+#endif /*\
    \ #if ( configUSE_MPU_WRAPPERS_V1 == 0 ) */\n+/*-----------------------------------------------------------*/"
  - "--- a/portable/IAR/ARM_CM55/non_secure/port.c\n+++ b/portable/IAR/ARM_CM55/non_secure/port.c\n\
    @@ -472,6 +472,15 @@ portDONT_DISCARD void vPortSVCHandler_C( uint32_t * pulCallerStackAddress\
    \ ) PRIV\n #endif /* configENABLE_MPU == 1 */\n /*-----------------------------------------------------------*/\n\
    \ \n+#if ( ( configENABLE_MPU == 1 ) && ( configUSE_MPU_WRAPPERS_V1 == 0 ) &&\
    \ ( configENABLE_ACCESS_CONTROL_LIST == 1 ) )\n+\n+/**\n+ * @brief This variable\
    \ is set to pdTRUE when the scheduler is started.\n+ */\n+    PRIVILEGED_DATA\
    \ static BaseType_t xSchedulerRunning = pdFALSE;\n+\n+#endif\n+\n /**\n  * @brief\
    \ Each task maintains its own interrupt status in the critical nesting\n  * variable.\n\
    @@ -1651,6 +1660,12 @@ BaseType_t xPortStartScheduler( void ) /* PRIVILEGED_FUNCTION\
    \ */\n     /* Initialize the critical nesting count ready for the first task.\
    \ */\n     ulCriticalNesting = 0;\n \n+    #if ( ( configENABLE_MPU == 1 ) &&\
    \ ( configUSE_MPU_WRAPPERS_V1 == 0 ) && ( configENABLE_ACCESS_CONTROL_LIST ==\
    \ 1 ) )\n+    {\n+        xSchedulerRunning = pdTRUE;\n+    }\n+    #endif\n+\n\
    \     /* Start the first task. */\n     vStartFirstTask();\n \n@@ -1931,3 +1946,98\
    \ @@ BaseType_t xPortIsInsideInterrupt( void )\n \n #endif /* #if ( ( configASSERT_DEFINED\
    \ == 1 ) && ( portHAS_BASEPRI == 1 ) ) */\n /*-----------------------------------------------------------*/\n\
    +\n+#if ( ( configENABLE_MPU == 1 ) && ( configUSE_MPU_WRAPPERS_V1 == 0 ) && (\
    \ configENABLE_ACCESS_CONTROL_LIST == 1 ) )\n+\n+    void vPortGrantAccessToKernelObject(\
    \ TaskHandle_t xInternalTaskHandle,\n+                                       \
    \  int32_t lInternalIndexOfKernelObject ) /* PRIVILEGED_FUNCTION */\n+    {\n\
    +        uint32_t ulAccessControlListEntryIndex, ulAccessControlListEntryBit;\n\
    +        xMPU_SETTINGS * xTaskMpuSettings;\n+\n+        ulAccessControlListEntryIndex\
    \ = ( ( uint32_t ) lInternalIndexOfKernelObject / portACL_ENTRY_SIZE_BITS );\n\
    +        ulAccessControlListEntryBit = ( ( uint32_t ) lInternalIndexOfKernelObject\
    \ % portACL_ENTRY_SIZE_BITS );\n+\n+        xTaskMpuSettings = xTaskGetMPUSettings(\
    \ xInternalTaskHandle );\n+\n+        xTaskMpuSettings->ulAccessControlList[ ulAccessControlListEntryIndex\
    \ ] |= ( 1U << ulAccessControlListEntryBit );\n+    }\n+\n+#endif /* #if ( ( configENABLE_MPU\
    \ == 1 ) && ( configUSE_MPU_WRAPPERS_V1 == 0 ) && ( configENABLE_ACCESS_CONTROL_LIST\
    \ == 1 ) ) */\n+/*-----------------------------------------------------------*/\n\
    +\n+#if ( ( configENABLE_MPU == 1 ) && ( configUSE_MPU_WRAPPERS_V1 == 0 ) && (\
    \ configENABLE_ACCESS_CONTROL_LIST == 1 ) )\n+\n+    void vPortRevokeAccessToKernelObject(\
    \ TaskHandle_t xInternalTaskHandle,\n+                                       \
    \   int32_t lInternalIndexOfKernelObject ) /* PRIVILEGED_FUNCTION */\n+    {\n\
    +        uint32_t ulAccessControlListEntryIndex, ulAccessControlListEntryBit;\n\
    +        xMPU_SETTINGS * xTaskMpuSettings;\n+\n+        ulAccessControlListEntryIndex\
    \ = ( ( uint32_t ) lInternalIndexOfKernelObject / portACL_ENTRY_SIZE_BITS );\n\
    +        ulAccessControlListEntryBit = ( ( uint32_t ) lInternalIndexOfKernelObject\
    \ % portACL_ENTRY_SIZE_BITS );\n+\n+        xTaskMpuSettings = xTaskGetMPUSettings(\
    \ xInternalTaskHandle );\n+\n+        xTaskMpuSettings->ulAccessControlList[ ulAccessControlListEntryIndex\
    \ ] &= ~( 1U << ulAccessControlListEntryBit );\n+    }\n+\n+#endif /* #if ( (\
    \ configENABLE_MPU == 1 ) && ( configUSE_MPU_WRAPPERS_V1 == 0 ) && ( configENABLE_ACCESS_CONTROL_LIST\
    \ == 1 ) ) */\n+/*-----------------------------------------------------------*/\n\
    +\n+#if ( ( configENABLE_MPU == 1 ) && ( configUSE_MPU_WRAPPERS_V1 == 0 ) )\n\
    +\n+    #if ( configENABLE_ACCESS_CONTROL_LIST == 1 )\n+\n+        BaseType_t\
    \ xPortIsAuthorizedToAccessKernelObject( int32_t lInternalIndexOfKernelObject\
    \ ) /* PRIVILEGED_FUNCTION */\n+        {\n+            uint32_t ulAccessControlListEntryIndex,\
    \ ulAccessControlListEntryBit;\n+            BaseType_t xAccessGranted = pdFALSE;\n\
    +            const xMPU_SETTINGS * xTaskMpuSettings;\n+\n+            if( xSchedulerRunning\
    \ == pdFALSE )\n+            {\n+                /* Grant access to all the kernel\
    \ objects before the scheduler\n+                 * is started. It is necessary\
    \ because there is no task running\n+                 * yet and therefore, we\
    \ cannot use the permissions of any\n+                 * task. */\n+         \
    \       xAccessGranted = pdTRUE;\n+            }\n+            else\n+       \
    \     {\n+                xTaskMpuSettings = xTaskGetMPUSettings( NULL ); /* Calling\
    \ task's MPU settings. */\n+\n+                ulAccessControlListEntryIndex =\
    \ ( ( uint32_t ) lInternalIndexOfKernelObject / portACL_ENTRY_SIZE_BITS );\n+\
    \                ulAccessControlListEntryBit = ( ( uint32_t ) lInternalIndexOfKernelObject\
    \ % portACL_ENTRY_SIZE_BITS );\n+\n+                if( ( xTaskMpuSettings->ulTaskFlags\
    \ & portTASK_IS_PRIVILEGED_FLAG ) == portTASK_IS_PRIVILEGED_FLAG )\n+        \
    \        {\n+                    xAccessGranted = pdTRUE;\n+                }\n\
    +                else\n+                {\n+                    if( ( xTaskMpuSettings->ulAccessControlList[\
    \ ulAccessControlListEntryIndex ] & ( 1U << ulAccessControlListEntryBit ) ) !=\
    \ 0 )\n+                    {\n+                        xAccessGranted = pdTRUE;\n\
    +                    }\n+                }\n+            }\n+\n+            return\
    \ xAccessGranted;\n+        }\n+\n+    #else /* #if ( configENABLE_ACCESS_CONTROL_LIST\
    \ == 1 ) */\n+\n+        BaseType_t xPortIsAuthorizedToAccessKernelObject( int32_t\
    \ lInternalIndexOfKernelObject ) /* PRIVILEGED_FUNCTION */\n+        {\n+    \
    \        ( void ) lInternalIndexOfKernelObject;\n+\n+            /* If Access\
    \ Control List feature is not used, all the tasks have\n+             * access\
    \ to all the kernel objects. */\n+            return pdTRUE;\n+        }\n+\n\
    +    #endif /* #if ( configENABLE_ACCESS_CONTROL_LIST == 1 ) */\n+\n+#endif /*\
    \ #if ( ( configENABLE_MPU == 1 ) && ( configUSE_MPU_WRAPPERS_V1 == 0 ) ) */\n\
    +/*-----------------------------------------------------------*/"
  - "--- a/portable/IAR/ARM_CM55_NTZ/non_secure/port.c\n+++ b/portable/IAR/ARM_CM55_NTZ/non_secure/port.c\n\
    @@ -472,6 +472,15 @@ portDONT_DISCARD void vPortSVCHandler_C( uint32_t * pulCallerStackAddress\
    \ ) PRIV\n #endif /* configENABLE_MPU == 1 */\n /*-----------------------------------------------------------*/\n\
    \ \n+#if ( ( configENABLE_MPU == 1 ) && ( configUSE_MPU_WRAPPERS_V1 == 0 ) &&\
    \ ( configENABLE_ACCESS_CONTROL_LIST == 1 ) )\n+\n+/**\n+ * @brief This variable\
    \ is set to pdTRUE when the scheduler is started.\n+ */\n+    PRIVILEGED_DATA\
    \ static BaseType_t xSchedulerRunning = pdFALSE;\n+\n+#endif\n+\n /**\n  * @brief\
    \ Each task maintains its own interrupt status in the critical nesting\n  * variable.\n\
    @@ -1651,6 +1660,12 @@ BaseType_t xPortStartScheduler( void ) /* PRIVILEGED_FUNCTION\
    \ */\n     /* Initialize the critical nesting count ready for the first task.\
    \ */\n     ulCriticalNesting = 0;\n \n+    #if ( ( configENABLE_MPU == 1 ) &&\
    \ ( configUSE_MPU_WRAPPERS_V1 == 0 ) && ( configENABLE_ACCESS_CONTROL_LIST ==\
    \ 1 ) )\n+    {\n+        xSchedulerRunning = pdTRUE;\n+    }\n+    #endif\n+\n\
    \     /* Start the first task. */\n     vStartFirstTask();\n \n@@ -1931,3 +1946,98\
    \ @@ BaseType_t xPortIsInsideInterrupt( void )\n \n #endif /* #if ( ( configASSERT_DEFINED\
    \ == 1 ) && ( portHAS_BASEPRI == 1 ) ) */\n /*-----------------------------------------------------------*/\n\
    +\n+#if ( ( configENABLE_MPU == 1 ) && ( configUSE_MPU_WRAPPERS_V1 == 0 ) && (\
    \ configENABLE_ACCESS_CONTROL_LIST == 1 ) )\n+\n+    void vPortGrantAccessToKernelObject(\
    \ TaskHandle_t xInternalTaskHandle,\n+                                       \
    \  int32_t lInternalIndexOfKernelObject ) /* PRIVILEGED_FUNCTION */\n+    {\n\
    +        uint32_t ulAccessControlListEntryIndex, ulAccessControlListEntryBit;\n\
    +        xMPU_SETTINGS * xTaskMpuSettings;\n+\n+        ulAccessControlListEntryIndex\
    \ = ( ( uint32_t ) lInternalIndexOfKernelObject / portACL_ENTRY_SIZE_BITS );\n\
    +        ulAccessControlListEntryBit = ( ( uint32_t ) lInternalIndexOfKernelObject\
    \ % portACL_ENTRY_SIZE_BITS );\n+\n+        xTaskMpuSettings = xTaskGetMPUSettings(\
    \ xInternalTaskHandle );\n+\n+        xTaskMpuSettings->ulAccessControlList[ ulAccessControlListEntryIndex\
    \ ] |= ( 1U << ulAccessControlListEntryBit );\n+    }\n+\n+#endif /* #if ( ( configENABLE_MPU\
    \ == 1 ) && ( configUSE_MPU_WRAPPERS_V1 == 0 ) && ( configENABLE_ACCESS_CONTROL_LIST\
    \ == 1 ) ) */\n+/*-----------------------------------------------------------*/\n\
    +\n+#if ( ( configENABLE_MPU == 1 ) && ( configUSE_MPU_WRAPPERS_V1 == 0 ) && (\
    \ configENABLE_ACCESS_CONTROL_LIST == 1 ) )\n+\n+    void vPortRevokeAccessToKernelObject(\
    \ TaskHandle_t xInternalTaskHandle,\n+                                       \
    \   int32_t lInternalIndexOfKernelObject ) /* PRIVILEGED_FUNCTION */\n+    {\n\
    +        uint32_t ulAccessControlListEntryIndex, ulAccessControlListEntryBit;\n\
    +        xMPU_SETTINGS * xTaskMpuSettings;\n+\n+        ulAccessControlListEntryIndex\
    \ = ( ( uint32_t ) lInternalIndexOfKernelObject / portACL_ENTRY_SIZE_BITS );\n\
    +        ulAccessControlListEntryBit = ( ( uint32_t ) lInternalIndexOfKernelObject\
    \ % portACL_ENTRY_SIZE_BITS );\n+\n+        xTaskMpuSettings = xTaskGetMPUSettings(\
    \ xInternalTaskHandle );\n+\n+        xTaskMpuSettings->ulAccessControlList[ ulAccessControlListEntryIndex\
    \ ] &= ~( 1U << ulAccessControlListEntryBit );\n+    }\n+\n+#endif /* #if ( (\
    \ configENABLE_MPU == 1 ) && ( configUSE_MPU_WRAPPERS_V1 == 0 ) && ( configENABLE_ACCESS_CONTROL_LIST\
    \ == 1 ) ) */\n+/*-----------------------------------------------------------*/\n\
    +\n+#if ( ( configENABLE_MPU == 1 ) && ( configUSE_MPU_WRAPPERS_V1 == 0 ) )\n\
    +\n+    #if ( configENABLE_ACCESS_CONTROL_LIST == 1 )\n+\n+        BaseType_t\
    \ xPortIsAuthorizedToAccessKernelObject( int32_t lInternalIndexOfKernelObject\
    \ ) /* PRIVILEGED_FUNCTION */\n+        {\n+            uint32_t ulAccessControlListEntryIndex,\
    \ ulAccessControlListEntryBit;\n+            BaseType_t xAccessGranted = pdFALSE;\n\
    +            const xMPU_SETTINGS * xTaskMpuSettings;\n+\n+            if( xSchedulerRunning\
    \ == pdFALSE )\n+            {\n+                /* Grant access to all the kernel\
    \ objects before the scheduler\n+                 * is started. It is necessary\
    \ because there is no task running\n+                 * yet and therefore, we\
    \ cannot use the permissions of any\n+                 * task. */\n+         \
    \       xAccessGranted = pdTRUE;\n+            }\n+            else\n+       \
    \     {\n+                xTaskMpuSettings = xTaskGetMPUSettings( NULL ); /* Calling\
    \ task's MPU settings. */\n+\n+                ulAccessControlListEntryIndex =\
    \ ( ( uint32_t ) lInternalIndexOfKernelObject / portACL_ENTRY_SIZE_BITS );\n+\
    \                ulAccessControlListEntryBit = ( ( uint32_t ) lInternalIndexOfKernelObject\
    \ % portACL_ENTRY_SIZE_BITS );\n+\n+                if( ( xTaskMpuSettings->ulTaskFlags\
    \ & portTASK_IS_PRIVILEGED_FLAG ) == portTASK_IS_PRIVILEGED_FLAG )\n+        \
    \        {\n+                    xAccessGranted = pdTRUE;\n+                }\n\
    +                else\n+                {\n+                    if( ( xTaskMpuSettings->ulAccessControlList[\
    \ ulAccessControlListEntryIndex ] & ( 1U << ulAccessControlListEntryBit ) ) !=\
    \ 0 )\n+                    {\n+                        xAccessGranted = pdTRUE;\n\
    +                    }\n+                }\n+            }\n+\n+            return\
    \ xAccessGranted;\n+        }\n+\n+    #else /* #if ( configENABLE_ACCESS_CONTROL_LIST\
    \ == 1 ) */\n+\n+        BaseType_t xPortIsAuthorizedToAccessKernelObject( int32_t\
    \ lInternalIndexOfKernelObject ) /* PRIVILEGED_FUNCTION */\n+        {\n+    \
    \        ( void ) lInternalIndexOfKernelObject;\n+\n+            /* If Access\
    \ Control List feature is not used, all the tasks have\n+             * access\
    \ to all the kernel objects. */\n+            return pdTRUE;\n+        }\n+\n\
    +    #endif /* #if ( configENABLE_ACCESS_CONTROL_LIST == 1 ) */\n+\n+#endif /*\
    \ #if ( ( configENABLE_MPU == 1 ) && ( configUSE_MPU_WRAPPERS_V1 == 0 ) ) */\n\
    +/*-----------------------------------------------------------*/"
  - "--- a/portable/IAR/ARM_CM85/non_secure/port.c\n+++ b/portable/IAR/ARM_CM85/non_secure/port.c\n\
    @@ -472,6 +472,15 @@ portDONT_DISCARD void vPortSVCHandler_C( uint32_t * pulCallerStackAddress\
    \ ) PRIV\n #endif /* configENABLE_MPU == 1 */\n /*-----------------------------------------------------------*/\n\
    \ \n+#if ( ( configENABLE_MPU == 1 ) && ( configUSE_MPU_WRAPPERS_V1 == 0 ) &&\
    \ ( configENABLE_ACCESS_CONTROL_LIST == 1 ) )\n+\n+/**\n+ * @brief This variable\
    \ is set to pdTRUE when the scheduler is started.\n+ */\n+    PRIVILEGED_DATA\
    \ static BaseType_t xSchedulerRunning = pdFALSE;\n+\n+#endif\n+\n /**\n  * @brief\
    \ Each task maintains its own interrupt status in the critical nesting\n  * variable.\n\
    @@ -1651,6 +1660,12 @@ BaseType_t xPortStartScheduler( void ) /* PRIVILEGED_FUNCTION\
    \ */\n     /* Initialize the critical nesting count ready for the first task.\
    \ */\n     ulCriticalNesting = 0;\n \n+    #if ( ( configENABLE_MPU == 1 ) &&\
    \ ( configUSE_MPU_WRAPPERS_V1 == 0 ) && ( configENABLE_ACCESS_CONTROL_LIST ==\
    \ 1 ) )\n+    {\n+        xSchedulerRunning = pdTRUE;\n+    }\n+    #endif\n+\n\
    \     /* Start the first task. */\n     vStartFirstTask();\n \n@@ -1931,3 +1946,98\
    \ @@ BaseType_t xPortIsInsideInterrupt( void )\n \n #endif /* #if ( ( configASSERT_DEFINED\
    \ == 1 ) && ( portHAS_BASEPRI == 1 ) ) */\n /*-----------------------------------------------------------*/\n\
    +\n+#if ( ( configENABLE_MPU == 1 ) && ( configUSE_MPU_WRAPPERS_V1 == 0 ) && (\
    \ configENABLE_ACCESS_CONTROL_LIST == 1 ) )\n+\n+    void vPortGrantAccessToKernelObject(\
    \ TaskHandle_t xInternalTaskHandle,\n+                                       \
    \  int32_t lInternalIndexOfKernelObject ) /* PRIVILEGED_FUNCTION */\n+    {\n\
    +        uint32_t ulAccessControlListEntryIndex, ulAccessControlListEntryBit;\n\
    +        xMPU_SETTINGS * xTaskMpuSettings;\n+\n+        ulAccessControlListEntryIndex\
    \ = ( ( uint32_t ) lInternalIndexOfKernelObject / portACL_ENTRY_SIZE_BITS );\n\
    +        ulAccessControlListEntryBit = ( ( uint32_t ) lInternalIndexOfKernelObject\
    \ % portACL_ENTRY_SIZE_BITS );\n+\n+        xTaskMpuSettings = xTaskGetMPUSettings(\
    \ xInternalTaskHandle );\n+\n+        xTaskMpuSettings->ulAccessControlList[ ulAccessControlListEntryIndex\
    \ ] |= ( 1U << ulAccessControlListEntryBit );\n+    }\n+\n+#endif /* #if ( ( configENABLE_MPU\
    \ == 1 ) && ( configUSE_MPU_WRAPPERS_V1 == 0 ) && ( configENABLE_ACCESS_CONTROL_LIST\
    \ == 1 ) ) */\n+/*-----------------------------------------------------------*/\n\
    +\n+#if ( ( configENABLE_MPU == 1 ) && ( configUSE_MPU_WRAPPERS_V1 == 0 ) && (\
    \ configENABLE_ACCESS_CONTROL_LIST == 1 ) )\n+\n+    void vPortRevokeAccessToKernelObject(\
    \ TaskHandle_t xInternalTaskHandle,\n+                                       \
    \   int32_t lInternalIndexOfKernelObject ) /* PRIVILEGED_FUNCTION */\n+    {\n\
    +        uint32_t ulAccessControlListEntryIndex, ulAccessControlListEntryBit;\n\
    +        xMPU_SETTINGS * xTaskMpuSettings;\n+\n+        ulAccessControlListEntryIndex\
    \ = ( ( uint32_t ) lInternalIndexOfKernelObject / portACL_ENTRY_SIZE_BITS );\n\
    +        ulAccessControlListEntryBit = ( ( uint32_t ) lInternalIndexOfKernelObject\
    \ % portACL_ENTRY_SIZE_BITS );\n+\n+        xTaskMpuSettings = xTaskGetMPUSettings(\
    \ xInternalTaskHandle );\n+\n+        xTaskMpuSettings->ulAccessControlList[ ulAccessControlListEntryIndex\
    \ ] &= ~( 1U << ulAccessControlListEntryBit );\n+    }\n+\n+#endif /* #if ( (\
    \ configENABLE_MPU == 1 ) && ( configUSE_MPU_WRAPPERS_V1 == 0 ) && ( configENABLE_ACCESS_CONTROL_LIST\
    \ == 1 ) ) */\n+/*-----------------------------------------------------------*/\n\
    +\n+#if ( ( configENABLE_MPU == 1 ) && ( configUSE_MPU_WRAPPERS_V1 == 0 ) )\n\
    +\n+    #if ( configENABLE_ACCESS_CONTROL_LIST == 1 )\n+\n+        BaseType_t\
    \ xPortIsAuthorizedToAccessKernelObject( int32_t lInternalIndexOfKernelObject\
    \ ) /* PRIVILEGED_FUNCTION */\n+        {\n+            uint32_t ulAccessControlListEntryIndex,\
    \ ulAccessControlListEntryBit;\n+            BaseType_t xAccessGranted = pdFALSE;\n\
    +            const xMPU_SETTINGS * xTaskMpuSettings;\n+\n+            if( xSchedulerRunning\
    \ == pdFALSE )\n+            {\n+                /* Grant access to all the kernel\
    \ objects before the scheduler\n+                 * is started. It is necessary\
    \ because there is no task running\n+                 * yet and therefore, we\
    \ cannot use the permissions of any\n+                 * task. */\n+         \
    \       xAccessGranted = pdTRUE;\n+            }\n+            else\n+       \
    \     {\n+                xTaskMpuSettings = xTaskGetMPUSettings( NULL ); /* Calling\
    \ task's MPU settings. */\n+\n+                ulAccessControlListEntryIndex =\
    \ ( ( uint32_t ) lInternalIndexOfKernelObject / portACL_ENTRY_SIZE_BITS );\n+\
    \                ulAccessControlListEntryBit = ( ( uint32_t ) lInternalIndexOfKernelObject\
    \ % portACL_ENTRY_SIZE_BITS );\n+\n+                if( ( xTaskMpuSettings->ulTaskFlags\
    \ & portTASK_IS_PRIVILEGED_FLAG ) == portTASK_IS_PRIVILEGED_FLAG )\n+        \
    \        {\n+                    xAccessGranted = pdTRUE;\n+                }\n\
    +                else\n+                {\n+                    if( ( xTaskMpuSettings->ulAccessControlList[\
    \ ulAccessControlListEntryIndex ] & ( 1U << ulAccessControlListEntryBit ) ) !=\
    \ 0 )\n+                    {\n+                        xAccessGranted = pdTRUE;\n\
    +                    }\n+                }\n+            }\n+\n+            return\
    \ xAccessGranted;\n+        }\n+\n+    #else /* #if ( configENABLE_ACCESS_CONTROL_LIST\
    \ == 1 ) */\n+\n+        BaseType_t xPortIsAuthorizedToAccessKernelObject( int32_t\
    \ lInternalIndexOfKernelObject ) /* PRIVILEGED_FUNCTION */\n+        {\n+    \
    \        ( void ) lInternalIndexOfKernelObject;\n+\n+            /* If Access\
    \ Control List feature is not used, all the tasks have\n+             * access\
    \ to all the kernel objects. */\n+            return pdTRUE;\n+        }\n+\n\
    +    #endif /* #if ( configENABLE_ACCESS_CONTROL_LIST == 1 ) */\n+\n+#endif /*\
    \ #if ( ( configENABLE_MPU == 1 ) && ( configUSE_MPU_WRAPPERS_V1 == 0 ) ) */\n\
    +/*-----------------------------------------------------------*/"
  - "--- a/portable/IAR/ARM_CM85_NTZ/non_secure/port.c\n+++ b/portable/IAR/ARM_CM85_NTZ/non_secure/port.c\n\
    @@ -472,6 +472,15 @@ portDONT_DISCARD void vPortSVCHandler_C( uint32_t * pulCallerStackAddress\
    \ ) PRIV\n #endif /* configENABLE_MPU == 1 */\n /*-----------------------------------------------------------*/\n\
    \ \n+#if ( ( configENABLE_MPU == 1 ) && ( configUSE_MPU_WRAPPERS_V1 == 0 ) &&\
    \ ( configENABLE_ACCESS_CONTROL_LIST == 1 ) )\n+\n+/**\n+ * @brief This variable\
    \ is set to pdTRUE when the scheduler is started.\n+ */\n+    PRIVILEGED_DATA\
    \ static BaseType_t xSchedulerRunning = pdFALSE;\n+\n+#endif\n+\n /**\n  * @brief\
    \ Each task maintains its own interrupt status in the critical nesting\n  * variable.\n\
    @@ -1651,6 +1660,12 @@ BaseType_t xPortStartScheduler( void ) /* PRIVILEGED_FUNCTION\
    \ */\n     /* Initialize the critical nesting count ready for the first task.\
    \ */\n     ulCriticalNesting = 0;\n \n+    #if ( ( configENABLE_MPU == 1 ) &&\
    \ ( configUSE_MPU_WRAPPERS_V1 == 0 ) && ( configENABLE_ACCESS_CONTROL_LIST ==\
    \ 1 ) )\n+    {\n+        xSchedulerRunning = pdTRUE;\n+    }\n+    #endif\n+\n\
    \     /* Start the first task. */\n     vStartFirstTask();\n \n@@ -1931,3 +1946,98\
    \ @@ BaseType_t xPortIsInsideInterrupt( void )\n \n #endif /* #if ( ( configASSERT_DEFINED\
    \ == 1 ) && ( portHAS_BASEPRI == 1 ) ) */\n /*-----------------------------------------------------------*/\n\
    +\n+#if ( ( configENABLE_MPU == 1 ) && ( configUSE_MPU_WRAPPERS_V1 == 0 ) && (\
    \ configENABLE_ACCESS_CONTROL_LIST == 1 ) )\n+\n+    void vPortGrantAccessToKernelObject(\
    \ TaskHandle_t xInternalTaskHandle,\n+                                       \
    \  int32_t lInternalIndexOfKernelObject ) /* PRIVILEGED_FUNCTION */\n+    {\n\
    +        uint32_t ulAccessControlListEntryIndex, ulAccessControlListEntryBit;\n\
    +        xMPU_SETTINGS * xTaskMpuSettings;\n+\n+        ulAccessControlListEntryIndex\
    \ = ( ( uint32_t ) lInternalIndexOfKernelObject / portACL_ENTRY_SIZE_BITS );\n\
    +        ulAccessControlListEntryBit = ( ( uint32_t ) lInternalIndexOfKernelObject\
    \ % portACL_ENTRY_SIZE_BITS );\n+\n+        xTaskMpuSettings = xTaskGetMPUSettings(\
    \ xInternalTaskHandle );\n+\n+        xTaskMpuSettings->ulAccessControlList[ ulAccessControlListEntryIndex\
    \ ] |= ( 1U << ulAccessControlListEntryBit );\n+    }\n+\n+#endif /* #if ( ( configENABLE_MPU\
    \ == 1 ) && ( configUSE_MPU_WRAPPERS_V1 == 0 ) && ( configENABLE_ACCESS_CONTROL_LIST\
    \ == 1 ) ) */\n+/*-----------------------------------------------------------*/\n\
    +\n+#if ( ( configENABLE_MPU == 1 ) && ( configUSE_MPU_WRAPPERS_V1 == 0 ) && (\
    \ configENABLE_ACCESS_CONTROL_LIST == 1 ) )\n+\n+    void vPortRevokeAccessToKernelObject(\
    \ TaskHandle_t xInternalTaskHandle,\n+                                       \
    \   int32_t lInternalIndexOfKernelObject ) /* PRIVILEGED_FUNCTION */\n+    {\n\
    +        uint32_t ulAccessControlListEntryIndex, ulAccessControlListEntryBit;\n\
    +        xMPU_SETTINGS * xTaskMpuSettings;\n+\n+        ulAccessControlListEntryIndex\
    \ = ( ( uint32_t ) lInternalIndexOfKernelObject / portACL_ENTRY_SIZE_BITS );\n\
    +        ulAccessControlListEntryBit = ( ( uint32_t ) lInternalIndexOfKernelObject\
    \ % portACL_ENTRY_SIZE_BITS );\n+\n+        xTaskMpuSettings = xTaskGetMPUSettings(\
    \ xInternalTaskHandle );\n+\n+        xTaskMpuSettings->ulAccessControlList[ ulAccessControlListEntryIndex\
    \ ] &= ~( 1U << ulAccessControlListEntryBit );\n+    }\n+\n+#endif /* #if ( (\
    \ configENABLE_MPU == 1 ) && ( configUSE_MPU_WRAPPERS_V1 == 0 ) && ( configENABLE_ACCESS_CONTROL_LIST\
    \ == 1 ) ) */\n+/*-----------------------------------------------------------*/\n\
    +\n+#if ( ( configENABLE_MPU == 1 ) && ( configUSE_MPU_WRAPPERS_V1 == 0 ) )\n\
    +\n+    #if ( configENABLE_ACCESS_CONTROL_LIST == 1 )\n+\n+        BaseType_t\
    \ xPortIsAuthorizedToAccessKernelObject( int32_t lInternalIndexOfKernelObject\
    \ ) /* PRIVILEGED_FUNCTION */\n+        {\n+            uint32_t ulAccessControlListEntryIndex,\
    \ ulAccessControlListEntryBit;\n+            BaseType_t xAccessGranted = pdFALSE;\n\
    +            const xMPU_SETTINGS * xTaskMpuSettings;\n+\n+            if( xSchedulerRunning\
    \ == pdFALSE )\n+            {\n+                /* Grant access to all the kernel\
    \ objects before the scheduler\n+                 * is started. It is necessary\
    \ because there is no task running\n+                 * yet and therefore, we\
    \ cannot use the permissions of any\n+                 * task. */\n+         \
    \       xAccessGranted = pdTRUE;\n+            }\n+            else\n+       \
    \     {\n+                xTaskMpuSettings = xTaskGetMPUSettings( NULL ); /* Calling\
    \ task's MPU settings. */\n+\n+                ulAccessControlListEntryIndex =\
    \ ( ( uint32_t ) lInternalIndexOfKernelObject / portACL_ENTRY_SIZE_BITS );\n+\
    \                ulAccessControlListEntryBit = ( ( uint32_t ) lInternalIndexOfKernelObject\
    \ % portACL_ENTRY_SIZE_BITS );\n+\n+                if( ( xTaskMpuSettings->ulTaskFlags\
    \ & portTASK_IS_PRIVILEGED_FLAG ) == portTASK_IS_PRIVILEGED_FLAG )\n+        \
    \        {\n+                    xAccessGranted = pdTRUE;\n+                }\n\
    +                else\n+                {\n+                    if( ( xTaskMpuSettings->ulAccessControlList[\
    \ ulAccessControlListEntryIndex ] & ( 1U << ulAccessControlListEntryBit ) ) !=\
    \ 0 )\n+                    {\n+                        xAccessGranted = pdTRUE;\n\
    +                    }\n+                }\n+            }\n+\n+            return\
    \ xAccessGranted;\n+        }\n+\n+    #else /* #if ( configENABLE_ACCESS_CONTROL_LIST\
    \ == 1 ) */\n+\n+        BaseType_t xPortIsAuthorizedToAccessKernelObject( int32_t\
    \ lInternalIndexOfKernelObject ) /* PRIVILEGED_FUNCTION */\n+        {\n+    \
    \        ( void ) lInternalIndexOfKernelObject;\n+\n+            /* If Access\
    \ Control List feature is not used, all the tasks have\n+             * access\
    \ to all the kernel objects. */\n+            return pdTRUE;\n+        }\n+\n\
    +    #endif /* #if ( configENABLE_ACCESS_CONTROL_LIST == 1 ) */\n+\n+#endif /*\
    \ #if ( ( configENABLE_MPU == 1 ) && ( configUSE_MPU_WRAPPERS_V1 == 0 ) ) */\n\
    +/*-----------------------------------------------------------*/"
  - "--- a/portable/RVDS/ARM_CM4_MPU/port.c\n+++ b/portable/RVDS/ARM_CM4_MPU/port.c\n\
    @@ -140,7 +140,16 @@\n /* Each task maintains its own interrupt status in the\
    \ critical nesting\n  * variable.  Note this is not saved as part of the task\
    \ context as context\n  * switches can only occur when uxCriticalNesting is zero.\
    \ */\n-static UBaseType_t uxCriticalNesting = 0xaaaaaaaa;\n+PRIVILEGED_DATA static\
    \ UBaseType_t uxCriticalNesting = 0xaaaaaaaa;\n+\n+#if ( ( configUSE_MPU_WRAPPERS_V1\
    \ == 0 ) && ( configENABLE_ACCESS_CONTROL_LIST == 1 ) )\n+\n+/*\n+ * This variable\
    \ is set to pdTRUE when the scheduler is started.\n+ */\n+    PRIVILEGED_DATA\
    \ static BaseType_t xSchedulerRunning = pdFALSE;\n+\n+#endif\n \n /*\n  * Setup\
    \ the timer to generate the tick interrupts.\n@@ -905,6 +914,12 @@ BaseType_t\
    \ xPortStartScheduler( void )\n     /* Initialise the critical nesting count ready\
    \ for the first task. */\n     uxCriticalNesting = 0;\n \n+    #if ( ( configUSE_MPU_WRAPPERS_V1\
    \ == 0 ) && ( configENABLE_ACCESS_CONTROL_LIST == 1 ) )\n+    {\n+        xSchedulerRunning\
    \ = pdTRUE;\n+    }\n+    #endif\n+\n     /* Ensure the VFP is enabled - it should\
    \ be anyway. */\n     vPortEnableVFP();\n \n@@ -1539,3 +1554,99 @@ __asm uint32_t\
    \ prvPortGetIPSR( void )\n     }\n \n #endif /* configASSERT_DEFINED */\n+/*-----------------------------------------------------------*/\n\
    +\n+#if ( ( configUSE_MPU_WRAPPERS_V1 == 0 ) && ( configENABLE_ACCESS_CONTROL_LIST\
    \ == 1 ) )\n+\n+    void vPortGrantAccessToKernelObject( TaskHandle_t xInternalTaskHandle,\n\
    +                                         int32_t lInternalIndexOfKernelObject\
    \ ) /* PRIVILEGED_FUNCTION */\n+    {\n+        uint32_t ulAccessControlListEntryIndex,\
    \ ulAccessControlListEntryBit;\n+        xMPU_SETTINGS * xTaskMpuSettings;\n+\n\
    +        ulAccessControlListEntryIndex = ( ( uint32_t ) lInternalIndexOfKernelObject\
    \ / portACL_ENTRY_SIZE_BITS );\n+        ulAccessControlListEntryBit = ( ( uint32_t\
    \ ) lInternalIndexOfKernelObject % portACL_ENTRY_SIZE_BITS );\n+\n+        xTaskMpuSettings\
    \ = xTaskGetMPUSettings( xInternalTaskHandle );\n+\n+        xTaskMpuSettings->ulAccessControlList[\
    \ ulAccessControlListEntryIndex ] |= ( 1U << ulAccessControlListEntryBit );\n\
    +    }\n+\n+#endif /* #if ( ( configUSE_MPU_WRAPPERS_V1 == 0 ) && ( configENABLE_ACCESS_CONTROL_LIST\
    \ == 1 ) ) */\n+/*-----------------------------------------------------------*/\n\
    +\n+#if ( ( configUSE_MPU_WRAPPERS_V1 == 0 ) && ( configENABLE_ACCESS_CONTROL_LIST\
    \ == 1 ) )\n+\n+    void vPortRevokeAccessToKernelObject( TaskHandle_t xInternalTaskHandle,\n\
    +                                          int32_t lInternalIndexOfKernelObject\
    \ ) /* PRIVILEGED_FUNCTION */\n+    {\n+        uint32_t ulAccessControlListEntryIndex,\
    \ ulAccessControlListEntryBit;\n+        xMPU_SETTINGS * xTaskMpuSettings;\n+\n\
    +        ulAccessControlListEntryIndex = ( ( uint32_t ) lInternalIndexOfKernelObject\
    \ / portACL_ENTRY_SIZE_BITS );\n+        ulAccessControlListEntryBit = ( ( uint32_t\
    \ ) lInternalIndexOfKernelObject % portACL_ENTRY_SIZE_BITS );\n+\n+        xTaskMpuSettings\
    \ = xTaskGetMPUSettings( xInternalTaskHandle );\n+\n+        xTaskMpuSettings->ulAccessControlList[\
    \ ulAccessControlListEntryIndex ] &= ~( 1U << ulAccessControlListEntryBit );\n\
    +    }\n+\n+#endif /* #if ( ( configUSE_MPU_WRAPPERS_V1 == 0 ) && ( configENABLE_ACCESS_CONTROL_LIST\
    \ == 1 ) ) */\n+/*-----------------------------------------------------------*/\n\
    +\n+#if ( configUSE_MPU_WRAPPERS_V1 == 0 )\n+\n+    #if ( configENABLE_ACCESS_CONTROL_LIST\
    \ == 1 )\n+\n+        BaseType_t xPortIsAuthorizedToAccessKernelObject( int32_t\
    \ lInternalIndexOfKernelObject ) /* PRIVILEGED_FUNCTION */\n+        {\n+    \
    \        uint32_t ulAccessControlListEntryIndex, ulAccessControlListEntryBit;\n\
    +            BaseType_t xAccessGranted = pdFALSE;\n+            const xMPU_SETTINGS\
    \ * xTaskMpuSettings;\n+\n+            if( xSchedulerRunning == pdFALSE )\n+ \
    \           {\n+                /* Grant access to all the kernel objects before\
    \ the scheduler\n+                 * is started. It is necessary because there\
    \ is no task running\n+                 * yet and therefore, we cannot use the\
    \ permissions of any\n+                 * task. */\n+                xAccessGranted\
    \ = pdTRUE;\n+            }\n+            else\n+            {\n+            \
    \    xTaskMpuSettings = xTaskGetMPUSettings( NULL ); /* Calling task's MPU settings.\
    \ */\n+\n+                ulAccessControlListEntryIndex = ( ( uint32_t ) lInternalIndexOfKernelObject\
    \ / portACL_ENTRY_SIZE_BITS );\n+                ulAccessControlListEntryBit =\
    \ ( ( uint32_t ) lInternalIndexOfKernelObject % portACL_ENTRY_SIZE_BITS );\n+\n\
    +                if( ( xTaskMpuSettings->ulTaskFlags & portTASK_IS_PRIVILEGED_FLAG\
    \ ) == portTASK_IS_PRIVILEGED_FLAG )\n+                {\n+                  \
    \  xAccessGranted = pdTRUE;\n+                }\n+                else\n+    \
    \            {\n+                    if( ( xTaskMpuSettings->ulAccessControlList[\
    \ ulAccessControlListEntryIndex ] & ( 1U << ulAccessControlListEntryBit ) ) !=\
    \ 0 )\n+                    {\n+                        xAccessGranted = pdTRUE;\n\
    +                    }\n+                }\n+            }\n+\n+            return\
    \ xAccessGranted;\n+        }\n+\n+    #else /* #if ( configENABLE_ACCESS_CONTROL_LIST\
    \ == 1 ) */\n+\n+        BaseType_t xPortIsAuthorizedToAccessKernelObject( int32_t\
    \ lInternalIndexOfKernelObject ) /* PRIVILEGED_FUNCTION */\n+        {\n+    \
    \        ( void ) lInternalIndexOfKernelObject;\n+\n+            /* If Access\
    \ Control List feature is not used, all the tasks have\n+             * access\
    \ to all the kernel objects. */\n+            return pdTRUE;\n+        }\n+\n\
    +    #endif /* #if ( configENABLE_ACCESS_CONTROL_LIST == 1 ) */\n+\n+#endif /*\
    \ #if ( configUSE_MPU_WRAPPERS_V1 == 0 ) */\n+/*-----------------------------------------------------------*/"
  identifiers: CVE:["CVE-2024-28115"],CWE:["CWE-284"]
  overview: Affected versions of this package are vulnerable to Improper Access Control
    due to insufficient protection mechanisms in the ARMv7-M MPU ports and ARMv8-M
    ports. An attacker can escalate privileges and execute arbitrary code by leveraging
    Return Oriented Programming techniques if a code injection vulnerability is present.
  references:
    GitHub Commit: https://github.com/FreeRTOS/FreeRTOS-Kernel/commit/6b7d4cf41be3438177ae7104553f0c69d2f2d286
  title: Improper Access Control
- diff_content:
  - "--- a/src/cpp/rtps/messages/MessageReceiver.cpp\n+++ b/src/cpp/rtps/messages/MessageReceiver.cpp\n\
    @@ -1046,6 +1046,8 @@ bool MessageReceiver::proc_Submsg_DataFrag(\n         {\n\
    \             EPROSIMA_LOG_WARNING(RTPS_MSG_IN, IDSTRING \"Serialized Payload\
    \ value invalid or larger than maximum allowed size \"\n                     \"\
    (\" << payload_size << \"/\" << (msg->length - msg->pos) << \")\");\n+       \
    \     ch.serializedPayload.data = nullptr;\n+            ch.inline_qos.data =\
    \ nullptr;\n             return false;\n         }\n     }"
  - "--- a/test/blackbox/common/BlackboxTestsTransportUDP.cpp\n+++ b/test/blackbox/common/BlackboxTestsTransportUDP.cpp\n\
    @@ -548,6 +548,7 @@ TEST(TransportUDP, DatagramInjection)\n     ASSERT_FALSE(receivers.empty());\n\
    \ \n     deliver_datagram_from_file(receivers, \"datagrams/16784.bin\");\n+  \
    \  deliver_datagram_from_file(receivers, \"datagrams/20140.bin\");\n }\n \n //\
    \ Test for ==operator UDPTransportDescriptor is not required as it is an abstract\
    \ class and in UDPv4 is same method"
  identifiers: CVE:["CVE-2023-50716"],CWE:["CWE-416"]
  overview: Affected versions of this package are vulnerable to Use After Free due
    to an invalid `DATA_FRAG` Submessage causing a bad-free error, allowing for the
    remote termination of the `Fast-DDS` process. If an invalid `Data_Frag` packet
    is sent, the `Inline_qos, SerializedPayload` member of object `ch` will attempt
    to release memory without initialization, leading to a 'bad-free' error.
  references:
    GitHub Commit: https://github.com/eProsima/Fast-DDS/commit/12036540f22b11afb35f8f783e0208d7fc337df1
  title: Use After Free
- diff_content:
  - "--- a/test/src/unit-regression.cpp\n+++ b/test/src/unit-regression.cpp\n@@ -610,4\
    \ +610,57 @@ TEST_CASE(\"regression tests\")\n         CHECK_THROWS_AS(json::from_cbor(vec2),\
    \ std::out_of_range);\n         CHECK_THROWS_AS(json::from_msgpack(vec2), std::out_of_range);\n\
    \     }\n+\n+    SECTION(\"issue #411 - Heap-buffer-overflow (OSS-Fuzz issue 366)\"\
    )\n+    {\n+        // original test case: empty UTF-8 string (indefinite length)\n\
    +        std::vector<uint8_t> vec1 {0x7f};\n+        CHECK_THROWS_AS(json::from_cbor(vec1),\
    \ std::out_of_range);\n+\n+        // related test case: empty array (indefinite\
    \ length)\n+        std::vector<uint8_t> vec2 {0x9f};\n+        CHECK_THROWS_AS(json::from_cbor(vec2),\
    \ std::out_of_range);\n+\n+        // related test case: empty map (indefinite\
    \ length)\n+        std::vector<uint8_t> vec3 {0xbf};\n+        CHECK_THROWS_AS(json::from_cbor(vec3),\
    \ std::out_of_range);\n+    }\n+\n+    SECTION(\"issue #412 - Heap-buffer-overflow\
    \ (OSS-Fuzz issue 367)\")\n+    {\n+        // original test case\n+        std::vector<uint8_t>\
    \ vec\n+        {\n+            0xab, 0x98, 0x98, 0x98, 0x98, 0x98, 0x98, 0x98,\n\
    +            0x98, 0x98, 0x98, 0x98, 0x98, 0x00, 0x00, 0x00,\n+            0x60,\
    \ 0xab, 0x98, 0x98, 0x98, 0x98, 0x98, 0x98,\n+            0x98, 0x98, 0x98, 0x98,\
    \ 0x98, 0x00, 0x00, 0x00,\n+            0x60, 0x60, 0x60, 0x60, 0x60, 0x60, 0x60,\
    \ 0x60,\n+            0x60, 0x60, 0x60, 0x60, 0x60, 0x60, 0x60, 0x60,\n+     \
    \       0x60, 0x60, 0x60, 0x60, 0x60, 0x60, 0x60, 0x60,\n+            0x60, 0x60,\
    \ 0x60, 0x60, 0x60, 0x60, 0x60, 0x60,\n+            0x60, 0x60, 0x60, 0x60, 0x60,\
    \ 0x60, 0x60, 0x60,\n+            0x60, 0x60, 0x60, 0x60, 0x60, 0x60, 0x60, 0x60,\n\
    +            0x60, 0x60, 0x60, 0x60, 0x60, 0x60, 0xa0, 0x9f,\n+            0x9f,\
    \ 0x97, 0x60, 0x60, 0x60, 0x60, 0x60, 0x60,\n+            0x60, 0x60, 0x60, 0x60,\
    \ 0x60, 0x60, 0x60, 0x60,\n+            0x60, 0x60, 0x60, 0x60, 0x60, 0x60, 0x60,\
    \ 0x60,\n+            0x60, 0x60, 0x60, 0x60, 0x60, 0x60, 0x60, 0x60,\n+     \
    \       0x60, 0x60, 0x60, 0x60, 0x60, 0x60, 0x60, 0x60,\n+            0x60, 0x60,\
    \ 0x60, 0x60, 0x60, 0x60, 0x60, 0x60\n+        };\n+        CHECK_THROWS_AS(json::from_cbor(vec),\
    \ std::out_of_range);\n+\n+        // related test case: nonempty UTF-8 string\
    \ (indefinite length)\n+        std::vector<uint8_t> vec1 {0x7f, 0x61, 0x61};\n\
    +        CHECK_THROWS_AS(json::from_cbor(vec1), std::out_of_range);\n+\n+    \
    \    // related test case: nonempty array (indefinite length)\n+        std::vector<uint8_t>\
    \ vec2 {0x9f, 0x01};\n+        CHECK_THROWS_AS(json::from_cbor(vec2), std::out_of_range);\n\
    +\n+        // related test case: nonempty map (indefinite length)\n+        std::vector<uint8_t>\
    \ vec3 {0xbf, 0x61, 0x61, 0x01};\n+        CHECK_THROWS_AS(json::from_cbor(vec3),\
    \ std::out_of_range);\n+    }\n }"
  identifiers: CVE:[],CWE:["CWE-122"],PVE:["PVE-2024-64942"]
  overview: Affected versions of this package are vulnerable to Heap-based Buffer
    Overflow during parsing of CBOR data, due to an unclosed UTF-8 string of undetermined
    length.
  references:
    GitHub Commit: https://github.com/nlohmann/json/commit/cf9bf2d9136a9d1c2131f83aa493bb03f36849ab
    GitHub Issue: https://github.com/nlohmann/json/issues/412
  title: Heap-based Buffer Overflow
- diff_content:
  - "--- a/test/src/unit-regression.cpp\n+++ b/test/src/unit-regression.cpp\n@@ -540,4\
    \ +540,11 @@ TEST_CASE(\"regression tests\")\n         CHECK(j.is_number_float());\n\
    \         CHECK(j.dump() == \"1.66020696663386e+20\");\n     }\n+\n+    SECTION(\"\
    issue #405 - Heap-buffer-overflow (OSS-Fuzz issue 342)\")\n+    {\n+        //\
    \ original test case\n+        std::vector<uint8_t> vec {0x65, 0xf5, 0x0a, 0x48,\
    \ 0x21};\n+        CHECK_THROWS_AS(json::from_cbor(vec), std::out_of_range);\n\
    +    }\n }"
  identifiers: CVE:[],CWE:["CWE-122"],PVE:["PVE-2024-64808"]
  overview: Affected versions of this package are vulnerable to Heap-based Buffer
    Overflow during the parsing of CBOR data.
  references:
    GitHub Commit: https://github.com/nlohmann/json/commit/871cebaf84d4f896bc730a92937f8d02e09b0023
    GitHub Issue: https://github.com/nlohmann/json/issues/405
  title: Heap-based Buffer Overflow
- diff_content:
  - "--- a/b/src/p2putil.c\n+++ b/b/src/p2putil.c\n@@ -5,6 +5,8 @@ CREATE EXTENSION\
    \ IF NOT EXISTS anon CASCADE;\n \n SELECT anon.init();\n \n+SECURITY LABEL FOR\
    \ anon ON SCHEMA pg_catalog IS 'TRUSTED';\n+\n CREATE ROLE oscar_the_owner LOGIN\
    \ PASSWORD 'xlfneifzmqdef';\n ALTER DATABASE :DBNAME OWNER TO oscar_the_owner;\n\
    \ \n@@ -39,12 +41,11 @@ VALUES\n ('Stalone'       ,'2683464645336781'),\n ('Lundgren'\
    \      ,'6877322588932345');\n \n-\n SECURITY LABEL FOR anon ON COLUMN test.customer.name\n\
    -IS E'MASKED WITH FUNCTION md5(''0'') ';\n+IS E'MASKED WITH FUNCTION pg_catalog.md5(''0'')\
    \ ';\n \n SECURITY LABEL FOR anon ON COLUMN test.customer.\"CreditCard\"\n-IS\
    \ E'MASKED WITH FUNCTION md5(''0'') ';\n+IS E'MASKED WITH FUNCTION pg_catalog.md5(''0'')\
    \ ';\n \n CREATE TABLE test.\"COMPANY\" (\n   rn SERIAL,\n@@ -56,7 +57,7 @@ INSERT\
    \ INTO test.\"COMPANY\"\n VALUES (1991,'12345677890','Cyberdyne Systems');\n \n\
    \ SECURITY LABEL FOR anon ON COLUMN test.\"COMPANY\".\"IBAN\"\n-IS E'MASKED WITH\
    \ FUNCTION md5(''0'') ';\n+IS E'MASKED WITH FUNCTION pg_catalog.md5(''0'') ';\n\
    \ \n SECURITY LABEL FOR anon ON COLUMN test.\"COMPANY\".brand\n IS E'MASKED WITH\
    \ VALUE $$CONFIDENTIAL$$ ';\n@@ -776,7 +776,7 @@ done:\n /* Section 4.2.1 */\n\
    \ int p2p_parse_beacon(const uint8_t *pdu, size_t len, struct p2p_beacon *out)\n\
    \ {\n-\tstruct p2p_beacon d = {};\n+\tstruct p2p_beacon d = {0};\n \tint r;\n\
    \ \n \tr = p2p_parse_attrs(pdu, len,\n@@ -797,7 +797,7 @@ int p2p_parse_beacon(const\
    \ uint8_t *pdu, size_t len, struct p2p_beacon *out)\n int p2p_parse_probe_req(const\
    \ uint8_t *pdu, size_t len,\n \t\t\tstruct p2p_probe_req *out)\n {\n-\tstruct\
    \ p2p_probe_req d = {};\n+\tstruct p2p_probe_req d = {0};\n \tint r;\n \n \tr\
    \ = p2p_parse_attrs(pdu, len,\n@@ -828,7 +828,7 @@ int p2p_parse_probe_req(const\
    \ uint8_t *pdu, size_t len,\n int p2p_parse_probe_resp(const uint8_t *pdu, size_t\
    \ len,\n \t\t\t\tstruct p2p_probe_resp *out)\n {\n-\tstruct p2p_probe_resp d =\
    \ {};\n+\tstruct p2p_probe_resp d = {0};\n \tint r;\n \n \tr = p2p_parse_attrs(pdu,\
    \ len,\n@@ -853,7 +853,7 @@ int p2p_parse_probe_resp(const uint8_t *pdu, size_t\
    \ len,\n int p2p_parse_association_req(const uint8_t *pdu, size_t len,\n \t\t\t\
    \tstruct p2p_association_req *out)\n {\n-\tstruct p2p_association_req d = {};\n\
    +\tstruct p2p_association_req d = {0};\n \tint r;\n \n \tr = p2p_parse_attrs(pdu,\
    \ len,\n@@ -876,7 +876,7 @@ int p2p_parse_association_req(const uint8_t *pdu,\
    \ size_t len,\n int p2p_parse_association_resp(const uint8_t *pdu, size_t len,\n\
    \ \t\t\t\tstruct p2p_association_resp *out)\n {\n-\tstruct p2p_association_resp\
    \ d = {};\n+\tstruct p2p_association_resp d = {0};\n \tint r;\n \n \tr = p2p_parse_attrs(pdu,\
    \ len,\n@@ -939,7 +939,7 @@ int p2p_parse_disassociation(const uint8_t *pdu, size_t\
    \ len,\n int p2p_parse_go_negotiation_req(const uint8_t *pdu, size_t len,\n \t\
    \t\t\t\tstruct p2p_go_negotiation_req *out)\n {\n-\tstruct p2p_go_negotiation_req\
    \ d = {};\n+\tstruct p2p_go_negotiation_req d = {0};\n \tint r;\n \tstruct p2p_go_intent_attr\
    \ go_intent;\n \tuint8_t *wsc_data;\n@@ -1001,7 +1001,7 @@ error:\n int p2p_parse_go_negotiation_resp(const\
    \ uint8_t *pdu, size_t len,\n \t\t\t\t\tstruct p2p_go_negotiation_resp *out)\n\
    \ {\n-\tstruct p2p_go_negotiation_resp d = {};\n+\tstruct p2p_go_negotiation_resp\
    \ d = {0};\n \tint r;\n \tstruct p2p_go_intent_attr go_intent;\n \tuint8_t *wsc_data;\n\
    @@ -1062,7 +1062,7 @@ error:\n int p2p_parse_go_negotiation_confirmation(const\
    \ uint8_t *pdu, size_t len,\n \t\t\t\tstruct p2p_go_negotiation_confirmation *out)\n\
    \ {\n-\tstruct p2p_go_negotiation_confirmation d = {};\n+\tstruct p2p_go_negotiation_confirmation\
    \ d = {0};\n \tint r;\n \n \tif (len < 1)\n@@ -1096,7 +1096,7 @@ error:\n int\
    \ p2p_parse_invitation_req(const uint8_t *pdu, size_t len,\n \t\t\t\tstruct p2p_invitation_req\
    \ *out)\n {\n-\tstruct p2p_invitation_req d = {};\n+\tstruct p2p_invitation_req\
    \ d = {0};\n \tint r;\n \tuint8_t *wsc_data;\n \tssize_t wsc_len;\n@@ -1151,7\
    \ +1151,7 @@ error:\n int p2p_parse_invitation_resp(const uint8_t *pdu, size_t\
    \ len,\n \t\t\t\tstruct p2p_invitation_resp *out)\n {\n-\tstruct p2p_invitation_resp\
    \ d = {};\n+\tstruct p2p_invitation_resp d = {0};\n \tint r;\n \n \tif (len <\
    \ 1)\n@@ -1185,7 +1185,7 @@ error:\n int p2p_parse_device_disc_req(const uint8_t\
    \ *pdu, size_t len,\n \t\t\t\tstruct p2p_device_discoverability_req *out)\n {\n\
    -\tstruct p2p_device_discoverability_req d = {};\n+\tstruct p2p_device_discoverability_req\
    \ d = {0};\n \tint r;\n \n \tif (len < 1)\n@@ -1210,7 +1210,7 @@ int p2p_parse_device_disc_req(const\
    \ uint8_t *pdu, size_t len,\n int p2p_parse_device_disc_resp(const uint8_t *pdu,\
    \ size_t len,\n \t\t\t\tstruct p2p_device_discoverability_resp *out)\n {\n-\t\
    struct p2p_device_discoverability_resp d = {};\n+\tstruct p2p_device_discoverability_resp\
    \ d = {0};\n \tint r;\n \n \tif (len < 1)\n@@ -1234,7 +1234,7 @@ int p2p_parse_device_disc_resp(const\
    \ uint8_t *pdu, size_t len,\n int p2p_parse_provision_disc_req(const uint8_t *pdu,\
    \ size_t len,\n \t\t\t\tstruct p2p_provision_discovery_req *out)\n {\n-\tstruct\
    \ p2p_provision_discovery_req d = {};\n+\tstruct p2p_provision_discovery_req d\
    \ = {0};\n \tint r;\n \tuint8_t *wsc_data;\n \tssize_t wsc_len;\n@@ -1309,7 +1309,7\
    \ @@ error:\n int p2p_parse_provision_disc_resp(const uint8_t *pdu, size_t len,\n\
    \ \t\t\t\tstruct p2p_provision_discovery_resp *out)\n {\n-\tstruct p2p_provision_discovery_resp\
    \ d = {};\n+\tstruct p2p_provision_discovery_resp d = {0};\n \tint r;\n \tuint8_t\
    \ *wsc_data;\n \tssize_t wsc_len;\n@@ -1389,7 +1389,7 @@ error:\n int p2p_parse_notice_of_absence(const\
    \ uint8_t *pdu, size_t len,\n \t\t\t\tstruct p2p_notice_of_absence *out)\n {\n\
    -\tstruct p2p_notice_of_absence d = {};\n+\tstruct p2p_notice_of_absence d = {0};\n\
    \ \tint r;\n \n \tif (len < 1)\n@@ -1411,7 +1411,7 @@ int p2p_parse_notice_of_absence(const\
    \ uint8_t *pdu, size_t len,\n int p2p_parse_presence_req(const uint8_t *pdu, size_t\
    \ len,\n \t\t\t\tstruct p2p_presence_req *out)\n {\n-\tstruct p2p_presence_req\
    \ d = {};\n+\tstruct p2p_presence_req d = {0};\n \tint r;\n \n \tif (len < 1)\n\
    @@ -1437,7 +1437,7 @@ int p2p_parse_presence_req(const uint8_t *pdu, size_t len,\n\
    \ int p2p_parse_presence_resp(const uint8_t *pdu, size_t len,\n \t\t\t\tstruct\
    \ p2p_presence_resp *out)\n {\n-\tstruct p2p_presence_resp d = {};\n+\tstruct\
    \ p2p_presence_resp d = {0};\n \tint r;\n \n \tif (len < 1)\n"
  identifiers: CVE:["CVE-2024-28084"],CWE:["CWE-416"]
  overview: Affected versions of this package are vulnerable to Use After Free in
    `p2putil.c`, due to improper initialization in situations where parsing of advertised
    service information fails. An attacker can cause a crash of the daemon or possibly
    have unspecified other impacts by sending malformed service information.
  references:
    Git Commit: https://git.kernel.org/pub/scm/network/wireless/iwd.git/commit/?id=d34b4e16e045142590ed7cb653e01ed0ae5362eb
  title: Use After Free
- diff_content:
  - "--- a/sys/kern/uipc_mbuf.c\n+++ b/sys/kern/uipc_mbuf.c\n@@ -1,4 +1,4 @@\n-/*\t\
    $OpenBSD: uipc_mbuf.c,v 1.287 2023/06/23 04:36:49 gnezdo Exp $\t*/\n+/*\t$OpenBSD:\
    \ uipc_mbuf.c,v 1.288 2023/10/20 16:25:15 bluhm Exp $\t*/\n /*\t$NetBSD: uipc_mbuf.c,v\
    \ 1.15.4.1 1996/06/13 17:11:44 cgd Exp $\t*/\n \n /*\n@@ -1080,9 +1080,7 @@ m_split(struct\
    \ mbuf *m0, int len0, int wait)\n \t\t\tn->m_len = 0;\n \t\t\treturn (n);\n \t\
    \t}\n-\t\tif (m->m_flags & M_EXT)\n-\t\t\tgoto extpacket;\n-\t\tif (remain > MHLEN)\
    \ {\n+\t\tif ((m->m_flags & M_EXT) == 0 && remain > MHLEN) {\n \t\t\t/* m can't\
    \ be the lead packet */\n \t\t\tm_align(n, 0);\n \t\t\tn->m_next = m_split(m,\
    \ len, wait);\n@@ -1094,8 +1092,7 @@ m_split(struct mbuf *m0, int len0, int wait)\n\
    \ \t\t\t\tn->m_len = 0;\n \t\t\t\treturn (n);\n \t\t\t}\n-\t\t} else\n-\t\t\t\
    m_align(n, remain);\n+\t\t}\n \t} else if (remain == 0) {\n \t\tn = m->m_next;\n\
    \ \t\tm->m_next = NULL;\n@@ -1104,14 +1101,13 @@ m_split(struct mbuf *m0, int\
    \ len0, int wait)\n \t\tMGET(n, wait, m->m_type);\n \t\tif (n == NULL)\n \t\t\t\
    return (NULL);\n-\t\tm_align(n, remain);\n \t}\n-extpacket:\n \tif (m->m_flags\
    \ & M_EXT) {\n \t\tn->m_ext = m->m_ext;\n \t\tMCLADDREFERENCE(m, n);\n \t\tn->m_data\
    \ = m->m_data + len;\n \t} else {\n+\t\tm_align(n, remain);\n \t\tmemcpy(mtod(n,\
    \ caddr_t), mtod(m, caddr_t) + len, remain);\n \t}\n \tn->m_len = remain;"
  identifiers: CVE:["CVE-2023-52558"],CWE:["CWE-131"]
  overview: Affected versions of this package are vulnerable to Incorrect Calculation
    of Buffer Size due to improper calculation of buffer size for a network buffer
    that needs to be split at a certain length. An attacker can crash the kernel after
    sending specially crafted escape sequences.
  references:
    GitHub Commit: https://github.com/openbsd/src/commit/7b4d35e0a60ba1dd4daf4b1c2932020a22463a89
    OpenBSD Errata: https://ftp.openbsd.org/pub/OpenBSD/patches/7.4/common/002_msplit.patch.sig
  title: Incorrect Calculation of Buffer Size
- diff_content:
  - "--- a/sys/net/pf.c\n+++ b/sys/net/pf.c\n@@ -1,4 +1,4 @@\n-/*\t$OpenBSD: pf.c,v\
    \ 1.1188 2023/10/10 16:26:06 bluhm Exp $ */\n+/*\t$OpenBSD: pf.c,v 1.1189 2023/12/01\
    \ 10:28:32 sashan Exp $ */\n \n /*\n  * Copyright (c) 2001 Daniel Hartmeier\n\
    @@ -469,6 +469,15 @@ pf_state_list_remove(struct pf_state_list *pfs, struct pf_state\
    \ *st)\n \tpf_state_unref(st); /* list no longer references the state */\n }\n\
    \ \n+void\n+pf_update_state_timeout(struct pf_state *st, int to)\n+{\n+\tmtx_enter(&st->mtx);\n\
    +\tif (st->timeout != PFTM_UNLINKED)\n+\t\tst->timeout = to;\n+\tmtx_leave(&st->mtx);\n\
    +}\n+\n int\n pf_src_connlimit(struct pf_state **stp)\n {\n@@ -549,7 +558,7 @@\
    \ pf_src_connlimit(struct pf_state **stp)\n \t\t\t\t    ((*stp)->rule.ptr->flush\
    \ &\n \t\t\t\t    PF_FLUSH_GLOBAL ||\n \t\t\t\t    (*stp)->rule.ptr == st->rule.ptr))\
    \ {\n-\t\t\t\t\tst->timeout = PFTM_PURGE;\n+\t\t\t\t\tpf_update_state_timeout(st,\
    \ PFTM_PURGE);\n \t\t\t\t\tpf_set_protostate(st, PF_PEER_BOTH,\n \t\t\t\t\t  \
    \  TCPS_CLOSED);\n \t\t\t\t\tkilled++;\n@@ -563,7 +572,7 @@ pf_src_connlimit(struct\
    \ pf_state **stp)\n \t}\n \n \t/* kill this state */\n-\t(*stp)->timeout = PFTM_PURGE;\n\
    +\tpf_update_state_timeout(*stp, PFTM_PURGE);\n \tpf_set_protostate(*stp, PF_PEER_BOTH,\
    \ TCPS_CLOSED);\n \treturn (1);\n }\n@@ -1758,10 +1767,13 @@ pf_remove_state(struct\
    \ pf_state *st)\n {\n \tPF_ASSERT_LOCKED();\n \n-\tif (st->timeout == PFTM_UNLINKED)\n\
    +\tmtx_enter(&st->mtx);\n+\tif (st->timeout == PFTM_UNLINKED) {\n+\t\tmtx_leave(&st->mtx);\n\
    \ \t\treturn;\n-\n+\t}\n \tst->timeout = PFTM_UNLINKED;\n+\tmtx_leave(&st->mtx);\n\
    \ \n \t/* handle load balancing related tasks */\n \tpf_postprocess_addr(st);\n\
    @@ -1816,7 +1828,8 @@ pf_remove_divert_state(struct pf_state_key *sk)\n \t\t\t\
    \t    sist->dst.state < TCPS_FIN_WAIT_2) {\n \t\t\t\t\tpf_set_protostate(sist,\
    \ PF_PEER_BOTH,\n \t\t\t\t\t    TCPS_TIME_WAIT);\n-\t\t\t\t\tsist->timeout = PFTM_TCP_CLOSED;\n\
    +\t\t\t\t\tpf_update_state_timeout(sist,\n+\t\t\t\t\t    PFTM_TCP_CLOSED);\n \t\
    \t\t\t\tsist->expire = getuptime();\n \t\t\t\t}\n \t\t\t\tsist->state_flags |=\
    \ PFSTATE_INP_UNLINKED;\n@@ -5036,18 +5049,18 @@ pf_tcp_track_full(struct pf_pdesc\
    \ *pd, struct pf_state **stp, u_short *reason,\n \t\t(*stp)->expire = getuptime();\n\
    \ \t\tif (src->state >= TCPS_FIN_WAIT_2 &&\n \t\t    dst->state >= TCPS_FIN_WAIT_2)\n\
    -\t\t\t(*stp)->timeout = PFTM_TCP_CLOSED;\n+\t\t\tpf_update_state_timeout(*stp,\
    \ PFTM_TCP_CLOSED);\n \t\telse if (src->state >= TCPS_CLOSING &&\n \t\t    dst->state\
    \ >= TCPS_CLOSING)\n-\t\t\t(*stp)->timeout = PFTM_TCP_FIN_WAIT;\n+\t\t\tpf_update_state_timeout(*stp,\
    \ PFTM_TCP_FIN_WAIT);\n \t\telse if (src->state < TCPS_ESTABLISHED ||\n \t\t \
    \   dst->state < TCPS_ESTABLISHED)\n-\t\t\t(*stp)->timeout = PFTM_TCP_OPENING;\n\
    +\t\t\tpf_update_state_timeout(*stp, PFTM_TCP_OPENING);\n \t\telse if (src->state\
    \ >= TCPS_CLOSING ||\n \t\t    dst->state >= TCPS_CLOSING)\n-\t\t\t(*stp)->timeout\
    \ = PFTM_TCP_CLOSING;\n+\t\t\tpf_update_state_timeout(*stp, PFTM_TCP_CLOSING);\n\
    \ \t\telse\n-\t\t\t(*stp)->timeout = PFTM_TCP_ESTABLISHED;\n+\t\t\tpf_update_state_timeout(*stp,\
    \ PFTM_TCP_ESTABLISHED);\n \n \t\t/* Fall through to PASS packet */\n \t} else\
    \ if ((dst->state < TCPS_SYN_SENT ||\n@@ -5229,18 +5242,18 @@ pf_tcp_track_sloppy(struct\
    \ pf_pdesc *pd, struct pf_state **stp,\n \t(*stp)->expire = getuptime();\n \t\
    if (src->state >= TCPS_FIN_WAIT_2 &&\n \t    dst->state >= TCPS_FIN_WAIT_2)\n\
    -\t\t(*stp)->timeout = PFTM_TCP_CLOSED;\n+\t\tpf_update_state_timeout(*stp, PFTM_TCP_CLOSED);\n\
    \ \telse if (src->state >= TCPS_CLOSING &&\n \t    dst->state >= TCPS_CLOSING)\n\
    -\t\t(*stp)->timeout = PFTM_TCP_FIN_WAIT;\n+\t\tpf_update_state_timeout(*stp,\
    \ PFTM_TCP_FIN_WAIT);\n \telse if (src->state < TCPS_ESTABLISHED ||\n \t    dst->state\
    \ < TCPS_ESTABLISHED)\n-\t\t(*stp)->timeout = PFTM_TCP_OPENING;\n+\t\tpf_update_state_timeout(*stp,\
    \ PFTM_TCP_OPENING);\n \telse if (src->state >= TCPS_CLOSING ||\n \t    dst->state\
    \ >= TCPS_CLOSING)\n-\t\t(*stp)->timeout = PFTM_TCP_CLOSING;\n+\t\tpf_update_state_timeout(*stp,\
    \ PFTM_TCP_CLOSING);\n \telse\n-\t\t(*stp)->timeout = PFTM_TCP_ESTABLISHED;\n\
    +\t\tpf_update_state_timeout(*stp, PFTM_TCP_ESTABLISHED);\n \n \treturn (PF_PASS);\n\
    \ }\n@@ -5377,7 +5390,7 @@ pf_test_state(struct pf_pdesc *pd, struct pf_state\
    \ **stp, u_short *reason)\n \t\t\t\t\taddlog(\"\\n\");\n \t\t\t\t}\n \t\t\t\t\
    /* XXX make sure it's the same direction ?? */\n-\t\t\t\t(*stp)->timeout = PFTM_PURGE;\n\
    +\t\t\t\tpf_update_state_timeout(*stp, PFTM_PURGE);\n \t\t\t\tpf_state_unref(*stp);\n\
    \ \t\t\t\t*stp = NULL;\n \t\t\t\tpf_mbuf_link_inpcb(pd->m, inp);\n@@ -5417,9 +5430,9\
    \ @@ pf_test_state(struct pf_pdesc *pd, struct pf_state **stp, u_short *reason)\n\
    \ \t\t(*stp)->expire = getuptime();\n \t\tif (src->state == PFUDPS_MULTIPLE &&\n\
    \ \t\t    dst->state == PFUDPS_MULTIPLE)\n-\t\t\t(*stp)->timeout = PFTM_UDP_MULTIPLE;\n\
    +\t\t\tpf_update_state_timeout(*stp, PFTM_UDP_MULTIPLE);\n \t\telse\n-\t\t\t(*stp)->timeout\
    \ = PFTM_UDP_SINGLE;\n+\t\t\tpf_update_state_timeout(*stp, PFTM_UDP_SINGLE);\n\
    \ \t\tbreak;\n \tdefault:\n \t\t/* update states */\n@@ -5432,9 +5445,9 @@ pf_test_state(struct\
    \ pf_pdesc *pd, struct pf_state **stp, u_short *reason)\n \t\t(*stp)->expire =\
    \ getuptime();\n \t\tif (src->state == PFOTHERS_MULTIPLE &&\n \t\t    dst->state\
    \ == PFOTHERS_MULTIPLE)\n-\t\t\t(*stp)->timeout = PFTM_OTHER_MULTIPLE;\n+\t\t\t\
    pf_update_state_timeout(*stp, PFTM_OTHER_MULTIPLE);\n \t\telse\n-\t\t\t(*stp)->timeout\
    \ = PFTM_OTHER_SINGLE;\n+\t\t\tpf_update_state_timeout(*stp, PFTM_OTHER_SINGLE);\n\
    \ \t\tbreak;\n \t}\n \n@@ -5585,7 +5598,7 @@ pf_test_state_icmp(struct pf_pdesc\
    \ *pd, struct pf_state **stp,\n \t\t\treturn (ret);\n \n \t\t(*stp)->expire =\
    \ getuptime();\n-\t\t(*stp)->timeout = PFTM_ICMP_ERROR_REPLY;\n+\t\tpf_update_state_timeout(*stp,\
    \ PFTM_ICMP_ERROR_REPLY);\n \n \t\t/* translate source/destination address, if\
    \ necessary */\n \t\tif ((*stp)->key[PF_SK_WIRE] != (*stp)->key[PF_SK_STACK])\
    \ {"
  identifiers: CVE:["CVE-2023-52556"],CWE:["CWE-367"]
  overview: Affected versions of this package are vulnerable to Time-of-check Time-of-use
    (TOCTOU) Race Condition between `pf(4)`'s processing of packets and the expiration
    of packet states, which may lead to a kernel panic. An attacker can cause a denial
    of service by exploiting this vulnerability.
  references:
    GitHub Commit: https://github.com/openbsd/src/commit/9d9f4dc6c833cb79d13f836581e3a781d06842e7
    OpenBSD Errata: https://ftp.openbsd.org/pub/OpenBSD/patches/7.4/common/009_pf.patch.sig
  title: Time-of-check Time-of-use (TOCTOU) Race Condition
- diff_content:
  - "--- a/usr.sbin/npppd/l2tp/l2tp_subr.c\n+++ b/usr.sbin/npppd/l2tp/l2tp_subr.c\n\
    @@ -1,4 +1,4 @@\n-/*\t$OpenBSD: l2tp_subr.c,v 1.4 2012/05/08 13:15:11 yasuoka\
    \ Exp $\t*/\n+/*\t$OpenBSD: l2tp_subr.c,v 1.5 2023/09/11 07:33:07 yasuoka Exp\
    \ $\t*/\n \n /*-\n  * Copyright (c) 2009 Internet Initiative Japan Inc.\n@@ -25,7\
    \ +25,7 @@\n  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY\
    \ OF\n  * SUCH DAMAGE.\n  */\n-/* $Id: l2tp_subr.c,v 1.4 2012/05/08 13:15:11 yasuoka\
    \ Exp $ */\n+/* $Id: l2tp_subr.c,v 1.5 2023/09/11 07:33:07 yasuoka Exp $ */\n\
    \ /**@file L2TP related sub-routines */\n #include <sys/types.h>\n #include <sys/time.h>\n\
    @@ -80,10 +80,10 @@ avp_enum(struct l2tp_avp *avp, const u_char *pkt, int pktlen,\
    \ int filldata)\n \tavp->attr_type |= *(pkt + 1);\n \tpkt += 2;\n \n-\tif (avp->length\
    \ > pktlen)\n+\tif (avp->length < 6 || avp->length > pktlen)\n \t\treturn -1;\n\
    \ \n-\tif (filldata != 0)\n+\tif (avp->length > 6 && filldata != 0)\n \t\tmemcpy(avp->attr_value,\
    \ pkt, avp->length - 6);\n \n \treturn avp->length;\n@@ -285,9 +285,8 @@ avp_find(struct\
    \ l2tp_avp *avp, const u_char *pkt, int pktlen,\n \n \twhile (pktlen >= 6 &&\n\
    \ \t    (avpsz = avp_enum(avp, pkt, pktlen, fill_data)) > 0) {\n+\t\tL2TP_SUBR_ASSERT(avpsz\
    \ >= 6);\n \t\tif (avp->vendor_id != vendor_id || avp->attr_type != attr_type)\
    \ {\n-\t\t\tif (avpsz < 6)\n-\t\t\t\treturn NULL;\n \t\t\tpkt += avpsz;\n \t\t\
    \tpktlen -= avpsz;\n \t\t\tcontinue;"
  identifiers: CVE:["CVE-2023-52557"],CWE:["CWE-131"]
  overview: Affected versions of this package are vulnerable to Incorrect Calculation
    of Buffer Size due to the handling of a L2TP message containing an AVP (Attribute-Value
    Pair) with an incorrect length. An attacker can cause a denial of service by sending
    a specially crafted L2TP message.
  references:
    GitHub Commit: https://github.com/openbsd/src/commit/abf3a29384c582c807a621e7fc6e7c68d0cafe9b
    OpenBSD Errata: https://ftp.openbsd.org/pub/OpenBSD/patches/7.3/common/016_npppd.patch.sig
  title: Incorrect Calculation of Buffer Size
- diff_content:
  - "--- a/apps/ts2las.cpp\n+++ b/apps/ts2las.cpp\n@@ -343,6 +343,7 @@ int main(int\
    \ argc, char* argv[])\n     if (!opened)\n     {\n         std::cerr << \"Could\
    \ not open file '\" << input << \"' to read TerraSolid .bin data! \" << std::endl;\n\
    +        delete hdr;\n         return 1;\n     }\n     "
  identifiers: CVE:["CVE-2024-27507"],CWE:["CWE-400"]
  overview: Affected versions of this package are vulnerable to Denial of Service
    (DoS) due to a memory leak in `ts2las.cpp`.
  references:
    GitHub Commit: https://github.com/libLAS/libLAS/commit/f1da55589ce568119a5b4cb5707af2ec403b3cd7
    Vulnerability Report: https://github.com/LuMingYinDetect/libLAS_defects/blob/main/libLAS_detect_1.md
    commons-fileupload:commons-fileupload: SNYK-JAVA-COMMONSFILEUPLOAD-30082
    npm <code>ws</code> package: https://snyk.io/vuln/npm:ws:20171108
  title: Denial of Service (DoS)
- diff_content:
  - "--- a/drivers/spi/spi-fsl-lpspi.c\n+++ b/drivers/spi/spi-fsl-lpspi.c\n@@ -200,7\
    \ +200,7 @@ static int lpspi_prepare_xfer_hardware(struct spi_controller *controller)\n\
    \ \t\t\t\tspi_controller_get_devdata(controller);\n \tint ret;\n \n-\tret = pm_runtime_get_sync(fsl_lpspi->dev);\n\
    +\tret = pm_runtime_resume_and_get(fsl_lpspi->dev);\n \tif (ret < 0) {\n \t\t\
    dev_err(fsl_lpspi->dev, \"failed to enable clock\\n\");\n \t\treturn ret;"
  identifiers: CVE:["CVE-2021-47051"],CWE:["CWE-400"]
  overview: Affected versions of this package are vulnerable to Resource Exhaustion
    due to improper handling of a power management (PM) reference in the `lpspi_prepare_xfer_hardware`
    function. An attacker with local access can cause a denial of service condition
    by exploiting this flaw.
  references:
    GitHub Commit: https://github.com/torvalds/linux/commit/a03675497970a93fcf25d81d9d92a59c2d7377a7
    RedHat Bugzilla Bug: https://bugzilla.redhat.com/show_bug.cgi?id=2266728
    Vulnerability Advisory: https://lore.kernel.org/linux-cve-announce/2024022840-CVE-2021-47051-cf30@gregkh/T/#u
  title: Resource Exhaustion
- diff_content:
  - "--- a/kernel/bpf/verifier.c\n+++ b/kernel/bpf/verifier.c\n@@ -12391,14 +12391,10\
    \ @@ static int do_misc_fixups(struct bpf_verifier_env *env)\n \t\t\t*patch++\
    \ = BPF_ALU64_REG(BPF_OR, BPF_REG_AX, off_reg);\n \t\t\t*patch++ = BPF_ALU64_IMM(BPF_NEG,\
    \ BPF_REG_AX, 0);\n \t\t\t*patch++ = BPF_ALU64_IMM(BPF_ARSH, BPF_REG_AX, 63);\n\
    -\t\t\tif (issrc) {\n-\t\t\t\t*patch++ = BPF_ALU64_REG(BPF_AND, BPF_REG_AX,\n\
    -\t\t\t\t\t\t\t off_reg);\n-\t\t\t\tinsn->src_reg = BPF_REG_AX;\n-\t\t\t} else\
    \ {\n-\t\t\t\t*patch++ = BPF_ALU64_REG(BPF_AND, off_reg,\n-\t\t\t\t\t\t\t BPF_REG_AX);\n\
    -\t\t\t}\n+\t\t\t*patch++ = BPF_ALU64_REG(BPF_AND, BPF_REG_AX, off_reg);\n+\t\t\
    \tif (!issrc)\n+\t\t\t\t*patch++ = BPF_MOV64_REG(insn->dst_reg, insn->src_reg);\n\
    +\t\t\tinsn->src_reg = BPF_REG_AX;\n \t\t\tif (isneg)\n \t\t\t\tinsn->code = insn->code\
    \ == code_add ?\n \t\t\t\t\t     code_sub : code_add;"
  identifiers: CVE:["CVE-2021-46974"],CWE:["CWE-787"]
  overview: Affected versions of this package are vulnerable to Out-of-bounds Write
    due to improper handling of masking negation logic upon a negative destination
    register. An attacker with local access can cause a denial of service by exploiting
    this flaw.
  references:
    GitHub Commit: https://github.com/torvalds/linux/commit/b9b34ddbe2076ade359cd5ce7537d5ed019e9807
    RedHat Bugzilla Bug: https://bugzilla.redhat.com/show_bug.cgi?id=2266826
    Vulnerability Advisory: https://lore.kernel.org/linux-cve-announce/2024022721-CVE-2021-46974-0852@gregkh/T/#u
  title: Out-of-bounds Write
- diff_content:
  - "--- a/drivers/media/dvb-core/dvbdev.c\n+++ b/drivers/media/dvb-core/dvbdev.c\n\
    @@ -241,6 +241,7 @@ static void dvb_media_device_free(struct dvb_device *dvbdev)\n\
    \ \n \tif (dvbdev->adapter->conn) {\n \t\tmedia_device_unregister_entity(dvbdev->adapter->conn);\n\
    +\t\tkfree(dvbdev->adapter->conn);\n \t\tdvbdev->adapter->conn = NULL;\n \t\t\
    kfree(dvbdev->adapter->conn_pads);\n \t\tdvbdev->adapter->conn_pads = NULL;"
  identifiers: CVE:["CVE-2020-36777"],CWE:["CWE-401"]
  overview: Affected versions of this package are vulnerable to Memory Leak due to
    improper handling of memory in the `dvb_media_device_free` function. An attacker
    can cause a denial of service condition by triggering a memory leak.
  references:
    GitHub Commit: https://github.com/torvalds/linux/commit/bf9a40ae8d722f281a2721779595d6df1c33a0bf
    RedHat Bugzilla Bug: https://bugzilla.redhat.com/show_bug.cgi?id=2266746
    Vulnerability Advisory: https://lore.kernel.org/linux-cve-announce/20240227184057.2368370-2-gregkh@linuxfoundation.org/T/#u
  title: Memory Leak
- diff_content:
  - "--- a/drivers/spi/spi-zynqmp-gqspi.c\n+++ b/drivers/spi/spi-zynqmp-gqspi.c\n\
    @@ -733,7 +733,7 @@ static irqreturn_t zynqmp_qspi_irq(int irq, void *dev_id)\n\
    \  * zynqmp_qspi_setuprxdma - This function sets up the RX DMA operation\n  *\
    \ @xqspi:\txqspi is a pointer to the GQSPI instance.\n  */\n-static void zynqmp_qspi_setuprxdma(struct\
    \ zynqmp_qspi *xqspi)\n+static int zynqmp_qspi_setuprxdma(struct zynqmp_qspi *xqspi)\n\
    \ {\n \tu32 rx_bytes, rx_rem, config_reg;\n \tdma_addr_t addr;\n@@ -747,16 +747,18\
    \ @@ static void zynqmp_qspi_setuprxdma(struct zynqmp_qspi *xqspi)\n \t\tzynqmp_gqspi_write(xqspi,\
    \ GQSPI_CONFIG_OFST, config_reg);\n \t\txqspi->mode = GQSPI_MODE_IO;\n \t\txqspi->dma_rx_bytes\
    \ = 0;\n-\t\treturn;\n+\t\treturn 0;\n \t}\n \n \trx_rem = xqspi->bytes_to_receive\
    \ % 4;\n \trx_bytes = (xqspi->bytes_to_receive - rx_rem);\n \n \taddr = dma_map_single(xqspi->dev,\
    \ (void *)xqspi->rxbuf,\n \t\t\t      rx_bytes, DMA_FROM_DEVICE);\n-\tif (dma_mapping_error(xqspi->dev,\
    \ addr))\n+\tif (dma_mapping_error(xqspi->dev, addr)) {\n \t\tdev_err(xqspi->dev,\
    \ \"ERR:rxdma:memory not mapped\\n\");\n+\t\treturn -ENOMEM;\n+\t}\n \n \txqspi->dma_rx_bytes\
    \ = rx_bytes;\n \txqspi->dma_addr = addr;\n@@ -777,6 +779,8 @@ static void zynqmp_qspi_setuprxdma(struct\
    \ zynqmp_qspi *xqspi)\n \n \t/* Write the number of bytes to transfer */\n \t\
    zynqmp_gqspi_write(xqspi, GQSPI_QSPIDMA_DST_SIZE_OFST, rx_bytes);\n+\n+\treturn\
    \ 0;\n }\n \n /**\n@@ -813,11 +817,17 @@ static void zynqmp_qspi_write_op(struct\
    \ zynqmp_qspi *xqspi, u8 tx_nbits,\n  * @genfifoentry:\tgenfifoentry is pointer\
    \ to the variable in which\n  *\t\t\tGENFIFO\tmask is returned to calling function\n\
    \  */\n-static void zynqmp_qspi_read_op(struct zynqmp_qspi *xqspi, u8 rx_nbits,\n\
    +static int zynqmp_qspi_read_op(struct zynqmp_qspi *xqspi, u8 rx_nbits,\n \t\t\
    \t\tu32 genfifoentry)\n {\n-\tzynqmp_qspi_setuprxdma(xqspi);\n+\tint ret;\n+\n\
    +\tret = zynqmp_qspi_setuprxdma(xqspi);\n+\tif (ret)\n+\t\treturn ret;\n \tzynqmp_qspi_fillgenfifo(xqspi,\
    \ rx_nbits, genfifoentry);\n+\n+\treturn 0;\n }\n \n /**\n@@ -1031,8 +1041,11\
    \ @@ static int zynqmp_qspi_exec_op(struct spi_mem *mem,\n \t\t\txqspi->rxbuf\
    \ = (u8 *)op->data.buf.in;\n \t\t\txqspi->bytes_to_receive = op->data.nbytes;\n\
    \ \t\t\txqspi->bytes_to_transfer = 0;\n-\t\t\tzynqmp_qspi_read_op(xqspi, op->data.buswidth,\n\
    +\t\t\terr = zynqmp_qspi_read_op(xqspi, op->data.buswidth,\n \t\t\t\t\t    genfifoentry);\n\
    +\t\t\tif (err)\n+\t\t\t\tgoto return_err;\n+\n \t\t\tzynqmp_gqspi_write(xqspi,\
    \ GQSPI_CONFIG_OFST,\n \t\t\t\t\t   zynqmp_gqspi_read\n \t\t\t\t\t   (xqspi, GQSPI_CONFIG_OFST)\
    \ |\n@@ -1159,6 +1172,7 @@ static int zynqmp_qspi_probe(struct platform_device\
    \ *pdev)\n \t\tgoto clk_dis_all;\n \t}\n \n+\tdma_set_mask(&pdev->dev, DMA_BIT_MASK(44));\n\
    \ \tctlr->bits_per_word_mask = SPI_BPW_MASK(8);\n \tctlr->num_chipselect = GQSPI_DEFAULT_NUM_CS;\n\
    \ \tctlr->mem_ops = &zynqmp_qspi_mem_ops;"
  identifiers: CVE:["CVE-2021-47047"],CWE:["CWE-400"]
  overview: Affected versions of this package are vulnerable to Resource Exhaustion
    due to the improper handling of memory allocation failures within the `spi-zynqmp-gqspi`
    function. An attacker with local access can cause a denial of service condition
    by triggering a failure in memory allocation.
  references:
    GitHub Commit: https://github.com/torvalds/linux/commit/126bdb606fd2802454e6048caef1be3e25dd121e
    RedHat Bugzilla Bug: https://bugzilla.redhat.com/show_bug.cgi?id=2266758
    Vulnerability Advisory: https://lore.kernel.org/linux-cve-announce/2024022839-CVE-2021-47047-4c75@gregkh/T/#u
  title: Resource Exhaustion
- diff_content:
  - "--- a/drivers/mmc/host/uniphier-sd.c\n+++ b/drivers/mmc/host/uniphier-sd.c\n\
    @@ -660,6 +660,7 @@ static int uniphier_sd_remove(struct platform_device *pdev)\n\
    \ \n \ttmio_mmc_host_remove(host);\n \tuniphier_sd_clk_disable(host);\n+\ttmio_mmc_host_free(host);\n\
    \ \n \treturn 0;\n }"
  identifiers: CVE:["CVE-2021-46962"],CWE:["CWE-400"]
  overview: Affected versions of this package are vulnerable to Resource Exhaustion
    due to a resource leak in the `remove` function. An attacker can cause a denial
    of service by exploiting the improper resource management.
  references:
    GitHub Commit: https://github.com/torvalds/linux/commit/e29c84857e2d51aa017ce04284b962742fb97d9e
    RedHat Bugzilla Bug: https://bugzilla.redhat.com/show_bug.cgi?id=2266818
    Vulnerability Advisory: https://lore.kernel.org/linux-cve-announce/2024022719-CVE-2021-46962-e081@gregkh/T/#u
  title: Resource Exhaustion
- diff_content:
  - "--- a/drivers/mtd/maps/physmap-bt1-rom.c\n+++ b/drivers/mtd/maps/physmap-bt1-rom.c\n\
    @@ -79,7 +79,7 @@ static void __xipram bt1_rom_map_copy_from(struct map_info *map,\n\
    \ \tif (shift) {\n \t\tchunk = min_t(ssize_t, 4 - shift, len);\n \t\tdata = readl_relaxed(src\
    \ - shift);\n-\t\tmemcpy(to, &data + shift, chunk);\n+\t\tmemcpy(to, (char *)&data\
    \ + shift, chunk);\n \t\tsrc += chunk;\n \t\tto += chunk;\n \t\tlen -= chunk;"
  identifiers: CVE:["CVE-2021-46965"],CWE:["CWE-787"]
  overview: Affected versions of this package are vulnerable to Out-of-bounds Write
    due to unintentional stack access. An attacker can cause a denial of service by
    exploiting this vulnerability.
  references:
    GitHub Commit: https://github.com/torvalds/linux/commit/683313993dbe1651c7aa00bb42a041d70e914925
    RedHat Bugzilla Bug: https://bugzilla.redhat.com/show_bug.cgi?id=2266812
    Vulnerability Advisory: https://lore.kernel.org/linux-cve-announce/2024022719-CVE-2021-46965-3b74@gregkh/T/#u
  title: Out-of-bounds Write
- diff_content:
  - "--- a/drivers/scsi/qla2xxx/qla_isr.c\n+++ b/drivers/scsi/qla2xxx/qla_isr.c\n\
    @@ -3998,11 +3998,11 @@ qla24xx_enable_msix(struct qla_hw_data *ha, struct rsp_que\
    \ *rsp)\n \tif (USER_CTRL_IRQ(ha) || !ha->mqiobase) {\n \t\t/* user wants to control\
    \ IRQ setting for target mode */\n \t\tret = pci_alloc_irq_vectors(ha->pdev, min_vecs,\n\
    -\t\t    min((u16)ha->msix_count, (u16)num_online_cpus()),\n+\t\t    min((u16)ha->msix_count,\
    \ (u16)(num_online_cpus() + min_vecs)),\n \t\t    PCI_IRQ_MSIX);\n \t} else\n\
    \ \t\tret = pci_alloc_irq_vectors_affinity(ha->pdev, min_vecs,\n-\t\t    min((u16)ha->msix_count,\
    \ (u16)num_online_cpus()),\n+\t\t    min((u16)ha->msix_count, (u16)(num_online_cpus()\
    \ + min_vecs)),\n \t\t    PCI_IRQ_MSIX | PCI_IRQ_AFFINITY,\n \t\t    &desc);\n\
    \ "
  identifiers: CVE:["CVE-2021-46964"],CWE:["CWE-400"]
  overview: Affected versions of this package are vulnerable to Resource Exhaustion
    due to the improper reservation of extra IRQ vectors. An attacker can cause a
    denial of service condition by exploiting this flaw in the IRQ handling mechanism.
  references:
    GitHub Commit: https://github.com/torvalds/linux/commit/f02d4086a8f36a0e1aaebf559b54cf24a177a486
    RedHat Bugzilla Bug: https://bugzilla.redhat.com/show_bug.cgi?id=2266814
    Vulnerability Advisory: https://lore.kernel.org/linux-cve-announce/2024022719-CVE-2021-46964-da8c@gregkh/T/#u
  title: Resource Exhaustion
- diff_content:
  - "--- a/drivers/net/ethernet/broadcom/bnxt/bnxt.c\n+++ b/drivers/net/ethernet/broadcom/bnxt/bnxt.c\n\
    @@ -1732,14 +1732,16 @@ static int bnxt_rx_pkt(struct bnxt *bp, struct bnxt_cp_ring_info\
    \ *cpr,\n \n \tcons = rxcmp->rx_cmp_opaque;\n \tif (unlikely(cons != rxr->rx_next_cons))\
    \ {\n-\t\tint rc1 = bnxt_discard_rx(bp, cpr, raw_cons, rxcmp);\n+\t\tint rc1 =\
    \ bnxt_discard_rx(bp, cpr, &tmp_raw_cons, rxcmp);\n \n \t\t/* 0xffff is forced\
    \ error, don't print it */\n \t\tif (rxr->rx_next_cons != 0xffff)\n \t\t\tnetdev_warn(bp->dev,\
    \ \"RX cons %x != expected cons %x\\n\",\n \t\t\t\t    cons, rxr->rx_next_cons);\n\
    \ \t\tbnxt_sched_reset(bp, rxr);\n-\t\treturn rc1;\n+\t\tif (rc1)\n+\t\t\treturn\
    \ rc1;\n+\t\tgoto next_rx_no_prod_no_len;\n \t}\n \trx_buf = &rxr->rx_buf_ring[cons];\n\
    \ \tdata = rx_buf->data;"
  identifiers: CVE:["CVE-2021-47015"],CWE:["CWE-770"]
  overview: Affected versions of this package are vulnerable to Allocation of Resources
    Without Limits or Throttling due to improper handling of the RX consumer index
    logic in the error path. An attacker can cause a denial of service condition by
    triggering this logic flaw.
  references:
    GitHub Commit: https://github.com/torvalds/linux/commit/bbd6f0a948139970f4a615dff189d9a503681a39
    RedHat Bugzilla Bug: https://bugzilla.redhat.com/show_bug.cgi?id=2266760
    Vulnerability Advisory: https://lore.kernel.org/linux-cve-announce/2024022832-CVE-2021-47015-c2ae@gregkh/T/#u
  title: Allocation of Resources Without Limits or Throttling
- diff_content:
  - "--- a/drivers/thermal/cpufreq_cooling.c\n+++ b/drivers/thermal/cpufreq_cooling.c\n\
    @@ -116,7 +116,7 @@ static u32 cpu_power_to_freq(struct cpufreq_cooling_device\
    \ *cpufreq_cdev,\n {\n \tint i;\n \n-\tfor (i = cpufreq_cdev->max_level; i >=\
    \ 0; i--) {\n+\tfor (i = cpufreq_cdev->max_level; i > 0; i--) {\n \t\tif (power\
    \ >= cpufreq_cdev->em->table[i].power)\n \t\t\tbreak;\n \t}"
  identifiers: CVE:["CVE-2020-36776"],CWE:["CWE-787"]
  overview: Affected versions of this package are vulnerable to Out-of-bounds Write
    due to improper handling in the `cpufreq_cooling` component. An attacker with
    local access can cause a denial of service by exploiting this vulnerability.
  references:
    GitHub Commit: https://github.com/torvalds/linux/commit/34ab17cc6c2c1ac93d7e5d53bb972df9a968f085
    RedHat Bugzilla Bug: https://bugzilla.redhat.com/show_bug.cgi?id=2266748
    Vulnerability Advisory: https://lore.kernel.org/linux-cve-announce/20240227184057.2368370-1-gregkh@linuxfoundation.org/T/#u
  title: Out-of-bounds Write
- diff_content:
  - "--- a/net/sched/act_ct.c\n+++ b/net/sched/act_ct.c\n@@ -732,7 +732,8 @@ static\
    \ int tcf_ct_handle_fragments(struct net *net, struct sk_buff *skb,\n #endif\n\
    \ \t}\n \n-\t*qdisc_skb_cb(skb) = cb;\n+\tif (err != -EINPROGRESS)\n+\t\t*qdisc_skb_cb(skb)\
    \ = cb;\n \tskb_clear_hash(skb);\n \tskb->ignore_df = 1;\n \treturn err;\n@@ -967,7\
    \ +968,7 @@ static int tcf_ct_act(struct sk_buff *skb, const struct tc_action\
    \ *a,\n \terr = tcf_ct_handle_fragments(net, skb, family, p->zone, &defrag);\n\
    \ \tif (err == -EINPROGRESS) {\n \t\tretval = TC_ACT_STOLEN;\n-\t\tgoto out;\n\
    +\t\tgoto out_clear;\n \t}\n \tif (err)\n \t\tgoto drop;\n@@ -1030,7 +1031,6 @@\
    \ static int tcf_ct_act(struct sk_buff *skb, const struct tc_action *a,\n out_push:\n\
    \ \tskb_push_rcsum(skb, nh_ofs);\n \n-out:\n \tqdisc_skb_cb(skb)->post_ct = true;\n\
    \ out_clear:\n \ttcf_action_update_bstats(&c->common, skb);"
  identifiers: CVE:["CVE-2021-47014"],CWE:["CWE-787"]
  overview: Affected versions of this package are vulnerable to Out-of-bounds Write
    due to improper handling of memory operations when clearing fragments in the `act_ct`
    module of the net/sched component. An attacker with local access can cause a denial
    of service by triggering wild memory access.
  references:
    GitHub Commit: https://github.com/torvalds/linux/commit/f77bd544a6bbe69aa50d9ed09f13494cf36ff806
    RedHat Bugzilla Bug: https://bugzilla.redhat.com/show_bug.cgi?id=2266738
    Vulnerability Advisory: https://lore.kernel.org/linux-cve-announce/2024022831-CVE-2021-47014-ffc7@gregkh/T/#u
  title: Out-of-bounds Write
- diff_content:
  - "--- a/drivers/crypto/allwinner/sun8i-ss/sun8i-ss-hash.c\n+++ b/drivers/crypto/allwinner/sun8i-ss/sun8i-ss-hash.c\n\
    @@ -348,8 +348,10 @@ int sun8i_ss_hash_run(struct crypto_engine *engine, void\
    \ *breq)\n \tbf = (__le32 *)pad;\n \n \tresult = kzalloc(digestsize, GFP_KERNEL\
    \ | GFP_DMA);\n-\tif (!result)\n+\tif (!result) {\n+\t\tkfree(pad);\n \t\treturn\
    \ -ENOMEM;\n+\t}\n \n \tfor (i = 0; i < MAX_SG; i++) {\n \t\trctx->t_dst[i].addr\
    \ = 0;"
  identifiers: CVE:["CVE-2021-47053"],CWE:["CWE-400"]
  overview: Affected versions of this package are vulnerable to Resource Exhaustion
    due to improper handling of memory allocation in the `sun8i-ss` driver. An attacker
    with local access can cause a denial of service condition by triggering a memory
    leak.
  references:
    GitHub Commit: https://github.com/torvalds/linux/commit/50274b01ac1689b1a3f6bc4b5b3dbf361a55dd3a
    RedHat Bugzilla Bug: https://bugzilla.redhat.com/show_bug.cgi?id=2266720
    Vulnerability Advisory: https://lore.kernel.org/linux-cve-announce/2024022841-CVE-2021-47053-c68d@gregkh/T/#u
  title: Resource Exhaustion
- diff_content:
  - "--- a/fs/overlayfs/namei.c\n+++ b/fs/overlayfs/namei.c\n@@ -919,6 +919,7 @@ struct\
    \ dentry *ovl_lookup(struct inode *dir, struct dentry *dentry,\n \t\t\tcontinue;\n\
    \ \n \t\tif ((uppermetacopy || d.metacopy) && !ofs->config.metacopy) {\n+\t\t\t\
    dput(this);\n \t\t\terr = -EPERM;\n \t\t\tpr_warn_ratelimited(\"refusing to follow\
    \ metacopy origin for (%pd2)\\n\", dentry);\n \t\t\tgoto out_put;"
  identifiers: CVE:["CVE-2021-46972"],CWE:["CWE-400"]
  overview: Affected versions of this package are vulnerable to Uncontrolled Resource
    Consumption ('Resource Exhaustion') due to improper handling of overlay file systems.
    An attacker with local access can cause a denial of service condition by exploiting
    the way `dentry` objects are managed.
  references:
    GitHub Commit: https://github.com/torvalds/linux/commit/eaab1d45cdb4bb0c846bd23c3d666d5b90af7b41
  title: Uncontrolled Resource Consumption ('Resource Exhaustion')
- diff_content:
  - "--- a/net/qrtr/mhi.c\n+++ b/net/qrtr/mhi.c\n@@ -50,6 +50,9 @@ static int qcom_mhi_qrtr_send(struct\
    \ qrtr_endpoint *ep, struct sk_buff *skb)\n \tstruct qrtr_mhi_dev *qdev = container_of(ep,\
    \ struct qrtr_mhi_dev, ep);\n \tint rc;\n \n+\tif (skb->sk)\n+\t\tsock_hold(skb->sk);\n\
    +\n \trc = skb_linearize(skb);\n \tif (rc)\n \t\tgoto free_skb;\n@@ -59,12 +62,11\
    \ @@ static int qcom_mhi_qrtr_send(struct qrtr_endpoint *ep, struct sk_buff *skb)\n\
    \ \tif (rc)\n \t\tgoto free_skb;\n \n-\tif (skb->sk)\n-\t\tsock_hold(skb->sk);\n\
    -\n \treturn rc;\n \n free_skb:\n+\tif (skb->sk)\n+\t\tsock_put(skb->sk);\n \t\
    kfree_skb(skb);\n \n \treturn rc;"
  identifiers: CVE:["CVE-2021-46973"],CWE:["CWE-416"]
  overview: Affected versions of this package are vulnerable to Use After Free due
    to improper handling in the `qrtr` module. An attacker can cause a denial of service
    or potentially execute arbitrary code.
  references:
    GitHub Commit: https://github.com/torvalds/linux/commit/47a017f33943278570c072bc71681809b2567b3a
  title: Use After Free
- diff_content:
  - "--- a/arch/arm/kernel/hw_breakpoint.c\n+++ b/arch/arm/kernel/hw_breakpoint.c\n\
    @@ -886,7 +886,7 @@ static void breakpoint_handler(unsigned long unknown, struct\
    \ pt_regs *regs)\n \t\t\tinfo->trigger = addr;\n \t\t\tpr_debug(\"breakpoint fired:\
    \ address = 0x%x\\n\", addr);\n \t\t\tperf_bp_event(bp, regs);\n-\t\t\tif (!bp->overflow_handler)\n\
    +\t\t\tif (is_default_overflow_handler(bp))\n \t\t\t\tenable_single_step(bp, addr);\n\
    \ \t\t\tgoto unlock;\n \t\t}"
  identifiers: CVE:["CVE-2021-47006"],CWE:["CWE-119"]
  overview: Affected versions of this package are vulnerable to Buffer Overflow due
    to improper validation of user-supplied input through the `hw_breakpoint` function.
    An attacker can cause a denial of service condition.
  references:
    GitHub Commit: https://github.com/torvalds/linux/commit/a506bd5756290821a4314f502b4bafc2afcf5260
  title: Buffer Overflow
- diff_content:
  - "--- a/drivers/vhost/vdpa.c\n+++ b/drivers/vhost/vdpa.c\n@@ -993,6 +993,7 @@ static\
    \ int vhost_vdpa_mmap(struct file *file, struct vm_area_struct *vma)\n \tif (vma->vm_end\
    \ - vma->vm_start != notify.size)\n \t\treturn -ENOTSUPP;\n \n+\tvma->vm_flags\
    \ |= VM_IO | VM_PFNMAP | VM_DONTEXPAND | VM_DONTDUMP;\n \tvma->vm_ops = &vhost_vdpa_vm_ops;\n\
    \ \treturn 0;\n }"
  identifiers: CVE:["CVE-2021-46967"],CWE:["CWE-400"]
  overview: Affected versions of this package are vulnerable to Resource Exhaustion
    due to improper handling of `vm_flags` for virtqueue doorbell mapping. An attacker
    can cause a denial of service by exploiting this flaw.
  references:
    GitHub Commit: https://github.com/torvalds/linux/commit/3a3e0fad16d40a2aa68ddf7eea4acdf48b22dd44
  title: Resource Exhaustion
- diff_content:
  - "--- a/drivers/s390/crypto/zcrypt_card.c\n+++ b/drivers/s390/crypto/zcrypt_card.c\n\
    @@ -192,5 +192,6 @@ void zcrypt_card_unregister(struct zcrypt_card *zc)\n \tspin_unlock(&zcrypt_list_lock);\n\
    \ \tsysfs_remove_group(&zc->card->ap_dev.device.kobj,\n \t\t\t   &zcrypt_card_attr_group);\n\
    +\tzcrypt_card_put(zc);\n }\n EXPORT_SYMBOL(zcrypt_card_unregister);"
  - "--- a/drivers/s390/crypto/zcrypt_queue.c\n+++ b/drivers/s390/crypto/zcrypt_queue.c\n\
    @@ -223,5 +223,6 @@ void zcrypt_queue_unregister(struct zcrypt_queue *zq)\n \t\
    sysfs_remove_group(&zq->queue->ap_dev.device.kobj,\n \t\t\t   &zcrypt_queue_attr_group);\n\
    \ \tzcrypt_card_put(zc);\n+\tzcrypt_queue_put(zq);\n }\n EXPORT_SYMBOL(zcrypt_queue_unregister);"
  identifiers: CVE:["CVE-2021-46968"],CWE:["CWE-400"]
  overview: Affected versions of this package are vulnerable to Resource Exhaustion
    due to improper handling of hardware component hot-unplug events. An attacker
    with local access can cause a denial of service by triggering a memory leak during
    the hot-unplug process of `zcard` and `zqueue` components.
  references:
    GitHub Commit: https://github.com/torvalds/linux/commit/70fac8088cfad9f3b379c9082832b4d7532c16c2
  title: Resource Exhaustion
- diff_content:
  - "--- a/src/link.c\n+++ b/src/link.c\n@@ -404,9 +404,9 @@ static void link_frame_received(void*\
    \ context, AMQP_VALUE performative, uint32_t\n                     }\n       \
    \          }\n             }\n-        }\n \n-        flow_destroy(flow_handle);\n\
    +            flow_destroy(flow_handle);\n+        }\n     }\n     else if (is_transfer_type_by_descriptor(descriptor))\n\
    \     {"
  - '--- a/tests/link_ut/link_ut.c

    +++ b/tests/link_ut/link_ut.c

    @@ -0,0 +1,477 @@

    +// Copyright (c) Microsoft. All rights reserved.

    +// Licensed under the MIT license. See LICENSE file in the project root for full
    license information.

    +

    +#ifdef __cplusplus

    +#include <cstdlib>

    +#include <cstdio>

    +#include <cstdint>

    +#else

    +#include <stdlib.h>

    +#include <string.h>

    +#include <stdint.h>

    +#include <stdbool.h>

    +#endif

    +

    +#include "azure_macro_utils/macro_utils.h"

    +#include "testrunnerswitcher.h"

    +#include "umock_c/umock_c.h"

    +#include "umock_c/umock_c_negative_tests.h"

    +#include "umock_c/umocktypes_bool.h"

    +

    +static void* my_gballoc_malloc(size_t size)

    +{

    +    return malloc(size);

    +}

    +

    +static void* my_gballoc_calloc(size_t nmemb, size_t size)

    +{

    +    return calloc(nmemb, size);

    +}

    +

    +static void* my_gballoc_realloc(void* ptr, size_t size)

    +{

    +    return realloc(ptr, size);

    +}

    +

    +static void my_gballoc_free(void* ptr)

    +{

    +    free(ptr);

    +}

    +

    +#define ENABLE_MOCKS

    +

    +#include "azure_c_shared_utility/gballoc.h"

    +#include "azure_c_shared_utility/singlylinkedlist.h"

    +#include "azure_c_shared_utility/tickcounter.h"

    +#include "azure_uamqp_c/session.h"

    +#include "azure_uamqp_c/amqpvalue.h"

    +#include "azure_uamqp_c/amqp_definitions.h"

    +#include "azure_uamqp_c/amqp_frame_codec.h"

    +#include "azure_uamqp_c/async_operation.h"

    +

    +#undef ENABLE_MOCKS

    +

    +#include "azure_uamqp_c/link.h"

    +

    +static SESSION_HANDLE TEST_SESSION_HANDLE = (SESSION_HANDLE)0x4000;

    +const char* TEST_LINK_NAME_1 = "test_link_name_1";

    +static TICK_COUNTER_HANDLE TEST_TICK_COUNTER_HANDLE = (TICK_COUNTER_HANDLE)0x4001;

    +static SINGLYLINKEDLIST_HANDLE TEST_SINGLYLINKEDLIST_HANDLE = (SINGLYLINKEDLIST_HANDLE)0x4002;

    +static LINK_ENDPOINT_HANDLE TEST_LINK_ENDPOINT = (LINK_ENDPOINT_HANDLE)0x4003;

    +const AMQP_VALUE TEST_LINK_SOURCE = (AMQP_VALUE)0x4004;

    +const AMQP_VALUE TEST_LINK_TARGET = (AMQP_VALUE)0x4005;

    +

    +static TEST_MUTEX_HANDLE g_testByTest;

    +

    +MU_DEFINE_ENUM_STRINGS(UMOCK_C_ERROR_CODE, UMOCK_C_ERROR_CODE_VALUES)

    +

    +static void on_umock_c_error(UMOCK_C_ERROR_CODE error_code)

    +{

    +    ASSERT_FAIL("umock_c reported error :%" PRI_MU_ENUM "", MU_ENUM_VALUE(UMOCK_C_ERROR_CODE,
    error_code));

    +}

    +

    +static int umocktypes_copy_bool_ptr(bool** destination, const bool** source)

    +{

    +    int result;

    +

    +    *destination = (bool*)my_gballoc_malloc(sizeof(bool));

    +    if (*destination == NULL)

    +    {

    +        result = MU_FAILURE;

    +    }

    +    else

    +    {

    +        *(*destination) = *(*source);

    +

    +        result = 0;

    +    }

    +

    +    return result;

    +}

    +

    +static void umocktypes_free_bool_ptr(bool** value)

    +{

    +    if (*value != NULL)

    +    {

    +        my_gballoc_free(*value);

    +    }

    +}

    +

    +static char* umocktypes_stringify_bool_ptr(const bool** value)

    +{

    +    char* result;

    +

    +    result = (char*)my_gballoc_malloc(8);

    +    if (result != NULL)

    +    {

    +        if (*value == NULL)

    +        {

    +            (void)strcpy(result, "{NULL}");

    +        }

    +        else if (*(*value) == true)

    +        {

    +            (void)strcpy(result, "{true}");

    +        }

    +        else

    +        {

    +            (void)strcpy(result, "{false}");

    +        }

    +    }

    +

    +    return result;

    +}

    +

    +static int umocktypes_are_equal_bool_ptr(bool** left, bool** right)

    +{

    +    int result;

    +

    +    if (*left == *right)

    +    {

    +        result = 1;

    +    }

    +    else

    +    {

    +        if (*(*left) == *(*right))

    +        {

    +            result = 1;

    +        }

    +        else

    +        {

    +            result = 0;

    +        }

    +    }

    +

    +    return result;

    +}

    +

    +static int umocktypes_copy_FLOW_HANDLE(FLOW_HANDLE* destination, const FLOW_HANDLE*
    source)

    +{

    +    int result = 0;

    +

    +    *(destination) = *(source);

    +

    +    return result;

    +}

    +

    +static void umocktypes_free_FLOW_HANDLE(FLOW_HANDLE* value)

    +{

    +    (void)value;

    +}

    +

    +static char* umocktypes_stringify_FLOW_HANDLE(const FLOW_HANDLE* value)

    +{

    +    char temp_buffer[32];

    +    char* result;

    +    size_t length = sprintf(temp_buffer, "%p", (void*)*value);

    +    if (length < 0)

    +    {

    +        result = NULL;

    +    }

    +    else

    +    {

    +        result = (char*)malloc(length + 1);

    +        if (result != NULL)

    +        {

    +            (void)memcpy(result, temp_buffer, length + 1);

    +        }

    +    }

    +    return result;

    +}

    +

    +static int umocktypes_are_equal_FLOW_HANDLE(FLOW_HANDLE* left, FLOW_HANDLE* right)

    +{

    +    int result;

    +

    +    if (*left == *right)

    +    {

    +        result = 1;

    +    }

    +    else

    +    {

    +        result = 0;

    +    }

    +

    +    return result;

    +}

    +

    +static TRANSFER_HANDLE test_on_transfer_received_transfer;

    +static uint32_t test_on_transfer_received_payload_size;

    +static unsigned char test_on_transfer_received_payload_bytes[2048];

    +static AMQP_VALUE test_on_transfer_received(void* context, TRANSFER_HANDLE transfer,
    uint32_t payload_size, const unsigned char* payload_bytes)

    +{

    +    (void)context;

    +    test_on_transfer_received_transfer = transfer;

    +    test_on_transfer_received_payload_size = payload_size;

    +    memcpy(test_on_transfer_received_payload_bytes, payload_bytes, payload_size);

    +

    +    return (AMQP_VALUE)0x6000;

    +}

    +

    +static LINK_STATE test_on_link_state_changed_new_link_state;

    +LINK_STATE test_on_link_state_changed_previous_link_state;

    +static void test_on_link_state_changed(void* context, LINK_STATE new_link_state,
    LINK_STATE previous_link_state)

    +{

    +    (void)context;

    +    test_on_link_state_changed_new_link_state = new_link_state;

    +    test_on_link_state_changed_previous_link_state = previous_link_state;

    +}

    +

    +static void test_on_link_flow_on(void* context)

    +{

    +    (void)context;

    +}

    +

    +static LINK_HANDLE create_link(role link_role)

    +{

    +    umock_c_reset_all_calls();

    +

    +    STRICT_EXPECTED_CALL(gballoc_calloc(IGNORED_NUM_ARG, IGNORED_NUM_ARG));

    +    STRICT_EXPECTED_CALL(amqpvalue_clone(IGNORED_PTR_ARG));

    +    STRICT_EXPECTED_CALL(amqpvalue_clone(IGNORED_PTR_ARG));

    +    STRICT_EXPECTED_CALL(tickcounter_create());

    +    STRICT_EXPECTED_CALL(singlylinkedlist_create());

    +    STRICT_EXPECTED_CALL(gballoc_malloc(IGNORED_NUM_ARG));

    +    STRICT_EXPECTED_CALL(session_create_link_endpoint(TEST_SESSION_HANDLE, TEST_LINK_NAME_1));

    +    STRICT_EXPECTED_CALL(session_set_link_endpoint_callback(TEST_LINK_ENDPOINT,
    IGNORED_PTR_ARG, IGNORED_PTR_ARG));

    +

    +    return link_create(TEST_SESSION_HANDLE, TEST_LINK_NAME_1, link_role, TEST_LINK_SOURCE,
    TEST_LINK_TARGET);

    +}

    +

    +static int attach_link(LINK_HANDLE link, ON_ENDPOINT_FRAME_RECEIVED* on_frame_received)

    +{

    +    umock_c_reset_all_calls();

    +

    +    STRICT_EXPECTED_CALL(session_begin(TEST_SESSION_HANDLE));

    +    STRICT_EXPECTED_CALL(session_start_link_endpoint(TEST_LINK_ENDPOINT, IGNORED_PTR_ARG,
    IGNORED_PTR_ARG, IGNORED_PTR_ARG, link))

    +        .CaptureArgumentValue_frame_received_callback(on_frame_received);

    +

    +    return link_attach(link, test_on_transfer_received, test_on_link_state_changed,
    test_on_link_flow_on, NULL);

    +}

    +

    +BEGIN_TEST_SUITE(link_ut)

    +

    +TEST_SUITE_INITIALIZE(suite_init)

    +{

    +    int result;

    +

    +    g_testByTest = TEST_MUTEX_CREATE();

    +    ASSERT_IS_NOT_NULL(g_testByTest);

    +

    +    umock_c_init(on_umock_c_error);

    +

    +    result = umocktypes_bool_register_types();

    +    ASSERT_ARE_EQUAL(int, 0, result, "Failed registering bool types");

    +

    +    REGISTER_GLOBAL_MOCK_HOOK(gballoc_malloc, my_gballoc_malloc);

    +    REGISTER_GLOBAL_MOCK_HOOK(gballoc_calloc, my_gballoc_calloc);

    +    REGISTER_GLOBAL_MOCK_HOOK(gballoc_realloc, my_gballoc_realloc);

    +    REGISTER_GLOBAL_MOCK_HOOK(gballoc_free, my_gballoc_free);

    +    REGISTER_UMOCK_ALIAS_TYPE(AMQP_VALUE, void*);

    +    REGISTER_UMOCK_ALIAS_TYPE(TICK_COUNTER_HANDLE, void*);

    +    REGISTER_UMOCK_ALIAS_TYPE(SINGLYLINKEDLIST_HANDLE, void*);

    +    REGISTER_UMOCK_ALIAS_TYPE(SESSION_HANDLE, void*);

    +    REGISTER_UMOCK_ALIAS_TYPE(LINK_ENDPOINT_HANDLE, void*);

    +    REGISTER_UMOCK_ALIAS_TYPE(ON_LINK_ENDPOINT_DESTROYED_CALLBACK, void*);

    +    REGISTER_UMOCK_ALIAS_TYPE(ON_ENDPOINT_FRAME_RECEIVED, void*);

    +    REGISTER_UMOCK_ALIAS_TYPE(ON_TRANSFER_RECEIVED, void*);

    +    REGISTER_UMOCK_ALIAS_TYPE(ON_LINK_STATE_CHANGED, void*);

    +    REGISTER_UMOCK_ALIAS_TYPE(ON_LINK_FLOW_ON, void*);

    +    REGISTER_UMOCK_ALIAS_TYPE(ON_SESSION_STATE_CHANGED, void*);

    +    REGISTER_UMOCK_ALIAS_TYPE(ON_SESSION_FLOW_ON, void*);

    +

    +    REGISTER_GLOBAL_MOCK_RETURNS(tickcounter_create, TEST_TICK_COUNTER_HANDLE,
    NULL);

    +    REGISTER_GLOBAL_MOCK_RETURNS(singlylinkedlist_create, TEST_SINGLYLINKEDLIST_HANDLE,
    NULL);

    +    REGISTER_GLOBAL_MOCK_RETURNS(session_create_link_endpoint, TEST_LINK_ENDPOINT,
    NULL);

    +    REGISTER_GLOBAL_MOCK_RETURNS(session_start_link_endpoint, 0, 1);

    +

    +    REGISTER_TYPE(FLOW_HANDLE, FLOW_HANDLE);

    +    REGISTER_TYPE(bool*, bool_ptr);

    +}

    +

    +TEST_SUITE_CLEANUP(suite_cleanup)

    +{

    +    umock_c_deinit();

    +

    +    TEST_MUTEX_DESTROY(g_testByTest);

    +}

    +

    +TEST_FUNCTION_INITIALIZE(test_init)

    +{

    +    if (TEST_MUTEX_ACQUIRE(g_testByTest))

    +    {

    +        ASSERT_FAIL("our mutex is ABANDONED. Failure in test framework");

    +    }

    +

    +    umock_c_reset_all_calls();

    +}

    +

    +TEST_FUNCTION_CLEANUP(test_cleanup)

    +{

    +    TEST_MUTEX_RELEASE(g_testByTest);

    +}

    +

    +TEST_FUNCTION(link_create_succeeds)

    +{

    +    // arrange

    +    AMQP_VALUE link_source = TEST_LINK_SOURCE;

    +    AMQP_VALUE link_target = TEST_LINK_TARGET;

    +

    +    umock_c_reset_all_calls();

    +

    +    STRICT_EXPECTED_CALL(gballoc_calloc(IGNORED_NUM_ARG, IGNORED_NUM_ARG));

    +    STRICT_EXPECTED_CALL(amqpvalue_clone(IGNORED_PTR_ARG));

    +    STRICT_EXPECTED_CALL(amqpvalue_clone(IGNORED_PTR_ARG));

    +    STRICT_EXPECTED_CALL(tickcounter_create());

    +    STRICT_EXPECTED_CALL(singlylinkedlist_create());

    +    STRICT_EXPECTED_CALL(gballoc_malloc(IGNORED_NUM_ARG));

    +    STRICT_EXPECTED_CALL(session_create_link_endpoint(TEST_SESSION_HANDLE, TEST_LINK_NAME_1));

    +    STRICT_EXPECTED_CALL(session_set_link_endpoint_callback(TEST_LINK_ENDPOINT,
    IGNORED_PTR_ARG, IGNORED_PTR_ARG));

    +

    +    // act

    +    LINK_HANDLE link = link_create(TEST_SESSION_HANDLE, TEST_LINK_NAME_1, role_receiver,
    link_source, link_target);

    +

    +    // assert

    +    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());

    +    ASSERT_IS_NOT_NULL(link);

    +

    +    // cleanup

    +    link_destroy(link);

    +}

    +

    +TEST_FUNCTION(link_attach_succeeds)

    +{

    +    // arrange

    +    LINK_HANDLE link = create_link(role_receiver);

    +    ON_ENDPOINT_FRAME_RECEIVED on_frame_received = NULL;

    +

    +    umock_c_reset_all_calls();

    +

    +    STRICT_EXPECTED_CALL(session_begin(TEST_SESSION_HANDLE));

    +    STRICT_EXPECTED_CALL(session_start_link_endpoint(TEST_LINK_ENDPOINT, IGNORED_PTR_ARG,
    IGNORED_PTR_ARG, IGNORED_PTR_ARG, link))

    +        .CaptureArgumentValue_frame_received_callback(&on_frame_received);

    +

    +    // act

    +    int result = link_attach(link, test_on_transfer_received, test_on_link_state_changed,
    test_on_link_flow_on, NULL);

    +

    +    // assert

    +    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());

    +    ASSERT_ARE_EQUAL(int, 0, result);

    +    ASSERT_IS_NOT_NULL(on_frame_received);

    +

    +    // cleanup

    +    link_destroy(link);

    +}

    +

    +TEST_FUNCTION(link_receiver_frame_received_succeeds)

    +{

    +    // arrange

    +    LINK_HANDLE link = create_link(role_receiver);

    +    ON_ENDPOINT_FRAME_RECEIVED on_frame_received = NULL;

    +    int attach_result = attach_link(link, &on_frame_received);

    +    ASSERT_ARE_EQUAL(int, 0, attach_result);

    +

    +    AMQP_VALUE performative = (AMQP_VALUE)0x5000;

    +    AMQP_VALUE descriptor = (AMQP_VALUE)0x5001;

    +    FLOW_HANDLE flow = (FLOW_HANDLE)0x5002;

    +    uint32_t frame_payload_size = 30;

    +    const unsigned char payload_bytes[30] = { 0 };

    +

    +    umock_c_reset_all_calls();

    +    STRICT_EXPECTED_CALL(amqpvalue_get_inplace_descriptor(performative))

    +        .SetReturn(descriptor);

    +    STRICT_EXPECTED_CALL(is_attach_type_by_descriptor(IGNORED_PTR_ARG))

    +        .SetReturn(false);

    +    STRICT_EXPECTED_CALL(is_flow_type_by_descriptor(IGNORED_PTR_ARG))

    +        .SetReturn(1);

    +    STRICT_EXPECTED_CALL(amqpvalue_get_flow(IGNORED_PTR_ARG, IGNORED_PTR_ARG))

    +        .CopyOutArgumentBuffer(2, &flow, sizeof(flow));

    +    STRICT_EXPECTED_CALL(flow_destroy(IGNORED_PTR_ARG));

    +

    +    // act

    +    on_frame_received(link, performative, frame_payload_size, payload_bytes);

    +

    +    // assert

    +    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());

    +

    +    // cleanup

    +    link_destroy(link);

    +}

    +

    +TEST_FUNCTION(link_sender_frame_received_succeeds)

    +{

    +    // arrange

    +    LINK_HANDLE link = create_link(role_sender);

    +    ON_ENDPOINT_FRAME_RECEIVED on_frame_received = NULL;

    +    int attach_result = attach_link(link, &on_frame_received);

    +    ASSERT_ARE_EQUAL(int, 0, attach_result);

    +

    +    AMQP_VALUE performative = (AMQP_VALUE)0x5000;

    +    AMQP_VALUE descriptor = (AMQP_VALUE)0x5001;

    +    FLOW_HANDLE flow = (FLOW_HANDLE)0x5002;

    +    uint32_t frame_payload_size = 30;

    +    const unsigned char payload_bytes[30] = { 0 };

    +    uint32_t link_credit_value = 700;

    +    uint32_t delivery_count_value = 300;

    +

    +    umock_c_reset_all_calls();

    +    STRICT_EXPECTED_CALL(amqpvalue_get_inplace_descriptor(performative))

    +        .SetReturn(descriptor);

    +    STRICT_EXPECTED_CALL(is_attach_type_by_descriptor(IGNORED_PTR_ARG))

    +        .SetReturn(false);

    +    STRICT_EXPECTED_CALL(is_flow_type_by_descriptor(IGNORED_PTR_ARG))

    +        .SetReturn(1);

    +    STRICT_EXPECTED_CALL(amqpvalue_get_flow(IGNORED_PTR_ARG, IGNORED_PTR_ARG))

    +        .CopyOutArgumentBuffer(2, &flow, sizeof(flow));

    +    STRICT_EXPECTED_CALL(flow_get_link_credit(IGNORED_PTR_ARG, IGNORED_PTR_ARG))

    +        .CopyOutArgumentBuffer(2, &link_credit_value, sizeof(link_credit_value));

    +    STRICT_EXPECTED_CALL(flow_get_delivery_count(IGNORED_PTR_ARG, IGNORED_PTR_ARG))

    +        .CopyOutArgumentBuffer(2, &delivery_count_value, sizeof(delivery_count_value));

    +    STRICT_EXPECTED_CALL(flow_destroy(IGNORED_PTR_ARG));

    +

    +    // act

    +    on_frame_received(link, performative, frame_payload_size, payload_bytes);

    +

    +    // assert

    +    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());

    +

    +    // cleanup

    +    link_destroy(link);

    +}

    +

    +TEST_FUNCTION(link_receiver_frame_received_get_flow_fails_no_double_free_fails)

    +{

    +    // arrange

    +    LINK_HANDLE link = create_link(role_receiver);

    +    ON_ENDPOINT_FRAME_RECEIVED on_frame_received = NULL;

    +    int attach_result = attach_link(link, &on_frame_received);

    +    ASSERT_ARE_EQUAL(int, 0, attach_result);

    +

    +    AMQP_VALUE performative = (AMQP_VALUE)0x5000;

    +    AMQP_VALUE descriptor = (AMQP_VALUE)0x5001;

    +    FLOW_HANDLE flow = NULL;

    +    uint32_t frame_payload_size = 30;

    +    const unsigned char payload_bytes[30] = { 0 };

    +

    +    umock_c_reset_all_calls();

    +    STRICT_EXPECTED_CALL(amqpvalue_get_inplace_descriptor(performative))

    +        .SetReturn(descriptor);

    +    STRICT_EXPECTED_CALL(is_attach_type_by_descriptor(IGNORED_PTR_ARG))

    +        .SetReturn(false);

    +    STRICT_EXPECTED_CALL(is_flow_type_by_descriptor(IGNORED_PTR_ARG))

    +        .SetReturn(1);

    +    STRICT_EXPECTED_CALL(amqpvalue_get_flow(IGNORED_PTR_ARG, IGNORED_PTR_ARG))

    +        .CopyOutArgumentBuffer(2, &flow, sizeof(flow))

    +        .SetReturn(1);

    +

    +    // act

    +    on_frame_received(link, performative, frame_payload_size, payload_bytes);

    +

    +    // assert

    +    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());

    +

    +    // cleanup

    +    link_destroy(link);

    +}

    +

    +

    +END_TEST_SUITE(link_ut)'
  - '--- a/tests/link_ut/main.c

    +++ b/tests/link_ut/main.c

    @@ -0,0 +1,11 @@

    +// Copyright (c) Microsoft. All rights reserved.

    +// Licensed under the MIT license. See LICENSE file in the project root for full
    license information.

    +

    +#include "testrunnerswitcher.h"

    +

    +int main(void)

    +{

    +    size_t failedTestCount = 0;

    +    RUN_TEST_SUITE(link_ut, failedTestCount);

    +    return (int)failedTestCount;

    +}'
  identifiers: CVE:["CVE-2024-27099"],CWE:["CWE-415"]
  overview: Affected versions of this package are vulnerable to Double Free due to
    the processing of an incorrect `AMQP_VALUE` in a failed state. An attacker can
    execute arbitrary code on the target system by exploiting this vulnerability.
  references:
    GitHub Commit: https://github.com/Azure/azure-uamqp-c/commit/2ca42b6e4e098af2d17e487814a91d05f6ae4987
  title: Double Free
- diff_content:
  - "--- a/htp/htp_request.c\n+++ b/htp/htp_request.c\n@@ -714,10 +714,14 @@ htp_status_t\
    \ htp_connp_REQ_HEADERS(htp_connp_t *connp) {\n                     connp->in_header\
    \ = bstr_dup_mem(data + trim, len - trim);\n                     if (connp->in_header\
    \ == NULL) return HTP_ERROR;\n                 } else {\n-                   \
    \ // Add to the existing header.                    \n-                    bstr\
    \ *new_in_header = bstr_add_mem(connp->in_header, data, len);\n-             \
    \       if (new_in_header == NULL) return HTP_ERROR;\n-                    connp->in_header\
    \ = new_in_header;\n+                    // Add to the existing header.\n+   \
    \                 if (bstr_len(connp->in_header) < HTP_MAX_HEADER_FOLDED) {\n\
    +                        bstr *new_in_header = bstr_add_mem(connp->in_header,\
    \ data, len);\n+                        if (new_in_header == NULL) return HTP_ERROR;\n\
    +                        connp->in_header = new_in_header;\n+                \
    \    } else {\n+                        htp_log(connp, HTP_LOG_MARK, HTP_LOG_WARNING,\
    \ 0, \"Request field length exceeds folded maximum\");\n+                    }\n\
    \                 }\n             }\n "
  - "--- a/htp/htp_response.c\n+++ b/htp/htp_response.c\n@@ -978,10 +978,14 @@ htp_status_t\
    \ htp_connp_RES_HEADERS(htp_connp_t *connp) {\n                             return\
    \ HTP_ERROR;\n                     } else {\n                         // Add to\
    \ the existing header.\n-                        bstr *new_out_header = bstr_add_mem(connp->out_header,\
    \ data, len);\n-                        if (new_out_header == NULL)\n-       \
    \                     return HTP_ERROR;\n-                        connp->out_header\
    \ = new_out_header;\n+                        if (bstr_len(connp->out_header)\
    \ < HTP_MAX_HEADER_FOLDED) {\n+                            bstr *new_out_header\
    \ = bstr_add_mem(connp->out_header, data, len);\n+                           \
    \ if (new_out_header == NULL)\n+                                return HTP_ERROR;\n\
    +                            connp->out_header = new_out_header;\n+          \
    \              } else {\n+                            htp_log(connp, HTP_LOG_MARK,\
    \ HTP_LOG_WARNING, 0, \"Response field length exceeds folded maximum\");\n+  \
    \                      }\n                     }\n                 }\n       \
    \      }"
  identifiers: CVE:["CVE-2024-23837"],CWE:["CWE-770"]
  overview: Affected versions of this package are vulnerable to Allocation of Resources
    Without Limits or Throttling due to the excessive processing time of HTTP headers.
  references:
    GitHub Commit: https://github.com/OISF/libhtp/commit/20ac301d801cdf01b3f021cca08a22a87f477c4a
    Issue Ticket: https://redmine.openinfosecfoundation.org/issues/6444
  title: Allocation of Resources Without Limits or Throttling
- diff_content:
  - "--- a/src/app-layer-smtp.c\n+++ b/src/app-layer-smtp.c\n@@ -112,6 +112,8 @@\n\
    \ #define SMTP_EHLO_EXTENSION_STARTTLS\n #define SMTP_EHLO_EXTENSION_8BITMIME\n\
    \ \n+#define SMTP_DEFAULT_MAX_TX 256\n+\n typedef struct SMTPInput_ {\n     /*\
    \ current input that is being parsed */\n     const uint8_t *buf;\n@@ -421,6 +423,18\
    \ @@ static void SMTPConfigure(void) {\n         smtp_config.raw_extraction =\
    \ 0;\n     }\n \n+    uint64_t value = SMTP_DEFAULT_MAX_TX;\n+    smtp_config.max_tx\
    \ = SMTP_DEFAULT_MAX_TX;\n+    const char *str = NULL;\n+    if (ConfGet(\"app-layer.protocols.smtp.max-tx\"\
    , &str) == 1) {\n+        if (ParseSizeStringU64(str, &value) < 0) {\n+      \
    \      SCLogWarning(\"max-tx value cannot be deduced: %s,\"\n+               \
    \          \" keeping default\",\n+                    str);\n+        }\n+  \
    \      smtp_config.max_tx = value;\n+    }\n+\n     SCReturn;\n }\n \n@@ -436,8\
    \ +450,11 @@ static void SMTPSetEvent(SMTPState *s, uint8_t e)\n     SCLogDebug(\"\
    couldn't set event %u\", e);\n }\n \n-static SMTPTransaction *SMTPTransactionCreate(void)\n\
    +static SMTPTransaction *SMTPTransactionCreate(SMTPState *state)\n {\n+    if\
    \ (state->tx_cnt > smtp_config.max_tx) {\n+        return NULL;\n+    }\n    \
    \ SMTPTransaction *tx = SCCalloc(1, sizeof(*tx));\n     if (tx == NULL) {\n  \
    \       return NULL;\n@@ -1170,7 +1187,7 @@ static int SMTPProcessRequest(SMTPState\
    \ *state, Flow *f, AppLayerParserState *ps\n         return 0;\n     }\n     if\
    \ (state->curr_tx == NULL || (state->curr_tx->done && !NoNewTx(state, line)))\
    \ {\n-        tx = SMTPTransactionCreate();\n+        tx = SMTPTransactionCreate(state);\n\
    \         if (tx == NULL)\n             return -1;\n         state->curr_tx =\
    \ tx;\n@@ -1203,7 +1220,7 @@ static int SMTPProcessRequest(SMTPState *state, Flow\
    \ *f, AppLayerParserState *ps\n                     // we did not close the previous\
    \ tx, set error\n                     SMTPSetEvent(state, SMTP_DECODER_EVENT_UNPARSABLE_CONTENT);\n\
    \                     FileCloseFile(&tx->files_ts, &smtp_config.sbcfg, NULL, 0,\
    \ FILE_TRUNCATED);\n-                    tx = SMTPTransactionCreate();\n+    \
    \                tx = SMTPTransactionCreate(state);\n                     if (tx\
    \ == NULL)\n                         return -1;\n                     state->curr_tx\
    \ = tx;\n@@ -1221,7 +1238,7 @@ static int SMTPProcessRequest(SMTPState *state,\
    \ Flow *f, AppLayerParserState *ps\n                      * of first one. So we\
    \ start a new transaction. */\n                     tx->mime_state->state_flag\
    \ = PARSE_ERROR;\n                     SMTPSetEvent(state, SMTP_DECODER_EVENT_UNPARSABLE_CONTENT);\n\
    -                    tx = SMTPTransactionCreate();\n+                    tx =\
    \ SMTPTransactionCreate(state);\n                     if (tx == NULL)\n      \
    \                   return -1;\n                     state->curr_tx = tx;\n@@\
    \ -1935,6 +1952,8 @@ static void SMTPTestInitConfig(void)\n     smtp_config.content_inspect_window\
    \ = FILEDATA_CONTENT_INSPECT_WINDOW;\n     smtp_config.content_inspect_min_size\
    \ = FILEDATA_CONTENT_INSPECT_MIN_SIZE;\n \n+    smtp_config.max_tx = SMTP_DEFAULT_MAX_TX;\n\
    +\n     smtp_config.sbcfg.buf_size = FILEDATA_CONTENT_INSPECT_WINDOW;\n }\n "
  identifiers: CVE:["CVE-2024-23836"],CWE:["CWE-770"]
  overview: Affected versions of this package are vulnerable to Allocation of Resources
    Without Limits or Throttling. An attacker can cause the application to consume
    excessive CPU and memory resources by sending malicious traffic.
  references:
    GitHub Commit: https://github.com/OISF/suricata/commit/f9de1cca6182e571f1c02387dca6e695e55608af
    Issue Ticket: https://redmine.openinfosecfoundation.org/issues/6660
  title: Allocation of Resources Without Limits or Throttling
- diff_content:
  - "--- a/src/auth.c\n+++ b/src/auth.c\n@@ -216,11 +216,11 @@ static int auth_change_state(t_client\
    \ *client, const unsigned int new_state, con\n \t} else if (state == FW_MARK_AUTHENTICATED)\
    \ {\n \n \t\tif (new_state == FW_MARK_PREAUTHENTICATED) {\n+\t\t\t// we now delete\
    \ the client instead of changing state to preauthenticated\n \t\t\tiptables_fw_deauthenticate(client);\n\
    \ \t\t\tbinauth_action(client, reason, customdata);\n \t\t\tclient_reset(client);\n\
    \ \t\t\tclient_list_delete(client);\n-\t\t\tclient->fw_connection_state = new_state;\n\
    \ \n \t\t} else if (new_state == FW_MARK_AUTH_BLOCKED) {\n \t\t\tclient->window_start\
    \ = now;"
  identifiers: CVE:["CVE-2024-25763"],CWE:["CWE-416"]
  overview: Affected versions of this package are vulnerable to Use After Free in
    `/openNDS/src/auth.c`. An attacker can execute arbitrary code or cause a denial
    of service by manipulating the timing of memory release and access.
  references:
    GitHub Commit: https://github.com/openNDS/openNDS/commit/210c5da18e90d684f3415de95faa53ae3b7dce8f
    Vulnerability Report: https://github.com/LuMingYinDetect/openNDS_defects/blob/main/openNDS_detect_1.md
  title: Use After Free
- diff_content:
  - "--- a/b/src/eapol.c\n+++ b/b/src/eapol.c\n@@ -5,6 +5,8 @@ CREATE EXTENSION IF\
    \ NOT EXISTS anon CASCADE;\n \n SELECT anon.init();\n \n+SECURITY LABEL FOR anon\
    \ ON SCHEMA pg_catalog IS 'TRUSTED';\n+\n CREATE ROLE oscar_the_owner LOGIN PASSWORD\
    \ 'xlfneifzmqdef';\n ALTER DATABASE :DBNAME OWNER TO oscar_the_owner;\n \n@@ -39,12\
    \ +41,11 @@ VALUES\n ('Stalone'       ,'2683464645336781'),\n ('Lundgren'    \
    \  ,'6877322588932345');\n \n-\n SECURITY LABEL FOR anon ON COLUMN test.customer.name\n\
    -IS E'MASKED WITH FUNCTION md5(''0'') ';\n+IS E'MASKED WITH FUNCTION pg_catalog.md5(''0'')\
    \ ';\n \n SECURITY LABEL FOR anon ON COLUMN test.customer.\"CreditCard\"\n-IS\
    \ E'MASKED WITH FUNCTION md5(''0'') ';\n+IS E'MASKED WITH FUNCTION pg_catalog.md5(''0'')\
    \ ';\n \n CREATE TABLE test.\"COMPANY\" (\n   rn SERIAL,\n@@ -56,7 +57,7 @@ INSERT\
    \ INTO test.\"COMPANY\"\n VALUES (1991,'12345677890','Cyberdyne Systems');\n \n\
    \ SECURITY LABEL FOR anon ON COLUMN test.\"COMPANY\".\"IBAN\"\n-IS E'MASKED WITH\
    \ FUNCTION md5(''0'') ';\n+IS E'MASKED WITH FUNCTION pg_catalog.md5(''0'') ';\n\
    \ \n SECURITY LABEL FOR anon ON COLUMN test.\"COMPANY\".brand\n IS E'MASKED WITH\
    \ VALUE $$CONFIDENTIAL$$ ';\n@@ -776,7 +776,7 @@ done:\n /* Section 4.2.1 */\n\
    \ int p2p_parse_beacon(const uint8_t *pdu, size_t len, struct p2p_beacon *out)\n\
    \ {\n-\tstruct p2p_beacon d = {};\n+\tstruct p2p_beacon d = {0};\n \tint r;\n\
    \ \n \tr = p2p_parse_attrs(pdu, len,\n@@ -797,7 +797,7 @@ int p2p_parse_beacon(const\
    \ uint8_t *pdu, size_t len, struct p2p_beacon *out)\n int p2p_parse_probe_req(const\
    \ uint8_t *pdu, size_t len,\n \t\t\tstruct p2p_probe_req *out)\n {\n-\tstruct\
    \ p2p_probe_req d = {};\n+\tstruct p2p_probe_req d = {0};\n \tint r;\n \n \tr\
    \ = p2p_parse_attrs(pdu, len,\n@@ -828,7 +828,7 @@ int p2p_parse_probe_req(const\
    \ uint8_t *pdu, size_t len,\n int p2p_parse_probe_resp(const uint8_t *pdu, size_t\
    \ len,\n \t\t\t\tstruct p2p_probe_resp *out)\n {\n-\tstruct p2p_probe_resp d =\
    \ {};\n+\tstruct p2p_probe_resp d = {0};\n \tint r;\n \n \tr = p2p_parse_attrs(pdu,\
    \ len,\n@@ -853,7 +853,7 @@ int p2p_parse_probe_resp(const uint8_t *pdu, size_t\
    \ len,\n int p2p_parse_association_req(const uint8_t *pdu, size_t len,\n \t\t\t\
    \tstruct p2p_association_req *out)\n {\n-\tstruct p2p_association_req d = {};\n\
    +\tstruct p2p_association_req d = {0};\n \tint r;\n \n \tr = p2p_parse_attrs(pdu,\
    \ len,\n@@ -876,7 +876,7 @@ int p2p_parse_association_req(const uint8_t *pdu,\
    \ size_t len,\n int p2p_parse_association_resp(const uint8_t *pdu, size_t len,\n\
    \ \t\t\t\tstruct p2p_association_resp *out)\n {\n-\tstruct p2p_association_resp\
    \ d = {};\n+\tstruct p2p_association_resp d = {0};\n \tint r;\n \n \tr = p2p_parse_attrs(pdu,\
    \ len,\n@@ -939,7 +939,7 @@ int p2p_parse_disassociation(const uint8_t *pdu, size_t\
    \ len,\n int p2p_parse_go_negotiation_req(const uint8_t *pdu, size_t len,\n \t\
    \t\t\t\tstruct p2p_go_negotiation_req *out)\n {\n-\tstruct p2p_go_negotiation_req\
    \ d = {};\n+\tstruct p2p_go_negotiation_req d = {0};\n \tint r;\n \tstruct p2p_go_intent_attr\
    \ go_intent;\n \tuint8_t *wsc_data;\n@@ -1001,7 +1001,7 @@ error:\n int p2p_parse_go_negotiation_resp(const\
    \ uint8_t *pdu, size_t len,\n \t\t\t\t\tstruct p2p_go_negotiation_resp *out)\n\
    \ {\n-\tstruct p2p_go_negotiation_resp d = {};\n+\tstruct p2p_go_negotiation_resp\
    \ d = {0};\n \tint r;\n \tstruct p2p_go_intent_attr go_intent;\n \tuint8_t *wsc_data;\n\
    @@ -1062,7 +1062,7 @@ error:\n int p2p_parse_go_negotiation_confirmation(const\
    \ uint8_t *pdu, size_t len,\n \t\t\t\tstruct p2p_go_negotiation_confirmation *out)\n\
    \ {\n-\tstruct p2p_go_negotiation_confirmation d = {};\n+\tstruct p2p_go_negotiation_confirmation\
    \ d = {0};\n \tint r;\n \n \tif (len < 1)\n@@ -1096,7 +1096,7 @@ error:\n int\
    \ p2p_parse_invitation_req(const uint8_t *pdu, size_t len,\n \t\t\t\tstruct p2p_invitation_req\
    \ *out)\n {\n-\tstruct p2p_invitation_req d = {};\n+\tstruct p2p_invitation_req\
    \ d = {0};\n \tint r;\n \tuint8_t *wsc_data;\n \tssize_t wsc_len;\n@@ -1151,7\
    \ +1151,7 @@ error:\n int p2p_parse_invitation_resp(const uint8_t *pdu, size_t\
    \ len,\n \t\t\t\tstruct p2p_invitation_resp *out)\n {\n-\tstruct p2p_invitation_resp\
    \ d = {};\n+\tstruct p2p_invitation_resp d = {0};\n \tint r;\n \n \tif (len <\
    \ 1)\n@@ -1185,7 +1185,7 @@ error:\n int p2p_parse_device_disc_req(const uint8_t\
    \ *pdu, size_t len,\n \t\t\t\tstruct p2p_device_discoverability_req *out)\n {\n\
    -\tstruct p2p_device_discoverability_req d = {};\n+\tstruct p2p_device_discoverability_req\
    \ d = {0};\n \tint r;\n \n \tif (len < 1)\n@@ -1210,7 +1210,7 @@ int p2p_parse_device_disc_req(const\
    \ uint8_t *pdu, size_t len,\n int p2p_parse_device_disc_resp(const uint8_t *pdu,\
    \ size_t len,\n \t\t\t\tstruct p2p_device_discoverability_resp *out)\n {\n-\t\
    struct p2p_device_discoverability_resp d = {};\n+\tstruct p2p_device_discoverability_resp\
    \ d = {0};\n \tint r;\n \n \tif (len < 1)\n@@ -1234,7 +1234,7 @@ int p2p_parse_device_disc_resp(const\
    \ uint8_t *pdu, size_t len,\n int p2p_parse_provision_disc_req(const uint8_t *pdu,\
    \ size_t len,\n \t\t\t\tstruct p2p_provision_discovery_req *out)\n {\n-\tstruct\
    \ p2p_provision_discovery_req d = {};\n+\tstruct p2p_provision_discovery_req d\
    \ = {0};\n \tint r;\n \tuint8_t *wsc_data;\n \tssize_t wsc_len;\n@@ -1309,7 +1309,7\
    \ @@ error:\n int p2p_parse_provision_disc_resp(const uint8_t *pdu, size_t len,\n\
    \ \t\t\t\tstruct p2p_provision_discovery_resp *out)\n {\n-\tstruct p2p_provision_discovery_resp\
    \ d = {};\n+\tstruct p2p_provision_discovery_resp d = {0};\n \tint r;\n \tuint8_t\
    \ *wsc_data;\n \tssize_t wsc_len;\n@@ -1389,7 +1389,7 @@ error:\n int p2p_parse_notice_of_absence(const\
    \ uint8_t *pdu, size_t len,\n \t\t\t\tstruct p2p_notice_of_absence *out)\n {\n\
    -\tstruct p2p_notice_of_absence d = {};\n+\tstruct p2p_notice_of_absence d = {0};\n\
    \ \tint r;\n \n \tif (len < 1)\n@@ -1411,7 +1411,7 @@ int p2p_parse_notice_of_absence(const\
    \ uint8_t *pdu, size_t len,\n int p2p_parse_presence_req(const uint8_t *pdu, size_t\
    \ len,\n \t\t\t\tstruct p2p_presence_req *out)\n {\n-\tstruct p2p_presence_req\
    \ d = {};\n+\tstruct p2p_presence_req d = {0};\n \tint r;\n \n \tif (len < 1)\n\
    @@ -1437,7 +1437,7 @@ int p2p_parse_presence_req(const uint8_t *pdu, size_t len,\n\
    \ int p2p_parse_presence_resp(const uint8_t *pdu, size_t len,\n \t\t\t\tstruct\
    \ p2p_presence_resp *out)\n {\n-\tstruct p2p_presence_resp d = {};\n+\tstruct\
    \ p2p_presence_resp d = {0};\n \tint r;\n \n \tif (len < 1)\n@@ -2092,6 +2092,10\
    \ @@ static void eapol_handle_ptk_4_of_4(struct eapol_sm *sm,\n \tif (L_BE64_TO_CPU(ek->key_replay_counter)\
    \ != sm->replay_counter)\n \t\treturn;\n \n+\t/* Ensure we received Message 2\
    \ and thus have a PTK to verify MIC */\n+\tif (!sm->handshake->have_snonce)\n\
    +\t\treturn;\n+\n \tkck = handshake_state_get_kck(sm->handshake);\n \n \tif (!eapol_verify_mic(sm->handshake->akm_suite,\
    \ kck, ek,\n"
  identifiers: CVE:["CVE-2023-52161"],CWE:["CWE-304"]
  overview: Affected versions of this package are vulnerable to Missing Critical Step
    in Authentication due to the `eapol_auth_key_handle` function in `eapol.c`, when
    used in Access Point mode. An attacker can gain unauthorized access to a protected
    Wi-Fi network by completing the EAPOL handshake by skipping Msg2/4 and instead
    sending Msg4/4 with an all-zero key.
  references:
    Git Commit: https://git.kernel.org/pub/scm/network/wireless/iwd.git/commit/?id=6415420f1c92012f64063c131480ffcef58e60ca
    Vulnerability Report: https://www.top10vpn.com/research/wifi-vulnerabilities/
  title: Missing Critical Step in Authentication
- diff_content:
  - "--- a/app/bluetooth/common/abr_initiator/abr_initiator.c\n+++ b/app/bluetooth/common/abr_initiator/abr_initiator.c\n\
    @@ -3,7 +3,7 @@\n  * @brief ABR initiator\n  *******************************************************************************\n\
    \  * # License\n- * <b>Copyright 2022-2023 Silicon Laboratories Inc. www.silabs.com</b>\n\
    + * <b>Copyright 2024 Silicon Laboratories Inc. www.silabs.com</b>\n  *******************************************************************************\n\
    \  *\n  * SPDX-License-Identifier: Zlib\n@@ -174,33 +174,21 @@ void bt_on_event_initiator(sl_bt_msg_t\
    \ *evt)\n                                            initiator_config->max_ce_length);\n\
    \ \n       app_assert_status(sc);\n+      app_log_info(\"Set connection parameters...\"\
    \ APP_LOG_NL);\n       ras_control_point_characteristic_found = false;\n     \
    \  ras_procedure_enable_data_characteristic_found = false;\n       ras_se_ranging_data_characteristic_found\
    \ = false;\n       ras_characteristics_discovered = false;\n-      sc = sl_bt_cs_set_procedure_parameters(connection_handle,\n\
    -                                             initiator_config->config_id,\n-\
    \                                             initiator_config->max_procedure_duration,\n\
    -                                             initiator_config->min_interval,\n\
    -                                             initiator_config->max_interval,\n\
    -                                             initiator_config->max_procedure_count,\n\
    -                                             initiator_config->min_subevent_len,\n\
    -                                             initiator_config->max_subevent_len,\n\
    -                                             initiator_config->antenna_config,\n\
    -                                             initiator_config->phy,\n-      \
    \                                       initiator_config->tx_pwr_delta,\n-   \
    \                                          initiator_config->preferred_peer_antenna);\n\
    -      app_log_status_warning_f(sc, \"Set procedure parameters failed\" APP_LOG_NL);\n\
    -\n       break;\n \n     case sl_bt_evt_connection_parameters_id:\n       if\
    \ (evt->data.evt_connection_parameters.security_mode == 1) {\n-        app_log_info(\"\
    Connection encrypted\" APP_LOG_NL);\n+        app_log_info(\"Connection parameters\
    \ set. Connection encrypted\" APP_LOG_NL);\n         sc = sl_bt_gatt_discover_primary_services_by_uuid(connection_handle,\n\
    \                                                           UUID_LEN,\n      \
    \                                                     ras_service_uuid);\n   \
    \      app_assert_status(sc);\n+        abr_initiator_create_config();\n     \
    \  }\n       break;\n \n@@ -274,7 +262,21 @@ void bt_on_event_initiator(sl_bt_msg_t\
    \ *evt)\n       break;\n \n     case sl_bt_evt_cs_config_complete_id:\n-     \
    \ app_log_info(\"Config created\" APP_LOG_NL);\n+      app_log_info(\"ABR config\
    \ created. Set procedure parameters ...\" APP_LOG_NL);\n+      sc = sl_bt_cs_set_procedure_parameters(connection_handle,\n\
    +                                             initiator_config->config_id,\n+\
    \                                             initiator_config->max_procedure_duration,\n\
    +                                             initiator_config->min_interval,\n\
    +                                             initiator_config->max_interval,\n\
    +                                             initiator_config->max_procedure_count,\n\
    +                                             initiator_config->min_subevent_len,\n\
    +                                             initiator_config->max_subevent_len,\n\
    +                                             initiator_config->antenna_config,\n\
    +                                             initiator_config->phy,\n+      \
    \                                       initiator_config->tx_pwr_delta,\n+   \
    \                                          initiator_config->preferred_peer_antenna);\n\
    +      app_assert_status(sc);\n+      app_log_info(\"Procedure parameters set\"\
    \ APP_LOG_NL);\n       sc = abr_file_log_config_complete_event(&evt->data.evt_cs_config_complete);\n\
    \       app_assert_status(sc);\n       abr_initiator_start_cs_procedure();\n@@\
    \ -332,7 +334,7 @@ void abr_set_antenna_offset()\n   if (sc != SL_STATUS_OK) {\n\
    \     app_log_warning(\"User message to target failed: %u\" APP_LOG_NL, sc);\n\
    \   } else {\n-    app_log_info(\"Received antenna offset parameters.\" APP_LOG_NL);\n\
    +    app_log_info(\"Received antenna offset parameters\" APP_LOG_NL);\n     //\
    \ First data is the number of antennas\n     initiator_config->antenna_offset.offset_count\
    \ = response_data_offset[0];\n     if (initiator_config->antenna_offset.offset_count\
    \ > MAX_ANTENNA_NUMBER) {\n@@ -799,7 +801,6 @@ static void process_procedure_complete_event(sl_bt_msg_t\
    \ *evt)\n \n     case act_subscribe_result_2:\n       app_log_info(\"Subscribed\
    \ to RAS Control Point indications\" APP_LOG_NL);\n-      abr_initiator_create_config();\n\
    \       action = act_none;\n       break;\n "
  - "--- a/app/bluetooth/common/app_ota_dfu/sl_bt_app_ota_dfu.c\n+++ b/app/bluetooth/common/app_ota_dfu/sl_bt_app_ota_dfu.c\n\
    @@ -3,7 +3,7 @@\n  * @brief Application Over-the-Air Device Firmware Update\n\
    \  *******************************************************************************\n\
    \  * # License\n- * <b>Copyright 2022 Silicon Laboratories Inc. www.silabs.com</b>\n\
    + * <b>Copyright 2024 Silicon Laboratories Inc. www.silabs.com</b>\n  *******************************************************************************\n\
    \  *\n  * SPDX-License-Identifier: Zlib\n@@ -49,8 +49,9 @@\n #define ATT_ERR_STORAGE_FULL\
    \                   0x82u\n #define ATT_ERR_PACKAGE_LOST                   0x83u\n\
    \ \n+// Resizing to fit the 32 bit target architecture.\n #define SL_BT_APP_OTA_DFU_FLASH_VERIFICATION_CONTEXT_SIZE\
    \ \\\n-  (uint16_t)(BOOTLOADER_STORAGE_VERIFICATION_CONTEXT_SIZE >> 2)\n+  (uint16_t)(BOOTLOADER_STORAGE_VERIFICATION_CONTEXT_SIZE\
    \ / sizeof(uint32_t))\n \n #ifndef SL_BT_INVALID_CONNECTION_HANDLE\n #define SL_BT_INVALID_CONNECTION_HANDLE\
    \ ((uint8_t) 0xFF)\n@@ -309,7 +310,7 @@ bool sl_bt_app_ota_dfu_is_ok_to_sleep(void)\n\
    \   // - no verification is in progress\n   // - no storage checking for erase\
    \ is in progress\n   if ((ota_sts == SL_BT_APP_OTA_DFU_VERIFY) \\\n-      || (ota_sts\
    \ == SL_BT_APP_OTA_DFU_ERASE)) {\n+      || (ota_sts == SL_BT_APP_OTA_DFU_READ_FLASH))\
    \ {\n     ret_val = false;\n   }\n   return ret_val;\n@@ -325,7 +326,7 @@ sl_power_manager_on_isr_exit_t\
    \ sl_bt_app_ota_dfu_sleep_on_isr_exit(void)\n   // - verification is in progress\n\
    \   // - storage checking for erase is in progress\n   if ((ota_sts == SL_BT_APP_OTA_DFU_VERIFY)\
    \ \\\n-      || (ota_sts == SL_BT_APP_OTA_DFU_ERASE)) {\n+      || (ota_sts ==\
    \ SL_BT_APP_OTA_DFU_READ_FLASH)) {\n     ret_val = SL_POWER_MANAGER_WAKEUP;\n\
    \   }\n   return ret_val;\n@@ -351,9 +352,11 @@ void sli_bt_app_ota_dfu_step(void)\n\
    \   int32_t btl_ret_val = BOOTLOADER_OK;\n   sl_bt_app_ota_dfu_error_t ota_error\
    \ = SL_BT_APP_OTA_DFU_NO_ERROR;\n   sl_bt_app_ota_dfu_status_t req_sts = SL_BT_APP_OTA_DFU_UNINIT;\n\
    -\n-  uint32_t offset = 0, num_blocks = 0, i = 0;\n   bool dirty = false;\n+ \
    \ uint32_t offset = 0, num_blocks = 0, i = 0;\n+  // Resizing to fit the 32 bit\
    \ target architecture.\n+  uint16_t data_fragments = \\\n+    (uint16_t)(SL_BT_APP_OTA_DFU_READ_STORAGE_CONTEXT_SIZE\
    \ / sizeof(uint32_t));\n \n   switch (ota_sts) {\n     ///////////////////////////////////////////////////////////////////////////\n\
    @@ -383,8 +386,8 @@ void sli_bt_app_ota_dfu_step(void)\n         ota_event.evt_info.btl_storage.storage_size_bytes\
    \ = slot_info.length;\n         ota_event.evt_info.btl_storage.storage_start_addr\
    \ = slot_info.address;\n         sl_bt_app_ota_dfu_on_status_event(&ota_event);\n\
    -        // Proceed to erase state to erase the storage.\n-        req_sts = SL_BT_APP_OTA_DFU_ERASE;\n\
    +        // Proceed to read flash state to determine if erase is necessary or\
    \ not.\n+        req_sts = SL_BT_APP_OTA_DFU_READ_FLASH;\n       } else {\n  \
    \       // Getting bootloader and storage information failed.\n         req_sts\
    \ = SL_BT_APP_OTA_DFU_ERROR;\n@@ -403,10 +406,10 @@ void sli_bt_app_ota_dfu_step(void)\n\
    \       sli_bt_app_ota_dfu_proceed();\n       break;\n     ///////////////////////////////////////////////////////////////////////////\n\
    -    // Erase storage slot if neccessary.                                    \
    \ //\n+    // Check flash storage slot.                                      \
    \       //\n     ///////////////////////////////////////////////////////////////////////////\n\
    -    case SL_BT_APP_OTA_DFU_ERASE:\n-      // Check the download area content\
    \ by reading it in byte blocks.\n+    case SL_BT_APP_OTA_DFU_READ_FLASH:\n+  \
    \    // Check the download area content by reading it in blocks.\n       num_blocks\
    \ = slot_info.length / SL_BT_APP_OTA_DFU_READ_STORAGE_CONTEXT_SIZE;\n       //\
    \ Run through the full storage and read the context in chunks.\n       while ((dirty\
    \ == false) && (offset < SL_BT_APP_OTA_DFU_READ_STORAGE_CONTEXT_SIZE * num_blocks)\
    \ && (btl_ret_val == BOOTLOADER_OK)) {\n@@ -418,8 +421,8 @@ void sli_bt_app_ota_dfu_step(void)\n\
    \                                  SL_BT_APP_OTA_DFU_READ_STORAGE_CONTEXT_SIZE);\n\
    \ \n         if (btl_ret_val == BOOTLOADER_OK) {\n-          // Run through the\
    \ chunk byte-by-byte and check if its empty or not.\n-          for (i = 0; i\
    \ < SL_BT_APP_OTA_DFU_READ_STORAGE_CONTEXT_SIZE && !dirty; i++) {\n+         \
    \ // Run through the chunk in 32 bit fragments and check if its empty or not.\n\
    +          for (i = 0; i < data_fragments && !dirty; i++) {\n             if (ota_buff[i]\
    \ != SL_BT_APP_OTA_DFU_EMPTY_FLASH_CONTENT) {\n               dirty = true;\n\
    \             }\n@@ -435,16 +438,7 @@ void sli_bt_app_ota_dfu_step(void)\n   \
    \      req_sts = SL_BT_APP_OTA_DFU_ERROR;\n       } else if (dirty) {\n      \
    \   // Storage space is not empty proceed to erase.\n-        btl_ret_val = bootloader_eraseStorageSlot(SL_BT_APP_OTA_DFU_USED_SLOT);\n\
    -        if (btl_ret_val != BOOTLOADER_OK) {\n-          // Failed to erase storage\
    \ slot.\n-          ota_error = SL_BT_APP_OTA_DFU_ERR_BOOTLOADER_API;\n-     \
    \     req_sts = SL_BT_APP_OTA_DFU_ERROR;\n-        } else {\n-          // Storage\
    \ slot erased successfully.\n-          // Application OTA DFU component is ready\
    \ for an OTA process.\n-          req_sts = SL_BT_APP_OTA_DFU_READY;\n-      \
    \  }\n+        req_sts = SL_BT_APP_OTA_DFU_ERASE;\n       } else {\n         //\
    \ Storage space was originally empty, proceed to next\n         req_sts = SL_BT_APP_OTA_DFU_READY;\n\
    @@ -462,6 +456,32 @@ void sli_bt_app_ota_dfu_step(void)\n       sli_bt_app_ota_dfu_proceed();\n\
    \       break;\n     ///////////////////////////////////////////////////////////////////////////\n\
    +    // Erase storage slot.                                                  \
    \ //\n+    ///////////////////////////////////////////////////////////////////////////\n\
    +    case SL_BT_APP_OTA_DFU_ERASE:\n+      btl_ret_val = bootloader_eraseStorageSlot(SL_BT_APP_OTA_DFU_USED_SLOT);\n\
    +      if (btl_ret_val != BOOTLOADER_OK) {\n+        // Failed to erase storage\
    \ slot.\n+        ota_error = SL_BT_APP_OTA_DFU_ERR_BOOTLOADER_API;\n+       \
    \ req_sts = SL_BT_APP_OTA_DFU_ERROR;\n+      } else {\n+        // Storage slot\
    \ erased successfully.\n+        // Application OTA DFU component is ready for\
    \ an OTA process.\n+        req_sts = SL_BT_APP_OTA_DFU_READY;\n+      }\n+  \
    \    // Change to next state.\n+      sli_bt_app_ota_dfu_set_main_status(req_sts);\n\
    +      // Forward state change information to application.\n+      ota_event.event_id\
    \ = SL_BT_APP_OTA_DFU_EVT_STATE_CHANGE_ID;\n+      ota_event.ota_error_code =\
    \ ota_error;\n+      ota_event.btl_api_retval = btl_ret_val;\n+      ota_event.evt_info.sts.status\
    \ = ota_sts;\n+      ota_event.evt_info.sts.prev_status = ota_prev_sts;\n+   \
    \   sl_bt_app_ota_dfu_on_status_event(&ota_event);\n+      // Continue execution.\n\
    +      sli_bt_app_ota_dfu_proceed();\n+      break;\n+    ///////////////////////////////////////////////////////////////////////////\n\
    \     // Ready for OTA DFU process.                                          \
    \  //\n     ///////////////////////////////////////////////////////////////////////////\n\
    \     case SL_BT_APP_OTA_DFU_READY:"
  - "--- a/app/bluetooth/common/esl_tag_core/src/esl_tag_core.c\n+++ b/app/bluetooth/common/esl_tag_core/src/esl_tag_core.c\n\
    @@ -285,8 +285,11 @@ void esl_core_step(void)\n       sl_bt_esl_log(ESL_LOG_COMPONENT_CORE,\n\
    \                     ESL_LOG_LEVEL_INFO,\n                     \"Unassociated\
    \ by watchdog timeout.\");\n-    } else if (esl_state_unassociated == esl_tag.status)\
    \ {\n-      // shutdown after one or two hours of advertising in vain\n+     \
    \ if (!ESL_TAG_POWER_DOWN_ENABLE) {\n+        (void)sl_sleeptimer_stop_timer(&esl_tag_persistent.watchdog_handle);\n\
    +      }\n+    } else if (ESL_TAG_POWER_DOWN_ENABLE && esl_state_unassociated\
    \ == esl_tag.status) {\n+      // if power saving is enabled, shut down after\
    \ the specified idle time\n       sl_bt_esl_log(ESL_LOG_COMPONENT_CORE,\n    \
    \                 ESL_LOG_LEVEL_INFO,\n                     \"Shutdown by watchdog\
    \ timeout.\");\n@@ -1229,13 +1232,31 @@ sl_status_t esl_core_start_advertising(void)\n\
    \       // change internal status\n       esl_tag.status = new_esl_status;\n \
    \    }\n-    // start / restart watchdog timer whenever ESL starts advertising\n\
    -    (void)sl_sleeptimer_restart_periodic_timer_ms(&esl_tag_persistent.watchdog_handle,\n\
    -                                                  ESL_CORE_SECURITY_TIMEOUT_MS,\n\
    -                                                  &esl_security_timeout,\n- \
    \                                                 NULL,\n-                   \
    \                               ESL_CORE_SECURITY_TIMER_PRIORITY,\n-         \
    \                                         SL_SLEEPTIMER_NO_HIGH_PRECISION_HF_CLOCKS_REQUIRED_FLAG);\n\
    +\n+    if (esl_tag.status != esl_state_unassociated || ESL_TAG_POWER_DOWN_ENABLE)\
    \ {\n+      uint32_t timeout_ms = ESL_CORE_SECURITY_TIMEOUT_MS;\n+\n+      if\
    \ (ESL_TAG_POWER_DOWN_ENABLE && esl_tag.status == esl_state_unassociated) {\n\
    +        // override default timeout value only if the current ESL state is Unassociated\
    \ AND energy saving is enabled\n+        timeout_ms = ESL_TAG_POWER_DOWN_TIMEOUT_MS;\n\
    +        sl_bt_esl_log(ESL_LOG_COMPONENT_CORE,\n+                      ESL_LOG_LEVEL_INFO,\n\
    +                      \"Enter power save mode after %d minutes of ineffective\
    \ advertising.\",\n+                      ESL_TAG_POWER_DOWN_TIMEOUT_MIN);\n+\
    \      }\n+      // start / restart watchdog timer whenever ESL starts advertising\n\
    +      // except in Unassociated state IF the energy saving is disabled!\n+  \
    \    (void)sl_sleeptimer_restart_periodic_timer_ms(&esl_tag_persistent.watchdog_handle,\n\
    +                                                    timeout_ms,\n+          \
    \                                          &esl_security_timeout,\n+         \
    \                                           NULL,\n+                         \
    \                           ESL_CORE_SECURITY_TIMER_PRIORITY,\n+             \
    \                                       SL_SLEEPTIMER_NO_HIGH_PRECISION_HF_CLOCKS_REQUIRED_FLAG);\n\
    +    } else {\n+      sl_bt_esl_log(ESL_LOG_COMPONENT_CORE,\n+               \
    \     ESL_LOG_LEVEL_INFO,\n+                    \"Power saving disabled by ESL_TAG_POWER_DOWN_ENABLE\
    \ config!\");\n+    }\n   }\n \n   return result;"
  - "--- a/app/bluetooth/common/ots/src/sl_bt_ots_server.c\n+++ b/app/bluetooth/common/ots/src/sl_bt_ots_server.c\n\
    @@ -1351,14 +1351,15 @@ static uint8_t handle_oacp_write(sl_bt_ots_server_t *server,\n\
    \         response_code = SL_BT_OTS_OACP_RESPONSE_CODE_PROCEDURE_NOT_PERMITTED;\n\
    \         break;\n       }\n-      if (client->operation_in_progress != SL_BT_OTS_OACP_OPCODE_READ)\
    \ {\n-        response_code = SL_BT_OTS_OACP_RESPONSE_CODE_OPERATION_FAILED;\n\
    -        break;\n-      }\n \n       // Parameter length is incorrect\n      \
    \ if (write_request->value.len != OACP_MESSAGE_LENGTH_ABORT) {\n         sc =\
    \ ATT_ERR_INVALID_ATTRIBUTE_LEN;\n+        return sc;\n+      }\n+\n+      if\
    \ (client->operation_in_progress != SL_BT_OTS_OACP_OPCODE_READ) {\n+        response_code\
    \ = SL_BT_OTS_OACP_RESPONSE_CODE_OPERATION_FAILED;\n         break;\n       }\n\
    \ \n@@ -1369,18 +1370,14 @@ static uint8_t handle_oacp_write(sl_bt_ots_server_t\
    \ *server,\n       break;\n   }\n \n-  // Send response in ATT error cases\n+\
    \  // Guard\n   if (sc != ATT_ERR_SUCCESS) {\n-    (void)sl_bt_gatt_server_send_user_write_response(write_request->connection,\n\
    -                                                     write_request->characteristic,\n\
    -                                                     sc);\n-    return SL_STATUS_FAIL;\n\
    +    return sc;\n   }\n \n   // Execute OP code\n   if (server->callbacks->on_oacp_event\
    \ != NULL\n-      && response_code == SL_BT_OTS_OACP_RESPONSE_CODE_SUCCESS\n-\
    \      && sc == ATT_ERR_SUCCESS) {\n+      && response_code == SL_BT_OTS_OACP_RESPONSE_CODE_SUCCESS)\
    \ {\n     uint32_t  max_pdu_suggested = 0;\n     uint32_t  max_sdu_suggested =\
    \ 0;\n \n@@ -1493,40 +1490,38 @@ static uint8_t handle_oacp_write(sl_bt_ots_server_t\
    \ *server,\n   (void)sl_bt_gatt_server_send_user_write_response(write_request->connection,\n\
    \                                                    write_request->characteristic,\n\
    \                                                    sc);\n-  if (sc == ATT_ERR_SUCCESS)\
    \ {\n-    send_indication(client->connection_handle,\n-                    server->gattdb_handles->characteristics.handles.object_action_control_point,\n\
    -                    sizeof(oacp_response_msg->opcode)\n-                    +\
    \ sizeof(oacp_response_msg->opcode)\n-                    + sizeof(oacp_response_msg->response)\n\
    -                    + oacp_response_data_len,\n-                    (uint8_t\
    \ *)oacp_response_msg);\n+  send_indication(client->connection_handle,\n+    \
    \              server->gattdb_handles->characteristics.handles.object_action_control_point,\n\
    +                  sizeof(oacp_response_msg->opcode)\n+                  + sizeof(oacp_response_msg->opcode)\n\
    +                  + sizeof(oacp_response_msg->response)\n+                  +\
    \ oacp_response_data_len,\n+                  (uint8_t *)oacp_response_msg);\n\
    \ \n #if SL_BT_OTS_SERVER_CONFIG_GLOBAL_OBJECT_CHANGED_SUPPORT\n-    if (oacp_response_msg->response\
    \ == SL_BT_OTS_OACP_RESPONSE_CODE_SUCCESS\n-        && server->capabilities.capability_object_changed)\
    \ {\n-      // Send indications to clients\n-      switch (oacp_response_msg->opcode)\
    \ {\n-        case SL_BT_OTS_OACP_OPCODE_CREATE:\n-          (void)send_object_changed(server,\n\
    -                                    &client->current_object,\n-             \
    \                       SL_BT_OTS_OBJECT_CHANGE_SOURCE_MASK\n-               \
    \                     | SL_BT_OTS_OBJECT_CHANGE_CREATION_MASK,\n-            \
    \                        client->connection_handle);\n-          break;\n-   \
    \     case SL_BT_OTS_OACP_OPCODE_DELETE:\n-          (void)send_object_changed(server,\n\
    -                                    &client->current_object,\n-             \
    \                       SL_BT_OTS_OBJECT_CHANGE_SOURCE_MASK\n-               \
    \                     | SL_BT_OTS_OBJECT_CHANGE_DELETION_MASK,\n-            \
    \                        client->connection_handle);\n-          break;\n-   \
    \     default:\n-          break;\n-      }\n+  if (oacp_response_msg->response\
    \ == SL_BT_OTS_OACP_RESPONSE_CODE_SUCCESS\n+      && server->capabilities.capability_object_changed)\
    \ {\n+    // Send indications to clients\n+    switch (oacp_response_msg->opcode)\
    \ {\n+      case SL_BT_OTS_OACP_OPCODE_CREATE:\n+        (void)send_object_changed(server,\n\
    +                                  &client->current_object,\n+               \
    \                   SL_BT_OTS_OBJECT_CHANGE_SOURCE_MASK\n+                   \
    \               | SL_BT_OTS_OBJECT_CHANGE_CREATION_MASK,\n+                  \
    \                client->connection_handle);\n+        break;\n+      case SL_BT_OTS_OACP_OPCODE_DELETE:\n\
    +        (void)send_object_changed(server,\n+                                \
    \  &client->current_object,\n+                                  SL_BT_OTS_OBJECT_CHANGE_SOURCE_MASK\n\
    +                                  | SL_BT_OTS_OBJECT_CHANGE_DELETION_MASK,\n\
    +                                  client->connection_handle);\n+        break;\n\
    +      default:\n+        break;\n     }\n-#endif // SL_BT_OTS_SERVER_CONFIG_GLOBAL_OBJECT_CHANGED_SUPPORT\n\
    \   }\n+#endif // SL_BT_OTS_SERVER_CONFIG_GLOBAL_OBJECT_CHANGED_SUPPORT\n \n \
    \  return sc;\n }\n@@ -1539,6 +1534,7 @@ static sl_status_t send_indication(uint8_t\
    \       connection,\n   sl_status_t sc;\n \n   sli_bt_ots_indication_queue_item_t\
    \ item;\n+  memset(&item, 0x00, sizeof(item));\n   item.connection = connection;\n\
    \   item.gattdb_handle = characteristic;\n   item.data_length = value_len;\n@@\
    \ -1708,11 +1704,15 @@ static uint8_t handle_olcp_write(sl_bt_ots_server_t *server,\n\
    \       response_code = SL_BT_OTS_OLCP_RESPONSE_CODE_OP_CODE_NOT_SUPPORTED;\n\
    \   }\n \n+  // Guard\n+  if (sc != ATT_ERR_SUCCESS) {\n+    return sc;\n+  }\n\
    +\n   uint32_t number_of_objects = 0;\n   // Execute OP code\n   if (server->callbacks->on_olcp_event\
    \ != NULL\n-      && response_code == SL_BT_OTS_OLCP_RESPONSE_CODE_SUCCESS\n-\
    \      && sc == ATT_ERR_SUCCESS) {\n+      && response_code == SL_BT_OTS_OLCP_RESPONSE_CODE_SUCCESS)\
    \ {\n     response_code = server->callbacks->on_olcp_event(server,\n         \
    \                                             client->connection_handle,\n   \
    \                                                   &client->current_object,\n\
    @@ -1730,12 +1730,10 @@ static uint8_t handle_olcp_write(sl_bt_ots_server_t *server,\n\
    \                                                    write_request->characteristic,\n\
    \                                                    sc);\n \n-  if (sc == ATT_ERR_SUCCESS)\
    \ {\n-    send_indication(client->connection_handle,\n-                    server->gattdb_handles->characteristics.handles.object_list_control_point,\n\
    -                    response_code_len,\n-                    (uint8_t *)olcp_response_msg);\n\
    -  }\n+  send_indication(client->connection_handle,\n+                  server->gattdb_handles->characteristics.handles.object_list_control_point,\n\
    +                  response_code_len,\n+                  (uint8_t *)olcp_response_msg);\n\
    \ \n   return sc;\n }"
  - "--- a/app/bluetooth/common/ots/src/sl_bt_ots_server_bm.c\n+++ b/app/bluetooth/common/ots/src/sl_bt_ots_server_bm.c\n\
    @@ -51,8 +51,9 @@ static app_queue_t indication_queue[SL_BT_CONFIG_MAX_CONNECTIONS];\n\
    \ \n // -----------------------------------------------------------------------------\n\
    \ // Forward declaration of private functions\n-\n+#ifdef SL_CATALOG_POWER_MANAGER_PRESENT\n\
    \ static bool server_has_task(void);\n+#endif // SL_CATALOG_POWER_MANAGER_PRESENT\n\
    \ \n // -----------------------------------------------------------------------------\n\
    \ // Bare metal functions"
  - "--- a/app/bluetooth/common/simple_com/sl_simple_com_usart.c\n+++ b/app/bluetooth/common/simple_com/sl_simple_com_usart.c\n\
    @@ -83,15 +83,16 @@ static void receive_cb(UARTDRV_Handle_t handle,\n        \
    \                uint8_t *data,\n                        UARTDRV_Count_t transferCount);\n\
    \ // Helper functions to ensure reception\n-static Ecode_t abort_receive(UARTDRV_Handle_t\
    \ handle);\n+static Ecode_t cancel_receive(UARTDRV_Handle_t handle);\n static\
    \ Ecode_t get_tail_buffer(UARTDRV_Buffer_FifoQueue_t *queue,\n               \
    \                 UARTDRV_Buffer_t **buffer);\n static Ecode_t dequeue_buffer(UARTDRV_Buffer_FifoQueue_t\
    \ *queue,\n                               UARTDRV_Buffer_t **buffer);\n-static\
    \ void disable_receiver(UARTDRV_Handle_t handle);\n \n static IRQn_Type irq_number_from_handle(UARTDRV_Handle_t\
    \ handle);\n \n+static Ecode_t uart_receive_start(UARTDRV_Handle_t handle);\n\
    +\n void sli_simple_com_isr(void);\n \n // -----------------------------------------------------------------------------\n\
    @@ -197,8 +198,7 @@ void sl_simple_com_receive(void)\n   // Clear any USART interrupt\
    \ flags\n   USART_IntClear(uartdrv_handle->peripheral.uart, _USART_IF_MASK);\n\
    \   USART_IntEnable(uartdrv_handle->peripheral.uart, USART_IF_TXIDLE | USART_IF_TCMP1);\n\
    -  // Start reception with callback set\n-  ec = UARTDRV_Receive(uartdrv_handle,\
    \ rx_buf, sizeof(rx_buf), receive_cb);\n+  ec = uart_receive_start(uartdrv_handle);\n\
    \   app_assert(ECODE_EMDRV_UARTDRV_OK == ec,\n              \"[E: 0x%04x] Failed\
    \ to start receiving\\n\",\n              (int)ec);\n@@ -250,6 +250,12 @@ static\
    \ void timer_callback(sl_sleeptimer_timer_handle_t *handle,\n {\n   (void)handle;\n\
    \   (void)data;\n+\n+  // Assert nRTS\n+  if (uartdrv_handle->fcType != uartdrvFlowControlHwUart)\
    \ {\n+    UARTDRV_FlowControlSet(uartdrv_handle, uartdrvFlowControlOff);\n+  }\n\
    +\n   // Get received bytes\n   uint8_t* buffer = NULL;\n   uint32_t received\
    \ = 0;\n@@ -262,9 +268,9 @@ static void timer_callback(sl_sleeptimer_timer_handle_t\
    \ *handle,\n     CORE_DECLARE_IRQ_STATE;\n     CORE_ENTER_ATOMIC();\n \n-    //\
    \ abort receive operation\n-    (void)abort_receive(uartdrv_handle);\n-    sl_simple_com_receive();\n\
    +    // cancel previous block receive operation\n+    (void)cancel_receive(uartdrv_handle);\n\
    +    uart_receive_start(uartdrv_handle);\n     CORE_EXIT_ATOMIC();\n     received_count\
    \ = 0;\n   } else {\n@@ -275,7 +281,7 @@ static void timer_callback(sl_sleeptimer_timer_handle_t\
    \ *handle,\n \n #endif // EFR32BG1_USART_E202_WORKAROUND\n \n-/**************************************************************************//**\n\
    +/******************************************************************************\n\
    \  * UART interrupt handler\n  *\n  * Called when the set timer for tx idle states\
    \ finished.\n@@ -288,6 +294,12 @@ void sli_simple_com_isr(void)\n   // RX timeout,\
    \ stop transfer and handle what we got in buffer\n   if (uartdrv_handle->peripheral.uart->IF\
    \ & USART_IF_TCMP1) {\n     CORE_DECLARE_IRQ_STATE;\n+\n+    // Assert nRTS\n\
    +    if (uartdrv_handle->fcType != uartdrvFlowControlHwUart) {\n+      UARTDRV_FlowControlSet(uartdrv_handle,\
    \ uartdrvFlowControlOff);\n+    }\n+\n     CORE_ENTER_ATOMIC();\n     // stop\
    \ the timer\n     uartdrv_handle->peripheral.uart->TIMECMP1 &= \\\n@@ -313,20\
    \ +325,20 @@ void sli_simple_com_isr(void)\n     UARTDRV_GetReceiveStatus(uartdrv_handle,\
    \ &buffer, &received, &remaining);\n     received_count = received;\n #else\n\
    -    // abort receive operation\n-    (void)abort_receive(uartdrv_handle);\n-\
    \    sl_simple_com_receive();\n+    // cancel previous block receive operation\n\
    +    (void)cancel_receive(uartdrv_handle);\n+    uart_receive_start(uartdrv_handle);\n\
    \ #endif // EFR32BG1_USART_E202_WORKAROUND\n     CORE_EXIT_ATOMIC();\n   }\n }\n\
    \ \n-/**************************************************************************//**\n\
    +/******************************************************************************\n\
    \  * Internal UART transmit completed callback\n  *\n  * Called after UART transmit\
    \ is finished.\n  *\n- * @param[in] handle Connection handle\n+ * @param[in] handle\
    \ UART driver handle\n  * @param[in] transferStatus Status of the transfer\n \
    \ * @param[in] data Transmitted data\n  * @param[in] transferCount Number of sent\
    \ bytes\n@@ -351,12 +363,12 @@ static void transmit_cb(UARTDRV_Handle_t handle,\n\
    \   sl_simple_com_os_task_proceed();\n }\n \n-/**************************************************************************//**\n\
    +/******************************************************************************\n\
    \  * Internal UART receive completed callback\n  *\n  * Called after UART receive\
    \ is finished.\n  *\n- * @param[in] handle Connection handle\n+ * @param[in] handle\
    \ UART driver handle\n  * @param[in] transferStatus Status of the transfer\n \
    \ * @param[in] data Received data\n  * @param[in] transferCount Number of received\
    \ bytes\n@@ -391,17 +403,15 @@ static void receive_cb(UARTDRV_Handle_t handle,\n\
    \                              data);\n   }\n \n-  // Clear RX buffer\n-  memset(rx_buf,\
    \ 0, sizeof(rx_buf));\n   sl_simple_com_os_task_proceed();\n }\n \n-/**************************************************************************//**\n\
    - * Aborted reception handler\n+/******************************************************************************\n\
    + * Cancel previous block receive operation.\n  *\n- * @param[in] handle Connection\
    \ handle\n+ * @param[in] handle UART driver handle\n  *****************************************************************************/\n\
    -static Ecode_t abort_receive(UARTDRV_Handle_t handle)\n+static Ecode_t cancel_receive(UARTDRV_Handle_t\
    \ handle)\n {\n   UARTDRV_Buffer_t *rxBuffer;\n   Ecode_t status;\n@@ -418,12\
    \ +428,12 @@ static Ecode_t abort_receive(UARTDRV_Handle_t handle)\n   }\n \n\
    \   // -------------------------------\n-  // Stop the current transfer\n+  //\
    \ Stop the current DMA transfer\n   (void)DMADRV_StopTransfer(handle->rxDmaCh);\n\
    \   handle->rxDmaActive = false;\n   // Update the transfer status of the active\
    \ transfer\n   status = get_tail_buffer(handle->rxQueue, &rxBuffer);\n-  // If\
    \ an abort was in progress when DMA completed, the ISR could be deferred\n+  //\
    \ If aborting was in progress when DMA completed, the ISR could be deferred\n\
    \   // until after the critical section. In this case, the buffers no longer\n\
    \   // exist, even though the DMA complete callback was called.\n   if (status\
    \ == ECODE_EMDRV_UARTDRV_QUEUE_EMPTY) {\n@@ -450,16 +460,12 @@ static Ecode_t\
    \ abort_receive(UARTDRV_Handle_t handle)\n   }\n \n   // -------------------------------\n\
    -  // Disable the receiver\n-  if (handle->fcType != uartdrvFlowControlHwUart)\
    \ {\n-    disable_receiver(handle);\n-  }\n   CORE_EXIT_ATOMIC();\n \n   return\
    \ ECODE_EMDRV_UARTDRV_OK;\n }\n \n-/**************************************************************************//**\n\
    +/******************************************************************************\n\
    \  * Gets the buffer tail.\n  *\n  * @param[in] queue Input buffer\n@@ -482,7\
    \ +488,7 @@ static Ecode_t get_tail_buffer(UARTDRV_Buffer_FifoQueue_t *queue,\n\
    \   return ECODE_EMDRV_UARTDRV_OK;\n }\n \n-/**************************************************************************//**\n\
    +/******************************************************************************\n\
    \  * Dequeues buffer\n  *\n  * Moves through the buffer.\n@@ -509,61 +515,10 @@\
    \ static Ecode_t dequeue_buffer(UARTDRV_Buffer_FifoQueue_t *queue,\n   return\
    \ ECODE_EMDRV_UARTDRV_OK;\n }\n \n-/**************************************************************************//**\n\
    - * Disables receiver.\n- *\n- * @param[in] handle Connection handle\n- *****************************************************************************/\n\
    -static void disable_receiver(UARTDRV_Handle_t handle)\n-{\n-#if (defined(LEUART_COUNT)\
    \ && (LEUART_COUNT > 0) \\\n-  && !defined(_SILICON_LABS_32B_SERIES_2))      \
    \ \\\n-  || (defined(EUART_COUNT) && (EUART_COUNT > 0) )\n-  if (handle->type\
    \ == uartdrvUartTypeUart)\n-#endif\n-  {\n-    // Disable Rx route\n-    #if defined(USART_ROUTEPEN_RXPEN)\n\
    -    handle->peripheral.uart->ROUTEPEN &= ~USART_ROUTEPEN_RXPEN;\n-    #elif defined(USART_ROUTE_RXPEN)\n\
    -    handle->peripheral.uart->ROUTE &= ~USART_ROUTE_RXPEN;\n-    #elif defined(GPIO_USART_ROUTEEN_RXPEN)\n\
    -    GPIO->USARTROUTE_CLR[handle->uartNum].ROUTEEN = GPIO_USART_ROUTEEN_RXPEN;\n\
    -    #endif\n-    // Disable Rx\n-    handle->peripheral.uart->CMD = USART_CMD_RXDIS;\n\
    -  }\n-#if defined(LEUART_COUNT) && (LEUART_COUNT > 0) \\\n-  && !defined(_SILICON_LABS_32B_SERIES_2)\n\
    -  else if (handle->type == uartdrvUartTypeLeuart) {\n-    // Wait for prevous\
    \ register writes to sync\n-    while ((handle->peripheral.leuart->SYNCBUSY &\
    \ LEUART_SYNCBUSY_CMD) != 0U) {\n-    }\n-\n-    // Disable Rx route\n-    #if\
    \ defined(LEUART_ROUTEPEN_RXPEN)\n-    handle->peripheral.leuart->ROUTEPEN &=\
    \ ~LEUART_ROUTEPEN_RXPEN;\n-    #else\n-    handle->peripheral.leuart->ROUTE &=\
    \ ~LEUART_ROUTE_RXPEN;\n-    #endif\n-    // Disable Rx\n-    handle->peripheral.leuart->CMD\
    \ = LEUART_CMD_RXDIS;\n-  }\n-#elif defined(EUART_COUNT) && (EUART_COUNT > 0)\n\
    -  else if (handle->type == uartdrvUartTypeEuart) {\n-    if (EUSART_StatusGet(handle->peripheral.euart)\
    \ &  EUSART_STATUS_TXENS) {\n-      EUSART_Enable(handle->peripheral.euart, eusartEnableTx);\n\
    -    } else {\n-      EUSART_Enable(handle->peripheral.euart, eusartDisable);\n\
    -    }\n-  }\n-#endif\n-}\n-\n-/**************************************************************************//**\n\
    +/******************************************************************************\n\
    \  * Get NVIC IRQ number from UARTDRV handle\n  *\n- * @param[in] handle Connection\
    \ handle\n+ * @param[in] handle UART driver handle\n  * @return Interrupt number\n\
    \  *****************************************************************************/\n\
    \ static IRQn_Type irq_number_from_handle(UARTDRV_Handle_t handle)\n@@ -599,7\
    \ +554,26 @@ static IRQn_Type irq_number_from_handle(UARTDRV_Handle_t handle)\n\
    \   return irq_number;\n }\n \n-/**************************************************************************//**\n\
    +/******************************************************************************\n\
    + * Start / resume UARTDRV receiving\n+ *\n+ * @param[in] handle UART driver handle\n\
    + * @return UARTDRV reported result of the operation\n+ *****************************************************************************/\n\
    +static Ecode_t uart_receive_start(UARTDRV_Handle_t handle)\n+{\n+  Ecode_t ec\
    \ = UARTDRV_Receive(handle, rx_buf, sizeof(rx_buf), receive_cb);\n+\n+  if (ec\
    \ == ECODE_EMDRV_UARTDRV_OK) {\n+    // De-assert nRTS or send XON\n+    if (uartdrv_handle->fcType\
    \ != uartdrvFlowControlHwUart) {\n+      UARTDRV_FlowControlSet(uartdrv_handle,\
    \ uartdrvFlowControlAuto);\n+    }\n+  }\n+\n+  return ec;\n+}\n+/******************************************************************************\n\
    \  * Function to trigger the OS task to proceed\n  *\n  * @note Weak implementation."
  - "--- a/app/bluetooth/common_host/app_sleep/app_sleep.c\n+++ b/app/bluetooth/common_host/app_sleep/app_sleep.c\n\
    @@ -3,7 +3,7 @@\n  * @brief OS dependent sleep functionality.\n  *******************************************************************************\n\
    \  * # License\n- * <b>Copyright 2021 Silicon Laboratories Inc. www.silabs.com</b>\n\
    + * <b>Copyright 2024 Silicon Laboratories Inc. www.silabs.com</b>\n  *******************************************************************************\n\
    \  *\n  * SPDX-License-Identifier: Zlib\n@@ -30,28 +30,50 @@\n \n #include \"\
    app_sleep.h\"\n \n-#if defined(POSIX) && POSIX == 1\n-inline void app_sleep_us(uint64_t\
    \ usec)\n+#if defined(POSIX)\n+#include <unistd.h>\n+#include <sys/select.h>\n\
    +#include <sys/time.h>\n+#include <sys/errno.h>\n+#elif defined(_WIN32)\n+#include\
    \ <windows.h>\n+#endif\n+\n+#if defined(POSIX)\n+// POSIX compliant\n+void app_sleep_us(uint64_t\
    \ usec)\n {\n-  usleep(usec);\n+  struct timeval tv;\n+  int ret = -1;\n+\n+ \
    \ tv.tv_sec = usec / 1000000;\n+  tv.tv_usec = usec % 1000000;\n+\n+  do {\n+\
    \    // using select() instead of usleep(usec) results in better precision and\
    \ slightly lower overall CPU usage as well\n+    ret = select(1, NULL, NULL, NULL,\
    \ &tv);\n+  } while ((ret == -1) && (errno == EINTR)); // select can be interruped\
    \ by SIGALRM\n }\n-#else\n+#elif defined(_WIN32)\n+static NTSTATUS(__stdcall *\
    \ NtDelayExecution)(BOOL Alertable, PLARGE_INTEGER DelayInterval) = NULL;\n+static\
    \ NTSTATUS(__stdcall * ZwSetTimerResolution)(IN ULONG RequestedResolution, IN\
    \ BOOLEAN Set, OUT PULONG ActualResolution) = NULL;\n+\n void app_sleep_us(uint64_t\
    \ usec)\n {\n-  HANDLE timer;\n-  LARGE_INTEGER due_time;\n+  static BOOL lazy_init\
    \ = TRUE; // need to get some function pointers and set timer resolution before\
    \ the first use\n+  LARGE_INTEGER interval;\n \n-  if (usec == 0) {\n-    SwitchToThread();\n\
    -    return;\n+  if (lazy_init) {\n+    ULONG actualResolution;\n+    // import\
    \ two ntdll functions which are needed\n+    ZwSetTimerResolution = (NTSTATUS(__stdcall*)(ULONG,\
    \ BOOLEAN, PULONG))GetProcAddress(GetModuleHandle(\"ntdll.dll\"), \"ZwSetTimerResolution\"\
    );\n+    NtDelayExecution = (NTSTATUS(__stdcall*)(BOOL, PLARGE_INTEGER))GetProcAddress(GetModuleHandle(\"\
    ntdll.dll\"), \"NtDelayExecution\");\n+    // set high resolution\n+    ZwSetTimerResolution(1,\
    \ TRUE, &actualResolution);\n+    lazy_init = FALSE;\n   }\n \n-  // Convert to\
    \ 100 nanosec interval, negative value indicates relative time\n-  due_time.QuadPart\
    \ = -((10 * usec) - 1);\n-\n-  timer = CreateWaitableTimer(NULL, TRUE, NULL);\n\
    -  SetWaitableTimer(timer, &due_time, 0, NULL, NULL, 0);\n-  WaitForSingleObject(timer,\
    \ INFINITE);\n-  CloseHandle(timer);\n+  interval.QuadPart = -1 * (int)(usec *\
    \ 10);\n+  NtDelayExecution(FALSE, &interval);\n }\n #endif"
  - "--- a/app/bluetooth/common_host/esl_key_lib/esl_key_lib.c\n+++ b/app/bluetooth/common_host/esl_key_lib/esl_key_lib.c\n\
    @@ -341,14 +341,16 @@ sl_status_t esl_key_lib_delete_record(const db_handle_p\
    \ db_hnd, const db_record_\n         if (rc == SQLITE_BUSY) {\n           app_log_error(\"\
    Sqlite is busy: %d\" APP_LOG_NL, rc);\n         }\n-      } else {\n-        rc\
    \ = sqlite3_finalize(stmt);\n-        if (rc != SQLITE_OK) {\n-          app_log_error(\"\
    Failed to execute finalize: %s\" APP_LOG_NL, sqlite3_errmsg(*db));\n+      }\n\
    +\n+      rc = sqlite3_finalize(stmt);\n+      if (rc != SQLITE_OK) {\n+     \
    \   app_log_error(\"Failed to execute finalize: %s\" APP_LOG_NL, sqlite3_errmsg(*db));\n\
    +        if (rc != SQLITE_CONSTRAINT) {\n           status = SL_STATUS_ABORT;\n\
    -        } else {\n-          status = SL_STATUS_OK;\n         }\n+      } else\
    \ {\n+        status = SL_STATUS_OK;\n       }\n     }\n \n@@ -431,8 +433,9 @@\
    \ sl_status_t esl_key_lib_get_record_by_ble_address(const db_handle_p db_hnd,\
    \ cons\n       memcpy(&((*record_hnd_out)->identity_key), sqlite3_column_blob(stmt,\
    \ ESL_KEY_LIB_AES_128_KEY_COLUMN_INDEX), sqlite3_column_bytes(stmt, ESL_KEY_LIB_AES_128_KEY_COLUMN_INDEX));\n\
    \       memcpy(&((*record_hnd_out)->ap_key_material), sqlite3_column_blob(stmt,\
    \ ESL_KEY_LIB_EAD_KEY_MATERIAL_COLUMN_INDEX), sqlite3_column_bytes(stmt, ESL_KEY_LIB_EAD_KEY_MATERIAL_COLUMN_INDEX));\n\
    \     } else {\n-      // Reset the statement, searching in the tag table\n- \
    \     sqlite3_reset(stmt);\n+      // Destroy the previous statement, searching\
    \ in the tag table instead\n+      sqlite3_finalize(stmt);\n+      stmt = NULL;\n\
    \       rc = sqlite3_prepare_v2(*db, \"SELECT * FROM tag_table WHERE tag_ble_address\
    \ = ?;\", -1, &stmt, NULL);\n \n       if (rc != SQLITE_OK) {\n@@ -1063,7 +1066,10\
    \ @@ static sl_status_t internal_store_record(const db_handle_p db_hnd,\n    \
    \   }\n     }\n \n-    sqlite3_reset(stmt);\n+    if (stmt != NULL) {\n+     \
    \ (void)sqlite3_finalize(stmt);\n+      stmt = NULL;\n+    }\n \n     if (status\
    \ == SL_STATUS_OK) {\n       // BLE address is not in the other table, we can\
    \ put the new record in\n@@ -1090,10 +1096,12 @@ static sl_status_t internal_store_record(const\
    \ db_handle_p db_hnd,\n       if (rc != SQLITE_DONE) {\n         app_log_error(\"\
    Failed to execute step: %s, %d\" APP_LOG_NL, sqlite3_errmsg(*db), rc);\n     \
    \    status = SL_STATUS_OBJECT_WRITE;\n-      } else {\n-        rc = sqlite3_finalize(stmt);\n\
    -        if (rc != SQLITE_OK) {\n-          app_log_error(\"Failed to execute\
    \ finalize: %s\" APP_LOG_NL, sqlite3_errmsg(*db));\n+      }\n+\n+      rc = sqlite3_finalize(stmt);\n\
    +      if (rc != SQLITE_OK) {\n+        app_log_error(\"Failed to execute finalize:\
    \ %s\" APP_LOG_NL, sqlite3_errmsg(*db));\n+        if (rc != SQLITE_CONSTRAINT)\
    \ {\n           status = SL_STATUS_ABORT;\n         }\n       }"
  - "--- a/app/bluetooth/common_host/esl_lib/esl_lib_connection.c\n+++ b/app/bluetooth/common_host/esl_lib/esl_lib_connection.c\n\
    @@ -55,14 +55,14 @@\n #define GATT_TIMEOUT_MS       10000\n \n // connection parameters\
    \ for PAST\n-#define PAST_CONN_INTERVAL_MIN       0x0006 // given in 1.25ms units,\
    \ 6 * 1.25 = 7.5ms, limited by Core specification\n-#define PAST_CONN_INTERVAL_MAX\
    \       0x0c80 // limited by Core specification to 4 seconds\n+#define PAST_CONN_INTERVAL_MIN\
    \       ESL_LIB_CONN_INTERVAL_MIN\n+#define PAST_CONN_INTERVAL_MAX       ESL_LIB_CONN_INTERVAL_MAX\n\
    \ #define PAST_CONN_PERIPHERAL_LATENCY 1      // allow to skip one connection\
    \ interval during PAST if there's no data\n #define PAST_CONN_DEFAULT_TIMEOUT\
    \    1000   // value * 10ms, this is 10 seconds\n-#define PAST_CONN_MIN_TIMEOUT\
    \        0x000a // min 100ms according to COre specification\n-#define PAST_CONN_MAX_TIMEOUT\
    \        0x0c80 // max 32 seconds according to COre specification\n-#define PAST_CONN_MIN_CE_LENGTH\
    \      0\n-#define PAST_CONN_MAX_CE_LENGTH      0xffff\n+#define PAST_CONN_MIN_TIMEOUT\
    \        ESL_LIB_CONN_MIN_TIMEOUT\n+#define PAST_CONN_MAX_TIMEOUT        ESL_LIB_CONN_MAX_TIMEOUT\n\
    +#define PAST_CONN_MIN_CE_LENGTH      ESL_LIB_CONN_MIN_CE_LENGTH\n+#define PAST_CONN_MAX_CE_LENGTH\
    \      ESL_LIB_CONN_MAX_CE_LENGTH // can be tuned to fits specific radio timing\
    \ needs\n #define PAST_GRACE_INTERVAL_COUNT    6\n \n #define PAWR_SERVICE_DATA\
    \            42\n@@ -86,6 +86,8 @@ typedef struct {\n static void esl_lib_connection_safe_remove_ptr(esl_lib_connection_t\
    \ *ptr);\n static void run_command(esl_lib_command_list_cmd_t *cmd);\n static\
    \ sl_status_t close_connection(esl_lib_connection_t *conn);\n+static sl_status_t\
    \ send_retry_event(esl_lib_connection_t *conn,\n+                            \
    \        sl_status_t          reason);\n static sl_status_t send_connection_status(esl_lib_connection_t\
    \ *conn,\n                                           esl_lib_bool_t       status,\n\
    \                                           sl_status_t          reason);\n@@\
    \ -703,6 +705,8 @@ void esl_lib_connection_on_bt_event(sl_bt_msg_t *evt)\n   \
    \                                         conn->connection_handle);\n        \
    \       conn->command_complete = true;\n             } else {\n+             \
    \ // Let the AP know that the connection is now closed but will retry\n+     \
    \         send_retry_event(conn, reason);\n               break;\n           \
    \  }\n           } else {\n@@ -896,6 +900,9 @@ void esl_lib_connection_on_bt_event(sl_bt_msg_t\
    \ *evt)\n       if (sc == SL_STATUS_OK) {\n         lib_status = ESL_LIB_STATUS_NO_ERROR;\n\
    \       } else {\n+        // Set library status accordingly.\n+        lib_status\
    \ = ESL_LIB_STATUS_BONDING_FAILED;\n+        conn->state = ESL_LIB_CONNECTION_STATE_BONDING_FAIL_RECONNECT;\n\
    \         // Defer forced close on error - normally the close event should come,\
    \ this is just a watchdog\n         (void)app_timer_stop(&conn->timer);\n    \
    \     (void)app_timer_start(&conn->timer,\n@@ -1036,7 +1043,7 @@ void esl_lib_connection_on_bt_event(sl_bt_msg_t\
    \ *evt)\n         // Check size for UUID if in proper state - send error otherwise\n\
    \         if (conn->state != ESL_LIB_CONNECTION_STATE_SERVICE_DISCOVERY) {\n \
    \          sc = SL_STATUS_INVALID_STATE;\n-          lib_status = conn->state;\n\
    +          lib_status = ESL_LIB_STATUS_CONN_DISCOVERY_FAILED;\n           esl_lib_log_connection_error(CONN_FMT\
    \ \"Service discovery failed, connection handle = %u, sc = 0x%04x\" APP_LOG_NL,\n\
    \                                        conn,\n                             \
    \           conn->connection_handle,\n@@ -1735,7 +1742,6 @@ static sl_status_t\
    \ send_cp_notification_event(esl_lib_connection_t *conn,\n                   \
    \                 len,\n                                    &lib_evt);\n   if\
    \ (sc == SL_STATUS_OK) {\n-    lib_evt->evt_code = ESL_LIB_EVT_CONTROL_POINT_NOTIFICATION;\n\
    \     lib_evt->data.evt_control_point_notification.connection_handle\n       =\
    \ (esl_lib_connection_handle_t)conn;\n     lib_evt->data.evt_control_point_notification.data.len\
    \ = len;\n@@ -1761,7 +1767,6 @@ static sl_status_t send_bonding_finished(esl_lib_connection_t\
    \ *conn)\n                                    0,\n                           \
    \         &lib_evt);\n   if (sc == SL_STATUS_OK) {\n-    lib_evt->evt_code = ESL_LIB_EVT_BONDING_FINISHED;\n\
    \     lib_evt->data.evt_bonding_finished.connection_handle\n       = (esl_lib_connection_handle_t)conn;\n\
    \     // Copy address\n@@ -1789,7 +1794,6 @@ static sl_status_t send_bonding_data(esl_lib_connection_t\
    \ *conn,\n                                    0,\n                           \
    \         &lib_evt);\n   if (sc == SL_STATUS_OK) {\n-    lib_evt->evt_code = ESL_LIB_EVT_BONDING_DATA;\n\
    \     lib_evt->data.evt_bonding_data.connection_handle\n       = (esl_lib_connection_handle_t)conn;\n\
    \     // Copy address\n@@ -1810,6 +1814,40 @@ static sl_status_t send_bonding_data(esl_lib_connection_t\
    \ *conn,\n   return sc;\n }\n \n+static sl_status_t send_retry_event(esl_lib_connection_t\
    \ *conn,\n+                                    sl_status_t          reason)\n\
    +{\n+  esl_lib_evt_t *lib_evt;\n+  sl_status_t sc = esl_lib_event_list_allocate(ESL_LIB_EVT_CONNECTION_RETRY,\n\
    +                                               0,\n+                        \
    \                       &lib_evt);\n+  if (sc == SL_STATUS_OK) {\n+    lib_evt->data.evt_connection_retry.connection_handle\
    \ = (esl_lib_connection_handle_t)conn;\n+    // Set last known connection state\
    \ for the event\n+    lib_evt->data.evt_connection_retry.connection_state = conn->state;\n\
    +    // Update the connection state\n+    conn->state = ESL_LIB_CONNECTION_STATE_RECONNECTING;\n\
    +    // Set reason for disconnection event\n+    lib_evt->data.evt_connection_retry.reason\
    \ = reason;\n+    // Copy address and set its type\n+    lib_evt->data.evt_connection_retry.address.address_type\
    \ = conn->address_type;\n+    // Copy remaining retry count, if known\n+    if\
    \ ((conn->command != NULL) && (conn->command->cmd_code == ESL_LIB_CMD_CONNECT))\
    \ {\n+      lib_evt->data.evt_connection_retry.retries_left = conn->command->data.cmd_connect.retries_left;\n\
    +    }\n+    memcpy(lib_evt->data.evt_connection_retry.address.addr,\n+      \
    \     conn->address.addr,\n+           sizeof(conn->address.addr));\n+    sc =\
    \ esl_lib_event_list_push_back(lib_evt);\n+\n+    if (sc != SL_STATUS_OK) {\n\
    +      // Free up memory on failure\n+      esl_lib_memory_free(lib_evt);\n+ \
    \   }\n+  }\n+\n+  return sc;\n+}\n static sl_status_t send_connection_status(esl_lib_connection_t\
    \ *conn,\n                                           esl_lib_bool_t       status,\n\
    \                                           sl_status_t          reason)\n@@ -1827,8\
    \ +1865,6 @@ static sl_status_t send_connection_status(esl_lib_connection_t *conn,\n\
    \                                    0,\n                                    &lib_evt);\n\
    \   if (sc == SL_STATUS_OK) {\n-    // Set event type\n-    lib_evt->evt_code\
    \ = type;\n     // Get pointer to status data in general\n     if (status == ESL_LIB_TRUE)\
    \ {\n       // Set handle\n@@ -1890,7 +1926,6 @@ static sl_status_t send_att_response(esl_lib_connection_t\
    \ *conn,\n   if (type == ESL_LIB_EVT_CONFIGURE_TAG_RESPONSE) {\n     sc = esl_lib_event_list_allocate(type,\
    \ 0, &lib_evt);\n     if (sc == SL_STATUS_OK) {\n-      lib_evt->evt_code = type;\n\
    \       // Tag config response\n       lib_evt->data.evt_configure_tag_response.connection_handle\n\
    \         = (esl_lib_connection_handle_t)conn;\n@@ -1903,7 +1938,6 @@ static sl_status_t\
    \ send_att_response(esl_lib_connection_t *conn,\n                            \
    \          conn->command->data.cmd_write_control_point.data.len,\n           \
    \                           &lib_evt);\n     if (sc == SL_STATUS_OK) {\n-    \
    \  lib_evt->evt_code = type;\n       // Control Point response\n       lib_evt->data.evt_control_point_response.connection_handle\n\
    \         = (esl_lib_connection_handle_t)conn;\n@@ -2085,7 +2119,6 @@ static void\
    \ on_image_transfer_finished(esl_lib_image_transfer_handle_t handle,\n     if\
    \ (result == SL_STATUS_OK) {\n       sc = esl_lib_event_list_allocate(ESL_LIB_EVT_IMAGE_TRANSFER_FINISHED,\
    \ 0, &lib_evt);\n       if (sc == SL_STATUS_OK) {\n-        lib_evt->evt_code\
    \ = ESL_LIB_EVT_IMAGE_TRANSFER_FINISHED;\n         lib_evt->data.evt_image_transfer_finished.connection_handle\
    \ = conn;\n         lib_evt->data.evt_image_type.img_index = image_index;\n  \
    \       lib_evt->data.evt_image_transfer_finished.status = result;\n@@ -2142,7\
    \ +2175,6 @@ static void on_image_transfer_type_arrived(esl_lib_image_transfer_handle_t\
    \ handl\n     if (result == SL_STATUS_OK) {\n       sc = esl_lib_event_list_allocate(ESL_LIB_EVT_IMAGE_TYPE,\
    \ len, &lib_evt);\n       if (sc == SL_STATUS_OK) {\n-        lib_evt->evt_code\
    \ = ESL_LIB_EVT_IMAGE_TYPE;\n         lib_evt->data.evt_image_type.connection_handle\
    \ = conn;\n         lib_evt->data.evt_image_type.img_index = image_index;\n  \
    \       lib_evt->data.evt_image_type.type_data.len = len;"
  - "--- a/app/bluetooth/common_host/esl_lib/esl_lib_core.c\n+++ b/app/bluetooth/common_host/esl_lib/esl_lib_core.c\n\
    @@ -240,6 +240,17 @@ static void esl_lib_core_on_bt_event(sl_bt_msg_t *evt)\n\
    \         lib_critical_error = true;\n       }\n \n+      sc = sl_bt_connection_set_default_parameters(ESL_LIB_CONN_INTERVAL_MIN,\n\
    +                                                   ESL_LIB_CONN_INTERVAL_MIN,\n\
    +                                                   ESL_LIB_CONN_PERIPHERAL_LATENCY,\n\
    +                                                   ESL_LIB_CONN_DEFAULT_TIMEOUT,\n\
    +                                                   ESL_LIB_CONN_MIN_CE_LENGTH,\n\
    +                                                   ESL_LIB_CONN_MAX_CE_LENGTH);\n\
    +      if (sc != SL_STATUS_OK) {\n+        esl_lib_log_core_critical(\"Failed\
    \ to set connection parameters, sc = 0x%04x\" APP_LOG_NL, sc);\n+        lib_critical_error\
    \ = true;\n+      }\n+\n       // Allocate and add event to the event list\n \
    \      sc = esl_lib_event_list_allocate(ESL_LIB_EVT_SYSTEM_BOOT, 0, &new_event);\n\
    \       if (sc == SL_STATUS_OK) {"
  - "--- a/app/bluetooth/common_host/esl_lib/esl_lib_event_list.c\n+++ b/app/bluetooth/common_host/esl_lib/esl_lib_event_list.c\n\
    @@ -126,6 +126,9 @@ sl_status_t esl_lib_event_list_allocate(esl_lib_evt_type_t\
    \ event_type,\n       size += sizeof(esl_lib_evt_control_point_notification_t);\n\
    \       size += additional_size;\n       break;\n+    case ESL_LIB_EVT_CONNECTION_RETRY:\n\
    +      size += sizeof(esl_lib_evt_connection_retry_t);\n+      break;\n     case\
    \ ESL_LIB_EVT_CONNECTION_CLOSED:\n       size += sizeof(esl_lib_evt_connection_closed_t);\n\
    \       break;\n@@ -175,8 +178,9 @@ sl_status_t esl_lib_event_list_allocate(esl_lib_evt_type_t\
    \ event_type,\n   }\n \n   memset(ptr, 0, size);\n-\n   *ptr_out = (esl_lib_evt_t\
    \ *)ptr;\n+  // Set event type\n+  (*ptr_out)->evt_code = event_type;\n \n   return\
    \ sc;\n }"
  - "--- a/app/bluetooth/common_host/host_comm/host_comm_posix.c\n+++ b/app/bluetooth/common_host/host_comm/host_comm_posix.c\n\
    @@ -182,7 +182,7 @@ sl_status_t host_comm_set_option(char option, char *value)\n\
    \       break;\n     // UART flow control disable.\n     case 'f':\n-      uart_flow_control\
    \ = 1;\n+      uart_flow_control = 0;\n       break;\n     // AF socket descriptor\n\
    \     case 'n':"
  - "--- a/app/bluetooth/common_host/host_comm/host_comm_win.c\n+++ b/app/bluetooth/common_host/host_comm/host_comm_win.c\n\
    @@ -151,7 +151,7 @@ sl_status_t host_comm_set_option(char option, char *value)\n\
    \       break;\n     // UART flow control disable.\n     case 'f':\n-      uart_flow_control\
    \ = 1;\n+      uart_flow_control = 0;\n       break;\n     // Unknown option.\n\
    \     default:"
  - "--- a/app/bluetooth/example/bt_soc_app_ota_dfu/app.c\n+++ b/app/bluetooth/example/bt_soc_app_ota_dfu/app.c\n\
    @@ -3,7 +3,7 @@\n  * @brief Core application logic.\n  *******************************************************************************\n\
    \  * # License\n- * <b>Copyright 2022 Silicon Laboratories Inc. www.silabs.com</b>\n\
    + * <b>Copyright 2024 Silicon Laboratories Inc. www.silabs.com</b>\n  *******************************************************************************\n\
    \  *\n  * SPDX-License-Identifier: Zlib\n@@ -367,12 +367,15 @@ static void app_ota_dfu_on_status_change(sl_bt_app_ota_dfu_status_t\
    \ curr_sts,\n       app_log_info(\"Bootloader initialized.\" APP_LOG_NL);\n  \
    \     break;\n \n+    case SL_BT_APP_OTA_DFU_READ_FLASH:\n+      app_log_info(\"\
    Read storage slot...\" APP_LOG_NL);\n+      break;\n+\n     case SL_BT_APP_OTA_DFU_ERASE:\n\
    -      app_log_info(\"Erase storage slot...\" APP_LOG_NL);\n+      app_log_info(\"\
    Erasing...\" APP_LOG_NL);\n       break;\n \n     case SL_BT_APP_OTA_DFU_READY:\n\
    -      app_log_info(\"Erase done.\" APP_LOG_NL);\n       app_log_info(\"Application\
    \ OTA DFU ready.\" APP_LOG_NL);\n       break;\n "
  - "--- a/app/bluetooth/example_host/bt_aoa_host_locator/app.c\n+++ b/app/bluetooth/example_host/bt_aoa_host_locator/app.c\n\
    @@ -181,7 +181,6 @@ void app_init(int argc, char *argv[])\n     app_log_info(\"\
    Selected CTE mode: %s\" APP_LOG_NL, cte_mode_string);\n   }\n   app_log_info(\"\
    Press Crtl+C to quit\" APP_LOG_NL APP_LOG_NL);\n-  ncp_reset();\n }\n \n /**************************************************************************//**"
  - "--- a/app/bluetooth/example_host/bt_host_ncp_test/app.c\n+++ b/app/bluetooth/example_host/bt_host_ncp_test/app.c\n\
    @@ -43,7 +43,7 @@\n #include \"sl_bt_api.h\"\n \n // Optstring argument for getopt.\n\
    -#define OPTSTRING   NCP_HOST_OPTSTRING \"c:w:i:e:h\"\n+#define OPTSTRING   NCP_HOST_OPTSTRING\
    \ APP_LOG_OPTSTRING \"c:w:i:e:h\"\n \n // Usage info.\n #define USAGE       APP_LOG_NL\
    \ \"%s \" NCP_HOST_USAGE APP_LOG_USAGE \" -c <command id> [-w <width>] [-i <interval>]\
    \ [-e <end>] [-h]\" APP_LOG_NL\n@@ -144,6 +144,9 @@ void app_init(int argc, char\
    \ *argv[])\n       // Process options for other modules.\n       default:\n  \
    \       sc = ncp_host_set_option((char)opt, optarg);\n+        if (sc == SL_STATUS_NOT_FOUND)\
    \ {\n+          sc = app_log_set_option((char)opt, optarg);\n+        }\n    \
    \     if (sc != SL_STATUS_OK) {\n           app_log(USAGE, argv[0]);\n       \
    \    exit(EXIT_FAILURE);"
  - '--- a/app/btmesh/common/btmesh_custom_role/sl_btmesh_custom_role.c

    +++ b/app/btmesh/common/btmesh_custom_role/sl_btmesh_custom_role.c

    @@ -0,0 +1,67 @@

    +/***************************************************************************//**

    + * @file

    + * @brief BT Mesh Custom Role Initializer

    + *******************************************************************************

    + * # License

    + * <b>Copyright 2024 Silicon Laboratories Inc. www.silabs.com</b>

    + *******************************************************************************

    + *

    + * SPDX-License-Identifier: Zlib

    + *

    + * The licensor of this software is Silicon Laboratories Inc.

    + *

    + * This software is provided ''as-is'', without any express or implied

    + * warranty. In no event will the authors be held liable for any damages

    + * arising from the use of this software.

    + *

    + * Permission is granted to anyone to use this software for any purpose,

    + * including commercial applications, and to alter it and redistribute it

    + * freely, subject to the following restrictions:

    + *

    + * 1. The origin of this software must not be misrepresented; you must not

    + *    claim that you wrote the original software. If you use this software

    + *    in a product, an acknowledgment in the product documentation would be

    + *    appreciated but is not required.

    + * 2. Altered source versions must be plainly marked as such, and must not be

    + *    misrepresented as being the original software.

    + * 3. This notice may not be removed or altered from any source distribution.

    + *

    + ******************************************************************************/

    +

    +// -----------------------------------------------------------------------------

    +// Includes

    +

    +#include "sl_bt_api.h"

    +#include "sl_btmesh_custom_role.h"

    +#include "sl_common.h"

    +

    +/***************************************************************************//**

    + * @addtogroup btmesh_custom_role

    + * @{

    + ******************************************************************************/

    +

    +// -----------------------------------------------------------------------------

    +// Public function definitions

    +

    +// Handle BLE events for the mesh custom role

    +void sl_bt_custom_role_on_event(sl_bt_msg_t* evt)

    +{

    +  switch (SL_BT_MSG_ID(evt->header)) {

    +    case sl_bt_evt_system_boot_id:

    +      sl_btmesh_custom_role_init();

    +      break;

    +    default:

    +      break;

    +  }

    +}

    +

    +// -----------------------------------------------------------------------------

    +// Event / callback definitions

    +

    +// Called on boot event and the application is able to override this function

    +// to initialize the device as a provisioner or as a provisionee.

    +SL_WEAK void sl_btmesh_custom_role_init(void)

    +{

    +}

    +

    +/** @} (end addtogroup btmesh_custom_role) */'
  - "--- a/app/btmesh/common/btmesh_provisioner/sl_btmesh_provisioner.c\n+++ b/app/btmesh/common/btmesh_provisioner/sl_btmesh_provisioner.c\n\
    @@ -75,4 +75,4 @@ SL_WEAK void sl_btmesh_provisioner_on_init(sl_status_t result)\n\
    \   (void)result;\n }\n \n-/** @} (end addtogroup provisionee) */\n+/** @} (end\
    \ addtogroup provisioner) */"
  - "--- a/app/btmesh/example/btmesh_soc_light_ctl/app_out_lcd.c\n+++ b/app/btmesh/example/btmesh_soc_light_ctl/app_out_lcd.c\n\
    @@ -60,6 +60,11 @@\n \n #include \"sl_btmesh_wstk_lcd.h\"\n \n+// -----------------------------------------------------------------------------\n\
    +// Macros\n+\n+#define LIGHTNESS_LEVEL_TO_PERCENTAGE(lev) ((((lev) * 100) + 32767)\
    \ / 65535)\n+\n // -----------------------------------------------------------------------------\n\
    \ // BT mesh Friend Node Callbacks\n \n@@ -156,7 +161,7 @@ void sl_btmesh_lighting_server_on_ui_update(uint16_t\
    \ lightness_level)\n {\n   // Temporary buffer to format the LCD output text\n\
    \   char tmp_str[LCD_ROW_LEN];\n-  uint16_t lightness_percent = (lightness_level\
    \ * 100 + 99) / 65535;\n+  uint16_t lightness_percent = LIGHTNESS_LEVEL_TO_PERCENTAGE(lightness_level);\n\
    \ \n   app_log(\"BT mesh Lightness: %5u%%\" APP_LOG_NL, lightness_percent);\n\
    \   snprintf(tmp_str, LCD_ROW_LEN, \"Lightness: %5u%%\", lightness_percent);"
  - "--- a/app/btmesh/example/btmesh_soc_light_ctl/app_out_log.c\n+++ b/app/btmesh/example/btmesh_soc_light_ctl/app_out_log.c\n\
    @@ -57,7 +57,10 @@\n #include \"sl_btmesh_factory_reset.h\"\n #endif // SL_CATALOG_BTMESH_FACTORY_RESET_PRESENT\n\
    \ \n-#define LIGHTNESS_LEVEL_TO_PERCENTAGE(lev) ((((lev) * 100) + 99) / 65535)\n\
    +// -----------------------------------------------------------------------------\n\
    +// Macros\n+\n+#define LIGHTNESS_LEVEL_TO_PERCENTAGE(lev) ((((lev) * 100) + 32767)\
    \ / 65535)\n \n // -----------------------------------------------------------------------------\n\
    \ // BT mesh Friend Node Callbacks"
  - "--- a/app/btmesh/example/btmesh_soc_nlc_basic_lightness_controller/app_out_lcd.c\n\
    +++ b/app/btmesh/example/btmesh_soc_nlc_basic_lightness_controller/app_out_lcd.c\n\
    @@ -64,6 +64,11 @@\n #define lcd_print(...) SL_STATUS_OK\n #endif // SL_CATALOG_BTMESH_WSTK_LCD_PRESENT\n\
    \ \n+// -----------------------------------------------------------------------------\n\
    +// Macros\n+\n+#define LIGHTNESS_LEVEL_TO_PERCENTAGE(lev) ((((lev) * 100) + 32767)\
    \ / 65535)\n+\n // -----------------------------------------------------------------------------\n\
    \ // Event / callback definitions\n \n@@ -111,7 +116,7 @@ void sl_btmesh_friend_on_friendship_terminated(uint16_t\
    \ netkey_index,\n  ******************************************************************************/\n\
    \ void sl_btmesh_lighting_server_on_ui_update(uint16_t lightness_level)\n {\n\
    -  uint16_t lightness_percent = (lightness_level * 100 + 99) / 65535;\n+  uint16_t\
    \ lightness_percent = LIGHTNESS_LEVEL_TO_PERCENTAGE(lightness_level);\n   app_log(\"\
    BT mesh Lightness: %5u%%\" APP_LOG_NL, lightness_percent);\n   #ifdef SL_CATALOG_BTMESH_WSTK_LCD_PRESENT\n\
    \   // Temporary buffer to format the LCD output text"
  - "--- a/app/btmesh/example/btmesh_soc_nlc_basic_lightness_controller/app_out_log.c\n\
    +++ b/app/btmesh/example/btmesh_soc_nlc_basic_lightness_controller/app_out_log.c\n\
    @@ -58,7 +58,7 @@\n // -----------------------------------------------------------------------------\n\
    \ // Macros\n \n-#define LIGHTNESS_LEVEL_TO_PERCENTAGE(lev) ((((lev) * 100) +\
    \ 99) / 65535)\n+#define LIGHTNESS_LEVEL_TO_PERCENTAGE(lev) ((((lev) * 100) +\
    \ 32767) / 65535)\n \n // -----------------------------------------------------------------------------\n\
    \ // Event / callback definitions"
  - "--- a/app/common/example/se_manager_host_firmware_upgrade/app_host_firmware_image.c\n\
    +++ b/app/common/example/se_manager_host_firmware_upgrade/app_host_firmware_image.c\n\
    @@ -36,7 +36,7 @@\n //                                Static Variables\n // -----------------------------------------------------------------------------\n\
    \ /// Host firmware image\n-SL_ALIGN(4) static const uint8_t host_firmware_image[]\
    \ SL_ATTRIBUTE_ALIGN(4) =\n+SL_ALIGN(4) static const uint8_t host_firmware_image[]\
    \ SL_ATTRIBUTE_ALIGN(4) SL_ATTRIBUTE_SECTION(\"FW\") =\n {\n #if (_SILICON_LABS_32B_SERIES_2_CONFIG\
    \ == 1)  // EFR32xG21 host firmware\n   0x00, 0x10, 0x00, 0x20, 0xE1, 0x04, 0x00,\
    \ 0x00, 0xDD, 0x04, 0x00, 0x00, 0xDD, 0x04, 0x00, 0x00, 0xDD, 0x04, 0x00, 0x00,\
    \ 0xDD, 0x04, 0x00, 0x00, 0xDD, 0x04, 0x00, 0x00, 0xDD, 0x04, 0x00, 0x00, 0xDD,\
    \ 0x04, 0x00, 0x00, 0xDD, 0x04, 0x00, 0x00,"
  - "--- a/app/common/example/wifi_commissioning_micriumos/app_wifi_events.c\n+++\
    \ b/app/common/example/wifi_commissioning_micriumos/app_wifi_events.c\n@@ -455,7\
    \ +455,7 @@ static void wfx_events_task(void *p_arg)\n             // Enable the\
    \ WFX power save mode\n             // Note: this mode is independent from the\
    \ host power saving\n             //       but has been linked to simplicfy the\
    \ example.\n-            sl_wfx_set_power_mode(WFM_PM_MODE_PS, WFM_PM_POLL_FAST_PS,\
    \ 1);\n+            sl_wfx_set_power_mode(WFM_PM_MODE_PS, WFM_PM_POLL_FAST_PS,\
    \ 1, 0);\n             sl_wfx_enable_device_power_save();\n           }\n #endif\n\
    @@ -472,7 +472,7 @@ static void wfx_events_task(void *p_arg)\n \n #ifdef SL_CATALOG_POWER_MANAGER_PRESENT\n\
    \           // Power save always disabled when SoftAP mode enabled\n-        \
    \  sl_wfx_set_power_mode(WFM_PM_MODE_ACTIVE, WFM_PM_POLL_FAST_PS, 0);\n+     \
    \     sl_wfx_set_power_mode(WFM_PM_MODE_ACTIVE, WFM_PM_POLL_FAST_PS, 0, 0);\n\
    \           sl_wfx_disable_device_power_save();\n #endif\n           break;\n\
    @@ -486,7 +486,7 @@ static void wfx_events_task(void *p_arg)\n             //\
    \ Enable the WFX power save mode\n             // Note: this mode is independent\
    \ from the host power saving\n             //       but has been linked to simplicfy\
    \ the example.\n-            sl_wfx_set_power_mode(WFM_PM_MODE_PS, WFM_PM_POLL_FAST_PS,\
    \ 1);\n+            sl_wfx_set_power_mode(WFM_PM_MODE_PS, WFM_PM_POLL_FAST_PS,\
    \ 1, 0);\n             sl_wfx_enable_device_power_save();\n           }\n #endif"
  - "--- a/app/common/util/app_timer/app_timer.c\n+++ b/app/common/util/app_timer/app_timer.c\n\
    @@ -55,7 +55,7 @@ static app_timer_t *app_timer_head = NULL;\n // -----------------------------------------------------------------------------\n\
    \ // Private function declarations\n \n-/***************************************************************************//**\n\
    +/*******************************************************************************\n\
    \  * Common callback for the sleeptimers.\n  *\n  * @param[in] handle Pointer\
    \ to the sleeptimer handle.\n@@ -66,7 +66,7 @@ static app_timer_t *app_timer_head\
    \ = NULL;\n static void app_timer_callback(sl_sleeptimer_timer_handle_t *handle,\n\
    \                                void *data);\n \n-/***************************************************************************//**\n\
    +/*******************************************************************************\n\
    \  * Append a timer to the end of the linked list.\n  *\n  * @param[in] timer\
    \ Pointer to the timer handle.\n@@ -75,7 +75,7 @@ static void app_timer_callback(sl_sleeptimer_timer_handle_t\
    \ *handle,\n  ******************************************************************************/\n\
    \ static void append_app_timer(app_timer_t *timer);\n \n-/***************************************************************************//**\n\
    +/*******************************************************************************\n\
    \  * Remove a timer from the linked list.\n  *\n  * @param[in] timer Pointer to\
    \ the timer handle.\n@@ -86,6 +86,16 @@ static void append_app_timer(app_timer_t\
    \ *timer);\n  ******************************************************************************/\n\
    \ static bool remove_app_timer(app_timer_t *timer);\n \n+/*******************************************************************************\n\
    + * Find and return the first triggered timer from the linked list.\n+ *\n+ *\
    \ @return The first triggered timer from the linked list.\n+ *\n+ * @note The\
    \ trigger state is also reset, and it is removed from the list if\n+ * the timer\
    \ is non-periodic.\n+ ******************************************************************************/\n\
    +static app_timer_t *get_triggered_app_timer(void);\n+\n // -----------------------------------------------------------------------------\n\
    \ // Public function definitions\n \n@@ -190,21 +200,14 @@ sl_status_t app_timer_stop(app_timer_t\
    \ *timer)\n void sli_app_timer_step(void)\n {\n   if (trigger_count > 0) {\n-\
    \    app_timer_t *timer = app_timer_head;\n     // Find triggered timers in list\
    \ and call their callbacks.\n-    while (timer != NULL) {\n-      if (timer->triggered)\
    \ {\n-        CORE_ATOMIC_SECTION(\n-          timer->triggered = false;\n-  \
    \        --trigger_count;\n-          )\n-        if (!timer->periodic) {\n- \
    \         (void)remove_app_timer(timer);\n-        }\n+    app_timer_t *timer;\n\
    +    do {\n+      timer = get_triggered_app_timer();\n+      if (timer != NULL)\
    \ {\n         timer->callback(timer, timer->callback_data);\n       }\n-     \
    \ timer = timer->next;\n-    }\n+    } while (timer != NULL);\n   }\n }\n \n@@\
    \ -277,6 +280,9 @@ static void app_timer_callback(sl_sleeptimer_timer_handle_t\
    \ *handle,\n \n static void append_app_timer(app_timer_t *timer)\n {\n+  CORE_DECLARE_IRQ_STATE;\n\
    +  CORE_ENTER_ATOMIC();\n+\n   if (app_timer_head != NULL) {\n     app_timer_t\
    \ *current = app_timer_head;\n     // Find end of list.\n@@ -288,10 +294,15 @@\
    \ static void append_app_timer(app_timer_t *timer)\n     app_timer_head = timer;\n\
    \   }\n   timer->next = NULL;\n+\n+  CORE_EXIT_ATOMIC();\n }\n \n static bool\
    \ remove_app_timer(app_timer_t *timer)\n {\n+  CORE_DECLARE_IRQ_STATE;\n+  CORE_ENTER_ATOMIC();\n\
    +\n   app_timer_t *prev = NULL;\n   app_timer_t *current = app_timer_head;\n \n\
    @@ -303,6 +314,7 @@ static bool remove_app_timer(app_timer_t *timer)\n \n   if\
    \ (current != timer) {\n     // Not found.\n+    CORE_EXIT_ATOMIC();\n     return\
    \ false;\n   }\n \n@@ -311,5 +323,32 @@ static bool remove_app_timer(app_timer_t\
    \ *timer)\n   } else {\n     app_timer_head = timer->next;\n   }\n+  CORE_EXIT_ATOMIC();\n\
    \   return true;\n }\n+\n+static app_timer_t *get_triggered_app_timer(void)\n\
    +{\n+  CORE_DECLARE_IRQ_STATE;\n+  CORE_ENTER_ATOMIC();\n+\n+  // Find the first\
    \ triggered timer in list\n+  app_timer_t *timer = app_timer_head;\n+  while (timer\
    \ != NULL) {\n+    if (timer->triggered) {\n+      // Timer found\n+      timer->triggered\
    \ = false;\n+      --trigger_count;\n+      if (!timer->periodic) {\n+       \
    \ (void)remove_app_timer(timer);\n+      }\n+\n+      CORE_EXIT_ATOMIC();\n+ \
    \     return timer;\n+    }\n+    timer = timer->next;\n+  }\n+\n+  CORE_EXIT_ATOMIC();\n\
    +  return NULL;\n+}"
  - "--- a/app/flex/component/connect/sl_connect_ecdh_key_exchange/sl_connect_ecdh_key_exchange.c\n\
    +++ b/app/flex/component/connect/sl_connect_ecdh_key_exchange/sl_connect_ecdh_key_exchange.c\n\
    @@ -202,8 +202,9 @@ psa_status_t sl_connect_ecdh_key_exchange_encrypt_message(\n\
    \     cipher_text_length);\n \n   if (psa_status == PSA_SUCCESS) {\n-    memcpy(cipher_text,\
    \ data, *cipher_text_length - iv_size);\n-    memcpy(iv, data + *cipher_text_length\
    \ - iv_size, iv_size);\n+    memcpy(iv, data, iv_size);\n+    memcpy(cipher_text,\
    \ data + iv_size, *cipher_text_length - iv_size);\n+\n     *cipher_text_length\
    \ -= iv_size;\n     *iv_length = iv_size;\n   }\n@@ -279,8 +280,8 @@ psa_status_t\
    \ sl_connect_ecdh_key_exchange_decrypt_message(\n #if SL_GSDK_VERSION >= 0x400\n\
    \ \n   // single part operation is only supported in GSDK 4.0+\n-  memcpy(data,\
    \ cipher_text, cipher_text_length);\n-  memcpy(data + cipher_text_length, iv,\
    \ iv_length);\n+  memcpy(data, iv, iv_length);\n+  memcpy(data + iv_length, cipher_text,\
    \ cipher_text_length);\n \n   psa_status = psa_cipher_decrypt(\n     key_id,"
  - "--- a/app/wisun/component/app_cli/sl_wisun_app_cli.c\n+++ b/app/wisun/component/app_cli/sl_wisun_app_cli.c\n\
    @@ -44,7 +44,7 @@\n #include \"sl_wisun_cli_core.h\"\n #if defined(SL_CATALOG_WISUN_APP_CORE_PRESENT)\n\
    \   #include \"sl_wisun_app_core_util.h\"\n-  #include \"sl_wisun_app_core_util_config.h\"\
    \n+  #include \"sl_wisun_app_core_config.h\"\n #endif\n \n // -----------------------------------------------------------------------------\n\
    @@ -435,7 +435,7 @@ static void _app_connect(const sl_wisun_phy_config_type_t\
    \ config_type);\n \n #if defined(SL_CATALOG_WISUN_APP_CORE_PRESENT)\n /// Wi-SUN\
    \ application regulation\n-static sl_wisun_regulation_t app_regulation = (sl_wisun_regulation_t)WISUN_APP_REGULATION;\n\
    +static sl_wisun_regulation_t app_regulation = (sl_wisun_regulation_t)SL_WISUN_APP_CORE_REGULATION;\n\
    \ #endif\n \n /// Common PHY parameters for CLI setter/getter\n@@ -851,7 +851,7\
    \ @@ const app_cli_entry_t app_settings_entries[] =\n #if defined(SL_CATALOG_APP_PROJECT_INFO_PRESENT)\n\
    \ void app_about(void)\n {\n-  app_wisun_project_info_print(false);\n+  sl_wisun_app_core_util_project_info_print(false);\n\
    \ }\n #endif\n \n@@ -877,7 +877,7 @@ static void _app_connect(const sl_wisun_phy_config_type_t\
    \ config_type)\n     return;\n   }\n   // call connect API\n-  app_wisun_network_connect();\n\
    +  sl_wisun_app_core_network_connect();\n }\n \n /* CLI app connect to FAN 1.0\
    \ handler */\n@@ -1163,10 +1163,9 @@ static sl_status_t _app_cli_get_network_size(char\
    \ *value_str,\n                                              const app_cli_entry_t\
    \ *entry)\n {\n   sl_status_t res = SL_STATUS_FAIL;\n-  (void)key_str;\n-  (void)entry;\n\
    \   const app_enum_t* value_enum;\n   uint8_t value = 0U;\n+  (void)key_str;\n\
    \ \n   res = app_wisun_setting_get_network_size(&value);\n   // finds the proper\
    \ string for the value\n@@ -1430,12 +1429,12 @@ static sl_status_t _app_set_regulation(const\
    \ char *value_str,\n                                        const char *key_str,\n\
    \                                        const app_settings_entry_t *entry)\n\
    \ {\n-  (void)key_str;\n-  (void)entry;\n   sl_status_t res = SL_STATUS_FAIL;\n\
    \   uint32_t value = 0U;\n-  regulation_thresholds_t thresholds;\n+  sl_wisun_app_core_reg_thresholds_t\
    \ thresholds = { 0U };\n   sl_wisun_join_state_t join_state = SL_WISUN_JOIN_STATE_DISCONNECTED;\n\
    +  (void)key_str;\n+  (void)entry;\n \n   if ((value_str == NULL) || (entry ==\
    \ NULL) || (entry->key == NULL)) {\n     return SL_STATUS_FAIL;\n@@ -1464,7 +1463,7\
    \ @@ static sl_status_t _app_set_regulation(const char *value_str,\n \n   if (strstr(entry->key,\
    \ \"regulation\")) {\n     // sets the thresholds\n-    (void)app_wisun_get_regulation_thresholds(&thresholds);\n\
    +    (void)sl_wisun_app_core_get_regulation_thresholds(&thresholds);\n     res\
    \ = sl_wisun_set_regulation_tx_thresholds(thresholds.warning_threshold,\n    \
    \                                             thresholds.alert_threshold);\n \
    \    if (res != SL_STATUS_OK) {\n@@ -1482,10 +1481,10 @@ static sl_status_t _app_set_regulation(const\
    \ char *value_str,\n     }\n \n     // sets status of regulation\n-    if ((sl_wisun_regulation_t)value\
    \ == SL_WISUN_REGULATION_NONE) {\n-      app_wisun_set_regulation_active(false);\n\
    +    if ((sl_wisun_regulation_t)value == SL_WISUN_APP_CORE_REGULATION_NONE) {\n\
    +      sl_wisun_app_core_set_regulation_active(false);\n     } else {\n-     \
    \ app_wisun_set_regulation_active(true);\n+      sl_wisun_app_core_set_regulation_active(true);\n\
    \     }\n   }\n \n@@ -1496,12 +1495,11 @@ static sl_status_t _app_set_regulation_warning_threshold(const\
    \ char *value_str,\n                                                         \
    \ const char *key_str,\n                                                     \
    \     const app_settings_entry_t *entry)\n {\n-  (void)key_str;\n-  (void)entry;\n\
    \   sl_status_t res = SL_STATUS_FAIL;\n   uint32_t value = 0U;\n-  regulation_thresholds_t\
    \ thresholds;\n+  sl_wisun_app_core_reg_thresholds_t thresholds = { 0U };\n  \
    \ sl_wisun_join_state_t join_state = SL_WISUN_JOIN_STATE_DISCONNECTED;\n+  (void)key_str;\n\
    \ \n   if ((value_str == NULL) || (entry == NULL) || (entry->key == NULL)) {\n\
    \     return SL_STATUS_FAIL;\n@@ -1529,13 +1527,13 @@ static sl_status_t _app_set_regulation_warning_threshold(const\
    \ char *value_str,\n   }\n \n   if (strstr(entry->key, \"regulation_warning_threshold\"\
    )) {\n-    (void)app_wisun_get_regulation_thresholds(&thresholds);\n+    (void)sl_wisun_app_core_get_regulation_thresholds(&thresholds);\n\
    \     res = sl_wisun_set_regulation_tx_thresholds((int8_t)value, thresholds.alert_threshold);\n\
    \     if (res != SL_STATUS_OK) {\n       printf(\"[Failed: unable to set regulation\
    \ TX warning threshold: %lu]\\n\", res);\n       return res;\n     } else {\n\
    -      app_wisun_set_regulation_thresholds((int8_t)value, thresholds.alert_threshold);\n\
    +      sl_wisun_app_core_set_regulation_thresholds((int8_t)value, thresholds.alert_threshold);\n\
    \     }\n   }\n \n@@ -1546,12 +1544,12 @@ static sl_status_t _app_set_regulation_alert_threshold(const\
    \ char *value_str,\n                                                        const\
    \ char *key_str,\n                                                        const\
    \ app_settings_entry_t *entry)\n {\n-  (void)key_str;\n-  (void)entry;\n   sl_status_t\
    \ res = SL_STATUS_FAIL;\n   uint32_t value = 0U;\n-  regulation_thresholds_t thresholds;\n\
    +  sl_wisun_app_core_reg_thresholds_t thresholds = { 0U };\n   sl_wisun_join_state_t\
    \ join_state = SL_WISUN_JOIN_STATE_DISCONNECTED;\n+  (void)key_str;\n+  (void)entry;\n\
    \ \n   if ((value_str == NULL) || (entry == NULL) || (entry->key == NULL)) {\n\
    \     return SL_STATUS_FAIL;\n@@ -1579,13 +1577,13 @@ static sl_status_t _app_set_regulation_alert_threshold(const\
    \ char *value_str,\n   }\n \n   if (strstr(entry->key, \"regulation_alert_threshold\"\
    )) {\n-    (void)app_wisun_get_regulation_thresholds(&thresholds);\n+    (void)sl_wisun_app_core_get_regulation_thresholds(&thresholds);\n\
    \     res = sl_wisun_set_regulation_tx_thresholds(thresholds.warning_threshold,\
    \ (int8_t)value);\n     if (res != SL_STATUS_OK) {\n       printf(\"[Failed: unable\
    \ to set regulation TX alert threshold: %lu]\\n\", res);\n       return res;\n\
    \     } else {\n-      app_wisun_set_regulation_thresholds(thresholds.warning_threshold,\
    \ (int8_t)value);\n+      sl_wisun_app_core_set_regulation_thresholds(thresholds.warning_threshold,\
    \ (int8_t)value);\n     }\n   }\n \n@@ -1596,12 +1594,11 @@ static sl_status_t\
    \ _app_get_regulation(char *value_str,\n                                     \
    \   const char *key_str,\n                                        const app_cli_entry_t\
    \ *entry)\n {\n-  sl_status_t res = SL_STATUS_FAIL;\n-  const app_enum_t* value_enum;\n\
    +  const app_enum_t *value_enum = NULL;\n   (void)key_str;\n \n   if ((value_str\
    \ == NULL) || (entry == NULL) || (entry->key == NULL)) {\n-    return res;\n+\
    \    return SL_STATUS_FAIL;\n   }\n \n   if (!strstr(entry->key, \"regulation\"\
    )) {\n@@ -1632,16 +1629,15 @@ static sl_status_t _app_get_regulation_warning_threshold(char\
    \ *value_str,\n                                                          const\
    \ char *key_str,\n                                                          const\
    \ app_cli_entry_t *entry)\n {\n-  sl_status_t res = SL_STATUS_FAIL;\n+  sl_wisun_app_core_reg_thresholds_t\
    \ thresholds = { 0U };\n   (void)key_str;\n-  regulation_thresholds_t thresholds;\n\
    \ \n   if ((value_str == NULL) || (entry == NULL) || (entry->key == NULL)) {\n\
    -    return res;\n+    return SL_STATUS_FAIL;\n   }\n \n   if (strstr(entry->key,\
    \ \"regulation_warning_threshold\")) {\n-    (void)app_wisun_get_regulation_thresholds(&thresholds);\n\
    +    (void)sl_wisun_app_core_get_regulation_thresholds(&thresholds);\n     snprintf(value_str,\
    \ APP_CLI_STR_VALUE_LENGTH, \"%d\",\n              thresholds.warning_threshold);\n\
    \   }\n@@ -1653,16 +1649,15 @@ static sl_status_t _app_get_regulation_alert_threshold(char\
    \ *value_str,\n                                                        const char\
    \ *key_str,\n                                                        const app_cli_entry_t\
    \ *entry)\n {\n-  sl_status_t res = SL_STATUS_FAIL;\n+  sl_wisun_app_core_reg_thresholds_t\
    \ thresholds = { 0U };\n   (void)key_str;\n-  regulation_thresholds_t thresholds;\n\
    \ \n   if ((value_str == NULL) || (entry == NULL) || (entry->key == NULL)) {\n\
    -    return res;\n+    return SL_STATUS_FAIL;\n   }\n \n   if (strstr(entry->key,\
    \ \"regulation_alert_threshold\")) {\n-    (void)app_wisun_get_regulation_thresholds(&thresholds);\n\
    +    (void)sl_wisun_app_core_get_regulation_thresholds(&thresholds);\n     snprintf(value_str,\
    \ APP_CLI_STR_VALUE_LENGTH, \"%d\",\n              thresholds.alert_threshold);\n\
    \   }\n@@ -1678,13 +1673,14 @@ static sl_status_t _app_get_device_type(char *value_str,\n\
    \ {\n   const char *dev_type_str = NULL;\n   sl_wisun_device_type_t dev_type =\
    \ SL_WISUN_ROUTER;\n+  (void) entry;\n   (void) key_str;\n \n-  if (value_str\
    \ == NULL || entry == NULL || entry->key == NULL) {\n+  if (value_str == NULL)\
    \ {\n     return SL_STATUS_FAIL;\n   }\n \n-  dev_type =  app_wisun_get_device_type();\n\
    +  dev_type =  sl_wisun_app_core_get_device_type();\n   dev_type_str = app_wisun_trace_util_device_type_to_str((uint32_t)\
    \ dev_type);\n \n   if (dev_type_str == NULL) {\n@@ -1701,14 +1697,14 @@ static\
    \ sl_status_t _app_get_lfn_profile(char *value_str,\n {\n   const char *lfn_profile_str\
    \ = NULL;\n   sl_wisun_lfn_profile_t lfn_profile = SL_WISUN_LFN_PROFILE_TEST;\n\
    -\n+  (void) entry;\n   (void) key_str;\n \n-  if (value_str == NULL || entry\
    \ == NULL || entry->key == NULL) {\n+  if (value_str == NULL) {\n     return SL_STATUS_FAIL;\n\
    \   }\n \n-  lfn_profile =  app_wisun_get_lfn_profile();\n+  lfn_profile =  sl_wisun_app_core_get_lfn_profile();\n\
    \   lfn_profile_str = app_wisun_trace_util_lfn_profile_to_str((uint32_t) lfn_profile);\n\
    \ \n   if (lfn_profile_str == NULL) {"
  - "--- a/app/wisun/component/app_core/sl_wisun_app_core.c\n+++ b/app/wisun/component/app_core/sl_wisun_app_core.c\n\
    @@ -36,7 +36,7 @@\n #include <string.h>\n #include \"sl_status.h\"\n #include\
    \ \"sl_wisun_app_core.h\"\n-#include \"sl_wisun_app_core_util_config.h\"\n+#include\
    \ \"sl_wisun_app_core_config.h\"\n #include \"cmsis_os2.h\"\n #include \"sl_cmsis_os2_common.h\"\
    \n #include \"sl_status.h\"\n@@ -51,13 +51,20 @@\n   #include \"sl_wisun_app_setting.h\"\
    \n #endif\n \n+#if defined(SL_CATALOG_POWER_MANAGER_PRESENT)\n+  #warning Power\
    \ Manager component is presented. Features/peripherals are constrained.\n+#endif\n\
    +\n // -----------------------------------------------------------------------------\n\
    \ //                              Macros and Typedefs\n // -----------------------------------------------------------------------------\n\
    \ \n /// MDR capability\n #define APP_WISUN_MDR_COMMAND_CAPABILITY           \
    \       0U\n \n+/// Eventflag error mask\n+#define APP_WISUN_EVTFLAG_ERROR_MSK\
    \                       (0x00000001UL << 31UL)\n+\n ///  Release mutex and return\n\
    \ #define _return_and_mtx_release() \\\n   do {                            \\\n\
    @@ -103,7 +110,7 @@ static sl_status_t _app_wisun_application_setting(const app_setting_wisun_t\
    \ * co\n  *****************************************************************************/\n\
    \ sl_status_t _app_wisun_security_setting(void);\n \n-#if (WISUN_APP_REGULATION\
    \ != REGULATION_NONE)\n+#if (SL_WISUN_APP_CORE_REGULATION != SL_WISUN_APP_CORE_REGULATION_NONE)\n\
    \ /**************************************************************************//**\n\
    \  * @brief Regulation setting\n  * @details It setup Wi-SUN with regulation related\
    \ parameters.\n@@ -136,11 +143,18 @@ static void _store_address(const char *addr_name,\n\
    \                            in6_addr_t *addr);\n \n /**************************************************************************//**\n\
    - * @brief Setting error flag\n- * @details It sets the error by a flag\n+ * @brief\
    \ Setting state flag\n+ * @details It sets the state by a flag\n+ * @param[in]\
    \ flag is a flag bit\n+ *****************************************************************************/\n\
    +__STATIC_INLINE void _app_wisun_core_set_state(const sl_wisun_app_core_state_t\
    \ flag);\n+\n+/**************************************************************************//**\n\
    + * @brief Clear state flag\n+ * @details It clears the state by a flag\n  * @param[in]\
    \ flag is a flag bit\n  *****************************************************************************/\n\
    -__STATIC_INLINE void _app_wisun_core_set_error(app_core_error_state_flag_t flag);\n\
    +__STATIC_INLINE void _app_wisun_core_clear_state(const sl_wisun_app_core_state_t\
    \ flag);\n \n /**************************************************************************//**\n\
    \  * @brief Storing the current address\n@@ -213,27 +227,35 @@ static const app_setting_wisun_t\
    \ _app_default_settings = {\n /// Here we track if regional regulation is active\
    \ or not\n static bool _regional_regulation_active = false;\n \n-static regulation_thresholds_t\
    \ _tresholds = {\n-  .warning_threshold = WISUN_DEFAULT_REGULATION_WARNING_THRESHOLD,\n\
    -  .alert_threshold = WISUN_DEFAULT_REGULATION_ALERT_THRESHOLD,\n+static sl_wisun_app_core_reg_thresholds_t\
    \ _tresholds = {\n+  .warning_threshold = SL_WISUN_APP_CORE_DEFAULT_REGULATION_WARNING_THRESHOLD,\n\
    +  .alert_threshold = SL_WISUN_APP_CORE_DEFAULT_REGULATION_ALERT_THRESHOLD,\n\
    \ };\n \n /// App framework mutex\n-static osMutexId_t _app_wisun_network_mtx\
    \ = NULL;\n+static osMutexId_t _app_core_mtx = NULL;\n \n ///  App framework mutex\
    \ attribute\n-static const osMutexAttr_t _app_wisun_network_mtx_attr = {\n-  .name\
    \      = \"AppWisunNetworkMutex\",\n+static const osMutexAttr_t _app_wisun_mtx_attr\
    \ = {\n+  .name      = \"AppWisunkMutex\",\n   .attr_bits = osMutexRecursive,\n\
    \   .cb_mem    = NULL,\n   .cb_size   = 0\n };\n \n /// Current address storage\n\
    -static current_addr_t _current_addr = { 0U };\n+static sl_wisun_app_core_current_addr_t\
    \ _current_addr = { 0U };\n \n /// error flag for errors\n-static app_core_error_state_flag_t\
    \ _error_flag = CONNECTION_FAILED_ERROR_FLAG_BIT;\n+static osEventFlagsId_t _app_core_state\
    \ = NULL;\n+\n+/// Sate event flags attributes\n+static const osEventFlagsAttr_t\
    \ _app_wisun_evt_attr = {\n+  .name      = \"AppWisunEvtFlags\",\n+  .attr_bits\
    \ = 0,\n+  .cb_mem    = NULL,\n+  .cb_size   = 0\n+};\n \n /// Internal join state\n\
    \ static sl_wisun_join_state_t _join_state = SL_WISUN_JOIN_STATE_DISCONNECTED;\n\
    @@ -242,7 +264,7 @@ static sl_wisun_join_state_t _join_state = SL_WISUN_JOIN_STATE_DISCONNECTED;\n\
    \ static app_setting_wisun_t _setting = { 0U };\n \n /// Time statistic storage\n\
    -static app_core_time_stat_t _time_stat = { 0U };\n+static sl_wisun_app_core_time_stat_t\
    \ _time_stat = { 0U };\n \n // -----------------------------------------------------------------------------\n\
    \ //                          Public Function Definitions\n@@ -294,6 +316,8 @@\
    \ void sl_wisun_connected_event_hnd(sl_wisun_evt_t *evt)\n \n   if (evt->evt.connected.status\
    \ != SL_STATUS_OK) {\n     printf(\"[Connection failed. Status: %lu]\\n\", evt->evt.connected.status);\n\
    +    _app_wisun_core_set_state(SL_WISUN_APP_CORE_STATE_NETWORK_DISCONNECTED);\n\
    +    _app_wisun_core_clear_state(SL_WISUN_APP_CORE_STATE_NETWORK_CONNECTED);\n\
    \     return;\n   }\n   // store the current addresses\n@@ -309,7 +333,8 @@ void\
    \ sl_wisun_connected_event_hnd(sl_wisun_evt_t *evt)\n   time_ms = time_ms - _time_stat.disconnected_ms;\n\
    \ \n   printf(\"[%lu s]\\n\", (uint32_t)time_ms / 1000U);\n-\n+  _app_wisun_core_set_state(SL_WISUN_APP_CORE_STATE_NETWORK_CONNECTED);\n\
    +  _app_wisun_core_clear_state(SL_WISUN_APP_CORE_STATE_NETWORK_DISCONNECTED);\n\
    \   __CHECK_FOR_STATUS(evt->evt.error.status);\n }\n \n@@ -327,6 +352,7 @@ void\
    \ sl_wisun_disconnected_event_hnd(sl_wisun_evt_t *evt)\n   _time_stat.disconnected_ms\
    \ = time_ms;\n \n   __CHECK_FOR_STATUS(evt->evt.error.status);\n+  _app_wisun_core_set_state(SL_WISUN_APP_CORE_STATE_NETWORK_DISCONNECTED);\n\
    \ }\n \n /* Socket connection lost event handler*/\n@@ -340,6 +366,9 @@ void sl_wisun_connection_lost_event_hnd(sl_wisun_evt_t\
    \ *evt)\n   if (stat == SL_STATUS_OK) {\n     printf(\"[Connection lost, connecting\
    \ to \\\"%s\\\"]\\n\", _setting.network_name);\n   }\n+  _app_wisun_core_set_state(SL_WISUN_APP_CORE_STATE_NETWORK_CONNECTION_LOST);\n\
    +  _app_wisun_core_set_state(SL_WISUN_APP_CORE_STATE_NETWORK_DISCONNECTED);\n\
    +  _app_wisun_core_clear_state(SL_WISUN_APP_CORE_STATE_NETWORK_CONNECTED);\n \
    \  __CHECK_FOR_STATUS(evt->evt.error.status);\n }\n \n@@ -372,22 +401,43 @@ void\
    \ sl_wisun_lfn_wake_up_hnd(sl_wisun_evt_t *evt)\n   __CHECK_FOR_STATUS(evt->evt.error.status);\n\
    \ }\n \n+void sl_wisun_multicast_reg_finish_hnd(sl_wisun_evt_t *evt)\n+{\n+  __CHECK_FOR_STATUS(evt->evt.error.status);\n\
    +}\n+\n /* Wisun app core init */\n-void app_wisun_core_init(void)\n+void sl_wisun_app_core_init(void)\n\
    \ {\n   // init wisun network mutex\n-  _app_wisun_network_mtx = osMutexNew(&_app_wisun_network_mtx_attr);\n\
    -  assert(_app_wisun_network_mtx != NULL);\n+  _app_core_mtx = osMutexNew(&_app_wisun_mtx_attr);\n\
    +  assert(_app_core_mtx != NULL);\n+\n+  _app_core_state = osEventFlagsNew(&_app_wisun_evt_attr);\n\
    +  assert(_app_core_state != NULL);\n }\n \n /* App core get error */\n-bool app_wisun_core_get_error(app_core_error_state_flag_t\
    \ flag)\n+sl_status_t sl_wisun_app_core_get_state(uint32_t * const state)\n+{\n\
    +  *state = osEventFlagsGet(_app_core_state);\n+  // Check error flag\n+  if (*state\
    \ & APP_WISUN_EVTFLAG_ERROR_MSK) {\n+    return SL_STATUS_FAIL;\n+  }\n+  return\
    \ SL_STATUS_OK;\n+}\n+\n+\n+sl_status_t sl_wisun_app_core_wait_state(const uint32_t\
    \ state, const uint32_t timeout)\n {\n-  return (bool)(_error_flag & (1 << flag));\n\
    +  uint32_t ret = 0UL;\n+  ret = osEventFlagsWait(_app_core_state, state, osFlagsWaitAll\
    \ | osFlagsNoClear, timeout);\n+  return (ret & APP_WISUN_EVTFLAG_ERROR_MSK) ?\
    \ SL_STATUS_FAIL : SL_STATUS_OK;\n }\n \n /*Connecting to the wisun network*/\n\
    -void app_wisun_network_connect(void)\n+void sl_wisun_app_core_network_connect(void)\n\
    \ {\n   sl_status_t ret = SL_STATUS_FAIL;\n   sl_wisun_join_state_t join_state\
    \ = SL_WISUN_JOIN_STATE_DISCONNECTED;\n@@ -403,7 +453,7 @@ void app_wisun_network_connect(void)\n\
    \   ret = app_wisun_setting_get(&_setting);\n   if (ret != SL_STATUS_OK) {\n \
    \    printf(\"[Failed: unable to get settings\\n\");\n-    _app_wisun_core_set_error(SETTING_ERROR_FLAG_BIT);\n\
    +    _app_wisun_core_set_state(SL_WISUN_APP_CORE_STATE_SETTING_ERROR);\n     _return_and_mtx_release();\n\
    \   }\n #else\n@@ -430,7 +480,7 @@ void app_wisun_network_connect(void)\n    \
    \ _return_and_mtx_release();\n   }\n \n-#if (WISUN_APP_REGULATION != REGULATION_NONE)\n\
    +#if (SL_WISUN_APP_CORE_REGULATION != SL_WISUN_APP_CORE_REGULATION_NONE)\n   ret\
    \ = _app_wisun_regulation_setting();\n   if (ret != SL_STATUS_OK) {\n     _return_and_mtx_release();\n\
    @@ -448,7 +498,7 @@ void app_wisun_network_connect(void)\n \n     printf(\"\\\
    n[Connecting to \\\"%s\\\"]\\n\", _setting.network_name);\n   } else {\n-    _app_wisun_core_set_error(CONNECTION_FAILED_ERROR_FLAG_BIT);\n\
    +    _app_wisun_core_set_state(SL_WISUN_APP_CORE_STATE_CONNECTION_ERROR);\n  \
    \   printf(\"\\n[Connection failed: %lu]\\n\", ret);\n   }\n   _app_wisun_mutex_release();\n\
    @@ -459,7 +509,7 @@ void sl_wisun_regulation_tx_level_hnd(sl_wisun_evt_t *evt)\n\
    \   (void)*evt;\n }\n \n-void app_wisun_get_current_addresses(current_addr_t *\
    \ const dest_addresses)\n+void sl_wisun_app_core_get_current_addresses(sl_wisun_app_core_current_addr_t\
    \ * const dest_addresses)\n {\n   _app_wisun_mutex_acquire();\n   memcpy(&dest_addresses->global,\
    \ &_current_addr.global, sizeof(in6_addr_t));\n@@ -470,14 +520,14 @@ void app_wisun_get_current_addresses(current_addr_t\
    \ * const dest_addresses)\n   _app_wisun_mutex_release();\n }\n \n-void app_wisun_set_regulation_active(bool\
    \ enabled)\n+void sl_wisun_app_core_set_regulation_active(bool enabled)\n {\n\
    \   _app_wisun_mutex_acquire();\n   _regional_regulation_active = enabled;\n \
    \  _app_wisun_mutex_release();\n }\n \n-bool app_wisun_get_regulation_active(void)\n\
    +bool sl_wisun_app_core_get_regulation_active(void)\n {\n   bool retval;\n   _app_wisun_mutex_acquire();\n\
    @@ -486,49 +536,52 @@ bool app_wisun_get_regulation_active(void)\n   return retval;\n\
    \ }\n \n-void app_wisun_set_regulation_thresholds(const int8_t warning_level,\
    \ const  int8_t alert_level)\n+void sl_wisun_app_core_set_regulation_thresholds(const\
    \ int8_t warning_level, const  int8_t alert_level)\n {\n   _app_wisun_mutex_acquire();\n\
    \   _tresholds.warning_threshold = warning_level;\n   _tresholds.alert_threshold\
    \ = alert_level;\n   _app_wisun_mutex_release();\n }\n \n-bool app_wisun_get_regulation_thresholds(regulation_thresholds_t*\
    \ thresholds_out)\n+sl_status_t sl_wisun_app_core_get_regulation_thresholds(sl_wisun_app_core_reg_thresholds_t*\
    \ thresholds_out)\n {\n   if (thresholds_out == NULL) {\n-    return false;\n\
    +    return SL_STATUS_FAIL;\n   }\n \n   _app_wisun_mutex_acquire();\n   thresholds_out->warning_threshold\
    \ = _tresholds.warning_threshold;\n   thresholds_out->alert_threshold = _tresholds.alert_threshold;\n\
    \   _app_wisun_mutex_release();\n-  return true;\n+  return SL_STATUS_OK;\n }\n\
    \ \n-bool app_wisun_get_remaining_tx_budget(uint32_t* const budget_out)\n+sl_status_t\
    \ sl_wisun_app_core_get_remaining_tx_budget(uint32_t* const budget_out)\n {\n\
    \   sl_wisun_statistics_t stat;\n+  sl_status_t ret = SL_STATUS_FAIL;\n+\n   if\
    \ (!_regional_regulation_active || budget_out == NULL) {\n-    return false;\n\
    +    return ret;\n   }\n \n   _app_wisun_mutex_acquire();\n \n   if (sl_wisun_get_statistics(SL_WISUN_STATISTICS_TYPE_REGULATION,\
    \ &stat) == SL_STATUS_OK) {\n     // return a meaningful value (budget remaning)\
    \ or zero (exceeded)\n-    *budget_out = (stat.regulation.arib.tx_duration_ms\
    \ < WISUN_APP_TX_BUDGET)\n-                  ? (WISUN_APP_TX_BUDGET - stat.regulation.arib.tx_duration_ms)\
    \ : 0UL;\n+    *budget_out = (stat.regulation.arib.tx_duration_ms < SL_WISUN_APP_CORE_TX_BUDGET)\n\
    +                  ? (SL_WISUN_APP_CORE_TX_BUDGET - stat.regulation.arib.tx_duration_ms)\
    \ : 0UL;\n+    ret = SL_STATUS_OK;\n   } else {\n-    return false;\n+    ret\
    \ = SL_STATUS_FAIL;\n   }\n   _app_wisun_mutex_release();\n \n-  return true;\n\
    +  return ret;\n }\n \n-sl_wisun_join_state_t app_wisun_get_join_state(void)\n\
    +sl_wisun_join_state_t sl_wisun_app_core_get_join_state(void)\n {\n   sl_wisun_join_state_t\
    \ join_state = SL_WISUN_JOIN_STATE_DISCONNECTED;\n   _app_wisun_mutex_acquire();\n\
    @@ -537,7 +590,7 @@ sl_wisun_join_state_t app_wisun_get_join_state(void)\n   return\
    \ join_state;\n }\n \n-void app_wisun_get_time_stat(app_core_time_stat_t * const\
    \ tstat)\n+void sl_wisun_app_core_get_time_stat(sl_wisun_app_core_time_stat_t\
    \ * const tstat)\n {\n   uint64_t time_ms = 0ULL;\n \n@@ -546,7 +599,7 @@ void\
    \ app_wisun_get_time_stat(app_core_time_stat_t * const tstat)\n   // update current\
    \ time\n   sl_sleeptimer_tick64_to_ms(sl_sleeptimer_get_tick_count64(), &time_ms);\n\
    \ \n-  memcpy(tstat, &_time_stat, sizeof(app_core_time_stat_t));\n+  memcpy(tstat,\
    \ &_time_stat, sizeof(sl_wisun_app_core_time_stat_t));\n \n   // add diff beetween\
    \ current time and last update time to the actual state\n   tstat->curr_ms = time_ms;\n\
    @@ -561,17 +614,17 @@ void app_wisun_get_time_stat(app_core_time_stat_t * const\
    \ tstat)\n }\n #if defined(SL_CATALOG_WISUN_LFN_DEVICE_SUPPORT_PRESENT)\n \n-sl_wisun_device_type_t\
    \ app_wisun_get_device_type(void)\n+sl_wisun_device_type_t sl_wisun_app_core_get_device_type(void)\n\
    \ {\n   return (sl_wisun_device_type_t)_setting.device_type;\n }\n \n-sl_wisun_lfn_profile_t\
    \ app_wisun_get_lfn_profile(void)\n+sl_wisun_lfn_profile_t sl_wisun_app_core_get_lfn_profile(void)\n\
    \ {\n   return (sl_wisun_lfn_profile_t)_setting.lfn_profile;\n }\n \n-const sl_wisun_lfn_params_t\
    \ *app_wisun_get_lfn_params(void)\n+const sl_wisun_lfn_params_t *sl_wisun_app_core_get_lfn_params(void)\n\
    \ {\n   // Not lfn device\n   if (_setting.device_type != SL_WISUN_LFN) {\n@@\
    \ -613,7 +666,7 @@ static sl_status_t _app_wisun_application_setting(const app_setting_wisun_t\
    \ * co\n #if defined(SL_CATALOG_WISUN_LFN_DEVICE_SUPPORT_PRESENT)\n   if (setting->device_type\
    \ == SL_WISUN_LFN) {\n     // Store LFN profile based on wisun config\n-    ret\
    \ = sl_wisun_set_lfn_parameters(app_wisun_get_lfn_params());\n+    ret = sl_wisun_set_lfn_parameters(sl_wisun_app_core_get_lfn_params());\n\
    \     if (ret != SL_STATUS_OK) {\n       printf(\"[Failed: unable to set device\
    \ type: %lu]\\n\", ret);\n       return ret;\n@@ -631,15 +684,15 @@ static sl_status_t\
    \ _app_wisun_application_setting(const app_setting_wisun_t * co\n   ret = sl_wisun_set_connection_parameters(conn_param);\n\
    \   if (ret != SL_STATUS_OK) {\n     printf(\"[Failed: unable to set network size:\
    \ %lu]\\n\", ret);\n-    _app_wisun_core_set_error(SET_NETWORK_SIZE_ERROR_FLAG_BIT);\n\
    +    _app_wisun_core_set_state(SL_WISUN_APP_CORE_STATE_SET_NETWORK_SIZE_ERROR);\n\
    \     return ret;\n   }\n \n   // sets the TX power\n   ret = sl_wisun_set_tx_power(setting->tx_power);\n\
    \   if (ret != SL_STATUS_OK) {\n     printf(\"[Failed: unable to set TX power:\
    \ %lu]\\n\", ret);\n-    _app_wisun_core_set_error(SET_TX_POWER_ERROR_FLAG_BIT);\n\
    +    _app_wisun_core_set_state(SL_WISUN_APP_CORE_STATE_SET_TX_POWER_ERROR);\n\
    \     return ret;\n   }\n #if defined(WISUN_CONFIG_ALLOWED_CHANNELS)\n@@ -665,7\
    \ +718,7 @@ static sl_status_t _app_wisun_application_setting(const app_setting_wisun_t\
    \ * co\n \n   if (ret != SL_STATUS_OK) {\n     printf(\"[Failed: unable to set\
    \ dwell interval: %lu]\\n\", ret);\n-    _app_wisun_core_set_error(SET_DWELL_INTERVAL_ERROR_FLAG_BIT);\n\
    +    _app_wisun_core_set_state(SL_WISUN_APP_CORE_STATE_SET_DWELL_INTERVAL_ERROR);\n\
    \     return ret;\n   }\n #endif\n@@ -675,7 +728,7 @@ static sl_status_t _app_wisun_application_setting(const\
    \ app_setting_wisun_t * co\n   ret = sl_wisun_set_mac_address(&wisun_config_mac_address);\n\
    \   if (ret != SL_STATUS_OK) {\n     printf(\"[Failed: unable to set MAC address:\
    \ %lu]\\n\", ret);\n-    _app_wisun_core_set_error(SET_MAC_ADDR_ERROR_FLAG_BIT);\n\
    +    _app_wisun_core_set_state(SL_WISUN_APP_CORE_STATE_SET_MAC_ADDR_ERROR);\n\
    \     return ret;\n   }\n #endif\n@@ -686,7 +739,7 @@ static sl_status_t _app_wisun_application_setting(const\
    \ app_setting_wisun_t * co\n     ret = sl_wisun_allow_mac_address(&wisun_config_mac_allow_list.mac_list[index]);\n\
    \     if (ret != SL_STATUS_OK) {\n       printf(\"[Failed: unable to set allow\
    \ address: %lu]\\n\", ret);\n-      _app_wisun_core_set_error(SET_ALLOW_MAC_ADDR_ERROR_FLAG_BIT);\n\
    +      _app_wisun_core_set_state(SL_WISUN_APP_CORE_STATE_SET_ALLOW_MAC_ADDR_ERROR);\n\
    \       return ret;\n     }\n   }\n@@ -697,7 +750,7 @@ static sl_status_t _app_wisun_application_setting(const\
    \ app_setting_wisun_t * co\n     ret = sl_wisun_deny_mac_address(&wisun_config_mac_deny_list.mac_list[index]);\n\
    \     if (ret != SL_STATUS_OK) {\n       printf(\"[Failed: unable to set allow\
    \ address: %lu]\\n\", ret);\n-      _app_wisun_core_set_error(SET_DENY_MAC_ADDR_ERROR_FLAG_BIT);\n\
    +      _app_wisun_core_set_state(SL_WISUN_APP_CORE_SET_DENY_MAC_ADDR_ERROR);\n\
    \       return ret;\n     }\n   }\n@@ -717,7 +770,7 @@ sl_status_t _app_wisun_security_setting(void)\n\
    \                                          wisun_config_ca_certificate);\n   if\
    \ (ret != SL_STATUS_OK) {\n     printf(\"[Failed: unable to set the trusted certificate:\
    \ %lu]\\n\", ret);\n-    _app_wisun_core_set_error(SET_TRUSTED_CERTIFICATE_ERROR_FLAG_BIT);\n\
    +    _app_wisun_core_set_state(SL_WISUN_APP_CORE_STATE_SET_TRUSTED_CERTIFICATE_ERROR);\n\
    \     return ret;\n   }\n \n@@ -727,7 +780,7 @@ sl_status_t _app_wisun_security_setting(void)\n\
    \                                         wisun_config_device_certificate);\n\
    \   if (ret != SL_STATUS_OK) {\n     printf(\"[Failed: unable to set the device\
    \ certificate: %lu]\\n\", ret);\n-    _app_wisun_core_set_error(SET_DEVICE_CERTIFICATE_ERROR_FLAG_BIT);\n\
    +    _app_wisun_core_set_state(SL_WISUN_APP_CORE_STATE_SET_DEVICE_CERTIFICATE_ERROR);\n\
    \     return ret;\n   }\n \n@@ -739,32 +792,32 @@ sl_status_t _app_wisun_security_setting(void)\n\
    \                                         wisun_config_device_private_key);\n\
    \   if (ret != SL_STATUS_OK) {\n     printf(\"[Failed: unable to set the device\
    \ private key: %lu]\\n\", ret);\n-    _app_wisun_core_set_error(SET_DEVICE_PRIVATE_KEY_ERROR_FLAG_BIT);\n\
    +    _app_wisun_core_set_state(SL_WISUN_APP_CORE_STATE_SET_DEVICE_PRIVATE_KEY_ERROR);\n\
    \     return ret;\n   }\n \n   return ret;\n }\n \n-#if (WISUN_APP_REGULATION\
    \ != REGULATION_NONE)\n+#if (SL_WISUN_APP_CORE_REGULATION != SL_WISUN_APP_CORE_REGULATION_NONE)\n\
    \ __STATIC_INLINE sl_status_t _app_wisun_regulation_setting(void)\n {\n   sl_status_t\
    \ ret = SL_STATUS_FAIL;\n \n   // regulation thresholds\n-  regulation_thresholds_t\
    \ thresholds;\n+  sl_wisun_app_core_reg_thresholds_t thresholds;\n   // name of\
    \ the regulation type to print upon connection\n   char* regulation_name;\n \n\
    -  (void)app_wisun_get_regulation_thresholds(&thresholds);\n+  (void)sl_wisun_app_core_get_regulation_thresholds(&thresholds);\n\
    \   ret = sl_wisun_set_regulation_tx_thresholds(thresholds.warning_threshold,\n\
    \                                               thresholds.alert_threshold);\n\
    \   if (ret == SL_STATUS_OK) {\n-    ret = sl_wisun_set_regulation(WISUN_APP_REGULATION);\n\
    +    ret = sl_wisun_set_regulation(SL_WISUN_APP_CORE_REGULATION);\n     if (ret\
    \ != SL_STATUS_OK) {\n       printf(\"[Failed: unable to set regulation: %lu]\\\
    n\", ret);\n     } else {\n-      switch (WISUN_APP_REGULATION) {\n+      switch\
    \ (SL_WISUN_APP_CORE_REGULATION) {\n         case SL_WISUN_REGULATION_ARIB: regulation_name\
    \ = \"ARIB\"; break;\n         default:\n           regulation_name = \"UNKNOWN\"\
    ;\n@@ -783,13 +836,13 @@ __STATIC_INLINE sl_status_t _app_wisun_regulation_setting(void)\n\
    \ /* Mutex acquire */\n __STATIC_INLINE void _app_wisun_mutex_acquire(void)\n\
    \ {\n-  assert(osMutexAcquire(_app_wisun_network_mtx, osWaitForever) == osOK);\n\
    +  assert(osMutexAcquire(_app_core_mtx, osWaitForever) == osOK);\n }\n \n /* Mutex\
    \ release */\n __STATIC_INLINE void _app_wisun_mutex_release(void)\n {\n-  assert(osMutexRelease(_app_wisun_network_mtx)\
    \ == osOK);\n+  assert(osMutexRelease(_app_core_mtx) == osOK);\n }\n \n /* Storing\
    \ address */\n@@ -822,15 +875,20 @@ static void _store_address(const char *addr_name,\n\
    \ }\n \n /* Setting error */\n-__STATIC_INLINE void _app_wisun_core_set_error(app_core_error_state_flag_t\
    \ flag)\n+__STATIC_INLINE void _app_wisun_core_set_state(const sl_wisun_app_core_state_t\
    \ flag)\n+{\n+  (void) osEventFlagsSet(_app_core_state, 1UL << flag);\n+}\n+\n\
    +__STATIC_INLINE void _app_wisun_core_clear_state(const sl_wisun_app_core_state_t\
    \ flag)\n {\n-  _error_flag |= (1 << flag);\n+  (void) osEventFlagsClear(_app_core_state,\
    \ 1UL << flag);\n }\n \n /* Storing current addresses */\n static void _store_current_addresses(void)\n\
    \ {\n-  memset(&_current_addr, 0, sizeof(current_addr_t));\n+  memset(&_current_addr,\
    \ 0, sizeof(sl_wisun_app_core_current_addr_t));\n   printf(\"\\nAddresses:\\n\"\
    );\n   _store_address(\"GLOBAL\", SL_WISUN_IP_ADDRESS_TYPE_GLOBAL, &_current_addr.global);\n\
    \   _store_address(\"LINK_LOCAL\", SL_WISUN_IP_ADDRESS_TYPE_LINK_LOCAL, &_current_addr.link_local);"
  - "--- a/app/wisun/component/app_core/sl_wisun_app_core_util.c\n+++ b/app/wisun/component/app_core/sl_wisun_app_core_util.c\n\
    @@ -35,7 +35,8 @@\n #include <string.h>\n #include \"sl_wisun_api.h\"\n #include\
    \ \"sl_wisun_app_core_util.h\"\n-#include \"sl_wisun_app_core_util_config.h\"\n\
    +#include \"sl_wisun_app_core_config.h\"\n+#include \"sl_wisun_app_core.h\"\n\
    \ #include \"app_project_info.h\"\n #include \"sl_wisun_config.h\"\n // -----------------------------------------------------------------------------\n\
    @@ -62,7 +63,7 @@ static app_project_info_t _app_project_info = { 0 };\n // -----------------------------------------------------------------------------\n\
    \ \n /* Init project info */\n-void app_wisun_project_info_init(const char * app_name)\n\
    +void sl_wisun_app_core_util_project_info_init(const char * app_name)\n {\n  \
    \ const app_project_info_version_t *stack_ver = NULL;\n   app_project_info_get(&_app_project_info);\n\
    @@ -77,7 +78,7 @@ void app_wisun_project_info_init(const char * app_name)\n }\n\
    \ \n /* Print project info */\n-void app_wisun_project_info_print(const bool json_format)\n\
    +void sl_wisun_app_core_util_project_info_print(const bool json_format)\n {\n\
    \   if (json_format) {\n     app_project_info_print_json(&_app_project_info, printf);\n\
    @@ -87,39 +88,25 @@ void app_wisun_project_info_print(const bool json_format)\n\
    \ }\n \n /* Connect and wait */\n-void app_wisun_connect_and_wait(void)\n+void\
    \ sl_wisun_app_core_util_connect_and_wait(void)\n {\n-  app_wisun_network_connect();\n\
    -  app_wisun_wait_for_connection();\n+  sl_wisun_app_core_network_connect();\n\
    +  sl_wisun_app_core_util_wait_for_connection();\n }\n \n /* Waiting for connection\
    \ */\n-void app_wisun_wait_for_connection(void)\n+void sl_wisun_app_core_util_wait_for_connection(void)\n\
    \ {\n-#if (HEARTBEAT_ENABLED == 1)\n-  uint8_t dot_line_cnt = 0;\n-#endif\n- \
    \ osDelay(10);\n-  printf(\"\\n\");\n-  while (1) {\n-    if (app_wisun_network_is_connected())\
    \ {\n-      break;\n-    }\n-#if (HEARTBEAT_ENABLED == 1)\n-    printf((dot_line_cnt\
    \ == HEARBEAT_SECTION_LENGTH ? \"[%ds]\\n\" : \"#\"), dot_line_cnt);\n-    dot_line_cnt\
    \ = dot_line_cnt == HEARBEAT_SECTION_LENGTH ? 0 : dot_line_cnt + 1;\n-#endif\n\
    -    osDelay(1000); // 1s\n-  }\n+  (void) sl_wisun_app_core_wait_state((1 <<\
    \ SL_WISUN_APP_CORE_STATE_NETWORK_CONNECTED), osWaitForever);\n }\n \n-bool app_wisun_network_is_connected(void)\n\
    +bool sl_wisun_app_core_util_network_is_connected(void)\n {\n-  sl_wisun_join_state_t\
    \ join_state = app_wisun_get_join_state();\n+  sl_wisun_join_state_t join_state\
    \ = sl_wisun_app_core_get_join_state();\n   return join_state == SL_WISUN_JOIN_STATE_OPERATIONAL\
    \ ? true : false;\n }\n \n-void app_wisun_dispatch_thread(void)\n+void sl_wisun_app_core_util_dispatch_thread(void)\n\
    \ {\n #if !defined(WISUN_CONFIG_DEVICE_TYPE)\n   uint8_t device_type = SL_WISUN_ROUTER;\n\
    @@ -128,13 +115,13 @@ void app_wisun_dispatch_thread(void)\n #endif\n \n   if\
    \ (device_type == SL_WISUN_LFN) {\n-    osDelay(APP_THREAD_LP_DISPATCH_MS);\n\
    +    osDelay(SL_WISUN_APP_CORE_THREAD_LP_DISPATCH_MS);\n   } else {\n     osDelay(1UL);\n\
    \   }\n }\n \n-const app_project_info_t * app_wisun_project_info_get(void)\n+const\
    \ app_project_info_t * sl_wisun_app_core_util_project_info_get(void)\n {\n   return\
    \ (const app_project_info_t * ) &_app_project_info;\n }"
  - "--- a/app/wisun/component/app_setting/sl_wisun_app_setting.c\n+++ b/app/wisun/component/app_setting/sl_wisun_app_setting.c\n\
    @@ -434,7 +434,7 @@ sl_status_t app_wisun_setting_subscribe_notification(const\
    \ app_setting_notificat\n   app_setting_notif_dsc_t *notif = NULL;\n   uint32_t\
    \ mask = 0UL;\n   notif = _get_notification_entry(type);\n-  if (notif == NULL)\
    \ {\n+  if (notif == NULL || channel == NULL) {\n     return stat;\n   }\n "
  - "--- a/app/wisun/component/app_status/sl_wisun_app_status.c\n+++ b/app/wisun/component/app_status/sl_wisun_app_status.c\n\
    @@ -162,6 +162,24 @@ static void _build_time_stat(uint8_t **buf, uint16_t *buf_len);\n\
    \  *****************************************************************************/\n\
    \ static uint16_t _build_payload(void);\n \n+/**************************************************************************//**\n\
    + * @brief Acquire application mutex\n+ * @details Internal mutex lock\n+ *****************************************************************************/\n\
    +__STATIC_INLINE void _app_wisun_mutex_acquire(void);\n+\n+/**************************************************************************//**\n\
    + * @brief Release application mutex\n+ * @details Internal mutex release\n+ *****************************************************************************/\n\
    +__STATIC_INLINE void _app_wisun_mutex_release(void);\n+\n+/**************************************************************************//**\n\
    + * @brief Updates the notify settings for CoAP app status notification\n+ * @details\
    \ Removes and add the new notification settings\n+ *****************************************************************************/\n\
    +__STATIC_INLINE sl_status_t _update_notify_settings(void);\n+\n // -----------------------------------------------------------------------------\n\
    \ //                                Global Variables\n // -----------------------------------------------------------------------------\n\
    @@ -176,11 +194,26 @@ static sl_wisun_coap_notify_t _notify = { 0U };\n /// Notification\
    \ payload buffer\n static uint8_t _notif_buff[SL_WISUN_APP_STATUS_NOTIF_PAYLOAD_SIZE]\
    \ = { 0U };\n \n+///  App status mutex\n+static osMutexId_t _app_wisun_app_status_mtx\
    \ = NULL;\n+\n+///  App status mutex attribute\n+static const osMutexAttr_t _app_wisun_app_status_mtx_attr\
    \ = {\n+  .name      = \"AppWisunAppStatusMutex\",\n+  .attr_bits = osMutexRecursive,\n\
    +  .cb_mem    = NULL,\n+  .cb_size   = 0\n+};\n+\n // -----------------------------------------------------------------------------\n\
    \ //                          Public Function Definitions\n // -----------------------------------------------------------------------------\n\
    \ void sl_wisun_app_status_init(void)\n {\n+  // init wisun network mutex\n+ \
    \ _app_wisun_app_status_mtx = osMutexNew(&_app_wisun_app_status_mtx_attr);\n+\
    \  assert(_app_wisun_app_status_mtx != NULL);\n+\n   _notify.id = SL_WISUN_APP_STATUS_DEFAULT_NOTIFCATION_ID;\n\
    \   (void) inet_pton(AF_INET6,\n                    SL_WISUN_APP_STATUS_DEFAULT_REMOTE_ADDR,\n\
    @@ -192,7 +225,7 @@ void sl_wisun_app_status_init(void)\n   _notify.condition_cb\
    \ = sl_wisun_app_status_condition_cb;\n   _notify.hnd_cb = _notify_hnd;\n \n-\
    \  sl_wisun_coap_notify_add(&_notify);\n+  _update_notify_settings();\n }\n \n\
    \ SL_WEAK bool sl_wisun_app_status_condition_cb(const sl_wisun_coap_notify_t *\
    \ notify)\n@@ -201,10 +234,47 @@ SL_WEAK bool sl_wisun_app_status_condition_cb(const\
    \ sl_wisun_coap_notify_t * not\n   return true;\n }\n \n+sockaddr_in6_t* sl_wisun_app_status_get_remote_address(void)\n\
    +{\n+  return &(_notify.remote_addr);\n+}\n+\n+uint32_t sl_wisun_app_status_get_schedule_time_ms(void)\n\
    +{\n+  return _notify.schedule_time_ms;\n+}\n+\n+sl_status_t sl_wisun_app_status_set_remote_address(const\
    \ char *remote_address, const uint16_t port)\n+{\n+  sl_status_t result = SL_STATUS_OK;\n\
    +  int32_t ip_result = 0;\n+  _app_wisun_mutex_acquire();\n+\n+  if (remote_address\
    \ == NULL) {\n+    result =  SL_STATUS_NULL_POINTER;\n+  } else {\n+    ip_result\
    \ = inet_pton(AF_INET6, remote_address, &_notify.remote_addr.sin6_addr);\n+  \
    \  if (ip_result != 1) {\n+      result = SL_STATUS_FAIL;\n+    }\n+    _notify.remote_addr.sin6_port\
    \ = port;\n+  }\n+  _update_notify_settings();\n+  _app_wisun_mutex_release();\n\
    +  return result;\n+}\n+\n+void sl_wisun_app_status_set_schedule_time_ms(const\
    \ uint32_t new_schedule_time_ms)\n+{\n+  _app_wisun_mutex_acquire();\n+  _notify.schedule_time_ms\
    \ = new_schedule_time_ms;\n+  _update_notify_settings();\n+  _app_wisun_mutex_release();\n\
    +}\n+\n // -----------------------------------------------------------------------------\n\
    \ //                          Static Function Definitions\n // -----------------------------------------------------------------------------\n\
    -\n static void _build_neighbour_info(uint8_t **buf, uint16_t *buf_len)\n {\n\
    \   int32_t r = 0L;\n@@ -296,10 +366,10 @@ static void _build_device_info(uint8_t\
    \ **buf, uint16_t *buf_len)\n \n   if (!initialized) {\n #if defined(SL_CATALOG_WISUN_LFN_DEVICE_SUPPORT_PRESENT)\n\
    -    dev_type = app_wisun_get_device_type();\n+    dev_type = sl_wisun_app_core_get_device_type();\n\
    \ #endif\n \n-    pinf = app_wisun_project_info_get();\n+    pinf = sl_wisun_app_core_util_project_info_get();\n\
    \     ver_stack = app_project_info_get_version(APP_PROJECT_INFO_VERSION_ID_WISUN,\
    \ pinf);\n     ver_app = app_project_info_get_version(APP_PROJECT_INFO_VERSION_ID_APP,\
    \ pinf);\n \n@@ -356,7 +426,7 @@ static void _build_device_info(uint8_t **buf,\
    \ uint16_t *buf_len)\n static void _build_time_stat(uint8_t **buf, uint16_t *buf_len)\n\
    \ {\n   int32_t r = 0L;\n-  static app_core_time_stat_t stat = { 0U };\n+  static\
    \ sl_wisun_app_core_time_stat_t stat = { 0U };\n   static sl_wisun_trace_util_time_t\
    \ time = { 0U };\n   const char *run_str = NULL;\n   const char *conn_str = NULL;\n\
    @@ -367,29 +437,29 @@ static void _build_time_stat(uint8_t **buf, uint16_t *buf_len)\n\
    \   uint8_t avail_i = 0U;\n   uint8_t avail_f = 0U;\n \n-  app_wisun_get_time_stat(&stat);\n\
    +  sl_wisun_app_core_get_time_stat(&stat);\n   app_wisun_trace_util_timestamp_init(stat.curr_ms,\
    \ &time);\n   run_str = app_wisun_trace_util_time_to_str(&time);\n \n-  app_wisun_get_time_stat(&stat);\n\
    +  sl_wisun_app_core_get_time_stat(&stat);\n   app_wisun_trace_util_timestamp_init(stat.connected_ms,\
    \ &time);\n   conn_str = app_wisun_trace_util_time_to_str(&time);\n \n-  app_wisun_get_time_stat(&stat);\n\
    +  sl_wisun_app_core_get_time_stat(&stat);\n   app_wisun_trace_util_timestamp_init(stat.tot_connected_ms,\
    \ &time);\n   tot_conn_str = app_wisun_trace_util_time_to_str(&time);\n \n-  app_wisun_get_time_stat(&stat);\n\
    +  sl_wisun_app_core_get_time_stat(&stat);\n   app_wisun_trace_util_timestamp_init(stat.disconnected_ms,\
    \ &time);\n   disconn_str = app_wisun_trace_util_time_to_str(&time);\n \n-  app_wisun_get_time_stat(&stat);\n\
    +  sl_wisun_app_core_get_time_stat(&stat);\n   app_wisun_trace_util_timestamp_init(stat.tot_disconnected_ms,\
    \ &time);\n   tot_disconn_str = app_wisun_trace_util_time_to_str(&time);\n \n\
    \   tmp = (uint16_t) ((stat.tot_connected_ms * 10000U) / (stat.tot_connected_ms\
    \ + stat.tot_disconnected_ms));\n   avail_i = (uint8_t) (tmp / 100U);\n-  avail_f\
    \ = (uint8_t) (tmp - avail_i * 100U); \n+  avail_f = (uint8_t) (tmp - avail_i\
    \ * 100U);\n \n   __print_to_buff(r, *buf, *buf_len,\n                   SL_WISUN_APP_STATUS_TIME_STAT_JSON_STR,\n\
    @@ -466,3 +536,22 @@ static sl_wisun_coap_packet_t * _notify_hnd(const struct\
    \ sl_wisun_coap_notify *n\n \n   return &pkt;\n }\n+\n+/* Mutex acquire */\n+__STATIC_INLINE\
    \ void _app_wisun_mutex_acquire(void)\n+{\n+  assert(osMutexAcquire(_app_wisun_app_status_mtx,\
    \ osWaitForever) == osOK);\n+}\n+\n+/* Mutex release */\n+__STATIC_INLINE void\
    \ _app_wisun_mutex_release(void)\n+{\n+  assert(osMutexRelease(_app_wisun_app_status_mtx)\
    \ == osOK);\n+}\n+\n+/* update coap notify instance*/\n+__STATIC_INLINE sl_status_t\
    \ _update_notify_settings(void)\n+{\n+  sl_wisun_coap_notify_remove_by_id(SL_WISUN_APP_STATUS_DEFAULT_NOTIFCATION_ID);\n\
    +  return sl_wisun_coap_notify_add(&_notify);\n+}"
  - '--- a/app/wisun/component/app_status_cli/sl_wisun_app_status_cli.c

    +++ b/app/wisun/component/app_status_cli/sl_wisun_app_status_cli.c

    @@ -0,0 +1,136 @@

    +/***************************************************************************//**

    + * @file

    + * @brief App Status commandline interface handler

    + *******************************************************************************

    + * # License

    + * <b>Copyright 2021 Silicon Laboratories Inc. www.silabs.com</b>

    + *******************************************************************************

    + *

    + * SPDX-License-Identifier: Zlib

    + *

    + * The licensor of this software is Silicon Laboratories Inc.

    + *

    + * This software is provided ''as-is'', without any express or implied

    + * warranty. In no event will the authors be held liable for any damages

    + * arising from the use of this software.

    + *

    + * Permission is granted to anyone to use this software for any purpose,

    + * including commercial applications, and to alter it and redistribute it

    + * freely, subject to the following restrictions:

    + *

    + * 1. The origin of this software must not be misrepresented; you must not

    + *    claim that you wrote the original software. If you use this software

    + *    in a product, an acknowledgment in the product documentation would be

    + *    appreciated but is not required.

    + * 2. Altered source versions must be plainly marked as such, and must not be

    + *    misrepresented as being the original software.

    + * 3. This notice may not be removed or altered from any source distribution.

    + *

    + ******************************************************************************/

    +

    +// -----------------------------------------------------------------------------

    +//                                   Includes

    +// -----------------------------------------------------------------------------

    +#include <string.h>

    +#include <stdio.h>

    +#include <stddef.h>

    +#include <stdint.h>

    +#include <stdbool.h>

    +#include <stdlib.h>

    +#include "sl_string.h"

    +#include "sl_cli.h"

    +#include "sl_wisun_cli_core.h"

    +#include "sl_wisun_app_status.h"

    +#include "sl_wisun_trace_util.h"

    +

    +// -----------------------------------------------------------------------------

    +//                              Macros and Typedefs

    +// -----------------------------------------------------------------------------

    +///  Size of the IPv6 string

    +#define IPV6_STRING_SIZE                (40U)

    +

    +// -----------------------------------------------------------------------------

    +//                          Static Function Declarations

    +// -----------------------------------------------------------------------------

    +

    +// -----------------------------------------------------------------------------

    +//                                Global Variables

    +// -----------------------------------------------------------------------------

    +

    +// -----------------------------------------------------------------------------

    +//                                Static Variables

    +// -----------------------------------------------------------------------------

    +///  Buffer to store the IPv6 string

    +static char ip_buff[IPV6_STRING_SIZE] = { 0 };

    +

    +// -----------------------------------------------------------------------------

    +//                          Public Function Definitions

    +// -----------------------------------------------------------------------------

    +/**************************************************************************//**

    + * @brief App status get remote address and port

    + * @details CLI function

    + * @param[in] arguments Arguments

    + *****************************************************************************/

    +void sl_app_status_cli_get_address(sl_cli_command_arg_t *arguments)

    +{

    +  (void)arguments;

    +  app_wisun_cli_mutex_lock();

    +  const sockaddr_in6_t* address = sl_wisun_app_status_get_remote_address();

    +  inet_ntop(AF_INET6, &(address->sin6_addr), ip_buff, sizeof(ip_buff));

    +  printf("remote_address=%s\n", ip_buff);

    +  printf("remote_port=%d\n", address->sin6_port);

    +  memset(ip_buff, 0, sizeof(ip_buff));

    +  app_wisun_cli_mutex_unlock();

    +}

    +

    +/**************************************************************************//**

    + * @brief App status get schedule time in ms

    + * @details CLI function

    + * @param[in] arguments Arguments

    + *****************************************************************************/

    +void sl_app_status_cli_get_schedule(sl_cli_command_arg_t *arguments)

    +{

    +  (void)arguments;

    +  app_wisun_cli_mutex_lock();

    +  printf("schedule_time_m=%ld\n", sl_wisun_app_status_get_schedule_time_ms());

    +  app_wisun_cli_mutex_unlock();

    +}

    +

    +/**************************************************************************//**

    + * @brief App status set schedule time in ms

    + * @details CLI function

    + * @param[in] arguments Arguments

    + *****************************************************************************/

    +void sl_app_status_cli_set_schedule(sl_cli_command_arg_t *arguments)

    +{

    +  uint32_t schedule_time_ms = 0;

    +  app_wisun_cli_mutex_lock();

    +  schedule_time_ms = sl_cli_get_argument_uint32(arguments, 0U);

    +  sl_wisun_app_status_set_schedule_time_ms(schedule_time_ms);

    +  printf("[Settings saved]\r\n");

    +  app_wisun_cli_mutex_unlock();

    +}

    +

    +/**************************************************************************//**

    + * @brief App status set remote address and port

    + * @details CLI function

    + * @param[in] arguments Arguments

    + *****************************************************************************/

    +void sl_app_status_cli_set_address(sl_cli_command_arg_t *arguments)

    +{

    +  uint16_t port = 0;

    +  char *address = NULL;

    +  app_wisun_cli_mutex_lock();

    +  address = sl_cli_get_argument_string(arguments, 0U);

    +  port = sl_cli_get_argument_uint16(arguments, 1U);

    +  if (sl_wisun_app_status_set_remote_address(address, port) != 0U) {

    +    printf("[Failed: invalid remote address parameter]\r\n");

    +  } else {

    +    printf("[Settings saved]\r\n");

    +  }

    +  app_wisun_cli_mutex_unlock();

    +}

    +

    +// -----------------------------------------------------------------------------

    +//                          Static Function Definitions

    +// -----------------------------------------------------------------------------'
  - "--- a/app/wisun/component/coap/sl_wisun_coap.c\n+++ b/app/wisun/component/coap/sl_wisun_coap.c\n\
    @@ -192,7 +192,7 @@ sl_status_t sl_wisun_coap_init_srv(sl_wisun_coap_srv_t * const\
    \ srv,\n   }\n \n   // Create socket\n-  srv->sockid = socket(AF_INET6, (SOCK_DGRAM\
    \ | SOCK_NONBLOCK), IPPROTO_UDP);\n+  srv->sockid = socket(AF_INET6, SOCK_DGRAM,\
    \ IPPROTO_UDP);\n   if (srv->sockid == SOCKET_INVALID_ID) {\n     return SL_STATUS_FAIL;\n\
    \   }\n@@ -235,7 +235,7 @@ sl_status_t sl_wisun_coap_init_clnt(sl_wisun_coap_clnt_t\
    \ * const clnt,\n   }\n \n   // Create socket\n-  clnt->sockid = socket(AF_INET6,\
    \ (SOCK_DGRAM | SOCK_NONBLOCK), IPPROTO_UDP);\n+  clnt->sockid = socket(AF_INET6,\
    \ SOCK_DGRAM, IPPROTO_UDP);\n   if (clnt->sockid == SOCKET_INVALID_ID) {\n   \
    \  return SL_STATUS_FAIL;\n   }"
  - "--- a/app/wisun/component/coap/sl_wisun_coap_notify.c\n+++ b/app/wisun/component/coap/sl_wisun_coap_notify.c\n\
    @@ -297,7 +297,7 @@ sl_status_t sl_wisun_coap_notify_send_notification(const sl_wisun_coap_notify_t\n\
    \   int32_t sockid = SOCKET_INVALID_ID;\n \n   // create socket\n-  sockid = socket(AF_INET6,\
    \ (SOCK_DGRAM | SOCK_NONBLOCK), IPPROTO_UDP);\n+  sockid = socket(AF_INET6, SOCK_DGRAM,\
    \ IPPROTO_UDP);\n   if (sockid == SOCKET_RETVAL_ERROR) {\n     return SL_STATUS_FAIL;\n\
    \   }\n@@ -397,7 +397,7 @@ static void _notify_thr_fnc(void * args)\n   (void)\
    \ args;\n \n   SL_COAP_SERVICE_LOOP() {\n-    if (!app_wisun_network_is_connected())\
    \ {\n+    if (!sl_wisun_app_core_util_network_is_connected()) {\n       osDelay(1000UL);\n\
    \       continue;\n     }"
  - "--- a/app/wisun/component/coap/sl_wisun_coap_rhnd.c\n+++ b/app/wisun/component/coap/sl_wisun_coap_rhnd.c\n\
    @@ -466,13 +466,13 @@ static void _rhnd_thr_fnc(void * args)\n \n   SL_COAP_SERVICE_LOOP()\
    \ {\n     // wait for network connected state\n-    if (!app_wisun_network_is_connected())\
    \ {\n+    if (!sl_wisun_app_core_util_network_is_connected()) {\n       osDelay(1000UL);\n\
    \       continue;\n     }\n \n     // creating socket\n-    sockid = socket(AF_INET6,\
    \ (SOCK_DGRAM | SOCK_NONBLOCK), IPPROTO_UDP);\n+    sockid = socket(AF_INET6,\
    \ SOCK_DGRAM, IPPROTO_UDP);\n     assert(sockid != SOCKET_INVALID_ID);\n \n  \
    \   // fill the server address structure\n@@ -487,7 +487,7 @@ static void _rhnd_thr_fnc(void\
    \ * args)\n     assert(r != SOCKET_RETVAL_ERROR);\n \n #if SL_WISUN_COAP_RD_SOCKET_REQUIRED\n\
    -    sockid_rd = socket(AF_INET6, (SOCK_DGRAM | SOCK_NONBLOCK), IPPROTO_UDP);\n\
    +    sockid_rd = socket(AF_INET6, SOCK_DGRAM, IPPROTO_UDP);\n     assert(sockid_rd\
    \ != SOCKET_INVALID_ID);\n \n     srv_addr_rd.sin6_family = AF_INET6;\n@@ -503,7\
    \ +503,7 @@ static void _rhnd_thr_fnc(void * args)\n     // Receiver loop\n  \
    \   while (1) {\n       // Dispatch\n-      app_wisun_dispatch_thread();\n+  \
    \    sl_wisun_app_core_util_dispatch_thread();\n \n       // Receive UDP packets\n\
    \       sockid_active = sockid;\n@@ -609,7 +609,7 @@ static void _rhnd_thr_fnc(void\
    \ * args)\n         __cleanup_service();\n \n         // Check network connection\
    \ after a session\n-      } else if (r == SOCKET_RETVAL_ERROR && !app_wisun_network_is_connected())\
    \ {\n+      } else if (r == SOCKET_RETVAL_ERROR && !sl_wisun_app_core_util_network_is_connected())\
    \ {\n         close(sockid);\n #if SL_WISUN_COAP_RD_SOCKET_REQUIRED\n        \
    \ close(sockid_rd);"
  - "--- a/app/wisun/component/collector_cli/sl_wisun_collector_cli.c\n+++ b/app/wisun/component/collector_cli/sl_wisun_collector_cli.c\n\
    @@ -114,6 +114,7 @@ void app_remove_meter(sl_cli_command_arg_t *arguments)\n \
    \  }\n   if (inet_pton(AF_INET6, meter_ip, &meter_addr.sin6_addr) == SOCKET_RETVAL_ERROR\
    \ ) {\n     printf(\"[Failed: invalid remote address parameter]\\r\\n\");\n+ \
    \   app_wisun_release_cli_mutex_and_return();\n   }\n \n   stat = sl_wisun_collector_remove_meter(&meter_addr);\n\
    @@ -147,6 +148,7 @@ void app_async_request(sl_cli_command_arg_t *arguments)\n\
    \   }\n   if (inet_pton(AF_INET6, meter_ip, &meter_addr.sin6_addr) == SOCKET_RETVAL_ERROR\
    \ ) {\n     printf(\"[Failed: invalid remote address parameter]\\r\\n\");\n+ \
    \   app_wisun_release_cli_mutex_and_return();\n   }\n \n   stat = sl_wisun_send_async_request(&meter_addr);"
  - "--- a/app/wisun/component/event_manager/sl_wisun_event_mgr.c\n+++ b/app/wisun/component/event_manager/sl_wisun_event_mgr.c\n\
    @@ -38,13 +38,14 @@\n #include \"sl_cmsis_os2_common.h\"\n #include \"sl_wisun_api.h\"\
    \n #include \"sl_wisun_event_mgr.h\"\n+#include \"sl_wisun_trace_util.h\"\n+\n\
    \ // -----------------------------------------------------------------------------\n\
    \ //                              Macros and Typedefs\n // -----------------------------------------------------------------------------\n\
    \ \n-/**************************************************************************//**\n\
    - * @brief Event index for lookup\n- *****************************************************************************/\n\
    +\n+/// Event index for lookup\n typedef enum {\n   EVENT_IDX_NOTVALID = -1,\n\
    \   EVENT_IDX_NETWORK_UPDATE,\n@@ -60,9 +61,28 @@ typedef enum {\n   EVENT_IDX_ERROR,\n\
    \   EVENT_IDX_JOIN_STATE,\n   EVENT_IDX_REGULATION_TX_LEVEL,\n-  EVENT_IDX_LFN_WAKE_UP\n\
    +  EVENT_IDX_LFN_WAKE_UP,\n+  EVENT_IDX_MULTICAST_REG_FINISH\n } app_wisun_event_id_t;\n\
    \ \n+/// Wi-SUN application callback type.\n+/// It is always called, User cannot\
    \ register or remove them.\n+/// It contains the must have implementation of the\
    \ event.\n+typedef void (*wisun_event_callback_t) (sl_wisun_evt_t *);\n+\n+\n\
    +/// Event handler structure\n+typedef struct event_handler {\n+  /// ID\n+  sl_wisun_msg_ind_id_t\
    \ id;\n+  /// Callback for internal usage\n+  wisun_event_callback_t callback;\n\
    +  /// Custom, registerable and removable callback for applications\n+  custom_wisun_event_callback_t\
    \ custom_callback;\n+  /// Event notification\n+  app_wisun_trace_util_evt_notify_t\
    \ evt_notify;\n+} event_handler_t;\n+\n // -----------------------------------------------------------------------------\n\
    \ //                          Static Function Declarations\n // -----------------------------------------------------------------------------\n\
    @@ -94,25 +114,19 @@ __STATIC_INLINE app_wisun_event_id_t _decode_ind(const sl_wisun_msg_ind_id_t\
    \ ind\n //                                Static Variables\n // -----------------------------------------------------------------------------\n\
    \ \n-/**************************************************************************//**\n\
    - * @brief App framework mutex\n- *****************************************************************************/\n\
    -static osMutexId_t _app_wisun_event_mgr_mtx;\n+/// App framework mutex\n+static\
    \ osMutexId_t _app_wisun_event_mgr_mtx = NULL;\n \n-/**************************************************************************//**\n\
    - * @brief App framework mutex attribute\n- *****************************************************************************/\n\
    +/// App framework mutex attribute\n static const osMutexAttr_t _app_wisun_event_mgr_mtx_attr\
    \ = {\n   .name      = \"AppWisunEventMgrMutex\",\n   .attr_bits = osMutexRecursive,\n\
    \   .cb_mem    = NULL,\n   .cb_size   = 0\n };\n \n-/**************************************************************************//**\n\
    - * @brief Event Lookup table\n- *        Lookup table indexes must be matched\
    \ with app_wisun_event_id_t!\n- *****************************************************************************/\n\
    +/// Event Lookup table\n+/// Lookup table indexes must be matched with app_wisun_event_id_t!\n\
    \ static event_handler_t _wisun_events[] = {\n   {\n     .id = SL_WISUN_MSG_NETWORK_UPDATE_IND_ID,\n\
    @@ -183,12 +197,15 @@ static event_handler_t _wisun_events[] = {\n     .id = SL_WISUN_MSG_LFN_WAKE_UP_IND_ID,\n\
    \     .callback = sl_wisun_lfn_wake_up_hnd,\n     .custom_callback = NULL\n+ \
    \ },\n+  {\n+    .id = SL_WISUN_MSG_LFN_MULTICAST_REG_IND_ID,\n+    .callback\
    \ = sl_wisun_multicast_reg_finish_hnd,\n+    .custom_callback = NULL\n   }\n };\n\
    \ \n-/**************************************************************************//**\n\
    - * @brief Handled event count\n- *****************************************************************************/\n\
    +/// Handled event count\n static const uint16_t _wisun_event_size = sizeof(_wisun_events)\
    \ / sizeof(event_handler_t);\n \n // -----------------------------------------------------------------------------\n\
    @@ -198,8 +215,14 @@ static const uint16_t _wisun_event_size = sizeof(_wisun_events)\
    \ / sizeof(event_h\n /* Event Manager initialization */\n void app_wisun_event_mgr_init(void)\n\
    \ {\n+  // Init mutex\n   _app_wisun_event_mgr_mtx = osMutexNew(&_app_wisun_event_mgr_mtx_attr);\n\
    \   assert(_app_wisun_event_mgr_mtx != NULL);\n+\n+  // Init event flags\n+  for\
    \ (uint16_t i = 0; i < _wisun_event_size; ++i) {\n+    app_wisun_trace_util_evt_notify_init(&_wisun_events[i].evt_notify,\
    \ osFlagsWaitAll);\n+  }\n }\n \n /* Event Manager custom callback register */\n\
    @@ -238,6 +261,8 @@ sl_status_t app_wisun_em_custom_callback_remove(sl_wisun_msg_ind_id_t\
    \ id)\n {\n   osKernelState_t kernel_state = osKernelLocked;\n \n+  kernel_state\
    \ = osKernelGetState();\n+\n   // check kernel state to avoid mutex acquire issue\n\
    \   if (kernel_state == osKernelRunning) {\n     app_wisun_event_mgr_mutex_lock();\n\
    @@ -271,11 +296,81 @@ void sl_wisun_on_event(sl_wisun_evt_t *evt)\n     if (_wisun_events[idx].custom_callback\
    \ != NULL) {\n       _wisun_events[idx].custom_callback(evt);\n     }\n+\n+  \
    \  if (_wisun_events[idx].evt_notify.evt_chs) {\n+      app_wisun_trace_util_evt_notfiy_chs(&_wisun_events[idx].evt_notify);\n\
    +    }\n   }\n \n   app_wisun_event_mgr_mutex_unlock();\n }\n \n+sl_status_t app_wisun_em_subscribe_evt_notification(const\
    \ sl_wisun_msg_ind_id_t id, uint8_t * const evt_ch)\n+{\n+  app_wisun_event_id_t\
    \ idx = _decode_ind(id);\n+  sl_status_t ret = SL_STATUS_FAIL;\n+  osKernelState_t\
    \ kernel_state = osKernelLocked;\n+\n+  kernel_state = osKernelGetState();\n+\n\
    +  if (EVENT_IDX_NOTVALID == idx) {\n+    return ret;\n+  }\n+\n+  if (kernel_state\
    \ == osKernelRunning) {\n+    app_wisun_event_mgr_mutex_lock();\n+  }\n+\n+  ret\
    \ = app_wisun_trace_util_evt_notify_subscribe_ch(&_wisun_events[idx].evt_notify,\
    \ evt_ch);\n+\n+  if (kernel_state == osKernelRunning) {\n+    app_wisun_event_mgr_mutex_unlock();\n\
    +  }\n+\n+  return ret;\n+}\n+\n+sl_status_t app_wisun_em_unsubscribe_evt_notification(const\
    \ sl_wisun_msg_ind_id_t id, const uint8_t evt_ch)\n+{\n+  app_wisun_event_id_t\
    \ idx = _decode_ind(id);\n+  sl_status_t ret = SL_STATUS_FAIL;\n+  osKernelState_t\
    \ kernel_state = osKernelLocked;\n+\n+  kernel_state = osKernelGetState();\n+\n\
    +  if (EVENT_IDX_NOTVALID == idx) {\n+    return ret;\n+  }\n+\n+  if (kernel_state\
    \ == osKernelRunning) {\n+    app_wisun_event_mgr_mutex_lock();\n+  }\n+\n+  ret\
    \ = app_wisun_trace_util_evt_notify_unsubscribe_ch(&_wisun_events[idx].evt_notify,\
    \ evt_ch);\n+\n+  if (kernel_state == osKernelRunning) {\n+    app_wisun_event_mgr_mutex_unlock();\n\
    +  }\n+\n+  return ret;\n+}\n+\n+sl_status_t app_wisun_em_wait_evt_notification(const\
    \ sl_wisun_msg_ind_id_t id, const uint8_t evt_ch)\n+{\n+  app_wisun_event_id_t\
    \ idx = _decode_ind(id);\n+  sl_status_t ret = SL_STATUS_FAIL;\n+\n+  if (EVENT_IDX_NOTVALID\
    \ == idx) {\n+    return ret;\n+  }\n+  \n+  ret = app_wisun_trace_util_evt_notify_wait(&_wisun_events[idx].evt_notify,\
    \ \n+                                             1U << evt_ch, \n+          \
    \                                   osWaitForever);\n+\n+  return ret;\n+}\n+\n\
    \ // -----------------------------------------------------------------------------\n\
    \ //                          Static Function Definitions\n // -----------------------------------------------------------------------------\n\
    @@ -310,6 +405,7 @@ __STATIC_INLINE app_wisun_event_id_t _decode_ind(const sl_wisun_msg_ind_id_t\
    \ ind\n     case SL_WISUN_MSG_JOIN_STATE_IND_ID:                    return EVENT_IDX_JOIN_STATE;\n\
    \     case SL_WISUN_MSG_REGULATION_TX_LEVEL_IND_ID:           return EVENT_IDX_REGULATION_TX_LEVEL;\n\
    \     case SL_WISUN_MSG_LFN_WAKE_UP_IND_ID:                   return EVENT_IDX_LFN_WAKE_UP;\n\
    +    case SL_WISUN_MSG_LFN_MULTICAST_REG_IND_ID:             return EVENT_IDX_MULTICAST_REG_FINISH;\n\
    \     default:                                                return EVENT_IDX_NOTVALID;\n\
    \   }\n }\n@@ -463,3 +559,14 @@ SL_WEAK void sl_wisun_lfn_wake_up_hnd(sl_wisun_evt_t\
    \ *evt)\n   (void) evt;\n   assert(false);\n }\n+\n+/**************************************************************************//**\n\
    + * @brief Wi-SUN multicast group registration finishes event handler\n+ * @details\n\
    + * @param[in] evt event ptr\n+ *****************************************************************************/\n\
    +SL_WEAK void sl_wisun_multicast_reg_finish_hnd(sl_wisun_evt_t *evt)\n+{\n+  (void)\
    \ evt;\n+  assert(false);\n+}"
  - "--- a/app/wisun/component/ftp_posix_port/sl_wisun_ftp_posix_port.c\n+++ b/app/wisun/component/ftp_posix_port/sl_wisun_ftp_posix_port.c\n\
    @@ -82,7 +82,7 @@ void sl_ftp_delay_ms(const uint32_t delay_ms)\n  ******************************************************************************/\n\
    \ bool sl_ftp_is_network_connected(void)\n {\n-  return app_wisun_network_is_connected();\n\
    +  return sl_wisun_app_core_util_network_is_connected();\n }\n \n /***************************************************************************//**\n\
    @@ -130,7 +130,7 @@ int32_t sl_ftp_socket_close(int32_t sockid)\n  ******************************************************************************/\n\
    \ int32_t sl_ftp_tcp_socket_create(void)\n {\n-  return socket(AF_INET6, (SOCK_STREAM\
    \ | SOCK_NONBLOCK), IPPROTO_TCP);\n+  return socket(AF_INET6, SOCK_STREAM, IPPROTO_TCP);\n\
    \ }\n \n /***************************************************************************//**\n\
    @@ -192,7 +192,7 @@ int32_t sl_ftp_tcp_socket_recv(int32_t sockid, void *buff,\
    \ uint32_t len)\n  ******************************************************************************/\n\
    \ int32_t sl_tftp_udp_socket_create(void)\n {\n-  return socket(AF_INET6, (SOCK_DGRAM\
    \ | SOCK_NONBLOCK), IPPROTO_UDP);\n+  return socket(AF_INET6, SOCK_DGRAM, IPPROTO_UDP);\n\
    \ }\n \n /**************************************************************************//**"
  - "--- a/app/wisun/component/iperf/sl_iperf.c\n+++ b/app/wisun/component/iperf/sl_iperf.c\n\
    @@ -224,20 +224,26 @@ void sl_iperf_test_init(sl_iperf_test_t * const test, sl_iperf_mode_t\
    \ mode, sl_i\n \n void sl_iperf_test_set_default_logger(sl_iperf_test_t * const\
    \ test)\n {\n-  test->log = &_def_log;\n+  if (test != NULL) {\n+    test->log\
    \ = &_def_log;\n+  }\n }\n \n void sl_iperf_test_set_default_buff(sl_iperf_test_t\
    \ * const test)\n {\n-  test->conn.buff = _iperf_buff;\n-  test->conn.buff_size\
    \ = SL_IPERF_BUFFER_SIZE;\n+  if (test != NULL) {\n+    test->conn.buff = _iperf_buff;\n\
    +    test->conn.buff_size = SL_IPERF_BUFFER_SIZE;\n+  }\n }\n \n #if !defined(SL_IPERF_CMSIS_RTOS_DISABLED)\n\
    \ bool sl_iperf_test_add(sl_iperf_test_t * const test)\n {\n   osStatus_t status\
    \ = osError;\n-  status = osMessageQueuePut(_iperf_test_req_msg_queue, test, 0U,\
    \ osWaitForever);\n+  if (test != NULL) {\n+    status = osMessageQueuePut(_iperf_test_req_msg_queue,\
    \ test, 0U, osWaitForever);\n+  }\n   return _os_status_to_bool(status);\n }\n\
    \ "
  - "--- a/app/wisun/component/iperf/sl_iperf_udp_clnt.c\n+++ b/app/wisun/component/iperf/sl_iperf_udp_clnt.c\n\
    @@ -353,6 +353,7 @@ static void _parse_srv_finack(sl_iperf_test_t * const test)\n\
    \   t.usec = sl_iperf_network_ntohl(hdr->stop_usec);\n   test->statistic.finack_duration_ms\
    \ = sl_iperf_calc_ms_from_time(&t);\n   test->statistic.finack_pkt = sl_iperf_network_ntohl(hdr->packet_cnt);\n\
    +  test->statistic.finack_bw = (uint32_t)(((uint64_t)test->statistic.finack_tot_len\
    \ * SL_IPERF_DATA_BYTE_TO_BIT_ML * SL_IPERF_TIME_S_TO_MS_ML) / test->statistic.finack_duration_ms);\n\
    \   test->statistic.udp_lost_pkt = sl_iperf_network_ntohl(hdr->lost_pkt_cnt);\n\
    \   test->statistic.udp_out_of_order = sl_iperf_network_ntohl(hdr->out_of_order_cnt);\n\
    \   t.sec = sl_iperf_network_ntohl(hdr->jitter_sec);"
  - "--- a/app/wisun/component/iperf/sl_iperf_util.c\n+++ b/app/wisun/component/iperf/sl_iperf_util.c\n\
    @@ -248,7 +248,8 @@ void sl_iperf_print_test_log_json(sl_iperf_test_t * const\
    \ test)\n   sl_iperf_log_print(test->log, \"%*s\\\"bandwidth\\\":            \
    \ %lu,\\n\", __indent(3U), test->statistic.bandwidth);\n   sl_iperf_log_print(test->log,\
    \ \"%*s\\\"finack_tot_len\\\":        %lu,\\n\", __indent(3U), test->statistic.finack_tot_len);\n\
    \   sl_iperf_log_print(test->log, \"%*s\\\"finack_duration_ms\\\":    %lu,\\n\"\
    , __indent(3U), test->statistic.finack_duration_ms);\n-  sl_iperf_log_print(test->log,\
    \ \"%*s\\\"finack_pkt\\\":            %lu\\n\", __indent(3U), test->statistic.finack_pkt);\n\
    +  sl_iperf_log_print(test->log, \"%*s\\\"finack_pkt\\\":            %lu,\\n\"\
    , __indent(3U), test->statistic.finack_pkt);\n+  sl_iperf_log_print(test->log,\
    \ \"%*s\\\"finack_bw\\\":             %lu\\n\", __indent(3U), test->statistic.finack_bw);\n\
    \   sl_iperf_log_print(test->log, \"%*s}\\n\", __indent(2U));\n   sl_iperf_log_print(test->log,\
    \ \"%*s}\\n\", __indent(1U));\n   sl_iperf_log_print(test->log, \"}\\n\");"
  - "--- a/app/wisun/component/iperf_posix_port/sl_wisun_iperf_posix_port.c\n+++ b/app/wisun/component/iperf_posix_port/sl_wisun_iperf_posix_port.c\n\
    @@ -84,10 +84,10 @@ int32_t sl_iperf_socket_create(sl_iperf_protocol_t protocol)\n\
    \ \n   switch (protocol) {\n     case SL_IPERF_IPROTOV6_UDP:\n-      sockid =\
    \ socket(AF_INET6, (SOCK_DGRAM | SOCK_NONBLOCK), IPPROTO_UDP);\n+      sockid\
    \ = socket(AF_INET6, SOCK_DGRAM | SOCK_NONBLOCK, IPPROTO_UDP);\n       break;\n\
    \     case SL_IPERF_IPROTOV6_TCP:\n-      sockid = socket(AF_INET6, (SOCK_STREAM\
    \ | SOCK_NONBLOCK), IPPROTO_TCP);\n+      sockid = socket(AF_INET6, SOCK_STREAM\
    \ | SOCK_NONBLOCK, IPPROTO_TCP);\n       break;\n     // IPv4 is not supported\
    \ on Wi-SUN\n     default: return SL_IPERF_NW_API_ERROR;\n@@ -195,7 +195,7 @@\
    \ void sl_iperf_get_socket_addr_ip(const sl_iperf_socket_addr_t * const addr,\
    \ void\n \n bool sl_iperf_network_is_connected(void)\n {\n-  return app_wisun_network_is_connected();\n\
    +  return sl_wisun_app_core_util_network_is_connected();\n }\n \n uint16_t sl_iperf_network_htons(uint16_t\
    \ val)"
  - "--- a/app/wisun/component/led_driver/sl_wisun_led_driver.c\n+++ b/app/wisun/component/led_driver/sl_wisun_led_driver.c\n\
    @@ -37,15 +37,19 @@\n #include <stddef.h>\n #include <stdio.h>\n #include <inttypes.h>\n\
    +\n+#include \"sl_wisun_led_driver.h\"\n+\n+#if !defined(SL_CATALOG_POWER_MANAGER_PRESENT)\n\
    \ #include \"cmsis_os2.h\"\n #include \"sl_status.h\"\n #include \"sl_cmsis_os2_common.h\"\
    \n-#include \"sl_wisun_led_driver.h\"\n #include \"sl_simple_led.h\"\n #include\
    \ \"sl_simple_led_instances.h\"\n #include \"sl_wisun_trace_util.h\"\n #include\
    \ \"sl_wisun_led_driver_config.h\"\n \n+\n // -----------------------------------------------------------------------------\n\
    \ //                              Macros and Typedefs\n // -----------------------------------------------------------------------------\n\
    @@ -397,3 +401,11 @@ __STATIC_INLINE sl_wisun_led_signal_t *_get_led_signal_ptr(const\
    \ sl_wisun_led_id\n     default:               return NULL;\n   }\n }\n+#else\n\
    +\n+void sl_wisun_led_driver_init(void)\n+{\n+  (void) 0UL;\n+}\n+\n+#endif"
  - "--- a/app/wisun/component/meter_collector_common/sl_wisun_coap_collector.c\n\
    +++ b/app/wisun/component/meter_collector_common/sl_wisun_coap_collector.c\n@@\
    \ -37,6 +37,7 @@\n #include \"sl_status.h\"\n #include \"sl_wisun_meter_collector_config.h\"\
    \n #include \"sl_wisun_collector.h\"\n+#include \"sl_wisun_trace_util.h\"\n \n\
    \ // -----------------------------------------------------------------------------\n\
    \ //                              Macros and Typedefs\n@@ -134,20 +135,22 @@ sl_status_t\
    \ sl_wisun_coap_collector_prepare_request(const sl_wisun_request_type_\n   packet->uri_path_len\
    \     = strlen(SL_WISUN_COAP_METER_COLLECTOR_MEASUREMENT_URI_PATH);\n   packet->msg_code\
    \         = COAP_MSG_CODE_REQUEST_GET;\n   packet->content_format   = COAP_CT_TEXT_PLAIN;\n\
    -  packet->payload_len      = SL_WISUN_METER_REQUEST_TYPE_LENGTH;\n   packet->payload_ptr\
    \      = NULL;\n   packet->options_list_ptr = NULL;\n   packet->msg_id       \
    \    = SL_WISUN_COAP_METER_COLLECTOR_DEFAULT_MESSAGE_ID;\n \n   switch (req_type)\
    \ {\n     case SL_WISUN_MC_REQ_ASYNC:\n       packet->payload_ptr = (uint8_t *)\
    \ SL_WISUN_METER_REQUEST_TYPE_STR_ASYNC;\n+      packet->payload_len = strlen(SL_WISUN_METER_REQUEST_TYPE_STR_ASYNC);\n\
    \       break;\n     case SL_WISUN_MC_REQ_REGISTER:\n       packet->payload_ptr\
    \ = (uint8_t *) SL_WISUN_METER_REQUEST_TYPE_STR_REGISTER;\n+      packet->payload_len\
    \ = strlen(SL_WISUN_METER_REQUEST_TYPE_STR_REGISTER);\n       break;\n     case\
    \ SL_WISUN_MC_REQ_REMOVE:\n       packet->payload_ptr = (uint8_t *) SL_WISUN_METER_REQUEST_TYPE_STR_REMOVE;\n\
    +      packet->payload_len = strlen(SL_WISUN_METER_REQUEST_TYPE_STR_REMOVE);\n\
    \       break;\n     default:\n       break;"
  - "--- a/app/wisun/component/meter_collector_common/sl_wisun_coap_meter.c\n+++ b/app/wisun/component/meter_collector_common/sl_wisun_coap_meter.c\n\
    @@ -40,6 +40,11 @@\n #include \"sl_wisun_app_core.h\"\n #include \"sl_wisun_coap_rhnd.h\"\
    \n #include \"sli_wisun_coap_rd.h\"\n+#include \"sl_wisun_trace_util.h\"\n+\n\
    +#if !defined(SL_CATALOG_POWER_MANAGER_PRESENT)\n+  #include \"sl_wisun_led_driver.h\"\
    \n+#endif\n \n #if defined(SL_CATALOG_TEMP_SENSOR_PRESENT)\n   #include \"sl_wisun_rht_measurement.h\"\
    \n@@ -151,6 +156,7 @@ static const char *_meter_packet2json(const sl_wisun_meter_packet_t\
    \ * const pack\n static sl_wisun_coap_packet_t *_prepare_measurement_resp(const\
    \ sl_wisun_coap_packet_t * const req_packet,\n                               \
    \                           const measurement_type_t measurement);\n \n+#if !defined(SL_CATALOG_POWER_MANAGER_PRESENT)\n\
    \ /**************************************************************************//**\n\
    \  * @brief Convert LED ID.\n  * @details Helper function to convert uint8_t LED\
    \ ID to sl_wisun_led_id_t\n@@ -159,6 +165,7 @@ static sl_wisun_coap_packet_t *_prepare_measurement_resp(const\
    \ sl_wisun_coap_pac\n  *****************************************************************************/\n\
    \ static sl_wisun_led_id_t _coap_meter_convert_led_id(const uint8_t led_id);\n\
    \ #endif\n+#endif\n \n // -----------------------------------------------------------------------------\n\
    \ //                                Global Variables\n@@ -190,6 +197,9 @@ static\
    \ sl_wisun_coap_packet_t dummy_req_pkt = {\n // -----------------------------------------------------------------------------\n\
    \ void sl_wisun_coap_meter_init(void)\n {\n+  // init meter for having proper\
    \ meter content\n+  sl_wisun_meter_init();\n+\n   // Init meter-collector common\
    \ component\n #if !defined(SL_CATALOG_TEMP_SENSOR_PRESENT)\n   sl_wisun_meter_set_initializer(&_coap_meter_hnd,\
    \ NULL);\n@@ -228,6 +238,7 @@ sl_wisun_coap_packet_t *sl_wisun_coap_meter_light_response_cb(const\
    \ sl_wisun_coa\n   return _prepare_measurement_resp(req_packet, COAP_METER_MEASUREMENT_LIGHT);\n\
    \ }\n \n+#if !defined(SL_CATALOG_POWER_MANAGER_PRESENT)\n sl_wisun_coap_packet_t\
    \ *sl_wisun_coap_meter_led_toggle_response_cb(const sl_wisun_coap_packet_t * const\
    \ req_packet)\n {\n   sl_wisun_coap_packet_t *resp_packet = NULL;\n@@ -256,6 +267,7\
    \ @@ sl_wisun_coap_packet_t *sl_wisun_coap_meter_led_toggle_response_cb(const\
    \ sl_wisu\n   return resp_packet;\n }\n #endif\n+#endif\n \n // -----------------------------------------------------------------------------\n\
    \ //                          Static Function Definitions\n@@ -331,7 +343,7 @@\
    \ static sl_status_t _coap_meter_build_packets(const sl_wisun_request_type_t req,\n\
    \                                              uint32_t * const len)\n {\n   sl_wisun_coap_packet_t\
    \ *packet                  = NULL;\n-  static current_addr_t addresses       \
    \          = { 0 };\n+  static sl_wisun_app_core_current_addr_t addresses    \
    \             = { 0 };\n   const char *ip_str_global                       = NULL;\n\
    \   uint16_t payload_len                            = 0U;\n   static char payload[JSON_MEASUREMENT_DATA_SIZE]\
    \ = { 0 };\n@@ -374,7 +386,7 @@ static sl_status_t _coap_meter_build_packets(const\
    \ sl_wisun_request_type_t req,\n     packet->msg_id            = SL_WISUN_COAP_METER_COLLECTOR_DEFAULT_MESSAGE_ID;\n\
    \     packet->msg_type          = COAP_MSG_TYPE_NON_CONFIRMABLE;\n \n-    app_wisun_get_current_addresses(&addresses);\n\
    +    sl_wisun_app_core_get_current_addresses(&addresses);\n     ip_str_global\
    \ = app_wisun_trace_util_get_ip_str(&addresses.global);\n \n     // Build payload\n\
    @@ -434,7 +446,7 @@ static sl_wisun_coap_packet_t *_prepare_measurement_resp(const\
    \ sl_wisun_coap_pac\n   sl_wisun_coap_packet_t * resp_packet  = NULL;\n   sn_coap_content_format_e\
    \ ct_format    = COAP_CT_JSON;\n   size_t max_content_size               = 0U;\n\
    -  static current_addr_t addresses       = { 0 };\n+  static sl_wisun_app_core_current_addr_t\
    \ addresses       = { 0 };\n   const char *ip_str_global             = NULL;\n\
    \   char *content                         = NULL;\n   static sl_wisun_meter_packet_t\
    \ packet = { 0 };\n@@ -450,7 +462,7 @@ static sl_wisun_coap_packet_t *_prepare_measurement_resp(const\
    \ sl_wisun_coap_pac\n     max_content_size = JSON_MEASUREMENT_DATA_SIZE;\n \n\
    \     // Get IP address\n-    app_wisun_get_current_addresses(&addresses);\n+\
    \    sl_wisun_app_core_get_current_addresses(&addresses);\n     ip_str_global\
    \ = app_wisun_trace_util_get_ip_str(&addresses.global);\n   } else {\n     ct_format\
    \ = COAP_CT_TEXT_PLAIN;"
  - "--- a/app/wisun/component/meter_collector_common/sl_wisun_collector.c\n+++ b/app/wisun/component/meter_collector_common/sl_wisun_collector.c\n\
    @@ -195,23 +195,28 @@ void sl_wisun_collector_init(void)\n   // init collector-meter\
    \ token\n   sl_wisun_mc_init_token(SL_WISUN_METER_COLLECTOR_TOKEN);\n \n-  req.length\
    \ = SL_WISUN_METER_REQUEST_TYPE_LENGTH\n-               + 1U\n-              \
    \ + sl_wisun_mc_get_token_size();\n-\n-  req.buff = (uint8_t *) SL_WISUN_METER_REQUEST_TYPE_STR_ASYNC\
    \ \\\n-             SL_WISUN_METER_REQUEST_DELIMITER                  \\\n-  \
    \           SL_WISUN_METER_COLLECTOR_TOKEN;\n+  req.length  = strlen(SL_WISUN_METER_REQUEST_TYPE_STR_ASYNC)\n\
    +                + 1U\n+                + sl_wisun_mc_get_token_size();\n+  req.buff\
    \    = (uint8_t *) SL_WISUN_METER_REQUEST_TYPE_STR_ASYNC \\\n+               \
    \ SL_WISUN_METER_REQUEST_DELIMITER                  \\\n+                SL_WISUN_METER_COLLECTOR_TOKEN;\n\
    \   sl_wisun_collector_set_async_measurement_request(&req);\n \n-  req.buff =\
    \ (uint8_t *) SL_WISUN_METER_REQUEST_TYPE_STR_REGISTER \\\n-             SL_WISUN_METER_REQUEST_DELIMITER\
    \                     \\\n-             SL_WISUN_METER_COLLECTOR_TOKEN;\n+  req.length\
    \  = strlen(SL_WISUN_METER_REQUEST_TYPE_STR_REGISTER)\n+                + 1U\n\
    +                + sl_wisun_mc_get_token_size();\n+  req.buff    = (uint8_t *)\
    \ SL_WISUN_METER_REQUEST_TYPE_STR_REGISTER \\\n+                SL_WISUN_METER_REQUEST_DELIMITER\
    \                     \\\n+                SL_WISUN_METER_COLLECTOR_TOKEN;\n \
    \  sl_wisun_collector_set_registration_request(&req);\n \n-  req.buff = (uint8_t\
    \ *) SL_WISUN_METER_REQUEST_TYPE_STR_REMOVE \\\n-             SL_WISUN_METER_REQUEST_DELIMITER\
    \                   \\\n-             SL_WISUN_METER_COLLECTOR_TOKEN;\n+  req.length\
    \  = strlen(SL_WISUN_METER_REQUEST_TYPE_STR_REMOVE)\n+                + 1U\n+\
    \                + sl_wisun_mc_get_token_size();\n+  req.buff    = (uint8_t *)\
    \ SL_WISUN_METER_REQUEST_TYPE_STR_REMOVE \\\n+                SL_WISUN_METER_REQUEST_DELIMITER\
    \                   \\\n+                SL_WISUN_METER_COLLECTOR_TOKEN;\n   sl_wisun_collector_set_removal_request(&req);\n\
    \ }\n \n@@ -485,7 +490,7 @@ static void _create_common_socket(void)\n   static\
    \ sockaddr_in6_t collector_addr  = { 0 };\n   int32_t res                    \
    \     = SOCKET_INVALID_ID;\n \n-  _common_socket = socket(AF_INET6, (SOCK_DGRAM\
    \ | SOCK_NONBLOCK), IPPROTO_UDP);\n+  _common_socket = socket(AF_INET6, SOCK_DGRAM\
    \ | SOCK_NONBLOCK, IPPROTO_UDP);\n   assert(_common_socket != SOCKET_INVALID_ID);\n\
    \ \n   collector_addr.sin6_family = AF_INET6;\n@@ -631,7 +636,7 @@ static void\
    \ _collector_recv_thread_fnc(void *args)\n   _create_common_socket();\n \n   SL_WISUN_THREAD_LOOP\
    \ {\n-    if (!app_wisun_network_is_connected()) {\n+    if (!sl_wisun_app_core_util_network_is_connected())\
    \ {\n       osDelay(1000);\n       continue;\n     }\n@@ -646,7 +651,7 @@ static\
    \ void _collector_recv_thread_fnc(void *args)\n                              \
    \      &packet_data_len);\n \n     if (res != SL_STATUS_OK) {\n-      app_wisun_dispatch_thread();\n\
    +      sl_wisun_app_core_util_dispatch_thread();\n       continue;\n     }\n \n\
    @@ -655,7 +660,7 @@ static void _collector_recv_thread_fnc(void *args)\n     \
    \                             &remote_addr);\n \n     if (meter == NULL) {\n-\
    \      app_wisun_dispatch_thread();\n+      sl_wisun_app_core_util_dispatch_thread();\n\
    \       continue;\n     }\n \n@@ -666,7 +671,7 @@ static void _collector_recv_thread_fnc(void\
    \ *args)\n       printf(\"[Response time: %ldms]\\n\", response_time_ms);\n  \
    \     sl_mempool_free(&_async_meters_mempool, meter);\n     }\n-    app_wisun_dispatch_thread();\n\
    +    sl_wisun_app_core_util_dispatch_thread();\n   }\n }\n "
  - "--- a/app/wisun/component/meter_collector_common/sl_wisun_meter.c\n+++ b/app/wisun/component/meter_collector_common/sl_wisun_meter.c\n\
    @@ -59,25 +59,26 @@\n #define SL_WISUN_LFN_WAKE_UP_EVT_MSK                   \
    \                 0x0001U\n \n /// Macro for dispatching the thread if the given\
    \ result is not SL_STATUS_OK\n-#define sl_wisun_check_result_and_dispatch_if_nok(__res,\
    \ __socket, __storage) \\\n-  if (__res != SL_STATUS_OK) {                   \
    \                             \\\n-    sl_wisun_meter_error_handler(__res, __socket,\
    \ __storage);                 \\\n-    app_wisun_dispatch_thread();          \
    \                                    \\\n-    continue;                      \
    \                                           \\\n-  }\n+#if defined(SL_CATALOG_WISUN_LFN_DEVICE_SUPPORT_PRESENT)\n\
    +#define sl_wisun_check_result_and_dispatch_if_nok(__res, __socket, __storage)\
    \   \\\n+  if (__res != SL_STATUS_OK) {                                      \
    \            \\\n+    sl_wisun_meter_error_handler(__res, __socket, __storage);\
    \                   \\\n+    continue;                                       \
    \                            \\\n+  }                                        \
    \                                   \n+#else\n+#define sl_wisun_check_result_and_dispatch_if_nok(__res,\
    \ __socket, __storage)   \\\n+  if (__res != SL_STATUS_OK) {                 \
    \                                 \\\n+    sl_wisun_meter_error_handler(__res,\
    \ __socket, __storage);                   \\\n+    sl_wisun_app_core_util_dispatch_thread();\
    \                                   \\\n+    continue;                       \
    \                                            \\\n+  }                        \
    \                                                   \n+#endif\n \n // -----------------------------------------------------------------------------\n\
    \ //                          Static Function Declarations\n // -----------------------------------------------------------------------------\n\
    \ \n #if SL_WISUN_COAP_MC_OPTIMIZED_MODE_ENABLE\n-/**************************************************************************//**\n\
    - * @brief LFN Wake up meter event handler\n- * @details Custom callback implementation.\n\
    - *          It sets an OS status flag to notify meter task\n- * @param[in] evt\
    \ Event descriptor\n- *****************************************************************************/\n\
    -static void _wisun_lfn_wake_up_meter_hnd(sl_wisun_evt_t *evt);\n \n /**************************************************************************//**\n\
    \  * @brief Meter parse\n@@ -269,16 +270,8 @@ static sl_wisun_meter_packet_storage_t\
    \ _packet_storage  = {\n   .stored = 0U\n };\n \n-/// LFN wake up event flag\n\
    -static osEventFlagsId_t _lfn_wake_up_evt = NULL;\n+static uint8_t _lfn_evt_notify_ch\
    \ = 0UL;\n \n-/// LFN wake up event flag attributes\n-static const osEventFlagsAttr_t\
    \ _evt_attr = {\n-  .name      = \"LfnWakeUpEvt\",\n-  .attr_bits = 0,\n-  .cb_mem\
    \    = NULL,\n-  .cb_size   = 0\n-};\n #endif\n \n // -----------------------------------------------------------------------------\n\
    @@ -357,14 +350,10 @@ void sl_wisun_meter_init(void)\n #endif\n   sl_wisun_meter_init_common_resources(_meter_parse_request,\n\
    \                                        _meter_build_packets);\n-\n-  // Register\
    \ LFN wake up event callback for meter\n-  app_wisun_em_custom_callback_register(SL_WISUN_MSG_LFN_WAKE_UP_IND_ID,\n\
    -                                        _wisun_lfn_wake_up_meter_hnd);\n-  //\
    \ Create lfn wake up event flag\n #if defined(SL_CATALOG_WISUN_LFN_DEVICE_SUPPORT_PRESENT)\n\
    -  _lfn_wake_up_evt = osEventFlagsNew(&_evt_attr);\n-  assert(_lfn_wake_up_evt\
    \ != NULL);\n+  assert( app_wisun_em_subscribe_evt_notification(SL_WISUN_MSG_LFN_WAKE_UP_IND_ID,\
    \ &_lfn_evt_notify_ch) \n+          != SL_STATUS_FAIL);\n+\n #endif\n }\n \n@@\
    \ -501,8 +490,8 @@ void sl_wisun_meter_process(void)\n \n   // Get the device\
    \ schedule\n #if defined(SL_CATALOG_WISUN_LFN_DEVICE_SUPPORT_PRESENT)\n-  device_type\
    \ = app_wisun_get_device_type();\n-  lfn_params = app_wisun_get_lfn_params();\n\
    +  device_type = sl_wisun_app_core_get_device_type();\n+  lfn_params = sl_wisun_app_core_get_lfn_params();\n\
    \   if (lfn_params != NULL) {\n     schedule = lfn_params->data_layer.unicast_interval_ms;\n\
    \   } else {\n@@ -518,10 +507,7 @@ void sl_wisun_meter_process(void)\n   SL_WISUN_THREAD_LOOP\
    \ {\n #if defined(SL_CATALOG_WISUN_LFN_DEVICE_SUPPORT_PRESENT)\n     if (device_type\
    \ == SL_WISUN_LFN) {\n-      osEventFlagsWait(_lfn_wake_up_evt,\n-           \
    \            SL_WISUN_LFN_WAKE_UP_EVT_MSK,\n-                       osFlagsWaitAny,\n\
    -                       osWaitForever);\n+      app_wisun_em_wait_evt_notification(SL_WISUN_MSG_LFN_WAKE_UP_IND_ID,\
    \ _lfn_evt_notify_ch);\n     }\n #endif\n     // Read data from socket buffer\n\
    @@ -545,9 +531,9 @@ void sl_wisun_meter_process(void)\n     res = _sl_wisun_meter_sending_cycle();\n\
    \     sl_wisun_check_result_and_dispatch_if_nok(res, _common_socket, &_packet_storage);\n\
    \ \n-#if defined(SL_CATALOG_WISUN_LFN_DEVICE_SUPPORT_PRESENT)\n+#if !defined(SL_CATALOG_WISUN_LFN_DEVICE_SUPPORT_PRESENT)\n\
    \     // dispatch thread\n-    app_wisun_dispatch_thread();\n+    sl_wisun_app_core_util_dispatch_thread();\n\
    \ #endif\n   }\n }\n@@ -558,11 +544,6 @@ void sl_wisun_meter_process(void)\n //\
    \ -----------------------------------------------------------------------------\n\
    \ \n #if SL_WISUN_COAP_MC_OPTIMIZED_MODE_ENABLE\n-static void _wisun_lfn_wake_up_meter_hnd(sl_wisun_evt_t\
    \ *evt)\n-{\n-  (void) evt;\n-  (void) osEventFlagsSet(_lfn_wake_up_evt, SL_WISUN_LFN_WAKE_UP_EVT_MSK);\n\
    -}\n \n static sl_status_t _meter_parse_request(const void * const raw,\n    \
    \                                     int32_t packet_data_len,\n@@ -692,7 +673,7\
    \ @@ static void _create_common_socket(void)\n   static sockaddr_in6_t meter_addr\
    \  = { 0 };\n   int32_t res                       = SOCKET_INVALID_ID;\n \n- \
    \ _common_socket = socket(AF_INET6, (SOCK_DGRAM | SOCK_NONBLOCK), IPPROTO_UDP);\n\
    +  _common_socket = socket(AF_INET6, SOCK_DGRAM | SOCK_NONBLOCK, IPPROTO_UDP);\n\
    \   assert(_common_socket != SOCKET_INVALID_ID);\n \n   meter_addr.sin6_family\
    \  = AF_INET6;"
  - "--- a/app/wisun/component/meter_collector_common/sli_wisun_meter_collector.c\n\
    +++ b/app/wisun/component/meter_collector_common/sli_wisun_meter_collector.c\n\
    @@ -41,6 +41,7 @@\n #include \"sl_wisun_meter_collector_config.h\"\n #include\
    \ \"sl_wisun_app_core_util.h\"\n #include \"sl_sleeptimer.h\"\n+#include \"sl_wisun_trace_util.h\"\
    \n \n // -----------------------------------------------------------------------------\n\
    \ //                              Macros and Typedefs"
  - "--- a/app/wisun/component/network_measurement/sl_wisun_network_measurement.c\n\
    +++ b/app/wisun/component/network_measurement/sl_wisun_network_measurement.c\n\
    @@ -43,9 +43,11 @@\n #include \"sl_wisun_ping_config.h\"\n #include \"cmsis_os2.h\"\
    \n #include \"socket/socket.h\"\n+#include \"sl_wisun_trace_util.h\"\n \n #if\
    \ defined(SL_CATALOG_GUI_PRESENT)\n #include \"sl_wisun_network_measurement_gui.h\"\
    \n+#include \"sli_wisun_network_measurement_ping_gui.h\"\n #include \"sl_display.h\"\
    \n #include \"sl_gui.h\"\n #endif"
  - "--- a/app/wisun/component/network_measurement/sl_wisun_network_measurement_gui.c\n\
    +++ b/app/wisun/component/network_measurement/sl_wisun_network_measurement_gui.c\n\
    @@ -48,6 +48,7 @@\n #include \"sl_wisun_network_measurement_config.h\"\n #include\
    \ \"sl_display.h\"\n #include \"sl_gui.h\"\n+#include \"sl_string.h\"\n #include\
    \ \"socket/socket.h\"\n #include \"sl_wisun_ping.h\"\n #include \"silabs_wisun_logo.h\"\
    \n@@ -56,6 +57,9 @@\n //                              Macros and Typedefs\n //\
    \ -----------------------------------------------------------------------------\n\
    \ \n+// LCD 1 line string length\n+#define LCD_STRING_LINE_LEN             (21)\n\
    +\n /// Internal string buffer size\n #define STR_BUFF_SIZE                  \
    \ (512U)\n \n@@ -170,7 +174,7 @@ typedef struct sl_wisun_nwm_setting {\n /// Node\
    \ info structure type definition\n typedef struct node_info {\n   /// Addresses\n\
    -  current_addr_t addresses;\n+  sl_wisun_app_core_current_addr_t addresses;\n\
    \   /// Settings\n   app_setting_wisun_t settings;\n } node_info_t;\n@@ -222,15\
    \ +226,25 @@ static sl_wisun_nwm_node_stat_t _children_stat[SL_WISUN_MAX_CHILDREN_COUNT];\n\
    \ void sli_wisun_nwm_logo_form(void *args)\n {\n   sl_wisun_nwm_logo_form_args_t\
    \ *logo_form_args = (sl_wisun_nwm_logo_form_args_t *)args;\n-  static char buff[4U]\
    \ = { 0 };\n+  static char buff[LCD_STRING_LINE_LEN] = { 0 };\n+  uint32_t str_len\
    \ = 0UL;\n \n   sl_display_draw_bitmap(0, 0,\n                          SILABS_WISUN_LOGO_WIDTH,\n\
    \                          SILABS_WISUN_LOGO_HEIGHT,\n                       \
    \   silabs_wisun_logo_bits);\n-  sl_display_draw_string_on_line(logo_form_args->network_name,\
    \ 2, GLIB_ALIGN_CENTER, 0, 0, false);\n+\n+  str_len = sl_strnlen((char *)logo_form_args->network_name,\
    \ 32UL);\n+  snprintf(buff, LCD_STRING_LINE_LEN,\"%s\", logo_form_args->network_name);\n\
    +  sl_display_draw_string_on_line(buff, 2, GLIB_ALIGN_CENTER, 0, 0, false);\n\
    +\n+  if (str_len > LCD_STRING_LINE_LEN - 1) {\n+    snprintf(buff, LCD_STRING_LINE_LEN,\"\
    %s\", logo_form_args->network_name + LCD_STRING_LINE_LEN - 1);\n+    sl_display_draw_string_on_line(buff,\
    \ 3, GLIB_ALIGN_LEFT, 3, 0, false);\n+  }\n+\n   sl_display_draw_string_on_line(logo_form_args->join_state_str,\
    \ 10, GLIB_ALIGN_CENTER, 0, 0, false);\n-  snprintf(buff, 4U, \"(%ld)\", logo_form_args->join_state);\n\
    +  snprintf(buff, LCD_STRING_LINE_LEN, \"(%ld)\", logo_form_args->join_state);\n\
    \   sl_display_draw_string_on_line(buff, 11, GLIB_ALIGN_CENTER, 0, 0, false);\n\
    \ }\n \n@@ -360,8 +374,8 @@ static void _node_info_form(void *args)\n   const\
    \ char *ip_str_br        = NULL;\n   const char *ip_str_pp        = NULL;\n  \
    \ const char *ip_str_sp        = NULL;\n-  uint32_t tx_remaining_budget = 0UL;\
    \ // Hold the remaning TX budget if applicable\n-  bool valid                \
    \   = false; // Indicates if the remaining budget returned is a usable value.\n\
    +  uint32_t tx_remaining_budget = 0UL;            // Hold the remaning TX budget\
    \ if applicable\n+  sl_status_t valid            = SL_STATUS_FAIL; // Indicates\
    \ if the remaining budget returned is a usable value.\n \n   (void) args;\n \n\
    @@ -377,14 +391,14 @@ static void _node_info_form(void *args)\n   sl_gui_button_update(SL_GUI_BUTTON0);\n\
    \ \n   // getting IP addresses\n-  app_wisun_get_current_addresses(&node_info.addresses);\n\
    +  sl_wisun_app_core_get_current_addresses(&node_info.addresses);\n \n   // getting\
    \ settings\n   app_wisun_setting_get(&node_info.settings);\n \n   // get remanining\
    \ transmission budget if applicable\n-  if ( app_wisun_get_regulation_active()\
    \ == true ) {\n-    valid = app_wisun_get_remaining_tx_budget(&tx_remaining_budget);\n\
    +  if ( sl_wisun_app_core_get_regulation_active() == true ) {\n+    valid = sl_wisun_app_core_get_remaining_tx_budget(&tx_remaining_budget);\n\
    \   }\n \n   ip_str_global = app_wisun_trace_util_get_ip_str(&node_info.addresses.global);\n\
    @@ -408,8 +422,8 @@ static void _node_info_form(void *args)\n              ip_str_br,\n\
    \              ip_str_pp,\n              ip_str_sp,\n-             (valid ? tx_remaining_budget\
    \ : 0UL),\n-             (valid ? _tx_remaining_budget(tx_remaining_budget) :\
    \ TX_REMAINING_NOT_AVAILABLE_STR));\n+             (valid == SL_STATUS_OK ? tx_remaining_budget\
    \ : 0UL),\n+             (valid == SL_STATUS_OK ? _tx_remaining_budget(tx_remaining_budget)\
    \ : TX_REMAINING_NOT_AVAILABLE_STR));\n   } else if (node_info.settings.phy.type\
    \ == SL_WISUN_PHY_CONFIG_FAN11) {\n     snprintf(_str_buff, STR_BUFF_SIZE,\n \
    \             PRINT_FAN11_NODE_INFO_FORMAT_STR,\n@@ -426,8 +440,8 @@ static void\
    \ _node_info_form(void *args)\n              ip_str_br,\n              ip_str_pp,\n\
    \              ip_str_sp,\n-             (valid ? tx_remaining_budget : 0UL),\n\
    -             (valid ? _tx_remaining_budget(tx_remaining_budget) : TX_REMAINING_NOT_AVAILABLE_STR));\n\
    +             (valid == SL_STATUS_OK ? tx_remaining_budget : 0UL),\n+        \
    \     (valid == SL_STATUS_OK ? _tx_remaining_budget(tx_remaining_budget) : TX_REMAINING_NOT_AVAILABLE_STR));\n\
    \   } else {\n     snprintf(_str_buff, STR_BUFF_SIZE, \"Wrong phy profile: %lu\"\
    , node_info.settings.phy.type);\n   }\n@@ -443,6 +457,9 @@ static void _node_info_form(void\
    \ *args)\n \n static void _set_nbinfo_txtbox(void *args)\n {\n+  if (args == NULL)\
    \ {\n+    return;\n+  }\n   sl_wisun_nwm_node_stat_t *stat = (sl_wisun_nwm_node_stat_t\
    \ *) args;\n   const char *ip_str             = NULL;\n "
  - "--- a/app/wisun/component/network_measurement/sl_wisun_network_measurement_remote_ctrl.c\n\
    +++ b/app/wisun/component/network_measurement/sl_wisun_network_measurement_remote_ctrl.c\n\
    @@ -57,13 +57,17 @@\n // -----------------------------------------------------------------------------\n\
    \ \n /// Network Measurement Remote Control buffer size\n-#define SL_WISUN_NWM_REMOTE_CTRL_BUFF_SIZE\
    \                     2048UL\n+#define SL_WISUN_NWM_REMOTE_CTRL_BUFF_SIZE    \
    \             2048UL\n \n /// Remote CLI measurement max query length\n-#define\
    \ SL_WISUN_COAP_NWM_REMOTE_CLI_MAX_QUERY_LENGTH          (SL_WISUN_NWM_REMOTE_CTRL_BUFF_SIZE)\n\
    +#define SL_WISUN_NWM_REMOTE_CTRL_MAX_QUERY_LENGTH          (SL_WISUN_NWM_REMOTE_CTRL_BUFF_SIZE)\n\
    \ \n /// Remote CLI measurement max string length\n-#define SL_WISUN_COAP_NWM_REMOTE_CLI_MAX_ARG_STRING_LENGTH\
    \     128UL\n+#define SL_WISUN_NWM_REMOTE_CTRL_MAX_ARG_STRING_LENGTH     128UL\n\
    +\n+\n+/// Max stored neighbor count\n+#define SL_WISUN_NWM_REMOTE_CTRL_MAX_NB_COUNT\
    \              30UL\n \n /// Network Measurement Remote Control ping stat format\n\
    \ #define SL_WISUN_NWM_REMOTE_CTRL_PING_STAT_JSON_FORMAT \\\n@@ -91,35 +95,106\
    \ @@\n \\\"rsli\\\":%u\\\n },\\n\"\n \n-/// Network Measurement Remote Control\
    \ iperf help string\n-#define SL_WISUN_NWM_REMOTE_CTRL_IPERF_HELP_STRING \\\n\
    +/// Succeed str\n+#define SL_WISUN_NWM_REMOTE_CTRL_SUCCEED_STR              \
    \        \"succeed\"\n+/// Failed str\n+#define SL_WISUN_NWM_REMOTE_CTRL_FAILED_STR\
    \                       \"failed\"\n+/// Ping transaction result format str\n\
    +#define SL_WISUN_NWM_REMOTE_CTRL_PING_RESULT_FROMAT_STR           \"[COAP CLI\
    \ Ping transaction %s]\\n\"\n+/// iPerf transaction result format str\n+#define\
    \ SL_WISUN_NWM_REMOTE_CTRL_IPERF_RESULT_FROMAT_STR          \"[COAP CLI iPerf\
    \ transaction %s]\\n\"\n+/// Neighbor info transaction result format str\n+#define\
    \ SL_WISUN_NWM_REMOTE_CTRL_NBRINFO_RESULT_FROMAT_STR        \"[COAP CLI NeighborInfo\
    \ transaction %s]\\n\"\n+\n+/// Arg help str\n+#define SL_WISUN_NWM_REMOTE_CTRL_ARG_HELP_STR\
    \                     \"help\"\n+/// Arg all str\n+#define SL_WISUN_NWM_REMOTE_CTRL_ARG_ALL_NODE_STR\
    \                 \"all\"\n+/// Arg parent node str\n+#define SL_WISUN_NWM_REMOTE_CTRL_ARG_PARENT_NODE_STR\
    \              \"parent\"\n+/// Arg Br node str\n+#define SL_WISUN_NWM_REMOTE_CTRL_ARG_BR_NODE_STR\
    \                  \"br\"\n+/// Arg Custom node str\n+#define SL_WISUN_NWM_REMOTE_CTRL_ARG_CUSTOM_NODE_STR\
    \              \"Custom Node\"\n+/// Arg server str\n+#define SL_WISUN_NWM_REMOTE_CTRL_ARG_SERVER_STR\
    \                   \"server\"\n+/// Arg client str\n+#define SL_WISUN_NWM_REMOTE_CTRL_ARG_CLIENT_STR\
    \                   \"client\"\n+/// Arg get str\n+#define SL_WISUN_NWM_REMOTE_CTRL_ARG_GET_STR\
    \                      \"get\"\n+/// Arg json str\n+#define SL_WISUN_NWM_REMOTE_CTRL_ARG_JSON_STR\
    \                     \"json\"\n+/// Arg text str\n+#define SL_WISUN_NWM_REMOTE_CTRL_ARG_TEXT_STR\
    \                     \"text\"\n+/// Arg set str\n+#define SL_WISUN_NWM_REMOTE_CTRL_ARG_SET_STR\
    \                      \"set\"\n+/// Arg options bandwidth str\n+#define SL_WISUN_NWM_REMOTE_CTRL_ARG_OPTIONS_BW_STR\
    \               \"options.bandwidth\"\n+/// Arg options remote addr str\n+#define\
    \ SL_WISUN_NWM_REMOTE_CTRL_ARG_OPTIONS_REMOTE_ADDR_STR      \"options.remote_addr\"\
    \n+/// Arg options duration str\n+#define SL_WISUN_NWM_REMOTE_CTRL_ARG_OPTIONS_DURATION_STR\
    \         \"options.duration\"\n+/// Arg options interval str\n+#define SL_WISUN_NWM_REMOTE_CTRL_ARG_OPTIONS_INTERVAL_STR\
    \         \"options.interval\"\n+\n+/// Response no coap payload str\n+#define\
    \ SL_WISUN_NWM_REMOTE_CTRL_RESP_NO_COAP_PAYLOAD_STR         \"[No CoAP payload:\
    \ -e \\\"<cli command>\\\"]\"\n+/// Response not enough argument str\n+#define\
    \ SL_WISUN_NWM_REMOTE_CTRL_RESP_NOT_ENOUGH_ARG_STR          \"[Not enough argument]\"\
    \n+/// Response ping help str\n+#define SL_WISUN_NWM_REMOTE_CTRL_RESP_PING_HELP_STR\
    \               \"[Ping CLI help: measure <packet_count> <packet_size> <address>]\"\
    \n+/// Response IP not valid str\n+#define SL_WISUN_NWM_REMOTE_CTRL_RESP_IP_NOT_VALID_STR\
    \            \"[IP address is not set or not valid]\"\n+/// Response invalid result\
    \ type str\n+#define SL_WISUN_NWM_REMOTE_CTRL_RESP_INVALID_RES_TYPE_STR      \
    \  \"[Invalid result type]\"\n+/// Response buffer error str\n+#define SL_WISUN_NWM_REMOTE_CTRL_RESP_BUFF_ERROR_STR\
    \              \"[Buffer error]\"\n+/// Response unknown cli command str\n+#define\
    \ SL_WISUN_NWM_REMOTE_CTRL_RESP_UNKNOWN_CLI_STR             \"[Unknown cli command]\"\
    \n+/// Response test queue failed str\n+#define SL_WISUN_NWM_REMOTE_CTRL_RESP_TEST_QUEUE_FAILED_STR\
    \       \"[Adding test to queue failed]\"\n+/// Response iPerf server started\
    \ str\n+#define SL_WISUN_NWM_REMOTE_CTRL_RESP_IPERF_SRV_STARTED           \"[iPerf\
    \ server started]\"\n+/// Response iPerf client started str\n+#define SL_WISUN_NWM_REMOTE_CTRL_RESP_IPERF_CLNT_STARTED\
    \          \"[iPerf client started]\"\n+/// Response iPerf set successfully str\n\
    +#define SL_WISUN_NWM_REMOTE_CTRL_RESP_IPERF_SET_SUCCEED           \"[iPerf parameter\
    \ is set succesfully]\"\n+/// Response iPerf set failed str\n+#define SL_WISUN_NWM_REMOTE_CTRL_RESP_IPERF_SET_FAILED\
    \            \"[iPerf parameter setting is failed]\"\n+/// Response iperf help\
    \ str\n+#define SL_WISUN_NWM_REMOTE_CTRL_RESP_IPERF_HELP_STR \\\n   \"\\niPerf\
    \ Remote Control CLI Help.\\n\\n\\\n   Writable options:\\n\\\n-    -options.remote_addr\\\
    n\\\n-    -options.bandwidth\\n\\\n-    -options.duration\\n\\\n-    -options.interval\\\
    n\\\n+    - remote_addr\\n\\\n+    - bandwidth\\n\\\n+    - duration\\n\\\n+ \
    \   - interval\\n\\\n   Example: iperf set options.bandwidth 10000\\n\\n\\\n-\
    \  Start iPerf command: iperf <client|server>\\n\"\n+  Start iPerf command: iperf\
    \ <client|server>\\n\\n\\\n+  Get iPerf results: iperf get <text|json>\\n\"\n\
    \ \n /// Remote CLI measurement print target type\n-typedef enum buffer_target_type\
    \ {\n+typedef enum sl_wisun_nwm_remote_ctrl_buf_target {\n   /// Nothing measurement\n\
    -  BUFFER_TYPE_NONE = -1,\n+  SL_WISUN_NWM_REMOTE_CTRL_BUF_TARGET_NONE = -1,\n\
    \   /// Only Border Router measurement\n-  BUFFER_TYPE_BORDER_ROUTER,\n+  SL_WISUN_NWM_REMOTE_CTRL_BUF_TARGET_BORDER_ROUTER,\n\
    \   /// Only Primary Parent measurement\n-  BUFFER_TYPE_PARENT,\n+  SL_WISUN_NWM_REMOTE_CTRL_BUF_TARGET_PARENT,\n\
    \   /// Measure all of available nodes\n-  BUFFER_TYPE_ALL,\n+  SL_WISUN_NWM_REMOTE_CTRL_BUF_TARGET_ALL,\n\
    \   /// Measure single node\n-  BUFFER_TYPE_SINGLE,\n-  // Measure iPerf\n-  BUFFER_TYPE_IPERF\n\
    -} buffer_target_type_t;\n-\n-// Remote CLI measurement command structure\n-typedef\
    \ struct ctrl_cmd_type {\n+  SL_WISUN_NWM_REMOTE_CTRL_BUF_TARGET_SINGLE,\n+  //\
    \ Measurement iPerf json format\n+  SL_WISUN_NWM_REMOTE_CTRL_BUF_TARGET_IPERF_JSON,\n\
    +  // Measurement iPerf text format\n+  SL_WISUN_NWM_REMOTE_CTRL_BUF_TARGET_IPERF_TEXT,\n\
    +  // Neighbor info buff type\n+  SL_WISUN_NWM_REMOTE_CTRL_BUF_TARGET_NBINF\n\
    +} sl_wisun_nwm_remote_ctrl_buf_target_t;\n+\n+/// Remote CLI measurement command\
    \ structure\n+typedef struct sl_wisun_nwm_remote_ctrl_cmd {\n   /// Nothing measurement\n\
    \   char* identifier;\n   /// Argument1 string\n@@ -128,7 +203,85 @@ typedef struct\
    \ ctrl_cmd_type {\n   char* arg2;\n   /// Argument3 string\n   char* arg3;\n-}\
    \ ctrl_cmd_type_t;\n+} sl_wisun_nwm_remote_ctrl_cmd_t;\n+\n+/// Remote CLI response\n\
    +typedef struct sl_wisun_nwm_remote_ctrl_resp {\n+  /// message code\n+  sn_coap_msg_code_e\
    \ msg_code;\n+  /// payload constant str ptr\n+  const char *payload;\n+} sl_wisun_nwm_remote_ctrl_resp_t;\n\
    +\n+/// Response no coap payload\n+static const sl_wisun_nwm_remote_ctrl_resp_t\
    \ _resp_no_coap_payload = {\n+  .payload = SL_WISUN_NWM_REMOTE_CTRL_RESP_NO_COAP_PAYLOAD_STR,\
    \ \n+  .msg_code= COAP_MSG_CODE_RESPONSE_NOT_ACCEPTABLE\n+};\n+/// Response not\
    \ enough argument\n+static const sl_wisun_nwm_remote_ctrl_resp_t _resp_not_enough_arg\
    \ = {\n+  .payload = SL_WISUN_NWM_REMOTE_CTRL_RESP_NOT_ENOUGH_ARG_STR, \n+  .msg_code=\
    \ COAP_MSG_CODE_RESPONSE_NOT_ACCEPTABLE\n+};\n+/// Response ping help\n+static\
    \ const sl_wisun_nwm_remote_ctrl_resp_t _resp_ping_help = {\n+  .payload = SL_WISUN_NWM_REMOTE_CTRL_RESP_PING_HELP_STR,\n\
    +  .msg_code= COAP_MSG_CODE_RESPONSE_CONTENT\n+};\n+/// Response IP not valid\n\
    +static const sl_wisun_nwm_remote_ctrl_resp_t _resp_ip_not_valid = {\n+  .payload\
    \ = SL_WISUN_NWM_REMOTE_CTRL_RESP_IP_NOT_VALID_STR,\n+  .msg_code= COAP_MSG_CODE_RESPONSE_NOT_ACCEPTABLE\n\
    +};\n+/// Response invalid result type\n+static const sl_wisun_nwm_remote_ctrl_resp_t\
    \ _resp_invalid_res_type = {\n+  .payload = SL_WISUN_NWM_REMOTE_CTRL_RESP_INVALID_RES_TYPE_STR,\n\
    +  .msg_code= COAP_MSG_CODE_RESPONSE_NOT_ACCEPTABLE\n+};\n+/// Response buffer\
    \ error\n+static const sl_wisun_nwm_remote_ctrl_resp_t _resp_buff_error = {\n\
    +  .payload = SL_WISUN_NWM_REMOTE_CTRL_RESP_BUFF_ERROR_STR,\n+  .msg_code= COAP_MSG_CODE_RESPONSE_NOT_ACCEPTABLE\n\
    +};\n+/// Response unknown cli command\n+static const sl_wisun_nwm_remote_ctrl_resp_t\
    \ _resp_unknown_cli = {\n+  .payload = SL_WISUN_NWM_REMOTE_CTRL_RESP_UNKNOWN_CLI_STR,\n\
    +  .msg_code= COAP_MSG_CODE_RESPONSE_NOT_ACCEPTABLE\n+};\n+/// Response test queue\
    \ faled\n+static const sl_wisun_nwm_remote_ctrl_resp_t _resp_test_queue_failed\
    \ = {\n+  .payload = SL_WISUN_NWM_REMOTE_CTRL_RESP_TEST_QUEUE_FAILED_STR,\n+ \
    \ .msg_code= COAP_MSG_CODE_RESPONSE_NOT_ACCEPTABLE\n+};\n+/// Response iPerf server\
    \ started\n+static const sl_wisun_nwm_remote_ctrl_resp_t _resp_iperf_srv_started\
    \ = {\n+  .payload = SL_WISUN_NWM_REMOTE_CTRL_RESP_IPERF_SRV_STARTED,\n+  .msg_code=\
    \ COAP_MSG_CODE_RESPONSE_CONTENT\n+};\n+/// Response iPerf client started\n+static\
    \ const sl_wisun_nwm_remote_ctrl_resp_t _resp_iperf_clnt_started = {\n+  .payload\
    \ = SL_WISUN_NWM_REMOTE_CTRL_RESP_IPERF_CLNT_STARTED,\n+  .msg_code= COAP_MSG_CODE_RESPONSE_CONTENT\n\
    +};\n+\n+/// Response iPerf set successfully\n+static const sl_wisun_nwm_remote_ctrl_resp_t\
    \ _resp_iperf_set_succeed = {\n+  .payload = SL_WISUN_NWM_REMOTE_CTRL_RESP_IPERF_SET_SUCCEED,\n\
    +  .msg_code= COAP_MSG_CODE_RESPONSE_CHANGED\n+};\n+\n+/// Response iPerf set\
    \ failed\n+static const sl_wisun_nwm_remote_ctrl_resp_t _resp_iperf_set_failed\
    \ = {\n+  .payload = SL_WISUN_NWM_REMOTE_CTRL_RESP_IPERF_SET_FAILED,\n+  .msg_code=\
    \ COAP_MSG_CODE_RESPONSE_NOT_ACCEPTABLE\n+};\n+\n+/// Response iperf help\n+static\
    \ const sl_wisun_nwm_remote_ctrl_resp_t _resp_iperf_help = {\n+  .payload = SL_WISUN_NWM_REMOTE_CTRL_RESP_IPERF_HELP_STR,\n\
    +  .msg_code= COAP_MSG_CODE_RESPONSE_CONTENT\n+};\n+\n // -----------------------------------------------------------------------------\n\
    \ //                          Static Function Declarations\n // -----------------------------------------------------------------------------\n\
    @@ -142,48 +295,86 @@ typedef struct ctrl_cmd_type {\n  * @return Payload buffer\
    \ position after print.\n  *****************************************************************************/\n\
    \ static void _parse_stat_to_json(char **payload_pos,\n-                     \
    \           sl_wisun_nwm_node_stat_t *stat,\n-                               \
    \ int16_t *payload_len);\n+                                const sl_wisun_nwm_node_stat_t\
    \ * const stat,\n+                                uint16_t * const payload_len);\n\
    \ \n /**************************************************************************//**\n\
    - * @brief Build and send CoAP response packet.\n- * @details Build and send CoAP\
    \ response packet.\n- * @param[in] sockid Socket id.\n- * @param[in] clnt_addr\
    \ Client address.\n- * @param[in,out] packet CoAP packet.\n- * @param[in] target\
    \ Measurement print target.\n- * @return SL_STATUS_OK on success, otherwise an\
    \ error code.\n+ * @brief Build payload and CoAP packet\n+ * @details Helper function\n\
    + * @param[in] req_packet Request packet\n+ * @param[in] target Measurement print\
    \ target\n+ * @return sl_wisun_coap_packet_t * Built CoAP packet on success, otherwise\
    \ NULL\n+ *****************************************************************************/\n\
    +static sl_wisun_coap_packet_t *  _build_response(const sl_wisun_coap_packet_t\
    \ * const req_packet,\n+                                                 const\
    \ sl_wisun_nwm_remote_ctrl_buf_target_t target);\n+\n+\n+/**************************************************************************//**\n\
    + * @brief Build iPerf result in json and plain text format\n+ * @details Helper\
    \ function\n+ * @param[in] target Measurement print target\n+ * @param[in,out]\
    \ payload_buff Payload buffer pointer\n+ * @return char * Payload for CoAP packet\
    \ on success, otherwise NULL\n+ *****************************************************************************/\n\
    +static char * _build_iperf_result(const sl_wisun_nwm_remote_ctrl_buf_target_t\
    \ target,\n+                                  char * const payload_buff);\n+\n\
    +/**************************************************************************//**\n\
    + * @brief Build neighbor info string\n+ * @details Helper function\n+ * @param[in,out]\
    \ payload_buff Payload buffer pointer\n+ * @param[in,out] nodes Node storage ptr\n\
    + * @param[in,out] br_stat Border router statistic ptr\n+ * @param[in,out] pp_stat\
    \ Primary parent statistic ptr\n+ * @param[in,out] children_stats Children statistic\
    \ array\n+ * @return char * Payload for CoAP packet on success, otherwise NULL\n\
    + *****************************************************************************/\n\
    +static char * _build_nbr_info(char * const payload_buff,\n+                 \
    \             sl_wisun_nwm_measurable_node_t * const nodes,\n+               \
    \               sl_wisun_nwm_node_stat_t * const br_stat,\n+                 \
    \             sl_wisun_nwm_node_stat_t * const pp_stat,\n+                   \
    \           sl_wisun_nwm_node_stat_t * const children_stats);\n+\n+/**************************************************************************//**\n\
    + * @brief Build neighbor info string\n+ * @details Helper function\n+ * @param[in]\
    \ target Measurement print target\n+ * @param[in,out] payload_buff Payload buffer\
    \ pointer\n+ * @param[in,out] br_stat Border router statistic ptr\n+ * @param[in,out]\
    \ pp_stat Primary parent statistic ptr\n+ * @param[in,out] children_stats Children\
    \ statistic array\n+ * @return char * Payload for CoAP packet on success, otherwise\
    \ NULL\n  *****************************************************************************/\n\
    -static sl_wisun_coap_packet_t *  _build_send_output(const sl_wisun_coap_packet_t\
    \ * const req_packet,\n-                                                    buffer_target_type_t\
    \ target);\n+static char * _build_ping_meas_stat(const sl_wisun_nwm_remote_ctrl_buf_target_t\
    \ target,\n+                                    char * const payload_buff,\n+\
    \                                    sl_wisun_nwm_node_stat_t * const br_stat,\n\
    +                                    sl_wisun_nwm_node_stat_t * const pp_stat,\n\
    +                                    sl_wisun_nwm_node_stat_t * const children_stats);\n\
    \ \n /**************************************************************************//**\n\
    \  * @brief Build payload for CoAP response packet.\n  * @details Build payload\
    \ for CoAP response packet.\n- * @param[in, out] payload_len CoAP packet payload\
    \ length.\n  * @param[in] target Measurement print target.\n- * @return SL_STATUS_OK\
    \ on success, otherwise an error code.\n+ * @return char * built payload on success,\
    \ otherwise NULL\n  *****************************************************************************/\n\
    -static sl_status_t _build_payload(buffer_target_type_t target);\n+static char\
    \ * _build_payload(sl_wisun_nwm_remote_ctrl_buf_target_t target);\n \n /**************************************************************************//**\n\
    - * @brief Send CoAP response packet.\n- * @details Send CoAP response packet.\n\
    - * @param[in] sockid Socket id.\n- * @param[in] clnt_addr Client address.\n-\
    \ * @param[in] payload_len CoAP packet payload length.\n- * @param[in,out] _buff\
    \ CoAP packet.\n+ * @brief Build response packet from response instance\n+ * @details\
    \ Build response with response builder API based on the request packet, and set\
    \ payload if it's exist\n+ * @param[in] resp Response instance\n+ * @param[in]\
    \ req_packet Request packet\n  * @return sl_wisun_coap_packet_t * Response packet\
    \ ptr\n  *****************************************************************************/\n\
    -static sl_wisun_coap_packet_t * _build_response_packet(char* payload,\n+static\
    \ sl_wisun_coap_packet_t * _build_response_packet(const sl_wisun_nwm_remote_ctrl_resp_t\
    \ * const resp,\n                                                        const\
    \ sl_wisun_coap_packet_t * const req_packet);\n \n /**************************************************************************//**\n\
    \  * @brief Network Measurement custom stat handler.\n  * @details Catch stat\
    \ object after measurement and copy to local variable.\n  * @param[in] stat Statistic\
    \ result after a ping measurement.\n  *****************************************************************************/\n\
    -static void _sl_wisun_nwm_remote_ctrl_stat_handler(sl_wisun_ping_stat_t *stat);\n\
    +static void _stat_handler(sl_wisun_ping_stat_t *stat);\n \n /**************************************************************************//**\n\
    \  * @brief CoAP remote CLI ping request parser.\n@@ -208,7 +399,7 @@ static sl_wisun_coap_packet_t\
    \ * _parse_iperf(const sl_wisun_coap_packet_t * cons\n  * @param[in, out] cmd\
    \ Command structure.\n  *****************************************************************************/\n\
    \ static void _parse_remote_cmd(char* req_cmd,\n-                            \
    \  ctrl_cmd_type_t* cmd);\n+                              sl_wisun_nwm_remote_ctrl_cmd_t*\
    \ cmd);\n \n /**************************************************************************//**\n\
    \  * @brief iPerf server handler.\n@@ -226,13 +417,6 @@ static sl_wisun_coap_packet_t\
    \ * _start_iperf_server(const sl_wisun_coap_packet_t\n  *****************************************************************************/\n\
    \ static sl_wisun_coap_packet_t * _start_iperf_client(const sl_wisun_coap_packet_t\
    \ * const req_packet);\n \n-/**************************************************************************//**\n\
    - * @brief Neighbour info handler.\n- * @details Get Neighbour info.\n- * @param[in]\
    \ req_packet Request packet.\n- * @return sl_wisun_coap_packet_t * Response packet\
    \ ptr\n- *****************************************************************************/\n\
    -static sl_wisun_coap_packet_t * _get_nbr(const sl_wisun_coap_packet_t * const\
    \ req_packet);\n \n /**************************************************************************//**\n\
    \  * @brief Parse neighbor statistic to json format\n@@ -281,199 +465,187 @@ static\
    \ sl_wisun_nwm_node_stat_t _stat;\n /// Network Measurement Remote Control iPerf\
    \ last test result\n static sl_iperf_test_t _last_test = { 0U };\n \n-/// Router\
    \ storage\n-static sl_wisun_nwm_measurable_node_t _nodes[SL_WISUN_MAX_NODE_COUNT];\n\
    -\n-/// Stat childre storage\n-static sl_wisun_nwm_node_stat_t _children_stats[30U];\n\
    -\n-/// Stat border router storage\n-static sl_wisun_nwm_node_stat_t _br_stat;\n\
    -\n-/// Stat primary parent storage\n-static sl_wisun_nwm_node_stat_t _pp_stat;\n\
    -\n-/// Payload buffer\n-static char _payload_buff[SL_WISUN_NWM_REMOTE_CTRL_BUFF_SIZE]\
    \ = { 0 };\n-\n // -----------------------------------------------------------------------------\n\
    \ //                          Public Function Definitions\n // -----------------------------------------------------------------------------\n\
    \ \n+__STATIC_INLINE void _print_cb_result(const char * format_str, \n+      \
    \                                const sl_wisun_coap_packet_t * const resp_packet)\n\
    +{\n+   printf(format_str, resp_packet != NULL ? SL_WISUN_NWM_REMOTE_CTRL_SUCCEED_STR\
    \ : SL_WISUN_NWM_REMOTE_CTRL_FAILED_STR);\n+}\n+\n sl_wisun_coap_packet_t * sl_wisun_coap_remote_cli_ping_cb(const\
    \ sl_wisun_coap_packet_t * const req_packet)\n {\n   sl_wisun_coap_packet_t *\
    \ resp_packet = NULL;\n   resp_packet = _parse_ping(req_packet);\n-  printf(\"\
    [COAP CLI Ping transaction %s]\\n\", resp_packet != NULL ? \"succeed\" : \"failed\"\
    );\n+  _print_cb_result(SL_WISUN_NWM_REMOTE_CTRL_PING_RESULT_FROMAT_STR, resp_packet);\n\
    \   return resp_packet;\n }\n \n sl_wisun_coap_packet_t * sl_wisun_coap_remote_cli_iperf_cb(const\
    \ sl_wisun_coap_packet_t * const req_packet)\n {\n   sl_wisun_coap_packet_t *\
    \ resp_packet = NULL;\n   resp_packet = _parse_iperf(req_packet);\n-  printf(\"\
    [COAP CLI iPerf transaction %s]\\n\", resp_packet != NULL ? \"succeed\" : \"failed\"\
    );\n+  _print_cb_result(SL_WISUN_NWM_REMOTE_CTRL_IPERF_RESULT_FROMAT_STR, resp_packet);\n\
    \   return resp_packet;\n }\n \n sl_wisun_coap_packet_t * sl_wisun_coap_remote_cli_nbr_cb(const\
    \ sl_wisun_coap_packet_t * const req_packet)\n {\n   sl_wisun_coap_packet_t *\
    \ resp_packet = NULL;\n-  resp_packet = _get_nbr(req_packet);\n-  printf(\"[COAP\
    \ CLI NeighborInfo transaction %s]\\n\", resp_packet != NULL ? \"succeed\" : \"\
    failed\");\n+  resp_packet = _build_response(req_packet, SL_WISUN_NWM_REMOTE_CTRL_BUF_TARGET_NBINF);\n\
    +  _print_cb_result(SL_WISUN_NWM_REMOTE_CTRL_NBRINFO_RESULT_FROMAT_STR, resp_packet);\n\
    \   return resp_packet;\n }\n \n // -----------------------------------------------------------------------------\n\
    \ //                          Static Function Definitions\n // -----------------------------------------------------------------------------\n\
    \ \n-static sl_wisun_coap_packet_t * _get_nbr(const sl_wisun_coap_packet_t * const\
    \ req_packet)\n-{\n-  int16_t free_payload_len  = SL_WISUN_NWM_REMOTE_CTRL_BUFF_SIZE;\n\
    -  uint8_t children_count    = 0U;\n-  char *payload_pos         = NULL;\n-\n\
    -  payload_pos = _payload_buff;\n-\n-  // get count of neighbors\n-  (void) sl_wisun_nwm_get_nodes(_nodes,\
    \ SL_WISUN_MAX_NODE_COUNT, true);\n-\n-  sl_wisun_nwm_get_border_router_stat(&_br_stat);\n\
    -  sl_wisun_nwm_get_primary_parent_stat(&_pp_stat);\n-  sl_wisun_nwm_get_children_stat(_children_stats,\
    \ 30U, &children_count);\n-\n-  payload_pos += snprintf(payload_pos, free_payload_len,\
    \ \"{\\n\");\n-  --free_payload_len;\n-  _parse_nbr_stat_to_json(&payload_pos,\
    \ &_br_stat, &free_payload_len);\n-  _parse_nbr_stat_to_json(&payload_pos, &_pp_stat,\
    \ &free_payload_len);\n-\n-  for (uint8_t i = 0; i < children_count; ++i) {\n\
    -    _parse_nbr_stat_to_json(&payload_pos, &_children_stats[i], &free_payload_len);\n\
    -  }\n-\n-  if ((payload_pos - 2U) >= _payload_buff) {\n-    // Remove last item\
    \ comma and print JSON end\n-    snprintf(*(payload_pos - 2U) == ',' ? payload_pos\
    \ - 2U : payload_pos, free_payload_len, \"\\n}\");\n-  }\n-\n-  return _build_response_packet(_payload_buff,\
    \ req_packet);\n-}\n \n static sl_wisun_coap_packet_t * _parse_ping(const sl_wisun_coap_packet_t\
    \ * const req_packet)\n {\n-  ctrl_cmd_type_t ping_cmd          = { 0U };\n- \
    \ sockaddr_in6_t remote_addr          = { 0U };\n-  uint16_t packet_count    \
    \         = 0U;\n-  uint16_t packet_size              = 0U;\n-  char* req_payload\
    \                 = NULL;\n-  buffer_target_type_t print_target = BUFFER_TYPE_NONE;\n\
    +  sl_wisun_nwm_remote_ctrl_cmd_t ping_cmd = { 0U };\n+  sockaddr_in6_t remote_addr\
    \ = { 0U };\n+  uint16_t packet_count = 0U;\n+  uint16_t packet_size = 0U;\n+\
    \  char* req_payload = NULL;\n+  sl_wisun_nwm_remote_ctrl_buf_target_t print_target\
    \ = SL_WISUN_NWM_REMOTE_CTRL_BUF_TARGET_NONE;\n \n   // Parsing incoming cli command\
    \ string.\n   req_payload = sl_wisun_coap_get_payload_str(req_packet);\n   if\
    \ (req_payload == NULL) {\n-    return _build_response_packet(\"No CoAP payload:\
    \ -e \\\"<cli command>\\\"\", req_packet);\n+    return _build_response_packet(&_resp_no_coap_payload,\
    \ req_packet);\n   }\n   _parse_remote_cmd(req_payload, &ping_cmd);\n \n   if\
    \ (ping_cmd.identifier == NULL || ping_cmd.arg1 == NULL) {\n     sl_wisun_coap_destroy_payload_str(req_payload);\n\
    -    return _build_response_packet(\"Not enough argument\", req_packet);\n+  \
    \  return _build_response_packet(&_resp_not_enough_arg, req_packet);\n   }\n \n\
    \   // Handle help request.\n-  if (!strncmp(ping_cmd.arg1, \"help\", SL_WISUN_COAP_NWM_REMOTE_CLI_MAX_ARG_STRING_LENGTH))\
    \ {\n+  if (!strncmp(ping_cmd.arg1,\n+               SL_WISUN_NWM_REMOTE_CTRL_ARG_HELP_STR,\
    \ \n+               SL_WISUN_NWM_REMOTE_CTRL_MAX_ARG_STRING_LENGTH)) {\n     sl_wisun_coap_destroy_payload_str(req_payload);\n\
    -    return _build_response_packet(\"Ping CLI help: measure <packet_count> <packet_size>\
    \ <address>\", req_packet);\n+    return _build_response_packet(&_resp_ping_help,\
    \ req_packet);\n   }\n \n   if (ping_cmd.arg2 == NULL) {\n     sl_wisun_coap_destroy_payload_str(req_payload);\n\
    -    return _build_response_packet(\"Not enough argument\", req_packet);\n+  \
    \  return _build_response_packet(&_resp_not_enough_arg, req_packet);\n   }\n \
    \  packet_count = atoi(ping_cmd.arg1);\n   packet_size = atoi(ping_cmd.arg2);\n\
    \ \n   // Handle measurement request based on address.\n-  if (ping_cmd.arg3 !=\
    \ NULL && !strncmp(ping_cmd.arg3, \"all\", SL_WISUN_COAP_NWM_REMOTE_CLI_MAX_ARG_STRING_LENGTH))\
    \ {\n+  if (ping_cmd.arg3 != NULL && !strncmp(ping_cmd.arg3, \n+             \
    \                           SL_WISUN_NWM_REMOTE_CTRL_ARG_ALL_NODE_STR, \n+   \
    \                                     SL_WISUN_NWM_REMOTE_CTRL_MAX_ARG_STRING_LENGTH))\
    \ {\n     sl_wisun_nwm_quick_measure(SL_WISUN_NWM_TARGET_TYPE_ALL, packet_count,\
    \ packet_size);\n-    print_target = BUFFER_TYPE_ALL;\n-  } else if (ping_cmd.arg3\
    \ != NULL && !strncmp(ping_cmd.arg3, \"parent\", SL_WISUN_COAP_NWM_REMOTE_CLI_MAX_ARG_STRING_LENGTH))\
    \ {\n+    print_target = SL_WISUN_NWM_REMOTE_CTRL_BUF_TARGET_ALL;\n+  } else if\
    \ (ping_cmd.arg3 != NULL && !strncmp(ping_cmd.arg3, \n+                      \
    \                         SL_WISUN_NWM_REMOTE_CTRL_ARG_PARENT_NODE_STR, \n+  \
    \                                             SL_WISUN_NWM_REMOTE_CTRL_MAX_ARG_STRING_LENGTH))\
    \ {\n     sl_wisun_nwm_quick_measure(SL_WISUN_NWM_TARGET_TYPE_PARENT, packet_count,\
    \ packet_size);\n-    print_target = BUFFER_TYPE_PARENT;\n-  } else if (ping_cmd.arg3\
    \ != NULL && !strncmp(ping_cmd.arg3, \"br\", SL_WISUN_COAP_NWM_REMOTE_CLI_MAX_ARG_STRING_LENGTH))\
    \ {\n+    print_target = SL_WISUN_NWM_REMOTE_CTRL_BUF_TARGET_PARENT;\n+  } else\
    \ if (ping_cmd.arg3 != NULL && !strncmp(ping_cmd.arg3, \n+                   \
    \                            SL_WISUN_NWM_REMOTE_CTRL_ARG_BR_NODE_STR, \n+   \
    \                                            SL_WISUN_NWM_REMOTE_CTRL_MAX_ARG_STRING_LENGTH))\
    \ {\n     sl_wisun_nwm_quick_measure(SL_WISUN_NWM_TARGET_TYPE_BORDER_ROUTER, packet_count,\
    \ packet_size);\n-    print_target = BUFFER_TYPE_BORDER_ROUTER;\n+    print_target\
    \ = SL_WISUN_NWM_REMOTE_CTRL_BUF_TARGET_BORDER_ROUTER;\n   } else {\n     if (ping_cmd.arg3\
    \ != NULL && inet_pton(AF_INET6, ping_cmd.arg3, &remote_addr.sin6_addr) == SOCKET_RETVAL_ERROR)\
    \ {\n       sl_wisun_coap_destroy_payload_str(req_payload);\n-      return _build_response_packet(\"\
    [IP address is not set or not valid]\", req_packet);\n+      return _build_response_packet(&_resp_ip_not_valid,\
    \ req_packet);\n     }\n     (void)sl_wisun_ping(&remote_addr, packet_count, packet_size,\n\
    -                        _sl_wisun_nwm_remote_ctrl_stat_handler, NULL);\n-   \
    \ _stat.name = \"Custom Node\";\n+                        _stat_handler, NULL);\n\
    +    _stat.name = SL_WISUN_NWM_REMOTE_CTRL_ARG_CUSTOM_NODE_STR;\n     _stat.addr\
    \ = remote_addr;\n-    print_target = BUFFER_TYPE_SINGLE;\n+    print_target =\
    \ SL_WISUN_NWM_REMOTE_CTRL_BUF_TARGET_SINGLE;\n   }\n \n   sl_wisun_coap_destroy_payload_str(req_payload);\n\
    \ \n   // Build response packet\n-  return _build_send_output(req_packet, print_target);\n\
    +  return _build_response(req_packet, print_target);\n }\n \n static sl_wisun_coap_packet_t\
    \ * _parse_iperf(const sl_wisun_coap_packet_t * const req_packet)\n {\n-  ctrl_cmd_type_t\
    \ iperf_cmd = { 0U };\n-  char* req_payload         = NULL;\n+  sl_wisun_nwm_remote_ctrl_cmd_t\
    \ iperf_cmd = { 0U };\n+  char* req_payload = NULL;\n+  sl_wisun_nwm_remote_ctrl_buf_target_t\
    \ get_res_type = SL_WISUN_NWM_REMOTE_CTRL_BUF_TARGET_NONE;\n   sl_wisun_coap_packet_t\
    \ * resp_packet = NULL;\n \n   // Parsing incoming cli command string.\n   req_payload\
    \ = sl_wisun_coap_get_payload_str(req_packet);\n   if (req_payload == NULL) {\n\
    -    return _build_response_packet(\"No CoAP payload: -e \\\"<cli command>\\\"\
    \", req_packet);\n+    return _build_response_packet(&_resp_no_coap_payload, req_packet);\n\
    \   }\n \n   _parse_remote_cmd(req_payload, &iperf_cmd);\n \n   if (iperf_cmd.identifier\
    \ == NULL || iperf_cmd.arg1 == NULL) {\n     sl_wisun_coap_destroy_payload_str(req_payload);\n\
    -    return _build_response_packet(\"Not enough argument\", req_packet);\n+  \
    \  return _build_response_packet(&_resp_not_enough_arg, req_packet);\n   }\n \n\
    \   // Handle help request.\n-  if (!strncmp(iperf_cmd.arg1, \"help\", SL_WISUN_COAP_NWM_REMOTE_CLI_MAX_ARG_STRING_LENGTH))\
    \ {\n+  if (!strncmp(iperf_cmd.arg1, \n+               SL_WISUN_NWM_REMOTE_CTRL_ARG_HELP_STR,\
    \ \n+               SL_WISUN_NWM_REMOTE_CTRL_MAX_ARG_STRING_LENGTH)) {\n     sl_wisun_coap_destroy_payload_str(req_payload);\n\
    -    return _build_response_packet(SL_WISUN_NWM_REMOTE_CTRL_IPERF_HELP_STRING,\
    \ req_packet);\n+    return _build_response_packet(&_resp_iperf_help, req_packet);\n\
    \   }\n \n   // Handle server or client start requests.\n-  if (!strncmp(iperf_cmd.arg1,\
    \ \"server\", SL_WISUN_COAP_NWM_REMOTE_CLI_MAX_ARG_STRING_LENGTH)) {\n+  if (!strncmp(iperf_cmd.arg1,\
    \ \n+               SL_WISUN_NWM_REMOTE_CTRL_ARG_SERVER_STR, \n+             \
    \  SL_WISUN_NWM_REMOTE_CTRL_MAX_ARG_STRING_LENGTH)) {\n     sl_wisun_coap_destroy_payload_str(req_payload);\n\
    \     return _start_iperf_server(req_packet);\n   }\n \n-  if (!strncmp(iperf_cmd.arg1,\
    \ \"client\", SL_WISUN_COAP_NWM_REMOTE_CLI_MAX_ARG_STRING_LENGTH)) {\n+  if (!strncmp(iperf_cmd.arg1,\
    \ \n+               SL_WISUN_NWM_REMOTE_CTRL_ARG_CLIENT_STR, \n+             \
    \  SL_WISUN_NWM_REMOTE_CTRL_MAX_ARG_STRING_LENGTH)) {\n     sl_wisun_coap_destroy_payload_str(req_payload);\n\
    \     return _start_iperf_client(req_packet);\n   }\n \n   if (iperf_cmd.arg2\
    \ == NULL) {\n     sl_wisun_coap_destroy_payload_str(req_payload);\n \n-    return\
    \ _build_response_packet(\"Not enough argument\", req_packet);\n+    return _build_response_packet(&_resp_not_enough_arg,\
    \ req_packet);\n   }\n \n   // Handle get requests.\n-  if (!strncmp(iperf_cmd.arg1,\
    \ \"get\", SL_WISUN_COAP_NWM_REMOTE_CLI_MAX_ARG_STRING_LENGTH)) {\n-    if (!strncmp(iperf_cmd.arg2,\
    \ \"result\", SL_WISUN_COAP_NWM_REMOTE_CLI_MAX_ARG_STRING_LENGTH)) {\n+  if (!strncmp(iperf_cmd.arg1,\
    \ \n+               SL_WISUN_NWM_REMOTE_CTRL_ARG_GET_STR, \n+               SL_WISUN_NWM_REMOTE_CTRL_MAX_ARG_STRING_LENGTH))\
    \ {\n+    if (!strncmp(iperf_cmd.arg2, \n+                 SL_WISUN_NWM_REMOTE_CTRL_ARG_JSON_STR,\
    \ \n+                 SL_WISUN_NWM_REMOTE_CTRL_MAX_ARG_STRING_LENGTH)) {\n+  \
    \    get_res_type = SL_WISUN_NWM_REMOTE_CTRL_BUF_TARGET_IPERF_JSON;\n+    } else\
    \ if (!strncmp(iperf_cmd.arg2, \n+                        SL_WISUN_NWM_REMOTE_CTRL_ARG_TEXT_STR,\
    \ \n+                        SL_WISUN_NWM_REMOTE_CTRL_MAX_ARG_STRING_LENGTH))\
    \ {\n+      get_res_type = SL_WISUN_NWM_REMOTE_CTRL_BUF_TARGET_IPERF_TEXT;\n+\
    \    } else {\n+      // Invalid iperf get request\n+      resp_packet = _build_response_packet(&_resp_invalid_res_type,\
    \ req_packet);\n+    }\n+\n+    if (get_res_type != SL_WISUN_NWM_REMOTE_CTRL_BUF_TARGET_NONE)\
    \ {\n       (void) sl_iperf_test_get(&_last_test, 1);\n-      resp_packet = _build_send_output(req_packet,\
    \ BUFFER_TYPE_IPERF);\n+      resp_packet = _build_response(req_packet, get_res_type);\n\
    \       if (resp_packet == NULL) {\n-        resp_packet = _build_response_packet(\"\
    [Buffer error]\", req_packet);\n+        resp_packet = _build_response_packet(&_resp_buff_error,\
    \ req_packet);\n       }\n-    } else {\n-      resp_packet = _build_response_packet(\"\
    Not found argument.\", req_packet);\n     }\n \n     // Clean memory\n@@ -483,28\
    \ +655,45 @@ static sl_wisun_coap_packet_t * _parse_iperf(const sl_wisun_coap_packet_t\
    \ * cons\n \n   if (iperf_cmd.arg3 == NULL) {\n     sl_wisun_coap_destroy_payload_str(req_payload);\n\
    -    return _build_response_packet(\"Not enough argument\", req_packet);\n+  \
    \  return _build_response_packet(&_resp_not_enough_arg, req_packet);\n   }\n \n\
    \   // Handle settings requests.\n-  if (!strncmp(iperf_cmd.arg1, \"set\", SL_WISUN_COAP_NWM_REMOTE_CLI_MAX_ARG_STRING_LENGTH))\
    \ {\n-    if (!strncmp(iperf_cmd.arg2, \"options.bandwidth\", SL_WISUN_COAP_NWM_REMOTE_CLI_MAX_ARG_STRING_LENGTH))\
    \ {\n+  if (!strncmp(iperf_cmd.arg1, \n+               SL_WISUN_NWM_REMOTE_CTRL_ARG_SET_STR,\
    \ \n+               SL_WISUN_NWM_REMOTE_CTRL_MAX_ARG_STRING_LENGTH)) {\n+\n+ \
    \   if (!strncmp(iperf_cmd.arg2, \n+                 SL_WISUN_NWM_REMOTE_CTRL_ARG_OPTIONS_BW_STR,\
    \ \n+                 SL_WISUN_NWM_REMOTE_CTRL_MAX_ARG_STRING_LENGTH)) {\n   \
    \    _options.bandwidth = atoi(iperf_cmd.arg3);\n-      resp_packet = sl_wisun_coap_build_response(req_packet,\
    \ COAP_MSG_CODE_RESPONSE_CHANGED);\n-    } else if (!strncmp(iperf_cmd.arg2, \"\
    options.remote_addr\", SL_WISUN_COAP_NWM_REMOTE_CLI_MAX_ARG_STRING_LENGTH)) {\n\
    -      memcpy(_options.remote_addr, iperf_cmd.arg3, sl_strnlen(iperf_cmd.arg3,\
    \ SL_WISUN_COAP_NWM_REMOTE_CLI_MAX_QUERY_LENGTH));\n-      resp_packet = sl_wisun_coap_build_response(req_packet,\
    \ COAP_MSG_CODE_RESPONSE_CHANGED);\n-    } else if (!strncmp(iperf_cmd.arg2, \"\
    options.duration\", SL_WISUN_COAP_NWM_REMOTE_CLI_MAX_ARG_STRING_LENGTH)) {\n+\
    \      resp_packet = _build_response_packet(&_resp_iperf_set_succeed, req_packet);\n\
    +    \n+    } else if (!strncmp(iperf_cmd.arg2, \n+                        SL_WISUN_NWM_REMOTE_CTRL_ARG_OPTIONS_REMOTE_ADDR_STR,\
    \ \n+                        SL_WISUN_NWM_REMOTE_CTRL_MAX_ARG_STRING_LENGTH))\
    \ {\n+      memcpy(_options.remote_addr, \n+             iperf_cmd.arg3, \n+ \
    \            sl_strnlen(iperf_cmd.arg3, SL_WISUN_NWM_REMOTE_CTRL_MAX_QUERY_LENGTH));\n\
    +      resp_packet = _build_response_packet(&_resp_iperf_set_succeed, req_packet);\n\
    +    \n+    } else if (!strncmp(iperf_cmd.arg2, \n+                        SL_WISUN_NWM_REMOTE_CTRL_ARG_OPTIONS_DURATION_STR,\
    \ \n+                        SL_WISUN_NWM_REMOTE_CTRL_MAX_ARG_STRING_LENGTH))\
    \ {\n       _options.duration_ms = atoi(iperf_cmd.arg3);\n-      resp_packet =\
    \ sl_wisun_coap_build_response(req_packet, COAP_MSG_CODE_RESPONSE_CHANGED);\n\
    -    } else if (!strncmp(iperf_cmd.arg2, \"options.interval\", SL_WISUN_COAP_NWM_REMOTE_CLI_MAX_ARG_STRING_LENGTH))\
    \ {\n+      resp_packet = _build_response_packet(&_resp_iperf_set_succeed, req_packet);\n\
    +    \n+    } else if (!strncmp(iperf_cmd.arg2, \n+                        SL_WISUN_NWM_REMOTE_CTRL_ARG_OPTIONS_INTERVAL_STR,\
    \ \n+                        SL_WISUN_NWM_REMOTE_CTRL_MAX_ARG_STRING_LENGTH))\
    \ {\n       _options.interval_ms = atoi(iperf_cmd.arg3);\n-      resp_packet =\
    \ sl_wisun_coap_build_response(req_packet, COAP_MSG_CODE_RESPONSE_CHANGED);\n\
    +      resp_packet = _build_response_packet(&_resp_iperf_set_succeed, req_packet);\n\
    +    \n     } else {\n-      resp_packet = sl_wisun_coap_build_response(req_packet,\
    \ COAP_MSG_CODE_RESPONSE_NOT_ACCEPTABLE);\n+      resp_packet = _build_response_packet(&_resp_iperf_set_failed,\
    \ req_packet);\n     }\n   } else {\n-    resp_packet = _build_response_packet(\"\
    Unknown cli command\", req_packet);\n+    resp_packet = _build_response_packet(&_resp_unknown_cli,\
    \ req_packet);\n   }\n \n   // Clean memory\n@@ -524,12 +713,13 @@ static  sl_wisun_coap_packet_t\
    \ * _start_iperf_server(const sl_wisun_coap_packet_\n \n   // Adds the test to\
    \ the queue\n   if (!sl_iperf_test_add(&test)) {\n-    printf(\"[Adding test to\
    \ queue failed]\\n\");\n-    return NULL;\n+    return _build_response_packet(&_resp_test_queue_failed,\
    \ \n+                                  req_packet);\n   }\n \n   // Build response\
    \ packet.\n-  return _build_response_packet(\"[iPerf server started]\", req_packet);\n\
    +  return _build_response_packet(&_resp_iperf_srv_started, \n+               \
    \                 req_packet);\n }\n \n static sl_wisun_coap_packet_t * _start_iperf_client(const\
    \ sl_wisun_coap_packet_t * const req_packet)\n@@ -544,120 +734,191 @@ static sl_wisun_coap_packet_t\
    \ * _start_iperf_client(const sl_wisun_coap_packet_t\n \n   // Adds the test to\
    \ the queue.\n   if (!sl_iperf_test_add(&test)) {\n-    printf(\"[Adding test\
    \ to queue failed]\\n\");\n-    return NULL;\n+    return _build_response_packet(&_resp_test_queue_failed,\
    \ req_packet);\n   }\n \n   // Build response packet.\n-  return _build_response_packet(\"\
    [iPerf client started]\", req_packet);\n-\n+  return _build_response_packet(&_resp_iperf_clnt_started,\
    \ \n+                                req_packet);\n }\n \n-\n-static void _parse_remote_cmd(char*\
    \ req_cmd, ctrl_cmd_type_t* cmd)\n+static void _parse_remote_cmd(char* req_cmd,\
    \ sl_wisun_nwm_remote_ctrl_cmd_t* cmd)\n {\n   cmd->identifier = strtok(req_cmd,\
    \ \" \");\n   cmd->arg1 = strtok(NULL, \" \");\n   cmd->arg2 = strtok(NULL, \"\
    \ \");\n   cmd->arg3 = strtok(NULL, \" \");\n }\n \n-static sl_status_t _build_payload(buffer_target_type_t\
    \ target)\n+static char * _build_iperf_result(const sl_wisun_nwm_remote_ctrl_buf_target_t\
    \ target,\n+                                  char * const payload_buff)\n {\n\
    -  uint8_t children_count = 0U;\n-  char *payload_pos = _payload_buff;\n-  int16_t\
    \ payload_len    = SL_WISUN_NWM_REMOTE_CTRL_BUFF_SIZE; // payload length\n-  int32_t\
    \ r = 0L;\n-\n-  // Get stats from stat storage\n-  sl_wisun_nwm_get_border_router_stat(&_br_stat);\n\
    -  sl_wisun_nwm_get_primary_parent_stat(&_pp_stat);\n-  sl_wisun_nwm_get_children_stat(_children_stats,\
    \ 30U, &children_count);\n+     // Set buffer\n+    sl_iperf_log_set_buff(_last_test.log,\
    \ payload_buff, SL_WISUN_NWM_REMOTE_CTRL_BUFF_SIZE);\n \n-  if (target == BUFFER_TYPE_IPERF)\
    \ {\n-    // Set buffer\n-    sl_iperf_log_set_buff(_last_test.log, _payload_buff,\
    \ payload_len);\n-    \n     // Set printer\n     sl_iperf_log_set_printer(_last_test.log,\
    \ _log_print_only_buff);\n-    \n-    // Print json formatted log\n-    sl_iperf_print_test_log_json(&_last_test);\n\
    +\n+    if (target == SL_WISUN_NWM_REMOTE_CTRL_BUF_TARGET_IPERF_JSON) {\n+   \
    \   // Print json formatted log\n+      sl_iperf_print_test_log_json(&_last_test);\n\
    +    } else {\n+      // print connection string with addresses\n+      sl_iperf_test_print_udp_conn_str(&_last_test);\n\
    +      // print report header\n+      if (_last_test.opt.mode == SL_IPERF_MODE_SERVER)\
    \ {\n+        sl_iperf_test_print_udp_srv_report_hdr(&_last_test);\n+      } else\
    \ {\n+        sl_iperf_test_print_udp_clnt_report_hdr(&_last_test);\n+      }\n\
    +      // print report summary\n+      sl_iperf_test_calculate_average_bandwidth(&_last_test);\n\
    +    }\n \n     // Reinit log\n     sl_iperf_log_init(_last_test.log);\n-    return\
    \ SL_STATUS_OK;\n+    return payload_buff;\n+}\n+\n+static char * _build_nbr_info(char\
    \ * const payload_buff,\n+                              sl_wisun_nwm_measurable_node_t\
    \ * const nodes,\n+                              sl_wisun_nwm_node_stat_t * const\
    \ br_stat,\n+                              sl_wisun_nwm_node_stat_t * const pp_stat,\n\
    +                              sl_wisun_nwm_node_stat_t * const children_stats)\n\
    +{\n+  int16_t free_payload_len = SL_WISUN_NWM_REMOTE_CTRL_BUFF_SIZE;\n+  uint8_t\
    \ children_count = 0U;\n+  char *payload_pos = NULL;\n+\n+  payload_pos = payload_buff;\n\
    +\n+  // get count of neighbors\n+  (void) sl_wisun_nwm_get_nodes(nodes, SL_WISUN_MAX_NODE_COUNT,\
    \ true);\n+\n+  sl_wisun_nwm_get_border_router_stat(br_stat);\n+  sl_wisun_nwm_get_primary_parent_stat(pp_stat);\n\
    +  sl_wisun_nwm_get_children_stat(children_stats, 30U, &children_count);\n+\n\
    +  payload_pos += snprintf(payload_pos, free_payload_len, \"{\\n\");\n+  --free_payload_len;\n\
    +  _parse_nbr_stat_to_json(&payload_pos, br_stat, &free_payload_len);\n+  _parse_nbr_stat_to_json(&payload_pos,\
    \ pp_stat, &free_payload_len);\n+\n+  for (uint8_t i = 0; i < children_count;\
    \ ++i) {\n+    _parse_nbr_stat_to_json(&payload_pos, &children_stats[i], &free_payload_len);\n\
    +  }\n+\n+  if ((payload_pos - 2U) >= payload_buff) {\n+    // Remove last item\
    \ comma and print JSON end\n+    snprintf(*(payload_pos - 2U) == ',' ? payload_pos\
    \ - 2U : payload_pos, free_payload_len, \"\\n}\");\n   }\n \n+  return payload_buff;\n\
    +}\n+\n+static char * _build_ping_meas_stat(const sl_wisun_nwm_remote_ctrl_buf_target_t\
    \ target,\n+                                    char * const payload_buff,\n+\
    \                                    sl_wisun_nwm_node_stat_t * const br_stat,\n\
    +                                    sl_wisun_nwm_node_stat_t * const pp_stat,\n\
    +                                    sl_wisun_nwm_node_stat_t * const children_stats)\n\
    +{\n+  uint8_t children_count = 0U;\n+  char *payload_pos = payload_buff;\n+ \
    \ uint16_t payload_len = SL_WISUN_NWM_REMOTE_CTRL_BUFF_SIZE;\n+  int32_t r = 0L;\n\
    +\n+  // Get stats from stat storage\n+  sl_wisun_nwm_get_border_router_stat(br_stat);\n\
    +  sl_wisun_nwm_get_primary_parent_stat(pp_stat);\n+  sl_wisun_nwm_get_children_stat(children_stats,\
    \ 30U, &children_count);\n+\n+\n   // Print JSON start\n   r = snprintf(payload_pos,\
    \ payload_len, \"{\\n\");\n   if (r < 0L) {\n-    return SL_STATUS_FAIL;\n+  \
    \  return NULL;\n   }\n   payload_pos += r;\n \n   // Print stats to buffer\n\
    -  if (target == BUFFER_TYPE_PARENT || target == BUFFER_TYPE_ALL) {\n-    _parse_stat_to_json(&payload_pos,\
    \ &_pp_stat, &payload_len);\n+  if (target == SL_WISUN_NWM_REMOTE_CTRL_BUF_TARGET_PARENT\
    \ || target == SL_WISUN_NWM_REMOTE_CTRL_BUF_TARGET_ALL) {\n+    _parse_stat_to_json(&payload_pos,\
    \ pp_stat, &payload_len);\n   }\n \n-  if (target == BUFFER_TYPE_BORDER_ROUTER\
    \ || target == BUFFER_TYPE_ALL) {\n-    _parse_stat_to_json(&payload_pos, &_br_stat,\
    \ &payload_len);\n+  if (target == SL_WISUN_NWM_REMOTE_CTRL_BUF_TARGET_BORDER_ROUTER\
    \ || target == SL_WISUN_NWM_REMOTE_CTRL_BUF_TARGET_ALL) {\n+    _parse_stat_to_json(&payload_pos,\
    \ br_stat, &payload_len);\n   }\n \n-  if (target == BUFFER_TYPE_SINGLE) {\n+\
    \  if (target == SL_WISUN_NWM_REMOTE_CTRL_BUF_TARGET_SINGLE) {\n     _parse_stat_to_json(&payload_pos,\
    \ &_stat, &payload_len);\n   }\n \n   for (uint8_t i = 0; i < children_count;\
    \ ++i) {\n-    _parse_stat_to_json(&payload_pos, &_children_stats[i], &payload_len);\n\
    +    _parse_stat_to_json(&payload_pos, &children_stats[i], &payload_len);\n  \
    \ }\n \n-  if ((payload_pos - 2U) >= _payload_buff) {\n+  if ((payload_pos - 2U)\
    \ >= payload_buff) {\n     // Remove last item comma and print JSON end\n    \
    \ r = snprintf(*(payload_pos - 2U) == ',' ? payload_pos - 2U : payload_pos, payload_len,\
    \ \"\\n}\");\n     if (r < 0L) {\n-      return SL_STATUS_FAIL;\n+      return\
    \ NULL;\n     }\n   }\n \n-  return SL_STATUS_OK;\n+  return payload_buff;\n }\n\
    \ \n-static sl_wisun_coap_packet_t * _build_send_output(const sl_wisun_coap_packet_t\
    \ * const req_packet, buffer_target_type_t target)\n+static char * _build_payload(sl_wisun_nwm_remote_ctrl_buf_target_t\
    \ target)\n {\n-  sl_status_t retval = SL_STATUS_FAIL; // assume success of operation\n\
    +  static sl_wisun_nwm_measurable_node_t nodes[SL_WISUN_MAX_NODE_COUNT];\n+  static\
    \ sl_wisun_nwm_node_stat_t children_stats[SL_WISUN_NWM_REMOTE_CTRL_MAX_NB_COUNT];\n\
    +  static sl_wisun_nwm_node_stat_t br_stat;\n+  static sl_wisun_nwm_node_stat_t\
    \ pp_stat;\n+  static char payload_buff[SL_WISUN_NWM_REMOTE_CTRL_BUFF_SIZE] =\
    \ { 0U };\n+\n+  if (target == SL_WISUN_NWM_REMOTE_CTRL_BUF_TARGET_IPERF_JSON\
    \ || target == SL_WISUN_NWM_REMOTE_CTRL_BUF_TARGET_IPERF_TEXT) {\n+    return\
    \ _build_iperf_result(target, payload_buff);\n+  } else if (target == SL_WISUN_NWM_REMOTE_CTRL_BUF_TARGET_NBINF)\
    \ {\n+    return _build_nbr_info(payload_buff, nodes, &br_stat, &pp_stat, children_stats);\n\
    +  } else {\n+    return _build_ping_meas_stat(target, payload_buff, &br_stat,\
    \ &pp_stat, children_stats);\n+  }\n+}\n \n-  // Build payload from stat.\n- \
    \ retval = _build_payload(target);\n+static sl_wisun_coap_packet_t *  _build_response(const\
    \ sl_wisun_coap_packet_t * const req_packet,\n+                              \
    \                      const sl_wisun_nwm_remote_ctrl_buf_target_t target)\n+{\n\
    +  static sl_wisun_nwm_remote_ctrl_resp_t resp = { \n+    .msg_code = COAP_MSG_CODE_RESPONSE_CONTENT,\n\
    +    .payload = NULL\n+  };\n \n-  if (retval != SL_STATUS_OK) {\n-    return\
    \ NULL;\n-  }\n+  // Build payload from stat.\n+  resp.payload = _build_payload(target);\n\
    \ \n   // Build response packet from built payload.\n-  return _build_response_packet(_payload_buff,\
    \ req_packet);\n+  return _build_response_packet(&resp, req_packet);\n }\n \n\
    -static sl_wisun_coap_packet_t * _build_response_packet(char* payload,\n+static\
    \ sl_wisun_coap_packet_t * _build_response_packet(const sl_wisun_nwm_remote_ctrl_resp_t\
    \ * const resp,\n                                                        const\
    \ sl_wisun_coap_packet_t * const req_packet)\n {\n   sl_wisun_coap_packet_t *resp_packet\
    \ = NULL;\n \n-  resp_packet = sl_wisun_coap_build_response(req_packet, COAP_MSG_CODE_RESPONSE_CONTENT);\n\
    +  resp_packet = sl_wisun_coap_build_response(req_packet, resp->msg_code);\n \
    \  if (resp_packet == NULL) {\n     return NULL;\n   }\n-\n-  resp_packet->msg_code\
    \       = COAP_MSG_CODE_RESPONSE_CONTENT;\n-  resp_packet->content_format = COAP_CT_JSON;\n\
    -  resp_packet->payload_ptr    = (uint8_t *) payload;\n-  resp_packet->payload_len\
    \    = (uint16_t) sl_strnlen(payload, SL_WISUN_NWM_REMOTE_CTRL_BUFF_SIZE);\n-\n\
    +  if (resp->payload != NULL) {\n+    resp_packet->payload_ptr = (uint8_t *) resp->payload;\n\
    +    resp_packet->payload_len = (uint16_t) sl_strnlen((char *)resp->payload, SL_WISUN_NWM_REMOTE_CTRL_BUFF_SIZE);\n\
    +  }\n   return resp_packet;\n }\n \n-static void _parse_stat_to_json(char **payload_pos,\
    \ sl_wisun_nwm_node_stat_t *stat, int16_t *payload_len)\n+static void _parse_stat_to_json(char\
    \ **payload_pos, \n+                                const sl_wisun_nwm_node_stat_t\
    \ * const stat, \n+                                uint16_t * const payload_len)\n\
    \ {\n   int32_t r = 0U;\n   const char *ip_str = NULL;\n@@ -709,13 +970,12 @@\
    \ static void _parse_nbr_stat_to_json(char **payload_pos,\n }\n \n /* Statistic\
    \ printer */\n-static void _sl_wisun_nwm_remote_ctrl_stat_handler(sl_wisun_ping_stat_t\
    \ *stat)\n+static void _stat_handler(sl_wisun_ping_stat_t *stat)\n {\n   assert(stat->packet_count\
    \ != 0);\n   memcpy(&_stat.ping_stat, stat, sizeof(sl_wisun_ping_stat_t));\n }\n\
    \ \n-\n static int32_t _log_print_only_buff(sl_iperf_log_t * const log, const\
    \ char * format, ...)\n {\n   va_list args;"
  - "--- a/app/wisun/component/network_measurement/sli_wisun_network_measurement_ping_gui.c\n\
    +++ b/app/wisun/component/network_measurement/sli_wisun_network_measurement_ping_gui.c\n\
    @@ -142,7 +142,7 @@ typedef struct sl_wisun_nwm_setting {\n /// Node info structure\
    \ type definition\n typedef struct node_info {\n   /// Addresses\n-  current_addr_t\
    \ addresses;\n+  sl_wisun_app_core_current_addr_t addresses;\n   /// Settings\n\
    \   app_setting_wisun_t settings;\n } node_info_t;"
  - "--- a/app/wisun/component/network_measurement/sli_wisun_network_measurement_settings_gui.c\n\
    +++ b/app/wisun/component/network_measurement/sli_wisun_network_measurement_settings_gui.c\n\
    @@ -182,6 +182,10 @@ void sli_wisun_nwm_phy_select_form(void *args)\n \n static\
    \ void _phy_fan_form(void *args)\n {\n+  if (args == NULL) {\n+    return;\n+\
    \  }\n+\n   uint8_t *profile               = NULL;\n   app_wisun_phy_list_t *tmp_list\
    \ = NULL;\n   app_enum_t *iter               = NULL;\n@@ -231,6 +235,10 @@ static\
    \ void _phy_fan_form(void *args)\n \n static void _phy_domain_form(void *args)\n\
    \ {\n+  if (args == NULL) {\n+    return;\n+  }\n+\n   phy_domain_list_t *domain\
    \ = NULL;\n \n   domain = (phy_domain_list_t *)args;\n@@ -286,7 +294,7 @@ static\
    \ void _set_phy(void *args)\n   sl_wisun_disconnect();\n \n   // to connect to\
    \ the network with the new settings\n-  app_wisun_network_connect();\n+  sl_wisun_app_core_network_connect();\n\
    \ }\n \n __STATIC_INLINE bool filter_profile(sl_wisun_phy_config_t *phy_cfg)"
  - "--- a/app/wisun/component/ota_dfu/sl_wisun_ota_dfu.c\n+++ b/app/wisun/component/ota_dfu/sl_wisun_ota_dfu.c\n\
    @@ -502,7 +502,7 @@ static sl_wisun_coap_packet_t * _ota_dfu_coap_response_cb(const\
    \ sl_wisun_coap_pa\n   resp_packet->msg_code = COAP_MSG_CODE_RESPONSE_CREATED;\n\
    \   resp_packet->content_format = COAP_CT_JSON;\n \n-  // CoAP PUT request to\
    \ start firmware updaet\n+  // CoAP PUT request to start firmware update\n   if\
    \ (req_packet->msg_code == COAP_MSG_CODE_REQUEST_POST) {\n     // Start fw update\n\
    \     if (!memcmp(SL_WISUN_OTA_DFU_START_PAYLOAD_STR,\n@@ -604,7 +604,7 @@ static\
    \ void _ota_dfu_thr_fnc(void * args)\n \n #if SL_WISUN_OTA_DFU_HOST_NOTIFY_ENABLED\n\
    \   // Create socket\n-  _notify_ch.sockid = socket(AF_INET6, (SOCK_DGRAM | SOCK_NONBLOCK),\
    \ IPPROTO_UDP);\n+  _notify_ch.sockid = socket(AF_INET6, SOCK_DGRAM, IPPROTO_UDP);\n\
    \   assert(_notify_ch.sockid != -1L);\n \n   // Set address"
  - "--- a/app/wisun/component/ping/sl_wisun_ping.c\n+++ b/app/wisun/component/ping/sl_wisun_ping.c\n\
    @@ -424,10 +424,10 @@ static void _ping_task_fnc(void *args)\n   _fill_payload(&icmp_req);\n\
    \ \n   SL_WISUN_THREAD_LOOP {\n-    stat = osMessageQueueGet(_ping_req_msg_queue,\
    \ &req, &msg_prio, 0U);\n+    stat = osMessageQueueGet(_ping_req_msg_queue, &req,\
    \ &msg_prio, osWaitForever);\n     (void) msg_prio;\n     if (stat != osOK) {\n\
    -      app_wisun_dispatch_thread();\n+      sl_wisun_app_core_util_dispatch_thread();\n\
    \       continue;\n     }\n \n@@ -443,7 +443,7 @@ static void _ping_task_fnc(void\
    \ *args)\n     req.remote_addr.sin6_family = AF_INET6;\n     req.remote_addr.sin6_port\
    \ = htons(SL_WISUN_PING_ICMP_PORT);\n \n-    sockid = socket(AF_INET6, (SOCK_RAW\
    \ | SOCK_NONBLOCK), IPPROTO_ICMP);\n+    sockid = socket(AF_INET6, SOCK_RAW, IPPROTO_ICMP);\n\
    \ \n     if (sockid == SOCKET_INVALID_ID) {\n       _prepare_and_push_failed_response(&resp,\
    \ SL_WISUN_PING_STATUS_SOCKET_ERROR);\n@@ -483,7 +483,7 @@ static void _ping_task_fnc(void\
    \ *args)\n         if (r > 0L) {\n           break;\n         }\n-        app_wisun_dispatch_thread();\n\
    +        sl_wisun_app_core_util_dispatch_thread();\n         time_cnt = _get_ms_val_from_start_time_stamp(&req);\n\
    \       }\n \n@@ -510,7 +510,7 @@ static void _ping_task_fnc(void *args)\n   \
    \    osMessageQueuePut(_ping_resp_msg_queue, &resp, 0U, 0U);\n \n       // thread\
    \ dispatch\n-      app_wisun_dispatch_thread();\n+      sl_wisun_app_core_util_dispatch_thread();\n\
    \     } while (multicast);\n \n     osEventFlagsSet(_ping_evt, SL_WISUN_PING_STATUS_TRANSACTION_END);"
  - "--- a/app/wisun/component/tcp_client/sl_wisun_tcp_client.c\n+++ b/app/wisun/component/tcp_client/sl_wisun_tcp_client.c\n\
    @@ -69,7 +69,7 @@ void sl_wisun_tcp_client_create(const char *ip_address, uint16_t\
    \ port)\n   }\n \n   // create client socket\n-  sockid = socket(AF_INET6, (SOCK_STREAM\
    \ | SOCK_NONBLOCK), IPPROTO_IP);\n+  sockid = socket(AF_INET6, SOCK_STREAM, IPPROTO_IP);\n\
    \ \n   if (sockid == SOCKET_RETVAL_ERROR) {\n     printf(\"[Failed to create socket:\
    \ %ld]\\n\", sockid);"
  - "--- a/app/wisun/component/trace_util/sl_wisun_trace_util.c\n+++ b/app/wisun/component/trace_util/sl_wisun_trace_util.c\n\
    @@ -38,6 +38,7 @@\n #include \"sl_wisun_trace_util.h\"\n #include \"sl_wisun_types.h\"\
    \n #include \"rail_config.h\"\n+#include \"cmsis_os2.h\"\n \n #if defined(SL_CATALOG_FREERTOS_KERNEL_PRESENT)\n\
    \ // FreeRTOS\n@@ -118,6 +119,15 @@\n /// Secs in Minute\n #define SEC_IN_MINUTE\
    \     60U\n \n+/// Trace util event notify max channel count\n+#define APP_WISUN_TRACE_UTIL_EVT_NOTIFY_MAX_CHS\
    \         31U\n+\n+/// Trace util event notify error mask\n+#define APP_WISUN_TRACE_UTIL_EVT_NOTIFY_ERROR_MSK\
    \       (1UL << 31U)\n+\n+/// Trace util event notify all flags mask\n+#define\
    \ APP_WISUN_TRACE_UTIL_EVT_NOTIFY_ALL_FLAGS_MSK   0x7FFFFFFFUL\n+\n /// PHY type\
    \ enumeration\n typedef enum phy_type {\n   /// PHY type FSK\n@@ -650,6 +660,109\
    \ @@ const char *app_wisun_trace_util_time_to_str(const sl_wisun_trace_util_time_t\
    \ *\n   return (const char *) str;\n }\n \n+\n+sl_status_t app_wisun_trace_util_evt_notify_init(app_wisun_trace_util_evt_notify_t\
    \ * const evt_notify,\n+                                                 const\
    \ uint32_t wait_opt)\n+{\n+  static const osEventFlagsAttr_t evt_attr = {\n+ \
    \   .name = \"EvtNotify\",\n+    .cb_mem = NULL,\n+    .cb_size = 0,\n+    .attr_bits\
    \ = 0\n+  };\n+\n+  if (evt_notify == NULL) {\n+    return SL_STATUS_FAIL;\n+\
    \  }\n+\n+  evt_notify->evt_chs = 0UL;\n+  evt_notify->wait_opt = wait_opt;\n\
    +  evt_notify->evt_id = osEventFlagsNew(&evt_attr);\n+  \n+  if (evt_notify->evt_id\
    \ == NULL) {\n+    return SL_STATUS_FAIL;\n+  }\n+\n+  return SL_STATUS_OK;\n\
    +}\n+\n+sl_status_t app_wisun_trace_util_evt_notify_clear(app_wisun_trace_util_evt_notify_t\
    \ * const evt_notify)\n+{\n+  uint32_t flags = 0UL;\n+\n+  flags = osEventFlagsClear(evt_notify->evt_id,\
    \ APP_WISUN_TRACE_UTIL_EVT_NOTIFY_ALL_FLAGS_MSK);\n+\n+  if (flags & APP_WISUN_TRACE_UTIL_EVT_NOTIFY_ERROR_MSK)\
    \ {\n+    return SL_STATUS_FAIL;\n+  }\n+\n+  return SL_STATUS_OK;\n+}\n+\n+\n\
    +sl_status_t app_wisun_trace_util_evt_notify_subscribe_ch(app_wisun_trace_util_evt_notify_t\
    \ * const evt_notify, \n+                                                    \
    \     uint8_t * const evt_ch)\n+{\n+  for (uint8_t ch_idx = 0; ch_idx < APP_WISUN_TRACE_UTIL_EVT_NOTIFY_MAX_CHS;\
    \ ch_idx++) {\n+    if (!(evt_notify->evt_chs & (1UL << ch_idx))) {\n+      *evt_ch\
    \ = ch_idx;\n+      evt_notify->evt_chs |= (1UL << ch_idx);\n+      return SL_STATUS_OK;\n\
    +    }\n+  }\n+  return SL_STATUS_FAIL;\n+}\n+\n+sl_status_t app_wisun_trace_util_evt_notify_unsubscribe_ch(app_wisun_trace_util_evt_notify_t\
    \ * const evt_notify, \n+                                                    \
    \       const uint8_t evt_ch)\n+{\n+\n+  if (!(evt_notify->evt_chs & (1UL << evt_ch)))\
    \ {\n+    return SL_STATUS_FAIL;\n+  }\n+\n+  (void) osEventFlagsClear(evt_notify->evt_id,\
    \ 1UL << evt_ch);\n+  evt_notify->evt_chs &= ~(1UL << evt_ch);\n+\n+\n+  return\
    \ SL_STATUS_OK;\n+}\n+\n+sl_status_t app_wisun_trace_util_evt_notfiy_chs(const\
    \ app_wisun_trace_util_evt_notify_t * const evt_notify)\n+{\n+  uint32_t flags\
    \ = 0UL;\n+\n+  flags = osEventFlagsSet(evt_notify->evt_id, evt_notify->evt_chs);\n\
    +\n+  if (flags & APP_WISUN_TRACE_UTIL_EVT_NOTIFY_ERROR_MSK) {\n+    return SL_STATUS_FAIL;\n\
    +  }\n+\n+  return SL_STATUS_OK;\n+}\n+\n+\n+sl_status_t app_wisun_trace_util_evt_notify_wait(const\
    \ app_wisun_trace_util_evt_notify_t * const evt_notify,\n+                   \
    \                              const uint32_t ch_mask,\n+                    \
    \                             const uint32_t timeout)\n+{\n+  uint32_t flags =\
    \ 0UL;\n+\n+  if (!(evt_notify->evt_chs & ch_mask)) {\n+    return SL_STATUS_FAIL;\n\
    +  }\n+\n+  flags = osEventFlagsWait(evt_notify->evt_id, ch_mask, evt_notify->wait_opt,\
    \ timeout);\n+\n+  if (flags & APP_WISUN_TRACE_UTIL_EVT_NOTIFY_ERROR_MSK) {\n\
    +    return SL_STATUS_FAIL;\n+  }\n+\n+  return SL_STATUS_OK;\n+}\n+\n+\n+\n //\
    \ -----------------------------------------------------------------------------\n\
    \ //                          Static Function Definitions\n // -----------------------------------------------------------------------------"
  - "--- a/app/wisun/component/udp_client/sl_wisun_udp_client.c\n+++ b/app/wisun/component/udp_client/sl_wisun_udp_client.c\n\
    @@ -66,7 +66,7 @@ void sl_wisun_udp_client_create(void)\n   int32_t sockid = SOCKET_INVALID_ID;\
    \ // client socket id\n \n   // create client socket\n-  sockid = socket(AF_INET6,\
    \ (SOCK_DGRAM | SOCK_NONBLOCK), IPPROTO_IP);\n+  sockid = socket(AF_INET6, SOCK_DGRAM,\
    \ IPPROTO_IP);\n \n   if (sockid == SOCKET_INVALID_ID) {\n     printf(\"[Failed\
    \ to create socket: %ld]\\n\", sockid);"
  - "--- a/app/wisun/example/wisun_soc_coap_collector/app.c\n+++ b/app/wisun/example/wisun_soc_coap_collector/app.c\n\
    @@ -63,10 +63,10 @@ void app_task(void *args)\n   (void) args;\n \n   // connect\
    \ to the wisun network\n-  app_wisun_connect_and_wait();\n+  sl_wisun_app_core_util_connect_and_wait();\n\
    \ \n   while (1) {\n-    app_wisun_dispatch_thread();\n+    sl_wisun_app_core_util_dispatch_thread();\n\
    \   }\n }\n "
  - "--- a/app/wisun/example/wisun_soc_coap_collector/app_init.c\n+++ b/app/wisun/example/wisun_soc_coap_collector/app_init.c\n\
    @@ -37,7 +37,7 @@\n #include \"sl_wisun_event_mgr.h\"\n #include \"sl_wisun_coap_collector.h\"\
    \n #include \"sl_wisun_app_core_util.h\"\n-#include \"sl_wisun_app_core_util_config.h\"\
    \n+#include \"sl_wisun_app_core_config.h\"\n #include \"app.h\"\n #include \"\
    app_custom_callback.h\"\n \n@@ -63,7 +63,7 @@\n void app_init(void)\n {\n   /*\
    \ Init project info */\n-  app_wisun_project_info_init(\"Wi-SUN CoAP Collector\
    \ Application\");\n+  sl_wisun_app_core_util_project_info_init(\"Wi-SUN CoAP Collector\
    \ Application\");\n \n   /* Init CoAP collector */\n   sl_wisun_coap_collector_init();\n\
    @@ -83,7 +83,7 @@ void app_init(void)\n     .cb_mem      = NULL,\n     .cb_size\
    \     = 0,\n     .stack_mem   = NULL,\n-    .stack_size  = app_stack_size_word_to_byte(APP_MAIN_STACK_SIZE_WORD),\n\
    +    .stack_size  = app_stack_size_word_to_byte(SL_WISUN_APP_CORE_MAIN_STACK_SIZE_WORD),\n\
    \     .priority    = osPriorityNormal,\n     .tz_module   = 0\n   };"
  - "--- a/app/wisun/example/wisun_soc_coap_meter/app.c\n+++ b/app/wisun/example/wisun_soc_coap_meter/app.c\n\
    @@ -66,13 +66,13 @@ void app_task(void *args)\n   (void) args;\n \n   // connect\
    \ to the wisun network\n-  app_wisun_connect_and_wait();\n+  sl_wisun_app_core_util_connect_and_wait();\n\
    \ \n   while (1) {\n #if !SL_WISUN_COAP_RESOURCE_HND_SERVICE_ENABLE\n     sl_wisun_meter_process();\n\
    \ #endif\n-    app_wisun_dispatch_thread();\n+    sl_wisun_app_core_util_dispatch_thread();\n\
    \   }\n }\n "
  - "--- a/app/wisun/example/wisun_soc_coap_meter/app_init.c\n+++ b/app/wisun/example/wisun_soc_coap_meter/app_init.c\n\
    @@ -38,11 +38,12 @@\n #include \"sl_wisun_event_mgr.h\"\n #include \"sl_wisun_coap_meter.h\"\
    \n #include \"sl_wisun_app_core_util.h\"\n-#include \"sl_wisun_app_core_util_config.h\"\
    \n+#include \"sl_wisun_app_core_config.h\"\n #include \"sl_wisun_coap_rhnd.h\"\
    \n #include \"sl_wisun_coap_meter_collector_config.h\"\n #include \"app.h\"\n\
    \ #include \"app_custom_callback.h\"\n+#include \"sl_component_catalog.h\"\n \n\
    \ // -----------------------------------------------------------------------------\n\
    \ //                              Macros and Typedefs\n@@ -89,7 +90,7 @@ void\
    \ app_init(void)\n   sl_wisun_coap_rhnd_resource_t coap_resource = { 0 };\n \n\
    \   // Init project info\n-  app_wisun_project_info_init(\"Wi-SUN CoAP Meter Application\"\
    );\n+  sl_wisun_app_core_util_project_info_init(\"Wi-SUN CoAP Meter Application\"\
    );\n \n   // Init meter collector\n   sl_wisun_coap_meter_init();\n@@ -126,14\
    \ +127,15 @@ void app_init(void)\n   coap_resource.auto_response          = sl_wisun_coap_meter_light_response_cb;\n\
    \   coap_resource.discoverable           = true;\n   assert(sl_wisun_coap_rhnd_resource_add(&coap_resource)\
    \ == SL_STATUS_OK);\n-\n+#if !defined(SL_CATALOG_POWER_MANAGER_PRESENT)\n   //\
    \ Init led resource\n   coap_resource.data.uri_path          = SL_WISUN_COAP_METER_COLLECTOR_LED_TOGGLE_URI_PATH;\n\
    \   coap_resource.data.resource_type     = SL_WISUN_COAP_METER_RESOURCE_RT_LED;\n\
    \   coap_resource.data.interface         = SL_WISUN_COAP_METER_RESOURCE_IF_LED;\n\
    \   coap_resource.auto_response          = sl_wisun_coap_meter_led_toggle_response_cb;\n\
    \   coap_resource.discoverable           = true;\n   assert(sl_wisun_coap_rhnd_resource_add(&coap_resource)\
    \ == SL_STATUS_OK);\n+#endif\n #else\n   // Init sensor all\n   coap_resource.data.uri_path\
    \          = SL_WISUN_COAP_METER_COLLECTOR_MEASUREMENT_URI_PATH;\n@@ -159,7 +161,7\
    \ @@ void app_init(void)\n     .cb_mem      = NULL,\n     .cb_size     = 0,\n\
    \     .stack_mem   = NULL,\n-    .stack_size  = app_stack_size_word_to_byte(APP_MAIN_STACK_SIZE_WORD),\n\
    +    .stack_size  = app_stack_size_word_to_byte(SL_WISUN_APP_CORE_MAIN_STACK_SIZE_WORD),\n\
    \     .priority    = osPriorityNormal,\n     .tz_module   = 0\n   };"
  - "--- a/app/wisun/example/wisun_soc_collector/app.c\n+++ b/app/wisun/example/wisun_soc_collector/app.c\n\
    @@ -59,10 +59,10 @@ void app_task(void *args)\n   (void) args;\n \n   // connect\
    \ to the wisun network\n-  app_wisun_connect_and_wait();\n+  sl_wisun_app_core_util_connect_and_wait();\n\
    \ \n   while (1) {\n-    app_wisun_dispatch_thread();\n+    sl_wisun_app_core_util_dispatch_thread();\n\
    \   }\n }\n "
  - "--- a/app/wisun/example/wisun_soc_collector/app_init.c\n+++ b/app/wisun/example/wisun_soc_collector/app_init.c\n\
    @@ -37,7 +37,7 @@\n #include \"sl_wisun_event_mgr.h\"\n #include \"sl_wisun_collector.h\"\
    \n #include \"sl_wisun_app_core_util.h\"\n-#include \"sl_wisun_app_core_util_config.h\"\
    \n+#include \"sl_wisun_app_core_config.h\"\n #include \"app.h\"\n #include \"\
    app_custom_callback.h\"\n \n@@ -63,7 +63,7 @@\n void app_init(void)\n {\n   /*\
    \ Init project info */\n-  app_wisun_project_info_init(\"Wi-SUN Collector Application\"\
    );\n+  sl_wisun_app_core_util_project_info_init(\"Wi-SUN Collector Application\"\
    );\n \n   /* Init collector component */\n   sl_wisun_collector_init();\n@@ -83,7\
    \ +83,7 @@ void app_init(void)\n     .cb_mem      = NULL,\n     .cb_size     =\
    \ 0,\n     .stack_mem   = NULL,\n-    .stack_size  = app_stack_size_word_to_byte(APP_MAIN_STACK_SIZE_WORD),\n\
    +    .stack_size  = app_stack_size_word_to_byte(SL_WISUN_APP_CORE_MAIN_STACK_SIZE_WORD),\n\
    \     .priority    = osPriorityNormal,\n     .tz_module   = 0\n   };"
  - "--- a/app/wisun/example/wisun_soc_empty/app.c\n+++ b/app/wisun/example/wisun_soc_empty/app.c\n\
    @@ -81,14 +81,14 @@ void app_task(void *args)\n \n #ifdef SL_CATALOG_WISUN_APP_CORE_PRESENT\n\
    \   // connect to the wisun network\n-  app_wisun_connect_and_wait();\n+  sl_wisun_app_core_util_connect_and_wait();\n\
    \ #endif\n \n   while (1) {\n     ///////////////////////////////////////////////////////////////////////////\n\
    \     // Put your application code here!                                     \
    \  //\n     ///////////////////////////////////////////////////////////////////////////\n\
    -    app_wisun_dispatch_thread();\n+    sl_wisun_app_core_util_dispatch_thread();\n\
    \   }\n }\n "
  - "--- a/app/wisun/example/wisun_soc_meter/app.c\n+++ b/app/wisun/example/wisun_soc_meter/app.c\n\
    @@ -64,12 +64,12 @@ void app_task(void *args)\n   (void) args;\n \n   // connect\
    \ to the wisun network\n-  app_wisun_connect_and_wait();\n+  sl_wisun_app_core_util_connect_and_wait();\n\
    \   printf(\"[Port: %u]\\n\", SL_WISUN_METER_PORT);\n \n   while (1) {\n     sl_wisun_meter_process();\n\
    -    app_wisun_dispatch_thread();\n+    sl_wisun_app_core_util_dispatch_thread();\n\
    \   }\n }\n "
  - "--- a/app/wisun/example/wisun_soc_meter/app_init.c\n+++ b/app/wisun/example/wisun_soc_meter/app_init.c\n\
    @@ -37,7 +37,7 @@\n #include \"sl_wisun_meter.h\"\n #include \"sl_wisun_event_mgr.h\"\
    \n #include \"sl_wisun_app_core_util.h\"\n-#include \"sl_wisun_app_core_util_config.h\"\
    \n+#include \"sl_wisun_app_core_config.h\"\n #include \"app.h\"\n #include \"\
    app_custom_callback.h\"\n \n@@ -63,7 +63,7 @@\n void app_init(void)\n {\n   /*\
    \ Init project info */\n-  app_wisun_project_info_init(\"Wi-SUN Meter Application\"\
    );\n+  sl_wisun_app_core_util_project_info_init(\"Wi-SUN Meter Application\");\n\
    \ \n   /* Init meter collector */\n   sl_wisun_meter_init();\n@@ -83,7 +83,7 @@\
    \ void app_init(void)\n     .cb_mem      = NULL,\n     .cb_size     = 0,\n   \
    \  .stack_mem   = NULL,\n-    .stack_size  = app_stack_size_word_to_byte(APP_MAIN_STACK_SIZE_WORD),\n\
    +    .stack_size  = app_stack_size_word_to_byte(SL_WISUN_APP_CORE_MAIN_STACK_SIZE_WORD),\n\
    \     .priority    = osPriorityNormal,\n     .tz_module   = 0\n   };"
  - "--- a/app/wisun/example/wisun_soc_network_measurement/app.c\n+++ b/app/wisun/example/wisun_soc_network_measurement/app.c\n\
    @@ -69,15 +69,15 @@ void app_task(void *args)\n   (void) args;\n \n   // connect\
    \ to the wisun network\n-  app_wisun_connect_and_wait();\n+  sl_wisun_app_core_util_connect_and_wait();\n\
    \ \n #if defined(SL_CATALOG_GUI_PRESENT)\n   sl_display_renderer(sl_wisun_nwm_main_form,\
    \ NULL, 0);\n #endif\n \n   while (1) {\n     // User code here\n-    app_wisun_dispatch_thread();\n\
    +    sl_wisun_app_core_util_dispatch_thread();\n   }\n }\n "
  - "--- a/app/wisun/example/wisun_soc_network_measurement/app_init.c\n+++ b/app/wisun/example/wisun_soc_network_measurement/app_init.c\n\
    @@ -37,7 +37,7 @@\n #include \"sl_cmsis_os2_common.h\"\n #include \"sl_wisun_app_core.h\"\
    \n #include \"sl_wisun_app_core_util.h\"\n-#include \"sl_wisun_app_core_util_config.h\"\
    \n+#include \"sl_wisun_app_core_config.h\"\n #include \"sl_wisun_network_measurement.h\"\
    \n #include \"sl_wisun_network_measurement_remote_ctrl.h\"\n #include \"sl_wisun_network_measurement_stat.h\"\
    \n@@ -95,7 +95,7 @@ void app_init(void)\n   sl_wisun_coap_rhnd_resource_t coap_resource\
    \ = { 0 };\n \n   // Init project info\n-  app_wisun_project_info_init(\"Wi-SUN\
    \ Network Measurement Application\");\n+  sl_wisun_app_core_util_project_info_init(\"\
    Wi-SUN Network Measurement Application\");\n \n #if defined(SL_CATALOG_GUI_PRESENT)\n\
    \   // Init display\n@@ -148,7 +148,7 @@ void app_init(void)\n     .cb_mem   \
    \   = NULL,\n     .cb_size     = 0,\n     .stack_mem   = NULL,\n-    .stack_size\
    \  = app_stack_size_word_to_byte(APP_MAIN_STACK_SIZE_WORD),\n+    .stack_size\
    \  = app_stack_size_word_to_byte(SL_WISUN_APP_CORE_MAIN_STACK_SIZE_WORD),\n  \
    \   .priority    = osPriorityNormal,\n     .tz_module   = 0\n   };"
  - "--- a/app/wisun/example/wisun_soc_ping/app.c\n+++ b/app/wisun/example/wisun_soc_ping/app.c\n\
    @@ -59,11 +59,11 @@ void app_task(void *args)\n   (void) args;\n \n   // connect\
    \ to the wisun network\n-  app_wisun_connect_and_wait();\n+  sl_wisun_app_core_util_connect_and_wait();\n\
    \ \n   while (1) {\n     // User code here\n-    app_wisun_dispatch_thread();\n\
    +    sl_wisun_app_core_util_dispatch_thread();\n   }\n }\n "
  - "--- a/app/wisun/example/wisun_soc_ping/app_init.c\n+++ b/app/wisun/example/wisun_soc_ping/app_init.c\n\
    @@ -36,7 +36,7 @@\n #include \"sl_cmsis_os2_common.h\"\n #include \"sl_wisun_event_mgr.h\"\
    \n #include \"sl_wisun_app_core_util.h\"\n-#include \"sl_wisun_app_core_util_config.h\"\
    \n+#include \"sl_wisun_app_core_config.h\"\n #include \"app.h\"\n #include \"\
    app_custom_callback.h\"\n \n@@ -62,7 +62,7 @@\n void app_init(void)\n {\n   /*\
    \ Init project info */\n-  app_wisun_project_info_init(\"Wi-SUN Ping Application\"\
    );\n+  sl_wisun_app_core_util_project_info_init(\"Wi-SUN Ping Application\");\n\
    \ \n   /* Register callbacks */\n   app_wisun_em_custom_callback_register(SL_WISUN_MSG_CONNECTED_IND_ID,\n\
    @@ -79,7 +79,7 @@ void app_init(void)\n     .cb_mem      = NULL,\n     .cb_size\
    \     = 0,\n     .stack_mem   = NULL,\n-    .stack_size  = app_stack_size_word_to_byte(APP_MAIN_STACK_SIZE_WORD),\n\
    +    .stack_size  = app_stack_size_word_to_byte(SL_WISUN_APP_CORE_MAIN_STACK_SIZE_WORD),\n\
    \     .priority    = osPriorityNormal,\n     .tz_module   = 0\n   };"
  - "--- a/app/wisun/example/wisun_soc_tcp_client/app.c\n+++ b/app/wisun/example/wisun_soc_tcp_client/app.c\n\
    @@ -61,11 +61,11 @@ void app_task(void *args)\n   (void) args;\n \n   // connect\
    \ to the wisun network\n-  app_wisun_connect_and_wait();\n+  sl_wisun_app_core_util_connect_and_wait();\n\
    \ \n   while (1) {\n     // User code here\n-    app_wisun_dispatch_thread();\n\
    +    sl_wisun_app_core_util_dispatch_thread();\n   }\n }\n "
  - "--- a/app/wisun/example/wisun_soc_tcp_client/app_init.c\n+++ b/app/wisun/example/wisun_soc_tcp_client/app_init.c\n\
    @@ -36,7 +36,7 @@\n #include \"sl_cmsis_os2_common.h\"\n #include \"sl_wisun_event_mgr.h\"\
    \n #include \"sl_wisun_app_core_util.h\"\n-#include \"sl_wisun_app_core_util_config.h\"\
    \n+#include \"sl_wisun_app_core_config.h\"\n #include \"app.h\"\n #include \"\
    app_custom_callback.h\"\n \n@@ -62,7 +62,7 @@\n void app_init(void)\n {\n   /*\
    \ Init project info */\n-  app_wisun_project_info_init(\"Wi-SUN TCP Client Application\"\
    );\n+  sl_wisun_app_core_util_project_info_init(\"Wi-SUN TCP Client Application\"\
    );\n \n   /* Register callbacks */\n   app_wisun_em_custom_callback_register(SL_WISUN_MSG_CONNECTED_IND_ID,\n\
    @@ -79,7 +79,7 @@ void app_init(void)\n     .cb_mem      = NULL,\n     .cb_size\
    \     = 0,\n     .stack_mem   = NULL,\n-    .stack_size  = app_stack_size_word_to_byte(APP_MAIN_STACK_SIZE_WORD),\n\
    +    .stack_size  = app_stack_size_word_to_byte(SL_WISUN_APP_CORE_MAIN_STACK_SIZE_WORD),\n\
    \     .priority    = osPriorityNormal,\n     .tz_module   = 0\n   };"
  - "--- a/app/wisun/example/wisun_soc_tcp_server/app.c\n+++ b/app/wisun/example/wisun_soc_tcp_server/app.c\n\
    @@ -33,6 +33,7 @@\n #include <stdio.h>\n #include <assert.h>\n #include \"app.h\"\
    \n+#include \"sl_wisun_trace_util.h\"\n \n // -----------------------------------------------------------------------------\n\
    \ //                              Macros and Typedefs\n@@ -69,7 +70,7 @@ void\
    \ app_task(void *args)\n   (void) args;\n \n   // connect to the wisun network\n\
    -  app_wisun_connect_and_wait();\n+  sl_wisun_app_core_util_connect_and_wait();\n\
    \   printf(\"[Port: %u]\\n\", SL_WISUN_TCP_SERVER_PORT);\n \n   // creating socket\n\
    @@ -110,7 +111,7 @@ void app_task(void *args)\n       r = recv(sockd_tcp_clnt,\
    \ buff, SL_WISUN_TCP_SERVER_BUFF_SIZE - 1, 0);\n       switch (r) {\n        \
    \ case -1:\n-          app_wisun_dispatch_thread();\n+          sl_wisun_app_core_util_dispatch_thread();\n\
    \           continue;\n         case 0: // scoket closed, EOF\n           printf(\"\
    [Socket closing: %ld]\\n\", sockd_tcp_clnt);\n@@ -131,7 +132,7 @@ void app_task(void\
    \ *args)\n           break;\n       }\n       // dispatch thread\n-      app_wisun_dispatch_thread();\n\
    +      sl_wisun_app_core_util_dispatch_thread();\n     }\n   }\n }"
  - "--- a/app/wisun/example/wisun_soc_tcp_server/app_init.c\n+++ b/app/wisun/example/wisun_soc_tcp_server/app_init.c\n\
    @@ -37,7 +37,7 @@\n #include \"sl_cmsis_os2_common.h\"\n #include \"sl_wisun_event_mgr.h\"\
    \n #include \"sl_wisun_app_core_util.h\"\n-#include \"sl_wisun_app_core_util_config.h\"\
    \n+#include \"sl_wisun_app_core_config.h\"\n #include \"app.h\"\n #include \"\
    app_custom_callback.h\"\n \n@@ -63,7 +63,7 @@\n void app_init(void)\n {\n   /*\
    \ Init project info */\n-  app_wisun_project_info_init(\"Wi-SUN TCP Server Application\"\
    );\n+  sl_wisun_app_core_util_project_info_init(\"Wi-SUN TCP Server Application\"\
    );\n \n   /* Register callbacks */\n   app_wisun_em_custom_callback_register(SL_WISUN_MSG_CONNECTED_IND_ID,\n\
    @@ -82,7 +82,7 @@ void app_init(void)\n     .cb_mem      = NULL,\n     .cb_size\
    \     = 0,\n     .stack_mem   = NULL,\n-    .stack_size  = app_stack_size_word_to_byte(APP_MAIN_STACK_SIZE_WORD),\n\
    +    .stack_size  = app_stack_size_word_to_byte(SL_WISUN_APP_CORE_MAIN_STACK_SIZE_WORD),\n\
    \     .priority    = osPriorityNormal,\n     .tz_module   = 0\n   };"
  - "--- a/app/wisun/example/wisun_soc_udp_client/app.c\n+++ b/app/wisun/example/wisun_soc_udp_client/app.c\n\
    @@ -61,11 +61,11 @@ void app_task(void *args)\n   (void) args;\n \n   // connect\
    \ to the wisun network\n-  app_wisun_connect_and_wait();\n+  sl_wisun_app_core_util_connect_and_wait();\n\
    \ \n   while (1) {\n     // User code here\n-    app_wisun_dispatch_thread();\n\
    +    sl_wisun_app_core_util_dispatch_thread();\n   }\n }\n "
  - "--- a/app/wisun/example/wisun_soc_udp_client/app_init.c\n+++ b/app/wisun/example/wisun_soc_udp_client/app_init.c\n\
    @@ -37,7 +37,7 @@\n #include \"sl_cmsis_os2_common.h\"\n #include \"sl_wisun_event_mgr.h\"\
    \n #include \"sl_wisun_app_core_util.h\"\n-#include \"sl_wisun_app_core_util_config.h\"\
    \n+#include \"sl_wisun_app_core_config.h\"\n #include \"app.h\"\n #include \"\
    app_custom_callback.h\"\n \n@@ -63,7 +63,7 @@\n void app_init(void)\n {\n   /*\
    \ Init project info */\n-  app_wisun_project_info_init(\"Wi-SUN UDP Client Application\"\
    );\n+  sl_wisun_app_core_util_project_info_init(\"Wi-SUN UDP Client Application\"\
    );\n \n   /* Register callbacks */\n   app_wisun_em_custom_callback_register(SL_WISUN_MSG_CONNECTED_IND_ID,\n\
    @@ -80,7 +80,7 @@ void app_init(void)\n     .cb_mem      = NULL,\n     .cb_size\
    \     = 0,\n     .stack_mem   = NULL,\n-    .stack_size  = app_stack_size_word_to_byte(APP_MAIN_STACK_SIZE_WORD),\n\
    +    .stack_size  = app_stack_size_word_to_byte(SL_WISUN_APP_CORE_MAIN_STACK_SIZE_WORD),\n\
    \     .priority    = osPriorityNormal,\n     .tz_module   = 0\n   };"
  - "--- a/app/wisun/example/wisun_soc_udp_server/app.c\n+++ b/app/wisun/example/wisun_soc_udp_server/app.c\n\
    @@ -33,6 +33,7 @@\n #include <stdio.h>\n #include <assert.h>\n #include \"app.h\"\
    \n+#include \"sl_wisun_trace_util.h\"\n \n // -----------------------------------------------------------------------------\n\
    \ //                              Macros and Typedefs\n@@ -67,11 +68,11 @@ void\
    \ app_task(void *args)\n   (void) args;\n \n   // connect to the wisun network\n\
    -  app_wisun_connect_and_wait();\n+  sl_wisun_app_core_util_connect_and_wait();\n\
    \   printf(\"[Port: %u]\\n\", SL_WISUN_UDP_SERVER_PORT);\n \n   // creating socket\n\
    -  sockd_udp_srv = socket(AF_INET6, (SOCK_DGRAM | SOCK_NONBLOCK), IPPROTO_UDP);\n\
    +  sockd_udp_srv = socket(AF_INET6, SOCK_DGRAM, IPPROTO_UDP);\n   assert_res(sockd_udp_srv,\
    \ \"UDP server socket()\");\n \n   // fill the server address structure\n@@ -100,7\
    \ +101,7 @@ void app_task(void *args)\n       }\n     }\n     // dispatch thread\n\
    -    app_wisun_dispatch_thread();\n+    sl_wisun_app_core_util_dispatch_thread();\n\
    \   }\n }\n "
  - "--- a/app/wisun/example/wisun_soc_udp_server/app_init.c\n+++ b/app/wisun/example/wisun_soc_udp_server/app_init.c\n\
    @@ -37,7 +37,7 @@\n #include \"sl_cmsis_os2_common.h\"\n #include \"sl_wisun_event_mgr.h\"\
    \n #include \"sl_wisun_app_core_util.h\"\n-#include \"sl_wisun_app_core_util_config.h\"\
    \n+#include \"sl_wisun_app_core_config.h\"\n #include \"app.h\"\n #include \"\
    app_custom_callback.h\"\n \n@@ -63,7 +63,7 @@\n void app_init(void)\n {\n   /*\
    \ Init project info */\n-  app_wisun_project_info_init(\"Wi-SUN UDP Server Application\"\
    );\n+  sl_wisun_app_core_util_project_info_init(\"Wi-SUN UDP Server Application\"\
    );\n \n   /* Register callbacks */\n   app_wisun_em_custom_callback_register(SL_WISUN_MSG_CONNECTED_IND_ID,\n\
    @@ -80,7 +80,7 @@ void app_init(void)\n     .cb_mem      = NULL,\n     .cb_size\
    \     = 0,\n     .stack_mem   = NULL,\n-    .stack_size  = app_stack_size_word_to_byte(APP_MAIN_STACK_SIZE_WORD),\n\
    +    .stack_size  = app_stack_size_word_to_byte(SL_WISUN_APP_CORE_MAIN_STACK_SIZE_WORD),\n\
    \     .priority    = osPriorityNormal,\n     .tz_module   = 0\n   };"
  identifiers: CVE:["CVE-2024-22473"],CWE:["CWE-908"]
  overview: Affected versions of this package are vulnerable to Use of Uninitialized
    Resource due to the improper implementation of TRNG functionality by the ECDSA
    signing driver when exiting EM2/EM3 modes on Virtual Secure Vault (VSE) devices.
    An attacker can spoof signatures by recreating keys, which are trusted if invoked
    before calling `psa_generate_random` or `psa_generate_key`.
  references:
    GitHub Commit: https://github.com/SiliconLabs/gecko_sdk/commit/911f6cdefccbae03bc66e8c790ceb7e67ca07417
    Vulnerability Advisory: https://community.silabs.com/068Vm000001FrjT
  title: Use of Uninitialized Resource
- diff_content:
  - "--- a/services/std_svc/sdei/sdei_main.c\n+++ b/services/std_svc/sdei/sdei_main.c\n\
    @@ -710,8 +710,8 @@ static int sdei_interrupt_bind(unsigned int intr_num)\n \t\
    sdei_ev_map_t *map;\n \tbool retry = true, shared_mapping;\n \n-\t/* SGIs are\
    \ not allowed to be bound */\n-\tif (plat_ic_is_sgi(intr_num) != 0)\n+\t/* Interrupt\
    \ must be either PPI or SPI */\n+\tif (!(plat_ic_is_ppi(intr_num) || plat_ic_is_spi(intr_num)))\n\
    \ \t\treturn SDEI_EINVAL;\n \n \tshared_mapping = (plat_ic_is_spi(intr_num) !=\
    \ 0);"
  identifiers: CVE:["CVE-2023-49100"],CWE:["CWE-125"]
  overview: Affected versions of this package are vulnerable to Out-of-bounds Read
    due to insufficient validation in the `sdei_interrupt_bind` function of the parameter
    in register x1. This parameter is then passed to a call to `plat_ic_get_interrupt_type`,
    allowing it to be any arbitrary value that passes checks in the `plat_ic_is_sgi`
    function. A compromised Normal World (Linux kernel) can enable a root-privileged
    attacker to issue arbitrary SMC calls, controlling the content of registers x0
    through x6, which are used to send parameters to TF-A. Out-of-bounds addresses
    can be read in the context of TF-A (EL3). Although the read value is never returned
    to non-secure memory or in registers, preventing a leak, an attacker can still
    crash TF-A.
  references:
    GitHub Commit: https://github.com/ARM-software/arm-trusted-firmware/commit/a7eff3477dcf3624c74f5217419b1a27b7ebd2aa
    Vulnerability Advisory: https://trustedfirmware-a.readthedocs.io/en/latest/security_advisories/security-advisory-tfv-11.html#advisory-tfv-11-cve-2023-49100
    Vulnerable Code: https://github.com/ARM-software/arm-trusted-firmware/blob/a05414bedc9b1cc35cf0795ce641b6b4db5bc97e/services/std_svc/sdei/sdei_main.c#L714
  title: Out-of-bounds Read
- diff_content:
  - "--- a/examples/server/server.c\n+++ b/examples/server/server.c\n@@ -3392,7 +3392,14\
    \ @@ THREAD_RETURN WOLFSSL_THREAD server_test(void* args)\n             } while\
    \ (err == WC_PENDING_E);\n         }\n #else\n-        (void)nonBlocking;\n+ \
    \       if (nonBlocking) {\n+            #ifdef WOLFSSL_DTLS\n+            if\
    \ (doDTLS) {\n+                wolfSSL_dtls_set_using_nonblock(ssl, 1);\n+   \
    \         }\n+            #endif\n+            tcp_set_nonblocking(&clientfd);\n\
    +        }\n         ret = NonBlockingSSL_Accept(ssl);\n #endif\n #ifdef WOLFSSL_EARLY_DATA"
  - "--- a/src/internal.c\n+++ b/src/internal.c\n@@ -26872,7 +26872,7 @@ int PickHashSigAlgo(WOLFSSL*\
    \ ssl, const byte* hashSigAlgo, word32 hashSigAlgoSz)\n             /* add data,\
    \ put in buffer if bigger than static buffer */\n             info->packets[info->numberPackets].valueSz\
    \ = totalSz;\n             if (totalSz < MAX_VALUE_SZ) {\n-                XMEMCPY(info->packets[info->numberPackets].value,\
    \ data + lateRL,\n+                XMEMCPY(info->packets[info->numberPackets].value\
    \ + lateRL, data,\n                                sz);\n             }\n    \
    \         else {"
  identifiers: CVE:["CVE-2023-6936"],CWE:["CWE-126"]
  overview: Affected versions of this package are vulnerable to Buffer Over-read when
    callback functions are enabled through the optional `WOLFSSL_CALLBACKS` flag.
    An attacker can read 5 bytes from the heap via malicious TLS 1.3 connection.
  references:
    GitHub Commit: https://github.com/wolfSSL/wolfssl/commit/2b1c61a013a2f583160decca97540c5cd3be9abb
    GitHub PR: https://github.com/wolfSSL/wolfssl/pull/6949/
  title: Buffer Over-read
- diff_content:
  - '--- a/test/unittests/test_openssl_misc.cpp

    +++ b/test/unittests/test_openssl_misc.cpp

    @@ -0,0 +1,123 @@

    +#include "test_common.h"

    +#include <iostream>

    +

    +#include <openvpn/openssl/sign/verify.hpp>

    +#include <openvpn/openssl/sign/pkcs7verify.hpp>

    +#include <openvpn/ssl/sslchoose.hpp>

    +

    +using namespace openvpn;

    +

    +constexpr const char *broken_pkcs7 = "-----BEGIN PKCS7-----\n"

    +                                     "MAsGCSqGSIb3DQEHAg==\n"

    +                                     "-----END PKCS7-----\n";

    +

    +constexpr const char *unit_test_ca = "-----BEGIN CERTIFICATE-----\n"

    +                                     "MIIBuTCCAUCgAwIBAgIUTLtjSBzx53qZRvZ6Ur7D9kgoOHkwCgYIKoZIzj0EAwIw\n"

    +                                     "EzERMA8GA1UEAwwIdW5pdHRlc3QwIBcNMjMxMTIxMDk1NDQ3WhgPMjA3ODA4MjQw\n"

    +                                     "OTU0NDdaMBMxETAPBgNVBAMMCHVuaXR0ZXN0MHYwEAYHKoZIzj0CAQYFK4EEACID\n"

    +                                     "YgAEHYB2hn2xx3f4lClXDtdi36P19pMZA+kI1Dkv/Vn10vBZ/j9oa+P99T8duz/e\n"

    +                                     "QlPeHpesNJO4fX8iEDj6+vMeWejOT7jAQ4MmG5EZjpcBKxCfwFooEvzu8bVujUcu\n"

    +                                     "wTQEo1MwUTAdBgNVHQ4EFgQUPcgBEVXjF5vYfDsInoE3dF6UfQswHwYDVR0jBBgw\n"

    +                                     "FoAUPcgBEVXjF5vYfDsInoE3dF6UfQswDwYDVR0TAQH/BAUwAwEB/zAKBggqhkjO\n"

    +                                     "PQQDAgNnADBkAjBLPAGrQAyinigqiu0RomoV8TVaknVLFSq6H6A8jgvzfsFCUK1O\n"

    +                                     "dvNZhFPM6idKB+oCME2JLOBANCSV8o7aJzq7SYHKwPyb1J4JFlwKe/0Jpv7oh9b1\n"

    +                                     "IJbuaM9Z/VSKbrIXGg==\n"

    +                                     "-----END CERTIFICATE-----\n";

    +

    +

    +constexpr const char *unit_test_ca_key [[maybe_unused]] = "-----BEGIN PRIVATE
    KEY-----\n"

    +                                                          "MIG2AgEAMBAGByqGSM49AgEGBSuBBAAiBIGeMIGbAgEBBDCJ92tBE1WmpBkPwgcN\n"

    +                                                          "5xJ93tVilpsS5hi22V/VIGpCwKplSzTdB61TkB5RRWuQMAuhZANiAAQdgHaGfbHH\n"

    +                                                          "d/iUKVcO12Lfo/X2kxkD6QjUOS/9WfXS8Fn+P2hr4/31Px27P95CU94el6w0k7h9\n"

    +                                                          "fyIQOPr68x5Z6M5PuMBDgyYbkRmOlwErEJ/AWigS/O7xtW6NRy7BNAQ=\n"

    +                                                          "-----END PRIVATE KEY-----\n";

    +

    +/* first stanza of a German children''s song for Saint Martin */

    +constexpr const char *laterne = "Laterne, Laterne, Sonne, Mond und Sterne,\n"

    +                                "brenne auf mein Licht,\n"

    +                                "brenne auf mein Licht,\n"

    +                                "aber du, meine Liebe Laterne, nicht.\n";

    +

    +

    +// created used openssl smime -in laterne --binary -sign -signer unittest.pem
    -inkey unittest.pem  -outform pem

    +constexpr const char *laterne_sig = "-----BEGIN PKCS7-----\n"

    +                                    "MIIDmAYJKoZIhvcNAQcCoIIDiTCCA4UCAQExDzANBglghkgBZQMEAgEFADALBgkq\n"

    +                                    "hkiG9w0BBwGgggG9MIIBuTCCAUCgAwIBAgIUTLtjSBzx53qZRvZ6Ur7D9kgoOHkw\n"

    +                                    "CgYIKoZIzj0EAwIwEzERMA8GA1UEAwwIdW5pdHRlc3QwIBcNMjMxMTIxMDk1NDQ3\n"

    +                                    "WhgPMjA3ODA4MjQwOTU0NDdaMBMxETAPBgNVBAMMCHVuaXR0ZXN0MHYwEAYHKoZI\n"

    +                                    "zj0CAQYFK4EEACIDYgAEHYB2hn2xx3f4lClXDtdi36P19pMZA+kI1Dkv/Vn10vBZ\n"

    +                                    "/j9oa+P99T8duz/eQlPeHpesNJO4fX8iEDj6+vMeWejOT7jAQ4MmG5EZjpcBKxCf\n"

    +                                    "wFooEvzu8bVujUcuwTQEo1MwUTAdBgNVHQ4EFgQUPcgBEVXjF5vYfDsInoE3dF6U\n"

    +                                    "fQswHwYDVR0jBBgwFoAUPcgBEVXjF5vYfDsInoE3dF6UfQswDwYDVR0TAQH/BAUw\n"

    +                                    "AwEB/zAKBggqhkjOPQQDAgNnADBkAjBLPAGrQAyinigqiu0RomoV8TVaknVLFSq6\n"

    +                                    "H6A8jgvzfsFCUK1OdvNZhFPM6idKB+oCME2JLOBANCSV8o7aJzq7SYHKwPyb1J4J\n"

    +                                    "FlwKe/0Jpv7oh9b1IJbuaM9Z/VSKbrIXGjGCAZ8wggGbAgEBMCswEzERMA8GA1UE\n"

    +                                    "AwwIdW5pdHRlc3QCFEy7Y0gc8ed6mUb2elK+w/ZIKDh5MA0GCWCGSAFlAwQCAQUA\n"

    +                                    "oIHkMBgGCSqGSIb3DQEJAzELBgkqhkiG9w0BBwEwHAYJKoZIhvcNAQkFMQ8XDTIz\n"

    +                                    "MTEyMTExNTYxOFowLwYJKoZIhvcNAQkEMSIEIL6nbAP3MXDvmWwGIpts8nUoOyHn\n"

    +                                    "aDA9IjR3QooF/IYvMHkGCSqGSIb3DQEJDzFsMGowCwYJYIZIAWUDBAEqMAsGCWCG\n"

    +                                    "SAFlAwQBFjALBglghkgBZQMEAQIwCgYIKoZIhvcNAwcwDgYIKoZIhvcNAwICAgCA\n"

    +                                    "MA0GCCqGSIb3DQMCAgFAMAcGBSsOAwIHMA0GCCqGSIb3DQMCAgEoMAoGCCqGSM49\n"

    +                                    "BAMCBGcwZQIwGjRweguw3AXhfSBu4czIiOk/kdncLIAzz0S78YURt5wYlbHSnMuO\n"

    +                                    "YSNyVn97Uc+UAjEA6+tj2o1i42yiF5WNMp/92QtfCV7TZE3ssiLxqst2aqlIY29H\n"

    +                                    "G9j5hdY2ZRkhUCHL\n"

    +                                    "-----END PKCS7-----";

    +

    +// created used openssl smime -in laterne --binary -sign -signer unittest.pem
    -inkey unittest.pem  -outform pem -nodetach

    +constexpr const char *laterne_signd = "-----BEGIN PKCS7-----\n"

    +                                      "MIIEGwYJKoZIhvcNAQcCoIIEDDCCBAgCAQExDzANBglghkgBZQMEAgEFADCBjAYJ\n"

    +                                      "KoZIhvcNAQcBoH8EfUxhdGVybmUsIExhdGVybmUsIFNvbm5lLCBNb25kIHVuZCBT\n"

    +                                      "dGVybmUsCmJyZW5uZSBhdWYgbWVpbiBMaWNodCwKYnJlbm5lIGF1ZiBtZWluIExp\n"

    +                                      "Y2h0LAphYmVyIGR1LCBtZWluZSBMaWViZSBMYXRlcm5lLCBuaWNodC4KoIIBvTCC\n"

    +                                      "AbkwggFAoAMCAQICFEy7Y0gc8ed6mUb2elK+w/ZIKDh5MAoGCCqGSM49BAMCMBMx\n"

    +                                      "ETAPBgNVBAMMCHVuaXR0ZXN0MCAXDTIzMTEyMTA5NTQ0N1oYDzIwNzgwODI0MDk1\n"

    +                                      "NDQ3WjATMREwDwYDVQQDDAh1bml0dGVzdDB2MBAGByqGSM49AgEGBSuBBAAiA2IA\n"

    +                                      "BB2AdoZ9scd3+JQpVw7XYt+j9faTGQPpCNQ5L/1Z9dLwWf4/aGvj/fU/Hbs/3kJT\n"

    +                                      "3h6XrDSTuH1/IhA4+vrzHlnozk+4wEODJhuRGY6XASsQn8BaKBL87vG1bo1HLsE0\n"

    +                                      "BKNTMFEwHQYDVR0OBBYEFD3IARFV4xeb2Hw7CJ6BN3RelH0LMB8GA1UdIwQYMBaA\n"

    +                                      "FD3IARFV4xeb2Hw7CJ6BN3RelH0LMA8GA1UdEwEB/wQFMAMBAf8wCgYIKoZIzj0E\n"

    +                                      "AwIDZwAwZAIwSzwBq0AMop4oKortEaJqFfE1WpJ1SxUquh+gPI4L837BQlCtTnbz\n"

    +                                      "WYRTzOonSgfqAjBNiSzgQDQklfKO2ic6u0mBysD8m9SeCRZcCnv9Cab+6IfW9SCW\n"

    +                                      "7mjPWf1Uim6yFxoxggGgMIIBnAIBATArMBMxETAPBgNVBAMMCHVuaXR0ZXN0AhRM\n"

    +                                      "u2NIHPHneplG9npSvsP2SCg4eTANBglghkgBZQMEAgEFAKCB5DAYBgkqhkiG9w0B\n"

    +                                      "CQMxCwYJKoZIhvcNAQcBMBwGCSqGSIb3DQEJBTEPFw0yMzExMjExMTU5MzZaMC8G\n"

    +                                      "CSqGSIb3DQEJBDEiBCC+p2wD9zFw75lsBiKbbPJ1KDsh52gwPSI0d0KKBfyGLzB5\n"

    +                                      "BgkqhkiG9w0BCQ8xbDBqMAsGCWCGSAFlAwQBKjALBglghkgBZQMEARYwCwYJYIZI\n"

    +                                      "AWUDBAECMAoGCCqGSIb3DQMHMA4GCCqGSIb3DQMCAgIAgDANBggqhkiG9w0DAgIB\n"

    +                                      "QDAHBgUrDgMCBzANBggqhkiG9w0DAgIBKDAKBggqhkjOPQQDAgRoMGYCMQD7s/oo\n"

    +                                      "MspfBQyDQ3RbEmJnub3d0JQjVFJjpSuQZuFfR4tn061LM0txurggtkCLU3MCMQCl\n"

    +                                      "rkK0zZs3G7UH2W4XXmzBQsfYGooTSyt5hASTo14xnA8GssngKQcztjxQ19nIic0=\n"

    +                                      "-----END PKCS7-----";

    +

    +

    +TEST(OpenSSL, verify_broken_pkcs7)

    +{

    +    std::list<OpenSSLPKI::X509> certs;

    +

    +    certs.emplace_back(unit_test_ca, "unit test certificate");

    +

    +    const std::string ident = "nothing to see here";

    +

    +    OVPN_EXPECT_THROW(

    +        OpenSSLSign::verify_pkcs7(certs, broken_pkcs7, ident),

    +        OpenSSLException,

    +        "OpenSSLSign::verify_pkcs7: verification failed");

    +}

    +

    +TEST(OpenSSL, verify_valid_pkcs7)

    +{

    +    std::list<OpenSSLPKI::X509> certs;

    +

    +    certs.emplace_back(unit_test_ca, "unit test certificate");

    +

    +    EXPECT_NO_THROW(OpenSSLSign::verify_pkcs7(certs, laterne_sig, laterne));

    +}

    +

    +TEST(OpenSSL, verify_nodetach_pkcs7)

    +{

    +    std::list<OpenSSLPKI::X509> certs;

    +

    +    certs.emplace_back(unit_test_ca, "unit test certificate");

    +

    +    EXPECT_NO_THROW(OpenSSLSign::verify_pkcs7(certs, laterne_signd, laterne));

    +}

    \ No newline at end of file'
  identifiers: CVE:["CVE-2023-6247"],CWE:["CWE-476"]
  overview: Affected versions of this package are vulnerable to NULL Pointer Dereference
    due to improper validation of parsed data in the PKCS#7 parser. An attacker can
    cause the application to crash by submitting specially crafted data.
  references:
    GitHub Commit: https://github.com/OpenVPN/openvpn3/commit/afdfe1bb3f4c54e8794
    Vulnerability Advisory: https://community.openvpn.net/openvpn/wiki/CVE-2023-6247
  title: NULL Pointer Dereference
- diff_content:
  - "--- a/crypto/rsa/rsa_ossl.c\n+++ b/crypto/rsa/rsa_ossl.c\n@@ -17,6 +17,9 @@\n\
    \ #include \"crypto/bn.h\"\n #include \"rsa_local.h\"\n #include \"internal/constant_time.h\"\
    \n+#include <openssl/evp.h>\n+#include <openssl/sha.h>\n+#include <openssl/hmac.h>\n\
    \ \n static int rsa_ossl_public_encrypt(int flen, const unsigned char *from,\n\
    \                                   unsigned char *to, RSA *rsa, int padding);\n\
    @@ -372,8 +375,13 @@ static int rsa_ossl_private_decrypt(int flen, const unsigned\
    \ char *from,\n     BIGNUM *f, *ret;\n     int j, num = 0, r = -1;\n     unsigned\
    \ char *buf = NULL;\n+    unsigned char d_hash[SHA256_DIGEST_LENGTH] = {0};\n\
    +    HMAC_CTX *hmac = NULL;\n+    unsigned int md_len = SHA256_DIGEST_LENGTH;\n\
    +    unsigned char kdk[SHA256_DIGEST_LENGTH] = {0};\n     BN_CTX *ctx = NULL;\n\
    \     int local_blinding = 0;\n+    EVP_MD *md = NULL;\n     /*\n      * Used\
    \ only if the blinding structure is shared. A non-NULL unblind\n      * instructs\
    \ rsa_blinding_convert() and rsa_blinding_invert() to store\n@@ -405,6 +413,11\
    \ @@ static int rsa_ossl_private_decrypt(int flen, const unsigned char *from,\n\
    \         goto err;\n     }\n \n+    if (flen < 1) {\n+        ERR_raise(ERR_LIB_RSA,\
    \ RSA_R_DATA_TOO_SMALL);\n+        goto err;\n+    }\n+\n     /* make data into\
    \ a big number */\n     if (BN_bin2bn(from, (int)flen, f) == NULL)\n         goto\
    \ err;\n@@ -471,13 +484,91 @@ static int rsa_ossl_private_decrypt(int flen, const\
    \ unsigned char *from,\n         if (!rsa_blinding_invert(blinding, ret, unblind,\
    \ ctx))\n             goto err;\n \n+    /*\n+     * derive the Key Derivation\
    \ Key from private exponent and public\n+     * ciphertext\n+     */\n+    if\
    \ (!(rsa->flags & RSA_FLAG_EXT_PKEY)) {\n+        /*\n+         * because we use\
    \ d as a handle to rsa->d we need to keep it local and\n+         * free before\
    \ any further use of rsa->d\n+         */\n+        BIGNUM *d = BN_new();\n+ \
    \       if (d == NULL) {\n+            ERR_raise(ERR_LIB_RSA, ERR_R_MALLOC_FAILURE);\n\
    +            goto err;\n+        }\n+        if (rsa->d == NULL) {\n+        \
    \    ERR_raise(ERR_LIB_RSA, RSA_R_MISSING_PRIVATE_KEY);\n+            BN_free(d);\n\
    +            goto err;\n+        }\n+        BN_with_flags(d, rsa->d, BN_FLG_CONSTTIME);\n\
    +        if (BN_bn2binpad(d, buf, num) < 0) {\n+            ERR_raise(ERR_LIB_RSA,\
    \ ERR_R_INTERNAL_ERROR);\n+            BN_free(d);\n+            goto err;\n+\
    \        }\n+        BN_free(d);\n+\n+        /*\n+         * we use hardcoded\
    \ hash so that migrating between versions that use\n+         * different hash\
    \ doesn't provide a Bleichenbacher oracle:\n+         * if the attacker can see\
    \ that different versions return different\n+         * messages for the same\
    \ ciphertext, they'll know that the message is\n+         * syntethically generated,\
    \ which means that the padding check failed\n+         */\n+        md = EVP_MD_fetch(rsa->libctx,\
    \ \"sha256\", NULL);\n+        if (md == NULL) {\n+            ERR_raise(ERR_LIB_RSA,\
    \ ERR_R_INTERNAL_ERROR);\n+            goto err;\n+        }\n+\n+        if (EVP_Digest(buf,\
    \ num, d_hash, NULL, md, NULL) <= 0) {\n+            ERR_raise(ERR_LIB_RSA, ERR_R_INTERNAL_ERROR);\n\
    +            goto err;\n+        }\n+\n+        hmac = HMAC_CTX_new();\n+    \
    \    if (hmac == NULL) {\n+            ERR_raise(ERR_LIB_RSA, ERR_R_MALLOC_FAILURE);\n\
    +            goto err;\n+        }\n+\n+        if (HMAC_Init_ex(hmac, d_hash,\
    \ sizeof(d_hash), md, NULL) <= 0) {\n+            ERR_raise(ERR_LIB_RSA, ERR_R_INTERNAL_ERROR);\n\
    +            goto err;\n+        }\n+\n+        if (flen < num) {\n+         \
    \   memset(buf, 0, num - flen);\n+            if (HMAC_Update(hmac, buf, num -\
    \ flen) <= 0) {\n+                ERR_raise(ERR_LIB_RSA, ERR_R_INTERNAL_ERROR);\n\
    +                goto err;\n+            }\n+        }\n+        if (HMAC_Update(hmac,\
    \ from, flen) <= 0) {\n+            ERR_raise(ERR_LIB_RSA, ERR_R_INTERNAL_ERROR);\n\
    +            goto err;\n+        }\n+\n+        md_len = SHA256_DIGEST_LENGTH;\n\
    +        if (HMAC_Final(hmac, kdk, &md_len) <= 0) {\n+            ERR_raise(ERR_LIB_RSA,\
    \ ERR_R_INTERNAL_ERROR);\n+            goto err;\n+        }\n+    }\n+\n    \
    \ j = BN_bn2binpad(ret, buf, num);\n     if (j < 0)\n         goto err;\n \n \
    \    switch (padding) {\n     case RSA_PKCS1_PADDING:\n-        r = RSA_padding_check_PKCS1_type_2(to,\
    \ num, buf, j, num);\n+        if (rsa->flags & RSA_FLAG_EXT_PKEY)\n+        \
    \    r = RSA_padding_check_PKCS1_type_2(to, num, buf, j, num);\n+        else\n\
    +            r = ossl_rsa_padding_check_PKCS1_type_2(rsa->libctx, to, num, buf,\
    \ j, num, kdk);\n         break;\n     case RSA_PKCS1_OAEP_PADDING:\n        \
    \ r = RSA_padding_check_PKCS1_OAEP(to, num, buf, j, num, NULL, 0);\n@@ -500,6\
    \ +591,8 @@ static int rsa_ossl_private_decrypt(int flen, const unsigned char\
    \ *from,\n #endif\n \n  err:\n+    HMAC_CTX_free(hmac);\n+    EVP_MD_free(md);\n\
    \     BN_CTX_end(ctx);\n     BN_CTX_free(ctx);\n     OPENSSL_clear_free(buf, num);"
  - "--- a/crypto/rsa/rsa_pk1.c\n+++ b/crypto/rsa/rsa_pk1.c\n@@ -21,10 +21,14 @@\n\
    \ #include <openssl/rand.h>\n /* Just for the SSL_MAX_MASTER_KEY_LENGTH value\
    \ */\n #include <openssl/prov_ssl.h>\n+#include <openssl/evp.h>\n+#include <openssl/sha.h>\n\
    +#include <openssl/hmac.h>\n #include \"internal/cryptlib.h\"\n #include \"crypto/rsa.h\"\
    \n #include \"rsa_local.h\"\n \n+\n int RSA_padding_add_PKCS1_type_1(unsigned\
    \ char *to, int tlen,\n                                  const unsigned char *from,\
    \ int flen)\n {\n@@ -271,6 +275,254 @@ int RSA_padding_check_PKCS1_type_2(unsigned\
    \ char *to, int tlen,\n     return constant_time_select_int(good, mlen, -1);\n\
    \ }\n \n+\n+static int ossl_rsa_prf(OSSL_LIB_CTX *ctx,\n+                    \
    \    unsigned char *to, int tlen,\n+                        const char *label,\
    \ int llen,\n+                        const unsigned char *kdk,\n+           \
    \             uint16_t bitlen)\n+{\n+    int pos;\n+    int ret = -1;\n+    uint16_t\
    \ iter = 0;\n+    unsigned char be_iter[sizeof(iter)];\n+    unsigned char be_bitlen[sizeof(bitlen)];\n\
    +    HMAC_CTX *hmac = NULL;\n+    EVP_MD *md = NULL;\n+    unsigned char hmac_out[SHA256_DIGEST_LENGTH];\n\
    +    unsigned int md_len;\n+\n+    if (tlen * 8 != bitlen) {\n+        ERR_raise(ERR_LIB_RSA,\
    \ ERR_R_INTERNAL_ERROR);\n+        return ret;\n+    }\n+\n+    be_bitlen[0] =\
    \ (bitlen >> 8) & 0xff;\n+    be_bitlen[1] = bitlen & 0xff;\n+\n+    hmac = HMAC_CTX_new();\n\
    +    if (hmac == NULL) {\n+        ERR_raise(ERR_LIB_RSA, ERR_R_INTERNAL_ERROR);\n\
    +        goto err;\n+    }\n+\n+    /*\n+     * we use hardcoded hash so that\
    \ migrating between versions that use\n+     * different hash doesn't provide\
    \ a Bleichenbacher oracle:\n+     * if the attacker can see that different versions\
    \ return different\n+     * messages for the same ciphertext, they'll know that\
    \ the message is\n+     * syntethically generated, which means that the padding\
    \ check failed\n+     */\n+    md = EVP_MD_fetch(ctx, \"sha256\", NULL);\n+  \
    \  if (md == NULL) {\n+        ERR_raise(ERR_LIB_RSA, ERR_R_INTERNAL_ERROR);\n\
    +        goto err;\n+    }\n+\n+    if (HMAC_Init_ex(hmac, kdk, SHA256_DIGEST_LENGTH,\
    \ md, NULL) <= 0) {\n+        ERR_raise(ERR_LIB_RSA, ERR_R_INTERNAL_ERROR);\n\
    +        goto err;\n+    }\n+\n+    for (pos = 0; pos < tlen; pos += SHA256_DIGEST_LENGTH,\
    \ iter++) {\n+        if (HMAC_Init_ex(hmac, NULL, 0, NULL, NULL) <= 0) {\n+ \
    \           ERR_raise(ERR_LIB_RSA, ERR_R_INTERNAL_ERROR);\n+            goto err;\n\
    +        }\n+\n+        be_iter[0] = (iter >> 8) & 0xff;\n+        be_iter[1]\
    \ = iter & 0xff;\n+\n+        if (HMAC_Update(hmac, be_iter, sizeof(be_iter))\
    \ <= 0) {\n+            ERR_raise(ERR_LIB_RSA, ERR_R_INTERNAL_ERROR);\n+     \
    \       goto err;\n+        }\n+        if (HMAC_Update(hmac, (unsigned char *)label,\
    \ llen) <= 0) {\n+            ERR_raise(ERR_LIB_RSA, ERR_R_INTERNAL_ERROR);\n\
    +            goto err;\n+        }\n+        if (HMAC_Update(hmac, be_bitlen,\
    \ sizeof(be_bitlen)) <= 0) {\n+            ERR_raise(ERR_LIB_RSA, ERR_R_INTERNAL_ERROR);\n\
    +            goto err;\n+        }\n+\n+        /*\n+         * HMAC_Final requires\
    \ the output buffer to fit the whole MAC\n+         * value, so we need to use\
    \ the intermediate buffer for the last\n+         * unaligned block\n+       \
    \  */\n+        md_len = SHA256_DIGEST_LENGTH;\n+        if (pos + SHA256_DIGEST_LENGTH\
    \ > tlen) {\n+            if (HMAC_Final(hmac, hmac_out, &md_len) <= 0) {\n+ \
    \               ERR_raise(ERR_LIB_RSA, ERR_R_INTERNAL_ERROR);\n+             \
    \   goto err;\n+            }\n+            memcpy(to + pos, hmac_out, tlen -\
    \ pos);\n+        } else {\n+            if (HMAC_Final(hmac, to + pos, &md_len)\
    \ <= 0) {\n+                ERR_raise(ERR_LIB_RSA, ERR_R_INTERNAL_ERROR);\n+ \
    \               goto err;\n+            }\n+        }\n+    }\n+\n+    ret = 0;\n\
    +\n+err:\n+    HMAC_CTX_free(hmac);\n+    EVP_MD_free(md);\n+    return ret;\n\
    +}\n+\n+/*\n+ * ossl_rsa_padding_check_PKCS1_type_2() checks and removes the PKCS#1\
    \ type 2\n+ * padding from a decrypted RSA message. Unlike the\n+ * RSA_padding_check_PKCS1_type_2()\
    \ it will not return an error in case it\n+ * detects a padding error, rather\
    \ it will return a deterministically generated\n+ * random message. In other words\
    \ it will perform an implicit rejection\n+ * of an invalid padding. This means\
    \ that the returned value does not indicate\n+ * if the padding of the encrypted\
    \ message was correct or not, making\n+ * side channel attacks like the ones described\
    \ by Bleichenbacher impossible\n+ * without access to the full decrypted value\
    \ and a brute-force search of\n+ * remaining padding bytes\n+ */\n+int ossl_rsa_padding_check_PKCS1_type_2(OSSL_LIB_CTX\
    \ *ctx,\n+                                        unsigned char *to, int tlen,\n\
    +                                        const unsigned char *from, int flen,\n\
    +                                        int num, unsigned char *kdk)\n+{\n+/*\n\
    + * We need to generate a random length for the synthethic message, to avoid\n\
    + * bias towards zero and avoid non-constant timeness of DIV, we prepare\n+ *\
    \ 128 values to check if they are not too large for the used key size,\n+ * and\
    \ use 0 in case none of them are small enough, as 2^-128 is a good enough\n+ *\
    \ safety margin\n+ */\n+#define MAX_LEN_GEN_TRIES 128\n+    unsigned char *synthetic\
    \ = NULL;\n+    int synthethic_length;\n+    uint16_t len_candidate;\n+    unsigned\
    \ char candidate_lengths[MAX_LEN_GEN_TRIES * sizeof(len_candidate)];\n+    uint16_t\
    \ len_mask;\n+    uint16_t max_sep_offset;\n+    int synth_msg_index = 0;\n+ \
    \   int ret = -1;\n+    int i, j;\n+    unsigned int good, found_zero_byte;\n\
    +    int zero_index = 0, msg_index;\n+\n+    /*\n+     * If these checks fail\
    \ then either the message in publicly invalid, or\n+     * we've been called incorrectly.\
    \ We can fail immediately.\n+     * Since this code is called only internally\
    \ by openssl, those are just\n+     * sanity checks\n+     */\n+    if (num !=\
    \ flen || tlen <= 0 || flen <= 0) {\n+        ERR_raise(ERR_LIB_RSA, ERR_R_INTERNAL_ERROR);\n\
    +        return -1;\n+    }\n+\n+    /* Generate a random message to return in\
    \ case the padding checks fail */\n+    synthetic = OPENSSL_malloc(flen);\n+ \
    \   if (synthetic == NULL) {\n+        ERR_raise(ERR_LIB_RSA, ERR_R_MALLOC_FAILURE);\n\
    +        return -1;\n+    }\n+\n+    if (ossl_rsa_prf(ctx, synthetic, flen, \"\
    message\", 7, kdk, flen * 8) < 0)\n+        goto err;\n+\n+    /* decide how long\
    \ the random message should be */\n+    if (ossl_rsa_prf(ctx, candidate_lengths,\
    \ sizeof(candidate_lengths),\n+                     \"length\", 6, kdk,\n+   \
    \                  MAX_LEN_GEN_TRIES * sizeof(len_candidate) * 8) < 0)\n+    \
    \    goto err;\n+\n+    /*\n+     * max message size is the size of the modulus\
    \ size less 2 bytes for\n+     * version and padding type and a minimum of 8 bytes\
    \ padding\n+     */\n+    len_mask = max_sep_offset = flen - 2 - 8;\n+    /*\n\
    +     * we want a mask so lets propagate the high bit to all positions less\n\
    +     * significant than it\n+     */\n+    len_mask |= len_mask >> 1;\n+    len_mask\
    \ |= len_mask >> 2;\n+    len_mask |= len_mask >> 4;\n+    len_mask |= len_mask\
    \ >> 8;\n+\n+    synthethic_length = 0;\n+    for (i = 0; i < MAX_LEN_GEN_TRIES\
    \ * (int)sizeof(len_candidate);\n+            i += sizeof(len_candidate)) {\n\
    +        len_candidate = (candidate_lengths[i] << 8) | candidate_lengths[i + 1];\n\
    +        len_candidate &= len_mask;\n+\n+        synthethic_length = constant_time_select_int(\n\
    +            constant_time_lt(len_candidate, max_sep_offset),\n+            len_candidate,\
    \ synthethic_length);\n+    }\n+\n+    synth_msg_index = flen - synthethic_length;\n\
    +\n+    /* we have alternative message ready, check the real one */\n+    good\
    \ = constant_time_is_zero(from[0]);\n+    good &= constant_time_eq(from[1], 2);\n\
    +\n+    /* then look for the padding|message separator (the first zero byte) */\n\
    +    found_zero_byte = 0;\n+    for (i = 2; i < flen; i++) {\n+        unsigned\
    \ int equals0 = constant_time_is_zero(from[i]);\n+        zero_index = constant_time_select_int(~found_zero_byte\
    \ & equals0,\n+                                              i, zero_index);\n\
    +        found_zero_byte |= equals0;\n+    }\n+\n+    /*\n+     * padding must\
    \ be at least 8 bytes long, and it starts two bytes into\n+     * |from|. If we\
    \ never found a 0-byte, then |zero_index| is 0 and the check\n+     * also fails.\n\
    +     */\n+    good &= constant_time_ge(zero_index, 2 + 8);\n+\n+    /*\n+   \
    \  * Skip the zero byte. This is incorrect if we never found a zero-byte\n+  \
    \   * but in this case we also do not copy the message out.\n+     */\n+    msg_index\
    \ = zero_index + 1;\n+\n+    /*\n+     * old code returned an error in case the\
    \ decrypted message wouldn't fit\n+     * into the |to|, since that would leak\
    \ information, return the synthethic\n+     * message instead\n+     */\n+   \
    \ good &= constant_time_ge(tlen, num - msg_index);\n+\n+    msg_index = constant_time_select_int(good,\
    \ msg_index, synth_msg_index);\n+\n+    /*\n+     * since at this point the |msg_index|\
    \ does not provide the signal\n+     * indicating if the padding check failed\
    \ or not, we don't have to worry\n+     * about leaking the length of returned\
    \ message, we still need to ensure\n+     * that we read contents of both buffers\
    \ so that cache accesses don't leak\n+     * the value of |good|\n+     */\n+\
    \    for (i = msg_index, j = 0; i < flen && j < tlen; i++, j++)\n+        to[j]\
    \ = constant_time_select_8(good, from[i], synthetic[i]);\n+    ret = j;\n+\n+err:\n\
    +    /*\n+     * the only time ret < 0 is when the ciphertext is publicly invalid\n\
    +     * or we were called with invalid parameters, so we don't have to perform\n\
    +     * a side-channel secure raising of the error\n+     */\n+    if (ret < 0)\n\
    +        ERR_raise(ERR_LIB_RSA, ERR_R_INTERNAL_ERROR);\n+    OPENSSL_free(synthetic);\n\
    +    return ret;\n+}\n+\n /*\n  * ossl_rsa_padding_check_PKCS1_type_2_TLS() checks\
    \ and removes the PKCS1 type 2\n  * padding from a decrypted RSA message in a\
    \ TLS signature. The result is stored"
  identifiers: CVE:[],CWE:["CWE-203"]
  overview: Affected versions of this package are vulnerable to Observable Timing
    Discrepancy via the PKCS#1 1.5 decryption process. An attacker can recover ciphertexts
    via a side-channel attack by exploiting the Marvin security flaw.
  references:
    GitHub Commit: https://github.com/openssl/openssl/commit/7fc67e0a33102aa47bbaa56533eeecb98c0450f7
    Github PR: https://github.com/openssl/openssl/pull/13817
    Vulnerability Report: https://people.redhat.com/~hkario/marvin/
  title: Observable Timing Discrepancy
- diff_content:
  - "--- a/ospfd/ospf_te.c\n+++ b/ospfd/ospf_te.c\n@@ -2246,6 +2246,10 @@ static int\
    \ ospf_te_parse_te(struct ls_ted *ted, struct ospf_lsa *lsa)\n \t}\n \n \t/* Get\
    \ corresponding Edge from Link State Data Base */\n+\tif (IPV4_NET0(attr.standard.local.s_addr)\
    \ && !attr.standard.local_id) {\n+\t\tote_debug(\"  |- Found no TE Link local\
    \ address/ID. Abort!\");\n+\t\treturn -1;\n+\t}\n \tedge = get_edge(ted, attr.adv,\
    \ attr.standard.local);\n \told = edge->attributes;\n "
  identifiers: CVE:["CVE-2024-27913"],CWE:["CWE-400"]
  overview: Affected versions of this package are vulnerable to Uncontrolled Resource
    Consumption ('Resource Exhaustion') due to improper handling of malformed OSPF
    LSA packets in the `ospf_te_parse_te` function. An attacker can cause a crash
    of the ospfd daemon, leading to a denial of service condition by sending a specially
    crafted packet that attempts to access a missing attribute field.
  references:
    GitHub Commit: https://github.com/FRRouting/frr/commit/541503eecd302d2cc8456167d130014cd2cf1134
    GitHub PR: https://github.com/FRRouting/frr/pull/15431
  title: Uncontrolled Resource Consumption ('Resource Exhaustion')
- diff_content:
  - "--- a/src/flv.c\n+++ b/src/flv.c\n@@ -247,7 +247,6 @@ int flv_read_video_tag(flv_stream\
    \ * stream, flv_video_tag * tag) {\n         int fourcc_retval = flv_read_fourcc_codec(stream,\
    \ tag);\n \n         if (fourcc_retval == FLV_ERROR_EOF) {\n-            flv_close(stream);\n\
    \             return FLV_ERROR_EOF;\n         }\n     }"
  identifiers: CVE:["CVE-2024-25385"],CWE:["CWE-400"]
  overview: Affected versions of this package are vulnerable to Denial of Service
    (DoS) due to the `flv_close` function in `flv.c:375:21`. An attacker can cause
    the application to crash by providing a specially crafted FLV file.
  references:
    GitHub Commit: https://github.com/noirotm/flvmeta/commit/b54861c940f2ebc67bf88c4f6841256dba8fb0ac
    GitHub Issue: https://github.com/noirotm/flvmeta/issues/23
    PoC: https://github.com/hanxuer/crashes/blob/main/flvmeta/01/readme.md
    commons-fileupload:commons-fileupload: SNYK-JAVA-COMMONSFILEUPLOAD-30082
    npm <code>ws</code> package: https://snyk.io/vuln/npm:ws:20171108
  title: Denial of Service (DoS)
- diff_content:
  - "--- a/src/detect-http-header.c\n+++ b/src/detect-http-header.c\n@@ -48,6 +48,7\
    \ @@\n #include \"util-print.h\"\n #include \"util-memcmp.h\"\n #include \"util-profiling.h\"\
    \n+#include \"util-validate.h\"\n \n #include \"app-layer.h\"\n #include \"app-layer-parser.h\"\
    \n@@ -467,6 +468,8 @@ void DetectHttpHeaderRegister(void)\n \n static int g_http_request_header_buffer_id\
    \ = 0;\n static int g_http_response_header_buffer_id = 0;\n+static int g_request_header_thread_id\
    \ = 0;\n+static int g_response_header_thread_id = 0;\n \n static InspectionBuffer\
    \ *GetHttp2HeaderData(DetectEngineThreadCtx *det_ctx, const uint8_t flags,\n \
    \        const DetectEngineTransforms *transforms, Flow *_f, const struct MpmListIdDataArgs\
    \ *cbdata,\n@@ -580,6 +583,36 @@ static int PrefilterMpmHttp2HeaderRegister(DetectEngineCtx\
    \ *de_ctx, SigGroupHead\n             mpm_reg->app_v2.tx_min_progress, pectx,\
    \ PrefilterMpmHttpHeaderFree, mpm_reg->name);\n }\n \n+typedef struct HttpMultiBufItem\
    \ {\n+    uint8_t *buffer;\n+    size_t len;\n+} HttpMultiBufItem;\n+\n+typedef\
    \ struct HttpMultiBufHeaderThreadData {\n+    // array of items, being defined\
    \ as a buffer with its length just above\n+    HttpMultiBufItem *items;\n+   \
    \ // capacity of items (size of allocation)\n+    size_t cap;\n+    // length\
    \ of items (number in use)\n+    size_t len;\n+} HttpMultiBufHeaderThreadData;\n\
    +\n+static void *HttpMultiBufHeaderThreadDataInit(void *data)\n+{\n+    HttpMultiBufHeaderThreadData\
    \ *td = SCCalloc(1, sizeof(*td));\n+    return td;\n+}\n+\n+static void HttpMultiBufHeaderThreadDataFree(void\
    \ *data)\n+{\n+    HttpMultiBufHeaderThreadData *td = data;\n+    for (size_t\
    \ i = 0; i < td->cap; i++) {\n+        SCFree(td->items[i].buffer);\n+    }\n\
    +    SCFree(td->items);\n+    SCFree(td);\n+}\n+\n static InspectionBuffer *GetHttp1HeaderData(DetectEngineThreadCtx\
    \ *det_ctx, const uint8_t flags,\n         const DetectEngineTransforms *transforms,\
    \ Flow *f, const struct MpmListIdDataArgs *cbdata,\n         int list_id)\n@@\
    \ -593,10 +626,15 @@ static InspectionBuffer *GetHttp1HeaderData(DetectEngineThreadCtx\
    \ *det_ctx, cons\n     if (buffer->initialized)\n         return buffer;\n \n\
    -    HttpHeaderThreadData *hdr_td = NULL;\n-    HttpHeaderBuffer *buf =\n-   \
    \         HttpHeaderGetBufferSpace(det_ctx, f, flags, g_keyword_thread_id, &hdr_td);\n\
    -    if (unlikely(buf == NULL)) {\n+    int kw_thread_id;\n+    if (flags & STREAM_TOSERVER)\
    \ {\n+        kw_thread_id = g_request_header_thread_id;\n+    } else {\n+   \
    \     kw_thread_id = g_response_header_thread_id;\n+    }\n+    HttpMultiBufHeaderThreadData\
    \ *hdr_td =\n+            DetectThreadCtxGetGlobalKeywordThreadCtx(det_ctx, kw_thread_id);\n\
    +    if (unlikely(hdr_td == NULL)) {\n         return NULL;\n     }\n \n@@ -607,33\
    \ +645,53 @@ static InspectionBuffer *GetHttp1HeaderData(DetectEngineThreadCtx\
    \ *det_ctx, cons\n     } else {\n         headers = tx->response_headers;\n  \
    \   }\n-    if (cbdata->local_id < htp_table_size(headers)) {\n-        htp_header_t\
    \ *h = htp_table_get_index(headers, cbdata->local_id, NULL);\n-        size_t\
    \ size1 = bstr_size(h->name);\n-        size_t size2 = bstr_size(h->value);\n\
    -        size_t b_len = size1 + 2 + size2;\n-        if (b_len > buf->size) {\n\
    -            if (HttpHeaderExpandBuffer(hdr_td, buf, b_len) != 0) {\n+    size_t\
    \ no_of_headers = htp_table_size(headers);\n+    if (cbdata->local_id == 0) {\n\
    +        // We initialize a big buffer on first item\n+        // Then, we will\
    \ just use parts of it\n+        hdr_td->len = 0;\n+        if (hdr_td->cap <\
    \ no_of_headers) {\n+            void *new_buffer = SCRealloc(hdr_td->items, no_of_headers\
    \ * sizeof(HttpMultiBufItem));\n+            if (unlikely(new_buffer == NULL))\
    \ {\n                 return NULL;\n             }\n+            hdr_td->items\
    \ = new_buffer;\n+            // zeroes the new part of the items\n+         \
    \   memset(hdr_td->items + hdr_td->cap, 0,\n+                    (no_of_headers\
    \ - hdr_td->cap) * sizeof(HttpMultiBufItem));\n+            hdr_td->cap = no_of_headers;\n\
    \         }\n-        memcpy(buf->buffer, bstr_ptr(h->name), bstr_size(h->name));\n\
    -        buf->buffer[size1] = ':';\n-        buf->buffer[size1 + 1] = ' ';\n-\
    \        memcpy(buf->buffer + size1 + 2, bstr_ptr(h->value), bstr_size(h->value));\n\
    -        buf->len = b_len;\n-    } else {\n-        InspectionBufferSetupMultiEmpty(buffer);\n\
    -        return NULL;\n-    }\n-    if (buf->len == 0) {\n-        InspectionBufferSetupMultiEmpty(buffer);\n\
    -        return NULL;\n+        for (size_t i = 0; i < no_of_headers; i++) {\n\
    +            htp_header_t *h = htp_table_get_index(headers, i, NULL);\n+     \
    \       size_t size1 = bstr_size(h->name);\n+            size_t size2 = bstr_size(h->value);\n\
    +            size_t size = size1 + size2 + 2;\n+            if (hdr_td->items[i].len\
    \ < size) {\n+                // Use realloc, as this pointer is not freed until\
    \ HttpMultiBufHeaderThreadDataFree\n+                hdr_td->items[i].buffer =\
    \ SCRealloc(hdr_td->items[i].buffer, size);\n+                if (unlikely(hdr_td->items[i].buffer\
    \ == NULL)) {\n+                    return NULL;\n+                }\n+      \
    \      }\n+            memcpy(hdr_td->items[i].buffer, bstr_ptr(h->name), size1);\n\
    +            hdr_td->items[i].buffer[size1] = ':';\n+            hdr_td->items[i].buffer[size1\
    \ + 1] = ' ';\n+            memcpy(hdr_td->items[i].buffer + size1 + 2, bstr_ptr(h->value),\
    \ size2);\n+            hdr_td->items[i].len = size;\n+        }\n+        hdr_td->len\
    \ = no_of_headers;\n     }\n \n-    InspectionBufferSetupMulti(buffer, transforms,\
    \ buf->buffer, buf->len);\n-\n-    SCReturnPtr(buffer, \"InspectionBuffer\");\n\
    +    // cbdata->local_id is the index of the requested header buffer\n+    //\
    \ hdr_td->len is the number of header buffers\n+    if (cbdata->local_id < hdr_td->len)\
    \ {\n+        // we have one valid header buffer\n+        InspectionBufferSetupMulti(buffer,\
    \ transforms, hdr_td->items[cbdata->local_id].buffer,\n+                hdr_td->items[cbdata->local_id].len);\n\
    +        SCReturnPtr(buffer, \"InspectionBuffer\");\n+    } // else there are\
    \ no more header buffer to get\n+    InspectionBufferSetupMultiEmpty(buffer);\n\
    +    return NULL;\n }\n \n static void PrefilterTxHttp1Header(DetectEngineThreadCtx\
    \ *det_ctx, const void *pectx, Packet *p,\n@@ -751,6 +809,8 @@ void DetectHttpRequestHeaderRegister(void)\n\
    \     DetectBufferTypeSetDescriptionByName(\"http_request_header\", \"HTTP header\
    \ name and value\");\n     g_http_request_header_buffer_id = DetectBufferTypeGetByName(\"\
    http_request_header\");\n     DetectBufferTypeSupportsMultiInstance(\"http_request_header\"\
    );\n+    g_request_header_thread_id = DetectRegisterThreadCtxGlobalFuncs(\"http_request_header\"\
    ,\n+            HttpMultiBufHeaderThreadDataInit, NULL, HttpMultiBufHeaderThreadDataFree);\n\
    \ }\n \n static int DetectHTTPResponseHeaderSetup(DetectEngineCtx *de_ctx, Signature\
    \ *s, const char *arg)\n@@ -786,6 +846,8 @@ void DetectHttpResponseHeaderRegister(void)\n\
    \     DetectBufferTypeSetDescriptionByName(\"http_response_header\", \"HTTP header\
    \ name and value\");\n     g_http_response_header_buffer_id = DetectBufferTypeGetByName(\"\
    http_response_header\");\n     DetectBufferTypeSupportsMultiInstance(\"http_response_header\"\
    );\n+    g_response_header_thread_id = DetectRegisterThreadCtxGlobalFuncs(\"http_response_header\"\
    ,\n+            HttpMultiBufHeaderThreadDataInit, NULL, HttpMultiBufHeaderThreadDataFree);\n\
    \ }\n \n /************************************Unittests*********************************/"
  identifiers: CVE:["CVE-2024-23839"],CWE:["CWE-416"]
  overview: Affected versions of this package are vulnerable to Use After Free due
    to the improper handling of certain traffic patterns, specifically when the ruleset
    employs the `http.request_header` or `http.response_header` keyword. Exploiting
    this vulnerability can lead to potential denial of service or execution of arbitrary
    code by sending specially crafted traffic.
  references:
    GitHub Commit: https://github.com/OISF/suricata/commit/cd731fcaf42e5f7078c9be643bfa0cee2ad53e8f
  title: Use After Free
- diff_content:
  - "--- a/src/lib/ares__read_line.c\n+++ b/src/lib/ares__read_line.c\n@@ -59,6 +59,14\
    \ @@ ares_status_t ares__read_line(FILE *fp, char **buf, size_t *bufsize)\n  \
    \     return (offset != 0) ? 0 : (ferror(fp)) ? ARES_EFILE : ARES_EOF;\n     }\n\
    \     len = offset + ares_strlen(*buf + offset);\n+\n+    /* Probably means there\
    \ was an embedded NULL as the first character in\n+     * the line, throw away\
    \ line */\n+    if (len == 0) {\n+      offset = 0;\n+      continue;\n+    }\n\
    +\n     if ((*buf)[len - 1] == '\\n') {\n       (*buf)[len - 1] = 0;\n       break;"
  identifiers: CVE:["CVE-2024-25629"],CWE:["CWE-127"]
  overview: Affected versions of this package are vulnerable to Buffer Under-read
    due to the `ares__read_line` function. An attacker can cause a crash by inserting
    an embedded `NULL` character as the first character in a new line in local configuration
    files such as `/etc/resolv.conf`, `/etc/nsswitch.conf`, the `HOSTALIASES` file.
  references:
    GitHub Commit: https://github.com/c-ares/c-ares/commit/a804c04ddc8245fc8adf0e92368709639125e183
  title: Buffer Under-read
- diff_content:
  - "--- a/wsutil/to_str.c\n+++ b/wsutil/to_str.c\n@@ -653,12 +653,17 @@ eui64_to_str(wmem_allocator_t\
    \ *scope, const guint64 ad) {\n #define CHARS_NANOSECONDS\t9\t/* 000000001 */\n\
    \ \n /*\n- * Format the fractonal part of a time, with the specified precision)\n\
    + * Format the fractional part of a time, with the specified precision.\n+ * Returns\
    \ the number of bytes formatted.\n  */\n-void\n+int\n format_fractional_part_nsecs(gchar\
    \ *buf, size_t buflen, guint32 nsecs, const char *decimal_point, int precision)\n\
    \ {\n+\tgchar *ptr;\n+\tsize_t remaining;\n+\tint num_bytes;\n \tgsize decimal_point_len;\n\
    +\tguint32 frac_part;\n \tgint8 num_buf[CHARS_NANOSECONDS];\n \tgint8 *num_end\
    \ = &num_buf[CHARS_NANOSECONDS];\n \tgint8 *num_ptr;\n@@ -671,22 +676,50 @@ format_fractional_part_nsecs(gchar\
    \ *buf, size_t buflen, guint32 nsecs, const cha\n \t\t * No room in the buffer\
    \ for anything, including\n \t\t * a terminating '\\0'.\n \t\t */\n-\t\treturn;\n\
    +\t\treturn 0;\n+\t}\n+\n+\t/*\n+\t * If the fractional part is >= 1, don't show\
    \ it as a\n+\t * fractional part.\n+\t */\n+\tif (nsecs >= 1000000000U) {\n+\t\
    \tnum_bytes = snprintf(buf, buflen, \"%s(%u nanoseconds)\",\n+\t\t    decimal_point,\
    \ nsecs);\n+\t\tif ((unsigned int)num_bytes >= buflen) {\n+\t\t\t/*\n+\t\t\t *\
    \ That filled up or would have overflowed\n+\t\t\t * the buffer.  Nothing more\
    \ to do; return\n+\t\t\t * the remaining space in the buffer, minus\n+\t\t\t *\
    \ one byte for the terminating '\\0',* as\n+\t\t\t * that's the number of bytes\
    \ we copied.\n+\t\t\t */\n+\t\t\treturn (int)(buflen - 1);\n+\t\t}\n+\t\treturn\
    \ num_bytes;\n \t}\n \n+\tptr = buf;\n+\tremaining = buflen;\n+\tnum_bytes = 0;\n\
    +\n \t/*\n \t * Copy the decimal point.\n \t */\n \tdecimal_point_len = g_strlcpy(buf,\
    \ decimal_point, buflen);\n \tif (decimal_point_len >= buflen) {\n \t\t/*\n \t\
    \t * The decimal point didn't fit in the buffer\n-\t\t * and was truncated.  Nothing\
    \ more to do.\n+\t\t * and was truncated.  Nothing more to do;\n+\t\t * return\
    \ the remaining space in the buffer,\n+\t\t * minus one byte for the terminating\
    \ '\\0',\n+\t\t * as that's the number of bytes we copied.\n \t\t */\n-\t\treturn;\n\
    +\t\treturn (int)(buflen - 1);\n \t}\n-\tbuf += decimal_point_len;\n-\tbuflen\
    \ -= decimal_point_len;\n+\tptr += decimal_point_len;\n+\tremaining -= decimal_point_len;\n\
    +\tnum_bytes += decimal_point_len;\n \n \t/*\n \t * Fill in num_buf with the nanoseconds\
    \ value, padded with\n@@ -709,104 +742,101 @@ format_fractional_part_nsecs(gchar\
    \ *buf, size_t buflen, guint32 nsecs, const cha\n \t\t/*\n \t\t * Scale down to\
    \ units of 1/10 second.\n \t\t */\n-\t\tnum_ptr = uint_to_str_back_len(num_end,\n\
    -\t\t    nsecs / 100000000, precision);\n+\t\tfrac_part = nsecs / 100000000U;\n\
    \ \t\tbreak;\n \n \tcase 2:\n \t\t/*\n \t\t * Scale down to units of 1/100 second.\n\
    \ \t\t */\n-\t\tnum_ptr = uint_to_str_back_len(num_end,\n-\t\t    nsecs / 10000000,\
    \ precision);\n+\t\tfrac_part = nsecs / 10000000U;\n \t\tbreak;\n \n \tcase 3:\n\
    \ \t\t/*\n \t\t * Scale down to units of 1/1000 second.\n \t\t */\n-\t\tnum_ptr\
    \ = uint_to_str_back_len(num_end,\n-\t\t    nsecs / 1000000, precision);\n+\t\t\
    frac_part = nsecs / 1000000U;\n \t\tbreak;\n \n \tcase 4:\n \t\t/*\n \t\t * Scale\
    \ down to units of 1/10000 second.\n \t\t */\n-\t\tnum_ptr = uint_to_str_back_len(num_end,\n\
    -\t\t    nsecs / 100000, precision);\n+\t\tfrac_part = nsecs / 100000U;\n \t\t\
    break;\n \n \tcase 5:\n \t\t/*\n \t\t * Scale down to units of 1/100000 second.\n\
    \ \t\t */\n-\t\tnum_ptr = uint_to_str_back_len(num_end,\n-\t\t    nsecs / 10000,\
    \ precision);\n+\t\tfrac_part = nsecs / 10000U;\n \t\tbreak;\n \n \tcase 6:\n\
    \ \t\t/*\n \t\t * Scale down to units of 1/1000000 second.\n \t\t */\n-\t\tnum_ptr\
    \ = uint_to_str_back_len(num_end,\n-\t\t    nsecs / 1000, precision);\n+\t\tfrac_part\
    \ = nsecs / 1000U;\n \t\tbreak;\n \n \tcase 7:\n \t\t/*\n \t\t * Scale down to\
    \ units of 1/10000000 second.\n \t\t */\n-\t\tnum_ptr = uint_to_str_back_len(num_end,\n\
    -\t\t    nsecs / 100, precision);\n+\t\tfrac_part = nsecs / 100U;\n \t\tbreak;\n\
    \ \n \tcase 8:\n \t\t/*\n \t\t * Scale down to units of 1/100000000 second.\n\
    \ \t\t */\n-\t\tnum_ptr = uint_to_str_back_len(num_end,\n-\t\t    nsecs / 10,\
    \ precision);\n+\t\tfrac_part = nsecs / 10U;\n \t\tbreak;\n \n \tcase 9:\n \t\t\
    /*\n \t\t * We're already in units of 1/1000000000 second.\n \t\t */\n-\t\tnum_ptr\
    \ = uint_to_str_back_len(num_end, nsecs,\n-\t\t    precision);\n+\t\tfrac_part\
    \ = nsecs;\n \t\tbreak;\n \n \tdefault:\n \t\tws_assert_not_reached();\n \t\t\
    break;\n \t}\n \n+\tnum_ptr = uint_to_str_back_len(num_end, frac_part, precision);\n\
    +\n \t/*\n \t * The length of the string that we want to copy to the buffer\n\
    \ \t * is the minimum of:\n \t *\n \t *    the length of the digit string;\n-\t\
    \ *    the size of the buffer, minus 1 for the terminating\n-\t *      '\\0'.\n\
    +\t *    the remaining space in the buffer, minus 1 for the\n+\t *      terminating\
    \ '\\0'.\n \t */\n-\tnum_len = MIN((size_t)(num_end - num_ptr), buflen - 1);\n\
    +\tnum_len = MIN((size_t)(num_end - num_ptr), remaining - 1);\n \tif (num_len\
    \ == 0) {\n \t\t/*\n \t\t * Not enough room to copy anything.\n+\t\t * Return\
    \ the number of bytes we've generated.\n \t\t */\n-\t\treturn;\n+\t\treturn num_bytes;\n\
    \ \t}\n \n \t/*\n \t * Copy over the fractional part.\n \t */\n-\tmemcpy(buf,\
    \ num_ptr, num_len);\n+\tmemcpy(ptr, num_ptr, num_len);\n+\tptr += num_len;\n\
    +\tnum_bytes += num_len;\n \n \t/*\n \t * '\\0'-terminate it.\n \t */\n-\t*(buf\
    \ + num_len) = '\\0';\n+\t*ptr = '\\0';\n+\treturn num_bytes;\n }\n \n void\n\
    @@ -892,8 +922,8 @@ format_nstime_as_iso8601(gchar *buf, size_t buflen, const\
    \ nstime_t *ns,\n {\n \tstruct tm tm, *tmp;\n \tgchar *ptr;\n-\tsize_t buf_remaining;\n\
    -\tint num_chars;\n+\tsize_t remaining;\n+\tint num_bytes;\n \n \tif (local)\n\
    \ \t\ttmp = ws_localtime_r(&ns->secs, &tm);\n@@ -904,45 +934,41 @@ format_nstime_as_iso8601(gchar\
    \ *buf, size_t buflen, const nstime_t *ns,\n \t\treturn;\n \t}\n \tptr = buf;\n\
    -\tbuf_remaining = buflen;\n-\tnum_chars = snprintf(ptr, buf_remaining,\n+\tremaining\
    \ = buflen;\n+\tnum_bytes = snprintf(ptr, remaining,\n \t    \"%04d-%02d-%02d\
    \ %02d:%02d:%02d\",\n \t    tmp->tm_year + 1900,\n \t    tmp->tm_mon + 1,\n \t\
    \    tmp->tm_mday,\n \t    tmp->tm_hour,\n \t    tmp->tm_min,\n \t    tmp->tm_sec);\n\
    -\tif (num_chars < 0) {\n+\tif (num_bytes < 0) {\n \t\t/*\n+\t\t * That got an\
    \ error.\n \t\t * Not much else we can do.\n \t\t */\n \t\tsnprintf(buf, buflen,\
    \ \"snprintf() failed\");\n \t\treturn;\n \t}\n-\tif ((unsigned int)num_chars\
    \ >= buf_remaining) {\n+\tif ((unsigned int)num_bytes >= remaining) {\n \t\t/*\n\
    -\t\t * Either that got an error (num_chars < 0) or it\n-\t\t * filled up or would\
    \ have overflowed the buffer\n-\t\t * (num_chars >= buf_remaining).\n+\t\t * That\
    \ filled up or would have overflowed the buffer.\n \t\t * Nothing more we can\
    \ do.\n \t\t */\n \t\treturn;\n \t}\n-\tptr += num_chars;\n-\tbuf_remaining -=\
    \ num_chars;\n+\tptr += num_bytes;\n+\tremaining -= num_bytes;\n \n-\tif (precision\
    \ == 0) {\n+\tif (precision != 0) {\n \t\t/*\n-\t\t * Seconds precision, so no\
    \ nanosecond.\n+\t\t * Append the fractional part.\n+\t\t * Get the nsecs as a\
    \ 32-bit unsigned value, as it should\n+\t\t * never be negative, so we treat\
    \ it as unsigned.\n \t\t */\n-\t\treturn;\n+\t\tformat_fractional_part_nsecs(ptr,\
    \ remaining, (guint32)ns->nsecs, decimal_point, precision);\n \t}\n-\n-\t/*\n\
    -\t * Append the fractional part.\n-\t */\n-\tformat_fractional_part_nsecs(ptr,\
    \ buf_remaining, (guint32)ns->nsecs, decimal_point, precision);\n }\n \n /*"
  identifiers: CVE:["CVE-2024-24479"],CWE:["CWE-120"]
  overview: Affected versions of this package are vulnerable to Buffer Overflow via
    the `wsutil/to_str.c`, and `format_fractional_part_nsecs` components. An attacker
    can cause a denial of service by sending crafted packets or files that are processed
    by the application.
  references:
    GitHub Commit: https://github.com/wireshark/wireshark/commit/c3720cff158c265dec2a0c6104b1d65954ae6bfd
    GitHub Gist: https://gist.github.com/1047524396/c50ad17e9a1a18990043a7cd27814c78
  title: Buffer Overflow
- diff_content:
  - "--- a/epan/dissectors/packet-bgp.c\n+++ b/epan/dissectors/packet-bgp.c\n@@ -8441,7\
    \ +8441,7 @@ dissect_bgp_capability_item(tvbuff_t *tvb, proto_tree *tree, packet_info\
    \ *pinfo,\n static void\n dissect_bgp_open(tvbuff_t *tvb, proto_tree *tree, packet_info\
    \ *pinfo)\n {\n-    guint8          optlen;    /* Option Length */\n+    uint16_t\
    \        optlen;    /* Option Length */\n     int             ptype;     /* parameter\
    \ type        */\n     int             plen;      /* parameter length      */\n\
    \     int             cend;      /* capabilities end      */\n@@ -11439,10 +11439,10\
    \ @@ proto_register_bgp(void)\n           NULL, 0x0, \"The total length of the\
    \ Optional Parameters field in octets\", HFILL }},\n       { &hf_bgp_open_opt_extension,\n\
    \         { \"Optional Parameter Extension\", \"bgp.open.opt.extension\", FT_NONE,\
    \ BASE_NONE,\n-          NULL, 0x0, \"Optional Parameters Extension dedetected\"\
    , HFILL }},\n+          NULL, 0x0, \"Optional Parameters Extension detected\"\
    , HFILL }},\n       { &hf_bgp_open_opt_extension_mark,\n         { \"Extension\
    \ Mark\", \"bgp.open.opt.extension.mark\", FT_UINT8, BASE_DEC,\n-          NULL,\
    \ 0x0, \"Optional Parameters Extension dedetected\", HFILL }},\n+          NULL,\
    \ 0x0, \"Optional Parameters Extension detected\", HFILL }},\n       { &hf_bgp_open_opt_extension_len,\n\
    \         { \"Extended Length\", \"bgp.open.opt.extension_len\", FT_UINT16, BASE_DEC,\n\
    \           NULL, 0x0, \"The total extended length of the Optional Parameters\
    \ field in octets\", HFILL }},"
  identifiers: CVE:["CVE-2024-24478"],CWE:["CWE-400"]
  overview: Affected versions of this package are vulnerable to Denial of Service
    (DoS) via the `packet-bgp.c`, `dissect_bgp_open(tvbuff_t*tvb, proto_tree*tree,
    packet_info*pinfo)`, optlen components. An attacker can cause the application
    to crash by sending specially crafted packets.
  references:
    GitHub Commit: https://github.com/wireshark/wireshark/commit/80a4dc55f4d2fa33c2b36a99406500726d3faaef
    GitHub Gist: https://gist.github.com/1047524396/e82c55147cd3cb62ef20cbdb0ec83694
    Issue: https://gitlab.com/wireshark/wireshark/-/issues/19347
    commons-fileupload:commons-fileupload: SNYK-JAVA-COMMONSFILEUPLOAD-30082
    npm <code>ws</code> package: https://snyk.io/vuln/npm:ws:20171108
  title: Denial of Service (DoS)
- diff_content:
  - "--- a/epan/addr_resolv.c\n+++ b/epan/addr_resolv.c\n@@ -1669,12 +1669,14 @@ add_manuf_name(const\
    \ guint8 *addr, unsigned int mask, gchar *name, gchar *longna\n } /* add_manuf_name\
    \ */\n \n static hashmanuf_t *\n-manuf_name_lookup(const guint8 *addr)\n+manuf_name_lookup(const\
    \ guint8 *addr, size_t size)\n {\n     guint32       manuf_key;\n     guint8 \
    \      oct;\n     hashmanuf_t  *manuf_value;\n \n+    ws_return_val_if(size <\
    \ 6, NULL);\n+\n     /* manuf needs only the 3 most significant octets of the\
    \ ethernet address */\n     manuf_key = addr[0];\n     manuf_key = manuf_key<<8;\n\
    @@ -1870,6 +1872,7 @@ eth_addr_resolve(hashether_t *tp) {\n     ether_t      *eth;\n\
    \     hashmanuf_t *manuf_value;\n     const guint8 *addr = tp->addr;\n+    size_t\
    \ addr_size = sizeof(tp->addr);\n \n     if ( (eth = get_ethbyaddr(addr)) != NULL)\
    \ {\n         (void) g_strlcpy(tp->resolved_name, eth->name, MAXNAMELEN);\n@@\
    \ -1916,7 +1919,7 @@ eth_addr_resolve(hashether_t *tp) {\n         } while (mask--);\n\
    \ \n         /* Now try looking in the manufacturer table. */\n-        manuf_value\
    \ = manuf_name_lookup(addr);\n+        manuf_value = manuf_name_lookup(addr, addr_size);\n\
    \         if ((manuf_value != NULL) && (manuf_value->status != HASHETHER_STATUS_UNRESOLVED))\
    \ {\n             snprintf(tp->resolved_name, MAXNAMELEN, \"%s_%02x:%02x:%02x\"\
    ,\n                     manuf_value->resolved_name, addr[3], addr[4], addr[5]);\n\
    @@ -3484,11 +3487,11 @@ get_vlan_name(wmem_allocator_t *allocator, const guint16\
    \ id)\n } /* get_vlan_name */\n \n const gchar *\n-get_manuf_name(const guint8\
    \ *addr)\n+get_manuf_name(const guint8 *addr, size_t size)\n {\n     hashmanuf_t\
    \ *manuf_value;\n \n-    manuf_value = manuf_name_lookup(addr);\n+    manuf_value\
    \ = manuf_name_lookup(addr, size);\n     if (gbl_resolv_flags.mac_name && manuf_value->status\
    \ != HASHETHER_STATUS_UNRESOLVED)\n         return manuf_value->resolved_name;\n\
    \ \n@@ -3499,16 +3502,20 @@ get_manuf_name(const guint8 *addr)\n const gchar *\n\
    \ tvb_get_manuf_name(tvbuff_t *tvb, gint offset)\n {\n-    return get_manuf_name(tvb_get_ptr(tvb,\
    \ offset, 3));\n+    guint8 buf[6] = { 0 };\n+    tvb_memcpy(tvb, buf, offset,\
    \ 3);\n+    return get_manuf_name(buf, sizeof(buf));\n }\n \n const gchar *\n\
    -get_manuf_name_if_known(const guint8 *addr)\n+get_manuf_name_if_known(const guint8\
    \ *addr, size_t size)\n {\n     hashmanuf_t *manuf_value;\n     guint manuf_key;\n\
    \     guint8 oct;\n \n+    ws_return_val_if(size != 6, NULL);\n+\n     /* manuf\
    \ needs only the 3 most significant octets of the ethernet address */\n     manuf_key\
    \ = addr[0];\n     manuf_key = manuf_key<<8;\n@@ -3564,7 +3571,9 @@ uint_get_manuf_name_if_known(const\
    \ guint32 manuf_key)\n const gchar *\n tvb_get_manuf_name_if_known(tvbuff_t *tvb,\
    \ gint offset)\n {\n-    return get_manuf_name_if_known(tvb_get_ptr(tvb, offset,\
    \ 3));\n+    guint8 buf[6] = { 0 };\n+    tvb_memcpy(tvb, buf, offset, 3);\n+\
    \    return get_manuf_name_if_known(buf, sizeof(buf));\n }\n \n char* get_hash_manuf_resolved_name(hashmanuf_t*\
    \ manuf)\n@@ -3582,7 +3591,7 @@ eui64_to_display(wmem_allocator_t *allocator,\
    \ const guint64 addr_eui64)\n     /* Copy and convert the address to network byte\
    \ order. */\n     *(guint64 *)(void *)(addr) = pntoh64(&(addr_eui64));\n \n- \
    \   manuf_value = manuf_name_lookup(addr);\n+    manuf_value = manuf_name_lookup(addr,\
    \ 8);\n     if (!gbl_resolv_flags.mac_name || (manuf_value->status == HASHETHER_STATUS_UNRESOLVED))\
    \ {\n         ret = wmem_strdup_printf(allocator, \"%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x\"\
    , addr[0], addr[1], addr[2], addr[3], addr[4], addr[5], addr[6], addr[7]);\n \
    \    } else {"
  - "--- a/epan/address_types.c\n+++ b/epan/address_types.c\n@@ -383,7 +383,7 @@ static\
    \ const gchar* fcwwn_name_res_str(const address* addr)\n     case FC_NH_NAA_IEEE_E:\n\
    \ \n         memcpy (oui, &addrp[2], 6);\n-        return get_manuf_name(oui);\n\
    +        return get_manuf_name(oui, sizeof(oui));\n \n     case FC_NH_NAA_IEEE_R:\n\
    \         oui[0] = ((addrp[0] & 0x0F) << 4) | ((addrp[1] & 0xF0) >> 4);\n@@ -393,7\
    \ +393,7 @@ static const gchar* fcwwn_name_res_str(const address* addr)\n    \
    \     oui[4] = ((addrp[4] & 0x0F) << 4) | ((addrp[5] & 0xF0) >> 4);\n        \
    \ oui[5] = ((addrp[5] & 0x0F) << 4) | ((addrp[6] & 0xF0) >> 4);\n \n-        return\
    \ get_manuf_name(oui);\n+        return get_manuf_name(oui, sizeof(oui));\n  \
    \   }\n \n     return \"\";"
  identifiers: CVE:["CVE-2024-24476"],CWE:["CWE-119"]
  overview: Affected versions of this package are vulnerable to Buffer Overflow due
    to improper handling in `pan/addr_resolv.c` and `ws_manuf_lookup_str()`. An attacker
    can cause the application to crash by sending crafted packets or manipulating
    input data.
  references:
    GitHub Commit: https://github.com/wireshark/wireshark/commit/108217f4bb1afb8b25fc705c2722b3e328b1ad78
    GitLab Issue: https://gitlab.com/wireshark/wireshark/-/issues/19344
  title: Buffer Overflow
- diff_content:
  - "--- a/fontforge/splinefont.c\n+++ b/fontforge/splinefont.c\n@@ -788,11 +788,14\
    \ @@ return( name );\n \n char *Unarchive(char *name, char **_archivedir) {\n\
    \     char *dir = getenv(\"TMPDIR\");\n-    char *pt, *archivedir, *listfile,\
    \ *listcommand, *unarchivecmd, *desiredfile;\n+    char *pt, *archivedir, *listfile,\
    \ *desiredfile;\n     char *finalfile;\n     int i;\n     int doall=false;\n \
    \    static int cnt=0;\n+    gchar *command[5];\n+    gchar *stdoutresponse =\
    \ NULL;\n+    gchar *stderrresponse = NULL;\n \n     *_archivedir = NULL;\n \n\
    @@ -827,18 +830,30 @@ return( NULL );\n     listfile = malloc(strlen(archivedir)+strlen(\"\
    /\" TOC_NAME)+1);\n     sprintf( listfile, \"%s/\" TOC_NAME, archivedir );\n \n\
    -    listcommand = malloc( strlen(archivers[i].unarchive) + 1 +\n-\t\t\tstrlen(\
    \ archivers[i].listargs) + 1 +\n-\t\t\tstrlen( name ) + 3 +\n-\t\t\tstrlen( listfile\
    \ ) +4 );\n-    sprintf( listcommand, \"%s %s %s > %s\", archivers[i].unarchive,\n\
    -\t    archivers[i].listargs, name, listfile );\n-    if ( system(listcommand)!=0\
    \ ) {\n-\tfree(listcommand); free(listfile);\n-\tArchiveCleanup(archivedir);\n\
    -return( NULL );\n-    }\n-    free(listcommand);\n+    command[0] = archivers[i].unarchive;\n\
    +    command[1] = archivers[i].listargs;\n+    command[2] = name;\n+    command[3]\
    \ = NULL; // command args need to be NULL-terminated\n+\n+    if ( g_spawn_sync(\n\
    +                      NULL,\n+                      command,\n+             \
    \         NULL,\n+                      G_SPAWN_SEARCH_PATH, \n+             \
    \         NULL, \n+                      NULL, \n+                      &stdoutresponse,\
    \ \n+                      &stderrresponse, \n+                      NULL, \n\
    +                      NULL\n+                      ) == FALSE) { // did not successfully\
    \ execute\n+      ArchiveCleanup(archivedir);\n+      return( NULL );\n+    }\n\
    +    // Write out the listfile to be read in later\n+    FILE *fp = fopen(listfile,\
    \ \"wb\");\n+    fwrite(stdoutresponse, strlen(stdoutresponse), 1, fp);\n+   \
    \ fclose(fp);\n \n     desiredfile = ArchiveParseTOC(listfile, archivers[i].ars,\
    \ &doall);\n     free(listfile);\n@@ -847,22 +862,28 @@ return( NULL );\n return(\
    \ NULL );\n     }\n \n-    /* I tried sending everything to stdout, but that doesn't\
    \ work if the */\n-    /*  output is a directory file (ufo, sfdir) */\n-    unarchivecmd\
    \ = malloc( strlen(archivers[i].unarchive) + 1 +\n-\t\t\tstrlen( archivers[i].listargs)\
    \ + 1 +\n-\t\t\tstrlen( name ) + 1 +\n-\t\t\tstrlen( desiredfile ) + 3 +\n-\t\t\
    \tstrlen( archivedir ) + 30 );\n-    sprintf( unarchivecmd, \"( cd %s ; %s %s\
    \ %s %s ) > /dev/null\", archivedir,\n-\t    archivers[i].unarchive,\n-\t    archivers[i].extractargs,\
    \ name, doall ? \"\" : desiredfile );\n-    if ( system(unarchivecmd)!=0 ) {\n\
    -\tfree(unarchivecmd); free(desiredfile);\n-\tArchiveCleanup(archivedir);\n-return(\
    \ NULL );\n+    command[0] = archivers[i].unarchive;\n+    command[1] = archivers[i].extractargs;\n\
    +    command[2] = name;\n+    command[3] = doall ? \"\" : desiredfile;\n+    command[4]\
    \ = NULL;\n+\n+    if ( g_spawn_sync(\n+                      (gchar*)archivedir,\n\
    +                      command,\n+                      NULL,\n+             \
    \         G_SPAWN_SEARCH_PATH, \n+                      NULL, \n+            \
    \          NULL, \n+                      &stdoutresponse, \n+               \
    \       &stderrresponse, \n+                      NULL, \n+                  \
    \    NULL\n+                      ) == FALSE) { // did not successfully execute\n\
    +      free(desiredfile);\n+      ArchiveCleanup(archivedir);\n+      return(\
    \ NULL );\n     }\n-    free(unarchivecmd);\n \n     finalfile = malloc( strlen(archivedir)\
    \ + 1 + strlen(desiredfile) + 1);\n     sprintf( finalfile, \"%s/%s\", archivedir,\
    \ desiredfile );\n@@ -885,20 +906,54 @@ struct compressors compressors[] = {\n\
    \ \n char *Decompress(char *name, int compression) {\n     char *dir = getenv(\"\
    TMPDIR\");\n-    char buf[1500];\n     char *tmpfn;\n-\n+    gchar *command[4];\n\
    +    gint stdout_pipe;\n+    gchar buffer[4096];\n+    gssize bytes_read;\n+ \
    \   GByteArray *binary_data = g_byte_array_new();\n+    \n     if ( dir==NULL\
    \ ) dir = P_tmpdir;\n     tmpfn = malloc(strlen(dir)+strlen(GFileNameTail(name))+2);\n\
    \     strcpy(tmpfn,dir);\n     strcat(tmpfn,\"/\");\n     strcat(tmpfn,GFileNameTail(name));\n\
    \     *strrchr(tmpfn,'.') = '\\0';\n-    snprintf( buf, sizeof(buf), \"%s < %s\
    \ > %s\", compressors[compression].decomp, name, tmpfn );\n-    if ( system(buf)==0\
    \ )\n-return( tmpfn );\n-    free(tmpfn);\n-return( NULL );\n+\n+    command[0]\
    \ = compressors[compression].decomp;\n+    command[1] = \"-c\";\n+    command[2]\
    \ = name;\n+    command[3] = NULL;\n+\n+    // Have to use async because g_spawn_sync\
    \ doesn't handle nul-bytes in the output (which happens with binary data)\n+ \
    \   if (g_spawn_async_with_pipes(\n+      NULL, \n+      command, \n+      NULL,\
    \ \n+      G_SPAWN_DO_NOT_REAP_CHILD | G_SPAWN_SEARCH_PATH,\n+      NULL, \n+\
    \      NULL,  \n+      NULL,\n+      NULL, \n+      &stdout_pipe, \n+      NULL,\
    \ \n+      NULL) == FALSE) {\n+      //command has failed\n+      return( NULL\
    \ );\n+    }\n+\n+    // Read binary data from pipe and output to file\n+    while\
    \ ((bytes_read = read(stdout_pipe, buffer, sizeof(buffer))) > 0) {\n+        g_byte_array_append(binary_data,\
    \ (guint8 *)buffer, bytes_read);\n+    }\n+    close(stdout_pipe);\n+\n+    FILE\
    \ *fp = fopen(tmpfn, \"wb\");\n+    fwrite(binary_data->data, sizeof(gchar), binary_data->len,\
    \ fp);\n+    fclose(fp);\n+    g_byte_array_free(binary_data, TRUE);\n+\n+\t\t\
    return(tmpfn);\n }\n \n static char *ForceFileToHaveName(FILE *file, char *exten)\
    \ {"
  identifiers: CVE:["CVE-2024-25082"],CWE:["CWE-77"]
  overview: Affected versions of this package are vulnerable to Command Injection
    via the `Splinefont` process. An attacker can execute arbitrary commands by crafting
    malicious archives or compressed files.
  references:
    GitHub Commit: https://github.com/fontforge/fontforge/commit/216eb14b558df344b206bf82e2bdaf03a1f2f429
    GitHub PR: https://github.com/fontforge/fontforge/pull/5367
  title: Command Injection
- diff_content:
  - "--- a/fontforge/splinefont.c\n+++ b/fontforge/splinefont.c\n@@ -788,11 +788,14\
    \ @@ return( name );\n \n char *Unarchive(char *name, char **_archivedir) {\n\
    \     char *dir = getenv(\"TMPDIR\");\n-    char *pt, *archivedir, *listfile,\
    \ *listcommand, *unarchivecmd, *desiredfile;\n+    char *pt, *archivedir, *listfile,\
    \ *desiredfile;\n     char *finalfile;\n     int i;\n     int doall=false;\n \
    \    static int cnt=0;\n+    gchar *command[5];\n+    gchar *stdoutresponse =\
    \ NULL;\n+    gchar *stderrresponse = NULL;\n \n     *_archivedir = NULL;\n \n\
    @@ -827,18 +830,30 @@ return( NULL );\n     listfile = malloc(strlen(archivedir)+strlen(\"\
    /\" TOC_NAME)+1);\n     sprintf( listfile, \"%s/\" TOC_NAME, archivedir );\n \n\
    -    listcommand = malloc( strlen(archivers[i].unarchive) + 1 +\n-\t\t\tstrlen(\
    \ archivers[i].listargs) + 1 +\n-\t\t\tstrlen( name ) + 3 +\n-\t\t\tstrlen( listfile\
    \ ) +4 );\n-    sprintf( listcommand, \"%s %s %s > %s\", archivers[i].unarchive,\n\
    -\t    archivers[i].listargs, name, listfile );\n-    if ( system(listcommand)!=0\
    \ ) {\n-\tfree(listcommand); free(listfile);\n-\tArchiveCleanup(archivedir);\n\
    -return( NULL );\n-    }\n-    free(listcommand);\n+    command[0] = archivers[i].unarchive;\n\
    +    command[1] = archivers[i].listargs;\n+    command[2] = name;\n+    command[3]\
    \ = NULL; // command args need to be NULL-terminated\n+\n+    if ( g_spawn_sync(\n\
    +                      NULL,\n+                      command,\n+             \
    \         NULL,\n+                      G_SPAWN_SEARCH_PATH, \n+             \
    \         NULL, \n+                      NULL, \n+                      &stdoutresponse,\
    \ \n+                      &stderrresponse, \n+                      NULL, \n\
    +                      NULL\n+                      ) == FALSE) { // did not successfully\
    \ execute\n+      ArchiveCleanup(archivedir);\n+      return( NULL );\n+    }\n\
    +    // Write out the listfile to be read in later\n+    FILE *fp = fopen(listfile,\
    \ \"wb\");\n+    fwrite(stdoutresponse, strlen(stdoutresponse), 1, fp);\n+   \
    \ fclose(fp);\n \n     desiredfile = ArchiveParseTOC(listfile, archivers[i].ars,\
    \ &doall);\n     free(listfile);\n@@ -847,22 +862,28 @@ return( NULL );\n return(\
    \ NULL );\n     }\n \n-    /* I tried sending everything to stdout, but that doesn't\
    \ work if the */\n-    /*  output is a directory file (ufo, sfdir) */\n-    unarchivecmd\
    \ = malloc( strlen(archivers[i].unarchive) + 1 +\n-\t\t\tstrlen( archivers[i].listargs)\
    \ + 1 +\n-\t\t\tstrlen( name ) + 1 +\n-\t\t\tstrlen( desiredfile ) + 3 +\n-\t\t\
    \tstrlen( archivedir ) + 30 );\n-    sprintf( unarchivecmd, \"( cd %s ; %s %s\
    \ %s %s ) > /dev/null\", archivedir,\n-\t    archivers[i].unarchive,\n-\t    archivers[i].extractargs,\
    \ name, doall ? \"\" : desiredfile );\n-    if ( system(unarchivecmd)!=0 ) {\n\
    -\tfree(unarchivecmd); free(desiredfile);\n-\tArchiveCleanup(archivedir);\n-return(\
    \ NULL );\n+    command[0] = archivers[i].unarchive;\n+    command[1] = archivers[i].extractargs;\n\
    +    command[2] = name;\n+    command[3] = doall ? \"\" : desiredfile;\n+    command[4]\
    \ = NULL;\n+\n+    if ( g_spawn_sync(\n+                      (gchar*)archivedir,\n\
    +                      command,\n+                      NULL,\n+             \
    \         G_SPAWN_SEARCH_PATH, \n+                      NULL, \n+            \
    \          NULL, \n+                      &stdoutresponse, \n+               \
    \       &stderrresponse, \n+                      NULL, \n+                  \
    \    NULL\n+                      ) == FALSE) { // did not successfully execute\n\
    +      free(desiredfile);\n+      ArchiveCleanup(archivedir);\n+      return(\
    \ NULL );\n     }\n-    free(unarchivecmd);\n \n     finalfile = malloc( strlen(archivedir)\
    \ + 1 + strlen(desiredfile) + 1);\n     sprintf( finalfile, \"%s/%s\", archivedir,\
    \ desiredfile );\n@@ -885,20 +906,54 @@ struct compressors compressors[] = {\n\
    \ \n char *Decompress(char *name, int compression) {\n     char *dir = getenv(\"\
    TMPDIR\");\n-    char buf[1500];\n     char *tmpfn;\n-\n+    gchar *command[4];\n\
    +    gint stdout_pipe;\n+    gchar buffer[4096];\n+    gssize bytes_read;\n+ \
    \   GByteArray *binary_data = g_byte_array_new();\n+    \n     if ( dir==NULL\
    \ ) dir = P_tmpdir;\n     tmpfn = malloc(strlen(dir)+strlen(GFileNameTail(name))+2);\n\
    \     strcpy(tmpfn,dir);\n     strcat(tmpfn,\"/\");\n     strcat(tmpfn,GFileNameTail(name));\n\
    \     *strrchr(tmpfn,'.') = '\\0';\n-    snprintf( buf, sizeof(buf), \"%s < %s\
    \ > %s\", compressors[compression].decomp, name, tmpfn );\n-    if ( system(buf)==0\
    \ )\n-return( tmpfn );\n-    free(tmpfn);\n-return( NULL );\n+\n+    command[0]\
    \ = compressors[compression].decomp;\n+    command[1] = \"-c\";\n+    command[2]\
    \ = name;\n+    command[3] = NULL;\n+\n+    // Have to use async because g_spawn_sync\
    \ doesn't handle nul-bytes in the output (which happens with binary data)\n+ \
    \   if (g_spawn_async_with_pipes(\n+      NULL, \n+      command, \n+      NULL,\
    \ \n+      G_SPAWN_DO_NOT_REAP_CHILD | G_SPAWN_SEARCH_PATH,\n+      NULL, \n+\
    \      NULL,  \n+      NULL,\n+      NULL, \n+      &stdout_pipe, \n+      NULL,\
    \ \n+      NULL) == FALSE) {\n+      //command has failed\n+      return( NULL\
    \ );\n+    }\n+\n+    // Read binary data from pipe and output to file\n+    while\
    \ ((bytes_read = read(stdout_pipe, buffer, sizeof(buffer))) > 0) {\n+        g_byte_array_append(binary_data,\
    \ (guint8 *)buffer, bytes_read);\n+    }\n+    close(stdout_pipe);\n+\n+    FILE\
    \ *fp = fopen(tmpfn, \"wb\");\n+    fwrite(binary_data->data, sizeof(gchar), binary_data->len,\
    \ fp);\n+    fclose(fp);\n+    g_byte_array_free(binary_data, TRUE);\n+\n+\t\t\
    return(tmpfn);\n }\n \n static char *ForceFileToHaveName(FILE *file, char *exten)\
    \ {"
  identifiers: CVE:["CVE-2024-25081"],CWE:["CWE-77"]
  overview: Affected versions of this package are vulnerable to Command Injection
    due to the improper handling of crafted filenames in the `Splinefont` function.
    An attacker can execute arbitrary commands by crafting a filename that injects
    malicious commands.
  references:
    GitHub Commit: https://github.com/fontforge/fontforge/commit/216eb14b558df344b206bf82e2bdaf03a1f2f429
    GitHub PR: https://github.com/fontforge/fontforge/pull/5367
  title: Command Injection
- diff_content:
  - "--- a/drivers/net/usb/hso.c\n+++ b/drivers/net/usb/hso.c\n@@ -611,16 +611,18\
    \ @@ static struct hso_serial *get_serial_by_index(unsigned index)\n \treturn\
    \ serial;\n }\n \n-static int get_free_serial_index(void)\n+static int obtain_minor(struct\
    \ hso_serial *serial)\n {\n \tint index;\n \tunsigned long flags;\n \n \tspin_lock_irqsave(&serial_table_lock,\
    \ flags);\n \tfor (index = 0; index < HSO_SERIAL_TTY_MINORS; index++) {\n \t\t\
    if (serial_table[index] == NULL) {\n+\t\t\tserial_table[index] = serial->parent;\n\
    +\t\t\tserial->minor = index;\n \t\t\tspin_unlock_irqrestore(&serial_table_lock,\
    \ flags);\n-\t\t\treturn index;\n+\t\t\treturn 0;\n \t\t}\n \t}\n \tspin_unlock_irqrestore(&serial_table_lock,\
    \ flags);\n@@ -629,15 +631,12 @@ static int get_free_serial_index(void)\n \treturn\
    \ -1;\n }\n \n-static void set_serial_by_index(unsigned index, struct hso_serial\
    \ *serial)\n+static void release_minor(struct hso_serial *serial)\n {\n \tunsigned\
    \ long flags;\n \n \tspin_lock_irqsave(&serial_table_lock, flags);\n-\tif (serial)\n\
    -\t\tserial_table[index] = serial->parent;\n-\telse\n-\t\tserial_table[index]\
    \ = NULL;\n+\tserial_table[serial->minor] = NULL;\n \tspin_unlock_irqrestore(&serial_table_lock,\
    \ flags);\n }\n \n@@ -2230,6 +2229,7 @@ static int hso_stop_serial_device(struct\
    \ hso_device *hso_dev)\n static void hso_serial_tty_unregister(struct hso_serial\
    \ *serial)\n {\n \ttty_unregister_device(tty_drv, serial->minor);\n+\trelease_minor(serial);\n\
    \ }\n \n static void hso_serial_common_free(struct hso_serial *serial)\n@@ -2253,24\
    \ +2253,22 @@ static void hso_serial_common_free(struct hso_serial *serial)\n\
    \ static int hso_serial_common_create(struct hso_serial *serial, int num_urbs,\n\
    \ \t\t\t\t    int rx_size, int tx_size)\n {\n-\tint minor;\n \tint i;\n \n \t\
    tty_port_init(&serial->port);\n \n-\tminor = get_free_serial_index();\n-\tif (minor\
    \ < 0)\n+\tif (obtain_minor(serial))\n \t\tgoto exit2;\n \n \t/* register our\
    \ minor number */\n \tserial->parent->dev = tty_port_register_device_attr(&serial->port,\n\
    -\t\t\ttty_drv, minor, &serial->parent->interface->dev,\n+\t\t\ttty_drv, serial->minor,\
    \ &serial->parent->interface->dev,\n \t\t\tserial->parent, hso_serial_dev_groups);\n\
    -\tif (IS_ERR(serial->parent->dev))\n+\tif (IS_ERR(serial->parent->dev)) {\n+\t\
    \trelease_minor(serial);\n \t\tgoto exit2;\n+\t}\n \n-\t/* fill in specific data\
    \ for later use */\n-\tserial->minor = minor;\n \tserial->magic = HSO_SERIAL_MAGIC;\n\
    \ \tspin_lock_init(&serial->serial_lock);\n \tserial->num_rx_urbs = num_urbs;\n\
    @@ -2667,9 +2665,6 @@ static struct hso_device *hso_create_bulk_serial_device(\n\
    \ \n \tserial->write_data = hso_std_serial_write_data;\n \n-\t/* and record this\
    \ serial */\n-\tset_serial_by_index(serial->minor, serial);\n-\n \t/* setup the\
    \ proc dirs and files if needed */\n \thso_log_port(hso_dev);\n \n@@ -2726,9 +2721,6\
    \ @@ struct hso_device *hso_create_mux_serial_device(struct usb_interface *interface,\n\
    \ \tserial->shared_int->ref_count++;\n \tmutex_unlock(&serial->shared_int->shared_int_lock);\n\
    \ \n-\t/* and record this serial */\n-\tset_serial_by_index(serial->minor, serial);\n\
    -\n \t/* setup the proc dirs and files if needed */\n \thso_log_port(hso_dev);\n\
    \ \n@@ -3113,7 +3105,6 @@ static void hso_free_interface(struct usb_interface\
    \ *interface)\n \t\t\tcancel_work_sync(&serial_table[i]->async_get_intf);\n \t\
    \t\thso_serial_tty_unregister(serial);\n \t\t\tkref_put(&serial_table[i]->ref,\
    \ hso_serial_ref_free);\n-\t\t\tset_serial_by_index(i, NULL);\n \t\t}\n \t}\n "
  identifiers: CVE:["CVE-2021-46904"],CWE:["CWE-476"]
  overview: Affected versions of this package are vulnerable to NULL Pointer Dereference
    due to an error during the unregistration process of a tty device. An attacker
    can cause a denial of service by triggering this flaw.
  references:
    GitHub Commit: https://github.com/torvalds/linux/commit/8a12f8836145ffe37e9c8733dce18c22fb668b66
  title: NULL Pointer Dereference
- diff_content:
  - "--- a/drivers/mfd/syscon.c\n+++ b/drivers/mfd/syscon.c\n@@ -105,6 +105,10 @@\
    \ static struct syscon *of_syscon_register(struct device_node *np, bool check_res)\n\
    \ \t}\n \n \tsyscon_config.name = kasprintf(GFP_KERNEL, \"%pOFn@%pa\", np, &res.start);\n\
    +\tif (!syscon_config.name) {\n+\t\tret = -ENOMEM;\n+\t\tgoto err_regmap;\n+\t\
    }\n \tsyscon_config.reg_stride = reg_io_width;\n \tsyscon_config.val_bits = reg_io_width\
    \ * 8;\n \tsyscon_config.max_register = resource_size(&res) - reg_io_width;"
  identifiers: CVE:["CVE-2023-52467"],CWE:["CWE-476"]
  overview: Affected versions of this package are vulnerable to NULL Pointer Dereference
    in `of_syscon_register`. An attacker can cause a denial of service or potentially
    execute arbitrary code by exploiting this vulnerability.
  references:
    GitHub Commit: https://github.com/torvalds/linux/commit/41673c66b3d0c09915698fec5c13b24336f18dd1
  title: NULL Pointer Dereference
- diff_content:
  - "--- a/drivers/power/supply/qcom_pmi8998_charger.c\n+++ b/drivers/power/supply/qcom_pmi8998_charger.c\n\
    @@ -972,10 +972,14 @@ static int smb2_probe(struct platform_device *pdev)\n \t\
    supply_config.of_node = pdev->dev.of_node;\n \n \tdesc = devm_kzalloc(chip->dev,\
    \ sizeof(smb2_psy_desc), GFP_KERNEL);\n+\tif (!desc)\n+\t\treturn -ENOMEM;\n \t\
    memcpy(desc, &smb2_psy_desc, sizeof(smb2_psy_desc));\n \tdesc->name =\n \t\tdevm_kasprintf(chip->dev,\
    \ GFP_KERNEL, \"%s-charger\",\n \t\t\t       (const char *)device_get_match_data(chip->dev));\n\
    +\tif (!desc->name)\n+\t\treturn -ENOMEM;\n \n \tchip->chg_psy =\n \t\tdevm_power_supply_register(chip->dev,\
    \ desc, &supply_config);"
  identifiers: CVE:["CVE-2023-52465"],CWE:["CWE-476"]
  overview: Affected versions of this package are vulnerable to NULL Pointer Dereference
    due to a flaw in the `smb2_probe` function. An attacker can cause a denial of
    service condition by sending specially crafted packets to the target system.
  references:
    GitHub Commit: https://github.com/torvalds/linux/commit/88f04bc3e737155e13caddf0ba8ed19db87f0212
  title: NULL Pointer Dereference
- diff_content:
  - "--- a/drivers/pci/bus.c\n+++ b/drivers/pci/bus.c\n@@ -386,29 +386,17 @@ void\
    \ pci_bus_add_devices(const struct pci_bus *bus)\n }\n EXPORT_SYMBOL(pci_bus_add_devices);\n\
    \ \n-/** pci_walk_bus - walk devices on/under bus, calling callback.\n- *  @top\
    \      bus whose devices should be walked\n- *  @cb       callback to be called\
    \ for each device found\n- *  @userdata arbitrary pointer to be passed to callback.\n\
    - *\n- *  Walk the given bus, including any bridged devices\n- *  on buses under\
    \ this bus.  Call the provided callback\n- *  on each device found.\n- *\n- *\
    \  We check the return of @cb each time. If it returns anything\n- *  other than\
    \ 0, we break out.\n- *\n- */\n-void pci_walk_bus(struct pci_bus *top, int (*cb)(struct\
    \ pci_dev *, void *),\n-\t\t  void *userdata)\n+static void __pci_walk_bus(struct\
    \ pci_bus *top, int (*cb)(struct pci_dev *, void *),\n+\t\t\t   void *userdata,\
    \ bool locked)\n {\n \tstruct pci_dev *dev;\n \tstruct pci_bus *bus;\n \tstruct\
    \ list_head *next;\n \tint retval;\n \n \tbus = top;\n-\tdown_read(&pci_bus_sem);\n\
    +\tif (!locked)\n+\t\tdown_read(&pci_bus_sem);\n \tnext = top->devices.next;\n\
    \ \tfor (;;) {\n \t\tif (next == &bus->devices) {\n@@ -431,10 +419,37 @@ void\
    \ pci_walk_bus(struct pci_bus *top, int (*cb)(struct pci_dev *, void *),\n \t\t\
    if (retval)\n \t\t\tbreak;\n \t}\n-\tup_read(&pci_bus_sem);\n+\tif (!locked)\n\
    +\t\tup_read(&pci_bus_sem);\n+}\n+\n+/**\n+ *  pci_walk_bus - walk devices on/under\
    \ bus, calling callback.\n+ *  @top: bus whose devices should be walked\n+ * \
    \ @cb: callback to be called for each device found\n+ *  @userdata: arbitrary\
    \ pointer to be passed to callback\n+ *\n+ *  Walk the given bus, including any\
    \ bridged devices\n+ *  on buses under this bus.  Call the provided callback\n\
    + *  on each device found.\n+ *\n+ *  We check the return of @cb each time. If\
    \ it returns anything\n+ *  other than 0, we break out.\n+ */\n+void pci_walk_bus(struct\
    \ pci_bus *top, int (*cb)(struct pci_dev *, void *), void *userdata)\n+{\n+\t\
    __pci_walk_bus(top, cb, userdata, false);\n }\n EXPORT_SYMBOL_GPL(pci_walk_bus);\n\
    \ \n+void pci_walk_bus_locked(struct pci_bus *top, int (*cb)(struct pci_dev *,\
    \ void *), void *userdata)\n+{\n+\tlockdep_assert_held(&pci_bus_sem);\n+\n+\t\
    __pci_walk_bus(top, cb, userdata, true);\n+}\n+EXPORT_SYMBOL_GPL(pci_walk_bus_locked);\n\
    +\n struct pci_bus *pci_bus_get(struct pci_bus *bus)\n {\n \tif (bus)"
  - "--- a/drivers/pci/controller/dwc/pcie-qcom.c\n+++ b/drivers/pci/controller/dwc/pcie-qcom.c\n\
    @@ -972,7 +972,7 @@ static int qcom_pcie_enable_aspm(struct pci_dev *pdev, void\
    \ *userdata)\n \t * Downstream devices need to be in D0 state before enabling\
    \ PCI PM\n \t * substates.\n \t */\n-\tpci_set_power_state(pdev, PCI_D0);\n+\t\
    pci_set_power_state_locked(pdev, PCI_D0);\n \tpci_enable_link_state_locked(pdev,\
    \ PCIE_LINK_STATE_ALL);\n \n \treturn 0;"
  - "--- a/drivers/pci/pci.c\n+++ b/drivers/pci/pci.c\n@@ -1354,6 +1354,7 @@ int pci_power_up(struct\
    \ pci_dev *dev)\n /**\n  * pci_set_full_power_state - Put a PCI device into D0\
    \ and update its state\n  * @dev: PCI device to power up\n+ * @locked: whether\
    \ pci_bus_sem is held\n  *\n  * Call pci_power_up() to put @dev into D0, read\
    \ from its PCI_PM_CTRL register\n  * to confirm the state change, restore its\
    \ BARs if they might be lost and\n@@ -1363,7 +1364,7 @@ int pci_power_up(struct\
    \ pci_dev *dev)\n  * to D0, it is more efficient to use pci_power_up() directly\
    \ instead of this\n  * function.\n  */\n-static int pci_set_full_power_state(struct\
    \ pci_dev *dev)\n+static int pci_set_full_power_state(struct pci_dev *dev, bool\
    \ locked)\n {\n \tu16 pmcsr;\n \tint ret;\n@@ -1399,7 +1400,7 @@ static int pci_set_full_power_state(struct\
    \ pci_dev *dev)\n \t}\n \n \tif (dev->bus->self)\n-\t\tpcie_aspm_pm_state_change(dev->bus->self);\n\
    +\t\tpcie_aspm_pm_state_change(dev->bus->self, locked);\n \n \treturn 0;\n }\n\
    @@ -1428,10 +1429,22 @@ void pci_bus_set_current_state(struct pci_bus *bus, pci_power_t\
    \ state)\n \t\tpci_walk_bus(bus, __pci_dev_set_current_state, &state);\n }\n \n\
    +static void __pci_bus_set_current_state(struct pci_bus *bus, pci_power_t state,\
    \ bool locked)\n+{\n+\tif (!bus)\n+\t\treturn;\n+\n+\tif (locked)\n+\t\tpci_walk_bus_locked(bus,\
    \ __pci_dev_set_current_state, &state);\n+\telse\n+\t\tpci_walk_bus(bus, __pci_dev_set_current_state,\
    \ &state);\n+}\n+\n /**\n  * pci_set_low_power_state - Put a PCI device into a\
    \ low-power state.\n  * @dev: PCI device to handle.\n  * @state: PCI power state\
    \ (D1, D2, D3hot) to put the device into.\n+ * @locked: whether pci_bus_sem is\
    \ held\n  *\n  * Use the device's PCI_PM_CTRL register to put it into a low-power\
    \ state.\n  *\n@@ -1442,7 +1455,7 @@ void pci_bus_set_current_state(struct pci_bus\
    \ *bus, pci_power_t state)\n  * 0 if device already is in the requested state.\n\
    \  * 0 if device's power state has been successfully changed.\n  */\n-static int\
    \ pci_set_low_power_state(struct pci_dev *dev, pci_power_t state)\n+static int\
    \ pci_set_low_power_state(struct pci_dev *dev, pci_power_t state, bool locked)\n\
    \ {\n \tu16 pmcsr;\n \n@@ -1496,29 +1509,12 @@ static int pci_set_low_power_state(struct\
    \ pci_dev *dev, pci_power_t state)\n \t\t\t\t     pci_power_name(state));\n \n\
    \ \tif (dev->bus->self)\n-\t\tpcie_aspm_pm_state_change(dev->bus->self);\n+\t\t\
    pcie_aspm_pm_state_change(dev->bus->self, locked);\n \n \treturn 0;\n }\n \n-/**\n\
    - * pci_set_power_state - Set the power state of a PCI device\n- * @dev: PCI device\
    \ to handle.\n- * @state: PCI power state (D0, D1, D2, D3hot) to put the device\
    \ into.\n- *\n- * Transition a device to a new power state, using the platform\
    \ firmware and/or\n- * the device's PCI PM registers.\n- *\n- * RETURN VALUE:\n\
    - * -EINVAL if the requested state is invalid.\n- * -EIO if device does not support\
    \ PCI PM or its PM capabilities register has a\n- * wrong version, or device doesn't\
    \ support the requested state.\n- * 0 if the transition is to D1 or D2 but D1\
    \ and D2 are not supported.\n- * 0 if device already is in the requested state.\n\
    - * 0 if the transition is to D3 but D3 is not supported.\n- * 0 if device's power\
    \ state has been successfully changed.\n- */\n-int pci_set_power_state(struct\
    \ pci_dev *dev, pci_power_t state)\n+static int __pci_set_power_state(struct pci_dev\
    \ *dev, pci_power_t state, bool locked)\n {\n \tint error;\n \n@@ -1542,7 +1538,7\
    \ @@ int pci_set_power_state(struct pci_dev *dev, pci_power_t state)\n \t\treturn\
    \ 0;\n \n \tif (state == PCI_D0)\n-\t\treturn pci_set_full_power_state(dev);\n\
    +\t\treturn pci_set_full_power_state(dev, locked);\n \n \t/*\n \t * This device\
    \ is quirked not to be put into D3, so don't put it in\n@@ -1556,25 +1552,55 @@\
    \ int pci_set_power_state(struct pci_dev *dev, pci_power_t state)\n \t\t * To\
    \ put the device in D3cold, put it into D3hot in the native\n \t\t * way, then\
    \ put it into D3cold using platform ops.\n \t\t */\n-\t\terror = pci_set_low_power_state(dev,\
    \ PCI_D3hot);\n+\t\terror = pci_set_low_power_state(dev, PCI_D3hot, locked);\n\
    \ \n \t\tif (pci_platform_power_transition(dev, PCI_D3cold))\n \t\t\treturn error;\n\
    \ \n \t\t/* Powering off a bridge may power off the whole hierarchy */\n \t\t\
    if (dev->current_state == PCI_D3cold)\n-\t\t\tpci_bus_set_current_state(dev->subordinate,\
    \ PCI_D3cold);\n+\t\t\t__pci_bus_set_current_state(dev->subordinate, PCI_D3cold,\
    \ locked);\n \t} else {\n-\t\terror = pci_set_low_power_state(dev, state);\n+\t\
    \terror = pci_set_low_power_state(dev, state, locked);\n \n \t\tif (pci_platform_power_transition(dev,\
    \ state))\n \t\t\treturn error;\n \t}\n \n \treturn 0;\n }\n+\n+/**\n+ * pci_set_power_state\
    \ - Set the power state of a PCI device\n+ * @dev: PCI device to handle.\n+ *\
    \ @state: PCI power state (D0, D1, D2, D3hot) to put the device into.\n+ *\n+\
    \ * Transition a device to a new power state, using the platform firmware and/or\n\
    + * the device's PCI PM registers.\n+ *\n+ * RETURN VALUE:\n+ * -EINVAL if the\
    \ requested state is invalid.\n+ * -EIO if device does not support PCI PM or its\
    \ PM capabilities register has a\n+ * wrong version, or device doesn't support\
    \ the requested state.\n+ * 0 if the transition is to D1 or D2 but D1 and D2 are\
    \ not supported.\n+ * 0 if device already is in the requested state.\n+ * 0 if\
    \ the transition is to D3 but D3 is not supported.\n+ * 0 if device's power state\
    \ has been successfully changed.\n+ */\n+int pci_set_power_state(struct pci_dev\
    \ *dev, pci_power_t state)\n+{\n+\treturn __pci_set_power_state(dev, state, false);\n\
    +}\n EXPORT_SYMBOL(pci_set_power_state);\n \n+int pci_set_power_state_locked(struct\
    \ pci_dev *dev, pci_power_t state)\n+{\n+\tlockdep_assert_held(&pci_bus_sem);\n\
    +\n+\treturn __pci_set_power_state(dev, state, true);\n+}\n+EXPORT_SYMBOL(pci_set_power_state_locked);\n\
    +\n #define PCI_EXP_SAVE_REGS\t7\n \n static struct pci_cap_saved_state *_pci_find_saved_cap(struct\
    \ pci_dev *pci_dev,"
  - "--- a/drivers/pci/pcie/aspm.c\n+++ b/drivers/pci/pcie/aspm.c\n@@ -1003,8 +1003,11\
    \ @@ void pcie_aspm_exit_link_state(struct pci_dev *pdev)\n \tup_read(&pci_bus_sem);\n\
    \ }\n \n-/* @pdev: the root port or switch downstream port */\n-void pcie_aspm_pm_state_change(struct\
    \ pci_dev *pdev)\n+/*\n+ * @pdev: the root port or switch downstream port\n+ *\
    \ @locked: whether pci_bus_sem is held\n+ */\n+void pcie_aspm_pm_state_change(struct\
    \ pci_dev *pdev, bool locked)\n {\n \tstruct pcie_link_state *link = pdev->link_state;\n\
    \ \n@@ -1014,12 +1017,14 @@ void pcie_aspm_pm_state_change(struct pci_dev *pdev)\n\
    \ \t * Devices changed PM state, we should recheck if latency\n \t * meets all\
    \ functions' requirement\n \t */\n-\tdown_read(&pci_bus_sem);\n+\tif (!locked)\n\
    +\t\tdown_read(&pci_bus_sem);\n \tmutex_lock(&aspm_lock);\n \tpcie_update_aspm_capable(link->root);\n\
    \ \tpcie_config_aspm_path(link);\n \tmutex_unlock(&aspm_lock);\n-\tup_read(&pci_bus_sem);\n\
    +\tif (!locked)\n+\t\tup_read(&pci_bus_sem);\n }\n \n void pcie_aspm_powersave_config_link(struct\
    \ pci_dev *pdev)"
  identifiers: CVE:["CVE-2024-26605"],CWE:["CWE-833"]
  overview: Affected versions of this package are vulnerable to Lock Order Reversal
    due to improper handling of the process for enabling Active State Power Management
    (ASPM) in the PCI subsystem. An attacker with local access can cause a denial
    of service.
  references:
    GitHub Commit: https://github.com/torvalds/linux/commit/1e560864159d002b453da42bd2c13a1805515a20
  title: Lock Order Reversal
- diff_content:
  - "--- a/arch/x86/kernel/fpu/signal.c\n+++ b/arch/x86/kernel/fpu/signal.c\n@@ -274,12\
    \ +274,13 @@ static int __restore_fpregs_from_user(void __user *buf, u64 ufeatures,\n\
    \  * Attempt to restore the FPU registers directly from user memory.\n  * Pagefaults\
    \ are handled and any errors returned are fatal.\n  */\n-static bool restore_fpregs_from_user(void\
    \ __user *buf, u64 xrestore,\n-\t\t\t\t     bool fx_only, unsigned int size)\n\
    +static bool restore_fpregs_from_user(void __user *buf, u64 xrestore, bool fx_only)\n\
    \ {\n \tstruct fpu *fpu = &current->thread.fpu;\n \tint ret;\n \n+\t/* Restore\
    \ enabled features only. */\n+\txrestore &= fpu->fpstate->user_xfeatures;\n retry:\n\
    \ \tfpregs_lock();\n \t/* Ensure that XFD is up to date */\n@@ -309,7 +310,7 @@\
    \ static bool restore_fpregs_from_user(void __user *buf, u64 xrestore,\n \t\t\
    if (ret != X86_TRAP_PF)\n \t\t\treturn false;\n \n-\t\tif (!fault_in_readable(buf,\
    \ size))\n+\t\tif (!fault_in_readable(buf, fpu->fpstate->user_size))\n \t\t\t\
    goto retry;\n \t\treturn false;\n \t}\n@@ -339,7 +340,6 @@ static bool __fpu_restore_sig(void\
    \ __user *buf, void __user *buf_fx,\n \tstruct user_i387_ia32_struct env;\n \t\
    bool success, fx_only = false;\n \tunion fpregs_state *fpregs;\n-\tunsigned int\
    \ state_size;\n \tu64 user_xfeatures = 0;\n \n \tif (use_xsave()) {\n@@ -349,17\
    \ +349,14 @@ static bool __fpu_restore_sig(void __user *buf, void __user *buf_fx,\n\
    \ \t\t\treturn false;\n \n \t\tfx_only = !fx_sw_user.magic1;\n-\t\tstate_size\
    \ = fx_sw_user.xstate_size;\n \t\tuser_xfeatures = fx_sw_user.xfeatures;\n \t\
    } else {\n \t\tuser_xfeatures = XFEATURE_MASK_FPSSE;\n-\t\tstate_size = fpu->fpstate->user_size;\n\
    \ \t}\n \n \tif (likely(!ia32_fxstate)) {\n \t\t/* Restore the FPU registers directly\
    \ from user memory. */\n-\t\treturn restore_fpregs_from_user(buf_fx, user_xfeatures,\
    \ fx_only,\n-\t\t\t\t\t\tstate_size);\n+\t\treturn restore_fpregs_from_user(buf_fx,\
    \ user_xfeatures, fx_only);\n \t}\n \n \t/*"
  identifiers: CVE:["CVE-2024-26603"],CWE:["CWE-119"]
  overview: Affected versions of this package are vulnerable to Improper Restriction
    of Operations within the Bounds of a Memory Buffer due to the reliance on userspace
    information to fault in the `xsave` buffer. An attacker can cause a denial of
    service by exploiting this reliance.
  references:
    GitHub Commit: https://github.com/torvalds/linux/commit/d877550eaf2dc9090d782864c96939397a3c6835
  title: Improper Restriction of Operations within the Bounds of a Memory Buffer
- diff_content:
  - "--- a/fs/ext4/mballoc.c\n+++ b/fs/ext4/mballoc.c\n@@ -1233,6 +1233,24 @@ void\
    \ ext4_mb_generate_buddy(struct super_block *sb,\n \tatomic64_add(period, &sbi->s_mb_generation_time);\n\
    \ }\n \n+static void mb_regenerate_buddy(struct ext4_buddy *e4b)\n+{\n+\tint count;\n\
    +\tint order = 1;\n+\tvoid *buddy;\n+\n+\twhile ((buddy = mb_find_buddy(e4b, order++,\
    \ &count)))\n+\t\tmb_set_bits(buddy, 0, count);\n+\n+\te4b->bd_info->bb_fragments\
    \ = 0;\n+\tmemset(e4b->bd_info->bb_counters, 0,\n+\t\tsizeof(*e4b->bd_info->bb_counters)\
    \ *\n+\t\t(e4b->bd_sb->s_blocksize_bits + 2));\n+\n+\text4_mb_generate_buddy(e4b->bd_sb,\
    \ e4b->bd_buddy,\n+\t\te4b->bd_bitmap, e4b->bd_group, e4b->bd_info);\n+}\n+\n\
    \ /* The buddy information is attached the buddy cache inode\n  * for convenience.\
    \ The information regarding each group\n  * is loaded via ext4_mb_load_buddy.\
    \ The information involve\n@@ -1920,6 +1938,8 @@ static void mb_free_blocks(struct\
    \ inode *inode, struct ext4_buddy *e4b,\n \t\t\text4_mark_group_bitmap_corrupted(\n\
    \ \t\t\t\tsb, e4b->bd_group,\n \t\t\t\tEXT4_GROUP_INFO_BBITMAP_CORRUPT);\n+\t\t\
    } else {\n+\t\t\tmb_regenerate_buddy(e4b);\n \t\t}\n \t\tgoto done;\n \t}"
  identifiers: CVE:["CVE-2024-26601"],CWE:["CWE-400"]
  overview: Affected versions of this package are vulnerable to Resource Exhaustion
    due to the improper handling of the `ext4` file system under certain conditions.
    An attacker with local access can cause a denial of service by triggering a failure
    in the block freeing process during file system check replay.
  references:
    GitHub Commit: https://github.com/torvalds/linux/commit/c9b528c35795b711331ed36dc3dbee90d5812d4e
  title: Resource Exhaustion
- diff_content:
  - "--- a/drivers/phy/ti/phy-omap-usb2.c\n+++ b/drivers/phy/ti/phy-omap-usb2.c\n\
    @@ -117,7 +117,7 @@ static int omap_usb_set_vbus(struct usb_otg *otg, bool enabled)\n\
    \ {\n \tstruct omap_usb *phy = phy_to_omapusb(otg->usb_phy);\n \n-\tif (!phy->comparator)\n\
    +\tif (!phy->comparator || !phy->comparator->set_vbus)\n \t\treturn -ENODEV;\n\
    \ \n \treturn phy->comparator->set_vbus(phy->comparator, enabled);\n@@ -127,7\
    \ +127,7 @@ static int omap_usb_start_srp(struct usb_otg *otg)\n {\n \tstruct\
    \ omap_usb *phy = phy_to_omapusb(otg->usb_phy);\n \n-\tif (!phy->comparator)\n\
    +\tif (!phy->comparator || !phy->comparator->start_srp)\n \t\treturn -ENODEV;\n\
    \ \n \treturn phy->comparator->start_srp(phy->comparator);"
  identifiers: CVE:["CVE-2024-26600"],CWE:["CWE-476"]
  overview: Affected versions of this package are vulnerable to NULL Pointer Dereference
    due to improper handling of the `phy-omap-usb2` process. An attacker can cause
    a denial of service by exploiting the lack of null pointer check.
  references:
    GitHub Commit: https://github.com/torvalds/linux/commit/7104ba0f1958adb250319e68a15eff89ec4fd36d
  title: NULL Pointer Dereference
- diff_content:
  - "--- a/drivers/edac/thunderx_edac.c\n+++ b/drivers/edac/thunderx_edac.c\n@@ -1133,7\
    \ +1133,7 @@ static irqreturn_t thunderx_ocx_com_threaded_isr(int irq, void *irq_id)\n\
    \ \t\tdecode_register(other, OCX_OTHER_SIZE,\n \t\t\t\tocx_com_errors, ctx->reg_com_int);\n\
    \ \n-\t\tstrncat(msg, other, OCX_MESSAGE_SIZE);\n+\t\tstrlcat(msg, other, OCX_MESSAGE_SIZE);\n\
    \ \n \t\tfor (lane = 0; lane < OCX_RX_LANES; lane++)\n \t\t\tif (ctx->reg_com_int\
    \ & BIT(lane)) {\n@@ -1142,12 +1142,12 @@ static irqreturn_t thunderx_ocx_com_threaded_isr(int\
    \ irq, void *irq_id)\n \t\t\t\t\t lane, ctx->reg_lane_int[lane],\n \t\t\t\t\t\
    \ lane, ctx->reg_lane_stat11[lane]);\n \n-\t\t\t\tstrncat(msg, other, OCX_MESSAGE_SIZE);\n\
    +\t\t\t\tstrlcat(msg, other, OCX_MESSAGE_SIZE);\n \n \t\t\t\tdecode_register(other,\
    \ OCX_OTHER_SIZE,\n \t\t\t\t\t\tocx_lane_errors,\n \t\t\t\t\t\tctx->reg_lane_int[lane]);\n\
    -\t\t\t\tstrncat(msg, other, OCX_MESSAGE_SIZE);\n+\t\t\t\tstrlcat(msg, other,\
    \ OCX_MESSAGE_SIZE);\n \t\t\t}\n \n \t\tif (ctx->reg_com_int & OCX_COM_INT_CE)\n\
    @@ -1217,7 +1217,7 @@ static irqreturn_t thunderx_ocx_lnk_threaded_isr(int irq,\
    \ void *irq_id)\n \t\tdecode_register(other, OCX_OTHER_SIZE,\n \t\t\t\tocx_com_link_errors,\
    \ ctx->reg_com_link_int);\n \n-\t\tstrncat(msg, other, OCX_MESSAGE_SIZE);\n+\t\
    \tstrlcat(msg, other, OCX_MESSAGE_SIZE);\n \n \t\tif (ctx->reg_com_link_int &\
    \ OCX_COM_LINK_INT_UE)\n \t\t\tedac_device_handle_ue(ocx->edac_dev, 0, 0, msg);\n\
    @@ -1896,7 +1896,7 @@ static irqreturn_t thunderx_l2c_threaded_isr(int irq, void\
    \ *irq_id)\n \n \t\tdecode_register(other, L2C_OTHER_SIZE, l2_errors, ctx->reg_int);\n\
    \ \n-\t\tstrncat(msg, other, L2C_MESSAGE_SIZE);\n+\t\tstrlcat(msg, other, L2C_MESSAGE_SIZE);\n\
    \ \n \t\tif (ctx->reg_int & mask_ue)\n \t\t\tedac_device_handle_ue(l2c->edac_dev,\
    \ 0, 0, msg);"
  identifiers: CVE:["CVE-2023-52464"],CWE:["CWE-125"]
  overview: Affected versions of this package are vulnerable to Out-of-bounds Read
    due to improper validation within the `EDAC/thunderx` component. An attacker can
    achieve unauthorized read access.
  references:
    GitHub Commit: https://github.com/torvalds/linux/commit/475c58e1a471e9b873e3e39958c64a2d278275c8
  title: Out-of-bounds Read
- diff_content:
  - "--- a/arch/arm64/kvm/vgic/vgic-its.c\n+++ b/arch/arm64/kvm/vgic/vgic-its.c\n\
    @@ -590,7 +590,11 @@ static struct vgic_irq *vgic_its_check_cache(struct kvm *kvm,\
    \ phys_addr_t db,\n \tunsigned long flags;\n \n \traw_spin_lock_irqsave(&dist->lpi_list_lock,\
    \ flags);\n+\n \tirq = __vgic_its_check_cache(dist, db, devid, eventid);\n+\t\
    if (irq)\n+\t\tvgic_get_irq_kref(irq);\n+\n \traw_spin_unlock_irqrestore(&dist->lpi_list_lock,\
    \ flags);\n \n \treturn irq;\n@@ -769,6 +773,7 @@ int vgic_its_inject_cached_translation(struct\
    \ kvm *kvm, struct kvm_msi *msi)\n \traw_spin_lock_irqsave(&irq->irq_lock, flags);\n\
    \ \tirq->pending_latch = true;\n \tvgic_queue_irq_unlock(kvm, irq, flags);\n+\t\
    vgic_put_irq(kvm, irq);\n \n \treturn 0;\n }"
  identifiers: CVE:["CVE-2024-26598"],CWE:["CWE-416"]
  overview: Affected versions of this package are vulnerable to Use After Free due
    to improper handling of the `LPI translation` cache. An attacker can potentially
    execute code or crash the service.
  references:
    GitHub Commit: https://github.com/torvalds/linux/commit/ad362fe07fecf0aba839ff2cc59a3617bd42c33f
  title: Use After Free
- diff_content:
  - "--- a/drivers/pwm/core.c\n+++ b/drivers/pwm/core.c\n@@ -152,7 +152,7 @@ of_pwm_single_xlate(struct\
    \ pwm_chip *chip, const struct of_phandle_args *args)\n \tpwm->args.period = args->args[0];\n\
    \ \tpwm->args.polarity = PWM_POLARITY_NORMAL;\n \n-\tif (args->args_count == 2\
    \ && args->args[2] & PWM_POLARITY_INVERTED)\n+\tif (args->args_count == 2 && args->args[1]\
    \ & PWM_POLARITY_INVERTED)\n \t\tpwm->args.polarity = PWM_POLARITY_INVERSED;\n\
    \ \n \treturn pwm;"
  identifiers: CVE:["CVE-2024-26599"],CWE:["CWE-125"]
  overview: Affected versions of this package are vulnerable to Out-of-bounds Read
    due to improper bounds checking in the `of_pwm_single_xlate` function. An attacker
    can read sensitive information from memory or cause a crash by supplying a crafted
    input.
  references:
    GitHub Commit: https://github.com/torvalds/linux/commit/a297d07b9a1e4fb8cda25a4a2363a507d294b7c9
  title: Out-of-bounds Read
- diff_content:
  - "--- a/drivers/tty/serial/imx.c\n+++ b/drivers/tty/serial/imx.c\n@@ -415,13 +415,13\
    \ @@ static void imx_uart_stop_tx(struct uart_port *port)\n \tucr1 = imx_uart_readl(sport,\
    \ UCR1);\n \timx_uart_writel(sport, ucr1 & ~UCR1_TRDYEN, UCR1);\n \n+\tucr4 =\
    \ imx_uart_readl(sport, UCR4);\n \tusr2 = imx_uart_readl(sport, USR2);\n-\tif\
    \ (!(usr2 & USR2_TXDC)) {\n+\tif ((!(usr2 & USR2_TXDC)) && (ucr4 & UCR4_TCEN))\
    \ {\n \t\t/* The shifter is still busy, so retry once TC triggers */\n \t\treturn;\n\
    \ \t}\n \n-\tucr4 = imx_uart_readl(sport, UCR4);\n \tucr4 &= ~UCR4_TCEN;\n \t\
    imx_uart_writel(sport, ucr4, UCR4);\n "
  identifiers: CVE:["CVE-2023-52456"],CWE:["CWE-833"]
  overview: Affected versions of this package are vulnerable to Deadlock due to an
    issue in the `tx` statemachine. An attacker can exploit the flawed state transition
    logic.
  references:
    GitHub Commit: https://github.com/torvalds/linux/commit/78d60dae9a0c9f09aa3d6477c94047df2fe6f7b0
  title: Deadlock
- diff_content:
  - "--- a/drivers/iommu/of_iommu.c\n+++ b/drivers/iommu/of_iommu.c\n@@ -252,6 +252,10\
    \ @@ void of_iommu_get_resv_regions(struct device *dev, struct list_head *list)\n\
    \ \t\t\t\t\tprot |= IOMMU_CACHE;\n \n \t\t\t\tmaps = of_translate_dma_region(np,\
    \ maps, &iova, &length);\n+\t\t\t\tif (length == 0) {\n+\t\t\t\t\tdev_warn(dev,\
    \ \"Cannot reserve IOVA region of 0 size\\n\");\n+\t\t\t\t\tcontinue;\n+\t\t\t\
    \t}\n \t\t\t\ttype = iommu_resv_region_get_type(dev, &phys, iova, length);\n \n\
    \ \t\t\t\tregion = iommu_alloc_resv_region(iova, length, prot, type,"
  identifiers: CVE:["CVE-2023-52455"],CWE:["CWE-119"]
  overview: Affected versions of this package are vulnerable to Improper Restriction
    of Operations within the Bounds of a Memory Buffer due to the improper handling
    of 0-length IOVA regions. An attacker can cause a denial of service or potentially
    gain unauthorized access to data by exploiting this flaw.
  references:
    GitHub Commit: https://github.com/torvalds/linux/commit/bb57f6705960bebeb832142ce9abf43220c3eab1
  title: Improper Restriction of Operations within the Bounds of a Memory Buffer
- diff_content:
  - "--- a/drivers/gpu/drm/scheduler/sched_entity.c\n+++ b/drivers/gpu/drm/scheduler/sched_entity.c\n\
    @@ -81,12 +81,15 @@ int drm_sched_entity_init(struct drm_sched_entity *entity,\n\
    \ \t\t */\n \t\tpr_warn(\"%s: called with uninitialized scheduler\\n\", __func__);\n\
    \ \t} else if (num_sched_list) {\n-\t\t/* The \"priority\" of an entity cannot\
    \ exceed the number\n-\t\t * of run-queues of a scheduler.\n+\t\t/* The \"priority\"\
    \ of an entity cannot exceed the number of run-queues of a\n+\t\t * scheduler.\
    \ Protect against num_rqs being 0, by converting to signed.\n \t\t */\n-\t\tif\
    \ (entity->priority >= sched_list[0]->num_rqs)\n-\t\t\tentity->priority = max_t(u32,\
    \ sched_list[0]->num_rqs,\n-\t\t\t\t\t\t DRM_SCHED_PRIORITY_MIN);\n+\t\tif (entity->priority\
    \ >= sched_list[0]->num_rqs) {\n+\t\t\tdrm_err(sched_list[0], \"entity with out-of-bounds\
    \ priority:%u num_rqs:%u\\n\",\n+\t\t\t\tentity->priority, sched_list[0]->num_rqs);\n\
    +\t\t\tentity->priority = max_t(s32, (s32) sched_list[0]->num_rqs - 1,\n+\t\t\t\
    \t\t\t (s32) DRM_SCHED_PRIORITY_MIN);\n+\t\t}\n \t\tentity->rq = sched_list[0]->sched_rq[entity->priority];\n\
    \ \t}\n "
  identifiers: CVE:["CVE-2023-52461"],CWE:["CWE-20"]
  overview: Affected versions of this package are vulnerable to Improper Input Validation
    within the `drm/sched` component. An attacker can exploit this vulnerability by
    submitting a malformed entity to the component, potentially leading to unauthorized
    actions or information disclosure.
  references:
    GitHub Commit: https://github.com/torvalds/linux/commit/2bbe6ab2be53858507f11f99f856846d04765ae3
  title: Improper Input Validation
- diff_content:
  - "--- a/block/ioctl.c\n+++ b/block/ioctl.c\n@@ -18,7 +18,7 @@ static int blkpg_do_ioctl(struct\
    \ block_device *bdev,\n {\n \tstruct gendisk *disk = bdev->bd_disk;\n \tstruct\
    \ blkpg_partition p;\n-\tlong long start, length;\n+\tsector_t start, length;\n\
    \ \n \tif (disk->flags & GENHD_FL_NO_PART)\n \t\treturn -EINVAL;\n@@ -35,14 +35,17\
    \ @@ static int blkpg_do_ioctl(struct block_device *bdev,\n \tif (op == BLKPG_DEL_PARTITION)\n\
    \ \t\treturn bdev_del_partition(disk, p.pno);\n \n+\tif (p.start < 0 || p.length\
    \ <= 0 || p.start + p.length < 0)\n+\t\treturn -EINVAL;\n+\t/* Check that the\
    \ partition is aligned to the block size */\n+\tif (!IS_ALIGNED(p.start | p.length,\
    \ bdev_logical_block_size(bdev)))\n+\t\treturn -EINVAL;\n+\n \tstart = p.start\
    \ >> SECTOR_SHIFT;\n \tlength = p.length >> SECTOR_SHIFT;\n \n \tswitch (op) {\n\
    \ \tcase BLKPG_ADD_PARTITION:\n-\t\t/* check if partition is aligned to blocksize\
    \ */\n-\t\tif (p.start & (bdev_logical_block_size(bdev) - 1))\n-\t\t\treturn -EINVAL;\n\
    \ \t\treturn bdev_add_partition(disk, p.pno, start, length);\n \tcase BLKPG_RESIZE_PARTITION:\n\
    \ \t\treturn bdev_resize_partition(disk, p.pno, start, length);"
  identifiers: CVE:["CVE-2023-52458"],CWE:["CWE-787"]
  overview: Affected versions of this package are vulnerable to Out-of-bounds Write
    due to improper validation of partition length alignment with the block size.
    An attacker can cause a denial of service or potentially execute arbitrary code
    by manipulating the partition length to not align with the expected block size.
  references:
    GitHub Commit: https://github.com/torvalds/linux/commit/6f64f866aa1ae6975c95d805ed51d7e9433a0016
  title: Out-of-bounds Write
- diff_content:
  - "--- a/kernel/bpf/verifier.c\n+++ b/kernel/bpf/verifier.c\n@@ -4431,7 +4431,7\
    \ @@ static int check_stack_write_fixed_off(struct bpf_verifier_env *env,\n \t\
    \ * so it's aligned access and [off, off + size) are within stack limits\n \t\
    \ */\n \tif (!env->allow_ptr_leaks &&\n-\t    state->stack[spi].slot_type[0] ==\
    \ STACK_SPILL &&\n+\t    is_spilled_reg(&state->stack[spi]) &&\n \t    size !=\
    \ BPF_REG_SIZE) {\n \t\tverbose(env, \"attempt to corrupt spilled pointer on stack\\\
    n\");\n \t\treturn -EACCES;"
  identifiers: CVE:["CVE-2023-52462"],CWE:["CWE-400"]
  overview: Affected versions of this package are vulnerable to Resource Exhaustion
    due to improper validation in the `bpf` subsystem. An attacker can cause a denial
    of service condition by attempting to corrupt a spilled pointer.
  references:
    GitHub Commit: https://github.com/torvalds/linux/commit/ab125ed3ec1c10ccc36bc98c7a4256ad114a3dae
  title: Resource Exhaustion
- diff_content:
  - "--- a/fs/efivarfs/super.c\n+++ b/fs/efivarfs/super.c\n@@ -15,6 +15,7 @@\n #include\
    \ <linux/slab.h>\n #include <linux/magic.h>\n #include <linux/statfs.h>\n+#include\
    \ <linux/printk.h>\n \n #include \"internal.h\"\n \n@@ -333,9 +334,20 @@ static\
    \ int efivarfs_get_tree(struct fs_context *fc)\n \treturn get_tree_single(fc,\
    \ efivarfs_fill_super);\n }\n \n+static int efivarfs_reconfigure(struct fs_context\
    \ *fc)\n+{\n+\tif (!efivar_supports_writes() && !(fc->sb_flags & SB_RDONLY)) {\n\
    +\t\tpr_err(\"Firmware does not support SetVariableRT. Can not remount with rw\\\
    n\");\n+\t\treturn -EINVAL;\n+\t}\n+\n+\treturn 0;\n+}\n+\n static const struct\
    \ fs_context_operations efivarfs_context_ops = {\n \t.get_tree\t= efivarfs_get_tree,\n\
    \ \t.parse_param\t= efivarfs_parse_param,\n+\t.reconfigure\t= efivarfs_reconfigure,\n\
    \ };\n \n static int efivarfs_init_fs_context(struct fs_context *fc)"
  identifiers: CVE:["CVE-2023-52463"],CWE:["CWE-362"]
  overview: Affected versions of this package are vulnerable to Race Condition due
    to the improper handling of the `efivarfs` when remounting if `SetVariable` is
    not supported. An attacker can exploit this vulnerability to force the file system
    into a read-only state, potentially leading to a denial of service.
  references:
    GitHub Commit: https://github.com/torvalds/linux/commit/0e8d2444168dd519fea501599d150e62718ed2fe
  title: Race Condition
- diff_content:
  - "--- a/drivers/nvme/target/tcp.c\n+++ b/drivers/nvme/target/tcp.c\n@@ -24,6 +24,7\
    \ @@\n #include \"nvmet.h\"\n \n #define NVMET_TCP_DEF_INLINE_DATA_SIZE\t(4 *\
    \ PAGE_SIZE)\n+#define NVMET_TCP_MAXH2CDATA\t\t0x400000 /* 16M arbitrary limit\
    \ */\n \n static int param_store_val(const char *str, int *val, int min, int max)\n\
    \ {\n@@ -923,7 +924,7 @@ static int nvmet_tcp_handle_icreq(struct nvmet_tcp_queue\
    \ *queue)\n \ticresp->hdr.pdo = 0;\n \ticresp->hdr.plen = cpu_to_le32(icresp->hdr.hlen);\n\
    \ \ticresp->pfv = cpu_to_le16(NVME_TCP_PFV_1_0);\n-\ticresp->maxdata = cpu_to_le32(0x400000);\
    \ /* 16M arbitrary limit */\n+\ticresp->maxdata = cpu_to_le32(NVMET_TCP_MAXH2CDATA);\n\
    \ \ticresp->cpda = 0;\n \tif (queue->hdr_digest)\n \t\ticresp->digest |= NVME_TCP_HDR_DIGEST_ENABLE;\n\
    @@ -978,6 +979,7 @@ static int nvmet_tcp_handle_h2c_data_pdu(struct nvmet_tcp_queue\
    \ *queue)\n {\n \tstruct nvme_tcp_data_pdu *data = &queue->pdu.data;\n \tstruct\
    \ nvmet_tcp_cmd *cmd;\n+\tunsigned int plen;\n \n \tif (likely(queue->nr_cmds))\
    \ {\n \t\tif (unlikely(data->ttag >= queue->nr_cmds)) {\n@@ -1001,7 +1003,16 @@\
    \ static int nvmet_tcp_handle_h2c_data_pdu(struct nvmet_tcp_queue *queue)\n \t\
    \treturn -EPROTO;\n \t}\n \n+\tplen = le32_to_cpu(data->hdr.plen);\n \tcmd->pdu_len\
    \ = le32_to_cpu(data->data_length);\n+\tif (unlikely(cmd->pdu_len != (plen - sizeof(*data))\
    \ ||\n+\t\t     cmd->pdu_len == 0 ||\n+\t\t     cmd->pdu_len > NVMET_TCP_MAXH2CDATA))\
    \ {\n+\t\tpr_err(\"H2CData PDU len %u is invalid\\n\", cmd->pdu_len);\n+\t\t/*\
    \ FIXME: use proper transport errors */\n+\t\tnvmet_tcp_fatal_error(queue);\n\
    +\t\treturn -EPROTO;\n+\t}\n \tcmd->pdu_recv = 0;\n \tnvmet_tcp_build_pdu_iovec(cmd);\n\
    \ \tqueue->cmd = cmd;"
  identifiers: CVE:["CVE-2023-52454"],CWE:["CWE-20"]
  overview: Affected versions of this package are vulnerable to Improper Input Validation
    in the `nvmet-tcp` component. An attacker can trigger a kernel panic and cause
    a denial of service condition by sending a specially crafted `H2C` PDU length.
  references:
    GitHub Commit: https://github.com/torvalds/linux/commit/efa56305908ba20de2104f1b8508c6a7401833be
  title: Improper Input Validation
- diff_content:
  - "--- a/drivers/net/ethernet/mellanox/mlxsw/spectrum_acl_tcam.c\n+++ b/drivers/net/ethernet/mellanox/mlxsw/spectrum_acl_tcam.c\n\
    @@ -681,13 +681,13 @@ static void\n mlxsw_sp_acl_tcam_region_destroy(struct mlxsw_sp\
    \ *mlxsw_sp,\n \t\t\t\t struct mlxsw_sp_acl_tcam_region *region)\n {\n+\tstruct\
    \ mlxsw_sp_acl_tcam *tcam = mlxsw_sp_acl_to_tcam(mlxsw_sp->acl);\n \tconst struct\
    \ mlxsw_sp_acl_tcam_ops *ops = mlxsw_sp->acl_tcam_ops;\n \n \tops->region_fini(mlxsw_sp,\
    \ region->priv);\n \tmlxsw_sp_acl_tcam_region_disable(mlxsw_sp, region);\n \t\
    mlxsw_sp_acl_tcam_region_free(mlxsw_sp, region);\n-\tmlxsw_sp_acl_tcam_region_id_put(region->group->tcam,\n\
    -\t\t\t\t\tregion->id);\n+\tmlxsw_sp_acl_tcam_region_id_put(tcam, region->id);\n\
    \ \tkfree(region);\n }\n "
  identifiers: CVE:["CVE-2024-26595"],CWE:["CWE-476"]
  overview: Affected versions of this package are vulnerable to NULL Pointer Dereference
    due to improper handling of error paths in the `spectrum_acl_tcam` component.
    An attacker can cause a denial of service.
  references:
    GitHub Commit: https://github.com/torvalds/linux/commit/efeb7dfea8ee10cdec11b6b6ba4e405edbe75809
  title: NULL Pointer Dereference
- diff_content:
  - "--- a/kernel/bpf/verifier.c\n+++ b/kernel/bpf/verifier.c\n@@ -12826,6 +12826,10\
    \ @@ static int adjust_ptr_min_max_vals(struct bpf_verifier_env *env,\n \t}\n\
    \ \n \tswitch (base_type(ptr_reg->type)) {\n+\tcase PTR_TO_FLOW_KEYS:\n+\t\tif\
    \ (known)\n+\t\t\tbreak;\n+\t\tfallthrough;\n \tcase CONST_PTR_TO_MAP:\n \t\t\
    /* smin_val represents the known value */\n \t\tif (known && smin_val == 0 &&\
    \ opcode == BPF_ADD)"
  identifiers: CVE:["CVE-2023-52459"],CWE:["CWE-416"]
  overview: 'Affected versions of this package are vulnerable to Use After Free due
    to improper handling of list deletion in the `v4l: async` subsystem. An attacker
    can cause a denial of service or potentially execute arbitrary code by exploiting
    this flaw.'
  references:
    GitHub Commit: https://github.com/torvalds/linux/commit/22c7fa171a02d310e3a3f6ed46a698ca8a0060ed
  title: Use After Free
- diff_content:
  - "--- a/kernel/bpf/verifier.c\n+++ b/kernel/bpf/verifier.c\n@@ -12826,6 +12826,10\
    \ @@ static int adjust_ptr_min_max_vals(struct bpf_verifier_env *env,\n \t}\n\
    \ \n \tswitch (base_type(ptr_reg->type)) {\n+\tcase PTR_TO_FLOW_KEYS:\n+\t\tif\
    \ (known)\n+\t\t\tbreak;\n+\t\tfallthrough;\n \tcase CONST_PTR_TO_MAP:\n \t\t\
    /* smin_val represents the known value */\n \t\tif (known && smin_val == 0 &&\
    \ opcode == BPF_ADD)"
  identifiers: CVE:["CVE-2024-26589"],CWE:["CWE-787"]
  overview: Affected versions of this package are vulnerable to Out-of-bounds Write
    due to the improper handling of variable offset ALU operations on `PTR_TO_FLOW_KEYS`.
    An attacker can cause a denial of service or potentially execute arbitrary code
    by crafting specific BPF programs that exploit this flaw.
  references:
    GitHub Commit: https://github.com/torvalds/linux/commit/22c7fa171a02d310e3a3f6ed46a698ca8a0060ed
  title: Out-of-bounds Write
- diff_content:
  - "--- a/drivers/i2c/busses/i2c-i801.c\n+++ b/drivers/i2c/busses/i2c-i801.c\n@@\
    \ -520,6 +519,7 @@ static int i801_block_transaction_by_block(struct i801_priv\
    \ *priv,\n \t\t}\n \n \t\tdata->block[0] = len;\n+\t\tinb_p(SMBHSTCNT(priv));\t\
    /* reset the data buffer index */\n \t\tfor (i = 0; i < len; i++)\n \t\t\tdata->block[i\
    \ + 1] = inb_p(SMBBLKDAT(priv));\n \t}"
  identifiers: CVE:["CVE-2024-26593"],CWE:["CWE-787"]
  overview: Affected versions of this package are vulnerable to Out-of-bounds Write
    due to improper handling of block process call transactions in the `i2c` subsystem.
    An attacker can cause a denial of service or potentially execute arbitrary code
    by sending crafted input to the affected subsystem.
  references:
    GitHub Commit: https://github.com/torvalds/linux/commit/c1c9d0f6f7f1dbf29db996bd8e166242843a5f21
  title: Out-of-bounds Write
- diff_content:
  - "--- a/drivers/net/ethernet/mellanox/mlxsw/spectrum_acl_tcam.c\n+++ b/drivers/net/ethernet/mellanox/mlxsw/spectrum_acl_tcam.c\n\
    @@ -1564,6 +1564,8 @@ int mlxsw_sp_acl_tcam_init(struct mlxsw_sp *mlxsw_sp,\n\
    \ \ttcam->max_groups = max_groups;\n \ttcam->max_group_size = MLXSW_CORE_RES_GET(mlxsw_sp->core,\n\
    \ \t\t\t\t\t\t  ACL_MAX_GROUP_SIZE);\n+\ttcam->max_group_size = min_t(unsigned\
    \ int, tcam->max_group_size,\n+\t\t\t\t     MLXSW_REG_PAGT_ACL_MAX_NUM);\n \n\
    \ \terr = ops->init(mlxsw_sp, tcam->priv, tcam);\n \tif (err)"
  identifiers: CVE:["CVE-2024-26586"],CWE:["CWE-787"]
  overview: Affected versions of this package are vulnerable to Out-of-bounds Write
    due to improper handling in the `spectrum_acl_tcam` component. An attacker can
    cause stack corruption by exploiting this flaw.
  references:
    GitHub Commit: https://github.com/torvalds/linux/commit/483ae90d8f976f8339cf81066312e1329f2d3706
  title: Out-of-bounds Write
- diff_content:
  - "--- a/kernel/bpf/verifier.c\n+++ b/kernel/bpf/verifier.c\n@@ -1259,7 +1259,10\
    \ @@ static int resize_reference_state(struct bpf_func_state *state, size_t n)\n\
    \ \treturn 0;\n }\n \n-static int grow_stack_state(struct bpf_func_state *state,\
    \ int size)\n+/* Possibly update state->allocated_stack to be at least size bytes.\
    \ Also\n+ * possibly update the function's high-water mark in its bpf_subprog_info.\n\
    + */\n+static int grow_stack_state(struct bpf_verifier_env *env, struct bpf_func_state\
    \ *state, int size)\n {\n \tsize_t old_n = state->allocated_stack / BPF_REG_SIZE,\
    \ n = size / BPF_REG_SIZE;\n \n@@ -1271,6 +1274,11 @@ static int grow_stack_state(struct\
    \ bpf_func_state *state, int size)\n \t\treturn -ENOMEM;\n \n \tstate->allocated_stack\
    \ = size;\n+\n+\t/* update known max for given subprogram */\n+\tif (env->subprog_info[state->subprogno].stack_depth\
    \ < size)\n+\t\tenv->subprog_info[state->subprogno].stack_depth = size;\n+\n \t\
    return 0;\n }\n \n@@ -4440,9 +4448,6 @@ static int check_stack_write_fixed_off(struct\
    \ bpf_verifier_env *env,\n \tstruct bpf_reg_state *reg = NULL;\n \tint insn_flags\
    \ = insn_stack_access_flags(state->frameno, spi);\n \n-\terr = grow_stack_state(state,\
    \ round_up(slot + 1, BPF_REG_SIZE));\n-\tif (err)\n-\t\treturn err;\n \t/* caller\
    \ checked that off % size == 0 and -MAX_BPF_STACK <= off < 0,\n \t * so it's aligned\
    \ access and [off, off + size) are within stack limits\n \t */\n@@ -4595,10 +4600,6\
    \ @@ static int check_stack_write_var_off(struct bpf_verifier_env *env,\n \t \
    \   (!value_reg && is_bpf_st_mem(insn) && insn->imm == 0))\n \t\twriting_zero\
    \ = true;\n \n-\terr = grow_stack_state(state, round_up(-min_off, BPF_REG_SIZE));\n\
    -\tif (err)\n-\t\treturn err;\n-\n \tfor (i = min_off; i < max_off; i++) {\n \t\
    \tint spi;\n \n@@ -5774,20 +5775,6 @@ static int check_ptr_alignment(struct bpf_verifier_env\
    \ *env,\n \t\t\t\t\t   strict);\n }\n \n-static int update_stack_depth(struct\
    \ bpf_verifier_env *env,\n-\t\t\t      const struct bpf_func_state *func,\n-\t\
    \t\t      int off)\n-{\n-\tu16 stack = env->subprog_info[func->subprogno].stack_depth;\n\
    -\n-\tif (stack >= -off)\n-\t\treturn 0;\n-\n-\t/* update known max for given\
    \ subprogram */\n-\tenv->subprog_info[func->subprogno].stack_depth = -off;\n-\t\
    return 0;\n-}\n-\n /* starting from main bpf function walk all instructions of\
    \ the function\n  * and recursively walk all callees that given function can call.\n\
    \  * Ignore jump and exit insns.\n@@ -6577,13 +6564,14 @@ static int check_ptr_to_map_access(struct\
    \ bpf_verifier_env *env,\n  * The minimum valid offset is -MAX_BPF_STACK for writes,\
    \ and\n  * -state->allocated_stack for reads.\n  */\n-static int check_stack_slot_within_bounds(s64\
    \ off,\n-\t\t\t\t\t  struct bpf_func_state *state,\n-\t\t\t\t\t  enum bpf_access_type\
    \ t)\n+static int check_stack_slot_within_bounds(struct bpf_verifier_env *env,\n\
    +                                          s64 off,\n+                       \
    \                   struct bpf_func_state *state,\n+                         \
    \                 enum bpf_access_type t)\n {\n \tint min_valid_off;\n \n-\tif\
    \ (t == BPF_WRITE)\n+\tif (t == BPF_WRITE || env->allow_uninit_stack)\n \t\tmin_valid_off\
    \ = -MAX_BPF_STACK;\n \telse\n \t\tmin_valid_off = -state->allocated_stack;\n\
    @@ -6632,7 +6620,7 @@ static int check_stack_access_within_bounds(\n \t\tmax_off\
    \ = reg->smax_value + off + access_size;\n \t}\n \n-\terr = check_stack_slot_within_bounds(min_off,\
    \ state, type);\n+\terr = check_stack_slot_within_bounds(env, min_off, state,\
    \ type);\n \tif (!err && max_off > 0)\n \t\terr = -EINVAL; /* out of stack access\
    \ into non-negative offsets */\n \n@@ -6647,8 +6635,10 @@ static int check_stack_access_within_bounds(\n\
    \ \t\t\tverbose(env, \"invalid variable-offset%s stack R%d var_off=%s off=%d size=%d\\\
    n\",\n \t\t\t\terr_extra, regno, tn_buf, off, access_size);\n \t\t}\n+\t\treturn\
    \ err;\n \t}\n-\treturn err;\n+\n+\treturn grow_stack_state(env, state, round_up(-min_off,\
    \ BPF_REG_SIZE));\n }\n \n /* check whether memory at (regno + off) is accessible\
    \ for t = (read | write)\n@@ -6663,7 +6653,6 @@ static int check_mem_access(struct\
    \ bpf_verifier_env *env, int insn_idx, u32 regn\n {\n \tstruct bpf_reg_state *regs\
    \ = cur_regs(env);\n \tstruct bpf_reg_state *reg = regs + regno;\n-\tstruct bpf_func_state\
    \ *state;\n \tint size, err = 0;\n \n \tsize = bpf_size_to_bytes(bpf_size);\n\
    @@ -6806,11 +6795,6 @@ static int check_mem_access(struct bpf_verifier_env *env,\
    \ int insn_idx, u32 regn\n \t\tif (err)\n \t\t\treturn err;\n \n-\t\tstate = func(env,\
    \ reg);\n-\t\terr = update_stack_depth(env, state, off);\n-\t\tif (err)\n-\t\t\
    \treturn err;\n-\n \t\tif (t == BPF_READ)\n \t\t\terr = check_stack_read(env,\
    \ regno, off, size,\n \t\t\t\t\t       value_regno);\n@@ -7004,7 +6988,8 @@ static\
    \ int check_atomic(struct bpf_verifier_env *env, int insn_idx, struct bpf_i\n\
    \ \n /* When register 'regno' is used to read the stack (either directly or through\n\
    \  * a helper function) make sure that it's within stack boundary and, depending\n\
    - * on the access type, that all elements of the stack are initialized.\n+ * on\
    \ the access type and privileges, that all elements of the stack are\n+ * initialized.\n\
    \  *\n  * 'off' includes 'regno->off', but not its dynamic part (if any).\n  *\n\
    @@ -7112,8 +7097,11 @@ static int check_stack_range_initialized(\n \n \t\tslot\
    \ = -i - 1;\n \t\tspi = slot / BPF_REG_SIZE;\n-\t\tif (state->allocated_stack\
    \ <= slot)\n-\t\t\tgoto err;\n+\t\tif (state->allocated_stack <= slot) {\n+\t\t\
    \tverbose(env, \"verifier bug: allocated_stack too small\");\n+\t\t\treturn -EFAULT;\n\
    +\t\t}\n+\n \t\tstype = &state->stack[spi].slot_type[slot % BPF_REG_SIZE];\n \t\
    \tif (*stype == STACK_MISC)\n \t\t\tgoto mark;\n@@ -7137,7 +7125,6 @@ static int\
    \ check_stack_range_initialized(\n \t\t\tgoto mark;\n \t\t}\n \n-err:\n \t\tif\
    \ (tnum_is_const(reg->var_off)) {\n \t\t\tverbose(env, \"invalid%s read from stack\
    \ R%d off %d+%d size %d\\n\",\n \t\t\t\terr_extra, regno, min_off, i - min_off,\
    \ access_size);\n@@ -7162,7 +7149,7 @@ static int check_stack_range_initialized(\n\
    \ \t\t * helper may write to the entire memory range.\n \t\t */\n \t}\n-\treturn\
    \ update_stack_depth(env, state, min_off);\n+\treturn 0;\n }\n \n static int check_helper_mem_access(struct\
    \ bpf_verifier_env *env, int regno,"
  - "--- a/tools/testing/selftests/bpf/progs/iters.c\n+++ b/tools/testing/selftests/bpf/progs/iters.c\n\
    @@ -846,7 +846,7 @@ __naked int delayed_precision_mark(void)\n \t\t\"call %[bpf_iter_num_next];\"\
    \n \t\t\"if r0 == 0 goto 2f;\"\n \t\t\"if r6 != 42 goto 3f;\"\n-\t\t\"r7 = -32;\"\
    \n+\t\t\"r7 = -33;\"\n \t\t\"call %[bpf_get_prandom_u32];\"\n \t\t\"r6 = r0;\"\
    \n \t\t\"goto 1b;\\n\""
  - "--- a/tools/testing/selftests/bpf/progs/test_global_func16.c\n+++ b/tools/testing/selftests/bpf/progs/test_global_func16.c\n\
    @@ -13,7 +13,7 @@ __noinline int foo(int (*arr)[10])\n }\n \n SEC(\"cgroup_skb/ingress\"\
    )\n-__failure __msg(\"invalid indirect read from stack\")\n+__success\n int global_func16(struct\
    \ __sk_buff *skb)\n {\n \tint array[10];"
  - "--- a/tools/testing/selftests/bpf/progs/verifier_basic_stack.c\n+++ b/tools/testing/selftests/bpf/progs/verifier_basic_stack.c\n\
    @@ -27,8 +27,8 @@ __naked void stack_out_of_bounds(void)\n \n SEC(\"socket\")\n\
    \ __description(\"uninitialized stack1\")\n-__failure __msg(\"invalid indirect\
    \ read from stack\")\n-__failure_unpriv\n+__success __log_level(4) __msg(\"stack\
    \ depth 8\")\n+__failure_unpriv __msg_unpriv(\"invalid indirect read from stack\"\
    )\n __naked void uninitialized_stack1(void)\n {\n \tasm volatile (\"\t\t\t\t\t\
    \\\n@@ -45,8 +45,8 @@ __naked void uninitialized_stack1(void)\n \n SEC(\"socket\"\
    )\n __description(\"uninitialized stack2\")\n-__failure __msg(\"invalid read from\
    \ stack\")\n-__failure_unpriv\n+__success __log_level(4) __msg(\"stack depth 8\"\
    )\n+__failure_unpriv __msg_unpriv(\"invalid read from stack\")\n __naked void\
    \ uninitialized_stack2(void)\n {\n \tasm volatile (\"\t\t\t\t\t\\"
  - "--- a/tools/testing/selftests/bpf/progs/verifier_int_ptr.c\n+++ b/tools/testing/selftests/bpf/progs/verifier_int_ptr.c\n\
    @@ -5,9 +5,10 @@\n #include <bpf/bpf_helpers.h>\n #include \"bpf_misc.h\"\n \n\
    -SEC(\"cgroup/sysctl\")\n+SEC(\"socket\")\n __description(\"ARG_PTR_TO_LONG uninitialized\"\
    )\n-__failure __msg(\"invalid indirect read from stack R4 off -16+0 size 8\")\n\
    +__success\n+__failure_unpriv __msg_unpriv(\"invalid indirect read from stack\
    \ R4 off -16+0 size 8\")\n __naked void arg_ptr_to_long_uninitialized(void)\n\
    \ {\n \tasm volatile (\"\t\t\t\t\t\\"
  - "--- a/tools/testing/selftests/bpf/progs/verifier_raw_stack.c\n+++ b/tools/testing/selftests/bpf/progs/verifier_raw_stack.c\n\
    @@ -5,9 +5,10 @@\n #include <bpf/bpf_helpers.h>\n #include \"bpf_misc.h\"\n \n\
    -SEC(\"tc\")\n+SEC(\"socket\")\n __description(\"raw_stack: no skb_load_bytes\"\
    )\n-__failure __msg(\"invalid read from stack R6 off=-8 size=8\")\n+__success\n\
    +__failure_unpriv __msg_unpriv(\"invalid read from stack R6 off=-8 size=8\")\n\
    \ __naked void stack_no_skb_load_bytes(void)\n {\n \tasm volatile (\"\t\t\t\t\t\
    \\"
  - "--- a/tools/testing/selftests/bpf/progs/verifier_var_off.c\n+++ b/tools/testing/selftests/bpf/progs/verifier_var_off.c\n\
    @@ -59,9 +59,10 @@ __naked void stack_read_priv_vs_unpriv(void)\n \"\t::: __clobber_all);\n\
    \ }\n \n-SEC(\"lwt_in\")\n+SEC(\"cgroup/skb\")\n __description(\"variable-offset\
    \ stack read, uninitialized\")\n-__failure __msg(\"invalid variable-offset read\
    \ from stack R2\")\n+__success\n+__failure_unpriv __msg_unpriv(\"R2 variable stack\
    \ access prohibited for !root\")\n __naked void variable_offset_stack_read_uninitialized(void)\n\
    \ {\n \tasm volatile (\"\t\t\t\t\t\\\n@@ -83,12 +84,55 @@ __naked void variable_offset_stack_read_uninitialized(void)\n\
    \ \n SEC(\"socket\")\n __description(\"variable-offset stack write, priv vs unpriv\"\
    )\n-__success __failure_unpriv\n+__success\n+/* Check that the maximum stack depth\
    \ is correctly maintained according to the\n+ * maximum possible variable offset.\n\
    + */\n+__log_level(4) __msg(\"stack depth 16\")\n+__failure_unpriv\n /* Variable\
    \ stack access is rejected for unprivileged.\n  */\n __msg_unpriv(\"R2 variable\
    \ stack access prohibited for !root\")\n __retval(0)\n __naked void stack_write_priv_vs_unpriv(void)\n\
    +{\n+\tasm volatile (\"                               \\\n+\t/* Get an unknown\
    \ value */                    \\\n+\tr2 = *(u32*)(r1 + 0);                   \
    \      \\\n+\t/* Make it small and 8-byte aligned */        \\\n+\tr2 &= 8;  \
    \                                    \\\n+\tr2 -= 16;                        \
    \             \\\n+\t/* Add it to fp. We now have either fp-8 or   \\\n+\t * fp-16,\
    \ but we don't know which             \\\n+\t */                             \
    \              \\\n+\tr2 += r10;                                    \\\n+\t/*\
    \ Dereference it for a stack write */        \\\n+\tr0 = 0;                  \
    \                     \\\n+\t*(u64*)(r2 + 0) = r0;                         \\\n\
    +\texit;                                         \\\n+\"\t::: __clobber_all);\n\
    +}\n+\n+/* Similar to the previous test, but this time also perform a read from\
    \ the\n+ * address written to with a variable offset. The read is allowed, showing\
    \ that,\n+ * after a variable-offset write, a priviledged program can read the\
    \ slots that\n+ * were in the range of that write (even if the verifier doesn't\
    \ actually know if\n+ * the slot being read was really written to or not.\n+ *\n\
    + * Despite this test being mostly a superset, the previous test is also kept\
    \ for\n+ * the sake of it checking the stack depth in the case where there is\
    \ no read.\n+ */\n+SEC(\"socket\")\n+__description(\"variable-offset stack write\
    \ followed by read\")\n+__success\n+/* Check that the maximum stack depth is correctly\
    \ maintained according to the\n+ * maximum possible variable offset.\n+ */\n+__log_level(4)\
    \ __msg(\"stack depth 16\")\n+__failure_unpriv\n+__msg_unpriv(\"R2 variable stack\
    \ access prohibited for !root\")\n+__retval(0)\n+__naked void stack_write_followed_by_read(void)\n\
    \ {\n \tasm volatile (\"\t\t\t\t\t\\\n \t/* Get an unknown value */\t\t\t\\\n\
    @@ -103,12 +147,7 @@ __naked void stack_write_priv_vs_unpriv(void)\n \t/* Dereference\
    \ it for a stack write */\t\t\\\n \tr0 = 0;\t\t\t\t\t\t\\\n \t*(u64*)(r2 + 0)\
    \ = r0;\t\t\t\t\\\n-\t/* Now read from the address we just wrote. This shows\\\
    \n-\t * that, after a variable-offset write, a priviledged\\\n-\t * program can\
    \ read the slots that were in the range of\\\n-\t * that write (even if the verifier\
    \ doesn't actually know\\\n-\t * if the slot being read was really written to\
    \ or not.\\\n-\t */\t\t\t\t\t\t\\\n+\t/* Now read from the address we just wrote.\
    \ */ \\\n \tr3 = *(u64*)(r2 + 0);\t\t\t\t\\\n \tr0 = 0;\t\t\t\t\t\t\\\n \texit;\t\
    \t\t\t\t\t\\\n@@ -282,9 +321,10 @@ __naked void access_min_out_of_bound(void)\n\
    \ \t: __clobber_all);\n }\n \n-SEC(\"lwt_in\")\n+SEC(\"cgroup/skb\")\n __description(\"\
    indirect variable-offset stack access, min_off < min_initialized\")\n-__failure\
    \ __msg(\"invalid indirect read from stack R2 var_off\")\n+__success\n+__failure_unpriv\
    \ __msg_unpriv(\"R2 variable stack access prohibited for !root\")\n __naked void\
    \ access_min_off_min_initialized(void)\n {\n \tasm volatile (\"\t\t\t\t\t\\"
  - "--- a/tools/testing/selftests/bpf/verifier/atomic_cmpxchg.c\n+++ b/tools/testing/selftests/bpf/verifier/atomic_cmpxchg.c\n\
    @@ -83,17 +83,6 @@\n \t.result = REJECT,\n \t.errstr = \"!read_ok\",\n },\n-{\n\
    -\t\"Can't use cmpxchg on uninit memory\",\n-\t.insns = {\n-\t\tBPF_MOV64_IMM(BPF_REG_0,\
    \ 3),\n-\t\tBPF_MOV64_IMM(BPF_REG_2, 4),\n-\t\tBPF_ATOMIC_OP(BPF_DW, BPF_CMPXCHG,\
    \ BPF_REG_10, BPF_REG_2, -8),\n-\t\tBPF_EXIT_INSN(),\n-\t},\n-\t.result = REJECT,\n\
    -\t.errstr = \"invalid read from stack\",\n-},\n {\n \t\"BPF_W cmpxchg should\
    \ zero top 32 bits\",\n \t.insns = {"
  - "--- a/tools/testing/selftests/bpf/verifier/calls.c\n+++ b/tools/testing/selftests/bpf/verifier/calls.c\n\
    @@ -1505,7 +1505,9 @@\n \t.prog_type = BPF_PROG_TYPE_XDP,\n \t.fixup_map_hash_8b\
    \ = { 23 },\n \t.result = REJECT,\n-\t.errstr = \"invalid read from stack R7 off=-16\
    \ size=8\",\n+\t.errstr = \"R0 invalid mem access 'scalar'\",\n+\t.result_unpriv\
    \ = REJECT,\n+\t.errstr_unpriv = \"invalid read from stack R7 off=-16 size=8\"\
    ,\n },\n {\n \t\"calls: two calls that receive map_value via arg=ptr_stack_of_caller.\
    \ test1\","
  identifiers: CVE:["CVE-2023-52452"],CWE:["CWE-908"]
  overview: Affected versions of this package are vulnerable to Use After Free due
    to improper handling of accesses to uninitialized stack slots in the BPF subsystem.
    An attacker can cause a denial of service or potentially execute arbitrary code
    by exploiting this flaw.
  references:
    GitHub Commit: https://github.com/torvalds/linux/commit/6b4a64bafd107e521c01eec3453ce94a3fb38529
  title: Use After Free
- diff_content:
  - "--- a/kernel/bpf/syscall.c\n+++ b/kernel/bpf/syscall.c\n@@ -692,6 +692,7 @@ static\
    \ void bpf_map_free_deferred(struct work_struct *work)\n {\n \tstruct bpf_map\
    \ *map = container_of(work, struct bpf_map, work);\n \tstruct btf_record *rec\
    \ = map->record;\n+\tstruct btf *btf = map->btf;\n \n \tsecurity_bpf_map_free(map);\n\
    \ \tbpf_map_release_memcg(map);\n@@ -707,6 +708,10 @@ static void bpf_map_free_deferred(struct\
    \ work_struct *work)\n \t * template bpf_map struct used during verification.\n\
    \ \t */\n \tbtf_record_free(rec);\n+\t/* Delay freeing of btf for maps, as map_free\
    \ callback may need\n+\t * struct_meta info which will be freed with btf_put().\n\
    +\t */\n+\tbtf_put(btf);\n }\n \n static void bpf_map_put_uref(struct bpf_map\
    \ *map)\n@@ -747,7 +752,6 @@ void bpf_map_put(struct bpf_map *map)\n \tif (atomic64_dec_and_test(&map->refcnt))\
    \ {\n \t\t/* bpf_map_free_id() must be called first */\n \t\tbpf_map_free_id(map);\n\
    -\t\tbtf_put(map->btf);\n \n \t\tWARN_ON_ONCE(atomic64_read(&map->sleepable_refcnt));\n\
    \ \t\tif (READ_ONCE(map->free_after_mult_rcu_gp))"
  identifiers: CVE:["CVE-2023-52446"],CWE:["CWE-362"]
  overview: Affected versions of this package are vulnerable to Race Condition between
    `btf_put` and `map_free`. An attacker can exploit this vulnerability to cause
    a denial of service or potentially execute arbitrary code.
  references:
    GitHub Commit: https://github.com/torvalds/linux/commit/59e5791f59dd83e8aa72a4e74217eabb6e8cfd90
  title: Race Condition
- diff_content:
  - "--- a/kernel/bpf/map_in_map.c\n+++ b/kernel/bpf/map_in_map.c\n@@ -129,10 +129,15\
    \ @@ void *bpf_map_fd_get_ptr(struct bpf_map *map,\n \n void bpf_map_fd_put_ptr(struct\
    \ bpf_map *map, void *ptr, bool need_defer)\n {\n-\t/* ptr->ops->map_free() has\
    \ to go through one\n-\t * rcu grace period by itself.\n+\tstruct bpf_map *inner_map\
    \ = ptr;\n+\n+\t/* The inner map may still be used by both non-sleepable and sleepable\n\
    +\t * bpf program, so free it after one RCU grace period and one tasks\n+\t *\
    \ trace RCU grace period.\n \t */\n-\tbpf_map_put(ptr);\n+\tif (need_defer)\n\
    +\t\tWRITE_ONCE(inner_map->free_after_mult_rcu_gp, true);\n+\tbpf_map_put(inner_map);\n\
    \ }\n \n u32 bpf_map_fd_sys_lookup_elem(void *ptr)"
  - "--- a/kernel/bpf/syscall.c\n+++ b/kernel/bpf/syscall.c\n@@ -719,6 +719,28 @@\
    \ static void bpf_map_put_uref(struct bpf_map *map)\n \t}\n }\n \n+static void\
    \ bpf_map_free_in_work(struct bpf_map *map)\n+{\n+\tINIT_WORK(&map->work, bpf_map_free_deferred);\n\
    +\t/* Avoid spawning kworkers, since they all might contend\n+\t * for the same\
    \ mutex like slab_mutex.\n+\t */\n+\tqueue_work(system_unbound_wq, &map->work);\n\
    +}\n+\n+static void bpf_map_free_rcu_gp(struct rcu_head *rcu)\n+{\n+\tbpf_map_free_in_work(container_of(rcu,\
    \ struct bpf_map, rcu));\n+}\n+\n+static void bpf_map_free_mult_rcu_gp(struct\
    \ rcu_head *rcu)\n+{\n+\tif (rcu_trace_implies_rcu_gp())\n+\t\tbpf_map_free_rcu_gp(rcu);\n\
    +\telse\n+\t\tcall_rcu(rcu, bpf_map_free_rcu_gp);\n+}\n+\n /* decrement map refcnt\
    \ and schedule it for freeing via workqueue\n  * (underlying map implementation\
    \ ops->map_free() might sleep)\n  */\n@@ -728,11 +750,11 @@ void bpf_map_put(struct\
    \ bpf_map *map)\n \t\t/* bpf_map_free_id() must be called first */\n \t\tbpf_map_free_id(map);\n\
    \ \t\tbtf_put(map->btf);\n-\t\tINIT_WORK(&map->work, bpf_map_free_deferred);\n\
    -\t\t/* Avoid spawning kworkers, since they all might contend\n-\t\t * for the\
    \ same mutex like slab_mutex.\n-\t\t */\n-\t\tqueue_work(system_unbound_wq, &map->work);\n\
    +\n+\t\tif (READ_ONCE(map->free_after_mult_rcu_gp))\n+\t\t\tcall_rcu_tasks_trace(&map->rcu,\
    \ bpf_map_free_mult_rcu_gp);\n+\t\telse\n+\t\t\tbpf_map_free_in_work(map);\n \t\
    }\n }\n EXPORT_SYMBOL_GPL(bpf_map_put);"
  identifiers: CVE:["CVE-2023-52447"],CWE:["CWE-416"]
  overview: Affected versions of this package are vulnerable to Use After Free due
    to improper handling of the free operation of inner maps under certain conditions.
    An attacker can cause a denial of service or potentially execute arbitrary code
    by exploiting this flaw.
  references:
    GitHub Commit: https://github.com/torvalds/linux/commit/876673364161da50eed6b472d746ef88242b2368
  title: Use After Free
- diff_content:
  - "--- a/drivers/media/usb/pvrusb2/pvrusb2-context.c\n+++ b/drivers/media/usb/pvrusb2/pvrusb2-context.c\n\
    @@ -268,7 +268,8 @@ void pvr2_context_disconnect(struct pvr2_context *mp)\n {\n\
    \ \tpvr2_hdw_disconnect(mp->hdw);\n \tmp->disconnect_flag = !0;\n-\tpvr2_context_notify(mp);\n\
    +\tif (!pvr2_context_shutok())\n+\t\tpvr2_context_notify(mp);\n }\n \n "
  identifiers: CVE:["CVE-2023-52445"],CWE:["CWE-416"]
  overview: Affected versions of this package are vulnerable to Use After Free due
    to improper handling of context disconnection in the `pvrusb2` driver. An attacker
    can exploit this vulnerability to execute arbitrary code or cause a denial of
    service (DoS) condition by manipulating the timing of disconnection events.
  references:
    GitHub Commit: https://github.com/torvalds/linux/commit/ded85b0c0edd8f45fec88783d7555a5b982449c1
  title: Use After Free
- diff_content:
  - "--- a/fs/gfs2/rgrp.c\n+++ b/fs/gfs2/rgrp.c\n@@ -2306,7 +2306,7 @@ void gfs2_rgrp_dump(struct\
    \ seq_file *seq, struct gfs2_rgrpd *rgd,\n \t\t       (unsigned long long)rgd->rd_addr,\
    \ rgd->rd_flags,\n \t\t       rgd->rd_free, rgd->rd_free_clone, rgd->rd_dinodes,\n\
    \ \t\t       rgd->rd_requested, rgd->rd_reserved, rgd->rd_extfail_pt);\n-\tif\
    \ (rgd->rd_sbd->sd_args.ar_rgrplvb) {\n+\tif (rgd->rd_sbd->sd_args.ar_rgrplvb\
    \ && rgd->rd_rgl) {\n \t\tstruct gfs2_rgrp_lvb *rgl = rgd->rd_rgl;\n \n \t\tgfs2_print_dbg(seq,\
    \ \"%s  L: f:%02x b:%u i:%u\\n\", fs_id_buf,"
  identifiers: CVE:["CVE-2023-52448"],CWE:["CWE-476"]
  overview: Affected versions of this package are vulnerable to NULL Pointer Dereference
    due to improper handling of a NULL pointer in the `gfs2_rgrp_dump` function. An
    attacker can cause a denial of service condition.
  references:
    GitHub Commit: https://github.com/torvalds/linux/commit/8877243beafa7c6bfc42022cbfdf9e39b25bd4fa
  title: NULL Pointer Dereference
- diff_content:
  - "--- a/arch/powerpc/platforms/pseries/hotplug-memory.c\n+++ b/arch/powerpc/platforms/pseries/hotplug-memory.c\n\
    @@ -436,14 +436,15 @@ static int dlpar_memory_remove_by_index(u32 drc_index)\n\
    \ \t\t}\n \t}\n \n-\tif (!lmb_found)\n+\tif (!lmb_found) {\n+\t\tpr_debug(\"Failed\
    \ to look up LMB for drc index %x\\n\", drc_index);\n \t\trc = -EINVAL;\n-\n-\t\
    if (rc)\n+\t} else if (rc) {\n \t\tpr_debug(\"Failed to hot-remove memory at %llx\\\
    n\",\n \t\t\t lmb->base_addr);\n-\telse\n+\t} else {\n \t\tpr_debug(\"Memory at\
    \ %llx was hot-removed\\n\", lmb->base_addr);\n+\t}\n \n \treturn rc;\n }"
  identifiers: CVE:["CVE-2023-52451"],CWE:["CWE-787"]
  overview: Affected versions of this package are vulnerable to Out-of-bounds Write
    due to improper validation of user-supplied input in the `drmem` array. An attacker
    can cause a denial of service or possibly execute arbitrary code by exploiting
    this flaw.
  references:
    GitHub Commit: https://github.com/torvalds/linux/commit/bd68ffce69f6cf8ddd3a3c32549d1d2275e49fc5
  title: Out-of-bounds Write
- diff_content:
  - "--- a/drivers/net/netdevsim/netdev.c\n+++ b/drivers/net/netdevsim/netdev.c\n\
    @@ -369,6 +369,12 @@ static int nsim_init_netdevsim_vf(struct netdevsim *ns)\n\
    \ \treturn err;\n }\n \n+static void nsim_exit_netdevsim(struct netdevsim *ns)\n\
    +{\n+\tnsim_udp_tunnels_info_destroy(ns->netdev);\n+\tmock_phc_destroy(ns->phc);\n\
    +}\n+\n struct netdevsim *\n nsim_create(struct nsim_dev *nsim_dev, struct nsim_dev_port\
    \ *nsim_dev_port)\n {\n@@ -417,8 +423,7 @@ void nsim_destroy(struct netdevsim\
    \ *ns)\n \t}\n \trtnl_unlock();\n \tif (nsim_dev_port_is_pf(ns->nsim_dev_port))\n\
    -\t\tnsim_udp_tunnels_info_destroy(dev);\n-\tmock_phc_destroy(ns->phc);\n+\t\t\
    nsim_exit_netdevsim(ns);\n \tfree_netdev(dev);\n }\n "
  identifiers: CVE:["CVE-2024-26587"],CWE:["CWE-400"]
  overview: Affected versions of this package are vulnerable to Resource Exhaustion
    due to improper handling of Physical Hardware Clock (PHC) on Virtual Functions
    (VFs). An attacker can cause a denial of service condition by triggering the destruction
    of PHC on VFs.
  references:
    GitHub Commit: https://github.com/torvalds/linux/commit/ea937f77208323d35ffe2f8d8fc81b00118bfcda
  title: Resource Exhaustion
- diff_content:
  - "--- a/kernel/bpf/syscall.c\n+++ b/kernel/bpf/syscall.c\n@@ -3237,6 +3237,10 @@\
    \ static int bpf_tracing_prog_attach(struct bpf_prog *prog,\n \t *\n \t * - if\
    \ prog->aux->dst_trampoline and tgt_prog is NULL, the program\n \t *   was detached\
    \ and is going for re-attachment.\n+\t *\n+\t * - if prog->aux->dst_trampoline\
    \ is NULL and tgt_prog and prog->aux->attach_btf\n+\t *   are NULL, then program\
    \ was already attached and user did not provide\n+\t *   tgt_prog_fd so we have\
    \ no way to find out or create trampoline\n \t */\n \tif (!prog->aux->dst_trampoline\
    \ && !tgt_prog) {\n \t\t/*\n@@ -3250,6 +3254,11 @@ static int bpf_tracing_prog_attach(struct\
    \ bpf_prog *prog,\n \t\t\terr = -EINVAL;\n \t\t\tgoto out_unlock;\n \t\t}\n+\t\
    \t/* We can allow re-attach only if we have valid attach_btf. */\n+\t\tif (!prog->aux->attach_btf)\
    \ {\n+\t\t\terr = -EINVAL;\n+\t\t\tgoto out_unlock;\n+\t\t}\n \t\tbtf_id = prog->aux->attach_btf_id;\n\
    \ \t\tkey = bpf_trampoline_compute_key(NULL, prog->aux->attach_btf, btf_id);\n\
    \ \t}"
  identifiers: CVE:["CVE-2024-26591"],CWE:["CWE-787"]
  overview: Affected versions of this package are vulnerable to Out-of-bounds Write
    due to improper handling of the re-attachment branch in the `bpf_tracing_prog_attach`
    function. An attacker can cause a denial of service or potentially execute arbitrary
    code by exploiting this flaw.
  references:
    GitHub Commit: https://github.com/torvalds/linux/commit/715d82ba636cb3629a6e18a33bb9dbe53f9936ee
  title: Out-of-bounds Write
- diff_content:
  - "--- a/drivers/mtd/mtd_blkdevs.c\n+++ b/drivers/mtd/mtd_blkdevs.c\n@@ -463,7 +463,7\
    \ @@ static void blktrans_notify_add(struct mtd_info *mtd)\n {\n \tstruct mtd_blktrans_ops\
    \ *tr;\n \n-\tif (mtd->type == MTD_ABSENT)\n+\tif (mtd->type == MTD_ABSENT ||\
    \ mtd->type == MTD_UBIVOLUME)\n \t\treturn;\n \n \tlist_for_each_entry(tr, &blktrans_majors,\
    \ list)\n@@ -503,7 +503,7 @@ int register_mtd_blktrans(struct mtd_blktrans_ops\
    \ *tr)\n \tmutex_lock(&mtd_table_mutex);\n \tlist_add(&tr->list, &blktrans_majors);\n\
    \ \tmtd_for_each_device(mtd)\n-\t\tif (mtd->type != MTD_ABSENT)\n+\t\tif (mtd->type\
    \ != MTD_ABSENT && mtd->type != MTD_UBIVOLUME)\n \t\t\ttr->add_mtd(tr, mtd);\n\
    \ \tmutex_unlock(&mtd_table_mutex);\n \treturn 0;"
  identifiers: CVE:["CVE-2023-52449"],CWE:["CWE-476"]
  overview: Affected versions of this package are vulnerable to NULL Pointer Dereference
    due to the improper handling of a `ftl` notifier. An attacker can cause a denial
    of service or potentially execute arbitrary code.
  references:
    GitHub Commit: https://github.com/torvalds/linux/commit/a43bdc376deab5fff1ceb93dca55bcab8dbdc1d6
  title: NULL Pointer Dereference
- diff_content:
  - "--- a/arch/x86/events/intel/uncore_snbep.c\n+++ b/arch/x86/events/intel/uncore_snbep.c\n\
    @@ -5596,7 +5596,7 @@ static int discover_upi_topology(struct intel_uncore_type\
    \ *type, int ubox_did, i\n \tstruct pci_dev *ubox = NULL;\n \tstruct pci_dev *dev\
    \ = NULL;\n \tu32 nid, gid;\n-\tint i, idx, ret = -EPERM;\n+\tint i, idx, lgc_pkg,\
    \ ret = -EPERM;\n \tstruct intel_uncore_topology *upi;\n \tunsigned int devfn;\n\
    \ \n@@ -5614,8 +5614,13 @@ static int discover_upi_topology(struct intel_uncore_type\
    \ *type, int ubox_did, i\n \t\tfor (i = 0; i < 8; i++) {\n \t\t\tif (nid != GIDNIDMAP(gid,\
    \ i))\n \t\t\t\tcontinue;\n+\t\t\tlgc_pkg = topology_phys_to_logical_pkg(i);\n\
    +\t\t\tif (lgc_pkg < 0) {\n+\t\t\t\tret = -EPERM;\n+\t\t\t\tgoto err;\n+\t\t\t\
    }\n \t\t\tfor (idx = 0; idx < type->num_boxes; idx++) {\n-\t\t\t\tupi = &type->topology[nid][idx];\n\
    +\t\t\t\tupi = &type->topology[lgc_pkg][idx];\n \t\t\t\tdevfn = PCI_DEVFN(dev_link0\
    \ + idx, ICX_UPI_REGS_ADDR_FUNCTION);\n \t\t\t\tdev = pci_get_domain_bus_and_slot(pci_domain_nr(ubox->bus),\n\
    \ \t\t\t\t\t\t\t\t  ubox->bus->number,\n@@ -5626,6 +5631,7 @@ static int discover_upi_topology(struct\
    \ intel_uncore_type *type, int ubox_did, i\n \t\t\t\t\t\tgoto err;\n \t\t\t\t\
    }\n \t\t\t}\n+\t\t\tbreak;\n \t\t}\n \t}\n err:"
  identifiers: CVE:["CVE-2023-52450"],CWE:["CWE-476"]
  overview: Affected versions of this package are vulnerable to NULL Pointer Dereference
    due to an issue in the `upi_fill_topology` function. An attacker can cause a denial
    of service or potentially execute arbitrary code by exploiting this vulnerability.
  references:
    GitHub Commit: https://github.com/torvalds/linux/commit/1692cf434ba1
  title: NULL Pointer Dereference
- diff_content:
  - "--- a/net/tls/tls_sw.c\n+++ b/net/tls/tls_sw.c\n@@ -196,6 +196,17 @@ static void\
    \ tls_decrypt_done(void *data, int err)\n \tstruct sock *sk;\n \tint aead_size;\n\
    \ \n+\t/* If requests get too backlogged crypto API returns -EBUSY and calls\n\
    +\t * ->complete(-EINPROGRESS) immediately followed by ->complete(0)\n+\t * to\
    \ make waiting for backlog to flush with crypto_wait_req() easier.\n+\t * First\
    \ wait converts -EBUSY -> -EINPROGRESS, and the second one\n+\t * -EINPROGRESS\
    \ -> 0.\n+\t * We have a single struct crypto_async_request per direction, this\n\
    +\t * scheme doesn't help us, so just ignore the first ->complete().\n+\t */\n\
    +\tif (err == -EINPROGRESS)\n+\t\treturn;\n+\n \taead_size = sizeof(*aead_req)\
    \ + crypto_aead_reqsize(aead);\n \taead_size = ALIGN(aead_size, __alignof__(*dctx));\n\
    \ \tdctx = (void *)((u8 *)aead_req + aead_size);\n@@ -269,6 +280,10 @@ static\
    \ int tls_do_decryption(struct sock *sk,\n \t}\n \n \tret = crypto_aead_decrypt(aead_req);\n\
    +\tif (ret == -EBUSY) {\n+\t\tret = tls_decrypt_async_wait(ctx);\n+\t\tret = ret\
    \ ?: -EINPROGRESS;\n+\t}\n \tif (ret == -EINPROGRESS) {\n \t\tif (darg->async)\n\
    \ \t\t\treturn 0;\n@@ -449,6 +464,9 @@ static void tls_encrypt_done(void *data,\
    \ int err)\n \tstruct sk_msg *msg_en;\n \tstruct sock *sk;\n \n+\tif (err == -EINPROGRESS)\
    \ /* see the comment in tls_decrypt_done() */\n+\t\treturn;\n+\n \tmsg_en = &rec->msg_encrypted;\n\
    \ \n \tsk = rec->sk;\n@@ -553,6 +571,10 @@ static int tls_do_encryption(struct\
    \ sock *sk,\n \tatomic_inc(&ctx->encrypt_pending);\n \n \trc = crypto_aead_encrypt(aead_req);\n\
    +\tif (rc == -EBUSY) {\n+\t\trc = tls_encrypt_async_wait(ctx);\n+\t\trc = rc ?:\
    \ -EINPROGRESS;\n+\t}\n \tif (!rc || rc != -EINPROGRESS) {\n \t\tatomic_dec(&ctx->encrypt_pending);\n\
    \ \t\tsge->offset -= prot->prepend_size;"
  identifiers: CVE:["CVE-2024-26584"],CWE:["CWE-400"]
  overview: Affected versions of this package are vulnerable to Resource Exhaustion
    due to the handling of backlogging of crypto requests. An attacker can exploit
    this vulnerability by sending crafted requests that could lead to a potentially
    arbitrary code execution.
  references:
    GitHub Commit: https://github.com/torvalds/linux/commit/859054147318
  title: Resource Exhaustion
- diff_content:
  - "--- a/net/tls/tls_sw.c\n+++ b/net/tls/tls_sw.c\n@@ -224,22 +224,15 @@ static\
    \ void tls_decrypt_done(void *data, int err)\n \n \tkfree(aead_req);\n \n-\tspin_lock_bh(&ctx->decrypt_compl_lock);\n\
    -\tif (!atomic_dec_return(&ctx->decrypt_pending))\n+\tif (atomic_dec_and_test(&ctx->decrypt_pending))\n\
    \ \t\tcomplete(&ctx->async_wait.completion);\n-\tspin_unlock_bh(&ctx->decrypt_compl_lock);\n\
    \ }\n \n static int tls_decrypt_async_wait(struct tls_sw_context_rx *ctx)\n {\n\
    -\tint pending;\n-\n-\tspin_lock_bh(&ctx->decrypt_compl_lock);\n-\treinit_completion(&ctx->async_wait.completion);\n\
    -\tpending = atomic_read(&ctx->decrypt_pending);\n-\tspin_unlock_bh(&ctx->decrypt_compl_lock);\n\
    -\tif (pending)\n+\tif (!atomic_dec_and_test(&ctx->decrypt_pending))\n \t\tcrypto_wait_req(-EINPROGRESS,\
    \ &ctx->async_wait);\n+\tatomic_inc(&ctx->decrypt_pending);\n \n \treturn ctx->async_wait.err;\n\
    \ }\n@@ -267,6 +260,7 @@ static int tls_do_decryption(struct sock *sk,\n \t\t\
    aead_request_set_callback(aead_req,\n \t\t\t\t\t  CRYPTO_TFM_REQ_MAY_BACKLOG,\n\
    \ \t\t\t\t\t  tls_decrypt_done, aead_req);\n+\t\tDEBUG_NET_WARN_ON_ONCE(atomic_read(&ctx->decrypt_pending)\
    \ < 1);\n \t\tatomic_inc(&ctx->decrypt_pending);\n \t} else {\n \t\taead_request_set_callback(aead_req,\n\
    @@ -455,7 +449,6 @@ static void tls_encrypt_done(void *data, int err)\n \tstruct\
    \ sk_msg *msg_en;\n \tbool ready = false;\n \tstruct sock *sk;\n-\tint pending;\n\
    \ \n \tmsg_en = &rec->msg_encrypted;\n \n@@ -494,12 +487,8 @@ static void tls_encrypt_done(void\
    \ *data, int err)\n \t\t\tready = true;\n \t}\n \n-\tspin_lock_bh(&ctx->encrypt_compl_lock);\n\
    -\tpending = atomic_dec_return(&ctx->encrypt_pending);\n-\n-\tif (!pending &&\
    \ ctx->async_notify)\n+\tif (atomic_dec_and_test(&ctx->encrypt_pending))\n \t\t\
    complete(&ctx->async_wait.completion);\n-\tspin_unlock_bh(&ctx->encrypt_compl_lock);\n\
    \ \n \tif (!ready)\n \t\treturn;\n@@ -511,22 +500,9 @@ static void tls_encrypt_done(void\
    \ *data, int err)\n \n static int tls_encrypt_async_wait(struct tls_sw_context_tx\
    \ *ctx)\n {\n-\tint pending;\n-\n-\tspin_lock_bh(&ctx->encrypt_compl_lock);\n\
    -\tctx->async_notify = true;\n-\n-\tpending = atomic_read(&ctx->encrypt_pending);\n\
    -\tspin_unlock_bh(&ctx->encrypt_compl_lock);\n-\tif (pending)\n+\tif (!atomic_dec_and_test(&ctx->encrypt_pending))\n\
    \ \t\tcrypto_wait_req(-EINPROGRESS, &ctx->async_wait);\n-\telse\n-\t\treinit_completion(&ctx->async_wait.completion);\n\
    -\n-\t/* There can be no concurrent accesses, since we have no\n-\t * pending\
    \ encrypt operations\n-\t */\n-\tWRITE_ONCE(ctx->async_notify, false);\n+\tatomic_inc(&ctx->encrypt_pending);\n\
    \ \n \treturn ctx->async_wait.err;\n }\n@@ -577,6 +553,7 @@ static int tls_do_encryption(struct\
    \ sock *sk,\n \n \t/* Add the record in tx_list */\n \tlist_add_tail((struct list_head\
    \ *)&rec->list, &ctx->tx_list);\n+\tDEBUG_NET_WARN_ON_ONCE(atomic_read(&ctx->encrypt_pending)\
    \ < 1);\n \tatomic_inc(&ctx->encrypt_pending);\n \n \trc = crypto_aead_encrypt(aead_req);\n\
    @@ -2601,7 +2578,7 @@ static struct tls_sw_context_tx *init_ctx_tx(struct tls_context\
    \ *ctx, struct soc\n \t}\n \n \tcrypto_init_wait(&sw_ctx_tx->async_wait);\n-\t\
    spin_lock_init(&sw_ctx_tx->encrypt_compl_lock);\n+\tatomic_set(&sw_ctx_tx->encrypt_pending,\
    \ 1);\n \tINIT_LIST_HEAD(&sw_ctx_tx->tx_list);\n \tINIT_DELAYED_WORK(&sw_ctx_tx->tx_work.work,\
    \ tx_work_handler);\n \tsw_ctx_tx->tx_work.sk = sk;\n@@ -2622,7 +2599,7 @@ static\
    \ struct tls_sw_context_rx *init_ctx_rx(struct tls_context *ctx)\n \t}\n \n \t\
    crypto_init_wait(&sw_ctx_rx->async_wait);\n-\tspin_lock_init(&sw_ctx_rx->decrypt_compl_lock);\n\
    +\tatomic_set(&sw_ctx_rx->decrypt_pending, 1);\n \tinit_waitqueue_head(&sw_ctx_rx->wq);\n\
    \ \tskb_queue_head_init(&sw_ctx_rx->rx_list);\n \tskb_queue_head_init(&sw_ctx_rx->async_hold);"
  identifiers: CVE:["CVE-2024-26583"],CWE:["CWE-362"]
  overview: Affected versions of this package are vulnerable to Race Condition between
    asynchronous notification and socket closure. An attacker can exploit this vulnerability
    to cause a denial of service or potentially execute arbitrary code by manipulating
    the timing between these operations.
  references:
    GitHub Commit: https://github.com/torvalds/linux/commit/aec7961916f3
  title: Race Condition
- diff_content:
  - "--- a/net/tls/tls_sw.c\n+++ b/net/tls/tls_sw.c\n@@ -63,6 +63,7 @@ struct tls_decrypt_ctx\
    \ {\n \tu8 iv[TLS_MAX_IV_SIZE];\n \tu8 aad[TLS_MAX_AAD_SIZE];\n \tu8 tail;\n+\t\
    bool free_sgout;\n \tstruct scatterlist sg[];\n };\n \n@@ -187,7 +188,6 @@ static\
    \ void tls_decrypt_done(void *data, int err)\n \tstruct aead_request *aead_req\
    \ = data;\n \tstruct crypto_aead *aead = crypto_aead_reqtfm(aead_req);\n \tstruct\
    \ scatterlist *sgout = aead_req->dst;\n-\tstruct scatterlist *sgin = aead_req->src;\n\
    \ \tstruct tls_sw_context_rx *ctx;\n \tstruct tls_decrypt_ctx *dctx;\n \tstruct\
    \ tls_context *tls_ctx;\n@@ -224,7 +224,7 @@ static void tls_decrypt_done(void\
    \ *data, int err)\n \t}\n \n \t/* Free the destination pages if skb was not decrypted\
    \ inplace */\n-\tif (sgout != sgin) {\n+\tif (dctx->free_sgout) {\n \t\t/* Skip\
    \ the first S/G entry as it points to AAD */\n \t\tfor_each_sg(sg_next(sgout),\
    \ sg, UINT_MAX, pages) {\n \t\t\tif (!sg)\n@@ -1583,6 +1583,7 @@ static int tls_decrypt_sg(struct\
    \ sock *sk, struct iov_iter *out_iov,\n \t} else if (out_sg) {\n \t\tmemcpy(sgout,\
    \ out_sg, n_sgout * sizeof(*sgout));\n \t}\n+\tdctx->free_sgout = !!pages;\n \n\
    \ \t/* Prepare and submit AEAD request */\n \terr = tls_do_decryption(sk, sgin,\
    \ sgout, dctx->iv,"
  identifiers: CVE:["CVE-2024-26582"],CWE:["CWE-416"]
  overview: Affected versions of this package are vulnerable to Use After Free due
    to improper handling of partial reads and asynchronous decryption. An attacker
    can exploit this vulnerability to execute arbitrary code or cause a denial of
    service.
  references:
    GitHub Commit: https://github.com/torvalds/linux/commit/32b55c5ff910
  title: Use After Free
- diff_content:
  - "--- a/net/tls/tls_sw.c\n+++ b/net/tls/tls_sw.c\n@@ -447,7 +447,6 @@ static void\
    \ tls_encrypt_done(void *data, int err)\n \tstruct tls_rec *rec = data;\n \tstruct\
    \ scatterlist *sge;\n \tstruct sk_msg *msg_en;\n-\tbool ready = false;\n \tstruct\
    \ sock *sk;\n \n \tmsg_en = &rec->msg_encrypted;\n@@ -483,19 +482,16 @@ static\
    \ void tls_encrypt_done(void *data, int err)\n \t\t/* If received record is at\
    \ head of tx_list, schedule tx */\n \t\tfirst_rec = list_first_entry(&ctx->tx_list,\n\
    \ \t\t\t\t\t     struct tls_rec, list);\n-\t\tif (rec == first_rec)\n-\t\t\tready\
    \ = true;\n+\t\tif (rec == first_rec) {\n+\t\t\t/* Schedule the transmission */\n\
    +\t\t\tif (!test_and_set_bit(BIT_TX_SCHEDULED,\n+\t\t\t\t\t      &ctx->tx_bitmask))\n\
    +\t\t\t\tschedule_delayed_work(&ctx->tx_work.work, 1);\n+\t\t}\n \t}\n \n \tif\
    \ (atomic_dec_and_test(&ctx->encrypt_pending))\n \t\tcomplete(&ctx->async_wait.completion);\n\
    -\n-\tif (!ready)\n-\t\treturn;\n-\n-\t/* Schedule the transmission */\n-\tif\
    \ (!test_and_set_bit(BIT_TX_SCHEDULED, &ctx->tx_bitmask))\n-\t\tschedule_delayed_work(&ctx->tx_work.work,\
    \ 1);\n }\n \n static int tls_encrypt_async_wait(struct tls_sw_context_tx *ctx)"
  identifiers: CVE:["CVE-2024-26585"],CWE:["CWE-362"]
  overview: Affected versions of this package are vulnerable to Race Condition due
    to a race condition between `tx` work scheduling and socket closure. An attacker
    can cause a denial of service by exploiting this timing issue.
  references:
    GitHub Commit: https://github.com/torvalds/linux/commit/e01e3934a1b2
  title: Race Condition
- diff_content:
  - "--- a/fs/smb/client/cached_dir.c\n+++ b/fs/smb/client/cached_dir.c\n@@ -291,16\
    \ +291,23 @@ int open_cached_dir(unsigned int xid, struct cifs_tcon *tcon,\n \t\
    oparms.fid->mid = le64_to_cpu(o_rsp->hdr.MessageId);\n #endif /* CIFS_DEBUG2 */\n\
    \ \n-\trc = -EINVAL;\n+\n \tif (o_rsp->OplockLevel != SMB2_OPLOCK_LEVEL_LEASE)\
    \ {\n+\t\tspin_unlock(&cfids->cfid_list_lock);\n+\t\trc = -EINVAL;\n+\t\tgoto\
    \ oshr_free;\n+\t}\n+\n+\trc = smb2_parse_contexts(server, rsp_iov,\n+\t\t\t\t\
    \ &oparms.fid->epoch,\n+\t\t\t\t oparms.fid->lease_key,\n+\t\t\t\t &oplock, NULL,\
    \ NULL);\n+\tif (rc) {\n \t\tspin_unlock(&cfids->cfid_list_lock);\n \t\tgoto oshr_free;\n\
    \ \t}\n \n-\tsmb2_parse_contexts(server, o_rsp,\n-\t\t\t    &oparms.fid->epoch,\n\
    -\t\t\t    oparms.fid->lease_key, &oplock,\n-\t\t\t    NULL, NULL);\n+\trc = -EINVAL;\n\
    \ \tif (!(oplock & SMB2_LEASE_READ_CACHING_HE)) {\n \t\tspin_unlock(&cfids->cfid_list_lock);\n\
    \ \t\tgoto oshr_free;"
  - "--- a/fs/smb/client/smb2pdu.c\n+++ b/fs/smb/client/smb2pdu.c\n@@ -2236,17 +2236,18\
    \ @@ parse_posix_ctxt(struct create_context *cc, struct smb2_file_all_info *info,\n\
    \ \t\t posix->nlink, posix->mode, posix->reparse_tag);\n }\n \n-void\n-smb2_parse_contexts(struct\
    \ TCP_Server_Info *server,\n-\t\t    struct smb2_create_rsp *rsp,\n-\t\t    unsigned\
    \ int *epoch, char *lease_key, __u8 *oplock,\n-\t\t    struct smb2_file_all_info\
    \ *buf,\n-\t\t    struct create_posix_rsp *posix)\n+int smb2_parse_contexts(struct\
    \ TCP_Server_Info *server,\n+\t\t\tstruct kvec *rsp_iov,\n+\t\t\tunsigned int\
    \ *epoch,\n+\t\t\tchar *lease_key, __u8 *oplock,\n+\t\t\tstruct smb2_file_all_info\
    \ *buf,\n+\t\t\tstruct create_posix_rsp *posix)\n {\n-\tchar *data_offset;\n+\t\
    struct smb2_create_rsp *rsp = rsp_iov->iov_base;\n \tstruct create_context *cc;\n\
    -\tunsigned int next;\n-\tunsigned int remaining;\n+\tsize_t rem, off, len;\n\
    +\tsize_t doff, dlen;\n+\tsize_t noff, nlen;\n \tchar *name;\n \tstatic const\
    \ char smb3_create_tag_posix[] = {\n \t\t0x93, 0xAD, 0x25, 0x50, 0x9C,\n@@ -2255,45\
    \ +2256,63 @@ smb2_parse_contexts(struct TCP_Server_Info *server,\n \t};\n \n\
    \ \t*oplock = 0;\n-\tdata_offset = (char *)rsp + le32_to_cpu(rsp->CreateContextsOffset);\n\
    -\tremaining = le32_to_cpu(rsp->CreateContextsLength);\n-\tcc = (struct create_context\
    \ *)data_offset;\n+\n+\toff = le32_to_cpu(rsp->CreateContextsOffset);\n+\trem\
    \ = le32_to_cpu(rsp->CreateContextsLength);\n+\tif (check_add_overflow(off, rem,\
    \ &len) || len > rsp_iov->iov_len)\n+\t\treturn -EINVAL;\n+\tcc = (struct create_context\
    \ *)((u8 *)rsp + off);\n \n \t/* Initialize inode number to 0 in case no valid\
    \ data in qfid context */\n \tif (buf)\n \t\tbuf->IndexNumber = 0;\n \n-\twhile\
    \ (remaining >= sizeof(struct create_context)) {\n-\t\tname = le16_to_cpu(cc->NameOffset)\
    \ + (char *)cc;\n-\t\tif (le16_to_cpu(cc->NameLength) == 4 &&\n-\t\t    strncmp(name,\
    \ SMB2_CREATE_REQUEST_LEASE, 4) == 0)\n-\t\t\t*oplock = server->ops->parse_lease_buf(cc,\
    \ epoch,\n-\t\t\t\t\t\t\t   lease_key);\n-\t\telse if (buf && (le16_to_cpu(cc->NameLength)\
    \ == 4) &&\n-\t\t    strncmp(name, SMB2_CREATE_QUERY_ON_DISK_ID, 4) == 0)\n-\t\
    \t\tparse_query_id_ctxt(cc, buf);\n-\t\telse if ((le16_to_cpu(cc->NameLength)\
    \ == 16)) {\n-\t\t\tif (posix &&\n-\t\t\t    memcmp(name, smb3_create_tag_posix,\
    \ 16) == 0)\n+\twhile (rem >= sizeof(*cc)) {\n+\t\tdoff = le16_to_cpu(cc->DataOffset);\n\
    +\t\tdlen = le32_to_cpu(cc->DataLength);\n+\t\tif (check_add_overflow(doff, dlen,\
    \ &len) || len > rem)\n+\t\t\treturn -EINVAL;\n+\n+\t\tnoff = le16_to_cpu(cc->NameOffset);\n\
    +\t\tnlen = le16_to_cpu(cc->NameLength);\n+\t\tif (noff + nlen >= doff)\n+\t\t\
    \treturn -EINVAL;\n+\n+\t\tname = (char *)cc + noff;\n+\t\tswitch (nlen) {\n+\t\
    \tcase 4:\n+\t\t\tif (!strncmp(name, SMB2_CREATE_REQUEST_LEASE, 4)) {\n+\t\t\t\
    \t*oplock = server->ops->parse_lease_buf(cc, epoch,\n+\t\t\t\t\t\t\t\t       lease_key);\n\
    +\t\t\t} else if (buf &&\n+\t\t\t\t   !strncmp(name, SMB2_CREATE_QUERY_ON_DISK_ID,\
    \ 4)) {\n+\t\t\t\tparse_query_id_ctxt(cc, buf);\n+\t\t\t}\n+\t\t\tbreak;\n+\t\t\
    case 16:\n+\t\t\tif (posix && !memcmp(name, smb3_create_tag_posix, 16))\n \t\t\
    \t\tparse_posix_ctxt(cc, buf, posix);\n+\t\t\tbreak;\n+\t\tdefault:\n+\t\t\tcifs_dbg(FYI,\
    \ \"%s: unhandled context (nlen=%zu dlen=%zu)\\n\",\n+\t\t\t\t __func__, nlen,\
    \ dlen);\n+\t\t\tif (IS_ENABLED(CONFIG_CIFS_DEBUG2))\n+\t\t\t\tcifs_dump_mem(\"\
    context data: \", cc, dlen);\n+\t\t\tbreak;\n \t\t}\n-\t\t/* else {\n-\t\t\tcifs_dbg(FYI,\
    \ \"Context not matched with len %d\\n\",\n-\t\t\t\tle16_to_cpu(cc->NameLength));\n\
    -\t\t\tcifs_dump_mem(\"Cctxt name: \", name, 4);\n-\t\t} */\n-\n-\t\tnext = le32_to_cpu(cc->Next);\n\
    -\t\tif (!next)\n+\n+\t\toff = le32_to_cpu(cc->Next);\n+\t\tif (!off)\n \t\t\t\
    break;\n-\t\tremaining -= next;\n-\t\tcc = (struct create_context *)((char *)cc\
    \ + next);\n+\t\tif (check_sub_overflow(rem, off, &rem))\n+\t\t\treturn -EINVAL;\n\
    +\t\tcc = (struct create_context *)((u8 *)cc + off);\n \t}\n \n \tif (rsp->OplockLevel\
    \ != SMB2_OPLOCK_LEVEL_LEASE)\n \t\t*oplock = rsp->OplockLevel;\n \n-\treturn;\n\
    +\treturn 0;\n }\n \n static int\n@@ -3124,8 +3143,8 @@ SMB2_open(const unsigned\
    \ int xid, struct cifs_open_parms *oparms, __le16 *path,\n \t}\n \n \n-\tsmb2_parse_contexts(server,\
    \ rsp, &oparms->fid->epoch,\n-\t\t\t    oparms->fid->lease_key, oplock, buf, posix);\n\
    +\trc = smb2_parse_contexts(server, &rsp_iov, &oparms->fid->epoch,\n+\t\t\t\t\
    \ oparms->fid->lease_key, oplock, buf, posix);\n creat_exit:\n \tSMB2_open_free(&rqst);\n\
    \ \tfree_rsp_buf(resp_buftype, rsp);"
  identifiers: CVE:["CVE-2023-52434"],CWE:["CWE-125"]
  overview: Affected versions of this package are vulnerable to Out-of-bounds Read
    due to improper handling in `smb2_parse_contexts` function. An attacker can send
    specially crafted SMB requests.
  references:
    GitHub Commit: https://github.com/torvalds/linux/commit/af1689a9b7701d9907dfc84d2a4b57c4bc907144
  title: Out-of-bounds Read
- diff_content:
  - "--- a/net/core/skbuff.c\n+++ b/net/core/skbuff.c\n@@ -4522,8 +4522,9 @@ struct\
    \ sk_buff *skb_segment(struct sk_buff *head_skb,\n \t\t/* GSO partial only requires\
    \ that we trim off any excess that\n \t\t * doesn't fit into an MSS sized block,\
    \ so take care of that\n \t\t * now.\n+\t\t * Cap len to not accidentally hit\
    \ GSO_BY_FRAGS.\n \t\t */\n-\t\tpartial_segs = len / mss;\n+\t\tpartial_segs =\
    \ min(len, GSO_BY_FRAGS - 1) / mss;\n \t\tif (partial_segs > 1)\n \t\t\tmss *=\
    \ partial_segs;\n \t\telse"
  identifiers: CVE:["CVE-2023-52435"],CWE:["CWE-120"]
  overview: Affected versions of this package are vulnerable to Buffer Overflow due
    to improper handling of the Maximum Segment Size (MSS) in the `skb_segment` function.
    An attacker can send specially crafted packets.
  references:
    GitHub Commit: https://github.com/torvalds/linux/commit/23d05d563b7e7b0314e65c8e882bc27eac2da8e7
  title: Buffer Overflow
- diff_content:
  - "--- a/subsys/fs/fuse_fs_access.c\n+++ b/subsys/fs/fuse_fs_access.c\n@@ -65,8\
    \ +65,15 @@ static void release_file_handle(size_t handle)\n static bool is_mount_point(const\
    \ char *path)\n {\n \tchar dir_path[PATH_MAX];\n+\tsize_t len;\n \n-\tsprintf(dir_path,\
    \ \"%s\", path);\n+\tlen = strlen(path);\n+\tif (len >=  sizeof(dir_path)) {\n\
    +\t\treturn false;\n+\t}\n+\n+\tmemcpy(dir_path, path, len);\n+\tdir_path[len]\
    \ = '\\0';\n \treturn strcmp(dirname(dir_path), \"/\") == 0;\n }\n "
  identifiers: CVE:["CVE-2023-6881"],CWE:["CWE-120"]
  overview: Affected versions of this package are vulnerable to Classic Buffer Overflow
    due to improper validation of input size in the `is_mount_point` function. An
    attacker can trigger a buffer overflow and potentially execute arbitrary code
    or cause a denial of service by supplying crafted input to the affected function.
  references:
    GitHub Commit: https://github.com/zephyrproject-rtos/zephyr/commit/3267bdc4b78bd773b59498c686b4914b3b1c0596
    Vulnerable Code: https://github.com/zephyrproject-rtos/zephyr/blob/main/subsys/fs/fuse_fs_access.c#L69
  title: Classic Buffer Overflow
- diff_content:
  - "--- a/contrib/elf2dmp/pdb.c\n+++ b/contrib/elf2dmp/pdb.c\n@@ -25,6 +25,10 @@\n\
    \ \n static uint32_t pdb_get_file_size(const struct pdb_reader *r, unsigned idx)\n\
    \ {\n+    if (idx >= r->ds.toc->num_files) {\n+        return 0;\n+    }\n+\n\
    \     return r->ds.toc->file_size[idx];\n }\n \n@@ -159,16 +163,17 @@ static void\
    \ *pdb_ds_read_file(struct pdb_reader* r, uint32_t file_number)\n \n static int\
    \ pdb_init_segments(struct pdb_reader *r)\n {\n-    char *segs;\n     unsigned\
    \ stream_idx = r->segments;\n \n-    segs = pdb_ds_read_file(r, stream_idx);\n\
    -    if (!segs) {\n+    r->segs = pdb_ds_read_file(r, stream_idx);\n+    if (!r->segs)\
    \ {\n         return 1;\n     }\n \n-    r->segs = segs;\n     r->segs_size =\
    \ pdb_get_file_size(r, stream_idx);\n+    if (!r->segs_size) {\n+        return\
    \ 1;\n+    }\n \n     return 0;\n }"
  identifiers: CVE:["CVE-2024-24475"],CWE:["CWE-94"]
  overview: Affected versions of this package are vulnerable to Code Injection due
    to the `pdb_get_file_size` component. An attacker can execute arbitrary code by
    exploiting the vulnerability in the specified component.
  references:
    GitHub Commit: https://github.com/qemu/qemu/commit/9d9c06b144da340b9a937ed01d45a936810715be
    GitHub Gist: https://gist.github.com/1047524396/a9f9ad5e3f5cf4dd2cea332ce50c3fc8
  title: Code Injection
- diff_content:
  - "--- a/hw/scsi/esp.c\n+++ b/hw/scsi/esp.c\n@@ -759,7 +759,8 @@ static void esp_do_nodma(ESPState\
    \ *s)\n     }\n \n     if (to_device) {\n-        len = MIN(fifo8_num_used(&s->fifo),\
    \ ESP_FIFO_SZ);\n+        len = MIN(s->async_len, ESP_FIFO_SZ);\n+        len\
    \ = MIN(len, fifo8_num_used(&s->fifo));\n         esp_fifo_pop_buf(&s->fifo, s->async_buf,\
    \ len);\n         s->async_buf += len;\n         s->async_len -= len;"
  identifiers: CVE:["CVE-2024-24474"],CWE:["CWE-120"]
  overview: Affected versions of this package are vulnerable to Buffer Overflow due
    to the improper handling of the `async_len` variable to the `FIFO buffer` component.
    An attacker can execute arbitrary code on the target system by sending crafted
    input.
  references:
    GitHub Commit: https://github.com/qemu/qemu/commit/77668e4b9bca03a856c27ba899a2513ddf52bb52
    GitLab Issue: https://gitlab.com/qemu-project/qemu/-/issues/1810
  title: Buffer Overflow
- diff_content:
  - "--- a/texk/ttfdump/libttf/hdmx.c\n+++ b/texk/ttfdump/libttf/hdmx.c\n@@ -43,7\
    \ +43,7 @@ static void ttfLoadHDMX (FILE *fp,HDMXPtr hdmx,ULONG offset)\n \t{\n\
    \ \t    hdmx->Records[i].PixelSize = ttfGetBYTE(fp);\n \t    hdmx->Records[i].MaxWidth\
    \ = ttfGetBYTE(fp);\n-\t    hdmx->Records[i].Width = XCALLOC (hdmx->size, BYTE);\n\
    +\t    hdmx->Records[i].Width = XCALLOC (hdmx->numGlyphs+1, BYTE);\n \t    fread\
    \ ((hdmx->Records+i)->Width, sizeof(BYTE), hdmx->numGlyphs+1,fp);\n \t}\n }"
  identifiers: CVE:["CVE-2024-25262"],CWE:["CWE-122"]
  overview: Affected versions of this package are vulnerable to Heap-based Buffer
    Overflow in the `ttfLoadHDMX:ttfdump` function. An attacker can cause a denial
    of service by supplying a crafted `TTF` file.
  references:
    ChangeLog: https://tug.org/svn/texlive/trunk/Build/source/texk/ttfdump/ChangeLog?revision=69605&view=co
    GitHub Commit: https://github.com/TeX-Live/texlive-source/commit/a9d26d498acc543c6af10591c50e5a3fa2f6344a
    Vulnerability Report: https://bugs.launchpad.net/ubuntu/+source/texlive-bin/+bug/2047912
  title: Heap-based Buffer Overflow
- diff_content:
  - "--- a/fs/f2fs/xattr.c\n+++ b/fs/f2fs/xattr.c\n@@ -754,6 +754,12 @@ static int\
    \ __f2fs_setxattr(struct inode *inode, int index,\n \t\tmemcpy(pval, value, size);\n\
    \ \t\tlast->e_value_size = cpu_to_le16(size);\n \t\tnew_hsize += newsize;\n+\t\
    \t/*\n+\t\t * Explicitly add the null terminator.  The unused xattr space\n+\t\
    \t * is supposed to always be zeroed, which would make this\n+\t\t * unnecessary,\
    \ but don't depend on that.\n+\t\t */\n+\t\t*(u32 *)((u8 *)last + newsize) = 0;\n\
    \ \t}\n \n \terror = write_all_xattrs(inode, new_hsize, base_addr, ipage);"
  identifiers: CVE:["CVE-2023-52436"],CWE:["CWE-170"]
  overview: Affected versions of this package are vulnerable to Improper Null Termination
    via the `xattr` list. An attacker can cause a denial of service or possibly execute
    arbitrary code.
  references:
    GitHub Commit: https://github.com/torvalds/linux/commit/e26b6d39270f5eab0087453d9b544189a38c8564
  title: Improper Null Termination
- diff_content:
  - "--- a/drivers/md/raid5.c\n+++ b/drivers/md/raid5.c\n@@ -36,7 +36,6 @@\n  */\n\
    \ \n #include <linux/blkdev.h>\n-#include <linux/delay.h>\n #include <linux/kthread.h>\n\
    \ #include <linux/raid/pq.h>\n #include <linux/async_tx.h>\n@@ -6820,18 +6819,7\
    \ @@ static void raid5d(struct md_thread *thread)\n \t\t\tspin_unlock_irq(&conf->device_lock);\n\
    \ \t\t\tmd_check_recovery(mddev);\n \t\t\tspin_lock_irq(&conf->device_lock);\n\
    -\n-\t\t\t/*\n-\t\t\t * Waiting on MD_SB_CHANGE_PENDING below may deadlock\n-\t\
    \t\t * seeing md_check_recovery() is needed to clear\n-\t\t\t * the flag when\
    \ using mdmon.\n-\t\t\t */\n-\t\t\tcontinue;\n \t\t}\n-\n-\t\twait_event_lock_irq(mddev->sb_wait,\n\
    -\t\t\t!test_bit(MD_SB_CHANGE_PENDING, &mddev->sb_flags),\n-\t\t\tconf->device_lock);\n\
    \ \t}\n \tpr_debug(\"%d stripes handled\\n\", handled);\n "
  identifiers: CVE:["CVE-2023-52437"],CWE:["CWE-787"]
  overview: Affected versions of this package are vulnerable to Out-of-bounds Write
    due to improper handling of certain operations within the `RAID5` disk array management.
    An attacker can exploit this flaw to cause a denial of service or potentially
    gain unauthorized access or control over affected systems.
  references:
    GitHub Commit: https://github.com/torvalds/linux/commit/bed9e27baf52a09b7ba2a3714f1e24e17ced386d
  title: Out-of-bounds Write
- diff_content:
  - "--- a/drivers/android/binder_alloc.c\n+++ b/drivers/android/binder_alloc.c\n\
    @@ -1005,7 +1005,9 @@ enum lru_status binder_alloc_free_page(struct list_head\
    \ *item,\n \t\tgoto err_mmget;\n \tif (!mmap_read_trylock(mm))\n \t\tgoto err_mmap_read_lock_failed;\n\
    -\tvma = binder_alloc_get_vma(alloc);\n+\tvma = vma_lookup(mm, page_addr);\n+\t\
    if (vma && vma != binder_alloc_get_vma(alloc))\n+\t\tgoto err_invalid_vma;\n \n\
    \ \tlist_lru_isolate(lru, item);\n \tspin_unlock(lock);\n@@ -1031,6 +1033,8 @@\
    \ enum lru_status binder_alloc_free_page(struct list_head *item,\n \tmutex_unlock(&alloc->mutex);\n\
    \ \treturn LRU_REMOVED_RETRY;\n \n+err_invalid_vma:\n+\tmmap_read_unlock(mm);\n\
    \ err_mmap_read_lock_failed:\n \tmmput_async(mm);\n err_mmget:"
  identifiers: CVE:["CVE-2023-52438"],CWE:["CWE-416"]
  overview: Affected versions of this package are vulnerable to Use After Free due
    to improper handling in the binder's callback mechanism. An attacker with local
    access can achieve arbitrary code execution or cause a denial of service.
  references:
    GitHub Commit: https://github.com/torvalds/linux/commit/3f489c2067c5824528212b0fc18b28d51332d906
  title: Use After Free
- diff_content:
  - "--- a/net/netfilter/nft_set_rbtree.c\n+++ b/net/netfilter/nft_set_rbtree.c\n\
    @@ -312,6 +312,7 @@ static int __nft_rbtree_insert(const struct net *net, const\
    \ struct nft_set *set,\n \tstruct nft_rbtree_elem *rbe, *rbe_le = NULL, *rbe_ge\
    \ = NULL;\n \tstruct rb_node *node, *next, *parent, **p, *first = NULL;\n \tstruct\
    \ nft_rbtree *priv = nft_set_priv(set);\n+\tu8 cur_genmask = nft_genmask_cur(net);\n\
    \ \tu8 genmask = nft_genmask_next(net);\n \tint d, err;\n \n@@ -357,8 +358,11\
    \ @@ static int __nft_rbtree_insert(const struct net *net, const struct nft_set\
    \ *set,\n \t\tif (!nft_set_elem_active(&rbe->ext, genmask))\n \t\t\tcontinue;\n\
    \ \n-\t\t/* perform garbage collection to avoid bogus overlap reports. */\n-\t\
    \tif (nft_set_elem_expired(&rbe->ext)) {\n+\t\t/* perform garbage collection to\
    \ avoid bogus overlap reports\n+\t\t * but skip new elements in this transaction.\n\
    +\t\t */\n+\t\tif (nft_set_elem_expired(&rbe->ext) &&\n+\t\t    nft_set_elem_active(&rbe->ext,\
    \ cur_genmask)) {\n \t\t\terr = nft_rbtree_gc_elem(set, priv, rbe, genmask);\n\
    \ \t\t\tif (err < 0)\n \t\t\t\treturn err;"
  identifiers: CVE:["CVE-2023-52433"],CWE:["CWE-416"]
  overview: Affected versions of this package are vulnerable to Use After Free due
    to improper garbage collection handling for new elements within a specific transaction
    in the `nft_set_rbtree` function. An attacker can cause a denial of service or
    potentially execute arbitrary code by exploiting this flaw.
  references:
    GitHub Commit: https://github.com/torvalds/linux/commit/2ee52ae94baabf7ee09cf2a8d854b990dac5d0e4
  title: Use After Free
- diff_content:
  - "--- a/net/netfilter/nft_set_rbtree.c\n+++ b/net/netfilter/nft_set_rbtree.c\n\
    @@ -234,7 +234,7 @@ static void nft_rbtree_gc_elem_remove(struct net *net, struct\
    \ nft_set *set,\n \n static const struct nft_rbtree_elem *\n nft_rbtree_gc_elem(const\
    \ struct nft_set *__set, struct nft_rbtree *priv,\n-\t\t   struct nft_rbtree_elem\
    \ *rbe, u8 genmask)\n+\t\t   struct nft_rbtree_elem *rbe)\n {\n \tstruct nft_set\
    \ *set = (struct nft_set *)__set;\n \tstruct rb_node *prev = rb_prev(&rbe->node);\n\
    @@ -253,7 +253,7 @@ nft_rbtree_gc_elem(const struct nft_set *__set, struct nft_rbtree\
    \ *priv,\n \twhile (prev) {\n \t\trbe_prev = rb_entry(prev, struct nft_rbtree_elem,\
    \ node);\n \t\tif (nft_rbtree_interval_end(rbe_prev) &&\n-\t\t    nft_set_elem_active(&rbe_prev->ext,\
    \ genmask))\n+\t\t    nft_set_elem_active(&rbe_prev->ext, NFT_GENMASK_ANY))\n\
    \ \t\t\tbreak;\n \n \t\tprev = rb_prev(prev);\n@@ -365,7 +365,7 @@ static int\
    \ __nft_rbtree_insert(const struct net *net, const struct nft_set *set,\n \t\t\
    \    nft_set_elem_active(&rbe->ext, cur_genmask)) {\n \t\t\tconst struct nft_rbtree_elem\
    \ *removed_end;\n \n-\t\t\tremoved_end = nft_rbtree_gc_elem(set, priv, rbe, genmask);\n\
    +\t\t\tremoved_end = nft_rbtree_gc_elem(set, priv, rbe);\n \t\t\tif (IS_ERR(removed_end))\n\
    \ \t\t\t\treturn PTR_ERR(removed_end);\n "
  identifiers: CVE:["CVE-2024-26581"],CWE:["CWE-787"]
  overview: Affected versions of this package are vulnerable to Out-of-bounds Write
    due to improper handling of the `nft_set_rbtree` skip end interval element from
    garbage collection. An attacker can cause a denial of service or potentially execute
    arbitrary code by exploiting this flaw.
  references:
    GitHub Commit: https://github.com/torvalds/linux/commit/60c0c230c6f046da536d3df8b39a20b9a9fd6af0
  title: Out-of-bounds Write
- diff_content:
  - "--- a/app/bluetooth/common/abr_initiator/abr_initiator.c\n+++ b/app/bluetooth/common/abr_initiator/abr_initiator.c\n\
    @@ -3,7 +3,7 @@\n  * @brief ABR initiator\n  *******************************************************************************\n\
    \  * # License\n- * <b>Copyright 2022-2023 Silicon Laboratories Inc. www.silabs.com</b>\n\
    + * <b>Copyright 2024 Silicon Laboratories Inc. www.silabs.com</b>\n  *******************************************************************************\n\
    \  *\n  * SPDX-License-Identifier: Zlib\n@@ -174,33 +174,21 @@ void bt_on_event_initiator(sl_bt_msg_t\
    \ *evt)\n                                            initiator_config->max_ce_length);\n\
    \ \n       app_assert_status(sc);\n+      app_log_info(\"Set connection parameters...\"\
    \ APP_LOG_NL);\n       ras_control_point_characteristic_found = false;\n     \
    \  ras_procedure_enable_data_characteristic_found = false;\n       ras_se_ranging_data_characteristic_found\
    \ = false;\n       ras_characteristics_discovered = false;\n-      sc = sl_bt_cs_set_procedure_parameters(connection_handle,\n\
    -                                             initiator_config->config_id,\n-\
    \                                             initiator_config->max_procedure_duration,\n\
    -                                             initiator_config->min_interval,\n\
    -                                             initiator_config->max_interval,\n\
    -                                             initiator_config->max_procedure_count,\n\
    -                                             initiator_config->min_subevent_len,\n\
    -                                             initiator_config->max_subevent_len,\n\
    -                                             initiator_config->antenna_config,\n\
    -                                             initiator_config->phy,\n-      \
    \                                       initiator_config->tx_pwr_delta,\n-   \
    \                                          initiator_config->preferred_peer_antenna);\n\
    -      app_log_status_warning_f(sc, \"Set procedure parameters failed\" APP_LOG_NL);\n\
    -\n       break;\n \n     case sl_bt_evt_connection_parameters_id:\n       if\
    \ (evt->data.evt_connection_parameters.security_mode == 1) {\n-        app_log_info(\"\
    Connection encrypted\" APP_LOG_NL);\n+        app_log_info(\"Connection parameters\
    \ set. Connection encrypted\" APP_LOG_NL);\n         sc = sl_bt_gatt_discover_primary_services_by_uuid(connection_handle,\n\
    \                                                           UUID_LEN,\n      \
    \                                                     ras_service_uuid);\n   \
    \      app_assert_status(sc);\n+        abr_initiator_create_config();\n     \
    \  }\n       break;\n \n@@ -274,7 +262,21 @@ void bt_on_event_initiator(sl_bt_msg_t\
    \ *evt)\n       break;\n \n     case sl_bt_evt_cs_config_complete_id:\n-     \
    \ app_log_info(\"Config created\" APP_LOG_NL);\n+      app_log_info(\"ABR config\
    \ created. Set procedure parameters ...\" APP_LOG_NL);\n+      sc = sl_bt_cs_set_procedure_parameters(connection_handle,\n\
    +                                             initiator_config->config_id,\n+\
    \                                             initiator_config->max_procedure_duration,\n\
    +                                             initiator_config->min_interval,\n\
    +                                             initiator_config->max_interval,\n\
    +                                             initiator_config->max_procedure_count,\n\
    +                                             initiator_config->min_subevent_len,\n\
    +                                             initiator_config->max_subevent_len,\n\
    +                                             initiator_config->antenna_config,\n\
    +                                             initiator_config->phy,\n+      \
    \                                       initiator_config->tx_pwr_delta,\n+   \
    \                                          initiator_config->preferred_peer_antenna);\n\
    +      app_assert_status(sc);\n+      app_log_info(\"Procedure parameters set\"\
    \ APP_LOG_NL);\n       sc = abr_file_log_config_complete_event(&evt->data.evt_cs_config_complete);\n\
    \       app_assert_status(sc);\n       abr_initiator_start_cs_procedure();\n@@\
    \ -332,7 +334,7 @@ void abr_set_antenna_offset()\n   if (sc != SL_STATUS_OK) {\n\
    \     app_log_warning(\"User message to target failed: %u\" APP_LOG_NL, sc);\n\
    \   } else {\n-    app_log_info(\"Received antenna offset parameters.\" APP_LOG_NL);\n\
    +    app_log_info(\"Received antenna offset parameters\" APP_LOG_NL);\n     //\
    \ First data is the number of antennas\n     initiator_config->antenna_offset.offset_count\
    \ = response_data_offset[0];\n     if (initiator_config->antenna_offset.offset_count\
    \ > MAX_ANTENNA_NUMBER) {\n@@ -799,7 +801,6 @@ static void process_procedure_complete_event(sl_bt_msg_t\
    \ *evt)\n \n     case act_subscribe_result_2:\n       app_log_info(\"Subscribed\
    \ to RAS Control Point indications\" APP_LOG_NL);\n-      abr_initiator_create_config();\n\
    \       action = act_none;\n       break;\n "
  - "--- a/app/bluetooth/common/app_ota_dfu/sl_bt_app_ota_dfu.c\n+++ b/app/bluetooth/common/app_ota_dfu/sl_bt_app_ota_dfu.c\n\
    @@ -3,7 +3,7 @@\n  * @brief Application Over-the-Air Device Firmware Update\n\
    \  *******************************************************************************\n\
    \  * # License\n- * <b>Copyright 2022 Silicon Laboratories Inc. www.silabs.com</b>\n\
    + * <b>Copyright 2024 Silicon Laboratories Inc. www.silabs.com</b>\n  *******************************************************************************\n\
    \  *\n  * SPDX-License-Identifier: Zlib\n@@ -49,8 +49,9 @@\n #define ATT_ERR_STORAGE_FULL\
    \                   0x82u\n #define ATT_ERR_PACKAGE_LOST                   0x83u\n\
    \ \n+// Resizing to fit the 32 bit target architecture.\n #define SL_BT_APP_OTA_DFU_FLASH_VERIFICATION_CONTEXT_SIZE\
    \ \\\n-  (uint16_t)(BOOTLOADER_STORAGE_VERIFICATION_CONTEXT_SIZE >> 2)\n+  (uint16_t)(BOOTLOADER_STORAGE_VERIFICATION_CONTEXT_SIZE\
    \ / sizeof(uint32_t))\n \n #ifndef SL_BT_INVALID_CONNECTION_HANDLE\n #define SL_BT_INVALID_CONNECTION_HANDLE\
    \ ((uint8_t) 0xFF)\n@@ -309,7 +310,7 @@ bool sl_bt_app_ota_dfu_is_ok_to_sleep(void)\n\
    \   // - no verification is in progress\n   // - no storage checking for erase\
    \ is in progress\n   if ((ota_sts == SL_BT_APP_OTA_DFU_VERIFY) \\\n-      || (ota_sts\
    \ == SL_BT_APP_OTA_DFU_ERASE)) {\n+      || (ota_sts == SL_BT_APP_OTA_DFU_READ_FLASH))\
    \ {\n     ret_val = false;\n   }\n   return ret_val;\n@@ -325,7 +326,7 @@ sl_power_manager_on_isr_exit_t\
    \ sl_bt_app_ota_dfu_sleep_on_isr_exit(void)\n   // - verification is in progress\n\
    \   // - storage checking for erase is in progress\n   if ((ota_sts == SL_BT_APP_OTA_DFU_VERIFY)\
    \ \\\n-      || (ota_sts == SL_BT_APP_OTA_DFU_ERASE)) {\n+      || (ota_sts ==\
    \ SL_BT_APP_OTA_DFU_READ_FLASH)) {\n     ret_val = SL_POWER_MANAGER_WAKEUP;\n\
    \   }\n   return ret_val;\n@@ -351,9 +352,11 @@ void sli_bt_app_ota_dfu_step(void)\n\
    \   int32_t btl_ret_val = BOOTLOADER_OK;\n   sl_bt_app_ota_dfu_error_t ota_error\
    \ = SL_BT_APP_OTA_DFU_NO_ERROR;\n   sl_bt_app_ota_dfu_status_t req_sts = SL_BT_APP_OTA_DFU_UNINIT;\n\
    -\n-  uint32_t offset = 0, num_blocks = 0, i = 0;\n   bool dirty = false;\n+ \
    \ uint32_t offset = 0, num_blocks = 0, i = 0;\n+  // Resizing to fit the 32 bit\
    \ target architecture.\n+  uint16_t data_fragments = \\\n+    (uint16_t)(SL_BT_APP_OTA_DFU_READ_STORAGE_CONTEXT_SIZE\
    \ / sizeof(uint32_t));\n \n   switch (ota_sts) {\n     ///////////////////////////////////////////////////////////////////////////\n\
    @@ -383,8 +386,8 @@ void sli_bt_app_ota_dfu_step(void)\n         ota_event.evt_info.btl_storage.storage_size_bytes\
    \ = slot_info.length;\n         ota_event.evt_info.btl_storage.storage_start_addr\
    \ = slot_info.address;\n         sl_bt_app_ota_dfu_on_status_event(&ota_event);\n\
    -        // Proceed to erase state to erase the storage.\n-        req_sts = SL_BT_APP_OTA_DFU_ERASE;\n\
    +        // Proceed to read flash state to determine if erase is necessary or\
    \ not.\n+        req_sts = SL_BT_APP_OTA_DFU_READ_FLASH;\n       } else {\n  \
    \       // Getting bootloader and storage information failed.\n         req_sts\
    \ = SL_BT_APP_OTA_DFU_ERROR;\n@@ -403,10 +406,10 @@ void sli_bt_app_ota_dfu_step(void)\n\
    \       sli_bt_app_ota_dfu_proceed();\n       break;\n     ///////////////////////////////////////////////////////////////////////////\n\
    -    // Erase storage slot if neccessary.                                    \
    \ //\n+    // Check flash storage slot.                                      \
    \       //\n     ///////////////////////////////////////////////////////////////////////////\n\
    -    case SL_BT_APP_OTA_DFU_ERASE:\n-      // Check the download area content\
    \ by reading it in byte blocks.\n+    case SL_BT_APP_OTA_DFU_READ_FLASH:\n+  \
    \    // Check the download area content by reading it in blocks.\n       num_blocks\
    \ = slot_info.length / SL_BT_APP_OTA_DFU_READ_STORAGE_CONTEXT_SIZE;\n       //\
    \ Run through the full storage and read the context in chunks.\n       while ((dirty\
    \ == false) && (offset < SL_BT_APP_OTA_DFU_READ_STORAGE_CONTEXT_SIZE * num_blocks)\
    \ && (btl_ret_val == BOOTLOADER_OK)) {\n@@ -418,8 +421,8 @@ void sli_bt_app_ota_dfu_step(void)\n\
    \                                  SL_BT_APP_OTA_DFU_READ_STORAGE_CONTEXT_SIZE);\n\
    \ \n         if (btl_ret_val == BOOTLOADER_OK) {\n-          // Run through the\
    \ chunk byte-by-byte and check if its empty or not.\n-          for (i = 0; i\
    \ < SL_BT_APP_OTA_DFU_READ_STORAGE_CONTEXT_SIZE && !dirty; i++) {\n+         \
    \ // Run through the chunk in 32 bit fragments and check if its empty or not.\n\
    +          for (i = 0; i < data_fragments && !dirty; i++) {\n             if (ota_buff[i]\
    \ != SL_BT_APP_OTA_DFU_EMPTY_FLASH_CONTENT) {\n               dirty = true;\n\
    \             }\n@@ -435,16 +438,7 @@ void sli_bt_app_ota_dfu_step(void)\n   \
    \      req_sts = SL_BT_APP_OTA_DFU_ERROR;\n       } else if (dirty) {\n      \
    \   // Storage space is not empty proceed to erase.\n-        btl_ret_val = bootloader_eraseStorageSlot(SL_BT_APP_OTA_DFU_USED_SLOT);\n\
    -        if (btl_ret_val != BOOTLOADER_OK) {\n-          // Failed to erase storage\
    \ slot.\n-          ota_error = SL_BT_APP_OTA_DFU_ERR_BOOTLOADER_API;\n-     \
    \     req_sts = SL_BT_APP_OTA_DFU_ERROR;\n-        } else {\n-          // Storage\
    \ slot erased successfully.\n-          // Application OTA DFU component is ready\
    \ for an OTA process.\n-          req_sts = SL_BT_APP_OTA_DFU_READY;\n-      \
    \  }\n+        req_sts = SL_BT_APP_OTA_DFU_ERASE;\n       } else {\n         //\
    \ Storage space was originally empty, proceed to next\n         req_sts = SL_BT_APP_OTA_DFU_READY;\n\
    @@ -462,6 +456,32 @@ void sli_bt_app_ota_dfu_step(void)\n       sli_bt_app_ota_dfu_proceed();\n\
    \       break;\n     ///////////////////////////////////////////////////////////////////////////\n\
    +    // Erase storage slot.                                                  \
    \ //\n+    ///////////////////////////////////////////////////////////////////////////\n\
    +    case SL_BT_APP_OTA_DFU_ERASE:\n+      btl_ret_val = bootloader_eraseStorageSlot(SL_BT_APP_OTA_DFU_USED_SLOT);\n\
    +      if (btl_ret_val != BOOTLOADER_OK) {\n+        // Failed to erase storage\
    \ slot.\n+        ota_error = SL_BT_APP_OTA_DFU_ERR_BOOTLOADER_API;\n+       \
    \ req_sts = SL_BT_APP_OTA_DFU_ERROR;\n+      } else {\n+        // Storage slot\
    \ erased successfully.\n+        // Application OTA DFU component is ready for\
    \ an OTA process.\n+        req_sts = SL_BT_APP_OTA_DFU_READY;\n+      }\n+  \
    \    // Change to next state.\n+      sli_bt_app_ota_dfu_set_main_status(req_sts);\n\
    +      // Forward state change information to application.\n+      ota_event.event_id\
    \ = SL_BT_APP_OTA_DFU_EVT_STATE_CHANGE_ID;\n+      ota_event.ota_error_code =\
    \ ota_error;\n+      ota_event.btl_api_retval = btl_ret_val;\n+      ota_event.evt_info.sts.status\
    \ = ota_sts;\n+      ota_event.evt_info.sts.prev_status = ota_prev_sts;\n+   \
    \   sl_bt_app_ota_dfu_on_status_event(&ota_event);\n+      // Continue execution.\n\
    +      sli_bt_app_ota_dfu_proceed();\n+      break;\n+    ///////////////////////////////////////////////////////////////////////////\n\
    \     // Ready for OTA DFU process.                                          \
    \  //\n     ///////////////////////////////////////////////////////////////////////////\n\
    \     case SL_BT_APP_OTA_DFU_READY:"
  - "--- a/app/bluetooth/common/esl_tag_core/src/esl_tag_core.c\n+++ b/app/bluetooth/common/esl_tag_core/src/esl_tag_core.c\n\
    @@ -285,8 +285,11 @@ void esl_core_step(void)\n       sl_bt_esl_log(ESL_LOG_COMPONENT_CORE,\n\
    \                     ESL_LOG_LEVEL_INFO,\n                     \"Unassociated\
    \ by watchdog timeout.\");\n-    } else if (esl_state_unassociated == esl_tag.status)\
    \ {\n-      // shutdown after one or two hours of advertising in vain\n+     \
    \ if (!ESL_TAG_POWER_DOWN_ENABLE) {\n+        (void)sl_sleeptimer_stop_timer(&esl_tag_persistent.watchdog_handle);\n\
    +      }\n+    } else if (ESL_TAG_POWER_DOWN_ENABLE && esl_state_unassociated\
    \ == esl_tag.status) {\n+      // if power saving is enabled, shut down after\
    \ the specified idle time\n       sl_bt_esl_log(ESL_LOG_COMPONENT_CORE,\n    \
    \                 ESL_LOG_LEVEL_INFO,\n                     \"Shutdown by watchdog\
    \ timeout.\");\n@@ -1229,13 +1232,31 @@ sl_status_t esl_core_start_advertising(void)\n\
    \       // change internal status\n       esl_tag.status = new_esl_status;\n \
    \    }\n-    // start / restart watchdog timer whenever ESL starts advertising\n\
    -    (void)sl_sleeptimer_restart_periodic_timer_ms(&esl_tag_persistent.watchdog_handle,\n\
    -                                                  ESL_CORE_SECURITY_TIMEOUT_MS,\n\
    -                                                  &esl_security_timeout,\n- \
    \                                                 NULL,\n-                   \
    \                               ESL_CORE_SECURITY_TIMER_PRIORITY,\n-         \
    \                                         SL_SLEEPTIMER_NO_HIGH_PRECISION_HF_CLOCKS_REQUIRED_FLAG);\n\
    +\n+    if (esl_tag.status != esl_state_unassociated || ESL_TAG_POWER_DOWN_ENABLE)\
    \ {\n+      uint32_t timeout_ms = ESL_CORE_SECURITY_TIMEOUT_MS;\n+\n+      if\
    \ (ESL_TAG_POWER_DOWN_ENABLE && esl_tag.status == esl_state_unassociated) {\n\
    +        // override default timeout value only if the current ESL state is Unassociated\
    \ AND energy saving is enabled\n+        timeout_ms = ESL_TAG_POWER_DOWN_TIMEOUT_MS;\n\
    +        sl_bt_esl_log(ESL_LOG_COMPONENT_CORE,\n+                      ESL_LOG_LEVEL_INFO,\n\
    +                      \"Enter power save mode after %d minutes of ineffective\
    \ advertising.\",\n+                      ESL_TAG_POWER_DOWN_TIMEOUT_MIN);\n+\
    \      }\n+      // start / restart watchdog timer whenever ESL starts advertising\n\
    +      // except in Unassociated state IF the energy saving is disabled!\n+  \
    \    (void)sl_sleeptimer_restart_periodic_timer_ms(&esl_tag_persistent.watchdog_handle,\n\
    +                                                    timeout_ms,\n+          \
    \                                          &esl_security_timeout,\n+         \
    \                                           NULL,\n+                         \
    \                           ESL_CORE_SECURITY_TIMER_PRIORITY,\n+             \
    \                                       SL_SLEEPTIMER_NO_HIGH_PRECISION_HF_CLOCKS_REQUIRED_FLAG);\n\
    +    } else {\n+      sl_bt_esl_log(ESL_LOG_COMPONENT_CORE,\n+               \
    \     ESL_LOG_LEVEL_INFO,\n+                    \"Power saving disabled by ESL_TAG_POWER_DOWN_ENABLE\
    \ config!\");\n+    }\n   }\n \n   return result;"
  - "--- a/app/bluetooth/common/ots/src/sl_bt_ots_server.c\n+++ b/app/bluetooth/common/ots/src/sl_bt_ots_server.c\n\
    @@ -1351,14 +1351,15 @@ static uint8_t handle_oacp_write(sl_bt_ots_server_t *server,\n\
    \         response_code = SL_BT_OTS_OACP_RESPONSE_CODE_PROCEDURE_NOT_PERMITTED;\n\
    \         break;\n       }\n-      if (client->operation_in_progress != SL_BT_OTS_OACP_OPCODE_READ)\
    \ {\n-        response_code = SL_BT_OTS_OACP_RESPONSE_CODE_OPERATION_FAILED;\n\
    -        break;\n-      }\n \n       // Parameter length is incorrect\n      \
    \ if (write_request->value.len != OACP_MESSAGE_LENGTH_ABORT) {\n         sc =\
    \ ATT_ERR_INVALID_ATTRIBUTE_LEN;\n+        return sc;\n+      }\n+\n+      if\
    \ (client->operation_in_progress != SL_BT_OTS_OACP_OPCODE_READ) {\n+        response_code\
    \ = SL_BT_OTS_OACP_RESPONSE_CODE_OPERATION_FAILED;\n         break;\n       }\n\
    \ \n@@ -1369,18 +1370,14 @@ static uint8_t handle_oacp_write(sl_bt_ots_server_t\
    \ *server,\n       break;\n   }\n \n-  // Send response in ATT error cases\n+\
    \  // Guard\n   if (sc != ATT_ERR_SUCCESS) {\n-    (void)sl_bt_gatt_server_send_user_write_response(write_request->connection,\n\
    -                                                     write_request->characteristic,\n\
    -                                                     sc);\n-    return SL_STATUS_FAIL;\n\
    +    return sc;\n   }\n \n   // Execute OP code\n   if (server->callbacks->on_oacp_event\
    \ != NULL\n-      && response_code == SL_BT_OTS_OACP_RESPONSE_CODE_SUCCESS\n-\
    \      && sc == ATT_ERR_SUCCESS) {\n+      && response_code == SL_BT_OTS_OACP_RESPONSE_CODE_SUCCESS)\
    \ {\n     uint32_t  max_pdu_suggested = 0;\n     uint32_t  max_sdu_suggested =\
    \ 0;\n \n@@ -1493,40 +1490,38 @@ static uint8_t handle_oacp_write(sl_bt_ots_server_t\
    \ *server,\n   (void)sl_bt_gatt_server_send_user_write_response(write_request->connection,\n\
    \                                                    write_request->characteristic,\n\
    \                                                    sc);\n-  if (sc == ATT_ERR_SUCCESS)\
    \ {\n-    send_indication(client->connection_handle,\n-                    server->gattdb_handles->characteristics.handles.object_action_control_point,\n\
    -                    sizeof(oacp_response_msg->opcode)\n-                    +\
    \ sizeof(oacp_response_msg->opcode)\n-                    + sizeof(oacp_response_msg->response)\n\
    -                    + oacp_response_data_len,\n-                    (uint8_t\
    \ *)oacp_response_msg);\n+  send_indication(client->connection_handle,\n+    \
    \              server->gattdb_handles->characteristics.handles.object_action_control_point,\n\
    +                  sizeof(oacp_response_msg->opcode)\n+                  + sizeof(oacp_response_msg->opcode)\n\
    +                  + sizeof(oacp_response_msg->response)\n+                  +\
    \ oacp_response_data_len,\n+                  (uint8_t *)oacp_response_msg);\n\
    \ \n #if SL_BT_OTS_SERVER_CONFIG_GLOBAL_OBJECT_CHANGED_SUPPORT\n-    if (oacp_response_msg->response\
    \ == SL_BT_OTS_OACP_RESPONSE_CODE_SUCCESS\n-        && server->capabilities.capability_object_changed)\
    \ {\n-      // Send indications to clients\n-      switch (oacp_response_msg->opcode)\
    \ {\n-        case SL_BT_OTS_OACP_OPCODE_CREATE:\n-          (void)send_object_changed(server,\n\
    -                                    &client->current_object,\n-             \
    \                       SL_BT_OTS_OBJECT_CHANGE_SOURCE_MASK\n-               \
    \                     | SL_BT_OTS_OBJECT_CHANGE_CREATION_MASK,\n-            \
    \                        client->connection_handle);\n-          break;\n-   \
    \     case SL_BT_OTS_OACP_OPCODE_DELETE:\n-          (void)send_object_changed(server,\n\
    -                                    &client->current_object,\n-             \
    \                       SL_BT_OTS_OBJECT_CHANGE_SOURCE_MASK\n-               \
    \                     | SL_BT_OTS_OBJECT_CHANGE_DELETION_MASK,\n-            \
    \                        client->connection_handle);\n-          break;\n-   \
    \     default:\n-          break;\n-      }\n+  if (oacp_response_msg->response\
    \ == SL_BT_OTS_OACP_RESPONSE_CODE_SUCCESS\n+      && server->capabilities.capability_object_changed)\
    \ {\n+    // Send indications to clients\n+    switch (oacp_response_msg->opcode)\
    \ {\n+      case SL_BT_OTS_OACP_OPCODE_CREATE:\n+        (void)send_object_changed(server,\n\
    +                                  &client->current_object,\n+               \
    \                   SL_BT_OTS_OBJECT_CHANGE_SOURCE_MASK\n+                   \
    \               | SL_BT_OTS_OBJECT_CHANGE_CREATION_MASK,\n+                  \
    \                client->connection_handle);\n+        break;\n+      case SL_BT_OTS_OACP_OPCODE_DELETE:\n\
    +        (void)send_object_changed(server,\n+                                \
    \  &client->current_object,\n+                                  SL_BT_OTS_OBJECT_CHANGE_SOURCE_MASK\n\
    +                                  | SL_BT_OTS_OBJECT_CHANGE_DELETION_MASK,\n\
    +                                  client->connection_handle);\n+        break;\n\
    +      default:\n+        break;\n     }\n-#endif // SL_BT_OTS_SERVER_CONFIG_GLOBAL_OBJECT_CHANGED_SUPPORT\n\
    \   }\n+#endif // SL_BT_OTS_SERVER_CONFIG_GLOBAL_OBJECT_CHANGED_SUPPORT\n \n \
    \  return sc;\n }\n@@ -1539,6 +1534,7 @@ static sl_status_t send_indication(uint8_t\
    \       connection,\n   sl_status_t sc;\n \n   sli_bt_ots_indication_queue_item_t\
    \ item;\n+  memset(&item, 0x00, sizeof(item));\n   item.connection = connection;\n\
    \   item.gattdb_handle = characteristic;\n   item.data_length = value_len;\n@@\
    \ -1708,11 +1704,15 @@ static uint8_t handle_olcp_write(sl_bt_ots_server_t *server,\n\
    \       response_code = SL_BT_OTS_OLCP_RESPONSE_CODE_OP_CODE_NOT_SUPPORTED;\n\
    \   }\n \n+  // Guard\n+  if (sc != ATT_ERR_SUCCESS) {\n+    return sc;\n+  }\n\
    +\n   uint32_t number_of_objects = 0;\n   // Execute OP code\n   if (server->callbacks->on_olcp_event\
    \ != NULL\n-      && response_code == SL_BT_OTS_OLCP_RESPONSE_CODE_SUCCESS\n-\
    \      && sc == ATT_ERR_SUCCESS) {\n+      && response_code == SL_BT_OTS_OLCP_RESPONSE_CODE_SUCCESS)\
    \ {\n     response_code = server->callbacks->on_olcp_event(server,\n         \
    \                                             client->connection_handle,\n   \
    \                                                   &client->current_object,\n\
    @@ -1730,12 +1730,10 @@ static uint8_t handle_olcp_write(sl_bt_ots_server_t *server,\n\
    \                                                    write_request->characteristic,\n\
    \                                                    sc);\n \n-  if (sc == ATT_ERR_SUCCESS)\
    \ {\n-    send_indication(client->connection_handle,\n-                    server->gattdb_handles->characteristics.handles.object_list_control_point,\n\
    -                    response_code_len,\n-                    (uint8_t *)olcp_response_msg);\n\
    -  }\n+  send_indication(client->connection_handle,\n+                  server->gattdb_handles->characteristics.handles.object_list_control_point,\n\
    +                  response_code_len,\n+                  (uint8_t *)olcp_response_msg);\n\
    \ \n   return sc;\n }"
  - "--- a/app/bluetooth/common/ots/src/sl_bt_ots_server_bm.c\n+++ b/app/bluetooth/common/ots/src/sl_bt_ots_server_bm.c\n\
    @@ -51,8 +51,9 @@ static app_queue_t indication_queue[SL_BT_CONFIG_MAX_CONNECTIONS];\n\
    \ \n // -----------------------------------------------------------------------------\n\
    \ // Forward declaration of private functions\n-\n+#ifdef SL_CATALOG_POWER_MANAGER_PRESENT\n\
    \ static bool server_has_task(void);\n+#endif // SL_CATALOG_POWER_MANAGER_PRESENT\n\
    \ \n // -----------------------------------------------------------------------------\n\
    \ // Bare metal functions"
  - "--- a/app/bluetooth/common/simple_com/sl_simple_com_usart.c\n+++ b/app/bluetooth/common/simple_com/sl_simple_com_usart.c\n\
    @@ -83,15 +83,16 @@ static void receive_cb(UARTDRV_Handle_t handle,\n        \
    \                uint8_t *data,\n                        UARTDRV_Count_t transferCount);\n\
    \ // Helper functions to ensure reception\n-static Ecode_t abort_receive(UARTDRV_Handle_t\
    \ handle);\n+static Ecode_t cancel_receive(UARTDRV_Handle_t handle);\n static\
    \ Ecode_t get_tail_buffer(UARTDRV_Buffer_FifoQueue_t *queue,\n               \
    \                 UARTDRV_Buffer_t **buffer);\n static Ecode_t dequeue_buffer(UARTDRV_Buffer_FifoQueue_t\
    \ *queue,\n                               UARTDRV_Buffer_t **buffer);\n-static\
    \ void disable_receiver(UARTDRV_Handle_t handle);\n \n static IRQn_Type irq_number_from_handle(UARTDRV_Handle_t\
    \ handle);\n \n+static Ecode_t uart_receive_start(UARTDRV_Handle_t handle);\n\
    +\n void sli_simple_com_isr(void);\n \n // -----------------------------------------------------------------------------\n\
    @@ -197,8 +198,7 @@ void sl_simple_com_receive(void)\n   // Clear any USART interrupt\
    \ flags\n   USART_IntClear(uartdrv_handle->peripheral.uart, _USART_IF_MASK);\n\
    \   USART_IntEnable(uartdrv_handle->peripheral.uart, USART_IF_TXIDLE | USART_IF_TCMP1);\n\
    -  // Start reception with callback set\n-  ec = UARTDRV_Receive(uartdrv_handle,\
    \ rx_buf, sizeof(rx_buf), receive_cb);\n+  ec = uart_receive_start(uartdrv_handle);\n\
    \   app_assert(ECODE_EMDRV_UARTDRV_OK == ec,\n              \"[E: 0x%04x] Failed\
    \ to start receiving\\n\",\n              (int)ec);\n@@ -250,6 +250,12 @@ static\
    \ void timer_callback(sl_sleeptimer_timer_handle_t *handle,\n {\n   (void)handle;\n\
    \   (void)data;\n+\n+  // Assert nRTS\n+  if (uartdrv_handle->fcType != uartdrvFlowControlHwUart)\
    \ {\n+    UARTDRV_FlowControlSet(uartdrv_handle, uartdrvFlowControlOff);\n+  }\n\
    +\n   // Get received bytes\n   uint8_t* buffer = NULL;\n   uint32_t received\
    \ = 0;\n@@ -262,9 +268,9 @@ static void timer_callback(sl_sleeptimer_timer_handle_t\
    \ *handle,\n     CORE_DECLARE_IRQ_STATE;\n     CORE_ENTER_ATOMIC();\n \n-    //\
    \ abort receive operation\n-    (void)abort_receive(uartdrv_handle);\n-    sl_simple_com_receive();\n\
    +    // cancel previous block receive operation\n+    (void)cancel_receive(uartdrv_handle);\n\
    +    uart_receive_start(uartdrv_handle);\n     CORE_EXIT_ATOMIC();\n     received_count\
    \ = 0;\n   } else {\n@@ -275,7 +281,7 @@ static void timer_callback(sl_sleeptimer_timer_handle_t\
    \ *handle,\n \n #endif // EFR32BG1_USART_E202_WORKAROUND\n \n-/**************************************************************************//**\n\
    +/******************************************************************************\n\
    \  * UART interrupt handler\n  *\n  * Called when the set timer for tx idle states\
    \ finished.\n@@ -288,6 +294,12 @@ void sli_simple_com_isr(void)\n   // RX timeout,\
    \ stop transfer and handle what we got in buffer\n   if (uartdrv_handle->peripheral.uart->IF\
    \ & USART_IF_TCMP1) {\n     CORE_DECLARE_IRQ_STATE;\n+\n+    // Assert nRTS\n\
    +    if (uartdrv_handle->fcType != uartdrvFlowControlHwUart) {\n+      UARTDRV_FlowControlSet(uartdrv_handle,\
    \ uartdrvFlowControlOff);\n+    }\n+\n     CORE_ENTER_ATOMIC();\n     // stop\
    \ the timer\n     uartdrv_handle->peripheral.uart->TIMECMP1 &= \\\n@@ -313,20\
    \ +325,20 @@ void sli_simple_com_isr(void)\n     UARTDRV_GetReceiveStatus(uartdrv_handle,\
    \ &buffer, &received, &remaining);\n     received_count = received;\n #else\n\
    -    // abort receive operation\n-    (void)abort_receive(uartdrv_handle);\n-\
    \    sl_simple_com_receive();\n+    // cancel previous block receive operation\n\
    +    (void)cancel_receive(uartdrv_handle);\n+    uart_receive_start(uartdrv_handle);\n\
    \ #endif // EFR32BG1_USART_E202_WORKAROUND\n     CORE_EXIT_ATOMIC();\n   }\n }\n\
    \ \n-/**************************************************************************//**\n\
    +/******************************************************************************\n\
    \  * Internal UART transmit completed callback\n  *\n  * Called after UART transmit\
    \ is finished.\n  *\n- * @param[in] handle Connection handle\n+ * @param[in] handle\
    \ UART driver handle\n  * @param[in] transferStatus Status of the transfer\n \
    \ * @param[in] data Transmitted data\n  * @param[in] transferCount Number of sent\
    \ bytes\n@@ -351,12 +363,12 @@ static void transmit_cb(UARTDRV_Handle_t handle,\n\
    \   sl_simple_com_os_task_proceed();\n }\n \n-/**************************************************************************//**\n\
    +/******************************************************************************\n\
    \  * Internal UART receive completed callback\n  *\n  * Called after UART receive\
    \ is finished.\n  *\n- * @param[in] handle Connection handle\n+ * @param[in] handle\
    \ UART driver handle\n  * @param[in] transferStatus Status of the transfer\n \
    \ * @param[in] data Received data\n  * @param[in] transferCount Number of received\
    \ bytes\n@@ -391,17 +403,15 @@ static void receive_cb(UARTDRV_Handle_t handle,\n\
    \                              data);\n   }\n \n-  // Clear RX buffer\n-  memset(rx_buf,\
    \ 0, sizeof(rx_buf));\n   sl_simple_com_os_task_proceed();\n }\n \n-/**************************************************************************//**\n\
    - * Aborted reception handler\n+/******************************************************************************\n\
    + * Cancel previous block receive operation.\n  *\n- * @param[in] handle Connection\
    \ handle\n+ * @param[in] handle UART driver handle\n  *****************************************************************************/\n\
    -static Ecode_t abort_receive(UARTDRV_Handle_t handle)\n+static Ecode_t cancel_receive(UARTDRV_Handle_t\
    \ handle)\n {\n   UARTDRV_Buffer_t *rxBuffer;\n   Ecode_t status;\n@@ -418,12\
    \ +428,12 @@ static Ecode_t abort_receive(UARTDRV_Handle_t handle)\n   }\n \n\
    \   // -------------------------------\n-  // Stop the current transfer\n+  //\
    \ Stop the current DMA transfer\n   (void)DMADRV_StopTransfer(handle->rxDmaCh);\n\
    \   handle->rxDmaActive = false;\n   // Update the transfer status of the active\
    \ transfer\n   status = get_tail_buffer(handle->rxQueue, &rxBuffer);\n-  // If\
    \ an abort was in progress when DMA completed, the ISR could be deferred\n+  //\
    \ If aborting was in progress when DMA completed, the ISR could be deferred\n\
    \   // until after the critical section. In this case, the buffers no longer\n\
    \   // exist, even though the DMA complete callback was called.\n   if (status\
    \ == ECODE_EMDRV_UARTDRV_QUEUE_EMPTY) {\n@@ -450,16 +460,12 @@ static Ecode_t\
    \ abort_receive(UARTDRV_Handle_t handle)\n   }\n \n   // -------------------------------\n\
    -  // Disable the receiver\n-  if (handle->fcType != uartdrvFlowControlHwUart)\
    \ {\n-    disable_receiver(handle);\n-  }\n   CORE_EXIT_ATOMIC();\n \n   return\
    \ ECODE_EMDRV_UARTDRV_OK;\n }\n \n-/**************************************************************************//**\n\
    +/******************************************************************************\n\
    \  * Gets the buffer tail.\n  *\n  * @param[in] queue Input buffer\n@@ -482,7\
    \ +488,7 @@ static Ecode_t get_tail_buffer(UARTDRV_Buffer_FifoQueue_t *queue,\n\
    \   return ECODE_EMDRV_UARTDRV_OK;\n }\n \n-/**************************************************************************//**\n\
    +/******************************************************************************\n\
    \  * Dequeues buffer\n  *\n  * Moves through the buffer.\n@@ -509,61 +515,10 @@\
    \ static Ecode_t dequeue_buffer(UARTDRV_Buffer_FifoQueue_t *queue,\n   return\
    \ ECODE_EMDRV_UARTDRV_OK;\n }\n \n-/**************************************************************************//**\n\
    - * Disables receiver.\n- *\n- * @param[in] handle Connection handle\n- *****************************************************************************/\n\
    -static void disable_receiver(UARTDRV_Handle_t handle)\n-{\n-#if (defined(LEUART_COUNT)\
    \ && (LEUART_COUNT > 0) \\\n-  && !defined(_SILICON_LABS_32B_SERIES_2))      \
    \ \\\n-  || (defined(EUART_COUNT) && (EUART_COUNT > 0) )\n-  if (handle->type\
    \ == uartdrvUartTypeUart)\n-#endif\n-  {\n-    // Disable Rx route\n-    #if defined(USART_ROUTEPEN_RXPEN)\n\
    -    handle->peripheral.uart->ROUTEPEN &= ~USART_ROUTEPEN_RXPEN;\n-    #elif defined(USART_ROUTE_RXPEN)\n\
    -    handle->peripheral.uart->ROUTE &= ~USART_ROUTE_RXPEN;\n-    #elif defined(GPIO_USART_ROUTEEN_RXPEN)\n\
    -    GPIO->USARTROUTE_CLR[handle->uartNum].ROUTEEN = GPIO_USART_ROUTEEN_RXPEN;\n\
    -    #endif\n-    // Disable Rx\n-    handle->peripheral.uart->CMD = USART_CMD_RXDIS;\n\
    -  }\n-#if defined(LEUART_COUNT) && (LEUART_COUNT > 0) \\\n-  && !defined(_SILICON_LABS_32B_SERIES_2)\n\
    -  else if (handle->type == uartdrvUartTypeLeuart) {\n-    // Wait for prevous\
    \ register writes to sync\n-    while ((handle->peripheral.leuart->SYNCBUSY &\
    \ LEUART_SYNCBUSY_CMD) != 0U) {\n-    }\n-\n-    // Disable Rx route\n-    #if\
    \ defined(LEUART_ROUTEPEN_RXPEN)\n-    handle->peripheral.leuart->ROUTEPEN &=\
    \ ~LEUART_ROUTEPEN_RXPEN;\n-    #else\n-    handle->peripheral.leuart->ROUTE &=\
    \ ~LEUART_ROUTE_RXPEN;\n-    #endif\n-    // Disable Rx\n-    handle->peripheral.leuart->CMD\
    \ = LEUART_CMD_RXDIS;\n-  }\n-#elif defined(EUART_COUNT) && (EUART_COUNT > 0)\n\
    -  else if (handle->type == uartdrvUartTypeEuart) {\n-    if (EUSART_StatusGet(handle->peripheral.euart)\
    \ &  EUSART_STATUS_TXENS) {\n-      EUSART_Enable(handle->peripheral.euart, eusartEnableTx);\n\
    -    } else {\n-      EUSART_Enable(handle->peripheral.euart, eusartDisable);\n\
    -    }\n-  }\n-#endif\n-}\n-\n-/**************************************************************************//**\n\
    +/******************************************************************************\n\
    \  * Get NVIC IRQ number from UARTDRV handle\n  *\n- * @param[in] handle Connection\
    \ handle\n+ * @param[in] handle UART driver handle\n  * @return Interrupt number\n\
    \  *****************************************************************************/\n\
    \ static IRQn_Type irq_number_from_handle(UARTDRV_Handle_t handle)\n@@ -599,7\
    \ +554,26 @@ static IRQn_Type irq_number_from_handle(UARTDRV_Handle_t handle)\n\
    \   return irq_number;\n }\n \n-/**************************************************************************//**\n\
    +/******************************************************************************\n\
    + * Start / resume UARTDRV receiving\n+ *\n+ * @param[in] handle UART driver handle\n\
    + * @return UARTDRV reported result of the operation\n+ *****************************************************************************/\n\
    +static Ecode_t uart_receive_start(UARTDRV_Handle_t handle)\n+{\n+  Ecode_t ec\
    \ = UARTDRV_Receive(handle, rx_buf, sizeof(rx_buf), receive_cb);\n+\n+  if (ec\
    \ == ECODE_EMDRV_UARTDRV_OK) {\n+    // De-assert nRTS or send XON\n+    if (uartdrv_handle->fcType\
    \ != uartdrvFlowControlHwUart) {\n+      UARTDRV_FlowControlSet(uartdrv_handle,\
    \ uartdrvFlowControlAuto);\n+    }\n+  }\n+\n+  return ec;\n+}\n+/******************************************************************************\n\
    \  * Function to trigger the OS task to proceed\n  *\n  * @note Weak implementation."
  - "--- a/app/bluetooth/common_host/app_sleep/app_sleep.c\n+++ b/app/bluetooth/common_host/app_sleep/app_sleep.c\n\
    @@ -3,7 +3,7 @@\n  * @brief OS dependent sleep functionality.\n  *******************************************************************************\n\
    \  * # License\n- * <b>Copyright 2021 Silicon Laboratories Inc. www.silabs.com</b>\n\
    + * <b>Copyright 2024 Silicon Laboratories Inc. www.silabs.com</b>\n  *******************************************************************************\n\
    \  *\n  * SPDX-License-Identifier: Zlib\n@@ -30,28 +30,50 @@\n \n #include \"\
    app_sleep.h\"\n \n-#if defined(POSIX) && POSIX == 1\n-inline void app_sleep_us(uint64_t\
    \ usec)\n+#if defined(POSIX)\n+#include <unistd.h>\n+#include <sys/select.h>\n\
    +#include <sys/time.h>\n+#include <sys/errno.h>\n+#elif defined(_WIN32)\n+#include\
    \ <windows.h>\n+#endif\n+\n+#if defined(POSIX)\n+// POSIX compliant\n+void app_sleep_us(uint64_t\
    \ usec)\n {\n-  usleep(usec);\n+  struct timeval tv;\n+  int ret = -1;\n+\n+ \
    \ tv.tv_sec = usec / 1000000;\n+  tv.tv_usec = usec % 1000000;\n+\n+  do {\n+\
    \    // using select() instead of usleep(usec) results in better precision and\
    \ slightly lower overall CPU usage as well\n+    ret = select(1, NULL, NULL, NULL,\
    \ &tv);\n+  } while ((ret == -1) && (errno == EINTR)); // select can be interruped\
    \ by SIGALRM\n }\n-#else\n+#elif defined(_WIN32)\n+static NTSTATUS(__stdcall *\
    \ NtDelayExecution)(BOOL Alertable, PLARGE_INTEGER DelayInterval) = NULL;\n+static\
    \ NTSTATUS(__stdcall * ZwSetTimerResolution)(IN ULONG RequestedResolution, IN\
    \ BOOLEAN Set, OUT PULONG ActualResolution) = NULL;\n+\n void app_sleep_us(uint64_t\
    \ usec)\n {\n-  HANDLE timer;\n-  LARGE_INTEGER due_time;\n+  static BOOL lazy_init\
    \ = TRUE; // need to get some function pointers and set timer resolution before\
    \ the first use\n+  LARGE_INTEGER interval;\n \n-  if (usec == 0) {\n-    SwitchToThread();\n\
    -    return;\n+  if (lazy_init) {\n+    ULONG actualResolution;\n+    // import\
    \ two ntdll functions which are needed\n+    ZwSetTimerResolution = (NTSTATUS(__stdcall*)(ULONG,\
    \ BOOLEAN, PULONG))GetProcAddress(GetModuleHandle(\"ntdll.dll\"), \"ZwSetTimerResolution\"\
    );\n+    NtDelayExecution = (NTSTATUS(__stdcall*)(BOOL, PLARGE_INTEGER))GetProcAddress(GetModuleHandle(\"\
    ntdll.dll\"), \"NtDelayExecution\");\n+    // set high resolution\n+    ZwSetTimerResolution(1,\
    \ TRUE, &actualResolution);\n+    lazy_init = FALSE;\n   }\n \n-  // Convert to\
    \ 100 nanosec interval, negative value indicates relative time\n-  due_time.QuadPart\
    \ = -((10 * usec) - 1);\n-\n-  timer = CreateWaitableTimer(NULL, TRUE, NULL);\n\
    -  SetWaitableTimer(timer, &due_time, 0, NULL, NULL, 0);\n-  WaitForSingleObject(timer,\
    \ INFINITE);\n-  CloseHandle(timer);\n+  interval.QuadPart = -1 * (int)(usec *\
    \ 10);\n+  NtDelayExecution(FALSE, &interval);\n }\n #endif"
  - "--- a/app/bluetooth/common_host/esl_key_lib/esl_key_lib.c\n+++ b/app/bluetooth/common_host/esl_key_lib/esl_key_lib.c\n\
    @@ -341,14 +341,16 @@ sl_status_t esl_key_lib_delete_record(const db_handle_p\
    \ db_hnd, const db_record_\n         if (rc == SQLITE_BUSY) {\n           app_log_error(\"\
    Sqlite is busy: %d\" APP_LOG_NL, rc);\n         }\n-      } else {\n-        rc\
    \ = sqlite3_finalize(stmt);\n-        if (rc != SQLITE_OK) {\n-          app_log_error(\"\
    Failed to execute finalize: %s\" APP_LOG_NL, sqlite3_errmsg(*db));\n+      }\n\
    +\n+      rc = sqlite3_finalize(stmt);\n+      if (rc != SQLITE_OK) {\n+     \
    \   app_log_error(\"Failed to execute finalize: %s\" APP_LOG_NL, sqlite3_errmsg(*db));\n\
    +        if (rc != SQLITE_CONSTRAINT) {\n           status = SL_STATUS_ABORT;\n\
    -        } else {\n-          status = SL_STATUS_OK;\n         }\n+      } else\
    \ {\n+        status = SL_STATUS_OK;\n       }\n     }\n \n@@ -431,8 +433,9 @@\
    \ sl_status_t esl_key_lib_get_record_by_ble_address(const db_handle_p db_hnd,\
    \ cons\n       memcpy(&((*record_hnd_out)->identity_key), sqlite3_column_blob(stmt,\
    \ ESL_KEY_LIB_AES_128_KEY_COLUMN_INDEX), sqlite3_column_bytes(stmt, ESL_KEY_LIB_AES_128_KEY_COLUMN_INDEX));\n\
    \       memcpy(&((*record_hnd_out)->ap_key_material), sqlite3_column_blob(stmt,\
    \ ESL_KEY_LIB_EAD_KEY_MATERIAL_COLUMN_INDEX), sqlite3_column_bytes(stmt, ESL_KEY_LIB_EAD_KEY_MATERIAL_COLUMN_INDEX));\n\
    \     } else {\n-      // Reset the statement, searching in the tag table\n- \
    \     sqlite3_reset(stmt);\n+      // Destroy the previous statement, searching\
    \ in the tag table instead\n+      sqlite3_finalize(stmt);\n+      stmt = NULL;\n\
    \       rc = sqlite3_prepare_v2(*db, \"SELECT * FROM tag_table WHERE tag_ble_address\
    \ = ?;\", -1, &stmt, NULL);\n \n       if (rc != SQLITE_OK) {\n@@ -1063,7 +1066,10\
    \ @@ static sl_status_t internal_store_record(const db_handle_p db_hnd,\n    \
    \   }\n     }\n \n-    sqlite3_reset(stmt);\n+    if (stmt != NULL) {\n+     \
    \ (void)sqlite3_finalize(stmt);\n+      stmt = NULL;\n+    }\n \n     if (status\
    \ == SL_STATUS_OK) {\n       // BLE address is not in the other table, we can\
    \ put the new record in\n@@ -1090,10 +1096,12 @@ static sl_status_t internal_store_record(const\
    \ db_handle_p db_hnd,\n       if (rc != SQLITE_DONE) {\n         app_log_error(\"\
    Failed to execute step: %s, %d\" APP_LOG_NL, sqlite3_errmsg(*db), rc);\n     \
    \    status = SL_STATUS_OBJECT_WRITE;\n-      } else {\n-        rc = sqlite3_finalize(stmt);\n\
    -        if (rc != SQLITE_OK) {\n-          app_log_error(\"Failed to execute\
    \ finalize: %s\" APP_LOG_NL, sqlite3_errmsg(*db));\n+      }\n+\n+      rc = sqlite3_finalize(stmt);\n\
    +      if (rc != SQLITE_OK) {\n+        app_log_error(\"Failed to execute finalize:\
    \ %s\" APP_LOG_NL, sqlite3_errmsg(*db));\n+        if (rc != SQLITE_CONSTRAINT)\
    \ {\n           status = SL_STATUS_ABORT;\n         }\n       }"
  - "--- a/app/bluetooth/common_host/esl_lib/esl_lib_connection.c\n+++ b/app/bluetooth/common_host/esl_lib/esl_lib_connection.c\n\
    @@ -55,14 +55,14 @@\n #define GATT_TIMEOUT_MS       10000\n \n // connection parameters\
    \ for PAST\n-#define PAST_CONN_INTERVAL_MIN       0x0006 // given in 1.25ms units,\
    \ 6 * 1.25 = 7.5ms, limited by Core specification\n-#define PAST_CONN_INTERVAL_MAX\
    \       0x0c80 // limited by Core specification to 4 seconds\n+#define PAST_CONN_INTERVAL_MIN\
    \       ESL_LIB_CONN_INTERVAL_MIN\n+#define PAST_CONN_INTERVAL_MAX       ESL_LIB_CONN_INTERVAL_MAX\n\
    \ #define PAST_CONN_PERIPHERAL_LATENCY 1      // allow to skip one connection\
    \ interval during PAST if there's no data\n #define PAST_CONN_DEFAULT_TIMEOUT\
    \    1000   // value * 10ms, this is 10 seconds\n-#define PAST_CONN_MIN_TIMEOUT\
    \        0x000a // min 100ms according to COre specification\n-#define PAST_CONN_MAX_TIMEOUT\
    \        0x0c80 // max 32 seconds according to COre specification\n-#define PAST_CONN_MIN_CE_LENGTH\
    \      0\n-#define PAST_CONN_MAX_CE_LENGTH      0xffff\n+#define PAST_CONN_MIN_TIMEOUT\
    \        ESL_LIB_CONN_MIN_TIMEOUT\n+#define PAST_CONN_MAX_TIMEOUT        ESL_LIB_CONN_MAX_TIMEOUT\n\
    +#define PAST_CONN_MIN_CE_LENGTH      ESL_LIB_CONN_MIN_CE_LENGTH\n+#define PAST_CONN_MAX_CE_LENGTH\
    \      ESL_LIB_CONN_MAX_CE_LENGTH // can be tuned to fits specific radio timing\
    \ needs\n #define PAST_GRACE_INTERVAL_COUNT    6\n \n #define PAWR_SERVICE_DATA\
    \            42\n@@ -86,6 +86,8 @@ typedef struct {\n static void esl_lib_connection_safe_remove_ptr(esl_lib_connection_t\
    \ *ptr);\n static void run_command(esl_lib_command_list_cmd_t *cmd);\n static\
    \ sl_status_t close_connection(esl_lib_connection_t *conn);\n+static sl_status_t\
    \ send_retry_event(esl_lib_connection_t *conn,\n+                            \
    \        sl_status_t          reason);\n static sl_status_t send_connection_status(esl_lib_connection_t\
    \ *conn,\n                                           esl_lib_bool_t       status,\n\
    \                                           sl_status_t          reason);\n@@\
    \ -703,6 +705,8 @@ void esl_lib_connection_on_bt_event(sl_bt_msg_t *evt)\n   \
    \                                         conn->connection_handle);\n        \
    \       conn->command_complete = true;\n             } else {\n+             \
    \ // Let the AP know that the connection is now closed but will retry\n+     \
    \         send_retry_event(conn, reason);\n               break;\n           \
    \  }\n           } else {\n@@ -896,6 +900,9 @@ void esl_lib_connection_on_bt_event(sl_bt_msg_t\
    \ *evt)\n       if (sc == SL_STATUS_OK) {\n         lib_status = ESL_LIB_STATUS_NO_ERROR;\n\
    \       } else {\n+        // Set library status accordingly.\n+        lib_status\
    \ = ESL_LIB_STATUS_BONDING_FAILED;\n+        conn->state = ESL_LIB_CONNECTION_STATE_BONDING_FAIL_RECONNECT;\n\
    \         // Defer forced close on error - normally the close event should come,\
    \ this is just a watchdog\n         (void)app_timer_stop(&conn->timer);\n    \
    \     (void)app_timer_start(&conn->timer,\n@@ -1036,7 +1043,7 @@ void esl_lib_connection_on_bt_event(sl_bt_msg_t\
    \ *evt)\n         // Check size for UUID if in proper state - send error otherwise\n\
    \         if (conn->state != ESL_LIB_CONNECTION_STATE_SERVICE_DISCOVERY) {\n \
    \          sc = SL_STATUS_INVALID_STATE;\n-          lib_status = conn->state;\n\
    +          lib_status = ESL_LIB_STATUS_CONN_DISCOVERY_FAILED;\n           esl_lib_log_connection_error(CONN_FMT\
    \ \"Service discovery failed, connection handle = %u, sc = 0x%04x\" APP_LOG_NL,\n\
    \                                        conn,\n                             \
    \           conn->connection_handle,\n@@ -1735,7 +1742,6 @@ static sl_status_t\
    \ send_cp_notification_event(esl_lib_connection_t *conn,\n                   \
    \                 len,\n                                    &lib_evt);\n   if\
    \ (sc == SL_STATUS_OK) {\n-    lib_evt->evt_code = ESL_LIB_EVT_CONTROL_POINT_NOTIFICATION;\n\
    \     lib_evt->data.evt_control_point_notification.connection_handle\n       =\
    \ (esl_lib_connection_handle_t)conn;\n     lib_evt->data.evt_control_point_notification.data.len\
    \ = len;\n@@ -1761,7 +1767,6 @@ static sl_status_t send_bonding_finished(esl_lib_connection_t\
    \ *conn)\n                                    0,\n                           \
    \         &lib_evt);\n   if (sc == SL_STATUS_OK) {\n-    lib_evt->evt_code = ESL_LIB_EVT_BONDING_FINISHED;\n\
    \     lib_evt->data.evt_bonding_finished.connection_handle\n       = (esl_lib_connection_handle_t)conn;\n\
    \     // Copy address\n@@ -1789,7 +1794,6 @@ static sl_status_t send_bonding_data(esl_lib_connection_t\
    \ *conn,\n                                    0,\n                           \
    \         &lib_evt);\n   if (sc == SL_STATUS_OK) {\n-    lib_evt->evt_code = ESL_LIB_EVT_BONDING_DATA;\n\
    \     lib_evt->data.evt_bonding_data.connection_handle\n       = (esl_lib_connection_handle_t)conn;\n\
    \     // Copy address\n@@ -1810,6 +1814,40 @@ static sl_status_t send_bonding_data(esl_lib_connection_t\
    \ *conn,\n   return sc;\n }\n \n+static sl_status_t send_retry_event(esl_lib_connection_t\
    \ *conn,\n+                                    sl_status_t          reason)\n\
    +{\n+  esl_lib_evt_t *lib_evt;\n+  sl_status_t sc = esl_lib_event_list_allocate(ESL_LIB_EVT_CONNECTION_RETRY,\n\
    +                                               0,\n+                        \
    \                       &lib_evt);\n+  if (sc == SL_STATUS_OK) {\n+    lib_evt->data.evt_connection_retry.connection_handle\
    \ = (esl_lib_connection_handle_t)conn;\n+    // Set last known connection state\
    \ for the event\n+    lib_evt->data.evt_connection_retry.connection_state = conn->state;\n\
    +    // Update the connection state\n+    conn->state = ESL_LIB_CONNECTION_STATE_RECONNECTING;\n\
    +    // Set reason for disconnection event\n+    lib_evt->data.evt_connection_retry.reason\
    \ = reason;\n+    // Copy address and set its type\n+    lib_evt->data.evt_connection_retry.address.address_type\
    \ = conn->address_type;\n+    // Copy remaining retry count, if known\n+    if\
    \ ((conn->command != NULL) && (conn->command->cmd_code == ESL_LIB_CMD_CONNECT))\
    \ {\n+      lib_evt->data.evt_connection_retry.retries_left = conn->command->data.cmd_connect.retries_left;\n\
    +    }\n+    memcpy(lib_evt->data.evt_connection_retry.address.addr,\n+      \
    \     conn->address.addr,\n+           sizeof(conn->address.addr));\n+    sc =\
    \ esl_lib_event_list_push_back(lib_evt);\n+\n+    if (sc != SL_STATUS_OK) {\n\
    +      // Free up memory on failure\n+      esl_lib_memory_free(lib_evt);\n+ \
    \   }\n+  }\n+\n+  return sc;\n+}\n static sl_status_t send_connection_status(esl_lib_connection_t\
    \ *conn,\n                                           esl_lib_bool_t       status,\n\
    \                                           sl_status_t          reason)\n@@ -1827,8\
    \ +1865,6 @@ static sl_status_t send_connection_status(esl_lib_connection_t *conn,\n\
    \                                    0,\n                                    &lib_evt);\n\
    \   if (sc == SL_STATUS_OK) {\n-    // Set event type\n-    lib_evt->evt_code\
    \ = type;\n     // Get pointer to status data in general\n     if (status == ESL_LIB_TRUE)\
    \ {\n       // Set handle\n@@ -1890,7 +1926,6 @@ static sl_status_t send_att_response(esl_lib_connection_t\
    \ *conn,\n   if (type == ESL_LIB_EVT_CONFIGURE_TAG_RESPONSE) {\n     sc = esl_lib_event_list_allocate(type,\
    \ 0, &lib_evt);\n     if (sc == SL_STATUS_OK) {\n-      lib_evt->evt_code = type;\n\
    \       // Tag config response\n       lib_evt->data.evt_configure_tag_response.connection_handle\n\
    \         = (esl_lib_connection_handle_t)conn;\n@@ -1903,7 +1938,6 @@ static sl_status_t\
    \ send_att_response(esl_lib_connection_t *conn,\n                            \
    \          conn->command->data.cmd_write_control_point.data.len,\n           \
    \                           &lib_evt);\n     if (sc == SL_STATUS_OK) {\n-    \
    \  lib_evt->evt_code = type;\n       // Control Point response\n       lib_evt->data.evt_control_point_response.connection_handle\n\
    \         = (esl_lib_connection_handle_t)conn;\n@@ -2085,7 +2119,6 @@ static void\
    \ on_image_transfer_finished(esl_lib_image_transfer_handle_t handle,\n     if\
    \ (result == SL_STATUS_OK) {\n       sc = esl_lib_event_list_allocate(ESL_LIB_EVT_IMAGE_TRANSFER_FINISHED,\
    \ 0, &lib_evt);\n       if (sc == SL_STATUS_OK) {\n-        lib_evt->evt_code\
    \ = ESL_LIB_EVT_IMAGE_TRANSFER_FINISHED;\n         lib_evt->data.evt_image_transfer_finished.connection_handle\
    \ = conn;\n         lib_evt->data.evt_image_type.img_index = image_index;\n  \
    \       lib_evt->data.evt_image_transfer_finished.status = result;\n@@ -2142,7\
    \ +2175,6 @@ static void on_image_transfer_type_arrived(esl_lib_image_transfer_handle_t\
    \ handl\n     if (result == SL_STATUS_OK) {\n       sc = esl_lib_event_list_allocate(ESL_LIB_EVT_IMAGE_TYPE,\
    \ len, &lib_evt);\n       if (sc == SL_STATUS_OK) {\n-        lib_evt->evt_code\
    \ = ESL_LIB_EVT_IMAGE_TYPE;\n         lib_evt->data.evt_image_type.connection_handle\
    \ = conn;\n         lib_evt->data.evt_image_type.img_index = image_index;\n  \
    \       lib_evt->data.evt_image_type.type_data.len = len;"
  - "--- a/app/bluetooth/common_host/esl_lib/esl_lib_core.c\n+++ b/app/bluetooth/common_host/esl_lib/esl_lib_core.c\n\
    @@ -240,6 +240,17 @@ static void esl_lib_core_on_bt_event(sl_bt_msg_t *evt)\n\
    \         lib_critical_error = true;\n       }\n \n+      sc = sl_bt_connection_set_default_parameters(ESL_LIB_CONN_INTERVAL_MIN,\n\
    +                                                   ESL_LIB_CONN_INTERVAL_MIN,\n\
    +                                                   ESL_LIB_CONN_PERIPHERAL_LATENCY,\n\
    +                                                   ESL_LIB_CONN_DEFAULT_TIMEOUT,\n\
    +                                                   ESL_LIB_CONN_MIN_CE_LENGTH,\n\
    +                                                   ESL_LIB_CONN_MAX_CE_LENGTH);\n\
    +      if (sc != SL_STATUS_OK) {\n+        esl_lib_log_core_critical(\"Failed\
    \ to set connection parameters, sc = 0x%04x\" APP_LOG_NL, sc);\n+        lib_critical_error\
    \ = true;\n+      }\n+\n       // Allocate and add event to the event list\n \
    \      sc = esl_lib_event_list_allocate(ESL_LIB_EVT_SYSTEM_BOOT, 0, &new_event);\n\
    \       if (sc == SL_STATUS_OK) {"
  - "--- a/app/bluetooth/common_host/esl_lib/esl_lib_event_list.c\n+++ b/app/bluetooth/common_host/esl_lib/esl_lib_event_list.c\n\
    @@ -126,6 +126,9 @@ sl_status_t esl_lib_event_list_allocate(esl_lib_evt_type_t\
    \ event_type,\n       size += sizeof(esl_lib_evt_control_point_notification_t);\n\
    \       size += additional_size;\n       break;\n+    case ESL_LIB_EVT_CONNECTION_RETRY:\n\
    +      size += sizeof(esl_lib_evt_connection_retry_t);\n+      break;\n     case\
    \ ESL_LIB_EVT_CONNECTION_CLOSED:\n       size += sizeof(esl_lib_evt_connection_closed_t);\n\
    \       break;\n@@ -175,8 +178,9 @@ sl_status_t esl_lib_event_list_allocate(esl_lib_evt_type_t\
    \ event_type,\n   }\n \n   memset(ptr, 0, size);\n-\n   *ptr_out = (esl_lib_evt_t\
    \ *)ptr;\n+  // Set event type\n+  (*ptr_out)->evt_code = event_type;\n \n   return\
    \ sc;\n }"
  - "--- a/app/bluetooth/common_host/host_comm/host_comm_posix.c\n+++ b/app/bluetooth/common_host/host_comm/host_comm_posix.c\n\
    @@ -182,7 +182,7 @@ sl_status_t host_comm_set_option(char option, char *value)\n\
    \       break;\n     // UART flow control disable.\n     case 'f':\n-      uart_flow_control\
    \ = 1;\n+      uart_flow_control = 0;\n       break;\n     // AF socket descriptor\n\
    \     case 'n':"
  - "--- a/app/bluetooth/common_host/host_comm/host_comm_win.c\n+++ b/app/bluetooth/common_host/host_comm/host_comm_win.c\n\
    @@ -151,7 +151,7 @@ sl_status_t host_comm_set_option(char option, char *value)\n\
    \       break;\n     // UART flow control disable.\n     case 'f':\n-      uart_flow_control\
    \ = 1;\n+      uart_flow_control = 0;\n       break;\n     // Unknown option.\n\
    \     default:"
  - "--- a/app/bluetooth/example/bt_soc_app_ota_dfu/app.c\n+++ b/app/bluetooth/example/bt_soc_app_ota_dfu/app.c\n\
    @@ -3,7 +3,7 @@\n  * @brief Core application logic.\n  *******************************************************************************\n\
    \  * # License\n- * <b>Copyright 2022 Silicon Laboratories Inc. www.silabs.com</b>\n\
    + * <b>Copyright 2024 Silicon Laboratories Inc. www.silabs.com</b>\n  *******************************************************************************\n\
    \  *\n  * SPDX-License-Identifier: Zlib\n@@ -367,12 +367,15 @@ static void app_ota_dfu_on_status_change(sl_bt_app_ota_dfu_status_t\
    \ curr_sts,\n       app_log_info(\"Bootloader initialized.\" APP_LOG_NL);\n  \
    \     break;\n \n+    case SL_BT_APP_OTA_DFU_READ_FLASH:\n+      app_log_info(\"\
    Read storage slot...\" APP_LOG_NL);\n+      break;\n+\n     case SL_BT_APP_OTA_DFU_ERASE:\n\
    -      app_log_info(\"Erase storage slot...\" APP_LOG_NL);\n+      app_log_info(\"\
    Erasing...\" APP_LOG_NL);\n       break;\n \n     case SL_BT_APP_OTA_DFU_READY:\n\
    -      app_log_info(\"Erase done.\" APP_LOG_NL);\n       app_log_info(\"Application\
    \ OTA DFU ready.\" APP_LOG_NL);\n       break;\n "
  - "--- a/app/bluetooth/example_host/bt_aoa_host_locator/app.c\n+++ b/app/bluetooth/example_host/bt_aoa_host_locator/app.c\n\
    @@ -181,7 +181,6 @@ void app_init(int argc, char *argv[])\n     app_log_info(\"\
    Selected CTE mode: %s\" APP_LOG_NL, cte_mode_string);\n   }\n   app_log_info(\"\
    Press Crtl+C to quit\" APP_LOG_NL APP_LOG_NL);\n-  ncp_reset();\n }\n \n /**************************************************************************//**"
  - "--- a/app/bluetooth/example_host/bt_host_ncp_test/app.c\n+++ b/app/bluetooth/example_host/bt_host_ncp_test/app.c\n\
    @@ -43,7 +43,7 @@\n #include \"sl_bt_api.h\"\n \n // Optstring argument for getopt.\n\
    -#define OPTSTRING   NCP_HOST_OPTSTRING \"c:w:i:e:h\"\n+#define OPTSTRING   NCP_HOST_OPTSTRING\
    \ APP_LOG_OPTSTRING \"c:w:i:e:h\"\n \n // Usage info.\n #define USAGE       APP_LOG_NL\
    \ \"%s \" NCP_HOST_USAGE APP_LOG_USAGE \" -c <command id> [-w <width>] [-i <interval>]\
    \ [-e <end>] [-h]\" APP_LOG_NL\n@@ -144,6 +144,9 @@ void app_init(int argc, char\
    \ *argv[])\n       // Process options for other modules.\n       default:\n  \
    \       sc = ncp_host_set_option((char)opt, optarg);\n+        if (sc == SL_STATUS_NOT_FOUND)\
    \ {\n+          sc = app_log_set_option((char)opt, optarg);\n+        }\n    \
    \     if (sc != SL_STATUS_OK) {\n           app_log(USAGE, argv[0]);\n       \
    \    exit(EXIT_FAILURE);"
  - '--- a/app/btmesh/common/btmesh_custom_role/sl_btmesh_custom_role.c

    +++ b/app/btmesh/common/btmesh_custom_role/sl_btmesh_custom_role.c

    @@ -0,0 +1,67 @@

    +/***************************************************************************//**

    + * @file

    + * @brief BT Mesh Custom Role Initializer

    + *******************************************************************************

    + * # License

    + * <b>Copyright 2024 Silicon Laboratories Inc. www.silabs.com</b>

    + *******************************************************************************

    + *

    + * SPDX-License-Identifier: Zlib

    + *

    + * The licensor of this software is Silicon Laboratories Inc.

    + *

    + * This software is provided ''as-is'', without any express or implied

    + * warranty. In no event will the authors be held liable for any damages

    + * arising from the use of this software.

    + *

    + * Permission is granted to anyone to use this software for any purpose,

    + * including commercial applications, and to alter it and redistribute it

    + * freely, subject to the following restrictions:

    + *

    + * 1. The origin of this software must not be misrepresented; you must not

    + *    claim that you wrote the original software. If you use this software

    + *    in a product, an acknowledgment in the product documentation would be

    + *    appreciated but is not required.

    + * 2. Altered source versions must be plainly marked as such, and must not be

    + *    misrepresented as being the original software.

    + * 3. This notice may not be removed or altered from any source distribution.

    + *

    + ******************************************************************************/

    +

    +// -----------------------------------------------------------------------------

    +// Includes

    +

    +#include "sl_bt_api.h"

    +#include "sl_btmesh_custom_role.h"

    +#include "sl_common.h"

    +

    +/***************************************************************************//**

    + * @addtogroup btmesh_custom_role

    + * @{

    + ******************************************************************************/

    +

    +// -----------------------------------------------------------------------------

    +// Public function definitions

    +

    +// Handle BLE events for the mesh custom role

    +void sl_bt_custom_role_on_event(sl_bt_msg_t* evt)

    +{

    +  switch (SL_BT_MSG_ID(evt->header)) {

    +    case sl_bt_evt_system_boot_id:

    +      sl_btmesh_custom_role_init();

    +      break;

    +    default:

    +      break;

    +  }

    +}

    +

    +// -----------------------------------------------------------------------------

    +// Event / callback definitions

    +

    +// Called on boot event and the application is able to override this function

    +// to initialize the device as a provisioner or as a provisionee.

    +SL_WEAK void sl_btmesh_custom_role_init(void)

    +{

    +}

    +

    +/** @} (end addtogroup btmesh_custom_role) */'
  - "--- a/app/btmesh/common/btmesh_provisioner/sl_btmesh_provisioner.c\n+++ b/app/btmesh/common/btmesh_provisioner/sl_btmesh_provisioner.c\n\
    @@ -75,4 +75,4 @@ SL_WEAK void sl_btmesh_provisioner_on_init(sl_status_t result)\n\
    \   (void)result;\n }\n \n-/** @} (end addtogroup provisionee) */\n+/** @} (end\
    \ addtogroup provisioner) */"
  - "--- a/app/btmesh/example/btmesh_soc_light_ctl/app_out_lcd.c\n+++ b/app/btmesh/example/btmesh_soc_light_ctl/app_out_lcd.c\n\
    @@ -60,6 +60,11 @@\n \n #include \"sl_btmesh_wstk_lcd.h\"\n \n+// -----------------------------------------------------------------------------\n\
    +// Macros\n+\n+#define LIGHTNESS_LEVEL_TO_PERCENTAGE(lev) ((((lev) * 100) + 32767)\
    \ / 65535)\n+\n // -----------------------------------------------------------------------------\n\
    \ // BT mesh Friend Node Callbacks\n \n@@ -156,7 +161,7 @@ void sl_btmesh_lighting_server_on_ui_update(uint16_t\
    \ lightness_level)\n {\n   // Temporary buffer to format the LCD output text\n\
    \   char tmp_str[LCD_ROW_LEN];\n-  uint16_t lightness_percent = (lightness_level\
    \ * 100 + 99) / 65535;\n+  uint16_t lightness_percent = LIGHTNESS_LEVEL_TO_PERCENTAGE(lightness_level);\n\
    \ \n   app_log(\"BT mesh Lightness: %5u%%\" APP_LOG_NL, lightness_percent);\n\
    \   snprintf(tmp_str, LCD_ROW_LEN, \"Lightness: %5u%%\", lightness_percent);"
  - "--- a/app/btmesh/example/btmesh_soc_light_ctl/app_out_log.c\n+++ b/app/btmesh/example/btmesh_soc_light_ctl/app_out_log.c\n\
    @@ -57,7 +57,10 @@\n #include \"sl_btmesh_factory_reset.h\"\n #endif // SL_CATALOG_BTMESH_FACTORY_RESET_PRESENT\n\
    \ \n-#define LIGHTNESS_LEVEL_TO_PERCENTAGE(lev) ((((lev) * 100) + 99) / 65535)\n\
    +// -----------------------------------------------------------------------------\n\
    +// Macros\n+\n+#define LIGHTNESS_LEVEL_TO_PERCENTAGE(lev) ((((lev) * 100) + 32767)\
    \ / 65535)\n \n // -----------------------------------------------------------------------------\n\
    \ // BT mesh Friend Node Callbacks"
  - "--- a/app/btmesh/example/btmesh_soc_nlc_basic_lightness_controller/app_out_lcd.c\n\
    +++ b/app/btmesh/example/btmesh_soc_nlc_basic_lightness_controller/app_out_lcd.c\n\
    @@ -64,6 +64,11 @@\n #define lcd_print(...) SL_STATUS_OK\n #endif // SL_CATALOG_BTMESH_WSTK_LCD_PRESENT\n\
    \ \n+// -----------------------------------------------------------------------------\n\
    +// Macros\n+\n+#define LIGHTNESS_LEVEL_TO_PERCENTAGE(lev) ((((lev) * 100) + 32767)\
    \ / 65535)\n+\n // -----------------------------------------------------------------------------\n\
    \ // Event / callback definitions\n \n@@ -111,7 +116,7 @@ void sl_btmesh_friend_on_friendship_terminated(uint16_t\
    \ netkey_index,\n  ******************************************************************************/\n\
    \ void sl_btmesh_lighting_server_on_ui_update(uint16_t lightness_level)\n {\n\
    -  uint16_t lightness_percent = (lightness_level * 100 + 99) / 65535;\n+  uint16_t\
    \ lightness_percent = LIGHTNESS_LEVEL_TO_PERCENTAGE(lightness_level);\n   app_log(\"\
    BT mesh Lightness: %5u%%\" APP_LOG_NL, lightness_percent);\n   #ifdef SL_CATALOG_BTMESH_WSTK_LCD_PRESENT\n\
    \   // Temporary buffer to format the LCD output text"
  - "--- a/app/btmesh/example/btmesh_soc_nlc_basic_lightness_controller/app_out_log.c\n\
    +++ b/app/btmesh/example/btmesh_soc_nlc_basic_lightness_controller/app_out_log.c\n\
    @@ -58,7 +58,7 @@\n // -----------------------------------------------------------------------------\n\
    \ // Macros\n \n-#define LIGHTNESS_LEVEL_TO_PERCENTAGE(lev) ((((lev) * 100) +\
    \ 99) / 65535)\n+#define LIGHTNESS_LEVEL_TO_PERCENTAGE(lev) ((((lev) * 100) +\
    \ 32767) / 65535)\n \n // -----------------------------------------------------------------------------\n\
    \ // Event / callback definitions"
  - "--- a/app/common/example/se_manager_host_firmware_upgrade/app_host_firmware_image.c\n\
    +++ b/app/common/example/se_manager_host_firmware_upgrade/app_host_firmware_image.c\n\
    @@ -36,7 +36,7 @@\n //                                Static Variables\n // -----------------------------------------------------------------------------\n\
    \ /// Host firmware image\n-SL_ALIGN(4) static const uint8_t host_firmware_image[]\
    \ SL_ATTRIBUTE_ALIGN(4) =\n+SL_ALIGN(4) static const uint8_t host_firmware_image[]\
    \ SL_ATTRIBUTE_ALIGN(4) SL_ATTRIBUTE_SECTION(\"FW\") =\n {\n #if (_SILICON_LABS_32B_SERIES_2_CONFIG\
    \ == 1)  // EFR32xG21 host firmware\n   0x00, 0x10, 0x00, 0x20, 0xE1, 0x04, 0x00,\
    \ 0x00, 0xDD, 0x04, 0x00, 0x00, 0xDD, 0x04, 0x00, 0x00, 0xDD, 0x04, 0x00, 0x00,\
    \ 0xDD, 0x04, 0x00, 0x00, 0xDD, 0x04, 0x00, 0x00, 0xDD, 0x04, 0x00, 0x00, 0xDD,\
    \ 0x04, 0x00, 0x00, 0xDD, 0x04, 0x00, 0x00,"
  - "--- a/app/common/example/wifi_commissioning_micriumos/app_wifi_events.c\n+++\
    \ b/app/common/example/wifi_commissioning_micriumos/app_wifi_events.c\n@@ -455,7\
    \ +455,7 @@ static void wfx_events_task(void *p_arg)\n             // Enable the\
    \ WFX power save mode\n             // Note: this mode is independent from the\
    \ host power saving\n             //       but has been linked to simplicfy the\
    \ example.\n-            sl_wfx_set_power_mode(WFM_PM_MODE_PS, WFM_PM_POLL_FAST_PS,\
    \ 1);\n+            sl_wfx_set_power_mode(WFM_PM_MODE_PS, WFM_PM_POLL_FAST_PS,\
    \ 1, 0);\n             sl_wfx_enable_device_power_save();\n           }\n #endif\n\
    @@ -472,7 +472,7 @@ static void wfx_events_task(void *p_arg)\n \n #ifdef SL_CATALOG_POWER_MANAGER_PRESENT\n\
    \           // Power save always disabled when SoftAP mode enabled\n-        \
    \  sl_wfx_set_power_mode(WFM_PM_MODE_ACTIVE, WFM_PM_POLL_FAST_PS, 0);\n+     \
    \     sl_wfx_set_power_mode(WFM_PM_MODE_ACTIVE, WFM_PM_POLL_FAST_PS, 0, 0);\n\
    \           sl_wfx_disable_device_power_save();\n #endif\n           break;\n\
    @@ -486,7 +486,7 @@ static void wfx_events_task(void *p_arg)\n             //\
    \ Enable the WFX power save mode\n             // Note: this mode is independent\
    \ from the host power saving\n             //       but has been linked to simplicfy\
    \ the example.\n-            sl_wfx_set_power_mode(WFM_PM_MODE_PS, WFM_PM_POLL_FAST_PS,\
    \ 1);\n+            sl_wfx_set_power_mode(WFM_PM_MODE_PS, WFM_PM_POLL_FAST_PS,\
    \ 1, 0);\n             sl_wfx_enable_device_power_save();\n           }\n #endif"
  - "--- a/app/common/util/app_timer/app_timer.c\n+++ b/app/common/util/app_timer/app_timer.c\n\
    @@ -55,7 +55,7 @@ static app_timer_t *app_timer_head = NULL;\n // -----------------------------------------------------------------------------\n\
    \ // Private function declarations\n \n-/***************************************************************************//**\n\
    +/*******************************************************************************\n\
    \  * Common callback for the sleeptimers.\n  *\n  * @param[in] handle Pointer\
    \ to the sleeptimer handle.\n@@ -66,7 +66,7 @@ static app_timer_t *app_timer_head\
    \ = NULL;\n static void app_timer_callback(sl_sleeptimer_timer_handle_t *handle,\n\
    \                                void *data);\n \n-/***************************************************************************//**\n\
    +/*******************************************************************************\n\
    \  * Append a timer to the end of the linked list.\n  *\n  * @param[in] timer\
    \ Pointer to the timer handle.\n@@ -75,7 +75,7 @@ static void app_timer_callback(sl_sleeptimer_timer_handle_t\
    \ *handle,\n  ******************************************************************************/\n\
    \ static void append_app_timer(app_timer_t *timer);\n \n-/***************************************************************************//**\n\
    +/*******************************************************************************\n\
    \  * Remove a timer from the linked list.\n  *\n  * @param[in] timer Pointer to\
    \ the timer handle.\n@@ -86,6 +86,16 @@ static void append_app_timer(app_timer_t\
    \ *timer);\n  ******************************************************************************/\n\
    \ static bool remove_app_timer(app_timer_t *timer);\n \n+/*******************************************************************************\n\
    + * Find and return the first triggered timer from the linked list.\n+ *\n+ *\
    \ @return The first triggered timer from the linked list.\n+ *\n+ * @note The\
    \ trigger state is also reset, and it is removed from the list if\n+ * the timer\
    \ is non-periodic.\n+ ******************************************************************************/\n\
    +static app_timer_t *get_triggered_app_timer(void);\n+\n // -----------------------------------------------------------------------------\n\
    \ // Public function definitions\n \n@@ -190,21 +200,14 @@ sl_status_t app_timer_stop(app_timer_t\
    \ *timer)\n void sli_app_timer_step(void)\n {\n   if (trigger_count > 0) {\n-\
    \    app_timer_t *timer = app_timer_head;\n     // Find triggered timers in list\
    \ and call their callbacks.\n-    while (timer != NULL) {\n-      if (timer->triggered)\
    \ {\n-        CORE_ATOMIC_SECTION(\n-          timer->triggered = false;\n-  \
    \        --trigger_count;\n-          )\n-        if (!timer->periodic) {\n- \
    \         (void)remove_app_timer(timer);\n-        }\n+    app_timer_t *timer;\n\
    +    do {\n+      timer = get_triggered_app_timer();\n+      if (timer != NULL)\
    \ {\n         timer->callback(timer, timer->callback_data);\n       }\n-     \
    \ timer = timer->next;\n-    }\n+    } while (timer != NULL);\n   }\n }\n \n@@\
    \ -277,6 +280,9 @@ static void app_timer_callback(sl_sleeptimer_timer_handle_t\
    \ *handle,\n \n static void append_app_timer(app_timer_t *timer)\n {\n+  CORE_DECLARE_IRQ_STATE;\n\
    +  CORE_ENTER_ATOMIC();\n+\n   if (app_timer_head != NULL) {\n     app_timer_t\
    \ *current = app_timer_head;\n     // Find end of list.\n@@ -288,10 +294,15 @@\
    \ static void append_app_timer(app_timer_t *timer)\n     app_timer_head = timer;\n\
    \   }\n   timer->next = NULL;\n+\n+  CORE_EXIT_ATOMIC();\n }\n \n static bool\
    \ remove_app_timer(app_timer_t *timer)\n {\n+  CORE_DECLARE_IRQ_STATE;\n+  CORE_ENTER_ATOMIC();\n\
    +\n   app_timer_t *prev = NULL;\n   app_timer_t *current = app_timer_head;\n \n\
    @@ -303,6 +314,7 @@ static bool remove_app_timer(app_timer_t *timer)\n \n   if\
    \ (current != timer) {\n     // Not found.\n+    CORE_EXIT_ATOMIC();\n     return\
    \ false;\n   }\n \n@@ -311,5 +323,32 @@ static bool remove_app_timer(app_timer_t\
    \ *timer)\n   } else {\n     app_timer_head = timer->next;\n   }\n+  CORE_EXIT_ATOMIC();\n\
    \   return true;\n }\n+\n+static app_timer_t *get_triggered_app_timer(void)\n\
    +{\n+  CORE_DECLARE_IRQ_STATE;\n+  CORE_ENTER_ATOMIC();\n+\n+  // Find the first\
    \ triggered timer in list\n+  app_timer_t *timer = app_timer_head;\n+  while (timer\
    \ != NULL) {\n+    if (timer->triggered) {\n+      // Timer found\n+      timer->triggered\
    \ = false;\n+      --trigger_count;\n+      if (!timer->periodic) {\n+       \
    \ (void)remove_app_timer(timer);\n+      }\n+\n+      CORE_EXIT_ATOMIC();\n+ \
    \     return timer;\n+    }\n+    timer = timer->next;\n+  }\n+\n+  CORE_EXIT_ATOMIC();\n\
    +  return NULL;\n+}"
  - "--- a/app/flex/component/connect/sl_connect_ecdh_key_exchange/sl_connect_ecdh_key_exchange.c\n\
    +++ b/app/flex/component/connect/sl_connect_ecdh_key_exchange/sl_connect_ecdh_key_exchange.c\n\
    @@ -202,8 +202,9 @@ psa_status_t sl_connect_ecdh_key_exchange_encrypt_message(\n\
    \     cipher_text_length);\n \n   if (psa_status == PSA_SUCCESS) {\n-    memcpy(cipher_text,\
    \ data, *cipher_text_length - iv_size);\n-    memcpy(iv, data + *cipher_text_length\
    \ - iv_size, iv_size);\n+    memcpy(iv, data, iv_size);\n+    memcpy(cipher_text,\
    \ data + iv_size, *cipher_text_length - iv_size);\n+\n     *cipher_text_length\
    \ -= iv_size;\n     *iv_length = iv_size;\n   }\n@@ -279,8 +280,8 @@ psa_status_t\
    \ sl_connect_ecdh_key_exchange_decrypt_message(\n #if SL_GSDK_VERSION >= 0x400\n\
    \ \n   // single part operation is only supported in GSDK 4.0+\n-  memcpy(data,\
    \ cipher_text, cipher_text_length);\n-  memcpy(data + cipher_text_length, iv,\
    \ iv_length);\n+  memcpy(data, iv, iv_length);\n+  memcpy(data + iv_length, cipher_text,\
    \ cipher_text_length);\n \n   psa_status = psa_cipher_decrypt(\n     key_id,"
  - "--- a/app/wisun/component/app_cli/sl_wisun_app_cli.c\n+++ b/app/wisun/component/app_cli/sl_wisun_app_cli.c\n\
    @@ -44,7 +44,7 @@\n #include \"sl_wisun_cli_core.h\"\n #if defined(SL_CATALOG_WISUN_APP_CORE_PRESENT)\n\
    \   #include \"sl_wisun_app_core_util.h\"\n-  #include \"sl_wisun_app_core_util_config.h\"\
    \n+  #include \"sl_wisun_app_core_config.h\"\n #endif\n \n // -----------------------------------------------------------------------------\n\
    @@ -435,7 +435,7 @@ static void _app_connect(const sl_wisun_phy_config_type_t\
    \ config_type);\n \n #if defined(SL_CATALOG_WISUN_APP_CORE_PRESENT)\n /// Wi-SUN\
    \ application regulation\n-static sl_wisun_regulation_t app_regulation = (sl_wisun_regulation_t)WISUN_APP_REGULATION;\n\
    +static sl_wisun_regulation_t app_regulation = (sl_wisun_regulation_t)SL_WISUN_APP_CORE_REGULATION;\n\
    \ #endif\n \n /// Common PHY parameters for CLI setter/getter\n@@ -851,7 +851,7\
    \ @@ const app_cli_entry_t app_settings_entries[] =\n #if defined(SL_CATALOG_APP_PROJECT_INFO_PRESENT)\n\
    \ void app_about(void)\n {\n-  app_wisun_project_info_print(false);\n+  sl_wisun_app_core_util_project_info_print(false);\n\
    \ }\n #endif\n \n@@ -877,7 +877,7 @@ static void _app_connect(const sl_wisun_phy_config_type_t\
    \ config_type)\n     return;\n   }\n   // call connect API\n-  app_wisun_network_connect();\n\
    +  sl_wisun_app_core_network_connect();\n }\n \n /* CLI app connect to FAN 1.0\
    \ handler */\n@@ -1163,10 +1163,9 @@ static sl_status_t _app_cli_get_network_size(char\
    \ *value_str,\n                                              const app_cli_entry_t\
    \ *entry)\n {\n   sl_status_t res = SL_STATUS_FAIL;\n-  (void)key_str;\n-  (void)entry;\n\
    \   const app_enum_t* value_enum;\n   uint8_t value = 0U;\n+  (void)key_str;\n\
    \ \n   res = app_wisun_setting_get_network_size(&value);\n   // finds the proper\
    \ string for the value\n@@ -1430,12 +1429,12 @@ static sl_status_t _app_set_regulation(const\
    \ char *value_str,\n                                        const char *key_str,\n\
    \                                        const app_settings_entry_t *entry)\n\
    \ {\n-  (void)key_str;\n-  (void)entry;\n   sl_status_t res = SL_STATUS_FAIL;\n\
    \   uint32_t value = 0U;\n-  regulation_thresholds_t thresholds;\n+  sl_wisun_app_core_reg_thresholds_t\
    \ thresholds = { 0U };\n   sl_wisun_join_state_t join_state = SL_WISUN_JOIN_STATE_DISCONNECTED;\n\
    +  (void)key_str;\n+  (void)entry;\n \n   if ((value_str == NULL) || (entry ==\
    \ NULL) || (entry->key == NULL)) {\n     return SL_STATUS_FAIL;\n@@ -1464,7 +1463,7\
    \ @@ static sl_status_t _app_set_regulation(const char *value_str,\n \n   if (strstr(entry->key,\
    \ \"regulation\")) {\n     // sets the thresholds\n-    (void)app_wisun_get_regulation_thresholds(&thresholds);\n\
    +    (void)sl_wisun_app_core_get_regulation_thresholds(&thresholds);\n     res\
    \ = sl_wisun_set_regulation_tx_thresholds(thresholds.warning_threshold,\n    \
    \                                             thresholds.alert_threshold);\n \
    \    if (res != SL_STATUS_OK) {\n@@ -1482,10 +1481,10 @@ static sl_status_t _app_set_regulation(const\
    \ char *value_str,\n     }\n \n     // sets status of regulation\n-    if ((sl_wisun_regulation_t)value\
    \ == SL_WISUN_REGULATION_NONE) {\n-      app_wisun_set_regulation_active(false);\n\
    +    if ((sl_wisun_regulation_t)value == SL_WISUN_APP_CORE_REGULATION_NONE) {\n\
    +      sl_wisun_app_core_set_regulation_active(false);\n     } else {\n-     \
    \ app_wisun_set_regulation_active(true);\n+      sl_wisun_app_core_set_regulation_active(true);\n\
    \     }\n   }\n \n@@ -1496,12 +1495,11 @@ static sl_status_t _app_set_regulation_warning_threshold(const\
    \ char *value_str,\n                                                         \
    \ const char *key_str,\n                                                     \
    \     const app_settings_entry_t *entry)\n {\n-  (void)key_str;\n-  (void)entry;\n\
    \   sl_status_t res = SL_STATUS_FAIL;\n   uint32_t value = 0U;\n-  regulation_thresholds_t\
    \ thresholds;\n+  sl_wisun_app_core_reg_thresholds_t thresholds = { 0U };\n  \
    \ sl_wisun_join_state_t join_state = SL_WISUN_JOIN_STATE_DISCONNECTED;\n+  (void)key_str;\n\
    \ \n   if ((value_str == NULL) || (entry == NULL) || (entry->key == NULL)) {\n\
    \     return SL_STATUS_FAIL;\n@@ -1529,13 +1527,13 @@ static sl_status_t _app_set_regulation_warning_threshold(const\
    \ char *value_str,\n   }\n \n   if (strstr(entry->key, \"regulation_warning_threshold\"\
    )) {\n-    (void)app_wisun_get_regulation_thresholds(&thresholds);\n+    (void)sl_wisun_app_core_get_regulation_thresholds(&thresholds);\n\
    \     res = sl_wisun_set_regulation_tx_thresholds((int8_t)value, thresholds.alert_threshold);\n\
    \     if (res != SL_STATUS_OK) {\n       printf(\"[Failed: unable to set regulation\
    \ TX warning threshold: %lu]\\n\", res);\n       return res;\n     } else {\n\
    -      app_wisun_set_regulation_thresholds((int8_t)value, thresholds.alert_threshold);\n\
    +      sl_wisun_app_core_set_regulation_thresholds((int8_t)value, thresholds.alert_threshold);\n\
    \     }\n   }\n \n@@ -1546,12 +1544,12 @@ static sl_status_t _app_set_regulation_alert_threshold(const\
    \ char *value_str,\n                                                        const\
    \ char *key_str,\n                                                        const\
    \ app_settings_entry_t *entry)\n {\n-  (void)key_str;\n-  (void)entry;\n   sl_status_t\
    \ res = SL_STATUS_FAIL;\n   uint32_t value = 0U;\n-  regulation_thresholds_t thresholds;\n\
    +  sl_wisun_app_core_reg_thresholds_t thresholds = { 0U };\n   sl_wisun_join_state_t\
    \ join_state = SL_WISUN_JOIN_STATE_DISCONNECTED;\n+  (void)key_str;\n+  (void)entry;\n\
    \ \n   if ((value_str == NULL) || (entry == NULL) || (entry->key == NULL)) {\n\
    \     return SL_STATUS_FAIL;\n@@ -1579,13 +1577,13 @@ static sl_status_t _app_set_regulation_alert_threshold(const\
    \ char *value_str,\n   }\n \n   if (strstr(entry->key, \"regulation_alert_threshold\"\
    )) {\n-    (void)app_wisun_get_regulation_thresholds(&thresholds);\n+    (void)sl_wisun_app_core_get_regulation_thresholds(&thresholds);\n\
    \     res = sl_wisun_set_regulation_tx_thresholds(thresholds.warning_threshold,\
    \ (int8_t)value);\n     if (res != SL_STATUS_OK) {\n       printf(\"[Failed: unable\
    \ to set regulation TX alert threshold: %lu]\\n\", res);\n       return res;\n\
    \     } else {\n-      app_wisun_set_regulation_thresholds(thresholds.warning_threshold,\
    \ (int8_t)value);\n+      sl_wisun_app_core_set_regulation_thresholds(thresholds.warning_threshold,\
    \ (int8_t)value);\n     }\n   }\n \n@@ -1596,12 +1594,11 @@ static sl_status_t\
    \ _app_get_regulation(char *value_str,\n                                     \
    \   const char *key_str,\n                                        const app_cli_entry_t\
    \ *entry)\n {\n-  sl_status_t res = SL_STATUS_FAIL;\n-  const app_enum_t* value_enum;\n\
    +  const app_enum_t *value_enum = NULL;\n   (void)key_str;\n \n   if ((value_str\
    \ == NULL) || (entry == NULL) || (entry->key == NULL)) {\n-    return res;\n+\
    \    return SL_STATUS_FAIL;\n   }\n \n   if (!strstr(entry->key, \"regulation\"\
    )) {\n@@ -1632,16 +1629,15 @@ static sl_status_t _app_get_regulation_warning_threshold(char\
    \ *value_str,\n                                                          const\
    \ char *key_str,\n                                                          const\
    \ app_cli_entry_t *entry)\n {\n-  sl_status_t res = SL_STATUS_FAIL;\n+  sl_wisun_app_core_reg_thresholds_t\
    \ thresholds = { 0U };\n   (void)key_str;\n-  regulation_thresholds_t thresholds;\n\
    \ \n   if ((value_str == NULL) || (entry == NULL) || (entry->key == NULL)) {\n\
    -    return res;\n+    return SL_STATUS_FAIL;\n   }\n \n   if (strstr(entry->key,\
    \ \"regulation_warning_threshold\")) {\n-    (void)app_wisun_get_regulation_thresholds(&thresholds);\n\
    +    (void)sl_wisun_app_core_get_regulation_thresholds(&thresholds);\n     snprintf(value_str,\
    \ APP_CLI_STR_VALUE_LENGTH, \"%d\",\n              thresholds.warning_threshold);\n\
    \   }\n@@ -1653,16 +1649,15 @@ static sl_status_t _app_get_regulation_alert_threshold(char\
    \ *value_str,\n                                                        const char\
    \ *key_str,\n                                                        const app_cli_entry_t\
    \ *entry)\n {\n-  sl_status_t res = SL_STATUS_FAIL;\n+  sl_wisun_app_core_reg_thresholds_t\
    \ thresholds = { 0U };\n   (void)key_str;\n-  regulation_thresholds_t thresholds;\n\
    \ \n   if ((value_str == NULL) || (entry == NULL) || (entry->key == NULL)) {\n\
    -    return res;\n+    return SL_STATUS_FAIL;\n   }\n \n   if (strstr(entry->key,\
    \ \"regulation_alert_threshold\")) {\n-    (void)app_wisun_get_regulation_thresholds(&thresholds);\n\
    +    (void)sl_wisun_app_core_get_regulation_thresholds(&thresholds);\n     snprintf(value_str,\
    \ APP_CLI_STR_VALUE_LENGTH, \"%d\",\n              thresholds.alert_threshold);\n\
    \   }\n@@ -1678,13 +1673,14 @@ static sl_status_t _app_get_device_type(char *value_str,\n\
    \ {\n   const char *dev_type_str = NULL;\n   sl_wisun_device_type_t dev_type =\
    \ SL_WISUN_ROUTER;\n+  (void) entry;\n   (void) key_str;\n \n-  if (value_str\
    \ == NULL || entry == NULL || entry->key == NULL) {\n+  if (value_str == NULL)\
    \ {\n     return SL_STATUS_FAIL;\n   }\n \n-  dev_type =  app_wisun_get_device_type();\n\
    +  dev_type =  sl_wisun_app_core_get_device_type();\n   dev_type_str = app_wisun_trace_util_device_type_to_str((uint32_t)\
    \ dev_type);\n \n   if (dev_type_str == NULL) {\n@@ -1701,14 +1697,14 @@ static\
    \ sl_status_t _app_get_lfn_profile(char *value_str,\n {\n   const char *lfn_profile_str\
    \ = NULL;\n   sl_wisun_lfn_profile_t lfn_profile = SL_WISUN_LFN_PROFILE_TEST;\n\
    -\n+  (void) entry;\n   (void) key_str;\n \n-  if (value_str == NULL || entry\
    \ == NULL || entry->key == NULL) {\n+  if (value_str == NULL) {\n     return SL_STATUS_FAIL;\n\
    \   }\n \n-  lfn_profile =  app_wisun_get_lfn_profile();\n+  lfn_profile =  sl_wisun_app_core_get_lfn_profile();\n\
    \   lfn_profile_str = app_wisun_trace_util_lfn_profile_to_str((uint32_t) lfn_profile);\n\
    \ \n   if (lfn_profile_str == NULL) {"
  - "--- a/app/wisun/component/app_core/sl_wisun_app_core.c\n+++ b/app/wisun/component/app_core/sl_wisun_app_core.c\n\
    @@ -36,7 +36,7 @@\n #include <string.h>\n #include \"sl_status.h\"\n #include\
    \ \"sl_wisun_app_core.h\"\n-#include \"sl_wisun_app_core_util_config.h\"\n+#include\
    \ \"sl_wisun_app_core_config.h\"\n #include \"cmsis_os2.h\"\n #include \"sl_cmsis_os2_common.h\"\
    \n #include \"sl_status.h\"\n@@ -51,13 +51,20 @@\n   #include \"sl_wisun_app_setting.h\"\
    \n #endif\n \n+#if defined(SL_CATALOG_POWER_MANAGER_PRESENT)\n+  #warning Power\
    \ Manager component is presented. Features/peripherals are constrained.\n+#endif\n\
    +\n // -----------------------------------------------------------------------------\n\
    \ //                              Macros and Typedefs\n // -----------------------------------------------------------------------------\n\
    \ \n /// MDR capability\n #define APP_WISUN_MDR_COMMAND_CAPABILITY           \
    \       0U\n \n+/// Eventflag error mask\n+#define APP_WISUN_EVTFLAG_ERROR_MSK\
    \                       (0x00000001UL << 31UL)\n+\n ///  Release mutex and return\n\
    \ #define _return_and_mtx_release() \\\n   do {                            \\\n\
    @@ -103,7 +110,7 @@ static sl_status_t _app_wisun_application_setting(const app_setting_wisun_t\
    \ * co\n  *****************************************************************************/\n\
    \ sl_status_t _app_wisun_security_setting(void);\n \n-#if (WISUN_APP_REGULATION\
    \ != REGULATION_NONE)\n+#if (SL_WISUN_APP_CORE_REGULATION != SL_WISUN_APP_CORE_REGULATION_NONE)\n\
    \ /**************************************************************************//**\n\
    \  * @brief Regulation setting\n  * @details It setup Wi-SUN with regulation related\
    \ parameters.\n@@ -136,11 +143,18 @@ static void _store_address(const char *addr_name,\n\
    \                            in6_addr_t *addr);\n \n /**************************************************************************//**\n\
    - * @brief Setting error flag\n- * @details It sets the error by a flag\n+ * @brief\
    \ Setting state flag\n+ * @details It sets the state by a flag\n+ * @param[in]\
    \ flag is a flag bit\n+ *****************************************************************************/\n\
    +__STATIC_INLINE void _app_wisun_core_set_state(const sl_wisun_app_core_state_t\
    \ flag);\n+\n+/**************************************************************************//**\n\
    + * @brief Clear state flag\n+ * @details It clears the state by a flag\n  * @param[in]\
    \ flag is a flag bit\n  *****************************************************************************/\n\
    -__STATIC_INLINE void _app_wisun_core_set_error(app_core_error_state_flag_t flag);\n\
    +__STATIC_INLINE void _app_wisun_core_clear_state(const sl_wisun_app_core_state_t\
    \ flag);\n \n /**************************************************************************//**\n\
    \  * @brief Storing the current address\n@@ -213,27 +227,35 @@ static const app_setting_wisun_t\
    \ _app_default_settings = {\n /// Here we track if regional regulation is active\
    \ or not\n static bool _regional_regulation_active = false;\n \n-static regulation_thresholds_t\
    \ _tresholds = {\n-  .warning_threshold = WISUN_DEFAULT_REGULATION_WARNING_THRESHOLD,\n\
    -  .alert_threshold = WISUN_DEFAULT_REGULATION_ALERT_THRESHOLD,\n+static sl_wisun_app_core_reg_thresholds_t\
    \ _tresholds = {\n+  .warning_threshold = SL_WISUN_APP_CORE_DEFAULT_REGULATION_WARNING_THRESHOLD,\n\
    +  .alert_threshold = SL_WISUN_APP_CORE_DEFAULT_REGULATION_ALERT_THRESHOLD,\n\
    \ };\n \n /// App framework mutex\n-static osMutexId_t _app_wisun_network_mtx\
    \ = NULL;\n+static osMutexId_t _app_core_mtx = NULL;\n \n ///  App framework mutex\
    \ attribute\n-static const osMutexAttr_t _app_wisun_network_mtx_attr = {\n-  .name\
    \      = \"AppWisunNetworkMutex\",\n+static const osMutexAttr_t _app_wisun_mtx_attr\
    \ = {\n+  .name      = \"AppWisunkMutex\",\n   .attr_bits = osMutexRecursive,\n\
    \   .cb_mem    = NULL,\n   .cb_size   = 0\n };\n \n /// Current address storage\n\
    -static current_addr_t _current_addr = { 0U };\n+static sl_wisun_app_core_current_addr_t\
    \ _current_addr = { 0U };\n \n /// error flag for errors\n-static app_core_error_state_flag_t\
    \ _error_flag = CONNECTION_FAILED_ERROR_FLAG_BIT;\n+static osEventFlagsId_t _app_core_state\
    \ = NULL;\n+\n+/// Sate event flags attributes\n+static const osEventFlagsAttr_t\
    \ _app_wisun_evt_attr = {\n+  .name      = \"AppWisunEvtFlags\",\n+  .attr_bits\
    \ = 0,\n+  .cb_mem    = NULL,\n+  .cb_size   = 0\n+};\n \n /// Internal join state\n\
    \ static sl_wisun_join_state_t _join_state = SL_WISUN_JOIN_STATE_DISCONNECTED;\n\
    @@ -242,7 +264,7 @@ static sl_wisun_join_state_t _join_state = SL_WISUN_JOIN_STATE_DISCONNECTED;\n\
    \ static app_setting_wisun_t _setting = { 0U };\n \n /// Time statistic storage\n\
    -static app_core_time_stat_t _time_stat = { 0U };\n+static sl_wisun_app_core_time_stat_t\
    \ _time_stat = { 0U };\n \n // -----------------------------------------------------------------------------\n\
    \ //                          Public Function Definitions\n@@ -294,6 +316,8 @@\
    \ void sl_wisun_connected_event_hnd(sl_wisun_evt_t *evt)\n \n   if (evt->evt.connected.status\
    \ != SL_STATUS_OK) {\n     printf(\"[Connection failed. Status: %lu]\\n\", evt->evt.connected.status);\n\
    +    _app_wisun_core_set_state(SL_WISUN_APP_CORE_STATE_NETWORK_DISCONNECTED);\n\
    +    _app_wisun_core_clear_state(SL_WISUN_APP_CORE_STATE_NETWORK_CONNECTED);\n\
    \     return;\n   }\n   // store the current addresses\n@@ -309,7 +333,8 @@ void\
    \ sl_wisun_connected_event_hnd(sl_wisun_evt_t *evt)\n   time_ms = time_ms - _time_stat.disconnected_ms;\n\
    \ \n   printf(\"[%lu s]\\n\", (uint32_t)time_ms / 1000U);\n-\n+  _app_wisun_core_set_state(SL_WISUN_APP_CORE_STATE_NETWORK_CONNECTED);\n\
    +  _app_wisun_core_clear_state(SL_WISUN_APP_CORE_STATE_NETWORK_DISCONNECTED);\n\
    \   __CHECK_FOR_STATUS(evt->evt.error.status);\n }\n \n@@ -327,6 +352,7 @@ void\
    \ sl_wisun_disconnected_event_hnd(sl_wisun_evt_t *evt)\n   _time_stat.disconnected_ms\
    \ = time_ms;\n \n   __CHECK_FOR_STATUS(evt->evt.error.status);\n+  _app_wisun_core_set_state(SL_WISUN_APP_CORE_STATE_NETWORK_DISCONNECTED);\n\
    \ }\n \n /* Socket connection lost event handler*/\n@@ -340,6 +366,9 @@ void sl_wisun_connection_lost_event_hnd(sl_wisun_evt_t\
    \ *evt)\n   if (stat == SL_STATUS_OK) {\n     printf(\"[Connection lost, connecting\
    \ to \\\"%s\\\"]\\n\", _setting.network_name);\n   }\n+  _app_wisun_core_set_state(SL_WISUN_APP_CORE_STATE_NETWORK_CONNECTION_LOST);\n\
    +  _app_wisun_core_set_state(SL_WISUN_APP_CORE_STATE_NETWORK_DISCONNECTED);\n\
    +  _app_wisun_core_clear_state(SL_WISUN_APP_CORE_STATE_NETWORK_CONNECTED);\n \
    \  __CHECK_FOR_STATUS(evt->evt.error.status);\n }\n \n@@ -372,22 +401,43 @@ void\
    \ sl_wisun_lfn_wake_up_hnd(sl_wisun_evt_t *evt)\n   __CHECK_FOR_STATUS(evt->evt.error.status);\n\
    \ }\n \n+void sl_wisun_multicast_reg_finish_hnd(sl_wisun_evt_t *evt)\n+{\n+  __CHECK_FOR_STATUS(evt->evt.error.status);\n\
    +}\n+\n /* Wisun app core init */\n-void app_wisun_core_init(void)\n+void sl_wisun_app_core_init(void)\n\
    \ {\n   // init wisun network mutex\n-  _app_wisun_network_mtx = osMutexNew(&_app_wisun_network_mtx_attr);\n\
    -  assert(_app_wisun_network_mtx != NULL);\n+  _app_core_mtx = osMutexNew(&_app_wisun_mtx_attr);\n\
    +  assert(_app_core_mtx != NULL);\n+\n+  _app_core_state = osEventFlagsNew(&_app_wisun_evt_attr);\n\
    +  assert(_app_core_state != NULL);\n }\n \n /* App core get error */\n-bool app_wisun_core_get_error(app_core_error_state_flag_t\
    \ flag)\n+sl_status_t sl_wisun_app_core_get_state(uint32_t * const state)\n+{\n\
    +  *state = osEventFlagsGet(_app_core_state);\n+  // Check error flag\n+  if (*state\
    \ & APP_WISUN_EVTFLAG_ERROR_MSK) {\n+    return SL_STATUS_FAIL;\n+  }\n+  return\
    \ SL_STATUS_OK;\n+}\n+\n+\n+sl_status_t sl_wisun_app_core_wait_state(const uint32_t\
    \ state, const uint32_t timeout)\n {\n-  return (bool)(_error_flag & (1 << flag));\n\
    +  uint32_t ret = 0UL;\n+  ret = osEventFlagsWait(_app_core_state, state, osFlagsWaitAll\
    \ | osFlagsNoClear, timeout);\n+  return (ret & APP_WISUN_EVTFLAG_ERROR_MSK) ?\
    \ SL_STATUS_FAIL : SL_STATUS_OK;\n }\n \n /*Connecting to the wisun network*/\n\
    -void app_wisun_network_connect(void)\n+void sl_wisun_app_core_network_connect(void)\n\
    \ {\n   sl_status_t ret = SL_STATUS_FAIL;\n   sl_wisun_join_state_t join_state\
    \ = SL_WISUN_JOIN_STATE_DISCONNECTED;\n@@ -403,7 +453,7 @@ void app_wisun_network_connect(void)\n\
    \   ret = app_wisun_setting_get(&_setting);\n   if (ret != SL_STATUS_OK) {\n \
    \    printf(\"[Failed: unable to get settings\\n\");\n-    _app_wisun_core_set_error(SETTING_ERROR_FLAG_BIT);\n\
    +    _app_wisun_core_set_state(SL_WISUN_APP_CORE_STATE_SETTING_ERROR);\n     _return_and_mtx_release();\n\
    \   }\n #else\n@@ -430,7 +480,7 @@ void app_wisun_network_connect(void)\n    \
    \ _return_and_mtx_release();\n   }\n \n-#if (WISUN_APP_REGULATION != REGULATION_NONE)\n\
    +#if (SL_WISUN_APP_CORE_REGULATION != SL_WISUN_APP_CORE_REGULATION_NONE)\n   ret\
    \ = _app_wisun_regulation_setting();\n   if (ret != SL_STATUS_OK) {\n     _return_and_mtx_release();\n\
    @@ -448,7 +498,7 @@ void app_wisun_network_connect(void)\n \n     printf(\"\\\
    n[Connecting to \\\"%s\\\"]\\n\", _setting.network_name);\n   } else {\n-    _app_wisun_core_set_error(CONNECTION_FAILED_ERROR_FLAG_BIT);\n\
    +    _app_wisun_core_set_state(SL_WISUN_APP_CORE_STATE_CONNECTION_ERROR);\n  \
    \   printf(\"\\n[Connection failed: %lu]\\n\", ret);\n   }\n   _app_wisun_mutex_release();\n\
    @@ -459,7 +509,7 @@ void sl_wisun_regulation_tx_level_hnd(sl_wisun_evt_t *evt)\n\
    \   (void)*evt;\n }\n \n-void app_wisun_get_current_addresses(current_addr_t *\
    \ const dest_addresses)\n+void sl_wisun_app_core_get_current_addresses(sl_wisun_app_core_current_addr_t\
    \ * const dest_addresses)\n {\n   _app_wisun_mutex_acquire();\n   memcpy(&dest_addresses->global,\
    \ &_current_addr.global, sizeof(in6_addr_t));\n@@ -470,14 +520,14 @@ void app_wisun_get_current_addresses(current_addr_t\
    \ * const dest_addresses)\n   _app_wisun_mutex_release();\n }\n \n-void app_wisun_set_regulation_active(bool\
    \ enabled)\n+void sl_wisun_app_core_set_regulation_active(bool enabled)\n {\n\
    \   _app_wisun_mutex_acquire();\n   _regional_regulation_active = enabled;\n \
    \  _app_wisun_mutex_release();\n }\n \n-bool app_wisun_get_regulation_active(void)\n\
    +bool sl_wisun_app_core_get_regulation_active(void)\n {\n   bool retval;\n   _app_wisun_mutex_acquire();\n\
    @@ -486,49 +536,52 @@ bool app_wisun_get_regulation_active(void)\n   return retval;\n\
    \ }\n \n-void app_wisun_set_regulation_thresholds(const int8_t warning_level,\
    \ const  int8_t alert_level)\n+void sl_wisun_app_core_set_regulation_thresholds(const\
    \ int8_t warning_level, const  int8_t alert_level)\n {\n   _app_wisun_mutex_acquire();\n\
    \   _tresholds.warning_threshold = warning_level;\n   _tresholds.alert_threshold\
    \ = alert_level;\n   _app_wisun_mutex_release();\n }\n \n-bool app_wisun_get_regulation_thresholds(regulation_thresholds_t*\
    \ thresholds_out)\n+sl_status_t sl_wisun_app_core_get_regulation_thresholds(sl_wisun_app_core_reg_thresholds_t*\
    \ thresholds_out)\n {\n   if (thresholds_out == NULL) {\n-    return false;\n\
    +    return SL_STATUS_FAIL;\n   }\n \n   _app_wisun_mutex_acquire();\n   thresholds_out->warning_threshold\
    \ = _tresholds.warning_threshold;\n   thresholds_out->alert_threshold = _tresholds.alert_threshold;\n\
    \   _app_wisun_mutex_release();\n-  return true;\n+  return SL_STATUS_OK;\n }\n\
    \ \n-bool app_wisun_get_remaining_tx_budget(uint32_t* const budget_out)\n+sl_status_t\
    \ sl_wisun_app_core_get_remaining_tx_budget(uint32_t* const budget_out)\n {\n\
    \   sl_wisun_statistics_t stat;\n+  sl_status_t ret = SL_STATUS_FAIL;\n+\n   if\
    \ (!_regional_regulation_active || budget_out == NULL) {\n-    return false;\n\
    +    return ret;\n   }\n \n   _app_wisun_mutex_acquire();\n \n   if (sl_wisun_get_statistics(SL_WISUN_STATISTICS_TYPE_REGULATION,\
    \ &stat) == SL_STATUS_OK) {\n     // return a meaningful value (budget remaning)\
    \ or zero (exceeded)\n-    *budget_out = (stat.regulation.arib.tx_duration_ms\
    \ < WISUN_APP_TX_BUDGET)\n-                  ? (WISUN_APP_TX_BUDGET - stat.regulation.arib.tx_duration_ms)\
    \ : 0UL;\n+    *budget_out = (stat.regulation.arib.tx_duration_ms < SL_WISUN_APP_CORE_TX_BUDGET)\n\
    +                  ? (SL_WISUN_APP_CORE_TX_BUDGET - stat.regulation.arib.tx_duration_ms)\
    \ : 0UL;\n+    ret = SL_STATUS_OK;\n   } else {\n-    return false;\n+    ret\
    \ = SL_STATUS_FAIL;\n   }\n   _app_wisun_mutex_release();\n \n-  return true;\n\
    +  return ret;\n }\n \n-sl_wisun_join_state_t app_wisun_get_join_state(void)\n\
    +sl_wisun_join_state_t sl_wisun_app_core_get_join_state(void)\n {\n   sl_wisun_join_state_t\
    \ join_state = SL_WISUN_JOIN_STATE_DISCONNECTED;\n   _app_wisun_mutex_acquire();\n\
    @@ -537,7 +590,7 @@ sl_wisun_join_state_t app_wisun_get_join_state(void)\n   return\
    \ join_state;\n }\n \n-void app_wisun_get_time_stat(app_core_time_stat_t * const\
    \ tstat)\n+void sl_wisun_app_core_get_time_stat(sl_wisun_app_core_time_stat_t\
    \ * const tstat)\n {\n   uint64_t time_ms = 0ULL;\n \n@@ -546,7 +599,7 @@ void\
    \ app_wisun_get_time_stat(app_core_time_stat_t * const tstat)\n   // update current\
    \ time\n   sl_sleeptimer_tick64_to_ms(sl_sleeptimer_get_tick_count64(), &time_ms);\n\
    \ \n-  memcpy(tstat, &_time_stat, sizeof(app_core_time_stat_t));\n+  memcpy(tstat,\
    \ &_time_stat, sizeof(sl_wisun_app_core_time_stat_t));\n \n   // add diff beetween\
    \ current time and last update time to the actual state\n   tstat->curr_ms = time_ms;\n\
    @@ -561,17 +614,17 @@ void app_wisun_get_time_stat(app_core_time_stat_t * const\
    \ tstat)\n }\n #if defined(SL_CATALOG_WISUN_LFN_DEVICE_SUPPORT_PRESENT)\n \n-sl_wisun_device_type_t\
    \ app_wisun_get_device_type(void)\n+sl_wisun_device_type_t sl_wisun_app_core_get_device_type(void)\n\
    \ {\n   return (sl_wisun_device_type_t)_setting.device_type;\n }\n \n-sl_wisun_lfn_profile_t\
    \ app_wisun_get_lfn_profile(void)\n+sl_wisun_lfn_profile_t sl_wisun_app_core_get_lfn_profile(void)\n\
    \ {\n   return (sl_wisun_lfn_profile_t)_setting.lfn_profile;\n }\n \n-const sl_wisun_lfn_params_t\
    \ *app_wisun_get_lfn_params(void)\n+const sl_wisun_lfn_params_t *sl_wisun_app_core_get_lfn_params(void)\n\
    \ {\n   // Not lfn device\n   if (_setting.device_type != SL_WISUN_LFN) {\n@@\
    \ -613,7 +666,7 @@ static sl_status_t _app_wisun_application_setting(const app_setting_wisun_t\
    \ * co\n #if defined(SL_CATALOG_WISUN_LFN_DEVICE_SUPPORT_PRESENT)\n   if (setting->device_type\
    \ == SL_WISUN_LFN) {\n     // Store LFN profile based on wisun config\n-    ret\
    \ = sl_wisun_set_lfn_parameters(app_wisun_get_lfn_params());\n+    ret = sl_wisun_set_lfn_parameters(sl_wisun_app_core_get_lfn_params());\n\
    \     if (ret != SL_STATUS_OK) {\n       printf(\"[Failed: unable to set device\
    \ type: %lu]\\n\", ret);\n       return ret;\n@@ -631,15 +684,15 @@ static sl_status_t\
    \ _app_wisun_application_setting(const app_setting_wisun_t * co\n   ret = sl_wisun_set_connection_parameters(conn_param);\n\
    \   if (ret != SL_STATUS_OK) {\n     printf(\"[Failed: unable to set network size:\
    \ %lu]\\n\", ret);\n-    _app_wisun_core_set_error(SET_NETWORK_SIZE_ERROR_FLAG_BIT);\n\
    +    _app_wisun_core_set_state(SL_WISUN_APP_CORE_STATE_SET_NETWORK_SIZE_ERROR);\n\
    \     return ret;\n   }\n \n   // sets the TX power\n   ret = sl_wisun_set_tx_power(setting->tx_power);\n\
    \   if (ret != SL_STATUS_OK) {\n     printf(\"[Failed: unable to set TX power:\
    \ %lu]\\n\", ret);\n-    _app_wisun_core_set_error(SET_TX_POWER_ERROR_FLAG_BIT);\n\
    +    _app_wisun_core_set_state(SL_WISUN_APP_CORE_STATE_SET_TX_POWER_ERROR);\n\
    \     return ret;\n   }\n #if defined(WISUN_CONFIG_ALLOWED_CHANNELS)\n@@ -665,7\
    \ +718,7 @@ static sl_status_t _app_wisun_application_setting(const app_setting_wisun_t\
    \ * co\n \n   if (ret != SL_STATUS_OK) {\n     printf(\"[Failed: unable to set\
    \ dwell interval: %lu]\\n\", ret);\n-    _app_wisun_core_set_error(SET_DWELL_INTERVAL_ERROR_FLAG_BIT);\n\
    +    _app_wisun_core_set_state(SL_WISUN_APP_CORE_STATE_SET_DWELL_INTERVAL_ERROR);\n\
    \     return ret;\n   }\n #endif\n@@ -675,7 +728,7 @@ static sl_status_t _app_wisun_application_setting(const\
    \ app_setting_wisun_t * co\n   ret = sl_wisun_set_mac_address(&wisun_config_mac_address);\n\
    \   if (ret != SL_STATUS_OK) {\n     printf(\"[Failed: unable to set MAC address:\
    \ %lu]\\n\", ret);\n-    _app_wisun_core_set_error(SET_MAC_ADDR_ERROR_FLAG_BIT);\n\
    +    _app_wisun_core_set_state(SL_WISUN_APP_CORE_STATE_SET_MAC_ADDR_ERROR);\n\
    \     return ret;\n   }\n #endif\n@@ -686,7 +739,7 @@ static sl_status_t _app_wisun_application_setting(const\
    \ app_setting_wisun_t * co\n     ret = sl_wisun_allow_mac_address(&wisun_config_mac_allow_list.mac_list[index]);\n\
    \     if (ret != SL_STATUS_OK) {\n       printf(\"[Failed: unable to set allow\
    \ address: %lu]\\n\", ret);\n-      _app_wisun_core_set_error(SET_ALLOW_MAC_ADDR_ERROR_FLAG_BIT);\n\
    +      _app_wisun_core_set_state(SL_WISUN_APP_CORE_STATE_SET_ALLOW_MAC_ADDR_ERROR);\n\
    \       return ret;\n     }\n   }\n@@ -697,7 +750,7 @@ static sl_status_t _app_wisun_application_setting(const\
    \ app_setting_wisun_t * co\n     ret = sl_wisun_deny_mac_address(&wisun_config_mac_deny_list.mac_list[index]);\n\
    \     if (ret != SL_STATUS_OK) {\n       printf(\"[Failed: unable to set allow\
    \ address: %lu]\\n\", ret);\n-      _app_wisun_core_set_error(SET_DENY_MAC_ADDR_ERROR_FLAG_BIT);\n\
    +      _app_wisun_core_set_state(SL_WISUN_APP_CORE_SET_DENY_MAC_ADDR_ERROR);\n\
    \       return ret;\n     }\n   }\n@@ -717,7 +770,7 @@ sl_status_t _app_wisun_security_setting(void)\n\
    \                                          wisun_config_ca_certificate);\n   if\
    \ (ret != SL_STATUS_OK) {\n     printf(\"[Failed: unable to set the trusted certificate:\
    \ %lu]\\n\", ret);\n-    _app_wisun_core_set_error(SET_TRUSTED_CERTIFICATE_ERROR_FLAG_BIT);\n\
    +    _app_wisun_core_set_state(SL_WISUN_APP_CORE_STATE_SET_TRUSTED_CERTIFICATE_ERROR);\n\
    \     return ret;\n   }\n \n@@ -727,7 +780,7 @@ sl_status_t _app_wisun_security_setting(void)\n\
    \                                         wisun_config_device_certificate);\n\
    \   if (ret != SL_STATUS_OK) {\n     printf(\"[Failed: unable to set the device\
    \ certificate: %lu]\\n\", ret);\n-    _app_wisun_core_set_error(SET_DEVICE_CERTIFICATE_ERROR_FLAG_BIT);\n\
    +    _app_wisun_core_set_state(SL_WISUN_APP_CORE_STATE_SET_DEVICE_CERTIFICATE_ERROR);\n\
    \     return ret;\n   }\n \n@@ -739,32 +792,32 @@ sl_status_t _app_wisun_security_setting(void)\n\
    \                                         wisun_config_device_private_key);\n\
    \   if (ret != SL_STATUS_OK) {\n     printf(\"[Failed: unable to set the device\
    \ private key: %lu]\\n\", ret);\n-    _app_wisun_core_set_error(SET_DEVICE_PRIVATE_KEY_ERROR_FLAG_BIT);\n\
    +    _app_wisun_core_set_state(SL_WISUN_APP_CORE_STATE_SET_DEVICE_PRIVATE_KEY_ERROR);\n\
    \     return ret;\n   }\n \n   return ret;\n }\n \n-#if (WISUN_APP_REGULATION\
    \ != REGULATION_NONE)\n+#if (SL_WISUN_APP_CORE_REGULATION != SL_WISUN_APP_CORE_REGULATION_NONE)\n\
    \ __STATIC_INLINE sl_status_t _app_wisun_regulation_setting(void)\n {\n   sl_status_t\
    \ ret = SL_STATUS_FAIL;\n \n   // regulation thresholds\n-  regulation_thresholds_t\
    \ thresholds;\n+  sl_wisun_app_core_reg_thresholds_t thresholds;\n   // name of\
    \ the regulation type to print upon connection\n   char* regulation_name;\n \n\
    -  (void)app_wisun_get_regulation_thresholds(&thresholds);\n+  (void)sl_wisun_app_core_get_regulation_thresholds(&thresholds);\n\
    \   ret = sl_wisun_set_regulation_tx_thresholds(thresholds.warning_threshold,\n\
    \                                               thresholds.alert_threshold);\n\
    \   if (ret == SL_STATUS_OK) {\n-    ret = sl_wisun_set_regulation(WISUN_APP_REGULATION);\n\
    +    ret = sl_wisun_set_regulation(SL_WISUN_APP_CORE_REGULATION);\n     if (ret\
    \ != SL_STATUS_OK) {\n       printf(\"[Failed: unable to set regulation: %lu]\\\
    n\", ret);\n     } else {\n-      switch (WISUN_APP_REGULATION) {\n+      switch\
    \ (SL_WISUN_APP_CORE_REGULATION) {\n         case SL_WISUN_REGULATION_ARIB: regulation_name\
    \ = \"ARIB\"; break;\n         default:\n           regulation_name = \"UNKNOWN\"\
    ;\n@@ -783,13 +836,13 @@ __STATIC_INLINE sl_status_t _app_wisun_regulation_setting(void)\n\
    \ /* Mutex acquire */\n __STATIC_INLINE void _app_wisun_mutex_acquire(void)\n\
    \ {\n-  assert(osMutexAcquire(_app_wisun_network_mtx, osWaitForever) == osOK);\n\
    +  assert(osMutexAcquire(_app_core_mtx, osWaitForever) == osOK);\n }\n \n /* Mutex\
    \ release */\n __STATIC_INLINE void _app_wisun_mutex_release(void)\n {\n-  assert(osMutexRelease(_app_wisun_network_mtx)\
    \ == osOK);\n+  assert(osMutexRelease(_app_core_mtx) == osOK);\n }\n \n /* Storing\
    \ address */\n@@ -822,15 +875,20 @@ static void _store_address(const char *addr_name,\n\
    \ }\n \n /* Setting error */\n-__STATIC_INLINE void _app_wisun_core_set_error(app_core_error_state_flag_t\
    \ flag)\n+__STATIC_INLINE void _app_wisun_core_set_state(const sl_wisun_app_core_state_t\
    \ flag)\n+{\n+  (void) osEventFlagsSet(_app_core_state, 1UL << flag);\n+}\n+\n\
    +__STATIC_INLINE void _app_wisun_core_clear_state(const sl_wisun_app_core_state_t\
    \ flag)\n {\n-  _error_flag |= (1 << flag);\n+  (void) osEventFlagsClear(_app_core_state,\
    \ 1UL << flag);\n }\n \n /* Storing current addresses */\n static void _store_current_addresses(void)\n\
    \ {\n-  memset(&_current_addr, 0, sizeof(current_addr_t));\n+  memset(&_current_addr,\
    \ 0, sizeof(sl_wisun_app_core_current_addr_t));\n   printf(\"\\nAddresses:\\n\"\
    );\n   _store_address(\"GLOBAL\", SL_WISUN_IP_ADDRESS_TYPE_GLOBAL, &_current_addr.global);\n\
    \   _store_address(\"LINK_LOCAL\", SL_WISUN_IP_ADDRESS_TYPE_LINK_LOCAL, &_current_addr.link_local);"
  - "--- a/app/wisun/component/app_core/sl_wisun_app_core_util.c\n+++ b/app/wisun/component/app_core/sl_wisun_app_core_util.c\n\
    @@ -35,7 +35,8 @@\n #include <string.h>\n #include \"sl_wisun_api.h\"\n #include\
    \ \"sl_wisun_app_core_util.h\"\n-#include \"sl_wisun_app_core_util_config.h\"\n\
    +#include \"sl_wisun_app_core_config.h\"\n+#include \"sl_wisun_app_core.h\"\n\
    \ #include \"app_project_info.h\"\n #include \"sl_wisun_config.h\"\n // -----------------------------------------------------------------------------\n\
    @@ -62,7 +63,7 @@ static app_project_info_t _app_project_info = { 0 };\n // -----------------------------------------------------------------------------\n\
    \ \n /* Init project info */\n-void app_wisun_project_info_init(const char * app_name)\n\
    +void sl_wisun_app_core_util_project_info_init(const char * app_name)\n {\n  \
    \ const app_project_info_version_t *stack_ver = NULL;\n   app_project_info_get(&_app_project_info);\n\
    @@ -77,7 +78,7 @@ void app_wisun_project_info_init(const char * app_name)\n }\n\
    \ \n /* Print project info */\n-void app_wisun_project_info_print(const bool json_format)\n\
    +void sl_wisun_app_core_util_project_info_print(const bool json_format)\n {\n\
    \   if (json_format) {\n     app_project_info_print_json(&_app_project_info, printf);\n\
    @@ -87,39 +88,25 @@ void app_wisun_project_info_print(const bool json_format)\n\
    \ }\n \n /* Connect and wait */\n-void app_wisun_connect_and_wait(void)\n+void\
    \ sl_wisun_app_core_util_connect_and_wait(void)\n {\n-  app_wisun_network_connect();\n\
    -  app_wisun_wait_for_connection();\n+  sl_wisun_app_core_network_connect();\n\
    +  sl_wisun_app_core_util_wait_for_connection();\n }\n \n /* Waiting for connection\
    \ */\n-void app_wisun_wait_for_connection(void)\n+void sl_wisun_app_core_util_wait_for_connection(void)\n\
    \ {\n-#if (HEARTBEAT_ENABLED == 1)\n-  uint8_t dot_line_cnt = 0;\n-#endif\n- \
    \ osDelay(10);\n-  printf(\"\\n\");\n-  while (1) {\n-    if (app_wisun_network_is_connected())\
    \ {\n-      break;\n-    }\n-#if (HEARTBEAT_ENABLED == 1)\n-    printf((dot_line_cnt\
    \ == HEARBEAT_SECTION_LENGTH ? \"[%ds]\\n\" : \"#\"), dot_line_cnt);\n-    dot_line_cnt\
    \ = dot_line_cnt == HEARBEAT_SECTION_LENGTH ? 0 : dot_line_cnt + 1;\n-#endif\n\
    -    osDelay(1000); // 1s\n-  }\n+  (void) sl_wisun_app_core_wait_state((1 <<\
    \ SL_WISUN_APP_CORE_STATE_NETWORK_CONNECTED), osWaitForever);\n }\n \n-bool app_wisun_network_is_connected(void)\n\
    +bool sl_wisun_app_core_util_network_is_connected(void)\n {\n-  sl_wisun_join_state_t\
    \ join_state = app_wisun_get_join_state();\n+  sl_wisun_join_state_t join_state\
    \ = sl_wisun_app_core_get_join_state();\n   return join_state == SL_WISUN_JOIN_STATE_OPERATIONAL\
    \ ? true : false;\n }\n \n-void app_wisun_dispatch_thread(void)\n+void sl_wisun_app_core_util_dispatch_thread(void)\n\
    \ {\n #if !defined(WISUN_CONFIG_DEVICE_TYPE)\n   uint8_t device_type = SL_WISUN_ROUTER;\n\
    @@ -128,13 +115,13 @@ void app_wisun_dispatch_thread(void)\n #endif\n \n   if\
    \ (device_type == SL_WISUN_LFN) {\n-    osDelay(APP_THREAD_LP_DISPATCH_MS);\n\
    +    osDelay(SL_WISUN_APP_CORE_THREAD_LP_DISPATCH_MS);\n   } else {\n     osDelay(1UL);\n\
    \   }\n }\n \n-const app_project_info_t * app_wisun_project_info_get(void)\n+const\
    \ app_project_info_t * sl_wisun_app_core_util_project_info_get(void)\n {\n   return\
    \ (const app_project_info_t * ) &_app_project_info;\n }"
  - "--- a/app/wisun/component/app_setting/sl_wisun_app_setting.c\n+++ b/app/wisun/component/app_setting/sl_wisun_app_setting.c\n\
    @@ -434,7 +434,7 @@ sl_status_t app_wisun_setting_subscribe_notification(const\
    \ app_setting_notificat\n   app_setting_notif_dsc_t *notif = NULL;\n   uint32_t\
    \ mask = 0UL;\n   notif = _get_notification_entry(type);\n-  if (notif == NULL)\
    \ {\n+  if (notif == NULL || channel == NULL) {\n     return stat;\n   }\n "
  - "--- a/app/wisun/component/app_status/sl_wisun_app_status.c\n+++ b/app/wisun/component/app_status/sl_wisun_app_status.c\n\
    @@ -162,6 +162,24 @@ static void _build_time_stat(uint8_t **buf, uint16_t *buf_len);\n\
    \  *****************************************************************************/\n\
    \ static uint16_t _build_payload(void);\n \n+/**************************************************************************//**\n\
    + * @brief Acquire application mutex\n+ * @details Internal mutex lock\n+ *****************************************************************************/\n\
    +__STATIC_INLINE void _app_wisun_mutex_acquire(void);\n+\n+/**************************************************************************//**\n\
    + * @brief Release application mutex\n+ * @details Internal mutex release\n+ *****************************************************************************/\n\
    +__STATIC_INLINE void _app_wisun_mutex_release(void);\n+\n+/**************************************************************************//**\n\
    + * @brief Updates the notify settings for CoAP app status notification\n+ * @details\
    \ Removes and add the new notification settings\n+ *****************************************************************************/\n\
    +__STATIC_INLINE sl_status_t _update_notify_settings(void);\n+\n // -----------------------------------------------------------------------------\n\
    \ //                                Global Variables\n // -----------------------------------------------------------------------------\n\
    @@ -176,11 +194,26 @@ static sl_wisun_coap_notify_t _notify = { 0U };\n /// Notification\
    \ payload buffer\n static uint8_t _notif_buff[SL_WISUN_APP_STATUS_NOTIF_PAYLOAD_SIZE]\
    \ = { 0U };\n \n+///  App status mutex\n+static osMutexId_t _app_wisun_app_status_mtx\
    \ = NULL;\n+\n+///  App status mutex attribute\n+static const osMutexAttr_t _app_wisun_app_status_mtx_attr\
    \ = {\n+  .name      = \"AppWisunAppStatusMutex\",\n+  .attr_bits = osMutexRecursive,\n\
    +  .cb_mem    = NULL,\n+  .cb_size   = 0\n+};\n+\n // -----------------------------------------------------------------------------\n\
    \ //                          Public Function Definitions\n // -----------------------------------------------------------------------------\n\
    \ void sl_wisun_app_status_init(void)\n {\n+  // init wisun network mutex\n+ \
    \ _app_wisun_app_status_mtx = osMutexNew(&_app_wisun_app_status_mtx_attr);\n+\
    \  assert(_app_wisun_app_status_mtx != NULL);\n+\n   _notify.id = SL_WISUN_APP_STATUS_DEFAULT_NOTIFCATION_ID;\n\
    \   (void) inet_pton(AF_INET6,\n                    SL_WISUN_APP_STATUS_DEFAULT_REMOTE_ADDR,\n\
    @@ -192,7 +225,7 @@ void sl_wisun_app_status_init(void)\n   _notify.condition_cb\
    \ = sl_wisun_app_status_condition_cb;\n   _notify.hnd_cb = _notify_hnd;\n \n-\
    \  sl_wisun_coap_notify_add(&_notify);\n+  _update_notify_settings();\n }\n \n\
    \ SL_WEAK bool sl_wisun_app_status_condition_cb(const sl_wisun_coap_notify_t *\
    \ notify)\n@@ -201,10 +234,47 @@ SL_WEAK bool sl_wisun_app_status_condition_cb(const\
    \ sl_wisun_coap_notify_t * not\n   return true;\n }\n \n+sockaddr_in6_t* sl_wisun_app_status_get_remote_address(void)\n\
    +{\n+  return &(_notify.remote_addr);\n+}\n+\n+uint32_t sl_wisun_app_status_get_schedule_time_ms(void)\n\
    +{\n+  return _notify.schedule_time_ms;\n+}\n+\n+sl_status_t sl_wisun_app_status_set_remote_address(const\
    \ char *remote_address, const uint16_t port)\n+{\n+  sl_status_t result = SL_STATUS_OK;\n\
    +  int32_t ip_result = 0;\n+  _app_wisun_mutex_acquire();\n+\n+  if (remote_address\
    \ == NULL) {\n+    result =  SL_STATUS_NULL_POINTER;\n+  } else {\n+    ip_result\
    \ = inet_pton(AF_INET6, remote_address, &_notify.remote_addr.sin6_addr);\n+  \
    \  if (ip_result != 1) {\n+      result = SL_STATUS_FAIL;\n+    }\n+    _notify.remote_addr.sin6_port\
    \ = port;\n+  }\n+  _update_notify_settings();\n+  _app_wisun_mutex_release();\n\
    +  return result;\n+}\n+\n+void sl_wisun_app_status_set_schedule_time_ms(const\
    \ uint32_t new_schedule_time_ms)\n+{\n+  _app_wisun_mutex_acquire();\n+  _notify.schedule_time_ms\
    \ = new_schedule_time_ms;\n+  _update_notify_settings();\n+  _app_wisun_mutex_release();\n\
    +}\n+\n // -----------------------------------------------------------------------------\n\
    \ //                          Static Function Definitions\n // -----------------------------------------------------------------------------\n\
    -\n static void _build_neighbour_info(uint8_t **buf, uint16_t *buf_len)\n {\n\
    \   int32_t r = 0L;\n@@ -296,10 +366,10 @@ static void _build_device_info(uint8_t\
    \ **buf, uint16_t *buf_len)\n \n   if (!initialized) {\n #if defined(SL_CATALOG_WISUN_LFN_DEVICE_SUPPORT_PRESENT)\n\
    -    dev_type = app_wisun_get_device_type();\n+    dev_type = sl_wisun_app_core_get_device_type();\n\
    \ #endif\n \n-    pinf = app_wisun_project_info_get();\n+    pinf = sl_wisun_app_core_util_project_info_get();\n\
    \     ver_stack = app_project_info_get_version(APP_PROJECT_INFO_VERSION_ID_WISUN,\
    \ pinf);\n     ver_app = app_project_info_get_version(APP_PROJECT_INFO_VERSION_ID_APP,\
    \ pinf);\n \n@@ -356,7 +426,7 @@ static void _build_device_info(uint8_t **buf,\
    \ uint16_t *buf_len)\n static void _build_time_stat(uint8_t **buf, uint16_t *buf_len)\n\
    \ {\n   int32_t r = 0L;\n-  static app_core_time_stat_t stat = { 0U };\n+  static\
    \ sl_wisun_app_core_time_stat_t stat = { 0U };\n   static sl_wisun_trace_util_time_t\
    \ time = { 0U };\n   const char *run_str = NULL;\n   const char *conn_str = NULL;\n\
    @@ -367,29 +437,29 @@ static void _build_time_stat(uint8_t **buf, uint16_t *buf_len)\n\
    \   uint8_t avail_i = 0U;\n   uint8_t avail_f = 0U;\n \n-  app_wisun_get_time_stat(&stat);\n\
    +  sl_wisun_app_core_get_time_stat(&stat);\n   app_wisun_trace_util_timestamp_init(stat.curr_ms,\
    \ &time);\n   run_str = app_wisun_trace_util_time_to_str(&time);\n \n-  app_wisun_get_time_stat(&stat);\n\
    +  sl_wisun_app_core_get_time_stat(&stat);\n   app_wisun_trace_util_timestamp_init(stat.connected_ms,\
    \ &time);\n   conn_str = app_wisun_trace_util_time_to_str(&time);\n \n-  app_wisun_get_time_stat(&stat);\n\
    +  sl_wisun_app_core_get_time_stat(&stat);\n   app_wisun_trace_util_timestamp_init(stat.tot_connected_ms,\
    \ &time);\n   tot_conn_str = app_wisun_trace_util_time_to_str(&time);\n \n-  app_wisun_get_time_stat(&stat);\n\
    +  sl_wisun_app_core_get_time_stat(&stat);\n   app_wisun_trace_util_timestamp_init(stat.disconnected_ms,\
    \ &time);\n   disconn_str = app_wisun_trace_util_time_to_str(&time);\n \n-  app_wisun_get_time_stat(&stat);\n\
    +  sl_wisun_app_core_get_time_stat(&stat);\n   app_wisun_trace_util_timestamp_init(stat.tot_disconnected_ms,\
    \ &time);\n   tot_disconn_str = app_wisun_trace_util_time_to_str(&time);\n \n\
    \   tmp = (uint16_t) ((stat.tot_connected_ms * 10000U) / (stat.tot_connected_ms\
    \ + stat.tot_disconnected_ms));\n   avail_i = (uint8_t) (tmp / 100U);\n-  avail_f\
    \ = (uint8_t) (tmp - avail_i * 100U); \n+  avail_f = (uint8_t) (tmp - avail_i\
    \ * 100U);\n \n   __print_to_buff(r, *buf, *buf_len,\n                   SL_WISUN_APP_STATUS_TIME_STAT_JSON_STR,\n\
    @@ -466,3 +536,22 @@ static sl_wisun_coap_packet_t * _notify_hnd(const struct\
    \ sl_wisun_coap_notify *n\n \n   return &pkt;\n }\n+\n+/* Mutex acquire */\n+__STATIC_INLINE\
    \ void _app_wisun_mutex_acquire(void)\n+{\n+  assert(osMutexAcquire(_app_wisun_app_status_mtx,\
    \ osWaitForever) == osOK);\n+}\n+\n+/* Mutex release */\n+__STATIC_INLINE void\
    \ _app_wisun_mutex_release(void)\n+{\n+  assert(osMutexRelease(_app_wisun_app_status_mtx)\
    \ == osOK);\n+}\n+\n+/* update coap notify instance*/\n+__STATIC_INLINE sl_status_t\
    \ _update_notify_settings(void)\n+{\n+  sl_wisun_coap_notify_remove_by_id(SL_WISUN_APP_STATUS_DEFAULT_NOTIFCATION_ID);\n\
    +  return sl_wisun_coap_notify_add(&_notify);\n+}"
  - '--- a/app/wisun/component/app_status_cli/sl_wisun_app_status_cli.c

    +++ b/app/wisun/component/app_status_cli/sl_wisun_app_status_cli.c

    @@ -0,0 +1,136 @@

    +/***************************************************************************//**

    + * @file

    + * @brief App Status commandline interface handler

    + *******************************************************************************

    + * # License

    + * <b>Copyright 2021 Silicon Laboratories Inc. www.silabs.com</b>

    + *******************************************************************************

    + *

    + * SPDX-License-Identifier: Zlib

    + *

    + * The licensor of this software is Silicon Laboratories Inc.

    + *

    + * This software is provided ''as-is'', without any express or implied

    + * warranty. In no event will the authors be held liable for any damages

    + * arising from the use of this software.

    + *

    + * Permission is granted to anyone to use this software for any purpose,

    + * including commercial applications, and to alter it and redistribute it

    + * freely, subject to the following restrictions:

    + *

    + * 1. The origin of this software must not be misrepresented; you must not

    + *    claim that you wrote the original software. If you use this software

    + *    in a product, an acknowledgment in the product documentation would be

    + *    appreciated but is not required.

    + * 2. Altered source versions must be plainly marked as such, and must not be

    + *    misrepresented as being the original software.

    + * 3. This notice may not be removed or altered from any source distribution.

    + *

    + ******************************************************************************/

    +

    +// -----------------------------------------------------------------------------

    +//                                   Includes

    +// -----------------------------------------------------------------------------

    +#include <string.h>

    +#include <stdio.h>

    +#include <stddef.h>

    +#include <stdint.h>

    +#include <stdbool.h>

    +#include <stdlib.h>

    +#include "sl_string.h"

    +#include "sl_cli.h"

    +#include "sl_wisun_cli_core.h"

    +#include "sl_wisun_app_status.h"

    +#include "sl_wisun_trace_util.h"

    +

    +// -----------------------------------------------------------------------------

    +//                              Macros and Typedefs

    +// -----------------------------------------------------------------------------

    +///  Size of the IPv6 string

    +#define IPV6_STRING_SIZE                (40U)

    +

    +// -----------------------------------------------------------------------------

    +//                          Static Function Declarations

    +// -----------------------------------------------------------------------------

    +

    +// -----------------------------------------------------------------------------

    +//                                Global Variables

    +// -----------------------------------------------------------------------------

    +

    +// -----------------------------------------------------------------------------

    +//                                Static Variables

    +// -----------------------------------------------------------------------------

    +///  Buffer to store the IPv6 string

    +static char ip_buff[IPV6_STRING_SIZE] = { 0 };

    +

    +// -----------------------------------------------------------------------------

    +//                          Public Function Definitions

    +// -----------------------------------------------------------------------------

    +/**************************************************************************//**

    + * @brief App status get remote address and port

    + * @details CLI function

    + * @param[in] arguments Arguments

    + *****************************************************************************/

    +void sl_app_status_cli_get_address(sl_cli_command_arg_t *arguments)

    +{

    +  (void)arguments;

    +  app_wisun_cli_mutex_lock();

    +  const sockaddr_in6_t* address = sl_wisun_app_status_get_remote_address();

    +  inet_ntop(AF_INET6, &(address->sin6_addr), ip_buff, sizeof(ip_buff));

    +  printf("remote_address=%s\n", ip_buff);

    +  printf("remote_port=%d\n", address->sin6_port);

    +  memset(ip_buff, 0, sizeof(ip_buff));

    +  app_wisun_cli_mutex_unlock();

    +}

    +

    +/**************************************************************************//**

    + * @brief App status get schedule time in ms

    + * @details CLI function

    + * @param[in] arguments Arguments

    + *****************************************************************************/

    +void sl_app_status_cli_get_schedule(sl_cli_command_arg_t *arguments)

    +{

    +  (void)arguments;

    +  app_wisun_cli_mutex_lock();

    +  printf("schedule_time_m=%ld\n", sl_wisun_app_status_get_schedule_time_ms());

    +  app_wisun_cli_mutex_unlock();

    +}

    +

    +/**************************************************************************//**

    + * @brief App status set schedule time in ms

    + * @details CLI function

    + * @param[in] arguments Arguments

    + *****************************************************************************/

    +void sl_app_status_cli_set_schedule(sl_cli_command_arg_t *arguments)

    +{

    +  uint32_t schedule_time_ms = 0;

    +  app_wisun_cli_mutex_lock();

    +  schedule_time_ms = sl_cli_get_argument_uint32(arguments, 0U);

    +  sl_wisun_app_status_set_schedule_time_ms(schedule_time_ms);

    +  printf("[Settings saved]\r\n");

    +  app_wisun_cli_mutex_unlock();

    +}

    +

    +/**************************************************************************//**

    + * @brief App status set remote address and port

    + * @details CLI function

    + * @param[in] arguments Arguments

    + *****************************************************************************/

    +void sl_app_status_cli_set_address(sl_cli_command_arg_t *arguments)

    +{

    +  uint16_t port = 0;

    +  char *address = NULL;

    +  app_wisun_cli_mutex_lock();

    +  address = sl_cli_get_argument_string(arguments, 0U);

    +  port = sl_cli_get_argument_uint16(arguments, 1U);

    +  if (sl_wisun_app_status_set_remote_address(address, port) != 0U) {

    +    printf("[Failed: invalid remote address parameter]\r\n");

    +  } else {

    +    printf("[Settings saved]\r\n");

    +  }

    +  app_wisun_cli_mutex_unlock();

    +}

    +

    +// -----------------------------------------------------------------------------

    +//                          Static Function Definitions

    +// -----------------------------------------------------------------------------'
  - "--- a/app/wisun/component/coap/sl_wisun_coap.c\n+++ b/app/wisun/component/coap/sl_wisun_coap.c\n\
    @@ -192,7 +192,7 @@ sl_status_t sl_wisun_coap_init_srv(sl_wisun_coap_srv_t * const\
    \ srv,\n   }\n \n   // Create socket\n-  srv->sockid = socket(AF_INET6, (SOCK_DGRAM\
    \ | SOCK_NONBLOCK), IPPROTO_UDP);\n+  srv->sockid = socket(AF_INET6, SOCK_DGRAM,\
    \ IPPROTO_UDP);\n   if (srv->sockid == SOCKET_INVALID_ID) {\n     return SL_STATUS_FAIL;\n\
    \   }\n@@ -235,7 +235,7 @@ sl_status_t sl_wisun_coap_init_clnt(sl_wisun_coap_clnt_t\
    \ * const clnt,\n   }\n \n   // Create socket\n-  clnt->sockid = socket(AF_INET6,\
    \ (SOCK_DGRAM | SOCK_NONBLOCK), IPPROTO_UDP);\n+  clnt->sockid = socket(AF_INET6,\
    \ SOCK_DGRAM, IPPROTO_UDP);\n   if (clnt->sockid == SOCKET_INVALID_ID) {\n   \
    \  return SL_STATUS_FAIL;\n   }"
  - "--- a/app/wisun/component/coap/sl_wisun_coap_notify.c\n+++ b/app/wisun/component/coap/sl_wisun_coap_notify.c\n\
    @@ -297,7 +297,7 @@ sl_status_t sl_wisun_coap_notify_send_notification(const sl_wisun_coap_notify_t\n\
    \   int32_t sockid = SOCKET_INVALID_ID;\n \n   // create socket\n-  sockid = socket(AF_INET6,\
    \ (SOCK_DGRAM | SOCK_NONBLOCK), IPPROTO_UDP);\n+  sockid = socket(AF_INET6, SOCK_DGRAM,\
    \ IPPROTO_UDP);\n   if (sockid == SOCKET_RETVAL_ERROR) {\n     return SL_STATUS_FAIL;\n\
    \   }\n@@ -397,7 +397,7 @@ static void _notify_thr_fnc(void * args)\n   (void)\
    \ args;\n \n   SL_COAP_SERVICE_LOOP() {\n-    if (!app_wisun_network_is_connected())\
    \ {\n+    if (!sl_wisun_app_core_util_network_is_connected()) {\n       osDelay(1000UL);\n\
    \       continue;\n     }"
  - "--- a/app/wisun/component/coap/sl_wisun_coap_rhnd.c\n+++ b/app/wisun/component/coap/sl_wisun_coap_rhnd.c\n\
    @@ -466,13 +466,13 @@ static void _rhnd_thr_fnc(void * args)\n \n   SL_COAP_SERVICE_LOOP()\
    \ {\n     // wait for network connected state\n-    if (!app_wisun_network_is_connected())\
    \ {\n+    if (!sl_wisun_app_core_util_network_is_connected()) {\n       osDelay(1000UL);\n\
    \       continue;\n     }\n \n     // creating socket\n-    sockid = socket(AF_INET6,\
    \ (SOCK_DGRAM | SOCK_NONBLOCK), IPPROTO_UDP);\n+    sockid = socket(AF_INET6,\
    \ SOCK_DGRAM, IPPROTO_UDP);\n     assert(sockid != SOCKET_INVALID_ID);\n \n  \
    \   // fill the server address structure\n@@ -487,7 +487,7 @@ static void _rhnd_thr_fnc(void\
    \ * args)\n     assert(r != SOCKET_RETVAL_ERROR);\n \n #if SL_WISUN_COAP_RD_SOCKET_REQUIRED\n\
    -    sockid_rd = socket(AF_INET6, (SOCK_DGRAM | SOCK_NONBLOCK), IPPROTO_UDP);\n\
    +    sockid_rd = socket(AF_INET6, SOCK_DGRAM, IPPROTO_UDP);\n     assert(sockid_rd\
    \ != SOCKET_INVALID_ID);\n \n     srv_addr_rd.sin6_family = AF_INET6;\n@@ -503,7\
    \ +503,7 @@ static void _rhnd_thr_fnc(void * args)\n     // Receiver loop\n  \
    \   while (1) {\n       // Dispatch\n-      app_wisun_dispatch_thread();\n+  \
    \    sl_wisun_app_core_util_dispatch_thread();\n \n       // Receive UDP packets\n\
    \       sockid_active = sockid;\n@@ -609,7 +609,7 @@ static void _rhnd_thr_fnc(void\
    \ * args)\n         __cleanup_service();\n \n         // Check network connection\
    \ after a session\n-      } else if (r == SOCKET_RETVAL_ERROR && !app_wisun_network_is_connected())\
    \ {\n+      } else if (r == SOCKET_RETVAL_ERROR && !sl_wisun_app_core_util_network_is_connected())\
    \ {\n         close(sockid);\n #if SL_WISUN_COAP_RD_SOCKET_REQUIRED\n        \
    \ close(sockid_rd);"
  - "--- a/app/wisun/component/collector_cli/sl_wisun_collector_cli.c\n+++ b/app/wisun/component/collector_cli/sl_wisun_collector_cli.c\n\
    @@ -114,6 +114,7 @@ void app_remove_meter(sl_cli_command_arg_t *arguments)\n \
    \  }\n   if (inet_pton(AF_INET6, meter_ip, &meter_addr.sin6_addr) == SOCKET_RETVAL_ERROR\
    \ ) {\n     printf(\"[Failed: invalid remote address parameter]\\r\\n\");\n+ \
    \   app_wisun_release_cli_mutex_and_return();\n   }\n \n   stat = sl_wisun_collector_remove_meter(&meter_addr);\n\
    @@ -147,6 +148,7 @@ void app_async_request(sl_cli_command_arg_t *arguments)\n\
    \   }\n   if (inet_pton(AF_INET6, meter_ip, &meter_addr.sin6_addr) == SOCKET_RETVAL_ERROR\
    \ ) {\n     printf(\"[Failed: invalid remote address parameter]\\r\\n\");\n+ \
    \   app_wisun_release_cli_mutex_and_return();\n   }\n \n   stat = sl_wisun_send_async_request(&meter_addr);"
  - "--- a/app/wisun/component/event_manager/sl_wisun_event_mgr.c\n+++ b/app/wisun/component/event_manager/sl_wisun_event_mgr.c\n\
    @@ -38,13 +38,14 @@\n #include \"sl_cmsis_os2_common.h\"\n #include \"sl_wisun_api.h\"\
    \n #include \"sl_wisun_event_mgr.h\"\n+#include \"sl_wisun_trace_util.h\"\n+\n\
    \ // -----------------------------------------------------------------------------\n\
    \ //                              Macros and Typedefs\n // -----------------------------------------------------------------------------\n\
    \ \n-/**************************************************************************//**\n\
    - * @brief Event index for lookup\n- *****************************************************************************/\n\
    +\n+/// Event index for lookup\n typedef enum {\n   EVENT_IDX_NOTVALID = -1,\n\
    \   EVENT_IDX_NETWORK_UPDATE,\n@@ -60,9 +61,28 @@ typedef enum {\n   EVENT_IDX_ERROR,\n\
    \   EVENT_IDX_JOIN_STATE,\n   EVENT_IDX_REGULATION_TX_LEVEL,\n-  EVENT_IDX_LFN_WAKE_UP\n\
    +  EVENT_IDX_LFN_WAKE_UP,\n+  EVENT_IDX_MULTICAST_REG_FINISH\n } app_wisun_event_id_t;\n\
    \ \n+/// Wi-SUN application callback type.\n+/// It is always called, User cannot\
    \ register or remove them.\n+/// It contains the must have implementation of the\
    \ event.\n+typedef void (*wisun_event_callback_t) (sl_wisun_evt_t *);\n+\n+\n\
    +/// Event handler structure\n+typedef struct event_handler {\n+  /// ID\n+  sl_wisun_msg_ind_id_t\
    \ id;\n+  /// Callback for internal usage\n+  wisun_event_callback_t callback;\n\
    +  /// Custom, registerable and removable callback for applications\n+  custom_wisun_event_callback_t\
    \ custom_callback;\n+  /// Event notification\n+  app_wisun_trace_util_evt_notify_t\
    \ evt_notify;\n+} event_handler_t;\n+\n // -----------------------------------------------------------------------------\n\
    \ //                          Static Function Declarations\n // -----------------------------------------------------------------------------\n\
    @@ -94,25 +114,19 @@ __STATIC_INLINE app_wisun_event_id_t _decode_ind(const sl_wisun_msg_ind_id_t\
    \ ind\n //                                Static Variables\n // -----------------------------------------------------------------------------\n\
    \ \n-/**************************************************************************//**\n\
    - * @brief App framework mutex\n- *****************************************************************************/\n\
    -static osMutexId_t _app_wisun_event_mgr_mtx;\n+/// App framework mutex\n+static\
    \ osMutexId_t _app_wisun_event_mgr_mtx = NULL;\n \n-/**************************************************************************//**\n\
    - * @brief App framework mutex attribute\n- *****************************************************************************/\n\
    +/// App framework mutex attribute\n static const osMutexAttr_t _app_wisun_event_mgr_mtx_attr\
    \ = {\n   .name      = \"AppWisunEventMgrMutex\",\n   .attr_bits = osMutexRecursive,\n\
    \   .cb_mem    = NULL,\n   .cb_size   = 0\n };\n \n-/**************************************************************************//**\n\
    - * @brief Event Lookup table\n- *        Lookup table indexes must be matched\
    \ with app_wisun_event_id_t!\n- *****************************************************************************/\n\
    +/// Event Lookup table\n+/// Lookup table indexes must be matched with app_wisun_event_id_t!\n\
    \ static event_handler_t _wisun_events[] = {\n   {\n     .id = SL_WISUN_MSG_NETWORK_UPDATE_IND_ID,\n\
    @@ -183,12 +197,15 @@ static event_handler_t _wisun_events[] = {\n     .id = SL_WISUN_MSG_LFN_WAKE_UP_IND_ID,\n\
    \     .callback = sl_wisun_lfn_wake_up_hnd,\n     .custom_callback = NULL\n+ \
    \ },\n+  {\n+    .id = SL_WISUN_MSG_LFN_MULTICAST_REG_IND_ID,\n+    .callback\
    \ = sl_wisun_multicast_reg_finish_hnd,\n+    .custom_callback = NULL\n   }\n };\n\
    \ \n-/**************************************************************************//**\n\
    - * @brief Handled event count\n- *****************************************************************************/\n\
    +/// Handled event count\n static const uint16_t _wisun_event_size = sizeof(_wisun_events)\
    \ / sizeof(event_handler_t);\n \n // -----------------------------------------------------------------------------\n\
    @@ -198,8 +215,14 @@ static const uint16_t _wisun_event_size = sizeof(_wisun_events)\
    \ / sizeof(event_h\n /* Event Manager initialization */\n void app_wisun_event_mgr_init(void)\n\
    \ {\n+  // Init mutex\n   _app_wisun_event_mgr_mtx = osMutexNew(&_app_wisun_event_mgr_mtx_attr);\n\
    \   assert(_app_wisun_event_mgr_mtx != NULL);\n+\n+  // Init event flags\n+  for\
    \ (uint16_t i = 0; i < _wisun_event_size; ++i) {\n+    app_wisun_trace_util_evt_notify_init(&_wisun_events[i].evt_notify,\
    \ osFlagsWaitAll);\n+  }\n }\n \n /* Event Manager custom callback register */\n\
    @@ -238,6 +261,8 @@ sl_status_t app_wisun_em_custom_callback_remove(sl_wisun_msg_ind_id_t\
    \ id)\n {\n   osKernelState_t kernel_state = osKernelLocked;\n \n+  kernel_state\
    \ = osKernelGetState();\n+\n   // check kernel state to avoid mutex acquire issue\n\
    \   if (kernel_state == osKernelRunning) {\n     app_wisun_event_mgr_mutex_lock();\n\
    @@ -271,11 +296,81 @@ void sl_wisun_on_event(sl_wisun_evt_t *evt)\n     if (_wisun_events[idx].custom_callback\
    \ != NULL) {\n       _wisun_events[idx].custom_callback(evt);\n     }\n+\n+  \
    \  if (_wisun_events[idx].evt_notify.evt_chs) {\n+      app_wisun_trace_util_evt_notfiy_chs(&_wisun_events[idx].evt_notify);\n\
    +    }\n   }\n \n   app_wisun_event_mgr_mutex_unlock();\n }\n \n+sl_status_t app_wisun_em_subscribe_evt_notification(const\
    \ sl_wisun_msg_ind_id_t id, uint8_t * const evt_ch)\n+{\n+  app_wisun_event_id_t\
    \ idx = _decode_ind(id);\n+  sl_status_t ret = SL_STATUS_FAIL;\n+  osKernelState_t\
    \ kernel_state = osKernelLocked;\n+\n+  kernel_state = osKernelGetState();\n+\n\
    +  if (EVENT_IDX_NOTVALID == idx) {\n+    return ret;\n+  }\n+\n+  if (kernel_state\
    \ == osKernelRunning) {\n+    app_wisun_event_mgr_mutex_lock();\n+  }\n+\n+  ret\
    \ = app_wisun_trace_util_evt_notify_subscribe_ch(&_wisun_events[idx].evt_notify,\
    \ evt_ch);\n+\n+  if (kernel_state == osKernelRunning) {\n+    app_wisun_event_mgr_mutex_unlock();\n\
    +  }\n+\n+  return ret;\n+}\n+\n+sl_status_t app_wisun_em_unsubscribe_evt_notification(const\
    \ sl_wisun_msg_ind_id_t id, const uint8_t evt_ch)\n+{\n+  app_wisun_event_id_t\
    \ idx = _decode_ind(id);\n+  sl_status_t ret = SL_STATUS_FAIL;\n+  osKernelState_t\
    \ kernel_state = osKernelLocked;\n+\n+  kernel_state = osKernelGetState();\n+\n\
    +  if (EVENT_IDX_NOTVALID == idx) {\n+    return ret;\n+  }\n+\n+  if (kernel_state\
    \ == osKernelRunning) {\n+    app_wisun_event_mgr_mutex_lock();\n+  }\n+\n+  ret\
    \ = app_wisun_trace_util_evt_notify_unsubscribe_ch(&_wisun_events[idx].evt_notify,\
    \ evt_ch);\n+\n+  if (kernel_state == osKernelRunning) {\n+    app_wisun_event_mgr_mutex_unlock();\n\
    +  }\n+\n+  return ret;\n+}\n+\n+sl_status_t app_wisun_em_wait_evt_notification(const\
    \ sl_wisun_msg_ind_id_t id, const uint8_t evt_ch)\n+{\n+  app_wisun_event_id_t\
    \ idx = _decode_ind(id);\n+  sl_status_t ret = SL_STATUS_FAIL;\n+\n+  if (EVENT_IDX_NOTVALID\
    \ == idx) {\n+    return ret;\n+  }\n+  \n+  ret = app_wisun_trace_util_evt_notify_wait(&_wisun_events[idx].evt_notify,\
    \ \n+                                             1U << evt_ch, \n+          \
    \                                   osWaitForever);\n+\n+  return ret;\n+}\n+\n\
    \ // -----------------------------------------------------------------------------\n\
    \ //                          Static Function Definitions\n // -----------------------------------------------------------------------------\n\
    @@ -310,6 +405,7 @@ __STATIC_INLINE app_wisun_event_id_t _decode_ind(const sl_wisun_msg_ind_id_t\
    \ ind\n     case SL_WISUN_MSG_JOIN_STATE_IND_ID:                    return EVENT_IDX_JOIN_STATE;\n\
    \     case SL_WISUN_MSG_REGULATION_TX_LEVEL_IND_ID:           return EVENT_IDX_REGULATION_TX_LEVEL;\n\
    \     case SL_WISUN_MSG_LFN_WAKE_UP_IND_ID:                   return EVENT_IDX_LFN_WAKE_UP;\n\
    +    case SL_WISUN_MSG_LFN_MULTICAST_REG_IND_ID:             return EVENT_IDX_MULTICAST_REG_FINISH;\n\
    \     default:                                                return EVENT_IDX_NOTVALID;\n\
    \   }\n }\n@@ -463,3 +559,14 @@ SL_WEAK void sl_wisun_lfn_wake_up_hnd(sl_wisun_evt_t\
    \ *evt)\n   (void) evt;\n   assert(false);\n }\n+\n+/**************************************************************************//**\n\
    + * @brief Wi-SUN multicast group registration finishes event handler\n+ * @details\n\
    + * @param[in] evt event ptr\n+ *****************************************************************************/\n\
    +SL_WEAK void sl_wisun_multicast_reg_finish_hnd(sl_wisun_evt_t *evt)\n+{\n+  (void)\
    \ evt;\n+  assert(false);\n+}"
  - "--- a/app/wisun/component/ftp_posix_port/sl_wisun_ftp_posix_port.c\n+++ b/app/wisun/component/ftp_posix_port/sl_wisun_ftp_posix_port.c\n\
    @@ -82,7 +82,7 @@ void sl_ftp_delay_ms(const uint32_t delay_ms)\n  ******************************************************************************/\n\
    \ bool sl_ftp_is_network_connected(void)\n {\n-  return app_wisun_network_is_connected();\n\
    +  return sl_wisun_app_core_util_network_is_connected();\n }\n \n /***************************************************************************//**\n\
    @@ -130,7 +130,7 @@ int32_t sl_ftp_socket_close(int32_t sockid)\n  ******************************************************************************/\n\
    \ int32_t sl_ftp_tcp_socket_create(void)\n {\n-  return socket(AF_INET6, (SOCK_STREAM\
    \ | SOCK_NONBLOCK), IPPROTO_TCP);\n+  return socket(AF_INET6, SOCK_STREAM, IPPROTO_TCP);\n\
    \ }\n \n /***************************************************************************//**\n\
    @@ -192,7 +192,7 @@ int32_t sl_ftp_tcp_socket_recv(int32_t sockid, void *buff,\
    \ uint32_t len)\n  ******************************************************************************/\n\
    \ int32_t sl_tftp_udp_socket_create(void)\n {\n-  return socket(AF_INET6, (SOCK_DGRAM\
    \ | SOCK_NONBLOCK), IPPROTO_UDP);\n+  return socket(AF_INET6, SOCK_DGRAM, IPPROTO_UDP);\n\
    \ }\n \n /**************************************************************************//**"
  - "--- a/app/wisun/component/iperf/sl_iperf.c\n+++ b/app/wisun/component/iperf/sl_iperf.c\n\
    @@ -224,20 +224,26 @@ void sl_iperf_test_init(sl_iperf_test_t * const test, sl_iperf_mode_t\
    \ mode, sl_i\n \n void sl_iperf_test_set_default_logger(sl_iperf_test_t * const\
    \ test)\n {\n-  test->log = &_def_log;\n+  if (test != NULL) {\n+    test->log\
    \ = &_def_log;\n+  }\n }\n \n void sl_iperf_test_set_default_buff(sl_iperf_test_t\
    \ * const test)\n {\n-  test->conn.buff = _iperf_buff;\n-  test->conn.buff_size\
    \ = SL_IPERF_BUFFER_SIZE;\n+  if (test != NULL) {\n+    test->conn.buff = _iperf_buff;\n\
    +    test->conn.buff_size = SL_IPERF_BUFFER_SIZE;\n+  }\n }\n \n #if !defined(SL_IPERF_CMSIS_RTOS_DISABLED)\n\
    \ bool sl_iperf_test_add(sl_iperf_test_t * const test)\n {\n   osStatus_t status\
    \ = osError;\n-  status = osMessageQueuePut(_iperf_test_req_msg_queue, test, 0U,\
    \ osWaitForever);\n+  if (test != NULL) {\n+    status = osMessageQueuePut(_iperf_test_req_msg_queue,\
    \ test, 0U, osWaitForever);\n+  }\n   return _os_status_to_bool(status);\n }\n\
    \ "
  - "--- a/app/wisun/component/iperf/sl_iperf_udp_clnt.c\n+++ b/app/wisun/component/iperf/sl_iperf_udp_clnt.c\n\
    @@ -353,6 +353,7 @@ static void _parse_srv_finack(sl_iperf_test_t * const test)\n\
    \   t.usec = sl_iperf_network_ntohl(hdr->stop_usec);\n   test->statistic.finack_duration_ms\
    \ = sl_iperf_calc_ms_from_time(&t);\n   test->statistic.finack_pkt = sl_iperf_network_ntohl(hdr->packet_cnt);\n\
    +  test->statistic.finack_bw = (uint32_t)(((uint64_t)test->statistic.finack_tot_len\
    \ * SL_IPERF_DATA_BYTE_TO_BIT_ML * SL_IPERF_TIME_S_TO_MS_ML) / test->statistic.finack_duration_ms);\n\
    \   test->statistic.udp_lost_pkt = sl_iperf_network_ntohl(hdr->lost_pkt_cnt);\n\
    \   test->statistic.udp_out_of_order = sl_iperf_network_ntohl(hdr->out_of_order_cnt);\n\
    \   t.sec = sl_iperf_network_ntohl(hdr->jitter_sec);"
  - "--- a/app/wisun/component/iperf/sl_iperf_util.c\n+++ b/app/wisun/component/iperf/sl_iperf_util.c\n\
    @@ -248,7 +248,8 @@ void sl_iperf_print_test_log_json(sl_iperf_test_t * const\
    \ test)\n   sl_iperf_log_print(test->log, \"%*s\\\"bandwidth\\\":            \
    \ %lu,\\n\", __indent(3U), test->statistic.bandwidth);\n   sl_iperf_log_print(test->log,\
    \ \"%*s\\\"finack_tot_len\\\":        %lu,\\n\", __indent(3U), test->statistic.finack_tot_len);\n\
    \   sl_iperf_log_print(test->log, \"%*s\\\"finack_duration_ms\\\":    %lu,\\n\"\
    , __indent(3U), test->statistic.finack_duration_ms);\n-  sl_iperf_log_print(test->log,\
    \ \"%*s\\\"finack_pkt\\\":            %lu\\n\", __indent(3U), test->statistic.finack_pkt);\n\
    +  sl_iperf_log_print(test->log, \"%*s\\\"finack_pkt\\\":            %lu,\\n\"\
    , __indent(3U), test->statistic.finack_pkt);\n+  sl_iperf_log_print(test->log,\
    \ \"%*s\\\"finack_bw\\\":             %lu\\n\", __indent(3U), test->statistic.finack_bw);\n\
    \   sl_iperf_log_print(test->log, \"%*s}\\n\", __indent(2U));\n   sl_iperf_log_print(test->log,\
    \ \"%*s}\\n\", __indent(1U));\n   sl_iperf_log_print(test->log, \"}\\n\");"
  - "--- a/app/wisun/component/iperf_posix_port/sl_wisun_iperf_posix_port.c\n+++ b/app/wisun/component/iperf_posix_port/sl_wisun_iperf_posix_port.c\n\
    @@ -84,10 +84,10 @@ int32_t sl_iperf_socket_create(sl_iperf_protocol_t protocol)\n\
    \ \n   switch (protocol) {\n     case SL_IPERF_IPROTOV6_UDP:\n-      sockid =\
    \ socket(AF_INET6, (SOCK_DGRAM | SOCK_NONBLOCK), IPPROTO_UDP);\n+      sockid\
    \ = socket(AF_INET6, SOCK_DGRAM | SOCK_NONBLOCK, IPPROTO_UDP);\n       break;\n\
    \     case SL_IPERF_IPROTOV6_TCP:\n-      sockid = socket(AF_INET6, (SOCK_STREAM\
    \ | SOCK_NONBLOCK), IPPROTO_TCP);\n+      sockid = socket(AF_INET6, SOCK_STREAM\
    \ | SOCK_NONBLOCK, IPPROTO_TCP);\n       break;\n     // IPv4 is not supported\
    \ on Wi-SUN\n     default: return SL_IPERF_NW_API_ERROR;\n@@ -195,7 +195,7 @@\
    \ void sl_iperf_get_socket_addr_ip(const sl_iperf_socket_addr_t * const addr,\
    \ void\n \n bool sl_iperf_network_is_connected(void)\n {\n-  return app_wisun_network_is_connected();\n\
    +  return sl_wisun_app_core_util_network_is_connected();\n }\n \n uint16_t sl_iperf_network_htons(uint16_t\
    \ val)"
  - "--- a/app/wisun/component/led_driver/sl_wisun_led_driver.c\n+++ b/app/wisun/component/led_driver/sl_wisun_led_driver.c\n\
    @@ -37,15 +37,19 @@\n #include <stddef.h>\n #include <stdio.h>\n #include <inttypes.h>\n\
    +\n+#include \"sl_wisun_led_driver.h\"\n+\n+#if !defined(SL_CATALOG_POWER_MANAGER_PRESENT)\n\
    \ #include \"cmsis_os2.h\"\n #include \"sl_status.h\"\n #include \"sl_cmsis_os2_common.h\"\
    \n-#include \"sl_wisun_led_driver.h\"\n #include \"sl_simple_led.h\"\n #include\
    \ \"sl_simple_led_instances.h\"\n #include \"sl_wisun_trace_util.h\"\n #include\
    \ \"sl_wisun_led_driver_config.h\"\n \n+\n // -----------------------------------------------------------------------------\n\
    \ //                              Macros and Typedefs\n // -----------------------------------------------------------------------------\n\
    @@ -397,3 +401,11 @@ __STATIC_INLINE sl_wisun_led_signal_t *_get_led_signal_ptr(const\
    \ sl_wisun_led_id\n     default:               return NULL;\n   }\n }\n+#else\n\
    +\n+void sl_wisun_led_driver_init(void)\n+{\n+  (void) 0UL;\n+}\n+\n+#endif"
  - "--- a/app/wisun/component/meter_collector_common/sl_wisun_coap_collector.c\n\
    +++ b/app/wisun/component/meter_collector_common/sl_wisun_coap_collector.c\n@@\
    \ -37,6 +37,7 @@\n #include \"sl_status.h\"\n #include \"sl_wisun_meter_collector_config.h\"\
    \n #include \"sl_wisun_collector.h\"\n+#include \"sl_wisun_trace_util.h\"\n \n\
    \ // -----------------------------------------------------------------------------\n\
    \ //                              Macros and Typedefs\n@@ -134,20 +135,22 @@ sl_status_t\
    \ sl_wisun_coap_collector_prepare_request(const sl_wisun_request_type_\n   packet->uri_path_len\
    \     = strlen(SL_WISUN_COAP_METER_COLLECTOR_MEASUREMENT_URI_PATH);\n   packet->msg_code\
    \         = COAP_MSG_CODE_REQUEST_GET;\n   packet->content_format   = COAP_CT_TEXT_PLAIN;\n\
    -  packet->payload_len      = SL_WISUN_METER_REQUEST_TYPE_LENGTH;\n   packet->payload_ptr\
    \      = NULL;\n   packet->options_list_ptr = NULL;\n   packet->msg_id       \
    \    = SL_WISUN_COAP_METER_COLLECTOR_DEFAULT_MESSAGE_ID;\n \n   switch (req_type)\
    \ {\n     case SL_WISUN_MC_REQ_ASYNC:\n       packet->payload_ptr = (uint8_t *)\
    \ SL_WISUN_METER_REQUEST_TYPE_STR_ASYNC;\n+      packet->payload_len = strlen(SL_WISUN_METER_REQUEST_TYPE_STR_ASYNC);\n\
    \       break;\n     case SL_WISUN_MC_REQ_REGISTER:\n       packet->payload_ptr\
    \ = (uint8_t *) SL_WISUN_METER_REQUEST_TYPE_STR_REGISTER;\n+      packet->payload_len\
    \ = strlen(SL_WISUN_METER_REQUEST_TYPE_STR_REGISTER);\n       break;\n     case\
    \ SL_WISUN_MC_REQ_REMOVE:\n       packet->payload_ptr = (uint8_t *) SL_WISUN_METER_REQUEST_TYPE_STR_REMOVE;\n\
    +      packet->payload_len = strlen(SL_WISUN_METER_REQUEST_TYPE_STR_REMOVE);\n\
    \       break;\n     default:\n       break;"
  - "--- a/app/wisun/component/meter_collector_common/sl_wisun_coap_meter.c\n+++ b/app/wisun/component/meter_collector_common/sl_wisun_coap_meter.c\n\
    @@ -40,6 +40,11 @@\n #include \"sl_wisun_app_core.h\"\n #include \"sl_wisun_coap_rhnd.h\"\
    \n #include \"sli_wisun_coap_rd.h\"\n+#include \"sl_wisun_trace_util.h\"\n+\n\
    +#if !defined(SL_CATALOG_POWER_MANAGER_PRESENT)\n+  #include \"sl_wisun_led_driver.h\"\
    \n+#endif\n \n #if defined(SL_CATALOG_TEMP_SENSOR_PRESENT)\n   #include \"sl_wisun_rht_measurement.h\"\
    \n@@ -151,6 +156,7 @@ static const char *_meter_packet2json(const sl_wisun_meter_packet_t\
    \ * const pack\n static sl_wisun_coap_packet_t *_prepare_measurement_resp(const\
    \ sl_wisun_coap_packet_t * const req_packet,\n                               \
    \                           const measurement_type_t measurement);\n \n+#if !defined(SL_CATALOG_POWER_MANAGER_PRESENT)\n\
    \ /**************************************************************************//**\n\
    \  * @brief Convert LED ID.\n  * @details Helper function to convert uint8_t LED\
    \ ID to sl_wisun_led_id_t\n@@ -159,6 +165,7 @@ static sl_wisun_coap_packet_t *_prepare_measurement_resp(const\
    \ sl_wisun_coap_pac\n  *****************************************************************************/\n\
    \ static sl_wisun_led_id_t _coap_meter_convert_led_id(const uint8_t led_id);\n\
    \ #endif\n+#endif\n \n // -----------------------------------------------------------------------------\n\
    \ //                                Global Variables\n@@ -190,6 +197,9 @@ static\
    \ sl_wisun_coap_packet_t dummy_req_pkt = {\n // -----------------------------------------------------------------------------\n\
    \ void sl_wisun_coap_meter_init(void)\n {\n+  // init meter for having proper\
    \ meter content\n+  sl_wisun_meter_init();\n+\n   // Init meter-collector common\
    \ component\n #if !defined(SL_CATALOG_TEMP_SENSOR_PRESENT)\n   sl_wisun_meter_set_initializer(&_coap_meter_hnd,\
    \ NULL);\n@@ -228,6 +238,7 @@ sl_wisun_coap_packet_t *sl_wisun_coap_meter_light_response_cb(const\
    \ sl_wisun_coa\n   return _prepare_measurement_resp(req_packet, COAP_METER_MEASUREMENT_LIGHT);\n\
    \ }\n \n+#if !defined(SL_CATALOG_POWER_MANAGER_PRESENT)\n sl_wisun_coap_packet_t\
    \ *sl_wisun_coap_meter_led_toggle_response_cb(const sl_wisun_coap_packet_t * const\
    \ req_packet)\n {\n   sl_wisun_coap_packet_t *resp_packet = NULL;\n@@ -256,6 +267,7\
    \ @@ sl_wisun_coap_packet_t *sl_wisun_coap_meter_led_toggle_response_cb(const\
    \ sl_wisu\n   return resp_packet;\n }\n #endif\n+#endif\n \n // -----------------------------------------------------------------------------\n\
    \ //                          Static Function Definitions\n@@ -331,7 +343,7 @@\
    \ static sl_status_t _coap_meter_build_packets(const sl_wisun_request_type_t req,\n\
    \                                              uint32_t * const len)\n {\n   sl_wisun_coap_packet_t\
    \ *packet                  = NULL;\n-  static current_addr_t addresses       \
    \          = { 0 };\n+  static sl_wisun_app_core_current_addr_t addresses    \
    \             = { 0 };\n   const char *ip_str_global                       = NULL;\n\
    \   uint16_t payload_len                            = 0U;\n   static char payload[JSON_MEASUREMENT_DATA_SIZE]\
    \ = { 0 };\n@@ -374,7 +386,7 @@ static sl_status_t _coap_meter_build_packets(const\
    \ sl_wisun_request_type_t req,\n     packet->msg_id            = SL_WISUN_COAP_METER_COLLECTOR_DEFAULT_MESSAGE_ID;\n\
    \     packet->msg_type          = COAP_MSG_TYPE_NON_CONFIRMABLE;\n \n-    app_wisun_get_current_addresses(&addresses);\n\
    +    sl_wisun_app_core_get_current_addresses(&addresses);\n     ip_str_global\
    \ = app_wisun_trace_util_get_ip_str(&addresses.global);\n \n     // Build payload\n\
    @@ -434,7 +446,7 @@ static sl_wisun_coap_packet_t *_prepare_measurement_resp(const\
    \ sl_wisun_coap_pac\n   sl_wisun_coap_packet_t * resp_packet  = NULL;\n   sn_coap_content_format_e\
    \ ct_format    = COAP_CT_JSON;\n   size_t max_content_size               = 0U;\n\
    -  static current_addr_t addresses       = { 0 };\n+  static sl_wisun_app_core_current_addr_t\
    \ addresses       = { 0 };\n   const char *ip_str_global             = NULL;\n\
    \   char *content                         = NULL;\n   static sl_wisun_meter_packet_t\
    \ packet = { 0 };\n@@ -450,7 +462,7 @@ static sl_wisun_coap_packet_t *_prepare_measurement_resp(const\
    \ sl_wisun_coap_pac\n     max_content_size = JSON_MEASUREMENT_DATA_SIZE;\n \n\
    \     // Get IP address\n-    app_wisun_get_current_addresses(&addresses);\n+\
    \    sl_wisun_app_core_get_current_addresses(&addresses);\n     ip_str_global\
    \ = app_wisun_trace_util_get_ip_str(&addresses.global);\n   } else {\n     ct_format\
    \ = COAP_CT_TEXT_PLAIN;"
  - "--- a/app/wisun/component/meter_collector_common/sl_wisun_collector.c\n+++ b/app/wisun/component/meter_collector_common/sl_wisun_collector.c\n\
    @@ -195,23 +195,28 @@ void sl_wisun_collector_init(void)\n   // init collector-meter\
    \ token\n   sl_wisun_mc_init_token(SL_WISUN_METER_COLLECTOR_TOKEN);\n \n-  req.length\
    \ = SL_WISUN_METER_REQUEST_TYPE_LENGTH\n-               + 1U\n-              \
    \ + sl_wisun_mc_get_token_size();\n-\n-  req.buff = (uint8_t *) SL_WISUN_METER_REQUEST_TYPE_STR_ASYNC\
    \ \\\n-             SL_WISUN_METER_REQUEST_DELIMITER                  \\\n-  \
    \           SL_WISUN_METER_COLLECTOR_TOKEN;\n+  req.length  = strlen(SL_WISUN_METER_REQUEST_TYPE_STR_ASYNC)\n\
    +                + 1U\n+                + sl_wisun_mc_get_token_size();\n+  req.buff\
    \    = (uint8_t *) SL_WISUN_METER_REQUEST_TYPE_STR_ASYNC \\\n+               \
    \ SL_WISUN_METER_REQUEST_DELIMITER                  \\\n+                SL_WISUN_METER_COLLECTOR_TOKEN;\n\
    \   sl_wisun_collector_set_async_measurement_request(&req);\n \n-  req.buff =\
    \ (uint8_t *) SL_WISUN_METER_REQUEST_TYPE_STR_REGISTER \\\n-             SL_WISUN_METER_REQUEST_DELIMITER\
    \                     \\\n-             SL_WISUN_METER_COLLECTOR_TOKEN;\n+  req.length\
    \  = strlen(SL_WISUN_METER_REQUEST_TYPE_STR_REGISTER)\n+                + 1U\n\
    +                + sl_wisun_mc_get_token_size();\n+  req.buff    = (uint8_t *)\
    \ SL_WISUN_METER_REQUEST_TYPE_STR_REGISTER \\\n+                SL_WISUN_METER_REQUEST_DELIMITER\
    \                     \\\n+                SL_WISUN_METER_COLLECTOR_TOKEN;\n \
    \  sl_wisun_collector_set_registration_request(&req);\n \n-  req.buff = (uint8_t\
    \ *) SL_WISUN_METER_REQUEST_TYPE_STR_REMOVE \\\n-             SL_WISUN_METER_REQUEST_DELIMITER\
    \                   \\\n-             SL_WISUN_METER_COLLECTOR_TOKEN;\n+  req.length\
    \  = strlen(SL_WISUN_METER_REQUEST_TYPE_STR_REMOVE)\n+                + 1U\n+\
    \                + sl_wisun_mc_get_token_size();\n+  req.buff    = (uint8_t *)\
    \ SL_WISUN_METER_REQUEST_TYPE_STR_REMOVE \\\n+                SL_WISUN_METER_REQUEST_DELIMITER\
    \                   \\\n+                SL_WISUN_METER_COLLECTOR_TOKEN;\n   sl_wisun_collector_set_removal_request(&req);\n\
    \ }\n \n@@ -485,7 +490,7 @@ static void _create_common_socket(void)\n   static\
    \ sockaddr_in6_t collector_addr  = { 0 };\n   int32_t res                    \
    \     = SOCKET_INVALID_ID;\n \n-  _common_socket = socket(AF_INET6, (SOCK_DGRAM\
    \ | SOCK_NONBLOCK), IPPROTO_UDP);\n+  _common_socket = socket(AF_INET6, SOCK_DGRAM\
    \ | SOCK_NONBLOCK, IPPROTO_UDP);\n   assert(_common_socket != SOCKET_INVALID_ID);\n\
    \ \n   collector_addr.sin6_family = AF_INET6;\n@@ -631,7 +636,7 @@ static void\
    \ _collector_recv_thread_fnc(void *args)\n   _create_common_socket();\n \n   SL_WISUN_THREAD_LOOP\
    \ {\n-    if (!app_wisun_network_is_connected()) {\n+    if (!sl_wisun_app_core_util_network_is_connected())\
    \ {\n       osDelay(1000);\n       continue;\n     }\n@@ -646,7 +651,7 @@ static\
    \ void _collector_recv_thread_fnc(void *args)\n                              \
    \      &packet_data_len);\n \n     if (res != SL_STATUS_OK) {\n-      app_wisun_dispatch_thread();\n\
    +      sl_wisun_app_core_util_dispatch_thread();\n       continue;\n     }\n \n\
    @@ -655,7 +660,7 @@ static void _collector_recv_thread_fnc(void *args)\n     \
    \                             &remote_addr);\n \n     if (meter == NULL) {\n-\
    \      app_wisun_dispatch_thread();\n+      sl_wisun_app_core_util_dispatch_thread();\n\
    \       continue;\n     }\n \n@@ -666,7 +671,7 @@ static void _collector_recv_thread_fnc(void\
    \ *args)\n       printf(\"[Response time: %ldms]\\n\", response_time_ms);\n  \
    \     sl_mempool_free(&_async_meters_mempool, meter);\n     }\n-    app_wisun_dispatch_thread();\n\
    +    sl_wisun_app_core_util_dispatch_thread();\n   }\n }\n "
  - "--- a/app/wisun/component/meter_collector_common/sl_wisun_meter.c\n+++ b/app/wisun/component/meter_collector_common/sl_wisun_meter.c\n\
    @@ -59,25 +59,26 @@\n #define SL_WISUN_LFN_WAKE_UP_EVT_MSK                   \
    \                 0x0001U\n \n /// Macro for dispatching the thread if the given\
    \ result is not SL_STATUS_OK\n-#define sl_wisun_check_result_and_dispatch_if_nok(__res,\
    \ __socket, __storage) \\\n-  if (__res != SL_STATUS_OK) {                   \
    \                             \\\n-    sl_wisun_meter_error_handler(__res, __socket,\
    \ __storage);                 \\\n-    app_wisun_dispatch_thread();          \
    \                                    \\\n-    continue;                      \
    \                                           \\\n-  }\n+#if defined(SL_CATALOG_WISUN_LFN_DEVICE_SUPPORT_PRESENT)\n\
    +#define sl_wisun_check_result_and_dispatch_if_nok(__res, __socket, __storage)\
    \   \\\n+  if (__res != SL_STATUS_OK) {                                      \
    \            \\\n+    sl_wisun_meter_error_handler(__res, __socket, __storage);\
    \                   \\\n+    continue;                                       \
    \                            \\\n+  }                                        \
    \                                   \n+#else\n+#define sl_wisun_check_result_and_dispatch_if_nok(__res,\
    \ __socket, __storage)   \\\n+  if (__res != SL_STATUS_OK) {                 \
    \                                 \\\n+    sl_wisun_meter_error_handler(__res,\
    \ __socket, __storage);                   \\\n+    sl_wisun_app_core_util_dispatch_thread();\
    \                                   \\\n+    continue;                       \
    \                                            \\\n+  }                        \
    \                                                   \n+#endif\n \n // -----------------------------------------------------------------------------\n\
    \ //                          Static Function Declarations\n // -----------------------------------------------------------------------------\n\
    \ \n #if SL_WISUN_COAP_MC_OPTIMIZED_MODE_ENABLE\n-/**************************************************************************//**\n\
    - * @brief LFN Wake up meter event handler\n- * @details Custom callback implementation.\n\
    - *          It sets an OS status flag to notify meter task\n- * @param[in] evt\
    \ Event descriptor\n- *****************************************************************************/\n\
    -static void _wisun_lfn_wake_up_meter_hnd(sl_wisun_evt_t *evt);\n \n /**************************************************************************//**\n\
    \  * @brief Meter parse\n@@ -269,16 +270,8 @@ static sl_wisun_meter_packet_storage_t\
    \ _packet_storage  = {\n   .stored = 0U\n };\n \n-/// LFN wake up event flag\n\
    -static osEventFlagsId_t _lfn_wake_up_evt = NULL;\n+static uint8_t _lfn_evt_notify_ch\
    \ = 0UL;\n \n-/// LFN wake up event flag attributes\n-static const osEventFlagsAttr_t\
    \ _evt_attr = {\n-  .name      = \"LfnWakeUpEvt\",\n-  .attr_bits = 0,\n-  .cb_mem\
    \    = NULL,\n-  .cb_size   = 0\n-};\n #endif\n \n // -----------------------------------------------------------------------------\n\
    @@ -357,14 +350,10 @@ void sl_wisun_meter_init(void)\n #endif\n   sl_wisun_meter_init_common_resources(_meter_parse_request,\n\
    \                                        _meter_build_packets);\n-\n-  // Register\
    \ LFN wake up event callback for meter\n-  app_wisun_em_custom_callback_register(SL_WISUN_MSG_LFN_WAKE_UP_IND_ID,\n\
    -                                        _wisun_lfn_wake_up_meter_hnd);\n-  //\
    \ Create lfn wake up event flag\n #if defined(SL_CATALOG_WISUN_LFN_DEVICE_SUPPORT_PRESENT)\n\
    -  _lfn_wake_up_evt = osEventFlagsNew(&_evt_attr);\n-  assert(_lfn_wake_up_evt\
    \ != NULL);\n+  assert( app_wisun_em_subscribe_evt_notification(SL_WISUN_MSG_LFN_WAKE_UP_IND_ID,\
    \ &_lfn_evt_notify_ch) \n+          != SL_STATUS_FAIL);\n+\n #endif\n }\n \n@@\
    \ -501,8 +490,8 @@ void sl_wisun_meter_process(void)\n \n   // Get the device\
    \ schedule\n #if defined(SL_CATALOG_WISUN_LFN_DEVICE_SUPPORT_PRESENT)\n-  device_type\
    \ = app_wisun_get_device_type();\n-  lfn_params = app_wisun_get_lfn_params();\n\
    +  device_type = sl_wisun_app_core_get_device_type();\n+  lfn_params = sl_wisun_app_core_get_lfn_params();\n\
    \   if (lfn_params != NULL) {\n     schedule = lfn_params->data_layer.unicast_interval_ms;\n\
    \   } else {\n@@ -518,10 +507,7 @@ void sl_wisun_meter_process(void)\n   SL_WISUN_THREAD_LOOP\
    \ {\n #if defined(SL_CATALOG_WISUN_LFN_DEVICE_SUPPORT_PRESENT)\n     if (device_type\
    \ == SL_WISUN_LFN) {\n-      osEventFlagsWait(_lfn_wake_up_evt,\n-           \
    \            SL_WISUN_LFN_WAKE_UP_EVT_MSK,\n-                       osFlagsWaitAny,\n\
    -                       osWaitForever);\n+      app_wisun_em_wait_evt_notification(SL_WISUN_MSG_LFN_WAKE_UP_IND_ID,\
    \ _lfn_evt_notify_ch);\n     }\n #endif\n     // Read data from socket buffer\n\
    @@ -545,9 +531,9 @@ void sl_wisun_meter_process(void)\n     res = _sl_wisun_meter_sending_cycle();\n\
    \     sl_wisun_check_result_and_dispatch_if_nok(res, _common_socket, &_packet_storage);\n\
    \ \n-#if defined(SL_CATALOG_WISUN_LFN_DEVICE_SUPPORT_PRESENT)\n+#if !defined(SL_CATALOG_WISUN_LFN_DEVICE_SUPPORT_PRESENT)\n\
    \     // dispatch thread\n-    app_wisun_dispatch_thread();\n+    sl_wisun_app_core_util_dispatch_thread();\n\
    \ #endif\n   }\n }\n@@ -558,11 +544,6 @@ void sl_wisun_meter_process(void)\n //\
    \ -----------------------------------------------------------------------------\n\
    \ \n #if SL_WISUN_COAP_MC_OPTIMIZED_MODE_ENABLE\n-static void _wisun_lfn_wake_up_meter_hnd(sl_wisun_evt_t\
    \ *evt)\n-{\n-  (void) evt;\n-  (void) osEventFlagsSet(_lfn_wake_up_evt, SL_WISUN_LFN_WAKE_UP_EVT_MSK);\n\
    -}\n \n static sl_status_t _meter_parse_request(const void * const raw,\n    \
    \                                     int32_t packet_data_len,\n@@ -692,7 +673,7\
    \ @@ static void _create_common_socket(void)\n   static sockaddr_in6_t meter_addr\
    \  = { 0 };\n   int32_t res                       = SOCKET_INVALID_ID;\n \n- \
    \ _common_socket = socket(AF_INET6, (SOCK_DGRAM | SOCK_NONBLOCK), IPPROTO_UDP);\n\
    +  _common_socket = socket(AF_INET6, SOCK_DGRAM | SOCK_NONBLOCK, IPPROTO_UDP);\n\
    \   assert(_common_socket != SOCKET_INVALID_ID);\n \n   meter_addr.sin6_family\
    \  = AF_INET6;"
  - "--- a/app/wisun/component/meter_collector_common/sli_wisun_meter_collector.c\n\
    +++ b/app/wisun/component/meter_collector_common/sli_wisun_meter_collector.c\n\
    @@ -41,6 +41,7 @@\n #include \"sl_wisun_meter_collector_config.h\"\n #include\
    \ \"sl_wisun_app_core_util.h\"\n #include \"sl_sleeptimer.h\"\n+#include \"sl_wisun_trace_util.h\"\
    \n \n // -----------------------------------------------------------------------------\n\
    \ //                              Macros and Typedefs"
  - "--- a/app/wisun/component/network_measurement/sl_wisun_network_measurement.c\n\
    +++ b/app/wisun/component/network_measurement/sl_wisun_network_measurement.c\n\
    @@ -43,9 +43,11 @@\n #include \"sl_wisun_ping_config.h\"\n #include \"cmsis_os2.h\"\
    \n #include \"socket/socket.h\"\n+#include \"sl_wisun_trace_util.h\"\n \n #if\
    \ defined(SL_CATALOG_GUI_PRESENT)\n #include \"sl_wisun_network_measurement_gui.h\"\
    \n+#include \"sli_wisun_network_measurement_ping_gui.h\"\n #include \"sl_display.h\"\
    \n #include \"sl_gui.h\"\n #endif"
  - "--- a/app/wisun/component/network_measurement/sl_wisun_network_measurement_gui.c\n\
    +++ b/app/wisun/component/network_measurement/sl_wisun_network_measurement_gui.c\n\
    @@ -48,6 +48,7 @@\n #include \"sl_wisun_network_measurement_config.h\"\n #include\
    \ \"sl_display.h\"\n #include \"sl_gui.h\"\n+#include \"sl_string.h\"\n #include\
    \ \"socket/socket.h\"\n #include \"sl_wisun_ping.h\"\n #include \"silabs_wisun_logo.h\"\
    \n@@ -56,6 +57,9 @@\n //                              Macros and Typedefs\n //\
    \ -----------------------------------------------------------------------------\n\
    \ \n+// LCD 1 line string length\n+#define LCD_STRING_LINE_LEN             (21)\n\
    +\n /// Internal string buffer size\n #define STR_BUFF_SIZE                  \
    \ (512U)\n \n@@ -170,7 +174,7 @@ typedef struct sl_wisun_nwm_setting {\n /// Node\
    \ info structure type definition\n typedef struct node_info {\n   /// Addresses\n\
    -  current_addr_t addresses;\n+  sl_wisun_app_core_current_addr_t addresses;\n\
    \   /// Settings\n   app_setting_wisun_t settings;\n } node_info_t;\n@@ -222,15\
    \ +226,25 @@ static sl_wisun_nwm_node_stat_t _children_stat[SL_WISUN_MAX_CHILDREN_COUNT];\n\
    \ void sli_wisun_nwm_logo_form(void *args)\n {\n   sl_wisun_nwm_logo_form_args_t\
    \ *logo_form_args = (sl_wisun_nwm_logo_form_args_t *)args;\n-  static char buff[4U]\
    \ = { 0 };\n+  static char buff[LCD_STRING_LINE_LEN] = { 0 };\n+  uint32_t str_len\
    \ = 0UL;\n \n   sl_display_draw_bitmap(0, 0,\n                          SILABS_WISUN_LOGO_WIDTH,\n\
    \                          SILABS_WISUN_LOGO_HEIGHT,\n                       \
    \   silabs_wisun_logo_bits);\n-  sl_display_draw_string_on_line(logo_form_args->network_name,\
    \ 2, GLIB_ALIGN_CENTER, 0, 0, false);\n+\n+  str_len = sl_strnlen((char *)logo_form_args->network_name,\
    \ 32UL);\n+  snprintf(buff, LCD_STRING_LINE_LEN,\"%s\", logo_form_args->network_name);\n\
    +  sl_display_draw_string_on_line(buff, 2, GLIB_ALIGN_CENTER, 0, 0, false);\n\
    +\n+  if (str_len > LCD_STRING_LINE_LEN - 1) {\n+    snprintf(buff, LCD_STRING_LINE_LEN,\"\
    %s\", logo_form_args->network_name + LCD_STRING_LINE_LEN - 1);\n+    sl_display_draw_string_on_line(buff,\
    \ 3, GLIB_ALIGN_LEFT, 3, 0, false);\n+  }\n+\n   sl_display_draw_string_on_line(logo_form_args->join_state_str,\
    \ 10, GLIB_ALIGN_CENTER, 0, 0, false);\n-  snprintf(buff, 4U, \"(%ld)\", logo_form_args->join_state);\n\
    +  snprintf(buff, LCD_STRING_LINE_LEN, \"(%ld)\", logo_form_args->join_state);\n\
    \   sl_display_draw_string_on_line(buff, 11, GLIB_ALIGN_CENTER, 0, 0, false);\n\
    \ }\n \n@@ -360,8 +374,8 @@ static void _node_info_form(void *args)\n   const\
    \ char *ip_str_br        = NULL;\n   const char *ip_str_pp        = NULL;\n  \
    \ const char *ip_str_sp        = NULL;\n-  uint32_t tx_remaining_budget = 0UL;\
    \ // Hold the remaning TX budget if applicable\n-  bool valid                \
    \   = false; // Indicates if the remaining budget returned is a usable value.\n\
    +  uint32_t tx_remaining_budget = 0UL;            // Hold the remaning TX budget\
    \ if applicable\n+  sl_status_t valid            = SL_STATUS_FAIL; // Indicates\
    \ if the remaining budget returned is a usable value.\n \n   (void) args;\n \n\
    @@ -377,14 +391,14 @@ static void _node_info_form(void *args)\n   sl_gui_button_update(SL_GUI_BUTTON0);\n\
    \ \n   // getting IP addresses\n-  app_wisun_get_current_addresses(&node_info.addresses);\n\
    +  sl_wisun_app_core_get_current_addresses(&node_info.addresses);\n \n   // getting\
    \ settings\n   app_wisun_setting_get(&node_info.settings);\n \n   // get remanining\
    \ transmission budget if applicable\n-  if ( app_wisun_get_regulation_active()\
    \ == true ) {\n-    valid = app_wisun_get_remaining_tx_budget(&tx_remaining_budget);\n\
    +  if ( sl_wisun_app_core_get_regulation_active() == true ) {\n+    valid = sl_wisun_app_core_get_remaining_tx_budget(&tx_remaining_budget);\n\
    \   }\n \n   ip_str_global = app_wisun_trace_util_get_ip_str(&node_info.addresses.global);\n\
    @@ -408,8 +422,8 @@ static void _node_info_form(void *args)\n              ip_str_br,\n\
    \              ip_str_pp,\n              ip_str_sp,\n-             (valid ? tx_remaining_budget\
    \ : 0UL),\n-             (valid ? _tx_remaining_budget(tx_remaining_budget) :\
    \ TX_REMAINING_NOT_AVAILABLE_STR));\n+             (valid == SL_STATUS_OK ? tx_remaining_budget\
    \ : 0UL),\n+             (valid == SL_STATUS_OK ? _tx_remaining_budget(tx_remaining_budget)\
    \ : TX_REMAINING_NOT_AVAILABLE_STR));\n   } else if (node_info.settings.phy.type\
    \ == SL_WISUN_PHY_CONFIG_FAN11) {\n     snprintf(_str_buff, STR_BUFF_SIZE,\n \
    \             PRINT_FAN11_NODE_INFO_FORMAT_STR,\n@@ -426,8 +440,8 @@ static void\
    \ _node_info_form(void *args)\n              ip_str_br,\n              ip_str_pp,\n\
    \              ip_str_sp,\n-             (valid ? tx_remaining_budget : 0UL),\n\
    -             (valid ? _tx_remaining_budget(tx_remaining_budget) : TX_REMAINING_NOT_AVAILABLE_STR));\n\
    +             (valid == SL_STATUS_OK ? tx_remaining_budget : 0UL),\n+        \
    \     (valid == SL_STATUS_OK ? _tx_remaining_budget(tx_remaining_budget) : TX_REMAINING_NOT_AVAILABLE_STR));\n\
    \   } else {\n     snprintf(_str_buff, STR_BUFF_SIZE, \"Wrong phy profile: %lu\"\
    , node_info.settings.phy.type);\n   }\n@@ -443,6 +457,9 @@ static void _node_info_form(void\
    \ *args)\n \n static void _set_nbinfo_txtbox(void *args)\n {\n+  if (args == NULL)\
    \ {\n+    return;\n+  }\n   sl_wisun_nwm_node_stat_t *stat = (sl_wisun_nwm_node_stat_t\
    \ *) args;\n   const char *ip_str             = NULL;\n "
  - "--- a/app/wisun/component/network_measurement/sl_wisun_network_measurement_remote_ctrl.c\n\
    +++ b/app/wisun/component/network_measurement/sl_wisun_network_measurement_remote_ctrl.c\n\
    @@ -57,13 +57,17 @@\n // -----------------------------------------------------------------------------\n\
    \ \n /// Network Measurement Remote Control buffer size\n-#define SL_WISUN_NWM_REMOTE_CTRL_BUFF_SIZE\
    \                     2048UL\n+#define SL_WISUN_NWM_REMOTE_CTRL_BUFF_SIZE    \
    \             2048UL\n \n /// Remote CLI measurement max query length\n-#define\
    \ SL_WISUN_COAP_NWM_REMOTE_CLI_MAX_QUERY_LENGTH          (SL_WISUN_NWM_REMOTE_CTRL_BUFF_SIZE)\n\
    +#define SL_WISUN_NWM_REMOTE_CTRL_MAX_QUERY_LENGTH          (SL_WISUN_NWM_REMOTE_CTRL_BUFF_SIZE)\n\
    \ \n /// Remote CLI measurement max string length\n-#define SL_WISUN_COAP_NWM_REMOTE_CLI_MAX_ARG_STRING_LENGTH\
    \     128UL\n+#define SL_WISUN_NWM_REMOTE_CTRL_MAX_ARG_STRING_LENGTH     128UL\n\
    +\n+\n+/// Max stored neighbor count\n+#define SL_WISUN_NWM_REMOTE_CTRL_MAX_NB_COUNT\
    \              30UL\n \n /// Network Measurement Remote Control ping stat format\n\
    \ #define SL_WISUN_NWM_REMOTE_CTRL_PING_STAT_JSON_FORMAT \\\n@@ -91,35 +95,106\
    \ @@\n \\\"rsli\\\":%u\\\n },\\n\"\n \n-/// Network Measurement Remote Control\
    \ iperf help string\n-#define SL_WISUN_NWM_REMOTE_CTRL_IPERF_HELP_STRING \\\n\
    +/// Succeed str\n+#define SL_WISUN_NWM_REMOTE_CTRL_SUCCEED_STR              \
    \        \"succeed\"\n+/// Failed str\n+#define SL_WISUN_NWM_REMOTE_CTRL_FAILED_STR\
    \                       \"failed\"\n+/// Ping transaction result format str\n\
    +#define SL_WISUN_NWM_REMOTE_CTRL_PING_RESULT_FROMAT_STR           \"[COAP CLI\
    \ Ping transaction %s]\\n\"\n+/// iPerf transaction result format str\n+#define\
    \ SL_WISUN_NWM_REMOTE_CTRL_IPERF_RESULT_FROMAT_STR          \"[COAP CLI iPerf\
    \ transaction %s]\\n\"\n+/// Neighbor info transaction result format str\n+#define\
    \ SL_WISUN_NWM_REMOTE_CTRL_NBRINFO_RESULT_FROMAT_STR        \"[COAP CLI NeighborInfo\
    \ transaction %s]\\n\"\n+\n+/// Arg help str\n+#define SL_WISUN_NWM_REMOTE_CTRL_ARG_HELP_STR\
    \                     \"help\"\n+/// Arg all str\n+#define SL_WISUN_NWM_REMOTE_CTRL_ARG_ALL_NODE_STR\
    \                 \"all\"\n+/// Arg parent node str\n+#define SL_WISUN_NWM_REMOTE_CTRL_ARG_PARENT_NODE_STR\
    \              \"parent\"\n+/// Arg Br node str\n+#define SL_WISUN_NWM_REMOTE_CTRL_ARG_BR_NODE_STR\
    \                  \"br\"\n+/// Arg Custom node str\n+#define SL_WISUN_NWM_REMOTE_CTRL_ARG_CUSTOM_NODE_STR\
    \              \"Custom Node\"\n+/// Arg server str\n+#define SL_WISUN_NWM_REMOTE_CTRL_ARG_SERVER_STR\
    \                   \"server\"\n+/// Arg client str\n+#define SL_WISUN_NWM_REMOTE_CTRL_ARG_CLIENT_STR\
    \                   \"client\"\n+/// Arg get str\n+#define SL_WISUN_NWM_REMOTE_CTRL_ARG_GET_STR\
    \                      \"get\"\n+/// Arg json str\n+#define SL_WISUN_NWM_REMOTE_CTRL_ARG_JSON_STR\
    \                     \"json\"\n+/// Arg text str\n+#define SL_WISUN_NWM_REMOTE_CTRL_ARG_TEXT_STR\
    \                     \"text\"\n+/// Arg set str\n+#define SL_WISUN_NWM_REMOTE_CTRL_ARG_SET_STR\
    \                      \"set\"\n+/// Arg options bandwidth str\n+#define SL_WISUN_NWM_REMOTE_CTRL_ARG_OPTIONS_BW_STR\
    \               \"options.bandwidth\"\n+/// Arg options remote addr str\n+#define\
    \ SL_WISUN_NWM_REMOTE_CTRL_ARG_OPTIONS_REMOTE_ADDR_STR      \"options.remote_addr\"\
    \n+/// Arg options duration str\n+#define SL_WISUN_NWM_REMOTE_CTRL_ARG_OPTIONS_DURATION_STR\
    \         \"options.duration\"\n+/// Arg options interval str\n+#define SL_WISUN_NWM_REMOTE_CTRL_ARG_OPTIONS_INTERVAL_STR\
    \         \"options.interval\"\n+\n+/// Response no coap payload str\n+#define\
    \ SL_WISUN_NWM_REMOTE_CTRL_RESP_NO_COAP_PAYLOAD_STR         \"[No CoAP payload:\
    \ -e \\\"<cli command>\\\"]\"\n+/// Response not enough argument str\n+#define\
    \ SL_WISUN_NWM_REMOTE_CTRL_RESP_NOT_ENOUGH_ARG_STR          \"[Not enough argument]\"\
    \n+/// Response ping help str\n+#define SL_WISUN_NWM_REMOTE_CTRL_RESP_PING_HELP_STR\
    \               \"[Ping CLI help: measure <packet_count> <packet_size> <address>]\"\
    \n+/// Response IP not valid str\n+#define SL_WISUN_NWM_REMOTE_CTRL_RESP_IP_NOT_VALID_STR\
    \            \"[IP address is not set or not valid]\"\n+/// Response invalid result\
    \ type str\n+#define SL_WISUN_NWM_REMOTE_CTRL_RESP_INVALID_RES_TYPE_STR      \
    \  \"[Invalid result type]\"\n+/// Response buffer error str\n+#define SL_WISUN_NWM_REMOTE_CTRL_RESP_BUFF_ERROR_STR\
    \              \"[Buffer error]\"\n+/// Response unknown cli command str\n+#define\
    \ SL_WISUN_NWM_REMOTE_CTRL_RESP_UNKNOWN_CLI_STR             \"[Unknown cli command]\"\
    \n+/// Response test queue failed str\n+#define SL_WISUN_NWM_REMOTE_CTRL_RESP_TEST_QUEUE_FAILED_STR\
    \       \"[Adding test to queue failed]\"\n+/// Response iPerf server started\
    \ str\n+#define SL_WISUN_NWM_REMOTE_CTRL_RESP_IPERF_SRV_STARTED           \"[iPerf\
    \ server started]\"\n+/// Response iPerf client started str\n+#define SL_WISUN_NWM_REMOTE_CTRL_RESP_IPERF_CLNT_STARTED\
    \          \"[iPerf client started]\"\n+/// Response iPerf set successfully str\n\
    +#define SL_WISUN_NWM_REMOTE_CTRL_RESP_IPERF_SET_SUCCEED           \"[iPerf parameter\
    \ is set succesfully]\"\n+/// Response iPerf set failed str\n+#define SL_WISUN_NWM_REMOTE_CTRL_RESP_IPERF_SET_FAILED\
    \            \"[iPerf parameter setting is failed]\"\n+/// Response iperf help\
    \ str\n+#define SL_WISUN_NWM_REMOTE_CTRL_RESP_IPERF_HELP_STR \\\n   \"\\niPerf\
    \ Remote Control CLI Help.\\n\\n\\\n   Writable options:\\n\\\n-    -options.remote_addr\\\
    n\\\n-    -options.bandwidth\\n\\\n-    -options.duration\\n\\\n-    -options.interval\\\
    n\\\n+    - remote_addr\\n\\\n+    - bandwidth\\n\\\n+    - duration\\n\\\n+ \
    \   - interval\\n\\\n   Example: iperf set options.bandwidth 10000\\n\\n\\\n-\
    \  Start iPerf command: iperf <client|server>\\n\"\n+  Start iPerf command: iperf\
    \ <client|server>\\n\\n\\\n+  Get iPerf results: iperf get <text|json>\\n\"\n\
    \ \n /// Remote CLI measurement print target type\n-typedef enum buffer_target_type\
    \ {\n+typedef enum sl_wisun_nwm_remote_ctrl_buf_target {\n   /// Nothing measurement\n\
    -  BUFFER_TYPE_NONE = -1,\n+  SL_WISUN_NWM_REMOTE_CTRL_BUF_TARGET_NONE = -1,\n\
    \   /// Only Border Router measurement\n-  BUFFER_TYPE_BORDER_ROUTER,\n+  SL_WISUN_NWM_REMOTE_CTRL_BUF_TARGET_BORDER_ROUTER,\n\
    \   /// Only Primary Parent measurement\n-  BUFFER_TYPE_PARENT,\n+  SL_WISUN_NWM_REMOTE_CTRL_BUF_TARGET_PARENT,\n\
    \   /// Measure all of available nodes\n-  BUFFER_TYPE_ALL,\n+  SL_WISUN_NWM_REMOTE_CTRL_BUF_TARGET_ALL,\n\
    \   /// Measure single node\n-  BUFFER_TYPE_SINGLE,\n-  // Measure iPerf\n-  BUFFER_TYPE_IPERF\n\
    -} buffer_target_type_t;\n-\n-// Remote CLI measurement command structure\n-typedef\
    \ struct ctrl_cmd_type {\n+  SL_WISUN_NWM_REMOTE_CTRL_BUF_TARGET_SINGLE,\n+  //\
    \ Measurement iPerf json format\n+  SL_WISUN_NWM_REMOTE_CTRL_BUF_TARGET_IPERF_JSON,\n\
    +  // Measurement iPerf text format\n+  SL_WISUN_NWM_REMOTE_CTRL_BUF_TARGET_IPERF_TEXT,\n\
    +  // Neighbor info buff type\n+  SL_WISUN_NWM_REMOTE_CTRL_BUF_TARGET_NBINF\n\
    +} sl_wisun_nwm_remote_ctrl_buf_target_t;\n+\n+/// Remote CLI measurement command\
    \ structure\n+typedef struct sl_wisun_nwm_remote_ctrl_cmd {\n   /// Nothing measurement\n\
    \   char* identifier;\n   /// Argument1 string\n@@ -128,7 +203,85 @@ typedef struct\
    \ ctrl_cmd_type {\n   char* arg2;\n   /// Argument3 string\n   char* arg3;\n-}\
    \ ctrl_cmd_type_t;\n+} sl_wisun_nwm_remote_ctrl_cmd_t;\n+\n+/// Remote CLI response\n\
    +typedef struct sl_wisun_nwm_remote_ctrl_resp {\n+  /// message code\n+  sn_coap_msg_code_e\
    \ msg_code;\n+  /// payload constant str ptr\n+  const char *payload;\n+} sl_wisun_nwm_remote_ctrl_resp_t;\n\
    +\n+/// Response no coap payload\n+static const sl_wisun_nwm_remote_ctrl_resp_t\
    \ _resp_no_coap_payload = {\n+  .payload = SL_WISUN_NWM_REMOTE_CTRL_RESP_NO_COAP_PAYLOAD_STR,\
    \ \n+  .msg_code= COAP_MSG_CODE_RESPONSE_NOT_ACCEPTABLE\n+};\n+/// Response not\
    \ enough argument\n+static const sl_wisun_nwm_remote_ctrl_resp_t _resp_not_enough_arg\
    \ = {\n+  .payload = SL_WISUN_NWM_REMOTE_CTRL_RESP_NOT_ENOUGH_ARG_STR, \n+  .msg_code=\
    \ COAP_MSG_CODE_RESPONSE_NOT_ACCEPTABLE\n+};\n+/// Response ping help\n+static\
    \ const sl_wisun_nwm_remote_ctrl_resp_t _resp_ping_help = {\n+  .payload = SL_WISUN_NWM_REMOTE_CTRL_RESP_PING_HELP_STR,\n\
    +  .msg_code= COAP_MSG_CODE_RESPONSE_CONTENT\n+};\n+/// Response IP not valid\n\
    +static const sl_wisun_nwm_remote_ctrl_resp_t _resp_ip_not_valid = {\n+  .payload\
    \ = SL_WISUN_NWM_REMOTE_CTRL_RESP_IP_NOT_VALID_STR,\n+  .msg_code= COAP_MSG_CODE_RESPONSE_NOT_ACCEPTABLE\n\
    +};\n+/// Response invalid result type\n+static const sl_wisun_nwm_remote_ctrl_resp_t\
    \ _resp_invalid_res_type = {\n+  .payload = SL_WISUN_NWM_REMOTE_CTRL_RESP_INVALID_RES_TYPE_STR,\n\
    +  .msg_code= COAP_MSG_CODE_RESPONSE_NOT_ACCEPTABLE\n+};\n+/// Response buffer\
    \ error\n+static const sl_wisun_nwm_remote_ctrl_resp_t _resp_buff_error = {\n\
    +  .payload = SL_WISUN_NWM_REMOTE_CTRL_RESP_BUFF_ERROR_STR,\n+  .msg_code= COAP_MSG_CODE_RESPONSE_NOT_ACCEPTABLE\n\
    +};\n+/// Response unknown cli command\n+static const sl_wisun_nwm_remote_ctrl_resp_t\
    \ _resp_unknown_cli = {\n+  .payload = SL_WISUN_NWM_REMOTE_CTRL_RESP_UNKNOWN_CLI_STR,\n\
    +  .msg_code= COAP_MSG_CODE_RESPONSE_NOT_ACCEPTABLE\n+};\n+/// Response test queue\
    \ faled\n+static const sl_wisun_nwm_remote_ctrl_resp_t _resp_test_queue_failed\
    \ = {\n+  .payload = SL_WISUN_NWM_REMOTE_CTRL_RESP_TEST_QUEUE_FAILED_STR,\n+ \
    \ .msg_code= COAP_MSG_CODE_RESPONSE_NOT_ACCEPTABLE\n+};\n+/// Response iPerf server\
    \ started\n+static const sl_wisun_nwm_remote_ctrl_resp_t _resp_iperf_srv_started\
    \ = {\n+  .payload = SL_WISUN_NWM_REMOTE_CTRL_RESP_IPERF_SRV_STARTED,\n+  .msg_code=\
    \ COAP_MSG_CODE_RESPONSE_CONTENT\n+};\n+/// Response iPerf client started\n+static\
    \ const sl_wisun_nwm_remote_ctrl_resp_t _resp_iperf_clnt_started = {\n+  .payload\
    \ = SL_WISUN_NWM_REMOTE_CTRL_RESP_IPERF_CLNT_STARTED,\n+  .msg_code= COAP_MSG_CODE_RESPONSE_CONTENT\n\
    +};\n+\n+/// Response iPerf set successfully\n+static const sl_wisun_nwm_remote_ctrl_resp_t\
    \ _resp_iperf_set_succeed = {\n+  .payload = SL_WISUN_NWM_REMOTE_CTRL_RESP_IPERF_SET_SUCCEED,\n\
    +  .msg_code= COAP_MSG_CODE_RESPONSE_CHANGED\n+};\n+\n+/// Response iPerf set\
    \ failed\n+static const sl_wisun_nwm_remote_ctrl_resp_t _resp_iperf_set_failed\
    \ = {\n+  .payload = SL_WISUN_NWM_REMOTE_CTRL_RESP_IPERF_SET_FAILED,\n+  .msg_code=\
    \ COAP_MSG_CODE_RESPONSE_NOT_ACCEPTABLE\n+};\n+\n+/// Response iperf help\n+static\
    \ const sl_wisun_nwm_remote_ctrl_resp_t _resp_iperf_help = {\n+  .payload = SL_WISUN_NWM_REMOTE_CTRL_RESP_IPERF_HELP_STR,\n\
    +  .msg_code= COAP_MSG_CODE_RESPONSE_CONTENT\n+};\n+\n // -----------------------------------------------------------------------------\n\
    \ //                          Static Function Declarations\n // -----------------------------------------------------------------------------\n\
    @@ -142,48 +295,86 @@ typedef struct ctrl_cmd_type {\n  * @return Payload buffer\
    \ position after print.\n  *****************************************************************************/\n\
    \ static void _parse_stat_to_json(char **payload_pos,\n-                     \
    \           sl_wisun_nwm_node_stat_t *stat,\n-                               \
    \ int16_t *payload_len);\n+                                const sl_wisun_nwm_node_stat_t\
    \ * const stat,\n+                                uint16_t * const payload_len);\n\
    \ \n /**************************************************************************//**\n\
    - * @brief Build and send CoAP response packet.\n- * @details Build and send CoAP\
    \ response packet.\n- * @param[in] sockid Socket id.\n- * @param[in] clnt_addr\
    \ Client address.\n- * @param[in,out] packet CoAP packet.\n- * @param[in] target\
    \ Measurement print target.\n- * @return SL_STATUS_OK on success, otherwise an\
    \ error code.\n+ * @brief Build payload and CoAP packet\n+ * @details Helper function\n\
    + * @param[in] req_packet Request packet\n+ * @param[in] target Measurement print\
    \ target\n+ * @return sl_wisun_coap_packet_t * Built CoAP packet on success, otherwise\
    \ NULL\n+ *****************************************************************************/\n\
    +static sl_wisun_coap_packet_t *  _build_response(const sl_wisun_coap_packet_t\
    \ * const req_packet,\n+                                                 const\
    \ sl_wisun_nwm_remote_ctrl_buf_target_t target);\n+\n+\n+/**************************************************************************//**\n\
    + * @brief Build iPerf result in json and plain text format\n+ * @details Helper\
    \ function\n+ * @param[in] target Measurement print target\n+ * @param[in,out]\
    \ payload_buff Payload buffer pointer\n+ * @return char * Payload for CoAP packet\
    \ on success, otherwise NULL\n+ *****************************************************************************/\n\
    +static char * _build_iperf_result(const sl_wisun_nwm_remote_ctrl_buf_target_t\
    \ target,\n+                                  char * const payload_buff);\n+\n\
    +/**************************************************************************//**\n\
    + * @brief Build neighbor info string\n+ * @details Helper function\n+ * @param[in,out]\
    \ payload_buff Payload buffer pointer\n+ * @param[in,out] nodes Node storage ptr\n\
    + * @param[in,out] br_stat Border router statistic ptr\n+ * @param[in,out] pp_stat\
    \ Primary parent statistic ptr\n+ * @param[in,out] children_stats Children statistic\
    \ array\n+ * @return char * Payload for CoAP packet on success, otherwise NULL\n\
    + *****************************************************************************/\n\
    +static char * _build_nbr_info(char * const payload_buff,\n+                 \
    \             sl_wisun_nwm_measurable_node_t * const nodes,\n+               \
    \               sl_wisun_nwm_node_stat_t * const br_stat,\n+                 \
    \             sl_wisun_nwm_node_stat_t * const pp_stat,\n+                   \
    \           sl_wisun_nwm_node_stat_t * const children_stats);\n+\n+/**************************************************************************//**\n\
    + * @brief Build neighbor info string\n+ * @details Helper function\n+ * @param[in]\
    \ target Measurement print target\n+ * @param[in,out] payload_buff Payload buffer\
    \ pointer\n+ * @param[in,out] br_stat Border router statistic ptr\n+ * @param[in,out]\
    \ pp_stat Primary parent statistic ptr\n+ * @param[in,out] children_stats Children\
    \ statistic array\n+ * @return char * Payload for CoAP packet on success, otherwise\
    \ NULL\n  *****************************************************************************/\n\
    -static sl_wisun_coap_packet_t *  _build_send_output(const sl_wisun_coap_packet_t\
    \ * const req_packet,\n-                                                    buffer_target_type_t\
    \ target);\n+static char * _build_ping_meas_stat(const sl_wisun_nwm_remote_ctrl_buf_target_t\
    \ target,\n+                                    char * const payload_buff,\n+\
    \                                    sl_wisun_nwm_node_stat_t * const br_stat,\n\
    +                                    sl_wisun_nwm_node_stat_t * const pp_stat,\n\
    +                                    sl_wisun_nwm_node_stat_t * const children_stats);\n\
    \ \n /**************************************************************************//**\n\
    \  * @brief Build payload for CoAP response packet.\n  * @details Build payload\
    \ for CoAP response packet.\n- * @param[in, out] payload_len CoAP packet payload\
    \ length.\n  * @param[in] target Measurement print target.\n- * @return SL_STATUS_OK\
    \ on success, otherwise an error code.\n+ * @return char * built payload on success,\
    \ otherwise NULL\n  *****************************************************************************/\n\
    -static sl_status_t _build_payload(buffer_target_type_t target);\n+static char\
    \ * _build_payload(sl_wisun_nwm_remote_ctrl_buf_target_t target);\n \n /**************************************************************************//**\n\
    - * @brief Send CoAP response packet.\n- * @details Send CoAP response packet.\n\
    - * @param[in] sockid Socket id.\n- * @param[in] clnt_addr Client address.\n-\
    \ * @param[in] payload_len CoAP packet payload length.\n- * @param[in,out] _buff\
    \ CoAP packet.\n+ * @brief Build response packet from response instance\n+ * @details\
    \ Build response with response builder API based on the request packet, and set\
    \ payload if it's exist\n+ * @param[in] resp Response instance\n+ * @param[in]\
    \ req_packet Request packet\n  * @return sl_wisun_coap_packet_t * Response packet\
    \ ptr\n  *****************************************************************************/\n\
    -static sl_wisun_coap_packet_t * _build_response_packet(char* payload,\n+static\
    \ sl_wisun_coap_packet_t * _build_response_packet(const sl_wisun_nwm_remote_ctrl_resp_t\
    \ * const resp,\n                                                        const\
    \ sl_wisun_coap_packet_t * const req_packet);\n \n /**************************************************************************//**\n\
    \  * @brief Network Measurement custom stat handler.\n  * @details Catch stat\
    \ object after measurement and copy to local variable.\n  * @param[in] stat Statistic\
    \ result after a ping measurement.\n  *****************************************************************************/\n\
    -static void _sl_wisun_nwm_remote_ctrl_stat_handler(sl_wisun_ping_stat_t *stat);\n\
    +static void _stat_handler(sl_wisun_ping_stat_t *stat);\n \n /**************************************************************************//**\n\
    \  * @brief CoAP remote CLI ping request parser.\n@@ -208,7 +399,7 @@ static sl_wisun_coap_packet_t\
    \ * _parse_iperf(const sl_wisun_coap_packet_t * cons\n  * @param[in, out] cmd\
    \ Command structure.\n  *****************************************************************************/\n\
    \ static void _parse_remote_cmd(char* req_cmd,\n-                            \
    \  ctrl_cmd_type_t* cmd);\n+                              sl_wisun_nwm_remote_ctrl_cmd_t*\
    \ cmd);\n \n /**************************************************************************//**\n\
    \  * @brief iPerf server handler.\n@@ -226,13 +417,6 @@ static sl_wisun_coap_packet_t\
    \ * _start_iperf_server(const sl_wisun_coap_packet_t\n  *****************************************************************************/\n\
    \ static sl_wisun_coap_packet_t * _start_iperf_client(const sl_wisun_coap_packet_t\
    \ * const req_packet);\n \n-/**************************************************************************//**\n\
    - * @brief Neighbour info handler.\n- * @details Get Neighbour info.\n- * @param[in]\
    \ req_packet Request packet.\n- * @return sl_wisun_coap_packet_t * Response packet\
    \ ptr\n- *****************************************************************************/\n\
    -static sl_wisun_coap_packet_t * _get_nbr(const sl_wisun_coap_packet_t * const\
    \ req_packet);\n \n /**************************************************************************//**\n\
    \  * @brief Parse neighbor statistic to json format\n@@ -281,199 +465,187 @@ static\
    \ sl_wisun_nwm_node_stat_t _stat;\n /// Network Measurement Remote Control iPerf\
    \ last test result\n static sl_iperf_test_t _last_test = { 0U };\n \n-/// Router\
    \ storage\n-static sl_wisun_nwm_measurable_node_t _nodes[SL_WISUN_MAX_NODE_COUNT];\n\
    -\n-/// Stat childre storage\n-static sl_wisun_nwm_node_stat_t _children_stats[30U];\n\
    -\n-/// Stat border router storage\n-static sl_wisun_nwm_node_stat_t _br_stat;\n\
    -\n-/// Stat primary parent storage\n-static sl_wisun_nwm_node_stat_t _pp_stat;\n\
    -\n-/// Payload buffer\n-static char _payload_buff[SL_WISUN_NWM_REMOTE_CTRL_BUFF_SIZE]\
    \ = { 0 };\n-\n // -----------------------------------------------------------------------------\n\
    \ //                          Public Function Definitions\n // -----------------------------------------------------------------------------\n\
    \ \n+__STATIC_INLINE void _print_cb_result(const char * format_str, \n+      \
    \                                const sl_wisun_coap_packet_t * const resp_packet)\n\
    +{\n+   printf(format_str, resp_packet != NULL ? SL_WISUN_NWM_REMOTE_CTRL_SUCCEED_STR\
    \ : SL_WISUN_NWM_REMOTE_CTRL_FAILED_STR);\n+}\n+\n sl_wisun_coap_packet_t * sl_wisun_coap_remote_cli_ping_cb(const\
    \ sl_wisun_coap_packet_t * const req_packet)\n {\n   sl_wisun_coap_packet_t *\
    \ resp_packet = NULL;\n   resp_packet = _parse_ping(req_packet);\n-  printf(\"\
    [COAP CLI Ping transaction %s]\\n\", resp_packet != NULL ? \"succeed\" : \"failed\"\
    );\n+  _print_cb_result(SL_WISUN_NWM_REMOTE_CTRL_PING_RESULT_FROMAT_STR, resp_packet);\n\
    \   return resp_packet;\n }\n \n sl_wisun_coap_packet_t * sl_wisun_coap_remote_cli_iperf_cb(const\
    \ sl_wisun_coap_packet_t * const req_packet)\n {\n   sl_wisun_coap_packet_t *\
    \ resp_packet = NULL;\n   resp_packet = _parse_iperf(req_packet);\n-  printf(\"\
    [COAP CLI iPerf transaction %s]\\n\", resp_packet != NULL ? \"succeed\" : \"failed\"\
    );\n+  _print_cb_result(SL_WISUN_NWM_REMOTE_CTRL_IPERF_RESULT_FROMAT_STR, resp_packet);\n\
    \   return resp_packet;\n }\n \n sl_wisun_coap_packet_t * sl_wisun_coap_remote_cli_nbr_cb(const\
    \ sl_wisun_coap_packet_t * const req_packet)\n {\n   sl_wisun_coap_packet_t *\
    \ resp_packet = NULL;\n-  resp_packet = _get_nbr(req_packet);\n-  printf(\"[COAP\
    \ CLI NeighborInfo transaction %s]\\n\", resp_packet != NULL ? \"succeed\" : \"\
    failed\");\n+  resp_packet = _build_response(req_packet, SL_WISUN_NWM_REMOTE_CTRL_BUF_TARGET_NBINF);\n\
    +  _print_cb_result(SL_WISUN_NWM_REMOTE_CTRL_NBRINFO_RESULT_FROMAT_STR, resp_packet);\n\
    \   return resp_packet;\n }\n \n // -----------------------------------------------------------------------------\n\
    \ //                          Static Function Definitions\n // -----------------------------------------------------------------------------\n\
    \ \n-static sl_wisun_coap_packet_t * _get_nbr(const sl_wisun_coap_packet_t * const\
    \ req_packet)\n-{\n-  int16_t free_payload_len  = SL_WISUN_NWM_REMOTE_CTRL_BUFF_SIZE;\n\
    -  uint8_t children_count    = 0U;\n-  char *payload_pos         = NULL;\n-\n\
    -  payload_pos = _payload_buff;\n-\n-  // get count of neighbors\n-  (void) sl_wisun_nwm_get_nodes(_nodes,\
    \ SL_WISUN_MAX_NODE_COUNT, true);\n-\n-  sl_wisun_nwm_get_border_router_stat(&_br_stat);\n\
    -  sl_wisun_nwm_get_primary_parent_stat(&_pp_stat);\n-  sl_wisun_nwm_get_children_stat(_children_stats,\
    \ 30U, &children_count);\n-\n-  payload_pos += snprintf(payload_pos, free_payload_len,\
    \ \"{\\n\");\n-  --free_payload_len;\n-  _parse_nbr_stat_to_json(&payload_pos,\
    \ &_br_stat, &free_payload_len);\n-  _parse_nbr_stat_to_json(&payload_pos, &_pp_stat,\
    \ &free_payload_len);\n-\n-  for (uint8_t i = 0; i < children_count; ++i) {\n\
    -    _parse_nbr_stat_to_json(&payload_pos, &_children_stats[i], &free_payload_len);\n\
    -  }\n-\n-  if ((payload_pos - 2U) >= _payload_buff) {\n-    // Remove last item\
    \ comma and print JSON end\n-    snprintf(*(payload_pos - 2U) == ',' ? payload_pos\
    \ - 2U : payload_pos, free_payload_len, \"\\n}\");\n-  }\n-\n-  return _build_response_packet(_payload_buff,\
    \ req_packet);\n-}\n \n static sl_wisun_coap_packet_t * _parse_ping(const sl_wisun_coap_packet_t\
    \ * const req_packet)\n {\n-  ctrl_cmd_type_t ping_cmd          = { 0U };\n- \
    \ sockaddr_in6_t remote_addr          = { 0U };\n-  uint16_t packet_count    \
    \         = 0U;\n-  uint16_t packet_size              = 0U;\n-  char* req_payload\
    \                 = NULL;\n-  buffer_target_type_t print_target = BUFFER_TYPE_NONE;\n\
    +  sl_wisun_nwm_remote_ctrl_cmd_t ping_cmd = { 0U };\n+  sockaddr_in6_t remote_addr\
    \ = { 0U };\n+  uint16_t packet_count = 0U;\n+  uint16_t packet_size = 0U;\n+\
    \  char* req_payload = NULL;\n+  sl_wisun_nwm_remote_ctrl_buf_target_t print_target\
    \ = SL_WISUN_NWM_REMOTE_CTRL_BUF_TARGET_NONE;\n \n   // Parsing incoming cli command\
    \ string.\n   req_payload = sl_wisun_coap_get_payload_str(req_packet);\n   if\
    \ (req_payload == NULL) {\n-    return _build_response_packet(\"No CoAP payload:\
    \ -e \\\"<cli command>\\\"\", req_packet);\n+    return _build_response_packet(&_resp_no_coap_payload,\
    \ req_packet);\n   }\n   _parse_remote_cmd(req_payload, &ping_cmd);\n \n   if\
    \ (ping_cmd.identifier == NULL || ping_cmd.arg1 == NULL) {\n     sl_wisun_coap_destroy_payload_str(req_payload);\n\
    -    return _build_response_packet(\"Not enough argument\", req_packet);\n+  \
    \  return _build_response_packet(&_resp_not_enough_arg, req_packet);\n   }\n \n\
    \   // Handle help request.\n-  if (!strncmp(ping_cmd.arg1, \"help\", SL_WISUN_COAP_NWM_REMOTE_CLI_MAX_ARG_STRING_LENGTH))\
    \ {\n+  if (!strncmp(ping_cmd.arg1,\n+               SL_WISUN_NWM_REMOTE_CTRL_ARG_HELP_STR,\
    \ \n+               SL_WISUN_NWM_REMOTE_CTRL_MAX_ARG_STRING_LENGTH)) {\n     sl_wisun_coap_destroy_payload_str(req_payload);\n\
    -    return _build_response_packet(\"Ping CLI help: measure <packet_count> <packet_size>\
    \ <address>\", req_packet);\n+    return _build_response_packet(&_resp_ping_help,\
    \ req_packet);\n   }\n \n   if (ping_cmd.arg2 == NULL) {\n     sl_wisun_coap_destroy_payload_str(req_payload);\n\
    -    return _build_response_packet(\"Not enough argument\", req_packet);\n+  \
    \  return _build_response_packet(&_resp_not_enough_arg, req_packet);\n   }\n \
    \  packet_count = atoi(ping_cmd.arg1);\n   packet_size = atoi(ping_cmd.arg2);\n\
    \ \n   // Handle measurement request based on address.\n-  if (ping_cmd.arg3 !=\
    \ NULL && !strncmp(ping_cmd.arg3, \"all\", SL_WISUN_COAP_NWM_REMOTE_CLI_MAX_ARG_STRING_LENGTH))\
    \ {\n+  if (ping_cmd.arg3 != NULL && !strncmp(ping_cmd.arg3, \n+             \
    \                           SL_WISUN_NWM_REMOTE_CTRL_ARG_ALL_NODE_STR, \n+   \
    \                                     SL_WISUN_NWM_REMOTE_CTRL_MAX_ARG_STRING_LENGTH))\
    \ {\n     sl_wisun_nwm_quick_measure(SL_WISUN_NWM_TARGET_TYPE_ALL, packet_count,\
    \ packet_size);\n-    print_target = BUFFER_TYPE_ALL;\n-  } else if (ping_cmd.arg3\
    \ != NULL && !strncmp(ping_cmd.arg3, \"parent\", SL_WISUN_COAP_NWM_REMOTE_CLI_MAX_ARG_STRING_LENGTH))\
    \ {\n+    print_target = SL_WISUN_NWM_REMOTE_CTRL_BUF_TARGET_ALL;\n+  } else if\
    \ (ping_cmd.arg3 != NULL && !strncmp(ping_cmd.arg3, \n+                      \
    \                         SL_WISUN_NWM_REMOTE_CTRL_ARG_PARENT_NODE_STR, \n+  \
    \                                             SL_WISUN_NWM_REMOTE_CTRL_MAX_ARG_STRING_LENGTH))\
    \ {\n     sl_wisun_nwm_quick_measure(SL_WISUN_NWM_TARGET_TYPE_PARENT, packet_count,\
    \ packet_size);\n-    print_target = BUFFER_TYPE_PARENT;\n-  } else if (ping_cmd.arg3\
    \ != NULL && !strncmp(ping_cmd.arg3, \"br\", SL_WISUN_COAP_NWM_REMOTE_CLI_MAX_ARG_STRING_LENGTH))\
    \ {\n+    print_target = SL_WISUN_NWM_REMOTE_CTRL_BUF_TARGET_PARENT;\n+  } else\
    \ if (ping_cmd.arg3 != NULL && !strncmp(ping_cmd.arg3, \n+                   \
    \                            SL_WISUN_NWM_REMOTE_CTRL_ARG_BR_NODE_STR, \n+   \
    \                                            SL_WISUN_NWM_REMOTE_CTRL_MAX_ARG_STRING_LENGTH))\
    \ {\n     sl_wisun_nwm_quick_measure(SL_WISUN_NWM_TARGET_TYPE_BORDER_ROUTER, packet_count,\
    \ packet_size);\n-    print_target = BUFFER_TYPE_BORDER_ROUTER;\n+    print_target\
    \ = SL_WISUN_NWM_REMOTE_CTRL_BUF_TARGET_BORDER_ROUTER;\n   } else {\n     if (ping_cmd.arg3\
    \ != NULL && inet_pton(AF_INET6, ping_cmd.arg3, &remote_addr.sin6_addr) == SOCKET_RETVAL_ERROR)\
    \ {\n       sl_wisun_coap_destroy_payload_str(req_payload);\n-      return _build_response_packet(\"\
    [IP address is not set or not valid]\", req_packet);\n+      return _build_response_packet(&_resp_ip_not_valid,\
    \ req_packet);\n     }\n     (void)sl_wisun_ping(&remote_addr, packet_count, packet_size,\n\
    -                        _sl_wisun_nwm_remote_ctrl_stat_handler, NULL);\n-   \
    \ _stat.name = \"Custom Node\";\n+                        _stat_handler, NULL);\n\
    +    _stat.name = SL_WISUN_NWM_REMOTE_CTRL_ARG_CUSTOM_NODE_STR;\n     _stat.addr\
    \ = remote_addr;\n-    print_target = BUFFER_TYPE_SINGLE;\n+    print_target =\
    \ SL_WISUN_NWM_REMOTE_CTRL_BUF_TARGET_SINGLE;\n   }\n \n   sl_wisun_coap_destroy_payload_str(req_payload);\n\
    \ \n   // Build response packet\n-  return _build_send_output(req_packet, print_target);\n\
    +  return _build_response(req_packet, print_target);\n }\n \n static sl_wisun_coap_packet_t\
    \ * _parse_iperf(const sl_wisun_coap_packet_t * const req_packet)\n {\n-  ctrl_cmd_type_t\
    \ iperf_cmd = { 0U };\n-  char* req_payload         = NULL;\n+  sl_wisun_nwm_remote_ctrl_cmd_t\
    \ iperf_cmd = { 0U };\n+  char* req_payload = NULL;\n+  sl_wisun_nwm_remote_ctrl_buf_target_t\
    \ get_res_type = SL_WISUN_NWM_REMOTE_CTRL_BUF_TARGET_NONE;\n   sl_wisun_coap_packet_t\
    \ * resp_packet = NULL;\n \n   // Parsing incoming cli command string.\n   req_payload\
    \ = sl_wisun_coap_get_payload_str(req_packet);\n   if (req_payload == NULL) {\n\
    -    return _build_response_packet(\"No CoAP payload: -e \\\"<cli command>\\\"\
    \", req_packet);\n+    return _build_response_packet(&_resp_no_coap_payload, req_packet);\n\
    \   }\n \n   _parse_remote_cmd(req_payload, &iperf_cmd);\n \n   if (iperf_cmd.identifier\
    \ == NULL || iperf_cmd.arg1 == NULL) {\n     sl_wisun_coap_destroy_payload_str(req_payload);\n\
    -    return _build_response_packet(\"Not enough argument\", req_packet);\n+  \
    \  return _build_response_packet(&_resp_not_enough_arg, req_packet);\n   }\n \n\
    \   // Handle help request.\n-  if (!strncmp(iperf_cmd.arg1, \"help\", SL_WISUN_COAP_NWM_REMOTE_CLI_MAX_ARG_STRING_LENGTH))\
    \ {\n+  if (!strncmp(iperf_cmd.arg1, \n+               SL_WISUN_NWM_REMOTE_CTRL_ARG_HELP_STR,\
    \ \n+               SL_WISUN_NWM_REMOTE_CTRL_MAX_ARG_STRING_LENGTH)) {\n     sl_wisun_coap_destroy_payload_str(req_payload);\n\
    -    return _build_response_packet(SL_WISUN_NWM_REMOTE_CTRL_IPERF_HELP_STRING,\
    \ req_packet);\n+    return _build_response_packet(&_resp_iperf_help, req_packet);\n\
    \   }\n \n   // Handle server or client start requests.\n-  if (!strncmp(iperf_cmd.arg1,\
    \ \"server\", SL_WISUN_COAP_NWM_REMOTE_CLI_MAX_ARG_STRING_LENGTH)) {\n+  if (!strncmp(iperf_cmd.arg1,\
    \ \n+               SL_WISUN_NWM_REMOTE_CTRL_ARG_SERVER_STR, \n+             \
    \  SL_WISUN_NWM_REMOTE_CTRL_MAX_ARG_STRING_LENGTH)) {\n     sl_wisun_coap_destroy_payload_str(req_payload);\n\
    \     return _start_iperf_server(req_packet);\n   }\n \n-  if (!strncmp(iperf_cmd.arg1,\
    \ \"client\", SL_WISUN_COAP_NWM_REMOTE_CLI_MAX_ARG_STRING_LENGTH)) {\n+  if (!strncmp(iperf_cmd.arg1,\
    \ \n+               SL_WISUN_NWM_REMOTE_CTRL_ARG_CLIENT_STR, \n+             \
    \  SL_WISUN_NWM_REMOTE_CTRL_MAX_ARG_STRING_LENGTH)) {\n     sl_wisun_coap_destroy_payload_str(req_payload);\n\
    \     return _start_iperf_client(req_packet);\n   }\n \n   if (iperf_cmd.arg2\
    \ == NULL) {\n     sl_wisun_coap_destroy_payload_str(req_payload);\n \n-    return\
    \ _build_response_packet(\"Not enough argument\", req_packet);\n+    return _build_response_packet(&_resp_not_enough_arg,\
    \ req_packet);\n   }\n \n   // Handle get requests.\n-  if (!strncmp(iperf_cmd.arg1,\
    \ \"get\", SL_WISUN_COAP_NWM_REMOTE_CLI_MAX_ARG_STRING_LENGTH)) {\n-    if (!strncmp(iperf_cmd.arg2,\
    \ \"result\", SL_WISUN_COAP_NWM_REMOTE_CLI_MAX_ARG_STRING_LENGTH)) {\n+  if (!strncmp(iperf_cmd.arg1,\
    \ \n+               SL_WISUN_NWM_REMOTE_CTRL_ARG_GET_STR, \n+               SL_WISUN_NWM_REMOTE_CTRL_MAX_ARG_STRING_LENGTH))\
    \ {\n+    if (!strncmp(iperf_cmd.arg2, \n+                 SL_WISUN_NWM_REMOTE_CTRL_ARG_JSON_STR,\
    \ \n+                 SL_WISUN_NWM_REMOTE_CTRL_MAX_ARG_STRING_LENGTH)) {\n+  \
    \    get_res_type = SL_WISUN_NWM_REMOTE_CTRL_BUF_TARGET_IPERF_JSON;\n+    } else\
    \ if (!strncmp(iperf_cmd.arg2, \n+                        SL_WISUN_NWM_REMOTE_CTRL_ARG_TEXT_STR,\
    \ \n+                        SL_WISUN_NWM_REMOTE_CTRL_MAX_ARG_STRING_LENGTH))\
    \ {\n+      get_res_type = SL_WISUN_NWM_REMOTE_CTRL_BUF_TARGET_IPERF_TEXT;\n+\
    \    } else {\n+      // Invalid iperf get request\n+      resp_packet = _build_response_packet(&_resp_invalid_res_type,\
    \ req_packet);\n+    }\n+\n+    if (get_res_type != SL_WISUN_NWM_REMOTE_CTRL_BUF_TARGET_NONE)\
    \ {\n       (void) sl_iperf_test_get(&_last_test, 1);\n-      resp_packet = _build_send_output(req_packet,\
    \ BUFFER_TYPE_IPERF);\n+      resp_packet = _build_response(req_packet, get_res_type);\n\
    \       if (resp_packet == NULL) {\n-        resp_packet = _build_response_packet(\"\
    [Buffer error]\", req_packet);\n+        resp_packet = _build_response_packet(&_resp_buff_error,\
    \ req_packet);\n       }\n-    } else {\n-      resp_packet = _build_response_packet(\"\
    Not found argument.\", req_packet);\n     }\n \n     // Clean memory\n@@ -483,28\
    \ +655,45 @@ static sl_wisun_coap_packet_t * _parse_iperf(const sl_wisun_coap_packet_t\
    \ * cons\n \n   if (iperf_cmd.arg3 == NULL) {\n     sl_wisun_coap_destroy_payload_str(req_payload);\n\
    -    return _build_response_packet(\"Not enough argument\", req_packet);\n+  \
    \  return _build_response_packet(&_resp_not_enough_arg, req_packet);\n   }\n \n\
    \   // Handle settings requests.\n-  if (!strncmp(iperf_cmd.arg1, \"set\", SL_WISUN_COAP_NWM_REMOTE_CLI_MAX_ARG_STRING_LENGTH))\
    \ {\n-    if (!strncmp(iperf_cmd.arg2, \"options.bandwidth\", SL_WISUN_COAP_NWM_REMOTE_CLI_MAX_ARG_STRING_LENGTH))\
    \ {\n+  if (!strncmp(iperf_cmd.arg1, \n+               SL_WISUN_NWM_REMOTE_CTRL_ARG_SET_STR,\
    \ \n+               SL_WISUN_NWM_REMOTE_CTRL_MAX_ARG_STRING_LENGTH)) {\n+\n+ \
    \   if (!strncmp(iperf_cmd.arg2, \n+                 SL_WISUN_NWM_REMOTE_CTRL_ARG_OPTIONS_BW_STR,\
    \ \n+                 SL_WISUN_NWM_REMOTE_CTRL_MAX_ARG_STRING_LENGTH)) {\n   \
    \    _options.bandwidth = atoi(iperf_cmd.arg3);\n-      resp_packet = sl_wisun_coap_build_response(req_packet,\
    \ COAP_MSG_CODE_RESPONSE_CHANGED);\n-    } else if (!strncmp(iperf_cmd.arg2, \"\
    options.remote_addr\", SL_WISUN_COAP_NWM_REMOTE_CLI_MAX_ARG_STRING_LENGTH)) {\n\
    -      memcpy(_options.remote_addr, iperf_cmd.arg3, sl_strnlen(iperf_cmd.arg3,\
    \ SL_WISUN_COAP_NWM_REMOTE_CLI_MAX_QUERY_LENGTH));\n-      resp_packet = sl_wisun_coap_build_response(req_packet,\
    \ COAP_MSG_CODE_RESPONSE_CHANGED);\n-    } else if (!strncmp(iperf_cmd.arg2, \"\
    options.duration\", SL_WISUN_COAP_NWM_REMOTE_CLI_MAX_ARG_STRING_LENGTH)) {\n+\
    \      resp_packet = _build_response_packet(&_resp_iperf_set_succeed, req_packet);\n\
    +    \n+    } else if (!strncmp(iperf_cmd.arg2, \n+                        SL_WISUN_NWM_REMOTE_CTRL_ARG_OPTIONS_REMOTE_ADDR_STR,\
    \ \n+                        SL_WISUN_NWM_REMOTE_CTRL_MAX_ARG_STRING_LENGTH))\
    \ {\n+      memcpy(_options.remote_addr, \n+             iperf_cmd.arg3, \n+ \
    \            sl_strnlen(iperf_cmd.arg3, SL_WISUN_NWM_REMOTE_CTRL_MAX_QUERY_LENGTH));\n\
    +      resp_packet = _build_response_packet(&_resp_iperf_set_succeed, req_packet);\n\
    +    \n+    } else if (!strncmp(iperf_cmd.arg2, \n+                        SL_WISUN_NWM_REMOTE_CTRL_ARG_OPTIONS_DURATION_STR,\
    \ \n+                        SL_WISUN_NWM_REMOTE_CTRL_MAX_ARG_STRING_LENGTH))\
    \ {\n       _options.duration_ms = atoi(iperf_cmd.arg3);\n-      resp_packet =\
    \ sl_wisun_coap_build_response(req_packet, COAP_MSG_CODE_RESPONSE_CHANGED);\n\
    -    } else if (!strncmp(iperf_cmd.arg2, \"options.interval\", SL_WISUN_COAP_NWM_REMOTE_CLI_MAX_ARG_STRING_LENGTH))\
    \ {\n+      resp_packet = _build_response_packet(&_resp_iperf_set_succeed, req_packet);\n\
    +    \n+    } else if (!strncmp(iperf_cmd.arg2, \n+                        SL_WISUN_NWM_REMOTE_CTRL_ARG_OPTIONS_INTERVAL_STR,\
    \ \n+                        SL_WISUN_NWM_REMOTE_CTRL_MAX_ARG_STRING_LENGTH))\
    \ {\n       _options.interval_ms = atoi(iperf_cmd.arg3);\n-      resp_packet =\
    \ sl_wisun_coap_build_response(req_packet, COAP_MSG_CODE_RESPONSE_CHANGED);\n\
    +      resp_packet = _build_response_packet(&_resp_iperf_set_succeed, req_packet);\n\
    +    \n     } else {\n-      resp_packet = sl_wisun_coap_build_response(req_packet,\
    \ COAP_MSG_CODE_RESPONSE_NOT_ACCEPTABLE);\n+      resp_packet = _build_response_packet(&_resp_iperf_set_failed,\
    \ req_packet);\n     }\n   } else {\n-    resp_packet = _build_response_packet(\"\
    Unknown cli command\", req_packet);\n+    resp_packet = _build_response_packet(&_resp_unknown_cli,\
    \ req_packet);\n   }\n \n   // Clean memory\n@@ -524,12 +713,13 @@ static  sl_wisun_coap_packet_t\
    \ * _start_iperf_server(const sl_wisun_coap_packet_\n \n   // Adds the test to\
    \ the queue\n   if (!sl_iperf_test_add(&test)) {\n-    printf(\"[Adding test to\
    \ queue failed]\\n\");\n-    return NULL;\n+    return _build_response_packet(&_resp_test_queue_failed,\
    \ \n+                                  req_packet);\n   }\n \n   // Build response\
    \ packet.\n-  return _build_response_packet(\"[iPerf server started]\", req_packet);\n\
    +  return _build_response_packet(&_resp_iperf_srv_started, \n+               \
    \                 req_packet);\n }\n \n static sl_wisun_coap_packet_t * _start_iperf_client(const\
    \ sl_wisun_coap_packet_t * const req_packet)\n@@ -544,120 +734,191 @@ static sl_wisun_coap_packet_t\
    \ * _start_iperf_client(const sl_wisun_coap_packet_t\n \n   // Adds the test to\
    \ the queue.\n   if (!sl_iperf_test_add(&test)) {\n-    printf(\"[Adding test\
    \ to queue failed]\\n\");\n-    return NULL;\n+    return _build_response_packet(&_resp_test_queue_failed,\
    \ req_packet);\n   }\n \n   // Build response packet.\n-  return _build_response_packet(\"\
    [iPerf client started]\", req_packet);\n-\n+  return _build_response_packet(&_resp_iperf_clnt_started,\
    \ \n+                                req_packet);\n }\n \n-\n-static void _parse_remote_cmd(char*\
    \ req_cmd, ctrl_cmd_type_t* cmd)\n+static void _parse_remote_cmd(char* req_cmd,\
    \ sl_wisun_nwm_remote_ctrl_cmd_t* cmd)\n {\n   cmd->identifier = strtok(req_cmd,\
    \ \" \");\n   cmd->arg1 = strtok(NULL, \" \");\n   cmd->arg2 = strtok(NULL, \"\
    \ \");\n   cmd->arg3 = strtok(NULL, \" \");\n }\n \n-static sl_status_t _build_payload(buffer_target_type_t\
    \ target)\n+static char * _build_iperf_result(const sl_wisun_nwm_remote_ctrl_buf_target_t\
    \ target,\n+                                  char * const payload_buff)\n {\n\
    -  uint8_t children_count = 0U;\n-  char *payload_pos = _payload_buff;\n-  int16_t\
    \ payload_len    = SL_WISUN_NWM_REMOTE_CTRL_BUFF_SIZE; // payload length\n-  int32_t\
    \ r = 0L;\n-\n-  // Get stats from stat storage\n-  sl_wisun_nwm_get_border_router_stat(&_br_stat);\n\
    -  sl_wisun_nwm_get_primary_parent_stat(&_pp_stat);\n-  sl_wisun_nwm_get_children_stat(_children_stats,\
    \ 30U, &children_count);\n+     // Set buffer\n+    sl_iperf_log_set_buff(_last_test.log,\
    \ payload_buff, SL_WISUN_NWM_REMOTE_CTRL_BUFF_SIZE);\n \n-  if (target == BUFFER_TYPE_IPERF)\
    \ {\n-    // Set buffer\n-    sl_iperf_log_set_buff(_last_test.log, _payload_buff,\
    \ payload_len);\n-    \n     // Set printer\n     sl_iperf_log_set_printer(_last_test.log,\
    \ _log_print_only_buff);\n-    \n-    // Print json formatted log\n-    sl_iperf_print_test_log_json(&_last_test);\n\
    +\n+    if (target == SL_WISUN_NWM_REMOTE_CTRL_BUF_TARGET_IPERF_JSON) {\n+   \
    \   // Print json formatted log\n+      sl_iperf_print_test_log_json(&_last_test);\n\
    +    } else {\n+      // print connection string with addresses\n+      sl_iperf_test_print_udp_conn_str(&_last_test);\n\
    +      // print report header\n+      if (_last_test.opt.mode == SL_IPERF_MODE_SERVER)\
    \ {\n+        sl_iperf_test_print_udp_srv_report_hdr(&_last_test);\n+      } else\
    \ {\n+        sl_iperf_test_print_udp_clnt_report_hdr(&_last_test);\n+      }\n\
    +      // print report summary\n+      sl_iperf_test_calculate_average_bandwidth(&_last_test);\n\
    +    }\n \n     // Reinit log\n     sl_iperf_log_init(_last_test.log);\n-    return\
    \ SL_STATUS_OK;\n+    return payload_buff;\n+}\n+\n+static char * _build_nbr_info(char\
    \ * const payload_buff,\n+                              sl_wisun_nwm_measurable_node_t\
    \ * const nodes,\n+                              sl_wisun_nwm_node_stat_t * const\
    \ br_stat,\n+                              sl_wisun_nwm_node_stat_t * const pp_stat,\n\
    +                              sl_wisun_nwm_node_stat_t * const children_stats)\n\
    +{\n+  int16_t free_payload_len = SL_WISUN_NWM_REMOTE_CTRL_BUFF_SIZE;\n+  uint8_t\
    \ children_count = 0U;\n+  char *payload_pos = NULL;\n+\n+  payload_pos = payload_buff;\n\
    +\n+  // get count of neighbors\n+  (void) sl_wisun_nwm_get_nodes(nodes, SL_WISUN_MAX_NODE_COUNT,\
    \ true);\n+\n+  sl_wisun_nwm_get_border_router_stat(br_stat);\n+  sl_wisun_nwm_get_primary_parent_stat(pp_stat);\n\
    +  sl_wisun_nwm_get_children_stat(children_stats, 30U, &children_count);\n+\n\
    +  payload_pos += snprintf(payload_pos, free_payload_len, \"{\\n\");\n+  --free_payload_len;\n\
    +  _parse_nbr_stat_to_json(&payload_pos, br_stat, &free_payload_len);\n+  _parse_nbr_stat_to_json(&payload_pos,\
    \ pp_stat, &free_payload_len);\n+\n+  for (uint8_t i = 0; i < children_count;\
    \ ++i) {\n+    _parse_nbr_stat_to_json(&payload_pos, &children_stats[i], &free_payload_len);\n\
    +  }\n+\n+  if ((payload_pos - 2U) >= payload_buff) {\n+    // Remove last item\
    \ comma and print JSON end\n+    snprintf(*(payload_pos - 2U) == ',' ? payload_pos\
    \ - 2U : payload_pos, free_payload_len, \"\\n}\");\n   }\n \n+  return payload_buff;\n\
    +}\n+\n+static char * _build_ping_meas_stat(const sl_wisun_nwm_remote_ctrl_buf_target_t\
    \ target,\n+                                    char * const payload_buff,\n+\
    \                                    sl_wisun_nwm_node_stat_t * const br_stat,\n\
    +                                    sl_wisun_nwm_node_stat_t * const pp_stat,\n\
    +                                    sl_wisun_nwm_node_stat_t * const children_stats)\n\
    +{\n+  uint8_t children_count = 0U;\n+  char *payload_pos = payload_buff;\n+ \
    \ uint16_t payload_len = SL_WISUN_NWM_REMOTE_CTRL_BUFF_SIZE;\n+  int32_t r = 0L;\n\
    +\n+  // Get stats from stat storage\n+  sl_wisun_nwm_get_border_router_stat(br_stat);\n\
    +  sl_wisun_nwm_get_primary_parent_stat(pp_stat);\n+  sl_wisun_nwm_get_children_stat(children_stats,\
    \ 30U, &children_count);\n+\n+\n   // Print JSON start\n   r = snprintf(payload_pos,\
    \ payload_len, \"{\\n\");\n   if (r < 0L) {\n-    return SL_STATUS_FAIL;\n+  \
    \  return NULL;\n   }\n   payload_pos += r;\n \n   // Print stats to buffer\n\
    -  if (target == BUFFER_TYPE_PARENT || target == BUFFER_TYPE_ALL) {\n-    _parse_stat_to_json(&payload_pos,\
    \ &_pp_stat, &payload_len);\n+  if (target == SL_WISUN_NWM_REMOTE_CTRL_BUF_TARGET_PARENT\
    \ || target == SL_WISUN_NWM_REMOTE_CTRL_BUF_TARGET_ALL) {\n+    _parse_stat_to_json(&payload_pos,\
    \ pp_stat, &payload_len);\n   }\n \n-  if (target == BUFFER_TYPE_BORDER_ROUTER\
    \ || target == BUFFER_TYPE_ALL) {\n-    _parse_stat_to_json(&payload_pos, &_br_stat,\
    \ &payload_len);\n+  if (target == SL_WISUN_NWM_REMOTE_CTRL_BUF_TARGET_BORDER_ROUTER\
    \ || target == SL_WISUN_NWM_REMOTE_CTRL_BUF_TARGET_ALL) {\n+    _parse_stat_to_json(&payload_pos,\
    \ br_stat, &payload_len);\n   }\n \n-  if (target == BUFFER_TYPE_SINGLE) {\n+\
    \  if (target == SL_WISUN_NWM_REMOTE_CTRL_BUF_TARGET_SINGLE) {\n     _parse_stat_to_json(&payload_pos,\
    \ &_stat, &payload_len);\n   }\n \n   for (uint8_t i = 0; i < children_count;\
    \ ++i) {\n-    _parse_stat_to_json(&payload_pos, &_children_stats[i], &payload_len);\n\
    +    _parse_stat_to_json(&payload_pos, &children_stats[i], &payload_len);\n  \
    \ }\n \n-  if ((payload_pos - 2U) >= _payload_buff) {\n+  if ((payload_pos - 2U)\
    \ >= payload_buff) {\n     // Remove last item comma and print JSON end\n    \
    \ r = snprintf(*(payload_pos - 2U) == ',' ? payload_pos - 2U : payload_pos, payload_len,\
    \ \"\\n}\");\n     if (r < 0L) {\n-      return SL_STATUS_FAIL;\n+      return\
    \ NULL;\n     }\n   }\n \n-  return SL_STATUS_OK;\n+  return payload_buff;\n }\n\
    \ \n-static sl_wisun_coap_packet_t * _build_send_output(const sl_wisun_coap_packet_t\
    \ * const req_packet, buffer_target_type_t target)\n+static char * _build_payload(sl_wisun_nwm_remote_ctrl_buf_target_t\
    \ target)\n {\n-  sl_status_t retval = SL_STATUS_FAIL; // assume success of operation\n\
    +  static sl_wisun_nwm_measurable_node_t nodes[SL_WISUN_MAX_NODE_COUNT];\n+  static\
    \ sl_wisun_nwm_node_stat_t children_stats[SL_WISUN_NWM_REMOTE_CTRL_MAX_NB_COUNT];\n\
    +  static sl_wisun_nwm_node_stat_t br_stat;\n+  static sl_wisun_nwm_node_stat_t\
    \ pp_stat;\n+  static char payload_buff[SL_WISUN_NWM_REMOTE_CTRL_BUFF_SIZE] =\
    \ { 0U };\n+\n+  if (target == SL_WISUN_NWM_REMOTE_CTRL_BUF_TARGET_IPERF_JSON\
    \ || target == SL_WISUN_NWM_REMOTE_CTRL_BUF_TARGET_IPERF_TEXT) {\n+    return\
    \ _build_iperf_result(target, payload_buff);\n+  } else if (target == SL_WISUN_NWM_REMOTE_CTRL_BUF_TARGET_NBINF)\
    \ {\n+    return _build_nbr_info(payload_buff, nodes, &br_stat, &pp_stat, children_stats);\n\
    +  } else {\n+    return _build_ping_meas_stat(target, payload_buff, &br_stat,\
    \ &pp_stat, children_stats);\n+  }\n+}\n \n-  // Build payload from stat.\n- \
    \ retval = _build_payload(target);\n+static sl_wisun_coap_packet_t *  _build_response(const\
    \ sl_wisun_coap_packet_t * const req_packet,\n+                              \
    \                      const sl_wisun_nwm_remote_ctrl_buf_target_t target)\n+{\n\
    +  static sl_wisun_nwm_remote_ctrl_resp_t resp = { \n+    .msg_code = COAP_MSG_CODE_RESPONSE_CONTENT,\n\
    +    .payload = NULL\n+  };\n \n-  if (retval != SL_STATUS_OK) {\n-    return\
    \ NULL;\n-  }\n+  // Build payload from stat.\n+  resp.payload = _build_payload(target);\n\
    \ \n   // Build response packet from built payload.\n-  return _build_response_packet(_payload_buff,\
    \ req_packet);\n+  return _build_response_packet(&resp, req_packet);\n }\n \n\
    -static sl_wisun_coap_packet_t * _build_response_packet(char* payload,\n+static\
    \ sl_wisun_coap_packet_t * _build_response_packet(const sl_wisun_nwm_remote_ctrl_resp_t\
    \ * const resp,\n                                                        const\
    \ sl_wisun_coap_packet_t * const req_packet)\n {\n   sl_wisun_coap_packet_t *resp_packet\
    \ = NULL;\n \n-  resp_packet = sl_wisun_coap_build_response(req_packet, COAP_MSG_CODE_RESPONSE_CONTENT);\n\
    +  resp_packet = sl_wisun_coap_build_response(req_packet, resp->msg_code);\n \
    \  if (resp_packet == NULL) {\n     return NULL;\n   }\n-\n-  resp_packet->msg_code\
    \       = COAP_MSG_CODE_RESPONSE_CONTENT;\n-  resp_packet->content_format = COAP_CT_JSON;\n\
    -  resp_packet->payload_ptr    = (uint8_t *) payload;\n-  resp_packet->payload_len\
    \    = (uint16_t) sl_strnlen(payload, SL_WISUN_NWM_REMOTE_CTRL_BUFF_SIZE);\n-\n\
    +  if (resp->payload != NULL) {\n+    resp_packet->payload_ptr = (uint8_t *) resp->payload;\n\
    +    resp_packet->payload_len = (uint16_t) sl_strnlen((char *)resp->payload, SL_WISUN_NWM_REMOTE_CTRL_BUFF_SIZE);\n\
    +  }\n   return resp_packet;\n }\n \n-static void _parse_stat_to_json(char **payload_pos,\
    \ sl_wisun_nwm_node_stat_t *stat, int16_t *payload_len)\n+static void _parse_stat_to_json(char\
    \ **payload_pos, \n+                                const sl_wisun_nwm_node_stat_t\
    \ * const stat, \n+                                uint16_t * const payload_len)\n\
    \ {\n   int32_t r = 0U;\n   const char *ip_str = NULL;\n@@ -709,13 +970,12 @@\
    \ static void _parse_nbr_stat_to_json(char **payload_pos,\n }\n \n /* Statistic\
    \ printer */\n-static void _sl_wisun_nwm_remote_ctrl_stat_handler(sl_wisun_ping_stat_t\
    \ *stat)\n+static void _stat_handler(sl_wisun_ping_stat_t *stat)\n {\n   assert(stat->packet_count\
    \ != 0);\n   memcpy(&_stat.ping_stat, stat, sizeof(sl_wisun_ping_stat_t));\n }\n\
    \ \n-\n static int32_t _log_print_only_buff(sl_iperf_log_t * const log, const\
    \ char * format, ...)\n {\n   va_list args;"
  - "--- a/app/wisun/component/network_measurement/sli_wisun_network_measurement_ping_gui.c\n\
    +++ b/app/wisun/component/network_measurement/sli_wisun_network_measurement_ping_gui.c\n\
    @@ -142,7 +142,7 @@ typedef struct sl_wisun_nwm_setting {\n /// Node info structure\
    \ type definition\n typedef struct node_info {\n   /// Addresses\n-  current_addr_t\
    \ addresses;\n+  sl_wisun_app_core_current_addr_t addresses;\n   /// Settings\n\
    \   app_setting_wisun_t settings;\n } node_info_t;"
  - "--- a/app/wisun/component/network_measurement/sli_wisun_network_measurement_settings_gui.c\n\
    +++ b/app/wisun/component/network_measurement/sli_wisun_network_measurement_settings_gui.c\n\
    @@ -182,6 +182,10 @@ void sli_wisun_nwm_phy_select_form(void *args)\n \n static\
    \ void _phy_fan_form(void *args)\n {\n+  if (args == NULL) {\n+    return;\n+\
    \  }\n+\n   uint8_t *profile               = NULL;\n   app_wisun_phy_list_t *tmp_list\
    \ = NULL;\n   app_enum_t *iter               = NULL;\n@@ -231,6 +235,10 @@ static\
    \ void _phy_fan_form(void *args)\n \n static void _phy_domain_form(void *args)\n\
    \ {\n+  if (args == NULL) {\n+    return;\n+  }\n+\n   phy_domain_list_t *domain\
    \ = NULL;\n \n   domain = (phy_domain_list_t *)args;\n@@ -286,7 +294,7 @@ static\
    \ void _set_phy(void *args)\n   sl_wisun_disconnect();\n \n   // to connect to\
    \ the network with the new settings\n-  app_wisun_network_connect();\n+  sl_wisun_app_core_network_connect();\n\
    \ }\n \n __STATIC_INLINE bool filter_profile(sl_wisun_phy_config_t *phy_cfg)"
  - "--- a/app/wisun/component/ota_dfu/sl_wisun_ota_dfu.c\n+++ b/app/wisun/component/ota_dfu/sl_wisun_ota_dfu.c\n\
    @@ -502,7 +502,7 @@ static sl_wisun_coap_packet_t * _ota_dfu_coap_response_cb(const\
    \ sl_wisun_coap_pa\n   resp_packet->msg_code = COAP_MSG_CODE_RESPONSE_CREATED;\n\
    \   resp_packet->content_format = COAP_CT_JSON;\n \n-  // CoAP PUT request to\
    \ start firmware updaet\n+  // CoAP PUT request to start firmware update\n   if\
    \ (req_packet->msg_code == COAP_MSG_CODE_REQUEST_POST) {\n     // Start fw update\n\
    \     if (!memcmp(SL_WISUN_OTA_DFU_START_PAYLOAD_STR,\n@@ -604,7 +604,7 @@ static\
    \ void _ota_dfu_thr_fnc(void * args)\n \n #if SL_WISUN_OTA_DFU_HOST_NOTIFY_ENABLED\n\
    \   // Create socket\n-  _notify_ch.sockid = socket(AF_INET6, (SOCK_DGRAM | SOCK_NONBLOCK),\
    \ IPPROTO_UDP);\n+  _notify_ch.sockid = socket(AF_INET6, SOCK_DGRAM, IPPROTO_UDP);\n\
    \   assert(_notify_ch.sockid != -1L);\n \n   // Set address"
  - "--- a/app/wisun/component/ping/sl_wisun_ping.c\n+++ b/app/wisun/component/ping/sl_wisun_ping.c\n\
    @@ -424,10 +424,10 @@ static void _ping_task_fnc(void *args)\n   _fill_payload(&icmp_req);\n\
    \ \n   SL_WISUN_THREAD_LOOP {\n-    stat = osMessageQueueGet(_ping_req_msg_queue,\
    \ &req, &msg_prio, 0U);\n+    stat = osMessageQueueGet(_ping_req_msg_queue, &req,\
    \ &msg_prio, osWaitForever);\n     (void) msg_prio;\n     if (stat != osOK) {\n\
    -      app_wisun_dispatch_thread();\n+      sl_wisun_app_core_util_dispatch_thread();\n\
    \       continue;\n     }\n \n@@ -443,7 +443,7 @@ static void _ping_task_fnc(void\
    \ *args)\n     req.remote_addr.sin6_family = AF_INET6;\n     req.remote_addr.sin6_port\
    \ = htons(SL_WISUN_PING_ICMP_PORT);\n \n-    sockid = socket(AF_INET6, (SOCK_RAW\
    \ | SOCK_NONBLOCK), IPPROTO_ICMP);\n+    sockid = socket(AF_INET6, SOCK_RAW, IPPROTO_ICMP);\n\
    \ \n     if (sockid == SOCKET_INVALID_ID) {\n       _prepare_and_push_failed_response(&resp,\
    \ SL_WISUN_PING_STATUS_SOCKET_ERROR);\n@@ -483,7 +483,7 @@ static void _ping_task_fnc(void\
    \ *args)\n         if (r > 0L) {\n           break;\n         }\n-        app_wisun_dispatch_thread();\n\
    +        sl_wisun_app_core_util_dispatch_thread();\n         time_cnt = _get_ms_val_from_start_time_stamp(&req);\n\
    \       }\n \n@@ -510,7 +510,7 @@ static void _ping_task_fnc(void *args)\n   \
    \    osMessageQueuePut(_ping_resp_msg_queue, &resp, 0U, 0U);\n \n       // thread\
    \ dispatch\n-      app_wisun_dispatch_thread();\n+      sl_wisun_app_core_util_dispatch_thread();\n\
    \     } while (multicast);\n \n     osEventFlagsSet(_ping_evt, SL_WISUN_PING_STATUS_TRANSACTION_END);"
  - "--- a/app/wisun/component/tcp_client/sl_wisun_tcp_client.c\n+++ b/app/wisun/component/tcp_client/sl_wisun_tcp_client.c\n\
    @@ -69,7 +69,7 @@ void sl_wisun_tcp_client_create(const char *ip_address, uint16_t\
    \ port)\n   }\n \n   // create client socket\n-  sockid = socket(AF_INET6, (SOCK_STREAM\
    \ | SOCK_NONBLOCK), IPPROTO_IP);\n+  sockid = socket(AF_INET6, SOCK_STREAM, IPPROTO_IP);\n\
    \ \n   if (sockid == SOCKET_RETVAL_ERROR) {\n     printf(\"[Failed to create socket:\
    \ %ld]\\n\", sockid);"
  - "--- a/app/wisun/component/trace_util/sl_wisun_trace_util.c\n+++ b/app/wisun/component/trace_util/sl_wisun_trace_util.c\n\
    @@ -38,6 +38,7 @@\n #include \"sl_wisun_trace_util.h\"\n #include \"sl_wisun_types.h\"\
    \n #include \"rail_config.h\"\n+#include \"cmsis_os2.h\"\n \n #if defined(SL_CATALOG_FREERTOS_KERNEL_PRESENT)\n\
    \ // FreeRTOS\n@@ -118,6 +119,15 @@\n /// Secs in Minute\n #define SEC_IN_MINUTE\
    \     60U\n \n+/// Trace util event notify max channel count\n+#define APP_WISUN_TRACE_UTIL_EVT_NOTIFY_MAX_CHS\
    \         31U\n+\n+/// Trace util event notify error mask\n+#define APP_WISUN_TRACE_UTIL_EVT_NOTIFY_ERROR_MSK\
    \       (1UL << 31U)\n+\n+/// Trace util event notify all flags mask\n+#define\
    \ APP_WISUN_TRACE_UTIL_EVT_NOTIFY_ALL_FLAGS_MSK   0x7FFFFFFFUL\n+\n /// PHY type\
    \ enumeration\n typedef enum phy_type {\n   /// PHY type FSK\n@@ -650,6 +660,109\
    \ @@ const char *app_wisun_trace_util_time_to_str(const sl_wisun_trace_util_time_t\
    \ *\n   return (const char *) str;\n }\n \n+\n+sl_status_t app_wisun_trace_util_evt_notify_init(app_wisun_trace_util_evt_notify_t\
    \ * const evt_notify,\n+                                                 const\
    \ uint32_t wait_opt)\n+{\n+  static const osEventFlagsAttr_t evt_attr = {\n+ \
    \   .name = \"EvtNotify\",\n+    .cb_mem = NULL,\n+    .cb_size = 0,\n+    .attr_bits\
    \ = 0\n+  };\n+\n+  if (evt_notify == NULL) {\n+    return SL_STATUS_FAIL;\n+\
    \  }\n+\n+  evt_notify->evt_chs = 0UL;\n+  evt_notify->wait_opt = wait_opt;\n\
    +  evt_notify->evt_id = osEventFlagsNew(&evt_attr);\n+  \n+  if (evt_notify->evt_id\
    \ == NULL) {\n+    return SL_STATUS_FAIL;\n+  }\n+\n+  return SL_STATUS_OK;\n\
    +}\n+\n+sl_status_t app_wisun_trace_util_evt_notify_clear(app_wisun_trace_util_evt_notify_t\
    \ * const evt_notify)\n+{\n+  uint32_t flags = 0UL;\n+\n+  flags = osEventFlagsClear(evt_notify->evt_id,\
    \ APP_WISUN_TRACE_UTIL_EVT_NOTIFY_ALL_FLAGS_MSK);\n+\n+  if (flags & APP_WISUN_TRACE_UTIL_EVT_NOTIFY_ERROR_MSK)\
    \ {\n+    return SL_STATUS_FAIL;\n+  }\n+\n+  return SL_STATUS_OK;\n+}\n+\n+\n\
    +sl_status_t app_wisun_trace_util_evt_notify_subscribe_ch(app_wisun_trace_util_evt_notify_t\
    \ * const evt_notify, \n+                                                    \
    \     uint8_t * const evt_ch)\n+{\n+  for (uint8_t ch_idx = 0; ch_idx < APP_WISUN_TRACE_UTIL_EVT_NOTIFY_MAX_CHS;\
    \ ch_idx++) {\n+    if (!(evt_notify->evt_chs & (1UL << ch_idx))) {\n+      *evt_ch\
    \ = ch_idx;\n+      evt_notify->evt_chs |= (1UL << ch_idx);\n+      return SL_STATUS_OK;\n\
    +    }\n+  }\n+  return SL_STATUS_FAIL;\n+}\n+\n+sl_status_t app_wisun_trace_util_evt_notify_unsubscribe_ch(app_wisun_trace_util_evt_notify_t\
    \ * const evt_notify, \n+                                                    \
    \       const uint8_t evt_ch)\n+{\n+\n+  if (!(evt_notify->evt_chs & (1UL << evt_ch)))\
    \ {\n+    return SL_STATUS_FAIL;\n+  }\n+\n+  (void) osEventFlagsClear(evt_notify->evt_id,\
    \ 1UL << evt_ch);\n+  evt_notify->evt_chs &= ~(1UL << evt_ch);\n+\n+\n+  return\
    \ SL_STATUS_OK;\n+}\n+\n+sl_status_t app_wisun_trace_util_evt_notfiy_chs(const\
    \ app_wisun_trace_util_evt_notify_t * const evt_notify)\n+{\n+  uint32_t flags\
    \ = 0UL;\n+\n+  flags = osEventFlagsSet(evt_notify->evt_id, evt_notify->evt_chs);\n\
    +\n+  if (flags & APP_WISUN_TRACE_UTIL_EVT_NOTIFY_ERROR_MSK) {\n+    return SL_STATUS_FAIL;\n\
    +  }\n+\n+  return SL_STATUS_OK;\n+}\n+\n+\n+sl_status_t app_wisun_trace_util_evt_notify_wait(const\
    \ app_wisun_trace_util_evt_notify_t * const evt_notify,\n+                   \
    \                              const uint32_t ch_mask,\n+                    \
    \                             const uint32_t timeout)\n+{\n+  uint32_t flags =\
    \ 0UL;\n+\n+  if (!(evt_notify->evt_chs & ch_mask)) {\n+    return SL_STATUS_FAIL;\n\
    +  }\n+\n+  flags = osEventFlagsWait(evt_notify->evt_id, ch_mask, evt_notify->wait_opt,\
    \ timeout);\n+\n+  if (flags & APP_WISUN_TRACE_UTIL_EVT_NOTIFY_ERROR_MSK) {\n\
    +    return SL_STATUS_FAIL;\n+  }\n+\n+  return SL_STATUS_OK;\n+}\n+\n+\n+\n //\
    \ -----------------------------------------------------------------------------\n\
    \ //                          Static Function Definitions\n // -----------------------------------------------------------------------------"
  - "--- a/app/wisun/component/udp_client/sl_wisun_udp_client.c\n+++ b/app/wisun/component/udp_client/sl_wisun_udp_client.c\n\
    @@ -66,7 +66,7 @@ void sl_wisun_udp_client_create(void)\n   int32_t sockid = SOCKET_INVALID_ID;\
    \ // client socket id\n \n   // create client socket\n-  sockid = socket(AF_INET6,\
    \ (SOCK_DGRAM | SOCK_NONBLOCK), IPPROTO_IP);\n+  sockid = socket(AF_INET6, SOCK_DGRAM,\
    \ IPPROTO_IP);\n \n   if (sockid == SOCKET_INVALID_ID) {\n     printf(\"[Failed\
    \ to create socket: %ld]\\n\", sockid);"
  - "--- a/app/wisun/example/wisun_soc_coap_collector/app.c\n+++ b/app/wisun/example/wisun_soc_coap_collector/app.c\n\
    @@ -63,10 +63,10 @@ void app_task(void *args)\n   (void) args;\n \n   // connect\
    \ to the wisun network\n-  app_wisun_connect_and_wait();\n+  sl_wisun_app_core_util_connect_and_wait();\n\
    \ \n   while (1) {\n-    app_wisun_dispatch_thread();\n+    sl_wisun_app_core_util_dispatch_thread();\n\
    \   }\n }\n "
  - "--- a/app/wisun/example/wisun_soc_coap_collector/app_init.c\n+++ b/app/wisun/example/wisun_soc_coap_collector/app_init.c\n\
    @@ -37,7 +37,7 @@\n #include \"sl_wisun_event_mgr.h\"\n #include \"sl_wisun_coap_collector.h\"\
    \n #include \"sl_wisun_app_core_util.h\"\n-#include \"sl_wisun_app_core_util_config.h\"\
    \n+#include \"sl_wisun_app_core_config.h\"\n #include \"app.h\"\n #include \"\
    app_custom_callback.h\"\n \n@@ -63,7 +63,7 @@\n void app_init(void)\n {\n   /*\
    \ Init project info */\n-  app_wisun_project_info_init(\"Wi-SUN CoAP Collector\
    \ Application\");\n+  sl_wisun_app_core_util_project_info_init(\"Wi-SUN CoAP Collector\
    \ Application\");\n \n   /* Init CoAP collector */\n   sl_wisun_coap_collector_init();\n\
    @@ -83,7 +83,7 @@ void app_init(void)\n     .cb_mem      = NULL,\n     .cb_size\
    \     = 0,\n     .stack_mem   = NULL,\n-    .stack_size  = app_stack_size_word_to_byte(APP_MAIN_STACK_SIZE_WORD),\n\
    +    .stack_size  = app_stack_size_word_to_byte(SL_WISUN_APP_CORE_MAIN_STACK_SIZE_WORD),\n\
    \     .priority    = osPriorityNormal,\n     .tz_module   = 0\n   };"
  - "--- a/app/wisun/example/wisun_soc_coap_meter/app.c\n+++ b/app/wisun/example/wisun_soc_coap_meter/app.c\n\
    @@ -66,13 +66,13 @@ void app_task(void *args)\n   (void) args;\n \n   // connect\
    \ to the wisun network\n-  app_wisun_connect_and_wait();\n+  sl_wisun_app_core_util_connect_and_wait();\n\
    \ \n   while (1) {\n #if !SL_WISUN_COAP_RESOURCE_HND_SERVICE_ENABLE\n     sl_wisun_meter_process();\n\
    \ #endif\n-    app_wisun_dispatch_thread();\n+    sl_wisun_app_core_util_dispatch_thread();\n\
    \   }\n }\n "
  - "--- a/app/wisun/example/wisun_soc_coap_meter/app_init.c\n+++ b/app/wisun/example/wisun_soc_coap_meter/app_init.c\n\
    @@ -38,11 +38,12 @@\n #include \"sl_wisun_event_mgr.h\"\n #include \"sl_wisun_coap_meter.h\"\
    \n #include \"sl_wisun_app_core_util.h\"\n-#include \"sl_wisun_app_core_util_config.h\"\
    \n+#include \"sl_wisun_app_core_config.h\"\n #include \"sl_wisun_coap_rhnd.h\"\
    \n #include \"sl_wisun_coap_meter_collector_config.h\"\n #include \"app.h\"\n\
    \ #include \"app_custom_callback.h\"\n+#include \"sl_component_catalog.h\"\n \n\
    \ // -----------------------------------------------------------------------------\n\
    \ //                              Macros and Typedefs\n@@ -89,7 +90,7 @@ void\
    \ app_init(void)\n   sl_wisun_coap_rhnd_resource_t coap_resource = { 0 };\n \n\
    \   // Init project info\n-  app_wisun_project_info_init(\"Wi-SUN CoAP Meter Application\"\
    );\n+  sl_wisun_app_core_util_project_info_init(\"Wi-SUN CoAP Meter Application\"\
    );\n \n   // Init meter collector\n   sl_wisun_coap_meter_init();\n@@ -126,14\
    \ +127,15 @@ void app_init(void)\n   coap_resource.auto_response          = sl_wisun_coap_meter_light_response_cb;\n\
    \   coap_resource.discoverable           = true;\n   assert(sl_wisun_coap_rhnd_resource_add(&coap_resource)\
    \ == SL_STATUS_OK);\n-\n+#if !defined(SL_CATALOG_POWER_MANAGER_PRESENT)\n   //\
    \ Init led resource\n   coap_resource.data.uri_path          = SL_WISUN_COAP_METER_COLLECTOR_LED_TOGGLE_URI_PATH;\n\
    \   coap_resource.data.resource_type     = SL_WISUN_COAP_METER_RESOURCE_RT_LED;\n\
    \   coap_resource.data.interface         = SL_WISUN_COAP_METER_RESOURCE_IF_LED;\n\
    \   coap_resource.auto_response          = sl_wisun_coap_meter_led_toggle_response_cb;\n\
    \   coap_resource.discoverable           = true;\n   assert(sl_wisun_coap_rhnd_resource_add(&coap_resource)\
    \ == SL_STATUS_OK);\n+#endif\n #else\n   // Init sensor all\n   coap_resource.data.uri_path\
    \          = SL_WISUN_COAP_METER_COLLECTOR_MEASUREMENT_URI_PATH;\n@@ -159,7 +161,7\
    \ @@ void app_init(void)\n     .cb_mem      = NULL,\n     .cb_size     = 0,\n\
    \     .stack_mem   = NULL,\n-    .stack_size  = app_stack_size_word_to_byte(APP_MAIN_STACK_SIZE_WORD),\n\
    +    .stack_size  = app_stack_size_word_to_byte(SL_WISUN_APP_CORE_MAIN_STACK_SIZE_WORD),\n\
    \     .priority    = osPriorityNormal,\n     .tz_module   = 0\n   };"
  - "--- a/app/wisun/example/wisun_soc_collector/app.c\n+++ b/app/wisun/example/wisun_soc_collector/app.c\n\
    @@ -59,10 +59,10 @@ void app_task(void *args)\n   (void) args;\n \n   // connect\
    \ to the wisun network\n-  app_wisun_connect_and_wait();\n+  sl_wisun_app_core_util_connect_and_wait();\n\
    \ \n   while (1) {\n-    app_wisun_dispatch_thread();\n+    sl_wisun_app_core_util_dispatch_thread();\n\
    \   }\n }\n "
  - "--- a/app/wisun/example/wisun_soc_collector/app_init.c\n+++ b/app/wisun/example/wisun_soc_collector/app_init.c\n\
    @@ -37,7 +37,7 @@\n #include \"sl_wisun_event_mgr.h\"\n #include \"sl_wisun_collector.h\"\
    \n #include \"sl_wisun_app_core_util.h\"\n-#include \"sl_wisun_app_core_util_config.h\"\
    \n+#include \"sl_wisun_app_core_config.h\"\n #include \"app.h\"\n #include \"\
    app_custom_callback.h\"\n \n@@ -63,7 +63,7 @@\n void app_init(void)\n {\n   /*\
    \ Init project info */\n-  app_wisun_project_info_init(\"Wi-SUN Collector Application\"\
    );\n+  sl_wisun_app_core_util_project_info_init(\"Wi-SUN Collector Application\"\
    );\n \n   /* Init collector component */\n   sl_wisun_collector_init();\n@@ -83,7\
    \ +83,7 @@ void app_init(void)\n     .cb_mem      = NULL,\n     .cb_size     =\
    \ 0,\n     .stack_mem   = NULL,\n-    .stack_size  = app_stack_size_word_to_byte(APP_MAIN_STACK_SIZE_WORD),\n\
    +    .stack_size  = app_stack_size_word_to_byte(SL_WISUN_APP_CORE_MAIN_STACK_SIZE_WORD),\n\
    \     .priority    = osPriorityNormal,\n     .tz_module   = 0\n   };"
  - "--- a/app/wisun/example/wisun_soc_empty/app.c\n+++ b/app/wisun/example/wisun_soc_empty/app.c\n\
    @@ -81,14 +81,14 @@ void app_task(void *args)\n \n #ifdef SL_CATALOG_WISUN_APP_CORE_PRESENT\n\
    \   // connect to the wisun network\n-  app_wisun_connect_and_wait();\n+  sl_wisun_app_core_util_connect_and_wait();\n\
    \ #endif\n \n   while (1) {\n     ///////////////////////////////////////////////////////////////////////////\n\
    \     // Put your application code here!                                     \
    \  //\n     ///////////////////////////////////////////////////////////////////////////\n\
    -    app_wisun_dispatch_thread();\n+    sl_wisun_app_core_util_dispatch_thread();\n\
    \   }\n }\n "
  - "--- a/app/wisun/example/wisun_soc_meter/app.c\n+++ b/app/wisun/example/wisun_soc_meter/app.c\n\
    @@ -64,12 +64,12 @@ void app_task(void *args)\n   (void) args;\n \n   // connect\
    \ to the wisun network\n-  app_wisun_connect_and_wait();\n+  sl_wisun_app_core_util_connect_and_wait();\n\
    \   printf(\"[Port: %u]\\n\", SL_WISUN_METER_PORT);\n \n   while (1) {\n     sl_wisun_meter_process();\n\
    -    app_wisun_dispatch_thread();\n+    sl_wisun_app_core_util_dispatch_thread();\n\
    \   }\n }\n "
  - "--- a/app/wisun/example/wisun_soc_meter/app_init.c\n+++ b/app/wisun/example/wisun_soc_meter/app_init.c\n\
    @@ -37,7 +37,7 @@\n #include \"sl_wisun_meter.h\"\n #include \"sl_wisun_event_mgr.h\"\
    \n #include \"sl_wisun_app_core_util.h\"\n-#include \"sl_wisun_app_core_util_config.h\"\
    \n+#include \"sl_wisun_app_core_config.h\"\n #include \"app.h\"\n #include \"\
    app_custom_callback.h\"\n \n@@ -63,7 +63,7 @@\n void app_init(void)\n {\n   /*\
    \ Init project info */\n-  app_wisun_project_info_init(\"Wi-SUN Meter Application\"\
    );\n+  sl_wisun_app_core_util_project_info_init(\"Wi-SUN Meter Application\");\n\
    \ \n   /* Init meter collector */\n   sl_wisun_meter_init();\n@@ -83,7 +83,7 @@\
    \ void app_init(void)\n     .cb_mem      = NULL,\n     .cb_size     = 0,\n   \
    \  .stack_mem   = NULL,\n-    .stack_size  = app_stack_size_word_to_byte(APP_MAIN_STACK_SIZE_WORD),\n\
    +    .stack_size  = app_stack_size_word_to_byte(SL_WISUN_APP_CORE_MAIN_STACK_SIZE_WORD),\n\
    \     .priority    = osPriorityNormal,\n     .tz_module   = 0\n   };"
  - "--- a/app/wisun/example/wisun_soc_network_measurement/app.c\n+++ b/app/wisun/example/wisun_soc_network_measurement/app.c\n\
    @@ -69,15 +69,15 @@ void app_task(void *args)\n   (void) args;\n \n   // connect\
    \ to the wisun network\n-  app_wisun_connect_and_wait();\n+  sl_wisun_app_core_util_connect_and_wait();\n\
    \ \n #if defined(SL_CATALOG_GUI_PRESENT)\n   sl_display_renderer(sl_wisun_nwm_main_form,\
    \ NULL, 0);\n #endif\n \n   while (1) {\n     // User code here\n-    app_wisun_dispatch_thread();\n\
    +    sl_wisun_app_core_util_dispatch_thread();\n   }\n }\n "
  - "--- a/app/wisun/example/wisun_soc_network_measurement/app_init.c\n+++ b/app/wisun/example/wisun_soc_network_measurement/app_init.c\n\
    @@ -37,7 +37,7 @@\n #include \"sl_cmsis_os2_common.h\"\n #include \"sl_wisun_app_core.h\"\
    \n #include \"sl_wisun_app_core_util.h\"\n-#include \"sl_wisun_app_core_util_config.h\"\
    \n+#include \"sl_wisun_app_core_config.h\"\n #include \"sl_wisun_network_measurement.h\"\
    \n #include \"sl_wisun_network_measurement_remote_ctrl.h\"\n #include \"sl_wisun_network_measurement_stat.h\"\
    \n@@ -95,7 +95,7 @@ void app_init(void)\n   sl_wisun_coap_rhnd_resource_t coap_resource\
    \ = { 0 };\n \n   // Init project info\n-  app_wisun_project_info_init(\"Wi-SUN\
    \ Network Measurement Application\");\n+  sl_wisun_app_core_util_project_info_init(\"\
    Wi-SUN Network Measurement Application\");\n \n #if defined(SL_CATALOG_GUI_PRESENT)\n\
    \   // Init display\n@@ -148,7 +148,7 @@ void app_init(void)\n     .cb_mem   \
    \   = NULL,\n     .cb_size     = 0,\n     .stack_mem   = NULL,\n-    .stack_size\
    \  = app_stack_size_word_to_byte(APP_MAIN_STACK_SIZE_WORD),\n+    .stack_size\
    \  = app_stack_size_word_to_byte(SL_WISUN_APP_CORE_MAIN_STACK_SIZE_WORD),\n  \
    \   .priority    = osPriorityNormal,\n     .tz_module   = 0\n   };"
  - "--- a/app/wisun/example/wisun_soc_ping/app.c\n+++ b/app/wisun/example/wisun_soc_ping/app.c\n\
    @@ -59,11 +59,11 @@ void app_task(void *args)\n   (void) args;\n \n   // connect\
    \ to the wisun network\n-  app_wisun_connect_and_wait();\n+  sl_wisun_app_core_util_connect_and_wait();\n\
    \ \n   while (1) {\n     // User code here\n-    app_wisun_dispatch_thread();\n\
    +    sl_wisun_app_core_util_dispatch_thread();\n   }\n }\n "
  - "--- a/app/wisun/example/wisun_soc_ping/app_init.c\n+++ b/app/wisun/example/wisun_soc_ping/app_init.c\n\
    @@ -36,7 +36,7 @@\n #include \"sl_cmsis_os2_common.h\"\n #include \"sl_wisun_event_mgr.h\"\
    \n #include \"sl_wisun_app_core_util.h\"\n-#include \"sl_wisun_app_core_util_config.h\"\
    \n+#include \"sl_wisun_app_core_config.h\"\n #include \"app.h\"\n #include \"\
    app_custom_callback.h\"\n \n@@ -62,7 +62,7 @@\n void app_init(void)\n {\n   /*\
    \ Init project info */\n-  app_wisun_project_info_init(\"Wi-SUN Ping Application\"\
    );\n+  sl_wisun_app_core_util_project_info_init(\"Wi-SUN Ping Application\");\n\
    \ \n   /* Register callbacks */\n   app_wisun_em_custom_callback_register(SL_WISUN_MSG_CONNECTED_IND_ID,\n\
    @@ -79,7 +79,7 @@ void app_init(void)\n     .cb_mem      = NULL,\n     .cb_size\
    \     = 0,\n     .stack_mem   = NULL,\n-    .stack_size  = app_stack_size_word_to_byte(APP_MAIN_STACK_SIZE_WORD),\n\
    +    .stack_size  = app_stack_size_word_to_byte(SL_WISUN_APP_CORE_MAIN_STACK_SIZE_WORD),\n\
    \     .priority    = osPriorityNormal,\n     .tz_module   = 0\n   };"
  - "--- a/app/wisun/example/wisun_soc_tcp_client/app.c\n+++ b/app/wisun/example/wisun_soc_tcp_client/app.c\n\
    @@ -61,11 +61,11 @@ void app_task(void *args)\n   (void) args;\n \n   // connect\
    \ to the wisun network\n-  app_wisun_connect_and_wait();\n+  sl_wisun_app_core_util_connect_and_wait();\n\
    \ \n   while (1) {\n     // User code here\n-    app_wisun_dispatch_thread();\n\
    +    sl_wisun_app_core_util_dispatch_thread();\n   }\n }\n "
  - "--- a/app/wisun/example/wisun_soc_tcp_client/app_init.c\n+++ b/app/wisun/example/wisun_soc_tcp_client/app_init.c\n\
    @@ -36,7 +36,7 @@\n #include \"sl_cmsis_os2_common.h\"\n #include \"sl_wisun_event_mgr.h\"\
    \n #include \"sl_wisun_app_core_util.h\"\n-#include \"sl_wisun_app_core_util_config.h\"\
    \n+#include \"sl_wisun_app_core_config.h\"\n #include \"app.h\"\n #include \"\
    app_custom_callback.h\"\n \n@@ -62,7 +62,7 @@\n void app_init(void)\n {\n   /*\
    \ Init project info */\n-  app_wisun_project_info_init(\"Wi-SUN TCP Client Application\"\
    );\n+  sl_wisun_app_core_util_project_info_init(\"Wi-SUN TCP Client Application\"\
    );\n \n   /* Register callbacks */\n   app_wisun_em_custom_callback_register(SL_WISUN_MSG_CONNECTED_IND_ID,\n\
    @@ -79,7 +79,7 @@ void app_init(void)\n     .cb_mem      = NULL,\n     .cb_size\
    \     = 0,\n     .stack_mem   = NULL,\n-    .stack_size  = app_stack_size_word_to_byte(APP_MAIN_STACK_SIZE_WORD),\n\
    +    .stack_size  = app_stack_size_word_to_byte(SL_WISUN_APP_CORE_MAIN_STACK_SIZE_WORD),\n\
    \     .priority    = osPriorityNormal,\n     .tz_module   = 0\n   };"
  - "--- a/app/wisun/example/wisun_soc_tcp_server/app.c\n+++ b/app/wisun/example/wisun_soc_tcp_server/app.c\n\
    @@ -33,6 +33,7 @@\n #include <stdio.h>\n #include <assert.h>\n #include \"app.h\"\
    \n+#include \"sl_wisun_trace_util.h\"\n \n // -----------------------------------------------------------------------------\n\
    \ //                              Macros and Typedefs\n@@ -69,7 +70,7 @@ void\
    \ app_task(void *args)\n   (void) args;\n \n   // connect to the wisun network\n\
    -  app_wisun_connect_and_wait();\n+  sl_wisun_app_core_util_connect_and_wait();\n\
    \   printf(\"[Port: %u]\\n\", SL_WISUN_TCP_SERVER_PORT);\n \n   // creating socket\n\
    @@ -110,7 +111,7 @@ void app_task(void *args)\n       r = recv(sockd_tcp_clnt,\
    \ buff, SL_WISUN_TCP_SERVER_BUFF_SIZE - 1, 0);\n       switch (r) {\n        \
    \ case -1:\n-          app_wisun_dispatch_thread();\n+          sl_wisun_app_core_util_dispatch_thread();\n\
    \           continue;\n         case 0: // scoket closed, EOF\n           printf(\"\
    [Socket closing: %ld]\\n\", sockd_tcp_clnt);\n@@ -131,7 +132,7 @@ void app_task(void\
    \ *args)\n           break;\n       }\n       // dispatch thread\n-      app_wisun_dispatch_thread();\n\
    +      sl_wisun_app_core_util_dispatch_thread();\n     }\n   }\n }"
  - "--- a/app/wisun/example/wisun_soc_tcp_server/app_init.c\n+++ b/app/wisun/example/wisun_soc_tcp_server/app_init.c\n\
    @@ -37,7 +37,7 @@\n #include \"sl_cmsis_os2_common.h\"\n #include \"sl_wisun_event_mgr.h\"\
    \n #include \"sl_wisun_app_core_util.h\"\n-#include \"sl_wisun_app_core_util_config.h\"\
    \n+#include \"sl_wisun_app_core_config.h\"\n #include \"app.h\"\n #include \"\
    app_custom_callback.h\"\n \n@@ -63,7 +63,7 @@\n void app_init(void)\n {\n   /*\
    \ Init project info */\n-  app_wisun_project_info_init(\"Wi-SUN TCP Server Application\"\
    );\n+  sl_wisun_app_core_util_project_info_init(\"Wi-SUN TCP Server Application\"\
    );\n \n   /* Register callbacks */\n   app_wisun_em_custom_callback_register(SL_WISUN_MSG_CONNECTED_IND_ID,\n\
    @@ -82,7 +82,7 @@ void app_init(void)\n     .cb_mem      = NULL,\n     .cb_size\
    \     = 0,\n     .stack_mem   = NULL,\n-    .stack_size  = app_stack_size_word_to_byte(APP_MAIN_STACK_SIZE_WORD),\n\
    +    .stack_size  = app_stack_size_word_to_byte(SL_WISUN_APP_CORE_MAIN_STACK_SIZE_WORD),\n\
    \     .priority    = osPriorityNormal,\n     .tz_module   = 0\n   };"
  - "--- a/app/wisun/example/wisun_soc_udp_client/app.c\n+++ b/app/wisun/example/wisun_soc_udp_client/app.c\n\
    @@ -61,11 +61,11 @@ void app_task(void *args)\n   (void) args;\n \n   // connect\
    \ to the wisun network\n-  app_wisun_connect_and_wait();\n+  sl_wisun_app_core_util_connect_and_wait();\n\
    \ \n   while (1) {\n     // User code here\n-    app_wisun_dispatch_thread();\n\
    +    sl_wisun_app_core_util_dispatch_thread();\n   }\n }\n "
  - "--- a/app/wisun/example/wisun_soc_udp_client/app_init.c\n+++ b/app/wisun/example/wisun_soc_udp_client/app_init.c\n\
    @@ -37,7 +37,7 @@\n #include \"sl_cmsis_os2_common.h\"\n #include \"sl_wisun_event_mgr.h\"\
    \n #include \"sl_wisun_app_core_util.h\"\n-#include \"sl_wisun_app_core_util_config.h\"\
    \n+#include \"sl_wisun_app_core_config.h\"\n #include \"app.h\"\n #include \"\
    app_custom_callback.h\"\n \n@@ -63,7 +63,7 @@\n void app_init(void)\n {\n   /*\
    \ Init project info */\n-  app_wisun_project_info_init(\"Wi-SUN UDP Client Application\"\
    );\n+  sl_wisun_app_core_util_project_info_init(\"Wi-SUN UDP Client Application\"\
    );\n \n   /* Register callbacks */\n   app_wisun_em_custom_callback_register(SL_WISUN_MSG_CONNECTED_IND_ID,\n\
    @@ -80,7 +80,7 @@ void app_init(void)\n     .cb_mem      = NULL,\n     .cb_size\
    \     = 0,\n     .stack_mem   = NULL,\n-    .stack_size  = app_stack_size_word_to_byte(APP_MAIN_STACK_SIZE_WORD),\n\
    +    .stack_size  = app_stack_size_word_to_byte(SL_WISUN_APP_CORE_MAIN_STACK_SIZE_WORD),\n\
    \     .priority    = osPriorityNormal,\n     .tz_module   = 0\n   };"
  - "--- a/app/wisun/example/wisun_soc_udp_server/app.c\n+++ b/app/wisun/example/wisun_soc_udp_server/app.c\n\
    @@ -33,6 +33,7 @@\n #include <stdio.h>\n #include <assert.h>\n #include \"app.h\"\
    \n+#include \"sl_wisun_trace_util.h\"\n \n // -----------------------------------------------------------------------------\n\
    \ //                              Macros and Typedefs\n@@ -67,11 +68,11 @@ void\
    \ app_task(void *args)\n   (void) args;\n \n   // connect to the wisun network\n\
    -  app_wisun_connect_and_wait();\n+  sl_wisun_app_core_util_connect_and_wait();\n\
    \   printf(\"[Port: %u]\\n\", SL_WISUN_UDP_SERVER_PORT);\n \n   // creating socket\n\
    -  sockd_udp_srv = socket(AF_INET6, (SOCK_DGRAM | SOCK_NONBLOCK), IPPROTO_UDP);\n\
    +  sockd_udp_srv = socket(AF_INET6, SOCK_DGRAM, IPPROTO_UDP);\n   assert_res(sockd_udp_srv,\
    \ \"UDP server socket()\");\n \n   // fill the server address structure\n@@ -100,7\
    \ +101,7 @@ void app_task(void *args)\n       }\n     }\n     // dispatch thread\n\
    -    app_wisun_dispatch_thread();\n+    sl_wisun_app_core_util_dispatch_thread();\n\
    \   }\n }\n "
  - "--- a/app/wisun/example/wisun_soc_udp_server/app_init.c\n+++ b/app/wisun/example/wisun_soc_udp_server/app_init.c\n\
    @@ -37,7 +37,7 @@\n #include \"sl_cmsis_os2_common.h\"\n #include \"sl_wisun_event_mgr.h\"\
    \n #include \"sl_wisun_app_core_util.h\"\n-#include \"sl_wisun_app_core_util_config.h\"\
    \n+#include \"sl_wisun_app_core_config.h\"\n #include \"app.h\"\n #include \"\
    app_custom_callback.h\"\n \n@@ -63,7 +63,7 @@\n void app_init(void)\n {\n   /*\
    \ Init project info */\n-  app_wisun_project_info_init(\"Wi-SUN UDP Server Application\"\
    );\n+  sl_wisun_app_core_util_project_info_init(\"Wi-SUN UDP Server Application\"\
    );\n \n   /* Register callbacks */\n   app_wisun_em_custom_callback_register(SL_WISUN_MSG_CONNECTED_IND_ID,\n\
    @@ -80,7 +80,7 @@ void app_init(void)\n     .cb_mem      = NULL,\n     .cb_size\
    \     = 0,\n     .stack_mem   = NULL,\n-    .stack_size  = app_stack_size_word_to_byte(APP_MAIN_STACK_SIZE_WORD),\n\
    +    .stack_size  = app_stack_size_word_to_byte(SL_WISUN_APP_CORE_MAIN_STACK_SIZE_WORD),\n\
    \     .priority    = osPriorityNormal,\n     .tz_module   = 0\n   };"
  identifiers: CVE:["CVE-2023-39540"],CWE:["CWE-125"]
  overview: Affected versions of this package are vulnerable to Out-of-bounds Read
    in ICMP IPv4 header parsing functionality. An attacker can cause a crash by sending
    a malicious packet.
  references:
    GitHub Commit: https://github.com/SiliconLabs/gecko_sdk/commit/911f6cdefccbae03bc66e8c790ceb7e67ca07417
    Talos Vulnerability Report: https://talosintelligence.com/vulnerability_reports/TALOS-2023-1828
  title: Out-of-bounds Read
- diff_content:
  - "--- a/Server/Source/http-s_req.c\n+++ b/Server/Source/http-s_req.c\n@@ -1444,8\
    \ +1444,8 @@ static  void  HTTPsReq_ProtocolVerParse (HTTPs_INSTANCE  *p_instance,\n\
    \              return;\n     }\n                                             \
    \                    /* Update the RxBuf ptr.                                */\n\
    -    p_conn->RxBufLenRem      -= (p_protocol_ver_end - p_conn->RxBufPtr) + 2;\n\
    -    p_conn->RxBufPtr          =  p_protocol_ver_end + 2;\n+    p_conn->RxBufLenRem\
    \ -= len + STR_CR_LF_LEN;\n+    p_conn->RxBufPtr     = p_protocol_ver_end + STR_CR_LF_LEN;\n\
    \ \n    *p_err = HTTPs_ERR_NONE;\n }"
  identifiers: CVE:["CVE-2023-45318"],CWE:["CWE-122"]
  overview: Affected versions of this package are vulnerable to Buffer Underflow in
    the `p_conn->RxBufLenRem` value in `ttp-s_req.c`, which can be manipulated to
    allow code execution.
  references:
    GitHub Commit: https://github.com/weston-embedded/uC-HTTP/commit/fa84fe9842c96b7cdb5933b9f22bace35e755d1d
    Talos Vulnerability Report: https://talosintelligence.com/vulnerability_reports/TALOS-2023-1843
  title: Buffer Underflow
- diff_content:
  - "--- a/src/mms/iso_mms/server/mms_named_variable_list_service.c\n+++ b/src/mms/iso_mms/server/mms_named_variable_list_service.c\n\
    @@ -130,16 +130,22 @@ mmsServer_handleDeleteNamedVariableListRequest(MmsServerConnection\
    \ connection,\n \t\tgoto exit_function;\n \t}\n \n-\tif ((mmsPdu->present == MmsPdu_PR_confirmedRequestPdu)\
    \ &&\n-\t\t(mmsPdu->choice.confirmedRequestPdu.confirmedServiceRequest.present\n\
    -\t\t== ConfirmedServiceRequest_PR_deleteNamedVariableList))\n-\t{\n-\t\trequest\
    \ = &(mmsPdu->choice.confirmedRequestPdu.confirmedServiceRequest.choice.deleteNamedVariableList);\n\
    -\t}\n-\telse {\n-\t\tmmsMsg_createMmsRejectPdu(&invokeId, MMS_ERROR_REJECT_INVALID_PDU,\
    \ response);\n-\t\tgoto exit_function;\n-\t}\n+    if ((mmsPdu->present == MmsPdu_PR_confirmedRequestPdu)\
    \ &&\n+        (mmsPdu->choice.confirmedRequestPdu.confirmedServiceRequest.present\n\
    +        == ConfirmedServiceRequest_PR_deleteNamedVariableList))\n+    {\n+  \
    \      request = &(mmsPdu->choice.confirmedRequestPdu.confirmedServiceRequest.choice.deleteNamedVariableList);\n\
    +    }\n+    else {\n+        mmsMsg_createMmsRejectPdu(&invokeId, MMS_ERROR_REJECT_INVALID_PDU,\
    \ response);\n+        goto exit_function;\n+    }\n+\n+    if (request->listOfVariableListName\
    \ == NULL)\n+    {\n+        mmsMsg_createMmsRejectPdu(&invokeId, MMS_ERROR_REJECT_INVALID_PDU,\
    \ response);\n+        goto exit_function;\n+    }\n  \n \tlong scopeOfDelete\
    \ = DeleteNamedVariableListRequest__scopeOfDelete_specific;\n "
  identifiers: CVE:["CVE-2024-25366"],CWE:["CWE-190"]
  overview: Affected versions of this package are vulnerable to Integer Overflow or
    Wraparound in the `mmsServer_handleGetNameListRequest` function of the `mms_getnamelist_service`
    component.
  references:
    GitHub Commit: https://github.com/mz-automation/libiec61850/commit/cf94d64206cf53298edf4799a75b31657bb7cbb3
    GitHub Issue: https://github.com/mz-automation/libiec61850/issues/492
  title: Integer Overflow or Wraparound
- diff_content:
  - "--- a/nav2_controller/src/controller_server.cpp\n+++ b/nav2_controller/src/controller_server.cpp\n\
    @@ -290,11 +290,7 @@ ControllerServer::on_deactivate(const rclcpp_lifecycle::State\
    \ & /*state*/)\n    * unordered_set iteration. Once this issue is resolved, we\
    \ can maybe make a stronger\n    * ordering assumption: https://github.com/ros2/rclcpp/issues/2096\n\
    \    */\n-  if (costmap_ros_->get_current_state().id() ==\n-    lifecycle_msgs::msg::State::PRIMARY_STATE_ACTIVE)\n\
    -  {\n-    costmap_ros_->deactivate();\n-  }\n+  costmap_ros_->deactivate();\n\
    \ \n   publishZeroVelocity();\n   vel_publisher_->on_deactivate();\n@@ -320,11\
    \ +316,9 @@ ControllerServer::on_cleanup(const rclcpp_lifecycle::State & /*state*/)\n\
    \ \n   goal_checkers_.clear();\n   progress_checkers_.clear();\n-  if (costmap_ros_->get_current_state().id()\
    \ ==\n-    lifecycle_msgs::msg::State::PRIMARY_STATE_INACTIVE)\n-  {\n-    costmap_ros_->cleanup();\n\
    -  }\n+\n+  costmap_ros_->cleanup();\n+\n \n   // Release any allocated resources\n\
    \   action_server_.reset();"
  - "--- a/nav2_costmap_2d/src/costmap_2d_ros.cpp\n+++ b/nav2_costmap_2d/src/costmap_2d_ros.cpp\n\
    @@ -61,8 +61,8 @@ namespace nav2_costmap_2d\n Costmap2DROS::Costmap2DROS(const\
    \ std::string & name, const bool & use_sim_time)\n : Costmap2DROS(name, \"/\"\
    , name, use_sim_time) {}\n \n-Costmap2DROS::Costmap2DROS()\n-: nav2_util::LifecycleNode(\"\
    costmap\", \"\"),\n+Costmap2DROS::Costmap2DROS(const rclcpp::NodeOptions & options)\n\
    +: nav2_util::LifecycleNode(\"costmap\", \"\", options),\n   name_(\"costmap\"\
    ),\n   default_plugins_{\"static_layer\", \"obstacle_layer\", \"inflation_layer\"\
    },\n   default_types_{\n@@ -71,6 +71,7 @@ Costmap2DROS::Costmap2DROS()\n     \"\
    nav2_costmap_2d::InflationLayer\"}\n {\n   declare_parameter(\"map_topic\", rclcpp::ParameterValue(std::string(\"\
    map\")));\n+  is_lifecycle_follower_ = false;\n   init();\n }\n "
  - "--- a/nav2_costmap_2d/test/unit/lifecycle_test.cpp\n+++ b/nav2_costmap_2d/test/unit/lifecycle_test.cpp\n\
    @@ -22,7 +22,7 @@\n TEST(LifecylceTest, CheckInitialTfTimeout) {\n   rclcpp::init(0,\
    \ nullptr);\n \n-  auto costmap = std::make_shared<nav2_costmap_2d::Costmap2DROS>(\"\
    test_costmap\");\n+  auto costmap = std::make_shared<nav2_costmap_2d::Costmap2DROS>(rclcpp::NodeOptions());\n\
    \   costmap->set_parameter({\"initial_transform_timeout\", 0.0});\n \n   std::thread\
    \ spin_thread{[costmap]() {rclcpp::spin(costmap->get_node_base_interface());}};"
  - "--- a/nav2_planner/src/planner_server.cpp\n+++ b/nav2_planner/src/planner_server.cpp\n\
    @@ -218,11 +218,7 @@ PlannerServer::on_deactivate(const rclcpp_lifecycle::State\
    \ & /*state*/)\n    * unordered_set iteration. Once this issue is resolved, we\
    \ can maybe make a stronger\n    * ordering assumption: https://github.com/ros2/rclcpp/issues/2096\n\
    \    */\n-  if (costmap_ros_->get_current_state().id() ==\n-    lifecycle_msgs::msg::State::PRIMARY_STATE_ACTIVE)\n\
    -  {\n-    costmap_ros_->deactivate();\n-  }\n+  costmap_ros_->deactivate();\n\
    \ \n   PlannerMap::iterator it;\n   for (it = planners_.begin(); it != planners_.end();\
    \ ++it) {\n@@ -247,15 +243,7 @@ PlannerServer::on_cleanup(const rclcpp_lifecycle::State\
    \ & /*state*/)\n   plan_publisher_.reset();\n   tf_.reset();\n \n-  /*\n-   *\
    \ Double check whether something else transitioned it to INACTIVE\n-   * already,\
    \ e.g. the rcl preshutdown callback.\n-   */\n-  if (costmap_ros_->get_current_state().id()\
    \ ==\n-    lifecycle_msgs::msg::State::PRIMARY_STATE_INACTIVE)\n-  {\n-    costmap_ros_->cleanup();\n\
    -  }\n+  costmap_ros_->cleanup();\n \n   PlannerMap::iterator it;\n   for (it\
    \ = planners_.begin(); it != planners_.end(); ++it) {"
  identifiers: CVE:["CVE-2024-25197"],CWE:["CWE-476"]
  overview: Affected versions of this package are vulnerable to NULL Pointer Dereference
    due to the improper handling of objects in the `isCurrent` function at `/src/layered_costmap.cpp`.
  references:
    GitHub Commit: https://github.com/ros-planning/navigation2/commit/aa9396e6c805bc787d8a7f3a46bfc16b1315939b
    GitHub Issue: https://github.com/ros-planning/navigation2/issues/3972
  title: NULL Pointer Dereference
- diff_content:
  - "--- a/nav2_amcl/src/amcl_node.cpp\n+++ b/nav2_amcl/src/amcl_node.cpp\n@@ -328,6\
    \ +328,7 @@ AmclNode::on_cleanup(const rclcpp_lifecycle::State & /*state*/)\n\
    \   nomotion_update_srv_.reset();\n   initial_pose_sub_.reset();\n   laser_scan_connection_.disconnect();\n\
    +  tf_listener_.reset();  //  listener may access lase_scan_filter_, so it should\
    \ be reset earlier\n   laser_scan_filter_.reset();\n   laser_scan_sub_.reset();\n\
    \ \n@@ -341,7 +342,6 @@ AmclNode::on_cleanup(const rclcpp_lifecycle::State & /*state*/)\n\
    \ \n   // Transforms\n   tf_broadcaster_.reset();\n-  tf_listener_.reset();\n\
    \   tf_buffer_.reset();\n \n   // PubSub"
  identifiers: CVE:["CVE-2024-25198"],CWE:["CWE-416"]
  overview: Affected versions of this package are vulnerable to Use After Free due
    to the inappropriate order of pointer operations `laser_scan_filter_.reset()`
    and `tf_listener_.reset()` in `amcl_node.cpp`.
  references:
    GitHub Commit: https://github.com/ros-planning/navigation2/commit/1348e526f4c945ea0c64239f78736c71349a5913
    GitHub PR: https://github.com/ros-planning/navigation2/pull/4070
    Vulnerable Code: https://github.com/ros-planning/navigation2/blob/main/nav2_amcl/src/amcl_node.cpp#L331-L344
  title: Use After Free
- diff_content:
  - "--- a/nav2_amcl/src/amcl_node.cpp\n+++ b/nav2_amcl/src/amcl_node.cpp\n@@ -333,6\
    \ +333,7 @@ AmclNode::on_cleanup(const rclcpp_lifecycle::State & /*state*/)\n\
    \   laser_scan_sub_.reset();\n \n   // Map\n+  map_sub_.reset();  //  map_sub_\
    \ may access map_, so it should be reset earlier\n   if (map_ != NULL) {\n   \
    \  map_free(map_);\n     map_ = nullptr;"
  identifiers: CVE:["CVE-2024-25199"],CWE:["CWE-416"]
  overview: Affected versions of this package are vulnerable to Use After Free due
    to the inappropriate pointer order of `map_sub_` and `map_free(map_)` in `amcl_node.cpp`.
  references:
    GitHub Commit: https://github.com/ros-planning/navigation2/commit/8d191da832d0189131fdc7f93a6d8586a32060c1
    GitHub PR: https://github.com/ros-planning/navigation2/pull/4079
    Vulnerable Code: https://github.com/ros-planning/navigation2/blob/main/nav2_amcl/src/amcl_node.cpp#L331-L344
  title: Use After Free
- diff_content:
  - "--- a/src/dicom-data.c\n+++ b/src/dicom-data.c\n@@ -1391,6 +1391,7 @@ DcmDataSet\
    \ *dcm_dataset_clone(DcmError **error, const DcmDataSet *dataset)\n          \
    \   return NULL;\n         }\n         if (!dcm_dataset_insert(error, cloned_dataset,\
    \ cloned_element)) {\n+            dcm_element_destroy(cloned_element);\n    \
    \         dcm_dataset_destroy(cloned_dataset);\n             return NULL;\n  \
    \       }\n@@ -1435,7 +1436,6 @@ bool dcm_dataset_insert(DcmError **error,\n \
    \                      \"Element already exists\",\n                       \"\
    Inserting Data Element '%08x' into Data Set failed\",\n                      \
    \ element->tag);\n-        dcm_element_destroy(element);\n         return false;\n\
    \     }\n \n@@ -1707,7 +1707,6 @@ DcmDataSet *dcm_sequence_steal(DcmError **error,\n\
    \     }\n \n     DcmDataSet *result = seq_item->dataset;\n-    //dcm_dataset_lock(result);\n\
    \     seq_item->dataset = NULL;\n     // this will free the SequenceItem\n   \
    \  utarray_erase(seq->items, index, 1);"
  identifiers: CVE:["CVE-2024-24793"],CWE:["CWE-416"]
  overview: Affected versions of this package are vulnerable to Use After Free in
    the `parse_meta_element_create` function. An attacker can execute arbitrary code
    or cause a denial of service condition by causing the vulnerable application to
    process a malicious DICOM image.
  references:
    GitHub Commit: https://github.com/ImagingDataCommons/libdicom/commit/e0f07cf89f5bd2121f935b9cef9c39797ef527a5
    Talos Vulnerability Report: https://talosintelligence.com/vulnerability_reports/TALOS-2024-1931
  title: Use After Free
- diff_content:
  - "--- a/src/dicom-data.c\n+++ b/src/dicom-data.c\n@@ -1391,6 +1391,7 @@ DcmDataSet\
    \ *dcm_dataset_clone(DcmError **error, const DcmDataSet *dataset)\n          \
    \   return NULL;\n         }\n         if (!dcm_dataset_insert(error, cloned_dataset,\
    \ cloned_element)) {\n+            dcm_element_destroy(cloned_element);\n    \
    \         dcm_dataset_destroy(cloned_dataset);\n             return NULL;\n  \
    \       }\n@@ -1435,7 +1436,6 @@ bool dcm_dataset_insert(DcmError **error,\n \
    \                      \"Element already exists\",\n                       \"\
    Inserting Data Element '%08x' into Data Set failed\",\n                      \
    \ element->tag);\n-        dcm_element_destroy(element);\n         return false;\n\
    \     }\n \n@@ -1707,7 +1707,6 @@ DcmDataSet *dcm_sequence_steal(DcmError **error,\n\
    \     }\n \n     DcmDataSet *result = seq_item->dataset;\n-    //dcm_dataset_lock(result);\n\
    \     seq_item->dataset = NULL;\n     // this will free the SequenceItem\n   \
    \  utarray_erase(seq->items, index, 1);"
  identifiers: CVE:["CVE-2024-24794"],CWE:["CWE-415"]
  overview: Affected versions of this package are vulnerable to Double Free in the
    `parse_meta_sequence_end` function. An attacker can execute arbitrary code or
    cause a denial of service by causing the vulnerable application to process a malicious
    DICOM image.
  references:
    GitHub Commit: https://github.com/ImagingDataCommons/libdicom/commit/e0f07cf89f5bd2121f935b9cef9c39797ef527a5
    Talos Vulnerability Report: https://talosintelligence.com/vulnerability_reports/TALOS-2024-1931
  title: Double Free
- diff_content:
  - "--- a/subsys/bluetooth/host/gatt.c\n+++ b/subsys/bluetooth/host/gatt.c\n@@ -3113,7\
    \ +3113,8 @@ uint8_t bt_gatt_check_perm(struct bt_conn *conn, const struct bt_gatt_attr\
    \ *attr\n \t * the error code \u201CInsufficient Encryption\u201D.\n \t */\n \n\
    -\tif (mask & (BT_GATT_PERM_ENCRYPT_MASK | BT_GATT_PERM_AUTHEN_MASK)) {\n+\tif\
    \ (mask &\n+\t    (BT_GATT_PERM_ENCRYPT_MASK | BT_GATT_PERM_AUTHEN_MASK | BT_GATT_PERM_LESC_MASK))\
    \ {\n #if defined(CONFIG_BT_SMP)\n \t\tif (!conn->encrypt) {\n \t\t\tif (bt_conn_ltk_present(conn))\
    \ {"
  identifiers: CVE:["CVE-2024-1638"],CWE:["CWE-732"]
  overview: Affected versions of this package are vulnerable to Incorrect Permission
    Assignment for Critical Resource in handling Bluetooth characteristic attributes
    in `gatt.c`. Without specifying additional permissions such as `BT_GATT_PERM_READ_ENCRYPT`/`BT_GATT_PERM_READ_AUTHEN`
    for read operations or `BT_GATT_PERM_WRITE_ENCRYPT`/`BT_GATT_PERM_WRITE_AUTHEN`
    for write operations, even in secure connections only mode, leads to the absence
    of permission checks when `BT_GATT_PERM_READ_LESC` or `BT_GATT_PERM_WRITE_LESC`
    are set.
  references:
    GitHub Commit: https://github.com/zephyrproject-rtos/zephyr/commit/d9ff7eb0eda36b4b70e5c5badfd6661c1ddfe626
  title: Incorrect Permission Assignment for Critical Resource
- diff_content:
  - "--- a/src/cpp/rtps/builtin/discovery/endpoint/EDPSimple.cpp\n+++ b/src/cpp/rtps/builtin/discovery/endpoint/EDPSimple.cpp\n\
    @@ -382,90 +382,21 @@ void EDPSimple::set_builtin_writer_history_attributes(\n\
    \ void EDPSimple::set_builtin_reader_attributes(\n         ReaderAttributes& attributes)\n\
    \ {\n-    const RTPSParticipantAttributes& pattr = mp_PDP->getRTPSParticipant()->getRTPSParticipantAttributes();\n\
    -\n-    // Matched writers will depend on total number of participants\n-    attributes.matched_writers_allocation\
    \ = pattr.allocation.participants;\n-\n-    // As participants allocation policy\
    \ includes the local participant, one has to be substracted\n-    if (attributes.matched_writers_allocation.initial\
    \ > 1)\n-    {\n-        attributes.matched_writers_allocation.initial--;\n- \
    \   }\n-    if ((attributes.matched_writers_allocation.maximum > 1) &&\n-    \
    \        (attributes.matched_writers_allocation.maximum < std::numeric_limits<size_t>::max()))\n\
    -    {\n-        attributes.matched_writers_allocation.maximum--;\n-    }\n-\n\
    -    // Locators are copied from the local participant metatraffic locators\n\
    -    attributes.endpoint.unicastLocatorList.clear();\n-    for (const Locator_t&\
    \ loc : mp_PDP->getLocalParticipantProxyData()->metatraffic_locators.unicast)\n\
    -    {\n-        attributes.endpoint.unicastLocatorList.push_back(loc);\n-   \
    \ }\n-    attributes.endpoint.multicastLocatorList.clear();\n-    for (const Locator_t&\
    \ loc : mp_PDP->getLocalParticipantProxyData()->metatraffic_locators.multicast)\n\
    -    {\n-        attributes.endpoint.multicastLocatorList.push_back(loc);\n- \
    \   }\n-    attributes.endpoint.external_unicast_locators = mp_PDP->builtin_attributes().metatraffic_external_unicast_locators;\n\
    -    attributes.endpoint.ignore_non_matching_locators = pattr.ignore_non_matching_locators;\n\
    +    attributes = mp_PDP->create_builtin_reader_attributes();\n \n     // Timings\
    \ are configured using EDP default values\n     attributes.times.heartbeatResponseDelay\
    \ = edp_heartbeat_response_delay;\n-\n-    // EDP endpoints are always reliable,\
    \ transsient local, keyed topics\n-    attributes.endpoint.reliabilityKind = RELIABLE;\n\
    -    attributes.endpoint.durabilityKind = TRANSIENT_LOCAL;\n-    attributes.endpoint.topicKind\
    \ = WITH_KEY;\n-\n-    // Built-in EDP readers never expect inline qos\n-    attributes.expectsInlineQos\
    \ = false;\n }\n \n void EDPSimple::set_builtin_writer_attributes(\n         WriterAttributes&\
    \ attributes)\n {\n-    const RTPSParticipantAttributes& pattr = mp_PDP->getRTPSParticipant()->getRTPSParticipantAttributes();\n\
    -\n-    // Matched readers will depend on total number of participants\n-    attributes.matched_readers_allocation\
    \ = pattr.allocation.participants;\n-\n-    // As participants allocation policy\
    \ includes the local participant, one has to be substracted\n-    if (attributes.matched_readers_allocation.initial\
    \ > 1)\n-    {\n-        attributes.matched_readers_allocation.initial--;\n- \
    \   }\n-    if ((attributes.matched_readers_allocation.maximum > 1) &&\n-    \
    \        (attributes.matched_readers_allocation.maximum < std::numeric_limits<size_t>::max()))\n\
    -    {\n-        attributes.matched_readers_allocation.maximum--;\n-    }\n-\n\
    -    // Locators are copied from the local participant metatraffic locators\n\
    -    attributes.endpoint.unicastLocatorList.clear();\n-    for (const Locator_t&\
    \ loc : mp_PDP->getLocalParticipantProxyData()->metatraffic_locators.unicast)\n\
    -    {\n-        attributes.endpoint.unicastLocatorList.push_back(loc);\n-   \
    \ }\n-    attributes.endpoint.multicastLocatorList.clear();\n-    for (const Locator_t&\
    \ loc : mp_PDP->getLocalParticipantProxyData()->metatraffic_locators.multicast)\n\
    -    {\n-        attributes.endpoint.multicastLocatorList.push_back(loc);\n- \
    \   }\n-    attributes.endpoint.external_unicast_locators = mp_PDP->builtin_attributes().metatraffic_external_unicast_locators;\n\
    -    attributes.endpoint.ignore_non_matching_locators = pattr.ignore_non_matching_locators;\n\
    +    attributes = mp_PDP->create_builtin_writer_attributes();\n \n     // Timings\
    \ are configured using EDP default values\n     attributes.times.heartbeatPeriod\
    \ = edp_heartbeat_period;\n     attributes.times.nackResponseDelay = edp_nack_response_delay;\n\
    \     attributes.times.nackSupressionDuration = edp_nack_supression_duration;\n\
    -\n-    // EDP endpoints are always reliable, transsient local, keyed topics\n\
    -    attributes.endpoint.reliabilityKind = RELIABLE;\n-    attributes.endpoint.durabilityKind\
    \ = TRANSIENT_LOCAL;\n-    attributes.endpoint.topicKind = WITH_KEY;\n }\n \n\
    \ bool EDPSimple::createSEDPEndpoints()\n@@ -537,34 +468,7 @@ bool EDPSimple::create_sedp_secure_endpoints()\n\
    \     set_builtin_writer_history_attributes(writer_history_att);\n     set_builtin_reader_attributes(ratt);\n\
    \     set_builtin_writer_attributes(watt);\n-\n-    const security::ParticipantSecurityAttributes&\
    \ part_attr = mp_RTPSParticipant->security_attributes();\n-\n-    ratt.endpoint.security_attributes().is_submessage_protected\
    \ = part_attr.is_discovery_protected;\n-    ratt.endpoint.security_attributes().plugin_endpoint_attributes\
    \ = PLUGIN_ENDPOINT_SECURITY_ATTRIBUTES_FLAG_IS_VALID;\n-\n-    watt.endpoint.security_attributes().is_submessage_protected\
    \ = part_attr.is_discovery_protected;\n-    watt.endpoint.security_attributes().plugin_endpoint_attributes\
    \ = PLUGIN_ENDPOINT_SECURITY_ATTRIBUTES_FLAG_IS_VALID;\n-\n-    if (part_attr.is_discovery_protected)\n\
    -    {\n-        security::PluginParticipantSecurityAttributes plugin_part_attr(part_attr.plugin_participant_attributes);\n\
    -\n-        if (plugin_part_attr.is_discovery_encrypted)\n-        {\n-      \
    \      ratt.endpoint.security_attributes().plugin_endpoint_attributes |=\n-  \
    \                  PLUGIN_ENDPOINT_SECURITY_ATTRIBUTES_FLAG_IS_SUBMESSAGE_ENCRYPTED;\n\
    -            watt.endpoint.security_attributes().plugin_endpoint_attributes |=\n\
    -                    PLUGIN_ENDPOINT_SECURITY_ATTRIBUTES_FLAG_IS_SUBMESSAGE_ENCRYPTED;\n\
    -        }\n-        if (plugin_part_attr.is_discovery_origin_authenticated)\n\
    -        {\n-            ratt.endpoint.security_attributes().plugin_endpoint_attributes\
    \ |=\n-                    PLUGIN_ENDPOINT_SECURITY_ATTRIBUTES_FLAG_IS_SUBMESSAGE_ORIGIN_AUTHENTICATED;\n\
    -            watt.endpoint.security_attributes().plugin_endpoint_attributes |=\n\
    -                    PLUGIN_ENDPOINT_SECURITY_ATTRIBUTES_FLAG_IS_SUBMESSAGE_ORIGIN_AUTHENTICATED;\n\
    -        }\n-    }\n+    mp_PDP->add_builtin_security_attributes(ratt, watt);\n\
    \ \n     if (m_discovery.discovery_config.m_simpleEDP.enable_builtin_secure_publications_writer_and_subscriptions_reader)\n\
    \     {"
  - "--- a/src/cpp/rtps/builtin/discovery/participant/DS/PDPSecurityInitiatorListener.cpp\n\
    +++ b/src/cpp/rtps/builtin/discovery/participant/DS/PDPSecurityInitiatorListener.cpp\n\
    @@ -23,6 +23,7 @@\n \n #include <fastdds/rtps/builtin/discovery/endpoint/EDP.h>\n\
    \ #include <fastdds/rtps/builtin/discovery/participant/PDP.h>\n+#include <fastdds/rtps/builtin/discovery/participant/PDPListener.h>\n\
    \ #include <fastdds/rtps/history/ReaderHistory.h>\n #include <fastdds/rtps/participant/ParticipantDiscoveryInfo.h>\n\
    \ #include <fastdds/rtps/participant/RTPSParticipantListener.h>\n@@ -47,121 +48,44\
    \ @@ namespace rtps {\n PDPSecurityInitiatorListener::PDPSecurityInitiatorListener(\n\
    \         PDP* parent,\n         SecurityInitiatedCallback response_cb)\n-   \
    \ : parent_pdp_(parent)\n-    , temp_participant_data_(parent->getRTPSParticipant()->getRTPSParticipantAttributes().allocation)\n\
    +    : PDPListener(parent)\n     , response_cb_(response_cb)\n {\n }\n \n-void\
    \ PDPSecurityInitiatorListener::onNewCacheChangeAdded(\n+void PDPSecurityInitiatorListener::process_alive_data(\n\
    +        ParticipantProxyData* old_data,\n+        ParticipantProxyData& new_data,\n\
    +        GUID_t& writer_guid,\n         RTPSReader* reader,\n-        const CacheChange_t*\
    \ const change_in)\n+        std::unique_lock<std::recursive_mutex>& lock)\n {\n\
    -    CacheChange_t* change = const_cast<CacheChange_t*>(change_in);\n-    GUID_t\
    \ writer_guid = change->writerGUID;\n-    EPROSIMA_LOG_INFO(RTPS_PDP, \"SPDP Message\
    \ received from: \" << change_in->writerGUID);\n-\n-    // Make sure we have an\
    \ instance handle (i.e GUID)\n-    if (change->instanceHandle == c_InstanceHandle_Unknown)\n\
    +    if (reader->matched_writer_is_matched(writer_guid))\n     {\n-        if\
    \ (!this->get_key(change))\n-        {\n-            EPROSIMA_LOG_WARNING(RTPS_PDP,\
    \ \"Problem getting the key of the change, removing\");\n-            parent_pdp_->builtin_endpoints_->remove_from_pdp_reader_history(change);\n\
    -            return;\n-        }\n+        // Act as the standard PDPListener\
    \ when the writer is matched.\n+        // This will be the case for unauthenticated\
    \ participants when\n+        // allowed_unathenticated_participants is true\n\
    +        PDPListener::process_alive_data(old_data, new_data, writer_guid, reader,\
    \ lock);\n+        return;\n     }\n \n-    // Take GUID from instance handle\n\
    -    GUID_t guid;\n-    iHandle2GUID(guid, change->instanceHandle);\n-\n-    if\
    \ (change->kind == ALIVE)\n+    if (old_data == nullptr)\n     {\n-        //\
    \ Ignore announcement from own RTPSParticipant\n-        if (guid == parent_pdp_->getRTPSParticipant()->getGuid())\n\
    -        {\n-            EPROSIMA_LOG_INFO(RTPS_PDP, \"Message from own RTPSParticipant,\
    \ removing\");\n-            parent_pdp_->builtin_endpoints_->remove_from_pdp_reader_history(change);\n\
    -            return;\n-        }\n-\n-        // Release reader lock to avoid\
    \ ABBA lock. PDP mutex should always be first.\n-        // Keep change information\
    \ on local variables to check consistency later\n-        SequenceNumber_t seq_num\
    \ = change->sequenceNumber;\n         reader->getMutex().unlock();\n-        std::unique_lock<std::recursive_mutex>\
    \ lock(*parent_pdp_->getMutex());\n-        reader->getMutex().lock();\n-\n- \
    \       // If change is not consistent, it will be processed on the thread that\
    \ has overriten it\n-        if ((ALIVE != change->kind) || (seq_num != change->sequenceNumber)\
    \ || (writer_guid != change->writerGUID))\n-        {\n-            return;\n\
    -        }\n-\n-        // Access to temp_participant_data_ is protected by reader\
    \ lock\n+        lock.unlock();\n \n-        // Load information on temp_participant_data_\n\
    -        CDRMessage_t msg(change->serializedPayload);\n-        temp_participant_data_.clear();\n\
    -        if (temp_participant_data_.readFromCDRMessage(&msg, true, parent_pdp_->getRTPSParticipant()->network_factory(),\n\
    -                parent_pdp_->getRTPSParticipant()->has_shm_transport(), true))\n\
    +        //! notify security manager in order to start handshake\n+        bool\
    \ ret = parent_pdp_->getRTPSParticipant()->security_manager().discovered_participant(new_data);\n\
    +        //! Reply to the remote participant\n+        if (ret)\n         {\n\
    -            // After correctly reading it\n-            change->instanceHandle\
    \ = temp_participant_data_.m_key;\n-            guid = temp_participant_data_.m_guid;\n\
    -\n-            // Filter locators\n-            const auto& pattr = parent_pdp_->getRTPSParticipant()->getAttributes();\n\
    -            fastdds::rtps::ExternalLocatorsProcessor::filter_remote_locators(temp_participant_data_,\n\
    -                    pattr.builtin.metatraffic_external_unicast_locators, pattr.default_external_unicast_locators,\n\
    -                    pattr.ignore_non_matching_locators);\n-\n-            //\
    \ Check if participant already exists (updated info)\n-            ParticipantProxyData*\
    \ pdata = nullptr;\n-            for (ParticipantProxyData* it : parent_pdp_->participant_proxies_)\n\
    -            {\n-                if (guid == it->m_guid)\n-                {\n\
    -                    pdata = it;\n-                    break;\n-             \
    \   }\n-            }\n-\n-            if (pdata == nullptr)\n-            {\n\
    -                // Create a new one when not found\n-\n-                reader->getMutex().unlock();\n\
    -                lock.unlock();\n-\n-                //! notify security manager\
    \ in order to start handshake\n-                bool ret = parent_pdp_->getRTPSParticipant()->security_manager().discovered_participant(\n\
    -                    temp_participant_data_);\n-\n-                //! Reply to\
    \ the remote participant\n-                if (ret)\n-                {\n-   \
    \                 response_cb_(temp_participant_data_);\n-                }\n\
    -\n-                // Take again the reader lock\n-                reader->getMutex().lock();\n\
    -\n-            } //! Do nothing if already discovered\n-\n+            response_cb_(temp_participant_data_);\n\
    \         }\n \n-    } //! Do nothing on participant removal\n-\n-    //Remove\
    \ change form history.\n-    parent_pdp_->builtin_endpoints_->remove_from_pdp_reader_history(change);\n\
    -}\n+        // Take again the reader lock\n+        reader->getMutex().lock();\n\
    +    }\n \n-bool PDPSecurityInitiatorListener::get_key(\n-        CacheChange_t*\
    \ change)\n-{\n-    return ParameterList::readInstanceHandleFromCDRMsg(change,\
    \ fastdds::dds::PID_PARTICIPANT_GUID);\n }\n \n } /* namespace rtps */"
  - "--- a/src/cpp/rtps/builtin/discovery/participant/PDP.cpp\n+++ b/src/cpp/rtps/builtin/discovery/participant/PDP.cpp\n\
    @@ -93,7 +91,6 @@ PDP::PDP (\n     , writer_proxies_number_(allocation.total_writers().initial)\n\
    \     , writer_proxies_pool_(allocation.total_writers())\n     , m_hasChangedLocalPDP(true)\n\
    -    , mp_listener(nullptr)\n     , temp_reader_proxies_({\n                 allocation.locators.max_unicast_locators,\n\
    \                 allocation.locators.max_multicast_locators,\n@@ -141,9 +138,6\
    \ @@ PDP::~PDP()\n     builtin_endpoints_->delete_pdp_endpoints(mp_RTPSParticipant);\n\
    \     builtin_endpoints_.reset();\n \n-    delete mp_listener;\n-    mp_listener\
    \ = nullptr;\n-\n     for (ParticipantProxyData* it : participant_proxies_)\n\
    \     {\n         delete it;\n@@ -524,7 +518,9 @@ void PDP::announceParticipantState(\n\
    \         else\n         {\n             this->mp_mutex->lock();\n-          \
    \  ParticipantProxyData proxy_data_copy(*getLocalParticipantProxyData());\n+ \
    \           ParticipantProxyData* local_participant_data = getLocalParticipantProxyData();\n\
    +            InstanceHandle_t key = local_participant_data->m_key;\n+        \
    \    ParticipantProxyData proxy_data_copy(*local_participant_data);\n        \
    \     this->mp_mutex->unlock();\n \n             if (history.getHistorySize()\
    \ > 0)\n@@ -536,7 +532,7 @@ void PDP::announceParticipantState(\n            \
    \                 {\n                                 return cdr_size;\n     \
    \                        },\n-                            NOT_ALIVE_DISPOSED_UNREGISTERED,\
    \ getLocalParticipantProxyData()->m_key);\n+                            NOT_ALIVE_DISPOSED_UNREGISTERED,\
    \ key);\n \n             if (change != nullptr)\n             {\n@@ -581,6 +577,39\
    \ @@ void PDP::resetParticipantAnnouncement()\n     }\n }\n \n+void PDP::notify_and_maybe_ignore_new_participant(\n\
    +        ParticipantProxyData* pdata,\n+        bool& should_be_ignored)\n+{\n\
    +    should_be_ignored = false;\n+\n+    EPROSIMA_LOG_INFO(RTPS_PDP_DISCOVERY,\
    \ \"New participant \"\n+            << pdata->m_guid << \" at \"\n+         \
    \   << \"MTTLoc: \" << pdata->metatraffic_locators\n+            << \" DefLoc:\"\
    \ << pdata->default_locators);\n+\n+    RTPSParticipantListener* listener = getRTPSParticipant()->getListener();\n\
    +    if (listener != nullptr)\n+    {\n+        {\n+            std::lock_guard<std::mutex>\
    \ cb_lock(callback_mtx_);\n+            ParticipantDiscoveryInfo info(*pdata);\n\
    +            info.status = ParticipantDiscoveryInfo::DISCOVERED_PARTICIPANT;\n\
    +\n+\n+            listener->onParticipantDiscovery(\n+                getRTPSParticipant()->getUserRTPSParticipant(),\n\
    +                std::move(info),\n+                should_be_ignored);\n+   \
    \     }\n+\n+        if (should_be_ignored)\n+        {\n+            getRTPSParticipant()->ignore_participant(pdata->m_guid.guidPrefix);\n\
    +        }\n+    }\n+}\n+\n bool PDP::has_reader_proxy_data(\n         const GUID_t&\
    \ reader)\n {\n@@ -1461,6 +1490,131 @@ void PDP::set_external_participant_properties_(\n\
    \     }\n }\n \n+static void set_builtin_matched_allocation(\n+        ResourceLimitedContainerConfig&\
    \ allocation,\n+        const RTPSParticipantAttributes& pattr)\n+{\n+    // Matched\
    \ endpoints will depend on total number of participants\n+    allocation = pattr.allocation.participants;\n\
    +\n+    // As participants allocation policy includes the local participant, one\
    \ has to be substracted\n+    if (allocation.initial > 1)\n+    {\n+        allocation.initial--;\n\
    +    }\n+    if ((allocation.maximum > 1) &&\n+            (allocation.maximum\
    \ < std::numeric_limits<size_t>::max()))\n+    {\n+        allocation.maximum--;\n\
    +    }\n+}\n+\n+static void set_builtin_endpoint_locators(\n+        EndpointAttributes&\
    \ endpoint,\n+        const PDP* pdp,\n+        const BuiltinProtocols* builtin)\n\
    +{\n+    const RTPSParticipantAttributes& pattr = pdp->getRTPSParticipant()->getRTPSParticipantAttributes();\n\
    +\n+    auto part_data = pdp->getLocalParticipantProxyData();\n+    if (nullptr\
    \ == part_data)\n+    {\n+        // Local participant data has not yet been created.\n\
    +        // This means we are creating the PDP endpoints, so we copy the locators\
    \ from mp_builtin\n+        endpoint.multicastLocatorList = builtin->m_metatrafficMulticastLocatorList;\n\
    +        endpoint.unicastLocatorList = builtin->m_metatrafficUnicastLocatorList;\n\
    +    }\n+    else\n+    {\n+        // Locators are copied from the local participant\
    \ metatraffic locators\n+        endpoint.unicastLocatorList.clear();\n+     \
    \   for (const Locator_t& loc : part_data->metatraffic_locators.unicast)\n+  \
    \      {\n+            endpoint.unicastLocatorList.push_back(loc);\n+        }\n\
    +        endpoint.multicastLocatorList.clear();\n+        for (const Locator_t&\
    \ loc : part_data->metatraffic_locators.multicast)\n+        {\n+            endpoint.multicastLocatorList.push_back(loc);\n\
    +        }\n+    }\n+\n+    // External locators are always taken from the same\
    \ place\n+    endpoint.external_unicast_locators = pdp->builtin_attributes().metatraffic_external_unicast_locators;\n\
    +    endpoint.ignore_non_matching_locators = pattr.ignore_non_matching_locators;\n\
    +}\n+\n+ReaderAttributes PDP::create_builtin_reader_attributes() const\n+{\n+\
    \    ReaderAttributes attributes;\n+\n+    const RTPSParticipantAttributes& pattr\
    \ = getRTPSParticipant()->getRTPSParticipantAttributes();\n+    set_builtin_matched_allocation(attributes.matched_writers_allocation,\
    \ pattr);\n+    set_builtin_endpoint_locators(attributes.endpoint, this, mp_builtin);\n\
    +\n+    // Builtin endpoints are always reliable, transient local, keyed topics\n\
    +    attributes.endpoint.reliabilityKind = RELIABLE;\n+    attributes.endpoint.durabilityKind\
    \ = TRANSIENT_LOCAL;\n+    attributes.endpoint.topicKind = WITH_KEY;\n+\n+   \
    \ // Built-in readers never expect inline qos\n+    attributes.expectsInlineQos\
    \ = false;\n+\n+    return attributes;\n+}\n+\n+WriterAttributes PDP::create_builtin_writer_attributes()\
    \ const\n+{\n+    WriterAttributes attributes;\n+\n+    const RTPSParticipantAttributes&\
    \ pattr = getRTPSParticipant()->getRTPSParticipantAttributes();\n+    set_builtin_matched_allocation(attributes.matched_readers_allocation,\
    \ pattr);\n+    set_builtin_endpoint_locators(attributes.endpoint, this, mp_builtin);\n\
    +\n+    // Builtin endpoints are always reliable, transient local, keyed topics\n\
    +    attributes.endpoint.reliabilityKind = RELIABLE;\n+    attributes.endpoint.durabilityKind\
    \ = TRANSIENT_LOCAL;\n+    attributes.endpoint.topicKind = WITH_KEY;\n+\n+   \
    \ return attributes;\n+}\n+\n+#if HAVE_SECURITY\n+void PDP::add_builtin_security_attributes(\n\
    +        ReaderAttributes& ratt,\n+        WriterAttributes& watt) const\n+{\n\
    +    const security::ParticipantSecurityAttributes& part_attr = mp_RTPSParticipant->security_attributes();\n\
    +\n+    ratt.endpoint.security_attributes().is_submessage_protected = part_attr.is_discovery_protected;\n\
    +    ratt.endpoint.security_attributes().plugin_endpoint_attributes = PLUGIN_ENDPOINT_SECURITY_ATTRIBUTES_FLAG_IS_VALID;\n\
    +\n+    watt.endpoint.security_attributes().is_submessage_protected = part_attr.is_discovery_protected;\n\
    +    watt.endpoint.security_attributes().plugin_endpoint_attributes = PLUGIN_ENDPOINT_SECURITY_ATTRIBUTES_FLAG_IS_VALID;\n\
    +\n+    if (part_attr.is_discovery_protected)\n+    {\n+        security::PluginParticipantSecurityAttributes\
    \ plugin_part_attr(part_attr.plugin_participant_attributes);\n+\n+        if (plugin_part_attr.is_discovery_encrypted)\n\
    +        {\n+            ratt.endpoint.security_attributes().plugin_endpoint_attributes\
    \ |=\n+                    PLUGIN_ENDPOINT_SECURITY_ATTRIBUTES_FLAG_IS_SUBMESSAGE_ENCRYPTED;\n\
    +            watt.endpoint.security_attributes().plugin_endpoint_attributes |=\n\
    +                    PLUGIN_ENDPOINT_SECURITY_ATTRIBUTES_FLAG_IS_SUBMESSAGE_ENCRYPTED;\n\
    +        }\n+        if (plugin_part_attr.is_discovery_origin_authenticated)\n\
    +        {\n+            ratt.endpoint.security_attributes().plugin_endpoint_attributes\
    \ |=\n+                    PLUGIN_ENDPOINT_SECURITY_ATTRIBUTES_FLAG_IS_SUBMESSAGE_ORIGIN_AUTHENTICATED;\n\
    +            watt.endpoint.security_attributes().plugin_endpoint_attributes |=\n\
    +                    PLUGIN_ENDPOINT_SECURITY_ATTRIBUTES_FLAG_IS_SUBMESSAGE_ORIGIN_AUTHENTICATED;\n\
    +        }\n+    }\n+}\n+\n+#endif // HAVE_SECURITY\n+\n } /* namespace rtps */\n\
    \ } /* namespace fastrtps */\n } /* namespace eprosima */"
  - "--- a/src/cpp/rtps/builtin/discovery/participant/PDPClient.cpp\n+++ b/src/cpp/rtps/builtin/discovery/participant/PDPClient.cpp\n\
    @@ -278,26 +278,20 @@ bool PDPClient::create_ds_pdp_best_effort_reader(\n    \
    \ ratt.endpoint.durabilityKind = VOLATILE;\n     ratt.endpoint.reliabilityKind\
    \ = BEST_EFFORT;\n \n-    endpoints.stateless_listener.reset(new PDPSecurityInitiatorListener(this));\n\
    +    endpoints.stateless_reader.listener_.reset(new PDPSecurityInitiatorListener(this));\n\
    \ \n     // Create PDP Reader\n     RTPSReader* reader = nullptr;\n     if (mp_RTPSParticipant->createReader(&reader,\
    \ ratt, endpoints.stateless_reader.history_.get(),\n-            endpoints.stateless_listener.get(),\
    \ c_EntityId_SPDPReader, true, false))\n+            endpoints.stateless_reader.listener_.get(),\
    \ c_EntityId_SPDPReader, true, false))\n     {\n         endpoints.stateless_reader.reader_\
    \ = dynamic_cast<fastrtps::rtps::StatelessReader*>(reader);\n-\n-        // Enable\
    \ unknown clients to reach this reader\n-        reader->enableMessagesFromUnkownWriters(true);\n\
    -\n         mp_RTPSParticipant->set_endpoint_rtps_protection_supports(reader,\
    \ false);\n     }\n     // Could not create PDP Reader, so return false\n    \
    \ else\n     {\n         EPROSIMA_LOG_ERROR(RTPS_PDP_SERVER, \"PDPServer security\
    \ initiation Reader creation failed\");\n-\n-        endpoints.stateless_listener.reset();\n\
    \         endpoints.stateless_reader.release();\n         return false;\n    \
    \ }\n@@ -360,7 +354,7 @@ bool PDPClient::create_ds_pdp_reliable_endpoints(\n \
    \    }\n #endif // HAVE_SECURITY\n \n-    mp_listener = new PDPListener(this);\n\
    +    endpoints.reader.listener_.reset(new PDPListener(this));\n \n     RTPSReader*\
    \ reader = nullptr;\n #if HAVE_SECURITY\n@@ -369,7 +363,8 @@ bool PDPClient::create_ds_pdp_reliable_endpoints(\n\
    \ #else\n     EntityId_t reader_entity = c_EntityId_SPDPReader;\n #endif // if\
    \ HAVE_SECURITY\n-    if (mp_RTPSParticipant->createReader(&reader, ratt, endpoints.reader.history_.get(),\
    \ mp_listener,\n+    if (mp_RTPSParticipant->createReader(&reader, ratt, endpoints.reader.history_.get(),\n\
    +            endpoints.reader.listener_.get(),\n             reader_entity, true,\
    \ false))\n     {\n         endpoints.reader.reader_ = dynamic_cast<fastrtps::rtps::StatefulReader*>(reader);\n\
    @@ -381,8 +376,6 @@ bool PDPClient::create_ds_pdp_reliable_endpoints(\n     else\n\
    \     {\n         EPROSIMA_LOG_ERROR(RTPS_PDP, \"PDPClient Reader creation failed\"\
    );\n-        delete mp_listener;\n-        mp_listener = nullptr;\n         endpoints.reader.release();\n\
    \         return false;\n     }\n@@ -483,25 +476,30 @@ bool PDPClient::create_ds_pdp_reliable_endpoints(\n\
    \ void PDPClient::assignRemoteEndpoints(\n         ParticipantProxyData* pdata)\n\
    \ {\n+    bool ignored = false;\n+    notify_and_maybe_ignore_new_participant(pdata,\
    \ ignored);\n+    if (!ignored)\n     {\n-        eprosima::shared_lock<eprosima::shared_mutex>\
    \ disc_lock(mp_builtin->getDiscoveryMutex());\n-\n-        // Verify if this participant\
    \ is a server\n-        for (auto& svr : mp_builtin->m_DiscoveryServers)\n   \
    \      {\n-            if (data_matches_with_prefix(svr.guidPrefix, *pdata))\n\
    +            eprosima::shared_lock<eprosima::shared_mutex> disc_lock(mp_builtin->getDiscoveryMutex());\n\
    +\n+            // Verify if this participant is a server\n+            for (auto&\
    \ svr : mp_builtin->m_DiscoveryServers)\n             {\n-                std::unique_lock<std::recursive_mutex>\
    \ lock(*getMutex());\n-                svr.proxy = pdata;\n+                if\
    \ (data_matches_with_prefix(svr.guidPrefix, *pdata))\n+                {\n+  \
    \                  std::unique_lock<std::recursive_mutex> lock(*getMutex());\n\
    +                    svr.proxy = pdata;\n+                }\n             }\n\
    \         }\n-    }\n \n #if HAVE_SECURITY\n-    if (mp_RTPSParticipant->security_manager().discovered_participant(*pdata))\n\
    +        if (mp_RTPSParticipant->security_manager().discovered_participant(*pdata))\n\
    \ #endif // HAVE_SECURITY\n-    {\n-        perform_builtin_endpoints_matching(*pdata);\n\
    +        {\n+            perform_builtin_endpoints_matching(*pdata);\n+      \
    \  }\n     }\n }\n "
  - "--- a/src/cpp/rtps/builtin/discovery/participant/PDPListener.cpp\n+++ b/src/cpp/rtps/builtin/discovery/participant/PDPListener.cpp\n\
    @@ -61,7 +61,7 @@ void PDPListener::onNewCacheChangeAdded(\n {\n     CacheChange_t*\
    \ change = const_cast<CacheChange_t*>(change_in);\n     GUID_t writer_guid = change->writerGUID;\n\
    -    EPROSIMA_LOG_INFO(RTPS_PDP, \"SPDP Message received from: \" << change_in->writerGUID);\n\
    +    EPROSIMA_LOG_INFO(RTPS_PDP, \"SPDP Message received from: \" << writer_guid);\n\
    \ \n     // Make sure we have an instance handle (i.e GUID)\n     if (change->instanceHandle\
    \ == c_InstanceHandle_Unknown)\n@@ -135,114 +135,10 @@ void PDPListener::onNewCacheChangeAdded(\n\
    \                 }\n             }\n \n-            auto status = (pdata == nullptr)\
    \ ? ParticipantDiscoveryInfo::DISCOVERED_PARTICIPANT :\n-                    ParticipantDiscoveryInfo::CHANGED_QOS_PARTICIPANT;\n\
    -\n-            if (pdata == nullptr)\n-            {\n-                // Create\
    \ a new one when not found\n-                pdata = parent_pdp_->createParticipantProxyData(temp_participant_data_,\
    \ writer_guid);\n-\n-                reader->getMutex().unlock();\n-         \
    \       lock.unlock();\n-\n-                if (pdata != nullptr)\n-         \
    \       {\n-                    EPROSIMA_LOG_INFO(RTPS_PDP_DISCOVERY, \"New participant\
    \ \"\n-                            << pdata->m_guid << \" at \"\n-           \
    \                 << \"MTTLoc: \" << pdata->metatraffic_locators\n-          \
    \                  << \" DefLoc:\" << pdata->default_locators);\n-\n-        \
    \            RTPSParticipantListener* listener = parent_pdp_->getRTPSParticipant()->getListener();\n\
    -                    if (listener != nullptr)\n-                    {\n-     \
    \                   bool should_be_ignored = false;\n-                       \
    \ {\n-                            std::lock_guard<std::mutex> cb_lock(parent_pdp_->callback_mtx_);\n\
    -                            ParticipantDiscoveryInfo info(*pdata);\n-       \
    \                     info.status = status;\n-\n-\n-                         \
    \   listener->onParticipantDiscovery(\n-                                parent_pdp_->getRTPSParticipant()->getUserRTPSParticipant(),\n\
    -                                std::move(info),\n-                         \
    \       should_be_ignored);\n-                        }\n-                   \
    \     if (should_be_ignored)\n-                        {\n-                  \
    \          parent_pdp_->getRTPSParticipant()->ignore_participant(guid.guidPrefix);\n\
    -                        }\n-\n-                    }\n-\n-                  \
    \  // Assigning remote endpoints implies sending a DATA(p) to all matched and\
    \ fixed readers, since\n-                    // StatelessWriter::matched_reader_add\
    \ marks the entire history as unsent if the added reader's\n-                \
    \    // durability is bigger or equal to TRANSIENT_LOCAL_DURABILITY_QOS (TRANSIENT_LOCAL\
    \ or TRANSIENT),\n-                    // which is the case of ENTITYID_BUILTIN_SDP_PARTICIPANT_READER\
    \ (TRANSIENT_LOCAL). If a remote\n-                    // participant is discovered\
    \ before creating the first DATA(p) change (which happens at the end of\n-   \
    \                 // BuiltinProtocols::initBuiltinProtocols), then StatelessWriter::matched_reader_add\
    \ ends up marking\n-                    // no changes as unsent (since the history\
    \ is empty), which is OK because this can only happen if a\n-                \
    \    // participant is discovered in the middle of BuiltinProtocols::initBuiltinProtocols,\
    \ which will\n-                    // create the first DATA(p) upon finishing,\
    \ thus triggering the sent to all fixed and matched\n-                    // readers\
    \ anyways.\n-                    parent_pdp_->assignRemoteEndpoints(pdata);\n\
    -                }\n-            }\n-            else\n-            {\n-     \
    \           pdata->updateData(temp_participant_data_);\n-                pdata->isAlive\
    \ = true;\n-                reader->getMutex().unlock();\n-\n-               \
    \ EPROSIMA_LOG_INFO(RTPS_PDP_DISCOVERY, \"Update participant \"\n-           \
    \             << pdata->m_guid << \" at \"\n-                        << \"MTTLoc:\
    \ \" << pdata->metatraffic_locators\n-                        << \" DefLoc:\"\
    \ << pdata->default_locators);\n-\n-                if (parent_pdp_->updateInfoMatchesEDP())\n\
    -                {\n-                    parent_pdp_->mp_EDP->assignRemoteEndpoints(*pdata,\
    \ true);\n-                }\n-\n-                lock.unlock();\n-\n-       \
    \         RTPSParticipantListener* listener = parent_pdp_->getRTPSParticipant()->getListener();\n\
    -                if (listener != nullptr)\n-                {\n-             \
    \       bool should_be_ignored = false;\n-\n-                    {\n-        \
    \                std::lock_guard<std::mutex> cb_lock(parent_pdp_->callback_mtx_);\n\
    -                        ParticipantDiscoveryInfo info(*pdata);\n-           \
    \             info.status = status;\n-\n-                        listener->onParticipantDiscovery(\n\
    -                            parent_pdp_->getRTPSParticipant()->getUserRTPSParticipant(),\n\
    -                            std::move(info),\n-                            should_be_ignored);\n\
    -                    }\n-                    if (should_be_ignored)\n-       \
    \             {\n-                        parent_pdp_->getRTPSParticipant()->ignore_participant(temp_participant_data_.m_guid.guidPrefix);\n\
    -                    }\n-                }\n-            }\n-\n-#ifdef FASTDDS_STATISTICS\n\
    -            //! Addition or update of a participant proxy should trigger\n- \
    \           //! a connections update on the local participant connection list\n\
    -            if (nullptr != parent_pdp_->getRTPSParticipant()->get_connections_observer())\n\
    -            {\n-                parent_pdp_->getRTPSParticipant()->get_connections_observer()->on_local_entity_connections_change(\n\
    -                    parent_pdp_->getRTPSParticipant()->getGuid());\n-       \
    \     }\n-#endif //FASTDDS_STATISTICS\n-\n-            // Take again the reader\
    \ lock\n-            reader->getMutex().lock();\n+            process_alive_data(pdata,\
    \ temp_participant_data_, writer_guid, reader, lock);\n         }\n     }\n- \
    \   else\n+    else if (reader->matched_writer_is_matched(writer_guid))\n    \
    \ {\n         reader->getMutex().unlock();\n         if (parent_pdp_->remove_remote_participant(guid,\
    \ ParticipantDiscoveryInfo::REMOVED_PARTICIPANT))\n@@ -267,6 +163,92 @@ void PDPListener::onNewCacheChangeAdded(\n\
    \     parent_pdp_->builtin_endpoints_->remove_from_pdp_reader_history(change);\n\
    \ }\n \n+void PDPListener::process_alive_data(\n+        ParticipantProxyData*\
    \ old_data,\n+        ParticipantProxyData& new_data,\n+        GUID_t& writer_guid,\n\
    +        RTPSReader* reader,\n+        std::unique_lock<std::recursive_mutex>&\
    \ lock)\n+{\n+    GUID_t participant_guid = new_data.m_guid;\n+\n+    if (old_data\
    \ == nullptr)\n+    {\n+        // Create a new one when not found\n+        old_data\
    \ = parent_pdp_->createParticipantProxyData(new_data, writer_guid);\n+\n+    \
    \    reader->getMutex().unlock();\n+        lock.unlock();\n+\n+        if (old_data\
    \ != nullptr)\n+        {\n+            // Assigning remote endpoints implies\
    \ sending a DATA(p) to all matched and fixed readers, since\n+            // StatelessWriter::matched_reader_add\
    \ marks the entire history as unsent if the added reader's\n+            // durability\
    \ is bigger or equal to TRANSIENT_LOCAL_DURABILITY_QOS (TRANSIENT_LOCAL or TRANSIENT),\n\
    +            // which is the case of ENTITYID_BUILTIN_SDP_PARTICIPANT_READER (TRANSIENT_LOCAL).\
    \ If a remote\n+            // participant is discovered before creating the first\
    \ DATA(p) change (which happens at the end of\n+            // BuiltinProtocols::initBuiltinProtocols),\
    \ then StatelessWriter::matched_reader_add ends up marking\n+            // no\
    \ changes as unsent (since the history is empty), which is OK because this can\
    \ only happen if a\n+            // participant is discovered in the middle of\
    \ BuiltinProtocols::initBuiltinProtocols, which will\n+            // create the\
    \ first DATA(p) upon finishing, thus triggering the sent to all fixed and matched\n\
    +            // readers anyways.\n+            parent_pdp_->assignRemoteEndpoints(old_data);\n\
    +        }\n+    }\n+    else\n+    {\n+        old_data->updateData(new_data);\n\
    +        old_data->isAlive = true;\n+        reader->getMutex().unlock();\n+\n\
    +        EPROSIMA_LOG_INFO(RTPS_PDP_DISCOVERY, \"Update participant \"\n+    \
    \            << old_data->m_guid << \" at \"\n+                << \"MTTLoc: \"\
    \ << old_data->metatraffic_locators\n+                << \" DefLoc:\" << old_data->default_locators);\n\
    +\n+        if (parent_pdp_->updateInfoMatchesEDP())\n+        {\n+          \
    \  parent_pdp_->mp_EDP->assignRemoteEndpoints(*old_data, true);\n+        }\n\
    +\n+        lock.unlock();\n+\n+        RTPSParticipantListener* listener = parent_pdp_->getRTPSParticipant()->getListener();\n\
    +        if (listener != nullptr)\n+        {\n+            bool should_be_ignored\
    \ = false;\n+\n+            {\n+                std::lock_guard<std::mutex> cb_lock(parent_pdp_->callback_mtx_);\n\
    +                ParticipantDiscoveryInfo info(*old_data);\n+                info.status\
    \ = ParticipantDiscoveryInfo::CHANGED_QOS_PARTICIPANT;\n+\n+                listener->onParticipantDiscovery(\n\
    +                    parent_pdp_->getRTPSParticipant()->getUserRTPSParticipant(),\n\
    +                    std::move(info),\n+                    should_be_ignored);\n\
    +            }\n+            if (should_be_ignored)\n+            {\n+       \
    \         parent_pdp_->getRTPSParticipant()->ignore_participant(participant_guid.guidPrefix);\n\
    +            }\n+        }\n+    }\n+\n+#ifdef FASTDDS_STATISTICS\n+    //! Addition\
    \ or update of a participant proxy should trigger\n+    //! a connections update\
    \ on the local participant connection list\n+    if (nullptr != parent_pdp_->getRTPSParticipant()->get_connections_observer())\n\
    +    {\n+        parent_pdp_->getRTPSParticipant()->get_connections_observer()->on_local_entity_connections_change(\n\
    +            parent_pdp_->getRTPSParticipant()->getGuid());\n+    }\n+#endif //FASTDDS_STATISTICS\n\
    +\n+    // Take again the reader lock\n+    reader->getMutex().lock();\n+}\n+\n\
    \ bool PDPListener::get_key(\n         CacheChange_t* change)\n {"
  - "--- a/src/cpp/rtps/builtin/discovery/participant/PDPServer.cpp\n+++ b/src/cpp/rtps/builtin/discovery/participant/PDPServer.cpp\n\
    @@ -293,7 +293,7 @@ bool PDPServer::create_ds_pdp_best_effort_reader(\n     ratt.endpoint.durabilityKind\
    \ = VOLATILE;\n     ratt.endpoint.reliabilityKind = BEST_EFFORT;\n \n-    endpoints.stateless_listener.reset(new\
    \ PDPSecurityInitiatorListener(this,\n+    endpoints.stateless_reader.listener_.reset(new\
    \ PDPSecurityInitiatorListener(this,\n             [this](const ParticipantProxyData&\
    \ participant_data)\n             {\n                 auto endpoints = static_cast<fastdds::rtps::DiscoveryServerPDPEndpoints*>(builtin_endpoints_.get());\n\
    @@ -320,21 +320,15 @@ bool PDPServer::create_ds_pdp_best_effort_reader(\n    \
    \ // Create PDP Reader\n     RTPSReader* reader = nullptr;\n     if (mp_RTPSParticipant->createReader(&reader,\
    \ ratt, endpoints.stateless_reader.history_.get(),\n-            endpoints.stateless_listener.get(),\
    \ c_EntityId_SPDPReader, true, false))\n+            endpoints.stateless_reader.listener_.get(),\
    \ c_EntityId_SPDPReader, true, false))\n     {\n         endpoints.stateless_reader.reader_\
    \ = dynamic_cast<fastrtps::rtps::StatelessReader*>(reader);\n-\n-        // Enable\
    \ unknown clients to reach this reader\n-        reader->enableMessagesFromUnkownWriters(true);\n\
    -\n         mp_RTPSParticipant->set_endpoint_rtps_protection_supports(reader,\
    \ false);\n     }\n     // Could not create PDP Reader, so return false\n    \
    \ else\n     {\n         EPROSIMA_LOG_ERROR(RTPS_PDP_SERVER, \"PDPServer security\
    \ initiation Reader creation failed\");\n-\n-        endpoints.stateless_listener.reset();\n\
    \         endpoints.stateless_reader.release();\n         return false;\n    \
    \ }\n@@ -403,7 +397,7 @@ bool PDPServer::create_ds_pdp_reliable_endpoints(\n #endif\
    \ // HAVE_SQLITE3\n \n     // PDP Listener\n-    mp_listener = new PDPServerListener(this);\n\
    +    endpoints.reader.listener_.reset(new PDPServerListener(this));\n \n     //\
    \ Create PDP Reader\n     RTPSReader* reader = nullptr;\n@@ -412,8 +406,8 @@ bool\
    \ PDPServer::create_ds_pdp_reliable_endpoints(\n #else\n     EntityId_t reader_entity\
    \ = c_EntityId_SPDPReader;\n #endif // if HAVE_SECURITY\n-    if (mp_RTPSParticipant->createReader(&reader,\
    \ ratt, endpoints.reader.history_.get(), mp_listener,\n-            reader_entity,\
    \ true, false))\n+    if (mp_RTPSParticipant->createReader(&reader, ratt, endpoints.reader.history_.get(),\n\
    +            endpoints.reader.listener_.get(), reader_entity, true, false))\n\
    \     {\n         endpoints.reader.reader_ = dynamic_cast<fastrtps::rtps::StatefulReader*>(reader);\n\
    \ \n@@ -428,8 +422,6 @@ bool PDPServer::create_ds_pdp_reliable_endpoints(\n  \
    \   else\n     {\n         EPROSIMA_LOG_ERROR(RTPS_PDP_SERVER, \"PDPServer Reader\
    \ creation failed\");\n-        delete mp_listener;\n-        mp_listener = nullptr;\n\
    \         endpoints.reader.release();\n         return false;\n     }\n@@ -1781,7\
    \ +1773,7 @@ bool PDPServer::process_backup_discovery_database_restore(\n    \
    \         {\n                 change_aux->writerGUID = change_aux->write_params.sample_identity().writer_guid();\n\
    \                 change_aux->sequenceNumber = change_aux->write_params.sample_identity().sequence_number();\n\
    -                mp_listener->onNewCacheChangeAdded(endpoints->reader.reader_,\
    \ change_aux);\n+                builtin_endpoints_->main_listener()->onNewCacheChangeAdded(endpoints->reader.reader_,\
    \ change_aux);\n             }\n         }\n "
  - "--- a/src/cpp/rtps/builtin/discovery/participant/PDPSimple.cpp\n+++ b/src/cpp/rtps/builtin/discovery/participant/PDPSimple.cpp\n\
    @@ -41,16 +41,47 @@\n #include <fastrtps/utils/IPLocator.h>\n #include <fastrtps/utils/TimeConversion.h>\n\
    \ \n+#include <rtps/builtin/discovery/participant/DS/PDPSecurityInitiatorListener.hpp>\n\
    \ #include <rtps/builtin/discovery/participant/simple/SimplePDPEndpoints.hpp>\n\
    +#include <rtps/builtin/discovery/participant/simple/SimplePDPEndpointsSecure.hpp>\n\
    \ #include <rtps/history/TopicPayloadPoolRegistry.hpp>\n #include <rtps/participant/RTPSParticipantImpl.h>\n\
    \ \n-using namespace eprosima::fastrtps;\n-\n namespace eprosima {\n namespace\
    \ fastrtps {\n namespace rtps {\n \n+static HistoryAttributes pdp_reader_history_attributes(\n\
    +        const BuiltinAttributes& builtin_att,\n+        const RTPSParticipantAllocationAttributes&\
    \ allocation)\n+{\n+    HistoryAttributes hatt;\n+    hatt.payloadMaxSize = builtin_att.readerPayloadSize;\n\
    +    hatt.memoryPolicy = builtin_att.readerHistoryMemoryPolicy;\n+    hatt.initialReservedCaches\
    \ = 25;\n+    if (allocation.participants.initial > 0)\n+    {\n+        hatt.initialReservedCaches\
    \ = (int32_t)allocation.participants.initial;\n+    }\n+    if (allocation.participants.maximum\
    \ < std::numeric_limits<size_t>::max())\n+    {\n+        hatt.maximumReservedCaches\
    \ = (int32_t)allocation.participants.maximum;\n+    }\n+\n+    return hatt;\n\
    +}\n+\n+static HistoryAttributes pdp_writer_history_attributes(\n+        const\
    \ BuiltinAttributes& builtin_att)\n+{\n+    HistoryAttributes hatt;\n+    hatt.payloadMaxSize\
    \ = builtin_att.writerPayloadSize;\n+    hatt.memoryPolicy = builtin_att.writerHistoryMemoryPolicy;\n\
    +    hatt.initialReservedCaches = 1;\n+    hatt.maximumReservedCaches = 1;\n+\n\
    +    return hatt;\n+}\n \n PDPSimple::PDPSimple (\n         BuiltinProtocols*\
    \ built,\n@@ -233,15 +264,28 @@ void PDPSimple::announceParticipantState(\n {\n\
    \     if (enabled_)\n     {\n-        auto endpoints = static_cast<fastdds::rtps::SimplePDPEndpoints*>(builtin_endpoints_.get());\n\
    -        StatelessWriter& writer = *(endpoints->writer.writer_);\n-        WriterHistory&\
    \ history = *(endpoints->writer.history_);\n+        new_change |= m_hasChangedLocalPDP.exchange(false);\n\
    \ \n+#if HAVE_SECURITY\n+        if (mp_RTPSParticipant->is_secure())\n+     \
    \   {\n+            auto secure = dynamic_cast<fastdds::rtps::SimplePDPEndpointsSecure*>(builtin_endpoints_.get());\n\
    +            assert(nullptr != secure);\n+\n+            RTPSWriter& writer =\
    \ *(secure->secure_writer.writer_);\n+            WriterHistory& history = *(secure->secure_writer.history_);\n\
    +            PDP::announceParticipantState(writer, history, new_change, dispose,\
    \ wp);\n+        }\n+#endif // HAVE_SECURITY\n+\n+        auto endpoints = dynamic_cast<fastdds::rtps::SimplePDPEndpoints*>(builtin_endpoints_.get());\n\
    +        RTPSWriter& writer = *(endpoints->writer.writer_);\n+        WriterHistory&\
    \ history = *(endpoints->writer.history_);\n         PDP::announceParticipantState(writer,\
    \ history, new_change, dispose, wp);\n \n         if (!(dispose || new_change))\n\
    \         {\n-            writer.unsent_changes_reset();\n+            endpoints->writer.writer_->unsent_changes_reset();\n\
    \         }\n     }\n }\n@@ -250,257 +294,437 @@ bool PDPSimple::createPDPEndpoints()\n\
    \ {\n     EPROSIMA_LOG_INFO(RTPS_PDP, \"Beginning\");\n \n+    fastdds::rtps::SimplePDPEndpoints*\
    \ endpoints = nullptr;\n+#if HAVE_SECURITY\n+    fastdds::rtps::SimplePDPEndpointsSecure*\
    \ secure_endpoints = nullptr;\n+    bool is_secure = mp_RTPSParticipant->is_secure();\n\
    +    if (is_secure)\n+    {\n+        secure_endpoints = new fastdds::rtps::SimplePDPEndpointsSecure();\n\
    +        secure_endpoints->secure_reader.listener_.reset(new PDPListener(this));\n\
    +\n+        endpoints = secure_endpoints;\n+        endpoints->reader.listener_.reset(new\
    \ PDPSecurityInitiatorListener(this));\n+    }\n+    else\n+#endif  // HAVE_SECURITY\n\
    +    {\n+        endpoints = new fastdds::rtps::SimplePDPEndpoints();\n+     \
    \   endpoints->reader.listener_.reset(new PDPListener(this));\n+    }\n+    builtin_endpoints_.reset(endpoints);\n\
    +\n+    bool ret_val = create_dcps_participant_endpoints();\n+#if HAVE_SECURITY\n\
    +    if (ret_val && is_secure)\n+    {\n+        create_dcps_participant_secure_endpoints();\n\
    +    }\n+#endif  // HAVE_SECURITY\n+    EPROSIMA_LOG_INFO(RTPS_PDP, \"SPDP Endpoints\
    \ creation finished\");\n+    return ret_val;\n+}\n+\n+bool PDPSimple::create_dcps_participant_endpoints()\n\
    +{\n     const RTPSParticipantAttributes& pattr = mp_RTPSParticipant->getRTPSParticipantAttributes();\n\
    \     const RTPSParticipantAllocationAttributes& allocation = pattr.allocation;\n\
    \     const BuiltinAttributes& builtin_att = mp_builtin->m_att;\n+    auto endpoints\
    \ = dynamic_cast<fastdds::rtps::SimplePDPEndpoints*>(builtin_endpoints_.get());\n\
    +    assert(nullptr != endpoints);\n \n-    auto endpoints = new fastdds::rtps::SimplePDPEndpoints();\n\
    -    builtin_endpoints_.reset(endpoints);\n+    constexpr const char* topic_name\
    \ = \"DCPSParticipant\";\n+    const EntityId_t reader_entity_id = c_EntityId_SPDPReader;\n\
    +    const EntityId_t writer_entity_id = c_EntityId_SPDPWriter;\n \n-    //SPDP\
    \ BUILTIN RTPSParticipant READER\n+    // BUILTIN DCPSParticipant READER\n+  \
    \  auto& reader = endpoints->reader;\n     HistoryAttributes hatt;\n-    hatt.payloadMaxSize\
    \ = builtin_att.readerPayloadSize;\n-    hatt.memoryPolicy = builtin_att.readerHistoryMemoryPolicy;\n\
    -    hatt.initialReservedCaches = 25;\n-    if (allocation.participants.initial\
    \ > 0)\n-    {\n-        hatt.initialReservedCaches = (int32_t)allocation.participants.initial;\n\
    -    }\n-    if (allocation.participants.maximum < std::numeric_limits<size_t>::max())\n\
    -    {\n-        hatt.maximumReservedCaches = (int32_t)allocation.participants.maximum;\n\
    -    }\n+    hatt = pdp_reader_history_attributes(builtin_att, allocation);\n\
    \ \n     PoolConfig reader_pool_cfg = PoolConfig::from_history_attributes(hatt);\n\
    -    endpoints->reader.payload_pool_ = TopicPayloadPoolRegistry::get(\"DCPSParticipant\"\
    , reader_pool_cfg);\n-    endpoints->reader.payload_pool_->reserve_history(reader_pool_cfg,\
    \ true);\n-\n-    endpoints->reader.history_.reset(new ReaderHistory(hatt));\n\
    -\n-    ReaderAttributes ratt;\n-    ratt.endpoint.multicastLocatorList = mp_builtin->m_metatrafficMulticastLocatorList;\n\
    -    ratt.endpoint.unicastLocatorList = mp_builtin->m_metatrafficUnicastLocatorList;\n\
    -    ratt.endpoint.external_unicast_locators = mp_builtin->m_att.metatraffic_external_unicast_locators;\n\
    -    ratt.endpoint.ignore_non_matching_locators = pattr.ignore_non_matching_locators;\n\
    -    ratt.endpoint.topicKind = WITH_KEY;\n-    ratt.endpoint.durabilityKind =\
    \ TRANSIENT_LOCAL;\n+    reader.payload_pool_ = TopicPayloadPoolRegistry::get(topic_name,\
    \ reader_pool_cfg);\n+    reader.payload_pool_->reserve_history(reader_pool_cfg,\
    \ true);\n+    reader.history_.reset(new ReaderHistory(hatt));\n+\n+    ReaderAttributes\
    \ ratt = create_builtin_reader_attributes();\n     ratt.endpoint.reliabilityKind\
    \ = BEST_EFFORT;\n-    ratt.matched_writers_allocation = allocation.participants;\n\
    -    mp_listener = new PDPListener(this);\n-    RTPSReader* reader = nullptr;\n\
    -    if (mp_RTPSParticipant->createReader(&reader, ratt,\n-            endpoints->reader.payload_pool_,\
    \ endpoints->reader.history_.get(),\n-            mp_listener, c_EntityId_SPDPReader,\
    \ true, false))\n-    {\n-        endpoints->reader.reader_ = dynamic_cast<StatelessReader*>(reader);\n\
    +\n+    RTPSReader* rtps_reader = nullptr;\n+    if (mp_RTPSParticipant->createReader(&rtps_reader,\
    \ ratt, reader.payload_pool_, reader.history_.get(),\n+            reader.listener_.get(),\
    \ reader_entity_id, true, false))\n+    {\n+        reader.reader_ = dynamic_cast<StatelessReader*>(rtps_reader);\n\
    +        assert(nullptr != reader.reader_);\n+\n #if HAVE_SECURITY\n-        mp_RTPSParticipant->set_endpoint_rtps_protection_supports(reader,\
    \ false);\n+        mp_RTPSParticipant->set_endpoint_rtps_protection_supports(rtps_reader,\
    \ false);\n #endif // if HAVE_SECURITY\n     }\n     else\n     {\n-        EPROSIMA_LOG_ERROR(RTPS_PDP,\
    \ \"SimplePDP Reader creation failed\");\n-        delete mp_listener;\n-    \
    \    mp_listener = nullptr;\n-        endpoints->reader.release();\n+        EPROSIMA_LOG_ERROR(RTPS_PDP,\
    \ \"'\" << topic_name << \"' builtin reader creation failed\");\n+        reader.release();\n\
    \         return false;\n     }\n \n-    //SPDP BUILTIN RTPSParticipant WRITER\n\
    -    hatt.payloadMaxSize = mp_builtin->m_att.writerPayloadSize;\n-    hatt.initialReservedCaches\
    \ = 1;\n-    hatt.maximumReservedCaches = 1;\n-    hatt.memoryPolicy = mp_builtin->m_att.writerHistoryMemoryPolicy;\n\
    +    // BUILTIN DCPSParticipant WRITER\n+    auto& writer = endpoints->writer;\n\
    +    hatt = pdp_writer_history_attributes(builtin_att);\n \n     PoolConfig writer_pool_cfg\
    \ = PoolConfig::from_history_attributes(hatt);\n-    endpoints->writer.payload_pool_\
    \ = TopicPayloadPoolRegistry::get(\"DCPSParticipant\", writer_pool_cfg);\n-  \
    \  endpoints->writer.payload_pool_->reserve_history(writer_pool_cfg, false);\n\
    -\n-    endpoints->writer.history_.reset(new WriterHistory(hatt));\n-    WriterAttributes\
    \ watt;\n-    watt.endpoint.external_unicast_locators = mp_builtin->m_att.metatraffic_external_unicast_locators;\n\
    -    watt.endpoint.ignore_non_matching_locators = pattr.ignore_non_matching_locators;\n\
    -    watt.endpoint.endpointKind = WRITER;\n-    watt.endpoint.durabilityKind =\
    \ TRANSIENT_LOCAL;\n+    writer.payload_pool_ = TopicPayloadPoolRegistry::get(topic_name,\
    \ writer_pool_cfg);\n+    writer.payload_pool_->reserve_history(writer_pool_cfg,\
    \ false);\n+    writer.history_.reset(new WriterHistory(hatt));\n+\n+    WriterAttributes\
    \ watt = create_builtin_writer_attributes();\n     watt.endpoint.reliabilityKind\
    \ = BEST_EFFORT;\n-    watt.endpoint.topicKind = WITH_KEY;\n     watt.endpoint.remoteLocatorList\
    \ = m_discovery.initialPeersList;\n-    watt.matched_readers_allocation = allocation.participants;\n\
    \ \n     if (pattr.throughputController.bytesPerPeriod != UINT32_MAX && pattr.throughputController.periodMillisecs\
    \ != 0)\n     {\n         watt.mode = ASYNCHRONOUS_WRITER;\n     }\n \n-    RTPSWriter*\
    \ wout = nullptr;\n-    if (mp_RTPSParticipant->createWriter(&wout, watt, endpoints->writer.payload_pool_,\
    \ endpoints->writer.history_.get(),\n-            nullptr,\n-            c_EntityId_SPDPWriter,\
    \ true))\n+    RTPSWriter* rtps_writer = nullptr;\n+    if (mp_RTPSParticipant->createWriter(&rtps_writer,\
    \ watt, writer.payload_pool_, writer.history_.get(),\n+            nullptr, writer_entity_id,\
    \ true))\n     {\n-        endpoints->writer.writer_ = dynamic_cast<StatelessWriter*>(wout);\n\
    +        writer.writer_ = dynamic_cast<StatelessWriter*>(rtps_writer);\n+    \
    \    assert(nullptr != writer.writer_);\n+\n #if HAVE_SECURITY\n-        mp_RTPSParticipant->set_endpoint_rtps_protection_supports(wout,\
    \ false);\n+        mp_RTPSParticipant->set_endpoint_rtps_protection_supports(rtps_writer,\
    \ false);\n #endif // if HAVE_SECURITY\n-        if (endpoints->writer.writer_\
    \ != nullptr)\n+\n+        const NetworkFactory& network = mp_RTPSParticipant->network_factory();\n\
    +        LocatorList_t fixed_locators;\n+        for (const Locator_t& loc : mp_builtin->m_initialPeersList)\n\
    \         {\n-            const NetworkFactory& network = mp_RTPSParticipant->network_factory();\n\
    -            LocatorList_t fixed_locators;\n-            for (const Locator_t&\
    \ loc : mp_builtin->m_initialPeersList)\n+            if (network.is_locator_remote_or_allowed(loc))\n\
    \             {\n-                if (network.is_locator_remote_or_allowed(loc))\n\
    -                {\n-                    // Add initial peers locator without\
    \ transformation as we don't know whether the\n-                    // remote\
    \ transport will allow localhost\n-                    fixed_locators.push_back(loc);\n\
    -\n-                    /**\n-                     * TCP special case:\n-    \
    \                 *\n-                     * In TCP, it is not possible to open\
    \ a socket with 'any' (0.0.0.0) address as it's done\n-                     *\
    \ in UDP, so when the TCP transports receive a locator with 'any', they open an\
    \ input\n-                     * channel for the specified port in each of the\
    \ machine interfaces (with the exception\n-                     * of localhost).\
    \ In fact, a participant with a TCP transport will only listen on localhost\n\
    -                     * if localhost is the address of any of the initial peers.\n\
    -                     *\n-                     * However, when the TCP enabled\
    \ participant does not have a whitelist (or localhost is in\n-               \
    \      * it), it allows for transformation of its locators to localhost for performance\
    \ optimizations.\n-                     * In this case, the remote TCP participant\
    \ it will send data using a socket in localhost,\n-                     * and\
    \ for that the participant with the initial peers list needs to be listening there\n\
    -                     * to receive it.\n-                     *\n-           \
    \          * That means:\n-                     *   1. Checking that the initial\
    \ peer is not already localhost\n-                     *   2. Checking that the\
    \ initial peer locator is of TCP kind\n-                     *   3. Checking that\
    \ the network configuration allows for localhost locators\n-                 \
    \    */\n-                    Locator_t local_locator;\n-                    network.transform_remote_locator(loc,\
    \ local_locator,\n-                            DISC_NETWORK_CONFIGURATION_LISTENING_LOCALHOST_ALL);\n\
    -                    if (loc != local_locator\n-                            &&\
    \ (loc.kind == LOCATOR_KIND_TCPv4 || loc.kind == LOCATOR_KIND_TCPv6)\n-      \
    \                      && network.is_locator_allowed(local_locator))\n-      \
    \              {\n-                        fixed_locators.push_back(local_locator);\n\
    -                    }\n-                }\n-                else\n+         \
    \       // Add initial peers locator without transformation as we don't know whether\
    \ the\n+                // remote transport will allow localhost\n+          \
    \      fixed_locators.push_back(loc);\n+\n+                /**\n+            \
    \     * TCP special case:\n+                 *\n+                 * In TCP, it\
    \ is not possible to open a socket with 'any' (0.0.0.0) address as it's done\n\
    +                 * in UDP, so when the TCP transports receive a locator with\
    \ 'any', they open an input\n+                 * channel for the specified port\
    \ in each of the machine interfaces (with the exception\n+                 * of\
    \ localhost). In fact, a participant with a TCP transport will only listen on\
    \ localhost\n+                 * if localhost is the address of any of the initial\
    \ peers.\n+                 *\n+                 * However, when the TCP enabled\
    \ participant does not have a whitelist (or localhost is in\n+               \
    \  * it), it allows for transformation of its locators to localhost for performance\
    \ optimizations.\n+                 * In this case, the remote TCP participant\
    \ it will send data using a socket in localhost,\n+                 * and for\
    \ that the participant with the initial peers list needs to be listening there\n\
    +                 * to receive it.\n+                 *\n+                 * That\
    \ means:\n+                 *   1. Checking that the initial peer is not already\
    \ localhost\n+                 *   2. Checking that the initial peer locator is\
    \ of TCP kind\n+                 *   3. Checking that the network configuration\
    \ allows for localhost locators\n+                 */\n+                Locator_t\
    \ local_locator;\n+                network.transform_remote_locator(loc, local_locator,\n\
    +                        DISC_NETWORK_CONFIGURATION_LISTENING_LOCALHOST_ALL);\n\
    +                if (loc != local_locator\n+                        && (loc.kind\
    \ == LOCATOR_KIND_TCPv4 || loc.kind == LOCATOR_KIND_TCPv6)\n+                \
    \        && network.is_locator_allowed(local_locator))\n                 {\n-\
    \                    EPROSIMA_LOG_WARNING(RTPS_PDP, \"Ignoring initial peers locator\
    \ \" << loc << \" : not allowed.\");\n+                    fixed_locators.push_back(local_locator);\n\
    \                 }\n             }\n-            endpoints->writer.writer_->set_fixed_locators(fixed_locators);\n\
    +            else\n+            {\n+                EPROSIMA_LOG_WARNING(RTPS_PDP,\
    \ \"Ignoring initial peers locator \" << loc << \" : not allowed.\");\n+     \
    \       }\n         }\n+        writer.writer_->set_fixed_locators(fixed_locators);\n\
    \     }\n     else\n     {\n-        EPROSIMA_LOG_ERROR(RTPS_PDP, \"SimplePDP\
    \ Writer creation failed\");\n-        endpoints->writer.release();\n+       \
    \ EPROSIMA_LOG_ERROR(RTPS_PDP, \"'\" << topic_name << \"' builtin writer creation\
    \ failed\");\n+        writer.release();\n         return false;\n     }\n-  \
    \  EPROSIMA_LOG_INFO(RTPS_PDP, \"SPDP Endpoints creation finished\");\n     return\
    \ true;\n }\n \n-void PDPSimple::assignRemoteEndpoints(\n-        ParticipantProxyData*\
    \ pdata)\n+#if HAVE_SECURITY\n+bool PDPSimple::create_dcps_participant_secure_endpoints()\n\
    \ {\n-    EPROSIMA_LOG_INFO(RTPS_PDP, \"For RTPSParticipant: \" << pdata->m_guid.guidPrefix);\n\
    +    const RTPSParticipantAttributes& pattr = mp_RTPSParticipant->getRTPSParticipantAttributes();\n\
    +    const RTPSParticipantAllocationAttributes& allocation = pattr.allocation;\n\
    +    const BuiltinAttributes& builtin_att = mp_builtin->m_att;\n+    auto endpoints\
    \ = dynamic_cast<fastdds::rtps::SimplePDPEndpointsSecure*>(builtin_endpoints_.get());\n\
    +    assert(nullptr != endpoints);\n \n-    auto endpoints = static_cast<fastdds::rtps::SimplePDPEndpoints*>(builtin_endpoints_.get());\n\
    +    constexpr const char* topic_name = \"DCPSParticipantsSecure\";\n+    const\
    \ EntityId_t reader_entity_id = c_EntityId_spdp_reliable_participant_secure_reader;\n\
    +    const EntityId_t writer_entity_id = c_EntityId_spdp_reliable_participant_secure_writer;\n\
    \ \n-    const NetworkFactory& network = mp_RTPSParticipant->network_factory();\n\
    -    uint32_t endp = pdata->m_availableBuiltinEndpoints;\n-    uint32_t auxendp\
    \ = endp;\n-    bool use_multicast_locators = !mp_RTPSParticipant->getAttributes().builtin.avoid_builtin_multicast\
    \ ||\n-            pdata->metatraffic_locators.unicast.empty();\n-    auxendp\
    \ &= DISC_BUILTIN_ENDPOINT_PARTICIPANT_ANNOUNCER;\n-    if (auxendp != 0)\n- \
    \   {\n-        auto temp_writer_data = get_temporary_writer_proxies_pool().get();\n\
    +    // BUILTIN DCPSParticipantsSecure READER\n+    auto& reader = endpoints->secure_reader;\n\
    +    HistoryAttributes hatt;\n+    hatt = pdp_reader_history_attributes(builtin_att,\
    \ allocation);\n \n-        temp_writer_data->clear();\n-        temp_writer_data->guid().guidPrefix\
    \ = pdata->m_guid.guidPrefix;\n-        temp_writer_data->guid().entityId = c_EntityId_SPDPWriter;\n\
    -        temp_writer_data->persistence_guid(pdata->get_persistence_guid());\n\
    -        temp_writer_data->set_persistence_entity_id(c_EntityId_SPDPWriter);\n\
    -        temp_writer_data->set_remote_locators(pdata->metatraffic_locators, network,\
    \ use_multicast_locators);\n-        temp_writer_data->m_qos.m_reliability.kind\
    \ = RELIABLE_RELIABILITY_QOS;\n-        temp_writer_data->m_qos.m_durability.kind\
    \ = TRANSIENT_LOCAL_DURABILITY_QOS;\n-        endpoints->reader.reader_->matched_writer_add(*temp_writer_data);\n\
    +    PoolConfig reader_pool_cfg = PoolConfig::from_history_attributes(hatt);\n\
    +    reader.payload_pool_ = TopicPayloadPoolRegistry::get(topic_name, reader_pool_cfg);\n\
    +    reader.payload_pool_->reserve_history(reader_pool_cfg, true);\n+    reader.history_.reset(new\
    \ ReaderHistory(hatt));\n+\n+    ReaderAttributes ratt = create_builtin_reader_attributes();\n\
    +    WriterAttributes watt = create_builtin_writer_attributes();\n+    add_builtin_security_attributes(ratt,\
    \ watt);\n+\n+    RTPSReader* rtps_reader = nullptr;\n+    if (mp_RTPSParticipant->createReader(&rtps_reader,\
    \ ratt, reader.payload_pool_, reader.history_.get(),\n+            reader.listener_.get(),\
    \ reader_entity_id, true, false))\n+    {\n+        reader.reader_ = dynamic_cast<StatefulReader*>(rtps_reader);\n\
    +        assert(nullptr != reader.reader_);\n     }\n-    auxendp = endp;\n- \
    \   auxendp &= DISC_BUILTIN_ENDPOINT_PARTICIPANT_DETECTOR;\n-    if (auxendp !=\
    \ 0)\n+    else\n     {\n-        auto temp_reader_data = get_temporary_reader_proxies_pool().get();\n\
    +        EPROSIMA_LOG_ERROR(RTPS_PDP, \"'\" << topic_name << \"' builtin reader\
    \ creation failed\");\n+        reader.release();\n+        return false;\n+ \
    \   }\n \n-        temp_reader_data->clear();\n-        temp_reader_data->m_expectsInlineQos\
    \ = false;\n-        temp_reader_data->guid().guidPrefix = pdata->m_guid.guidPrefix;\n\
    -        temp_reader_data->guid().entityId = c_EntityId_SPDPReader;\n-       \
    \ temp_reader_data->set_remote_locators(pdata->metatraffic_locators, network,\
    \ use_multicast_locators);\n-        temp_reader_data->m_qos.m_reliability.kind\
    \ = BEST_EFFORT_RELIABILITY_QOS;\n-        temp_reader_data->m_qos.m_durability.kind\
    \ = TRANSIENT_LOCAL_DURABILITY_QOS;\n-        endpoints->writer.writer_->matched_reader_add(*temp_reader_data);\n\
    +    // SPDP BUILTIN RTPSParticipant WRITER\n+    auto& writer = endpoints->secure_writer;\n\
    +    hatt = pdp_writer_history_attributes(builtin_att);\n \n-        StatelessWriter*\
    \ pW = endpoints->writer.writer_;\n+    PoolConfig writer_pool_cfg = PoolConfig::from_history_attributes(hatt);\n\
    +    writer.payload_pool_ = TopicPayloadPoolRegistry::get(topic_name, writer_pool_cfg);\n\
    +    writer.payload_pool_->reserve_history(writer_pool_cfg, false);\n+    writer.history_.reset(new\
    \ WriterHistory(hatt));\n \n-        if (pW != nullptr)\n+    RTPSWriter* rtps_writer\
    \ = nullptr;\n+    if (mp_RTPSParticipant->createWriter(&rtps_writer, watt, writer.payload_pool_,\
    \ writer.history_.get(),\n+            nullptr, writer_entity_id, true))\n+  \
    \  {\n+        writer.writer_ = dynamic_cast<StatefulWriter*>(rtps_writer);\n\
    +        assert(nullptr != writer.writer_);\n+    }\n+    else\n+    {\n+    \
    \    EPROSIMA_LOG_ERROR(RTPS_PDP, \"'\" << topic_name << \"' builtin writer creation\
    \ failed\");\n+        writer.release();\n+        return false;\n+    }\n+  \
    \  return true;\n+}\n+\n+#endif  // HAVE_SECURITY\n+\n+void PDPSimple::assignRemoteEndpoints(\n\
    +        ParticipantProxyData* pdata)\n+{\n+    bool ignored = false;\n+    notify_and_maybe_ignore_new_participant(pdata,\
    \ ignored);\n+    if (!ignored)\n+    {\n+#if HAVE_SECURITY\n+        auto endpoints\
    \ = dynamic_cast<fastdds::rtps::SimplePDPEndpointsSecure*>(builtin_endpoints_.get());\n\
    +        if (nullptr != endpoints)\n         {\n-            pW->unsent_changes_reset();\n\
    +            // This participant is secure.\n+            // PDP should have been\
    \ matched inside notifyAboveRemoteEndpoints after completing the authentication\
    \ process.\n+            // We now match the other builtin endpoints.\n+     \
    \       GUID_t remote_guid = pdata->m_guid;\n+            remote_guid.entityId\
    \ = c_EntityId_spdp_reliable_participant_secure_writer;\n+            bool notify_secure\
    \ = endpoints->secure_reader.reader_->matched_writer_is_matched(remote_guid);\n\
    +            assign_low_level_remote_endpoints(*pdata, notify_secure);\n     \
    \    }\n         else\n+#endif // if HAVE_SECURITY\n         {\n-            EPROSIMA_LOG_ERROR(RTPS_PDP,\
    \ \"Using PDPSimple protocol with a reliable writer\");\n+            // This\
    \ participant is not secure.\n+            // Match PDP and other builtin endpoints.\n\
    +            match_pdp_remote_endpoints(*pdata, false);\n+            assign_low_level_remote_endpoints(*pdata,\
    \ false);\n         }\n     }\n-\n-#if HAVE_SECURITY\n-    // Validate remote\
    \ participant\n-    mp_RTPSParticipant->security_manager().discovered_participant(*pdata);\n\
    -#else\n-    //Inform EDP of new RTPSParticipant data:\n-    notifyAboveRemoteEndpoints(*pdata,\
    \ true);\n-#endif // if HAVE_SECURITY\n }\n \n void PDPSimple::removeRemoteEndpoints(\n\
    \         ParticipantProxyData* pdata)\n {\n     EPROSIMA_LOG_INFO(RTPS_PDP, \"\
    For RTPSParticipant: \" << pdata->m_guid);\n \n-    auto endpoints = static_cast<fastdds::rtps::SimplePDPEndpoints*>(builtin_endpoints_.get());\n\
    +    GUID_t guid = pdata->m_guid;\n \n-    uint32_t endp = pdata->m_availableBuiltinEndpoints;\n\
    -    uint32_t auxendp = endp;\n-    auxendp &= DISC_BUILTIN_ENDPOINT_PARTICIPANT_ANNOUNCER;\n\
    -    if (auxendp != 0)\n     {\n-        GUID_t writer_guid(pdata->m_guid.guidPrefix,\
    \ c_EntityId_SPDPWriter);\n-        endpoints->reader.reader_->matched_writer_remove(writer_guid);\n\
    +        auto endpoints = dynamic_cast<fastdds::rtps::SimplePDPEndpoints*>(builtin_endpoints_.get());\n\
    +        assert(nullptr != endpoints);\n+\n+        guid.entityId = c_EntityId_SPDPWriter;\n\
    +        endpoints->reader.reader_->matched_writer_remove(guid);\n+\n+       \
    \ guid.entityId = c_EntityId_SPDPReader;\n+        endpoints->writer.writer_->matched_reader_remove(guid);\n\
    \     }\n-    auxendp = endp;\n-    auxendp &= DISC_BUILTIN_ENDPOINT_PARTICIPANT_DETECTOR;\n\
    -    if (auxendp != 0)\n+\n+#if HAVE_SECURITY\n+    auto endpoints = dynamic_cast<fastdds::rtps::SimplePDPEndpointsSecure*>(builtin_endpoints_.get());\n\
    +    if (nullptr != endpoints)\n     {\n-        GUID_t reader_guid(pdata->m_guid.guidPrefix,\
    \ c_EntityId_SPDPReader);\n-        endpoints->writer.writer_->matched_reader_remove(reader_guid);\n\
    +        guid.entityId = c_EntityId_spdp_reliable_participant_secure_writer;\n\
    +        endpoints->secure_reader.reader_->matched_writer_remove(guid);\n+\n+\
    \        guid.entityId = c_EntityId_spdp_reliable_participant_secure_reader;\n\
    +        endpoints->secure_writer.writer_->matched_reader_remove(guid);\n    \
    \ }\n+#endif // HAVE_SECURITY\n }\n \n void PDPSimple::notifyAboveRemoteEndpoints(\n\
    \         const ParticipantProxyData& pdata,\n         bool notify_secure_endpoints)\n\
    \ {\n-    //Inform EDP of new RTPSParticipant data:\n+    if (notify_secure_endpoints)\n\
    +    {\n+        match_pdp_remote_endpoints(pdata, true);\n+    }\n+    else\n\
    +    {\n+        // Add remote participant data\n+        GUID_t writer_guid{\
    \ pdata.m_guid.guidPrefix, c_EntityId_SPDPWriter };\n+        ParticipantProxyData*\
    \ part_data = createParticipantProxyData(pdata, writer_guid);\n+        if (part_data\
    \ != nullptr)\n+        {\n+            bool ignored = false;\n+            notify_and_maybe_ignore_new_participant(part_data,\
    \ ignored);\n+            if (!ignored)\n+            {\n+                match_pdp_remote_endpoints(*part_data,\
    \ false);\n+                assign_low_level_remote_endpoints(*part_data, false);\n\
    +            }\n+        }\n+    }\n+\n+}\n+\n+void PDPSimple::match_pdp_remote_endpoints(\n\
    +        const ParticipantProxyData& pdata,\n+        bool notify_secure_endpoints)\n\
    +{\n+#if !HAVE_SECURITY\n+    static_cast<void>(notify_secure_endpoints);\n+#endif\
    \ // !HAVE_SECURITY\n+\n+    auto endpoints = static_cast<fastdds::rtps::SimplePDPEndpoints*>(builtin_endpoints_.get());\n\
    +\n+    const NetworkFactory& network = mp_RTPSParticipant->network_factory();\n\
    +    bool use_multicast_locators = !mp_RTPSParticipant->getAttributes().builtin.avoid_builtin_multicast\
    \ ||\n+            pdata.metatraffic_locators.unicast.empty();\n+    const uint32_t\
    \ endp = pdata.m_availableBuiltinEndpoints;\n+\n+    // Default to values for\
    \ non-secure endpoints\n+    auto reliability_kind = BEST_EFFORT_RELIABILITY_QOS;\n\
    +    uint32_t pdp_reader_mask = DISC_BUILTIN_ENDPOINT_PARTICIPANT_DETECTOR;\n\
    +    uint32_t pdp_writer_mask = DISC_BUILTIN_ENDPOINT_PARTICIPANT_ANNOUNCER;\n\
    +    EntityId_t reader_entity_id = c_EntityId_SPDPReader;\n+    EntityId_t writer_entity_id\
    \ = c_EntityId_SPDPWriter;\n+    RTPSReader* reader = endpoints->reader.reader_;\n\
    +    RTPSWriter* writer = endpoints->writer.writer_;\n+\n+#if HAVE_SECURITY\n\
    +    // If the other participant has been authenticated, use values for secure\
    \ endpoints\n+    if (notify_secure_endpoints)\n+    {\n+        auto secure_endpoints\
    \ = static_cast<fastdds::rtps::SimplePDPEndpointsSecure*>(builtin_endpoints_.get());\n\
    +        reliability_kind = RELIABLE_RELIABILITY_QOS;\n+        pdp_reader_mask\
    \ = DISC_BUILTIN_ENDPOINT_PARTICIPANT_SECURE_DETECTOR;\n+        pdp_writer_mask\
    \ = DISC_BUILTIN_ENDPOINT_PARTICIPANT_SECURE_ANNOUNCER;\n+        reader_entity_id\
    \ = c_EntityId_spdp_reliable_participant_secure_reader;\n+        writer_entity_id\
    \ = c_EntityId_spdp_reliable_participant_secure_writer;\n+        reader = secure_endpoints->secure_reader.reader_;\n\
    +        writer = secure_endpoints->secure_writer.writer_;\n+    }\n+#endif //\
    \ HAVE_SECURITY\n+\n+    if (0 != (endp & pdp_writer_mask))\n+    {\n+       \
    \ auto temp_writer_data = get_temporary_writer_proxies_pool().get();\n+\n+   \
    \     temp_writer_data->clear();\n+        temp_writer_data->guid().guidPrefix\
    \ = pdata.m_guid.guidPrefix;\n+        temp_writer_data->guid().entityId = writer_entity_id;\n\
    +        temp_writer_data->persistence_guid(pdata.get_persistence_guid());\n+\
    \        temp_writer_data->set_persistence_entity_id(writer_entity_id);\n+   \
    \     temp_writer_data->set_remote_locators(pdata.metatraffic_locators, network,\
    \ use_multicast_locators);\n+        temp_writer_data->m_qos.m_reliability.kind\
    \ = reliability_kind;\n+        temp_writer_data->m_qos.m_durability.kind = TRANSIENT_LOCAL_DURABILITY_QOS;\n\
    +#if HAVE_SECURITY\n+        if (notify_secure_endpoints)\n+        {\n+     \
    \       if (!mp_RTPSParticipant->security_manager().discovered_builtin_writer(\n\
    +                        reader->getGuid(), pdata.m_guid, *temp_writer_data,\n\
    +                        reader->getAttributes().security_attributes()))\n+  \
    \          {\n+                EPROSIMA_LOG_ERROR(RTPS_EDP, \"Security manager\
    \ returns an error for writer \" <<\n+                        temp_writer_data->guid());\n\
    +            }\n+        }\n+        else\n+#endif // HAVE_SECURITY\n+       \
    \ {\n+            reader->matched_writer_add(*temp_writer_data);\n+        }\n\
    +    }\n+\n+    if (0 != (endp & pdp_reader_mask))\n+    {\n+        auto temp_reader_data\
    \ = get_temporary_reader_proxies_pool().get();\n+\n+        temp_reader_data->clear();\n\
    +        temp_reader_data->m_expectsInlineQos = false;\n+        temp_reader_data->guid().guidPrefix\
    \ = pdata.m_guid.guidPrefix;\n+        temp_reader_data->guid().entityId = reader_entity_id;\n\
    +        temp_reader_data->set_remote_locators(pdata.metatraffic_locators, network,\
    \ use_multicast_locators);\n+        temp_reader_data->m_qos.m_reliability.kind\
    \ = reliability_kind;\n+        temp_reader_data->m_qos.m_durability.kind = TRANSIENT_LOCAL_DURABILITY_QOS;\n\
    +#if HAVE_SECURITY\n+        if (notify_secure_endpoints)\n+        {\n+     \
    \       if (!mp_RTPSParticipant->security_manager().discovered_builtin_reader(\n\
    +                        writer->getGuid(), pdata.m_guid, *temp_reader_data,\n\
    +                        writer->getAttributes().security_attributes()))\n+  \
    \          {\n+                EPROSIMA_LOG_ERROR(RTPS_EDP, \"Security manager\
    \ returns an error for reader \" <<\n+                        temp_reader_data->guid());\n\
    +            }\n+        }\n+        else\n+#endif // HAVE_SECURITY\n+       \
    \ {\n+            writer->matched_reader_add(*temp_reader_data);\n+        }\n\
    +\n+        if (BEST_EFFORT_RELIABILITY_QOS == reliability_kind)\n+        {\n\
    +            endpoints->writer.writer_->unsent_changes_reset();\n+        }\n\
    +    }\n+}\n+\n+void PDPSimple::assign_low_level_remote_endpoints(\n+        const\
    \ ParticipantProxyData& pdata,\n+        bool notify_secure_endpoints)\n+{\n \
    \    if (mp_EDP != nullptr)\n     {\n-        mp_EDP->assignRemoteEndpoints(pdata,\
    \ (notify_secure_endpoints ? true : false));\n+        mp_EDP->assignRemoteEndpoints(pdata,\
    \ notify_secure_endpoints);\n     }\n \n     if (mp_builtin->mp_WLP != nullptr)\n\
    \     {\n-        mp_builtin->mp_WLP->assignRemoteEndpoints(pdata, (notify_secure_endpoints\
    \ ? true : false));\n+        mp_builtin->mp_WLP->assignRemoteEndpoints(pdata,\
    \ notify_secure_endpoints);\n     }\n \n     if (mp_builtin->tlm_ != nullptr)\n\
    @@ -509,6 +733,37 @@ void PDPSimple::notifyAboveRemoteEndpoints(\n     }\n }\n\
    \ \n+#if HAVE_SECURITY\n+bool PDPSimple::pairing_remote_writer_with_local_reader_after_security(\n\
    +        const GUID_t& local_reader,\n+        const WriterProxyData& remote_writer_data)\n\
    +{\n+    auto endpoints = dynamic_cast<fastdds::rtps::SimplePDPEndpointsSecure*>(builtin_endpoints_.get());\n\
    +    if ((nullptr != endpoints) && (local_reader == endpoints->secure_reader.reader_->getGuid()))\n\
    +    {\n+        endpoints->secure_reader.reader_->matched_writer_add(remote_writer_data);\n\
    +        return true;\n+    }\n+\n+    return PDP::pairing_remote_writer_with_local_reader_after_security(local_reader,\
    \ remote_writer_data);\n+}\n+\n+bool PDPSimple::pairing_remote_reader_with_local_writer_after_security(\n\
    +        const GUID_t& local_writer,\n+        const ReaderProxyData& remote_reader_data)\n\
    +{\n+    auto endpoints = dynamic_cast<fastdds::rtps::SimplePDPEndpointsSecure*>(builtin_endpoints_.get());\n\
    +    if ((nullptr != endpoints) && (local_writer == endpoints->secure_writer.writer_->getGuid()))\n\
    +    {\n+        endpoints->secure_writer.writer_->matched_reader_add(remote_reader_data);\n\
    +        return true;\n+    }\n+\n+    return PDP::pairing_remote_reader_with_local_writer_after_security(local_writer,\
    \ remote_reader_data);\n+}\n+\n+#endif // HAVE_SECURITY\n+\n bool PDPSimple::newRemoteEndpointStaticallyDiscovered(\n\
    \         const GUID_t& pguid,\n         int16_t userDefinedId,"
  - "--- a/src/cpp/rtps/reader/StatelessReader.cpp\n+++ b/src/cpp/rtps/reader/StatelessReader.cpp\n\
    @@ -306,14 +306,24 @@ bool StatelessReader::change_received(\n     // TODO Revisar\
    \ si no hay que incluirlo.\n     if (!thereIsUpperRecordOf(change->writerGUID,\
    \ change->sequenceNumber))\n     {\n-        // Update Ownership strength.\n-\
    \        if (EXCLUSIVE_OWNERSHIP_QOS == m_att.ownershipKind)\n+        bool update_notified\
    \ = true;\n+\n+        decltype(matched_writers_)::iterator writer = matched_writers_.end();\n\
    +        if ((EXCLUSIVE_OWNERSHIP_QOS == m_att.ownershipKind) ||\n+          \
    \      (m_trustedWriterEntityId == change->writerGUID.entityId))\n         {\n\
    -            auto writer = std::find_if(matched_writers_.begin(), matched_writers_.end(),\n\
    +            writer = std::find_if(matched_writers_.begin(), matched_writers_.end(),\n\
    \                             [change](const RemoteWriterInfo_t& item)\n     \
    \                        {\n                                 return item.guid\
    \ == change->writerGUID;\n                             });\n+            bool\
    \ is_matched = matched_writers_.end() != writer;\n+            update_notified\
    \ = is_matched;\n+        }\n+\n+        // Update Ownership strength.\n+    \
    \    if (EXCLUSIVE_OWNERSHIP_QOS == m_att.ownershipKind)\n+        {\n       \
    \      assert(matched_writers_.end() != writer);\n             change->reader_info.writer_ownership_strength\
    \ = writer->ownership_strength;\n         }\n@@ -329,7 +339,11 @@ bool StatelessReader::change_received(\n\
    \             auto seq = change->sequenceNumber;\n \n             Time_t::now(change->reader_info.receptionTimestamp);\n\
    -            SequenceNumber_t previous_seq = update_last_notified(change->writerGUID,\
    \ change->sequenceNumber);\n+            SequenceNumber_t previous_seq{ 0, 0 };\n\
    +            if (update_notified)\n+            {\n+                previous_seq\
    \ = update_last_notified(change->writerGUID, change->sequenceNumber);\n+     \
    \       }\n             ++total_unread_;\n \n             on_data_notify(guid,\
    \ change->sourceTimestamp);"
  - "--- a/src/cpp/rtps/security/SecurityManager.cpp\n+++ b/src/cpp/rtps/security/SecurityManager.cpp\n\
    @@ -680,6 +680,11 @@ bool SecurityManager::discovered_participant(\n         {\n\
    \             return false;\n         }\n+\n+        if (remote_participant_info->auth_status_\
    \ == AUTHENTICATION_FAILED)\n+        {\n+            remote_participant_info->auth_status_\
    \ = AUTHENTICATION_REQUEST_NOT_SEND;\n+        }\n     }\n \n     bool returnedValue\
    \ = true;\n@@ -846,6 +851,7 @@ bool SecurityManager::on_process_handshake(\n \n\
    \     if (ret == VALIDATION_FAILED)\n     {\n+        remote_participant_info->auth_status_\
    \ = AUTHENTICATION_FAILED;\n         on_validation_failed(participant_data, exception);\n\
    \         return false;\n     }\n@@ -4180,9 +4186,13 @@ void SecurityManager::resend_handshake_message_token(\n\
    \         {\n             if (remote_participant_info->handshake_requests_sent_\
    \ >= DiscoveredParticipantInfo::MAX_HANDSHAKE_REQUESTS)\n             {\n-   \
    \             SecurityException exception;\n-                remote_participant_info->event_->cancel_timer();\n\
    -                on_validation_failed(dp_it->second->participant_data(), exception);\n\
    +                if (remote_participant_info->auth_status_ != AUTHENTICATION_FAILED)\n\
    +                {\n+                    SecurityException exception;\n+     \
    \               remote_participant_info->event_->cancel_timer();\n+          \
    \          remote_participant_info->auth_status_ = AUTHENTICATION_FAILED;\n+ \
    \                   on_validation_failed(dp_it->second->participant_data(), exception);\n\
    +                }\n             }\n             else\n             {"
  - "--- a/test/blackbox/common/BlackboxTestsSecurity.cpp\n+++ b/test/blackbox/common/BlackboxTestsSecurity.cpp\n\
    @@ -16,21 +16,24 @@\n \n #if HAVE_SECURITY\n \n+#include <atomic>\n+#include <algorithm>\n\
    +#include <fstream>\n+#include <map>\n+\n+#include <gtest/gtest.h>\n+\n #include\
    \ \"PubSubReader.hpp\"\n #include \"PubSubWriter.hpp\"\n #include \"PubSubWriterReader.hpp\"\
    \n #include \"PubSubParticipant.hpp\"\n \n-#include <gtest/gtest.h>\n-#include\
    \ <fstream>\n-#include <map>\n-#include <algorithm>\n-\n-#include <fastrtps/xmlparser/XMLProfileManager.h>\n\
    +#include <fastdds/dds/log/Log.hpp>\n+#include <fastdds/rtps/common/EntityId_t.hpp>\n\
    \ #include <fastdds/rtps/transport/shared_mem/SharedMemTransportDescriptor.h>\n\
    -#include <rtps/transport/test_UDPv4Transport.h>\n+#include <fastrtps/xmlparser/XMLProfileManager.h>\n\
    \ \n-#include <fastdds/dds/log/Log.hpp>\n+#include <rtps/transport/test_UDPv4Transport.h>\n\
    \ \n using namespace eprosima::fastrtps;\n using namespace eprosima::fastrtps::rtps;\n\
    @@ -88,6 +91,31 @@ class Security : public testing::TestWithParam<communication_type>\n\
    \ \n };\n \n+struct UDPMessageSender\n+{\n+    asio::io_service service;\n+  \
    \  asio::ip::udp::socket socket;\n+\n+    UDPMessageSender()\n+        : service()\n\
    +        , socket(service)\n+    {\n+        socket.open(asio::ip::udp::v4());\n\
    +    }\n+\n+    void send(\n+            const CDRMessage_t& msg,\n+         \
    \   const Locator_t& destination)\n+    {\n+        std::string addr = IPLocator::toIPv4string(destination);\n\
    +        unsigned short port = static_cast<unsigned short>(destination.port);\n\
    +        auto remote = asio::ip::udp::endpoint(asio::ip::address::from_string(addr),\
    \ port);\n+        asio::error_code ec;\n+\n+        socket.send_to(asio::buffer(msg.buffer,\
    \ msg.length), remote, 0, ec);\n+    }\n+\n+};\n \n class SecurityPkcs : public\
    \ ::testing::Test\n {\n@@ -441,7 +469,7 @@ TEST_P(Security, BuiltinAuthenticationPlugin_PKIDH_lossy_conditions)\n\
    \ }\n \n // Regresion test for Refs #13295, github #2362\n-TEST_P(Security, BuiltinAuthenticationPlugin_second_participant_creation_loop)\n\
    +TEST(Security, BuiltinAuthenticationPlugin_second_participant_creation_loop)\n\
    \ {\n     constexpr size_t n_loops = 101;\n \n@@ -477,6 +505,63 @@ TEST_P(Security,\
    \ BuiltinAuthenticationPlugin_second_participant_creation_loop)\n     Log::ClearConsumers();\n\
    \     Log::RegisterConsumer(std::unique_ptr<LogConsumer>(new TestConsumer(n_logs)));\n\
    \ \n+    // Class to allow waiting for the authentication message to be sent\n\
    +    class AuthMessageSendStatus\n+    {\n+        bool message_sent_ = false;\n\
    +        std::mutex mutex_;\n+        std::condition_variable cv_;\n+\n+    public:\n\
    +\n+        void reset()\n+        {\n+            std::lock_guard < std::mutex>\
    \ guard(mutex_);\n+            message_sent_ = false;\n+        }\n+\n+      \
    \  void notify()\n+        {\n+            std::lock_guard<std::mutex> guard(mutex_);\n\
    +            message_sent_ = true;\n+            cv_.notify_one();\n+        }\n\
    +\n+        void wait()\n+        {\n+            std::unique_lock<std::mutex>\
    \ lock(mutex_);\n+            cv_.wait(lock, [this]() -> bool\n+             \
    \       {\n+                        return message_sent_;\n+                 \
    \   });\n+        }\n+\n+    };\n+\n+    // Prepare transport to check that the\
    \ authentication message is sent\n+    auto transport = std::make_shared<test_UDPv4TransportDescriptor>();\n\
    +    AuthMessageSendStatus auth_message_send_status;\n+    transport->drop_data_messages_filter_\
    \ = [&auth_message_send_status](eprosima::fastrtps::rtps::CDRMessage_t& msg)\n\
    +            -> bool\n+            {\n+                auto old_pos = msg.pos;\n\
    +\n+                // Jump to writer entity id\n+                msg.pos += 2\
    \ + 2 + 4;\n+\n+                // Read writer entity id\n+                eprosima::fastrtps::rtps::GUID_t\
    \ writer_guid;\n+                eprosima::fastrtps::rtps::CDRMessage::readEntityId(&msg,\
    \ &writer_guid.entityId);\n+                msg.pos = old_pos;\n+\n+         \
    \       if (writer_guid.entityId == eprosima::fastrtps::rtps::participant_stateless_message_writer_entity_id)\n\
    +                {\n+                    auth_message_send_status.notify();\n\
    +                }\n+\n+                return false;\n+            };\n+\n  \
    \   // Prepare participant properties\n     PropertyPolicy property_policy;\n\
    \     property_policy.properties().emplace_back(Property(\"dds.sec.auth.plugin\"\
    , \"builtin.PKI-DH\"));\n@@ -489,6 +574,7 @@ TEST_P(Security, BuiltinAuthenticationPlugin_second_participant_creation_loop)\n\
    \ \n     // Create the participant being checked\n     PubSubReader<HelloWorldPubSubType>\
    \ main_participant(\"HelloWorldTopic\");\n+    main_participant.disable_builtin_transport().add_user_transport_to_pparams(transport);\n\
    \     main_participant.property_policy(property_policy).init();\n     EXPECT_TRUE(main_participant.isInitialized());\n\
    \ \n@@ -501,13 +587,14 @@ TEST_P(Security, BuiltinAuthenticationPlugin_second_participant_creation_loop)\n\
    \ \n         // Wait for undiscovery so we can wait for discovery below\n    \
    \     EXPECT_TRUE(main_participant.wait_participant_undiscovery());\n+       \
    \ auth_message_send_status.reset();\n \n         // Create another participant\
    \ with authentication enabled\n         PubSubParticipant<HelloWorldPubSubType>\
    \ other_participant(0, 0, 0, 0);\n         EXPECT_TRUE(other_participant.property_policy(property_policy).init_participant());\n\
    \ \n-        // Wait for the new participant to be discovered by the main one\n\
    -        EXPECT_TRUE(main_participant.wait_participant_discovery());\n+      \
    \  // Wait for the main participant to send an authentication message to the other\
    \ participant\n+        auth_message_send_status.wait();\n \n         // The created\
    \ participant gets out of scope here, and is destroyed\n     }\n@@ -3668,11 +3755,14\
    \ @@ TEST(Security, AllowUnauthenticatedParticipants_TwoSecureParticipantsWithDiffere\n\
    \ \n     ASSERT_TRUE(writer.isInitialized());\n \n-    //! Wait enough time for\
    \ the PKI requests to time out and give validation_failed (~15secs)\n-    writer.wait_discovery(std::chrono::seconds(20));\n\
    +    //! Wait for the authorization to fail (~15secs)\n+    writer.waitUnauthorized();\n\
    +\n+    //! Wait for the discovery\n+    writer.wait_discovery();\n \n     //!\
    \ check that the writer matches the reader because of having allow_unauthenticated_participants\
    \ enabled\n-    ASSERT_TRUE(writer.get_matched());\n+    ASSERT_TRUE(writer.is_matched());\n\
    \ \n     //! Data is correctly sent and received\n     auto data = default_helloworld_data_generator();\n\
    @@ -3748,13 +3838,16 @@ TEST(Security, AllowUnauthenticatedParticipants_TwoParticipantsDifferentCertific\n\
    \ \n     ASSERT_TRUE(writer.isInitialized());\n \n-    //! Wait enough time for\
    \ the PKI requests to time out and give validation_failed (~15secs)\n-    writer.wait_discovery(std::chrono::seconds(20));\n\
    +    //! Wait for the authorization to fail (~15secs)\n+    writer.waitUnauthorized();\n\
    +\n+    //! Wait some time afterwards (this will time out)\n+    writer.wait_discovery(std::chrono::seconds(1));\n\
    \ \n     //! check that the writer does not match the reader because of\n    \
    \ //! having read and write protection enabled\n     //! despite allow_unauthenticated_participants\
    \ is enabled\n-    ASSERT_FALSE(writer.get_matched());\n+    ASSERT_FALSE(writer.is_matched());\n\
    \ }\n \n // *INDENT-OFF*\n@@ -4497,32 +4590,7 @@ TEST(Security, MaliciousHeartbeatIgnore)\n\
    \                 return avoid_sec_submessages.load() && (0x30 == (msg.buffer[msg.pos]\
    \ & 0xF0));\n             };\n \n-    struct FakeMsg\n-    {\n-        asio::io_service\
    \ service;\n-        asio::ip::udp::socket socket;\n-\n-        FakeMsg()\n- \
    \           : service()\n-            , socket(service)\n-        {\n-       \
    \     socket.open(asio::ip::udp::v4());\n-        }\n-\n-        void send(\n\
    -                const CDRMessage_t& msg,\n-                const Locator_t& destination)\n\
    -        {\n-            std::string addr = IPLocator::toIPv4string(destination);\n\
    -            unsigned short port = static_cast<unsigned short>(destination.port);\n\
    -            auto remote = asio::ip::udp::endpoint(asio::ip::address::from_string(addr),\
    \ port);\n-            asio::error_code ec;\n-\n-            socket.send_to(asio::buffer(msg.buffer,\
    \ msg.length), remote, 0, ec);\n-        }\n-\n-    };\n-    FakeMsg fake_msg;\n\
    +    UDPMessageSender fake_msg_sender;\n \n     writer.disable_builtin_transport().add_user_transport_to_pparams(transport);\n\
    \     reader.disable_builtin_transport().add_user_transport_to_pparams(transport);\n\
    @@ -4574,7 +4642,7 @@ TEST(Security, MaliciousHeartbeatIgnore)\n         msg.init(reinterpret_cast<octet*>(&hb),\
    \ msg_len);\n         msg.length = msg_len;\n         msg.pos = msg_len;\n-  \
    \      fake_msg.send(msg, reader_locator);\n+        fake_msg_sender.send(msg,\
    \ reader_locator);\n     }\n \n     // Enable secure submessages\n@@ -4583,6 +4651,125\
    \ @@ TEST(Security, MaliciousHeartbeatIgnore)\n     reader.block_for_all();\n\
    \ }\n \n+TEST_P(Security, MaliciousParticipantRemovalIgnore)\n+{\n+    PubSubWriter<HelloWorldPubSubType>\
    \ writer(\"HelloWorldTopic_MaliciousParticipantRemovalIgnore\");\n+    PubSubReader<HelloWorldPubSubType>\
    \ reader(\"HelloWorldTopic_MaliciousParticipantRemovalIgnore\");\n+\n+    struct\
    \ MaliciousParticipantRemoval\n+    {\n+        std::array<char, 4> rtps_id{ {'R',\
    \ 'T', 'P', 'S'} };\n+        std::array<uint8_t, 2> protocol_version{ {2, 3}\
    \ };\n+        std::array<uint8_t, 2> vendor_id{ {0x01, 0x0F} };\n+        GuidPrefix_t\
    \ sender_prefix{};\n+\n+        struct DataSubMsg\n+        {\n+            struct\
    \ Header\n+            {\n+                uint8_t submessage_id = 0x15;\n+#if\
    \ FASTDDS_IS_BIG_ENDIAN_TARGET\n+                uint8_t flags = 0x02;\n+#else\n\
    +                uint8_t flags = 0x03;\n+#endif  // FASTDDS_IS_BIG_ENDIAN_TARGET\n\
    +                uint16_t submessage_length = 2 + 2 + 4 + 4 + 8;\n+          \
    \      uint16_t extra_flags = 0;\n+                uint16_t octets_to_inline_qos\
    \ = 4 + 4 + 8;\n+                EntityId_t reader_id{};\n+                EntityId_t\
    \ writer_id{};\n+                SequenceNumber_t sn{};\n+            };\n+\n\
    +            struct InlineQos\n+            {\n+                struct KeyHash\n\
    +                {\n+                    uint16_t pid = 0x0070;  // PID_KEY_HASH\n\
    +                    uint16_t plen = 16;\n+                    GUID_t guid{};\n\
    +                };\n+\n+                struct StatusInfo\n+                {\n\
    +                    uint16_t pid = 0x0071;  // PID_STATUS_INFO\n+           \
    \         uint16_t plen = 4;\n+                    uint8_t flags[4] = { 0x00,\
    \ 0x00, 0x00, 0x03 };\n+                };\n+\n+                struct Sentinel\n\
    +                {\n+                    uint16_t pid = 0x0001;  // PID_SENTINEL\n\
    +                    uint16_t plen = 0;\n+                };\n+\n+           \
    \     KeyHash hash;\n+                StatusInfo status;\n+                Sentinel\
    \ sentinel;\n+            };\n+\n+            Header header;\n+            InlineQos\
    \ inline_qos;\n+        }\n+        data;\n+    };\n+\n+    // Set common QoS\n\
    +    reader.history_depth(10).reliability(eprosima::fastrtps::RELIABLE_RELIABILITY_QOS);\n\
    +    writer.history_depth(10).reliability(eprosima::fastrtps::RELIABLE_RELIABILITY_QOS);\n\
    +\n+    // Configure security\n+    const std::string governance_file(\"governance_helloworld_all_enable.smime\"\
    );\n+    const std::string permissions_file(\"permissions_helloworld.smime\");\n\
    +    CommonPermissionsConfigure(reader, writer, governance_file, permissions_file);\n\
    +\n+    // Initialize and wait for authorization and discovery\n+    reader.init();\n\
    +    ASSERT_TRUE(reader.isInitialized());\n+    writer.init();\n+    ASSERT_TRUE(writer.isInitialized());\n\
    +    reader.waitAuthorized();\n+    writer.waitAuthorized();\n+    reader.wait_discovery();\n\
    +    writer.wait_discovery();\n+\n+    // Send fake DATA(p[UD])\n+    UDPMessageSender\
    \ fake_msg_sender;\n+    {\n+        auto writer_guid = writer.datawriter_guid();\n\
    +        auto participant_guid = writer.participant_guid();\n+        auto domain_id\
    \ = static_cast<uint32_t>(GET_PID() % 230);\n+\n+        MaliciousParticipantRemoval\
    \ packet{};\n+        packet.sender_prefix = writer_guid.guidPrefix;\n+      \
    \  packet.data.header.submessage_length += sizeof(packet.data.inline_qos);\n+\
    \        packet.data.header.writer_id = c_EntityId_SPDPWriter;\n+        packet.data.header.reader_id\
    \ = c_EntityId_SPDPReader;\n+        packet.data.header.sn.low = 100;\n+     \
    \   packet.data.inline_qos.hash.guid = participant_guid;\n+\n+        Locator_t\
    \ mcast_locator;\n+        ASSERT_TRUE(IPLocator::setIPv4(mcast_locator, \"239.255.0.1\"\
    ));\n+        mcast_locator.port = 7400 + 250 * domain_id;\n+\n+        CDRMessage_t\
    \ msg(0);\n+        uint32_t msg_len = static_cast<uint32_t>(sizeof(packet));\n\
    +        msg.init(reinterpret_cast<octet*>(&packet), msg_len);\n+        msg.length\
    \ = msg_len;\n+        msg.pos = msg_len;\n+        fake_msg_sender.send(msg,\
    \ mcast_locator);\n+    }\n+\n+    EXPECT_FALSE(reader.wait_participant_undiscovery(std::chrono::seconds(1)));\n\
    +\n+    auto data = default_helloworld_data_generator();\n+    reader.startReception(data);\n\
    +    writer.send(data);\n+    ASSERT_TRUE(data.empty());\n+    reader.block_for_all();\n\
    +}\n+\n+\n void blackbox_security_init()\n {\n     certs_path = std::getenv(\"\
    CERTS_PATH\");"
  - "--- a/test/unittest/rtps/discovery/PDPTests.cpp\n+++ b/test/unittest/rtps/discovery/PDPTests.cpp\n\
    @@ -15,6 +15,7 @@\n #include <chrono>\n #include <iostream>\n #include <future>\n\
    +#include <memory>\n #include <gmock/gmock.h>\n #include <gtest/gtest.h>\n #include\
    \ <string>\n@@ -27,6 +28,7 @@\n #include <fastdds/dds/publisher/DataWriterListener.hpp>\n\
    \ #include <fastdds/rtps/builtin/BuiltinProtocols.h>\n #include <fastdds/rtps/builtin/discovery/participant/PDP.h>\n\
    +#include <fastdds/rtps/reader/ReaderListener.h>\n #include <fastrtps/rtps/builtin/data/ReaderProxyData.h>\n\
    \ #include <fastrtps/rtps/builtin/data/WriterProxyData.h>\n \n@@ -71,6 +73,11\
    \ @@ class TesterPDPEndpoints : public fastdds::rtps::PDPEndpoints\n         return\
    \ DISC_BUILTIN_ENDPOINT_PARTICIPANT_ANNOUNCER | DISC_BUILTIN_ENDPOINT_PARTICIPANT_DETECTOR;\n\
    \     }\n \n+    const std::unique_ptr<fastrtps::rtps::ReaderListener>& main_listener()\
    \ const override\n+    {\n+        return no_listener_;\n+    }\n+\n     bool\
    \ enable_pdp_readers(\n             fastrtps::rtps::RTPSParticipantImpl*) override\n\
    \     {\n@@ -101,6 +108,8 @@ class TesterPDPEndpoints : public fastdds::rtps::PDPEndpoints\n\
    \ \n     }\n \n+    std::unique_ptr<fastrtps::rtps::ReaderListener> no_listener_;\n\
    +\n };\n \n class PDPTester : public PDP"
  identifiers: CVE:["CVE-2023-50257"],CWE:["CWE-488"]
  overview: Affected versions of this package are vulnerable to Exposure of Data Element
    to Wrong Session due to `p[UD]` and `guid` values in RTPS packets not being encrypted.
    An attacker can exploit this to forcibly disconnect a Subscriber and deny their
    attempts to connect. If the attacker then sends the `data(p[UD])` packet to the
    Global Data Space (239.255.0.1:7400) using the Publisher ID, all other Subscribers
    (Listeners) connected to the Publisher (Talker) will not receive any data and
    their connection will be disconnected.
  references:
    GitHub Commit: https://github.com/eProsima/Fast-DDS/commit/f2e5ceae8fbea0a6c9445a366faaca0b98a8ef86
  title: Exposure of Data Element to Wrong Session
- diff_content:
  - "--- a/filename.c\n+++ b/filename.c\n@@ -972,6 +972,8 @@ close_altfile(altfilename,\
    \ filename)\n {\n #if HAVE_POPEN\n \tchar *lessclose;\n+\tchar *qfilename;\n+\t\
    char *qaltfilename;\n \tFILE *fd;\n \tchar *cmd;\n \tint len;\n@@ -986,9 +988,13\
    \ @@ close_altfile(altfilename, filename)\n \t\terror(\"LESSCLOSE ignored; must\
    \ contain no more than 2 %%s\", NULL_PARG);\n \t\treturn;\n \t}\n-\tlen = (int)\
    \ (strlen(lessclose) + strlen(filename) + strlen(altfilename) + 2);\n+\tqfilename\
    \ = shell_quote(filename);\n+\tqaltfilename = shell_quote(altfilename);\n+\tlen\
    \ = (int) (strlen(lessclose) + strlen(qfilename) + strlen(qaltfilename) + 2);\n\
    \ \tcmd = (char *) ecalloc(len, sizeof(char));\n-\tSNPRINTF2(cmd, len, lessclose,\
    \ filename, altfilename);\n+\tSNPRINTF2(cmd, len, lessclose, qfilename, qaltfilename);\n\
    +\tfree(qaltfilename);\n+\tfree(qfilename);\n \tfd = shellcmd(cmd);\n \tfree(cmd);\n\
    \ \tif (fd != NULL)"
  identifiers: CVE:["CVE-2022-48624"],CWE:["CWE-78"]
  overview: Affected versions of this package are vulnerable to Improper Neutralization
    of Special Elements used in an OS Command ('OS Command Injection') due to the
    omission of `shell_quote` calls for `LESSCLOSE` in `close_altfile` within `filename.c`.
    An attacker can execute arbitrary code by crafting a malicious input that exploits
    the lack of proper shell quoting.
  references:
    GitHub Commit: https://github.com/gwsw/less/commit/c6ac6de49698be84d264a0c4c0c40bb870b10144
  title: Improper Neutralization of Special Elements used in an OS Command ('OS Command
    Injection')
- diff_content:
  - "--- a/drivers/can/can_loopback.c\n+++ b/drivers/can/can_loopback.c\n@@ -211,7\
    \ +211,7 @@ static void can_loopback_remove_rx_filter(const struct device *dev,\
    \ int filter_i\n {\n \tstruct can_loopback_data *data = dev->data;\n \n-\tif (filter_id\
    \ >= ARRAY_SIZE(data->filters)) {\n+\tif (filter_id < 0 || filter_id >= ARRAY_SIZE(data->filters))\
    \ {\n \t\tLOG_ERR(\"filter ID %d out-of-bounds\", filter_id);\n \t\treturn;\n\
    \ \t}"
  - "--- a/drivers/can/can_mcan.c\n+++ b/drivers/can/can_mcan.c\n@@ -1149,12 +1149,17\
    \ @@ void can_mcan_remove_rx_filter(const struct device *dev, int filter_id)\n\
    \ \tstruct can_mcan_data *data = dev->data;\n \tint err;\n \n+\tif (filter_id\
    \ < 0) {\n+\t\tLOG_ERR(\"filter ID %d out of bounds\", filter_id);\n+\t\treturn;\n\
    +\t}\n+\n \tk_mutex_lock(&data->lock, K_FOREVER);\n \n \tif (filter_id >= cbs->num_std)\
    \ {\n \t\tfilter_id -= cbs->num_std;\n \t\tif (filter_id >= cbs->num_ext) {\n\
    -\t\t\tLOG_ERR(\"Wrong filter id\");\n+\t\t\tLOG_ERR(\"filter ID %d out of bounds\"\
    , filter_id);\n \t\t\tk_mutex_unlock(&data->lock);\n \t\t\treturn;\n \t\t}"
  - "--- a/drivers/can/can_mcp2515.c\n+++ b/drivers/can/can_mcp2515.c\n@@ -663,6 +663,11\
    \ @@ static void mcp2515_remove_rx_filter(const struct device *dev, int filter_id)\n\
    \ {\n \tstruct mcp2515_data *dev_data = dev->data;\n \n+\tif (filter_id < 0 ||\
    \ filter_id >= CONFIG_CAN_MAX_FILTER) {\n+\t\tLOG_ERR(\"filter ID %d out of bounds\"\
    , filter_id);\n+\t\treturn;\n+\t}\n+\n \tk_mutex_lock(&dev_data->mutex, K_FOREVER);\n\
    \ \tdev_data->filter_usage &= ~BIT(filter_id);\n \tk_mutex_unlock(&dev_data->mutex);"
  - "--- a/drivers/can/can_mcux_flexcan.c\n+++ b/drivers/can/can_mcux_flexcan.c\n\
    @@ -922,9 +922,8 @@ static void mcux_flexcan_remove_rx_filter(const struct device\
    \ *dev, int filter_i\n {\n \tstruct mcux_flexcan_data *data = dev->data;\n \n\
    -\tif (filter_id >= MCUX_FLEXCAN_MAX_RX) {\n-\t\tLOG_ERR(\"Detach: Filter id >=\
    \ MAX_RX (%d >= %d)\", filter_id,\n-\t\t\tMCUX_FLEXCAN_MAX_RX);\n+\tif (filter_id\
    \ < 0 || filter_id >= MCUX_FLEXCAN_MAX_RX) {\n+\t\tLOG_ERR(\"filter ID %d out\
    \ of bounds\", filter_id);\n \t\treturn;\n \t}\n "
  - "--- a/drivers/can/can_native_posix_linux.c\n+++ b/drivers/can/can_native_posix_linux.c\n\
    @@ -239,6 +239,7 @@ static void can_npl_remove_rx_filter(const struct device *dev,\
    \ int filter_id)\n \tstruct can_npl_data *data = dev->data;\n \n \tif (filter_id\
    \ < 0 || filter_id >= ARRAY_SIZE(data->filters)) {\n+\t\tLOG_ERR(\"filter ID %d\
    \ out of bounds\");\n \t\treturn;\n \t}\n "
  - "--- a/drivers/can/can_nxp_s32_canxl.c\n+++ b/drivers/can/can_nxp_s32_canxl.c\n\
    @@ -396,7 +396,10 @@ static void can_nxp_s32_remove_rx_filter(const struct device\
    \ *dev, int filter_id\n \tstruct can_nxp_s32_data *data = dev->data;\n \tint mb_indx\
    \ = ALLOC_IDX_TO_RXMB_IDX(filter_id);\n \n-\t__ASSERT_NO_MSG(filter_id >= 0 &&\
    \ filter_id < CONFIG_CAN_NXP_S32_MAX_RX);\n+\tif (filter_id < 0 || filter_id >=\
    \ CONFIG_CAN_NXP_S32_MAX_RX) {\n+\t\tLOG_ERR(\"filter ID %d out of bounds\", filter_id);\n\
    +\t\treturn;\n+\t}\n \n \tk_mutex_lock(&data->rx_mutex, K_FOREVER);\n "
  - "--- a/drivers/can/can_rcar.c\n+++ b/drivers/can/can_rcar.c\n@@ -975,7 +975,8\
    \ @@ static void can_rcar_remove_rx_filter(const struct device *dev, int filter_id)\n\
    \ {\n \tstruct can_rcar_data *data = dev->data;\n \n-\tif (filter_id >= CONFIG_CAN_RCAR_MAX_FILTER)\
    \ {\n+\tif (filter_id < 0 || filter_id >= CONFIG_CAN_RCAR_MAX_FILTER) {\n+\t\t\
    LOG_ERR(\"filter ID %d out of bounds\", filter_id);\n \t\treturn;\n \t}\n "
  - "--- a/drivers/can/can_stm32_bxcan.c\n+++ b/drivers/can/can_stm32_bxcan.c\n@@\
    \ -1035,7 +1035,10 @@ static void can_stm32_remove_rx_filter(const struct device\
    \ *dev, int filter_id)\n \tint bank_num;\n \tbool bank_unused;\n \n-\t__ASSERT_NO_MSG(filter_id\
    \ >= 0 && filter_id < CAN_STM32_MAX_FILTER_ID);\n+\tif (filter_id < 0 || filter_id\
    \ >= CAN_STM32_MAX_FILTER_ID) {\n+\t\tLOG_ERR(\"filter ID %d out of bounds\",\
    \ filter_id);\n+\t\treturn;\n+\t}\n \n \tk_mutex_lock(&filter_mutex, K_FOREVER);\n\
    \ \tk_mutex_lock(&data->inst_mutex, K_FOREVER);"
  identifiers: CVE:["CVE-2023-5779"],CWE:["CWE-787"]
  overview: Affected versions of this package are vulnerable to Out-of-bounds Write
    due to improper validation in the `remove_rx_filter` function. An attacker can
    cause a system crash or potentially execute arbitrary code by sending specially
    crafted inputs to the function.
  references:
    GitHub Commit: https://github.com/zephyrproject-rtos/zephyr/commit/6c5400d2e1dbc6fc278dad8cce396208fbecc59a
  title: Out-of-bounds Write
- diff_content:
  - "--- a/subsys/settings/src/settings_shell.c\n+++ b/subsys/settings/src/settings_shell.c\n\
    @@ -182,6 +182,11 @@ static int cmd_write(const struct shell *shell_ptr, size_t\
    \ argc, char *argv[])\n \t\tbreak;\n \tcase SETTINGS_VALUE_STRING:\n \t\tbuffer_len\
    \ = strlen(argv[argc - 1]) + 1;\n+\t\tif (buffer_len > sizeof(buffer)) {\n+\t\t\
    \tshell_error(shell_ptr, \"%s is bigger than shell's buffer\", argv[argc - 1]);\n\
    +\t\t\treturn -EINVAL;\n+\t\t}\n+\n \t\tmemcpy(buffer, argv[argc - 1], buffer_len);\n\
    \ \t\tbreak;\n \t}"
  identifiers: CVE:["CVE-2023-6749"],CWE:["CWE-121"]
  overview: Affected versions of this package are vulnerable to Stack-based Buffer
    Overflow due to unchecked length coming from user input in the settings shell.
    An attacker can cause a denial of service by providing specially crafted input.
  references:
    GitHub Commit: https://github.com/zephyrproject-rtos/zephyr/commit/8977784afee870e107f639ace7a4b5cd57cfaeb6
    Vulnerable Code: https://github.com/zephyrproject-rtos/zephyr/blob/v3.5.0/subsys/settings/src/settings_shell.c
  title: Stack-based Buffer Overflow
- diff_content:
  - "--- a/src/xercesc/internal/DGXMLScanner.cpp\n+++ b/src/xercesc/internal/DGXMLScanner.cpp\n\
    @@ -1052,13 +1052,12 @@ void DGXMLScanner::scanDocTypeDecl()\n             DTDEntityDecl*\
    \ declDTD = new (fMemoryManager) DTDEntityDecl(gDTDStr, false, fMemoryManager);\n\
    \             declDTD->setSystemId(sysId);\n             declDTD->setIsExternal(true);\n\
    -            Janitor<DTDEntityDecl> janDecl(declDTD);\n \n             // Mark\
    \ this one as a throw at end\n             reader->setThrowAtEnd(true);\n \n \
    \            // And push it onto the stack, with its pseudo name\n-          \
    \  fReaderMgr.pushReader(reader, declDTD);\n+            fReaderMgr.pushReaderAdoptEntity(reader,\
    \ declDTD);\n \n             // Tell it its not in an include section\n      \
    \       dtdScanner.scanExtSubsetDecl(false, true);\n@@ -2131,13 +2130,12 @@ Grammar*\
    \ DGXMLScanner::loadDTDGrammar(const InputSource& src,\n     DTDEntityDecl* declDTD\
    \ = new (fMemoryManager) DTDEntityDecl(gDTDStr, false, fMemoryManager);\n    \
    \ declDTD->setSystemId(src.getSystemId());\n     declDTD->setIsExternal(true);\n\
    -    Janitor<DTDEntityDecl> janDecl(declDTD);\n \n     // Mark this one as a throw\
    \ at end\n     newReader->setThrowAtEnd(true);\n \n     // And push it onto the\
    \ stack, with its pseudo name\n-    fReaderMgr.pushReader(newReader, declDTD);\n\
    +    fReaderMgr.pushReaderAdoptEntity(newReader, declDTD);\n \n     //  If we\
    \ have a doc type handler and advanced callbacks are enabled,\n     //  call the\
    \ doctype event."
  - "--- a/src/xercesc/internal/IGXMLScanner.cpp\n+++ b/src/xercesc/internal/IGXMLScanner.cpp\n\
    @@ -1535,13 +1535,12 @@ void IGXMLScanner::scanDocTypeDecl()\n             DTDEntityDecl*\
    \ declDTD = new (fMemoryManager) DTDEntityDecl(gDTDStr, false, fMemoryManager);\n\
    \             declDTD->setSystemId(sysId);\n             declDTD->setIsExternal(true);\n\
    -            Janitor<DTDEntityDecl> janDecl(declDTD);\n \n             // Mark\
    \ this one as a throw at end\n             reader->setThrowAtEnd(true);\n \n \
    \            // And push it onto the stack, with its pseudo name\n-          \
    \  fReaderMgr.pushReader(reader, declDTD);\n+            fReaderMgr.pushReaderAdoptEntity(reader,\
    \ declDTD);\n \n             // Tell it its not in an include section\n      \
    \       dtdScanner.scanExtSubsetDecl(false, true);\n@@ -3098,13 +3097,12 @@ Grammar*\
    \ IGXMLScanner::loadDTDGrammar(const InputSource& src,\n     DTDEntityDecl* declDTD\
    \ = new (fMemoryManager) DTDEntityDecl(gDTDStr, false, fMemoryManager);\n    \
    \ declDTD->setSystemId(src.getSystemId());\n     declDTD->setIsExternal(true);\n\
    -    Janitor<DTDEntityDecl> janDecl(declDTD);\n \n     // Mark this one as a throw\
    \ at end\n     newReader->setThrowAtEnd(true);\n \n     // And push it onto the\
    \ stack, with its pseudo name\n-    fReaderMgr.pushReader(newReader, declDTD);\n\
    +    fReaderMgr.pushReaderAdoptEntity(newReader, declDTD);\n \n     //  If we\
    \ have a doc type handler and advanced callbacks are enabled,\n     //  call the\
    \ doctype event."
  - "--- a/src/xercesc/internal/ReaderMgr.cpp\n+++ b/src/xercesc/internal/ReaderMgr.cpp\n\
    @@ -45,12 +45,61 @@\n \n XERCES_CPP_NAMESPACE_BEGIN\n \n+// ---------------------------------------------------------------------------\n\
    +//  ReaderMgr::ReaderData: Constructors and Destructor\n+// ---------------------------------------------------------------------------\n\
    +ReaderMgr::ReaderData::ReaderData( XMLReader* const       reader\n+         \
    \                          , XMLEntityDecl* const entity\n+                  \
    \                 , const bool           adoptEntity) :\n+\n+    fReader(reader)\n\
    +    , fEntity(entity)\n+    , fEntityAdopted(adoptEntity)\n+{\n+}\n+\n+ReaderMgr::ReaderData::~ReaderData()\n\
    +{\n+    delete fReader;\n+\n+    if (fEntityAdopted)\n+        delete fEntity;\n\
    +}\n+\n+// ---------------------------------------------------------------------------\n\
    +//  ReaderMgr::ReaderData: Getter methods\n+// ---------------------------------------------------------------------------\n\
    +XMLReader* ReaderMgr::ReaderData::getReader() const\n+{\n+  return fReader;\n\
    +}\n+\n+XMLEntityDecl* ReaderMgr::ReaderData::getEntity() const\n+{\n+  return\
    \ fEntity;\n+}\n+\n+bool ReaderMgr::ReaderData::getEntityAdopted() const\n+{\n\
    +  return fEntityAdopted;\n+}\n+\n+//\n+//  This method gives up the entity object\
    \ ownership but leaves the fEntity\n+//  pointer intact.\n+//\n+XMLEntityDecl*\
    \ ReaderMgr::ReaderData::releaseEntity()\n+{\n+  fEntityAdopted = false;\n+  return\
    \ fEntity;\n+}\n+\n // ---------------------------------------------------------------------------\n\
    \ //  ReaderMgr: Constructors and Destructor\n // ---------------------------------------------------------------------------\n\
    \ ReaderMgr::ReaderMgr(MemoryManager* const manager) :\n \n-    fCurEntity(0)\n\
    +    fCurReaderData(0)\n     , fCurReader(0)\n     , fEntityHandler(0)\n     ,\
    \ fEntityStack(0)\n@@ -66,12 +115,11 @@ ReaderMgr::ReaderMgr(MemoryManager* const\
    \ manager) :\n ReaderMgr::~ReaderMgr()\n {\n     //\n-    //  Clean up the reader\
    \ and entity stacks. Note that we don't own the\n-    //  entities, so we don't\
    \ delete the current entity (and the entity stack\n-    //  does not own its elements\
    \ either, so deleting it will not delete the\n-    //  entities it still references!)\n\
    +    //  Clean up the reader stack and orphan entities container. Note that\n\
    +    //  all adopted entities (potentially contained in fCurReaderData,\n+   \
    \ //  fReaderStack, and fEntityStack) are deleted here.\n     //\n-    delete\
    \ fCurReader;\n+    delete fCurReaderData;\n     delete fReaderStack;\n     delete\
    \ fEntityStack;\n }\n@@ -357,9 +405,9 @@ void ReaderMgr::cleanStackBackTo(const\
    \ XMLSize_t readerNum)\n         if (fReaderStack->empty())\n             ThrowXMLwithMemMgr(RuntimeException,\
    \ XMLExcepts::RdrMgr_ReaderIdNotFound, fMemoryManager);\n \n-        delete fCurReader;\n\
    -        fCurReader = fReaderStack->pop();\n-        fCurEntity = fEntityStack->pop();\n\
    +        delete fCurReaderData;\n+        fCurReaderData = fReaderStack->pop();\n\
    +        fCurReader = fCurReaderData->getReader ();\n     }\n }\n \n@@ -795,28\
    \ +843,28 @@ const XMLCh* ReaderMgr::getCurrentEncodingStr() const\n \n const\
    \ XMLEntityDecl* ReaderMgr::getCurrentEntity() const\n {\n-    return fCurEntity;\n\
    +    return fCurReaderData? fCurReaderData->getEntity() : 0;\n }\n \n \n XMLEntityDecl*\
    \ ReaderMgr::getCurrentEntity()\n {\n-    return fCurEntity;\n+    return fCurReaderData?\
    \ fCurReaderData->getEntity() : 0;\n }\n \n \n XMLSize_t ReaderMgr::getReaderDepth()\
    \ const\n {\n     // If the stack doesn't exist, its obviously zero\n-    if (!fEntityStack)\n\
    +    if (!fReaderStack)\n         return 0;\n \n     //\n     //  The return is\
    \ the stack size, plus one if there is a current\n     //  reader. So if there\
    \ is no current reader and none on the stack,\n     //  its zero, else its some\
    \ non-zero value.\n     //\n-    XMLSize_t retVal = fEntityStack->size();\n+ \
    \   XMLSize_t retVal = fReaderStack->size();\n     if (fCurReader)\n         retVal++;\n\
    \     return retVal;\n@@ -852,7 +900,7 @@ void ReaderMgr::getLastExtEntityInfo(LastExtEntityInfo&\
    \ lastInfo) const\n bool ReaderMgr::isScanningPERefOutOfLiteral() const\n {\n\
    \     // If the current reader is not for an entity, then definitely not\n-  \
    \  if (!fCurEntity)\n+    if (!fCurReaderData || !fCurReaderData->getEntity())\n\
    \         return false;\n \n     //\n@@ -867,33 +915,50 @@ bool ReaderMgr::isScanningPERefOutOfLiteral()\
    \ const\n     return false;\n }\n \n-\n bool ReaderMgr::pushReader(         XMLReader*\
    \ const        reader\n                             ,       XMLEntityDecl* const\
    \    entity)\n+{\n+    return pushReaderAdoptEntity(reader, entity, false);\n\
    +}\n+\n+bool ReaderMgr::pushReaderAdoptEntity(     XMLReader* const        reader\n\
    +                                       ,   XMLEntityDecl* const    entity\n+\
    \                                       ,   const bool              adoptEntity)\n\
    \ {\n     //\n     //  First, if an entity was passed, we have to confirm that\
    \ this entity\n-    //  is not already on the entity stack. If so, then this is\
    \ a recursive\n+    //  is not already on the reader stack. If so, then this is\
    \ a recursive\n     //  entity expansion, so we issue an error and refuse to put\
    \ the reader\n     //  on the stack.\n     //\n     //  If there is no entity\
    \ passed, then its not an entity being pushed, so\n     //  nothing to do. If\
    \ there is no entity stack yet, then of coures it\n     //  cannot already be\
    \ there.\n     //\n-    if (entity && fEntityStack)\n+    if (entity && fReaderStack)\n\
    \     {\n-        const XMLSize_t count = fEntityStack->size();\n+        // @@\
    \ Strangely, we don't check the entity at the top of the stack\n+        //  \
    \  (fCurReaderData). Is it a bug?\n+        //\n+        const XMLSize_t count\
    \ = fReaderStack->size();\n         const XMLCh* const theName = entity->getName();\n\
    \         for (XMLSize_t index = 0; index < count; index++)\n         {\n-   \
    \         const XMLEntityDecl* curDecl = fEntityStack->elementAt(index);\n+  \
    \          const XMLEntityDecl* curDecl =\n+              fReaderStack->elementAt(index)->getEntity();\n\
    +\n             if (curDecl)\n             {\n                 if (XMLString::equals(theName,\
    \ curDecl->getName()))\n                 {\n-                    // Oops, already\
    \ there so delete reader and return\n+                    // Oops, already there\
    \ so delete reader and entity and\n+                    // return.\n+        \
    \            //\n                     delete reader;\n+\n+                   \
    \ if (adoptEntity)\n+                        delete entity;\n+\n             \
    \        return false;\n                 }\n             }\n@@ -905,52 +970,37\
    \ @@ bool ReaderMgr::pushReader(         XMLReader* const        reader\n    \
    \ //  tell it it does own its elements.\n     //\n     if (!fReaderStack)\n- \
    \       fReaderStack = new (fMemoryManager) RefStackOf<XMLReader>(16, true, fMemoryManager);\n\
    -\n-    // And the entity stack, which does not own its elements\n-    if (!fEntityStack)\n\
    -        fEntityStack = new (fMemoryManager) RefStackOf<XMLEntityDecl>(16, false,\
    \ fMemoryManager);\n+        fReaderStack = new (fMemoryManager) RefStackOf<ReaderData>(16,\
    \ true, fMemoryManager);\n \n     //\n-    //  Push the current reader and entity\
    \ onto their respective stacks.\n-    //  Note that the the current entity can\
    \ be null if the current reader\n-    //  is not for an entity.\n+    //  Push\
    \ the current reader and entity onto the stack. Note that\n+    //  the current\
    \ entity can be null if the current reader is not for\n+    //  an entity.\n \
    \    //\n-    if (fCurReader)\n-    {\n-        fReaderStack->push(fCurReader);\n\
    -        fEntityStack->push(fCurEntity);\n-    }\n+    if (fCurReaderData)\n+\
    \        fReaderStack->push(fCurReaderData);\n \n     //\n     //  Make the passed\
    \ reader and entity the current top of stack. The\n     //  passed entity can\
    \ (and often is) null.\n     //\n+    fCurReaderData = new (fMemoryManager) ReaderData(reader,\
    \ entity, adoptEntity);\n     fCurReader = reader;\n-    fCurEntity = entity;\n\
    \ \n     return true;\n }\n \n-\n void ReaderMgr::reset()\n {\n     // Reset all\
    \ of the flags\n     fThrowEOE = false;\n \n     // Delete the current reader\
    \ and flush the reader stack\n-    delete fCurReader;\n+    delete fCurReaderData;\n\
    +    fCurReaderData = 0;\n     fCurReader = 0;\n     if (fReaderStack)\n     \
    \    fReaderStack->removeAllElements();\n-\n-    //\n-    //  And do the same\
    \ for the entity stack, but don't delete the current\n-    //  entity (if any)\
    \ since we don't own them.\n-    //\n-    fCurEntity = 0;\n-    if (fEntityStack)\n\
    -        fEntityStack->removeAllElements();\n }\n \n \n@@ -1014,7 +1064,9 @@ ReaderMgr::getLastExtEntity(const\
    \ XMLEntityDecl*& itsEntity) const\n     //  search the stack; else, keep the\
    \ reader that we've got since its\n     //  either an external entity reader or\
    \ the main file reader.\n     //\n-    const XMLEntityDecl* curEntity = fCurEntity;\n\
    +    const XMLEntityDecl* curEntity =\n+        fCurReaderData? fCurReaderData->getEntity()\
    \ : 0;\n+\n     if (curEntity && !curEntity->isExternal())\n     {\n         XMLSize_t\
    \ index = fReaderStack->size();\n@@ -1024,20 +1076,20 @@ ReaderMgr::getLastExtEntity(const\
    \ XMLEntityDecl*& itsEntity) const\n             {\n                 // Move down\
    \ to the previous element and get a pointer to it\n                 index--;\n\
    -                curEntity = fEntityStack->elementAt(index);\n+              \
    \  curEntity = fReaderStack->elementAt(index)->getEntity();\n \n             \
    \    //\n                 //  If its null or its an external entity, then this\
    \ reader\n                 //  is what we want, so break out with that one.\n\
    \                 //\n                 if (!curEntity)\n                 {\n-\
    \                    theReader = fReaderStack->elementAt(index);\n+          \
    \          theReader = fReaderStack->elementAt(index)->getReader ();\n       \
    \              break;\n                 }\n                  else if (curEntity->isExternal())\n\
    \                 {\n-                    theReader = fReaderStack->elementAt(index);\n\
    +                    theReader = fReaderStack->elementAt(index)->getReader ();\n\
    \                     break;\n                 }\n \n@@ -1048,6 +1100,11 @@ ReaderMgr::getLastExtEntity(const\
    \ XMLEntityDecl*& itsEntity) const\n         }\n     }\n \n+    // @@ It feels\
    \ like we may end up with theReader being from the top of\n+    //    the stack\
    \ (fCurReader) and itsEntity being from the bottom of the\n+    //    stack (if\
    \ there are no null or external entities on the stack).\n+    //    Is it a bug?\n\
    +    //\n     itsEntity = curEntity;\n     return theReader;\n }\n@@ -1059,31\
    \ +1116,59 @@ bool ReaderMgr::popReader()\n     //  We didn't get any more, so\
    \ try to pop off a reader. If the reader\n     //  stack is empty, then we are\
    \ at the end, so return false.\n     //\n+    //  @@ It feels like we never pop\
    \ the reader pushed to the stack first\n+    //     (think of fReaderStack empty\
    \ but fCurReader not null). Is it a\n+    //     bug?\n+    //\n     if (fReaderStack->empty())\n\
    \         return false;\n \n     //\n-    //  Remember the current entity, before\
    \ we pop off a new one. We might\n+    //  Remember the current reader, before\
    \ we pop off a new one. We might\n     //  need this to throw the end of entity\
    \ exception at the end.\n     //\n-    XMLEntityDecl* prevEntity = fCurEntity;\n\
    +    ReaderData* prevReaderData = fCurReaderData;\n     const bool prevReaderThrowAtEnd\
    \ = fCurReader->getThrowAtEnd();\n     const XMLSize_t readerNum = fCurReader->getReaderNum();\n\
    \ \n     //\n-    //  Delete the current reader and pop a new reader and entity\
    \ off\n-    //  the stacks.\n+    //  Pop a new reader and entity off the stack.\n\
    \     //\n-    delete fCurReader;\n-    fCurReader = fReaderStack->pop();\n- \
    \   fCurEntity = fEntityStack->pop();\n+    fCurReaderData = fReaderStack->pop();\n\
    +    fCurReader = fCurReaderData->getReader();\n \n     //\n     //  If there\
    \ was a previous entity, and either the fThrowEOE flag is set\n-    //  or reader\
    \ was marked as such, then throw an end of entity.\n+    //  or reader was marked\
    \ as such, then throw an end of entity. Otherwise,\n+    //  delete the previous\
    \ reader data.\n     //\n-    if (prevEntity && (fThrowEOE || prevReaderThrowAtEnd))\n\
    -        throw EndOfEntityException(prevEntity, readerNum);\n+    if (prevReaderData->getEntity()\
    \ && (fThrowEOE || prevReaderThrowAtEnd))\n+    {\n+        //\n+        // If\
    \ the entity is adopted, then move it to fEntityStack so that\n+        // its\
    \ life-time is prolonged to the life-time of this reader\n+        // manager.\
    \ Also delete the previous reader data before throwing\n+        // EndOfEntityException.\n\
    +        //\n+        XMLEntityDecl* entity;\n+\n+        if (prevReaderData->getEntityAdopted())\n\
    +        {\n+            if (!fEntityStack)\n+                fEntityStack = new\
    \ (fMemoryManager) RefStackOf<XMLEntityDecl>(16, true, fMemoryManager);\n+\n+\
    \            entity = prevReaderData->releaseEntity();\n+            fEntityStack->push(entity);\n\
    +        }\n+        else\n+            entity = prevReaderData->getEntity();\n\
    +\n+        delete prevReaderData;\n+\n+        throw EndOfEntityException(entity,\
    \ readerNum);\n+    }\n+    else\n+        delete prevReaderData;\n \n     while\
    \ (true)\n     {\n@@ -1113,9 +1198,9 @@ bool ReaderMgr::popReader()\n        \
    \     return false;\n \n         // Else pop again and try it one more time\n\
    -        delete fCurReader;\n-        fCurReader = fReaderStack->pop();\n-   \
    \     fCurEntity = fEntityStack->pop();\n+        delete fCurReaderData;\n+  \
    \      fCurReaderData = fReaderStack->pop();\n+        fCurReader = fCurReaderData->getReader();\n\
    \     }\n     return true;\n }"
  identifiers: CVE:["CVE-2024-23807"],CWE:["CWE-94"]
  overview: 'Affected versions of this package are vulnerable to Code Injection due
    to incorrect handling of certain XML files. An attacker can achieve remote code
    execution by crafting malicious XML files that exploit the vulnerability. '
  references:
    Apache Jira Issues: https://issues.apache.org/jira/browse/XERCESC-2188
    CVE-2018-1311: https://security.snyk.io/vuln/SNYK-UNMANAGED-XERCESC-2384842
    GitHub Commit: https://github.com/apache/xerces-c/commit/e0024267504188e42ace4dd9031d936786914835
    OSS Security Advisory: https://www.openwall.com/lists/oss-security/2024/02/16/1
  title: Code Injection
- diff_content:
  - "--- a/src/gui/util/qktxhandler.cpp\n+++ b/src/gui/util/qktxhandler.cpp\n@@ -41,7\
    \ +41,7 @@ struct KTXHeader {\n     quint32 bytesOfKeyValueData;\n };\n \n-static\
    \ const quint32 qktxh_headerSize = sizeof(KTXHeader);\n+static constexpr quint32\
    \ qktxh_headerSize = sizeof(KTXHeader);\n \n // Currently unused, declared for\
    \ future reference\n struct KTXKeyValuePairItem {\n@@ -71,20 +71,32 @@ struct\
    \ KTXMipmapLevel {\n     */\n };\n \n-// Returns the nearest multiple of 'rounding'\
    \ greater than or equal to 'value'\n-constexpr quint32 withPadding(quint32 value,\
    \ quint32 rounding)\n+// Returns the nearest multiple of 4 greater than or equal\
    \ to 'value'\n+static const std::optional<quint32> nearestMultipleOf4(quint32\
    \ value)\n {\n-    Q_ASSERT(rounding > 1);\n-    return value + (rounding - 1)\
    \ - ((value + (rounding - 1)) % rounding);\n+    constexpr quint32 rounding =\
    \ 4;\n+    quint32 result = 0;\n+    if (qAddOverflow(value, rounding - 1, &result))\n\
    +        return std::nullopt;\n+    result &= ~(rounding - 1);\n+    return result;\n\
    +}\n+\n+// Returns a view with prechecked bounds\n+static QByteArrayView safeView(QByteArrayView\
    \ view, quint32 start, quint32 length)\n+{\n+    quint32 end = 0;\n+    if (qAddOverflow(start,\
    \ length, &end) || end > quint32(view.length()))\n+        return {};\n+    return\
    \ view.sliced(start, length);\n }\n \n QKtxHandler::~QKtxHandler() = default;\n\
    \ \n bool QKtxHandler::canRead(const QByteArray &suffix, const QByteArray &block)\n\
    \ {\n     Q_UNUSED(suffix);\n-\n-    return (qstrncmp(block.constData(), ktxIdentifier,\
    \ KTX_IDENTIFIER_LENGTH) == 0);\n+    return block.startsWith(ktxIdentifier);\n\
    \ }\n \n QTextureFileData QKtxHandler::read()\n@@ -93,55 +105,122 @@ QTextureFileData\
    \ QKtxHandler::read()\n         return QTextureFileData();\n \n     const QByteArray\
    \ buf = device()->readAll();\n-    const quint32 dataSize = quint32(buf.size());\n\
    -    if (dataSize < qktxh_headerSize || !canRead(QByteArray(), buf)) {\n-    \
    \    qCDebug(lcQtGuiTextureIO, \"Invalid KTX file %s\", logName().constData());\n\
    +    if (buf.size() > std::numeric_limits<quint32>::max()) {\n+        qWarning(lcQtGuiTextureIO,\
    \ \"Too big KTX file %s\", logName().constData());\n+        return QTextureFileData();\n\
    +    }\n+\n+    if (!canRead(QByteArray(), buf)) {\n+        qWarning(lcQtGuiTextureIO,\
    \ \"Invalid KTX file %s\", logName().constData());\n         return QTextureFileData();\n\
    \     }\n \n-    const KTXHeader *header = reinterpret_cast<const KTXHeader *>(buf.data());\n\
    -    if (!checkHeader(*header)) {\n-        qCDebug(lcQtGuiTextureIO, \"Unsupported\
    \ KTX file format in %s\", logName().constData());\n+    if (buf.size() < qsizetype(qktxh_headerSize))\
    \ {\n+        qWarning(lcQtGuiTextureIO, \"Invalid KTX header size in %s\", logName().constData());\n\
    +        return QTextureFileData();\n+    }\n+\n+    KTXHeader header;\n+    memcpy(&header,\
    \ buf.data(), qktxh_headerSize);\n+    if (!checkHeader(header)) {\n+        qWarning(lcQtGuiTextureIO,\
    \ \"Unsupported KTX file format in %s\", logName().constData());\n         return\
    \ QTextureFileData();\n     }\n \n     QTextureFileData texData;\n     texData.setData(buf);\n\
    \ \n-    texData.setSize(QSize(decode(header->pixelWidth), decode(header->pixelHeight)));\n\
    -    texData.setGLFormat(decode(header->glFormat));\n-    texData.setGLInternalFormat(decode(header->glInternalFormat));\n\
    -    texData.setGLBaseInternalFormat(decode(header->glBaseInternalFormat));\n\
    +    texData.setSize(QSize(decode(header.pixelWidth), decode(header.pixelHeight)));\n\
    +    texData.setGLFormat(decode(header.glFormat));\n+    texData.setGLInternalFormat(decode(header.glInternalFormat));\n\
    +    texData.setGLBaseInternalFormat(decode(header.glBaseInternalFormat));\n \n\
    -    texData.setNumLevels(decode(header->numberOfMipmapLevels));\n-    texData.setNumFaces(decode(header->numberOfFaces));\n\
    +    texData.setNumLevels(decode(header.numberOfMipmapLevels));\n+    texData.setNumFaces(decode(header.numberOfFaces));\n\
    +\n+    const quint32 bytesOfKeyValueData = decode(header.bytesOfKeyValueData);\n\
    +    quint32 headerKeyValueSize;\n+    if (qAddOverflow(qktxh_headerSize, bytesOfKeyValueData,\
    \ &headerKeyValueSize)) {\n+        qWarning(lcQtGuiTextureIO, \"Overflow in size\
    \ of key value data in header of KTX file %s\",\n+                 logName().constData());\n\
    +        return QTextureFileData();\n+    }\n \n-    const quint32 bytesOfKeyValueData\
    \ = decode(header->bytesOfKeyValueData);\n-    if (qktxh_headerSize + bytesOfKeyValueData\
    \ < quint64(buf.size())) // oob check\n-        texData.setKeyValueMetadata(decodeKeyValues(\n\
    -                QByteArrayView(buf.data() + qktxh_headerSize, bytesOfKeyValueData)));\n\
    -    quint32 offset = qktxh_headerSize + bytesOfKeyValueData;\n+    if (headerKeyValueSize\
    \ >= quint32(buf.size())) {\n+        qWarning(lcQtGuiTextureIO, \"OOB request\
    \ in KTX file %s\", logName().constData());\n+        return QTextureFileData();\n\
    +    }\n+\n+    // File contains key/values\n+    if (bytesOfKeyValueData > 0)\
    \ {\n+        auto keyValueDataView = safeView(buf, qktxh_headerSize, bytesOfKeyValueData);\n\
    +        if (keyValueDataView.isEmpty()) {\n+            qWarning(lcQtGuiTextureIO,\
    \ \"Invalid view in KTX file %s\", logName().constData());\n+            return\
    \ QTextureFileData();\n+        }\n+\n+        auto keyValues = decodeKeyValues(keyValueDataView);\n\
    +        if (!keyValues) {\n+            qWarning(lcQtGuiTextureIO, \"Could not\
    \ parse key values in KTX file %s\",\n+                     logName().constData());\n\
    +            return QTextureFileData();\n+        }\n+\n+        texData.setKeyValueMetadata(*keyValues);\n\
    +    }\n+\n+    // Technically, any number of levels is allowed but if the value\
    \ is bigger than\n+    // what is possible in KTX V2 (and what makes sense) we\
    \ return an error.\n+    // maxLevels = log2(max(width, height, depth))\n+   \
    \ const int maxLevels = (sizeof(quint32) * 8)\n+            - qCountLeadingZeroBits(std::max(\n\
    +                    { header.pixelWidth, header.pixelHeight, header.pixelDepth\
    \ }));\n+\n+    if (texData.numLevels() > maxLevels) {\n+        qWarning(lcQtGuiTextureIO,\
    \ \"Too many levels in KTX file %s\", logName().constData());\n+        return\
    \ QTextureFileData();\n+    }\n \n-    constexpr int MAX_ITERATIONS = 32; // cap\
    \ iterations in case of corrupt data\n+    if (texData.numFaces() != 1 && texData.numFaces()\
    \ != 6) {\n+        qWarning(lcQtGuiTextureIO, \"Invalid number of faces in KTX\
    \ file %s\", logName().constData());\n+        return QTextureFileData();\n+ \
    \   }\n \n-    for (int level = 0; level < qMin(texData.numLevels(), MAX_ITERATIONS);\
    \ level++) {\n-        if (offset + sizeof(quint32) > dataSize) // Corrupt file;\
    \ avoid oob read\n-            break;\n+    quint32 offset = headerKeyValueSize;\n\
    +    for (int level = 0; level < texData.numLevels(); level++) {\n+        const\
    \ auto imageSizeView = safeView(buf, offset, sizeof(quint32));\n+        if (imageSizeView.isEmpty())\
    \ {\n+            qWarning(lcQtGuiTextureIO, \"OOB request in KTX file %s\", logName().constData());\n\
    +            return QTextureFileData();\n+        }\n \n-        const quint32\
    \ imageSize = decode(qFromUnaligned<quint32>(buf.data() + offset));\n-       \
    \ offset += sizeof(quint32);\n+        const quint32 imageSize = decode(qFromUnaligned<quint32>(imageSizeView.data()));\n\
    +        offset += sizeof(quint32); // overflow checked indirectly above\n \n\
    -        for (int face = 0; face < qMin(texData.numFaces(), MAX_ITERATIONS); face++)\
    \ {\n+        for (int face = 0; face < texData.numFaces(); face++) {\n      \
    \       texData.setDataOffset(offset, level, face);\n             texData.setDataLength(imageSize,\
    \ level, face);\n \n             // Add image data and padding to offset\n-  \
    \          offset += withPadding(imageSize, 4);\n+            const auto padded\
    \ = nearestMultipleOf4(imageSize);\n+            if (!padded) {\n+           \
    \     qWarning(lcQtGuiTextureIO, \"Overflow in KTX file %s\", logName().constData());\n\
    +                return QTextureFileData();\n+            }\n+\n+            quint32\
    \ offsetNext;\n+            if (qAddOverflow(offset, *padded, &offsetNext)) {\n\
    +                qWarning(lcQtGuiTextureIO, \"OOB request in KTX file %s\", logName().constData());\n\
    +                return QTextureFileData();\n+            }\n+\n+            offset\
    \ = offsetNext;\n         }\n     }\n \n     if (!texData.isValid()) {\n-    \
    \    qCDebug(lcQtGuiTextureIO, \"Invalid values in header of KTX file %s\", logName().constData());\n\
    +        qWarning(lcQtGuiTextureIO, \"Invalid values in header of KTX file %s\"\
    ,\n+                 logName().constData());\n         return QTextureFileData();\n\
    \     }\n \n@@ -187,33 +266,83 @@ bool QKtxHandler::checkHeader(const KTXHeader\
    \ &header)\n     return is2D && (isCubeMap || isCompressedImage);\n }\n \n-QMap<QByteArray,\
    \ QByteArray> QKtxHandler::decodeKeyValues(QByteArrayView view) const\n+std::optional<QMap<QByteArray,\
    \ QByteArray>> QKtxHandler::decodeKeyValues(QByteArrayView view) const\n {\n \
    \    QMap<QByteArray, QByteArray> output;\n     quint32 offset = 0;\n-    while\
    \ (offset < view.size() + sizeof(quint32)) {\n+    while (offset < quint32(view.size()))\
    \ {\n+        const auto keyAndValueByteSizeView = safeView(view, offset, sizeof(quint32));\n\
    +        if (keyAndValueByteSizeView.isEmpty()) {\n+            qWarning(lcQtGuiTextureIO,\
    \ \"Invalid view in KTX key-value\");\n+            return std::nullopt;\n+  \
    \      }\n+\n         const quint32 keyAndValueByteSize =\n-                decode(qFromUnaligned<quint32>(view.constData()\
    \ + offset));\n-        offset += sizeof(quint32);\n+                decode(qFromUnaligned<quint32>(keyAndValueByteSizeView.data()));\n\
    \ \n-        if (offset + keyAndValueByteSize > quint64(view.size()))\n-     \
    \       break; // oob read\n+        quint32 offsetKeyAndValueStart;\n+      \
    \  if (qAddOverflow(offset, quint32(sizeof(quint32)), &offsetKeyAndValueStart))\
    \ {\n+            qWarning(lcQtGuiTextureIO, \"Overflow in KTX key-value\");\n\
    +            return std::nullopt;\n+        }\n+\n+        quint32 offsetKeyAndValueEnd;\n\
    +        if (qAddOverflow(offsetKeyAndValueStart, keyAndValueByteSize, &offsetKeyAndValueEnd))\
    \ {\n+            qWarning(lcQtGuiTextureIO, \"Overflow in KTX key-value\");\n\
    +            return std::nullopt;\n+        }\n+\n+        const auto keyValueView\
    \ = safeView(view, offsetKeyAndValueStart, keyAndValueByteSize);\n+        if\
    \ (keyValueView.isEmpty()) {\n+            qWarning(lcQtGuiTextureIO, \"Invalid\
    \ view in KTX key-value\");\n+            return std::nullopt;\n+        }\n \n\
    \         // 'key' is a UTF-8 string ending with a null terminator, 'value' is\
    \ the rest.\n         // To separate the key and value we convert the complete\
    \ data to utf-8 and find the first\n         // null terminator from the left,\
    \ here we split the data into two.\n-        const auto str = QString::fromUtf8(view.constData()\
    \ + offset, keyAndValueByteSize);\n-        const int idx = str.indexOf('\\0'_L1);\n\
    -        if (idx == -1)\n-            continue;\n-\n-        const QByteArray\
    \ key = str.left(idx).toUtf8();\n-        const size_t keySize = key.size() +\
    \ 1; // Actual data size\n-        const QByteArray value = QByteArray::fromRawData(view.constData()\
    \ + offset + keySize,\n-                                                     \
    \    keyAndValueByteSize - keySize);\n-\n-        offset = withPadding(offset\
    \ + keyAndValueByteSize, 4);\n-        output.insert(key, value);\n+\n+      \
    \  const int idx = keyValueView.indexOf('\\0');\n+        if (idx == -1) {\n+\
    \            qWarning(lcQtGuiTextureIO, \"Invalid key in KTX key-value\");\n+\
    \            return std::nullopt;\n+        }\n+\n+        const QByteArrayView\
    \ keyView = safeView(view, offsetKeyAndValueStart, idx);\n+        if (keyView.isEmpty())\
    \ {\n+            qWarning(lcQtGuiTextureIO, \"Overflow in KTX key-value\");\n\
    +            return std::nullopt;\n+        }\n+\n+        const quint32 keySize\
    \ = idx + 1; // Actual data size\n+\n+        quint32 offsetValueStart;\n+   \
    \     if (qAddOverflow(offsetKeyAndValueStart, keySize, &offsetValueStart)) {\n\
    +            qWarning(lcQtGuiTextureIO, \"Overflow in KTX key-value\");\n+   \
    \         return std::nullopt;\n+        }\n+\n+        quint32 valueSize;\n+\
    \        if (qSubOverflow(keyAndValueByteSize, keySize, &valueSize)) {\n+    \
    \        qWarning(lcQtGuiTextureIO, \"Underflow in KTX key-value\");\n+      \
    \      return std::nullopt;\n+        }\n+\n+        const QByteArrayView valueView\
    \ = safeView(view, offsetValueStart, valueSize);\n+        if (valueView.isEmpty())\
    \ {\n+            qWarning(lcQtGuiTextureIO, \"Invalid view in KTX key-value\"\
    );\n+            return std::nullopt;\n+        }\n+\n+        output.insert(keyView.toByteArray(),\
    \ valueView.toByteArray());\n+\n+        const auto offsetNext = nearestMultipleOf4(offsetKeyAndValueEnd);\n\
    +        if (!offsetNext) {\n+            qWarning(lcQtGuiTextureIO, \"Overflow\
    \ in KTX key-value\");\n+            return std::nullopt;\n+        }\n+\n+  \
    \      offset = *offsetNext;\n     }\n \n     return output;"
  - "--- a/tests/auto/gui/util/qtexturefilereader/tst_qtexturefilereader.cpp\n+++\
    \ b/tests/auto/gui/util/qtexturefilereader/tst_qtexturefilereader.cpp\n@@ -11,6\
    \ +11,7 @@ class tst_qtexturefilereader : public QObject\n private slots:\n  \
    \   void checkHandlers_data();\n     void checkHandlers();\n+    void checkInvalid();\n\
    \     void checkMetadata();\n };\n \n@@ -140,6 +141,18 @@ void tst_qtexturefilereader::checkMetadata()\n\
    \     QCOMPARE(kvs.value(\"test C\"), QByteArrayLiteral(\"3\\x0000\"));\n }\n\
    \ \n+void tst_qtexturefilereader::checkInvalid()\n+{\n+    QFile f(\":/texturefiles/invalid.ktx\"\
    );\n+    QVERIFY(f.open(QIODevice::ReadOnly));\n+    QTextureFileReader r(&f);\n\
    +    QTextureFileData d = r.read();\n+    auto kvs = d.keyValueMetadata();\n+\n\
    +    // Basically just checking that we don't crash on and invalid file\n+   \
    \ QVERIFY(kvs.empty());\n+}\n+\n QTEST_MAIN(tst_qtexturefilereader)\n \n #include\
    \ \"tst_qtexturefilereader.moc\""
  identifiers: CVE:["CVE-2024-25580"],CWE:["CWE-121"]
  overview: Affected versions of this package are vulnerable to Stack-based Buffer
    Overflow due to a GUI flaw in the `qktxhandler.cpp` file. An attacker can trigger
    a denial of service.
  references:
    GitHub Commit: https://github.com/qt/qtbase/commit/dec1863c7dc63e5788b0c6c061d36e856a6ae2b2
  title: Stack-based Buffer Overflow
- diff_content:
  - '--- a/app/bluetooth/common/abr_cs_parser/abr_cs_parser.c

    +++ b/app/bluetooth/common/abr_cs_parser/abr_cs_parser.c

    @@ -0,0 +1,1150 @@

    +/***************************************************************************//**

    + * @file

    + * @brief ABR CS Parser component.

    + *

    + *******************************************************************************

    + * # License

    + * <b>Copyright 2023 Silicon Laboratories Inc. www.silabs.com</b>

    + *******************************************************************************

    + *

    + * SPDX-License-Identifier: Zlib

    + *

    + * The licensor of this software is Silicon Laboratories Inc.

    + *

    + * This software is provided ''as-is'', without any express or implied

    + * warranty. In no event will the authors be held liable for any damages

    + * arising from the use of this software.

    + *

    + * Permission is granted to anyone to use this software for any purpose,

    + * including commercial applications, and to alter it and redistribute it

    + * freely, subject to the following restrictions:

    + *

    + * 1. The origin of this software must not be misrepresented; you must not

    + *    claim that you wrote the original software. If you use this software

    + *    in a product, an acknowledgment in the product documentation would be

    + *    appreciated but is not required.

    + * 2. Altered source versions must be plainly marked as such, and must not be

    + *    misrepresented as being the original software.

    + * 3. This notice may not be removed or altered from any source distribution.

    + *

    + ******************************************************************************/

    +#include <stdlib.h>

    +#include <unistd.h>

    +#include "sl_status.h"

    +#include "app_log.h"

    +#include "abr_cs_parser.h"

    +#include "abr_cs_parser_config.h"

    +#include "abr_file_log.h"

    +

    +// -----------------------------------------------------------------------------

    +// Definitions

    +

    +#define MAX_NUM_CHANNELS      80                // Maximum CS channel number

    +#define CS_MODE_CALIBRATION   0                 // Calibration CS mode

    +#define CS_MODE_RTT           sl_bt_cs_mode_rtt   // RTT CS mode

    +#define CS_MODE_RTP           sl_bt_cs_mode_pbr   // RTP CS mode

    +#define CS_MODE_COMBINED      sl_bt_cs_mode_pbr_and_rtt   // Combined CS mode

    +#define RTT_VALUE_LEN         6                 // RTT data field length

    +#define LL_INVALID_TOA        0x800             // Invalid time value from LL

    +#define PCT_DATA_MASK_LOW     0x00000FFF        // Tone PCT mask low

    +#define PCT_DATA_MASK_HIGH    0x00FFF000        // Tone PCT mask high

    +#define PCT_IQ_LEN            12                // PCT IQ sample length

    +#define PCT_BYTE_COUNT        3                 // Tone PCT byte count in data
    field

    +#define CS_PROCEDURE_ABORTED  0x0F              // All subsequent CS procedures
    aborted

    +#define CS_SUBEVENT_ABORTED   0x0F              // Current CS subevent aborted

    +#define BYTE_LEN              8                 // Byte length in bits

    +#define INVALID_TIME_VALUE    0x80000000        // Invalid RTL library time value

    +#define INVALID_RSSI_VALUE    0x80000000        // Invalid RTL library RSSI value

    +#define TONE_PCT_INVALID      ((uint32_t)0xFFFFFF)      // Invalid tone PCT value

    +#define MIN(a, b)             (((a) < (b)) ? (a) : (b)) // Minimum calculation

    +#define DEFAULT_FREQUENCY_DELTA 2e6f                    // Channel frequency
    delta

    +

    +/// Check status code, log warning and return

    +#define CHECK_STATUS_RETURN(sc, ...) \

    +  do {                               \

    +    if ((sc) != SL_STATUS_OK) {      \

    +      app_log_warning(__VA_ARGS__);  \

    +      return (sc);                   \

    +    }                                \

    +  } while (0)

    +

    +// -----------------------------------------------------------------------------

    +// Enums, structs, typedefs

    +

    +/// RTT measurement related data

    +typedef struct {

    +  sl_rtl_abr_rtt_data   rtl_input;                        ///< RTT data for RTL
    library

    +  uint8_t               initiator_idx;                    ///< Initiator data
    index

    +  uint8_t               reflector_idx;                    ///< Reflector data
    index

    +  int32_t               rssi_initiator[MAX_NUM_CHANNELS]; ///< Initiator RSSI
    measurements

    +  int32_t               rssi_reflector[MAX_NUM_CHANNELS]; ///< Reflector RSSI
    measurements

    +  int32_t               time_initiator[MAX_NUM_CHANNELS]; ///< Initiator time
    measurements

    +  int32_t               time_reflector[MAX_NUM_CHANNELS]; ///< Reflector time
    measurements

    +} rtt_measurement_t;

    +

    +/// RTP measurement related data

    +typedef struct {

    +  sl_rtl_abr_rtp_data rtl_input;                ///< RTP data for RTL library

    +  float initiator_i_samples[MAX_NUM_CHANNELS];  ///< IQ-data I-components from
    initiator

    +  float initiator_q_samples[MAX_NUM_CHANNELS];  ///< IQ-data Q-components from
    initiator

    +  float reflector_i_samples[MAX_NUM_CHANNELS];  ///< IQ-data I-components from
    reflector

    +  float reflector_q_samples[MAX_NUM_CHANNELS];  ///< IQ-data Q-components from
    reflector

    +} rtp_measurement_t;

    +

    +/// CS measurement data

    +typedef struct {

    +  uint8_t                 connection;               ///< Connection handle

    +  bool                    restart_needed;           ///< CS measurement restart
    needed

    +  bool                    initiator_ready;          ///< Initiator ready flag

    +  bool                    reflector_ready;          ///< Reflector ready flag

    +  bool                    ready_to_process;         ///< CS measurement data
    is ready to processed

    +  uint32_t                initiator_procedure_cnt;  ///< Initiator procedure
    count

    +  uint32_t                reflector_procedure_cnt;  ///< Reflector procedure
    count

    +  cs_step_t               step_data;                ///< Step data container

    +  rtt_measurement_t       rtt_data;                 ///< RTT measurement data

    +  rtp_measurement_t       rtp_data;                 ///< RTP measurement data

    +  reflector_calibration_t reflector_calib;          ///< Reflector calibration
    data

    +  initiator_calibration_t initiator_calib;          ///< Initiator claibration
    data

    +} cs_measurement_t;

    +

    +/// CS parser structure

    +typedef struct {

    +  uint32_t                      channels_number;                      ///< Number
    of channels

    +  uint32_t                      num_tones;                            ///< Number
    of tones (frequencies)

    +  uint32_t                      blank_tone_channels[MAX_NUM_CHANNELS];///< Blank
    tone channels

    +  uint32_t                      num_blank_tone_indices;               ///< Number
    of blank tones

    +  uint8_t                       mode_0_steps;                         ///< Number
    of mode 0 steps included

    +  cs_measurement_t              measurements[NUM_OF_REFLECTORS];      ///< CS
    measurements

    +  uint8_t                       initialized;                          ///< Parser
    initialized flag

    +  abr_cs_parser_configuration_t config;                               ///< CS
    parser configuration

    +} abr_cs_parser_t;

    +

    +// -----------------------------------------------------------------------------

    +// Forward declaration of private functions

    +static sl_status_t set_channel_map(const uint8_t *channel_map,

    +                                   const uint32_t channel_map_len);

    +static sl_status_t parse_event_result_data(sl_bt_evt_cs_result_t *cs_res,

    +                                           abr_role_t             role);

    +static sl_status_t parse_steps(sl_bt_evt_cs_result_t *cs_res,

    +                               abr_role_t             role,

    +                               cs_measurement_t      *meas);

    +static sl_status_t parse_one_step(uint8_t   *data,

    +                                  uint32_t   data_size,

    +                                  abr_role_t role,

    +                                  uint32_t  *read_cnt,

    +                                  cs_step_t *out);

    +static sl_status_t read_byte(const uint8_t *data,

    +                             uint32_t data_size,

    +                             uint32_t *read_cnt,

    +                             uint8_t *out);

    +static sl_status_t check_cs_event_flags(sl_bt_evt_cs_result_t *cs_res,

    +                                        cs_measurement_t *meas);

    +static void update_measurement_flags(cs_measurement_t *meas,

    +                                     abr_role_t role);

    +static void check_measurement_completed(cs_measurement_t *meas);

    +static sl_status_t parse_calibration_initiator(const uint8_t* data,

    +                                               uint32_t       data_size,

    +                                               uint32_t      *read_cnt,

    +                                               cs_step_t     *out);

    +static sl_status_t parse_calibration_reflector(const uint8_t* data,

    +                                               uint32_t       data_size,

    +                                               uint32_t      *read_cnt,

    +                                               cs_step_t     *out);

    +static sl_status_t parse_rtt_step(const uint8_t *data,

    +                                  uint32_t       data_size,

    +                                  uint32_t      *read_cnt,

    +                                  cs_step_t     *step_data);

    +static int16_t tone_pct_to_int(uint32_t tone_pct);

    +static sl_status_t parse_rtp_step(const uint8_t *data,

    +                                  uint32_t       data_size,

    +                                  uint32_t      *read_cnt,

    +                                  cs_step_t     *step_data);

    +static sl_status_t get_measurement_index_from_connection(uint8_t connection,

    +                                                         uint8_t *index);

    +static sl_status_t get_measurement_from_connection(cs_measurement_t **meas,

    +                                                   uint8_t            conn);

    +static void clear_measurement_buffers(void);

    +static void clear_measurement_buffer(cs_measurement_t *meas);

    +static void set_restart_needed(cs_measurement_t *meas, bool needed);

    +static sl_status_t add_rtt_data_to_measurement(rtt_measurement_t *meas,

    +                                               cs_step_t         *step_data,

    +                                               abr_role_t         role);

    +static sl_status_t add_rtp_data_to_measurement(rtp_measurement_t *meas,

    +                                               cs_step_t         *step_data,

    +                                               abr_role_t         role);

    +static sl_status_t add_calibration_data_to_measurement(cs_measurement_t  *meas,

    +                                                       cs_step_t         *step_data,

    +                                                       abr_role_t         role);

    +

    +// -----------------------------------------------------------------------------

    +// Private variables

    +

    +/// CS parser state

    +static abr_cs_parser_t cs_parser;

    +

    +// -----------------------------------------------------------------------------

    +// Public functions

    +

    +sl_status_t abr_cs_parser_init(abr_cs_parser_configuration_t *config)

    +{

    +  sl_status_t ret = SL_STATUS_NULL_POINTER;

    +  sl_status_t ret_log = SL_STATUS_OK;

    +

    +  if (config != NULL) {

    +    cs_parser.channels_number = MAX_NUM_CHANNELS;

    +    cs_parser.mode_0_steps = 1;

    +    cs_parser.config = *config;

    +    for (uint8_t i = 0; i < NUM_OF_REFLECTORS; i++) {

    +      cs_parser.measurements[i].connection = SL_BT_INVALID_CONNECTION_HANDLE;

    +    }

    +    clear_measurement_buffers();

    +    cs_parser.initialized = 1;

    +    ret = SL_STATUS_OK;

    +  }

    +  ret_log = abr_file_log_init(config->measurement_mode);

    +  if (ret_log != SL_STATUS_OK) {

    +    app_log_error("abr_file_log is not functional! No valid logs will be produced!
    (code: 0x%x)" APP_LOG_NL, ret_log);

    +  }

    +  return ret;

    +}

    +

    +sl_status_t abr_cs_parser_configure(const uint8_t  *ch_data,

    +                                    uint32_t        ch_data_len,

    +                                    uint8_t         mode0_step_count)

    +{

    +  sl_status_t ret, ret_log = SL_STATUS_OK;

    +  ret = set_channel_map(ch_data, ch_data_len);

    +

    +  if (ret == SL_STATUS_OK) {

    +    cs_parser.mode_0_steps = mode0_step_count;

    +    ret_log = abr_file_log_append_header_section(ch_data,

    +                                                 ch_data_len,

    +                                                 cs_parser.mode_0_steps);

    +    if (ret_log != SL_STATUS_OK) {

    +      app_log_error("abr_file_log is not functional! No valid logs will be produced!
    (code: 0x%x)" APP_LOG_NL, ret_log);

    +    }

    +  } else {

    +    app_log_warning("Failed to set channel map!" APP_LOG_NL);

    +  }

    +  return ret;

    +}

    +

    +sl_status_t abr_cs_parser_parse_event_result_data(sl_bt_evt_cs_result_t *cs_res,

    +                                                  abr_role_t             role)

    +{

    +  sl_status_t ret = SL_STATUS_NULL_POINTER;

    +  if (cs_res != NULL) {

    +    if (cs_parser.initialized) {

    +      ret = parse_event_result_data(cs_res, role);

    +    } else {

    +      ret = SL_STATUS_NOT_INITIALIZED;

    +    }

    +  }

    +  return ret;

    +}

    +

    +bool abr_cs_parser_procedure_restart_needed(uint8_t connection)

    +{

    +  cs_measurement_t *measurement = NULL;

    +  sl_status_t sc;

    +  bool restart_needed = false;

    +

    +  sc = get_measurement_from_connection(&measurement, connection);

    +  if (sc == SL_STATUS_OK) {

    +    restart_needed = measurement->restart_needed;

    +  } else {

    +    app_log_warning("Invalid connection handle!" APP_LOG_NL);

    +  }

    +  return restart_needed;

    +}

    +

    +sl_status_t abr_cs_parser_deinit(void)

    +{

    +  cs_parser.initialized = 0;

    +  sl_status_t ret = SL_STATUS_OK;

    +  return ret;

    +}

    +

    +sl_status_t

    +abr_cs_parser_get_measurement_data(uint8_t connection,

    +                                   uint8_t mode,

    +                                   abr_cs_parser_meas_data_t *meas_data)

    +{

    +  sl_status_t ret = SL_STATUS_INVALID_PARAMETER;

    +  cs_measurement_t *meas = NULL;

    +

    +  if (meas_data != NULL && connection != SL_BT_INVALID_CONNECTION_HANDLE) {

    +    ret = get_measurement_from_connection(&meas, connection);

    +    CHECK_STATUS_RETURN(ret, "Invalid connection handle!" APP_LOG_NL);

    +

    +    ret = SL_STATUS_NOT_READY;

    +    if (meas->ready_to_process) {

    +      switch (mode) {

    +        case sl_bt_cs_mode_rtt: // Get RTT data

    +          memcpy(&meas_data->rtt_data,

    +                 (void *)&meas->rtt_data.rtl_input,

    +                 sizeof(sl_rtl_abr_rtt_data));

    +          ret = SL_STATUS_OK;

    +          break;

    +        case sl_bt_cs_mode_pbr: // Get RTP data

    +          memcpy(&meas_data->rtp_data,

    +                 (void *)&meas->rtp_data.rtl_input,

    +                 sizeof(sl_rtl_abr_rtp_data));

    +          ret = SL_STATUS_OK;

    +          break;

    +        case sl_bt_cs_mode_pbr_and_rtt:

    +          break;

    +        default:

    +          ret = SL_STATUS_INVALID_PARAMETER;

    +          break;

    +      }

    +      meas_data->initiator_calibration_rssi = (float)meas->initiator_calib.rssi;

    +      meas_data->reflector_calibration_rssi = (float)meas->reflector_calib.rssi;

    +    }

    +  }

    +  return ret;

    +}

    +

    +sl_status_t abr_cs_parser_cleanup_measurement(uint8_t connection)

    +{

    +  sl_status_t ret = SL_STATUS_FAIL;

    +  cs_measurement_t *meas = NULL;

    +  ret = get_measurement_from_connection(&meas, connection);

    +

    +  if (ret == SL_STATUS_OK) {

    +    clear_measurement_buffer(meas);

    +  }

    +  return ret;

    +}

    +

    +void abr_cs_parser_store_distance(float *distance)

    +{

    +  sl_status_t ret_log = SL_STATUS_OK;

    +  app_log_debug("Store distance for logging" APP_LOG_NL);

    +  ret_log = abr_file_log_finalize_measurement_section(distance);

    +  if (ret_log != SL_STATUS_OK) {

    +    app_log_error("abr_file_log is not functional! No valid logs will be produced!
    (code: 0x%x)" APP_LOG_NL, ret_log);

    +  }

    +}

    +

    +// -----------------------------------------------------------------------------

    +// Private functions

    +

    +/***************************************************************************//**

    + * Parse CS result event data.

    + * @param[in] cs_res CS event result struct pointer.

    + * @param[in] role ABR role.

    + *

    + * Parse and collect CS result event data according to ABR role.

    + * @return Status code.

    + ******************************************************************************/

    +static sl_status_t parse_event_result_data(sl_bt_evt_cs_result_t *cs_res,

    +                                           abr_role_t             role)

    +{

    +  sl_status_t ret = SL_STATUS_NULL_POINTER, ret_log = SL_STATUS_OK;

    +  cs_measurement_t *measurement = NULL;

    +

    +  if (cs_res == NULL) {

    +    return ret;

    +  }

    +

    +  ret = get_measurement_from_connection(&measurement, cs_res->connection);

    +  CHECK_STATUS_RETURN(ret, "Invalid connection handle!" APP_LOG_NL);

    +

    +  ret = check_cs_event_flags(cs_res, measurement);

    +  if (ret != SL_STATUS_OK) {

    +    return ret;

    +  }

    +  // Log the event header

    +  ret_log = abr_file_log_append_event_header(role, cs_res);

    +  if (ret_log != SL_STATUS_OK) {

    +    app_log_error("abr_file_log is not functional! No valid logs will be produced!
    (code: 0x%x)" APP_LOG_NL, ret_log);

    +  }

    +

    +  ret = parse_steps(cs_res, role, measurement);

    +  if (ret == SL_STATUS_OK) {

    +    if (cs_res->subevent_done_status == 0) {

    +      update_measurement_flags(measurement, role);

    +    }

    +    check_measurement_completed(measurement);

    +    ret_log = abr_file_log_assign_steps_to_event(role, cs_res->num_steps);

    +    if (ret_log != SL_STATUS_OK) {

    +      app_log_error("abr_file_log is not functional! No valid logs will be produced!
    (code: 0x%x)" APP_LOG_NL, ret_log);

    +    }

    +  } else {

    +    app_log_info("Failed to parse steps, clearing measurement buffers." APP_LOG_NL);

    +    clear_measurement_buffer(measurement);

    +    set_restart_needed(measurement, true);

    +  }

    +

    +  return ret;

    +}

    +

    +/***************************************************************************//**

    + * Parse steps in CS subevent.

    + * @param[in] cs_res CS event result struct pointer.

    + * @param[in] role ABR role.

    + * @param[in,out] meas CS measurement data.

    + *

    + * @return Status code.

    + ******************************************************************************/

    +static sl_status_t parse_steps(sl_bt_evt_cs_result_t *cs_res,

    +                               abr_role_t             role,

    +                               cs_measurement_t      *meas)

    +{

    +  sl_status_t ret = SL_STATUS_NULL_POINTER;

    +  uint32_t read_count = 0;

    +

    +  if (cs_res == NULL || meas == NULL) {

    +    return ret;

    +  }

    +

    +  for (uint8_t step = 0; step < cs_res->num_steps; step++) {

    +    memset(&meas->step_data, 0, sizeof(cs_step_t));

    +    ret = parse_one_step(cs_res->data.data,

    +                         cs_res->data.len,

    +                         role,

    +                         &read_count,

    +                         &meas->step_data);

    +

    +    if (ret == SL_STATUS_OK) {

    +      switch (meas->step_data.type) {

    +        case MEASUREMENT_RTP:

    +          if (role == ABR_DEVICE_INITIATOR) {

    +            if (!meas->initiator_ready) {

    +              ret = add_rtp_data_to_measurement(&meas->rtp_data,

    +                                                &meas->step_data,

    +                                                role);

    +              if (cs_res->procedure_counter != 0) {

    +                meas->initiator_procedure_cnt = cs_res->procedure_counter;

    +              }

    +            }

    +          } else { // Reflector

    +            if (!meas->reflector_ready) {

    +              ret = add_rtp_data_to_measurement(&meas->rtp_data,

    +                                                &meas->step_data,

    +                                                role);

    +              if (cs_res->procedure_counter != 0) {

    +                meas->reflector_procedure_cnt = cs_res->procedure_counter;

    +              }

    +            }

    +          }

    +          break;

    +

    +        case MEASUREMENT_RTT:

    +          if (role == ABR_DEVICE_INITIATOR) {

    +            if (!meas->initiator_ready) {

    +              ret = add_rtt_data_to_measurement(&meas->rtt_data,

    +                                                &meas->step_data,

    +                                                role);

    +              if (cs_res->procedure_counter != 0) {

    +                meas->initiator_procedure_cnt = cs_res->procedure_counter;

    +              }

    +            }

    +          } else { // Reflector

    +            if (!meas->reflector_ready) {

    +              ret = add_rtt_data_to_measurement(&meas->rtt_data,

    +                                                &meas->step_data,

    +                                                role);

    +              if (cs_res->procedure_counter != 0) {

    +                meas->reflector_procedure_cnt = cs_res->procedure_counter;

    +              }

    +            }

    +          }

    +          break;

    +

    +        case CALIBRATION_INITIATOR:

    +          ret = add_calibration_data_to_measurement(meas,

    +                                                    &meas->step_data,

    +                                                    role);

    +          break;

    +

    +        case CALIBRATION_REFLECTOR:

    +          ret = add_calibration_data_to_measurement(meas,

    +                                                    &meas->step_data,

    +                                                    role);

    +          break;

    +

    +        default:

    +          break;

    +      }

    +    } else {

    +      break; // Finish parsing, return with error code

    +    }

    +  } // end for(...)

    +  return ret;

    +}

    +

    +/***************************************************************************//**

    + * Parse one CS step.

    + * @param[in] data Step data field pointer.

    + * @param[in] data_size Step data field size.

    + * @param[in] role ABR role.

    + * @param[in,out] read_cnt Data field byte read count.

    + * @param[out] out Parsed step data.

    + *

    + * @return Status code.

    + ******************************************************************************/

    +static sl_status_t parse_one_step(uint8_t   *data,

    +                                  uint32_t   data_size,

    +                                  abr_role_t role,

    +                                  uint32_t  *read_cnt,

    +                                  cs_step_t *out)

    +{

    +  sl_status_t ret = SL_STATUS_NULL_POINTER, ret_log = SL_STATUS_OK;

    +  if (data == NULL || read_cnt == NULL || out == NULL) {

    +    return ret;

    +  }

    +  // Step mode

    +  ret = read_byte(data, data_size, read_cnt, &out->step_mode);

    +  CHECK_STATUS_RETURN(ret, "Failed to read CS data!" APP_LOG_NL);

    +  // Step channel

    +  ret = read_byte(data, data_size, read_cnt, &out->step_channel);

    +  CHECK_STATUS_RETURN(ret, "Failed to read CS data!" APP_LOG_NL);

    +  // Step data length

    +  ret = read_byte(data, data_size, read_cnt, &out->step_data_length);

    +  CHECK_STATUS_RETURN(ret, "Failed to read CS data!" APP_LOG_NL);

    +

    +  // Step data

    +  switch (out->step_mode) {

    +    case CS_MODE_CALIBRATION:

    +      if (role == ABR_DEVICE_INITIATOR) {

    +        ret = parse_calibration_initiator(data, data_size, read_cnt, out);

    +      } else {

    +        ret = parse_calibration_reflector(data, data_size, read_cnt, out);

    +      }

    +      break;

    +

    +    case sl_bt_cs_mode_rtt: // RTT

    +      ret = parse_rtt_step(data, data_size, read_cnt, out);

    +      break;

    +    case sl_bt_cs_mode_pbr: // RTP

    +      ret = parse_rtp_step(data, data_size, read_cnt, out);

    +      break;

    +    case sl_bt_cs_mode_pbr_and_rtt: // Combined

    +      break;

    +

    +    default:

    +      break;

    +  } // end switch

    +

    +  ret_log = abr_file_log_store_step(role, out);

    +  if (ret_log != SL_STATUS_OK) {

    +    app_log_error("abr_file_log is not functional! No valid logs will be produced!
    (code: 0x%x)" APP_LOG_NL, ret_log);

    +  }

    +  return ret;

    +}

    +

    +/***************************************************************************//**

    + * Read byte from step data field and increment read count.

    + * @param[in] data Step data field pointer.

    + * @param[in] data_size Step data field size.

    + * @param[in,out] read_cnt Data field byte read count.

    + * @param[out] out Byte read.

    + *

    + * @return Status code.

    + ******************************************************************************/

    +static sl_status_t read_byte(const uint8_t *data,

    +                             uint32_t       data_size,

    +                             uint32_t      *read_cnt,

    +                             uint8_t       *out)

    +{

    +  sl_status_t ret = SL_STATUS_FAIL;

    +  if (*read_cnt < data_size) {

    +    *out = data[*read_cnt];

    +    (*read_cnt)++;

    +    ret = SL_STATUS_OK;

    +  } else {

    +    app_log_warning("CS step data reading failed!" APP_LOG_NL);

    +  }

    +  return ret;

    +}

    +

    +/***************************************************************************//**

    + * Check CS event flags.

    + * @param[in] cs_res CS event result struct pointer.

    + * @param[in,out] meas CS measurement data.

    + *

    + * @return Status code.

    + ******************************************************************************/

    +static sl_status_t check_cs_event_flags(sl_bt_evt_cs_result_t *cs_res,

    +                                        cs_measurement_t *meas)

    +{

    +  sl_status_t ret = SL_STATUS_NULL_POINTER;

    +  if (cs_res == NULL || meas == NULL) {

    +    return ret;

    +  }

    +

    +  // Empty event occured

    +  if (cs_res->num_steps == 0) {

    +    app_log_info("Empty CS result event occured!" APP_LOG_NL);

    +    clear_measurement_buffer(meas);

    +    set_restart_needed(meas, true);

    +    ret = SL_STATUS_FAIL;

    +  } // Procedure aborted

    +  else if ((cs_res->procedure_done_status & CS_PROCEDURE_ABORTED)

    +           == CS_PROCEDURE_ABORTED) {

    +    app_log_info("Procedure aborted" APP_LOG_NL);

    +    clear_measurement_buffer(meas);

    +    set_restart_needed(meas, true);

    +    ret = SL_STATUS_OK;

    +  } // Subevent aborted, no restart needed just clear the buffer

    +  else if ((cs_res->subevent_done_status & CS_SUBEVENT_ABORTED)

    +           == CS_SUBEVENT_ABORTED) {

    +    app_log_info("Subevent aborted" APP_LOG_NL);

    +    clear_measurement_buffer(meas);

    +    ret = SL_STATUS_OK;

    +  } else {

    +    ret = SL_STATUS_OK;

    +  }

    +  return ret;

    +}

    +

    +/***************************************************************************//**

    + * Update CS measurement flags.

    + * @param[in,out] meas CS measurement data.

    + * @param[in] role ABR role.

    + ******************************************************************************/

    +static void update_measurement_flags(cs_measurement_t *meas,

    +                                     abr_role_t role)

    +{

    +  if (meas != NULL) {

    +    if (role == ABR_DEVICE_INITIATOR) {

    +      if ((meas->initiator_procedure_cnt > 0)

    +          && (meas->initiator_procedure_cnt

    +              >= meas->reflector_procedure_cnt)) {

    +        meas->initiator_ready = true;

    +      }

    +    } else { // Reflector

    +      if ((meas->reflector_procedure_cnt > 0)

    +          && (meas->reflector_procedure_cnt

    +              >= meas->initiator_procedure_cnt)) {

    +        meas->reflector_ready = true;

    +      }

    +    }

    +

    +    // Check ready state according to procedure counters

    +    if (meas->initiator_ready

    +        && (meas->initiator_procedure_cnt

    +            < meas->reflector_procedure_cnt)) {

    +      meas->initiator_ready = false;

    +      meas->rtt_data.initiator_idx = 0;

    +    }

    +    if (meas->reflector_ready

    +        && (meas->reflector_procedure_cnt

    +            < meas->initiator_procedure_cnt)) {

    +      meas->reflector_ready = false;

    +      meas->rtt_data.reflector_idx = 0;

    +    }

    +  }

    +}

    +

    +/***************************************************************************//**

    + * Check if parsing of the CS samples is completed and update output.

    + * @param[in,out] meas CS measurement data.

    + ******************************************************************************/

    +static void check_measurement_completed(cs_measurement_t *meas)

    +{

    +  if (meas != NULL) {

    +    if (meas->initiator_ready && meas->reflector_ready) {

    +      if (meas->reflector_procedure_cnt == meas->initiator_procedure_cnt) {

    +        // RTT measurement

    +        meas->rtt_data.rtl_input.num_time_stamps = MIN(meas->rtt_data.reflector_idx,
    \

    +                                                       meas->rtt_data.initiator_idx);

    +        meas->rtt_data.rtl_input.rssi_d1 = meas->rtt_data.rssi_initiator;

    +        meas->rtt_data.rtl_input.rssi_d2 = meas->rtt_data.rssi_reflector;

    +        meas->rtt_data.rtl_input.time_d1 = meas->rtt_data.time_initiator;

    +        meas->rtt_data.rtl_input.time_d2 = meas->rtt_data.time_reflector;

    +        // RTP measurement

    +        meas->rtp_data.rtl_input.num_tones = cs_parser.num_tones;

    +        meas->rtp_data.rtl_input.tones_frequency_delta_hz = DEFAULT_FREQUENCY_DELTA;

    +        meas->rtp_data.rtl_input.blank_tone_indices = cs_parser.blank_tone_channels;

    +        meas->rtp_data.rtl_input.num_blank_tone_indices

    +          = cs_parser.num_blank_tone_indices;

    +        meas->rtp_data.rtl_input.tone_qualities_d1 = NULL;

    +        meas->rtp_data.rtl_input.tone_qualities_d2 = NULL;

    +        meas->rtp_data.rtl_input.i_samples_d1 = meas->rtp_data.initiator_i_samples;

    +        meas->rtp_data.rtl_input.q_samples_d1 = meas->rtp_data.initiator_q_samples;

    +        meas->rtp_data.rtl_input.i_samples_d2 = meas->rtp_data.reflector_i_samples;

    +        meas->rtp_data.rtl_input.q_samples_d2 = meas->rtp_data.reflector_q_samples;

    +        meas->ready_to_process = true;

    +        app_log_debug("Measurement ready to process" APP_LOG_NL);

    +      } else {

    +        clear_measurement_buffer(meas);

    +      }

    +    }

    +  }

    +}

    +

    +/***************************************************************************//**

    + * Parse CS RTT step data.

    + * @param[in] data Step data field pointer.

    + * @param[in] data_size Step data field size.

    + * @param[in,out] read_cnt Data field byte read count.

    + * @param[out] step_data Parsed step data.

    + *

    + * @return Status code.

    + ******************************************************************************/

    +static sl_status_t parse_rtt_step(const uint8_t *data,

    +                                  uint32_t       data_size,

    +                                  uint32_t      *read_cnt,

    +                                  cs_step_t     *step_data)

    +{

    +  sl_status_t ret = SL_STATUS_FAIL;

    +  uint8_t data_octet;

    +

    +  if (step_data->step_data_length >= RTT_VALUE_LEN) {

    +    ret = read_byte(data,

    +                    data_size,

    +                    read_cnt,

    +                    &step_data->data.meas_rtt.packet_quality);

    +    CHECK_STATUS_RETURN(ret, "Failed to read CS data!" APP_LOG_NL);

    +

    +    ret = read_byte(data,

    +                    data_size,

    +                    read_cnt,

    +                    &step_data->data.meas_rtt.nadm);

    +    CHECK_STATUS_RETURN(ret, "Failed to read CS data!" APP_LOG_NL);

    +

    +    ret = read_byte(data,

    +                    data_size,

    +                    read_cnt,

    +                    &data_octet);

    +    CHECK_STATUS_RETURN(ret, "Failed to read CS data!" APP_LOG_NL);

    +    step_data->data.meas_rtt.rssi = (int8_t)data_octet;

    +

    +    ret = read_byte(data, data_size, read_cnt, &data_octet);

    +    CHECK_STATUS_RETURN(ret, "Failed to read CS data!" APP_LOG_NL);

    +    step_data->data.meas_rtt.tod_toa = data_octet;

    +

    +    ret = read_byte(data, data_size, read_cnt, &data_octet);

    +    CHECK_STATUS_RETURN(ret, "Failed to read CS data!" APP_LOG_NL);

    +    step_data->data.meas_rtt.tod_toa |= (uint16_t)data_octet << 8;

    +

    +    ret = read_byte(data,

    +                    data_size,

    +                    read_cnt,

    +                    &step_data->data.meas_rtt.antenna);

    +    CHECK_STATUS_RETURN(ret, "Failed to read CS data!" APP_LOG_NL);

    +    step_data->type = MEASUREMENT_RTT;

    +  }

    +  return ret;

    +}

    +

    +/***************************************************************************//**

    + * Convert raw RTP tone PCT value to integer

    + * @param[in] tone_pct Raw tone PCT value.

    + *

    + * @return Converted tone PCT integer value.

    + ******************************************************************************/

    +static int16_t tone_pct_to_int(uint32_t tone_pct)

    +{

    +  // Tone PCT value is aligned into the lower 12 bit of tone_pct

    +  int16_t tone_pct_int16 = (tone_pct & 0xfff) << 4;

    +  return tone_pct_int16 >> 4;

    +}

    +

    +/***************************************************************************//**

    + * Parse CS RTP step data.

    + * @param[in] data Step data field pointer.

    + * @param[in] data_size Step data field size.

    + * @param[in,out] read_cnt Data field byte read count.

    + * @param[out] step_data Parsed step data.

    + *

    + * @return Status code.

    + ******************************************************************************/

    +static sl_status_t parse_rtp_step(const uint8_t *data,

    +                                  uint32_t       data_size,

    +                                  uint32_t      *read_cnt,

    +                                  cs_step_t     *step_data)

    +{

    +  sl_status_t ret = SL_STATUS_OK;

    +  sl_status_t sc = SL_STATUS_FAIL;

    +  uint8_t pct_octet[3];

    +

    +  sc = read_byte(data,

    +                 data_size,

    +                 read_cnt,

    +                 &step_data->data.meas_rtp.antenna_permutation_index);

    +  CHECK_STATUS_RETURN(sc, "Failed to read CS data!" APP_LOG_NL);

    +  app_log_debug("antenna_permutation_index %hhu"APP_LOG_NL,

    +                step_data->data.meas_rtp.antenna_permutation_index);

    +

    +  // Calculate tone pct count based on step data size

    +  const uint32_t tone_pct_count =

    +    (step_data->step_data_length

    +     - sizeof(step_data->data.meas_rtp.antenna_permutation_index))

    +    / (sizeof(pct_octet) + sizeof(step_data->data.meas_rtp.tone_quality[0]));

    +

    +  for (uint8_t i = 0; i < ANTENNA_PERMUTATION_MAX; i++) {

    +    // Check exit condition

    +    if (i >= tone_pct_count) {

    +      break;

    +    }

    +

    +    // Parsing 3 byte PCT field

    +    for (uint8_t pct_octet_num = 0; pct_octet_num < PCT_BYTE_COUNT; pct_octet_num++)
    {

    +      sc = read_byte(data,

    +                     data_size,

    +                     read_cnt,

    +                     &pct_octet[pct_octet_num]);

    +      CHECK_STATUS_RETURN(sc, "Failed to read CS data!" APP_LOG_NL);

    +    }

    +    uint32_t tone_pct = (uint32_t)pct_octet[0]

    +                        + ((uint32_t)pct_octet[1] << 8)

    +                        + ((uint32_t)pct_octet[2] << 16);

    +

    +    // Check if tone_pct is invalid from the non extension slot

    +    if ((tone_pct == TONE_PCT_INVALID) && (i == 0)) {

    +      app_log_warning("incorrect pct %04x" APP_LOG_NL, tone_pct);

    +      ret = SL_STATUS_FAIL;

    +    } else {

    +      app_log_debug("pct %04x"APP_LOG_NL, tone_pct);

    +    }

    +

    +    step_data->data.meas_rtp.pct_i[i] =

    +      (float)tone_pct_to_int((tone_pct) & PCT_DATA_MASK_LOW);

    +    step_data->data.meas_rtp.pct_q[i] =

    +      (float)tone_pct_to_int(((tone_pct) & PCT_DATA_MASK_HIGH) >> PCT_IQ_LEN);

    +

    +    app_log_debug("pcti %f, pctq %f"APP_LOG_NL, step_data->data.meas_rtp.pct_i[i],

    +                  step_data->data.meas_rtp.pct_q[i]);

    +

    +    // Parsing tone quality

    +    sc = read_byte(data,

    +                   data_size,

    +                   read_cnt,

    +                   &step_data->data.meas_rtp.tone_quality[i]);

    +    CHECK_STATUS_RETURN(sc, "Failed to read CS data!" APP_LOG_NL);

    +  } // end for(... ANTENNA_PERMUTATION_MAX)

    +  step_data->data.meas_rtp.pct_sample_num = tone_pct_count;

    +  step_data->type = MEASUREMENT_RTP;

    +  return ret;

    +}

    +

    +/***************************************************************************//**

    + * Parse reflector calibration step.

    + * @param[in] data Step data field pointer.

    + * @param[in] data_size Step data field size.

    + * @param[in,out] read_cnt Data field byte read count.

    + * @param[out] out Parsed step data.

    + *

    + * @return Status code.

    + ******************************************************************************/

    +static sl_status_t parse_calibration_reflector(const uint8_t* data,

    +                                               uint32_t       data_size,

    +                                               uint32_t      *read_cnt,

    +                                               cs_step_t     *out)

    +{

    +  sl_status_t ret = SL_STATUS_OK;

    +  uint8_t data_octet;

    +  ret = read_byte(data, data_size, read_cnt, &out->data.reflector_calib.packet_quality);

    +  CHECK_STATUS_RETURN(ret, "Failed to read CS data!" APP_LOG_NL);

    +

    +  ret = read_byte(data, data_size, read_cnt, &data_octet);

    +  CHECK_STATUS_RETURN(ret, "Failed to read CS data!" APP_LOG_NL);

    +  out->data.reflector_calib.rssi = (int8_t)data_octet;

    +

    +  ret = read_byte(data, data_size, read_cnt, &out->data.reflector_calib.packet_antenna);

    +  CHECK_STATUS_RETURN(ret, "Failed to read CS data!" APP_LOG_NL);

    +  out->type = CALIBRATION_REFLECTOR;

    +  return ret;

    +}

    +

    +/***************************************************************************//**

    + * Parse initiator calibration step.

    + * @param[in] data Step data field pointer.

    + * @param[in] data_size Step data field size.

    + * @param[in,out] read_cnt Data field byte read count.

    + * @param[out] out Parsed step data.

    + *

    + * @return Status code.

    + ******************************************************************************/

    +static sl_status_t parse_calibration_initiator(const uint8_t* data,

    +                                               uint32_t       data_size,

    +                                               uint32_t      *read_cnt,

    +                                               cs_step_t     *out)

    +{

    +  sl_status_t ret = SL_STATUS_OK;

    +  uint8_t data_octet;

    +  ret = read_byte(data, data_size, read_cnt, &out->data.initiator_calib.packet_quality);

    +  CHECK_STATUS_RETURN(ret, "Failed to read CS data!" APP_LOG_NL);

    +

    +  ret = read_byte(data, data_size, read_cnt, &data_octet);

    +  CHECK_STATUS_RETURN(ret, "Failed to read CS data!" APP_LOG_NL);

    +  out->data.initiator_calib.rssi = (int8_t)data_octet;

    +

    +  ret = read_byte(data, data_size, read_cnt, &out->data.initiator_calib.packet_antenna);

    +  CHECK_STATUS_RETURN(ret, "Failed to read CS data!" APP_LOG_NL);

    +

    +  uint8_t freq_offset_lsb;

    +  uint8_t freq_offset_msb;

    +  ret = read_byte(data, data_size, read_cnt, &freq_offset_lsb);

    +  CHECK_STATUS_RETURN(ret, "Failed to read CS data!" APP_LOG_NL);

    +

    +  ret = read_byte(data, data_size, read_cnt, &freq_offset_msb);

    +  CHECK_STATUS_RETURN(ret, "Failed to read CS data!" APP_LOG_NL);

    +  int16_t freq_offset = (uint16_t)freq_offset_lsb + (((uint16_t)freq_offset_msb)
    << 8);

    +  out->data.initiator_calib.freq_offset = freq_offset;

    +  out->type = CALIBRATION_INITIATOR;

    +  return ret;

    +}

    +

    +/***************************************************************************//**

    + * Add parsed RTT data to measurement data.

    + * @param[out] meas CS measurement data.

    + * @param[in] step_data Parsed step data.

    + * @param[in] role ABR role.

    + *

    + * @return Status code.

    + ******************************************************************************/

    +static sl_status_t add_rtt_data_to_measurement(rtt_measurement_t *meas,

    +                                               cs_step_t         *step_data,

    +                                               abr_role_t         role)

    +{

    +  sl_status_t ret = SL_STATUS_NULL_POINTER;

    +

    +  if (meas != NULL && step_data != NULL) {

    +    int32_t rssi = (int32_t)step_data->data.meas_rtt.rssi;

    +    int32_t time = step_data->data.meas_rtt.tod_toa != LL_INVALID_TOA

    +                   ? step_data->data.meas_rtt.tod_toa

    +                   : (int32_t)INVALID_TIME_VALUE;

    +

    +    if (role == ABR_DEVICE_INITIATOR) {

    +      if (meas->initiator_idx >= MAX_NUM_CHANNELS) {

    +        meas->initiator_idx = 0;

    +      }

    +      meas->rssi_initiator[meas->initiator_idx] = rssi;

    +      meas->time_initiator[meas->initiator_idx] = time;

    +      meas->initiator_idx++;

    +    } else { // Reflector

    +      if (meas->reflector_idx >= MAX_NUM_CHANNELS) {

    +        meas->reflector_idx = 0;

    +      }

    +      meas->rssi_reflector[meas->reflector_idx] = rssi;

    +      meas->time_reflector[meas->reflector_idx] = time;

    +      meas->reflector_idx++;

    +    }

    +    ret = SL_STATUS_OK;

    +  }

    +  return ret;

    +}

    +

    +/***************************************************************************//**

    + * Add parsed RTP data to measurement data.

    + * @param[out] meas CS measurement data.

    + * @param[in] step_data Parsed step data.

    + * @param[in] role ABR role.

    + *

    + * @return Status code.

    + ******************************************************************************/

    +static sl_status_t add_rtp_data_to_measurement(rtp_measurement_t *meas,

    +                                               cs_step_t         *step_data,

    +                                               abr_role_t         role)

    +{

    +  sl_status_t ret = SL_STATUS_NULL_POINTER;

    +  uint8_t channel_idx = 0;

    +

    +  if (meas != NULL && step_data != NULL) {

    +    channel_idx = step_data->step_channel / 2; // Calculate channel index from
    step_channel

    +    if (channel_idx > MAX_NUM_CHANNELS) {

    +      app_log_warning("Incorrect PCT channel!" APP_LOG_NL);

    +      ret = SL_STATUS_FAIL;

    +    } else {

    +      if (role == ABR_DEVICE_INITIATOR) {

    +        meas->initiator_i_samples[channel_idx] = step_data->data.meas_rtp.pct_i[0];

    +        meas->initiator_q_samples[channel_idx] = step_data->data.meas_rtp.pct_q[0];

    +      } else { // Reflector

    +        meas->reflector_i_samples[channel_idx] = step_data->data.meas_rtp.pct_i[0];

    +        meas->reflector_q_samples[channel_idx] = step_data->data.meas_rtp.pct_q[0];

    +      }

    +      ret = SL_STATUS_OK;

    +    }

    +  }

    +  return ret;

    +}

    +

    +/***************************************************************************//**

    + * Add parsed calibration data to measurement data.

    + * @param[out] meas CS measurement data.

    + * @param[in] step_data Parsed step data.

    + * @param[in] role ABR role.

    + *

    + * @return Status code.

    + ******************************************************************************/

    +static sl_status_t add_calibration_data_to_measurement(cs_measurement_t  *meas,

    +                                                       cs_step_t         *step_data,

    +                                                       abr_role_t         role)

    +{

    +  sl_status_t ret = SL_STATUS_NULL_POINTER;

    +

    +  if (meas != NULL && step_data != NULL) {

    +    if (role == ABR_DEVICE_INITIATOR) {

    +      meas->initiator_calib = step_data->data.initiator_calib;

    +    } else { // Reflector

    +      meas->reflector_calib = step_data->data.reflector_calib;

    +    }

    +    ret = SL_STATUS_OK;

    +  }

    +  return ret;

    +}

    +

    +/***************************************************************************//**

    + * Get measurement index according to connection handle.

    + *

    + * @param[in] connection Connection handle from BLE stack.

    + * @param[out] index Pointer to calculated index.

    + *

    + * Note:

    + * If connection is not stored yet and there is an empty slot left,

    + * then the function stores the connection handle.

    + * The connection slot number is configurable and equals to the number of

    + * supported reflector connections.

    + * For more information see ''NUM_OF_REFLECTORS'' configuration parameter.

    + * @return Status code.

    + ******************************************************************************/

    +static sl_status_t get_measurement_index_from_connection(uint8_t connection,

    +                                                         uint8_t *index)

    +{

    +  sl_status_t ret = SL_STATUS_FAIL;

    +  bool found = false;

    +

    +  if ((connection != SL_BT_INVALID_CONNECTION_HANDLE)

    +      && (index != NULL)) {

    +    for (uint8_t idx = 0; idx < NUM_OF_REFLECTORS; idx++) {

    +      if (cs_parser.measurements[idx].connection == connection) {

    +        *index = idx;

    +        found = true;

    +        ret = SL_STATUS_OK;

    +        break;

    +      }

    +    }

    +    if (!found) {

    +      uint8_t empty_slots = 0;

    +      // Calculate empty slots

    +      for (uint8_t idx = 0; idx < NUM_OF_REFLECTORS; idx++) {

    +        if (cs_parser.measurements[idx].connection

    +            == SL_BT_INVALID_CONNECTION_HANDLE) {

    +          empty_slots++;

    +        }

    +      }

    +      if (empty_slots != 0) {

    +        // Occupy empty slot

    +        *index = NUM_OF_REFLECTORS - empty_slots;

    +        cs_parser.measurements[*index].connection = connection;

    +        ret = SL_STATUS_OK;

    +      }

    +    }

    +  }

    +  return ret;

    +}

    +

    +/***************************************************************************//**

    + * Get measurement pointer based on connection handle.

    + * @param[out] meas CS measurement data stucture pointer.

    + * @param[in] conn Connection handle from BLE stack.

    + *

    + * @return Status code.

    + ******************************************************************************/

    +static sl_status_t get_measurement_from_connection(cs_measurement_t **meas,

    +                                                   uint8_t            conn)

    +{

    +  sl_status_t ret = SL_STATUS_NOT_FOUND;

    +  uint8_t meas_idx = 0;

    +

    +  if (meas != NULL) {

    +    ret = get_measurement_index_from_connection(conn, &meas_idx);

    +

    +    if (ret == SL_STATUS_OK) {

    +      *meas = &cs_parser.measurements[meas_idx];

    +      (*meas)->connection = conn;

    +    }

    +  }

    +  return ret;

    +}

    +

    +/***************************************************************************//**

    + * Clear CS measurement buffers.

    + ******************************************************************************/

    +static void clear_measurement_buffers(void)

    +{

    +  for (uint8_t i = 0; i < NUM_OF_REFLECTORS; i++) {

    +    clear_measurement_buffer(&cs_parser.measurements[i]);

    +  }

    +}

    +

    +/***************************************************************************//**

    + * Clear measurement buffer and restore initial state.

    + * @param[in] meas CS measurement data.

    + ******************************************************************************/

    +static void clear_measurement_buffer(cs_measurement_t *meas)

    +{

    +  if (meas != NULL) {

    +    uint8_t conn = meas->connection; // Preserve connection handle

    +    memset(meas, 0, sizeof(cs_measurement_t));

    +    // Set RTT invalid data as empty values for RTL lib.

    +    for (uint8_t c = 0; c < MAX_NUM_CHANNELS; c++) {

    +      meas->rtt_data.time_initiator[c] = INVALID_TIME_VALUE;

    +      meas->rtt_data.time_reflector[c] = INVALID_TIME_VALUE;

    +      meas->rtt_data.rssi_initiator[c] = INVALID_RSSI_VALUE;

    +      meas->rtt_data.rssi_reflector[c] = INVALID_RSSI_VALUE;

    +    }

    +    meas->connection = conn;

    +  }

    +}

    +

    +/***************************************************************************//**

    + * Set restart needed for a particular measurement.

    + * @param[in] meas CS measurement data.

    + * @param[in] needed Restart needed boolean.

    + ******************************************************************************/

    +static void set_restart_needed(cs_measurement_t *meas, bool needed)

    +{

    +  if (meas != NULL) {

    +    meas->restart_needed = needed;

    +  }

    +}

    +

    +/******************************************************************************

    + * Set the channel_map

    + *

    + * @param channel_map is the channel_map data

    + * @param channel_map_len is the channel_map data length

    + *****************************************************************************/

    +static sl_status_t set_channel_map(const uint8_t *channel_map,

    +                                   const uint32_t channel_map_len)

    +{

    +  uint8_t current_channel_map;

    +

    +  uint32_t num_channels = 0;

    +  uint32_t blank_tone_channels_index = 0;

    +  uint32_t num_hadm_channels = 0;

    +  sl_status_t ret = SL_STATUS_NULL_POINTER;

    +

    +  if (channel_map != NULL) {

    +    cs_parser.num_blank_tone_indices = 0;

    +

    +    for (uint32_t channel_map_index = 0;

    +         channel_map_index < channel_map_len;

    +         channel_map_index++) {

    +      current_channel_map = channel_map[channel_map_index];

    +      for (uint8_t current_bit_index = 0;

    +           current_bit_index < sizeof(uint8_t) * BYTE_LEN;

    +           current_bit_index++) {

    +        if (current_channel_map & (1 << current_bit_index)) {

    +          num_hadm_channels++;

    +        } else {

    +          cs_parser.blank_tone_channels[blank_tone_channels_index]

    +            = num_channels;

    +          blank_tone_channels_index++;

    +        }

    +        num_channels++;

    +      }

    +    }

    +

    +    cs_parser.num_tones = num_hadm_channels;

    +    app_log_info("RTL process %u channels" APP_LOG_NL, cs_parser.num_tones);

    +    ret = SL_STATUS_OK;

    +  }

    +  return ret;

    +}'
  - "--- a/app/bluetooth/common/abr_cs_parser/abr_file_log.c\n+++ b/app/bluetooth/common/abr_cs_parser/abr_file_log.c\n\
    @@ -0,0 +1,942 @@\n+/***************************************************************************//**\n\
    + * @file\n+ * @brief ABR file logger\n+ *******************************************************************************\n\
    + * # License\n+ * <b>Copyright 2023 Silicon Laboratories Inc. www.silabs.com</b>\n\
    + *******************************************************************************\n\
    + *\n+ * SPDX-License-Identifier: Zlib\n+ *\n+ * The licensor of this software\
    \ is Silicon Laboratories Inc.\n+ *\n+ * This software is provided 'as-is', without\
    \ any express or implied\n+ * warranty. In no event will the authors be held liable\
    \ for any damages\n+ * arising from the use of this software.\n+ *\n+ * Permission\
    \ is granted to anyone to use this software for any purpose,\n+ * including commercial\
    \ applications, and to alter it and redistribute it\n+ * freely, subject to the\
    \ following restrictions:\n+ *\n+ * 1. The origin of this software must not be\
    \ misrepresented; you must not\n+ *    claim that you wrote the original software.\
    \ If you use this software\n+ *    in a product, an acknowledgment in the product\
    \ documentation would be\n+ *    appreciated but is not required.\n+ * 2. Altered\
    \ source versions must be plainly marked as such, and must not be\n+ *    misrepresented\
    \ as being the original software.\n+ * 3. This notice may not be removed or altered\
    \ from any source distribution.\n+ *\n+ ******************************************************************************/\n\
    +#if defined(HOST_TOOLCHAIN) && (ABR_FILE_LOG_ENABLED == 1)\n+\n+#include <stdbool.h>\n\
    +#include <time.h>\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <string.h>\n\
    +#include \"cJSON.h\"\n+#include \"abr_file_log.h\"\n+#include \"abr_file_log_config.h\"\
    \n+\n+#include \"sl_status.h\"\n+#include \"app_log.h\"\n+#include \"abr_cs_parser_types.h\"\
    \n+#include \"abr_cs_parser_config.h\"\n+\n+// -----------------------------------------------------------------------------\n\
    +// Defines\n+\n+#define FILENAME_STRLEN                      1024\n+#define MAX_STRLEN\
    \                           FILENAME_STRLEN\n+#define TIME_STRLEN            \
    \              20UL\n+#define NANOSEC_DIVIDER                      (double)0.000000001\n\
    +\n+// File section literals\n+// *INDENT-OFF*\n+#define FILE_EXTENSION      \
    \                 \".jsonl\"\n+\n+// jsonl fields\n+#define HDR_CH_MAP       \
    \                    \"channel_map\"\n+#define HDR_MODE0_STEPS               \
    \       \"mode_0_steps\"\n+#define HDR_TIMESTAMP                        \"timestamp\"\
    \n+#define HDR_TIMESTAMP_REALTIME               \"timestamp_realtime\"\n+#define\
    \ HDR_SDKVERSION                       \"sdk_version\"\n+\n+#define MEAS_ESTIMATED_DISTANCE\
    \              \"estimated_distance\"\n+#define MEAS_INITIATOR_BEGIN         \
    \        \"initiator_cs_subevent_result_events\"\n+#define MEAS_REFLECTOR_BEGIN\
    \                 \"reflector_cs_subevent_result_events\"\n+#define MEAS_NUM_EVENTS\
    \                      \"num_events\"\n+#define MEAS_EVENTS_ARRAY            \
    \        \"events\"\n+\n+#define MEAS_EVENT_ID                        \"start_acl_conn_event\"\
    \n+#define MEAS_EVENT_PROC_CNT                  \"procedure_counter\"\n+#define\
    \ MEAS_EVENT_FREQ_COMP                 \"frequency_compensation\"\n+#define MEAS_EVENT_PROC_DONE_STS\
    \             \"procedure_done_status\"\n+#define MEAS_SUBEVENT_DONE_STS     \
    \          \"subevent_done_status\"\n+#define MEAS_EVENT_ABORT_REASON        \
    \      \"abort_reason\"\n+#define MEAS_EVENT_REF_POWER_LVL             \"reference_power_level\"\
    \n+#define MEAS_EVENT_NUM_ANT_PATHS             \"num_antenna_paths\"\n+#define\
    \ MEAS_NUM_STEPS                       \"num_steps\"\n+#define MEAS_STEPS_ARRAY\
    \                     \"steps\"\n+\n+#define CAL_STEP_MODE                   \
    \     \"step_mode\"\n+#define CAL_STEP_CHANNEL                     \"step_channel\"\
    \n+#define CAL_STEP_RSSI                        \"rssi\"\n+#define CAL_STEP_FREQ_OFFSET\
    \                 \"freq_offset\"\n+#define CAL_STEP_PACKET_QUALITY          \
    \    \"packet_quality\"\n+#define CAL_STEP_PACKET_ANTENNA              \"antenna\"\
    \n+\n+#define RTT_STEP_MODE                        CAL_STEP_MODE\n+#define RTT_STEP_CHANNEL\
    \                     CAL_STEP_CHANNEL\n+#define RTT_STEP_PACKET_QUALITY     \
    \         CAL_STEP_PACKET_QUALITY\n+#define RTT_STEP_NADM                    \
    \    \"nadm\"\n+#define RTT_STEP_RSSI                        CAL_STEP_RSSI\n+#define\
    \ RTT_STEP_TOD_TOA                     \"rtt\"\n+#define RTT_STEP_ANTENNA    \
    \                 \"antenna\"\n+\n+#define RTP_STEP_MODE                     \
    \   CAL_STEP_MODE\n+#define RTP_STEP_CHANNEL                     CAL_STEP_CHANNEL\n\
    +#define RTP_STEP_ANTENNA_PERMUTATION_INDEX   \"antenna_permutation_index\"\n\
    +#define RTP_STEP_PCT_I                       \"PCT_I\"\n+#define RTP_STEP_PCT_Q\
    \                       \"PCT_Q\"\n+#define RTP_STEP_TONE_QUALITY            \
    \    \"tone_quality\"\n+// *INDENT-ON*\n+\n+// Selector for timestamps\n+typedef\
    \ enum {\n+  realtime_clock = 0,\n+  monotonic_clock,\n+  both_clocks = 0xff\n\
    +} abr_file_log_clocktype_t;\n+\n+// -----------------------------------------------------------------------------\n\
    +// Module variables.\n+\n+static FILE * jsonl_file = NULL;\n+static char jsonl_filename[FILENAME_STRLEN]\
    \ = \" \";\n+static bool file_conflict = false;\n+\n+// Header section\n+static\
    \ uint16_t sw_major;\n+static uint16_t sw_minor;\n+static uint16_t sw_patch;\n\
    +static uint16_t sw_build;\n+\n+// Measurement section\n+static uint32_t initiator_num_events\
    \ = 0;\n+static uint32_t reflector_num_events = 0;\n+static cJSON *jsonl_initiator_events[ABR_FILE_LOG_CFG_MAX_EVENTS];\n\
    +static cJSON *jsonl_reflector_events[ABR_FILE_LOG_CFG_MAX_EVENTS];\n+\n+static\
    \ uint32_t initiator_num_steps = 0;\n+static uint32_t reflector_num_steps = 0;\n\
    +static cJSON *jsonl_initiator_steps[ABR_FILE_LOG_CFG_MAX_STEPS];\n+static cJSON\
    \ *jsonl_reflector_steps[ABR_FILE_LOG_CFG_MAX_STEPS];\n+static uint32_t measurement_cycle\
    \ = 0;\n+\n+// -----------------------------------------------------------------------------\n\
    +// Private function declarations\n+static void initialize_cjson_buffers(abr_role_t\
    \ role);\n+static sl_status_t append_channel_map(cJSON* const jsonl, const uint8_t\
    \ *data, const uint32_t data_len);\n+static sl_status_t append_steps_to_event_header(cJSON\
    \ **actual_event, const uint32_t num_steps,\n+                               \
    \                 cJSON **steps_array, const uint32_t array_size);\n+static void\
    \ append_current_time(cJSON * const jsonl, abr_file_log_clocktype_t clock);\n\
    +static sl_status_t abr_file_log_append_device_section(abr_role_t role, cJSON\
    \ *target_section);\n+\n+#if (ABR_FILE_LOG_CFG_KEEP_OLD_FILES)\n+static bool fexist(const\
    \ char* filename);\n+#endif\n+static sl_status_t set_filename(uint8_t measurement_mode);\n\
    +\n+static void store_calib_step(abr_role_t role, cs_step_t *step);\n+static void\
    \ store_rtt_step(abr_role_t role, cs_step_t *step);\n+static void store_rtp_step(abr_role_t\
    \ role, cs_step_t *step);\n+\n+// -----------------------------------------------------------------------------\n\
    +// Public function definitions\n+\n+/******************************************************************************\n\
    + * ABR file logger initialization\n+ * This function sets the target filename\
    \ and gets the measurement mode.\n+ *****************************************************************************/\n\
    +sl_status_t abr_file_log_init(uint8_t abr_mode)\n+{\n+  sl_status_t sc = SL_STATUS_OK;\n\
    +\n+  initialize_cjson_buffers(ABR_DEVICE_INITIATOR);\n+  initialize_cjson_buffers(ABR_DEVICE_REFLECTOR);\n\
    +\n+  sc = set_filename(abr_mode);\n+  if (sc != SL_STATUS_OK) {\n+    file_conflict\
    \ = true;\n+  }\n+\n+  app_log_info(\"File logger initiatized.\" APP_LOG_NL);\n\
    +  return sc;\n+}\n+\n+/******************************************************************************\n\
    + * ABR file logger deinitialization\n+ * Closing file if its still open.\n+ *****************************************************************************/\n\
    +sl_status_t abr_file_log_deinit(void)\n+{\n+  sl_status_t sc = SL_STATUS_OK;\n\
    +  FILE *f;\n+\n+  // *INDENT-OFF*\n+  f = fopen(jsonl_filename,\"w+\");\n+  if\
    \ (f != NULL) {\n+    fclose(f);\n+    app_log_warning(\"%s was still open. Closed\
    \ file.\" APP_LOG_NL, jsonl_filename);\n+  }\n+  // *INDENT-ON*\n+\n+  return\
    \ sc;\n+}\n+\n+/******************************************************************************\n\
    + * ABR file logger get application version\n+ * Gets application version info\
    \ for loggin.\n+ *****************************************************************************/\n\
    +void abr_file_log_app_version(uint16_t major, uint16_t minor,\n+            \
    \                  uint16_t patch, uint16_t build)\n+{\n+  sw_major = major;\n\
    +  sw_minor = minor;\n+  sw_patch = patch;\n+  sw_build = build;\n+}\n+\n+/******************************************************************************\n\
    + * ABR file log append header section\n+ * This function gathers all the information\
    \ the file header must contain\n+ * such as:\n+ * - timestamp: the start time\
    \ of the initiator feature\n+ * - sdk_version: base GSDK version in format \"\
    major.minor.patch.build\"\n+ * - channel_map: channel map string\n+ * - mode0_steps:\
    \ number of mode0 steps (calibration) in every event\n+ * The jsonl object is\
    \ also appended to the target file and it will be closed\n+ * until the first\
    \ distance measurement finished.\n+ *****************************************************************************/\n\
    +sl_status_t abr_file_log_append_header_section(const uint8_t *ch_data,\n+   \
    \                                            const uint32_t ch_data_len,\n+  \
    \                                             const uint8_t mode0_steps_count)\n\
    +{\n+  sl_status_t sc = SL_STATUS_OK;\n+  cJSON *jsonl_header = cJSON_CreateObject();\n\
    +  char sdk_version_string[MAX_STRLEN];\n+  char *header_string;\n+  int printed_bytes\
    \ = 0, i = 0, max_iteration = 1;\n+\n+#if (ABR_FILE_LOG_CFG_RETRY_FPRINTF && (ABR_FILE_LOG_CFG_RETRY_FPRINTF_COUNT\
    \ > 1))\n+  max_iteration = ABR_FILE_LOG_CFG_RETRY_FPRINTF_COUNT;\n+#endif //\
    \ (ABR_FILE_LOG_CFG_RETRY_FPRINTF && (ABR_FILE_LOG_CFG_RETRY_FPRINTF_COUNT > 0))\n\
    +\n+  append_current_time(jsonl_header, both_clocks);\n+\n+  sprintf(sdk_version_string,\
    \ \"%d.%d.%d.%d\", sw_major, sw_minor, sw_patch, sw_build);\n+\n+  cJSON_AddStringToObject(jsonl_header,\
    \ HDR_SDKVERSION, sdk_version_string);\n+\n+  sc = append_channel_map(jsonl_header,\
    \ ch_data, ch_data_len);\n+\n+  cJSON_AddIntegerToObject(jsonl_header, HDR_MODE0_STEPS,\
    \ mode0_steps_count);\n+\n+  if (!file_conflict) {\n+    if (ABR_FILE_LOG_CFG_FORMATTED_PRINT)\
    \ {\n+      header_string = cJSON_Print(jsonl_header);\n+    } else {\n+     \
    \ header_string = cJSON_PrintUnformatted(jsonl_header);\n+    }\n+    app_log_info(\"\
    Open file %s to write header...\" APP_LOG_NL, jsonl_filename);\n+    jsonl_file\
    \ = fopen(jsonl_filename, \"w\");\n+    if (jsonl_file != NULL) {\n+      app_log_debug(\"\
    Appending file header...\" APP_LOG_NL);\n+\n+      for (i = 0; i < max_iteration;\
    \ i++) {\n+        if (ABR_FILE_LOG_CFG_FORCE_ADD_NEWLINE == 1) {\n+         \
    \ printed_bytes = fprintf(jsonl_file, \"%s\" ABR_FILE_LOG_CFG_NL, header_string);\n\
    +        } else {\n+          printed_bytes = fprintf(jsonl_file, \"%s\", header_string);\n\
    +        }\n+        if (printed_bytes >= 0) {\n+          app_log_debug(\"Written\
    \ %d bytes into the file.\" APP_LOG_NL, printed_bytes);\n+          sc = SL_STATUS_OK;\n\
    +          break;\n+        } else {\n+          app_log_warning(\"Failed to write\
    \ file.\");\n+          if (max_iteration > 1) {\n+            app_log_append_warning(\"\
    Retrying ...\" APP_LOG_NL);\n+          }\n+          sc = SL_STATUS_FAIL;\n+\
    \        }\n+      }\n+      if (sc == SL_STATUS_FAIL) {\n+        app_log_error(\"\
    Appending header failed, retried %d times. (code: 0x%x)\" APP_LOG_NL,\n+     \
    \                 max_iteration, printed_bytes);\n+      } else {\n+        app_log_debug(\"\
    Appended header, closing file...\" APP_LOG_NL);\n+      }\n+      fclose(jsonl_file);\n\
    +      // free() is a necessary step here because of cJSON_Print()\n+      //\
    \ usage above\n+      free(header_string);\n+    } else {\n+      app_log_error(\"\
    Cannot open file %s!\" APP_LOG_NL, jsonl_filename);\n+      sc = SL_STATUS_NULL_POINTER;\n\
    +    }\n+  } else {\n+    app_log_error(\"Cannot open file to avoid data loss!\"\
    \ APP_LOG_NL);\n+    sc = SL_STATUS_FAIL;\n+  }\n+\n+  app_log_debug(\"Measurement\
    \ cycle %04u starts.\" APP_LOG_NL, measurement_cycle);\n+  initiator_num_events\
    \ = 0;\n+  reflector_num_events = 0;\n+\n+  return sc;\n+}\n+\n+/******************************************************************************\n\
    + * Append new event header to the new event jsonl objects\n+ * This event header\
    \ appended on the beginning of every measurement cycle!\n+ * It checks the actual\
    \ event role (device) and fill up\n+ * the header for it with the already known\
    \ information:\n+ * - start_acl_conn_event: the event identifier\n+ * - timestamp\n\
    + * The jsonl object will be extended the additional information later on.\n+\
    \ *****************************************************************************/\n\
    +sl_status_t abr_file_log_append_event_header(abr_role_t role,\n+            \
    \                                 sl_bt_evt_cs_result_t *cs_res)\n+{\n+  sl_status_t\
    \ sc = SL_STATUS_OK;\n+\n+  // Check input parameters\n+  if (cs_res != NULL)\
    \ {\n+    // At this point it is not known how many events may come yet so\n+\
    \    // we can only add the following elements to the event object:\n+    // -\
    \ start_acl_conn_event\n+    // - timestamp (the moment when the event detected\
    \ here)\n+    if (role == ABR_DEVICE_INITIATOR) {\n+      initiator_num_steps\
    \ = 0;\n+      cJSON_AddIntegerToObject(jsonl_initiator_events[initiator_num_events],\n\
    +                               MEAS_EVENT_ID,\n+                            \
    \   cs_res->start_acl_conn_event);\n+      cJSON_AddIntegerToObject(jsonl_initiator_events[initiator_num_events],\n\
    +                               MEAS_EVENT_PROC_CNT,\n+                      \
    \         cs_res->procedure_counter);\n+      cJSON_AddIntegerToObject(jsonl_initiator_events[initiator_num_events],\n\
    +                               MEAS_EVENT_FREQ_COMP,\n+                     \
    \          cs_res->frequency_compensation);\n+      cJSON_AddIntegerToObject(jsonl_initiator_events[initiator_num_events],\n\
    +                               MEAS_EVENT_PROC_DONE_STS,\n+                 \
    \              cs_res->procedure_done_status);\n+      cJSON_AddIntegerToObject(jsonl_initiator_events[initiator_num_events],\n\
    +                               MEAS_SUBEVENT_DONE_STS,\n+                   \
    \            cs_res->subevent_done_status);\n+      cJSON_AddIntegerToObject(jsonl_initiator_events[initiator_num_events],\n\
    +                               MEAS_EVENT_ABORT_REASON,\n+                  \
    \             cs_res->abort_reason);\n+      cJSON_AddIntegerToObject(jsonl_initiator_events[initiator_num_events],\n\
    +                               MEAS_EVENT_REF_POWER_LVL,\n+                 \
    \              cs_res->reference_power_level);\n+      cJSON_AddIntegerToObject(jsonl_initiator_events[initiator_num_events],\n\
    +                               MEAS_EVENT_NUM_ANT_PATHS,\n+                 \
    \              cs_res->num_antenna_paths);\n+      append_current_time(jsonl_initiator_events[initiator_num_events],\
    \ both_clocks);\n+      app_log_debug(\"<<< %02d. initiator EVENT processing begin\
    \ >>>\" APP_LOG_NL, initiator_num_events);\n+    } else {\n+      reflector_num_steps\
    \ = 0;\n+      cJSON_AddIntegerToObject(jsonl_reflector_events[reflector_num_events],\n\
    +                               MEAS_EVENT_ID,\n+                            \
    \   cs_res->start_acl_conn_event);\n+      cJSON_AddIntegerToObject(jsonl_reflector_events[reflector_num_events],\n\
    +                               MEAS_EVENT_PROC_CNT,\n+                      \
    \         cs_res->procedure_counter);\n+      cJSON_AddIntegerToObject(jsonl_reflector_events[reflector_num_events],\n\
    +                               MEAS_EVENT_FREQ_COMP,\n+                     \
    \          cs_res->frequency_compensation);\n+      cJSON_AddIntegerToObject(jsonl_reflector_events[reflector_num_events],\n\
    +                               MEAS_EVENT_PROC_DONE_STS,\n+                 \
    \              cs_res->procedure_done_status);\n+      cJSON_AddIntegerToObject(jsonl_reflector_events[reflector_num_events],\n\
    +                               MEAS_SUBEVENT_DONE_STS,\n+                   \
    \            cs_res->subevent_done_status);\n+      cJSON_AddIntegerToObject(jsonl_reflector_events[reflector_num_events],\n\
    +                               MEAS_EVENT_ABORT_REASON,\n+                  \
    \             cs_res->abort_reason);\n+      cJSON_AddIntegerToObject(jsonl_reflector_events[reflector_num_events],\n\
    +                               MEAS_EVENT_REF_POWER_LVL,\n+                 \
    \              cs_res->reference_power_level);\n+      cJSON_AddIntegerToObject(jsonl_reflector_events[reflector_num_events],\n\
    +                               MEAS_EVENT_NUM_ANT_PATHS,\n+                 \
    \              cs_res->num_antenna_paths);\n+      append_current_time(jsonl_reflector_events[reflector_num_events],\
    \ both_clocks);\n+      app_log_debug(\"<<< %02d. reflector EVENT processing begin\
    \ >>>\" APP_LOG_NL, reflector_num_events);\n+    }\n+  } else {\n+    app_log_error(\"\
    Invalid input parameter!\" APP_LOG_NL);\n+    sc = SL_STATUS_NULL_POINTER;\n+\
    \  }\n+\n+  return sc;\n+}\n+\n+/******************************************************************************\n\
    + * Assign steps to event\n+ * Once every steps is processed in 1 event, assign\
    \ their array to that event\n+ * and finalize.\n+ *****************************************************************************/\n\
    +sl_status_t abr_file_log_assign_steps_to_event(abr_role_t role, uint16_t num_steps)\n\
    +{\n+  sl_status_t sc = SL_STATUS_OK;\n+  app_log_debug(\"Assign steps to event\"\
    \ APP_LOG_NL);\n+  if (num_steps != 0) {\n+    if (role == ABR_DEVICE_INITIATOR)\
    \ {\n+      sc = append_steps_to_event_header(&jsonl_initiator_events[initiator_num_events],\n\
    +                                        num_steps,\n+                       \
    \                 jsonl_initiator_steps,\n+                                  \
    \      initiator_num_steps);\n+      app_log_debug(\"%s\" APP_LOG_NL, cJSON_PrintUnformatted(jsonl_initiator_events[initiator_num_events]));\n\
    +      if (sc == SL_STATUS_OK) {\n+        app_log_debug(\"<<< %02d. initiator\
    \ EVENT processing end >>>\" APP_LOG_NL, initiator_num_events);\n+        initiator_num_events++;\n\
    +      } else {\n+        app_log_error(\"%02d. initiator event is corrupted!\"\
    \ APP_LOG_NL, initiator_num_events);\n+      }\n+    } else {\n+      sc = append_steps_to_event_header(&jsonl_reflector_events[reflector_num_events],\n\
    +                                        num_steps,\n+                       \
    \                 jsonl_reflector_steps,\n+                                  \
    \      reflector_num_steps);\n+      app_log_debug(\"%s\" APP_LOG_NL, cJSON_Print(jsonl_reflector_events[reflector_num_events]));\n\
    +      if (sc == SL_STATUS_OK) {\n+        app_log_debug(\"<<< %02d. reflector\
    \ EVENT processing end >>>\" APP_LOG_NL, reflector_num_events);\n+        reflector_num_events++;\n\
    +      } else {\n+        app_log_error(\"%02d. reflector event is corrupted!\"\
    \ APP_LOG_NL, reflector_num_events);\n+      }\n+    }\n+  }\n+\n+  return sc;\n\
    +}\n+\n+/******************************************************************************\n\
    + * Store step data\n+ * Parsed and saved properties according to the actual mode\
    \ and role.\n+ * There is also an option to keep the old jsonl format of the steps\
    \ or extend\n+ * them with additional properties.\n+ * The function also increments\
    \ the step counters.\n+ *****************************************************************************/\n\
    +sl_status_t abr_file_log_store_step(abr_role_t role, cs_step_t * step_data)\n\
    +{\n+  sl_status_t sc = SL_STATUS_OK;\n+  if (step_data != NULL) {\n+    switch\
    \ (step_data->step_mode) {\n+      case sl_bt_cs_mode_calibration:\n+        store_calib_step(role,\
    \ step_data);\n+        break;\n+\n+      case sl_bt_cs_mode_rtt:\n+        store_rtt_step(role,\
    \ step_data);\n+        break;\n+\n+      case sl_bt_cs_mode_pbr:\n+        store_rtp_step(role,\
    \ step_data);\n+        break;\n+\n+      case sl_bt_cs_mode_pbr_and_rtt:    \
    \   // Reserved for the future\n+        break;\n+\n+      default:\n+       \
    \ break;\n+    }\n+  } else {\n+    app_log_error(\"No step data detected!\" APP_LOG_NL);\n\
    +    sc = SL_STATUS_NULL_POINTER;\n+  }\n+\n+  return sc;\n+}\n+\n+static void\
    \ store_calib_step(abr_role_t role, cs_step_t * step)\n+{\n+  if (role == ABR_DEVICE_INITIATOR)\
    \ {\n+    jsonl_initiator_steps[initiator_num_steps] = cJSON_CreateObject();\n\
    +    cJSON_AddIntegerToObject(jsonl_initiator_steps[initiator_num_steps], CAL_STEP_MODE,\
    \ step->step_mode);\n+    cJSON_AddIntegerToObject(jsonl_initiator_steps[initiator_num_steps],\
    \ CAL_STEP_CHANNEL, step->step_channel);\n+    cJSON_AddIntegerToObject(jsonl_initiator_steps[initiator_num_steps],\
    \ CAL_STEP_RSSI,\n+                             step->data.initiator_calib.rssi);\n\
    +    cJSON_AddIntegerToObject(jsonl_initiator_steps[initiator_num_steps], CAL_STEP_FREQ_OFFSET,\n\
    +                             step->data.initiator_calib.freq_offset);\n+    cJSON_AddIntegerToObject(jsonl_initiator_steps[initiator_num_steps],\
    \ CAL_STEP_PACKET_ANTENNA,\n+                             step->data.initiator_calib.packet_antenna);\n\
    +    cJSON_AddIntegerToObject(jsonl_initiator_steps[initiator_num_steps], CAL_STEP_PACKET_QUALITY,\n\
    +                             step->data.initiator_calib.packet_quality);\n+ \
    \   app_log_debug(\" %02d: initiator calib.step stored.\" APP_LOG_NL, initiator_num_steps);\n\
    +    initiator_num_steps++;\n+  } else {\n+    jsonl_reflector_steps[reflector_num_steps]\
    \ = cJSON_CreateObject();\n+    cJSON_AddIntegerToObject(jsonl_reflector_steps[reflector_num_steps],\
    \ CAL_STEP_MODE, step->step_mode);\n+    cJSON_AddIntegerToObject(jsonl_reflector_steps[reflector_num_steps],\
    \ CAL_STEP_CHANNEL, step->step_channel);\n+    cJSON_AddIntegerToObject(jsonl_reflector_steps[reflector_num_steps],\
    \ CAL_STEP_RSSI,\n+                             step->data.reflector_calib.rssi);\n\
    +    cJSON_AddIntegerToObject(jsonl_reflector_steps[reflector_num_steps], CAL_STEP_PACKET_ANTENNA,\n\
    +                             step->data.reflector_calib.packet_antenna);\n+ \
    \   cJSON_AddIntegerToObject(jsonl_reflector_steps[reflector_num_steps], CAL_STEP_PACKET_QUALITY,\n\
    +                             step->data.reflector_calib.packet_quality);\n+ \
    \   app_log_debug(\" %02d: reflector calib.step stored.\" APP_LOG_NL, reflector_num_steps);\n\
    +    reflector_num_steps++;\n+  }\n+}\n+\n+static void store_rtt_step(abr_role_t\
    \ role, cs_step_t * step)\n+{\n+  if (role == ABR_DEVICE_INITIATOR) {\n+    jsonl_initiator_steps[initiator_num_steps]\
    \ = cJSON_CreateObject();\n+    cJSON_AddIntegerToObject(jsonl_initiator_steps[initiator_num_steps],\
    \ RTT_STEP_MODE, step->step_mode);\n+    cJSON_AddIntegerToObject(jsonl_initiator_steps[initiator_num_steps],\
    \ RTT_STEP_CHANNEL, step->step_channel);\n+    cJSON_AddIntegerToObject(jsonl_initiator_steps[initiator_num_steps],\
    \ RTT_STEP_NADM, step->data.meas_rtt.nadm);\n+    cJSON_AddIntegerToObject(jsonl_initiator_steps[initiator_num_steps],\
    \ RTT_STEP_RSSI, step->data.meas_rtt.rssi);\n+    cJSON_AddIntegerToObject(jsonl_initiator_steps[initiator_num_steps],\
    \ RTT_STEP_TOD_TOA, step->data.meas_rtt.tod_toa);\n+    cJSON_AddIntegerToObject(jsonl_initiator_steps[initiator_num_steps],\
    \ RTT_STEP_ANTENNA, step->data.meas_rtt.antenna);\n+    cJSON_AddIntegerToObject(jsonl_initiator_steps[initiator_num_steps],\
    \ RTT_STEP_PACKET_QUALITY,\n+                             step->data.meas_rtt.packet_quality);\n\
    +    app_log_debug(\" %02d: initiator rtt step stored.\" APP_LOG_NL, initiator_num_steps);\n\
    +    initiator_num_steps++;\n+  } else {\n+    jsonl_reflector_steps[reflector_num_steps]\
    \ = cJSON_CreateObject();\n+    cJSON_AddIntegerToObject(jsonl_reflector_steps[reflector_num_steps],\
    \ RTT_STEP_MODE, step->step_mode);\n+    cJSON_AddIntegerToObject(jsonl_reflector_steps[reflector_num_steps],\
    \ RTT_STEP_CHANNEL, step->step_channel);\n+    cJSON_AddIntegerToObject(jsonl_reflector_steps[reflector_num_steps],\
    \ RTT_STEP_NADM, step->data.meas_rtt.nadm);\n+    cJSON_AddIntegerToObject(jsonl_reflector_steps[reflector_num_steps],\
    \ RTT_STEP_RSSI, step->data.meas_rtt.rssi);\n+    cJSON_AddIntegerToObject(jsonl_reflector_steps[reflector_num_steps],\
    \ RTT_STEP_TOD_TOA, step->data.meas_rtt.tod_toa);\n+    cJSON_AddIntegerToObject(jsonl_reflector_steps[reflector_num_steps],\
    \ RTT_STEP_ANTENNA, step->data.meas_rtt.antenna);\n+    cJSON_AddIntegerToObject(jsonl_reflector_steps[reflector_num_steps],\
    \ RTT_STEP_PACKET_QUALITY,\n+                             step->data.meas_rtt.packet_quality);\n\
    +    app_log_debug(\" %02d: reflector rtt step stored.\" APP_LOG_NL, reflector_num_steps);\n\
    +    reflector_num_steps++;\n+  }\n+}\n+\n+static void store_rtp_step(abr_role_t\
    \ role, cs_step_t * step)\n+{\n+  cJSON *pct_i_array = cJSON_CreateFloatArray(step->data.meas_rtp.pct_i,\
    \ ANTENNA_PERMUTATION_MAX);\n+  cJSON *pct_q_array = cJSON_CreateFloatArray(step->data.meas_rtp.pct_q,\
    \ ANTENNA_PERMUTATION_MAX);\n+\n+  int tone_quality_iter;\n+  int tone_quality[ANTENNA_PERMUTATION_MAX];\n\
    +\n+  for (tone_quality_iter = 0; tone_quality_iter < ANTENNA_PERMUTATION_MAX;\
    \ tone_quality_iter++) {\n+    tone_quality[tone_quality_iter] = step->data.meas_rtp.tone_quality[tone_quality_iter];\n\
    +  }\n+\n+  cJSON *tone_quality_array = cJSON_CreateIntArray(tone_quality, ANTENNA_PERMUTATION_MAX);\n\
    +\n+  if (role == ABR_DEVICE_INITIATOR) {\n+    jsonl_initiator_steps[initiator_num_steps]\
    \ = cJSON_CreateObject();\n+    cJSON_AddIntegerToObject(jsonl_initiator_steps[initiator_num_steps],\
    \ RTP_STEP_MODE, step->step_mode);\n+    cJSON_AddIntegerToObject(jsonl_initiator_steps[initiator_num_steps],\
    \ RTP_STEP_CHANNEL, step->step_channel);\n+    cJSON_AddIntegerToObject(jsonl_initiator_steps[initiator_num_steps],\
    \ RTP_STEP_ANTENNA_PERMUTATION_INDEX, step->data.meas_rtp.antenna_permutation_index);\n\
    +    cJSON_AddItemToObject(jsonl_initiator_steps[initiator_num_steps], RTP_STEP_PCT_I,\
    \ pct_i_array);\n+    cJSON_AddItemToObject(jsonl_initiator_steps[initiator_num_steps],\
    \ RTP_STEP_PCT_Q, pct_q_array);\n+    cJSON_AddItemToObject(jsonl_initiator_steps[initiator_num_steps],\
    \ RTP_STEP_TONE_QUALITY, tone_quality_array);\n+    app_log_debug(\" %02d: initiator\
    \ rtp step stored.\" APP_LOG_NL, initiator_num_steps);\n+    initiator_num_steps++;\n\
    +  } else {\n+    jsonl_reflector_steps[reflector_num_steps] = cJSON_CreateObject();\n\
    +    cJSON_AddIntegerToObject(jsonl_reflector_steps[reflector_num_steps], RTP_STEP_MODE,\
    \ step->step_mode);\n+    cJSON_AddIntegerToObject(jsonl_reflector_steps[reflector_num_steps],\
    \ RTP_STEP_CHANNEL, step->step_channel);\n+    cJSON_AddIntegerToObject(jsonl_reflector_steps[reflector_num_steps],\
    \ RTP_STEP_ANTENNA_PERMUTATION_INDEX, step->data.meas_rtp.antenna_permutation_index);\n\
    +    cJSON_AddItemToObject(jsonl_reflector_steps[reflector_num_steps], RTP_STEP_PCT_I,\
    \ pct_i_array);\n+    cJSON_AddItemToObject(jsonl_reflector_steps[reflector_num_steps],\
    \ RTP_STEP_PCT_Q, pct_q_array);\n+    cJSON_AddItemToObject(jsonl_reflector_steps[reflector_num_steps],\
    \ RTP_STEP_TONE_QUALITY, tone_quality_array);\n+    app_log_debug(\" %02d: reflector\
    \ rtp step stored.\" APP_LOG_NL, reflector_num_steps);\n+    reflector_num_steps++;\n\
    +  }\n+}\n+\n+/******************************************************************************\n\
    + * ABR file log finalize measurement section\n+ * Gets all the initiator and\
    \ reflector data and stores in together with the\n+ * estimated distance to the\
    \ target log file.\n+ *****************************************************************************/\n\
    +sl_status_t abr_file_log_finalize_measurement_section(float *estimated_distance)\n\
    +{\n+  sl_status_t sc = SL_STATUS_OK;\n+  char *raw_content = NULL;\n+  int written_bytes\
    \ = 0;\n+  int i = 0, max_iteration = 1;\n+\n+#if (ABR_FILE_LOG_CFG_RETRY_FPRINTF\
    \ && (ABR_FILE_LOG_CFG_RETRY_FPRINTF_COUNT > 1))\n+  max_iteration = ABR_FILE_LOG_CFG_RETRY_FPRINTF_COUNT;\n\
    +#endif // (ABR_FILE_LOG_CFG_RETRY_FPRINTF && (ABR_FILE_LOG_CFG_RETRY_FPRINTF_COUNT\
    \ > 0))\n+\n+  cJSON *initiator_section = cJSON_CreateObject();\n+  cJSON *reflector_section\
    \ = cJSON_CreateObject();\n+  cJSON *measurement_section = cJSON_CreateObject();\n\
    +\n+  app_log_info(\"Log measurement cycle %04u ...\" APP_LOG_NL, measurement_cycle);\n\
    +\n+  sc = abr_file_log_append_device_section(ABR_DEVICE_INITIATOR, initiator_section);\n\
    +  sc = abr_file_log_append_device_section(ABR_DEVICE_REFLECTOR, reflector_section);\n\
    +\n+  cJSON_AddDoubleToObject(measurement_section, MEAS_ESTIMATED_DISTANCE, *estimated_distance);\n\
    +  cJSON_AddItemToObject(measurement_section, MEAS_INITIATOR_BEGIN, initiator_section);\n\
    +  cJSON_AddItemToObject(measurement_section, MEAS_REFLECTOR_BEGIN, reflector_section);\n\
    +\n+  if (sc == SL_STATUS_OK) {\n+    if (ABR_FILE_LOG_CFG_FORMATTED_PRINT) {\n\
    +      raw_content = cJSON_Print(measurement_section);\n+    } else {\n+     \
    \ raw_content = cJSON_PrintUnformatted(measurement_section);\n+    }\n+    //\
    \ Free up the memory - kill all the subsections to start fresh\n+    cJSON_Delete(measurement_section);\n\
    +\n+    if (!file_conflict) {\n+      app_log_debug(\"Opening file \\'%s\\' to\
    \ write\" APP_LOG_NL, jsonl_filename);\n+      jsonl_file = fopen(jsonl_filename,\
    \ \"a\");\n+      if (jsonl_file == NULL) {\n+        app_log_error(\"Unable to\
    \ open file for write.\" APP_LOG_NL);\n+        app_log_error(\"Logger non-functional!\"\
    \ APP_LOG_NL);\n+        sc = SL_STATUS_NULL_POINTER;\n+      } else {\n+    \
    \    app_log_debug(\"Trying to print raw content into file...\" APP_LOG_NL);\n\
    +        for (i = 0; i < max_iteration; i++) {\n+          if (ABR_FILE_LOG_CFG_FORCE_ADD_NEWLINE\
    \ == 1) {\n+            written_bytes = fprintf(jsonl_file, \"%s\" ABR_FILE_LOG_CFG_NL,\
    \ raw_content);\n+          } else {\n+            written_bytes = fprintf(jsonl_file,\
    \ \"%s\", raw_content);\n+          }\n+          if (written_bytes >= 0) {\n\
    +            app_log_debug(\"Printed %d bytes to the filestream.\" APP_LOG_NL,\
    \ written_bytes);\n+            fclose(jsonl_file);\n+            break;\n+  \
    \        } else {\n+            if (max_iteration > 1) {\n+              app_log_warning(\"\
    Retrying...\" APP_LOG_NL);\n+            }\n+            sc = SL_STATUS_FAIL;\n\
    +          }\n+        }\n+        if (sc == SL_STATUS_FAIL) {\n+          app_log_error(\"\
    Retried %d times. Check file write permissions or\", ABR_FILE_LOG_CFG_RETRY_FPRINTF_COUNT);\n\
    +          app_log_error(\"that the file is not in use anywhere else!\" APP_LOG_NL);\n\
    +        }\n+      }\n+    }\n+  } else {\n+    app_log_error(\"Cannot open file\
    \ to avoid data loss!\" APP_LOG_NL);\n+    app_log_error(\"Logger non-functional!\"\
    \ APP_LOG_NL);\n+    sc = SL_STATUS_FAIL;\n+  }\n+\n+  // Prepare for the next\
    \ measurement cycle\n+  if (sc == SL_STATUS_OK) {\n+    measurement_cycle++;\n\
    +    app_log_debug(\"Measurement cycle %04u starts\" APP_LOG_NL, measurement_cycle);\n\
    +    initiator_num_events = 0;\n+    reflector_num_events = 0;\n+    initialize_cjson_buffers(ABR_DEVICE_INITIATOR);\n\
    +    initialize_cjson_buffers(ABR_DEVICE_REFLECTOR);\n+  }\n+\n+  return sc;\n\
    +}\n+\n+// -----------------------------------------------------------------------------\n\
    +// Private function definitions\n+\n+static void initialize_cjson_buffers(abr_role_t\
    \ role)\n+{\n+  int i;\n+  if (role == ABR_DEVICE_INITIATOR) {\n+    for (i =\
    \ 0; i < ABR_FILE_LOG_CFG_MAX_EVENTS; i++) {\n+      jsonl_initiator_events[i]\
    \ = cJSON_CreateObject();\n+    }\n+    for (i = 0; i < ABR_FILE_LOG_CFG_MAX_STEPS;\
    \ i++) {\n+      jsonl_initiator_steps[i] = cJSON_CreateObject();\n+    }\n+ \
    \ } else {\n+    for (i = 0; i < ABR_FILE_LOG_CFG_MAX_EVENTS; i++) {\n+      jsonl_reflector_events[i]\
    \ = cJSON_CreateObject();\n+    }\n+    for (i = 0; i < ABR_FILE_LOG_CFG_MAX_STEPS;\
    \ i++) {\n+      jsonl_reflector_steps[i] = cJSON_CreateObject();\n+    }\n+ \
    \ }\n+}\n+\n+/******************************************************************************\n\
    + * Append the channel_map to the header\n+ *****************************************************************************/\n\
    +static sl_status_t append_channel_map(cJSON * const jsonl,\n+               \
    \                       const uint8_t * data,\n+                             \
    \         const uint32_t data_len)\n+{\n+  sl_status_t sc = SL_STATUS_OK;\n+ \
    \ char *channel_map_string;\n+  uint32_t string_memsize;\n+  int memory_position\
    \ = 0, written_bytes = 0;\n+\n+  string_memsize = (data_len * 2) + 1;\n+\n+  if\
    \ ((string_memsize > 0) && (string_memsize < UINT32_MAX)) {\n+    app_log_debug(\"\
    Allocate %d bytes for the channel map.\" APP_LOG_NL, string_memsize);\n+    //\
    \ Avoiding resonance cascase \u03BB\n+    channel_map_string = calloc(string_memsize,\
    \ sizeof(char));\n+    if (channel_map_string != NULL) {\n+      app_log_debug(\"\
    Allocated %d bytes of heap.\" APP_LOG_NL, string_memsize);\n+      // Copy channel\
    \ map to the string\n+      for (int i = 0; i < data_len; i++) {\n+        written_bytes\
    \ = sprintf(&channel_map_string[memory_position], \"%02x\", data[i]);\n+     \
    \   memory_position += written_bytes;\n+      }\n+      cJSON_AddStringToObject(jsonl,\
    \ HDR_CH_MAP, channel_map_string);\n+      // Free memory only if allocated before\n\
    +      free(channel_map_string);\n+    } else {\n+      app_log_critical(\"Memory\
    \ allocation failed! Cannot proceed!\" APP_LOG_NL);\n+      sc = SL_STATUS_ALLOCATION_FAILED;\n\
    +    }\n+  } else {\n+    app_log_error(\"Invalid parameter for data_len=%d!\"\
    \ APP_LOG_NL, data_len);\n+    sc = SL_STATUS_ALLOCATION_FAILED;\n+  }\n+  return\
    \ sc;\n+}\n+\n+/******************************************************************************\n\
    + * Append the steps info to the event jsonl object\n+ * Such as:\n+ * - num_steps:\
    \ size of the steps array\n+ * - steps: the steps array reference itself\n+ *****************************************************************************/\n\
    +static sl_status_t append_steps_to_event_header(cJSON **actual_event,\n+    \
    \                                            const uint32_t num_steps,\n+    \
    \                                            cJSON **steps_array,\n+         \
    \                                       const uint32_t array_size)\n+{\n+  sl_status_t\
    \ sc = SL_STATUS_OK;\n+  int i;\n+  if ((*actual_event != NULL) && (*steps_array\
    \ != NULL)  \\\n+      && (actual_event != NULL) && (steps_array != NULL) \\\n\
    +      && (num_steps != 0) && (array_size != 0)) {\n+    cJSON_AddIntegerToObject(*actual_event,\
    \ MEAS_NUM_STEPS, num_steps);\n+    // Copy all non-empty steps into a temporary\
    \ array and add it to the actual\n+    // event\n+    cJSON *temp_array = cJSON_CreateArray();\n\
    +    for (i = 0; i < array_size; i++) {\n+      if (steps_array[i] != NULL) {\n\
    +        cJSON_AddItemToArray(temp_array, steps_array[i]);\n+        app_log_debug(\"\
    step %02d/%02d: %s\" APP_LOG_NL, i, num_steps, cJSON_PrintUnformatted(steps_array[i]));\n\
    +      } else {\n+        app_log_error(\"step %02d is null-pointer!\" APP_LOG_NL,\
    \ i);\n+      }\n+    }\n+    cJSON_AddItemToObject(*actual_event, MEAS_STEPS_ARRAY,\
    \ temp_array);\n+    app_log_debug(\"new event: %s\" APP_LOG_NL, cJSON_PrintUnformatted(*actual_event));\n\
    +  } else {\n+    app_log_error(\"Invalid input parameter!\" APP_LOG_NL);\n+ \
    \   sc = SL_STATUS_NULL_POINTER;\n+  }\n+  app_log_debug(\"%02d steps assigned.\"\
    \ APP_LOG_NL, num_steps);\n+  return sc;\n+}\n+\n+/******************************************************************************\n\
    + * Append the current time string to a cjson object\n+ *****************************************************************************/\n\
    +static void append_current_time(cJSON * const jsonl, abr_file_log_clocktype_t\
    \ clock)\n+{\n+  struct timespec current_timestamp, current_timestamp_rt;\n+\n\
    +  double tstamp = 0.0, tstamp_realtime = 0.0;\n+  char timestamp_string[TIME_STRLEN],\
    \ timestamp_string_rt[TIME_STRLEN];\n+\n+  if (clock == both_clocks || clock ==\
    \ monotonic_clock) {\n+    clock_gettime(CLOCK_MONOTONIC, &current_timestamp);\n\
    +    if (ABR_FILE_LOG_CFG_NUMERIC_TIMESTAMPS == 1) {\n+      tstamp = ((double)current_timestamp.tv_sec\
    \ + (double)current_timestamp.tv_nsec * NANOSEC_DIVIDER);\n+      cJSON_AddDoubleToObject(jsonl,\
    \ HDR_TIMESTAMP, tstamp);\n+    } else {\n+      snprintf(timestamp_string, TIME_STRLEN,\
    \ \"%lld.%.9ld\",\n+               (long long)current_timestamp.tv_sec, current_timestamp.tv_nsec);\n\
    +      cJSON_AddStringToObject(jsonl, HDR_TIMESTAMP, timestamp_string);\n+   \
    \ }\n+  }\n+\n+  if (clock == both_clocks || clock == realtime_clock) {\n+   \
    \ clock_gettime(CLOCK_REALTIME, &current_timestamp_rt);\n+    if (ABR_FILE_LOG_CFG_NUMERIC_TIMESTAMPS\
    \ == 1) {\n+      tstamp_realtime = ((double)current_timestamp_rt.tv_sec + (double)current_timestamp_rt.tv_nsec\
    \ * NANOSEC_DIVIDER);\n+      cJSON_AddDoubleToObject(jsonl, HDR_TIMESTAMP_REALTIME,\
    \ tstamp_realtime);\n+    } else {\n+      snprintf(timestamp_string_rt, TIME_STRLEN,\
    \ \"%lld.%.9ld\",\n+               (long long)current_timestamp_rt.tv_sec, current_timestamp_rt.tv_nsec);\n\
    +      cJSON_AddStringToObject(jsonl, HDR_TIMESTAMP_REALTIME, timestamp_string_rt);\n\
    +    }\n+  }\n+}\n+\n+/******************************************************************************\n\
    + * ABR file log append device section\n+ * This function gathers all the information\
    \ required for the selected device.\n+ * Such as:\n+ * - initiator subevents:\n\
    + *   \\_num_events: number of elements the 'events ' array has\n+ *   \\_events[]:\
    \ events array\n+ *     \\_start_acl_conn_event: event identifier\n+ *     \\\
    _timestamp: when the event processed\n+ *     \\_num_steps: number of elements\
    \ the 'steps ' array has\n+ *     \\_steps[]: actual steps in the event\n+ *****************************************************************************/\n\
    +static sl_status_t abr_file_log_append_device_section(abr_role_t role, cJSON\
    \ * target_section)\n+{\n+  sl_status_t sc = SL_STATUS_OK;\n+  int i;\n+  if (role\
    \ == ABR_DEVICE_INITIATOR) {\n+    if ((target_section == NULL) || (jsonl_initiator_events[initiator_num_events]\
    \ == NULL)) {\n+      app_log_critical(\"Can not create initiator device cJSON\
    \ object!\" APP_LOG_NL);\n+      app_log_critical(\"ABR file logger is not functional!\"\
    \ APP_LOG_NL);\n+      sc = SL_STATUS_NULL_POINTER;\n+    } else {\n+      cJSON\
    \ * final_initiator_events = cJSON_CreateArray();\n+      for (i = 0; i < initiator_num_events;\
    \ i++) {\n+        if (jsonl_initiator_events[i] != NULL) {\n+          cJSON_AddItemToArray(final_initiator_events,\
    \ jsonl_initiator_events[i]);\n+        } else {\n+          app_log_error(\"\
    initiator EVENT %02d lost!\" APP_LOG_NL, i);\n+        }\n+      }\n+      cJSON_AddIntegerToObject(target_section,\
    \ MEAS_NUM_EVENTS, initiator_num_events);\n+      cJSON_AddItemToObject(target_section,\
    \ MEAS_EVENTS_ARRAY, final_initiator_events);\n+      app_log_debug(\"Appended\
    \ %d events to initiator section successfully:\" APP_LOG_NL, initiator_num_events);\n\
    +      app_log_debug(\"%s\" APP_LOG_NL, cJSON_PrintUnformatted(final_initiator_events));\n\
    +    }\n+  } else {\n+    if ((target_section == NULL) || (jsonl_reflector_events[reflector_num_events]\
    \ == NULL)) {\n+      app_log_critical(\"Can not create reflector device cJSON\
    \ object!\" APP_LOG_NL);\n+      app_log_critical(\"ABR file logger is not functional!\"\
    \ APP_LOG_NL);\n+      sc = SL_STATUS_NULL_POINTER;\n+    } else {\n+      cJSON\
    \ * final_reflector_events = cJSON_CreateArray();\n+      for (i = 0; i < reflector_num_events;\
    \ i++) {\n+        if (jsonl_reflector_events[i] != NULL) {\n+          cJSON_AddItemToArray(final_reflector_events,\
    \ jsonl_reflector_events[i]);\n+        } else {\n+          app_log_error(\"\
    reflector EVENT %02d lost!\" APP_LOG_NL, i);\n+        }\n+      }\n+      cJSON_AddIntegerToObject(target_section,\
    \ MEAS_NUM_EVENTS, reflector_num_events);\n+      cJSON_AddItemToObject(target_section,\
    \ MEAS_EVENTS_ARRAY, final_reflector_events);\n+      app_log_debug(\"Appended\
    \ %d events to reflector section successfully:\" APP_LOG_NL, reflector_num_events);\n\
    +      app_log_debug(\"%s\" APP_LOG_NL, cJSON_PrintUnformatted(final_reflector_events));\n\
    +    }\n+  }\n+  return sc;\n+}\n+\n+#if (ABR_FILE_LOG_CFG_KEEP_OLD_FILES == 1)\n\
    +/******************************************************************************\n\
    + * Check file existance\n+ * Opens the target file to read, and if it can be\
    \ opened it does exist.\n+ *****************************************************************************/\n\
    +static bool fexist(const char* filename)\n+{\n+  bool r = true;\n+  FILE *file;\n\
    +\n+  file = fopen(filename, \"r\");\n+  if (file == NULL) {\n+    r = false;\n\
    +  } else {\n+    fclose(file);\n+  }\n+  return r;\n+}\n+#endif // (ABR_FILE_LOG_CFG_KEEP_OLD_FILES\
    \ == 1)\n+\n+/******************************************************************************\n\
    + * Setter for the json filename\n+ * Function considers the measurement mode\
    \ and if configured appends a postfix\n+ * accordingly. In case the file already\
    \ exist the function handles the\n+ * conflict according to the configuration\
    \ too:\n+ * - if the old file must be kept instead of overwriting, the function\
    \ will\n+ *   append a postfix to the file-extension according to the configuration\n\
    + * - if the old file cannot be renamed the function indicates by text\n+ *  \
    \ message (app_log call) and with the return value the logger should\n+ *   not\
    \ function to avoid the data loss\n+ * - if old files should not be considered\
    \ it will overwrite an existing file\n+ *****************************************************************************/\n\
    +static sl_status_t set_filename(uint8_t measurement_mode)\n+{\n+  sl_status_t\
    \ sc = SL_STATUS_OK;\n+#if (ABR_FILE_LOG_CFG_KEEP_OLD_FILES == 1)\n+  bool already_exist\
    \ = false;\n+  int ret = 1;\n+  time_t raw_time;\n+  struct tm *time_info;\n+\
    \  char time_string[TIME_STRLEN] = \"\";\n+  char backup_filename[FILENAME_STRLEN]\
    \ = \"\";\n+#endif // (ABR_FILE_LOG_CFG_KEEP_OLD_FILES == 1)\n+\n+  // initialize\
    \ the filename string before any action\n+  memset(jsonl_filename, '\\0', FILENAME_STRLEN);\n\
    +  // return value ignored by strcat() calls because only the pointer to\n+  //\
    \ the first parameter is retured - that is already known\n+  (void)strcat(jsonl_filename,\
    \ ABR_FILE_LOG_CFG_FILENAME);\n+\n+  if (ABR_FILE_LOG_CFG_MEAS_TYPE_POSTFIX_ENABLE)\
    \ {\n+    if (measurement_mode == sl_bt_cs_mode_pbr) {\n+      (void)strcat(jsonl_filename,\
    \ ABR_FILE_LOG_CFG_PBS_POSTFIX);\n+    } else if (measurement_mode == sl_bt_cs_mode_rtt)\
    \ {\n+      (void)strcat(jsonl_filename, ABR_FILE_LOG_CFG_RTT_POSTFIX);\n+   \
    \ } else {\n+      app_log_warning(\"Unknown measurement mode: 0x%x\" APP_LOG_NL,\
    \ measurement_mode);\n+      app_log_warning(\"Could not append mode postfix to\
    \ filename!\" APP_LOG_NL);\n+    }\n+  }\n+  // append extension\n+  (void)strcat(jsonl_filename,\
    \ FILE_EXTENSION);\n+\n+#if (ABR_FILE_LOG_CFG_KEEP_OLD_FILES == 1)\n+  already_exist\
    \ = fexist(jsonl_filename);\n+  if (already_exist) {\n+    app_log_warning(\"\
    %s already exist!\" APP_LOG_NL, jsonl_filename);\n+\n+    // load filename & append\
    \ backup postfix\n+    (void)snprintf(backup_filename, sizeof(jsonl_filename),\
    \ \"%s\", jsonl_filename);\n+    (void)strcat(backup_filename, ABR_FILE_LOG_CFG_BACKUP_POSTFIX);\n\
    +\n+    // append datetime in format: 09-11-2023-12_45_34\n+    time(&raw_time);\n\
    +    time_info = localtime(&raw_time);\n+\n+    sprintf(time_string, \"%01d-%01d-%d-%01d_%01d_%01d\"\
    ,\n+            time_info->tm_mday, time_info->tm_mon + 1, time_info->tm_year\
    \ + 1900,\n+            time_info->tm_hour, time_info->tm_min, time_info->tm_sec);\n\
    +\n+    //example: old.jsnl --> old.jsonl_bkp09-11-2023-12:45:34\n+    (void)strcat(backup_filename,\
    \ time_string);\n+\n+    app_log_warning(\"Renaming %s --> %s\" APP_LOG_NL, jsonl_filename,\
    \ backup_filename);\n+    // try to rename the old file\n+    ret = rename(jsonl_filename,\
    \ backup_filename);\n+    if (ret == 0) {\n+      app_log_info(\"Renamed successfully.\"\
    \ APP_LOG_NL);\n+    } else {\n+      app_log_error(\"Unable to rename file! (code:\
    \ 0x%x)\" APP_LOG_NL, ret);\n+      app_log_error(\"Logger WILL NOT START to avoid\
    \ data loss!\" APP_LOG_NL);\n+      sc = SL_STATUS_FAIL;\n+    }\n+  }\n+#endif\
    \ // (ABR_FILE_LOG_CFG_KEEP_OLD_FILES == 1)\n+\n+  return sc;\n+}\n+\n+#endif\
    \ // defined(HOST_TOOLCHAIN) && (ABR_FILE_LOG_ENABLED == 1)"
  - '--- a/app/bluetooth/common/abr_initiator/abr_initiator.c

    +++ b/app/bluetooth/common/abr_initiator/abr_initiator.c

    @@ -0,0 +1,688 @@

    +/*******************************************************************************

    + * @file

    + * @brief ABR initiator

    + *******************************************************************************

    + * # License

    + * <b>Copyright 2022-2023 Silicon Laboratories Inc. www.silabs.com</b>

    + *******************************************************************************

    + *

    + * SPDX-License-Identifier: Zlib

    + *

    + * The licensor of this software is Silicon Laboratories Inc.

    + *

    + * This software is provided ''as-is'', without any express or implied

    + * warranty. In no event will the authors be held liable for any damages

    + * arising from the use of this software.

    + *

    + * Permission is granted to anyone to use this software for any purpose,

    + * including commercial applications, and to alter it and redistribute it

    + * freely, subject to the following restrictions:

    + *

    + * 1. The origin of this software must not be misrepresented; you must not

    + *    claim that you wrote the original software. If you use this software

    + *    in a product, an acknowledgment in the product documentation would be

    + *    appreciated but is not required.

    + * 2. Altered source versions must be plainly marked as such, and must not be

    + *    misrepresented as being the original software.

    + * 3. This notice may not be removed or altered from any source distribution.

    + *

    + ******************************************************************************/

    +

    +#include <stdbool.h>

    +#include <time.h>

    +#include <math.h>

    +

    +#include "sl_bt_api.h"

    +#include "sl_common.h"

    +#include "abr_initiator.h"

    +#include "app_log.h"

    +#include "app_assert.h"

    +#include "abr_cs_parser.h"

    +#include "abr_initiator_interface.h"

    +#include "abr_initiator_config.h"

    +

    +#include "sl_rtl_clib_api.h"

    +

    +/// Discovering services/characteristics and subscribing raises procedure_complete
    events

    +/// Actions are used to indicate which procedure was completed.

    +typedef enum {

    +  act_none = 0,

    +  act_discover_service,

    +  act_discover_characteristics,

    +  act_subscribe_result

    +} action_t;

    +

    +static abr_initiator_config_t *initiator_config;

    +static const char *device_name = INITIATOR_DEVICE_NAME; // Device name to match
    against scan results.

    +

    +static bool characteristic_found;

    +static sl_bt_cs_channel_map_t channel_map;

    +

    +static uint8_t connection_handle = SL_BT_INVALID_CONNECTION_HANDLE;

    +static uint32_t service_handle = 0xFFFFFFFF;

    +static uint16_t result_handle = 0xFFFF;

    +static action_t action = act_none;

    +

    +// bbb99e70-fff7-46cf-abc7-2d32c71820f2

    +const uint8_t service_uuid[] = INITIATOR_SERVICE_UUID;

    +

    +// 929f95ec-1391-4303-9b49-3c22a418be91

    +const uint8_t result_characteristic_uuid[] = INITIATOR_CHARACTERISTIC_UUID;

    +

    +static bool initiator_process_scan_response(sl_bt_evt_scanner_scan_report_t *response);

    +static void initiator_scanning_start(void);

    +static void check_characteristic_uuid(sl_bt_msg_t *evt);

    +static void process_procedure_complete_event(sl_bt_msg_t *evt);

    +static void initiator_calculate_distance(uint8_t connection);

    +static void abr_initiator_perform_procedure(void);

    +static void abr_initiator_create_config(void);

    +static void rtl_library_init(sl_rtl_abr_libitem *handle, uint8_t abr_mode);

    +

    +#ifdef DEBUG_MODE

    +FILE *initiator_statistics_file, *reflector_statistics_file;

    +struct timespec bt_event_timestamp;

    +#endif

    +

    +/******************************************************************************

    + * ABR initiator set initial config.

    + *****************************************************************************/

    +void abr_initiator_set_initial_state(abr_initiator_config_t *config)

    +{

    +  initiator_config = config;

    +  initiator_config->discovery_state = ABR_DISCOVERY_STATE_IDLE;

    +}

    +

    +/******************************************************************************

    + * Bluetooth stack event handler.

    + * This overrides the dummy weak implementation.

    + *****************************************************************************/

    +void bt_on_event_initiator(sl_bt_msg_t *evt)

    +{

    +  sl_status_t sc;

    +

    +  switch (SL_BT_MSG_ID(evt->header)) {

    +    case sl_bt_evt_scanner_scan_report_id:

    +      if (initiator_process_scan_response(&(evt->data.evt_scanner_scan_report)))
    {

    +        // Stop scanning

    +        sc = sl_bt_scanner_stop();

    +        app_assert_status(sc);

    +

    +        initiator_config->discovery_state = ABR_DISCOVERY_STATE_CONN;

    +

    +        if (initiator_config->phy != sl_bt_gap_phy_coding_1m_uncoded) {

    +          app_log_warning("Connection PHY is not supported and set to 1M PHY"
    APP_LOG_NL);

    +          initiator_config->phy = sl_bt_gap_phy_coding_1m_uncoded;

    +        }

    +

    +        if (connection_handle == SL_BT_INVALID_CONNECTION_HANDLE) {

    +          app_log_info("Opening connection to Reflector" APP_LOG_NL);

    +          sc = sl_bt_connection_open(evt->data.evt_scanner_scan_report.address,

    +                                     evt->data.evt_scanner_scan_report.address_type,

    +                                     initiator_config->phy,

    +                                     &connection_handle);

    +          app_assert_status(sc);

    +        }

    +      } else {

    +        waiting_indication();

    +      }

    +      break;

    +    case sl_bt_evt_connection_opened_id:

    +      app_log_info("Connection opened to the Reflector" APP_LOG_NL);

    +      platform_display_state(ABR_STATE_CONNECTED);

    +      //Encrypt link

    +      app_log_info("Encrypting connection" APP_LOG_NL);

    +      sc = sl_bt_sm_increase_security(connection_handle);

    +      app_assert_status(sc);

    +

    +      // Request connection parameter update.

    +      sc = sl_bt_connection_set_parameters(connection_handle,

    +                                           initiator_config->min_connection_interval,

    +                                           initiator_config->max_connection_interval,

    +                                           initiator_config->latency,

    +                                           initiator_config->timeout,

    +                                           initiator_config->min_ce_length,

    +                                           initiator_config->max_ce_length);

    +

    +      app_assert_status(sc);

    +

    +      break;

    +    case sl_bt_evt_connection_parameters_id:

    +      if (evt->data.evt_connection_parameters.security_mode == 1) {

    +        app_log_info("Connection encrypted" APP_LOG_NL);

    +        sc = sl_bt_gatt_discover_primary_services_by_uuid(connection_handle,

    +                                                          UUID_LEN,

    +                                                          service_uuid);

    +        app_assert_status(sc);

    +        characteristic_found = false;

    +      }

    +      break;

    +    case sl_bt_evt_gatt_procedure_completed_id:

    +      process_procedure_complete_event(evt);

    +      break;

    +    case sl_bt_evt_gatt_characteristic_id:

    +      check_characteristic_uuid(evt);

    +      break;

    +    case sl_bt_evt_gatt_service_id:

    +      if (evt->data.evt_gatt_service.uuid.len == UUID_LEN) {

    +        if (memcmp(service_uuid, evt->data.evt_gatt_service.uuid.data, UUID_LEN)
    == 0) {

    +          service_handle = evt->data.evt_gatt_service.service;

    +          action = act_discover_service;

    +          app_log_info("Service found" APP_LOG_NL);

    +        }

    +      }

    +      break;

    +    case sl_bt_evt_gatt_characteristic_value_id:

    +      app_log_debug("Received new measurement data from the reflector" APP_LOG_NL);

    +

    +#ifdef DEBUG_MODE

    +      reflector_statistics_file = fopen("reflector_stats.txt", "w");

    +      app_assert(reflector_statistics_file != NULL, "Failed opening file");

    +      clock_gettime(CLOCK_MONOTONIC, &bt_event_timestamp);

    +      fprintf(reflector_statistics_file, "%li:%li %s\n", bt_event_timestamp.tv_sec,
    bt_event_timestamp.tv_nsec, "new result");

    +      fclose(reflector_statistics_file);

    +#endif

    +

    +      if (evt->data.evt_gatt_characteristic_value.att_opcode == gatt_handle_value_indication)
    {

    +        // Reflector sends indication about result after each test. Data is uint8array
    LSB first.

    +

    +        sc = sl_bt_gatt_send_characteristic_confirmation(evt->data.evt_gatt_characteristic_value.connection);

    +        app_assert_status(sc);

    +

    +        app_log_debug("Reflector packet %hhu" APP_LOG_NL, evt->data.evt_gatt_characteristic_value.value.len);

    +

    +        struct sl_bt_evt_cs_result_s* result_ptr = (struct sl_bt_evt_cs_result_s*)evt->data.evt_gatt_characteristic_value.value.data;

    +

    +        sl_status_t parse_status = abr_cs_parser_parse_event_result_data(result_ptr,

    +                                                                         ABR_DEVICE_REFLECTOR);

    +        if (parse_status != SL_STATUS_OK) {

    +          app_log_info("Incorrect cs_event_result reflector" APP_LOG_NL);

    +        }

    +

    +        initiator_calculate_distance(result_ptr->connection);

    +

    +        if (abr_cs_parser_procedure_restart_needed(result_ptr->connection)) {

    +          abr_initiator_perform_procedure();

    +        }

    +      }

    +      break;

    +    case  sl_bt_evt_cs_procedure_enable_complete_id:

    +      app_log_debug("Procedure enable complete" APP_LOG_NL);

    +      break;

    +    case sl_bt_evt_cs_config_complete_id:

    +      app_log_info("Config created" APP_LOG_NL);

    +      abr_initiator_perform_procedure();

    +      break;

    +    case sl_bt_evt_cs_result_id:

    +      app_log_debug("Initiator packet %hhu" APP_LOG_NL, evt->data.evt_cs_result.data.len);

    +

    +#ifdef DEBUG_MODE

    +      initiator_statistics_file = fopen("initiator_stats.txt", "w");

    +      app_assert(initiator_statistics_file != NULL, "Failed opening file");

    +      clock_gettime(CLOCK_MONOTONIC, &bt_event_timestamp);

    +      fprintf(initiator_statistics_file, "%li:%li %s\n", bt_event_timestamp.tv_sec,
    bt_event_timestamp.tv_nsec, "new result");

    +      fclose(initiator_statistics_file);

    +#endif

    +

    +      sl_status_t parse_status = abr_cs_parser_parse_event_result_data(&evt->data.evt_cs_result,

    +                                                                       ABR_DEVICE_INITIATOR);

    +      if (parse_status != SL_STATUS_OK) {

    +        app_log_info("Incorrect cs_event_result initiator" APP_LOG_NL);

    +      }

    +

    +      initiator_calculate_distance(evt->data.evt_cs_result.connection);

    +

    +      if (abr_cs_parser_procedure_restart_needed(evt->data.evt_cs_result.connection))
    {

    +        abr_initiator_perform_procedure();

    +      }

    +

    +      break;

    +    case sl_bt_evt_connection_closed_id:

    +      initiator_config->discovery_state = ABR_DISCOVERY_STATE_IDLE;

    +

    +      uint16_t reason = evt->data.evt_connection_closed.reason;

    +      app_log_info("Connection closed to the Reflector %02X" APP_LOG_NL, reason);

    +      platform_display_state(ABR_STATE_DISCONNECTED);

    +      connection_handle = SL_BT_INVALID_CONNECTION_HANDLE;

    +#ifdef DEBUG_MODE

    +      char log_message[100];

    +      sprintf(log_message, "Connection closed to the Reflector %02X", reason);

    +      add_debug_message(log_message);

    +#endif

    +      initiator_scanning_start();

    +      break;

    +    default:

    +      break;

    +  }

    +}

    +

    +/******************************************************************************

    + * ABR initiator create channel-sounding and radio configuration.

    + *****************************************************************************/

    +static void abr_initiator_create_config(void)

    +{

    +  sl_status_t sc;

    +

    +  app_log_info("Creating ABR config..." APP_LOG_NL);

    +

    +  memset(channel_map.data, 0x55, 10);

    +

    +  // Set role

    +  sc = sl_bt_cs_set_default_settings(connection_handle,

    +                                     sl_bt_cs_role_status_enable,

    +                                     sl_bt_cs_role_status_disable,

    +                                     initiator_config->cs_sync_antenna,

    +                                     initiator_config->max_tx_power_dbm);

    +  app_assert_status(sc);

    +

    +  // Enable security.

    +  sc = sl_bt_cs_security_enable(connection_handle);

    +  app_assert_status(sc);

    +

    +  sc = sl_bt_cs_create_config(connection_handle,

    +                              initiator_config->config_id,

    +                              initiator_config->create_context,

    +                              initiator_config->mode,

    +                              initiator_config->submode,

    +                              initiator_config->min_main_mode_steps,

    +                              initiator_config->max_main_mode_steps,

    +                              initiator_config->main_mode_repetition,

    +                              initiator_config->mode0_step,

    +                              sl_bt_cs_role_initiator,

    +                              initiator_config->rtt_type,

    +                              initiator_config->phy,

    +                              &channel_map,

    +                              initiator_config->channel_map_repetition,

    +                              initiator_config->channel_selection_type,

    +                              initiator_config->ch3c_shape,

    +                              initiator_config->ch3c_jump,

    +                              initiator_config->companion_signal_enable);

    +  app_assert_status(sc);

    +

    +  sc = abr_cs_parser_configure(channel_map.data,

    +                               sizeof(channel_map.data) / sizeof(channel_map.data[0]),

    +                               initiator_config->mode0_step);

    +  app_assert_status(sc);

    +}

    +

    +/******************************************************************************

    + * ABR initiator trigger channel-sounding procedure

    + *****************************************************************************/

    +static void abr_initiator_perform_procedure(void)

    +{

    +  sl_status_t sc;

    +

    +  app_log_debug("Starting CS measurement..." APP_LOG_NL);

    +  sc = sl_bt_cs_set_procedure_parameters(connection_handle,

    +                                         initiator_config->config_id,

    +                                         initiator_config->max_procedure_duration,

    +                                         initiator_config->min_interval,

    +                                         initiator_config->max_interval,

    +                                         initiator_config->max_procedure_count,

    +                                         initiator_config->min_subevent_len,

    +                                         initiator_config->max_subevent_len,

    +                                         initiator_config->antenna_config,

    +                                         initiator_config->phy,

    +                                         initiator_config->tx_pwr_delta,

    +                                         initiator_config->preferred_peer_antenna);

    +  app_log_status_warning_f(sc, "Set procedure parameters failed" APP_LOG_NL);

    +

    +  sc = abr_cs_parser_cleanup_measurement(connection_handle);

    +  app_assert_status(sc);

    +  sc = sl_bt_cs_procedure_enable(connection_handle, sl_bt_cs_procedure_state_enabled,
    initiator_config->config_id);

    +  app_log_status_warning_f(sc, "Procedure enable failed" APP_LOG_NL);

    +  app_assert_status(sc);

    +}

    +

    +/******************************************************************************

    + * Init function that sets the first discovery and initiator config

    + * and register the selected callback function pointer as a

    + * callback for the distance measurement.

    + *****************************************************************************/

    +void abr_initiator_init(abr_result_cb_t result_cb,

    +                        abr_initiator_config_t *initiator_config)

    +{

    +  sl_status_t sc;

    +  abr_cs_parser_configuration_t parser_config;

    +  abr_initiator_set_initial_state(initiator_config);

    +  platform_display_state(ABR_STATE_DISCONNECTED);

    +  initiator_config->discovery_state = ABR_DISCOVERY_STATE_IDLE;

    +  initiator_config->result_cb = result_cb;

    +

    +  if (initiator_config->filter_address != NULL) {

    +    app_log_info("Filtering reflectors. Accepting %02x:%02x:%02x:%02x:%02x:%02x"
    APP_LOG_NL,

    +                 initiator_config->filter_address[5],

    +                 initiator_config->filter_address[4],

    +                 initiator_config->filter_address[3],

    +                 initiator_config->filter_address[2],

    +                 initiator_config->filter_address[1],

    +                 initiator_config->filter_address[0]);

    +  }

    +  rtl_library_init(&initiator_config->rtl_handle, initiator_config->mode);

    +  parser_config.measurement_mode = initiator_config->mode;

    +  parser_config.rssi_measurement_enabled = initiator_config->rssi_measurement_enabled;

    +  parser_config.rssi_tx_power = initiator_config->rssi_tx_power;

    +

    +  sc = abr_cs_parser_init(&parser_config);

    +  app_assert_status(sc);

    +}

    +

    +/******************************************************************************

    + * ABR initiator enable functionality

    + *****************************************************************************/

    +void abr_initiator_enable(void)

    +{

    +  sl_status_t sc;

    +  int16_t tx_power_min_dbm, tx_power_max_dbm;

    +

    +  // Convert power to mdBm

    +  int16_t max_power = ( ((int16_t)initiator_config->tx_power_requested_max_dbm)
    * 10);

    +  int16_t min_power = ( ((int16_t)initiator_config->tx_power_requested_max_dbm)
    * 10);

    +  sc = sl_bt_system_set_tx_power(min_power,

    +                                 max_power,

    +                                 &tx_power_min_dbm,

    +                                 &tx_power_max_dbm);

    +  app_assert_status(sc);

    +

    +  // Store the actual power level for later use

    +  initiator_config->tx_power_max_dbm = tx_power_max_dbm / 10;

    +  initiator_config->tx_power_min_dbm = tx_power_min_dbm / 10;

    +

    +  // Check if the PHY is set to 1M. Currently, this is the only supported PHY

    +  if (initiator_config->scan_phy != sl_bt_gap_phy_coding_1m_uncoded) {

    +    initiator_config->scan_phy = sl_bt_gap_phy_coding_1m_uncoded;

    +    app_log_warning("Scanning PHY is not supported and set to 1M PHY" APP_LOG_NL);

    +  }

    +

    +  // Start scanning

    +  sc = sl_bt_scanner_set_parameters(sl_bt_scanner_scan_mode_passive, initiator_config->scan_interval,
    initiator_config->scan_window);

    +  app_assert_status(sc);

    +

    +  initiator_scanning_start();

    +}

    +

    +/******************************************************************************

    + * Start scanning for the reflector device

    + *****************************************************************************/

    +static void initiator_scanning_start(void)

    +{

    +  sl_status_t sc;

    +

    +  app_log_info("Scanning..." APP_LOG_NL);

    +  platform_display_state(ABR_STATE_SCANNING);

    +

    +  // Check if the PHY is set to 1M. Currently, this is the only supported PHY

    +  if (initiator_config->scan_phy != sl_bt_gap_phy_coding_1m_uncoded) {

    +    initiator_config->scan_phy = sl_bt_gap_phy_coding_1m_uncoded;

    +    app_log_warning("Scanning PHY is not supported and set to 1M PHY" APP_LOG_NL);

    +  }

    +

    +  // Start scanning

    +  sc = sl_bt_scanner_set_parameters(sl_bt_scanner_scan_mode_passive, initiator_config->scan_interval,
    initiator_config->scan_window);

    +  app_assert_status(sc);

    +

    +  // Start scanning - looking for peripheral devices

    +  sc = sl_bt_scanner_start(initiator_config->scan_phy, scanner_discover_generic);

    +  app_assert_status(sc);

    +  initiator_config->discovery_state = ABR_DISCOVERY_STATE_SCAN;

    +}

    +

    +/******************************************************************************

    + * Stop scanning for the reflector device

    + *****************************************************************************/

    +void initiator_scanning_stop(void)

    +{

    +  sl_status_t sc;

    +  if (initiator_config->discovery_state == ABR_DISCOVERY_STATE_SCAN) {

    +    sc = sl_bt_scanner_stop();

    +    app_assert_status(sc);

    +    initiator_config->discovery_state = ABR_DISCOVERY_STATE_IDLE;

    +  }

    +}

    +

    +/******************************************************************************

    + * Cycle through advertisement contents and look for the matching device name

    + *****************************************************************************/

    +static bool initiator_process_scan_response(sl_bt_evt_scanner_scan_report_t *response)

    +{

    +  int i = 0;

    +  bool reflector_match = false;

    +  uint8_t advertisement_length;

    +  uint8_t advertisement_type;

    +

    +  while (i < (response->data.len - 1)) {

    +    advertisement_length = response->data.data[i];

    +    advertisement_type = response->data.data[i + 1];

    +

    +    // Type 0x09 = Complete Local Name, 0x08 Shortened Name

    +    if (advertisement_type == INITIATOR_LOCAL_NAME) {

    +      // Check if device name is a mach to device_name

    +      if (memcmp(response->data.data + i + 2, device_name, strlen(device_name))
    == 0) {

    +        reflector_match = true;

    +        break;

    +      }

    +    }

    +    // Jump to next AD record

    +    i = i + advertisement_length + 1;

    +  }

    +

    +  //  Filter reflector

    +  if (initiator_config->filter_address != NULL && 0 != memcmp(initiator_config->filter_address,
    response->address.addr, ADR_LEN)) {

    +    reflector_match = false;

    +  }

    +

    +  return (reflector_match);

    +}

    +

    +/******************************************************************************

    + * Check if the detected characteristic matches the UUIDs that

    + * is required for the ABR functionality

    + *****************************************************************************/

    +static void check_characteristic_uuid(sl_bt_msg_t *evt)

    +{

    +  if (evt->data.evt_gatt_characteristic.uuid.len == UUID_LEN) {

    +    if (memcmp(result_characteristic_uuid, evt->data.evt_gatt_characteristic.uuid.data,
    UUID_LEN) == 0) {

    +      result_handle = evt->data.evt_gatt_characteristic.characteristic;

    +      characteristic_found = true;

    +      app_log_info("Found remote value characteristic" APP_LOG_NL);

    +    }

    +  }

    +}

    +

    +/******************************************************************************

    + * Event handler dedicated for the discovery process:

    + * discovering services on reflector side and checking the characteristics.

    + * Once everything is compatible, triggers the configuration of this initiator

    + * device.

    + *****************************************************************************/

    +static void process_procedure_complete_event(sl_bt_msg_t *evt)

    +{

    +  uint16_t procedure_result =  evt->data.evt_gatt_procedure_completed.result;

    +  sl_status_t sc;

    +

    +  switch (action) {

    +    case act_discover_service:

    +      action = act_none;

    +      app_assert_status(procedure_result);

    +      if (!procedure_result) {

    +        // Discover successful, start characteristic discovery.

    +        sc = sl_bt_gatt_discover_characteristics(connection_handle, service_handle);

    +        app_assert_status(sc);

    +        action = act_discover_characteristics;

    +        app_log_info("Service discovered" APP_LOG_NL);

    +      }

    +      break;

    +    case act_discover_characteristics:

    +      action = act_none;

    +      app_assert_status(procedure_result);

    +      if (!procedure_result) {

    +        if (characteristic_found) {

    +          initiator_config->discovery_state = ABR_DISCOVERY_STATE_FINISHED;

    +          sc = sl_bt_gatt_set_characteristic_notification(connection_handle,
    result_handle, sl_bt_gatt_indication);

    +          app_assert_status(sc);

    +          action = act_subscribe_result;

    +          app_log_info("Characteristic discovered" APP_LOG_NL);

    +        }

    +      }

    +      break;

    +    case act_subscribe_result:

    +      action = act_none;

    +      app_assert_status(procedure_result);

    +      abr_initiator_create_config();

    +      break;

    +    case act_none:

    +      break;

    +    default:

    +      break;

    +  }

    +}

    +

    +/******************************************************************************

    + * Calculate distance between initiator and reflector using RTL library.

    + *

    + * @param[in] connection Connection handle from BLE stack.

    + *****************************************************************************/

    +static void initiator_calculate_distance(uint8_t connection)

    +{

    +  sl_status_t sc;

    +  abr_rtl_result_t result;

    +  enum sl_rtl_error_code rtl_err;

    +  abr_cs_parser_meas_data_t cs_meas_data;

    +  bool restart_procedure = false;

    +  result.distance = 0.0;

    +  result.rssi_distance = 0.0;

    +  memset(&cs_meas_data, 0, sizeof(abr_cs_parser_meas_data_t));

    +

    +  switch (initiator_config->mode) {

    +    case sl_bt_cs_mode_rtt:

    +      sc = abr_cs_parser_get_measurement_data(connection,

    +                                              initiator_config->mode,

    +                                              &cs_meas_data);

    +      if (sc == SL_STATUS_OK) {

    +        // RTT measurement can be processed by RTL lib.

    +        rtl_err = sl_rtl_abr_process_rtt(&initiator_config->rtl_handle,

    +                                         &cs_meas_data.rtt_data);

    +        if (rtl_err == SL_RTL_ERROR_SUCCESS) {

    +          rtl_err = sl_rtl_abr_get_distance(&initiator_config->rtl_handle,

    +                                            &result.distance);

    +        } else {

    +          app_log_warning("Failed to call RTL library!" APP_LOG_NL);

    +        }

    +

    +        if (rtl_err == SL_RTL_ERROR_SUCCESS) {

    +          abr_cs_parser_store_distance(&result.distance);

    +

    +          rtl_err = sl_rtl_util_rssi2distance(initiator_config->rssi_tx_power,

    +                                              cs_meas_data.initiator_calibration_rssi,

    +                                              &result.rssi_distance);

    +          if (rtl_err != SL_RTL_ERROR_SUCCESS) {

    +            app_log_error("Failed to calculate RSSI distance!" APP_LOG_NL);

    +          }

    +

    +          if (initiator_config->result_cb != NULL) {

    +            initiator_config->result_cb(&result, NULL);

    +          }

    +        }

    +        sc = abr_cs_parser_cleanup_measurement(connection);

    +        app_assert_status(sc);

    +

    +        if (initiator_config->max_procedure_count != 0) {

    +          restart_procedure = true;

    +        }

    +      }

    +      break;

    +    case sl_bt_cs_mode_pbr:

    +      sc = abr_cs_parser_get_measurement_data(connection,

    +                                              initiator_config->mode,

    +                                              &cs_meas_data);

    +      if (sc == SL_STATUS_OK) {

    +        // RTP measurement can be processed by RTL lib.

    +        rtl_err = sl_rtl_abr_process_rtp(&initiator_config->rtl_handle,

    +                                         &cs_meas_data.rtp_data);

    +        if (rtl_err == SL_RTL_ERROR_SUCCESS) {

    +          rtl_err = sl_rtl_abr_get_distance(&initiator_config->rtl_handle,

    +                                            &result.distance);

    +        } else {

    +          app_log_warning("Failed to call RTL library!" APP_LOG_NL);

    +        }

    +

    +        if (rtl_err == SL_RTL_ERROR_SUCCESS) {

    +          abr_cs_parser_store_distance(&result.distance);

    +

    +          rtl_err = sl_rtl_util_rssi2distance(initiator_config->rssi_tx_power,

    +                                              cs_meas_data.initiator_calibration_rssi,

    +                                              &result.rssi_distance);

    +          if (rtl_err != SL_RTL_ERROR_SUCCESS) {

    +            app_log_error("Failed to calculate RSSI distance!" APP_LOG_NL);

    +          }

    +

    +          if (initiator_config->result_cb != NULL) {

    +            initiator_config->result_cb(&result, NULL);

    +          }

    +        }

    +

    +        sc = abr_cs_parser_cleanup_measurement(connection);

    +        app_assert_status(sc);

    +

    +        if (initiator_config->max_procedure_count != 0) {

    +          restart_procedure = true;

    +        }

    +      }

    +      break;

    +    case sl_bt_cs_mode_pbr_and_rtt:

    +      break;

    +    default:

    +      break;

    +  }

    +

    +  if (restart_procedure) {

    +    abr_initiator_perform_procedure();

    +  }

    +}

    +

    +/**************************************************************************//**

    + * Initialize RTL library.

    + * @param[in] handle RTL library item handle.

    + * @param[in] abr_mode Specifying ABR method.

    + *****************************************************************************/

    +static void rtl_library_init(sl_rtl_abr_libitem *handle, uint8_t abr_mode)

    +{

    +  enum sl_rtl_error_code rtl_err;

    +

    +  app_log_info("Initialising RTL..." APP_LOG_NL);

    +  rtl_err = sl_rtl_abr_init(handle);

    +  app_assert(rtl_err == SL_RTL_ERROR_SUCCESS,

    +             "Failed to initialize RTL library!" APP_LOG_NL);

    +

    +  rtl_err = sl_rtl_abr_set_algo_mode(handle, SL_RTL_ABR_ALGO_MODE_REAL_TIME_BASIC);

    +  app_assert(rtl_err == SL_RTL_ERROR_SUCCESS,

    +             "RTL library set mode failed!" APP_LOG_NL);

    +

    +  switch (abr_mode) {

    +    case sl_bt_cs_mode_rtt:

    +      rtl_err = sl_rtl_abr_set_cs_mode(handle, SL_RTL_ABR_CS_MODE_RTT);

    +      app_assert(rtl_err == SL_RTL_ERROR_SUCCESS,

    +                 "RTL library set method failed!" APP_LOG_NL);

    +      break;

    +    case sl_bt_cs_mode_pbr:

    +      rtl_err = sl_rtl_abr_set_cs_mode(handle, SL_RTL_ABR_CS_MODE_RTP);

    +      app_assert(rtl_err == SL_RTL_ERROR_SUCCESS,

    +                 "RTL library set method failed!" APP_LOG_NL);

    +      break;

    +    case sl_bt_cs_mode_pbr_and_rtt:

    +      // This shall be changed in future.

    +      // There''s no combined mode support in RTL now

    +      rtl_err = sl_rtl_abr_set_cs_mode(handle, SL_RTL_ABR_CS_MODE_RTP);

    +      app_assert(rtl_err == SL_RTL_ERROR_SUCCESS,

    +                 "RTL library set method failed!" APP_LOG_NL);

    +      break;

    +    default:

    +      rtl_err = sl_rtl_abr_set_cs_mode(handle, SL_RTL_ABR_CS_MODE_RTP);

    +      app_assert(rtl_err == SL_RTL_ERROR_SUCCESS,

    +                 "RTL library set method failed!" APP_LOG_NL);

    +      break;

    +  }

    +

    +  rtl_err = sl_rtl_abr_create_estimator(handle);

    +  app_assert(rtl_err == SL_RTL_ERROR_SUCCESS, "Failed to create estimator!"

    +             APP_LOG_NL);

    +}'
  - '--- a/app/bluetooth/common/abr_initiator/abr_initiator_config.c

    +++ b/app/bluetooth/common/abr_initiator/abr_initiator_config.c

    @@ -0,0 +1,139 @@

    +/***************************************************************************//**

    + * @file

    + * @brief ABR initiator configuration

    + *******************************************************************************

    + * # License

    + * <b>Copyright 2023 Silicon Laboratories Inc. www.silabs.com</b>

    + *******************************************************************************

    + *

    + * SPDX-License-Identifier: Zlib

    + *

    + * The licensor of this software is Silicon Laboratories Inc.

    + *

    + * This software is provided ''as-is'', without any express or implied

    + * warranty. In no event will the authors be held liable for any damages

    + * arising from the use of this software.

    + *

    + * Permission is granted to anyone to use this software for any purpose,

    + * including commercial applications, and to alter it and redistribute it

    + * freely, subject to the following restrictions:

    + *

    + * 1. The origin of this software must not be misrepresented; you must not

    + *    claim that you wrote the original software. If you use this software

    + *    in a product, an acknowledgment in the product documentation would be

    + *    appreciated but is not required.

    + * 2. Altered source versions must be plainly marked as such, and must not be

    + *    misrepresented as being the original software.

    + * 3. This notice may not be removed or altered from any source distribution.

    + *

    + ******************************************************************************/

    +

    +#include "sl_bt_api.h"

    +#include "abr_initiator_config.h"

    +

    +sl_status_t abr_initiator_config_set_default(abr_initiator_config_t *config)

    +{

    +  // Main mode. mode_2: RTP, mode_1: RTT

    +  config->mode =                        sl_bt_cs_mode_pbr;

    +  // Submode

    +  config->submode =                     sl_bt_cs_mode_rtt;

    +  // Minimum suggested duration for each ABR subevent in microseconds. Range:
    0x01 to 0xFFFFFF

    +  config->min_subevent_len =            1;

    +  // Maximum suggested duration for each ABR subevent in microseconds. Range:
    0x01 to 0xFFFFFF

    +  config->max_subevent_len =            0xffff;

    +  // In 1.25ms units, 20ms

    +  config->min_connection_interval =     16;

    +  // In 1.25ms units, 20ms

    +  config->max_connection_interval =     16;

    +  // Scan interval

    +  config->scan_interval =               16;

    +  // Scan window

    +  config->scan_window =                 16;

    +  // Minimum duration in number of connection events between consecutive measurement
    procedure.

    +  // Range: 0x01 to 0xFF

    +  config->min_interval =                5;

    +  // Maximum duration in number of connection events between consecutive measurement
    procedure.

    +  // Range: 0x01 to 0xFF

    +  config->max_interval =                5;

    +  // Procedure execution number

    +  config->max_procedure_count =         1;

    +  // Scanning PHY

    +  config->scan_phy =                    sl_bt_gap_phy_coding_1m_uncoded;

    +  // Connection PHY

    +  config->phy =                         sl_bt_gap_phy_coding_1m_uncoded;

    +  // Only one channel is supported

    +  config->config_id =                   1;

    +  // Range: 0x02 to 0xA0

    +  config->min_main_mode_steps =         0xff;

    +  // Range: 0x02 to 0xA0

    +  config->max_main_mode_steps =         0xff;

    +  // The number of main mode steps taken from the end of the last ABR subevent

    +  // to be repeated at the beginning of the current ABR subevent directly after

    +  // the last Mode 0 step of that event. Range: 0x01 to 0x03

    +  config->main_mode_repetition =        0;

    +  // Number of Mode 0 steps to be included at the beginning of the test ABR subevent.

    +  config->mode0_step =                  3;

    +  // The number of times the channel_map field will be cycled through for non-Mode
    0 steps within a ABR procedure.

    +  // Range: 0x01 to 0x03

    +  config->channel_map_repetition =      1;

    +  // Number of channels skipped in each rising and falling sequence. Range: 2
    to 8

    +  config->ch3c_jump =                   2;

    +  // Maximum duration for each measurement procedure. Value in units of 0.625
    ms

    +  // Range: 0x0001 to 0xFFFF

    +  config->max_procedure_duration =      0xffff;

    +  // Transmit power delta, in signed dB.

    +  config->tx_pwr_delta =                0x80;

    +  // Antenna configuration index. Range: 0x01 to 0x07

    +  config->antenna_config =              0;

    +  // BT address for filtering reflectors

    +  config->filter_address =              NULL;

    +  // The preferred peer-ordered antenna elements to be used by the remote device

    +  // for the antenna configuration denoted by the tone antenna config selection.

    +  config->preferred_peer_antenna =      0;

    +  // CS power

    +  config->max_tx_power_dbm =            20;

    +  // Value: 0x00. Write ABR configuration in the local controller only

    +  // Value: 0x01. Write ABR configuration in both the local and remote controller
    using a configuration procedure

    +  config->create_context =              1;

    +  // RSSI measurement enabled

    +  config->rssi_measurement_enabled =    false;

    +  // Reference RSSI value of the Tx device at 1.0 m distance in dBm

    +  config->rssi_tx_power =               -40.0F;

    +  // Peripheral latency, which defines how many connection intervals the peripheral

    +  // can skip if it has no data to send

    +  config->latency =                     0;

    +  // Supervision timeout

    +  config->timeout =                     200;

    +  // Minimum length of the connection event

    +  config->min_ce_length =               0;

    +  // Maximum length of the connection event

    +  config->max_ce_length =               0xffff;

    +  // Antenna identifier to be used for ABR

    +  config->cs_sync_antenna =             1;

    +  // Connection maximum TX power in dBm

    +  config->tx_power_requested_max_dbm =  10;

    +  // Connection minimum TX power in dBm

    +  config->tx_power_requested_min_dbm =  -10;

    +  // RTT type

    +  config->rtt_type =                    sl_bt_cs_rtt_type_fractional_96_bit_sounding;

    +  // Channel selection type.

    +  config->channel_selection_type =      sl_bt_cs_channel_selection_algorithm_3b;

    +  // Ch3c shape.

    +  config->ch3c_shape =                  sl_bt_cs_ch3c_shape_hat;

    +  // Companion signal enable/disable.

    +  config->companion_signal_enable =     sl_bt_cs_companion_signal_status_disable;

    +

    +  switch (config->mode) {

    +    case sl_bt_cs_mode_rtt: // RTT

    +      config->submode = 0xff;

    +      break;

    +    case sl_bt_cs_mode_pbr: // Phase based

    +      config->submode = sl_bt_cs_mode_rtt;

    +      break;

    +    default:

    +      return SL_STATUS_INVALID_PARAMETER;

    +      break;

    +  }

    +

    +  return SL_STATUS_OK;

    +}'
  - '--- a/app/bluetooth/common/abr_initiator/abr_initiator_platform.c

    +++ b/app/bluetooth/common/abr_initiator/abr_initiator_platform.c

    @@ -0,0 +1,47 @@

    +/***************************************************************************//**

    + * @file

    + * @brief ABR initiator

    + *******************************************************************************

    + * # License

    + * <b>Copyright 2022 Silicon Laboratories Inc. www.silabs.com</b>

    + *******************************************************************************

    + *

    + * SPDX-License-Identifier: Zlib

    + *

    + * The licensor of this software is Silicon Laboratories Inc.

    + *

    + * This software is provided ''as-is'', without any express or implied

    + * warranty. In no event will the authors be held liable for any damages

    + * arising from the use of this software.

    + *

    + * Permission is granted to anyone to use this software for any purpose,

    + * including commercial applications, and to alter it and redistribute it

    + * freely, subject to the following restrictions:

    + *

    + * 1. The origin of this software must not be misrepresented; you must not

    + *    claim that you wrote the original software. If you use this software

    + *    in a product, an acknowledgment in the product documentation would be

    + *    appreciated but is not required.

    + * 2. Altered source versions must be plainly marked as such, and must not be

    + *    misrepresented as being the original software.

    + * 3. This notice may not be removed or altered from any source distribution.

    + *

    + ******************************************************************************/

    +

    +#include "abr_ui.h"

    +

    +/**************************************************************************//**

    + * ASCII graphics for indicating wait status

    + *****************************************************************************/

    +void waiting_indication(void)

    +{

    +  // Do nothing

    +}

    +

    +/**************************************************************************//**

    + * Display ABR state machine state

    + *****************************************************************************/

    +void platform_display_state(abr_state_t state)

    +{

    +  abr_ui_set_state(state);

    +}'
  - '--- a/app/bluetooth/common/abr_reflector/abr_reflector.c

    +++ b/app/bluetooth/common/abr_reflector/abr_reflector.c

    @@ -0,0 +1,186 @@

    +/***************************************************************************//**

    + * @file

    + * @brief ABR reflector.

    + *******************************************************************************

    + * # License

    + * <b>Copyright 2023 Silicon Laboratories Inc. www.silabs.com</b>

    + *******************************************************************************

    + *

    + * SPDX-License-Identifier: Zlib

    + *

    + * The licensor of this software is Silicon Laboratories Inc.

    + *

    + * This software is provided ''as-is'', without any express or implied

    + * warranty. In no event will the authors be held liable for any damages

    + * arising from the use of this software.

    + *

    + * Permission is granted to anyone to use this software for any purpose,

    + * including commercial applications, and to alter it and redistribute it

    + * freely, subject to the following restrictions:

    + *

    + * 1. The origin of this software must not be misrepresented; you must not

    + *    claim that you wrote the original software. If you use this software

    + *    in a product, an acknowledgment in the product documentation would be

    + *    appreciated but is not required.

    + * 2. Altered source versions must be plainly marked as such, and must not be

    + *    misrepresented as being the original software.

    + * 3. This notice may not be removed or altered from any source distribution.

    + *

    + ******************************************************************************/

    +

    +#include "sl_bt_api.h"

    +#include "gatt_db.h"

    +#include "app_assert.h"

    +#include "abr_reflector.h"

    +

    +#define EVENT_BUFF_LEN 256

    +#define EVENT_MAX 4

    +#define MAX_POWER_DBM 20

    +

    +typedef struct {

    +  uint8_t data[EVENT_BUFF_LEN];

    +  uint8_t len;

    +  bool empty;

    +} event_data_t;

    +

    +// The advertising set handle allocated from Bluetooth stack.

    +static uint8_t advertising_set_handle = 0xff;

    +static uint8_t connection;

    +static event_data_t response_buffer[EVENT_MAX];

    +static uint8_t rx_slot;

    +static uint8_t tx_slot;

    +static bool busy;

    +

    +static void abr_reflector_send_results(void);

    +

    +/**************************************************************************//**

    + * Bluetooth stack event handler.

    + * This overrides the dummy weak implementation.

    + *

    + * @param[in] evt Event coming from the Bluetooth stack.

    + *****************************************************************************/

    +void abr_reflector_on_bt_event(sl_bt_msg_t *evt)

    +{

    +  sl_status_t sc;

    +  size_t result_len;

    +  uint8_t event_iter;

    +

    +  switch (SL_BT_MSG_ID(evt->header)) {

    +    // -------------------------------

    +    // This event indicates that a new connection was opened.

    +    case sl_bt_evt_connection_opened_id:

    +      connection = evt->data.evt_connection_opened.connection;

    +      sc = sl_bt_cs_set_default_settings(connection,

    +                                         sl_bt_cs_role_status_disable,

    +                                         sl_bt_cs_role_status_enable,

    +                                         1,

    +                                         MAX_POWER_DBM);

    +      app_assert_status(sc);

    +

    +      for (event_iter = 0; event_iter < EVENT_MAX; event_iter++) {

    +        response_buffer[event_iter].empty = true;

    +      }

    +

    +      busy = false;

    +

    +      rx_slot = 0;

    +      tx_slot = 0;

    +

    +      break;

    +

    +    // -------------------------------

    +    // This event indicates that a new result is available.

    +    case sl_bt_evt_cs_result_id:

    +      result_len = sizeof(evt->data.evt_cs_result) + evt->data.evt_cs_result.data.len;

    +

    +      memcpy(response_buffer[rx_slot].data, (uint8_t *)&evt->data.evt_cs_result,
    result_len);

    +      response_buffer[rx_slot].len = result_len;

    +      response_buffer[rx_slot].empty = false;

    +      rx_slot++;

    +      if (rx_slot >= EVENT_MAX) {

    +        rx_slot = 0;

    +      }

    +

    +      abr_reflector_send_results();

    +      break;

    +    case sl_bt_evt_gatt_server_characteristic_status_id:

    +      if (evt->data.evt_gatt_server_characteristic_status.status_flags & sl_bt_gatt_server_confirmation)
    {

    +        busy = false;

    +        abr_reflector_send_results();

    +      }

    +      break;

    +

    +    case sl_bt_evt_gatt_mtu_exchanged_id:

    +      break;

    +

    +    // -------------------------------

    +    // This event indicates that a connection was closed.

    +    case sl_bt_evt_connection_closed_id:

    +      // -------------------------------

    +      // Restart advertisement.

    +      abr_reflector_restart_advertise();

    +      break;

    +  }

    +}

    +

    +static void abr_reflector_send_results(void)

    +{

    +  sl_status_t sc;

    +

    +  if (busy) {

    +    return;

    +  }

    +

    +  if (response_buffer[tx_slot].empty == false) {

    +    sc = sl_bt_gatt_server_send_indication(connection,

    +                                           gattdb_abr_result,

    +                                           response_buffer[tx_slot].len,

    +                                           response_buffer[tx_slot].data);

    +    app_assert_status(sc);

    +    response_buffer[tx_slot].empty = true;

    +    tx_slot++;

    +    if (tx_slot >= EVENT_MAX) {

    +      tx_slot = 0;

    +    }

    +    busy = true;

    +  }

    +}

    +

    +void abr_reflector_advertise(void)

    +{

    +  sl_status_t sc;

    +

    +  // Stop running advertising.

    +  sl_bt_advertiser_stop(advertising_set_handle);

    +  // Delete advertiser set

    +  sl_bt_advertiser_delete_set(advertising_set_handle);

    +

    +  sc = sl_bt_advertiser_create_set(&advertising_set_handle);

    +  app_assert_status(sc);

    +

    +  // Generate data for advertising

    +  sc = sl_bt_legacy_advertiser_generate_data(advertising_set_handle,

    +                                             sl_bt_advertiser_general_discoverable);

    +  app_assert_status(sc);

    +

    +  // Set advertising interval to 100ms.

    +  sc = sl_bt_advertiser_set_timing(

    +    advertising_set_handle,

    +    160, // min. adv. interval (milliseconds * 1.6)

    +    160, // max. adv. interval (milliseconds * 1.6)

    +    0,   // adv. duration

    +    0);  // max. num. adv. events

    +  app_assert_status(sc);

    +

    +  abr_reflector_restart_advertise();

    +}

    +

    +void abr_reflector_restart_advertise(void)

    +{

    +  sl_status_t sc;

    +

    +  // Start advertising and enable connections.

    +  sc = sl_bt_legacy_advertiser_start(advertising_set_handle,

    +                                     sl_bt_advertiser_connectable_scannable);

    +  app_assert_status(sc);

    +}'
  - "--- a/app/bluetooth/common/cbap/sl_bt_cbap.c\n+++ b/app/bluetooth/common/cbap/sl_bt_cbap.c\n\
    @@ -1,903 +1,903 @@\n-/***************************************************************************//**\r\
    \n- * @file\r\n- * @brief Certificate Based Authentication and Pairing implementation\r\
    \n- *******************************************************************************\r\
    \n- * # License\r\n- * <b>Copyright 2022 Silicon Laboratories Inc. www.silabs.com</b>\r\
    \n- *******************************************************************************\r\
    \n- *\r\n- * SPDX-License-Identifier: Zlib\r\n- *\r\n- * The licensor of this\
    \ software is Silicon Laboratories Inc.\r\n- *\r\n- * This software is provided\
    \ 'as-is', without any express or implied\r\n- * warranty. In no event will the\
    \ authors be held liable for any damages\r\n- * arising from the use of this software.\r\
    \n- *\r\n- * Permission is granted to anyone to use this software for any purpose,\r\
    \n- * including commercial applications, and to alter it and redistribute it\r\
    \n- * freely, subject to the following restrictions:\r\n- *\r\n- * 1. The origin\
    \ of this software must not be misrepresented; you must not\r\n- *    claim that\
    \ you wrote the original software. If you use this software\r\n- *    in a product,\
    \ an acknowledgment in the product documentation would be\r\n- *    appreciated\
    \ but is not required.\r\n- * 2. Altered source versions must be plainly marked\
    \ as such, and must not be\r\n- *    misrepresented as being the original software.\r\
    \n- * 3. This notice may not be removed or altered from any source distribution.\r\
    \n- *\r\n- ******************************************************************************/\r\
    \n-\r\n-#include <stdbool.h>\r\n-#include \"em_common.h\"\r\n-#include \"em_system.h\"\
    \r\n-\r\n-#include \"app_assert.h\"\r\n-#include \"gatt_db.h\"\r\n-#include \"\
    sl_bluetooth.h\"\r\n-#include \"sl_simple_timer.h\"\r\n-#include \"sl_bt_cbap_config.h\"\
    \r\n-#include \"sl_bt_cbap_root_cert.h\"\r\n-#include \"sl_bt_cbap.h\"\r\n-#include\
    \ \"sl_bt_cbap_lib.h\"\r\n-\r\n-#ifdef SL_COMPONENT_CATALOG_PRESENT\r\n-#include\
    \ \"sl_component_catalog.h\"\r\n-#endif // SL_COMPONENT_CATALOG_PRESENT\r\n-#ifdef\
    \ SL_CATALOG_APP_LOG_PRESENT\r\n-#include \"app_log.h\"\r\n-#endif // SL_CATALOG_APP_LOG_PRESENT\r\
    \n-\r\n-// -----------------------------------------------------------------------------\r\
    \n-// Defines\r\n-\r\n-#if defined(SL_CATALOG_APP_LOG_PRESENT) && SL_BT_CBAP_LOG\r\
    \n-#define sl_bt_cbap_log_debug(...)           app_log_debug(__VA_ARGS__)\r\n\
    -#define sl_bt_cbap_log_info(...)            app_log_info(__VA_ARGS__)\r\n-#define\
    \ sl_bt_cbap_log_error(...)           app_log_error(__VA_ARGS__)\r\n-#define sl_bt_cbap_log_hexdump(p_data,\
    \ len) app_log_hexdump_debug(p_data, len)\r\n-#else\r\n-#define sl_bt_cbap_log_debug(...)\r\
    \n-#define sl_bt_cbap_log_info(...)\r\n-#define sl_bt_cbap_log_error(...)\r\n\
    -#define sl_bt_cbap_log_hexdump(p_data, len)\r\n-#endif\r\n-\r\n-#define IS_PERIPHERAL_IN_PROGRESS\
    \ (cbap_peripheral_state > 0 && cbap_peripheral_state < SL_BT_CBAP_PERIPHERAL_STATE_NUM\
    \ - 1)\r\n-#define IS_CENTRAL_IN_PROGRESS    (cbap_central_state > 0 && cbap_central_state\
    \ < SL_BT_CBAP_CENTRAL_STATE_NUM - 1)\r\n-\r\n-#define UUID_16_LEN           \
    \        2\r\n-#define UUID_128_LEN                  16\r\n-#define HANDLE_NOT_INITIALIZED\
    \        0\r\n-\r\n-#define GAP_INCOMPLETE_16B_UUID       0x02 // Incomplete List\
    \ of 16-bit Service Class UUIDs\r\n-#define GAP_COMPLETE_16B_UUID         0x03\
    \ // Complete List of 16-bit Service Class UUIDs\r\n-#define GAP_INCOMPLETE_128B_UUID\
    \      0x06 // Incomplete List of 128-bit Service Class UUIDs\r\n-#define GAP_COMPLETE_128B_UUID\
    \        0x07 // Complete List of 128-bit Service Class UUIDs\r\n-\r\n-#define\
    \ CHAIN_LINK_DATA_LEN           192  // Length of an NVM3 chunk\r\n-#define CHAIN_LINK_DATA_NUM\
    \           4    // Number of how many chunks needed for a certificate\r\n-\r\n\
    -#define OOB_SIGNATURE_LEN             64\r\n-#define CERT_IND_CHUNK_LEN     \
    \       100\r\n-#define EC_PUB_KEY_LEN                65\r\n-#define PUB_KEY_OFFSET\
    \                26\r\n-\r\n-#define OOB_RANDOM_LEN                (sizeof(aes_key_128))\r\
    \n-#define OOB_DATA_LEN                  (2 * OOB_RANDOM_LEN)\r\n-#define SIGNED_OOB_DATA_LEN\
    \           (OOB_DATA_LEN + OOB_SIGNATURE_LEN)\r\n-\r\n-#define TIMEOUT      \
    \                 5000 // ms\r\n-#define NO_CALLBACK_DATA              (void *)NULL\
    \ // Callback has no parameters\r\n-\r\n-// -----------------------------------------------------------------------------\r\
    \n-// Type definitions.\r\n-\r\n-typedef struct characteristic_128_ref_s {\r\n\
    -  uint16_t handle;\r\n-  uint8_t uuid[UUID_128_LEN];\r\n-} characteristic_128_ref_t;\r\
    \n-\r\n-typedef enum {\r\n-  CHAR_CENTRAL_CERT,\r\n-  CHAR_PERIPHERAL_CERT,\r\n\
    -  CHAR_CENTRAL_OOB,\r\n-  CHAR_PERIPHERAL_OOB,\r\n-  CHAR_NUM\r\n-} characteristics_t;\r\
    \n-\r\n-// -----------------------------------------------------------------------------\r\
    \n-// Module variables.\r\n-\r\n-// Device role\r\n-static sl_bt_cbap_role_t role;\r\
    \n-\r\n-// Handle of the active connection.\r\n-static uint8_t connection = SL_BT_INVALID_CONNECTION_HANDLE;\r\
    \n-\r\n-// Root certificate in PEM format.\r\n-const char *root_certificate_pem\
    \ = SL_BT_CBAP_ROOT_CERT;\r\n-\r\n-// Reference to the CBAP service.\r\n-static\
    \ uint32_t cbap_service_handle = HANDLE_NOT_INITIALIZED;\r\n-static const uint8_t\
    \ cbap_service_uuid[] = {\r\n-  0x10, 0x56, 0x28, 0xd0, 0x40, 0xdd, 0x8e, 0x91,\r\
    \n-  0x4d, 0x41, 0x47, 0x81, 0xc6, 0x8c, 0x81, 0xd8\r\n-};\r\n-\r\n-// Reference\
    \ to the CBAP characteristics.\r\n-static characteristic_128_ref_t cbap_characteristics[]\
    \ = {\r\n-  {   // CHAR_CENTRAL_CERT\r\n-    .handle = HANDLE_NOT_INITIALIZED,\r\
    \n-    .uuid = {\r\n-      0xca, 0x25, 0xf3, 0xa2, 0xf6, 0xda, 0xbd, 0xb6,\r\n\
    -      0x69, 0x4a, 0xaa, 0x08, 0xf9, 0xd0, 0x5f, 0x31\r\n-    }\r\n-  },\r\n-\
    \  {   // CHAR_PERIPHERAL_CERT\r\n-    .handle = HANDLE_NOT_INITIALIZED,\r\n-\
    \    .uuid = {\r\n-      0x66, 0x50, 0xfd, 0x84, 0x4d, 0xad, 0xa2, 0x99,\r\n-\
    \      0xc9, 0x4f, 0xf5, 0x16, 0x9e, 0xda, 0xf6, 0x0c\r\n-    }\r\n-  },\r\n-\
    \  {   // CHAR_CENTRAL_OOB\r\n-    .handle = HANDLE_NOT_INITIALIZED,\r\n-    .uuid\
    \ = {\r\n-      0x2c, 0x19, 0xf1, 0xeb, 0x85, 0xcd, 0xb6, 0x8a,\r\n-      0x2c,\
    \ 0x4e, 0x7d, 0x89, 0x51, 0x57, 0xd3, 0xe8\r\n-    }\r\n-  },\r\n-  {   // CHAR_PERIPHERAL_OOB\r\
    \n-    .handle = HANDLE_NOT_INITIALIZED,\r\n-    .uuid = {\r\n-      0xab, 0x69,\
    \ 0xb2, 0x5e, 0xb8, 0x41, 0xb3, 0x8b,\r\n-      0x82, 0x41, 0x51, 0xa2, 0x41,\
    \ 0xcb, 0x91, 0x69\r\n-    }\r\n-  }\r\n-};\r\n-\r\n-// State of the central device\r\
    \n-static sl_bt_cbap_central_state_t cbap_central_state = SL_BT_CBAP_CENTRAL_SCANNING;\r\
    \n-// Pointing to the characteristic that shall be discovered next\r\n-static\
    \ characteristics_t char_state = (characteristics_t)0;\r\n-// State of the peripheral\
    \ device\r\n-static sl_bt_cbap_peripheral_state_t cbap_peripheral_state = SL_BT_CBAP_PERIPHERAL_IDLE;\r\
    \n-\r\n-// Timer handle\r\n-static sl_simple_timer_t state_timer;\r\n-\r\n-//\
    \ Remote certificate which was sent over GATT in DER format\r\n-static uint8_t\
    \ remote_certificate_der[CHAIN_LINK_DATA_LEN * CHAIN_LINK_DATA_NUM] = { 0 };\r\
    \n-static uint32_t remote_certificate_der_len = 0;\r\n-static bool remote_cert_arrived\
    \ = false;\r\n-\r\n-// Device certificate in DER format\r\n-static uint8_t device_certificate_der[CHAIN_LINK_DATA_LEN\
    \ * CHAIN_LINK_DATA_NUM] = { 0 };\r\n-static uint32_t device_certificate_der_len\
    \ = 0;\r\n-static uint32_t dev_cert_sending_progression = 0;\r\n-static bool device_cert_sent\
    \ = false;\r\n-\r\n-static uint8_t signed_device_oob_data[SIGNED_OOB_DATA_LEN];\r\
    \n-static size_t signed_device_oob_len = 0;\r\n-\r\n-// -----------------------------------------------------------------------------\r\
    \n-// Private function declarations\r\n-\r\n-// Central device bluetooth event\
    \ handler.\r\n-static void on_event_peripheral(sl_bt_msg_t *evt);\r\n-// Peripheral\
    \ device bluetooth event handler.\r\n-static void on_event_central(sl_bt_msg_t\
    \ *evt);\r\n-\r\n-// Reset CBAP process states, flags and timers.\r\n-static void\
    \ cbap_reset(void);\r\n-\r\n-// Search for a Service UUID in scan report.\r\n\
    -static bool find_service_in_advertisement(const uint8_t *scan_data,\r\n-    \
    \                                      uint8_t scan_data_len,\r\n-           \
    \                               const uint8_t *uuid,\r\n-                    \
    \                      uint8_t uuid_len);\r\n-\r\n-// Start or stop timer for\
    \ timeout check.\r\n-static void set_timeout(bool activate);\r\n-// Timer callback.\r\
    \n-static void state_timer_cb(sl_simple_timer_t *handle, void *data);\r\n-\r\n\
    -// -----------------------------------------------------------------------------\r\
    \n-// Public function definitions\r\n-\r\n-// Initialize the component. Import\
    \ and validate the device and root certificate.\r\n-void sl_bt_cbap_init(void)\r\
    \n-{\r\n-  sl_status_t sc;\r\n-  sc = sl_bt_cbap_lib_init(root_certificate_pem,\r\
    \n-                           device_certificate_der,\r\n-                   \
    \        &device_certificate_der_len);\r\n-  app_assert_status(sc);\r\n-  sl_bt_cbap_log_info(\"\
    Device certificate verified.\" APP_LOG_NL);\r\n-\r\n-  cbap_reset();\r\n-}\r\n\
    -\r\n-// Start CBAP procedure.\r\n-sl_status_t sl_bt_cbap_start(sl_bt_cbap_role_t\
    \ cbap_role,\r\n-                             uint8_t connection_handle)\r\n-{\r\
    \n-  sl_status_t sc;\r\n-  if (IS_PERIPHERAL_IN_PROGRESS || IS_CENTRAL_IN_PROGRESS)\
    \ {\r\n-    return SL_STATUS_IN_PROGRESS;\r\n-  }\r\n-\r\n-  role = cbap_role;\r\
    \n-  connection = connection_handle;\r\n-\r\n-  if (role == SL_BT_CBAP_ROLE_CENTRAL)\
    \ {\r\n-    // Discover CBAP service on the peripheral device\r\n-    sc = sl_bt_gatt_discover_primary_services_by_uuid(connection,\r\
    \n-                                                      sizeof(cbap_service_uuid),\r\
    \n-                                                      (const uint8_t *)cbap_service_uuid);\r\
    \n-    app_assert_status(sc);\r\n-    cbap_central_state = SL_BT_CBAP_CENTRAL_DISCOVER_SERVICES;\r\
    \n-    sl_bt_cbap_central_on_event(cbap_central_state);\r\n-  }\r\n-\r\n-  set_timeout(true);\r\
    \n-  return SL_STATUS_OK;\r\n-}\r\n-\r\n-// Bluetooth stack event handler.\r\n\
    -void sli_bt_cbap_on_event(sl_bt_msg_t *evt)\r\n-{\r\n-  switch (role) {\r\n-\
    \    case SL_BT_CBAP_ROLE_PERIPHERAL:\r\n-      on_event_peripheral(evt);\r\n\
    -      break;\r\n-    case SL_BT_CBAP_ROLE_CENTRAL:\r\n-      on_event_central(evt);\r\
    \n-      break;\r\n-  }\r\n-}\r\n-\r\n-// Search for a the CBAP Service UUID in\
    \ scan report.\r\n-bool sl_bt_cbap_find_service_in_advertisement(const uint8_t\
    \ *scan_data,\r\n-                                              uint8_t scan_data_len)\r\
    \n-{\r\n-  return find_service_in_advertisement(scan_data,\r\n-              \
    \                         scan_data_len,\r\n-                                \
    \       cbap_service_uuid,\r\n-                                       sizeof(cbap_service_uuid));\r\
    \n-}\r\n-\r\n-// -----------------------------------------------------------------------------\r\
    \n-// Private function definitions\r\n-\r\n-/*******************************************************************************\r\
    \n- * Peripheral device bluetooth event handler.\r\n- ******************************************************************************/\r\
    \n-static void on_event_peripheral(sl_bt_msg_t *evt)\r\n-{\r\n-  sl_status_t sc;\r\
    \n-  // Handle stack events\r\n-  switch (SL_BT_MSG_ID(evt->header)) {\r\n-  \
    \  // This event indicates the device has started and the radio is ready.\r\n\
    -    // Do not call any stack command before receiving this boot event!\r\n- \
    \   case sl_bt_evt_system_boot_id:\r\n-      // Request OOB data from both device\r\
    \n-      sc = sl_bt_sm_configure(SL_BT_SM_CONFIGURATION_OOB_FROM_BOTH_DEVICES_REQUIRED,\r\
    \n-                              sl_bt_sm_io_capability_noinputnooutput);\r\n\
    -      app_assert_status(sc);\r\n-      break;\r\n-\r\n-    //--------------------------------\r\
    \n-    // Triggered whenever the connection parameters are changed\r\n-    case\
    \ sl_bt_evt_connection_parameters_id:\r\n-      if (evt->data.evt_connection_parameters.connection\
    \ != connection) {\r\n-        break;\r\n-      }\r\n-\r\n-      sl_bt_cbap_log_debug(\"\
    Security mode: %i\" APP_LOG_NL,\r\n-                           evt->data.evt_connection_parameters.security_mode);\r\
    \n-      if (evt->data.evt_connection_parameters.security_mode > sl_bt_connection_mode1_level1\r\
    \n-          && cbap_peripheral_state != SL_BT_CBAP_PERIPHERAL_CENTRAL_OOB_OK)\
    \ {\r\n-        sl_bt_cbap_log_error(\"The central device increased the security\
    \ level with \" \\\r\n-                             \"no CBAP. Disconnecting.\"\
    \ APP_LOG_NL);\r\n-        sl_bt_on_cbap_error();\r\n-        cbap_reset();\r\n\
    -        break;\r\n-      }\r\n-\r\n-      if (evt->data.evt_connection_parameters.security_mode\
    \ == sl_bt_connection_mode1_level4) {\r\n-        cbap_peripheral_state = SL_BT_CBAP_PERIPHERAL_DONE;\r\
    \n-        sl_bt_cbap_peripheral_on_event(cbap_peripheral_state);\r\n-       \
    \ cbap_reset();\r\n-      }\r\n-      break;\r\n-\r\n-    case sl_bt_evt_gatt_server_user_write_request_id:\r\
    \n-      if (evt->data.evt_gatt_server_user_write_request.connection != connection)\
    \ {\r\n-        break;\r\n-      }\r\n-\r\n-      // Set default response parameters.\r\
    \n-      sc = SL_STATUS_BT_ATT_WRITE_REQUEST_REJECTED;\r\n-      // Receiving\
    \ Certificate from central device\r\n-      if (evt->data.evt_gatt_server_user_write_request.characteristic\
    \ == gattdb_central_cert) {\r\n-        if (remote_cert_arrived == false) {\r\n\
    -          // First byte indicates that it is a last packet or not\r\n-      \
    \    memcpy(&remote_certificate_der[remote_certificate_der_len],\r\n-        \
    \         &evt->data.evt_gatt_server_user_write_request.value.data[1],\r\n-  \
    \               evt->data.evt_gatt_server_user_write_request.value.len - 1);\r\
    \n-          remote_certificate_der_len += evt->data.evt_gatt_server_user_write_request.value.len\
    \ - 1;\r\n-          sc = SL_STATUS_OK;\r\n-          if (evt->data.evt_gatt_server_user_write_request.value.data[0]\
    \ == 0) {\r\n-            // Last packet of the remote cert arrived\r\n-     \
    \       sl_bt_cbap_log_info(\"Getting certificate from central.\" APP_LOG_NL);\r\
    \n-            remote_cert_arrived = true;\r\n-            sc = sl_bt_cbap_lib_process_remote_cert(remote_certificate_der,\r\
    \n-                                                    remote_certificate_der_len);\r\
    \n-            if (sc == SL_STATUS_OK) {\r\n-              app_assert(cbap_peripheral_state\
    \ == SL_BT_CBAP_PERIPHERAL_IDLE,\r\n-                         \"Unexpected peripheral\
    \ state.\");\r\n-              cbap_peripheral_state = SL_BT_CBAP_PERIPHERAL_CENTRAL_CERT_OK;\r\
    \n-              sl_bt_cbap_peripheral_on_event(cbap_peripheral_state);\r\n- \
    \             set_timeout(true);\r\n-            } else {\r\n-              sl_bt_cbap_log_error(\"\
    Remote certificate verification failed. \" \\\r\n-                           \
    \        \"Disconnecting.\" APP_LOG_NL);\r\n-              sl_bt_on_cbap_error();\r\
    \n-              cbap_reset();\r\n-              break;\r\n-            }\r\n\
    -          }\r\n-          // Map status code to a valid attribute error.\r\n\
    -          if (SL_STATUS_OK != sc) {\r\n-            sc = SL_STATUS_BT_ATT_WRITE_REQUEST_REJECTED;\r\
    \n-          }\r\n-        } else {\r\n-          sc = SL_STATUS_BT_ATT_PROCEDURE_ALREADY_IN_PROGRESS;\r\
    \n-        }\r\n-        sl_bt_gatt_server_send_user_write_response(evt->data.evt_gatt_server_user_write_request.connection,\r\
    \n-                                                   evt->data.evt_gatt_server_user_write_request.characteristic,\r\
    \n-                                                   (uint8_t)sc);\r\n-     \
    \ }\r\n-      // Receiving OOB data from central device\r\n-      else if (evt->data.evt_gatt_server_user_write_request.characteristic\
    \ == gattdb_central_oob ) {\r\n-        sl_bt_cbap_log_info(\"Getting OOB data\
    \ from central.\" APP_LOG_NL);\r\n-        aes_key_128 remote_random;\r\n-   \
    \     aes_key_128 remote_confirm;\r\n-        uint8_t remote_oob_signature[OOB_SIGNATURE_LEN];\r\
    \n-        memcpy(&remote_random,\r\n-               &evt->data.evt_gatt_server_user_write_request.value.data[0],\r\
    \n-               sizeof(remote_random));\r\n-        memcpy(&remote_confirm,\r\
    \n-               &evt->data.evt_gatt_server_user_write_request.value.data[16],\r\
    \n-               sizeof(remote_confirm));\r\n-        memcpy(&remote_oob_signature,\r\
    \n-               &evt->data.evt_gatt_server_user_write_request.value.data[32],\r\
    \n-               OOB_SIGNATURE_LEN);\r\n-\r\n-        sc = sl_bt_gatt_server_send_user_write_response(evt->data.evt_gatt_server_user_write_request.connection,\r\
    \n-                                                        evt->data.evt_gatt_server_user_write_request.characteristic,\r\
    \n-                                                        SL_STATUS_OK);\r\n\
    -        app_assert_status(sc);\r\n-\r\n-        sl_bt_cbap_log_debug(\"Remote\
    \ OOB data:\" APP_LOG_NL);\r\n-        sl_bt_cbap_log_hexdump(&remote_random,\
    \ sizeof(aes_key_128));\r\n-        sl_bt_cbap_log_debug(APP_LOG_NL);\r\n-   \
    \     sl_bt_cbap_log_hexdump(&remote_confirm, sizeof(aes_key_128));\r\n-     \
    \   sl_bt_cbap_log_debug(APP_LOG_NL);\r\n-        sl_bt_cbap_log_debug(\"Remote\
    \ OOB signature:\" APP_LOG_NL);\r\n-        sl_bt_cbap_log_hexdump(&remote_oob_signature,\
    \ OOB_SIGNATURE_LEN);\r\n-        sl_bt_cbap_log_debug(APP_LOG_NL);\r\n-\r\n-\
    \        sc = sl_bt_cbap_lib_verify_remote_oob_data(remote_random.data,\r\n- \
    \                                                  remote_confirm.data,\r\n- \
    \                                                  remote_oob_signature);\r\n\
    -        app_assert_status(sc);\r\n-        sl_bt_cbap_log_info(\"Remote OOB data\
    \ verified.\" APP_LOG_NL);\r\n-        sc = sl_bt_sm_set_remote_oob(1, remote_random,\
    \ remote_confirm);\r\n-        app_assert_status(sc);\r\n-        sc = sl_bt_cbap_destroy_key();\r\
    \n-        app_assert_status(sc);\r\n-\r\n-        app_assert(cbap_peripheral_state\
    \ == SL_BT_CBAP_PERIPHERAL_CENTRAL_CERT_OK,\r\n-                   \"Unexpected\
    \ peripheral state.\");\r\n-        cbap_peripheral_state = SL_BT_CBAP_PERIPHERAL_CENTRAL_OOB_OK;\r\
    \n-        sl_bt_cbap_peripheral_on_event(cbap_peripheral_state);\r\n-       \
    \ set_timeout(true);\r\n-      }\r\n-      break;\r\n-\r\n-    case sl_bt_evt_gatt_server_characteristic_status_id:\r\
    \n-      if (evt->data.evt_gatt_server_characteristic_status.connection != connection)\
    \ {\r\n-        break;\r\n-      }\r\n-\r\n-      if (gattdb_peripheral_cert ==\
    \ evt->data.evt_gatt_server_characteristic_status.characteristic) {\r\n-     \
    \   if (sl_bt_gatt_server_client_config == (sl_bt_gatt_server_characteristic_status_flag_t)evt->data.evt_gatt_server_characteristic_status.status_flags)\
    \ {\r\n-          if (sl_bt_gatt_indication == (sl_bt_gatt_client_config_flag_t)evt->data.evt_gatt_server_characteristic_status.client_config_flags\r\
    \n-              && device_cert_sent == false) {\r\n-            uint8_t buff[CERT_IND_CHUNK_LEN\
    \ + 1];\r\n-            buff[0] = 1;\r\n-            memcpy(&buff[1], device_certificate_der,\
    \ CERT_IND_CHUNK_LEN);\r\n-            sc = sl_bt_gatt_server_send_indication(connection,\r\
    \n-                                                   gattdb_peripheral_cert,\r\
    \n-                                                   CERT_IND_CHUNK_LEN + 1,\r\
    \n-                                                   buff);\r\n-            app_assert_status(sc);\r\
    \n-            dev_cert_sending_progression += CERT_IND_CHUNK_LEN;\r\n-      \
    \    }\r\n-        }\r\n-        // Sending Peripheral certificate to Central\
    \ device\r\n-        else if (sl_bt_gatt_server_confirmation == (sl_bt_gatt_server_characteristic_status_flag_t)evt->data.evt_gatt_server_characteristic_status.status_flags)\
    \ {\r\n-          if (device_cert_sent == false) {\r\n-            uint32_t remaining\
    \ = device_certificate_der_len - dev_cert_sending_progression;\r\n-          \
    \  uint8_t buff[CERT_IND_CHUNK_LEN + 1];\r\n-            uint8_t len = 0;\r\n\
    -            if (remaining > CERT_IND_CHUNK_LEN) {\r\n-              buff[0] =\
    \ 1;\r\n-              len = CERT_IND_CHUNK_LEN + 1;\r\n-            } else {\r\
    \n-              // Send last chunk\r\n-              buff[0] = 0;\r\n-      \
    \        len = remaining + 1;\r\n-              device_cert_sent = true;\r\n-\
    \            }\r\n-            memcpy(&buff[1], &device_certificate_der[dev_cert_sending_progression],\
    \ len - 1);\r\n-            dev_cert_sending_progression += len - 1;\r\n-    \
    \        sc = sl_bt_gatt_server_send_indication(connection,\r\n-             \
    \                                      gattdb_peripheral_cert,\r\n-          \
    \                                         len,\r\n-                          \
    \                         buff);\r\n-            app_assert_status(sc);\r\n- \
    \         }\r\n-        }\r\n-      }\r\n-      // Sending Peripheral OOB data\
    \ to Central device\r\n-      else if (gattdb_peripheral_oob == evt->data.evt_gatt_server_characteristic_status.characteristic\
    \ ) {\r\n-        if (sl_bt_gatt_server_client_config == (sl_bt_gatt_server_characteristic_status_flag_t)evt->data.evt_gatt_server_characteristic_status.status_flags\r\
    \n-            && sl_bt_gatt_indication == (sl_bt_gatt_client_config_flag_t)evt->data.evt_gatt_server_characteristic_status.client_config_flags)\
    \ {\r\n-          aes_key_128 device_random;\r\n-          aes_key_128 device_confirm;\r\
    \n-          // Generate device oob data and send over GATT\r\n-          sc =\
    \ sl_bt_sm_set_oob(1, &device_random, &device_confirm);\r\n-          app_assert_status(sc);\r\
    \n-\r\n-          sl_bt_cbap_log_debug(\"Device OOB Data:\" APP_LOG_NL);\r\n-\
    \          sl_bt_cbap_log_hexdump(&device_random, OOB_RANDOM_LEN);\r\n-      \
    \    sl_bt_cbap_log_debug(APP_LOG_NL);\r\n-          sl_bt_cbap_log_hexdump(&device_confirm,\
    \ OOB_RANDOM_LEN);\r\n-          sl_bt_cbap_log_debug(APP_LOG_NL);\r\n-\r\n- \
    \         sc = sl_bt_cbap_lib_sign_device_oob_data(device_random.data,\r\n-  \
    \                                                 device_confirm.data,\r\n-  \
    \                                                 signed_device_oob_data,\r\n\
    -                                                   &signed_device_oob_len);\r\
    \n-          app_assert_status(sc);\r\n-\r\n-          sl_bt_cbap_log_debug(\"\
    Device OOB Signature:\" APP_LOG_NL);\r\n-          sl_bt_cbap_log_hexdump(&signed_device_oob_data[OOB_DATA_LEN],\r\
    \n-                                 OOB_SIGNATURE_LEN);\r\n-\r\n-          sl_bt_cbap_log_debug(APP_LOG_NL);\r\
    \n-\r\n-          sc = sl_bt_gatt_server_send_indication(connection,\r\n-    \
    \                                             gattdb_peripheral_oob,\r\n-    \
    \                                             signed_device_oob_len,\r\n-    \
    \                                             signed_device_oob_data);\r\n-  \
    \        app_assert_status(sc);\r\n-        }\r\n-      }\r\n-      break;\r\n\
    -  }\r\n-}\r\n-\r\n-/*******************************************************************************\r\
    \n- * Central device bluetooth event handler.\r\n- ******************************************************************************/\r\
    \n-static void on_event_central(sl_bt_msg_t *evt)\r\n-{\r\n-  sl_status_t sc;\r\
    \n-  // Handle stack events\r\n-  switch (SL_BT_MSG_ID(evt->header)) {\r\n-  \
    \  //--------------------------------\r\n-    // Triggered whenever the connection\
    \ parameters are changed\r\n-    case sl_bt_evt_connection_parameters_id:\r\n\
    -      if (evt->data.evt_connection_parameters.connection != connection) {\r\n\
    -        break;\r\n-      }\r\n-\r\n-      sl_bt_cbap_log_debug(\"Security mode:\
    \ %i\" APP_LOG_NL, evt->data.evt_connection_parameters.security_mode);\r\n-  \
    \    if (evt->data.evt_connection_parameters.security_mode > sl_bt_connection_mode1_level1\r\
    \n-          && cbap_central_state != SL_BT_CBAP_CENTRAL_INCREASE_SECURITY) {\r\
    \n-        sl_bt_cbap_log_error(\"Security level has been increased with no CBAP.\
    \ \" \\\r\n-                             \"Disconnecting.\" APP_LOG_NL);\r\n-\
    \        sl_bt_on_cbap_error();\r\n-        cbap_reset();\r\n-        break;\r\
    \n-      }\r\n-\r\n-      if (evt->data.evt_connection_parameters.security_mode\
    \ == sl_bt_connection_mode1_level4) {\r\n-        cbap_central_state = SL_BT_CBAP_CENTRAL_DONE;\r\
    \n-        sl_bt_cbap_central_on_event(cbap_central_state);\r\n-        cbap_reset();\r\
    \n-      }\r\n-      break;\r\n-\r\n-    // -------------------------------\r\n\
    -    // This event is generated when a new service is discovered\r\n-    case\
    \ sl_bt_evt_gatt_service_id:\r\n-      if (evt->data.evt_gatt_service.connection\
    \ != connection) {\r\n-        break;\r\n-      }\r\n-\r\n-      if (cbap_service_handle\
    \ == HANDLE_NOT_INITIALIZED) {\r\n-        // Save service handle for future reference\r\
    \n-        cbap_service_handle = evt->data.evt_gatt_service.service;\r\n-    \
    \    sl_bt_cbap_log_debug(\"Service handle found: %i\" APP_LOG_NL,\r\n-      \
    \                       (int)cbap_service_handle);\r\n-      }\r\n-      break;\r\
    \n-\r\n-    // -------------------------------\r\n-    // This event is generated\
    \ when a new characteristic is discovered\r\n-    case sl_bt_evt_gatt_characteristic_id:\r\
    \n-      if (evt->data.evt_gatt_characteristic.connection != connection) {\r\n\
    -        break;\r\n-      }\r\n-\r\n-      if (cbap_characteristics[char_state].handle\
    \ == HANDLE_NOT_INITIALIZED) {\r\n-        // Save characteristic handle for future\
    \ reference\r\n-        cbap_characteristics[char_state].handle = evt->data.evt_gatt_characteristic.characteristic;\r\
    \n-        sl_bt_cbap_log_debug(\"Characteristic handle found: %i\" APP_LOG_NL,\r\
    \n-                             cbap_characteristics[char_state].handle);\r\n\
    -      }\r\n-      break;\r\n-\r\n-    // -------------------------------\r\n\
    -    // This event is generated for various procedure completions, e.g. when a\r\
    \n-    // write procedure is completed, or service discovery is completed\r\n\
    -    case sl_bt_evt_gatt_procedure_completed_id:\r\n-      if (evt->data.evt_gatt_procedure_completed.connection\
    \ != connection) {\r\n-        break;\r\n-      }\r\n-\r\n-      // Check result\r\
    \n-      if (evt->data.evt_gatt_procedure_completed.result != 0) {\r\n-      \
    \  sl_bt_cbap_log_error(\"GATT procedure failed [E:%i]. Disconnecting.\" APP_LOG_NL,\r\
    \n-                             evt->data.evt_gatt_procedure_completed.result);\r\
    \n-        sl_bt_on_cbap_error();\r\n-        cbap_reset();\r\n-        break;\r\
    \n-      }\r\n-\r\n-      switch (cbap_central_state) {\r\n-        case SL_BT_CBAP_CENTRAL_DISCOVER_SERVICES:\
    \ {\r\n-          // Continue by finding the characteristics under the CBAP service.\r\
    \n-          char_state = (characteristics_t)0; // Start with the first characteristic\r\
    \n-          sc = sl_bt_gatt_discover_characteristics_by_uuid(evt->data.evt_gatt_procedure_completed.connection,\r\
    \n-                                                           cbap_service_handle,\r\
    \n-                                                           sizeof(cbap_characteristics[char_state].uuid),\r\
    \n-                                                           (const uint8_t *)cbap_characteristics[char_state].uuid);\r\
    \n-          app_assert_status(sc);\r\n-          cbap_central_state = SL_BT_CBAP_CENTRAL_DISCOVER_CHARACTERISTICS;\r\
    \n-          sl_bt_cbap_central_on_event(cbap_central_state);\r\n-          set_timeout(true);\r\
    \n-          break;\r\n-        }\r\n-\r\n-        case SL_BT_CBAP_CENTRAL_DISCOVER_CHARACTERISTICS:\
    \ {\r\n-          char_state++;\r\n-          if (char_state < CHAR_NUM) {\r\n\
    -            // Find the next characteristic\r\n-            sc = sl_bt_gatt_discover_characteristics_by_uuid(evt->data.evt_gatt_procedure_completed.connection,\r\
    \n-                                                             cbap_service_handle,\r\
    \n-                                                             sizeof(cbap_characteristics[char_state].uuid),\r\
    \n-                                                             (const uint8_t\
    \ *)cbap_characteristics[char_state].uuid);\r\n-            app_assert_status(sc);\r\
    \n-          } else {\r\n-            // Get Peripheral certificates\r\n-    \
    \        sc = sl_bt_gatt_set_characteristic_notification(evt->data.evt_gatt_procedure_completed.connection,\r\
    \n-                                                            cbap_characteristics[CHAR_PERIPHERAL_CERT].handle,\r\
    \n-                                                            sl_bt_gatt_indication);\r\
    \n-            app_assert_status(sc);\r\n-            cbap_central_state = SL_BT_CBAP_CENTRAL_GET_PERIPHERAL_CERT;\r\
    \n-            sl_bt_cbap_central_on_event(cbap_central_state);\r\n-         \
    \   set_timeout(true);\r\n-          }\r\n-          break;\r\n-        }\r\n\
    -\r\n-        case SL_BT_CBAP_CENTRAL_SEND_CENTRAL_CERT: {\r\n-          if (!device_cert_sent)\
    \ {\r\n-            uint32_t remaining = device_certificate_der_len\r\n-     \
    \                            - dev_cert_sending_progression;\r\n-            uint8_t\
    \ buff[CERT_IND_CHUNK_LEN + 1];\r\n-            uint8_t len = 0;\r\n-        \
    \    if (remaining > CERT_IND_CHUNK_LEN) {\r\n-              buff[0] = 1;\r\n\
    -              memcpy(&buff[1],\r\n-                     &device_certificate_der[dev_cert_sending_progression],\r\
    \n-                     CERT_IND_CHUNK_LEN);\r\n-              dev_cert_sending_progression\
    \ += CERT_IND_CHUNK_LEN;\r\n-              len = CERT_IND_CHUNK_LEN + 1;\r\n-\
    \            } else {\r\n-              // Last chunk\r\n-              buff[0]\
    \ = 0;\r\n-              memcpy(&buff[1],\r\n-                     &device_certificate_der[dev_cert_sending_progression],\r\
    \n-                     remaining);\r\n-              len = remaining + 1;\r\n\
    -              device_cert_sent = true;\r\n-            }\r\n-            sc =\
    \ sl_bt_gatt_write_characteristic_value(connection,\r\n-                     \
    \                                  cbap_characteristics[CHAR_CENTRAL_CERT].handle,\r\
    \n-                                                       len,\r\n-          \
    \                                             buff);\r\n-            app_assert_status(sc);\r\
    \n-          } else {\r\n-            // If certificate exchange completed get\
    \ OOB data. Enable indication.\r\n-            sc = sl_bt_gatt_set_characteristic_notification(evt->data.evt_gatt_procedure_completed.connection,\r\
    \n-                                                            cbap_characteristics[CHAR_PERIPHERAL_OOB].handle,\r\
    \n-                                                            sl_bt_gatt_indication);\r\
    \n-            app_assert_status(sc);\r\n-            aes_key_128 device_random;\r\
    \n-            aes_key_128 device_confirm;\r\n-            // Generate device\
    \ oob data and send over GATT\r\n-            sc = sl_bt_sm_set_oob(1, &device_random,\
    \ &device_confirm);\r\n-            app_assert_status(sc);\r\n-\r\n-         \
    \   sl_bt_cbap_log_debug(\"Device OOB Data:\" APP_LOG_NL);\r\n-            sl_bt_cbap_log_hexdump(&device_random,\
    \ OOB_RANDOM_LEN);\r\n-            sl_bt_cbap_log_debug(APP_LOG_NL);\r\n-    \
    \        sl_bt_cbap_log_hexdump(&device_confirm, OOB_RANDOM_LEN);\r\n-       \
    \     sl_bt_cbap_log_debug(APP_LOG_NL);\r\n-\r\n-            sc = sl_bt_cbap_lib_sign_device_oob_data(device_random.data,\r\
    \n-                                                     device_confirm.data,\r\
    \n-                                                     signed_device_oob_data,\r\
    \n-                                                     &signed_device_oob_len);\r\
    \n-            app_assert_status(sc);\r\n-\r\n-            sl_bt_cbap_log_debug(\"\
    Device OOB Signature:\" APP_LOG_NL);\r\n-            sl_bt_cbap_log_hexdump(&signed_device_oob_data[OOB_DATA_LEN],\r\
    \n-                                   OOB_SIGNATURE_LEN);\r\n-            sl_bt_cbap_log_debug(APP_LOG_NL);\r\
    \n-\r\n-            cbap_central_state = SL_BT_CBAP_CENTRAL_GET_PERIPHERAL_OOB;\r\
    \n-            sl_bt_cbap_central_on_event(cbap_central_state);\r\n-         \
    \   set_timeout(true);\r\n-          }\r\n-          break;\r\n-        }\r\n\
    -\r\n-        case SL_BT_CBAP_CENTRAL_SEND_OOB: {\r\n-          sc = sl_bt_gatt_write_characteristic_value(connection,\r\
    \n-                                                     cbap_characteristics[CHAR_CENTRAL_OOB].handle,\r\
    \n-                                                     signed_device_oob_len,\r\
    \n-                                                     signed_device_oob_data);\r\
    \n-          app_assert_status(sc);\r\n-\r\n-          // Request OOB data from\
    \ both device\r\n-          sc = sl_bt_sm_configure(SL_BT_SM_CONFIGURATION_OOB_FROM_BOTH_DEVICES_REQUIRED,\r\
    \n-                                  sl_bt_sm_io_capability_noinputnooutput);\r\
    \n-          app_assert_status(sc);\r\n-          sc = sl_bt_sm_increase_security(connection);\r\
    \n-          app_assert_status(sc);\r\n-\r\n-          cbap_central_state = SL_BT_CBAP_CENTRAL_INCREASE_SECURITY;\r\
    \n-          sl_bt_cbap_central_on_event(cbap_central_state);\r\n-          set_timeout(true);\r\
    \n-          break;\r\n-        }\r\n-\r\n-        default: {\r\n-          break;\r\
    \n-        }\r\n-      }\r\n-      break;\r\n-\r\n-    // -------------------------------\r\
    \n-    // This event is generated when a characteristic value was received e.g.\
    \ an indication\r\n-    case sl_bt_evt_gatt_characteristic_value_id:\r\n-    \
    \  if (evt->data.evt_gatt_characteristic_value.connection != connection) {\r\n\
    -        break;\r\n-      }\r\n-\r\n-      if (cbap_central_state == SL_BT_CBAP_CENTRAL_GET_PERIPHERAL_CERT)\
    \ {\r\n-        memcpy(&remote_certificate_der[remote_certificate_der_len],\r\n\
    -               &evt->data.evt_gatt_characteristic_value.value.data[1],\r\n- \
    \              evt->data.evt_gatt_characteristic_value.value.len - 1);\r\n-  \
    \      remote_certificate_der_len += evt->data.evt_gatt_characteristic_value.value.len\
    \ - 1;\r\n-        sc = sl_bt_gatt_send_characteristic_confirmation(evt->data.evt_gatt_characteristic_value.connection);\r\
    \n-        app_assert_status(sc);\r\n-        if (evt->data.evt_gatt_characteristic_value.value.data[0]\
    \ == 0) {\r\n-          // Last chunk stop indication\r\n-          sc = sl_bt_gatt_set_characteristic_notification(connection,\r\
    \n-                                                          cbap_characteristics[CHAR_PERIPHERAL_CERT].handle,\r\
    \n-                                                          sl_bt_gatt_disable);\r\
    \n-          app_assert_status(sc);\r\n-\r\n-          remote_cert_arrived = true;\r\
    \n-          cbap_central_state = SL_BT_CBAP_CENTRAL_SEND_CENTRAL_CERT;\r\n- \
    \         sl_bt_cbap_central_on_event(cbap_central_state);\r\n-          set_timeout(true);\r\
    \n-\r\n-          sc = sl_bt_cbap_lib_process_remote_cert(remote_certificate_der,\r\
    \n-                                                  remote_certificate_der_len);\r\
    \n-          if (sc == SL_STATUS_OK) {\r\n-            sl_bt_cbap_log_info(\"\
    Remote certificate verified.\" APP_LOG_NL);\r\n-          } else {\r\n-      \
    \      sl_bt_cbap_log_error(\"Remote certificate verification failed. \" \\\r\n\
    -                                 \"Disconnecting.\" APP_LOG_NL);\r\n-       \
    \     sl_bt_on_cbap_error();\r\n-            cbap_reset();\r\n-            break;\r\
    \n-          }\r\n-        }\r\n-      } else if (cbap_central_state == SL_BT_CBAP_CENTRAL_GET_PERIPHERAL_OOB)\
    \ {\r\n-        aes_key_128 remote_random;\r\n-        aes_key_128 remote_confirm;\r\
    \n-        uint8_t remote_oob_signature[OOB_SIGNATURE_LEN];\r\n-        memcpy(&remote_random,\r\
    \n-               &evt->data.evt_gatt_characteristic_value.value.data[0],\r\n\
    -               sizeof(aes_key_128));\r\n-        memcpy(&remote_confirm,\r\n\
    -               &evt->data.evt_gatt_characteristic_value.value.data[16],\r\n-\
    \               sizeof(aes_key_128));\r\n-        memcpy(&remote_oob_signature,\r\
    \n-               &evt->data.evt_gatt_server_user_write_request.value.data[32],\r\
    \n-               OOB_SIGNATURE_LEN);\r\n-        sc = sl_bt_gatt_send_characteristic_confirmation(evt->data.evt_gatt_characteristic_value.connection);\r\
    \n-        app_assert_status(sc);\r\n-        cbap_central_state = SL_BT_CBAP_CENTRAL_SEND_OOB;\r\
    \n-        sl_bt_cbap_central_on_event(cbap_central_state);\r\n-        set_timeout(true);\r\
    \n-        sc = sl_bt_gatt_set_characteristic_notification(connection,\r\n-  \
    \                                                      cbap_characteristics[CHAR_PERIPHERAL_OOB].handle,\r\
    \n-                                                        sl_bt_gatt_disable);\r\
    \n-        app_assert_status(sc);\r\n-\r\n-        sl_bt_cbap_log_debug(\"Remote\
    \ OOB data:\" APP_LOG_NL);\r\n-        sl_bt_cbap_log_hexdump(&remote_random,\
    \ sizeof(aes_key_128));\r\n-        sl_bt_cbap_log_debug(APP_LOG_NL);\r\n-   \
    \     sl_bt_cbap_log_hexdump(&remote_confirm, sizeof(aes_key_128));\r\n-     \
    \   sl_bt_cbap_log_debug(APP_LOG_NL);\r\n-        sl_bt_cbap_log_debug(\"Remote\
    \ OOB signature:\" APP_LOG_NL);\r\n-        sl_bt_cbap_log_hexdump(&remote_oob_signature,\
    \ OOB_SIGNATURE_LEN);\r\n-        sl_bt_cbap_log_debug(APP_LOG_NL);\r\n-\r\n-\
    \        sc = sl_bt_cbap_lib_verify_remote_oob_data(remote_random.data,\r\n- \
    \                                                  remote_confirm.data,\r\n- \
    \                                                  remote_oob_signature);\r\n\
    -        app_assert_status(sc);\r\n-        sl_bt_cbap_log_info(\"Remote OOB data\
    \ verified.\" APP_LOG_NL);\r\n-        sc = sl_bt_sm_set_remote_oob(1, remote_random,\
    \ remote_confirm);\r\n-        app_assert_status(sc);\r\n-        sc = sl_bt_cbap_destroy_key();\r\
    \n-        app_assert_status(sc);\r\n-      }\r\n-      break;\r\n-  }\r\n-}\r\
    \n-\r\n-/***************************************************************************//**\r\
    \n- * Reset CBAP process states, flags and timers.\r\n- ******************************************************************************/\r\
    \n-static void cbap_reset(void)\r\n-{\r\n-  set_timeout(false); // Make sure timer\
    \ is stopped\r\n-  connection = SL_BT_INVALID_CONNECTION_HANDLE; // Clear connection\
    \ handle\r\n-  // Reset states\r\n-  cbap_peripheral_state = (sl_bt_cbap_peripheral_state_t)0;\r\
    \n-  sl_bt_cbap_peripheral_on_event(cbap_peripheral_state);\r\n-  cbap_central_state\
    \ = (sl_bt_cbap_central_state_t)0;\r\n-  sl_bt_cbap_central_on_event(cbap_central_state);\r\
    \n-  char_state = (characteristics_t)0;\r\n-  // Reset flags\r\n-  remote_cert_arrived\
    \ = false;\r\n-  device_cert_sent = false;\r\n-  remote_certificate_der_len =\
    \ 0;\r\n-  dev_cert_sending_progression = 0;\r\n-}\r\n-\r\n-/*******************************************************************************\r\
    \n- * Search for a Service UUID in scan report.\r\n- *\r\n- * @param[in] scan_data\
    \ Data received in scanner advertisement report event\r\n- * @param[in] scan_data_len\
    \ Length of the scan data\r\n- * @param[in] uuid Service UUID to search for\r\n\
    - * @param[in] uuid_len Service UUID length\r\n- * @return true if the service\
    \ is found\r\n- ******************************************************************************/\r\
    \n-static bool find_service_in_advertisement(const uint8_t *scan_data,\r\n-  \
    \                                        uint8_t scan_data_len,\r\n-         \
    \                                 const uint8_t *uuid,\r\n-                  \
    \                        uint8_t uuid_len)\r\n-{\r\n-  uint8_t ad_field_length;\r\
    \n-  uint8_t ad_field_type;\r\n-  uint8_t i = 0;\r\n-\r\n-  while (i < scan_data_len)\
    \ {\r\n-    // Parse advertisement packet\r\n-    ad_field_length = scan_data[i];\
    \  // Not counting the length byte itself\r\n-    ad_field_type = scan_data[i\
    \ + 1];\r\n-    if ((uuid_len == UUID_16_LEN && (ad_field_type == GAP_INCOMPLETE_16B_UUID\r\
    \n-                                     || ad_field_type == GAP_COMPLETE_16B_UUID))\r\
    \n-        || (uuid_len == UUID_128_LEN && (ad_field_type == GAP_INCOMPLETE_128B_UUID\r\
    \n-                                         || ad_field_type == GAP_COMPLETE_128B_UUID)))\
    \ {\r\n-      // Packet containing the list of complete/incomplete 16/128-bit\
    \ services found.\r\n-      // Loop through the UUID list\r\n-      uint8_t j\
    \ = 2;\r\n-      while (j < ad_field_length + 1) {\r\n-        // Compare payload.\r\
    \n-        if (memcmp(&scan_data[i + j], uuid, uuid_len) == 0) {\r\n-        \
    \  return true;\r\n-        }\r\n-        // Advance to the next UUID\r\n-   \
    \     j += uuid_len;\r\n-      }\r\n-    }\r\n-    // Advance to the next packet\r\
    \n-    i += ad_field_length + 1;\r\n-  }\r\n-  return false;\r\n-}\r\n-\r\n-/***************************************************************************//**\r\
    \n- * Start or stop timer for timeout check.\r\n- * @param[in] activate If true\
    \ timer will start for timeout check\r\n- ******************************************************************************/\r\
    \n-static void set_timeout(bool activate)\r\n-{\r\n-  sl_status_t sc;\r\n-  if\
    \ (activate) {\r\n-    // Start or restart timer to timeout check\r\n-    sc =\
    \ sl_simple_timer_start(&state_timer,\r\n-                               TIMEOUT,\r\
    \n-                               state_timer_cb,\r\n-                       \
    \        NO_CALLBACK_DATA,\r\n-                               false);\r\n-   \
    \ app_assert_status(sc);\r\n-  } else {\r\n-    // Stop timer\r\n-    sc = sl_simple_timer_stop(&state_timer);\r\
    \n-    app_assert_status(sc);\r\n-  }\r\n-}\r\n-\r\n-/***************************************************************************//**\r\
    \n- * Timer Callback.\r\n- * @param[in] handle pointer to handle instance\r\n\
    - * @param[in] data pointer to input data\r\n- ******************************************************************************/\r\
    \n-static void state_timer_cb(sl_simple_timer_t *handle, void *data)\r\n-{\r\n\
    -  (void)handle;\r\n-  (void)data;\r\n-\r\n-  sl_bt_cbap_log_error(\"Timeout error.\
    \ Disconnecting.\" APP_LOG_NL);\r\n-  sl_bt_on_cbap_error();\r\n-  cbap_reset();\r\
    \n-}\r\n-\r\n-// CBAP Peripheral event handler WEAK implementation.\r\n-SL_WEAK\
    \ void sl_bt_cbap_peripheral_on_event(sl_bt_cbap_peripheral_state_t status)\r\n\
    -{\r\n-  (void)status;\r\n-}\r\n-\r\n-// CBAP Central event handler WEAK implementation.\r\
    \n-SL_WEAK void sl_bt_cbap_central_on_event(sl_bt_cbap_central_state_t status)\r\
    \n-{\r\n-  (void)status;\r\n-}\r\n-\r\n-// Callback to handle CBAP process errors.\r\
    \n-SL_WEAK void sl_bt_on_cbap_error(void)\r\n-{\r\n-  sl_status_t sc;\r\n-  sc\
    \ = sl_bt_connection_close(connection);\r\n-  app_assert_status(sc);\r\n-}\r\n\
    +/***************************************************************************//**\n\
    + * @file\n+ * @brief Certificate Based Authentication and Pairing implementation\n\
    + *******************************************************************************\n\
    + * # License\n+ * <b>Copyright 2022 Silicon Laboratories Inc. www.silabs.com</b>\n\
    + *******************************************************************************\n\
    + *\n+ * SPDX-License-Identifier: Zlib\n+ *\n+ * The licensor of this software\
    \ is Silicon Laboratories Inc.\n+ *\n+ * This software is provided 'as-is', without\
    \ any express or implied\n+ * warranty. In no event will the authors be held liable\
    \ for any damages\n+ * arising from the use of this software.\n+ *\n+ * Permission\
    \ is granted to anyone to use this software for any purpose,\n+ * including commercial\
    \ applications, and to alter it and redistribute it\n+ * freely, subject to the\
    \ following restrictions:\n+ *\n+ * 1. The origin of this software must not be\
    \ misrepresented; you must not\n+ *    claim that you wrote the original software.\
    \ If you use this software\n+ *    in a product, an acknowledgment in the product\
    \ documentation would be\n+ *    appreciated but is not required.\n+ * 2. Altered\
    \ source versions must be plainly marked as such, and must not be\n+ *    misrepresented\
    \ as being the original software.\n+ * 3. This notice may not be removed or altered\
    \ from any source distribution.\n+ *\n+ ******************************************************************************/\n\
    +\n+#include <stdbool.h>\n+#include \"em_common.h\"\n+#include \"em_system.h\"\
    \n+\n+#include \"app_assert.h\"\n+#include \"gatt_db.h\"\n+#include \"sl_bluetooth.h\"\
    \n+#include \"app_timer.h\"\n+#include \"sl_bt_cbap_config.h\"\n+#include \"sl_bt_cbap_root_cert.h\"\
    \n+#include \"sl_bt_cbap.h\"\n+#include \"sl_bt_cbap_lib.h\"\n+\n+#ifdef SL_COMPONENT_CATALOG_PRESENT\n\
    +#include \"sl_component_catalog.h\"\n+#endif // SL_COMPONENT_CATALOG_PRESENT\n\
    +#ifdef SL_CATALOG_APP_LOG_PRESENT\n+#include \"app_log.h\"\n+#endif // SL_CATALOG_APP_LOG_PRESENT\n\
    +\n+// -----------------------------------------------------------------------------\n\
    +// Defines\n+\n+#if defined(SL_CATALOG_APP_LOG_PRESENT) && SL_BT_CBAP_LOG\n+#define\
    \ sl_bt_cbap_log_debug(...)           app_log_debug(__VA_ARGS__)\n+#define sl_bt_cbap_log_info(...)\
    \            app_log_info(__VA_ARGS__)\n+#define sl_bt_cbap_log_error(...)   \
    \        app_log_error(__VA_ARGS__)\n+#define sl_bt_cbap_log_hexdump(p_data, len)\
    \ app_log_hexdump_debug(p_data, len)\n+#else\n+#define sl_bt_cbap_log_debug(...)\n\
    +#define sl_bt_cbap_log_info(...)\n+#define sl_bt_cbap_log_error(...)\n+#define\
    \ sl_bt_cbap_log_hexdump(p_data, len)\n+#endif\n+\n+#define IS_PERIPHERAL_IN_PROGRESS\
    \ (cbap_peripheral_state > 0 && cbap_peripheral_state < SL_BT_CBAP_PERIPHERAL_STATE_NUM\
    \ - 1)\n+#define IS_CENTRAL_IN_PROGRESS    (cbap_central_state > 0 && cbap_central_state\
    \ < SL_BT_CBAP_CENTRAL_STATE_NUM - 1)\n+\n+#define UUID_16_LEN               \
    \    2\n+#define UUID_128_LEN                  16\n+#define HANDLE_NOT_INITIALIZED\
    \        0\n+\n+#define GAP_INCOMPLETE_16B_UUID       0x02 // Incomplete List\
    \ of 16-bit Service Class UUIDs\n+#define GAP_COMPLETE_16B_UUID         0x03 //\
    \ Complete List of 16-bit Service Class UUIDs\n+#define GAP_INCOMPLETE_128B_UUID\
    \      0x06 // Incomplete List of 128-bit Service Class UUIDs\n+#define GAP_COMPLETE_128B_UUID\
    \        0x07 // Complete List of 128-bit Service Class UUIDs\n+\n+#define CHAIN_LINK_DATA_LEN\
    \           192  // Length of an NVM3 chunk\n+#define CHAIN_LINK_DATA_NUM    \
    \       4    // Number of how many chunks needed for a certificate\n+\n+#define\
    \ OOB_SIGNATURE_LEN             64\n+#define CERT_IND_CHUNK_LEN            100\n\
    +#define EC_PUB_KEY_LEN                65\n+#define PUB_KEY_OFFSET           \
    \     26\n+\n+#define OOB_RANDOM_LEN                (sizeof(aes_key_128))\n+#define\
    \ OOB_DATA_LEN                  (2 * OOB_RANDOM_LEN)\n+#define SIGNED_OOB_DATA_LEN\
    \           (OOB_DATA_LEN + OOB_SIGNATURE_LEN)\n+\n+#define TIMEOUT          \
    \             5000 // ms\n+#define NO_CALLBACK_DATA              (void *)NULL\
    \ // Callback has no parameters\n+\n+// -----------------------------------------------------------------------------\n\
    +// Type definitions.\n+\n+typedef struct characteristic_128_ref_s {\n+  uint16_t\
    \ handle;\n+  uint8_t uuid[UUID_128_LEN];\n+} characteristic_128_ref_t;\n+\n+typedef\
    \ enum {\n+  CHAR_CENTRAL_CERT,\n+  CHAR_PERIPHERAL_CERT,\n+  CHAR_CENTRAL_OOB,\n\
    +  CHAR_PERIPHERAL_OOB,\n+  CHAR_NUM\n+} characteristics_t;\n+\n+// -----------------------------------------------------------------------------\n\
    +// Module variables.\n+\n+// Device role\n+static sl_bt_cbap_role_t role;\n+\n\
    +// Handle of the active connection.\n+static uint8_t connection = SL_BT_INVALID_CONNECTION_HANDLE;\n\
    +\n+// Root certificate in PEM format.\n+const char *root_certificate_pem = SL_BT_CBAP_ROOT_CERT;\n\
    +\n+// Reference to the CBAP service.\n+static uint32_t cbap_service_handle =\
    \ HANDLE_NOT_INITIALIZED;\n+static const uint8_t cbap_service_uuid[] = {\n+  0x10,\
    \ 0x56, 0x28, 0xd0, 0x40, 0xdd, 0x8e, 0x91,\n+  0x4d, 0x41, 0x47, 0x81, 0xc6,\
    \ 0x8c, 0x81, 0xd8\n+};\n+\n+// Reference to the CBAP characteristics.\n+static\
    \ characteristic_128_ref_t cbap_characteristics[] = {\n+  {   // CHAR_CENTRAL_CERT\n\
    +    .handle = HANDLE_NOT_INITIALIZED,\n+    .uuid = {\n+      0xca, 0x25, 0xf3,\
    \ 0xa2, 0xf6, 0xda, 0xbd, 0xb6,\n+      0x69, 0x4a, 0xaa, 0x08, 0xf9, 0xd0, 0x5f,\
    \ 0x31\n+    }\n+  },\n+  {   // CHAR_PERIPHERAL_CERT\n+    .handle = HANDLE_NOT_INITIALIZED,\n\
    +    .uuid = {\n+      0x66, 0x50, 0xfd, 0x84, 0x4d, 0xad, 0xa2, 0x99,\n+    \
    \  0xc9, 0x4f, 0xf5, 0x16, 0x9e, 0xda, 0xf6, 0x0c\n+    }\n+  },\n+  {   // CHAR_CENTRAL_OOB\n\
    +    .handle = HANDLE_NOT_INITIALIZED,\n+    .uuid = {\n+      0x2c, 0x19, 0xf1,\
    \ 0xeb, 0x85, 0xcd, 0xb6, 0x8a,\n+      0x2c, 0x4e, 0x7d, 0x89, 0x51, 0x57, 0xd3,\
    \ 0xe8\n+    }\n+  },\n+  {   // CHAR_PERIPHERAL_OOB\n+    .handle = HANDLE_NOT_INITIALIZED,\n\
    +    .uuid = {\n+      0xab, 0x69, 0xb2, 0x5e, 0xb8, 0x41, 0xb3, 0x8b,\n+    \
    \  0x82, 0x41, 0x51, 0xa2, 0x41, 0xcb, 0x91, 0x69\n+    }\n+  }\n+};\n+\n+// State\
    \ of the central device\n+static sl_bt_cbap_central_state_t cbap_central_state\
    \ = SL_BT_CBAP_CENTRAL_SCANNING;\n+// Pointing to the characteristic that shall\
    \ be discovered next\n+static characteristics_t char_state = (characteristics_t)0;\n\
    +// State of the peripheral device\n+static sl_bt_cbap_peripheral_state_t cbap_peripheral_state\
    \ = SL_BT_CBAP_PERIPHERAL_IDLE;\n+\n+// Timer handle\n+static app_timer_t state_timer;\n\
    +\n+// Remote certificate which was sent over GATT in DER format\n+static uint8_t\
    \ remote_certificate_der[CHAIN_LINK_DATA_LEN * CHAIN_LINK_DATA_NUM] = { 0 };\n\
    +static uint32_t remote_certificate_der_len = 0;\n+static bool remote_cert_arrived\
    \ = false;\n+\n+// Device certificate in DER format\n+static uint8_t device_certificate_der[CHAIN_LINK_DATA_LEN\
    \ * CHAIN_LINK_DATA_NUM] = { 0 };\n+static uint32_t device_certificate_der_len\
    \ = 0;\n+static uint32_t dev_cert_sending_progression = 0;\n+static bool device_cert_sent\
    \ = false;\n+\n+static uint8_t signed_device_oob_data[SIGNED_OOB_DATA_LEN];\n\
    +static size_t signed_device_oob_len = 0;\n+\n+// -----------------------------------------------------------------------------\n\
    +// Private function declarations\n+\n+// Central device bluetooth event handler.\n\
    +static void on_event_peripheral(sl_bt_msg_t *evt);\n+// Peripheral device bluetooth\
    \ event handler.\n+static void on_event_central(sl_bt_msg_t *evt);\n+\n+// Reset\
    \ CBAP process states, flags and timers.\n+static void cbap_reset(void);\n+\n\
    +// Search for a Service UUID in scan report.\n+static bool find_service_in_advertisement(const\
    \ uint8_t *scan_data,\n+                                          uint8_t scan_data_len,\n\
    +                                          const uint8_t *uuid,\n+           \
    \                               uint8_t uuid_len);\n+\n+// Start or stop timer\
    \ for timeout check.\n+static void set_timeout(bool activate);\n+// Timer callback.\n\
    +static void state_timer_cb(app_timer_t *handle, void *data);\n+\n+// -----------------------------------------------------------------------------\n\
    +// Public function definitions\n+\n+// Initialize the component. Import and validate\
    \ the device and root certificate.\n+void sl_bt_cbap_init(void)\n+{\n+  sl_status_t\
    \ sc;\n+  sc = sl_bt_cbap_lib_init(root_certificate_pem,\n+                  \
    \         device_certificate_der,\n+                           &device_certificate_der_len);\n\
    +  app_assert_status(sc);\n+  sl_bt_cbap_log_info(\"Device certificate verified.\"\
    \ APP_LOG_NL);\n+\n+  cbap_reset();\n+}\n+\n+// Start CBAP procedure.\n+sl_status_t\
    \ sl_bt_cbap_start(sl_bt_cbap_role_t cbap_role,\n+                           \
    \  uint8_t connection_handle)\n+{\n+  sl_status_t sc;\n+  if (IS_PERIPHERAL_IN_PROGRESS\
    \ || IS_CENTRAL_IN_PROGRESS) {\n+    return SL_STATUS_IN_PROGRESS;\n+  }\n+\n\
    +  role = cbap_role;\n+  connection = connection_handle;\n+\n+  if (role == SL_BT_CBAP_ROLE_CENTRAL)\
    \ {\n+    // Discover CBAP service on the peripheral device\n+    sc = sl_bt_gatt_discover_primary_services_by_uuid(connection,\n\
    +                                                      sizeof(cbap_service_uuid),\n\
    +                                                      (const uint8_t *)cbap_service_uuid);\n\
    +    app_assert_status(sc);\n+    cbap_central_state = SL_BT_CBAP_CENTRAL_DISCOVER_SERVICES;\n\
    +    sl_bt_cbap_central_on_event(cbap_central_state);\n+  }\n+\n+  set_timeout(true);\n\
    +  return SL_STATUS_OK;\n+}\n+\n+// Bluetooth stack event handler.\n+void sli_bt_cbap_on_event(sl_bt_msg_t\
    \ *evt)\n+{\n+  switch (role) {\n+    case SL_BT_CBAP_ROLE_PERIPHERAL:\n+    \
    \  on_event_peripheral(evt);\n+      break;\n+    case SL_BT_CBAP_ROLE_CENTRAL:\n\
    +      on_event_central(evt);\n+      break;\n+  }\n+}\n+\n+// Search for a the\
    \ CBAP Service UUID in scan report.\n+bool sl_bt_cbap_find_service_in_advertisement(const\
    \ uint8_t *scan_data,\n+                                              uint8_t\
    \ scan_data_len)\n+{\n+  return find_service_in_advertisement(scan_data,\n+  \
    \                                     scan_data_len,\n+                      \
    \                 cbap_service_uuid,\n+                                      \
    \ sizeof(cbap_service_uuid));\n+}\n+\n+// -----------------------------------------------------------------------------\n\
    +// Private function definitions\n+\n+/*******************************************************************************\n\
    + * Peripheral device bluetooth event handler.\n+ ******************************************************************************/\n\
    +static void on_event_peripheral(sl_bt_msg_t *evt)\n+{\n+  sl_status_t sc;\n+\
    \  // Handle stack events\n+  switch (SL_BT_MSG_ID(evt->header)) {\n+    // This\
    \ event indicates the device has started and the radio is ready.\n+    // Do not\
    \ call any stack command before receiving this boot event!\n+    case sl_bt_evt_system_boot_id:\n\
    +      // Request OOB data from both device\n+      sc = sl_bt_sm_configure(SL_BT_SM_CONFIGURATION_OOB_FROM_BOTH_DEVICES_REQUIRED,\n\
    +                              sl_bt_sm_io_capability_noinputnooutput);\n+   \
    \   app_assert_status(sc);\n+      break;\n+\n+    //--------------------------------\n\
    +    // Triggered whenever the connection parameters are changed\n+    case sl_bt_evt_connection_parameters_id:\n\
    +      if (evt->data.evt_connection_parameters.connection != connection) {\n+\
    \        break;\n+      }\n+\n+      sl_bt_cbap_log_debug(\"Security mode: %i\"\
    \ APP_LOG_NL,\n+                           evt->data.evt_connection_parameters.security_mode);\n\
    +      if (evt->data.evt_connection_parameters.security_mode > sl_bt_connection_mode1_level1\n\
    +          && cbap_peripheral_state != SL_BT_CBAP_PERIPHERAL_CENTRAL_OOB_OK) {\n\
    +        sl_bt_cbap_log_error(\"The central device increased the security level\
    \ with \" \\\n+                             \"no CBAP. Disconnecting.\" APP_LOG_NL);\n\
    +        sl_bt_on_cbap_error();\n+        cbap_reset();\n+        break;\n+  \
    \    }\n+\n+      if (evt->data.evt_connection_parameters.security_mode == sl_bt_connection_mode1_level4)\
    \ {\n+        cbap_peripheral_state = SL_BT_CBAP_PERIPHERAL_DONE;\n+        sl_bt_cbap_peripheral_on_event(cbap_peripheral_state);\n\
    +        cbap_reset();\n+      }\n+      break;\n+\n+    case sl_bt_evt_gatt_server_user_write_request_id:\n\
    +      if (evt->data.evt_gatt_server_user_write_request.connection != connection)\
    \ {\n+        break;\n+      }\n+\n+      // Set default response parameters.\n\
    +      sc = SL_STATUS_BT_ATT_WRITE_REQUEST_REJECTED;\n+      // Receiving Certificate\
    \ from central device\n+      if (evt->data.evt_gatt_server_user_write_request.characteristic\
    \ == gattdb_central_cert) {\n+        if (remote_cert_arrived == false) {\n+ \
    \         // First byte indicates that it is a last packet or not\n+         \
    \ memcpy(&remote_certificate_der[remote_certificate_der_len],\n+             \
    \    &evt->data.evt_gatt_server_user_write_request.value.data[1],\n+         \
    \        evt->data.evt_gatt_server_user_write_request.value.len - 1);\n+     \
    \     remote_certificate_der_len += evt->data.evt_gatt_server_user_write_request.value.len\
    \ - 1;\n+          sc = SL_STATUS_OK;\n+          if (evt->data.evt_gatt_server_user_write_request.value.data[0]\
    \ == 0) {\n+            // Last packet of the remote cert arrived\n+         \
    \   sl_bt_cbap_log_info(\"Getting certificate from central.\" APP_LOG_NL);\n+\
    \            remote_cert_arrived = true;\n+            sc = sl_bt_cbap_lib_process_remote_cert(remote_certificate_der,\n\
    +                                                    remote_certificate_der_len);\n\
    +            if (sc == SL_STATUS_OK) {\n+              app_assert(cbap_peripheral_state\
    \ == SL_BT_CBAP_PERIPHERAL_IDLE,\n+                         \"Unexpected peripheral\
    \ state.\");\n+              cbap_peripheral_state = SL_BT_CBAP_PERIPHERAL_CENTRAL_CERT_OK;\n\
    +              sl_bt_cbap_peripheral_on_event(cbap_peripheral_state);\n+     \
    \         set_timeout(true);\n+            } else {\n+              sl_bt_cbap_log_error(\"\
    Remote certificate verification failed. \" \\\n+                             \
    \      \"Disconnecting.\" APP_LOG_NL);\n+              sl_bt_on_cbap_error();\n\
    +              cbap_reset();\n+              break;\n+            }\n+       \
    \   }\n+          // Map status code to a valid attribute error.\n+          if\
    \ (SL_STATUS_OK != sc) {\n+            sc = SL_STATUS_BT_ATT_WRITE_REQUEST_REJECTED;\n\
    +          }\n+        } else {\n+          sc = SL_STATUS_BT_ATT_PROCEDURE_ALREADY_IN_PROGRESS;\n\
    +        }\n+        sl_bt_gatt_server_send_user_write_response(evt->data.evt_gatt_server_user_write_request.connection,\n\
    +                                                   evt->data.evt_gatt_server_user_write_request.characteristic,\n\
    +                                                   (uint8_t)sc);\n+      }\n\
    +      // Receiving OOB data from central device\n+      else if (evt->data.evt_gatt_server_user_write_request.characteristic\
    \ == gattdb_central_oob ) {\n+        sl_bt_cbap_log_info(\"Getting OOB data from\
    \ central.\" APP_LOG_NL);\n+        aes_key_128 remote_random;\n+        aes_key_128\
    \ remote_confirm;\n+        uint8_t remote_oob_signature[OOB_SIGNATURE_LEN];\n\
    +        memcpy(&remote_random,\n+               &evt->data.evt_gatt_server_user_write_request.value.data[0],\n\
    +               sizeof(remote_random));\n+        memcpy(&remote_confirm,\n+ \
    \              &evt->data.evt_gatt_server_user_write_request.value.data[16],\n\
    +               sizeof(remote_confirm));\n+        memcpy(&remote_oob_signature,\n\
    +               &evt->data.evt_gatt_server_user_write_request.value.data[32],\n\
    +               OOB_SIGNATURE_LEN);\n+\n+        sc = sl_bt_gatt_server_send_user_write_response(evt->data.evt_gatt_server_user_write_request.connection,\n\
    +                                                        evt->data.evt_gatt_server_user_write_request.characteristic,\n\
    +                                                        SL_STATUS_OK);\n+   \
    \     app_assert_status(sc);\n+\n+        sl_bt_cbap_log_debug(\"Remote OOB data:\"\
    \ APP_LOG_NL);\n+        sl_bt_cbap_log_hexdump(&remote_random, sizeof(aes_key_128));\n\
    +        sl_bt_cbap_log_debug(APP_LOG_NL);\n+        sl_bt_cbap_log_hexdump(&remote_confirm,\
    \ sizeof(aes_key_128));\n+        sl_bt_cbap_log_debug(APP_LOG_NL);\n+       \
    \ sl_bt_cbap_log_debug(\"Remote OOB signature:\" APP_LOG_NL);\n+        sl_bt_cbap_log_hexdump(&remote_oob_signature,\
    \ OOB_SIGNATURE_LEN);\n+        sl_bt_cbap_log_debug(APP_LOG_NL);\n+\n+      \
    \  sc = sl_bt_cbap_lib_verify_remote_oob_data(remote_random.data,\n+         \
    \                                          remote_confirm.data,\n+           \
    \                                        remote_oob_signature);\n+        app_assert_status(sc);\n\
    +        sl_bt_cbap_log_info(\"Remote OOB data verified.\" APP_LOG_NL);\n+   \
    \     sc = sl_bt_sm_set_remote_oob(1, remote_random, remote_confirm);\n+     \
    \   app_assert_status(sc);\n+        sc = sl_bt_cbap_destroy_key();\n+       \
    \ app_assert_status(sc);\n+\n+        app_assert(cbap_peripheral_state == SL_BT_CBAP_PERIPHERAL_CENTRAL_CERT_OK,\n\
    +                   \"Unexpected peripheral state.\");\n+        cbap_peripheral_state\
    \ = SL_BT_CBAP_PERIPHERAL_CENTRAL_OOB_OK;\n+        sl_bt_cbap_peripheral_on_event(cbap_peripheral_state);\n\
    +        set_timeout(true);\n+      }\n+      break;\n+\n+    case sl_bt_evt_gatt_server_characteristic_status_id:\n\
    +      if (evt->data.evt_gatt_server_characteristic_status.connection != connection)\
    \ {\n+        break;\n+      }\n+\n+      if (gattdb_peripheral_cert == evt->data.evt_gatt_server_characteristic_status.characteristic)\
    \ {\n+        if (sl_bt_gatt_server_client_config == (sl_bt_gatt_server_characteristic_status_flag_t)evt->data.evt_gatt_server_characteristic_status.status_flags)\
    \ {\n+          if (sl_bt_gatt_indication == (sl_bt_gatt_client_config_flag_t)evt->data.evt_gatt_server_characteristic_status.client_config_flags\n\
    +              && device_cert_sent == false) {\n+            uint8_t buff[CERT_IND_CHUNK_LEN\
    \ + 1];\n+            buff[0] = 1;\n+            memcpy(&buff[1], device_certificate_der,\
    \ CERT_IND_CHUNK_LEN);\n+            sc = sl_bt_gatt_server_send_indication(connection,\n\
    +                                                   gattdb_peripheral_cert,\n\
    +                                                   CERT_IND_CHUNK_LEN + 1,\n\
    +                                                   buff);\n+            app_assert_status(sc);\n\
    +            dev_cert_sending_progression += CERT_IND_CHUNK_LEN;\n+          }\n\
    +        }\n+        // Sending Peripheral certificate to Central device\n+  \
    \      else if (sl_bt_gatt_server_confirmation == (sl_bt_gatt_server_characteristic_status_flag_t)evt->data.evt_gatt_server_characteristic_status.status_flags)\
    \ {\n+          if (device_cert_sent == false) {\n+            uint32_t remaining\
    \ = device_certificate_der_len - dev_cert_sending_progression;\n+            uint8_t\
    \ buff[CERT_IND_CHUNK_LEN + 1];\n+            uint8_t len = 0;\n+            if\
    \ (remaining > CERT_IND_CHUNK_LEN) {\n+              buff[0] = 1;\n+         \
    \     len = CERT_IND_CHUNK_LEN + 1;\n+            } else {\n+              //\
    \ Send last chunk\n+              buff[0] = 0;\n+              len = remaining\
    \ + 1;\n+              device_cert_sent = true;\n+            }\n+           \
    \ memcpy(&buff[1], &device_certificate_der[dev_cert_sending_progression], len\
    \ - 1);\n+            dev_cert_sending_progression += len - 1;\n+            sc\
    \ = sl_bt_gatt_server_send_indication(connection,\n+                         \
    \                          gattdb_peripheral_cert,\n+                        \
    \                           len,\n+                                          \
    \         buff);\n+            app_assert_status(sc);\n+          }\n+       \
    \ }\n+      }\n+      // Sending Peripheral OOB data to Central device\n+    \
    \  else if (gattdb_peripheral_oob == evt->data.evt_gatt_server_characteristic_status.characteristic\
    \ ) {\n+        if (sl_bt_gatt_server_client_config == (sl_bt_gatt_server_characteristic_status_flag_t)evt->data.evt_gatt_server_characteristic_status.status_flags\n\
    +            && sl_bt_gatt_indication == (sl_bt_gatt_client_config_flag_t)evt->data.evt_gatt_server_characteristic_status.client_config_flags)\
    \ {\n+          aes_key_128 device_random;\n+          aes_key_128 device_confirm;\n\
    +          // Generate device oob data and send over GATT\n+          sc = sl_bt_sm_set_oob(1,\
    \ &device_random, &device_confirm);\n+          app_assert_status(sc);\n+\n+ \
    \         sl_bt_cbap_log_debug(\"Device OOB Data:\" APP_LOG_NL);\n+          sl_bt_cbap_log_hexdump(&device_random,\
    \ OOB_RANDOM_LEN);\n+          sl_bt_cbap_log_debug(APP_LOG_NL);\n+          sl_bt_cbap_log_hexdump(&device_confirm,\
    \ OOB_RANDOM_LEN);\n+          sl_bt_cbap_log_debug(APP_LOG_NL);\n+\n+       \
    \   sc = sl_bt_cbap_lib_sign_device_oob_data(device_random.data,\n+          \
    \                                         device_confirm.data,\n+            \
    \                                       signed_device_oob_data,\n+           \
    \                                        &signed_device_oob_len);\n+         \
    \ app_assert_status(sc);\n+\n+          sl_bt_cbap_log_debug(\"Device OOB Signature:\"\
    \ APP_LOG_NL);\n+          sl_bt_cbap_log_hexdump(&signed_device_oob_data[OOB_DATA_LEN],\n\
    +                                 OOB_SIGNATURE_LEN);\n+\n+          sl_bt_cbap_log_debug(APP_LOG_NL);\n\
    +\n+          sc = sl_bt_gatt_server_send_indication(connection,\n+          \
    \                                       gattdb_peripheral_oob,\n+            \
    \                                     signed_device_oob_len,\n+              \
    \                                   signed_device_oob_data);\n+          app_assert_status(sc);\n\
    +        }\n+      }\n+      break;\n+  }\n+}\n+\n+/*******************************************************************************\n\
    + * Central device bluetooth event handler.\n+ ******************************************************************************/\n\
    +static void on_event_central(sl_bt_msg_t *evt)\n+{\n+  sl_status_t sc;\n+  //\
    \ Handle stack events\n+  switch (SL_BT_MSG_ID(evt->header)) {\n+    //--------------------------------\n\
    +    // Triggered whenever the connection parameters are changed\n+    case sl_bt_evt_connection_parameters_id:\n\
    +      if (evt->data.evt_connection_parameters.connection != connection) {\n+\
    \        break;\n+      }\n+\n+      sl_bt_cbap_log_debug(\"Security mode: %i\"\
    \ APP_LOG_NL, evt->data.evt_connection_parameters.security_mode);\n+      if (evt->data.evt_connection_parameters.security_mode\
    \ > sl_bt_connection_mode1_level1\n+          && cbap_central_state != SL_BT_CBAP_CENTRAL_INCREASE_SECURITY)\
    \ {\n+        sl_bt_cbap_log_error(\"Security level has been increased with no\
    \ CBAP. \" \\\n+                             \"Disconnecting.\" APP_LOG_NL);\n\
    +        sl_bt_on_cbap_error();\n+        cbap_reset();\n+        break;\n+  \
    \    }\n+\n+      if (evt->data.evt_connection_parameters.security_mode == sl_bt_connection_mode1_level4)\
    \ {\n+        cbap_central_state = SL_BT_CBAP_CENTRAL_DONE;\n+        sl_bt_cbap_central_on_event(cbap_central_state);\n\
    +        cbap_reset();\n+      }\n+      break;\n+\n+    // -------------------------------\n\
    +    // This event is generated when a new service is discovered\n+    case sl_bt_evt_gatt_service_id:\n\
    +      if (evt->data.evt_gatt_service.connection != connection) {\n+        break;\n\
    +      }\n+\n+      if (cbap_service_handle == HANDLE_NOT_INITIALIZED) {\n+  \
    \      // Save service handle for future reference\n+        cbap_service_handle\
    \ = evt->data.evt_gatt_service.service;\n+        sl_bt_cbap_log_debug(\"Service\
    \ handle found: %i\" APP_LOG_NL,\n+                             (int)cbap_service_handle);\n\
    +      }\n+      break;\n+\n+    // -------------------------------\n+    // This\
    \ event is generated when a new characteristic is discovered\n+    case sl_bt_evt_gatt_characteristic_id:\n\
    +      if (evt->data.evt_gatt_characteristic.connection != connection) {\n+  \
    \      break;\n+      }\n+\n+      if (cbap_characteristics[char_state].handle\
    \ == HANDLE_NOT_INITIALIZED) {\n+        // Save characteristic handle for future\
    \ reference\n+        cbap_characteristics[char_state].handle = evt->data.evt_gatt_characteristic.characteristic;\n\
    +        sl_bt_cbap_log_debug(\"Characteristic handle found: %i\" APP_LOG_NL,\n\
    +                             cbap_characteristics[char_state].handle);\n+   \
    \   }\n+      break;\n+\n+    // -------------------------------\n+    // This\
    \ event is generated for various procedure completions, e.g. when a\n+    // write\
    \ procedure is completed, or service discovery is completed\n+    case sl_bt_evt_gatt_procedure_completed_id:\n\
    +      if (evt->data.evt_gatt_procedure_completed.connection != connection) {\n\
    +        break;\n+      }\n+\n+      // Check result\n+      if (evt->data.evt_gatt_procedure_completed.result\
    \ != 0) {\n+        sl_bt_cbap_log_error(\"GATT procedure failed [E:%i]. Disconnecting.\"\
    \ APP_LOG_NL,\n+                             evt->data.evt_gatt_procedure_completed.result);\n\
    +        sl_bt_on_cbap_error();\n+        cbap_reset();\n+        break;\n+  \
    \    }\n+\n+      switch (cbap_central_state) {\n+        case SL_BT_CBAP_CENTRAL_DISCOVER_SERVICES:\
    \ {\n+          // Continue by finding the characteristics under the CBAP service.\n\
    +          char_state = (characteristics_t)0; // Start with the first characteristic\n\
    +          sc = sl_bt_gatt_discover_characteristics_by_uuid(evt->data.evt_gatt_procedure_completed.connection,\n\
    +                                                           cbap_service_handle,\n\
    +                                                           sizeof(cbap_characteristics[char_state].uuid),\n\
    +                                                           (const uint8_t *)cbap_characteristics[char_state].uuid);\n\
    +          app_assert_status(sc);\n+          cbap_central_state = SL_BT_CBAP_CENTRAL_DISCOVER_CHARACTERISTICS;\n\
    +          sl_bt_cbap_central_on_event(cbap_central_state);\n+          set_timeout(true);\n\
    +          break;\n+        }\n+\n+        case SL_BT_CBAP_CENTRAL_DISCOVER_CHARACTERISTICS:\
    \ {\n+          char_state++;\n+          if (char_state < CHAR_NUM) {\n+    \
    \        // Find the next characteristic\n+            sc = sl_bt_gatt_discover_characteristics_by_uuid(evt->data.evt_gatt_procedure_completed.connection,\n\
    +                                                             cbap_service_handle,\n\
    +                                                             sizeof(cbap_characteristics[char_state].uuid),\n\
    +                                                             (const uint8_t *)cbap_characteristics[char_state].uuid);\n\
    +            app_assert_status(sc);\n+          } else {\n+            // Get\
    \ Peripheral certificates\n+            sc = sl_bt_gatt_set_characteristic_notification(evt->data.evt_gatt_procedure_completed.connection,\n\
    +                                                            cbap_characteristics[CHAR_PERIPHERAL_CERT].handle,\n\
    +                                                            sl_bt_gatt_indication);\n\
    +            app_assert_status(sc);\n+            cbap_central_state = SL_BT_CBAP_CENTRAL_GET_PERIPHERAL_CERT;\n\
    +            sl_bt_cbap_central_on_event(cbap_central_state);\n+            set_timeout(true);\n\
    +          }\n+          break;\n+        }\n+\n+        case SL_BT_CBAP_CENTRAL_SEND_CENTRAL_CERT:\
    \ {\n+          if (!device_cert_sent) {\n+            uint32_t remaining = device_certificate_der_len\n\
    +                                 - dev_cert_sending_progression;\n+         \
    \   uint8_t buff[CERT_IND_CHUNK_LEN + 1];\n+            uint8_t len = 0;\n+  \
    \          if (remaining > CERT_IND_CHUNK_LEN) {\n+              buff[0] = 1;\n\
    +              memcpy(&buff[1],\n+                     &device_certificate_der[dev_cert_sending_progression],\n\
    +                     CERT_IND_CHUNK_LEN);\n+              dev_cert_sending_progression\
    \ += CERT_IND_CHUNK_LEN;\n+              len = CERT_IND_CHUNK_LEN + 1;\n+    \
    \        } else {\n+              // Last chunk\n+              buff[0] = 0;\n\
    +              memcpy(&buff[1],\n+                     &device_certificate_der[dev_cert_sending_progression],\n\
    +                     remaining);\n+              len = remaining + 1;\n+    \
    \          device_cert_sent = true;\n+            }\n+            sc = sl_bt_gatt_write_characteristic_value(connection,\n\
    +                                                       cbap_characteristics[CHAR_CENTRAL_CERT].handle,\n\
    +                                                       len,\n+              \
    \                                         buff);\n+            app_assert_status(sc);\n\
    +          } else {\n+            // If certificate exchange completed get OOB\
    \ data. Enable indication.\n+            sc = sl_bt_gatt_set_characteristic_notification(evt->data.evt_gatt_procedure_completed.connection,\n\
    +                                                            cbap_characteristics[CHAR_PERIPHERAL_OOB].handle,\n\
    +                                                            sl_bt_gatt_indication);\n\
    +            app_assert_status(sc);\n+            aes_key_128 device_random;\n\
    +            aes_key_128 device_confirm;\n+            // Generate device oob\
    \ data and send over GATT\n+            sc = sl_bt_sm_set_oob(1, &device_random,\
    \ &device_confirm);\n+            app_assert_status(sc);\n+\n+            sl_bt_cbap_log_debug(\"\
    Device OOB Data:\" APP_LOG_NL);\n+            sl_bt_cbap_log_hexdump(&device_random,\
    \ OOB_RANDOM_LEN);\n+            sl_bt_cbap_log_debug(APP_LOG_NL);\n+        \
    \    sl_bt_cbap_log_hexdump(&device_confirm, OOB_RANDOM_LEN);\n+            sl_bt_cbap_log_debug(APP_LOG_NL);\n\
    +\n+            sc = sl_bt_cbap_lib_sign_device_oob_data(device_random.data,\n\
    +                                                     device_confirm.data,\n+\
    \                                                     signed_device_oob_data,\n\
    +                                                     &signed_device_oob_len);\n\
    +            app_assert_status(sc);\n+\n+            sl_bt_cbap_log_debug(\"Device\
    \ OOB Signature:\" APP_LOG_NL);\n+            sl_bt_cbap_log_hexdump(&signed_device_oob_data[OOB_DATA_LEN],\n\
    +                                   OOB_SIGNATURE_LEN);\n+            sl_bt_cbap_log_debug(APP_LOG_NL);\n\
    +\n+            cbap_central_state = SL_BT_CBAP_CENTRAL_GET_PERIPHERAL_OOB;\n\
    +            sl_bt_cbap_central_on_event(cbap_central_state);\n+            set_timeout(true);\n\
    +          }\n+          break;\n+        }\n+\n+        case SL_BT_CBAP_CENTRAL_SEND_OOB:\
    \ {\n+          sc = sl_bt_gatt_write_characteristic_value(connection,\n+    \
    \                                                 cbap_characteristics[CHAR_CENTRAL_OOB].handle,\n\
    +                                                     signed_device_oob_len,\n\
    +                                                     signed_device_oob_data);\n\
    +          app_assert_status(sc);\n+\n+          // Request OOB data from both\
    \ device\n+          sc = sl_bt_sm_configure(SL_BT_SM_CONFIGURATION_OOB_FROM_BOTH_DEVICES_REQUIRED,\n\
    +                                  sl_bt_sm_io_capability_noinputnooutput);\n\
    +          app_assert_status(sc);\n+          sc = sl_bt_sm_increase_security(connection);\n\
    +          app_assert_status(sc);\n+\n+          cbap_central_state = SL_BT_CBAP_CENTRAL_INCREASE_SECURITY;\n\
    +          sl_bt_cbap_central_on_event(cbap_central_state);\n+          set_timeout(true);\n\
    +          break;\n+        }\n+\n+        default: {\n+          break;\n+  \
    \      }\n+      }\n+      break;\n+\n+    // -------------------------------\n\
    +    // This event is generated when a characteristic value was received e.g.\
    \ an indication\n+    case sl_bt_evt_gatt_characteristic_value_id:\n+      if\
    \ (evt->data.evt_gatt_characteristic_value.connection != connection) {\n+    \
    \    break;\n+      }\n+\n+      if (cbap_central_state == SL_BT_CBAP_CENTRAL_GET_PERIPHERAL_CERT)\
    \ {\n+        memcpy(&remote_certificate_der[remote_certificate_der_len],\n+ \
    \              &evt->data.evt_gatt_characteristic_value.value.data[1],\n+    \
    \           evt->data.evt_gatt_characteristic_value.value.len - 1);\n+       \
    \ remote_certificate_der_len += evt->data.evt_gatt_characteristic_value.value.len\
    \ - 1;\n+        sc = sl_bt_gatt_send_characteristic_confirmation(evt->data.evt_gatt_characteristic_value.connection);\n\
    +        app_assert_status(sc);\n+        if (evt->data.evt_gatt_characteristic_value.value.data[0]\
    \ == 0) {\n+          // Last chunk stop indication\n+          sc = sl_bt_gatt_set_characteristic_notification(connection,\n\
    +                                                          cbap_characteristics[CHAR_PERIPHERAL_CERT].handle,\n\
    +                                                          sl_bt_gatt_disable);\n\
    +          app_assert_status(sc);\n+\n+          remote_cert_arrived = true;\n\
    +          cbap_central_state = SL_BT_CBAP_CENTRAL_SEND_CENTRAL_CERT;\n+     \
    \     sl_bt_cbap_central_on_event(cbap_central_state);\n+          set_timeout(true);\n\
    +\n+          sc = sl_bt_cbap_lib_process_remote_cert(remote_certificate_der,\n\
    +                                                  remote_certificate_der_len);\n\
    +          if (sc == SL_STATUS_OK) {\n+            sl_bt_cbap_log_info(\"Remote\
    \ certificate verified.\" APP_LOG_NL);\n+          } else {\n+            sl_bt_cbap_log_error(\"\
    Remote certificate verification failed. \" \\\n+                             \
    \    \"Disconnecting.\" APP_LOG_NL);\n+            sl_bt_on_cbap_error();\n+ \
    \           cbap_reset();\n+            break;\n+          }\n+        }\n+  \
    \    } else if (cbap_central_state == SL_BT_CBAP_CENTRAL_GET_PERIPHERAL_OOB) {\n\
    +        aes_key_128 remote_random;\n+        aes_key_128 remote_confirm;\n+ \
    \       uint8_t remote_oob_signature[OOB_SIGNATURE_LEN];\n+        memcpy(&remote_random,\n\
    +               &evt->data.evt_gatt_characteristic_value.value.data[0],\n+   \
    \            sizeof(aes_key_128));\n+        memcpy(&remote_confirm,\n+      \
    \         &evt->data.evt_gatt_characteristic_value.value.data[16],\n+        \
    \       sizeof(aes_key_128));\n+        memcpy(&remote_oob_signature,\n+     \
    \          &evt->data.evt_gatt_server_user_write_request.value.data[32],\n+  \
    \             OOB_SIGNATURE_LEN);\n+        sc = sl_bt_gatt_send_characteristic_confirmation(evt->data.evt_gatt_characteristic_value.connection);\n\
    +        app_assert_status(sc);\n+        cbap_central_state = SL_BT_CBAP_CENTRAL_SEND_OOB;\n\
    +        sl_bt_cbap_central_on_event(cbap_central_state);\n+        set_timeout(true);\n\
    +        sc = sl_bt_gatt_set_characteristic_notification(connection,\n+      \
    \                                                  cbap_characteristics[CHAR_PERIPHERAL_OOB].handle,\n\
    +                                                        sl_bt_gatt_disable);\n\
    +        app_assert_status(sc);\n+\n+        sl_bt_cbap_log_debug(\"Remote OOB\
    \ data:\" APP_LOG_NL);\n+        sl_bt_cbap_log_hexdump(&remote_random, sizeof(aes_key_128));\n\
    +        sl_bt_cbap_log_debug(APP_LOG_NL);\n+        sl_bt_cbap_log_hexdump(&remote_confirm,\
    \ sizeof(aes_key_128));\n+        sl_bt_cbap_log_debug(APP_LOG_NL);\n+       \
    \ sl_bt_cbap_log_debug(\"Remote OOB signature:\" APP_LOG_NL);\n+        sl_bt_cbap_log_hexdump(&remote_oob_signature,\
    \ OOB_SIGNATURE_LEN);\n+        sl_bt_cbap_log_debug(APP_LOG_NL);\n+\n+      \
    \  sc = sl_bt_cbap_lib_verify_remote_oob_data(remote_random.data,\n+         \
    \                                          remote_confirm.data,\n+           \
    \                                        remote_oob_signature);\n+        app_assert_status(sc);\n\
    +        sl_bt_cbap_log_info(\"Remote OOB data verified.\" APP_LOG_NL);\n+   \
    \     sc = sl_bt_sm_set_remote_oob(1, remote_random, remote_confirm);\n+     \
    \   app_assert_status(sc);\n+        sc = sl_bt_cbap_destroy_key();\n+       \
    \ app_assert_status(sc);\n+      }\n+      break;\n+  }\n+}\n+\n+/***************************************************************************//**\n\
    + * Reset CBAP process states, flags and timers.\n+ ******************************************************************************/\n\
    +static void cbap_reset(void)\n+{\n+  set_timeout(false); // Make sure timer is\
    \ stopped\n+  connection = SL_BT_INVALID_CONNECTION_HANDLE; // Clear connection\
    \ handle\n+  // Reset states\n+  cbap_peripheral_state = (sl_bt_cbap_peripheral_state_t)0;\n\
    +  sl_bt_cbap_peripheral_on_event(cbap_peripheral_state);\n+  cbap_central_state\
    \ = (sl_bt_cbap_central_state_t)0;\n+  sl_bt_cbap_central_on_event(cbap_central_state);\n\
    +  char_state = (characteristics_t)0;\n+  // Reset flags\n+  remote_cert_arrived\
    \ = false;\n+  device_cert_sent = false;\n+  remote_certificate_der_len = 0;\n\
    +  dev_cert_sending_progression = 0;\n+}\n+\n+/*******************************************************************************\n\
    + * Search for a Service UUID in scan report.\n+ *\n+ * @param[in] scan_data Data\
    \ received in scanner advertisement report event\n+ * @param[in] scan_data_len\
    \ Length of the scan data\n+ * @param[in] uuid Service UUID to search for\n+ *\
    \ @param[in] uuid_len Service UUID length\n+ * @return true if the service is\
    \ found\n+ ******************************************************************************/\n\
    +static bool find_service_in_advertisement(const uint8_t *scan_data,\n+      \
    \                                    uint8_t scan_data_len,\n+               \
    \                           const uint8_t *uuid,\n+                          \
    \                uint8_t uuid_len)\n+{\n+  uint8_t ad_field_length;\n+  uint8_t\
    \ ad_field_type;\n+  uint8_t i = 0;\n+\n+  while (i < scan_data_len) {\n+    //\
    \ Parse advertisement packet\n+    ad_field_length = scan_data[i];  // Not counting\
    \ the length byte itself\n+    ad_field_type = scan_data[i + 1];\n+    if ((uuid_len\
    \ == UUID_16_LEN && (ad_field_type == GAP_INCOMPLETE_16B_UUID\n+             \
    \                        || ad_field_type == GAP_COMPLETE_16B_UUID))\n+      \
    \  || (uuid_len == UUID_128_LEN && (ad_field_type == GAP_INCOMPLETE_128B_UUID\n\
    +                                         || ad_field_type == GAP_COMPLETE_128B_UUID)))\
    \ {\n+      // Packet containing the list of complete/incomplete 16/128-bit services\
    \ found.\n+      // Loop through the UUID list\n+      uint8_t j = 2;\n+     \
    \ while (j < ad_field_length + 1) {\n+        // Compare payload.\n+        if\
    \ (memcmp(&scan_data[i + j], uuid, uuid_len) == 0) {\n+          return true;\n\
    +        }\n+        // Advance to the next UUID\n+        j += uuid_len;\n+ \
    \     }\n+    }\n+    // Advance to the next packet\n+    i += ad_field_length\
    \ + 1;\n+  }\n+  return false;\n+}\n+\n+/***************************************************************************//**\n\
    + * Start or stop timer for timeout check.\n+ * @param[in] activate If true timer\
    \ will start for timeout check\n+ ******************************************************************************/\n\
    +static void set_timeout(bool activate)\n+{\n+  sl_status_t sc;\n+  if (activate)\
    \ {\n+    // Start or restart timer to timeout check\n+    sc = app_timer_start(&state_timer,\n\
    +                         TIMEOUT,\n+                         state_timer_cb,\n\
    +                         NO_CALLBACK_DATA,\n+                         false);\n\
    +    app_assert_status(sc);\n+  } else {\n+    // Stop timer\n+    sc = app_timer_stop(&state_timer);\n\
    +    app_assert_status(sc);\n+  }\n+}\n+\n+/***************************************************************************//**\n\
    + * Timer Callback.\n+ * @param[in] handle pointer to handle instance\n+ * @param[in]\
    \ data pointer to input data\n+ ******************************************************************************/\n\
    +static void state_timer_cb(app_timer_t *handle, void *data)\n+{\n+  (void)handle;\n\
    +  (void)data;\n+\n+  sl_bt_cbap_log_error(\"Timeout error. Disconnecting.\" APP_LOG_NL);\n\
    +  sl_bt_on_cbap_error();\n+  cbap_reset();\n+}\n+\n+// CBAP Peripheral event\
    \ handler WEAK implementation.\n+SL_WEAK void sl_bt_cbap_peripheral_on_event(sl_bt_cbap_peripheral_state_t\
    \ status)\n+{\n+  (void)status;\n+}\n+\n+// CBAP Central event handler WEAK implementation.\n\
    +SL_WEAK void sl_bt_cbap_central_on_event(sl_bt_cbap_central_state_t status)\n\
    +{\n+  (void)status;\n+}\n+\n+// Callback to handle CBAP process errors.\n+SL_WEAK\
    \ void sl_bt_on_cbap_error(void)\n+{\n+  sl_status_t sc;\n+  sc = sl_bt_connection_close(connection);\n\
    +  app_assert_status(sc);\n+}"
  - '--- a/app/bluetooth/common/ead_core/sl_bt_ead_core.c

    +++ b/app/bluetooth/common/ead_core/sl_bt_ead_core.c

    @@ -0,0 +1,455 @@

    +/***************************************************************************//**

    + * @file

    + * @brief Encrypted Advertisement Data core functions implementation.

    + *******************************************************************************

    + * # License

    + * <b>Copyright 2022 Silicon Laboratories Inc. www.silabs.com</b>

    + *******************************************************************************

    + *

    + * SPDX-License-Identifier: Zlib

    + *

    + * The licensor of this software is Silicon Laboratories Inc.

    + *

    + * This software is provided ''as-is'', without any express or implied

    + * warranty. In no event will the authors be held liable for any damages

    + * arising from the use of this software.

    + *

    + * Permission is granted to anyone to use this software for any purpose,

    + * including commercial applications, and to alter it and redistribute it

    + * freely, subject to the following restrictions:

    + *

    + * 1. The origin of this software must not be misrepresented; you must not

    + *    claim that you wrote the original software. If you use this software

    + *    in a product, an acknowledgment in the product documentation would be

    + *    appreciated but is not required.

    + * 2. Altered source versions must be plainly marked as such, and must not be

    + *    misrepresented as being the original software.

    + * 3. This notice may not be removed or altered from any source distribution.

    + *

    + ******************************************************************************/

    +#include <stdlib.h>

    +#include <string.h>

    +#include <assert.h>

    +#include "em_common.h"

    +#include "psa/crypto.h"

    +#include "sl_bt_ead_core.h"

    +#include "psa/crypto_values.h"

    +#include "sli_protocol_crypto.h"

    +#include "sl_bt_ead_core_config.h"

    +

    +// According to Core Vol 2, Part H, Section 9. the tag (= MIC) size is 32 bits

    +#define PSA_ALG_BLE_CCM     PSA_ALG_AEAD_WITH_SHORTENED_TAG(PSA_ALG_CCM, \

    +                                                            SL_BT_EAD_MIC_SIZE)

    +

    +#if (SL_BT_EAD_CORE_ACCELERATOR == SL_BT_EAD_CORE_USE_PSA_ACC)

    +// Additional data for EAD encryption, see CSS d11, Part A, 1.23.3

    +static const uint8_t aad[] = { SL_BT_ENCRYPTED_DATA_B1_HEADER };

    +static psa_key_attributes_t attributes = PSA_KEY_ATTRIBUTES_INIT;

    +#endif // (SL_BT_EAD_CORE_ACCELERATOR == SL_BT_EAD_CORE_USE_PSA_ACC)

    +

    +/**************************************************************************//**

    + * Update the Randomizer field of the EAD Nonce value with newly generated value

    + *****************************************************************************/

    +sl_status_t sl_bt_ead_randomizer_update(sl_bt_ead_nonce_p nonce)

    +{

    +  sl_status_t result = SL_STATUS_FAIL;

    +  psa_status_t status = psa_crypto_init();

    +

    +  assert(nonce != NULL);

    +

    +  if (status == PSA_SUCCESS) {

    +    status = psa_generate_random((uint8_t *)(nonce->randomizer),

    +                                 SL_BT_EAD_RANDOMIZER_SIZE);

    +    if (status == PSA_SUCCESS) {

    +      result = SL_STATUS_OK;

    +    }

    +  }

    +

    +  return result;

    +}

    +

    +/**************************************************************************//**

    + * Set the Randomizer field of the EAD Nonce value manually to a given value

    + *****************************************************************************/

    +sl_status_t sl_bt_ead_randomizer_set(sl_bt_ead_randomizer_t randomizer,

    +                                     sl_bt_ead_nonce_p nonce)

    +{

    +  sl_status_t result = SL_STATUS_NOT_SUPPORTED;

    +

    +  assert(nonce != NULL);

    +

    +  if (randomizer != NULL) {

    +    memcpy((void *)(nonce->randomizer),

    +           (const void *)randomizer,

    +           sizeof(sl_bt_ead_randomizer_t));

    +    result = SL_STATUS_OK;

    +  } else {

    +    return sl_bt_ead_randomizer_update(nonce);

    +  }

    +

    +  return result;

    +}

    +

    +/**************************************************************************//**

    + * (Re)initialize the entire Nonce value with the new key material provided

    + *****************************************************************************/

    +sl_status_t sl_bt_ead_session_init(sl_bt_ead_key_material_p key_material,

    +                                   sl_bt_ead_randomizer_t   randomizer,

    +                                   sl_bt_ead_nonce_p        nonce)

    +{

    +  uint8_t      tmp[SL_BT_EAD_SESSION_KEY_SIZE];

    +  sl_status_t  result = SL_STATUS_INITIALIZATION;

    +

    +  assert(key_material != NULL);

    +

    +  // Make a copy of the session key, first

    +  memcpy(tmp, key_material->key, SL_BT_EAD_SESSION_KEY_SIZE);

    +

    +  // Swap key endianness to make the sli_ccm_[crypto] functions work as expected

    +  for (unsigned int t = 0; t < SL_BT_EAD_SESSION_KEY_SIZE; t++) {

    +    key_material->key[(SL_BT_EAD_SESSION_KEY_SIZE - 1) - t] = tmp[t];

    +  }

    +

    +  if (nonce != NULL) {

    +    memcpy((void *)nonce->iv,

    +           (const void *)key_material->iv,

    +           SL_BT_EAD_IV_SIZE);

    +

    +    result = sl_bt_ead_randomizer_set(randomizer, nonce);

    +  }

    +

    +  #if (SL_BT_EAD_CORE_ACCELERATOR == SL_BT_EAD_CORE_USE_PSA_ACC)

    +  // Prepare key attributes

    +  psa_set_key_algorithm(&attributes, PSA_ALG_BLE_CCM);

    +  psa_set_key_type(&attributes, PSA_KEY_TYPE_AES);

    +  psa_set_key_bits(&attributes, SL_BT_EAD_SESSION_KEY_SIZE * 8);

    +  #endif // (SL_BT_EAD_CORE_ACCELERATOR == SL_BT_EAD_CORE_USE_PSA_ACC)

    +  return result;

    +}

    +

    +/**************************************************************************//**

    + * Encrypt message in-place using EAD encryption

    + *****************************************************************************/

    +sl_status_t sl_bt_ead_encrypt(sl_bt_ead_key_material_p key_material,

    +                              sl_bt_ead_nonce_p        nonce,

    +                              uint8_t                  length,

    +                              uint8_t                  *data,

    +                              sl_bt_ead_mic_t          mic)

    +{

    +  sl_status_t  result = SL_STATUS_INITIALIZATION;

    +  #if (SL_BT_EAD_CORE_ACCELERATOR == SL_BT_EAD_CORE_USE_PSA_ACC)

    +  psa_status_t status;

    +  psa_key_id_t key_id;

    +  uint8_t      *output_data;

    +  size_t       output_length;

    +  const size_t output_size = length + SL_BT_EAD_MIC_SIZE;

    +  #endif // (SL_BT_EAD_CORE_ACCELERATOR == SL_BT_EAD_CORE_USE_PSA_ACC)

    +

    +  assert(key_material != NULL);

    +  assert(nonce != NULL);

    +  assert(length >= 1);

    +  assert(data != NULL);

    +  assert(mic != NULL);

    +

    +  #if (SL_BT_EAD_CORE_ACCELERATOR == SL_BT_EAD_CORE_USE_PSA_ACC)

    +  // Initialize PSA Crypto

    +  status = psa_crypto_init();

    +

    +  if (status == PSA_SUCCESS) {

    +    result = SL_STATUS_ALLOCATION_FAILED;

    +    output_data = (uint8_t *)malloc(output_size);

    +

    +    if (output_data != NULL) {

    +      result = SL_STATUS_INVALID_KEY;

    +      // Import the key

    +      psa_set_key_usage_flags(&attributes, PSA_KEY_USAGE_ENCRYPT);

    +      status = psa_import_key(&attributes,

    +                              key_material->key,

    +                              sizeof(key_material->key),

    +                              &key_id);

    +

    +      if (status == PSA_SUCCESS) {

    +        result = SL_STATUS_FAIL;

    +        // Authenticate and encrypt

    +        status = psa_aead_encrypt(key_id, PSA_ALG_BLE_CCM,

    +                                  (const uint8_t *)nonce, SL_BT_EAD_NONCE_SIZE,

    +                                  aad, sizeof(aad),

    +                                  data, length,

    +                                  output_data, output_size,

    +                                  &output_length);

    +

    +        if (status == PSA_SUCCESS) {

    +          memcpy(mic, output_data + length, SL_BT_EAD_MIC_SIZE);

    +          memcpy(data, output_data, length);

    +          result = SL_STATUS_OK;

    +        }

    +

    +        free(output_data);

    +

    +        // Destroy the key

    +        psa_destroy_key(key_id);

    +      }

    +    }

    +  }

    +  #else

    +  // Use the RADIOAES accelerator instead of PSA Crypto library

    +  // Can be up to 5-10 times faster and also produces few kilobytes less code

    +  result = sli_ccm_encrypt_and_tag_ble(data,

    +                                       length,

    +                                       (const unsigned char*)key_material->key,

    +                                       (const unsigned char*)nonce,

    +                                       SL_BT_ENCRYPTED_DATA_B1_HEADER,

    +                                       mic);

    +  #endif // (SL_BT_EAD_CORE_ACCELERATOR == SL_BT_EAD_CORE_USE_PSA_ACC)

    +  return result;

    +}

    +

    +/**************************************************************************//**

    + * Decrypt message in-place that is encrypted with EAD

    + *****************************************************************************/

    +sl_status_t sl_bt_ead_decrypt(sl_bt_ead_key_material_p key_material,

    +                              sl_bt_ead_nonce_p        nonce,

    +                              sl_bt_ead_mic_t          mic,

    +                              uint8_t                  length,

    +                              uint8_t                  *data)

    +{

    +  sl_status_t  result = SL_STATUS_INITIALIZATION;

    +  #if (SL_BT_EAD_CORE_ACCELERATOR == SL_BT_EAD_CORE_USE_PSA_ACC)

    +  psa_status_t status;

    +  psa_key_id_t key_id;

    +  uint8_t      *output_data;

    +  size_t       output_length;

    +  const size_t output_size = length + SL_BT_EAD_MIC_SIZE;

    +  #endif // (SL_BT_EAD_CORE_ACCELERATOR == SL_BT_EAD_CORE_USE_PSA_ACC)

    +  assert(key_material != NULL);

    +  assert(length >= 1);

    +  assert(data != NULL);

    +  assert(mic != NULL);

    +

    +  #if (SL_BT_EAD_CORE_ACCELERATOR == SL_BT_EAD_CORE_USE_PSA_ACC)

    +  // Initialize PSA Crypto

    +  status = psa_crypto_init();

    +

    +  if (status == PSA_SUCCESS) {

    +    result = SL_STATUS_ALLOCATION_FAILED;

    +    output_data = (uint8_t *)malloc(output_size);

    +

    +    if (output_data != NULL) {

    +      result = SL_STATUS_INVALID_KEY;

    +      // Import the key

    +      psa_set_key_usage_flags(&attributes, PSA_KEY_USAGE_DECRYPT);

    +      status = psa_import_key(&attributes,

    +                              key_material->key,

    +                              sizeof(key_material->key),

    +                              &key_id);

    +

    +      if (status == PSA_SUCCESS) {

    +        result = SL_STATUS_FAIL;

    +        memcpy(output_data, data, length);

    +        memcpy(output_data + length, mic, SL_BT_EAD_MIC_SIZE);

    +

    +        // Authenticate and encrypt

    +        status = psa_aead_decrypt(key_id, PSA_ALG_BLE_CCM,

    +                                  (const uint8_t *)nonce, SL_BT_EAD_NONCE_SIZE,

    +                                  aad, sizeof(aad),

    +                                  output_data, output_size,

    +                                  data, length,

    +                                  &output_length);

    +

    +        if (status == PSA_SUCCESS) {

    +          result = SL_STATUS_OK;

    +        }

    +

    +        free(output_data);

    +

    +        // Destroy the key

    +        psa_destroy_key(key_id);

    +      }

    +    }

    +  }

    +  #else

    +  // Use the RADIOAES accelerator instead of PSA Crypto library

    +  // Can be up to 5-10 times faster and also produces few kilobytes less code

    +  result = sli_ccm_auth_decrypt_ble(data,

    +                                    length,

    +                                    (const unsigned char*)key_material->key,

    +                                    (const unsigned char*)nonce,

    +                                    SL_BT_ENCRYPTED_DATA_B1_HEADER,

    +                                    mic);

    +  #endif // (SL_BT_EAD_CORE_ACCELERATOR == SL_BT_EAD_CORE_USE_PSA_ACC)

    +

    +  return result;

    +}

    +

    +/**************************************************************************//**

    + *  Unpack advertising data that is encrypted with EAD and decrypt the message

    + *****************************************************************************/

    +sl_status_t sl_bt_ead_unpack_decrypt(sl_bt_ead_key_material_p key_material,

    +                                     uint8_t                  **data,

    +                                     uint8_t                  *length)

    +{

    +  sl_status_t result = SL_STATUS_INVALID_TYPE;

    +  uint32_t data_length;

    +

    +  assert(key_material != NULL);

    +  assert(length != NULL);

    +  assert(data != NULL);

    +  assert(*data != NULL);

    +

    +  data_length = (uint32_t)(*data)[0];

    +  // Check if the encrypted data has the minimum expected size

    +  if (data_length < SL_BT_EAD_PACKET_OVERHEAD) {

    +    result = SL_STATUS_INVALID_COUNT;

    +  } else if ((*data)[1] == SL_BT_ENCRYPTED_DATA_AD_TYPE) {

    +    // The type field reported an Encrypted AD Data type, continue

    +    struct sl_bt_ead_nonce_s nonce;

    +

    +    // Init local nonce for the session before decrypt

    +    memcpy((void *)nonce.iv,

    +           (const void *)key_material->iv,

    +           SL_BT_EAD_IV_SIZE);

    +

    +    result = sl_bt_ead_randomizer_set(*data + SL_BT_EAD_HEADER_SIZE,

    +                                      &nonce);

    +

    +    data_length -= SL_BT_EAD_PACKET_REDUCED_OVERHEAD;

    +

    +    if (result == SL_STATUS_OK) {

    +      uint32_t start_index = SL_BT_EAD_HEADER_SIZE + SL_BT_EAD_RANDOMIZER_SIZE;

    +      uint32_t mic_index = start_index + data_length;

    +

    +      *length = (uint8_t)data_length;

    +      result = sl_bt_ead_decrypt(key_material,

    +                                 &nonce,

    +                                 *data + mic_index,

    +                                 *length,

    +                                 *data + start_index);

    +

    +      if (result == SL_STATUS_OK) {

    +        *data += start_index;

    +      }

    +    }

    +  }

    +

    +  return result;

    +}

    +

    +/**************************************************************************//**

    + * Pack encrypted EAD AD_Data to Advertising, Periodic Advertising, and Scan

    + * Response Data packet

    + *****************************************************************************/

    +sl_status_t sl_bt_ead_pack_ad_data(sl_bt_ead_ad_structure_p ad_info,

    +                                   uint8_t         *size,

    +                                   uint8_t         *pack_buf)

    +{

    +  sl_status_t result = SL_STATUS_WOULD_OVERFLOW;

    +  uint32_t    data_index;

    +

    +  // Check for invalid parameters

    +  assert(ad_info != NULL);

    +  assert(size != NULL);

    +  assert(pack_buf != NULL);

    +

    +  // Check for uninitialized ad_info structure

    +  assert(ad_info->randomizer != NULL);

    +  assert(ad_info->ad_data != NULL);

    +  assert(ad_info->mic != NULL);

    +

    +  // Check for valid encrypted length

    +  if (ad_info->length < 1) {

    +    result = SL_STATUS_ABORT;

    +  } else if (*size >= (ad_info->length + SL_BT_EAD_PACKET_OVERHEAD)) {

    +    // Set packet length for the serialized data and the AD Type

    +    pack_buf[0] = ad_info->length;

    +    pack_buf[0] += SL_BT_EAD_PACKET_OVERHEAD - SL_BT_EAD_LENGTH_FIELD_SIZE;

    +    pack_buf[1] = ad_info->ad_type;

    +

    +    // Copy the randomizer to the first part of the encrypted data

    +    data_index = SL_BT_EAD_HEADER_SIZE;

    +    memcpy(pack_buf + data_index,

    +           ad_info->randomizer,

    +           SL_BT_EAD_RANDOMIZER_SIZE);

    +

    +    // Copy the the encrypted data

    +    data_index += SL_BT_EAD_RANDOMIZER_SIZE;

    +    memcpy(pack_buf + data_index, ad_info->ad_data, ad_info->length);

    +

    +    // Copy the the MIC

    +    data_index += ad_info->length;

    +    memcpy(pack_buf + data_index, ad_info->mic, SL_BT_EAD_MIC_SIZE);

    +

    +    // Set the size output variable according to the final length of the packet

    +    *size = data_index + SL_BT_EAD_MIC_SIZE;

    +

    +    result = SL_STATUS_OK;

    +  }

    +

    +  return result;

    +}

    +

    +/**************************************************************************//**

    + * Unpack encrypted EAD Data from Advertising, Periodic Advertising, and Scan

    + * Response data format

    + *****************************************************************************/

    +sl_status_t sl_bt_ead_unpack_ad_data(uint8_t                  *packed_data,

    +                                     sl_bt_ead_ad_structure_p ad_info)

    +{

    +  sl_status_t result = SL_STATUS_INVALID_TYPE;

    +  uint32_t data_length;

    +

    +  assert(packed_data != NULL);

    +  assert(ad_info != NULL);

    +  assert(ad_info->randomizer != NULL);

    +  assert(ad_info->ad_data != NULL);

    +  assert(ad_info->mic != NULL);

    +

    +  data_length = (uint32_t)packed_data[0];

    +  ad_info->ad_type = packed_data[1];

    +

    +  // Check if the encrypted data has the minimum expected size

    +  if (data_length < SL_BT_EAD_PACKET_OVERHEAD) {

    +    result = SL_STATUS_INVALID_COUNT;

    +  } else if (ad_info->ad_type == SL_BT_ENCRYPTED_DATA_AD_TYPE) {

    +    // The type field reported an Encrypted AD Data type, get AD Data length

    +    data_length -= SL_BT_EAD_PACKET_REDUCED_OVERHEAD;

    +

    +    if (ad_info->length >= data_length) {

    +      uint32_t    data_index;

    +      // Copy the randomizer to the first part of the encrypted data

    +      data_index = SL_BT_EAD_HEADER_SIZE;

    +      memcpy(*ad_info->randomizer,

    +             packed_data + data_index,

    +             SL_BT_EAD_RANDOMIZER_SIZE);

    +

    +      // Copy the the encrypted data

    +      data_index += SL_BT_EAD_RANDOMIZER_SIZE;

    +      ad_info->length = data_length;

    +      memcpy(ad_info->ad_data, packed_data + data_index, ad_info->length);

    +

    +      // Copy the the MIC

    +      data_index += ad_info->length;

    +      memcpy(*ad_info->mic, packed_data + data_index, SL_BT_EAD_MIC_SIZE);

    +

    +      result = SL_STATUS_OK;

    +    } else {

    +      result = SL_STATUS_WOULD_OVERFLOW;

    +    }

    +  }

    +

    +  return result;

    +}

    +

    +// Workaround for a bug (feature?) in IAR compiler that may break build, see:

    +// https://www.iar.com/sv/knowledge/learn/programming/overriding-and-redirecting-library-modules-without-rebuilding-the-entire-library/

    +#if defined(__ICCARM__) && !defined(SL_CATALOG_RETARGET_STDIO_PRESENT)

    +SL_WEAK __ATTRIBUTES size_t __write(int handle, const unsigned char * buffer,
    size_t size)

    +{

    +  // This dependency is sneakily introduced by the 3rd party mbedtls utility

    +  // with its dependency on stdlib printf method - for which the IAR compiler

    +  // apparently does not provide a sufficient __write() method by default.

    +  (void)handle;

    +  (void)buffer;

    +  (void)size;

    +  return 0;

    +}

    +#endif'
  - '--- a/app/bluetooth/common/esl_tag_cli_test_harness/esl_tag_cli_test_harness.c

    +++ b/app/bluetooth/common/esl_tag_cli_test_harness/esl_tag_cli_test_harness.c

    @@ -0,0 +1,904 @@

    +/***************************************************************************//**

    + * @file

    + * @brief ESL Tag CLI commands implementation.

    + *******************************************************************************

    + * # License

    + * <b>Copyright 2022 Silicon Laboratories Inc. www.silabs.com</b>

    + *******************************************************************************

    + *

    + * SPDX-License-Identifier: Zlib

    + *

    + * The licensor of this software is Silicon Laboratories Inc.

    + *

    + * This software is provided ''as-is'', without any express or implied

    + * warranty. In no event will the authors be held liable for any damages

    + * arising from the use of this software.

    + *

    + * Permission is granted to anyone to use this software for any purpose,

    + * including commercial applications, and to alter it and redistribute it

    + * freely, subject to the following restrictions:

    + *

    + * 1. The origin of this software must not be misrepresented; you must not

    + *    claim that you wrote the original software. If you use this software

    + *    in a product, an acknowledgment in the product documentation would be

    + *    appreciated but is not required.

    + * 2. Altered source versions must be plainly marked as such, and must not be

    + *    misrepresented as being the original software.

    + * 3. This notice may not be removed or altered from any source distribution.

    + *

    + ******************************************************************************/

    +#include <stdarg.h>

    +#include <stdint.h>

    +#include <stdbool.h>

    +#include "gatt_db.h"

    +#include "app_log.h"

    +#include "sl_iostream.h"

    +#include "esl_tag_core.h"

    +#include "esl_log_config.h"

    +#include "sl_bt_ead_core.h"

    +#include "esl_tag_internal.h"

    +#include "sl_board_control.h"

    +#include "esl_tag_led_core.h"

    +#include "esl_tag_image_core.h"

    +#include "esl_tag_sensor_core.h"

    +#include "esl_tag_display_core.h"

    +#include "esl_tag_cli_test_harness.h"

    +

    +// global CLI enable / disable, non-configurable in Studio, for debugging purpose

    +static bool cli_enabled = true;

    +

    +// Two static images for OTS image transfer substitute command

    +#define BITS_PER_PIXEL  8

    +#define IMAGE_HEIGHT    128

    +#define IMAGE_WIDTH     128

    +

    +static const uint8_t images[][(IMAGE_HEIGHT * IMAGE_WIDTH) / BITS_PER_PIXEL]
    = {

    +  {

    +    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff,

    +    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff,

    +    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff,

    +    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff,

    +    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff,

    +    0xff, 0xff, 0xff, 0xff, 0xff, 0x7f, 0xdc, 0xff, 0xee, 0xff, 0xfd, 0xff, 0xff,
    0xff, 0xff,

    +    0xbe, 0xff, 0x1f, 0xfe, 0xff, 0xff, 0xbf, 0xdb, 0xff, 0xfe, 0xff, 0xfd, 0xff,
    0xff, 0xff,

    +    0xff, 0xbc, 0xff, 0xcf, 0xfd, 0xff, 0xff, 0xbf, 0x0f, 0x61, 0xe8, 0xf8, 0x0d,
    0x71, 0x78,

    +    0x74, 0xfc, 0xba, 0xe3, 0xef, 0xfd, 0xff, 0xff, 0xbf, 0xdf, 0xdf, 0x6e, 0xff,
    0xed, 0xee,

    +    0xb7, 0xb3, 0xfb, 0xb2, 0xdd, 0xef, 0xfd, 0xff, 0xff, 0x7f, 0xdc, 0xdf, 0x6e,
    0xff, 0xed,

    +    0xee, 0xb7, 0xb7, 0xfb, 0xb6, 0xbd, 0xef, 0xfb, 0xff, 0xff, 0xff, 0xdb, 0xc1,
    0x6e, 0xff,

    +    0xed, 0x6e, 0xb0, 0x37, 0xf0, 0xae, 0xbd, 0xef, 0xfd, 0xff, 0xff, 0xff, 0xd7,
    0xdd, 0x6e,

    +    0xff, 0xed, 0x6e, 0xb7, 0xb7, 0xff, 0x8e, 0xbd, 0xef, 0xfd, 0xff, 0xff, 0xbf,
    0xd3, 0xdd,

    +    0x6e, 0xf7, 0xed, 0x6e, 0xb7, 0xb3, 0xff, 0x9e, 0xdd, 0xcf, 0xfd, 0xff, 0xff,
    0x7f, 0x38,

    +    0xc1, 0xe9, 0xf8, 0xed, 0x6e, 0x70, 0x74, 0xf8, 0xbe, 0xe3, 0x1d, 0xfe, 0xff,
    0xff, 0xff,

    +    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfb, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff,

    +    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7f, 0xfc, 0xdf, 0xff, 0xff, 0xfd,
    0xff, 0xff,

    +    0xff, 0xff, 0xff, 0xff, 0xff, 0x9f, 0xff, 0xbf, 0xff, 0xff, 0xaf, 0xe7, 0x3f,
    0xe7, 0xff,

    +    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x01, 0x00, 0x80, 0xfa, 0xff, 0xff, 0xff,
    0xff, 0x05,

    +    0xfe, 0xff, 0xff, 0xff, 0xff, 0xff, 0x1f, 0x00, 0xa0, 0xff, 0xdf, 0x07, 0xd2,
    0xff, 0xff,

    +    0x1f, 0xfc, 0xff, 0xff, 0xff, 0xff, 0xff, 0x03, 0x80, 0xff, 0xbf, 0xa4, 0xfe,
    0x5f, 0xfe,

    +    0xff, 0x7f, 0xf8, 0xff, 0xff, 0xff, 0xff, 0xff, 0x80, 0x5e, 0x2a, 0x40, 0xfb,
    0xff, 0xff,

    +    0xf1, 0xff, 0xff, 0xf0, 0xff, 0xff, 0xff, 0xff, 0x1f, 0xf8, 0xff, 0xff, 0xff,
    0xff, 0xff,

    +    0xff, 0x8f, 0xff, 0xff, 0xe1, 0xff, 0xff, 0xff, 0xff, 0x07, 0xfe, 0xff, 0xff,
    0xff, 0x5f,

    +    0x22, 0xea, 0x7f, 0xfe, 0xff, 0xc3, 0xff, 0xff, 0xff, 0xff, 0x83, 0x0f, 0xe0,
    0xff, 0xbf,

    +    0xa0, 0xff, 0x0b, 0xfd, 0xf9, 0xff, 0x87, 0xff, 0xff, 0xff, 0xff, 0xe0, 0xf7,
    0x2f, 0x12,

    +    0x00, 0xff, 0xff, 0xff, 0xf2, 0xf3, 0xff, 0x87, 0xff, 0xff, 0xff, 0x7f, 0xf0,
    0xff, 0xff,

    +    0xff, 0xff, 0xff, 0xff, 0xff, 0xcf, 0xcf, 0xff, 0x0f, 0xff, 0xff, 0xff, 0x1f,
    0xfc, 0xff,

    +    0xff, 0xff, 0xff, 0xff, 0x57, 0xd5, 0x1f, 0x3e, 0xff, 0x1f, 0xfe, 0xff, 0xff,
    0x0f, 0xfe,

    +    0xff, 0xef, 0xff, 0xff, 0xff, 0xff, 0x2f, 0xf4, 0x7c, 0xff, 0x1f, 0xfe, 0xff,
    0xff, 0x0f,

    +    0xff, 0x7f, 0x29, 0xa0, 0xff, 0xff, 0xf9, 0xff, 0xeb, 0xf3, 0xfc, 0x3f, 0xfc,
    0xff, 0xff,

    +    0x87, 0xff, 0x8f, 0xff, 0x8f, 0xff, 0xff, 0xfd, 0xff, 0x1f, 0xe7, 0xfb, 0x3f,
    0xfc, 0xff,

    +    0xff, 0xcf, 0xff, 0xf7, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0x9e, 0xf7,
    0x7f, 0xfc,

    +    0xff, 0xff, 0xe7, 0xff, 0xf3, 0xff, 0xff, 0xff, 0x7f, 0xff, 0xff, 0xff, 0x79,
    0xdf, 0x7f,

    +    0xf8, 0xff, 0xff, 0xc7, 0xff, 0xfb, 0xff, 0xcf, 0xff, 0x7f, 0xff, 0xff, 0xff,
    0xf7, 0xfe,

    +    0xff, 0xf8, 0xff, 0xff, 0xe7, 0xff, 0xfd, 0xff, 0xdf, 0xff, 0x7f, 0xff, 0xff,
    0xff, 0xef,

    +    0xff, 0xff, 0xf8, 0xff, 0xff, 0xc7, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff,

    +    0xff, 0xfb, 0xff, 0xf1, 0xff, 0xff, 0xe3, 0xff, 0xff, 0xff, 0xbf, 0xff, 0xff,
    0xff, 0x01,

    +    0xe8, 0xff, 0xff, 0xff, 0xe1, 0xff, 0xff, 0xe3, 0xff, 0xff, 0xff, 0xbf, 0xff,
    0xff, 0x5f,

    +    0x00, 0x80, 0xff, 0xff, 0xff, 0xe3, 0xff, 0xff, 0xe1, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff,

    +    0x07, 0x00, 0x00, 0xfe, 0xff, 0xff, 0xc3, 0xff, 0xff, 0xf0, 0xff, 0x7f, 0xd0,
    0xdf, 0xff,

    +    0xff, 0x01, 0x0e, 0x00, 0xf8, 0xff, 0xff, 0x87, 0xff, 0x7f, 0xf0, 0xff, 0x0f,
    0x00, 0xfe,

    +    0xff, 0xff, 0xc0, 0x07, 0x00, 0xf0, 0xff, 0xff, 0x0f, 0xff, 0x7f, 0xf8, 0xff,
    0x07, 0x04,

    +    0xf0, 0xff, 0x7f, 0xf8, 0x0f, 0x80, 0xe1, 0xff, 0xff, 0x0f, 0xfe, 0x1f, 0xfc,
    0xff, 0x83,

    +    0x0b, 0xe0, 0xff, 0x3f, 0xf4, 0x0f, 0x80, 0xe6, 0xfc, 0xbf, 0x0a, 0xfc, 0x1f,
    0xde, 0x95,

    +    0x03, 0x00, 0x80, 0xff, 0x3f, 0xfc, 0x00, 0x00, 0xc0, 0xc3, 0x5f, 0x35, 0xf8,
    0x07, 0x07,

    +    0xff, 0x03, 0x00, 0x00, 0xf1, 0x1f, 0x3e, 0x00, 0x12, 0xc0, 0xeb, 0xff, 0xeb,
    0xe0, 0x87,

    +    0xf3, 0xff, 0x7f, 0x01, 0x00, 0xf0, 0x3f, 0x0c, 0xf0, 0xff, 0xe0, 0xfe, 0xff,
    0xbf, 0xe1,

    +    0xc3, 0xfc, 0xff, 0xff, 0xff, 0x00, 0xf0, 0x3f, 0x00, 0xff, 0xfe, 0xff, 0x7d,
    0x80, 0x7f,

    +    0xc7, 0xe1, 0xde, 0xff, 0xff, 0xff, 0x0f, 0xfe, 0x7f, 0xc0, 0x7f, 0xfc, 0xff,
    0x0f, 0x00,

    +    0xfc, 0x8d, 0x21, 0xe7, 0xff, 0xff, 0xff, 0x1f, 0xff, 0xff, 0xf1, 0xff, 0xf0,
    0xff, 0x03,

    +    0x04, 0xf8, 0x1f, 0xe1, 0xf9, 0xea, 0xff, 0xff, 0x1f, 0xff, 0xff, 0xff, 0xff,
    0xe0, 0xff,

    +    0x00, 0xff, 0xf0, 0x1b, 0xb1, 0x3b, 0x00, 0xff, 0xff, 0x9f, 0xff, 0xff, 0xff,
    0xff, 0x81,

    +    0x5f, 0xc0, 0xff, 0xe3, 0x3f, 0xd0, 0x1d, 0x00, 0xfc, 0xff, 0x1f, 0xff, 0xff,
    0xff, 0xff,

    +    0x07, 0x00, 0xe8, 0xf9, 0xc7, 0x7f, 0xd1, 0x0f, 0x2a, 0x70, 0xfc, 0x1f, 0xff,
    0xff, 0xff,

    +    0xff, 0x0f, 0x00, 0xfe, 0xf9, 0x87, 0x77, 0xf0, 0xfd, 0x7f, 0x00, 0xfe, 0x0f,
    0xff, 0xff,

    +    0xff, 0xff, 0xff, 0xed, 0xff, 0xf1, 0x8f, 0x7f, 0xd1, 0xfd, 0xff, 0x00, 0xfe,
    0x87, 0xff,

    +    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 0x1f, 0xf7, 0xd1, 0xfd, 0xe7, 0x80,
    0xff, 0x83,

    +    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x3f, 0xf0, 0x9f, 0xff, 0xd1, 0xff, 0xc7,
    0xff, 0xff,

    +    0xe0, 0xff, 0xff, 0xf0, 0xff, 0xff, 0xff, 0x0f, 0xc0, 0x1f, 0xf7, 0xd1, 0xfd,
    0xe7, 0xff,

    +    0x7f, 0xf0, 0xff, 0x7f, 0xc0, 0xfe, 0xff, 0xff, 0x01, 0x02, 0x1f, 0xff, 0xd3,
    0xfb, 0xc7,

    +    0xff, 0x3f, 0xfc, 0xff, 0x7f, 0x00, 0xfd, 0xff, 0x7f, 0xc0, 0x03, 0x1e, 0xf7,
    0xc3, 0xf3,

    +    0xc3, 0xff, 0x0f, 0xfc, 0xff, 0xff, 0x8f, 0x25, 0xf9, 0x1f, 0xf0, 0x03, 0x9c,
    0xff, 0xa3,

    +    0xef, 0xc1, 0xff, 0x07, 0xfc, 0xff, 0xff, 0x1f, 0xff, 0xff, 0x03, 0xfc, 0x43,
    0x08, 0x77,

    +    0x87, 0xff, 0xc1, 0xff, 0x05, 0xfc, 0xff, 0x01, 0x9f, 0xff, 0xff, 0x00, 0xff,
    0xe1, 0x8f,

    +    0x7f, 0x47, 0xfe, 0xc1, 0xff, 0x9a, 0xf8, 0x7f, 0x00, 0x8c, 0xff, 0x1f, 0x40,
    0xff, 0xf1,

    +    0xcf, 0x7b, 0x8f, 0xf1, 0x80, 0x3f, 0xdf, 0xf1, 0xff, 0x00, 0x86, 0xff, 0x03,
    0xc0, 0xff,

    +    0xf0, 0xc7, 0x3b, 0x0f, 0xc7, 0x00, 0xdf, 0xff, 0xe3, 0xff, 0xff, 0xc6, 0x7f,
    0x00, 0xe2,

    +    0x7f, 0xf0, 0xef, 0x1d, 0x1f, 0xff, 0x08, 0xfe, 0xff, 0xc3, 0xf9, 0xff, 0xc7,
    0x0f, 0xa0,

    +    0xc7, 0x1f, 0xf0, 0xff, 0x19, 0x1f, 0x7e, 0x00, 0xf8, 0xff, 0x0f, 0xf2, 0xff,
    0xff, 0x02,

    +    0xfc, 0xc3, 0x0f, 0xf0, 0xff, 0x0e, 0x3f, 0xfe, 0x40, 0xe0, 0xff, 0x0f, 0xf8,
    0xff, 0x1f,

    +    0x80, 0xff, 0xe3, 0x01, 0xfc, 0xbf, 0x87, 0x3f, 0x7c, 0x40, 0x80, 0xff, 0x3f,
    0xfc, 0xff,

    +    0x01, 0xf0, 0xff, 0x03, 0x00, 0xfc, 0xef, 0xc3, 0x7f, 0x7c, 0x60, 0x00, 0xfc,
    0xff, 0xfe,

    +    0x17, 0x00, 0xfc, 0xff, 0x01, 0x00, 0xfe, 0xff, 0xe0, 0x7f, 0x7c, 0x60, 0x0c,
    0x80, 0xfe,

    +    0x2f, 0x00, 0xa0, 0xf8, 0x7f, 0x00, 0x1c, 0xff, 0x7f, 0xf0, 0x7f, 0x7c, 0x60,
    0x5c, 0x00,

    +    0x00, 0x00, 0x00, 0x7d, 0xfc, 0x1f, 0x00, 0x8f, 0xff, 0x5f, 0xf8, 0x7f, 0x7c,
    0x70, 0x7e,

    +    0x00, 0x00, 0x00, 0xf0, 0xff, 0xf8, 0x0b, 0xc0, 0x87, 0xff, 0x3f, 0xfc, 0xff,
    0x78, 0x60,

    +    0x7c, 0x5c, 0x01, 0x68, 0xfc, 0xff, 0x78, 0x00, 0xc0, 0xc7, 0xff, 0x1f, 0xfe,
    0xff, 0x78,

    +    0x60, 0x3c, 0xfe, 0xc7, 0x7f, 0xfe, 0xff, 0x08, 0x00, 0xe0, 0xe3, 0xff, 0x1f,
    0xff, 0xff,

    +    0x78, 0x00, 0x3c, 0xfc, 0x87, 0xff, 0xfc, 0xff, 0x01, 0x00, 0xe3, 0xe1, 0xff,
    0x0f, 0xff,

    +    0xff, 0x78, 0x00, 0x1c, 0xfe, 0xc7, 0x7f, 0xfc, 0x7f, 0x00, 0xc0, 0xe3, 0xf0,
    0xff, 0x87,

    +    0xff, 0xff, 0x78, 0x00, 0x20, 0xfe, 0xc7, 0x7f, 0xfc, 0x07, 0x00, 0xf8, 0x63,
    0xf8, 0xff,

    +    0xc7, 0xff, 0xff, 0xf8, 0x00, 0x00, 0x40, 0x45, 0x55, 0x54, 0x00, 0x00, 0xfd,
    0x07, 0xfc,

    +    0xff, 0xc7, 0xff, 0xff, 0x78, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0,
    0xff, 0x07,

    +    0xfc, 0xff, 0xe3, 0xff, 0xff, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xf0, 0xff,

    +    0x07, 0xff, 0xff, 0xe3, 0xff, 0xff, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x80, 0xe3,

    +    0xff, 0x0f, 0xff, 0xff, 0xf3, 0xff, 0xff, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0xf0,

    +    0xe3, 0xff, 0x83, 0xff, 0xff, 0xf1, 0xff, 0xff, 0xf8, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00,

    +    0xfe, 0xe3, 0xff, 0xc0, 0xff, 0xff, 0xf0, 0xff, 0xff, 0xfc, 0x08, 0x00, 0x00,
    0x00, 0x00,

    +    0xe0, 0xff, 0xc3, 0x7f, 0xe0, 0xff, 0xff, 0xf8, 0xff, 0xff, 0xf8, 0x11, 0x01,
    0x00, 0x00,

    +    0x00, 0xe2, 0xff, 0xc7, 0x1f, 0xf8, 0xff, 0x7f, 0xf8, 0xff, 0xff, 0xfc, 0x11,
    0x42, 0x00,

    +    0x00, 0xe9, 0xf3, 0xff, 0x87, 0x0f, 0xfc, 0xff, 0x3f, 0xfc, 0xff, 0x7f, 0xfc,
    0x21, 0xc6,

    +    0xe3, 0x87, 0xff, 0xe3, 0xff, 0x8f, 0x03, 0xff, 0xff, 0x1f, 0xfe, 0xff, 0xff,
    0xfc, 0x23,

    +    0x86, 0xc3, 0x0f, 0xff, 0xe3, 0xff, 0x8f, 0x82, 0xfe, 0xff, 0x0f, 0xff, 0xff,
    0x7f, 0xfc,

    +    0x03, 0x8c, 0xc7, 0x8f, 0xff, 0xe3, 0xff, 0x1f, 0xe0, 0xff, 0xff, 0x87, 0xff,
    0xff, 0x7f,

    +    0xfc, 0x07, 0x0f, 0xc7, 0x1f, 0xff, 0xe3, 0xff, 0x07, 0xf0, 0xdf, 0xdf, 0xc3,
    0xff, 0xff,

    +    0x7f, 0xfc, 0x07, 0x1e, 0x8f, 0x1f, 0xff, 0xe3, 0xff, 0x08, 0xfc, 0xf7, 0xe3,
    0xe0, 0xff,

    +    0xff, 0x7f, 0xfc, 0x0f, 0x00, 0x8f, 0x3f, 0xff, 0xe3, 0x1f, 0x00, 0xff, 0x78,
    0x78, 0xf0,

    +    0xff, 0xff, 0x7f, 0xfe, 0x3f, 0x00, 0x0a, 0x1f, 0xff, 0xa3, 0x01, 0xc0, 0x3f,
    0x5f, 0x3e,

    +    0xf8, 0xff, 0xff, 0x7f, 0xfc, 0x7f, 0x00, 0x00, 0x34, 0xb4, 0x00, 0x00, 0xf4,
    0xcf, 0x8f,

    +    0x0f, 0xfe, 0xff, 0xff, 0x3f, 0xfe, 0xff, 0x0b, 0x00, 0x00, 0x00, 0x00, 0x40,
    0xff, 0xe3,

    +    0xe3, 0x03, 0xff, 0xff, 0xff, 0x7f, 0xfe, 0xff, 0x7f, 0x00, 0x00, 0x00, 0x00,
    0xf4, 0xff,

    +    0xfc, 0xf8, 0xc0, 0xff, 0xff, 0xff, 0x3f, 0xfe, 0xff, 0xff, 0xbf, 0x02, 0x21,
    0xfd, 0xff,

    +    0x3f, 0x3f, 0xbe, 0xe0, 0xff, 0xff, 0xff, 0x3f, 0xfe, 0xbf, 0xff, 0xff, 0xff,
    0xff, 0xff,

    +    0xff, 0xc7, 0x8b, 0x2f, 0xf8, 0xff, 0xff, 0xff, 0x3f, 0xbe, 0xbf, 0xff, 0xff,
    0xff, 0xff,

    +    0xff, 0xff, 0xf9, 0xe2, 0x0b, 0xfe, 0xff, 0xff, 0xff, 0x3f, 0x7e, 0x7f, 0xfe,
    0x7f, 0x25,

    +    0x95, 0xfe, 0x7f, 0x3e, 0xfc, 0x01, 0xff, 0xff, 0xff, 0xff, 0x3f, 0x7e, 0xff,
    0xfc, 0xff,

    +    0xff, 0xff, 0xff, 0x8f, 0x87, 0x7f, 0xc0, 0xff, 0xff, 0xff, 0xff, 0x3f, 0xfe,
    0xff, 0xe1,

    +    0xff, 0xff, 0xff, 0x7f, 0xf1, 0xe8, 0x1f, 0xf8, 0xff, 0xff, 0xff, 0xff, 0x3f,
    0x7f, 0xff,

    +    0x0f, 0xfd, 0xff, 0xff, 0x85, 0x9e, 0xfe, 0x07, 0xfe, 0xff, 0xff, 0xff, 0xff,
    0x3f, 0xfe,

    +    0xfc, 0xff, 0xaa, 0xbf, 0x7d, 0xfb, 0xf3, 0xff, 0x80, 0xff, 0xff, 0xff, 0xff,
    0xff, 0x3f,

    +    0xfe, 0xf3, 0xff, 0xff, 0xff, 0xff, 0xbf, 0xfe, 0x3f, 0xe0, 0xff, 0xff, 0xff,
    0xff, 0xff,

    +    0x3f, 0xfe, 0xc7, 0xff, 0xff, 0xff, 0x7f, 0xd5, 0xff, 0x0f, 0xfc, 0xff, 0xff,
    0xff, 0xff,

    +    0xff, 0x3f, 0xfe, 0x3f, 0xfc, 0xff, 0xef, 0xca, 0xff, 0xff, 0x03, 0xff, 0xff,
    0xff, 0xff,

    +    0xff, 0xff, 0x3f, 0xfe, 0xff, 0x01, 0x55, 0x59, 0xff, 0xff, 0xff, 0xc0, 0xff,
    0xff, 0xff,

    +    0xff, 0xff, 0xff, 0x3f, 0xfc, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x3f, 0xf0,
    0xff, 0xff,

    +    0xff, 0xff, 0xff, 0xff, 0x7f, 0xfc, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0f,
    0xfc, 0xff,

    +    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf8, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0x03, 0xff,

    +    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 0xff, 0xff, 0xff, 0xff, 0xff,
    0x05, 0xa0,

    +    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe1, 0xff, 0xff, 0xff, 0xff,
    0x7f, 0x00,

    +    0xd0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc3, 0xff, 0xff, 0xff,
    0xff, 0x0f,

    +    0x00, 0xfc, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x07, 0xff, 0xff,
    0xff, 0xff,

    +    0x02, 0x40, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x1f, 0xf8,
    0xff, 0xff,

    +    0x17, 0x00, 0xfd, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x3f,
    0x80, 0xfe,

    +    0x2b, 0x00, 0xf0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0x00,

    +    0x00, 0x00, 0x80, 0xfe, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff,

    +    0x03, 0x00, 0x00, 0xf4, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff,

    +    0xff, 0xbf, 0x00, 0xe8, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff,

    +    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff,

    +    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff,

    +    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff,

    +    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff,

    +    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff,

    +    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff,

    +    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff,

    +    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff,

    +    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff

    +  },

    +  {

    +    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff,

    +    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff,

    +    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff,

    +    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff,

    +    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff,

    +    0xff, 0xff, 0xff, 0xff, 0xff, 0x7f, 0xdc, 0xff, 0xee, 0xff, 0xfd, 0xff, 0xff,
    0xff, 0xff,

    +    0xbe, 0xff, 0xdf, 0xff, 0xff, 0xff, 0xbf, 0xdb, 0xff, 0xfe, 0xff, 0xfd, 0xff,
    0xff, 0xff,

    +    0xff, 0xbc, 0xff, 0xc7, 0xff, 0xff, 0xff, 0xbf, 0x0f, 0x61, 0xe8, 0xf8, 0x0d,
    0x71, 0x78,

    +    0x74, 0xfc, 0xba, 0xe3, 0xdf, 0xff, 0xff, 0xff, 0xbf, 0xdf, 0xdf, 0x6e, 0xff,
    0xed, 0xee,

    +    0xb7, 0xb3, 0xfb, 0xb2, 0xdd, 0xdf, 0xff, 0xff, 0xff, 0x7f, 0xdc, 0xdf, 0x6e,
    0xff, 0xed,

    +    0xee, 0xb7, 0xb7, 0xfb, 0xb6, 0xbd, 0xdf, 0xff, 0xff, 0xff, 0xff, 0xdb, 0xc1,
    0x6e, 0xff,

    +    0xed, 0x6e, 0xb0, 0x37, 0xf0, 0xae, 0xbd, 0xdf, 0xff, 0xff, 0xff, 0xff, 0xd7,
    0xdd, 0x6e,

    +    0xff, 0xed, 0x6e, 0xb7, 0xb7, 0xff, 0x8e, 0xbd, 0xdf, 0xff, 0xff, 0xff, 0xbf,
    0xd3, 0xdd,

    +    0x6e, 0xf7, 0xed, 0x6e, 0xb7, 0xb3, 0xff, 0x9e, 0xdd, 0xdf, 0xff, 0xff, 0xff,
    0x7f, 0x38,

    +    0xc1, 0xe9, 0xf8, 0xed, 0x6e, 0x70, 0x74, 0xf8, 0xbe, 0xe3, 0xdd, 0xff, 0xff,
    0xff, 0xff,

    +    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfb, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff,

    +    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7f, 0xfc, 0xdf, 0xff, 0xff, 0xff,
    0xff, 0xff,

    +    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xbf, 0xff, 0xff, 0x8f, 0xff, 0xff,
    0xff, 0xff,

    +    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x23, 0xab, 0xff, 0xff, 0x73, 0xe1,
    0xff, 0xff,

    +    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc0, 0x7a, 0xf8, 0xf7, 0x9e,
    0x02, 0xff,

    +    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x3f, 0x98, 0x1f, 0x38, 0xe2,
    0xf0, 0x1a,

    +    0xfe, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x9f, 0x66, 0xbd, 0x7e,
    0xe6, 0xc0,

    +    0x67, 0xf8, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x87, 0x3a, 0x38,
    0xbf, 0xf7,

    +    0xcc, 0xdf, 0xf0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x63, 0x3e,
    0x39, 0x30,

    +    0x7f, 0xcc, 0x73, 0xc3, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xd1,
    0x3f, 0x3f,

    +    0x30, 0xff, 0xd4, 0xc1, 0x86, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7f,
    0xe8, 0x3f,

    +    0x7a, 0x3e, 0x76, 0xe0, 0x88, 0x1b, 0xfe, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0x3f, 0xf6,

    +    0x7f, 0x70, 0x3e, 0x63, 0xf2, 0xf9, 0x2d, 0xfc, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0x1f,

    +    0xd9, 0xfe, 0x60, 0x36, 0x32, 0x66, 0xfc, 0xd8, 0xf8, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff,

    +    0x8f, 0x0e, 0xff, 0x47, 0x60, 0x30, 0x66, 0xe0, 0xb1, 0xf0, 0xff, 0xff, 0xff,
    0xff, 0xff,

    +    0xff, 0x47, 0x83, 0x7e, 0xec, 0x70, 0x38, 0x73, 0xf2, 0x41, 0xe3, 0xff, 0xff,
    0xff, 0xff,

    +    0xff, 0xff, 0xa3, 0x71, 0xfe, 0xc4, 0xfe, 0x7f, 0x73, 0xfe, 0xc0, 0xc2, 0xff,
    0xff, 0xff,

    +    0xff, 0xff, 0xff, 0xd1, 0x63, 0xfe, 0xe0, 0x03, 0xc0, 0x97, 0x7f, 0xfc, 0xcb,
    0xff, 0xff,

    +    0xff, 0xff, 0xff, 0xff, 0xe9, 0x07, 0xfe, 0x3b, 0x50, 0x05, 0x3c, 0x7c, 0xfc,
    0x17, 0xff,

    +    0xff, 0xff, 0xff, 0xff, 0xff, 0xf4, 0x87, 0xff, 0x87, 0xae, 0xda, 0xe0, 0x38,
    0xfe, 0x17,

    +    0xff, 0xff, 0xff, 0xff, 0xff, 0x7f, 0x14, 0x9e, 0xff, 0xb1, 0xfa, 0x2f, 0xab,
    0x1f, 0xff,

    +    0x2f, 0xfe, 0xff, 0xff, 0xff, 0xff, 0x3f, 0x0a, 0x1c, 0x7f, 0xcc, 0xff, 0xff,
    0x15, 0x9e,

    +    0xff, 0x5f, 0xfc, 0xff, 0xff, 0xff, 0xff, 0x1f, 0x6d, 0x38, 0x1e, 0xfb, 0xff,
    0xff, 0x6f,

    +    0x98, 0xff, 0xbf, 0xfc, 0xff, 0xff, 0xff, 0xff, 0x9f, 0xc6, 0x71, 0x4c, 0xfd,
    0xff, 0xff,

    +    0xbf, 0xf1, 0xff, 0x7f, 0xf9, 0xff, 0xff, 0xff, 0xff, 0x8f, 0xce, 0x63, 0xa3,
    0xff, 0xfd,

    +    0xff, 0xff, 0xe6, 0xff, 0x7f, 0xf1, 0xeb, 0xff, 0xff, 0xff, 0x4f, 0x0f, 0xc7,
    0xdb, 0xff,

    +    0xdb, 0xf3, 0xff, 0x89, 0xff, 0xff, 0x52, 0x80, 0xff, 0xff, 0xff, 0xa7, 0x1d,
    0xce, 0xe8,

    +    0xff, 0xc1, 0xe0, 0xff, 0x97, 0xff, 0xff, 0x02, 0x00, 0xff, 0xff, 0xff, 0xa3,
    0x3c, 0xc4,

    +    0xf6, 0x7f, 0xe2, 0xc3, 0xff, 0x2f, 0xfe, 0x17, 0x00, 0x20, 0xfe, 0xff, 0xff,
    0xd3, 0xfc,

    +    0x20, 0xfa, 0xff, 0xe1, 0xe1, 0xf8, 0xdf, 0x7e, 0x01, 0x00, 0xa8, 0xfe, 0xff,
    0xff, 0x53,

    +    0xfc, 0xb1, 0xfd, 0xe1, 0xc1, 0xef, 0xf8, 0xbf, 0x08, 0x00, 0x00, 0x20, 0xfe,
    0xff, 0xff,

    +    0x69, 0xf0, 0x9f, 0xfe, 0xe3, 0xfd, 0xff, 0xfd, 0x7f, 0xc0, 0x00, 0x80, 0x86,
    0xfc, 0xff,

    +    0xff, 0x29, 0xc1, 0x4f, 0xff, 0xe0, 0xff, 0xff, 0xff, 0x0b, 0x00, 0x10, 0xf4,
    0x0f, 0xfc,

    +    0xff, 0xff, 0x68, 0x17, 0xe7, 0xff, 0xd3, 0xff, 0xff, 0x1f, 0x10, 0x00, 0xc0,
    0xfc, 0x0f,

    +    0xfc, 0xff, 0xff, 0xf4, 0x3f, 0xd6, 0xff, 0xf7, 0xff, 0xff, 0x02, 0x20, 0x00,
    0xfa, 0xfe,

    +    0x07, 0xfd, 0xff, 0x7f, 0xf4, 0x7f, 0xd2, 0x9f, 0xff, 0xff, 0x8f, 0x04, 0x10,
    0x00, 0xff,

    +    0xfd, 0x01, 0xfc, 0xff, 0xff, 0xfa, 0xff, 0xeb, 0x1f, 0xff, 0x7f, 0x01, 0x20,
    0x00, 0x0a,

    +    0xff, 0xe5, 0x01, 0xfa, 0xff, 0x7f, 0xfa, 0xff, 0xe9, 0x9f, 0xff, 0x0b, 0x00,
    0x00, 0xe5,

    +    0x1f, 0x5f, 0xe0, 0x01, 0xf8, 0xff, 0x3f, 0xfa, 0xff, 0xf5, 0xff, 0x7f, 0x00,
    0x04, 0x40,

    +    0xf8, 0x3f, 0x0f, 0xc8, 0x93, 0xf8, 0xff, 0x7f, 0xfe, 0xbf, 0xf4, 0xff, 0x0b,
    0x00, 0x00,

    +    0x7d, 0xf2, 0x3f, 0x1e, 0xc4, 0x23, 0xf8, 0xff, 0x3f, 0xfd, 0xff, 0xfc, 0x5f,
    0x00, 0x00,

    +    0x20, 0xfe, 0xf1, 0x7c, 0x1e, 0xc1, 0x03, 0xf0, 0xff, 0x3f, 0xfd, 0xff, 0xfa,
    0x05, 0x00,

    +    0x20, 0x14, 0xfe, 0xf1, 0x78, 0xfe, 0xc3, 0x03, 0xf0, 0xff, 0x3f, 0xfd, 0x7f,
    0x5a, 0x80,

    +    0x00, 0x40, 0x1f, 0xdf, 0xe3, 0x78, 0xfe, 0x83, 0x1b, 0xf0, 0xff, 0x1f, 0xff,
    0x7f, 0x00,

    +    0x00, 0x00, 0xf0, 0x3f, 0xcf, 0xe3, 0x39, 0xfe, 0xc3, 0x07, 0xf0, 0xff, 0x3f,
    0xfe, 0x17,

    +    0x00, 0x00, 0xf0, 0xe1, 0x3f, 0x8f, 0xe7, 0x3d, 0x7c, 0xa1, 0x47, 0xf0, 0xff,
    0x9f, 0x7e,

    +    0x01, 0x00, 0x40, 0xf8, 0xe7, 0x03, 0x8f, 0xe0, 0x3f, 0x1c, 0x80, 0x07, 0xe0,
    0xff, 0x9f,

    +    0x46, 0x00, 0x0c, 0x40, 0xf8, 0xe7, 0x01, 0x0f, 0xe0, 0x7f, 0x3c, 0x80, 0x0f,
    0xe0, 0xff,

    +    0x1f, 0x81, 0x00, 0x20, 0x04, 0xbc, 0xc7, 0x05, 0x8e, 0xc0, 0xff, 0x3c, 0x04,
    0x0f, 0xe4,

    +    0xff, 0x0b, 0x02, 0x01, 0xf4, 0x09, 0x3c, 0xef, 0x2b, 0x1f, 0xc0, 0xf3, 0x78,
    0x0d, 0x0f,

    +    0xe0, 0xbf, 0x00, 0x00, 0x00, 0xff, 0x0b, 0x3c, 0xc1, 0x7f, 0x1e, 0xc0, 0xf3,
    0xfc, 0x0f,

    +    0x8f, 0xe0, 0x1f, 0x02, 0x00, 0x0d, 0xfe, 0x07, 0x7a, 0xc0, 0x7f, 0x1e, 0xcf,
    0xe3, 0xf9,

    +    0x0f, 0x01, 0xe0, 0x0f, 0x00, 0xc0, 0x1f, 0xdf, 0x07, 0xf8, 0xc1, 0x7f, 0x1e,
    0x8f, 0xf3,

    +    0xf9, 0x0f, 0x00, 0xe0, 0x07, 0x80, 0xc2, 0x3f, 0x9e, 0x07, 0xf8, 0x87, 0x17,
    0x3c, 0x8f,

    +    0xe7, 0xf1, 0x00, 0x00, 0xf0, 0x07, 0xe8, 0xe7, 0x7f, 0x1e, 0x4f, 0xf0, 0xcf,
    0x07, 0x3f,

    +    0x9e, 0xe7, 0x13, 0x00, 0x20, 0xfc, 0x07, 0xfe, 0xe7, 0x79, 0x1c, 0x0f, 0xe0,
    0x9f, 0x07,

    +    0x3c, 0x8f, 0x47, 0x00, 0x00, 0x40, 0xff, 0x07, 0xff, 0xe7, 0xf9, 0xbe, 0x0f,
    0x81, 0x9f,

    +    0x07, 0xf8, 0x8f, 0x07, 0x80, 0x02, 0xf8, 0xff, 0x07, 0xfe, 0xe0, 0x71, 0xfc,
    0x87, 0x00,

    +    0x3e, 0xf7, 0xf9, 0x0f, 0x80, 0x10, 0x40, 0xf9, 0xff, 0x07, 0xf4, 0xe1, 0xf1,
    0xfc, 0x07,

    +    0x70, 0x9c, 0xff, 0xf0, 0x03, 0x40, 0x04, 0x7c, 0xf9, 0xff, 0x0f, 0xe0, 0xe0,
    0xf1, 0xfc,

    +    0x03, 0xf2, 0x3c, 0xff, 0xa1, 0x00, 0x10, 0xa0, 0x7f, 0xfc, 0xff, 0x47, 0xe0,
    0xe1, 0xf9,

    +    0x79, 0x80, 0xf0, 0xbc, 0xff, 0x01, 0x04, 0x02, 0xfa, 0x7f, 0xf9, 0xff, 0x1f,
    0xf0, 0xc1,

    +    0xe3, 0x7c, 0x29, 0xe4, 0x9f, 0x0f, 0x00, 0x20, 0x50, 0xfe, 0x7f, 0xfc, 0xfb,
    0x8f, 0xc0,

    +    0xe3, 0xe3, 0x79, 0x02, 0xe0, 0x1f, 0x00, 0x90, 0x80, 0x3e, 0xff, 0xbf, 0xfc,
    0xff, 0x0f,

    +    0xe0, 0xc1, 0xe3, 0x79, 0x14, 0xc8, 0x4f, 0x00, 0x02, 0xf4, 0x5f, 0xff, 0x7f,
    0xfc, 0xff,

    +    0x1f, 0xc0, 0xc3, 0xe3, 0x71, 0x18, 0x00, 0x41, 0x00, 0x40, 0xff, 0x2f, 0xff,
    0xbf, 0xfc,

    +    0xff, 0x1f, 0xc1, 0x83, 0xe7, 0xf9, 0x60, 0x00, 0x40, 0x00, 0xf4, 0xff, 0x9f,
    0xff, 0x3f,

    +    0xfe, 0xff, 0x1f, 0xc0, 0xc7, 0xe7, 0xf1, 0x04, 0x00, 0x20, 0xa0, 0xff, 0xfd,
    0x97, 0xff,

    +    0x5f, 0xfe, 0xee, 0x1f, 0x84, 0x8b, 0xff, 0xf1, 0x80, 0x00, 0x00, 0xfa, 0xff,
    0xf9, 0xd7,

    +    0xfc, 0x5f, 0xfe, 0xff, 0x1f, 0x81, 0x07, 0xff, 0x20, 0x02, 0x01, 0xe0, 0xff,
    0xff, 0xf9,

    +    0xcb, 0xfc, 0x3f, 0xff, 0xff, 0x3f, 0x80, 0x07, 0x7f, 0x00, 0x20, 0x00, 0xfd,
    0xff, 0xff,

    +    0xf5, 0x6b, 0xfc, 0x2f, 0xff, 0xff, 0x3f, 0x80, 0x07, 0x1c, 0x00, 0x40, 0xf0,
    0xff, 0xff,

    +    0xcf, 0xff, 0x25, 0xf8, 0x2f, 0xff, 0xff, 0x3f, 0x80, 0x17, 0x00, 0x00, 0x80,
    0xff, 0xff,

    +    0xff, 0xcb, 0xff, 0x32, 0xe0, 0x8f, 0xff, 0xff, 0x3f, 0x00, 0x07, 0x00, 0x00,
    0xf8, 0xbf,

    +    0xff, 0xbf, 0xa7, 0xff, 0x39, 0x83, 0x97, 0xff, 0xff, 0x7f, 0x00, 0x00, 0x00,
    0x80, 0xfe,

    +    0x9f, 0xff, 0xdb, 0xc7, 0x7f, 0xc9, 0x0f, 0x86, 0xff, 0xff, 0x7f, 0x00, 0x00,
    0x00, 0x3a,

    +    0xfd, 0x8f, 0x97, 0x93, 0xb7, 0xbf, 0xcc, 0x3f, 0xca, 0xff, 0xff, 0x7f, 0x04,
    0x00, 0xa0,

    +    0x7f, 0xfa, 0x3f, 0xcf, 0x07, 0xff, 0x5f, 0xc6, 0x7f, 0xc3, 0xff, 0xff, 0x7f,
    0x00, 0x00,

    +    0xfe, 0xff, 0xf4, 0xff, 0x83, 0x07, 0xff, 0x2f, 0x63, 0xfc, 0xe5, 0xff, 0xff,
    0xff, 0x10,

    +    0x40, 0xff, 0xff, 0xe9, 0xff, 0xaf, 0xc3, 0xff, 0x93, 0x43, 0xfe, 0xe2, 0xff,
    0xff, 0xff,

    +    0x31, 0x4f, 0xff, 0xff, 0x93, 0xff, 0xef, 0xdf, 0xff, 0xcd, 0x07, 0xee, 0xf2,
    0xff, 0xff,

    +    0xff, 0xef, 0x8f, 0xfe, 0xff, 0x66, 0xff, 0xff, 0xff, 0x7f, 0x62, 0x1c, 0x67,
    0xf1, 0xff,

    +    0xff, 0xff, 0xff, 0x1f, 0xfd, 0x7f, 0x8c, 0xfc, 0xff, 0xff, 0xdf, 0x39, 0x38,
    0xa0, 0xf8,

    +    0xff, 0xff, 0xff, 0xff, 0x3f, 0xfd, 0xff, 0x38, 0xf5, 0xff, 0xff, 0x57, 0x8c,
    0x78, 0xb0,

    +    0xfc, 0xff, 0xff, 0xff, 0xff, 0x3f, 0xfa, 0xff, 0x61, 0x84, 0xff, 0xff, 0x14,
    0x8f, 0xf3,

    +    0x59, 0xfc, 0xff, 0xff, 0xff, 0xff, 0x7f, 0xf4, 0x7f, 0xe0, 0xb3, 0xb4, 0x95,
    0xc5, 0x1d,

    +    0xe1, 0x2b, 0xfe, 0xff, 0xff, 0xff, 0xff, 0xff, 0xec, 0x7f, 0x3c, 0x0e, 0x55,
    0x35, 0x71,

    +    0x38, 0xc0, 0x9f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xd1, 0x7f, 0x1e, 0x7c,
    0x00, 0x01,

    +    0x3e, 0x60, 0x8c, 0x8b, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xb1, 0x1f, 0x8f,
    0xd9, 0x2f,

    +    0xfa, 0x2b, 0xf3, 0x1c, 0xc5, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xa7, 0x1f,
    0x8f, 0x19,

    +    0xff, 0x7f, 0x30, 0xfe, 0xb0, 0xe5, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc7,
    0x8e, 0xc7,

    +    0x58, 0xfc, 0x61, 0x34, 0xfe, 0x71, 0xf1, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0x0f, 0xcd,

    +    0xe7, 0x8c, 0xf8, 0x40, 0x7e, 0xde, 0xb3, 0xf0, 0xfd, 0xff, 0xff, 0xff, 0xff,
    0xff, 0x1f,

    +    0xda, 0x67, 0x8c, 0xf9, 0xcc, 0x64, 0x8c, 0x4f, 0xfc, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xdd,

    +    0x7f, 0xf4, 0x63, 0xcc, 0xf8, 0xf8, 0xe0, 0xb8, 0x37, 0xbc, 0xff, 0xfb, 0xff,
    0xff, 0xff,

    +    0xff, 0xff, 0xc8, 0x33, 0x0e, 0xfc, 0xf0, 0xd0, 0x88, 0x0b, 0xff, 0xff, 0xfe,
    0xff, 0xff,

    +    0xff, 0xff, 0xff, 0xb1, 0x47, 0x86, 0xfe, 0xc1, 0xf9, 0xc1, 0x84, 0xff, 0xff,
    0xff, 0xff,

    +    0xff, 0xff, 0xff, 0xff, 0x43, 0x06, 0xef, 0xff, 0xc7, 0xf8, 0x6b, 0xe3, 0xff,
    0xff, 0xff,

    +    0xff, 0xff, 0xff, 0xff, 0xff, 0x0f, 0xf9, 0xc7, 0xff, 0xcd, 0x81, 0x5f, 0xf0,
    0xff, 0xff,

    +    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x1f, 0xea, 0xe7, 0xff, 0x88, 0x81, 0x2b,
    0xfc, 0xff,

    +    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7f, 0x28, 0xef, 0xff, 0xc9, 0xfb,
    0x3a, 0xfe,

    +    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc1, 0xf8, 0xff, 0xe1,
    0x97, 0x92,

    +    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0f, 0x45, 0xff,
    0xbf, 0x54,

    +    0xd0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x1f, 0xb0,
    0x20, 0xa1,

    +    0x05, 0xfc, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0x00, 0x6a,

    +    0x4d, 0x80, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0x17,

    +    0x00, 0x00, 0xf0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7d, 0xff, 0xff, 0xff,
    0xff, 0xff,

    +    0xff, 0x02, 0xa0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xd7, 0xfd, 0xff,
    0xff, 0xff,

    +    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff,

    +    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff,

    +    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff,

    +    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff,

    +    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff,

    +    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff,

    +    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff,

    +    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff,

    +    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff,

    +    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff,

    +    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff,

    +    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff,

    +    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff,

    +    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff

    +  }

    +};

    +

    +void esl_tag_cli_test_harness_init(void)

    +{

    +  // Enable VCOM for CLI communication (disabled by default in Tag example)

    +  sl_board_enable_vcom();

    +}

    +

    +// Get sl_status_t result status strings

    +static const char* get_status_str(uint32_t status_code)

    +{

    +  switch (status_code) {

    +    case SL_STATUS_OK:

    +      return "OK";

    +

    +    case SL_STATUS_FAIL:

    +      return "Fail";

    +

    +    case SL_STATUS_INVALID_STATE:

    +      return "Invalid state";

    +

    +    case SL_STATUS_INVALID_PARAMETER:

    +      return "Invalid parameter";

    +

    +    case SL_STATUS_NOT_READY:

    +      return "Not ready";

    +

    +    case SL_STATUS_NOT_SUPPORTED:

    +      return "Not supported";

    +

    +    case SL_STATUS_BUSY:

    +      return "Busy";

    +

    +    case SL_STATUS_NO_MORE_RESOURCE:

    +      return "No more resource";

    +

    +    case SL_STATUS_EMPTY:

    +      return "Empty";

    +

    +    case SL_STATUS_FULL:

    +      return "Full";

    +

    +    case SL_STATUS_WOULD_OVERFLOW:

    +      return "Would overflow";

    +

    +    case SL_STATUS_BT_CTRL_CONNECTION_LIMIT_EXCEEDED:

    +      return "Connection limit exceeded";

    +

    +    case SL_STATUS_INVALID_INDEX:

    +      return "Invalid index";

    +

    +    default:

    +      return "Unknown";

    +  }

    +}

    +

    +// Get ESL State machine status name

    +static const char* get_esl_state_str(esl_state_t status_code)

    +{

    +  switch (status_code) {

    +    case esl_state_boot:

    +      return "Boot";

    +

    +    case esl_state_unassociated:

    +      return "Unassociated";

    +

    +    case esl_state_configuring:

    +      return "Configuring";

    +

    +    case esl_state_synchronized:

    +      return "Synchronized";

    +

    +    case esl_state_unsynchronized:

    +      return "Unsynchronized";

    +

    +    case esl_state_updating:

    +      return "Updating";

    +

    +    default:

    +      return "Invalid";

    +  }

    +}

    +

    +// Get ESL Basic State flag strings

    +static const char* get_esl_basic_flag_str(esl_basic_state_t basic_state_mask)

    +{

    +  switch (basic_state_mask) {

    +    case ESL_BASIC_STATE_MASK(ESL_BASIC_STATE_SERVICE_NEEDED_BIT):

    +      return "Service needed";

    +

    +    case ESL_BASIC_STATE_MASK(ESL_BASIC_STATE_SYNCHRONIZED_BIT):

    +      return "Synchronized";

    +

    +    case ESL_BASIC_STATE_MASK(ESL_BASIC_STATE_ACTIVE_LED_BIT):

    +      return "LED active";

    +

    +    case ESL_BASIC_STATE_MASK(ESL_BASIC_STATE_PENDING_LED_BIT):

    +      return "Pending LED";

    +

    +    case ESL_BASIC_STATE_MASK(ESL_BASIC_STATE_PENDING_DISPLAY_BIT):

    +      return "Pending display";

    +

    +    default:

    +      return NULL;

    +  }

    +}

    +

    +// Make ESL Basic State register status human readable

    +static void cli_decode_esl_basic_state(esl_basic_state_t basic_state)

    +{

    +  bool first = true;

    +  CLI_RESPONSE("Basic state value: 0x%02x", basic_state);

    +

    +  if (!basic_state) {

    +    CLI_RESPONSE_HEADLESS("  No basic state flag is set.");

    +    return;

    +  }

    +

    +  CLI_RESPONSE_HEADLESS("  Flags set: ");

    +  for (uint8_t i = 0; basic_state; i++) {

    +    const char* str;

    +

    +    str = get_esl_basic_flag_str(ESL_BASIC_STATE_MASK(i) & basic_state);

    +    basic_state &= (esl_basic_state_t)(~(ESL_BASIC_STATE_MASK(i)));

    +

    +    if (str) {

    +      if (first) {

    +        first = false;

    +      } else {

    +        CLI_RESPONSE_APPEND(", ");

    +      }

    +

    +      CLI_RESPONSE_APPEND("%s", str);

    +    }

    +  }

    +  app_log_nl();

    +}

    +

    +// Check if given component has logging enabled

    +static bool component_log_enabled(uint8_t component)

    +{

    +  bool enabled = (ESL_CORE_LOG_ENABLE != 0);

    +

    +  // is enabled by config?

    +  if (enabled) {

    +    switch (component & ESL_LOG_FLAGS_MASK) {

    +      case ESL_LOG_COMPONENT_CORE:

    +        if (ESL_LOG_COMPONENT_CORE_ENABLE == 0) {

    +          enabled = false;

    +        }

    +        break;

    +

    +      case ESL_LOG_COMPONENT_APP:

    +        if (ESL_LOG_COMPONENT_APP_ENABLE == 0) {

    +          enabled = false;

    +        }

    +        break;

    +

    +      case ESL_LOG_COMPONENT_DISPLAY:

    +        if (ESL_LOG_COMPONENT_DISPLAY_ENABLE == 0) {

    +          enabled = false;

    +        }

    +        break;

    +

    +      case ESL_LOG_COMPONENT_RAM_IMAGE:

    +        if (ESL_LOG_COMPONENT_RAM_IMAGE_ENABLE == 0) {

    +          enabled = false;

    +        }

    +        break;

    +

    +      case ESL_LOG_COMPONENT_NVM_IMAGE:

    +        if (ESL_LOG_COMPONENT_NVM_IMAGE_ENABLE == 0) {

    +          enabled = false;

    +        }

    +        break;

    +

    +      case ESL_LOG_COMPONENT_LED:

    +        if (ESL_LOG_COMPONENT_LED_ENABLE == 0) {

    +          enabled = false;

    +        }

    +        break;

    +

    +      case ESL_LOG_COMPONENT_OTS:

    +        if (ESL_LOG_COMPONENT_OTS_ENABLE == 0) {

    +          enabled = false;

    +        }

    +        break;

    +

    +      case ESL_LOG_COMPONENT_SENSOR:

    +        if (ESL_LOG_COMPONENT_SENSOR_ENABLE == 0) {

    +          enabled = false;

    +        }

    +        break;

    +

    +      default:

    +        // do not block any future components by default

    +        break;

    +    }

    +  }

    +

    +  return enabled;

    +}

    +

    +void cli_esl_tag_address_get(sl_cli_command_arg_t *arguments)

    +{

    +  esl_address_t address = 0;

    +  sl_status_t sc = esl_core_read_esl_address(&address);

    +  (void)sc; // warning elimination if logging disabled

    +

    +  (void)arguments;

    +  if (cli_enabled) {

    +    CLI_RESPONSE("ESL Address: 0x%04X", address);

    +    CLI_RESPONSE_HEADLESS("  ID: %u in group: %u",

    +                          esl_core_get_id(address),

    +                          esl_core_get_group_id(address));

    +    CLI_RESPONSE("Result: %s (0x%04lX)", get_status_str(sc), sc);

    +  } else {

    +    CLI_RESPONSE(CLI_ERROR);

    +  }

    +}

    +

    +void cli_esl_tag_ap_key_get(sl_cli_command_arg_t *arguments)

    +{

    +  struct sl_bt_ead_key_material_s key_data = { 0 };

    +  sl_status_t sc = esl_core_read_ap_key(&key_data);

    +  (void)sc; // warning elimination if logging disabled

    +

    +  (void)arguments;

    +  if (cli_enabled) {

    +    uint32_t i = sizeof(key_data);

    +    CLI_RESPONSE("ESL Ap Key: 0x");

    +    while (i--) {

    +      CLI_RESPONSE_APPEND("%02x", ((uint8_t *)&key_data)[i]);

    +    }

    +    CLI_RESPONSE_APPEND(APP_LOG_NL);

    +    CLI_RESPONSE("Result: %s (0x%04lX)", get_status_str(sc), sc);

    +  } else {

    +    CLI_RESPONSE(CLI_ERROR);

    +  }

    +}

    +

    +void cli_esl_tag_response_key_get(sl_cli_command_arg_t *arguments)

    +{

    +  struct sl_bt_ead_key_material_s key_data = { 0 };

    +  sl_status_t sc = esl_core_read_response_key(&key_data);

    +  (void)sc; // warning elimination if logging disabled

    +

    +  (void)arguments;

    +  if (cli_enabled) {

    +    uint32_t i = sizeof(key_data);

    +    CLI_RESPONSE("ESL Response Key: 0x");

    +    while (i--) {

    +      CLI_RESPONSE_APPEND("%02x", ((uint8_t *)&key_data)[i]);

    +    }

    +    CLI_RESPONSE_APPEND(APP_LOG_NL);

    +    CLI_RESPONSE("Result: %s (0x%04lX)", get_status_str(sc), sc);

    +  } else {

    +    CLI_RESPONSE(CLI_ERROR);

    +  }

    +}

    +

    +void cli_esl_tag_absolute_time_get(sl_cli_command_arg_t *arguments)

    +{

    +  uint32_t time = 0;

    +  sl_status_t sc = esl_core_read_absolute_time(&time);

    +  (void)sc; // warning elimination if logging disabled

    +

    +  (void)arguments;

    +  if (cli_enabled) {

    +    CLI_RESPONSE("ESL Absolute Time: %lu (0x%lX)", time, time);

    +    CLI_RESPONSE("Result: %s (0x%04lX)", get_status_str(sc), sc);

    +  } else {

    +    CLI_RESPONSE(CLI_ERROR);

    +  }

    +}

    +

    +void cli_esl_tag_led_info_get(sl_cli_command_arg_t *arguments)

    +{

    +  sl_status_t sc = SL_STATUS_OK;

    +  (void)sc; // warning elimination if logging disabled

    +

    +  (void)arguments;

    +  if (cli_enabled) {

    +    uint8_t led_count = esl_led_get_count();

    +    (void)led_count; // warning elimination if logging disabled

    +

    +    CLI_RESPONSE("LED count: %d", led_count);

    +    CLI_RESPONSE("Result: %s (0x%04lX)", get_status_str(sc), sc);

    +  } else {

    +    CLI_RESPONSE(CLI_ERROR);

    +  }

    +}

    +

    +void cli_esl_tag_display_info_get(sl_cli_command_arg_t *arguments)

    +{

    +  sl_status_t sc = SL_STATUS_NOT_SUPPORTED;

    +

    +  (void)arguments;

    +  if (cli_enabled) {

    +#if defined(gattdb_esl_display_info)

    +    uint8_t display_count = esl_display_get_count();

    +

    +    CLI_RESPONSE("Display count: %d", display_count);

    +    if (display_count) {

    +      for (uint8_t i = 0; i < display_count; i++) {

    +        uint16_t width;

    +        uint16_t height;

    +        uint8_t  type;

    +

    +        CLI_RESPONSE_HEADLESS("  Display %u:", i);

    +

    +        sc = esl_display_get_height(i, &height);

    +        if (sc != SL_STATUS_OK) {

    +          break;

    +        }

    +

    +        sc = esl_display_get_width(i, &width);

    +        if (sc != SL_STATUS_OK) {

    +          break;

    +        }

    +

    +        sc = esl_display_get_type(i, &type);

    +        if (sc != SL_STATUS_OK) {

    +          break;

    +        }

    +

    +        CLI_RESPONSE_HEADLESS("    Width:  %4u px", width);

    +        CLI_RESPONSE_HEADLESS("    Height: %4u px", height);

    +        CLI_RESPONSE_HEADLESS("    Type:   0x%02x", type);

    +      }

    +    }

    +#endif // defined(gattdb_esl_display_info)

    +    CLI_RESPONSE("Result: %s (0x%04lX)", get_status_str(sc), sc);

    +  } else {

    +    CLI_RESPONSE(CLI_ERROR);

    +  }

    +}

    +

    +void cli_esl_tag_image_info_get(sl_cli_command_arg_t *arguments)

    +{

    +  sl_status_t sc = SL_STATUS_NOT_SUPPORTED;

    +

    +  (void)arguments;

    +  (void)sc;

    +

    +  if (cli_enabled) {

    +#if defined(gattdb_esl_image_info)

    +    uint8_t gatt_data;

    +    size_t gatt_len;

    +    sc = sl_bt_gatt_server_read_attribute_value(gattdb_esl_image_info,

    +                                                0,

    +                                                sizeof(gatt_data),

    +                                                &gatt_len,

    +                                                &gatt_data);

    +

    +    CLI_RESPONSE("Max. number of images: %d", gatt_data + 1);

    +#endif // defined(gattdb_esl_image_info)

    +    CLI_RESPONSE("Result: %s (0x%04lX)", get_status_str(sc), sc);

    +  } else {

    +    CLI_RESPONSE(CLI_ERROR);

    +  }

    +}

    +

    +void cli_esl_tag_sensor_info_get(sl_cli_command_arg_t *arguments)

    +{

    +  sl_status_t sc = SL_STATUS_OK;

    +  (void)sc; // warning elimination if logging disabled

    +  (void)arguments;

    +

    +  if (cli_enabled) {

    +    uint8_t sensor_count = esl_sensor_get_count();

    +    (void)sensor_count; // warning elimination if logging disabled

    +

    +    CLI_RESPONSE("Sensor count: %d", sensor_count);

    +    CLI_RESPONSE("Result: %s (0x%04lX)", get_status_str(sc), sc);

    +  } else {

    +    CLI_RESPONSE(CLI_ERROR);

    +  }

    +}

    +

    +void cli_esl_tag_status_get(sl_cli_command_arg_t *arguments)

    +{

    +  esl_state_t status = esl_core_get_status();

    +  (void)status; // warning elimination if logging disabled

    +  (void)arguments;

    +

    +  if (cli_enabled) {

    +    CLI_RESPONSE("ESL State: %s (0x%04X)", get_esl_state_str(status), status);

    +  } else {

    +    CLI_RESPONSE(CLI_ERROR);

    +  }

    +}

    +

    +void cli_esl_tag_basic_state_get(sl_cli_command_arg_t *arguments)

    +{

    +  (void)arguments;

    +

    +  if (cli_enabled) {

    +    esl_basic_state_t basic_state = esl_core_get_basic_state();

    +    cli_decode_esl_basic_state(basic_state);

    +  } else {

    +    CLI_RESPONSE(CLI_ERROR);

    +  }

    +}

    +

    +void cli_esl_tag_service_needed_set(sl_cli_command_arg_t *arguments)

    +{

    +  sl_status_t sc = SL_STATUS_NOT_SUPPORTED;

    +  (void)sc; // warning elimination if logging disabled

    +

    +  if (cli_enabled) {

    +    esl_state_t value = (esl_state_t)sl_cli_get_argument_uint8(arguments, 0);

    +    if (ESL_SET == value || ESL_CLEAR == value) {

    +      esl_basic_state_t basic_state;

    +      basic_state = esl_core_set_basic_state_bit(ESL_BASIC_STATE_SERVICE_NEEDED_BIT,

    +                                                 value);

    +      cli_decode_esl_basic_state(basic_state);

    +      sc = SL_STATUS_OK;

    +    } else {

    +      sc = SL_STATUS_INVALID_PARAMETER;

    +    }

    +    CLI_RESPONSE("Result: %s (0x%04lX)", get_status_str(sc), sc);

    +  } else {

    +    CLI_RESPONSE(CLI_ERROR);

    +  }

    +}

    +

    +void cli_esl_tag_advertising_set(sl_cli_command_arg_t *arguments)

    +{

    +  sl_status_t sc = SL_STATUS_NOT_SUPPORTED;

    +  (void)sc; // warning elimination if logging disabled

    +

    +  (void)arguments;

    +  if (cli_enabled) {

    +    sc = esl_core_start_advertising();

    +    CLI_RESPONSE("Result: %s (0x%04lX)", get_status_str(sc), sc);

    +  } else {

    +    CLI_RESPONSE(CLI_ERROR);

    +  }

    +}

    +

    +void cli_esl_tag_image_set(sl_cli_command_arg_t *arguments)

    +{

    +  sl_status_t sc = SL_STATUS_NOT_SUPPORTED;

    +

    +  if (cli_enabled) {

    +#if defined(gattdb_esl_image_info)

    +    esl_state_t request = (esl_state_t)sl_cli_get_argument_uint8(arguments, 0);

    +    uint32_t source_image = request & 1;

    +    esl_image_object_id_t object_id = { 0 };

    +

    +    object_id[0] = request;

    +    object_id[1] = ESL_IMAGE_OBJECT_BASE >> BITS_PER_PIXEL;

    +

    +    sc = esl_image_select_object(object_id, sizeof(object_id));

    +

    +    if (sc == SL_STATUS_OK) {

    +      sc = esl_image_chunk_received(images[source_image],

    +                                    sizeof(images[source_image]));

    +    }

    +#else

    +    (void)arguments;

    +    (void)images;

    +#endif // defined(gattdb_esl_image_info)

    +    CLI_RESPONSE("Result: %s (0x%04lX)", get_status_str(sc), sc);

    +  } else {

    +    CLI_RESPONSE(CLI_ERROR);

    +  }

    +}

    +

    +void cli_esl_tag_restart(sl_cli_command_arg_t *arguments)

    +{

    +  if (cli_enabled) {

    +    if (sl_cli_get_argument_uint8(arguments, 0) == 1) {

    +      sl_bt_system_reset(sl_bt_system_boot_mode_normal);

    +    } else if (sl_cli_get_argument_uint8(arguments, 0) == 2) {

    +      esl_core_unassociate();

    +      sl_bt_system_reset(sl_bt_system_boot_mode_normal);

    +    } else {

    +      CLI_RESPONSE("Unconfirmed request, ignored!");

    +    }

    +  } else {

    +    CLI_RESPONSE(CLI_ERROR);

    +  }

    +}

    +

    +void sli_bt_esl_logger(uint8_t component, uint8_t level, const char *fmt, ...)

    +{

    +#if defined(APP_LOG_ENABLE) && APP_LOG_ENABLE

    +  if (component_log_enabled(component)) {

    +    va_list va;

    +    va_start(va, fmt);

    +

    +    if (app_log_check_level(level)) {

    +      if (!(component & ESL_LOG_FLAG_APPEND)) {

    +        app_log_nl();

    +      }

    +

    +      _app_log_print_color(level);

    +

    +      if (!(component & (ESL_LOG_FLAG_NOHEADER | ESL_LOG_FLAG_APPEND))) {

    +        _app_log_print_prefix(level);

    +        _app_log_time();

    +        _app_log_counter();

    +        _app_log_print_trace();

    +      }

    +

    +      sl_iostream_vprintf(app_log_iostream, fmt, va);

    +    }

    +    va_end(va);

    +  }

    +#else // defined(APP_LOG_ENABLE) && APP_LOG_ENABLE

    +  (void)component;

    +  (void)level;

    +  (void)fmt;

    +#endif // defined(APP_LOG_ENABLE) && APP_LOG_ENABLE

    +}

    +

    +void sli_bt_esl_log_hex_dump(uint8_t component,

    +                             uint8_t level,

    +                             void    *p_data,

    +                             uint8_t len)

    +{

    +#if defined(APP_LOG_ENABLE) && APP_LOG_ENABLE

    +  if (component_log_enabled(component)) {

    +    if (app_log_check_level(level)) {

    +      uint8_t *tmp = (uint8_t *)p_data;

    +

    +      if (!(component & ESL_LOG_FLAG_APPEND)) {

    +        app_log_nl();

    +      }

    +

    +      _app_log_print_color(level);

    +

    +      if (!(component & (ESL_LOG_FLAG_NOHEADER | ESL_LOG_FLAG_APPEND))) {

    +        _app_log_print_prefix(level);

    +        _app_log_time();

    +        _app_log_counter();

    +        _app_log_print_trace();

    +      }

    +

    +      while (len--) {

    +        if (tmp != p_data) {

    +          app_log_append(APP_LOG_HEXDUMP_SEPARATOR);

    +        }

    +

    +        app_log_append(APP_LOG_HEXDUMP_PREFIX);

    +        app_log_append(APP_LOG_HEXDUMP_FORMAT,

    +                       *tmp++);

    +      }

    +    }

    +  }

    +#else // defined(APP_LOG_ENABLE) && APP_LOG_ENABLE

    +  (void)component;

    +  (void)level;

    +  (void)p_data;

    +  (void)len;

    +#endif // defined(APP_LOG_ENABLE) && APP_LOG_ENABLE

    +}

    +

    +void sli_bt_esl_assert_func(const char *func,

    +                            const char *file,

    +                            const char *expr,

    +                            int        line)

    +{

    +  sli_bt_esl_logger(ESL_LOG_COMPONENT_CLI,

    +                    ESL_LOG_LEVEL_CRITICAL,

    +                    "Assert failed: (%s) in file: %s, function: %s @ line: %d.",

    +                    expr, file, func, line);

    +  while (1) ; // Halt

    +}'
  - '--- a/app/bluetooth/common/esl_tag_core/src/esl_tag_battery_adc.c

    +++ b/app/bluetooth/common/esl_tag_core/src/esl_tag_battery_adc.c

    @@ -0,0 +1,136 @@

    +/***************************************************************************//**

    + * @file

    + * @brief ESL Tag core built-in battery measurement with ADC.

    + *******************************************************************************

    + * # License

    + * <b>Copyright 2022 Silicon Laboratories Inc. www.silabs.com</b>

    + *******************************************************************************

    + *

    + * SPDX-License-Identifier: Zlib

    + *

    + * The licensor of this software is Silicon Laboratories Inc.

    + *

    + * This software is provided ''as-is'', without any express or implied

    + * warranty. In no event will the authors be held liable for any damages

    + * arising from the use of this software.

    + *

    + * Permission is granted to anyone to use this software for any purpose,

    + * including commercial applications, and to alter it and redistribute it

    + * freely, subject to the following restrictions:

    + *

    + * 1. The origin of this software must not be misrepresented; you must not

    + *    claim that you wrote the original software. If you use this software

    + *    in a product, an acknowledgment in the product documentation would be

    + *    appreciated but is not required.

    + * 2. Altered source versions must be plainly marked as such, and must not be

    + *    misrepresented as being the original software.

    + * 3. This notice may not be removed or altered from any source distribution.

    + *

    + ******************************************************************************/

    +#include "em_cmu.h"

    +#include "em_common.h"

    +#include "esl_tag_core_config.h"

    +#include "esl_tag_battery_internal.h"

    +

    +#if (ESL_TAG_BUILTIN_BATTERY_MEASURE_ENABLE == 1) && defined (ADC_PRESENT)

    +

    +// 1MHz ADC sample frequency will be enough

    +#define CLK_ADC_FREQ            1000000

    +

    +// ADC conversion result maximum value

    +#define ADC_RESULT_MAX          0xFFF

    +

    +// Raw ADC conversion result

    +static volatile uint32_t        sample;

    +

    +// backup for ADC Vref value in milli Volts unit - using internal Vref 5V

    +static const uint32_t           vref_mv = 5000;

    +

    +sl_status_t esl_sensor_battery_read(void)

    +{

    +  // set an implausible value until the conversion is finished

    +  sample = ESL_TAG_BATTERY_LEVEL_UNKNOWN;

    +

    +  // re-enable ADC clock

    +  CMU_ClockEnable(cmuClock_ADC0, true);

    +

    +  // start next ADC conversion

    +  ADC_Start(ADC0, adcStartSingle);

    +

    +  // only the WEAK implementation returns an error

    +  return SL_STATUS_OK;

    +}

    +

    +sl_status_t esl_sensor_battery_init(void)

    +{

    +  // enable ADC0 clock

    +  CMU_ClockEnable(cmuClock_ADC0, true);

    +

    +  // declare init structs

    +  ADC_Init_TypeDef init = ADC_INIT_DEFAULT;

    +  // use single ended default at 12-bit resolution, select Vref later

    +  ADC_InitSingle_TypeDef init_single = ADC_INITSINGLE_DEFAULT;

    +

    +  // modify init structs and initialize

    +  init.prescale = ADC_PrescaleCalc(CLK_ADC_FREQ, 0);

    +  init.timebase = ADC_TimebaseCalc(0);

    +

    +  // set acquisition time to meet minimum requirements

    +  init_single.acqTime = adcAcqTime4;

    +  // select 5V internal reference

    +  init_single.reference = adcRef5VDIFF;

    +

    +  // select ADC input

    +  init_single.posSel = adcPosSelAVDD;

    +

    +  ADC_Init(ADC0, &init);

    +  ADC_InitSingle(ADC0, &init_single);

    +

    +  // enable ADC Single Conversion Complete interrupt

    +  ADC_IntEnable(ADC0, ADC_IEN_SINGLE);

    +

    +  // enable ADC interrupts

    +  NVIC_ClearPendingIRQ(ADC0_IRQn);

    +  NVIC_EnableIRQ(ADC0_IRQn);

    +

    +  return esl_sensor_battery_read();

    +}

    +

    +void ADC0_IRQHandler(void)

    +{

    +  // get ADC result

    +  sample = ADC_DataSingleGet(ADC0);

    +

    +  ADC0->CMD = ADC_CMD_SINGLESTOP | ADC_CMD_SCANSTOP;

    +  // clear interrupt flag

    +  ADC0->IFC = _ADC_IFC_MASK;

    +

    +  // clear data FIFOs to allow enter EM2 after single converion

    +  #if defined(_ADC_SINGLEFIFOCLEAR_MASK)

    +  ADC0->SINGLEFIFOCLEAR |= ADC_SINGLEFIFOCLEAR_SINGLEFIFOCLEAR;

    +  #endif // defined(_ADC_SINGLEFIFOCLEAR_MASK)

    +

    +  // disable clock to save more power until the next conversion

    +  CMU_ClockEnable(cmuClock_ADC0, false);

    +}

    +

    +uint32_t esl_sensor_get_battery_voltage_mv(void)

    +{

    +  uint32_t battery_millivolts = ESL_TAG_BATTERY_LEVEL_UNKNOWN;

    +  CORE_DECLARE_IRQ_STATE;

    +

    +  CORE_ENTER_CRITICAL();

    +  if (sample != ESL_TAG_BATTERY_LEVEL_UNKNOWN) {

    +    // for single-ended conversions, the result can range from 0 to

    +    // +Vref, i.e., for Vref = adcRef5V = 5.0 V the value 0xFFF represents the

    +    // full scale value of 5.0 V. Since our input is AVDD, the actual battery

    +    // value can be calculated as follows (with rounding correction for integer

    +    // division)

    +    battery_millivolts = ((sample * vref_mv) + (ADC_RESULT_MAX / 2))

    +                         / ADC_RESULT_MAX;

    +  }

    +  CORE_EXIT_CRITICAL();

    +

    +  return battery_millivolts;

    +}

    +#endif // (ESL_TAG_BUILTIN_BATTERY_MEASURE_ENABLE == 1) && defined (ADC_PRESENT)'
  - '--- a/app/bluetooth/common/esl_tag_core/src/esl_tag_battery_iadc.c

    +++ b/app/bluetooth/common/esl_tag_core/src/esl_tag_battery_iadc.c

    @@ -0,0 +1,166 @@

    +/***************************************************************************//**

    + * @file

    + * @brief ESL Tag core built-in battery measurement with IADC.

    + *******************************************************************************

    + * # License

    + * <b>Copyright 2022 Silicon Laboratories Inc. www.silabs.com</b>

    + *******************************************************************************

    + *

    + * SPDX-License-Identifier: Zlib

    + *

    + * The licensor of this software is Silicon Laboratories Inc.

    + *

    + * This software is provided ''as-is'', without any express or implied

    + * warranty. In no event will the authors be held liable for any damages

    + * arising from the use of this software.

    + *

    + * Permission is granted to anyone to use this software for any purpose,

    + * including commercial applications, and to alter it and redistribute it

    + * freely, subject to the following restrictions:

    + *

    + * 1. The origin of this software must not be misrepresented; you must not

    + *    claim that you wrote the original software. If you use this software

    + *    in a product, an acknowledgment in the product documentation would be

    + *    appreciated but is not required.

    + * 2. Altered source versions must be plainly marked as such, and must not be

    + *    misrepresented as being the original software.

    + * 3. This notice may not be removed or altered from any source distribution.

    + *

    + ******************************************************************************/

    +#include "em_cmu.h"

    +#include "em_common.h"

    +#include "esl_tag_core_config.h"

    +#include "esl_tag_battery_internal.h"

    +

    +#if (ESL_TAG_BUILTIN_BATTERY_MEASURE_ENABLE == 1) && defined (IADC_PRESENT)

    +

    +// set 2MHz ADC base clock for reduced current consumption

    +#define CLK_SRC_ADC_FREQ        2000000

    +

    +// 1MHz ADC sample frequency will be enough

    +#define CLK_ADC_FREQ            1000000

    +

    +// ADC conversion result maximum value

    +#define ADC_RESULT_MAX          0xFFF

    +

    +// Raw IADC conversion result

    +static volatile IADC_Result_t   sample;

    +

    +// backup for IADC Vref value in milli Volts unit

    +static uint32_t                 vref_mv;

    +

    +sl_status_t esl_sensor_battery_read(void)

    +{

    +  // set an implausible value until the conversion is finished

    +  sample.data = ESL_TAG_BATTERY_LEVEL_UNKNOWN;

    +

    +  // re-enable the peripheral clock

    +  CMU_ClockEnable(cmuClock_IADC0, true);

    +  // re-enable IADC0

    +  IADC0->EN_SET = IADC_EN_EN;

    +

    +  IADC_command(IADC0, iadcCmdStartSingle);

    +

    +  // only the WEAK implementation returns an error

    +  return SL_STATUS_OK;

    +}

    +

    +sl_status_t esl_sensor_battery_init(void)

    +{

    +  // declare IADC initialization structures

    +  IADC_Init_t init = IADC_INIT_DEFAULT;

    +  IADC_AllConfigs_t init_all_configs = IADC_ALLCONFIGS_DEFAULT;

    +  IADC_InitSingle_t init_single = IADC_INITSINGLE_DEFAULT;

    +

    +  // single input structure

    +  IADC_SingleInput_t single_input = IADC_SINGLEINPUT_DEFAULT;

    +  CMU_ClockEnable(cmuClock_IADC0, true);

    +

    +  // use the FSRC0 as the IADC clock so it can run in EM2

    +  CMU_CLOCK_SELECT_SET(IADCCLK, FSRCO);

    +

    +  // set the prescaler needed for the intended IADC clock frequency

    +  init.srcClkPrescale = IADC_calcSrcClkPrescale(IADC0, CLK_SRC_ADC_FREQ, 0);

    +

    +  // Shutdown between conversions to reduce current

    +  init.warmup = iadcWarmupNormal;

    +

    +  // select 2x oversampling which implicitly generates 12-bit results

    +  init_all_configs.configs[0].osrHighSpeed = iadcCfgOsrHighSpeed2x;

    +

    +  // set derive the intended CLK_ADC frequency.

    +  init_all_configs.configs[0].adcClkPrescale = IADC_calcAdcClkPrescale(IADC0,

    +                                                                       CLK_ADC_FREQ,

    +                                                                       0,

    +                                                                       iadcCfgModeNormal,

    +                                                                       init.srcClkPrescale);

    +

    +  // the following will actually select AVDD/4 to measure, according to RM

    +  single_input.posInput   = iadcPosInputAvdd;

    +

    +  // store vref value for later use

    +  vref_mv = init_all_configs.configs[0].vRef;

    +

    +  // initialize IADC

    +  IADC_init(IADC0, &init, &init_all_configs);

    +

    +  // initialize a single-channel conversion

    +  IADC_initSingle(IADC0, &init_single, &single_input);

    +

    +  // clear any previous interrupt flags

    +  IADC_clearInt(IADC0, _IADC_IF_MASK);

    +

    +  // enable single-channel done interrupts

    +  IADC_enableInt(IADC0, IADC_IEN_SINGLEDONE);

    +

    +  // enable IADC interrupts

    +  NVIC_ClearPendingIRQ(IADC_IRQn);

    +  NVIC_EnableIRQ(IADC_IRQn);

    +

    +  return esl_sensor_battery_read();

    +}

    +

    +void IADC_IRQHandler(void)

    +{

    +  // read a result from the FIFO

    +  sample = IADC_pullSingleFifoResult(IADC0);

    +

    +  // clear the interrupt flag

    +  IADC_clearInt(IADC0, IADC_IF_SINGLEDONE);

    +  #if defined(IADC_STATUS_SYNCBUSY)

    +  while ((IADC0->STATUS & IADC_STATUS_SYNCBUSY) != 0U) {

    +    // wait for synchronization to finish before disable

    +  }

    +  #endif // defined(IADC_STATUS_SYNCBUSY)

    +  // to reduce power consumption to the limits: disable IADC0 in EM2

    +  IADC0->EN_CLR = IADC_EN_EN;

    +

    +  #if defined _IADC_EN_DISABLING_MASK && defined IADC_EN_DISABLING

    +  // wait for IADC to disable on some MCUs, e.g. on BG24

    +  while ((IADC0->EN & _IADC_EN_DISABLING_MASK) == IADC_EN_DISABLING) ;

    +  #endif // defined _IADC_EN_DISABLING_MASK && defined IADC_EN_DISABLING

    +

    +  // and disable the peripheral clock too after every single conversion

    +  CMU_ClockEnable(cmuClock_IADC0, false);

    +}

    +

    +uint32_t esl_sensor_get_battery_voltage_mv(void)

    +{

    +  uint32_t battery_millivolts = ESL_TAG_BATTERY_LEVEL_UNKNOWN;

    +  CORE_DECLARE_IRQ_STATE;

    +

    +  CORE_ENTER_CRITICAL();

    +  if (sample.data != ESL_TAG_BATTERY_LEVEL_UNKNOWN) {

    +    // for single-ended conversions, the result can range from 0 to

    +    // +Vref, i.e., for Vref = VrefInt = 1.21 V the value 0xFFF represents the

    +    // full scale value of 1.21 V. Since our input is AVDD / 4, the actual

    +    // battery value can be calculated as follows (with rounding correction for

    +    // integer division)

    +    battery_millivolts = ((4 * sample.data * vref_mv) + (ADC_RESULT_MAX / 2))

    +                         / ADC_RESULT_MAX;

    +  }

    +  CORE_EXIT_CRITICAL();

    +

    +  return battery_millivolts;

    +}

    +#endif // (ESL_TAG_BUILTIN_BATTERY_MEASURE_ENABLE == 1) && defined (IADC_PRESENT)'
  - '--- a/app/bluetooth/common/esl_tag_core/src/esl_tag_core.c

    +++ b/app/bluetooth/common/esl_tag_core/src/esl_tag_core.c

    @@ -0,0 +1,1398 @@

    +/***************************************************************************//**

    + * @file

    + * @brief ESL Tag core component logic.

    + *******************************************************************************

    + * # License

    + * <b>Copyright 2021 Silicon Laboratories Inc. www.silabs.com</b>

    + *******************************************************************************

    + *

    + * SPDX-License-Identifier: Zlib

    + *

    + * The licensor of this software is Silicon Laboratories Inc.

    + *

    + * This software is provided ''as-is'', without any express or implied

    + * warranty. In no event will the authors be held liable for any damages

    + * arising from the use of this software.

    + *

    + * Permission is granted to anyone to use this software for any purpose,

    + * including commercial applications, and to alter it and redistribute it

    + * freely, subject to the following restrictions:

    + *

    + * 1. The origin of this software must not be misrepresented; you must not

    + *    claim that you wrote the original software. If you use this software

    + *    in a product, an acknowledgment in the product documentation would be

    + *    appreciated but is not required.

    + * 2. Altered source versions must be plainly marked as such, and must not be

    + *    misrepresented as being the original software.

    + * 3. This notice may not be removed or altered from any source distribution.

    + *

    + ******************************************************************************/

    +#include <stdio.h>

    +#include <stdint.h>

    +#include <stdlib.h>

    +#include <string.h>

    +#include "em_core.h"

    +#include "em_emu.h"

    +#include "gatt_db.h"

    +#include "app_scheduler.h"

    +#include "sl_sleeptimer.h"

    +#include "esl_tag_log.h"

    +#include "esl_tag_tlv.h"

    +#include "esl_tag_core.h"

    +#include "esl_tag_crypto.h"

    +#include "esl_tag_opcodes.h"

    +#include "esl_tag_internal.h"

    +#include "esl_tag_response.h"

    +#include "esl_tag_led_core.h"

    +#include "esl_tag_image_core.h"

    +#include "esl_tag_sensor_core.h"

    +#include "esl_tag_display_core.h"

    +#include "esl_tag_battery_internal.h"

    +

    +// Encryption requires bonding. This setting will also enable bonding.

    +#define ESL_SECURITY_BASE_FLAGS   (0x02)

    +

    +// Allow connections only from bonded devices

    +#define ESL_SECURITY_BONDED_ONLY  (0x10)

    +

    +// Maximum allowed bonding count

    +#define ESL_MAX_BONDINGS          (1)

    +

    +// Maximum number of PAwR packets that can be skipped after a successful receive

    +#define ESL_SYNC_SKIP             (0)

    +

    +// Minimum permitted time between successful receives.

    +#define ESL_SYNC_MIN_TIMEOUT      (0x0a)    // see sl_bt_sync_set_parameters
    API

    +

    +// Maximum permitted time between successful receives.

    +#define ESL_SYNC_MAX_TIMEOUT      (0x4000)  // see sl_bt_sync_set_parameters
    API

    +

    +// Bonding policy: if database is full, new bonding attempts will fail

    +#define ESL_BONDING_POLICY_FLAGS  (0)

    +

    +// Invalid ESL Access Point BT address

    +#define ESL_INVALID_AP_ADDRESS    ("\0\0\0\0\0\0")

    +

    +// Timeout in milliseconds, ESLP d095r11, Section 8.3 Security Requirements

    +#define ESL_CORE_SECURITY_TIMEOUT_MS      (60u * 60u * 1000u) // min * sec *
    ms

    +

    +// Security timeout callback priority

    +#define ESL_CORE_SECURITY_TIMER_PRIORITY  1

    +

    +// some flags for internal use, only:

    +#define ESL_CONFIG_FLAG_ESL_ADDRESS       (0x01u)

    +#define ESL_CONFIG_FLAG_ESL_AP_KEY        (0x02u)

    +#define ESL_CONFIG_FLAG_ESL_RESPONSE_KEY  (0x04u)

    +#define ESL_CONFIG_FLAG_ESL_ABS_TIME      (0x08u)

    +#define ESL_CONFIG_FLAG_UPDATE_COMPLETE   (0x10u)

    +#define ESL_CONFIG_FLAGS_MANDATORY_MASK   (ESL_CONFIG_FLAG_ESL_ADDRESS        \

    +                                           | ESL_CONFIG_FLAG_ESL_AP_KEY       \

    +                                           | ESL_CONFIG_FLAG_ESL_RESPONSE_KEY
    \

    +                                           | ESL_CONFIG_FLAG_ESL_ABS_TIME)

    +

    +// Periodic Advertisement with Responses interval resolution from LE Core spec.

    +#define ESL_PAWR_INTERVAL_RESOLUTION_MS   1.25f

    +

    +// Multiplier for clock drift compensation with integer math only

    +#define ESL_DRIFT_INTEGER_MULTIPLIER      100u

    +

    +// Actual helper constant for clock drift compensation

    +#define ESL_PAWR_INTEGER_INTERVAL  (uint32_t)(ESL_DRIFT_INTEGER_MULTIPLIER \

    +                                              * ESL_PAWR_INTERVAL_RESOLUTION_MS)

    +

    +// Divisor constant for unit to milli unit conversion

    +#define ESL_DRIFT_THRESHOLD_DIVISOR    1000u

    +

    +typedef struct {

    +  // Timestamp of last PAwR sync received event

    +  uint64_t pawr_timestamp;

    +  // ESL Control Point Notifications status

    +  bool     notifications_enabled;

    +  // Helper variable to accumulate time drifts

    +  int32_t  tick_error;

    +  // ESL Absolute Time cumulative and continuously adjusted offset

    +  uint32_t time_offset;

    +  // PAwR interval value

    +  uint32_t pawr_interval_ticks;

    +  // Sync timeout parameter for the PAwR sync.

    +  uint32_t sync_timeout;

    +  // The Sync handle allocated from Bluetooth stack.

    +  uint16_t sync_handle;

    +  // ESL Tag Basic state variable

    +  esl_basic_state_t basic_state;

    +  // ESL Tag Internal status variable

    +  esl_state_t status;

    +  // ESL Tag Internal configuration status variable

    +  uint8_t config_status;

    +  // The connection handle allocated from Bluetooth stack.

    +  uint8_t connection_handle;

    +  // The bonding handle allocated from Bluetooth stack.

    +  uint8_t bonding_handle;

    +  // ESL Access Point BT address

    +  bd_addr ap_address;

    +  // ESL Address local storage

    +  union {

    +    esl_address_t value;

    +    struct {

    +      uint8_t esl_id;

    +      uint8_t group_id;

    +    };

    +  } address;

    +  // ESL AP Sync key local storage

    +  struct sl_bt_ead_key_material_s ap_key;

    +  // ESL Response key local storage

    +  struct sl_bt_ead_key_material_s response_key;

    +} esl_struct_t;

    +

    +typedef struct {

    +  // Security timeout task handle

    +  sl_sleeptimer_timer_handle_t watchdog_handle;

    +  // PAwR evt_pawr_sync_subevent_report.event_counter backup

    +  uint16_t request_event;

    +  // PAwR evt_pawr_sync_subevent_report.subevent field backup

    +  uint8_t request_subevent;

    +  // The advertising set handle allocated from Bluetooth stack.

    +  uint8_t advertising_set_handle;

    +} esl_persistent_struct_t;

    +

    +// Custom data for advertising, in accordance with ESLS v1.0r01, section 2.7.3.1

    +static const uint8_t esl_core_advertising_data[] = {

    +  0x02, 0x01, 0x06,        // Flags

    +  0x03, 0x03, 0x57, 0x18   // Complete list of 16 bits UUID - ESL Service (only)

    +};

    +

    +static const char *esl_states_string[] = {

    +  "Boot",

    +  "Unassociated",

    +  "Configuring",

    +  "Synchronized",

    +  "Unsynchronized",

    +  "Updating"

    +};

    +

    +static esl_struct_t esl_tag = {

    +  .pawr_timestamp         = 0,

    +  .notifications_enabled  = false,

    +  .tick_error             = 0,

    +  .time_offset            = 0,

    +  .pawr_interval_ticks    = 0,

    +  .sync_timeout           = ESL_SYNC_MIN_TIMEOUT,

    +  .sync_handle            = SL_BT_INVALID_SYNC_HANDLE,

    +  .basic_state            = 0,

    +  .status                 = esl_state_boot,

    +  .config_status          = 0,

    +  .connection_handle      = SL_BT_INVALID_CONNECTION_HANDLE,

    +  .bonding_handle         = SL_BT_INVALID_BONDING_HANDLE,

    +  .ap_address             = { { 0 } },

    +  .address.value          = 0,

    +  .ap_key                 = { { 0 } },

    +  .response_key           = { { 0 } }

    +};

    +

    +static esl_persistent_struct_t esl_tag_persistent = {

    +  .watchdog_handle        = { 0 },

    +  .request_event          = 0,

    +  .request_subevent       = 0,

    +  .advertising_set_handle = SL_BT_INVALID_ADVERTISING_SET_HANDLE

    +};

    +

    +// ESL Tag PAwR sync handle getter

    +uint16_t esl_core_get_sync_handle(void)

    +{

    +  return esl_tag.sync_handle;

    +}

    +

    +// ESL Tag PAwR request event getter

    +uint16_t esl_core_get_request_event(void)

    +{

    +  return esl_tag_persistent.request_event;

    +}

    +

    +// ESL Tag PAwR response subevent getter

    +uint8_t esl_core_get_request_subevent(void)

    +{

    +  return esl_tag_persistent.request_subevent;

    +}

    +

    +// ESL Tag asynchronous disconnect

    +void esl_core_async_disconnect(void *p_event_data, uint16_t event_size)

    +{

    +  (void)event_size;

    +  (void)p_event_data;

    +

    +  if (esl_tag.connection_handle != SL_BT_INVALID_CONNECTION_HANDLE) {

    +    // there''s nothing that we could do with return value below due the async
    call

    +    (void)sl_bt_connection_close(esl_tag.connection_handle);

    +  }

    +}

    +

    +// ESL Tag unassociate (resets configuration, connection and bonding)

    +void esl_core_unassociate(void)

    +{

    +  sl_status_t sc;

    +

    +  (void)sc; // suppress the compiler warning if sl_bt_esl_assert disabled

    +  esl_state_t last_status = esl_tag.status;

    +

    +  esl_core_purge_delayed_commands();

    +  esl_core_clear_last_error();

    +  esl_core_purge_responses();

    +

    +  memset(&esl_tag, 0, sizeof(esl_tag));

    +  // set some fundamental values properly after cleanup

    +  esl_tag.status                = last_status;

    +  esl_tag.connection_handle     = SL_BT_INVALID_CONNECTION_HANDLE,

    +  esl_tag.bonding_handle        = SL_BT_INVALID_BONDING_HANDLE;

    +  esl_tag.sync_timeout          = ESL_SYNC_MIN_TIMEOUT;

    +  esl_tag.sync_handle           = SL_BT_INVALID_SYNC_HANDLE;

    +

    +  sl_bt_sm_delete_bondings();

    +

    +  sc = sl_bt_sm_configure(ESL_SECURITY_BASE_FLAGS,

    +                          sl_bt_sm_io_capability_noinputnooutput);

    +  sl_bt_esl_assert(sc == SL_STATUS_OK);

    +

    +  // call user callback before start advertising

    +  esl_core_unassociate_callback();

    +

    +  (void)esl_core_start_advertising();

    +}

    +

    +/*******************************************************************************

    + * ESL Security timeout handler

    + *

    + * @param[in] data Unused by this function but mandatory for sleeptimer tasks

    + * @param[in] size Unused by this function but mandatory for sleeptimer tasks

    + ******************************************************************************/

    +void esl_security_timeout(sl_sleeptimer_timer_handle_t *timer, void *data)

    +{

    +  // suppress compiler warnings

    +  (void)timer;

    +  (void)data;

    +

    +  if (esl_state_unsynchronized == esl_tag.status) {

    +    // ESLS d095r13 2.7.3.5 Unsynchronized state watchdog requirement

    +    esl_core_unassociate();

    +    sl_bt_esl_log(ESL_LOG_COMPONENT_CORE,

    +                  ESL_LOG_LEVEL_INFO,

    +                  "Unassociated by watchdog timeout.");

    +  } else if (esl_state_unassociated == esl_tag.status) {

    +    // shutdown after one or two hours of advertising in vain

    +    sl_bt_esl_log(ESL_LOG_COMPONENT_CORE,

    +                  ESL_LOG_LEVEL_INFO,

    +                  "Shutdown by watchdog timeout.");

    +    (void)sl_sleeptimer_stop_timer(&esl_tag_persistent.watchdog_handle);

    +    EMU_EM4Init_TypeDef em4init;

    +

    +    esl_core_shutdown_hook();

    +

    +    em4init.em4State = emuEM4Shutoff;

    +    em4init.retainLfxo = false;

    +    em4init.retainLfrco = false;

    +    em4init.retainUlfrco = false;

    +    em4init.pinRetentionMode = emuPinRetentionDisable;

    +

    +    EMU_EM4Init(&em4init);

    +    CORE_CRITICAL_SECTION(

    +      GPIO_IntClear(GPIO_IntGet());

    +      EMU_EnterEM4S();

    +      );

    +    NVIC_SystemReset(); // just in case, we should never get here, anyway.

    +  } else if (esl_tag.sync_handle != SL_BT_INVALID_SYNC_HANDLE) {

    +    // implement ESLS d095r13  2.7.3.3 Synchronized state watchdog requirement

    +    sl_bt_sync_close(esl_tag.sync_handle);

    +    sl_bt_esl_log(ESL_LOG_COMPONENT_CORE,

    +                  ESL_LOG_LEVEL_INFO,

    +                  "Unsynchronized by watchdog timeout.");

    +  }

    +}

    +

    +static inline bool is_esl_configured_for(uint8_t mask)

    +{

    +  bool result = (mask

    +                 == (esl_tag.config_status & mask));

    +  return result;

    +}

    +

    +static void esl_sync_cleanup(uint16_t reason)

    +{

    +  esl_tag.sync_handle = SL_BT_INVALID_SYNC_HANDLE;

    +  esl_core_set_basic_state_bit(ESL_BASIC_STATE_SYNCHRONIZED_BIT, ESL_CLEAR);

    +

    +  if (reason == SL_STATUS_BT_CTRL_CONNECTION_TERMINATED_BY_LOCAL_HOST) {

    +    sl_bt_esl_log(ESL_LOG_COMPONENT_CORE,

    +                  ESL_LOG_LEVEL_INFO,

    +                  "Sync closed on request.");

    +  } else {

    +    sl_bt_esl_log(ESL_LOG_COMPONENT_CORE,

    +                  ESL_LOG_LEVEL_INFO,

    +                  "Sync lost due 0x%04x",

    +                  reason);

    +  }

    +

    +  if (esl_tag.status == esl_state_synchronized) {

    +    (void)esl_core_start_advertising();

    +  }

    +}

    +

    +static void esl_state_boot_handler(sl_bt_msg_t *evt)

    +{

    +  sl_status_t sc;

    +  (void)sc; // suppress the compiler warning if sl_bt_esl_assert is disabled

    +  (void)esl_states_string; // suppress warning if sl_bt_esl_log is disabled

    +

    +  switch (SL_BT_MSG_ID(evt->header)) {

    +    case sl_bt_evt_system_boot_id: {

    +      uint32_t num_bondings;

    +      size_t   data_lenght;

    +      uint32_t bondings;

    +      uint32_t seed;

    +      uint8_t  flags = ESL_SECURITY_BASE_FLAGS;

    +

    +      esl_sensor_battery_init();

    +      // This state  changes ESL internal status and calls for ESL boot

    +      // event handler (to be written by the users). After that, the data

    +      // for the characteristics shall be ready to be set for this lifecycle.

    +      esl_core_boot_event(); // e.g. users add their displays, leds, etc.

    +

    +      // This function will write the appropriate characteristics - if present

    +      esl_image_characteristic_update();

    +

    +      // limit the bonding count

    +      sc = sl_bt_sm_store_bonding_configuration(ESL_MAX_BONDINGS,

    +                                                ESL_BONDING_POLICY_FLAGS);

    +      sl_bt_esl_assert(sc == SL_STATUS_OK);

    +

    +      sc = sl_bt_sm_get_bonding_handles(0,

    +                                        &num_bondings,

    +                                        sizeof(bondings),

    +                                        &data_lenght,

    +                                        (uint8_t *)&bondings);

    +      sl_bt_esl_assert(sc == SL_STATUS_OK);

    +

    +      if (!num_bondings || num_bondings > ESL_MAX_BONDINGS) {

    +        // delete all just in case, ignore status

    +        (void)sl_bt_sm_delete_bondings();

    +        // accept bonding since now none is available

    +        sc = sl_bt_sm_set_bondable_mode(ESL_TRUE);

    +        sl_bt_esl_assert(sc == SL_STATUS_OK);

    +      } else {

    +        // do not accept more bondings

    +        sc = sl_bt_sm_set_bondable_mode(ESL_FALSE);

    +        sl_bt_esl_assert(sc == SL_STATUS_OK);

    +

    +        // extend security flags

    +        flags |= ESL_SECURITY_BONDED_ONLY;

    +

    +        // set esl_tag.bonding_handle, default 0

    +        esl_tag.bonding_handle = 0;

    +

    +        // find non-zero handle, if so

    +        while ((bondings & 1) == 0 && data_lenght > 0) {

    +          // increment bonding handle until the proper one found

    +          if ((++esl_tag.bonding_handle & 0x07) == 0) {

    +            // decrement the bondings_len after each byte checked

    +            --data_lenght;

    +          }

    +

    +          bondings >>= 1;

    +        }

    +      }

    +

    +      // configure security options

    +      sc = sl_bt_sm_configure(flags, sl_bt_sm_io_capability_noinputnooutput);

    +      sl_bt_esl_assert(sc == SL_STATUS_OK);

    +

    +      // create advertising set once

    +      sc = sl_bt_advertiser_create_set(&esl_tag_persistent.advertising_set_handle);

    +      sl_bt_esl_assert(sc == SL_STATUS_OK);

    +

    +      sc = sl_bt_system_get_random_data(sizeof(uint32_t) - 1,

    +                                        sizeof(seed),

    +                                        &data_lenght,

    +                                        (uint8_t *)&seed);

    +      sl_bt_esl_assert(sc == SL_STATUS_OK);

    +      sl_bt_esl_log(ESL_LOG_COMPONENT_CORE,

    +                    ESL_LOG_LEVEL_DEBUG,

    +                    "Started with random seed: %lu.",

    +                    seed);

    +      // init stdlib''s rand() generator by our TRNG seed

    +      srand(seed);

    +      // Set custom data for advertising, according to ESLS v0.9d095r08, section
    2.7.3.1

    +      sc = sl_bt_legacy_advertiser_set_data(esl_tag_persistent.advertising_set_handle,

    +                                            sl_bt_advertiser_advertising_data_packet,

    +                                            sizeof(esl_core_advertising_data),

    +                                            esl_core_advertising_data);

    +      sl_bt_esl_assert(sc == SL_STATUS_OK);

    +      // Start advertising before leave the boot state

    +      sc = esl_core_start_advertising();

    +      sl_bt_esl_assert(sc == SL_STATUS_OK);

    +    } break;

    +

    +    // This state doesn''t care about anything else than the stack boot event.

    +    default:

    +      break;

    +  }

    +}

    +

    +static void esl_state_connectable_handler(sl_bt_msg_t *evt)

    +{

    +  sl_status_t sc;

    +  (void)sc; // suppress the compiler warning if sl_bt_esl_assert disabled

    +

    +  switch (SL_BT_MSG_ID(evt->header)) {

    +    case sl_bt_evt_sm_bonding_failed_id:

    +      sl_bt_esl_log(ESL_LOG_COMPONENT_CORE,

    +                    ESL_LOG_LEVEL_ERROR,

    +                    "Bond fail reason: %d.",

    +                    evt->data.evt_sm_bonding_failed.reason);

    +      if (evt->data.evt_sm_bonding_failed.reason == SL_STATUS_BT_CTRL_PIN_OR_KEY_MISSING)
    {

    +        // can happen if the key was cleared on the Tag

    +        sl_bt_esl_log(ESL_LOG_COMPONENT_CORE,

    +                      ESL_LOG_LEVEL_WARNING,

    +                      "Bonding key missing, close.");

    +        // safe to ignore the return value below

    +        (void)sl_bt_connection_close(evt->data.evt_sm_bonding_failed.connection);

    +      } else if (evt->data.evt_sm_bonding_failed.reason == SL_STATUS_BT_SMP_PAIRING_NOT_SUPPORTED)
    {

    +        // can happen if another AP tries to connect or the bonded AP lost the
    key

    +        sl_bt_esl_log(ESL_LOG_COMPONENT_CORE,

    +                      ESL_LOG_LEVEL_WARNING,

    +                      "Only one bonding is permitted, close.");

    +        sl_bt_connection_close(evt->data.evt_sm_bonding_failed.connection);

    +

    +        // check if it''s the already bonded AP - if it is, then retry bonding

    +        if (memcmp(&esl_tag.ap_address.addr, ESL_INVALID_AP_ADDRESS, sizeof(bd_addr))
    != 0) {

    +          sl_bt_esl_log(ESL_LOG_COMPONENT_CORE,

    +                        ESL_LOG_LEVEL_WARNING,

    +                        "AP seemingly lost LTK key, retry bonding.");

    +

    +          if (esl_tag.status > esl_state_unassociated) {

    +            esl_core_unassociate();

    +          }

    +        }

    +      }

    +      break;

    +

    +    case sl_bt_evt_connection_parameters_id:

    +      if (evt->data.evt_connection_parameters.security_mode > sl_bt_connection_mode1_level1

    +          && esl_tag.bonding_handle != SL_BT_INVALID_BONDING_HANDLE) {

    +        // pre-configure PAST receiver for the current connection

    +        sl_bt_past_receiver_set_sync_receive_parameters(evt->data.evt_connection_parameters.connection,

    +                                                        sl_bt_past_receiver_mode_synchronize,

    +                                                        ESL_SYNC_SKIP,

    +                                                        ESL_SYNC_MAX_TIMEOUT,

    +                                                        sl_bt_sync_report_all);

    +

    +        // further internal state depends on the status of ESL configuration

    +        if (is_esl_configured_for(ESL_CONFIG_FLAGS_MANDATORY_MASK)) {

    +          esl_tag.status = esl_state_updating;

    +        } else {

    +          esl_tag.status = esl_state_configuring;

    +        }

    +        sl_bt_esl_log(ESL_LOG_COMPONENT_CORE,

    +                      ESL_LOG_LEVEL_INFO,

    +                      "State transition to %s due connection parameters change",

    +                      esl_states_string[esl_tag.status]);

    +      }

    +      break;

    +

    +    case sl_bt_evt_sm_bonded_id:

    +      if (esl_tag.bonding_handle == SL_BT_INVALID_BONDING_HANDLE) {

    +        esl_tag.bonding_handle = evt->data.evt_sm_bonded.bonding;

    +

    +        sc = sl_bt_sm_configure(ESL_SECURITY_BASE_FLAGS

    +                                | ESL_SECURITY_BONDED_ONLY,

    +                                sl_bt_sm_io_capability_noinputnooutput);

    +        sl_bt_esl_assert(sc == SL_STATUS_OK);

    +        // do not accept bonding anymore

    +        (void)sl_bt_sm_set_bondable_mode(ESL_FALSE);

    +        // at this point the internal state shall be esl_state_configuring

    +        esl_tag.status = esl_state_configuring;

    +        sl_bt_esl_log(ESL_LOG_COMPONENT_CORE,

    +                      ESL_LOG_LEVEL_INFO,

    +                      "State transition to %s on bonding",

    +                      esl_states_string[esl_tag.status]);

    +        // pre-configure PAST receiver for the current connection

    +        sl_bt_past_receiver_set_sync_receive_parameters(evt->data.evt_sm_bonded.connection,

    +                                                        sl_bt_past_receiver_mode_synchronize,

    +                                                        ESL_SYNC_SKIP,

    +                                                        ESL_SYNC_MAX_TIMEOUT,

    +                                                        sl_bt_sync_report_all);

    +      } else {

    +      #if (ESL_MAX_BONDINGS > 1) && (!ESL_SECURITY_BONDED_ONLY)

    +        // the pre-processor condition optimizes code size if the configuration
    allows

    +        sl_bt_esl_log(ESL_LOG_COMPONENT_CORE,

    +                      ESL_LOG_LEVEL_ERROR,

    +                      "Bonding not permitted, close.");

    +        (void)sl_bt_sm_delete_bonding(evt->data.evt_sm_bonded.bonding);

    +        sc = sl_bt_connection_close(evt->data.evt_sm_bonded.connection);

    +        sl_bt_esl_assert(sc == SL_STATUS_OK);

    +      #endif // (ESL_MAX_BONDINGS > 1) && (!ESL_SECURITY_BONDED_ONLY)

    +      }

    +      break;

    +

    +    case sl_bt_evt_connection_opened_id:

    +      // Remove update complete flag

    +      esl_tag.config_status &= (uint8_t) (~ESL_CONFIG_FLAG_UPDATE_COMPLETE);

    +      // store connection handle for later use

    +      esl_tag.connection_handle = evt->data.evt_connection_opened.connection;

    +

    +      // check if it is the only allowed connection

    +      // if not yet bonded, then any connection is allowed until the first

    +      // bonding request (descriptors etc. can be read by anyone)

    +      if (evt->data.evt_connection_opened.bonding == esl_tag.bonding_handle)
    {

    +        // store AP address

    +        memcpy(&esl_tag.ap_address.addr, evt->data.evt_connection_opened.address.addr,
    sizeof(bd_addr));

    +

    +        sl_bt_esl_log(ESL_LOG_COMPONENT_CORE,

    +                      ESL_LOG_LEVEL_INFO,

    +                      "Connection opened");

    +

    +        // Do not close sync, if it was open before

    +        if (esl_tag.sync_handle != SL_BT_INVALID_SYNC_HANDLE) {

    +          sl_bt_esl_log(ESL_LOG_COMPONENT_CORE | ESL_LOG_FLAG_APPEND,

    +                        ESL_LOG_LEVEL_INFO,

    +                        " - keeping sync with AP");

    +        }

    +      } else {

    +        memset(&esl_tag.ap_address, 0, sizeof(bd_addr));

    +        sl_bt_esl_log(ESL_LOG_COMPONENT_CORE,

    +                      ESL_LOG_LEVEL_WARNING,

    +                      "Foreign connection detected!");

    +      }

    +

    +      // force-stop security watchdog if running

    +      (void)sl_sleeptimer_stop_timer(&esl_tag_persistent.watchdog_handle);

    +      break;

    +

    +    case sl_bt_evt_connection_closed_id:

    +      // reset connection handle - before re-enabling advertising!

    +      esl_tag.connection_handle     = SL_BT_INVALID_CONNECTION_HANDLE;

    +      // disable notification responses

    +      esl_tag.notifications_enabled = false;

    +

    +      // according to ESL standard, both Unsynchronized and Unassociated states

    +      // need to re-start advertising on (probably sudden) connection close.

    +      (void)esl_core_start_advertising();

    +      sl_bt_esl_log(ESL_LOG_COMPONENT_CORE,

    +                    ESL_LOG_LEVEL_INFO,

    +                    "Close reason: %x",

    +                    evt->data.evt_connection_closed.reason);

    +      break;

    +

    +    case sl_bt_evt_sync_closed_id:

    +      esl_sync_cleanup(evt->data.evt_sync_closed.reason);

    +      break;

    +

    +    default:

    +      break;

    +  }

    +}

    +

    +static void esl_state_configuring_handler(sl_bt_msg_t *evt)

    +{

    +  sl_status_t sc;

    +  (void)sc; // suppress the compiler warning if sl_bt_esl_assert disabled

    +

    +  switch (SL_BT_MSG_ID(evt->header)) {

    +    case sl_bt_evt_connection_parameters_id:

    +    // connection could be opened over PAwR, so this event needs to be handled

    +    // @suppress("No break at end of case")

    +    /* FALLTHRU */

    +    case sl_bt_evt_sm_bonding_failed_id:

    +      // can happen if the bonded AP unexpectedly requests new bonding (e.g.
    lost the bonding key)

    +      esl_state_connectable_handler(evt);

    +      break;

    +

    +    case sl_bt_evt_gatt_server_user_write_request_id: {

    +      sl_status_t result = SL_STATUS_INVALID_PARAMETER;

    +      const uint16_t offset = evt->data.evt_gatt_server_user_write_request.offset;

    +      const uint8_t  len = evt->data.evt_gatt_server_user_write_request.value.len;

    +      const uint16_t overall_size = offset + len;

    +      static uint8_t execute_write_flag = 0;

    +

    +      if (evt->data.evt_gatt_server_user_write_request.characteristic == gattdb_esl_control_point)
    {

    +        uint32_t cmd_len;

    +        cmd_len = evt->data.evt_gatt_server_attribute_value.value.data[0];

    +        cmd_len = esl_core_get_tlv_len(cmd_len) + 1; // opcode is one more byte!

    +        if (evt->data.evt_gatt_server_attribute_value.value.len == cmd_len) {

    +          uint8_t *data = evt->data.evt_gatt_server_attribute_value.value.data;

    +

    +          // process command sent to the ESL control point

    +          result = esl_core_parse_all_opcodes(data, cmd_len);

    +

    +          // send response only if required by the client

    +          if (evt->data.evt_gatt_server_user_write_request.att_opcode == sl_bt_gatt_write_request)
    {

    +            sl_bt_gatt_server_send_user_write_response(evt->data.evt_gatt_server_user_write_request.connection,

    +                                                       evt->data.evt_gatt_server_user_write_request.characteristic,

    +                                                       SL_STATUS_OK);

    +          } else {

    +            // in case of Write Without Response request, the result''s just
    logged

    +            sl_bt_esl_log(ESL_LOG_COMPONENT_CORE,

    +                          ESL_LOG_LEVEL_INFO,

    +                          "Write Without Response result: 0x%04lX",

    +                          result);

    +          }

    +

    +          if (esl_tag.notifications_enabled) {

    +            uint8_t response[ESL_CP_MAX_PAYLOAD_LENGTH];

    +            // send notification from response queue

    +            uint8_t len = esl_core_get_responses(sizeof(response), response);

    +

    +            if (len) {

    +              sl_bt_gatt_server_send_notification(evt->data.evt_gatt_server_user_write_request.connection,

    +                                                  evt->data.evt_gatt_server_user_write_request.characteristic,

    +                                                  len,

    +                                                  response);

    +            }

    +          } else {

    +            // responses were created, but we can''t just send -> delete all!

    +            esl_core_purge_responses();

    +          }

    +        }

    +      } else {

    +        result = SL_STATUS_OK;

    +

    +        switch (evt->data.evt_gatt_server_user_write_request.characteristic)
    {

    +          case gattdb_esl_address:

    +            if (evt->data.evt_gatt_server_user_write_request.value.len == sizeof(esl_address_t))
    {

    +              esl_address_t address = *(esl_address_t *)evt->data.evt_gatt_server_user_write_request.value.data;

    +              // do not allow the broadcast address to be set - neither by mistake!

    +              if (esl_core_get_id(address) != ESL_BROADCAST_ID) {

    +                // ignore RFU bit

    +                esl_tag.address.value = address & (ESL_GROUP_ID_MASK | ESL_ID_MASK);

    +                esl_tag.config_status |= ESL_CONFIG_FLAG_ESL_ADDRESS;

    +

    +                sl_bt_esl_log(ESL_LOG_COMPONENT_CORE,

    +                              ESL_LOG_LEVEL_INFO,

    +                              "ESL Address configured: 0x%04x",

    +                              esl_tag.address.value);

    +

    +                if (esl_tag.sync_handle != SL_BT_INVALID_SYNC_HANDLE) {

    +                  // change subevent according to new group if already in sync

    +                  (void)sl_bt_pawr_sync_set_sync_subevents(esl_tag.sync_handle,

    +                                                           sizeof(esl_tag.address.group_id),

    +                                                           &esl_tag.address.group_id);

    +                }

    +              } else {

    +                result = SL_STATUS_BT_ATT_VALUE_NOT_ALLOWED;

    +              }

    +            } else {

    +              result = SL_STATUS_BT_ATT_INVALID_ATT_LENGTH;

    +            }

    +            break;

    +

    +          case gattdb_esl_ap_sync_key:

    +            execute_write_flag = ESL_CONFIG_FLAG_ESL_AP_KEY;

    +            if ((evt->data.evt_gatt_server_user_write_request.att_opcode == sl_bt_gatt_prepare_write_request
    && overall_size <= SL_BT_EAD_KEY_MATERIAL_SIZE)

    +                || (evt->data.evt_gatt_server_user_write_request.att_opcode ==
    sl_bt_gatt_write_request && overall_size == SL_BT_EAD_KEY_MATERIAL_SIZE)) {

    +              memcpy((void *)&esl_tag.ap_key.key[offset],

    +                     (void *)evt->data.evt_gatt_server_user_write_request.value.data,

    +                     len);

    +

    +              sl_bt_esl_log(ESL_LOG_COMPONENT_CORE,

    +                            ESL_LOG_LEVEL_INFO,

    +                            "Write AP Sync Key Material");

    +

    +              if (overall_size == SL_BT_EAD_KEY_MATERIAL_SIZE) {

    +                // Pre-initialize the session key alone

    +                sl_bt_ead_session_init(&esl_tag.ap_key, NULL, NULL);

    +                esl_tag.config_status |= execute_write_flag;

    +                break;

    +              }

    +            } else {

    +              result = SL_STATUS_BT_ATT_INVALID_ATT_LENGTH;

    +              memset((void *)&esl_tag.ap_key, 0, SL_BT_EAD_KEY_MATERIAL_SIZE);

    +              esl_tag.config_status &= (uint8_t) ~execute_write_flag;

    +            }

    +            break;

    +

    +          case gattdb_esl_response_key:

    +            execute_write_flag = ESL_CONFIG_FLAG_ESL_RESPONSE_KEY;

    +            if ((evt->data.evt_gatt_server_user_write_request.att_opcode == sl_bt_gatt_prepare_write_request
    && overall_size <= SL_BT_EAD_KEY_MATERIAL_SIZE)

    +                || (evt->data.evt_gatt_server_user_write_request.att_opcode ==
    sl_bt_gatt_write_request && overall_size == SL_BT_EAD_KEY_MATERIAL_SIZE)) {

    +              memcpy((void *)&esl_tag.response_key.key[offset],

    +                     (void *)evt->data.evt_gatt_server_user_write_request.value.data,

    +                     len);

    +

    +              sl_bt_esl_log(ESL_LOG_COMPONENT_CORE,

    +                            ESL_LOG_LEVEL_INFO,

    +                            "Write AP Response Key Material");

    +

    +              if (overall_size == SL_BT_EAD_KEY_MATERIAL_SIZE) {

    +                esl_tag.config_status |= execute_write_flag;

    +                break;

    +              }

    +            } else {

    +              result = SL_STATUS_BT_ATT_INVALID_ATT_LENGTH;

    +              memset((void *)&esl_tag.response_key, 0, SL_BT_EAD_KEY_MATERIAL_SIZE);

    +              esl_tag.config_status &= (uint8_t) ~execute_write_flag;

    +            }

    +            break;

    +

    +          case gattdb_esl_absolute_time:

    +            if (evt->data.evt_gatt_server_user_write_request.value.len == sizeof(uint32_t))
    {

    +              CORE_ATOMIC_SECTION(

    +                esl_tag.time_offset  = *(uint32_t *)evt->data.evt_gatt_server_user_write_request.value.data;

    +                esl_tag.time_offset -= sl_sleeptimer_tick_to_ms(sl_sleeptimer_get_tick_count());

    +                )

    +              esl_tag.config_status |= ESL_CONFIG_FLAG_ESL_ABS_TIME;

    +              sl_bt_esl_log(ESL_LOG_COMPONENT_CORE,

    +                            ESL_LOG_LEVEL_INFO,

    +                            "ESL Absolute Time configured to: 0x%lx",

    +                            *(uint32_t *)evt->data.evt_gatt_server_user_write_request.value.data);

    +            } else {

    +              esl_tag.config_status &= (uint8_t) ~ESL_CONFIG_FLAG_ESL_ABS_TIME;

    +              result = SL_STATUS_BT_ATT_INVALID_ATT_LENGTH;

    +            }

    +            break;

    +

    +          default:

    +            if (evt->data.evt_gatt_server_user_write_request.att_opcode == sl_bt_gatt_execute_write_request)
    {

    +              // characteristic value will be 0 for sl_bt_gatt_execute_write_request
    and shall be ignored

    +              if (!execute_write_flag) {

    +                // flag shall be set before sl_bt_gatt_execute_write_request
    can be accepted!

    +                result = SL_STATUS_BT_ATT_WRITE_REQUEST_REJECTED;

    +                sl_bt_esl_log(ESL_LOG_COMPONENT_CORE,

    +                              ESL_LOG_LEVEL_WARNING,

    +                              "Invalid GATT Execute Write Request ignored");

    +              } else if ((esl_tag.config_status & execute_write_flag) == 0) {

    +                void *data = &esl_tag.ap_key;

    +                // error case: insufficient write length before the sl_bt_gatt_execute_write_request

    +                result = SL_STATUS_BT_ATT_INVALID_ATT_LENGTH;

    +

    +                if (execute_write_flag == ESL_CONFIG_FLAG_ESL_RESPONSE_KEY) {

    +                  // change data pointer if needed

    +                  data = &esl_tag.response_key;

    +                }

    +                // clear corresponding data

    +                memset(data, 0, SL_BT_EAD_KEY_MATERIAL_SIZE);

    +

    +                sl_bt_esl_log(ESL_LOG_COMPONENT_CORE,

    +                              ESL_LOG_LEVEL_ERROR,

    +                              "Key Material writing failed due length mismatch");

    +              } else {

    +                sl_bt_esl_log(ESL_LOG_COMPONENT_CORE,

    +                              ESL_LOG_LEVEL_INFO,

    +                              "Key Material written successfully");

    +              }

    +              // clear the flag after execution - either was it successful or
    not

    +              execute_write_flag = 0;

    +            } else {

    +              // let other components try process the requests unknown to ESL
    core

    +              result = SL_STATUS_BT_ATT_REQUEST_NOT_SUPPORTED;

    +            }

    +            break;

    +        }

    +

    +        if (result != SL_STATUS_BT_ATT_REQUEST_NOT_SUPPORTED) {

    +          if (evt->data.evt_gatt_server_user_write_request.att_opcode == sl_bt_gatt_write_request

    +              || evt->data.evt_gatt_server_user_write_request.att_opcode == sl_bt_gatt_execute_write_request)
    {

    +            sl_bt_gatt_server_send_user_write_response(evt->data.evt_gatt_server_user_write_request.connection,

    +                                                       evt->data.evt_gatt_server_user_write_request.characteristic,

    +                                                       result);

    +          } else if (evt->data.evt_gatt_server_user_write_request.att_opcode
    == sl_bt_gatt_prepare_write_request) {

    +            sl_bt_gatt_server_send_user_prepare_write_response(evt->data.evt_gatt_server_user_write_request.connection,

    +                                                               evt->data.evt_gatt_server_user_write_request.characteristic,

    +                                                               result,

    +                                                               evt->data.evt_gatt_server_user_write_request.offset,

    +                                                               evt->data.evt_gatt_server_user_write_request.value.len,

    +                                                               evt->data.evt_gatt_server_user_write_request.value.data);

    +          }

    +        }

    +      }

    +    } break;

    +

    +    case sl_bt_evt_gatt_server_characteristic_status_id:

    +      if (evt->data.evt_gatt_server_characteristic_status.characteristic == gattdb_esl_control_point

    +          && evt->data.evt_gatt_server_characteristic_status.status_flags ==
    sl_bt_gatt_server_client_config) {

    +        switch (evt->data.evt_gatt_server_characteristic_status.client_config_flags)
    {

    +          case sl_bt_gatt_server_notification:

    +          case sl_bt_gatt_server_notification_and_indication:

    +            esl_tag.notifications_enabled = true;

    +            sl_bt_esl_log(ESL_LOG_COMPONENT_CORE,

    +                          ESL_LOG_LEVEL_INFO,

    +                          "AP subscribed to ECP notifications");

    +            break;

    +

    +          case sl_bt_gatt_server_disable:

    +            sl_bt_esl_log(ESL_LOG_COMPONENT_CORE,

    +                          ESL_LOG_LEVEL_DEBUG,

    +                          "AP unsubscribed from ECP notifications");

    +            esl_tag.notifications_enabled = false;

    +            break;

    +        }

    +      }

    +      break;

    +

    +    case sl_bt_evt_periodic_sync_transfer_received_id:

    +      // error case, close the sync and connection immediately.

    +      (void)sl_bt_sync_close(evt->data.evt_periodic_sync_transfer_received.sync);

    +      // closing the connection will force the fall-back mechanism (sync by scan)

    +      (void)sl_bt_connection_close(evt->data.evt_periodic_sync_transfer_received.connection);

    +      sl_bt_esl_log(ESL_LOG_COMPONENT_CORE,

    +                    ESL_LOG_LEVEL_WARNING,

    +                    "Unsupported PAST sync detected, ignore.");

    +      break;

    +

    +    case sl_bt_evt_pawr_sync_transfer_received_id:

    +      // the connection will be closed regardless of status

    +      (void)sl_bt_connection_close(evt->data.evt_pawr_sync_transfer_received.connection);

    +

    +      if (evt->data.evt_pawr_sync_transfer_received.status == SL_STATUS_OK) {

    +        uint32_t interval;

    +        uint32_t sync_timeout;

    +

    +        // init the internal anti-drift helper

    +        esl_tag.pawr_timestamp = sl_sleeptimer_get_tick_count64();

    +        esl_tag.tick_error = 0;

    +        // as we''re going to use only integer math for speed, we need the

    +        // following tricks for keeping full accuracy

    +        interval = ESL_PAWR_INTEGER_INTERVAL

    +                   * evt->data.evt_pawr_sync_transfer_received.adv_interval;

    +        // get the base for the timeout value from the adv_interval that arrives
    in unit of 1.25 ms

    +        sync_timeout = (10 * evt->data.evt_pawr_sync_transfer_received.adv_interval)
    / 8;

    +        // accept the sync transfer only from the bonded AP according to ESL
    spec.

    +

    +        if (evt->data.evt_pawr_sync_transfer_received.bonding != esl_tag.bonding_handle)
    {

    +          // close connection if the transfer is not from the bonded AP

    +          (void)sl_bt_sync_close(evt->data.evt_pawr_sync_transfer_received.sync);

    +        } else {

    +          esl_core_set_basic_state_bit(ESL_BASIC_STATE_SYNCHRONIZED_BIT, ESL_SET);

    +          esl_tag.sync_handle = evt->data.evt_pawr_sync_transfer_received.sync;

    +

    +          sl_bt_esl_log(ESL_LOG_COMPONENT_CORE,

    +                        ESL_LOG_LEVEL_INFO,

    +                        "PAST done, %d ms PAwR sync service opened.",

    +                        sync_timeout);

    +          sl_bt_esl_log(ESL_LOG_COMPONENT_CORE,

    +                        ESL_LOG_LEVEL_DEBUG,

    +                        "Remote clock accuracy: %d ppm",

    +                        evt->data.evt_pawr_sync_transfer_received.clock_accuracy);

    +

    +          esl_core_update_sync_parameters(sync_timeout, ESL_SYNC_SKIP);

    +

    +          // due to the earlier multiplication trick, this will always give an

    +          // integer value equal to one hundred times the current interval!

    +          (void)sl_sleeptimer_ms32_to_tick(interval,

    +                                           &esl_tag.pawr_interval_ticks);

    +          // set listener subevent according to current ESL group

    +          (void)sl_bt_pawr_sync_set_sync_subevents(esl_tag.sync_handle,

    +                                                   sizeof(esl_tag.address.group_id),

    +                                                   &esl_tag.address.group_id);

    +        }

    +      } else {

    +        // clean up sync info

    +        esl_sync_cleanup(evt->data.evt_pawr_sync_transfer_received.status);

    +      }

    +      break;

    +

    +    case sl_bt_evt_connection_closed_id:

    +      // reset connection handle - before re-enabling advertising!

    +      esl_tag.connection_handle = SL_BT_INVALID_CONNECTION_HANDLE;

    +      // disable notification responses

    +      esl_tag.notifications_enabled = false;

    +

    +      if (!is_esl_configured_for(ESL_CONFIG_FLAGS_MANDATORY_MASK)) {

    +        // esl_service_d095r08 Section 2.7.3.2.1

    +        esl_core_unassociate();

    +      } else {

    +        // set synchronized state if sync exists and Update Complete received

    +        if (esl_tag.sync_handle != SL_BT_INVALID_SYNC_HANDLE

    +            && is_esl_configured_for(ESL_CONFIG_FLAG_UPDATE_COMPLETE)

    +            && evt->data.evt_connection_closed.reason == SL_STATUS_BT_CTRL_CONNECTION_TERMINATED_BY_LOCAL_HOST)
    {

    +          esl_tag.status = esl_state_synchronized;

    +          sl_bt_esl_log(ESL_LOG_COMPONENT_CORE,

    +                        ESL_LOG_LEVEL_INFO,

    +                        "State transition to %s",

    +                        esl_states_string[esl_tag.status]);

    +          // start watchdog again according to ESLP security requirement (d095r16,
    8.3)

    +          (void)sl_sleeptimer_restart_periodic_timer_ms(&esl_tag_persistent.watchdog_handle,

    +                                                        ESL_CORE_SECURITY_TIMEOUT_MS,

    +                                                        &esl_security_timeout,

    +                                                        NULL,

    +                                                        ESL_CORE_SECURITY_TIMER_PRIORITY,

    +                                                        SL_SLEEPTIMER_NO_HIGH_PRECISION_HF_CLOCKS_REQUIRED_FLAG);

    +        } else {

    +          // out of sync or link loss before Update Complete: start advertising

    +          (void)esl_core_start_advertising(); // will set appropriate state

    +        }

    +      }

    +      sl_bt_esl_log(ESL_LOG_COMPONENT_CORE,

    +                    ESL_LOG_LEVEL_INFO,

    +                    "Close reason: %x",

    +                    evt->data.evt_connection_closed.reason);

    +      break;

    +

    +    case sl_bt_evt_sync_closed_id:

    +      // In case of connection opened over PAwR the sync may be closed already

    +      if (esl_tag.sync_handle != SL_BT_INVALID_SYNC_HANDLE) {

    +        sl_bt_esl_log(ESL_LOG_COMPONENT_CORE,

    +                      ESL_LOG_LEVEL_INFO,

    +                      "Sync closed due: %x",

    +                      evt->data.evt_sync_closed.reason);

    +        esl_sync_cleanup(evt->data.evt_sync_closed.reason);

    +      }

    +      break;

    +

    +    default:

    +      break;

    +  }

    +}

    +

    +static void esl_state_synchronized_handler(sl_bt_msg_t *evt)

    +{

    +  switch (SL_BT_MSG_ID(evt->header)) {

    +    case sl_bt_evt_connection_opened_id:

    +      // connection can be initiated over PAwR, so this event has to be handled

    +      esl_state_connectable_handler(evt);

    +      break;

    +

    +    case sl_bt_evt_pawr_sync_subevent_report_id:

    +      // skip any incomplete data

    +      if (evt->data.evt_pawr_sync_subevent_report.data_status == 0) {

    +        uint64_t tick_now = sl_sleeptimer_get_tick_count64();

    +        uint64_t ticks_elapsed, ticks_rounded_up, ticks_expected;

    +        uint32_t interval_count;

    +        uint8_t* msg = evt->data.evt_pawr_sync_subevent_report.data.data;

    +        uint8_t len = evt->data.evt_pawr_sync_subevent_report.data.len;

    +        const int32_t error_threshold = sl_sleeptimer_get_timer_frequency();

    +

    +        // try decrypting the message

    +        msg = esl_core_decrypt_message(msg, &len);

    +

    +        // also skip processing any improperly encrypted data:

    +        // (skip msg == NULL and improper length and/or type)

    +        if (msg && msg[0] == --len && msg[1] == ESL_AD_TYPE) {

    +          // backup vales for response

    +          esl_tag_persistent.request_event = evt->data.evt_pawr_sync_subevent_report.event_counter;

    +          esl_tag_persistent.request_subevent = evt->data.evt_pawr_sync_subevent_report.subevent;

    +

    +          // While in the Updating state, the ESL shall ignore any data present

    +          // on the LE PAwR logical transport

    +          if (esl_tag.status == esl_state_synchronized) {

    +            esl_group_id_t group_id = esl_core_get_group_id(esl_tag.address.value);

    +

    +            // re-start watchdog according to ESLP security requirement

    +            (void)sl_sleeptimer_restart_periodic_timer_ms(&esl_tag_persistent.watchdog_handle,

    +                                                          ESL_CORE_SECURITY_TIMEOUT_MS,

    +                                                          &esl_security_timeout,

    +                                                          NULL,

    +                                                          ESL_CORE_SECURITY_TIMER_PRIORITY,

    +                                                          SL_SLEEPTIMER_NO_HIGH_PRECISION_HF_CLOCKS_REQUIRED_FLAG);

    +

    +            // check if command(s) addressed to this group

    +            if (*(esl_group_id_t *)&msg[ESL_PAYLOAD_OVERHEAD] == group_id) {

    +              // declare local static for proper battery voltage measure interval

    +              static uint32_t last_measured = (UINT32_MAX - ESL_TAG_BATTERY_MEASUREMENT_INTERVAL_MS);

    +              uint32_t now = sl_sleeptimer_tick_to_ms(sl_sleeptimer_get_tick_count());

    +

    +              // only measure if the requested interval has passed (saves power)

    +              if ((uint32_t)(now - last_measured) >= ESL_TAG_BATTERY_MEASUREMENT_INTERVAL_MS)
    {

    +                // save time stamp

    +                last_measured = now;

    +                // do the measurement once

    +                esl_sensor_battery_read();

    +              }

    +

    +              (void)esl_core_parse_all_opcodes(&msg[ESL_PAYLOAD_OVERHEAD + 1],

    +                                               (uint8_t)(len - ESL_PAYLOAD_OVERHEAD));

    +            }

    +          } else {

    +            sl_bt_esl_log(ESL_LOG_COMPONENT_CORE,

    +                          ESL_LOG_LEVEL_INFO,

    +                          "Ignore command over PAwR while connected: ");

    +            sl_bt_esl_log_hexdump(ESL_LOG_COMPONENT_CORE | ESL_LOG_FLAG_APPEND,

    +                                  ESL_LOG_LEVEL_INFO,

    +                                  &msg[ESL_PAYLOAD_OVERHEAD + 1],

    +                                  (uint8_t)(len - ESL_PAYLOAD_OVERHEAD));

    +          }

    +        }

    +        ticks_elapsed = (uint64_t)(tick_now - esl_tag.pawr_timestamp);

    +        // ''tick_now'' may have overflowed - in that edge case the elapsed time

    +        // also overflows and become suddenly "negative", so handle this properly

    +        if ((int64_t)ticks_elapsed < 0) {

    +          ticks_elapsed = -ticks_elapsed; // turn back to positive

    +        }

    +

    +        // as we used multiplication for keeping full integer accuracy, we need

    +        // to do the same here as well

    +        ticks_elapsed      *= ESL_DRIFT_INTEGER_MULTIPLIER;

    +        ticks_rounded_up    = ticks_elapsed + (esl_tag.pawr_interval_ticks >>
    1);

    +        interval_count      = ticks_rounded_up / esl_tag.pawr_interval_ticks;

    +        ticks_expected      = interval_count * esl_tag.pawr_interval_ticks;

    +

    +        sl_bt_esl_log(ESL_LOG_COMPONENT_CORE,

    +                      ESL_LOG_LEVEL_DEBUG,

    +                      "Interval%c %u, measured: %lu, expected: %lu [Ticks]",

    +                      (interval_count == 1 ? ''\0'' : ''s''),

    +                      (uint8_t)interval_count,

    +                      ((uint32_t)ticks_elapsed / ESL_DRIFT_INTEGER_MULTIPLIER),

    +                      ((uint32_t)ticks_expected) / ESL_DRIFT_INTEGER_MULTIPLIER);

    +

    +        if (interval_count != 0) {

    +          // as we still have ''only'' hundred times of the real difference,

    +          // we have multiply by ten again, to reach the full sleeptimer

    +          // resolution and thus not to lose the threshold precision.

    +          esl_tag.tick_error -= (int32_t)(ticks_expected - ticks_elapsed)

    +                                * (int32_t)(ESL_DRIFT_THRESHOLD_DIVISOR

    +                                            / ESL_DRIFT_INTEGER_MULTIPLIER);

    +          sl_bt_esl_log(ESL_LOG_COMPONENT_CORE,

    +                        ESL_LOG_LEVEL_DEBUG,

    +                        "Error: %ld mTicks (sum: %d.%03d T) @ nominal %ldHz",

    +                        (int32_t)(ticks_elapsed - ticks_expected),

    +                        (int16_t)(esl_tag.tick_error / (int32_t)ESL_DRIFT_THRESHOLD_DIVISOR),

    +                        (uint16_t)abs((esl_tag.tick_error % (int32_t)ESL_DRIFT_THRESHOLD_DIVISOR)),

    +                        error_threshold);

    +        }

    +

    +        // save current tick count

    +        esl_tag.pawr_timestamp = tick_now;

    +

    +        if (esl_tag.tick_error >= error_threshold) {

    +          esl_tag.tick_error -= error_threshold;

    +          esl_tag.time_offset--;

    +          sl_bt_esl_log(ESL_LOG_COMPONENT_CORE,

    +                        ESL_LOG_LEVEL_INFO,

    +                        "LFXO is too fast, Absolute Time adjusted down!");

    +        } else if (esl_tag.tick_error <= -error_threshold) {

    +          esl_tag.tick_error += error_threshold;

    +          esl_tag.time_offset++;

    +          sl_bt_esl_log(ESL_LOG_COMPONENT_CORE,

    +                        ESL_LOG_LEVEL_INFO,

    +                        "LFXO is too slow, Absolute Time adjusted up!");

    +        } else {

    +          // nothing more to do until the time drifts

    +          break;

    +        }

    +

    +        if (sl_sleeptimer_tick64_to_ms(tick_now, &ticks_elapsed) == SL_STATUS_OK)
    {

    +          // do the time offset correction if it''s possible and necessary

    +          interval_count = (uint32_t)ticks_elapsed + esl_tag.time_offset;

    +          esl_reschedule_delayed_commands(interval_count);

    +        }

    +      }

    +      break;

    +

    +    case sl_bt_evt_sync_closed_id:

    +      esl_sync_cleanup(evt->data.evt_sync_closed.reason);

    +      break;

    +

    +    default:

    +      break;

    +  }

    +}

    +

    +void esl_core_init(void)

    +{

    +  esl_core_init_hook();

    +  esl_core_respones_init();

    +  esl_led_init();

    +  esl_image_init();

    +  esl_sensor_init();

    +  esl_display_init();

    +}

    +

    +SL_WEAK void esl_core_boot_event(void)

    +{

    +}

    +

    +SL_WEAK void esl_core_unassociate_callback(void)

    +{

    +}

    +

    +SL_WEAK void esl_core_update_complete_callback(void)

    +{

    +}

    +

    +SL_WEAK void esl_core_service_reset_event(void)

    +{

    +}

    +

    +SL_WEAK void esl_core_init_hook(void)

    +{

    +}

    +

    +SL_WEAK void esl_core_shutdown_hook(void)

    +{

    +}

    +

    +void esl_core_bt_on_event(sl_bt_msg_t *evt)

    +{

    +  // Internal state machine skeleton code - actual implementation of the states

    +  // are out of scope of this event handler.

    +  switch (esl_tag.status) {

    +    case esl_state_boot:

    +      esl_state_boot_handler(evt);

    +      break;

    +

    +    case esl_state_unassociated:

    +      // ESL Unassociated state is almost the same as the unsynchronized state,

    +      // thus both are calling the same event handler, while the small

    +      // differences will be handled internally.

    +      esl_state_connectable_handler(evt);

    +      break;

    +

    +    case esl_state_configuring:

    +      esl_state_configuring_handler(evt);

    +      break;

    +

    +    case esl_state_synchronized:

    +      esl_state_synchronized_handler(evt);

    +      if (esl_tag.connection_handle != SL_BT_INVALID_CONNECTION_HANDLE) {

    +        esl_state_configuring_handler(evt);

    +      }

    +      break;

    +

    +    case esl_state_unsynchronized:

    +      // See the notes in esl_state_unassociated case.

    +      esl_state_connectable_handler(evt);

    +      break;

    +

    +    case esl_state_updating:

    +      // ESL Updating state is almost the same as the configuring state, however

    +      // they are handled slightly different, internally.

    +      esl_state_configuring_handler(evt);

    +      // moreover, it can handle sync events as well (if needed).

    +      if (esl_tag.sync_handle != SL_BT_INVALID_SYNC_HANDLE) {

    +        esl_state_synchronized_handler(evt);

    +      }

    +      break;

    +

    +    default:

    +      // Invalid ESL state, recover by reset

    +      sl_bt_system_reset(sl_bt_system_boot_mode_normal);

    +      break;

    +  }

    +}

    +

    +esl_state_t esl_core_get_status(void)

    +{

    +  return esl_tag.status;

    +}

    +

    +sl_status_t esl_core_start_advertising(void)

    +{

    +  sl_status_t result = SL_STATUS_FAIL;

    +  esl_state_t new_esl_status = esl_tag.bonding_handle != SL_BT_INVALID_BONDING_HANDLE

    +                               ? esl_state_unsynchronized

    +                               : esl_state_unassociated;

    +

    +  if (esl_tag.connection_handle == SL_BT_INVALID_CONNECTION_HANDLE) {

    +    // set random advertising interval.

    +    const uint32_t max_interval = ESL_TAG_ADVERTISING_INTERVAL_MAX;

    +    uint32_t       min_interval = ESL_TAG_ADVERTISING_INTERVAL_MIN;

    +

    +    // force close sync if any (may happen if AP disconnects suddenly)

    +    if (esl_tag.sync_handle != SL_BT_INVALID_SYNC_HANDLE) {

    +      (void)sl_bt_sync_close(esl_tag.sync_handle);

    +    }

    +

    +    // this number has nothing to do with security, so it''s OK to use stdlib''s
    rand()

    +    min_interval  = (uint32_t)rand() % (max_interval - min_interval + 1);

    +    min_interval += ESL_TAG_ADVERTISING_INTERVAL_MIN;

    +

    +    result = sl_bt_advertiser_set_timing(esl_tag_persistent.advertising_set_handle,

    +                                         16 * min_interval / 10, // configurator
    asks users for [ms],

    +                                         16 * max_interval / 10, // but our API
    expects in 0.625ms units

    +                                         0, // adv. duration

    +                                         0); // max. num. adv. events

    +

    +    sl_bt_esl_log(ESL_LOG_COMPONENT_CORE,

    +                  ESL_LOG_LEVEL_INFO,

    +                  "Random advertising interval between %u and %u ms selected",

    +                  min_interval,

    +                  max_interval);

    +

    +    if (result == SL_STATUS_OK) {

    +      // Start advertising and enable connections.

    +      result = sl_bt_legacy_advertiser_start(esl_tag_persistent.advertising_set_handle,

    +                                             sl_bt_legacy_advertiser_connectable);

    +      sl_bt_esl_log(ESL_LOG_COMPONENT_CORE,

    +                    ESL_LOG_LEVEL_INFO,

    +                    "State transition from %s to %s",

    +                    esl_states_string[esl_tag.status],

    +                    esl_states_string[new_esl_status]);

    +      // change internal status

    +      esl_tag.status = new_esl_status;

    +    }

    +    // start / restart watchdog timer whenever ESL starts advertising

    +    (void)sl_sleeptimer_restart_periodic_timer_ms(&esl_tag_persistent.watchdog_handle,

    +                                                  ESL_CORE_SECURITY_TIMEOUT_MS,

    +                                                  &esl_security_timeout,

    +                                                  NULL,

    +                                                  ESL_CORE_SECURITY_TIMER_PRIORITY,

    +                                                  SL_SLEEPTIMER_NO_HIGH_PRECISION_HF_CLOCKS_REQUIRED_FLAG);

    +  }

    +

    +  return result;

    +}

    +

    +bool esl_core_has_notifications()

    +{

    +  return esl_tag.notifications_enabled;

    +}

    +

    +esl_basic_state_t esl_core_get_basic_state()

    +{

    +  return esl_tag.basic_state;

    +}

    +

    +uint8_t esl_core_get_basic_state_bit(uint8_t bit)

    +{

    +  uint8_t result = ESL_FALSE;

    +

    +  if (!!(esl_tag.basic_state & (esl_basic_state_t) (1u << bit))) {

    +    result = ESL_TRUE;

    +  }

    +

    +  return result;

    +}

    +

    +esl_basic_state_t esl_core_set_basic_state_bit(uint8_t bit, uint8_t value)

    +{

    +  // Invalid basic state request.

    +  sl_bt_esl_assert(ESL_SET == value || ESL_CLEAR == value);

    +

    +  CORE_ATOMIC_SECTION(

    +    esl_tag.basic_state &= (esl_basic_state_t) ~(1u << bit);

    +    esl_tag.basic_state |= (esl_basic_state_t) (value << bit);

    +    )

    +

    +  return esl_tag.basic_state;

    +}

    +

    +sl_status_t esl_core_read_ap_key(sl_bt_ead_key_material_p ap_key)

    +{

    +  sl_status_t result = SL_STATUS_NOT_READY;

    +

    +  if (!!(esl_tag.config_status & ESL_CONFIG_FLAG_ESL_AP_KEY)) {

    +    memcpy((void *)ap_key, (void *)&esl_tag.ap_key,

    +           SL_BT_EAD_KEY_MATERIAL_SIZE);

    +    result = SL_STATUS_OK;

    +  }

    +

    +  return result;

    +}

    +

    +sl_status_t esl_core_read_response_key(sl_bt_ead_key_material_p response_key)

    +{

    +  sl_status_t result = SL_STATUS_NOT_READY;

    +

    +  if (!!(esl_tag.config_status & ESL_CONFIG_FLAG_ESL_RESPONSE_KEY)) {

    +    memcpy((void *)response_key, (void *)&esl_tag.response_key,

    +           SL_BT_EAD_KEY_MATERIAL_SIZE);

    +    result = SL_STATUS_OK;

    +  }

    +

    +  return result;

    +}

    +

    +sl_status_t esl_core_read_esl_address(esl_address_t *address)

    +{

    +  sl_status_t result = SL_STATUS_NOT_READY;

    +

    +  if (!!(esl_tag.config_status & ESL_CONFIG_FLAG_ESL_ADDRESS)) {

    +    *address = esl_tag.address.value;

    +    result = SL_STATUS_OK;

    +  }

    +  return result;

    +}

    +

    +sl_status_t esl_core_read_absolute_time(uint32_t *time)

    +{

    +  sl_status_t result = SL_STATUS_NOT_READY;

    +

    +  if (!!(esl_tag.config_status & ESL_CONFIG_FLAG_ESL_ABS_TIME)) {

    +    uint64_t current_tick = sl_sleeptimer_get_tick_count64();

    +    uint64_t ms64         = 0;

    +

    +    result = sl_sleeptimer_tick64_to_ms(current_tick, &ms64);

    +

    +    if (result == SL_STATUS_OK) {

    +      // overflow is allowed, arithmetics will do the trick, anyway:

    +      *time = (uint32_t)ms64 + esl_tag.time_offset;

    +    }

    +  }

    +

    +  return result;

    +}

    +

    +sl_status_t esl_core_update_sync_parameters(uint32_t timeout, uint16_t skip)

    +{

    +  sl_status_t result = SL_STATUS_INVALID_STATE; // default response if unsynced

    +

    +  if (!!timeout) {

    +    // calculate an appropriate sync timeout parameter value - but the latter

    +    // is expected in units of 10ms.

    +    timeout = ((ESL_TAG_MAX_SYNC_LOST_COUNT * timeout) + ESL_SYNC_MIN_TIMEOUT)
    / 10;

    +

    +    // finally, keep sync_timeout within its limits according to documentation

    +    if (timeout < ESL_SYNC_MIN_TIMEOUT) {

    +      timeout = ESL_SYNC_MIN_TIMEOUT;

    +    } else if (timeout > ESL_SYNC_MAX_TIMEOUT) {

    +      timeout = ESL_SYNC_MAX_TIMEOUT;

    +    }

    +    // store new timeout value if any

    +    esl_tag.sync_timeout = timeout;

    +  }

    +

    +  // adjust actual timeout value to the current skip parameter

    +  timeout = esl_tag.sync_timeout * (skip + 1);

    +  timeout = timeout > ESL_SYNC_MAX_TIMEOUT ? ESL_SYNC_MAX_TIMEOUT : timeout;

    +

    +  if (esl_tag.sync_handle != SL_BT_INVALID_SYNC_HANDLE) {

    +    // set an appropriate timeout for possible sync lost

    +    result = sl_bt_sync_update_sync_parameters(esl_tag.sync_handle,

    +                                               skip,

    +                                               timeout);

    +

    +    sl_bt_esl_log(ESL_LOG_COMPONENT_CORE,

    +                  ESL_LOG_LEVEL_INFO,

    +                  "Sync loss timeout was set to: %d ms, skip: %d.",

    +                  timeout * 10, skip);

    +  }

    +

    +  return result;

    +}

    +

    +/**************************************************************************//**

    + * Request ESL to return the synchronized state once synchronized

    + * @return sl_status_t

    + *****************************************************************************/

    +sl_status_t esl_core_update_complete(void)

    +{

    +  sl_status_t result = SL_STATUS_INVALID_STATE;

    +  if (esl_tag.status == esl_state_updating

    +      || esl_tag.status == esl_state_configuring) {

    +    // Set update complete flag

    +    esl_tag.config_status |= ESL_CONFIG_FLAG_UPDATE_COMPLETE;

    +    esl_core_update_complete_callback();

    +    if (esl_tag.sync_handle != SL_BT_INVALID_SYNC_HANDLE) {

    +      // If ESL receives the Update Complete command and it is synchronized,

    +      // it shall immediately terminate the ACL connection and transition

    +      // to the Synchronized state.

    +      sl_status_t result = app_scheduler_add(&esl_core_async_disconnect, 0, 0,
    NULL);

    +      // However, doing it literally "immediately" would cause possible loss
    of the

    +      // write response sent by the sl_bt_gatt_server_send_user_write_response()

    +      // following the opcode processing in the ESL, therefore we''re going to

    +      // try defer close by one step cycle to avoid such unwanted side-effect.

    +      if (result != SL_STATUS_OK) {

    +        // Fall-back: disconnect immediately if defer attempt fails! Even though

    +        // the Core spec. allows remote device to flush all ACL packets when
    it

    +        // receives the disconnection command, we tried to avoid this at least.

    +        (void)sl_bt_connection_close(esl_tag.connection_handle);

    +      }

    +    } else {

    +      // If ESL receives the Update Complete command and it is not

    +      // synchronized, it shall wait for synchronization to be established.

    +    }

    +    result = SL_STATUS_OK;

    +  }

    +  return result;

    +}

    +

    +void esl_core_invalidate_config(void)

    +{

    +  esl_tag.config_status = 0;

    +}'
  - '--- a/app/bluetooth/common/esl_tag_core/src/esl_tag_crypto.c

    +++ b/app/bluetooth/common/esl_tag_core/src/esl_tag_crypto.c

    @@ -0,0 +1,124 @@

    +/***************************************************************************//**

    + * @file

    + * @brief ESL Tag basic cryptography implementation.

    + *******************************************************************************

    + * # License

    + * <b>Copyright 2021 Silicon Laboratories Inc. www.silabs.com</b>

    + *******************************************************************************

    + *

    + * SPDX-License-Identifier: Zlib

    + *

    + * The licensor of this software is Silicon Laboratories Inc.

    + *

    + * This software is provided ''as-is'', without any express or implied

    + * warranty. In no event will the authors be held liable for any damages

    + * arising from the use of this software.

    + *

    + * Permission is granted to anyone to use this software for any purpose,

    + * including commercial applications, and to alter it and redistribute it

    + * freely, subject to the following restrictions:

    + *

    + * 1. The origin of this software must not be misrepresented; you must not

    + *    claim that you wrote the original software. If you use this software

    + *    in a product, an acknowledgment in the product documentation would be

    + *    appreciated but is not required.

    + * 2. Altered source versions must be plainly marked as such, and must not be

    + *    misrepresented as being the original software.

    + * 3. This notice may not be removed or altered from any source distribution.

    + *

    + ******************************************************************************/

    +#include <string.h>

    +#include "em_common.h"

    +#include "esl_tag_log.h"

    +#include "esl_tag_core.h"

    +#include "esl_tag_crypto.h"

    +#include "sl_bt_ead_core.h"

    +#include "psa/crypto.h"

    +

    +#define ENCRYPTION_ENABLED    1

    +

    +#if ENCRYPTION_ENABLED

    +

    +static uint8_t cipher_message_buffer[ESL_PAYLOAD_MAX_LENGTH

    +                                     + SL_BT_EAD_PACKET_OVERHEAD

    +                                     + ESL_PAYLOAD_OVERHEAD];

    +

    +// ESL Tag dummy encrypt function

    +void* esl_core_encrypt_message(void *msg, uint8_t *len)

    +{

    +  void* ret_val = NULL;

    +  sl_status_t status;

    +  struct sl_bt_ead_key_material_s key_material;

    +  struct sl_bt_ead_nonce_s nonce;

    +  sl_bt_ead_mic_t mic;

    +  struct sl_bt_ead_ad_structure_s ad_info = {

    +    *len,

    +    SL_BT_ENCRYPTED_DATA_AD_TYPE,

    +    &nonce.randomizer,

    +    msg,

    +    &mic

    +  };

    +

    +  sl_bt_esl_assert(len != NULL);

    +  sl_bt_esl_assert(msg != NULL);

    +

    +  status = esl_core_read_response_key(&key_material);

    +

    +  if (status == SL_STATUS_OK) {

    +    status = sl_bt_ead_session_init(&key_material, NULL, &nonce);

    +  }

    +

    +  if (status == SL_STATUS_OK) {

    +    status = sl_bt_ead_encrypt(&key_material, &nonce, *len, msg, mic);

    +  }

    +

    +  if (status == SL_STATUS_OK) {

    +    *len = sizeof(cipher_message_buffer);

    +    status = sl_bt_ead_pack_ad_data(&ad_info, len, cipher_message_buffer);

    +  }

    +

    +  if (status == SL_STATUS_OK) {

    +    ret_val = cipher_message_buffer;

    +  }

    +

    +  return ret_val;

    +}

    +

    +// ESL Tag dummy decrypt function

    +void* esl_core_decrypt_message(void *msg, uint8_t *len)

    +{

    +  void* ret_val = NULL;

    +

    +  if (*len > SL_BT_EAD_PACKET_OVERHEAD) {

    +    uint8_t *data = (uint8_t *)msg;

    +    struct sl_bt_ead_key_material_s key_material;

    +    sl_status_t status = esl_core_read_ap_key(&key_material);

    +

    +    if (status == SL_STATUS_OK) {

    +      status = sl_bt_ead_unpack_decrypt(&key_material, &data, len);

    +    }

    +

    +    if (status == SL_STATUS_OK) {

    +      ret_val = (void *)data;

    +    }

    +  }

    +

    +  return ret_val;

    +}

    +

    +#else // ENCRYPTION_ENABLED

    +SL_WEAK void* esl_core_encrypt_message(void *msg, uint8_t* len)

    +{

    +  (void)len;

    +

    +  return msg;

    +}

    +

    +SL_WEAK void* esl_core_decrypt_message(void *msg, uint8_t* len)

    +{

    +  (void)len;

    +

    +  return msg;

    +}

    +

    +#endif // ENCRYPTION_ENABLED'
  - '--- a/app/bluetooth/common/esl_tag_core/src/esl_tag_display_core.c

    +++ b/app/bluetooth/common/esl_tag_core/src/esl_tag_display_core.c

    @@ -0,0 +1,60 @@

    +/***************************************************************************//**

    + * @file

    + * @brief ESL Tag core WEAK implementations of abstract display functionalities.

    + *******************************************************************************

    + * # License

    + * <b>Copyright 2021 Silicon Laboratories Inc. www.silabs.com</b>

    + *******************************************************************************

    + *

    + * SPDX-License-Identifier: Zlib

    + *

    + * The licensor of this software is Silicon Laboratories Inc.

    + *

    + * This software is provided ''as-is'', without any express or implied

    + * warranty. In no event will the authors be held liable for any damages

    + * arising from the use of this software.

    + *

    + * Permission is granted to anyone to use this software for any purpose,

    + * including commercial applications, and to alter it and redistribute it

    + * freely, subject to the following restrictions:

    + *

    + * 1. The origin of this software must not be misrepresented; you must not

    + *    claim that you wrote the original software. If you use this software

    + *    in a product, an acknowledgment in the product documentation would be

    + *    appreciated but is not required.

    + * 2. Altered source versions must be plainly marked as such, and must not be

    + *    misrepresented as being the original software.

    + * 3. This notice may not be removed or altered from any source distribution.

    + *

    + ******************************************************************************/

    +#include "em_common.h"

    +#include "esl_tag_core.h"

    +#include "esl_tag_display_core.h"

    +

    +SL_WEAK void esl_display_init(void)

    +{

    +}

    +

    +SL_WEAK sl_status_t esl_display_refresh(uint8_t display_index,

    +                                        uint8_t *image_index)

    +{

    +  (void)display_index;

    +  (void)image_index;

    +

    +  return SL_STATUS_NOT_AVAILABLE;

    +}

    +

    +SL_WEAK sl_status_t esl_display_update(uint8_t display_index,

    +                                       uint8_t image_index)

    +{

    +  (void)display_index;

    +  (void)image_index;

    +

    +  esl_core_set_last_error(ESL_ERROR_INVALID_PARAMETER);

    +  return SL_STATUS_NOT_AVAILABLE;

    +}

    +

    +SL_WEAK uint8_t esl_display_get_count()

    +{

    +  return 0;

    +}'
  - '--- a/app/bluetooth/common/esl_tag_core/src/esl_tag_errors.c

    +++ b/app/bluetooth/common/esl_tag_core/src/esl_tag_errors.c

    @@ -0,0 +1,58 @@

    +/***************************************************************************//**

    + * @file

    + * @brief ESL Tag error report related functions.

    + *******************************************************************************

    + * # License

    + * <b>Copyright 2021 Silicon Laboratories Inc. www.silabs.com</b>

    + *******************************************************************************

    + *

    + * SPDX-License-Identifier: Zlib

    + *

    + * The licensor of this software is Silicon Laboratories Inc.

    + *

    + * This software is provided ''as-is'', without any express or implied

    + * warranty. In no event will the authors be held liable for any damages

    + * arising from the use of this software.

    + *

    + * Permission is granted to anyone to use this software for any purpose,

    + * including commercial applications, and to alter it and redistribute it

    + * freely, subject to the following restrictions:

    + *

    + * 1. The origin of this software must not be misrepresented; you must not

    + *    claim that you wrote the original software. If you use this software

    + *    in a product, an acknowledgment in the product documentation would be

    + *    appreciated but is not required.

    + * 2. Altered source versions must be plainly marked as such, and must not be

    + *    misrepresented as being the original software.

    + * 3. This notice may not be removed or altered from any source distribution.

    + *

    + ******************************************************************************/

    +#include "esl_tag_log.h"

    +#include "esl_tag_core.h"

    +#include "esl_tag_errors.h"

    +

    +/// ESL Tag last error code internal store location

    +static esl_error_t last_error = ESL_ERROR_VENDOR_NOERROR;

    +

    +esl_error_t esl_core_get_last_error(void)

    +{

    +  esl_error_t error = last_error;

    +  last_error = ESL_ERROR_VENDOR_NOERROR;

    +

    +  return error;

    +}

    +

    +void esl_core_set_last_error(esl_error_t error_code)

    +{

    +  // do not override any error not yet processed

    +  if (error_code == ESL_ERROR_VENDOR_NOERROR

    +      || last_error == ESL_ERROR_VENDOR_NOERROR) {

    +    last_error = error_code;

    +  } else {

    +    sl_bt_esl_log(ESL_LOG_COMPONENT_CORE,

    +                  ESL_LOG_LEVEL_WARNING,

    +                  "Last error already set: 0x%02x, skipping 0x%02x",

    +                  last_error,

    +                  error_code);

    +  }

    +}'
  - '--- a/app/bluetooth/common/esl_tag_core/src/esl_tag_image_core.c

    +++ b/app/bluetooth/common/esl_tag_core/src/esl_tag_image_core.c

    @@ -0,0 +1,63 @@

    +/***************************************************************************//**

    + * @file

    + * @brief ESL Tag core WEAK implementations of abstract image functionalities.

    + *******************************************************************************

    + * # License

    + * <b>Copyright 2021 Silicon Laboratories Inc. www.silabs.com</b>

    + *******************************************************************************

    + *

    + * SPDX-License-Identifier: Zlib

    + *

    + * The licensor of this software is Silicon Laboratories Inc.

    + *

    + * This software is provided ''as-is'', without any express or implied

    + * warranty. In no event will the authors be held liable for any damages

    + * arising from the use of this software.

    + *

    + * Permission is granted to anyone to use this software for any purpose,

    + * including commercial applications, and to alter it and redistribute it

    + * freely, subject to the following restrictions:

    + *

    + * 1. The origin of this software must not be misrepresented; you must not

    + *    claim that you wrote the original software. If you use this software

    + *    in a product, an acknowledgment in the product documentation would be

    + *    appreciated but is not required.

    + * 2. Altered source versions must be plainly marked as such, and must not be

    + *    misrepresented as being the original software.

    + * 3. This notice may not be removed or altered from any source distribution.

    + *

    + ******************************************************************************/

    +#include <stddef.h>

    +#include "em_common.h"

    +#include "esl_tag_core.h"

    +#include "esl_tag_image_core.h"

    +

    +SL_WEAK void esl_image_init(void)

    +{

    +}

    +

    +SL_WEAK void esl_image_characteristic_update(void)

    +{

    +}

    +

    +SL_WEAK sl_status_t esl_image_get_data(uint8_t image_index, uint16_t* offset,

    +                                       uint16_t buf_size, uint8_t *target_buf)

    +{

    +  (void)image_index;

    +  (void)buf_size;

    +  (void)offset;

    +  (void)target_buf;

    +

    +  esl_core_set_last_error(ESL_ERROR_IMAGE_NOT_AVAILABLE);

    +

    +  return SL_STATUS_NOT_AVAILABLE;

    +}

    +

    +SL_WEAK uint8_t esl_image_get_count(void)

    +{

    +  return 0;

    +}

    +

    +SL_WEAK void esl_image_reset_storage(void)

    +{

    +}'
  - '--- a/app/bluetooth/common/esl_tag_core/src/esl_tag_led_core.c

    +++ b/app/bluetooth/common/esl_tag_core/src/esl_tag_led_core.c

    @@ -0,0 +1,56 @@

    +/***************************************************************************//**

    + * @file

    + * @brief ESL Tag core WEAK implementations of LED functionalities.

    + *******************************************************************************

    + * # License

    + * <b>Copyright 2021 Silicon Laboratories Inc. www.silabs.com</b>

    + *******************************************************************************

    + *

    + * SPDX-License-Identifier: Zlib

    + *

    + * The licensor of this software is Silicon Laboratories Inc.

    + *

    + * This software is provided ''as-is'', without any express or implied

    + * warranty. In no event will the authors be held liable for any damages

    + * arising from the use of this software.

    + *

    + * Permission is granted to anyone to use this software for any purpose,

    + * including commercial applications, and to alter it and redistribute it

    + * freely, subject to the following restrictions:

    + *

    + * 1. The origin of this software must not be misrepresented; you must not

    + *    claim that you wrote the original software. If you use this software

    + *    in a product, an acknowledgment in the product documentation would be

    + *    appreciated but is not required.

    + * 2. Altered source versions must be plainly marked as such, and must not be

    + *    misrepresented as being the original software.

    + * 3. This notice may not be removed or altered from any source distribution.

    + *

    + ******************************************************************************/

    +#include "em_common.h"

    +#include "esl_tag_led_core.h"

    +

    +SL_WEAK void esl_led_init(void)

    +{

    +}

    +

    +SL_WEAK sl_status_t esl_led_control(esl_led_control_t *control_param)

    +{

    +  (void)control_param;

    +  // real implementation shall set ESL_BASIC_STATE_ACTIVE_LED_BIT according to

    +  // the cumulative status of all LEDs

    +  esl_core_set_basic_state_bit(ESL_BASIC_STATE_ACTIVE_LED_BIT, ESL_CLEAR);

    +

    +  return SL_STATUS_NOT_AVAILABLE;

    +}

    +

    +SL_WEAK uint8_t esl_led_get_count()

    +{

    +  return 0;

    +}

    +

    +SL_WEAK bool esl_led_is_srgb(uint8_t led_index)

    +{

    +  (void)led_index;

    +  return false;

    +}'
  - '--- a/app/bluetooth/common/esl_tag_core/src/esl_tag_log.c

    +++ b/app/bluetooth/common/esl_tag_core/src/esl_tag_log.c

    @@ -0,0 +1,65 @@

    +/***************************************************************************//**

    + * @file

    + * @brief ESL Tag core logging weak implementation for keeping the code size
    low

    + *******************************************************************************

    + * # License

    + * <b>Copyright 2022 Silicon Laboratories Inc. www.silabs.com</b>

    + *******************************************************************************

    + *

    + * SPDX-License-Identifier: Zlib

    + *

    + * The licensor of this software is Silicon Laboratories Inc.

    + *

    + * This software is provided ''as-is'', without any express or implied

    + * warranty. In no event will the authors be held liable for any damages

    + * arising from the use of this software.

    + *

    + * Permission is granted to anyone to use this software for any purpose,

    + * including commercial applications, and to alter it and redistribute it

    + * freely, subject to the following restrictions:

    + *

    + * 1. The origin of this software must not be misrepresented; you must not

    + *    claim that you wrote the original software. If you use this software

    + *    in a product, an acknowledgment in the product documentation would be

    + *    appreciated but is not required.

    + * 2. Altered source versions must be plainly marked as such, and must not be

    + *    misrepresented as being the original software.

    + * 3. This notice may not be removed or altered from any source distribution.

    + *

    + ******************************************************************************/

    +

    +#include "sl_common.h"

    +#include "esl_tag_log.h"

    +

    +SL_WEAK void sli_bt_esl_logger(uint8_t    component,

    +                               uint8_t    level,

    +                               const char *fmt,

    +                               ...)

    +{

    +  (void)component;

    +  (void)level;

    +  (void)fmt;

    +}

    +

    +SL_WEAK void sli_bt_esl_log_hex_dump(uint8_t component,

    +                                     uint8_t level,

    +                                     void    *p_data,

    +                                     uint8_t len)

    +{

    +  (void)component;

    +  (void)level;

    +  (void)p_data;

    +  (void)len;

    +}

    +

    +SL_WEAK void sli_bt_esl_assert_func(const char *func,

    +                                    const char *file,

    +                                    const char *expr,

    +                                    int        line)

    +{

    +  (void)func;

    +  (void)file;

    +  (void)expr;

    +  (void)line;

    +  while (1) ; // Halt

    +}'
  - '--- a/app/bluetooth/common/esl_tag_core/src/esl_tag_opcodes.c

    +++ b/app/bluetooth/common/esl_tag_core/src/esl_tag_opcodes.c

    @@ -0,0 +1,1088 @@

    +/***************************************************************************//**

    + * @file

    + * @brief ESL Tag opcode processor implementation

    + *******************************************************************************

    + * # License

    + * <b>Copyright 2021 Silicon Laboratories Inc. www.silabs.com</b>

    + *******************************************************************************

    + *

    + * SPDX-License-Identifier: Zlib

    + *

    + * The licensor of this software is Silicon Laboratories Inc.

    + *

    + * This software is provided ''as-is'', without any express or implied

    + * warranty. In no event will the authors be held liable for any damages

    + * arising from the use of this software.

    + *

    + * Permission is granted to anyone to use this software for any purpose,

    + * including commercial applications, and to alter it and redistribute it

    + * freely, subject to the following restrictions:

    + *

    + * 1. The origin of this software must not be misrepresented; you must not

    + *    claim that you wrote the original software. If you use this software

    + *    in a product, an acknowledgment in the product documentation would be

    + *    appreciated but is not required.

    + * 2. Altered source versions must be plainly marked as such, and must not be

    + *    misrepresented as being the original software.

    + * 3. This notice may not be removed or altered from any source distribution.

    + *

    + ******************************************************************************/

    +#include <stdio.h>

    +#include <stdbool.h>

    +#include "esl_tag_log.h"

    +#include "esl_tag_tlv.h"

    +#include "esl_tag_core.h"

    +#include "esl_tag_crypto.h"

    +#include "esl_tag_errors.h"

    +#include "esl_tag_led_core.h"

    +#include "esl_tag_internal.h"

    +#include "esl_tag_response.h"

    +#include "esl_tag_image_core.h"

    +#include "esl_tag_sensor_core.h"

    +#include "esl_tag_display_core.h"

    +#include "esl_tag_battery_internal.h"

    +#include "esl_tag_opcodes.h"

    +#include "app_scheduler.h"

    +

    +// ESL Access Point unassociate & reset command delay value [in milliseconds]

    +#define ESL_CORE_DEFAULT_COMMAND_DELAY_MS 750

    +

    +// ESL timed command absolute delay max value: 48 days [in milliseconds]

    +#define ESL_PLAUSIBLE_DELAY_MAX_VALUE_MS  4147200000  // ESLS d09r03, 3.10.2

    +

    +// ESL response slot default value

    +#define ESL_NO_PAWR_RESPONSE             -1

    +

    +// ESL timed (delayed) task type enumeration

    +typedef enum {

    +  esl_delayed_task_unknown = 0,

    +  esl_delayed_task_display,

    +  esl_delayed_task_led

    +} esl_delayed_task_type_t;

    +

    +// ESL scheduled object type to keep track of a scheduled timed task

    +typedef struct {

    +  bool                        is_running;

    +  uint32_t                    absolute_time;

    +  app_scheduler_task_handle_t scheduler;

    +  esl_delayed_task_type_t     type;

    +  uint8_t                     peripheral_index;

    +} esl_scheduled_object_t;

    +

    +// ESL timed commands register type to keep track of all scheduled items

    +typedef struct {

    +  esl_scheduled_object_t  schedule_list[APP_SCHEDULER_MAX_QUEUE_SIZE];

    +  uint8_t                 led_count;

    +  uint8_t                 display_count;

    +} esl_timed_command_register_t;

    +

    +// ESL timed commands register instance to keep track of actual pending commands

    +static esl_timed_command_register_t pending_commands = { 0 };

    +

    +/*******************************************************************************

    + * Expose ESL LED control parameters in human readable format to debug output

    + *

    + * @param[in] control_data pointer to LED control data to decode

    + ******************************************************************************/

    +static void esl_debug_led_control_parameters(esl_led_control_t *control_data)

    +{

    +#ifdef SL_CATALOG_ESL_TAG_CLI_TEST_HARNESS_PRESENT

    +  esl_led_gamut_control_t brightness = esl_led_get_brightness(control_data->gamut);

    +

    +  // calculate brightness component as percentage

    +  brightness = ESL_LED_LEVEL_STEP_PERCENTAGE * brightness + ESL_LED_LEVEL_STEP_PERCENTAGE;

    +

    +  sl_bt_esl_log(ESL_LOG_COMPONENT_CORE | ESL_LOG_FLAG_NOHEADER,

    +                ESL_LOG_LEVEL_INFO,

    +                "    LED %u ",

    +                control_data->index);

    +

    +  switch (control_data->repeats) {

    +    case ESL_LED_REPEATS_TYPE_TIME:

    +      sl_bt_esl_log(ESL_LOG_COMPONENT_CORE | ESL_LOG_FLAG_APPEND,

    +                    ESL_LOG_LEVEL_INFO, "turned on.");

    +      break;

    +

    +    case ESL_LED_REPEATS_TYPE_COUNT:

    +      sl_bt_esl_log(ESL_LOG_COMPONENT_CORE | ESL_LOG_FLAG_APPEND,

    +                    ESL_LOG_LEVEL_INFO, "turned off.");

    +      break;

    +

    +    default: {

    +      esl_led_repeats_type_t duration;

    +

    +      duration = control_data->repeats >> ESL_LED_REPEATS_DURATION_SHIFT;

    +      sl_bt_esl_log(ESL_LOG_COMPONENT_CORE | ESL_LOG_FLAG_APPEND,

    +                    ESL_LOG_LEVEL_INFO, "is flashing ");

    +      (void)duration; // remove the compiler warning if logging is disabled

    +

    +      if ((control_data->repeats & ESL_LED_REPEATS_TYPE_MASK) == 0) {

    +        sl_bt_esl_log(ESL_LOG_COMPONENT_CORE | ESL_LOG_FLAG_APPEND,

    +                      ESL_LOG_LEVEL_INFO, "%u times.",

    +                      duration);

    +      } else {

    +        sl_bt_esl_log(ESL_LOG_COMPONENT_CORE | ESL_LOG_FLAG_APPEND,

    +                      ESL_LOG_LEVEL_INFO, "for %u seconds.",

    +                      duration);

    +      }

    +      sl_bt_esl_log(ESL_LOG_COMPONENT_CORE | ESL_LOG_FLAG_NOHEADER,

    +                    ESL_LOG_LEVEL_INFO, "    Pattern: 0x");

    +      for (uint32_t i = sizeof(control_data->pattern.data); i; ) {

    +        sl_bt_esl_log(ESL_LOG_COMPONENT_LED | ESL_LOG_FLAG_APPEND,

    +                      ESL_LOG_LEVEL_INFO,

    +                      "%02X",

    +                      (uint8_t) control_data->pattern.data[--i]);

    +      }

    +      sl_bt_esl_log(ESL_LOG_COMPONENT_CORE | ESL_LOG_FLAG_NOHEADER,

    +                    ESL_LOG_LEVEL_INFO,

    +                    "    On period %u ms, off period %u ms.",

    +                    2 * control_data->pattern.bit_on_period,

    +                    2 * control_data->pattern.bit_off_period);

    +    } break;

    +  }

    +

    +  if (control_data->repeats != ESL_LED_REPEATS_TYPE_COUNT) {

    +    sl_bt_esl_log(ESL_LOG_COMPONENT_CORE | ESL_LOG_FLAG_NOHEADER,

    +                  ESL_LOG_LEVEL_INFO,

    +                  "    Brightness set to %u%%",

    +                  brightness);

    +

    +    if (esl_led_is_srgb(control_data->index)) {

    +      sl_bt_esl_log(ESL_LOG_COMPONENT_CORE | ESL_LOG_FLAG_NOHEADER,

    +                    ESL_LOG_LEVEL_INFO,

    +                    "    Red: %u, Green: %u, Blue: %u",

    +                    esl_led_get_red_value(control_data->gamut),

    +                    esl_led_get_green_value(control_data->gamut),

    +                    esl_led_get_blue_value(control_data->gamut));

    +    } else {

    +      sl_bt_esl_log(ESL_LOG_COMPONENT_CORE | ESL_LOG_FLAG_NOHEADER,

    +                    ESL_LOG_LEVEL_INFO,

    +                    "    Color field ignored.");

    +    }

    +  }

    +#else

    +  (void)control_data;

    +#endif // SL_CATALOG_ESL_TAG_CLI_TEST_HARNESS_PRESENT

    +}

    +

    +/*******************************************************************************

    + * ESL delayed unassociate task function

    + *

    + * @param[in] data Unused by this function but mandatory for app_scheduler tasks

    + * @param[in] size Unused by this function but mandatory for app_scheduler tasks

    + ******************************************************************************/

    +static void esl_delayed_unassociate(void *p_event_data, uint16_t event_size)

    +{

    +  (void)event_size;

    +  (void)p_event_data;

    +

    +  esl_core_unassociate();

    +}

    +

    +/*******************************************************************************

    + * ESL delayed reset task function

    + *

    + * @param[in] data Unused by this function but mandatory for app_scheduler tasks

    + * @param[in] size Unused by this function but mandatory for app_scheduler tasks

    + ******************************************************************************/

    +static void esl_delayed_reset(void *p_event_data, uint16_t event_size)

    +{

    +  (void)event_size;

    +  (void)p_event_data;

    +

    +  // delete bonding data

    +  (void)sl_bt_sm_delete_bondings();

    +  // system reset will restore the factory default state

    +  sl_bt_system_reset(sl_bt_system_boot_mode_normal);

    +}

    +

    +/*******************************************************************************

    + * ESL cleanup delayed task

    + *

    + * @param[in] cleanup_object pointer to esl_scheduled_object_t to remove from

    + *                           the list of running scheduler tasks

    + * @param[in] counter pointer to pending led or pending display task counter

    + * @param[in] flag esl_basic_state_t flag to clear if counter reach zero

    + * @note cleanup_object counter can be NULL

    + ******************************************************************************/

    +static void cleanup_delayed_task(esl_scheduled_object_t *cleanup_object,

    +                                 uint8_t *counter,

    +                                 esl_basic_state_t flag)

    +{

    +  // counter can''t be NULL!

    +  sl_bt_esl_assert(counter != NULL);

    +

    +  if (cleanup_object) {

    +    CORE_DECLARE_IRQ_STATE;

    +    // accessing the register shall be an atomic operation

    +    CORE_ENTER_CRITICAL();

    +    // clear the running flag and stop the periodic timer

    +    cleanup_object->is_running = false;

    +    cleanup_object->type = esl_delayed_task_unknown;

    +    CORE_EXIT_CRITICAL();

    +  }

    +

    +  // decrease pending count down to zero

    +  if (*counter && --(*counter) == 0) {

    +    // clear pending display basic state bit on demand

    +    esl_core_set_basic_state_bit(flag, ESL_CLEAR);

    +  }

    +}

    +

    +/*******************************************************************************

    + * ESL timed LED control task function

    + *

    + * @param[in] data contains pending_commands.schedule_list index and

    + *                 esl_led_control_t data concatenated

    + * @param[in] size Overall size of the data above

    + ******************************************************************************/

    +static void esl_delayed_led(void *p_event_data, uint16_t event_size)

    +{

    +  // Check for the proper size, skip anything that seems invalid

    +  if (event_size == (sizeof(uint16_t) + sizeof(esl_led_control_t))) {

    +    esl_led_control_t *control_data;

    +    // status for internal evaluation, only

    +    sl_status_t result      = SL_STATUS_FAIL;

    +    // get register index - always at the first event data position

    +    uint16_t register_index = *(uint16_t *)p_event_data;

    +    // helper pointer for byte positioning over p_event_data

    +    uint8_t  *data_p = ((uint8_t *)p_event_data) + sizeof(register_index);

    +    // backup copy last error code, if any

    +    const esl_error_t last_error = esl_core_get_last_error();

    +

    +    // get the event specific data according to ESLS 3.9.2.10 LED Control

    +    control_data = (esl_led_control_t *)data_p;

    +    // call actual led control

    +    result = esl_led_control(control_data);

    +    // revert last error code since timed commands shall not set any response!

    +    esl_core_set_last_error(last_error);

    +

    +    cleanup_delayed_task(&pending_commands.schedule_list[register_index],

    +                         &pending_commands.led_count,

    +                         ESL_BASIC_STATE_PENDING_LED_BIT);

    +    (void)result; // suppress the compiler warning if sl_bt_esl_log disabled

    +

    +    // check results, log accordingly

    +    if (result != SL_STATUS_OK) {

    +      sl_bt_esl_log(ESL_LOG_COMPONENT_CORE,

    +                    ESL_LOG_LEVEL_WARNING,

    +                    "Timed led control failed with status 0x%02lx!",

    +                    result);

    +    } else {

    +      sl_bt_esl_log(ESL_LOG_COMPONENT_CORE,

    +                    ESL_LOG_LEVEL_INFO,

    +                    "Timed control as follows:");

    +      esl_debug_led_control_parameters(control_data);

    +      sl_bt_esl_log(ESL_LOG_COMPONENT_CORE,

    +                    ESL_LOG_LEVEL_DEBUG,

    +                    "Still pending %u",

    +                    pending_commands.led_count);

    +    }

    +  } else {

    +    sl_bt_esl_log(ESL_LOG_COMPONENT_CORE,

    +                  ESL_LOG_LEVEL_WARNING,

    +                  "Invalid parameters for timed led control!");

    +  }

    +}

    +

    +/*******************************************************************************

    + * ESL timed display image task function

    + *

    + * @param[in] data contains pending_commands.schedule_list index, display_index

    + *                 and image index values concatenated

    + * @param[in] size Overall size of the data above

    + ******************************************************************************/

    +static void esl_delayed_display(void *p_event_data, uint16_t event_size)

    +{

    +  // Check for the proper size, skip anything that seems invalid

    +  if (event_size == (sizeof(uint16_t) + sizeof(uint8_t) + sizeof(uint8_t))) {

    +    // get register index - always at the first event data position

    +    uint16_t  register_index = *(uint16_t *)p_event_data;

    +    // get the event specific data: display index first, then image index

    +    uint8_t   *display_index = ((uint8_t *)p_event_data) + sizeof(register_index);

    +    uint8_t   *image_index   = display_index + sizeof(*display_index);

    +    // status for internal evaluation, only

    +    sl_status_t result       = SL_STATUS_FAIL;

    +    // backup copy last error code, if any

    +    const esl_error_t last_error = esl_core_get_last_error();

    +    // call actual display update

    +    result = esl_display_update(*display_index, *image_index);

    +    // revert last error code since timed commands shall not set any response!

    +    esl_core_set_last_error(last_error);

    +

    +    cleanup_delayed_task(&pending_commands.schedule_list[register_index],

    +                         &pending_commands.display_count,

    +                         ESL_BASIC_STATE_PENDING_DISPLAY_BIT);

    +    (void)result; // suppress the compiler warning if sl_bt_esl_log disabled

    +

    +    // check results, log accordingly

    +    if (result != SL_STATUS_OK) {

    +      sl_bt_esl_log(ESL_LOG_COMPONENT_CORE,

    +                    ESL_LOG_LEVEL_WARNING,

    +                    "Timed display failed with status 0x%02lx!",

    +                    result);

    +    } else {

    +      sl_bt_esl_log(ESL_LOG_COMPONENT_CORE,

    +                    ESL_LOG_LEVEL_INFO,

    +                    "Timed image %u on display %u",

    +                    *image_index,

    +                    *display_index);

    +      sl_bt_esl_log(ESL_LOG_COMPONENT_CORE, ESL_LOG_LEVEL_DEBUG, "Still pending
    %u",

    +                    pending_commands.display_count);

    +    }

    +  } else {

    +    sl_bt_esl_log(ESL_LOG_COMPONENT_CORE,

    +                  ESL_LOG_LEVEL_WARNING,

    +                  "Invalid parameters for timed display!");

    +  }

    +}

    +

    +/*******************************************************************************

    + * Remove an already scheduled task

    + *

    + * @param[in] object ESL scheduled object to be removed from the task scheduler

    + ******************************************************************************/

    +static void esl_remove_delayed_command(esl_scheduled_object_t *object)

    +{

    +  sl_bt_esl_assert(object != NULL);            // Object can''t be NULL!

    +  sl_bt_esl_assert(object->scheduler != NULL); // Object shall be initialized!

    +  // remove task from the scheduler

    +  (void)app_scheduler_remove(object->scheduler);

    +

    +  // decrement appropriate counts after removal - on successful re-

    +  // scheduling they will be adjusted again in esl_core_process_opcode

    +  if (object->type == esl_delayed_task_display) {

    +    cleanup_delayed_task(object,

    +                         &pending_commands.display_count,

    +                         ESL_BASIC_STATE_PENDING_DISPLAY_BIT);

    +    sl_bt_esl_log(ESL_LOG_COMPONENT_CORE,

    +                  ESL_LOG_LEVEL_DEBUG,

    +                  "Display task deleted, still pending: %u",

    +                  pending_commands.display_count);

    +  } else if (object->type == esl_delayed_task_led) {

    +    cleanup_delayed_task(object,

    +                         &pending_commands.led_count,

    +                         ESL_BASIC_STATE_PENDING_LED_BIT);

    +    sl_bt_esl_log(ESL_LOG_COMPONENT_CORE,

    +                  ESL_LOG_LEVEL_DEBUG,

    +                  "LED task deleted, still pending: %u",

    +                  pending_commands.led_count);

    +  }

    +}

    +

    +/*******************************************************************************

    + * Add a task to be scheduled with mandatory requested time and data parameters

    + *

    + * @param[in] task Task function to be scheduled

    + * @param[in] requested_time Absolute time when the task needs to be run

    + * @param[in] data The data that is passed to the task

    + * @param[in] size The size of the data

    + *

    + * @note Deletes a pending command if the requested time is zero, according to

    + *       ESL Service specification d095r13 Section 3.9.2.9.1 Handling multiple

    + *       Display Timed Image commands3.9.2.11.1 Handling multiple LED Timed

    + *       Control commands.

    + * @return Status of the operation

    + ******************************************************************************/

    +static sl_status_t esl_add_delayed_command(app_scheduler_task_t task,

    +                                           uint32_t requested_time,

    +                                           void *data,

    +                                           size_t size)

    +{

    +  CORE_DECLARE_IRQ_STATE;

    +  esl_delayed_task_type_t type = esl_delayed_task_unknown;

    +  sl_status_t result           = SL_STATUS_OK;

    +  uint32_t    absolute_time    = 0;

    +  uint16_t    free_index       = APP_SCHEDULER_MAX_QUEUE_SIZE;

    +  uint16_t    search_index     = 0;

    +  uint8_t     peripheral_index = 0;

    +  uint8_t     pending_flag     = 0;

    +  uint8_t     *counter;

    +

    +  // set local type according to task type

    +  if (task == &esl_delayed_display) {

    +    type = esl_delayed_task_display;

    +    peripheral_index = ((esl_led_control_t *)data)->index;

    +    counter = &pending_commands.display_count;

    +    pending_flag = ESL_BASIC_STATE_PENDING_DISPLAY_BIT;

    +  } else if (task == &esl_delayed_led) {

    +    type = esl_delayed_task_led;

    +    peripheral_index = *(uint8_t *)data;

    +    counter = &pending_commands.led_count;

    +    pending_flag = ESL_BASIC_STATE_PENDING_LED_BIT;

    +  } else {

    +    // invalid task to add delayed!

    +    return SL_STATUS_ABORT;

    +  }

    +

    +  // accessing the pending commands register shall be an atomic operation

    +  CORE_ENTER_CRITICAL();

    +  // for each entry search for either a free slot, or an occupied slot with the

    +  // same peripheral index

    +  for (; search_index < APP_SCHEDULER_MAX_QUEUE_SIZE; search_index++) {

    +    esl_scheduled_object_t *current_object;

    +

    +    current_object = &pending_commands.schedule_list[search_index];

    +

    +    // if running, then search for special conditions described in ESL Service

    +    // specification d095r13, Section 3.9.2.9.1 and Section 3.9.2.11.1

    +    if (current_object->is_running) {

    +      if (type == current_object->type && peripheral_index == current_object->peripheral_index)
    {

    +        // remove same tasks with same absolute_time of what''s now requested

    +        // or if requested time is 0 (delete command)

    +        if (!requested_time || requested_time == current_object->absolute_time)
    {

    +          // override actual free_index for re-scheduling the task

    +          free_index = search_index;

    +

    +          absolute_time = current_object->absolute_time;  // used as backup copy

    +          sl_bt_esl_log(ESL_LOG_COMPONENT_CORE,

    +                        ESL_LOG_LEVEL_INFO,

    +                        "Found running task at index %u, time %lu",

    +                        free_index, requested_time);

    +

    +          esl_remove_delayed_command(current_object);

    +          result = SL_STATUS_DELETED;

    +        } else {

    +          // only single delayed command per peripheral index is allowed!

    +          result = SL_STATUS_FULL;

    +        }

    +        break;

    +      }

    +    } else if (free_index == APP_SCHEDULER_MAX_QUEUE_SIZE) {

    +      // get first free available slot in the first place

    +      free_index = search_index;

    +    }

    +  }

    +  CORE_EXIT_CRITICAL();

    +

    +  if (!requested_time) {

    +    // was a delete request, report OK only if pending task existed for given
    index!

    +    if (result == SL_STATUS_DELETED) {

    +      sl_bt_esl_log(ESL_LOG_COMPONENT_CORE,

    +                    ESL_LOG_LEVEL_INFO,

    +                    "Deleted timed request at %lu",

    +                    absolute_time);

    +      return SL_STATUS_OK;

    +    } else {

    +      esl_core_set_last_error(ESL_ERROR_INVALID_PARAMETER);

    +      result = SL_STATUS_INVALID_PARAMETER;

    +    }

    +  } else if (free_index < APP_SCHEDULER_MAX_QUEUE_SIZE && result != SL_STATUS_FULL)
    {

    +    // if there was a free slot available for scheduling and not delete request

    +    uint32_t delay = 0;

    +    app_scheduler_task_handle_t *handle_p = NULL;

    +    const uint16_t extended_size = size + sizeof(free_index);

    +    uint8_t extended_data[APP_SCHEDULER_MAX_DATA_SIZE] = { 0 };

    +

    +    handle_p = &pending_commands.schedule_list[free_index].scheduler;

    +    result   = esl_core_read_absolute_time(&absolute_time);

    +

    +    if (result != SL_STATUS_OK) {

    +      esl_core_set_last_error(ESL_ERROR_INVALID_STATE);

    +    } else {

    +      memcpy(extended_data, &free_index, sizeof(free_index));

    +      memcpy(&extended_data[sizeof(free_index)], data, size);

    +

    +      delay  = requested_time - absolute_time;

    +

    +      if (delay <= ESL_PLAUSIBLE_DELAY_MAX_VALUE_MS) {

    +        result = app_scheduler_add_delayed(task, delay, extended_data,

    +                                           extended_size, handle_p);

    +

    +        if (result == SL_STATUS_OK) {

    +          esl_scheduled_object_t *current_object;

    +          current_object = &pending_commands.schedule_list[free_index];

    +

    +          current_object->is_running       = true;

    +          current_object->absolute_time    = requested_time;

    +          current_object->type             = type;

    +          current_object->peripheral_index = peripheral_index;

    +

    +          // increment counter on successful scheduling

    +          (*counter)++;

    +          // set pending bit of basic state, accordingly

    +          esl_core_set_basic_state_bit(pending_flag, ESL_SET);

    +          sl_bt_esl_log(ESL_LOG_COMPONENT_CORE,

    +                        ESL_LOG_LEVEL_INFO,

    +                        "Register timed command after %lu ms",

    +                        delay);

    +        } else {

    +          sl_bt_esl_log(ESL_LOG_COMPONENT_CORE,

    +                        ESL_LOG_LEVEL_ERROR,

    +                        "Register timed command failed with status %lu",

    +                        result);

    +        }

    +      } else {

    +        esl_core_set_last_error(ESL_ERROR_IMPLAUSIBLE_TIME);

    +        result = SL_STATUS_ABORT;

    +      }

    +    }

    +  } else {

    +    esl_core_set_last_error(ESL_ERROR_QUEUE_FULL);

    +    result = SL_STATUS_NO_MORE_RESOURCE;

    +  }

    +

    +  sl_bt_esl_log(ESL_LOG_COMPONENT_CORE,

    +                ESL_LOG_LEVEL_INFO,

    +                "Timed request at %lu result: 0x%04lx",

    +                requested_time, result);

    +  return result;

    +}

    +

    +void esl_reschedule_delayed_commands(uint32_t current_absolute_time)

    +{

    +  sl_status_t result;

    +  uint16_t    search_index = 0;

    +  CORE_DECLARE_IRQ_STATE;

    +

    +  // accessing the pending commands register shall be an atomic operation

    +  CORE_ENTER_CRITICAL();

    +  // for each entry search for occupied slots

    +  for (; search_index < APP_SCHEDULER_MAX_QUEUE_SIZE; search_index++) {

    +    esl_scheduled_object_t *current_object;

    +    uint32_t delay = 0;

    +

    +    current_object = &pending_commands.schedule_list[search_index];

    +

    +    // if running, then needs to be adjusted

    +    if (current_object->is_running) {

    +      uint32_t previous_delay;

    +      delay = current_object->absolute_time - current_absolute_time;

    +

    +      if (delay > ESL_PLAUSIBLE_DELAY_MAX_VALUE_MS) {

    +        delay = 0; // underflow means the time has passed, run immediately!

    +      }

    +      (void)app_scheduler_get_timeout(current_object->scheduler, &previous_delay);

    +      sl_bt_esl_log(ESL_LOG_COMPONENT_CORE,

    +                    ESL_LOG_LEVEL_DEBUG,

    +                    "Task %d re-schedule from %ld ms delay to %ld ms.",

    +                    search_index, previous_delay, delay);

    +      result = app_scheduler_reschedule(current_object->scheduler, delay);

    +

    +      if (result != SL_STATUS_OK) {

    +        sl_bt_esl_log(ESL_LOG_COMPONENT_CORE,

    +                      ESL_LOG_LEVEL_ERROR,

    +                      "Task %d re-schedule failed!",

    +                      search_index);

    +        current_object->is_running = false;

    +        current_object->type = esl_delayed_task_unknown;

    +      }

    +    }

    +  }

    +  CORE_EXIT_CRITICAL();

    +}

    +

    +void esl_core_purge_delayed_commands()

    +{

    +  CORE_DECLARE_IRQ_STATE;

    +  uint16_t search_index = 0;

    +

    +  // accessing the pending commands register shall be an atomic operation

    +  CORE_ENTER_CRITICAL();

    +  // for each entry search for either a free slot, or an occupied slot with the

    +  // same absolute_time value of current requested_time

    +  for (; search_index < APP_SCHEDULER_MAX_QUEUE_SIZE; search_index++) {

    +    esl_scheduled_object_t *current_object;

    +

    +    current_object = &pending_commands.schedule_list[search_index];

    +

    +    // if running, then stop it

    +    if (current_object->is_running) {

    +      esl_remove_delayed_command(current_object);

    +    }

    +  }

    +  CORE_EXIT_CRITICAL();

    +}

    +

    +sl_status_t esl_core_parse_all_opcodes(void *data, uint8_t len)

    +{

    +  esl_address_t esl_address = 0;

    +  sl_status_t   result = SL_STATUS_INVALID_STATE;

    +

    +  bool          has_notifications = esl_core_has_notifications();

    +  int16_t       response_slot = ESL_NO_PAWR_RESPONSE;

    +

    +  // Don''t allow any command before boot

    +  if (esl_core_get_status() != esl_state_boot) {

    +    // payload length shall be within reasonable limits

    +    if (ESL_PAYLOAD_MAX_LENGTH > len && ESL_PAYLOAD_MIN_LENGTH <= len) {

    +      esl_id_t      self_id;

    +      uint8_t       *next_opcode = data;

    +      uint8_t       tlv_count    = 0;

    +

    +      result = esl_core_read_esl_address(&esl_address);

    +

    +      // ESL Address won''t be configured properly after factory reset processed,

    +      // skip processing in that case

    +      if (result != SL_STATUS_OK && has_notifications) {

    +        esl_error_t error_code = ESL_ERROR_UNSPECIFIED; // according to ESLS
    3.9.2.4

    +        // return status of esl_core_build_response can be ignored in this case

    +        // because there''s nothing to do with it, anyway

    +        (void)esl_core_build_response(ESL_TLV_RESPONSE_ERROR, &error_code);

    +      }

    +

    +      // before command processing check if Service Needed flag needs to be set

    +      // due to low battery - whenever a valid ESL message is received

    +      esl_sensor_core_check_battery_level();

    +

    +      self_id = esl_core_get_id(esl_address);

    +

    +      // parse all possible opcodes

    +      while (len >= ESL_TLV_OPCODE_MIN_LENGTH && result == SL_STATUS_OK) {

    +        tlv_t     opcode     = *next_opcode++;  // there''s an opcode, first

    +        esl_id_t  id         = *next_opcode++;  // then the ESL id follows

    +        uint8_t   *next_data = next_opcode;     // point to data (if any)

    +        uint8_t   processed_length;

    +

    +        // adjust ''len'' by lengths of opcode and ESL id

    +        len -= ESL_TLV_OPCODE_MIN_LENGTH;

    +

    +        // process current opcode

    +        result           = esl_core_process_opcode(self_id,

    +                                                   id,

    +                                                   opcode,

    +                                                   (void *)&next_data);

    +        processed_length = (next_data - next_opcode); // might be 0, it''s OK

    +

    +        // check for bad edge case (e.g. after a misformatted TLV)

    +        if (processed_length > len) {

    +          result = SL_STATUS_FAIL;

    +        } else {

    +          len         -= processed_length;

    +          next_opcode += processed_length;

    +

    +          // track the proper response slot

    +          if (id == self_id) {

    +            response_slot = tlv_count;

    +          }

    +

    +          tlv_count++;

    +        }

    +      }

    +    } else {

    +      result = SL_STATUS_INVALID_PARAMETER;

    +    }

    +  }

    +

    +  if (!has_notifications && response_slot >= 0) {

    +    uint8_t responses[ESL_PAYLOAD_OVERHEAD + ESL_PAYLOAD_MAX_LENGTH];

    +    uint8_t length = esl_core_get_responses(sizeof(responses) - ESL_PAYLOAD_OVERHEAD,

    +                                            &responses[ESL_PAYLOAD_OVERHEAD]);

    +

    +    if (length && esl_core_get_sync_handle() != SL_BT_INVALID_SYNC_HANDLE) {

    +      sl_status_t sc;

    +      (void)sc; // suppress the compiler warning if sl_bt_esl_log disabled

    +      uint8_t *msg;

    +

    +      responses[0] = ++length;    // set length properly for LL Adv.Data frame

    +      responses[1] = ESL_AD_TYPE; // set ESL AD Type

    +

    +      length++; // set length properly for the whole frame to be encrypted

    +      sl_bt_esl_log(ESL_LOG_COMPONENT_CORE,

    +                    ESL_LOG_LEVEL_INFO,

    +                    "PAwR response(s): ");

    +      sl_bt_esl_log_hexdump(ESL_LOG_COMPONENT_CORE | ESL_LOG_FLAG_APPEND,

    +                            ESL_LOG_LEVEL_INFO,

    +                            responses,

    +                            length);

    +      msg = esl_core_encrypt_message(responses, &length);

    +

    +      sl_bt_esl_log(ESL_LOG_COMPONENT_CORE,

    +                    ESL_LOG_LEVEL_DEBUG,

    +                    "Encrypted: ");

    +      sl_bt_esl_log_hexdump(ESL_LOG_COMPONENT_CORE | ESL_LOG_FLAG_APPEND,

    +                            ESL_LOG_LEVEL_DEBUG,

    +                            responses,

    +                            length);

    +      if (msg != NULL) {

    +        // send periodic advertisement responses

    +        sc = sl_bt_pawr_sync_set_response_data(esl_core_get_sync_handle(),

    +                                               esl_core_get_request_event(),

    +                                               esl_core_get_request_subevent(),

    +                                               esl_core_get_group_id(esl_address),

    +                                               (uint8_t)response_slot,

    +                                               length,

    +                                               msg);

    +        sl_bt_esl_log(ESL_LOG_COMPONENT_CORE | ESL_LOG_FLAG_APPEND,

    +                      ESL_LOG_LEVEL_INFO,

    +                      ", result: 0x%04lx on slot %d",

    +                      sc,

    +                      response_slot);

    +      }

    +    }

    +    esl_core_purge_responses();

    +  }

    +

    +  return result;

    +}

    +

    +sl_status_t esl_core_process_opcode(esl_id_t self_id,

    +                                    esl_id_t id,

    +                                    tlv_t opcode,

    +                                    void **data)

    +{

    +  sl_status_t result = SL_STATUS_OK; // if not sent for us, do nothing, it''s
    OK

    +  bool        has_notifications = esl_core_has_notifications();

    +  bool        needs_response    = (has_notifications || (id == self_id));

    +

    +  // process only TLVs addressed to this ESL Tag or broadcasted (only over PAwR!)

    +  if (id == self_id || (id == ESL_BROADCAST_ID && !has_notifications)) {

    +#ifdef ESL_TAG_VENDOR_OPCODES_ENABLED

    +    // check for vendor opcodes first - let them processed by the vendor callback

    +    if ((opcode & ESL_TLV_OPCODE_VENDOR_SPECIFIC) == ESL_TLV_OPCODE_VENDOR_SPECIFIC)
    {

    +      uint8_t *data_p  = *(uint8_t **)data;

    +      uint8_t data_len = esl_core_get_tlv_len(opcode);

    +

    +      result = esl_core_process_vendor_opcode(opcode, data_len, data_p);

    +

    +      if (result != SL_STATUS_OK) {

    +        esl_error_t error_code = ESL_ERROR_INVALID_OPCODE;

    +

    +        if (result != SL_STATUS_NOT_SUPPORTED) {

    +          error_code = esl_core_get_last_error();

    +        }

    +

    +        (void)esl_core_build_response(ESL_TLV_RESPONSE_ERROR, &error_code);

    +      }

    +      // adjust data pointer properly - custom implementation shall not care

    +      *data = (void *)(data_p + data_len - sizeof(opcode));

    +      return SL_STATUS_OK;

    +    }

    +#endif // ESL_TAG_VENDOR_OPCODES_ENABLED

    +

    +    switch (opcode) {

    +      case ESL_TLV_OPCODE_SERVICE_RST:

    +        // refresh the battery level actual value

    +        esl_sensor_battery_read();

    +        // clear the service needed flag in the first place

    +        esl_core_set_basic_state_bit(ESL_BASIC_STATE_SERVICE_NEEDED_BIT,

    +                                     ESL_CLEAR);

    +        // call user callback in the end

    +        esl_core_service_reset_event(); // @suppress("No break at end of case")

    +      // intentional fall through to ESL_TLV_OPCODE_PING, GCC suppress follows:

    +      /* FALLTHRU */

    +      case ESL_TLV_OPCODE_PING:

    +        // ignore any PING sent as broadcast message over PAWR sync!

    +        if (needs_response) {

    +          // report the Basic State register for ESL_TLV_OPCODE_SERVICE_RST

    +          // and ESL_TLV_OPCODE_PING commands according to ESL Service Spec.

    +          esl_basic_state_t basic_state = esl_core_get_basic_state();

    +          result = esl_core_build_response(ESL_TLV_RESPONSE_BASIC_STATE,

    +                                           &basic_state);

    +        } else {

    +          result = SL_STATUS_OK;

    +        }

    +        break;

    +

    +      case ESL_TLV_OPCODE_UNASSOCIATE: {

    +        esl_basic_state_t basic_state = esl_core_get_basic_state();

    +

    +        // remove any pending delayed command immediately

    +        esl_core_purge_delayed_commands();

    +

    +        // Close the connection, if opened

    +        (void)app_scheduler_add(&esl_core_async_disconnect, 0, 0, NULL);

    +

    +        result = app_scheduler_add_delayed(&esl_delayed_unassociate,

    +                                           ESL_CORE_DEFAULT_COMMAND_DELAY_MS,

    +                                           NULL, 0, NULL);

    +        if (result != SL_STATUS_OK) {

    +          esl_core_set_last_error(ESL_ERROR_INSUFFICIENT_RESOURCES);

    +        } else if (needs_response) {

    +          result = esl_core_build_response(ESL_TLV_RESPONSE_BASIC_STATE,

    +                                           &basic_state);

    +        }

    +      } break;

    +

    +      case ESL_TLV_OPCODE_LED_TIMED_CONTROL:

    +      case ESL_TLV_OPCODE_LED_CONTROL: {

    +        // get led control data from **data

    +        esl_led_control_t *control_data = *(esl_led_control_t **)data;

    +        // prepare for immediate or delayed command response

    +        uint8_t response[] = { control_data->index };

    +        uint8_t led_count  = esl_led_get_count();

    +        // step data pointer forward

    +        *data = (void *)((uint8_t *)control_data + sizeof(*control_data));

    +

    +        // check valid range before call the actual update function

    +        if (control_data->index < led_count) {

    +          if (opcode == ESL_TLV_OPCODE_LED_CONTROL) {

    +            result = esl_led_control(control_data);

    +#ifdef SL_CATALOG_ESL_TAG_CLI_TEST_HARNESS_PRESENT

    +            if (result == SL_STATUS_OK) {

    +              sl_bt_esl_log(ESL_LOG_COMPONENT_CORE,

    +                            ESL_LOG_LEVEL_INFO,

    +                            "Immediate LED control as follows:");

    +              esl_debug_led_control_parameters(control_data);

    +            }

    +#endif // SL_CATALOG_ESL_TAG_CLI_TEST_HARNESS_PRESENT

    +          } else {

    +            // get absolute time from **data

    +            uint32_t *requested_time = *((uint32_t **)data);

    +            // helper pointer for byte positioning over data

    +            uint8_t   *data_p = (uint8_t *)requested_time;

    +            *data = (void *)(data_p + sizeof(*requested_time));

    +

    +            result = esl_add_delayed_command(&esl_delayed_led,

    +                                             *requested_time,

    +                                             control_data,

    +                                             sizeof(*control_data));

    +            if (result != SL_STATUS_OK) {

    +              // ESL_ERROR_QUEUE_FULL might be set already in that particular

    +              // error case, otherwise send ESL_ERROR_INSUFFICIENT_RESOURCES

    +              esl_core_set_last_error(ESL_ERROR_INSUFFICIENT_RESOURCES);

    +            }

    +          }

    +

    +          if (result == SL_STATUS_OK) {

    +            if (needs_response) {

    +              // return status of esl_core_build_response can be safely ignored

    +              // because if the LED status response doesn''t fit, then the other

    +              // ''Capacity Limit'' error response wouldn''t fit, either!

    +              (void)esl_core_build_response(ESL_TLV_RESPONSE_LED_STATE,

    +                                            response);

    +            }

    +          } else {

    +            esl_core_set_last_error(ESL_ERROR_UNSPECIFIED);

    +          }

    +        } else {

    +          if (led_count != 0) {

    +            result = SL_STATUS_INVALID_INDEX;

    +            esl_core_set_last_error(ESL_ERROR_INVALID_PARAMETER);

    +          } else {

    +            result = SL_STATUS_NOT_AVAILABLE;

    +            esl_core_set_last_error(ESL_ERROR_INVALID_OPCODE);

    +          }

    +

    +          if (opcode == ESL_TLV_OPCODE_LED_TIMED_CONTROL) {

    +            // skip absolute time value of the timed LED commands

    +            *data = (void *)((*(uint8_t **)data) + sizeof(uint32_t));

    +          }

    +        }

    +      } break;

    +

    +      case ESL_TLV_OPCODE_REFRESH_DISPLAY: {

    +        // get display index from **data

    +        uint8_t *display_index = *((uint8_t **)data);

    +        // prepare for immediate response

    +        uint8_t response[] = { *display_index, 0 }; // image index placeholder

    +        uint8_t display_count = esl_display_get_count();

    +

    +        // step data pointer forward

    +        *data = (void *)(display_index + sizeof(*display_index));

    +

    +        // check valid range before call the actual update function

    +        if (*display_index < display_count) {

    +          uint8_t image_index;

    +

    +          result = esl_display_refresh(*display_index, &image_index);

    +

    +          if (result == SL_STATUS_OK) {

    +            if (needs_response) {

    +              // set the image index properly

    +              response[1] = image_index;

    +              result = esl_core_build_response(ESL_TLV_RESPONSE_DISPLAY_STATE,

    +                                               response);

    +            }

    +          } else {

    +            esl_core_set_last_error(ESL_ERROR_UNSPECIFIED);

    +          }

    +        } else if (display_count != 0) {

    +          result = SL_STATUS_INVALID_INDEX;

    +          esl_core_set_last_error(ESL_ERROR_INVALID_PARAMETER);

    +        } else {

    +          result = SL_STATUS_NOT_AVAILABLE;

    +          esl_core_set_last_error(ESL_ERROR_INVALID_OPCODE);

    +        }

    +      } break;

    +

    +      case ESL_TLV_OPCODE_DISPLAY_TIMED_IMAGE:

    +      case ESL_TLV_OPCODE_DISPLAY_IMAGE: {

    +        // get display and image indices from **data

    +        uint8_t *display_index = *((uint8_t **)data);

    +        uint8_t *image_index = display_index + sizeof(*display_index);

    +        // prepare for immediate or delayed command response

    +        uint8_t response[] = { *display_index, *image_index };

    +

    +        uint8_t display_count = esl_display_get_count();

    +

    +        // step data pointer forward

    +        *data = (void *)(image_index + sizeof(*image_index));

    +

    +        // check valid range before call the actual update function

    +        if (*display_index  < display_count

    +            && *image_index < esl_image_get_count()) {

    +          // do immediately if it''s not the timed command

    +          if (opcode == ESL_TLV_OPCODE_DISPLAY_IMAGE) {

    +            result = esl_display_update(*display_index, *image_index);

    +          } else {

    +            // get absolute time from **data

    +            uint32_t *requested_time = *((uint32_t **)data);

    +            // helper pointer for byte positioning over data

    +            uint8_t   *data_p = (uint8_t *)requested_time;

    +            *data = (void *)(data_p + sizeof(*requested_time));

    +

    +            result = esl_add_delayed_command(&esl_delayed_display,

    +                                             *requested_time, response,

    +                                             sizeof(response));

    +            if (result != SL_STATUS_OK) {

    +              // ESL_ERROR_QUEUE_FULL might be set already in that particular

    +              // error case, otherwise send ESL_ERROR_INSUFFICIENT_RESOURCES

    +              esl_core_set_last_error(ESL_ERROR_INSUFFICIENT_RESOURCES);

    +            }

    +          }

    +

    +          if (result == SL_STATUS_OK) {

    +            if (needs_response) {

    +              // return status of esl_core_build_response can be safely ignored

    +              // because if the Display status response doesn''t fit, then the

    +              // other ''Capacity Limit'' error response wouldn''t fit, either!

    +              (void)esl_core_build_response(ESL_TLV_RESPONSE_DISPLAY_STATE,

    +                                            response);

    +            }

    +          } else {

    +            esl_core_set_last_error(ESL_ERROR_UNSPECIFIED);

    +          }

    +        } else {

    +          result = SL_STATUS_INVALID_INDEX;

    +          // if the display_index is within its boundaries, then it must be

    +          // the image index wrong...

    +          if (*display_index < display_count) {

    +            esl_core_set_last_error(ESL_ERROR_INVALID_IMAGE_INDEX);

    +          } else if (display_count != 0) {

    +            esl_core_set_last_error(ESL_ERROR_INVALID_PARAMETER);

    +          } else {

    +            result = SL_STATUS_NOT_AVAILABLE;

    +            esl_core_set_last_error(ESL_ERROR_INVALID_OPCODE);

    +          }

    +

    +          if (opcode == ESL_TLV_OPCODE_DISPLAY_TIMED_IMAGE) {

    +            // skip absolute time value of the timed display commands

    +            *data = (void *)((*(uint8_t **)data) + sizeof(uint32_t));

    +          }

    +        }

    +      } break;

    +

    +      case ESL_TLV_OPCODE_FACTORY_RST:

    +        if (esl_core_get_status() == esl_state_synchronized) {

    +          result = SL_STATUS_INVALID_STATE;

    +          esl_core_set_last_error(ESL_ERROR_INVALID_STATE);

    +        } else {

    +          sl_status_t result;

    +

    +          // remove any pending delayed command immediately

    +          esl_core_purge_delayed_commands();

    +          // Invalidate config to avoid processing any further commands according
    to ESLS 3.9.2.4

    +          esl_core_invalidate_config();

    +          // deferred close of the active connection

    +          result = app_scheduler_add(&esl_core_async_disconnect, 0, 0, NULL);

    +

    +          if (result == SL_STATUS_OK) {

    +            result = app_scheduler_add_delayed(&esl_delayed_reset,

    +                                               ESL_CORE_DEFAULT_COMMAND_DELAY_MS,

    +                                               NULL, 0, NULL);

    +          }

    +

    +          // brute-force fall-back case if scheduling failed

    +          if (result != SL_STATUS_OK) {

    +            // delete bonding data

    +            (void)sl_bt_sm_delete_bondings();

    +            // and do immediate reset on failed scheduling

    +            sl_bt_system_reset(sl_bt_system_boot_mode_normal);

    +          }

    +        }

    +        break;

    +

    +      case ESL_TLV_OPCODE_UPDATE_COMPLETE:

    +        result = esl_core_update_complete();

    +        // Check result

    +        if (result == SL_STATUS_INVALID_STATE) {

    +          esl_core_set_last_error(ESL_ERROR_INVALID_STATE);

    +        }

    +        break;

    +

    +      case ESL_TLV_OPCODE_READ_SENSOR: {

    +        // get sensor index from **data

    +        uint8_t *sensor_index = *((uint8_t **)data);

    +        uint8_t sensor_count = esl_sensor_get_count();

    +

    +        // step data pointer forward

    +        *data = (void *)(sensor_index + sizeof(*sensor_index));

    +

    +        // check valid range before call the actual read function

    +        if (*sensor_index < sensor_count) {

    +          // call only if not a broadcast request - else no answer is expected!

    +          if (id != ESL_BROADCAST_ID) {

    +            // esl_sensor_read() will take care of the ESL error code, if any

    +            result = esl_sensor_read(*sensor_index);

    +          }

    +          if (result != SL_STATUS_OK) {

    +            esl_core_set_last_error(ESL_ERROR_UNSPECIFIED);

    +          }

    +        } else if (sensor_count != 0) {

    +          result = SL_STATUS_INVALID_INDEX;

    +          esl_core_set_last_error(ESL_ERROR_INVALID_PARAMETER);

    +        } else {

    +          result = SL_STATUS_NOT_AVAILABLE;

    +          esl_core_set_last_error(ESL_ERROR_INVALID_OPCODE);

    +        }

    +      }

    +      break;

    +

    +      default:

    +        // unknown or unimplemented opcode

    +        // Forward compatibility, ESL Profile d09r18, Section 3.1.3:

    +        result = SL_STATUS_NOT_SUPPORTED;

    +        esl_core_set_last_error(ESL_ERROR_INVALID_OPCODE);

    +        break;

    +    }

    +

    +    sl_bt_esl_log(ESL_LOG_COMPONENT_CORE,

    +                  ((result) ? ESL_LOG_LEVEL_ERROR : ESL_LOG_LEVEL_INFO),

    +                  "Opcode 0x%02x result: 0x%04lx",

    +                  opcode, result);

    +

    +    if (result != SL_STATUS_OK) {

    +      // actual result value is only used up to this point, internally...

    +      if (needs_response) {

    +        esl_error_t error_code = esl_core_get_last_error();

    +        sl_bt_esl_log(ESL_LOG_COMPONENT_CORE,

    +                      ESL_LOG_LEVEL_ERROR,

    +                      "Last ESL error code: 0x%02x",

    +                      error_code);

    +        // return status of esl_core_build_response must be ignored in this case

    +        // because there''s nothing left to do with it, anyway

    +        (void)esl_core_build_response(ESL_TLV_RESPONSE_ERROR, &error_code);

    +      }

    +      // thus, after it may transformed to an ESL error report, now we override

    +      result = SL_STATUS_OK;

    +    }

    +  } else {

    +    uint8_t *data_p  = *(uint8_t **)data;

    +    uint8_t data_len = esl_core_get_tlv_len(opcode);

    +    // adjust data pointer properly is mandatory even if isn''t addressed to
    us!

    +    *data = (void *)(data_p + data_len - sizeof(opcode));

    +

    +    if (has_notifications) {  // did it come from ESL CP?

    +      esl_error_t error_code = ESL_ERROR_INVALID_PARAMETER;

    +      // return status of esl_core_build_response must be ignored in this case

    +      // because there''s nothing left to do with it, anyway

    +      (void)esl_core_build_response(ESL_TLV_RESPONSE_ERROR, &error_code);

    +    }

    +  }

    +

    +  return result;

    +}

    +

    +SL_WEAK sl_status_t esl_core_process_vendor_opcode(tlv_t opcode,

    +                                                   uint8_t input_length,

    +                                                   void *data)

    +{

    +  // the default implementation does nothing, see app.c in the ESL Tag Studio

    +  // example project app.c for an implementation tutorial

    +  (void)opcode;

    +  (void)input_length;

    +  (void)data;

    +

    +  return SL_STATUS_NOT_SUPPORTED;

    +}'
  - '--- a/app/bluetooth/common/esl_tag_core/src/esl_tag_response.c

    +++ b/app/bluetooth/common/esl_tag_core/src/esl_tag_response.c

    @@ -0,0 +1,112 @@

    +/***************************************************************************//**

    + * @file

    + * @brief ESL Tag response implementation

    + *******************************************************************************

    + * # License

    + * <b>Copyright 2021 Silicon Laboratories Inc. www.silabs.com</b>

    + *******************************************************************************

    + *

    + * SPDX-License-Identifier: Zlib

    + *

    + * The licensor of this software is Silicon Laboratories Inc.

    + *

    + * This software is provided ''as-is'', without any express or implied

    + * warranty. In no event will the authors be held liable for any damages

    + * arising from the use of this software.

    + *

    + * Permission is granted to anyone to use this software for any purpose,

    + * including commercial applications, and to alter it and redistribute it

    + * freely, subject to the following restrictions:

    + *

    + * 1. The origin of this software must not be misrepresented; you must not

    + *    claim that you wrote the original software. If you use this software

    + *    in a product, an acknowledgment in the product documentation would be

    + *    appreciated but is not required.

    + * 2. Altered source versions must be plainly marked as such, and must not be

    + *    misrepresented as being the original software.

    + * 3. This notice may not be removed or altered from any source distribution.

    + *

    + ******************************************************************************/

    +#include <stdint.h>

    +#include "esl_tag_log.h"

    +#include "esl_tag_core.h"

    +#include "circular_queue.h"

    +#include "esl_tag_response.h"

    +

    +static Queue_t esl_response_queue;

    +static bool esl_core_on_response_queue_overflow(const Queue_t *queue,

    +                                                void *data)

    +{

    +  (void)queue;

    +  (void)data;

    +  // The event queue is overflowing but we don''t allow overwriting the oldest

    +  // entry in the buffer. Rather, we''re going just to drop the new response

    +  // since it doesn''t fit

    +  return false; // disallow the overwrite

    +}

    +

    +void esl_core_respones_init()

    +{

    +  // Initialize the queue for ESL responses

    +  bool init_result = queueInit(&esl_response_queue, ESL_PAYLOAD_MAX_LENGTH);

    +

    +  (void)init_result;  // remove the compiler warning if asserts are disabled

    +  // ESL responses queue init failed! Circular queue max length must be >= 48!

    +  sl_bt_esl_assert(init_result);

    +

    +  queueOverflow(&esl_response_queue, &esl_core_on_response_queue_overflow);

    +}

    +

    +sl_status_t esl_core_build_response(tlv_t tlv, const void *input_data)

    +{

    +  sl_status_t   result = SL_STATUS_WOULD_OVERFLOW;

    +  uint8_t       length = esl_core_get_tlv_len(tlv);

    +  const uint8_t *data  = (uint8_t *)input_data;

    +

    +  if (esl_response_queue.size - esl_response_queue.count > length) {

    +    queueAdd(&esl_response_queue, (void *)(uint32_t)tlv);

    +

    +    while (length--) {

    +      queueAdd(&esl_response_queue, (void *)(uint32_t)(*data++));

    +    }

    +

    +    result = SL_STATUS_OK;

    +  } else {

    +    esl_core_set_last_error(ESL_ERROR_CAPACITY_LIMIT);

    +  }

    +

    +  return result;

    +}

    +

    +uint8_t esl_core_get_responses(uint8_t remaining_length, uint8_t *buf_p)

    +{

    +  uint8_t length = 0;

    +  // Invalid function invocation!

    +  sl_bt_esl_assert(buf_p != NULL);

    +

    +  while (!queueIsEmpty(&esl_response_queue)) {

    +    tlv_t   next_tlv = (tlv_t)(uint32_t)queuePeek(&esl_response_queue);

    +    uint8_t data_len = esl_core_get_tlv_len(next_tlv) + 1;

    +    // only allow getting responses with full integrity, get them all possible

    +    if (data_len <= remaining_length) {

    +      remaining_length -= data_len;

    +      while (data_len--) {

    +        *buf_p++ = (uint8_t)(uint32_t)queueRemove(&esl_response_queue);

    +        ++length;

    +      }

    +    } else {

    +      break;

    +    }

    +  }

    +

    +  return length;

    +}

    +

    +/**************************************************************************//**

    + * Purge all ESL Tag responses from the queue (if any).

    + *****************************************************************************/

    +void esl_core_purge_responses()

    +{

    +  esl_core_set_last_error(ESL_ERROR_VENDOR_NOERROR);

    +  queueInit(&esl_response_queue, ESL_PAYLOAD_MAX_LENGTH);

    +}'
  - '--- a/app/bluetooth/common/esl_tag_core/src/esl_tag_sensor_core.c

    +++ b/app/bluetooth/common/esl_tag_core/src/esl_tag_sensor_core.c

    @@ -0,0 +1,74 @@

    +/***************************************************************************//**

    + * @file

    + * @brief ESL Tag core WEAK implementations of sensor functionalities.

    + *******************************************************************************

    + * # License

    + * <b>Copyright 2021 Silicon Laboratories Inc. www.silabs.com</b>

    + *******************************************************************************

    + *

    + * SPDX-License-Identifier: Zlib

    + *

    + * The licensor of this software is Silicon Laboratories Inc.

    + *

    + * This software is provided ''as-is'', without any express or implied

    + * warranty. In no event will the authors be held liable for any damages

    + * arising from the use of this software.

    + *

    + * Permission is granted to anyone to use this software for any purpose,

    + * including commercial applications, and to alter it and redistribute it

    + * freely, subject to the following restrictions:

    + *

    + * 1. The origin of this software must not be misrepresented; you must not

    + *    claim that you wrote the original software. If you use this software

    + *    in a product, an acknowledgment in the product documentation would be

    + *    appreciated but is not required.

    + * 2. Altered source versions must be plainly marked as such, and must not be

    + *    misrepresented as being the original software.

    + * 3. This notice may not be removed or altered from any source distribution.

    + *

    + ******************************************************************************/

    +#include "em_common.h"

    +#include "esl_tag_core_config.h"

    +#include "esl_tag_sensor_core.h"

    +#include "esl_tag_battery_internal.h"

    +

    +SL_WEAK sl_status_t esl_sensor_battery_read(void)

    +{

    +  return SL_STATUS_NOT_SUPPORTED;

    +}

    +

    +SL_WEAK sl_status_t  esl_sensor_battery_init(void)

    +{

    +  return SL_STATUS_NOT_SUPPORTED;

    +}

    +

    +SL_WEAK uint32_t esl_sensor_get_battery_voltage_mv(void)

    +{

    +  return ESL_TAG_BATTERY_LEVEL_FULL_MILLIVOLTS;

    +}

    +

    +SL_WEAK void esl_sensor_init(void)

    +{

    +}

    +

    +SL_WEAK uint8_t esl_sensor_get_count(void)

    +{

    +  return 0;

    +}

    +

    +SL_WEAK sl_status_t esl_sensor_read(uint8_t index)

    +{

    +  (void)index;

    +

    +  return SL_STATUS_NOT_AVAILABLE;

    +}

    +

    +void esl_sensor_core_check_battery_level(void)

    +{

    +  uint32_t battery_level = esl_sensor_get_battery_voltage_mv();

    +

    +  if (battery_level > ESL_TAG_BATTERY_LEVEL_UNKNOWN

    +      && battery_level <= ESL_TAG_BATTERY_LEVEL_LOW_MILLIVOLTS) {

    +    esl_core_set_basic_state_bit(ESL_BASIC_STATE_SERVICE_NEEDED_BIT, ESL_SET);

    +  }

    +}'
  - '--- a/app/bluetooth/common/esl_tag_display/src/esl_tag_display.c

    +++ b/app/bluetooth/common/esl_tag_display/src/esl_tag_display.c

    @@ -0,0 +1,313 @@

    +/***************************************************************************//**

    + * @file

    + * @brief ESL Tag abstract display logic.

    + *******************************************************************************

    + * # License

    + * <b>Copyright 2021 Silicon Laboratories Inc. www.silabs.com</b>

    + *******************************************************************************

    + *

    + * SPDX-License-Identifier: Zlib

    + *

    + * The licensor of this software is Silicon Laboratories Inc.

    + *

    + * This software is provided ''as-is'', without any express or implied

    + * warranty. In no event will the authors be held liable for any damages

    + * arising from the use of this software.

    + *

    + * Permission is granted to anyone to use this software for any purpose,

    + * including commercial applications, and to alter it and redistribute it

    + * freely, subject to the following restrictions:

    + *

    + * 1. The origin of this software must not be misrepresented; you must not

    + *    claim that you wrote the original software. If you use this software

    + *    in a product, an acknowledgment in the product documentation would be

    + *    appreciated but is not required.

    + * 2. Altered source versions must be plainly marked as such, and must not be

    + *    misrepresented as being the original software.

    + * 3. This notice may not be removed or altered from any source distribution.

    + *

    + ******************************************************************************/

    +#include <stddef.h>

    +#include "gatt_db.h"

    +#include "esl_tag_log.h"

    +#include "esl_tag_display.h"

    +#include "esl_tag_image_core.h"

    +

    +#define ESL_LAST_IMAGE_UNSET  -1

    +

    +// Display Information type - same format as defined in ESL Specification,

    +// Display Information Characteristic definition

    +PACKSTRUCT(struct esl_display_info_t {

    +  uint16_t              width;

    +  uint16_t              height;

    +  esl_display_type_t    type;

    +});

    +

    +// Extended display object type, containing additional function pointers for

    +// internal use

    +typedef PACKSTRUCT (struct {

    +  esl_display_info_p    info;

    +  esl_va_method_p       init;

    +  esl_va_method_p       write_image;

    +  int32_t               last_image;

    +}) esl_display_object_t;

    +

    +// Internal display registry type

    +typedef PACKSTRUCT (struct {

    +  esl_display_object_t  *next_object;

    +  uint8_t               display_count;

    +}) esl_display_registry_t;

    +

    +// Display info array - max. number of elements is defined in config header

    +static struct esl_display_info_t  display_info[ESL_TAG_MAX_DISPLAYS];

    +

    +// Display object array for internal use

    +static esl_display_object_t       display_object[ESL_TAG_MAX_DISPLAYS];

    +

    +// Display registry structure

    +static esl_display_registry_t     display_registry;

    +

    +/******************************************************************************

    + * Display info getter - returns with all display data in a format which can
    be

    + * easily write to the ESL Display Information characteristic.

    + * @param[out] uint16_t* size of the ESL display info data

    + * @param[out] void** pointer to the serialized ESL Display Info data

    + *****************************************************************************/

    +static inline void esl_display_get_all_info(uint16_t *data_size, void **out)

    +{

    +  *data_size = display_registry.display_count * sizeof(struct esl_display_info_t);

    +

    +  // having the characteristic with zero length of data is invalid!

    +  if (*data_size == 0) {

    +    // this is an ''user error'' condition, still the GATT req. shall succeed
    once

    +    // the ESL access point tries to read it, thus we need at least one full
    set

    +    // to be reported even if this "shadow" display itself will be invalid

    +    // (0 x 0 pixels, type 0) and hence non-functioning without registering at

    +    // least one during the ESL boot event, properly

    +    *data_size = sizeof(struct esl_display_info_t);

    +  }

    +

    +  *out = (void *)display_info;

    +}

    +

    +void esl_display_init(void)

    +{

    +  uint8_t i;

    +  // clear all display data

    +  memset(display_info, 0, sizeof(display_info));

    +  memset(display_object, 0, sizeof(display_object));

    +

    +  // 1:1 assign every display_info to the corresponding display_objects

    +  for (i = 0; i < ESL_TAG_MAX_DISPLAYS; ++i) {

    +    display_object[i].info = &display_info[i];

    +    // set an invalid last image index to all, too

    +    display_object[i].last_image = ESL_LAST_IMAGE_UNSET;

    +  }

    +  // initialize zero display count, prepare display creation / allocation

    +  display_registry.next_object  = display_object;

    +  display_registry.display_count = 0;

    +}

    +

    +void esl_display_bt_on_event(sl_bt_msg_t *evt)

    +{

    +  switch (SL_BT_MSG_ID(evt->header)) {

    +    case sl_bt_evt_gatt_server_user_read_request_id:

    +      if (evt->data.evt_gatt_server_user_read_request.characteristic == gattdb_esl_display_info)
    {

    +        uint8_t*  raw_info;

    +        uint16_t  raw_size, offset;

    +        uint16_t  mtu_size;

    +        sl_status_t sc;

    +        (void)sc; // suppress the compiler warning if sl_bt_esl_assert disabled

    +

    +        // get pointer first to the beginning of the display_info packed struct

    +        esl_display_get_all_info(&raw_size, (void *)&raw_info);

    +        // then get the offset value from the request

    +        offset = evt->data.evt_gatt_server_user_read_request.offset;

    +        // finally, adjust offset and size

    +        raw_info += offset;

    +        raw_size -= offset;

    +

    +        // check current ATT_MTU limits

    +        sc = sl_bt_gatt_server_get_mtu(evt->data.evt_gatt_server_user_read_request.connection,
    &mtu_size);

    +        sl_bt_esl_assert(sc == SL_STATUS_OK);

    +

    +        // sl_bt_gatt_server_send_user_read_response allows (ATT_MTU - 1) size

    +        --mtu_size; // of data to be sent at once!

    +

    +        // and limit the actual data size to be sent accordingly

    +        raw_size = raw_size > mtu_size ? mtu_size : raw_size;

    +

    +        // send data (chunk, maybe more read reqs. with offset != 0 will follow)

    +        sc = sl_bt_gatt_server_send_user_read_response(evt->data.evt_gatt_server_user_read_request.connection,

    +                                                       evt->data.evt_gatt_server_user_read_request.characteristic,

    +                                                       SL_STATUS_OK,

    +                                                       raw_size,

    +                                                       raw_info,

    +                                                       NULL);

    +        sl_bt_esl_assert(sc == SL_STATUS_OK);

    +      }

    +      break;

    +

    +    default:

    +      break;

    +  }

    +}

    +

    +sl_status_t esl_display_refresh(uint8_t display_index, uint8_t *image_index)

    +{

    +  sl_status_t result = SL_STATUS_INVALID_INDEX;

    +

    +  if (display_index < display_registry.display_count) {

    +    esl_display_object_t  *active_display = &display_object[display_index];

    +

    +    // Invalid display object!

    +    sl_bt_esl_assert(NULL != active_display->write_image);

    +

    +    if (active_display->last_image != ESL_LAST_IMAGE_UNSET) {

    +      result = (*active_display->write_image)(ESL_DISPLAY_WRITE_FUNC_PARAMETERS_COUNT,

    +                                              display_index,

    +                                              active_display->last_image);

    +      if (image_index != NULL) {

    +        *image_index = (uint8_t)active_display->last_image;

    +      }

    +    } else {

    +      esl_core_set_last_error(ESL_ERROR_IMAGE_NOT_AVAILABLE);

    +    }

    +  } else {

    +    esl_core_set_last_error(ESL_ERROR_INVALID_PARAMETER);

    +  }

    +

    +  return result;

    +}

    +

    +sl_status_t esl_display_update(uint8_t display_index, uint8_t image_index)

    +{

    +  return esl_display_set_image(display_index, image_index);

    +}

    +

    +sl_status_t esl_display_create(uint16_t width,

    +                               uint16_t height,

    +                               esl_display_type_t type,

    +                               esl_display_info_p *info)

    +{

    +  sl_status_t result = SL_STATUS_NO_MORE_RESOURCE;

    +

    +  if (display_registry.display_count < ESL_TAG_MAX_DISPLAYS) {

    +    // select an available slot for object creation

    +    *info           = display_registry.next_object->info;

    +    (*info)->width  = width;

    +    (*info)->height = height;

    +    (*info)->type   = type;

    +    result          = SL_STATUS_OK;

    +  }

    +

    +  return result;

    +}

    +

    +sl_status_t esl_display_add(esl_display_info_p info,

    +                            esl_va_method_p init_func,

    +                            esl_va_method_p write_func)

    +{

    +  sl_status_t result = SL_STATUS_INVALID_STATE;

    +  esl_state_t state  = esl_core_get_status();

    +

    +  // ESL Display: write function is mandatory!

    +  sl_bt_esl_assert(NULL != write_func);

    +

    +  // ESL Display: adding displays after the boot event is disallowed!

    +  sl_bt_esl_assert(esl_state_boot == state);

    +

    +  if (state == esl_state_boot) {

    +    result = SL_STATUS_NO_MORE_RESOURCE;

    +

    +    if (display_registry.display_count < ESL_TAG_MAX_DISPLAYS) {

    +      display_registry.next_object->info        = info;

    +      display_registry.next_object->write_image = write_func;

    +

    +      if (init_func != NULL) {

    +        // call with current display index

    +        init_func(ESL_DISPLAY_INIT_FUNC_PARAMETERS_COUNT,

    +                  display_registry.display_count);

    +      }

    +

    +      // increase display count

    +      ++display_registry.display_count;

    +      // get next object

    +      ++display_registry.next_object;

    +      result = SL_STATUS_OK;

    +    } else {

    +      sl_bt_esl_log(ESL_LOG_COMPONENT_DISPLAY,

    +                    ESL_LOG_LEVEL_ERROR,

    +                    "Unable to add more display, ESL_TAG_MAX_DISPLAYS might be
    low.");

    +    }

    +  }

    +

    +  return result;

    +}

    +

    +sl_status_t esl_display_set_image(uint8_t display_index, uint8_t image_index)

    +{

    +  sl_status_t result = SL_STATUS_INVALID_INDEX;

    +

    +  if (display_index < display_registry.display_count) {

    +    esl_display_object_t  *active_display;

    +

    +    active_display = &display_object[display_index];

    +

    +    // Invalid display object!

    +    sl_bt_esl_assert(NULL != active_display->write_image);

    +

    +    result = (*active_display->write_image)(ESL_DISPLAY_WRITE_FUNC_PARAMETERS_COUNT,

    +                                            display_index, image_index);

    +    active_display->last_image = image_index;

    +  } else {

    +    esl_core_set_last_error(ESL_ERROR_INVALID_PARAMETER);

    +  }

    +

    +  return result;

    +}

    +

    +sl_status_t esl_display_get_width(uint8_t display_index, uint16_t *width)

    +{

    +  sl_status_t result = SL_STATUS_INVALID_INDEX;

    +

    +  if (display_index < display_registry.display_count) {

    +    esl_display_object_t  *active_display = &display_object[display_index];

    +    *width = active_display->info->width;

    +    result = SL_STATUS_OK;

    +  }

    +

    +  return result;

    +}

    +

    +sl_status_t esl_display_get_height(uint8_t display_index, uint16_t *height)

    +{

    +  sl_status_t result = SL_STATUS_INVALID_INDEX;

    +

    +  if (display_index < display_registry.display_count) {

    +    esl_display_object_t  *active_display = &display_object[display_index];

    +    *height = active_display->info->height;

    +    result = SL_STATUS_OK;

    +  }

    +

    +  return result;

    +}

    +

    +sl_status_t esl_display_get_type(uint8_t display_index,

    +                                 esl_display_type_t *type)

    +{

    +  sl_status_t result = SL_STATUS_INVALID_INDEX;

    +

    +  if (display_index < display_registry.display_count) {

    +    esl_display_object_t  *active_display = &display_object[display_index];

    +    *type = active_display->info->type;

    +    result = SL_STATUS_OK;

    +  }

    +

    +  return result;

    +}

    +

    +uint8_t esl_display_get_count()

    +{

    +  return display_registry.display_count;

    +}'
  - '--- a/app/bluetooth/common/esl_tag_led/src/esl_tag_led.c

    +++ b/app/bluetooth/common/esl_tag_led/src/esl_tag_led.c

    @@ -0,0 +1,560 @@

    +/***************************************************************************//**

    + * @file

    + * @brief ESL Tag LED component logic.

    + *******************************************************************************

    + * # License

    + * <b>Copyright 2021 Silicon Laboratories Inc. www.silabs.com</b>

    + *******************************************************************************

    + *

    + * SPDX-License-Identifier: Zlib

    + *

    + * The licensor of this software is Silicon Laboratories Inc.

    + *

    + * This software is provided ''as-is'', without any express or implied

    + * warranty. In no event will the authors be held liable for any damages

    + * arising from the use of this software.

    + *

    + * Permission is granted to anyone to use this software for any purpose,

    + * including commercial applications, and to alter it and redistribute it

    + * freely, subject to the following restrictions:

    + *

    + * 1. The origin of this software must not be misrepresented; you must not

    + *    claim that you wrote the original software. If you use this software

    + *    in a product, an acknowledgment in the product documentation would be

    + *    appreciated but is not required.

    + * 2. Altered source versions must be plainly marked as such, and must not be

    + *    misrepresented as being the original software.

    + * 3. This notice may not be removed or altered from any source distribution.

    + *

    + ******************************************************************************/

    +#include <stddef.h>

    +#include <stdint.h>

    +#include <stdbool.h>

    +#include "sl_sleeptimer.h"

    +#include "gatt_db.h"

    +#include "esl_tag_log.h"

    +#include "esl_tag_led.h"

    +#include "esl_tag_image_core.h"

    +#include "em_common.h"

    +

    +// An arbitrary big value to tell if a LED is currently inactive

    +#define ESL_LED_PATTERN_INACTIVE      UINT8_MAX

    +// Another arbitrary value to tell if a LED is continuously active

    +#define ESL_LED_PATTERN_IGNORED       0

    +// LED control pattern highest bit position by ESL Service specification

    +#define ESL_LED_PATTERN_MAX_MSB       39

    +

    +// Extended LED object type, containing additional function pointers and data

    +// for internal use

    +typedef struct {

    +  esl_led_type_t               *info;

    +  sl_sleeptimer_timer_handle_t timer_handle;

    +  uint32_t                     start_time;

    +  esl_led_control_t            control;

    +  uint8_t                      pattern_position;

    +} esl_led_object_t;

    +

    +// Internal LED registry type

    +typedef PACKSTRUCT (struct {

    +  esl_led_object_t  *next_object;

    +  uint8_t           led_count;

    +}) esl_led_registry_t;

    +

    +// LED info array - max. number of elements is defined in config header

    +static esl_led_type_t         led_info[ESL_TAG_MAX_LEDS];

    +

    +// LED object array for internal use

    +static esl_led_object_t       led_object[ESL_TAG_MAX_LEDS];

    +

    +// LED registry structure

    +static esl_led_registry_t     led_registry;

    +

    +/******************************************************************************

    + * Get LED information characteristic data

    + * Returns with all LED data in a format which can be easily write to the ESL

    + * LED Information characteristic.

    + * @param[out] uint8_t* size of the ESL LED info data

    + * @param[out] void** pointer to the serialized ESL LED Information data array

    + *****************************************************************************/

    +static inline void esl_led_get_all_info(uint16_t *data_size, void **out)

    +{

    +  *data_size = led_registry.led_count;

    +

    +  // having the characteristic with zero length of data is invalid!

    +  if (*data_size == 0) {

    +    // this is a ''user error'' condition, still the GATT request shall succeed

    +    // once the ESL access point tries to read it, thus we need at least one

    +    // LED to be reported even if this "shadow" LED itself won''t be functional

    +    // without a proper registration during the ESL boot event

    +    *data_size = sizeof(esl_led_type_t);

    +  }

    +

    +  *out = (void *)led_info;

    +}

    +

    +/******************************************************************************

    + * Find ESL LED state in control pattern at given position

    + *

    + * @param[in] control esl_led_control_t * type of pointer of the ESL LED control

    + *            block to check

    + * @param[in] position uint8_t bit position to check

    + *****************************************************************************/

    +static inline bool esl_led_get_pattern_state(esl_led_control_t* control,

    +                                             uint8_t position)

    +{

    +  uint8_t data_index   = position >> 3;   // fast division by 8

    +  uint8_t bit_index    = position & 0x07; // fast modulo 8

    +

    +  return (bool)(control->pattern.data[data_index] & (1 << bit_index));

    +}

    +

    +/******************************************************************************

    + * Find ESL LED control pattern most significant bit

    + *

    + * @param[in] control esl_led_control_t * type of pointer of the ESL LED control

    + *            block to analyze

    + *****************************************************************************/

    +static uint8_t esl_led_find_pattern_msb(esl_led_control_t* control)

    +{

    +  uint8_t msb_position = ESL_LED_PATTERN_MAX_MSB;

    +  uint8_t data_index   = msb_position >> 3;   // fast division by 8

    +  uint8_t bit_index    = msb_position & 0x07; // fast modulo 8

    +

    +  // search through the pattern data from "left to right" until the first

    +  // ''1'' is found according to ESL Service Specification v0.9

    +  // Section 3.10.2.10.2.2

    +  while ((msb_position <= ESL_LED_PATTERN_MAX_MSB)

    +         && !(control->pattern.data[data_index] & (1 << bit_index))) {

    +    data_index = --msb_position >> 3;

    +    bit_index  = msb_position & 0x07;

    +  }

    +

    +  return msb_position;

    +}

    +

    +/******************************************************************************

    + * ESL Tag internal LED on function.

    + * Calls out for public method @ref sl_esl_led_on, and handles internal registry

    + * status according to the result.

    + * @return sl_status_t

    + *****************************************************************************/

    +static sl_status_t esl_led_internal_led_on(uint8_t led_index,

    +                                           esl_led_gamut_control_t gamut)

    +{

    +  sl_status_t result = SL_STATUS_INVALID_INDEX;

    +

    +  if (led_index < led_registry.led_count) {

    +    // call the user method responsible to physically turn on the LED

    +    result = esl_led_on(led_index, gamut);

    +

    +    // according to the result, adjust internal database

    +    if (result == SL_STATUS_OK) {

    +      esl_led_type_t type = led_info[led_index] & ESL_LED_TYPE_MASK;

    +

    +      // implements ESL Service Spec. d09r18, Section 3.10.3.3.1

    +      esl_core_set_basic_state_bit(ESL_BASIC_STATE_ACTIVE_LED_BIT, ESL_SET);

    +

    +      if (type == ESL_LED_TYPE_SRGB) {

    +        esl_led_type_t new_info = 0;

    +

    +        // get red color component

    +        new_info |= esl_led_get_red_value(gamut) << ESL_LED_RED_GAMUT_SHIFT;

    +

    +        // get green color component

    +        new_info |= esl_led_get_green_value(gamut) << ESL_LED_GREEN_GAMUT_SHIFT;

    +

    +        // get blue color component

    +        new_info |= esl_led_get_blue_value(gamut) << ESL_LED_BLUE_GAMUT_SHIFT;

    +

    +        // put all together after bit manipulation

    +        type |= new_info;

    +

    +        // keep ESL LED characteristic data up-to date

    +        led_info[led_index] = type;

    +      }

    +    } else {

    +      sl_bt_esl_log(ESL_LOG_COMPONENT_LED,

    +                    ESL_LOG_LEVEL_WARNING,

    +                    "ESL LED couldn''t be turned on.");

    +    }

    +  } else {

    +    sl_bt_esl_log(ESL_LOG_COMPONENT_LED,

    +                  ESL_LOG_LEVEL_WARNING,

    +                  "ESL LED index out of bounds!");

    +  }

    +

    +  return result;

    +}

    +

    +/******************************************************************************

    + * ESL Tag internal LED off function.

    + * Calls out for public method @ref sl_esl_led_off, and handles internal

    + * registry status according to the result.

    + * @return sl_status_t

    + *****************************************************************************/

    +static sl_status_t esl_led_internal_led_off(uint8_t led_index)

    +{

    +  sl_status_t result = SL_STATUS_INVALID_INDEX;

    +

    +  if (led_index < led_registry.led_count) {

    +    // call the user method responsible to physically turn on the LED

    +    result = esl_led_off(led_index);

    +

    +    // according to the result, adjust internal database

    +    if (result == SL_STATUS_OK) {

    +      bool has_active = false;

    +      uint8_t index   = 0;

    +

    +      // implements ESL Service Spec. d09r18, Section 3.10.3.3.1

    +      for (; !has_active && index < led_registry.led_count; index++) {

    +        bool current_is_active =

    +          (led_object[index].pattern_position <= ESL_LED_PATTERN_MAX_MSB);

    +

    +        has_active = has_active || current_is_active;

    +      }

    +

    +      if (!has_active) {

    +        esl_core_set_basic_state_bit(ESL_BASIC_STATE_ACTIVE_LED_BIT, ESL_CLEAR);

    +      }

    +    } else {

    +      sl_bt_esl_log(ESL_LOG_COMPONENT_LED,

    +                    ESL_LOG_LEVEL_WARNING,

    +                    "LED couldn''t be turned off.");

    +    }

    +  } else {

    +    sl_bt_esl_log(ESL_LOG_COMPONENT_LED,

    +                  ESL_LOG_LEVEL_WARNING,

    +                  "LED index out of bounds!");

    +  }

    +

    +  return result;

    +}

    +

    +/******************************************************************************

    + * ESL Tag internal LED control timer callback.

    + * Implements the expected prototype of the user''s callback function for

    + * sleeptimer which is called when the timer expires.

    + * Called in interrupt context.

    + *

    + * @param[in] timer Pointer to the timer handle.

    + * @param[in] data  Extra parameter: an (esl_led_object_t *) pointer to the

    + *            actual LED under control

    + *****************************************************************************/

    +static void esl_led_timer_callback(sl_sleeptimer_timer_handle_t *timer,

    +                                   void *data)

    +{

    +  esl_led_object_t *led = (esl_led_object_t *)data;

    +  uint32_t         time = 0;

    +  bool             lit  = false;

    +

    +  // ESL LED timer callback: improper use, *data can''t be NULL!

    +  sl_bt_esl_assert(led != NULL);

    +

    +  --(led->pattern_position);

    +

    +  // check repeat type

    +  if ((led->control.repeats & ESL_LED_REPEATS_TYPE_MASK) == ESL_LED_REPEATS_TYPE_COUNT)
    {

    +    esl_led_repeats_type_t repeat_count;

    +

    +    repeat_count = (led->control.repeats & (esl_led_repeats_type_t)(~ESL_LED_REPEATS_TYPE_MASK))

    +                   >> ESL_LED_REPEATS_DURATION_SHIFT;

    +    // check if the last bit of the pattern was just executed

    +    if (led->pattern_position > ESL_LED_PATTERN_MAX_MSB && repeat_count != 0)
    {

    +      --repeat_count;

    +      // after lowering the repeat count, store it in the control block

    +      led->control.repeats = (repeat_count << ESL_LED_REPEATS_DURATION_SHIFT)

    +                             | (ESL_LED_REPEATS_TYPE_MASK & ESL_LED_REPEATS_TYPE_COUNT);

    +      led->pattern_position = esl_led_find_pattern_msb(&led->control);

    +    }

    +

    +    if (repeat_count != 0 && esl_core_get_status() != esl_state_unassociated)
    {

    +      esl_led_control_t *control = &led->control;

    +

    +      lit  = esl_led_get_pattern_state(control, led->pattern_position);

    +      time = lit ? control->pattern.bit_on_period : control->pattern.bit_off_period;

    +      time = time << 1;

    +    } else {

    +      // repeat count reached or the Tag has been unassociated in the meanwhile

    +      led->pattern_position = ESL_LED_PATTERN_INACTIVE;

    +      time = 0;

    +      lit  = false;

    +    }

    +  } else {

    +    sl_status_t status;

    +    uint32_t    current_time;

    +    uint32_t    elapsed_time;

    +    uint64_t    ms64 = 0;

    +    uint64_t    current_tick = sl_sleeptimer_get_tick_count64();

    +

    +    status = sl_sleeptimer_tick64_to_ms(current_tick, &ms64);

    +

    +    if (status == SL_STATUS_OK) {

    +      esl_led_control_t *control  = &led->control;

    +      // the unit of the duration value is [sec] by ESL Service specification

    +      uint32_t          duration  = led->control.repeats >> ESL_LED_REPEATS_DURATION_SHIFT;

    +      // get initial remaining time in [ms] from the requested duration value

    +      uint32_t          remaining = 1000u * (uint32_t)duration;

    +

    +      current_time = (uint32_t)ms64;

    +      // calculate elapsed time since switched on for the very first time

    +      elapsed_time = (uint32_t)(current_time - led->start_time);

    +

    +      // handle underflow condition

    +      if (led->pattern_position > ESL_LED_PATTERN_MAX_MSB) {

    +        led->pattern_position = esl_led_find_pattern_msb(&led->control);

    +      }

    +

    +      // check if we need to continue at all

    +      if (elapsed_time < remaining) {

    +        lit  = esl_led_get_pattern_state(control, led->pattern_position);

    +        time = lit ? control->pattern.bit_on_period : control->pattern.bit_off_period;

    +        time = time << 1;

    +

    +        // adjust remaining time

    +        remaining -= elapsed_time;

    +        if (time > remaining) {

    +          // start timer (later on, see at the end) only for true remaining time

    +          time = remaining;

    +        }

    +      } else {

    +        // requested duration already ended

    +        led->pattern_position = ESL_LED_PATTERN_INACTIVE;

    +        time = 0;

    +        lit  = false;

    +      }

    +    } else {

    +      // this is an error case e.g. when the ESL Tag has been unassociated while

    +      // an LED control was in progress!

    +      led->pattern_position = ESL_LED_PATTERN_INACTIVE;

    +      time = 0;

    +      lit  = false;

    +    }

    +  }

    +

    +  if (time != 0) {

    +    (void)sl_sleeptimer_start_timer_ms(timer,

    +                                       time,

    +                                       &esl_led_timer_callback,

    +                                       led,

    +                                       (uint8_t)INT8_MAX,

    +                                       SL_SLEEPTIMER_NO_HIGH_PRECISION_HF_CLOCKS_REQUIRED_FLAG);

    +  } else {

    +    // override the lit value if the timer does not need to be started, thus

    +    // avoiding the LED being ever stuck in the on state (that is, to avoid

    +    // a sudden battery drain)

    +    led->pattern_position = ESL_LED_PATTERN_INACTIVE;

    +    lit = false;

    +  }

    +

    +  if (lit) {

    +    (void)esl_led_internal_led_on(led->control.index, led->control.gamut);

    +  } else {

    +    (void)esl_led_internal_led_off(led->control.index);

    +  }

    +}

    +

    +void esl_led_init(void)

    +{

    +  uint8_t i;

    +  // clear all display data

    +  memset(led_info, 0, sizeof(led_info));

    +  memset(led_object, 0, sizeof(led_object));

    +

    +  // 1:1 assign every led_info to the corresponding led_objects

    +  for (i = 0; i < ESL_TAG_MAX_LEDS; ++i) {

    +    led_object[i].info = &led_info[i];

    +    // initialize pattern position index

    +    led_object[i].pattern_position = ESL_LED_PATTERN_INACTIVE;

    +  }

    +  // initialize zero led count, prepare led creation / allocation

    +  led_registry.next_object = led_object;

    +  led_registry.led_count   = 0;

    +}

    +

    +void esl_led_bt_on_event(sl_bt_msg_t *evt)

    +{

    +  switch (SL_BT_MSG_ID(evt->header)) {

    +    case sl_bt_evt_gatt_server_user_read_request_id:

    +      if (evt->data.evt_gatt_server_user_read_request.characteristic == gattdb_esl_led_info)
    {

    +        uint8_t*  raw_info;

    +        uint16_t  raw_size, offset;

    +        uint16_t  mtu_size;

    +        sl_status_t sc;

    +        (void)sc; // suppress the compiler warning if sl_bt_esl_assert disabled

    +

    +        // get pointer first to the beginning of the display_info packed struct

    +        esl_led_get_all_info(&raw_size, (void *)&raw_info);

    +        // then get the offset value from the request

    +        offset = evt->data.evt_gatt_server_user_read_request.offset;

    +        // finally, adjust offset and size

    +        raw_info += offset;

    +        raw_size -= offset;

    +

    +        // check current ATT_MTU limits

    +        sc = sl_bt_gatt_server_get_mtu(evt->data.evt_gatt_server_user_read_request.connection,
    &mtu_size);

    +        sl_bt_esl_assert(sc == SL_STATUS_OK);

    +

    +        // sl_bt_gatt_server_send_user_read_response allows (ATT_MTU - 1) size

    +        --mtu_size; // of data to be sent at once!

    +

    +        // and limit the actual data size to be sent accordingly

    +        raw_size = raw_size > mtu_size ? mtu_size : raw_size;

    +

    +        // send data (chunk, maybe more read reqs. with offset != 0 will follow)

    +        sc = sl_bt_gatt_server_send_user_read_response(evt->data.evt_gatt_server_user_read_request.connection,

    +                                                       evt->data.evt_gatt_server_user_read_request.characteristic,

    +                                                       SL_STATUS_OK,

    +                                                       raw_size,

    +                                                       raw_info,

    +                                                       NULL);

    +        sl_bt_esl_assert(sc == SL_STATUS_OK);

    +      }

    +      break;

    +

    +    default:

    +      break;

    +  }

    +}

    +

    +sl_status_t esl_led_add(esl_led_type_t type,

    +                        uint8_t red_value,

    +                        uint8_t green_value,

    +                        uint8_t blue_value)

    +{

    +  sl_status_t result = SL_STATUS_INVALID_STATE;

    +  esl_state_t state  = esl_core_get_status();

    +

    +  // ESL LED: adding LED after the boot event is disallowed!

    +  sl_bt_esl_assert(esl_state_boot == state);

    +

    +  if (state == esl_state_boot) {

    +    result = SL_STATUS_NO_MORE_RESOURCE;

    +

    +    if (led_registry.led_count < ESL_TAG_MAX_LEDS) {

    +      esl_led_type_t new_led = type & ESL_LED_TYPE_MASK;

    +      // assemble the led info for this new led

    +

    +      new_led |= (red_value & ESL_LED_GENERIC_2BIT_MASK) << ESL_LED_RED_GAMUT_SHIFT;

    +      new_led |= (green_value & ESL_LED_GENERIC_2BIT_MASK) << ESL_LED_GREEN_GAMUT_SHIFT;

    +      new_led |= (blue_value & ESL_LED_GENERIC_2BIT_MASK) << ESL_LED_BLUE_GAMUT_SHIFT;

    +

    +      *(led_registry.next_object->info) = new_led;

    +

    +      // increase LED count

    +      ++led_registry.led_count;

    +      // get next object

    +      ++led_registry.next_object;

    +      result = SL_STATUS_OK;

    +    } else {

    +      sl_bt_esl_log(ESL_LOG_COMPONENT_LED,

    +                    ESL_LOG_LEVEL_ERROR,

    +                    "Unable to add more LED, ESL_TAG_MAX_LEDS might be low.");

    +    }

    +  }

    +

    +  return result;

    +}

    +

    +sl_status_t esl_led_control(esl_led_control_t *control_param)

    +{

    +  esl_led_gamut_control_t gamut  = control_param->gamut;

    +  uint8_t                 index  = control_param->index;

    +  sl_status_t             result = SL_STATUS_INVALID_INDEX;

    +

    +  if (index < led_registry.led_count) {

    +    esl_led_object_t             *current_led  = &led_object[index];

    +    sl_sleeptimer_timer_handle_t *timer_handle = &(current_led->timer_handle);

    +

    +    // do default actions in the first place: override previous LED control

    +    (void)sl_sleeptimer_stop_timer(timer_handle);   // ignore return status

    +    current_led->pattern_position = ESL_LED_PATTERN_INACTIVE;

    +

    +    // handle simple LED off command as per ESL Specification v0.9

    +    // Section 3.10.2.10.4

    +    if (control_param->repeats == 0) {

    +      result = esl_led_internal_led_off(control_param->index);

    +    } else {

    +      uint64_t current_tick = sl_sleeptimer_get_tick_count64();

    +      uint64_t ms64         = 0;

    +

    +      result = sl_sleeptimer_tick64_to_ms(current_tick, &ms64);

    +      // handle simple LED on command as per ESL Specification v0.9

    +      // Section 3.10.2.10.2.4

    +      if (control_param->repeats == ESL_LED_REPEATS_TYPE_MASK) {

    +        // handle the special case

    +        current_led->pattern_position = ESL_LED_PATTERN_IGNORED;

    +        // save current internal time if available, ignore any possible error

    +        current_led->start_time = (uint32_t)ms64;

    +        // this will let us enable the led in the end

    +        result = SL_STATUS_OK;

    +      } else if (!control_param->pattern.bit_on_period

    +                 || !control_param->pattern.bit_off_period) {

    +        // handle the error case defined in ESL Service Specification v0.9,

    +        // Section 3.10.2.10.2.2

    +        result = SL_STATUS_INVALID_PARAMETER;

    +        // the following call will override the default error response

    +        esl_core_set_last_error(ESL_ERROR_INVALID_PARAMETER);

    +      } else if (result == SL_STATUS_OK) {

    +        current_led->start_time = (uint32_t)ms64;

    +        current_led->control    = *control_param;   // shallow copy is just fine

    +        current_led->pattern_position = esl_led_find_pattern_msb(control_param);

    +

    +        if (current_led->pattern_position <= ESL_LED_PATTERN_MAX_MSB) {

    +          result = sl_sleeptimer_start_timer_ms(timer_handle,

    +                                                (control_param->pattern.bit_on_period
    << 1),

    +                                                &esl_led_timer_callback,

    +                                                (void *)current_led,

    +                                                (uint8_t)INT8_MAX,

    +                                                SL_SLEEPTIMER_NO_HIGH_PRECISION_HF_CLOCKS_REQUIRED_FLAG);

    +

    +          if (result != SL_STATUS_OK) {

    +            // set insufficient resources if the timer couldn''t be started

    +            esl_core_set_last_error(ESL_ERROR_INSUFFICIENT_RESOURCES);

    +          }

    +        } else {

    +          // set invalid parameter response if the pattern is all zero

    +          esl_core_set_last_error(ESL_ERROR_INVALID_PARAMETER);

    +        }

    +      }

    +

    +      if (result == SL_STATUS_OK) {

    +        result = esl_led_internal_led_on(control_param->index, gamut);

    +      }

    +    }

    +

    +    if (result != SL_STATUS_OK) {

    +      // default error response for any unknown error (if not yet set)

    +      esl_core_set_last_error(ESL_ERROR_UNSPECIFIED);

    +    }

    +  } else {

    +    esl_core_set_last_error(ESL_ERROR_INVALID_PARAMETER);

    +  }

    +

    +  return result;

    +}

    +

    +uint8_t esl_led_get_count()

    +{

    +  return led_registry.led_count;

    +}

    +

    +bool esl_led_is_srgb(uint8_t led_index)

    +{

    +  return (led_index < led_registry.led_count

    +          && (led_info[led_index] & ESL_LED_TYPE_MASK) == ESL_LED_TYPE_SRGB);

    +}

    +

    +SL_WEAK sl_status_t esl_led_on(uint8_t led_index, esl_led_gamut_control_t gamut)

    +{

    +  (void)led_index;

    +  (void)gamut;

    +

    +  return SL_STATUS_FAIL;

    +}

    +

    +SL_WEAK sl_status_t esl_led_off(uint8_t led_index)

    +{

    +  (void)led_index;

    +

    +  return SL_STATUS_FAIL;

    +}'
  - '--- a/app/bluetooth/common/esl_tag_nvm_image/src/esl_tag_nvm_image.c

    +++ b/app/bluetooth/common/esl_tag_nvm_image/src/esl_tag_nvm_image.c

    @@ -0,0 +1,416 @@

    +/***************************************************************************//**

    + * @file

    + * @brief ESL Tag NVM Image logic.

    + *******************************************************************************

    + * # License

    + * <b>Copyright 2021 Silicon Laboratories Inc. www.silabs.com</b>

    + *******************************************************************************

    + *

    + * SPDX-License-Identifier: Zlib

    + *

    + * The licensor of this software is Silicon Laboratories Inc.

    + *

    + * This software is provided ''as-is'', without any express or implied

    + * warranty. In no event will the authors be held liable for any damages

    + * arising from the use of this software.

    + *

    + * Permission is granted to anyone to use this software for any purpose,

    + * including commercial applications, and to alter it and redistribute it

    + * freely, subject to the following restrictions:

    + *

    + * 1. The origin of this software must not be misrepresented; you must not

    + *    claim that you wrote the original software. If you use this software

    + *    in a product, an acknowledgment in the product documentation would be

    + *    appreciated but is not required.

    + * 2. Altered source versions must be plainly marked as such, and must not be

    + *    misrepresented as being the original software.

    + * 3. This notice may not be removed or altered from any source distribution.

    + *

    + ******************************************************************************/

    +#include <stddef.h>

    +#include <string.h>

    +#include "esl_tag_image_config.h"

    +#include "esl_tag_ots_server.h"

    +#include "esl_tag_image_core.h"

    +#include "esl_tag_errors.h"

    +#include "esl_tag_image.h"

    +#include "esl_tag_core.h"

    +#include "esl_tag_log.h"

    +#include "em_common.h"

    +#include "gatt_db.h"

    +#include "nvm3.h"

    +#include "nvm3_hal_flash.h"

    +#include "nvm3_default_config.h"

    +

    +// Size of single image chunk

    +#define NVM_IMAGE_CHUNK_SIZE        (NVM3_DEFAULT_MAX_OBJECT_SIZE \

    +                                     - sizeof(nvm3_ObjectKey_t))

    +// NVM storage handle

    +#define NVM3_ESL_IMAGE_HANDLE       nvm3_defaultHandle

    +// NVM3 region to be used to store ESL image data

    +#define ESL_IMAGE_NVM3_REGION_BEGIN (0x04000)

    +

    +// Maximum number image chunks that can be stored in ESL image data NVM region

    +#define ESL_IMAGE_MAX_OBJECT_COUNT  (0x02000)

    +

    +// NVM3 region end of ESL image data storage space

    +#define ESL_IMAGE_NVM3_REGION_END   (ESL_IMAGE_NVM3_REGION_BEGIN \

    +                                     + ESL_IMAGE_MAX_OBJECT_COUNT)

    +

    +// NVM image object storage type

    +typedef PACKSTRUCT (struct {

    +  uint16_t          max_size;

    +  uint16_t          size;

    +  nvm3_ObjectKey_t  first_nvm_obj_key;

    +}) esl_image_object_t;

    +

    +// NVM image - single image chunk type

    +typedef PACKSTRUCT (struct {

    +  nvm3_ObjectKey_t  next_nvm_obj_key;

    +  uint8_t           nvm_data[NVM_IMAGE_CHUNK_SIZE];

    +}) esl_image_chunk_t;

    +

    +// Internal NVM image registry type

    +typedef PACKSTRUCT (struct {

    +  esl_image_object_t  *active_image;

    +  nvm3_ObjectKey_t    next_nvm_object_key;

    +  uint16_t            pending_write;

    +  uint8_t             images_count;

    +}) esl_image_registry_t;

    +

    +// Image registry structure

    +static esl_image_registry_t image_registry = { 0 };

    +

    +// Image object array - max. number of elements is defined in config header

    +static esl_image_object_t   image_object[ESL_TAG_MAX_IMAGES] = { 0 };

    +

    +// NVM image chunk buffer

    +static esl_image_chunk_t    image_chunk_buffer;

    +

    +void esl_image_receive_finished(void)

    +{

    +  esl_image_object_t *active_image = image_registry.active_image;

    +

    +  if (active_image != NULL && image_registry.pending_write != 0) {

    +    Ecode_t nvm_status;

    +    nvm3_ObjectKey_t target_key = image_chunk_buffer.next_nvm_obj_key;

    +

    +    image_chunk_buffer.next_nvm_obj_key = 0;

    +    nvm_status = nvm3_writeData(NVM3_ESL_IMAGE_HANDLE,

    +                                target_key,

    +                                &image_chunk_buffer,

    +                                image_registry.pending_write + sizeof(nvm3_ObjectKey_t));

    +

    +    if (nvm_status == ECODE_NVM3_OK) {

    +      image_registry.pending_write = 0;

    +    } else {

    +      sl_bt_esl_log(ESL_LOG_COMPONENT_NVM_IMAGE,

    +                    ESL_LOG_LEVEL_ERROR,

    +                    "ESL NVM Image: NVM operation failed with status 0x%lx!",

    +                    nvm_status);

    +    }

    +  }

    +}

    +

    +sl_status_t esl_image_chunk_received(uint8_t const *data,

    +                                     uint16_t length)

    +{

    +  sl_status_t result  = SL_STATUS_INVALID_INDEX;

    +  esl_image_object_t *active_image = image_registry.active_image;

    +

    +  // ESL NVM image: data must fit to NVM object. Please check NVM config!

    +  sl_bt_esl_assert(length <= NVM_IMAGE_CHUNK_SIZE);

    +

    +  // if there''s a valid image object selected

    +  if (active_image != NULL) {

    +    // check for overflow condition

    +    if ((active_image->size + length) > active_image->max_size) {

    +      sl_bt_esl_log(ESL_LOG_COMPONENT_NVM_IMAGE,

    +                    ESL_LOG_LEVEL_ERROR,

    +                    "Image size overflow!");

    +      // invalidate the image in this case by clearing it''s size

    +      active_image->size = 0;

    +      // return the error

    +      result = SL_STATUS_WOULD_OVERFLOW;

    +    } else {

    +      // store the data, otherwise

    +      uint32_t data_index   = active_image->size % NVM_IMAGE_CHUNK_SIZE;

    +      uint32_t outrun_bytes = (NVM_IMAGE_CHUNK_SIZE < (data_index + length))

    +                              ? (data_index + length) % NVM_IMAGE_CHUNK_SIZE

    +                              : 0;

    +      length -= outrun_bytes;

    +

    +      memcpy(&(image_chunk_buffer.nvm_data[data_index]), data, length);

    +      active_image->size           += length;

    +      image_registry.pending_write += length;

    +

    +      result = SL_STATUS_OK;

    +      // check for NVM write conditions:

    +      if (outrun_bytes != 0 || image_registry.pending_write == NVM_IMAGE_CHUNK_SIZE)
    {

    +        Ecode_t nvm_status;

    +        // select target object key, increase object ID in buffer for later use

    +        nvm3_ObjectKey_t target_key = image_chunk_buffer.next_nvm_obj_key++;

    +

    +        // check if this is the last expected image chunk - if it is, then

    +        // close our "poor man''s linked list" by setting next key to zero

    +        if (active_image->size == active_image->max_size) {

    +          image_chunk_buffer.next_nvm_obj_key = 0;

    +          // improve OTS response by not sending credit after the slot is full

    +          result = SL_STATUS_FULL;

    +        }

    +

    +        nvm_status = nvm3_writeData(NVM3_ESL_IMAGE_HANDLE,

    +                                    target_key,

    +                                    &image_chunk_buffer,

    +                                    sizeof(image_chunk_buffer));

    +

    +        // if there were more bytes received than the size of one image chunk

    +        // then adjust buffer and registry data accordingly, save data to buffer

    +        if (nvm_status == ECODE_NVM3_OK) {

    +          image_registry.pending_write = outrun_bytes;

    +          memcpy(image_chunk_buffer.nvm_data, &data[length], outrun_bytes);

    +          active_image->size += outrun_bytes;

    +        } else {

    +          result = SL_STATUS_FAIL;

    +          sl_bt_esl_log(ESL_LOG_COMPONENT_NVM_IMAGE,

    +                        ESL_LOG_LEVEL_ERROR,

    +                        "ESL NVM Image: NVM operation failed with status 0x%lx!",

    +                        nvm_status);

    +        }

    +      }

    +    }

    +  }

    +

    +  return result;

    +}

    +

    +sl_status_t esl_image_select_object(void const *data, uint16_t length)

    +{

    +  // in case of size mismatch, this is the default answer:

    +  sl_status_t    result     = SL_STATUS_INVALID_HANDLE;

    +  const uint16_t valid_size = sizeof(esl_image_object_id_t);

    +

    +  // select null object by default (in case of error)

    +  image_registry.active_image = NULL;

    +

    +  if (length == valid_size) {

    +    if (*(uint16_t *)data < ESL_IMAGE_OBJECT_BASE) {

    +      // invalid Object ID (wrong base?)

    +      result = SL_STATUS_INVALID_PARAMETER;

    +    } else if (*(uint8_t *)data >= image_registry.images_count) {

    +      // image index is out of bounds

    +      result = SL_STATUS_INVALID_INDEX;

    +    } else {

    +      // select active image storage for the upcoming data transfer

    +      image_registry.active_image = &image_object[*(uint8_t *)data];

    +      // there''s no temporary storage -> initiating image transfer by this

    +      // selection it will destroy the previous image content (if any)

    +      image_registry.active_image->size = 0;

    +      image_registry.pending_write      = 0;

    +      // prepare buffer for the transfer

    +      image_chunk_buffer.next_nvm_obj_key = image_registry.active_image->first_nvm_obj_key;

    +      result = SL_STATUS_OK;

    +    }

    +  }

    +

    +  return result;

    +}

    +

    +void esl_image_init(void)

    +{

    +  Ecode_t status = nvm3_open(NVM3_ESL_IMAGE_HANDLE, nvm3_defaultInit);

    +

    +  if (ECODE_NVM3_OK == status) {

    +    size_t numberOfObjects;

    +

    +    // Get the number of valid image chunk keys already in NVM3

    +    const nvm3_ObjectKey_t MAX_KEY = ESL_IMAGE_NVM3_REGION_END - 1;

    +    nvm3_ObjectKey_t       current_key;

    +

    +    // Skip if we don''t have image chunks at all

    +    while ((numberOfObjects = nvm3_enumObjects(NVM3_ESL_IMAGE_HANDLE,

    +                                               &current_key, 1,

    +                                               ESL_IMAGE_NVM3_REGION_BEGIN,

    +                                               MAX_KEY))) {

    +      // Clear all images data, ESL Profile specification d09r18, Section 3.2

    +      (void)nvm3_deleteObject(NVM3_ESL_IMAGE_HANDLE, current_key);

    +    }

    +

    +    if (nvm3_repackNeeded(NVM3_ESL_IMAGE_HANDLE)) {

    +      (void)nvm3_repack(NVM3_ESL_IMAGE_HANDLE);

    +    }

    +  } else {

    +    sl_bt_esl_log(ESL_LOG_COMPONENT_NVM_IMAGE,

    +                  ESL_LOG_LEVEL_ERROR,

    +                  "ESL NVM Image: initialization failure!");

    +  }

    +

    +  // initialize zero images count, set max. available size for image allocation

    +  image_registry.active_image         = NULL;

    +  image_registry.next_nvm_object_key  = ESL_IMAGE_NVM3_REGION_BEGIN;

    +  image_registry.images_count         = 0;

    +  image_registry.pending_write        = 0;

    +}

    +

    +void esl_image_characteristic_update(void)

    +{

    +  sl_status_t sc;

    +  uint8_t gatt_data = image_registry.images_count;// ESL Serv.spec. 3.7.1

    +

    +  // gattdb_esl_image_info shall contain Max_Image_Index, not the image count!

    +  if (gatt_data > 0) {

    +    gatt_data -= 1;

    +  }

    +

    +  sc = sl_bt_gatt_server_write_attribute_value(gattdb_esl_image_info,

    +                                               0,

    +                                               sizeof(gatt_data),

    +                                               &gatt_data);

    +  sl_bt_esl_assert(sc == SL_STATUS_OK);

    +}

    +

    +sl_status_t esl_image_add(uint16_t width, uint16_t height,

    +                          uint8_t bits_per_pixel)

    +{

    +  sl_status_t result = SL_STATUS_INVALID_STATE;

    +  esl_state_t state  = esl_core_get_status();

    +

    +  // ESL Image: adding images after ESL boot event is disallowed!

    +  sl_bt_esl_assert(esl_state_boot == state);

    +

    +  if (state == esl_state_boot) {

    +    result = SL_STATUS_NO_MORE_RESOURCE;

    +

    +    // Refuse to add any new image if the max images count is reached!

    +    if (image_registry.images_count < ESL_TAG_MAX_IMAGES) {

    +      // get image size in bytes

    +      uint32_t  size      = (bits_per_pixel * width * height) / 8;

    +      // calculate chunks count needed to store the whole image in NVM

    +      uint32_t  chunks    = (size / NVM_IMAGE_CHUNK_SIZE)

    +                            + (size % NVM_IMAGE_CHUNK_SIZE ? 1 : 0);

    +      // get remaining objects count

    +      uint32_t  available = ESL_IMAGE_MAX_OBJECT_COUNT

    +                            + ESL_IMAGE_NVM3_REGION_BEGIN

    +                            - image_registry.next_nvm_object_key;

    +

    +      result = SL_STATUS_ALLOCATION_FAILED;

    +

    +      if (chunks <= available) {

    +        uint8_t new_image_index = image_registry.images_count;

    +        const sl_bt_ots_object_type_t* type;

    +        // currently, there are only two types of images available

    +        type = bits_per_pixel == 1 ? &esl_image_type_1b : &esl_image_type_2b;

    +

    +        // store maximum size of the image object

    +        image_object[new_image_index].max_size = (uint16_t)size;

    +        // set actual size to zero, initially

    +        image_object[new_image_index].size     = 0;

    +        // allocate raw data pointer in the pool

    +        image_object[new_image_index].first_nvm_obj_key = image_registry.next_nvm_object_key;

    +        // finish registration

    +        ++image_registry.images_count;

    +        image_registry.next_nvm_object_key += chunks;

    +        result = esl_tag_ots_add_object(type, size, ESL_OTS_IMAGE_OBJECT);

    +      } else {

    +        sl_bt_esl_log(ESL_LOG_COMPONENT_NVM_IMAGE,

    +                      ESL_LOG_LEVEL_ERROR,

    +                      "Unable to add image due size constraints.");

    +      }

    +    } else {

    +      sl_bt_esl_log(ESL_LOG_COMPONENT_NVM_IMAGE,

    +                    ESL_LOG_LEVEL_ERROR,

    +                    "Unable to add more images, ESL_TAG_MAX_IMAGES might be low.");

    +    }

    +  }

    +

    +  return result;

    +}

    +

    +sl_status_t esl_image_get_data(uint8_t image_index, uint16_t* offset,

    +                               uint16_t buf_size, uint8_t *target_buf)

    +{

    +  sl_status_t result = SL_STATUS_INVALID_INDEX;

    +

    +  // check if given index points to a registered image

    +  if (image_index < image_registry.images_count) {

    +    Ecode_t nvm_status;

    +    esl_image_object_t *image = &image_object[image_index];

    +

    +    // calculate the remaining size to read

    +    uint16_t          remaining_size = image->size - *offset;

    +    // calculate the source key to read from

    +    nvm3_ObjectKey_t  source_key     = (*offset / NVM_IMAGE_CHUNK_SIZE)

    +                                       + image->first_nvm_obj_key;

    +    uint16_t          source_offset  = (*offset % NVM_IMAGE_CHUNK_SIZE)

    +                                       + sizeof(nvm3_ObjectKey_t);

    +

    +    // check if image has valid data

    +    if (image->size == 0) {

    +      esl_core_set_last_error(ESL_ERROR_IMAGE_NOT_AVAILABLE);

    +      return SL_STATUS_NOT_AVAILABLE;

    +    } else if (*offset > image->size) {

    +      // else check if offset is out of bounds

    +      esl_core_set_last_error(ESL_ERROR_UNSPECIFIED);

    +      return SL_STATUS_ABORT;

    +    } else if (*offset == image->size) {

    +      // else check an edge case: read to be finished just right now

    +      return SL_STATUS_OK;

    +    } else if (remaining_size > buf_size) {

    +      // or adjust remaining size to the buffer size on success

    +      remaining_size = buf_size;

    +    }

    +

    +    result = SL_STATUS_OK;

    +

    +    // if there''s still data to read

    +    while (remaining_size != 0 && result == SL_STATUS_OK) {

    +      uint32_t size_to_read = remaining_size;

    +

    +      // check if byte count to be read is available under the current key, only

    +      if ((source_offset + size_to_read) > NVM3_DEFAULT_MAX_OBJECT_SIZE) {

    +        size_to_read = NVM3_DEFAULT_MAX_OBJECT_SIZE - source_offset;

    +      }

    +      // get data chunk(s) from NVM to the buffer

    +

    +      nvm_status = nvm3_readPartialData(NVM3_ESL_IMAGE_HANDLE,

    +                                        source_key,

    +                                        target_buf,

    +                                        source_offset,

    +                                        size_to_read);

    +      // shift target pointer

    +      target_buf     += size_to_read;

    +      // shift the offset

    +      *offset        += size_to_read;

    +      // calculate remaining

    +      remaining_size -= size_to_read;

    +      // get next key

    +      source_key++;

    +      // set the source offset (skip forward link)

    +      source_offset = sizeof(nvm3_ObjectKey_t);

    +      // set result according to NVM status

    +      result = ECODE_NVM3_OK == nvm_status ? SL_STATUS_OK : SL_STATUS_FAIL;

    +    }

    +  } else {

    +    // signal invalid index to the remote ESL Access Point

    +    esl_core_set_last_error(ESL_ERROR_INVALID_IMAGE_INDEX);

    +  }

    +

    +  return result;

    +}

    +

    +uint8_t esl_image_get_count()

    +{

    +  return image_registry.images_count;

    +}

    +

    +void esl_image_reset_storage(void)

    +{

    +  uint8_t image_index = image_registry.images_count;

    +

    +  while (image_index--) {

    +    // get every image objects one by one

    +    esl_image_object_t *image = &image_object[image_index];

    +    // invalidate data content by clearing the size

    +    image->size = 0;

    +  }

    +}'
  - '--- a/app/bluetooth/common/esl_tag_ots_server/src/esl_tag_ots_server.c

    +++ b/app/bluetooth/common/esl_tag_ots_server/src/esl_tag_ots_server.c

    @@ -0,0 +1,459 @@

    +/***************************************************************************//**

    + * @file

    + * @brief Core ESL Tag Object Transfer Service logic.

    + *******************************************************************************

    + * # License

    + * <b>Copyright 2022 Silicon Laboratories Inc. www.silabs.com</b>

    + *******************************************************************************

    + *

    + * SPDX-License-Identifier: Zlib

    + *

    + * The licensor of this software is Silicon Laboratories Inc.

    + *

    + * This software is provided ''as-is'', without any express or implied

    + * warranty. In no event will the authors be held liable for any damages

    + * arising from the use of this software.

    + *

    + * Permission is granted to anyone to use this software for any purpose,

    + * including commercial applications, and to alter it and redistribute it

    + * freely, subject to the following restrictions:

    + *

    + * 1. The origin of this software must not be misrepresented; you must not

    + *    claim that you wrote the original software. If you use this software

    + *    in a product, an acknowledgment in the product documentation would be

    + *    appreciated but is not required.

    + * 2. Altered source versions must be plainly marked as such, and must not be

    + *    misrepresented as being the original software.

    + * 3. This notice may not be removed or altered from any source distribution.

    + *

    + ******************************************************************************/

    +#include <stdbool.h>

    +#include "em_common.h"

    +#include "sl_bluetooth.h"

    +#include "esl_tag_log.h"

    +#include "esl_tag_core.h"

    +#include "esl_tag_image.h"

    +#include "sl_bt_ots_server.h"

    +#include "esl_tag_image_core.h"

    +#include "esl_tag_ots_server.h"

    +#include "sl_bt_ots_server_instances.h"

    +

    +#define OBJECT_ID_NOT_FOUND -1

    +

    +#define IMAGE_NAME_PREFIX   "Image-"

    +

    +#define IMAGE_NAME_POSTFIX  "***"

    +

    +#define IMAGE_NAME_FULL_STR IMAGE_NAME_PREFIX IMAGE_NAME_POSTFIX

    +

    +const sl_bt_ots_object_type_t esl_image_type_1b = {

    +  false,

    +  (uint8_t[SL_BT_OTS_UUID_SIZE_128]){ 0xe5, 0x10, 0x00, 0x01, 0x4b, 0x1d, 0xb1,
    0x9b, 0x00, 0xb1, 0xe5, 0x01, 0x8b, 0xad, 0xf0, 0x0d }

    +};

    +

    +const sl_bt_ots_object_type_t esl_image_type_2b = {

    +  false,

    +  (uint8_t[SL_BT_OTS_UUID_SIZE_128]){ 0xe5, 0x10, 0x00, 0x06, 0x4b, 0x1d, 0xb1,
    0x9b, 0x00, 0xb1, 0xe5, 0x01, 0x8b, 0xad, 0xf0, 0x0d }

    +};

    +

    +// Image default name type

    +typedef union {

    +  char data[sizeof(IMAGE_NAME_FULL_STR)];

    +  struct {

    +    const char prefix[sizeof(IMAGE_NAME_PREFIX) - 1]; // exclude terminating
    zero!

    +    char       postfix[sizeof(IMAGE_NAME_POSTFIX)];

    +  };

    +} esl_ots_image_name_t;

    +

    +// ESL Custom directory Listing Object

    +typedef struct {

    +  sl_bt_ots_object_id_t            id;          // Object ID

    +  const sl_bt_ots_object_type_t    *type;       // ESL Image object type

    +  sl_bt_ots_object_size_t          size;        // current and allocated size

    +  sl_bt_ots_object_properties_t    properties;  // ESL Image object properties

    +} esl_image_ots_object_t;

    +

    +// Image default name - postfix to be overwritten on-the-fly according to object

    +esl_ots_image_name_t object_name = { { IMAGE_NAME_FULL_STR } };

    +

    +// Array of objects

    +static esl_image_ots_object_t object_array[ESL_TAG_OTS_OBJECT_COUNT] = { 0 };

    +

    +// Index for object registration

    +static uint8_t object_array_register_index = 0;

    +

    +static int find_object_index_by_id(sl_bt_ots_object_id_t *object)

    +{

    +  const uint8_t image_count = esl_image_get_count();

    +  for (uint8_t i = 0; i < image_count; i++) {

    +    if (memcmp(object_array[i].id.data, object->data, sizeof(object->data)) ==
    0) {

    +      return i;

    +    }

    +  }

    +  return OBJECT_ID_NOT_FOUND;

    +}

    +

    +// Fast and simple uint8_t to 10-base string converter

    +static char u8toa(uint8_t n, char *const buf)

    +{

    +  if (buf == NULL ) {

    +    return 0;

    +  }

    +

    +  size_t length = n > 99 ? sizeof("123") : n > 9 ? sizeof("12") : sizeof("1");

    +  char *p = buf + --length;

    +  *p-- = 0;                         // Terminate the buffer

    +

    +  do {

    +    uint8_t t = n;                  // save current value

    +    n /= 10;

    +    *p-- = (t - (n * 10)) + 0x30;   // Convert diff. to ASCII

    +  } while (n != 0 && p >= buf);

    +

    +  return (char)length;              // The character count, w/o terminating nul!

    +}

    +

    +static sl_bt_ots_object_metadata_read_response_code_t ots_meta_read(sl_bt_ots_server_handle_t                   server,

    +                                                                    uint16_t                                    client,

    +                                                                    sl_bt_ots_object_id_t                       *object,

    +                                                                    sl_bt_ots_object_metadata_read_event_type_t
    event,

    +                                                                    sl_bt_ots_object_metadata_read_parameters_t
    *parameters)

    +{

    +  (void)server;

    +  (void)client;

    +

    +  sl_bt_ots_object_metadata_read_response_code_t response = SL_BT_OTS_OBJECT_METADATA_READ_RESPONSE_CODE_NOT_SUPPORTED;

    +

    +  // Find the object index

    +  int object_index = find_object_index_by_id(object);

    +  if (object_index > OBJECT_ID_NOT_FOUND) {

    +    esl_image_ots_object_t *object_ptr = &object_array[object_index];

    +    switch (event) {

    +      case SL_BT_OTS_OBJECT_METADATA_READ_OBJECT_NAME:

    +        // (Re)generate the name just-in-time

    +        parameters->object_name.length = sizeof(object_name.prefix) + u8toa(object_index,
    object_name.postfix);

    +        parameters->object_name.name = object_name.data;

    +        sl_bt_esl_log(ESL_LOG_COMPONENT_OTS,

    +                      ESL_LOG_LEVEL_INFO,

    +                      "ots_meta_read: Name: %.*s",

    +                      parameters->object_name.length,

    +                      parameters->object_name.name);

    +        response = SL_BT_OTS_OBJECT_METADATA_READ_RESPONSE_CODE_SUCCESS;

    +        break;

    +      case SL_BT_OTS_OBJECT_METADATA_READ_OBJECT_TYPE:

    +        sl_bt_esl_log(ESL_LOG_COMPONENT_OTS,

    +                      ESL_LOG_LEVEL_INFO,

    +                      "ots_meta_read: Type: ");

    +        sl_bt_esl_log_hexdump(ESL_LOG_COMPONENT_OTS | ESL_LOG_FLAG_APPEND,

    +                              ESL_LOG_LEVEL_INFO,

    +                              object_ptr->type->uuid_data,

    +                              ((object_ptr->type->uuid_is_sig) ? SL_BT_OTS_UUID_SIZE_16
    : SL_BT_OTS_UUID_SIZE_128));

    +        parameters->object_type.uuid_is_sig = object_ptr->type->uuid_is_sig;

    +        parameters->object_type.uuid_data = object_ptr->type->uuid_data;

    +        response = SL_BT_OTS_OBJECT_METADATA_READ_RESPONSE_CODE_SUCCESS;

    +        break;

    +      case SL_BT_OTS_OBJECT_METADATA_READ_OBJECT_SIZE:

    +        sl_bt_esl_log(ESL_LOG_COMPONENT_OTS,

    +                      ESL_LOG_LEVEL_INFO,

    +                      "ots_meta_read: Size - Current: %lu , Allocated: %lu",

    +                      object_ptr->size.current_size,

    +                      object_ptr->size.allocated_size);

    +        parameters->object_size.allocated_size = object_ptr->size.allocated_size;

    +        parameters->object_size.current_size = object_ptr->size.current_size;

    +        response = SL_BT_OTS_OBJECT_METADATA_READ_RESPONSE_CODE_SUCCESS;

    +        break;

    +      case SL_BT_OTS_OBJECT_METADATA_READ_OBJECT_PROPERTIES:

    +        sl_bt_esl_log(ESL_LOG_COMPONENT_OTS,

    +                      ESL_LOG_LEVEL_INFO,

    +                      "ots_meta_read: Properties: %02lx",

    +                      object_ptr->properties);

    +        parameters->object_properties = object_ptr->properties;

    +        response = SL_BT_OTS_OBJECT_METADATA_READ_RESPONSE_CODE_SUCCESS;

    +        break;

    +      case SL_BT_OTS_OBJECT_METADATA_READ_OBJECT_ID:

    +        sl_bt_esl_log(ESL_LOG_COMPONENT_OTS,

    +                      ESL_LOG_LEVEL_INFO,

    +                      "ots_meta_read: ID: ");

    +        sl_bt_esl_log_hexdump(ESL_LOG_COMPONENT_OTS | ESL_LOG_FLAG_APPEND,

    +                              ESL_LOG_LEVEL_INFO,

    +                              object_ptr->id.data,

    +                              sizeof(object_ptr->id.data));

    +        memcpy(parameters->object_id.data,

    +               object_ptr->id.data,

    +               sizeof(object_ptr->id.data));

    +        response = SL_BT_OTS_OBJECT_METADATA_READ_RESPONSE_CODE_SUCCESS;

    +        break;

    +      default:

    +        break;

    +    }

    +  }

    +  return response;

    +}

    +

    +static sl_bt_ots_olcp_response_code_t ots_olcp(sl_bt_ots_server_handle_t   server,

    +                                               uint16_t                    client,

    +                                               sl_bt_ots_object_id_t       *object,

    +                                               sl_bt_ots_olcp_event_t      event,

    +                                               sl_bt_ots_olcp_parameters_t *parameters,

    +                                               uint32_t                    *number_of_objects)

    +{

    +  sl_status_t sc = SL_STATUS_IN_PROGRESS;

    +  int         object_index = OBJECT_ID_NOT_FOUND;

    +  uint8_t     image_count  = esl_image_get_count();

    +  // Set the operation failed response as default

    +  sl_bt_ots_olcp_response_code_t response = SL_BT_OTS_OLCP_RESPONSE_CODE_OPEATION_FAILED;

    +

    +  (void)number_of_objects;

    +  sl_bt_esl_log(ESL_LOG_COMPONENT_OTS,

    +                ESL_LOG_LEVEL_INFO,

    +                "ots_olcp: OLCP OpCode: 0x%02x",

    +                event);

    +

    +  switch (event) {

    +    case SL_BT_OTS_OLCP_OPCODE_FIRST:

    +      object_index = 0;

    +      break;

    +

    +    case SL_BT_OTS_OLCP_OPCODE_LAST:

    +      if (image_count-- > 0) {

    +        object_index = image_count;

    +      }

    +      break;

    +

    +    case SL_BT_OTS_OLCP_OPCODE_NEXT:

    +      object_index = find_object_index_by_id(object);

    +      if (object_index > OBJECT_ID_NOT_FOUND) {

    +        const uint8_t max_image_index = image_count - 1;

    +        if (!(object_index++ < max_image_index)) {

    +          // Reset index on error

    +          object_index = OBJECT_ID_NOT_FOUND;

    +          response = SL_BT_OTS_OLCP_RESPONSE_CODE_OUT_OF_BOUNDS;

    +          break;

    +        }

    +      }

    +      break;

    +

    +    case SL_BT_OTS_OLCP_OPCODE_PREVIOUS:

    +      object_index = find_object_index_by_id(object);

    +      if (object_index > OBJECT_ID_NOT_FOUND) {

    +        if (object_index-- == 0) {

    +          object_index = OBJECT_ID_NOT_FOUND;

    +          response = SL_BT_OTS_OLCP_RESPONSE_CODE_OUT_OF_BOUNDS;

    +        }

    +      }

    +      break;

    +

    +    case SL_BT_OTS_OLCP_OPCODE_GO_TO:

    +      object_index = find_object_index_by_id(&parameters->go_to.id);

    +      if (object_index == OBJECT_ID_NOT_FOUND) {

    +        response = SL_BT_OTS_OLCP_RESPONSE_CODE_OBJECT_ID_NOT_FOUND;

    +      }

    +      break;

    +

    +    default:

    +      // Replace the default error response in case of unsupported opcodes

    +      response = SL_BT_OTS_OLCP_RESPONSE_CODE_OP_CODE_NOT_SUPPORTED;

    +      break;

    +  }

    +

    +  if (object_index != OBJECT_ID_NOT_FOUND) {

    +    sc = sl_bt_ots_server_set_current_object(server,

    +                                             client,

    +                                             &object_array[object_index].id,

    +                                             &object_array[object_index].properties,

    +                                             &object_array[object_index].size);

    +    if (sc == SL_STATUS_OK) {

    +      sc = esl_image_select_object(&object_array[object_index].id,

    +                                   sizeof(object_array[object_index].id));

    +      if (sc != SL_STATUS_OK) {

    +        // Invalidate the previous OTS object selection, ignore (override) result.

    +        (void)sl_bt_ots_server_set_current_object(server, client, NULL, NULL,
    NULL);

    +        response = SL_BT_OTS_OLCP_RESPONSE_CODE_OPEATION_FAILED;

    +      } else {

    +        response = SL_BT_OTS_OLCP_RESPONSE_CODE_SUCCESS;

    +      }

    +    }

    +  }

    +  return response;

    +}

    +

    +static sl_bt_ots_oacp_response_code_t ots_oacp(sl_bt_ots_server_handle_t      server,

    +                                               uint16_t                       client,

    +                                               sl_bt_ots_object_id_t          *object,

    +                                               sl_bt_ots_oacp_event_t         event,

    +                                               sl_bt_ots_oacp_parameters_t    *parameters,

    +                                               sl_bt_ots_oacp_response_data_t
    *response_data,

    +                                               uint16_t                       *max_sdu,

    +                                               uint16_t                       *max_pdu)

    +{

    +  (void)client;

    +  (void)server;

    +  (void)response_data;

    +  (void)parameters;

    +  sl_bt_ots_oacp_response_code_t response = SL_BT_OTS_OACP_RESPONSE_CODE_OP_CODE_NOT_SUPPORTED;

    +

    +  sl_bt_esl_log(ESL_LOG_COMPONENT_OTS,

    +                ESL_LOG_LEVEL_INFO,

    +                "ots_oacp: OACP OpCode: 0x%02x",

    +                event);

    +

    +  // Find the object index

    +  int object_index = find_object_index_by_id(object);

    +  if (object_index > OBJECT_ID_NOT_FOUND) {

    +    // OACP events can be handled here

    +    // Transfer can be implemented.

    +

    +    switch (event) {

    +      case SL_BT_OTS_OACP_OPCODE_WRITE:

    +        response = SL_BT_OTS_OACP_RESPONSE_CODE_SUCCESS;

    +        *max_pdu = ESL_TAG_OTS_TRANSFER_MAX_PDU_SIZE;

    +        *max_sdu = ESL_TAG_OTS_TRANSFER_MAX_SDU_SIZE;

    +        sl_bt_esl_log(ESL_LOG_COMPONENT_OTS,

    +                      ESL_LOG_LEVEL_INFO,

    +                      "Write object - Client %d.  Object ID: ",

    +                      client);

    +        sl_bt_esl_log_hexdump(ESL_LOG_COMPONENT_OTS | ESL_LOG_FLAG_APPEND,

    +                              ESL_LOG_LEVEL_INFO,

    +                              object->data,

    +                              sizeof(object->data));

    +        break;

    +      default:

    +        break;

    +    }

    +  }

    +

    +  return response;

    +}

    +

    +static sl_bt_ots_l2cap_credit_t ots_data(sl_bt_ots_server_handle_t server,

    +                                         uint16_t                  client,

    +                                         sl_bt_ots_object_id_t     *object,

    +                                         int32_t                   current_offset,

    +                                         void                      *data,

    +                                         int32_t                   size)

    +{

    +  sl_bt_ots_object_id_t current_object;

    +  sl_status_t sc = sl_bt_ots_server_get_current_object(server, client, &current_object);

    +  sl_bt_ots_l2cap_credit_t credit = 0;

    +

    +  sl_bt_esl_log(ESL_LOG_COMPONENT_OTS,

    +                ESL_LOG_LEVEL_DEBUG,

    +                "Data chunk received from client %u. Offset: %ld, Size %ld, Object
    ID: ",

    +                client,

    +                current_offset,

    +                size);

    +  sl_bt_esl_log_hexdump(ESL_LOG_COMPONENT_OTS | ESL_LOG_FLAG_APPEND,

    +                        ESL_LOG_LEVEL_DEBUG,

    +                        object->data,

    +                        sizeof(object->data));

    +

    +  if (sc == SL_STATUS_OK

    +      && memcmp(object, &current_object, SL_BT_OTS_OBJECT_ID_SIZE) == 0) {

    +    // ESL doesn''t need the offset information

    +    (void)current_offset;

    +    sc = esl_image_chunk_received(data, size);

    +    if (sc == SL_STATUS_OK) {

    +      credit++;

    +    } else {

    +      if (sc != SL_STATUS_FULL) {

    +        sl_bt_esl_log(ESL_LOG_COMPONENT_OTS,

    +                      ESL_LOG_LEVEL_ERROR,

    +                      "ESL Image error: 0x%04lX",

    +                      sc);

    +      } else {

    +        sl_bt_esl_log(ESL_LOG_COMPONENT_OTS,

    +                      ESL_LOG_LEVEL_INFO,

    +                      "ESL Image: slot full");

    +      }

    +      sl_bt_ots_server_abort(server, client);

    +    }

    +  }

    +

    +  return credit;

    +}

    +

    +static void ots_data_finished(sl_bt_ots_server_handle_t   server,

    +                              uint16_t                    client,

    +                              sl_bt_ots_object_id_t       *object,

    +                              sl_bt_ots_transfer_result_t result)

    +{

    +  (void)client;

    +  (void)server;

    +  (void)result;

    +  (void)object;

    +

    +  sl_bt_esl_log(ESL_LOG_COMPONENT_OTS,

    +                ESL_LOG_LEVEL_INFO,

    +                "Transfer finished with Client %d, result: %x Object ID: ",

    +                client,

    +                result);

    +  sl_bt_esl_log_hexdump(ESL_LOG_COMPONENT_OTS | ESL_LOG_FLAG_APPEND,

    +                        ESL_LOG_LEVEL_INFO,

    +                        object->data,

    +                        sizeof(object->data));

    +

    +  esl_image_receive_finished();

    +}

    +

    +// OTS Object Server Callbacks

    +static sl_bt_ots_server_callbacks_t ots_callbacks = {

    +  NULL,           // No callback to handle connection of a client

    +  NULL,           // No callback to handle disconnection of a client

    +  NULL,           // No callback to handle client subscription status changes

    +  NULL,           // No callback to handle metadata writes (unsupported)

    +  ots_meta_read,  // Callback to handle metadata read operations

    +  NULL,           // No callback to handle Object List Filter write operations

    +  NULL,           // No callback to handle Object List Filter read operations

    +  ots_olcp,          // Callback to handle OLCP List management events

    +  ots_oacp,          // Callback to handle OACP Data management events

    +  ots_data,          // Callback to handle incoming data

    +  ots_data_finished, // Callback to handle the end of a data transfer

    +  NULL               // No callback to handle outgoing data

    +};

    +

    +void esl_tag_ots_server_bt_on_event(sl_bt_msg_t *evt)

    +{

    +  sl_status_t sc;

    +  (void)sc; // suppress the compiler warning if sl_bt_esl_assert disabled

    +  // Handle stack events

    +  switch (SL_BT_MSG_ID(evt->header)) {

    +    // -------------------------------

    +    // This event indicates the device has started and the radio is ready.

    +    // Do not call any stack command before receiving this boot event!

    +    case sl_bt_evt_system_boot_id:

    +      // Initialize OTS Server

    +      sc = sl_bt_ots_server_init(&sl_bt_ots_server_instance_esl_image,

    +                                 &sl_bt_ots_server_gatt_esl_image,

    +                                 &ots_callbacks);

    +      sl_bt_esl_assert(sc == SL_STATUS_OK);

    +      break;

    +    default:

    +      break;

    +  }

    +}

    +

    +sl_status_t esl_tag_ots_add_object(const sl_bt_ots_object_type_t* type,

    +                                   uint32_t allocated_size,

    +                                   uint32_t properties)

    +{

    +  sl_status_t status = SL_STATUS_NO_MORE_RESOURCE;

    +

    +  // Check for in-bound limit.

    +  if (object_array_register_index < (sizeof(object_array) / sizeof(object_array[0])))
    {

    +    // Set Object ID according to ESLS spec.

    +    *(uint16_t*)&object_array[object_array_register_index].id.data = ESL_IMAGE_OBJECT_BASE
    | object_array_register_index;

    +

    +    // Set initial size

    +    object_array[object_array_register_index].size.allocated_size = allocated_size;

    +    object_array[object_array_register_index].size.current_size   = 0;

    +    // Set properties

    +    object_array[object_array_register_index].properties = properties;

    +    // Set object type

    +    object_array[object_array_register_index].type = type;

    +    // Prepare for next object

    +    object_array_register_index++;

    +    status = SL_STATUS_OK;

    +  }

    +

    +  return status;

    +}'
  - '--- a/app/bluetooth/common/esl_tag_ram_image/src/esl_tag_ram_image.c

    +++ b/app/bluetooth/common/esl_tag_ram_image/src/esl_tag_ram_image.c

    @@ -0,0 +1,278 @@

    +/***************************************************************************//**

    + * @file

    + * @brief ESL Tag RAM Image logic.

    + *******************************************************************************

    + * # License

    + * <b>Copyright 2021 Silicon Laboratories Inc. www.silabs.com</b>

    + *******************************************************************************

    + *

    + * SPDX-License-Identifier: Zlib

    + *

    + * The licensor of this software is Silicon Laboratories Inc.

    + *

    + * This software is provided ''as-is'', without any express or implied

    + * warranty. In no event will the authors be held liable for any damages

    + * arising from the use of this software.

    + *

    + * Permission is granted to anyone to use this software for any purpose,

    + * including commercial applications, and to alter it and redistribute it

    + * freely, subject to the following restrictions:

    + *

    + * 1. The origin of this software must not be misrepresented; you must not

    + *    claim that you wrote the original software. If you use this software

    + *    in a product, an acknowledgment in the product documentation would be

    + *    appreciated but is not required.

    + * 2. Altered source versions must be plainly marked as such, and must not be

    + *    misrepresented as being the original software.

    + * 3. This notice may not be removed or altered from any source distribution.

    + *

    + ******************************************************************************/

    +#include <stddef.h>

    +#include <string.h>

    +#include "esl_tag_image_config.h"

    +#include "esl_tag_ots_server.h"

    +#include "esl_tag_image_core.h"

    +#include "esl_tag_errors.h"

    +#include "esl_tag_image.h"

    +#include "esl_tag_core.h"

    +#include "esl_tag_log.h"

    +#include "em_common.h"

    +#include "gatt_db.h"

    +

    +// Single image object storage type

    +typedef PACKSTRUCT (struct {

    +  uint16_t  max_size;

    +  uint16_t  size;

    +  uint8_t   *data;

    +}) esl_image_object_t;

    +

    +// Internal image registry type

    +typedef PACKSTRUCT (struct {

    +  esl_image_object_t  *active_image;

    +  uint8_t             *next_object;

    +  uint8_t             images_count;

    +}) esl_image_registry_t;

    +

    +// Image registry structure

    +static esl_image_registry_t image_registry = { 0 };

    +

    +// Image object array - max. number of elements is defined in config header

    +static esl_image_object_t   image_object[ESL_TAG_MAX_IMAGES] = { 0 };

    +

    +// Image pool - the static storage for all image data

    +static uint8_t              image_pool[ESL_TAG_RAM_IMAGE_POOL_SIZE];

    +

    +void esl_image_receive_finished(void)

    +{

    +}

    +

    +sl_status_t esl_image_chunk_received(uint8_t const *data,

    +                                     uint16_t length)

    +{

    +  sl_status_t result  = SL_STATUS_INVALID_INDEX;

    +  esl_image_object_t *active_image = image_registry.active_image;

    +

    +  // ESL RAM image: data must fit to RAM pool. Please check your config!

    +  sl_bt_esl_assert(length <= ESL_TAG_RAM_IMAGE_POOL_SIZE);

    +

    +  // if there''s a valid image object selected

    +  if (active_image != NULL) {

    +    // check for overflow condition

    +    if ((active_image->size + length) > active_image->max_size) {

    +      sl_bt_esl_log(ESL_LOG_COMPONENT_RAM_IMAGE,

    +                    ESL_LOG_LEVEL_ERROR,

    +                    "Image size overflow!");

    +      // invalidate the image in this case by clearing it''s size

    +      active_image->size = 0;

    +      // return the error

    +      result = SL_STATUS_WOULD_OVERFLOW;

    +    } else {

    +      // store the data, otherwise

    +      memcpy(&(active_image->data[active_image->size]), data, length);

    +      // adjust the size

    +      active_image->size += length;

    +

    +      // improve OTS response by not sending credit after the storage is full

    +      if (active_image->size < active_image->max_size) {

    +        result = SL_STATUS_OK;

    +      } else {

    +        result = SL_STATUS_FULL;

    +      }

    +    }

    +  }

    +

    +  return result;

    +}

    +

    +sl_status_t esl_image_select_object(void const *data, uint16_t length)

    +{

    +  // in case of size mismatch, this is the default answer:

    +  sl_status_t    result     = SL_STATUS_INVALID_HANDLE;

    +  const uint16_t valid_size = sizeof(esl_image_object_id_t);

    +

    +  // select null object by default (in case of error)

    +  image_registry.active_image = NULL;

    +

    +  if (length == valid_size) {

    +    if (*(uint16_t *)data < ESL_IMAGE_OBJECT_BASE) {

    +      // invalid Object ID (wrong base?)

    +      result = SL_STATUS_INVALID_PARAMETER;

    +    } else if (*(uint8_t *)data >= image_registry.images_count) {

    +      // image index is out of bounds

    +      result = SL_STATUS_INVALID_INDEX;

    +    } else {

    +      // select active image storage for the upcoming data transfer

    +      image_registry.active_image = &image_object[*(uint8_t *)data];

    +      // there''s no temporary storage -> initiating image transfer by this

    +      // selection it will destroy the previous image content (if any)

    +      image_registry.active_image->size = 0;

    +      result = SL_STATUS_OK;

    +    }

    +  }

    +

    +  return result;

    +}

    +

    +void esl_image_init(void)

    +{

    +  // clear all images data, ESL Profile specification d09r18, Section 3.2

    +  memset(image_pool, 0, sizeof(image_pool));

    +

    +  // initialize zero images count, set max. available size for image allocation

    +  image_registry.active_image = NULL;

    +  image_registry.next_object  = (void *)image_pool;

    +  image_registry.images_count = 0;

    +}

    +

    +void esl_image_characteristic_update(void)

    +{

    +  sl_status_t sc;

    +  (void)sc; // suppress the compiler warning if sl_bt_esl_assert disabled

    +  uint8_t gatt_data = image_registry.images_count; // ESL Serv.spec. 3.7.1

    +

    +  // gattdb_esl_image_info shall contain Max_Image_Index, not the image count!

    +  if (gatt_data > 0) {

    +    gatt_data -= 1;

    +  }

    +

    +  sc = sl_bt_gatt_server_write_attribute_value(gattdb_esl_image_info,

    +                                               0,

    +                                               sizeof(gatt_data),

    +                                               &gatt_data);

    +  sl_bt_esl_assert(sc == SL_STATUS_OK);

    +}

    +

    +sl_status_t esl_image_add(uint16_t width, uint16_t height,

    +                          uint8_t bits_per_pixel)

    +{

    +  sl_status_t result = SL_STATUS_INVALID_STATE;

    +  esl_state_t state  = esl_core_get_status();

    +

    +  // ESL Image: adding images after ESL boot event is disallowed!

    +  sl_bt_esl_assert(esl_state_boot == state);

    +

    +  if (state == esl_state_boot) {

    +    result = SL_STATUS_NO_MORE_RESOURCE;

    +

    +    // Refuse to add any new image if the max images count is reached!

    +    if (image_registry.images_count < ESL_TAG_MAX_IMAGES) {

    +      // get buffer size in bytes

    +      uint32_t  size      = (bits_per_pixel * width * height) / 8;

    +      // get remaining pool size

    +      uint32_t  available = &image_pool[ESL_TAG_RAM_IMAGE_POOL_SIZE]

    +                            - image_registry.next_object;

    +      result = SL_STATUS_ALLOCATION_FAILED;

    +

    +      if (size <= available) {

    +        uint8_t new_image_index = image_registry.images_count;

    +        const sl_bt_ots_object_type_t* type;

    +        // currently, there are only two types of images available

    +        type = bits_per_pixel == 1 ? &esl_image_type_1b : &esl_image_type_2b;

    +

    +        // store maximum size of the image object

    +        image_object[new_image_index].max_size = (uint16_t)size;

    +        // set actual size to zero, initially

    +        image_object[new_image_index].size     = 0;

    +        // allocate raw data pointer in the pool

    +        image_object[new_image_index].data     = image_registry.next_object;

    +        // finish registration

    +        ++image_registry.images_count;

    +        image_registry.next_object += size;

    +        result = esl_tag_ots_add_object(type, size, ESL_OTS_IMAGE_OBJECT);

    +      } else {

    +        sl_bt_esl_log(ESL_LOG_COMPONENT_RAM_IMAGE,

    +                      ESL_LOG_LEVEL_ERROR,

    +                      "Unable to add image due size constraints.");

    +      }

    +    } else {

    +      sl_bt_esl_log(ESL_LOG_COMPONENT_RAM_IMAGE,

    +                    ESL_LOG_LEVEL_ERROR,

    +                    "Unable to add more images, ESL_TAG_MAX_IMAGES might be low.");

    +    }

    +  }

    +

    +  return result;

    +}

    +

    +sl_status_t esl_image_get_data(uint8_t image_index, uint16_t* offset,

    +                               uint16_t buf_size, uint8_t *target_buf)

    +{

    +  sl_status_t result = SL_STATUS_INVALID_INDEX;

    +

    +  // check if given index points to a registered image

    +  if (image_index < image_registry.images_count) {

    +    // calculate the remaining size to read

    +    uint16_t remaining_size = image_object[image_index].size - *offset;

    +    // calculate the source address to read from

    +    uint8_t *source_ptr     = &(image_object[image_index].data[*offset]);

    +

    +    // check if image has valid data

    +    if (image_object[image_index].size == 0) {

    +      // set proper ESL ERROR to be sent to the ESL Access point

    +      esl_core_set_last_error(ESL_ERROR_IMAGE_NOT_AVAILABLE);

    +      return SL_STATUS_NOT_AVAILABLE;

    +    } else if (*offset > image_object[image_index].size) {

    +      // else check if offset is out of bounds

    +      esl_core_set_last_error(ESL_ERROR_UNSPECIFIED);

    +      return SL_STATUS_ABORT;

    +    } else if (*offset == image_object[image_index].size) {

    +      // else check an edge case: read to be finished just right now

    +      return SL_STATUS_OK;

    +    } else if (remaining_size > buf_size) {

    +      // or adjust remaining size to the buffer size on success

    +      remaining_size = buf_size;

    +    }

    +

    +    // if there''s still data to read

    +    if (remaining_size != 0) {

    +      // copy data chunk

    +      memcpy(target_buf, source_ptr, remaining_size);

    +      // shift the offset

    +      *offset += remaining_size;

    +    }

    +

    +    result = SL_STATUS_OK;

    +  } else {

    +    // signal invalid index to the remote ESL Access Point

    +    esl_core_set_last_error(ESL_ERROR_INVALID_IMAGE_INDEX);

    +  }

    +

    +  return result;

    +}

    +

    +uint8_t esl_image_get_count()

    +{

    +  return image_registry.images_count;

    +}

    +

    +void esl_image_reset_storage(void)

    +{

    +  uint8_t image_index = image_registry.images_count;

    +

    +  while (image_index--) {

    +    // get every image objects one by one

    +    esl_image_object_t *image = &image_object[image_index];

    +    // invalidate data content by clearing the size

    +    image->size = 0;

    +  }

    +}'
  - '--- a/app/bluetooth/common/esl_tag_sensor/src/esl_tag_sensor.c

    +++ b/app/bluetooth/common/esl_tag_sensor/src/esl_tag_sensor.c

    @@ -0,0 +1,386 @@

    +/***************************************************************************//**

    + * @file

    + * @brief ESL Tag Sensor implementation

    + *******************************************************************************

    + * # License

    + * <b>Copyright 2022 Silicon Laboratories Inc. www.silabs.com</b>

    + *******************************************************************************

    + *

    + * SPDX-License-Identifier: Zlib

    + *

    + * The licensor of this software is Silicon Laboratories Inc.

    + *

    + * This software is provided ''as-is'', without any express or implied

    + * warranty. In no event will the authors be held liable for any damages

    + * arising from the use of this software.

    + *

    + * Permission is granted to anyone to use this software for any purpose,

    + * including commercial applications, and to alter it and redistribute it

    + * freely, subject to the following restrictions:

    + *

    + * 1. The origin of this software must not be misrepresented; you must not

    + *    claim that you wrote the original software. If you use this software

    + *    in a product, an acknowledgment in the product documentation would be

    + *    appreciated but is not required.

    + * 2. Altered source versions must be plainly marked as such, and must not be

    + *    misrepresented as being the original software.

    + * 3. This notice may not be removed or altered from any source distribution.

    + *

    + ******************************************************************************/

    +#include <stdio.h>

    +#include <string.h>

    +#include "em_emu.h"

    +#include "gatt_db.h"

    +#include "em_common.h"

    +#include "sl_sleeptimer.h"

    +#include "esl_tag_log.h"

    +#include "esl_tag_sensor.h"

    +#include "esl_tag_response.h"

    +#include "esl_tag_sensor_core.h"

    +#include "esl_tag_sensor_config.h"

    +#include "esl_tag_battery_internal.h"

    +

    +// ESL Sensor Information Characteristics minimum length (by specification)

    +#define ESL_SENSOR_INFO_MINIMUM_SIZE  3

    +

    +// ESL Sensor Information Characteristics: absolute maximum number of sensors

    +#define ESL_SENSOR_MAX_COUNT          (ESL_SENSOR_INFO_POOL_SIZE \

    +                                       / ESL_SENSOR_INFO_MINIMUM_SIZE)

    +// Sensor Information type - same format as defined in ESL Specification:

    +// Sensor Information Characteristic definition

    +PACKSTRUCT(struct esl_sensor_info_s {

    +  esl_sensor_size_t size;                         // one octet

    +  union {

    +    esl_sensor_standard_id_t mesh_property_id;    // only two octets

    +    esl_sensor_vendor_id_t   vendor_specific;     // four octets

    +  };

    +});

    +

    +/// ESL Sensor Object abstract data type pointer

    +typedef struct esl_sensor_info_s *esl_sensor_info_p;

    +

    +// Sensor object type for internal use

    +typedef PACKSTRUCT (struct {

    +  esl_sensor_info_p info;

    +}) esl_sensor_object_t;

    +

    +// Internal sensor registry type

    +typedef PACKSTRUCT (struct {

    +  esl_sensor_object_t *next_object;

    +  uint8_t             sensor_count;

    +}) esl_sensor_registry_t;

    +

    +// Sensor info array - max. number of elements is defined in config header

    +static uint8_t                sensor_info[ESL_SENSOR_INFO_POOL_SIZE];

    +

    +// Sensor object array for internal use

    +static esl_sensor_object_t    sensor_object[ESL_SENSOR_MAX_COUNT];

    +

    +// Sensor registry structure

    +static esl_sensor_registry_t  sensor_registry;

    +

    +/******************************************************************************

    + * Sensor info getter - returns with all sensor data in a format which can be

    + * easily write to the ESL Sensor Information characteristic.

    + * @param[out] uint16_t* size of the ESL sensor info data

    + * @param[out] void** pointer to the serialized ESL Sensor Information data

    + *****************************************************************************/

    +static inline void esl_sensor_get_all_info(uint16_t *data_size, void **out)

    +{

    +  *data_size = (uint16_t)((uint8_t *)sensor_registry.next_object->info

    +                          - sensor_info);

    +

    +  // having the characteristic with zero length of data is invalid!

    +  if (*data_size == 0) {

    +    // this is an ''user error'' condition, still the GATT req. shall succeed
    once

    +    // the ESL access point tries to read it, thus we need at least one full
    set

    +    // to be reported even if this "shadow" sensor itself will be invalid

    +    // and hence non-functioning without registering at least one during

    +    // the ESL boot event, properly

    +    *data_size = ESL_SENSOR_INFO_MINIMUM_SIZE;

    +  }

    +

    +  *out = (void *)sensor_info;

    +}

    +

    +void esl_sensor_init(void)

    +{

    +  // clear all sensor data

    +  memset(sensor_info, 0, sizeof(sensor_info));

    +  memset(sensor_object, 0, sizeof(sensor_object));

    +

    +  // initialize zero sensor count, prepare sensor creation / allocation

    +  sensor_registry.next_object  = sensor_object;

    +  sensor_registry.sensor_count = 0;

    +  sensor_object[0].info        = (esl_sensor_info_p)sensor_info;

    +}

    +

    +void esl_sensor_bt_on_event(sl_bt_msg_t *evt)

    +{

    +  sl_status_t sc;

    +  (void)sc; // suppress the compiler warning if sl_bt_esl_assert disabled

    +

    +  switch (SL_BT_MSG_ID(evt->header)) {

    +    case sl_bt_evt_system_boot_id:

    +      // here we''re checking that we precede the esl_core_bt_on_event invocation

    +      if (esl_core_get_status() == esl_state_boot) {

    +        // register sensors which are enabled in the configuration

    +#if (ESL_SENSOR_INPUT_VOLTAGE_ENABLE)

    +        sc = esl_sensor_add(ESL_SENSOR_MESH_DEVICE,

    +                            PRESENT_INPUT_VOLTAGE);

    +        sl_bt_esl_assert(sc == SL_STATUS_OK);

    +#endif // (ESL_SENSOR_INPUT_VOLTAGE_ENABLE)

    +#if (ESL_SENSOR_OPERATING_TEMPERATURE_ENABLE)

    +        sc = esl_sensor_add(ESL_SENSOR_MESH_DEVICE,

    +                            PRESENT_DEVICE_OPERATING_TEMPERATURE);

    +        sl_bt_esl_assert(sc == SL_STATUS_OK);

    +#endif // (ESL_SENSOR_OPERATING_TEMPERATURE_ENABLE)

    +#if (ESL_SENSOR_FW_REVISION_ENABLE)

    +        sc = esl_sensor_add(ESL_SENSOR_MESH_DEVICE,

    +                            DEVICE_FIRMWARE_REVISION);

    +        sl_bt_esl_assert(sc == SL_STATUS_OK);

    +#endif // (ESL_SENSOR_FW_REVISION_ENABLE)

    +#if (ESL_SENSOR_MANUFACTURING_DATE_ENABLE)

    +        sc = esl_sensor_add(ESL_SENSOR_MESH_DEVICE,

    +                            DEVICE_DATE_OF_MANUFACTURE);

    +        sl_bt_esl_assert(sc == SL_STATUS_OK);

    +#endif // (ESL_SENSOR_MANUFACTURING_DATE_ENABLE)

    +#if (ESL_SENSOR_DEVICE_TEMPERATURE_RANGE_ENABLE)

    +        sc = esl_sensor_add(ESL_SENSOR_MESH_DEVICE,

    +                            DEVICE_OPERATING_TEMPERATURE_RANGE_SPECIFICATION);

    +        sl_bt_esl_assert(sc == SL_STATUS_OK);

    +#endif // (ESL_SENSOR_DEVICE_TEMPERATURE_RANGE_ENABLE)

    +      }

    +      break;

    +

    +    case sl_bt_evt_gatt_server_user_read_request_id:

    +      if (evt->data.evt_gatt_server_user_read_request.characteristic == gattdb_esl_sensor_info)
    {

    +        uint8_t*  raw_info;

    +        uint16_t  raw_size, offset;

    +        uint16_t  mtu_size;

    +        sl_status_t sc;

    +        (void)sc; // suppress the compiler warning if sl_bt_esl_assert disabled

    +

    +        // get pointer first to the beginning of the sensor_info packed struct

    +        esl_sensor_get_all_info(&raw_size, (void *)&raw_info);

    +        // then get the offset value from the request

    +        offset = evt->data.evt_gatt_server_user_read_request.offset;

    +        // finally, adjust offset and size

    +        raw_info += offset;

    +        raw_size -= offset;

    +

    +        // check current ATT_MTU limits

    +        sc = sl_bt_gatt_server_get_mtu(evt->data.evt_gatt_server_user_read_request.connection,
    &mtu_size);

    +        sl_bt_esl_assert(sc == SL_STATUS_OK);

    +

    +        // sl_bt_gatt_server_send_user_read_response allows (ATT_MTU - 1) size

    +        --mtu_size; // of data to be sent at once!

    +

    +        // and limit the actual data size to be sent accordingly

    +        raw_size = raw_size > mtu_size ? mtu_size : raw_size;

    +

    +        // send data (chunk, maybe more read reqs. with offset != 0 will follow)

    +        sc = sl_bt_gatt_server_send_user_read_response(evt->data.evt_gatt_server_user_read_request.connection,

    +                                                       evt->data.evt_gatt_server_user_read_request.characteristic,

    +                                                       SL_STATUS_OK,

    +                                                       raw_size,

    +                                                       raw_info,

    +                                                       NULL);

    +        sl_bt_esl_assert(sc == SL_STATUS_OK);

    +      }

    +      break;

    +

    +    default:

    +      break;

    +  }

    +}

    +

    +sl_status_t esl_sensor_add(esl_sensor_company_id_t company,

    +                           esl_sensor_sensor_code_t code)

    +{

    +  sl_status_t result = SL_STATUS_INVALID_STATE;

    +  esl_state_t state  = esl_core_get_status();

    +

    +  // ESL Sensor: adding sensors after the boot event is disallowed!

    +  sl_bt_esl_assert(esl_state_boot == state);

    +

    +  if (state == esl_state_boot) {

    +    const uint8_t remaining = (uint8_t)(&sensor_info[ESL_SENSOR_INFO_POOL_SIZE]

    +                                        - (uint8_t *)sensor_registry.next_object->info);

    +    const uint8_t info_size = ((company == ESL_SENSOR_MESH_DEVICE)

    +                               ? ESL_SENSOR_INFO_MINIMUM_SIZE

    +                               : (sizeof(esl_sensor_vendor_id_t) + 1));

    +    const bool    is_custom = info_size != ESL_SENSOR_INFO_MINIMUM_SIZE;

    +

    +    result = SL_STATUS_NO_MORE_RESOURCE;

    +

    +    if (remaining > info_size) {

    +      uint8_t* current_info_ptr = (uint8_t *)sensor_object[sensor_registry.sensor_count].info;

    +

    +      if (is_custom) {

    +        sensor_registry.next_object->info->size = ESL_SENSOR_SIZE_VENDOR_SPECIFIC;

    +        sensor_registry.next_object->info->vendor_specific.company_id = company;

    +        sensor_registry.next_object->info->vendor_specific.sensor_code = code;

    +      } else {

    +        sensor_registry.next_object->info->size = ESL_SENSOR_SIZE_MESH_DEVICE;

    +        sensor_registry.next_object->info->mesh_property_id = code;

    +      }

    +

    +      // increase packed sensor info pointer

    +      current_info_ptr += info_size;

    +      // increase sensor count

    +      ++sensor_registry.sensor_count;

    +      // setup next object

    +      sensor_object[sensor_registry.sensor_count].info = (esl_sensor_info_p)current_info_ptr;

    +      // get next object in registry

    +      ++sensor_registry.next_object;

    +      result = SL_STATUS_OK;

    +    } else {

    +      sl_bt_esl_log(ESL_LOG_COMPONENT_SENSOR,

    +                    ESL_LOG_LEVEL_ERROR,

    +                    "Unable to add more sensor, ESL_SENSOR_INFO_POOL_SIZE might
    be low.");

    +    }

    +  }

    +

    +  return result;

    +}

    +

    +sl_status_t esl_sensor_read(uint8_t index)

    +{

    +  sl_status_t result = SL_STATUS_INVALID_INDEX;

    +

    +  if (index < sensor_registry.sensor_count) {

    +    esl_sensor_size_t size = sensor_object[index].info->size;

    +    esl_sensor_sensor_code_t code = (size == ESL_SENSOR_SIZE_MESH_DEVICE)

    +                                    ? sensor_object[index].info->mesh_property_id

    +                                    : sensor_object[index].info->vendor_specific.sensor_code;

    +    esl_sensor_company_id_t company = (size == ESL_SENSOR_SIZE_MESH_DEVICE)

    +                                      ? ESL_SENSOR_MESH_DEVICE

    +                                      : sensor_object[index].info->vendor_specific.company_id;

    +    result = esl_sensor_custom_read(index, size, code, company);

    +

    +    if (result != SL_STATUS_OK && company == ESL_SENSOR_MESH_DEVICE) {

    +      char        report_data[ESL_SENSOR_MAX_REPORT_LENGTH + 1] = { index, 0
    };

    +      char* const read_target = &report_data[1];

    +      uint8_t     report_len  = 0;

    +

    +      // prepare to continue but keep existing user response, if any

    +      result = (result == SL_STATUS_NOT_SUPPORTED) ? SL_STATUS_OK : result;

    +

    +      switch (code) {

    +        default:

    +          *read_target = 0;

    +          if (result == SL_STATUS_OK) {

    +            // change only if there''s no previous user result available

    +            result = SL_STATUS_INVALID_PARAMETER;

    +          }

    +          break;

    +#if (ESL_SENSOR_INPUT_VOLTAGE_ENABLE)

    +        case PRESENT_INPUT_VOLTAGE: {

    +          uint32_t battery_millivolts = esl_sensor_get_battery_voltage_mv();

    +          if (battery_millivolts != ESL_TAG_BATTERY_LEVEL_UNKNOWN) {

    +            // convert from mV to 1/64 V of resolution: needs divide by 15.625

    +            // but we do the conversion with integer math, only

    +            voltage_t input_voltage = (1000 * battery_millivolts) / 15625;

    +            report_len = sizeof(voltage_t);

    +            memcpy(read_target, &input_voltage, report_len);

    +            // check if Service Needed flag has to be set (on low battery level)

    +            esl_sensor_core_check_battery_level();

    +          } else {

    +            result = SL_STATUS_BUSY;

    +            esl_core_set_last_error(ESL_ERROR_RETRY);

    +          }

    +        } break;

    +#endif // (ESL_SENSOR_INPUT_VOLTAGE_ENABLE)

    +#if (ESL_SENSOR_OPERATING_TEMPERATURE_ENABLE)

    +        case PRESENT_DEVICE_OPERATING_TEMPERATURE: {

    +          temperature_t temp = (temperature_t)((EMU_TemperatureGet() + .5f) *
    100.f);

    +          report_len = sizeof(temperature_t);

    +          memcpy(read_target, &temp, report_len);

    +        } break;

    +#endif // (ESL_SENSOR_OPERATING_TEMPERATURE_ENABLE)

    +#if (ESL_SENSOR_FW_REVISION_ENABLE)

    +        case DEVICE_FIRMWARE_REVISION: {

    +          const uint8_t str_len = sizeof(fixed_string8);

    +          report_len = str_len;

    +          snprintf(read_target,

    +                   // here it''s safe to leave extra space for terminating null

    +                   str_len + 1,

    +                   "%02u.%02u.%02u",

    +                   ESL_SENSOR_FW_REVISION_MAJOR,

    +                   ESL_SENSOR_FW_REVISION_MINOR,

    +                   ESL_SENSOR_FW_REVISION_PATCH);

    +        } break;

    +#endif // (ESL_SENSOR_FW_REVISION_ENABLE)

    +#if (ESL_SENSOR_MANUFACTURING_DATE_ENABLE)

    +        case DEVICE_DATE_OF_MANUFACTURE: {

    +          // GATT Service Supplement v5, Section 3.67.2 (on Date UTC format):

    +          const size_t utc_len = 3; // Date UTC is uint24, thus 3 bytes long

    +          sl_sleeptimer_timestamp_t time = 0;

    +          sl_sleeptimer_date_t      date;

    +          date_utc_t                utc_date;

    +          (void)sl_sleeptimer_build_datetime(&date,

    +                                             ESL_SENSOR_MANUFACTURING_YEAR,

    +                                             ESL_SENSOR_MANUFACTURING_MONTH -
    1,

    +                                             ESL_SENSOR_MANUFACTURING_DAY,

    +                                             0, 0, 0, 0);

    +          (void)sl_sleeptimer_convert_date_to_time(&date, &time);

    +          utc_date = time ? (time / (24u * 60u * 60u)) : 0;

    +          report_len = utc_len;

    +          memcpy(read_target, &utc_date, utc_len);

    +        } break;

    +#endif // (ESL_SENSOR_MANUFACTURING_DATE_ENABLE)

    +#if (ESL_SENSOR_DEVICE_TEMPERATURE_RANGE_ENABLE)

    +        case DEVICE_OPERATING_TEMPERATURE_RANGE_SPECIFICATION: {

    +          temperature_range_t operating_range = {

    +            ESL_SENSOR_DEVICE_TEMPERATURE_RANGE_MIN * 100,

    +            ESL_SENSOR_DEVICE_TEMPERATURE_RANGE_MAX * 100

    +          };

    +          report_len = sizeof(temperature_range_t);

    +          memcpy(read_target, &operating_range, report_len);

    +        } break;

    +#endif // (ESL_SENSOR_DEVICE_TEMPERATURE_RANGE_ENABLE)

    +      }

    +

    +      if (result == SL_STATUS_OK) {

    +        result = esl_sensor_set_report(report_len, report_data);

    +      }

    +    }

    +  } else {

    +    esl_core_set_last_error(ESL_ERROR_INVALID_PARAMETER);

    +  }

    +

    +  return result;

    +}

    +

    +SL_WEAK sl_status_t esl_sensor_custom_read(uint8_t index,

    +                                           esl_sensor_size_t size,

    +                                           esl_sensor_sensor_code_t sensor_id,

    +                                           esl_sensor_company_id_t company)

    +{

    +  (void)index;

    +  (void)size;

    +  (void)sensor_id;

    +  (void)company;

    +

    +  // default answer is SL_STATUS_NOT_SUPPORTED

    +  return SL_STATUS_NOT_SUPPORTED;

    +}

    +

    +sl_status_t esl_sensor_set_report(uint8_t report_size, void *report_data)

    +{

    +  sl_status_t result = SL_STATUS_WOULD_OVERFLOW;

    +

    +  if (report_size < ESL_SENSOR_MAX_REPORT_LENGTH) {

    +    tlv_t tlv_result  = ESL_TLV_RESPONSE_SENSOR_VALUE;

    +    esl_core_set_tlv_len(tlv_result, report_size + 1); // +1 for the index!

    +    result = esl_core_build_response(tlv_result, report_data);

    +  }

    +

    +  return result;

    +}

    +

    +uint8_t esl_sensor_get_count()

    +{

    +  return sensor_registry.sensor_count;

    +}'
  - '--- a/app/bluetooth/common/esl_tag_user_display_driver/src/esl_tag_user_display_driver.c

    +++ b/app/bluetooth/common/esl_tag_user_display_driver/src/esl_tag_user_display_driver.c

    @@ -0,0 +1,117 @@

    +/***************************************************************************//**

    + * @file

    + * @brief WSTK display driver implementation for user defined displays.

    + *******************************************************************************

    + * # License

    + * <b>Copyright 2021 Silicon Laboratories Inc. www.silabs.com</b>

    + *******************************************************************************

    + *

    + * SPDX-License-Identifier: Zlib

    + *

    + * The licensor of this software is Silicon Laboratories Inc.

    + *

    + * This software is provided ''as-is'', without any express or implied

    + * warranty. In no event will the authors be held liable for any damages

    + * arising from the use of this software.

    + *

    + * Permission is granted to anyone to use this software for any purpose,

    + * including commercial applications, and to alter it and redistribute it

    + * freely, subject to the following restrictions:

    + *

    + * 1. The origin of this software must not be misrepresented; you must not

    + *    claim that you wrote the original software. If you use this software

    + *    in a product, an acknowledgment in the product documentation would be

    + *    appreciated but is not required.

    + * 2. Altered source versions must be plainly marked as such, and must not be

    + *    misrepresented as being the original software.

    + * 3. This notice may not be removed or altered from any source distribution.

    + *

    + ******************************************************************************/

    +#include <stdint.h>

    +#include <stdarg.h>

    +#include "esl_tag_log.h"

    +#include "esl_tag_display.h"

    +#include "esl_tag_image_core.h"

    +#include "esl_tag_user_display_driver.h"

    +

    +sl_status_t esl_user_display_write(int param_count, ...)

    +{

    +  // Please note that implementing this function is mandatory.

    +

    +  // Declaring pointer to the argument list

    +  va_list     ptr;

    +  // Default status is SL_STATUS_IN_PROGRESS, set to SL_STATUS_OK once the

    +  // display data has been written successfully.

    +  sl_status_t status = SL_STATUS_IN_PROGRESS;

    +  // Variables for va parameters

    +  uint8_t     display_index;  // 2nd parameter

    +  uint8_t     image_index;    // 3rd parameter

    +

    +  // User display write: Invalid parameters!

    +  sl_bt_esl_assert(param_count == ESL_DISPLAY_WRITE_FUNC_PARAMETERS_COUNT);

    +

    +  // Initializing argument to the list pointer

    +  va_start(ptr, param_count);

    +

    +  // Accessing variables (after each call to va_arg our ptr points to next one)

    +  display_index = (uint8_t)va_arg(ptr, int);

    +  image_index   = (uint8_t)va_arg(ptr, int);

    +

    +  // end argument list traversal

    +  va_end(ptr);

    +

    +  /////////////////////////////////////////////////////////////////////////////

    +  // Put your additional display driver write code here!                     //

    +  // This is called by ESL display core on appropriate request coming from   //

    +  // the ESL Access Point the ESL Tag is synchronized to.                    //

    +  // Please do not call any long term blocking functions from here!          //

    +  // If the write goes slowly on your display, and especially, if it needs   //

    +  // a sequence of multiple transactions which takes long time, then please  //

    +  // do the scheduling only from here.                                       //

    +  // Do not forget to set result = SL_STATUS_OK after successful operation,  //

    +  // including the scheduling only, if it''s the case.                        //

    +  /////////////////////////////////////////////////////////////////////////////

    +

    +  return status;

    +}

    +

    +sl_status_t esl_user_display_init(int param_count, ...)

    +{

    +  /////////////////////////////////////////////////////////////////////////////

    +  // Please note that implementing this function can be omitted if unnecessary

    +  // - in that particular case just pass a NULL ptr to the esl_display_create()

    +  // call in the appropriate parameter.

    +  /////////////////////////////////////////////////////////////////////////////

    +

    +  // Declaring pointer to the argument list

    +  va_list     ptr;

    +  // Default status is SL_STATUS_FAIL, set to SL_STATUS_OK once the display

    +  // has been initialized successfully.

    +  sl_status_t status = SL_STATUS_FAIL;

    +  // Variable for va parameter

    +  uint8_t     index;  // 2nd parameter

    +

    +  // User display init: Invalid parameters!

    +  sl_bt_esl_assert(param_count == ESL_DISPLAY_INIT_FUNC_PARAMETERS_COUNT);

    +

    +  // Initializing argument to the list pointer

    +  va_start(ptr, param_count);

    +  // Extract the index value (the only extra parameter)

    +  index = (uint8_t)va_arg(ptr, int);

    +  va_end(ptr);

    +

    +  /////////////////////////////////////////////////////////////////////////////

    +  // Put your additional display driver init code here!                      //

    +  // This is called once, during the invocation of esl_display_create().     //

    +  // Temporary blocking functions are allowed to be called from here yet not
    //

    +  // recommended.                                                            //

    +  // If the display needs pre-initialization - especially if it takes longer
    //

    +  // time to finish (e.g. internal boot of the display or a clock to become  //

    +  // stable) - then it is highly recommended to take those pre-steps in the  //

    +  // callback called app_init(), instead - and take only the post-init steps
    //

    +  // here, if there''s any.                                                   //

    +  // Do not forget to set result = SL_STATUS_OK after successful init.       //

    +  /////////////////////////////////////////////////////////////////////////////

    +

    +  return status;

    +}'
  - '--- a/app/bluetooth/common/esl_tag_wstk_lcd_driver/src/esl_tag_wstk_lcd_driver.c

    +++ b/app/bluetooth/common/esl_tag_wstk_lcd_driver/src/esl_tag_wstk_lcd_driver.c

    @@ -0,0 +1,385 @@

    +/***************************************************************************//**

    + * @file

    + * @brief WSTK display driver implementation for ESL Tag example.

    + *******************************************************************************

    + * # License

    + * <b>Copyright 2021 Silicon Laboratories Inc. www.silabs.com</b>

    + *******************************************************************************

    + *

    + * SPDX-License-Identifier: Zlib

    + *

    + * The licensor of this software is Silicon Laboratories Inc.

    + *

    + * This software is provided ''as-is'', without any express or implied

    + * warranty. In no event will the authors be held liable for any damages

    + * arising from the use of this software.

    + *

    + * Permission is granted to anyone to use this software for any purpose,

    + * including commercial applications, and to alter it and redistribute it

    + * freely, subject to the following restrictions:

    + *

    + * 1. The origin of this software must not be misrepresented; you must not

    + *    claim that you wrote the original software. If you use this software

    + *    in a product, an acknowledgment in the product documentation would be

    + *    appreciated but is not required.

    + * 2. Altered source versions must be plainly marked as such, and must not be

    + *    misrepresented as being the original software.

    + * 3. This notice may not be removed or altered from any source distribution.

    + *

    + ******************************************************************************/

    +#include <stdint.h>

    +#include <stdarg.h>

    +#include "dmd.h"

    +#include "esl_tag_log.h"

    +#include "esl_tag_display.h"

    +#include "sl_board_control.h"

    +#include "sl_common.h"

    +#include "esl_tag_image_core.h"

    +#include "esl_tag_wstk_lcd_driver.h"

    +

    +// Embedded image metadata

    +#define PIC_WIDTH                 (128u)

    +#define PIC_HEIGHT                (128u)

    +#define BITS_PER_PIXEL            (1u)

    +

    +// Calculate the pixel count for a given amount of data bytes

    +#define GetPixelCount(bytes)      ((8u * bytes) / BITS_PER_PIXEL)

    +

    +// An arbitrary size of temporary image buffer - must fit on the stack, though!

    +#define IMAGE_CHUNK_BUFFER_SIZE   (257u) // in bytes

    +

    +// QR placeholder information block

    +PACKSTRUCT(struct qr_ph_s {

    +  const uint8_t magic[16];          /// Magic memory pattern

    +  const uint16_t size;              /// Size of the pic_data placeholder

    +  const uint8_t* volatile qr_data;  /// Pointer to pic_data[]

    +});

    +

    +// Embedded image

    +static const uint8_t pic_data[] = {

    +  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,

    +  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,

    +  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,

    +  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,

    +  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,

    +  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,

    +  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,

    +  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,

    +  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,

    +  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,

    +  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,

    +  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,

    +  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,

    +  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,

    +  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,

    +  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,

    +  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,

    +  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,

    +  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,

    +  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,

    +  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,

    +  0xFF, 0xFF, 0xFF, 0xC7, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,

    +  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFD, 0xBB, 0xFF, 0xFF, 0xFF, 0xFF,

    +  0xFF, 0xFF, 0xF0, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFB, 0xAB,

    +  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x1F, 0xFF, 0xFF, 0x7F, 0x00, 0x00, 0xFE,

    +  0xFF, 0xFF, 0xE7, 0xBB, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xE3, 0xFF, 0xFF,

    +  0x07, 0x00, 0x00, 0xE0, 0xFF, 0xFF, 0x8F, 0xC7, 0xFF, 0xFF, 0xFF, 0xFF,

    +  0x3F, 0xFC, 0xFF, 0x7F, 0x00, 0x00, 0x00, 0x80, 0xFF, 0xFF, 0x0F, 0xFE,

    +  0xFF, 0xFF, 0xFF, 0xFF, 0x87, 0xFF, 0xFF, 0x1F, 0x00, 0x00, 0x00, 0x00,

    +  0xFF, 0xFF, 0x0F, 0xFC, 0xFF, 0xFF, 0xFF, 0xFF, 0xE0, 0xFF, 0xFF, 0x03,

    +  0x00, 0x00, 0x00, 0x00, 0xFE, 0xFF, 0x1F, 0xF8, 0xFF, 0xFF, 0xFF, 0x1F,

    +  0xFC, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFC, 0xFF, 0x0F, 0xE0,

    +  0xFF, 0xFF, 0xFF, 0x07, 0xFF, 0xFF, 0x3F, 0x00, 0x00, 0x00, 0x00, 0x00,

    +  0xFC, 0xFF, 0x0F, 0xE0, 0xFF, 0xFF, 0xFF, 0xC1, 0xFF, 0xFF, 0x0F, 0x00,

    +  0x00, 0x00, 0x00, 0x00, 0xFE, 0xFF, 0x07, 0xC0, 0xFF, 0xFF, 0x7F, 0xE0,

    +  0xFF, 0xFF, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x03, 0xC0,

    +  0xFF, 0xFF, 0x1F, 0xF8, 0xFF, 0xFF, 0x03, 0x00, 0x00, 0x00, 0x00, 0x80,

    +  0xFF, 0xFF, 0x01, 0x80, 0xFF, 0xFF, 0x07, 0xFC, 0xFF, 0xFF, 0x01, 0x00,

    +  0x00, 0x00, 0x00, 0xC0, 0xFF, 0x7F, 0x00, 0x80, 0xFF, 0xFF, 0x00, 0xFE,

    +  0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x03, 0x00, 0x80,

    +  0xFF, 0x3F, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

    +  0x00, 0x00, 0x00, 0x80, 0xFF, 0x1F, 0x80, 0xFF, 0xFF, 0x7F, 0x00, 0x00,

    +  0xE0, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0xC0, 0xFF, 0x0F, 0x80, 0xFF,

    +  0xFF, 0x7F, 0x00, 0xF0, 0xFF, 0xFF, 0xFF, 0x7F, 0x00, 0x00, 0x00, 0xC0,

    +  0xFF, 0x03, 0x80, 0xFF, 0xFF, 0xFF, 0xC0, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,

    +  0x0F, 0x00, 0x00, 0xC0, 0xFF, 0x00, 0x80, 0xFF, 0xFF, 0xFF, 0xE1, 0xFF,

    +  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0xE0, 0x7F, 0x00, 0x80, 0xFF,

    +  0xFF, 0xFF, 0x03, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x01, 0x00, 0xF0,

    +  0x3F, 0x00, 0x80, 0xFF, 0xFF, 0xFF, 0x07, 0x00, 0xFF, 0xFF, 0xFF, 0xFF,

    +  0xFF, 0x03, 0x00, 0xF8, 0x1F, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x3F, 0x00,

    +  0x00, 0xF8, 0xFF, 0xFF, 0xFF, 0x07, 0x00, 0xFC, 0x0F, 0x00, 0x00, 0xFE,

    +  0xFF, 0xFF, 0xFF, 0x07, 0x00, 0x80, 0xFF, 0xFF, 0xFF, 0x0F, 0x00, 0xFC,

    +  0x0F, 0x00, 0x00, 0xFC, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x03, 0xFE, 0xFF,

    +  0xFF, 0x0F, 0x00, 0xFF, 0x07, 0x00, 0x00, 0xE0, 0xFF, 0xFF, 0xFF, 0xFF,

    +  0xFF, 0x3F, 0xF8, 0xFF, 0xFF, 0x0F, 0x80, 0xFF, 0x03, 0x00, 0x00, 0x00,

    +  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x07, 0xF8, 0xFF, 0xFF, 0x0F, 0xE0, 0xFF,

    +  0x03, 0x00, 0x00, 0x00, 0xE0, 0xFF, 0xFF, 0xFF, 0x0F, 0x00, 0xF0, 0xFF,

    +  0xFF, 0x0F, 0xF0, 0xFF, 0x01, 0x00, 0x00, 0x00, 0x00, 0x80, 0x7F, 0x00,

    +  0x00, 0x00, 0xF0, 0xFF, 0xFF, 0x07, 0xF8, 0xFF, 0x01, 0x00, 0x00, 0x00,

    +  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF0, 0xFF, 0xFF, 0x07, 0xFE, 0xFF,

    +  0x01, 0x00, 0x00, 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF8, 0xFF,

    +  0xFF, 0x83, 0xFF, 0xFF, 0x01, 0x00, 0xC0, 0xFF, 0x01, 0x00, 0x00, 0x00,

    +  0x00, 0x00, 0xF8, 0xFF, 0xFF, 0xE0, 0xFF, 0xFF, 0x01, 0x00, 0xF0, 0xFF,

    +  0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFE, 0xFF, 0x7F, 0xFC, 0xFF, 0xFF,

    +  0x01, 0x00, 0xF8, 0xFF, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF,

    +  0x1F, 0xFE, 0xFF, 0xFF, 0x03, 0x00, 0xFE, 0xFF, 0x03, 0x00, 0x00, 0x00,

    +  0x00, 0x80, 0xFF, 0xFF, 0xCF, 0xFF, 0xFF, 0xFF, 0x07, 0x00, 0xFF, 0xFF,

    +  0x01, 0x00, 0x00, 0x00, 0x00, 0xE0, 0xFF, 0xFF, 0xF1, 0xFF, 0xFF, 0xFF,

    +  0x07, 0x80, 0xFF, 0xFF, 0x03, 0x00, 0x00, 0x00, 0x00, 0xF8, 0xFF, 0x7F,

    +  0xFE, 0xFF, 0xFF, 0xFF, 0x1F, 0x80, 0xFF, 0xFF, 0x07, 0x00, 0x00, 0x00,

    +  0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x3F, 0x80, 0xFF, 0xFF,

    +  0x1F, 0x00, 0x00, 0x00, 0xF0, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,

    +  0x7F, 0x80, 0xFF, 0xFF, 0x7F, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF,

    +  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x81, 0xFF, 0xFF, 0xFF, 0x0F, 0x00, 0xFC,

    +  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x07, 0xFF, 0xFF,

    +  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,

    +  0xFF, 0x7F, 0xFC, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,

    +  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xE3, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,

    +  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,

    +  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,

    +  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,

    +  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,

    +  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,

    +  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,

    +  0x03, 0x3F, 0x9F, 0x7F, 0x7E, 0xE0, 0x07, 0x3E, 0xCF, 0xFF, 0x9F, 0xFF,

    +  0xF7, 0x0F, 0xF8, 0xC0, 0x01, 0x3E, 0x9F, 0x7F, 0x3E, 0xC0, 0x03, 0x3C,

    +  0xCE, 0xFF, 0x9F, 0xFF, 0xE3, 0x0F, 0x70, 0x80, 0x79, 0x3E, 0x9F, 0x7F,

    +  0x3E, 0xCF, 0xF3, 0x3C, 0xCE, 0xFF, 0x9F, 0xFF, 0xE3, 0xCF, 0x73, 0x9E,

    +  0xF9, 0x3F, 0x9F, 0x7F, 0x3E, 0xFF, 0xF3, 0x3C, 0xCC, 0xFF, 0x9F, 0xFF,

    +  0xC9, 0xCF, 0x73, 0xFE, 0xF9, 0x3F, 0x9F, 0x7F, 0x3E, 0xFF, 0xF3, 0x3C,

    +  0xCC, 0xFF, 0x9F, 0xFF, 0xC9, 0xCF, 0x73, 0xFE, 0xE1, 0x3F, 0x9F, 0x7F,

    +  0x3E, 0xFF, 0xF3, 0x3C, 0xCC, 0xFF, 0x9F, 0xFF, 0xC9, 0xCF, 0x7B, 0xF8,

    +  0x07, 0x3F, 0x9F, 0x7F, 0x3E, 0xFF, 0xF3, 0x3C, 0xC9, 0xFF, 0x9F, 0xFF,

    +  0x9C, 0x0F, 0xFC, 0xC1, 0x3F, 0x3E, 0x9F, 0x7F, 0x3E, 0xFF, 0xF3, 0x3C,

    +  0xC9, 0xFF, 0x9F, 0xFF, 0x9C, 0x0F, 0xF8, 0x8F, 0x7F, 0x3E, 0x9F, 0x7F,

    +  0x3E, 0xFF, 0xF3, 0x3C, 0xC3, 0xFF, 0x9F, 0xFF, 0x9C, 0xCF, 0xF3, 0x9F,

    +  0x7F, 0x3E, 0x9F, 0x7F, 0x3E, 0xFF, 0xF3, 0x3C, 0xC3, 0xFF, 0x9F, 0xFF,

    +  0x80, 0xCF, 0xF3, 0x9F, 0x79, 0x3E, 0x9F, 0x7F, 0x3E, 0xCF, 0xF3, 0x3C,

    +  0xC7, 0xFF, 0x9F, 0x7F, 0x00, 0xCF, 0x73, 0x9E, 0x79, 0x3E, 0x9F, 0x7F,

    +  0x3E, 0xCF, 0xF3, 0x3C, 0xC7, 0xFF, 0x9F, 0x7F, 0x3E, 0xCF, 0x73, 0x9E,

    +  0x01, 0x3E, 0x1F, 0x70, 0x3E, 0xC0, 0x03, 0x3C, 0xC7, 0xFF, 0x1F, 0x70,

    +  0x3E, 0x0F, 0x78, 0x80, 0x03, 0x3F, 0x1F, 0x70, 0x7E, 0xE0, 0x07, 0x3E,

    +  0xCF, 0xFF, 0x1F, 0x70, 0x3E, 0x0F, 0xFC, 0xC0, 0xFF, 0xFF, 0xFF, 0xFF,

    +  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,

    +  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,

    +  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,

    +  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,

    +  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,

    +  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,

    +  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,

    +  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,

    +  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,

    +  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,

    +  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,

    +  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,

    +  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,

    +  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,

    +  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,

    +  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,

    +  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,

    +  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,

    +  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,

    +  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,

    +  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,

    +  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xDF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,

    +  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xC1, 0xFE, 0xFF, 0xFF, 0xFF, 0xDF, 0xFF,

    +  0xE3, 0xFE, 0xDF, 0x7D, 0xFF, 0xEF, 0xFF, 0xFD, 0xFF, 0xFD, 0xFE, 0x7F,

    +  0xFF, 0xFF, 0xFF, 0xFF, 0xDD, 0xFE, 0xDF, 0x7E, 0xFF, 0xEF, 0xFF, 0xFD,

    +  0xFF, 0xFD, 0xCE, 0x33, 0xD6, 0x38, 0xDC, 0xF9, 0xDD, 0xF0, 0x5C, 0x7C,

    +  0x7F, 0x0E, 0xCF, 0xFD, 0xFF, 0xFD, 0xB6, 0x6D, 0x67, 0xB7, 0xDB, 0xF6,

    +  0xF9, 0x6E, 0xDB, 0x7E, 0xBF, 0x6D, 0xB7, 0xFD, 0xFF, 0xC1, 0xB6, 0x7D,

    +  0x77, 0xB7, 0xDB, 0xFE, 0xC3, 0x6E, 0xDB, 0x7E, 0xFF, 0xED, 0xB6, 0xFD,

    +  0xFF, 0xFD, 0x86, 0x7D, 0x77, 0xB7, 0xDB, 0xFE, 0xDF, 0x6E, 0xD8, 0x7E,

    +  0x7F, 0xEC, 0x86, 0xFD, 0xFF, 0xFD, 0xF6, 0x7D, 0x77, 0xB7, 0xDB, 0xFE,

    +  0xDD, 0x6E, 0xDF, 0x7E, 0xBF, 0xED, 0xF6, 0xFD, 0xFF, 0xFD, 0xB6, 0x6D,

    +  0x77, 0xB7, 0xDB, 0xF6, 0xDD, 0x6E, 0xDB, 0x7E, 0xBF, 0x6D, 0xB7, 0xFD,

    +  0xFF, 0xC1, 0xCE, 0xF3, 0xF6, 0xB8, 0xDB, 0xF9, 0xE3, 0xEE, 0xDC, 0x7E,

    +  0x30, 0x0C, 0xCF, 0xFD, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,

    +  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,

    +  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,

    +  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,

    +  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,

    +  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,

    +  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,

    +  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,

    +  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,

    +  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,

    +  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,

    +  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,

    +  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,

    +  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,

    +  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,

    +  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,

    +  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,

    +  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,

    +  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,

    +  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,

    +  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,

    +  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,

    +  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,

    +  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,

    +  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,

    +  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,

    +  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,

    +  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,

    +  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,

    +  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,

    +  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,

    +  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,

    +  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,

    +  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF

    +};

    +

    +#define MAGIC_DATA_OFFSET 1164

    +

    +// data slice from pic_data at @MAGIC_DATA_OFFSET

    +static const uint8_t original_magic[] = {

    +  0x80, 0xCF, 0xF3, 0x9F, 0x79, 0x3E, 0x9F, 0x7F, 0x3E, 0xCF, 0xF3, 0x3C

    +};

    +

    +// QR placeholder information block

    +const struct qr_ph_s qr_info = {

    +  .magic = {

    +    ''.'', ''q'', ''r'', ''c'',

    +    ''_'', ''p'', ''h'', ''_'',

    +    ''p'', ''i'', ''c'', ''_'',

    +    ''d'', ''a'', ''t'', ''a''

    +  },

    +  .size = sizeof(pic_data),

    +  .qr_data = pic_data

    +};

    +

    +bool esl_wstk_lcd_is_logo()

    +{

    +  if (memcmp(&original_magic,

    +             &(qr_info.qr_data[MAGIC_DATA_OFFSET]),

    +             sizeof(original_magic)) == 0) {

    +    return true;

    +  } else {

    +    return false;

    +  }

    +}

    +

    +sl_status_t esl_wstk_lcd_write(int param_count, ...)

    +{

    +  // Declaring pointer to the argument list

    +  va_list               ptr;

    +  EMSTATUS              status;

    +  sl_status_t           result = SL_STATUS_FAIL;

    +  DMD_DisplayGeometry*  pgeometry;

    +  uint8_t               image_index;

    +

    +  // LCD write_func: Invalid parameters!

    +  sl_bt_esl_assert(param_count == ESL_DISPLAY_WRITE_FUNC_PARAMETERS_COUNT);

    +

    +  // initializing argument to the list pointer

    +  va_start(ptr, param_count);

    +

    +  // accessing variables (after each call to va_arg our ptr points to next one)

    +  (void)va_arg(ptr, int); // this simple driver just ignores the display index!

    +  image_index = (uint8_t)va_arg(ptr, int);

    +

    +  // end argument list traversal

    +  va_end(ptr);

    +

    +  // get display geometry data

    +  status = DMD_getDisplayGeometry(&pgeometry);

    +

    +  if (status == DMD_OK) {

    +    uint8_t        data[IMAGE_CHUNK_BUFFER_SIZE];

    +    uint16_t       offset     = 0;

    +    uint16_t       read_count = 1;

    +

    +    result = SL_STATUS_OK;

    +

    +    while (result == SL_STATUS_OK && read_count) {

    +      uint16_t x_offset = GetPixelCount(offset) % pgeometry->clipWidth;

    +      uint16_t y_offset = GetPixelCount(offset) / pgeometry->clipHeight;

    +

    +      read_count = offset;  // temporary storage

    +      result = esl_image_get_data(image_index, &offset, sizeof(data), data);

    +

    +      read_count = offset - read_count;

    +

    +      status = DMD_ERROR_TEST_FAILED;

    +      if (result == SL_STATUS_OK) {

    +        status = DMD_writeData(x_offset, y_offset, data,

    +                               GetPixelCount(read_count));

    +        if (status == DMD_OK) {

    +          status = DMD_updateDisplay();

    +        }

    +      }

    +

    +      if (status != DMD_OK) {

    +        result = SL_STATUS_FAIL;

    +      }

    +    }

    +  }

    +

    +  return result;

    +}

    +

    +SL_WEAK sl_status_t esl_tag_wstk_lcd_run_qrcode()

    +{

    +  return SL_STATUS_OK;

    +}

    +

    +sl_status_t esl_wstk_lcd_init(int param_count, ...)

    +{

    +  sl_status_t result = SL_STATUS_FAIL;

    +  EMSTATUS    status;

    +

    +  // this simple driver ignores all the parameters

    +  (void)param_count;

    +

    +  // enable the DMD HW module for the DISPLAY device driver.

    +  sl_board_enable_display();

    +

    +  status = DMD_init(0);

    +  // Failed to init display driver

    +  sl_bt_esl_assert(DMD_OK == status);

    +

    +  // write initial bitmap to display

    +  status = DMD_writeData(0, 0, qr_info.qr_data, 8 * qr_info.size);

    +

    +  if (status == DMD_OK) {

    +    // refresh visible content of the display

    +    status = DMD_updateDisplay();

    +    status = esl_tag_wstk_lcd_run_qrcode();

    +  }

    +  // put the LCD display into sleep mode - greatly reduces power consumption
    by

    +  // disabling auto-refresh, while still allowing static images to be displayed

    +  (void)DMD_sleep();

    +

    +  return result;

    +}

    +

    +void esl_wstk_lcd_bt_on_event(sl_bt_msg_t *evt)

    +{

    +  sl_status_t sc;

    +  (void)sc; // suppress the compiler warning if sl_bt_esl_assert disabled

    +

    +  // This event shall precede the esl_core_bt_on_event ahdnler, and hence the

    +  // esl_core_boot handler invocation. Only then we can assure that the WST LCD

    +  // will be registered as the very first one in the list of available displays.

    +  switch (SL_BT_MSG_ID(evt->header)) {

    +    case sl_bt_evt_system_boot_id:

    +      // here we''re checking that we precede the esl_core_bt_on_event invocation

    +      if (esl_core_get_status() == esl_state_boot) {

    +        esl_display_info_p info;

    +        // create the display info characteristic data

    +        sc = esl_display_create(PIC_WIDTH,

    +                                PIC_HEIGHT,

    +                                ESL_DISPLAY_TYPE_BLACK_WHITE,

    +                                &info);

    +        sl_bt_esl_assert(sc == SL_STATUS_OK);

    +        // register display we just created temporary - this makes it permanent

    +        sc = esl_display_add(info, esl_wstk_lcd_init, esl_wstk_lcd_write);

    +        sl_bt_esl_assert(sc == SL_STATUS_OK);

    +      }

    +      break;

    +

    +    default:

    +      break;

    +  }

    +}'
  - "--- a/app/bluetooth/common/gatt_service_battery/sl_gatt_service_battery.c\n+++\
    \ b/app/bluetooth/common/gatt_service_battery/sl_gatt_service_battery.c\n@@ -30,7\
    \ +30,7 @@\n \n #include \"em_common.h\"\n #include \"sl_status.h\"\n-#include\
    \ \"sl_simple_timer.h\"\n+#include \"app_timer.h\"\n #include \"gatt_db.h\"\n\
    \ #include \"app_assert.h\"\n #include \"sl_gatt_service_battery.h\"\n@@ -43,14\
    \ +43,14 @@\n // -----------------------------------------------------------------------------\n\
    \ // Private variables\n \n-static sl_simple_timer_t batt_timer;\n+static app_timer_t\
    \ batt_timer;\n static uint8_t batt_connection = 0;\n \n // -----------------------------------------------------------------------------\n\
    \ // Private function declarations\n \n static void batt_measurement_notify(void);\n\
    -static void batt_timer_cb(sl_simple_timer_t *timer, void *data);\n+static void\
    \ batt_timer_cb(app_timer_t *timer, void *data);\n static void batt_connection_closed_cb(sl_bt_evt_connection_closed_t\
    \ *data);\n static void batt_measurement_read_cb(sl_bt_evt_gatt_server_user_read_request_t\
    \ *data);\n static void batt_type_read_cb(sl_bt_evt_gatt_server_user_read_request_t\
    \ *data);\n@@ -71,7 +71,7 @@ static void batt_measurement_notify(void)\n   app_assert_status(sc);\n\
    \ }\n \n-static void batt_timer_cb(sl_simple_timer_t *timer, void *data)\n+static\
    \ void batt_timer_cb(app_timer_t *timer, void *data)\n {\n   (void)data;\n   (void)timer;\n\
    @@ -83,7 +83,7 @@ static void batt_connection_closed_cb(sl_bt_evt_connection_closed_t\
    \ *data)\n {\n   (void)data;\n   sl_status_t sc;\n-  sc = sl_simple_timer_stop(&batt_timer);\n\
    +  sc = app_timer_stop(&batt_timer);\n   app_assert_status(sc);\n }\n \n@@ -122,19\
    \ +122,19 @@ static void batt_measurement_changed_cb(sl_bt_evt_gatt_server_characteristic_sta\n\
    \   // indication or notification enabled\n   if (sl_bt_gatt_disable != data->client_config_flags)\
    \ {\n     // start timer used for periodic notifications\n-    sc = sl_simple_timer_start(&batt_timer,\n\
    -                               BATT_MEASUREMENT_INTERVAL_MS,\n-             \
    \                  batt_timer_cb,\n-                               NULL,\n-  \
    \                             true);\n+    sc = app_timer_start(&batt_timer,\n\
    +                         BATT_MEASUREMENT_INTERVAL_MS,\n+                   \
    \      batt_timer_cb,\n+                         NULL,\n+                    \
    \     true);\n     app_assert_status(sc);\n     // Send the first notification\n\
    \     batt_measurement_notify();\n   }\n   // indication and notifications disabled\n\
    \   else {\n     // stop timer used for periodic notifications\n-    sc = sl_simple_timer_stop(&batt_timer);\n\
    +    sc = app_timer_stop(&batt_timer);\n     app_assert_status(sc);\n   }\n }"
  - "--- a/app/bluetooth/common/gatt_service_hall/sl_gatt_service_hall.c\n+++ b/app/bluetooth/common/gatt_service_hall/sl_gatt_service_hall.c\n\
    @@ -32,7 +32,7 @@\n #include \"em_core.h\"\n #include \"em_common.h\"\n #include\
    \ \"sl_status.h\"\n-#include \"sl_simple_timer.h\"\n+#include \"app_timer.h\"\n\
    \ #include \"gatt_db.h\"\n #include \"app_assert.h\"\n #include \"sl_gatt_service_hall.h\"\
    \n@@ -56,7 +56,7 @@\n // -----------------------------------------------------------------------------\n\
    \ // Private variables\n \n-static sl_simple_timer_t hall_timer;\n+static app_timer_t\
    \ hall_timer;\n static uint8_t hall_connection = 0;\n \n // Field strength characteristic\
    \ variables\n@@ -74,7 +74,7 @@ static bool hall_tamper_latch = false;\n static\
    \ void hall_update(void);\n static void hall_field_strength_notify(void);\n static\
    \ void hall_state_notify(void);\n-static void hall_timer_cb(sl_simple_timer_t\
    \ *timer, void *data);\n+static void hall_timer_cb(app_timer_t *timer, void *data);\n\
    \ static void hall_connection_closed_cb(sl_bt_evt_connection_closed_t *data);\n\
    \ static void hall_char_read_cb(sl_bt_evt_gatt_server_user_read_request_t *data);\n\
    \ static void hall_char_config_changed_cb(sl_bt_evt_gatt_server_characteristic_status_t\
    \ *data);\n@@ -139,7 +139,7 @@ static void hall_state_notify(void)\n   app_assert_status(sc);\n\
    \ }\n \n-static void hall_timer_cb(sl_simple_timer_t * timer, void *data)\n+static\
    \ void hall_timer_cb(app_timer_t * timer, void *data)\n {\n   (void)data;\n  \
    \ (void)timer;\n@@ -160,7 +160,7 @@ static void hall_connection_closed_cb(sl_bt_evt_connection_closed_t\
    \ * data)\n   (void)data;\n   sl_status_t sc;\n   // stop periodic timer\n-  sc\
    \ = sl_simple_timer_stop(&hall_timer);\n+  sc = app_timer_stop(&hall_timer);\n\
    \   app_assert_status(sc);\n   // reset notification flags\n   hall_field_strength_notification\
    \ = false;\n@@ -229,14 +229,14 @@ static void hall_char_config_changed_cb(sl_bt_evt_gatt_server_characteristic_sta\n\
    \ \n   // start periodic timer if any of the notifications are enabled\n   if\
    \ (hall_field_strength_notification || hall_state_notification) {\n-    sc = sl_simple_timer_start(&hall_timer,\n\
    -                               HALL_MEASUREMENT_INTERVAL_MS,\n-             \
    \                  hall_timer_cb,\n-                               NULL,\n-  \
    \                             true);\n+    sc = app_timer_start(&hall_timer,\n\
    +                         HALL_MEASUREMENT_INTERVAL_MS,\n+                   \
    \      hall_timer_cb,\n+                         NULL,\n+                    \
    \     true);\n     app_assert_status(sc);\n   } else {\n-    sc = sl_simple_timer_stop(&hall_timer);\n\
    +    sc = app_timer_stop(&hall_timer);\n     app_assert_status(sc);\n   }\n }"
  identifiers: CVE:["CVE-2024-0240"],CWE:["CWE-400"]
  overview: Affected versions of this package are vulnerable to Uncontrolled Resource
    Consumption due to a memory leak in the Bluetooth stack for EFR32 products. An
    attacker can cause memory to be exhausted when sending notifications to multiple
    clients, resulting in all Bluetooth operations, such as advertising and scanning,
    to stop.
  references:
    GitHub Commit: https://github.com/SiliconLabs/gecko_sdk/commit/551fb8d0f659a56dcb0abde93cef7b8464bf0ac6
  title: Uncontrolled Resource Consumption
- diff_content:
  - "--- a/src/dtls13.c\n+++ b/src/dtls13.c\n@@ -363,6 +363,14 @@ int Dtls13ProcessBufferedMessages(WOLFSSL*\
    \ ssl)\n         if (!msg->ready)\n             break;\n \n+#ifndef WOLFSSL_DISABLE_EARLY_SANITY_CHECKS\n\
    +        ret = MsgCheckEncryption(ssl, msg->type, msg->encrypted);\n+        if\
    \ (ret != 0) {\n+            SendAlert(ssl, alert_fatal, unexpected_message);\n\
    +            break;\n+        }\n+#endif\n+\n         /* We may have DTLS <=1.2\
    \ msgs stored from before we knew which version\n          * we were going to\
    \ use. Interpret correctly. */\n         if (IsAtLeastTLSv1_3(ssl->version)) {\n\
    @@ -1622,6 +1630,13 @@ static int _Dtls13HandshakeRecv(WOLFSSL* ssl, byte* input,\
    \ word32 size,\n     if (ret != 0)\n         return PARSE_ERROR;\n \n+    /* Need\
    \ idx + fragLength as we don't advance the inputBuffer idx value */\n+    ret\
    \ = EarlySanityCheckMsgReceived(ssl, handshakeType, idx + fragLength);\n+    if\
    \ (ret != 0) {\n+        WOLFSSL_ERROR(ret);\n+        return ret;\n+    }\n+\n\
    \     if (ssl->options.side == WOLFSSL_SERVER_END &&\n             ssl->options.acceptState\
    \ < TLS13_ACCEPT_FIRST_REPLY_DONE) {\n         if (handshakeType != client_hello)\
    \ {"
  - "--- a/src/internal.c\n+++ b/src/internal.c\n@@ -547,7 +547,7 @@ int IsAtLeastTLSv1_3(const\
    \ ProtocolVersion pv)\n     return ret;\n }\n \n-int IsEncryptionOn(WOLFSSL* ssl,\
    \ int isSend)\n+int IsEncryptionOn(const WOLFSSL* ssl, int isSend)\n {\n     #ifdef\
    \ WOLFSSL_DTLS\n     /* For DTLS, epoch 0 is always not encrypted. */\n@@ -4688,7\
    \ +4688,7 @@ static void SetDigest(WOLFSSL* ssl, int hashAlgo)\n #endif /* !NO_CERTS\
    \ */\n \n #if defined(HAVE_ENCRYPT_THEN_MAC) && !defined(WOLFSSL_AEAD_ONLY)\n\
    -static word32 MacSize(WOLFSSL* ssl)\n+static word32 MacSize(const WOLFSSL* ssl)\n\
    \ {\n #ifdef HAVE_TRUNCATED_HMAC\n     word32 digestSz = ssl->truncated_hmac ?\
    \ (byte)TRUNCATED_HMAC_SZ\n@@ -8972,7 +8972,8 @@ static void DtlsMsgAssembleCompleteMessage(DtlsMsg*\
    \ msg)\n }\n \n int DtlsMsgSet(DtlsMsg* msg, word32 seq, word16 epoch, const byte*\
    \ data, byte type,\n-               word32 fragOffset, word32 fragSz, void* heap,\
    \ word32 totalLen)\n+               word32 fragOffset, word32 fragSz, void* heap,\
    \ word32 totalLen,\n+               byte encrypted)\n {\n     word32 fragOffsetEnd\
    \ = fragOffset + fragSz;\n \n@@ -8993,11 +8994,13 @@ int DtlsMsgSet(DtlsMsg* msg,\
    \ word32 seq, word16 epoch, const byte* data, byte ty\n             WOLFSSL_ERROR_VERBOSE(SEQUENCE_ERROR);\n\
    \             return SEQUENCE_ERROR;\n         }\n+        msg->encrypted = msg->encrypted\
    \ && encrypted;\n     }\n     else {\n         msg->type = type;\n         msg->epoch\
    \ = epoch;\n         msg->seq = seq;\n+        msg->encrypted = encrypted;\n \
    \    }\n \n     if (msg->fragBucketList == NULL) {\n@@ -9118,6 +9121,7 @@ void\
    \ DtlsMsgStore(WOLFSSL* ssl, word16 epoch, word32 seq, const byte* data,\n   \
    \   */\n \n     DtlsMsg* head = ssl->dtls_rx_msg_list;\n+    byte encrypted =\
    \ ssl->keys.decryptedCur == 1;\n     WOLFSSL_ENTER(\"DtlsMsgStore\");\n \n   \
    \  if (head != NULL) {\n@@ -9126,7 +9130,7 @@ void DtlsMsgStore(WOLFSSL* ssl,\
    \ word16 epoch, word32 seq, const byte* data,\n             cur = DtlsMsgNew(dataSz,\
    \ 0, heap);\n             if (cur != NULL) {\n                 if (DtlsMsgSet(cur,\
    \ seq, epoch, data, type,\n-                                       fragOffset,\
    \ fragSz, heap, dataSz) < 0) {\n+                             fragOffset, fragSz,\
    \ heap, dataSz, encrypted) < 0) {\n                     DtlsMsgDelete(cur, heap);\n\
    \                 }\n                 else {\n@@ -9138,13 +9142,13 @@ void DtlsMsgStore(WOLFSSL*\
    \ ssl, word16 epoch, word32 seq, const byte* data,\n         else {\n        \
    \     /* If this fails, the data is just dropped. */\n             DtlsMsgSet(cur,\
    \ seq, epoch, data, type, fragOffset,\n-                    fragSz, heap, dataSz);\n\
    +                    fragSz, heap, dataSz, encrypted);\n         }\n     }\n \
    \    else {\n         head = DtlsMsgNew(dataSz, 0, heap);\n         if (DtlsMsgSet(head,\
    \ seq, epoch, data, type, fragOffset,\n-                    fragSz, heap, dataSz)\
    \ < 0) {\n+                    fragSz, heap, dataSz, encrypted) < 0) {\n     \
    \        DtlsMsgDelete(head, heap);\n             head = NULL;\n         }\n@@\
    \ -10714,6 +10718,297 @@ int CheckAvailableSize(WOLFSSL *ssl, int size)\n    \
    \ return 0;\n }\n \n+#ifndef WOLFSSL_DISABLE_EARLY_SANITY_CHECKS\n+\n+int MsgCheckEncryption(WOLFSSL*\
    \ ssl, byte type, byte encrypted)\n+{\n+#ifdef WOLFSSL_QUIC\n+    /* QUIC protects\
    \ messages outside of the TLS scope */\n+    if (WOLFSSL_IS_QUIC(ssl) && IsAtLeastTLSv1_3(ssl->version))\n\
    +        return 0;\n+#endif\n+    /* Verify which messages always have to be encrypted\
    \ */\n+    if (IsAtLeastTLSv1_3(ssl->version)) {\n+        switch ((enum HandShakeType)type)\
    \ {\n+            case client_hello:\n+            case server_hello:\n+     \
    \       case hello_verify_request:\n+            case hello_retry_request:\n+\
    \            case change_cipher_hs:\n+                if (encrypted) {\n+    \
    \                WOLFSSL_MSG(\"Message can not be encrypted\");\n+           \
    \         WOLFSSL_ERROR_VERBOSE(OUT_OF_ORDER_E);\n+                    return\
    \ OUT_OF_ORDER_E;\n+                }\n+                break;\n+            case\
    \ hello_request:\n+            case session_ticket:\n+            case end_of_early_data:\n\
    +            case encrypted_extensions:\n+            case certificate:\n+   \
    \         case server_key_exchange:\n+            case certificate_request:\n\
    +            case server_hello_done:\n+            case certificate_verify:\n\
    +            case client_key_exchange:\n+            case finished:\n+       \
    \     case certificate_status:\n+            case key_update:\n+             \
    \   if (!encrypted) {\n+                    WOLFSSL_MSG(\"Message always has to\
    \ be encrypted\");\n+                    WOLFSSL_ERROR_VERBOSE(OUT_OF_ORDER_E);\n\
    +                    return OUT_OF_ORDER_E;\n+                }\n+           \
    \     break;\n+            case message_hash:\n+            case no_shake:\n+\
    \            default:\n+                WOLFSSL_MSG(\"Unknown message type\");\n\
    +                WOLFSSL_ERROR_VERBOSE(SANITY_MSG_E);\n+                return\
    \ SANITY_MSG_E;\n+        }\n+    }\n+    else {\n+        switch ((enum HandShakeType)type)\
    \ {\n+            case client_hello:\n+                if ((IsSCR(ssl) || ssl->options.handShakeDone)\
    \ && !encrypted) {\n+                    WOLFSSL_MSG(\"Message has to be encrypted\
    \ for SCR\");\n+                    WOLFSSL_ERROR_VERBOSE(OUT_OF_ORDER_E);\n+\
    \                    return OUT_OF_ORDER_E;\n+                }\n+           \
    \     break;\n+            case server_hello:\n+            case hello_verify_request:\n\
    +            case hello_retry_request:\n+            case certificate:\n+    \
    \        case server_key_exchange:\n+            case certificate_request:\n+\
    \            case server_hello_done:\n+            case certificate_verify:\n\
    +            case client_key_exchange:\n+            case certificate_status:\n\
    +            case session_ticket:\n+            case change_cipher_hs:\n+    \
    \            if (IsSCR(ssl)) {\n+                    if (!encrypted) {\n+    \
    \                    WOLFSSL_MSG(\"Message has to be encrypted during SCR\");\n\
    +                        WOLFSSL_ERROR_VERBOSE(OUT_OF_ORDER_E);\n+           \
    \             return OUT_OF_ORDER_E;\n+                    }\n+              \
    \  }\n+                else if (encrypted) {\n+                    WOLFSSL_MSG(\"\
    Message can not be encrypted in regular \"\n+                                \"\
    handshake\");\n+                    WOLFSSL_ERROR_VERBOSE(OUT_OF_ORDER_E);\n+\
    \                    return OUT_OF_ORDER_E;\n+                }\n+           \
    \     break;\n+            case hello_request:\n+            case finished:\n\
    +                if (!encrypted) {\n+                    WOLFSSL_MSG(\"Message\
    \ always has to be encrypted\");\n+                    WOLFSSL_ERROR_VERBOSE(OUT_OF_ORDER_E);\n\
    +                    return OUT_OF_ORDER_E;\n+                }\n+           \
    \     break;\n+            case key_update:\n+            case encrypted_extensions:\n\
    +            case end_of_early_data:\n+            case message_hash:\n+     \
    \       case no_shake:\n+            default:\n+                WOLFSSL_MSG(\"\
    Unknown message type\");\n+                WOLFSSL_ERROR_VERBOSE(SANITY_MSG_E);\n\
    +                return SANITY_MSG_E;\n+        }\n+    }\n+    return 0;\n+}\n\
    +\n+static WC_INLINE int isLastMsg(const WOLFSSL* ssl, word32 msgSz)\n+{\n+  \
    \  word32 extra = 0;\n+    if (IsEncryptionOn(ssl, 0)) {\n+        extra = ssl->keys.padSz;\n\
    +#if defined(HAVE_ENCRYPT_THEN_MAC) && !defined(WOLFSSL_AEAD_ONLY)\n+        if\
    \ (ssl->options.startedETMRead)\n+            extra += MacSize(ssl);\n+#endif\n\
    +    }\n+    return (ssl->buffers.inputBuffer.idx - ssl->curStartIdx) + msgSz\
    \ + extra\n+            == ssl->curSize;\n+}\n+\n+/* Check if the msg is the last\
    \ msg in a record. This is also an easy way\n+ * to check that a record doesn't\
    \ span different key boundaries. */\n+static int MsgCheckBoundary(const WOLFSSL*\
    \ ssl, byte type,\n+        byte version_negotiated, word32 msgSz)\n+{\n+    if\
    \ (version_negotiated) {\n+        if (IsAtLeastTLSv1_3(ssl->version)) {\n+  \
    \          switch ((enum HandShakeType)type) {\n+                case hello_request:\n\
    +                case client_hello:\n+                case server_hello:\n+  \
    \              case hello_verify_request:\n+                case hello_retry_request:\n\
    +                case finished:\n+                case end_of_early_data:\n+ \
    \                   if (!isLastMsg(ssl, msgSz)) {\n+                        WOLFSSL_MSG(\"\
    Message type is not last in record\");\n+                        WOLFSSL_ERROR_VERBOSE(OUT_OF_ORDER_E);\n\
    +                        return OUT_OF_ORDER_E;\n+                    }\n+   \
    \                 break;\n+                case session_ticket:\n+           \
    \     case encrypted_extensions:\n+                case certificate:\n+      \
    \          case server_key_exchange:\n+                case certificate_request:\n\
    +                case certificate_verify:\n+                case client_key_exchange:\n\
    +                case certificate_status:\n+                case key_update:\n\
    +                case change_cipher_hs:\n+                    break;\n+      \
    \          case server_hello_done:\n+                case message_hash:\n+   \
    \             case no_shake:\n+                default:\n+                   \
    \ WOLFSSL_MSG(\"Unknown message type\");\n+                    WOLFSSL_ERROR_VERBOSE(SANITY_MSG_E);\n\
    +                    return SANITY_MSG_E;\n+            }\n+        }\n+     \
    \   else {\n+            switch ((enum HandShakeType)type) {\n+              \
    \  case hello_request:\n+                case client_hello:\n+               \
    \ case hello_verify_request:\n+                    if (!isLastMsg(ssl, msgSz))\
    \ {\n+                        WOLFSSL_MSG(\"Message type is not last in record\"\
    );\n+                        WOLFSSL_ERROR_VERBOSE(OUT_OF_ORDER_E);\n+       \
    \                 return OUT_OF_ORDER_E;\n+                    }\n+          \
    \          break;\n+                case server_hello:\n+                case\
    \ session_ticket:\n+                case end_of_early_data:\n+               \
    \ case certificate:\n+                case server_key_exchange:\n+           \
    \     case certificate_request:\n+                case server_hello_done:\n+ \
    \               case certificate_verify:\n+                case client_key_exchange:\n\
    +                case finished:\n+                case certificate_status:\n+\
    \                case change_cipher_hs:\n+                    break;\n+      \
    \          case hello_retry_request:\n+                case encrypted_extensions:\n\
    +                case key_update:\n+                case message_hash:\n+    \
    \            case no_shake:\n+                default:\n+                    WOLFSSL_MSG(\"\
    Unknown message type\");\n+                    WOLFSSL_ERROR_VERBOSE(SANITY_MSG_E);\n\
    +                    return SANITY_MSG_E;\n+            }\n+        }\n+    }\n\
    +    else {\n+        switch ((enum HandShakeType)type) {\n+            case hello_request:\n\
    +            case client_hello:\n+            case hello_verify_request:\n+  \
    \              if (!isLastMsg(ssl, msgSz)) {\n+                    WOLFSSL_MSG(\"\
    Message type is not last in record\");\n+                    WOLFSSL_ERROR_VERBOSE(OUT_OF_ORDER_E);\n\
    +                    return OUT_OF_ORDER_E;\n+                }\n+           \
    \     break;\n+            case server_hello:\n+            case session_ticket:\n\
    +            case end_of_early_data:\n+            case hello_retry_request:\n\
    +            case encrypted_extensions:\n+            case certificate:\n+   \
    \         case server_key_exchange:\n+            case certificate_request:\n\
    +            case server_hello_done:\n+            case certificate_verify:\n\
    +            case client_key_exchange:\n+            case finished:\n+       \
    \     case certificate_status:\n+            case key_update:\n+            case\
    \ change_cipher_hs:\n+                break;\n+            case message_hash:\n\
    +            case no_shake:\n+            default:\n+                WOLFSSL_MSG(\"\
    Unknown message type\");\n+                WOLFSSL_ERROR_VERBOSE(SANITY_MSG_E);\n\
    +                return SANITY_MSG_E;\n+        }\n+    }\n+    return 0;\n+}\n\
    +\n+#endif /* WOLFSSL_DISABLE_EARLY_SANITY_CHECKS */\n+\n+/**\n+ * This check\
    \ is performed as soon as the handshake message type becomes known.\n+ * These\
    \ checks can not be delayed and need to be performed when the msg is\n+ * received\
    \ and not when it is processed (fragmentation may cause messages to\n+ * be processed\
    \ at a later time). This function CAN NOT be called on stored\n+ * messages as\
    \ it relies on the state of the WOLFSSL object right after\n+ * receiving the\
    \ message.\n+ *\n+ * @param ssl   The current connection\n+ * @param type  The\
    \ enum HandShakeType of the current message\n+ * @param msgSz Size of the current\
    \ message\n+ * @return\n+ */\n+int EarlySanityCheckMsgReceived(WOLFSSL* ssl, byte\
    \ type, word32 msgSz)\n+{\n+    int ret = 0;\n+#ifndef WOLFSSL_DISABLE_EARLY_SANITY_CHECKS\n\
    +    byte version_negotiated = 0;\n+\n+    WOLFSSL_ENTER(\"EarlySanityCheckMsgReceived\"\
    );\n+\n+#ifdef WOLFSSL_DTLS\n+    /* Version has only been negotiated after we\
    \ either send or process a\n+     * ServerHello message */\n+    if (ssl->options.dtls)\n\
    +        version_negotiated = ssl->options.serverState >= SERVER_HELLO_COMPLETE;\n\
    +    else\n+#endif\n+        version_negotiated = 1;\n+\n+    if (version_negotiated)\n\
    +        ret = MsgCheckEncryption(ssl, type, ssl->keys.decryptedCur == 1);\n+\n\
    +    if (ret == 0)\n+        ret = MsgCheckBoundary(ssl, type, version_negotiated,\
    \ msgSz);\n+\n+    if (ret != 0\n+#ifdef WOLFSSL_DTLS\n+            && ssl->options.dtls\
    \ && ssl->options.dtlsStateful\n+#endif\n+            )\n+        SendAlert(ssl,\
    \ alert_fatal, unexpected_message);\n+\n+    WOLFSSL_LEAVE(\"EarlySanityCheckMsgReceived\"\
    , ret);\n+#else\n+    (void)ssl;\n+    (void)type;\n+    (void)msgSz;\n+#endif\n\
    +\n+    return ret;\n+}\n+\n #ifdef WOLFSSL_DTLS13\n static int GetInputData(WOLFSSL\
    \ *ssl, word32 size);\n static int GetDtls13RecordHeader(WOLFSSL* ssl, word32*\
    \ inOutIdx,\n@@ -16650,6 +16944,12 @@ static int DoHandShakeMsg(WOLFSSL* ssl,\
    \ byte* input, word32* inOutIdx,\n             return PARSE_ERROR;\n         }\n\
    \ \n+        ret = EarlySanityCheckMsgReceived(ssl, type, size);\n+        if\
    \ (ret != 0) {\n+            WOLFSSL_ERROR(ret);\n+            return ret;\n+\
    \        }\n+\n         if (size > MAX_HANDSHAKE_SZ) {\n             WOLFSSL_MSG(\"\
    Handshake message too large\");\n             WOLFSSL_ERROR_VERBOSE(HANDSHAKE_SIZE_ERROR);\n\
    @@ -16673,6 +16973,13 @@ static int DoHandShakeMsg(WOLFSSL* ssl, byte* input,\
    \ word32* inOutIdx,\n             return PARSE_ERROR;\n         }\n \n+      \
    \  ret = EarlySanityCheckMsgReceived(ssl, type,\n+                min(inputLength\
    \ - HANDSHAKE_HEADER_SZ, size));\n+        if (ret != 0) {\n+            WOLFSSL_ERROR(ret);\n\
    +            return ret;\n+        }\n+\n         /* Cap the maximum size of a\
    \ handshake message to something reasonable.\n          * By default is the maximum\
    \ size of a certificate message assuming\n          * nine 2048-bit RSA certificates\
    \ in the chain. */\n@@ -16711,6 +17018,13 @@ static int DoHandShakeMsg(WOLFSSL*\
    \ ssl, byte* input, word32* inOutIdx,\n         if (inputLength > pendSz)\n  \
    \           inputLength = pendSz;\n \n+        ret = EarlySanityCheckMsgReceived(ssl,\
    \ ssl->arrays->pendingMsgType,\n+                inputLength);\n+        if (ret\
    \ != 0) {\n+            WOLFSSL_ERROR(ret);\n+            return ret;\n+     \
    \   }\n+\n     #ifdef WOLFSSL_ASYNC_CRYPT\n         if (ssl->error != WC_PENDING_E)\n\
    \     #endif\n@@ -17265,6 +17579,14 @@ int DtlsMsgDrain(WOLFSSL* ssl)\n      \
    \       item->ready && ret == 0) {\n         word32 idx = 0;\n \n+    #ifndef\
    \ WOLFSSL_DISABLE_EARLY_SANITY_CHECKS\n+        ret = MsgCheckEncryption(ssl,\
    \ item->type, item->encrypted);\n+        if (ret != 0) {\n+            SendAlert(ssl,\
    \ alert_fatal, unexpected_message);\n+            break;\n+        }\n+    #endif\n\
    +\n     #ifdef WOLFSSL_NO_TLS12\n         ret = DoTls13HandShakeMsgType(ssl, item->fullMsg,\
    \ &idx, item->type,\n                                       item->sz, item->sz);\n\
    @@ -17314,6 +17636,12 @@ static int DoDtlsHandShakeMsg(WOLFSSL* ssl, byte* input,\
    \ word32* inOutIdx,\n         return PARSE_ERROR;\n     }\n \n+    ret = EarlySanityCheckMsgReceived(ssl,\
    \ type, fragSz);\n+    if (ret != 0) {\n+        WOLFSSL_ERROR(ret);\n+      \
    \  return ret;\n+    }\n+\n     /* Cap the maximum size of a handshake message\
    \ to something reasonable.\n      * By default is the maximum size of a certificate\
    \ message assuming\n      * nine 2048-bit RSA certificates in the chain. */\n\
    @@ -20271,7 +20599,6 @@ int ProcessReplyEx(WOLFSSL* ssl, int allowSocketErr)\n\
    \ {\n     int    ret = 0, type = internal_error, readSz;\n     int    atomicUser\
    \ = 0;\n-    word32 startIdx = 0;\n #if defined(WOLFSSL_DTLS)\n     int    used;\n\
    \ #endif\n@@ -20563,7 +20890,8 @@ int ProcessReplyEx(WOLFSSL* ssl, int allowSocketErr)\n\
    \             ssl->keys.padSz = 0;\n \n             ssl->options.processReply\
    \ = verifyEncryptedMessage;\n-            startIdx = ssl->buffers.inputBuffer.idx;\
    \  /* in case > 1 msg per */\n+            /* in case > 1 msg per record */\n\
    +            ssl->curStartIdx = ssl->buffers.inputBuffer.idx;\n             FALL_THROUGH;\n\
    \ \n         /* verify digest of encrypted message */\n@@ -20907,7 +21235,7 @@\
    \ int ProcessReplyEx(WOLFSSL* ssl, int allowSocketErr)\n                 /* For\
    \ TLS v1.1 the block size and explicit IV are added to idx,\n                \
    \  * so it needs to be included in this limit check */\n                 if ((ssl->curSize\
    \ - ssl->keys.padSz -\n-                        (ssl->buffers.inputBuffer.idx\
    \ - startIdx) -\n+                        (ssl->buffers.inputBuffer.idx - ssl->curStartIdx)\
    \ -\n                         MacSize(ssl) > MAX_PLAINTEXT_SZ)\n #ifdef WOLFSSL_ASYNC_CRYPT\n\
    \                         && ssl->buffers.inputBuffer.length !=\n@@ -20929,7 +21257,7\
    \ @@ int ProcessReplyEx(WOLFSSL* ssl, int allowSocketErr)\n              * so\
    \ it needs to be included in this limit check */\n             if (!IsAtLeastTLSv1_3(ssl->version)\n\
    \                     && ssl->curSize - ssl->keys.padSz -\n-                 \
    \       (ssl->buffers.inputBuffer.idx - startIdx)\n+                        (ssl->buffers.inputBuffer.idx\
    \ - ssl->curStartIdx)\n                             > MAX_PLAINTEXT_SZ\n #ifdef\
    \ WOLFSSL_ASYNC_CRYPT\n                     && ssl->buffers.inputBuffer.length\
    \ !=\n@@ -21333,7 +21661,8 @@ int ProcessReplyEx(WOLFSSL* ssl, int allowSocketErr)\n\
    \                 return ret;\n             }\n             /* more messages per\
    \ record */\n-            else if ((ssl->buffers.inputBuffer.idx - startIdx) <\
    \ ssl->curSize) {\n+            else if ((ssl->buffers.inputBuffer.idx - ssl->curStartIdx)\n\
    +                    < ssl->curSize) {\n                 WOLFSSL_MSG(\"More messages\
    \ in record\");\n \n                 ssl->options.processReply = runProcessingOneMessage;"
  - "--- a/src/tls13.c\n+++ b/src/tls13.c\n@@ -11787,15 +11787,19 @@ int DoTls13HandShakeMsg(WOLFSSL*\
    \ ssl, byte* input, word32* inOutIdx,\n     WOLFSSL_ENTER(\"DoTls13HandShakeMsg\"\
    );\n \n     if (ssl->arrays == NULL) {\n-\n-\n         if (GetHandshakeHeader(ssl,\
    \ input, inOutIdx, &type, &size,\n                                           \
    \                      totalSz) != 0) {\n             SendAlert(ssl, alert_fatal,\
    \ unexpected_message);\n             WOLFSSL_ERROR_VERBOSE(PARSE_ERROR);\n   \
    \          return PARSE_ERROR;\n         }\n \n+        ret = EarlySanityCheckMsgReceived(ssl,\
    \ type, size);\n+        if (ret != 0) {\n+            WOLFSSL_ERROR(ret);\n+\
    \            return ret;\n+        }\n+\n         return DoTls13HandShakeMsgType(ssl,\
    \ input, inOutIdx, type, size,\n                                        totalSz);\n\
    \     }\n@@ -11812,6 +11816,13 @@ int DoTls13HandShakeMsg(WOLFSSL* ssl, byte*\
    \ input, word32* inOutIdx,\n             return PARSE_ERROR;\n         }\n \n\
    +        ret = EarlySanityCheckMsgReceived(ssl, type,\n+                min(inputLength\
    \ - HANDSHAKE_HEADER_SZ, size));\n+        if (ret != 0) {\n+            WOLFSSL_ERROR(ret);\n\
    +            return ret;\n+        }\n+\n         /* Cap the maximum size of a\
    \ handshake message to something reasonable.\n          * By default is the maximum\
    \ size of a certificate message assuming\n          * nine 2048-bit RSA certificates\
    \ in the chain. */\n@@ -11847,6 +11858,14 @@ int DoTls13HandShakeMsg(WOLFSSL*\
    \ ssl, byte* input, word32* inOutIdx,\n             inputLength = ssl->arrays->pendingMsgSz\
    \ -\n                                                   ssl->arrays->pendingMsgOffset;\n\
    \         }\n+\n+        ret = EarlySanityCheckMsgReceived(ssl, ssl->arrays->pendingMsgType,\n\
    +                inputLength);\n+        if (ret != 0) {\n+            WOLFSSL_ERROR(ret);\n\
    +            return ret;\n+        }\n+\n         XMEMCPY(ssl->arrays->pendingMsg\
    \ + ssl->arrays->pendingMsgOffset,\n                 input + *inOutIdx, inputLength);\n\
    \         ssl->arrays->pendingMsgOffset += inputLength;"
  - "--- a/tests/api.c\n+++ b/tests/api.c\n@@ -61806,6 +61806,7 @@ static word32 test_wolfSSL_dtls_stateless_HashWOLFSSL(const\
    \ WOLFSSL* ssl)\n     sslCopy.buffers.outputBuffer.offset = 0;\n     sslCopy.error\
    \ = 0;\n     sslCopy.curSize = 0;\n+    sslCopy.curStartIdx = 0;\n     sslCopy.keys.curSeq_lo\
    \ = 0;\n     XMEMSET(&sslCopy.curRL, 0, sizeof(sslCopy.curRL));\n #ifdef WOLFSSL_DTLS13\n\
    @@ -67470,7 +67471,11 @@ static int test_TLSX_CA_NAMES_bad_extension(void)\n \
    \        }\n \n         ExpectIntEQ(wolfSSL_connect(ssl_c), -1);\n+#ifndef WOLFSSL_DISABLE_EARLY_SANITY_CHECKS\n\
    +        ExpectIntEQ(wolfSSL_get_error(ssl_c, -1), OUT_OF_ORDER_E);\n+#else\n\
    \         ExpectIntEQ(wolfSSL_get_error(ssl_c, -1), BUFFER_ERROR);\n+#endif\n\
    \ \n         wolfSSL_free(ssl_c);\n         ssl_c = NULL;"
  identifiers: CVE:["CVE-2023-6937"],CWE:["CWE-20"]
  overview: Affected versions of this package are vulnerable to Marvin Attack due
    to the improper handling of `(D)TLS` records that do not check if messages span
    key boundaries. An attacker can exploit this vulnerability to combine (D)TLS messages
    using different keys into one (D)TLS record.
  references:
    GitHub Commit: https://github.com/wolfSSL/wolfssl/commit/f12b61183b3781adc3e89b3e92143c7e4f3556eb
    GitHub PR: https://github.com/wolfSSL/wolfssl/pull/7029
    Security Advisory: https://www.wolfssl.com/docs/security-vulnerabilities/
  title: Marvin Attack
- diff_content:
  - "--- a/os/net/routing/rpl-lite/rpl-icmp6.c\n+++ b/os/net/routing/rpl-lite/rpl-icmp6.c\n\
    @@ -49,6 +49,7 @@\n #include \"net/packetbuf.h\"\n #include \"lib/random.h\"\n\
    \ \n+#include <inttypes.h>\n #include <limits.h>\n \n /* Log configuration */\n\
    @@ -172,7 +173,7 @@ static void\n dio_input(void)\n {\n   unsigned char *buffer;\n\
    -  uint8_t buffer_length;\n+  uint16_t buffer_length;\n   rpl_dio_t dio;\n   uint8_t\
    \ subopt_type;\n   int i;\n@@ -195,6 +196,12 @@ dio_input(void)\n \n   buffer_length\
    \ = uip_len - uip_l3_icmp_hdr_len;\n \n+  if(buffer_length < 8 + sizeof(dio.dag_id))\
    \ {\n+    LOG_WARN(\"dio_input: invalid DIO header, len %\"PRIu16\", discard\\\
    n\",\n+             buffer_length);\n+    goto discard;\n+  }\n+\n   /* Process\
    \ the DIO base option. */\n   i = 0;\n   buffer = UIP_ICMP_PAYLOAD;\n@@ -222,6\
    \ +229,10 @@ dio_input(void)\n       len = 1;\n     } else {\n       /* Suboption\
    \ with a two-byte header + payload */\n+      if(i + 1 >= buffer_length) {\n+\
    \        LOG_ERR(\"dio_input: malformed packet, discard\\n\");\n+        goto\
    \ discard;\n+      }\n       len = 2 + buffer[i + 1];\n     }\n \n@@ -246,8 +257,16\
    \ @@ dio_input(void)\n         if(dio.mc.type == RPL_DAG_MC_NONE) {\n        \
    \   /* No metric container: do nothing */\n         } else if(dio.mc.type == RPL_DAG_MC_ETX)\
    \ {\n+          if(len < 8) {\n+            LOG_WARN(\"dio_input: invalid DAG\
    \ MC, len %u, discard\\n\", len);\n+            goto discard;\n+          }\n\
    \           dio.mc.obj.etx = get16(buffer, i + 6);\n         } else if(dio.mc.type\
    \ == RPL_DAG_MC_ENERGY) {\n+          if(len < 8) {\n+            LOG_WARN(\"\
    dio_input: invalid DAG MC, len %u, discard\\n\", len);\n+            goto discard;\n\
    +          }\n           dio.mc.obj.energy.flags = buffer[i + 6];\n          \
    \ dio.mc.obj.energy.energy_est = buffer[i + 7];\n         } else {\n@@ -256,8\
    \ +275,9 @@ dio_input(void)\n         }\n         break;\n       case RPL_OPTION_ROUTE_INFO:\n\
    -        if(len < 9) {\n-          LOG_WARN(\"dio_input: invalid destination prefix\
    \ option, len %u, discard\\n\", len);\n+        if(len < 8) {\n+          LOG_WARN(\"\
    dio_input: invalid route info option, len %u, discard\\n\",\n+               \
    \    len);\n           goto discard;\n         }\n \n@@ -457,7 +477,7 @@ dao_input(void)\n\
    \   struct rpl_dao dao;\n   uint8_t subopt_type;\n   unsigned char *buffer;\n\
    -  uint8_t buffer_length;\n+  uint16_t buffer_length;\n   int pos;\n   int len;\n\
    \   int i;\n@@ -477,6 +497,12 @@ dao_input(void)\n   buffer = UIP_ICMP_PAYLOAD;\n\
    \   buffer_length = uip_len - uip_l3_icmp_hdr_len;\n \n+  if(buffer_length < 4)\
    \ {\n+    LOG_WARN(\"dao_input: invalid DAO header, len %\"PRIu16\", discard\\\
    n\",\n+             buffer_length);\n+    goto discard;\n+  }\n+\n   pos = 0;\n\
    \   pos++; /* instance ID */\n   dao.lifetime = curr_instance.default_lifetime;\n\
    @@ -486,6 +512,11 @@ dao_input(void)\n \n   /* Is the DAG ID present? */\n   if(dao.flags\
    \ & RPL_DAO_D_FLAG) {\n+    if(buffer_length < 4 + sizeof(curr_instance.dag.dag_id))\
    \ {\n+      LOG_WARN(\"dao_input: missing full DAG ID, len %\"PRIu16\", discard\\\
    n\",\n+               buffer_length);\n+      goto discard;\n+    }\n     if(memcmp(&curr_instance.dag.dag_id,\
    \ &buffer[pos], sizeof(curr_instance.dag.dag_id))) {\n       LOG_ERR(\"dao_input:\
    \ different DAG ID \");\n       LOG_ERR_6ADDR((uip_ipaddr_t *)&buffer[pos]);\n\
    @@ -502,20 +533,43 @@ dao_input(void)\n       len = 1;\n     } else {\n      \
    \ /* The option consists of a two-byte header and a payload. */\n+      if(i +\
    \ 1 >= buffer_length) {\n+        LOG_ERR(\"dao_input: malformed packet, discard\\\
    n\");\n+        goto discard;\n+      }\n       len = 2 + buffer[i + 1];\n   \
    \  }\n \n+    if(i + len > buffer_length) {\n+      LOG_ERR(\"dao_input: malformed\
    \ packet, discard\\n\");\n+      goto discard;\n+    }\n+\n     switch(subopt_type)\
    \ {\n       case RPL_OPTION_TARGET:\n         /* Handle the target option. */\n\
    +        if(len < 4) {\n+          LOG_WARN(\"dao_input: invalid target option,\
    \ len %u, discard\\n\", len);\n+          goto discard;\n+        }\n        \
    \ dao.prefixlen = buffer[i + 3];\n+        if(4 + (dao.prefixlen + 7) / CHAR_BIT\
    \ != len) {\n+          LOG_WARN(\"dao_input: invalid target option, len %u !=\
    \ %u, discard\\n\",\n+                   len, 4 + (dao.prefixlen + 7) / CHAR_BIT);\n\
    +          goto discard;\n+        }\n         memset(&dao.prefix, 0, sizeof(dao.prefix));\n\
    \         memcpy(&dao.prefix, buffer + i + 4, (dao.prefixlen + 7) / CHAR_BIT);\n\
    \         break;\n       case RPL_OPTION_TRANSIT:\n         /* The path sequence\
    \ and control are ignored. */\n         /*      pathcontrol = buffer[i + 3];\n\
    \                 pathsequence = buffer[i + 4];*/\n+        if(len < 6) {\n+ \
    \         LOG_WARN(\"dao_input: invalid transit option, len %\"PRIu16\", discard\\\
    n\",\n+                   buffer_length);\n+          goto discard;\n+       \
    \ }\n         dao.lifetime = buffer[i + 5];\n         if(len >= 20) {\n      \
    \     memcpy(&dao.parent_addr, buffer + i + 6, 16);"
  identifiers: CVE:["CVE-2023-50927"],CWE:["CWE-125"]
  overview: Affected versions of this package are vulnerable to Out-of-bounds Read
    due to insufficient control of the lengths for DIO and DAO messages, when they
    contain RPL sub-option headers.
  references:
    GitHub Commit: https://github.com/contiki-ng/contiki-ng/commit/f4c7167a8a1d0397f309f42592ea87d676ee5ea7
    GitHub PR: https://github.com/contiki-ng/contiki-ng/pull/2484
  title: Out-of-bounds Read
- diff_content:
  - "--- a/src/util.c\n+++ b/src/util.c\n@@ -1559,23 +1559,24 @@ static char *oidc_util_get_chunk_cookie_name(request_rec\
    \ *r, const char *cookieN\n  * get a cookie value that is split over a number\
    \ of chunked cookies\n  */\n char *oidc_util_get_chunked_cookie(request_rec *r,\
    \ const char *cookieName, int chunkSize) {\n-\tchar *cookieValue = NULL;\n-\t\
    char *chunkValue = NULL;\n-\tint i = 0;\n-\tif (chunkSize == 0) {\n-\t\tcookieValue\
    \ = oidc_util_get_cookie(r, cookieName);\n-\t} else {\n-\t\tint chunkCount = oidc_util_get_chunked_count(r,\
    \ cookieName);\n-\t\tif (chunkCount > 0) {\n-\t\t\tcookieValue = \"\";\n-\t\t\t\
    for (i = 0; i < chunkCount; i++) {\n-\t\t\t\tchunkValue = oidc_util_get_cookie(r,\
    \ oidc_util_get_chunk_cookie_name(r, cookieName, i));\n-\t\t\t\tif (chunkValue\
    \ != NULL)\n-\t\t\t\t\tcookieValue = apr_psprintf(r->pool, \"%s%s\", cookieValue,\
    \ chunkValue);\n-\t\t\t}\n-\t\t} else {\n-\t\t\tcookieValue = oidc_util_get_cookie(r,\
    \ cookieName);\n+\tchar *cookieValue = NULL, *chunkValue = NULL;\n+\tint chunkCount\
    \ = 0, i = 0;\n+\tif (chunkSize == 0)\n+\t\treturn oidc_util_get_cookie(r, cookieName);\n\
    +\tchunkCount = oidc_util_get_chunked_count(r, cookieName);\n+\tif (chunkCount\
    \ == 0)\n+\t\treturn oidc_util_get_cookie(r, cookieName);\n+\tif ((chunkCount\
    \ < 0) || (chunkCount > 99)) {\n+\t\toidc_warn(r, \"chunk count out of bounds:\
    \ %d\", chunkCount);\n+\t\treturn NULL;\n+\t}\n+\tfor (i = 0; i < chunkCount;\
    \ i++) {\n+\t\tchunkValue = oidc_util_get_cookie(r, oidc_util_get_chunk_cookie_name(r,\
    \ cookieName, i));\n+\t\tif (chunkValue == NULL) {\n+\t\t\toidc_warn(r, \"could\
    \ not find chunk %d; aborting\", i);\n+\t\t\tbreak;\n \t\t}\n+\t\tcookieValue\
    \ = apr_psprintf(r->pool, \"%s%s\", cookieValue ? cookieValue : \"\", chunkValue);\n\
    \ \t}\n \treturn cookieValue;\n }"
  identifiers: CVE:["CVE-2024-24814"],CWE:["CWE-400"]
  overview: Affected versions of this package are vulnerable to Resource Exhaustion
    due to missing input validation in the `mod_auth_openidc_session_chunks` cookie
    value. An attacker can cause the application or system to slow down or crash by
    crafting a request that leads to unhandled errors.
  references:
    GitHub Commit: https://github.com/OpenIDC/mod_auth_openidc/commit/4022c12f314bd89d127d1be008b1a80a08e1203d
  title: Resource Exhaustion
- diff_content:
  - "--- a/lib/dns/message.c\n+++ b/lib/dns/message.c\n@@ -22,6 +22,8 @@\n #include\
    \ <stdbool.h>\n \n #include <isc/buffer.h>\n+#include <isc/hash.h>\n+#include\
    \ <isc/ht.h>\n #include <isc/mem.h>\n #include <isc/print.h>\n #include <isc/result.h>\n\
    @@ -493,9 +495,11 @@ msgresetsigs(dns_message_t *msg, bool replying) {\n \t\t\
    } else {\n \t\t\tdns_rdataset_disassociate(msg->tsig);\n \t\t\tisc_mempool_put(msg->rdspool,\
    \ msg->tsig);\n+\t\t\tmsg->tsig = NULL;\n \t\t\tif (msg->querytsig != NULL) {\n\
    \ \t\t\t\tdns_rdataset_disassociate(msg->querytsig);\n \t\t\t\tisc_mempool_put(msg->rdspool,\
    \ msg->querytsig);\n+\t\t\t\tmsg->querytsig = NULL;\n \t\t\t}\n \t\t}\n \t\tdns_message_puttempname(msg,\
    \ &msg->tsigname);\n@@ -790,6 +794,18 @@ dns_message_detach(dns_message_t **messagep)\
    \ {\n \t}\n }\n \n+static isc_result_t\n+name_hash_add(isc_ht_t *ht, dns_name_t\
    \ *name, dns_name_t **foundp) {\n+\tisc_result_t result = isc_ht_find(ht, name->ndata,\
    \ name->length,\n+\t\t\t\t\t  (void **)foundp);\n+\tif (result == ISC_R_SUCCESS)\
    \ {\n+\t\treturn (ISC_R_EXISTS);\n+\t}\n+\tresult = isc_ht_add(ht, name->ndata,\
    \ name->length, (void *)name);\n+\tINSIST(result == ISC_R_SUCCESS);\n+\treturn\
    \ (ISC_R_SUCCESS);\n+}\n+\n static isc_result_t\n findname(dns_name_t **foundname,\
    \ const dns_name_t *target,\n \t dns_namelist_t *section) {\n@@ -809,29 +825,26\
    \ @@ findname(dns_name_t **foundname, const dns_name_t *target,\n \treturn (ISC_R_NOTFOUND);\n\
    \ }\n \n-isc_result_t\n-dns_message_find(const dns_name_t *name, dns_rdataclass_t\
    \ rdclass,\n-\t\t dns_rdatatype_t type, dns_rdatatype_t covers,\n-\t\t dns_rdataset_t\
    \ **rdataset) {\n-\tdns_rdataset_t *curr;\n-\n-\tREQUIRE(name != NULL);\n-\tREQUIRE(rdataset\
    \ == NULL || *rdataset == NULL);\n-\n-\tfor (curr = ISC_LIST_TAIL(name->list);\
    \ curr != NULL;\n-\t     curr = ISC_LIST_PREV(curr, link))\n-\t{\n-\t\tif (curr->rdclass\
    \ == rdclass && curr->type == type &&\n-\t\t    curr->covers == covers)\n-\t\t\
    {\n-\t\t\tif (rdataset != NULL) {\n-\t\t\t\t*rdataset = curr;\n-\t\t\t}\n-\t\t\
    \treturn (ISC_R_SUCCESS);\n-\t\t}\n-\t}\n+typedef struct __attribute__((__packed__))\
    \ rds_key {\n+\tdns_rdataclass_t rdclass;\n+\tdns_rdatatype_t type;\n+\tdns_rdatatype_t\
    \ covers;\n+} rds_key_t;\n \n-\treturn (ISC_R_NOTFOUND);\n+static isc_result_t\n\
    +rds_hash_add(isc_ht_t *ht, dns_rdataset_t *rds, dns_rdataset_t **foundp) {\n\
    +\trds_key_t key = { .rdclass = rds->rdclass,\n+\t\t\t  .type = rds->type,\n+\t\
    \t\t  .covers = rds->covers };\n+\tisc_result_t result = isc_ht_find(ht, (const\
    \ unsigned char *)&key,\n+\t\t\t\t\t  sizeof(key), (void **)foundp);\n+\tif (result\
    \ == ISC_R_SUCCESS) {\n+\t\treturn (ISC_R_EXISTS);\n+\t}\n+\tresult = isc_ht_add(ht,\
    \ (const unsigned char *)&key, sizeof(key),\n+\t\t\t    (void *)rds);\n+\tINSIST(result\
    \ == ISC_R_SUCCESS);\n+\treturn (ISC_R_SUCCESS);\n }\n \n isc_result_t\n@@ -958,6\
    \ +971,18 @@ getrdata(isc_buffer_t *source, dns_message_t *msg, dns_decompress_t\
    \ *dctx,\n \t\t}                            \\\n \t} while (0)\n \n+static void\n\
    +cleanup_name_hashmaps(dns_namelist_t *section) {\n+\tdns_name_t *name = NULL;\n\
    +\tfor (name = ISC_LIST_HEAD(*section); name != NULL;\n+\t     name = ISC_LIST_NEXT(name,\
    \ link))\n+\t{\n+\t\tif (name->ht != NULL) {\n+\t\t\tisc_ht_destroy(&name->ht);\n\
    +\t\t}\n+\t}\n+}\n+\n static isc_result_t\n getquestions(isc_buffer_t *source,\
    \ dns_message_t *msg, dns_decompress_t *dctx,\n \t     unsigned int options) {\n\
    @@ -967,13 +992,19 @@ getquestions(isc_buffer_t *source, dns_message_t *msg, dns_decompress_t\
    \ *dctx,\n \tdns_name_t *name2 = NULL;\n \tdns_rdataset_t *rdataset = NULL;\n\
    \ \tdns_rdatalist_t *rdatalist = NULL;\n-\tisc_result_t result;\n+\tisc_result_t\
    \ result = ISC_R_SUCCESS;\n \tdns_rdatatype_t rdtype;\n \tdns_rdataclass_t rdclass;\n\
    \ \tdns_namelist_t *section = &msg->sections[DNS_SECTION_QUESTION];\n \tbool best_effort\
    \ = ((options & DNS_MESSAGEPARSE_BESTEFFORT) != 0);\n \tbool seen_problem = false;\n\
    \ \tbool free_name = false;\n+\tbool free_ht = false;\n+\tisc_ht_t *name_map =\
    \ NULL;\n+\n+\tif (msg->counts[DNS_SECTION_QUESTION] > 1) {\n+\t\tisc_ht_init(&name_map,\
    \ msg->mctx, 1, ISC_HT_CASE_INSENSITIVE);\n+\t}\n \n \tfor (count = 0; count <\
    \ msg->counts[DNS_SECTION_QUESTION]; count++) {\n \t\tname = NULL;\n@@ -994,13\
    \ +1025,19 @@ getquestions(isc_buffer_t *source, dns_message_t *msg, dns_decompress_t\
    \ *dctx,\n \t\t\tgoto cleanup;\n \t\t}\n \n+\t\t/* If there is only one QNAME,\
    \ skip the duplicity checks */\n+\t\tif (name_map == NULL) {\n+\t\t\tresult =\
    \ ISC_R_SUCCESS;\n+\t\t\tgoto skip_name_check;\n+\t\t}\n+\n \t\t/*\n \t\t * Run\
    \ through the section, looking to see if this name\n \t\t * is already there.\
    \  If it is found, put back the allocated\n \t\t * name since we no longer need\
    \ it, and set our name pointer\n \t\t * to point to the name we found.\n \t\t\
    \ */\n-\t\tresult = findname(&name2, name, section);\n+\t\tresult = name_hash_add(name_map,\
    \ name, &name2);\n \n \t\t/*\n \t\t * If it is the first name in the section,\
    \ accept it.\n@@ -1012,19 +1049,25 @@ getquestions(isc_buffer_t *source, dns_message_t\
    \ *msg, dns_decompress_t *dctx,\n \t\t * this should be legal or not.  In either\
    \ case we no longer\n \t\t * need this name pointer.\n \t\t */\n-\t\tif (result\
    \ != ISC_R_SUCCESS) {\n+\tskip_name_check:\n+\t\tswitch (result) {\n+\t\tcase\
    \ ISC_R_SUCCESS:\n \t\t\tif (!ISC_LIST_EMPTY(*section)) {\n \t\t\t\tDO_ERROR(DNS_R_FORMERR);\n\
    \ \t\t\t}\n \t\t\tISC_LIST_APPEND(*section, name, link);\n-\t\t\tfree_name = false;\n\
    -\t\t} else {\n+\t\t\tbreak;\n+\t\tcase ISC_R_EXISTS:\n \t\t\tdns_message_puttempname(msg,\
    \ &name);\n \t\t\tname = name2;\n \t\t\tname2 = NULL;\n-\t\t\tfree_name = false;\n\
    +\t\t\tbreak;\n+\t\tdefault:\n+\t\t\tUNREACHABLE();\n \t\t}\n \n+\t\tfree_name\
    \ = false;\n+\n \t\t/*\n \t\t * Get type and class.\n \t\t */\n@@ -1054,14 +1097,6\
    \ @@ getquestions(isc_buffer_t *source, dns_message_t *msg, dns_decompress_t *dctx,\n\
    \ \t\t\tmsg->tkey = 1;\n \t\t}\n \n-\t\t/*\n-\t\t * Can't ask the same question\
    \ twice.\n-\t\t */\n-\t\tresult = dns_message_find(name, rdclass, rdtype, 0, NULL);\n\
    -\t\tif (result == ISC_R_SUCCESS) {\n-\t\t\tDO_ERROR(DNS_R_FORMERR);\n-\t\t}\n\
    -\n \t\t/*\n \t\t * Allocate a new rdatalist.\n \t\t */\n@@ -1071,30 +1106,61\
    \ @@ getquestions(isc_buffer_t *source, dns_message_t *msg, dns_decompress_t *dctx,\n\
    \ \t\t\tgoto cleanup;\n \t\t}\n \t\trdataset = isc_mempool_get(msg->rdspool);\n\
    +\t\tdns_rdataset_init(rdataset);\n \n \t\t/*\n \t\t * Convert rdatalist to rdataset,\
    \ and attach the latter to\n \t\t * the name.\n \t\t */\n \t\trdatalist->type\
    \ = rdtype;\n \t\trdatalist->rdclass = rdclass;\n-\n-\t\tdns_rdataset_init(rdataset);\n\
    \ \t\tresult = dns_rdatalist_tordataset(rdatalist, rdataset);\n \t\tif (result\
    \ != ISC_R_SUCCESS) {\n \t\t\tgoto cleanup;\n \t\t}\n \n \t\trdataset->attributes\
    \ |= DNS_RDATASETATTR_QUESTION;\n \n+\t\t/*\n+\t\t * Skip the duplicity check\
    \ for first rdataset\n+\t\t */\n+\t\tif (ISC_LIST_EMPTY(name->list)) {\n+\t\t\t\
    result = ISC_R_SUCCESS;\n+\t\t\tgoto skip_rds_check;\n+\t\t}\n+\n+\t\t/*\n+\t\t\
    \ * Can't ask the same question twice.\n+\t\t */\n+\t\tif (name->ht == NULL) {\n\
    +\t\t\tisc_ht_init(&name->ht, msg->mctx, 1,\n+\t\t\t\t    ISC_HT_CASE_SENSITIVE);\n\
    +\t\t\tfree_ht = true;\n+\n+\t\t\tINSIST(ISC_LIST_HEAD(name->list) ==\n+\t\t\t\
    \       ISC_LIST_TAIL(name->list));\n+\n+\t\t\tdns_rdataset_t *old_rdataset =\n\
    +\t\t\t\tISC_LIST_HEAD(name->list);\n+\n+\t\t\tresult = rds_hash_add(name->ht,\
    \ old_rdataset, NULL);\n+\n+\t\t\tINSIST(result == ISC_R_SUCCESS);\n+\t\t}\n+\t\
    \tresult = rds_hash_add(name->ht, rdataset, NULL);\n+\t\tif (result == ISC_R_EXISTS)\
    \ {\n+\t\t\tDO_ERROR(DNS_R_FORMERR);\n+\t\t}\n+\n+\tskip_rds_check:\n \t\tISC_LIST_APPEND(name->list,\
    \ rdataset, link);\n+\n \t\trdataset = NULL;\n \t}\n \n \tif (seen_problem) {\n\
    -\t\treturn (DNS_R_RECOVERABLE);\n+\t\tresult = DNS_R_RECOVERABLE;\n \t}\n-\t\
    return (ISC_R_SUCCESS);\n \n cleanup:\n \tif (rdataset != NULL) {\n@@ -1105,6\
    \ +1171,14 @@ getquestions(isc_buffer_t *source, dns_message_t *msg, dns_decompress_t\
    \ *dctx,\n \t\tdns_message_puttempname(msg, &name);\n \t}\n \n+\tif (free_ht)\
    \ {\n+\t\tcleanup_name_hashmaps(section);\n+\t}\n+\n+\tif (name_map != NULL) {\n\
    +\t\tisc_ht_destroy(&name_map);\n+\t}\n+\n \treturn (result);\n }\n \n@@ -1184,25\
    \ +1258,31 @@ getsection(isc_buffer_t *source, dns_message_t *msg, dns_decompress_t\
    \ *dctx,\n \tdns_name_t *name = NULL;\n \tdns_name_t *name2 = NULL;\n \tdns_rdataset_t\
    \ *rdataset = NULL;\n+\tdns_rdataset_t *found_rdataset = NULL;\n \tdns_rdatalist_t\
    \ *rdatalist = NULL;\n-\tisc_result_t result;\n+\tisc_result_t result = ISC_R_SUCCESS;\n\
    \ \tdns_rdatatype_t rdtype, covers;\n \tdns_rdataclass_t rdclass;\n \tdns_rdata_t\
    \ *rdata = NULL;\n \tdns_ttl_t ttl;\n \tdns_namelist_t *section = &msg->sections[sectionid];\n\
    -\tbool free_name = false, free_rdataset = false, seen_problem = false;\n+\tbool\
    \ free_name = false, seen_problem = false;\n+\tbool free_ht = false;\n \tbool\
    \ preserve_order = ((options & DNS_MESSAGEPARSE_PRESERVEORDER) != 0);\n \tbool\
    \ best_effort = ((options & DNS_MESSAGEPARSE_BESTEFFORT) != 0);\n \tbool isedns,\
    \ issigzero, istsig;\n+\tisc_ht_t *name_map = NULL;\n+\n+\tif (msg->counts[sectionid]\
    \ > 1) {\n+\t\tisc_ht_init(&name_map, msg->mctx, 1, ISC_HT_CASE_INSENSITIVE);\n\
    +\t}\n \n \tfor (count = 0; count < msg->counts[sectionid]; count++) {\n \t\t\
    int recstart = source->current;\n \t\tbool skip_name_search, skip_type_search;\n\
    \ \n \t\tskip_name_search = false;\n \t\tskip_type_search = false;\n-\t\tfree_rdataset\
    \ = false;\n \t\tisedns = false;\n \t\tissigzero = false;\n \t\tistsig = false;\n\
    @@ -1245,8 +1325,8 @@ getsection(isc_buffer_t *source, dns_message_t *msg, dns_decompress_t\
    \ *dctx,\n \t\tif (msg->rdclass_set == 0 &&\n \t\t    rdtype != dns_rdatatype_opt\
    \ &&  /* class is UDP SIZE */\n \t\t    rdtype != dns_rdatatype_tsig && /* class\
    \ is ANY */\n-\t\t    rdtype != dns_rdatatype_tkey)\n-\t\t{ /* class is undefined\
    \ */\n+\t\t    rdtype != dns_rdatatype_tkey)   /* class is undefined */\n+\t\t\
    {\n \t\t\tmsg->rdclass = rdclass;\n \t\t\tmsg->rdclass_set = 1;\n \t\t}\n@@ -1445,61\
    \ +1525,124 @@ getsection(isc_buffer_t *source, dns_message_t *msg, dns_decompress_t\
    \ *dctx,\n \t\t\t\tfree_name = false;\n \t\t\t}\n \t\t} else {\n+\t\t\tif (name_map\
    \ == NULL) {\n+\t\t\t\tresult = ISC_R_SUCCESS;\n+\t\t\t\tgoto skip_name_check;\n\
    +\t\t\t}\n+\n \t\t\t/*\n \t\t\t * Run through the section, looking to see if this\
    \ name\n \t\t\t * is already there.  If it is found, put back the\n \t\t\t * allocated\
    \ name since we no longer need it, and set\n \t\t\t * our name pointer to point\
    \ to the name we found.\n \t\t\t */\n-\t\t\tresult = findname(&name2, name, section);\n\
    +\t\t\tresult = name_hash_add(name_map, name, &name2);\n \n \t\t\t/*\n \t\t\t\
    \ * If it is a new name, append to the section.\n \t\t\t */\n-\t\t\tif (result\
    \ == ISC_R_SUCCESS) {\n+\t\tskip_name_check:\n+\t\t\tswitch (result) {\n+\t\t\t\
    case ISC_R_SUCCESS:\n+\t\t\t\tISC_LIST_APPEND(*section, name, link);\n+\t\t\t\t\
    break;\n+\t\t\tcase ISC_R_EXISTS:\n \t\t\t\tdns_message_puttempname(msg, &name);\n\
    \ \t\t\t\tname = name2;\n-\t\t\t} else {\n-\t\t\t\tISC_LIST_APPEND(*section, name,\
    \ link);\n+\t\t\t\tname2 = NULL;\n+\t\t\t\tbreak;\n+\t\t\tdefault:\n+\t\t\t\t\
    UNREACHABLE();\n \t\t\t}\n \t\t\tfree_name = false;\n \t\t}\n \n+\t\trdatalist\
    \ = newrdatalist(msg);\n+\t\trdatalist->type = rdtype;\n+\t\trdatalist->covers\
    \ = covers;\n+\t\trdatalist->rdclass = rdclass;\n+\t\trdatalist->ttl = ttl;\n\
    +\n+\t\tdns_message_gettemprdataset(msg, &rdataset);\n+\t\tRUNTIME_CHECK(dns_rdatalist_tordataset(rdatalist,\
    \ rdataset) ==\n+\t\t\t      ISC_R_SUCCESS);\n+\t\tdns_rdataset_setownercase(rdataset,\
    \ name);\n+\t\trdatalist = NULL;\n+\n \t\t/*\n \t\t * Search name for the particular\
    \ type and class.\n \t\t * Skip this stage if in update mode or this is a meta-type.\n\
    \ \t\t */\n-\t\tif (preserve_order || msg->opcode == dns_opcode_update ||\n-\t\
    \t    skip_type_search)\n+\t\tif (isedns || istsig || issigzero) {\n+\t\t\t/*\
    \ Skip adding the rdataset to the tables */\n+\t\t} else if (preserve_order ||\
    \ msg->opcode == dns_opcode_update ||\n+\t\t\t   skip_type_search)\n \t\t{\n-\t\
    \t\tresult = ISC_R_NOTFOUND;\n+\t\t\tresult = ISC_R_SUCCESS;\n+\n+\t\t\tISC_LIST_APPEND(name->list,\
    \ rdataset, link);\n \t\t} else {\n \t\t\t/*\n \t\t\t * If this is a type that\
    \ can only occur in\n \t\t\t * the question section, fail.\n \t\t\t */\n \t\t\t\
    if (dns_rdatatype_questiononly(rdtype)) {\n+\t\t\t\tdns_message_puttemprdataset(msg,\
    \ &rdataset);\n \t\t\t\tDO_ERROR(DNS_R_FORMERR);\n \t\t\t}\n \n-\t\t\trdataset\
    \ = NULL;\n-\t\t\tresult = dns_message_find(name, rdclass, rdtype, covers,\n-\t\
    \t\t\t\t\t  &rdataset);\n-\t\t}\n+\t\t\tif (ISC_LIST_EMPTY(name->list)) {\n+\t\
    \t\t\tresult = ISC_R_SUCCESS;\n+\t\t\t\tgoto skip_rds_check;\n+\t\t\t}\n+\n+\t\
    \t\tif (name->ht == NULL) {\n+\t\t\t\tisc_ht_init(&name->ht, msg->mctx, 1,\n+\t\
    \t\t\t\t    ISC_HT_CASE_SENSITIVE);\n+\t\t\t\tfree_ht = true;\n+\n+\t\t\t\tINSIST(ISC_LIST_HEAD(name->list)\
    \ ==\n+\t\t\t\t       ISC_LIST_TAIL(name->list));\n+\n+\t\t\t\tdns_rdataset_t\
    \ *old_rdataset =\n+\t\t\t\t\tISC_LIST_HEAD(name->list);\n+\n+\t\t\t\tresult =\
    \ rds_hash_add(name->ht, old_rdataset,\n+\t\t\t\t\t\t      NULL);\n+\n+\t\t\t\t\
    INSIST(result == ISC_R_SUCCESS);\n+\t\t\t}\n+\t\t\tfound_rdataset = NULL;\n+\t\
    \t\tresult = rds_hash_add(name->ht, rdataset,\n+\t\t\t\t\t      &found_rdataset);\n\
    +\n+\t\t\t/*\n+\t\t\t * If we found an rdataset that matches, we need to\n+\t\t\
    \t * append this rdata to that set.  If we did not, we\n+\t\t\t * need to create\
    \ a new rdatalist, store the important\n+\t\t\t * bits there, convert it to an\
    \ rdataset, and link the\n+\t\t\t * latter to the name. Yuck.  When appending,\
    \ make\n+\t\t\t * certain that the type isn't a singleton type, such as\n+\t\t\
    \t * SOA or CNAME.\n+\t\t\t *\n+\t\t\t * Note that this check will be bypassed\
    \ when preserving\n+\t\t\t * order, the opcode is an update, or the type search\
    \ is\n+\t\t\t * skipped.\n+\t\t\t */\n+\t\tskip_rds_check:\n+\t\t\tswitch (result)\
    \ {\n+\t\t\tcase ISC_R_EXISTS:\n+\t\t\t\t/* Free the rdataset we used as the key\
    \ */\n+\t\t\t\tdns_rdataset_disassociate(rdataset);\n+\t\t\t\tisc_mempool_put(msg->rdspool,\
    \ rdataset);\n+\t\t\t\trdataset = found_rdataset;\n+\n+\t\t\t\tresult = ISC_R_SUCCESS;\n\
    +\n+\t\t\t\tif (!dns_rdatatype_issingleton(rdtype)) {\n+\t\t\t\t\tbreak;\n+\t\t\
    \t\t}\n \n-\t\t/*\n-\t\t * If we found an rdataset that matches, we need to\n\
    -\t\t * append this rdata to that set.  If we did not, we need\n-\t\t * to create\
    \ a new rdatalist, store the important bits there,\n-\t\t * convert it to an rdataset,\
    \ and link the latter to the name.\n-\t\t * Yuck.  When appending, make certain\
    \ that the type isn't\n-\t\t * a singleton type, such as SOA or CNAME.\n-\t\t\
    \ *\n-\t\t * Note that this check will be bypassed when preserving order,\n-\t\
    \t * the opcode is an update, or the type search is skipped.\n-\t\t */\n-\t\t\
    if (result == ISC_R_SUCCESS) {\n-\t\t\tif (dns_rdatatype_issingleton(rdtype))\
    \ {\n \t\t\t\tdns_rdata_t *first;\n \t\t\t\tdns_rdatalist_fromrdataset(rdataset,\n\
    \ \t\t\t\t\t\t\t   &rdatalist);\n@@ -1508,33 +1651,12 @@ getsection(isc_buffer_t\
    \ *source, dns_message_t *msg, dns_decompress_t *dctx,\n \t\t\t\tif (dns_rdata_compare(rdata,\
    \ first) != 0) {\n \t\t\t\t\tDO_ERROR(DNS_R_FORMERR);\n \t\t\t\t}\n-\t\t\t}\n\
    -\t\t}\n-\n-\t\tif (result == ISC_R_NOTFOUND) {\n-\t\t\trdataset = isc_mempool_get(msg->rdspool);\n\
    -\t\t\tfree_rdataset = true;\n-\n-\t\t\trdatalist = newrdatalist(msg);\n-\t\t\t\
    if (rdatalist == NULL) {\n-\t\t\t\tresult = ISC_R_NOMEMORY;\n-\t\t\t\tgoto cleanup;\n\
    -\t\t\t}\n-\n-\t\t\trdatalist->type = rdtype;\n-\t\t\trdatalist->covers = covers;\n\
    -\t\t\trdatalist->rdclass = rdclass;\n-\t\t\trdatalist->ttl = ttl;\n-\n-\t\t\t\
    dns_rdataset_init(rdataset);\n-\t\t\tRUNTIME_CHECK(\n-\t\t\t\tdns_rdatalist_tordataset(rdatalist,\
    \ rdataset) ==\n-\t\t\t\tISC_R_SUCCESS);\n-\t\t\tdns_rdataset_setownercase(rdataset,\
    \ name);\n-\n-\t\t\tif (!isedns && !istsig && !issigzero) {\n+\t\t\t\tbreak;\n\
    +\t\t\tcase ISC_R_SUCCESS:\n \t\t\t\tISC_LIST_APPEND(name->list, rdataset, link);\n\
    -\t\t\t\tfree_rdataset = false;\n+\t\t\t\tbreak;\n+\t\t\tdefault:\n+\t\t\t\tUNREACHABLE();\n\
    \ \t\t\t}\n \t\t}\n \n@@ -1570,7 +1692,6 @@ getsection(isc_buffer_t *source, dns_message_t\
    \ *msg, dns_decompress_t *dctx,\n \n \t\t\tmsg->opt = rdataset;\n \t\t\trdataset\
    \ = NULL;\n-\t\t\tfree_rdataset = false;\n \t\t\tercode = (dns_rcode_t)((msg->opt->ttl\
    \ &\n \t\t\t\t\t\tDNS_MESSAGE_EDNSRCODE_MASK) >>\n \t\t\t\t\t       20);\n@@ -1582,7\
    \ +1703,6 @@ getsection(isc_buffer_t *source, dns_message_t *msg, dns_decompress_t\
    \ *dctx,\n \t\t\tmsg->sig0name = name;\n \t\t\tmsg->sigstart = recstart;\n \t\t\
    \trdataset = NULL;\n-\t\t\tfree_rdataset = false;\n \t\t\tfree_name = false;\n\
    \ \t\t} else if (istsig) {\n \t\t\tmsg->tsig = rdataset;\n@@ -1593,21 +1713,18\
    \ @@ getsection(isc_buffer_t *source, dns_message_t *msg, dns_decompress_t *dctx,\n\
    \ \t\t\t */\n \t\t\tmsg->tsigname->attributes |= DNS_NAMEATTR_NOCOMPRESS;\n \t\
    \t\trdataset = NULL;\n-\t\t\tfree_rdataset = false;\n \t\t\tfree_name = false;\n\
    \ \t\t}\n \n \t\tif (seen_problem) {\n \t\t\tif (free_name) {\n \t\t\t\tdns_message_puttempname(msg,\
    \ &name);\n \t\t\t}\n-\t\t\tif (free_rdataset) {\n-\t\t\t\tisc_mempool_put(msg->rdspool,\
    \ rdataset);\n-\t\t\t}\n-\t\t\tfree_name = free_rdataset = false;\n+\t\t\tfree_name\
    \ = false;\n \t\t}\n \t\tINSIST(!free_name);\n-\t\tINSIST(!free_rdataset);\n+\n\
    +\t\trdataset = NULL;\n \t}\n \n \t/*\n@@ -1625,16 +1742,20 @@ getsection(isc_buffer_t\
    \ *source, dns_message_t *msg, dns_decompress_t *dctx,\n \t}\n \n \tif (seen_problem)\
    \ {\n-\t\treturn (DNS_R_RECOVERABLE);\n+\t\tresult = DNS_R_RECOVERABLE;\n \t}\n\
    -\treturn (ISC_R_SUCCESS);\n \n cleanup:\n \tif (free_name) {\n \t\tdns_message_puttempname(msg,\
    \ &name);\n \t}\n-\tif (free_rdataset) {\n-\t\tisc_mempool_put(msg->rdspool, rdataset);\n\
    +\n+\tif (free_ht) {\n+\t\tcleanup_name_hashmaps(section);\n+\t}\n+\n+\tif (name_map\
    \ != NULL) {\n+\t\tisc_ht_destroy(&name_map);\n \t}\n \n \treturn (result);\n\
    @@ -2452,7 +2573,7 @@ dns_message_findname(dns_message_t *msg, dns_section_t section,\n\
    \ \t\t     const dns_name_t *target, dns_rdatatype_t type,\n \t\t     dns_rdatatype_t\
    \ covers, dns_name_t **name,\n \t\t     dns_rdataset_t **rdataset) {\n-\tdns_name_t\
    \ *foundname;\n+\tdns_name_t *foundname = NULL;\n \tisc_result_t result;\n \n\
    \ \t/*\n@@ -2499,22 +2620,6 @@ dns_message_findname(dns_message_t *msg, dns_section_t\
    \ section,\n \treturn (result);\n }\n \n-void\n-dns_message_movename(dns_message_t\
    \ *msg, dns_name_t *name,\n-\t\t     dns_section_t fromsection, dns_section_t\
    \ tosection) {\n-\tREQUIRE(msg != NULL);\n-\tREQUIRE(msg->from_to_wire == DNS_MESSAGE_INTENTRENDER);\n\
    -\tREQUIRE(name != NULL);\n-\tREQUIRE(VALID_NAMED_SECTION(fromsection));\n-\t\
    REQUIRE(VALID_NAMED_SECTION(tosection));\n-\n-\t/*\n-\t * Unlink the name from\
    \ the old section\n-\t */\n-\tISC_LIST_UNLINK(msg->sections[fromsection], name,\
    \ link);\n-\tISC_LIST_APPEND(msg->sections[tosection], name, link);\n-}\n-\n void\n\
    \ dns_message_addname(dns_message_t *msg, dns_name_t *name,\n \t\t    dns_section_t\
    \ section) {\n@@ -2591,6 +2696,10 @@ dns_message_puttempname(dns_message_t *msg,\
    \ dns_name_t **itemp) {\n \tREQUIRE(!ISC_LINK_LINKED(item, link));\n \tREQUIRE(ISC_LIST_HEAD(item->list)\
    \ == NULL);\n \n+\tif (item->ht != NULL) {\n+\t\tisc_ht_destroy(&item->ht);\n\
    +\t}\n+\n \t/*\n \t * we need to check this in case dns_name_dup() was used.\n\
    \ \t */"
  - "--- a/lib/dns/name.c\n+++ b/lib/dns/name.c\n@@ -188,6 +188,7 @@ dns_name_invalidate(dns_name_t\
    \ *name) {\n \tname->offsets = NULL;\n \tname->buffer = NULL;\n \tISC_LINK_INIT(name,\
    \ link);\n+\tINSIST(name->ht == NULL);\n }\n \n bool"
  identifiers: CVE:["CVE-2023-4408"],CWE:["CWE-407"]
  overview: Affected versions of this package are vulnerable to Inefficient Algorithmic
    Complexity in the DNS message parsing code in `named` which could be exploited
    to cause excessive CPU load.
  references:
    GitHub Commit: https://github.com/isc-projects/bind9/commit/7f39a9888b416155353d71577362a22fc9f60b58
    Vulnerability Advisory: https://kb.isc.org/docs/cve-2023-4408
  title: Inefficient Algorithmic Complexity
- diff_content:
  - "--- a/lib/ns/query.c\n+++ b/lib/ns/query.c\n@@ -455,10 +455,10 @@ static void\n\
    \ query_addnxrrsetnsec(query_ctx_t *qctx);\n \n static isc_result_t\n-query_nxdomain(query_ctx_t\
    \ *qctx, bool empty_wild);\n+query_nxdomain(query_ctx_t *qctx, isc_result_t result);\n\
    \ \n static isc_result_t\n-query_redirect(query_ctx_t *qctx);\n+query_redirect(query_ctx_t\
    \ *qctx, isc_result_t result);\n \n static isc_result_t\n query_ncache(query_ctx_t\
    \ *qctx, isc_result_t result);\n@@ -7345,8 +7345,7 @@ query_usestale(query_ctx_t\
    \ *qctx, isc_result_t result) {\n  * result from the search.\n  */\n static isc_result_t\n\
    -query_gotanswer(query_ctx_t *qctx, isc_result_t res) {\n-\tisc_result_t result\
    \ = res;\n+query_gotanswer(query_ctx_t *qctx, isc_result_t result) {\n \tchar\
    \ errmsg[256];\n \n \tCCTRACE(ISC_LOG_DEBUG(3), \"query_gotanswer\");\n@@ -7416,16\
    \ +7415,16 @@ query_gotanswer(query_ctx_t *qctx, isc_result_t res) {\n \t\treturn\
    \ (query_nodata(qctx, DNS_R_NXRRSET));\n \n \tcase DNS_R_EMPTYWILD:\n-\t\treturn\
    \ (query_nxdomain(qctx, true));\n+\t\treturn (query_nxdomain(qctx, DNS_R_EMPTYWILD));\n\
    \ \n \tcase DNS_R_NXDOMAIN:\n-\t\treturn (query_nxdomain(qctx, false));\n+\t\t\
    return (query_nxdomain(qctx, DNS_R_NXDOMAIN));\n \n \tcase DNS_R_COVERINGNSEC:\n\
    \ \t\treturn (query_coveringnsec(qctx));\n \n \tcase DNS_R_NCACHENXDOMAIN:\n-\t\
    \tresult = query_redirect(qctx);\n+\t\tresult = query_redirect(qctx, result);\n\
    \ \t\tif (result != ISC_R_COMPLETE) {\n \t\t\treturn (result);\n \t\t}\n@@ -9243,10\
    \ +9242,10 @@ query_addnxrrsetnsec(query_ctx_t *qctx) {\n  * Handle NXDOMAIN and\
    \ empty wildcard responses.\n  */\n static isc_result_t\n-query_nxdomain(query_ctx_t\
    \ *qctx, bool empty_wild) {\n+query_nxdomain(query_ctx_t *qctx, isc_result_t result)\
    \ {\n \tdns_section_t section;\n \tuint32_t ttl;\n-\tisc_result_t result;\n+\t\
    bool empty_wild = (result == DNS_R_EMPTYWILD);\n \n \tCCTRACE(ISC_LOG_DEBUG(3),\
    \ \"query_nxdomain\");\n \n@@ -9255,7 +9254,7 @@ query_nxdomain(query_ctx_t *qctx,\
    \ bool empty_wild) {\n \tINSIST(qctx->is_zone || REDIRECT(qctx->client));\n \n\
    \ \tif (!empty_wild) {\n-\t\tresult = query_redirect(qctx);\n+\t\tresult = query_redirect(qctx,\
    \ result);\n \t\tif (result != ISC_R_COMPLETE) {\n \t\t\treturn (result);\n \t\
    \t}\n@@ -9343,7 +9342,7 @@ query_nxdomain(query_ctx_t *qctx, bool empty_wild)\
    \ {\n  * redirecting, so query processing should continue past it.\n  */\n static\
    \ isc_result_t\n-query_redirect(query_ctx_t *qctx) {\n+query_redirect(query_ctx_t\
    \ *qctx, isc_result_t saved_result) {\n \tisc_result_t result;\n \n \tCCTRACE(ISC_LOG_DEBUG(3),\
    \ \"query_redirect\");\n@@ -9384,7 +9383,7 @@ query_redirect(query_ctx_t *qctx)\
    \ {\n \t\tSAVE(qctx->client->query.redirect.rdataset, qctx->rdataset);\n \t\t\
    SAVE(qctx->client->query.redirect.sigrdataset,\n \t\t     qctx->sigrdataset);\n\
    -\t\tqctx->client->query.redirect.result = DNS_R_NCACHENXDOMAIN;\n+\t\tqctx->client->query.redirect.result\
    \ = saved_result;\n \t\tdns_name_copynf(qctx->fname,\n \t\t\t\tqctx->client->query.redirect.fname);\n\
    \ \t\tqctx->client->query.redirect.authoritative =\n@@ -10005,7 +10004,7 @@ query_coveringnsec(query_ctx_t\
    \ *qctx) {\n \t * We now have the proof that we have an NXDOMAIN.  Apply\n \t\
    \ * NXDOMAIN redirection if configured.\n \t */\n-\tresult = query_redirect(qctx);\n\
    +\tresult = query_redirect(qctx, DNS_R_COVERINGNSEC);\n \tif (result != ISC_R_COMPLETE)\
    \ {\n \t\tredirected = true;\n \t\tgoto cleanup;"
  identifiers: CVE:["CVE-2023-5517"],CWE:["CWE-617"]
  overview: Affected versions of this package are vulnerable to Reachable Assertion
    due to the `nxdomain-redirect` feature being configured and the resolver receiving
    a PTR query for an RFC 1918 address that would normally result in an authoritative
    NXDOMAIN response. An attacker can cause the `named` process to exit prematurely
    with an assertion failure.
  references:
    GitHub Commit: https://github.com/isc-projects/bind9/commit/c73262493658cb8623927ef6cc2f023501f7e809
    Vulnerability Advisory: https://kb.isc.org/docs/cve-2023-5517
  title: Reachable Assertion
- diff_content:
  - "--- a/lib/ns/query.c\n+++ b/lib/ns/query.c\n@@ -6228,6 +6228,13 @@ query_lookup_stale(ns_client_t\
    \ *client) {\n \tquery_ctx_t qctx;\n \n \tqctx_init(client, NULL, client->query.qtype,\
    \ &qctx);\n+\tif (DNS64(client)) {\n+\t\tqctx.qtype = qctx.type = dns_rdatatype_a;\n\
    +\t\tqctx.dns64 = true;\n+\t}\n+\tif (DNS64EXCLUDE(client)) {\n+\t\tqctx.dns64_exclude\
    \ = true;\n+\t}\n \tdns_db_attach(client->view->cachedb, &qctx.db);\n \tclient->query.attributes\
    \ &= ~NS_QUERYATTR_RECURSIONOK;\n \tclient->query.dboptions |= DNS_DBFIND_STALETIMEOUT;"
  identifiers: CVE:["CVE-2023-5679"],CWE:["CWE-400"]
  overview: Affected versions of this package are vulnerable to Denial of Service
    (DoS) due to a bad interaction between DNS64 and serve-stale features, which may
    lead to an assertion failure during recursive resolution. This is only exploitable
    if both DNS64 and serve-stale features are enabled.
  references:
    GitHub Commit: https://github.com/isc-projects/bind9/commit/efbe5b660d8663e54fbaece087f930eab11d8784
    Vulnerability Advisory: https://kb.isc.org/docs/cve-2023-5679
    commons-fileupload:commons-fileupload: SNYK-JAVA-COMMONSFILEUPLOAD-30082
    npm <code>ws</code> package: https://snyk.io/vuln/npm:ws:20171108
  title: Denial of Service (DoS)
- diff_content:
  - "--- a/arch/cpu/nrf/net/nrf-ieee-driver-arch.c\n+++ b/arch/cpu/nrf/net/nrf-ieee-driver-arch.c\n\
    @@ -704,8 +704,8 @@ read_frame(void *buf, unsigned short bufsize)\n \n   payload_len\
    \ = rx_buf.phr - FCS_LEN;\n \n-  if(phr_is_valid(rx_buf.phr) == false) {\n-  \
    \  LOG_DBG(\"Incorrect length: %d\\n\", payload_len);\n+  if(phr_is_valid(rx_buf.phr)\
    \ == false || payload_len > bufsize) {\n+    LOG_DBG(\"Incorrect length: %d (bufsize:\
    \ %hu)\\n\", payload_len, bufsize);\n     rx_buf_clear();\n     enter_rx();\n\
    \     return 0;"
  - "--- a/arch/cpu/nrf52840/rf/nrf52840-ieee.c\n+++ b/arch/cpu/nrf52840/rf/nrf52840-ieee.c\n\
    @@ -655,8 +655,8 @@ read_frame(void *buf, unsigned short bufsize)\n \n   payload_len\
    \ = rx_buf.phr - FCS_LEN;\n \n-  if(phr_is_valid(rx_buf.phr) == false) {\n-  \
    \  LOG_DBG(\"Incorrect length: %d\\n\", payload_len);\n+  if(phr_is_valid(rx_buf.phr)\
    \ == false || payload_len > bufsize) {\n+    LOG_DBG(\"Incorrect length: %d (bufsize:\
    \ %hu)\\n\", payload_len, bufsize);\n     rx_buf_clear();\n     enter_rx();\n\
    \     return 0;"
  identifiers: CVE:["CVE-2023-48229"],CWE:["CWE-787"]
  overview: Affected versions of this package are vulnerable to Out-of-bounds Write
    in to the `read_frame` function in the `arch/cpu/nrf/net/nrf-ieee-driver-arch.c`
    module. An attacker can write data outside the intended buffer boundaries by sending
    specially crafted radio packets with a payload length that exceeds the buffer
    capacity allocated for the packet.
  references:
    GitHub Commit: https://github.com/contiki-ng/contiki-ng/commit/ac8f9a792781c167532ef0fd840ac5962262444d
    GitHub PR: https://github.com/contiki-ng/contiki-ng/pull/2741
  title: Out-of-bounds Write
- diff_content:
  - "--- a/os/net/routing/rpl-lite/rpl-icmp6.c\n+++ b/os/net/routing/rpl-lite/rpl-icmp6.c\n\
    @@ -319,6 +319,12 @@ dio_input(void)\n           goto discard;\n         }\n \
    \        dio.prefix_info.length = buffer[i + 2];\n+        if(dio.prefix_info.length\
    \ > sizeof(uip_ipaddr_t) * 8) {\n+          LOG_WARN(\"dio_input: invalid DAG\
    \ prefix info, len %u > %zu\\n\",\n+                   dio.prefix_info.length,\
    \ sizeof(uip_ipaddr_t) * 8);\n+          goto discard;\n+        }\n+\n      \
    \   dio.prefix_info.flags = buffer[i + 3];\n         /* valid lifetime is ingnored\
    \ for now - at i + 4 */\n         /* preferred lifetime stored in lifetime */"
  identifiers: CVE:["CVE-2023-50926"],CWE:["CWE-125"]
  overview: Affected versions of this package are vulnerable to Out-of-bounds Read
    due to the handling of incoming DIO messages in the `RPL-Lite` implementation.
    An attacker can specify a prefix length value that exceeds the maximum allowed,
    leading to a `memcmp` function call with a length argument that goes beyond the
    allocated array boundary for the prefix.
  references:
    GitHub Commit: https://github.com/contiki-ng/contiki-ng/commit/5aa701bd59082e31be094fc652723b804f315b37
    GitHub PR: https://github.com/contiki-ng/contiki-ng/pull/2721
  title: Out-of-bounds Read
- diff_content:
  - "--- a/wolfcrypt/src/rsa.c\n+++ b/wolfcrypt/src/rsa.c\n@@ -2495,6 +2495,7 @@ static\
    \ int RsaFunctionPrivate(mp_int* tmp, RsaKey* key, WC_RNG* rng)\n {\n     int\
    \    ret = 0;\n #if defined(WC_RSA_BLINDING) && !defined(WC_NO_RNG)\n+    mp_digit\
    \ mp;\n     DECL_MP_INT_SIZE_DYN(rnd, mp_bitsused(&key->n), RSA_MAX_SIZE);\n \
    \    DECL_MP_INT_SIZE_DYN(rndi, mp_bitsused(&key->n), RSA_MAX_SIZE);\n #endif\
    \ /* WC_RSA_BLINDING && !WC_NO_RNG */\n@@ -2627,9 +2628,31 @@ static int RsaFunctionPrivate(mp_int*\
    \ tmp, RsaKey* key, WC_RNG* rng)\n #endif   /* RSA_LOW_MEM */\n \n #if defined(WC_RSA_BLINDING)\
    \ && !defined(WC_NO_RNG)\n-    /* unblind */\n-    if (ret == 0 && mp_mulmod(tmp,\
    \ rndi, &key->n, tmp) != MP_OKAY)\n+    /* Multiply result (tmp) by bliding invertor\
    \ (rndi).\n+     * Use Montogemery form to make operation more constant time.\n\
    +     */\n+    if ((ret == 0) && (mp_montgomery_setup(&key->n, &mp) != MP_OKAY))\
    \ {\n+        ret = MP_MULMOD_E;\n+    }\n+    if ((ret == 0) && (mp_montgomery_calc_normalization(rnd,\
    \ &key->n) !=\n+            MP_OKAY)) {\n+        ret = MP_MULMOD_E;\n+    }\n\
    +    /* Convert blinding invert to Montogmery form. */\n+    if ((ret == 0) &&\
    \ (mp_mul(rndi, rnd, rndi) != MP_OKAY)) {\n+        ret = MP_MULMOD_E;\n+    }\n\
    +    if ((ret == 0) && (mp_mod(rndi, &key->n, rndi) != MP_OKAY)) {\n         ret\
    \ = MP_MULMOD_E;\n+    }\n+    /* Multiply result by blinding invert. */\n+  \
    \  if ((ret == 0) && (mp_mul(tmp, rndi, tmp) != MP_OKAY)) {\n+        ret = MP_MULMOD_E;\n\
    +    }\n+    /* Reduce result. */\n+    if ((ret == 0) && (mp_montgomery_reduce_ct(tmp,\
    \ &key->n, mp) != MP_OKAY)) {\n+        ret = MP_MULMOD_E;\n+    }\n \n     mp_forcezero(rndi);\n\
    \     mp_forcezero(rnd);\n@@ -3520,8 +3543,9 @@ static int RsaPrivateDecryptEx(const\
    \ byte* in, word32 inLen, byte* out,\n                              mgf, label,\
    \ labelSz, saltLen,\n                              mp_count_bits(&key->n), key->heap);\n\
    \ #endif\n-        if (rsa_type == RSA_PUBLIC_DECRYPT && ret > (int)outLen)\n\
    +        if (rsa_type == RSA_PUBLIC_DECRYPT && ret > (int)outLen) {\n        \
    \     ret = RSA_BUFFER_E;\n+        }\n         else if (ret >= 0 && pad != NULL)\
    \ {\n             /* only copy output if not inline */\n             if (outPtr\
    \ == NULL) {\n@@ -3547,8 +3571,9 @@ static int RsaPrivateDecryptEx(const byte*\
    \ in, word32 inLen, byte* out,\n                     XMEMCPY(out, pad, (size_t)ret);\n\
    \                 }\n             }\n-            else\n+            else {\n\
    \                 *outPtr = pad;\n+            }\n \n #if !defined(WOLFSSL_RSA_VERIFY_ONLY)\n\
    \             ret = ctMaskSelInt(ctMaskLTE(ret, (int)outLen), ret, RSA_BUFFER_E);"
  - "--- a/wolfcrypt/src/sp_int.c\n+++ b/wolfcrypt/src/sp_int.c\n@@ -4770,7 +4770,7\
    \ @@ WOLFSSL_LOCAL int sp_ModExp_4096(sp_int* base, sp_int* exp, sp_int* mod,\n\
    \ \n #if defined(WOLFSSL_SP_MATH_ALL) || defined(WOLFSSL_HAVE_SP_DH) || \\\n \
    \    defined(OPENSSL_ALL)\n-static int _sp_mont_red(sp_int* a, const sp_int* m,\
    \ sp_int_digit mp);\n+static int _sp_mont_red(sp_int* a, const sp_int* m, sp_int_digit\
    \ mp, int ct);\n #endif\n #if defined(WOLFSSL_SP_MATH_ALL) || defined(WOLFSSL_HAVE_SP_DH)\
    \ || \\\n     defined(WOLFCRYPT_HAVE_ECCSI) || defined(WOLFCRYPT_HAVE_SAKKE) ||\
    \ \\\n@@ -7673,6 +7673,28 @@ int sp_submod(const sp_int* a, const sp_int* b, const\
    \ sp_int* m, sp_int* r)\n }\n #endif /* WOLFSSL_SP_MATH_ALL */\n \n+#if (defined(WOLFSSL_SP_MATH_ALL)\
    \ && defined(HAVE_ECC)) || \\\n+    (defined(WOLFSSL_SP_MATH_ALL) || defined(WOLFSSL_HAVE_SP_DH)\
    \ || \\\n+     defined(WOLFCRYPT_HAVE_ECCSI) || defined(WOLFCRYPT_HAVE_SAKKE)\
    \ || \\\n+     defined(OPENSSL_ALL))\n+/* Constant time clamping/\n+ *\n+ * @param\
    \ [in, out] a  SP integer to clamp.\n+ */\n+static void sp_clamp_ct(sp_int* a)\n\
    +{\n+    int i;\n+    unsigned int used = a->used;\n+    unsigned int mask = (unsigned\
    \ int)-1;\n+\n+    for (i = a->used-1; i >= 0; i--) {\n+        used -= ((unsigned\
    \ int)(a->dp[i] == 0)) & mask;\n+        mask &= (unsigned int)0 - (a->dp[i] ==\
    \ 0);\n+    }\n+    a->used = used;\n+}\n+#endif\n+\n #if defined(WOLFSSL_SP_MATH_ALL)\
    \ && defined(HAVE_ECC)\n /* Add two value and reduce: r = (a + b) % m\n  *\n@@\
    \ -7826,7 +7848,7 @@ int sp_addmod_ct(const sp_int* a, const sp_int* b, const\
    \ sp_int* m, sp_int* r)\n         r->sign = MP_ZPOS;\n     #endif /* WOLFSSL_SP_INT_NEGATIVE\
    \ */\n         /* Remove leading zeros. */\n-        sp_clamp(r);\n+        sp_clamp_ct(r);\n\
    \ \n #if 0\n         sp_print(r, \"rma\");\n@@ -7837,11 +7859,13 @@ int sp_addmod_ct(const\
    \ sp_int* a, const sp_int* b, const sp_int* m, sp_int* r)\n }\n #endif /* WOLFSSL_SP_MATH_ALL\
    \ && HAVE_ECC */\n \n-#if defined(WOLFSSL_SP_MATH_ALL) && defined(HAVE_ECC)\n\
    -/* Sub b from a and reduce: r = (a - b) % m\n- * Result is always positive.\n\
    +#if (defined(WOLFSSL_SP_MATH_ALL) && defined(HAVE_ECC)) || \\\n+    (defined(WOLFSSL_SP_MATH_ALL)\
    \ || defined(WOLFSSL_HAVE_SP_DH) || \\\n+     defined(WOLFCRYPT_HAVE_ECCSI) ||\
    \ defined(WOLFCRYPT_HAVE_SAKKE) || \\\n+     defined(OPENSSL_ALL))\n+/* Sub b\
    \ from a modulo m: r = (a - b) % m\n  *\n- * r = a - b (mod m) - constant time\
    \ (a < m and b < m, a, b and m are positive)\n+ * Result is always positive.\n\
    \  *\n  * Assumes a, b, m and r are not NULL.\n  * m and r must not be the same\
    \ pointer.\n@@ -7853,9 +7877,9 @@ int sp_addmod_ct(const sp_int* a, const sp_int*\
    \ b, const sp_int* m, sp_int* r)\n  *\n  * @return  MP_OKAY on success.\n  */\n\
    -int sp_submod_ct(const sp_int* a, const sp_int* b, const sp_int* m, sp_int* r)\n\
    +static void _sp_submod_ct(const sp_int* a, const sp_int* b, const sp_int* m,\n\
    +    unsigned int max, sp_int* r)\n {\n-    int err = MP_OKAY;\n #ifndef SQR_MUL_ASM\n\
    \     sp_int_sword w;\n #else\n@@ -7868,6 +7892,106 @@ int sp_submod_ct(const\
    \ sp_int* a, const sp_int* b, const sp_int* m, sp_int* r)\n     sp_int_digit mask_b\
    \ = (sp_int_digit)-1;\n     unsigned int i;\n \n+    /* In constant time, subtract\
    \ b from a putting result in r. */\n+#ifndef SQR_MUL_ASM\n+    w = 0;\n+#else\n\
    +    l = 0;\n+    h = 0;\n+#endif\n+    for (i = 0; i < max; i++) {\n+       \
    \ /* Values past 'used' are not initialized. */\n+        mask_a += (i == a->used);\n\
    +        mask_b += (i == b->used);\n+\n+    #ifndef SQR_MUL_ASM\n+        /* Add\
    \ a to and subtract b from current value. */\n+        w         += a->dp[i] &\
    \ mask_a;\n+        w         -= b->dp[i] & mask_b;\n+        /* Store low digit\
    \ in result. */\n+        r->dp[i]   = (sp_int_digit)w;\n+        /* Move high\
    \ digit down. */\n+        w        >>= DIGIT_BIT;\n+    #else\n+        /* Add\
    \ a and subtract b from current value. */\n+        t = a->dp[i] & mask_a;\n+\
    \        SP_ASM_ADDC_REG(l, h, t);\n+        t = b->dp[i] & mask_b;\n+       \
    \ SP_ASM_SUBB_REG(l, h, t);\n+        /* Store low digit in result. */\n+    \
    \    r->dp[i] = l;\n+        /* Move high digit down. */\n+        l = h;\n+ \
    \       /* High digit is 0 when positive or -1 on negative. */\n+        h = (sp_int_digit)0\
    \ - (l >> (SP_WORD_SIZE - 1));\n+    #endif\n+    }\n+    /* When w is negative\
    \ then we need to add modulus to make result\n+     * positive. */\n+#ifndef SQR_MUL_ASM\n\
    +    mask = (sp_int_digit)0 - (w < 0);\n+#else\n+    mask = h;\n+#endif\n+\n+\
    \    /* Constant time, conditionally, add modulus to difference. */\n+#ifndef\
    \ SQR_MUL_ASM\n+    w = 0;\n+#else\n+    l = 0;\n+#endif\n+    for (i = 0; i <\
    \ m->used; i++) {\n+    #ifndef SQR_MUL_ASM\n+        /* Add result and conditionally\
    \ modulus to current value. */\n+        w         += r->dp[i];\n+        w  \
    \       += m->dp[i] & mask;\n+        /* Store low digit in result. */\n+    \
    \    r->dp[i]   = (sp_int_digit)w;\n+        /* Move high digit down. */\n+  \
    \      w        >>= DIGIT_BIT;\n+    #else\n+        h = 0;\n+        /* Add result\
    \ and conditionally modulus to current value. */\n+        SP_ASM_ADDC(l, h, r->dp[i]);\n\
    +        t = m->dp[i] & mask;\n+        SP_ASM_ADDC_REG(l, h, t);\n+        /*\
    \ Store low digit in result. */\n+        r->dp[i] = l;\n+        /* Move high\
    \ digit down. */\n+        l = h;\n+    #endif\n+    }\n+    /* Result will always\
    \ have digits equal to or less than those in\n+     * modulus. */\n+    r->used\
    \ = i;\n+#ifdef WOLFSSL_SP_INT_NEGATIVE\n+    r->sign = MP_ZPOS;\n+#endif /* WOLFSSL_SP_INT_NEGATIVE\
    \ */\n+    /* Remove leading zeros. */\n+    sp_clamp_ct(r);\n+}\n+#endif\n+\n\
    +#if defined(WOLFSSL_SP_MATH_ALL) && defined(HAVE_ECC)\n+/* Sub b from a modulo\
    \ m: r = (a - b) % m\n+ * Result is always positive.\n+ *\n+ * r = a - b (mod\
    \ m) - constant time (a < m and b < m, a, b and m are positive)\n+ *\n+ * Assumes\
    \ a, b, m and r are not NULL.\n+ * m and r must not be the same pointer.\n+ *\n\
    + * @param  [in]   a  SP integer to subtract from\n+ * @param  [in]   b  SP integer\
    \ to subtract.\n+ * @param  [in]   m  SP integer that is the modulus.\n+ * @param\
    \  [out]  r  SP integer to hold result.\n+ *\n+ * @return  MP_OKAY on success.\n\
    + */\n+int sp_submod_ct(const sp_int* a, const sp_int* b, const sp_int* m, sp_int*\
    \ r)\n+{\n+    int err = MP_OKAY;\n+\n     /* Check result is as big as modulus\
    \ plus one digit. */\n     if (m->used > r->size) {\n         err = MP_VAL;\n\
    @@ -7884,82 +8008,7 @@ int sp_submod_ct(const sp_int* a, const sp_int* b, const\
    \ sp_int* m, sp_int* r)\n         sp_print(m, \"m\");\n #endif\n \n-        /*\
    \ In constant time, subtract b from a putting result in r. */\n-    #ifndef SQR_MUL_ASM\n\
    -        w = 0;\n-    #else\n-        l = 0;\n-        h = 0;\n-    #endif\n-\
    \        for (i = 0; i < m->used; i++) {\n-            /* Values past 'used' are\
    \ not initialized. */\n-            mask_a += (i == a->used);\n-            mask_b\
    \ += (i == b->used);\n-\n-        #ifndef SQR_MUL_ASM\n-            /* Add a to\
    \ and subtract b from current value. */\n-            w         += a->dp[i] &\
    \ mask_a;\n-            w         -= b->dp[i] & mask_b;\n-            /* Store\
    \ low digit in result. */\n-            r->dp[i]   = (sp_int_digit)w;\n-     \
    \       /* Move high digit down. */\n-            w        >>= DIGIT_BIT;\n- \
    \       #else\n-            /* Add a and subtract b from current value. */\n-\
    \            t = a->dp[i] & mask_a;\n-            SP_ASM_ADDC_REG(l, h, t);\n\
    -            t = b->dp[i] & mask_b;\n-            SP_ASM_SUBB_REG(l, h, t);\n\
    -            /* Store low digit in result. */\n-            r->dp[i] = l;\n- \
    \           /* Move high digit down. */\n-            l = h;\n-            /*\
    \ High digit is 0 when positive or -1 on negative. */\n-            h = (sp_int_digit)0\
    \ - (l >> (SP_WORD_SIZE - 1));\n-        #endif\n-        }\n-        /* When\
    \ w is negative then we need to add modulus to make result\n-         * positive.\
    \ */\n-    #ifndef SQR_MUL_ASM\n-        mask = (sp_int_digit)0 - (w < 0);\n-\
    \    #else\n-        mask = h;\n-    #endif\n-        /* Constant time, conditionally,\
    \ add modulus to difference. */\n-    #ifndef SQR_MUL_ASM\n-        w = 0;\n-\
    \    #else\n-        l = 0;\n-    #endif\n-        for (i = 0; i < m->used; i++)\
    \ {\n-        #ifndef SQR_MUL_ASM\n-            /* Add result and conditionally\
    \ modulus to current value. */\n-            w         += r->dp[i];\n-       \
    \     w         += m->dp[i] & mask;\n-            /* Store low digit in result.\
    \ */\n-            r->dp[i]   = (sp_int_digit)w;\n-            /* Move high digit\
    \ down. */\n-            w        >>= DIGIT_BIT;\n-        #else\n-          \
    \  h = 0;\n-            /* Add result and conditionally modulus to current value.\
    \ */\n-            SP_ASM_ADDC(l, h, r->dp[i]);\n-            t = m->dp[i] & mask;\n\
    -            SP_ASM_ADDC_REG(l, h, t);\n-            /* Store low digit in result.\
    \ */\n-            r->dp[i] = l;\n-            /* Move high digit down. */\n-\
    \            l = h;\n-        #endif\n-        }\n-        /* Result will always\
    \ have digits equal to or less than those in\n-         * modulus. */\n-     \
    \   r->used = i;\n-    #ifdef WOLFSSL_SP_INT_NEGATIVE\n-        r->sign = MP_ZPOS;\n\
    -    #endif /* WOLFSSL_SP_INT_NEGATIVE */\n-        /* Remove leading zeros. */\n\
    -        sp_clamp(r);\n+        _sp_submod_ct(a, b, m, m->used, r);\n \n #if 0\n\
    \         sp_print(r, \"rms\");\n@@ -12377,14 +12426,14 @@ static int _sp_invmod_mont_ct(const\
    \ sp_int* a, const sp_int* m, sp_int* r,\n             _sp_init_size(pre[i], m->used\
    \ * 2 + 1);\n             err = sp_sqr(pre[i-1], pre[i]);\n             if (err\
    \ == MP_OKAY) {\n-                err = _sp_mont_red(pre[i], m, mp);\n+      \
    \          err = _sp_mont_red(pre[i], m, mp, 0);\n             }\n           \
    \  /* ..10 -> ..11 */\n             if (err == MP_OKAY) {\n                 err\
    \ = sp_mul(pre[i], a, pre[i]);\n             }\n             if (err == MP_OKAY)\
    \ {\n-                err = _sp_mont_red(pre[i], m, mp);\n+                err\
    \ = _sp_mont_red(pre[i], m, mp, 0);\n             }\n         }\n     }\n@@ -12438,7\
    \ +12487,7 @@ static int _sp_invmod_mont_ct(const sp_int* a, const sp_int* m,\
    \ sp_int* r,\n                     /* 6.4.2.1. t = (t ^ 2) mod m */\n        \
    \             err = sp_sqr(t, t);\n                     if (err == MP_OKAY) {\n\
    -                        err = _sp_mont_red(t, m, mp);\n+                    \
    \    err = _sp_mont_red(t, m, mp, 0);\n                     }\n              \
    \   }\n                 /* 6.4.3. s = 1 - bit */\n@@ -12449,7 +12498,7 @@ static\
    \ int _sp_invmod_mont_ct(const sp_int* a, const sp_int* m, sp_int* r,\n      \
    \               err = sp_mul(t, pre[j-1], t);\n                 }\n          \
    \       if (err == MP_OKAY) {\n-                    err = _sp_mont_red(t, m, mp);\n\
    +                    err = _sp_mont_red(t, m, mp, 0);\n                 }\n  \
    \               /* 6.4.5. j = 0\n                  *        Reset number of 1\
    \ bits seen.\n@@ -12465,7 +12514,7 @@ static int _sp_invmod_mont_ct(const sp_int*\
    \ a, const sp_int* m, sp_int* r,\n             /* 7.1. t = (t ^ 2) mod m */\n\
    \             err = sp_sqr(t, t);\n             if (err == MP_OKAY) {\n-     \
    \           err = _sp_mont_red(t, m, mp);\n+                err = _sp_mont_red(t,\
    \ m, mp, 0);\n             }\n         }\n     }\n@@ -12474,7 +12523,7 @@ static\
    \ int _sp_invmod_mont_ct(const sp_int* a, const sp_int* m, sp_int* r,\n      \
    \   if (j > 0) {\n             err = sp_mul(t, pre[j-1], r);\n             if\
    \ (err == MP_OKAY) {\n-                err = _sp_mont_red(r, m, mp);\n+      \
    \          err = _sp_mont_red(r, m, mp, 0);\n             }\n         }\n    \
    \     /* 9. Else r = t */\n@@ -12887,7 +12936,7 @@ static int _sp_exptmod_mont_ex(const\
    \ sp_int* b, const sp_int* e, int bits,\n                      t[3]);\n      \
    \       err = sp_sqr(t[3], t[3]);\n             if (err == MP_OKAY) {\n-     \
    \           err = _sp_mont_red(t[3], m, mp);\n+                err = _sp_mont_red(t[3],\
    \ m, mp, 0);\n             }\n             _sp_copy(t[3],\n                  \
    \    (sp_int*)(((size_t)t[0] & sp_off_on_addr[s^1]) +\n@@ -12907,7 +12956,7 @@\
    \ static int _sp_exptmod_mont_ex(const sp_int* b, const sp_int* e, int bits,\n\
    \                          t[3]);\n                 err = sp_mul(t[3], t[2], t[3]);\n\
    \                 if (err == MP_OKAY) {\n-                    err = _sp_mont_red(t[3],\
    \ m, mp);\n+                    err = _sp_mont_red(t[3], m, mp, 0);\n        \
    \         }\n                 _sp_copy(t[3],\n                          (sp_int*)(((size_t)t[0]\
    \ & sp_off_on_addr[j^1]) +\n@@ -12916,7 +12965,7 @@ static int _sp_exptmod_mont_ex(const\
    \ sp_int* b, const sp_int* e, int bits,\n         }\n         if (err == MP_OKAY)\
    \ {\n             /* 7. t[1] = FromMont(t[1]) */\n-            err = _sp_mont_red(t[1],\
    \ m, mp);\n+            err = _sp_mont_red(t[1], m, mp, 0);\n             /* Reduction\
    \ implementation returns number to range: 0..m-1. */\n         }\n     }\n@@ -13017,7\
    \ +13066,7 @@ static int _sp_exptmod_mont_ex(const sp_int* b, const sp_int* e,\
    \ int bits,\n             /* 4.2. t[2] = t[0] * t[1] */\n             err = sp_mul(t[0],\
    \ t[1], t[2]);\n             if (err == MP_OKAY) {\n-                err = _sp_mont_red(t[2],\
    \ m, mp);\n+                err = _sp_mont_red(t[2], m, mp, 0);\n            \
    \ }\n             /* 4.3. t[3] = t[y] ^ 2 */\n             if (err == MP_OKAY)\
    \ {\n@@ -13027,7 +13076,7 @@ static int _sp_exptmod_mont_ex(const sp_int* b, const\
    \ sp_int* e, int bits,\n                 err = sp_sqr(t[3], t[3]);\n         \
    \    }\n             if (err == MP_OKAY) {\n-                err = _sp_mont_red(t[3],\
    \ m, mp);\n+                err = _sp_mont_red(t[3], m, mp, 0);\n            \
    \ }\n             /* 4.4. t[y] = t[3], t[y^1] = t[2] */\n             if (err\
    \ == MP_OKAY) {\n@@ -13037,7 +13086,7 @@ static int _sp_exptmod_mont_ex(const\
    \ sp_int* b, const sp_int* e, int bits,\n \n         if (err == MP_OKAY) {\n \
    \            /* 5. t[0] = FromMont(t[0]) */\n-            err = _sp_mont_red(t[0],\
    \ m, mp);\n+            err = _sp_mont_red(t[0], m, mp, 0);\n             /* Reduction\
    \ implementation returns number to range: 0..m-1. */\n         }\n     }\n@@ -13189,7\
    \ +13238,7 @@ static int _sp_exptmod_mont_ex(const sp_int* b, const sp_int* e,\
    \ int bits,\n             }\n             /* Montgomery reduce square or multiplication\
    \ result. */\n             if (err == MP_OKAY) {\n-                err = _sp_mont_red(t[i],\
    \ m, mp);\n+                err = _sp_mont_red(t[i], m, mp, 0);\n            \
    \ }\n         }\n \n@@ -13250,7 +13299,7 @@ static int _sp_exptmod_mont_ex(const\
    \ sp_int* b, const sp_int* e, int bits,\n                 for (j = 0; (j < winBits)\
    \ && (err == MP_OKAY); j++) {\n                     err = sp_sqr(tr, tr);\n  \
    \                   if (err == MP_OKAY) {\n-                        err = _sp_mont_red(tr,\
    \ m, mp);\n+                        err = _sp_mont_red(tr, m, mp, 0);\n      \
    \               }\n                 }\n \n@@ -13259,14 +13308,14 @@ static int\
    \ _sp_exptmod_mont_ex(const sp_int* b, const sp_int* e, int bits,\n          \
    \           err = sp_mul(tr, t[y], tr);\n                 }\n                \
    \ if (err == MP_OKAY) {\n-                    err = _sp_mont_red(tr, m, mp);\n\
    +                    err = _sp_mont_red(tr, m, mp, 0);\n                 }\n \
    \            }\n         }\n \n         if (err == MP_OKAY) {\n             /*\
    \ 7. tr = FromMont(tr) */\n-            err = _sp_mont_red(tr, m, mp);\n+    \
    \        err = _sp_mont_red(tr, m, mp, 0);\n             /* Reduction implementation\
    \ returns number to range: 0..m-1. */\n         }\n     }\n@@ -13475,7 +13524,7\
    \ @@ static int _sp_exptmod_base_2(const sp_int* e, int digits, const sp_int*\
    \ m,\n             err = sp_sqr(tr, tr);\n             if (err == MP_OKAY) {\n\
    \                 if (useMont) {\n-                    err = _sp_mont_red(tr,\
    \ m, mp);\n+                    err = _sp_mont_red(tr, m, mp, 0);\n          \
    \       }\n                 else {\n                     err = sp_mod(tr, m, tr);\n\
    @@ -13501,7 +13550,7 @@ static int _sp_exptmod_base_2(const sp_int* e, int digits,\
    \ const sp_int* m,\n \n     /* 7. if Words(m) > 1 then tr = FromMont(tr) */\n\
    \     if ((err == MP_OKAY) && useMont) {\n-        err = _sp_mont_red(tr, m, mp);\n\
    +        err = _sp_mont_red(tr, m, mp, 0);\n         /* Reduction implementation\
    \ returns number to range: 0..m-1. */\n     }\n     if (err == MP_OKAY) {\n@@\
    \ -13880,15 +13929,15 @@ static int _sp_exptmod_nct(const sp_int* b, const sp_int*\
    \ e, const sp_int* m,\n         for (i = 1; (i < winBits) && (err == MP_OKAY);\
    \ i++) {\n             err = sp_sqr(t[0], t[0]);\n             if (err == MP_OKAY)\
    \ {\n-                err = _sp_mont_red(t[0], m, mp);\n+                err =\
    \ _sp_mont_red(t[0], m, mp, 0);\n             }\n         }\n         /* For each\
    \ table entry after first. */\n         for (i = 1; (i < preCnt) && (err == MP_OKAY);\
    \ i++) {\n             /* Multiply previous entry by the base in Mont form into\
    \ table. */\n             err = sp_mul(t[i-1], bm, t[i]);\n             if (err\
    \ == MP_OKAY) {\n-                err = _sp_mont_red(t[i], m, mp);\n+        \
    \        err = _sp_mont_red(t[i], m, mp, 0);\n             }\n         }\n \n\
    @@ -13972,7 +14021,7 @@ static int _sp_exptmod_nct(const sp_int* b, const sp_int*\
    \ e, const sp_int* m,\n                 for (; (err == MP_OKAY) && (sqrs > 0);\
    \ sqrs--) {\n                     err = sp_sqr(tr, tr);\n                    \
    \ if (err == MP_OKAY) {\n-                        err = _sp_mont_red(tr, m, mp);\n\
    +                        err = _sp_mont_red(tr, m, mp, 0);\n                 \
    \    }\n                 }\n \n@@ -14013,7 +14062,7 @@ static int _sp_exptmod_nct(const\
    \ sp_int* b, const sp_int* e, const sp_int* m,\n                     err = sp_mul(tr,\
    \ t[y], tr);\n                 }\n                 if (err == MP_OKAY) {\n-  \
    \                  err = _sp_mont_red(tr, m, mp);\n+                    err =\
    \ _sp_mont_red(tr, m, mp, 0);\n                 }\n             }\n \n@@ -14027,7\
    \ +14076,7 @@ static int _sp_exptmod_nct(const sp_int* b, const sp_int* e, const\
    \ sp_int* m,\n                     /* 5.1. Montogmery square result */\n     \
    \                err = sp_sqr(tr, tr);\n                     if (err == MP_OKAY)\
    \ {\n-                        err = _sp_mont_red(tr, m, mp);\n+              \
    \          err = _sp_mont_red(tr, m, mp, 0);\n                     }\n       \
    \              /* 5.2. If exponent bit set */\n                     if ((err ==\
    \ MP_OKAY) && ((n >> c) & 1)) {\n@@ -14036,7 +14085,7 @@ static int _sp_exptmod_nct(const\
    \ sp_int* b, const sp_int* e, const sp_int* m,\n                          */\n\
    \                         err = sp_mul(tr, bm, tr);\n                        \
    \ if (err == MP_OKAY) {\n-                            err = _sp_mont_red(tr, m,\
    \ mp);\n+                            err = _sp_mont_red(tr, m, mp, 0);\n     \
    \                    }\n                     }\n                 }\n@@ -14045,7\
    \ +14094,7 @@ static int _sp_exptmod_nct(const sp_int* b, const sp_int* e, const\
    \ sp_int* m,\n \n         if (err == MP_OKAY) {\n             /* 6. Convert result\
    \ back from Montgomery form. */\n-            err = _sp_mont_red(tr, m, mp);\n\
    +            err = _sp_mont_red(tr, m, mp, 0);\n             /* Reduction implementation\
    \ returns number to range: 0..m-1. */\n         }\n     }\n@@ -14141,7 +14190,7\
    \ @@ static int _sp_exptmod_nct(const sp_int* b, const sp_int* e, const sp_int*\
    \ m,\n             /* 3.1. Montgomery square result. */\n             err = sp_sqr(t[0],\
    \ t[0]);\n             if (err == MP_OKAY) {\n-                err = _sp_mont_red(t[0],\
    \ m, mp);\n+                err = _sp_mont_red(t[0], m, mp, 0);\n            \
    \ }\n             if (err == MP_OKAY) {\n                 /* Get bit and index\
    \ i. */\n@@ -14151,14 +14200,14 @@ static int _sp_exptmod_nct(const sp_int* b,\
    \ const sp_int* e, const sp_int* m,\n                     /* 3.2.1. Montgomery\
    \ multiply result by Mont of base. */\n                     err = sp_mul(t[0],\
    \ t[1], t[0]);\n                     if (err == MP_OKAY) {\n-                \
    \        err = _sp_mont_red(t[0], m, mp);\n+                        err = _sp_mont_red(t[0],\
    \ m, mp, 0);\n                     }\n                 }\n             }\n   \
    \      }\n         if (err == MP_OKAY) {\n             /* 4. Convert from Montgomery\
    \ form. */\n-            err = _sp_mont_red(t[0], m, mp);\n+            err =\
    \ _sp_mont_red(t[0], m, mp, 0);\n             /* Reduction implementation returns\
    \ number of range 0..m-1. */\n         }\n     }\n@@ -16995,10 +17044,11 @@ int\
    \ sp_sqrmod(const sp_int* a, const sp_int* m, sp_int* r)\n  * @param  [in,out]\
    \  a   SP integer to Montgomery reduce.\n  * @param  [in]      m   SP integer\
    \ that is the modulus.\n  * @param  [in]      mp  SP integer digit that is the\
    \ bottom digit of inv(-m).\n+ * @param  [in]      ct  Indicates operation must\
    \ be constant time.\n  *\n  * @return  MP_OKAY on success.\n  */\n-static int\
    \ _sp_mont_red(sp_int* a, const sp_int* m, sp_int_digit mp)\n+static int _sp_mont_red(sp_int*\
    \ a, const sp_int* m, sp_int_digit mp, int ct)\n {\n #if !defined(SQR_MUL_ASM)\n\
    \     unsigned int i;\n@@ -17015,8 +17065,15 @@ static int _sp_mont_red(sp_int*\
    \ a, const sp_int* m, sp_int_digit mp)\n     bits = sp_count_bits(m);\n \n   \
    \  /* Adding numbers into m->used * 2 digits - zero out unused digits. */\n- \
    \   for (i = a->used; i < m->used * 2; i++) {\n-        a->dp[i] = 0;\n+    if\
    \ (!ct) {\n+        for (i = a->used; i < m->used * 2; i++) {\n+            a->dp[i]\
    \ = 0;\n+        }\n+    }\n+    else {\n+        for (i = 0; i < m->used * 2;\
    \ i++) {\n+            a->dp[i] &= (sp_int_digit)(sp_int_sdigit)ctMaskIntGTE(a->used-1,\
    \ i);\n+        }\n     }\n \n     /* Special case when modulus is 1 digit or\
    \ less. */\n@@ -17087,16 +17144,29 @@ static int _sp_mont_red(sp_int* a, const\
    \ sp_int* m, sp_int_digit mp)\n         a->used = m->used * 2 + 1;\n     }\n \n\
    -    /* Remove leading zeros. */\n-    sp_clamp(a);\n-    /* 3. a >>= NumBits(m)\
    \ */\n-    (void)sp_rshb(a, bits, a);\n+    if (!ct) {\n+        /* Remove leading\
    \ zeros. */\n+        sp_clamp(a);\n+        /* 3. a >>= NumBits(m) */\n+    \
    \    (void)sp_rshb(a, bits, a);\n+        /* 4. a = a mod m */\n+        if (_sp_cmp_abs(a,\
    \ m) != MP_LT) {\n+            _sp_sub_off(a, m, a, 0);\n+        }\n+    }\n\
    +    else {\n+        /* 3. a >>= NumBits(m) */\n+        (void)sp_rshb(a, bits,\
    \ a);\n+        /* Constant time clamping. */\n+        sp_clamp_ct(a);\n \n-\
    \    /* 4. a = a mod m */\n-    if (_sp_cmp_abs(a, m) != MP_LT) {\n-        _sp_sub_off(a,\
    \ m, a, 0);\n+        /* 4. a = a mod m\n+         * Always subtract but at a\
    \ too high offset if a is less than m.\n+         */\n+        _sp_submod_ct(a,\
    \ m, m, m->used + 1, a);\n     }\n \n+\n #if 0\n     sp_print(a, \"rr\");\n #endif\n\
    @@ -17118,8 +17188,15 @@ static int _sp_mont_red(sp_int* a, const sp_int* m, sp_int_digit\
    \ mp)\n     bits = sp_count_bits(m);\n     mask = ((sp_int_digit)1 << (bits &\
    \ (SP_WORD_SIZE - 1))) - 1;\n \n-    for (i = a->used; i < m->used * 2; i++) {\n\
    -        a->dp[i] = 0;\n+    if (!ct) {\n+        for (i = a->used; i < m->used\
    \ * 2; i++) {\n+            a->dp[i] = 0;\n+        }\n+    }\n+    else {\n+\
    \        for (i = 0; i < m->used * 2; i++) {\n+            a->dp[i] &= (sp_int_digit)(sp_int_sdigit)ctMaskIntGTE(a->used-1,\
    \ i);\n+        }\n     }\n \n     if (m->used <= 1) {\n@@ -17398,13 +17475,21\
    \ @@ static int _sp_mont_red(sp_int* a, const sp_int* m, sp_int_digit mp)\n  \
    \       a->used = m->used * 2 + 1;\n     }\n \n-    /* Remove leading zeros. */\n\
    -    sp_clamp(a);\n-    (void)sp_rshb(a, bits, a);\n+    if (!ct) {\n+       \
    \ /* Remove leading zeros. */\n+        sp_clamp(a);\n+        (void)sp_rshb(a,\
    \ bits, a);\n+        /* a = a mod m */\n+        if (_sp_cmp_abs(a, m) != MP_LT)\
    \ {\n+            _sp_sub_off(a, m, a, 0);\n+        }\n+    }\n+    else {\n\
    +        (void)sp_rshb(a, bits, a);\n+        /* Constant time clamping. */\n\
    +        sp_clamp_ct(a);\n \n-    /* a = a mod m */\n-    if (_sp_cmp_abs(a, m)\
    \ != MP_LT) {\n-        _sp_sub_off(a, m, a, 0);\n+        _sp_submod_ct(a, m,\
    \ m, m->used + 1, a);\n     }\n \n #if 0\n@@ -17422,11 +17507,12 @@ static int\
    \ _sp_mont_red(sp_int* a, const sp_int* m, sp_int_digit mp)\n  * @param  [in,out]\
    \  a   SP integer to Montgomery reduce.\n  * @param  [in]      m   SP integer\
    \ that is the modulus.\n  * @param  [in]      mp  SP integer digit that is the\
    \ bottom digit of inv(-m).\n+ * @param  [in]      ct  Indicates operation must\
    \ be constant time.\n  *\n  * @return  MP_OKAY on success.\n  * @return  MP_VAL\
    \ when a or m is NULL or m is zero.\n  */\n-int sp_mont_red(sp_int* a, const sp_int*\
    \ m, sp_int_digit mp)\n+int sp_mont_red_ex(sp_int* a, const sp_int* m, sp_int_digit\
    \ mp, int ct)\n {\n     int err;\n \n@@ -17440,7 +17526,7 @@ int sp_mont_red(sp_int*\
    \ a, const sp_int* m, sp_int_digit mp)\n     }\n     else {\n         /* Perform\
    \ Montogomery Reduction. */\n-        err = _sp_mont_red(a, m, mp);\n+       \
    \ err = _sp_mont_red(a, m, mp, ct);\n     }\n \n     return err;"
  - "--- a/wolfcrypt/src/tfm.c\n+++ b/wolfcrypt/src/tfm.c\n@@ -6049,15 +6049,8 @@\
    \ int mp_read_radix(mp_int *a, const char *str, int radix)\n \n #endif /* !defined(NO_DSA)\
    \ || defined(HAVE_ECC) */\n \n-#ifdef HAVE_ECC\n+#if defined(HAVE_ECC) || (!defined(NO_RSA)\
    \ && defined(WC_RSA_BLINDING))\n \n-/* fast math conversion */\n-int mp_sqr(fp_int\
    \ *A, fp_int *B)\n-{\n-    return fp_sqr(A, B);\n-}\n-\n-/* fast math conversion\
    \ */\n int mp_montgomery_reduce(fp_int *a, fp_int *m, fp_digit mp)\n {\n     return\
    \ fp_montgomery_reduce(a, m, mp);\n@@ -6075,6 +6068,17 @@ int mp_montgomery_setup(fp_int\
    \ *a, fp_digit *rho)\n     return fp_montgomery_setup(a, rho);\n }\n \n+#endif\
    \ /* HAVE_ECC || (!NO_RSA && WC_RSA_BLINDING) */\n+\n+#ifdef HAVE_ECC\n+\n+/*\
    \ fast math conversion */\n+int mp_sqr(fp_int *A, fp_int *B)\n+{\n+    return\
    \ fp_sqr(A, B);\n+}\n+\n+/* fast math conversion */\n int mp_div_2(fp_int * a,\
    \ fp_int * b)\n {\n     fp_div_2(a, b);"
  identifiers: CVE:["CVE-2023-6935"],CWE:["CWE-203"]
  overview: Affected versions of this package are vulnerable to Observable Discrepancy
    due to the implementation of the `SP Math All RSA` when built with specific configuration
    options. An attacker can decrypt ciphertexts and forge signatures after probing
    with a large number of test observations (Marvin). However, the server's private
    key is not exposed. This is only exploitable if the server is configured with
    `--enable-all CFLAGS="-DWOLFSSL_STATIC_RSA"`, which enables static RSA cipher
    suites.
  references:
    GitHub Commit: https://github.com/wolfSSL/wolfssl/commit/61a2d2de3da9cf0d2daefac1a1e1f027ae50c2ef
    GitHub PR: https://github.com/wolfSSL/wolfssl/pull/6955
    Vulnerability Report: https://people.redhat.com/~hkario/marvin/
  title: Observable Discrepancy
- diff_content:
  - "--- a/src/event/quic/ngx_event_quic_protection.c\n+++ b/src/event/quic/ngx_event_quic_protection.c\n\
    @@ -1144,8 +1144,19 @@ ngx_quic_decrypt(ngx_quic_header_t *pkt, uint64_t *largest_pn)\n\
    \         key_phase = (pkt->flags & NGX_QUIC_PKT_KPHASE) != 0;\n \n         if\
    \ (key_phase != pkt->key_phase) {\n-            secret = &pkt->keys->next_key.client;\n\
    -            pkt->key_update = 1;\n+            if (pkt->keys->next_key.client.ctx\
    \ != NULL) {\n+                secret = &pkt->keys->next_key.client;\n+      \
    \          pkt->key_update = 1;\n+\n+            } else {\n+                /*\n\
    +                 * RFC 9001,  6.3. Timing of Receive Key Generation.\n+     \
    \            *\n+                 * Trial decryption to avoid timing side-channel.\n\
    +                 */\n+                ngx_log_debug0(NGX_LOG_DEBUG_EVENT, pkt->log,\
    \ 0,\n+                               \"quic next key missing\");\n+         \
    \   }\n         }\n     }\n "
  identifiers: CVE:["CVE-2024-24989"],CWE:["CWE-476"]
  overview: Affected versions of this package are vulnerable to NULL Pointer Dereference
    that allows an attacker to terminate a worker process by sending malicious traffic
    to a QUIC session.
  references:
    GitHub Commit: https://github.com/nginx/nginx/commit/5902baf680609f884a1e11ff2b82a0bffb3724cc
    RedHat Bugzilla Bug: https://bugzilla.redhat.com/show_bug.cgi?id=2264290
    Vulnerability Advisory: https://my.f5.com/manage/s/article/K000138444
  title: NULL Pointer Dereference
- diff_content:
  - "--- a/components/calendar/eventpluginsmanager.cpp\n+++ b/components/calendar/eventpluginsmanager.cpp\n\
    @@ -201,7 +201,7 @@ QStringList EventPluginsManager::enabledPlugins() const\n\
    \ \n void EventPluginsManager::loadPlugin(const QString &pluginId)\n {\n-    QPluginLoader\
    \ loader(\"plasmacalendarplugins/\" + pluginId);\n+    QPluginLoader loader(\"\
    plasmacalendarplugins/\" + QDir::cleanPath(pluginId));\n \n     if (!loader.load())\
    \ {\n         qWarning() << \"Could not create Plasma Calendar Plugin: \" << pluginId;"
  identifiers: CVE:["CVE-2024-1433"],CWE:["CWE-22"]
  overview: 'Affected versions of this package are vulnerable to Directory Traversal
    via the manipulation of the `pluginId` argument in the `EventPluginsManager::enabledPlugins`
    function of the `components/calendar/eventpluginsmanager.cpp` file. An attacker
    can achieve unauthorized file system access by crafting malicious input. '
  references:
    GitHub Commit: https://github.com/KDE/plasma-workspace/commit/6cdf42916369ebf4ad5bd876c4dfa0170d7b2f01
    vulnerability of this type: https://snyk.io/vuln/npm:st:20140206
  title: Directory Traversal
- diff_content:
  - "--- a/src/quicktimevideo.cpp\n+++ b/src/quicktimevideo.cpp\n@@ -489,43 +489,6\
    \ @@ bool dataIgnoreList(Exiv2::DataBuf& buf) {\n \n   return false;\n }\n-\n\
    -/*!\n-  @brief Function used to convert buffer data into 64-bit\n-      signed\
    \ integer, information stored in Big Endian format\n-  @param buf Data buffer\
    \ that will contain data to be converted\n-  @return Returns a signed 64-bit integer\n\
    - */\n-int64_t returnBufValue(Exiv2::DataBuf& buf, int n = 4) {\n-  int64_t temp\
    \ = 0;\n-  for (int i = n - 1; i >= 0; i--)\n-#ifdef _MSC_VER\n-    temp = temp\
    \ + static_cast<int64_t>(buf.data()[i] * (pow(static_cast<float>(256), n - i -\
    \ 1)));\n-#else\n-    temp = temp + buf.data()[i] * (pow((float)256, n - i - 1));\n\
    -#endif\n-\n-  return temp;\n-}\n-\n-/*!\n-  @brief Function used to convert buffer\
    \ data into 64-bit\n-      unsigned integer, information stored in Big Endian\
    \ format\n-  @param buf Data buffer that will contain data to be converted\n-\
    \  @return Returns an unsigned 64-bit integer\n- */\n-size_t returnUnsignedBufValue(Exiv2::DataBuf&\
    \ buf, int n = 4) {\n-  size_t temp = 0;\n-  for (int i = n - 1; i >= 0; i--)\n\
    -#if _MSC_VER\n-    temp = temp + static_cast<size_t>(buf.data()[i] * (pow(static_cast<float>(256),\
    \ n - i - 1)));\n-#else\n-    temp = temp + buf.data()[i] * (pow((float)256, n\
    \ - i - 1));\n-#endif\n-\n-  return temp;\n-}\n-\n }  // namespace Internal\n\
    \ }  // namespace Exiv2\n \n@@ -568,7 +531,7 @@ void QuickTimeVideo::readMetadata()\
    \ {\n   aspectRatio();\n }  // QuickTimeVideo::readMetadata\n \n-void QuickTimeVideo::decodeBlock()\
    \ {\n+void QuickTimeVideo::decodeBlock(std::string const& entered_from) {\n  \
    \ const long bufMinSize = 4;\n   DataBuf buf(bufMinSize + 1);\n   uint64_t size\
    \ = 0;\n@@ -580,9 +543,9 @@ void QuickTimeVideo::decodeBlock() {\n     return;\n\
    \   }\n \n-  size = Exiv2::getULong(buf.data(), bigEndian);\n+  size = buf.read_uint32(0,\
    \ bigEndian);\n \n-  io_->read(buf.data(), 4);\n+  io_->readOrThrow(buf.data(),\
    \ 4);\n \n   // we have read 2x 4 bytes\n   size_t hdrsize = 8;\n@@ -591,25 +554,30\
    \ @@ void QuickTimeVideo::decodeBlock() {\n     // The box size is encoded as\
    \ a uint64_t, so we need to read another 8 bytes.\n     DataBuf data(8);\n   \
    \  hdrsize += 8;\n-    io_->read(data.data(), data.size());\n+    io_->readOrThrow(data.data(),\
    \ data.size());\n     size = data.read_uint64(0, bigEndian);\n+  } else if (size\
    \ == 0) {\n+    if (entered_from == \"meta\") {\n+      size = buf.read_uint32(0,\
    \ bigEndian);\n+      io_->readOrThrow(buf.data(), 4, Exiv2::ErrorCode::kerCorruptedMetadata);\n\
    +    }\n   }\n+\n   enforce(size >= hdrsize, Exiv2::ErrorCode::kerCorruptedMetadata);\n\
    \   enforce(size - hdrsize <= io_->size() - io_->tell(), Exiv2::ErrorCode::kerCorruptedMetadata);\n\
    \   enforce(size - hdrsize <= std::numeric_limits<size_t>::max(), Exiv2::ErrorCode::kerCorruptedMetadata);\n\
    \ \n-  // std::cerr<<\"\\nTag=>\"<<buf.data()<<\"     size=>\"<<size-8 << \"\"\
    ;\n+  // std::cerr<<\"Tag=>\"<<buf.data()<<\"     size=>\"<<size-hdrsize << std::endl;\n\
    \   tagDecoder(buf, static_cast<size_t>(size - hdrsize));\n }  // QuickTimeVideo::decodeBlock\n\
    \ \n void QuickTimeVideo::tagDecoder(Exiv2::DataBuf& buf, size_t size) {\n   if\
    \ (ignoreList(buf))\n     discard(size);\n \n-  else if (dataIgnoreList(buf))\n\
    -    decodeBlock();\n-\n-  else if (equalsQTimeTag(buf, \"ftyp\"))\n+  else if\
    \ (dataIgnoreList(buf)) {\n+    decodeBlock(Exiv2::toString(buf.data()));\n+ \
    \ } else if (equalsQTimeTag(buf, \"ftyp\"))\n     fileTypeDecoder(size);\n \n\
    \   else if (equalsQTimeTag(buf, \"trak\"))\n@@ -652,30 +620,30 @@ void QuickTimeVideo::tagDecoder(Exiv2::DataBuf&\
    \ buf, size_t size) {\n     keysTagDecoder(size);\n \n   else if (equalsQTimeTag(buf,\
    \ \"url \")) {\n-    io_->read(buf.data(), size);\n+    io_->readOrThrow(buf.data(),\
    \ size);\n     if (currentStream_ == Video)\n       xmpData_[\"Xmp.video.URL\"\
    ] = Exiv2::toString(buf.data());\n     else if (currentStream_ == Audio)\n   \
    \    xmpData_[\"Xmp.audio.URL\"] = Exiv2::toString(buf.data());\n   }\n \n   else\
    \ if (equalsQTimeTag(buf, \"urn \")) {\n-    io_->read(buf.data(), size);\n+ \
    \   io_->readOrThrow(buf.data(), size);\n     if (currentStream_ == Video)\n \
    \      xmpData_[\"Xmp.video.URN\"] = Exiv2::toString(buf.data());\n     else if\
    \ (currentStream_ == Audio)\n       xmpData_[\"Xmp.audio.URN\"] = Exiv2::toString(buf.data());\n\
    \   }\n \n   else if (equalsQTimeTag(buf, \"dcom\")) {\n-    io_->read(buf.data(),\
    \ size);\n+    io_->readOrThrow(buf.data(), size);\n     xmpData_[\"Xmp.video.Compressor\"\
    ] = Exiv2::toString(buf.data());\n   }\n \n   else if (equalsQTimeTag(buf, \"\
    smhd\")) {\n-    io_->read(buf.data(), 4);\n-    io_->read(buf.data(), 4);\n-\
    \    xmpData_[\"Xmp.audio.Balance\"] = returnBufValue(buf, 2);\n+    io_->readOrThrow(buf.data(),\
    \ 4);\n+    io_->readOrThrow(buf.data(), 4);\n+    xmpData_[\"Xmp.audio.Balance\"\
    ] = buf.read_uint16(0, bigEndian);\n   }\n \n   else {\n@@ -691,12 +659,12 @@\
    \ void QuickTimeVideo::discard(size_t size) {\n void QuickTimeVideo::previewTagDecoder(size_t\
    \ size) {\n   DataBuf buf(4);\n   size_t cur_pos = io_->tell();\n-  io_->read(buf.data(),\
    \ 4);\n-  xmpData_[\"Xmp.video.PreviewDate\"] = getULong(buf.data(), bigEndian);\n\
    -  io_->read(buf.data(), 2);\n+  io_->readOrThrow(buf.data(), 4);\n+  xmpData_[\"\
    Xmp.video.PreviewDate\"] = buf.read_uint32(0, bigEndian);\n+  io_->readOrThrow(buf.data(),\
    \ 2);\n   xmpData_[\"Xmp.video.PreviewVersion\"] = getShort(buf.data(), bigEndian);\n\
    \ \n-  io_->read(buf.data(), 4);\n+  io_->readOrThrow(buf.data(), 4);\n   if (equalsQTimeTag(buf,\
    \ \"PICT\"))\n     xmpData_[\"Xmp.video.PreviewAtomType\"] = \"QuickDraw Picture\"\
    ;\n   else\n@@ -708,12 +676,12 @@ void QuickTimeVideo::previewTagDecoder(size_t\
    \ size) {\n void QuickTimeVideo::keysTagDecoder(size_t size) {\n   DataBuf buf(4);\n\
    \   size_t cur_pos = io_->tell();\n-  io_->read(buf.data(), 4);\n-  xmpData_[\"\
    Xmp.video.PreviewDate\"] = getULong(buf.data(), bigEndian);\n-  io_->read(buf.data(),\
    \ 2);\n+  io_->readOrThrow(buf.data(), 4);\n+  xmpData_[\"Xmp.video.PreviewDate\"\
    ] = buf.read_uint32(0, bigEndian);\n+  io_->readOrThrow(buf.data(), 2);\n   xmpData_[\"\
    Xmp.video.PreviewVersion\"] = getShort(buf.data(), bigEndian);\n \n-  io_->read(buf.data(),\
    \ 4);\n+  io_->readOrThrow(buf.data(), 4);\n   if (equalsQTimeTag(buf, \"PICT\"\
    ))\n     xmpData_[\"Xmp.video.PreviewAtomType\"] = \"QuickDraw Picture\";\n  \
    \ else\n@@ -729,42 +697,42 @@ void QuickTimeVideo::trackApertureTagDecoder(size_t\
    \ size) {\n \n   while (n--) {\n     io_->seek(static_cast<long>(4), BasicIo::cur);\n\
    -    io_->read(buf.data(), 4);\n+    io_->readOrThrow(buf.data(), 4);\n \n   \
    \  if (equalsQTimeTag(buf, \"clef\")) {\n       io_->seek(static_cast<long>(4),\
    \ BasicIo::cur);\n-      io_->read(buf.data(), 2);\n-      io_->read(buf2.data(),\
    \ 2);\n+      io_->readOrThrow(buf.data(), 2);\n+      io_->readOrThrow(buf2.data(),\
    \ 2);\n       xmpData_[\"Xmp.video.CleanApertureWidth\"] =\n-          Exiv2::toString(getUShort(buf.data(),\
    \ bigEndian)) + \".\" + Exiv2::toString(getUShort(buf2.data(), bigEndian));\n\
    -      io_->read(buf.data(), 2);\n-      io_->read(buf2.data(), 2);\n+       \
    \   Exiv2::toString(buf.read_uint16(0, bigEndian)) + \".\" + Exiv2::toString(buf2.read_uint16(0,\
    \ bigEndian));\n+      io_->readOrThrow(buf.data(), 2);\n+      io_->readOrThrow(buf2.data(),\
    \ 2);\n       xmpData_[\"Xmp.video.CleanApertureHeight\"] =\n-          Exiv2::toString(getUShort(buf.data(),\
    \ bigEndian)) + \".\" + Exiv2::toString(getUShort(buf2.data(), bigEndian));\n\
    +          Exiv2::toString(buf.read_uint16(0, bigEndian)) + \".\" + Exiv2::toString(buf2.read_uint16(0,\
    \ bigEndian));\n     }\n \n     else if (equalsQTimeTag(buf, \"prof\")) {\n  \
    \     io_->seek(static_cast<long>(4), BasicIo::cur);\n-      io_->read(buf.data(),\
    \ 2);\n-      io_->read(buf2.data(), 2);\n+      io_->readOrThrow(buf.data(),\
    \ 2);\n+      io_->readOrThrow(buf2.data(), 2);\n       xmpData_[\"Xmp.video.ProductionApertureWidth\"\
    ] =\n-          Exiv2::toString(getUShort(buf.data(), bigEndian)) + \".\" + Exiv2::toString(getUShort(buf2.data(),\
    \ bigEndian));\n-      io_->read(buf.data(), 2);\n-      io_->read(buf2.data(),\
    \ 2);\n+          Exiv2::toString(buf.read_uint16(0, bigEndian)) + \".\" + Exiv2::toString(buf2.read_uint16(0,\
    \ bigEndian));\n+      io_->readOrThrow(buf.data(), 2);\n+      io_->readOrThrow(buf2.data(),\
    \ 2);\n       xmpData_[\"Xmp.video.ProductionApertureHeight\"] =\n-          Exiv2::toString(getUShort(buf.data(),\
    \ bigEndian)) + \".\" + Exiv2::toString(getUShort(buf2.data(), bigEndian));\n\
    +          Exiv2::toString(buf.read_uint16(0, bigEndian)) + \".\" + Exiv2::toString(buf2.read_uint16(0,\
    \ bigEndian));\n     }\n \n     else if (equalsQTimeTag(buf, \"enof\")) {\n  \
    \     io_->seek(static_cast<long>(4), BasicIo::cur);\n-      io_->read(buf.data(),\
    \ 2);\n-      io_->read(buf2.data(), 2);\n+      io_->readOrThrow(buf.data(),\
    \ 2);\n+      io_->readOrThrow(buf2.data(), 2);\n       xmpData_[\"Xmp.video.EncodedPixelsWidth\"\
    ] =\n-          Exiv2::toString(getUShort(buf.data(), bigEndian)) + \".\" + Exiv2::toString(getUShort(buf2.data(),\
    \ bigEndian));\n-      io_->read(buf.data(), 2);\n-      io_->read(buf2.data(),\
    \ 2);\n+          Exiv2::toString(buf.read_uint16(0, bigEndian)) + \".\" + Exiv2::toString(buf2.read_uint16(0,\
    \ bigEndian));\n+      io_->readOrThrow(buf.data(), 2);\n+      io_->readOrThrow(buf2.data(),\
    \ 2);\n       xmpData_[\"Xmp.video.EncodedPixelsHeight\"] =\n-          Exiv2::toString(getUShort(buf.data(),\
    \ bigEndian)) + \".\" + Exiv2::toString(getUShort(buf2.data(), bigEndian));\n\
    +          Exiv2::toString(buf.read_uint16(0, bigEndian)) + \".\" + Exiv2::toString(buf2.read_uint16(0,\
    \ bigEndian));\n     }\n   }\n   io_->seek(static_cast<long>(cur_pos + size),\
    \ BasicIo::beg);\n@@ -775,37 +743,36 @@ void QuickTimeVideo::CameraTagsDecoder(size_t\
    \ size_external) {\n   DataBuf buf(50), buf2(4);\n   const TagDetails* td;\n \n\
    -  io_->read(buf.data(), 4);\n+  io_->readOrThrow(buf.data(), 4);\n   if (equalsQTimeTag(buf,\
    \ \"NIKO\")) {\n     io_->seek(cur_pos, BasicIo::beg);\n \n-    io_->read(buf.data(),\
    \ 24);\n+    io_->readOrThrow(buf.data(), 24);\n     xmpData_[\"Xmp.video.Make\"\
    ] = Exiv2::toString(buf.data());\n-    io_->read(buf.data(), 14);\n+    io_->readOrThrow(buf.data(),\
    \ 14);\n     xmpData_[\"Xmp.video.Model\"] = Exiv2::toString(buf.data());\n- \
    \   io_->read(buf.data(), 4);\n-    xmpData_[\"Xmp.video.ExposureTime\"] = \"\
    1/\" + Exiv2::toString(ceil(getULong(buf.data(), littleEndian) / (double)10));\n\
    -    io_->read(buf.data(), 4);\n-    io_->read(buf2.data(), 4);\n-    xmpData_[\"\
    Xmp.video.FNumber\"] = getULong(buf.data(), littleEndian) / (double)getULong(buf2.data(),\
    \ littleEndian);\n-    io_->read(buf.data(), 4);\n-    io_->read(buf2.data(),\
    \ 4);\n+    io_->readOrThrow(buf.data(), 4);\n+    xmpData_[\"Xmp.video.ExposureTime\"\
    ] = \"1/\" + Exiv2::toString(ceil(buf.read_uint32(0, littleEndian) / (double)10));\n\
    +    io_->readOrThrow(buf.data(), 4);\n+    io_->readOrThrow(buf2.data(), 4);\n\
    +    xmpData_[\"Xmp.video.FNumber\"] = buf.read_uint32(0, littleEndian) / (double)buf2.read_uint32(0,\
    \ littleEndian);\n+    io_->readOrThrow(buf.data(), 4);\n+    io_->readOrThrow(buf2.data(),\
    \ 4);\n     xmpData_[\"Xmp.video.ExposureCompensation\"] =\n-        getULong(buf.data(),\
    \ littleEndian) / (double)getULong(buf2.data(), littleEndian);\n-    io_->read(buf.data(),\
    \ 10);\n-    io_->read(buf.data(), 4);\n-    td = find(whiteBalance, getULong(buf.data(),\
    \ littleEndian));\n+        buf.read_uint32(0, littleEndian) / (double)buf2.read_uint32(0,\
    \ littleEndian);\n+    io_->readOrThrow(buf.data(), 10);\n+    io_->readOrThrow(buf.data(),\
    \ 4);\n+    td = find(whiteBalance, buf.read_uint32(0, littleEndian));\n     if\
    \ (td)\n       xmpData_[\"Xmp.video.WhiteBalance\"] = exvGettext(td->label_);\n\
    -    io_->read(buf.data(), 4);\n-    io_->read(buf2.data(), 4);\n-    xmpData_[\"\
    Xmp.video.FocalLength\"] =\n-        getULong(buf.data(), littleEndian) / (double)getULong(buf2.data(),\
    \ littleEndian);\n+    io_->readOrThrow(buf.data(), 4);\n+    io_->readOrThrow(buf2.data(),\
    \ 4);\n+    xmpData_[\"Xmp.video.FocalLength\"] = buf.read_uint32(0, littleEndian)\
    \ / (double)buf2.read_uint32(0, littleEndian);\n     io_->seek(static_cast<long>(95),\
    \ BasicIo::cur);\n-    io_->read(buf.data(), 48);\n+    io_->readOrThrow(buf.data(),\
    \ 48);\n     xmpData_[\"Xmp.video.Software\"] = Exiv2::toString(buf.data());\n\
    -    io_->read(buf.data(), 4);\n-    xmpData_[\"Xmp.video.ISO\"] = getULong(buf.data(),\
    \ littleEndian);\n+    io_->readOrThrow(buf.data(), 4);\n+    xmpData_[\"Xmp.video.ISO\"\
    ] = buf.read_uint32(0, littleEndian);\n   }\n \n   io_->seek(cur_pos + size_external,\
    \ BasicIo::beg);\n@@ -823,12 +790,12 @@ void QuickTimeVideo::userDataDecoder(size_t\
    \ size_external) {\n \n   while ((size_internal / 4 != 0) && (size_internal >\
    \ 0)) {\n     buf.data()[4] = '\\0';\n-    io_->read(buf.data(), 4);\n-    size\
    \ = Exiv2::getULong(buf.data(), bigEndian);\n+    io_->readOrThrow(buf.data(),\
    \ 4);\n+    size = buf.read_uint32(0, bigEndian);\n     if (size > size_internal)\n\
    \       break;\n     size_internal -= size;\n-    io_->read(buf.data(), 4);\n\
    +    io_->readOrThrow(buf.data(), 4);\n \n     if (buf.data()[0] == 169)\n   \
    \    buf.data()[0] = ' ';\n@@ -850,12 +817,12 @@ void QuickTimeVideo::userDataDecoder(size_t\
    \ size_external) {\n \n     else if (equalsQTimeTag(buf, \"CNCV\") || equalsQTimeTag(buf,\
    \ \"CNFV\") || equalsQTimeTag(buf, \"CNMN\") ||\n              equalsQTimeTag(buf,\
    \ \"NCHD\") || equalsQTimeTag(buf, \"FFMV\")) {\n-      io_->read(buf.data(),\
    \ size - 8);\n+      io_->readOrThrow(buf.data(), size - 8);\n       xmpData_[exvGettext(tv->label_)]\
    \ = Exiv2::toString(buf.data());\n     }\n \n     else if (equalsQTimeTag(buf,\
    \ \"CMbo\") || equalsQTimeTag(buf, \"Cmbo\")) {\n-      io_->read(buf.data(),\
    \ 2);\n+      io_->readOrThrow(buf.data(), 2);\n       buf.data()[2] = '\\0';\n\
    \       tv_internal = find(cameraByteOrderTags, Exiv2::toString(buf.data()));\n\
    \ \n@@ -866,8 +833,8 @@ void QuickTimeVideo::userDataDecoder(size_t size_external)\
    \ {\n     }\n \n     else if (tv) {\n-      io_->read(buf.data(), 4);\n-     \
    \ io_->read(buf.data(), size - 12);\n+      io_->readOrThrow(buf.data(), 4);\n\
    +      io_->readOrThrow(buf.data(), size - 12);\n       xmpData_[exvGettext(tv->label_)]\
    \ = Exiv2::toString(buf.data());\n     }\n \n@@ -886,106 +853,106 @@ void QuickTimeVideo::NikonTagsDecoder(size_t\
    \ size_external) {\n   const TagDetails *td, *td2;\n \n   for (int i = 0; i <\
    \ 100; i++) {\n-    io_->read(buf.data(), 4);\n-    TagID = Exiv2::getULong(buf.data(),\
    \ bigEndian);\n+    io_->readOrThrow(buf.data(), 4);\n+    TagID = buf.read_uint32(0,\
    \ bigEndian);\n     td = find(NikonNCTGTags, TagID);\n \n-    io_->read(buf.data(),\
    \ 2);\n-    dataType = Exiv2::getUShort(buf.data(), bigEndian);\n+    io_->readOrThrow(buf.data(),\
    \ 2);\n+    dataType = buf.read_uint16(0, bigEndian);\n \n     std::memset(buf.data(),\
    \ 0x0, buf.size());\n-    io_->read(buf.data(), 2);\n+    io_->readOrThrow(buf.data(),\
    \ 2);\n \n     if (TagID == 0x2000023) {\n       size_t local_pos = io_->tell();\n\
    -      dataLength = Exiv2::getUShort(buf.data(), bigEndian);\n+      dataLength\
    \ = buf.read_uint16(0, bigEndian);\n       std::memset(buf.data(), 0x0, buf.size());\n\
    \ \n-      io_->read(buf.data(), 4);\n+      io_->readOrThrow(buf.data(), 4);\n\
    \       xmpData_[\"Xmp.video.PictureControlVersion\"] = Exiv2::toString(buf.data());\n\
    -      io_->read(buf.data(), 20);\n+      io_->readOrThrow(buf.data(), 20);\n\
    \       xmpData_[\"Xmp.video.PictureControlName\"] = Exiv2::toString(buf.data());\n\
    -      io_->read(buf.data(), 20);\n+      io_->readOrThrow(buf.data(), 20);\n\
    \       xmpData_[\"Xmp.video.PictureControlBase\"] = Exiv2::toString(buf.data());\n\
    -      io_->read(buf.data(), 4);\n+      io_->readOrThrow(buf.data(), 4);\n  \
    \     std::memset(buf.data(), 0x0, buf.size());\n \n-      io_->read(buf.data(),\
    \ 1);\n+      io_->readOrThrow(buf.data(), 1);\n       td2 = find(PictureControlAdjust,\
    \ (int)buf.data()[0] & 7);\n       if (td2)\n         xmpData_[\"Xmp.video.PictureControlAdjust\"\
    ] = exvGettext(td2->label_);\n       else\n         xmpData_[\"Xmp.video.PictureControlAdjust\"\
    ] = (int)buf.data()[0] & 7;\n \n-      io_->read(buf.data(), 1);\n+      io_->readOrThrow(buf.data(),\
    \ 1);\n       td2 = find(NormalSoftHard, (int)buf.data()[0] & 7);\n       if (td2)\n\
    \         xmpData_[\"Xmp.video.PictureControlQuickAdjust\"] = exvGettext(td2->label_);\n\
    \ \n-      io_->read(buf.data(), 1);\n+      io_->readOrThrow(buf.data(), 1);\n\
    \       td2 = find(NormalSoftHard, (int)buf.data()[0] & 7);\n       if (td2)\n\
    \         xmpData_[\"Xmp.video.Sharpness\"] = exvGettext(td2->label_);\n     \
    \  else\n         xmpData_[\"Xmp.video.Sharpness\"] = (int)buf.data()[0] & 7;\n\
    \ \n-      io_->read(buf.data(), 1);\n+      io_->readOrThrow(buf.data(), 1);\n\
    \       td2 = find(NormalSoftHard, (int)buf.data()[0] & 7);\n       if (td2)\n\
    \         xmpData_[\"Xmp.video.Contrast\"] = exvGettext(td2->label_);\n      \
    \ else\n         xmpData_[\"Xmp.video.Contrast\"] = (int)buf.data()[0] & 7;\n\
    \ \n-      io_->read(buf.data(), 1);\n+      io_->readOrThrow(buf.data(), 1);\n\
    \       td2 = find(NormalSoftHard, (int)buf.data()[0] & 7);\n       if (td2)\n\
    \         xmpData_[\"Xmp.video.Brightness\"] = exvGettext(td2->label_);\n    \
    \   else\n         xmpData_[\"Xmp.video.Brightness\"] = (int)buf.data()[0] & 7;\n\
    \ \n-      io_->read(buf.data(), 1);\n+      io_->readOrThrow(buf.data(), 1);\n\
    \       td2 = find(Saturation, (int)buf.data()[0] & 7);\n       if (td2)\n   \
    \      xmpData_[\"Xmp.video.Saturation\"] = exvGettext(td2->label_);\n       else\n\
    \         xmpData_[\"Xmp.video.Saturation\"] = (int)buf.data()[0] & 7;\n \n- \
    \     io_->read(buf.data(), 1);\n+      io_->readOrThrow(buf.data(), 1);\n   \
    \    xmpData_[\"Xmp.video.HueAdjustment\"] = (int)buf.data()[0] & 7;\n \n-   \
    \   io_->read(buf.data(), 1);\n+      io_->readOrThrow(buf.data(), 1);\n     \
    \  td2 = find(FilterEffect, (int)buf.data()[0]);\n       if (td2)\n         xmpData_[\"\
    Xmp.video.FilterEffect\"] = exvGettext(td2->label_);\n       else\n         xmpData_[\"\
    Xmp.video.FilterEffect\"] = (int)buf.data()[0];\n \n-      io_->read(buf.data(),\
    \ 1);\n+      io_->readOrThrow(buf.data(), 1);\n       td2 = find(ToningEffect,\
    \ (int)buf.data()[0]);\n       if (td2)\n         xmpData_[\"Xmp.video.ToningEffect\"\
    ] = exvGettext(td2->label_);\n       else\n         xmpData_[\"Xmp.video.ToningEffect\"\
    ] = (int)buf.data()[0];\n \n-      io_->read(buf.data(), 1);\n+      io_->readOrThrow(buf.data(),\
    \ 1);\n       xmpData_[\"Xmp.video.ToningSaturation\"] = (int)buf.data()[0];\n\
    \ \n       io_->seek(local_pos + dataLength, BasicIo::beg);\n     }\n \n     else\
    \ if (TagID == 0x2000024) {\n       size_t local_pos = io_->tell();\n-      dataLength\
    \ = Exiv2::getUShort(buf.data(), bigEndian);\n+      dataLength = buf.read_uint16(0,\
    \ bigEndian);\n       std::memset(buf.data(), 0x0, buf.size());\n \n-      io_->read(buf.data(),\
    \ 2);\n+      io_->readOrThrow(buf.data(), 2);\n       xmpData_[\"Xmp.video.TimeZone\"\
    ] = Exiv2::getShort(buf.data(), bigEndian);\n-      io_->read(buf.data(), 1);\n\
    +      io_->readOrThrow(buf.data(), 1);\n       td2 = find(YesNo, (int)buf.data()[0]);\n\
    \       if (td2)\n         xmpData_[\"Xmp.video.DayLightSavings\"] = exvGettext(td2->label_);\n\
    \ \n-      io_->read(buf.data(), 1);\n+      io_->readOrThrow(buf.data(), 1);\n\
    \       td2 = find(DateDisplayFormat, (int)buf.data()[0]);\n       if (td2)\n\
    \         xmpData_[\"Xmp.video.DateDisplayFormat\"] = exvGettext(td2->label_);\n\
    @@ -994,7 +961,7 @@ void QuickTimeVideo::NikonTagsDecoder(size_t size_external)\
    \ {\n     }\n \n     else if (dataType == 2 || dataType == 7) {\n-      dataLength\
    \ = Exiv2::getUShort(buf.data(), bigEndian);\n+      dataLength = buf.read_uint16(0,\
    \ bigEndian);\n       std::memset(buf.data(), 0x0, buf.size());\n \n       //\
    \ Sanity check with an \"unreasonably\" large number\n@@ -1005,18 +972,18 @@ void\
    \ QuickTimeVideo::NikonTagsDecoder(size_t size_external) {\n #endif\n        \
    \ io_->seek(io_->tell() + dataLength, BasicIo::beg);\n       } else {\n-     \
    \   io_->read(buf.data(), dataLength);\n+        io_->readOrThrow(buf.data(),\
    \ dataLength);\n       }\n \n       if (td) {\n         xmpData_[exvGettext(td->label_)]\
    \ = Exiv2::toString(buf.data());\n       }\n     } else if (dataType == 4) {\n\
    -      dataLength = Exiv2::getUShort(buf.data(), bigEndian) * 4;\n+      dataLength\
    \ = buf.read_uint16(0, bigEndian) * 4;\n       std::memset(buf.data(), 0x0, buf.size());\n\
    -      io_->read(buf.data(), 4);\n+      io_->readOrThrow(buf.data(), 4);\n  \
    \     if (td)\n-        xmpData_[exvGettext(td->label_)] = Exiv2::toString(Exiv2::getULong(buf.data(),\
    \ bigEndian));\n+        xmpData_[exvGettext(td->label_)] = Exiv2::toString(buf.read_uint32(0,\
    \ bigEndian));\n \n       // Sanity check with an \"unreasonably\" large number\n\
    \       if (dataLength > 200 || dataLength < 4) {\n@@ -1026,13 +993,13 @@ void\
    \ QuickTimeVideo::NikonTagsDecoder(size_t size_external) {\n #endif\n        \
    \ io_->seek(io_->tell() + dataLength - 4, BasicIo::beg);\n       } else\n-   \
    \     io_->read(buf.data(), dataLength - 4);\n+        io_->readOrThrow(buf.data(),\
    \ dataLength - 4);\n     } else if (dataType == 3) {\n-      dataLength = Exiv2::getUShort(buf.data(),\
    \ bigEndian) * 2;\n+      dataLength = buf.read_uint16(0, bigEndian) * 2;\n  \
    \     std::memset(buf.data(), 0x0, buf.size());\n-      io_->read(buf.data(),\
    \ 2);\n+      io_->readOrThrow(buf.data(), 2);\n       if (td)\n-        xmpData_[exvGettext(td->label_)]\
    \ = Exiv2::toString(Exiv2::getUShort(buf.data(), bigEndian));\n+        xmpData_[exvGettext(td->label_)]\
    \ = Exiv2::toString(buf.read_uint16(0, bigEndian));\n \n       // Sanity check\
    \ with an \"unreasonably\" large number\n       if (dataLength > 200 || dataLength\
    \ < 2) {\n@@ -1042,15 +1009,15 @@ void QuickTimeVideo::NikonTagsDecoder(size_t\
    \ size_external) {\n #endif\n         io_->seek(io_->tell() + dataLength - 2,\
    \ BasicIo::beg);\n       } else\n-        io_->read(buf.data(), dataLength - 2);\n\
    +        io_->readOrThrow(buf.data(), dataLength - 2);\n     } else if (dataType\
    \ == 5) {\n-      dataLength = Exiv2::getUShort(buf.data(), bigEndian) * 8;\n\
    +      dataLength = buf.read_uint16(0, bigEndian) * 8;\n       std::memset(buf.data(),\
    \ 0x0, buf.size());\n-      io_->read(buf.data(), 4);\n-      io_->read(buf2.data(),\
    \ 4);\n+      io_->readOrThrow(buf.data(), 4);\n+      io_->readOrThrow(buf2.data(),\
    \ 4);\n       if (td)\n-        xmpData_[exvGettext(td->label_)] = Exiv2::toString((double)Exiv2::getULong(buf.data(),\
    \ bigEndian) /\n-                                                           (double)Exiv2::getULong(buf2.data(),\
    \ bigEndian));\n+        xmpData_[exvGettext(td->label_)] =\n+            Exiv2::toString((double)buf.read_uint32(0,\
    \ bigEndian) / (double)buf2.read_uint32(0, bigEndian));\n \n       // Sanity check\
    \ with an \"unreasonably\" large number\n       if (dataLength > 200 || dataLength\
    \ < 8) {\n@@ -1060,15 +1027,15 @@ void QuickTimeVideo::NikonTagsDecoder(size_t\
    \ size_external) {\n #endif\n         io_->seek(io_->tell() + dataLength - 8,\
    \ BasicIo::beg);\n       } else\n-        io_->read(buf.data(), dataLength - 8);\n\
    +        io_->readOrThrow(buf.data(), dataLength - 8);\n     } else if (dataType\
    \ == 8) {\n-      dataLength = Exiv2::getUShort(buf.data(), bigEndian) * 2;\n\
    +      dataLength = buf.read_uint16(0, bigEndian) * 2;\n       std::memset(buf.data(),\
    \ 0x0, buf.size());\n-      io_->read(buf.data(), 2);\n-      io_->read(buf2.data(),\
    \ 2);\n+      io_->readOrThrow(buf.data(), 2);\n+      io_->readOrThrow(buf2.data(),\
    \ 2);\n       if (td)\n-        xmpData_[exvGettext(td->label_)] = Exiv2::toString(Exiv2::getUShort(buf.data(),\
    \ bigEndian)) + \" \" +\n-                                           Exiv2::toString(Exiv2::getUShort(buf2.data(),\
    \ bigEndian));\n+        xmpData_[exvGettext(td->label_)] =\n+            Exiv2::toString(buf.read_uint16(0,\
    \ bigEndian)) + \" \" + Exiv2::toString(buf2.read_uint16(0, bigEndian));\n \n\
    \       // Sanity check with an \"unreasonably\" large number\n       if (dataLength\
    \ > 200 || dataLength < 4) {\n@@ -1078,7 +1045,7 @@ void QuickTimeVideo::NikonTagsDecoder(size_t\
    \ size_external) {\n #endif\n         io_->seek(io_->tell() + dataLength - 4,\
    \ BasicIo::beg);\n       } else\n-        io_->read(buf.data(), dataLength - 4);\n\
    +        io_->readOrThrow(buf.data(), dataLength - 4);\n     }\n   }\n \n@@ -1090,11\
    \ +1057,11 @@ void QuickTimeVideo::setMediaStream() {\n   DataBuf buf(4 + 1);\n\
    \ \n   while (!io_->eof()) {\n-    io_->read(buf.data(), 4);\n+    io_->readOrThrow(buf.data(),\
    \ 4);\n     if (equalsQTimeTag(buf, \"hdlr\")) {\n-      io_->read(buf.data(),\
    \ 4);\n-      io_->read(buf.data(), 4);\n-      io_->read(buf.data(), 4);\n+ \
    \     io_->readOrThrow(buf.data(), 4);\n+      io_->readOrThrow(buf.data(), 4);\n\
    +      io_->readOrThrow(buf.data(), 4);\n \n       if (equalsQTimeTag(buf, \"\
    vide\"))\n         currentStream_ = Video;\n@@ -1113,18 +1080,18 @@ void QuickTimeVideo::setMediaStream()\
    \ {\n \n void QuickTimeVideo::timeToSampleDecoder() {\n   DataBuf buf(4 + 1);\n\
    -  io_->read(buf.data(), 4);\n-  io_->read(buf.data(), 4);\n+  io_->readOrThrow(buf.data(),\
    \ 4);\n+  io_->readOrThrow(buf.data(), 4);\n   size_t noOfEntries, totalframes\
    \ = 0, timeOfFrames = 0;\n-  noOfEntries = returnUnsignedBufValue(buf);\n+  noOfEntries\
    \ = buf.read_uint32(0, bigEndian);\n   size_t temp;\n \n   for (unsigned long\
    \ i = 1; i <= noOfEntries; i++) {\n-    io_->read(buf.data(), 4);\n-    temp =\
    \ returnBufValue(buf);\n+    io_->readOrThrow(buf.data(), 4);\n+    temp = buf.read_uint32(0,\
    \ bigEndian);\n     totalframes += temp;\n-    io_->read(buf.data(), 4);\n-  \
    \  timeOfFrames += temp * returnBufValue(buf);\n+    io_->readOrThrow(buf.data(),\
    \ 4);\n+    timeOfFrames += temp * buf.read_uint32(0, bigEndian);\n   }\n   if\
    \ (currentStream_ == Video)\n     xmpData_[\"Xmp.video.FrameRate\"] = (double)totalframes\
    \ * (double)timeScale_ / (double)timeOfFrames;\n@@ -1133,10 +1100,10 @@ void QuickTimeVideo::timeToSampleDecoder()\
    \ {\n void QuickTimeVideo::sampleDesc(size_t size) {\n   DataBuf buf(100);\n \
    \  size_t cur_pos = io_->tell();\n-  io_->read(buf.data(), 4);\n-  io_->read(buf.data(),\
    \ 4);\n+  io_->readOrThrow(buf.data(), 4);\n+  io_->readOrThrow(buf.data(), 4);\n\
    \   size_t noOfEntries;\n-  noOfEntries = returnUnsignedBufValue(buf);\n+  noOfEntries\
    \ = buf.read_uint32(0, bigEndian);\n \n   for (unsigned long i = 1; i <= noOfEntries;\
    \ i++) {\n     if (currentStream_ == Video)\n@@ -1151,13 +1118,13 @@ void QuickTimeVideo::audioDescDecoder()\
    \ {\n   DataBuf buf(40);\n   std::memset(buf.data(), 0x0, buf.size());\n   buf.data()[4]\
    \ = '\\0';\n-  io_->read(buf.data(), 4);\n+  io_->readOrThrow(buf.data(), 4);\n\
    \   size_t size = 82;\n \n   const TagVocabulary* td;\n \n   for (int i = 0; size\
    \ / 4 != 0; size -= 4, i++) {\n-    io_->read(buf.data(), 4);\n+    io_->readOrThrow(buf.data(),\
    \ 4);\n     switch (i) {\n       case AudioFormat:\n         td = find(qTimeFileType,\
    \ Exiv2::toString(buf.data()));\n@@ -1172,30 +1139,31 @@ void QuickTimeVideo::audioDescDecoder()\
    \ {\n           xmpData_[\"Xmp.audio.VendorID\"] = exvGettext(td->label_);\n \
    \        break;\n       case AudioChannels:\n-        xmpData_[\"Xmp.audio.ChannelType\"\
    ] = returnBufValue(buf, 2);\n+        xmpData_[\"Xmp.audio.ChannelType\"] = buf.read_uint16(0,\
    \ bigEndian);\n         xmpData_[\"Xmp.audio.BitsPerSample\"] = (buf.data()[2]\
    \ * 256 + buf.data()[3]);\n         break;\n       case AudioSampleRate:\n-  \
    \      xmpData_[\"Xmp.audio.SampleRate\"] = returnBufValue(buf, 2) + ((buf.data()[2]\
    \ * 256 + buf.data()[3]) * 0.01);\n+        xmpData_[\"Xmp.audio.SampleRate\"\
    ] =\n+            buf.read_uint16(0, bigEndian) + ((buf.data()[2] * 256 + buf.data()[3])\
    \ * 0.01);\n         break;\n       default:\n         break;\n     }\n   }\n\
    -  io_->read(buf.data(), static_cast<long>(size % 4));  // cause size is so small,\
    \ this cast should be right.\n+  io_->readOrThrow(buf.data(), static_cast<long>(size\
    \ % 4));  // cause size is so small, this cast should be right.\n }  // QuickTimeVideo::audioDescDecoder\n\
    \ \n void QuickTimeVideo::imageDescDecoder() {\n   DataBuf buf(40);\n   std::memset(buf.data(),\
    \ 0x0, buf.size());\n   buf.data()[4] = '\\0';\n-  io_->read(buf.data(), 4);\n\
    +  io_->readOrThrow(buf.data(), 4);\n   size_t size = 82;\n \n   const TagVocabulary*\
    \ td;\n \n   for (int i = 0; size / 4 != 0; size -= 4, i++) {\n-    io_->read(buf.data(),\
    \ 4);\n+    io_->readOrThrow(buf.data(), 4);\n \n     switch (i) {\n       case\
    \ codec:\n@@ -1211,37 +1179,39 @@ void QuickTimeVideo::imageDescDecoder() {\n\
    \           xmpData_[\"Xmp.video.VendorID\"] = exvGettext(td->label_);\n     \
    \    break;\n       case SourceImageWidth_Height:\n-        xmpData_[\"Xmp.video.SourceImageWidth\"\
    ] = returnBufValue(buf, 2);\n+        xmpData_[\"Xmp.video.SourceImageWidth\"\
    ] = buf.read_uint16(0, bigEndian);\n         xmpData_[\"Xmp.video.SourceImageHeight\"\
    ] = (buf.data()[2] * 256 + buf.data()[3]);\n         break;\n       case XResolution:\n\
    -        xmpData_[\"Xmp.video.XResolution\"] = returnBufValue(buf, 2) + ((buf.data()[2]\
    \ * 256 + buf.data()[3]) * 0.01);\n+        xmpData_[\"Xmp.video.XResolution\"\
    ] =\n+            buf.read_uint16(0, bigEndian) + ((buf.data()[2] * 256 + buf.data()[3])\
    \ * 0.01);\n         break;\n       case YResolution:\n-        xmpData_[\"Xmp.video.YResolution\"\
    ] = returnBufValue(buf, 2) + ((buf.data()[2] * 256 + buf.data()[3]) * 0.01);\n\
    -        io_->read(buf.data(), 3);\n+        xmpData_[\"Xmp.video.YResolution\"\
    ] =\n+            buf.read_uint16(0, bigEndian) + ((buf.data()[2] * 256 + buf.data()[3])\
    \ * 0.01);\n+        io_->readOrThrow(buf.data(), 3);\n         size -= 3;\n \
    \        break;\n       case CompressorName:\n-        io_->read(buf.data(), 32);\n\
    +        io_->readOrThrow(buf.data(), 32);\n         size -= 32;\n         xmpData_[\"\
    Xmp.video.Compressor\"] = Exiv2::toString(buf.data());\n         break;\n    \
    \   default:\n         break;\n     }\n   }\n-  io_->read(buf.data(), static_cast<long>(size\
    \ % 4));\n-  xmpData_[\"Xmp.video.BitDepth\"] = returnBufValue(buf, 1);\n+  io_->readOrThrow(buf.data(),\
    \ static_cast<long>(size % 4));\n+  xmpData_[\"Xmp.video.BitDepth\"] = static_cast<int>(buf.read_uint8(0));\n\
    \ }  // QuickTimeVideo::imageDescDecoder\n \n void QuickTimeVideo::multipleEntriesDecoder()\
    \ {\n   DataBuf buf(4 + 1);\n-  io_->read(buf.data(), 4);\n-  io_->read(buf.data(),\
    \ 4);\n+  io_->readOrThrow(buf.data(), 4);\n+  io_->readOrThrow(buf.data(), 4);\n\
    \   size_t noOfEntries;\n \n-  noOfEntries = returnUnsignedBufValue(buf);\n+ \
    \ noOfEntries = buf.read_uint32(0, bigEndian);\n \n   for (unsigned long i = 1;\
    \ i <= noOfEntries; i++)\n     decodeBlock();\n@@ -1256,22 +1226,22 @@ void QuickTimeVideo::videoHeaderDecoder(size_t\
    \ size) {\n   const TagDetails* td;\n \n   for (int i = 0; size / 2 != 0; size\
    \ -= 2, i++) {\n-    io_->read(buf.data(), 2);\n+    io_->readOrThrow(buf.data(),\
    \ 2);\n \n     switch (i) {\n       case GraphicsMode:\n-        td = find(graphicsModetags,\
    \ returnBufValue(buf, 2));\n+        td = find(graphicsModetags, buf.read_uint16(0,\
    \ bigEndian));\n         if (td)\n           xmpData_[\"Xmp.video.GraphicsMode\"\
    ] = exvGettext(td->label_);\n         break;\n       case OpColor:\n-        xmpData_[\"\
    Xmp.video.OpColor\"] = returnBufValue(buf, 2);\n+        xmpData_[\"Xmp.video.OpColor\"\
    ] = buf.read_uint16(0, bigEndian);\n         break;\n       default:\n       \
    \  break;\n     }\n   }\n-  io_->read(buf.data(), size % 2);\n+  io_->readOrThrow(buf.data(),\
    \ size % 2);\n }  // QuickTimeVideo::videoHeaderDecoder\n \n void QuickTimeVideo::handlerDecoder(size_t\
    \ size) {\n@@ -1283,7 +1253,7 @@ void QuickTimeVideo::handlerDecoder(size_t size)\
    \ {\n   const TagVocabulary* tv;\n \n   for (int i = 0; i < 5; i++) {\n-    io_->read(buf.data(),\
    \ 4);\n+    io_->readOrThrow(buf.data(), 4);\n \n     switch (i) {\n       case\
    \ HandlerClass:\n@@ -1326,7 +1296,7 @@ void QuickTimeVideo::fileTypeDecoder(size_t\
    \ size) {\n   const TagVocabulary* td;\n \n   for (int i = 0; size / 4 != 0; size\
    \ -= 4, i++) {\n-    io_->read(buf.data(), 4);\n+    io_->readOrThrow(buf.data(),\
    \ 4);\n     td = find(qTimeFileType, Exiv2::toString(buf.data()));\n \n     switch\
    \ (i) {\n@@ -1335,7 +1305,7 @@ void QuickTimeVideo::fileTypeDecoder(size_t size)\
    \ {\n           xmpData_[\"Xmp.video.MajorBrand\"] = exvGettext(td->label_);\n\
    \         break;\n       case 1:\n-        xmpData_[\"Xmp.video.MinorVersion\"\
    ] = returnBufValue(buf);\n+        xmpData_[\"Xmp.video.MinorVersion\"] = buf.read_uint32(0,\
    \ bigEndian);\n         break;\n       default:\n         if (td)\n@@ -1346,7\
    \ +1316,7 @@ void QuickTimeVideo::fileTypeDecoder(size_t size) {\n     }\n   }\n\
    \   xmpData_.add(Exiv2::XmpKey(\"Xmp.video.CompatibleBrands\"), v.get());\n- \
    \ io_->read(buf.data(), size % 4);\n+  io_->readOrThrow(buf.data(), size % 4);\n\
    \ }  // QuickTimeVideo::fileTypeDecoder\n \n void QuickTimeVideo::mediaHeaderDecoder(size_t\
    \ size) {\n@@ -1356,56 +1326,56 @@ void QuickTimeVideo::mediaHeaderDecoder(size_t\
    \ size) {\n   int64_t time_scale = 1;\n \n   for (int i = 0; size / 4 != 0; size\
    \ -= 4, i++) {\n-    io_->read(buf.data(), 4);\n+    io_->readOrThrow(buf.data(),\
    \ 4);\n \n     switch (i) {\n       case MediaHeaderVersion:\n         if (currentStream_\
    \ == Video)\n-          xmpData_[\"Xmp.video.MediaHeaderVersion\"] = returnBufValue(buf,\
    \ 1);\n+          xmpData_[\"Xmp.video.MediaHeaderVersion\"] = static_cast<int>(buf.read_uint8(0));\n\
    \         else if (currentStream_ == Audio)\n-          xmpData_[\"Xmp.audio.MediaHeaderVersion\"\
    ] = returnBufValue(buf, 1);\n+          xmpData_[\"Xmp.audio.MediaHeaderVersion\"\
    ] = static_cast<int>(buf.read_uint8(0));\n         break;\n       case MediaCreateDate:\n\
    \         // A 32-bit integer that specifies (in seconds since midnight, January\
    \ 1, 1904) when the movie atom was created.\n         if (currentStream_ == Video)\n\
    -          xmpData_[\"Xmp.video.MediaCreateDate\"] = returnUnsignedBufValue(buf);\n\
    +          xmpData_[\"Xmp.video.MediaCreateDate\"] = buf.read_uint32(0, bigEndian);\n\
    \         else if (currentStream_ == Audio)\n-          xmpData_[\"Xmp.audio.MediaCreateDate\"\
    ] = returnUnsignedBufValue(buf);\n+          xmpData_[\"Xmp.audio.MediaCreateDate\"\
    ] = buf.read_uint32(0, bigEndian);\n         break;\n       case MediaModifyDate:\n\
    \         // A 32-bit integer that specifies (in seconds since midnight, January\
    \ 1, 1904) when the movie atom was created.\n         if (currentStream_ == Video)\n\
    -          xmpData_[\"Xmp.video.MediaModifyDate\"] = returnUnsignedBufValue(buf);\n\
    +          xmpData_[\"Xmp.video.MediaModifyDate\"] = buf.read_uint32(0, bigEndian);\n\
    \         else if (currentStream_ == Audio)\n-          xmpData_[\"Xmp.audio.MediaModifyDate\"\
    ] = returnUnsignedBufValue(buf);\n+          xmpData_[\"Xmp.audio.MediaModifyDate\"\
    ] = buf.read_uint32(0, bigEndian);\n         break;\n       case MediaTimeScale:\n\
    \         if (currentStream_ == Video)\n-          xmpData_[\"Xmp.video.MediaTimeScale\"\
    ] = returnBufValue(buf);\n+          xmpData_[\"Xmp.video.MediaTimeScale\"] =\
    \ buf.read_uint32(0, bigEndian);\n         else if (currentStream_ == Audio)\n\
    -          xmpData_[\"Xmp.audio.MediaTimeScale\"] = returnBufValue(buf);\n-  \
    \      time_scale = returnBufValue(buf);\n+          xmpData_[\"Xmp.audio.MediaTimeScale\"\
    ] = buf.read_uint32(0, bigEndian);\n+        time_scale = buf.read_uint32(0, bigEndian);\n\
    \         if (time_scale <= 0)\n           time_scale = 1;\n         break;\n\
    \       case MediaDuration:\n         if (currentStream_ == Video)\n-        \
    \  xmpData_[\"Xmp.video.MediaDuration\"] = time_scale ? returnBufValue(buf) /\
    \ time_scale : 0;\n+          xmpData_[\"Xmp.video.MediaDuration\"] = time_scale\
    \ ? buf.read_uint32(0, bigEndian) / time_scale : 0;\n         else if (currentStream_\
    \ == Audio)\n-          xmpData_[\"Xmp.audio.MediaDuration\"] = time_scale ? returnBufValue(buf)\
    \ / time_scale : 0;\n+          xmpData_[\"Xmp.audio.MediaDuration\"] = time_scale\
    \ ? buf.read_uint32(0, bigEndian) / time_scale : 0;\n         break;\n       case\
    \ MediaLanguageCode:\n         if (currentStream_ == Video)\n-          xmpData_[\"\
    Xmp.video.MediaLangCode\"] = returnUnsignedBufValue(buf, 2);\n+          xmpData_[\"\
    Xmp.video.MediaLangCode\"] = buf.read_uint16(0, bigEndian);\n         else if\
    \ (currentStream_ == Audio)\n-          xmpData_[\"Xmp.audio.MediaLangCode\"]\
    \ = returnUnsignedBufValue(buf, 2);\n+          xmpData_[\"Xmp.audio.MediaLangCode\"\
    ] = buf.read_uint16(0, bigEndian);\n         break;\n \n       default:\n    \
    \     break;\n     }\n   }\n-  io_->read(buf.data(), size % 4);\n+  io_->readOrThrow(buf.data(),\
    \ size % 4);\n }  // QuickTimeVideo::mediaHeaderDecoder\n \n void QuickTimeVideo::trackHeaderDecoder(size_t\
    \ size) {\n@@ -1415,63 +1385,63 @@ void QuickTimeVideo::trackHeaderDecoder(size_t\
    \ size) {\n   int64_t temp = 0;\n \n   for (int i = 0; size / 4 != 0; size -=\
    \ 4, i++) {\n-    io_->read(buf.data(), 4);\n+    io_->readOrThrow(buf.data(),\
    \ 4);\n \n     switch (i) {\n       case TrackHeaderVersion:\n         if (currentStream_\
    \ == Video)\n-          xmpData_[\"Xmp.video.TrackHeaderVersion\"] = returnBufValue(buf,\
    \ 1);\n+          xmpData_[\"Xmp.video.TrackHeaderVersion\"] = static_cast<int>(buf.read_uint8(0));\n\
    \         else if (currentStream_ == Audio)\n-          xmpData_[\"Xmp.audio.TrackHeaderVersion\"\
    ] = returnBufValue(buf, 1);\n+          xmpData_[\"Xmp.audio.TrackHeaderVersion\"\
    ] = static_cast<int>(buf.read_uint8(0));\n         break;\n       case TrackCreateDate:\n\
    \         // A 32-bit integer that specifies (in seconds since midnight, January\
    \ 1, 1904) when the movie atom was created.\n         if (currentStream_ == Video)\n\
    -          xmpData_[\"Xmp.video.TrackCreateDate\"] = returnUnsignedBufValue(buf);\n\
    +          xmpData_[\"Xmp.video.TrackCreateDate\"] = buf.read_uint32(0, bigEndian);\n\
    \         else if (currentStream_ == Audio)\n-          xmpData_[\"Xmp.audio.TrackCreateDate\"\
    ] = returnUnsignedBufValue(buf);\n+          xmpData_[\"Xmp.audio.TrackCreateDate\"\
    ] = buf.read_uint32(0, bigEndian);\n         break;\n       case TrackModifyDate:\n\
    \         // A 32-bit integer that specifies (in seconds since midnight, January\
    \ 1, 1904) when the movie atom was created.\n         if (currentStream_ == Video)\n\
    -          xmpData_[\"Xmp.video.TrackModifyDate\"] = returnUnsignedBufValue(buf);\n\
    +          xmpData_[\"Xmp.video.TrackModifyDate\"] = buf.read_uint32(0, bigEndian);\n\
    \         else if (currentStream_ == Audio)\n-          xmpData_[\"Xmp.audio.TrackModifyDate\"\
    ] = returnUnsignedBufValue(buf);\n+          xmpData_[\"Xmp.audio.TrackModifyDate\"\
    ] = buf.read_uint32(0, bigEndian);\n         break;\n       case TrackID:\n  \
    \       if (currentStream_ == Video)\n-          xmpData_[\"Xmp.video.TrackID\"\
    ] = returnBufValue(buf);\n+          xmpData_[\"Xmp.video.TrackID\"] = buf.read_uint32(0,\
    \ bigEndian);\n         else if (currentStream_ == Audio)\n-          xmpData_[\"\
    Xmp.audio.TrackID\"] = returnBufValue(buf);\n+          xmpData_[\"Xmp.audio.TrackID\"\
    ] = buf.read_uint32(0, bigEndian);\n         break;\n       case TrackDuration:\n\
    \         if (currentStream_ == Video)\n-          xmpData_[\"Xmp.video.TrackDuration\"\
    ] = timeScale_ ? returnBufValue(buf) / timeScale_ : 0;\n+          xmpData_[\"\
    Xmp.video.TrackDuration\"] = timeScale_ ? buf.read_uint32(0, bigEndian) / timeScale_\
    \ : 0;\n         else if (currentStream_ == Audio)\n-          xmpData_[\"Xmp.audio.TrackDuration\"\
    ] = timeScale_ ? returnBufValue(buf) / timeScale_ : 0;\n+          xmpData_[\"\
    Xmp.audio.TrackDuration\"] = timeScale_ ? buf.read_uint32(0, bigEndian) / timeScale_\
    \ : 0;\n         break;\n       case TrackLayer:\n         if (currentStream_\
    \ == Video)\n-          xmpData_[\"Xmp.video.TrackLayer\"] = returnBufValue(buf,\
    \ 2);\n+          xmpData_[\"Xmp.video.TrackLayer\"] = buf.read_uint16(0, bigEndian);\n\
    \         else if (currentStream_ == Audio)\n-          xmpData_[\"Xmp.audio.TrackLayer\"\
    ] = returnBufValue(buf, 2);\n+          xmpData_[\"Xmp.audio.TrackLayer\"] = buf.read_uint16(0,\
    \ bigEndian);\n         break;\n       case TrackVolume:\n         if (currentStream_\
    \ == Video)\n-          xmpData_[\"Xmp.video.TrackVolume\"] = (returnBufValue(buf,\
    \ 1) + (buf.data()[2] * 0.1)) * 100;\n+          xmpData_[\"Xmp.video.TrackVolume\"\
    ] = (static_cast<int>(buf.read_uint8(0)) + (buf.data()[2] * 0.1)) * 100;\n   \
    \      else if (currentStream_ == Audio)\n-          xmpData_[\"Xmp.video.TrackVolume\"\
    ] = (returnBufValue(buf, 1) + (buf.data()[2] * 0.1)) * 100;\n+          xmpData_[\"\
    Xmp.video.TrackVolume\"] = (static_cast<int>(buf.read_uint8(0)) + (buf.data()[2]\
    \ * 0.1)) * 100;\n         break;\n       case ImageWidth:\n         if (currentStream_\
    \ == Video) {\n-          temp = returnBufValue(buf, 2) + static_cast<int64_t>((buf.data()[2]\
    \ * 256 + buf.data()[3]) * 0.01);\n+          temp = buf.read_uint16(0, bigEndian)\
    \ + static_cast<int64_t>((buf.data()[2] * 256 + buf.data()[3]) * 0.01);\n    \
    \       xmpData_[\"Xmp.video.Width\"] = temp;\n           width_ = temp;\n   \
    \      }\n         break;\n       case ImageHeight:\n         if (currentStream_\
    \ == Video) {\n-          temp = returnBufValue(buf, 2) + static_cast<int64_t>((buf.data()[2]\
    \ * 256 + buf.data()[3]) * 0.01);\n+          temp = buf.read_uint16(0, bigEndian)\
    \ + static_cast<int64_t>((buf.data()[2] * 256 + buf.data()[3]) * 0.01);\n    \
    \       xmpData_[\"Xmp.video.Height\"] = temp;\n           height_ = temp;\n \
    \        }\n@@ -1480,7 +1450,7 @@ void QuickTimeVideo::trackHeaderDecoder(size_t\
    \ size) {\n         break;\n     }\n   }\n-  io_->read(buf.data(), size % 4);\n\
    +  io_->readOrThrow(buf.data(), size % 4);\n }  // QuickTimeVideo::trackHeaderDecoder\n\
    \ \n void QuickTimeVideo::movieHeaderDecoder(size_t size) {\n@@ -1489,63 +1459,64\
    \ @@ void QuickTimeVideo::movieHeaderDecoder(size_t size) {\n   buf.data()[4]\
    \ = '\\0';\n \n   for (int i = 0; size / 4 != 0; size -= 4, i++) {\n-    io_->read(buf.data(),\
    \ 4);\n+    io_->readOrThrow(buf.data(), 4);\n \n     switch (i) {\n       case\
    \ MovieHeaderVersion:\n-        xmpData_[\"Xmp.video.MovieHeaderVersion\"] = returnBufValue(buf,\
    \ 1);\n+        xmpData_[\"Xmp.video.MovieHeaderVersion\"] = static_cast<int>(buf.read_uint8(0));\n\
    \         break;\n       case CreateDate:\n         // A 32-bit integer that specifies\
    \ (in seconds since midnight, January 1, 1904) when the movie atom was created.\n\
    -        xmpData_[\"Xmp.video.DateUTC\"] = returnUnsignedBufValue(buf);\n+   \
    \     xmpData_[\"Xmp.video.DateUTC\"] = buf.read_uint32(0, bigEndian);\n     \
    \    break;\n       case ModifyDate:\n         // A 32-bit integer that specifies\
    \ (in seconds since midnight, January 1, 1904) when the movie atom was created.\n\
    -        xmpData_[\"Xmp.video.ModificationDate\"] = returnUnsignedBufValue(buf);\n\
    +        xmpData_[\"Xmp.video.ModificationDate\"] = buf.read_uint32(0, bigEndian);\n\
    \         break;\n       case TimeScale:\n-        xmpData_[\"Xmp.video.TimeScale\"\
    ] = returnBufValue(buf);\n-        timeScale_ = returnBufValue(buf);\n+      \
    \  xmpData_[\"Xmp.video.TimeScale\"] = buf.read_uint32(0, bigEndian);\n+     \
    \   timeScale_ = buf.read_uint32(0, bigEndian);\n         if (timeScale_ <= 0)\n\
    \           timeScale_ = 1;\n         break;\n       case Duration:\n        \
    \ if (timeScale_ != 0) {  // To prevent division by zero\n-          xmpData_[\"\
    Xmp.video.Duration\"] = returnBufValue(buf) * 1000 / timeScale_;\n+          xmpData_[\"\
    Xmp.video.Duration\"] = buf.read_uint32(0, bigEndian) * 1000 / timeScale_;\n \
    \        }\n         break;\n       case PreferredRate:\n-        xmpData_[\"\
    Xmp.video.PreferredRate\"] = returnBufValue(buf, 2) + ((buf.data()[2] * 256 +\
    \ buf.data()[3]) * 0.01);\n+        xmpData_[\"Xmp.video.PreferredRate\"] =\n\
    +            buf.read_uint16(0, bigEndian) + ((buf.data()[2] * 256 + buf.data()[3])\
    \ * 0.01);\n         break;\n       case PreferredVolume:\n-        xmpData_[\"\
    Xmp.video.PreferredVolume\"] = (returnBufValue(buf, 1) + (buf.data()[2] * 0.1))\
    \ * 100;\n+        xmpData_[\"Xmp.video.PreferredVolume\"] = (static_cast<int>(buf.read_uint8(0))\
    \ + (buf.data()[2] * 0.1)) * 100;\n         break;\n       case PreviewTime:\n\
    -        xmpData_[\"Xmp.video.PreviewTime\"] = returnBufValue(buf);\n+       \
    \ xmpData_[\"Xmp.video.PreviewTime\"] = buf.read_uint32(0, bigEndian);\n     \
    \    break;\n       case PreviewDuration:\n-        xmpData_[\"Xmp.video.PreviewDuration\"\
    ] = returnBufValue(buf);\n+        xmpData_[\"Xmp.video.PreviewDuration\"] = buf.read_uint32(0,\
    \ bigEndian);\n         break;\n       case PosterTime:\n-        xmpData_[\"\
    Xmp.video.PosterTime\"] = returnBufValue(buf);\n+        xmpData_[\"Xmp.video.PosterTime\"\
    ] = buf.read_uint32(0, bigEndian);\n         break;\n       case SelectionTime:\n\
    -        xmpData_[\"Xmp.video.SelectionTime\"] = returnBufValue(buf);\n+     \
    \   xmpData_[\"Xmp.video.SelectionTime\"] = buf.read_uint32(0, bigEndian);\n \
    \        break;\n       case SelectionDuration:\n-        xmpData_[\"Xmp.video.SelectionDuration\"\
    ] = returnBufValue(buf);\n+        xmpData_[\"Xmp.video.SelectionDuration\"] =\
    \ buf.read_uint32(0, bigEndian);\n         break;\n       case CurrentTime:\n\
    -        xmpData_[\"Xmp.video.CurrentTime\"] = returnBufValue(buf);\n+       \
    \ xmpData_[\"Xmp.video.CurrentTime\"] = buf.read_uint32(0, bigEndian);\n     \
    \    break;\n       case NextTrackID:\n-        xmpData_[\"Xmp.video.NextTrackID\"\
    ] = returnBufValue(buf);\n+        xmpData_[\"Xmp.video.NextTrackID\"] = buf.read_uint32(0,\
    \ bigEndian);\n         break;\n       default:\n         break;\n     }\n   }\n\
    -  io_->read(buf.data(), size % 4);\n+  io_->readOrThrow(buf.data(), size % 4);\n\
    \ }  // QuickTimeVideo::movieHeaderDecoder\n \n void QuickTimeVideo::aspectRatio()\
    \ {"
  identifiers: CVE:["CVE-2024-25112"],CWE:["CWE-400"]
  overview: Affected versions of this package are vulnerable to Denial of Service
    (DoS) due to the `QuickTimeVideo::multipleEntriesDecoder` function. An attacker
    can cause the application to crash by exhausting the stack through the use of
    a crafted video file.
  references:
    GitHub Commit: https://github.com/Exiv2/exiv2/commit/e4adf388aaaccccaf08fc0fc38419a5b0117b299
    GitHub PR: https://github.com/Exiv2/exiv2/pull/2337
    commons-fileupload:commons-fileupload: SNYK-JAVA-COMMONSFILEUPLOAD-30082
    npm <code>ws</code> package: https://snyk.io/vuln/npm:ws:20171108
  title: Denial of Service (DoS)
- diff_content:
  - "--- a/src/pkcs15init/pkcs15-authentic.c\n+++ b/src/pkcs15init/pkcs15-authentic.c\n\
    @@ -868,7 +868,7 @@ authentic_emu_update_tokeninfo(struct sc_profile *profile,\
    \ struct sc_pkcs15_card\n \trv = sc_select_file(p15card->card, &path, &file);\n\
    \ \tif (!rv) {\n \t\trv = sc_get_challenge(p15card->card, buffer, sizeof(buffer));\n\
    -\t\tif (!rv) {\n+\t\tif (rv < 0) {\n \t\t\tsc_file_free(file);\n \t\t\tLOG_TEST_RET(ctx,\
    \ rv, \"Get challenge error\");\n \t\t}"
  identifiers: CVE:["CVE-2024-1454"],CWE:["CWE-416"]
  overview: Affected versions of this package are vulnerable to Use After Free due
    to improper handling in the AuthentIC driver when updating token information.
    An attacker can exploit this vulnerability by manipulating the memory after it
    has been freed, potentially leading to unauthorized actions or information disclosure.
  references:
    GitHub Commit: https://github.com/OpenSC/OpenSC/commit/5835f0d4f6c033bd58806d33fa546908d39825c9
    RedHat Bugzilla Bug: https://bugzilla.redhat.com/show_bug.cgi?id=2263929
  title: Use After Free
- diff_content:
  - "--- a/main/modules/screen_billboard.c\n+++ b/main/modules/screen_billboard.c\n\
    @@ -110,10 +110,11 @@ void DisplayBillboard(int _addmessageflag, char* _nickname,\
    \ char* _message) {\n         strcpy(messagearray[messagecursor], _message);\n\
    \ \n         // increment or reset cursor\n-        if (messagecursor >= nbmessages)\
    \ {\n+        if (messagecursor >= nbmessages - 1) {\n             messagecursor\
    \ = 0;\n+        } else {\n+            messagecursor++;\n         }\n-      \
    \  messagecursor++;\n     }\n \n     for (int i = 0; i < nbmessages; i++) {"
  identifiers: CVE:["CVE-2024-21875"],CWE:["CWE-770"]
  overview: Affected versions of this package are vulnerable to Allocation of Resources
    Without Limits or Throttling via a buffer overflow due to invalid bounds checking.
  references:
    GitHub Commit: https://github.com/badgeteam/hackerhotel-2024-firmware-esp32c6/commit/bd4b5777948e66b78693e6d3d73cac68e20ee0a6
    GitHub PR: https://github.com/badgeteam/hackerhotel-2024-firmware-esp32c6/pull/64
  title: Allocation of Resources Without Limits or Throttling
- diff_content:
  - "--- a/src/http/ngx_http_copy_filter_module.c\n+++ b/src/http/ngx_http_copy_filter_module.c\n\
    @@ -208,9 +208,18 @@ ngx_http_copy_aio_event_handler(ngx_event_t *ev)\n     r->main->blocked--;\n\
    \     r->aio = 0;\n \n-    r->write_event_handler(r);\n+    if (r->main->terminated)\
    \ {\n+        /*\n+         * trigger connection event handler if the request\
    \ was\n+         * terminated\n+         */\n+\n+        c->write->handler(c->write);\n\
    \ \n-    ngx_http_run_posted_requests(c);\n+    } else {\n+        r->write_event_handler(r);\n\
    +        ngx_http_run_posted_requests(c);\n+    }\n }\n \n #endif\n@@ -331,11\
    \ +340,11 @@ ngx_http_copy_thread_event_handler(ngx_event_t *ev)\n \n #endif\n\
    \ \n-    if (r->done) {\n+    if (r->done || r->main->terminated) {\n        \
    \ /*\n          * trigger connection event handler if the subrequest was\n-  \
    \       * already finalized; this can happen if the handler is used\n-       \
    \  * for sendfile() in threads\n+         * already finalized (this can happen\
    \ if the handler is used\n+         * for sendfile() in threads), or if the request\
    \ was terminated\n          */\n \n         c->write->handler(c->write);"
  - "--- a/src/http/ngx_http_file_cache.c\n+++ b/src/http/ngx_http_file_cache.c\n\
    @@ -14,7 +14,7 @@\n static ngx_int_t ngx_http_file_cache_lock(ngx_http_request_t\
    \ *r,\n     ngx_http_cache_t *c);\n static void ngx_http_file_cache_lock_wait_handler(ngx_event_t\
    \ *ev);\n-static void ngx_http_file_cache_lock_wait(ngx_http_request_t *r,\n+static\
    \ ngx_int_t ngx_http_file_cache_lock_wait(ngx_http_request_t *r,\n     ngx_http_cache_t\
    \ *c);\n static ngx_int_t ngx_http_file_cache_read(ngx_http_request_t *r,\n  \
    \   ngx_http_cache_t *c);\n@@ -463,6 +463,7 @@ ngx_http_file_cache_lock(ngx_http_request_t\
    \ *r, ngx_http_cache_t *c)\n static void\n ngx_http_file_cache_lock_wait_handler(ngx_event_t\
    \ *ev)\n {\n+    ngx_int_t            rc;\n     ngx_connection_t    *c;\n    \
    \ ngx_http_request_t  *r;\n \n@@ -474,13 +475,31 @@ ngx_http_file_cache_lock_wait_handler(ngx_event_t\
    \ *ev)\n     ngx_log_debug2(NGX_LOG_DEBUG_HTTP, c->log, 0,\n                 \
    \   \"http file cache wait: \\\"%V?%V\\\"\", &r->uri, &r->args);\n \n-    ngx_http_file_cache_lock_wait(r,\
    \ r->cache);\n+    rc = ngx_http_file_cache_lock_wait(r, r->cache);\n \n-    ngx_http_run_posted_requests(c);\n\
    +    if (rc == NGX_AGAIN) {\n+        return;\n+    }\n+\n+    r->cache->waiting\
    \ = 0;\n+    r->main->blocked--;\n+\n+    if (r->main->terminated) {\n+      \
    \  /*\n+         * trigger connection event handler if the request was\n+    \
    \     * terminated\n+         */\n+\n+        c->write->handler(c->write);\n+\n\
    +    } else {\n+        r->write_event_handler(r);\n+        ngx_http_run_posted_requests(c);\n\
    +    }\n }\n \n \n-static void\n+static ngx_int_t\n ngx_http_file_cache_lock_wait(ngx_http_request_t\
    \ *r, ngx_http_cache_t *c)\n {\n     ngx_uint_t              wait;\n@@ -495,7\
    \ +514,7 @@ ngx_http_file_cache_lock_wait(ngx_http_request_t *r, ngx_http_cache_t\
    \ *c)\n         ngx_log_error(NGX_LOG_INFO, r->connection->log, 0,\n         \
    \              \"cache lock timeout\");\n         c->lock_timeout = 0;\n-    \
    \    goto wakeup;\n+        return NGX_OK;\n     }\n \n     cache = c->file_cache;\n\
    @@ -513,14 +532,10 @@ ngx_http_file_cache_lock_wait(ngx_http_request_t *r, ngx_http_cache_t\
    \ *c)\n \n     if (wait) {\n         ngx_add_timer(&c->wait_event, (timer > 500)\
    \ ? 500 : timer);\n-        return;\n+        return NGX_AGAIN;\n     }\n \n-wakeup:\n\
    -\n-    c->waiting = 0;\n-    r->main->blocked--;\n-    r->write_event_handler(r);\n\
    +    return NGX_OK;\n }\n \n \n@@ -753,9 +768,18 @@ ngx_http_cache_aio_event_handler(ngx_event_t\
    \ *ev)\n     r->main->blocked--;\n     r->aio = 0;\n \n-    r->write_event_handler(r);\n\
    +    if (r->main->terminated) {\n+        /*\n+         * trigger connection event\
    \ handler if the request was\n+         * terminated\n+         */\n+\n+     \
    \   c->write->handler(c->write);\n \n-    ngx_http_run_posted_requests(c);\n+\
    \    } else {\n+        r->write_event_handler(r);\n+        ngx_http_run_posted_requests(c);\n\
    +    }\n }\n \n #endif\n@@ -836,9 +860,18 @@ ngx_http_cache_thread_event_handler(ngx_event_t\
    \ *ev)\n     r->main->blocked--;\n     r->aio = 0;\n \n-    r->write_event_handler(r);\n\
    +    if (r->main->terminated) {\n+        /*\n+         * trigger connection event\
    \ handler if the request was\n+         * terminated\n+         */\n \n-    ngx_http_run_posted_requests(c);\n\
    +        c->write->handler(c->write);\n+\n+    } else {\n+        r->write_event_handler(r);\n\
    +        ngx_http_run_posted_requests(c);\n+    }\n }\n \n #endif"
  - "--- a/src/http/ngx_http_request.c\n+++ b/src/http/ngx_http_request.c\n@@ -2694,6\
    \ +2694,8 @@ ngx_http_terminate_request(ngx_http_request_t *r, ngx_int_t rc)\n\
    \     ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n            \
    \        \"http terminate request count:%d\", mr->count);\n \n+    mr->terminated\
    \ = 1;\n+\n     if (rc > 0 && (mr->headers_out.status == 0 || mr->connection->sent\
    \ == 0)) {\n         mr->headers_out.status = rc;\n     }\n@@ -2716,8 +2718,11\
    \ @@ ngx_http_terminate_request(ngx_http_request_t *r, ngx_int_t rc)\n     if\
    \ (mr->write_event_handler) {\n \n         if (mr->blocked) {\n+            r\
    \ = r->connection->data;\n+\n             r->connection->error = 1;\n        \
    \     r->write_event_handler = ngx_http_request_finalizer;\n+\n             return;\n\
    \         }\n "
  - "--- a/src/http/ngx_http_upstream.c\n+++ b/src/http/ngx_http_upstream.c\n@@ -3997,11\
    \ +3997,11 @@ ngx_http_upstream_thread_event_handler(ngx_event_t *ev)\n \n #endif\n\
    \ \n-    if (r->done) {\n+    if (r->done || r->main->terminated) {\n        \
    \ /*\n          * trigger connection event handler if the subrequest was\n-  \
    \       * already finalized; this can happen if the handler is used\n-       \
    \  * for sendfile() in threads\n+         * already finalized (this can happen\
    \ if the handler is used\n+         * for sendfile() in threads), or if the request\
    \ was terminated\n          */\n \n         c->write->handler(c->write);"
  identifiers: CVE:["CVE-2024-24990"],CWE:["CWE-416"]
  overview: Affected versions of this package are vulnerable to Use After Free that
    allows an attacker to terminate a worker process by sending malicious traffic
    to a QUIC session.
  references:
    GitHub Commit: https://github.com/nginx/nginx/commit/c251961c4186ce93cf6eb3c99bf5b7114535d490
    RedHat Bugzilla Bug: https://bugzilla.redhat.com/show_bug.cgi?id=2264298
    Vulnerability Advisory: https://my.f5.com/manage/s/article/K000138445
  title: Use After Free
- diff_content:
  - "--- a/src/backend/commands/matview.c\n+++ b/src/backend/commands/matview.c\n\
    @@ -655,13 +655,35 @@ refresh_by_match_merge(Oid matviewOid, Oid tempOid, Oid\
    \ relowner,\n \t\t\t\t\t\t   SPI_getvalue(SPI_tuptable->vals[0], SPI_tuptable->tupdesc,\
    \ 1))));\n \t}\n \n+\t/*\n+\t * Create the temporary \"diff\" table.\n+\t *\n\
    +\t * Temporarily switch out of the SECURITY_RESTRICTED_OPERATION context,\n+\t\
    \ * because you cannot create temp tables in SRO context.  For extra\n+\t * paranoia,\
    \ add the composite type column only after switching back to\n+\t * SRO context.\n\
    +\t */\n \tSetUserIdAndSecContext(relowner,\n \t\t\t\t\t\t   save_sec_context\
    \ | SECURITY_LOCAL_USERID_CHANGE);\n+\tresetStringInfo(&querybuf);\n+\tappendStringInfo(&querybuf,\n\
    +\t\t\t\t\t \"CREATE TEMP TABLE %s (tid pg_catalog.tid)\",\n+\t\t\t\t\t diffname);\n\
    +\tif (SPI_exec(querybuf.data, 0) != SPI_OK_UTILITY)\n+\t\telog(ERROR, \"SPI_exec\
    \ failed: %s\", querybuf.data);\n+\tSetUserIdAndSecContext(relowner,\n+\t\t\t\t\
    \t\t   save_sec_context | SECURITY_RESTRICTED_OPERATION);\n+\tresetStringInfo(&querybuf);\n\
    +\tappendStringInfo(&querybuf,\n+\t\t\t\t\t \"ALTER TABLE %s ADD COLUMN newdata\
    \ %s\",\n+\t\t\t\t\t diffname, tempname);\n+\tif (SPI_exec(querybuf.data, 0) !=\
    \ SPI_OK_UTILITY)\n+\t\telog(ERROR, \"SPI_exec failed: %s\", querybuf.data);\n\
    \ \n-\t/* Start building the query for creating the diff table. */\n+\t/* Start\
    \ building the query for populating the diff table. */\n \tresetStringInfo(&querybuf);\n\
    \ \tappendStringInfo(&querybuf,\n-\t\t\t\t\t \"CREATE TEMP TABLE %s AS \"\n+\t\
    \t\t\t\t \"INSERT INTO %s \"\n \t\t\t\t\t \"SELECT mv.ctid AS tid, newdata.*::%s\
    \ AS newdata \"\n \t\t\t\t\t \"FROM %s mv FULL JOIN %s newdata ON (\",\n \t\t\t\
    \t\t diffname, tempname, matviewname, tempname);\n@@ -790,13 +812,10 @@ refresh_by_match_merge(Oid\
    \ matviewOid, Oid tempOid, Oid relowner,\n \t\t\t\t\t\t   \"WHERE newdata.* IS\
    \ NULL OR mv.* IS NULL \"\n \t\t\t\t\t\t   \"ORDER BY tid\");\n \n-\t/* Create\
    \ the temporary \"diff\" table. */\n-\tif (SPI_exec(querybuf.data, 0) != SPI_OK_UTILITY)\n\
    +\t/* Populate the temporary \"diff\" table. */\n+\tif (SPI_exec(querybuf.data,\
    \ 0) != SPI_OK_INSERT)\n \t\telog(ERROR, \"SPI_exec failed: %s\", querybuf.data);\n\
    \ \n-\tSetUserIdAndSecContext(relowner,\n-\t\t\t\t\t\t   save_sec_context | SECURITY_RESTRICTED_OPERATION);\n\
    -\n \t/*\n \t * We have no further use for data from the \"full-data\" temp table,\
    \ but we\n \t * must keep it around because its type is referenced from the diff\
    \ table."
  identifiers: CVE:["CVE-2024-0985"],CWE:["CWE-271"]
  overview: Affected versions of this package are vulnerable to Privilege Management
    Errors due to the improper handling of the `REFRESH MATERIALIZED VIEW CONCURRENTLY`
    statement. An attacker can execute arbitrary SQL commands by convincing a user
    with the necessary privileges to run it on the attacker's view, which has `CREATE
    RULE` rules based on it with higher-privileged function execution.
  references:
    GitHub Commit: https://github.com/postgres/postgres/commit/f4f2883521fc3f81765ab82eab2ffa31574f0a07
    RedHat Bugzilla Bug: https://bugzilla.redhat.com/show_bug.cgi?id=2263384
    Vulnerability Advisory: https://www.postgresql.org/support/security/CVE-2024-0985/
  title: Privilege Management Errors
- diff_content:
  - "--- a/src/plugin/protocol_oidc.c\n+++ b/src/plugin/protocol_oidc.c\n@@ -3803,8\
    \ +3803,6 @@ static int check_client_redirect_uri_valid(struct _oidc_config *\
    \ config,\n       } else {\n         uri_found = 0;\n       }\n-    } else {\n\
    -      uri_found = 1;\n     }\n     if (!uri_found) {\n       y_log_message(Y_LOG_LEVEL_DEBUG,\
    \ \"check_client_redirect_uri_valid - oidc - Error, redirect_uri '%s' is invalid\
    \ for the client '%s', origin: %s\", redirect_uri, client_id, ip_source);\n@@\
    \ -3834,14 +3832,11 @@ static json_t * check_client_valid_without_secret(struct\
    \ _oidc_config * config,\n   j_client = config->glewlwyd_config->glewlwyd_plugin_callback_get_client(config->glewlwyd_config,\
    \ client_id);\n   if (check_result_value(j_client, G_OK) && json_object_get(json_object_get(j_client,\
    \ \"client\"), \"enabled\") == json_true()) {\n     if (redirect_uri != NULL)\
    \ {\n-      uri_found = 0;\n       json_array_foreach(json_object_get(json_object_get(j_client,\
    \ \"client\"), \"redirect_uri\"), index, j_element) {\n         if (0 == o_strcmp(json_string_value(j_element),\
    \ redirect_uri)) {\n           uri_found = 1;\n         }\n       }\n-    } else\
    \ {\n-      uri_found = 1;\n     }\n \n     authorization_type_enabled = 1;\n\
    @@ -4003,8 +3998,6 @@ static json_t * check_client_valid(struct _oidc_config *\
    \ config,\n     } else {\n       if (redirect_uri != NULL) {\n         uri_found\
    \ = json_array_has_string(json_object_get(json_object_get(j_client, \"client\"\
    ), \"redirect_uri\"), redirect_uri);\n-      } else {\n-        uri_found = 1;\n\
    \       }\n \n       authorization_type_enabled = 1;\n@@ -14165,7 +14158,7 @@\
    \ static int callback_oidc_authorization(const struct _u_request * request, struct\n\
    \       }\n     }\n \n-    if (!o_strnullempty(client_id) && !o_strnullempty(redirect_uri)\
    \ && check_client_redirect_uri_valid(config, client_id, redirect_uri, ip_source)\
    \ != G_OK) {\n+    if (!o_strnullempty(response_type) && check_client_redirect_uri_valid(config,\
    \ client_id, redirect_uri, ip_source) != G_OK) {\n       y_log_message(Y_LOG_LEVEL_DEBUG,\
    \ \"callback_oidc_authorization - invlid client identified with redirect_uri\"\
    );\n       response->status = 403;\n       break;\n@@ -14274,7 +14267,7 @@ static\
    \ int callback_oidc_authorization(const struct _u_request * request, struct\n\
    \           login_hint = json_string_value(json_object_get(json_object_get(j_request,\
    \ \"request\"), \"login_hint\"));\n           prompt = json_string_value(json_object_get(json_object_get(j_request,\
    \ \"request\"), \"prompt\"));\n           max_age = json_string_value(json_object_get(json_object_get(j_request,\
    \ \"request\"), \"max_age\"));\n-          if (!o_strnullempty(client_id) && !o_strnullempty(redirect_uri)\
    \ && check_client_redirect_uri_valid(config, client_id, redirect_uri, ip_source)\
    \ != G_OK) {\n+          if (check_client_redirect_uri_valid(config, client_id,\
    \ redirect_uri, ip_source) != G_OK) {\n             y_log_message(Y_LOG_LEVEL_DEBUG,\
    \ \"callback_oidc_authorization - invlid client identified with redirect_uri\"\
    );\n             response->status = 403;\n             break;\n@@ -14523,10 +14516,7\
    \ @@ static int callback_oidc_authorization(const struct _u_request * request,\
    \ struct\n \n     // Check if at least one scope has been provided\n     if (o_strnullempty(scope))\
    \ {\n-      // Scope is not allowed for this user\n-      y_log_message(Y_LOG_LEVEL_DEBUG,\
    \ \"oidc validate_endpoint_auth - scope list is missing or empty or scope 'openid'\
    \ missing, origin: %s\", ip_source);\n-      u_map_put(&map_redirect, \"error\"\
    , \"invalid_scope\");\n-      build_auth_response(config, response, response_mode,\
    \ json_object_get(j_client, \"client\"), redirect_uri, &map_redirect);\n+    \
    \  response->status = 403;\n       break;\n     }\n "
  identifiers: CVE:["CVE-2024-25715"],CWE:["CWE-601"]
  overview: Affected versions of this package are vulnerable to Open Redirect due
    to improper validation of the `redirect_uri` parameter. An attacker can redirect
    users to a malicious website by crafting a malicious URL and convincing the user
    to click on it.
  references:
    GitHub Commit: https://github.com/babelouest/glewlwyd/commit/c91c0155f2393274cc18efe77e06c6846e404c75
  title: Open Redirect
- diff_content:
  - "--- a/src/jws.c\n+++ b/src/jws.c\n@@ -479,7 +479,10 @@ static int r_jws_verify_sig_hmac(jws_t\
    \ * jws, jwk_t * jwk) {\n   unsigned char * sig = r_jws_sign_hmac(jws, jwk);\n\
    \   int ret;\n \n-  if (sig != NULL && 0 == o_strcmp((const char *)jws->signature_b64url,\
    \ (const char *)sig)) {\n+  if (!o_strnullempty((const char *)jws->signature_b64url)\
    \ &&\n+      !o_strnullempty((const char *)sig) &&\n+      o_strlen((const char\
    \ *)sig) == o_strlen((const char *)jws->signature_b64url) &&\n+      0 == gnutls_memcmp(jws->signature_b64url,\
    \ sig, o_strlen((const char *)sig))) {\n     ret = RHN_OK;\n   } else {\n    \
    \ ret = RHN_ERROR_INVALID;"
  identifiers: CVE:["CVE-2024-25714"],CWE:["CWE-200"]
  overview: Affected versions of this package are vulnerable to Information Exposure
    due to the use of a `strcmp` function for HMAC signature verification, which may
    halt the comparison upon encountering the first discrepancy between two signatures.
    An attacker can potentially infer the HMAC signature by observing the time variations
    in the comparison process.
  references:
    GitHub Commit: https://github.com/babelouest/rhonabwy/commit/f9fd9a1c77e48b514ebb3baf0360f87eef3d846e
  title: Information Exposure
- diff_content:
  - "--- a/src/GUI/Authentication.cpp\n+++ b/src/GUI/Authentication.cpp\n@@ -11,41\
    \ +11,42 @@ using nm = nitrokey::NitrokeyManager;\n #include <QTimer>\n \n Authentication::Authentication(QObject\
    \ *parent) : QObject(parent) {\n-\n+    tempPassword.clear();\n }\n \n bool Authentication::authenticate(){\n\
    -  qDebug() << tempPassword.toLatin1().toHex();\n+//  qDebug() << tempPassword.toLatin1().toHex();\n\
    \   bool authenticationSuccess = false;\n \n   const auto validation_period =\
    \ 10 * 60 * 1000; //TODO move to field, add to ctr as param\n-  if (!tempPassword.isEmpty()\
    \ && authenticationValidUntilTime >= getCurrentTime()){\n-    authenticationValidUntilTime\
    \ = getCurrentTime() + validation_period;\n-    authenticationSuccess = true;\n\
    -    QTimer::singleShot(validation_period, this, SLOT(clearTemporaryPassword()));\n\
    -    return authenticationSuccess;\n-  }\n+//  if (!tempPassword.isEmpty() &&\
    \ authenticationValidUntilTime >= getCurrentTime()){\n+//    authenticationValidUntilTime\
    \ = getCurrentTime() + validation_period;\n+//    authenticationSuccess = true;\n\
    +//    QTimer::singleShot(validation_period, this, SLOT(clearTemporaryPassword()));\n\
    +//    return authenticationSuccess;\n+//  }\n \n   QString password;\n   do {\n\
    -    PinDialog dialog(tr(\"Enter admin PIN\"), tr(\"Admin PIN:\"), PinDialog::PLAIN,\n\
    -                     PinDialog::ADMIN_PIN); //TODO move user/admin to field,\
    \ add to ctr as param\n+      PinDialog dialog(PinDialog::ADMIN_PIN);\n+\n   \
    \  int ok = dialog.exec();\n     if (ok != QDialog::Accepted) {\n       return\
    \ authenticationSuccess;\n     }\n \n     //emit signal with password to authenticate\
    \ (by pointer)\n     auto password = dialog.getPassword();\n-    auto tempPasswordLocal\
    \ = generateTemporaryPassword();\n+//    auto tempPasswordLocal = generateTemporaryPassword();\n\
    +    tempPassword = generateTemporaryPassword();\n     //emit end\n \n     //slot\
    \ receiving signal\n     try{\n       nm::instance()->first_authenticate(password.c_str(),\
    \ tempPassword.toLatin1().constData());\n       //FIXME securedelete password\n\
    \       authenticationValidUntilTime = getCurrentTime() + validation_period;\n\
    -      tempPassword = tempPasswordLocal;\n+//      tempPassword = tempPasswordLocal;\n\
    \       authenticationSuccess = true;\n       return authenticationSuccess;\n\
    \     }\n@@ -79,11 +80,13 @@ QString Authentication::generateTemporaryPassword()\
    \ const {\n }\n \n #include \"core/ScopedGuard.h\"\n+\n const QString Authentication::getTempPassword()\
    \ {\n+//    authenticate(); //TODO check?\n     QString local_tempPassword = tempPassword;\n\
    \     bool is_07nkpro_device = libada::i()->is_nkpro_07_rtm1();\n-  if (is_07nkpro_device){\n\
    -    clearTemporaryPassword(true);\n-  }\n-  return local_tempPassword;\n+   \
    \ if (is_07nkpro_device) {\n+        clearTemporaryPassword(true);\n+    }\n+\
    \    return local_tempPassword;\n }\n\\ No newline at end of file"
  identifiers: CVE:[],CWE:["CWE-311"],PVE:["PVE-2024-63550"]
  overview: Affected versions of this package are vulnerable to Missing Encryption
    of Sensitive Data where passwords were stored in plaintext in memory. This flaw
    poses a significant risk of unauthorized data access.
  references:
    GitHub Commit: https://github.com/Nitrokey/nitrokey-app/commit/c1c00c0081083c9722ea890b1f6f3f1e5fd26bfb
  title: Missing Encryption of Sensitive Data
- diff_content:
  - "--- a/src/message.c\n+++ b/src/message.c\n@@ -7,6 +7,7 @@\n #include \"azure_macro_utils/macro_utils.h\"\
    \n #include \"azure_c_shared_utility/gballoc.h\"\n #include \"azure_c_shared_utility/xlogging.h\"\
    \n+#include \"azure_c_shared_utility/safe_math.h\"\n #include \"azure_uamqp_c/amqp_definitions.h\"\
    \n #include \"azure_uamqp_c/message.h\"\n #include \"azure_uamqp_c/amqpvalue.h\"\
    \n@@ -232,78 +233,100 @@ MESSAGE_HANDLE message_clone(MESSAGE_HANDLE source_message)\n\
    \ \n             if ((result != NULL) && (source_message->body_amqp_data_count\
    \ > 0))\n             {\n-                size_t i;\n+                size_t calloc_size\
    \ = safe_multiply_size_t(source_message->body_amqp_data_count, sizeof(BODY_AMQP_DATA));\n\
    \ \n-                result->body_amqp_data_items = (BODY_AMQP_DATA*)calloc(1,\
    \ (source_message->body_amqp_data_count * sizeof(BODY_AMQP_DATA)));\n-       \
    \         if (result->body_amqp_data_items == NULL)\n+                if (calloc_size\
    \ == SIZE_MAX)\n                 {\n-                    /* Codes_SRS_MESSAGE_01_012:\
    \ [ If any cloning operation for the members of the source message fails, then\
    \ `message_clone` shall fail and return NULL. ]*/\n-                    LogError(\"\
    Cannot allocate memory for body data sections\");\n-                    message_destroy(result);\n\
    +                    LogError(\"Invalid size for body_amqp_data_items\");\n  \
    \                   result = NULL;\n                 }\n                 else\n\
    \                 {\n-                    for (i = 0; i < source_message->body_amqp_data_count;\
    \ i++)\n+                    result->body_amqp_data_items = (BODY_AMQP_DATA*)calloc(1,\
    \ calloc_size);\n+\n+                    if (result->body_amqp_data_items == NULL)\n\
    \                     {\n-                        result->body_amqp_data_items[i].body_data_section_length\
    \ = source_message->body_amqp_data_items[i].body_data_section_length;\n+     \
    \                   /* Codes_SRS_MESSAGE_01_012: [ If any cloning operation for\
    \ the members of the source message fails, then `message_clone` shall fail and\
    \ return NULL. ]*/\n+                        LogError(\"Cannot allocate memory\
    \ for body data sections\");\n+                        message_destroy(result);\n\
    +                        result = NULL;\n+                    }\n+           \
    \         else\n+                    {\n+                        size_t i;\n \n\
    -                        /* Codes_SRS_MESSAGE_01_011: [If an AMQP data has been\
    \ set as message body on the source message it shall be cloned by allocating memory\
    \ for the binary payload.] */\n-                        result->body_amqp_data_items[i].body_data_section_bytes\
    \ = (unsigned char*)malloc(source_message->body_amqp_data_items[i].body_data_section_length);\n\
    -                        if (result->body_amqp_data_items[i].body_data_section_bytes\
    \ == NULL)\n+                        for (i = 0; i < source_message->body_amqp_data_count;\
    \ i++)\n                         {\n-                            LogError(\"Cannot\
    \ allocate memory for body data section %u\", (unsigned int)i);\n-           \
    \                 break;\n+                            result->body_amqp_data_items[i].body_data_section_length\
    \ = source_message->body_amqp_data_items[i].body_data_section_length;\n+\n+  \
    \                          /* Codes_SRS_MESSAGE_01_011: [If an AMQP data has been\
    \ set as message body on the source message it shall be cloned by allocating memory\
    \ for the binary payload.] */\n+                            result->body_amqp_data_items[i].body_data_section_bytes\
    \ = (unsigned char*)malloc(source_message->body_amqp_data_items[i].body_data_section_length);\n\
    +                            if (result->body_amqp_data_items[i].body_data_section_bytes\
    \ == NULL)\n+                            {\n+                                LogError(\"\
    Cannot allocate memory for body data section %u\", (unsigned int)i);\n+      \
    \                          break;\n+                            }\n+         \
    \                   else\n+                            {\n+                  \
    \              (void)memcpy(result->body_amqp_data_items[i].body_data_section_bytes,\
    \ source_message->body_amqp_data_items[i].body_data_section_bytes, result->body_amqp_data_items[i].body_data_section_length);\n\
    +                            }\n                         }\n-                \
    \        else\n+\n+                        result->body_amqp_data_count = i;\n\
    +                        if (i < source_message->body_amqp_data_count)\n     \
    \                    {\n-                            (void)memcpy(result->body_amqp_data_items[i].body_data_section_bytes,\
    \ source_message->body_amqp_data_items[i].body_data_section_bytes, result->body_amqp_data_items[i].body_data_section_length);\n\
    +                            /* Codes_SRS_MESSAGE_01_012: [ If any cloning operation\
    \ for the members of the source message fails, then `message_clone` shall fail\
    \ and return NULL. ]*/\n+                            message_destroy(result);\n\
    +                            result = NULL;\n                         }\n    \
    \                 }\n-\n-                    result->body_amqp_data_count = i;\n\
    -                    if (i < source_message->body_amqp_data_count)\n-        \
    \            {\n-                        /* Codes_SRS_MESSAGE_01_012: [ If any\
    \ cloning operation for the members of the source message fails, then `message_clone`\
    \ shall fail and return NULL. ]*/\n-                        message_destroy(result);\n\
    -                        result = NULL;\n-                    }\n            \
    \     }\n             }\n \n             if ((result != NULL) && (source_message->body_amqp_sequence_count\
    \ > 0))\n             {\n-                size_t i;\n+                size_t calloc_size\
    \ = safe_multiply_size_t(source_message->body_amqp_sequence_count, sizeof(AMQP_VALUE));\n\
    \ \n-                result->body_amqp_sequence_items = (AMQP_VALUE*)calloc(1,\
    \ (source_message->body_amqp_sequence_count * sizeof(AMQP_VALUE)));\n-       \
    \         if (result->body_amqp_sequence_items == NULL)\n+                if (calloc_size\
    \ == SIZE_MAX)\n                 {\n-                    /* Codes_SRS_MESSAGE_01_012:\
    \ [ If any cloning operation for the members of the source message fails, then\
    \ `message_clone` shall fail and return NULL. ]*/\n-                    LogError(\"\
    Cannot allocate memory for body AMQP sequences\");\n+                    LogError(\"\
    Invalid size for body_amqp_sequence_items\");\n                     message_destroy(result);\n\
    \                     result = NULL;\n                 }\n                 else\n\
    \                 {\n-                    for (i = 0; i < source_message->body_amqp_sequence_count;\
    \ i++)\n-                    {\n-                        /* Codes_SRS_MESSAGE_01_160:\
    \ [ If AMQP sequences are set as AMQP body they shall be cloned by calling `amqpvalue_clone`.\
    \ ] */\n-                        result->body_amqp_sequence_items[i] = amqpvalue_clone(source_message->body_amqp_sequence_items[i]);\n\
    -                        if (result->body_amqp_sequence_items[i] == NULL)\n- \
    \                       {\n-                            LogError(\"Cannot clone\
    \ AMQP sequence %u\", (unsigned int)i);\n-                            break;\n\
    -                        }\n-                    }\n-\n-                    result->body_amqp_sequence_count\
    \ = i;\n-                    if (i < source_message->body_amqp_sequence_count)\n\
    +                    result->body_amqp_sequence_items = (AMQP_VALUE*)calloc(1,\
    \ calloc_size);\n+                    if (result->body_amqp_sequence_items ==\
    \ NULL)\n                     {\n                         /* Codes_SRS_MESSAGE_01_012:\
    \ [ If any cloning operation for the members of the source message fails, then\
    \ `message_clone` shall fail and return NULL. ]*/\n+                        LogError(\"\
    Cannot allocate memory for body AMQP sequences\");\n                         message_destroy(result);\n\
    \                         result = NULL;\n                     }\n-          \
    \      }\n+                    else\n+                    {\n+               \
    \         size_t i;\n+\n+                        for (i = 0; i < source_message->body_amqp_sequence_count;\
    \ i++)\n+                        {\n+                            /* Codes_SRS_MESSAGE_01_160:\
    \ [ If AMQP sequences are set as AMQP body they shall be cloned by calling `amqpvalue_clone`.\
    \ ] */\n+                            result->body_amqp_sequence_items[i] = amqpvalue_clone(source_message->body_amqp_sequence_items[i]);\n\
    +                            if (result->body_amqp_sequence_items[i] == NULL)\n\
    +                            {\n+                                LogError(\"Cannot\
    \ clone AMQP sequence %u\", (unsigned int)i);\n+                             \
    \   break;\n+                            }\n+                        }\n+\n+ \
    \                       result->body_amqp_sequence_count = i;\n+             \
    \           if (i < source_message->body_amqp_sequence_count)\n+             \
    \           {\n+                            /* Codes_SRS_MESSAGE_01_012: [ If\
    \ any cloning operation for the members of the source message fails, then `message_clone`\
    \ shall fail and return NULL. ]*/\n+                            message_destroy(result);\n\
    +                            result = NULL;\n+                        }\n+   \
    \                 }\n+\t\t\t\t}\n             }\n \n             if ((result !=\
    \ NULL) && (source_message->body_amqp_value != NULL))\n@@ -1017,45 +1040,56 @@\
    \ int message_add_body_amqp_data(MESSAGE_HANDLE message, BINARY_DATA amqp_data)\n\
    \         }\n         else\n         {\n-            /* Codes_SRS_MESSAGE_01_086:\
    \ [ `message_add_body_amqp_data` shall add the contents of `amqp_data` to the\
    \ list of AMQP data values for the body of the message identified by `message`.\
    \ ]*/\n-            BODY_AMQP_DATA* new_body_amqp_data_items = (BODY_AMQP_DATA*)realloc(message->body_amqp_data_items,\
    \ sizeof(BODY_AMQP_DATA) * (message->body_amqp_data_count + 1));\n-          \
    \  if (new_body_amqp_data_items == NULL)\n+            size_t realloc_size = safe_add_size_t(message->body_amqp_data_count,\
    \ 1);\n+            realloc_size = safe_multiply_size_t(sizeof(BODY_AMQP_DATA),\
    \ realloc_size);\n+\n+            if (realloc_size == SIZE_MAX)\n            \
    \ {\n-                /* Codes_SRS_MESSAGE_01_153: [ If allocating memory to store\
    \ the added AMQP data fails, `message_add_body_amqp_data` shall fail and return\
    \ a non-zero value. ]*/\n-                LogError(\"Cannot allocate memory for\
    \ body AMQP data items\");\n+                LogError(\"Invalid size for new_body_amqp_data_items\"\
    );\n                 result = MU_FAILURE;\n             }\n             else\n\
    \             {\n-                message->body_amqp_data_items = new_body_amqp_data_items;\n\
    -\n-                if (amqp_data.length == 0)\n+                /* Codes_SRS_MESSAGE_01_086:\
    \ [ `message_add_body_amqp_data` shall add the contents of `amqp_data` to the\
    \ list of AMQP data values for the body of the message identified by `message`.\
    \ ]*/\n+                BODY_AMQP_DATA* new_body_amqp_data_items = (BODY_AMQP_DATA*)realloc(message->body_amqp_data_items,\
    \ realloc_size);\n+                if (new_body_amqp_data_items == NULL)\n   \
    \              {\n-                    message->body_amqp_data_items[message->body_amqp_data_count].body_data_section_bytes\
    \ = NULL;\n-                    message->body_amqp_data_items[message->body_amqp_data_count].body_data_section_length\
    \ = 0;\n-                    message->body_amqp_data_count++;\n-\n-          \
    \          /* Codes_SRS_MESSAGE_01_087: [ On success it shall return 0. ]*/\n\
    -                    result = 0;\n+                    /* Codes_SRS_MESSAGE_01_153:\
    \ [ If allocating memory to store the added AMQP data fails, `message_add_body_amqp_data`\
    \ shall fail and return a non-zero value. ]*/\n+                    LogError(\"\
    Cannot allocate memory for body AMQP data items\");\n+                    result\
    \ = MU_FAILURE;\n                 }\n                 else\n                 {\n\
    -                    message->body_amqp_data_items[message->body_amqp_data_count].body_data_section_bytes\
    \ = (unsigned char*)malloc(amqp_data.length);\n-                    if (message->body_amqp_data_items[message->body_amqp_data_count].body_data_section_bytes\
    \ == NULL)\n-                    {\n-                        /* Codes_SRS_MESSAGE_01_153:\
    \ [ If allocating memory to store the added AMQP data fails, `message_add_body_amqp_data`\
    \ shall fail and return a non-zero value. ]*/\n-                        LogError(\"\
    Cannot allocate memory for body AMQP data to be added\");\n-                 \
    \       result = MU_FAILURE;\n-                    }\n-                    else\n\
    +                    message->body_amqp_data_items = new_body_amqp_data_items;\n\
    +\n+                    if (amqp_data.length == 0)\n                     {\n-\
    \                        message->body_amqp_data_items[message->body_amqp_data_count].body_data_section_length\
    \ = amqp_data.length;\n-                        (void)memcpy(message->body_amqp_data_items[message->body_amqp_data_count].body_data_section_bytes,\
    \ amqp_data.bytes, amqp_data.length);\n+                        message->body_amqp_data_items[message->body_amqp_data_count].body_data_section_bytes\
    \ = NULL;\n+                        message->body_amqp_data_items[message->body_amqp_data_count].body_data_section_length\
    \ = 0;\n                         message->body_amqp_data_count++;\n \n       \
    \                  /* Codes_SRS_MESSAGE_01_087: [ On success it shall return 0.\
    \ ]*/\n                         result = 0;\n                     }\n+       \
    \             else\n+                    {\n+                        message->body_amqp_data_items[message->body_amqp_data_count].body_data_section_bytes\
    \ = (unsigned char*)malloc(amqp_data.length);\n+                        if (message->body_amqp_data_items[message->body_amqp_data_count].body_data_section_bytes\
    \ == NULL)\n+                        {\n+                            /* Codes_SRS_MESSAGE_01_153:\
    \ [ If allocating memory to store the added AMQP data fails, `message_add_body_amqp_data`\
    \ shall fail and return a non-zero value. ]*/\n+                            LogError(\"\
    Cannot allocate memory for body AMQP data to be added\");\n+                 \
    \           result = MU_FAILURE;\n+                        }\n+              \
    \          else\n+                        {\n+                            message->body_amqp_data_items[message->body_amqp_data_count].body_data_section_length\
    \ = amqp_data.length;\n+                            (void)memcpy(message->body_amqp_data_items[message->body_amqp_data_count].body_data_section_bytes,\
    \ amqp_data.bytes, amqp_data.length);\n+                            message->body_amqp_data_count++;\n\
    +\n+                            /* Codes_SRS_MESSAGE_01_087: [ On success it shall\
    \ return 0. ]*/\n+                            result = 0;\n+                 \
    \       }\n+                    }\n                 }\n             }\n      \
    \   }\n@@ -1250,33 +1284,45 @@ int message_add_body_amqp_sequence(MESSAGE_HANDLE\
    \ message, AMQP_VALUE sequence_l\n         }\n         else\n         {\n-   \
    \         AMQP_VALUE* new_body_amqp_sequence_items = (AMQP_VALUE*)realloc(message->body_amqp_sequence_items,\
    \ sizeof(AMQP_VALUE) * (message->body_amqp_sequence_count + 1));\n-          \
    \  if (new_body_amqp_sequence_items == NULL)\n+            size_t realloc_size\
    \ = safe_add_size_t(message->body_amqp_sequence_count, 1);\n+            realloc_size\
    \ = safe_multiply_size_t(sizeof(AMQP_VALUE), realloc_size);\n+\n+            if\
    \ (realloc_size == SIZE_MAX)\n             {\n-                /* Codes_SRS_MESSAGE_01_158:\
    \ [ If allocating memory in order to store the sequence fails, `message_add_body_amqp_sequence`\
    \ shall fail and return a non-zero value. ]*/\n-                LogError(\"Cannot\
    \ allocate enough memory for sequence items\");\n+                LogError(\"\
    Invalid size for new_body_amqp_sequence_items\");\n                 result = MU_FAILURE;\n\
    \             }\n             else\n             {\n-                message->body_amqp_sequence_items\
    \ = new_body_amqp_sequence_items;\n+                AMQP_VALUE* new_body_amqp_sequence_items\
    \ = (AMQP_VALUE*)realloc(message->body_amqp_sequence_items, realloc_size);\n \n\
    -                /* Codes_SRS_MESSAGE_01_110: [ `message_add_body_amqp_sequence`\
    \ shall add the contents of `sequence` to the list of AMQP sequences for the body\
    \ of the message identified by `message`. ]*/\n-                /* Codes_SRS_MESSAGE_01_156:\
    \ [ The AMQP sequence shall be cloned by calling `amqpvalue_clone`. ]*/\n-   \
    \             message->body_amqp_sequence_items[message->body_amqp_sequence_count]\
    \ = amqpvalue_clone(sequence_list);\n-                if (message->body_amqp_sequence_items[message->body_amqp_sequence_count]\
    \ == NULL)\n+                if (new_body_amqp_sequence_items == NULL)\n     \
    \            {\n-                    /* Codes_SRS_MESSAGE_01_157: [ If `amqpvalue_clone`\
    \ fails, `message_add_body_amqp_sequence` shall fail and return a non-zero value.\
    \ ]*/\n-                    LogError(\"Cloning sequence failed\");\n+        \
    \            /* Codes_SRS_MESSAGE_01_158: [ If allocating memory in order to store\
    \ the sequence fails, `message_add_body_amqp_sequence` shall fail and return a\
    \ non-zero value. ]*/\n+                    LogError(\"Cannot allocate enough\
    \ memory for sequence items\");\n                     result = MU_FAILURE;\n \
    \                }\n                 else\n                 {\n-             \
    \       /* Codes_SRS_MESSAGE_01_114: [ If adding the AMQP sequence fails, the\
    \ previous value shall be preserved. ]*/\n-                    message->body_amqp_sequence_count++;\n\
    +                    message->body_amqp_sequence_items = new_body_amqp_sequence_items;\n\
    \ \n-                    /* Codes_SRS_MESSAGE_01_111: [ On success it shall return\
    \ 0. ]*/\n-                    result = 0;\n+                    /* Codes_SRS_MESSAGE_01_110:\
    \ [ `message_add_body_amqp_sequence` shall add the contents of `sequence` to the\
    \ list of AMQP sequences for the body of the message identified by `message`.\
    \ ]*/\n+                    /* Codes_SRS_MESSAGE_01_156: [ The AMQP sequence shall\
    \ be cloned by calling `amqpvalue_clone`. ]*/\n+                    message->body_amqp_sequence_items[message->body_amqp_sequence_count]\
    \ = amqpvalue_clone(sequence_list);\n+                    if (message->body_amqp_sequence_items[message->body_amqp_sequence_count]\
    \ == NULL)\n+                    {\n+                        /* Codes_SRS_MESSAGE_01_157:\
    \ [ If `amqpvalue_clone` fails, `message_add_body_amqp_sequence` shall fail and\
    \ return a non-zero value. ]*/\n+                        LogError(\"Cloning sequence\
    \ failed\");\n+                        result = MU_FAILURE;\n+               \
    \     }\n+                    else\n+                    {\n+                \
    \        /* Codes_SRS_MESSAGE_01_114: [ If adding the AMQP sequence fails, the\
    \ previous value shall be preserved. ]*/\n+                        message->body_amqp_sequence_count++;\n\
    +\n+                        /* Codes_SRS_MESSAGE_01_111: [ On success it shall\
    \ return 0. ]*/\n+                        result = 0;\n+                    }\n\
    \                 }\n             }\n         }"
  identifiers: CVE:["CVE-2024-25110"],CWE:["CWE-94"]
  overview: Affected versions of this package are vulnerable to Improper Control of
    Generation of Code ('Code Injection') during a call to `open_get_offered_capabilities`.
    A memory allocation may fail causing a use-after-free issue and if a client called
    it during connection communication it may cause unintended code execution by manipulating
    the memory after it has been freed.
  references:
    GitHub Commit: https://github.com/Azure/azure-uamqp-c/commit/30865c9ccedaa32ddb036e87a8ebb52c3f18f695
  title: Improper Control of Generation of Code ('Code Injection')
- diff_content:
  - "--- a/library/rsa.c\n+++ b/library/rsa.c\n@@ -34,6 +34,7 @@\n #include \"mbedtls/error.h\"\
    \n #include \"constant_time_internal.h\"\n #include \"mbedtls/constant_time.h\"\
    \n+#include \"bignum_internal.h\"\n \n #include <string.h>\n \n@@ -804,6 +805,47\
    \ @@ static int rsa_prepare_blinding(mbedtls_rsa_context *ctx,\n     return ret;\n\
    \ }\n \n+/*\n+ * Unblind\n+ * T = T * Vf mod N\n+ */\n+static int rsa_unblind(mbedtls_mpi\
    \ *T, mbedtls_mpi *Vf, const mbedtls_mpi *N)\n+{\n+    int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;\n\
    +    const size_t nlimbs = N->n;\n+    const size_t tlimbs = 2 * (nlimbs + 1);\n\
    +\n+    mbedtls_mpi_uint mm;\n+    mbedtls_mpi_montg_init(&mm, N);\n+\n+    mbedtls_mpi\
    \ RR, M_T;\n+\n+    mbedtls_mpi_init(&RR);\n+    mbedtls_mpi_init(&M_T);\n+\n\
    +    MBEDTLS_MPI_CHK(mbedtls_mpi_get_mont_r2_unsafe(&RR, N));\n+    MBEDTLS_MPI_CHK(mbedtls_mpi_grow(&M_T,\
    \ tlimbs));\n+\n+    MBEDTLS_MPI_CHK(mbedtls_mpi_grow(T, nlimbs));\n+    MBEDTLS_MPI_CHK(mbedtls_mpi_grow(Vf,\
    \ nlimbs));\n+\n+    /* T = T * Vf mod N\n+     * Reminder: montmul(A, B, N) =\
    \ A * B * R^-1 mod N\n+     * Usually both operands are multiplied by R mod N\
    \ beforehand, yielding a\n+     * result that's also * R mod N (aka \"in the Montgomery\
    \ domain\"). Here we\n+     * only multiply one operand by R mod N, so the result\
    \ is directly what we\n+     * want - no need to call `mpi_montred()` on it. */\n\
    +    mbedtls_mpi_montmul(T, &RR, N, mm, &M_T);\n+    mbedtls_mpi_montmul(T, Vf,\
    \ N, mm, &M_T);\n+\n+cleanup:\n+\n+    mbedtls_mpi_free(&RR);\n+    mbedtls_mpi_free(&M_T);\n\
    +\n+    return ret;\n+}\n+\n /*\n  * Exponent blinding supposed to prevent side-channel\
    \ attacks using multiple\n  * traces of measurements to recover the RSA key. The\
    \ more collisions are there,\n@@ -1000,8 +1042,7 @@ int mbedtls_rsa_private(mbedtls_rsa_context\
    \ *ctx,\n          * Unblind\n          * T = T * Vf mod N\n          */\n-  \
    \      MBEDTLS_MPI_CHK(mbedtls_mpi_mul_mpi(&T, &T, &ctx->Vf));\n-        MBEDTLS_MPI_CHK(mbedtls_mpi_mod_mpi(&T,\
    \ &T, &ctx->N));\n+        MBEDTLS_MPI_CHK(rsa_unblind(&T, &ctx->Vf, &ctx->N));\n\
    \     }\n \n     /* Verify the result to prevent glitching attacks. */"
  identifiers: CVE:["CVE-2024-23170"],CWE:["CWE-203"]
  overview: 'Affected versions of this package are vulnerable to Observable Timing
    Discrepancy during in RSA private operations. An attacker can recover the plaintext
    by sending a large number of messages for decryption, as described in the "Everlasting
    ROBOT: the Marvin Attack" by Hubert Kario.'
  references:
    GitHub Commit: https://github.com/Mbed-TLS/mbedtls/commit/aa6760d7b5d9a218eaf072f4155974f58b00986b
    Vulnerability Advisory: https://mbed-tls.readthedocs.io/en/latest/security-advisories/mbedtls-security-advisory-2024-01-1/
    Vulnerability Report: https://people.redhat.com/~hkario/marvin/
  title: Observable Timing Discrepancy
- diff_content:
  - "--- a/library/x509_create.c\n+++ b/library/x509_create.c\n@@ -195,6 +195,10 @@\
    \ int mbedtls_x509_set_extension(mbedtls_asn1_named_data **head, const char *oid,\n\
    \ {\n     mbedtls_asn1_named_data *cur;\n \n+    if (val_len > (SIZE_MAX  - 1))\
    \ {\n+        return MBEDTLS_ERR_X509_BAD_INPUT_DATA;\n+    }\n+\n     if ((cur\
    \ = mbedtls_asn1_store_named_data(head, oid, oid_len,\n                      \
    \                        NULL, val_len + 1)) == NULL) {\n         return MBEDTLS_ERR_X509_ALLOC_FAILED;"
  identifiers: CVE:["CVE-2024-23775"],CWE:["CWE-122"]
  overview: Affected versions of this package are vulnerable to Heap-based Buffer
    Overflow via the `mbedtls_x509_set_extension` function. An attacker can cause
    a segfault by sending crafted input to trigger an integer overflow.
  references:
    GitHub Commit: https://github.com/Mbed-TLS/mbedtls/commit/e90cbc3d1260901efc879178a15f2d90a5e17612
    Vulnerability Advisory: https://mbed-tls.readthedocs.io/en/latest/security-advisories/mbedtls-security-advisory-2024-01-2/
  title: Heap-based Buffer Overflow
- diff_content:
  - "--- a/picoquic/frames.c\n+++ b/picoquic/frames.c\n@@ -501,7 +501,11 @@ protoop_arg_t\
    \ parse_new_connection_id_frame(picoquic_cnx_t* cnx)\n         return (protoop_arg_t)\
    \ NULL;\n     }\n \n-    if ((bytes = picoquic_frames_varint_decode(bytes + picoquic_varint_skip(bytes),\
    \ bytes_max, &frame->sequence)) == NULL ||\n+    if (cnx->active_connection_id_count\
    \ >= cnx->local_parameters.active_connection_id_limit) {\n+        picoquic_connection_error(cnx,\
    \ PICOQUIC_TRANSPORT_CONNECTION_ID_LIMIT_ERROR, picoquic_frame_type_new_connection_id);\n\
    +        picoquic_reinsert_by_wake_time(cnx->quic, cnx, picoquic_current_time());\n\
    +        return (protoop_arg_t) NULL;\n+    } else if ((bytes = picoquic_frames_varint_decode(bytes\
    \ + picoquic_varint_skip(bytes), bytes_max, &frame->sequence)) == NULL ||\n  \
    \       (bytes = picoquic_frames_varint_decode(bytes, bytes_max, &frame->retire_prior_to))\
    \ == NULL ||\n         (bytes = picoquic_frames_uint8_decode(bytes, bytes_max,\
    \ &frame->connection_id.id_len)) == NULL ||\n         (frame->connection_id.id_len\
    \ > PICOQUIC_CONNECTION_ID_MAX_SIZE) ||\n@@ -520,6 +524,7 @@ protoop_arg_t parse_new_connection_id_frame(picoquic_cnx_t*\
    \ cnx)\n         bytes += frame->connection_id.id_len;\n         memcpy(&frame->stateless_reset_token,\
    \ bytes, 16);\n         bytes += 16;\n+        cnx->active_connection_id_count++;\n\
    \     }\n \n     protoop_save_outputs(cnx, frame, ack_needed, is_retransmittable);"
  - "--- a/picoquic/packet.c\n+++ b/picoquic/packet.c\n@@ -485,11 +485,13 @@ int picoquic_parse_header_and_decrypt(\n\
    \                 /* Packet is not encrypted */\n                 break;\n   \
    \          case picoquic_packet_initial:\n-                decoded_length = picoquic_decrypt_packet(*pcnx,\
    \ bytes, packet_length, ph,\n-                    (*pcnx)->crypto_context[0].hp_dec,\n\
    -                    (*pcnx)->crypto_context[0].aead_decrypt, &already_received,\
    \ path_from);\n-                length = ph->offset + ph->payload_length;\n- \
    \               *consumed = length;\n+                if((*pcnx)->crypto_context[0].aead_decrypt\
    \ != NULL){\n+                    decoded_length = picoquic_decrypt_packet(*pcnx,\
    \ bytes, packet_length, ph,\n+                        (*pcnx)->crypto_context[0].hp_dec,\n\
    +                        (*pcnx)->crypto_context[0].aead_decrypt, &already_received,\
    \ path_from);\n+                    length = ph->offset + ph->payload_length;\n\
    +                    *consumed = length;\n+                }\n               \
    \  break;\n             case picoquic_packet_retry:\n                 /* packet\
    \ is not encrypted, no sequence number. */\n@@ -1345,7 +1347,10 @@ int picoquic_incoming_segment(\n\
    \                     if (ret == 0) {\n                         if (cnx->client_mode\
    \ == 0) {\n                             /* TODO: finish processing initial connection\
    \ packet */\n-                            cnx->local_parameters.original_destination_connection_id\
    \ = ph.dest_cnx_id;\n+                            if(cnx->local_parameters.original_destination_connection_id.id_len\
    \ == 0){\n+                                cnx->local_parameters.original_destination_connection_id\
    \ = ph.dest_cnx_id;\n+                            }\n+\n                     \
    \        ret = picoquic_incoming_initial(&cnx, bytes,\n                      \
    \           addr_from, addr_to, if_index_to, &ph, current_time, *new_context_created);\n\
    \                         }\n@@ -1372,6 +1377,12 @@ int picoquic_incoming_segment(\n\
    \                 else\n                 {\n                     ret = picoquic_incoming_client_cleartext(cnx,\
    \ bytes, &ph, current_time);\n+                    \n+                    if (ret\
    \ == 0 && cnx->crypto_context[2].aead_decrypt != NULL && cnx->crypto_context[2].aead_encrypt\
    \ != NULL)\n+                    {\n+                        picoquic_implicit_handshake_ack(cnx,\
    \ cnx->path[0], picoquic_packet_context_initial, current_time);\n+           \
    \             picoquic_crypto_context_free(&cnx->crypto_context[0]);\n+      \
    \              }\n                 }\n                 break;\n             case\
    \ picoquic_packet_0rtt_protected:"
  - "--- a/picoquic/quicctx.c\n+++ b/picoquic/quicctx.c\n@@ -1352,6 +1352,7 @@ picoquic_cnx_t*\
    \ picoquic_create_cnx(picoquic_quic_t* quic,\n             cnx->cnx_state = picoquic_state_server_init;\n\
    \             cnx->initial_cnxid = initial_cnx_id;\n             cnx->path[0]->remote_cnxid\
    \ = remote_cnx_id;\n+            cnx->active_connection_id_count = 1;\n \n   \
    \          if (quic->cnx_id_callback_fn)\n                 quic->cnx_id_callback_fn(cnx->path[0]->local_cnxid,\
    \ cnx->initial_cnxid,"
  - "--- a/picoquic/sender.c\n+++ b/picoquic/sender.c\n@@ -575,10 +575,12 @@ protoop_arg_t\
    \ get_checksum_length(picoquic_cnx_t *cnx)\n     int is_cleartext_mode = (int)\
    \ cnx->protoop_inputv[0];\n     uint32_t ret = 16;\n \n-    if (is_cleartext_mode\
    \ || cnx->crypto_context[2].aead_encrypt == NULL) {\n+    if (is_cleartext_mode\
    \ && cnx->crypto_context[2].aead_encrypt == NULL && cnx->crypto_context[0].aead_encrypt\
    \ != NULL) {\n         ret = picoquic_aead_get_checksum_length(cnx->crypto_context[0].aead_encrypt);\n\
    -    } else {\n+    } else if (cnx->crypto_context[2].aead_encrypt != NULL) {\n\
    \         ret = picoquic_aead_get_checksum_length(cnx->crypto_context[2].aead_encrypt);\n\
    +    } else if(cnx->crypto_context[3].aead_encrypt != NULL) {\n+        ret =\
    \ picoquic_aead_get_checksum_length(cnx->crypto_context[3].aead_encrypt);\n  \
    \   }\n \n     return (protoop_arg_t) ret;\n@@ -608,7 +610,13 @@ uint32_t picoquic_protect_packet(picoquic_cnx_t*\
    \ cnx,\n     uint32_t pn_offset = 0;\n     size_t sample_offset = 0;\n     uint32_t\
    \ pn_length = 0;\n-    uint32_t aead_checksum_length = (uint32_t)picoquic_aead_get_checksum_length(aead_context);\n\
    +    uint32_t aead_checksum_length;\n+    \n+    if(aead_context != NULL){\n+\
    \        aead_checksum_length = (uint32_t)picoquic_aead_get_checksum_length(aead_context);\n\
    +    }else{\n+        return 0;\n+    }\n \n     /* Create the packet header just\
    \ before encrypting the content */\n     h_length = picoquic_create_packet_header(cnx,\
    \ ptype, path_x,\n@@ -962,7 +970,7 @@ void picoquic_implicit_handshake_ack(picoquic_cnx_t*\
    \ cnx, picoquic_path_t *path,\n \n     /* Remove packets from the retransmit queue\
    \ */\n     while (p != NULL) {\n-        picoquic_packet_t* p_next = p->next_packet;\n\
    +        picoquic_packet_t* p_next = p->previous_packet;\n         picoquic_path_t\
    \ * old_path = p->send_path;\n \n         /* Update the congestion control state\
    \ for the path */\n@@ -2546,7 +2554,7 @@ int picoquic_prepare_packet_server_init(picoquic_cnx_t*\
    \ cnx, picoquic_path_t **\n \n     /* If context is handshake, verify first that\
    \ there is no need for retransmit or ack\n     * on initial context */\n-    if\
    \ (ret == 0 && pc == picoquic_packet_context_handshake) {\n+    if (ret == 0 &&\
    \ pc == picoquic_packet_context_handshake && cnx->crypto_context[0].aead_encrypt\
    \ != NULL) {\n         length = picoquic_prepare_packet_old_context(cnx, picoquic_packet_context_initial,\n\
    \             path_x, packet, send_buffer_max, current_time, &header_length);\n\
    \     }\n@@ -3171,6 +3179,7 @@ protoop_arg_t schedule_frames_on_path(picoquic_cnx_t\
    \ *cnx)\n                                 length += (uint32_t) data_bytes;\n \
    \                                packet->has_handshake_done = 1;\n           \
    \                      packet->is_pure_ack = 0;\n+                           \
    \     picoquic_crypto_context_free(&cnx->crypto_context[2]);\n               \
    \              }\n                         }\n "
  identifiers: CVE:["CVE-2024-25679"],CWE:["CWE-323"]
  overview: Affected versions of this package are vulnerable to Reusing a Nonce, Key
    Pair in Encryption. An attacker can disrupt a connection with a PSK configuration
    by sending a `CONNECTION_CLOSE` frame that is encrypted via the initial key computed.
    Network traffic sniffing is required as part of exploitation.
  references:
    GitHub Commit: https://github.com/p-quic/pquic/commit/5bde5bb5534ae3fc233547b2db88f418fceff170
    GitHub Issue: https://github.com/p-quic/pquic/issues/35
    GitHub PR: https://github.com/p-quic/pquic/pull/39
  title: Reusing a Nonce, Key Pair in Encryption
- diff_content:
  - "--- a/src/liblsquic/lsquic_full_conn_ietf.c\n+++ b/src/liblsquic/lsquic_full_conn_ietf.c\n\
    @@ -7283,7 +7283,8 @@ on_dcid_change (struct ietf_full_conn *conn, const lsquic_cid_t\
    \ *dcid_in)\n     struct lsquic_conn *const lconn = &conn->ifc_conn;  /* Shorthand\
    \ */\n     struct conn_cid_elem *cce;\n \n-    LSQ_DEBUG(\"peer switched its DCID,\
    \ attempt to switch own SCID\");\n+    LSQ_DEBUGC(\"peer switched its DCID to\
    \ %\"CID_FMT\n+              \", attempt to switch own SCID\", CID_BITS(dcid_in));\n\
    \ \n     for (cce = lconn->cn_cces; cce < END_OF_CCES(lconn); ++cce)\n       \
    \  if (cce - lconn->cn_cces != lconn->cn_cur_cce_idx\n@@ -7545,7 +7546,9 @@ process_regular_packet\
    \ (struct ietf_full_conn *conn,\n                                            \
    \         << packet_in->pi_path_id);\n                 }\n             }\n-  \
    \          else if (is_dcid_changed)\n+            else if (is_dcid_changed\n\
    +                && !LSQUIC_CIDS_EQ(CN_SCID(&conn->ifc_conn),\n+             \
    \                      &packet_in->pi_dcid))\n             {\n               \
    \  if (0 != on_dcid_change(conn, &packet_in->pi_dcid))\n                     return\
    \ -1;"
  identifiers: CVE:["CVE-2024-25678"],CWE:["CWE-20"]
  overview: Affected versions of this package are vulnerable to Improper Input Validation.
    An attacker can exploit this vulnerability by sending specially crafted packets
    to bypass security restrictions due to mishandling of DCID validation.
  references:
    GitHub Commit: https://github.com/litespeedtech/lsquic/commit/515f453556c99d27c4dddb5424898dc1a5537708
    GitHub Release: https://github.com/litespeedtech/lsquic/releases/tag/v4.0.4
  title: Improper Input Validation
- diff_content:
  - "--- a/drivers/md/dm-ioctl.c\n+++ b/drivers/md/dm-ioctl.c\n@@ -1941,7 +1941,8\
    \ @@ static int copy_params(struct dm_ioctl __user *user, struct dm_ioctl *param_kern\n\
    \ \t\t\t   minimum_data_size - sizeof(param_kernel->version)))\n \t\treturn -EFAULT;\n\
    \ \n-\tif (param_kernel->data_size < minimum_data_size) {\n+\tif (unlikely(param_kernel->data_size\
    \ < minimum_data_size) ||\n+\t    unlikely(param_kernel->data_size > DM_MAX_TARGETS\
    \ * DM_MAX_TARGET_PARAMS)) {\n \t\tDMERR(\"Invalid data size in the ioctl structure:\
    \ %u\",\n \t\t      param_kernel->data_size);\n \t\treturn -EINVAL;"
  - "--- a/drivers/md/dm-table.c\n+++ b/drivers/md/dm-table.c\n@@ -129,7 +129,12 @@\
    \ static int alloc_targets(struct dm_table *t, unsigned int num)\n int dm_table_create(struct\
    \ dm_table **result, blk_mode_t mode,\n \t\t    unsigned int num_targets, struct\
    \ mapped_device *md)\n {\n-\tstruct dm_table *t = kzalloc(sizeof(*t), GFP_KERNEL);\n\
    +\tstruct dm_table *t;\n+\n+\tif (num_targets > DM_MAX_TARGETS)\n+\t\treturn -EOVERFLOW;\n\
    +\n+\tt = kzalloc(sizeof(*t), GFP_KERNEL);\n \n \tif (!t)\n \t\treturn -ENOMEM;\n\
    @@ -144,7 +149,7 @@ int dm_table_create(struct dm_table **result, blk_mode_t mode,\n\
    \ \n \tif (!num_targets) {\n \t\tkfree(t);\n-\t\treturn -ENOMEM;\n+\t\treturn\
    \ -EOVERFLOW;\n \t}\n \n \tif (alloc_targets(t, num_targets)) {"
  identifiers: CVE:["CVE-2023-52429"],CWE:["CWE-400"]
  overview: Affected versions of this package are vulnerable to Denial of Service
    (DoS) due to an improper validation in the `dm_table_create` function within the
    `drivers/md/dm-table.c` file. An attacker can cause the system to crash by attempting
    to allocate more than `INT_MAX` bytes.
  references:
    GitHub Commit: https://github.com/torvalds/linux/commit/bd504bcfec41a503b32054da5472904b404341a4
    Report: https://www.spinics.net/lists/dm-devel/msg56625.html
    commons-fileupload:commons-fileupload: SNYK-JAVA-COMMONSFILEUPLOAD-30082
    npm <code>ws</code> package: https://snyk.io/vuln/npm:ws:20171108
  title: Denial of Service (DoS)
- diff_content:
  - "--- a/arch/x86/coco/tdx/tdx.c\n+++ b/arch/x86/coco/tdx/tdx.c\n@@ -10,6 +10,7\
    \ @@\n #include <asm/coco.h>\n #include <asm/tdx.h>\n #include <asm/vmx.h>\n+#include\
    \ <asm/ia32.h>\n #include <asm/insn.h>\n #include <asm/insn-eval.h>\n #include\
    \ <asm/pgtable.h>\n@@ -891,5 +892,14 @@ void __init tdx_early_init(void)\n \t\
    \ */\n \tx86_cpuinit.parallel_bringup = false;\n \n+\t/*\n+\t * The VMM is capable\
    \ of injecting interrupt 0x80 and triggering the\n+\t * compatibility syscall\
    \ path.\n+\t *\n+\t * By default, the 32-bit emulation is disabled in order to\
    \ ensure\n+\t * the safety of the VM.\n+\t */\n+\tia32_disable();\n+\n \tpr_info(\"\
    Guest detected\\n\");\n }"
  - "--- a/arch/x86/mm/mem_encrypt_amd.c\n+++ b/arch/x86/mm/mem_encrypt_amd.c\n@@\
    \ -32,6 +32,7 @@\n #include <asm/msr.h>\n #include <asm/cmdline.h>\n #include\
    \ <asm/sev.h>\n+#include <asm/ia32.h>\n \n #include \"mm_internal.h\"\n \n@@ -481,6\
    \ +482,16 @@ void __init sme_early_init(void)\n \t */\n \tif (sev_status & MSR_AMD64_SEV_ES_ENABLED)\n\
    \ \t\tx86_cpuinit.parallel_bringup = false;\n+\n+\t/*\n+\t * The VMM is capable\
    \ of injecting interrupt 0x80 and triggering the\n+\t * compatibility syscall\
    \ path.\n+\t *\n+\t * By default, the 32-bit emulation is disabled in order to\
    \ ensure\n+\t * the safety of the VM.\n+\t */\n+\tif (sev_status & MSR_AMD64_SEV_ENABLED)\n\
    +\t\tia32_disable();\n }\n \n void __init mem_encrypt_free_decrypted_mem(void)"
  identifiers: CVE:["CVE-2024-25744"],CWE:["CWE-119"]
  overview: 'Affected versions of this package are vulnerable to Improper Control
    of a Resource Through its Lifetime due to improper syscall handling in specific
    kernel components. An attacker with control over the Virtual Machine Monitor (VMM)
    can manipulate the execution flow at any point, leading to potential system compromise
    or information disclosure. '
  references:
    GitHub Commit: https://github.com/torvalds/linux/commit/b82a8dbd3d2f4563156f7150c6f2ecab6e960b30
  title: Improper Control of a Resource Through its Lifetime
- diff_content:
  - "--- a/src/libgit2/revparse.c\n+++ b/src/libgit2/revparse.c\n@@ -701,6 +701,7\
    \ @@ static int revparse(\n \tgit_object *base_rev = NULL;\n \n \tbool should_return_reference\
    \ = true;\n+\tbool parsed = false;\n \n \tGIT_ASSERT_ARG(object_out);\n \tGIT_ASSERT_ARG(reference_out);\n\
    @@ -710,7 +711,7 @@ static int revparse(\n \t*object_out = NULL;\n \t*reference_out\
    \ = NULL;\n \n-\twhile (spec[pos]) {\n+\twhile (!parsed && spec[pos]) {\n \t\t\
    switch (spec[pos]) {\n \t\tcase '^':\n \t\t\tshould_return_reference = false;\n\
    @@ -817,6 +818,8 @@ static int revparse(\n \t\t\t\tbreak;\n \t\t\t} else if (spec[pos+1]\
    \ == '\\0') {\n \t\t\t\tspec = \"HEAD\";\n+\t\t\t\tidentifier_len = 4;\n+\t\t\t\
    \tparsed = true;\n \t\t\t\tbreak;\n \t\t\t}\n \t\t\t/* fall through */"
  identifiers: CVE:["CVE-2024-24575"],CWE:["CWE-835"]
  overview: Affected versions of this package are vulnerable to Infinite Loop in the
    `git_revparse_single` function in `src/libgit2/revparse.c`. An attacker can cause
    the function to enter an infinite loop. The `revparse` function uses a loop to
    parse the user-provided spec string, and there is an edge-case during parsing
    that allows a bad actor to force the loop conditions to access arbitrary memory.
    Potentially, this could also leak memory if the extracted rev spec is reflected
    back to the attacker.
  references:
    GitHub Commit: https://github.com/libgit2/libgit2/commit/c9d31b711e8906cf248566f43142f20b03e20cbf
    GitHub Release: https://github.com/libgit2/libgit2/releases/tag/v1.7.2
    Github Commit: https://github.com/rust-lang/git2-rs/commit/9e57876be78924c1e5f3f268bb599e3981fe58bb
    RedHat Bugzilla Bug: https://bugzilla.redhat.com/show_bug.cgi?id=2263092
  title: Infinite Loop
- diff_content:
  - "--- a/src/libgit2/index.c\n+++ b/src/libgit2/index.c\n@@ -1148,10 +1148,13 @@\
    \ static int has_dir_name(git_index *index,\n \t\tsize_t len, pos;\n \n \t\tfor\
    \ (;;) {\n-\t\t\tif (*--slash == '/')\n-\t\t\t\tbreak;\n+\t\t\tslash--;\n+\n \t\
    \t\tif (slash <= entry->path)\n \t\t\t\treturn 0;\n+\n+\t\t\tif (*slash == '/')\n\
    +\t\t\t\tbreak;\n \t\t}\n \t\tlen = slash - name;\n "
  identifiers: CVE:["CVE-2024-24577"],CWE:["CWE-122"]
  overview: Affected versions of this package are vulnerable to Heap-based Buffer
    Overflow via the `has_dir_name` function in `src/libgit2/index.c`. An attacker
    can cause heap corruption that could be leveraged for arbitrary code execution
    by triggering two consecutive calls to `git_index_add` with a filename that starts
    with a `/` character. This is only exploitable if the bad actor is able to  control
    the `ctime` field of the `git_index_entry` data structure.
  references:
    CVE-2024-25817: https://www.cubeyond.net/blog/my-cves/eza-cve-report
    GitHub Commit: https://github.com/libgit2/libgit2/commit/eb4c1716cd92bf56f2770653a915d5fc01eab8f3
    GitHub Release: https://github.com/libgit2/libgit2/releases/tag/v1.7.2
    Github Advisory: https://github.com/advisories/GHSA-3qx3-6hxr-j2ch
    Github Commit: https://github.com/rust-lang/git2-rs/commit/9e57876be78924c1e5f3f268bb599e3981fe58bb
    RedHat Bugzilla Bug: https://bugzilla.redhat.com/show_bug.cgi?id=2263095
    Vulnerability Advisory: https://www.cubeyond.net/blog/my-cves/eza-cve-report
  title: Heap-based Buffer Overflow
- diff_content:
  - "--- a/src/brpc/details/http_message.cpp\n+++ b/src/brpc/details/http_message.cpp\n\
    @@ -33,6 +33,8 @@\n \n namespace brpc {\n \n+DEFINE_bool(allow_chunked_length,\
    \ false,\n+            \"Allow both Transfer-Encoding and Content-Length headers\
    \ are present.\");\n DEFINE_bool(http_verbose, false,\n             \"[DEBUG]\
    \ Print EVERY http request/response\");\n DEFINE_int32(http_verbose_max_body_length,\
    \ 512,\n@@ -172,6 +174,28 @@ int HttpMessage::on_headers_complete(http_parser\
    \ *parser) {\n         }\n     }\n \n+    // https://datatracker.ietf.org/doc/html/rfc7230#section-3.3.3\n\
    +    // If a message is received with both a Transfer-Encoding and a\n+    //\
    \ Content-Length header field, the Transfer-Encoding overrides the\n+    // Content-Length.\
    \ Such a message might indicate an attempt to\n+    // perform request smuggling\
    \ (Section 9.5) or response splitting\n+    // (Section 9.4) and ought to be handled\
    \ as an error. A sender MUST\n+    // remove the received Content-Length field\
    \ prior to forwarding such\n+    // a message.\n+\n+    // Reject message if both\
    \ Transfer-Encoding and Content-Length headers\n+    // are present or if allowed\
    \ by gflag and 'Transfer-Encoding'\n+    // is chunked - remove Content-Length\
    \ and serve request.\n+    if (parser->uses_transfer_encoding && parser->flags\
    \ & F_CONTENTLENGTH) {\n+        if (parser->flags & F_CHUNKED && FLAGS_allow_chunked_length)\
    \ {\n+            http_message->header().RemoveHeader(\"Content-Length\");\n+\
    \        } else {\n+            LOG(ERROR) << \"HTTP/1.1 protocol error: both\
    \ Content-Length \"\n+                       << \"and Transfer-Encoding are set.\"\
    ;\n+            return -1;\n+        }\n+    }\n+\n     // If server receives\
    \ a response to a HEAD request, returns 1 and then\n     // the parser will interpret\
    \ that as saying that this message has no body.\n     if (parser->type == HTTP_RESPONSE\
    \ &&\n@@ -401,6 +425,7 @@ HttpMessage::HttpMessage(bool read_body_progressively,\n\
    \     , _cur_value(NULL)\n     , _vbodylen(0) {\n     http_parser_init(&_parser,\
    \ HTTP_BOTH);\n+    _parser.allow_chunked_length = 1;\n     _parser.data = this;\n\
    \ }\n \n@@ -489,6 +514,9 @@ static void DescribeHttpParserFlags(std::ostream&\
    \ os, unsigned int flags) {\n     if (flags & F_SKIPBODY) {\n         os << \"\
    F_SKIPBODY|\";\n     }\n+    if (flags & F_CONTENTLENGTH) {\n+        os << \"\
    F_CONTENTLENGTH|\";\n+    }\n }\n \n std::ostream& operator<<(std::ostream& os,\
    \ const http_parser& parser) {\n@@ -548,7 +576,13 @@ void MakeRawHttpRequest(butil::IOBuf*\
    \ request,\n        << h->minor_version() << BRPC_CRLF;\n     // Never use \"\
    Content-Length\" set by user.\n     h->RemoveHeader(\"Content-Length\");\n-  \
    \  if (h->method() != HTTP_METHOD_GET) {\n+    const std::string* transfer_encoding\
    \ = h->GetHeader(\"Transfer-Encoding\");\n+    if (h->method() == HTTP_METHOD_GET)\
    \ {\n+        h->RemoveHeader(\"Transfer-Encoding\");\n+    } else if (!transfer_encoding)\
    \ {\n+        // https://datatracker.ietf.org/doc/html/rfc7230#section-3.3.2\n\
    +        // A sender MUST NOT send a Content-Length header field in any message\n\
    +        // that contains a Transfer-Encoding header field.\n         os << \"\
    Content-Length: \" << (content ? content->length() : 0)\n            << BRPC_CRLF;\n\
    \     }\n@@ -638,25 +672,36 @@ void MakeRawHttpResponse(butil::IOBuf* response,\n\
    \         // A server MUST NOT send a Content-Length header field in any response\n\
    \         // with a status code of 1xx (Informational) or 204 (No Content).\n\
    \         h->RemoveHeader(\"Content-Length\");\n-    } else if (content) {\n-\
    \        const std::string* content_length = h->GetHeader(\"Content-Length\");\n\
    -        if (is_head_req) {\n-            // Prioritize \"Content-Length\" set\
    \ by user.\n-            // If \"Content-Length\" is not set, set it to the length\
    \ of content.\n-            if (!content_length) {\n-                os << \"\
    Content-Length: \" << content->length() << BRPC_CRLF;\n-            }\n-     \
    \   } else {\n-            if (content_length) {\n-                h->RemoveHeader(\"\
    Content-Length\");\n+    } else {\n+        const std::string* transfer_encoding\
    \ = h->GetHeader(\"Transfer-Encoding\");\n+        // https://datatracker.ietf.org/doc/html/rfc7230#section-3.3.2\n\
    +        // A sender MUST NOT send a Content-Length header field in any message\n\
    +        // that contains a Transfer-Encoding header field.\n+        if (transfer_encoding)\
    \ {\n+            h->RemoveHeader(\"Content-Length\");\n+        }\n+        if\
    \ (content) {\n+            const std::string* content_length = h->GetHeader(\"\
    Content-Length\");\n+            if (is_head_req) {\n+                if (!content_length\
    \ && !transfer_encoding) {\n+                    // Prioritize \"Content-Length\"\
    \ set by user.\n+                    // If \"Content-Length\" is not set, set\
    \ it to the length of content.\n+                    os << \"Content-Length: \"\
    \ << content->length() << BRPC_CRLF;\n+                }\n+            } else\
    \ {\n+                if (!transfer_encoding) {\n+                    if (content_length)\
    \ {\n+                        h->RemoveHeader(\"Content-Length\");\n+        \
    \            }\n+                    // Never use \"Content-Length\" set by user.\n\
    +                    // Always set Content-Length since lighttpd requires the\
    \ header to be\n+                    // set to 0 for empty content.\n+       \
    \             os << \"Content-Length: \" << content->length() << BRPC_CRLF;\n\
    +                }\n             }\n-            // Never use \"Content-Length\"\
    \ set by user.\n-            // Always set Content-Length since lighttpd requires\
    \ the header to be\n-            // set to 0 for empty content.\n-           \
    \ os << \"Content-Length: \" << content->length() << BRPC_CRLF;\n         }\n\
    \     }\n-    if (!h->content_type().empty()) {\n+    if (!is_invalid_content\
    \ && !h->content_type().empty()) {\n         os << \"Content-Type: \" << h->content_type()\n\
    \            << BRPC_CRLF;\n     }"
  - "--- a/src/brpc/details/http_parser.cpp\n+++ b/src/brpc/details/http_parser.cpp\n\
    @@ -410,7 +410,10 @@ enum header_states\n   , h_transfer_encoding\n   , h_upgrade\n\
    \ \n+  , h_matching_transfer_encoding_token_start\n   , h_matching_transfer_encoding_chunked\n\
    +  , h_matching_transfer_encoding_token\n+\n   , h_matching_connection_keep_alive\n\
    \   , h_matching_connection_close\n \n@@ -499,6 +502,12 @@ bool is_url_char(char\
    \ c) { return IS_URL_CHAR(c); }\n \n #define start_state (parser->type == HTTP_REQUEST\
    \ ? s_start_req : s_start_res)\n \n+/**\n+ * Verify that a char is a valid visible\
    \ (printable) US-ASCII\n+ * character or %x80-FF\n+ **/\n+#define IS_HEADER_CHAR(ch)\
    \                                                     \\\n+  (ch == CR || ch ==\
    \ LF || ch == 9 || ((unsigned char)ch > 31 && ch != 127))\n \n #if BRPC_HTTP_PARSER_STRICT\n\
    \ # define STRICT_CHECK(cond)                                          \\\n@@\
    \ -691,6 +700,8 @@ size_t http_parser_execute (http_parser *parser,\n   const\
    \ char *url_mark = 0;\n   const char *body_mark = 0;\n   const char *status_mark\
    \ = 0;\n+  const unsigned int lenient = parser->lenient_http_headers;\n+  const\
    \ unsigned int allow_chunked_length = parser->allow_chunked_length;\n \n   /*\
    \ We're in an error state. Don't bother doing anything. */\n   if (HTTP_PARSER_ERRNO(parser)\
    \ != HPE_OK) {\n@@ -782,6 +793,7 @@ size_t http_parser_execute (http_parser *parser,\n\
    \         if (ch == CR || ch == LF)\n           break;\n         parser->flags\
    \ = 0;\n+        parser->uses_transfer_encoding = 0;\n         parser->content_length\
    \ = ULLONG_MAX;\n \n         if (ch == 'H') {\n@@ -817,6 +829,7 @@ size_t http_parser_execute\
    \ (http_parser *parser,\n       case s_start_res:\n       {\n         parser->flags\
    \ = 0;\n+        parser->uses_transfer_encoding = 0;\n         parser->content_length\
    \ = ULLONG_MAX;\n \n         switch (ch) {\n@@ -1015,6 +1028,7 @@ size_t http_parser_execute\
    \ (http_parser *parser,\n         if (ch == CR || ch == LF)\n           break;\n\
    \         parser->flags = 0;\n+        parser->uses_transfer_encoding = 0;\n \
    \        parser->content_length = ULLONG_MAX;\n \n         if (!IS_ALPHA(ch))\
    \ {\n@@ -1470,6 +1484,7 @@ size_t http_parser_execute (http_parser *parser,\n\
    \                 parser->header_state = h_general;\n               } else if\
    \ (parser->index == sizeof(TRANSFER_ENCODING)-2) {\n                 parser->header_state\
    \ = h_transfer_encoding;\n+                parser->uses_transfer_encoding = 1;\n\
    \               }\n               break;\n \n@@ -1544,16 +1559,26 @@ size_t http_parser_execute\
    \ (http_parser *parser,\n             if ('c' == c) {\n               parser->header_state\
    \ = h_matching_transfer_encoding_chunked;\n             } else {\n-          \
    \    parser->header_state = h_general;\n+              parser->header_state =\
    \ h_matching_transfer_encoding_token;\n             }\n             break;\n \n\
    +          /* Multi-value `Transfer-Encoding` header */\n+          case h_matching_transfer_encoding_token_start:\n\
    +            break;\n+\n           case h_content_length:\n             if (!IS_NUM(ch))\
    \ {\n               SET_ERRNO(HPE_INVALID_CONTENT_LENGTH);\n               goto\
    \ error;\n             }\n \n+            if (parser->flags & F_CONTENTLENGTH)\
    \ {\n+              SET_ERRNO(HPE_UNEXPECTED_CONTENT_LENGTH);\n+             \
    \ goto error;\n+            }\n+\n+            parser->flags |= F_CONTENTLENGTH;\n\
    \             parser->content_length = ch - '0';\n             break;\n \n@@ -1591,6\
    \ +1616,11 @@ size_t http_parser_execute (http_parser *parser,\n           goto\
    \ reexecute_byte;\n         }\n \n+        if (!lenient && !IS_HEADER_CHAR(ch))\
    \ {\n+          SET_ERRNO(HPE_INVALID_HEADER_TOKEN);\n+          goto error;\n\
    +        }\n+\n         c = LOWER(ch);\n \n         switch (parser->header_state)\
    \ {\n@@ -1627,17 +1657,47 @@ size_t http_parser_execute (http_parser *parser,\n\
    \             break;\n           }\n \n+          /* Transfer-Encoding: chunked\
    \ */\n+          case h_matching_transfer_encoding_token_start:\n+           \
    \ /* looking for 'Transfer-Encoding: chunked' */\n+            if ('c' == c) {\n\
    +              parser->header_state = h_matching_transfer_encoding_chunked;\n\
    +            } else if (TOKEN(c)) {\n+              /* NOTE(gejun): Not use strict\
    \ mode for these macros since the additional\n+               * characeters seem\
    \ to be OK.\n+               */\n+\n+              /* TODO(indutny): similar code\
    \ below does this, but why?\n+               * At the very least it seems to be\
    \ inconsistent given that\n+               * h_matching_transfer_encoding_token\
    \ does not check for\n+               * `STRICT_TOKEN`\n+               */\n+\
    \              parser->header_state = h_matching_transfer_encoding_token;\n+ \
    \           } else if (c == ' ' || c == '\\t') {\n+              /* Skip lws */\n\
    +            } else {\n+              parser->header_state = h_general;\n+   \
    \         }\n+            break;\n+\n           /* Transfer-Encoding: chunked\
    \ */\n           case h_matching_transfer_encoding_chunked:\n             parser->index++;\n\
    \             if (parser->index > sizeof(CHUNKED)-1\n                 || c !=\
    \ CHUNKED[parser->index]) {\n-              parser->header_state = h_general;\n\
    +              parser->header_state = h_matching_transfer_encoding_token;\n  \
    \           } else if (parser->index == sizeof(CHUNKED)-2) {\n               parser->header_state\
    \ = h_transfer_encoding_chunked;\n             }\n             break;\n \n+  \
    \        case h_matching_transfer_encoding_token:\n+            if (ch == ',')\
    \ {\n+              parser->header_state = h_matching_transfer_encoding_token_start;\n\
    +              parser->index = 0;\n+            }\n+            break;\n+\n  \
    \         /* looking for 'Connection: keep-alive' */\n           case h_matching_connection_keep_alive:\n\
    \             parser->index++;\n@@ -1660,6 +1720,9 @@ size_t http_parser_execute\
    \ (http_parser *parser,\n             break;\n \n           case h_transfer_encoding_chunked:\n\
    +            if (ch != ' ') parser->header_state = h_matching_transfer_encoding_token;\n\
    +            break;\n+\n           case h_connection_keep_alive:\n           case\
    \ h_connection_close:\n             if (ch != ' ') parser->header_state = h_general;\n\
    @@ -1739,6 +1802,24 @@ size_t http_parser_execute (http_parser *parser,\n    \
    \       break;\n         }\n \n+        /* Cannot use transfer-encoding and a\
    \ content-length header together\n+           per the HTTP specification. (RFC\
    \ 7230 Section 3.3.3) */\n+        if ((parser->uses_transfer_encoding == 1) &&\n\
    +             (parser->flags & F_CONTENTLENGTH)) {\n+          /* Allow it for\
    \ lenient parsing as long as `Transfer-Encoding` is\n+           * not `chunked`\
    \ or allow_length_with_encoding is set\n+           */\n+          if (parser->flags\
    \ & F_CHUNKED) {\n+            if (!allow_chunked_length) {\n+              SET_ERRNO(HPE_UNEXPECTED_CONTENT_LENGTH);\n\
    +              goto error;\n+            }\n+          } else if (!lenient) {\n\
    +            SET_ERRNO(HPE_UNEXPECTED_CONTENT_LENGTH);\n+            goto error;\n\
    +          }\n+        }\n+\n         parser->state = s_headers_done;\n \n   \
    \      /* Here we call the headers_complete callback. This is somewhat\n@@ -1791,6\
    \ +1872,26 @@ size_t http_parser_execute (http_parser *parser,\n         } else\
    \ if (parser->flags & F_CHUNKED) {\n           /* chunked encoding - ignore Content-Length\
    \ header */\n           parser->state = s_chunk_size_start;\n+        } else if\
    \ (parser->uses_transfer_encoding == 1) {\n+          if (parser->type == HTTP_REQUEST\
    \ && !lenient) {\n+            /* RFC 7230 3.3.3 */\n+            /* If a Transfer-Encoding\
    \ header field\n+            * is present in a request and the chunked transfer\
    \ coding is not\n+            * the final encoding, the message body length cannot\
    \ be determined\n+            * reliably; the server MUST respond with the 400\
    \ (Bad Request)\n+            * status code and then close the connection.\n+\
    \            */\n+            SET_ERRNO(HPE_INVALID_TRANSFER_ENCODING);\n+   \
    \         return (p - data); /* Error */\n+          } else {\n+            /*\
    \ RFC 7230 3.3.3 */\n+            /* If a Transfer-Encoding header field is present\
    \ in a response and\n+            * the chunked transfer coding is not the final\
    \ encoding, the\n+            * message body length is determined by reading the\
    \ connection until\n+            * it is closed by the server.\n+            */\n\
    +              parser->state = s_body_identity_eof;\n+          }\n         }\
    \ else {\n           if (parser->content_length == 0) {\n             /* Content-Length\
    \ header given but zero: Content-Length: 0\\r\\n */\n@@ -2037,6 +2138,12 @@ http_message_needs_eof\
    \ (const http_parser *parser)\n     return 0;\n   }\n \n+  /* RFC 7230 3.3.3,\
    \ see `s_headers_almost_done` */\n+  if ((parser->uses_transfer_encoding == 1)\
    \ &&\n+      (parser->flags & F_CHUNKED) == 0) {\n+    return 1;\n+  }\n+\n  \
    \ if ((parser->flags & F_CHUNKED) || parser->content_length != ULLONG_MAX) {\n\
    \     return 0;\n   }"
  - "--- a/test/brpc_http_message_unittest.cpp\n+++ b/test/brpc_http_message_unittest.cpp\n\
    @@ -26,6 +26,9 @@\n #include \"echo.pb.h\"\n \n namespace brpc {\n+\n+DECLARE_bool(allow_chunked_length);\n\
    +\n namespace policy {\n Server::MethodProperty*\n FindMethodPropertyByURI(const\
    \ std::string& uri_path, const Server* server,\n@@ -259,6 +262,93 @@ TEST(HttpMessageTest,\
    \ parse_http_head_response) {\n     ASSERT_EQ(\"chunked\", *transfer_encoding);\n\
    \ }\n \n+TEST(HttpMessageTest, cl_and_te) {\n+    // https://datatracker.ietf.org/doc/html/rfc2616#section-14.41\n\
    +    // If multiple encodings have been applied to an entity, the transfer-\n\
    +    // codings MUST be listed in the order in which they were applied.\n+   \
    \ const char* request_buf1 = \"POST /chunked_w_content_length HTTP/1.1\\r\\n\"\
    \n+                               \"Content-Length: 10\\r\\n\"\n+            \
    \                   \"Transfer-Encoding: gzip,chunked\\r\\n\"\n+             \
    \                  \"\\r\\n\"\n+                               \"5; ilovew3;whattheluck=aretheseparametersfor\\\
    r\\nhello\\r\\n\"\n+                               \"6; blahblah; blah\\r\\n world\\\
    r\\n\"\n+                               \"0\\r\\n\"\n+                       \
    \        \"\\r\\n\";\n+    butil::IOBuf request1;\n+    request1.append(request_buf1);\n\
    +\n+    const char* request_buf2 = \"POST /chunked_w_content_length HTTP/1.1\\\
    r\\n\"\n+                               \"Content-Length: 19\\r\\n\"\n+      \
    \                         \"Transfer-Encoding: chunked,gzip\\r\\n\"\n+       \
    \                        \"\\r\\n\"\n+                               \"Message\
    \ Body sdfsdf\";\n+    butil::IOBuf request2;\n+    request2.append(request_buf2);\n\
    +\n+    const char* response_buf1 = \"HTTP/1.1 200 OK\\r\\n\"\n+             \
    \                   \"Content-Length: 10\\r\\n\"\n+                          \
    \      \"Transfer-Encoding: gzip,chunked\\r\\n\"\n+                          \
    \      \"\\r\\n\"\n+                                \"5; ilovew3;whattheluck=aretheseparametersfor\\\
    r\\nhello\\r\\n\"\n+                                \"6; blahblah; blah\\r\\n\
    \ world\\r\\n\"\n+                                \"0\\r\\n\"\n+             \
    \                   \"\\r\\n\";\n+    butil::IOBuf response1;\n+    response1.append(response_buf1);\n\
    +\n+    const char* response_buf2 = \"HTTP/1.1 200 OK\\r\\n\"\n+             \
    \                   \"Content-Length: 19\\r\\n\"\n+                          \
    \      \"Transfer-Encoding: chunked,gzip\\r\\n\"\n+                          \
    \      \"\\r\\n\"\n+                                \"Message Body sdfsdf\";\n\
    +    butil::IOBuf response2;\n+    response2.append(response_buf2);\n+\n+    brpc::FLAGS_allow_chunked_length\
    \ = false;\n+    {\n+        brpc::HttpMessage http_message;\n+        ASSERT_EQ(http_message.ParseFromIOBuf(request1),\
    \ -1)\n+                        << http_message._parser;\n+    }\n+    {\n+  \
    \      brpc::HttpMessage http_message;\n+        ASSERT_EQ(http_message.ParseFromIOBuf(request2),\
    \ -1)\n+                        << http_message._parser;\n+    }\n+    {\n+  \
    \      brpc::HttpMessage http_message;\n+        ASSERT_EQ(http_message.ParseFromIOBuf(response1),\
    \ -1)\n+                        << http_message._parser;\n+    }\n+    {\n+  \
    \      brpc::HttpMessage http_message;\n+        ASSERT_EQ(http_message.ParseFromIOBuf(response2),\
    \ -1)\n+                        << http_message._parser;\n+    }\n+\n+    brpc::FLAGS_allow_chunked_length\
    \ = true;\n+    {\n+        brpc::HttpMessage http_message;\n+        ASSERT_EQ(http_message.ParseFromIOBuf(request1),\
    \ request1.size())\n+                        << http_message._parser;\n+    }\n\
    +    {\n+        brpc::HttpMessage http_message;\n+        ASSERT_EQ(http_message.ParseFromIOBuf(request2),\
    \ -1)\n+                        << http_message._parser;\n+    }\n+    {\n+  \
    \      brpc::HttpMessage http_message;\n+        ASSERT_EQ(http_message.ParseFromIOBuf(response1),\
    \ response1.size())\n+                        << http_message._parser;\n+    }\n\
    +    {\n+        brpc::HttpMessage http_message;\n+        ASSERT_EQ(http_message.ParseFromIOBuf(response2),\
    \ -1)\n+                        << http_message._parser;\n+    }\n+}\n+\n TEST(HttpMessageTest,\
    \ find_method_property_by_uri) {\n     brpc::Server server;\n     ASSERT_EQ(0,\
    \ server.AddService(new test::EchoService(),\n@@ -408,6 +498,10 @@ TEST(HttpMessageTest,\
    \ serialize_http_request) {\n     MakeRawHttpRequest(&request, &header, ep, &content);\n\
    \     ASSERT_EQ(\"POST / HTTP/1.1\\r\\nContent-Length: 4\\r\\naccePT: blahblah\\\
    r\\nuser-AGENT: myUA\\r\\nauthorization: myAuthString\\r\\nFoo: Bar\\r\\nHost:\
    \ MyHost: 4321\\r\\n\\r\\ndata\", request);\n \n+    header.SetHeader(\"Transfer-Encoding\"\
    , \"chunked\");\n+    MakeRawHttpRequest(&request, &header, ep, &content);\n+\
    \    ASSERT_EQ(\"POST / HTTP/1.1\\r\\naccePT: blahblah\\r\\nTransfer-Encoding:\
    \ chunked\\r\\nuser-AGENT: myUA\\r\\nauthorization: myAuthString\\r\\nFoo: Bar\\\
    r\\nHost: MyHost: 4321\\r\\n\\r\\ndata\", request);\n+\n     // GET does not serialize\
    \ content and user-set content-length is ignored.\n     header.set_method(brpc::HTTP_METHOD_GET);\n\
    \     header.SetHeader(\"Content-Length\", \"100\");\n@@ -434,12 +528,25 @@ TEST(HttpMessageTest,\
    \ serialize_http_response) {\n     ASSERT_EQ(\"HTTP/1.1 200 OK\\r\\nContent-Length:\
    \ 100\\r\\nFoo: Bar\\r\\n\\r\\n\", response)\n         << butil::ToPrintable(response);\n\
    \ \n+    header.SetHeader(\"Transfer-Encoding\", \"chunked\");\n+    MakeRawHttpResponse(&response,\
    \ &header, NULL);\n+    ASSERT_EQ(\"HTTP/1.1 200 OK\\r\\nTransfer-Encoding: chunked\\\
    r\\nFoo: Bar\\r\\n\\r\\n\", response)\n+                    << butil::ToPrintable(response);\n\
    +    header.RemoveHeader(\"Transfer-Encoding\");\n+\n     // User-set content-length\
    \ is ignored.\n     content.append(\"data2\");\n     MakeRawHttpResponse(&response,\
    \ &header, &content);\n     ASSERT_EQ(\"HTTP/1.1 200 OK\\r\\nContent-Length: 5\\\
    r\\nFoo: Bar\\r\\n\\r\\ndata2\", response)\n         << butil::ToPrintable(response);\n\
    \ \n+    header.SetHeader(\"Content-Length\", \"100\");\n+    header.SetHeader(\"\
    Transfer-Encoding\", \"chunked\");\n+    MakeRawHttpResponse(&response, &header,\
    \ NULL);\n+    ASSERT_EQ(\"HTTP/1.1 200 OK\\r\\nTransfer-Encoding: chunked\\r\\\
    nFoo: Bar\\r\\n\\r\\n\", response)\n+                    << butil::ToPrintable(response);\n\
    +    header.RemoveHeader(\"Transfer-Encoding\");\n+\n     // User-set content-length\
    \ and transfer-encoding is ignored when status code is 204 or 1xx.\n     // 204\
    \ No Content.\n     header.SetHeader(\"Content-Length\", \"100\");"
  identifiers: CVE:["CVE-2024-23452"],CWE:["CWE-444"]
  overview: 'Affected versions of this package are vulnerable to HTTP Request Smuggling
    due to the `http_parser` not complying with the RFC-7230 HTTP 1.1 specification.
    An attacker can smuggle a request into the connection to the backend server by
    sending a message with both a Transfer-Encoding and a Content-Length header field,
    indicating an attempt to perform request smuggling or response splitting. '
  references:
    Apache Lists: https://lists.apache.org/thread/kkvdpwyr2s2yt9qvvxfdzon012898vxd
    GitHub Commit: https://github.com/apache/brpc/commit/09b960026089d5efe22416b8cb7ec777663ca1e0
    GitHub PR: https://github.com/apache/brpc/pull/2518
    GitHub Release: https://github.com/apache/brpc/releases/tag/1.8.0
  title: HTTP Request Smuggling
- diff_content:
  - "--- a/test/test-idna.c\n+++ b/test/test-idna.c\n@@ -151,8 +151,8 @@ TEST_IMPL(idna_toascii)\
    \ {\n   /* Illegal inputs. */\n   F(\"\\xC0\\x80\\xC1\\x80\", UV_EINVAL);  /*\
    \ Overlong UTF-8 sequence. */\n   F(\"\\xC0\\x80\\xC1\\x80.com\", UV_EINVAL);\
    \  /* Overlong UTF-8 sequence. */\n+  F(\"\", UV_EINVAL);\n   /* No conversion.\
    \ */\n-  T(\"\", \"\");\n   T(\".\", \".\");\n   T(\".com\", \".com\");\n   T(\"\
    example\", \"example\");"
  identifiers: CVE:["CVE-2024-24806"],CWE:["CWE-918"]
  overview: Affected versions of this package are vulnerable to Server-Side Request
    Forgery (SSRF) due to the handling of the `hostname_ascii` variable in the `uv_getaddrinfo`
    function. Attackers can exploit the creation of addresses that bypass developer
    checks and resolve to unintended IP addresses, to access internal APIs or for
    websites that allow users to have `username.example.com` pages, potentially exposing
    internal services to attacks.
  references:
    GitHub Commit: https://github.com/libuv/libuv/commit/e0327e1d508b8207c9150b6e582f0adf26213c39
  title: Server-Side Request Forgery (SSRF)
- diff_content:
  - "--- a/mm/memory.c\n+++ b/mm/memory.c\n@@ -5393,27 +5393,28 @@ struct vm_area_struct\
    \ *lock_vma_under_rcu(struct mm_struct *mm,\n \tif (!vma_is_anonymous(vma) &&\
    \ !vma_is_tcp(vma))\n \t\tgoto inval;\n \n-\t/* find_mergeable_anon_vma uses adjacent\
    \ vmas which are not locked */\n-\tif (!vma->anon_vma && !vma_is_tcp(vma))\n-\t\
    \tgoto inval;\n-\n \tif (!vma_start_read(vma))\n \t\tgoto inval;\n \n+\t/*\n+\t\
    \ * find_mergeable_anon_vma uses adjacent vmas which are not locked.\n+\t * This\
    \ check must happen after vma_start_read(); otherwise, a\n+\t * concurrent mremap()\
    \ with MREMAP_DONTUNMAP could dissociate the VMA\n+\t * from its anon_vma.\n+\t\
    \ */\n+\tif (unlikely(!vma->anon_vma && !vma_is_tcp(vma)))\n+\t\tgoto inval_end_read;\n\
    +\n \t/*\n \t * Due to the possibility of userfault handler dropping mmap_lock,\
    \ avoid\n \t * it for now and fall back to page fault handling under mmap_lock.\n\
    \ \t */\n-\tif (userfaultfd_armed(vma)) {\n-\t\tvma_end_read(vma);\n-\t\tgoto\
    \ inval;\n-\t}\n+\tif (userfaultfd_armed(vma))\n+\t\tgoto inval_end_read;\n \n\
    \ \t/* Check since vm_start/vm_end might change before we lock the VMA */\n-\t\
    if (unlikely(address < vma->vm_start || address >= vma->vm_end)) {\n-\t\tvma_end_read(vma);\n\
    -\t\tgoto inval;\n-\t}\n+\tif (unlikely(address < vma->vm_start || address >=\
    \ vma->vm_end))\n+\t\tgoto inval_end_read;\n \n \t/* Check if the VMA got isolated\
    \ after we found it */\n \tif (vma->detached) {\n@@ -5425,6 +5426,9 @@ struct\
    \ vm_area_struct *lock_vma_under_rcu(struct mm_struct *mm,\n \n \trcu_read_unlock();\n\
    \ \treturn vma;\n+\n+inval_end_read:\n+\tvma_end_read(vma);\n inval:\n \trcu_read_unlock();\n\
    \ \tcount_vm_vma_lock_event(VMA_LOCK_ABORT);"
  identifiers: CVE:["CVE-2024-1312"],CWE:["CWE-416"]
  overview: Affected versions of this package are vulnerable to Use After Free due
    to a flaw in the `mas_prev_slot` function. An attacker can crash the system by
    winning two races simultaneously with a failure in the specified function.
  references:
    GitHub Commit: https://github.com/torvalds/linux/commit/657b5146955eba331e01b9a6ae89ce2e716ba306
    RedHat Bugzilla Bug: https://bugzilla.redhat.com/show_bug.cgi?id=2225569
  title: Use After Free
- diff_content:
  - "--- a/src/fr-command-cpio.c\n+++ b/src/fr-command-cpio.c\n@@ -219,7 +219,7 @@\
    \ fr_command_cpio_extract (FrCommand *comm,\n \tfr_process_end_command (comm->process);\n\
    \ }\n \n-const char *cpio_mime_type[] = { \"application/x-cpio\", NULL };\n+const\
    \ char *cpio_mime_type[] = { /*\"application/x-cpio\",*/ NULL };\n \n static const\
    \ char **\n fr_command_cpio_get_mime_types (FrCommand *comm)\n@@ -235,8 +235,8\
    \ @@ fr_command_cpio_get_capabilities (FrCommand  *comm,\n \tFrCommandCaps capabilities;\n\
    \ \n \tcapabilities = FR_COMMAND_CAN_ARCHIVE_MANY_FILES;\n-\tif (is_program_available\
    \ (CPIO_PATH, check_command))\n-\t\tcapabilities |= FR_COMMAND_CAN_READ;\n+/*\t\
    if (is_program_available (CPIO_PATH, check_command))\n+\t\tcapabilities |= FR_COMMAND_CAN_READ;*/\n\
    \ \n \treturn capabilities;\n }"
  - "--- a/src/fr-command-unarchiver.c\n+++ b/src/fr-command-unarchiver.c\n@@ -247,6\
    \ +247,7 @@ fr_command_unarchiver_handle_error (FrCommand   *comm,\n const char\
    \ *unarchiver_mime_type[] = { \"application/zip\",\n \t\t\t\t       \"application/x-cbr\"\
    ,\n \t\t\t\t       \"application/x-rar\",\n+\t\t\t\t       \"application/x-cpio\"\
    ,\n \t\t\t\t       NULL };\n \n static const char **"
  identifiers: CVE:["CVE-2023-52138"],CWE:["CWE-22"]
  overview: Affected versions of this package are vulnerable to Directory Traversal
    via the extraction process of CPIO archives. An attacker can write arbitrary files
    to unintended locations by crafting a malicious CPIO or ISO archive that contains
    symlinks pointing to locations outside of the intended directory structure. When
    the victim extracts such an archive, it can lead to the execution of arbitrary
    code on the target system.
  references:
    GitHub Commit: https://github.com/mate-desktop/engrampa/commit/63d5dfa9005c6b16d0f0ccd888cc859fca78f970
    vulnerability of this type: https://snyk.io/vuln/npm:st:20140206
  title: Directory Traversal
- diff_content:
  - "--- a/net/netfilter/nf_tables_api.c\n+++ b/net/netfilter/nf_tables_api.c\n@@\
    \ -10992,16 +10992,10 @@ static int nft_verdict_init(const struct nft_ctx *ctx,\
    \ struct nft_data *data,\n \tdata->verdict.code = ntohl(nla_get_be32(tb[NFTA_VERDICT_CODE]));\n\
    \ \n \tswitch (data->verdict.code) {\n-\tdefault:\n-\t\tswitch (data->verdict.code\
    \ & NF_VERDICT_MASK) {\n-\t\tcase NF_ACCEPT:\n-\t\tcase NF_DROP:\n-\t\tcase NF_QUEUE:\n\
    -\t\t\tbreak;\n-\t\tdefault:\n-\t\t\treturn -EINVAL;\n-\t\t}\n-\t\tfallthrough;\n\
    +\tcase NF_ACCEPT:\n+\tcase NF_DROP:\n+\tcase NF_QUEUE:\n+\t\tbreak;\n \tcase\
    \ NFT_CONTINUE:\n \tcase NFT_BREAK:\n \tcase NFT_RETURN:\n@@ -11036,6 +11030,8\
    \ @@ static int nft_verdict_init(const struct nft_ctx *ctx, struct nft_data *data,\n\
    \ \n \t\tdata->verdict.chain = chain;\n \t\tbreak;\n+\tdefault:\n+\t\treturn -EINVAL;\n\
    \ \t}\n \n \tdesc->len = sizeof(data->verdict);"
  identifiers: CVE:["CVE-2024-1086"],CWE:["CWE-416"]
  overview: 'Affected versions of this package are vulnerable to Use After Free via
    the `nft_verdict_init` function. An attacker can achieve local privilege escalation
    by issuing a drop error that resembles `NF_ACCEPT`, leading to a double-free condition
    in the `nf_hook_slow` function. '
  references:
    GitHub Commit: https://github.com/torvalds/linux/commit/f342de4e2f33e0e39165d8639387aa6c19dff660
    RedHat Bugzilla Bug: https://bugzilla.redhat.com/show_bug.cgi?id=2262126
  title: Use After Free
- diff_content:
  - "--- a/drivers/scsi/lpfc/lpfc_hbadisc.c\n+++ b/drivers/scsi/lpfc/lpfc_hbadisc.c\n\
    @@ -6944,7 +6944,9 @@ lpfc_unregister_fcf_rescan(struct lpfc_hba *phba)\n \tif\
    \ (rc)\n \t\treturn;\n \t/* Reset HBA FCF states after successful unregister FCF\
    \ */\n+\tspin_lock_irq(&phba->hbalock);\n \tphba->fcf.fcf_flag = 0;\n+\tspin_unlock_irq(&phba->hbalock);\n\
    \ \tphba->fcf.current_rec.flag = 0;\n \n \t/*"
  identifiers: CVE:["CVE-2024-24855"],CWE:["CWE-362"]
  overview: Affected versions of this package are vulnerable to Race Condition in
    the `lpfc_unregister_fcf_rescan` function. An attacker can cause a denial of service
    by exploiting the timing window between actions.
  references:
    GitHub Commit: https://github.com/torvalds/linux/commit/0e881c0a4b6146b7e856735226208f48251facd8
  title: Race Condition
- diff_content:
  - "--- a/sound/hda/hdac_regmap.c\n+++ b/sound/hda/hdac_regmap.c\n@@ -596,10 +596,9\
    \ @@ EXPORT_SYMBOL_GPL(snd_hdac_regmap_update_raw_once);\n  */\n void snd_hdac_regmap_sync(struct\
    \ hdac_device *codec)\n {\n-\tif (codec->regmap) {\n-\t\tmutex_lock(&codec->regmap_lock);\n\
    +\tmutex_lock(&codec->regmap_lock);\n+\tif (codec->regmap)\n \t\tregcache_sync(codec->regmap);\n\
    -\t\tmutex_unlock(&codec->regmap_lock);\n-\t}\n+\tmutex_unlock(&codec->regmap_lock);\n\
    \ }\n EXPORT_SYMBOL_GPL(snd_hdac_regmap_sync);"
  identifiers: CVE:["CVE-2024-23196"],CWE:["CWE-362"]
  overview: Affected versions of this package are vulnerable to Race Condition in
    the `snd_hdac_regmap_sync` function. An attacker can cause a denial of service
    by exploiting the timing window between actions.
  references:
    GitHub Commit: https://github.com/torvalds/linux/commit/1f4a08fed450db87fbb5ff5105354158bdbe1a22
  title: Race Condition
- diff_content:
  - "--- a/libs/filesystem/jswrap_fs.c\n+++ b/libs/filesystem/jswrap_fs.c\n@@ -358,7\
    \ +358,7 @@ JsVar *jswrap_fs_stat(JsVar *path) {\n       date.month = (int)(((info.fdate>>5)&15)-1);\
    \  // TomWS: Month is 0 based.\n       date.day = (int)((info.fdate)&31);\n  \
    \     TimeInDay td;\n-      td.daysSinceEpoch = fromCalenderDate(&date);\n+  \
    \    td.daysSinceEpoch = fromCalendarDate(&date);\n       td.hour = (int)((info.ftime>>11)&31);\n\
    \       td.min = (int)((info.ftime>>5)&63);\n       td.sec = (int)((info.ftime)&63);"
  - "--- a/libs/misc/nmea.c\n+++ b/libs/misc/nmea.c\n@@ -184,7 +184,7 @@ JsVar *nmea_to_jsVar(NMEAFixInfo\
    \ *gpsFix) {\n       date.month = gpsFix->month-1; // 1 based to 0 based\n   \
    \    date.year = 2000+gpsFix->year;\n       TimeInDay td;\n-      td.daysSinceEpoch\
    \ = fromCalenderDate(&date);\n+      td.daysSinceEpoch = fromCalendarDate(&date);\n\
    \       td.hour = gpsFix->hour;\n       td.min = gpsFix->min;\n       td.sec =\
    \ gpsFix->sec;"
  - "--- a/src/jswrap_date.c\n+++ b/src/jswrap_date.c\n@@ -23,29 +23,52 @@ const int\
    \ BASE_DOW = 4;\n const char *MONTHNAMES = \"Jan\\0Feb\\0Mar\\0Apr\\0May\\0Jun\\\
    0Jul\\0Aug\\0Sep\\0Oct\\0Nov\\0Dec\";\n const char *DAYNAMES = \"Sun\\0Mon\\0Tue\\\
    0Wed\\0Thu\\0Fri\\0Sat\";\n \n+#ifdef ESPR_LIMIT_DATE_RANGE\n+// This rounds towards\
    \ zero - which is not what the algorithm needs. Hence the range for Date() is\
    \ further limited when ESPR_LIMIT_DATE_RANGE is set\n+#define INTEGER_DIVIDE_FLOOR(a,b)\
    \ ((a)/(b))\n+#else\n+// This rounds down, which is what the algorithm needs\n\
    +int integerDivideFloor(int a, int b) {\n+  return (a < 0 ? a-b+1 : a)/b;\n+}\n\
    +#define INTEGER_DIVIDE_FLOOR(a,b) integerDivideFloor((a),(b))\n+#endif\n+\n+\n\
    \ // Convert y,m,d into a number of days since 1970, where 0<=m<=11\n // https://github.com/deirdreobyrne/CalendarAndDST\n\
    \ int getDayNumberFromDate(int y, int m, int d) {\n   int ans;\n-\n-  if (m <\
    \ 2) {\n+  \n+#ifdef ESPR_LIMIT_DATE_RANGE\n+  if (y < 1500 || y >= 1250000) {\
    \ // Should actually work down to 1101, but since the Gregorian calendar started\
    \ in 1582 . . .\n+#else\n+  if (y < -1250000 || y >= 1250000) {\n+#endif\n+  \
    \  jsExceptionHere(JSET_ERROR, \"Date out of bounds\");\n+    return 0; // Need\
    \ to head off any overflow error\n+  }\n+  while (m < 2) {\n     y--;\n     m+=12;\n\
    \   }\n-  ans = (y/100);\n-  return 365*y + (y>>2) - ans + (ans>>2) + 30*m + ((3*m+6)/5)\
    \ + d - 719531;\n+  // #2456 was created by integer division rounding towards\
    \ zero, rather than the FLOOR-behaviour required by the algorithm.\n+  ans = INTEGER_DIVIDE_FLOOR(y,100);\n\
    +  return 365*y + INTEGER_DIVIDE_FLOOR(y,4) - ans + INTEGER_DIVIDE_FLOOR(ans,4)\
    \ + 30*m + ((3*m+6)/5) + d - 719531;\n }\n \n // Convert a number of days since\
    \ 1970 into y,m,d. 0<=m<=11\n // https://github.com/deirdreobyrne/CalendarAndDST\n\
    \ void getDateFromDayNumber(int day, int *y, int *m, int *date) {\n   int a =\
    \ day + 135081;\n   int b,c,d;\n-  a = (a-(a/146097)+146095)/36524;\n-  a = day\
    \ + a - (a>>2);\n-  b = ((a<<2)+2877911)/1461;\n-  c = a + 719600 - 365*b - (b>>2);\n\
    -  d = (5*c-1)/153;\n+\n+  // Bug #2456 fixed here too\n+  a = INTEGER_DIVIDE_FLOOR(a\
    \ - INTEGER_DIVIDE_FLOOR(a,146097) + 146095,36524);\n+  a = day + a - INTEGER_DIVIDE_FLOOR(a,4);\n\
    +  b = INTEGER_DIVIDE_FLOOR((a<<2)+2877911,1461);\n+  c = a + 719600 - 365*b -\
    \ INTEGER_DIVIDE_FLOOR(b,4);\n+  d = (5*c-1)/153; // Floor behaviour not needed,\
    \ as c is always positive\n   if (date) *date=c-30*d-((3*d)/5);\n   if (m) {\n\
    \     if (d<14)\n@@ -178,7 +201,7 @@ CalendarDate getCalendarDate(int d) {\n \
    \  return date;\n };\n \n-int fromCalenderDate(CalendarDate *date) {\n+int fromCalendarDate(CalendarDate\
    \ *date) {\n   while (date->month < 0) {\n     date->year--;\n     date->month\
    \ += 12;\n@@ -298,7 +321,7 @@ JsVar *jswrap_date_constructor(JsVar *args) {\n\
    \     date.month = (int)(jsvGetIntegerAndUnLock(jsvGetArrayItem(args, 1)));\n\
    \     date.day = (int)(jsvGetIntegerAndUnLock(jsvGetArrayItem(args, 2)));\n  \
    \   TimeInDay td;\n-    td.daysSinceEpoch = fromCalenderDate(&date);\n+    td.daysSinceEpoch\
    \ = fromCalendarDate(&date);\n     td.hour = (int)(jsvGetIntegerAndUnLock(jsvGetArrayItem(args,\
    \ 3)));\n     td.min = (int)(jsvGetIntegerAndUnLock(jsvGetArrayItem(args, 4)));\n\
    \     td.sec = (int)(jsvGetIntegerAndUnLock(jsvGetArrayItem(args, 5)));\n@@ -376,6\
    \ +399,14 @@ JsVarFloat jswrap_date_getTime(JsVar *date) {\n Set the time/date\
    \ of this Date class\n  */\n JsVarFloat jswrap_date_setTime(JsVar *date, JsVarFloat\
    \ timeValue) {\n+#ifdef ESPR_LIMIT_DATE_RANGE\n+  if (timeValue < -1.48317696e13\
    \ || timeValue >= 3.93840543168E+016) { // This should actually work down to 1101AD\
    \ . . .\n+#else\n+  if (timeValue < -3.95083256832E+016 || timeValue >= 3.93840543168E+016)\
    \ {\n+#endif\n+    jsExceptionHere(JSET_ERROR, \"Date out of bounds\");\n+   \
    \ return 0.0;\n+  }\n   if (date)\n     jsvObjectSetChildAndUnLock(date, \"ms\"\
    , jsvNewFromFloat(timeValue));\n   return timeValue;\n@@ -607,7 +638,7 @@ JsVarFloat\
    \ jswrap_date_setDate(JsVar *parent, int dayValue) {\n   TimeInDay td = getTimeFromDateVar(parent,\
    \ false/*system timezone*/);\n   CalendarDate d = getCalendarDate(td.daysSinceEpoch);\n\
    \   d.day = dayValue;\n-  td.daysSinceEpoch = fromCalenderDate(&d);\n+  td.daysSinceEpoch\
    \ = fromCalendarDate(&d);\n   setCorrectTimeZone(&td);\n   return jswrap_date_setTime(parent,\
    \ fromTimeInDay(&td));\n }\n@@ -620,11 +651,11 @@ JsVarFloat jswrap_date_setDate(JsVar\
    \ *parent, int dayValue) {\n   \"name\" : \"setMonth\",\n   \"generate\" : \"\
    jswrap_date_setMonth\",\n   \"params\" : [\n-    [\"yearValue\",\"int\",\"The\
    \ month, between 0 and 11\"],\n+    [\"monthValue\",\"int\",\"The month, between\
    \ 0 and 11\"],\n     [\"dayValue\",\"JsVar\",\"[optional] the day, between 0 and\
    \ 31\"]\n   ],\n   \"return\" : [\"float\",\"The number of milliseconds since\
    \ 1970\"],\n-  \"typescript\" : \"setMonth(yearValue: number, dayValue?: number):\
    \ number;\"\n+  \"typescript\" : \"setMonth(monthValue: number, dayValue?: number):\
    \ number;\"\n }\n Month of the year 0..11\n  */\n@@ -634,7 +665,7 @@ JsVarFloat\
    \ jswrap_date_setMonth(JsVar *parent, int monthValue, JsVar *dayValue)\n   d.month\
    \ = monthValue;\n   if (jsvIsNumeric(dayValue))\n     d.day = jsvGetInteger(dayValue);\n\
    -  td.daysSinceEpoch = fromCalenderDate(&d);\n+  td.daysSinceEpoch = fromCalendarDate(&d);\n\
    \   setCorrectTimeZone(&td);\n   return jswrap_date_setTime(parent, fromTimeInDay(&td));\n\
    \ }\n@@ -662,7 +693,7 @@ JsVarFloat jswrap_date_setFullYear(JsVar *parent, int\
    \ yearValue, JsVar *monthVal\n     d.month = jsvGetInteger(monthValue);\n   if\
    \ (jsvIsNumeric(dayValue))\n     d.day = jsvGetInteger(dayValue);\n-  td.daysSinceEpoch\
    \ = fromCalenderDate(&d);\n+  td.daysSinceEpoch = fromCalendarDate(&d);\n   setCorrectTimeZone(&td);\n\
    \   return jswrap_date_setTime(parent, fromTimeInDay(&td));\n }\n@@ -874,7 +905,7\
    \ @@ JsVarFloat jswrap_date_parse(JsVar *str) {\n           jslGetNextToken();\n\
    \           if (lex.tk == LEX_INT) {\n             date.year = _parse_int();\n\
    -            time.daysSinceEpoch = fromCalenderDate(&date);\n+            time.daysSinceEpoch\
    \ = fromCalendarDate(&date);\n             jslGetNextToken();\n             if\
    \ (lex.tk == LEX_INT) {\n               _parse_time(&time, 0);\n@@ -897,7 +928,7\
    \ @@ JsVarFloat jswrap_date_parse(JsVar *str) {\n             jslGetNextToken();\n\
    \             if (lex.tk == LEX_INT) {\n               date.year = _parse_int();\n\
    -              time.daysSinceEpoch = fromCalenderDate(&date);\n+             \
    \ time.daysSinceEpoch = fromCalendarDate(&date);\n               jslGetNextToken();\n\
    \               if (lex.tk == LEX_INT) {\n                 _parse_time(&time,\
    \ 0);\n@@ -924,7 +955,7 @@ JsVarFloat jswrap_date_parse(JsVar *str) {\n      \
    \     jslGetNextToken();\n           if (lex.tk == LEX_INT) {\n             date.day\
    \ = _parse_int();\n-            time.daysSinceEpoch = fromCalenderDate(&date);\n\
    +            time.daysSinceEpoch = fromCalendarDate(&date);\n             jslGetNextToken();\n\
    \             if (lex.tk == LEX_ID && jslGetTokenValueAsString()[0]=='T') {\n\
    \               _parse_time(&time, 1);"
  - "--- a/targets/nrf5x/bluetooth_ancs.c\n+++ b/targets/nrf5x/bluetooth_ancs.c\n\
    @@ -289,7 +289,7 @@ void ble_cts_handle_time(BLEPending blep, char *buffer, size_t\
    \ bufferLen) {\n   date.month = time.month-1; // JS months are 0-11, but CTS uses\
    \ 1-12\n   date.day = time.day;\n   TimeInDay td;\n-  td.daysSinceEpoch = fromCalenderDate(&date);\n\
    +  td.daysSinceEpoch = fromCalendarDate(&date);\n   td.hour = time.hours;\n  \
    \ td.min = time.minutes;\n   td.sec = time.seconds;"
  - "--- a/targets/stm32/jshardware.c\n+++ b/targets/stm32/jshardware.c\n@@ -1536,7\
    \ +1536,7 @@ JsSysTime jshGetRTCSystemTime() {\n   cdate.month = date.RTC_Month-1;\
    \ // 1..12 -> 0..11\n   cdate.year = 2000+date.RTC_Year; // 0..99 -> 2000..2099\n\
    \   cdate.dow = date.RTC_WeekDay%7; // 1(monday)..7 -> 0(sunday)..6\n-  ctime.daysSinceEpoch\
    \ = fromCalenderDate(&cdate);\n+  ctime.daysSinceEpoch = fromCalendarDate(&cdate);\n\
    \   ctime.zone = 0;\n   ctime.ms = 0;\n   ctime.sec = time.RTC_Seconds;"
  identifiers: CVE:["CVE-2024-25201"],CWE:["CWE-125"]
  overview: Affected versions of this package are vulnerable to Out-of-bounds Read
    via the `jsvStringIteratorPrintfCallback` function in `src/jsvar.c`. An attacker
    can read sensitive information or cause a crash by supplying crafted input that
    triggers the out-of-bounds read.
  references:
    GitHub Commit: https://github.com/espruino/Espruino/commit/fcd68f62172dee8086fe159b3af0fa1528f3a6fe
    GitHub Issue: https://github.com/espruino/Espruino/issues/2456
    GitHub PR: https://github.com/espruino/Espruino/pull/2459
  title: Out-of-bounds Read
- diff_content:
  - "--- a/src/jsparse.c\n+++ b/src/jsparse.c\n@@ -1319,9 +1319,12 @@ NO_INLINE JsVar\
    \ *jspeFactorFunctionCall() {\n   while ((lex->tk=='(' || (isConstructor && JSP_SHOULD_EXECUTE))\
    \ && !jspIsInterrupted()) {\n     JsVar *funcName = a;\n     JsVar *func = jsvSkipName(funcName);\n\
    -\n+    if (!func)  { // could have ReferenceErrored while skipping name\n+  \
    \    jsvUnLock2(funcName, parent);\n+      return 0;\n+    }\n     /* The constructor\
    \ function doesn't change parsing, so if we're\n-     * not executing, just short-cut\
    \ it. */\n+    * not executing, just short-cut it. */\n     if (isConstructor\
    \ && JSP_SHOULD_EXECUTE) {\n       // If we have '(' parse an argument list, otherwise\
    \ don't look for any args\n       bool parseArgs = lex->tk=='(';"
  identifiers: CVE:["CVE-2024-25200"],CWE:["CWE-121"]
  overview: Affected versions of this package are vulnerable to Stack-based Buffer
    Overflow via the `jspeFactorFunctionCall` function in `src/jsparse.c`. An attacker
    can cause a crash or potentially execute arbitrary code by providing crafted input
    that triggers a stack overflow.
  references:
    GitHub Commit: https://github.com/espruino/Espruino/commit/5fee08ff28ae5e9b14b199a7849200cf9d7c9398
    GitHub Issue: https://github.com/espruino/Espruino/issues/2457
  title: Stack-based Buffer Overflow
- diff_content:
  - "--- a/src/map.c\n+++ b/src/map.c\n@@ -3114,7 +3114,7 @@ did_set_langmap(optset_T\
    \ *args UNUSED)\n \t\t    {\n \t\t\tif (p[0] != ',')\n \t\t\t{\n-\t\t\t    sprintf(args->os_errbuf,\n\
    +\t\t\t    snprintf(args->os_errbuf, args->os_errbuflen,\n \t\t\t\t    _(e_langmap_extra_characters_after_semicolon_str),\n\
    \ \t\t\t\t    p);\n \t\t\t    return args->os_errbuf;"
  - "--- a/src/option.c\n+++ b/src/option.c\n@@ -1932,6 +1932,7 @@ do_set_option_string(\n\
    \ \tint\t    cp_val,\n \tchar_u\t    *varp_arg,\n \tchar\t    *errbuf,\n+\tint\t\
    \    errbuflen,\n \tint\t    *value_checked,\n \tchar\t    **errmsg)\n {\n@@ -2030,7\
    \ +2031,7 @@ do_set_option_string(\n \t// be triggered that can cause havoc.\n\
    \ \t*errmsg = did_set_string_option(\n \t\t\topt_idx, (char_u **)varp, oldval,\
    \ newval, errbuf,\n-\t\t\topt_flags, op, value_checked);\n+\t\t\terrbuflen, opt_flags,\
    \ op, value_checked);\n \n \tsecure = secure_saved;\n     }\n@@ -2287,7 +2288,7\
    \ @@ do_set_option_value(\n \t{\n \t    // string option\n \t    if (do_set_option_string(opt_idx,\
    \ opt_flags, &arg, nextchar, op,\n-\t\t\t\t\tflags, cp_val, varp, errbuf,\n+\t\
    \t\t\t\tflags, cp_val, varp, errbuf, errbuflen,\n \t\t\t\t\t&value_checked, &errmsg)\
    \ == FAIL)\n \t    {\n \t\tif (errmsg != NULL)\n@@ -2579,12 +2580,12 @@ do_set(\n\
    \ \t{\n \t    int\t\tstopopteval = FALSE;\n \t    char\t*errmsg = NULL;\n-\t \
    \   char\terrbuf[80];\n+\t    char\terrbuf[ERR_BUFLEN];\n \t    char_u\t*startarg\
    \ = arg;\n \n \t    errmsg = do_set_option(opt_flags, &arg, arg_start, &startarg,\n\
    \ \t\t\t\t\t&did_show, &stopopteval, errbuf,\n-\t\t\t\t\tsizeof(errbuf));\n+\t\
    \t\t\t\tERR_BUFLEN);\n \t    if (stopopteval)\n \t\tbreak;\n \n@@ -5347,7 +5348,8\
    \ @@ set_option_value(\n     int\t\topt_idx;\n     char_u\t*varp;\n     long_u\t\
    flags;\n-    static char\terrbuf[80];\n+    static char\terrbuf[ERR_BUFLEN];\n\
    +    int\t\terrbuflen = ERR_BUFLEN;\n \n     opt_idx = findoption(name);\n   \
    \  if (opt_idx < 0)\n@@ -5390,7 +5392,7 @@ set_option_value(\n \t}\n #endif\n\
    \ \tif (flags & P_STRING)\n-\t    return set_string_option(opt_idx, string, opt_flags,\
    \ errbuf);\n+\t    return set_string_option(opt_idx, string, opt_flags, errbuf,\
    \ errbuflen);\n \n \tvarp = get_varp_scope(&(options[opt_idx]), opt_flags);\n\
    \ \tif (varp != NULL)\t// hidden option is not changed"
  - "--- a/src/optionstr.c\n+++ b/src/optionstr.c\n@@ -229,11 +229,12 @@ trigger_optionset_string(\n\
    \ #endif\n \n     static char *\n-illegal_char(char *errbuf, int c)\n+illegal_char(char\
    \ *errbuf, int errbuflen, int c)\n {\n     if (errbuf == NULL)\n \treturn \"\"\
    ;\n-    sprintf((char *)errbuf, _(e_illegal_character_str), (char *)transchar(c));\n\
    +    snprintf((char *)errbuf, errbuflen, _(e_illegal_character_str),\n+\t\t  \
    \  (char *)transchar(c));\n     return errbuf;\n }\n \n@@ -525,7 +526,8 @@ set_string_option(\n\
    \     int\t\topt_idx,\n     char_u\t*value,\n     int\t\topt_flags,\t// OPT_LOCAL\
    \ and/or OPT_GLOBAL\n-    char\t*errbuf)\n+    char\t*errbuf,\n+    int\t\terrbuflen)\n\
    \ {\n     char_u\t*s;\n     char_u\t**varp;\n@@ -579,7 +581,7 @@ set_string_option(\n\
    \     }\n #endif\n     if ((errmsg = did_set_string_option(opt_idx, varp, oldval,\
    \ value, errbuf,\n-\t\t    opt_flags, OP_NONE, &value_checked)) == NULL)\n+\t\t\
    \    errbuflen, opt_flags, OP_NONE, &value_checked)) == NULL)\n \tdid_set_option(opt_idx,\
    \ opt_flags, TRUE, value_checked);\n \n #if defined(FEAT_EVAL)\n@@ -615,7 +617,8\
    \ @@ valid_filetype(char_u *val)\n check_stl_option(char_u *s)\n {\n     int\t\
    \tgroupdepth = 0;\n-    static char errbuf[80];\n+    static char errbuf[ERR_BUFLEN];\n\
    +    int\t\terrbuflen = ERR_BUFLEN;\n \n     while (*s)\n     {\n@@ -656,15 +659,15\
    \ @@ check_stl_option(char_u *s)\n \t}\n \tif (vim_strchr(STL_ALL, *s) == NULL)\n\
    \ \t{\n-\t    return illegal_char(errbuf, *s);\n+\t    return illegal_char(errbuf,\
    \ errbuflen, *s);\n \t}\n \tif (*s == '{')\n \t{\n \t    int reevaluate = (*++s\
    \ == '%');\n \n \t    if (reevaluate && *++s == '}')\n \t\t// \"}\" is not allowed\
    \ immediately after \"%{%\"\n-\t\treturn illegal_char(errbuf, '}');\n+\t\treturn\
    \ illegal_char(errbuf, errbuflen, '}');\n \t    while ((*s != '}' || (reevaluate\
    \ && s[-1] != '%')) && *s)\n \t\ts++;\n \t    if (*s != '}')\n@@ -719,13 +722,17\
    \ @@ did_set_opt_strings(char_u *val, char **values, int list)\n  * An option\
    \ which is a list of flags is set.  Valid values are in 'flags'.\n  */\n     static\
    \ char *\n-did_set_option_listflag(char_u *val, char_u *flags, char *errbuf)\n\
    +did_set_option_listflag(\n+\tchar_u *val,\n+\tchar_u *flags,\n+\tchar *errbuf,\n\
    +\tint errbuflen)\n {\n     char_u\t*s;\n \n     for (s = val; *s; ++s)\n \tif\
    \ (vim_strchr(flags, *s) == NULL)\n-\t    return illegal_char(errbuf, *s);\n+\t\
    \    return illegal_char(errbuf, errbuflen, *s);\n \n     return NULL;\n }\n@@\
    \ -1461,7 +1468,7 @@ did_set_comments(optset_T *args)\n \t    if (vim_strchr((char_u\
    \ *)COM_ALL, *s) == NULL\n \t\t    && !VIM_ISDIGIT(*s) && *s != '-')\n \t    {\n\
    -\t\terrmsg = illegal_char(args->os_errbuf, *s);\n+\t\terrmsg = illegal_char(args->os_errbuf,\
    \ args->os_errbuflen, *s);\n \t\tbreak;\n \t    }\n \t    ++s;\n@@ -1517,7 +1524,7\
    \ @@ did_set_complete(optset_T *args)\n \tif (!*s)\n \t    break;\n \tif (vim_strchr((char_u\
    \ *)\".wbuksid]tU\", *s) == NULL)\n-\t    return illegal_char(args->os_errbuf,\
    \ *s);\n+\t    return illegal_char(args->os_errbuf, args->os_errbuflen, *s);\n\
    \ \tif (*++s != NUL && *s != ',' && *s != ' ')\n \t{\n \t    if (s[-1] == 'k'\
    \ || s[-1] == 's')\n@@ -1534,7 +1541,7 @@ did_set_complete(optset_T *args)\n \t\
    \    {\n \t\tif (args->os_errbuf != NULL)\n \t\t{\n-\t\t    sprintf((char *)args->os_errbuf,\n\
    +\t\t    snprintf((char *)args->os_errbuf, args->os_errbuflen,\n \t\t\t    _(e_illegal_character_after_chr),\
    \ *--s);\n \t\t    return args->os_errbuf;\n \t\t}\n@@ -1634,7 +1641,8 @@ did_set_concealcursor(optset_T\
    \ *args)\n {\n     char_u\t**varp = (char_u **)args->os_varp;\n \n-    return\
    \ did_set_option_listflag(*varp, (char_u *)COCU_ALL, args->os_errbuf);\n+    return\
    \ did_set_option_listflag(*varp, (char_u *)COCU_ALL, args->os_errbuf,\n+\t\t \
    \   args->os_errbuflen);\n }\n \n     int\n@@ -1652,7 +1660,8 @@ did_set_cpoptions(optset_T\
    \ *args)\n {\n     char_u\t**varp = (char_u **)args->os_varp;\n \n-    return\
    \ did_set_option_listflag(*varp, (char_u *)CPO_ALL, args->os_errbuf);\n+    return\
    \ did_set_option_listflag(*varp, (char_u *)CPO_ALL, args->os_errbuf,\n+\t\t  \
    \  args->os_errbuflen);\n }\n \n     int\n@@ -2281,7 +2290,8 @@ did_set_formatoptions(optset_T\
    \ *args)\n {\n     char_u\t**varp = (char_u **)args->os_varp;\n \n-    return\
    \ did_set_option_listflag(*varp, (char_u *)FO_ALL, args->os_errbuf);\n+    return\
    \ did_set_option_listflag(*varp, (char_u *)FO_ALL, args->os_errbuf,\n+\t\t   \
    \ args->os_errbuflen);\n }\n \n     int\n@@ -2422,7 +2432,8 @@ did_set_guioptions(optset_T\
    \ *args)\n     char_u\t**varp = (char_u **)args->os_varp;\n     char *errmsg;\n\
    \ \n-    errmsg = did_set_option_listflag(*varp, (char_u *)GO_ALL, args->os_errbuf);\n\
    +    errmsg = did_set_option_listflag(*varp, (char_u *)GO_ALL, args->os_errbuf,\n\
    +\t\t    args->os_errbuflen);\n     if (errmsg != NULL)\n \treturn errmsg;\n \n\
    @@ -2926,8 +2937,8 @@ did_set_mouse(optset_T *args)\n {\n     char_u\t**varp =\
    \ (char_u **)args->os_varp;\n \n-    return did_set_option_listflag(*varp, (char_u\
    \ *)MOUSE_ALL,\n-\t\t\t\t\t\t\targs->os_errbuf);\n+    return did_set_option_listflag(*varp,\
    \ (char_u *)MOUSE_ALL, args->os_errbuf,\n+\t\t    args->os_errbuflen);\n }\n \n\
    \     int\n@@ -3364,7 +3375,8 @@ did_set_shortmess(optset_T *args)\n {\n     char_u\t\
    **varp = (char_u **)args->os_varp;\n \n-    return did_set_option_listflag(*varp,\
    \ (char_u *)SHM_ALL, args->os_errbuf);\n+    return did_set_option_listflag(*varp,\
    \ (char_u *)SHM_ALL, args->os_errbuf,\n+\t\t    args->os_errbuflen);\n }\n \n\
    \     int\n@@ -4030,7 +4042,7 @@ did_set_viminfo(optset_T *args)\n \t// Check\
    \ it's a valid character\n \tif (vim_strchr((char_u *)\"!\\\"%'/:<@cfhnrs\", *s)\
    \ == NULL)\n \t{\n-\t    errmsg = illegal_char(args->os_errbuf, *s);\n+\t    errmsg\
    \ = illegal_char(args->os_errbuf, args->os_errbuflen, *s);\n \t    break;\n \t\
    }\n \tif (*s == 'n')\t// name is always last one\n@@ -4057,7 +4069,7 @@ did_set_viminfo(optset_T\
    \ *args)\n \t    {\n \t\tif (args->os_errbuf != NULL)\n \t\t{\n-\t\t    sprintf(args->os_errbuf,\n\
    +\t\t    snprintf(args->os_errbuf, args->os_errbuflen,\n \t\t\t    _(e_missing_number_after_angle_str_angle),\n\
    \ \t\t\t    transchar_byte(*(s - 1)));\n \t\t    errmsg = args->os_errbuf;\n@@\
    \ -4140,7 +4152,8 @@ did_set_whichwrap(optset_T *args)\n \n     // Add ',' to\
    \ the list flags because 'whichwrap' is a flag\n     // list that is comma-separated.\n\
    -    return did_set_option_listflag(*varp, (char_u *)(WW_ALL \",\"), args->os_errbuf);\n\
    +    return did_set_option_listflag(*varp, (char_u *)(WW_ALL \",\"),\n+\t\t  \
    \  args->os_errbuf, args->os_errbuflen);\n }\n \n     int\n@@ -4341,6 +4354,7\
    \ @@ did_set_string_option(\n     char_u\t*oldval,\t\t// previous value of the\
    \ option\n     char_u\t*value,\t\t\t// new value of the option\n     char\t*errbuf,\t\
    \t// buffer for errors, or NULL\n+    int\t\terrbuflen,\t\t// length of error\
    \ buffer\n     int\t\topt_flags,\t\t// OPT_LOCAL and/or OPT_GLOBAL\n     set_op_T\
    \    op,\t\t\t// OP_ADDING/OP_PREPENDING/OP_REMOVING\n     int\t\t*value_checked)\t\
    \t// value was checked to be safe, no\n@@ -4385,6 +4399,7 @@ did_set_string_option(\n\
    \ \targs.os_oldval.string = oldval;\n \targs.os_newval.string = value;\n \targs.os_errbuf\
    \ = errbuf;\n+\targs.os_errbuflen = errbuflen;\n \t// Invoke the option specific\
    \ callback function to validate and apply\n \t// the new option value.\n \terrmsg\
    \ = did_set_cb(&args);"
  - "--- a/src/version.c\n+++ b/src/version.c\n@@ -704,6 +704,8 @@ static char *(features[])\
    \ =\n \n static int included_patches[] =\n {   /* Add new patch number below this\
    \ line */\n+/**/\n+    2142,\n /**/\n     2141,\n /**/"
  identifiers: CVE:["CVE-2024-22667"],CWE:["CWE-121"]
  overview: Affected versions of this package are vulnerable to Stack-based Buffer
    Overflow due to improper bounds checking in the `did_set_langmap` function. An
    attacker can cause a buffer overflow and potentially execute arbitrary code by
    supplying a crafted input to the affected function.
  references:
    GitHub Commit: https://github.com/vim/vim/commit/b39b240c386a5a29241415541f1c99e2e6b8ce47
    Vulnerability Report: https://gist.githubusercontent.com/henices/2467e7f22dcc2aa97a2453e197b55a0c/raw/7b54bccc9a129c604fb139266f4497ab7aaa94c7/gistfile1.txt
  title: Stack-based Buffer Overflow
- diff_content:
  - "--- a/src/lib/OpenEXRCore/decoding.c\n+++ b/src/lib/OpenEXRCore/decoding.c\n\
    @@ -288,6 +288,9 @@ default_decompress_chunk (exr_decode_pipeline_t* decode)\n\
    \         uint64_t sampsize =\n             (((uint64_t) decode->chunk.width)\
    \ *\n              ((uint64_t) decode->chunk.height));\n+\n+        if ((decode->decode_flags\
    \ & EXR_DECODE_SAMPLE_COUNTS_AS_INDIVIDUAL))\n+            sampsize += 1;\n  \
    \       sampsize *= sizeof (int32_t);\n \n         rv = decompress_data (\n@@\
    \ -340,7 +343,7 @@ unpack_sample_table (\n     exr_result_t rv           = EXR_ERR_SUCCESS;\n\
    \     int32_t      w            = decode->chunk.width;\n     int32_t      h  \
    \          = decode->chunk.height;\n-    int32_t      totsamp      = 0;\n+   \
    \ uint64_t     totsamp      = 0;\n     int32_t*     samptable    = decode->sample_count_table;\n\
    \     size_t       combSampSize = 0;\n \n@@ -351,38 +354,44 @@ unpack_sample_table\
    \ (\n     {\n         for (int32_t y = 0; y < h; ++y)\n         {\n+         \
    \   int32_t *cursampline = samptable + y * w;\n             int32_t prevsamp =\
    \ 0;\n             for (int32_t x = 0; x < w; ++x)\n             {\n         \
    \        int32_t nsamps =\n-                    (int32_t) one_to_native32 ((uint32_t)\
    \ samptable[y * w + x]);\n-                if (nsamps < 0) return EXR_ERR_INVALID_SAMPLE_DATA;\n\
    -                samptable[y * w + x] = nsamps - prevsamp;\n-                prevsamp\
    \             = nsamps;\n+                    (int32_t) one_to_native32 ((uint32_t)\
    \ cursampline[x]);\n+                if (nsamps < prevsamp) return EXR_ERR_INVALID_SAMPLE_DATA;\n\
    +\n+                cursampline[x] = nsamps - prevsamp;\n+                prevsamp\
    \       = nsamps;\n             }\n-            totsamp += prevsamp;\n+      \
    \      totsamp += (uint64_t)prevsamp;\n         }\n-        samptable[w * h] =\
    \ totsamp;\n+        if (totsamp >= (uint64_t)INT32_MAX)\n+            return\
    \ EXR_ERR_INVALID_SAMPLE_DATA;\n+        samptable[w * h] = (int32_t)totsamp;\n\
    \     }\n     else\n     {\n         for (int32_t y = 0; y < h; ++y)\n       \
    \  {\n+            int32_t *cursampline = samptable + y * w;\n             int32_t\
    \ prevsamp = 0;\n             for (int32_t x = 0; x < w; ++x)\n             {\n\
    \                 int32_t nsamps =\n-                    (int32_t) one_to_native32\
    \ ((uint32_t) samptable[y * w + x]);\n-                if (nsamps < 0) return\
    \ EXR_ERR_INVALID_SAMPLE_DATA;\n-                samptable[y * w + x] = nsamps;\n\
    -                prevsamp             = nsamps;\n+                    (int32_t)\
    \ one_to_native32 ((uint32_t) cursampline[x]);\n+                if (nsamps <\
    \ prevsamp) return EXR_ERR_INVALID_SAMPLE_DATA;\n+\n+                cursampline[x]\
    \ = nsamps;\n+                prevsamp = nsamps;\n             }\n-          \
    \  totsamp += prevsamp;\n+\n+            totsamp += (uint64_t)prevsamp;\n    \
    \     }\n     }\n \n-    if (totsamp < 0 ||\n-        (((uint64_t) totsamp) *\
    \ combSampSize) > decode->chunk.unpacked_size)\n+    if ((totsamp * combSampSize)\
    \ > decode->chunk.unpacked_size)\n     {\n         rv = pctxt->report_error (\n\
    \             pctxt, EXR_ERR_INVALID_SAMPLE_DATA, \"Corrupt sample count table\"\
    );"
  - "--- a/src/lib/OpenEXRCore/unpack.c\n+++ b/src/lib/OpenEXRCore/unpack.c\n@@ -1196,9\
    \ +1196,10 @@ generic_unpack_deep_pointers (exr_decode_pipeline_t* decode)\n \
    \                if (outpix)\n                 {\n                     uint8_t*\
    \ cdata = outpix;\n+\n                     UNPACK_SAMPLES (samps)\n          \
    \       }\n-                srcbuffer += bpc * samps;\n+                srcbuffer\
    \ += ((size_t) bpc) * ((size_t) samps);\n             }\n         }\n        \
    \ sampbuffer += w;\n@@ -1263,7 +1266,7 @@ generic_unpack_deep (exr_decode_pipeline_t*\
    \ decode)\n \n                 UNPACK_SAMPLES (samps)\n \n-                srcbuffer\
    \ += bpc * samps;\n+                srcbuffer += ((size_t) bpc) * ((size_t) samps);\n\
    \                 if (incr_tot) totsamps += (size_t) samps;\n             }\n\
    \         }\n@@ -1301,7 +1304,7 @@ internal_exr_match_decode (\n \n     if (isdeep)\n\
    \     {\n-        if ((decode->decode_flags & EXR_DECODE_SAMPLE_COUNTS_AS_INDIVIDUAL))\n\
    +        if ((decode->decode_flags & EXR_DECODE_NON_IMAGE_DATA_AS_POINTERS))\n\
    \             return &generic_unpack_deep_pointers;\n         return &generic_unpack_deep;\n\
    \     }"
  - "--- a/src/lib/OpenEXRUtil/ImfCheckFile.cpp\n+++ b/src/lib/OpenEXRUtil/ImfCheckFile.cpp\n\
    @@ -1200,13 +1200,88 @@ runChecks (T& source, bool reduceMemory, bool reduceTime)\n\
    \     return threw;\n }\n \n+// This is not entirely needed in that the chunk\
    \ info has the\n+// total unpacked_size field which can be used for allocation\n\
    +// but this adds an additional point to use when debugging issues.\n+static exr_result_t\n\
    +realloc_deepdata(exr_decode_pipeline_t* decode)\n+{\n+    int32_t w = decode->chunk.width;\n\
    +    int32_t h = decode->chunk.height;\n+    uint64_t totsamps = 0, bytes = 0;\n\
    +    const int32_t *sampbuffer = decode->sample_count_table;\n+    std::vector<uint8_t>*\
    \ ud = static_cast<std::vector<uint8_t>*>(\n+        decode->decoding_user_data);\n\
    +\n+    if ( ! ud )\n+    {\n+        for (int c = 0; c < decode->channel_count;\
    \ c++)\n+        {\n+            exr_coding_channel_info_t& outc = decode->channels[c];\n\
    +            outc.decode_to_ptr              = NULL;\n+            outc.user_pixel_stride\
    \          = outc.user_bytes_per_element;\n+            outc.user_line_stride\
    \           = 0;\n+        }\n+        return EXR_ERR_SUCCESS;\n+    }\n+\n+ \
    \   if ((decode->decode_flags &\n+         EXR_DECODE_SAMPLE_COUNTS_AS_INDIVIDUAL))\n\
    +    {\n+        for (int32_t y = 0; y < h; ++y)\n+        {\n+            for\
    \ (int x = 0; x < w; ++x)\n+                totsamps += sampbuffer[x];\n+    \
    \        sampbuffer += w;\n+        }\n+    }\n+    else\n+    {\n+        for\
    \ (int32_t y = 0; y < h; ++y)\n+            totsamps += sampbuffer[y*w + w - 1];\n\
    +    }\n+\n+    for (int c = 0; c < decode->channel_count; c++)\n+    {\n+   \
    \     exr_coding_channel_info_t& outc = decode->channels[c];\n+        bytes +=\
    \ totsamps * outc.user_bytes_per_element;\n+    }\n+\n+    if (bytes >= gMaxBytesPerDeepScanline\
    \ * h)\n+    {\n+        for (int c = 0; c < decode->channel_count; c++)\n+  \
    \      {\n+            exr_coding_channel_info_t& outc = decode->channels[c];\n\
    +            outc.decode_to_ptr              = NULL;\n+            outc.user_pixel_stride\
    \          = outc.user_bytes_per_element;\n+            outc.user_line_stride\
    \           = 0;\n+        }\n+        return EXR_ERR_SUCCESS;\n+    }\n+\n+ \
    \   if (ud->size () < bytes)\n+        ud->resize (bytes);\n+\n+    uint8_t* dptr\
    \ = &((*ud)[0]);\n+    for (int c = 0; c < decode->channel_count; c++)\n+    {\n\
    +        exr_coding_channel_info_t& outc = decode->channels[c];\n+        outc.decode_to_ptr\
    \              = dptr;\n+        outc.user_pixel_stride          = outc.user_bytes_per_element;\n\
    +        outc.user_line_stride           = 0;\n+\n+        dptr += totsamps *\
    \ (uint64_t) outc.user_bytes_per_element;\n+    }\n+    return EXR_ERR_SUCCESS;\n\
    +}\n+\n ////////////////////////////////////////\n \n bool\n readCoreScanlinePart\
    \ (\n     exr_context_t f, int part, bool reduceMemory, bool reduceTime)\n {\n\
    -    exr_result_t     rv;\n+    exr_result_t     rv, frv;\n     exr_attr_box2i_t\
    \ datawin;\n     rv = exr_get_data_window (f, part, &datawin);\n     if (rv !=\
    \ EXR_ERR_SUCCESS) return true;\n@@ -1224,6 +1299,8 @@ readCoreScanlinePart (\n\
    \     rv = exr_get_scanlines_per_chunk (f, part, &lines_per_chunk);\n     if (rv\
    \ != EXR_ERR_SUCCESS) return true;\n \n+    frv = rv;\n+\n     for (uint64_t chunk\
    \ = 0; chunk < height; chunk += lines_per_chunk)\n     {\n         exr_chunk_info_t\
    \ cinfo = {0};\n@@ -1232,6 +1309,7 @@ readCoreScanlinePart (\n         rv = exr_read_scanline_chunk_info\
    \ (f, part, y, &cinfo);\n         if (rv != EXR_ERR_SUCCESS)\n         {\n+  \
    \          frv = rv;\n             if (reduceTime) break;\n             continue;\n\
    \         }\n@@ -1253,48 +1331,66 @@ readCoreScanlinePart (\n                \
    \          (uint64_t) lines_per_chunk;\n             }\n \n-            // TODO:\
    \ check we are supposed to multiple by lines per chunk above\n             doread\
    \ = true;\n-            if (reduceMemory && bytes >= gMaxBytesPerScanline) doread\
    \ = false;\n \n-            if (doread) imgdata.resize (bytes);\n+           \
    \ if (cinfo.type == EXR_STORAGE_DEEP_SCANLINE)\n+            {\n+            \
    \    decoder.decoding_user_data       = &imgdata;\n+                decoder.realloc_nonimage_data_fn\
    \ = &realloc_deepdata;\n+            }\n+            else\n+            {\n+ \
    \               if (reduceMemory && bytes >= gMaxBytesPerScanline) doread = false;\n\
    +\n+                if (doread) imgdata.resize (bytes);\n+            }\n    \
    \         rv = exr_decoding_choose_default_routines (f, part, &decoder);\n-  \
    \          if (rv != EXR_ERR_SUCCESS) break;\n+            if (rv != EXR_ERR_SUCCESS)\n\
    +            {\n+                frv = rv;\n+                break;\n+       \
    \     }\n         }\n         else\n         {\n             rv = exr_decoding_update\
    \ (f, part, &cinfo, &decoder);\n             if (rv != EXR_ERR_SUCCESS)\n    \
    \         {\n+                frv = rv;\n                 if (reduceTime) break;\n\
    \                 continue;\n             }\n         }\n \n         if (doread)\n\
    \         {\n-            uint8_t* dptr = &(imgdata[0]);\n-            for (int\
    \ c = 0; c < decoder.channel_count; c++)\n+            if (cinfo.type != EXR_STORAGE_DEEP_SCANLINE)\n\
    \             {\n-                exr_coding_channel_info_t& outc = decoder.channels[c];\n\
    -                outc.decode_to_ptr              = dptr;\n-                outc.user_pixel_stride\
    \          = outc.user_bytes_per_element;\n-                outc.user_line_stride\
    \ = outc.user_pixel_stride * width;\n-                dptr += width * (uint64_t)\
    \ outc.user_bytes_per_element *\n+                uint8_t* dptr = &(imgdata[0]);\n\
    +                for (int c = 0; c < decoder.channel_count; c++)\n+          \
    \      {\n+                    exr_coding_channel_info_t& outc = decoder.channels[c];\n\
    +                    outc.decode_to_ptr              = dptr;\n+              \
    \      outc.user_pixel_stride          = outc.user_bytes_per_element;\n+     \
    \               outc.user_line_stride           = outc.user_pixel_stride * width;\n\
    +\n+                    dptr += width * (uint64_t) outc.user_bytes_per_element\
    \ *\n                         (uint64_t) lines_per_chunk;\n+                }\n\
    \             }\n \n             rv = exr_decoding_run (f, part, &decoder);\n\
    \             if (rv != EXR_ERR_SUCCESS)\n             {\n+                frv\
    \ = rv;\n                 if (reduceTime) break;\n             }\n         }\n\
    \     }\n \n     exr_decoding_destroy (f, &decoder);\n \n-    return (rv != EXR_ERR_SUCCESS);\n\
    +    return (frv != EXR_ERR_SUCCESS);\n }\n \n ////////////////////////////////////////\n\
    @@ -1303,7 +1399,7 @@ bool\n readCoreTiledPart (\n     exr_context_t f, int part,\
    \ bool reduceMemory, bool reduceTime)\n {\n-    exr_result_t rv;\n+    exr_result_t\
    \ rv, frv;\n \n     exr_attr_box2i_t datawin;\n     rv = exr_get_data_window (f,\
    \ part, &datawin);\n@@ -1321,6 +1417,7 @@ readCoreTiledPart (\n     rv = exr_get_tile_levels\
    \ (f, part, &levelsx, &levelsy);\n     if (rv != EXR_ERR_SUCCESS) return true;\n\
    \ \n+    frv = rv;\n     bool keepgoing = true;\n     for (int32_t ylevel = 0;\
    \ keepgoing && ylevel < levelsy; ++ylevel)\n     {\n@@ -1330,6 +1427,7 @@ readCoreTiledPart\
    \ (\n             rv = exr_get_level_sizes (f, part, xlevel, ylevel, &levw, &levh);\n\
    \             if (rv != EXR_ERR_SUCCESS)\n             {\n+                frv\
    \ = rv;\n                 if (reduceTime)\n                 {\n              \
    \       keepgoing = false;\n@@ -1342,6 +1440,7 @@ readCoreTiledPart (\n      \
    \       rv = exr_get_tile_sizes (f, part, xlevel, ylevel, &curtw, &curth);\n \
    \            if (rv != EXR_ERR_SUCCESS)\n             {\n+                frv\
    \ = rv;\n                 if (reduceTime)\n                 {\n              \
    \       keepgoing = false;\n@@ -1371,6 +1470,7 @@ readCoreTiledPart (\n      \
    \                   f, part, tx, ty, xlevel, ylevel, &cinfo);\n              \
    \       if (rv != EXR_ERR_SUCCESS)\n                     {\n+                \
    \        frv = rv;\n                         if (reduceTime)\n               \
    \          {\n                             keepgoing = false;\n@@ -1385,6 +1485,7\
    \ @@ readCoreTiledPart (\n                             exr_decoding_initialize\
    \ (f, part, &cinfo, &decoder);\n                         if (rv != EXR_ERR_SUCCESS)\n\
    \                         {\n+                            frv = rv;\n        \
    \                     keepgoing = false;\n                             break;\n\
    \                         }\n@@ -1406,14 +1507,23 @@ readCoreTiledPart (\n   \
    \                      }\n \n                         doread = true;\n-      \
    \                  if (reduceMemory && bytes >= gMaxTileBytes)\n-            \
    \                doread = false;\n+                        if (cinfo.type == EXR_STORAGE_DEEP_TILED)\n\
    +                        {\n+                            decoder.decoding_user_data\
    \       = &tiledata;\n+                            decoder.realloc_nonimage_data_fn\
    \ = &realloc_deepdata;\n+                        }\n+                        else\n\
    +                        {\n+                            if (reduceMemory && bytes\
    \ >= gMaxTileBytes)\n+                                doread = false;\n \n-  \
    \                      if (doread) tiledata.resize (bytes);\n+               \
    \             if (doread) tiledata.resize (bytes);\n+                        }\n\
    \                         rv = exr_decoding_choose_default_routines (\n      \
    \                       f, part, &decoder);\n                         if (rv !=\
    \ EXR_ERR_SUCCESS)\n                         {\n+                            frv\
    \ = rv;\n                             keepgoing = false;\n                   \
    \          break;\n                         }\n@@ -1423,6 +1533,7 @@ readCoreTiledPart\
    \ (\n                         rv = exr_decoding_update (f, part, &cinfo, &decoder);\n\
    \                         if (rv != EXR_ERR_SUCCESS)\n                       \
    \  {\n+                            frv = rv;\n                             if\
    \ (reduceTime)\n                             {\n                             \
    \    keepgoing = false;\n@@ -1434,24 +1545,28 @@ readCoreTiledPart (\n \n    \
    \                 if (doread)\n                     {\n-                     \
    \   uint8_t* dptr = &(tiledata[0]);\n-                        for (int c = 0;\
    \ c < decoder.channel_count; c++)\n+                        if (cinfo.type !=\
    \ EXR_STORAGE_DEEP_TILED)\n                         {\n-                     \
    \       exr_coding_channel_info_t& outc =\n-                                decoder.channels[c];\n\
    -                            outc.decode_to_ptr = dptr;\n-                   \
    \         outc.user_pixel_stride =\n-                                outc.user_bytes_per_element;\n\
    -                            outc.user_line_stride =\n-                      \
    \          outc.user_pixel_stride * curtw;\n-                            dptr\
    \ += (uint64_t) curtw *\n+                            uint8_t* dptr = &(tiledata[0]);\n\
    +                            for (int c = 0; c < decoder.channel_count; c++)\n\
    +                            {\n+                                exr_coding_channel_info_t&\
    \ outc =\n+                                    decoder.channels[c];\n+       \
    \                         outc.decode_to_ptr = dptr;\n+                      \
    \          outc.user_pixel_stride =\n+                                    outc.user_bytes_per_element;\n\
    +                                outc.user_line_stride =\n+                  \
    \                  outc.user_pixel_stride * curtw;\n+                        \
    \        dptr += (uint64_t) curtw *\n                                     (uint64_t)\
    \ outc.user_bytes_per_element *\n                                     (uint64_t)\
    \ curth;\n+                            }\n                         }\n \n    \
    \                     rv = exr_decoding_run (f, part, &decoder);\n           \
    \              if (rv != EXR_ERR_SUCCESS)\n                         {\n+     \
    \                       frv = rv;\n                             if (reduceTime)\n\
    \                             {\n                                 keepgoing =\
    \ false;\n@@ -1486,17 +1601,14 @@ checkCoreFile (exr_context_t f, bool reduceMemory,\
    \ bool reduceTime)\n         rv = exr_get_storage (f, p, &store);\n         if\
    \ (rv != EXR_ERR_SUCCESS) return true;\n \n-        // TODO: Need to fill this\
    \ in\n-        if (store == EXR_STORAGE_DEEP_SCANLINE ||\n-            store ==\
    \ EXR_STORAGE_DEEP_TILED)\n-            continue;\n-\n-        if (store == EXR_STORAGE_SCANLINE)\n\
    +        if (store == EXR_STORAGE_SCANLINE ||\n+            store == EXR_STORAGE_DEEP_SCANLINE)\n\
    \         {\n             if (readCoreScanlinePart (f, p, reduceMemory, reduceTime))\n\
    \                 return true;\n         }\n-        else if (store == EXR_STORAGE_TILED)\n\
    +        else if (store == EXR_STORAGE_TILED ||\n+                 store == EXR_STORAGE_DEEP_TILED)\n\
    \         {\n             if (readCoreTiledPart (f, p, reduceMemory, reduceTime))\
    \ return true;\n         }"
  identifiers: CVE:["CVE-2023-5841"],CWE:["CWE-122"]
  overview: Affected versions of this package are vulnerable to Heap-based Buffer
    Overflow due to improper handling of scanline deep data during image parsing.
    An attacker can execute arbitrary code or perform unauthorized read/write operations
    on the system by submitting a specially crafted image file.
  references:
    GitHub Commit: https://github.com/AcademySoftwareFoundation/openexr/commit/8bedf106ef14d97c6e383c1052659e4f3b5b487d
    GitHub Release: https://github.com/AcademySoftwareFoundation/openexr/releases/tag/v3.2.2-rc
    RedHat Bugzilla Bug: https://bugzilla.redhat.com/show_bug.cgi?id=2262397
    Vulnerability Advisory: https://takeonme.org/cves/CVE-2023-5841.html#
  title: Heap-based Buffer Overflow
- diff_content:
  - "--- a/lib/gvc/gvconfig.c\n+++ b/lib/gvc/gvconfig.c\n@@ -190,6 +190,10 @@ static\
    \ int gvconfig_plugin_install_from_config(GVC_t * gvc, char *s)\n \tdo {\n \t\
    \    const char *api = token(&nest, &s);\n \t    const api_t gv_api = gvplugin_api(api);\n\
    +\t    if (gv_api == (api_t)-1) {\n+\t\tagerr(AGERR, \"config error: %s %s not\
    \ found\\n\", package_path, api);\n+\t\treturn 0;\n+\t    }\n \t    do {\n \t\t\
    if (nest == 2) {\n \t\t    type = token(&nest, &s);\n"
  identifiers: CVE:["CVE-2023-46045"],CWE:["CWE-125"]
  overview: 'Affected versions of this package are vulnerable to Out-of-bounds Read
    due to improper handling of a crafted `config6a` file. An attacker can read memory
    contents that may contain sensitive information by supplying a maliciously crafted
    file. '
  references:
    GitLab Commit: https://gitlab.com/graphviz/graphviz/-/commit/a95f977f5d809915ec4b14836d2b5b7f5e74881e
    GitLab Issue: https://gitlab.com/graphviz/graphviz/-/issues/2441
  title: Out-of-bounds Read
- diff_content:
  - "--- a/expat/lib/xmlparse.c\n+++ b/expat/lib/xmlparse.c\n@@ -416,7 +416,7 @@ enum\
    \ XML_Account {\n   XML_ACCOUNT_NONE              /* i.e. do not account, was\
    \ accounted already */\n };\n \n-#ifdef XML_DTD\n+#if defined(XML_DTD) || XML_GE\
    \ == 1\n typedef unsigned long long XmlBigCount;\n typedef struct accounting {\n\
    \   XmlBigCount countBytesDirect;\n@@ -432,7 +432,7 @@ typedef struct entity_stats\
    \ {\n   unsigned int maximumDepthSeen;\n   unsigned long debugLevel;\n } ENTITY_STATS;\n\
    -#endif /* XML_DTD */\n+#endif /* defined(XML_DTD) || XML_GE == 1 */\n \n typedef\
    \ enum XML_Error PTRCALL Processor(XML_Parser parser, const char *start,\n   \
    \                                       const char *end, const char **endPtr);\n\
    @@ -570,7 +570,7 @@ static XML_Parser parserCreate(const XML_Char *encodingName,\n\
    \ \n static void parserInit(XML_Parser parser, const XML_Char *encodingName);\n\
    \ \n-#ifdef XML_DTD\n+#if defined(XML_DTD) || XML_GE == 1\n static float accountingGetCurrentAmplification(XML_Parser\
    \ rootParser);\n static void accountingReportStats(XML_Parser originParser, const\
    \ char *epilog);\n static void accountingOnAbort(XML_Parser originParser);\n@@\
    \ -593,7 +593,7 @@ static void entityTrackingOnClose(XML_Parser parser, ENTITY\
    \ *entity,\n \n static XML_Parser getRootParserOf(XML_Parser parser,\n       \
    \                            unsigned int *outLevelDiff);\n-#endif /* XML_DTD\
    \ */\n+#endif /* defined(XML_DTD) || XML_GE == 1 */\n \n static unsigned long\
    \ getDebugLevel(const char *variableName,\n                                  \
    \  unsigned long defaultDebugLevel);\n@@ -718,7 +718,7 @@ struct XML_ParserStruct\
    \ {\n   enum XML_ParamEntityParsing m_paramEntityParsing;\n #endif\n   unsigned\
    \ long m_hash_secret_salt;\n-#ifdef XML_DTD\n+#if defined(XML_DTD) || XML_GE ==\
    \ 1\n   ACCOUNTING m_accounting;\n   ENTITY_STATS m_entity_stats;\n #endif\n@@\
    \ -1178,7 +1178,7 @@ parserInit(XML_Parser parser, const XML_Char *encodingName)\
    \ {\n #endif\n   parser->m_hash_secret_salt = 0;\n \n-#ifdef XML_DTD\n+#if defined(XML_DTD)\
    \ || XML_GE == 1\n   memset(&parser->m_accounting, 0, sizeof(ACCOUNTING));\n \
    \  parser->m_accounting.debugLevel = getDebugLevel(\"EXPAT_ACCOUNTING_DEBUG\"\
    , 0u);\n   parser->m_accounting.maximumAmplificationFactor\n@@ -2534,8 +2534,9\
    \ @@ XML_GetFeatureList(void) {\n #ifdef XML_ATTR_INFO\n     {XML_FEATURE_ATTR_INFO,\
    \ XML_L(\"XML_ATTR_INFO\"), 0},\n #endif\n-#ifdef XML_DTD\n-    /* Added in Expat\
    \ 2.4.0. */\n+#if defined(XML_DTD) || XML_GE == 1\n+    /* Added in Expat 2.4.0\
    \ for XML_DTD defined and\n+     * added in Expat 2.6.0 for XML_GE == 1. */\n\
    \     {XML_FEATURE_BILLION_LAUGHS_ATTACK_PROTECTION_MAXIMUM_AMPLIFICATION_DEFAULT,\n\
    \      XML_L(\"XML_BLAP_MAX_AMP\"),\n      (long int)\n@@ -2550,7 +2551,7 @@ XML_GetFeatureList(void)\
    \ {\n   return features;\n }\n \n-#ifdef XML_DTD\n+#if defined(XML_DTD) || XML_GE\
    \ == 1\n XML_Bool XMLCALL\n XML_SetBillionLaughsAttackProtectionMaximumAmplification(\n\
    \     XML_Parser parser, float maximumAmplificationFactor) {\n@@ -2572,7 +2573,7\
    \ @@ XML_SetBillionLaughsAttackProtectionActivationThreshold(\n   parser->m_accounting.activationThresholdBytes\
    \ = activationThresholdBytes;\n   return XML_TRUE;\n }\n-#endif /* XML_DTD */\n\
    +#endif /* defined(XML_DTD) || XML_GE == 1 */\n \n /* Initially tag->rawName always\
    \ points into the parse buffer;\n    for those TAG instances opened while the\
    \ current parse buffer was\n@@ -2658,13 +2659,13 @@ externalEntityInitProcessor2(XML_Parser\
    \ parser, const char *start,\n   int tok = XmlContentTok(parser->m_encoding, start,\
    \ end, &next);\n   switch (tok) {\n   case XML_TOK_BOM:\n-#ifdef XML_DTD\n+#if\
    \ defined(XML_DTD) || XML_GE == 1\n     if (! accountingDiffTolerated(parser,\
    \ tok, start, next, __LINE__,\n                                   XML_ACCOUNT_DIRECT))\
    \ {\n       accountingOnAbort(parser);\n       return XML_ERROR_AMPLIFICATION_LIMIT_BREACH;\n\
    \     }\n-#endif /* XML_DTD */\n+#endif /* defined(XML_DTD) || XML_GE == 1 */\n\
    \ \n     /* If we are at the end of the buffer, this would cause the next stage,\n\
    \        i.e. externalEntityInitProcessor3, to pass control directly to\n@@ -2778,7\
    \ +2779,7 @@ doContent(XML_Parser parser, int startTagLevel, const ENCODING *enc,\n\
    \   for (;;) {\n     const char *next = s; /* XmlContentTok doesn't always set\
    \ the last arg */\n     int tok = XmlContentTok(enc, s, end, &next);\n-#ifdef\
    \ XML_DTD\n+#if defined(XML_DTD) || XML_GE == 1\n     const char *accountAfter\n\
    \         = ((tok == XML_TOK_TRAILING_RSQB) || (tok == XML_TOK_TRAILING_CR))\n\
    \               ? (haveMore ? s /* i.e. 0 bytes */ : end)\n@@ -2844,14 +2845,14\
    \ @@ doContent(XML_Parser parser, int startTagLevel, const ENCODING *enc,\n  \
    \     XML_Char ch = (XML_Char)XmlPredefinedEntityName(\n           enc, s + enc->minBytesPerChar,\
    \ next - enc->minBytesPerChar);\n       if (ch) {\n-#ifdef XML_DTD\n+#if defined(XML_DTD)\
    \ || XML_GE == 1\n         /* NOTE: We are replacing 4-6 characters original input\
    \ for 1 character\n          *       so there is no amplification and hence recording\
    \ without\n          *       protection. */\n         accountingDiffTolerated(parser,\
    \ tok, (char *)&ch,\n                                 ((char *)&ch) + sizeof(XML_Char),\
    \ __LINE__,\n                                 XML_ACCOUNT_ENTITY_EXPANSION);\n\
    -#endif /* XML_DTD */\n+#endif /* defined(XML_DTD) || XML_GE == 1 */\n       \
    \  if (parser->m_characterDataHandler)\n           parser->m_characterDataHandler(parser->m_handlerArg,\
    \ &ch, 1);\n         else if (parser->m_defaultHandler)\n@@ -4053,7 +4054,7 @@\
    \ doCdataSection(XML_Parser parser, const ENCODING *enc, const char **startPtr,\n\
    \   for (;;) {\n     const char *next = s; /* in case of XML_TOK_NONE or XML_TOK_PARTIAL\
    \ */\n     int tok = XmlCdataSectionTok(enc, s, end, &next);\n-#ifdef XML_DTD\n\
    +#if defined(XML_DTD) || XML_GE == 1\n     if (! accountingDiffTolerated(parser,\
    \ tok, s, next, __LINE__, account)) {\n       accountingOnAbort(parser);\n   \
    \    return XML_ERROR_AMPLIFICATION_LIMIT_BREACH;\n@@ -4205,7 +4206,7 @@ doIgnoreSection(XML_Parser\
    \ parser, const ENCODING *enc, const char **startPtr,\n   *eventPP = s;\n   *startPtr\
    \ = NULL;\n   tok = XmlIgnoreSectionTok(enc, s, end, &next);\n-#  ifdef XML_DTD\n\
    +#  if defined(XML_DTD) || XML_GE == 1\n   if (! accountingDiffTolerated(parser,\
    \ tok, s, next, __LINE__,\n                                 XML_ACCOUNT_DIRECT))\
    \ {\n     accountingOnAbort(parser);\n@@ -4297,7 +4298,7 @@ processXmlDecl(XML_Parser\
    \ parser, int isGeneralTextEntity, const char *s,\n   const XML_Char *storedversion\
    \ = NULL;\n   int standalone = -1;\n \n-#ifdef XML_DTD\n+#if defined(XML_DTD)\
    \ || XML_GE == 1\n   if (! accountingDiffTolerated(parser, XML_TOK_XML_DECL, s,\
    \ next, __LINE__,\n                                 XML_ACCOUNT_DIRECT)) {\n \
    \    accountingOnAbort(parser);\n@@ -4504,7 +4505,7 @@ entityValueInitProcessor(XML_Parser\
    \ parser, const char *s, const char *end,\n        is not valid to have multiple\
    \ BOMs.\n     */\n     else if (tok == XML_TOK_BOM) {\n-#  ifdef XML_DTD\n+# \
    \ if defined(XML_DTD) || XML_GE == 1\n       if (! accountingDiffTolerated(parser,\
    \ tok, s, next, __LINE__,\n                                     XML_ACCOUNT_DIRECT))\
    \ {\n         accountingOnAbort(parser);\n@@ -4720,11 +4721,13 @@ doProlog(XML_Parser\
    \ parser, const ENCODING *enc, const char *s, const char *end,\n       }\n   \
    \  }\n     role = XmlTokenRole(&parser->m_prologState, tok, s, next, enc);\n-#ifdef\
    \ XML_DTD\n+#if defined(XML_DTD) || XML_GE == 1\n     switch (role) {\n     case\
    \ XML_ROLE_INSTANCE_START: // bytes accounted in contentProcessor\n     case XML_ROLE_XML_DECL:\
    \       // bytes accounted in processXmlDecl\n-    case XML_ROLE_TEXT_DECL:  \
    \    // bytes accounted in processXmlDecl\n+#  ifdef XML_DTD\n+    case XML_ROLE_TEXT_DECL:\
    \ // bytes accounted in processXmlDecl\n+#  endif\n       break;\n     default:\n\
    \       if (! accountingDiffTolerated(parser, tok, s, next, __LINE__, account))\
    \ {\n@@ -5661,7 +5664,7 @@ epilogProcessor(XML_Parser parser, const char *s, const\
    \ char *end,\n   for (;;) {\n     const char *next = NULL;\n     int tok = XmlPrologTok(parser->m_encoding,\
    \ s, end, &next);\n-#ifdef XML_DTD\n+#if defined(XML_DTD) || XML_GE == 1\n   \
    \  if (! accountingDiffTolerated(parser, tok, s, next, __LINE__,\n           \
    \                        XML_ACCOUNT_DIRECT)) {\n       accountingOnAbort(parser);\n\
    @@ -5741,7 +5744,7 @@ processInternalEntity(XML_Parser parser, ENTITY *entity,\
    \ XML_Bool betweenDecl) {\n       return XML_ERROR_NO_MEMORY;\n   }\n   entity->open\
    \ = XML_TRUE;\n-#ifdef XML_DTD\n+#if defined(XML_DTD) || XML_GE == 1\n   entityTrackingOnOpen(parser,\
    \ entity, __LINE__);\n #endif\n   entity->processed = 0;\n@@ -5775,9 +5778,9 @@\
    \ processInternalEntity(XML_Parser parser, ENTITY *entity, XML_Bool betweenDecl)\
    \ {\n       entity->processed = (int)(next - textStart);\n       parser->m_processor\
    \ = internalEntityProcessor;\n     } else {\n-#ifdef XML_DTD\n+#if defined(XML_DTD)\
    \ || XML_GE == 1\n       entityTrackingOnClose(parser, entity, __LINE__);\n-#endif\
    \ /* XML_DTD */\n+#endif /* defined(XML_DTD) || XML_GE == 1 */\n       entity->open\
    \ = XML_FALSE;\n       parser->m_openInternalEntities = openEntity->next;\n  \
    \     /* put openEntity back in list of free instances */\n@@ -5826,7 +5829,7\
    \ @@ internalEntityProcessor(XML_Parser parser, const char *s, const char *end,\n\
    \     return result;\n   }\n \n-#ifdef XML_DTD\n+#if defined(XML_DTD) || XML_GE\
    \ == 1\n   entityTrackingOnClose(parser, entity, __LINE__);\n #endif\n   entity->open\
    \ = XML_FALSE;\n@@ -5905,7 +5908,7 @@ appendAttributeValue(XML_Parser parser,\
    \ const ENCODING *enc, XML_Bool isCdata,\n     const char *next\n         = ptr;\
    \ /* XmlAttributeValueTok doesn't always set the last arg */\n     int tok = XmlAttributeValueTok(enc,\
    \ ptr, end, &next);\n-#ifdef XML_DTD\n+#if defined(XML_DTD) || XML_GE == 1\n \
    \    if (! accountingDiffTolerated(parser, tok, ptr, next, __LINE__, account))\
    \ {\n       accountingOnAbort(parser);\n       return XML_ERROR_AMPLIFICATION_LIMIT_BREACH;\n\
    @@ -5970,14 +5973,14 @@ appendAttributeValue(XML_Parser parser, const ENCODING\
    \ *enc, XML_Bool isCdata,\n       XML_Char ch = (XML_Char)XmlPredefinedEntityName(\n\
    \           enc, ptr + enc->minBytesPerChar, next - enc->minBytesPerChar);\n \
    \      if (ch) {\n-#ifdef XML_DTD\n+#if defined(XML_DTD) || XML_GE == 1\n    \
    \     /* NOTE: We are replacing 4-6 characters original input for 1 character\n\
    \          *       so there is no amplification and hence recording without\n\
    \          *       protection. */\n         accountingDiffTolerated(parser, tok,\
    \ (char *)&ch,\n                                 ((char *)&ch) + sizeof(XML_Char),\
    \ __LINE__,\n                                 XML_ACCOUNT_ENTITY_EXPANSION);\n\
    -#endif /* XML_DTD */\n+#endif /* defined(XML_DTD) || XML_GE == 1 */\n       \
    \  if (! poolAppendChar(pool, ch))\n           return XML_ERROR_NO_MEMORY;\n \
    \        break;\n@@ -6055,14 +6058,14 @@ appendAttributeValue(XML_Parser parser,\
    \ const ENCODING *enc, XML_Bool isCdata,\n         enum XML_Error result;\n  \
    \       const XML_Char *textEnd = entity->textPtr + entity->textLen;\n       \
    \  entity->open = XML_TRUE;\n-#ifdef XML_DTD\n+#if defined(XML_DTD) || XML_GE\
    \ == 1\n         entityTrackingOnOpen(parser, entity, __LINE__);\n #endif\n  \
    \       result = appendAttributeValue(parser, parser->m_internalEncoding,\n  \
    \                                     isCdata, (const char *)entity->textPtr,\n\
    \                                       (const char *)textEnd, pool,\n       \
    \                                XML_ACCOUNT_ENTITY_EXPANSION);\n-#ifdef XML_DTD\n\
    +#if defined(XML_DTD) || XML_GE == 1\n         entityTrackingOnClose(parser, entity,\
    \ __LINE__);\n #endif\n         entity->open = XML_FALSE;\n@@ -6118,7 +6121,7\
    \ @@ storeEntityValue(XML_Parser parser, const ENCODING *enc,\n         = entityTextPtr;\
    \ /* XmlEntityValueTok doesn't always set the last arg */\n     int tok = XmlEntityValueTok(enc,\
    \ entityTextPtr, entityTextEnd, &next);\n \n-#ifdef XML_DTD\n+#if defined(XML_DTD)\
    \ || XML_GE == 1\n     if (! accountingDiffTolerated(parser, tok, entityTextPtr,\
    \ next, __LINE__,\n                                   account)) {\n       accountingOnAbort(parser);\n\
    @@ -7669,7 +7672,7 @@ copyString(const XML_Char *s, const XML_Memory_Handling_Suite\
    \ *memsuite) {\n   return result;\n }\n \n-#ifdef XML_DTD\n+#if defined(XML_DTD)\
    \ || XML_GE == 1\n \n static float\n accountingGetCurrentAmplification(XML_Parser\
    \ rootParser) {\n@@ -8400,7 +8403,7 @@ unsignedCharToPrintable(unsigned char c)\
    \ {\n   assert(0); /* never gets here */\n }\n \n-#endif /* XML_DTD */\n+#endif\
    \ /* defined(XML_DTD) || XML_GE == 1 */\n \n static unsigned long\n getDebugLevel(const\
    \ char *variableName, unsigned long defaultDebugLevel) {"
  - "--- a/expat/xmlwf/xmlwf.c\n+++ b/expat/xmlwf/xmlwf.c\n@@ -1096,9 +1096,10 @@\
    \ tmain(int argc, XML_Char **argv) {\n             \" (needs a floating point\
    \ number greater or equal than 1.0)\"));\n         exit(XMLWF_EXIT_USAGE_ERROR);\n\
    \       }\n-#ifndef XML_DTD\n-      ftprintf(stderr, T(\"Warning: Given amplification\
    \ limit ignored\") T(\n-                           \", xmlwf has been compiled\
    \ without DTD support.\\n\"));\n+#if ! defined(XML_DTD) && XML_GE == 0\n+    \
    \  ftprintf(stderr,\n+               T(\"Warning: Given amplification limit ignored\"\
    )\n+                   T(\", xmlwf has been compiled without DTD/GE support.\\\
    n\"));\n #endif\n       break;\n     }\n@@ -1117,9 +1118,10 @@ tmain(int argc,\
    \ XML_Char **argv) {\n         exit(XMLWF_EXIT_USAGE_ERROR);\n       }\n     \
    \  attackThresholdGiven = XML_TRUE;\n-#ifndef XML_DTD\n-      ftprintf(stderr,\
    \ T(\"Warning: Given attack threshold ignored\") T(\n-                       \
    \    \", xmlwf has been compiled without DTD support.\\n\"));\n+#if ! defined(XML_DTD)\
    \ && XML_GE == 0\n+      ftprintf(stderr,\n+               T(\"Warning: Given\
    \ attack threshold ignored\")\n+                   T(\", xmlwf has been compiled\
    \ without DTD/GE support.\\n\"));\n #endif\n       break;\n     }\n@@ -1155,13\
    \ +1157,13 @@ tmain(int argc, XML_Char **argv) {\n     }\n \n     if (attackMaximumAmplification\
    \ != -1.0f) {\n-#ifdef XML_DTD\n+#if defined(XML_DTD) || XML_GE == 1\n       XML_SetBillionLaughsAttackProtectionMaximumAmplification(\n\
    \           parser, attackMaximumAmplification);\n #endif\n     }\n     if (attackThresholdGiven)\
    \ {\n-#ifdef XML_DTD\n+#if defined(XML_DTD) || XML_GE == 1\n       XML_SetBillionLaughsAttackProtectionActivationThreshold(\n\
    \           parser, attackThresholdBytes);\n #else"
  identifiers: CVE:["CVE-2023-52426"],CWE:["CWE-776"]
  overview: Affected versions of this package are vulnerable to Improper Restriction
    of Recursive Entity References in DTDs ('XML Entity Expansion') due to improper
    handling of XML entities when `XML_DTD` is undefined at compile time. An attacker
    can cause a denial of service or possibly have unspecified other impact by submitting
    specially crafted XML data that triggers recursive entity expansion.
  references:
    GitHub Commit: https://github.com/libexpat/libexpat/commit/0f075ec8ecb5e43f8fdca5182f8cca4703da0404
    GitHub PR: https://github.com/libexpat/libexpat/pull/777
  title: Improper Restriction of Recursive Entity References in DTDs ('XML Entity
    Expansion')
- diff_content:
  - "--- a/expat/lib/xmlparse.c\n+++ b/expat/lib/xmlparse.c\n@@ -89,6 +89,7 @@\n #\
    \  endif\n #endif\n \n+#include <stdbool.h>\n #include <stddef.h>\n #include <string.h>\
    \ /* memset(), memcpy() */\n #include <assert.h>\n@@ -212,6 +213,8 @@ typedef\
    \ char ICHAR;\n /* Do safe (NULL-aware) pointer arithmetic */\n #define EXPAT_SAFE_PTR_DIFF(p,\
    \ q) (((p) && (q)) ? ((p) - (q)) : 0)\n \n+#define EXPAT_MIN(a, b) (((a) < (b))\
    \ ? (a) : (b))\n+\n #include \"internal.h\"\n #include \"xmltok.h\"\n #include\
    \ \"xmlrole.h\"\n@@ -624,6 +627,9 @@ static unsigned long getDebugLevel(const\
    \ char *variableName,\n        ? 0                                           \
    \                          \\\n        : ((*((pool)->ptr)++ = c), 1))\n \n+XML_Bool\
    \ g_reparseDeferralEnabledDefault = XML_TRUE; // write ONLY in runtests.c\n+unsigned\
    \ int g_parseAttempts = 0;                    // used for testing only\n+\n struct\
    \ XML_ParserStruct {\n   /* The first member must be m_userData so that the XML_GetUserData\n\
    \      macro works. */\n@@ -647,6 +653,9 @@ struct XML_ParserStruct {\n \n   XML_Index\
    \ m_parseEndByteIndex;\n   const char *m_parseEndPtr;\n+  size_t m_partialTokenBytesBefore;\
    \ /* used in heuristic to avoid O(n^2) */\n+  XML_Bool m_reparseDeferralEnabled;\n\
    +  int m_lastBufferRequestSize;\n   XML_Char *m_dataBuf;\n   XML_Char *m_dataBufEnd;\n\
    \   XML_StartElementHandler m_startElementHandler;\n@@ -978,6 +987,47 @@ get_hash_secret_salt(XML_Parser\
    \ parser) {\n   return parser->m_hash_secret_salt;\n }\n \n+static enum XML_Error\n\
    +callProcessor(XML_Parser parser, const char *start, const char *end,\n+     \
    \         const char **endPtr) {\n+  const size_t have_now = EXPAT_SAFE_PTR_DIFF(end,\
    \ start);\n+\n+  if (parser->m_reparseDeferralEnabled\n+      && ! parser->m_parsingStatus.finalBuffer)\
    \ {\n+    // Heuristic: don't try to parse a partial token again until the amount\
    \ of\n+    // available data has increased significantly.\n+    const size_t had_before\
    \ = parser->m_partialTokenBytesBefore;\n+    // ...but *do* try anyway if we're\
    \ close to causing a reallocation.\n+    size_t available_buffer\n+        = EXPAT_SAFE_PTR_DIFF(parser->m_bufferPtr,\
    \ parser->m_buffer);\n+#if XML_CONTEXT_BYTES > 0\n+    available_buffer -= EXPAT_MIN(available_buffer,\
    \ XML_CONTEXT_BYTES);\n+#endif\n+    available_buffer\n+        += EXPAT_SAFE_PTR_DIFF(parser->m_bufferLim,\
    \ parser->m_bufferEnd);\n+    // m_lastBufferRequestSize is never assigned a value\
    \ < 0, so the cast is ok\n+    const bool enough\n+        = (have_now >= 2 *\
    \ had_before)\n+          || ((size_t)parser->m_lastBufferRequestSize > available_buffer);\n\
    +\n+    if (! enough) {\n+      *endPtr = start; // callers may expect this to\
    \ be set\n+      return XML_ERROR_NONE;\n+    }\n+  }\n+  g_parseAttempts += 1;\n\
    +  const enum XML_Error ret = parser->m_processor(parser, start, end, endPtr);\n\
    +  if (ret == XML_ERROR_NONE) {\n+    // if we consumed nothing, remember what\
    \ we had on this parse attempt.\n+    if (*endPtr == start) {\n+      parser->m_partialTokenBytesBefore\
    \ = have_now;\n+    } else {\n+      parser->m_partialTokenBytesBefore = 0;\n\
    +    }\n+  }\n+  return ret;\n+}\n+\n static XML_Bool /* only valid for root parser\
    \ */\n startParsing(XML_Parser parser) {\n   /* hash functions must be initialized\
    \ before setContext() is called */\n@@ -1159,6 +1209,9 @@ parserInit(XML_Parser\
    \ parser, const XML_Char *encodingName) {\n   parser->m_bufferEnd = parser->m_buffer;\n\
    \   parser->m_parseEndByteIndex = 0;\n   parser->m_parseEndPtr = NULL;\n+  parser->m_partialTokenBytesBefore\
    \ = 0;\n+  parser->m_reparseDeferralEnabled = g_reparseDeferralEnabledDefault;\n\
    +  parser->m_lastBufferRequestSize = 0;\n   parser->m_declElementType = NULL;\n\
    \   parser->m_declAttributeId = NULL;\n   parser->m_declEntity = NULL;\n@@ -1328,6\
    \ +1381,7 @@ XML_ExternalEntityParserCreate(XML_Parser oldParser, const XML_Char\
    \ *context,\n      to worry which hash secrets each table has.\n   */\n   unsigned\
    \ long oldhash_secret_salt;\n+  XML_Bool oldReparseDeferralEnabled;\n \n   /*\
    \ Validate the oldParser parameter before we pull everything out of it */\n  \
    \ if (oldParser == NULL)\n@@ -1372,6 +1426,7 @@ XML_ExternalEntityParserCreate(XML_Parser\
    \ oldParser, const XML_Char *context,\n      to worry which hash secrets each\
    \ table has.\n   */\n   oldhash_secret_salt = parser->m_hash_secret_salt;\n+ \
    \ oldReparseDeferralEnabled = parser->m_reparseDeferralEnabled;\n \n #ifdef XML_DTD\n\
    \   if (! context)\n@@ -1424,6 +1479,7 @@ XML_ExternalEntityParserCreate(XML_Parser\
    \ oldParser, const XML_Char *context,\n   parser->m_defaultExpandInternalEntities\
    \ = oldDefaultExpandInternalEntities;\n   parser->m_ns_triplets = oldns_triplets;\n\
    \   parser->m_hash_secret_salt = oldhash_secret_salt;\n+  parser->m_reparseDeferralEnabled\
    \ = oldReparseDeferralEnabled;\n   parser->m_parentParser = oldParser;\n #ifdef\
    \ XML_DTD\n   parser->m_paramEntityParsing = oldParamEntityParsing;\n@@ -1878,55\
    \ +1934,8 @@ XML_Parse(XML_Parser parser, const char *s, int len, int isFinal)\
    \ {\n     parser->m_parsingStatus.parsing = XML_PARSING;\n   }\n \n-  if (len\
    \ == 0) {\n-    parser->m_parsingStatus.finalBuffer = (XML_Bool)isFinal;\n-  \
    \  if (! isFinal)\n-      return XML_STATUS_OK;\n-    parser->m_positionPtr =\
    \ parser->m_bufferPtr;\n-    parser->m_parseEndPtr = parser->m_bufferEnd;\n-\n\
    -    /* If data are left over from last buffer, and we now know that these\n-\
    \       data are the final chunk of input, then we have to check them again\n\
    -       to detect errors based on that fact.\n-    */\n-    parser->m_errorCode\n\
    -        = parser->m_processor(parser, parser->m_bufferPtr,\n-               \
    \               parser->m_parseEndPtr, &parser->m_bufferPtr);\n-\n-    if (parser->m_errorCode\
    \ == XML_ERROR_NONE) {\n-      switch (parser->m_parsingStatus.parsing) {\n- \
    \     case XML_SUSPENDED:\n-        /* It is hard to be certain, but it seems\
    \ that this case\n-         * cannot occur.  This code is cleaning up a previous\
    \ parse\n-         * with no new data (since len == 0).  Changing the parsing\n\
    -         * state requires getting to execute a handler function, and\n-     \
    \    * there doesn't seem to be an opportunity for that while in\n-         *\
    \ this circumstance.\n-         *\n-         * Given the uncertainty, we retain\
    \ the code but exclude it\n-         * from coverage tests.\n-         *\n-  \
    \       * LCOV_EXCL_START\n-         */\n-        XmlUpdatePosition(parser->m_encoding,\
    \ parser->m_positionPtr,\n-                          parser->m_bufferPtr, &parser->m_position);\n\
    -        parser->m_positionPtr = parser->m_bufferPtr;\n-        return XML_STATUS_SUSPENDED;\n\
    -        /* LCOV_EXCL_STOP */\n-      case XML_INITIALIZED:\n-      case XML_PARSING:\n\
    -        parser->m_parsingStatus.parsing = XML_FINISHED;\n-        /* fall through\
    \ */\n-      default:\n-        return XML_STATUS_OK;\n-      }\n-    }\n-   \
    \ parser->m_eventEndPtr = parser->m_eventPtr;\n-    parser->m_processor = errorProcessor;\n\
    -    return XML_STATUS_ERROR;\n-  }\n #if XML_CONTEXT_BYTES == 0\n-  else if (parser->m_bufferPtr\
    \ == parser->m_bufferEnd) {\n+  if (parser->m_bufferPtr == parser->m_bufferEnd)\
    \ {\n     const char *end;\n     int nLeftOver;\n     enum XML_Status result;\n\
    @@ -1937,12 +1946,15 @@ XML_Parse(XML_Parser parser, const char *s, int len, int\
    \ isFinal) {\n       parser->m_processor = errorProcessor;\n       return XML_STATUS_ERROR;\n\
    \     }\n+    // though this isn't a buffer request, we assume that `len` is the\
    \ app's\n+    // preferred buffer fill size, and therefore save it here.\n+  \
    \  parser->m_lastBufferRequestSize = len;\n     parser->m_parseEndByteIndex +=\
    \ len;\n     parser->m_positionPtr = s;\n     parser->m_parsingStatus.finalBuffer\
    \ = (XML_Bool)isFinal;\n \n     parser->m_errorCode\n-        = parser->m_processor(parser,\
    \ s, parser->m_parseEndPtr = s + len, &end);\n+        = callProcessor(parser,\
    \ s, parser->m_parseEndPtr = s + len, &end);\n \n     if (parser->m_errorCode\
    \ != XML_ERROR_NONE) {\n       parser->m_eventEndPtr = parser->m_eventPtr;\n@@\
    \ -1975,6 +1987,9 @@ XML_Parse(XML_Parser parser, const char *s, int len, int\
    \ isFinal) {\n       parser->m_parsingStatus.parsing = XML_PARSING;\n       void\
    \ *const temp = XML_GetBuffer(parser, nLeftOver);\n       parser->m_parsingStatus.parsing\
    \ = originalStatus;\n+      // GetBuffer may have overwritten this, but we want\
    \ to remember what the\n+      // app requested, not how many bytes were left\
    \ over after parsing.\n+      parser->m_lastBufferRequestSize = len;\n       if\
    \ (temp == NULL) {\n         // NOTE: parser->m_errorCode has already been set\
    \ by XML_GetBuffer().\n         parser->m_eventPtr = parser->m_eventEndPtr = NULL;\n\
    @@ -1996,15 +2011,14 @@ XML_Parse(XML_Parser parser, const char *s, int len, int\
    \ isFinal) {\n     return result;\n   }\n #endif /* XML_CONTEXT_BYTES == 0 */\n\
    -  else {\n-    void *buff = XML_GetBuffer(parser, len);\n-    if (buff == NULL)\n\
    -      return XML_STATUS_ERROR;\n-    else {\n-      memcpy(buff, s, len);\n-\
    \      return XML_ParseBuffer(parser, len, isFinal);\n-    }\n+  void *buff =\
    \ XML_GetBuffer(parser, len);\n+  if (buff == NULL)\n+    return XML_STATUS_ERROR;\n\
    +  if (len > 0) {\n+    assert(s != NULL); // make sure s==NULL && len!=0 was\
    \ rejected above\n+    memcpy(buff, s, len);\n   }\n+  return XML_ParseBuffer(parser,\
    \ len, isFinal);\n }\n \n enum XML_Status XMLCALL\n@@ -2044,8 +2058,8 @@ XML_ParseBuffer(XML_Parser\
    \ parser, int len, int isFinal) {\n   parser->m_parseEndByteIndex += len;\n  \
    \ parser->m_parsingStatus.finalBuffer = (XML_Bool)isFinal;\n \n-  parser->m_errorCode\
    \ = parser->m_processor(\n-      parser, start, parser->m_parseEndPtr, &parser->m_bufferPtr);\n\
    +  parser->m_errorCode = callProcessor(parser, start, parser->m_parseEndPtr,\n\
    +                                      &parser->m_bufferPtr);\n \n   if (parser->m_errorCode\
    \ != XML_ERROR_NONE) {\n     parser->m_eventEndPtr = parser->m_eventPtr;\n@@ -2090,7\
    \ +2104,11 @@ XML_GetBuffer(XML_Parser parser, int len) {\n   default:;\n   }\n\
    \ \n-  if (len > EXPAT_SAFE_PTR_DIFF(parser->m_bufferLim, parser->m_bufferEnd))\
    \ {\n+  // whether or not the request succeeds, `len` seems to be the app's preferred\n\
    +  // buffer fill size; remember it.\n+  parser->m_lastBufferRequestSize = len;\n\
    +  if (len > EXPAT_SAFE_PTR_DIFF(parser->m_bufferLim, parser->m_bufferEnd)\n+\
    \      || parser->m_buffer == NULL) {\n #if XML_CONTEXT_BYTES > 0\n     int keep;\n\
    \ #endif /* XML_CONTEXT_BYTES > 0 */\n@@ -2113,8 +2131,9 @@ XML_GetBuffer(XML_Parser\
    \ parser, int len) {\n     }\n     neededSize += keep;\n #endif /* XML_CONTEXT_BYTES\
    \ > 0 */\n-    if (neededSize\n-        <= EXPAT_SAFE_PTR_DIFF(parser->m_bufferLim,\
    \ parser->m_buffer)) {\n+    if (parser->m_buffer && parser->m_bufferPtr\n+  \
    \      && neededSize\n+               <= EXPAT_SAFE_PTR_DIFF(parser->m_bufferLim,\
    \ parser->m_buffer)) {\n #if XML_CONTEXT_BYTES > 0\n       if (keep < EXPAT_SAFE_PTR_DIFF(parser->m_bufferPtr,\
    \ parser->m_buffer)) {\n         int offset\n@@ -2128,14 +2147,12 @@ XML_GetBuffer(XML_Parser\
    \ parser, int len) {\n         parser->m_bufferPtr -= offset;\n       }\n #else\n\
    -      if (parser->m_buffer && parser->m_bufferPtr) {\n-        memmove(parser->m_buffer,\
    \ parser->m_bufferPtr,\n-                EXPAT_SAFE_PTR_DIFF(parser->m_bufferEnd,\
    \ parser->m_bufferPtr));\n-        parser->m_bufferEnd\n-            = parser->m_buffer\n\
    -              + EXPAT_SAFE_PTR_DIFF(parser->m_bufferEnd, parser->m_bufferPtr);\n\
    -        parser->m_bufferPtr = parser->m_buffer;\n-      }\n+      memmove(parser->m_buffer,\
    \ parser->m_bufferPtr,\n+              EXPAT_SAFE_PTR_DIFF(parser->m_bufferEnd,\
    \ parser->m_bufferPtr));\n+      parser->m_bufferEnd\n+          = parser->m_buffer\n\
    +            + EXPAT_SAFE_PTR_DIFF(parser->m_bufferEnd, parser->m_bufferPtr);\n\
    +      parser->m_bufferPtr = parser->m_buffer;\n #endif /* XML_CONTEXT_BYTES >\
    \ 0 */\n     } else {\n       char *newBuf;\n@@ -2237,7 +2254,7 @@ XML_ResumeParser(XML_Parser\
    \ parser) {\n   }\n   parser->m_parsingStatus.parsing = XML_PARSING;\n \n-  parser->m_errorCode\
    \ = parser->m_processor(\n+  parser->m_errorCode = callProcessor(\n       parser,\
    \ parser->m_bufferPtr, parser->m_parseEndPtr, &parser->m_bufferPtr);\n \n   if\
    \ (parser->m_errorCode != XML_ERROR_NONE) {\n@@ -2592,6 +2609,15 @@ XML_SetBillionLaughsAttackProtectionActivationThreshold(\n\
    \ }\n #endif /* XML_GE == 1 */\n \n+XML_Bool XMLCALL\n+XML_SetReparseDeferralEnabled(XML_Parser\
    \ parser, XML_Bool enabled) {\n+  if (parser != NULL && (enabled == XML_TRUE ||\
    \ enabled == XML_FALSE)) {\n+    parser->m_reparseDeferralEnabled = enabled;\n\
    +    return XML_TRUE;\n+  }\n+  return XML_FALSE;\n+}\n+\n /* Initially tag->rawName\
    \ always points into the parse buffer;\n    for those TAG instances opened while\
    \ the current parse buffer was\n    processed, and not yet closed, we need to\
    \ store tag->rawName in a more"
  - "--- a/expat/tests/basic_tests.c\n+++ b/expat/tests/basic_tests.c\n@@ -49,6 +49,7\
    \ @@\n \n #include <stdio.h>\n #include <string.h>\n+#include <time.h>\n \n #if\
    \ ! defined(__cplusplus)\n #  include <stdbool.h>\n@@ -2910,6 +2911,20 @@ START_TEST(test_buffer_can_grow_to_max)\
    \ {\n }\n END_TEST\n \n+START_TEST(test_getbuffer_allocates_on_zero_len) {\n+\
    \  for (int first_len = 1; first_len >= 0; first_len--) {\n+    set_subtest(\"\
    with len=%d first\", first_len);\n+    XML_Parser parser = XML_ParserCreate(NULL);\n\
    +    assert_true(parser != NULL);\n+    assert_true(XML_GetBuffer(parser, first_len)\
    \ != NULL);\n+    assert_true(XML_GetBuffer(parser, 0) != NULL);\n+    if (XML_ParseBuffer(parser,\
    \ 0, XML_FALSE) != XML_STATUS_OK)\n+      xml_failure(parser);\n+    XML_ParserFree(parser);\n\
    +  }\n+}\n+END_TEST\n+\n /* Test position information macros */\n START_TEST(test_byte_info_at_end)\
    \ {\n   const char *text = \"<doc></doc>\";\n@@ -3148,7 +3163,7 @@ static int\
    \ XMLCALL\n external_bom_checker(XML_Parser parser, const XML_Char *context,\n\
    \                      const XML_Char *base, const XML_Char *systemId,\n     \
    \                 const XML_Char *publicId) {\n-  const char *text = \"\";\n+\
    \  const char *text;\n   UNUSED_P(base);\n   UNUSED_P(systemId);\n   UNUSED_P(publicId);\n\
    @@ -3625,7 +3640,9 @@ START_TEST(test_suspend_resume_internal_entity) {\n   XML_SetStartElementHandler(g_parser,\
    \ start_element_suspender);\n   XML_SetCharacterDataHandler(g_parser, accumulate_characters);\n\
    \   XML_SetUserData(g_parser, &storage);\n-  if (_XML_Parse_SINGLE_BYTES(g_parser,\
    \ text, (int)strlen(text), XML_TRUE)\n+  // can't use SINGLE_BYTES here, because\
    \ it'll return early on suspension, and\n+  // we won't know exactly how much\
    \ input we actually managed to give Expat.\n+  if (XML_Parse(g_parser, text, (int)strlen(text),\
    \ XML_TRUE)\n       != XML_STATUS_SUSPENDED)\n     xml_failure(g_parser);\n  \
    \ CharData_CheckXMLChars(&storage, XCS(\"\"));\n@@ -4638,6 +4655,12 @@ START_TEST(test_utf8_in_start_tags)\
    \ {\n   char doc[1024];\n   size_t failCount = 0;\n \n+  // we need all the bytes\
    \ to be parsed, but we don't want the errors that can\n+  // trigger on isFinal=XML_TRUE,\
    \ so we skip the test if the heuristic is on.\n+  if (g_reparseDeferralEnabledDefault)\
    \ {\n+    return;\n+  }\n+\n   for (; i < sizeof(cases) / sizeof(cases[0]); i++)\
    \ {\n     size_t j = 0;\n     for (; j < sizeof(atNameStart) / sizeof(atNameStart[0]);\
    \ j++) {\n@@ -5178,6 +5201,629 @@ START_TEST(test_nested_entity_suspend) {\n }\n\
    \ END_TEST\n \n+/* Regression test for quadratic parsing on large tokens */\n\
    +START_TEST(test_big_tokens_take_linear_time) {\n+  const char *const too_slow_failure_message\n\
    +      = \"Compared to the baseline runtime of the first test, this test has a\
    \ \"\n+        \"slowdown of more than <max_slowdown>. \"\n+        \"Please keep\
    \ increasing the value by 1 until it reliably passes the \"\n+        \"test on\
    \ your hardware and open a bug sharing that number with us. \"\n+        \"Thanks\
    \ in advance!\";\n+  const struct {\n+    const char *pre;\n+    const char *post;\n\
    +  } text[] = {\n+      {\"<a>\", \"</a>\"},                      // assumed good,\
    \ used as baseline\n+      {\"<b><![CDATA[ value: \", \" ]]></b>\"}, // CDATA,\
    \ performed OK before patch\n+      {\"<c attr='\", \"'></c>\"},             \
    \ // big attribute, used to be O(N\xB2)\n+      {\"<d><!-- \", \" --></d>\"},\
    \             // long comment, used to be O(N\xB2)\n+      {\"<e><\", \"/></e>\"\
    },                   // big elem name, used to be O(N\xB2)\n+  };\n+  const int\
    \ num_cases = sizeof(text) / sizeof(text[0]);\n+  // For the test we need a <max_slowdown>\
    \ value that is:\n+  // (1) big enough that the test passes reliably (avoiding\
    \ flaky tests), and\n+  // (2) small enough that the test actually catches regressions.\n\
    +  const int max_slowdown = 15;\n+  char aaaaaa[4096];\n+  const int fillsize\
    \ = (int)sizeof(aaaaaa);\n+  const int fillcount = 100;\n+\n+  memset(aaaaaa,\
    \ 'a', fillsize);\n+\n+  if (! g_reparseDeferralEnabledDefault) {\n+    return;\
    \ // heuristic is disabled; we would get O(n^2) and fail.\n+  }\n+#if defined(_WIN32)\n\
    +  if (CLOCKS_PER_SEC < 100000) {\n+    // Skip this test if clock() doesn't have\
    \ reasonably good resolution.\n+    // This workaround is only applied to Windows\
    \ targets, since XSI requires\n+    // the value to be 1 000 000 (10x the condition\
    \ here), and we want to be\n+    // very sure that at least one platform in CI\
    \ can catch regressions.\n+    return;\n+  }\n+#endif\n+\n+  clock_t baseline\
    \ = 0;\n+  for (int i = 0; i < num_cases; ++i) {\n+    XML_Parser parser = XML_ParserCreate(NULL);\n\
    +    assert_true(parser != NULL);\n+    enum XML_Status status;\n+    set_subtest(\"\
    max_slowdown=%d text=\\\"%saaaaaa%s\\\"\", max_slowdown,\n+                text[i].pre,\
    \ text[i].post);\n+    const clock_t start = clock();\n+\n+    // parse the start\
    \ text\n+    status = _XML_Parse_SINGLE_BYTES(parser, text[i].pre,\n+        \
    \                             (int)strlen(text[i].pre), XML_FALSE);\n+    if (status\
    \ != XML_STATUS_OK) {\n+      xml_failure(parser);\n+    }\n+    // parse lots\
    \ of 'a', failing the test early if it takes too long\n+    for (int f = 0; f\
    \ < fillcount; ++f) {\n+      status = _XML_Parse_SINGLE_BYTES(parser, aaaaaa,\
    \ fillsize, XML_FALSE);\n+      if (status != XML_STATUS_OK) {\n+        xml_failure(parser);\n\
    +      }\n+      // i == 0 means we're still calculating the baseline value\n\
    +      if (i > 0) {\n+        const clock_t now = clock();\n+        const clock_t\
    \ clocks_so_far = now - start;\n+        const int slowdown = clocks_so_far /\
    \ baseline;\n+        if (slowdown >= max_slowdown) {\n+          fprintf(\n+\
    \              stderr,\n+              \"fill#%d: clocks_so_far=%d baseline=%d\
    \ slowdown=%d max_slowdown=%d\\n\",\n+              f, (int)clocks_so_far, (int)baseline,\
    \ slowdown, max_slowdown);\n+          fail(too_slow_failure_message);\n+    \
    \    }\n+      }\n+    }\n+    // parse the end text\n+    status = _XML_Parse_SINGLE_BYTES(parser,\
    \ text[i].post,\n+                                     (int)strlen(text[i].post),\
    \ XML_TRUE);\n+    if (status != XML_STATUS_OK) {\n+      xml_failure(parser);\n\
    +    }\n+\n+    // how long did it take in total?\n+    const clock_t end = clock();\n\
    +    const clock_t taken = end - start;\n+    if (i == 0) {\n+      assert_true(taken\
    \ > 0); // just to make sure we don't div-by-0 later\n+      baseline = taken;\n\
    +    }\n+    const int slowdown = taken / baseline;\n+    if (slowdown >= max_slowdown)\
    \ {\n+      fprintf(stderr, \"taken=%d baseline=%d slowdown=%d max_slowdown=%d\\\
    n\",\n+              (int)taken, (int)baseline, slowdown, max_slowdown);\n+  \
    \    fail(too_slow_failure_message);\n+    }\n+\n+    XML_ParserFree(parser);\n\
    +  }\n+}\n+END_TEST\n+\n+START_TEST(test_set_reparse_deferral) {\n+  const char\
    \ *const pre = \"<d>\";\n+  const char *const start = \"<x attr='\";\n+  const\
    \ char *const end = \"'></x>\";\n+  char eeeeee[100];\n+  const int fillsize =\
    \ (int)sizeof(eeeeee);\n+  memset(eeeeee, 'e', fillsize);\n+\n+  for (int enabled\
    \ = 0; enabled <= 1; enabled += 1) {\n+    set_subtest(\"deferral=%d\", enabled);\n\
    +\n+    XML_Parser parser = XML_ParserCreate(NULL);\n+    assert_true(parser !=\
    \ NULL);\n+    assert_true(XML_SetReparseDeferralEnabled(parser, enabled));\n\
    +    // pre-grow the buffer to avoid reparsing due to almost-fullness\n+    assert_true(XML_GetBuffer(parser,\
    \ fillsize * 10103) != NULL);\n+\n+    CharData storage;\n+    CharData_Init(&storage);\n\
    +    XML_SetUserData(parser, &storage);\n+    XML_SetStartElementHandler(parser,\
    \ start_element_event_handler);\n+\n+    enum XML_Status status;\n+    // parse\
    \ the start text\n+    status = XML_Parse(parser, pre, (int)strlen(pre), XML_FALSE);\n\
    +    if (status != XML_STATUS_OK) {\n+      xml_failure(parser);\n+    }\n+  \
    \  CharData_CheckXMLChars(&storage, XCS(\"d\")); // first element should be done\n\
    +\n+    // ..and the start of the token\n+    status = XML_Parse(parser, start,\
    \ (int)strlen(start), XML_FALSE);\n+    if (status != XML_STATUS_OK) {\n+    \
    \  xml_failure(parser);\n+    }\n+    CharData_CheckXMLChars(&storage, XCS(\"\
    d\")); // still just the first one\n+\n+    // try to parse lots of 'e', but the\
    \ token isn't finished\n+    for (int c = 0; c < 100; ++c) {\n+      status =\
    \ XML_Parse(parser, eeeeee, fillsize, XML_FALSE);\n+      if (status != XML_STATUS_OK)\
    \ {\n+        xml_failure(parser);\n+      }\n+    }\n+    CharData_CheckXMLChars(&storage,\
    \ XCS(\"d\")); // *still* just the first one\n+\n+    // end the <x> token.\n\
    +    status = XML_Parse(parser, end, (int)strlen(end), XML_FALSE);\n+    if (status\
    \ != XML_STATUS_OK) {\n+      xml_failure(parser);\n+    }\n+\n+    if (enabled)\
    \ {\n+      // In general, we may need to push more data to trigger a reparse\
    \ attempt,\n+      // but in this test, the data is constructed to always require\
    \ it.\n+      CharData_CheckXMLChars(&storage, XCS(\"d\")); // or the test is\
    \ incorrect\n+      // 2x the token length should suffice; the +1 covers the start\
    \ and end.\n+      for (int c = 0; c < 101; ++c) {\n+        status = XML_Parse(parser,\
    \ eeeeee, fillsize, XML_FALSE);\n+        if (status != XML_STATUS_OK) {\n+  \
    \        xml_failure(parser);\n+        }\n+      }\n+    }\n+    CharData_CheckXMLChars(&storage,\
    \ XCS(\"dx\")); // the <x> should be done\n+\n+    XML_ParserFree(parser);\n+\
    \  }\n+}\n+END_TEST\n+\n+struct element_decl_data {\n+  XML_Parser parser;\n+\
    \  int count;\n+};\n+\n+static void\n+element_decl_counter(void *userData, const\
    \ XML_Char *name, XML_Content *model) {\n+  UNUSED_P(name);\n+  struct element_decl_data\
    \ *testdata = (struct element_decl_data *)userData;\n+  testdata->count += 1;\n\
    +  XML_FreeContentModel(testdata->parser, model);\n+}\n+\n+static int\n+external_inherited_parser(XML_Parser\
    \ p, const XML_Char *context,\n+                          const XML_Char *base,\
    \ const XML_Char *systemId,\n+                          const XML_Char *publicId)\
    \ {\n+  UNUSED_P(base);\n+  UNUSED_P(systemId);\n+  UNUSED_P(publicId);\n+  const\
    \ char *const pre = \"<!ELEMENT document ANY>\\n\";\n+  const char *const start\
    \ = \"<!ELEMENT \";\n+  const char *const end = \" ANY>\\n\";\n+  const char *const\
    \ post = \"<!ELEMENT xyz ANY>\\n\";\n+  const int enabled = *(int *)XML_GetUserData(p);\n\
    +  char eeeeee[100];\n+  char spaces[100];\n+  const int fillsize = (int)sizeof(eeeeee);\n\
    +  assert_true(fillsize == (int)sizeof(spaces));\n+  memset(eeeeee, 'e', fillsize);\n\
    +  memset(spaces, ' ', fillsize);\n+\n+  XML_Parser parser = XML_ExternalEntityParserCreate(p,\
    \ context, NULL);\n+  assert_true(parser != NULL);\n+  // pre-grow the buffer\
    \ to avoid reparsing due to almost-fullness\n+  assert_true(XML_GetBuffer(parser,\
    \ fillsize * 10103) != NULL);\n+\n+  struct element_decl_data testdata;\n+  testdata.parser\
    \ = parser;\n+  testdata.count = 0;\n+  XML_SetUserData(parser, &testdata);\n\
    +  XML_SetElementDeclHandler(parser, element_decl_counter);\n+\n+  enum XML_Status\
    \ status;\n+  // parse the initial text\n+  status = XML_Parse(parser, pre, (int)strlen(pre),\
    \ XML_FALSE);\n+  if (status != XML_STATUS_OK) {\n+    xml_failure(parser);\n\
    +  }\n+  assert_true(testdata.count == 1); // first element should be done\n+\n\
    +  // ..and the start of the big token\n+  status = XML_Parse(parser, start, (int)strlen(start),\
    \ XML_FALSE);\n+  if (status != XML_STATUS_OK) {\n+    xml_failure(parser);\n\
    +  }\n+  assert_true(testdata.count == 1); // still just the first one\n+\n+ \
    \ // try to parse lots of 'e', but the token isn't finished\n+  for (int c = 0;\
    \ c < 100; ++c) {\n+    status = XML_Parse(parser, eeeeee, fillsize, XML_FALSE);\n\
    +    if (status != XML_STATUS_OK) {\n+      xml_failure(parser);\n+    }\n+  }\n\
    +  assert_true(testdata.count == 1); // *still* just the first one\n+\n+  // end\
    \ the big token.\n+  status = XML_Parse(parser, end, (int)strlen(end), XML_FALSE);\n\
    +  if (status != XML_STATUS_OK) {\n+    xml_failure(parser);\n+  }\n+\n+  if (enabled)\
    \ {\n+    // In general, we may need to push more data to trigger a reparse attempt,\n\
    +    // but in this test, the data is constructed to always require it.\n+   \
    \ assert_true(testdata.count == 1); // or the test is incorrect\n+    // 2x the\
    \ token length should suffice; the +1 covers the start and end.\n+    for (int\
    \ c = 0; c < 101; ++c) {\n+      status = XML_Parse(parser, spaces, fillsize,\
    \ XML_FALSE);\n+      if (status != XML_STATUS_OK) {\n+        xml_failure(parser);\n\
    +      }\n+    }\n+  }\n+  assert_true(testdata.count == 2); // the big token\
    \ should be done\n+\n+  // parse the final text\n+  status = XML_Parse(parser,\
    \ post, (int)strlen(post), XML_TRUE);\n+  if (status != XML_STATUS_OK) {\n+  \
    \  xml_failure(parser);\n+  }\n+  assert_true(testdata.count == 3); // after isFinal=XML_TRUE,\
    \ all must be done\n+\n+  XML_ParserFree(parser);\n+  return XML_STATUS_OK;\n\
    +}\n+\n+START_TEST(test_reparse_deferral_is_inherited) {\n+  const char *const\
    \ text\n+      = \"<!DOCTYPE document SYSTEM 'something.ext'><document/>\";\n\
    +  for (int enabled = 0; enabled <= 1; ++enabled) {\n+    set_subtest(\"deferral=%d\"\
    , enabled);\n+\n+    XML_Parser parser = XML_ParserCreate(NULL);\n+    assert_true(parser\
    \ != NULL);\n+    XML_SetUserData(parser, (void *)&enabled);\n+    XML_SetParamEntityParsing(parser,\
    \ XML_PARAM_ENTITY_PARSING_ALWAYS);\n+    // this handler creates a sub-parser\
    \ and checks that its deferral behavior\n+    // is what we expected, based on\
    \ the value of `enabled` (in userdata).\n+    XML_SetExternalEntityRefHandler(parser,\
    \ external_inherited_parser);\n+    assert_true(XML_SetReparseDeferralEnabled(parser,\
    \ enabled));\n+    if (XML_Parse(parser, text, (int)strlen(text), XML_TRUE) !=\
    \ XML_STATUS_OK)\n+      xml_failure(parser);\n+\n+    XML_ParserFree(parser);\n\
    +  }\n+}\n+END_TEST\n+\n+START_TEST(test_set_reparse_deferral_on_null_parser)\
    \ {\n+  assert_true(XML_SetReparseDeferralEnabled(NULL, 0) == XML_FALSE);\n+ \
    \ assert_true(XML_SetReparseDeferralEnabled(NULL, 1) == XML_FALSE);\n+  assert_true(XML_SetReparseDeferralEnabled(NULL,\
    \ 10) == XML_FALSE);\n+  assert_true(XML_SetReparseDeferralEnabled(NULL, 100)\
    \ == XML_FALSE);\n+  assert_true(XML_SetReparseDeferralEnabled(NULL, (XML_Bool)INT_MIN)\n\
    +              == XML_FALSE);\n+  assert_true(XML_SetReparseDeferralEnabled(NULL,\
    \ (XML_Bool)INT_MAX)\n+              == XML_FALSE);\n+}\n+END_TEST\n+\n+START_TEST(test_set_reparse_deferral_on_the_fly)\
    \ {\n+  const char *const pre = \"<d><x attr='\";\n+  const char *const end =\
    \ \"'></x>\";\n+  char iiiiii[100];\n+  const int fillsize = (int)sizeof(iiiiii);\n\
    +  memset(iiiiii, 'i', fillsize);\n+\n+  XML_Parser parser = XML_ParserCreate(NULL);\n\
    +  assert_true(parser != NULL);\n+  assert_true(XML_SetReparseDeferralEnabled(parser,\
    \ XML_TRUE));\n+\n+  CharData storage;\n+  CharData_Init(&storage);\n+  XML_SetUserData(parser,\
    \ &storage);\n+  XML_SetStartElementHandler(parser, start_element_event_handler);\n\
    +\n+  enum XML_Status status;\n+  // parse the start text\n+  status = XML_Parse(parser,\
    \ pre, (int)strlen(pre), XML_FALSE);\n+  if (status != XML_STATUS_OK) {\n+   \
    \ xml_failure(parser);\n+  }\n+  CharData_CheckXMLChars(&storage, XCS(\"d\"));\
    \ // first element should be done\n+\n+  // try to parse some 'i', but the token\
    \ isn't finished\n+  status = XML_Parse(parser, iiiiii, fillsize, XML_FALSE);\n\
    +  if (status != XML_STATUS_OK) {\n+    xml_failure(parser);\n+  }\n+  CharData_CheckXMLChars(&storage,\
    \ XCS(\"d\")); // *still* just the first one\n+\n+  // end the <x> token.\n+ \
    \ status = XML_Parse(parser, end, (int)strlen(end), XML_FALSE);\n+  if (status\
    \ != XML_STATUS_OK) {\n+    xml_failure(parser);\n+  }\n+  CharData_CheckXMLChars(&storage,\
    \ XCS(\"d\")); // not yet.\n+\n+  // now change the heuristic setting and add\
    \ *no* data\n+  assert_true(XML_SetReparseDeferralEnabled(parser, XML_FALSE));\n\
    +  // we avoid isFinal=XML_TRUE, because that would force-bypass the heuristic.\n\
    +  status = XML_Parse(parser, \"\", 0, XML_FALSE);\n+  if (status != XML_STATUS_OK)\
    \ {\n+    xml_failure(parser);\n+  }\n+  CharData_CheckXMLChars(&storage, XCS(\"\
    dx\"));\n+\n+  XML_ParserFree(parser);\n+}\n+END_TEST\n+\n+START_TEST(test_set_bad_reparse_option)\
    \ {\n+  XML_Parser parser = XML_ParserCreate(NULL);\n+  assert_true(XML_FALSE\
    \ == XML_SetReparseDeferralEnabled(parser, 2));\n+  assert_true(XML_FALSE == XML_SetReparseDeferralEnabled(parser,\
    \ 3));\n+  assert_true(XML_FALSE == XML_SetReparseDeferralEnabled(parser, 99));\n\
    +  assert_true(XML_FALSE == XML_SetReparseDeferralEnabled(parser, 127));\n+  assert_true(XML_FALSE\
    \ == XML_SetReparseDeferralEnabled(parser, 128));\n+  assert_true(XML_FALSE ==\
    \ XML_SetReparseDeferralEnabled(parser, 129));\n+  assert_true(XML_FALSE == XML_SetReparseDeferralEnabled(parser,\
    \ 255));\n+  assert_true(XML_TRUE == XML_SetReparseDeferralEnabled(parser, 0));\n\
    +  assert_true(XML_TRUE == XML_SetReparseDeferralEnabled(parser, 1));\n+  XML_ParserFree(parser);\n\
    +}\n+END_TEST\n+\n+static size_t g_totalAlloc = 0;\n+static size_t g_biggestAlloc\
    \ = 0;\n+\n+static void *\n+counting_realloc(void *ptr, size_t size) {\n+  g_totalAlloc\
    \ += size;\n+  if (size > g_biggestAlloc) {\n+    g_biggestAlloc = size;\n+  }\n\
    +  return realloc(ptr, size);\n+}\n+\n+static void *\n+counting_malloc(size_t\
    \ size) {\n+  return counting_realloc(NULL, size);\n+}\n+\n+START_TEST(test_bypass_heuristic_when_close_to_bufsize)\
    \ {\n+  if (g_chunkSize != 0) {\n+    // this test does not use SINGLE_BYTES,\
    \ because it depends on very precise\n+    // buffer fills.\n+    return;\n+ \
    \ }\n+  if (! g_reparseDeferralEnabledDefault) {\n+    return; // this test is\
    \ irrelevant when the deferral heuristic is disabled.\n+  }\n+\n+  const int document_length\
    \ = 65536;\n+  char *const document = (char *)malloc(document_length);\n+\n+ \
    \ const XML_Memory_Handling_Suite memfuncs = {\n+      counting_malloc,\n+   \
    \   counting_realloc,\n+      free,\n+  };\n+\n+  const int leading_list[] = {0,\
    \ 3, 61, 96, 400, 401, 4000, 4010, 4099, -1};\n+  const int bigtoken_list[] =\
    \ {3000, 4000, 4001, 4096, 4099, 5000, 20000, -1};\n+  const int fillsize_list[]\
    \ = {131, 256, 399, 400, 401, 1025, 4099, 4321, -1};\n+\n+  for (const int *leading\
    \ = leading_list; *leading >= 0; leading++) {\n+    for (const int *bigtoken =\
    \ bigtoken_list; *bigtoken >= 0; bigtoken++) {\n+      for (const int *fillsize\
    \ = fillsize_list; *fillsize >= 0; fillsize++) {\n+        set_subtest(\"leading=%d\
    \ bigtoken=%d fillsize=%d\", *leading, *bigtoken,\n+                    *fillsize);\n\
    +        // start by checking that the test looks reasonably valid\n+        assert_true(*leading\
    \ + *bigtoken <= document_length);\n+\n+        // put 'x' everywhere; some will\
    \ be overwritten by elements.\n+        memset(document, 'x', document_length);\n\
    +        // maybe add an initial tag\n+        if (*leading) {\n+          assert_true(*leading\
    \ >= 3); // or the test case is invalid\n+          memcpy(document, \"<a>\",\
    \ 3);\n+        }\n+        // add the large token\n+        document[*leading\
    \ + 0] = '<';\n+        document[*leading + 1] = 'b';\n+        memset(&document[*leading\
    \ + 2], ' ', *bigtoken - 2); // a spacy token\n+        document[*leading + *bigtoken\
    \ - 1] = '>';\n+\n+        // 1 for 'b', plus 1 or 0 depending on the presence\
    \ of 'a'\n+        const int expected_elem_total = 1 + (*leading ? 1 : 0);\n+\n\
    +        XML_Parser parser = XML_ParserCreate_MM(NULL, &memfuncs, NULL);\n+  \
    \      assert_true(parser != NULL);\n+\n+        CharData storage;\n+        CharData_Init(&storage);\n\
    +        XML_SetUserData(parser, &storage);\n+        XML_SetStartElementHandler(parser,\
    \ start_element_event_handler);\n+\n+        g_biggestAlloc = 0;\n+        g_totalAlloc\
    \ = 0;\n+        int offset = 0;\n+        // fill data until the big token is\
    \ covered (but not necessarily parsed)\n+        while (offset < *leading + *bigtoken)\
    \ {\n+          assert_true(offset + *fillsize <= document_length);\n+       \
    \   const enum XML_Status status\n+              = XML_Parse(parser, &document[offset],\
    \ *fillsize, XML_FALSE);\n+          if (status != XML_STATUS_OK) {\n+       \
    \     xml_failure(parser);\n+          }\n+          offset += *fillsize;\n+ \
    \       }\n+        // Now, check that we've had a buffer allocation that could\
    \ fit the\n+        // context bytes and our big token. In order to detect a special\
    \ case,\n+        // we need to know how many bytes of our big token were included\
    \ in the\n+        // first push that contained _any_ bytes of the big token:\n\
    +        const int bigtok_first_chunk_bytes = *fillsize - (*leading % *fillsize);\n\
    +        if (bigtok_first_chunk_bytes >= *bigtoken && XML_CONTEXT_BYTES == 0)\
    \ {\n+          // Special case: we aren't saving any context, and the whole big\
    \ token\n+          // was covered by a single fill, so Expat may have parsed\
    \ directly\n+          // from our input pointer, without allocating an internal\
    \ buffer.\n+        } else if (*leading < XML_CONTEXT_BYTES) {\n+          assert_true(g_biggestAlloc\
    \ >= *leading + (size_t)*bigtoken);\n+        } else {\n+          assert_true(g_biggestAlloc\
    \ >= XML_CONTEXT_BYTES + (size_t)*bigtoken);\n+        }\n+        // fill data\
    \ until the big token is actually parsed\n+        while (storage.count < expected_elem_total)\
    \ {\n+          const size_t alloc_before = g_totalAlloc;\n+          assert_true(offset\
    \ + *fillsize <= document_length);\n+          const enum XML_Status status\n\
    +              = XML_Parse(parser, &document[offset], *fillsize, XML_FALSE);\n\
    +          if (status != XML_STATUS_OK) {\n+            xml_failure(parser);\n\
    +          }\n+          offset += *fillsize;\n+          // since all the bytes\
    \ of the big token are already in the buffer,\n+          // the bufsize ceiling\
    \ should make us finish its parsing without any\n+          // further buffer\
    \ allocations. We assume that there will be no other\n+          // large allocations\
    \ in this test.\n+          assert_true(g_totalAlloc - alloc_before < 4096);\n\
    +        }\n+        // test-the-test: was our alloc even called?\n+        assert_true(g_totalAlloc\
    \ > 0);\n+        // test-the-test: there shouldn't be any extra start elements\n\
    +        assert_true(storage.count == expected_elem_total);\n+\n+        XML_ParserFree(parser);\n\
    +      }\n+    }\n+  }\n+  free(document);\n+}\n+END_TEST\n+\n+START_TEST(test_varying_buffer_fills)\
    \ {\n+  const int KiB = 1024;\n+  const int MiB = 1024 * KiB;\n+  const int document_length\
    \ = 16 * MiB;\n+  const int big = 7654321; // arbitrarily chosen between 4 and\
    \ 8 MiB\n+\n+  if (g_chunkSize != 0) {\n+    return; // this test is slow, and\
    \ doesn't use _XML_Parse_SINGLE_BYTES().\n+  }\n+\n+  char *const document = (char\
    \ *)malloc(document_length);\n+  assert_true(document != NULL);\n+  memset(document,\
    \ 'x', document_length);\n+  document[0] = '<';\n+  document[1] = 't';\n+  memset(&document[2],\
    \ ' ', big - 2); // a very spacy token\n+  document[big - 1] = '>';\n+\n+  //\
    \ Each testcase is a list of buffer fill sizes, terminated by a value < 0.\n+\
    \  // When reparse deferral is enabled, the final (negated) value is the expected\n\
    +  // maximum number of bytes scanned in parse attempts.\n+  const int testcases[][30]\
    \ = {\n+      {8 * MiB, -8 * MiB},\n+      {4 * MiB, 4 * MiB, -12 * MiB}, // try\
    \ at 4MB, then 8MB = 12 MB total\n+      // zero-size fills shouldn't trigger\
    \ the bypass\n+      {4 * MiB, 0, 4 * MiB, -12 * MiB},\n+      {4 * MiB, 0, 0,\
    \ 4 * MiB, -12 * MiB},\n+      {4 * MiB, 0, 1 * MiB, 0, 3 * MiB, -12 * MiB},\n\
    +      // try to hit the buffer ceiling only once (at the end)\n+      {4 * MiB,\
    \ 2 * MiB, 1 * MiB, 512 * KiB, 256 * KiB, 256 * KiB, -12 * MiB},\n+      // try\
    \ to hit the same buffer ceiling multiple times\n+      {4 * MiB + 1, 2 * MiB,\
    \ 1 * MiB, 512 * KiB, -25 * MiB},\n+\n+      // try to hit every ceiling, by always\
    \ landing 1K shy of the buffer size\n+      {1 * KiB, 2 * KiB, 4 * KiB, 8 * KiB,\
    \ 16 * KiB, 32 * KiB, 64 * KiB,\n+       128 * KiB, 256 * KiB, 512 * KiB, 1 *\
    \ MiB, 2 * MiB, 4 * MiB, -16 * MiB},\n+\n+      // try to avoid every ceiling,\
    \ by always landing 1B past the buffer size\n+      // the normal 2x heuristic\
    \ threshold still forces parse attempts.\n+      {2 * KiB + 1,          // will\
    \ attempt 2KiB + 1 ==> total 2KiB + 1\n+       2 * KiB, 4 * KiB,     // will attempt\
    \ 8KiB + 1 ==> total 10KiB + 2\n+       8 * KiB, 16 * KiB,    // will attempt\
    \ 32KiB + 1 ==> total 42KiB + 3\n+       32 * KiB, 64 * KiB,   // will attempt\
    \ 128KiB + 1 ==> total 170KiB + 4\n+       128 * KiB, 256 * KiB, // will attempt\
    \ 512KiB + 1 ==> total 682KiB + 5\n+       512 * KiB, 1 * MiB,   // will attempt\
    \ 2MiB + 1 ==> total 2M + 682K + 6\n+       2 * MiB, 4 * MiB,     // will attempt\
    \ 8MiB + 1 ==> total 10M + 682K + 7\n+       -(10 * MiB + 682 * KiB + 7)},\n+\
    \      // try to avoid every ceiling again, except on our last fill.\n+      {2\
    \ * KiB + 1,          // will attempt 2KiB + 1 ==> total 2KiB + 1\n+       2 *\
    \ KiB, 4 * KiB,     // will attempt 8KiB + 1 ==> total 10KiB + 2\n+       8 *\
    \ KiB, 16 * KiB,    // will attempt 32KiB + 1 ==> total 42KiB + 3\n+       32\
    \ * KiB, 64 * KiB,   // will attempt 128KiB + 1 ==> total 170KiB + 4\n+      \
    \ 128 * KiB, 256 * KiB, // will attempt 512KiB + 1 ==> total 682KiB + 5\n+   \
    \    512 * KiB, 1 * MiB,   // will attempt 2MiB + 1 ==> total 2M + 682K + 6\n\
    +       2 * MiB, 4 * MiB - 1, // will attempt 8MiB ==> total 10M + 682K + 6\n\
    +       -(10 * MiB + 682 * KiB + 6)},\n+\n+      // try to hit ceilings on the\
    \ way multiple times\n+      {512 * KiB + 1, 256 * KiB, 128 * KiB, 128 * KiB -\
    \ 1, // 1 MiB buffer\n+       512 * KiB + 1, 256 * KiB, 128 * KiB, 128 * KiB -\
    \ 1, // 2 MiB buffer\n+       1 * MiB + 1, 512 * KiB, 256 * KiB, 256 * KiB - 1,\
    \   // 4 MiB buffer\n+       2 * MiB + 1, 1 * MiB, 512 * KiB,                \
    \    // 8 MiB buffer\n+       // we'll make a parse attempt at every parse call\n\
    +       -(45 * MiB + 12)},\n+  };\n+  const int testcount = sizeof(testcases)\
    \ / sizeof(testcases[0]);\n+  for (int test_i = 0; test_i < testcount; test_i++)\
    \ {\n+    const int *fillsize = testcases[test_i];\n+    set_subtest(\"#%d {%d\
    \ %d %d %d ...}\", test_i, fillsize[0], fillsize[1],\n+                fillsize[2],\
    \ fillsize[3]);\n+    XML_Parser parser = XML_ParserCreate(NULL);\n+    assert_true(parser\
    \ != NULL);\n+    g_parseAttempts = 0;\n+\n+    CharData storage;\n+    CharData_Init(&storage);\n\
    +    XML_SetUserData(parser, &storage);\n+    XML_SetStartElementHandler(parser,\
    \ start_element_event_handler);\n+\n+    int worstcase_bytes = 0; // sum of (buffered\
    \ bytes at each XML_Parse call)\n+    int scanned_bytes = 0;   // sum of (buffered\
    \ bytes at each actual parse)\n+    int offset = 0;\n+    while (*fillsize >=\
    \ 0) {\n+      assert_true(offset + *fillsize <= document_length); // or test\
    \ is invalid\n+      const unsigned attempts_before = g_parseAttempts;\n+    \
    \  const enum XML_Status status\n+          = XML_Parse(parser, &document[offset],\
    \ *fillsize, XML_FALSE);\n+      if (status != XML_STATUS_OK) {\n+        xml_failure(parser);\n\
    +      }\n+      offset += *fillsize;\n+      fillsize++;\n+      assert_true(offset\
    \ <= INT_MAX - worstcase_bytes); // avoid overflow\n+      worstcase_bytes +=\
    \ offset; // we might've tried to parse all pending bytes\n+      if (g_parseAttempts\
    \ != attempts_before) {\n+        assert_true(g_parseAttempts == attempts_before\
    \ + 1); // max 1/XML_Parse\n+        assert_true(offset <= INT_MAX - scanned_bytes);\
    \      // avoid overflow\n+        scanned_bytes += offset; // we *did* try to\
    \ parse all pending bytes\n+      }\n+    }\n+    assert_true(storage.count ==\
    \ 1); // the big token should've been parsed\n+    assert_true(scanned_bytes >\
    \ 0);  // test-the-test: does our counter work?\n+    if (g_reparseDeferralEnabledDefault)\
    \ {\n+      // heuristic is enabled; some XML_Parse calls may have deferred reparsing\n\
    +      const int max_bytes_scanned = -*fillsize;\n+      if (scanned_bytes > max_bytes_scanned)\
    \ {\n+        fprintf(stderr,\n+                \"bytes scanned in parse attempts:\
    \ actual=%d limit=%d \\n\",\n+                scanned_bytes, max_bytes_scanned);\n\
    +        fail(\"too many bytes scanned in parse attempts\");\n+      }\n+    \
    \  assert_true(scanned_bytes <= worstcase_bytes);\n+    } else {\n+      // heuristic\
    \ is disabled; every XML_Parse() will have reparsed\n+      assert_true(scanned_bytes\
    \ == worstcase_bytes);\n+    }\n+\n+    XML_ParserFree(parser);\n+  }\n+  free(document);\n\
    +}\n+END_TEST\n+\n void\n make_basic_test_case(Suite *s) {\n   TCase *tc_basic\
    \ = tcase_create(\"basic tests\");\n@@ -5299,6 +5945,7 @@ make_basic_test_case(Suite\
    \ *s) {\n   tcase_add_test(tc_basic, test_get_buffer_3_overflow);\n #endif\n \
    \  tcase_add_test(tc_basic, test_buffer_can_grow_to_max);\n+  tcase_add_test(tc_basic,\
    \ test_getbuffer_allocates_on_zero_len);\n   tcase_add_test(tc_basic, test_byte_info_at_end);\n\
    \   tcase_add_test(tc_basic, test_byte_info_at_error);\n   tcase_add_test(tc_basic,\
    \ test_byte_info_at_cdata);\n@@ -5417,4 +6064,12 @@ make_basic_test_case(Suite\
    \ *s) {\n   tcase_add_test__ifdef_xml_dtd(tc_basic,\n                        \
    \         test_pool_integrity_with_unfinished_attr);\n   tcase_add_test__if_xml_ge(tc_basic,\
    \ test_nested_entity_suspend);\n+  tcase_add_test(tc_basic, test_big_tokens_take_linear_time);\n\
    +  tcase_add_test(tc_basic, test_set_reparse_deferral);\n+  tcase_add_test(tc_basic,\
    \ test_reparse_deferral_is_inherited);\n+  tcase_add_test(tc_basic, test_set_reparse_deferral_on_null_parser);\n\
    +  tcase_add_test(tc_basic, test_set_reparse_deferral_on_the_fly);\n+  tcase_add_test(tc_basic,\
    \ test_set_bad_reparse_option);\n+  tcase_add_test(tc_basic, test_bypass_heuristic_when_close_to_bufsize);\n\
    +  tcase_add_test(tc_basic, test_varying_buffer_fills);\n }"
  - "--- a/expat/tests/common.c\n+++ b/expat/tests/common.c\n@@ -185,7 +185,7 @@ _xml_failure(XML_Parser\
    \ parser, const char *file, int line) {\n            \"u, offset %\" XML_FMT_INT_MOD\
    \ \"u)\\n    reported from %s, line %d\\n\",\n            err, XML_ErrorString(err),\
    \ XML_GetCurrentLineNumber(parser),\n            XML_GetCurrentColumnNumber(parser),\
    \ file, line);\n-  _assert_true(0, file, line, buffer);\n+  _fail(file, line,\
    \ buffer);\n }\n \n enum XML_Status\n@@ -214,9 +214,9 @@ _expect_failure(const\
    \ char *text, enum XML_Error errorCode,\n                 const char *errorMessage,\
    \ const char *file, int lineno) {\n   if (_XML_Parse_SINGLE_BYTES(g_parser, text,\
    \ (int)strlen(text), XML_TRUE)\n       == XML_STATUS_OK)\n-    /* Hackish use\
    \ of _assert_true() macro, but let's us report\n+    /* Hackish use of _fail()\
    \ macro, but lets us report\n        the right filename and line number. */\n\
    -    _assert_true(0, file, lineno, errorMessage);\n+    _fail(file, lineno, errorMessage);\n\
    \   if (XML_GetErrorCode(g_parser) != errorCode)\n     _xml_failure(g_parser,\
    \ file, lineno);\n }"
  - "--- a/expat/tests/handlers.c\n+++ b/expat/tests/handlers.c\n@@ -1717,7 +1717,9\
    \ @@ record_element_end_handler(void *userData, const XML_Char *name) {\n const\
    \ struct handler_record_entry *\n _handler_record_get(const struct handler_record_list\
    \ *storage, int index,\n                     const char *file, int line) {\n-\
    \  _assert_true(storage->count > index, file, line, \"too few handler calls\"\
    );\n+  if (storage->count <= index) {\n+    _fail(file, line, \"too few handler\
    \ calls\");\n+  }\n   return &storage->entries[index];\n }\n "
  - "--- a/expat/tests/minicheck.c\n+++ b/expat/tests/minicheck.c\n@@ -244,14 +244,11\
    \ @@ srunner_summarize(SRunner *runner, int verbosity) {\n }\n \n void\n-_assert_true(int\
    \ condition, const char *file, int line, const char *msg) {\n+_fail(const char\
    \ *file, int line, const char *msg) {\n   /* Always print the error message so\
    \ it isn't lost.  In this case,\n      we have a failure, so there's no reason\
    \ to be quiet about what\n      it is.\n   */\n-  if (condition) {\n-    return;\n\
    -  }\n   _check_current_filename = file;\n   _check_current_lineno = line;\n \
    \  if (msg != NULL) {"
  - "--- a/expat/tests/runtests.c\n+++ b/expat/tests/runtests.c\n@@ -98,10 +98,14\
    \ @@ main(int argc, char *argv[]) {\n     printf(\"Expat version: %\" XML_FMT_STR\
    \ \"\\n\", XML_ExpatVersion());\n \n   for (g_chunkSize = 0; g_chunkSize <= 5;\
    \ g_chunkSize++) {\n-    char context[100];\n-    snprintf(context, sizeof(context),\
    \ \"chunksize=%d\", g_chunkSize);\n-    context[sizeof(context) - 1] = '\\0';\n\
    -    srunner_run_all(sr, context, verbosity);\n+    for (int enabled = 0; enabled\
    \ <= 1; ++enabled) {\n+      char context[100];\n+      g_reparseDeferralEnabledDefault\
    \ = enabled;\n+      snprintf(context, sizeof(context), \"chunksize=%d deferral=%d\"\
    ,\n+               g_chunkSize, enabled);\n+      context[sizeof(context) - 1]\
    \ = '\\0';\n+      srunner_run_all(sr, context, verbosity);\n+    }\n   }\n  \
    \ srunner_summarize(sr, verbosity);\n   nf = srunner_ntests_failed(sr);"
  - "--- a/expat/xmlwf/xmlwf.c\n+++ b/expat/xmlwf/xmlwf.c\n@@ -918,6 +918,9 @@ usage(const\
    \ XML_Char *prog, int rc) {\n       T(\"  -a FACTOR      set maximum tolerated\
    \ [a]mplification factor (default: 100.0)\\n\")\n       T(\"  -b BYTES       set\
    \ number of output [b]ytes needed to activate (default: 8 MiB)\\n\")\n       T(\"\
    \\n\")\n+      T(\"reparse deferral:\\n\")\n+      T(\"  -q             disable\
    \ reparse deferral, and allow [q]uadratic parse runtime with large tokens\\n\"\
    )\n+      T(\"\\n\")\n       T(\"info arguments:\\n\")\n       T(\"  -h, --help\
    \     show this [h]elp message and exit\\n\")\n       T(\"  -v, --version  show\
    \ program's [v]ersion number and exit\\n\")\n@@ -973,6 +976,8 @@ tmain(int argc,\
    \ XML_Char **argv) {\n   unsigned long long attackThresholdBytes = 0;\n   XML_Bool\
    \ attackThresholdGiven = XML_FALSE;\n \n+  XML_Bool disableDeferral = XML_FALSE;\n\
    +\n   int exitCode = XMLWF_EXIT_SUCCESS;\n   enum XML_ParamEntityParsing paramEntityParsing\n\
    \       = XML_PARAM_ENTITY_PARSING_NEVER;\n@@ -1125,6 +1130,11 @@ tmain(int argc,\
    \ XML_Char **argv) {\n #endif\n       break;\n     }\n+    case T('q'): {\n+ \
    \     disableDeferral = XML_TRUE;\n+      j++;\n+      break;\n+    }\n     case\
    \ T('\\0'):\n       if (j > 1) {\n         i++;\n@@ -1171,6 +1181,16 @@ tmain(int\
    \ argc, XML_Char **argv) {\n #endif\n     }\n \n+    if (disableDeferral) {\n\
    +      const XML_Bool success = XML_SetReparseDeferralEnabled(parser, XML_FALSE);\n\
    +      if (! success) {\n+        // This prevents tperror(..) from reporting\
    \ misleading \"[..]: Success\"\n+        errno = EINVAL;\n+        tperror(T(\"\
    Failed to disable reparse deferral\"));\n+        exit(XMLWF_EXIT_INTERNAL_ERROR);\n\
    +      }\n+    }\n+\n     if (requireStandalone)\n       XML_SetNotStandaloneHandler(parser,\
    \ notStandalone);\n     XML_SetParamEntityParsing(parser, paramEntityParsing);"
  identifiers: CVE:["CVE-2023-52425"],CWE:["CWE-400"]
  overview: Affected versions of this package are vulnerable to Denial of Service
    (DoS) due to improper handling of large tokens that require multiple buffer fills.
    An attacker can cause the application to perform numerous full reparsings, leading
    to excessive resource consumption and service disruption.
  references:
    GitHub Commit: https://github.com/libexpat/libexpat/commit/34b598c5f594b015c513c73f06e7ced3323edbf1
    GitHub PR: https://github.com/libexpat/libexpat/pull/789
    commons-fileupload:commons-fileupload: SNYK-JAVA-COMMONSFILEUPLOAD-30082
    npm <code>ws</code> package: https://snyk.io/vuln/npm:ws:20171108
  title: Denial of Service (DoS)
- diff_content:
  - "--- a/misc/syslog.c\n+++ b/misc/syslog.c\n@@ -41,6 +41,7 @@ static char sccsid[]\
    \ = \"@(#)syslog.c\t8.4 (Berkeley) 3/18/94\";\n #include <sys/uio.h>\n #include\
    \ <sys/un.h>\n #include <syslog.h>\n+#include <limits.h>\n \n static int LogType\
    \ = SOCK_DGRAM;\t/* type of socket connection */\n static int LogFile = -1;\t\t\
    /* fd for log */\n@@ -219,7 +220,7 @@ __vsyslog_internal (int pri, const char\
    \ *fmt, va_list ap,\n     vl = __vsnprintf_internal (pos, len, fmt, apc, mode_flags);\n\
    \     va_end (apc);\n \n-    if (vl < 0)\n+    if (vl < 0 || vl >= INT_MAX - l)\n\
    \       goto out;\n \n     if (vl >= len)"
  identifiers: CVE:["CVE-2023-6780"],CWE:["CWE-190"]
  overview: Affected versions of this package are vulnerable to Integer Overflow or
    Wraparound due to an integer overflow in the `__vsyslog_internal` function. An
    attacker can cause undefined behavior by calling `syslog` or `vsyslog` with an
    excessively long message, which leads to miscalculation of the buffer size needed
    to store the message.
  references:
    GitHub Commit: https://github.com/bminor/glibc/commit/ddf542da94caf97ff43cc2875c88749880b7259b
    OSS Security Advisory: https://www.openwall.com/lists/oss-security/2024/01/30/6
    RedHat Bugzilla Bug: https://bugzilla.redhat.com/show_bug.cgi?id=2254396
  title: Integer Overflow or Wraparound
- diff_content:
  - "--- a/misc/syslog.c\n+++ b/misc/syslog.c\n@@ -185,11 +185,13 @@ __vsyslog_internal\
    \ (int pri, const char *fmt, va_list ap,\n   else\n     l = __snprintf (bufs,\
    \ sizeof bufs,\n \t\t    SYSLOG_HEADER_WITHOUT_TS (pri, &msgoff));\n+  if (l <\
    \ 0)\n+    goto out;\n \n   char *pos;\n   size_t len;\n \n-  if (0 <= l && l\
    \ < sizeof bufs)\n+  if (l < sizeof bufs)\n     {\n       /* At this point, there\
    \ is still a chance that we can print the\n          remaining part of the log\
    \ into bufs and use that.  */\n@@ -215,12 +217,15 @@ __vsyslog_internal (int pri,\
    \ const char *fmt, va_list ap,\n     __set_errno (saved_errno);\n \n     vl =\
    \ __vsnprintf_internal (pos, len, fmt, apc, mode_flags);\n+    va_end (apc);\n\
    +\n+    if (vl < 0)\n+      goto out;\n \n-    if (!(0 <= vl && vl < len))\n+\
    \    if (vl >= len)\n       buf = NULL;\n \n     bufsize = l + vl;\n-    va_end\
    \ (apc);\n   }\n \n   if (buf == NULL)\n@@ -231,25 +236,37 @@ __vsyslog_internal\
    \ (int pri, const char *fmt, va_list ap,\n \t  /* Tell the cancellation handler\
    \ to free this buffer.  */\n \t  clarg.buf = buf;\n \n+\t  int cl;\n \t  if (has_ts)\n\
    -\t    __snprintf (buf, l + 1,\n-\t\t\tSYSLOG_HEADER (pri, timestamp, &msgoff,\
    \ pid));\n+\t    cl = __snprintf (buf, l + 1,\n+\t\t\t     SYSLOG_HEADER (pri,\
    \ timestamp, &msgoff, pid));\n \t  else\n-\t    __snprintf (buf, l + 1,\n-\t\t\
    \tSYSLOG_HEADER_WITHOUT_TS (pri, &msgoff));\n+\t    cl = __snprintf (buf, l +\
    \ 1,\n+\t\t\t     SYSLOG_HEADER_WITHOUT_TS (pri, &msgoff));\n+\t  if (cl != l)\n\
    +\t    goto out;\n \n \t  va_list apc;\n \t  va_copy (apc, ap);\n-\t  __vsnprintf_internal\
    \ (buf + l, bufsize - l + 1, fmt, apc,\n-\t\t\t\tmode_flags);\n+\t  cl = __vsnprintf_internal\
    \ (buf + l, bufsize - l + 1, fmt, apc,\n+\t\t\t\t     mode_flags);\n \t  va_end\
    \ (apc);\n+\n+\t  if (cl != vl)\n+\t    goto out;\n \t}\n       else\n       \
    \  {\n+          int bl;\n \t  /* Nothing much to do but emit an error message.\
    \  */\n-          bufsize = __snprintf (bufs, sizeof bufs,\n-                \
    \                \"out of memory[%d]\", __getpid ());\n+          bl = __snprintf\
    \ (bufs, sizeof bufs,\n+                           \"out of memory[%d]\", __getpid\
    \ ());\n+          if (bl < 0 || bl >= sizeof bufs)\n+            goto out;\n\
    +\n+          bufsize = bl;\n           buf = bufs;\n+          msgoff = 0;\n\
    \         }\n     }\n "
  identifiers: CVE:["CVE-2023-6779"],CWE:["CWE-122"]
  overview: Affected versions of this package are vulnerable to Heap-based Buffer
    Overflow due to an off-by-one error in the `__vsyslog_internal` function, which
    is also used by the `syslog` and `vsyslog` functions. An attacker can cause an
    application crash by providing a message that exceeds `INT_MAX` bytes, leading
    to a miscalculation of the buffer size needed to store the message.
  references:
    GitHub Commit: https://github.com/bminor/glibc/commit/7e5a0c286da33159d47d0122007aac016f3e02cd
    OSS Security Advisory: https://www.openwall.com/lists/oss-security/2024/01/30/6
    RedHat Bugzilla Bug: https://bugzilla.redhat.com/show_bug.cgi?id=2254395
  title: Heap-based Buffer Overflow
- diff_content:
  - "--- a/src/libopensc/padding.c\n+++ b/src/libopensc/padding.c\n@@ -32,10 +32,13\
    \ @@\n #include <string.h>\n #include <stdlib.h>\n \n+#include \"common/constant-time.h\"\
    \n #include \"internal.h\"\n #include \"pkcs11/pkcs11.h\"\n /* TODO doxygen comments\
    \ */\n \n+#define SC_PKCS1_PADDING_MIN_SIZE 11\n+\n /*\n  * Prefixes for pkcs-v1\
    \ signatures\n  */\n@@ -143,45 +146,82 @@ sc_pkcs1_strip_01_padding(struct sc_context\
    \ *ctx, const u8 *in_dat, size_t in_le\n \treturn SC_SUCCESS;\n }\n \n-\n-/* remove\
    \ pkcs1 BT02 padding (adding BT02 padding is currently not\n- * needed/implemented)\
    \ */\n+/* Remove pkcs1 BT02 padding (adding BT02 padding is currently not\n+ *\
    \ needed/implemented) in constant-time.\n+ * Original source: https://github.com/openssl/openssl/blob/9890cc42daff5e2d0cad01ac4bf78c391f599a6e/crypto/rsa/rsa_pk1.c#L171\
    \ */\n int\n-sc_pkcs1_strip_02_padding(sc_context_t *ctx, const u8 *data, size_t\
    \ len, u8 *out, size_t *out_len)\n+sc_pkcs1_strip_02_padding_constant_time(sc_context_t\
    \ *ctx, unsigned int n, const u8 *data, unsigned int data_len, u8 *out, unsigned\
    \ int *out_len)\n {\n-\tunsigned int\tn = 0;\n-\n+\tunsigned int i = 0;\n+\tu8\
    \ *msg, *msg_orig = NULL;\n+\tunsigned int good, found_zero_byte, mask;\n+\tunsigned\
    \ int zero_index = 0, msg_index, mlen = -1, len = 0;\n \tLOG_FUNC_CALLED(ctx);\n\
    -\tif (data == NULL || len < 3)\n+\n+\tif (data == NULL || data_len <= 0 || data_len\
    \ > n || n < SC_PKCS1_PADDING_MIN_SIZE)\n \t\tLOG_FUNC_RETURN(ctx, SC_ERROR_INTERNAL);\n\
    \ \n-\t/* skip leading zero byte */\n-\tif (*data == 0) {\n-\t\tdata++;\n-\t\t\
    len--;\n+\tmsg = msg_orig = calloc(n, sizeof(u8));\n+\tif (msg == NULL)\n+\t\t\
    LOG_FUNC_RETURN(ctx, SC_ERROR_INTERNAL);\n+\n+\t/*\n+\t * We can not check length\
    \ of input data straight away and still we need to read\n+\t * from input even\
    \ when the input is not as long as needed to keep the time constant.\n+\t * If\
    \ data has wrong size, it is padded by zeroes from left and the following checks\n\
    +\t * do not pass.\n+\t */\n+\tlen = data_len;\n+\tfor (data += len, msg += n,\
    \ i = 0; i < n; i++) {\n+\t\tmask = ~constant_time_is_zero(len);\n+\t\tlen -=\
    \ 1 & mask;\n+\t\tdata -= 1 & mask;\n+\t\t*--msg = *data & mask;\n+\t}\n+\t//\
    \ check first byte to be 0x00\n+\tgood = constant_time_is_zero(msg[0]);\n+\t//\
    \ check second byte to be 0x02\n+\tgood &= constant_time_eq(msg[1], 2);\n+\n+\t\
    // find zero byte after random data in padding\n+\tfound_zero_byte = 0;\n+\tfor\
    \ (i = 2; i < n; i++) {\n+\t\tunsigned int equals0 = constant_time_is_zero(msg[i]);\n\
    +\t\tzero_index = constant_time_select(~found_zero_byte & equals0, i, zero_index);\n\
    +\t\tfound_zero_byte |= equals0;\n \t}\n-\tif (data[0] != 0x02)\n-\t\tLOG_FUNC_RETURN(ctx,\
    \ SC_ERROR_WRONG_PADDING);\n-\t/* skip over padding bytes */\n-\tfor (n = 1; n\
    \ < len && data[n]; n++)\n-\t\t;\n-\t/* Must be at least 8 pad bytes */\n-\tif\
    \ (n >= len || n < 9)\n-\t\tLOG_FUNC_RETURN(ctx, SC_ERROR_WRONG_PADDING);\n-\t\
    n++;\n-\tif (out == NULL)\n-\t\t/* just check the padding */\n-\t\tLOG_FUNC_RETURN(ctx,\
    \ SC_SUCCESS);\n \n-\t/* Now move decrypted contents to head of buffer */\n-\t\
    if (*out_len < len - n)\n-\t\tLOG_FUNC_RETURN(ctx, SC_ERROR_INTERNAL);\n-\t*out_len\
    \ = len - n;\n-\tmemmove(out, data + n, *out_len);\n+\t// zero_index stands for\
    \ index of last found zero\n+\tgood &= constant_time_ge(zero_index, 2 + 8);\n\
    +\n+\t// start of the actual message in data\n+\tmsg_index = zero_index + 1;\n\
    +\n+\t// length of message\n+\tmlen = data_len - msg_index;\n+\n+\t// check that\
    \ message fits into out buffer\n+\tgood &= constant_time_ge(*out_len, mlen);\n\
    +\n+\t// move the result in-place by |num|-SC_PKCS1_PADDING_MIN_SIZE-|mlen| bytes\
    \ to the left.\n+\t*out_len = constant_time_select(constant_time_lt(n - SC_PKCS1_PADDING_MIN_SIZE,\
    \ *out_len),\n+\t\t\tn - SC_PKCS1_PADDING_MIN_SIZE, *out_len);\n+\tfor (msg_index\
    \ = 1; msg_index < n - SC_PKCS1_PADDING_MIN_SIZE; msg_index <<= 1) {\n+\t\tmask\
    \ = ~constant_time_eq(msg_index & (n - SC_PKCS1_PADDING_MIN_SIZE - mlen), 0);\n\
    +\t\tfor (i = SC_PKCS1_PADDING_MIN_SIZE; i < n - msg_index; i++)\n+\t\t\tmsg[i]\
    \ = constant_time_select_8(mask, msg[i + msg_index], msg[i]);\n+\t}\n+\t// move\
    \ message into out buffer, if good\n+\tfor (i = 0; i < *out_len; i++) {\n+\t\t\
    unsigned int msg_index;\n+\t\t// when out is longer than message in data, use\
    \ some bogus index in msg\n+\t\tmask = good & constant_time_lt(i, mlen);\n+\t\t\
    msg_index = constant_time_select(mask, i + SC_PKCS1_PADDING_MIN_SIZE, 0); // to\
    \ now overflow msg buffer\n+\t\tout[i] = constant_time_select_8(mask, msg[msg_index],\
    \ out[i]);\n+\t}\n \n-\tsc_log(ctx, \"stripped output(%\"SC_FORMAT_LEN_SIZE_T\"\
    u): %s\", len - n,\n-\t       sc_dump_hex(out, len - n));\n-\tLOG_FUNC_RETURN(ctx,\
    \ (int)(len - n));\n+\tfree(msg_orig);\n+\treturn constant_time_select(good, mlen,\
    \ SC_ERROR_WRONG_PADDING);\n }\n \n #ifdef ENABLE_OPENSSL"
  - "--- a/src/libopensc/pkcs15-sec.c\n+++ b/src/libopensc/pkcs15-sec.c\n@@ -308,8\
    \ +308,9 @@ int sc_pkcs15_decipher(struct sc_pkcs15_card *p15card,\n \n \t/* Strip\
    \ any padding */\n \tif (pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1) {\n-\t\tsize_t\
    \ s = r;\n-\t\tr = sc_pkcs1_strip_02_padding(ctx, out, s, out, &s);\n+\t\tint\
    \ s = r;\n+\t\tint key_size = alg_info->key_length;\n+\t\tr = sc_pkcs1_strip_02_padding_constant_time(ctx,\
    \ key_size / 8, out, s, out, &s);\n \t\tLOG_TEST_RET(ctx, r, \"Invalid PKCS#1\
    \ padding\");\n \t}\n #ifdef ENABLE_OPENSSL"
  - "--- a/src/minidriver/minidriver.c\n+++ b/src/minidriver/minidriver.c\n@@ -4653,9\
    \ +4653,9 @@ DWORD WINAPI CardRSADecrypt(__in PCARD_DATA pCardData,\n \t\t\t\t\
    \t  \"sc_pkcs15_decipher: DECRYPT-INFO dwVersion=%lu\\n\",\n \t\t\t\t\t  (unsigned\
    \ long)pInfo->dwVersion);\n \t\t\t\tif (pInfo->dwPaddingType == CARD_PADDING_PKCS1)\
    \   {\n-\t\t\t\t\tsize_t temp = pInfo->cbData;\n+\t\t\t\t\tunsigned int temp =\
    \ pInfo->cbData;\n \t\t\t\t\tlogprintf(pCardData, 2, \"sc_pkcs15_decipher: stripping\
    \ PKCS1 padding\\n\");\n-\t\t\t\t\tr = sc_pkcs1_strip_02_padding(vs->ctx, pbuf2,\
    \ pInfo->cbData, pbuf2, &temp);\n+\t\t\t\t\tr = sc_pkcs1_strip_02_padding_constant_time(vs->ctx,\
    \ prkey_info->modulus_length / 8, pbuf2, pInfo->cbData, pbuf2, &temp);\n \t\t\t\
    \t\tpInfo->cbData = (DWORD) temp;\n \t\t\t\t\tif (r < 0)   {\n \t\t\t\t\t\tlogprintf(pCardData,\
    \ 2, \"Cannot strip PKCS1 padding: %i\\n\", r);"
  identifiers: CVE:["CVE-2023-5992"],CWE:["CWE-385"]
  overview: Affected versions of this package are vulnerable to Covert Timing Channel
    due to improper implementation of PKCS#1 encryption padding removal that is not
    resistant to "Marvin" side-channel attacks. An attacker can leak private data
    by exploiting the timing differences observed during the decryption process.
  references:
    GitHub Commit: https://github.com/OpenSC/OpenSC/commit/e8883b1f91572c40bab8718f0ba274ab71906490
    GitHub Wiki: https://github.com/OpenSC/OpenSC/wiki/CVE-2023-5992
    RedHat Bugzilla Bug: https://bugzilla.redhat.com/show_bug.cgi?id=2248685
    Vulnerability Report: https://people.redhat.com/~hkario/marvin/
  title: Covert Timing Channel
- diff_content:
  - "--- a/src/asymmetric_cipher.c\n+++ b/src/asymmetric_cipher.c\n@@ -296,12 +296,26\
    \ @@ static int p11prov_rsaenc_decrypt(void *ctx, unsigned char *out, size_t *outlen,\n\
    \         goto endsess;\n     }\n \n+    /* Special handling against PKCS#1 1.5\
    \ side channel leaking */\n+    if (mechanism.mechanism == CKM_RSA_PKCS) {\n+\
    \        CK_ULONG cond;\n+        ret = side_channel_free_Decrypt(encctx->provctx,\
    \ sess, (void *)in,\n+                                        inlen, out, &out_size);\n\
    +        /* the error case need to be handled in a side-channel free way, so\n\
    +         * conditionals need to be constant time. Always setting outlen is\n\
    +         * fine because out_size is initialized to the value of outlen\n+   \
    \      * and the value should not matter in an error condition anyway */\n+  \
    \      *outlen = out_size;\n+        cond = constant_equal(ret, CKR_OK);\n+  \
    \      result = constant_select_int(cond, RET_OSSL_OK, RET_OSSL_ERR);\n+     \
    \   goto endsess;\n+    }\n+\n     ret = p11prov_Decrypt(encctx->provctx, sess,\
    \ (void *)in, inlen, out,\n                           &out_size);\n     if (ret\
    \ != CKR_OK) {\n         goto endsess;\n     }\n-\n     *outlen = out_size;\n\
    \     result = RET_OSSL_OK;\n "
  - "--- a/src/interface.c\n+++ b/src/interface.c\n@@ -450,3 +450,22 @@ CK_RV p11prov_module_reinit(P11PROV_MODULE\
    \ *mctx)\n     /* ------------- LOCKED SECTION */\n     return ret;\n }\n+\n+/*\
    \ This is needed to avoid side channels in the PKCS 1.5 decryption case */\n+CK_RV\
    \ side_channel_free_Decrypt(P11PROV_CTX *ctx, CK_SESSION_HANDLE hSession,\n+ \
    \                               CK_BYTE_PTR pEncryptedData,\n+               \
    \                 CK_ULONG ulEncryptedDataLen, CK_BYTE_PTR pData,\n+         \
    \                       CK_ULONG_PTR pulDataLen)\n+{\n+    P11PROV_INTERFACE *intf\
    \ = p11prov_ctx_get_interface(ctx);\n+    CK_RV ret = CKR_GENERAL_ERROR;\n+  \
    \  if (!intf) {\n+        P11PROV_raise(ctx, ret, \"Can't get module interfaces\"\
    );\n+        return ret;\n+    }\n+    P11PROV_debug(\"Calling C_Decrypt\");\n\
    +    /* Must not add any conditionals based on return value, so we just return\n\
    +     * straight */\n+    return intf->Decrypt(hSession, pEncryptedData, ulEncryptedDataLen,\
    \ pData,\n+                         pulDataLen);\n+}"
  identifiers: CVE:["CVE-2023-6258"],CWE:["CWE-203"]
  overview: Affected versions of this package are vulnerable to Observable Discrepancy
    via the PKCS#1 1.5 decryption process. An attacker can recover ciphertexts via
    a side-channel attack by exploiting the Marvin security flaw.
  references:
    GitHub Commit: https://github.com/latchset/pkcs11-provider/commit/de52d24c1b4b0bdc3a49a23db0f3231e209c3c68
    GitHub PR: https://github.com/latchset/pkcs11-provider/pull/308
    RedHat Bugzilla Bug: https://bugzilla.redhat.com/show_bug.cgi?id=2251062
    Vulnerability Report: https://people.redhat.com/~hkario/marvin/
  title: Observable Discrepancy
- diff_content:
  - "--- a/misc/syslog.c\n+++ b/misc/syslog.c\n@@ -124,8 +124,9 @@ __vsyslog_internal\
    \ (int pri, const char *fmt, va_list ap,\n {\n   /* Try to use a static buffer\
    \ as an optimization.  */\n   char bufs[1024];\n-  char *buf = NULL;\n-  size_t\
    \ bufsize = 0;\n+  char *buf = bufs;\n+  size_t bufsize;\n+\n   int msgoff;\n\
    \   int saved_errno = errno;\n \n@@ -177,29 +178,50 @@ __vsyslog_internal (int\
    \ pri, const char *fmt, va_list ap,\n #define SYSLOG_HEADER_WITHOUT_TS(__pri,\
    \ __msgoff)        \\\n   \"<%d>: %n\", __pri, __msgoff\n \n-  int l;\n+  int\
    \ l, vl;\n   if (has_ts)\n     l = __snprintf (bufs, sizeof bufs,\n \t\t    SYSLOG_HEADER\
    \ (pri, timestamp, &msgoff, pid));\n   else\n     l = __snprintf (bufs, sizeof\
    \ bufs,\n \t\t    SYSLOG_HEADER_WITHOUT_TS (pri, &msgoff));\n+\n+  char *pos;\n\
    +  size_t len;\n+\n   if (0 <= l && l < sizeof bufs)\n     {\n-      va_list apc;\n\
    -      va_copy (apc, ap);\n+      /* At this point, there is still a chance that\
    \ we can print the\n+         remaining part of the log into bufs and use that.\
    \  */\n+      pos = bufs + l;\n+      len = sizeof (bufs) - l;\n+    }\n+  else\n\
    +    {\n+      buf = NULL;\n+      /* We already know that bufs is too small to\
    \ use for this log message.\n+         The next vsnprintf into bufs is used only\
    \ to calculate the total\n+         required buffer length.  We will discard bufs\
    \ contents and allocate\n+         an appropriately sized buffer later instead.\
    \  */\n+      pos = bufs;\n+      len = sizeof (bufs);\n+    }\n \n-      /* Restore\
    \ errno for %m format.  */\n-      __set_errno (saved_errno);\n+  {\n+    va_list\
    \ apc;\n+    va_copy (apc, ap);\n \n-      int vl = __vsnprintf_internal (bufs\
    \ + l, sizeof bufs - l, fmt, apc,\n-                                     mode_flags);\n\
    -      if (0 <= vl && vl < sizeof bufs - l)\n-        buf = bufs;\n-      bufsize\
    \ = l + vl;\n+    /* Restore errno for %m format.  */\n+    __set_errno (saved_errno);\n\
    \ \n-      va_end (apc);\n-    }\n+    vl = __vsnprintf_internal (pos, len, fmt,\
    \ apc, mode_flags);\n+\n+    if (!(0 <= vl && vl < len))\n+      buf = NULL;\n\
    +\n+    bufsize = l + vl;\n+    va_end (apc);\n+  }\n \n   if (buf == NULL)\n\
    \     {"
  - '--- a/misc/tst-syslog-long-progname.c

    +++ b/misc/tst-syslog-long-progname.c

    @@ -0,0 +1,39 @@

    +/* Test heap buffer overflow in syslog with long __progname (CVE-2023-6246)

    +   Copyright (C) 2023 Free Software Foundation, Inc.

    +   This file is part of the GNU C Library.

    +

    +   The GNU C Library is free software; you can redistribute it and/or

    +   modify it under the terms of the GNU Lesser General Public

    +   License as published by the Free Software Foundation; either

    +   version 2.1 of the License, or (at your option) any later version.

    +

    +   The GNU C Library is distributed in the hope that it will be useful,

    +   but WITHOUT ANY WARRANTY; without even the implied warranty of

    +   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU

    +   Lesser General Public License for more details.

    +

    +   You should have received a copy of the GNU Lesser General Public

    +   License along with the GNU C Library; if not, see

    +   <https://www.gnu.org/licenses/>.  */

    +

    +#include <syslog.h>

    +#include <string.h>

    +

    +extern char * __progname;

    +

    +static int

    +do_test (void)

    +{

    +  char long_progname[2048];

    +

    +  memset (long_progname, ''X'', sizeof (long_progname) - 1);

    +  long_progname[sizeof (long_progname) - 1] = ''\0'';

    +

    +  __progname = long_progname;

    +

    +  syslog (LOG_INFO, "Hello, World!");

    +

    +  return 0;

    +}

    +

    +#include <support/test-driver.c>'
  identifiers: CVE:["CVE-2023-6246"],CWE:["CWE-122"]
  overview: ''
  references:
    GitHub Commit: https://github.com/bminor/glibc/commit/6bd0e4efcc78f3c0115e5ea9739a1642807450da
    Nuclei Templates: https://github.com/projectdiscovery/nuclei-templates/blob/master/code/cves/2023/CVE-2023-6246.yaml
    PoC: https://www.qualys.com/2024/01/30/cve-2023-6246/syslog.txt
    Vulnerability Report: https://blog.qualys.com/vulnerabilities-threat-research/2024/01/30/qualys-tru-discovers-important-vulnerabilities-in-gnu-c-librarys-syslog
    Vulnerable Code: https://github.com/bminor/glibc/commit/52a5be0df411ef3ff45c10c7c308cb92993d15b1
  title: Heap-based Buffer Overflow
- diff_content:
  - "--- a/lib/vtls/openssl.c\n+++ b/lib/vtls/openssl.c\n@@ -4351,6 +4351,20 @@ static\
    \ CURLcode servercert(struct Curl_cfilter *cf,\n     /* don't do this after Session\
    \ ID reuse */\n     result = verifystatus(cf, data);\n     if(result) {\n+   \
    \   /* when verifystatus failed, remove the session id from the cache again\n\
    +         if present */\n+      if(!Curl_ssl_cf_is_proxy(cf)) {\n+        void\
    \ *old_ssl_sessionid = NULL;\n+        bool incache;\n+        Curl_ssl_sessionid_lock(data);\n\
    +        incache = !(Curl_ssl_getsessionid(cf, data, &old_ssl_sessionid, NULL));\n\
    +        if(incache) {\n+          infof(data, \"Remove session ID again from\
    \ cache\");\n+          Curl_ssl_delsessionid(data, old_ssl_sessionid);\n+   \
    \     }\n+        Curl_ssl_sessionid_unlock(data);\n+      }\n+\n       X509_free(backend->server_cert);\n\
    \       backend->server_cert = NULL;\n       return result;"
  identifiers: CVE:["CVE-2024-0853"],CWE:["CWE-299"]
  overview: <a href="https://curl.se">curl</a> is a command line tool and library
    for transferring data with URL syntax, supporting DICT, FILE, FTP, FTPS, GOPHER,
    GOPHERS, HTTP, HTTPS, IMAP, IMAPS, LDAP, LDAPS, MQTT, POP3, POP3S, RTMP, RTMPS,
    RTSP, SCP, SFTP, SMB, SMBS, SMTP, SMTPS, TELNET and TFTP. libcurl offers a myriad
    of powerful features.
  references:
    Curl Advisory: https://curl.se/docs/CVE-2024-0853.html
    GitHub Commit: https://github.com/curl/curl/commit/c28e9478cb2548848ec
    HackerOne Report: https://hackerone.com/reports/2298922
    RedHat Bugzilla Bug: https://bugzilla.redhat.com/show_bug.cgi?id=2262097
    Vulnerable Code: https://github.com/curl/curl/commit/395365ad2d9a6c3f1a35d
    curl: https://curl.se
  title: Improper Check for Certificate Revocation
- diff_content:
  - "--- a/usr/lib/common/mech_openssl.c\n+++ b/usr/lib/common/mech_openssl.c\n@@\
    \ -1154,6 +1154,7 @@ CK_RV openssl_specific_rsa_pkcs_decrypt(STDLL_TokData_t *tokdata,\n\
    \     CK_RV rc;\n     CK_BYTE out[MAX_RSA_KEYLEN];\n     CK_ULONG modulus_bytes;\n\
    +    unsigned char kdk[SHA256_HASH_SIZE] = { 0 };\n \n     modulus_bytes = in_data_len;\n\
    \ \n@@ -1163,7 +1164,16 @@ CK_RV openssl_specific_rsa_pkcs_decrypt(STDLL_TokData_t\
    \ *tokdata,\n         goto done;\n     }\n \n-    rc = rsa_parse_block(out, modulus_bytes,\
    \ out_data, out_data_len, PKCS_BT_2);\n+    rc = openssl_specific_rsa_derive_kdk(tokdata,\
    \ key_obj,\n+                                         in_data, in_data_len,\n\
    +                                         kdk, sizeof(kdk));\n+    if (rc != CKR_OK)\
    \ {\n+        TRACE_DEVEL(\"openssl_specific_rsa_derive_kdk failed\\n\");\n+ \
    \       goto done;\n+    }\n+\n+    rc = rsa_parse_block(out, modulus_bytes, out_data,\
    \ out_data_len, PKCS_BT_2,\n+                         kdk, sizeof(kdk));\n \n\
    \ done:\n     OPENSSL_cleanse(out, sizeof(out));\n@@ -1254,7 +1264,7 @@ CK_RV\
    \ openssl_specific_rsa_pkcs_verify(STDLL_TokData_t *tokdata, SESSION *sess,\n\
    \     }\n \n     rc = rsa_parse_block(out, modulus_bytes, out_data, &out_data_len,\n\
    -                         PKCS_BT_1);\n+                         PKCS_BT_1, NULL,\
    \ 0);\n     if (rc == CKR_ENCRYPTED_DATA_INVALID) {\n         TRACE_ERROR(\"%s\\\
    n\", ock_err(ERR_SIGNATURE_INVALID));\n         return CKR_SIGNATURE_INVALID;\n\
    @@ -1318,7 +1328,8 @@ CK_RV openssl_specific_rsa_pkcs_verify_recover(STDLL_TokData_t\
    \ *tokdata,\n         return rc;\n     }\n \n-    rc = rsa_parse_block(out, modulus_bytes,\
    \ out_data, out_data_len, PKCS_BT_1);\n+    rc = rsa_parse_block(out, modulus_bytes,\
    \ out_data, out_data_len, PKCS_BT_1,\n+                         NULL, 0);\n  \
    \   if (rc == CKR_ENCRYPTED_DATA_INVALID) {\n         TRACE_ERROR(\"%s\\n\", ock_err(ERR_SIGNATURE_INVALID));\n\
    \         return CKR_SIGNATURE_INVALID;\n@@ -4983,3 +4994,388 @@ CK_RV openssl_specific_hmac_final(SIGN_VERIFY_CONTEXT\
    \ *ctx, CK_BYTE *signature,\n     ctx->context = NULL;\n     return rv;\n }\n\
    +\n+static CK_RV calc_rsa_priv_exp(STDLL_TokData_t *tokdata, OBJECT *key_obj,\n\
    +                               CK_BYTE *priv_exp, CK_ULONG priv_exp_len)\n+{\n\
    +    CK_ATTRIBUTE *modulus = NULL, *pub_exp = NULL;\n+    CK_ATTRIBUTE *prime1\
    \ = NULL, *prime2 = NULL;\n+    BN_CTX *bn_ctx;\n+    BIGNUM *n, *e, *p, *q, *d;\n\
    +    CK_RV rc;\n+\n+    UNUSED(tokdata);\n+\n+    bn_ctx = BN_CTX_secure_new();\n\
    +    if (bn_ctx == NULL) {\n+        TRACE_ERROR(\"BN_CTX_secure_new failed\\\
    n\");\n+        return CKR_FUNCTION_FAILED;\n+    }\n+\n+    /* Get modulus a\
    \ BIGNUM */\n+    rc = template_attribute_get_non_empty(key_obj->template, CKA_MODULUS,\n\
    +                                          &modulus);\n+    if (rc != CKR_OK)\
    \ {\n+        TRACE_ERROR(\"Failed to get CKA_MODULUS\\n\");\n+        goto done;\n\
    +    }\n+\n+    n = BN_CTX_get(bn_ctx);\n+    if (n == NULL ||\n+        BN_bin2bn(modulus->pValue,\
    \ modulus->ulValueLen, n) == NULL) {\n+        TRACE_ERROR(\"BN_CTX_get/BN_bin2bn\
    \ failed for modulus\\n\");\n+        rc = CKR_FUNCTION_FAILED;\n+        goto\
    \ done;\n+    }\n+    BN_set_flags(n, BN_FLG_CONSTTIME);\n+\n+    /* Get public\
    \ exponent a BIGNUM */\n+    rc = template_attribute_get_non_empty(key_obj->template,\n\
    +                                          CKA_PUBLIC_EXPONENT, &pub_exp);\n+\
    \    if (rc != CKR_OK) {\n+        TRACE_ERROR(\"Failed to get CKA_PUBLIC_EXPONENT\\\
    n\");\n+        goto done;\n+    }\n+\n+    e = BN_CTX_get(bn_ctx);\n+    if (e\
    \ == NULL ||\n+        BN_bin2bn(pub_exp->pValue, pub_exp->ulValueLen, e) == NULL)\
    \ {\n+        TRACE_ERROR(\"BN_CTX_get/BN_bin2bn failed for public exponent\\\
    n\");\n+        rc = CKR_FUNCTION_FAILED;\n+        goto done;\n+    }\n+    BN_set_flags(e,\
    \ BN_FLG_CONSTTIME);\n+\n+    /* Get prime1 a BIGNUM */\n+    rc = template_attribute_get_non_empty(key_obj->template,\
    \ CKA_PRIME_1,\n+                                          &prime1);\n+    if\
    \ (rc != CKR_OK) {\n+        TRACE_ERROR(\"Failed to get CKA_PRIME_1\\n\");\n\
    +        goto done;\n+    }\n+\n+    p = BN_CTX_get(bn_ctx);\n+    if (p == NULL\
    \ ||\n+        BN_bin2bn(prime1->pValue, prime1->ulValueLen, p) == NULL) {\n+\
    \        TRACE_ERROR(\"BN_CTX_get/BN_bin2bn failed for prime1\\n\");\n+      \
    \  rc = CKR_FUNCTION_FAILED;\n+        goto done;\n+    }\n+    BN_set_flags(p,\
    \ BN_FLG_CONSTTIME);\n+\n+    /* Get prime2 a BIGNUM */\n+    rc = template_attribute_get_non_empty(key_obj->template,\
    \ CKA_PRIME_2,\n+                                          &prime2);\n+    if\
    \ (rc != CKR_OK) {\n+        TRACE_ERROR(\"Failed to get CKA_PRIME_2\\n\");\n\
    +        goto done;\n+    }\n+\n+    q = BN_CTX_get(bn_ctx);\n+    if (q == NULL\
    \ ||\n+        BN_bin2bn(prime2->pValue, prime2->ulValueLen, q) == NULL) {\n+\
    \        TRACE_ERROR(\"BN_CTX_get/BN_bin2bn failed for prime2\\n\");\n+      \
    \  rc = CKR_FUNCTION_FAILED;\n+        goto done;\n+    }\n+    BN_set_flags(q,\
    \ BN_FLG_CONSTTIME);\n+\n+    d = BN_CTX_get(bn_ctx);\n+    if (d == NULL) {\n\
    +        TRACE_ERROR(\"BN_CTX_get failed to get d\\n\");\n+        rc = CKR_FUNCTION_FAILED;\n\
    +        goto done;\n+    }\n+    BN_set_flags(d, BN_FLG_CONSTTIME);\n+\n+   \
    \ /*\n+     * phi(n) = (p - 1 )(q - 1) = n - p - q + 1\n+     * d = e ^{-1} mod\
    \ phi(n).\n+     */\n+    if (BN_copy(d, n) == NULL ||\n+        BN_sub(d, d,\
    \ p) == 0 ||\n+        BN_sub(d, d, q) == 0 ||\n+        BN_add_word(d, 1) ==\
    \ 0 ||\n+        BN_mod_inverse(d, e, d, bn_ctx) == NULL) {\n+        TRACE_ERROR(\"\
    Failed to calculate private key part d\\n\");\n+        rc = CKR_FUNCTION_FAILED;\n\
    +        goto done;\n+    }\n+\n+    if (BN_bn2binpad(d, priv_exp, priv_exp_len)\
    \ <= 0) {\n+        TRACE_ERROR(\"BN_bn2binpad failed\\n\");\n+        rc = CKR_FUNCTION_FAILED;\n\
    +        goto done;\n+    }\n+\n+done:\n+    BN_CTX_free(bn_ctx);\n+\n+    return\
    \ rc;\n+}\n+\n+CK_RV openssl_specific_rsa_derive_kdk(STDLL_TokData_t *tokdata,\
    \ OBJECT *key_obj,\n+                                      const CK_BYTE *in,\
    \ CK_ULONG inlen,\n+                                      CK_BYTE *kdk, CK_ULONG\
    \ kdklen)\n+{\n+    CK_ATTRIBUTE *priv_exp_attr = NULL, *modulus = NULL;\n+  \
    \  CK_BYTE *priv_exp = NULL, *buf = NULL;\n+    EVP_PKEY *pkey = NULL;\n+    EVP_MD_CTX\
    \ *mdctx = NULL;\n+    const EVP_MD *md = NULL;\n+    size_t md_len;\n+    unsigned\
    \ char d_hash[SHA256_HASH_SIZE] = { 0 };\n+    CK_RV rc;\n+\n+    /*\n+     *\
    \ The implementation of this function is copied from OpenSSL's function\n+   \
    \  * derive_kdk() in crypto/rsa/rsa_ossl.c and is slightly modified to fit to\n\
    +     * the OpenCryptoki environment.\n+     * Changes include:\n+     * - Different\
    \ variable and define names.\n+     * - Usage of TRACE_ERROR to report errors\
    \ and issue debug messages.\n+     * - Different return codes.\n+     * - Different\
    \ code to get the private key component 'd'.\n+     * - Use of the EVP APIs instead\
    \ of the internal APIs for Digest and HMAC\n+     *   operations.\n+     */\n\
    +\n+    if (kdklen != SHA256_HASH_SIZE) {\n+        TRACE_ERROR(\"KDK length is\
    \ wrong\\n\");\n+        return CKR_ARGUMENTS_BAD;\n+    }\n+\n+    rc = template_attribute_get_non_empty(key_obj->template,\
    \ CKA_MODULUS,\n+                                          &modulus);\n+    if\
    \ (rc != CKR_OK) {\n+        TRACE_ERROR(\"Failed to get CKA_MODULUS\\n\");\n\
    +        return rc;\n+    }\n+\n+    buf = calloc(1, modulus->ulValueLen);\n+\
    \    if (buf == NULL) {\n+        TRACE_ERROR(\"Failed to allocate a buffer for\
    \ private exponent\\n\");\n+        return CKR_HOST_MEMORY;\n+    }\n+\n+    rc\
    \ = template_attribute_get_non_empty(key_obj->template,\n+                   \
    \                       CKA_PRIVATE_EXPONENT, &priv_exp_attr);\n+    if (rc !=\
    \ CKR_OK && rc != CKR_TEMPLATE_INCOMPLETE) {\n+        TRACE_ERROR(\"Failed to\
    \ get CKA_PRIVATE_EXPONENT\\n\");\n+        goto out;\n+    }\n+\n+    if (priv_exp_attr\
    \ == NULL) {\n+        rc = calc_rsa_priv_exp(tokdata, key_obj, buf, modulus->ulValueLen);\n\
    +        if (rc != CKR_OK) {\n+            TRACE_ERROR(\"calc_rsa_priv_exp failed\\\
    n\");\n+            goto out;\n+        }\n+        priv_exp = buf;\n+    } else\
    \ {\n+        if (priv_exp_attr->ulValueLen < modulus->ulValueLen) {\n+      \
    \      memcpy(buf + modulus->ulValueLen - priv_exp_attr->ulValueLen,\n+      \
    \             priv_exp_attr->pValue, priv_exp_attr->ulValueLen);\n+          \
    \  priv_exp = buf;\n+        } else {\n+            priv_exp = (CK_BYTE *)priv_exp_attr->pValue\
    \ +\n+                            priv_exp_attr->ulValueLen - modulus->ulValueLen;\n\
    +        }\n+    }\n+\n+    /*\n+     * we use hardcoded hash so that migrating\
    \ between versions that use\n+     * different hash doesn't provide a Bleichenbacher\
    \ oracle:\n+     * if the attacker can see that different versions return different\n\
    +     * messages for the same ciphertext, they'll know that the message is\n+\
    \     * synthetically generated, which means that the padding check failed\n+\
    \     */\n+    md = EVP_sha256();\n+    if (md == NULL) {\n+        TRACE_ERROR(\"\
    EVP_sha256 failed\\n\");\n+        rc = CKR_FUNCTION_FAILED;\n+        goto out;\n\
    +    }\n+\n+    if (EVP_Digest(priv_exp, modulus->ulValueLen, d_hash, NULL,\n\
    +                   md, NULL) <= 0) {\n+        TRACE_ERROR(\"EVP_Digest failed\\\
    n\");\n+        rc = CKR_FUNCTION_FAILED;\n+        goto out;\n+    }\n+\n+  \
    \  pkey = EVP_PKEY_new_mac_key(EVP_PKEY_HMAC, NULL, d_hash, sizeof(d_hash));\n\
    +    if (pkey == NULL) {\n+        TRACE_ERROR(\"EVP_PKEY_new_mac_key() failed.\\\
    n\");\n+        rc = CKR_FUNCTION_FAILED;\n+        goto out;\n+    }\n+\n+  \
    \  mdctx = EVP_MD_CTX_create();\n+    if (mdctx == NULL) {\n+        TRACE_ERROR(\"\
    EVP_MD_CTX_create() failed.\\n\");\n+        rc = CKR_FUNCTION_FAILED;\n+    \
    \    goto out;\n+    }\n+\n+    if (EVP_DigestSignInit(mdctx, NULL, md, NULL,\
    \ pkey) != 1) {\n+        TRACE_ERROR(\"EVP_DigestSignInit failed\\n\");\n+  \
    \      rc = CKR_FUNCTION_FAILED;\n+        goto out;\n+    }\n+\n+    if (inlen\
    \ < modulus->ulValueLen) {\n+        memset(buf, 0, modulus->ulValueLen - inlen);\n\
    +        if (EVP_DigestSignUpdate(mdctx, buf, modulus->ulValueLen - inlen)!= 1)\
    \ {\n+            TRACE_ERROR(\"EVP_DigestSignUpdate failed\\n\");\n+        \
    \    rc = CKR_FUNCTION_FAILED;\n+            goto out;\n+        }\n+    }\n+\
    \    if (EVP_DigestSignUpdate(mdctx, in, inlen) != 1) {\n+        TRACE_ERROR(\"\
    EVP_DigestSignUpdate failed\\n\");\n+        rc = CKR_FUNCTION_FAILED;\n+    \
    \    goto out;\n+    }\n+\n+    md_len = kdklen;\n+    if (EVP_DigestSignFinal(mdctx,\
    \ kdk, &md_len) != 1 ||\n+        md_len != kdklen) {\n+        TRACE_ERROR(\"\
    EVP_DigestSignFinal failed\\n\");\n+        rc = CKR_FUNCTION_FAILED;\n+     \
    \   goto out;\n+    }\n+\n+    rc = CKR_OK;\n+\n+out:\n+    if (buf != NULL)\n\
    +        free(buf);\n+    if (pkey != NULL)\n+        EVP_PKEY_free(pkey);\n+\
    \    if (mdctx != NULL)\n+        EVP_MD_CTX_free(mdctx);\n+\n+    return rc;\n\
    +}\n+\n+CK_RV openssl_specific_rsa_prf(CK_BYTE *out, CK_ULONG outlen,\n+     \
    \                          const char *label, CK_ULONG labellen,\n+          \
    \                     const CK_BYTE *kdk, CK_ULONG kdklen,\n+                \
    \               uint16_t bitlen)\n+{\n+    CK_RV rc;\n+    CK_ULONG pos;\n+  \
    \  uint16_t iter = 0;\n+    unsigned char be_iter[sizeof(iter)];\n+    unsigned\
    \ char be_bitlen[sizeof(bitlen)];\n+    EVP_PKEY *pkey = NULL;\n+    EVP_MD_CTX\
    \ *mdctx = NULL;\n+    unsigned char hmac_out[SHA256_HASH_SIZE];\n+    size_t\
    \ md_len;\n+\n+    /*\n+     * The implementation of this function is copied from\
    \ OpenSSL's function\n+     * ossl_rsa_prf() in crypto/rsa/rsapk1.c and is slightly\
    \ modified to fit to\n+     * the providers environment.\n+     * Changes include:\n\
    +     * - Different variable and define names.\n+     * - Usage of TRACE_ERROR\
    \ report errors and issue debug messages.\n+     * - Different return codes.\n\
    +     * - Use of the EVP API instead of the internal APIs for HMAC operations.\n\
    +     */\n+\n+    if (kdklen != SHA256_HASH_SIZE) {\n+        TRACE_ERROR(\"invalid\
    \ kdklen\\n\");\n+        return CKR_ARGUMENTS_BAD;\n+    }\n+    if (outlen *\
    \ 8 != bitlen) {\n+        TRACE_ERROR(\"invalid outlen\\n\");\n+        return\
    \ CKR_ARGUMENTS_BAD;\n+    }\n+\n+    be_bitlen[0] = (bitlen >> 8) & 0xff;\n+\
    \    be_bitlen[1] = bitlen & 0xff;\n+\n+    pkey = EVP_PKEY_new_mac_key(EVP_PKEY_HMAC,\
    \ NULL, kdk, kdklen);\n+    if (pkey == NULL) {\n+        TRACE_ERROR(\"EVP_PKEY_new_mac_key()\
    \ failed.\\n\");\n+        rc = CKR_FUNCTION_FAILED;\n+        goto out;\n+  \
    \  }\n+\n+    mdctx = EVP_MD_CTX_create();\n+    if (mdctx == NULL) {\n+     \
    \   TRACE_ERROR(\"EVP_MD_CTX_create() failed.\\n\");\n+        rc = CKR_FUNCTION_FAILED;\n\
    +        goto out;\n+    }\n+\n+    /*\n+     * we use hardcoded hash so that\
    \ migrating between versions that use\n+     * different hash doesn't provide\
    \ a Bleichenbacher oracle:\n+     * if the attacker can see that different versions\
    \ return different\n+     * messages for the same ciphertext, they'll know that\
    \ the message is\n+     * synthetically generated, which means that the padding\
    \ check failed\n+     */\n+    for (pos = 0; pos < outlen; pos += SHA256_HASH_SIZE,\
    \ iter++) {\n+        if (EVP_DigestSignInit(mdctx, NULL, EVP_sha256(), NULL,\
    \ pkey) != 1) {\n+            TRACE_ERROR(\"EVP_DigestSignInit failed\\n\");\n\
    +            rc = CKR_FUNCTION_FAILED;\n+            goto out;\n+        }\n+\n\
    +        be_iter[0] = (iter >> 8) & 0xff;\n+        be_iter[1] = iter & 0xff;\n\
    +\n+        if (EVP_DigestSignUpdate(mdctx, be_iter, sizeof(be_iter)) != 1) {\n\
    +            TRACE_ERROR(\"EVP_DigestSignUpdate failed\\n\");\n+            rc\
    \ = CKR_FUNCTION_FAILED;\n+            goto out;\n+        }\n+        if (EVP_DigestSignUpdate(mdctx,\
    \ (unsigned char *)label, labellen) != 1) {\n+            TRACE_ERROR(\"EVP_DigestSignUpdate\
    \ failed\\n\");\n+            rc = CKR_FUNCTION_FAILED;\n+            goto out;\n\
    +        }\n+        if (EVP_DigestSignUpdate(mdctx, be_bitlen, sizeof(be_bitlen))\
    \ != 1) {\n+            TRACE_ERROR(\"EVP_DigestSignUpdate failed\\n\");\n+  \
    \          rc = CKR_FUNCTION_FAILED;\n+            goto out;\n+        }\n+\n\
    +        /*\n+         * HMAC_Final requires the output buffer to fit the whole\
    \ MAC\n+         * value, so we need to use the intermediate buffer for the last\n\
    +         * unaligned block\n+         */\n+        md_len = SHA256_HASH_SIZE;\n\
    +        if (pos + SHA256_HASH_SIZE > outlen) {\n+            md_len = sizeof(hmac_out);\n\
    +            if (EVP_DigestSignFinal(mdctx, hmac_out, &md_len) != 1) {\n+    \
    \            TRACE_ERROR(\"EVP_DigestSignFinal failed\\n\");\n+              \
    \  rc = CKR_FUNCTION_FAILED;\n+                goto out;\n+            }\n+  \
    \          memcpy(out + pos, hmac_out, outlen - pos);\n+        } else {\n+  \
    \          md_len = outlen - pos;\n+            if (EVP_DigestSignFinal(mdctx,\
    \ out + pos, &md_len) != 1) {\n+                TRACE_ERROR(\"EVP_DigestSignFinal\
    \ failed\\n\");\n+                rc = CKR_FUNCTION_FAILED;\n+               \
    \ goto out;\n+            }\n+        }\n+    }\n+\n+    rc = CKR_OK;\n+\n+out:\n\
    +    if (pkey != NULL)\n+        EVP_PKEY_free(pkey);\n+    if (mdctx != NULL)\n\
    +        EVP_MD_CTX_free(mdctx);\n+\n+    return rc;\n+}\n+"
  - "--- a/usr/lib/common/mech_rsa.c\n+++ b/usr/lib/common/mech_rsa.c\n@@ -289,21\
    \ +289,34 @@ static CK_RV rsa_parse_block_type_1(CK_BYTE *in_data,\n     return\
    \ rc;\n }\n \n+#define MAX_LEN_GEN_TRIES 128\n+\n static CK_RV rsa_parse_block_type_2(CK_BYTE\
    \ *in_data,\n                                     CK_ULONG in_data_len,\n    \
    \                                 CK_BYTE *out_data,\n-                      \
    \              CK_ULONG *out_data_len)\n+                                    CK_ULONG\
    \ *out_data_len,\n+                                    CK_BYTE *kdk, CK_ULONG\
    \ kdklen)\n {\n-    int i;\n-    unsigned char *em = NULL;\n-    unsigned int\
    \ good, found_zero_byte, mask, equals0;\n-    int zero_index = 0, msg_index, mlen\
    \ = -1;\n-    int out_len = *out_data_len;\n-    int rsa_size = in_data_len;\n\
    +    unsigned int good = 0, found_zero_byte, equals0;\n+    size_t zero_index\
    \ = 0, msg_index;\n+    unsigned char *synthetic = NULL;\n+    int synthetic_length;\n\
    +    uint16_t len_candidate;\n+    unsigned char candidate_lengths[MAX_LEN_GEN_TRIES\
    \ * sizeof(len_candidate)];\n+    uint16_t len_mask;\n+    uint16_t max_sep_offset;\n\
    +    int synth_msg_index = 0;\n+    size_t i, j;\n+    CK_RV rc;\n+\n+    if (kdk\
    \ == NULL || kdklen == 0) {\n+        TRACE_DEVEL(\"%s\\n\", ock_err(ERR_ARGUMENTS_BAD));\n\
    +        return CKR_ARGUMENTS_BAD;\n+    }\n \n     /*\n      * The implementation\
    \ of this function is copied from OpenSSL's function\n-     * RSA_padding_check_PKCS1_type_2()\
    \ in crypto/rsa/rsa_pk1.c\n+     * ossl_rsa_padding_check_PKCS1_type_2() in crypto/rsa/rsa_pk1.c\n\
    \      * and is slightly modified to fit to the OpenCryptoki environment.\n  \
    \    *\n      * The OpenSSL code is licensed under the Apache License 2.0.\n@@\
    \ -328,35 +341,75 @@ static CK_RV rsa_parse_block_type_2(CK_BYTE *in_data,\n \
    \     * PKCS#1 v1.5 decryption. See \"PKCS #1 v2.2: RSA Cryptography Standard\"\
    ,\n      * section 7.2.2.\n      */\n-    if (rsa_size < RSA_PKCS1_PADDING_SIZE)\
    \ {\n+    if (in_data_len < RSA_PKCS1_PADDING_SIZE) {\n         TRACE_DEVEL(\"\
    %s\\n\", ock_err(ERR_FUNCTION_FAILED));\n         return CKR_FUNCTION_FAILED;\n\
    \     }\n \n-    em = malloc(rsa_size);\n-    if (em == NULL) {\n-        TRACE_DEVEL(\"\
    %s\\n\", ock_err(ERR_HOST_MEMORY));\n+    /* Generate a random message to return\
    \ in case the padding checks fail. */\n+    synthetic = calloc(1, in_data_len);\n\
    +    if (synthetic == NULL) {\n+        TRACE_ERROR(\"Failed to allocate synthetic\
    \ buffer\");\n         return CKR_HOST_MEMORY;\n     }\n \n-    /* in_data_len\
    \ is always equal to rsa_size */\n-    memcpy(em, in_data, rsa_size);\n+    rc\
    \ = openssl_specific_rsa_prf(synthetic, in_data_len, \"message\", 7,\n+      \
    \                            kdk, kdklen, in_data_len * 8);\n+    if (rc != CKR_OK)\n\
    +        goto out;\n+\n+    /* decide how long the random message should be */\n\
    +    rc = openssl_specific_rsa_prf(candidate_lengths,\n+                     \
    \             sizeof(candidate_lengths),\n+                                  \"\
    length\", 6, kdk, kdklen,\n+                                  MAX_LEN_GEN_TRIES\
    \ *\n+                                              sizeof(len_candidate) * 8);\n\
    +    if (rc != CKR_OK)\n+        goto out;\n \n-    good = constant_time_is_zero(em[0]);\n\
    -    good &= constant_time_eq(em[1], 2);\n+    /*\n+     * max message size is\
    \ the size of the modulus size minus 2 bytes for\n+     * version and padding\
    \ type and a minimum of 8 bytes padding\n+     */\n+    len_mask = max_sep_offset\
    \ = in_data_len - 2 - 8;\n+    /*\n+     * we want a mask so let's propagate the\
    \ high bit to all positions less\n+     * significant than it\n+     */\n+   \
    \ len_mask |= len_mask >> 1;\n+    len_mask |= len_mask >> 2;\n+    len_mask |=\
    \ len_mask >> 4;\n+    len_mask |= len_mask >> 8;\n+\n+    synthetic_length =\
    \ 0;\n+    for (i = 0; i < MAX_LEN_GEN_TRIES * (int)sizeof(len_candidate);\n+\
    \                                            i += sizeof(len_candidate)) {\n+\
    \        len_candidate = (candidate_lengths[i] << 8) |\n+                    \
    \                            candidate_lengths[i + 1];\n+        len_candidate\
    \ &= len_mask;\n+\n+        synthetic_length = constant_time_select_int(\n+  \
    \                      constant_time_lt(len_candidate, max_sep_offset),\n+   \
    \                                      len_candidate, synthetic_length);\n+  \
    \  }\n+\n+    synth_msg_index = in_data_len - synthetic_length;\n+\n+    good\
    \ = constant_time_is_zero(in_data[0]);\n+    good &= constant_time_eq(in_data[1],\
    \ 2);\n \n     /* scan over padding data */\n     found_zero_byte = 0;\n-    for\
    \ (i = 2; i < rsa_size; i++) {\n-        equals0 = constant_time_is_zero(em[i]);\n\
    +    for (i = 2; i < in_data_len; i++) {\n+        equals0 = constant_time_is_zero(in_data[i]);\n\
    \ \n         zero_index = constant_time_select_int(~found_zero_byte & equals0,\n\
    \                                               i, zero_index);\n         found_zero_byte\
    \ |= equals0;\n     }\n \n     /*\n-     * PS must be at least 8 bytes long, and\
    \ it starts two bytes into |em|.\n+     * PS must be at least 8 bytes long, and\
    \ it starts two bytes into |in_data|.\n      * If we never found a 0-byte, then\
    \ |zero_index| is 0 and the check\n      * also fails.\n      */\n@@ -367,61 +420,49\
    \ @@ static CK_RV rsa_parse_block_type_2(CK_BYTE *in_data,\n      * but in this\
    \ case we also do not copy the message out.\n      */\n     msg_index = zero_index\
    \ + 1;\n-    mlen = rsa_size - msg_index;\n \n     /*\n-     * For good measure,\
    \ do this check in constant time as well.\n+     * old code returned an error\
    \ in case the decrypted message wouldn't fit\n+     * into the |out_data|, since\
    \ that would leak information, return the\n+     * synthetic message instead\n\
    \      */\n-    good &= constant_time_ge(out_len, mlen);\n+    good &= constant_time_ge(*out_data_len,\
    \ in_data_len - msg_index);\n+\n+    msg_index = constant_time_select_int(good,\
    \ msg_index, synth_msg_index);\n \n     /*\n-     * Move the result in-place by\
    \ |rsa_size|-RSA_PKCS1_PADDING_SIZE-|mlen|\n-     * bytes to the left.\n-    \
    \ * Then if |good| move |mlen| bytes from |em|+RSA_PKCS1_PADDING_SIZE to\n-  \
    \   * |out_data|. Otherwise leave |out_data| unchanged.\n-     * Copy the memory\
    \ back in a way that does not reveal the size of\n-     * the data being copied\
    \ via a timing side channel. This requires copying\n-     * parts of the buffer\
    \ multiple times based on the bits set in the real\n-     * length. Clear bits\
    \ do a non-copy with identical access pattern.\n-     * The loop below has overall\
    \ complexity of O(N*log(N)).\n+     * since at this point the |msg_index| does\
    \ not provide the signal\n+     * indicating if the padding check failed or not,\
    \ we don't have to worry\n+     * about leaking the length of returned message,\
    \ we still need to ensure\n+     * that we read contents of both buffers so that\
    \ cache accesses don't leak\n+     * the value of |good|\n      */\n-    out_len\
    \ = constant_time_select_int(\n-            constant_time_lt(rsa_size - RSA_PKCS1_PADDING_SIZE,\
    \ out_len),\n-            rsa_size - RSA_PKCS1_PADDING_SIZE,\n-            out_len);\n\
    -    for (msg_index = 1; msg_index < rsa_size - RSA_PKCS1_PADDING_SIZE;\n-   \
    \                                                         msg_index <<= 1) {\n\
    -        mask = ~constant_time_eq(\n-                    msg_index & (rsa_size\
    \ - RSA_PKCS1_PADDING_SIZE - mlen), 0);\n-        for (i = RSA_PKCS1_PADDING_SIZE;\
    \ i < rsa_size - msg_index; i++)\n-            em[i] = constant_time_select_8(mask,\
    \ em[i + msg_index], em[i]);\n-    }\n-    for (i = 0; i < out_len; i++) {\n-\
    \        mask = good & constant_time_lt(i, mlen);\n-        out_data[i] = constant_time_select_8(\n\
    -                        mask, em[i + RSA_PKCS1_PADDING_SIZE], out_data[i]);\n\
    -    }\n+    for (i = msg_index, j = 0; i < in_data_len && j < *out_data_len;\n\
    +                                                                i++, j++)\n+\
    \        out_data[j] = constant_time_select_8(good, in_data[i], synthetic[i]);\n\
    \ \n-    OPENSSL_cleanse(em, rsa_size);\n-    free(em);\n+    *out_data_len =\
    \ j;\n \n-    *out_data_len = constant_time_select_int(good, mlen, 0);\n+out:\n\
    +    if (synthetic != NULL)\n+        free(synthetic);\n \n-    return constant_time_select_int(good,\
    \ CKR_OK, CKR_ENCRYPTED_DATA_INVALID);\n+    return rc;\n }\n \n CK_RV rsa_parse_block(CK_BYTE\
    \ *in_data,\n                       CK_ULONG in_data_len,\n                  \
    \     CK_BYTE *out_data,\n-                      CK_ULONG *out_data_len, CK_ULONG\
    \ type)\n+                      CK_ULONG *out_data_len, CK_ULONG type,\n+    \
    \                  CK_BYTE *kdk, CK_ULONG kdklen)\n {\n     switch (type) {\n\
    \     case PKCS_BT_1:\n         return rsa_parse_block_type_1(in_data, in_data_len,\n\
    \                                         out_data, out_data_len);\n     case\
    \ PKCS_BT_2:\n         return rsa_parse_block_type_2(in_data, in_data_len,\n-\
    \                                       out_data, out_data_len);\n+          \
    \                             out_data, out_data_len, kdk, kdklen);\n     }\n\
    \ \n     return CKR_ARGUMENTS_BAD;"
  identifiers: CVE:["CVE-2024-0914"],CWE:["CWE-203"]
  overview: Affected versions of this package are vulnerable to Observable Timing
    Discrepancy via the handling of RSA PKCS#1 v1.5 padded ciphertexts. An attacker
    can obtain sensitive information by observing the time taken to process these
    ciphertexts (Marvin).
  references:
    GitHub Commit: https://github.com/opencryptoki/opencryptoki/commit/c26e049bf40d656bc51429bad190b82fbf63f0c7
    GitHub Issue: https://github.com/opencryptoki/opencryptoki/issues/731
    GitHub PR: https://github.com/opencryptoki/opencryptoki/pull/737
    RedHat Bugzilla Bug: https://bugzilla.redhat.com/show_bug.cgi?id=2260407
    Vulnerability Report: https://people.redhat.com/~hkario/marvin/
  title: Observable Timing Discrepancy
- diff_content:
  - "--- a/pe.c\n+++ b/pe.c\n@@ -355,7 +355,11 @@ verify_sbat_section(char *SBATBase,\
    \ size_t SBATSize)\n \t\treturn in_protocol ? EFI_SUCCESS : EFI_SECURITY_VIOLATION;\n\
    \ \t}\n \n-\tsbat_size = SBATSize + 1;\n+\tif (checked_add(SBATSize, 1, &sbat_size))\
    \ {\n+\t\tdprint(L\"SBATSize + 1 would overflow\\n\");\n+\t\treturn EFI_SECURITY_VIOLATION;\n\
    +\t}\n+\n \tsbat_data = AllocatePool(sbat_size);\n \tif (!sbat_data) {\n \t\t\
    console_print(L\"Failed to allocate .sbat section buffer\\n\");"
  - "--- a/shim.c\n+++ b/shim.c\n@@ -743,11 +743,17 @@ verify_buffer_sbat (char *data,\
    \ int datasize,\n \t\t * and ignore the section if it isn't. */\n \t\tif (Section->SizeOfRawData\
    \ &&\n \t\t    Section->SizeOfRawData >= Section->Misc.VirtualSize) {\n+\t\t\t\
    uint64_t boundary;\n \t\t\tSBATBase = ImageAddress(data, datasize,\n \t\t\t\t\t\
    \tSection->PointerToRawData);\n \t\t\tSBATSize = Section->SizeOfRawData;\n \t\t\
    \tdprint(L\"sbat section base:0x%lx size:0x%lx\\n\",\n \t\t\t       SBATBase,\
    \ SBATSize);\n+\t\t\tif (checked_add((uint64_t)SBATBase, SBATSize, &boundary)\
    \ ||\n+\t\t\t    (boundary > (uint64_t)data + datasize)) {\n+\t\t\t\tperror(L\"\
    Section exceeds bounds of image\\n\");\n+\t\t\t\treturn EFI_UNSUPPORTED;\n+\t\t\
    \t}\n \t\t}\n \t}\n "
  identifiers: CVE:["CVE-2023-40548"],CWE:["CWE-122"]
  overview: Affected versions of this package are vulnerable to Heap-based Buffer
    Overflow via an addition operation involving a user-controlled value parsed from
    the PE binary. An attacker can cause memory corruption and potentially execute
    arbitrary code by providing a crafted PE binary that triggers the overflow during
    the boot phase.
  references:
    GitHub Commit: https://github.com/rhboot/shim/commit/96dccc255b16e9465dbee50b3cef6b3db74d11c8
    RedHat Bugzilla Bug: https://bugzilla.redhat.com/show_bug.cgi?id=2241782
  title: Heap-based Buffer Overflow
- diff_content:
  - "--- a/shim.c\n+++ b/shim.c\n@@ -627,11 +627,13 @@ verify_buffer_authenticode\
    \ (char *data, int datasize,\n \t\treturn EFI_SECURITY_VIOLATION;\n \t}\n \n-\t\
    if (context->SecDir->Size >= size) {\n+\tif (checked_add(context->SecDir->Size,\
    \ context->SecDir->VirtualAddress, &offset) ||\n+\t    offset > size) {\n \t\t\
    perror(L\"Certificate Database size is too large\\n\");\n \t\treturn EFI_INVALID_PARAMETER;\n\
    \ \t}\n \n+\toffset = 0;\n \tret_efi_status = EFI_NOT_FOUND;\n \tdo {\n \t\tWIN_CERTIFICATE_EFI_PKCS\
    \ *sig = NULL;\n@@ -642,6 +644,11 @@ verify_buffer_authenticode (char *data, int\
    \ datasize,\n \t\tif (!sig)\n \t\t\tbreak;\n \n+\t\tif ((uint64_t)&sig[1] > (uint64_t)data\
    \ + datasize) {\n+\t\t\tperror(L\"Certificate size is too large for secruity database\"\
    );\n+\t\t\treturn EFI_INVALID_PARAMETER;\n+\t\t}\n+\n \t\tsz = offset + offsetof(WIN_CERTIFICATE_EFI_PKCS,\
    \ Hdr.dwLength)\n \t\t     + sizeof(sig->Hdr.dwLength);\n \t\tif (sz > context->SecDir->Size)\
    \ {"
  identifiers: CVE:["CVE-2023-40549"],CWE:["CWE-125"]
  overview: Affected versions of this package are vulnerable to Out-of-bounds Read
    due to the lack of proper boundary verification during the load of a PE binary.
    An attacker can crash the system, resulting in a denial of service.
  references:
    GitHub Commit: https://github.com/rhboot/shim/commit/afdc5039de0a4a3a40162a32daa070f94a883f09
    RedHat Bugzilla Bug: https://bugzilla.redhat.com/show_bug.cgi?id=2241797
  title: Out-of-bounds Read
- diff_content:
  - "--- a/pe-relocate.c\n+++ b/pe-relocate.c\n@@ -309,7 +309,7 @@ static int\n image_is_64_bit(EFI_IMAGE_OPTIONAL_HEADER_UNION\
    \ *PEHdr)\n {\n \t/* .Magic is the same offset in all cases */\n-\tif (PEHdr->Pe32Plus.OptionalHeader.Magic\n\
    +\tif (PEHdr->Pe32.OptionalHeader.Magic\n \t\t\t== EFI_IMAGE_NT_OPTIONAL_HDR64_MAGIC)\n\
    \ \t\treturn 1;\n \treturn 0;\n@@ -375,14 +375,34 @@ read_header(void *data, unsigned\
    \ int datasize,\n \tunsigned long HeaderWithoutDataDir, SectionHeaderOffset, OptHeaderSize;\n\
    \ \tunsigned long FileAlignment = 0;\n \tUINT16 DllFlags;\n+\tsize_t dos_sz =\
    \ 0;\n \n-\tif (datasize < sizeof (PEHdr->Pe32)) {\n+\tif (datasize < sizeof (*DosHdr))\
    \ {\n \t\tperror(L\"Invalid image\\n\");\n \t\treturn EFI_UNSUPPORTED;\n \t}\n\
    \ \n-\tif (DosHdr->e_magic == EFI_IMAGE_DOS_SIGNATURE)\n+\tif (DosHdr->e_magic\
    \ == EFI_IMAGE_DOS_SIGNATURE) {\n+\t\tif (DosHdr->e_lfanew < sizeof (*DosHdr)\
    \ ||\n+\t\t    DosHdr->e_lfanew > datasize - 4) {\n+\t\t\tperror(L\"Invalid image\\\
    n\");\n+\t\t\treturn EFI_UNSUPPORTED;\n+\t\t}\n+\n+\t\tdos_sz = DosHdr->e_lfanew;\n\
    \ \t\tPEHdr = (EFI_IMAGE_OPTIONAL_HEADER_UNION *)((char *)data + DosHdr->e_lfanew);\n\
    +\t}\n+\n+\tif (datasize - dos_sz < sizeof (PEHdr->Pe32)) {\n+\t\tperror(L\"Invalid\
    \ image\\n\");\n+\t\treturn EFI_UNSUPPORTED;\n+\t}\n+\n+\tif (image_is_64_bit(PEHdr)\
    \ &&\n+\t    (datasize - dos_sz < sizeof (PEHdr->Pe32Plus))) {\n+\t\tperror(L\"\
    Invalid image\\n\");\n+\t\treturn EFI_UNSUPPORTED;\n+\t}\n \n \tif (!image_is_loadable(PEHdr))\
    \ {\n \t\tperror(L\"Platform does not support this image\\n\");"
  identifiers: CVE:["CVE-2023-40551"],CWE:["CWE-125"]
  overview: Affected versions of this package are vulnerable to Out-of-bounds Read
    due to improper handling of the MZ binary format during the system's boot phase.
    An attacker with local access can cause a crash or potentially disclose sensitive
    information.
  references:
    GitHub Commit: https://github.com/rhboot/shim/commit/5a5147d1e19cf90ec280990c84061ac3f67ea1ab
    RedHat Bugzilla Bug: https://bugzilla.redhat.com/show_bug.cgi?id=2259918
  title: Out-of-bounds Read
- diff_content:
  - "--- a/mok.c\n+++ b/mok.c\n@@ -291,7 +291,7 @@ mirror_one_esl(CHAR16 *name, EFI_GUID\
    \ *guid, UINT32 attrs,\n \t\t\t\t\t &var, &varsz);\n \tif (EFI_ERROR(efi_status)\
    \ || !var || !varsz) {\n \t\tLogError(L\"Couldn't allocate %lu bytes for mok variable\
    \ \\\"%s\\\": %r\\n\",\n-\t\t\t varsz, var, efi_status);\n+\t\t\t varsz, name,\
    \ efi_status);\n \t\treturn efi_status;\n \t}\n \n@@ -302,7 +302,7 @@ mirror_one_esl(CHAR16\
    \ *name, EFI_GUID *guid, UINT32 attrs,\n \tFreePool(var);\n \tif (EFI_ERROR(efi_status))\
    \ {\n \t\tLogError(L\"Couldn't create mok variable \\\"%s\\\": %r\\n\",\n-\t\t\
    \t varsz, var, efi_status);\n+\t\t\t name, efi_status);\n \t\treturn efi_status;\n\
    \ \t}\n "
  identifiers: CVE:["CVE-2023-40546"],CWE:["CWE-476"]
  overview: Affected versions of this package are vulnerable to NULL Pointer Dereference
    due to an improper handling of error messages. An attacker can cause a system
    crash or read sensitive information from memory by triggering an out-of-bounds
    read.
  references:
    GitHub Commit: https://github.com/rhboot/shim/commit/66e6579dbf921152f647a0c16da1d3b2f40861ca
    RedHat Bugzilla Bug: https://bugzilla.redhat.com/show_bug.cgi?id=2241796
  title: NULL Pointer Dereference
- diff_content:
  - "--- a/shim.c\n+++ b/shim.c\n@@ -709,6 +709,11 @@ verify_buffer_sbat (char *data,\
    \ int datasize,\n \n \tSection = context->FirstSection;\n \tfor (i = 0; i < context->NumberOfSections;\
    \ i++, Section++) {\n+\t\tif ((uint64_t)&Section[1] > (uint64_t)data + datasize)\
    \ {\n+\t\t\tperror(L\"Section exceeds bounds of image\\n\");\n+\t\t\treturn EFI_UNSUPPORTED;\n\
    +\t\t}\n+\n \t\tif (CompareMem(Section->Name, \".sbat\\0\\0\\0\", 8) != 0)\n \t\
    \t\tcontinue;\n "
  identifiers: CVE:["CVE-2023-40550"],CWE:["CWE-125"]
  overview: Affected versions of this package are vulnerable to Out-of-bounds Read
    due to improper validation of SBAT information during the system's boot phase.
    An attacker can expose sensitive data by exploiting the flaw in the boot validation
    process.
  references:
    GitHub Commit: https://github.com/rhboot/shim/commit/93ce2552f3e9f71f888a672913bfc0eef255c56d
    RedHat Bugzilla Bug: https://bugzilla.redhat.com/show_bug.cgi?id=2259915
  title: Out-of-bounds Read
- diff_content:
  - "--- a/libavcodec/osq.c\n+++ b/libavcodec/osq.c\n@@ -52,7 +52,7 @@ typedef struct\
    \ OSQContext {\n \n     int decorrelate;\n     int frame_samples;\n-    int64_t\
    \ nb_samples;\n+    uint64_t nb_samples;\n \n     int32_t *decode_buffer[2];\n\
    \ "
  identifiers: CVE:["CVE-2024-22861"],CWE:["CWE-190"]
  overview: Affected versions of this package are vulnerable to Integer Overflow or
    Wraparound due to an integer overflow in the `avcodec/osq` module. An attacker
    can cause a crash or disruption of service by supplying crafted input that triggers
    the overflow.
  references:
    GitHub Commit: https://github.com/FFmpeg/FFmpeg/commit/87b8c1081959e45ffdcbabb3d53ac9882ef2b5ce
  title: Integer Overflow or Wraparound
- diff_content:
  - "--- a/libavcodec/jpegxl_parser.c\n+++ b/libavcodec/jpegxl_parser.c\n@@ -1326,7\
    \ +1326,7 @@ static int skip_boxes(JXLParseContext *ctx, const uint8_t *buf, int\
    \ buf_size)\n         if (!size)\n             return AVERROR_INVALIDDATA;\n \
    \        /* invalid ISOBMFF size */\n-        if (size <= head_size + 4)\n+  \
    \      if (size <= head_size + 4 || size > INT_MAX - ctx->skip)\n            \
    \ return AVERROR_INVALIDDATA;\n \n         ctx->skip += size;"
  identifiers: CVE:["CVE-2024-22862"],CWE:["CWE-190"]
  overview: Affected versions of this package are vulnerable to Integer Overflow to
    Buffer Overflow via the JPEG XL Parser. An attacker can trigger the overflow and
    execute arbitrary code by providing a crafted JPEG XL file.
  references:
    Chromium Bugs: https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=62113
    GitHub Commit: https://github.com/FFmpeg/FFmpeg/commit/ca09d8a0dcd82e3128e62463231296aaf63ae6f7
  title: Integer Overflow to Buffer Overflow
- diff_content:
  - "--- a/libavformat/jpegxl_anim_dec.c\n+++ b/libavformat/jpegxl_anim_dec.c\n@@\
    \ -152,6 +152,8 @@ static int jpegxl_anim_read_packet(AVFormatContext *s, AVPacket\
    \ *pkt)\n     size = avio_size(pb);\n     if (size < 0)\n         return size;\n\
    +    if (size > INT_MAX)\n+        return AVERROR(EDOM);\n     if (size == 0)\n\
    \         size = 4096;\n "
  identifiers: CVE:["CVE-2024-22860"],CWE:["CWE-190"]
  overview: Affected versions of this package are vulnerable to Integer Overflow or
    Wraparound via the `jpegxl_anim_read_packet` component in the JPEG XL Animation
    decoder. An attacker can execute arbitrary code by sending crafted input that
    triggers the integer overflow.
  references:
    Chromium Bugs: https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=61991
    GitHub Commit: https://github.com/FFmpeg/FFmpeg/commit/d2e8974699a9e35cc1a926bf74a972300d629cd5
  title: Integer Overflow or Wraparound
- diff_content:
  - "--- a/src/coap_oscore.c\n+++ b/src/coap_oscore.c\n@@ -1678,11 +1678,12 @@ get_split_entry(const\
    \ char **start,\n                 oscore_value_t *value) {\n   const char *begin\
    \ = *start;\n   const char *end;\n+  const char *kend;\n   const char *split;\n\
    \   size_t i;\n \n retry:\n-  end = memchr(begin, '\\n', size);\n+  kend = end\
    \ = memchr(begin, '\\n', size);\n   if (end == NULL)\n     return 0;\n \n@@ -1693,7\
    \ +1694,7 @@ get_split_entry(const char **start,\n \n   if (begin[0] == '#' ||\
    \ (end - begin) == 0) {\n     /* Skip comment / blank line */\n-    size -= end\
    \ - begin + 1;\n+    size -= kend - begin + 1;\n     begin = *start;\n     goto\
    \ retry;\n   }"
  identifiers: CVE:["CVE-2024-0962"],CWE:["CWE-121"]
  overview: Affected versions of this package are vulnerable to Stack-based Buffer
    Overflow via the `get_split_entry` function of the `src/coap_oscore.c` file. An
    attacker can cause a buffer overflow condition and potentially execute arbitrary
    code or disrupt service by sending crafted input to the affected function.
  references:
    GitHub Commit: https://github.com/obgm/libcoap/commit/2b28d8b0e9607e71a145345b4fe49517e052b7d9
    GitHub Issue: https://github.com/obgm/libcoap/issues/1310#issue-2099860835
    GitHub PR: https://github.com/obgm/libcoap/pull/1311
  title: Stack-based Buffer Overflow
- diff_content:
  - "--- a/net/core/dst.c\n+++ b/net/core/dst.c\n@@ -82,12 +82,8 @@ void *dst_alloc(struct\
    \ dst_ops *ops, struct net_device *dev,\n \n \tif (ops->gc &&\n \t    !(flags\
    \ & DST_NOCOUNT) &&\n-\t    dst_entries_get_fast(ops) > ops->gc_thresh) {\n-\t\
    \tif (ops->gc(ops)) {\n-\t\t\tpr_notice_ratelimited(\"Route cache is full: consider\
    \ increasing sysctl net.ipv6.route.max_size.\\n\");\n-\t\t\treturn NULL;\n-\t\t\
    }\n-\t}\n+\t    dst_entries_get_fast(ops) > ops->gc_thresh)\n+\t\tops->gc(ops);\n\
    \ \n \tdst = kmem_cache_alloc(ops->kmem_cachep, GFP_ATOMIC);\n \tif (!dst)"
  - "--- a/net/ipv6/route.c\n+++ b/net/ipv6/route.c\n@@ -91,7 +91,7 @@ static struct\
    \ dst_entry *ip6_negative_advice(struct dst_entry *);\n static void\t\tip6_dst_destroy(struct\
    \ dst_entry *);\n static void\t\tip6_dst_ifdown(struct dst_entry *,\n \t\t\t\t\
    \       struct net_device *dev, int how);\n-static int\t\t ip6_dst_gc(struct dst_ops\
    \ *ops);\n+static void\t\t ip6_dst_gc(struct dst_ops *ops);\n \n static int\t\t\
    ip6_pkt_discard(struct sk_buff *skb);\n static int\t\tip6_pkt_discard_out(struct\
    \ net *net, struct sock *sk, struct sk_buff *skb);\n@@ -3284,23 +3284,21 @@ struct\
    \ dst_entry *icmp6_dst_alloc(struct net_device *dev,\n \treturn dst;\n }\n \n\
    -static int ip6_dst_gc(struct dst_ops *ops)\n+static void ip6_dst_gc(struct dst_ops\
    \ *ops)\n {\n \tstruct net *net = container_of(ops, struct net, ipv6.ip6_dst_ops);\n\
    \ \tint rt_min_interval = net->ipv6.sysctl.ip6_rt_gc_min_interval;\n-\tint rt_max_size\
    \ = net->ipv6.sysctl.ip6_rt_max_size;\n \tint rt_elasticity = net->ipv6.sysctl.ip6_rt_gc_elasticity;\n\
    \ \tint rt_gc_timeout = net->ipv6.sysctl.ip6_rt_gc_timeout;\n \tunsigned long\
    \ rt_last_gc = net->ipv6.ip6_rt_last_gc;\n \tunsigned int val;\n \tint entries;\n\
    \ \n \tentries = dst_entries_get_fast(ops);\n-\tif (entries > rt_max_size)\n+\t\
    if (entries > ops->gc_thresh)\n \t\tentries = dst_entries_get_slow(ops);\n \n\
    -\tif (time_after(rt_last_gc + rt_min_interval, jiffies) &&\n-\t    entries <=\
    \ rt_max_size)\n+\tif (time_after(rt_last_gc + rt_min_interval, jiffies))\n \t\
    \tgoto out;\n \n \tfib6_run_gc(atomic_inc_return(&net->ipv6.ip6_rt_gc_expire),\
    \ net, true);\n@@ -3310,7 +3308,6 @@ static int ip6_dst_gc(struct dst_ops *ops)\n\
    \ out:\n \tval = atomic_read(&net->ipv6.ip6_rt_gc_expire);\n \tatomic_set(&net->ipv6.ip6_rt_gc_expire,\
    \ val - (val >> rt_elasticity));\n-\treturn entries > rt_max_size;\n }\n \n static\
    \ int ip6_nh_lookup_table(struct net *net, struct fib6_config *cfg,\n@@ -6512,7\
    \ +6509,7 @@ static int __net_init ip6_route_net_init(struct net *net)\n #endif\n\
    \ \n \tnet->ipv6.sysctl.flush_delay = 0;\n-\tnet->ipv6.sysctl.ip6_rt_max_size\
    \ = 4096;\n+\tnet->ipv6.sysctl.ip6_rt_max_size = INT_MAX;\n \tnet->ipv6.sysctl.ip6_rt_gc_min_interval\
    \ = HZ / 2;\n \tnet->ipv6.sysctl.ip6_rt_gc_timeout = 60*HZ;\n \tnet->ipv6.sysctl.ip6_rt_gc_interval\
    \ = 30*HZ;"
  identifiers: CVE:["CVE-2023-52340"],CWE:["CWE-400"]
  overview: Affected versions of this package are vulnerable to Resource Exhaustion
    via the ICMPv6 handling of `Packet Too Big` messages. An attacker can cause a
    denial of service condition by sending crafted ICMPv6 `Packet Too Big` messages
    that exceed the routing table size and garbage collector threshold, leading to
    high CPU usage.
  references:
    GitHub Commit: https://github.com/torvalds/linux/commit/af6d10345ca76670c1b7c37799f0d5576ccef277
  title: Resource Exhaustion
- diff_content:
  - "--- a/net/ipv6/ip6_fib.c\n+++ b/net/ipv6/ip6_fib.c\n@@ -160,8 +160,6 @@ struct\
    \ fib6_info *fib6_info_alloc(gfp_t gfp_flags, bool with_fib6_nh)\n \tINIT_LIST_HEAD(&f6i->fib6_siblings);\n\
    \ \trefcount_set(&f6i->fib6_ref, 1);\n \n-\tINIT_HLIST_NODE(&f6i->gc_link);\n\
    -\n \treturn f6i;\n }\n \n@@ -248,7 +246,6 @@ static struct fib6_table *fib6_alloc_table(struct\
    \ net *net, u32 id)\n \t\t\t\t   net->ipv6.fib6_null_entry);\n \t\ttable->tb6_root.fn_flags\
    \ = RTN_ROOT | RTN_TL_ROOT | RTN_RTINFO;\n \t\tinet_peer_base_init(&table->tb6_peers);\n\
    -\t\tINIT_HLIST_HEAD(&table->tb6_gc_hlist);\n \t}\n \n \treturn table;\n@@ -1060,8\
    \ +1057,6 @@ static void fib6_purge_rt(struct fib6_info *rt, struct fib6_node\
    \ *fn,\n \t\t\t\t    lockdep_is_held(&table->tb6_lock));\n \t\t}\n \t}\n-\n-\t\
    fib6_clean_expires_locked(rt);\n }\n \n /*\n@@ -1123,10 +1118,9 @@ static int\
    \ fib6_add_rt2node(struct fib6_node *fn, struct fib6_info *rt,\n \t\t\t\tif (!(iter->fib6_flags\
    \ & RTF_EXPIRES))\n \t\t\t\t\treturn -EEXIST;\n \t\t\t\tif (!(rt->fib6_flags &\
    \ RTF_EXPIRES))\n-\t\t\t\t\tfib6_clean_expires_locked(iter);\n+\t\t\t\t\tfib6_clean_expires(iter);\n\
    \ \t\t\t\telse\n-\t\t\t\t\tfib6_set_expires_locked(iter,\n-\t\t\t\t\t\t\t\trt->expires);\n\
    +\t\t\t\t\tfib6_set_expires(iter, rt->expires);\n \n \t\t\t\tif (rt->fib6_pmtu)\n\
    \ \t\t\t\t\tfib6_metric_set(iter, RTAX_MTU,\n@@ -1485,10 +1479,6 @@ int fib6_add(struct\
    \ fib6_node *root, struct fib6_info *rt,\n \t\tif (rt->nh)\n \t\t\tlist_add(&rt->nh_list,\
    \ &rt->nh->f6i_list);\n \t\t__fib6_update_sernum_upto_root(rt, fib6_new_sernum(info->nl_net));\n\
    -\n-\t\tif (fib6_has_expires(rt))\n-\t\t\thlist_add_head(&rt->gc_link, &table->tb6_gc_hlist);\n\
    -\n \t\tfib6_start_gc(info->nl_net, rt);\n \t}\n \n@@ -2291,16 +2281,17 @@ static\
    \ void fib6_flush_trees(struct net *net)\n  *\tGarbage collection\n  */\n \n-static\
    \ int fib6_age(struct fib6_info *rt, struct fib6_gc_args *gc_args)\n+static int\
    \ fib6_age(struct fib6_info *rt, void *arg)\n {\n+\tstruct fib6_gc_args *gc_args\
    \ = arg;\n \tunsigned long now = jiffies;\n \n \t/*\n \t *\tcheck addrconf expiration\
    \ here.\n \t *\tRoutes are expired even if they are in use.\n \t */\n \n-\tif\
    \ (fib6_has_expires(rt) && rt->expires) {\n+\tif (rt->fib6_flags & RTF_EXPIRES\
    \ && rt->expires) {\n \t\tif (time_after(now, rt->expires)) {\n \t\t\tRT6_TRACE(\"\
    expiring %p\\n\", rt);\n \t\t\treturn -1;\n@@ -2317,40 +2308,6 @@ static int fib6_age(struct\
    \ fib6_info *rt, struct fib6_gc_args *gc_args)\n \treturn 0;\n }\n \n-static void\
    \ fib6_gc_table(struct net *net,\n-\t\t\t  struct fib6_table *tb6,\n-\t\t\t  struct\
    \ fib6_gc_args *gc_args)\n-{\n-\tstruct fib6_info *rt;\n-\tstruct hlist_node *n;\n\
    -\tstruct nl_info info = {\n-\t\t.nl_net = net,\n-\t\t.skip_notify = false,\n\
    -\t};\n-\n-\thlist_for_each_entry_safe(rt, n, &tb6->tb6_gc_hlist, gc_link)\n-\t\
    \tif (fib6_age(rt, gc_args) == -1)\n-\t\t\tfib6_del(rt, &info);\n-}\n-\n-static\
    \ void fib6_gc_all(struct net *net, struct fib6_gc_args *gc_args)\n-{\n-\tstruct\
    \ fib6_table *table;\n-\tstruct hlist_head *head;\n-\tunsigned int h;\n-\n-\t\
    rcu_read_lock();\n-\tfor (h = 0; h < FIB6_TABLE_HASHSZ; h++) {\n-\t\thead = &net->ipv6.fib_table_hash[h];\n\
    -\t\thlist_for_each_entry_rcu(table, head, tb6_hlist) {\n-\t\t\tspin_lock_bh(&table->tb6_lock);\n\
    -\t\t\tfib6_gc_table(net, table, gc_args);\n-\t\t\tspin_unlock_bh(&table->tb6_lock);\n\
    -\t\t}\n-\t}\n-\trcu_read_unlock();\n-}\n-\n void fib6_run_gc(unsigned long expires,\
    \ struct net *net, bool force)\n {\n \tstruct fib6_gc_args gc_args;\n@@ -2366,7\
    \ +2323,7 @@ void fib6_run_gc(unsigned long expires, struct net *net, bool force)\n\
    \ \t\t\t  net->ipv6.sysctl.ip6_rt_gc_interval;\n \tgc_args.more = 0;\n \n-\tfib6_gc_all(net,\
    \ &gc_args);\n+\tfib6_clean_all(net, fib6_age, &gc_args);\n \tnow = jiffies;\n\
    \ \tnet->ipv6.ip6_rt_last_gc = now;\n "
  - "--- a/net/ipv6/route.c\n+++ b/net/ipv6/route.c\n@@ -3763,10 +3763,10 @@ static\
    \ struct fib6_info *ip6_route_info_create(struct fib6_config *cfg,\n \t\trt->dst_nocount\
    \ = true;\n \n \tif (cfg->fc_flags & RTF_EXPIRES)\n-\t\tfib6_set_expires_locked(rt,\
    \ jiffies +\n-\t\t\t\t\tclock_t_to_jiffies(cfg->fc_expires));\n+\t\tfib6_set_expires(rt,\
    \ jiffies +\n+\t\t\t\tclock_t_to_jiffies(cfg->fc_expires));\n \telse\n-\t\tfib6_clean_expires_locked(rt);\n\
    +\t\tfib6_clean_expires(rt);\n \n \tif (cfg->fc_protocol == RTPROT_UNSPEC)\n \t\
    \tcfg->fc_protocol = RTPROT_BOOT;"
  identifiers: CVE:["CVE-2023-6200"],CWE:["CWE-362"]
  overview: 'Affected versions of this package are vulnerable to Race Condition via
    the processing of ICMPv6 Router Advertisement packets. An attacker can cause arbitrary
    code execution by sending a specially crafted ICMPv6 router advertisement packet
    from an adjacent network. '
  references:
    GitHub Commit: https://github.com/torvalds/linux/commit/dade3f6a1e4e35a5ae916d5e78b3229ec34c78ec
    instruction: https://access.redhat.com/solutions/8709
  title: Race Condition
- diff_content:
  - "--- a/Foundation/src/UTF32Encoding.cpp\n+++ b/Foundation/src/UTF32Encoding.cpp\n\
    @@ -30,22 +30,22 @@ const char* UTF32Encoding::_names[] =\n \n const TextEncoding::CharacterMap\
    \ UTF32Encoding::_charMap =\n {\n-\t/* 00 */\t-2, -2, -2, -2, -2, -2, -2, -2,\
    \ -2, -2, -2, -2, -2, -2, -2, -2,\n-\t/* 10 */\t-2, -2, -2, -2, -2, -2, -2, -2,\
    \ -2, -2, -2, -2, -2, -2, -2, -2,\n-\t/* 20 */\t-2, -2, -2, -2, -2, -2, -2, -2,\
    \ -2, -2, -2, -2, -2, -2, -2, -2,\n-\t/* 30 */\t-2, -2, -2, -2, -2, -2, -2, -2,\
    \ -2, -2, -2, -2, -2, -2, -2, -2,\n-\t/* 40 */\t-2, -2, -2, -2, -2, -2, -2, -2,\
    \ -2, -2, -2, -2, -2, -2, -2, -2,\n-\t/* 50 */\t-2, -2, -2, -2, -2, -2, -2, -2,\
    \ -2, -2, -2, -2, -2, -2, -2, -2,\n-\t/* 60 */\t-2, -2, -2, -2, -2, -2, -2, -2,\
    \ -2, -2, -2, -2, -2, -2, -2, -2,\n-\t/* 70 */\t-2, -2, -2, -2, -2, -2, -2, -2,\
    \ -2, -2, -2, -2, -2, -2, -2, -2,\n-\t/* 80 */\t-2, -2, -2, -2, -2, -2, -2, -2,\
    \ -2, -2, -2, -2, -2, -2, -2, -2,\n-\t/* 90 */\t-2, -2, -2, -2, -2, -2, -2, -2,\
    \ -2, -2, -2, -2, -2, -2, -2, -2,\n-\t/* a0 */\t-2, -2, -2, -2, -2, -2, -2, -2,\
    \ -2, -2, -2, -2, -2, -2, -2, -2,\n-\t/* b0 */\t-2, -2, -2, -2, -2, -2, -2, -2,\
    \ -2, -2, -2, -2, -2, -2, -2, -2,\n-\t/* c0 */\t-2, -2, -2, -2, -2, -2, -2, -2,\
    \ -2, -2, -2, -2, -2, -2, -2, -2,\n-\t/* d0 */\t-2, -2, -2, -2, -2, -2, -2, -2,\
    \ -2, -2, -2, -2, -2, -2, -2, -2,\n-\t/* e0 */\t-2, -2, -2, -2, -2, -2, -2, -2,\
    \ -2, -2, -2, -2, -2, -2, -2, -2,\n-\t/* f0 */\t-2, -2, -2, -2, -2, -2, -2, -2,\
    \ -2, -2, -2, -2, -2, -2, -2, -2,\n+\t/* 00 */\t-4, -4, -4, -4, -4, -4, -4, -4,\
    \ -4, -4, -4, -4, -4, -4, -4, -4,\n+\t/* 10 */\t-4, -4, -4, -4, -4, -4, -4, -4,\
    \ -4, -4, -4, -4, -4, -4, -4, -4,\n+\t/* 20 */\t-4, -4, -4, -4, -4, -4, -4, -4,\
    \ -4, -4, -4, -4, -4, -4, -4, -4,\n+\t/* 30 */\t-4, -4, -4, -4, -4, -4, -4, -4,\
    \ -4, -4, -4, -4, -4, -4, -4, -4,\n+\t/* 40 */\t-4, -4, -4, -4, -4, -4, -4, -4,\
    \ -4, -4, -4, -4, -4, -4, -4, -4,\n+\t/* 50 */\t-4, -4, -4, -4, -4, -4, -4, -4,\
    \ -4, -4, -4, -4, -4, -4, -4, -4,\n+\t/* 60 */\t-4, -4, -4, -4, -4, -4, -4, -4,\
    \ -4, -4, -4, -4, -4, -4, -4, -4,\n+\t/* 70 */\t-4, -4, -4, -4, -4, -4, -4, -4,\
    \ -4, -4, -4, -4, -4, -4, -4, -4,\n+\t/* 80 */\t-4, -4, -4, -4, -4, -4, -4, -4,\
    \ -4, -4, -4, -4, -4, -4, -4, -4,\n+\t/* 90 */\t-4, -4, -4, -4, -4, -4, -4, -4,\
    \ -4, -4, -4, -4, -4, -4, -4, -4,\n+\t/* a0 */\t-4, -4, -4, -4, -4, -4, -4, -4,\
    \ -4, -4, -4, -4, -4, -4, -4, -4,\n+\t/* b0 */\t-4, -4, -4, -4, -4, -4, -4, -4,\
    \ -4, -4, -4, -4, -4, -4, -4, -4,\n+\t/* c0 */\t-4, -4, -4, -4, -4, -4, -4, -4,\
    \ -4, -4, -4, -4, -4, -4, -4, -4,\n+\t/* d0 */\t-4, -4, -4, -4, -4, -4, -4, -4,\
    \ -4, -4, -4, -4, -4, -4, -4, -4,\n+\t/* e0 */\t-4, -4, -4, -4, -4, -4, -4, -4,\
    \ -4, -4, -4, -4, -4, -4, -4, -4,\n+\t/* f0 */\t-4, -4, -4, -4, -4, -4, -4, -4,\
    \ -4, -4, -4, -4, -4, -4, -4, -4,\n };\n \n \n@@ -118,7 +118,7 @@ const TextEncoding::CharacterMap&\
    \ UTF32Encoding::characterMap() const\n int UTF32Encoding::convert(const unsigned\
    \ char* bytes) const\n {\n \tUInt32 uc;\n-\tunsigned char* p = (unsigned char*)\
    \ &uc;\n+\tunsigned char* p = reinterpret_cast<unsigned char*>(&uc);\n \t*p++\
    \ = *bytes++;\n \t*p++ = *bytes++;\n \t*p++ = *bytes++;\n@@ -129,7 +129,7 @@ int\
    \ UTF32Encoding::convert(const unsigned char* bytes) const\n \t\tuc = ByteOrder::flipBytes(uc);\n\
    \ \t}\n \n-\treturn uc;\n+\treturn safeToInt(uc);\n }\n \n \n@@ -138,7 +138,7\
    \ @@ int UTF32Encoding::convert(int ch, unsigned char* bytes, int length) const\n\
    \ \tif (bytes && length >= 4)\n \t{\n \t\tUInt32 ch1 = _flipBytes ? ByteOrder::flipBytes((UInt32)\
    \ ch) : (UInt32) ch;\n-\t\tunsigned char* p = (unsigned char*) &ch1;\n+\t\tunsigned\
    \ char* p = reinterpret_cast<unsigned char*>(&ch1);\n \t\t*bytes++ = *p++;\n \t\
    \t*bytes++ = *p++;\n \t\t*bytes++ = *p++;\n@@ -155,7 +155,7 @@ int UTF32Encoding::queryConvert(const\
    \ unsigned char* bytes, int length) const\n \tif (length >= 4)\n \t{\n \t\tUInt32\
    \ uc;\n-\t\tunsigned char* p = (unsigned char*) &uc;\n+\t\tunsigned char* p =\
    \ reinterpret_cast<unsigned char*>(&uc);\n \t\t*p++ = *bytes++;\n \t\t*p++ = *bytes++;\n\
    \ \t\t*p++ = *bytes++;\n@@ -164,7 +164,7 @@ int UTF32Encoding::queryConvert(const\
    \ unsigned char* bytes, int length) const\n \t\t{\n \t\t\tuc = ByteOrder::flipBytes(uc);\n\
    \ \t\t}\n-\t\treturn uc;\n+\t\tret = safeToInt(uc);\n \t}\n \n \treturn ret;"
  identifiers: CVE:["CVE-2023-52389"],CWE:["CWE-680"]
  overview: Affected versions of this package are vulnerable to Integer Overflow to
    Buffer Overflow in the `UTF32Encoding::convert` and `UTF32Encoding::queryConvert`
    methods.
  references:
    GitHub Commit: https://github.com/pocoproject/poco/commit/6caa224e22adf71b0e54febd833f44cc7efee470
    GitHub Diff: https://github.com/pocoproject/poco/compare/poco-1.12.5p2-release...poco-1.13.0-release
    GitHub Issue: https://github.com/pocoproject/poco/issues/4320
    Release Notes: https://pocoproject.org/blog/?p=1226
  title: Integer Overflow to Buffer Overflow
- diff_content:
  - "--- a/src/isomedia/isom_write.c\n+++ b/src/isomedia/isom_write.c\n@@ -4574,7\
    \ +4574,8 @@ GF_Err gf_isom_new_generic_sample_description(GF_ISOFile *movie,\
    \ u32 trackNumber\n \t\tentry->spatial_quality = udesc->spatial_quality;\n \t\t\
    entry->Width = udesc->width;\n \t\tentry->Height = udesc->height;\n-\t\tstrcpy(entry->compressor_name,\
    \ udesc->compressor_name);\n+\t\tstrncpy(entry->compressor_name, udesc->compressor_name,\
    \ GF_ARRAY_LENGTH(entry->compressor_name));\n+\t\tentry->compressor_name[ GF_ARRAY_LENGTH(entry->compressor_name)\
    \ - 1] = 0;\n \t\tentry->color_table_index = -1;\n \t\tentry->frames_per_sample\
    \ = 1;\n \t\tentry->horiz_res = udesc->h_res ? udesc->h_res : 0x00480000;"
  identifiers: CVE:["CVE-2024-22749"],CWE:["CWE-120"]
  overview: Affected versions of this package are vulnerable to Buffer Overflow via
    the `gf_isom_new_generic_sample_description` function in `isomedia/isom_write.c:4577`.
    An attacker can execute arbitrary code or cause a denial of service by providing
    crafted input that triggers a buffer overflow.
  references:
    GitHub Commit: https://github.com/gpac/gpac/commit/7aef8038c6bdd310e65000704e39afaa0e721048
    GitHub Issue: https://github.com/gpac/gpac/issues/2713
    Vulnerability Advisory: https://github.com/hanxuer/crashes/blob/main/gapc/01/readme.md
  title: Buffer Overflow
- diff_content:
  - "--- a/backend/epub/epub-document.c\n+++ b/backend/epub/epub-document.c\n@@ -671,7\
    \ +671,7 @@ check_mime_type(const gchar* uri,GError** error)\n }\n \n static gboolean\n\
    -extract_one_file(EpubDocument* epub_document,GError ** error)\n+extract_one_file(EpubDocument*\
    \ epub_document, GFile *tmp_gfile, GError ** error)\n {\n     GFile * outfile\
    \ ;\n     gsize writesize = 0;\n@@ -698,6 +698,20 @@ extract_one_file(EpubDocument*\
    \ epub_document,GError ** error)\n     gfilepath = g_string_new(epub_document->tmp_archive_dir)\
    \ ;\n     g_string_append_printf(gfilepath,\"/%s\",(gchar*)currentfilename);\n\
    \ \n+    outfile = g_file_new_for_path (gfilepath->str);\n+    g_autofree gchar\
    \ *rpath = g_file_get_relative_path (tmp_gfile, outfile);\n+\n+    if (rpath ==\
    \ NULL)\n+    {\n+        g_set_error_literal (error,\n+                     \
    \        EV_DOCUMENT_ERROR,\n+                             EV_DOCUMENT_ERROR_INVALID,\n\
    +                             _(\"epub file is invalid or corrupt\"));\n+    \
    \    g_critical (\"Invalid filename in Epub container - '%s'\", (gchar *) currentfilename);\n\
    +        result = FALSE;\n+        goto out;\n+    }\n+\n     /*if we encounter\
    \ a directory, make a directory inside our temporary folder.*/\n     if (directory\
    \ != NULL && *directory == '\\0')\n     {\n@@ -725,7 +739,6 @@ extract_one_file(EpubDocument*\
    \ epub_document,GError ** error)\n         g_string_free(dir_create,TRUE);\n \
    \    }\n \n-    outfile = g_file_new_for_path(gfilepath->str);\n     outstream\
    \ = g_file_create(outfile,G_FILE_CREATE_PRIVATE,NULL,error);\n     gpointer buffer\
    \ = g_malloc0(512);\n     while ( (writesize = unzReadCurrentFile(epub_document->epubDocument,buffer,512)\
    \ ) != 0 )\n@@ -738,10 +751,10 @@ extract_one_file(EpubDocument* epub_document,GError\
    \ ** error)\n     }\n     g_free(buffer);\n     g_output_stream_close((GOutputStream*)outstream,NULL,error);\n\
    -    g_object_unref(outfile) ;\n-    g_object_unref(outstream) ;\n+    g_object_unref(outstream);\n\
    \ \n out:\n+    g_object_unref(outfile);\n     unzCloseCurrentFile (epub_document->epubDocument)\
    \ ;\n     g_string_free(gfilepath,TRUE);\n     g_free(currentfilename);\n@@ -753,6\
    \ +766,7 @@ extract_epub_from_container (const gchar* uri,\n                 \
    \             EpubDocument *epub_document,\n                              GError\
    \ ** error)\n {\n+    GFile *tmp_gfile = NULL;\n     GError *err = NULL;\n   \
    \  epub_document->archivename = g_filename_from_uri(uri,NULL,error);\n \n@@ -814,9\
    \ +828,10 @@ extract_epub_from_container (const gchar* uri,\n         goto out;\n\
    \     }\n \n+    tmp_gfile = g_file_new_for_path (epub_document->tmp_archive_dir);\n\
    \     while ( TRUE )\n     {\n-        if ( extract_one_file(epub_document,&err)\
    \ == FALSE )\n+        if ( extract_one_file(epub_document, tmp_gfile, &err) ==\
    \ FALSE )\n         {\n             if (err) {\n                 g_propagate_error\
    \ (error, err);\n@@ -837,6 +852,7 @@ extract_epub_from_container (const gchar*\
    \ uri,\n     }\n \n out:\n+    g_clear_object (&tmp_gfile);\n     unzClose(epub_document->epubDocument);\n\
    \     return result;\n }"
  identifiers: CVE:["CVE-2023-52076"],CWE:["CWE-24"]
  overview: Affected versions of this package are vulnerable to Path Traversal via
    the processing of a crafted document. An attacker can write arbitrary files to
    any location on the filesystem that the user has access to. This is only exploitable
    when opening a malicious document, and it cannot be used to overwrite existing
    files. However, it can lead to Remote Command Execution on the affected system.
  references:
    GitHub Commit: https://github.com/mate-desktop/atril/commit/e70b21c815418a1e6ebedf6d8d31b8477c03ba50
    GitHub Release: https://github.com/mate-desktop/atril/releases/tag/v1.26.2
  title: Path Traversal
- diff_content:
  - "--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_cs.c\n+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_cs.c\n\
    @@ -1654,15 +1654,15 @@ static int amdgpu_cs_wait_all_fences(struct amdgpu_device\
    \ *adev,\n \t\t\tcontinue;\n \n \t\tr = dma_fence_wait_timeout(fence, true, timeout);\n\
    +\t\tif (r > 0 && fence->error)\n+\t\t\tr = fence->error;\n+\n \t\tdma_fence_put(fence);\n\
    \ \t\tif (r < 0)\n \t\t\treturn r;\n \n \t\tif (r == 0)\n \t\t\tbreak;\n-\n-\t\
    \tif (fence->error)\n-\t\t\treturn fence->error;\n \t}\n \n \tmemset(wait, 0,\
    \ sizeof(*wait));"
  identifiers: CVE:["CVE-2023-51042"],CWE:["CWE-416"]
  overview: Affected versions of this package are vulnerable to Use After Free via
    the `amdgpu_cs_wait_all_fences` function in the GPU driver. An attacker with local
    access can cause a denial of service or potentially execute arbitrary code by
    manipulating the timing of memory deallocation and reuse.
  references:
    GitHub Commit: https://github.com/torvalds/linux/commit/2e54154b9f27262efd0cb4f903cc7d5ad1fe9628
    RedHat Bugzilla Bug: https://bugzilla.redhat.com/show_bug.cgi?id=2259866
  title: Use After Free
- diff_content:
  - "--- a/b/fs/smb/server/smb2misc.c\n+++ b/b/fs/smb/server/smb2misc.c\n@@ -190,6\
    \ +190,10 @@ static int gvconfig_plugin_install_from_config(GVC_t * gvc, char\
    \ *s)\n \tdo {\n \t    const char *api = token(&nest, &s);\n \t    const api_t\
    \ gv_api = gvplugin_api(api);\n+\t    if (gv_api == (api_t)-1) {\n+\t\tagerr(AGERR,\
    \ \"config error: %s %s not found\\n\", package_path, api);\n+\t\treturn 0;\n\
    +\t    }\n \t    do {\n \t\tif (nest == 2) {\n \t\t    type = token(&nest, &s);\n\
    @@ -106,16 +106,25 @@ static int smb2_get_data_area_len(unsigned int *off, unsigned\
    \ int *len,\n \t\tbreak;\n \tcase SMB2_CREATE:\n \t{\n+\t\tunsigned short int\
    \ name_off =\n+\t\t\tle16_to_cpu(((struct smb2_create_req *)hdr)->NameOffset);\n\
    +\t\tunsigned short int name_len =\n+\t\t\tle16_to_cpu(((struct smb2_create_req\
    \ *)hdr)->NameLength);\n+\n \t\tif (((struct smb2_create_req *)hdr)->CreateContextsLength)\
    \ {\n \t\t\t*off = le32_to_cpu(((struct smb2_create_req *)\n \t\t\t\thdr)->CreateContextsOffset);\n\
    \ \t\t\t*len = le32_to_cpu(((struct smb2_create_req *)\n \t\t\t\thdr)->CreateContextsLength);\n\
    -\t\t\tbreak;\n+\t\t\tif (!name_len)\n+\t\t\t\tbreak;\n+\n+\t\t\tif (name_off\
    \ + name_len < (u64)*off + *len)\n+\t\t\t\tbreak;\n \t\t}\n \n-\t\t*off = le16_to_cpu(((struct\
    \ smb2_create_req *)hdr)->NameOffset);\n-\t\t*len = le16_to_cpu(((struct smb2_create_req\
    \ *)hdr)->NameLength);\n+\t\t*off = name_off;\n+\t\t*len = name_len;\n \t\tbreak;\n\
    \ \t}\n \tcase SMB2_QUERY_INFO:\n"
  identifiers: CVE:["CVE-2024-22705"],CWE:["CWE-125"]
  overview: Affected versions of this package are vulnerable to Out-of-bounds Read
    via the `smb2_get_data_area_len` function in the Linux kernel's SMB server implementation.
    An attacker can achieve out-of-bounds access and potentially read or modify memory
    that is outside of the intended buffer by sending a specially crafted SMB request
    that mishandles the relationship between Name data and CreateContexts data.
  references:
    Git Commit: https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=d10c77873ba1e9e6b91905018e29e196fd5f863d
  title: Out-of-bounds Read
- diff_content:
  - "--- a/httpboot.c\n+++ b/httpboot.c\n@@ -578,7 +578,13 @@ receive_http_response(EFI_HTTP_PROTOCOL\
    \ *http, VOID **buffer, UINT64 *buf_size)\n \t}\n \n \tif (*buf_size == 0) {\n\
    -\t\tperror(L\"Failed to get Content-Lenght\\n\");\n+\t\tperror(L\"Failed to get\
    \ Content-Length\\n\");\n+\t\tgoto error;\n+\t}\n+\n+\tif (*buf_size < rx_message.BodyLength)\
    \ {\n+\t\tefi_status = EFI_BAD_BUFFER_SIZE;\n+\t\tperror(L\"Invalid Content-Length\\\
    n\");\n \t\tgoto error;\n \t}\n "
  identifiers: CVE:["CVE-2023-40547"],CWE:["CWE-94"]
  overview: Affected versions of this package are vulnerable to Improper Control of
    Generation of Code ('Code Injection') due to improper validation of attacker-controlled
    values when parsing an HTTP response. An attacker can execute arbitrary code on
    the system by crafting a specific malicious HTTP request, leading to an out-of-bounds
    write and potentially a complete system compromise.
  references:
    Github Commit: https://github.com/rhboot/shim/commit/0226b56513b2b8bd5fd281bce77c40c9bf07c66d
    RedHat Bugzilla Bug: https://bugzilla.redhat.com/show_bug.cgi?id=2234589
  title: Improper Control of Generation of Code ('Code Injection')
- diff_content:
  - "--- a/drivers/gpu/drm/drm_atomic.c\n+++ b/drivers/gpu/drm/drm_atomic.c\n@@ -140,6\
    \ +140,12 @@ drm_atomic_state_init(struct drm_device *dev, struct drm_atomic_state\
    \ *state)\n \tif (!state->planes)\n \t\tgoto fail;\n \n+\t/*\n+\t * Because drm_atomic_state\
    \ can be committed asynchronously we need our\n+\t * own reference and cannot\
    \ rely on the on implied by drm_file in the\n+\t * ioctl call.\n+\t */\n+\tdrm_dev_get(dev);\n\
    \ \tstate->dev = dev;\n \n \tdrm_dbg_atomic(dev, \"Allocated atomic state %p\\\
    n\", state);\n@@ -299,7 +305,8 @@ EXPORT_SYMBOL(drm_atomic_state_clear);\n void\
    \ __drm_atomic_state_free(struct kref *ref)\n {\n \tstruct drm_atomic_state *state\
    \ = container_of(ref, typeof(*state), ref);\n-\tstruct drm_mode_config *config\
    \ = &state->dev->mode_config;\n+\tstruct drm_device *dev = state->dev;\n+\tstruct\
    \ drm_mode_config *config = &dev->mode_config;\n \n \tdrm_atomic_state_clear(state);\n\
    \ \n@@ -311,6 +318,8 @@ void __drm_atomic_state_free(struct kref *ref)\n \t\t\
    drm_atomic_state_default_release(state);\n \t\tkfree(state);\n \t}\n+\n+\tdrm_dev_put(dev);\n\
    \ }\n EXPORT_SYMBOL(__drm_atomic_state_free);\n "
  identifiers: CVE:["CVE-2023-51043"],CWE:["CWE-416"]
  overview: Affected versions of this package are vulnerable to Use After Free due
    to a race condition between a nonblocking atomic commit and a driver unload in
    the `drm_atomic` component. An attacker can achieve privilege escalation or cause
    a system crash by exploiting the timing window where memory has been freed and
    is subsequently accessed.
  references:
    GitHub Commit: https://github.com/torvalds/linux/commit/4e076c73e4f6e90816b30fcd4a0d7ab365087255
  title: Use After Free
- diff_content:
  - "--- a/b/net/nfc/nci/spi.c\n+++ b/b/net/nfc/nci/spi.c\n@@ -190,6 +190,10 @@ static\
    \ int gvconfig_plugin_install_from_config(GVC_t * gvc, char *s)\n \tdo {\n \t\
    \    const char *api = token(&nest, &s);\n \t    const api_t gv_api = gvplugin_api(api);\n\
    +\t    if (gv_api == (api_t)-1) {\n+\t\tagerr(AGERR, \"config error: %s %s not\
    \ found\\n\", package_path, api);\n+\t\treturn 0;\n+\t    }\n \t    do {\n \t\t\
    if (nest == 2) {\n \t\t    type = token(&nest, &s);\n@@ -106,16 +106,25 @@ static\
    \ int smb2_get_data_area_len(unsigned int *off, unsigned int *len,\n \t\tbreak;\n\
    \ \tcase SMB2_CREATE:\n \t{\n+\t\tunsigned short int name_off =\n+\t\t\tle16_to_cpu(((struct\
    \ smb2_create_req *)hdr)->NameOffset);\n+\t\tunsigned short int name_len =\n+\t\
    \t\tle16_to_cpu(((struct smb2_create_req *)hdr)->NameLength);\n+\n \t\tif (((struct\
    \ smb2_create_req *)hdr)->CreateContextsLength) {\n \t\t\t*off = le32_to_cpu(((struct\
    \ smb2_create_req *)\n \t\t\t\thdr)->CreateContextsOffset);\n \t\t\t*len = le32_to_cpu(((struct\
    \ smb2_create_req *)\n \t\t\t\thdr)->CreateContextsLength);\n-\t\t\tbreak;\n+\t\
    \t\tif (!name_len)\n+\t\t\t\tbreak;\n+\n+\t\t\tif (name_off + name_len < (u64)*off\
    \ + *len)\n+\t\t\t\tbreak;\n \t\t}\n \n-\t\t*off = le16_to_cpu(((struct smb2_create_req\
    \ *)hdr)->NameOffset);\n-\t\t*len = le16_to_cpu(((struct smb2_create_req *)hdr)->NameLength);\n\
    +\t\t*off = name_off;\n+\t\t*len = name_len;\n \t\tbreak;\n \t}\n \tcase SMB2_QUERY_INFO:\n\
    @@ -151,6 +151,8 @@ static int send_acknowledge(struct nci_spi *nspi, u8 acknowledge)\n\
    \ \tint ret;\n \n \tskb = nci_skb_alloc(nspi->ndev, 0, GFP_KERNEL);\n+\tif (!skb)\n\
    +\t\treturn -ENOMEM;\n \n \t/* add the NCI SPI header to the start of the buffer\
    \ */\n \thdr = skb_push(skb, NCI_SPI_HDR_LEN);\n"
  - "--- a/net/nfc/nci/spi.c\n+++ b/net/nfc/nci/spi.c\n@@ -151,6 +151,8 @@ static\
    \ int send_acknowledge(struct nci_spi *nspi, u8 acknowledge)\n \tint ret;\n \n\
    \ \tskb = nci_skb_alloc(nspi->ndev, 0, GFP_KERNEL);\n+\tif (!skb)\n+\t\treturn\
    \ -ENOMEM;\n \n \t/* add the NCI SPI header to the start of the buffer */\n \t\
    hdr = skb_push(skb, NCI_SPI_HDR_LEN);"
  identifiers: CVE:["CVE-2023-46343"],CWE:["CWE-476"]
  overview: Affected versions of this package are vulnerable to NULL Pointer Dereference
    due to improper handling of certain input in the `send_acknowledge` function.
    An attacker can cause a system crash by triggering a NULL pointer dereference.
  references:
    Git Commit: https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=7937609cd387246aed994e81aa4fa951358fba41
    GitHub Commit: https://github.com/torvalds/linux/commit/7937609cd387246aed994e81aa4fa951358fba41
  title: NULL Pointer Dereference
- diff_content:
  - "--- a/modules/pam_namespace/pam_namespace.c\n+++ b/modules/pam_namespace/pam_namespace.c\n\
    @@ -1201,7 +1201,7 @@ static int protect_dir(const char *path, mode_t mode, int\
    \ do_mkdir,\n \tint dfd = AT_FDCWD;\n \tint dfd_next;\n \tint save_errno;\n-\t\
    int flags = O_RDONLY;\n+\tint flags = O_RDONLY | O_DIRECTORY;\n \tint rv = -1;\n\
    \ \tstruct stat st;\n \n@@ -1255,22 +1255,6 @@ static int protect_dir(const char\
    \ *path, mode_t mode, int do_mkdir,\n \t\trv = openat(dfd, dir, flags);\n \t}\n\
    \ \n-\tif (rv != -1) {\n-\t\tif (fstat(rv, &st) != 0) {\n-\t\t\tsave_errno = errno;\n\
    -\t\t\tclose(rv);\n-\t\t\trv = -1;\n-\t\t\terrno = save_errno;\n-\t\t\tgoto error;\n\
    -\t\t}\n-\t\tif (!S_ISDIR(st.st_mode)) {\n-\t\t\tclose(rv);\n-\t\t\terrno = ENOTDIR;\n\
    -\t\t\trv = -1;\n-\t\t\tgoto error;\n-\t\t}\n-\t}\n-\n \tif (flags & O_NOFOLLOW)\
    \ {\n \t\t/* we are inside user-owned dir - protect */\n \t\tif (protect_mount(rv,\
    \ p, idata) == -1) {"
  identifiers: CVE:["CVE-2024-22365"],CWE:["CWE-277"]
  overview: Affected versions of this package are vulnerable to Improper Authorization
    via the `openat()` system call in the `protect_dir()` function. An attacker can
    block a user's login attempt by placing a FIFO in a directory that is expected
    to be a polyinstantiated directory when `pam_namespace` is configured. This is
    only exploitable if the system is configured with a non-default mount namespace
    setup and the `/tmp` directory is mounted as a polyinstantiated directory.
  references:
    GitHub Commit: https://github.com/linux-pam/linux-pam/commit/031bb5a5d0d950253b68138b498dc93be69a64cb
    GitHub Release: https://github.com/linux-pam/linux-pam/releases/tag/v1.6.0
    OSS Security Advisory: https://www.openwall.com/lists/oss-security/2024/01/18/3
    RedHat Bugzilla Bug: https://bugzilla.redhat.com/show_bug.cgi?id=2257722
  title: Improper Authorization
- diff_content:
  - "--- a/cipher/dsa-common.c\n+++ b/cipher/dsa-common.c\n@@ -29,6 +29,30 @@\n #include\
    \ \"pubkey-internal.h\"\n \n \n+/*\n+ * Modify K, so that computation time difference\
    \ can be small,\n+ * by making K large enough.\n+ *\n+ * Originally, (EC)DSA computation\
    \ requires k where 0 < k < q.  Here,\n+ * we add q (the order), to keep k in a\
    \ range: q < k < 2*q (or,\n+ * addming more q, to keep k in a range: 2*q < k <\
    \ 3*q), so that\n+ * timing difference of the EC multiply (or exponentiation)\
    \ operation\n+ * can be small.  The result of (EC)DSA computation is same.\n+\
    \ */\n+void\n+_gcry_dsa_modify_k (gcry_mpi_t k, gcry_mpi_t q, int qbits)\n+{\n\
    +  gcry_mpi_t k1 = mpi_new (qbits+2);\n+\n+  mpi_resize (k, (qbits+2+BITS_PER_MPI_LIMB-1)\
    \ / BITS_PER_MPI_LIMB);\n+  k->nlimbs = k->alloced;\n+  mpi_add (k, k, q);\n+\
    \  mpi_add (k1, k, q);\n+  mpi_set_cond (k, k1, !mpi_test_bit (k, qbits));\n+\n\
    +  mpi_free (k1);\n+}\n+\n /*\n  * Generate a random secret exponent K less than\
    \ Q.\n  * Note that ECDSA uses this code also to generate D."
  - "--- a/cipher/dsa.c\n+++ b/cipher/dsa.c\n@@ -635,6 +635,8 @@ sign (gcry_mpi_t\
    \ r, gcry_mpi_t s, gcry_mpi_t input, DSA_secret_key *skey,\n       k = _gcry_dsa_gen_k\
    \ (skey->q, GCRY_STRONG_RANDOM);\n     }\n \n+  _gcry_dsa_modify_k (k, skey->q,\
    \ qbits);\n+\n   /* r = (a^k mod p) mod q */\n   mpi_powm( r, skey->g, k, skey->p\
    \ );\n   mpi_fdiv_r( r, r, skey->q );"
  - "--- a/cipher/ecc-ecdsa.c\n+++ b/cipher/ecc-ecdsa.c\n@@ -114,15 +114,7 @@ _gcry_ecc_ecdsa_sign\
    \ (gcry_mpi_t input, ECC_secret_key *skey,\n           else\n             k =\
    \ _gcry_dsa_gen_k (skey->E.n, GCRY_STRONG_RANDOM);\n \n-          /* Originally,\
    \ ECDSA computation requires k where 0 < k < n.\n-           * Here, we add n\
    \ (the order of curve), to keep k in a\n-           * range: n < k < 2*n, or,\
    \ addming more n, keep k in a range:\n-           * 2*n < k < 3*n, so that timing\
    \ difference of the EC\n-           * multiply operation can be small.  The result\
    \ is same.\n-           */\n-          mpi_add (k, k, skey->E.n);\n-         \
    \ if (!mpi_test_bit (k, qbits))\n-            mpi_add (k, k, skey->E.n);\n+  \
    \        _gcry_dsa_modify_k (k, skey->E.n, qbits);\n \n           _gcry_mpi_ec_mul_point\
    \ (&I, k, &skey->E.G, ctx);\n           if (_gcry_mpi_ec_get_affine (x, NULL,\
    \ &I, ctx))"
  - "--- a/cipher/ecc-gost.c\n+++ b/cipher/ecc-gost.c\n@@ -94,6 +94,8 @@ _gcry_ecc_gost_sign\
    \ (gcry_mpi_t input, ECC_secret_key *skey,\n           mpi_free (k);\n       \
    \    k = _gcry_dsa_gen_k (skey->E.n, GCRY_STRONG_RANDOM);\n \n+          _gcry_dsa_modify_k\
    \ (k, skey->E.n, qbits);\n+\n           _gcry_mpi_ec_mul_point (&I, k, &skey->E.G,\
    \ ctx);\n           if (_gcry_mpi_ec_get_affine (x, NULL, &I, ctx))\n        \
    \     {"
  identifiers: CVE:["CVE-2019-13627"],CWE:["CWE-200"]
  overview: Affected versions of this package are vulnerable to Information Exposure
    via the `dsa-common.c` file. The `EdDSA` scalar multiplication could lead to an
    information leakage.
  references:
    GitHub Commit: https://github.com/gpg/libgcrypt/commit/db4e9976cc31b314aafad6626b2894e86ee44d60
  title: Information Exposure
- diff_content:
  - "--- a/library/ssl_tls13_server.c\n+++ b/library/ssl_tls13_server.c\n@@ -1925,13\
    \ +1925,23 @@ static int ssl_tls13_process_client_hello(mbedtls_ssl_context *ssl)\n\
    \                                    * by MBEDTLS_SSL_PROC_CHK_NEG. */\n \n  \
    \   /*\n-     * Version 1.2 of the protocol has been chosen, set the\n+     *\
    \ Version 1.2 of the protocol has to be used for the handshake.\n+     * If TLS\
    \ 1.2 is not supported, abort the handshake. Otherwise, set the\n      * ssl->keep_current_message\
    \ flag for the ClientHello to be kept and parsed\n      * as a TLS 1.2 ClientHello.\
    \ We also change ssl->tls_version to\n      * MBEDTLS_SSL_VERSION_TLS1_2 thus\
    \ from now on mbedtls_ssl_handshake_step()\n      * will dispatch to the TLS 1.2\
    \ state machine.\n      */\n     if (SSL_CLIENT_HELLO_TLS1_2 == parse_client_hello_ret)\
    \ {\n+        /* Check if server supports TLS 1.2 */\n+        if (!mbedtls_ssl_conf_is_tls12_enabled(ssl->conf))\
    \ {\n+            MBEDTLS_SSL_DEBUG_MSG(\n+                1, (\"TLS 1.2 not supported.\"\
    ));\n+            MBEDTLS_SSL_PEND_FATAL_ALERT(\n+                MBEDTLS_SSL_ALERT_MSG_PROTOCOL_VERSION,\n\
    +                MBEDTLS_ERR_SSL_BAD_PROTOCOL_VERSION);\n+            return MBEDTLS_ERR_SSL_BAD_PROTOCOL_VERSION;\n\
    +        }\n         ssl->keep_current_message = 1;\n         ssl->tls_version\
    \ = MBEDTLS_SSL_VERSION_TLS1_2;\n         return 0;"
  identifiers: CVE:["CVE-2024-23744"],CWE:["CWE-400"]
  overview: Affected versions of this package are vulnerable to Uncontrolled Resource
    Consumption ('Resource Exhaustion') due to improper handling of TLS 1.3 ClientHello
    messages. An attacker can cause a denial of service by sending a crafted ClientHello
    message without the necessary extensions.
  references:
    GitHub Commit: https://github.com/Mbed-TLS/mbedtls/commit/7c14afcaaaa2a4045e1b3cca840711ffa603c561
    GitHub Issue: https://github.com/Mbed-TLS/mbedtls/issues/8694
  title: Uncontrolled Resource Consumption ('Resource Exhaustion')
- diff_content:
  - "--- a/darkhttpd.c\n+++ b/darkhttpd.c\n@@ -941,7 +941,9 @@ static void usage(const\
    \ char *argv0) {\n     \"\\t\\tit will be closed. Set to zero to disable timeouts.\\\
    n\\n\",\n     timeout_secs);\n     printf(\"\\t--auth username:password\\n\"\n\
    -    \"\\t\\tEnable basic authentication.\\n\\n\");\n+    \"\\t\\tEnable basic\
    \ authentication. This is *INSECURE*: passwords\\n\"\n+    \"\\t\\tare sent unencrypted\
    \ over HTTP, plus the password is visible\\n\"\n+    \"\\t\\tin ps(1) to other\
    \ users on the system.\\n\\n\");\n     printf(\"\\t--forward-https\\n\"\n    \
    \ \"\\t\\tIf the client requested HTTP, forward to HTTPS.\\n\"\n     \"\\t\\tThis\
    \ is useful if darkhttpd is behind a reverse proxy\\n\""
  identifiers: CVE:["CVE-2024-23770"],CWE:["CWE-200"]
  overview: Affected versions of this package are vulnerable to Exposure of Sensitive
    Information to an Unauthorized Actor due to improper handling of command-line
    arguments. An attacker with local access can obtain sensitive information by inspecting
    the command-line arguments of the running process.
  references:
    GitHub Commit: https://github.com/emikulic/darkhttpd/commit/2b339828b2a42a5fda105ea84934957a7d23e35d
    GitHub Diff: https://github.com/emikulic/darkhttpd/compare/v1.14...v1.15
  title: Exposure of Sensitive Information to an Unauthorized Actor
- diff_content:
  - "--- a/darkhttpd.c\n+++ b/darkhttpd.c\n@@ -304,7 +304,7 @@ static char *pidfile_name\
    \ = NULL;   /* NULL = no pidfile */\n static int want_chroot = 0, want_daemon\
    \ = 0, want_accf = 0,\n            want_keepalive = 1, want_server_id = 1;\n static\
    \ char *server_hdr = NULL;\n-static char *auth_key = NULL;\n+static char *auth_key\
    \ = NULL;       /* NULL or \"Basic base64_of_password\" */\n static char *custom_hdrs\
    \ = NULL;\n static uint64_t num_requests = 0, total_in = 0, total_out = 0;\n static\
    \ int accepting = 1;           /* set to 0 to stop accept()ing */\n@@ -2291,6\
    \ +2291,33 @@ static void process_get(struct connection *conn) {\n     }\n }\n\
    \ \n+/* Returns 1 if passwords are equal, runtime is proportional to the length\
    \ of\n+ * user_input to avoid leaking the secret's length and contents through\
    \ timing\n+ * information.\n+ */\n+int password_equal(const char *user_input,\
    \ const char *secret) {\n+    size_t i = 0;\n+    size_t j = 0;\n+    char out\
    \ = 0;\n+\n+    while (1) {\n+        /* Out stays zero if the strings are the\
    \ same. */\n+        out |= user_input[i] ^ secret[j];\n+\n+        /* Stop at\
    \ end of user_input. */\n+        if (user_input[i] == 0) break;\n+        i++;\n\
    +\n+        /* Don't go past end of secret. */\n+        if (secret[j] != 0) j++;\n\
    +    }\n+\n+    /* Check length after loop, otherwise early exit would leak length.\
    \ */\n+    out |= (i != j); /* Secret was shorter. */\n+    out |= (secret[j]\
    \ != 0); /* Secret was longer; j is not the end. */\n+    return out == 0;\n+}\n\
    +\n /* Process a request: build the header and reply, advance state. */\n static\
    \ void process_request(struct connection *conn) {\n     num_requests++;\n@@ -2305,8\
    \ +2332,7 @@ static void process_request(struct connection *conn) {\n     /* fail\
    \ if: (auth_enabled) AND (client supplied invalid credentials) */\n     else if\
    \ (auth_key != NULL &&\n             (conn->authorization == NULL ||\n-      \
    \       strcmp(conn->authorization, auth_key)))\n-    {\n+             !password_equal(conn->authorization,\
    \ auth_key))) {\n         default_reply(conn, 401, \"Unauthorized\",\n       \
    \      \"Access denied due to invalid credentials.\");\n     }"
  - '--- a/devel/test_password_equal.c

    +++ b/devel/test_password_equal.c

    @@ -0,0 +1,30 @@

    +#define main _main_disabled_

    +#include "../darkhttpd.c"

    +#undef main

    +

    +static void

    +test(int equal, const char *user_input, const char *secret)

    +{

    +    int out = password_equal(user_input, secret);

    +    printf("%s: \"%s\" \"%s\"\n",

    +        (equal == out) ? "PASS" : "FAIL",

    +        user_input, secret);

    +}

    +

    +int

    +main(void)

    +{

    +    test(1, "", "");

    +    test(1, "a", "a");

    +    test(1, "abc", "abc");

    +

    +    test(0, "a", "");

    +    test(0, "ab", "");

    +    test(0, "", "a");

    +    test(0, "", "ab");

    +    test(0, "abcd", "abc");

    +    test(0, "abc", "abcd");

    +    return 0;

    +}

    +

    +/* vim:set tabstop=4 shiftwidth=4 expandtab tw=78: */'
  identifiers: CVE:["CVE-2024-23771"],CWE:["CWE-208"]
  overview: Affected versions of this package are vulnerable to Observable Timing
    Discrepancy due to the use of a non-constant time string comparison function `strcmp`
    for authentication verification. An attacker can potentially bypass authentication
    controls by observing the time it takes for the server to respond to authentication
    attempts.
  references:
    GitHub Commit: https://github.com/emikulic/darkhttpd/commit/f477619d49f3c4de9ad59bd194265a48ddc03f04
    GitHub Diff: https://github.com/emikulic/darkhttpd/compare/v1.14...v1.15
  title: Observable Timing Discrepancy
- diff_content:
  - "--- a/libfreerdp/codec/planar.c\n+++ b/libfreerdp/codec/planar.c\n@@ -1496,7\
    \ +1496,13 @@ BOOL freerdp_bitmap_planar_context_reset(BITMAP_PLANAR_CONTEXT*\
    \ context, UINT32\n \tcontext->bgr = FALSE;\n \tcontext->maxWidth = PLANAR_ALIGN(width,\
    \ 4);\n \tcontext->maxHeight = PLANAR_ALIGN(height, 4);\n-\tcontext->maxPlaneSize\
    \ = context->maxWidth * context->maxHeight;\n+\tconst UINT64 tmp = (UINT64)context->maxWidth\
    \ * context->maxHeight;\n+\tif (tmp > UINT32_MAX)\n+\t\treturn FALSE;\n+\tcontext->maxPlaneSize\
    \ = tmp;\n+\n+\tif (context->maxWidth > UINT32_MAX / 4)\n+\t\treturn FALSE;\n\
    \ \tcontext->nTempStep = context->maxWidth * 4;\n \tfree(context->planesBuffer);\n\
    \ \tfree(context->pTempData);"
  identifiers: CVE:["CVE-2024-22211"],CWE:["CWE-190"]
  overview: Affected versions of this package are vulnerable to Integer Overflow or
    Wraparound due to an integer overflow in the `freerdp_bitmap_planar_context_reset()`
    function. An attacker can cause a heap-buffer overflow by sending a crafted `RDPGFX_RESET_GRAPHICS_PDU`
    to the client. Data extraction over the network is not possible as the affected
    buffers are only used to display an image.
  references:
    GitHub Commit: https://github.com/FreeRDP/FreeRDP/commit/aeac3040cc99eeaff1e1171a822114c857b9dca9
  title: Integer Overflow or Wraparound
- diff_content:
  - "--- a/src/json.c\n+++ b/src/json.c\n@@ -2902,6 +2902,7 @@ static void jsonReplaceFunc(\n\
    \   }\n   pParse = jsonParseCached(ctx, argv[0], ctx, argc>1);\n   if( pParse==0\
    \ ) return;\n+  pParse->nJPRef++;\n   for(i=1; i<(u32)argc; i+=2){\n     zPath\
    \ = (const char*)sqlite3_value_text(argv[i]);\n     pParse->useMod = 1;\n@@ -2914,6\
    \ +2915,7 @@ static void jsonReplaceFunc(\n   jsonReturnJson(pParse, pParse->aNode,\
    \ ctx, 1);\n replace_err:\n   jsonDebugPrintParse(pParse);\n+  jsonParseFree(pParse);\n\
    \ }\n \n \n@@ -2948,6 +2950,7 @@ static void jsonSetFunc(\n   }\n   pParse = jsonParseCached(ctx,\
    \ argv[0], ctx, argc>1);\n   if( pParse==0 ) return;\n+  pParse->nJPRef++;\n \
    \  for(i=1; i<(u32)argc; i+=2){\n     zPath = (const char*)sqlite3_value_text(argv[i]);\n\
    \     bApnd = 0;\n@@ -2964,9 +2967,8 @@ static void jsonSetFunc(\n   }\n   jsonDebugPrintParse(pParse);\n\
    \   jsonReturnJson(pParse, pParse->aNode, ctx, 1);\n-\n jsonSetDone:\n-  /* no\
    \ cleanup required */;\n+  jsonParseFree(pParse);\n }\n \n /*"
  identifiers: CVE:["CVE-2024-0232"],CWE:["CWE-416"]
  overview: Affected versions of this package are vulnerable to Use After Free via
    the `jsonParseAddNodeArray` function in `sqlite3.c` file. An attacker can potentially
    lead to a denial of service by passing specially crafted malicious input to the
    application.
  references:
    GitHub Commit: https://github.com/sqlite/sqlite/commit/3736d874229135abecb935d938346dee5429196a
    RedHat Bugzilla Bug: https://bugzilla.redhat.com/show_bug.cgi?id=2243754
  title: Use After Free
- diff_content:
  - "--- a/src/split.c\n+++ b/src/split.c\n@@ -809,10 +809,7 @@ line_bytes_split (intmax_t\
    \ n_bytes, char *buf, idx_t bufsize)\n             {\n               cwrite (n_out\
    \ == 0, hold, n_hold);\n               n_out += n_hold;\n-              if (n_hold\
    \ > bufsize)\n-                hold = xirealloc (hold, bufsize);\n           \
    \    n_hold = 0;\n-              hold_size = bufsize;\n             }\n \n   \
    \        /* Output to eol if present.  */"
  identifiers: CVE:["CVE-2024-0684"],CWE:["CWE-122"]
  overview: Affected versions of this package are vulnerable to Heap-based Buffer
    Overflow via the `line_bytes_split` function. An attacker can cause an application
    crash by providing user-controlled data of multiple hundred bytes in length.
  references:
    GitHub Commit: https://github.com/coreutils/coreutils/commit/c4c5ed8f4e9cd55a12966d4f520e3a13101637d9
    OSS Security Advisory: https://www.openwall.com/lists/oss-security/2024/01/18/2
  title: Heap-based Buffer Overflow
- diff_content:
  - "--- a/b/net/tls/tls_sw.c\n+++ b/b/net/tls/tls_sw.c\n@@ -190,6 +190,10 @@ static\
    \ int gvconfig_plugin_install_from_config(GVC_t * gvc, char *s)\n \tdo {\n \t\
    \    const char *api = token(&nest, &s);\n \t    const api_t gv_api = gvplugin_api(api);\n\
    +\t    if (gv_api == (api_t)-1) {\n+\t\tagerr(AGERR, \"config error: %s %s not\
    \ found\\n\", package_path, api);\n+\t\treturn 0;\n+\t    }\n \t    do {\n \t\t\
    if (nest == 2) {\n \t\t    type = token(&nest, &s);\n@@ -106,16 +106,25 @@ static\
    \ int smb2_get_data_area_len(unsigned int *off, unsigned int *len,\n \t\tbreak;\n\
    \ \tcase SMB2_CREATE:\n \t{\n+\t\tunsigned short int name_off =\n+\t\t\tle16_to_cpu(((struct\
    \ smb2_create_req *)hdr)->NameOffset);\n+\t\tunsigned short int name_len =\n+\t\
    \t\tle16_to_cpu(((struct smb2_create_req *)hdr)->NameLength);\n+\n \t\tif (((struct\
    \ smb2_create_req *)hdr)->CreateContextsLength) {\n \t\t\t*off = le32_to_cpu(((struct\
    \ smb2_create_req *)\n \t\t\t\thdr)->CreateContextsOffset);\n \t\t\t*len = le32_to_cpu(((struct\
    \ smb2_create_req *)\n \t\t\t\thdr)->CreateContextsLength);\n-\t\t\tbreak;\n+\t\
    \t\tif (!name_len)\n+\t\t\t\tbreak;\n+\n+\t\t\tif (name_off + name_len < (u64)*off\
    \ + *len)\n+\t\t\t\tbreak;\n \t\t}\n \n-\t\t*off = le16_to_cpu(((struct smb2_create_req\
    \ *)hdr)->NameOffset);\n-\t\t*len = le16_to_cpu(((struct smb2_create_req *)hdr)->NameLength);\n\
    +\t\t*off = name_off;\n+\t\t*len = name_len;\n \t\tbreak;\n \t}\n \tcase SMB2_QUERY_INFO:\n\
    @@ -151,6 +151,8 @@ static int send_acknowledge(struct nci_spi *nspi, u8 acknowledge)\n\
    \ \tint ret;\n \n \tskb = nci_skb_alloc(nspi->ndev, 0, GFP_KERNEL);\n+\tif (!skb)\n\
    +\t\treturn -ENOMEM;\n \n \t/* add the NCI SPI header to the start of the buffer\
    \ */\n \thdr = skb_push(skb, NCI_SPI_HDR_LEN);\n@@ -952,6 +952,8 @@ static int\
    \ tls_sw_sendmsg_splice(struct sock *sk, struct msghdr *msg,\n \t\t}\n \n \t\t\
    sk_msg_page_add(msg_pl, page, part, off);\n+\t\tmsg_pl->sg.copybreak = 0;\n+\t\
    \tmsg_pl->sg.curr = msg_pl->sg.end;\n \t\tsk_mem_charge(sk, part);\n \t\t*copied\
    \ += part;\n \t\ttry_to_copy -= part;\n"
  - "--- a/net/tls/tls_sw.c\n+++ b/net/tls/tls_sw.c\n@@ -952,6 +952,8 @@ static int\
    \ tls_sw_sendmsg_splice(struct sock *sk, struct msghdr *msg,\n \t\t}\n \n \t\t\
    sk_msg_page_add(msg_pl, page, part, off);\n+\t\tmsg_pl->sg.copybreak = 0;\n+\t\
    \tmsg_pl->sg.curr = msg_pl->sg.end;\n \t\tsk_mem_charge(sk, part);\n \t\t*copied\
    \ += part;\n \t\ttry_to_copy -= part;"
  identifiers: CVE:["CVE-2024-0646"],CWE:["CWE-787"]
  overview: Affected versions of this package are vulnerable to Out-of-bounds Write
    in the Transport Layer Security functionality via the `splice` function with a
    `ktls` socket as the destination. An attacker can crash the system or potentially
    escalate their privileges by exploiting this vulnerability.
  references:
    Git Commit: https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=c5a595000e267
    GitHub Commit: https://github.com/torvalds/linux/commit/c5a595000e2677e865a39f249c056bc05d6e55fd
    RedHat Bugzilla Bug: https://bugzilla.redhat.com/show_bug.cgi?id=2253908
  title: Out-of-bounds Write
- diff_content:
  - "--- a/net/netfilter/nft_byteorder.c\n+++ b/net/netfilter/nft_byteorder.c\n@@\
    \ -38,21 +38,22 @@ void nft_byteorder_eval(const struct nft_expr *expr,\n \n \t\
    switch (priv->size) {\n \tcase 8: {\n+\t\tu64 *dst64 = (void *)dst;\n \t\tu64\
    \ src64;\n \n \t\tswitch (priv->op) {\n \t\tcase NFT_BYTEORDER_NTOH:\n \t\t\t\
    for (i = 0; i < priv->len / 8; i++) {\n \t\t\t\tsrc64 = nft_reg_load64(&src[i]);\n\
    -\t\t\t\tnft_reg_store64(&dst[i],\n+\t\t\t\tnft_reg_store64(&dst64[i],\n \t\t\t\
    \t\t\tbe64_to_cpu((__force __be64)src64));\n \t\t\t}\n \t\t\tbreak;\n \t\tcase\
    \ NFT_BYTEORDER_HTON:\n \t\t\tfor (i = 0; i < priv->len / 8; i++) {\n \t\t\t\t\
    src64 = (__force __u64)\n \t\t\t\t\tcpu_to_be64(nft_reg_load64(&src[i]));\n-\t\
    \t\t\tnft_reg_store64(&dst[i], src64);\n+\t\t\t\tnft_reg_store64(&dst64[i], src64);\n\
    \ \t\t\t}\n \t\t\tbreak;\n \t\t}"
  - "--- a/net/netfilter/nft_meta.c\n+++ b/net/netfilter/nft_meta.c\n@@ -63,7 +63,7\
    \ @@ nft_meta_get_eval_time(enum nft_meta_keys key,\n {\n \tswitch (key) {\n \t\
    case NFT_META_TIME_NS:\n-\t\tnft_reg_store64(dest, ktime_get_real_ns());\n+\t\t\
    nft_reg_store64((u64 *)dest, ktime_get_real_ns());\n \t\tbreak;\n \tcase NFT_META_TIME_DAY:\n\
    \ \t\tnft_reg_store8(dest, nft_meta_weekday());"
  identifiers: CVE:["CVE-2024-0607"],CWE:["CWE-787"]
  overview: Affected versions of this package are vulnerable to Out-of-bounds Write
    via the `nft_byteorder_eval` function. An attacker can achieve arbitrary code
    execution by exploiting incorrect pointer arithmetic to manipulate memory.
  references:
    GitHub Commit: https://github.com/torvalds/linux/commit/c301f0981fdd3fd1ffac6836b423c4d7a8e0eb63
    RedHat Bugzilla Bug: https://bugzilla.redhat.com/show_bug.cgi?id=2258635
  title: Out-of-bounds Write
- diff_content:
  - "--- a/net/ipv4/igmp.c\n+++ b/net/ipv4/igmp.c\n@@ -216,8 +216,10 @@ static void\
    \ igmp_start_timer(struct ip_mc_list *im, int max_delay)\n \tint tv = get_random_u32_below(max_delay);\n\
    \ \n \tim->tm_running = 1;\n-\tif (!mod_timer(&im->timer, jiffies+tv+2))\n-\t\t\
    refcount_inc(&im->refcnt);\n+\tif (refcount_inc_not_zero(&im->refcnt)) {\n+\t\t\
    if (mod_timer(&im->timer, jiffies + tv + 2))\n+\t\t\tip_ma_put(im);\n+\t}\n }\n\
    \ \n static void igmp_gq_start_timer(struct in_device *in_dev)"
  identifiers: CVE:["CVE-2024-0584"],CWE:["CWE-416"]
  overview: Affected versions of this package are vulnerable to Use After Free via
    the `igmp_start_timer` process when handling an IGMP query packet. An attacker
    with local access can cause a use-after-free error leading to potential privilege
    escalation or denial of service.
  references:
    GitHub Commit: https://github.com/torvalds/linux/commit/e2b706c691905fe78468c361aaabc719d0a496f1
    RedHat Bugzilla Bug: https://bugzilla.redhat.com/show_bug.cgi?id=2258584
  title: Use After Free
- diff_content:
  - "--- a/lib/auth/rsa_psk.c\n+++ b/lib/auth/rsa_psk.c\n@@ -256,7 +256,6 @@ static\
    \ int _gnutls_proc_rsa_psk_client_kx(gnutls_session_t session,\n \tint ret, dsize;\n\
    \ \tssize_t data_size = _data_size;\n \tgnutls_psk_server_credentials_t cred;\n\
    -\tgnutls_datum_t premaster_secret = { NULL, 0 };\n \tvolatile uint8_t ver_maj,\
    \ ver_min;\n \n \tcred = (gnutls_psk_server_credentials_t)_gnutls_get_cred(\n\
    @@ -318,24 +317,49 @@ static int _gnutls_proc_rsa_psk_client_kx(gnutls_session_t\
    \ session,\n \tver_maj = _gnutls_get_adv_version_major(session);\n \tver_min =\
    \ _gnutls_get_adv_version_minor(session);\n \n-\tpremaster_secret.data = gnutls_malloc(GNUTLS_MASTER_SIZE);\n\
    -\tif (premaster_secret.data == NULL) {\n+\t/* Find the key of this username.\
    \ A random value will be\n+\t * filled in if the key is not found.\n+\t */\n+\t\
    ret = _gnutls_psk_pwd_find_entry(session, info->username,\n+\t\t\t\t\t strlen(info->username),\
    \ &pwd_psk,\n+\t\t\t\t\t NULL);\n+\tif (ret < 0)\n+\t\treturn gnutls_assert_val(ret);\n\
    +\n+\t/* Allocate memory for premaster secret, and fill in the\n+\t * fields except\
    \ the decryption result.\n+\t */\n+\tsession->key.key.size = 2 + GNUTLS_MASTER_SIZE\
    \ + 2 + pwd_psk.size;\n+\tsession->key.key.data = gnutls_malloc(session->key.key.size);\n\
    +\tif (session->key.key.data == NULL) {\n \t\tgnutls_assert();\n+\t\t_gnutls_free_key_datum(&pwd_psk);\n\
    +\t\t/* No need to zeroize, as the secret is not copied in yet */\n+\t\t_gnutls_free_datum(&session->key.key);\n\
    \ \t\treturn GNUTLS_E_MEMORY_ERROR;\n \t}\n-\tpremaster_secret.size = GNUTLS_MASTER_SIZE;\n\
    \ \n \t/* Fallback value when decryption fails. Needs to be unpredictable. */\n\
    -\tret = gnutls_rnd(GNUTLS_RND_NONCE, premaster_secret.data,\n-\t\t\t premaster_secret.size);\n\
    +\tret = gnutls_rnd(GNUTLS_RND_NONCE, session->key.key.data + 2,\n+\t\t\t GNUTLS_MASTER_SIZE);\n\
    \ \tif (ret < 0) {\n \t\tgnutls_assert();\n-\t\tgoto cleanup;\n+\t\t_gnutls_free_key_datum(&pwd_psk);\n\
    +\t\t/* No need to zeroize, as the secret is not copied in yet */\n+\t\t_gnutls_free_datum(&session->key.key);\n\
    +\t\treturn ret;\n \t}\n \n+\t_gnutls_write_uint16(GNUTLS_MASTER_SIZE, session->key.key.data);\n\
    +\t_gnutls_write_uint16(pwd_psk.size,\n+\t\t\t     &session->key.key.data[2 +\
    \ GNUTLS_MASTER_SIZE]);\n+\tmemcpy(&session->key.key.data[2 + GNUTLS_MASTER_SIZE\
    \ + 2], pwd_psk.data,\n+\t       pwd_psk.size);\n+\t_gnutls_free_key_datum(&pwd_psk);\n\
    +\n \tgnutls_privkey_decrypt_data2(session->internals.selected_key, 0,\n-\t\t\t\
    \t     &ciphertext, premaster_secret.data,\n-\t\t\t\t     premaster_secret.size);\n\
    +\t\t\t\t     &ciphertext, session->key.key.data + 2,\n+\t\t\t\t     GNUTLS_MASTER_SIZE);\n\
    \ \t/* After this point, any conditional on failure that cause differences\n \t\
    \ * in execution may create a timing or cache access pattern side\n \t * channel\
    \ that can be used as an oracle, so tread carefully */\n@@ -354,31 +378,10 @@\
    \ static int _gnutls_proc_rsa_psk_client_kx(gnutls_session_t session,\n \t/* This\
    \ is here to avoid the version check attack\n \t * discussed above.\n \t */\n\
    -\tpremaster_secret.data[0] = ver_maj;\n-\tpremaster_secret.data[1] = ver_min;\n\
    -\n-\t/* find the key of this username\n-\t */\n-\tret = _gnutls_psk_pwd_find_entry(session,\
    \ info->username,\n-\t\t\t\t\t strlen(info->username), &pwd_psk,\n-\t\t\t\t\t\
    \ NULL);\n-\tif (ret < 0) {\n-\t\tgnutls_assert();\n-\t\tgoto cleanup;\n-\t}\n\
    +\tsession->key.key.data[2] = ver_maj;\n+\tsession->key.key.data[3] = ver_min;\n\
    \ \n-\tret = set_rsa_psk_session_key(session, &pwd_psk, &premaster_secret);\n\
    -\tif (ret < 0) {\n-\t\tgnutls_assert();\n-\t\tgoto cleanup;\n-\t}\n-\n-\tret\
    \ = 0;\n-cleanup:\n-\t_gnutls_free_key_datum(&pwd_psk);\n-\t_gnutls_free_temp_key_datum(&premaster_secret);\n\
    -\n-\treturn ret;\n+\treturn 0;\n }\n \n static int _gnutls_proc_rsa_psk_server_kx(gnutls_session_t\
    \ session,"
  identifiers: CVE:["CVE-2024-0553"],CWE:["CWE-203"]
  overview: Affected versions of this package are vulnerable to Observable Discrepancy
    in response times when processing malformed ciphertexts compared to those with
    correct PKCS#1 v1.5 padding during RSA-PSK ClientKeyExchange. An attacker can
    potentially exploit this timing side-channel to leak sensitive information by
    observing the differences in response times (Marvin).
  references:
    CVE-2023-5981: https://security.snyk.io/vuln/SNYK-UNMANAGED-GNUTLS-6094981
    GitHub Commit: https://github.com/gnutls/gnutls/commit/40dbbd8de499668590e8af51a15799fbc430595e
    Gitlab Issue: https://gitlab.com/gnutls/gnutls/-/issues/1522
    RedHat Bugzilla Bug: https://bugzilla.redhat.com/show_bug.cgi?id=2258412
    Release Notes: https://lists.gnupg.org/pipermail/gnutls-help/2024-January/004841.html
    Vulnerability Report: https://people.redhat.com/~hkario/marvin/
  title: Observable Discrepancy
- diff_content:
  - "--- a/fs/smb/client/smb2ops.c\n+++ b/fs/smb/client/smb2ops.c\n@@ -4943,6 +4943,7\
    \ @@ receive_encrypted_standard(struct TCP_Server_Info *server,\n \tstruct smb2_hdr\
    \ *shdr;\n \tunsigned int pdu_length = server->pdu_size;\n \tunsigned int buf_size;\n\
    +\tunsigned int next_cmd;\n \tstruct mid_q_entry *mid_entry;\n \tint next_is_large;\n\
    \ \tchar *next_buffer = NULL;\n@@ -4971,14 +4972,15 @@ receive_encrypted_standard(struct\
    \ TCP_Server_Info *server,\n \tnext_is_large = server->large_buf;\n one_more:\n\
    \ \tshdr = (struct smb2_hdr *)buf;\n-\tif (shdr->NextCommand) {\n+\tnext_cmd =\
    \ le32_to_cpu(shdr->NextCommand);\n+\tif (next_cmd) {\n+\t\tif (WARN_ON_ONCE(next_cmd\
    \ > pdu_length))\n+\t\t\treturn -1;\n \t\tif (next_is_large)\n \t\t\tnext_buffer\
    \ = (char *)cifs_buf_get();\n \t\telse\n \t\t\tnext_buffer = (char *)cifs_small_buf_get();\n\
    -\t\tmemcpy(next_buffer,\n-\t\t       buf + le32_to_cpu(shdr->NextCommand),\n\
    -\t\t       pdu_length - le32_to_cpu(shdr->NextCommand));\n+\t\tmemcpy(next_buffer,\
    \ buf + next_cmd, pdu_length - next_cmd);\n \t}\n \n \tmid_entry = smb2_find_mid(server,\
    \ buf);\n@@ -5002,8 +5004,8 @@ receive_encrypted_standard(struct TCP_Server_Info\
    \ *server,\n \telse\n \t\tret = cifs_handle_standard(server, mid_entry);\n \n\
    -\tif (ret == 0 && shdr->NextCommand) {\n-\t\tpdu_length -= le32_to_cpu(shdr->NextCommand);\n\
    +\tif (ret == 0 && next_cmd) {\n+\t\tpdu_length -= next_cmd;\n \t\tserver->large_buf\
    \ = next_is_large;\n \t\tif (next_is_large)\n \t\t\tserver->bigbuf = buf = next_buffer;"
  identifiers: CVE:["CVE-2024-0565"],CWE:["CWE-191"]
  overview: Affected versions of this package are vulnerable to Integer Underflow
    due to improper input validation in the `receive_encrypted_standard` function.
    An attacker can cause a denial of service or potentially execute arbitrary code
    by sending specially crafted packets that trigger this vulnerability.
  references:
    GitHub Commit: https://github.com/torvalds/linux/commit/eec04ea119691e65227a97ce53c0da6b9b74b0b7
    RedHat Bugzilla Bug: https://bugzilla.redhat.com/show_bug.cgi?id=2258518
  title: Integer Underflow
- diff_content:
  - "--- a/fs/fs-writeback.c\n+++ b/fs/fs-writeback.c\n@@ -134,10 +134,10 @@ static\
    \ bool inode_io_list_move_locked(struct inode *inode,\n \n static void wb_wakeup(struct\
    \ bdi_writeback *wb)\n {\n-\tspin_lock_bh(&wb->work_lock);\n+\tspin_lock_irq(&wb->work_lock);\n\
    \ \tif (test_bit(WB_registered, &wb->state))\n \t\tmod_delayed_work(bdi_wq, &wb->dwork,\
    \ 0);\n-\tspin_unlock_bh(&wb->work_lock);\n+\tspin_unlock_irq(&wb->work_lock);\n\
    \ }\n \n static void finish_writeback_work(struct bdi_writeback *wb,\n@@ -164,15\
    \ +164,15 @@ static void wb_queue_work(struct bdi_writeback *wb,\n \tif (work->done)\n\
    \ \t\tatomic_inc(&work->done->cnt);\n \n-\tspin_lock_bh(&wb->work_lock);\n+\t\
    spin_lock_irq(&wb->work_lock);\n \n \tif (test_bit(WB_registered, &wb->state))\
    \ {\n \t\tlist_add_tail(&work->list, &wb->work_list);\n \t\tmod_delayed_work(bdi_wq,\
    \ &wb->dwork, 0);\n \t} else\n \t\tfinish_writeback_work(wb, work);\n \n-\tspin_unlock_bh(&wb->work_lock);\n\
    +\tspin_unlock_irq(&wb->work_lock);\n }\n \n /**\n@@ -2082,13 +2082,13 @@ static\
    \ struct wb_writeback_work *get_next_work_item(struct bdi_writeback *wb)\n {\n\
    \ \tstruct wb_writeback_work *work = NULL;\n \n-\tspin_lock_bh(&wb->work_lock);\n\
    +\tspin_lock_irq(&wb->work_lock);\n \tif (!list_empty(&wb->work_list)) {\n \t\t\
    work = list_entry(wb->work_list.next,\n \t\t\t\t  struct wb_writeback_work, list);\n\
    \ \t\tlist_del_init(&work->list);\n \t}\n-\tspin_unlock_bh(&wb->work_lock);\n\
    +\tspin_unlock_irq(&wb->work_lock);\n \treturn work;\n }\n "
  - "--- a/mm/backing-dev.c\n+++ b/mm/backing-dev.c\n@@ -260,10 +260,10 @@ void wb_wakeup_delayed(struct\
    \ bdi_writeback *wb)\n \tunsigned long timeout;\n \n \ttimeout = msecs_to_jiffies(dirty_writeback_interval\
    \ * 10);\n-\tspin_lock_bh(&wb->work_lock);\n+\tspin_lock_irq(&wb->work_lock);\n\
    \ \tif (test_bit(WB_registered, &wb->state))\n \t\tqueue_delayed_work(bdi_wq,\
    \ &wb->dwork, timeout);\n-\tspin_unlock_bh(&wb->work_lock);\n+\tspin_unlock_irq(&wb->work_lock);\n\
    \ }\n \n static void wb_update_bandwidth_workfn(struct work_struct *work)\n@@\
    \ -334,12 +334,12 @@ static void cgwb_remove_from_bdi_list(struct bdi_writeback\
    \ *wb);\n static void wb_shutdown(struct bdi_writeback *wb)\n {\n \t/* Make sure\
    \ nobody queues further work */\n-\tspin_lock_bh(&wb->work_lock);\n+\tspin_lock_irq(&wb->work_lock);\n\
    \ \tif (!test_and_clear_bit(WB_registered, &wb->state)) {\n-\t\tspin_unlock_bh(&wb->work_lock);\n\
    +\t\tspin_unlock_irq(&wb->work_lock);\n \t\treturn;\n \t}\n-\tspin_unlock_bh(&wb->work_lock);\n\
    +\tspin_unlock_irq(&wb->work_lock);\n \n \tcgwb_remove_from_bdi_list(wb);\n \t\
    /*"
  - "--- a/mm/page-writeback.c\n+++ b/mm/page-writeback.c\n@@ -2892,6 +2892,7 @@ static\
    \ void wb_inode_writeback_start(struct bdi_writeback *wb)\n \n static void wb_inode_writeback_end(struct\
    \ bdi_writeback *wb)\n {\n+\tunsigned long flags;\n \tatomic_dec(&wb->writeback_inodes);\n\
    \ \t/*\n \t * Make sure estimate of writeback throughput gets updated after\n\
    @@ -2900,7 +2901,10 @@ static void wb_inode_writeback_end(struct bdi_writeback\
    \ *wb)\n \t * that if multiple inodes end writeback at a similar time, they get\n\
    \ \t * batched into one bandwidth update.\n \t */\n-\tqueue_delayed_work(bdi_wq,\
    \ &wb->bw_dwork, BANDWIDTH_INTERVAL);\n+\tspin_lock_irqsave(&wb->work_lock, flags);\n\
    +\tif (test_bit(WB_registered, &wb->state))\n+\t\tqueue_delayed_work(bdi_wq, &wb->bw_dwork,\
    \ BANDWIDTH_INTERVAL);\n+\tspin_unlock_irqrestore(&wb->work_lock, flags);\n }\n\
    \ \n bool __folio_end_writeback(struct folio *folio)"
  identifiers: CVE:["CVE-2024-0562"],CWE:["CWE-416"]
  overview: Affected versions of this package are vulnerable to Use After Free due
    to improper synchronization between `bdi_unregister` and `wb_inode_writeback_end`
    functions. An attacker with local access can cause a denial of service or potentially
    execute arbitrary code by triggering this vulnerability when a disk is removed
    and the system attempts to access a recently freed `bdi_writeback`.
  references:
    GitHub Commit: https://github.com/torvalds/linux/commit/f87904c075515f3e1d8f4a7115869d3b914674fd
    RedHat Bugzilla Bug: https://bugzilla.redhat.com/show_bug.cgi?id=2258475
  title: Use After Free
- diff_content:
  - "--- a/lib/idr.c\n+++ b/lib/idr.c\n@@ -508,7 +508,7 @@ void ida_free(struct ida\
    \ *ida, unsigned int id)\n \t\t\tgoto delete;\n \t\txas_store(&xas, xa_mk_value(v));\n\
    \ \t} else {\n-\t\tif (!test_bit(bit, bitmap->bitmap))\n+\t\tif (!bitmap || !test_bit(bit,\
    \ bitmap->bitmap))\n \t\t\tgoto err;\n \t\t__clear_bit(bit, bitmap->bitmap);\n\
    \ \t\txas_set_mark(&xas, XA_FREE_MARK);"
  - "--- a/lib/test_ida.c\n+++ b/lib/test_ida.c\n@@ -150,6 +150,45 @@ static void\
    \ ida_check_conv(struct ida *ida)\n \tIDA_BUG_ON(ida, !ida_is_empty(ida));\n }\n\
    \ \n+/*\n+ * Check various situations where we attempt to free an ID we don't\
    \ own.\n+ */\n+static void ida_check_bad_free(struct ida *ida)\n+{\n+\tunsigned\
    \ long i;\n+\n+\tprintk(\"vvv Ignore \\\"not allocated\\\" warnings\\n\");\n+\t\
    /* IDA is empty; all of these will fail */\n+\tida_free(ida, 0);\n+\tfor (i =\
    \ 0; i < 31; i++)\n+\t\tida_free(ida, 1 << i);\n+\n+\t/* IDA contains a single\
    \ value entry */\n+\tIDA_BUG_ON(ida, ida_alloc_min(ida, 3, GFP_KERNEL) != 3);\n\
    +\tida_free(ida, 0);\n+\tfor (i = 0; i < 31; i++)\n+\t\tida_free(ida, 1 << i);\n\
    +\n+\t/* IDA contains a single bitmap */\n+\tIDA_BUG_ON(ida, ida_alloc_min(ida,\
    \ 1023, GFP_KERNEL) != 1023);\n+\tida_free(ida, 0);\n+\tfor (i = 0; i < 31; i++)\n\
    +\t\tida_free(ida, 1 << i);\n+\n+\t/* IDA contains a tree */\n+\tIDA_BUG_ON(ida,\
    \ ida_alloc_min(ida, (1 << 20) - 1, GFP_KERNEL) != (1 << 20) - 1);\n+\tida_free(ida,\
    \ 0);\n+\tfor (i = 0; i < 31; i++)\n+\t\tida_free(ida, 1 << i);\n+\tprintk(\"\
    ^^^ \\\"not allocated\\\" warnings over\\n\");\n+\n+\tida_free(ida, 3);\n+\tida_free(ida,\
    \ 1023);\n+\tida_free(ida, (1 << 20) - 1);\n+\n+\tIDA_BUG_ON(ida, !ida_is_empty(ida));\n\
    +}\n+\n static DEFINE_IDA(ida);\n \n static int ida_checks(void)\n@@ -162,6 +201,7\
    \ @@ static int ida_checks(void)\n \tida_check_leaf(&ida, 1024 * 64);\n \tida_check_max(&ida);\n\
    \ \tida_check_conv(&ida);\n+\tida_check_bad_free(&ida);\n \n \tprintk(\"IDA: %u\
    \ of %u tests passed\\n\", tests_passed, tests_run);\n \treturn (tests_run !=\
    \ tests_passed) ? 0 : -EINVAL;"
  identifiers: CVE:["CVE-2023-6915"],CWE:["CWE-476"]
  overview: Affected versions of this package are vulnerable to NULL Pointer Dereference
    via the `ida_free` function in the `lib/idr.c file`. An attacker can cause a system
    crash by triggering a missing check at a function return.
  references:
    GitHub Commit: https://github.com/torvalds/linux/commit/af73483f4e8b6f5c68c9aa63257bdd929a9c194a
    RedHat Bugzilla Bug: https://bugzilla.redhat.com/show_bug.cgi?id=2254982
  title: NULL Pointer Dereference
- diff_content:
  - "--- a/src/libjasper/base/jas_icc.c\n+++ b/src/libjasper/base/jas_icc.c\n@@ -1324,12\
    \ +1324,22 @@ static int jas_icctxt_input(jas_iccattrval_t *attrval, jas_stream_t\
    \ *in,\n {\n \tjas_icctxt_t *txt = &attrval->data.txt;\n \ttxt->string = 0;\n\
    +\t/* The string must at least contain a single null character. */\n+\tif (cnt\
    \ < 1) {\n+\t\tgoto error;\n+\t}\n \tif (!(txt->string = jas_malloc(cnt))) {\n\
    \ \t\tgoto error;\n \t}\n \tif (jas_stream_read(in, txt->string, cnt) != cnt)\
    \ {\n \t\tgoto error;\n \t}\n+\t/* Ensure that the string is null terminated.\
    \ */\n+\tif (txt->string[cnt - 1] != '\\0') {\n+\t\tgoto error;\n+\t}\n+\t/* The\
    \ following line is redundant, unless we do not enforce that\n+\t  the last character\
    \ must be null. */\n \ttxt->string[cnt - 1] = '\\0';\n \tif (strlen(txt->string)\
    \ + 1 != cnt) {\n \t\tgoto error;"
  identifiers: CVE:["CVE-2023-51257"],CWE:["CWE-787"]
  overview: Affected versions of this package are vulnerable to Out-of-bounds Write
    due to improper validation of user-supplied input. An attacker can cause the application
    to write data to an incorrect memory location by submitting crafted input.
  references:
    GitHub Commit: https://github.com/jasper-software/jasper/commit/aeef5293c978158255ad4f127089644745602f2a
    Issue: https://bugs.gentoo.org/922075
    RedHat Bugzilla Bug: https://bugzilla.redhat.com/show_bug.cgi?id=2258400
  title: Out-of-bounds Write
- diff_content:
  - "--- a/src/libbson/src/bson/bson-utf8.c\n+++ b/src/libbson/src/bson/bson-utf8.c\n\
    @@ -118,8 +118,8 @@ bson_utf8_validate (const char *utf8, /* IN */\n    bson_unichar_t\
    \ c;\n    uint8_t first_mask;\n    uint8_t seq_length;\n-   unsigned i;\n-   unsigned\
    \ j;\n+   size_t i;\n+   size_t j;\n \n    BSON_ASSERT (utf8);\n "
  identifiers: CVE:["CVE-2023-0437"],CWE:["CWE-835"]
  overview: Affected versions of this package are vulnerable to Loop with Unreachable
    Exit Condition ('Infinite Loop') due to an issue in the `bson_utf8_validate` function.
    An attacker can cause a denial of service by providing inputs that trigger an
    infinite loop.
  references:
    GitHub Commit: https://github.com/mongodb/mongo-c-driver/commit/fd3a978b35cac8f3c78c4d9a1b08fd5aa4d440b8
    Jira Issue: https://jira.mongodb.org/browse/CDRIVER-4747
  title: Loop with Unreachable Exit Condition ('Infinite Loop')
- diff_content:
  - "--- a/backend/comics/comics-document.c\n+++ b/backend/comics/comics-document.c\n\
    @@ -30,24 +30,17 @@\n #include <glib/gstdio.h>\n #include <gio/gio.h>\n \n-#include\
    \ <sys/wait.h>\n-\n #include \"comics-document.h\"\n #include \"ev-document-misc.h\"\
    \n #include \"ev-document-thumbnails.h\"\n #include \"ev-file-helpers.h\"\n+#include\
    \ \"ev-archive.h\"\n+#include <archive.h>\n+#include <archive_entry.h>\n \n #define\
    \ EV_EOL \"\\n\"\n \n-typedef enum\n-{\n-\tRARLABS,\n-\tGNAUNRAR,\n-\tUNZIP,\n\
    -\tP7ZIP,\n-\tTAR,\n-\tUNARCHIVER\n-} ComicBookDecompressType;\n+#define BLOCK_SIZE\
    \ 10240\n \n typedef struct _ComicsDocumentClass ComicsDocumentClass;\n \n@@ -58,398\
    \ +51,269 @@ struct _ComicsDocumentClass\n \n struct _ComicsDocument\n {\n-\t\
    EvDocument parent_instance;\n-\n-\tgchar    *archive, *dir;\n-\tGPtrArray *page_names;\n\
    -\tgchar    *selected_command, *alternative_command;\n-\tgchar    *extract_command,\
    \ *list_command, *decompress_tmp;\n-\tgboolean regex_arg;\n-\tgint     offset;\n\
    -\tComicBookDecompressType command_usage;\n+\tEvDocument     parent_instance;\n\
    +\tEvArchive     *archive;\n+\tgchar         *archive_path;\n+\tgchar        \
    \ *archive_uri;\n+\tGPtrArray     *page_names; /* elem: char * */\n+\tGHashTable\
    \    *page_positions; /* key: char *, value: uint + 1 */\n+\n };\n \n-#define\
    \ OFFSET_7Z 53\n-#define OFFSET_ZIP 2\n-#define NO_OFFSET 0\n-\n-/* For perfomance\
    \ reasons of 7z* we've choosen to decompress on the temporary\n- * directory instead\
    \ of decompressing on the stdout */\n-\n-/**\n- * @extract: command line arguments\
    \ to pass to extract a file from the archive\n- *   to stdout.\n- * @list: command\
    \ line arguments to list the archive contents\n- * @decompress_tmp: command line\
    \ arguments to pass to extract the archive\n- *   into a directory.\n- * @regex_arg:\
    \ whether the command can accept regex expressions\n- * @offset: the position\
    \ offset of the filename on each line in the output of\n- *   running the @list\
    \ command\n- */\n-typedef struct {\n-        char *extract;\n-        char *list;\n\
    -        char *decompress_tmp;\n-        gboolean regex_arg;\n-        gint offset;\n\
    -} ComicBookDecompressCommand;\n+static void       \n+comics_document_document_thumbnails_iface_init\
    \ (EvDocumentThumbnailsInterface *iface);\n+EV_BACKEND_REGISTER_WITH_CODE (ComicsDocument,\
    \ comics_document,\n+    {\n+        EV_BACKEND_IMPLEMENT_INTERFACE (EV_TYPE_DOCUMENT_THUMBNAILS,\n\
    +                        comics_document_document_thumbnails_iface_init);\n+ \
    \   } );\n+\n+#define FORMAT_UNKNOWN     0\n+#define FORMAT_SUPPORTED   1\n+#define\
    \ FORMAT_UNSUPPORTED 2\n+\n+/* Returns a GHashTable of:\n+ * <key>: file extensions\n\
    + * <value>: degree of support in gdk-pixbuf */\n+static GHashTable *\n+get_image_extensions(void)\n\
    +{\n+\tGHashTable *extensions;\n+\tGSList *formats = gdk_pixbuf_get_formats ();\n\
    +\tGSList *l;\n+\tguint i;\n+\tconst char *known_image_formats[] = {\n+\t\t\"\
    png\",\n+\t\t\"jpg\",\n+\t\t\"jpeg\",\n+\t\t\"webp\"\n+\t};\n+\n+\textensions\
    \ = g_hash_table_new_full (g_str_hash, g_str_equal,\n+\t\t\t\t\t    g_free, NULL);\n\
    +\tfor (l = formats; l != NULL; l = l->next) {\n+\t\tint i;\n+\t\tgchar **ext\
    \ = gdk_pixbuf_format_get_extensions (l->data);\n+\n+\t\tfor (i = 0; ext[i] !=\
    \ NULL; i++) {\n+\t\t\tg_hash_table_insert (extensions,\n+\t\t\t\t\t     g_strdup\
    \ (ext[i]),\n+\t\t\t\t\t     GINT_TO_POINTER (FORMAT_SUPPORTED));\n+\t\t}\n \n\
    -static const ComicBookDecompressCommand command_usage_def[] = {\n-        /*\
    \ RARLABS unrar */\n-\t{\"%s p -c- -ierr --\", \"%s vb -c- -- %s\", NULL     \
    \        , FALSE, NO_OFFSET},\n+\t\tg_strfreev (ext);\n+\t}\n+\tg_slist_free (formats);\n\
    \ \n-        /* GNA! unrar */\n-\t{NULL               , \"%s t %s\"        , \"\
    %s -xf %s %s\"   , FALSE, NO_OFFSET},\n+\t/* Add known image formats that aren't\
    \ supported by gdk-pixbuf */\n+\tfor (i = 0; i < G_N_ELEMENTS (known_image_formats);\
    \ i++) {\n+\t\tif (!g_hash_table_lookup (extensions, known_image_formats[i]))\
    \ {\n+\t\t\tg_hash_table_insert (extensions,\n+\t\t\t\t\t     g_strdup (known_image_formats[i]),\n\
    +\t\t\t\t\t     GINT_TO_POINTER (FORMAT_UNSUPPORTED));\n+\t\t}\n+\t}\n \n-   \
    \     /* unzip */\n-\t{\"%s -p -C --\"      , \"%s %s\"          , NULL      \
    \       , TRUE , OFFSET_ZIP},\n+\treturn extensions;\n+}\n \n-        /* 7zip\
    \ */\n-\t{NULL               , \"%s l -- %s\"     , \"%s x -y %s -o%s\", FALSE,\
    \ OFFSET_7Z},\n+static int\n+has_supported_extension (const char *name,\n+\t\t\
    \t GHashTable *supported_extensions)\n+{\n+\tgboolean ret = FALSE;\n+\tgchar *suffix;\n\
    +\tsuffix = g_strrstr (name, \".\");\n+\tif (!suffix)\n+\t\treturn ret;\n \n-\
    \        /* tar */\n-\t{\"%s -xOf\"          , \"%s -tf %s\"      , NULL     \
    \        , FALSE, NO_OFFSET},\n+\tsuffix = g_ascii_strdown (suffix + 1, -1);\n\
    +\tret = GPOINTER_TO_INT (g_hash_table_lookup (supported_extensions, suffix));\n\
    +\tg_free (suffix);\n \n-\t/* UNARCHIVER */\n-\t{\"unar -o -\"\t    , \"%s %s\"\
    \t       , NULL\t\t  , FALSE, NO_OFFSET}\n-};\n+\treturn ret;\n+}\n \n-static\
    \ void       comics_document_document_thumbnails_iface_init (EvDocumentThumbnailsInterface\
    \ *iface);\n+#define APPLE_DOUBLE_PREFIX \"._\"\n+static gboolean\n+is_apple_double\
    \ (const char *name)\n+{\n+char *basename;\n+\tgboolean ret = FALSE;\n \n-static\
    \ GSList*    get_supported_image_extensions (void);\n-static void       get_page_size_area_prepared_cb\
    \ (GdkPixbufLoader *loader,\n-\t\t\t\t\t\t  gpointer data);\n-static void    \
    \   render_pixbuf_size_prepared_cb (GdkPixbufLoader *loader,\n-\t\t\t\t\t\t  gint\
    \ width,\n-\t\t\t\t\t\t  gint height,\n-\t\t\t\t\t\t  gpointer data);\n-static\
    \ char**     extract_argv                   (EvDocument *document,\n-\t\t\t\t\t\
    \t  gint page);\n+\tbasename = g_path_get_basename (name);\n+\tif (basename ==\
    \ NULL) {\n+\t\tg_debug (\"Filename '%s' doesn't have a basename?\", name);\n\
    +\t\treturn ret;\n+\t}\n+\tret = g_str_has_prefix (basename, APPLE_DOUBLE_PREFIX);\n\
    +\tg_free (basename);\n \n-EV_BACKEND_REGISTER_WITH_CODE (ComicsDocument, comics_document,\n\
    -\t{\n-\t\tEV_BACKEND_IMPLEMENT_INTERFACE (EV_TYPE_DOCUMENT_THUMBNAILS,\n-\t\t\
    \t\t\t\tcomics_document_document_thumbnails_iface_init);\n-\t} );\n-\n-/**\n-\
    \ * comics_regex_quote:\n- * @unquoted_string: a literal string\n- *\n- * Quotes\
    \ a string so unzip will not interpret the regex expressions of\n- * @unquoted_string.\
    \ Basically, this functions uses [] to disable regex\n- * expressions. The return\
    \ value must be freed with * g_free()\n- *\n- * Return value: quoted and disabled-regex\
    \ string\n- **/\n-static gchar *\n-comics_regex_quote (const gchar *unquoted_string)\n\
    +\treturn ret;\n+}\n+\n+static gboolean\n+archive_reopen_if_needed (ComicsDocument\
    \  *comics_document,\n+\t\t\t  const char      *page_wanted,\n+\t\t\t  GError\
    \         **error)\n {\n-\tconst gchar *p;\n-\tGString *dest;\n-\n-\tdest = g_string_new\
    \ (\"'\");\n-\n-\tp = unquoted_string;\n-\n-\twhile (*p) {\n-\t\tswitch (*p) {\n\
    -\t\t\t/* * matches a sequence of 0 or more characters */\n-\t\t\tcase ('*'):\n\
    -\t\t\t/* ? matches exactly 1 charactere */\n-\t\t\tcase ('?'):\n-\t\t\t/* [...]\
    \  matches any single character found inside\n-\t\t\t * the brackets. Disabling\
    \ the first bracket is enough.\n-\t\t\t */\n-\t\t\tcase ('['):\n-\t\t\t\tg_string_append\
    \ (dest, \"[\");\n-\t\t\t\tg_string_append_c (dest, *p);\n-\t\t\t\tg_string_append\
    \ (dest, \"]\");\n-\t\t\t\tbreak;\n-\t\t\t/* Because \\ escapes regex expressions\
    \ that we are\n-\t\t\t * disabling for unzip, we need to disable \\ too */\n-\t\
    \t\tcase ('\\\\'):\n-\t\t\t\tg_string_append (dest, \"[\\\\\\\\]\");\n-\t\t\t\t\
    break;\n-\t\t\t/* Escape single quote inside the string */\n-\t\t\tcase ('\\''):\n\
    -\t\t\t\tg_string_append (dest, \"'\\\\''\");\n-\t\t\t\tbreak;\n-\t\t\tdefault:\n\
    -\t\t\t\tg_string_append_c (dest, *p);\n-\t\t\t\tbreak;\n+\tconst char *current_page;\n\
    +\tguint current_page_idx, page_wanted_idx;\n+\n+\tif (ev_archive_at_entry (comics_document->archive))\
    \ {\n+\t\tcurrent_page = ev_archive_get_entry_pathname (comics_document->archive);\n\
    +\t\tif (current_page) {\n+\t\t\tcurrent_page_idx = GPOINTER_TO_UINT (g_hash_table_lookup\
    \ (comics_document->page_positions, current_page));\n+\t\t\tpage_wanted_idx =\
    \ GPOINTER_TO_UINT (g_hash_table_lookup (comics_document->page_positions, page_wanted));\n\
    +\n+\t\t\tif (current_page_idx != 0 &&\n+\t\t\t    page_wanted_idx != 0 &&\n+\t\
    \t\t    page_wanted_idx > current_page_idx)\n+\t\t\t\treturn TRUE;\n \t\t}\n-\t\
    \t++p;\n+\n+\t\tev_archive_reset (comics_document->archive);\n \t}\n-\tg_string_append_c\
    \ (dest, '\\'');\n-\treturn g_string_free (dest, FALSE);\n+return ev_archive_open_filename\
    \ (comics_document->archive, comics_document->archive_path, error);\n }\n \n-/*\
    \ This function manages the command for decompressing a comic book */\n-static\
    \ gboolean\n-comics_decompress_temp_dir (const gchar *command_decompress_tmp,\n\
    -\t\t\t    const gchar *command,\n-\t\t\t    GError      **error)\n+static GPtrArray\
    \ *\n+comics_document_list (ComicsDocument  *comics_document,\n+\t\t      GError\
    \         **error)\n {\n-\tgboolean success;\n-\tgchar *std_out, *basename;\n\
    -\tGError *err = NULL;\n-\tgint retval;\n-\n-\tsuccess = g_spawn_command_line_sync\
    \ (command_decompress_tmp, &std_out,\n-\t\t\t\t\t     NULL, &retval, &err);\n\
    -\tbasename = g_path_get_basename (command);\n-\tif (!success) {\n-\t\tg_set_error\
    \ (error,\n-\t\t\t     EV_DOCUMENT_ERROR,\n-\t\t\t     EV_DOCUMENT_ERROR_INVALID,\n\
    -\t\t\t     _(\"Error launching the command \u201C%s\u201D in order to \"\n-\t\
    \t\t     \"decompress the comic book: %s\"),\n-\t\t\t     basename,\n-\t\t\t \
    \    err->message);\n-\t\tg_error_free (err);\n-\t} else if (WIFEXITED (retval))\
    \ {\n-\t\tif (WEXITSTATUS (retval) == EXIT_SUCCESS) {\n-\t\t\tg_free (std_out);\n\
    -\t\t\tg_free (basename);\n-\t\t\treturn TRUE;\n-\t\t} else {\n-\t\t\tg_set_error\
    \ (error,\n+GPtrArray *array = NULL;\n+\tgboolean has_encrypted_files, has_unsupported_images,\
    \ has_archive_errors;\n+\tGHashTable *supported_extensions = NULL;\n+\n+\tif (!ev_archive_open_filename\
    \ (comics_document->archive, comics_document->archive_path, error)) {\n+\t\tif\
    \ (*error != NULL) {\n+\t\t\tg_warning (\"Fatal error handling archive (%s): %s\"\
    , G_STRFUNC, (*error)->message);\n+\t\t\tg_clear_error (error);\n+\t\t}\n+\n+\t\
    \tg_set_error_literal (error,\n \t\t\t\t     EV_DOCUMENT_ERROR,\n \t\t\t\t   \
    \  EV_DOCUMENT_ERROR_INVALID,\n-\t\t\t\t     _(\"The command \u201C%s\u201D failed\
    \ at \"\n-\t\t\t\t     \"decompressing the comic book.\"),\n-\t\t\t\t     basename);\n\
    -\t\t\tg_free (std_out);\n+\t\t\t     _(\"File is corrupted\"));\n+\t\tgoto out;\n\
    +\t}\n+\n+\tsupported_extensions = get_image_extensions ();\n+\n+\thas_encrypted_files\
    \ = FALSE;\n+\thas_unsupported_images = FALSE;\n+\thas_archive_errors = FALSE;\n\
    +\tarray = g_ptr_array_sized_new (64);\n+\n+\twhile (1) {\n+\t\tconst char *name;\n\
    +\t\tint supported;\n+\n+\t\tif (!ev_archive_read_next_header (comics_document->archive,\
    \ error)) {\n+\t\t\tif (*error != NULL) {\n+\t\t\t\tg_debug (\"Fatal error handling\
    \ archive (%s): %s\", G_STRFUNC, (*error)->message);\n+\t\t\t\tg_clear_error (error);\n\
    +\t\t\t\thas_archive_errors = TRUE;\n+\t\t\t\tgoto out;\n+\t\t\t}\n+\t\t\tbreak;\n\
    \ \t\t}\n-\t} else {\n-\t\tg_set_error (error,\n-\t\t\t     EV_DOCUMENT_ERROR,\n\
    -\t\t\t     EV_DOCUMENT_ERROR_INVALID,\n-\t\t\t     _(\"The command \u201C%s\u201D\
    \ did not end normally.\"),\n-\t\t\t     basename);\n-\t\tg_free (std_out);\n\
    +\n+\t\tname = ev_archive_get_entry_pathname (comics_document->archive);\n+\t\t\
    /* Ignore https://en.wikipedia.org/wiki/AppleSingle_and_AppleDouble_formats */\n\
    +\t\tif (is_apple_double (name)) {\n+\t\t\tg_debug (\"Not adding AppleDouble file\
    \ '%s' to the list of files in the comics\", name);\n+\t\t\tcontinue;\n+\t\t}\n\
    +\n+\t\tsupported = has_supported_extension (name, supported_extensions);\n+\t\
    \tif (supported == FORMAT_UNKNOWN) {\n+\t\t\tg_debug (\"Not adding unsupported\
    \ file '%s' to the list of files in the comics\", name);\n+\t\t\tcontinue;\n+\t\
    \t} else if (supported == FORMAT_UNSUPPORTED) {\n+\t\t\tg_debug (\"Not adding\
    \ unsupported image '%s' to the list of files in the comics\", name);\n+\t\t\t\
    has_unsupported_images = TRUE;\n+\t\t\tcontinue;\n+\t\t}\n+\n+\t\tif (ev_archive_get_entry_is_encrypted\
    \ (comics_document->archive)) {\n+\t\t\tg_debug (\"Not adding encrypted file '%s'\
    \ to the list of files in the comics\", name);\n+\t\t\thas_encrypted_files = TRUE;\n\
    +\t\t\tcontinue;\n+\t\t}\n+\n+\t\tg_debug (\"Adding '%s' to the list of files\
    \ in the comics\", name);\n+\t\tg_ptr_array_add (array, g_strdup (name));\n \t\
    }\n-\tg_free (basename);\n-\treturn FALSE;\n+out:\n+\tif (array->len == 0) {\n\
    +\t\tg_ptr_array_free (array, TRUE);\n+\t\tarray = NULL;\n+\n+\t\tif (has_encrypted_files)\
    \ {\n+\t\t\tg_set_error_literal (error,\n+\t\t\t\t\t     EV_DOCUMENT_ERROR,\n\
    +\t\t\t\t\t     EV_DOCUMENT_ERROR_ENCRYPTED,\n+\t\t\t\t\t     _(\"Archive is encrypted\"\
    ));\n+\t\t} else if (has_unsupported_images) {\n+\t\t\tg_set_error_literal (error,\n\
    +\t\t\t\t\t     EV_DOCUMENT_ERROR,\n+\t\t\t\t\t     EV_DOCUMENT_ERROR_UNSUPPORTED_CONTENT,\n\
    +\t\t\t\t\t     _(\"No supported images in archive\"));\n+\t\t} else if (has_archive_errors)\
    \ {\n+\t\t\tg_set_error_literal (error,\n+\t\t\t\t\t     EV_DOCUMENT_ERROR,\n\
    +\t\t\t\t\t     EV_DOCUMENT_ERROR_INVALID,\n+\t\t\t\t\t     _(\"File is corrupted\"\
    ));\n+\t\t} else {\n+\t\t\tg_set_error_literal (error,\n+\t\t\t\t\t     EV_DOCUMENT_ERROR,\n\
    +\t\t\t\t\t     EV_DOCUMENT_ERROR_INVALID,\n+\t\t\t\t\t     _(\"No files in archive\"\
    ));\n+\t\t}\n+\t}\n+\n+\tif (supported_extensions)\n+\t\tg_hash_table_destroy\
    \ (supported_extensions);\n+\tev_archive_reset (comics_document->archive);\n+\t\
    return array;\n }\n \n-/* This function shows how to use the choosen command for\
    \ decompressing a\n- * comic book file. It modifies fields of the ComicsDocument\
    \ struct with\n- * this information */\n-static gboolean\n-comics_generate_command_lines\
    \ (ComicsDocument *comics_document,\n-\t\t\t       GError         **error)\n+static\
    \ GHashTable *\n+save_positions (GPtrArray *page_names)\n {\n-\tgchar *quoted_file,\
    \ *quoted_file_aux;\n-\tgchar *quoted_command;\n-\tComicBookDecompressType type;\n\
    -\n-\ttype = comics_document->command_usage;\n-\tcomics_document->regex_arg =\
    \ command_usage_def[type].regex_arg;\n-\tquoted_command = g_shell_quote (comics_document->selected_command);\n\
    -\tif (comics_document->regex_arg) {\n-\t\tquoted_file = comics_regex_quote (comics_document->archive);\n\
    -\t\tquoted_file_aux = g_shell_quote (comics_document->archive);\n-\t\tcomics_document->list_command\
    \ =\n-\t\t\t   g_strdup_printf (command_usage_def[type].list,\n-\t\t\t       \
    \             comics_document->alternative_command,\n-\t\t\t                 \
    \   quoted_file_aux);\n-\t\tg_free (quoted_file_aux);\n-\t} else {\n-\t\tquoted_file\
    \ = g_shell_quote (comics_document->archive);\n-\t\tcomics_document->list_command\
    \ =\n-\t\t\t\tg_strdup_printf (command_usage_def[type].list,\n-\t\t\t\t      \
    \           quoted_command, quoted_file);\n-\t}\n-\tcomics_document->extract_command\
    \ =\n-\t\t\t    g_strdup_printf (command_usage_def[type].extract,\n-\t\t\t\t \
    \            quoted_command);\n-\tcomics_document->offset = command_usage_def[type].offset;\n\
    -\tif (command_usage_def[type].decompress_tmp) {\n-\t\tcomics_document->dir =\
    \ ev_mkdtemp (\"atril-comics-XXXXXX\", error);\n-                if (comics_document->dir\
    \ == NULL)\n-                        return FALSE;\n-\n-\t\t/* unrar-free can't\
    \ create directories, but ev_mkdtemp already created the dir */\n-\n-\t\tcomics_document->decompress_tmp\
    \ =\n-\t\t\tg_strdup_printf (command_usage_def[type].decompress_tmp,\n-\t\t\t\t\
    \t quoted_command, quoted_file,\n-\t\t\t\t\t comics_document->dir);\n-\t\tg_free\
    \ (quoted_file);\n-\t\tg_free (quoted_command);\n-\n-\t\tif (!comics_decompress_temp_dir\
    \ (comics_document->decompress_tmp,\n-\t\t    comics_document->selected_command,\
    \ error))\n-\t\t\treturn FALSE;\n-\t\telse\n-\t\t\treturn TRUE;\n-\t} else {\n\
    -\t\tg_free (quoted_file);\n-\t\tg_free (quoted_command);\n-\t\treturn TRUE;\n\
    -\t}\n+\tguint i;\n+\tGHashTable *ht;\n \n+\tht = g_hash_table_new (g_str_hash,\
    \ g_str_equal);\n+\tfor (i = 0; i < page_names->len; i++)\n+\t\tg_hash_table_insert\
    \ (ht, page_names->pdata[i], GUINT_TO_POINTER(i + 1));\n+\treturn ht;\n }\n \n\
    -/* This function chooses an external command for decompressing a comic\n- * book\
    \ based on its mime tipe. */\n+/*This function chooses the archive decompression\
    \ support\n+ * book based on its mime type. */\n static gboolean\n-comics_check_decompress_command\t\
    (gchar          *mime_type,\n+comics_check_decompress_support\t(gchar        \
    \  *mime_type,\n \t\t\t\t ComicsDocument *comics_document,\n \t\t\t\t GError \
    \        **error)\n {\n-\tgboolean success;\n-\tgchar *std_out, *std_err;\n-\t\
    gint retval;\n-\tGError *err = NULL;\n-\n-\t/* FIXME, use proper cbr/cbz mime\
    \ types once they're\n-\t * included in shared-mime-info */\n-\n \tif (g_content_type_is_a\
    \ (mime_type, \"application/x-cbr\") ||\n \t    g_content_type_is_a (mime_type,\
    \ \"application/x-rar\")) {\n-\t        /* The RARLAB provides a no-charge proprietary\
    \ (freeware)\n-\t        * decompress-only client for Linux called unrar. Another\n\
    -\t\t* option is a GPLv2-licensed command-line tool developed by\n-\t\t* the Gna!\
    \ project. Confusingly enough, the free software RAR\n-\t\t* decoder is also named\
    \ unrar. For this reason we need to add\n-\t\t* some lines for disambiguation.\
    \ Sorry for the added the\n-\t\t* complexity but it's life :)\n-\t\t* Finally,\
    \ some distributions, like Debian, rename this free\n-\t\t* option as unrar-free.\n\
    -\t\t* */\n-\t\tcomics_document->selected_command =\n-\t\t\t\t\tg_find_program_in_path\
    \ (\"unrar\");\n-\t\tif (comics_document->selected_command) {\n-\t\t\t/* We only\
    \ use std_err to avoid printing useless error\n-\t\t\t * messages on the terminal\
    \ */\n-\t\t\tsuccess =\n-\t\t\t\tg_spawn_command_line_sync (\n-\t\t\t\t      \
    \        comics_document->selected_command,\n-\t\t\t\t\t\t\t   &std_out, &std_err,\n\
    -\t\t\t\t\t\t\t   &retval, &err);\n-\t\t\tif (!success) {\n-\t\t\t\tg_propagate_error\
    \ (error, err);\n-\t\t\t\tg_error_free (err);\n-\t\t\t\treturn FALSE;\n-\t\t\t\
    /* I don't check retval status because RARLAB unrar\n-\t\t\t * doesn't have a\
    \ way to return 0 without involving an\n-\t\t\t * operation with a file*/\n-\t\
    \t\t} else if (WIFEXITED (retval)) {\n-\t\t\t\tif (g_strrstr (std_out,\"freeware\"\
    ) != NULL)\n-\t\t\t\t\t/* The RARLAB freeware client */\n-\t\t\t\t\tcomics_document->command_usage\
    \ = RARLABS;\n-\t\t\t\telse\n-\t\t\t\t\t/* The Gna! free software client */\n\
    -\t\t\t\t\tcomics_document->command_usage = GNAUNRAR;\n-\n-\t\t\t\tg_free (std_out);\n\
    -\t\t\t\tg_free (std_err);\n-\t\t\t\treturn TRUE;\n-\t\t\t}\n-\t\t}\n-\t\t/* The\
    \ Gna! free software client with Debian naming convention */\n-\t\tcomics_document->selected_command\
    \ =\n-\t\t\t\tg_find_program_in_path (\"unrar-free\");\n-\t\tif (comics_document->selected_command)\
    \ {\n-\t\t\tcomics_document->command_usage = GNAUNRAR;\n-\t\t\treturn TRUE;\n\
    -\t\t}\n-\t\tcomics_document->selected_command =\n-\t\t\t\tg_find_program_in_path\
    \ (\"lsar\");\n-\t\tif (comics_document->selected_command) {\n-\t\t\tcomics_document->command_usage\
    \ = UNARCHIVER;\n-\t\t\treturn TRUE;\n-\t\t}\n-\t\tcomics_document->selected_command\
    \ =\n-\t\t\t\tg_find_program_in_path (\"bsdtar\");\n-\t\tif (comics_document->selected_command)\
    \ {\n-\t\t\tcomics_document->command_usage = TAR;\n+\t\tif (ev_archive_set_archive_type\
    \ (comics_document->archive, EV_ARCHIVE_TYPE_RAR))\n \t\t\treturn TRUE;\n-\t\t\
    }\n-\n \t} else if (g_content_type_is_a (mime_type, \"application/x-cbz\") ||\n\
    \ \t\t   g_content_type_is_a (mime_type, \"application/zip\")) {\n-\t\t/* InfoZIP's\
    \ unzip program */\n-\t\tcomics_document->selected_command =\n-\t\t\t\tg_find_program_in_path\
    \ (\"unzip\");\n-\t\tcomics_document->alternative_command =\n-\t\t\t\tg_find_program_in_path\
    \ (\"zipnote\");\n-\t\tif (comics_document->selected_command &&\n-\t\t    comics_document->alternative_command)\
    \ {\n-\t\t\tcomics_document->command_usage = UNZIP;\n+\t\tif (ev_archive_set_archive_type\
    \ (comics_document->archive, EV_ARCHIVE_TYPE_ZIP))\n \t\t\treturn TRUE;\n-\t\t\
    }\n-\t\tcomics_document->selected_command =\n-\t\t\t\tg_find_program_in_path (\"\
    bsdtar\");\n-\t\tif (comics_document->selected_command) {\n-\t\t\tcomics_document->command_usage\
    \ = TAR;\n-\t\t\treturn TRUE;\n-\t\t}\n-\t\tcomics_document->selected_command\
    \ =\n-\t\t\t\tg_find_program_in_path (\"lsar\");\n-\t\tif (comics_document->selected_command)\
    \ {\n-\t\t\tcomics_document->command_usage = UNARCHIVER;\n-\t\t\treturn TRUE;\n\
    -\t\t}\n-\n \t} else if (g_content_type_is_a (mime_type, \"application/x-cb7\"\
    ) ||\n \t\t   g_content_type_is_a (mime_type, \"application/x-7z-compressed\"\
    )) {\n-\t\t/* 7zr, 7za and 7z are the commands from the p7zip project able\n-\t\
    \t * to decompress .7z files */\n-\t\tcomics_document->selected_command =\n-\t\
    \t\tg_find_program_in_path (\"7zr\");\n-\t\tif (comics_document->selected_command)\
    \ {\n-\t\t\tcomics_document->command_usage = P7ZIP;\n+\t\tif (ev_archive_set_archive_type\
    \ (comics_document->archive, EV_ARCHIVE_TYPE_7Z))\n \t\t\treturn TRUE;\n-\t\t\
    }\n-\t\tcomics_document->selected_command =\n-\t\t\tg_find_program_in_path (\"\
    7za\");\n-\t\tif (comics_document->selected_command) {\n-\t\t\tcomics_document->command_usage\
    \ = P7ZIP;\n-\t\t\treturn TRUE;\n-\t\t}\n-\t\tcomics_document->selected_command\
    \ =\n-\t\t\tg_find_program_in_path (\"7z\");\n-\t\tif (comics_document->selected_command)\
    \ {\n-\t\t\tcomics_document->command_usage = P7ZIP;\n-\t\t\treturn TRUE;\n-\t\t\
    }\n-\t\tcomics_document->selected_command =\n-\t\t\t\tg_find_program_in_path (\"\
    bsdtar\");\n-\t\tif (comics_document->selected_command) {\n-\t\t\tcomics_document->command_usage\
    \ = TAR;\n-\t\t\treturn TRUE;\n-\t\t}\n-\t\tcomics_document->selected_command\
    \ =\n-\t\t\t\tg_find_program_in_path (\"lsar\");\n-\t\tif (comics_document->selected_command)\
    \ {\n-\t\t\tcomics_document->command_usage = UNARCHIVER;\n-\t\t\treturn TRUE;\n\
    -\t\t}\n \t} else if (g_content_type_is_a (mime_type, \"application/x-cbt\") ||\n\
    \ \t\t   g_content_type_is_a (mime_type, \"application/x-tar\")) {\n-\t\t/* tar\
    \ utility (Tape ARchive) */\n-\t\tcomics_document->selected_command =\n-\t\t\t\
    \tg_find_program_in_path (\"tar\");\n-\t\tif (comics_document->selected_command)\
    \ {\n-\t\t\tcomics_document->command_usage = TAR;\n+\tif (ev_archive_set_archive_type\
    \ (comics_document->archive, EV_ARCHIVE_TYPE_TAR))\n \t\t\treturn TRUE;\n-\t\t\
    }\n-\t\tcomics_document->selected_command =\n-\t\t\t\tg_find_program_in_path (\"\
    bsdtar\");\n-\t\tif (comics_document->selected_command) {\n-\t\t\tcomics_document->command_usage\
    \ = TAR;\n-\t\t\treturn TRUE;\n-\t\t}\n-\t\tcomics_document->selected_command\
    \ =\n-\t\t\t\tg_find_program_in_path (\"lsar\");\n-\t\tif (comics_document->selected_command)\
    \ {\n-\t\t\tcomics_document->command_usage = UNARCHIVER;\n-\t\t\treturn TRUE;\n\
    -\t\t}\n \t} else {\n \t\tg_set_error (error,\n \t\t\t     EV_DOCUMENT_ERROR,\n\
    @@ -461,52 +325,25 @@ comics_check_decompress_command\t(gchar          *mime_type,\n\
    \ \tg_set_error_literal (error,\n \t\t\t     EV_DOCUMENT_ERROR,\n \t\t\t     EV_DOCUMENT_ERROR_INVALID,\n\
    -\t\t\t     _(\"Can't find an appropriate command to \"\n-\t\t\t     \"decompress\
    \ this type of comic book\"));\n+\t\t             _(\"libarchive lacks support\
    \ for this comic book\u2019s \"\n+\t\t\t     \"compression, please contact your\
    \ distributor\"));\n+\n \treturn FALSE;\n }\n \n static int\n sort_page_names\
    \ (gconstpointer a,\n                  gconstpointer b)\n {\n-\tconst char *name_1,\
    \ *name_2;\n-\tgchar *key_1, *key_2;\n-\tgboolean sort_last_1, sort_last_2;\n\
    -\tint compare;\n-\n-\tname_1 = * (const char **) a;\n-\tname_2 = * (const char\
    \ **) b;\n-\n-\t#define SORT_LAST_CHAR1 '.'\n-\t#define SORT_LAST_CHAR2 '#'\n\
    -\n-\tsort_last_1 = name_1[0] == SORT_LAST_CHAR1 || name_1[0] == SORT_LAST_CHAR2;\n\
    -\tsort_last_2 = name_2[0] == SORT_LAST_CHAR1 || name_2[0] == SORT_LAST_CHAR2;\n\
    -\n-\t#undef SORT_LAST_CHAR1\n-\t#undef SORT_LAST_CHAR2\n-\n-\tif (sort_last_1\
    \ && !sort_last_2)\n-\t{\n-\t\tcompare = +1;\n-\t}\n-\telse if (!sort_last_1 &&\
    \ sort_last_2)\n-\t{\n-\t\tcompare = -1;\n-\t}\n-\telse\n-\t{\n-\t\tkey_1 = g_utf8_collate_key_for_filename\
    \ (name_1, -1);\n-\t\tkey_2 = g_utf8_collate_key_for_filename (name_2, -1);\n\
    -\n-\t\tcompare = strcmp (key_1, key_2);\n-\n-\t\tg_free (key_1);\n-\t\tg_free\
    \ (key_2);\n-\t}\n-\n-\treturn compare;\n+\tgchar *temp1, *temp2;\n+\tgint ret;\n\
    +\ttemp1 = g_utf8_collate_key_for_filename (* (const char **) a, -1);\n+\ttemp2\
    \ = g_utf8_collate_key_for_filename (* (const char **) b, -1);\n+\tret = strcmp\
    \ (temp1, temp2);\n+\n+\tg_free (temp1);\n+\tg_free (temp2);\n+\treturn ret;\n\
    \ }\n \n static gboolean\n@@ -515,109 +352,40 @@ comics_document_load (EvDocument\
    \ *document,\n \t\t      GError    **error)\n {\n \tComicsDocument *comics_document\
    \ = COMICS_DOCUMENT (document);\n-\tGSList *supported_extensions;\n-\tgchar *std_out;\n\
    \ \tgchar *mime_type;\n-\tgchar **cb_files, *cb_file;\n-\tgboolean success;\n\
    -\tint i, retval;\n-\tGError *err = NULL;\n-\n-\tcomics_document->archive = g_filename_from_uri\
    \ (uri, NULL, error);\n-\tif (!comics_document->archive)\n-\t\treturn FALSE;\n\
    -\n-\tmime_type = ev_file_get_mime_type (uri, FALSE, &err);\n-\tif (!mime_type)\
    \ {\n-\t\tif (err) {\n-\t\t\tg_propagate_error (error, err);\n-\t\t} else {\n\
    -\t\t\tg_set_error_literal (error,\n-\t\t\t\t\t     EV_DOCUMENT_ERROR,\n-\t\t\t\
    \t\t     EV_DOCUMENT_ERROR_INVALID,\n-\t\t\t\t\t     _(\"Unknown MIME Type\"));\n\
    -\t\t}\n-\n-\t\treturn FALSE;\n-\t}\n-\n-\tif (!comics_check_decompress_command\
    \ (mime_type, comics_document,\n-\terror)) {\n-\t\tg_free (mime_type);\n-\t\t\
    return FALSE;\n-\t} else if (!comics_generate_command_lines (comics_document,\
    \ error)) {\n-\t\t   g_free (mime_type);\n-\t\treturn FALSE;\n-\t}\n+\tGFile *file;\n\
    +\tfile = g_file_new_for_uri (uri);\n+\tcomics_document->archive_path = g_file_get_path\
    \ (file);\n+\tg_object_unref (file);\n \n-\tg_free (mime_type);\n-\n-\t/* Get\
    \ list of files in archive */\n-\tsuccess = g_spawn_command_line_sync (comics_document->list_command,\n\
    -\t\t\t\t\t     &std_out, NULL, &retval, error);\n-\n-\tif (!success) {\n-\t\t\
    return FALSE;\n-\t} else if (!WIFEXITED(retval) || WEXITSTATUS(retval) != EXIT_SUCCESS)\
    \ {\n+\tif (!comics_document->archive_path) {\n \t\tg_set_error_literal (error,\n\
    \                                      EV_DOCUMENT_ERROR,\n                  \
    \                    EV_DOCUMENT_ERROR_INVALID,\n                            \
    \          _(\"File corrupted\"));\n \t\treturn FALSE;\n \t}\n \n-\t/* FIXME:\
    \ is this safe against filenames containing \\n in the archive ? */\n-\tcb_files\
    \ = g_strsplit (std_out, EV_EOL, 0);\n+\tcomics_document->archive_uri = g_strdup\
    \ (uri);\n+\tmime_type = ev_file_get_mime_type (uri, FALSE, error);\n \n-\tg_free\
    \ (std_out);\n+\tif (mime_type == NULL)\n+\t\treturn FALSE;\n \n-\tif (!cb_files)\
    \ {\n-\t\tg_set_error_literal (error,\n-\t\t\t\t     EV_DOCUMENT_ERROR,\n-\t\t\
    \t\t     EV_DOCUMENT_ERROR_INVALID,\n-\t\t\t\t     _(\"No files in archive\"));\n\
    +\tif (!comics_check_decompress_support (mime_type, comics_document, error)) {\n\
    +\t\tg_free (mime_type);\n \t\treturn FALSE;\n \t}\n \n-        comics_document->page_names\
    \ = g_ptr_array_sized_new (64);\n-\n-\tsupported_extensions = get_supported_image_extensions\
    \ ();\n-\tfor (i = 0; cb_files[i] != NULL; i++) {\n-\t\tif (comics_document->offset\
    \ != NO_OFFSET) {\n-\t\t\tif (g_utf8_strlen (cb_files[i],-1) >\n-\t\t\t    comics_document->offset)\
    \ {\n-\t\t\t\tcb_file =\n-\t\t\t\t\tg_utf8_offset_to_pointer (cb_files[i],\n-\t\
    \t\t\t\t\t       comics_document->offset);\n-\t\t\t} else {\n-\t\t\t\tcontinue;\n\
    -\t\t\t}\n-\t\t} else {\n-\t\t\tcb_file = cb_files[i];\n-\t\t}\n-\t\tgchar *suffix\
    \ = g_strrstr (cb_file, \".\");\n-\t\tif (!suffix)\n-\t\t\tcontinue;\n-\t\tsuffix\
    \ = g_ascii_strdown (suffix + 1, -1);\n-\t\tif (g_slist_find_custom (supported_extensions,\
    \ suffix,\n-\t\t\t\t\t (GCompareFunc) strcmp) != NULL) {\n-                  \
    \      g_ptr_array_add (comics_document->page_names,\n-                      \
    \                   g_strstrip (g_strdup (cb_file)));\n-\t\t}\n-\t\tg_free (suffix);\n\
    -\t}\n-\tg_strfreev (cb_files);\n-\tg_slist_foreach (supported_extensions, (GFunc)\
    \ g_free, NULL);\n-\tg_slist_free (supported_extensions);\n+\tg_free (mime_type);\n\
    \ \n-\tif (comics_document->page_names->len == 0) {\n-\t\tg_set_error (error,\n\
    -\t\t\t     EV_DOCUMENT_ERROR,\n-\t\t\t     EV_DOCUMENT_ERROR_INVALID,\n-\t\t\t\
    \     _(\"No images found in archive %s\"),\n-\t\t\t     uri);\n+\t/* Get list\
    \ of files in archive */\n+\tcomics_document->page_names = comics_document_list\
    \ (comics_document, error);\n+\tif (!comics_document->page_names)\n \t\treturn\
    \ FALSE;\n-\t}\n+\n+\t/* Keep an index */\n+\tcomics_document->page_positions\
    \ = save_positions (comics_document->page_names);\n \n         /* Now sort the\
    \ pages */\n         g_ptr_array_sort (comics_document->page_names, sort_page_names);\n\
    @@ -632,7 +400,7 @@ comics_document_save (EvDocument *document,\n {\n \tComicsDocument\
    \ *comics_document = COMICS_DOCUMENT (document);\n \n-\treturn ev_xfer_uri_simple\
    \ (comics_document->archive, uri, error);\n+\treturn ev_xfer_uri_simple (comics_document->archive_uri,\
    \ uri, error);\n }\n \n static int\n@@ -646,151 +414,182 @@ comics_document_get_n_pages\
    \ (EvDocument *document)\n \treturn comics_document->page_names->len;\n }\n \n\
    +typedef struct {\n+\tgboolean got_info;\n+\tint height;\n+\tint width;\n+} PixbufInfo;\n\
    +\n+static void\n+get_page_size_prepared_cb (GdkPixbufLoader *loader,\n+\t\t\t\
    \   int              width,\n+\t\t\t   int              height,\n+\t\t\t   PixbufInfo\
    \      *info)\n+{\n+\tinfo->got_info = TRUE;\n+\tinfo->height = height;\n+\tinfo->width\
    \ = width;\n+}\n+\n static void\n comics_document_get_page_size (EvDocument *document,\n\
    \ \t\t\t       EvPage     *page,\n \t\t\t       double     *width,\n \t\t\t  \
    \     double     *height)\n {\n \tGdkPixbufLoader *loader;\n-\tchar **argv;\n\
    -\tguchar buf[1024];\n-\tgboolean success, got_size = FALSE;\n-\tgint outpipe\
    \ = -1;\n-\tGPid child_pid;\n-\tgssize bytes;\n-\tGdkPixbuf *pixbuf;\n-\tgchar\
    \ *filename;\n+\n \tComicsDocument *comics_document = COMICS_DOCUMENT (document);\n\
    \ \n-\tif (!comics_document->decompress_tmp) {\n-\t\targv = extract_argv (document,\
    \ page->index);\n-\t\tsuccess = g_spawn_async_with_pipes (NULL, argv, NULL,\n\
    -\t\t\t\t\t\t    G_SPAWN_SEARCH_PATH |\n-\t\t\t\t\t\t    G_SPAWN_STDERR_TO_DEV_NULL,\n\
    -\t\t\t\t\t\t    NULL, NULL,\n-\t\t\t\t\t\t    &child_pid,\n-\t\t\t\t\t\t    NULL,\
    \ &outpipe, NULL, NULL);\n-\t\tg_strfreev (argv);\n-\t\tg_return_if_fail (success\
    \ == TRUE);\n-\n-\t\tloader = gdk_pixbuf_loader_new ();\n-\t\tg_signal_connect\
    \ (loader, \"area-prepared\",\n-\t\t\t\t  G_CALLBACK (get_page_size_area_prepared_cb),\n\
    -\t\t\t\t  &got_size);\n-\n-\t\twhile (outpipe >= 0) {\n-\t\t\tbytes = read (outpipe,\
    \ buf, 1024);\n-\n-\t\t\tif (bytes > 0)\n-\t\t\tgdk_pixbuf_loader_write (loader,\
    \ buf, bytes, NULL);\n-\t\t\tif (bytes <= 0 || got_size) {\n-\t\t\t\tclose (outpipe);\n\
    -\t\t\t\toutpipe = -1;\n-\t\t\t\tgdk_pixbuf_loader_close (loader, NULL);\n+\t\
    const char *page_path;\n+\tPixbufInfo info;\n+\tGError *error = NULL;\n+\n+\t\
    page_path = g_ptr_array_index (comics_document->page_names, page->index);\n+\n\
    +\tif (!archive_reopen_if_needed (comics_document, page_path, &error)) {\n+\t\t\
    g_warning (\"Fatal error opening archive: %s\", error->message);\n+\t\tg_error_free\
    \ (error);\n+\t\treturn;\n+\t}\n+\n+\tloader = gdk_pixbuf_loader_new ();\n+\t\
    info.got_info = FALSE;\n+\tg_signal_connect (loader, \"size-prepared\",\n+\t\t\
    \t  G_CALLBACK (get_page_size_prepared_cb),\n+\t\t\t  &info);\n+\n+\twhile (1)\
    \ {\n+\t\tconst char *name;\n+\t\tGError *error = NULL;\n+\n+\t\tif (!ev_archive_read_next_header\
    \ (comics_document->archive, &error)) {\n+\t\t\tif (error != NULL) {\n+\t\t\t\t\
    g_warning (\"Fatal error handling archive (%s): %s\", G_STRFUNC, error->message);\n\
    +\t\t\t\tg_error_free (error);\n \t\t\t}\n+\t\t\tbreak;\n \t\t}\n-\t\tpixbuf =\
    \ gdk_pixbuf_loader_get_pixbuf (loader);\n-\t\tif (pixbuf) {\n-\t\t\tif (width)\n\
    -\t\t\t\t*width = gdk_pixbuf_get_width (pixbuf);\n-\t\t\tif (height)\n-\t\t\t\t\
    *height = gdk_pixbuf_get_height (pixbuf);\n-\t\t}\n-\t\tg_spawn_close_pid (child_pid);\n\
    -\t\tg_object_unref (loader);\n-\t} else {\n-\t\tfilename = g_build_filename (comics_document->dir,\n\
    -                                             (char *) comics_document->page_names->pdata[page->index],\n\
    -\t\t\t\t\t     NULL);\n-\t\tpixbuf = gdk_pixbuf_new_from_file (filename, NULL);\n\
    -\t\tif (pixbuf) {\n-\t\t\tif (width)\n-\t\t\t\t*width = gdk_pixbuf_get_width\
    \ (pixbuf);\n-\t\t\tif (height)\n-\t\t\t\t*height = gdk_pixbuf_get_height (pixbuf);\n\
    -\t\t\tg_object_unref (pixbuf);\n+\n+\t\tname = ev_archive_get_entry_pathname\
    \ (comics_document->archive);\n+\t\tif (g_strcmp0 (name, page_path) == 0) {\n\
    +\t\t\tchar buf[BLOCK_SIZE];\n+\t\t\tgssize read;\n+\t\t\tgint64 left;\n+\n+\t\
    \t\tleft = ev_archive_get_entry_size (comics_document->archive);\n+\t\t\tread\
    \ = ev_archive_read_data (comics_document->archive, buf,\n+\t\t\t\t\t\t     MIN(BLOCK_SIZE,\
    \ left), &error);\n+\t\t\twhile (read > 0 && !info.got_info) {\n+\t\t\t\tif (!gdk_pixbuf_loader_write\
    \ (loader, (guchar *) buf, read, &error)) {\n+\t\t\t\t\tread = -1;\n+\t\t\t\t\t\
    break;\n+\t\t\t\t}\n+\t\t\t\tleft -= read;\n+\t\t\t\tread = ev_archive_read_data\
    \ (comics_document->archive, buf,\n+\t\t\t\t\t\t\t     MIN(BLOCK_SIZE, left),\
    \ &error);\n+\t\t\t}\n+\t\t\tif (read < 0) {\n+\t\t\t\tg_warning (\"Fatal error\
    \ reading '%s' in archive: %s\", name, error->message);\n+\t\t\t\tg_error_free\
    \ (error);\n+\t\t\t}\n+\t\t\tbreak;\n \t\t}\n-\t\tg_free (filename);\n+\t}\n+\n\
    +\tgdk_pixbuf_loader_close (loader, NULL);\n+\tg_object_unref (loader);\n+\n+\t\
    if (info.got_info) {\n+\t\tif (width)\n+\t\t\t*width = info.width;\n+\t\tif (height)\n\
    +\t\t\t*height = info.height;\n \t}\n }\n \n static void\n-get_page_size_area_prepared_cb\
    \ (GdkPixbufLoader *loader,\n-\t\t\t\tgpointer         data)\n+render_pixbuf_size_prepared_cb\
    \ (GdkPixbufLoader *loader,\n+\t\t\t\tgint             width,\n+\t\t\t\tgint \
    \            height,\n+\t\t\t\tEvRenderContext *rc)\n {\n-\tgboolean *got_size\
    \ = data;\n-\t*got_size = TRUE;\n+\t// int scaled_width, scaled_height;\n+\tdouble\
    \ scale = rc->scale;\n+\tint w = (width  * scale + 0.5);\n+\tint h = (height *\
    \ scale + 0.5);\n+\n+\t// ev_render_context_compute_scaled_size (rc, width, height,\
    \ &scaled_width, &scaled_height);\n+\tgdk_pixbuf_loader_set_size (loader, w, h);\n\
    \ }\n \n static GdkPixbuf *\n comics_document_render_pixbuf (EvDocument      *document,\n\
    \ \t\t\t       EvRenderContext *rc)\n {\n \tGdkPixbufLoader *loader;\n-\tGdkPixbuf\
    \ *rotated_pixbuf, *tmp_pixbuf;\n-\tchar **argv;\n-\tguchar buf[4096];\n-\tgboolean\
    \ success;\n-\tgint outpipe = -1;\n-\tGPid child_pid;\n-\tgssize bytes;\n-\tgint\
    \ width, height;\n-\tgchar *filename;\n+\tGdkPixbuf *tmp_pixbuf;\n+\tGdkPixbuf\
    \ *rotated_pixbuf = NULL;\n \tComicsDocument *comics_document = COMICS_DOCUMENT\
    \ (document);\n+\tconst char *page_path;\n+\tGError *error = NULL;\n+\n+\tpage_path\
    \ = g_ptr_array_index (comics_document->page_names, rc->page->index);\n+\n+\t\
    if (!archive_reopen_if_needed (comics_document, page_path, &error)) {\n+\t\tg_warning\
    \ (\"Fatal error opening archive: %s\", error->message);\n+\t\tg_error_free (error);\n\
    +\t\treturn NULL;\n+\t}\n \n-\tif (!comics_document->decompress_tmp) {\n-\t\t\
    argv = extract_argv (document, rc->page->index);\n-\t\tsuccess = g_spawn_async_with_pipes\
    \ (NULL, argv, NULL,\n-\t\t\t\t\t\t    G_SPAWN_SEARCH_PATH |\n-\t\t\t\t\t\t  \
    \  G_SPAWN_STDERR_TO_DEV_NULL,\n-\t\t\t\t\t\t    NULL, NULL,\n-\t\t\t\t\t\t  \
    \  &child_pid,\n-\t\t\t\t\t\t    NULL, &outpipe, NULL, NULL);\n-\t\tg_strfreev\
    \ (argv);\n-\t\tg_return_val_if_fail (success == TRUE, NULL);\n-\n-\t\tloader\
    \ = gdk_pixbuf_loader_new ();\n-\t\tg_signal_connect (loader, \"size-prepared\"\
    ,\n-\t\t\t\t  G_CALLBACK (render_pixbuf_size_prepared_cb),\n-\t\t\t\t  &rc->scale);\n\
    -\n-\t\twhile (outpipe >= 0) {\n-\t\t\tbytes = read (outpipe, buf, 4096);\n-\n\
    -\t\t\tif (bytes > 0) {\n-\t\t\t\tgdk_pixbuf_loader_write (loader, buf, bytes,\n\
    -\t\t\t\tNULL);\n+\tloader = gdk_pixbuf_loader_new ();\n+\tg_signal_connect (loader,\
    \ \"size-prepared\",\n+\t\t\t  G_CALLBACK (render_pixbuf_size_prepared_cb),\n\
    +\t\t\t  rc);\n+\n+\twhile (1) {\n+\t\tconst char *name;\n+\n+\t\tif (!ev_archive_read_next_header\
    \ (comics_document->archive, &error)) {\n+\t\t\tif (error != NULL) {\n+\t\t\t\t\
    g_warning (\"Fatal error handling archive (%s): %s\", G_STRFUNC, error->message);\n\
    +\t\t\t\tg_error_free (error);\n+\t\t\t}\n+\t\t\tbreak;\n+\t\t}\n+\n+\t\tname\
    \ = ev_archive_get_entry_pathname (comics_document->archive);\n+\t\tif (g_strcmp0\
    \ (name, page_path) == 0) {\n+\t\t\tsize_t size = ev_archive_get_entry_size (comics_document->archive);\n\
    +\t\t\tchar *buf;\n+\t\t\tssize_t read;\n+\n+\t\t\tbuf = g_malloc (size);\n+\t\
    \t\tread = ev_archive_read_data (comics_document->archive, buf, size, &error);\n\
    +\t\t\tif (read <= 0) {\n+\t\t\t\tif (read < 0) {\n+\t\t\t\t\tg_warning (\"Fatal\
    \ error reading '%s' in archive: %s\", name, error->message);\n+\t\t\t\t\tg_error_free\
    \ (error);\n+\t\t\t\t} else {\n+\t\t\t\t\tg_warning (\"Read an empty file from\
    \ the archive\");\n+\t\t\t\t}\n \t\t\t} else {\n-\t\t\t\tclose (outpipe);\n-\t\
    \t\t\tgdk_pixbuf_loader_close (loader, NULL);\n-\t\t\t\toutpipe = -1;\n+\t\t\t\
    \tgdk_pixbuf_loader_write (loader, (guchar *) buf, size, NULL);\n \t\t\t}\n+\t\
    \t\tg_free (buf);\n+\t\t\tgdk_pixbuf_loader_close (loader, NULL);\n+\t\t\tbreak;\n\
    \ \t\t}\n-\t\ttmp_pixbuf = gdk_pixbuf_loader_get_pixbuf (loader);\n-\t\trotated_pixbuf\
    \ =\n-\t\t\tgdk_pixbuf_rotate_simple (tmp_pixbuf,\n-\t\t\t\t\t\t  360 - rc->rotation);\n\
    -\t\tg_spawn_close_pid (child_pid);\n-\t\tg_object_unref (loader);\n-\t} else\
    \ {\n-\t\tfilename =\n-\t\t\tg_build_filename (comics_document->dir,\n-      \
    \                                    (char *) comics_document->page_names->pdata[rc->page->index],\n\
    -\t\t\t\t\t  NULL);\n-\n-\t\tgdk_pixbuf_get_file_info (filename, &width, &height);\n\
    -\n-\t\ttmp_pixbuf =\n-\t\t\tgdk_pixbuf_new_from_file_at_size (\n-\t\t\t\t   \
    \ filename, width * (rc->scale) + 0.5,\n-\t\t\t\t    height * (rc->scale) + 0.5,\
    \ NULL);\n-\t\trotated_pixbuf =\n-\t\t\tgdk_pixbuf_rotate_simple (tmp_pixbuf,\n\
    -\t\t\t\t\t\t  360 - rc->rotation);\n-\t\tg_free (filename);\n-\t\tg_object_unref\
    \ (tmp_pixbuf);\n \t}\n+\ttmp_pixbuf = gdk_pixbuf_loader_get_pixbuf (loader);\n\
    +\tif (tmp_pixbuf) {\n+\t\tif ((rc->rotation % 360) == 0)\n+\t\t\trotated_pixbuf\
    \ = g_object_ref (tmp_pixbuf);\n+\t\telse\n+\t\t\trotated_pixbuf = gdk_pixbuf_rotate_simple\
    \ (tmp_pixbuf,\n+\t\t\t\t\t\t\t\t   360 - rc->rotation);\n+\t}\n+\tg_object_unref\
    \ (loader);\n \treturn rotated_pixbuf;\n }\n \n@@ -802,79 +601,26 @@ comics_document_render\
    \ (EvDocument      *document,\n \tcairo_surface_t *surface;\n \n \tpixbuf = comics_document_render_pixbuf\
    \ (document, rc);\n+\tif (!pixbuf)\n+\t\treturn NULL;\n \tsurface = ev_document_misc_surface_from_pixbuf\
    \ (pixbuf);\n-\tg_object_unref (pixbuf);\n-\n+\tg_clear_object (&pixbuf);\n \t\
    return surface;\n }\n \n-static void\n-render_pixbuf_size_prepared_cb (GdkPixbufLoader\
    \ *loader,\n-\t\t\t\tgint             width,\n-\t\t\t\tgint             height,\n\
    -\t\t\t\tgpointer         data)\n-{\n-\tdouble *scale = data;\n-\tint w = (width\
    \  * (*scale) + 0.5);\n-\tint h = (height * (*scale) + 0.5);\n-\n-\tgdk_pixbuf_loader_set_size\
    \ (loader, w, h);\n-}\n-\n-/**\n- * comics_remove_dir: Removes a directory recursively.\n\
    - * Returns:\n- *   \t0 if it was successfully deleted,\n- * \t-1 if an error\
    \ occurred\n- */\n-static int\n-comics_remove_dir (gchar *path_name)\n-{\n-\t\
    GDir  *content_dir;\n-\tconst gchar *filename;\n-\tgchar *filename_with_path;\n\
    -\n-\tif (g_file_test (path_name, G_FILE_TEST_IS_DIR)) {\n-\t\tcontent_dir = g_dir_open\
    \  (path_name, 0, NULL);\n-\t\tfilename  = g_dir_read_name (content_dir);\n-\t\
    \twhile (filename) {\n-\t\t\tfilename_with_path =\n-\t\t\t\tg_build_filename (path_name,\n\
    -\t\t\t\t\t\t  filename, NULL);\n-\t\t\tcomics_remove_dir (filename_with_path);\n\
    -\t\t\tg_free (filename_with_path);\n-\t\t\tfilename = g_dir_read_name (content_dir);\n\
    -\t\t}\n-\t\tg_dir_close (content_dir);\n-\t}\n-\t/* Note from g_remove() documentation:\
    \ on Windows, it is in general not\n-\t * possible to remove a file that is open\
    \ to some process, or mapped\n-\t * into memory.*/\n-\treturn (g_remove (path_name));\n\
    -}\n-\n static void\n comics_document_finalize (GObject *object)\n {\n \tComicsDocument\
    \ *comics_document = COMICS_DOCUMENT (object);\n \n-\tif (comics_document->decompress_tmp)\
    \ {\n-\t\tif (comics_remove_dir (comics_document->dir) == -1)\n-\t\t\tg_warning\
    \ (_(\"There was an error deleting \u201C%s\u201D.\"),\n-\t\t\t\t   comics_document->dir);\n\
    -\t\tg_free (comics_document->dir);\n-\t}\n-\n \tif (comics_document->page_names)\
    \ {\n                 g_ptr_array_foreach (comics_document->page_names, (GFunc)\
    \ g_free, NULL);\n                 g_ptr_array_free (comics_document->page_names,\
    \ TRUE);\n \t}\n-\n-\tg_free (comics_document->archive);\n-\tg_free (comics_document->selected_command);\n\
    -\tg_free (comics_document->alternative_command);\n-\tg_free (comics_document->extract_command);\n\
    -\tg_free (comics_document->list_command);\n+\tg_clear_pointer (&comics_document->page_positions,\
    \ g_hash_table_destroy);\n+\tg_clear_object (&comics_document->archive);\n+\t\
    g_free (comics_document->archive_path);\n+\tg_free (comics_document->archive_uri);\n\
    \ \n \tG_OBJECT_CLASS (comics_document_parent_class)->finalize (object);\n }\n\
    @@ -897,33 +643,7 @@ comics_document_class_init (ComicsDocumentClass *klass)\n\
    \ static void\n comics_document_init (ComicsDocument *comics_document)\n {\n-\t\
    comics_document->archive = NULL;\n-\tcomics_document->page_names = NULL;\n-\t\
    comics_document->extract_command = NULL;\n-}\n-\n-/* Returns a list of file extensions\
    \ supported by gdk-pixbuf */\n-static GSList*\n-get_supported_image_extensions(void)\n\
    -{\n-\tGSList *extensions = NULL;\n-\tGSList *formats = gdk_pixbuf_get_formats\
    \ ();\n-\tGSList *l;\n-\n-\tfor (l = formats; l != NULL; l = l->next) {\n-\t\t\
    int i;\n-\t\tgchar **ext = gdk_pixbuf_format_get_extensions (l->data);\n-\n-\t\
    \tfor (i = 0; ext[i] != NULL; i++) {\n-\t\t\textensions = g_slist_append (extensions,\n\
    -\t\t\t\t\t\t     g_strdup (ext[i]));\n-\t\t}\n-\n-\t\tg_strfreev (ext);\n-\t\
    }\n-\n-\tg_slist_free (formats);\n-\treturn extensions;\n+\tcomics_document->archive\
    \ = ev_archive_new ();\n }\n \n static GdkPixbuf *\n@@ -971,48 +691,3 @@ comics_document_document_thumbnails_iface_init\
    \ (EvDocumentThumbnailsInterface *i\n \tiface->get_thumbnail = comics_document_thumbnails_get_thumbnail;\n\
    \ \tiface->get_dimensions = comics_document_thumbnails_get_dimensions;\n }\n-\n\
    -static char**\n-extract_argv (EvDocument *document, gint page)\n-{\n-\tComicsDocument\
    \ *comics_document = COMICS_DOCUMENT (document);\n-\tchar **argv;\n-\tchar *command_line,\
    \ *quoted_archive, *quoted_filename;\n-\tGError *err = NULL;\n-\n-\tif (g_strrstr\
    \ (comics_document->page_names->pdata[page], \"--checkpoint-action=\"))\n-\t{\n\
    -\t\tg_warning (\"File unsupported\\n\");\n-\t\tgtk_main_quit ();\n-\t}\n-\n-\
    \        if (page >= comics_document->page_names->len)\n-                return\
    \ NULL;\n-\n-\tif (comics_document->regex_arg) {\n-\t\tquoted_archive = g_shell_quote\
    \ (comics_document->archive);\n-\t\tquoted_filename =\n-\t\t\tcomics_regex_quote\
    \ (comics_document->page_names->pdata[page]);\n-\t} else {\n-\t\tquoted_archive\
    \ = g_shell_quote (comics_document->archive);\n-\t\tquoted_filename = g_shell_quote\
    \ (comics_document->page_names->pdata[page]);\n-\t}\n-\n-\tcommand_line = g_strdup_printf\
    \ (\"%s %s %s\",\n-\t\t\t\t\tcomics_document->extract_command,\n-\t\t\t\t\tquoted_archive,\n\
    -\t\t\t\t\tquoted_filename);\n-\tg_free (quoted_archive);\n-\tg_free (quoted_filename);\n\
    -\n-\tg_shell_parse_argv (command_line, NULL, &argv, &err);\n-\tg_free (command_line);\n\
    -\n-\tif (err) {\n-\t\tg_warning (_(\"Error %s\"), err->message);\n-\t\tg_error_free\
    \ (err);\n-\t\treturn NULL;\n-\t}\n-\n-\treturn argv;\n-}"
  - "--- a/backend/comics/ev-archive.c\n+++ b/backend/comics/ev-archive.c\n@@ -0,0\
    \ +1,323 @@\n+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: t; c-basic-offset:\
    \ 8; c-indent-level: 8 -*- */\n+/*\n+ * Copyright (C) 2017, Bastien Nocera <hadess@hadess.net>\n\
    + *\n+ * This program is free software; you can redistribute it and/or modify\n\
    + * it under the terms of the GNU General Public License as published by\n+ *\
    \ the Free Software Foundation; either version 2, or (at your option)\n+ * any\
    \ later version.\n+ *\n+ * This program is distributed in the hope that it will\
    \ be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty\
    \ of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ * GNU\
    \ General Public License for more details.\n+ *\n+ * You should have received\
    \ a copy of the GNU General Public License\n+ * along with this program; if not,\
    \ write to the Free Software\n+ * Foundation, Inc., 51 Franklin Street, Fifth\
    \ Floor, Boston, MA 02110-1301, USA.\n+ */\n+\n+#include \"config.h\"\n+#include\
    \ \"ev-archive.h\"\n+\n+#include <archive.h>\n+#include <archive_entry.h>\n+#include\
    \ <gio/gio.h>\n+\n+#define BUFFER_SIZE (64 * 1024)\n+\n+struct _EvArchive {\n\
    +\tGObject parent_instance;\n+\tEvArchiveType type;\n+\n+\t/* libarchive */\n\
    +\tstruct archive *libar;\n+\tstruct archive_entry *libar_entry;\n+};\n+\n+G_DEFINE_TYPE(EvArchive,\
    \ ev_archive, G_TYPE_OBJECT);\n+\n+static void\n+ev_archive_finalize (GObject\
    \ *object)\n+{\n+\tEvArchive *archive = EV_ARCHIVE (object);\n+\n+\tswitch (archive->type)\
    \ {\n+\tcase EV_ARCHIVE_TYPE_RAR:\n+\tcase EV_ARCHIVE_TYPE_ZIP:\n+\tcase EV_ARCHIVE_TYPE_7Z:\n\
    +\tcase EV_ARCHIVE_TYPE_TAR:\n+\t\tg_clear_pointer (&archive->libar, archive_free);\n\
    +\t\tbreak;\n+\tdefault:\n+\t\tbreak;\n+\t}\n+\n+\tG_OBJECT_CLASS (ev_archive_parent_class)->finalize\
    \ (object);\n+}\n+\n+static void\n+ev_archive_class_init (EvArchiveClass *klass)\n\
    +{\n+        GObjectClass *object_class = (GObjectClass *) klass;\n+\n+      \
    \  object_class->finalize = ev_archive_finalize;\n+}\n+\n+EvArchive *\n+ev_archive_new\
    \ (void)\n+{\n+\treturn g_object_new (EV_TYPE_ARCHIVE, NULL);\n+}\n+\n+static\
    \ void\n+libarchive_set_archive_type (EvArchive *archive,\n+\t\t\t     EvArchiveType\
    \ archive_type)\n+{\n+\tarchive->type = archive_type;\n+\tarchive->libar = archive_read_new\
    \ ();\n+\n+\tif (archive_type == EV_ARCHIVE_TYPE_ZIP)\n+\t\tarchive_read_support_format_zip\
    \ (archive->libar);\n+\telse if (archive_type == EV_ARCHIVE_TYPE_7Z)\n+\t\tarchive_read_support_format_7zip\
    \ (archive->libar);\n+\telse if (archive_type == EV_ARCHIVE_TYPE_TAR)\n+\t\tarchive_read_support_format_tar\
    \ (archive->libar);\n+\telse if (archive_type == EV_ARCHIVE_TYPE_RAR) {\n+\t\t\
    archive_read_support_format_rar (archive->libar);\n+\t\tarchive_read_support_format_rar5\
    \ (archive->libar);\n+\t} else\n+\t\tg_assert_not_reached ();\n+}\n+\n+EvArchiveType\n\
    +ev_archive_get_archive_type (EvArchive *archive)\n+{\n+\tg_return_val_if_fail\
    \ (EV_IS_ARCHIVE (archive), EV_ARCHIVE_TYPE_NONE);\n+\n+\treturn archive->type;\n\
    +}\n+\n+gboolean\n+ev_archive_set_archive_type (EvArchive *archive,\n+\t\t\t \
    \    EvArchiveType archive_type)\n+{\n+\tg_return_val_if_fail (EV_IS_ARCHIVE (archive),\
    \ FALSE);\n+\tg_return_val_if_fail (archive->type == EV_ARCHIVE_TYPE_NONE, FALSE);\n\
    +\n+\tswitch (archive_type) {\n+\tcase EV_ARCHIVE_TYPE_RAR:\n+\tcase EV_ARCHIVE_TYPE_ZIP:\n\
    +\tcase EV_ARCHIVE_TYPE_7Z:\n+\tcase EV_ARCHIVE_TYPE_TAR:\n+\t\tlibarchive_set_archive_type\
    \ (archive, archive_type);\n+\t\tbreak;\n+\tdefault:\n+\t\tg_assert_not_reached\
    \ ();\n+\t}\n+\n+\treturn TRUE;\n+}\n+\n+gboolean\n+ev_archive_open_filename (EvArchive\
    \   *archive,\n+\t\t\t  const char  *path,\n+\t\t\t  GError     **error)\n+{\n\
    +\tint r;\n+\n+\tg_return_val_if_fail (EV_IS_ARCHIVE (archive), FALSE);\n+\tg_return_val_if_fail\
    \ (archive->type != EV_ARCHIVE_TYPE_NONE, FALSE);\n+\tg_return_val_if_fail (path\
    \ != NULL, FALSE);\n+\n+\tswitch (archive->type) {\n+\tcase EV_ARCHIVE_TYPE_NONE:\n\
    +\t\tg_assert_not_reached ();\n+\tcase EV_ARCHIVE_TYPE_RAR:\n+\tcase EV_ARCHIVE_TYPE_ZIP:\n\
    +\tcase EV_ARCHIVE_TYPE_7Z:\n+\tcase EV_ARCHIVE_TYPE_TAR:\n+\t\tr = archive_read_open_filename\
    \ (archive->libar, path, BUFFER_SIZE);\n+\t\tif (r != ARCHIVE_OK) {\n+\t\t\tg_set_error\
    \ (error, G_IO_ERROR, G_IO_ERROR_FAILED,\n+\t\t\t\t     \"Error opening archive:\
    \ %s\", archive_error_string (archive->libar));\n+\t\t\treturn FALSE;\n+\t\t}\n\
    +\t\treturn TRUE;\n+\t}\n+\n+\treturn FALSE;\n+}\n+\n+static gboolean\n+libarchive_read_next_header\
    \ (EvArchive *archive,\n+\t\t\t     GError   **error)\n+{\n+\twhile (1) {\n+\t\
    \tint r;\n+\n+\t\tr = archive_read_next_header (archive->libar, &archive->libar_entry);\n\
    +\t\tif (r != ARCHIVE_OK) {\n+\t\t\tif (r != ARCHIVE_EOF)\n+\t\t\t\tg_set_error\
    \ (error, G_IO_ERROR, G_IO_ERROR_FAILED,\n+\t\t\t\t\t     \"Error reading archive:\
    \ %s\", archive_error_string (archive->libar));\n+\t\t\treturn FALSE;\n+\t\t}\n\
    +\n+\t\tif (archive_entry_filetype (archive->libar_entry) != AE_IFREG) {\n+\t\t\
    \tg_debug (\"Skipping '%s' as it's not a regular file\",\n+\t\t\t\t archive_entry_pathname\
    \ (archive->libar_entry));\n+\t\t\tcontinue;\n+\t\t}\n+\n+\t\tg_debug (\"At header\
    \ for file '%s'\", archive_entry_pathname (archive->libar_entry));\n+\n+\t\tbreak;\n\
    +\t}\n+\n+\treturn TRUE;\n+}\n+\n+gboolean\n+ev_archive_read_next_header (EvArchive\
    \ *archive,\n+\t\t\t     GError   **error)\n+{\n+\tg_return_val_if_fail (EV_IS_ARCHIVE\
    \ (archive), FALSE);\n+\tg_return_val_if_fail (archive->type != EV_ARCHIVE_TYPE_NONE,\
    \ FALSE);\n+\n+\tswitch (archive->type) {\n+\tcase EV_ARCHIVE_TYPE_NONE:\n+\t\t\
    g_assert_not_reached ();\n+\tcase EV_ARCHIVE_TYPE_RAR:\n+\tcase EV_ARCHIVE_TYPE_ZIP:\n\
    +\tcase EV_ARCHIVE_TYPE_7Z:\n+\tcase EV_ARCHIVE_TYPE_TAR:\n+\t\treturn libarchive_read_next_header\
    \ (archive, error);\n+\t}\n+\n+\treturn FALSE;\n+}\n+\n+gboolean\n+ev_archive_at_entry\
    \ (EvArchive *archive)\n+{\n+\tg_return_val_if_fail (EV_IS_ARCHIVE (archive),\
    \ FALSE);\n+\tg_return_val_if_fail (archive->type != EV_ARCHIVE_TYPE_NONE, FALSE);\n\
    +\n+\treturn (archive->libar_entry != NULL);\n+}\n+\n+const char *\n+ev_archive_get_entry_pathname\
    \ (EvArchive *archive)\n+{\n+\tg_return_val_if_fail (EV_IS_ARCHIVE (archive),\
    \ NULL);\n+\tg_return_val_if_fail (archive->type != EV_ARCHIVE_TYPE_NONE, NULL);\n\
    +\n+\tswitch (archive->type) {\n+\tcase EV_ARCHIVE_TYPE_NONE:\n+\t\tg_assert_not_reached\
    \ ();\n+\tcase EV_ARCHIVE_TYPE_RAR:\n+\tcase EV_ARCHIVE_TYPE_ZIP:\n+\tcase EV_ARCHIVE_TYPE_7Z:\n\
    +\tcase EV_ARCHIVE_TYPE_TAR:\n+\t\tg_return_val_if_fail (archive->libar_entry\
    \ != NULL, NULL);\n+\t\treturn archive_entry_pathname (archive->libar_entry);\n\
    +\t}\n+\n+\treturn NULL;\n+}\n+\n+gint64\n+ev_archive_get_entry_size (EvArchive\
    \ *archive)\n+{\n+\tg_return_val_if_fail (EV_IS_ARCHIVE (archive), -1);\n+\tg_return_val_if_fail\
    \ (archive->type != EV_ARCHIVE_TYPE_NONE, -1);\n+\n+\tswitch (archive->type) {\n\
    +\tcase EV_ARCHIVE_TYPE_NONE:\n+\t\tg_assert_not_reached ();\n+\tcase EV_ARCHIVE_TYPE_RAR:\n\
    +\tcase EV_ARCHIVE_TYPE_ZIP:\n+\tcase EV_ARCHIVE_TYPE_7Z:\n+\tcase EV_ARCHIVE_TYPE_TAR:\n\
    +\t\tg_return_val_if_fail (archive->libar_entry != NULL, -1);\n+\t\treturn archive_entry_size\
    \ (archive->libar_entry);\n+\t}\n+\n+\treturn -1;\n+}\n+\n+gboolean\n+ev_archive_get_entry_is_encrypted\
    \ (EvArchive *archive)\n+{\n+\tg_return_val_if_fail (EV_IS_ARCHIVE (archive),\
    \ FALSE);\n+\tg_return_val_if_fail (archive->type != EV_ARCHIVE_TYPE_NONE, FALSE);\n\
    +\n+\tswitch (archive->type) {\n+\tcase EV_ARCHIVE_TYPE_NONE:\n+\t\tg_assert_not_reached\
    \ ();\n+\tcase EV_ARCHIVE_TYPE_RAR:\n+\tcase EV_ARCHIVE_TYPE_ZIP:\n+\tcase EV_ARCHIVE_TYPE_7Z:\n\
    +\tcase EV_ARCHIVE_TYPE_TAR:\n+\t\tg_return_val_if_fail (archive->libar_entry\
    \ != NULL, -1);\n+\t\treturn archive_entry_is_encrypted (archive->libar_entry);\n\
    +\t}\n+\n+\treturn FALSE;\n+}\n+\n+gssize\n+ev_archive_read_data (EvArchive *archive,\n\
    +\t\t      void      *buf,\n+\t\t      gsize      count,\n+\t\t      GError  \
    \ **error)\n+{\n+\tgssize r = -1;\n+\n+\tg_return_val_if_fail (EV_IS_ARCHIVE (archive),\
    \ -1);\n+\tg_return_val_if_fail (archive->type != EV_ARCHIVE_TYPE_NONE, -1);\n\
    +\n+\tswitch (archive->type) {\n+\tcase EV_ARCHIVE_TYPE_NONE:\n+\t\tg_assert_not_reached\
    \ ();\n+\tcase EV_ARCHIVE_TYPE_RAR:\n+\tcase EV_ARCHIVE_TYPE_ZIP:\n+\tcase EV_ARCHIVE_TYPE_7Z:\n\
    +\tcase EV_ARCHIVE_TYPE_TAR:\n+\t\tg_return_val_if_fail (archive->libar_entry\
    \ != NULL, -1);\n+\t\tr = archive_read_data (archive->libar, buf, count);\n+\t\
    \tif (r < 0) {\n+\t\t\tg_set_error (error, G_IO_ERROR, G_IO_ERROR_FAILED,\n+\t\
    \t\t\t     \"Failed to decompress data: %s\", archive_error_string (archive->libar));\n\
    +\t\t}\n+\t\tbreak;\n+\t}\n+\n+\treturn r;\n+}\n+\n+void\n+ev_archive_reset (EvArchive\
    \ *archive)\n+{\n+\tg_return_if_fail (EV_IS_ARCHIVE (archive));\n+\tg_return_if_fail\
    \ (archive->type != EV_ARCHIVE_TYPE_NONE);\n+\n+\tswitch (archive->type) {\n+\t\
    case EV_ARCHIVE_TYPE_RAR:\n+\tcase EV_ARCHIVE_TYPE_ZIP:\n+\tcase EV_ARCHIVE_TYPE_7Z:\n\
    +\tcase EV_ARCHIVE_TYPE_TAR:\n+\t\tg_clear_pointer (&archive->libar, archive_free);\n\
    +\t\tlibarchive_set_archive_type (archive, archive->type);\n+\t\tarchive->libar_entry\
    \ = NULL;\n+\t\tbreak;\n+\tdefault:\n+\t\tg_assert_not_reached ();\n+\t}\n+}\n\
    +\n+static void\n+ev_archive_init (EvArchive *archive)\n+{\n+}"
  identifiers: CVE:["CVE-2023-51698"],CWE:["CWE-78"]
  overview: Affected versions of this package are vulnerable to OS Command Injection
    via the processing of a maliciously crafted CBT document which is a TAR archive.
    An attacker can gain immediate access to the target system when the target user
    opens the crafted document or clicks on a crafted link/URL.
  references:
    GitHub Commit: https://github.com/mate-desktop/atril/commit/ce41df6467521ff9fd4f16514ae7d6ebb62eb1ed
  title: OS Command Injection
- diff_content:
  - "--- a/drivers/input/input.c\n+++ b/drivers/input/input.c\n@@ -47,6 +47,17 @@\
    \ static DEFINE_MUTEX(input_mutex);\n \n static const struct input_value input_value_sync\
    \ = { EV_SYN, SYN_REPORT, 1 };\n \n+static const unsigned int input_max_code[EV_CNT]\
    \ = {\n+\t[EV_KEY] = KEY_MAX,\n+\t[EV_REL] = REL_MAX,\n+\t[EV_ABS] = ABS_MAX,\n\
    +\t[EV_MSC] = MSC_MAX,\n+\t[EV_SW] = SW_MAX,\n+\t[EV_LED] = LED_MAX,\n+\t[EV_SND]\
    \ = SND_MAX,\n+\t[EV_FF] = FF_MAX,\n+};\n+\n static inline int is_event_supported(unsigned\
    \ int code,\n \t\t\t\t     unsigned long *bm, unsigned int max)\n {\n@@ -2110,6\
    \ +2121,14 @@ EXPORT_SYMBOL(input_get_timestamp);\n  */\n void input_set_capability(struct\
    \ input_dev *dev, unsigned int type, unsigned int code)\n {\n+\tif (type < EV_CNT\
    \ && input_max_code[type] &&\n+\t    code > input_max_code[type]) {\n+\t\tpr_err(\"\
    %s: invalid code %u for type %u\\n\", __func__, code,\n+\t\t       type);\n+\t\
    \tdump_stack();\n+\t\treturn;\n+\t}\n+\n \tswitch (type) {\n \tcase EV_KEY:\n\
    \ \t\t__set_bit(code, dev->keybit);"
  identifiers: CVE:["CVE-2022-48619"],CWE:["CWE-400"]
  overview: Affected versions of this package are vulnerable to Uncontrolled Resource
    Consumption ('Resource Exhaustion') due to an event code falling outside of a
    bitmap in `input_set_capability`, leading to a system panic. An attacker can cause
    a denial of service by triggering this condition.
  references:
    ChangeLog: https://cdn.kernel.org/pub/linux/kernel/v5.x/ChangeLog-5.17.10
    GitHub Commit: https://github.com/torvalds/linux/commit/409353cbe9fe48f6bc196114c442b1cff05a39bc
    RedHat Bugzilla Bug: https://bugzilla.redhat.com/show_bug.cgi?id=2258012
  title: Uncontrolled Resource Consumption ('Resource Exhaustion')
- diff_content:
  - "--- a/block/blk-cgroup.c\n+++ b/block/blk-cgroup.c\n@@ -34,6 +34,8 @@\n #include\
    \ \"blk-ioprio.h\"\n #include \"blk-throttle.h\"\n \n+static void __blkcg_rstat_flush(struct\
    \ blkcg *blkcg, int cpu);\n+\n /*\n  * blkcg_pol_mutex protects blkcg_policy[]\
    \ and policy [de]activation.\n  * blkcg_pol_register_mutex nests outside of it\
    \ and synchronizes entire\n@@ -56,6 +58,8 @@ static LIST_HEAD(all_blkcgs);\t\t\
    /* protected by blkcg_pol_mutex */\n \n bool blkcg_debug_stats = false;\n \n+static\
    \ DEFINE_RAW_SPINLOCK(blkg_stat_lock);\n+\n #define BLKG_DESTROY_BATCH_SIZE  64\n\
    \ \n /*\n@@ -163,10 +167,20 @@ static void blkg_free(struct blkcg_gq *blkg)\n\
    \ static void __blkg_release(struct rcu_head *rcu)\n {\n \tstruct blkcg_gq *blkg\
    \ = container_of(rcu, struct blkcg_gq, rcu_head);\n+\tstruct blkcg *blkcg = blkg->blkcg;\n\
    +\tint cpu;\n \n #ifdef CONFIG_BLK_CGROUP_PUNT_BIO\n \tWARN_ON(!bio_list_empty(&blkg->async_bios));\n\
    \ #endif\n+\t/*\n+\t * Flush all the non-empty percpu lockless lists before releasing\n\
    +\t * us, given these stat belongs to us.\n+\t *\n+\t * blkg_stat_lock is for\
    \ serializing blkg stat update\n+\t */\n+\tfor_each_possible_cpu(cpu)\n+\t\t__blkcg_rstat_flush(blkcg,\
    \ cpu);\n \n \t/* release the blkcg and parent blkg refs this blkg has been holding\
    \ */\n \tcss_put(&blkg->blkcg->css);\n@@ -951,23 +965,26 @@ static void blkcg_iostat_update(struct\
    \ blkcg_gq *blkg, struct blkg_iostat *cur,\n \tu64_stats_update_end_irqrestore(&blkg->iostat.sync,\
    \ flags);\n }\n \n-static void blkcg_rstat_flush(struct cgroup_subsys_state *css,\
    \ int cpu)\n+static void __blkcg_rstat_flush(struct blkcg *blkcg, int cpu)\n {\n\
    -\tstruct blkcg *blkcg = css_to_blkcg(css);\n \tstruct llist_head *lhead = per_cpu_ptr(blkcg->lhead,\
    \ cpu);\n \tstruct llist_node *lnode;\n \tstruct blkg_iostat_set *bisc, *next_bisc;\n\
    \ \n-\t/* Root-level stats are sourced from system-wide IO stats */\n-\tif (!cgroup_parent(css->cgroup))\n\
    -\t\treturn;\n-\n \trcu_read_lock();\n \n \tlnode = llist_del_all(lhead);\n \t\
    if (!lnode)\n \t\tgoto out;\n \n+\t/*\n+\t * For covering concurrent parent blkg\
    \ update from blkg_release().\n+\t *\n+\t * When flushing from cgroup, cgroup_rstat_lock\
    \ is always held, so\n+\t * this lock won't cause contention most of time.\n+\t\
    \ */\n+\traw_spin_lock(&blkg_stat_lock);\n+\n \t/*\n \t * Iterate only the iostat_cpu's\
    \ queued in the lockless list.\n \t */\n@@ -991,13 +1008,19 @@ static void blkcg_rstat_flush(struct\
    \ cgroup_subsys_state *css, int cpu)\n \t\tif (parent && parent->parent)\n \t\t\
    \tblkcg_iostat_update(parent, &blkg->iostat.cur,\n \t\t\t\t\t    &blkg->iostat.last);\n\
    -\t\tpercpu_ref_put(&blkg->refcnt);\n \t}\n-\n+\traw_spin_unlock(&blkg_stat_lock);\n\
    \ out:\n \trcu_read_unlock();\n }\n \n+static void blkcg_rstat_flush(struct cgroup_subsys_state\
    \ *css, int cpu)\n+{\n+\t/* Root-level stats are sourced from system-wide IO stats\
    \ */\n+\tif (cgroup_parent(css->cgroup))\n+\t\t__blkcg_rstat_flush(css_to_blkcg(css),\
    \ cpu);\n+}\n+\n /*\n  * We source root cgroup stats from the system-wide stats\
    \ to avoid\n  * tracking the same information twice and incurring overhead when\
    \ no\n@@ -2075,7 +2098,6 @@ void blk_cgroup_bio_start(struct bio *bio)\n \n \t\
    \tllist_add(&bis->lnode, lhead);\n \t\tWRITE_ONCE(bis->lqueued, true);\n-\t\t\
    percpu_ref_get(&bis->blkg->refcnt);\n \t}\n \n \tu64_stats_update_end_irqrestore(&bis->sync,\
    \ flags);"
  identifiers: CVE:["CVE-2024-0443"],CWE:["CWE-402"]
  overview: Affected versions of this package are vulnerable to Transmission of Private
    Resources into a New Sphere ('Resource Leak') due to improper handling in the
    `blk-cgroup.c` destruction path. An attacker with local access can cause system
    instability, such as an out of memory error, by exploiting the circular dependency
    that prevents `blkcg` and some `blkgs` from being freed after they are made offline.
  references:
    GitHub Commit: https://github.com/torvalds/linux/commit/20cb1c2fb7568a6054c55defe044311397e01ddb
    RedHat Bugzilla Bug: https://bugzilla.redhat.com/show_bug.cgi?id=2257968
    Vulnerability Advisory: https://lore.kernel.org/linux-block/20221215033132.230023-3-longman@redhat.com/
  title: Transmission of Private Resources into a New Sphere ('Resource Leak')
- diff_content:
  - "--- a/net/netfilter/nf_tables_api.c\n+++ b/net/netfilter/nf_tables_api.c\n@@\
    \ -1072,6 +1072,30 @@ static int nft_objname_hash_cmp(struct rhashtable_compare_arg\
    \ *arg,\n \treturn strcmp(obj->key.name, k->name);\n }\n \n+static bool nft_supported_family(u8\
    \ family)\n+{\n+\treturn false\n+#ifdef CONFIG_NF_TABLES_INET\n+\t\t|| family\
    \ == NFPROTO_INET\n+#endif\n+#ifdef CONFIG_NF_TABLES_IPV4\n+\t\t|| family == NFPROTO_IPV4\n\
    +#endif\n+#ifdef CONFIG_NF_TABLES_ARP\n+\t\t|| family == NFPROTO_ARP\n+#endif\n\
    +#ifdef CONFIG_NF_TABLES_NETDEV\n+\t\t|| family == NFPROTO_NETDEV\n+#endif\n+#if\
    \ IS_ENABLED(CONFIG_NF_TABLES_BRIDGE)\n+\t\t|| family == NFPROTO_BRIDGE\n+#endif\n\
    +#ifdef CONFIG_NF_TABLES_IPV6\n+\t\t|| family == NFPROTO_IPV6\n+#endif\n+\t\t\
    ;\n+}\n+\n static int nf_tables_newtable(struct sk_buff *skb, const struct nfnl_info\
    \ *info,\n \t\t\t      const struct nlattr * const nla[])\n {\n@@ -1086,6 +1110,9\
    \ @@ static int nf_tables_newtable(struct sk_buff *skb, const struct nfnl_info\
    \ *info,\n \tu32 flags = 0;\n \tint err;\n \n+\tif (!nft_supported_family(family))\n\
    +\t\treturn -EOPNOTSUPP;\n+\n \tlockdep_assert_held(&nft_net->commit_mutex);\n\
    \ \tattr = nla[NFTA_TABLE_NAME];\n \ttable = nft_table_lookup(net, attr, family,\
    \ genmask,"
  identifiers: CVE:["CVE-2023-6040"],CWE:["CWE-125"]
  overview: Affected versions of this package are vulnerable to Out-of-bounds Read
    due to improper validation of user-supplied input within the `nf_tables_newtable`
    function. An attacker with local access can read sensitive information or cause
    a system crash by sending crafted input to create a netfilter table with an invalid
    family value.
  references:
    GitHub Commit: https://github.com/torvalds/linux/commit/f1082dd31fe461d482d69da2a8eccfeb7bf07ac2
    RedHat Bugzilla Bug: https://bugzilla.redhat.com/show_bug.cgi?id=2258013
  title: Out-of-bounds Read
- diff_content:
  - "--- a/src/uev.c\n+++ b/src/uev.c\n@@ -196,11 +196,11 @@ int uev_init(uev_ctx_t\
    \ *ctx)\n /**\n  * Create an event loop context\n  * @param ctx       Pointer\
    \ to an uev_ctx_t context to be initialized\n- * @param maxevents Maximum number\
    \ of events in event cache\n+ * @param maxevents Maximum number of events in event\
    \ cache [1, 10]\n  *\n  * This function is the same as uev_init() except for the\
    \ @p maxevents\n- * argument, which controls the number of events in the event\
    \ cache\n- * returned to the main loop.\n+ * argument, max ::UEV_MAX_EVENTS, which\
    \ controls the number of events\n+ * in the event cache returned to the main loop.\n\
    \  *\n  * In cases where you have multiple events pending in the cache and some\n\
    \  * event may cause later ones, already sent by the kernel to userspace,\n@@\
    \ -222,6 +222,9 @@ int uev_init1(uev_ctx_t *ctx, int maxevents)\n \t\treturn -1;\n\
    \ \t}\n \n+\tif (maxevents > UEV_MAX_EVENTS)\n+\t\tmaxevents = UEV_MAX_EVENTS;\n\
    +\n \tmemset(ctx, 0, sizeof(*ctx));\n \tctx->maxevents = maxevents;\n \n@@ -319,8\
    \ +322,12 @@ int uev_run(uev_ctx_t *ctx, int flags)\n \n \twhile (ctx->running\
    \ && ctx->watchers) {\n \t\tstruct epoll_event ee[UEV_MAX_EVENTS];\n+\t\tint maxevents\
    \ = ctx->maxevents;\n \t\tint i, nfds, rerun = 0;\n \n+\t\tif (maxevents > UEV_MAX_EVENTS)\n\
    +\t\t\tmaxevents = UEV_MAX_EVENTS;\n+\n \t\t/* Handle special case: `application\
    \ < file.txt` */\n \t\tif (ctx->workaround) {\n \t\t\t_UEV_FOREACH(w, ctx->watchers)\
    \ {\n@@ -341,7 +348,7 @@ int uev_run(uev_ctx_t *ctx, int flags)\n \t\t\tcontinue;\n\
    \ \t\tctx->workaround = 0;\n \n-\t\twhile ((nfds = epoll_wait(ctx->fd, ee, ctx->maxevents,\
    \ timeout)) < 0) {\n+\t\twhile ((nfds = epoll_wait(ctx->fd, ee, maxevents, timeout))\
    \ < 0) {\n \t\t\tif (!ctx->running)\n \t\t\t\tbreak;\n "
  identifiers: CVE:["CVE-2022-48620"],CWE:["CWE-120"]
  overview: Affected versions of this package are vulnerable to Buffer Overflow due
    to improper handling of the `maxevents` parameter in the `epoll_wait` function.
    An attacker can execute arbitrary code or crash the application by providing a
    `maxevents` > 10 value.
  references:
    GitHub Commit: https://github.com/troglobit/libuev/commit/2d9f1c9ce655cc38511aeeb6e95ac30914f7aec9
    GitHub Issue: https://github.com/troglobit/libuev/issues/27
  title: Buffer Overflow
- diff_content:
  - "--- a/src/filters/reframe_ac3.c\n+++ b/src/filters/reframe_ac3.c\n@@ -480,12\
    \ +480,11 @@ GF_Err ac3dmx_process(GF_Filter *filter)\n \t\t\tcts = GF_FILTER_NO_TS;\n\
    \ \t\t}\n \n-\t\tif (!ctx->in_seek && remain >= ctx->hdr.framesize) {\n+\t\tif\
    \ (!ctx->in_seek && remain >= sync_pos + ctx->hdr.framesize) {\n \t\t\tdst_pck\
    \ = gf_filter_pck_new_alloc(ctx->opid, ctx->hdr.framesize, &output);\n \t\t\t\
    if (!dst_pck) return GF_OUT_OF_MEM;\n \n \t\t\tif (ctx->src_pck) gf_filter_pck_merge_properties(ctx->src_pck,\
    \ dst_pck);\n-\n \t\t\tmemcpy(output, sync, ctx->hdr.framesize);\n \t\t\tgf_filter_pck_set_dts(dst_pck,\
    \ ctx->cts);\n \t\t\tgf_filter_pck_set_cts(dst_pck, ctx->cts);"
  identifiers: CVE:["CVE-2024-0322"],CWE:["CWE-122"]
  overview: Affected versions of this package are vulnerable to Heap-based Buffer
    Overflow in ac3dmx_process at filters/reframe_ac3.c:489.
  references:
    GitHub Commit: https://github.com/gpac/gpac/commit/092904b80edbc4dce315684a59cc3184c45c1b70
  title: Heap-based Buffer Overflow
- diff_content:
  - "--- a/fs/exec.c\n+++ b/fs/exec.c\n@@ -1304,6 +1304,9 @@ int begin_new_exec(struct\
    \ linux_binprm * bprm)\n \tbprm->mm = NULL;\n \n #ifdef CONFIG_POSIX_TIMERS\n\
    +\tspin_lock_irq(&me->sighand->siglock);\n+\tposix_cpu_timers_exit(me);\n+\tspin_unlock_irq(&me->sighand->siglock);\n\
    \ \texit_itimers(me);\n \tflush_itimer_signals();\n #endif"
  identifiers: CVE:["CVE-2022-2585"],CWE:["CWE-416"]
  overview: Affected versions of this package are vulnerable to Use After Free due
    to improper handling of POSIX CPU timers during the execution process from a non-leader
    thread. An attacker can cause a denial of service or potentially execute arbitrary
    code by triggering a use-after-free condition.
  references:
    GitHub Commit: https://github.com/torvalds/linux/commit/e362359ace6f87c201531872486ff295df306d13
    OSS Security Advisory: https://www.openwall.com/lists/oss-security/2022/08/09/7
  title: Use After Free
- diff_content:
  - "--- a/net/socket.c\n+++ b/net/socket.c\n@@ -450,7 +450,9 @@ static struct file_system_type\
    \ sock_fs_type = {\n  *\n  *\tReturns the &file bound with @sock, implicitly storing\
    \ it\n  *\tin sock->file. If dname is %NULL, sets to \"\".\n- *\tOn failure the\
    \ return is a ERR pointer (see linux/err.h).\n+ *\n+ *\tOn failure @sock is released,\
    \ and an ERR pointer is returned.\n+ *\n  *\tThis function uses GFP_KERNEL internally.\n\
    \  */\n \n@@ -1638,7 +1640,6 @@ static struct socket *__sys_socket_create(int\
    \ family, int type, int protocol)\n struct file *__sys_socket_file(int family,\
    \ int type, int protocol)\n {\n \tstruct socket *sock;\n-\tstruct file *file;\n\
    \ \tint flags;\n \n \tsock = __sys_socket_create(family, type, protocol);\n@@\
    \ -1649,11 +1650,7 @@ struct file *__sys_socket_file(int family, int type, int\
    \ protocol)\n \tif (SOCK_NONBLOCK != O_NONBLOCK && (flags & SOCK_NONBLOCK))\n\
    \ \t\tflags = (flags & ~SOCK_NONBLOCK) | O_NONBLOCK;\n \n-\tfile = sock_alloc_file(sock,\
    \ flags, NULL);\n-\tif (IS_ERR(file))\n-\t\tsock_release(sock);\n-\n-\treturn\
    \ file;\n+\treturn sock_alloc_file(sock, flags, NULL);\n }\n \n int __sys_socket(int\
    \ family, int type, int protocol)"
  identifiers: CVE:["CVE-2023-1032"],CWE:["CWE-415"]
  overview: Affected versions of this package are vulnerable to Double Free via the
    `__sys_socket_file` function in the `net/socket.c` file. An attacker can cause
    a denial of service or potentially execute arbitrary code by triggering a double
    free condition.
  references:
    GitHub Commit: https://github.com/torvalds/linux/commit/649c15c7691e9b13cbe9bf6c65c365350e056067
    OSS Security Advisory: https://www.openwall.com/lists/oss-security/2023/03/13/2
  title: Double Free
- diff_content:
  - "--- a/kernel/bpf/verifier.c\n+++ b/kernel/bpf/verifier.c\n@@ -11003,30 +11003,28\
    \ @@ static int fixup_bpf_calls(struct bpf_verifier_env *env)\n \t\t    insn->code\
    \ == (BPF_ALU | BPF_MOD | BPF_X) ||\n \t\t    insn->code == (BPF_ALU | BPF_DIV\
    \ | BPF_X)) {\n \t\t\tbool is64 = BPF_CLASS(insn->code) == BPF_ALU64;\n-\t\t\t\
    struct bpf_insn mask_and_div[] = {\n-\t\t\t\tBPF_MOV32_REG(insn->src_reg, insn->src_reg),\n\
    +\t\t\tbool isdiv = BPF_OP(insn->code) == BPF_DIV;\n+\t\t\tstruct bpf_insn *patchlet;\n\
    +\t\t\tstruct bpf_insn chk_and_div[] = {\n \t\t\t\t/* Rx div 0 -> 0 */\n-\t\t\t\
    \tBPF_JMP_IMM(BPF_JNE, insn->src_reg, 0, 2),\n+\t\t\t\tBPF_RAW_INSN((is64 ? BPF_JMP\
    \ : BPF_JMP32) |\n+\t\t\t\t\t     BPF_JNE | BPF_K, insn->src_reg,\n+\t\t\t\t\t\
    \     0, 2, 0),\n \t\t\t\tBPF_ALU32_REG(BPF_XOR, insn->dst_reg, insn->dst_reg),\n\
    \ \t\t\t\tBPF_JMP_IMM(BPF_JA, 0, 0, 1),\n \t\t\t\t*insn,\n \t\t\t};\n-\t\t\tstruct\
    \ bpf_insn mask_and_mod[] = {\n-\t\t\t\tBPF_MOV32_REG(insn->src_reg, insn->src_reg),\n\
    +\t\t\tstruct bpf_insn chk_and_mod[] = {\n \t\t\t\t/* Rx mod 0 -> Rx */\n-\t\t\
    \t\tBPF_JMP_IMM(BPF_JEQ, insn->src_reg, 0, 1),\n+\t\t\t\tBPF_RAW_INSN((is64 ?\
    \ BPF_JMP : BPF_JMP32) |\n+\t\t\t\t\t     BPF_JEQ | BPF_K, insn->src_reg,\n+\t\
    \t\t\t\t     0, 1, 0),\n \t\t\t\t*insn,\n \t\t\t};\n-\t\t\tstruct bpf_insn *patchlet;\n\
    \ \n-\t\t\tif (insn->code == (BPF_ALU64 | BPF_DIV | BPF_X) ||\n-\t\t\t    insn->code\
    \ == (BPF_ALU | BPF_DIV | BPF_X)) {\n-\t\t\t\tpatchlet = mask_and_div + (is64\
    \ ? 1 : 0);\n-\t\t\t\tcnt = ARRAY_SIZE(mask_and_div) - (is64 ? 1 : 0);\n-\t\t\t\
    } else {\n-\t\t\t\tpatchlet = mask_and_mod + (is64 ? 1 : 0);\n-\t\t\t\tcnt = ARRAY_SIZE(mask_and_mod)\
    \ - (is64 ? 1 : 0);\n-\t\t\t}\n+\t\t\tpatchlet = isdiv ? chk_and_div : chk_and_mod;\n\
    +\t\t\tcnt = isdiv ? ARRAY_SIZE(chk_and_div) :\n+\t\t\t\t      ARRAY_SIZE(chk_and_mod);\n\
    \ \n \t\t\tnew_prog = bpf_patch_insn_data(env, i + delta, patchlet, cnt);\n \t\
    \t\tif (!new_prog)"
  identifiers: CVE:["CVE-2021-3600"],CWE:["CWE-787"]
  overview: Affected versions of this package are vulnerable to Out-of-bounds Write
    due to improper bounds checking in the eBPF implementation when handling 32-bit
    register `div` and `mod` operations. An attacker can execute arbitrary code by
    exploiting insufficient validation of user-supplied input.
  references:
    GitHub Commit: https://github.com/torvalds/linux/commit/e88b2c6e5a4d9ce30d75391e4d950da74bb2bd90
  title: Out-of-bounds Write
- diff_content:
  - "--- a/src/amqpvalue.c\n+++ b/src/amqpvalue.c\n@@ -5912,7 +5912,17 @@ static int\
    \ internal_decoder_decode_bytes(INTERNAL_DECODER_DATA* internal_decoder\n    \
    \                         }\n                             else\n             \
    \                {\n-                                internal_decoder_data->decode_to_value->value.binary_value.bytes\
    \ = (unsigned char*)malloc((size_t)internal_decoder_data->decode_to_value->value.binary_value.length\
    \ + 1);\n+                                size_t malloc_size = (size_t)internal_decoder_data->decode_to_value->value.binary_value.length\
    \ + 1;\n+                                if (malloc_size == 0)\n+            \
    \                    {\n+                                    internal_decoder_data->decode_to_value->value.binary_value.bytes\
    \ = NULL;\n+                                    LogError(\"Invalid binary_value\
    \ size exceeded max allocation\");\n+                                }\n+    \
    \                            else\n+                                {\n+     \
    \                               internal_decoder_data->decode_to_value->value.binary_value.bytes\
    \ = (unsigned char*)malloc(malloc_size);\n+                                }\n\
    +\n                                 if (internal_decoder_data->decode_to_value->value.binary_value.bytes\
    \ == NULL)\n                                 {\n                             \
    \        /* Codes_SRS_AMQPVALUE_01_326: [If any allocation failure occurs during\
    \ decoding, amqpvalue_decode_bytes shall fail and return a non-zero value.] */"
  identifiers: CVE:["CVE-2024-21646"],CWE:["CWE-94"]
  overview: Affected versions of this package are vulnerable to Improper Control of
    Generation of Code ('Code Injection') when clients process a crafted binary type
    data. An attacker can execute arbitrary code on the target system by exploiting
    an integer overflow or wraparound or memory safety issue caused by the crafted
    data.
  references:
    GitHub Commit: https://github.com/Azure/azure-uamqp-c/commit/12ddb3a31a5a97f55b06fa5d74c59a1d84ad78fe
  title: Improper Control of Generation of Code ('Code Injection')
- diff_content:
  - "--- a/src/media_tools/av_parsers.c\n+++ b/src/media_tools/av_parsers.c\n@@ -1635,7\
    \ +1635,7 @@ static u32 av1_uvlc(GF_BitStream *bs, const char *fname)\n {\n \t\
    u32 res;\n \tu8 leadingZeros = 0;\n-\twhile (1) {\n+\twhile (gf_bs_available(bs))\
    \ {\n \t\tBool done = gf_bs_read_int(bs, 1);\n \t\tif (done)\n \t\t\tbreak;"
  identifiers: CVE:["CVE-2023-50120"],CWE:["CWE-835"]
  overview: Affected versions of this package are vulnerable to Infinite Loop due
    to an infinite loop in the `av1_uvlc` function. An attacker can cause a system
    to become unresponsive by providing a specially crafted MP4 file.
  references:
    GitHub Commit: https://github.com/gpac/gpac/commit/b655955b840ccd7c7198bb15375aa510e76208eb
    GitHub Issue: https://github.com/gpac/gpac/issues/2698
  title: Infinite Loop
- diff_content:
  - "--- a/src/filters/load_text.c\n+++ b/src/filters/load_text.c\n@@ -377,6 +377,10\
    \ @@ char *gf_text_get_utf8_line(char *szLine, u32 lineSize, FILE *txt_in, s32\
    \ unicod\n \t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_PARSER, (\"[TXTIn] Line too long\
    \ to convert to utf8 (len: %d)\\n\", len));\n \t\t\tj = GF_ARRAY_LENGTH(szLineConv)\
    \ -1 ;\n \t\t}\n+\t\tif ( j >= lineSize ) {\n+\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_PARSER,\
    \ (\"[TXTIn] UT8 converted line too long for buffer (len: %d, buffer: %d)\\n\"\
    , j, lineSize));\n+\t\t\tj = lineSize-1 ;\n+\t\t}\n \t\tszLineConv[j] = 0;\n \t\
    \tstrcpy(szLine, szLineConv);\n \t\treturn sOK;"
  identifiers: CVE:["CVE-2024-0321"],CWE:["CWE-121"]
  overview: Affected versions of this package are vulnerable to Stack-based Buffer
    Overflow due to improper bounds checking on user-supplied data. An attacker can
    cause a buffer overflow and potentially execute arbitrary code or disrupt service
    by supplying crafted input to the affected function.
  references:
    GitHub Commit: https://github.com/gpac/gpac/commit/d0ced41651b279bb054eb6390751e2d4eb84819a
  title: Stack-based Buffer Overflow
- diff_content:
  - "--- a/src/sds.c\n+++ b/src/sds.c\n@@ -348,20 +348,22 @@ sds sdsResize(sds s,\
    \ size_t size, int would_regrow) {\n      * type. */\n     int use_realloc = (oldtype==type\
    \ || (type < oldtype && type > SDS_TYPE_8));\n     size_t newlen = use_realloc\
    \ ? oldhdrlen+size+1 : hdrlen+size+1;\n-    int alloc_already_optimal = 0;\n-\
    \    #if defined(USE_JEMALLOC)\n-        /* je_nallocx returns the expected allocation\
    \ size for the newlen.\n-         * We aim to avoid calling realloc() when using\
    \ Jemalloc if there is no\n-         * change in the allocation size, as it incurs\
    \ a cost even if the\n-         * allocation size stays the same. */\n-      \
    \  alloc_already_optimal = (je_nallocx(newlen, 0) == zmalloc_size(sh));\n-   \
    \ #endif\n-\n-    if (use_realloc && !alloc_already_optimal) {\n-        newsh\
    \ = s_realloc(sh, newlen);\n-        if (newsh == NULL) return NULL;\n-      \
    \  s = (char*)newsh+oldhdrlen;\n-    } else if (!alloc_already_optimal) {\n+\n\
    +    if (use_realloc) {\n+        int alloc_already_optimal = 0;\n+        #if\
    \ defined(USE_JEMALLOC)\n+            /* je_nallocx returns the expected allocation\
    \ size for the newlen.\n+             * We aim to avoid calling realloc() when\
    \ using Jemalloc if there is no\n+             * change in the allocation size,\
    \ as it incurs a cost even if the\n+             * allocation size stays the same.\
    \ */\n+            alloc_already_optimal = (je_nallocx(newlen, 0) == zmalloc_size(sh));\n\
    +        #endif\n+        if (!alloc_already_optimal) {\n+            newsh =\
    \ s_realloc(sh, newlen);\n+            if (newsh == NULL) return NULL;\n+    \
    \        s = (char*)newsh+oldhdrlen;\n+        }\n+    } else {\n         newsh\
    \ = s_malloc(newlen);\n         if (newsh == NULL) return NULL;\n         memcpy((char*)newsh+hdrlen,\
    \ s, len);"
  identifiers: CVE:["CVE-2023-41056"],CWE:["CWE-122"]
  overview: Affected versions of this package are vulnerable to Heap-based Buffer
    Overflow due to improper handling of memory allocation. An attacker can execute
    arbitrary code by sending specially crafted requests to the affected service.
  references:
    GitHub Commit: https://github.com/redis/redis/commit/e351099e1119fb89496be578f5232c61ce300224
    RedHat Bugzilla Bug: https://bugzilla.redhat.com/show_bug.cgi?id=2257454
  title: Heap-based Buffer Overflow
- diff_content:
  - "--- a/net/bluetooth/af_bluetooth.c\n+++ b/net/bluetooth/af_bluetooth.c\n@@ -309,11\
    \ +309,14 @@ int bt_sock_recvmsg(struct socket *sock, struct msghdr *msg, size_t\
    \ len,\n \tif (flags & MSG_OOB)\n \t\treturn -EOPNOTSUPP;\n \n+\tlock_sock(sk);\n\
    +\n \tskb = skb_recv_datagram(sk, flags, &err);\n \tif (!skb) {\n \t\tif (sk->sk_shutdown\
    \ & RCV_SHUTDOWN)\n-\t\t\treturn 0;\n+\t\t\terr = 0;\n \n+\t\trelease_sock(sk);\n\
    \ \t\treturn err;\n \t}\n \n@@ -343,6 +346,8 @@ int bt_sock_recvmsg(struct socket\
    \ *sock, struct msghdr *msg, size_t len,\n \n \tskb_free_datagram(sk, skb);\n\
    \ \n+\trelease_sock(sk);\n+\n \tif (flags & MSG_TRUNC)\n \t\tcopied = skblen;\n\
    \ "
  identifiers: CVE:["CVE-2023-51779"],CWE:["CWE-362"]
  overview: Affected versions of this package are vulnerable to Race Condition between
    the `bt_sock_recvmsg` and `bt_sock_ioctl` functions. An attacker can cause a denial
    of service condition or potentially execute arbitrary code by exploiting the use-after-free
    condition on a socket buffer ("skb").
  references:
    GitHub Commit: https://github.com/torvalds/linux/commit/2e07e8348ea454615e268222ae3fc240421be768
    RedHat Bugzilla Bug: https://bugzilla.redhat.com/show_bug.cgi?id=2256822
  title: Race Condition
- diff_content:
  - "--- a/deflate.c\n+++ b/deflate.c\n@@ -1137,7 +1137,7 @@ static uint32_t longest_match(deflate_state\
    \ *s, IPos cur_match /* current match\n     register uint8_t *scan = s->window\
    \ + s->strstart; /* current string */\n     register uint8_t *match;         \
    \                 /* matched string */\n     register int len;               \
    \                  /* length of current match */\n-    int best_len = s->prev_length;\
    \                    /* best match length so far */\n+    int best_len = (s->prev_length\
    \ == 0) ? ACTUAL_MIN_MATCH-1 : s->prev_length;                    /* best match\
    \ length so far */\n     int nice_match = s->nice_match;                   /*\
    \ stop if match long enough */\n     IPos limit = s->strstart > (IPos)MAX_DIST(s)\
    \ ?\n         s->strstart - (IPos)MAX_DIST(s) : NIL;\n@@ -1467,8 +1467,8 @@ static\
    \ block_state deflate_stored(deflate_state *s, int flush)\n     uint64_t max_block_size\
    \ = 0xffff;\n     uint64_t max_start;\n \n-    if (max_block_size > s->pending_buf_size\
    \ - 5) {\n-        max_block_size = s->pending_buf_size - 5;\n+    if (max_block_size\
    \ > s->pending_buf_size - 6) {\n+        max_block_size = s->pending_buf_size\
    \ - 6;\n     }\n \n     /* Copy as much as possible from input to output: */\n\
    @@ -1688,7 +1688,7 @@ static block_state deflate_slow(deflate_state *s, int flush)\
    \ {\n                 insert_cnt = max_insert - s->strstart;\n \n            \
    \ bulk_insert_str(s, s->strstart + 1, insert_cnt);\n-            s->prev_length\
    \ = 0;\n+            s->prev_length = ACTUAL_MIN_MATCH-1;\n             s->match_available\
    \ = 0;\n             s->match_length = ACTUAL_MIN_MATCH-1;\n             s->strstart\
    \ += mov_fwd + 1;"
  identifiers: CVE:["CVE-2023-6992"],CWE:["CWE-20"]
  overview: Affected versions of this package are vulnerable to Improper Input Validation
    in the `deflate` algorithm. A local attacker could exploit the problem during
    compression using a crafted malicious file potentially leading to denial of service
    of the software.
  references:
    GitHub Commit: https://github.com/cloudflare/zlib/commit/8352d108c05db1bdc5ac3bdf834dad641694c13c
  title: Improper Input Validation
- diff_content:
  - "--- a/src/media_tools/av_parsers.c\n+++ b/src/media_tools/av_parsers.c\n@@ -6865,6\
    \ +6865,9 @@ GF_Err gf_avc_change_vui(GF_AVCConfig *avcc, GF_VUIInfo *vui_info)\n\
    \ \tGF_AVCConfigSlot *slc;\n \torig = NULL;\n \n+\tif (!avcc)\n+\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\
    +\n \tmemset(&avc, 0, sizeof(AVCState));\n \tavc.sps_active_idx = -1;\n "
  identifiers: CVE:["CVE-2023-46929"],CWE:["CWE-248"]
  overview: Affected versions of this package are vulnerable to Uncontrolled Resource
    Consumption ('Resource Exhaustion') via the `gf_avc_change_vui` function in `av_parsers.c`.
    An attacker can cause the application to crash by triggering a specific condition
    in the function.
  references:
    GitHub Commit: https://github.com/gpac/gpac/commit/4248def5d24325aeb0e35cacde3d56c9411816a6
    GitHub Issue: https://github.com/gpac/gpac/issues/2662
  title: Uncontrolled Resource Consumption ('Resource Exhaustion')
- diff_content:
  - "--- a/src/amf/gmm-sm.c\n+++ b/src/amf/gmm-sm.c\n@@ -1716,6 +1716,39 @@ void gmm_state_authentication(ogs_fsm_t\
    \ *s, amf_event_t *e)\n             END\n             break;\n \n+        CASE(OGS_SBI_SERVICE_NAME_NUDM_UECM)\n\
    +            if (sbi_message->res_status != OGS_SBI_HTTP_STATUS_CREATED &&\n+\
    \                sbi_message->res_status != OGS_SBI_HTTP_STATUS_NO_CONTENT &&\n\
    +                sbi_message->res_status != OGS_SBI_HTTP_STATUS_OK) {\n+     \
    \           ogs_error(\"[%s] HTTP response error [%d]\",\n+                  \
    \      amf_ue->supi, sbi_message->res_status);\n+            }\n+\n+         \
    \   SWITCH(sbi_message->h.resource.component[1])\n+            CASE(OGS_SBI_RESOURCE_NAME_REGISTRATIONS)\n\
    +                SWITCH(sbi_message->h.method)\n+                CASE(OGS_SBI_HTTP_METHOD_PUT)\n\
    +                    /*\n+                     * Issue #2733\n+              \
    \       *\n+                     * We need to ignore this message in this state.\n\
    +                     */\n+                    ogs_error(\"[%s] Ignore SBI message\"\
    , amf_ue->supi);\n+                    break;\n+                DEFAULT\n+   \
    \                 ogs_error(\"[%s] Invalid HTTP method [%s]\",\n+            \
    \                amf_ue->suci, sbi_message->h.method);\n+                    ogs_assert_if_reached();\n\
    +                END\n+                break;\n+\n+            DEFAULT\n+    \
    \            ogs_error(\"Invalid resource name [%s]\",\n+                    \
    \    sbi_message->h.resource.component[1]);\n+                ogs_assert_if_reached();\n\
    +            END\n+            break;\n+\n         DEFAULT\n             ogs_error(\"\
    Invalid service name [%s]\", sbi_message->h.service.name);\n             ogs_assert_if_reached();"
  identifiers: CVE:["CVE-2023-50019"],CWE:["CWE-755"]
  overview: Affected versions of this package are vulnerable to Improper Handling
    of Exceptional Conditions due to improper error handling in the `gmm_state_authentication`
    function in `/src/amf/gmm-sm.c` file. An attacker can cause the `AMF` to crash
    by sending an `InitialUEMessage` and a `Registration` request at a specific time.
  references:
    GitHub Commit: https://github.com/open5gs/open5gs/commit/7278714133422cee46c32c7523f81ec2cecad9e2
    GitHub Issue: https://github.com/open5gs/open5gs/issues/2733
  title: Improper Handling of Exceptional Conditions
- diff_content:
  - "--- a/lib/core/ogs-epoll.c\n+++ b/lib/core/ogs-epoll.c\n@@ -254,6 +254,7 @@ static\
    \ int epoll_process(ogs_pollset_t *pollset, ogs_time_t timeout)\n            \
    \ }\n             if (received & EPOLLRDHUP) {\n                 when |= OGS_POLLIN;\n\
    +                when &= ~OGS_POLLOUT;\n             }\n         }\n "
  identifiers: CVE:["CVE-2023-50020"],CWE:["CWE-400"]
  overview: Affected versions of this package are vulnerable to Uncontrolled Resource
    Consumption ('Resource Exhaustion') via the handling of `SIGPIPE` signals. An
    attacker can could cause the core network `AMF` to crash.
  references:
    GitHub Commit: https://github.com/open5gs/open5gs/commit/4739198c5d8887807ed95c3d2de62a1000b7f1c9
    GitHub Issue: https://github.com/open5gs/open5gs/issues/2734
    commons-fileupload:commons-fileupload: SNYK-JAVA-COMMONSFILEUPLOAD-30082
    npm <code>ws</code> package: https://snyk.io/vuln/npm:ws:20171108
  title: Uncontrolled Resource Consumption ('Resource Exhaustion')
- diff_content:
  - "--- a/net/netfilter/nf_tables_api.c\n+++ b/net/netfilter/nf_tables_api.c\n@@\
    \ -9887,7 +9887,7 @@ static void nft_set_commit_update(struct list_head *set_update_list)\n\
    \ \tlist_for_each_entry_safe(set, next, set_update_list, pending_update) {\n \t\
    \tlist_del_init(&set->pending_update);\n \n-\t\tif (!set->ops->commit)\n+\t\t\
    if (!set->ops->commit || set->dead)\n \t\t\tcontinue;\n \n \t\tset->ops->commit(set);"
  identifiers: CVE:["CVE-2024-0193"],CWE:["CWE-416"]
  overview: Affected versions of this package are vulnerable to Use After Free in
    the `nft_trans_gc_catchall_sync` function. An attacker can escalate privileges
    if the attacker has local access and can execute code.
  references:
    GitHub Commit: https://github.com/torvalds/linux/commit/7315dc1e122c85ffdfc8defffbb8f8b616c2eb1a
    RedHat Bugzilla Bug: https://bugzilla.redhat.com/show_bug.cgi?id=2255653
  title: Use After Free
- diff_content:
  - "--- a/src/decode_r2007.c\n+++ b/src/decode_r2007.c\n@@ -798,6 +798,12 @@ read_data_section\
    \ (Bit_Chain *sec_dat, Bit_Chain *dat,\n   for (i = 0; i < (int)section->num_pages;\
    \ i++)\n     {\n       r2007_section_page *section_page = section->pages[i];\n\
    +      if (!section_page)\n+        {\n+          free (decomp);\n+          LOG_ERROR\
    \ (\"Failed to find section page %d\", (int)i)\n+          return DWG_ERR_PAGENOTFOUND;\n\
    +        }\n       page = get_page (pages_map, section_page->id);\n       if (page\
    \ == NULL)\n         {\n@@ -954,12 +960,11 @@ read_sections_map (Bit_Chain *dat,\
    \ int64_t size_comp, int64_t size_uncomp,\n       LOG_TRACE (\"\\n\")\n      \
    \ section->type = dwg_section_wtype (section->name);\n \n-      if (section->num_pages\
    \ <= 0)\n-        continue;\n-      if (section->num_pages > 0xf0000)\n+     \
    \ if (section->num_pages <= 0 || section->num_pages > 0xf0000)\n         {\n \
    \          LOG_ERROR (\"Invalid num_pages %zu, skip\",\n                     \
    \ (size_t)section->num_pages);\n+          section->num_pages = 0;\n         \
    \  continue;\n         }\n "
  identifiers: CVE:["CVE-2023-26157"],CWE:["CWE-400"]
  overview: Affected versions of this package are vulnerable to Denial of Service
    (DoS) due to an out-of-bounds read involving `section->num_pages` in `decode_r2007.c`.
  references:
    GitHub Commit: https://github.com/LibreDWG/libredwg/commit/c8cf03ce4c2315b146caf582ea061c0460193bcc
    GitHub Issue: https://github.com/LibreDWG/libredwg/issues/850
    commons-fileupload:commons-fileupload: SNYK-JAVA-COMMONSFILEUPLOAD-30082
    npm <code>ws</code> package: https://snyk.io/vuln/npm:ws:20171108
  title: Denial of Service (DoS)
- diff_content:
  - "--- a/core/iwasm/interpreter/wasm_loader.c\n+++ b/core/iwasm/interpreter/wasm_loader.c\n\
    @@ -5476,6 +5476,7 @@ wasm_loader_pop_frame_ref(WASMLoaderContext *ctx, uint8\
    \ type, char *error_buf,\n     return true;\n }\n \n+#if WASM_ENABLE_FAST_INTERP\
    \ == 0\n static bool\n wasm_loader_push_pop_frame_ref(WASMLoaderContext *ctx,\
    \ uint8 pop_cnt,\n                                uint8 type_push, uint8 type_pop,\
    \ char *error_buf,\n@@ -5490,6 +5491,7 @@ wasm_loader_push_pop_frame_ref(WASMLoaderContext\
    \ *ctx, uint8 pop_cnt,\n         return false;\n     return true;\n }\n+#endif\n\
    \ \n static bool\n wasm_loader_push_frame_csp(WASMLoaderContext *ctx, uint8 label_type,\n\
    @@ -6166,27 +6168,6 @@ wasm_loader_pop_frame_offset(WASMLoaderContext *ctx, uint8\
    \ type,\n     return true;\n }\n \n-static bool\n-wasm_loader_push_pop_frame_offset(WASMLoaderContext\
    \ *ctx, uint8 pop_cnt,\n-                                  uint8 type_push, uint8\
    \ type_pop,\n-                                  bool disable_emit, int16 operand_offset,\n\
    -                                  char *error_buf, uint32 error_buf_size)\n-{\n\
    -    uint8 i;\n-\n-    for (i = 0; i < pop_cnt; i++) {\n-        if (!wasm_loader_pop_frame_offset(ctx,\
    \ type_pop, error_buf,\n-                                          error_buf_size))\n\
    -            return false;\n-    }\n-    if (!wasm_loader_push_frame_offset(ctx,\
    \ type_push, disable_emit,\n-                                       operand_offset,\
    \ error_buf,\n-                                       error_buf_size))\n-    \
    \    return false;\n-\n-    return true;\n-}\n-\n static bool\n wasm_loader_push_frame_ref_offset(WASMLoaderContext\
    \ *ctx, uint8 type,\n                                   bool disable_emit, int16\
    \ operand_offset,\n@@ -6220,12 +6201,24 @@ wasm_loader_push_pop_frame_ref_offset(WASMLoaderContext\
    \ *ctx, uint8 pop_cnt,\n                                       bool disable_emit,\
    \ int16 operand_offset,\n                                       char *error_buf,\
    \ uint32 error_buf_size)\n {\n-    if (!wasm_loader_push_pop_frame_offset(ctx,\
    \ pop_cnt, type_push, type_pop,\n-                                           disable_emit,\
    \ operand_offset,\n-                                           error_buf, error_buf_size))\n\
    +    uint8 i;\n+\n+    for (i = 0; i < pop_cnt; i++) {\n+        if (!wasm_loader_pop_frame_offset(ctx,\
    \ type_pop, error_buf,\n+                                          error_buf_size))\n\
    +            return false;\n+\n+        if (!wasm_loader_pop_frame_ref(ctx, type_pop,\
    \ error_buf,\n+                                       error_buf_size))\n+    \
    \        return false;\n+    }\n+\n+    if (!wasm_loader_push_frame_offset(ctx,\
    \ type_push, disable_emit,\n+                                       operand_offset,\
    \ error_buf,\n+                                       error_buf_size))\n     \
    \    return false;\n-    if (!wasm_loader_push_pop_frame_ref(ctx, pop_cnt, type_push,\
    \ type_pop,\n-                                        error_buf, error_buf_size))\n\
    +\n+    if (!wasm_loader_push_frame_ref(ctx, type_push, error_buf, error_buf_size))\n\
    \         return false;\n \n     return true;"
  - "--- a/core/iwasm/interpreter/wasm_mini_loader.c\n+++ b/core/iwasm/interpreter/wasm_mini_loader.c\n\
    @@ -3937,6 +3937,7 @@ wasm_loader_pop_frame_ref(WASMLoaderContext *ctx, uint8\
    \ type, char *error_buf,\n     return true;\n }\n \n+#if WASM_ENABLE_FAST_INTERP\
    \ == 0\n static bool\n wasm_loader_push_pop_frame_ref(WASMLoaderContext *ctx,\
    \ uint8 pop_cnt,\n                                uint8 type_push, uint8 type_pop,\
    \ char *error_buf,\n@@ -3951,6 +3952,7 @@ wasm_loader_push_pop_frame_ref(WASMLoaderContext\
    \ *ctx, uint8 pop_cnt,\n         return false;\n     return true;\n }\n+#endif\n\
    \ \n static bool\n wasm_loader_push_frame_csp(WASMLoaderContext *ctx, uint8 label_type,\n\
    @@ -4608,25 +4610,6 @@ wasm_loader_pop_frame_offset(WASMLoaderContext *ctx, uint8\
    \ type,\n     return true;\n }\n \n-static bool\n-wasm_loader_push_pop_frame_offset(WASMLoaderContext\
    \ *ctx, uint8 pop_cnt,\n-                                  uint8 type_push, uint8\
    \ type_pop,\n-                                  bool disable_emit, int16 operand_offset,\n\
    -                                  char *error_buf, uint32 error_buf_size)\n-{\n\
    -    for (int i = 0; i < pop_cnt; i++) {\n-        if (!wasm_loader_pop_frame_offset(ctx,\
    \ type_pop, error_buf,\n-                                          error_buf_size))\n\
    -            return false;\n-    }\n-    if (!wasm_loader_push_frame_offset(ctx,\
    \ type_push, disable_emit,\n-                                       operand_offset,\
    \ error_buf,\n-                                       error_buf_size))\n-    \
    \    return false;\n-\n-    return true;\n-}\n-\n static bool\n wasm_loader_push_frame_ref_offset(WASMLoaderContext\
    \ *ctx, uint8 type,\n                                   bool disable_emit, int16\
    \ operand_offset,\n@@ -4660,12 +4643,24 @@ wasm_loader_push_pop_frame_ref_offset(WASMLoaderContext\
    \ *ctx, uint8 pop_cnt,\n                                       bool disable_emit,\
    \ int16 operand_offset,\n                                       char *error_buf,\
    \ uint32 error_buf_size)\n {\n-    if (!wasm_loader_push_pop_frame_offset(ctx,\
    \ pop_cnt, type_push, type_pop,\n-                                           disable_emit,\
    \ operand_offset,\n-                                           error_buf, error_buf_size))\n\
    +    uint8 i;\n+\n+    for (i = 0; i < pop_cnt; i++) {\n+        if (!wasm_loader_pop_frame_offset(ctx,\
    \ type_pop, error_buf,\n+                                          error_buf_size))\n\
    +            return false;\n+\n+        if (!wasm_loader_pop_frame_ref(ctx, type_pop,\
    \ error_buf,\n+                                       error_buf_size))\n+    \
    \        return false;\n+    }\n+\n+    if (!wasm_loader_push_frame_offset(ctx,\
    \ type_push, disable_emit,\n+                                       operand_offset,\
    \ error_buf,\n+                                       error_buf_size))\n     \
    \    return false;\n-    if (!wasm_loader_push_pop_frame_ref(ctx, pop_cnt, type_push,\
    \ type_pop,\n-                                        error_buf, error_buf_size))\n\
    +\n+    if (!wasm_loader_push_frame_ref(ctx, type_push, error_buf, error_buf_size))\n\
    \         return false;\n \n     return true;"
  identifiers: CVE:["CVE-2023-52284"],CWE:["CWE-191"]
  overview: Affected versions of this package are vulnerable to Integer Underflow
    (Wrap or Wraparound) due to improper handling of `push_pop_frame_ref_offset` during
    the execution of a valid WebAssembly module. An attacker can trigger a double
    free, leading to a denial of service.
  references:
    GitHub Commit: https://github.com/bytecodealliance/wasm-micro-runtime/commit/6382162711a9cfaedc63de9065b0bc6eda8123f3
    GitHub Diff: https://github.com/bytecodealliance/wasm-micro-runtime/compare/WAMR-1.2.3...WAMR-1.3.0
    GitHub Issue: https://github.com/bytecodealliance/wasm-micro-runtime/issues/2586
    GitHub PR: https://github.com/bytecodealliance/wasm-micro-runtime/pull/2590
  title: Integer Underflow (Wrap or Wraparound)
- diff_content:
  - "--- a/src/epoll_socket.cpp\n+++ b/src/epoll_socket.cpp\n@@ -228,11 +228,6 @@\
    \ int EpollSocket::handle_accept_event(int &epollfd, epoll_event &event, EpollSock\n\
    \ void read_func(void *data) {\n     TaskData *td = (TaskData *) data;\n     td->es->handle_readable_event(td->event);\n\
    -\n-    EpollContext *hc = (EpollContext *) td->event.data.ptr;\n-    if (hc !=\
    \ NULL) {\n-        hc->_ctx_status = CONTEXT_READ_OVER;\n-    }\n     delete\
    \ td;\n }\n \n@@ -248,6 +243,9 @@ int EpollSocket::handle_readable_event(epoll_event\
    \ &event) {\n     if (ret == READ_CLOSE) {\n         return close_and_release(event);\n\
    \     }\n+    if (epoll_context != NULL) {\n+        epoll_context->_ctx_status\
    \ = CONTEXT_READ_OVER;\n+    }\n \n     if (ret == READ_CONTINUE) {\n        \
    \ event.events = EPOLLIN | EPOLLONESHOT;"
  - "--- a/src/sim_parser.cpp\n+++ b/src/sim_parser.cpp\n@@ -577,7 +577,7 @@ int Request::parse_request(const\
    \ char *read_buffer, int read_size) {\n         LOG_INFO(\"TOO BIG REQUEST WE\
    \ WILL REFUSE IT! MAX_REQ_SIZE:%d\", MAX_REQ_SIZE);\n         return -1;\n   \
    \  }\n-    LOG_DEBUG(\"read from client: size:%d, content:%s\", read_size, read_buffer);\n\
    +    LOG_DEBUG(\"read from client: size:%d, content:%.4096s\", read_size, read_buffer);\n\
    \     ssize_t nparsed = http_parser_execute(&_parser, &_settings, read_buffer,\
    \ read_size);\n     if (nparsed != read_size) {\n         std::string err_msg\
    \ = \"unkonw\";"
  identifiers: CVE:["CVE-2023-52267"],CWE:["CWE-125"]
  overview: Affected versions of this package are vulnerable to Out-of-bounds Read
    due to improper handling of error logging for long strings in `simple_log.cpp`.
    An attacker can read sensitive information from memory or cause a crash by supplying
    a long string.
  references:
    GitHub Commit: https://github.com/hongliuliao/ehttp/commit/17405b975948abc216f6a085d2d027ec1cfd5766
    GitHub Issue: https://github.com/hongliuliao/ehttp/issues/38
  title: Out-of-bounds Read
- diff_content:
  - "--- a/src/epoll_socket.cpp\n+++ b/src/epoll_socket.cpp\n@@ -228,11 +228,6 @@\
    \ int EpollSocket::handle_accept_event(int &epollfd, epoll_event &event, EpollSock\n\
    \ void read_func(void *data) {\n     TaskData *td = (TaskData *) data;\n     td->es->handle_readable_event(td->event);\n\
    -\n-    EpollContext *hc = (EpollContext *) td->event.data.ptr;\n-    if (hc !=\
    \ NULL) {\n-        hc->_ctx_status = CONTEXT_READ_OVER;\n-    }\n     delete\
    \ td;\n }\n \n@@ -248,6 +243,9 @@ int EpollSocket::handle_readable_event(epoll_event\
    \ &event) {\n     if (ret == READ_CLOSE) {\n         return close_and_release(event);\n\
    \     }\n+    if (epoll_context != NULL) {\n+        epoll_context->_ctx_status\
    \ = CONTEXT_READ_OVER;\n+    }\n \n     if (ret == READ_CONTINUE) {\n        \
    \ event.events = EPOLLIN | EPOLLONESHOT;"
  - "--- a/src/sim_parser.cpp\n+++ b/src/sim_parser.cpp\n@@ -577,7 +577,7 @@ int Request::parse_request(const\
    \ char *read_buffer, int read_size) {\n         LOG_INFO(\"TOO BIG REQUEST WE\
    \ WILL REFUSE IT! MAX_REQ_SIZE:%d\", MAX_REQ_SIZE);\n         return -1;\n   \
    \  }\n-    LOG_DEBUG(\"read from client: size:%d, content:%s\", read_size, read_buffer);\n\
    +    LOG_DEBUG(\"read from client: size:%d, content:%.4096s\", read_size, read_buffer);\n\
    \     ssize_t nparsed = http_parser_execute(&_parser, &_settings, read_buffer,\
    \ read_size);\n     if (nparsed != read_size) {\n         std::string err_msg\
    \ = \"unkonw\";"
  identifiers: CVE:["CVE-2023-52266"],CWE:["CWE-416"]
  overview: Affected versions of this package are vulnerable to Use After Free in
    the `read_func` function in `epoll_socket.cpp`. An attacker can cause denial of
    service by making many connections over a short time.
  references:
    GitHub Commit: https://github.com/hongliuliao/ehttp/commit/17405b975948abc216f6a085d2d027ec1cfd5766
    GitHub Issue: https://github.com/hongliuliao/ehttp/issues/38
  title: Use After Free
- diff_content:
  - "--- a/py/objslice.c\n+++ b/py/objslice.c\n@@ -54,7 +54,7 @@ STATIC mp_obj_t slice_unary_op(mp_unary_op_t\
    \ op, mp_obj_t o_in) {\n \n #if MICROPY_PY_BUILTINS_SLICE_INDICES\n STATIC mp_obj_t\
    \ slice_indices(mp_obj_t self_in, mp_obj_t length_obj) {\n-    mp_int_t length\
    \ = mp_obj_int_get_checked(length_obj);\n+    mp_int_t length = mp_obj_get_int(length_obj);\n\
    \     mp_bound_slice_t bound_indices;\n     mp_obj_slice_indices(self_in, length,\
    \ &bound_indices);\n "
  identifiers: CVE:["CVE-2023-7158"],CWE:["CWE-122"]
  overview: Affected versions of this package are vulnerable to Heap-based Buffer
    Overflow via the `slice_indices` function. An attacker can potentially execute
    arbitrary code or disrupt service by manipulating the input to this function.
  references:
    GitHub Commit: https://github.com/micropython/micropython/commit/f397a3ec318f3ad05aa287764ae7cef32202380f
    GitHub Issue: https://github.com/micropython/micropython/issues/13007
    GitHub PR: https://github.com/micropython/micropython/pull/13039
    GitHub Release: https://github.com/micropython/micropython/releases/tag/v1.22.0
  title: Heap-based Buffer Overflow
- diff_content:
  - "--- a/extmod/modselect.c\n+++ b/extmod/modselect.c\n@@ -41,6 +41,7 @@\n \n #if\
    \ MICROPY_PY_SELECT_POSIX_OPTIMISATIONS\n \n+#include <string.h>\n #include <poll.h>\n\
    \ \n #if !((MP_STREAM_POLL_RD) == (POLLIN) && \\\n@@ -142,14 +143,47 @@ STATIC\
    \ void poll_obj_set_revents(poll_obj_t *poll_obj, mp_uint_t revents) {\n     }\n\
    \ }\n \n+// How much (in pollfds) to grow the allocation for poll_set->pollfds\
    \ by.\n+#define POLL_SET_ALLOC_INCREMENT (4)\n+\n STATIC struct pollfd *poll_set_add_fd(poll_set_t\
    \ *poll_set, int fd) {\n     struct pollfd *free_slot = NULL;\n \n     if (poll_set->used\
    \ == poll_set->max_used) {\n         // No free slots below max_used, so expand\
    \ max_used (and possibly allocate).\n         if (poll_set->max_used >= poll_set->alloc)\
    \ {\n-            poll_set->pollfds = m_renew(struct pollfd, poll_set->pollfds,\
    \ poll_set->alloc, poll_set->alloc + 4);\n-            poll_set->alloc += 4;\n\
    +            size_t new_alloc = poll_set->alloc + POLL_SET_ALLOC_INCREMENT;\n\
    +            // Try to grow in-place.\n+            struct pollfd *new_fds = m_renew_maybe(struct\
    \ pollfd, poll_set->pollfds, poll_set->alloc, new_alloc, false);\n+          \
    \  if (!new_fds) {\n+                // Failed to grow in-place. Do a new allocation\
    \ and copy over the pollfd values.\n+                new_fds = m_new(struct pollfd,\
    \ new_alloc);\n+                memcpy(new_fds, poll_set->pollfds, sizeof(struct\
    \ pollfd) * poll_set->alloc);\n+\n+                // Update existing poll_obj_t\
    \ to update their pollfd field to\n+                // point to the same offset\
    \ inside the new allocation.\n+                for (mp_uint_t i = 0; i < poll_set->map.alloc;\
    \ ++i) {\n+                    if (!mp_map_slot_is_filled(&poll_set->map, i))\
    \ {\n+                        continue;\n+                    }\n+\n+        \
    \            poll_obj_t *poll_obj = MP_OBJ_TO_PTR(poll_set->map.table[i].value);\n\
    +                    if (!poll_obj) {\n+                        // This is the\
    \ one we're currently adding,\n+                        // poll_set_add_obj doesn't\
    \ assign elem->value until\n+                        // afterwards.\n+       \
    \                 continue;\n+                    }\n+\n+                    poll_obj->pollfd\
    \ = new_fds + (poll_obj->pollfd - poll_set->pollfds);\n+                }\n+\n\
    +                // Delete the old allocation.\n+                m_del(struct\
    \ pollfd, poll_set->pollfds, poll_set->alloc);\n+            }\n+\n+         \
    \   poll_set->pollfds = new_fds;\n+            poll_set->alloc = new_alloc;\n\
    \         }\n         free_slot = &poll_set->pollfds[poll_set->max_used++];\n\
    \     } else {"
  identifiers: CVE:["CVE-2023-7152"],CWE:["CWE-416"]
  overview: Affected versions of this package are vulnerable to Use After Free because
    `poll_set_add_fd` frees previously allocated `fds at m_renew`, when fd is allocated
    for a poll object. An attacker can try to malform an object or fd by using each
    other, leading to unintended behavior of the package.
  references:
    GitHub Commit: https://github.com/jimmo/micropython/commit/8b24aa36ba978eafc6114b6798b47b7bfecdca26
    GitHub Issue: https://github.com/micropython/micropython/issues/12887
  title: Use After Free
- diff_content:
  - "--- a/src/switch_rtp.c\n+++ b/src/switch_rtp.c\n@@ -3374,7 +3374,20 @@ static\
    \ int do_dtls(switch_rtp_t *rtp_session, switch_dtls_t *dtls)\n \t\treturn 0;\n\
    \ \t}\n \n-\tif (is_ice && !rtp_session->ice.cand_responsive) {\n+\tif (is_ice\
    \ && !(rtp_session->ice.type & ICE_LITE) && !rtp_session->ice.cand_responsive)\
    \ {\n+\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session),\
    \ SWITCH_LOG_DEBUG6, \"Got DTLS packet but candidate is not responsive\\n\");\n\
    +\n+\t\treturn 0;\n+\t}\n+\n+\tif (is_ice && !switch_cmp_addr(rtp_session->from_addr,\
    \ rtp_session->ice.addr, SWITCH_TRUE)) {\n+\t\tchar tmp_buf1[80] = \"\";\n+\t\t\
    char tmp_buf2[80] = \"\";\n+\t\tconst char *host_from = switch_get_addr(tmp_buf1,\
    \ sizeof(tmp_buf1), rtp_session->from_addr);\n+\t\tconst char *host_ice_cur_addr\
    \ = switch_get_addr(tmp_buf2, sizeof(tmp_buf2), rtp_session->ice.addr);\n+\n+\t\
    \tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_DEBUG5,\
    \ \"Got DTLS packet from [%s] whilst current ICE negotiated address is [%s]. Ignored.\\\
    n\", host_from, host_ice_cur_addr);\n+\n \t\treturn 0;\n \t}\n "
  identifiers: CVE:["CVE-2023-51443"],CWE:["CWE-703"]
  overview: Affected versions of this package are vulnerable to Improper Check or
    Handling of Exceptional Conditions via the DTLS handshake process. An attacker
    can cause a denial of service by continuously sending a ClientHello DTLS message
    with an invalid CipherSuite to the server's port, leading to the teardown of media
    sessions and associated signaling.
  references:
    GitHub Commit: https://github.com/signalwire/freeswitch/commit/86cbda90b84ba186e508fbc7bfae469270a97d11
  title: Improper Check or Handling of Exceptional Conditions
- diff_content:
  - "--- a/3rdparty/libzipplugin/libzipplugin.cpp\n+++ b/3rdparty/libzipplugin/libzipplugin.cpp\n\
    @@ -761,6 +761,11 @@ ErrorType LibzipPlugin::extractEntry(zip_t *archive, zip_int64_t\
    \ index, const Ex\n     }\n \n     strFileName = m_common->trans2uft8(statBuffer.name,\
    \ m_mapFileCode[index]);    // \u89E3\u538B\u6587\u4EF6\u540D\uFF08\u538B\u7F29\
    \u5305\u4E2D\uFF09\n+    //fix 232873\n+    if(strFileName.indexOf(\"../\") !=\
    \ -1) {\n+        qInfo() << \"skipped ../ path component(s) in \" << strFileName;\n\
    +        strFileName = strFileName.replace(\"../\", \"\");\n+    }\n     if(strFileName.contains(QLatin1Char('\\\
    \\')))\n         strFileName = strFileName.replace(QLatin1Char('\\\\'), QDir::separator());\n\
    \     QString strOriginName = strFileName;"
  identifiers: CVE:["CVE-2023-50255"],CWE:["CWE-29"]
  overview: ''
  references:
    GitHub Commit: https://github.com/linuxdeepin/deepin-compressor/commit/82f668c78c133873f5094cfab6e4eabc0b70e4b6
  title: Arbitrary File Write via Archive Extraction (Zip Slip)
- diff_content:
  - "--- a/src/gpasswd.c\n+++ b/src/gpasswd.c\n@@ -898,6 +898,7 @@ static void change_passwd\
    \ (struct group *gr)\n \t\terase_pass (cp);\n \t\tcp = agetpass (_(\"Re-enter\
    \ new password: \"));\n \t\tif (NULL == cp) {\n+\t\t\tmemzero (pass, sizeof pass);\n\
    \ \t\t\texit (1);\n \t\t}\n "
  identifiers: CVE:["CVE-2023-4641"],CWE:["CWE-256"],RHSA:["RHSA-2023:6632","RHSA-2023:7112"]
  overview: Affected versions of this package are vulnerable to Plaintext Storage
    of a Password due to improper handling of password verification failures. An attacker
    with local access could potentially retrieve a password from memory if they can
    trigger a password verification failure.
  references:
    GitHub Commit: https://github.com/shadow-maint/shadow/commit/65c88a43a23c2391dcc90c0abda3e839e9c57904
    RedHat Bugzilla Bug: https://bugzilla.redhat.com/show_bug.cgi?id=2215945
  title: Plaintext Storage of a Password
- diff_content:
  - "--- a/net/core/scm.c\n+++ b/net/core/scm.c\n@@ -26,6 +26,7 @@\n #include <linux/nsproxy.h>\n\
    \ #include <linux/slab.h>\n #include <linux/errqueue.h>\n+#include <linux/io_uring.h>\n\
    \ \n #include <linux/uaccess.h>\n \n@@ -103,6 +104,11 @@ static int scm_fp_copy(struct\
    \ cmsghdr *cmsg, struct scm_fp_list **fplp)\n \n \t\tif (fd < 0 || !(file = fget_raw(fd)))\n\
    \ \t\t\treturn -EBADF;\n+\t\t/* don't allow io_uring files */\n+\t\tif (io_uring_get_socket(file))\
    \ {\n+\t\t\tfput(file);\n+\t\t\treturn -EINVAL;\n+\t\t}\n \t\t*fpp++ = file;\n\
    \ \t\tfpl->count++;\n \t}"
  identifiers: CVE:["CVE-2023-6531"],CWE:["CWE-400"]
  overview: Affected versions of this package are vulnerable to Denial of Service
    (DoS) due to a race condition in the unix garbage collector's handling of socket
    buffer (SKB) deletion. An attacker with local access can cause a denial of service
    or potentially execute arbitrary code by triggering a use-after-free error.
  references:
    GitHub Commit: https://github.com/torvalds/linux/commit/705318a99a138c29a512a72c3e0043b3cd7f55f4
    RedHat Bugzilla Bug: https://bugzilla.redhat.com/show_bug.cgi?id=2253034
    commons-fileupload:commons-fileupload: SNYK-JAVA-COMMONSFILEUPLOAD-30082
    npm <code>ws</code> package: https://snyk.io/vuln/npm:ws:20171108
  title: Denial of Service (DoS)
- diff_content:
  - "--- a/net/appletalk/ddp.c\n+++ b/net/appletalk/ddp.c\n@@ -1775,15 +1775,14 @@\
    \ static int atalk_ioctl(struct socket *sock, unsigned int cmd, unsigned long\
    \ arg)\n \t\tbreak;\n \t}\n \tcase TIOCINQ: {\n-\t\t/*\n-\t\t * These two are\
    \ safe on a single CPU system as only\n-\t\t * user tasks fiddle here\n-\t\t */\n\
    -\t\tstruct sk_buff *skb = skb_peek(&sk->sk_receive_queue);\n+\t\tstruct sk_buff\
    \ *skb;\n \t\tlong amount = 0;\n \n+\t\tspin_lock_irq(&sk->sk_receive_queue.lock);\n\
    +\t\tskb = skb_peek(&sk->sk_receive_queue);\n \t\tif (skb)\n \t\t\tamount = skb->len\
    \ - sizeof(struct ddpehdr);\n+\t\tspin_unlock_irq(&sk->sk_receive_queue.lock);\n\
    \ \t\trc = put_user(amount, (int __user *)argp);\n \t\tbreak;\n \t}"
  identifiers: CVE:["CVE-2023-51781"],CWE:["CWE-416"]
  overview: Affected versions of this package are vulnerable to Use After Free in
    the `atalk_ioctl` function in `net/appletalk/ddp.c` file. This can cause a race
    condition within `atalk_recvmsg()` function.
  references:
    ChangeLog: https://cdn.kernel.org/pub/linux/kernel/v6.x/ChangeLog-6.6.8
    GitHub Commit: https://github.com/torvalds/linux/commit/189ff16722ee36ced4d2a2469d4ab65a8fee4198
  title: Use After Free
- diff_content:
  - "--- a/net/rose/af_rose.c\n+++ b/net/rose/af_rose.c\n@@ -1315,9 +1315,11 @@ static\
    \ int rose_ioctl(struct socket *sock, unsigned int cmd, unsigned long arg)\n \t\
    case TIOCINQ: {\n \t\tstruct sk_buff *skb;\n \t\tlong amount = 0L;\n-\t\t/* These\
    \ two are safe on a single CPU system as only user tasks fiddle here */\n+\n+\t\
    \tspin_lock_irq(&sk->sk_receive_queue.lock);\n \t\tif ((skb = skb_peek(&sk->sk_receive_queue))\
    \ != NULL)\n \t\t\tamount = skb->len;\n+\t\tspin_unlock_irq(&sk->sk_receive_queue.lock);\n\
    \ \t\treturn put_user(amount, (unsigned int __user *) argp);\n \t}\n "
  identifiers: CVE:["CVE-2023-51782"],CWE:["CWE-416"]
  overview: Affected versions of this package are vulnerable to Use After Free via
    the `rose_ioctl` function in the `net/rose/af_rose.c` file. This can cause a race
    condition within `rose_accept()` function.
  references:
    ChangeLog: https://cdn.kernel.org/pub/linux/kernel/v6.x/ChangeLog-6.6.8
    GitHub Commit: https://github.com/torvalds/linux/commit/810c38a369a0a0ce625b5c12169abce1dd9ccd53
  title: Use After Free
- diff_content:
  - "--- a/net/atm/ioctl.c\n+++ b/net/atm/ioctl.c\n@@ -73,14 +73,17 @@ static int\
    \ do_vcc_ioctl(struct socket *sock, unsigned int cmd,\n \tcase SIOCINQ:\n \t{\n\
    \ \t\tstruct sk_buff *skb;\n+\t\tint amount;\n \n \t\tif (sock->state != SS_CONNECTED)\
    \ {\n \t\t\terror = -EINVAL;\n \t\t\tgoto done;\n \t\t}\n+\t\tspin_lock_irq(&sk->sk_receive_queue.lock);\n\
    \ \t\tskb = skb_peek(&sk->sk_receive_queue);\n-\t\terror = put_user(skb ? skb->len\
    \ : 0,\n-\t\t\t\t (int __user *)argp) ? -EFAULT : 0;\n+\t\tamount = skb ? skb->len\
    \ : 0;\n+\t\tspin_unlock_irq(&sk->sk_receive_queue.lock);\n+\t\terror = put_user(amount,\
    \ (int __user *)argp) ? -EFAULT : 0;\n \t\tgoto done;\n \t}\n \tcase ATM_SETSC:"
  identifiers: CVE:["CVE-2023-51780"],CWE:["CWE-416"]
  overview: Affected versions of this package are vulnerable to Use After Free via
    the `do_vcc_ioctl` function in `net/atm/ioctl.c`. This can cause a race condition
    within `vcc_recvmsg()`.
  references:
    ChangeLog: https://cdn.kernel.org/pub/linux/kernel/v6.x/ChangeLog-6.6.8
    GitHub Commit: https://github.com/torvalds/linux/commit/24e90b9e34f9e039f56b5f25f6e6eb92cdd8f4b3
  title: Use After Free
- diff_content:
  - "--- a/ext/session/sqlite3session.c\n+++ b/ext/session/sqlite3session.c\n@@ -3236,15\
    \ +3236,19 @@ static int sessionReadRecord(\n         }\n       }\n       if(\
    \ eType==SQLITE_INTEGER || eType==SQLITE_FLOAT ){\n-        sqlite3_int64 v =\
    \ sessionGetI64(aVal);\n-        if( eType==SQLITE_INTEGER ){\n-          sqlite3VdbeMemSetInt64(apOut[i],\
    \ v);\n+        if( (pIn->nData-pIn->iNext)<8 ){\n+          rc = SQLITE_CORRUPT_BKPT;\n\
    \         }else{\n-          double d;\n-          memcpy(&d, &v, 8);\n-     \
    \     sqlite3VdbeMemSetDouble(apOut[i], d);\n+          sqlite3_int64 v = sessionGetI64(aVal);\n\
    +          if( eType==SQLITE_INTEGER ){\n+            sqlite3VdbeMemSetInt64(apOut[i],\
    \ v);\n+          }else{\n+            double d;\n+            memcpy(&d, &v,\
    \ 8);\n+            sqlite3VdbeMemSetDouble(apOut[i], d);\n+          }\n+   \
    \       pIn->iNext += 8;\n         }\n-        pIn->iNext += 8;\n       }\n  \
    \   }\n   }"
  identifiers: CVE:["CVE-2023-7104"],CWE:["CWE-122"]
  overview: Affected versions of this package are vulnerable to Heap-based Buffer
    Overflow via the `sessionReadRecord` function in the `ext/session/sqlite3session.c`
    file. An attacker can cause a program crash or execute arbitrary code by manipulating
    the input to trigger a heap-based buffer overflow.
  references:
    GitHub Commit: https://github.com/sqlite/sqlite/commit/09f1652f36c5c4e8a6a640ce887f9ea0f48a7958
    SQLite Commit: https://sqlite.org/src/info/0e4e7a05c4204b47
    SQLite Issue: https://sqlite.org/forum/forumpost/5bcbf4571c
  title: Heap-based Buffer Overflow
- diff_content:
  - "--- a/src/parser_yin.c\n+++ b/src/parser_yin.c\n@@ -4572,7 +4572,7 @@ read_yin_anydata(struct\
    \ lys_module *module, struct lys_node *parent, struct lyxm\n \n     for (r = 0;\
    \ r < retval->ext_size; ++r) {\n         /* set flag, which represent LYEXT_OPT_VALID\
    \ */\n-        if (retval->ext[r]->flags & LYEXT_OPT_VALID) {\n+        if (retval->ext[r]\
    \ && (retval->ext[r]->flags & LYEXT_OPT_VALID)) {\n             retval->flags\
    \ |= LYS_VALID_EXT;\n             break;\n         }\n@@ -4794,7 +4794,7 @@ read_yin_leaf(struct\
    \ lys_module *module, struct lys_node *parent, struct lyxml_e\n \n     for (r\
    \ = 0; r < retval->ext_size; ++r) {\n         /* set flag, which represent LYEXT_OPT_VALID\
    \ */\n-        if (retval->ext[r]->flags & LYEXT_OPT_VALID) {\n+        if (retval->ext[r]\
    \ && (retval->ext[r]->flags & LYEXT_OPT_VALID)) {\n             retval->flags\
    \ |= LYS_VALID_EXT;\n             break;\n         }\n@@ -5108,7 +5108,7 @@ read_yin_leaflist(struct\
    \ lys_module *module, struct lys_node *parent, struct lyx\n \n     for (r = 0;\
    \ r < retval->ext_size; ++r) {\n         /* set flag, which represent LYEXT_OPT_VALID\
    \ */\n-        if (retval->ext[r]->flags & LYEXT_OPT_VALID) {\n+        if (retval->ext[r]\
    \ && (retval->ext[r]->flags & LYEXT_OPT_VALID)) {\n             retval->flags\
    \ |= LYS_VALID_EXT;\n             break;\n         }\n@@ -5477,7 +5477,7 @@ read_yin_list(struct\
    \ lys_module *module, struct lys_node *parent, struct lyxml_e\n \n     for (r\
    \ = 0; r < retval->ext_size; ++r) {\n         /* set flag, which represent LYEXT_OPT_VALID\
    \ */\n-        if (retval->ext[r]->flags & LYEXT_OPT_VALID) {\n+        if (retval->ext[r]\
    \ && (retval->ext[r]->flags & LYEXT_OPT_VALID)) {\n             retval->flags\
    \ |= LYS_VALID_EXT;\n             if (retval->ext[r]->flags & LYEXT_OPT_VALID_SUBTREE)\
    \ {\n                 retval->flags |= LYS_VALID_EXT_SUBTREE;\n@@ -5701,8 +5701,9\
    \ @@ read_yin_container(struct lys_module *module, struct lys_node *parent, struct\
    \ ly\n     }\n \n     for (r = 0; r < retval->ext_size; ++r) {\n-        /* set\
    \ flag, which represent LYEXT_OPT_VALID */\n-        if (retval->ext[r]->flags\
    \ & LYEXT_OPT_VALID) {\n+        /* extension instance may not yet be resolved\
    \ */\n+        if (retval->ext[r] && (retval->ext[r]->flags & LYEXT_OPT_VALID))\
    \ {\n+             /* set flag, which represent LYEXT_OPT_VALID */\n         \
    \    retval->flags |= LYS_VALID_EXT;\n             if (retval->ext[r]->flags &\
    \ LYEXT_OPT_VALID_SUBTREE) {\n                 retval->flags |= LYS_VALID_EXT_SUBTREE;"
  identifiers: CVE:["CVE-2021-28902"],CWE:["CWE-476"]
  overview: Affected versions of this package are vulnerable to NULL Pointer Dereference
    in the function `read_yin_container()` that could result in a crash.
  references:
    GitHub Commit: https://github.com/CESNET/libyang/commit/a3917d95d516e3de267d3cfa5d4d3715a90e8777
    GitHub Issue: https://github.com/CESNET/libyang/issues/1454
  title: NULL Pointer Dereference
- diff_content:
  - "--- a/plugins/codecs/ndlz/ndlz4x4.c\n+++ b/plugins/codecs/ndlz/ndlz4x4.c\n@@\
    \ -59,6 +59,8 @@\n int ndlz4_compress(const uint8_t *input, int32_t input_len,\
    \ uint8_t *output, int32_t output_len,\n                    uint8_t meta, blosc2_cparams\
    \ *cparams) {\n   BLOSC_UNUSED_PARAM(meta);\n+  BLOSC_ERROR_NULL(cparams, BLOSC2_ERROR_NULL_POINTER);\n\
    +  BLOSC_ERROR_NULL(cparams->schunk, BLOSC2_ERROR_NULL_POINTER);\n   uint8_t *smeta;\n\
    \   int32_t smeta_len;\n \n@@ -513,6 +515,8 @@ int ndlz4_decompress(const uint8_t\
    \ *input, int32_t input_len, uint8_t *output, i\n                      uint8_t\
    \ meta, blosc2_dparams *dparams) {\n   BLOSC_UNUSED_PARAM(meta);\n   BLOSC_UNUSED_PARAM(dparams);\n\
    +  BLOSC_ERROR_NULL(input, BLOSC2_ERROR_NULL_POINTER);\n+  BLOSC_ERROR_NULL(output,\
    \ BLOSC2_ERROR_NULL_POINTER);\n \n   uint8_t *ip = (uint8_t *) input;\n   uint8_t\
    \ *ip_limit = ip + input_len;\n@@ -541,7 +545,7 @@ int ndlz4_decompress(const\
    \ uint8_t *input, int32_t input_len, uint8_t *output, i\n   eshape[0] = ((blockshape[0]\
    \ + 3) / 4) * 4;\n   eshape[1] = ((blockshape[1] + 3) / 4) * 4;\n \n-  if (NDLZ_UNEXPECT_CONDITIONAL(output_len\
    \ < (int32_t) (blockshape[0] * blockshape[1]))) {\n+  if (NDLZ_UNEXPECT_CONDITIONAL((int64_t)output_len\
    \ < (int64_t)blockshape[0] * (int64_t)blockshape[1])) {\n     return 0;\n   }\n\
    \   memset(op, 0, blockshape[0] * blockshape[1]);"
  - "--- a/plugins/codecs/ndlz/ndlz8x8.c\n+++ b/plugins/codecs/ndlz/ndlz8x8.c\n@@\
    \ -59,6 +59,8 @@\n int ndlz8_compress(const uint8_t *input, int32_t input_len,\
    \ uint8_t *output, int32_t output_len,\n                    uint8_t meta, blosc2_cparams\
    \ *cparams) {\n   BLOSC_UNUSED_PARAM(meta);\n+  BLOSC_ERROR_NULL(cparams, BLOSC2_ERROR_NULL_POINTER);\n\
    +  BLOSC_ERROR_NULL(cparams->schunk, BLOSC2_ERROR_NULL_POINTER);\n   uint8_t *smeta;\n\
    \   int32_t smeta_len;\n \n@@ -430,6 +432,8 @@ int ndlz8_decompress(const uint8_t\
    \ *input, int32_t input_len, uint8_t *output, i\n                      uint8_t\
    \ meta, blosc2_dparams *dparams) {\n   BLOSC_UNUSED_PARAM(meta);\n   BLOSC_UNUSED_PARAM(dparams);\n\
    +  BLOSC_ERROR_NULL(input, BLOSC2_ERROR_NULL_POINTER);\n+  BLOSC_ERROR_NULL(output,\
    \ BLOSC2_ERROR_NULL_POINTER);\n \n   const int cell_shape = 8;\n   const int cell_size\
    \ = 64;\n@@ -458,8 +462,7 @@ int ndlz8_decompress(const uint8_t *input, int32_t\
    \ input_len, uint8_t *output, i\n   ip += 4;\n   eshape[0] = ((blockshape[0] +\
    \ 7) / cell_shape) * cell_shape;\n   eshape[1] = ((blockshape[1] + 7) / cell_shape)\
    \ * cell_shape;\n-\n-  if (NDLZ_UNEXPECT_CONDITIONAL(output_len < blockshape[0]\
    \ * blockshape[1])) {\n+  if (NDLZ_UNEXPECT_CONDITIONAL((int64_t)output_len <\
    \ (int64_t)blockshape[0] * (int64_t)blockshape[1])) {\n     return 0;\n   }\n\
    \   memset(op, 0, blockshape[0] * blockshape[1]);"
  identifiers: CVE:["CVE-2023-37186"],CWE:["CWE-476"]
  overview: Affected versions of this package are vulnerable to NULL Pointer Dereference
    in `ndlz8x8.c.`. An attacker can cause a crash by processing a malicious file.
  references:
    GitHub Commit: https://github.com/Blosc/c-blosc2/commit/d55bfcd6804699e1435dc3e233fd76c8a5d3f9e3
    GitHub Diff: https://github.com/Blosc/c-blosc2/compare/v2.9.2...v2.9.3
    GitHub Issue: https://github.com/Blosc/c-blosc2/issues/522
  title: NULL Pointer Dereference
- diff_content:
  - "--- a/plugins/codecs/zfp/blosc2-zfp.c\n+++ b/plugins/codecs/zfp/blosc2-zfp.c\n\
    @@ -26,6 +26,7 @@ int zfp_acc_compress(const uint8_t *input, int32_t input_len,\
    \ uint8_t *output,\n   ZFP_ERROR_NULL(input);\n   ZFP_ERROR_NULL(output);\n  \
    \ ZFP_ERROR_NULL(cparams);\n+  ZFP_ERROR_NULL(cparams->schunk);\n \n   double\
    \ tol = (int8_t) meta;\n   int8_t ndim;\n@@ -146,6 +147,7 @@ int zfp_acc_decompress(const\
    \ uint8_t *input, int32_t input_len, uint8_t *output,\n   ZFP_ERROR_NULL(input);\n\
    \   ZFP_ERROR_NULL(output);\n   ZFP_ERROR_NULL(dparams);\n+  ZFP_ERROR_NULL(dparams->schunk);\n\
    \   BLOSC_UNUSED_PARAM(chunk);\n \n   blosc2_schunk *sc = dparams->schunk;\n@@\
    \ -241,6 +243,7 @@ int zfp_prec_compress(const uint8_t *input, int32_t input_len,\
    \ uint8_t *output,\n   ZFP_ERROR_NULL(input);\n   ZFP_ERROR_NULL(output);\n  \
    \ ZFP_ERROR_NULL(cparams);\n+  ZFP_ERROR_NULL(cparams->schunk);\n \n   int8_t\
    \ ndim;\n   int64_t *shape = malloc(8 * sizeof(int64_t));\n@@ -385,6 +388,7 @@\
    \ int zfp_prec_decompress(const uint8_t *input, int32_t input_len, uint8_t *output\n\
    \   ZFP_ERROR_NULL(input);\n   ZFP_ERROR_NULL(output);\n   ZFP_ERROR_NULL(dparams);\n\
    +  ZFP_ERROR_NULL(dparams->schunk);\n   BLOSC_UNUSED_PARAM(chunk);\n \n   blosc2_schunk\
    \ *sc = dparams->schunk;\n@@ -504,6 +508,7 @@ int zfp_rate_compress(const uint8_t\
    \ *input, int32_t input_len, uint8_t *output,\n   ZFP_ERROR_NULL(input);\n   ZFP_ERROR_NULL(output);\n\
    \   ZFP_ERROR_NULL(cparams);\n+  ZFP_ERROR_NULL(cparams->schunk);\n \n   double\
    \ ratio = (double) meta / 100.0;\n   int8_t ndim;\n@@ -635,6 +640,7 @@ int zfp_rate_decompress(const\
    \ uint8_t *input, int32_t input_len, uint8_t *output\n   ZFP_ERROR_NULL(input);\n\
    \   ZFP_ERROR_NULL(output);\n   ZFP_ERROR_NULL(dparams);\n+  ZFP_ERROR_NULL(dparams->schunk);\n\
    \   BLOSC_UNUSED_PARAM(chunk);\n \n   blosc2_schunk *sc = dparams->schunk;"
  identifiers: CVE:["CVE-2023-37185"],CWE:["CWE-476"]
  overview: Affected versions of this package are vulnerable to NULL Pointer Dereference
    in the `zfp_prec_decompress()` function in `zfp/blosc2-zfp.c`. An attacker can
    cause a crash by passing in a malicious file.
  references:
    GitHub Commit: https://github.com/Blosc/c-blosc2/commit/425e8a9a59d49378d57e2116b6c9b0190a5986f5
    GitHub Diff: https://github.com/Blosc/c-blosc2/compare/v2.9.2...v2.9.3
    GitHub Issue: https://github.com/Blosc/c-blosc2/issues/519
  title: NULL Pointer Dereference
- diff_content:
  - "--- a/plugins/codecs/zfp/blosc2-zfp.c\n+++ b/plugins/codecs/zfp/blosc2-zfp.c\n\
    @@ -26,6 +26,7 @@ int zfp_acc_compress(const uint8_t *input, int32_t input_len,\
    \ uint8_t *output,\n   ZFP_ERROR_NULL(input);\n   ZFP_ERROR_NULL(output);\n  \
    \ ZFP_ERROR_NULL(cparams);\n+  ZFP_ERROR_NULL(cparams->schunk);\n \n   double\
    \ tol = (int8_t) meta;\n   int8_t ndim;\n@@ -146,6 +147,7 @@ int zfp_acc_decompress(const\
    \ uint8_t *input, int32_t input_len, uint8_t *output,\n   ZFP_ERROR_NULL(input);\n\
    \   ZFP_ERROR_NULL(output);\n   ZFP_ERROR_NULL(dparams);\n+  ZFP_ERROR_NULL(dparams->schunk);\n\
    \   BLOSC_UNUSED_PARAM(chunk);\n \n   blosc2_schunk *sc = dparams->schunk;\n@@\
    \ -241,6 +243,7 @@ int zfp_prec_compress(const uint8_t *input, int32_t input_len,\
    \ uint8_t *output,\n   ZFP_ERROR_NULL(input);\n   ZFP_ERROR_NULL(output);\n  \
    \ ZFP_ERROR_NULL(cparams);\n+  ZFP_ERROR_NULL(cparams->schunk);\n \n   int8_t\
    \ ndim;\n   int64_t *shape = malloc(8 * sizeof(int64_t));\n@@ -385,6 +388,7 @@\
    \ int zfp_prec_decompress(const uint8_t *input, int32_t input_len, uint8_t *output\n\
    \   ZFP_ERROR_NULL(input);\n   ZFP_ERROR_NULL(output);\n   ZFP_ERROR_NULL(dparams);\n\
    +  ZFP_ERROR_NULL(dparams->schunk);\n   BLOSC_UNUSED_PARAM(chunk);\n \n   blosc2_schunk\
    \ *sc = dparams->schunk;\n@@ -504,6 +508,7 @@ int zfp_rate_compress(const uint8_t\
    \ *input, int32_t input_len, uint8_t *output,\n   ZFP_ERROR_NULL(input);\n   ZFP_ERROR_NULL(output);\n\
    \   ZFP_ERROR_NULL(cparams);\n+  ZFP_ERROR_NULL(cparams->schunk);\n \n   double\
    \ ratio = (double) meta / 100.0;\n   int8_t ndim;\n@@ -635,6 +640,7 @@ int zfp_rate_decompress(const\
    \ uint8_t *input, int32_t input_len, uint8_t *output\n   ZFP_ERROR_NULL(input);\n\
    \   ZFP_ERROR_NULL(output);\n   ZFP_ERROR_NULL(dparams);\n+  ZFP_ERROR_NULL(dparams->schunk);\n\
    \   BLOSC_UNUSED_PARAM(chunk);\n \n   blosc2_schunk *sc = dparams->schunk;"
  identifiers: CVE:["CVE-2023-37188"],CWE:["CWE-476"]
  overview: Affected versions of this package are vulnerable to NULL Pointer Dereference
    via the `zfp_rate_decompress()` function. An attacker can cause a crash by passing
    in a malicious file.
  references:
    GitHub Commit: https://github.com/Blosc/c-blosc2/commit/425e8a9a59d49378d57e2116b6c9b0190a5986f5
    GitHub Diff: https://github.com/Blosc/c-blosc2/compare/v2.9.2...v2.9.3
    GitHub Issue: https://github.com/Blosc/c-blosc2/issues/521
  title: NULL Pointer Dereference
- diff_content:
  - "--- a/src/Compression/CompressionCodecGorilla.cpp\n+++ b/src/Compression/CompressionCodecGorilla.cpp\n\
    @@ -264,7 +264,7 @@ UInt32 compressDataForType(const char * source, UInt32 source_size,\
    \ char * dest,\n }\n \n template <typename T>\n-void decompressDataForType(const\
    \ char * source, UInt32 source_size, char * dest)\n+void decompressDataForType(const\
    \ char * source, UInt32 source_size, char * dest, UInt32 dest_size)\n {\n    \
    \ const char * const source_end = source + source_size;\n \n@@ -280,6 +280,9 @@\
    \ void decompressDataForType(const char * source, UInt32 source_size, char * dest)\n\
    \     if (source + sizeof(T) > source_end || items_count < 1)\n         return;\n\
    \ \n+    if (static_cast<UInt64>(items_count) * sizeof(T) > dest_size)\n+    \
    \    throw Exception(ErrorCodes::CANNOT_DECOMPRESS, \"Cannot decompress Gorilla-encoded\
    \ data: corrupted input data.\");\n+\n     prev_value = unalignedLoadLittleEndian<T>(source);\n\
    \     unalignedStoreLittleEndian<T>(dest, prev_value);\n \n@@ -422,22 +425,28\
    \ @@ void CompressionCodecGorilla::doDecompressData(const char * source, UInt32\
    \ sourc\n     if (static_cast<UInt32>(2 + bytes_to_skip) > source_size)\n    \
    \     throw Exception(ErrorCodes::CANNOT_DECOMPRESS, \"Cannot decompress Gorilla-encoded\
    \ data. File has wrong header\");\n \n+    if (bytes_to_skip >= uncompressed_size)\n\
    +        throw Exception(ErrorCodes::CANNOT_DECOMPRESS, \"Cannot decompress Gorilla-encoded\
    \ data. File has wrong header\");\n+\n     memcpy(dest, &source[2], bytes_to_skip);\n\
    \     UInt32 source_size_no_header = source_size - bytes_to_skip - 2;\n+    UInt32\
    \ uncompressed_size_left = uncompressed_size - bytes_to_skip;\n     switch (bytes_size)\
    \ // NOLINT(bugprone-switch-missing-default-case)\n     {\n     case 1:\n-   \
    \     decompressDataForType<UInt8>(&source[2 + bytes_to_skip], source_size_no_header,\
    \ &dest[bytes_to_skip]);\n+        decompressDataForType<UInt8>(&source[2 + bytes_to_skip],\
    \ source_size_no_header, &dest[bytes_to_skip], uncompressed_size_left);\n    \
    \     break;\n     case 2:\n-        decompressDataForType<UInt16>(&source[2 +\
    \ bytes_to_skip], source_size_no_header, &dest[bytes_to_skip]);\n+        decompressDataForType<UInt16>(&source[2\
    \ + bytes_to_skip], source_size_no_header, &dest[bytes_to_skip], uncompressed_size_left);\n\
    \         break;\n     case 4:\n-        decompressDataForType<UInt32>(&source[2\
    \ + bytes_to_skip], source_size_no_header, &dest[bytes_to_skip]);\n+        decompressDataForType<UInt32>(&source[2\
    \ + bytes_to_skip], source_size_no_header, &dest[bytes_to_skip], uncompressed_size_left);\n\
    \         break;\n     case 8:\n-        decompressDataForType<UInt64>(&source[2\
    \ + bytes_to_skip], source_size_no_header, &dest[bytes_to_skip]);\n+        decompressDataForType<UInt64>(&source[2\
    \ + bytes_to_skip], source_size_no_header, &dest[bytes_to_skip], uncompressed_size_left);\n\
    \         break;\n+    default:\n+        throw Exception(ErrorCodes::CANNOT_DECOMPRESS,\
    \ \"Cannot decompress Gorilla-encoded data. File has wrong header\");\n     }\n\
    \ }\n "
  identifiers: CVE:["CVE-2023-48704"],CWE:["CWE-122"]
  overview: Affected versions of this package are vulnerable to Heap-based Buffer
    Overflow in the decompression logic of the Gorilla codec on the server's native
    interface. An attacker can cause a crash by sending data over TCP port 9000, which
    does not require authentication.
  references:
    GitHub Commit: https://github.com/ClibMouse/ClickHouse/commit/e5b078162c86fff4f436c1536e5ee784bc59e0ee
    GitHub PR: https://github.com/ClickHouse/ClickHouse/pull/57107
  title: Heap-based Buffer Overflow
- diff_content:
  - "--- a/src/http_microhttpd.c\n+++ b/src/http_microhttpd.c\n@@ -145,6 +145,10 @@\
    \ static int do_binauth(\n \tuser_agent = safe_calloc(USER_AGENT);\n \tMHD_get_connection_values(connection,\
    \ MHD_HEADER_KIND, get_user_agent_callback, &user_agent);\n \n+\tif (user_agent\
    \ == NULL) {\n+\t\treturn send_error(connection, 403);\n+\t}\n+\n \tdebug(LOG_DEBUG,\
    \ \"BinAuth: User Agent is [ %s ]\", user_agent);\n \n \t// Get custom data string\
    \ as passed in the query string\n@@ -984,6 +988,10 @@ static int show_preauthpage(struct\
    \ MHD_Connection *connection, const char *query\n \n \t\tMHD_get_connection_values(connection,\
    \ MHD_HEADER_KIND, get_user_agent_callback, &user_agent);\n \n+\t\tif (user_agent\
    \ == NULL) {\n+\t\t\treturn send_error(connection, 403);\n+\t\t}\n+\n \t\tuh_urlencode(enc_user_agent,\
    \ ENC_USER_AGENT, user_agent, strlen(user_agent));\n \t\tdebug(LOG_DEBUG, \"PreAuth:\
    \ Encoded User Agent is [ %s ]\", enc_user_agent);\n "
  identifiers: CVE:["CVE-2023-38321"],CWE:["CWE-476"]
  overview: Affected versions of this package are vulnerable to NULL Pointer Dereference
    via a GET request to `/opennds_auth/` that omits a required custom query string
    parameter and client-token, which can cause a crash.
  references:
    GitHub Commit: https://github.com/openNDS/openNDS/commit/b97bf3566071a8176c6e1add9af9abbfa6d89173
    GitHub Release: https://github.com/openNDS/openNDS/releases/tag/v10.1.2
  title: NULL Pointer Dereference
- diff_content:
  - "--- a/postfix/src/global/smtp_stream.c\n+++ b/postfix/src/global/smtp_stream.c\n\
    @@ -52,6 +52,8 @@\n /*\tVSTREAM *stream;\n /*\tchar\t*format;\n /*\tva_list\t\
    ap;\n+/*\n+/*\tint\tsmtp_forbid_bare_lf;\n /* AUXILIARY API\n /*\tint\tsmtp_get_noexcept(vp,\
    \ stream, maxlen, flags)\n /*\tVSTRING\t*vp;\n@@ -131,11 +133,16 @@\n /*\tsmtp_vprintf()\
    \ is the machine underneath smtp_printf().\n /*\n /*\tsmtp_get_noexcept() implements\
    \ the subset of smtp_get()\n-/*\twithout timeouts and without making long jumps.\
    \ Instead,\n+/*\twithout long jumps for timeout or EOF errors. Instead,\n /*\t\
    query the stream status with vstream_feof() etc.\n+/*\tThis function will make\
    \ a VSTREAM long jump (error code\n+/*\tSMTP_ERR_LF) when rejecting input with\
    \ a bare newline byte.\n /*\n /*\tsmtp_timeout_setup() is a backwards-compatibility\
    \ interface\n /*\tfor programs that don't require deadline or data-rate support.\n\
    +/*\n+/*\tsmtp_forbid_bare_lf controls whether smtp_get_noexcept()\n+/*\twill\
    \ reject input with a bare newline byte.\n /* DIAGNOSTICS\n /* .fi\n /* .ad\n\
    @@ -214,6 +221,7 @@\n   * the buffer. Such system calls would really hurt when\
    \ receiving or sending\n   * body content one line at a time.\n   */\n+int   \
    \  smtp_forbid_bare_lf;\n \n /* smtp_timeout_reset - reset per-stream error flags\
    \ */\n \n@@ -418,6 +426,9 @@ int     smtp_get_noexcept(VSTRING *vp, VSTREAM *stream,\
    \ ssize_t bound, int flags\n \t */\n     case '\\n':\n \tvstring_truncate(vp,\
    \ VSTRING_LEN(vp) - 1);\n+\tif (smtp_forbid_bare_lf\n+\t    && (VSTRING_LEN(vp)\
    \ == 0 || vstring_end(vp)[-1] != '\\r'))\n+\t    vstream_longjmp(stream, SMTP_ERR_LF);\n\
    \ \twhile (VSTRING_LEN(vp) > 0 && vstring_end(vp)[-1] == '\\r')\n \t    vstring_truncate(vp,\
    \ VSTRING_LEN(vp) - 1);\n \tVSTRING_TERMINATE(vp);"
  - "--- a/postfix/src/smtpd/smtpd.c\n+++ b/postfix/src/smtpd/smtpd.c\n@@ -802,6 +802,15\
    \ @@\n /* .IP \"\\fBsmtpd_forbid_unauth_pipelining (Postfix >= 3.9: yes)\\fR\"\
    \n /*\tDisconnect remote SMTP clients that violate RFC 2920 (or 5321)\n /*\tcommand\
    \ pipelining constraints.\n+/* .PP\n+/*\tAvailable in Postfix 3.9, 3.8.4, 3.7.9,\
    \ 3.6.13, 3.5.23 and later:\n+/* .IP \"\\fBsmtpd_forbid_bare_newline (Postfix\
    \ < 3.9: no)\\fR\"\n+/*\tReply with \"Error: bare <LF> received\" and disconnect\n\
    +/*\twhen a remote SMTP client sends a line ending in <LF>, violating\n+/*\tthe\
    \ RFC 5321 requirement that lines must end in <CR><LF>.\n+/* .IP \"\\fBsmtpd_forbid_bare_newline_exclusions\
    \ ($mynetworks)\\fR\"\n+/*\tExclude the specified clients from smtpd_forbid_bare_newline\n\
    +/*\tenforcement.\n /* TARPIT CONTROLS\n /* .ad\n /* .fi\n@@ -1510,6 +1519,9 @@\
    \ bool    var_relay_before_rcpt_checks;\n bool    var_smtpd_req_deadline;\n int\
    \     var_smtpd_min_data_rate;\n char   *var_hfrom_format;\n+bool    var_smtpd_forbid_bare_lf;\n\
    +char   *var_smtpd_forbid_bare_lf_excl;\n+static NAMADR_LIST *bare_lf_excl;\n\
    \ \n  /*\n   * Silly little macros.\n@@ -1585,6 +1597,7 @@ static void tls_reset(SMTPD_STATE\
    \ *);\n #define REASON_TIMEOUT\t\t\"timeout\"\n #define REASON_LOST_CONNECTION\t\
    \"lost connection\"\n #define REASON_ERROR_LIMIT\t\"too many errors\"\n+#define\
    \ REASON_BARE_LF\t\t\"bare <LF> received\"\n \n #ifdef USE_TLS\n \n@@ -4030,6\
    \ +4043,7 @@ static int bdat_cmd(SMTPD_STATE *state, int argc, SMTPD_TOKEN *argv)\n\
    \      */\n     done = 0;\n     do {\n+\tint     payload_err;\n \n \t/*\n \t *\
    \ Do not skip the smtp_fread_buf() call if read_len == 0. We still\n@@ -4043,6\
    \ +4057,10 @@ static int bdat_cmd(SMTPD_STATE *state, int argc, SMTPD_TOKEN *argv)\n\
    \ \tsmtp_fread_buf(state->buffer, read_len, state->client);\n \tstate->bdat_get_stream\
    \ = vstream_memreopen(\n \t\t\t   state->bdat_get_stream, state->buffer, O_RDONLY);\n\
    +\tvstream_control(state->bdat_get_stream, CA_VSTREAM_CTL_EXCEPT,\n+\t\t\tCA_VSTREAM_CTL_END);\n\
    +\tif ((payload_err = vstream_setjmp(state->bdat_get_stream)) != 0)\n+\t    vstream_longjmp(state->client,\
    \ payload_err);\n \n \t/*\n \t * Read lines from the fragment. The last line may\
    \ continue in the\n@@ -4718,6 +4736,9 @@ static int xclient_cmd(SMTPD_STATE *state,\
    \ int argc, SMTPD_TOKEN *argv)\n      */\n     xclient_allowed =\n \tnamadr_list_match(xclient_hosts,\
    \ state->name, state->addr);\n+    smtp_forbid_bare_lf = SMTPD_STAND_ALONE((state))\
    \ == 0\n+\t&& var_smtpd_forbid_bare_lf\n+\t&& !namadr_list_match(bare_lf_excl,\
    \ state->name, state->addr);\n     /* NOT: tls_reset() */\n     if (got_helo ==\
    \ 0)\n \thelo_reset(state);\n@@ -5539,6 +5560,13 @@ static void smtpd_proto(SMTPD_STATE\
    \ *state)\n \t\t\t     var_myhostname);\n \tbreak;\n \n+    case SMTP_ERR_LF:\n\
    +\tstate->reason = REASON_BARE_LF;\n+\tif (vstream_setjmp(state->client) == 0)\n\
    +\t    smtpd_chat_reply(state, \"521 5.5.2 %s Error: bare <LF> received\",\n+\t\
    \t\t     var_myhostname);\n+\tbreak;\n+\n     case 0:\n \n \t/*\n@@ -6105,6 +6133,13\
    \ @@ static void smtpd_service(VSTREAM *stream, char *service, char **argv)\n\
    \     xforward_allowed = SMTPD_STAND_ALONE((&state)) == 0 &&\n \tnamadr_list_match(xforward_hosts,\
    \ state.name, state.addr);\n \n+    /*\n+     * Enforce strict SMTP line endings,\
    \ with compatibility exclusions.\n+     */\n+    smtp_forbid_bare_lf = SMTPD_STAND_ALONE((&state))\
    \ == 0\n+\t&& var_smtpd_forbid_bare_lf\n+\t&& !namadr_list_match(bare_lf_excl,\
    \ state.name, state.addr);\n+\n     /*\n      * See if we need to turn on verbose\
    \ logging for this client.\n      */\n@@ -6166,6 +6201,10 @@ static void pre_jail_init(char\
    \ *unused_name, char **unused_argv)\n     hogger_list = namadr_list_init(VAR_SMTPD_HOGGERS,\
    \ MATCH_FLAG_RETURN\n \t\t\t\t   | match_parent_style(VAR_SMTPD_HOGGERS),\n \t\
    \t\t\t   var_smtpd_hoggers);\n+    bare_lf_excl = namadr_list_init(VAR_SMTPD_FORBID_BARE_LF_EXCL,\n\
    +\t\t\t\t    MATCH_FLAG_RETURN\n+\t\t\t\t    | match_parent_style(VAR_MYNETWORKS),\n\
    +\t\t\t\t    var_smtpd_forbid_bare_lf_excl);\n \n     /*\n      * Open maps before\
    \ dropping privileges so we can read passwords etc.\n@@ -6530,6 +6569,7 @@ int\
    \     main(int argc, char **argv)\n \tVAR_SMTPD_DELAY_OPEN, DEF_SMTPD_DELAY_OPEN,\
    \ &var_smtpd_delay_open,\n \tVAR_SMTPD_CLIENT_PORT_LOG, DEF_SMTPD_CLIENT_PORT_LOG,\
    \ &var_smtpd_client_port_log,\n \tVAR_SMTPD_FORBID_UNAUTH_PIPE, DEF_SMTPD_FORBID_UNAUTH_PIPE,\
    \ &var_smtpd_forbid_unauth_pipe,\n+\tVAR_SMTPD_FORBID_BARE_LF, DEF_SMTPD_FORBID_BARE_LF,\
    \ &var_smtpd_forbid_bare_lf,\n \t0,\n     };\n     static const CONFIG_NBOOL_TABLE\
    \ nbool_table[] = {\n@@ -6646,6 +6686,7 @@ int     main(int argc, char **argv)\n\
    \ \tVAR_SMTPD_DNS_RE_FILTER, DEF_SMTPD_DNS_RE_FILTER, &var_smtpd_dns_re_filter,\
    \ 0, 0,\n \tVAR_SMTPD_REJ_FTR_MAPS, DEF_SMTPD_REJ_FTR_MAPS, &var_smtpd_rej_ftr_maps,\
    \ 0, 0,\n \tVAR_HFROM_FORMAT, DEF_HFROM_FORMAT, &var_hfrom_format, 1, 0,\n+\t\
    VAR_SMTPD_FORBID_BARE_LF_EXCL, DEF_SMTPD_FORBID_BARE_LF_EXCL, &var_smtpd_forbid_bare_lf_excl,\
    \ 0, 0,\n \t0,\n     };\n     static const CONFIG_RAW_TABLE raw_table[] = {"
  identifiers: CVE:["CVE-2023-51764"],CWE:["CWE-924"]
  overview: Affected versions of this package are vulnerable to Improper Enforcement
    of Message Integrity During Transmission in a Communication Channel due to improper
    handling of SMTP protocol sequences, which allows header smuggling. An attacker
    can inject e-mail messages that appear to originate from the server, thus bypassing
    SPF protection mechanisms by exploiting the support for `<LF>.<CR><LF>` sequences,
    which are not universally handled by other e-mail servers. This is only exploitable
    if `smtpd_data_restrictions` is not configured with `reject_unauth_pipelining`
    or other protective options available in recent versions.
  references:
    GitHub Commit: https://github.com/vdukhovni/postfix/commit/fc8128b3b18c51399962097529685de01ce28c68
    Vulnerability Advisory: https://www.postfix.org/smtp-smuggling.html
    Vulnerability Report: https://sec-consult.com/blog/detail/smtp-smuggling-spoofing-e-mails-worldwide/
  title: Improper Enforcement of Message Integrity During Transmission in a Communication
    Channel
- diff_content:
  - "--- a/src/src/receive.c\n+++ b/src/src/receive.c\n@@ -1960,8 +1960,10 @@ for\
    \ (;;)\n \n   if (ch == '\\n')\n     {\n-    if (first_line_ended_crlf == TRUE_UNSET)\
    \ first_line_ended_crlf = FALSE;\n-      else if (first_line_ended_crlf) receive_ungetc('\
    \ ');\n+    if (first_line_ended_crlf == TRUE_UNSET)\n+      first_line_ended_crlf\
    \ = FALSE;\n+    else if (first_line_ended_crlf)\n+      receive_ungetc(' ');\n\
    \     goto EOL;\n     }\n \n@@ -1970,14 +1972,19 @@ for (;;)\n   This implements\
    \ the dot-doubling rule, though header lines starting with\n   dots aren't exactly\
    \ common. They are legal in RFC 822, though. If the\n   following is CRLF or LF,\
    \ this is the line that that terminates the\n+\n   entire message. We set message_ended\
    \ to indicate this has happened (to\n   prevent further reading), and break out\
    \ of the loop, having freed the\n   empty header, and set next = NULL to indicate\
    \ no data line. */\n \n   if (f.dot_ends && ptr == 0 && ch == '.')\n     {\n \
    \    ch = (receive_getc)(GETC_BUFFER_UNLIMITED);\n-    if (ch == '\\r')\n+   \
    \ if (ch == '\\n' && first_line_ended_crlf == TRUE /* and not TRUE_UNSET */ )\n\
    +    \t\t/* dot, LF  but we are in CRLF mode.  Attack? */\n+      ch = ' ';\t\
    /* replace the LF with a space */\n+\n+    else if (ch == '\\r')\n       {\n \
    \      ch = (receive_getc)(GETC_BUFFER_UNLIMITED);\n       if (ch != '\\n')\n\
    @@ -2013,7 +2020,8 @@ for (;;)\n     ch = (receive_getc)(GETC_BUFFER_UNLIMITED);\n\
    \     if (ch == '\\n')\n       {\n-      if (first_line_ended_crlf == TRUE_UNSET)\
    \ first_line_ended_crlf = TRUE;\n+      if (first_line_ended_crlf == TRUE_UNSET)\n\
    +\tfirst_line_ended_crlf = TRUE;\n       goto EOL;\n       }\n "
  - "--- a/src/src/smtp_in.c\n+++ b/src/src/smtp_in.c\n@@ -5105,15 +5105,18 @@ while\
    \ (done <= 0)\n \t}\n \n       if (chunking_state > CHUNKING_OFFERED)\n-\trc =\
    \ OK;\t\t\t/* No predata ACL or go-ahead output for BDAT */\n+\trc = OK;\t/* There\
    \ is no predata ACL or go-ahead output for BDAT */\n       else\n \t{\n-\t/* If\
    \ there is an ACL, re-check the synchronization afterwards, since the\n-\tACL\
    \ may have delayed.  To handle cutthrough delivery enforce a dummy call\n-\tto\
    \ get the DATA command sent. */\n+\t/* If there is a predata-ACL, re-check the\
    \ synchronization afterwards,\n+\tsince the ACL may have delayed.  To handle cutthrough\
    \ delivery enforce a\n+\tdummy call to get the DATA command sent. */\n \n \tif\
    \ (!acl_smtp_predata && cutthrough.cctx.sock < 0)\n+\t  {\n+\t  if (!check_sync())\
    \ goto SYNC_FAILURE;\n \t  rc = OK;\n+\t  }\n \telse\n \t  {\n \t  uschar * acl\
    \ = acl_smtp_predata ? acl_smtp_predata : US\"accept\";"
  identifiers: CVE:["CVE-2023-51766"],CWE:["CWE-924"]
  overview: Affected versions of this package are vulnerable to Improper Enforcement
    of Message Integrity During Transmission in a Communication Channel due to improper
    handling of SMTP protocol sequences, which allows header smuggling. An attacker
    can inject e-mail messages that appear to originate from the server, thus bypassing
    SPF protection mechanisms by exploiting the support for `<LF>.<CR><LF>` sequences,
    which are not universally handled by other e-mail servers.
  references:
    Bugzilla Page: https://bugs.exim.org/show_bug.cgi?id=3063
    GitHub Commit: https://github.com/Exim/exim/commit/cf1376206284f2a4f11e32d931d4aade34c206c5
    OSS Security Advisory: https://www.openwall.com/lists/oss-security/2023/12/23/2
    Vulnerability Advisory: https://exim.org/static/doc/security/CVE-2023-51766.txt
    Vulnerability Report: https://sec-consult.com/blog/detail/smtp-smuggling-spoofing-e-mails-worldwide/
  title: Improper Enforcement of Message Integrity During Transmission in a Communication
    Channel
- diff_content:
  - "--- a/plugins/sudoers/file.c\n+++ b/plugins/sudoers/file.c\n@@ -85,7 +85,7 @@\
    \ sudo_file_open(struct sudo_nss *nss)\n     if (handle != NULL) {\n \thandle->fp\
    \ = open_sudoers(sudoers_file, false, NULL);\n \tif (handle->fp != NULL) {\n-\t\
    \    init_parse_tree(&handle->parse_tree);\n+\t    init_parse_tree(&handle->parse_tree,\
    \ NULL, NULL);\n \t} else {\n \t    free(handle);\n \t    handle = NULL;"
  - "--- a/plugins/sudoers/gram.c\n+++ b/plugins/sudoers/gram.c\n@@ -106,7 +106,9\
    \ @@ char *errorfile = NULL;\n struct sudoers_parse_tree parsed_policy = {\n \
    \    TAILQ_HEAD_INITIALIZER(parsed_policy.userspecs),\n     TAILQ_HEAD_INITIALIZER(parsed_policy.defaults),\n\
    -    NULL /* aliases */\n+    NULL, /* aliases */\n+    NULL, /* lhost */\n+ \
    \   NULL /* shost */\n };\n \n /*\n@@ -118,7 +120,7 @@ static bool add_userspec(struct\
    \ member *, struct privilege *);\n static struct defaults *new_default(char *,\
    \ char *, short);\n static struct member *new_member(char *, int);\n static struct\
    \ command_digest *new_digest(int, char *);\n-#line 80 \"gram.y\"\n+#line 82 \"\
    gram.y\"\n #ifndef YYSTYPE_DEFINED\n #define YYSTYPE_DEFINED\n typedef union {\n\
    @@ -135,7 +137,7 @@ typedef union {\n     int tok;\n } YYSTYPE;\n #endif /* YYSTYPE_DEFINED\
    \ */\n-#line 133 \"gram.c\"\n+#line 135 \"gram.c\"\n #define COMMAND 257\n #define\
    \ ALIAS 258\n #define DEFVAR 259\n@@ -675,7 +677,7 @@ short *yysslim;\n YYSTYPE\
    \ *yyvs;\n unsigned int yystacksize;\n int yyparse(void);\n-#line 906 \"gram.y\"\
    \n+#line 908 \"gram.y\"\n void\n sudoerserror(const char *s)\n {\n@@ -1019,11\
    \ +1021,14 @@ free_userspec(struct userspec *us)\n  * Initialized a sudoers parse\
    \ tree.\n  */\n void\n-init_parse_tree(struct sudoers_parse_tree *parse_tree)\n\
    +init_parse_tree(struct sudoers_parse_tree *parse_tree, const char *lhost,\n+\
    \    const char *shost)\n {\n     TAILQ_INIT(&parse_tree->userspecs);\n     TAILQ_INIT(&parse_tree->defaults);\n\
    \     parse_tree->aliases = NULL;\n+    parse_tree->shost = shost;\n+    parse_tree->lhost\
    \ = lhost;\n }\n \n /*\n@@ -1100,7 +1105,7 @@ init_options(struct command_options\
    \ *opts)\n     opts->limitprivs = NULL;\n #endif\n }\n-#line 1046 \"gram.c\"\n\
    +#line 1051 \"gram.c\"\n /* allocate initial stack or double stack size, up to\
    \ YYMAXDEPTH */\n #if defined(__cplusplus) || defined(__STDC__)\n static int yygrowstack(void)\n\
    @@ -1309,23 +1314,23 @@ yyparse()\n     switch (yyn)\n     {\n case 1:\n-#line\
    \ 178 \"gram.y\"\n+#line 180 \"gram.y\"\n { ; }\n break;\n case 5:\n-#line 186\
    \ \"gram.y\"\n+#line 188 \"gram.y\"\n {\n \t\t\t    ;\n \t\t\t}\n break;\n case\
    \ 6:\n-#line 189 \"gram.y\"\n+#line 191 \"gram.y\"\n {\n \t\t\t    yyerrok;\n\
    \ \t\t\t}\n break;\n case 7:\n-#line 192 \"gram.y\"\n+#line 194 \"gram.y\"\n {\n\
    \ \t\t\t    if (!add_userspec(yyvsp[-1].member, yyvsp[0].privilege)) {\n \t\t\t\
    \tsudoerserror(N_(\"unable to allocate memory\"));\n@@ -1334,73 +1339,73 @@ case\
    \ 7:\n \t\t\t}\n break;\n case 8:\n-#line 198 \"gram.y\"\n+#line 200 \"gram.y\"\
    \n {\n \t\t\t    ;\n \t\t\t}\n break;\n case 9:\n-#line 201 \"gram.y\"\n+#line\
    \ 203 \"gram.y\"\n {\n \t\t\t    ;\n \t\t\t}\n break;\n case 10:\n-#line 204 \"\
    gram.y\"\n+#line 206 \"gram.y\"\n {\n \t\t\t    ;\n \t\t\t}\n break;\n case 11:\n\
    -#line 207 \"gram.y\"\n+#line 209 \"gram.y\"\n {\n \t\t\t    ;\n \t\t\t}\n break;\n\
    \ case 12:\n-#line 210 \"gram.y\"\n+#line 212 \"gram.y\"\n {\n \t\t\t    if (!add_defaults(DEFAULTS,\
    \ NULL, yyvsp[0].defaults))\n \t\t\t\tYYERROR;\n \t\t\t}\n break;\n case 13:\n\
    -#line 214 \"gram.y\"\n+#line 216 \"gram.y\"\n {\n \t\t\t    if (!add_defaults(DEFAULTS_USER,\
    \ yyvsp[-1].member, yyvsp[0].defaults))\n \t\t\t\tYYERROR;\n \t\t\t}\n break;\n\
    \ case 14:\n-#line 218 \"gram.y\"\n+#line 220 \"gram.y\"\n {\n \t\t\t    if (!add_defaults(DEFAULTS_RUNAS,\
    \ yyvsp[-1].member, yyvsp[0].defaults))\n \t\t\t\tYYERROR;\n \t\t\t}\n break;\n\
    \ case 15:\n-#line 222 \"gram.y\"\n+#line 224 \"gram.y\"\n {\n \t\t\t    if (!add_defaults(DEFAULTS_HOST,\
    \ yyvsp[-1].member, yyvsp[0].defaults))\n \t\t\t\tYYERROR;\n \t\t\t}\n break;\n\
    \ case 16:\n-#line 226 \"gram.y\"\n+#line 228 \"gram.y\"\n {\n \t\t\t    if (!add_defaults(DEFAULTS_CMND,\
    \ yyvsp[-1].member, yyvsp[0].defaults))\n \t\t\t\tYYERROR;\n \t\t\t}\n break;\n\
    \ case 18:\n-#line 233 \"gram.y\"\n+#line 235 \"gram.y\"\n {\n \t\t\t    HLTQ_CONCAT(yyvsp[-2].defaults,\
    \ yyvsp[0].defaults, entries);\n \t\t\t    yyval.defaults = yyvsp[-2].defaults;\n\
    \ \t\t\t}\n break;\n case 19:\n-#line 239 \"gram.y\"\n+#line 241 \"gram.y\"\n\
    \ {\n \t\t\t    yyval.defaults = new_default(yyvsp[0].string, NULL, true);\n \t\
    \t\t    if (yyval.defaults == NULL) {\n@@ -1410,7 +1415,7 @@ case 19:\n \t\t\t\
    }\n break;\n case 20:\n-#line 246 \"gram.y\"\n+#line 248 \"gram.y\"\n {\n \t\t\
    \t    yyval.defaults = new_default(yyvsp[0].string, NULL, false);\n \t\t\t   \
    \ if (yyval.defaults == NULL) {\n@@ -1420,7 +1425,7 @@ case 20:\n \t\t\t}\n break;\n\
    \ case 21:\n-#line 253 \"gram.y\"\n+#line 255 \"gram.y\"\n {\n \t\t\t    yyval.defaults\
    \ = new_default(yyvsp[-2].string, yyvsp[0].string, true);\n \t\t\t    if (yyval.defaults\
    \ == NULL) {\n@@ -1430,7 +1435,7 @@ case 21:\n \t\t\t}\n break;\n case 22:\n-#line\
    \ 260 \"gram.y\"\n+#line 262 \"gram.y\"\n {\n \t\t\t    yyval.defaults = new_default(yyvsp[-2].string,\
    \ yyvsp[0].string, '+');\n \t\t\t    if (yyval.defaults == NULL) {\n@@ -1440,7\
    \ +1445,7 @@ case 22:\n \t\t\t}\n break;\n case 23:\n-#line 267 \"gram.y\"\n+#line\
    \ 269 \"gram.y\"\n {\n \t\t\t    yyval.defaults = new_default(yyvsp[-2].string,\
    \ yyvsp[0].string, '-');\n \t\t\t    if (yyval.defaults == NULL) {\n@@ -1450,14\
    \ +1455,14 @@ case 23:\n \t\t\t}\n break;\n case 25:\n-#line 277 \"gram.y\"\n\
    +#line 279 \"gram.y\"\n {\n \t\t\t    HLTQ_CONCAT(yyvsp[-2].privilege, yyvsp[0].privilege,\
    \ entries);\n \t\t\t    yyval.privilege = yyvsp[-2].privilege;\n \t\t\t}\n break;\n\
    \ case 26:\n-#line 283 \"gram.y\"\n+#line 285 \"gram.y\"\n {\n \t\t\t    struct\
    \ privilege *p = calloc(1, sizeof(*p));\n \t\t\t    if (p == NULL) {\n@@ -1472,21\
    \ +1477,21 @@ case 26:\n \t\t\t}\n break;\n case 27:\n-#line 297 \"gram.y\"\n\
    +#line 299 \"gram.y\"\n {\n \t\t\t    yyval.member = yyvsp[0].member;\n \t\t\t\
    \    yyval.member->negated = false;\n \t\t\t}\n break;\n case 28:\n-#line 301\
    \ \"gram.y\"\n+#line 303 \"gram.y\"\n {\n \t\t\t    yyval.member = yyvsp[0].member;\n\
    \ \t\t\t    yyval.member->negated = true;\n \t\t\t}\n break;\n case 29:\n-#line\
    \ 307 \"gram.y\"\n+#line 309 \"gram.y\"\n {\n \t\t\t    yyval.member = new_member(yyvsp[0].string,\
    \ ALIAS);\n \t\t\t    if (yyval.member == NULL) {\n@@ -1496,7 +1501,7 @@ case\
    \ 29:\n \t\t\t}\n break;\n case 30:\n-#line 314 \"gram.y\"\n+#line 316 \"gram.y\"\
    \n {\n \t\t\t    yyval.member = new_member(NULL, ALL);\n \t\t\t    if (yyval.member\
    \ == NULL) {\n@@ -1506,7 +1511,7 @@ case 30:\n \t\t\t}\n break;\n case 31:\n-#line\
    \ 321 \"gram.y\"\n+#line 323 \"gram.y\"\n {\n \t\t\t    yyval.member = new_member(yyvsp[0].string,\
    \ NETGROUP);\n \t\t\t    if (yyval.member == NULL) {\n@@ -1516,7 +1521,7 @@ case\
    \ 31:\n \t\t\t}\n break;\n case 32:\n-#line 328 \"gram.y\"\n+#line 330 \"gram.y\"\
    \n {\n \t\t\t    yyval.member = new_member(yyvsp[0].string, NTWKADDR);\n \t\t\t\
    \    if (yyval.member == NULL) {\n@@ -1526,7 +1531,7 @@ case 32:\n \t\t\t}\n break;\n\
    \ case 33:\n-#line 335 \"gram.y\"\n+#line 337 \"gram.y\"\n {\n \t\t\t    yyval.member\
    \ = new_member(yyvsp[0].string, WORD);\n \t\t\t    if (yyval.member == NULL) {\n\
    @@ -1536,7 +1541,7 @@ case 33:\n \t\t\t}\n break;\n case 35:\n-#line 345 \"gram.y\"\
    \n+#line 347 \"gram.y\"\n {\n \t\t\t    struct cmndspec *prev;\n \t\t\t    prev\
    \ = HLTQ_LAST(yyvsp[-2].cmndspec, cmndspec, entries);\n@@ -1590,7 +1595,7 @@ case\
    \ 35:\n \t\t\t}\n break;\n case 36:\n-#line 398 \"gram.y\"\n+#line 400 \"gram.y\"\
    \n {\n \t\t\t    struct cmndspec *cs = calloc(1, sizeof(*cs));\n \t\t\t    if\
    \ (cs == NULL) {\n@@ -1642,7 +1647,7 @@ case 36:\n \t\t\t}\n break;\n case 37:\n\
    -#line 449 \"gram.y\"\n+#line 451 \"gram.y\"\n {\n \t\t\t    yyval.digest = new_digest(SUDO_DIGEST_SHA224,\
    \ yyvsp[0].string);\n \t\t\t    if (yyval.digest == NULL) {\n@@ -1652,7 +1657,7\
    \ @@ case 37:\n \t\t\t}\n break;\n case 38:\n-#line 456 \"gram.y\"\n+#line 458\
    \ \"gram.y\"\n {\n \t\t\t    yyval.digest = new_digest(SUDO_DIGEST_SHA256, yyvsp[0].string);\n\
    \ \t\t\t    if (yyval.digest == NULL) {\n@@ -1662,7 +1667,7 @@ case 38:\n \t\t\
    \t}\n break;\n case 39:\n-#line 463 \"gram.y\"\n+#line 465 \"gram.y\"\n {\n \t\
    \t\t    yyval.digest = new_digest(SUDO_DIGEST_SHA384, yyvsp[0].string);\n \t\t\
    \t    if (yyval.digest == NULL) {\n@@ -1672,7 +1677,7 @@ case 39:\n \t\t\t}\n\
    \ break;\n case 40:\n-#line 470 \"gram.y\"\n+#line 472 \"gram.y\"\n {\n \t\t\t\
    \    yyval.digest = new_digest(SUDO_DIGEST_SHA512, yyvsp[0].string);\n \t\t\t\
    \    if (yyval.digest == NULL) {\n@@ -1682,13 +1687,13 @@ case 40:\n \t\t\t}\n\
    \ break;\n case 41:\n-#line 479 \"gram.y\"\n+#line 481 \"gram.y\"\n {\n \t\t\t\
    \    yyval.member = yyvsp[0].member;\n \t\t\t}\n break;\n case 42:\n-#line 482\
    \ \"gram.y\"\n+#line 484 \"gram.y\"\n {\n \t\t\t    if (yyvsp[0].member->type\
    \ != COMMAND) {\n \t\t\t\tsudoerserror(N_(\"a digest requires a path name\"));\n\
    @@ -1700,75 +1705,75 @@ case 42:\n \t\t\t}\n break;\n case 43:\n-#line 493 \"\
    gram.y\"\n+#line 495 \"gram.y\"\n {\n \t\t\t    yyval.member = yyvsp[0].member;\n\
    \ \t\t\t    yyval.member->negated = false;\n \t\t\t}\n break;\n case 44:\n-#line\
    \ 497 \"gram.y\"\n+#line 499 \"gram.y\"\n {\n \t\t\t    yyval.member = yyvsp[0].member;\n\
    \ \t\t\t    yyval.member->negated = true;\n \t\t\t}\n break;\n case 45:\n-#line\
    \ 503 \"gram.y\"\n+#line 505 \"gram.y\"\n {\n \t\t\t    yyval.string = yyvsp[0].string;\n\
    \ \t\t\t}\n break;\n case 46:\n-#line 508 \"gram.y\"\n+#line 510 \"gram.y\"\n\
    \ {\n \t\t\t    yyval.string = yyvsp[0].string;\n \t\t\t}\n break;\n case 47:\n\
    -#line 512 \"gram.y\"\n+#line 514 \"gram.y\"\n {\n \t\t\t    yyval.string = yyvsp[0].string;\n\
    \ \t\t\t}\n break;\n case 48:\n-#line 517 \"gram.y\"\n+#line 519 \"gram.y\"\n\
    \ {\n \t\t\t    yyval.string = yyvsp[0].string;\n \t\t\t}\n break;\n case 49:\n\
    -#line 522 \"gram.y\"\n+#line 524 \"gram.y\"\n {\n \t\t\t    yyval.string = yyvsp[0].string;\n\
    \ \t\t\t}\n break;\n case 50:\n-#line 527 \"gram.y\"\n+#line 529 \"gram.y\"\n\
    \ {\n \t\t\t    yyval.string = yyvsp[0].string;\n \t\t\t}\n break;\n case 51:\n\
    -#line 531 \"gram.y\"\n+#line 533 \"gram.y\"\n {\n \t\t\t    yyval.string = yyvsp[0].string;\n\
    \ \t\t\t}\n break;\n case 52:\n-#line 536 \"gram.y\"\n+#line 538 \"gram.y\"\n\
    \ {\n \t\t\t    yyval.runas = NULL;\n \t\t\t}\n break;\n case 53:\n-#line 539\
    \ \"gram.y\"\n+#line 541 \"gram.y\"\n {\n \t\t\t    yyval.runas = yyvsp[-1].runas;\n\
    \ \t\t\t}\n break;\n case 54:\n-#line 544 \"gram.y\"\n+#line 546 \"gram.y\"\n\
    \ {\n \t\t\t    yyval.runas = calloc(1, sizeof(struct runascontainer));\n \t\t\
    \t    if (yyval.runas != NULL) {\n@@ -1786,7 +1791,7 @@ case 54:\n \t\t\t}\n break;\n\
    \ case 55:\n-#line 559 \"gram.y\"\n+#line 561 \"gram.y\"\n {\n \t\t\t    yyval.runas\
    \ = calloc(1, sizeof(struct runascontainer));\n \t\t\t    if (yyval.runas == NULL)\
    \ {\n@@ -1798,7 +1803,7 @@ case 55:\n \t\t\t}\n break;\n case 56:\n-#line 568\
    \ \"gram.y\"\n+#line 570 \"gram.y\"\n {\n \t\t\t    yyval.runas = calloc(1, sizeof(struct\
    \ runascontainer));\n \t\t\t    if (yyval.runas == NULL) {\n@@ -1810,7 +1815,7\
    \ @@ case 56:\n \t\t\t}\n break;\n case 57:\n-#line 577 \"gram.y\"\n+#line 579\
    \ \"gram.y\"\n {\n \t\t\t    yyval.runas = calloc(1, sizeof(struct runascontainer));\n\
    \ \t\t\t    if (yyval.runas == NULL) {\n@@ -1822,7 +1827,7 @@ case 57:\n \t\t\t\
    }\n break;\n case 58:\n-#line 586 \"gram.y\"\n+#line 588 \"gram.y\"\n {\n \t\t\
    \t    yyval.runas = calloc(1, sizeof(struct runascontainer));\n \t\t\t    if (yyval.runas\
    \ != NULL) {\n@@ -1840,13 +1845,13 @@ case 58:\n \t\t\t}\n break;\n case 59:\n\
    -#line 603 \"gram.y\"\n+#line 605 \"gram.y\"\n {\n \t\t\t    init_options(&yyval.options);\n\
    \ \t\t\t}\n break;\n case 60:\n-#line 606 \"gram.y\"\n+#line 608 \"gram.y\"\n\
    \ {\n \t\t\t    yyval.options.notbefore = parse_gentime(yyvsp[0].string);\n \t\
    \t\t    free(yyvsp[0].string);\n@@ -1857,7 +1862,7 @@ case 60:\n \t\t\t}\n break;\n\
    \ case 61:\n-#line 614 \"gram.y\"\n+#line 616 \"gram.y\"\n {\n \t\t\t    yyval.options.notafter\
    \ = parse_gentime(yyvsp[0].string);\n \t\t\t    free(yyvsp[0].string);\n@@ -1868,7\
    \ +1873,7 @@ case 61:\n \t\t\t}\n break;\n case 62:\n-#line 622 \"gram.y\"\n+#line\
    \ 624 \"gram.y\"\n {\n \t\t\t    yyval.options.timeout = parse_timeout(yyvsp[0].string);\n\
    \ \t\t\t    free(yyvsp[0].string);\n@@ -1882,7 +1887,7 @@ case 62:\n \t\t\t}\n\
    \ break;\n case 63:\n-#line 633 \"gram.y\"\n+#line 635 \"gram.y\"\n {\n #ifdef\
    \ HAVE_SELINUX\n \t\t\t    free(yyval.options.role);\n@@ -1891,7 +1896,7 @@ case\
    \ 63:\n \t\t\t}\n break;\n case 64:\n-#line 639 \"gram.y\"\n+#line 641 \"gram.y\"\
    \n {\n #ifdef HAVE_SELINUX\n \t\t\t    free(yyval.options.type);\n@@ -1900,7 +1905,7\
    \ @@ case 64:\n \t\t\t}\n break;\n case 65:\n-#line 645 \"gram.y\"\n+#line 647\
    \ \"gram.y\"\n {\n #ifdef HAVE_PRIV_SET\n \t\t\t    free(yyval.options.privs);\n\
    @@ -1909,7 +1914,7 @@ case 65:\n \t\t\t}\n break;\n case 66:\n-#line 651 \"gram.y\"\
    \n+#line 653 \"gram.y\"\n {\n #ifdef HAVE_PRIV_SET\n \t\t\t    free(yyval.options.limitprivs);\n\
    @@ -1918,97 +1923,97 @@ case 66:\n \t\t\t}\n break;\n case 67:\n-#line 659 \"\
    gram.y\"\n+#line 661 \"gram.y\"\n {\n \t\t\t    TAGS_INIT(yyval.tag);\n \t\t\t\
    }\n break;\n case 68:\n-#line 662 \"gram.y\"\n+#line 664 \"gram.y\"\n {\n \t\t\
    \t    yyval.tag.nopasswd = true;\n \t\t\t}\n break;\n case 69:\n-#line 665 \"\
    gram.y\"\n+#line 667 \"gram.y\"\n {\n \t\t\t    yyval.tag.nopasswd = false;\n\
    \ \t\t\t}\n break;\n case 70:\n-#line 668 \"gram.y\"\n+#line 670 \"gram.y\"\n\
    \ {\n \t\t\t    yyval.tag.noexec = true;\n \t\t\t}\n break;\n case 71:\n-#line\
    \ 671 \"gram.y\"\n+#line 673 \"gram.y\"\n {\n \t\t\t    yyval.tag.noexec = false;\n\
    \ \t\t\t}\n break;\n case 72:\n-#line 674 \"gram.y\"\n+#line 676 \"gram.y\"\n\
    \ {\n \t\t\t    yyval.tag.setenv = true;\n \t\t\t}\n break;\n case 73:\n-#line\
    \ 677 \"gram.y\"\n+#line 679 \"gram.y\"\n {\n \t\t\t    yyval.tag.setenv = false;\n\
    \ \t\t\t}\n break;\n case 74:\n-#line 680 \"gram.y\"\n+#line 682 \"gram.y\"\n\
    \ {\n \t\t\t    yyval.tag.log_input = true;\n \t\t\t}\n break;\n case 75:\n-#line\
    \ 683 \"gram.y\"\n+#line 685 \"gram.y\"\n {\n \t\t\t    yyval.tag.log_input =\
    \ false;\n \t\t\t}\n break;\n case 76:\n-#line 686 \"gram.y\"\n+#line 688 \"gram.y\"\
    \n {\n \t\t\t    yyval.tag.log_output = true;\n \t\t\t}\n break;\n case 77:\n\
    -#line 689 \"gram.y\"\n+#line 691 \"gram.y\"\n {\n \t\t\t    yyval.tag.log_output\
    \ = false;\n \t\t\t}\n break;\n case 78:\n-#line 692 \"gram.y\"\n+#line 694 \"\
    gram.y\"\n {\n \t\t\t    yyval.tag.follow = true;\n \t\t\t}\n break;\n case 79:\n\
    -#line 695 \"gram.y\"\n+#line 697 \"gram.y\"\n {\n \t\t\t    yyval.tag.follow\
    \ = false;\n \t\t\t}\n break;\n case 80:\n-#line 698 \"gram.y\"\n+#line 700 \"\
    gram.y\"\n {\n \t\t\t    yyval.tag.send_mail = true;\n \t\t\t}\n break;\n case\
    \ 81:\n-#line 701 \"gram.y\"\n+#line 703 \"gram.y\"\n {\n \t\t\t    yyval.tag.send_mail\
    \ = false;\n \t\t\t}\n break;\n case 82:\n-#line 706 \"gram.y\"\n+#line 708 \"\
    gram.y\"\n {\n \t\t\t    yyval.member = new_member(NULL, ALL);\n \t\t\t    if\
    \ (yyval.member == NULL) {\n@@ -2018,7 +2023,7 @@ case 82:\n \t\t\t}\n break;\n\
    \ case 83:\n-#line 713 \"gram.y\"\n+#line 715 \"gram.y\"\n {\n \t\t\t    yyval.member\
    \ = new_member(yyvsp[0].string, ALIAS);\n \t\t\t    if (yyval.member == NULL)\
    \ {\n@@ -2028,7 +2033,7 @@ case 83:\n \t\t\t}\n break;\n case 84:\n-#line 720\
    \ \"gram.y\"\n+#line 722 \"gram.y\"\n {\n \t\t\t    struct sudo_command *c = calloc(1,\
    \ sizeof(*c));\n \t\t\t    if (c == NULL) {\n@@ -2046,7 +2051,7 @@ case 84:\n\
    \ \t\t\t}\n break;\n case 87:\n-#line 741 \"gram.y\"\n+#line 743 \"gram.y\"\n\
    \ {\n \t\t\t    const char *s;\n \t\t\t    s = alias_add(&parsed_policy, yyvsp[-2].string,\
    \ HOSTALIAS,\n@@ -2058,14 +2063,14 @@ case 87:\n \t\t\t}\n break;\n case 89:\n\
    -#line 753 \"gram.y\"\n+#line 755 \"gram.y\"\n {\n \t\t\t    HLTQ_CONCAT(yyvsp[-2].member,\
    \ yyvsp[0].member, entries);\n \t\t\t    yyval.member = yyvsp[-2].member;\n \t\
    \t\t}\n break;\n case 92:\n-#line 763 \"gram.y\"\n+#line 765 \"gram.y\"\n {\n\
    \ \t\t\t    const char *s;\n \t\t\t    s = alias_add(&parsed_policy, yyvsp[-2].string,\
    \ CMNDALIAS,\n@@ -2077,14 +2082,14 @@ case 92:\n \t\t\t}\n break;\n case 94:\n\
    -#line 775 \"gram.y\"\n+#line 777 \"gram.y\"\n {\n \t\t\t    HLTQ_CONCAT(yyvsp[-2].member,\
    \ yyvsp[0].member, entries);\n \t\t\t    yyval.member = yyvsp[-2].member;\n \t\
    \t\t}\n break;\n case 97:\n-#line 785 \"gram.y\"\n+#line 787 \"gram.y\"\n {\n\
    \ \t\t\t    const char *s;\n \t\t\t    s = alias_add(&parsed_policy, yyvsp[-2].string,\
    \ RUNASALIAS,\n@@ -2096,7 +2101,7 @@ case 97:\n \t\t\t}\n break;\n case 100:\n\
    -#line 800 \"gram.y\"\n+#line 802 \"gram.y\"\n {\n \t\t\t    const char *s;\n\
    \ \t\t\t    s = alias_add(&parsed_policy, yyvsp[-2].string, USERALIAS,\n@@ -2108,28\
    \ +2113,28 @@ case 100:\n \t\t\t}\n break;\n case 102:\n-#line 812 \"gram.y\"\n\
    +#line 814 \"gram.y\"\n {\n \t\t\t    HLTQ_CONCAT(yyvsp[-2].member, yyvsp[0].member,\
    \ entries);\n \t\t\t    yyval.member = yyvsp[-2].member;\n \t\t\t}\n break;\n\
    \ case 103:\n-#line 818 \"gram.y\"\n+#line 820 \"gram.y\"\n {\n \t\t\t    yyval.member\
    \ = yyvsp[0].member;\n \t\t\t    yyval.member->negated = false;\n \t\t\t}\n break;\n\
    \ case 104:\n-#line 822 \"gram.y\"\n+#line 824 \"gram.y\"\n {\n \t\t\t    yyval.member\
    \ = yyvsp[0].member;\n \t\t\t    yyval.member->negated = true;\n \t\t\t}\n break;\n\
    \ case 105:\n-#line 828 \"gram.y\"\n+#line 830 \"gram.y\"\n {\n \t\t\t    yyval.member\
    \ = new_member(yyvsp[0].string, ALIAS);\n \t\t\t    if (yyval.member == NULL)\
    \ {\n@@ -2139,7 +2144,7 @@ case 105:\n \t\t\t}\n break;\n case 106:\n-#line 835\
    \ \"gram.y\"\n+#line 837 \"gram.y\"\n {\n \t\t\t    yyval.member = new_member(NULL,\
    \ ALL);\n \t\t\t    if (yyval.member == NULL) {\n@@ -2149,7 +2154,7 @@ case 106:\n\
    \ \t\t\t}\n break;\n case 107:\n-#line 842 \"gram.y\"\n+#line 844 \"gram.y\"\n\
    \ {\n \t\t\t    yyval.member = new_member(yyvsp[0].string, NETGROUP);\n \t\t\t\
    \    if (yyval.member == NULL) {\n@@ -2159,7 +2164,7 @@ case 107:\n \t\t\t}\n\
    \ break;\n case 108:\n-#line 849 \"gram.y\"\n+#line 851 \"gram.y\"\n {\n \t\t\t\
    \    yyval.member = new_member(yyvsp[0].string, USERGROUP);\n \t\t\t    if (yyval.member\
    \ == NULL) {\n@@ -2169,7 +2174,7 @@ case 108:\n \t\t\t}\n break;\n case 109:\n\
    -#line 856 \"gram.y\"\n+#line 858 \"gram.y\"\n {\n \t\t\t    yyval.member = new_member(yyvsp[0].string,\
    \ WORD);\n \t\t\t    if (yyval.member == NULL) {\n@@ -2179,28 +2184,28 @@ case\
    \ 109:\n \t\t\t}\n break;\n case 111:\n-#line 866 \"gram.y\"\n+#line 868 \"gram.y\"\
    \n {\n \t\t\t    HLTQ_CONCAT(yyvsp[-2].member, yyvsp[0].member, entries);\n \t\
    \t\t    yyval.member = yyvsp[-2].member;\n \t\t\t}\n break;\n case 112:\n-#line\
    \ 872 \"gram.y\"\n+#line 874 \"gram.y\"\n {\n \t\t\t    yyval.member = yyvsp[0].member;\n\
    \ \t\t\t    yyval.member->negated = false;\n \t\t\t}\n break;\n case 113:\n-#line\
    \ 876 \"gram.y\"\n+#line 878 \"gram.y\"\n {\n \t\t\t    yyval.member = yyvsp[0].member;\n\
    \ \t\t\t    yyval.member->negated = true;\n \t\t\t}\n break;\n case 114:\n-#line\
    \ 882 \"gram.y\"\n+#line 884 \"gram.y\"\n {\n \t\t\t    yyval.member = new_member(yyvsp[0].string,\
    \ ALIAS);\n \t\t\t    if (yyval.member == NULL) {\n@@ -2210,7 +2215,7 @@ case\
    \ 114:\n \t\t\t}\n break;\n case 115:\n-#line 889 \"gram.y\"\n+#line 891 \"gram.y\"\
    \n {\n \t\t\t    yyval.member = new_member(NULL, ALL);\n \t\t\t    if (yyval.member\
    \ == NULL) {\n@@ -2220,7 +2225,7 @@ case 115:\n \t\t\t}\n break;\n case 116:\n\
    -#line 896 \"gram.y\"\n+#line 898 \"gram.y\"\n {\n \t\t\t    yyval.member = new_member(yyvsp[0].string,\
    \ WORD);\n \t\t\t    if (yyval.member == NULL) {\n@@ -2229,7 +2234,7 @@ case 116:\n\
    \ \t\t\t    }\n \t\t\t}\n break;\n-#line 2175 \"gram.c\"\n+#line 2180 \"gram.c\"\
    \n     }\n     yyssp -= yym;\n     yystate = *yyssp;"
  - "--- a/plugins/sudoers/ldap.c\n+++ b/plugins/sudoers/ldap.c\n@@ -1665,7 +1665,7\
    \ @@ sudo_ldap_open(struct sudo_nss *nss)\n     }\n     handle->ld = ld;\n   \
    \  /* handle->pw = NULL; */\n-    init_parse_tree(&handle->parse_tree);\n+   \
    \ init_parse_tree(&handle->parse_tree, NULL, NULL);\n     nss->handle = handle;\n\
    \ \n done:"
  - "--- a/plugins/sudoers/match.c\n+++ b/plugins/sudoers/match.c\n@@ -72,8 +72,10\
    \ @@ int\n user_matches(struct sudoers_parse_tree *parse_tree, const struct passwd\
    \ *pw,\n     const struct member *m)\n {\n-    struct alias *a;\n+    const char\
    \ *lhost = parse_tree->lhost ? parse_tree->lhost : user_runhost;\n+    const char\
    \ *shost = parse_tree->shost ? parse_tree->shost : user_srunhost;\n     int matched\
    \ = UNSPEC;\n+    struct alias *a;\n     debug_decl(user_matches, SUDOERS_DEBUG_MATCH)\n\
    \ \n     switch (m->type) {\n@@ -82,8 +84,8 @@ user_matches(struct sudoers_parse_tree\
    \ *parse_tree, const struct passwd *pw,\n \t    break;\n \tcase NETGROUP:\n \t\
    \    if (netgr_matches(m->name,\n-\t\tdef_netgroup_tuple ? user_runhost : NULL,\n\
    -\t\tdef_netgroup_tuple ? user_srunhost : NULL, pw->pw_name))\n+\t\tdef_netgroup_tuple\
    \ ? lhost : NULL,\n+\t\tdef_netgroup_tuple ? shost : NULL, pw->pw_name))\n \t\t\
    matched = !m->negated;\n \t    break;\n \tcase USERGROUP:\n@@ -153,11 +155,13\
    \ @@ runaslist_matches(struct sudoers_parse_tree *parse_tree,\n     const struct\
    \ member_list *user_list, const struct member_list *group_list,\n     struct member\
    \ **matching_user, struct member **matching_group)\n {\n+    const char *lhost\
    \ = parse_tree->lhost ? parse_tree->lhost : user_runhost;\n+    const char *shost\
    \ = parse_tree->shost ? parse_tree->shost : user_srunhost;\n+    int user_matched\
    \ = UNSPEC;\n+    int group_matched = UNSPEC;\n     struct member *m;\n     struct\
    \ alias *a;\n     int rc;\n-    int user_matched = UNSPEC;\n-    int group_matched\
    \ = UNSPEC;\n     debug_decl(runaslist_matches, SUDOERS_DEBUG_MATCH)\n \n    \
    \ if (ISSET(sudo_user.flags, RUNAS_USER_SPECIFIED) || !ISSET(sudo_user.flags,\
    \ RUNAS_GROUP_SPECIFIED)) {\n@@ -175,8 +179,8 @@ runaslist_matches(struct sudoers_parse_tree\
    \ *parse_tree,\n \t\t\tbreak;\n \t\t    case NETGROUP:\n \t\t\tif (netgr_matches(m->name,\n\
    -\t\t\t    def_netgroup_tuple ? user_runhost : NULL,\n-\t\t\t    def_netgroup_tuple\
    \ ? user_srunhost : NULL,\n+\t\t\t    def_netgroup_tuple ? lhost : NULL,\n+\t\t\
    \t    def_netgroup_tuple ? shost : NULL,\n \t\t\t    runas_pw->pw_name))\n \t\t\
    \t    user_matched = !m->negated;\n \t\t\tbreak;\n@@ -309,7 +313,10 @@ int\n hostlist_matches(struct\
    \ sudoers_parse_tree *parse_tree, const struct passwd *pw,\n     const struct\
    \ member_list *list)\n {\n-    return hostlist_matches_int(parse_tree, pw, user_runhost,\
    \ user_srunhost, list);\n+    const char *lhost = parse_tree->lhost ? parse_tree->lhost\
    \ : user_runhost;\n+    const char *shost = parse_tree->shost ? parse_tree->shost\
    \ : user_srunhost;\n+\n+    return hostlist_matches_int(parse_tree, pw, lhost,\
    \ shost, list);\n }\n \n /*"
  - "--- a/plugins/sudoers/sssd.c\n+++ b/plugins/sudoers/sssd.c\n@@ -554,7 +554,6\
    \ @@ sudo_sss_open(struct sudo_nss *nss)\n \tsudo_warnx(U_(\"%s: %s\"), __func__,\
    \ U_(\"unable to allocate memory\"));\n \tdebug_return_int(ENOMEM);\n     }\n\
    -    init_parse_tree(&handle->parse_tree);\n \n     /* Load symbols */\n     handle->ssslib\
    \ = sudo_dso_load(path, SUDO_DSO_LAZY);\n@@ -612,8 +611,6 @@ sudo_sss_open(struct\
    \ sudo_nss *nss)\n \tdebug_return_int(EFAULT);\n     }\n \n-    nss->handle =\
    \ handle;\n-\n     /*\n      * If runhost is the same as the local host, check\
    \ for ipa_hostname\n      * in sssd.conf and use it in preference to user_runhost.\n\
    @@ -625,6 +622,10 @@ sudo_sss_open(struct sudo_nss *nss)\n \t}\n     }\n \n+ \
    \   /* The \"parse tree\" contains userspecs, defaults, aliases and hostnames.\
    \ */\n+    init_parse_tree(&handle->parse_tree, handle->ipa_host, handle->ipa_shost);\n\
    +    nss->handle = handle;\n+\n     sudo_debug_printf(SUDO_DEBUG_DEBUG, \"handle=%p\"\
    , handle);\n \n     debug_return_int(0);"
  identifiers: CVE:["CVE-2023-7090"],CWE:["CWE-270"]
  overview: Affected versions of this package are vulnerable to Privilege Context
    Switching Error due to the mishandling of `ipa_hostname` from `/etc/sssd/sssd.conf`,
    which is not properly propagated. As a result, client hosts may retain privileges
    even after such privileges have been retracted.
  references:
    Fix Commit: https://www.sudo.ws/repos/sudo/rev/b4f31dbe3109
    GitHub Commit: https://github.com/sudo-project/sudo/commit/e99082e05b9f0dd0e0f47fa1d2e1b9d922ea8c4c
    RedHat Bugzilla Bug: https://bugzilla.redhat.com/show_bug.cgi?id=2255723
    Release Notes: https://www.sudo.ws/releases/legacy/#1.8.28
  title: Privilege Context Switching Error
- diff_content:
  - "--- a/plugins/codecs/zfp/blosc2-zfp.c\n+++ b/plugins/codecs/zfp/blosc2-zfp.c\n\
    @@ -26,6 +26,7 @@ int zfp_acc_compress(const uint8_t *input, int32_t input_len,\
    \ uint8_t *output,\n   ZFP_ERROR_NULL(input);\n   ZFP_ERROR_NULL(output);\n  \
    \ ZFP_ERROR_NULL(cparams);\n+  ZFP_ERROR_NULL(cparams->schunk);\n \n   double\
    \ tol = (int8_t) meta;\n   int8_t ndim;\n@@ -146,6 +147,7 @@ int zfp_acc_decompress(const\
    \ uint8_t *input, int32_t input_len, uint8_t *output,\n   ZFP_ERROR_NULL(input);\n\
    \   ZFP_ERROR_NULL(output);\n   ZFP_ERROR_NULL(dparams);\n+  ZFP_ERROR_NULL(dparams->schunk);\n\
    \   BLOSC_UNUSED_PARAM(chunk);\n \n   blosc2_schunk *sc = dparams->schunk;\n@@\
    \ -241,6 +243,7 @@ int zfp_prec_compress(const uint8_t *input, int32_t input_len,\
    \ uint8_t *output,\n   ZFP_ERROR_NULL(input);\n   ZFP_ERROR_NULL(output);\n  \
    \ ZFP_ERROR_NULL(cparams);\n+  ZFP_ERROR_NULL(cparams->schunk);\n \n   int8_t\
    \ ndim;\n   int64_t *shape = malloc(8 * sizeof(int64_t));\n@@ -385,6 +388,7 @@\
    \ int zfp_prec_decompress(const uint8_t *input, int32_t input_len, uint8_t *output\n\
    \   ZFP_ERROR_NULL(input);\n   ZFP_ERROR_NULL(output);\n   ZFP_ERROR_NULL(dparams);\n\
    +  ZFP_ERROR_NULL(dparams->schunk);\n   BLOSC_UNUSED_PARAM(chunk);\n \n   blosc2_schunk\
    \ *sc = dparams->schunk;\n@@ -504,6 +508,7 @@ int zfp_rate_compress(const uint8_t\
    \ *input, int32_t input_len, uint8_t *output,\n   ZFP_ERROR_NULL(input);\n   ZFP_ERROR_NULL(output);\n\
    \   ZFP_ERROR_NULL(cparams);\n+  ZFP_ERROR_NULL(cparams->schunk);\n \n   double\
    \ ratio = (double) meta / 100.0;\n   int8_t ndim;\n@@ -635,6 +640,7 @@ int zfp_rate_decompress(const\
    \ uint8_t *input, int32_t input_len, uint8_t *output\n   ZFP_ERROR_NULL(input);\n\
    \   ZFP_ERROR_NULL(output);\n   ZFP_ERROR_NULL(dparams);\n+  ZFP_ERROR_NULL(dparams->schunk);\n\
    \   BLOSC_UNUSED_PARAM(chunk);\n \n   blosc2_schunk *sc = dparams->schunk;"
  identifiers: CVE:["CVE-2023-37187"],CWE:["CWE-476"]
  overview: Affected versions of this package are vulnerable to NULL Pointer Dereference
    via the `zfp_acc_decompress()` function. An attacker can cause a crash by passing
    in a malicious file.
  references:
    GitHub Commit: https://github.com/Blosc/c-blosc2/commit/425e8a9a59d49378d57e2116b6c9b0190a5986f5
    GitHub Diff: https://github.com/Blosc/c-blosc2/compare/v2.9.2...v2.9.3
    GitHub Issue: https://github.com/Blosc/c-blosc2/issues/520
  title: NULL Pointer Dereference
- diff_content:
  - "--- a/reader/document/Model.cpp\n+++ b/reader/document/Model.cpp\n@@ -13,6 +13,7\
    \ @@\n #include <QFile>\n #include <QDir>\n #include <QTimer>\n+#include <QTemporaryFile>\n\
    \ \n namespace deepin_reader {\n deepin_reader::Document *deepin_reader::DocumentFactory::getDocument(const\
    \ int &fileType,\n@@ -77,7 +78,10 @@ deepin_reader::Document *deepin_reader::DocumentFactory::getDocument(const\
    \ int &\n             return nullptr;\n         }\n         qDebug() << \"\u6587\
    \u6863\u89E3\u538B\u5B8C\u6210\";\n-\n+        QTemporaryFile tmpFile(convertedFileDir\
    \ + \"/word/\" + QCoreApplication::applicationName() + \"_XXXXXX.html\");\n+ \
    \       if( tmpFile.open()) { //fix 232871\n+             tmpHtmlFilePath = tmpFile.fileName();\
    \ // returns the unique file name\n+         }\n         // docx -> html\n   \
    \      QProcess converter;\n         *pprocess = &converter;"
  identifiers: CVE:["CVE-2023-50254"],CWE:["CWE-27"]
  overview: Affected versions of this package are vulnerable to Path Traversal due
    to improper handling of docx file paths. An attacker can overwrite critical files
    and execute arbitrary code by convincing a user to open a malicious document.
  references:
    Changelog: https://github.com/linuxdeepin/deepin-reader/commit/4db7a079fb7bd77257b1b9208a7ab26aade8fe04
    GitHub Commit: https://github.com/linuxdeepin/deepin-reader/commit/c192fd20a2fe4003e0581c3164489a89e06420c6
  title: Path Traversal
- diff_content:
  - "--- a/src/network/access/http2/hpacktable.cpp\n+++ b/src/network/access/http2/hpacktable.cpp\n\
    @@ -26,7 +26,9 @@ HeaderSize entry_size(QByteArrayView name, QByteArrayView value)\n\
    \     // for counting the number of references to the name and value would have\n\
    \     // 32 octets of overhead.\"\n \n-    const unsigned sum = unsigned(name.size()\
    \ + value.size());\n+    size_t sum;\n+    if (qAddOverflow(size_t(name.size()),\
    \ size_t(value.size()), &sum))\n+        return HeaderSize();\n     if (sum >\
    \ (std::numeric_limits<unsigned>::max() - 32))\n         return HeaderSize();\n\
    \     return HeaderSize(true, quint32(sum + 32));"
  identifiers: CVE:["CVE-2023-51714"],CWE:["CWE-680"]
  overview: Affected versions of this package are vulnerable to Integer Overflow to
    Buffer Overflow due to an incorrect HPack integer overflow check in `hpacktable.cpp`.
    An attacker can cause a buffer overflow by sending crafted HTTP2 requests.
  references:
    GitHub Commit: https://github.com/qt/qtbase/commit/ee5da1f2eaf8932aeca02ffea6e4c618585e29e3
  title: Integer Overflow to Buffer Overflow
- diff_content:
  - "--- a/src/resolve/resolved-dns-transaction.c\n+++ b/src/resolve/resolved-dns-transaction.c\n\
    @@ -2808,7 +2808,7 @@ static int dns_transaction_requires_rrsig(DnsTransaction\
    \ *t, DnsResourceRecord *\n                         if (r == 0)\n            \
    \                     continue;\n \n-                        return FLAGS_SET(t->answer_query_flags,\
    \ SD_RESOLVED_AUTHENTICATED);\n+                        return FLAGS_SET(dt->answer_query_flags,\
    \ SD_RESOLVED_AUTHENTICATED);\n                 }\n \n                 return\
    \ true;\n@@ -2835,7 +2835,7 @@ static int dns_transaction_requires_rrsig(DnsTransaction\
    \ *t, DnsResourceRecord *\n                         /* We found the transaction\
    \ that was supposed to find the SOA RR for us. It was\n                      \
    \    * successful, but found no RR for us. This means we are not at a zone cut.\
    \ In this\n                          * case, we require authentication if the\
    \ SOA lookup was authenticated too. */\n-                        return FLAGS_SET(t->answer_query_flags,\
    \ SD_RESOLVED_AUTHENTICATED);\n+                        return FLAGS_SET(dt->answer_query_flags,\
    \ SD_RESOLVED_AUTHENTICATED);\n                 }\n \n                 return\
    \ true;"
  identifiers: CVE:["CVE-2023-7008"],CWE:["CWE-345"]
  overview: Affected versions of this package are vulnerable to Insufficient Verification
    of Data Authenticity due to improper validation of DNSSEC signatures in `systemd-resolved`.
    If the default `DNSSEC=no` option has been changed to `yes`, an attacker in a
    MitM position can manipulate DNS records.
  references:
    GitHub Commit: https://github.com/systemd/systemd-stable/commit/6da5ca9dd69c0e3340d4439413718ad4963252de
    GitHub Issue: https://github.com/systemd/systemd/issues/25676
    RedHat Bugzilla Bug: https://bugzilla.redhat.com/show_bug.cgi?id=2222672
    RedHat CVE Database: https://access.redhat.com/security/cve/CVE-2023-7008
  title: Insufficient Verification of Data Authenticity
- diff_content:
  - "--- a/plugins/sudoers/auth/passwd.c\n+++ b/plugins/sudoers/auth/passwd.c\n@@\
    \ -68,7 +68,7 @@ sudo_passwd_verify(const struct sudoers_context *ctx, struct\
    \ passwd *pw,\n     char des_pass[9], *epass;\n     char *pw_epasswd = auth->data;\n\
    \     size_t pw_len;\n-    int matched = 0;\n+    int ret;\n     debug_decl(sudo_passwd_verify,\
    \ SUDOERS_DEBUG_AUTH);\n \n     /* An empty plain-text password must match an\
    \ empty encrypted password. */\n@@ -80,7 +80,7 @@ sudo_passwd_verify(const struct\
    \ sudoers_context *ctx, struct passwd *pw,\n      */\n     pw_len = strlen(pw_epasswd);\n\
    \     if (pw_len == DESLEN || HAS_AGEINFO(pw_epasswd, pw_len)) {\n-\tstrlcpy(des_pass,\
    \ pass, sizeof(des_pass));\n+\t(void)strlcpy(des_pass, pass, sizeof(des_pass));\n\
    \ \tpass = des_pass;\n     }\n \n@@ -90,30 +90,37 @@ sudo_passwd_verify(const\
    \ struct sudoers_context *ctx, struct passwd *pw,\n      * only compare the first\
    \ DESLEN characters in that case.\n      */\n     epass = (char *) crypt(pass,\
    \ pw_epasswd);\n+    ret = AUTH_FAILURE;\n     if (epass != NULL) {\n-\tif (HAS_AGEINFO(pw_epasswd,\
    \ pw_len) && strlen(epass) == DESLEN)\n-\t    matched = !strncmp(pw_epasswd, epass,\
    \ DESLEN);\n-\telse\n-\t    matched = !strcmp(pw_epasswd, epass);\n+\tif (HAS_AGEINFO(pw_epasswd,\
    \ pw_len) && strlen(epass) == DESLEN) {\n+\t    if (strncmp(pw_epasswd, epass,\
    \ DESLEN) == 0)\n+\t\tret = AUTH_SUCCESS;\n+\t} else {\n+\t    if (strcmp(pw_epasswd,\
    \ epass) == 0)\n+\t\tret = AUTH_SUCCESS;\n+\t}\n     }\n \n     explicit_bzero(des_pass,\
    \ sizeof(des_pass));\n \n-    debug_return_int(matched ? AUTH_SUCCESS : AUTH_FAILURE);\n\
    +    debug_return_int(ret);\n }\n #else\n int\n sudo_passwd_verify(const struct\
    \ sudoers_context *ctx, struct passwd *pw,\n     const char *pass, sudo_auth *auth,\
    \ struct sudo_conv_callback *callback)\n {\n     char *pw_passwd = auth->data;\n\
    -    int matched;\n+    int ret;\n     debug_decl(sudo_passwd_verify, SUDOERS_DEBUG_AUTH);\n\
    \ \n     /* Simple string compare for systems without crypt(). */\n-    matched\
    \ = !strcmp(pass, pw_passwd);\n+    if (strcmp(pass, pw_passwd) == 0)\n+\tret\
    \ = AUTH_SUCCESS;\n+    else\n+\tret = AUTH_FAILURE;\n \n-    debug_return_int(matched\
    \ ? AUTH_SUCCESS : AUTH_FAILURE);\n+    debug_return_int(ret);\n }\n #endif\n "
  - "--- a/plugins/sudoers/auth/sudo_auth.c\n+++ b/plugins/sudoers/auth/sudo_auth.c\n\
    @@ -116,10 +116,16 @@ sudo_auth_init(const struct sudoers_context *ctx, struct\
    \ passwd *pw,\n \tif (auth->init && !IS_DISABLED(auth)) {\n \t    /* Disable if\
    \ it failed to init unless there was a fatal error. */\n \t    status = (auth->init)(ctx,\
    \ pw, auth);\n-\t    if (status == AUTH_FAILURE)\n+\t    switch (status) {\n+\t\
    \    case AUTH_SUCCESS:\n+\t\tbreak;\n+\t    case AUTH_FAILURE:\n \t\tSET(auth->flags,\
    \ FLAG_DISABLED);\n-\t    else if (status == AUTH_ERROR)\n-\t\tbreak;\t\t/* assume\
    \ error msg already printed */\n+\t\tbreak;\n+\t    default:\n+\t\t/* Assume error\
    \ msg already printed. */\n+\t\tdebug_return_int(-1);\n+\t    }\n \t}\n     }\n\
    \ \n@@ -166,7 +172,7 @@ sudo_auth_init(const struct sudoers_context *ctx, struct\
    \ passwd *pw,\n \t}\n     }\n \n-    debug_return_int(status == AUTH_ERROR ? -1\
    \ : 0);\n+    debug_return_int(0);\n }\n \n /*\n@@ -209,7 +215,7 @@ sudo_auth_cleanup(const\
    \ struct sudoers_context *ctx, struct passwd *pw,\n     for (auth = auth_switch;\
    \ auth->name; auth++) {\n \tif (auth->cleanup && !IS_DISABLED(auth)) {\n \t  \
    \  int status = (auth->cleanup)(ctx, pw, auth, force);\n-\t    if (status == AUTH_ERROR)\
    \ {\n+\t    if (status != AUTH_SUCCESS) {\n \t\t/* Assume error msg already printed.\
    \ */\n \t\tdebug_return_int(-1);\n \t    }\n@@ -306,7 +312,7 @@ verify_user(const\
    \ struct sudoers_context *ctx, struct passwd *pw, char *prompt,\n \t\t    SET(auth->flags,\
    \ FLAG_DISABLED);\n \t\telse if (status == AUTH_NONINTERACTIVE)\n \t\t    goto\
    \ done;\n-\t\telse if (status == AUTH_ERROR || user_interrupted())\n+\t\telse\
    \ if (status != AUTH_SUCCESS || user_interrupted())\n \t\t    goto done;\t\t/*\
    \ assume error msg already printed */\n \t    }\n \t}\n@@ -365,7 +371,6 @@ verify_user(const\
    \ struct sudoers_context *ctx, struct passwd *pw, char *prompt,\n \tcase AUTH_NONINTERACTIVE:\n\
    \ \t    SET(validated, FLAG_NO_USER_INPUT);\n \t    FALLTHROUGH;\n-\tcase AUTH_ERROR:\n\
    \ \tdefault:\n \t    log_auth_failure(ctx, validated, 0);\n \t    ret = -1;\n\
    @@ -377,25 +382,33 @@ verify_user(const struct sudoers_context *ctx, struct passwd\
    \ *pw, char *prompt,\n \n /*\n  * Call authentication method begin session hooks.\n\
    - * Returns 1 on success and -1 on error.\n+ * Returns true on success, false\
    \ on failure and -1 on error.\n  */\n int\n sudo_auth_begin_session(const struct\
    \ sudoers_context *ctx, struct passwd *pw,\n     char **user_env[])\n {\n    \
    \ sudo_auth *auth;\n+    int ret = true;\n     debug_decl(sudo_auth_begin_session,\
    \ SUDOERS_DEBUG_AUTH);\n \n     for (auth = auth_switch; auth->name; auth++) {\n\
    \ \tif (auth->begin_session && !IS_DISABLED(auth)) {\n \t    int status = (auth->begin_session)(ctx,\
    \ pw, user_env, auth);\n-\t    if (status != AUTH_SUCCESS) {\n+\t    switch (status)\
    \ {\n+\t    case AUTH_SUCCESS:\n+\t\tbreak;\n+\t    case AUTH_FAILURE:\n+\t\t\
    ret = false;\n+\t\tbreak;\n+\t    default:\n \t\t/* Assume error msg already printed.\
    \ */\n-\t\tdebug_return_int(-1);\n+\t\tret = -1;\n+\t\tbreak;\n \t    }\n \t}\n\
    \     }\n-    debug_return_int(1);\n+    debug_return_int(ret);\n }\n \n bool\n\
    @@ -416,25 +429,33 @@ sudo_auth_needs_end_session(void)\n \n /*\n  * Call authentication\
    \ method end session hooks.\n- * Returns 1 on success and -1 on error.\n+ * Returns\
    \ true on success, false on failure and -1 on error.\n  */\n int\n sudo_auth_end_session(void)\n\
    \ {\n     sudo_auth *auth;\n+    int ret = true;\n     int status;\n     debug_decl(sudo_auth_end_session,\
    \ SUDOERS_DEBUG_AUTH);\n \n     for (auth = auth_switch; auth->name; auth++) {\n\
    \ \tif (auth->end_session && !IS_DISABLED(auth)) {\n \t    status = (auth->end_session)(auth);\n\
    -\t    if (status == AUTH_ERROR) {\n+\t    switch (status) {\n+\t    case AUTH_SUCCESS:\n\
    +\t\tbreak;\n+\t    case AUTH_FAILURE:\n+\t\tret = false;\n+\t\tbreak;\n+\t  \
    \  default:\n \t\t/* Assume error msg already printed. */\n-\t\tdebug_return_int(-1);\n\
    +\t\tret = -1;\n+\t\tbreak;\n \t    }\n \t}\n     }\n-    debug_return_int(1);\n\
    +    debug_return_int(ret);\n }\n \n /*"
  - "--- a/plugins/sudoers/lookup.c\n+++ b/plugins/sudoers/lookup.c\n@@ -100,7 +100,7\
    \ @@ sudoers_lookup_pseudo(struct sudo_nss_list *snl, struct sudoers_context *ctx,\n\
    \ \t    int user_match = userlist_matches(nss->parse_tree, ctx->user.pw,\n \t\t\
    &us->users);\n \t    if (user_match != ALLOW) {\n-\t\tif (callback != NULL &&\
    \ user_match != UNSPEC) {\n+\t\tif (callback != NULL && user_match == DENY) {\n\
    \ \t\t    callback(nss->parse_tree, us, user_match, NULL, UNSPEC,\n \t\t\tNULL,\
    \ UNSPEC, UNSPEC, UNSPEC, cb_data);\n \t\t}\n@@ -189,7 +189,7 @@ sudoers_lookup_pseudo(struct\
    \ sudo_nss_list *snl, struct sudoers_context *ctx,\n \t\t\t    host_match, cs,\
    \ date_match, runas_match,\n \t\t\t    cmnd_match, cb_data);\n \t\t    }\n-\t\t\
    \    if (cmnd_match != UNSPEC) {\n+\t\t    if (SPECIFIED(cmnd_match)) {\n \t\t\
    \t/*\n \t\t\t * We take the last match but must process\n \t\t\t * the entire\
    \ policy for pwcheck == all.\n@@ -245,7 +245,7 @@ sudoers_lookup_check(struct\
    \ sudo_nss *nss, struct sudoers_context *ctx,\n     TAILQ_FOREACH_REVERSE(us,\
    \ &nss->parse_tree->userspecs, userspec_list, entries) {\n \tint user_match =\
    \ userlist_matches(nss->parse_tree, ctx->user.pw, &us->users);\n \tif (user_match\
    \ != ALLOW) {\n-\t    if (callback != NULL && user_match != UNSPEC) {\n+\t   \
    \ if (callback != NULL && user_match == DENY) {\n \t\tcallback(nss->parse_tree,\
    \ us, user_match, NULL, UNSPEC, NULL,\n \t\t    UNSPEC, UNSPEC, UNSPEC, cb_data);\n\
    \ \t    }\n@@ -290,7 +290,7 @@ sudoers_lookup_check(struct sudo_nss *nss, struct\
    \ sudoers_context *ctx,\n \t\t\tcs, date_match, runas_match, cmnd_match, cb_data);\n\
    \ \t\t}\n \n-\t\tif (cmnd_match != UNSPEC) {\n+\t\tif (SPECIFIED(cmnd_match))\
    \ {\n \t\t    /*\n \t\t     * If user is running command as themselves,\n \t\t\
    \     * set ctx->runas.pw = ctx->user.pw.\n@@ -542,15 +542,15 @@ sudoers_lookup(struct\
    \ sudo_nss_list *snl, struct sudoers_context *ctx,\n \n \tm = sudoers_lookup_check(nss,\
    \ ctx, &validated, &info, now, callback,\n \t    cb_data, &cs, &defs);\n-\tif\
    \ (m != UNSPEC) {\n+\tif (SPECIFIED(m)) {\n \t    match = m;\n \t    parse_tree\
    \ = nss->parse_tree;\n \t}\n \n \tif (!sudo_nss_can_continue(nss, m))\n \t   \
    \ break;\n     }\n-    if (match != UNSPEC) {\n+    if (SPECIFIED(match)) {\n\
    \ \tif (info.cmnd_path != NULL) {\n \t    /* Update cmnd, cmnd_stat, cmnd_status\
    \ from matching entry. */\n \t    free(ctx->user.cmnd);"
  - "--- a/plugins/sudoers/match.c\n+++ b/plugins/sudoers/match.c\n@@ -91,7 +91,7\
    \ @@ user_matches(const struct sudoers_parse_tree *parse_tree,\n \t    if ((a\
    \ = alias_get(parse_tree, m->name, USERALIAS)) != NULL) {\n \t\t/* XXX */\n \t\
    \tconst int rc = userlist_matches(parse_tree, pw, &a->members);\n-\t\tif (rc !=\
    \ UNSPEC) {\n+\t\tif (SPECIFIED(rc)) {\n \t\t    if (m->negated) {\n \t\t\tmatched\
    \ = rc == ALLOW ? DENY : ALLOW;\n \t\t    } else {\n@@ -123,7 +123,8 @@ userlist_matches(const\
    \ struct sudoers_parse_tree *parse_tree,\n     debug_decl(userlist_matches, SUDOERS_DEBUG_MATCH);\n\
    \ \n     TAILQ_FOREACH_REVERSE(m, list, member_list, entries) {\n-\tif ((matched\
    \ = user_matches(parse_tree, pw, m)) != UNSPEC)\n+\tmatched = user_matches(parse_tree,\
    \ pw, m);\n+\tif (SPECIFIED(matched))\n \t    break;\n     }\n     debug_return_int(matched);\n\
    @@ -184,7 +185,7 @@ runas_userlist_matches(const struct sudoers_parse_tree *parse_tree,\n\
    \ \t\tif (a != NULL) {\n \t\t    const int rc = runas_userlist_matches(parse_tree,\n\
    \ \t\t\t&a->members, matching_user);\n-\t\t    if (rc != UNSPEC) {\n+\t\t    if\
    \ (SPECIFIED(rc)) {\n \t\t\tif (m->negated) {\n \t\t\t    user_matched = rc ==\
    \ ALLOW ? DENY : ALLOW;\n \t\t\t} else {\n@@ -211,7 +212,7 @@ runas_userlist_matches(const\
    \ struct sudoers_parse_tree *parse_tree,\n \t\t    user_matched = m->negated ?\
    \ DENY : ALLOW;\n \t\tbreak;\n \t}\n-\tif (user_matched != UNSPEC) {\n+\tif (SPECIFIED(user_matched))\
    \ {\n \t    if (matching_user != NULL && m->type != ALIAS)\n \t\t*matching_user\
    \ = m;\n \t    break;\n@@ -246,7 +247,7 @@ runas_grouplist_matches(const struct\
    \ sudoers_parse_tree *parse_tree,\n \t\t    if (a != NULL) {\n \t\t\tconst int\
    \ rc = runas_grouplist_matches(parse_tree,\n \t\t\t    &a->members, matching_group);\n\
    -\t\t\tif (rc != UNSPEC) {\n+\t\t\tif (SPECIFIED(rc)) {\n \t\t\t    if (m->negated)\
    \ {\n \t\t\t\tgroup_matched = rc == ALLOW ? DENY : ALLOW;\n \t\t\t    } else {\n\
    @@ -262,14 +263,14 @@ runas_grouplist_matches(const struct sudoers_parse_tree\
    \ *parse_tree,\n \t\t\tgroup_matched = m->negated ? DENY : ALLOW;\n \t\t    break;\n\
    \ \t    }\n-\t    if (group_matched != UNSPEC) {\n+\t    if (SPECIFIED(group_matched))\
    \ {\n \t\tif (matching_group != NULL && m->type != ALIAS)\n \t\t    *matching_group\
    \ = m;\n \t\tbreak;\n \t    }\n \t}\n     }\n-    if (group_matched == UNSPEC)\
    \ {\n+    if (!SPECIFIED(group_matched)) {\n \tstruct gid_list *runas_groups;\n\
    \ \t/*\n \t * The runas group was not explicitly allowed by sudoers.\n@@ -349,7\
    \ +350,7 @@ hostlist_matches_int(const struct sudoers_parse_tree *parse_tree,\n\
    \ \n     TAILQ_FOREACH_REVERSE(m, list, member_list, entries) {\n \tmatched =\
    \ host_matches(parse_tree, pw, lhost, shost, m);\n-\tif (matched != UNSPEC)\n\
    +\tif (SPECIFIED(matched))\n \t    break;\n     }\n     debug_return_int(matched);\n\
    @@ -402,7 +403,7 @@ host_matches(const struct sudoers_parse_tree *parse_tree,\n\
    \ \t\t/* XXX */\n \t\tconst int rc = hostlist_matches_int(parse_tree, pw, lhost,\n\
    \ \t\t    shost, &a->members);\n-\t\tif (rc != UNSPEC) {\n+\t\tif (SPECIFIED(rc))\
    \ {\n \t\t    if (m->negated) {\n \t\t\tmatched = rc == ALLOW ? DENY : ALLOW;\n\
    \ \t\t    } else {\n@@ -440,7 +441,7 @@ cmndlist_matches(const struct sudoers_parse_tree\
    \ *parse_tree,\n \n     TAILQ_FOREACH_REVERSE(m, list, member_list, entries) {\n\
    \ \tmatched = cmnd_matches(parse_tree, m, runchroot, info);\n-\tif (matched !=\
    \ UNSPEC)\n+\tif (SPECIFIED(matched))\n \t    break;\n     }\n     debug_return_int(matched);\n\
    @@ -471,7 +472,7 @@ cmnd_matches(const struct sudoers_parse_tree *parse_tree,\n\
    \ \t    a = alias_get(parse_tree, m->name, CMNDALIAS);\n \t    if (a != NULL)\
    \ {\n \t\trc = cmndlist_matches(parse_tree, &a->members, runchroot, info);\n-\t\
    \tif (rc != UNSPEC) {\n+\t\tif (SPECIFIED(rc)) {\n \t\t    if (m->negated) {\n\
    \ \t\t\tmatched = rc == ALLOW ? DENY : ALLOW;\n \t\t    } else {\n@@ -511,7 +512,7\
    \ @@ cmnd_matches_all(const struct sudoers_parse_tree *parse_tree,\n \t    if\
    \ (a != NULL) {\n \t\tTAILQ_FOREACH_REVERSE(m, &a->members, member_list, entries)\
    \ {\n \t\t    matched = cmnd_matches_all(parse_tree, m, runchroot, info);\n-\t\
    \t    if (matched != UNSPEC) {\n+\t\t    if (SPECIFIED(matched)) {\n \t\t\tif\
    \ (negated)\n \t\t\t    matched = matched == ALLOW ? DENY : ALLOW;\n \t\t\tbreak;"
  identifiers: CVE:["CVE-2023-42465"],CWE:["CWE-264"]
  overview: Affected versions of this package are vulnerable to Privilege Escalation
    due to the application logic that relies on not equaling an error value rather
    than equaling a success value, and the susceptibility of these values to single
    bit flips. A co-located attacker can escalate privileges by inducing bit flips
    through ROWHAMMER attacks on stack variables and register values.
  references:
    GitHub Commit: https://github.com/sudo-project/sudo/commit/7873f8334c8d31031f8cfa83bd97ac6029309e4f
    GitHub Release: https://github.com/sudo-project/sudo/releases/tag/SUDO_1_9_15
    OSS Security Advisory: https://www.openwall.com/lists/oss-security/2023/12/21/9
    Rowhammer on Register Values: https://arxiv.org/abs/2309.02545
  title: Privilege Escalation
- diff_content:
  - "--- a/src/main.c\n+++ b/src/main.c\n@@ -821,15 +821,36 @@ static cmd_rec *make_ftp_cmd(pool\
    \ *p, char *buf, size_t buflen, int flags) {\n     return NULL;\n   }\n \n+  /*\
    \ By default, pr_str_get_word will handle quotes and backslashes for\n+   * escaping\
    \ characters.  This can produce words which are shorter, use\n+   * fewer bytes\
    \ than the corresponding input buffer.\n+   *\n+   * In this particular situation,\
    \ we use the length of this initial word\n+   * for determining the length of\
    \ the remaining buffer bytes, assumed to\n+   * contain the FTP command arguments.\
    \  If this initial word is thus\n+   * unexpectedly \"shorter\", due to nonconformant\
    \ FTP text, it can lead\n+   * the subsequent buffer scan, looking for CRNUL sequencees,\
    \ to access\n+   * unexpected memory addresses (Issue #1683).\n+   *\n+   * Thus\
    \ for this particular situation, we tell the function to ignore/skip\n+   * such\
    \ quote/backslash semantics, and treat them as any other character\n+   * using\
    \ the IGNORE_QUOTES flag.\n+   */\n+\n   ptr = buf;\n-  wrd = pr_str_get_word(&ptr,\
    \ str_flags);\n+  wrd = pr_str_get_word(&ptr, str_flags|PR_STR_FL_IGNORE_QUOTES);\n\
    \   if (wrd == NULL) {\n     /* Nothing there...bail out. */\n     pr_trace_msg(\"\
    ctrl\", 5, \"command '%s' is empty, ignoring\", buf);\n     errno = ENOENT;\n\
    \     return NULL;\n   }\n \n+  /* Note that this first word is the FTP command.\
    \  This is why we make\n+   * use of the ptr buffer, which advances through the\
    \ input buffer as\n+   * we read words from the buffer.\n+   */\n+\n   subpool\
    \ = make_sub_pool(p);\n   pr_pool_tag(subpool, \"make_ftp_cmd pool\");\n   cmd\
    \ = pcalloc(subpool, sizeof(cmd_rec));\n@@ -856,6 +877,7 @@ static cmd_rec *make_ftp_cmd(pool\
    \ *p, char *buf, size_t buflen, int flags) {\n   arg_len = buflen - strlen(wrd);\n\
    \   arg = pcalloc(cmd->pool, arg_len + 1);\n \n+  /* Remember that ptr here is\
    \ advanced past the first word. */\n   for (i = 0, j = 0; i < arg_len; i++) {\n\
    \     pr_signals_handle();\n     if (i > 1 &&\n@@ -864,14 +886,13 @@ static cmd_rec\
    \ *make_ftp_cmd(pool *p, char *buf, size_t buflen, int flags) {\n \n       /*\
    \ Strip out the NUL by simply not copying it into the new buffer. */\n       have_crnul\
    \ = TRUE;\n+\n     } else {\n       arg[j++] = ptr[i];\n     }\n   }\n \n-  cmd->arg\
    \ = arg;\n-\n-  if (have_crnul) {\n+  if (have_crnul == TRUE) {\n     char *dup_arg;\n\
    \ \n     /* Now make a copy of the stripped argument; this is what we need to\n\
    @@ -881,6 +902,11 @@ static cmd_rec *make_ftp_cmd(pool *p, char *buf, size_t buflen,\
    \ int flags) {\n     ptr = dup_arg;\n   }\n \n+  cmd->arg = arg;\n+\n+  /* Now\
    \ we can read the remamining words, as command arguments, from the\n+   * input\
    \ buffer.\n+   */\n   while ((wrd = pr_str_get_word(&ptr, str_flags)) != NULL)\
    \ {\n     pr_signals_handle();\n     *((char **) push_array(tarr)) = pstrdup(cmd->pool,\
    \ wrd);"
  - "--- a/src/str.c\n+++ b/src/str.c\n@@ -1,6 +1,6 @@\n /*\n  * ProFTPD - FTP server\
    \ daemon\n- * Copyright (c) 2008-2022 The ProFTPD Project team\n+ * Copyright\
    \ (c) 2008-2023 The ProFTPD Project team\n  *\n  * This program is free software;\
    \ you can redistribute it and/or modify\n  * it under the terms of the GNU General\
    \ Public License as published by\n@@ -1241,7 +1241,7 @@ int pr_str_get_nbytes(const\
    \ char *str, const char *units, off_t *nbytes) {\n \n char *pr_str_get_word(char\
    \ **cp, int flags) {\n   char *res, *dst;\n-  char quote_mode = 0;\n+  int quote_mode\
    \ = FALSE;\n \n   if (cp == NULL ||\n      !*cp ||\n@@ -1270,24 +1270,28 @@ char\
    \ *pr_str_get_word(char **cp, int flags) {\n     }\n   }\n \n-  if (**cp == '\\\
    \"') {\n-    quote_mode++;\n-    (*cp)++;\n+  if (!(flags & PR_STR_FL_IGNORE_QUOTES))\
    \ {\n+    if (**cp == '\\\"') {\n+      quote_mode = TRUE;\n+      (*cp)++;\n\
    +    }\n   }\n \n   while (**cp && (quote_mode ? (**cp != '\\\"') : !PR_ISSPACE(**cp)))\
    \ {\n     pr_signals_handle();\n \n-    if (**cp == '\\\\' && quote_mode) {\n\
    -\n+    if (**cp == '\\\\' &&\n+        quote_mode == TRUE) {\n       /* Escaped\
    \ char */\n       if (*((*cp)+1)) {\n-        *dst = *(++(*cp));\n+        *dst++\
    \ = *(++(*cp));\n+        (*cp)++;\n+        continue;\n       }\n     }\n \n\
    \     *dst++ = **cp;\n-    ++(*cp);\n+    (*cp)++;\n   }\n \n   if (**cp) {"
  - "--- a/tests/api/str.c\n+++ b/tests/api/str.c\n@@ -1,6 +1,6 @@\n /*\n  * ProFTPD\
    \ - FTP server testsuite\n- * Copyright (c) 2008-2021 The ProFTPD Project team\n\
    + * Copyright (c) 2008-2023 The ProFTPD Project team\n  *\n  * This program is\
    \ free software; you can redistribute it and/or modify\n  * it under the terms\
    \ of the GNU General Public License as published by\n@@ -700,19 +700,23 @@ END_TEST\n\
    \ START_TEST (get_word_test) {\n   char *ok, *res, *str;\n \n+  mark_point();\n\
    \   res = pr_str_get_word(NULL, 0);\n   ck_assert_msg(res == NULL, \"Failed to\
    \ handle null arguments\");\n   ck_assert_msg(errno == EINVAL, \"Failed to set\
    \ errno to EINVAL\");\n \n+  mark_point();\n   str = NULL;\n   res = pr_str_get_word(&str,\
    \ 0);\n   ck_assert_msg(res == NULL, \"Failed to handle null str argument\");\n\
    \   ck_assert_msg(errno == EINVAL, \"Failed to set errno to EINVAL\");\n \n+ \
    \ mark_point();\n   str = pstrdup(p, \"  \");\n   res = pr_str_get_word(&str,\
    \ 0);\n   ck_assert_msg(res == NULL, \"Failed to handle whitespace argument\"\
    );\n \n+  mark_point();\n   str = pstrdup(p, \" foo\");\n   res = pr_str_get_word(&str,\
    \ PR_STR_FL_PRESERVE_WHITESPACE);\n   ck_assert_msg(res != NULL, \"Failed to handle\
    \ whitespace argument: %s\",\n@@ -728,6 +732,7 @@ START_TEST (get_word_test) {\n\
    \   ok = \"foo\";\n   ck_assert_msg(strcmp(res, ok) == 0, \"Expected '%s', got\
    \ '%s'\", ok, res);\n \n+  mark_point();\n   str = pstrdup(p, \"  # foo\");\n\
    \   res = pr_str_get_word(&str, 0);\n   ck_assert_msg(res == NULL, \"Failed to\
    \ handle commented argument\");\n@@ -747,6 +752,8 @@ START_TEST (get_word_test)\
    \ {\n   ck_assert_msg(strcmp(res, ok) == 0, \"Expected '%s', got '%s'\", ok, res);\n\
    \ \n   /* Test multiple embedded quotes. */\n+\n+  mark_point();\n   str = pstrdup(p,\
    \ \"foo \\\"bar baz\\\" qux \\\"quz norf\\\"\");\n   res = pr_str_get_word(&str,\
    \ 0);\n   ck_assert_msg(res != NULL, \"Failed to handle quoted argument: %s\"\
    ,\n@@ -775,6 +782,46 @@ START_TEST (get_word_test) {\n \n   ok = \"quz norf\"\
    ;\n   ck_assert_msg(strcmp(res, ok) == 0, \"Expected '%s', got '%s'\", ok, res);\n\
    +\n+  /* Test embedded quotes with backslashes (Issue #1683). */\n+  mark_point();\n\
    +\n+  str = pstrdup(p, \"\\\"\\\\\\\\SYST\\\"\");\n+  res = pr_str_get_word(&str,\
    \ 0);\n+  ck_assert_msg(res != NULL, \"Failed to handle quoted argument: %s\"\
    ,\n+    strerror(errno));\n+\n+  ok = \"\\\\SYST\";\n+  ck_assert_msg(strcmp(res,\
    \ ok) == 0, \"Expected '%s', got '%s'\", ok, res);\n+\n+  mark_point();\n+  str\
    \ = pstrdup(p, \"\\\"\\\"\\\\\\\\SYST\");\n+  res = pr_str_get_word(&str, 0);\n\
    +  ck_assert_msg(res != NULL, \"Failed to handle quoted argument: %s\",\n+   \
    \ strerror(errno));\n+\n+  /* Note that pr_str_get_word() is intended to be called\
    \ multiple times\n+   * on an advancing buffer, effectively tokenizing the buffer.\
    \  This is\n+   * why the function does NOT decrement its quote mode.\n+   */\n\
    +  ok = \"\";\n+  ck_assert_msg(strcmp(res, ok) == 0, \"Expected '%s', got '%s'\"\
    , ok, res);\n+\n+  /* Now do the same tests with the IGNORE_QUOTES flag */\n+\
    \  mark_point();\n+\n+  str = ok = pstrdup(p, \"\\\"\\\\\\\\SYST\\\"\");\n+  res\
    \ = pr_str_get_word(&str, PR_STR_FL_IGNORE_QUOTES);\n+  ck_assert_msg(res != NULL,\
    \ \"Failed to handle quoted argument: %s\",\n+    strerror(errno));\n+  ck_assert_msg(strcmp(res,\
    \ ok) == 0, \"Expected '%s', got '%s'\", ok, res);\n+\n+  mark_point();\n+  str\
    \ = ok = pstrdup(p, \"\\\"\\\"\\\\\\\\SYST\");\n+  res = pr_str_get_word(&str,\
    \ PR_STR_FL_IGNORE_QUOTES);\n+  ck_assert_msg(res != NULL, \"Failed to handle\
    \ quoted argument: %s\",\n+    strerror(errno));\n+  ck_assert_msg(strcmp(res,\
    \ ok) == 0, \"Expected '%s', got '%s'\", ok, res);\n }\n END_TEST\n "
  identifiers: CVE:["CVE-2023-51713"],CWE:["CWE-125"]
  overview: Affected versions of this package are vulnerable to Out-of-bounds Read
    when handling unexpectedly formatted input text from client, caused by quote/backslash
    semantics. An attacker can cause a one-byte out-of-bounds read, leading to a daemon
    crash by sending specially crafted commands.
  references:
    GitHub Commit: https://github.com/proftpd/proftpd/commit/97bbe68363ccf2de0c07f67170ec64a8b4d62592
    GitHub Issue: https://github.com/proftpd/proftpd/issues/1683#issuecomment-1712887554
    Release Log: https://github.com/proftpd/proftpd/blob/1.3.8/NEWS
  title: Out-of-bounds Read
- diff_content:
  - "--- a/src/Compression/CompressionCodecFPC.cpp\n+++ b/src/Compression/CompressionCodecFPC.cpp\n\
    @@ -153,23 +153,23 @@ void registerCodecFPC(CompressionCodecFactory & factory)\n\
    \ namespace\n {\n \n-template <std::unsigned_integral TUint>\n-requires (sizeof(TUint)\
    \ >= 4)\n+template <std::unsigned_integral TUInt>\n+requires (sizeof(TUInt) >=\
    \ 4)\n class DfcmPredictor\n {\n public:\n-    explicit DfcmPredictor(std::size_t\
    \ table_size)\n+    explicit DfcmPredictor(size_t table_size)\n         : table(table_size,\
    \ 0), prev_value{0}, hash{0}\n     {\n     }\n \n     [[nodiscard]]\n-    TUint\
    \ predict() const noexcept\n+    TUInt predict() const noexcept\n     {\n    \
    \     return table[hash] + prev_value;\n     }\n \n-    void add(TUint value)\
    \ noexcept\n+    void add(TUInt value) noexcept\n     {\n         table[hash]\
    \ = value - prev_value;\n         recalculateHash();\n@@ -180,38 +180,38 @@ class\
    \ DfcmPredictor\n     void recalculateHash() noexcept\n     {\n         auto value\
    \ = table[hash];\n-        if constexpr (sizeof(TUint) >= 8)\n+        if constexpr\
    \ (sizeof(TUInt) >= 8)\n         {\n-            hash = ((hash << 2) ^ static_cast<std::size_t>(value\
    \ >> 40)) & (table.size() - 1);\n+            hash = ((hash << 2) ^ static_cast<size_t>(value\
    \ >> 40)) & (table.size() - 1);\n         }\n         else\n         {\n-    \
    \        hash = ((hash << 4) ^ static_cast<std::size_t>(value >> 23)) & (table.size()\
    \ - 1);\n+            hash = ((hash << 4) ^ static_cast<size_t>(value >> 23))\
    \ & (table.size() - 1);\n         }\n     }\n \n-    std::vector<TUint> table;\n\
    -    TUint prev_value;\n-    std::size_t hash;\n+    std::vector<TUInt> table;\n\
    +    TUInt prev_value;\n+    size_t hash;\n };\n \n-template <std::unsigned_integral\
    \ TUint>\n-requires (sizeof(TUint) >= 4)\n+template <std::unsigned_integral TUInt>\n\
    +requires (sizeof(TUInt) >= 4)\n class FcmPredictor\n {\n public:\n-    explicit\
    \ FcmPredictor(std::size_t table_size)\n+    explicit FcmPredictor(size_t table_size)\n\
    \         : table(table_size, 0), hash{0}\n     {\n     }\n \n     [[nodiscard]]\n\
    -    TUint predict() const noexcept\n+    TUInt predict() const noexcept\n   \
    \  {\n         return table[hash];\n     }\n \n-    void add(TUint value) noexcept\n\
    +    void add(TUInt value) noexcept\n     {\n         table[hash] = value;\n \
    \        recalculateHash();\n@@ -221,44 +221,44 @@ class FcmPredictor\n     void\
    \ recalculateHash() noexcept\n     {\n         auto value = table[hash];\n-  \
    \      if constexpr (sizeof(TUint) >= 8)\n+        if constexpr (sizeof(TUInt)\
    \ >= 8)\n         {\n-            hash = ((hash << 6) ^ static_cast<std::size_t>(value\
    \ >> 48)) & (table.size() - 1);\n+            hash = ((hash << 6) ^ static_cast<size_t>(value\
    \ >> 48)) & (table.size() - 1);\n         }\n         else\n         {\n-    \
    \        hash = ((hash << 1) ^ static_cast<std::size_t>(value >> 22)) & (table.size()\
    \ - 1);\n+            hash = ((hash << 1) ^ static_cast<size_t>(value >> 22))\
    \ & (table.size() - 1);\n         }\n     }\n \n-    std::vector<TUint> table;\n\
    -    std::size_t hash;\n+    std::vector<TUInt> table;\n+    size_t hash;\n };\n\
    \ \n-template <std::unsigned_integral TUint>\n+template <std::unsigned_integral\
    \ TUInt>\n class FPCOperation\n {\n-    static constexpr auto VALUE_SIZE = sizeof(TUint);\n\
    +    static constexpr size_t VALUE_SIZE = sizeof(TUInt);\n     static constexpr\
    \ std::byte FCM_BIT{0};\n     static constexpr std::byte DFCM_BIT{1u << 3};\n\
    -    static constexpr auto DFCM_BIT_1 = DFCM_BIT << 4;\n-    static constexpr\
    \ auto DFCM_BIT_2 = DFCM_BIT;\n-    static constexpr unsigned MAX_ZERO_BYTE_COUNT\
    \ = 0b111u;\n+    static constexpr std::byte DFCM_BIT_1 = DFCM_BIT << 4;\n+  \
    \  static constexpr std::byte DFCM_BIT_2 = DFCM_BIT;\n+    static constexpr UInt32\
    \ MAX_ZERO_BYTE_COUNT = 0b111u;\n     static constexpr std::endian ENDIAN = std::endian::little;\n\
    -    static constexpr std::size_t CHUNK_SIZE = 64;\n+    static constexpr size_t\
    \ CHUNK_SIZE = 64;\n \n public:\n     FPCOperation(std::span<std::byte> destination,\
    \ UInt8 compression_level)\n         : dfcm_predictor(1u << compression_level),\
    \ fcm_predictor(1u << compression_level), chunk{}, result{destination}\n     {\n\
    \     }\n \n-    std::size_t encode(std::span<const std::byte> data) &&\n+   \
    \ size_t encode(std::span<const std::byte> data) &&\n     {\n         auto initial_size\
    \ = result.size();\n \n         std::span chunk_view(chunk);\n-        for (std::size_t\
    \ i = 0; i < data.size(); i += chunk_view.size_bytes())\n+        for (size_t\
    \ i = 0; i < data.size(); i += chunk_view.size_bytes())\n         {\n        \
    \     auto written_values_count = importChunk(data.subspan(i), chunk_view);\n\
    \             encodeChunk(chunk_view.subspan(0, written_values_count));\n@@ -267,12\
    \ +267,12 @@ class FPCOperation\n         return initial_size - result.size();\n\
    \     }\n \n-    void decode(std::span<const std::byte> values, std::size_t decoded_size)\
    \ &&\n+    void decode(std::span<const std::byte> values, size_t decoded_size)\
    \ &&\n     {\n-        std::size_t read_bytes = 0;\n+        size_t read_bytes\
    \ = 0;\n \n-        std::span<TUint> chunk_view(chunk);\n-        for (std::size_t\
    \ i = 0; i < decoded_size; i += chunk_view.size_bytes())\n+        std::span<TUInt>\
    \ chunk_view(chunk);\n+        for (size_t i = 0; i < decoded_size; i += chunk_view.size_bytes())\n\
    \         {\n             if (i + chunk_view.size_bytes() > decoded_size)\n  \
    \               chunk_view = chunk_view.first(ceilBytesToEvenValues(decoded_size\
    \ - i));\n@@ -282,50 +282,50 @@ class FPCOperation\n     }\n \n private:\n-  \
    \  static std::size_t ceilBytesToEvenValues(std::size_t bytes_count)\n+    static\
    \ size_t ceilBytesToEvenValues(size_t bytes_count)\n     {\n-        auto values_count\
    \ = (bytes_count + VALUE_SIZE - 1) / VALUE_SIZE;\n+        size_t values_count\
    \ = (bytes_count + VALUE_SIZE - 1) / VALUE_SIZE;\n         return values_count\
    \ % 2 == 0 ? values_count : values_count + 1;\n     }\n \n-    std::size_t importChunk(std::span<const\
    \ std::byte> values, std::span<TUint> chnk)\n+    size_t importChunk(std::span<const\
    \ std::byte> values, std::span<TUInt> current_chunk)\n     {\n-        if (auto\
    \ chunk_view = std::as_writable_bytes(chnk); chunk_view.size() <= values.size())\n\
    +        if (auto chunk_view = std::as_writable_bytes(current_chunk); chunk_view.size()\
    \ <= values.size())\n         {\n-            std::memcpy(chunk_view.data(), values.data(),\
    \ chunk_view.size());\n+            memcpy(chunk_view.data(), values.data(), chunk_view.size());\n\
    \             return chunk_view.size() / VALUE_SIZE;\n         }\n         else\n\
    \         {\n-            std::memset(chunk_view.data(), 0, chunk_view.size());\n\
    -            std::memcpy(chunk_view.data(), values.data(), values.size());\n+\
    \            memset(chunk_view.data(), 0, chunk_view.size());\n+            memcpy(chunk_view.data(),\
    \ values.data(), values.size());\n             return ceilBytesToEvenValues(values.size());\n\
    \         }\n     }\n \n-    void exportChunk(std::span<const TUint> chnk)\n+\
    \    void exportChunk(std::span<const TUInt> current_chunk)\n     {\n-       \
    \ auto chunk_view = std::as_bytes(chnk).first(std::min(result.size(), chnk.size_bytes()));\n\
    -        std::memcpy(result.data(), chunk_view.data(), chunk_view.size());\n+\
    \        auto chunk_view = std::as_bytes(current_chunk).first(std::min(result.size(),\
    \ current_chunk.size_bytes()));\n+        memcpy(result.data(), chunk_view.data(),\
    \ chunk_view.size());\n         result = result.subspan(chunk_view.size());\n\
    \     }\n \n-    void encodeChunk(std::span<const TUint> seq)\n+    void encodeChunk(std::span<const\
    \ TUInt> sequence)\n     {\n-        for (std::size_t i = 0; i < seq.size(); i\
    \ += 2)\n+        for (size_t i = 0; i < sequence.size(); i += 2)\n         {\n\
    -            encodePair(seq[i], seq[i + 1]);\n+            encodePair(sequence[i],\
    \ sequence[i + 1]);\n         }\n     }\n \n     struct CompressedValue\n    \
    \ {\n-        TUint value;\n-        unsigned compressed_size;\n+        TUInt\
    \ value;\n+        UInt32 compressed_size;\n         std::byte predictor;\n  \
    \   };\n \n-    unsigned encodeCompressedZeroByteCount(unsigned compressed)\n\
    +    UInt32 encodeCompressedZeroByteCount(UInt32 compressed)\n     {\n       \
    \  if constexpr (VALUE_SIZE == MAX_ZERO_BYTE_COUNT + 1)\n         {\n@@ -335,7\
    \ +335,7 @@ class FPCOperation\n         return std::min(compressed, MAX_ZERO_BYTE_COUNT);\n\
    \     }\n \n-    unsigned decodeCompressedZeroByteCount(unsigned encoded_size)\n\
    +    UInt32 decodeCompressedZeroByteCount(UInt32 encoded_size)\n     {\n     \
    \    if constexpr (VALUE_SIZE == MAX_ZERO_BYTE_COUNT + 1)\n         {\n@@ -345,22\
    \ +345,22 @@ class FPCOperation\n         return encoded_size;\n     }\n \n- \
    \   CompressedValue compressValue(TUint value) noexcept\n+    CompressedValue\
    \ compressValue(TUInt value) noexcept\n     {\n         static constexpr auto\
    \ BITS_PER_BYTE = std::numeric_limits<unsigned char>::digits;\n \n-        TUint\
    \ compressed_dfcm = dfcm_predictor.predict() ^ value;\n-        TUint compressed_fcm\
    \ = fcm_predictor.predict() ^ value;\n+        TUInt compressed_dfcm = dfcm_predictor.predict()\
    \ ^ value;\n+        TUInt compressed_fcm = fcm_predictor.predict() ^ value;\n\
    \         dfcm_predictor.add(value);\n         fcm_predictor.add(value);\n   \
    \      auto zeroes_dfcm = std::countl_zero(compressed_dfcm);\n         auto zeroes_fcm\
    \ = std::countl_zero(compressed_fcm);\n         if (zeroes_dfcm > zeroes_fcm)\n\
    -            return {compressed_dfcm, encodeCompressedZeroByteCount(static_cast<unsigned>(zeroes_dfcm)\
    \ / BITS_PER_BYTE), DFCM_BIT};\n-        return {compressed_fcm, encodeCompressedZeroByteCount(static_cast<unsigned>(zeroes_fcm)\
    \ / BITS_PER_BYTE), FCM_BIT};\n+            return {compressed_dfcm, encodeCompressedZeroByteCount(static_cast<UInt32>(zeroes_dfcm)\
    \ / BITS_PER_BYTE), DFCM_BIT};\n+        return {compressed_fcm, encodeCompressedZeroByteCount(static_cast<UInt32>(zeroes_fcm)\
    \ / BITS_PER_BYTE), FCM_BIT};\n     }\n \n-    void encodePair(TUint first, TUint\
    \ second)\n+    void encodePair(TUInt first, TUInt second)\n     {\n         auto\
    \ [compressed_value1, zero_byte_count1, predictor1] = compressValue(first);\n\
    \         auto [compressed_value2, zero_byte_count2, predictor2] = compressValue(second);\n\
    @@ -374,24 +374,24 @@ class FPCOperation\n         auto tail_size1 = VALUE_SIZE\
    \ - zero_byte_count1;\n         auto tail_size2 = VALUE_SIZE - zero_byte_count2;\n\
    \ \n-        std::memcpy(result.data() + 1, valueTail(compressed_value1, zero_byte_count1),\
    \ tail_size1);\n-        std::memcpy(result.data() + 1 + tail_size1, valueTail(compressed_value2,\
    \ zero_byte_count2), tail_size2);\n+        memcpy(result.data() + 1, valueTail(compressed_value1,\
    \ zero_byte_count1), tail_size1);\n+        memcpy(result.data() + 1 + tail_size1,\
    \ valueTail(compressed_value2, zero_byte_count2), tail_size2);\n         result\
    \ = result.subspan(1 + tail_size1 + tail_size2);\n     }\n \n-    std::size_t\
    \ decodeChunk(std::span<const std::byte> values, std::span<TUint> seq)\n+    size_t\
    \ decodeChunk(std::span<const std::byte> values, std::span<TUInt> sequence)\n\
    \     {\n-        std::size_t read_bytes = 0;\n-        for (std::size_t i = 0;\
    \ i < seq.size(); i += 2)\n+        size_t read_bytes = 0;\n+        for (size_t\
    \ i = 0; i < sequence.size(); i += 2)\n         {\n-            read_bytes +=\
    \ decodePair(values.subspan(read_bytes), seq[i], seq[i + 1]);\n+            read_bytes\
    \ += decodePair(values.subspan(read_bytes), sequence[i], sequence[i + 1]);\n \
    \        }\n         return read_bytes;\n     }\n \n-    TUint decompressValue(TUint\
    \ value, bool isDfcmPredictor)\n+    TUInt decompressValue(TUInt value, bool isDfcmPredictor)\n\
    \     {\n-        TUint decompressed;\n+        TUInt decompressed;\n        \
    \ if (isDfcmPredictor)\n         {\n             decompressed = dfcm_predictor.predict()\
    \ ^ value;\n@@ -405,37 +405,45 @@ class FPCOperation\n         return decompressed;\n\
    \     }\n \n-    std::size_t decodePair(std::span<const std::byte> bytes, TUint&\
    \ first, TUint& second)\n+    size_t decodePair(std::span<const std::byte> bytes,\
    \ TUInt & first, TUInt & second)\n     {\n         if (bytes.empty()) [[unlikely]]\n\
    \             throw Exception(ErrorCodes::CANNOT_DECOMPRESS, \"Unexpected end\
    \ of encoded sequence\");\n \n-        auto zero_byte_count1 = decodeCompressedZeroByteCount(\n\
    -            std::to_integer<unsigned>(bytes.front() >> 4) & MAX_ZERO_BYTE_COUNT);\n\
    -        auto zero_byte_count2 = decodeCompressedZeroByteCount(\n-           \
    \ std::to_integer<unsigned>(bytes.front()) & MAX_ZERO_BYTE_COUNT);\n+        UInt32\
    \ zero_byte_count1 = decodeCompressedZeroByteCount(\n+            std::to_integer<UInt32>(bytes.front()\
    \ >> 4) & MAX_ZERO_BYTE_COUNT);\n+        UInt32 zero_byte_count2 = decodeCompressedZeroByteCount(\n\
    +            std::to_integer<UInt32>(bytes.front()) & MAX_ZERO_BYTE_COUNT);\n\
    \ \n-        auto tail_size1 = VALUE_SIZE - zero_byte_count1;\n-        auto tail_size2\
    \ = VALUE_SIZE - zero_byte_count2;\n+        if (zero_byte_count1 > VALUE_SIZE\
    \ || zero_byte_count2 > VALUE_SIZE) [[unlikely]]\n+            throw Exception(ErrorCodes::CANNOT_DECOMPRESS,\
    \ \"Invalid compressed data\");\n+\n+        size_t tail_size1 = VALUE_SIZE -\
    \ zero_byte_count1;\n+        size_t tail_size2 = VALUE_SIZE - zero_byte_count2;\n\
    +\n+        size_t expected_size = 0;\n+        if (__builtin_add_overflow(tail_size1,\
    \ tail_size2, &expected_size)\n+            || __builtin_add_overflow(expected_size,\
    \ 1, &expected_size)) [[unlikely]]\n+            throw Exception(ErrorCodes::CANNOT_DECOMPRESS,\
    \ \"Invalid compressed data\");\n \n-        if (bytes.size() < 1 + tail_size1\
    \ + tail_size2) [[unlikely]]\n+        if (bytes.size() < expected_size) [[unlikely]]\n\
    \             throw Exception(ErrorCodes::CANNOT_DECOMPRESS, \"Unexpected end\
    \ of encoded sequence\");\n \n-        TUint value1 = 0;\n-        TUint value2\
    \ = 0;\n+        TUInt value1 = 0;\n+        TUInt value2 = 0;\n \n-        std::memcpy(valueTail(value1,\
    \ zero_byte_count1), bytes.data() + 1, tail_size1);\n-        std::memcpy(valueTail(value2,\
    \ zero_byte_count2), bytes.data() + 1 + tail_size1, tail_size2);\n+        memcpy(valueTail(value1,\
    \ zero_byte_count1), bytes.data() + 1, tail_size1);\n+        memcpy(valueTail(value2,\
    \ zero_byte_count2), bytes.data() + 1 + tail_size1, tail_size2);\n \n        \
    \ auto is_dfcm_predictor1 = std::to_integer<unsigned char>(bytes.front() & DFCM_BIT_1)\
    \ != 0;\n         auto is_dfcm_predictor2 = std::to_integer<unsigned char>(bytes.front()\
    \ & DFCM_BIT_2) != 0;\n         first = decompressValue(value1, is_dfcm_predictor1);\n\
    \         second = decompressValue(value2, is_dfcm_predictor2);\n \n-        return\
    \ 1 + tail_size1 + tail_size2;\n+        return expected_size;\n     }\n \n- \
    \   static void* valueTail(TUint& value, unsigned compressed_size)\n+    static\
    \ void* valueTail(TUInt& value, UInt32 compressed_size)\n     {\n         if constexpr\
    \ (ENDIAN == std::endian::little)\n         {\n@@ -447,11 +455,11 @@ class FPCOperation\n\
    \         }\n     }\n \n-    DfcmPredictor<TUint> dfcm_predictor;\n-    FcmPredictor<TUint>\
    \ fcm_predictor;\n+    DfcmPredictor<TUInt> dfcm_predictor;\n+    FcmPredictor<TUInt>\
    \ fcm_predictor;\n \n     // memcpy the input into this buffer to align reads,\
    \ this improves performance compared to unaligned reads (bit_cast) by ~10%\n-\
    \    std::array<TUint, CHUNK_SIZE> chunk{};\n+    std::array<TUInt, CHUNK_SIZE>\
    \ chunk{};\n \n     std::span<std::byte> result{};\n };"
  identifiers: CVE:["CVE-2023-48298"],CWE:["CWE-191"]
  overview: Affected versions of this package are vulnerable to Integer Underflow
    in the `CompressionCodecFPC.cpp` file. An attacker can trigger and exploit this
    vulnerability resulting in crash due to stack buffer overflow in decompression
    of FPC codec.
  references:
    GitHub Commit: https://github.com/ClickHouse/ClickHouse/commit/9401b904173d7b4a3deb5fce173e87a33ecc64e8
    GitHub PR: https://github.com/ClickHouse/ClickHouse/pull/56795
  title: Integer Underflow
- diff_content:
  - "--- a/etc.c\n+++ b/etc.c\n@@ -393,7 +393,10 @@ checkType(Str s, Lineprop **oprop,\
    \ Linecolor **ocolor)\n \t\t\t    if (color)\n \t\t\t\tcolor -= plen;\n #endif\n\
    -\t\t\t    plen = *(--plens);\n+\t\t\t    if (plens == plens_buffer)\n+\t\t\t\t\
    plen = 0;\n+\t\t\t    else\n+\t\t\t\tplen = *(--plens);\n \t\t\t    str += 2;\n\
    \ \t\t\t}\n \t\t    }\n@@ -419,7 +422,10 @@ checkType(Str s, Lineprop **oprop,\
    \ Linecolor **ocolor)\n \t\t\t    if (color)\n \t\t\t\tcolor -= plen;\n #endif\n\
    -\t\t\t    plen = *(--plens);\n+\t\t\t    if (plens == plens_buffer)\n+\t\t\t\t\
    plen = 0;\n+\t\t\t    else\n+\t\t\t\tplen = *(--plens);\n \t\t\t    str++;\n \t\
    \t\t}\n #else"
  identifiers: CVE:["CVE-2023-4255"],CWE:["CWE-787"]
  overview: Affected versions of this package are vulnerable to Out-of-bounds Write
    via the `checkType` function in `etc.c`.
  references:
    CVE-2022-38223: https://security.snyk.io/vuln/SNYK-UNMANAGED-TATSW3M-3023036
    GitHub Commit: https://github.com/tats/w3m/commit/edc602651c506aeeb60544b55534dd1722a340d3
    GitHub Issue: https://github.com/tats/w3m/issues/268
    GitHub PR: https://github.com/tats/w3m/pull/273
    RedHat Bugzilla Bug: https://bugzilla.redhat.com/show_bug.cgi?id=2255207
  title: Out-of-bounds Write
- diff_content:
  - "--- a/drivers/net/wireless/ath/ath10k/wmi-tlv.c\n+++ b/drivers/net/wireless/ath/ath10k/wmi-tlv.c\n\
    @@ -851,6 +851,10 @@ ath10k_wmi_tlv_op_pull_mgmt_tx_compl_ev(struct ath10k *ar,\
    \ struct sk_buff *skb,\n \t}\n \n \tev = tb[WMI_TLV_TAG_STRUCT_MGMT_TX_COMPL_EVENT];\n\
    +\tif (!ev) {\n+\t\tkfree(tb);\n+\t\treturn -EPROTO;\n+\t}\n \n \targ->desc_id\
    \ = ev->desc_id;\n \targ->status = ev->status;"
  identifiers: CVE:["CVE-2023-7042"],CWE:["CWE-476"]
  overview: Affected versions of this package are vulnerable to NULL Pointer Dereference
    via the `ath10k_wmi_tlv_op_pull_mgmt_tx_compl_ev()` function in the `drivers/net/wireless/ath/ath10k/wmi-tlv.c`
    file. This issue could be exploited to trigger a denial of service.
  references:
    Fix Commit: https://patchwork.kernel.org/project/linux-wireless/patch/20231208043433.271449-1-hdthky0@gmail.com/
    GitHub Commit: https://github.com/torvalds/linux/commit/ad25ee36f00172f7d53242dc77c69fff7ced0755
    RedHat Bugzilla Bug: https://bugzilla.redhat.com/show_bug.cgi?id=2255497
  title: NULL Pointer Dereference
- diff_content:
  - "--- a/drivers/tty/n_gsm.c\n+++ b/drivers/tty/n_gsm.c\n@@ -3042,12 +3042,13 @@\
    \ static void gsm_error(struct gsm_mux *gsm)\n static void gsm_cleanup_mux(struct\
    \ gsm_mux *gsm, bool disc)\n {\n \tint i;\n-\tstruct gsm_dlci *dlci = gsm->dlci[0];\n\
    +\tstruct gsm_dlci *dlci;\n \tstruct gsm_msg *txq, *ntxq;\n \n \tgsm->dead = true;\n\
    \ \tmutex_lock(&gsm->mutex);\n \n+\tdlci = gsm->dlci[0];\n \tif (dlci) {\n \t\t\
    if (disc && dlci->state != DLCI_CLOSED) {\n \t\t\tgsm_dlci_begin_close(dlci);"
  identifiers: CVE:["CVE-2023-6546"],CWE:["CWE-362"]
  overview: Affected versions of this package are vulnerable to Race Condition in
    the `n_gsm` kernel module. A local unprivileged user could use this vulnerability
    to escalate their privileges on the system.
  references:
    GitHub Commit: https://github.com/torvalds/linux/commit/3c4f8333b582487a2d1e02171f1465531cde53e3
    RedHat Bugzilla Bug: https://bugzilla.redhat.com/show_bug.cgi?id=2255498
  title: Race Condition
- diff_content:
  - "--- a/os/net/app-layer/snmp/snmp-ber.c\n+++ b/os/net/app-layer/snmp/snmp-ber.c\n\
    @@ -128,6 +128,11 @@ snmp_ber_encode_null(unsigned char *out, uint32_t *out_len,\
    \ uint8_t type)\n unsigned char *\n snmp_ber_decode_type(unsigned char *buff,\
    \ uint32_t *buff_len, uint8_t *type)\n {\n+  if(*buff_len == 0)\n+  {\n+    return\
    \ NULL;\n+  }\n+\n   *type = *buff++;\n   (*buff_len)--;\n \n@@ -137,6 +142,11\
    \ @@ snmp_ber_decode_type(unsigned char *buff, uint32_t *buff_len, uint8_t *type)\n\
    \ unsigned char *\n snmp_ber_decode_length(unsigned char *buff, uint32_t *buff_len,\
    \ uint8_t *length)\n {\n+  if(*buff_len == 0)\n+  {\n+    return NULL;\n+  }\n\
    +\n   *length = *buff++;\n   (*buff_len)--;\n \n@@ -150,7 +160,8 @@ snmp_ber_decode_integer(unsigned\
    \ char *buf, uint32_t *buff_len, uint32_t *num)\n \n   buf = snmp_ber_decode_type(buf,\
    \ buff_len, &type);\n \n-  if(type != BER_DATA_TYPE_INTEGER) {\n+  if(buf == NULL\
    \ ||\n+     type != BER_DATA_TYPE_INTEGER) {\n     /*\n      * Sanity check\n\
    \      * Invalid type in buffer\n@@ -160,14 +171,20 @@ snmp_ber_decode_integer(unsigned\
    \ char *buf, uint32_t *buff_len, uint32_t *num)\n \n   buf = snmp_ber_decode_length(buf,\
    \ buff_len, &len);\n \n-  if(len > 4) {\n+  if(buf == NULL ||\n+     len > 4)\
    \ {\n     /*\n      * Sanity check\n      * It will not fit in the uint32_t\n\
    \      */\n     return NULL;\n   }\n \n+  if(*buff_len < len)\n+  {\n+    return\
    \ NULL;\n+  }\n+\n   *num = (uint32_t)(*buf++ & 0xFF);\n   (*buff_len)--;\n  \
    \ for(i = 1; i < len; ++i) {\n@@ -186,7 +203,8 @@ snmp_ber_decode_unsigned_integer(unsigned\
    \ char *buf, uint32_t *buff_len, uint8_t\n \n   buf = snmp_ber_decode_type(buf,\
    \ buff_len, &type);\n \n-  if(type != expected_type) {\n+  if(buf == NULL ||\n\
    +     type != expected_type) {\n     /*\n      * Sanity check\n      * Invalid\
    \ type in buffer\n@@ -196,14 +214,20 @@ snmp_ber_decode_unsigned_integer(unsigned\
    \ char *buf, uint32_t *buff_len, uint8_t\n \n   buf = snmp_ber_decode_length(buf,\
    \ buff_len, &len);\n \n-  if(len > 4) {\n+  if(buf == NULL ||\n+     len > 4)\
    \ {\n     /*\n      * Sanity check\n      * It will not fit in the uint32_t\n\
    \      */\n     return NULL;\n   }\n \n+  if(*buff_len < len)\n+  {\n+    return\
    \ NULL;\n+  }\n+\n   *num = (uint32_t)(*buf++ & 0xFF);\n   (*buff_len)--;\n  \
    \ for(i = 1; i < len; ++i) {\n@@ -222,7 +246,8 @@ snmp_ber_decode_string_len_buffer(unsigned\
    \ char *buf, uint32_t *buff_len, const\n \n   buf = snmp_ber_decode_type(buf,\
    \ buff_len, &type);\n \n-  if(type != BER_DATA_TYPE_OCTET_STRING) {\n+  if(buf\
    \ == NULL ||\n+    type != BER_DATA_TYPE_OCTET_STRING) {\n     /*\n      * Sanity\
    \ check\n      * Invalid type in buffer"
  - "--- a/os/net/app-layer/snmp/snmp-engine.c\n+++ b/os/net/app-layer/snmp/snmp-engine.c\n\
    @@ -206,7 +206,7 @@ snmp_engine(unsigned char *buff, uint32_t buff_len, unsigned\
    \ char *out, uint32_t\n {\n   static snmp_header_t header;\n   static snmp_varbind_t\
    \ varbinds[SNMP_MAX_NR_VALUES];\n-  static uint32_t varbind_length;\n+  static\
    \ uint32_t varbind_length = SNMP_MAX_NR_VALUES;\n \n   buff = snmp_message_decode(buff,\
    \ buff_len, &header, varbinds, &varbind_length);\n   if(buff == NULL) {"
  - "--- a/os/net/app-layer/snmp/snmp-message.c\n+++ b/os/net/app-layer/snmp/snmp-message.c\n\
    @@ -115,7 +115,7 @@ snmp_message_decode(uint8_t *buf, uint32_t buf_len, snmp_header_t\
    \ *header,\n                     snmp_varbind_t *varbinds, uint32_t *varbind_num)\n\
    \ {\n   uint8_t type, len;\n-  uint32_t i, oid_len;\n+  uint32_t i, oid_len =\
    \ SNMP_MSG_OID_MAX_LEN;\n \n   buf = snmp_ber_decode_type(buf, &buf_len, &type);\n\
    \   if(buf == NULL) {\n@@ -224,6 +224,10 @@ snmp_message_decode(uint8_t *buf,\
    \ uint32_t buf_len, snmp_header_t *header,\n   }\n \n   for(i = 0; buf_len > 0;\
    \ ++i) {\n+    if (i >= *varbind_num)\n+    {\n+      return NULL;\n+    }\n \n\
    \     buf = snmp_ber_decode_type(buf, &buf_len, &type);\n     if(buf == NULL)\
    \ {"
  identifiers: CVE:["CVE-2020-14934"],CWE:["CWE-787"]
  overview: Affected versions of this package are vulnerable to Out-of-bounds Write.
    Buffer overflows were discovered in Contiki-NG 4.4 through 4.5, in the SNMP agent.
    The function parsing the received SNMP request does not verify the input message's
    requested variables against the capacity of the internal SNMP engine buffer. If
    the number of variables in the request exceeds the allocated buffer, a memory
    write out of the buffer boundaries occurs. This write operation provides a possibility
    to overwrite other variables allocated in the .bss section by the application.
    Because the sender of the frame is in control of the content that will be written
    beyond the buffer limits, and there is no strict process memory separation, this
    issue may allow overwriting of sensitive memory areas of an IoT device.
  references:
    GitHub Issue: https://github.com/contiki-ng/contiki-ng/issues/1352
    Github Commit: https://github.com/contiki-ng/contiki-ng/commit/35e5ac8aa760a424276ac4b1279a0f2649f47985
  title: Out-of-bounds Write
- diff_content:
  - "--- a/os/net/ipv6/sicslowpan.c\n+++ b/os/net/ipv6/sicslowpan.c\n@@ -1068,17 +1068,32\
    \ @@ compress_hdr_iphc(linkaddr_t *link_destaddr)\n  * \\param ip_len Equal to\
    \ 0 if the packet is not a fragment (IP length\n  * is then inferred from the\
    \ L2 length), non 0 if the packet is a 1st\n  * fragment.\n+ * \\return A boolean\
    \ value indicating whether the uncompression succeeded.\n  */\n-static void\n\
    +static bool\n uncompress_hdr_iphc(uint8_t *buf, uint16_t buf_size, uint16_t ip_len)\n\
    \ {\n   uint8_t tmp, iphc0, iphc1, nhc;\n   struct uip_ext_hdr *exthdr;\n   uint8_t*\
    \ last_nextheader;\n   uint8_t* ip_payload;\n   uint8_t ext_hdr_len = 0;\n+  uint16_t\
    \ cmpr_len;\n+\n+/* Macro used only internally, during header uncompression. Checks\
    \ if there\n+ * is sufficient space in packetbuf before reading any further. */\n\
    +#define CHECK_READ_SPACE(readlen) \\\n+  if((hc06_ptr - packetbuf_ptr) + (readlen)\
    \ > cmpr_len) { \\\n+    LOG_WARN(\"Not enough packetbuf space to decompress header\
    \ (%u bytes, %u left). Aborting.\\n\", \\\n+             (unsigned)(readlen),\
    \ (unsigned)(cmpr_len - (hc06_ptr - packetbuf_ptr))); \\\n+    return false; \\\
    \n+  }\n \n   /* at least two byte will be used for the encoding */\n+  cmpr_len\
    \ = packetbuf_datalen();\n+  if(cmpr_len < packetbuf_hdr_len + 2) {\n+    return\
    \ false;\n+  }\n   hc06_ptr = packetbuf_ptr + packetbuf_hdr_len + 2;\n \n   iphc0\
    \ = PACKETBUF_IPHC_BUF[0];\n@@ -1095,6 +1110,7 @@ uncompress_hdr_iphc(uint8_t\
    \ *buf, uint16_t buf_size, uint16_t ip_len)\n       /* Flow label are carried\
    \ inline */\n       if((iphc0 & SICSLOWPAN_IPHC_TC_C) == 0) {\n         /* Traffic\
    \ class is carried inline */\n+        CHECK_READ_SPACE(4);\n         memcpy(&SICSLOWPAN_IP_BUF(buf)->tcflow,\
    \ hc06_ptr + 1, 3);\n         tmp = *hc06_ptr;\n         hc06_ptr += 4;\n@@ -1108,7\
    \ +1124,8 @@ uncompress_hdr_iphc(uint8_t *buf, uint16_t buf_size, uint16_t ip_len)\n\
    \         /* Traffic class is compressed (set version and no TC)*/\n         SICSLOWPAN_IP_BUF(buf)->vtc\
    \ = 0x60;\n         /* highest flow label bits + ECN bits */\n-        SICSLOWPAN_IP_BUF(buf)->tcflow\
    \ = (*hc06_ptr & 0x0F) |\n+        CHECK_READ_SPACE(3);\n+        SICSLOWPAN_IP_BUF(buf)->tcflow\
    \ = (*hc06_ptr & 0x0F) | \n           ((*hc06_ptr >> 2) & 0x30);\n         memcpy(&SICSLOWPAN_IP_BUF(buf)->flow,\
    \ hc06_ptr + 1, 2);\n         hc06_ptr += 3;\n@@ -1118,10 +1135,11 @@ uncompress_hdr_iphc(uint8_t\
    \ *buf, uint16_t buf_size, uint16_t ip_len)\n       /* Version and flow label\
    \ are compressed */\n       if((iphc0 & SICSLOWPAN_IPHC_TC_C) == 0) {\n      \
    \   /* Traffic class is inline */\n+        CHECK_READ_SPACE(1);\n         SICSLOWPAN_IP_BUF(buf)->vtc\
    \ = 0x60 | ((*hc06_ptr >> 2) & 0x0f);\n-          SICSLOWPAN_IP_BUF(buf)->tcflow\
    \ = ((*hc06_ptr << 6) & 0xC0) | ((*hc06_ptr >> 2) & 0x30);\n-          SICSLOWPAN_IP_BUF(buf)->flow\
    \ = 0;\n-          hc06_ptr += 1;\n+        SICSLOWPAN_IP_BUF(buf)->tcflow = ((*hc06_ptr\
    \ << 6) & 0xC0) | ((*hc06_ptr >> 2) & 0x30);\n+        SICSLOWPAN_IP_BUF(buf)->flow\
    \ = 0;\n+        hc06_ptr += 1;\n       } else {\n         /* Traffic class is\
    \ compressed */\n         SICSLOWPAN_IP_BUF(buf)->vtc = 0x60;\n@@ -1133,6 +1151,7\
    \ @@ uncompress_hdr_iphc(uint8_t *buf, uint16_t buf_size, uint16_t ip_len)\n \
    \  /* Next Header */\n   if((iphc0 & SICSLOWPAN_IPHC_NH_C) == 0) {\n     /* Next\
    \ header is carried inline */\n+    CHECK_READ_SPACE(1);\n     SICSLOWPAN_IP_BUF(buf)->proto\
    \ = *hc06_ptr;\n     LOG_DBG(\"uncompression: next header inline: %d\\n\", SICSLOWPAN_IP_BUF(buf)->proto);\n\
    \     hc06_ptr += 1;\n@@ -1142,6 +1161,7 @@ uncompress_hdr_iphc(uint8_t *buf,\
    \ uint16_t buf_size, uint16_t ip_len)\n   if((iphc0 & 0x03) != SICSLOWPAN_IPHC_TTL_I)\
    \ {\n     SICSLOWPAN_IP_BUF(buf)->ttl = ttl_values[iphc0 & 0x03];\n   } else {\n\
    +    CHECK_READ_SPACE(1);\n     SICSLOWPAN_IP_BUF(buf)->ttl = *hc06_ptr;\n   \
    \  hc06_ptr += 1;\n   }\n@@ -1159,7 +1179,7 @@ uncompress_hdr_iphc(uint8_t *buf,\
    \ uint16_t buf_size, uint16_t ip_len)\n       context = addr_context_lookup_by_number(sci);\n\
    \       if(context == NULL) {\n         LOG_ERR(\"uncompression: error context\
    \ not found\\n\");\n-        return;\n+        return false;\n       }\n     }\n\
    \     /* if tmp == 0 we do not have a context and therefore no prefix */\n@@ -1189,6\
    \ +1209,7 @@ uncompress_hdr_iphc(uint8_t *buf, uint16_t buf_size, uint16_t ip_len)\n\
    \       /* DAM_11:   8 bits FF02::00XX */\n       uint8_t prefix[] = {0xff, 0x02};\n\
    \       if(tmp > 0 && tmp < 3) {\n+        CHECK_READ_SPACE(1);\n         prefix[1]\
    \ = *hc06_ptr;\n         hc06_ptr++;\n       }\n@@ -1206,7 +1227,7 @@ uncompress_hdr_iphc(uint8_t\
    \ *buf, uint16_t buf_size, uint16_t ip_len)\n       /* all valid cases below need\
    \ the context! */\n       if(context == NULL) {\n         LOG_ERR(\"uncompression:\
    \ error context not found\\n\");\n-        return;\n+        return false;\n \
    \      }\n       uncompress_addr(&SICSLOWPAN_IP_BUF(buf)->destipaddr, context->prefix,\n\
    \                       unc_ctxconf[tmp],\n@@ -1227,6 +1248,7 @@ uncompress_hdr_iphc(uint8_t\
    \ *buf, uint16_t buf_size, uint16_t ip_len)\n   ip_payload = SICSLOWPAN_IPPAYLOAD_BUF(buf);\n\
    \ \n   while(nhc && (*hc06_ptr & SICSLOWPAN_NHC_MASK) == SICSLOWPAN_NHC_EXT_HDR)\
    \ {\n+    CHECK_READ_SPACE(1);\n     uint8_t eid = (*hc06_ptr & 0x0e) >> 1;\n\
    \     /* next header compression flag */\n     uint8_t nh = (*hc06_ptr & 0x01);\n\
    @@ -1238,10 +1260,12 @@ uncompress_hdr_iphc(uint8_t *buf, uint16_t buf_size, uint16_t\
    \ ip_len)\n \n     hc06_ptr++;\n     if(!nh) {\n+      CHECK_READ_SPACE(1);\n\
    \       next = *hc06_ptr;\n       hc06_ptr++;\n       LOG_DBG(\"uncompression:\
    \ next header is inlined. Next: %d\\n\", next);\n     }\n+    CHECK_READ_SPACE(1);\n\
    \     len = *hc06_ptr;\n     hc06_ptr++;\n \n@@ -1261,29 +1285,31 @@ uncompress_hdr_iphc(uint8_t\
    \ *buf, uint16_t buf_size, uint16_t ip_len)\n       break;\n     default:\n  \
    \     LOG_DBG(\"uncompression: error unsupported ext header\\n\");\n-      return;\n\
    +      return false;\n     }\n     *last_nextheader = proto;\n \n     /* Check\
    \ that there is enough room to write the extension header. */\n     if((ip_payload\
    \ - buf) + UIP_EXT_HDR_LEN + len > buf_size) {\n       LOG_WARN(\"uncompression:\
    \ cannot write ext header beyond target buffer\\n\");\n-      return;\n+     \
    \ return false;\n     }\n \n     /* uncompress the extension header */\n     exthdr\
    \ = (struct uip_ext_hdr *)ip_payload;\n     exthdr->len = (UIP_EXT_HDR_LEN + len)\
    \ / 8;\n     if(exthdr->len == 0) {\n       LOG_WARN(\"Extension header length\
    \ is below 8\\n\");\n-      return;\n+      return false;\n     }\n     exthdr->len--;\n\
    \     exthdr->next = next;\n     last_nextheader = &exthdr->next;\n-    memcpy((uint8_t\
    \ *)exthdr + UIP_EXT_HDR_LEN, hc06_ptr, len);\n \n+    CHECK_READ_SPACE(len);\n\
    +    memcpy((uint8_t *)exthdr + UIP_EXT_HDR_LEN, hc06_ptr, len);\n     hc06_ptr\
    \ += len;\n+\n     uncomp_hdr_len += (exthdr->len + 1) * 8;\n     ip_payload +=\
    \ (exthdr->len + 1) * 8;\n     ext_hdr_len += (exthdr->len + 1) * 8;\n@@ -1293,6\
    \ +1319,7 @@ uncompress_hdr_iphc(uint8_t *buf, uint16_t buf_size, uint16_t ip_len)\n\
    \   }\n \n   /* The next header is compressed, NHC is following */\n+  CHECK_READ_SPACE(1);\n\
    \   if(nhc && (*hc06_ptr & SICSLOWPAN_NHC_UDP_MASK) == SICSLOWPAN_NHC_UDP_ID)\
    \ {\n     struct uip_udp_hdr *udp_buf = (struct uip_udp_hdr *)ip_payload;\n  \
    \   uint16_t udp_len;\n@@ -1303,6 +1330,7 @@ uncompress_hdr_iphc(uint8_t *buf,\
    \ uint16_t buf_size, uint16_t ip_len)\n     switch(*hc06_ptr & SICSLOWPAN_NHC_UDP_CS_P_11)\
    \ {\n     case SICSLOWPAN_NHC_UDP_CS_P_00:\n       /* 1 byte for NHC, 4 byte for\
    \ ports, 2 bytes chksum */\n+      CHECK_READ_SPACE(5);\n       memcpy(&udp_buf->srcport,\
    \ hc06_ptr + 1, 2);\n       memcpy(&udp_buf->destport, hc06_ptr + 3, 2);\n   \
    \    LOG_DBG(\"uncompression: UDP ports (ptr+5): %x, %x\\n\",\n@@ -1314,6 +1342,7\
    \ @@ uncompress_hdr_iphc(uint8_t *buf, uint16_t buf_size, uint16_t ip_len)\n \
    \    case SICSLOWPAN_NHC_UDP_CS_P_01:\n       /* 1 byte for NHC + source 16bit\
    \ inline, dest = 0xF0 + 8 bit inline */\n       LOG_DBG(\"uncompression: destination\
    \ address\\n\");\n+      CHECK_READ_SPACE(4);\n       memcpy(&udp_buf->srcport,\
    \ hc06_ptr + 1, 2);\n       udp_buf->destport = UIP_HTONS(SICSLOWPAN_UDP_8_BIT_PORT_MIN\
    \ + (*(hc06_ptr + 3)));\n       LOG_DBG(\"uncompression: UDP ports (ptr+4): %x,\
    \ %x\\n\",\n@@ -1324,6 +1353,7 @@ uncompress_hdr_iphc(uint8_t *buf, uint16_t buf_size,\
    \ uint16_t ip_len)\n     case SICSLOWPAN_NHC_UDP_CS_P_10:\n       /* 1 byte for\
    \ NHC + source = 0xF0 + 8bit inline, dest = 16 bit inline*/\n       LOG_DBG(\"\
    uncompression: source address\\n\");\n+      CHECK_READ_SPACE(4);\n       udp_buf->srcport\
    \ = UIP_HTONS(SICSLOWPAN_UDP_8_BIT_PORT_MIN +\n                              \
    \      (*(hc06_ptr + 1)));\n       memcpy(&udp_buf->destport, hc06_ptr + 2, 2);\n\
    @@ -1334,19 +1364,22 @@ uncompress_hdr_iphc(uint8_t *buf, uint16_t buf_size, uint16_t\
    \ ip_len)\n \n     case SICSLOWPAN_NHC_UDP_CS_P_11:\n       /* 1 byte for NHC,\
    \ 1 byte for ports */\n+      CHECK_READ_SPACE(2);\n       udp_buf->srcport =\
    \ UIP_HTONS(SICSLOWPAN_UDP_4_BIT_PORT_MIN +\n                                \
    \    (*(hc06_ptr + 1) >> 4));\n       udp_buf->destport = UIP_HTONS(SICSLOWPAN_UDP_4_BIT_PORT_MIN\
    \ +\n                                     ((*(hc06_ptr + 1)) & 0x0F));\n     \
    \  LOG_DBG(\"uncompression: UDP ports (ptr+2): %x, %x\\n\",\n              UIP_HTONS(udp_buf->srcport),\
    \ UIP_HTONS(udp_buf->destport));\n+\n       hc06_ptr += 2;\n       break;\n  \
    \   default:\n       LOG_DBG(\"uncompression: error unsupported UDP compression\\\
    n\");\n-      return;\n+      return false;\n     }\n     if(!checksum_compressed)\
    \ { /* has_checksum, default  */\n+      CHECK_READ_SPACE(2);\n       memcpy(&udp_buf->udpchksum,\
    \ hc06_ptr, 2);\n       hc06_ptr += 2;\n       LOG_DBG(\"uncompression: checksum\
    \ included\\n\");\n@@ -1380,6 +1413,8 @@ uncompress_hdr_iphc(uint8_t *buf, uint16_t\
    \ buf_size, uint16_t ip_len)\n     SICSLOWPAN_IP_BUF(buf)->len[0] = (ip_len -\
    \ UIP_IPH_LEN) >> 8;\n     SICSLOWPAN_IP_BUF(buf)->len[1] = (ip_len - UIP_IPH_LEN)\
    \ & 0x00FF;\n   }\n+\n+  return true;\n }\n /** @} */\n #endif /* SICSLOWPAN_COMPRESSION\
    \ >= SICSLOWPAN_COMPRESSION_IPHC */\n@@ -1936,7 +1971,10 @@ input(void)\n   if(SICSLOWPAN_COMPRESSION\
    \ > SICSLOWPAN_COMPRESSION_IPV6 &&\n      (PACKETBUF_6LO_PTR[PACKETBUF_6LO_DISPATCH]\
    \ & SICSLOWPAN_DISPATCH_IPHC_MASK) == SICSLOWPAN_DISPATCH_IPHC) {\n     LOG_DBG(\"\
    uncompression: IPHC dispatch\\n\");\n-    uncompress_hdr_iphc(buffer, buffer_size,\
    \ frag_size);\n+    if(uncompress_hdr_iphc(buffer, buffer_size, frag_size) ==\
    \ false) {\n+      LOG_ERR(\"input: failed to decompress IPHC packet\\n\");\n\
    +      return;\n+    }\n   } else if(PACKETBUF_6LO_PTR[PACKETBUF_6LO_DISPATCH]\
    \ == SICSLOWPAN_DISPATCH_IPV6) {\n     LOG_DBG(\"uncompression: IPV6 dispatch\\\
    n\");\n     packetbuf_hdr_len += SICSLOWPAN_IPV6_HDR_LEN;"
  identifiers: CVE:["CVE-2021-21410"],CWE:["CWE-125"]
  overview: Affected versions of this package are vulnerable to Out-of-bounds Read.
    Contiki-NG is an open-source, cross-platform operating system for Next-Generation
    IoT devices. An out-of-bounds read can be triggered by 6LoWPAN packets sent to
    devices running Contiki-NG 4.6 and prior. The IPv6 header decompression function
    (`uncompress_hdr_iphc`) does not perform proper boundary checks when reading from
    the packet buffer. Hence, it is possible to construct a compressed 6LoWPAN packet
    that will read more bytes than what is available from the packet buffer. As of
    time of publication, there is not a release with a patch available. Users can
    apply the patch for this vulnerability out-of-band as a workaround.
  references:
    GitHub Advisory: https://github.com/contiki-ng/contiki-ng/security/advisories/GHSA-hhwj-2p59-v8p9
    GitHub PR: https://github.com/contiki-ng/contiki-ng/pull/1482
    Github Commit: https://github.com/contiki-ng/contiki-ng/commit/aa6e26f430f3beaa3ce6b8290d4b19f73343e11f
  title: Out-of-bounds Read
- diff_content:
  - "--- a/os/net/app-layer/snmp/snmp-ber.c\n+++ b/os/net/app-layer/snmp/snmp-ber.c\n\
    @@ -128,6 +128,11 @@ snmp_ber_encode_null(unsigned char *out, uint32_t *out_len,\
    \ uint8_t type)\n unsigned char *\n snmp_ber_decode_type(unsigned char *buff,\
    \ uint32_t *buff_len, uint8_t *type)\n {\n+  if(*buff_len == 0)\n+  {\n+    return\
    \ NULL;\n+  }\n+\n   *type = *buff++;\n   (*buff_len)--;\n \n@@ -137,6 +142,11\
    \ @@ snmp_ber_decode_type(unsigned char *buff, uint32_t *buff_len, uint8_t *type)\n\
    \ unsigned char *\n snmp_ber_decode_length(unsigned char *buff, uint32_t *buff_len,\
    \ uint8_t *length)\n {\n+  if(*buff_len == 0)\n+  {\n+    return NULL;\n+  }\n\
    +\n   *length = *buff++;\n   (*buff_len)--;\n \n@@ -150,7 +160,8 @@ snmp_ber_decode_integer(unsigned\
    \ char *buf, uint32_t *buff_len, uint32_t *num)\n \n   buf = snmp_ber_decode_type(buf,\
    \ buff_len, &type);\n \n-  if(type != BER_DATA_TYPE_INTEGER) {\n+  if(buf == NULL\
    \ ||\n+     type != BER_DATA_TYPE_INTEGER) {\n     /*\n      * Sanity check\n\
    \      * Invalid type in buffer\n@@ -160,14 +171,20 @@ snmp_ber_decode_integer(unsigned\
    \ char *buf, uint32_t *buff_len, uint32_t *num)\n \n   buf = snmp_ber_decode_length(buf,\
    \ buff_len, &len);\n \n-  if(len > 4) {\n+  if(buf == NULL ||\n+     len > 4)\
    \ {\n     /*\n      * Sanity check\n      * It will not fit in the uint32_t\n\
    \      */\n     return NULL;\n   }\n \n+  if(*buff_len < len)\n+  {\n+    return\
    \ NULL;\n+  }\n+\n   *num = (uint32_t)(*buf++ & 0xFF);\n   (*buff_len)--;\n  \
    \ for(i = 1; i < len; ++i) {\n@@ -186,7 +203,8 @@ snmp_ber_decode_unsigned_integer(unsigned\
    \ char *buf, uint32_t *buff_len, uint8_t\n \n   buf = snmp_ber_decode_type(buf,\
    \ buff_len, &type);\n \n-  if(type != expected_type) {\n+  if(buf == NULL ||\n\
    +     type != expected_type) {\n     /*\n      * Sanity check\n      * Invalid\
    \ type in buffer\n@@ -196,14 +214,20 @@ snmp_ber_decode_unsigned_integer(unsigned\
    \ char *buf, uint32_t *buff_len, uint8_t\n \n   buf = snmp_ber_decode_length(buf,\
    \ buff_len, &len);\n \n-  if(len > 4) {\n+  if(buf == NULL ||\n+     len > 4)\
    \ {\n     /*\n      * Sanity check\n      * It will not fit in the uint32_t\n\
    \      */\n     return NULL;\n   }\n \n+  if(*buff_len < len)\n+  {\n+    return\
    \ NULL;\n+  }\n+\n   *num = (uint32_t)(*buf++ & 0xFF);\n   (*buff_len)--;\n  \
    \ for(i = 1; i < len; ++i) {\n@@ -222,7 +246,8 @@ snmp_ber_decode_string_len_buffer(unsigned\
    \ char *buf, uint32_t *buff_len, const\n \n   buf = snmp_ber_decode_type(buf,\
    \ buff_len, &type);\n \n-  if(type != BER_DATA_TYPE_OCTET_STRING) {\n+  if(buf\
    \ == NULL ||\n+    type != BER_DATA_TYPE_OCTET_STRING) {\n     /*\n      * Sanity\
    \ check\n      * Invalid type in buffer"
  - "--- a/os/net/app-layer/snmp/snmp-engine.c\n+++ b/os/net/app-layer/snmp/snmp-engine.c\n\
    @@ -206,7 +206,7 @@ snmp_engine(unsigned char *buff, uint32_t buff_len, unsigned\
    \ char *out, uint32_t\n {\n   static snmp_header_t header;\n   static snmp_varbind_t\
    \ varbinds[SNMP_MAX_NR_VALUES];\n-  static uint32_t varbind_length;\n+  static\
    \ uint32_t varbind_length = SNMP_MAX_NR_VALUES;\n \n   buff = snmp_message_decode(buff,\
    \ buff_len, &header, varbinds, &varbind_length);\n   if(buff == NULL) {"
  - "--- a/os/net/app-layer/snmp/snmp-message.c\n+++ b/os/net/app-layer/snmp/snmp-message.c\n\
    @@ -115,7 +115,7 @@ snmp_message_decode(uint8_t *buf, uint32_t buf_len, snmp_header_t\
    \ *header,\n                     snmp_varbind_t *varbinds, uint32_t *varbind_num)\n\
    \ {\n   uint8_t type, len;\n-  uint32_t i, oid_len;\n+  uint32_t i, oid_len =\
    \ SNMP_MSG_OID_MAX_LEN;\n \n   buf = snmp_ber_decode_type(buf, &buf_len, &type);\n\
    \   if(buf == NULL) {\n@@ -224,6 +224,10 @@ snmp_message_decode(uint8_t *buf,\
    \ uint32_t buf_len, snmp_header_t *header,\n   }\n \n   for(i = 0; buf_len > 0;\
    \ ++i) {\n+    if (i >= *varbind_num)\n+    {\n+      return NULL;\n+    }\n \n\
    \     buf = snmp_ber_decode_type(buf, &buf_len, &type);\n     if(buf == NULL)\
    \ {"
  identifiers: CVE:["CVE-2020-14936"],CWE:["CWE-787"]
  overview: Affected versions of this package are vulnerable to Out-of-bounds Write.
    Buffer overflows were discovered in Contiki-NG 4.4 through 4.5, in the SNMP agent.
    Functions parsing the OIDs in SNMP requests lack sufficient allocated target-buffer
    capacity verification when writing parsed OID values. The function snmp_oid_decode_oid()
    may overwrite memory areas beyond the provided target buffer, when called from
    snmp_message_decode() upon an SNMP request reception. Because the content of the
    write operations is externally provided in the SNMP requests, it enables a remote
    overwrite of an IoT device's memory regions beyond the allocated buffer. This
    overflow may allow remote overwrite of stack and statically allocated variables
    memory regions by sending a crafted SNMP request.
  references:
    GitHub Issue: https://github.com/contiki-ng/contiki-ng/issues/1351
    Github Commit: https://github.com/contiki-ng/contiki-ng/commit/35e5ac8aa760a424276ac4b1279a0f2649f47985
  title: Out-of-bounds Write
- diff_content:
  - "--- a/os/net/app-layer/snmp/snmp-ber.c\n+++ b/os/net/app-layer/snmp/snmp-ber.c\n\
    @@ -128,6 +128,11 @@ snmp_ber_encode_null(unsigned char *out, uint32_t *out_len,\
    \ uint8_t type)\n unsigned char *\n snmp_ber_decode_type(unsigned char *buff,\
    \ uint32_t *buff_len, uint8_t *type)\n {\n+  if(*buff_len == 0)\n+  {\n+    return\
    \ NULL;\n+  }\n+\n   *type = *buff++;\n   (*buff_len)--;\n \n@@ -137,6 +142,11\
    \ @@ snmp_ber_decode_type(unsigned char *buff, uint32_t *buff_len, uint8_t *type)\n\
    \ unsigned char *\n snmp_ber_decode_length(unsigned char *buff, uint32_t *buff_len,\
    \ uint8_t *length)\n {\n+  if(*buff_len == 0)\n+  {\n+    return NULL;\n+  }\n\
    +\n   *length = *buff++;\n   (*buff_len)--;\n \n@@ -150,7 +160,8 @@ snmp_ber_decode_integer(unsigned\
    \ char *buf, uint32_t *buff_len, uint32_t *num)\n \n   buf = snmp_ber_decode_type(buf,\
    \ buff_len, &type);\n \n-  if(type != BER_DATA_TYPE_INTEGER) {\n+  if(buf == NULL\
    \ ||\n+     type != BER_DATA_TYPE_INTEGER) {\n     /*\n      * Sanity check\n\
    \      * Invalid type in buffer\n@@ -160,14 +171,20 @@ snmp_ber_decode_integer(unsigned\
    \ char *buf, uint32_t *buff_len, uint32_t *num)\n \n   buf = snmp_ber_decode_length(buf,\
    \ buff_len, &len);\n \n-  if(len > 4) {\n+  if(buf == NULL ||\n+     len > 4)\
    \ {\n     /*\n      * Sanity check\n      * It will not fit in the uint32_t\n\
    \      */\n     return NULL;\n   }\n \n+  if(*buff_len < len)\n+  {\n+    return\
    \ NULL;\n+  }\n+\n   *num = (uint32_t)(*buf++ & 0xFF);\n   (*buff_len)--;\n  \
    \ for(i = 1; i < len; ++i) {\n@@ -186,7 +203,8 @@ snmp_ber_decode_unsigned_integer(unsigned\
    \ char *buf, uint32_t *buff_len, uint8_t\n \n   buf = snmp_ber_decode_type(buf,\
    \ buff_len, &type);\n \n-  if(type != expected_type) {\n+  if(buf == NULL ||\n\
    +     type != expected_type) {\n     /*\n      * Sanity check\n      * Invalid\
    \ type in buffer\n@@ -196,14 +214,20 @@ snmp_ber_decode_unsigned_integer(unsigned\
    \ char *buf, uint32_t *buff_len, uint8_t\n \n   buf = snmp_ber_decode_length(buf,\
    \ buff_len, &len);\n \n-  if(len > 4) {\n+  if(buf == NULL ||\n+     len > 4)\
    \ {\n     /*\n      * Sanity check\n      * It will not fit in the uint32_t\n\
    \      */\n     return NULL;\n   }\n \n+  if(*buff_len < len)\n+  {\n+    return\
    \ NULL;\n+  }\n+\n   *num = (uint32_t)(*buf++ & 0xFF);\n   (*buff_len)--;\n  \
    \ for(i = 1; i < len; ++i) {\n@@ -222,7 +246,8 @@ snmp_ber_decode_string_len_buffer(unsigned\
    \ char *buf, uint32_t *buff_len, const\n \n   buf = snmp_ber_decode_type(buf,\
    \ buff_len, &type);\n \n-  if(type != BER_DATA_TYPE_OCTET_STRING) {\n+  if(buf\
    \ == NULL ||\n+    type != BER_DATA_TYPE_OCTET_STRING) {\n     /*\n      * Sanity\
    \ check\n      * Invalid type in buffer"
  - "--- a/os/net/app-layer/snmp/snmp-engine.c\n+++ b/os/net/app-layer/snmp/snmp-engine.c\n\
    @@ -206,7 +206,7 @@ snmp_engine(unsigned char *buff, uint32_t buff_len, unsigned\
    \ char *out, uint32_t\n {\n   static snmp_header_t header;\n   static snmp_varbind_t\
    \ varbinds[SNMP_MAX_NR_VALUES];\n-  static uint32_t varbind_length;\n+  static\
    \ uint32_t varbind_length = SNMP_MAX_NR_VALUES;\n \n   buff = snmp_message_decode(buff,\
    \ buff_len, &header, varbinds, &varbind_length);\n   if(buff == NULL) {"
  - "--- a/os/net/app-layer/snmp/snmp-message.c\n+++ b/os/net/app-layer/snmp/snmp-message.c\n\
    @@ -115,7 +115,7 @@ snmp_message_decode(uint8_t *buf, uint32_t buf_len, snmp_header_t\
    \ *header,\n                     snmp_varbind_t *varbinds, uint32_t *varbind_num)\n\
    \ {\n   uint8_t type, len;\n-  uint32_t i, oid_len;\n+  uint32_t i, oid_len =\
    \ SNMP_MSG_OID_MAX_LEN;\n \n   buf = snmp_ber_decode_type(buf, &buf_len, &type);\n\
    \   if(buf == NULL) {\n@@ -224,6 +224,10 @@ snmp_message_decode(uint8_t *buf,\
    \ uint32_t buf_len, snmp_header_t *header,\n   }\n \n   for(i = 0; buf_len > 0;\
    \ ++i) {\n+    if (i >= *varbind_num)\n+    {\n+      return NULL;\n+    }\n \n\
    \     buf = snmp_ber_decode_type(buf, &buf_len, &type);\n     if(buf == NULL)\
    \ {"
  identifiers: CVE:["CVE-2020-14937"],CWE:["CWE-125","CWE-787"]
  overview: Affected versions of this package are vulnerable to Out-of-bounds Write.
    Memory access out of buffer boundaries issues was discovered in Contiki-NG 4.4
    through 4.5, in the SNMP BER encoder/decoder. The length of provided input/output
    buffers is insufficiently verified during the encoding and decoding of data. This
    may lead to out-of-bounds buffer read or write access in BER decoding and encoding
    functions.
  references:
    GitHub Issue: https://github.com/contiki-ng/contiki-ng/issues/1354
    Github Commit: https://github.com/contiki-ng/contiki-ng/commit/35e5ac8aa760a424276ac4b1279a0f2649f47985
  title: Out-of-bounds Write
- diff_content:
  - "--- a/os/net/app-layer/snmp/snmp-ber.c\n+++ b/os/net/app-layer/snmp/snmp-ber.c\n\
    @@ -128,6 +128,11 @@ snmp_ber_encode_null(unsigned char *out, uint32_t *out_len,\
    \ uint8_t type)\n unsigned char *\n snmp_ber_decode_type(unsigned char *buff,\
    \ uint32_t *buff_len, uint8_t *type)\n {\n+  if(*buff_len == 0)\n+  {\n+    return\
    \ NULL;\n+  }\n+\n   *type = *buff++;\n   (*buff_len)--;\n \n@@ -137,6 +142,11\
    \ @@ snmp_ber_decode_type(unsigned char *buff, uint32_t *buff_len, uint8_t *type)\n\
    \ unsigned char *\n snmp_ber_decode_length(unsigned char *buff, uint32_t *buff_len,\
    \ uint8_t *length)\n {\n+  if(*buff_len == 0)\n+  {\n+    return NULL;\n+  }\n\
    +\n   *length = *buff++;\n   (*buff_len)--;\n \n@@ -150,7 +160,8 @@ snmp_ber_decode_integer(unsigned\
    \ char *buf, uint32_t *buff_len, uint32_t *num)\n \n   buf = snmp_ber_decode_type(buf,\
    \ buff_len, &type);\n \n-  if(type != BER_DATA_TYPE_INTEGER) {\n+  if(buf == NULL\
    \ ||\n+     type != BER_DATA_TYPE_INTEGER) {\n     /*\n      * Sanity check\n\
    \      * Invalid type in buffer\n@@ -160,14 +171,20 @@ snmp_ber_decode_integer(unsigned\
    \ char *buf, uint32_t *buff_len, uint32_t *num)\n \n   buf = snmp_ber_decode_length(buf,\
    \ buff_len, &len);\n \n-  if(len > 4) {\n+  if(buf == NULL ||\n+     len > 4)\
    \ {\n     /*\n      * Sanity check\n      * It will not fit in the uint32_t\n\
    \      */\n     return NULL;\n   }\n \n+  if(*buff_len < len)\n+  {\n+    return\
    \ NULL;\n+  }\n+\n   *num = (uint32_t)(*buf++ & 0xFF);\n   (*buff_len)--;\n  \
    \ for(i = 1; i < len; ++i) {\n@@ -186,7 +203,8 @@ snmp_ber_decode_unsigned_integer(unsigned\
    \ char *buf, uint32_t *buff_len, uint8_t\n \n   buf = snmp_ber_decode_type(buf,\
    \ buff_len, &type);\n \n-  if(type != expected_type) {\n+  if(buf == NULL ||\n\
    +     type != expected_type) {\n     /*\n      * Sanity check\n      * Invalid\
    \ type in buffer\n@@ -196,14 +214,20 @@ snmp_ber_decode_unsigned_integer(unsigned\
    \ char *buf, uint32_t *buff_len, uint8_t\n \n   buf = snmp_ber_decode_length(buf,\
    \ buff_len, &len);\n \n-  if(len > 4) {\n+  if(buf == NULL ||\n+     len > 4)\
    \ {\n     /*\n      * Sanity check\n      * It will not fit in the uint32_t\n\
    \      */\n     return NULL;\n   }\n \n+  if(*buff_len < len)\n+  {\n+    return\
    \ NULL;\n+  }\n+\n   *num = (uint32_t)(*buf++ & 0xFF);\n   (*buff_len)--;\n  \
    \ for(i = 1; i < len; ++i) {\n@@ -222,7 +246,8 @@ snmp_ber_decode_string_len_buffer(unsigned\
    \ char *buf, uint32_t *buff_len, const\n \n   buf = snmp_ber_decode_type(buf,\
    \ buff_len, &type);\n \n-  if(type != BER_DATA_TYPE_OCTET_STRING) {\n+  if(buf\
    \ == NULL ||\n+    type != BER_DATA_TYPE_OCTET_STRING) {\n     /*\n      * Sanity\
    \ check\n      * Invalid type in buffer"
  - "--- a/os/net/app-layer/snmp/snmp-engine.c\n+++ b/os/net/app-layer/snmp/snmp-engine.c\n\
    @@ -206,7 +206,7 @@ snmp_engine(unsigned char *buff, uint32_t buff_len, unsigned\
    \ char *out, uint32_t\n {\n   static snmp_header_t header;\n   static snmp_varbind_t\
    \ varbinds[SNMP_MAX_NR_VALUES];\n-  static uint32_t varbind_length;\n+  static\
    \ uint32_t varbind_length = SNMP_MAX_NR_VALUES;\n \n   buff = snmp_message_decode(buff,\
    \ buff_len, &header, varbinds, &varbind_length);\n   if(buff == NULL) {"
  - "--- a/os/net/app-layer/snmp/snmp-message.c\n+++ b/os/net/app-layer/snmp/snmp-message.c\n\
    @@ -115,7 +115,7 @@ snmp_message_decode(uint8_t *buf, uint32_t buf_len, snmp_header_t\
    \ *header,\n                     snmp_varbind_t *varbinds, uint32_t *varbind_num)\n\
    \ {\n   uint8_t type, len;\n-  uint32_t i, oid_len;\n+  uint32_t i, oid_len =\
    \ SNMP_MSG_OID_MAX_LEN;\n \n   buf = snmp_ber_decode_type(buf, &buf_len, &type);\n\
    \   if(buf == NULL) {\n@@ -224,6 +224,10 @@ snmp_message_decode(uint8_t *buf,\
    \ uint32_t buf_len, snmp_header_t *header,\n   }\n \n   for(i = 0; buf_len > 0;\
    \ ++i) {\n+    if (i >= *varbind_num)\n+    {\n+      return NULL;\n+    }\n \n\
    \     buf = snmp_ber_decode_type(buf, &buf_len, &type);\n     if(buf == NULL)\
    \ {"
  identifiers: CVE:["CVE-2020-14935"],CWE:["CWE-787"]
  overview: Affected versions of this package are vulnerable to Out-of-bounds Write.
    Buffer overflows were discovered in Contiki-NG 4.4 through 4.5, in the SNMP bulk
    get request response encoding function. The function parsing the received SNMP
    request does not verify the input message's requested variables against the capacity
    of the internal SNMP engine buffer. When a bulk get request response is assembled,
    a stack buffer dedicated for OIDs (with a limited capacity) is allocated in snmp_engine_get_bulk().
    When snmp_engine_get_bulk() is populating the stack buffer, an overflow condition
    may occur due to lack of input length validation. This makes it possible to overwrite
    stack regions beyond the allocated buffer, including the return address from the
    function. As a result, the code execution path may be redirected to an address
    provided in the SNMP bulk get payload. If the target architecture uses common
    addressing space for program and data memory, it may also be possible to supply
    code in the SNMP request payload, and redirect the execution path to the remotely
    injected code, by modifying the function's return address.
  references:
    GitHub Issue: https://github.com/contiki-ng/contiki-ng/issues/1353
    Github Commit: https://github.com/contiki-ng/contiki-ng/commit/35e5ac8aa760a424276ac4b1279a0f2649f47985
  title: Out-of-bounds Write
- diff_content:
  - "--- a/os/storage/antelope/aql-adt.c\n+++ b/os/storage/antelope/aql-adt.c\n@@\
    \ -90,6 +90,21 @@ aql_clear(aql_adt_t *adt)\n   memset(adt->aggregators, 0, sizeof(adt->aggregators));\n\
    \ }\n \n+db_result_t\n+aql_add_relation(aql_adt_t *adt, const char *name)\n+{\n\
    +  if(adt->relation_count >= AQL_RELATION_LIMIT) {\n+    return DB_LIMIT_ERROR;\n\
    +  }\n+\n+  strncpy(adt->relations[adt->relation_count], name,\n+\t  sizeof(adt->relations[0])\
    \ - 1);\n+  adt->relations[adt->relation_count][sizeof(adt->relations[0]) - 1]\
    \ = '\\0';\n+  adt->relation_count++;\n+\n+  return DB_OK;\n+}\n+\n db_result_t\n\
    \ aql_add_attribute(aql_adt_t *adt, char *name, domain_t domain,\n           \
    \         unsigned element_size, int processed_only)"
  - "--- a/os/storage/antelope/aql-lexer.c\n+++ b/os/storage/antelope/aql-lexer.c\n\
    @@ -207,6 +207,10 @@ next_string(lexer_t *lexer, const char *s)\n   *lexer->token\
    \ = STRING_VALUE;\n   lexer->input = end + 1; /* Skip the closing delimiter. */\n\
    \ \n+  if(length > DB_MAX_ELEMENT_SIZE - 1) {\n+    length = DB_MAX_ELEMENT_SIZE\
    \ - 1;\n+  }\n+\n   memcpy(lexer->value, s, length);\n   (*lexer->value)[length]\
    \ = '\\0';\n \n@@ -236,6 +240,10 @@ next_token(lexer_t *lexer, const char *s)\n\
    \ \n   *lexer->token = IDENTIFIER;\n \n+  if(length > DB_MAX_ELEMENT_SIZE - 1)\
    \ {\n+    length = DB_MAX_ELEMENT_SIZE - 1;\n+  }\n+\n   memcpy(lexer->value,\
    \ s, length);\n   (*lexer->value)[length] = '\\0';\n "
  - "--- a/os/storage/antelope/aql-parser.c\n+++ b/os/storage/antelope/aql-parser.c\n\
    @@ -269,16 +269,20 @@ PARSER(operand)\n   NEXT;\n   switch(TOKEN) {\n   case IDENTIFIER:\n\
    -    lvm_register_variable(VALUE, LVM_LONG);\n-    lvm_set_variable(&p, VALUE);\n\
    +    if(LVM_ERROR(lvm_register_variable(VALUE, LVM_LONG)) ||\n+       LVM_ERROR(lvm_set_variable(&p,\
    \ VALUE))) {\n+      RETURN(SYNTAX_ERROR);\n+    }\n     AQL_ADD_PROCESSING_ATTRIBUTE(adt,\
    \ VALUE);\n     break;\n   case STRING_VALUE:\n     break;\n   case FLOAT_VALUE:\n\
    \     break;\n   case INTEGER_VALUE:\n-    lvm_set_long(&p, *(long *)lexer->value);\n\
    +    if(LVM_ERROR(lvm_set_long(&p, *(long *)lexer->value))) {\n+      RETURN(SYNTAX_ERROR);\n\
    +    }\n     break;\n   default:\n     RETURN(SYNTAX_ERROR);\n@@ -340,7 +344,9\
    \ @@ PARSER(expr)\n     default:\n       RETURN(SYNTAX_ERROR);\n     }\n-    lvm_set_op(&p,\
    \ op);\n+    if(LVM_ERROR(lvm_set_op(&p, op))) {\n+      RETURN(SYNTAX_ERROR);\n\
    +    }\n     lvm_set_end(&p, saved_end);\n   }\n \n@@ -389,7 +395,9 @@ PARSER(comparison)\n\
    \     RETURN(SYNTAX_ERROR);\n   }\n \n-  lvm_set_relation(&p, rel);\n+  if(LVM_ERROR(lvm_set_relation(&p,\
    \ rel))) {\n+    RETURN(SYNTAX_ERROR);\n+  }\n   lvm_set_end(&p, saved_end);\n\
    \ \n   if(!PARSE(expr)) {\n@@ -422,7 +430,9 @@ PARSER(where)\n     connective\
    \ = TOKEN == AND ? LVM_AND : LVM_OR;\n \n     saved_end = lvm_shift_for_operator(&p,\
    \ saved_end);\n-    lvm_set_relation(&p, connective);\n+    if(LVM_ERROR(lvm_set_relation(&p,\
    \ connective))) {\n+      RETURN(SYNTAX_ERROR);\n+    }\n     lvm_set_end(&p,\
    \ saved_end);\n   \n     NEXT;"
  - "--- a/os/storage/antelope/lvm.c\n+++ b/os/storage/antelope/lvm.c\n@@ -82,10 +82,10\
    \ @@ typedef struct derivation derivation_t;\n \n /* Registered variables for\
    \ a LVM expression. Their values may be \n    changed between executions of the\
    \ expression. */\n-static variable_t variables[LVM_MAX_VARIABLE_ID - 1];\n+static\
    \ variable_t variables[LVM_MAX_VARIABLE_ID];\n \n /* Range derivations of variables\
    \ that are used for index searches. */\n-static derivation_t derivations[LVM_MAX_VARIABLE_ID\
    \ - 1];\n+static derivation_t derivations[LVM_MAX_VARIABLE_ID];\n \n #if DEBUG\n\
    \ static void\n@@ -187,7 +187,7 @@ eval_expr(lvm_instance_t *p, operator_t op,\
    \ operand_t *result)\n       get_operand(p, &operand[i]);\n       break;\n   \
    \  default:\n-      return SEMANTIC_ERROR;\n+      return LVM_SEMANTIC_ERROR;\n\
    \     }\n     value[i] = operand_to_long(&operand[i]);\n   }\n@@ -204,18 +204,18\
    \ @@ eval_expr(lvm_instance_t *p, operator_t op, operand_t *result)\n     break;\n\
    \   case LVM_DIV:\n     if(value[1] == 0) {\n-      return MATH_ERROR;\n+    \
    \  return LVM_MATH_ERROR;\n     }\n     result_value = value[0] / value[1];\n\
    \     break;\n   default:\n-    return EXECUTION_ERROR;\n+    return LVM_EXECUTION_ERROR;\n\
    \   }\n \n   result->type = LVM_LONG;\n   result->value.l = result_value;\n \n\
    -  return TRUE;\n+  return LVM_TRUE;\n }\n \n static int\n@@ -236,7 +236,7 @@\
    \ eval_logic(lvm_instance_t *p, operator_t *op)\n     for(i = 0; i < arguments;\
    \ i++) {\n       type = get_type(p);\n       if(type != LVM_CMP_OP) {\n-\treturn\
    \ SEMANTIC_ERROR;\n+\treturn LVM_SEMANTIC_ERROR;\n       }\n       operator =\
    \ get_operator(p);\n       logic_result[i] = eval_logic(p, operator);\n@@ -248,9\
    \ +248,9 @@ eval_logic(lvm_instance_t *p, operator_t *op)\n     if(*op == LVM_NOT)\
    \ {\n       return !logic_result[0];\n     } else if(*op == LVM_AND) {\n-    \
    \  return logic_result[0] == TRUE && logic_result[1] == TRUE;\n+      return logic_result[0]\
    \ == LVM_TRUE && logic_result[1] == LVM_TRUE;\n     } else {\n-      return logic_result[0]\
    \ == TRUE || logic_result[1] == TRUE;\n+      return logic_result[0] == LVM_TRUE\
    \ || logic_result[1] == LVM_TRUE;\n     }\n   }\n \n@@ -268,7 +268,7 @@ eval_logic(lvm_instance_t\
    \ *p, operator_t *op)\n       get_operand(p, &operand);\n       break;\n     default:\n\
    -      return SEMANTIC_ERROR;\n+      return LVM_SEMANTIC_ERROR;\n     }\n   \
    \  result[i] = operand_to_long(&operand);\n   }\n@@ -294,7 +294,7 @@ eval_logic(lvm_instance_t\
    \ *p, operator_t *op)\n     break;\n   }\n \n-  return EXECUTION_ERROR;\n+  return\
    \ LVM_EXECUTION_ERROR;\n }\n \n void\n@@ -334,7 +334,8 @@ lvm_shift_for_operator(lvm_instance_t\
    \ *p, lvm_ip_t end)\n \n   old_end = p->end;\n \n-  if(p->end + sizeof(operator_t)\
    \ > p->size || end >= old_end) {\n+  if(p->end + sizeof(operator_t) + sizeof(node_type_t)\
    \ > p->size ||\n+     end >= old_end) {\n     p->error = __LINE__;\n     return\
    \ 0;\n   }\n@@ -369,13 +370,6 @@ lvm_set_end(lvm_instance_t *p, lvm_ip_t end)\n\
    \   return old_end;\n }\n \n-void\n-lvm_set_type(lvm_instance_t *p, node_type_t\
    \ type)\n-{\n-  *(node_type_t *)(p->code + p->end) = type;\n-  p->end += sizeof(type);\n\
    -}\n-\n lvm_status_t\n lvm_execute(lvm_instance_t *p)\n {\n@@ -384,14 +378,14\
    \ @@ lvm_execute(lvm_instance_t *p)\n   lvm_status_t status;\n \n   p->ip = 0;\n\
    -  status = EXECUTION_ERROR;\n+  status = LVM_EXECUTION_ERROR;\n   type = get_type(p);\n\
    \   switch(type) {\n   case LVM_CMP_OP:\n     operator = get_operator(p);\n  \
    \   status = eval_logic(p, operator);\n     if(!LVM_ERROR(status)) {\n-      PRINTF(\"\
    The statement is %s\\n\", status == TRUE ? \"true\" : \"false\");\n+      PRINTF(\"\
    The statement is %s\\n\", status == LVM_TRUE ? \"true\" : \"false\");\n     }\
    \ else {\n       PRINTF(\"Execution error: %d\\n\", (int)status);\n     }\n@@\
    \ -403,39 +397,88 @@ lvm_execute(lvm_instance_t *p)\n   return status;\n }\n \n\
    -void\n+lvm_status_t\n+lvm_set_type(lvm_instance_t *p, node_type_t type)\n+{\n\
    +  if(p->end + sizeof(node_type_t) >= DB_VM_BYTECODE_SIZE) {\n+    PRINTF(\"Error:\
    \ overflow in lvm_set_type\\n\");\n+    return LVM_STACK_OVERFLOW;\n+  }\n+\n\
    +  *(node_type_t *)(p->code + p->end) = type;\n+  p->end += sizeof(type);\n+ \
    \ return LVM_TRUE;\n+}\n+\n+lvm_status_t\n lvm_set_op(lvm_instance_t *p, operator_t\
    \ op)\n {\n-  lvm_set_type(p, LVM_ARITH_OP);\n+  lvm_status_t status;\n+\n+  status\
    \ = lvm_set_type(p, LVM_ARITH_OP);\n+  if(status != LVM_TRUE) {\n+    return status;\n\
    +  }\n+\n+  if(p->end + sizeof(op) >= DB_VM_BYTECODE_SIZE) {\n+    PRINTF(\"Error:\
    \ overflow in lvm_set_op\\n\");\n+    return LVM_STACK_OVERFLOW;\n+  }\n+\n  \
    \ memcpy(&p->code[p->end], &op, sizeof(op));\n   p->end += sizeof(op);\n+  return\
    \ LVM_TRUE;\n }\n \n-void\n+lvm_status_t\n lvm_set_relation(lvm_instance_t *p,\
    \ operator_t op)\n {\n-  lvm_set_type(p, LVM_CMP_OP);\n+  lvm_status_t status;\n\
    +\n+  status = lvm_set_type(p, LVM_CMP_OP);\n+  if(status != LVM_TRUE) {\n+  \
    \  return status;\n+  }\n+\n+  if(p->end + sizeof(op) >= DB_VM_BYTECODE_SIZE)\
    \ {\n+    PRINTF(\"Error: overflow in lvm_set_relation\\n\");\n+    return LVM_STACK_OVERFLOW;\n\
    +  }\n+\n   memcpy(&p->code[p->end], &op, sizeof(op));\n   p->end += sizeof(op);\n\
    +  return LVM_TRUE;\n }\n \n-void\n+lvm_status_t\n lvm_set_operand(lvm_instance_t\
    \ *p, operand_t *op)\n {\n-  lvm_set_type(p, LVM_OPERAND);\n+  lvm_status_t status;\n\
    +\n+  status = lvm_set_type(p, LVM_OPERAND);\n+  if(status != LVM_TRUE) {\n+ \
    \   return status;\n+  }\n+\n+  if(p->end + sizeof(*op) >= DB_VM_BYTECODE_SIZE)\
    \ {\n+    PRINTF(\"Error: overflow in lvm_set_operand\\n\");\n+    return LVM_STACK_OVERFLOW;\n\
    +  }\n+\n   memcpy(&p->code[p->end], op, sizeof(*op));\n   p->end += sizeof(*op);\n\
    +  return LVM_TRUE;\n }\n \n-void\n+lvm_status_t\n lvm_set_long(lvm_instance_t\
    \ *p, long l)\n {\n   operand_t op;\n \n   op.type = LVM_LONG;\n   op.value.l\
    \ = l;\n \n-  lvm_set_operand(p, &op);\n+  return lvm_set_operand(p, &op);\n }\n\
    \ \n lvm_status_t\n@@ -446,7 +489,7 @@ lvm_register_variable(char *name, operand_type_t\
    \ type)\n \n   id = lookup(name);\n   if(id == LVM_MAX_VARIABLE_ID) {\n-    return\
    \ VARIABLE_LIMIT_REACHED;\n+    return LVM_VARIABLE_LIMIT_REACHED;\n   }\n \n\
    \   var = &variables[id];\n@@ -456,7 +499,7 @@ lvm_register_variable(char *name,\
    \ operand_type_t type)\n     var->type = type;\n   }\n \n-  return TRUE;\n+  return\
    \ LVM_TRUE;\n }\n \n lvm_status_t\n@@ -466,25 +509,28 @@ lvm_set_variable_value(char\
    \ *name, operand_value_t value)\n \n   id = lookup(name);\n   if(id == LVM_MAX_VARIABLE_ID)\
    \ {\n-    return INVALID_IDENTIFIER;\n+    return LVM_INVALID_IDENTIFIER;\n  \
    \ }\n+\n   variables[id].value = value;\n-  return TRUE;\n+  return LVM_TRUE;\n\
    \ }\n \n-void\n+lvm_status_t\n lvm_set_variable(lvm_instance_t *p, char *name)\n\
    \ {\n   operand_t op;\n   variable_id_t id;\n \n   id = lookup(name);\n-  if(id\
    \ < LVM_MAX_VARIABLE_ID) {\n-    PRINTF(\"var id = %d\\n\", id);\n-    op.type\
    \ = LVM_VARIABLE;\n-    op.value.id = id;\n-    lvm_set_operand(p, &op);\n+  if(id\
    \ == LVM_MAX_VARIABLE_ID) {\n+    return LVM_INVALID_IDENTIFIER;\n   }\n+\n+ \
    \ PRINTF(\"var id = %d\\n\", id);\n+  op.type = LVM_VARIABLE;\n+  op.value.id\
    \ = id;\n+  return lvm_set_operand(p, &op);\n }\n \n void\n@@ -598,7 +644,7 @@\
    \ derive_relation(lvm_instance_t *p, derivation_t *local_derivations)\n     derivation_t\
    \ d2[LVM_MAX_VARIABLE_ID];\n \n     if(*operator != LVM_AND && *operator != LVM_OR)\
    \ {\n-      return DERIVATION_ERROR;\n+      return LVM_DERIVATION_ERROR;\n  \
    \   }\n \n     PRINTF(\"Attempting to infer ranges from a logical connective\\\
    n\");\n@@ -608,15 +654,15 @@ derive_relation(lvm_instance_t *p, derivation_t *local_derivations)\n\
    \ \n     if(LVM_ERROR(derive_relation(p, d1)) ||\n        LVM_ERROR(derive_relation(p,\
    \ d2))) {\n-      return DERIVATION_ERROR;\n+      return LVM_DERIVATION_ERROR;\n\
    \     }\n \n     if(*operator == LVM_AND) {\n       create_intersection(local_derivations,\
    \ d1, d2);\n     } else if(*operator == LVM_OR) {\n       create_union(local_derivations,\
    \ d1, d2);\n     }\n-    return TRUE;\n+    return LVM_TRUE;\n   }\n \n   for(i\
    \ = 0; i < 2; i++) {\n@@ -626,18 +672,18 @@ derive_relation(lvm_instance_t *p,\
    \ derivation_t *local_derivations)\n       get_operand(p, &operand[i]);\n    \
    \   break;\n     default:\n-      return DERIVATION_ERROR;\n+      return LVM_DERIVATION_ERROR;\n\
    \     }\n   }\n \n   if(operand[0].type == LVM_VARIABLE && operand[1].type ==\
    \ LVM_VARIABLE) {\n-    return DERIVATION_ERROR;\n+    return LVM_DERIVATION_ERROR;\n\
    \   }\n \n   /* Determine which of the operands that is the variable. */\n   if(operand[0].type\
    \ == LVM_VARIABLE) {\n     if(operand[1].type == LVM_VARIABLE) {\n-      return\
    \ DERIVATION_ERROR;\n+      return LVM_DERIVATION_ERROR;\n     }\n     variable_id\
    \ = operand[0].value.id;\n     value = &operand[1].value;\n@@ -647,7 +693,7 @@\
    \ derive_relation(lvm_instance_t *p, derivation_t *local_derivations)\n   }\n\
    \ \n   if(variable_id >= LVM_MAX_VARIABLE_ID) {\n-     return DERIVATION_ERROR;\n\
    +     return LVM_DERIVATION_ERROR;\n   }\n \n   PRINTF(\"variable id %d, value\
    \ %ld\\n\", variable_id, *(long *)value);\n@@ -675,12 +721,12 @@ derive_relation(lvm_instance_t\
    \ *p, derivation_t *local_derivations)\n     derivation->max.l = value->l;\n \
    \    break;\n   default:\n-    return DERIVATION_ERROR;\n+    return LVM_DERIVATION_ERROR;\n\
    \   }\n \n   derivation->derived = 1;\n \n-  return TRUE;\n+  return LVM_TRUE;\n\
    \ }\n \n lvm_status_t\n@@ -700,12 +746,12 @@ lvm_get_derived_range(lvm_instance_t\
    \ *p, char *name,\n       if(derivations[i].derived) {\n         *min = derivations[i].min;\n\
    \         *max = derivations[i].max;\n-        return TRUE;\n+        return LVM_TRUE;\n\
    \       }\n-      return DERIVATION_ERROR;\n+      return LVM_DERIVATION_ERROR;\n\
    \     }\n   }\n-  return INVALID_IDENTIFIER;\n+  return LVM_INVALID_IDENTIFIER;\n\
    \ }\n \n #if DEBUG\n@@ -755,7 +801,8 @@ print_operand(lvm_instance_t *p, lvm_ip_t\
    \ index)\n \n   switch(operand.type) {\n   case LVM_VARIABLE:\n-  if(operand.value.id\
    \ >= LVM_MAX_VARIABLE_ID || variables[operand.value.id].name == NULL) {\n+  if(operand.value.id\
    \ >= LVM_MAX_VARIABLE_ID ||\n+     variables[operand.value.id].name == NULL) {\n\
    \     PRINTF(\"var(id:%d):?? \", operand.value.id);\n   } else {\n     PRINTF(\"\
    var(%s):%ld \", variables[operand.value.id].name,"
  - "--- a/os/storage/antelope/relation.c\n+++ b/os/storage/antelope/relation.c\n\
    @@ -813,9 +813,9 @@ relation_process_select(void *handle_ptr)\n     }\n   }\n\
    \ \n-  wanted_result = TRUE;\n+  wanted_result = LVM_TRUE;\n   if(AQL_GET_FLAGS(adt)\
    \ & AQL_FLAG_INVERSE_LOGIC) {\n-    wanted_result = FALSE;\n+    wanted_result\
    \ = LVM_FALSE;\n   }\n \n   /* Check whether the given predicate is true for this\
    \ tuple. */"
  identifiers: CVE:["CVE-2018-1000804"],CWE:["CWE-119"]
  overview: Affected versions of this package are vulnerable to Out-of-Bounds contiki-ng
    version 4 contains a Buffer Overflow vulnerability in AQL (Antelope Query Language)
    database engine that can result in Attacker can perform Remote Code Execution
    on device using Contiki-NG operating system. This attack appear to be exploitable
    via Attacker must be able to run malicious AQL code (e.g. via SQL-like Injection
    attack).
  references:
    GitHub Issue: https://github.com/contiki-ng/contiki-ng/issues/594
    GitHub PR: https://github.com/contiki-ng/contiki-ng/pull/624
    Github Commit: https://github.com/contiki-ng/contiki-ng/commit/6ebdbf0675844918623e5a878b910fea38ee88de
  title: Out-of-Bounds
- diff_content:
  - "--- a/os/net/routing/rpl-classic/rpl-ext-header.c\n+++ b/os/net/routing/rpl-classic/rpl-ext-header.c\n\
    @@ -240,8 +240,16 @@ rpl_ext_header_srh_update(void)\n       return 0;\n     }\
    \ else {\n       uint8_t i = path_len - segments_left; /* The index of the next\
    \ address to be visited */\n-      uint8_t *addr_ptr = ((uint8_t *)rh_header)\
    \ + RPL_RH_LEN + RPL_SRH_LEN + (i * (16 - cmpri));\n       uint8_t cmpr = segments_left\
    \ == 1 ? cmpre : cmpri;\n+      ptrdiff_t rh_offset = (uint8_t *)rh_header - uip_buf;\n\
    +      size_t addr_offset = RPL_RH_LEN + RPL_SRH_LEN + (i * (16 - cmpri));\n+\n\
    +      if(rh_offset + addr_offset + 16 - cmpr > UIP_BUFSIZE) {\n+        LOG_ERR(\"\
    Invalid SRH address pointer\\n\");\n+        return 0;\n+      }\n+\n+      uint8_t\
    \ *addr_ptr = ((uint8_t *)rh_header) + addr_offset;\n \n       /* As per RFC6554:\
    \ swap the IPv6 destination address and address[i] */\n "
  - "--- a/os/net/routing/rpl-lite/rpl-ext-header.c\n+++ b/os/net/routing/rpl-lite/rpl-ext-header.c\n\
    @@ -130,8 +130,16 @@ rpl_ext_header_srh_update(void)\n     return 0;\n   } else\
    \ {\n     uint8_t i = path_len - segments_left; /* The index of the next address\
    \ to be visited */\n-    uint8_t *addr_ptr = ((uint8_t *)rh_header) + RPL_RH_LEN\
    \ + RPL_SRH_LEN + (i * (16 - cmpri));\n     uint8_t cmpr = segments_left == 1\
    \ ? cmpre : cmpri;\n+    ptrdiff_t rh_offset = (uint8_t *)rh_header - uip_buf;\n\
    +    size_t addr_offset = RPL_RH_LEN + RPL_SRH_LEN + (i * (16 - cmpri));\n+\n\
    +    if(rh_offset + addr_offset + 16 - cmpr > UIP_BUFSIZE) {\n+      LOG_ERR(\"\
    Invalid SRH address pointer\\n\");\n+      return 0;\n+    }\n+\n+    uint8_t\
    \ *addr_ptr = ((uint8_t *)rh_header) + addr_offset;\n \n     /* As per RFC6554:\
    \ swap the IPv6 destination address with address[i] */\n "
  identifiers: CVE:["CVE-2021-21257"],CWE:["CWE-787"]
  overview: Affected versions of this package are vulnerable to Out-of-bounds Write.
    Contiki-NG is an open-source, cross-platform operating system for internet of
    things devices. The RPL-Classic and RPL-Lite implementations in the Contiki-NG
    operating system versions prior to 4.6 do not validate the address pointer in
    the RPL source routing header This makes it possible for an attacker to cause
    out-of-bounds writes with packets injected into the network stack. Specifically,
    the problem lies in the rpl_ext_header_srh_update function in the two rpl-ext-header.c
    modules for RPL-Classic and RPL-Lite respectively. The addr_ptr variable is calculated
    using an unvalidated CMPR field value from the source routing header. An out-of-bounds
    write can be triggered on line 151 in os/net/routing/rpl-lite/rpl-ext-header.c
    and line 261 in os/net/routing/rpl-classic/rpl-ext-header.c, which contain the
    following memcpy call with addr_ptr as destination. The problem has been patched
    in Contiki-NG 4.6. Users can apply a patch out-of-band as a workaround.
  references:
    GitHub Advisory: https://github.com/contiki-ng/contiki-ng/security/advisories/GHSA-mvc7-9p4q-c5cm
    GitHub PR: https://github.com/contiki-ng/contiki-ng/pull/1431
    Github Commit: https://github.com/contiki-ng/contiki-ng/commit/3f9a601e2de998a79cbe3320aaa5dfbbaec1678c
  title: Out-of-bounds Write
- diff_content:
  - "--- a/os/net/ipv6/sicslowpan.c\n+++ b/os/net/ipv6/sicslowpan.c\n@@ -123,6 +123,7\
    \ @@\n \n #define UIP_IPPAYLOAD_BUF_POS(pos)         (&uip_buf[UIP_IPH_LEN + (pos)])\n\
    \ #define UIP_UDP_BUF_POS(pos)               ((struct uip_udp_hdr *)UIP_IPPAYLOAD_BUF_POS(pos))\n\
    +#define UIP_EXT_HDR_LEN                    2\n \n /** @} */\n \n@@ -1063,12 +1064,13\
    \ @@ compress_hdr_iphc(linkaddr_t *link_destaddr)\n  * are set to the appropriate\
    \ values\n  *\n  * \\param buf Pointer to the buffer to uncompress the packet\
    \ into.\n+ * \\param buf_size The size of the buffer to uncompress the packet\
    \ into.\n  * \\param ip_len Equal to 0 if the packet is not a fragment (IP length\n\
    \  * is then inferred from the L2 length), non 0 if the packet is a 1st\n  * fragment.\n\
    \  */\n static void\n-uncompress_hdr_iphc(uint8_t *buf, uint16_t ip_len)\n+uncompress_hdr_iphc(uint8_t\
    \ *buf, uint16_t buf_size, uint16_t ip_len)\n {\n   uint8_t tmp, iphc0, iphc1,\
    \ nhc;\n   struct uip_ext_hdr *exthdr;\n@@ -1262,23 +1264,32 @@ uncompress_hdr_iphc(uint8_t\
    \ *buf, uint16_t ip_len)\n       return;\n     }\n     *last_nextheader = proto;\n\
    +\n+    /* Check that there is enough room to write the extension header. */\n\
    +    if((ip_payload - buf) + UIP_EXT_HDR_LEN + len > buf_size) {\n+      LOG_WARN(\"\
    uncompression: cannot write ext header beyond target buffer\\n\");\n+      return;\n\
    +    }\n+\n     /* uncompress the extension header */\n     exthdr = (struct uip_ext_hdr\
    \ *)ip_payload;\n-    exthdr->len = (2 + len) / 8 - 1;\n-    exthdr->next = next;\n\
    -    last_nextheader = &exthdr->next;\n-    if(ip_len == 0 && (uint8_t *)exthdr\
    \ - uip_buf + 2 + len > sizeof(uip_buf)) {\n-      LOG_DBG(\"uncompression: ext\
    \ header points beyond uip buffer boundary\\n\");\n+    exthdr->len = (UIP_EXT_HDR_LEN\
    \ + len) / 8;\n+    if(exthdr->len == 0) {\n+      LOG_WARN(\"Extension header\
    \ length is below 8\\n\");\n       return;\n     }\n-    memcpy((uint8_t*)exthdr\
    \ + 2, hc06_ptr, len);\n+    exthdr->len--;\n+    exthdr->next = next;\n+    last_nextheader\
    \ = &exthdr->next;\n+    memcpy((uint8_t *)exthdr + UIP_EXT_HDR_LEN, hc06_ptr,\
    \ len);\n+\n     hc06_ptr += len;\n     uncomp_hdr_len += (exthdr->len + 1) *\
    \ 8;\n     ip_payload += (exthdr->len + 1) * 8;\n     ext_hdr_len += (exthdr->len\
    \ + 1) * 8;\n \n-    LOG_DBG(\"uncompression: %d len: %d exhdrlen: %d (calc: %d)\\\
    n\",\n-           proto, len, exthdr->len, (exthdr->len + 1) * 8);\n+    LOG_DBG(\"\
    uncompression: %d len: %d exthdr len: %d (calc: %d)\\n\",\n+            proto,\
    \ len, exthdr->len, (exthdr->len + 1) * 8);\n   }\n \n   /* The next header is\
    \ compressed, NHC is following */\n@@ -1806,6 +1817,7 @@ input(void)\n   /* offset\
    \ of the fragment in the IP packet */\n   uint8_t frag_offset = 0;\n   uint8_t\
    \ *buffer;\n+  uint16_t buffer_size;\n \n #if SICSLOWPAN_CONF_FRAG\n   uint8_t\
    \ is_fragment = 0;\n@@ -1836,6 +1848,7 @@ input(void)\n \n   /* This is default\
    \ uip_buf since we assume that this is not fragmented */\n   buffer = (uint8_t\
    \ *)UIP_IP_BUF;\n+  buffer_size = UIP_BUFSIZE;\n \n   /* Save the RSSI of the\
    \ incoming packet in case the upper layer will\n      want to query us for it\
    \ later. */\n@@ -1868,6 +1881,7 @@ input(void)\n       }\n \n       buffer = frag_info[frag_context].first_frag;\n\
    +      buffer_size = SICSLOWPAN_FIRST_FRAGMENT_SIZE;\n       break;\n     case\
    \ SICSLOWPAN_DISPATCH_FRAGN:\n       /*\n@@ -1922,7 +1936,7 @@ input(void)\n \
    \  if(SICSLOWPAN_COMPRESSION > SICSLOWPAN_COMPRESSION_IPV6 &&\n      (PACKETBUF_6LO_PTR[PACKETBUF_6LO_DISPATCH]\
    \ & SICSLOWPAN_DISPATCH_IPHC_MASK) == SICSLOWPAN_DISPATCH_IPHC) {\n     LOG_DBG(\"\
    uncompression: IPHC dispatch\\n\");\n-    uncompress_hdr_iphc(buffer, frag_size);\n\
    +    uncompress_hdr_iphc(buffer, buffer_size, frag_size);\n   } else if(PACKETBUF_6LO_PTR[PACKETBUF_6LO_DISPATCH]\
    \ == SICSLOWPAN_DISPATCH_IPV6) {\n     LOG_DBG(\"uncompression: IPV6 dispatch\\\
    n\");\n     packetbuf_hdr_len += SICSLOWPAN_IPV6_HDR_LEN;"
  identifiers: CVE:["CVE-2021-21280"],CWE:["CWE-787"]
  overview: Affected versions of this package are vulnerable to Out-of-bounds Write.
    Contiki-NG is an open-source, cross-platform operating system for internet of
    things devices. It is possible to cause an out-of-bounds write in versions of
    Contiki-NG prior to 4.6 when transmitting a 6LoWPAN packet with a chain of extension
    headers. Unfortunately, the written header is not checked to be within the available
    space, thereby making it possible to write outside the buffer. The problem has
    been patched in Contiki-NG 4.6. Users can apply the patch for this vulnerability
    out-of-band as a workaround.
  references:
    GitHub Advisory: https://github.com/contiki-ng/contiki-ng/security/advisories/GHSA-r768-hrhf-v592
    GitHub PR: https://github.com/contiki-ng/contiki-ng/pull/1409
    Github Commit: https://github.com/contiki-ng/contiki-ng/commit/48a3799e2d2c52e91cb7153b163bb26dfd9a4b4f
  title: Out-of-bounds Write
- diff_content:
  - "--- a/os/net/routing/rpl-classic/rpl-ext-header.c\n+++ b/os/net/routing/rpl-classic/rpl-ext-header.c\n\
    @@ -233,6 +233,11 @@ rpl_ext_header_srh_update(void)\n \n     if(segments_left\
    \ == 0) {\n       /* We are the final destination, do nothing */\n+    } else\
    \ if(segments_left > path_len) {\n+      /* Discard the packet because of a parameter\
    \ problem. */\n+      LOG_ERR(\"SRH with too many segments left (%u > %u)\\n\"\
    ,\n+              segments_left, path_len);\n+      return 0;\n     } else {\n\
    \       uint8_t i = path_len - segments_left; /* The index of the next address\
    \ to be visited */\n       uint8_t *addr_ptr = ((uint8_t *)rh_header) + RPL_RH_LEN\
    \ + RPL_SRH_LEN + (i * (16 - cmpri));"
  - "--- a/os/net/routing/rpl-lite/rpl-ext-header.c\n+++ b/os/net/routing/rpl-lite/rpl-ext-header.c\n\
    @@ -123,6 +123,11 @@ rpl_ext_header_srh_update(void)\n   /* Update SRH in-place\
    \ */\n   if(segments_left == 0) {\n     /* We are the final destination, do nothing\
    \ */\n+  } else if(segments_left > path_len) {\n+    /* Discard the packet because\
    \ of a parameter problem. */\n+    LOG_ERR(\"SRH with too many segments left (%u\
    \ > %u)\\n\",\n+            segments_left, path_len);\n+    return 0;\n   } else\
    \ {\n     uint8_t i = path_len - segments_left; /* The index of the next address\
    \ to be visited */\n     uint8_t *addr_ptr = ((uint8_t *)rh_header) + RPL_RH_LEN\
    \ + RPL_SRH_LEN + (i * (16 - cmpri));"
  identifiers: CVE:["CVE-2021-21282"],CWE:["CWE-120"]
  overview: Affected versions of this package are vulnerable to Buffer Overflow. Contiki-NG
    is an open-source, cross-platform operating system for internet of things devices.
    In versions prior to 4.5, buffer overflow can be triggered by an input packet
    when using either of Contiki-NG's two RPL implementations in source-routing mode.
    The problem has been patched in Contiki-NG 4.5. Users can apply the patch for
    this vulnerability out-of-band as a workaround.
  references:
    GitHub Advisory: https://github.com/contiki-ng/contiki-ng/security/advisories/GHSA-6xf2-77gf-fgjx
    GitHub PR: https://github.com/contiki-ng/contiki-ng/pull/1183
    Github Commit: https://github.com/contiki-ng/contiki-ng/commit/ebd4cae4458b30f7897083182fda35f180809c57
  title: Buffer Overflow
- diff_content:
  - "--- a/os/net/ipv6/sicslowpan.c\n+++ b/os/net/ipv6/sicslowpan.c\n@@ -231,6 +231,11\
    \ @@ static uint16_t my_tag;\n #define SICSLOWPAN_FRAGMENT_SIZE (127 - 2 - 15)\n\
    \ #endif\n \n+/* Check the selected fragment size, since we use 8-bit integers\
    \ to handle it. */\n+#if SICSLOWPAN_FRAGMENT_SIZE > 255\n+#error Too large SICSLOWPAN_FRAGMENT_SIZE\
    \ set.\n+#endif\n+\n /* Assuming that the worst growth for uncompression is 38\
    \ bytes */\n #define SICSLOWPAN_FIRST_FRAGMENT_SIZE (SICSLOWPAN_FRAGMENT_SIZE\
    \ + 38)\n \n@@ -306,16 +311,25 @@ static int\n store_fragment(uint8_t index, uint8_t\
    \ offset)\n {\n   int i;\n+  int len;\n+\n+  len = packetbuf_datalen() - packetbuf_hdr_len;\n\
    +\n+  if(len < 0 || len > SICSLOWPAN_FRAGMENT_SIZE) {\n+    /* Unacceptable fragment\
    \ size. */\n+    return -1;\n+  }\n+\n   for(i = 0; i < SICSLOWPAN_FRAGMENT_BUFFERS;\
    \ i++) {\n     if(frag_buf[i].len == 0) {\n-      /* copy over the data from packetbuf\
    \ into the fragment buffer and store offset and len */\n+      /* copy over the\
    \ data from packetbuf into the fragment buffer,\n+         and store offset and\
    \ len */\n       frag_buf[i].offset = offset; /* frag offset */\n-      frag_buf[i].len\
    \ = packetbuf_datalen() - packetbuf_hdr_len;\n+      frag_buf[i].len = len;\n\
    \       frag_buf[i].index = index;\n-      memcpy(frag_buf[i].data, packetbuf_ptr\
    \ + packetbuf_hdr_len,\n-             packetbuf_datalen() - packetbuf_hdr_len);\n\
    +      memcpy(frag_buf[i].data, packetbuf_ptr + packetbuf_hdr_len, len);\n   \
    \    /* return the length of the stored fragment */\n-      return frag_buf[i].len;\n\
    +      return len;\n     }\n   }\n   /* failed */\n@@ -396,23 +410,43 @@ add_fragment(uint16_t\
    \ tag, uint16_t frag_size, uint8_t offset)\n /*---------------------------------------------------------------------------*/\n\
    \ /* Copy all the fragments that are associated with a specific context\n    into\
    \ uip */\n-static void\n+static bool\n copy_frags2uip(int context)\n {\n   int\
    \ i;\n \n+  /* Check length fields before proceeding. */\n+  if(frag_info[context].len\
    \ < frag_info[context].first_frag_len ||\n+     frag_info[context].len > sizeof(uip_buf))\
    \ {\n+    LOG_WARN(\"input: invalid total size of fragments\\n\");\n+    clear_fragments(context);\n\
    +    return false;\n+  }\n+\n   /* Copy from the fragment context info buffer\
    \ first */\n   memcpy((uint8_t *)UIP_IP_BUF, (uint8_t *)frag_info[context].first_frag,\n\
    \          frag_info[context].first_frag_len);\n+\n+  /* Ensure that no previous\
    \ data is used for reassembly in case of missing fragments. */\n+  memset((uint8_t\
    \ *)UIP_IP_BUF + frag_info[context].first_frag_len, 0,\n+         frag_info[context].len\
    \ - frag_info[context].first_frag_len);\n+\n   for(i = 0; i < SICSLOWPAN_FRAGMENT_BUFFERS;\
    \ i++) {\n     /* And also copy all matching fragments */\n     if(frag_buf[i].len\
    \ > 0 && frag_buf[i].index == context) {\n+      if((frag_buf[i].offset << 3)\
    \ + frag_buf[i].len > sizeof(uip_buf)) {\n+        LOG_WARN(\"input: invalid fragment\
    \ offset\\n\");\n+        clear_fragments(context);\n+        return false;\n\
    +      }\n       memcpy((uint8_t *)UIP_IP_BUF + (uint16_t)(frag_buf[i].offset\
    \ << 3),\n              (uint8_t *)frag_buf[i].data, frag_buf[i].len);\n     }\n\
    \   }\n   /* deallocate all the fragments for this context */\n   clear_fragments(context);\n\
    +\n+  return true;\n }\n #endif /* SICSLOWPAN_CONF_FRAG */\n \n@@ -1233,6 +1267,10\
    \ @@ uncompress_hdr_iphc(uint8_t *buf, uint16_t ip_len)\n     exthdr->len = (2\
    \ + len) / 8 - 1;\n     exthdr->next = next;\n     last_nextheader = &exthdr->next;\n\
    +    if(ip_len == 0 && (uint8_t *)exthdr - uip_buf + 2 + len > sizeof(uip_buf))\
    \ {\n+      LOG_DBG(\"uncompression: ext header points beyond uip buffer boundary\\\
    n\");\n+      return;\n+    }\n     memcpy((uint8_t*)exthdr + 2, hc06_ptr, len);\n\
    \     hc06_ptr += len;\n     uncomp_hdr_len += (exthdr->len + 1) * 8;\n@@ -1729,11\
    \ +1767,17 @@ output(const linkaddr_t *localdest)\n     return 0;\n #endif /*\
    \ SICSLOWPAN_CONF_FRAG */\n   } else {\n-\n     /*\n      * The packet does not\
    \ need to be fragmented\n      * copy \"payload\" and send\n      */\n+\n+   if(uip_len\
    \ < uncomp_hdr_len) {\n+     LOG_ERR(\"output: uip_len is smaller than uncomp_hdr_len\
    \ (%d < %d)\",\n+             (int)uip_len, (int)uncomp_hdr_len);\n+     return\
    \ 0;\n+    }\n+\n     memcpy(packetbuf_ptr + packetbuf_hdr_len, (uint8_t *)UIP_IP_BUF\
    \ + uncomp_hdr_len,\n            uip_len - uncomp_hdr_len);\n     packetbuf_set_datalen(uip_len\
    \ - uncomp_hdr_len + packetbuf_hdr_len);\n@@ -1923,10 +1967,16 @@ input(void)\n\
    \     int req_size = uncomp_hdr_len + (uint16_t)(frag_offset << 3)\n         +\
    \ packetbuf_payload_len;\n     if(req_size > sizeof(uip_buf)) {\n+#if SICSLOWPAN_CONF_FRAG\n\
    \       LOG_ERR(\n-          \"input: packet dropped, minimum required IP_BUF\
    \ size: %d+%d+%d=%d (current size: %u)\\n\",\n+          \"input: packet and fragment\
    \ context %u dropped, minimum required IP_BUF size: %d+%d+%d=%d (current size:\
    \ %u)\\n\",\n+          frag_context,\n           uncomp_hdr_len, (uint16_t)(frag_offset\
    \ << 3),\n           packetbuf_payload_len, req_size, (unsigned)sizeof(uip_buf));\n\
    +      /* Discard all fragments for this contex, as reassembling this particular\
    \ fragment would\n+       * cause an overflow in uipbuf */\n+      clear_fragments(frag_context);\n\
    +#endif /* SICSLOWPAN_CONF_FRAG */\n       return;\n     }\n   }\n@@ -1951,7 +2001,9\
    \ @@ input(void)\n     if(last_fragment != 0) {\n       frag_info[frag_context].reassembled_len\
    \ = frag_size;\n       /* copy to uip */\n-      copy_frags2uip(frag_context);\n\
    +      if(!copy_frags2uip(frag_context)) {\n+        return;\n+      }\n     }\n\
    \   }\n "
  identifiers: CVE:["CVE-2019-9183"],CWE:["CWE-190"]
  overview: Affected versions of this package are vulnerable to Integer Overflow or
    Wraparound. An issue was discovered in Contiki-NG through 4.3 and Contiki through
    3.0. A buffer overflow is present due to an integer underflow during 6LoWPAN fragment
    processing in the face of truncated fragments in os/net/ipv6/sicslowpan.c. This
    results in accesses of unmapped memory, crashing the application. An attacker
    can cause a denial-of-service via a crafted 6LoWPAN frame.
  references:
    GitHub PR: https://github.com/contiki-ng/contiki-ng/pull/972
    GitHub Release: https://github.com/contiki-ng/contiki-ng/releases/tag/release%2Fv4.4
    Github Commit: https://github.com/contiki-ng/contiki-ng/commit/5884a12d7d71c5bce0d97b1a387aeb7928189b04
  title: Integer Overflow or Wraparound
- diff_content:
  - "--- a/os/net/ipv6/uip6.c\n+++ b/os/net/ipv6/uip6.c\n@@ -1840,6 +1840,15 @@ uip_process(uint8_t\
    \ flag)\n   /* Calculate the length of the data, if the application has sent\n\
    \      any data to us. */\n   c = (UIP_TCP_BUF->tcpoffset >> 4) << 2;\n+\n+  /*\
    \ Check that the indicated length of the TCP header is not too large\n+     for\
    \ the total packet length. */\n+  if(uip_len < c + UIP_IPH_LEN) {\n+    LOG_WARN(\"\
    Dropping TCP packet with too large data offset (%u bytes)\\n\",\n+           \
    \  (unsigned)c);\n+    goto drop;\n+  }\n+\n   /* uip_len will contain the length\
    \ of the actual TCP data. This is\n      calculated by subtracing the length of\
    \ the TCP header (in\n      c) and the length of the IP header (20 bytes). */"
  identifiers: CVE:["CVE-2021-21281"],CWE:["CWE-120"]
  overview: Affected versions of this package are vulnerable to Buffer Overflow. Contiki-NG
    is an open-source, cross-platform operating system for internet of things devices.
    A buffer overflow vulnerability exists in Contiki-NG versions prior to 4.6. After
    establishing a TCP socket using the tcp-socket library, it is possible for the
    remote end to send a packet with a data offset that is unvalidated. The problem
    has been patched in Contiki-NG 4.6. Users can apply the patch for this vulnerability
    out-of-band as a workaround.
  references:
    GitHub Advisory: https://github.com/contiki-ng/contiki-ng/security/advisories/GHSA-mc42-fqfr-h9fp
    GitHub PR: https://github.com/contiki-ng/contiki-ng/pull/1366
    Github Commit: https://github.com/contiki-ng/contiki-ng/commit/307385a27a413dd51aabea0a39792776be840059
  title: Buffer Overflow
- diff_content:
  - "--- a/os/net/ipv6/sicslowpan.c\n+++ b/os/net/ipv6/sicslowpan.c\n@@ -231,6 +231,11\
    \ @@ static uint16_t my_tag;\n #define SICSLOWPAN_FRAGMENT_SIZE (127 - 2 - 15)\n\
    \ #endif\n \n+/* Check the selected fragment size, since we use 8-bit integers\
    \ to handle it. */\n+#if SICSLOWPAN_FRAGMENT_SIZE > 255\n+#error Too large SICSLOWPAN_FRAGMENT_SIZE\
    \ set.\n+#endif\n+\n /* Assuming that the worst growth for uncompression is 38\
    \ bytes */\n #define SICSLOWPAN_FIRST_FRAGMENT_SIZE (SICSLOWPAN_FRAGMENT_SIZE\
    \ + 38)\n \n@@ -306,16 +311,25 @@ static int\n store_fragment(uint8_t index, uint8_t\
    \ offset)\n {\n   int i;\n+  int len;\n+\n+  len = packetbuf_datalen() - packetbuf_hdr_len;\n\
    +\n+  if(len < 0 || len > SICSLOWPAN_FRAGMENT_SIZE) {\n+    /* Unacceptable fragment\
    \ size. */\n+    return -1;\n+  }\n+\n   for(i = 0; i < SICSLOWPAN_FRAGMENT_BUFFERS;\
    \ i++) {\n     if(frag_buf[i].len == 0) {\n-      /* copy over the data from packetbuf\
    \ into the fragment buffer and store offset and len */\n+      /* copy over the\
    \ data from packetbuf into the fragment buffer,\n+         and store offset and\
    \ len */\n       frag_buf[i].offset = offset; /* frag offset */\n-      frag_buf[i].len\
    \ = packetbuf_datalen() - packetbuf_hdr_len;\n+      frag_buf[i].len = len;\n\
    \       frag_buf[i].index = index;\n-      memcpy(frag_buf[i].data, packetbuf_ptr\
    \ + packetbuf_hdr_len,\n-             packetbuf_datalen() - packetbuf_hdr_len);\n\
    +      memcpy(frag_buf[i].data, packetbuf_ptr + packetbuf_hdr_len, len);\n   \
    \    /* return the length of the stored fragment */\n-      return frag_buf[i].len;\n\
    +      return len;\n     }\n   }\n   /* failed */\n@@ -396,23 +410,43 @@ add_fragment(uint16_t\
    \ tag, uint16_t frag_size, uint8_t offset)\n /*---------------------------------------------------------------------------*/\n\
    \ /* Copy all the fragments that are associated with a specific context\n    into\
    \ uip */\n-static void\n+static bool\n copy_frags2uip(int context)\n {\n   int\
    \ i;\n \n+  /* Check length fields before proceeding. */\n+  if(frag_info[context].len\
    \ < frag_info[context].first_frag_len ||\n+     frag_info[context].len > sizeof(uip_buf))\
    \ {\n+    LOG_WARN(\"input: invalid total size of fragments\\n\");\n+    clear_fragments(context);\n\
    +    return false;\n+  }\n+\n   /* Copy from the fragment context info buffer\
    \ first */\n   memcpy((uint8_t *)UIP_IP_BUF, (uint8_t *)frag_info[context].first_frag,\n\
    \          frag_info[context].first_frag_len);\n+\n+  /* Ensure that no previous\
    \ data is used for reassembly in case of missing fragments. */\n+  memset((uint8_t\
    \ *)UIP_IP_BUF + frag_info[context].first_frag_len, 0,\n+         frag_info[context].len\
    \ - frag_info[context].first_frag_len);\n+\n   for(i = 0; i < SICSLOWPAN_FRAGMENT_BUFFERS;\
    \ i++) {\n     /* And also copy all matching fragments */\n     if(frag_buf[i].len\
    \ > 0 && frag_buf[i].index == context) {\n+      if((frag_buf[i].offset << 3)\
    \ + frag_buf[i].len > sizeof(uip_buf)) {\n+        LOG_WARN(\"input: invalid fragment\
    \ offset\\n\");\n+        clear_fragments(context);\n+        return false;\n\
    +      }\n       memcpy((uint8_t *)UIP_IP_BUF + (uint16_t)(frag_buf[i].offset\
    \ << 3),\n              (uint8_t *)frag_buf[i].data, frag_buf[i].len);\n     }\n\
    \   }\n   /* deallocate all the fragments for this context */\n   clear_fragments(context);\n\
    +\n+  return true;\n }\n #endif /* SICSLOWPAN_CONF_FRAG */\n \n@@ -1233,6 +1267,10\
    \ @@ uncompress_hdr_iphc(uint8_t *buf, uint16_t ip_len)\n     exthdr->len = (2\
    \ + len) / 8 - 1;\n     exthdr->next = next;\n     last_nextheader = &exthdr->next;\n\
    +    if(ip_len == 0 && (uint8_t *)exthdr - uip_buf + 2 + len > sizeof(uip_buf))\
    \ {\n+      LOG_DBG(\"uncompression: ext header points beyond uip buffer boundary\\\
    n\");\n+      return;\n+    }\n     memcpy((uint8_t*)exthdr + 2, hc06_ptr, len);\n\
    \     hc06_ptr += len;\n     uncomp_hdr_len += (exthdr->len + 1) * 8;\n@@ -1729,11\
    \ +1767,17 @@ output(const linkaddr_t *localdest)\n     return 0;\n #endif /*\
    \ SICSLOWPAN_CONF_FRAG */\n   } else {\n-\n     /*\n      * The packet does not\
    \ need to be fragmented\n      * copy \"payload\" and send\n      */\n+\n+   if(uip_len\
    \ < uncomp_hdr_len) {\n+     LOG_ERR(\"output: uip_len is smaller than uncomp_hdr_len\
    \ (%d < %d)\",\n+             (int)uip_len, (int)uncomp_hdr_len);\n+     return\
    \ 0;\n+    }\n+\n     memcpy(packetbuf_ptr + packetbuf_hdr_len, (uint8_t *)UIP_IP_BUF\
    \ + uncomp_hdr_len,\n            uip_len - uncomp_hdr_len);\n     packetbuf_set_datalen(uip_len\
    \ - uncomp_hdr_len + packetbuf_hdr_len);\n@@ -1923,10 +1967,16 @@ input(void)\n\
    \     int req_size = uncomp_hdr_len + (uint16_t)(frag_offset << 3)\n         +\
    \ packetbuf_payload_len;\n     if(req_size > sizeof(uip_buf)) {\n+#if SICSLOWPAN_CONF_FRAG\n\
    \       LOG_ERR(\n-          \"input: packet dropped, minimum required IP_BUF\
    \ size: %d+%d+%d=%d (current size: %u)\\n\",\n+          \"input: packet and fragment\
    \ context %u dropped, minimum required IP_BUF size: %d+%d+%d=%d (current size:\
    \ %u)\\n\",\n+          frag_context,\n           uncomp_hdr_len, (uint16_t)(frag_offset\
    \ << 3),\n           packetbuf_payload_len, req_size, (unsigned)sizeof(uip_buf));\n\
    +      /* Discard all fragments for this contex, as reassembling this particular\
    \ fragment would\n+       * cause an overflow in uipbuf */\n+      clear_fragments(frag_context);\n\
    +#endif /* SICSLOWPAN_CONF_FRAG */\n       return;\n     }\n   }\n@@ -1951,7 +2001,9\
    \ @@ input(void)\n     if(last_fragment != 0) {\n       frag_info[frag_context].reassembled_len\
    \ = frag_size;\n       /* copy to uip */\n-      copy_frags2uip(frag_context);\n\
    +      if(!copy_frags2uip(frag_context)) {\n+        return;\n+      }\n     }\n\
    \   }\n "
  identifiers: CVE:["CVE-2019-8359"],CWE:["CWE-787"]
  overview: Affected versions of this package are vulnerable to Out-of-bounds Write.
    An issue was discovered in Contiki-NG through 4.3 and Contiki through 3.0. An
    out of bounds write is present in the data section during 6LoWPAN fragment re-assembly
    in the face of forged fragment offsets in os/net/ipv6/sicslowpan.c.
  references:
    GitHub PR: https://github.com/contiki-ng/contiki-ng/pull/972
    GitHub Release: https://github.com/contiki-ng/contiki-ng/releases/tag/release%2Fv4.4
    Github Commit: https://github.com/contiki-ng/contiki-ng/commit/5884a12d7d71c5bce0d97b1a387aeb7928189b04
  title: Out-of-bounds Write
- diff_content:
  - "--- a/os/storage/antelope/storage-cfs.c\n+++ b/os/storage/antelope/storage-cfs.c\n\
    @@ -333,7 +333,7 @@ storage_rename_relation(char *old_name, char *new_name)\n\
    \ db_result_t\n storage_get_index(index_t *index, relation_t *rel, attribute_t\
    \ *attr)\n {\n-  char filename[INDEX_NAME_LENGTH];\n+  char filename[INDEX_NAME_LENGTH\
    \ + 1];\n   int fd;\n   int r;\n   struct index_record record;\n@@ -369,7 +369,7\
    \ @@ storage_get_index(index_t *index, relation_t *rel, attribute_t *attr)\n db_result_t\n\
    \ storage_put_index(index_t *index)\n {\n-  char filename[INDEX_NAME_LENGTH];\n\
    +  char filename[INDEX_NAME_LENGTH + 1];\n   int fd;\n   int r;\n   struct index_record\
    \ record;"
  identifiers: CVE:["CVE-2023-30546"],CWE:["CWE-125"]
  overview: Affected versions of this package are vulnerable to Buffer Overflow due
    to missing length limit of the filename array
  references:
    GitHub PR: https://github.com/contiki-ng/contiki-ng/pull/2425
    Github Commit: https://github.com/contiki-ng/contiki-ng/commit/6e21dd2955642818a31f5f32c7ae2f78c7f9dd0a
  title: Buffer Overflow
- diff_content:
  - "--- a/os/net/mac/ble/ble-l2cap.c\n+++ b/os/net/mac/ble/ble-l2cap.c\n@@ -452,6\
    \ +452,12 @@ input_l2cap_frame_flow_channel(l2cap_channel_t *channel, uint8_t\
    \ *data, uint16_t\n \n   if((channel->rx_buffer.sdu_length > 0) &&\n      (channel->rx_buffer.sdu_length\
    \ == channel->rx_buffer.current_index)) {\n+    if(channel->rx_buffer.sdu_length\
    \ > packetbuf_remaininglen()) {\n+      LOG_WARN(\"l2cap_frame: illegal L2CAP\
    \ frame sdu_length: %\"PRIu16\"\\n\",\n+               channel->rx_buffer.sdu_length);\n\
    +      return;\n+    }\n+\n     /* do not use packetbuf_copyfrom here because\
    \ the packetbuf_attr\n      * must not be cleared */\n     memcpy(packetbuf_dataptr(),\
    \ channel->rx_buffer.sdu, channel->rx_buffer.sdu_length);"
  identifiers: CVE:["CVE-2023-23609"],CWE:["CWE-787"]
  overview: Affected versions of this package are vulnerable to Out-of-bounds Write
    in the `input_l2cap_frame_flow_channel()` function in `ble-l2cap.c`. When fragments
    are reassembled in the BLE-L2CAP module they are stored in a packet buffer of
    a configurable size, but there is no check to verify that the packet buffer is
    large enough to hold the reassembled packet. An out-of-bounds write of up to 1152
    bytes is possible.
  references:
    GitHub Commit: https://github.com/contiki-ng/contiki-ng/commit/506f9def7cdff853fa24cf6d88e1f4e5619dc46c
    GitHub PR: https://github.com/contiki-ng/contiki-ng/pull/2254
  title: Out-of-bounds Write
- diff_content:
  - "--- a/os/net/mac/ble/ble-l2cap.c\n+++ b/os/net/mac/ble/ble-l2cap.c\n@@ -378,11\
    \ +378,16 @@ input_l2cap_credit(uint8_t *data)\n   uint16_t credits;\n   l2cap_channel_t\
    \ *channel = get_channel_for_addr(packetbuf_addr(PACKETBUF_ADDR_SENDER));\n \n\
    +  if(channel == NULL) {\n+    LOG_WARN(\"input_l2cap_credit: no channel found\
    \ for sender address\\n\");\n+    return;\n+  }\n+\n /*  uint8_t  identifier =\
    \ data[0]; */\n   memcpy(&len, &data[1], 2);\n \n   if(len != 4) {\n-    LOG_WARN(\"\
    process_l2cap_credit: invalid len: %d\\n\", len);\n+    LOG_WARN(\"input_l2cap_credit:\
    \ invalid len: %d\\n\", len);\n     return;\n   }\n "
  identifiers: CVE:["CVE-2022-41972"],CWE:["CWE-476"]
  overview: Affected versions of this package are vulnerable to NULL Pointer Dereference
    which allows an attacker to inject a packet into the Bluetooth Low Energy stack.
  references:
    GitHub PR: https://github.com/contiki-ng/contiki-ng/pull/2253
    Github Commit: https://github.com/contiki-ng/contiki-ng/commit/77898af8488c063a84d6b8338b24fdd4812b9e66
  title: NULL Pointer Dereference
- diff_content:
  - "--- a/os/net/mac/ble/ble-l2cap.c\n+++ b/os/net/mac/ble/ble-l2cap.c\n@@ -593,6\
    \ +593,10 @@ PROCESS_THREAD(ble_l2cap_tx_process, ev, data)\n         }\n \n \
    \        /* copy payload */\n+        if(data_len > PACKETBUF_SIZE - packetbuf_hdrlen())\
    \ {\n+          LOG_WARN(\"Not enough packetbuf space to copy buffer\\n\");\n\
    +          continue;\n+        }\n         memcpy(packetbuf_dataptr(),\n     \
    \           &channel->tx_buffer.sdu[channel->tx_buffer.current_index],\n     \
    \           data_len);"
  identifiers: CVE:["CVE-2023-28116"],CWE:["CWE-120"]
  overview: Affected versions of this package are vulnerable to Out-of-Bounds in the
    `BLE L2CAP` module of the Contiki-NG operating system.
  references:
    GitHub PR: https://github.com/contiki-ng/contiki-ng/pull/2398
    Github Commit: https://github.com/contiki-ng/contiki-ng/commit/210c39de20cd2fe396e135850556be5c46e0c96d
  title: Out-of-Bounds
- diff_content:
  - "--- a/os/net/mac/ble/ble-l2cap.c\n+++ b/os/net/mac/ble/ble-l2cap.c\n@@ -105,9\
    \ +105,9 @@ get_channel_for_addr(const linkaddr_t *peer_addr)\n static l2cap_channel_t\
    \ *\n get_channel_for_cid(uint16_t own_cid)\n {\n-  uint8_t i = own_cid - L2CAP_FLOW_CHANNEL;\n\
    +  int16_t i = own_cid - L2CAP_FLOW_CHANNEL;\n   if(i >= 0 && i < l2cap_channel_count)\
    \ {\n-    return &l2cap_channels[own_cid - L2CAP_FLOW_CHANNEL];\n+    return &l2cap_channels[i];\n\
    \   } else {\n     return NULL;\n   }"
  identifiers: CVE:["CVE-2022-41873"],CWE:["CWE-125"]
  overview: Affected versions of this package are vulnerable to Out-of-bounds Read
    due to an integer truncation issue leading to only the lowest byte of the channel
    ID to be checked. A crafted channel ID leads to out-of-bounds memory to be read
    and written with attacker-controlled data.
  references:
    GitHub Commit: https://github.com/contiki-ng/contiki-ng/commit/3216ebf59e698b6dc71d0ba3e8052d5d5e09d2bd
    GitHub PR: https://github.com/contiki-ng/contiki-ng/pull/2081
  title: Out-of-bounds Read
- diff_content:
  - "--- a/src/Compression/CompressionCodecT64.cpp\n+++ b/src/Compression/CompressionCodecT64.cpp\n\
    @@ -66,6 +66,7 @@ namespace ErrorCodes\n     extern const int ILLEGAL_SYNTAX_FOR_CODEC_TYPE;\n\
    \     extern const int ILLEGAL_CODEC_PARAMETER;\n     extern const int LOGICAL_ERROR;\n\
    +    extern const int INCORRECT_DATA;\n }\n \n namespace\n@@ -145,7 +146,7 @@\
    \ TypeIndex deserializeTypeId(uint8_t serialized_type_id)\n         case MagicNumber::IPv4:\
    \         return TypeIndex::IPv4;\n     }\n \n-    throw Exception(ErrorCodes::LOGICAL_ERROR,\
    \ \"Bad magic number in T64 codec: {}\", static_cast<UInt32>(serialized_type_id));\n\
    +    throw Exception(ErrorCodes::INCORRECT_DATA, \"Bad magic number in T64 codec:\
    \ {}\", static_cast<UInt32>(serialized_type_id));\n }\n \n \n@@ -378,13 +379,6\
    \ @@ void transpose(const T * src, char * dst, UInt32 num_bits, UInt32 tail =\
    \ 64)\n \n /// UInt64[N] transposed matrix -> UIntX[64]\n template <typename T,\
    \ bool full = false>\n-#if defined(__s390x__)\n-\n-/* Compiler Bug for S390x :-\
    \ https://github.com/llvm/llvm-project/issues/62572\n- * Please remove this after\
    \ the fix is backported\n- */\n-        __attribute__((noinline))\n-#endif\n void\
    \ reverseTranspose(const char * src, T * buf, UInt32 num_bits, UInt32 tail = 64)\n\
    \ {\n     UInt64 matrix[64] = {};\n@@ -544,12 +538,13 @@ void decompressData(const\
    \ char * src, UInt32 bytes_size, char * dst, UInt32 unco\n     static constexpr\
    \ const UInt32 header_size = 2 * sizeof(UInt64);\n \n     if (bytes_size < header_size)\n\
    -        throw Exception(ErrorCodes::CANNOT_DECOMPRESS, \"Cannot decompress, data\
    \ size {} is less then T64 header\",\n+        throw Exception(ErrorCodes::CANNOT_DECOMPRESS,\
    \ \"Cannot decompress, data size ({}) is less than the size of T64 header\",\n\
    \                         bytes_size);\n \n     if (uncompressed_size % sizeof(T))\n\
    -        throw Exception(ErrorCodes::CANNOT_DECOMPRESS, \"Cannot decompress, unexpected\
    \ uncompressed size {}\",\n-                        uncompressed_size);\n+   \
    \     throw Exception(ErrorCodes::CANNOT_DECOMPRESS, \"Cannot decompress, unexpected\
    \ uncompressed size ({})\"\n+                        \" isn't a multiple of the\
    \ data type size ({})\",\n+                        uncompressed_size, sizeof(T));\n\
    \ \n     UInt64 num_elements = uncompressed_size / sizeof(T);\n     MinMaxType\
    \ min;\n@@ -576,14 +571,20 @@ void decompressData(const char * src, UInt32 bytes_size,\
    \ char * dst, UInt32 unco\n     UInt32 dst_shift = sizeof(T) * matrix_size;\n\
    \ \n     if (!bytes_size || bytes_size % src_shift)\n-        throw Exception(ErrorCodes::CANNOT_DECOMPRESS,\
    \ \"Cannot decompress, data size {} is not multiplier of {}\",\n-            \
    \            bytes_size, toString(src_shift));\n+        throw Exception(ErrorCodes::CANNOT_DECOMPRESS,\
    \ \"Cannot decompress, data size ({}) is not a multiplier of {}\",\n+        \
    \                bytes_size, src_shift);\n \n     UInt32 num_full = bytes_size\
    \ / src_shift;\n     UInt32 tail = num_elements % matrix_size;\n     if (tail)\n\
    \         --num_full;\n \n+    UInt64 expected = static_cast<UInt64>(num_full)\
    \ * matrix_size + tail;    /// UInt64 to avoid overflow.\n+    if (expected !=\
    \ num_elements)\n+        throw Exception(ErrorCodes::CANNOT_DECOMPRESS, \"Cannot\
    \ decompress, the number of elements in the compressed data ({})\"\n+        \
    \                \" is not equal to the expected number of elements in the decompressed\
    \ data ({})\",\n+                        expected, num_elements);\n+\n     T upper_min\
    \ = 0;\n     T upper_max [[maybe_unused]] = 0;\n     T sign_bit [[maybe_unused]]\
    \ = 0;"
  identifiers: CVE:["CVE-2023-47118"],CWE:["CWE-122"]
  overview: Affected versions of this package are vulnerable to Heap-based Buffer
    Overflow via the decompression logic of the T64 codec on the native interface.
    An attacker can cause a crash by sending malicious data to port 9000/tcp. This
    attack does not require authentication. However, when exploiting via the HTTP
    protocol, valid credentials are needed as HTTP authentication occurs first.
  references:
    GitHub Commit: https://github.com/ClickHouse/ClickHouse/commit/933d6bb4c10526270473dd14dcde7607d67b4318
  title: Heap-based Buffer Overflow
- diff_content:
  - "--- a/src/protocols/vnc/argv.c\n+++ b/src/protocols/vnc/argv.c\n@@ -21,8 +21,10\
    \ @@\n #include \"argv.h\"\n #include \"vnc.h\"\n \n+#include <guacamole/mem.h>\n\
    \ #include <guacamole/protocol.h>\n #include <guacamole/socket.h>\n+#include <guacamole/string.h>\n\
    \ #include <guacamole/user.h>\n \n #include <pthread.h>\n@@ -38,16 +40,16 @@ int\
    \ guac_vnc_argv_callback(guac_user* user, const char* mimetype,\n \n     /* Update\
    \ username */\n     if (strcmp(name, GUAC_VNC_ARGV_USERNAME) == 0) {\n-      \
    \  free(settings->username);\n-        settings->username = strdup(value);\n+\
    \        guac_mem_free(settings->username);\n+        settings->username = guac_strdup(value);\n\
    \     }\n     \n     /* Update password */\n     else if (strcmp(name, GUAC_VNC_ARGV_PASSWORD)\
    \ == 0) {\n-        free(settings->password);\n-        settings->password = strdup(value);\n\
    +        guac_mem_free(settings->password);\n+        settings->password = guac_strdup(value);\n\
    \     }\n \n     return 0;\n \n-}\n\\ No newline at end of file\n+}"
  - "--- a/src/protocols/vnc/client.c\n+++ b/src/protocols/vnc/client.c\n@@ -34,6\
    \ +34,7 @@\n #endif\n \n #include <guacamole/client.h>\n+#include <guacamole/mem.h>\n\
    \ #include <guacamole/recording.h>\n \n #include <pthread.h>\n@@ -102,7 +103,7\
    \ @@ int guac_client_init(guac_client* client) {\n     client->args = GUAC_VNC_CLIENT_ARGS;\n\
    \ \n     /* Alloc client data */\n-    guac_vnc_client* vnc_client = calloc(1,\
    \ sizeof(guac_vnc_client));\n+    guac_vnc_client* vnc_client = guac_mem_zalloc(sizeof(guac_vnc_client));\n\
    \     client->data = vnc_client;\n \n #ifdef ENABLE_VNC_TLS_LOCKING\n@@ -209,7\
    \ +210,7 @@ int guac_vnc_client_free_handler(guac_client* client) {\n #endif\n\
    \ \n     /* Free generic data struct */\n-    free(client->data);\n+    guac_mem_free(client->data);\n\
    \ \n     return 0;\n }"
  - "--- a/src/protocols/vnc/cursor.c\n+++ b/src/protocols/vnc/cursor.c\n@@ -28,6\
    \ +28,7 @@\n #include <cairo/cairo.h>\n #include <guacamole/client.h>\n #include\
    \ <guacamole/layer.h>\n+#include <guacamole/mem.h>\n #include <guacamole/protocol.h>\n\
    \ #include <guacamole/socket.h>\n #include <rfb/rfbclient.h>\n@@ -51,7 +52,7 @@\
    \ void guac_vnc_cursor(rfbClient* client, int x, int y, int w, int h, int bpp)\
    \ {\n \n     /* Cairo image buffer */\n     int stride = cairo_format_stride_for_width(CAIRO_FORMAT_ARGB32,\
    \ w);\n-    unsigned char* buffer = malloc(h*stride);\n+    unsigned char* buffer\
    \ = guac_mem_alloc(h, stride);\n     unsigned char* buffer_row_current = buffer;\n\
    \ \n     /* VNC image buffer */\n@@ -120,7 +121,7 @@ void guac_vnc_cursor(rfbClient*\
    \ client, int x, int y, int w, int h, int bpp) {\n             buffer, w, h, stride);\n\
    \ \n     /* Free surface */\n-    free(buffer);\n+    guac_mem_free(buffer);\n\
    \ \n     /* libvncclient does not free rcMask as it does rcSource */\n     free(client->rcMask);"
  - "--- a/src/protocols/vnc/display.c\n+++ b/src/protocols/vnc/display.c\n@@ -27,6\
    \ +27,7 @@\n #include <cairo/cairo.h>\n #include <guacamole/client.h>\n #include\
    \ <guacamole/layer.h>\n+#include <guacamole/mem.h>\n #include <guacamole/protocol.h>\n\
    \ #include <guacamole/socket.h>\n #include <rfb/rfbclient.h>\n@@ -69,7 +70,7 @@\
    \ void guac_vnc_update(rfbClient* client, int x, int y, int w, int h) {\n \n \
    \    /* Init Cairo buffer */\n     stride = cairo_format_stride_for_width(CAIRO_FORMAT_RGB24,\
    \ w);\n-    buffer = malloc(h*stride);\n+    buffer = guac_mem_alloc(h, stride);\n\
    \     buffer_row_current = buffer;\n \n     bpp = client->format.bitsPerPixel/8;\n\
    @@ -134,7 +135,7 @@ void guac_vnc_update(rfbClient* client, int x, int y, int\
    \ w, int h) {\n \n     /* Free surface */\n     cairo_surface_destroy(surface);\n\
    -    free(buffer);\n+    guac_mem_free(buffer);\n \n }\n "
  - "--- a/src/protocols/vnc/settings.c\n+++ b/src/protocols/vnc/settings.c\n@@ -24,6\
    \ +24,7 @@\n #include \"common/defaults.h\"\n #include \"settings.h\"\n \n+#include\
    \ <guacamole/mem.h>\n #include <guacamole/user.h>\n #include <guacamole/wol-constants.h>\n\
    \ \n@@ -395,7 +396,7 @@ guac_vnc_settings* guac_vnc_parse_args(guac_user* user,\n\
    \         return NULL;\n     }\n \n-    guac_vnc_settings* settings = calloc(1,\
    \ sizeof(guac_vnc_settings));\n+    guac_vnc_settings* settings = guac_mem_zalloc(sizeof(guac_vnc_settings));\n\
    \ \n     settings->hostname =\n         guac_user_parse_args_string(user, GUAC_VNC_CLIENT_ARGS,\
    \ argv,\n@@ -646,43 +647,43 @@ guac_vnc_settings* guac_vnc_parse_args(guac_user*\
    \ user,\n void guac_vnc_settings_free(guac_vnc_settings* settings) {\n \n    \
    \ /* Free settings strings */\n-    free(settings->clipboard_encoding);\n-   \
    \ free(settings->encodings);\n-    free(settings->hostname);\n-    free(settings->password);\n\
    -    free(settings->recording_name);\n-    free(settings->recording_path);\n-\
    \    free(settings->username);\n+    guac_mem_free(settings->clipboard_encoding);\n\
    +    guac_mem_free(settings->encodings);\n+    guac_mem_free(settings->hostname);\n\
    +    guac_mem_free(settings->password);\n+    guac_mem_free(settings->recording_name);\n\
    +    guac_mem_free(settings->recording_path);\n+    guac_mem_free(settings->username);\n\
    \ \n #ifdef ENABLE_VNC_REPEATER\n     /* Free VNC repeater settings */\n-    free(settings->dest_host);\n\
    +    guac_mem_free(settings->dest_host);\n #endif\n \n #ifdef ENABLE_COMMON_SSH\n\
    \     /* Free SFTP settings */\n-    free(settings->sftp_directory);\n-    free(settings->sftp_root_directory);\n\
    -    free(settings->sftp_host_key);\n-    free(settings->sftp_hostname);\n-  \
    \  free(settings->sftp_passphrase);\n-    free(settings->sftp_password);\n-  \
    \  free(settings->sftp_port);\n-    free(settings->sftp_private_key);\n-    free(settings->sftp_username);\n\
    +    guac_mem_free(settings->sftp_directory);\n+    guac_mem_free(settings->sftp_root_directory);\n\
    +    guac_mem_free(settings->sftp_host_key);\n+    guac_mem_free(settings->sftp_hostname);\n\
    +    guac_mem_free(settings->sftp_passphrase);\n+    guac_mem_free(settings->sftp_password);\n\
    +    guac_mem_free(settings->sftp_port);\n+    guac_mem_free(settings->sftp_private_key);\n\
    +    guac_mem_free(settings->sftp_username);\n #endif\n \n #ifdef ENABLE_PULSE\n\
    \     /* Free PulseAudio settings */\n-    free(settings->pa_servername);\n+ \
    \   guac_mem_free(settings->pa_servername);\n #endif\n     \n     /* Free Wake-on-LAN\
    \ strings */\n-    free(settings->wol_mac_addr);\n-    free(settings->wol_broadcast_addr);\n\
    +    guac_mem_free(settings->wol_mac_addr);\n+    guac_mem_free(settings->wol_broadcast_addr);\n\
    \ \n     /* Free settings structure */\n-    free(settings);\n+    guac_mem_free(settings);\n\
    \ \n }\n "
  identifiers: CVE:["CVE-2023-43826"],CWE:["CWE-190"]
  overview: Affected versions of this package are vulnerable to Integer Overflow or
    Wraparound when handling VNC image buffers. An attacker can cause memory corruption
    or execute arbitrary code with the privileges of the running `guacd` process by
    convincing a user to connect to a compromised VNC server.
  references:
    Apache Mailing List: https://lists.apache.org/thread/23gzwftpfgtq97tj6ttmbclry53kmwv6
    GitHub Commit: https://github.com/apache/guacamole-server/commit/dfb708498d1286c6e6403b47e08587109670bfce
    OSS Security Advisory: http://www.openwall.com/lists/oss-security/2023/12/19/4
  title: Integer Overflow or Wraparound
