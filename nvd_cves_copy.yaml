- diff_content:
  - "--- a/src/svg/qsvghandler.cpp\n+++ b/src/svg/qsvghandler.cpp\n@@ -1595,14 +1595,16\
    \ @@ static void pathArc(QPainterPath &path,\n \n static bool parsePathDataFast(QStringView\
    \ dataStr, QPainterPath &path)\n {\n+    const int maxElementCount = 0x7fff; //\
    \ Assume file corruption if more path elements than this\n     qreal x0 = 0, y0\
    \ = 0;              // starting point\n     qreal x = 0, y = 0;              \
    \  // current point\n     char lastMode = 0;\n     QPointF ctrlPt;\n     const\
    \ QChar *str = dataStr.constData();\n     const QChar *end = str + dataStr.size();\n\
    \ \n-    while (str != end) {\n+    bool ok = true;\n+    while (ok && str !=\
    \ end) {\n         while (str->isSpace() && (str + 1) != end)\n             ++str;\n\
    \         QChar pathElem = *str;\n@@ -1619,14 +1621,13 @@ static bool parsePathDataFast(QStringView\
    \ dataStr, QPainterPath &path)\n             arg.append(0);//dummy\n         const\
    \ qreal *num = arg.constData();\n         int count = arg.count();\n-        while\
    \ (count > 0) {\n+        while (ok && count > 0) {\n             qreal offsetX\
    \ = x;        // correction offsets\n             qreal offsetY = y;        //\
    \ for relative commands\n             switch (pathElem.unicode()) {\n        \
    \     case 'm': {\n                 if (count < 2) {\n-                    num++;\n\
    -                    count--;\n+                    ok = false;\n            \
    \         break;\n                 }\n                 x = x0 = num[0] + offsetX;\n\
    @@ -1643,8 +1644,7 @@ static bool parsePathDataFast(QStringView dataStr, QPainterPath\
    \ &path)\n                 break;\n             case 'M': {\n                \
    \ if (count < 2) {\n-                    num++;\n-                    count--;\n\
    +                    ok = false;\n                     break;\n              \
    \   }\n                 x = x0 = num[0];\n@@ -1670,8 +1670,7 @@ static bool parsePathDataFast(QStringView\
    \ dataStr, QPainterPath &path)\n                 break;\n             case 'l':\
    \ {\n                 if (count < 2) {\n-                    num++;\n-       \
    \             count--;\n+                    ok = false;\n                   \
    \  break;\n                 }\n                 x = num[0] + offsetX;\n@@ -1684,8\
    \ +1683,7 @@ static bool parsePathDataFast(QStringView dataStr, QPainterPath &path)\n\
    \                 break;\n             case 'L': {\n                 if (count\
    \ < 2) {\n-                    num++;\n-                    count--;\n+      \
    \              ok = false;\n                     break;\n                 }\n\
    \                 x = num[0];\n@@ -1725,8 +1723,7 @@ static bool parsePathDataFast(QStringView\
    \ dataStr, QPainterPath &path)\n                 break;\n             case 'c':\
    \ {\n                 if (count < 6) {\n-                    num += count;\n-\
    \                    count = 0;\n+                    ok = false;\n          \
    \           break;\n                 }\n                 QPointF c1(num[0] + offsetX,\
    \ num[1] + offsetY);\n@@ -1742,8 +1739,7 @@ static bool parsePathDataFast(QStringView\
    \ dataStr, QPainterPath &path)\n             }\n             case 'C': {\n   \
    \              if (count < 6) {\n-                    num += count;\n-       \
    \             count = 0;\n+                    ok = false;\n                 \
    \    break;\n                 }\n                 QPointF c1(num[0], num[1]);\n\
    @@ -1759,8 +1755,7 @@ static bool parsePathDataFast(QStringView dataStr, QPainterPath\
    \ &path)\n             }\n             case 's': {\n                 if (count\
    \ < 4) {\n-                    num += count;\n-                    count = 0;\n\
    +                    ok = false;\n                     break;\n              \
    \   }\n                 QPointF c1;\n@@ -1781,8 +1776,7 @@ static bool parsePathDataFast(QStringView\
    \ dataStr, QPainterPath &path)\n             }\n             case 'S': {\n   \
    \              if (count < 4) {\n-                    num += count;\n-       \
    \             count = 0;\n+                    ok = false;\n                 \
    \    break;\n                 }\n                 QPointF c1;\n@@ -1803,8 +1797,7\
    \ @@ static bool parsePathDataFast(QStringView dataStr, QPainterPath &path)\n\
    \             }\n             case 'q': {\n                 if (count < 4) {\n\
    -                    num += count;\n-                    count = 0;\n+       \
    \             ok = false;\n                     break;\n                 }\n \
    \                QPointF c(num[0] + offsetX, num[1] + offsetY);\n@@ -1819,8 +1812,7\
    \ @@ static bool parsePathDataFast(QStringView dataStr, QPainterPath &path)\n\
    \             }\n             case 'Q': {\n                 if (count < 4) {\n\
    -                    num += count;\n-                    count = 0;\n+       \
    \             ok = false;\n                     break;\n                 }\n \
    \                QPointF c(num[0], num[1]);\n@@ -1835,8 +1827,7 @@ static bool\
    \ parsePathDataFast(QStringView dataStr, QPainterPath &path)\n             }\n\
    \             case 't': {\n                 if (count < 2) {\n-              \
    \      num += count;\n-                    count = 0;\n+                    ok\
    \ = false;\n                     break;\n                 }\n                \
    \ QPointF e(num[0] + offsetX, num[1] + offsetY);\n@@ -1856,8 +1847,7 @@ static\
    \ bool parsePathDataFast(QStringView dataStr, QPainterPath &path)\n          \
    \   }\n             case 'T': {\n                 if (count < 2) {\n-        \
    \            num += count;\n-                    count = 0;\n+               \
    \     ok = false;\n                     break;\n                 }\n         \
    \        QPointF e(num[0], num[1]);\n@@ -1877,8 +1867,7 @@ static bool parsePathDataFast(QStringView\
    \ dataStr, QPainterPath &path)\n             }\n             case 'a': {\n   \
    \              if (count < 7) {\n-                    num += count;\n-       \
    \             count = 0;\n+                    ok = false;\n                 \
    \    break;\n                 }\n                 qreal rx = (*num++);\n@@ -1900,8\
    \ +1889,7 @@ static bool parsePathDataFast(QStringView dataStr, QPainterPath &path)\n\
    \                 break;\n             case 'A': {\n                 if (count\
    \ < 7) {\n-                    num += count;\n-                    count = 0;\n\
    +                    ok = false;\n                     break;\n              \
    \   }\n                 qreal rx = (*num++);\n@@ -1922,12 +1910,15 @@ static bool\
    \ parsePathDataFast(QStringView dataStr, QPainterPath &path)\n             }\n\
    \                 break;\n             default:\n-                return false;\n\
    +                ok = false;\n+                break;\n             }\n      \
    \       lastMode = pathElem.toLatin1();\n+            if (path.elementCount()\
    \ > maxElementCount)\n+                ok = false;\n         }\n     }\n-    return\
    \ true;\n+    return ok;\n }\n \n static bool parseStyle(QSvgNode *node,\n@@ -2985,8\
    \ +2976,8 @@ static QSvgNode *createPathNode(QSvgNode *parent,\n \n     QPainterPath\
    \ qpath;\n     qpath.setFillRule(Qt::WindingFill);\n-    //XXX do error handling\n\
    -    parsePathDataFast(data, qpath);\n+    if (!parsePathDataFast(data, qpath))\n\
    +        qCWarning(lcSvgHandler, \"Invalid path data; path truncated.\");\n \n\
    \     QSvgNode *path = new QSvgPath(parent, qpath);\n     return path;"
  - "--- a/src/svg/qsvghandler.cpp\n+++ b/src/svg/qsvghandler.cpp\n@@ -1597,14 +1597,16\
    \ @@ static void pathArc(QPainterPath &path,\n \n static bool parsePathDataFast(QStringView\
    \ dataStr, QPainterPath &path)\n {\n+    const int maxElementCount = 0x7fff; //\
    \ Assume file corruption if more path elements than this\n     qreal x0 = 0, y0\
    \ = 0;              // starting point\n     qreal x = 0, y = 0;              \
    \  // current point\n     char lastMode = 0;\n     QPointF ctrlPt;\n     const\
    \ QChar *str = dataStr.constData();\n     const QChar *end = str + dataStr.size();\n\
    \ \n-    while (str != end) {\n+    bool ok = true;\n+    while (ok && str !=\
    \ end) {\n         while (str->isSpace() && (str + 1) != end)\n             ++str;\n\
    \         QChar pathElem = *str;\n@@ -1621,14 +1623,13 @@ static bool parsePathDataFast(QStringView\
    \ dataStr, QPainterPath &path)\n             arg.append(0);//dummy\n         const\
    \ qreal *num = arg.constData();\n         int count = arg.count();\n-        while\
    \ (count > 0) {\n+        while (ok && count > 0) {\n             qreal offsetX\
    \ = x;        // correction offsets\n             qreal offsetY = y;        //\
    \ for relative commands\n             switch (pathElem.unicode()) {\n        \
    \     case 'm': {\n                 if (count < 2) {\n-                    num++;\n\
    -                    count--;\n+                    ok = false;\n            \
    \         break;\n                 }\n                 x = x0 = num[0] + offsetX;\n\
    @@ -1645,8 +1646,7 @@ static bool parsePathDataFast(QStringView dataStr, QPainterPath\
    \ &path)\n                 break;\n             case 'M': {\n                \
    \ if (count < 2) {\n-                    num++;\n-                    count--;\n\
    +                    ok = false;\n                     break;\n              \
    \   }\n                 x = x0 = num[0];\n@@ -1672,8 +1672,7 @@ static bool parsePathDataFast(QStringView\
    \ dataStr, QPainterPath &path)\n                 break;\n             case 'l':\
    \ {\n                 if (count < 2) {\n-                    num++;\n-       \
    \             count--;\n+                    ok = false;\n                   \
    \  break;\n                 }\n                 x = num[0] + offsetX;\n@@ -1686,8\
    \ +1685,7 @@ static bool parsePathDataFast(QStringView dataStr, QPainterPath &path)\n\
    \                 break;\n             case 'L': {\n                 if (count\
    \ < 2) {\n-                    num++;\n-                    count--;\n+      \
    \              ok = false;\n                     break;\n                 }\n\
    \                 x = num[0];\n@@ -1727,8 +1725,7 @@ static bool parsePathDataFast(QStringView\
    \ dataStr, QPainterPath &path)\n                 break;\n             case 'c':\
    \ {\n                 if (count < 6) {\n-                    num += count;\n-\
    \                    count = 0;\n+                    ok = false;\n          \
    \           break;\n                 }\n                 QPointF c1(num[0] + offsetX,\
    \ num[1] + offsetY);\n@@ -1744,8 +1741,7 @@ static bool parsePathDataFast(QStringView\
    \ dataStr, QPainterPath &path)\n             }\n             case 'C': {\n   \
    \              if (count < 6) {\n-                    num += count;\n-       \
    \             count = 0;\n+                    ok = false;\n                 \
    \    break;\n                 }\n                 QPointF c1(num[0], num[1]);\n\
    @@ -1761,8 +1757,7 @@ static bool parsePathDataFast(QStringView dataStr, QPainterPath\
    \ &path)\n             }\n             case 's': {\n                 if (count\
    \ < 4) {\n-                    num += count;\n-                    count = 0;\n\
    +                    ok = false;\n                     break;\n              \
    \   }\n                 QPointF c1;\n@@ -1783,8 +1778,7 @@ static bool parsePathDataFast(QStringView\
    \ dataStr, QPainterPath &path)\n             }\n             case 'S': {\n   \
    \              if (count < 4) {\n-                    num += count;\n-       \
    \             count = 0;\n+                    ok = false;\n                 \
    \    break;\n                 }\n                 QPointF c1;\n@@ -1805,8 +1799,7\
    \ @@ static bool parsePathDataFast(QStringView dataStr, QPainterPath &path)\n\
    \             }\n             case 'q': {\n                 if (count < 4) {\n\
    -                    num += count;\n-                    count = 0;\n+       \
    \             ok = false;\n                     break;\n                 }\n \
    \                QPointF c(num[0] + offsetX, num[1] + offsetY);\n@@ -1821,8 +1814,7\
    \ @@ static bool parsePathDataFast(QStringView dataStr, QPainterPath &path)\n\
    \             }\n             case 'Q': {\n                 if (count < 4) {\n\
    -                    num += count;\n-                    count = 0;\n+       \
    \             ok = false;\n                     break;\n                 }\n \
    \                QPointF c(num[0], num[1]);\n@@ -1837,8 +1829,7 @@ static bool\
    \ parsePathDataFast(QStringView dataStr, QPainterPath &path)\n             }\n\
    \             case 't': {\n                 if (count < 2) {\n-              \
    \      num += count;\n-                    count = 0;\n+                    ok\
    \ = false;\n                     break;\n                 }\n                \
    \ QPointF e(num[0] + offsetX, num[1] + offsetY);\n@@ -1858,8 +1849,7 @@ static\
    \ bool parsePathDataFast(QStringView dataStr, QPainterPath &path)\n          \
    \   }\n             case 'T': {\n                 if (count < 2) {\n-        \
    \            num += count;\n-                    count = 0;\n+               \
    \     ok = false;\n                     break;\n                 }\n         \
    \        QPointF e(num[0], num[1]);\n@@ -1879,8 +1869,7 @@ static bool parsePathDataFast(QStringView\
    \ dataStr, QPainterPath &path)\n             }\n             case 'a': {\n   \
    \              if (count < 7) {\n-                    num += count;\n-       \
    \             count = 0;\n+                    ok = false;\n                 \
    \    break;\n                 }\n                 qreal rx = (*num++);\n@@ -1902,8\
    \ +1891,7 @@ static bool parsePathDataFast(QStringView dataStr, QPainterPath &path)\n\
    \                 break;\n             case 'A': {\n                 if (count\
    \ < 7) {\n-                    num += count;\n-                    count = 0;\n\
    +                    ok = false;\n                     break;\n              \
    \   }\n                 qreal rx = (*num++);\n@@ -1924,12 +1912,15 @@ static bool\
    \ parsePathDataFast(QStringView dataStr, QPainterPath &path)\n             }\n\
    \                 break;\n             default:\n-                return false;\n\
    +                ok = false;\n+                break;\n             }\n      \
    \       lastMode = pathElem.toLatin1();\n+            if (path.elementCount()\
    \ > maxElementCount)\n+                ok = false;\n         }\n     }\n-    return\
    \ true;\n+    return ok;\n }\n \n static bool parseStyle(QSvgNode *node,\n@@ -2987,8\
    \ +2978,8 @@ static QSvgNode *createPathNode(QSvgNode *parent,\n \n     QPainterPath\
    \ qpath;\n     qpath.setFillRule(Qt::WindingFill);\n-    //XXX do error handling\n\
    -    parsePathDataFast(data, qpath);\n+    if (!parsePathDataFast(data, qpath))\n\
    +        qCWarning(lcSvgHandler, \"Invalid path data; path truncated.\");\n \n\
    \     QSvgNode *path = new QSvgPath(parent, qpath);\n     return path;"
  - "--- a/src/svg/qsvghandler.cpp\n+++ b/src/svg/qsvghandler.cpp\n@@ -1611,14 +1611,16\
    \ @@ static void pathArc(QPainterPath &path,\n \n static bool parsePathDataFast(const\
    \ QStringRef &dataStr, QPainterPath &path)\n {\n+    const int maxElementCount\
    \ = 0x7fff; // Assume file corruption if more path elements than this\n     qreal\
    \ x0 = 0, y0 = 0;              // starting point\n     qreal x = 0, y = 0;   \
    \             // current point\n     char lastMode = 0;\n     QPointF ctrlPt;\n\
    \     const QChar *str = dataStr.constData();\n     const QChar *end = str + dataStr.size();\n\
    \ \n-    while (str != end) {\n+    bool ok = true;\n+    while (ok && str !=\
    \ end) {\n         while (str->isSpace() && (str + 1) != end)\n             ++str;\n\
    \         QChar pathElem = *str;\n@@ -1632,14 +1634,13 @@ static bool parsePathDataFast(const\
    \ QStringRef &dataStr, QPainterPath &path)\n             arg.append(0);//dummy\n\
    \         const qreal *num = arg.constData();\n         int count = arg.count();\n\
    -        while (count > 0) {\n+        while (ok && count > 0) {\n           \
    \  qreal offsetX = x;        // correction offsets\n             qreal offsetY\
    \ = y;        // for relative commands\n             switch (pathElem.unicode())\
    \ {\n             case 'm': {\n                 if (count < 2) {\n-          \
    \          num++;\n-                    count--;\n+                    ok = false;\n\
    \                     break;\n                 }\n                 x = x0 = num[0]\
    \ + offsetX;\n@@ -1656,8 +1657,7 @@ static bool parsePathDataFast(const QStringRef\
    \ &dataStr, QPainterPath &path)\n                 break;\n             case 'M':\
    \ {\n                 if (count < 2) {\n-                    num++;\n-       \
    \             count--;\n+                    ok = false;\n                   \
    \  break;\n                 }\n                 x = x0 = num[0];\n@@ -1683,8 +1683,7\
    \ @@ static bool parsePathDataFast(const QStringRef &dataStr, QPainterPath &path)\n\
    \                 break;\n             case 'l': {\n                 if (count\
    \ < 2) {\n-                    num++;\n-                    count--;\n+      \
    \              ok = false;\n                     break;\n                 }\n\
    \                 x = num[0] + offsetX;\n@@ -1697,8 +1696,7 @@ static bool parsePathDataFast(const\
    \ QStringRef &dataStr, QPainterPath &path)\n                 break;\n        \
    \     case 'L': {\n                 if (count < 2) {\n-                    num++;\n\
    -                    count--;\n+                    ok = false;\n            \
    \         break;\n                 }\n                 x = num[0];\n@@ -1738,8\
    \ +1736,7 @@ static bool parsePathDataFast(const QStringRef &dataStr, QPainterPath\
    \ &path)\n                 break;\n             case 'c': {\n                \
    \ if (count < 6) {\n-                    num += count;\n-                    count\
    \ = 0;\n+                    ok = false;\n                     break;\n      \
    \           }\n                 QPointF c1(num[0] + offsetX, num[1] + offsetY);\n\
    @@ -1755,8 +1752,7 @@ static bool parsePathDataFast(const QStringRef &dataStr,\
    \ QPainterPath &path)\n             }\n             case 'C': {\n            \
    \     if (count < 6) {\n-                    num += count;\n-                \
    \    count = 0;\n+                    ok = false;\n                     break;\n\
    \                 }\n                 QPointF c1(num[0], num[1]);\n@@ -1772,8\
    \ +1768,7 @@ static bool parsePathDataFast(const QStringRef &dataStr, QPainterPath\
    \ &path)\n             }\n             case 's': {\n                 if (count\
    \ < 4) {\n-                    num += count;\n-                    count = 0;\n\
    +                    ok = false;\n                     break;\n              \
    \   }\n                 QPointF c1;\n@@ -1794,8 +1789,7 @@ static bool parsePathDataFast(const\
    \ QStringRef &dataStr, QPainterPath &path)\n             }\n             case\
    \ 'S': {\n                 if (count < 4) {\n-                    num += count;\n\
    -                    count = 0;\n+                    ok = false;\n          \
    \           break;\n                 }\n                 QPointF c1;\n@@ -1816,8\
    \ +1810,7 @@ static bool parsePathDataFast(const QStringRef &dataStr, QPainterPath\
    \ &path)\n             }\n             case 'q': {\n                 if (count\
    \ < 4) {\n-                    num += count;\n-                    count = 0;\n\
    +                    ok = false;\n                     break;\n              \
    \   }\n                 QPointF c(num[0] + offsetX, num[1] + offsetY);\n@@ -1832,8\
    \ +1825,7 @@ static bool parsePathDataFast(const QStringRef &dataStr, QPainterPath\
    \ &path)\n             }\n             case 'Q': {\n                 if (count\
    \ < 4) {\n-                    num += count;\n-                    count = 0;\n\
    +                    ok = false;\n                     break;\n              \
    \   }\n                 QPointF c(num[0], num[1]);\n@@ -1848,8 +1840,7 @@ static\
    \ bool parsePathDataFast(const QStringRef &dataStr, QPainterPath &path)\n    \
    \         }\n             case 't': {\n                 if (count < 2) {\n-  \
    \                  num += count;\n-                    count = 0;\n+         \
    \           ok = false;\n                     break;\n                 }\n   \
    \              QPointF e(num[0] + offsetX, num[1] + offsetY);\n@@ -1869,8 +1860,7\
    \ @@ static bool parsePathDataFast(const QStringRef &dataStr, QPainterPath &path)\n\
    \             }\n             case 'T': {\n                 if (count < 2) {\n\
    -                    num += count;\n-                    count = 0;\n+       \
    \             ok = false;\n                     break;\n                 }\n \
    \                QPointF e(num[0], num[1]);\n@@ -1890,8 +1880,7 @@ static bool\
    \ parsePathDataFast(const QStringRef &dataStr, QPainterPath &path)\n         \
    \    }\n             case 'a': {\n                 if (count < 7) {\n-       \
    \             num += count;\n-                    count = 0;\n+              \
    \      ok = false;\n                     break;\n                 }\n        \
    \         qreal rx = (*num++);\n@@ -1913,8 +1902,7 @@ static bool parsePathDataFast(const\
    \ QStringRef &dataStr, QPainterPath &path)\n                 break;\n        \
    \     case 'A': {\n                 if (count < 7) {\n-                    num\
    \ += count;\n-                    count = 0;\n+                    ok = false;\n\
    \                     break;\n                 }\n                 qreal rx =\
    \ (*num++);\n@@ -1935,12 +1923,15 @@ static bool parsePathDataFast(const QStringRef\
    \ &dataStr, QPainterPath &path)\n             }\n                 break;\n   \
    \          default:\n-                return false;\n+                ok = false;\n\
    +                break;\n             }\n             lastMode = pathElem.toLatin1();\n\
    +            if (path.elementCount() > maxElementCount)\n+                ok =\
    \ false;\n         }\n     }\n-    return true;\n+    return ok;\n }\n \n static\
    \ bool parseStyle(QSvgNode *node,\n@@ -2976,8 +2967,8 @@ static QSvgNode *createPathNode(QSvgNode\
    \ *parent,\n \n     QPainterPath qpath;\n     qpath.setFillRule(Qt::WindingFill);\n\
    -    //XXX do error handling\n-    parsePathDataFast(data, qpath);\n+    if (!parsePathDataFast(data,\
    \ qpath))\n+        qCWarning(lcSvgHandler, \"Invalid path data; path truncated.\"\
    );\n \n     QSvgNode *path = new QSvgPath(parent, qpath);\n     return path;"
  identifiers:
  - CVE-2021-45930
  - CWE-787
  overview: Qt SVG in Qt 5.0.0 through 5.15.2 and 6.0.0 through 6.2.1 has an out-of-bounds
    write in QtPrivate::QCommonArrayOps<QPainterPath::Element>::growAppend (called
    from QPainterPath::addPath and QPathClipper::intersect).
  references:
  - source: cve@mitre.org
    tags:
    - Exploit
    - Issue Tracking
    - Third Party Advisory
    url: https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=37025
  - source: cve@mitre.org
    tags:
    - Exploit
    - Issue Tracking
    - Third Party Advisory
    url: https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=37306
  - source: cve@mitre.org
    tags:
    - Exploit
    - Third Party Advisory
    url: https://github.com/google/oss-fuzz-vulns/blob/main/vulns/qt/OSV-2021-1121.yaml
  - source: cve@mitre.org
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/qt/qtsvg/commit/36cfd9efb9b22b891adee9c48d30202289cfa620
  - source: cve@mitre.org
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/qt/qtsvg/commit/79bb9f51fa374106a612d17c9d98d35d807be670
  - source: cve@mitre.org
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/qt/qtsvg/commit/a3b753c2d077313fc9eb93af547051b956e383fc
  - source: cve@mitre.org
    tags:
    - Mailing List
    - Third Party Advisory
    url: https://lists.debian.org/debian-lts-announce/2022/01/msg00020.html
  - source: cve@mitre.org
    tags:
    - Mailing List
    - Third Party Advisory
    url: https://lists.debian.org/debian-lts-announce/2022/01/msg00022.html
  - source: cve@mitre.org
    url: https://lists.debian.org/debian-lts-announce/2023/08/msg00028.html
  - source: cve@mitre.org
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/4GKOKVCSDZSOWWR3HOW5XUIUJC4MKQY5/
  - source: cve@mitre.org
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/GZIXNSX7FV733TWTTLY6FHSH3SCNQKKD/
  - source: cve@mitre.org
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/V75XNX4GDB64N5BSOAN474RUXXS5OHRU/
  title: Qt SVG in Qt 5.0.0 through 5.15.2 and 6.0.0 through 6.2.1 has an out-of-bounds
    write in QtPrivate::QCommonArrayOps<QPainterPath::Element>::growAppend (called
    from QPainterPath::addPath and QPathClipper::intersect).
- diff_content:
  - "--- a/src/mqtt_client.c\n+++ b/src/mqtt_client.c\n@@ -906,8 +906,9 @@ static\
    \ int MqttClient_WaitType(MqttClient *client, void *packet_obj,\n            \
    \ /* Determine if we received data for this request */\n             if ((wait_type\
    \ == MQTT_PACKET_TYPE_ANY ||\n                  wait_type == packet_type ||\n\
    -                 MqttIsPubRespPacket(packet_type) == MqttIsPubRespPacket(wait_type))\
    \ &&\n-               (wait_packet_id == 0 || wait_packet_id == packet_id))\n\
    +                 (MqttIsPubRespPacket(packet_type) &&\n+                  MqttIsPubRespPacket(wait_type)))\
    \ &&\n+                (wait_packet_id == 0 || wait_packet_id == packet_id))\n\
    \             {\n                 use_packet_obj = packet_obj;\n             \
    \    waitMatchFound = 1;"
  identifiers:
  - CVE-2021-45932
  - CWE-787
  overview: wolfSSL wolfMQTT 1.9 has a heap-based buffer overflow (4 bytes) in MqttDecode_Publish
    (called from MqttClient_DecodePacket and MqttClient_HandlePacket).
  references:
  - source: cve@mitre.org
    tags:
    - Exploit
    - Issue Tracking
    - Third Party Advisory
    url: https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=37866
  - source: cve@mitre.org
    tags:
    - Exploit
    - Third Party Advisory
    url: https://github.com/google/oss-fuzz-vulns/blob/main/vulns/wolfmqtt/OSV-2021-1188.yaml
  - source: cve@mitre.org
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/wolfSSL/wolfMQTT/commit/84d4b53122e0fa0280c7872350b89d5777dabbb2
  title: wolfSSL wolfMQTT 1.9 has a heap-based buffer overflow (4 bytes) in MqttDecode_Publish
    (called from MqttClient_DecodePacket and MqttClient_HandlePacket).
- diff_content:
  - "--- a/src/mqtt_client.c\n+++ b/src/mqtt_client.c\n@@ -906,8 +906,9 @@ static\
    \ int MqttClient_WaitType(MqttClient *client, void *packet_obj,\n            \
    \ /* Determine if we received data for this request */\n             if ((wait_type\
    \ == MQTT_PACKET_TYPE_ANY ||\n                  wait_type == packet_type ||\n\
    -                 MqttIsPubRespPacket(packet_type) == MqttIsPubRespPacket(wait_type))\
    \ &&\n-               (wait_packet_id == 0 || wait_packet_id == packet_id))\n\
    +                 (MqttIsPubRespPacket(packet_type) &&\n+                  MqttIsPubRespPacket(wait_type)))\
    \ &&\n+                (wait_packet_id == 0 || wait_packet_id == packet_id))\n\
    \             {\n                 use_packet_obj = packet_obj;\n             \
    \    waitMatchFound = 1;"
  identifiers:
  - CVE-2021-45933
  - CWE-787
  overview: wolfSSL wolfMQTT 1.9 has a heap-based buffer overflow (8 bytes) in MqttDecode_Publish
    (called from MqttClient_DecodePacket and MqttClient_HandlePacket).
  references:
  - source: cve@mitre.org
    tags:
    - Exploit
    - Issue Tracking
    - Third Party Advisory
    url: https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=38237
  - source: cve@mitre.org
    tags:
    - Exploit
    - Third Party Advisory
    url: https://github.com/google/oss-fuzz-vulns/blob/main/vulns/wolfmqtt/OSV-2021-1211.yaml
  - source: cve@mitre.org
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/wolfSSL/wolfMQTT/commit/84d4b53122e0fa0280c7872350b89d5777dabbb2
  title: wolfSSL wolfMQTT 1.9 has a heap-based buffer overflow (8 bytes) in MqttDecode_Publish
    (called from MqttClient_DecodePacket and MqttClient_HandlePacket).
- diff_content:
  - "--- a/src/mqtt_client.c\n+++ b/src/mqtt_client.c\n@@ -906,8 +906,9 @@ static\
    \ int MqttClient_WaitType(MqttClient *client, void *packet_obj,\n            \
    \ /* Determine if we received data for this request */\n             if ((wait_type\
    \ == MQTT_PACKET_TYPE_ANY ||\n                  wait_type == packet_type ||\n\
    -                 MqttIsPubRespPacket(packet_type) == MqttIsPubRespPacket(wait_type))\
    \ &&\n-               (wait_packet_id == 0 || wait_packet_id == packet_id))\n\
    +                 (MqttIsPubRespPacket(packet_type) &&\n+                  MqttIsPubRespPacket(wait_type)))\
    \ &&\n+                (wait_packet_id == 0 || wait_packet_id == packet_id))\n\
    \             {\n                 use_packet_obj = packet_obj;\n             \
    \    waitMatchFound = 1;"
  identifiers:
  - CVE-2021-45934
  - CWE-787
  overview: wolfSSL wolfMQTT 1.9 has a heap-based buffer overflow in MqttClient_DecodePacket
    (called from MqttClient_HandlePacket and MqttClient_WaitType).
  references:
  - source: cve@mitre.org
    tags:
    - Exploit
    - Issue Tracking
    - Third Party Advisory
    url: https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=38146
  - source: cve@mitre.org
    tags:
    - Exploit
    - Third Party Advisory
    url: https://github.com/google/oss-fuzz-vulns/blob/main/vulns/wolfmqtt/OSV-2021-1204.yaml
  - source: cve@mitre.org
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/wolfSSL/wolfMQTT/commit/84d4b53122e0fa0280c7872350b89d5777dabbb2
  title: wolfSSL wolfMQTT 1.9 has a heap-based buffer overflow in MqttClient_DecodePacket
    (called from MqttClient_HandlePacket and MqttClient_WaitType).
- diff_content:
  - "--- a/src/mqtt_client.c\n+++ b/src/mqtt_client.c\n@@ -906,8 +906,9 @@ static\
    \ int MqttClient_WaitType(MqttClient *client, void *packet_obj,\n            \
    \ /* Determine if we received data for this request */\n             if ((wait_type\
    \ == MQTT_PACKET_TYPE_ANY ||\n                  wait_type == packet_type ||\n\
    -                 MqttIsPubRespPacket(packet_type) == MqttIsPubRespPacket(wait_type))\
    \ &&\n-               (wait_packet_id == 0 || wait_packet_id == packet_id))\n\
    +                 (MqttIsPubRespPacket(packet_type) &&\n+                  MqttIsPubRespPacket(wait_type)))\
    \ &&\n+                (wait_packet_id == 0 || wait_packet_id == packet_id))\n\
    \             {\n                 use_packet_obj = packet_obj;\n             \
    \    waitMatchFound = 1;"
  identifiers:
  - CVE-2021-45936
  - CWE-787
  overview: wolfSSL wolfMQTT 1.9 has a heap-based buffer overflow in MqttDecode_Disconnect
    (called from MqttClient_DecodePacket and MqttClient_WaitType).
  references:
  - source: cve@mitre.org
    tags:
    - Exploit
    - Issue Tracking
    - Third Party Advisory
    url: https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=39053
  - source: cve@mitre.org
    tags:
    - Exploit
    - Third Party Advisory
    url: https://github.com/google/oss-fuzz-vulns/blob/main/vulns/wolfmqtt/OSV-2021-1348.yaml
  - source: cve@mitre.org
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/wolfSSL/wolfMQTT/commit/84d4b53122e0fa0280c7872350b89d5777dabbb2
  title: wolfSSL wolfMQTT 1.9 has a heap-based buffer overflow in MqttDecode_Disconnect
    (called from MqttClient_DecodePacket and MqttClient_WaitType).
- diff_content:
  - "--- a/src/mqtt_client.c\n+++ b/src/mqtt_client.c\n@@ -906,8 +906,9 @@ static\
    \ int MqttClient_WaitType(MqttClient *client, void *packet_obj,\n            \
    \ /* Determine if we received data for this request */\n             if ((wait_type\
    \ == MQTT_PACKET_TYPE_ANY ||\n                  wait_type == packet_type ||\n\
    -                 MqttIsPubRespPacket(packet_type) == MqttIsPubRespPacket(wait_type))\
    \ &&\n-               (wait_packet_id == 0 || wait_packet_id == packet_id))\n\
    +                 (MqttIsPubRespPacket(packet_type) &&\n+                  MqttIsPubRespPacket(wait_type)))\
    \ &&\n+                (wait_packet_id == 0 || wait_packet_id == packet_id))\n\
    \             {\n                 use_packet_obj = packet_obj;\n             \
    \    waitMatchFound = 1;"
  identifiers:
  - CVE-2021-45937
  - CWE-787
  overview: wolfSSL wolfMQTT 1.9 has a heap-based buffer overflow in MqttClient_DecodePacket
    (called from MqttClient_WaitType and MqttClient_Connect).
  references:
  - source: cve@mitre.org
    tags:
    - Exploit
    - Issue Tracking
    - Third Party Advisory
    url: https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=39083
  - source: cve@mitre.org
    tags:
    - Exploit
    - Third Party Advisory
    url: https://github.com/google/oss-fuzz-vulns/blob/main/vulns/wolfmqtt/OSV-2021-1349.yaml
  - source: cve@mitre.org
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/wolfSSL/wolfMQTT/commit/84d4b53122e0fa0280c7872350b89d5777dabbb2
  title: wolfSSL wolfMQTT 1.9 has a heap-based buffer overflow in MqttClient_DecodePacket
    (called from MqttClient_WaitType and MqttClient_Connect).
- diff_content:
  - "--- a/src/mqtt_client.c\n+++ b/src/mqtt_client.c\n@@ -906,8 +906,9 @@ static\
    \ int MqttClient_WaitType(MqttClient *client, void *packet_obj,\n            \
    \ /* Determine if we received data for this request */\n             if ((wait_type\
    \ == MQTT_PACKET_TYPE_ANY ||\n                  wait_type == packet_type ||\n\
    -                 MqttIsPubRespPacket(packet_type) == MqttIsPubRespPacket(wait_type))\
    \ &&\n-               (wait_packet_id == 0 || wait_packet_id == packet_id))\n\
    +                 (MqttIsPubRespPacket(packet_type) &&\n+                  MqttIsPubRespPacket(wait_type)))\
    \ &&\n+                (wait_packet_id == 0 || wait_packet_id == packet_id))\n\
    \             {\n                 use_packet_obj = packet_obj;\n             \
    \    waitMatchFound = 1;"
  identifiers:
  - CVE-2021-45938
  - CWE-787
  overview: wolfSSL wolfMQTT 1.9 has a heap-based buffer overflow in MqttClient_DecodePacket
    (called from MqttClient_WaitType and MqttClient_Unsubscribe).
  references:
  - source: cve@mitre.org
    tags:
    - Exploit
    - Issue Tracking
    - Third Party Advisory
    url: https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=39056
  - source: cve@mitre.org
    tags:
    - Exploit
    - Third Party Advisory
    url: https://github.com/google/oss-fuzz-vulns/blob/main/vulns/wolfmqtt/OSV-2021-1353.yaml
  - source: cve@mitre.org
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/wolfSSL/wolfMQTT/commit/84d4b53122e0fa0280c7872350b89d5777dabbb2
  title: wolfSSL wolfMQTT 1.9 has a heap-based buffer overflow in MqttClient_DecodePacket
    (called from MqttClient_WaitType and MqttClient_Unsubscribe).
- diff_content:
  - "--- a/src/mqtt_client.c\n+++ b/src/mqtt_client.c\n@@ -906,8 +906,9 @@ static\
    \ int MqttClient_WaitType(MqttClient *client, void *packet_obj,\n            \
    \ /* Determine if we received data for this request */\n             if ((wait_type\
    \ == MQTT_PACKET_TYPE_ANY ||\n                  wait_type == packet_type ||\n\
    -                 MqttIsPubRespPacket(packet_type) == MqttIsPubRespPacket(wait_type))\
    \ &&\n-               (wait_packet_id == 0 || wait_packet_id == packet_id))\n\
    +                 (MqttIsPubRespPacket(packet_type) &&\n+                  MqttIsPubRespPacket(wait_type)))\
    \ &&\n+                (wait_packet_id == 0 || wait_packet_id == packet_id))\n\
    \             {\n                 use_packet_obj = packet_obj;\n             \
    \    waitMatchFound = 1;"
  identifiers:
  - CVE-2021-45939
  - CWE-787
  overview: wolfSSL wolfMQTT 1.9 has a heap-based buffer overflow in MqttClient_DecodePacket
    (called from MqttClient_WaitType and MqttClient_Subscribe).
  references:
  - source: cve@mitre.org
    tags:
    - Exploit
    - Issue Tracking
    - Third Party Advisory
    url: https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=39103
  - source: cve@mitre.org
    tags:
    - Exploit
    - Third Party Advisory
    url: https://github.com/google/oss-fuzz-vulns/blob/main/vulns/wolfmqtt/OSV-2021-1361.yaml
  - source: cve@mitre.org
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/wolfSSL/wolfMQTT/commit/84d4b53122e0fa0280c7872350b89d5777dabbb2
  title: wolfSSL wolfMQTT 1.9 has a heap-based buffer overflow in MqttClient_DecodePacket
    (called from MqttClient_WaitType and MqttClient_Subscribe).
- diff_content:
  - "--- a/src/lib/OpenEXR/ImfCompositeDeepScanLine.cpp\n+++ b/src/lib/OpenEXR/ImfCompositeDeepScanLine.cpp\n\
    @@ -238,6 +238,20 @@ CompositeDeepScanLine::setFrameBuffer(const FrameBuffer&\
    \ fr)\n     \n     for(FrameBuffer::ConstIterator q=fr.begin();q!=fr.end();q++)\n\
    \     {\n+\n+        //\n+        // Frame buffer must have xSampling and ySampling\
    \ set to 1\n+        // (Sampling in FrameBuffers must match sampling in file,\n\
    +        //  and Header::sanityCheck enforces sampling in deep files is 1)\n+\
    \        //\n+\n+        if(q.slice().xSampling!=1 || q.slice().ySampling!=1)\n\
    +        {\n+             THROW (IEX_NAMESPACE::ArgExc, \"X and/or y subsampling\
    \ factors \"\n+\t\t\t\t\"of \\\"\" << q.name() << \"\\\" channel in framebuffer\
    \ \"\n+\t\t\t\t\"are not 1\");\n+        }\n+\n         string name(q.name());\n\
    \         if(name==\"ZBack\")\n         {"
  - "--- a/src/lib/OpenEXR/ImfDeepScanLineInputFile.cpp\n+++ b/src/lib/OpenEXR/ImfDeepScanLineInputFile.cpp\n\
    @@ -1961,14 +1961,20 @@ readSampleCountForLineBlock(InputStreamMutex* streamData,\n\
    \     // @TODO refactor the compressor code to ensure full 64-bit support.\n \
    \    //\n \n-    int compressorMaxDataSize = std::numeric_limits<int>::max();\n\
    -    if (sampleCountTableDataSize > uint64_t(compressorMaxDataSize))\n+    uint64_t\
    \ compressorMaxDataSize = static_cast<uint64_t>(std::numeric_limits<int>::max());\n\
    +    if (packedDataSize         > compressorMaxDataSize ||\n+        unpackedDataSize\
    \ > compressorMaxDataSize ||\n+        sampleCountTableDataSize        > compressorMaxDataSize)\n\
    \     {\n-        THROW (IEX_NAMESPACE::ArgExc, \"This version of the library\
    \ does not \"\n-              << \"support the allocation of data with size  >\
    \ \"\n-              << compressorMaxDataSize\n-              << \" file table\
    \ size    :\" << sampleCountTableDataSize << \".\\n\");\n+        THROW (IEX_NAMESPACE::ArgExc,\
    \ \"This version of the library does not\"\n+            << \"support the allocation\
    \ of data with size  > \"\n+            << compressorMaxDataSize\n+          \
    \  << \" file table size    :\" << sampleCountTableDataSize\n+            << \"\
    \ file unpacked size :\" << unpackedDataSize\n+            << \" file packed size\
    \   :\" << packedDataSize << \".\\n\");\n     }\n+\n+\n     streamData->is->read(data->sampleCountTableBuffer,\
    \ static_cast<int>(sampleCountTableDataSize));\n     \n     const char* readPtr;"
  identifiers:
  - CVE-2021-45942
  - CWE-787
  overview: 'OpenEXR 3.1.x before 3.1.4 has a heap-based buffer overflow in Imf_3_1::LineCompositeTask::execute
    (called from IlmThread_3_1::NullThreadPoolProvider::addTask and IlmThread_3_1::ThreadPool::addGlobalTask).
    NOTE: db217f2 may be inapplicable.'
  references:
  - source: cve@mitre.org
    tags:
    - Exploit
    - Issue Tracking
    - Mailing List
    - Patch
    - Third Party Advisory
    url: https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=41416
  - source: cve@mitre.org
    tags:
    - Release Notes
    - Third Party Advisory
    url: https://github.com/AcademySoftwareFoundation/openexr/blob/v3.1.4/CHANGES.md#version-314-january-26-2022
  - source: cve@mitre.org
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/AcademySoftwareFoundation/openexr/commit/11cad77da87c4fa2aab7d58dd5339e254db7937e
  - source: cve@mitre.org
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/AcademySoftwareFoundation/openexr/commit/db217f29dfb24f6b4b5100c24ac5e7490e1c57d0
  - source: cve@mitre.org
    tags:
    - Exploit
    - Patch
    - Third Party Advisory
    url: https://github.com/AcademySoftwareFoundation/openexr/pull/1209
  - source: cve@mitre.org
    tags:
    - Release Notes
    - Third Party Advisory
    url: https://github.com/AcademySoftwareFoundation/openexr/releases/tag/v3.1.4
  - source: cve@mitre.org
    tags:
    - Third Party Advisory
    url: https://github.com/google/oss-fuzz-vulns/blob/main/vulns/openexr/OSV-2021-1627.yaml
  - source: cve@mitre.org
    tags:
    - Mailing List
    - Third Party Advisory
    url: https://lists.debian.org/debian-lts-announce/2022/12/msg00022.html
  - source: cve@mitre.org
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/6TEZDE2S2DB4BF4LZSSV4W3DNW7DSRHJ/
  - source: cve@mitre.org
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/HJ5PW4WNXBKCRFGDZGAQOSVH2BKZKL4X/
  - source: cve@mitre.org
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/XJUK7WIQV5EKWTCZBRXFN6INHG6MLS5O/
  - source: cve@mitre.org
    tags:
    - Third Party Advisory
    url: https://security.gentoo.org/glsa/202210-31
  - source: cve@mitre.org
    tags:
    - Third Party Advisory
    url: https://www.debian.org/security/2022/dsa-5299
  title: 'OpenEXR 3.1.x before 3.1.4 has a heap-based buffer overflow in Imf_3_1::LineCompositeTask::execute
    (called from IlmThread_3_1::NullThreadPoolProvider::addTask and IlmThread_3_1::ThreadPool::addGlobalTask).
    NOTE: db217f2 may be inapplicable.'
- diff_content:
  - "--- a/frmts/pcidsk/sdk/segment/cpcidskbinarysegment.cpp\n+++ b/frmts/pcidsk/sdk/segment/cpcidskbinarysegment.cpp\n\
    @@ -31,6 +31,7 @@\n #include \"pcidsk_exception.h\"\n #include \"core/pcidsk_utils.h\"\
    \n \n+#include <limits>\n #include <vector>\n #include <string>\n #include <cassert>\n\
    @@ -73,8 +74,12 @@ void CPCIDSKBinarySegment::Load()\n     if (loaded_) {\n  \
    \       return;\n     }\n+    if( data_size - 1024 > static_cast<uint64_t>(std::numeric_limits<int>::max())\
    \ )\n+    {\n+        return ThrowPCIDSKException(\"too large data_size\");\n\
    +    }\n \n-    seg_data.SetSize((int)data_size - 1024);\n+    seg_data.SetSize((int)(data_size\
    \ - 1024));\n \n     ReadFromFile(seg_data.buffer, 0, data_size - 1024);\n "
  identifiers:
  - CVE-2021-45943
  - CWE-787
  overview: GDAL 3.3.0 through 3.4.0 has a heap-based buffer overflow in PCIDSK::CPCIDSKFile::ReadFromFile
    (called from PCIDSK::CPCIDSKSegment::ReadFromFile and PCIDSK::CPCIDSKBinarySegment::CPCIDSKBinarySegment).
  references:
  - source: cve@mitre.org
    tags:
    - Exploit
    - Issue Tracking
    - Mailing List
    - Patch
    - Third Party Advisory
    url: https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=41993
  - source: cve@mitre.org
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/OSGeo/gdal/commit/1ca6a3e5168c200763fa46d8aa7e698d0b757e7e
  - source: cve@mitre.org
    tags:
    - Exploit
    - Patch
    - Third Party Advisory
    url: https://github.com/OSGeo/gdal/pull/4944
  - source: cve@mitre.org
    tags:
    - Third Party Advisory
    url: https://github.com/google/oss-fuzz-vulns/blob/main/vulns/gdal/OSV-2021-1651.yaml
  - source: cve@mitre.org
    tags:
    - Mailing List
    - Third Party Advisory
    url: https://lists.debian.org/debian-lts-announce/2022/01/msg00004.html
  - source: cve@mitre.org
    tags:
    - Mailing List
    - Third Party Advisory
    url: https://lists.debian.org/debian-lts-announce/2022/09/msg00040.html
  - source: cve@mitre.org
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/JBPJGXY7IYY65NVJBLP3RONXE7ZBVCNU/
  - source: cve@mitre.org
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/P23E4DEHY5FJCR5VJ46I6TO32DT7Y3T4/
  - source: cve@mitre.org
    tags:
    - Third Party Advisory
    url: https://security.gentoo.org/glsa/202210-15
  - source: cve@mitre.org
    tags:
    - Third Party Advisory
    url: https://www.debian.org/security/2022/dsa-5239
  - source: cve@mitre.org
    tags:
    - Patch
    - Third Party Advisory
    url: https://www.oracle.com/security-alerts/cpujul2022.html
  title: GDAL 3.3.0 through 3.4.0 has a heap-based buffer overflow in PCIDSK::CPCIDSKFile::ReadFromFile
    (called from PCIDSK::CPCIDSKSegment::ReadFromFile and PCIDSK::CPCIDSKBinarySegment::CPCIDSKBinarySegment).
- diff_content:
  - "--- a/src/proc.c\n+++ b/src/proc.c\n@@ -207,12 +207,12 @@ mrb_proc_copy(mrb_state\
    \ *mrb, struct RProc *a, struct RProc *b)\n     /* already initialized proc */\n\
    \     return;\n   }\n+  if (!MRB_PROC_CFUNC_P(b) && b->body.irep) {\n+    mrb_irep_incref(mrb,\
    \ (mrb_irep*)b->body.irep);\n+  }\n   a->flags = b->flags;\n   a->body = b->body;\n\
    \   a->upper = b->upper;\n-  if (!MRB_PROC_CFUNC_P(a) && a->body.irep) {\n-  \
    \  mrb_irep_incref(mrb, (mrb_irep*)a->body.irep);\n-  }\n   a->e.env = b->e.env;\n\
    \   /* a->e.target_class = a->e.target_class; */\n }"
  identifiers:
  - CVE-2022-0080
  - CWE-122
  overview: mruby is vulnerable to Heap-based Buffer Overflow
  references:
  - source: security@huntr.dev
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/mruby/mruby/commit/28ccc664e5dcd3f9d55173e9afde77c4705a9ab6
  - source: security@huntr.dev
    tags:
    - Exploit
    - Issue Tracking
    - Patch
    - Third Party Advisory
    url: https://huntr.dev/bounties/59a70392-4864-4ce3-8e35-6ac2111d1e2e
  title: mruby is vulnerable to Heap-based Buffer Overflow
- diff_content:
  - '--- a/server/vendor/aws/aws-crt-php/ext/awscrt.c

    +++ b/server/vendor/aws/aws-crt-php/ext/awscrt.c

    @@ -0,0 +1,17 @@

    +/**

    + * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.

    + * SPDX-License-Identifier: Apache-2.0.

    + */

    +

    +/* This is a unity-build style source file, as PHP''s build system is simplest
    with 1 source file per extension */

    +

    +#include "credentials.c"

    +#include "crt.c"

    +#include "event_loop.c"

    +#include "http.c"

    +#include "signing.c"

    +#include "stream.c"

    +// #include "hash.c"

    +#include "crc.c"

    +#include "logging.c"

    +#include "php_util.c"'
  - '--- a/server/vendor/aws/aws-crt-php/ext/crc.c

    +++ b/server/vendor/aws/aws-crt-php/ext/crc.c

    @@ -0,0 +1,32 @@

    +/**

    + * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.

    + * SPDX-License-Identifier: Apache-2.0.

    + */

    +

    +#include "php_aws_crt.h"

    +

    +PHP_FUNCTION(aws_crt_crc32) {

    +    zend_ulong prev = 0;

    +    const char *input = NULL;

    +    size_t len = 0;

    +

    +    aws_php_parse_parameters("sl", &input, &len, &prev);

    +

    +    if (prev > UINT32_MAX) {

    +        aws_php_throw_exception("previous crc cannot be larger than UINT32_MAX");

    +    }

    +    RETURN_LONG((zend_ulong)aws_crt_crc32((const uint8_t *)input, len, prev));

    +}

    +

    +PHP_FUNCTION(aws_crt_crc32c) {

    +    zend_ulong prev = 0;

    +    const char *input = NULL;

    +    size_t len = 0;

    +

    +    aws_php_parse_parameters("sl", &input, &len, &prev);

    +

    +    if (prev > UINT32_MAX) {

    +        aws_php_throw_exception("previous crc cannot be larger than UINT32_MAX");

    +    }

    +    RETURN_LONG((zend_ulong)aws_crt_crc32c((const uint8_t *)input, len, prev));

    +}'
  - '--- a/server/vendor/aws/aws-crt-php/ext/credentials.c

    +++ b/server/vendor/aws/aws-crt-php/ext/credentials.c

    @@ -0,0 +1,154 @@

    +/**

    + * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.

    + * SPDX-License-Identifier: Apache-2.0.

    + */

    +

    +#include "php_aws_crt.h"

    +

    +PHP_FUNCTION(aws_crt_credentials_options_new) {

    +    aws_crt_credentials_options *options = aws_crt_credentials_options_new();

    +    RETURN_LONG((zend_ulong)options);

    +}

    +

    +PHP_FUNCTION(aws_crt_credentials_options_release) {

    +    zend_ulong php_options = 0;

    +

    +    aws_php_parse_parameters("l", &php_options);

    +

    +    aws_crt_credentials_options *options = (void *)php_options;

    +    aws_crt_credentials_options_release(options);

    +}

    +

    +PHP_FUNCTION(aws_crt_credentials_options_set_access_key_id) {

    +    zend_ulong php_options = 0;

    +    const char *access_key_id = NULL;

    +    size_t access_key_id_len = 0;

    +

    +    aws_php_parse_parameters("ls", &php_options, &access_key_id, &access_key_id_len);

    +

    +    aws_crt_credentials_options *options = (void *)php_options;

    +    aws_crt_credentials_options_set_access_key_id(options, (uint8_t *)access_key_id,
    access_key_id_len);

    +}

    +

    +PHP_FUNCTION(aws_crt_credentials_options_set_secret_access_key) {

    +    zend_ulong php_options = 0;

    +    const char *secret_access_key = NULL;

    +    size_t secret_access_key_len = 0;

    +

    +    if (zend_parse_parameters(ZEND_NUM_ARGS(), "ls", &php_options, &secret_access_key,
    &secret_access_key_len) ==

    +        FAILURE) {

    +        RETURN_NULL();

    +    }

    +

    +    aws_crt_credentials_options *options = (void *)php_options;

    +    aws_crt_credentials_options_set_secret_access_key(options, (uint8_t *)secret_access_key,
    secret_access_key_len);

    +}

    +

    +PHP_FUNCTION(aws_crt_credentials_options_set_session_token) {

    +    zend_ulong php_options = 0;

    +    const char *session_token = NULL;

    +    size_t session_token_len = 0;

    +

    +    aws_php_parse_parameters("ls", &php_options, &session_token, &session_token_len);

    +

    +    aws_crt_credentials_options *options = (void *)php_options;

    +    aws_crt_credentials_options_set_session_token(options, (uint8_t *)session_token,
    session_token_len);

    +}

    +

    +PHP_FUNCTION(aws_crt_credentials_options_set_expiration_timepoint_seconds) {

    +    zend_ulong php_options = 0;

    +    zend_ulong expiration_timepoint_seconds = 0;

    +    aws_php_parse_parameters("ll", &php_options, &expiration_timepoint_seconds);

    +

    +    aws_crt_credentials_options *options = (void *)php_options;

    +    aws_crt_credentials_options_set_expiration_timepoint_seconds(options, expiration_timepoint_seconds);

    +}

    +

    +PHP_FUNCTION(aws_crt_credentials_new) {

    +    zend_ulong php_options = 0;

    +

    +    aws_php_parse_parameters("l", &php_options);

    +

    +    aws_crt_credentials_options *options = (void *)php_options;

    +    aws_crt_credentials *credentials = aws_crt_credentials_new(options);

    +    RETURN_LONG((zend_ulong)credentials);

    +}

    +

    +PHP_FUNCTION(aws_crt_credentials_release) {

    +    zend_ulong php_credentials = 0;

    +

    +    aws_php_parse_parameters("l", &php_credentials);

    +

    +    aws_crt_credentials *credentials = (void *)php_credentials;

    +    aws_crt_credentials_release(credentials);

    +}

    +

    +PHP_FUNCTION(aws_crt_credentials_provider_release) {

    +    zend_ulong php_creds_provider = 0;

    +

    +    aws_php_parse_parameters("l", &php_creds_provider);

    +

    +    aws_crt_credentials_provider *provider = (void *)php_creds_provider;

    +    aws_crt_credentials_provider_release(provider);

    +}

    +

    +PHP_FUNCTION(aws_crt_credentials_provider_static_options_new) {

    +    aws_crt_credentials_provider_static_options *options = aws_crt_credentials_provider_static_options_new();

    +    RETURN_LONG((zend_ulong)options);

    +}

    +

    +PHP_FUNCTION(aws_crt_credentials_provider_static_options_release) {

    +    zend_ulong php_options = 0;

    +

    +    aws_php_parse_parameters("l", &php_options);

    +

    +    aws_crt_credentials_provider_static_options *options = (void *)php_options;

    +    aws_crt_credentials_provider_static_options_release(options);

    +}

    +

    +PHP_FUNCTION(aws_crt_credentials_provider_static_options_set_access_key_id) {

    +    zend_ulong php_options = 0;

    +    const char *access_key_id = NULL;

    +    size_t access_key_id_len = 0;

    +

    +    aws_php_parse_parameters("ls", &php_options, &access_key_id, &access_key_id_len);

    +

    +    aws_crt_credentials_provider_static_options *options = (void *)php_options;

    +    aws_crt_credentials_provider_static_options_set_access_key_id(options, (uint8_t
    *)access_key_id, access_key_id_len);

    +}

    +

    +PHP_FUNCTION(aws_crt_credentials_provider_static_options_set_secret_access_key)
    {

    +    zend_ulong php_options = 0;

    +    const char *secret_access_key = NULL;

    +    size_t secret_access_key_len = 0;

    +

    +    if (zend_parse_parameters(ZEND_NUM_ARGS(), "ls", &php_options, &secret_access_key,
    &secret_access_key_len) ==

    +        FAILURE) {

    +        RETURN_NULL();

    +    }

    +

    +    aws_crt_credentials_provider_static_options *options = (void *)php_options;

    +    aws_crt_credentials_provider_static_options_set_secret_access_key(

    +        options, (uint8_t *)secret_access_key, secret_access_key_len);

    +}

    +

    +PHP_FUNCTION(aws_crt_credentials_provider_static_options_set_session_token) {

    +    zend_ulong php_options = 0;

    +    const char *session_token = NULL;

    +    size_t session_token_len = 0;

    +

    +    aws_php_parse_parameters("ls", &php_options, &session_token, &session_token_len);

    +

    +    aws_crt_credentials_provider_static_options *options = (void *)php_options;

    +    aws_crt_credentials_provider_static_options_set_session_token(options, (uint8_t
    *)session_token, session_token_len);

    +}

    +

    +PHP_FUNCTION(aws_crt_credentials_provider_static_new) {

    +    zend_ulong php_options = 0;

    +

    +    aws_php_parse_parameters("l", &php_options);

    +

    +    aws_crt_credentials_provider_static_options *options = (void *)php_options;

    +    aws_crt_credentials_provider *provider = aws_crt_credentials_provider_static_new(options);

    +    RETURN_LONG((zend_ulong)provider);

    +}'
  - '--- a/server/vendor/aws/aws-crt-php/ext/crt.c

    +++ b/server/vendor/aws/aws-crt-php/ext/crt.c

    @@ -0,0 +1,314 @@

    +

    +/**

    + * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.

    + * SPDX-License-Identifier: Apache-2.0.

    + */

    +

    +#include "php_aws_crt.h"

    +

    +/* Helpful references for this extension:

    + * zend_parse_parameters and friends -

    + * https://git.php.net/?p=php-src.git;a=blob;f=docs/parameter-parsing-api.md;h=c962fc6ee58cc756aaac9e65759b7d5ea5c18fc4;hb=HEAD

    + * https://git.php.net/?p=php-src.git;a=blob;f=docs/self-contained-extensions.md;h=47f4c636baca8ca195118e2cc234ac7fd2842c1b;hb=HEAD

    + * Threads:

    + * http://blog.jpauli.tech/2017-01-12-threads-and-php-html/

    + * Examples:

    + * Curl extension: https://github.com/php/php-src/blob/PHP-5.6/ext/curl/interface.c

    + * libuv extension: https://github.com/amphp/ext-uv/blob/master/php_uv.c

    + */

    +

    +zval aws_php_invoke_callback(zval *callback, const char *arg_types, ...) {

    +

    +    char *error = NULL;

    +    zend_fcall_info fci = {0};

    +    zend_fcall_info_cache fcc = empty_fcall_info_cache;

    +    if (zend_fcall_info_init(callback, IS_CALLABLE_CHECK_SYNTAX_ONLY, &fci, &fcc,
    NULL, &error) == FAILURE) {

    +        aws_php_throw_exception("Unable to initialize callback from callable
    via zend_fcall_info_init: %s", error);

    +    }

    +

    +    /* Allocate the stack frame of zval arguments and fill them in */

    +    const size_t num_args = strlen(arg_types);

    +    zval *stack = alloca(sizeof(zval) * num_args);

    +    int arg_idx = 0;

    +    va_list va;

    +    va_start(va, arg_types);

    +    while (arg_idx < num_args) {

    +        const char arg_type = arg_types[arg_idx];

    +        switch (arg_type) {

    +            /* zval types */

    +            case ''a'':

    +            case ''A'':

    +            case ''n'':

    +            case ''o'':

    +            case ''r'':

    +            case ''z'': {

    +                zval *zval_val = va_arg(va, zval *);

    +                ZVAL_ZVAL(&stack[arg_idx], zval_val, 0, 0);

    +                break;

    +            }

    +            /* buffers/strings (char *, size_t) */

    +            case ''p'':

    +            case ''s'': {

    +                const char *buf = va_arg(va, const char *);

    +                const size_t len = va_arg(va, size_t);

    +                aws_php_zval_stringl(&stack[arg_idx], buf, len);

    +                break;

    +            }

    +            /* other primitives */

    +            case ''b'': {

    +                zend_bool bool_val = va_arg(va, int);

    +                ZVAL_BOOL(&stack[arg_idx], bool_val);

    +                break;

    +            }

    +            case ''d'': {

    +                double double_val = va_arg(va, double);

    +                ZVAL_DOUBLE(&stack[arg_idx], double_val);

    +                break;

    +            }

    +            case ''l'': {

    +                zend_ulong long_val = va_arg(va, zend_ulong);

    +                ZVAL_LONG(&stack[arg_idx], long_val);

    +                break;

    +            }

    +            /* strings (zend_string), not supported in PHP 5.6, therefore not
    supported */

    +            case ''P'':

    +            case ''S'':

    +            /* unsupported */

    +            case ''C'':

    +            case ''f'':

    +            case ''h'':

    +            case ''H'':

    +            case ''O'':

    +                aws_php_throw_exception("Unsupported argument type to aws_php_invoke_callback:
    %c", arg_type);

    +                break;

    +            default:

    +                aws_php_throw_exception("Unsupported argument type to aws_php_invoke_callback:
    %c", arg_type);

    +                break;

    +        }

    +        ++arg_idx;

    +    }

    +    va_end(va);

    +

    +    /* set up the stack for the call */

    +#if AWS_PHP_AT_LEAST_7

    +    zend_fcall_info_argp(&fci, num_args, stack);

    +#else

    +    /* PHP5.6 may mutate the arguments due to coercion */

    +    zval **arg_ptrs = alloca(sizeof(zval *) * num_args);

    +    zval ***args = alloca(sizeof(zval **) * num_args);

    +    for (int arg_idx = 0; arg_idx < num_args; ++arg_idx) {

    +        arg_ptrs[arg_idx] = &stack[arg_idx];

    +        args[arg_idx] = &arg_ptrs[arg_idx];

    +    }

    +    fci.param_count = num_args;

    +    fci.params = args;

    +#endif

    +

    +    zval retval;

    +    /* PHP5 allocates its own return value, 7+ uses an existing one we provide
    */

    +#if !AWS_PHP_AT_LEAST_7

    +    zval *retval5 = NULL;

    +    fci.retval_ptr_ptr = &retval5;

    +#else

    +    fci.retval = &retval;

    +#endif

    +

    +    if (zend_call_function(&fci, &fcc) == FAILURE) {

    +        aws_php_throw_exception("zend_call_function failed in aws_php_invoke_callback");

    +    }

    +

    +#if !AWS_PHP_AT_LEAST_7

    +    /* initialize the local retval from the retval in retval_ptr_ptr above */

    +    if (retval5) {

    +        ZVAL_ZVAL(&retval, retval5, 1, 1);

    +    }

    +#endif

    +

    +    /* Clean up arguments */

    +#if AWS_PHP_AT_LEAST_7

    +    zend_fcall_info_args_clear(&fci, 1);

    +#endif

    +

    +    return retval;

    +}

    +

    +void aws_php_zval_stringl(zval *val, const char *str, size_t len) {

    +    AWS_FATAL_ASSERT(val != NULL);

    +#if AWS_PHP_AT_LEAST_7

    +    ZVAL_STRINGL(val, str, len);

    +#else

    +    ZVAL_STRINGL(val, str, len, 1);

    +#endif

    +}

    +

    +aws_php_thread_queue s_aws_php_main_thread_queue;

    +

    +bool aws_php_is_main_thread(void) {

    +    return s_aws_php_main_thread_queue.thread_id == aws_thread_current_thread_id();

    +}

    +

    +void aws_php_thread_queue_init(aws_php_thread_queue *queue) {

    +    aws_mutex_init(&queue->mutex);

    +    memset(queue->queue, 0, sizeof(aws_php_task) * AWS_PHP_THREAD_QUEUE_MAX_DEPTH);

    +    queue->write_slot = 0;

    +    queue->thread_id = aws_thread_current_thread_id();

    +}

    +

    +void aws_php_thread_queue_clean_up(aws_php_thread_queue *queue) {

    +    assert(queue->write_slot == 0 && "aws_php_thread_queue cannot be cleaned
    up while queue is not empty");

    +    aws_mutex_clean_up(&queue->mutex);

    +}

    +

    +void aws_php_thread_queue_push(aws_php_thread_queue *queue, aws_php_task task)
    {

    +    aws_mutex_lock(&queue->mutex);

    +    assert(queue->write_slot < AWS_PHP_THREAD_QUEUE_MAX_DEPTH && "thread queue
    is full");

    +    queue->queue[queue->write_slot++] = task;

    +    aws_mutex_unlock(&queue->mutex);

    +}

    +

    +bool aws_php_thread_queue_drain(aws_php_thread_queue *queue) {

    +    assert(

    +        queue->thread_id == aws_thread_current_thread_id() &&

    +        "thread queue cannot be drained from a thread other than its home");

    +    aws_php_task drain_queue[AWS_PHP_THREAD_QUEUE_MAX_DEPTH];

    +    aws_mutex_lock(&queue->mutex);

    +    /* copy any queued tasks into the drain queue, then reset the queue */

    +    memcpy(drain_queue, queue->queue, sizeof(aws_php_task) * AWS_PHP_THREAD_QUEUE_MAX_DEPTH);

    +    memset(queue->queue, 0, sizeof(aws_php_task) * AWS_PHP_THREAD_QUEUE_MAX_DEPTH);

    +    queue->write_slot = 0;

    +    aws_mutex_unlock(&queue->mutex);

    +

    +    bool did_work = false;

    +    for (int idx = 0; idx < AWS_PHP_THREAD_QUEUE_MAX_DEPTH; ++idx) {

    +        aws_php_task *task = &drain_queue[idx];

    +        if (!task->callback) {

    +            break;

    +        }

    +        did_work = true;

    +        task->callback(task->data);

    +        if (task->dtor) {

    +            task->dtor(task->data);

    +        }

    +    }

    +

    +    return did_work;

    +}

    +

    +/* called on main thread after delivery */

    +static void s_thread_queue_complete_promise(void *data) {

    +    struct aws_promise *promise = data;

    +    aws_promise_complete(promise, NULL, NULL);

    +}

    +

    +/* called from worker thread to wait for the main thread to execute any queued
    work in PHP */

    +void aws_php_thread_queue_yield(aws_php_thread_queue *queue) {

    +    /* If on the main thread, then just drain the queue */

    +    if (aws_php_is_main_thread()) {

    +        aws_php_thread_queue_drain(queue);

    +    } else {

    +        /* push a task onto the end of the queue, we will return once this task
    completes our promise */

    +        struct aws_promise *queue_drained = aws_promise_new(aws_crt_default_allocator());

    +        aws_php_task queue_drained_task = {

    +            .callback = s_thread_queue_complete_promise,

    +            .data = queue_drained,

    +        };

    +        aws_php_thread_queue_push(queue, queue_drained_task);

    +        aws_promise_wait(queue_drained);

    +        aws_promise_release(queue_drained);

    +    }

    +}

    +

    +/* called from PHP thread to wait on async queued jobs, one of which should complete
    the promise */

    +void aws_php_thread_queue_wait(aws_php_thread_queue *queue, struct aws_promise
    *promise) {

    +    while (!aws_promise_is_complete(promise)) {

    +        aws_php_thread_queue_drain(queue);

    +    }

    +}

    +

    +ZEND_DECLARE_MODULE_GLOBALS(awscrt);

    +

    +PHP_INI_BEGIN()

    +STD_PHP_INI_ENTRY(

    +    "awscrt.log_level",

    +    "",

    +    PHP_INI_ALL,

    +    OnUpdateLongGEZero,

    +    log_level,

    +    zend_awscrt_globals,

    +    awscrt_globals)

    +PHP_INI_END()

    +

    +static PHP_MINIT_FUNCTION(awscrt) {

    +    REGISTER_INI_ENTRIES();

    +

    +    /* prevent s2n from initializing/de-initializing OpenSSL/libcrypto */

    +    aws_crt_crypto_share();

    +    aws_crt_init();

    +    aws_php_thread_queue_init(&s_aws_php_main_thread_queue);

    +    return SUCCESS;

    +}

    +

    +static PHP_MSHUTDOWN_FUNCTION(awscrt) {

    +    UNREGISTER_INI_ENTRIES();

    +    aws_php_thread_queue_clean_up(&s_aws_php_main_thread_queue);

    +    aws_crt_thread_join_all(0);

    +    aws_crt_clean_up();

    +    return SUCCESS;

    +}

    +

    +static PHP_GINIT_FUNCTION(awscrt) {

    +#if defined(COMPILE_DL_ASTKIT) && defined(ZTS)

    +    ZEND_TSRMLS_CACHE_UPDATE();

    +#endif

    +    awscrt_globals->log_level = 0;

    +}

    +

    +zend_module_entry awscrt_module_entry = {

    +    STANDARD_MODULE_HEADER,

    +    "awscrt",

    +    ext_functions, /* functions */

    +    PHP_MINIT(awscrt),

    +    PHP_MSHUTDOWN(awscrt),

    +    NULL, /* RINIT */

    +    NULL, /* RSHUTDOWN */

    +    NULL, /* MINFO */

    +    NO_VERSION_YET,

    +    PHP_MODULE_GLOBALS(awscrt),

    +    PHP_GINIT(awscrt),

    +    NULL, /* GSHUTDOWN */

    +    NULL, /* RPOSTSHUTDOWN */

    +    STANDARD_MODULE_PROPERTIES_EX,

    +};

    +

    +#ifdef COMPILE_DL_AWSCRT

    +ZEND_GET_MODULE(awscrt)

    +#endif

    +

    +/* aws_crt_last_error() */

    +PHP_FUNCTION(aws_crt_last_error) {

    +    RETURN_LONG(aws_crt_last_error());

    +}

    +

    +/* aws_crt_error_str(int error_code) */

    +PHP_FUNCTION(aws_crt_error_str) {

    +    zend_ulong error_code = 0;

    +    aws_php_parse_parameters("l", &error_code);

    +

    +    XRETURN_STRING(aws_crt_error_str(error_code));

    +}

    +

    +/* aws_crt_error_name(int error_code) */

    +PHP_FUNCTION(aws_crt_error_name) {

    +    zend_ulong error_code = 0;

    +    aws_php_parse_parameters("l", &error_code);

    +

    +    XRETURN_STRING(aws_crt_error_name(error_code));

    +}

    +

    +/* aws_crt_error_debug_str(int error_code) */

    +PHP_FUNCTION(aws_crt_error_debug_str) {

    +    zend_ulong error_code = 0;

    +    aws_php_parse_parameters("l", &error_code);

    +

    +    XRETURN_STRING(aws_crt_error_debug_str(error_code));

    +}'
  - '--- a/server/vendor/aws/aws-crt-php/ext/event_loop.c

    +++ b/server/vendor/aws/aws-crt-php/ext/event_loop.c

    @@ -0,0 +1,48 @@

    +/**

    + * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.

    + * SPDX-License-Identifier: Apache-2.0.

    + */

    +

    +#include "php_aws_crt.h"

    +

    +PHP_FUNCTION(aws_crt_event_loop_group_options_new) {

    +    aws_php_parse_parameters_none();

    +    aws_crt_event_loop_group_options *options = aws_crt_event_loop_group_options_new();

    +    RETURN_LONG((zend_ulong)options);

    +}

    +

    +PHP_FUNCTION(aws_crt_event_loop_group_options_release) {

    +    zend_ulong php_options = 0;

    +    aws_php_parse_parameters("l", &php_options);

    +

    +    aws_crt_event_loop_group_options *options = (void *)php_options;

    +    aws_crt_event_loop_group_options_release(options);

    +}

    +

    +PHP_FUNCTION(aws_crt_event_loop_group_options_set_max_threads) {

    +    zend_ulong php_options = 0;

    +    zend_ulong num_threads = 0;

    +    aws_php_parse_parameters("ll", &php_options, &num_threads);

    +

    +    aws_crt_event_loop_group_options *options = (void *)php_options;

    +    aws_crt_event_loop_group_options_set_max_threads(options, num_threads);

    +}

    +

    +PHP_FUNCTION(aws_crt_event_loop_group_new) {

    +    zend_ulong php_options = 0;

    +

    +    aws_php_parse_parameters("l", &php_options);

    +

    +    aws_crt_event_loop_group_options *options = (void *)php_options;

    +    aws_crt_event_loop_group *elg = aws_crt_event_loop_group_new(options);

    +    RETURN_LONG((zend_ulong)elg);

    +}

    +

    +PHP_FUNCTION(aws_crt_event_loop_group_release) {

    +    zend_ulong php_elg = 0;

    +

    +    aws_php_parse_parameters("l", &php_elg);

    +

    +    aws_crt_event_loop_group *elg = (void *)php_elg;

    +    aws_crt_event_loop_group_release(elg);

    +}'
  - '--- a/server/vendor/aws/aws-crt-php/ext/http.c

    +++ b/server/vendor/aws/aws-crt-php/ext/http.c

    @@ -0,0 +1,36 @@

    +/**

    + * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.

    + * SPDX-License-Identifier: Apache-2.0.

    + */

    +

    +#include "php_aws_crt.h"

    +

    +PHP_FUNCTION(aws_crt_http_message_new_from_blob) {

    +    const char *blob = NULL;

    +    size_t blob_len = 0;

    +

    +    aws_php_parse_parameters("s", &blob, &blob_len);

    +

    +    aws_crt_http_message *message = aws_crt_http_message_new_from_blob((uint8_t
    *)blob, blob_len);

    +    RETURN_LONG((zend_ulong)message);

    +}

    +

    +PHP_FUNCTION(aws_crt_http_message_to_blob) {

    +    zend_ulong php_msg = 0;

    +

    +    aws_php_parse_parameters("l", &php_msg);

    +

    +    aws_crt_http_message *message = (void *)php_msg;

    +    aws_crt_buf blob;

    +    aws_crt_http_message_to_blob(message, &blob);

    +    XRETURN_STRINGL((const char *)blob.blob, blob.length);

    +}

    +

    +PHP_FUNCTION(aws_crt_http_message_release) {

    +    zend_ulong php_msg = 0;

    +

    +    aws_php_parse_parameters("l", &php_msg);

    +

    +    aws_crt_http_message *message = (void *)php_msg;

    +    aws_crt_http_message_release(message);

    +}'
  - '--- a/server/vendor/aws/aws-crt-php/ext/logging.c

    +++ b/server/vendor/aws/aws-crt-php/ext/logging.c

    @@ -0,0 +1,65 @@

    +/**

    + * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.

    + * SPDX-License-Identifier: Apache-2.0.

    + */

    +

    +#include "php_aws_crt.h"

    +

    +PHP_FUNCTION(aws_crt_log_to_stdout) {

    +    aws_php_parse_parameters_none();

    +    aws_crt_log_to_stdout();

    +}

    +

    +PHP_FUNCTION(aws_crt_log_to_stderr) {

    +    aws_php_parse_parameters_none();

    +    aws_crt_log_to_stderr();

    +}

    +

    +PHP_FUNCTION(aws_crt_log_to_file) {

    +    const char *filename = NULL;

    +    size_t filename_len = 0;

    +    /* read the filename as a path, which guarantees no NUL bytes */

    +    aws_php_parse_parameters("p", &filename, &filename_len);

    +    aws_crt_log_to_file(filename);

    +}

    +

    +static void php_crt_log(const char *message, size_t len, void *user_data) {

    +    php_stream *stream = user_data;

    +    php_stream_write(stream, message, len);

    +    php_stream_flush(stream);

    +}

    +

    +PHP_FUNCTION(aws_crt_log_to_stream) {

    +    zval *php_log_stream = NULL;

    +    aws_php_parse_parameters("r", &php_log_stream);

    +

    +    if (php_log_stream) {

    +        php_stream *stream = NULL;

    +        Z_ADDREF(*php_log_stream);

    +        AWS_PHP_STREAM_FROM_ZVAL(stream, php_log_stream);

    +        aws_crt_log_to_callback((aws_crt_log_callback *)php_crt_log, stream);

    +    } else {

    +        aws_crt_log_to_callback(NULL, NULL);

    +    }

    +}

    +

    +PHP_FUNCTION(aws_crt_log_set_level) {

    +    zend_ulong log_level = 0;

    +    aws_php_parse_parameters("l", &log_level);

    +    aws_crt_log_set_level((aws_crt_log_level)log_level);

    +}

    +

    +PHP_FUNCTION(aws_crt_log_stop) {

    +    aws_php_parse_parameters_none();

    +    aws_crt_log_stop();

    +}

    +

    +PHP_FUNCTION(aws_crt_log_message) {

    +    zend_ulong log_level = 0;

    +    const char *message = NULL;

    +    size_t message_len = 0;

    +

    +    aws_php_parse_parameters("ls", &log_level, &message, &message_len);

    +

    +    aws_crt_log_message((aws_crt_log_level)log_level, (const uint8_t *)message,
    message_len);

    +}'
  - '--- a/server/vendor/aws/aws-crt-php/ext/php_util.c

    +++ b/server/vendor/aws/aws-crt-php/ext/php_util.c

    @@ -0,0 +1,33 @@

    +

    +/**

    + * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.

    + * SPDX-License-Identifier: Apache-2.0.

    + */

    +

    +#include "php_aws_crt.h"

    +

    +zval *aws_php_zval_new(void) {

    +    return emalloc(sizeof(zval));

    +}

    +

    +void aws_php_zval_dtor(void *zval_ptr) {

    +    zval *z = zval_ptr;

    +    zval_dtor(z);

    +    efree(z);

    +}

    +

    +bool aws_php_zval_as_bool(zval *z) {

    +#if AWS_PHP_AT_LEAST_7

    +    return (Z_TYPE_P(z) == IS_TRUE);

    +#else

    +    return (Z_TYPE_P(z) == IS_BOOL && Z_LVAL_P(z) != 0);

    +#endif

    +}

    +

    +void aws_php_zval_copy(zval *dest, zval *src) {

    +#if AWS_PHP_AT_LEAST_7

    +    ZVAL_COPY(dest, src);

    +#else

    +    ZVAL_COPY_VALUE(dest, src);

    +#endif

    +}'
  - '--- a/server/vendor/aws/aws-crt-php/ext/signing.c

    +++ b/server/vendor/aws/aws-crt-php/ext/signing.c

    @@ -0,0 +1,374 @@

    +/**

    + * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.

    + * SPDX-License-Identifier: Apache-2.0.

    + */

    +

    +#include "php_aws_crt.h"

    +

    +PHP_FUNCTION(aws_crt_signing_config_aws_new) {

    +    if (zend_parse_parameters_none() == FAILURE) {

    +        RETURN_NULL();

    +    }

    +

    +    aws_crt_signing_config_aws *signing_config = aws_crt_signing_config_aws_new();

    +    RETURN_LONG((zend_ulong)signing_config);

    +}

    +

    +PHP_FUNCTION(aws_crt_signing_config_aws_release) {

    +    zend_ulong php_signing_config = 0;

    +

    +    aws_php_parse_parameters("l", &php_signing_config);

    +

    +    aws_crt_signing_config_aws *signing_config = (void *)php_signing_config;

    +    aws_crt_signing_config_aws_release(signing_config);

    +}

    +

    +PHP_FUNCTION(aws_crt_signing_config_aws_set_algorithm) {

    +    zend_ulong php_signing_config = 0;

    +    zend_ulong php_algorithm = 0;

    +

    +    aws_php_parse_parameters("ll", &php_signing_config, &php_algorithm);

    +

    +    aws_crt_signing_config_aws *signing_config = (void *)php_signing_config;

    +    aws_crt_signing_algorithm algorithm = php_algorithm;

    +    aws_crt_signing_config_aws_set_algorithm(signing_config, algorithm);

    +}

    +

    +PHP_FUNCTION(aws_crt_signing_config_aws_set_signature_type) {

    +    zend_ulong php_signing_config = 0;

    +    zend_ulong php_signature_type = 0;

    +

    +    aws_php_parse_parameters("ll", &php_signing_config, &php_signature_type);

    +

    +    aws_crt_signing_config_aws *signing_config = (void *)php_signing_config;

    +    aws_crt_signature_type signature_type = php_signature_type;

    +    aws_crt_signing_config_aws_set_signature_type(signing_config, signature_type);

    +}

    +

    +PHP_FUNCTION(aws_crt_signing_config_aws_set_credentials_provider) {

    +    zend_ulong php_signing_config = 0;

    +    zend_ulong php_credentials_provider = 0;

    +

    +    aws_php_parse_parameters("ll", &php_signing_config, &php_credentials_provider);

    +

    +    aws_crt_signing_config_aws *signing_config = (void *)php_signing_config;

    +    aws_crt_credentials_provider *credentials_provider = (void *)php_credentials_provider;

    +    aws_crt_signing_config_aws_set_credentials_provider(signing_config, credentials_provider);

    +}

    +

    +PHP_FUNCTION(aws_crt_signing_config_aws_set_region) {

    +    zend_ulong php_signing_config = 0;

    +    const char *region = NULL;

    +    size_t region_len = 0;

    +

    +    aws_php_parse_parameters("ls", &php_signing_config, &region, &region_len);

    +

    +    aws_crt_signing_config_aws *signing_config = (void *)php_signing_config;

    +    aws_crt_signing_config_aws_set_region(signing_config, (uint8_t *)region,
    region_len);

    +}

    +

    +PHP_FUNCTION(aws_crt_signing_config_aws_set_service) {

    +    zend_ulong php_signing_config = 0;

    +    const char *service = NULL;

    +    size_t service_len = 0;

    +

    +    aws_php_parse_parameters("ls", &php_signing_config, &service, &service_len);

    +

    +    aws_crt_signing_config_aws *signing_config = (void *)php_signing_config;

    +    aws_crt_signing_config_aws_set_service(signing_config, (uint8_t *)service,
    service_len);

    +}

    +

    +PHP_FUNCTION(aws_crt_signing_config_aws_set_use_double_uri_encode) {

    +    zend_ulong php_signing_config = 0;

    +    zend_bool php_use_double_uri_encode = 0;

    +

    +    aws_php_parse_parameters("lb", &php_signing_config, &php_use_double_uri_encode);

    +

    +    aws_crt_signing_config_aws *signing_config = (void *)php_signing_config;

    +    aws_crt_signing_config_aws_set_use_double_uri_encode(signing_config, php_use_double_uri_encode);

    +}

    +

    +PHP_FUNCTION(aws_crt_signing_config_aws_set_should_normalize_uri_path) {

    +    zend_ulong php_signing_config = 0;

    +    zend_bool php_should_normalize_uri_path = 0;

    +

    +    aws_php_parse_parameters("lb", &php_signing_config, &php_should_normalize_uri_path);

    +

    +    aws_crt_signing_config_aws *signing_config = (void *)php_signing_config;

    +    aws_crt_signing_config_aws_set_should_normalize_uri_path(signing_config,
    php_should_normalize_uri_path);

    +}

    +

    +PHP_FUNCTION(aws_crt_signing_config_aws_set_omit_session_token) {

    +    zend_ulong php_signing_config = 0;

    +    zend_bool php_omit_session_token = 0;

    +

    +    aws_php_parse_parameters("lb", &php_signing_config, &php_omit_session_token);

    +

    +    aws_crt_signing_config_aws *signing_config = (void *)php_signing_config;

    +    aws_crt_signing_config_aws_set_omit_session_token(signing_config, php_omit_session_token);

    +}

    +

    +PHP_FUNCTION(aws_crt_signing_config_aws_set_signed_body_value) {

    +    zend_ulong php_signing_config = 0;

    +    const char *signed_body_value = NULL;

    +    size_t signed_body_value_len = 0;

    +

    +    aws_php_parse_parameters("ls", &php_signing_config, &signed_body_value, &signed_body_value_len);

    +

    +    aws_crt_signing_config_aws *signing_config = (void *)php_signing_config;

    +    aws_crt_signing_config_aws_set_signed_body_value(

    +        signing_config, (uint8_t *)signed_body_value, signed_body_value_len);

    +}

    +

    +PHP_FUNCTION(aws_crt_signing_config_aws_set_signed_body_header_type) {

    +    zend_ulong php_signing_config = 0;

    +    zend_ulong php_signed_body_header_type = 0;

    +

    +    aws_php_parse_parameters("ll", &php_signing_config, &php_signed_body_header_type);

    +

    +    aws_crt_signing_config_aws *signing_config = (void *)php_signing_config;

    +    aws_crt_signed_body_header_type signed_body_header_type = php_signed_body_header_type;

    +    aws_crt_signing_config_aws_set_signed_body_header_type(signing_config, signed_body_header_type);

    +}

    +

    +PHP_FUNCTION(aws_crt_signing_config_aws_set_expiration_in_seconds) {

    +    zend_ulong php_signing_config = 0;

    +    zend_ulong php_expiration_in_seconds = 0;

    +

    +    aws_php_parse_parameters("ll", &php_signing_config, &php_expiration_in_seconds);

    +

    +    aws_crt_signing_config_aws *signing_config = (void *)php_signing_config;

    +    aws_crt_signing_config_aws_set_expiration_in_seconds(signing_config, php_expiration_in_seconds);

    +}

    +

    +PHP_FUNCTION(aws_crt_signing_config_aws_set_date) {

    +    zend_ulong php_signing_config = 0;

    +    zend_ulong php_timestamp = 0;

    +

    +    aws_php_parse_parameters("ll", &php_signing_config, &php_timestamp);

    +

    +    aws_crt_signing_config_aws *signing_config = (void *)php_signing_config;

    +    aws_crt_signing_config_aws_set_date(signing_config, php_timestamp);

    +}

    +

    +typedef struct _should_sign_header_data {

    +    zval *should_sign_header;

    +    zval *header_name;

    +    bool result;

    +} should_sign_header_data;

    +

    +static void should_sign_header_task(void *data) {

    +    should_sign_header_data *task = data;

    +    zval result = aws_php_invoke_callback(task->should_sign_header, "z", task->header_name);

    +    task->result = aws_php_zval_as_bool(&result);

    +    zval_dtor(&result);

    +}

    +

    +static bool aws_php_should_sign_header(const char *header_name, size_t header_length,
    void *user_data) {

    +    zval php_header_name;

    +    aws_php_zval_stringl(&php_header_name, header_name, header_length);

    +

    +    should_sign_header_data task_data = {

    +        .should_sign_header = user_data,

    +        .header_name = &php_header_name,

    +        .result = false,

    +    };

    +

    +    aws_php_task task = {

    +        .callback = should_sign_header_task,

    +        .data = &task_data,

    +    };

    +

    +    aws_php_thread_queue_push(&s_aws_php_main_thread_queue, task);

    +    aws_php_thread_queue_yield(&s_aws_php_main_thread_queue);

    +

    +    zval_dtor(&php_header_name);

    +

    +    return task_data.result;

    +}

    +

    +PHP_FUNCTION(aws_crt_signing_config_aws_set_should_sign_header_fn) {

    +    zend_ulong php_signing_config = 0;

    +    zval *php_should_sign_header = NULL;

    +

    +    aws_php_parse_parameters("lz", &php_signing_config, &php_should_sign_header);

    +

    +    aws_crt_signing_config_aws *signing_config = (void *)php_signing_config;

    +

    +    /* copy/retain PHP callback, add as user data for signing_config resource
    */

    +    zval *should_sign_header = aws_php_zval_new();

    +    aws_php_zval_copy(should_sign_header, php_should_sign_header);

    +    aws_crt_resource_set_user_data(signing_config, should_sign_header, aws_php_zval_dtor);

    +

    +    aws_crt_signing_config_aws_set_should_sign_header_fn(

    +        signing_config, aws_php_should_sign_header, should_sign_header);

    +}

    +

    +PHP_FUNCTION(aws_crt_signable_new_from_http_request) {

    +    zend_ulong php_http_message = 0;

    +

    +    aws_php_parse_parameters("l", &php_http_message);

    +

    +    const aws_crt_http_message *http_message = (void *)php_http_message;

    +    aws_crt_signable *signable = aws_crt_signable_new_from_http_request(http_message);

    +    RETURN_LONG((zend_ulong)signable);

    +}

    +

    +PHP_FUNCTION(aws_crt_signable_new_from_chunk) {

    +    zend_ulong php_input_stream = 0;

    +    const char *previous_signature = NULL;

    +    size_t previous_signature_len = 0;

    +

    +    aws_php_parse_parameters("ls", &php_input_stream, &previous_signature, &previous_signature_len);

    +

    +    aws_crt_input_stream *input_stream = (void *)php_input_stream;

    +    aws_crt_signable *signable =

    +        aws_crt_signable_new_from_chunk(input_stream, (uint8_t *)previous_signature,
    previous_signature_len);

    +    RETURN_LONG((zend_ulong)signable);

    +}

    +

    +PHP_FUNCTION(aws_crt_signable_new_from_canonical_request) {

    +    const char *canonical_request = NULL;

    +    size_t canonical_request_len = 0;

    +

    +    aws_crt_signable *signable =

    +        aws_crt_signable_new_from_canonical_request((uint8_t *)canonical_request,
    canonical_request_len);

    +    RETURN_LONG((zend_ulong)signable);

    +}

    +

    +PHP_FUNCTION(aws_crt_signable_release) {

    +    zend_ulong php_signable = 0;

    +

    +    aws_php_parse_parameters("l", &php_signable);

    +

    +    aws_crt_signable *signable = (void *)php_signable;

    +    aws_crt_signable_release(signable);

    +}

    +

    +PHP_FUNCTION(aws_crt_signing_result_release) {

    +    zend_ulong php_signing_result = 0;

    +

    +    aws_php_parse_parameters("l", &php_signing_result);

    +    aws_crt_signing_result *result = (void *)php_signing_result;

    +    aws_crt_signing_result_release(result);

    +}

    +

    +PHP_FUNCTION(aws_crt_signing_result_apply_to_http_request) {

    +    zend_ulong php_signing_result = 0;

    +    zend_ulong php_http_request = 0;

    +

    +    aws_php_parse_parameters("ll", &php_signing_result, &php_http_request);

    +    aws_crt_signing_result *result = (void *)php_signing_result;

    +    aws_crt_http_message *request = (void *)php_http_request;

    +

    +    if (aws_crt_signing_result_apply_to_http_request(result, request)) {

    +        aws_php_throw_exception(

    +            "Failed to apply signing result to HTTP request: %s", aws_crt_error_name(aws_crt_last_error()));

    +    }

    +}

    +

    +typedef struct _signing_state {

    +    struct aws_promise *promise;

    +    zval *on_complete;

    +    aws_crt_signing_result *signing_result;

    +    int error_code;

    +} signing_state;

    +

    +/* called on main thread to deliver result to php */

    +static void s_sign_aws_complete(void *data) {

    +    signing_state *state = data;

    +    zval *on_complete = state->on_complete;

    +    aws_php_invoke_callback(on_complete, "ll", (zend_ulong)state->signing_result,
    (zend_ulong)state->error_code);

    +}

    +

    +/* called from signing process in aws_sign_request_aws */

    +static void s_on_sign_request_aws_complete(aws_crt_signing_result *result, int
    error_code, void *user_data) {

    +    signing_state *state = user_data;

    +    struct aws_promise *promise = state->promise;

    +

    +    state->signing_result = result;

    +    state->error_code = error_code;

    +

    +    /*

    +     * Must execute PHP callback before this function returns, or signing_result
    will be killed

    +     * so the callback is queued back to the main thread and will have run when
    yield returns

    +     */

    +    aws_php_task complete_callback_task = {

    +        .callback = s_sign_aws_complete,

    +        .data = state,

    +    };

    +    aws_php_thread_queue_push(&s_aws_php_main_thread_queue, complete_callback_task);

    +    aws_php_thread_queue_yield(&s_aws_php_main_thread_queue);

    +

    +    if (error_code) {

    +        aws_promise_fail(promise, error_code);

    +    } else {

    +        aws_promise_complete(promise, result, NULL);

    +    }

    +}

    +

    +PHP_FUNCTION(aws_crt_sign_request_aws) {

    +    zend_ulong php_signable = 0;

    +    zend_ulong php_signing_config = 0;

    +    zval *php_on_complete = 0;

    +    zend_ulong php_user_data = 0;

    +

    +    aws_php_parse_parameters("llzl", &php_signable, &php_signing_config, &php_on_complete,
    &php_user_data);

    +

    +    aws_crt_signable *signable = (void *)php_signable;

    +    aws_crt_signing_config_aws *signing_config = (void *)php_signing_config;

    +

    +    struct aws_promise *promise = aws_promise_new(aws_crt_default_allocator());

    +    signing_state state = {

    +        .promise = promise,

    +        .on_complete = php_on_complete,

    +    };

    +    int ret = aws_crt_sign_request_aws(signable, signing_config, s_on_sign_request_aws_complete,
    &state);

    +    if (ret != 0) {

    +        int last_error = aws_crt_last_error();

    +        aws_promise_fail(promise, last_error);

    +        aws_php_throw_exception(

    +            "aws_crt_sign_request_aws: error starting signing process: %s", aws_crt_error_name(last_error));

    +    }

    +

    +    aws_php_thread_queue_wait(&s_aws_php_main_thread_queue, promise);

    +

    +done:

    +    aws_promise_release(promise);

    +    RETURN_LONG(ret);

    +}

    +

    +PHP_FUNCTION(aws_crt_test_verify_sigv4a_signing) {

    +    zend_ulong php_signable = 0;

    +    zend_ulong php_signing_config = 0;

    +    const char *expected_canonical_request = NULL;

    +    size_t expected_canonical_request_len = 0;

    +    const char *signature = NULL;

    +    size_t signature_len = 0;

    +    const char *ecc_key_pub_x = NULL;

    +    size_t ecc_key_pub_x_len = 0;

    +    const char *ecc_key_pub_y = NULL;

    +    size_t ecc_key_pub_y_len = 0;

    +

    +    aws_php_parse_parameters(

    +        "llssss",

    +        &php_signable,

    +        &php_signing_config,

    +        &expected_canonical_request,

    +        &expected_canonical_request_len,

    +        &signature,

    +        &signature_len,

    +        &ecc_key_pub_x,

    +        &ecc_key_pub_x_len,

    +        &ecc_key_pub_y,

    +        &ecc_key_pub_y_len);

    +

    +    const aws_crt_signable *signable = (void *)php_signable;

    +    const aws_crt_signing_config *signing_config = (void *)php_signing_config;

    +

    +    bool result = AWS_OP_SUCCESS ==

    +                  aws_crt_test_verify_sigv4a_signing(

    +                      signable, signing_config, expected_canonical_request, signature,
    ecc_key_pub_x, ecc_key_pub_y);

    +

    +    RETURN_BOOL(result);

    +}'
  - '--- a/server/vendor/aws/aws-crt-php/ext/stream.c

    +++ b/server/vendor/aws/aws-crt-php/ext/stream.c

    @@ -0,0 +1,148 @@

    +/**

    + * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.

    + * SPDX-License-Identifier: Apache-2.0.

    + */

    +

    +#include "php_aws_crt.h"

    +

    +/* PHP streams info:

    + * https://git.php.net/?p=php-src.git;a=blob;f=docs/streams.md;h=0ec3846d68bf70067297d8a6c691d2591c49b48a;hb=HEAD

    + * https://github.com/php/php-src/blob/PHP-5.6.0/main/php_streams.h

    + */

    +

    +PHP_FUNCTION(aws_crt_input_stream_options_new) {

    +    if (zend_parse_parameters_none() == FAILURE) {

    +        aws_php_argparse_fail();

    +    }

    +

    +    aws_crt_input_stream_options *options = aws_crt_input_stream_options_new();

    +    RETURN_LONG((zend_ulong)options);

    +}

    +

    +PHP_FUNCTION(aws_crt_input_stream_options_release) {

    +    zend_ulong php_options = 0;

    +

    +    aws_php_parse_parameters("l", &php_options);

    +

    +    aws_crt_input_stream_options *options = (void *)php_options;

    +    aws_crt_input_stream_options_release(options);

    +}

    +

    +PHP_FUNCTION(aws_crt_input_stream_options_set_user_data) {

    +    zend_ulong php_options = 0;

    +    zval *user_data = NULL;

    +

    +    aws_php_parse_parameters("lz", &php_options, &user_data);

    +

    +    aws_crt_input_stream_options *options = (void *)php_options;

    +    php_stream *stream = NULL;

    +    AWS_PHP_STREAM_FROM_ZVAL(stream, user_data);

    +    aws_crt_input_stream_options_set_user_data(options, stream);

    +}

    +

    +static int s_php_stream_seek(void *user_data, int64_t offset, aws_crt_input_stream_seek_basis
    basis) {

    +    php_stream *stream = user_data;

    +    return php_stream_seek(stream, offset, basis);

    +}

    +

    +static int s_php_stream_read(void *user_data, uint8_t *dest, size_t dest_length)
    {

    +    php_stream *stream = user_data;

    +    return php_stream_read(stream, (char *)dest, dest_length) != 0;

    +}

    +

    +static int s_php_stream_get_length(void *user_data, int64_t *out_length) {

    +    php_stream *stream = user_data;

    +    size_t pos = php_stream_tell(stream);

    +    php_stream_seek(stream, 0, SEEK_END);

    +    *out_length = php_stream_tell(stream);

    +    php_stream_seek(stream, pos, SEEK_SET);

    +    return 0;

    +}

    +

    +static int s_php_stream_get_status(void *user_data, aws_crt_input_stream_status
    *out_status) {

    +    php_stream *stream = user_data;

    +    out_status->is_valid = stream != NULL;

    +    /* We would like to use php_stream_eof here, but certain streams (notably
    php://memory)

    +     * are not actually capable of EOF, so we get to do it the hard way */

    +    int64_t length = 0;

    +    int64_t pos = 0;

    +    s_php_stream_get_length(stream, &length);

    +    pos = php_stream_tell(stream);

    +    out_status->is_end_of_stream = pos == length;

    +    return 0;

    +}

    +

    +static void s_php_stream_destroy(void *user_data) {

    +    (void)user_data;

    +    /* no op, stream will be freed by PHP refcount dropping from InputStream::stream
    */

    +}

    +

    +PHP_FUNCTION(aws_crt_input_stream_new) {

    +    zend_ulong php_options = 0;

    +

    +    aws_php_parse_parameters("l", &php_options);

    +

    +    aws_crt_input_stream_options *options = (void *)php_options;

    +    aws_crt_input_stream_options_set_seek(options, s_php_stream_seek);

    +    aws_crt_input_stream_options_set_read(options, s_php_stream_read);

    +    aws_crt_input_stream_options_set_get_status(options, s_php_stream_get_status);

    +    aws_crt_input_stream_options_set_get_length(options, s_php_stream_get_length);

    +    aws_crt_input_stream_options_set_destroy(options, s_php_stream_destroy);

    +    aws_crt_input_stream *stream = aws_crt_input_stream_new(options);

    +    RETURN_LONG((zend_ulong)stream);

    +}

    +

    +PHP_FUNCTION(aws_crt_input_stream_release) {

    +    zend_ulong php_stream = 0;

    +

    +    aws_php_parse_parameters("l", &php_stream);

    +

    +    aws_crt_input_stream *stream = (void *)php_stream;

    +    aws_crt_input_stream_release(stream);

    +}

    +

    +PHP_FUNCTION(aws_crt_input_stream_seek) {

    +    zend_ulong php_stream = 0;

    +    zend_ulong offset = 0;

    +    zend_ulong basis = 0;

    +

    +    aws_php_parse_parameters("lll", &php_stream, &offset, &basis);

    +

    +    aws_crt_input_stream *stream = (void *)php_stream;

    +    RETURN_LONG(aws_crt_input_stream_seek(stream, offset, basis));

    +}

    +

    +PHP_FUNCTION(aws_crt_input_stream_read) {

    +    zend_ulong php_stream = 0;

    +    zend_ulong length = 0;

    +

    +    aws_php_parse_parameters("ll", &php_stream, &length);

    +

    +    aws_crt_input_stream *stream = (void *)php_stream;

    +    uint8_t *buf = emalloc(length);

    +    int ret = aws_crt_input_stream_read(stream, buf, length);

    +    XRETVAL_STRINGL((const char *)buf, length);

    +    efree(buf);

    +}

    +

    +PHP_FUNCTION(aws_crt_input_stream_eof) {

    +    zend_ulong php_stream = 0;

    +

    +    aws_php_parse_parameters("l", &php_stream);

    +

    +    aws_crt_input_stream *stream = (void *)php_stream;

    +    aws_crt_input_stream_status status = {0};

    +    aws_crt_input_stream_get_status(stream, &status);

    +    RETURN_BOOL(status.is_end_of_stream);

    +}

    +

    +PHP_FUNCTION(aws_crt_input_stream_get_length) {

    +    zend_ulong php_stream = 0;

    +

    +    aws_php_parse_parameters("l", &php_stream);

    +

    +    aws_crt_input_stream *stream = (void *)php_stream;

    +    int64_t length = 0;

    +    aws_crt_input_stream_get_length(stream, &length);

    +    RETURN_LONG(length);

    +}'
  identifiers:
  - CVE-2022-0079
  - CWE-209
  overview: showdoc is vulnerable to Generation of Error Message Containing Sensitive
    Information
  references:
  - source: security@huntr.dev
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/star7th/showdoc/commit/e43df0a190f68aefa272507d3bd54475f566c1db
  - source: security@huntr.dev
    tags:
    - Exploit
    - Issue Tracking
    - Patch
    - Third Party Advisory
    url: https://huntr.dev/bounties/b37f0e26-355a-4d50-8495-a567c10828ee
  title: showdoc is vulnerable to Generation of Error Message Containing Sensitive
    Information
- diff_content:
  - "--- a/pjmedia/src/pjmedia-codec/and_aud_mediacodec.cpp\n+++ b/pjmedia/src/pjmedia-codec/and_aud_mediacodec.cpp\n\
    @@ -754,6 +754,7 @@ static pj_status_t and_media_alloc_codec(pjmedia_codec_factory\
    \ *factory,\n     }\n     if (idx == -1) {\n \t*p_codec = NULL;\n+\tpj_mutex_unlock(and_media_factory.mutex);\n\
    \ \treturn PJMEDIA_CODEC_EFAILED;\n     }\n "
  - "--- a/pjmedia/src/pjmedia-codec/ipp_codecs.c\n+++ b/pjmedia/src/pjmedia-codec/ipp_codecs.c\n\
    @@ -939,6 +939,7 @@ static pj_status_t ipp_alloc_codec( pjmedia_codec_factory\
    \ *factory,\n     }\n     if (idx == -1) {\n \t*p_codec = NULL;\n+\tpj_mutex_unlock(ipp_factory.mutex);\n\
    \ \treturn PJMEDIA_CODEC_EFAILED;\n     }\n "
  - "--- a/pjmedia/src/pjmedia-codec/opus.c\n+++ b/pjmedia/src/pjmedia-codec/opus.c\n\
    @@ -723,6 +723,7 @@ static pj_status_t  codec_open( pjmedia_codec *codec,\n \t\
    \t\t    OPUS_APPLICATION_VOIP);\n     if (err != OPUS_OK) {\n \tPJ_LOG(2, (THIS_FILE,\
    \ \"Unable to create encoder\"));\n+\tpj_mutex_unlock (opus_data->mutex);\n \t\
    return PJMEDIA_CODEC_EFAILED;\n     }\n     \n@@ -767,6 +768,7 @@ static pj_status_t\
    \  codec_open( pjmedia_codec *codec,\n \t\t\t     attr->info.channel_cnt);\n \
    \    if (err != OPUS_OK) {\n \tPJ_LOG(2, (THIS_FILE, \"Unable to initialize decoder\"\
    ));\n+\tpj_mutex_unlock (opus_data->mutex);\n \treturn PJMEDIA_CODEC_EFAILED;\n\
    \     }\n "
  - "--- a/pjmedia/src/pjmedia-codec/passthrough.c\n+++ b/pjmedia/src/pjmedia-codec/passthrough.c\n\
    @@ -625,6 +625,7 @@ static pj_status_t alloc_codec( pjmedia_codec_factory *factory,\n\
    \     }\n     if (idx == -1) {\n \t*p_codec = NULL;\n+\tpj_mutex_unlock(codec_factory.mutex);\n\
    \ \treturn PJMEDIA_CODEC_EUNSUP;\n     }\n "
  - "--- a/pjmedia/src/pjmedia-codec/speex_codec.c\n+++ b/pjmedia/src/pjmedia-codec/speex_codec.c\n\
    @@ -379,6 +379,7 @@ PJ_DEF(pj_status_t) pjmedia_codec_speex_deinit(void)\n   \
    \  if (!codec_mgr) {\n \tpj_pool_release(spx_factory.pool);\n \tspx_factory.pool\
    \ = NULL;\n+\tpj_mutex_unlock(spx_factory.mutex);\n \treturn PJ_EINVALIDOP;\n\
    \     }\n "
  - "--- a/pjmedia/src/pjmedia/vid_conf.c\n+++ b/pjmedia/src/pjmedia/vid_conf.c\n\
    @@ -304,6 +304,7 @@ PJ_DEF(pj_status_t) pjmedia_vid_conf_add_port( pjmedia_vid_conf\
    \ *vid_conf,\n \t    PJ_LOG(4,(THIS_FILE, \"pjmedia_vid_conf_add_port(): \"\n\
    \ \t\t\t\t \"unrecognized format %04X\",\n \t\t\t\t port->info.fmt.id));\n+\t\
    \    pj_mutex_unlock(vid_conf->mutex);\n \t    return PJMEDIA_EBADFMT;\n \t}\n\
    \ \n@@ -314,6 +315,7 @@ PJ_DEF(pj_status_t) pjmedia_vid_conf_add_port( pjmedia_vid_conf\
    \ *vid_conf,\n \t    PJ_LOG(4,(THIS_FILE, \"pjmedia_vid_conf_add_port(): \"\n\
    \ \t\t\t\t \"Failed to apply format %04X\",\n \t\t\t\t port->info.fmt.id));\n\
    +\t    pj_mutex_unlock(vid_conf->mutex);\n \t    return status;\n \t}\n \tif (port->put_frame)\
    \ {\n@@ -331,28 +333,41 @@ PJ_DEF(pj_status_t) pjmedia_vid_conf_add_port( pjmedia_vid_conf\
    \ *vid_conf,\n \t\t\t    pj_pool_zalloc(pool,\n \t\t\t\t\t   vid_conf->opt.max_slot_cnt\
    \ *\n \t\t\t\t\t   sizeof(unsigned));\n-    PJ_ASSERT_RETURN(cport->listener_slots,\
    \ PJ_ENOMEM);\n+    if (!cport->listener_slots) {\t\n+\tpj_mutex_unlock(vid_conf->mutex);\n\
    +\treturn PJ_ENOMEM;\n+    }\n \n     /* Create transmitter array */\n     cport->transmitter_slots\
    \ = (unsigned*)\n \t\t\t       pj_pool_zalloc(pool,\n \t\t\t\t\t      vid_conf->opt.max_slot_cnt\
    \ *\n-\t\t\t\t\t      sizeof(unsigned));\n-    PJ_ASSERT_RETURN(cport->transmitter_slots,\
    \ PJ_ENOMEM);\n+\t\t\t\t\t      sizeof(unsigned));    \n+    if (!cport->transmitter_slots)\
    \ {\n+\tpj_mutex_unlock(vid_conf->mutex);\n+\treturn PJ_ENOMEM;\n+    }\n \n \
    \    /* Create pointer-to-render_state array */\n     cport->render_states = (render_state**)\n\
    \ \t\t\t   pj_pool_zalloc(pool,\n \t\t\t\t\t  vid_conf->opt.max_slot_cnt *\n \t\
    \t\t\t\t  sizeof(render_state*));\n-    PJ_ASSERT_RETURN(cport->render_states,\
    \ PJ_ENOMEM);\n+\n+    if (!cport->render_states) {\n+\tpj_mutex_unlock(vid_conf->mutex);\n\
    +\treturn PJ_ENOMEM;\n+    }\n \n     /* Create pointer-to-render-pool array */\n\
    \     cport->render_pool = (pj_pool_t**)\n \t\t\t pj_pool_zalloc(pool,\n \t\t\t\
    \t\tvid_conf->opt.max_slot_cnt *\n-\t\t\t\t\tsizeof(pj_pool_t*));\n-    PJ_ASSERT_RETURN(cport->render_pool,\
    \ PJ_ENOMEM);\n+\t\t\t\t\tsizeof(pj_pool_t*));    \n+    if (!cport->render_pool)\
    \ {\n+\tpj_mutex_unlock(vid_conf->mutex);\n+\treturn PJ_ENOMEM;\n+    }\n \n \
    \    /* Register the conf port. */\n     vid_conf->ports[index] = cport;\n@@ -420,6\
    \ +435,7 @@ PJ_DEF(pj_status_t) pjmedia_vid_conf_remove_port( pjmedia_vid_conf\
    \ *vid_conf,\n \tstatus = pjmedia_clock_stop(vid_conf->clock);\n \tif (status\
    \ != PJ_SUCCESS) {\n \t    PJ_PERROR(4, (THIS_FILE, status, \"Failed to stop clock\"\
    ));\n+\t    pj_mutex_unlock(vid_conf->mutex);\n \t    return status;\n \t}\n \
    \    }\n@@ -584,6 +600,7 @@ PJ_DEF(pj_status_t) pjmedia_vid_conf_connect_port(\n\
    \ \t    status = pjmedia_clock_start(vid_conf->clock);\n \t    if (status != PJ_SUCCESS)\
    \ {\n \t\tPJ_PERROR(4, (THIS_FILE, status, \"Failed to start clock\"));\n+\t\t\
    pj_mutex_unlock(vid_conf->mutex);\n \t\treturn status;\n \t    }\n \t}\n@@ -673,6\
    \ +690,7 @@ PJ_DEF(pj_status_t) pjmedia_vid_conf_disconnect_port(\n \t    status\
    \ = pjmedia_clock_stop(vid_conf->clock);\n \t    if (status != PJ_SUCCESS) {\n\
    \ \t\tPJ_PERROR(4, (THIS_FILE, status, \"Failed to stop clock\"));\n+\t\tpj_mutex_unlock(vid_conf->mutex);\n\
    \ \t\treturn status;\n \t    }\n \t}"
  identifiers:
  - CVE-2021-41141
  - CWE-667
  overview: PJSIP is a free and open source multimedia communication library written
    in the C language implementing standard based protocols such as SIP, SDP, RTP,
    STUN, TURN, and ICE. In various parts of PJSIP, when error/failure occurs, it
    is found that the function returns without releasing the currently held locks.
    This could result in a system deadlock, which cause a denial of service for the
    users. No release has yet been made which contains the linked fix commit. All
    versions up to an including 2.11.1 are affected. Users may need to manually apply
    the patch.
  references:
  - source: security-advisories@github.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/pjsip/pjproject/commit/1aa2c0e0fb60a1b0bf793e0d834073ffe50fb196
  - source: security-advisories@github.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/pjsip/pjproject/security/advisories/GHSA-8fmx-hqw7-6gmc
  - source: security-advisories@github.com
    tags:
    - Mailing List
    - Third Party Advisory
    url: https://lists.debian.org/debian-lts-announce/2022/03/msg00035.html
  - source: security-advisories@github.com
    tags:
    - Third Party Advisory
    url: https://security.gentoo.org/glsa/202210-37
  title: PJSIP is a free and open source multimedia communication library written
    in the C language implementing standard based protocols such as SIP, SDP, RTP,
    STUN, TURN, and ICE. In various parts of PJSIP, when error/failure occurs, it
    is found that the function returns without releasing the currently held locks.
    This could result in a system deadlock, which cause a denial of service for the
    users. No release has yet been made which contains the linked fix commit. All
    versions up to an including 2.11.1 are affected. Users may need to manually apply
    the patch.
- diff_content:
  - "--- a/src/ex_docmd.c\n+++ b/src/ex_docmd.c\n@@ -3632,7 +3632,8 @@ find_ex_command(\n\
    \ \t}\n \n \t// Check for \"++nr\" and \"--nr\".\n-\tif (p == eap->cmd && p[0]\
    \ == p[1] && (*p == '+' || *p == '-'))\n+\tif (p == eap->cmd && p[0] != NUL &&\
    \ p[0] == p[1]\n+\t\t\t\t\t\t   && (*p == '+' || *p == '-'))\n \t{\n \t    eap->cmdidx\
    \ = *p == '+' ? CMD_increment : CMD_decrement;\n \t    return eap->cmd + 2;"
  - "--- a/src/version.c\n+++ b/src/version.c\n@@ -750,6 +750,8 @@ static char *(features[])\
    \ =\n \n static int included_patches[] =\n {   /* Add new patch number below this\
    \ line */\n+/**/\n+    4009,\n /**/\n     4008,\n /**/"
  - "--- a/src/vim9compile.c\n+++ b/src/vim9compile.c\n@@ -2781,7 +2781,8 @@ compile_def_function(\n\
    \ \tcmd = ea.cmd;\n \tif ((*cmd != '$' || starts_with_colon)\n \t\t&& (starts_with_colon\
    \ || !(*cmd == '\\''\n-\t\t       || (cmd[0] == cmd[1] && (*cmd == '+' || *cmd\
    \ == '-')))))\n+\t\t       || (cmd[0] != NUL && cmd[0] == cmd[1]\n+\t\t\t\t\t\
    \    && (*cmd == '+' || *cmd == '-')))))\n \t{\n \t    ea.cmd = skip_range(ea.cmd,\
    \ TRUE, NULL);\n \t    if (ea.cmd > cmd)"
  identifiers:
  - CVE-2022-0128
  - CWE-125
  overview: vim is vulnerable to Out-of-bounds Read
  references:
  - source: security@huntr.dev
    tags:
    - Mailing List
    - Third Party Advisory
    url: http://seclists.org/fulldisclosure/2022/Jul/14
  - source: security@huntr.dev
    tags:
    - Mailing List
    - Third Party Advisory
    url: http://seclists.org/fulldisclosure/2022/Mar/29
  - source: security@huntr.dev
    tags:
    - Mailing List
    - Third Party Advisory
    url: http://seclists.org/fulldisclosure/2022/May/35
  - source: security@huntr.dev
    tags:
    - Mailing List
    - Third Party Advisory
    url: http://www.openwall.com/lists/oss-security/2022/01/15/1
  - source: security@huntr.dev
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/vim/vim/commit/d3a117814d6acbf0dca3eff1a7626843b9b3734a
  - source: security@huntr.dev
    tags:
    - Exploit
    - Issue Tracking
    - Patch
    - Third Party Advisory
    url: https://huntr.dev/bounties/63f51299-008a-4112-b85b-1e904aadd4ba
  - source: security@huntr.dev
    tags:
    - Third Party Advisory
    url: https://security.gentoo.org/glsa/202208-32
  - source: security@huntr.dev
    tags:
    - Release Notes
    - Third Party Advisory
    url: https://support.apple.com/kb/HT213183
  - source: security@huntr.dev
    tags:
    - Third Party Advisory
    url: https://support.apple.com/kb/HT213256
  - source: security@huntr.dev
    tags:
    - Third Party Advisory
    url: https://support.apple.com/kb/HT213343
  title: vim is vulnerable to Out-of-bounds Read
- diff_content:
  - "--- a/src/alloc.c\n+++ b/src/alloc.c\n@@ -702,7 +702,7 @@ ga_init(garray_T *gap)\n\
    \ }\n \n     void\n-ga_init2(garray_T *gap, int itemsize, int growsize)\n+ga_init2(garray_T\
    \ *gap, size_t itemsize, int growsize)\n {\n     ga_init(gap);\n     gap->ga_itemsize\
    \ = itemsize;\n@@ -789,7 +789,7 @@ ga_concat_strings(garray_T *gap, char *sep)\n\
    \  * When out of memory nothing changes and FAIL is returned.\n  */\n     int\n\
    -ga_add_string(garray_T *gap, char_u *p)\n+ga_copy_string(garray_T *gap, char_u\
    \ *p)\n {\n     char_u *cp = vim_strsave(p);\n \n@@ -805,6 +805,19 @@ ga_add_string(garray_T\
    \ *gap, char_u *p)\n     return OK;\n }\n \n+/*\n+ * Add string \"p\" to \"gap\"\
    .\n+ * When out of memory \"p\" is freed and FAIL is returned.\n+ */\n+    int\n\
    +ga_add_string(garray_T *gap, char_u *p)\n+{\n+    if (ga_grow(gap, 1) == FAIL)\n\
    +\treturn FAIL;\n+    ((char_u **)(gap->ga_data))[gap->ga_len++] = p;\n+    return\
    \ OK;\n+}\n+\n /*\n  * Concatenate a string to a growarray which contains bytes.\n\
    \  * When \"s\" is NULL does not do anything."
  - "--- a/src/message.c\n+++ b/src/message.c\n@@ -587,7 +587,7 @@ ignore_error_for_testing(char_u\
    \ *error)\n     if (STRCMP(\"RESET\", error) == 0)\n \tga_clear_strings(&ignore_error_list);\n\
    \     else\n-\tga_add_string(&ignore_error_list, error);\n+\tga_copy_string(&ignore_error_list,\
    \ error);\n }\n \n     static int"
  - "--- a/src/usercmd.c\n+++ b/src/usercmd.c\n@@ -1021,7 +1021,7 @@ may_get_cmd_block(exarg_T\
    \ *eap, char_u *p, char_u **tofree, int *flags)\n \tchar_u\t    *line = NULL;\n\
    \ \n \tga_init2(&ga, sizeof(char_u *), 10);\n-\tif (ga_add_string(&ga, p) == FAIL)\n\
    +\tif (ga_copy_string(&ga, p) == FAIL)\n \t    return retp;\n \n \t// If the argument\
    \ ends in \"}\" it must have been concatenated already\n@@ -1038,7 +1038,7 @@\
    \ may_get_cmd_block(exarg_T *eap, char_u *p, char_u **tofree, int *flags)\n \t\
    \t    emsg(_(e_missing_rcurly));\n \t\t    break;\n \t\t}\n-\t\tif (ga_add_string(&ga,\
    \ line) == FAIL)\n+\t\tif (ga_copy_string(&ga, line) == FAIL)\n \t\t    break;\n\
    \ \t\tif (*skipwhite(line) == '}')\n \t\t    break;"
  - "--- a/src/userfunc.c\n+++ b/src/userfunc.c\n@@ -166,13 +166,13 @@ one_function_arg(\n\
    \ \n /*\n  * Handle line continuation in function arguments or body.\n- * Get\
    \ a next line, store it in \"eap\" if appropriate and use \"line_to_free\" to\n\
    - * handle freeing the line later.\n+ * Get a next line, store it in \"eap\" if\
    \ appropriate and put the line in\n+ * \"lines_to_free\" to free the line later.\n\
    \  */\n     static char_u *\n get_function_line(\n \texarg_T\t\t*eap,\n-\tchar_u\t\
    \t**line_to_free,\n+\tgarray_T\t*lines_to_free,\n \tint\t\tindent,\n \tgetline_opt_T\t\
    getline_options)\n {\n@@ -184,10 +184,11 @@ get_function_line(\n \ttheline = eap->getline(':',\
    \ eap->cookie, indent, getline_options);\n     if (theline != NULL)\n     {\n\
    -\tif (*eap->cmdlinep == *line_to_free)\n+\tif (lines_to_free->ga_len > 0\n+\t\
    \t&& *eap->cmdlinep == ((char_u **)lines_to_free->ga_data)\n+\t\t\t\t\t\t   [lines_to_free->ga_len\
    \ - 1])\n \t    *eap->cmdlinep = theline;\n-\tvim_free(*line_to_free);\n-\t*line_to_free\
    \ = theline;\n+\tga_add_string(lines_to_free, theline);\n     }\n \n     return\
    \ theline;\n@@ -210,7 +211,7 @@ get_function_args(\n     garray_T\t*default_args,\n\
    \     int\t\tskip,\n     exarg_T\t*eap,\n-    char_u\t**line_to_free)\n+    garray_T\t\
    *lines_to_free)\n {\n     int\t\tmustend = FALSE;\n     char_u\t*arg;\n@@ -241,7\
    \ +242,7 @@ get_function_args(\n \t\t\t && (*p == NUL || (VIM_ISWHITE(*whitep)\
    \ && *p == '#')))\n \t{\n \t    // End of the line, get the next one.\n-\t   \
    \ char_u *theline = get_function_line(eap, line_to_free, 0,\n+\t    char_u *theline\
    \ = get_function_line(eap, lines_to_free, 0,\n \t\t\t\t\t\t\t  GETLINE_CONCAT_CONT);\n\
    \ \n \t    if (theline == NULL)\n@@ -677,7 +678,7 @@ get_function_body(\n \texarg_T\t\
    \    *eap,\n \tgarray_T    *newlines,\n \tchar_u\t    *line_arg_in,\n-\tchar_u\t\
    \    **line_to_free)\n+\tgarray_T    *lines_to_free)\n {\n     linenr_T\tsourcing_lnum_top\
    \ = SOURCING_LNUM;\n     linenr_T\tsourcing_lnum_off;\n@@ -744,7 +745,7 @@ get_function_body(\n\
    \ \t}\n \telse\n \t{\n-\t    theline = get_function_line(eap, line_to_free, indent,\n\
    +\t    theline = get_function_line(eap, lines_to_free, indent,\n \t\t\t\t\t\t\t\
    \      getline_options);\n \t}\n \tif (KeyTyped)\n@@ -854,14 +855,20 @@ get_function_body(\n\
    \ \t\t    {\n \t\t\t// Another command follows. If the line came from \"eap\"\n\
    \ \t\t\t// we can simply point into it, otherwise we need to\n-\t\t\t// change\
    \ \"eap->cmdlinep\".\n+\t\t\t// change \"eap->cmdlinep\" to point to the last\
    \ fetched\n+\t\t\t// line.\n \t\t\teap->nextcmd = nextcmd;\n-\t\t\tif (*line_to_free\
    \ != NULL\n-\t\t\t\t\t    && *eap->cmdlinep != *line_to_free)\n+\t\t\tif (lines_to_free->ga_len\
    \ > 0\n+\t\t\t\t&& *eap->cmdlinep !=\n+\t\t\t\t\t    ((char_u **)lines_to_free->ga_data)\n\
    +\t\t\t\t\t\t   [lines_to_free->ga_len - 1])\n \t\t\t{\n+\t\t\t    // *cmdlinep\
    \ will be freed later, thus remove the\n+\t\t\t    // line from lines_to_free.\n\
    \ \t\t\t    vim_free(*eap->cmdlinep);\n-\t\t\t    *eap->cmdlinep = *line_to_free;\n\
    -\t\t\t    *line_to_free = NULL;\n+\t\t\t    *eap->cmdlinep = ((char_u **)lines_to_free->ga_data)\n\
    +\t\t\t\t\t\t   [lines_to_free->ga_len - 1];\n+\t\t\t    --lines_to_free->ga_len;\n\
    \ \t\t\t}\n \t\t    }\n \t\t    break;\n@@ -1118,7 +1125,6 @@ lambda_function_body(\n\
    \     garray_T\tnewlines;\n     char_u\t*cmdline = NULL;\n     int\t\tret = FAIL;\n\
    -    char_u\t*line_to_free = NULL;\n     partial_T\t*pt;\n     char_u\t*name;\n\
    \     int\t\tlnum_save = -1;\n@@ -1144,12 +1150,9 @@ lambda_function_body(\n \
    \    }\n \n     ga_init2(&newlines, (int)sizeof(char_u *), 10);\n-    if (get_function_body(&eap,\
    \ &newlines, NULL, &line_to_free) == FAIL)\n-    {\n-\tif (cmdline != line_to_free)\n\
    -\t    vim_free(cmdline);\n+    if (get_function_body(&eap, &newlines, NULL,\n\
    +\t\t\t\t\t     &evalarg->eval_tofree_ga) == FAIL)\n \tgoto erret;\n-    }\n \n\
    \     // When inside a lambda must add the function lines to evalarg.eval_ga.\n\
    \     evalarg->eval_break_count += newlines.ga_len;\n@@ -1208,8 +1211,6 @@ lambda_function_body(\n\
    \ \t{\n \t    ((char_u **)(tfgap->ga_data))[tfgap->ga_len++] = cmdline;\n \t \
    \   evalarg->eval_using_cmdline = TRUE;\n-\t    if (cmdline == line_to_free)\n\
    -\t\tline_to_free = NULL;\n \t}\n     }\n     else\n@@ -1278,7 +1279,6 @@ lambda_function_body(\n\
    \ erret:\n     if (lnum_save >= 0)\n \tSOURCING_LNUM = lnum_save;\n-    vim_free(line_to_free);\n\
    \     ga_clear_strings(&newlines);\n     if (newargs != NULL)\n \tga_clear_strings(newargs);\n\
    @@ -3957,10 +3957,11 @@ list_functions(regmatch_T *regmatch)\n  * \":function\"\
    \ also supporting nested \":def\".\n  * When \"name_arg\" is not NULL this is\
    \ a nested function, using \"name_arg\" for\n  * the function name.\n+ * \"lines_to_free\"\
    \ is a list of strings to be freed later.\n  * Returns a pointer to the function\
    \ or NULL if no function defined.\n  */\n     ufunc_T *\n-define_function(exarg_T\
    \ *eap, char_u *name_arg, char_u **line_to_free)\n+define_function(exarg_T *eap,\
    \ char_u *name_arg, garray_T *lines_to_free)\n {\n     int\t\tj;\n     int\t\t\
    c;\n@@ -4229,7 +4230,7 @@ define_function(exarg_T *eap, char_u *name_arg, char_u\
    \ **line_to_free)\n     if (get_function_args(&p, ')', &newargs,\n \t\t\teap->cmdidx\
    \ == CMD_def ? &argtypes : NULL, FALSE,\n \t\t\t NULL, &varargs, &default_args,\
    \ eap->skip,\n-\t\t\t eap, line_to_free) == FAIL)\n+\t\t\t eap, lines_to_free)\
    \ == FAIL)\n \tgoto errret_2;\n     whitep = p;\n \n@@ -4339,7 +4340,7 @@ define_function(exarg_T\
    \ *eap, char_u *name_arg, char_u **line_to_free)\n \n     // Do not define the\
    \ function when getting the body fails and when\n     // skipping.\n-    if (get_function_body(eap,\
    \ &newlines, line_arg, line_to_free) == FAIL\n+    if (get_function_body(eap,\
    \ &newlines, line_arg, lines_to_free) == FAIL\n \t    || eap->skip)\n \tgoto erret;\n\
    \ \n@@ -4645,10 +4646,11 @@ define_function(exarg_T *eap, char_u *name_arg, char_u\
    \ **line_to_free)\n     void\n ex_function(exarg_T *eap)\n {\n-    char_u *line_to_free\
    \ = NULL;\n+    garray_T lines_to_free;\n \n-    (void)define_function(eap, NULL,\
    \ &line_to_free);\n-    vim_free(line_to_free);\n+    ga_init2(&lines_to_free,\
    \ sizeof(char_u *), 50);\n+    (void)define_function(eap, NULL, &lines_to_free);\n\
    +    ga_clear_strings(&lines_to_free);\n }\n \n /*"
  - "--- a/src/version.c\n+++ b/src/version.c\n@@ -750,6 +750,8 @@ static char *(features[])\
    \ =\n \n static int included_patches[] =\n {   /* Add new patch number below this\
    \ line */\n+/**/\n+    4040,\n /**/\n     4039,\n /**/"
  - "--- a/src/vim9compile.c\n+++ b/src/vim9compile.c\n@@ -810,7 +810,7 @@ func_needs_compiling(ufunc_T\
    \ *ufunc, compiletype_T compile_type)\n  * Compile a nested :def command.\n  */\n\
    \     static char_u *\n-compile_nested_function(exarg_T *eap, cctx_T *cctx, char_u\
    \ **line_to_free)\n+compile_nested_function(exarg_T *eap, cctx_T *cctx, garray_T\
    \ *lines_to_free)\n {\n     int\t\tis_global = *eap->arg == 'g' && eap->arg[1]\
    \ == ':';\n     char_u\t*name_start = eap->arg;\n@@ -876,7 +876,7 @@ compile_nested_function(exarg_T\
    \ *eap, cctx_T *cctx, char_u **line_to_free)\n \tgoto theend;\n     }\n \n-  \
    \  ufunc = define_function(eap, lambda_name, line_to_free);\n+    ufunc = define_function(eap,\
    \ lambda_name, lines_to_free);\n     if (ufunc == NULL)\n     {\n \tr = eap->skip\
    \ ? OK : FAIL;\n@@ -2496,7 +2496,7 @@ compile_def_function(\n \tcctx_T\t\t*outer_cctx)\n\
    \ {\n     char_u\t*line = NULL;\n-    char_u\t*line_to_free = NULL;\n+    garray_T\t\
    lines_to_free;\n     char_u\t*p;\n     char\t*errormsg = NULL;\t// error message\n\
    \     cctx_T\tcctx;\n@@ -2514,6 +2514,9 @@ compile_def_function(\n #endif\n  \
    \   int\t\tdebug_lnum = -1;\n \n+    // allocated lines are freed at the end\n\
    +    ga_init2(&lines_to_free, sizeof(char_u *), 50);\n+\n     // When using a\
    \ function that was compiled before: Free old instructions.\n     // The index\
    \ is reused.  Otherwise add a new entry in \"def_functions\".\n     if (ufunc->uf_dfunc_idx\
    \ > 0)\n@@ -2681,8 +2684,8 @@ compile_def_function(\n \t    if (line != NULL)\n\
    \ \t    {\n \t\tline = vim_strsave(line);\n-\t\tvim_free(line_to_free);\n-\t\t\
    line_to_free = line;\n+\t\tif (ga_add_string(&lines_to_free, line) == FAIL)\n\
    +\t\t    goto erret;\n \t    }\n \t}\n \n@@ -2926,7 +2929,7 @@ compile_def_function(\n\
    \ \t    case CMD_def:\n \t    case CMD_function:\n \t\t    ea.arg = p;\n-\t\t\
    \    line = compile_nested_function(&ea, &cctx, &line_to_free);\n+\t\t    line\
    \ = compile_nested_function(&ea, &cctx, &lines_to_free);\n \t\t    break;\n \n\
    \ \t    case CMD_return:\n@@ -3236,7 +3239,7 @@ compile_def_function(\n     if\
    \ (do_estack_push)\n \testack_pop();\n \n-    vim_free(line_to_free);\n+    ga_clear_strings(&lines_to_free);\n\
    \     free_imported(&cctx);\n     free_locals(&cctx);\n     ga_clear(&cctx.ctx_type_stack);"
  - "--- a/src/viminfo.c\n+++ b/src/viminfo.c\n@@ -2730,7 +2730,7 @@ read_viminfo_barline(vir_T\
    \ *virp, int got_encoding, int force, int writing)\n     {\n \t// Continuation\
    \ line of an unrecognized item.\n \tif (writing)\n-\t    ga_add_string(&virp->vir_barlines,\
    \ virp->vir_line);\n+\t    ga_copy_string(&virp->vir_barlines, virp->vir_line);\n\
    \     }\n     else\n     {\n@@ -2769,7 +2769,7 @@ read_viminfo_barline(vir_T *virp,\
    \ int got_encoding, int force, int writing)\n \t    default:\n \t\t// copy unrecognized\
    \ line (for future use)\n \t\tif (writing)\n-\t\t    ga_add_string(&virp->vir_barlines,\
    \ virp->vir_line);\n+\t\t    ga_copy_string(&virp->vir_barlines, virp->vir_line);\n\
    \ \t}\n \tfor (i = 0; i < values.ga_len; ++i)\n \t{"
  identifiers:
  - CVE-2022-0156
  - CWE-416
  overview: vim is vulnerable to Use After Free
  references:
  - source: security@huntr.dev
    tags:
    - Mailing List
    - Third Party Advisory
    url: http://seclists.org/fulldisclosure/2022/Jul/13
  - source: security@huntr.dev
    tags:
    - Mailing List
    - Third Party Advisory
    url: http://seclists.org/fulldisclosure/2022/Mar/29
  - source: security@huntr.dev
    tags:
    - Mailing List
    - Third Party Advisory
    url: http://www.openwall.com/lists/oss-security/2022/01/15/1
  - source: security@huntr.dev
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/vim/vim/commit/9f1a39a5d1cd7989ada2d1cb32f97d84360e050f
  - source: security@huntr.dev
    tags:
    - Exploit
    - Patch
    - Third Party Advisory
    url: https://huntr.dev/bounties/47dded34-3767-4725-8c7c-9dcb68c70b36
  - source: security@huntr.dev
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/3FH2J57GDA2WMBS6J56F6QQRA6BXQQFZ/
  - source: security@huntr.dev
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/HD5S2FC2HF22A7XQXK2XXIR46EARVWIM/
  - source: security@huntr.dev
    tags:
    - Third Party Advisory
    url: https://security.gentoo.org/glsa/202208-32
  - source: security@huntr.dev
    tags:
    - Release Notes
    - Third Party Advisory
    url: https://support.apple.com/kb/HT213183
  - source: security@huntr.dev
    tags:
    - Third Party Advisory
    url: https://support.apple.com/kb/HT213344
  title: vim is vulnerable to Use After Free
- diff_content:
  - "--- a/src/version.c\n+++ b/src/version.c\n@@ -750,6 +750,8 @@ static char *(features[])\
    \ =\n \n static int included_patches[] =\n {   /* Add new patch number below this\
    \ line */\n+/**/\n+    4049,\n /**/\n     4048,\n /**/"
  - "--- a/src/vim9expr.c\n+++ b/src/vim9expr.c\n@@ -1233,7 +1233,7 @@ compile_get_env(char_u\
    \ **arg, cctx_T *cctx)\n     len = get_env_len(arg);\n     if (len == 0)\n   \
    \  {\n-\tsemsg(_(e_syntax_error_at_str), start - 1);\n+\tsemsg(_(e_syntax_error_at_str),\
    \ start);\n \treturn FAIL;\n     }\n "
  identifiers:
  - CVE-2022-0158
  - CWE-122
  overview: vim is vulnerable to Heap-based Buffer Overflow
  references:
  - source: security@huntr.dev
    tags:
    - Mailing List
    - Third Party Advisory
    url: http://seclists.org/fulldisclosure/2022/Jul/13
  - source: security@huntr.dev
    tags:
    - Mailing List
    - Third Party Advisory
    url: http://seclists.org/fulldisclosure/2022/Mar/29
  - source: security@huntr.dev
    tags:
    - Mailing List
    - Third Party Advisory
    url: http://www.openwall.com/lists/oss-security/2022/01/15/1
  - source: security@huntr.dev
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/vim/vim/commit/5f25c3855071bd7e26255c68bf458b1b5cf92f39
  - source: security@huntr.dev
    tags:
    - Exploit
    - Patch
    - Third Party Advisory
    url: https://huntr.dev/bounties/ac5d7005-07c6-4a0a-b251-ba9cdbf6738b
  - source: security@huntr.dev
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/3FH2J57GDA2WMBS6J56F6QQRA6BXQQFZ/
  - source: security@huntr.dev
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/HD5S2FC2HF22A7XQXK2XXIR46EARVWIM/
  - source: security@huntr.dev
    tags:
    - Third Party Advisory
    url: https://security.gentoo.org/glsa/202208-32
  - source: security@huntr.dev
    tags:
    - Release Notes
    - Third Party Advisory
    url: https://support.apple.com/kb/HT213183
  - source: security@huntr.dev
    tags:
    - Third Party Advisory
    url: https://support.apple.com/kb/HT213344
  title: vim is vulnerable to Heap-based Buffer Overflow
- diff_content:
  - "--- a/src/isomedia/box_funcs.c\n+++ b/src/isomedia/box_funcs.c\n@@ -205,17 +205,11\
    \ @@ GF_Err gf_isom_box_parse_ex(GF_Box **outBox, GF_BitStream *bs, u32 parent_type,\n\
    \ \n \tnewBox->size = size - hdr_size;\n \n-\tif (newBox->size) {\n-\t\te = gf_isom_full_box_read(newBox,\
    \ bs);\n-\t\tif (!e) e = gf_isom_box_read(newBox, bs);\n-\t\tnewBox->size = size;\n\
    -\t\tend = gf_bs_get_position(bs);\n-\t} else {\n-\t\tnewBox->size = size;\n-\t\
    \t//empty box\n-\t\te = GF_OK;\n-\t\tend = gf_bs_get_position(bs);\n-\t}\n+\t\
    //parse even if size is 0 - this makes sure that we perform box parsing (usually\
    \ in box->read)\n+\te = gf_isom_full_box_read(newBox, bs);\n+\tif (!e) e = gf_isom_box_read(newBox,\
    \ bs);\n+\tnewBox->size = size;\n+\tend = gf_bs_get_position(bs);\n \n \tif (e\
    \ && (e != GF_ISOM_INCOMPLETE_FILE)) {\n \t\tgf_isom_box_del(newBox);"
  identifiers:
  - CVE-2020-25427
  - CWE-476
  overview: A Null pointer dereference vulnerability exits in MP4Box - GPAC version
    0.8.0-rev177-g51a8ef874-master via the gf_isom_get_track_id function, which causes
    a denial of service.
  references:
  - source: cve@mitre.org
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/gpac/gpac/commit/8e585e623b1d666b4ef736ed609264639cb27701
  - source: cve@mitre.org
    tags:
    - Third Party Advisory
    url: https://github.com/gpac/gpac/issues/1406
  title: A Null pointer dereference vulnerability exits in MP4Box - GPAC version 0.8.0-rev177-g51a8ef874-master
    via the gf_isom_get_track_id function, which causes a denial of service.
- diff_content:
  - "--- a/libr/io/io_bank.c\n+++ b/libr/io/io_bank.c\n@@ -230,7 +230,10 @@ R_API\
    \ bool r_io_bank_map_add_top(RIO *io, const ut32 bankid, const ut32 mapid) {\n\
    \ \t\t//delete all submaps that are completly included in sm\n \t\tRRBNode *next\
    \ = r_rbnode_next (entry);\n \t\t// this can be optimized, there is no need to\
    \ do search here\n-\t\tr_crbtree_delete (bank->submaps, entry->data, _find_sm_by_from_vaddr_cb,\
    \ NULL);\n+\t\tbool a = r_crbtree_delete (bank->submaps, entry->data, _find_sm_by_from_vaddr_cb,\
    \ NULL);\n+\t\tif (!a) {\n+\t\t\tbreak;\n+\t\t}\n \t\tentry = next;\n \t}\n \t\
    if (entry && r_io_submap_from (((RIOSubMap *)entry->data)) <= r_io_submap_to (sm))\
    \ {"
  identifiers:
  - CVE-2022-0173
  - CWE-125
  overview: radare2 is vulnerable to Out-of-bounds Read
  references:
  - source: security@huntr.dev
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/radareorg/radare2/commit/37897226a1a31f982bfefdc4aeefc2e50355c73c
  - source: security@huntr.dev
    tags:
    - Exploit
    - Third Party Advisory
    url: https://huntr.dev/bounties/727d8600-88bc-4dde-8dea-ee3d192600e5
  - source: security@huntr.dev
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/IQIRJ72UALGMSWH6MYPVJQQLXFGZ23RS/
  - source: security@huntr.dev
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/SKGIB52R4XPCPNEW6GF56EHW7ST24IJU/
  title: radare2 is vulnerable to Out-of-bounds Read
- diff_content:
  - "--- a/sources/libmeshb7.c\n+++ b/sources/libmeshb7.c\n@@ -2,14 +2,14 @@\n \n\
    \ /*----------------------------------------------------------------------------*/\n\
    \ /*                                                                         \
    \   */\n-/*                               LIBMESHB V7.61                     \
    \          */\n+/*                               LIBMESHB V7.62              \
    \                 */\n /*                                                    \
    \                        */\n /*----------------------------------------------------------------------------*/\n\
    \ /*                                                                         \
    \   */\n /*   Description:        handles .meshb file format I/O             \
    \          */\n /*   Author:             Loic MARECHAL                       \
    \                 */\n /*   Creation date:      dec 09 1999                  \
    \                        */\n-/*   Last modification:  sep 27 2021           \
    \                               */\n+/*   Last modification:  jan 07 2022    \
    \                                      */\n /*                               \
    \                                             */\n /*----------------------------------------------------------------------------*/\n\
    \ \n@@ -655,7 +655,7 @@ int64_t GmfOpenMesh(const char *FilNam, int mod, ...)\n\
    \ \n          do\n          {\n-            res = fscanf(msh->hdl, \"%s\", str);\n\
    +            res = fscanf(msh->hdl, \"%100s\", str);\n          }while( (res !=\
    \ EOF) && strcmp(str, \"MeshVersionFormatted\") );\n \n          if(res == EOF)\n\
    @@ -668,7 +668,7 @@ int64_t GmfOpenMesh(const char *FilNam, int mod, ...)\n \n\
    \          do\n          {\n-            res = fscanf(msh->hdl, \"%s\", str);\n\
    +            res = fscanf(msh->hdl, \"%100s\", str);\n          }while( (res !=\
    \ EOF) && strcmp(str, \"Dimension\") );\n \n          if(res == EOF)\n@@ -2539,7\
    \ +2539,7 @@ static int ScaKwdTab(GmfMshSct *msh)\n    if(msh->typ & Asc)\n  \
    \  {\n       // Scan each string in the file until the end\n-      while(fscanf(msh->hdl,\
    \ \"%s\", str) != EOF)\n+      while(fscanf(msh->hdl, \"%100s\", str) != EOF)\n\
    \       {\n          // Fast test in order to reject quickly the numeric values\n\
    \          if(isalpha(str[0]))"
  identifiers:
  - CVE-2021-46225
  - CWE-120
  overview: A buffer overflow in the GmfOpenMesh() function of libMeshb v7.61 allows
    attackers to cause a Denial of Service (DoS) via a crafted MESH file.
  references:
  - source: cve@mitre.org
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/LoicMarechal/libMeshb/commit/8cd68c54e0647c0030ae4506a225ad4a2655c316
  - source: cve@mitre.org
    tags:
    - Exploit
    - Issue Tracking
    - Third Party Advisory
    url: https://github.com/LoicMarechal/libMeshb/issues/21
  title: A buffer overflow in the GmfOpenMesh() function of libMeshb v7.61 allows
    attackers to cause a Denial of Service (DoS) via a crafted MESH file.
- diff_content:
  - "--- a/src/filters/reframe_nalu.c\n+++ b/src/filters/reframe_nalu.c\n@@ -1352,9\
    \ +1352,9 @@ void naludmx_create_avc_decoder_config(GF_NALUDmxCtx *ctx, u8 **dsi,\
    \ u32 *dsi_si\n \t\t\t\t\telse\n \t\t\t\t\t\tDeltaTfiDivisorIdx = (ctx->avc_state->sei.pic_timing.pic_struct+1)\
    \ / 2;\n \t\t\t\t}\n-\t\t\t\tif (!ctx->timescale) {\n+\t\t\t\tif (!ctx->timescale\
    \ && sps->vui.time_scale && sps->vui.num_units_in_tick) {\n \t\t\t\t\tctx->cur_fps.num\
    \ = 2 * sps->vui.time_scale;\n-\t\t\t\t\tctx->cur_fps.den =  2 * sps->vui.num_units_in_tick\
    \ * DeltaTfiDivisorIdx;\n+\t\t\t\t\tctx->cur_fps.den = 2 * sps->vui.num_units_in_tick\
    \ * DeltaTfiDivisorIdx;\n \n \t\t\t\t\tif (!ctx->fps.num && ctx->dts==ctx->fps.den)\n\
    \ \t\t\t\t\t\tctx->dts = ctx->cur_fps.den;"
  identifiers:
  - CVE-2021-40562
  - CWE-697
  overview: A Segmentation fault caused by a floating point exception exists in Gpac
    through 1.0.1 using mp4box via the naludmx_enqueue_or_dispatch function in reframe_nalu.c,
    which causes a denial of service.
  references:
  - source: cve@mitre.org
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/gpac/gpac/commit/5dd71c7201a3e5cf40732d585bfb21c906c171d3
  - source: cve@mitre.org
    tags:
    - Third Party Advisory
    url: https://github.com/gpac/gpac/issues/1901
  - source: cve@mitre.org
    url: https://www.debian.org/security/2023/dsa-5411
  title: A Segmentation fault caused by a floating point exception exists in Gpac
    through 1.0.1 using mp4box via the naludmx_enqueue_or_dispatch function in reframe_nalu.c,
    which causes a denial of service.
- diff_content:
  - "--- a/src/filters/reframe_nalu.c\n+++ b/src/filters/reframe_nalu.c\n@@ -1680,8\
    \ +1680,10 @@ static void naludmx_queue_param_set(GF_NALUDmxCtx *ctx, char *data,\
    \ u32 size, u3\n {\n \tGF_List *list = NULL, *alt_list = NULL;\n \tGF_NALUFFParam\
    \ *sl;\n-\tu32 i, count;\n-\tu32 crc = gf_crc_32(data, size);\n+\tu32 i, count,\
    \ crc;\n+\n+\tif (!size) return;\n+\tcrc = gf_crc_32(data, size);\n \n \tif (ctx->codecid==GF_CODECID_HEVC)\
    \ {\n \t\tswitch (ps_type) {"
  identifiers:
  - CVE-2021-40563
  - CWE-476
  overview: A Segmentation fault exists casued by null pointer dereference exists
    in Gpac through 1.0.1 via the naludmx_create_avc_decoder_config function in reframe_nalu.c
    when using mp4box, which causes a denial of service.
  references:
  - source: cve@mitre.org
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/gpac/gpac/commit/5ce0c906ed8599d218036b18b78e8126a496f137
  - source: cve@mitre.org
    tags:
    - Third Party Advisory
    url: https://github.com/gpac/gpac/issues/1892
  - source: cve@mitre.org
    url: https://www.debian.org/security/2023/dsa-5411
  title: A Segmentation fault exists casued by null pointer dereference exists in
    Gpac through 1.0.1 via the naludmx_create_avc_decoder_config function in reframe_nalu.c
    when using mp4box, which causes a denial of service.
- diff_content:
  - "--- a/src/media_tools/av_parsers.c\n+++ b/src/media_tools/av_parsers.c\n@@ -4705,8\
    \ +4705,12 @@ u32 gf_bs_read_ue_log_idx3(GF_BitStream *bs, const char *fname,\
    \ s32 idx1, s32 id\n \t}\n \n \tif (nb_lead) {\n+\t\tu32 leads=1;\n \t\tval =\
    \ gf_bs_read_int(bs, nb_lead);\n-\t\tval += (1 << nb_lead) - 1;\n+\t\tleads <<=\
    \ nb_lead;\n+\t\tleads -= 1;\n+\t\tval += leads;\n+//\t\tval += (1 << nb_lead)\
    \ - 1;\n \t\tbits += nb_lead;\n \t}\n \n@@ -5671,7 +5675,7 @@ static s32 avc_parse_slice(GF_BitStream\
    \ *bs, AVCState *avc, Bool svc_idr_flag, A\n \tif (si->slice_type > 9) return\
    \ -1;\n \n \tpps_id = gf_bs_read_ue_log(bs, \"pps_id\");\n-\tif (pps_id > 255)\
    \ return -1;\n+\tif ((pps_id<0) || (pps_id > 255)) return -1;\n \tsi->pps = &avc->pps[pps_id];\n\
    \ \tif (!si->pps->slice_group_count) return -2;\n \tsi->sps = &avc->sps[si->pps->sps_id];"
  identifiers:
  - CVE-2021-40564
  - CWE-476
  overview: A Segmentation fault caused by null pointer dereference vulnerability
    eists in Gpac through 1.0.2 via the avc_parse_slice function in av_parsers.c when
    using mp4box, which causes a denial of service.
  references:
  - source: cve@mitre.org
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/gpac/gpac/commit/cf6771c857eb9a290e2c19ddacfdd3ed98b27618
  - source: cve@mitre.org
    tags:
    - Third Party Advisory
    url: https://github.com/gpac/gpac/issues/1898
  - source: cve@mitre.org
    url: https://www.debian.org/security/2023/dsa-5411
  title: A Segmentation fault caused by null pointer dereference vulnerability eists
    in Gpac through 1.0.2 via the avc_parse_slice function in av_parsers.c when using
    mp4box, which causes a denial of service.
- diff_content:
  - "--- a/src/media_tools/av_parsers.c\n+++ b/src/media_tools/av_parsers.c\n@@ -6113,7\
    \ +6113,8 @@ s32 gf_avc_parse_nalu(GF_BitStream *bs, AVCState *avc)\n \t\t\tret\
    \ = 1;\n \t\t\tbreak;\n \t\t}\n-\t\tassert(avc->s_info.sps);\n+\t\tif (!avc->s_info.sps)\n\
    +\t\t\treturn -1;\n \n \t\tif (avc->s_info.sps->poc_type == n_state.sps->poc_type)\
    \ {\n \t\t\tif (!avc->s_info.sps->poc_type) {"
  identifiers:
  - CVE-2021-40565
  - CWE-476
  overview: A Segmentation fault caused by a null pointer dereference vulnerability
    exists in Gpac through 1.0.1 via the gf_avc_parse_nalu function in av_parsers.c
    when using mp4box, which causes a denial of service.
  references:
  - source: cve@mitre.org
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/gpac/gpac/commit/893fb99b606eebfae46cde151846a980e689039b
  - source: cve@mitre.org
    tags:
    - Third Party Advisory
    url: https://github.com/gpac/gpac/issues/1902
  - source: cve@mitre.org
    url: https://www.debian.org/security/2023/dsa-5411
  title: A Segmentation fault caused by a null pointer dereference vulnerability exists
    in Gpac through 1.0.1 via the gf_avc_parse_nalu function in av_parsers.c when
    using mp4box, which causes a denial of service.
- diff_content:
  - "--- a/src/filters/dec_xvid.c\n+++ b/src/filters/dec_xvid.c\n@@ -181,7 +181,7\
    \ @@ static GF_Err xviddec_configure_pid(GF_Filter *filter, GF_FilterPid *pid,\
    \ Bool i\n \t/*decode DSI*/\n \te = gf_m4v_get_config(p->value.data.ptr, p->value.data.size,\
    \ &dsi);\n \tif (e) return e;\n-\tif (!dsi.width || !dsi.height) return GF_NON_COMPLIANT_BITSTREAM;\n\
    +\tif (!dsi.width || (dsi.width%2) || !dsi.height) return GF_NON_COMPLIANT_BITSTREAM;\n\
    \ \n \tmemset(&par, 0, sizeof(par));\n \tpar.width = dsi.width;"
  - "--- a/src/filters/reframe_mpgvid.c\n+++ b/src/filters/reframe_mpgvid.c\n@@ -805,12\
    \ +805,17 @@ GF_Err mpgviddmx_process(GF_Filter *filter)\n \t\t\t\t//not enough\
    \ data, accumulate until we can parse the full header\n \t\t\t\tif (e==GF_EOS)\
    \ {\n \t\t\t\t\tif (vosh_start<0) vosh_start = 0;\n-\t\t\t\t\tif (ctx->hdr_store_alloc\
    \ < ctx->hdr_store_size + pck_size - vosh_start) {\n-\t\t\t\t\t\tctx->hdr_store_alloc\
    \ = (u32) (ctx->hdr_store_size + pck_size - vosh_start);\n-\t\t\t\t\t\tctx->hdr_store\
    \ = gf_realloc(ctx->hdr_store, sizeof(char)*ctx->hdr_store_alloc);\n+\t\t\t\t\t\
    if (data == ctx->hdr_store) {\n+\t\t\t\t\t\tmemmove(ctx->hdr_store, start, remain);\n\
    +\t\t\t\t\t\tctx->hdr_store_size = remain;\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\t\
    if (ctx->hdr_store_alloc < ctx->hdr_store_size + pck_size - vosh_start) {\n+\t\
    \t\t\t\t\t\tctx->hdr_store_alloc = (u32) (ctx->hdr_store_size + pck_size - vosh_start);\n\
    +\t\t\t\t\t\t\tctx->hdr_store = gf_realloc(ctx->hdr_store, sizeof(char)*ctx->hdr_store_alloc);\n\
    +\t\t\t\t\t\t}\n+\t\t\t\t\t\tmemcpy(ctx->hdr_store + ctx->hdr_store_size, data\
    \ + vosh_start, (size_t) (pck_size - vosh_start) );\n+\t\t\t\t\t\tctx->hdr_store_size\
    \ += pck_size - (u32) vosh_start;\n \t\t\t\t\t}\n-\t\t\t\t\tmemcpy(ctx->hdr_store\
    \ + ctx->hdr_store_size, data + vosh_start, (size_t) (pck_size - vosh_start) );\n\
    -\t\t\t\t\tctx->hdr_store_size += pck_size - (u32) vosh_start;\n \t\t\t\t\tgf_filter_pid_drop_packet(ctx->ipid);\n\
    \ \t\t\t\t\treturn GF_OK;\n \t\t\t\t} else if (e != GF_OK) {\n@@ -844,12 +849,17\
    \ @@ GF_Err mpgviddmx_process(GF_Filter *filter)\n \t\t\t\t//not enough data,\
    \ accumulate until we can parse the full header\n \t\t\t\tif (e==GF_EOS) {\n \t\
    \t\t\t\tif (vosh_start<0) vosh_start = 0;\n-\t\t\t\t\tif (ctx->hdr_store_alloc\
    \ < ctx->hdr_store_size + pck_size - vosh_start) {\n-\t\t\t\t\t\tctx->hdr_store_alloc\
    \ = (u32) (ctx->hdr_store_size + pck_size - (u32) vosh_start);\n-\t\t\t\t\t\t\
    ctx->hdr_store = gf_realloc(ctx->hdr_store, sizeof(char)*ctx->hdr_store_alloc);\n\
    +\t\t\t\t\tif (data == ctx->hdr_store) {\n+\t\t\t\t\t\tmemmove(ctx->hdr_store,\
    \ start, remain);\n+\t\t\t\t\t\tctx->hdr_store_size = remain;\n+\t\t\t\t\t} else\
    \ {\n+\t\t\t\t\t\tif (ctx->hdr_store_alloc < ctx->hdr_store_size + pck_size -\
    \ vosh_start) {\n+\t\t\t\t\t\t\tctx->hdr_store_alloc = (u32) (ctx->hdr_store_size\
    \ + pck_size - (u32) vosh_start);\n+\t\t\t\t\t\t\tctx->hdr_store = gf_realloc(ctx->hdr_store,\
    \ sizeof(char)*ctx->hdr_store_alloc);\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\tmemcpy(ctx->hdr_store\
    \ + ctx->hdr_store_size, data + vosh_start, (size_t) (pck_size - vosh_start) );\n\
    +\t\t\t\t\t\tctx->hdr_store_size += pck_size - (u32) vosh_start;\n \t\t\t\t\t\
    }\n-\t\t\t\t\tmemcpy(ctx->hdr_store + ctx->hdr_store_size, data + vosh_start,\
    \ (size_t) (pck_size - vosh_start) );\n-\t\t\t\t\tctx->hdr_store_size += pck_size\
    \ - (u32) vosh_start;\n \t\t\t\t\tgf_filter_pid_drop_packet(ctx->ipid);\n \t\t\
    \t\t\treturn GF_OK;\n \t\t\t\t} else if (e != GF_OK) {"
  identifiers:
  - CVE-2021-40566
  - CWE-416
  overview: A Segmentation fault casued by heap use after free vulnerability exists
    in Gpac through 1.0.1 via the mpgviddmx_process function in reframe_mpgvid.c when
    using mp4box, which causes a denial of service.
  references:
  - source: cve@mitre.org
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/gpac/gpac/commit/96047e0e6166407c40cc19f4e94fb35cd7624391
  - source: cve@mitre.org
    tags:
    - Third Party Advisory
    url: https://github.com/gpac/gpac/issues/1887
  - source: cve@mitre.org
    url: https://www.debian.org/security/2023/dsa-5411
  title: A Segmentation fault casued by heap use after free vulnerability exists in
    Gpac through 1.0.1 via the mpgviddmx_process function in reframe_mpgvid.c when
    using mp4box, which causes a denial of service.
- diff_content:
  - "--- a/common/flatpak-dir.c\n+++ b/common/flatpak-dir.c\n@@ -9372,6 +9372,13 @@\
    \ flatpak_dir_ensure_bundle_remote (FlatpakDir         *self,\n   if (metadata\
    \ == NULL)\n     return NULL;\n \n+  /* If we rely on metadata (to e.g. print\
    \ permissions), check it exists before creating the remote */\n+  if (out_metadata\
    \ && fp_metadata == NULL)\n+    {\n+      flatpak_fail_error (error, FLATPAK_ERROR_INVALID_DATA,\
    \ \"No metadata in bundler header\");\n+      return NULL;\n+    }\n+\n   gpg_data\
    \ = extra_gpg_data ? extra_gpg_data : included_gpg_data;\n \n   deploy_data =\
    \ flatpak_dir_get_deploy_data (self, ref, FLATPAK_DEPLOY_VERSION_ANY, cancellable,\
    \ NULL);"
  - "--- a/common/flatpak-dir.c\n+++ b/common/flatpak-dir.c\n@@ -1795,7 +1795,6 @@\
    \ validate_commit_metadata (GVariant   *commit_data,\n                       \
    \    const char *ref,\n                           const char *required_metadata,\n\
    \                           gsize       required_metadata_size,\n-           \
    \               gboolean   require_xa_metadata,\n                           GError\
    \   **error)\n {\n   g_autoptr(GVariant) commit_metadata = NULL;\n@@ -1814,9 +1813,9\
    \ @@ validate_commit_metadata (GVariant   *commit_data,\n         xa_metadata\
    \ = g_variant_get_string (xa_metadata_v, &xa_metadata_size);\n     }\n \n-  if\
    \ ((xa_metadata == NULL && require_xa_metadata) ||\n-      (xa_metadata != NULL\
    \ && (xa_metadata_size != required_metadata_size ||\n-                       \
    \        memcmp (xa_metadata, required_metadata, xa_metadata_size) != 0)))\n+\
    \  if (xa_metadata == NULL ||\n+      xa_metadata_size != required_metadata_size\
    \ ||\n+      memcmp (xa_metadata, required_metadata, xa_metadata_size) != 0)\n\
    \     {\n       g_set_error (error, G_IO_ERROR, G_IO_ERROR_PERMISSION_DENIED,\n\
    \                    _(\"Commit metadata for %s not matching expected metadata\"\
    ), ref);\n@@ -5848,7 +5847,6 @@ flatpak_dir_pull (FlatpakDir                 \
    \          *self,\n                                      ref,\n              \
    \                        (const char *)g_bytes_get_data (require_metadata, NULL),\n\
    \                                      g_bytes_get_size (require_metadata),\n\
    -                                     TRUE,\n                                \
    \      error))\n         goto out;\n     }\n@@ -8173,7 +8171,6 @@ flatpak_dir_deploy\
    \ (FlatpakDir          *self,\n   g_autoptr(GFile) metadata_file = NULL;\n   g_autofree\
    \ char *metadata_contents = NULL;\n   gsize metadata_size = 0;\n-  gboolean is_oci;\n\
    \   const char *flatpak;\n \n   if (!flatpak_dir_ensure_repo (self, cancellable,\
    \ error))\n@@ -8399,12 +8396,9 @@ flatpak_dir_deploy (FlatpakDir          *self,\n\
    \   /* Check the metadata in the commit to make sure it matches the actual\n \
    \   * deployed metadata, in case we relied on the one in the commit for\n    *\
    \ a decision\n-   * Note: For historical reason we don't enforce commits to contain\
    \ xa.metadata\n-   * since this was lacking in fedora builds.\n    */\n-  is_oci\
    \ = flatpak_dir_get_remote_oci (self, origin);\n   if (!validate_commit_metadata\
    \ (commit_data, flatpak_decomposed_get_ref (ref),\n-                         \
    \        metadata_contents, metadata_size, !is_oci, error))\n+               \
    \                  metadata_contents, metadata_size, error))\n     return FALSE;\n\
    \ \n   dotref = g_file_resolve_relative_path (checkoutdir, \"files/.ref\");"
  - "--- a/common/flatpak-dir.c\n+++ b/common/flatpak-dir.c\n@@ -1794,19 +1794,29\
    \ @@ static gboolean\n validate_commit_metadata (GVariant   *commit_data,\n  \
    \                         const char *ref,\n                           const char\
    \ *required_metadata,\n+                          gsize       required_metadata_size,\n\
    \                           gboolean   require_xa_metadata,\n                \
    \           GError   **error)\n {\n   g_autoptr(GVariant) commit_metadata = NULL;\n\
    +  g_autoptr(GVariant) xa_metadata_v = NULL;\n   const char *xa_metadata = NULL;\n\
    +  gsize xa_metadata_size = 0;\n \n   commit_metadata = g_variant_get_child_value\
    \ (commit_data, 0);\n \n   if (commit_metadata != NULL)\n-    g_variant_lookup\
    \ (commit_metadata, \"xa.metadata\", \"&s\", &xa_metadata);\n+    {\n+      xa_metadata_v\
    \ = g_variant_lookup_value (commit_metadata,\n+                              \
    \                \"xa.metadata\",\n+                                         \
    \     G_VARIANT_TYPE_STRING);\n+      if (xa_metadata_v)\n+        xa_metadata\
    \ = g_variant_get_string (xa_metadata_v, &xa_metadata_size);\n+    }\n \n   if\
    \ ((xa_metadata == NULL && require_xa_metadata) ||\n-      (xa_metadata != NULL\
    \ && g_strcmp0 (required_metadata, xa_metadata) != 0))\n+      (xa_metadata !=\
    \ NULL && (xa_metadata_size != required_metadata_size ||\n+                  \
    \             memcmp (xa_metadata, required_metadata, xa_metadata_size) != 0)))\n\
    \     {\n       g_set_error (error, G_IO_ERROR, G_IO_ERROR_PERMISSION_DENIED,\n\
    \                    _(\"Commit metadata for %s not matching expected metadata\"\
    ), ref);\n@@ -3515,6 +3525,7 @@ upgrade_deploy_data (GBytes             *deploy_data,\n\
    \       g_autoptr(GKeyFile) keyfile = NULL;\n       g_autoptr(GFile) metadata_file\
    \ = NULL;\n       g_autofree char *metadata_contents = NULL;\n+      gsize metadata_size\
    \ = 0;\n       g_autofree char *id = flatpak_decomposed_dup_id (ref);\n \n   \
    \    /* Add fields from commit metadata to deploy */\n@@ -3528,9 +3539,9 @@ upgrade_deploy_data\
    \ (GBytes             *deploy_data,\n       keyfile = g_key_file_new ();\n   \
    \    metadata_file = g_file_resolve_relative_path (deploy_dir, \"metadata\");\n\
    \       if (!g_file_load_contents (metadata_file, cancellable,\n-            \
    \                     &metadata_contents, NULL, NULL, error))\n+             \
    \                    &metadata_contents, &metadata_size, NULL, error))\n     \
    \    return NULL;\n-      if (!g_key_file_load_from_data (keyfile, metadata_contents,\
    \ -1, 0, error))\n+      if (!g_key_file_load_from_data (keyfile, metadata_contents,\
    \ metadata_size, 0, error))\n         return NULL;\n       add_metadata_to_deploy_data\
    \ (&metadata_dict, keyfile);\n \n@@ -5833,8 +5844,13 @@ flatpak_dir_pull (FlatpakDir\
    \                           *self,\n     {\n       g_autoptr(GVariant) commit_data\
    \ = NULL;\n       if (!ostree_repo_load_commit (repo, rev, &commit_data, NULL,\
    \ error) ||\n-          !validate_commit_metadata (commit_data, ref, (const char\
    \ *)g_bytes_get_data (require_metadata, NULL), TRUE, error))\n-        return\
    \ FALSE;\n+          !validate_commit_metadata (commit_data,\n+              \
    \                       ref,\n+                                     (const char\
    \ *)g_bytes_get_data (require_metadata, NULL),\n+                            \
    \         g_bytes_get_size (require_metadata),\n+                            \
    \         TRUE,\n+                                     error))\n+        goto\
    \ out;\n     }\n \n   if (!flatpak_dir_pull_extra_data (self, repo,\n@@ -8156,6\
    \ +8172,7 @@ flatpak_dir_deploy (FlatpakDir          *self,\n   g_auto(GLnxLockFile)\
    \ lock = { 0, };\n   g_autoptr(GFile) metadata_file = NULL;\n   g_autofree char\
    \ *metadata_contents = NULL;\n+  gsize metadata_size = 0;\n   gboolean is_oci;\n\
    \   const char *flatpak;\n \n@@ -8366,11 +8383,12 @@ flatpak_dir_deploy (FlatpakDir\
    \          *self,\n   keyfile = g_key_file_new ();\n   metadata_file = g_file_resolve_relative_path\
    \ (checkoutdir, \"metadata\");\n   if (g_file_load_contents (metadata_file, NULL,\n\
    -                            &metadata_contents, NULL, NULL, NULL))\n+       \
    \                     &metadata_contents,\n+                            &metadata_size,\
    \ NULL, NULL))\n     {\n       if (!g_key_file_load_from_data (keyfile,\n    \
    \                                   metadata_contents,\n-                    \
    \                  -1,\n+                                      metadata_size,\n\
    \                                       0, error))\n         return FALSE;\n \n\
    @@ -8386,7 +8404,7 @@ flatpak_dir_deploy (FlatpakDir          *self,\n    */\n\
    \   is_oci = flatpak_dir_get_remote_oci (self, origin);\n   if (!validate_commit_metadata\
    \ (commit_data, flatpak_decomposed_get_ref (ref),\n-                         \
    \        metadata_contents, !is_oci, error))\n+                              \
    \   metadata_contents, metadata_size, !is_oci, error))\n     return FALSE;\n \n\
    \   dotref = g_file_resolve_relative_path (checkoutdir, \"files/.ref\");"
  - "--- a/common/flatpak-transaction.c\n+++ b/common/flatpak-transaction.c\n@@ -2539,7\
    \ +2539,7 @@ flatpak_transaction_add_ref (FlatpakTransaction             *self,\n\
    \     return FALSE;\n \n   if (external_metadata)\n-    op->external_metadata\
    \ = g_bytes_new (external_metadata, strlen (external_metadata) + 1);\n+    op->external_metadata\
    \ = g_bytes_new (external_metadata, strlen (external_metadata));\n \n   return\
    \ TRUE;\n }\n@@ -2950,7 +2950,7 @@ load_deployed_metadata (FlatpakTransaction\
    \ *self, FlatpakDecomposed *ref, char *\n       return NULL;\n     }\n \n-  return\
    \ g_bytes_new_take (g_steal_pointer (&metadata_contents), metadata_contents_length\
    \ + 1);\n+  return g_bytes_new_take (g_steal_pointer (&metadata_contents), metadata_contents_length);\n\
    \ }\n \n static void\n@@ -3051,7 +3051,7 @@ resolve_op_from_commit (FlatpakTransaction\
    \ *self,\n   if (xa_metadata == NULL)\n     g_message (\"Warning: No xa.metadata\
    \ in local commit %s ref %s\", checksum, flatpak_decomposed_get_ref (op->ref));\n\
    \   else\n-    metadata_bytes = g_bytes_new (xa_metadata, strlen (xa_metadata)\
    \ + 1);\n+    metadata_bytes = g_bytes_new (xa_metadata, strlen (xa_metadata));\n\
    \ \n   if (g_variant_lookup (commit_metadata, \"xa.download-size\", \"t\", &download_size))\n\
    \     op->download_size = GUINT64_FROM_BE (download_size);\n@@ -3091,7 +3091,7\
    \ @@ try_resolve_op_from_metadata (FlatpakTransaction *self,\n               \
    \                            &download_size, &installed_size, &metadata, NULL))\n\
    \       return FALSE;\n \n-  metadata_bytes = g_bytes_new (metadata, strlen (metadata)\
    \ + 1);\n+  metadata_bytes = g_bytes_new (metadata, strlen (metadata));\n \n \
    \  if (flatpak_remote_state_lookup_ref (state, flatpak_decomposed_get_ref (op->ref),\n\
    \                                        NULL, NULL, &info, NULL, NULL))"
  - "--- a/common/flatpak-utils.c\n+++ b/common/flatpak-utils.c\n@@ -6667,6 +6667,7\
    \ @@ flatpak_pull_from_bundle (OstreeRepo   *repo,\n                         \
    \  GCancellable *cancellable,\n                           GError      **error)\n\
    \ {\n+  gsize metadata_size = 0;\n   g_autofree char *metadata_contents = NULL;\n\
    \   g_autofree char *to_checksum = NULL;\n   g_autoptr(GFile) root = NULL;\n@@\
    \ -6683,6 +6684,8 @@ flatpak_pull_from_bundle (OstreeRepo   *repo,\n   if (metadata\
    \ == NULL)\n     return FALSE;\n \n+  metadata_size = strlen (metadata_contents);\n\
    +\n   if (!ostree_repo_get_remote_option (repo, remote, \"collection-id\", NULL,\n\
    \                                       &remote_collection_id, NULL))\n     remote_collection_id\
    \ = NULL;\n@@ -6752,12 +6755,10 @@ flatpak_pull_from_bundle (OstreeRepo   *repo,\n\
    \                                   cancellable, error) < 0)\n         return\
    \ FALSE;\n \n-      /* Null terminate */\n-      g_output_stream_write (G_OUTPUT_STREAM\
    \ (data_stream), \"\\0\", 1, NULL, NULL);\n-\n       metadata_valid =\n      \
    \   metadata_contents != NULL &&\n-        strcmp (metadata_contents, g_memory_output_stream_get_data\
    \ (data_stream)) == 0;\n+        metadata_size == g_memory_output_stream_get_data_size\
    \ (data_stream) &&\n+        memcmp (metadata_contents, g_memory_output_stream_get_data\
    \ (data_stream), metadata_size) == 0;\n     }\n   else\n     {"
  - "--- a/common/flatpak-transaction.c\n+++ b/common/flatpak-transaction.c\n@@ -2970,12\
    \ +2970,13 @@ emit_eol_and_maybe_skip (FlatpakTransaction          *self,\n  \
    \ g_signal_emit (self, signals[END_OF_LIFED_WITH_REBASE], 0, op->remote, flatpak_decomposed_get_ref\
    \ (op->ref), op->eol, op->eol_rebase, previous_ids, &op->skip);\n }\n \n-static\
    \ void\n+static gboolean\n mark_op_resolved (FlatpakTransactionOperation *op,\n\
    \                   const char                  *commit,\n                   GFile\
    \                       *sideload_path,\n                   GBytes           \
    \           *metadata,\n-                  GBytes                      *old_metadata)\n\
    +                  GBytes                      *old_metadata,\n+             \
    \     GError                     **error)\n {\n   g_debug (\"marking op %s:%s\
    \ resolved to %s\", kind_to_str (op->kind), flatpak_decomposed_get_ref (op->ref),\
    \ commit ? commit : \"-\");\n \n@@ -2997,13 +2998,12 @@ mark_op_resolved (FlatpakTransactionOperation\
    \ *op,\n   if (metadata)\n     {\n       g_autoptr(GKeyFile) metakey = g_key_file_new\
    \ ();\n-      if (g_key_file_load_from_bytes (metakey, metadata, G_KEY_FILE_NONE,\
    \ NULL))\n-        {\n-          op->resolved_metadata = g_bytes_ref (metadata);\n\
    -          op->resolved_metakey = g_steal_pointer (&metakey);\n-        }\n- \
    \     else\n-        g_message (\"Warning: Failed to parse metadata for %s\\n\"\
    , flatpak_decomposed_get_ref (op->ref));\n+      if (!g_key_file_load_from_bytes\
    \ (metakey, metadata, G_KEY_FILE_NONE, NULL))\n+        return flatpak_fail_error\
    \ (error, FLATPAK_ERROR_INVALID_DATA,\n+                                   \"\
    Metadata for %s is invalid\", flatpak_decomposed_get_ref (op->ref));\n+\n+   \
    \   op->resolved_metadata = g_bytes_ref (metadata);\n+      op->resolved_metakey\
    \ = g_steal_pointer (&metakey);\n     }\n   if (old_metadata)\n     {\n@@ -3014,31\
    \ +3014,40 @@ mark_op_resolved (FlatpakTransactionOperation *op,\n           op->resolved_old_metakey\
    \ = g_steal_pointer (&metakey);\n         }\n       else\n-        g_message (\"\
    Warning: Failed to parse old metadata for %s\\n\", flatpak_decomposed_get_ref\
    \ (op->ref));\n+        {\n+          /* This shouldn't happen, but a NULL old\
    \ metadata is safe (all permisssions are considered new) */\n+          g_message\
    \ (\"Warning: Failed to parse old metadata for %s\\n\", flatpak_decomposed_get_ref\
    \ (op->ref));\n+        }\n     }\n+\n+  return TRUE;\n }\n \n-static void\n+static\
    \ gboolean\n resolve_op_end (FlatpakTransaction *self,\n                 FlatpakTransactionOperation\
    \ *op,\n                 const char *checksum,\n                 GFile *sideload_path,\n\
    -                GBytes *metadata_bytes)\n+                GBytes *metadata_bytes,\n\
    +                GError **error)\n {\n   g_autoptr(GBytes) old_metadata_bytes\
    \ = NULL;\n \n   old_metadata_bytes = load_deployed_metadata (self, op->ref, NULL,\
    \ NULL);\n-  mark_op_resolved (op, checksum, sideload_path, metadata_bytes, old_metadata_bytes);\n\
    +  if (!mark_op_resolved (op, checksum, sideload_path, metadata_bytes, old_metadata_bytes,\
    \ error))\n+    return FALSE;\n   emit_eol_and_maybe_skip (self, op);\n+  return\
    \ TRUE;\n  }\n \n \n-static void\n+static gboolean\n resolve_op_from_commit (FlatpakTransaction\
    \ *self,\n                         FlatpakTransactionOperation *op,\n        \
    \                 const char *checksum,\n                         GFile *sideload_path,\n\
    -                        GVariant *commit_data)\n+                        GVariant\
    \ *commit_data,\n+                        GError **error)\n {\n   g_autoptr(GBytes)\
    \ metadata_bytes = NULL;\n   g_autoptr(GVariant) commit_metadata = NULL;\n@@ -3049,9\
    \ +3058,11 @@ resolve_op_from_commit (FlatpakTransaction *self,\n   commit_metadata\
    \ = g_variant_get_child_value (commit_data, 0);\n   g_variant_lookup (commit_metadata,\
    \ \"xa.metadata\", \"&s\", &xa_metadata);\n   if (xa_metadata == NULL)\n-    g_message\
    \ (\"Warning: No xa.metadata in local commit %s ref %s\", checksum, flatpak_decomposed_get_ref\
    \ (op->ref));\n-  else\n-    metadata_bytes = g_bytes_new (xa_metadata, strlen\
    \ (xa_metadata));\n+    return flatpak_fail_error (error, FLATPAK_ERROR_INVALID_DATA,\n\
    +                               \"No xa.metadata in local commit %s ref %s\",\n\
    +                               checksum, flatpak_decomposed_get_ref (op->ref));\n\
    +\n+  metadata_bytes = g_bytes_new (xa_metadata, strlen (xa_metadata));\n \n \
    \  if (g_variant_lookup (commit_metadata, \"xa.download-size\", \"t\", &download_size))\n\
    \     op->download_size = GUINT64_FROM_BE (download_size);\n@@ -3061,15 +3072,19\
    \ @@ resolve_op_from_commit (FlatpakTransaction *self,\n   g_variant_lookup (commit_metadata,\
    \ OSTREE_COMMIT_META_KEY_ENDOFLIFE, \"s\", &op->eol);\n   g_variant_lookup (commit_metadata,\
    \ OSTREE_COMMIT_META_KEY_ENDOFLIFE_REBASE, \"s\", &op->eol_rebase);\n \n-  resolve_op_end\
    \ (self, op, checksum, sideload_path, metadata_bytes);\n+  return resolve_op_end\
    \ (self, op, checksum, sideload_path, metadata_bytes, error);\n }\n \n+/* NOTE:\
    \ In case of non-available summary this returns FALSE with a\n+ * NULL error,\
    \ but for other error cases it will be set.\n+ */\n static gboolean\n try_resolve_op_from_metadata\
    \ (FlatpakTransaction *self,\n                               FlatpakTransactionOperation\
    \ *op,\n                               const char *checksum,\n               \
    \                GFile *sideload_path,\n-                              FlatpakRemoteState\
    \ *state)\n+                              FlatpakRemoteState *state,\n+      \
    \                        GError **error)\n {\n   g_autoptr(GBytes) metadata_bytes\
    \ = NULL;\n   guint64 download_size = 0;\n@@ -3109,8 +3124,7 @@ try_resolve_op_from_metadata\
    \ (FlatpakTransaction *self,\n       op->token_type = GINT32_FROM_LE (var_metadata_lookup_int32\
    \ (sparse_cache, FLATPAK_SPARSE_CACHE_KEY_TOKEN_TYPE, op->token_type));\n    \
    \ }\n \n-  resolve_op_end (self, op, checksum, sideload_path, metadata_bytes);\n\
    -  return TRUE;\n+  return resolve_op_end (self, op, checksum, sideload_path,\
    \ metadata_bytes, error);\n }\n \n static gboolean\n@@ -3153,7 +3167,8 @@ resolve_ops\
    \ (FlatpakTransaction *self,\n            * checksum we got was the version already\
    \ installed.\n            */\n           g_assert (op->resolved_commit != NULL);\n\
    -          mark_op_resolved (op, op->resolved_commit, NULL, NULL, NULL);\n+  \
    \        if (!mark_op_resolved (op, op->resolved_commit, NULL, NULL, NULL, error))\n\
    +            return FALSE;\n           continue;\n         }\n \n@@ -3167,14 +3182,16\
    \ @@ resolve_ops (FlatpakTransaction *self,\n               op->skip = TRUE;\n\
    \               continue;\n             }\n-          mark_op_resolved (op, checksum,\
    \ NULL, metadata_bytes, NULL);\n+          if (!mark_op_resolved (op, checksum,\
    \ NULL, metadata_bytes, NULL, error))\n+            return FALSE;\n          \
    \ continue;\n         }\n \n       if (op->kind == FLATPAK_TRANSACTION_OPERATION_INSTALL_BUNDLE)\n\
    \         {\n           g_assert (op->commit != NULL);\n-          mark_op_resolved\
    \ (op, op->commit, NULL, op->external_metadata, NULL);\n+          if (!mark_op_resolved\
    \ (op, op->commit, NULL, op->external_metadata, NULL, error))\n+            return\
    \ FALSE;\n           continue;\n         }\n \n@@ -3205,7 +3222,8 @@ resolve_ops\
    \ (FlatpakTransaction *self,\n           if (commit_data == NULL)\n          \
    \   return FALSE;\n \n-          resolve_op_from_commit (self, op, checksum, NULL,\
    \ commit_data);\n+          if (!resolve_op_from_commit (self, op, checksum, NULL,\
    \ commit_data, error))\n+            return FALSE;\n         }\n       else\n\
    \         {\n@@ -3264,9 +3282,16 @@ resolve_ops (FlatpakTransaction *self,\n \
    \            }\n \n           /* First try to resolve via metadata (if remote\
    \ is available and its metadata matches the commit version) */\n-          if\
    \ (!try_resolve_op_from_metadata (self, op, checksum, sideload_path, state))\n\
    +          if (!try_resolve_op_from_metadata (self, op, checksum, sideload_path,\
    \ state, &local_error))\n             {\n-              /* Else try to load the\
    \ commit object.\n+              if (local_error)\n+                {\n+     \
    \             /* Actual error, not just missing from summary */\n+           \
    \       g_propagate_error (error, g_steal_pointer (&local_error));\n+        \
    \          return FALSE;\n+                }\n+\n+              /* Missing from\
    \ summary, try to load the commit object.\n                * Note, we don't have\
    \ a token here, so this will not work for authenticated apps.\n              \
    \  * We handle this by catching the 401 http status and retrying. */\n       \
    \        g_autoptr(GVariant) commit_data = NULL;\n@@ -3302,7 +3327,8 @@ resolve_ops\
    \ (FlatpakTransaction *self,\n                   return FALSE;\n             \
    \    }\n \n-              resolve_op_from_commit (self, op, checksum, sideload_path,\
    \ commit_data);\n+              if (!resolve_op_from_commit (self, op, checksum,\
    \ sideload_path, commit_data, error))\n+                return FALSE;\n      \
    \       }\n         }\n     }"
  identifiers:
  - CVE-2021-43860
  - CWE-276
  overview: Flatpak is a Linux application sandboxing and distribution framework.
    Prior to versions 1.12.3 and 1.10.6, Flatpak doesn't properly validate that the
    permissions displayed to the user for an app at install time match the actual
    permissions granted to the app at runtime, in the case that there's a null byte
    in the metadata file of an app. Therefore apps can grant themselves permissions
    without the consent of the user. Flatpak shows permissions to the user during
    install by reading them from the "xa.metadata" key in the commit metadata. This
    cannot contain a null terminator, because it is an untrusted GVariant. Flatpak
    compares these permissions to the *actual* metadata, from the "metadata" file
    to ensure it wasn't lied to. However, the actual metadata contents are loaded
    in several places where they are read as simple C-style strings. That means that,
    if the metadata file includes a null terminator, only the content of the file
    from *before* the terminator gets compared to xa.metadata. Thus, any permissions
    that appear in the metadata file after a null terminator are applied at runtime
    but not shown to the user. So maliciously crafted apps can give themselves hidden
    permissions. Users who have Flatpaks installed from untrusted sources are at risk
    in case the Flatpak has a maliciously crafted metadata file, either initially
    or in an update. This issue is patched in versions 1.12.3 and 1.10.6. As a workaround,
    users can manually check the permissions of installed apps by checking the metadata
    file or the xa.metadata key on the commit metadata.
  references:
  - source: security-advisories@github.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/flatpak/flatpak/commit/54ec1a482dfc668127eaae57f135e6a8e0bc52da
  - source: security-advisories@github.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/flatpak/flatpak/commit/65cbfac982cb1c83993a9e19aa424daee8e9f042
  - source: security-advisories@github.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/flatpak/flatpak/commit/93357d357119093804df05acc32ff335839c6451
  - source: security-advisories@github.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/flatpak/flatpak/commit/ba818f504c926baaf6e362be8159cfacf994310e
  - source: security-advisories@github.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/flatpak/flatpak/commit/d9a8f9d8ccc0b7c1135d0ecde006a75d25f66aee
  - source: security-advisories@github.com
    tags:
    - Release Notes
    - Third Party Advisory
    url: https://github.com/flatpak/flatpak/releases/tag/1.10.6
  - source: security-advisories@github.com
    tags:
    - Release Notes
    - Third Party Advisory
    url: https://github.com/flatpak/flatpak/releases/tag/1.12.3
  - source: security-advisories@github.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/flatpak/flatpak/security/advisories/GHSA-qpjc-vq3c-572j
  - source: security-advisories@github.com
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/APFTBYGJJVJPFVHRXUW5PII5XOAFI4KH/
  - source: security-advisories@github.com
    url: https://security.gentoo.org/glsa/202312-12
  - source: security-advisories@github.com
    tags:
    - Third Party Advisory
    url: https://www.debian.org/security/2022/dsa-5049
  title: Flatpak is a Linux application sandboxing and distribution framework. Prior
    to versions 1.12.3 and 1.10.6, Flatpak doesn't properly validate that the permissions
    displayed to the user for an app at install time match the actual permissions
    granted to the app at runtime, in the case that there's a null byte in the metadata
    file of an app. Therefore apps can grant themselves permissions without the consent
    of the user. Flatpak shows permissions to the user during install by reading them
    from the "xa.metadata" key in the commit metadata. This cannot contain a null
    terminator, because it is an untrusted GVariant. Flatpak compares these permissions
    to the *actual* metadata, from the "metadata" file to ensure it wasn't lied to.
    However, the actual metadata contents are loaded in several places where they
    are read as simple C-style strings. That means that, if the metadata file includes
    a null terminator, only the content of the file from *before* the terminator gets
    compared to xa.metadata. Thus, any permissions that appear in the metadata file
    after a null terminator are applied at runtime but not shown to the user. So maliciously
    crafted apps can give themselves hidden permissions. Users who have Flatpaks installed
    from untrusted sources are at risk in case the Flatpak has a maliciously crafted
    metadata file, either initially or in an update. This issue is patched in versions
    1.12.3 and 1.10.6. As a workaround, users can manually check the permissions of
    installed apps by checking the metadata file or the xa.metadata key on the commit
    metadata.
- diff_content:
  - "--- a/src/media_tools/isom_hinter.c\n+++ b/src/media_tools/isom_hinter.c\n@@\
    \ -1241,7 +1241,7 @@ GF_Err gf_hinter_finalize(GF_ISOFile *file, GF_SDP_IODProfile\
    \ IOD_Profile, u32 b\n \t\tif (gf_isom_get_sample_count(file, sceneT)==1) {\n\
    \ \t\t\tsamp = gf_isom_get_sample(file, sceneT, 1, &descIndex);\n \t\t\tif (samp\
    \ && gf_hinter_can_embbed_data(samp->data, samp->dataLength, GF_STREAM_SCENE))\
    \ {\n-\n+\t\t\t\tInitSL_NULL(&slc);\n \t\t\t\tslc.timeScale = slc.timestampResolution\
    \ = gf_isom_get_media_timescale(file, sceneT);\n \t\t\t\tslc.OCRResolution = 1000;\n\
    \ \t\t\t\tslc.startCTS = samp->DTS+samp->CTS_Offset;"
  identifiers:
  - CVE-2021-40567
  - NVD-CWE-noinfo
  overview: Segmentation fault vulnerability exists in Gpac through 1.0.1 via the
    gf_odf_size_descriptor function in desc_private.c when using mp4box, which causes
    a denial of service.
  references:
  - source: cve@mitre.org
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/gpac/gpac/commit/f5a038e6893019ee471b6a57490cf7a495673816
  - source: cve@mitre.org
    tags:
    - Exploit
    - Issue Tracking
    - Third Party Advisory
    url: https://github.com/gpac/gpac/issues/1889
  - source: cve@mitre.org
    url: https://www.debian.org/security/2023/dsa-5411
  title: Segmentation fault vulnerability exists in Gpac through 1.0.1 via the gf_odf_size_descriptor
    function in desc_private.c when using mp4box, which causes a denial of service.
- diff_content:
  - "--- a/src/media_tools/av_parsers.c\n+++ b/src/media_tools/av_parsers.c\n@@ -4690,20\
    \ +4690,23 @@ u32 gf_bs_read_ue_log_idx3(GF_BitStream *bs, const char *fname,\
    \ s32 idx1, s32 id\n \tu32 bits = 0;\n \tfor (code=0; !code; nb_lead++) {\n \t\
    \tif (nb_lead>=32) {\n-\t\t\t//gf_bs_read_int keeps returning 0 on EOS, so if\
    \ no more bits available, rbsp was truncated otherwise code is broken in rbsp)\n\
    -\t\t\t//we only test once nb_lead>=32 to avoid testing at each bit read\n-\t\t\
    \tif (!gf_bs_available(bs)) {\n-\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"\
    [Core] exp-golomb read failed, not enough bits in bitstream !\\n\"));\n-\t\t\t\
    } else {\n-\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[Core] corrupted exp-golomb\
    \ code, %d leading zeros, max 31 allowed !\\n\", nb_lead));\n-\t\t\t}\n-\t\t\t\
    return 0;\n+\t\t\tbreak;\n \t\t}\n-\n \t\tcode = gf_bs_read_int(bs, 1);\n \t\t\
    bits++;\n \t}\n \n+\tif (nb_lead>=32) {\n+\t\t//gf_bs_read_int keeps returning\
    \ 0 on EOS, so if no more bits available, rbsp was truncated otherwise code is\
    \ broken in rbsp)\n+\t\t//we only test once nb_lead>=32 to avoid testing at each\
    \ bit read\n+\t\tif (!gf_bs_available(bs)) {\n+\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING,\
    \ (\"[Core] exp-golomb read failed, not enough bits in bitstream !\\n\"));\n+\t\
    \t} else {\n+\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[Core] corrupted exp-golomb\
    \ code, %d leading zeros, max 31 allowed !\\n\", nb_lead));\n+\t\t}\n+\t\treturn\
    \ 0;\n+\t}\n+\n \tif (nb_lead) {\n \t\tu32 leads=1;\n \t\tval = gf_bs_read_int(bs,\
    \ nb_lead);\n@@ -5785,7 +5788,7 @@ static s32 svc_parse_slice(GF_BitStream *bs,\
    \ AVCState *avc, AVCSliceInfo *si)\n \tif (si->slice_type > 9) return -1;\n \n\
    \ \tpps_id = gf_bs_read_ue_log(bs, \"pps_id\");\n-\tif (pps_id > 255)\n+\tif ((pps_id<0)\
    \ || (pps_id > 255))\n \t\treturn -1;\n \tsi->pps = &avc->pps[pps_id];\n \tsi->pps->id\
    \ = pps_id;"
  identifiers:
  - CVE-2021-40568
  - CWE-120
  overview: A buffer overflow vulnerability exists in Gpac through 1.0.1 via a malformed
    MP4 file in the svc_parse_slice function in av_parsers.c, which allows attackers
    to cause a denial of service, even code execution and escalation of privileges.
  references:
  - source: cve@mitre.org
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/gpac/gpac/commit/f1ae01d745200a258cdf62622f71754c37cb6c30
  - source: cve@mitre.org
    tags:
    - Exploit
    - Issue Tracking
    - Third Party Advisory
    url: https://github.com/gpac/gpac/issues/1900
  - source: cve@mitre.org
    url: https://www.debian.org/security/2023/dsa-5411
  title: A buffer overflow vulnerability exists in Gpac through 1.0.1 via a malformed
    MP4 file in the svc_parse_slice function in av_parsers.c, which allows attackers
    to cause a denial of service, even code execution and escalation of privileges.
- diff_content:
  - "--- a/src/isomedia/box_code_meta.c\n+++ b/src/isomedia/box_code_meta.c\n@@ -282,7\
    \ +282,8 @@ GF_Err iloc_box_read(GF_Box *s, GF_BitStream *bs)\n \t}\n \n \tfor\
    \ (i = 0; i < item_count; i++) {\n-\t\tGF_ItemLocationEntry *location_entry =\
    \ (GF_ItemLocationEntry *)gf_malloc(sizeof(GF_ItemLocationEntry));\n+\t\tGF_ItemLocationEntry\
    \ *location_entry;\n+\t\tGF_SAFEALLOC(location_entry, GF_ItemLocationEntry);\n\
    \ \t\tif (!location_entry) return GF_OUT_OF_MEM;\n \n \t\tgf_list_add(ptr->location_entries,\
    \ location_entry);\n@@ -311,7 +312,8 @@ GF_Err iloc_box_read(GF_Box *s, GF_BitStream\
    \ *bs)\n \t\textent_count = gf_bs_read_u16(bs);\n \t\tlocation_entry->extent_entries\
    \ = gf_list_new();\n \t\tfor (j = 0; j < extent_count; j++) {\n-\t\t\tGF_ItemExtentEntry\
    \ *extent_entry = (GF_ItemExtentEntry *)gf_malloc(sizeof(GF_ItemExtentEntry));\n\
    +\t\t\tGF_ItemExtentEntry *extent_entry;\n+\t\t\tGF_SAFEALLOC(extent_entry, GF_ItemExtentEntry);\n\
    \ \t\t\tif (!extent_entry) return GF_OUT_OF_MEM;\n \t\t\t\n \t\t\tgf_list_add(location_entry->extent_entries,\
    \ extent_entry);"
  identifiers:
  - CVE-2021-40569
  - CWE-415
  overview: The binary MP4Box in Gpac through 1.0.1 has a double-free vulnerability
    in the iloc_entry_del funciton in box_code_meta.c, which allows attackers to cause
    a denial of service.
  references:
  - source: cve@mitre.org
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/gpac/gpac/commit/b03c9f252526bb42fbd1b87b9f5e339c3cf2390a
  - source: cve@mitre.org
    tags:
    - Exploit
    - Issue Tracking
    - Third Party Advisory
    url: https://github.com/gpac/gpac/issues/1890
  - source: cve@mitre.org
    url: https://www.debian.org/security/2023/dsa-5411
  title: The binary MP4Box in Gpac through 1.0.1 has a double-free vulnerability in
    the iloc_entry_del funciton in box_code_meta.c, which allows attackers to cause
    a denial of service.
- diff_content:
  - "--- a/src/media_tools/av_parsers.c\n+++ b/src/media_tools/av_parsers.c\n@@ -5198,6\
    \ +5198,7 @@ static s32 gf_avc_read_sps_bs_internal(GF_BitStream *bs, AVCState\
    \ *avc, u32 subs\n \t\tsps->offset_for_top_to_bottom_field = gf_bs_read_se_log(bs,\
    \ \"offset_for_top_to_bottom_field\");\n \t\tsps->poc_cycle_length = gf_bs_read_ue_log(bs,\
    \ \"poc_cycle_length\");\n \t\tif (sps->poc_cycle_length > GF_ARRAY_LENGTH(sps->offset_for_ref_frame))\
    \ {\n+\t\t\tsps->poc_cycle_length = 255;\n \t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING,\
    \ (\"[avc-h264] offset_for_ref_frame overflow from poc_cycle_length\\n\"));\n\
    \ \t\t\treturn -1;\n \t\t}"
  identifiers:
  - CVE-2021-40570
  - CWE-415
  overview: The binary MP4Box in Gpac 1.0.1 has a double-free vulnerability in the
    avc_compute_poc function in av_parsers.c, which allows attackers to cause a denial
    of service, even code execution and escalation of privileges.
  references:
  - source: cve@mitre.org
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/gpac/gpac/commit/04dbf08bff4d61948bab80c3f9096ecc60c7f302
  - source: cve@mitre.org
    tags:
    - Exploit
    - Issue Tracking
    - Third Party Advisory
    url: https://github.com/gpac/gpac/issues/1899
  - source: cve@mitre.org
    url: https://www.debian.org/security/2023/dsa-5411
  title: The binary MP4Box in Gpac 1.0.1 has a double-free vulnerability in the avc_compute_poc
    function in av_parsers.c, which allows attackers to cause a denial of service,
    even code execution and escalation of privileges.
- diff_content:
  - "--- a/src/odf/descriptors.c\n+++ b/src/odf/descriptors.c\n@@ -1613,6 +1613,7\
    \ @@ GF_AV1Config *gf_odf_av1_cfg_read_bs_size(GF_BitStream *bs, u32 size)\n \t\
    \tsize -= (u32) obu_size;\n \t}\n \tgf_av1_reset_state(& state, GF_TRUE);\n+\t\
    gf_bs_align(bs);\n \treturn cfg;\n #else\n \treturn NULL;"
  identifiers:
  - CVE-2021-40571
  - CWE-415
  overview: The binary MP4Box in Gpac 1.0.1 has a double-free vulnerability in the
    ilst_box_read function in box_code_apple.c, which allows attackers to cause a
    denial of service, even code execution and escalation of privileges.
  references:
  - source: cve@mitre.org
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/gpac/gpac/commit/a69b567b8c95c72f9560c873c5ab348be058f340
  - source: cve@mitre.org
    tags:
    - Exploit
    - Issue Tracking
    - Third Party Advisory
    url: https://github.com/gpac/gpac/issues/1895
  - source: cve@mitre.org
    url: https://www.debian.org/security/2023/dsa-5411
  title: The binary MP4Box in Gpac 1.0.1 has a double-free vulnerability in the ilst_box_read
    function in box_code_apple.c, which allows attackers to cause a denial of service,
    even code execution and escalation of privileges.
- diff_content:
  - "--- a/src/media_tools/av_parsers.c\n+++ b/src/media_tools/av_parsers.c\n@@ -3980,10\
    \ +3980,8 @@ void gf_av1_reset_state(AV1State *state, Bool is_destroy)\n \t\t\
    gf_list_del(l1);\n \t\tgf_list_del(l2);\n \t\tif (state->bs) {\n-\t\t\tif (gf_bs_get_position(state->bs))\
    \ {\n-\t\t\t\tu32 size;\n-\t\t\t\tgf_bs_get_content_no_truncate(state->bs, &state->frame_obus,\
    \ &size, &state->frame_obus_alloc);\n-\t\t\t}\n+\t\t\tu32 size;\n+\t\t\tgf_bs_get_content_no_truncate(state->bs,\
    \ &state->frame_obus, &size, &state->frame_obus_alloc);\n \t\t\tgf_bs_del(state->bs);\n\
    \ \t\t}\n \t\tstate->bs = NULL;"
  identifiers:
  - CVE-2021-40572
  - CWE-415
  overview: The binary MP4Box in Gpac 1.0.1 has a double-free bug in the av1dmx_finalize
    function in reframe_av1.c, which allows attackers to cause a denial of service.
  references:
  - source: cve@mitre.org
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/gpac/gpac/commit/7bb1b4a4dd23c885f9db9f577dfe79ecc5433109
  - source: cve@mitre.org
    tags:
    - Exploit
    - Issue Tracking
    - Third Party Advisory
    url: https://github.com/gpac/gpac/issues/1893
  - source: cve@mitre.org
    url: https://www.debian.org/security/2023/dsa-5411
  title: The binary MP4Box in Gpac 1.0.1 has a double-free bug in the av1dmx_finalize
    function in reframe_av1.c, which allows attackers to cause a denial of service.
- diff_content:
  - "--- a/src/isomedia/box_code_meta.c\n+++ b/src/isomedia/box_code_meta.c\n@@ -282,7\
    \ +282,8 @@ GF_Err iloc_box_read(GF_Box *s, GF_BitStream *bs)\n \t}\n \n \tfor\
    \ (i = 0; i < item_count; i++) {\n-\t\tGF_ItemLocationEntry *location_entry =\
    \ (GF_ItemLocationEntry *)gf_malloc(sizeof(GF_ItemLocationEntry));\n+\t\tGF_ItemLocationEntry\
    \ *location_entry;\n+\t\tGF_SAFEALLOC(location_entry, GF_ItemLocationEntry);\n\
    \ \t\tif (!location_entry) return GF_OUT_OF_MEM;\n \n \t\tgf_list_add(ptr->location_entries,\
    \ location_entry);\n@@ -311,7 +312,8 @@ GF_Err iloc_box_read(GF_Box *s, GF_BitStream\
    \ *bs)\n \t\textent_count = gf_bs_read_u16(bs);\n \t\tlocation_entry->extent_entries\
    \ = gf_list_new();\n \t\tfor (j = 0; j < extent_count; j++) {\n-\t\t\tGF_ItemExtentEntry\
    \ *extent_entry = (GF_ItemExtentEntry *)gf_malloc(sizeof(GF_ItemExtentEntry));\n\
    +\t\t\tGF_ItemExtentEntry *extent_entry;\n+\t\t\tGF_SAFEALLOC(extent_entry, GF_ItemExtentEntry);\n\
    \ \t\t\tif (!extent_entry) return GF_OUT_OF_MEM;\n \t\t\t\n \t\t\tgf_list_add(location_entry->extent_entries,\
    \ extent_entry);"
  identifiers:
  - CVE-2021-40573
  - CWE-415
  overview: The binary MP4Box in Gpac 1.0.1 has a double-free vulnerability in the
    gf_list_del function in list.c, which allows attackers to cause a denial of service.
  references:
  - source: cve@mitre.org
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/gpac/gpac/commit/b03c9f252526bb42fbd1b87b9f5e339c3cf2390a
  - source: cve@mitre.org
    tags:
    - Exploit
    - Issue Tracking
    - Third Party Advisory
    url: https://github.com/gpac/gpac/issues/1891
  title: The binary MP4Box in Gpac 1.0.1 has a double-free vulnerability in the gf_list_del
    function in list.c, which allows attackers to cause a denial of service.
- diff_content:
  - "--- a/src/filters/load_text.c\n+++ b/src/filters/load_text.c\n@@ -255,7 +255,7\
    \ @@ char *gf_text_get_utf8_line(char *szLine, u32 lineSize, FILE *txt_in, s32\
    \ unicod\n {\n \tu32 i, j, len;\n \tchar *sOK;\n-\tchar szLineConv[1024];\n+\t\
    char szLineConv[2048];\n \tunsigned short *sptr;\n \n \tmemset(szLine, 0, sizeof(char)*lineSize);\n\
    @@ -328,7 +328,7 @@ char *gf_text_get_utf8_line(char *szLine, u32 lineSize, FILE\
    \ *txt_in, s32 unicod\n \t\t}\n \t}\n \tsptr = (u16 *)szLine;\n-\ti = (u32) gf_utf8_wcstombs(szLineConv,\
    \ 1024, (const unsigned short **) &sptr);\n+\ti = (u32) gf_utf8_wcstombs(szLineConv,\
    \ 2048, (const unsigned short **) &sptr);\n \tszLineConv[i] = 0;\n \tstrcpy(szLine,\
    \ szLineConv);\n \t/*this is ugly indeed: since input is UTF16-LE, there are many\
    \ chances the gf_fgets never reads the \\0 after a \\n*/\n@@ -2338,6 +2338,8 @@\
    \ static GF_Err gf_text_process_sub(GF_Filter *filter, GF_TXTIn *ctx)\n \t\twhile\
    \ (szLine[i+1] && szLine[i+1]!='}') {\n \t\t\tszTime[i] = szLine[i+1];\n \t\t\t\
    i++;\n+\t\t\tif (i>=19)\n+\t\t\t\tbreak;\n \t\t}\n \t\tszTime[i] = 0;\n \t\tctx->start\
    \ = atoi(szTime);"
  identifiers:
  - CVE-2021-40574
  - CWE-415
  overview: The binary MP4Box in Gpac 1.0.1 has a double-free vulnerability in the
    gf_text_get_utf8_line function in load_text.c, which allows attackers to cause
    a denial of service, even code execution and escalation of privileges.
  references:
  - source: cve@mitre.org
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/gpac/gpac/commit/30ac5e5236b790accd1f25347eebf2dc8c6c1bcb
  - source: cve@mitre.org
    tags:
    - Exploit
    - Issue Tracking
    - Third Party Advisory
    url: https://github.com/gpac/gpac/issues/1897
  - source: cve@mitre.org
    url: https://www.debian.org/security/2023/dsa-5411
  title: The binary MP4Box in Gpac 1.0.1 has a double-free vulnerability in the gf_text_get_utf8_line
    function in load_text.c, which allows attackers to cause a denial of service,
    even code execution and escalation of privileges.
- diff_content:
  - "--- a/src/filters/reframe_mpgvid.c\n+++ b/src/filters/reframe_mpgvid.c\n@@ -784,8\
    \ +784,14 @@ GF_Err mpgviddmx_process(GF_Filter *filter)\n \t\t\tmpgviddmx_enqueue_or_dispatch(ctx,\
    \ dst_pck, GF_FALSE, GF_FALSE);\n \t\t}\n \n-\t\t//parse headers\n+\t\t//not enough\
    \ bytes to parse start code\n+\t\tif (remain<5) {\n+\t\t\tmemcpy(ctx->hdr_store,\
    \ start, remain);\n+\t\t\tctx->bytes_in_header = remain;\n+\t\t\tbreak;\n+\t\t\
    }\n \n+\t\t//parse headers\n \t\t//we have a start code loaded, eg the data packet\
    \ does not have a full start code at the beginning\n \t\tif (sc_type_forced) {\n\
    \ \t\t\tgf_bs_reassign_buffer(ctx->bs, start + hdr_offset, remain - hdr_offset);"
  identifiers:
  - CVE-2021-40575
  - CWE-476
  overview: The binary MP4Box in Gpac 1.0.1 has a null pointer dereference vulnerability
    in the mpgviddmx_process function in reframe_mpgvid.c, which allows attackers
    to cause a denial of service. This vulnerability is possibly due to an incomplete
    fix for CVE-2021-40566.
  references:
  - source: cve@mitre.org
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/gpac/gpac/commit/5f2c2a16d30229b6241f02fa28e3d6b810d64858
  - source: cve@mitre.org
    tags:
    - Exploit
    - Issue Tracking
    - Third Party Advisory
    url: https://github.com/gpac/gpac/issues/1905
  - source: cve@mitre.org
    url: https://www.debian.org/security/2023/dsa-5411
  title: The binary MP4Box in Gpac 1.0.1 has a null pointer dereference vulnerability
    in the mpgviddmx_process function in reframe_mpgvid.c, which allows attackers
    to cause a denial of service. This vulnerability is possibly due to an incomplete
    fix for CVE-2021-40566.
- diff_content:
  - "--- a/src/isomedia/hint_track.c\n+++ b/src/isomedia/hint_track.c\n@@ -43,7 +43,7\
    \ @@ Bool IsHintTrack(GF_TrackBox *trak)\n u32 GetHintFormat(GF_TrackBox *trak)\n\
    \ {\n \tGF_HintMediaHeaderBox *hmhd = (GF_HintMediaHeaderBox *)trak->Media->information->InfoHeader;\n\
    -\tif (hmhd->type != GF_ISOM_BOX_TYPE_HMHD)\n+\tif (!hmhd || (hmhd->type != GF_ISOM_BOX_TYPE_HMHD))\n\
    \ \t\treturn 0;\n \t\t\n \tif (!hmhd || !hmhd->subType) {"
  identifiers:
  - CVE-2021-40576
  - CWE-476
  overview: The binary MP4Box in Gpac 1.0.1 has a null pointer dereference vulnerability
    in the gf_isom_get_payt_count function in hint_track.c, which allows attackers
    to cause a denial of service.
  references:
  - source: cve@mitre.org
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/gpac/gpac/commit/ad18ece95fa064efc0995c4ab2c985f77fb166ec
  - source: cve@mitre.org
    tags:
    - Exploit
    - Issue Tracking
    - Third Party Advisory
    url: https://github.com/gpac/gpac/issues/1904
  - source: cve@mitre.org
    url: https://www.debian.org/security/2023/dsa-5411
  title: The binary MP4Box in Gpac 1.0.1 has a null pointer dereference vulnerability
    in the gf_isom_get_payt_count function in hint_track.c, which allows attackers
    to cause a denial of service.
- diff_content:
  - "--- a/common/flatpak-context.c\n+++ b/common/flatpak-context.c\n@@ -852,6 +852,31\
    \ @@ flatpak_context_parse_filesystem (const char             *filesystem_and_mode,\n\
    \   return FALSE;\n }\n \n+/* Note: This only works with valid keys, i.e. they\
    \ passed flatpak_context_parse_filesystem */\n+static gboolean\n+flatpak_filesystem_key_in_home\
    \ (const char *filesystem)\n+{\n+  /* \"home\" is definitely in home */\n+  if\
    \ (strcmp (filesystem, \"home\") == 0)\n+    return TRUE;\n+\n+  /* All the other\
    \ special fs:es are non-home.\n+   * Note: This considers absolute paths that\
    \ are in the homedir as non-home.\n+   */\n+  if (g_strv_contains (flatpak_context_special_filesystems,\
    \ filesystem) ||\n+      g_str_has_prefix (filesystem, \"/\"))\n+    return FALSE;\n\
    +\n+  /* Files in xdg-run are not in home */\n+  if (g_str_has_prefix (filesystem,\
    \ \"xdg-run\"))\n+    return FALSE;\n+\n+  /* All remaining keys (~/, xdg-data,\
    \ etc) are considered in home,\n+   * Note: technically $XDG_HOME_DATA could point\
    \ outside the homedir, but we ignore that.\n+   */\n+  return TRUE;\n+}\n+\n static\
    \ void\n flatpak_context_take_filesystem (FlatpakContext        *context,\n  \
    \                                char                  *fs,\n@@ -866,6 +891,8\
    \ @@ flatpak_context_merge (FlatpakContext *context,\n {\n   GHashTableIter iter;\n\
    \   gpointer key, value;\n+  gboolean no_home = FALSE;\n+  gboolean no_host =\
    \ FALSE;\n \n   context->shares &= ~other->shares_valid;\n   context->shares |=\
    \ other->shares;\n@@ -888,6 +915,41 @@ flatpak_context_merge (FlatpakContext *context,\n\
    \   while (g_hash_table_iter_next (&iter, &key, &value))\n     g_hash_table_insert\
    \ (context->persistent, g_strdup (key), value);\n \n+  /* We first handle all\
    \ negative home and host as they override other\n+     keys than themselves from\
    \ the parent */\n+  if (g_hash_table_lookup_extended (other->filesystems,\n+ \
    \                                   \"host\",\n+                             \
    \       NULL, &value))\n+    {\n+      FlatpakFilesystemMode host_mode = GPOINTER_TO_INT\
    \ (value);\n+      if (host_mode == FLATPAK_FILESYSTEM_MODE_NONE)\n+        no_host\
    \ = TRUE;\n+    }\n+\n+  if (g_hash_table_lookup_extended (other->filesystems,\n\
    +                                    \"home\",\n+                            \
    \        NULL, &value))\n+    {\n+      FlatpakFilesystemMode home_mode = GPOINTER_TO_INT\
    \ (value);\n+      if (home_mode == FLATPAK_FILESYSTEM_MODE_NONE)\n+        no_home\
    \ = TRUE;\n+    }\n+\n+  if (no_host)\n+    {\n+      g_hash_table_remove_all\
    \ (context->filesystems);\n+    }\n+  else if (no_home)\n+    {\n+      g_hash_table_iter_init\
    \ (&iter, context->filesystems);\n+      while (g_hash_table_iter_next (&iter,\
    \ &key, &value))\n+        {\n+          if (flatpak_filesystem_key_in_home ((const\
    \ char *)key))\n+            g_hash_table_iter_remove (&iter);\n+        }\n+\
    \    }\n+\n+  /* Then set the new ones, which includes propagating the nohost\
    \ and nohome ones. */\n   g_hash_table_iter_init (&iter, other->filesystems);\n\
    \   while (g_hash_table_iter_next (&iter, &key, &value))\n     g_hash_table_insert\
    \ (context->filesystems, g_strdup (key), value);"
  identifiers:
  - CVE-2022-21682
  - CWE-22
  overview: Flatpak is a Linux application sandboxing and distribution framework.
    A path traversal vulnerability affects versions of Flatpak prior to 1.12.3 and
    1.10.6. flatpak-builder applies `finish-args` last in the build. At this point
    the build directory will have the full access that is specified in the manifest,
    so running `flatpak build` against it will gain those permissions. Normally this
    will not be done, so this is not problem. However, if `--mirror-screenshots-url`
    is specified, then flatpak-builder will launch `flatpak build --nofilesystem=host
    appstream-utils mirror-screenshots` after finalization, which can lead to issues
    even with the `--nofilesystem=host` protection. In normal use, the only issue
    is that these empty directories can be created wherever the user has write permissions.
    However, a malicious application could replace the `appstream-util` binary and
    potentially do something more hostile. This has been resolved in Flatpak 1.12.3
    and 1.10.6 by changing the behaviour of `--nofilesystem=home` and `--nofilesystem=host`.
  references:
  - source: security-advisories@github.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/flatpak/flatpak/commit/445bddeee657fdc8d2a0a1f0de12975400d4fc1a
  - source: security-advisories@github.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/flatpak/flatpak/commit/4d11f77aa7fd3e64cfa80af89d92567ab9e8e6fa
  - source: security-advisories@github.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/flatpak/flatpak/security/advisories/GHSA-8ch7-5j3h-g4fx
  - source: security-advisories@github.com
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/APFTBYGJJVJPFVHRXUW5PII5XOAFI4KH/
  - source: security-advisories@github.com
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/IXKBERLJRYV7KXKGXOLI6IOXVBQNN4DP/
  - source: security-advisories@github.com
    url: https://security.gentoo.org/glsa/202312-12
  - source: security-advisories@github.com
    tags:
    - Third Party Advisory
    url: https://www.debian.org/security/2022/dsa-5049
  title: Flatpak is a Linux application sandboxing and distribution framework. A path
    traversal vulnerability affects versions of Flatpak prior to 1.12.3 and 1.10.6.
    flatpak-builder applies `finish-args` last in the build. At this point the build
    directory will have the full access that is specified in the manifest, so running
    `flatpak build` against it will gain those permissions. Normally this will not
    be done, so this is not problem. However, if `--mirror-screenshots-url` is specified,
    then flatpak-builder will launch `flatpak build --nofilesystem=host appstream-utils
    mirror-screenshots` after finalization, which can lead to issues even with the
    `--nofilesystem=host` protection. In normal use, the only issue is that these
    empty directories can be created wherever the user has write permissions. However,
    a malicious application could replace the `appstream-util` binary and potentially
    do something more hostile. This has been resolved in Flatpak 1.12.3 and 1.10.6
    by changing the behaviour of `--nofilesystem=home` and `--nofilesystem=host`.
- diff_content:
  - "--- a/src/drawscreen.c\n+++ b/src/drawscreen.c\n@@ -462,12 +462,13 @@ win_redr_status(win_T\
    \ *wp, int ignore_pum UNUSED)\n \tp = NameBuff;\n \tlen = (int)STRLEN(p);\n \n\
    -\tif (bt_help(wp->w_buffer)\n+\tif ((bt_help(wp->w_buffer)\n #ifdef FEAT_QUICKFIX\n\
    -\t\t|| wp->w_p_pvw\n+\t\t    || wp->w_p_pvw\n #endif\n-\t\t|| bufIsChanged(wp->w_buffer)\n\
    -\t\t|| wp->w_buffer->b_p_ro)\n+\t\t    || bufIsChanged(wp->w_buffer)\n+\t\t \
    \   || wp->w_buffer->b_p_ro)\n+\t\t&& len < MAXPATHL - 1)\n \t    *(p + len++)\
    \ = ' ';\n \tif (bt_help(wp->w_buffer))\n \t{"
  - "--- a/src/version.c\n+++ b/src/version.c\n@@ -750,6 +750,8 @@ static char *(features[])\
    \ =\n \n static int included_patches[] =\n {   /* Add new patch number below this\
    \ line */\n+/**/\n+    4074,\n /**/\n     4073,\n /**/"
  identifiers:
  - CVE-2022-0213
  - CWE-122
  overview: vim is vulnerable to Heap-based Buffer Overflow
  references:
  - source: security@huntr.dev
    tags:
    - Mailing List
    - Third Party Advisory
    url: http://www.openwall.com/lists/oss-security/2022/01/15/1
  - source: security@huntr.dev
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/vim/vim/commit/de05bb25733c3319e18dca44e9b59c6ee389eb26
  - source: security@huntr.dev
    tags:
    - Exploit
    - Patch
    - Third Party Advisory
    url: https://huntr.dev/bounties/f3afe1a5-e6f8-4579-b68a-6e5c7e39afed
  - source: security@huntr.dev
    tags:
    - Mailing List
    - Third Party Advisory
    url: https://lists.debian.org/debian-lts-announce/2022/03/msg00018.html
  - source: security@huntr.dev
    tags:
    - Mailing List
    - Third Party Advisory
    url: https://lists.debian.org/debian-lts-announce/2022/11/msg00009.html
  - source: security@huntr.dev
    tags:
    - Third Party Advisory
    url: https://security.gentoo.org/glsa/202208-32
  title: vim is vulnerable to Heap-based Buffer Overflow
- diff_content:
  - "--- a/src/rec-parser.c\n+++ b/src/rec-parser.c\n@@ -432,7 +432,7 @@ rec_parse_comment\
    \ (rec_parser_t parser, rec_comment_t *comment)\n                 c = '\\n';\n\
    \             }\n \n-          if (rec_buf_putc (c, buf) == EOF)\n+          if\
    \ (rec_buf_putc (ci, buf) == EOF)\n             {\n               /* Out of memory\
    \ */\n               parser->error = REC_PARSER_ENOMEM;"
  identifiers:
  - CVE-2021-46019
  - CWE-476
  overview: An untrusted pointer dereference in rec_db_destroy() at rec-db.c of GNU
    Recutils v1.8.90 can lead to a segmentation fault or application crash.
  references:
  - source: cve@mitre.org
    url: https://github.com/gnu-mirror-unofficial/recutils/commit/34b75ed7ad492c8e38b669ebafe0176f1f9992d2
  - source: cve@mitre.org
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/TDVOFC3HTBG7DF2PZTEXRMG4CV2F55UF/
  - source: cve@mitre.org
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/VRSXSN2XF6PX74WDYVV26TQMYIFAEQ3T/
  - source: cve@mitre.org
    tags:
    - Exploit
    - Mailing List
    - Vendor Advisory
    url: https://lists.gnu.org/archive/html/bug-recutils/2021-12/msg00009.html
  title: An untrusted pointer dereference in rec_db_destroy() at rec-db.c of GNU Recutils
    v1.8.90 can lead to a segmentation fault or application crash.
- diff_content:
  - "--- a/src/rec-parser.c\n+++ b/src/rec-parser.c\n@@ -432,7 +432,7 @@ rec_parse_comment\
    \ (rec_parser_t parser, rec_comment_t *comment)\n                 c = '\\n';\n\
    \             }\n \n-          if (rec_buf_putc (c, buf) == EOF)\n+          if\
    \ (rec_buf_putc (ci, buf) == EOF)\n             {\n               /* Out of memory\
    \ */\n               parser->error = REC_PARSER_ENOMEM;"
  identifiers:
  - CVE-2021-46022
  - CWE-416
  overview: An Use-After-Free vulnerability in rec_mset_elem_destroy() at rec-mset.c
    of GNU Recutils v1.8.90 can lead to a segmentation fault or application crash.
  references:
  - source: cve@mitre.org
    url: https://github.com/gnu-mirror-unofficial/recutils/commit/34b75ed7ad492c8e38b669ebafe0176f1f9992d2
  - source: cve@mitre.org
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/TDVOFC3HTBG7DF2PZTEXRMG4CV2F55UF/
  - source: cve@mitre.org
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/VRSXSN2XF6PX74WDYVV26TQMYIFAEQ3T/
  - source: cve@mitre.org
    tags:
    - Exploit
    - Mailing List
    - Vendor Advisory
    url: https://lists.gnu.org/archive/html/bug-recutils/2021-12/msg00007.html
  - source: cve@mitre.org
    url: https://nvd.nist.gov/vuln/detail/CVE-2021-46022
  title: An Use-After-Free vulnerability in rec_mset_elem_destroy() at rec-mset.c
    of GNU Recutils v1.8.90 can lead to a segmentation fault or application crash.
- diff_content:
  - "--- a/src/class.c\n+++ b/src/class.c\n@@ -357,6 +357,7 @@ prepare_singleton_class(mrb_state\
    \ *mrb, struct RBasic *o)\n {\n   struct RClass *sc, *c;\n \n+  mrb_assert(o->c);\n\
    \   if (o->c->tt == MRB_TT_SCLASS) return;\n   sc = MRB_OBJ_ALLOC(mrb, MRB_TT_SCLASS,\
    \ mrb->class_class);\n   sc->flags |= MRB_FL_CLASS_IS_INHERITED;\n@@ -1682,6 +1683,7\
    \ @@ mrb_singleton_class_ptr(mrb_state *mrb, mrb_value v)\n     break;\n   }\n\
    \   obj = mrb_basic_ptr(v);\n+  if (obj->c == NULL) return NULL;\n   prepare_singleton_class(mrb,\
    \ obj);\n   return obj->c;\n }"
  identifiers:
  - CVE-2022-0240
  - CWE-476
  overview: mruby is vulnerable to NULL Pointer Dereference
  references:
  - source: security@huntr.dev
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/mruby/mruby/commit/31fa3304049fc406a201a72293cce140f0557dca
  - source: security@huntr.dev
    tags:
    - Exploit
    - Third Party Advisory
    url: https://huntr.dev/bounties/5857eced-aad9-417d-864e-0bdf17226cbb
  title: mruby is vulnerable to NULL Pointer Dereference
- diff_content:
  - "--- a/src/ops.c\n+++ b/src/ops.c\n@@ -536,24 +536,29 @@ block_insert(\n \t  \
    \  if (b_insert)\n \t    {\n \t\toff = (*mb_head_off)(oldp, oldp + offset + spaces);\n\
    +\t\tspaces -= off;\n+\t\tcount -= off;\n \t    }\n \t    else\n \t    {\n-\t\t\
    off = (*mb_off_next)(oldp, oldp + offset);\n-\t\toffset += off;\n+\t\t// spaces\
    \ fill the gap, the character that's at the edge moves\n+\t\t// right\n+\t\toff\
    \ = (*mb_head_off)(oldp, oldp + offset);\n+\t\toffset -= off;\n \t    }\n-\t \
    \   spaces -= off;\n-\t    count -= off;\n \t}\n \tif (spaces < 0)  // can happen\
    \ when the cursor was moved\n \t    spaces = 0;\n \n-\tnewp = alloc(STRLEN(oldp)\
    \ + s_len + count + 1);\n+\t// Make sure the allocated size matches what is actually\
    \ copied below.\n+\tnewp = alloc(STRLEN(oldp) + spaces + s_len\n+\t\t    + (spaces\
    \ > 0 && !bdp->is_short ? ts_val - spaces : 0)\n+\t\t\t\t\t\t\t\t  + count + 1);\n\
    \ \tif (newp == NULL)\n \t    continue;\n \n \t// copy up to shifted part\n-\t\
    mch_memmove(newp, oldp, (size_t)(offset));\n+\tmch_memmove(newp, oldp, (size_t)offset);\n\
    \ \toldp += offset;\n \n \t// insert pre-padding\n@@ -564,14 +569,21 @@ block_insert(\n\
    \ \tmch_memmove(newp + startcol, s, (size_t)s_len);\n \toffset += s_len;\n \n\
    -\tif (spaces && !bdp->is_short)\n+\tif (spaces > 0 && !bdp->is_short)\n \t{\n\
    -\t    // insert post-padding\n-\t    vim_memset(newp + offset + spaces, ' ',\
    \ (size_t)(ts_val - spaces));\n-\t    // We're splitting a TAB, don't copy it.\n\
    -\t    oldp++;\n-\t    // We allowed for that TAB, remember this now\n-\t    count++;\n\
    +\t    if (*oldp == TAB)\n+\t    {\n+\t\t// insert post-padding\n+\t\tvim_memset(newp\
    \ + offset + spaces, ' ',\n+\t\t\t\t\t\t    (size_t)(ts_val - spaces));\n+\t\t\
    // we're splitting a TAB, don't copy it\n+\t\toldp++;\n+\t\t// We allowed for\
    \ that TAB, remember this now\n+\t\tcount++;\n+\t    }\n+\t    else\n+\t\t// Not\
    \ a TAB, no extra spaces\n+\t\tcount = spaces;\n \t}\n \n \tif (spaces > 0)\n\
    @@ -1598,7 +1610,7 @@ op_insert(oparg_T *oap, long count1)\n \t\t    oap->start_vcol\
    \ = t;\n \t\t}\n \t\telse if (oap->op_type == OP_APPEND\n-\t\t\t&& oap->end.col\
    \ + oap->end.coladd\n+\t\t\t&& oap->start.col + oap->start.coladd\n \t\t\t\t>=\
    \ curbuf->b_op_start_orig.col\n \t\t\t\t\t      + curbuf->b_op_start_orig.coladd)\n\
    \ \t\t{"
  - "--- a/src/version.c\n+++ b/src/version.c\n@@ -750,6 +750,8 @@ static char *(features[])\
    \ =\n \n static int included_patches[] =\n {   /* Add new patch number below this\
    \ line */\n+/**/\n+    4120,\n /**/\n     4119,\n /**/"
  identifiers:
  - CVE-2022-0261
  - CWE-787
  overview: Heap-based Buffer Overflow in GitHub repository vim/vim prior to 8.2.
  references:
  - source: security@huntr.dev
    tags:
    - Mailing List
    - Third Party Advisory
    url: http://seclists.org/fulldisclosure/2022/Oct/28
  - source: security@huntr.dev
    tags:
    - Mailing List
    - Third Party Advisory
    url: http://seclists.org/fulldisclosure/2022/Oct/41
  - source: security@huntr.dev
    tags:
    - Mailing List
    - Third Party Advisory
    url: http://seclists.org/fulldisclosure/2022/Oct/43
  - source: security@huntr.dev
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/vim/vim/commit/9f8c304c8a390ade133bac29963dc8e56ab14cbc
  - source: security@huntr.dev
    tags:
    - Exploit
    - Patch
    - Third Party Advisory
    url: https://huntr.dev/bounties/fa795954-8775-4f23-98c6-d4d4d3fe8a82
  - source: security@huntr.dev
    tags:
    - Mailing List
    - Third Party Advisory
    url: https://lists.debian.org/debian-lts-announce/2022/05/msg00022.html
  - source: security@huntr.dev
    tags:
    - Mailing List
    - Third Party Advisory
    url: https://lists.debian.org/debian-lts-announce/2022/11/msg00009.html
  - source: security@huntr.dev
    tags:
    - Third Party Advisory
    url: https://security.gentoo.org/glsa/202208-32
  - source: security@huntr.dev
    tags:
    - Third Party Advisory
    url: https://support.apple.com/kb/HT213444
  - source: security@huntr.dev
    tags:
    - Third Party Advisory
    url: https://support.apple.com/kb/HT213488
  title: Heap-based Buffer Overflow in GitHub repository vim/vim prior to 8.2.
- diff_content:
  - "--- a/android-gif-drawable/src/main/c/decoding.c\n+++ b/android-gif-drawable/src/main/c/decoding.c\n\
    @@ -1,4 +1,5 @@\n #include \"gif.h\"\n+#define COMMENT_LENGTH_MAX 2048\n \n static\
    \ bool updateGCB(GifInfo *info, uint_fast32_t *lastAllocatedGCBIndex) {\n \tif\
    \ (*lastAllocatedGCBIndex < info->gifFilePtr->ImageCount) {\n@@ -177,12 +178,16\
    \ @@ static int readExtensions(int ExtFunction, GifByteType *ExtData, GifInfo\
    \ *info)\n }\n \n static int getComment(GifByteType *Bytes, GifInfo *info) {\n\
    -\tunsigned int len = (unsigned int) Bytes[0];\n+\tunsigned int length = (unsigned\
    \ int) Bytes[0];\n \tsize_t offset = info->comment != NULL ? strlen(info->comment)\
    \ : 0;\n-\tchar *ret = reallocarray(info->comment, len + offset + 1, sizeof(char));\n\
    +    unsigned int newLength = length + offset + 1;\n+    if (newLength > COMMENT_LENGTH_MAX)\
    \ {\n+\t\treturn GIF_OK;\n+\t}\n+    char *ret = reallocarray(info->comment, newLength,\
    \ sizeof(char));\n \tif (ret != NULL) {\n-\t\tmemcpy(ret + offset, &Bytes[1],\
    \ len);\n-\t\tret[len + offset] = 0;\n+\t\tmemcpy(ret + offset, &Bytes[1], length);\n\
    +\t\tret[length + offset] = 0;\n \t\tinfo->comment = ret;\n \t\treturn GIF_OK;\n\
    \ \t}"
  identifiers:
  - CVE-2022-23435
  - NVD-CWE-noinfo
  overview: decoding.c in android-gif-drawable before 1.2.24 does not limit the maximum
    length of a comment, leading to denial of service.
  references:
  - source: cve@mitre.org
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/koral--/android-gif-drawable/commit/9f0f0c89e6fa38548163771feeb4bde84b828887
  - source: cve@mitre.org
    tags:
    - Patch
    - Release Notes
    - Third Party Advisory
    url: https://github.com/koral--/android-gif-drawable/compare/v1.2.23...v1.2.24
  title: decoding.c in android-gif-drawable before 1.2.24 does not limit the maximum
    length of a comment, leading to denial of service.
- diff_content:
  - "--- a/mrbgems/mruby-compiler/core/codegen.c\n+++ b/mrbgems/mruby-compiler/core/codegen.c\n\
    @@ -1644,14 +1644,13 @@ gen_hash(codegen_scope *s, node *tree, int val, int limit)\n\
    \     }\n   }\n   if (update) {\n-    if (len > 0) {\n+    if (val && len > 0)\
    \ {\n       pop_n(len*2+1);\n       genop_2(s, OP_HASHADD, cursp(), len);\n  \
    \     push();\n     }\n     return -1;                  /* variable length */\n\
    \   }\n-  if (update) return -1;\n   return len;\n }\n "
  identifiers:
  - CVE-2022-0326
  - CWE-476
  overview: NULL Pointer Dereference in Homebrew mruby prior to 3.2.
  references:
  - source: security@huntr.dev
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/mruby/mruby/commit/b611c43a5de061ec21b343967e1b64c45c373d7e
  - source: security@huntr.dev
    tags:
    - Exploit
    - Patch
    - Third Party Advisory
    url: https://huntr.dev/bounties/795dcbd9-1695-44bb-8c59-ad327c97c976
  title: NULL Pointer Dereference in Homebrew mruby prior to 3.2.
- diff_content:
  - "--- a/src/ops.c\n+++ b/src/ops.c\n@@ -529,24 +529,9 @@ block_insert(\n \t}\n\
    \ \n \tif (has_mbyte && spaces > 0)\n-\t{\n-\t    int off;\n+\t    // avoid copying\
    \ part of a multi-byte character\n+\t    offset -= (*mb_head_off)(oldp, oldp +\
    \ offset);\n \n-\t    // Avoid starting halfway a multi-byte character.\n-\t \
    \   if (b_insert)\n-\t    {\n-\t\toff = (*mb_head_off)(oldp, oldp + offset + spaces);\n\
    -\t\tspaces -= off;\n-\t\tcount -= off;\n-\t    }\n-\t    else\n-\t    {\n-\t\t\
    // spaces fill the gap, the character that's at the edge moves\n-\t\t// right\n\
    -\t\toff = (*mb_head_off)(oldp, oldp + offset);\n-\t\toffset -= off;\n-\t    }\n\
    -\t}\n \tif (spaces < 0)  // can happen when the cursor was moved\n \t    spaces\
    \ = 0;\n "
  - "--- a/src/version.c\n+++ b/src/version.c\n@@ -750,6 +750,8 @@ static char *(features[])\
    \ =\n \n static int included_patches[] =\n {   /* Add new patch number below this\
    \ line */\n+/**/\n+    4151,\n /**/\n     4150,\n /**/"
  identifiers:
  - CVE-2022-0318
  - CWE-787
  overview: Heap-based Buffer Overflow in vim/vim prior to 8.2.
  references:
  - source: security@huntr.dev
    tags:
    - Mailing List
    - Third Party Advisory
    url: http://seclists.org/fulldisclosure/2022/Oct/28
  - source: security@huntr.dev
    tags:
    - Mailing List
    - Third Party Advisory
    url: http://seclists.org/fulldisclosure/2022/Oct/41
  - source: security@huntr.dev
    tags:
    - Mailing List
    - Third Party Advisory
    url: http://seclists.org/fulldisclosure/2022/Oct/43
  - source: security@huntr.dev
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/vim/vim/commit/57df9e8a9f9ae1aafdde9b86b10ad907627a87dc
  - source: security@huntr.dev
    tags:
    - Exploit
    - Patch
    - Third Party Advisory
    url: https://huntr.dev/bounties/0d10ba02-b138-4e68-a284-67f781a62d08
  - source: security@huntr.dev
    tags:
    - Mailing List
    - Third Party Advisory
    url: https://lists.debian.org/debian-lts-announce/2022/11/msg00032.html
  - source: security@huntr.dev
    tags:
    - Third Party Advisory
    url: https://security.gentoo.org/glsa/202208-32
  - source: security@huntr.dev
    tags:
    - Third Party Advisory
    url: https://support.apple.com/kb/HT213444
  - source: security@huntr.dev
    tags:
    - Third Party Advisory
    url: https://support.apple.com/kb/HT213488
  title: Heap-based Buffer Overflow in vim/vim prior to 8.2.
- diff_content:
  - "--- a/Source/Core/PltHttpServer.cpp\n+++ b/Source/Core/PltHttpServer.cpp\n@@\
    \ -190,7 +190,7 @@ PLT_HttpServer::ServeFile(const NPT_HttpRequest&        request,\n\
    \     NPT_FileInfo             file_info;\n     \n     // prevent hackers from\
    \ accessing files outside of our root\n-    if ((file_path.Find(\"/..\") >= 0)\
    \ || (file_path.Find(\"\\\\..\") >= 0) ||\n+    if ((file_path.Find(\"../\") >=\
    \ 0) || (file_path.Find(\"..\\\\\") >= 0) ||\n         NPT_FAILED(NPT_File::GetInfo(file_path,\
    \ &file_info))) {\n         return NPT_ERROR_NO_SUCH_ITEM;\n     }"
  identifiers:
  - CVE-2020-19858
  - CWE-22
  overview: Platinum Upnp SDK through 1.2.0 has a directory traversal vulnerability.
    The attack could remote attack victim by sending http://ip:port/../privacy.avi
    URL to compromise a victim's privacy.
  references:
  - source: cve@mitre.org
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/plutinosoft/Platinum/commit/9a4ceaccb1585ec35c45fd8e2585538fff6a865e
  - source: cve@mitre.org
    tags:
    - Issue Tracking
    - Third Party Advisory
    url: https://github.com/plutinosoft/Platinum/issues/22
  title: Platinum Upnp SDK through 1.2.0 has a directory traversal vulnerability.
    The attack could remote attack victim by sending http://ip:port/../privacy.avi
    URL to compromise a victim's privacy.
- diff_content:
  - "--- a/rr.c\n+++ b/rr.c\n@@ -365,15 +365,18 @@ ldns_rr_new_frm_str_internal(ldns_rr\
    \ **newrr, const char *str,\n \t\t\t\tldns_buffer_remaining(rd_buf) > 0){\n \n\
    \ \t\t\t/* skip spaces */\n-\t\t\twhile (*(ldns_buffer_current(rd_buf)) == ' ')\
    \ {\n+\t\t\twhile (sldns_buffer_remaining(strbuf) > 0 &&\n+\t\t\t\t*(ldns_buffer_current(rd_buf))\
    \ == ' ') {\n \t\t\t\tldns_buffer_skip(rd_buf, 1);\n \t\t\t}\n \n-\t\t\tif (*(ldns_buffer_current(rd_buf))\
    \ == '\\\"') {\n+\t\t\tif (sldns_buffer_remaining(strbuf) > 0 &&\n+\t\t\t\t*(ldns_buffer_current(rd_buf))\
    \ == '\\\"') {\n \t\t\t\tdelimiters = \"\\\"\\0\";\n \t\t\t\tldns_buffer_skip(rd_buf,\
    \ 1);\n \t\t\t\tquoted = true;\n-\t\t\t} else if (ldns_rr_descriptor_field_type(desc,\
    \ r_cnt)\n+\t\t\t}\n+\t\t\tif (!quoted && ldns_rr_descriptor_field_type(desc,\
    \ r_cnt)\n \t\t\t\t\t== LDNS_RDF_TYPE_LONG_STR) {\n \n \t\t\t\tstatus = LDNS_STATUS_SYNTAX_RDATA_ERR;"
  identifiers:
  - CVE-2020-19860
  - CWE-125
  overview: When ldns version 1.7.1 verifies a zone file, the ldns_rr_new_frm_str_internal
    function has a heap out of bounds read vulnerability. An attacker can leak information
    on the heap by constructing a zone file payload.
  references:
  - source: cve@mitre.org
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/NLnetLabs/ldns/commit/15d96206996bea969fbc918eb0a4a346f514b9f3
  - source: cve@mitre.org
    tags:
    - Exploit
    - Issue Tracking
    - Third Party Advisory
    url: https://github.com/NLnetLabs/ldns/issues/50
  title: When ldns version 1.7.1 verifies a zone file, the ldns_rr_new_frm_str_internal
    function has a heap out of bounds read vulnerability. An attacker can leak information
    on the heap by constructing a zone file payload.
- diff_content:
  - "--- a/src/version.c\n+++ b/src/version.c\n@@ -750,6 +750,8 @@ static char *(features[])\
    \ =\n \n static int included_patches[] =\n {   /* Add new patch number below this\
    \ line */\n+/**/\n+    4154,\n /**/\n     4153,\n /**/"
  - "--- a/src/window.c\n+++ b/src/window.c\n@@ -1691,6 +1691,11 @@ win_exchange(long\
    \ Prenum)\n \n     (void)win_comp_pos();\t\t// recompute window positions\n \n\
    +    if (wp->w_buffer != curbuf)\n+\treset_VIsual_and_resel();\n+    else if (VIsual_active)\n\
    +\twp->w_cursor = curwin->w_cursor;\n+\n     win_enter(wp, TRUE);\n     redraw_all_later(NOT_VALID);\n\
    \ }"
  identifiers:
  - CVE-2022-0319
  - CWE-125
  overview: Out-of-bounds Read in vim/vim prior to 8.2.
  references:
  - source: security@huntr.dev
    tags:
    - Mailing List
    - Third Party Advisory
    url: http://seclists.org/fulldisclosure/2022/Oct/28
  - source: security@huntr.dev
    tags:
    - Mailing List
    - Third Party Advisory
    url: http://seclists.org/fulldisclosure/2022/Oct/41
  - source: security@huntr.dev
    tags:
    - Mailing List
    - Third Party Advisory
    url: http://seclists.org/fulldisclosure/2022/Oct/43
  - source: security@huntr.dev
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/vim/vim/commit/05b27615481e72e3b338bb12990fb3e0c2ecc2a9
  - source: security@huntr.dev
    tags:
    - Exploit
    - Patch
    - Third Party Advisory
    url: https://huntr.dev/bounties/ba622fd2-e6ef-4ad9-95b4-17f87b68755b
  - source: security@huntr.dev
    tags:
    - Mitigation
    - Third Party Advisory
    url: https://lists.debian.org/debian-lts-announce/2022/03/msg00018.html
  - source: security@huntr.dev
    tags:
    - Mailing List
    - Third Party Advisory
    url: https://lists.debian.org/debian-lts-announce/2022/11/msg00009.html
  - source: security@huntr.dev
    tags:
    - Third Party Advisory
    url: https://security.gentoo.org/glsa/202208-32
  - source: security@huntr.dev
    tags:
    - Third Party Advisory
    url: https://support.apple.com/kb/HT213444
  - source: security@huntr.dev
    tags:
    - Third Party Advisory
    url: https://support.apple.com/kb/HT213488
  title: Out-of-bounds Read in vim/vim prior to 8.2.
- diff_content:
  - "--- a/parse.c\n+++ b/parse.c\n@@ -73,6 +73,17 @@ int flag2str_sh(int flag, char\
    \ *flag_str) {\n     return 0;\n }\n \n+/**\n+ * @description: Judge whether the\
    \ memory address is legal\n+ * @param {uint32_t} addr\n+ * @param {uint32_t} start\n\
    + * @param {uint32_t} end\n+ * @return {*}\n+ */\n+int validated_offset(uint32_t\
    \ addr, uint32_t start, uint32_t end){\n+    return addr <= end && addr >= start?\
    \ 0:-1;\n+}\n+\n int parse(char *elf) {\n     int fd;\n     struct stat st;\n\
    @@ -256,6 +267,10 @@ int parse(char *elf) {\n         PRINT_SECTION_TITLE(\"Nr\"\
    , \"Name\", \"Type\", \"Addr\", \"Off\", \"Size\", \"Es\", \"Flg\", \"Lk\", \"\
    Inf\", \"Al\");\n         for (int i = 0; i < ehdr->e_shnum; i++) {\n        \
    \     name = elf_map + shstrtab.sh_offset + shdr[i].sh_name;\n+            if\
    \ (validated_offset(name, elf_map, elf_map + st.st_size)) {\n+               \
    \ ERROR(\"Corrupt file format\\n\");\n+                return -1;\n+         \
    \   }\n \n             switch (shdr[i].sh_type) {\n                 case SHT_NULL:\n\
    @@ -902,6 +917,10 @@ int parse(char *elf) {\n         PRINT_SECTION_TITLE(\"Nr\"\
    , \"Name\", \"Type\", \"Addr\", \"Off\", \"Size\", \"Es\", \"Flg\", \"Lk\", \"\
    Inf\", \"Al\");\n         for (int i = 0; i < ehdr->e_shnum; i++) {\n        \
    \     name = elf_map + shstrtab.sh_offset + shdr[i].sh_name;\n+            if\
    \ (validated_offset(name, elf_map, elf_map + st.st_size)) {\n+               \
    \ ERROR(\"Corrupt file format\\n\");\n+                return -1;\n+         \
    \   }\n \n             switch (shdr[i].sh_type) {\n                 case SHT_NULL:"
  identifiers:
  - CVE-2022-21711
  - CWE-125
  overview: elfspirit is an ELF static analysis and injection framework that parses,
    manipulates, and camouflages ELF files. When analyzing the ELF file format in
    versions prior to 1.1, there is an out-of-bounds read bug, which can lead to application
    crashes or information leakage. By constructing a special format ELF file, the
    information of any address can be leaked. elfspirit version 1.1 contains a patch
    for this issue.
  references:
  - source: security-advisories@github.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/liyansong2018/elfspirit/commit/c5b0f5a9a24f2451bbeda4751d67633bc375e608
  - source: security-advisories@github.com
    tags:
    - Exploit
    - Issue Tracking
    - Third Party Advisory
    url: https://github.com/liyansong2018/elfspirit/issues/1
  - source: security-advisories@github.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/liyansong2018/elfspirit/security/advisories/GHSA-jr8h-2657-m68r
  title: elfspirit is an ELF static analysis and injection framework that parses,
    manipulates, and camouflages ELF files. When analyzing the ELF file format in
    versions prior to 1.1, there is an out-of-bounds read bug, which can lead to application
    crashes or information leakage. By constructing a special format ELF file, the
    information of any address can be leaked. elfspirit version 1.1 contains a patch
    for this issue.
- diff_content:
  - "--- a/src/eval.c\n+++ b/src/eval.c\n@@ -3526,6 +3526,7 @@ eval7(\n     char_u\t\
    *start_leader, *end_leader;\n     int\t\tret = OK;\n     char_u\t*alias;\n+  \
    \  static\tint recurse = 0;\n \n     /*\n      * Initialise variable so that clear_tv()\
    \ can't mistake this for a\n@@ -3552,6 +3553,15 @@ eval7(\n \treturn FAIL;\n \
    \    }\n \n+    // Limit recursion to 1000 levels.  At least at 10000 we run out\
    \ of stack\n+    // and crash.\n+    if (recurse == 1000)\n+    {\n+\tsemsg(_(e_expression_too_recursive_str),\
    \ *arg);\n+\treturn FAIL;\n+    }\n+    ++recurse;\n+\n     switch (**arg)\n \
    \    {\n     /*\n@@ -3781,6 +3791,8 @@ eval7(\n      */\n     if (ret == OK &&\
    \ evaluate && end_leader > start_leader)\n \tret = eval7_leader(rettv, FALSE,\
    \ start_leader, &end_leader);\n+\n+    --recurse;\n     return ret;\n }\n "
  - "--- a/src/version.c\n+++ b/src/version.c\n@@ -750,6 +750,8 @@ static char *(features[])\
    \ =\n \n static int included_patches[] =\n {   /* Add new patch number below this\
    \ line */\n+/**/\n+    4206,\n /**/\n     4205,\n /**/"
  identifiers:
  - CVE-2022-0351
  - CWE-119
  overview: Access of Memory Location Before Start of Buffer in GitHub repository
    vim/vim prior to 8.2.
  references:
  - source: security@huntr.dev
    tags:
    - Mailing List
    - Third Party Advisory
    url: http://seclists.org/fulldisclosure/2022/Oct/28
  - source: security@huntr.dev
    tags:
    - Mailing List
    - Third Party Advisory
    url: http://seclists.org/fulldisclosure/2022/Oct/41
  - source: security@huntr.dev
    tags:
    - Mailing List
    - Third Party Advisory
    url: http://seclists.org/fulldisclosure/2022/Oct/43
  - source: security@huntr.dev
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/vim/vim/commit/fe6fb267e6ee5c5da2f41889e4e0e0ac5bf4b89d
  - source: security@huntr.dev
    tags:
    - Exploit
    - Third Party Advisory
    url: https://huntr.dev/bounties/8b36db58-b65c-4298-be7f-40b9e37fd161
  - source: security@huntr.dev
    tags:
    - Mailing List
    - Third Party Advisory
    url: https://lists.debian.org/debian-lts-announce/2022/05/msg00022.html
  - source: security@huntr.dev
    tags:
    - Mailing List
    - Third Party Advisory
    url: https://lists.debian.org/debian-lts-announce/2022/11/msg00009.html
  - source: security@huntr.dev
    tags:
    - Third Party Advisory
    url: https://security.gentoo.org/glsa/202208-32
  - source: security@huntr.dev
    tags:
    - Vendor Advisory
    url: https://support.apple.com/kb/HT213444
  - source: security@huntr.dev
    tags:
    - Vendor Advisory
    url: https://support.apple.com/kb/HT213488
  title: Access of Memory Location Before Start of Buffer in GitHub repository vim/vim
    prior to 8.2.
- diff_content:
  - "--- a/block/mirror.c\n+++ b/block/mirror.c\n@@ -160,18 +160,25 @@ static void\
    \ coroutine_fn mirror_wait_on_conflicts(MirrorOp *self,\n             if (ranges_overlap(self_start_chunk,\
    \ self_nb_chunks,\n                                op_start_chunk, op_nb_chunks))\n\
    \             {\n-                /*\n-                 * If the operation is\
    \ already (indirectly) waiting for us, or\n-                 * will wait for us\
    \ as soon as it wakes up, then just go on\n-                 * (instead of producing\
    \ a deadlock in the former case).\n-                 */\n-                if (op->waiting_for_op)\
    \ {\n-                    continue;\n+                if (self) {\n+         \
    \           /*\n+                     * If the operation is already (indirectly)\
    \ waiting for us,\n+                     * or will wait for us as soon as it wakes\
    \ up, then just go\n+                     * on (instead of producing a deadlock\
    \ in the former case).\n+                     */\n+                    if (op->waiting_for_op)\
    \ {\n+                        continue;\n+                    }\n+\n+        \
    \            self->waiting_for_op = op;\n                 }\n \n-            \
    \    self->waiting_for_op = op;\n                 qemu_co_queue_wait(&op->waiting_requests,\
    \ NULL);\n-                self->waiting_for_op = NULL;\n+\n+                if\
    \ (self) {\n+                    self->waiting_for_op = NULL;\n+             \
    \   }\n+\n                 break;\n             }\n         }\n"
  identifiers:
  - CVE-2021-4145
  - CWE-476
  overview: A NULL pointer dereference issue was found in the block mirror layer of
    QEMU in versions prior to 6.2.0. The `self` pointer is dereferenced in mirror_wait_on_conflicts()
    without ensuring that it's not NULL. A malicious unprivileged user within the
    guest could use this flaw to crash the QEMU process on the host when writing data
    reaches the threshold of mirroring node.
  references:
  - source: secalert@redhat.com
    tags:
    - Issue Tracking
    - Patch
    - Third Party Advisory
    url: https://bugzilla.redhat.com/show_bug.cgi?id=2034602
  - source: secalert@redhat.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://gitlab.com/qemu-project/qemu/-/commit/66fed30c9cd11854fc878a4eceb507e915d7c9cd
  - source: secalert@redhat.com
    tags:
    - Third Party Advisory
    url: https://security.gentoo.org/glsa/202208-27
  - source: secalert@redhat.com
    tags:
    - Third Party Advisory
    url: https://security.netapp.com/advisory/ntap-20220311-0004/
  title: A NULL pointer dereference issue was found in the block mirror layer of QEMU
    in versions prior to 6.2.0. The `self` pointer is dereferenced in mirror_wait_on_conflicts()
    without ensuring that it's not NULL. A malicious unprivileged user within the
    guest could use this flaw to crash the QEMU process on the host when writing data
    reaches the threshold of mirroring node.
- diff_content:
  - "--- a/src/ex_getln.c\n+++ b/src/ex_getln.c\n@@ -1513,7 +1513,7 @@ init_ccline(int\
    \ firstc, int indent)\n     ccline.cmdindent = (firstc > 0 ? indent : 0);\n \n\
    \     // alloc initial ccline.cmdbuff\n-    alloc_cmdbuff(exmode_active ? 250\
    \ : indent + 1);\n+    alloc_cmdbuff(indent + 50);\n     if (ccline.cmdbuff ==\
    \ NULL)\n \treturn FAIL;\n     ccline.cmdlen = ccline.cmdpos = 0;"
  - "--- a/src/version.c\n+++ b/src/version.c\n@@ -750,6 +750,8 @@ static char *(features[])\
    \ =\n \n static int included_patches[] =\n {   /* Add new patch number below this\
    \ line */\n+/**/\n+    4214,\n /**/\n     4213,\n /**/"
  identifiers:
  - CVE-2022-0359
  - CWE-122
  overview: Heap-based Buffer Overflow in GitHub repository vim/vim prior to 8.2.
  references:
  - source: security@huntr.dev
    tags:
    - Mailing List
    - Third Party Advisory
    url: http://seclists.org/fulldisclosure/2022/Oct/28
  - source: security@huntr.dev
    tags:
    - Mailing List
    - Third Party Advisory
    url: http://seclists.org/fulldisclosure/2022/Oct/41
  - source: security@huntr.dev
    tags:
    - Mailing List
    - Third Party Advisory
    url: http://seclists.org/fulldisclosure/2022/Oct/43
  - source: security@huntr.dev
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/vim/vim/commit/85b6747abc15a7a81086db31289cf1b8b17e6cb1
  - source: security@huntr.dev
    tags:
    - Exploit
    - Issue Tracking
    - Patch
    - Third Party Advisory
    url: https://huntr.dev/bounties/a3192d90-4f82-4a67-b7a6-37046cc88def
  - source: security@huntr.dev
    tags:
    - Mailing List
    - Third Party Advisory
    url: https://lists.debian.org/debian-lts-announce/2022/03/msg00018.html
  - source: security@huntr.dev
    tags:
    - Mailing List
    - Third Party Advisory
    url: https://lists.debian.org/debian-lts-announce/2022/11/msg00009.html
  - source: security@huntr.dev
    tags:
    - Third Party Advisory
    url: https://security.gentoo.org/glsa/202208-32
  - source: security@huntr.dev
    tags:
    - Vendor Advisory
    url: https://support.apple.com/kb/HT213444
  - source: security@huntr.dev
    tags:
    - Vendor Advisory
    url: https://support.apple.com/kb/HT213488
  title: Heap-based Buffer Overflow in GitHub repository vim/vim prior to 8.2.
- diff_content:
  - "--- a/src/ex_cmds.c\n+++ b/src/ex_cmds.c\n@@ -866,6 +866,8 @@ ex_copy(linenr_T\
    \ line1, linenr_T line2, linenr_T n)\n     }\n \n     appended_lines_mark(n, count);\n\
    +    if (VIsual_active)\n+\tcheck_pos(curbuf, &VIsual);\n \n     msgmore((long)count);\n\
    \ }"
  - "--- a/src/version.c\n+++ b/src/version.c\n@@ -750,6 +750,8 @@ static char *(features[])\
    \ =\n \n static int included_patches[] =\n {   /* Add new patch number below this\
    \ line */\n+/**/\n+    4215,\n /**/\n     4214,\n /**/"
  identifiers:
  - CVE-2022-0361
  - CWE-122
  overview: Heap-based Buffer Overflow in GitHub repository vim/vim prior to 8.2.
  references:
  - source: security@huntr.dev
    tags:
    - Mailing List
    - Third Party Advisory
    url: http://seclists.org/fulldisclosure/2022/Oct/28
  - source: security@huntr.dev
    tags:
    - Mailing List
    - Third Party Advisory
    url: http://seclists.org/fulldisclosure/2022/Oct/41
  - source: security@huntr.dev
    tags:
    - Mailing List
    - Third Party Advisory
    url: http://seclists.org/fulldisclosure/2022/Oct/43
  - source: security@huntr.dev
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/vim/vim/commit/dc5490e2cbc8c16022a23b449b48c1bd0083f366
  - source: security@huntr.dev
    tags:
    - Exploit
    - Issue Tracking
    - Patch
    - Third Party Advisory
    url: https://huntr.dev/bounties/a055618c-0311-409c-a78a-99477121965b
  - source: security@huntr.dev
    tags:
    - Mailing List
    - Third Party Advisory
    url: https://lists.debian.org/debian-lts-announce/2022/03/msg00018.html
  - source: security@huntr.dev
    tags:
    - Mailing List
    - Third Party Advisory
    url: https://lists.debian.org/debian-lts-announce/2022/11/msg00009.html
  - source: security@huntr.dev
    tags:
    - Third Party Advisory
    url: https://security.gentoo.org/glsa/202208-32
  - source: security@huntr.dev
    tags:
    - Third Party Advisory
    url: https://support.apple.com/kb/HT213444
  - source: security@huntr.dev
    tags:
    - Third Party Advisory
    url: https://support.apple.com/kb/HT213488
  title: Heap-based Buffer Overflow in GitHub repository vim/vim prior to 8.2.
- diff_content:
  - "--- a/src/undo.c\n+++ b/src/undo.c\n@@ -3029,6 +3029,8 @@ u_undo_end(\n \t}\n\
    \     }\n #endif\n+    if (VIsual_active)\n+\tcheck_pos(curbuf, &VIsual);\n \n\
    \     smsg_attr_keep(0, _(\"%ld %s; %s #%ld  %s\"),\n \t    u_oldcount < 0 ? -u_oldcount\
    \ : u_oldcount,"
  - "--- a/src/version.c\n+++ b/src/version.c\n@@ -750,6 +750,8 @@ static char *(features[])\
    \ =\n \n static int included_patches[] =\n {   /* Add new patch number below this\
    \ line */\n+/**/\n+    4217,\n /**/\n     4216,\n /**/"
  identifiers:
  - CVE-2022-0368
  - CWE-125
  overview: Out-of-bounds Read in GitHub repository vim/vim prior to 8.2.
  references:
  - source: security@huntr.dev
    tags:
    - Mailing List
    - Third Party Advisory
    url: http://seclists.org/fulldisclosure/2022/Oct/28
  - source: security@huntr.dev
    tags:
    - Mailing List
    - Third Party Advisory
    url: http://seclists.org/fulldisclosure/2022/Oct/41
  - source: security@huntr.dev
    tags:
    - Mailing List
    - Third Party Advisory
    url: http://seclists.org/fulldisclosure/2022/Oct/43
  - source: security@huntr.dev
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/vim/vim/commit/8d02ce1ed75d008c34a5c9aaa51b67cbb9d33baa
  - source: security@huntr.dev
    tags:
    - Exploit
    - Issue Tracking
    - Patch
    - Third Party Advisory
    url: https://huntr.dev/bounties/bca9ce1f-400a-4bf9-9207-3f3187cb3fa9
  - source: security@huntr.dev
    tags:
    - Mailing List
    - Third Party Advisory
    url: https://lists.debian.org/debian-lts-announce/2022/03/msg00018.html
  - source: security@huntr.dev
    tags:
    - Mailing List
    - Third Party Advisory
    url: https://lists.debian.org/debian-lts-announce/2022/11/msg00009.html
  - source: security@huntr.dev
    tags:
    - Third Party Advisory
    url: https://security.gentoo.org/glsa/202208-32
  - source: security@huntr.dev
    tags:
    - Vendor Advisory
    url: https://support.apple.com/kb/HT213444
  - source: security@huntr.dev
    tags:
    - Vendor Advisory
    url: https://support.apple.com/kb/HT213488
  title: Out-of-bounds Read in GitHub repository vim/vim prior to 8.2.
- diff_content:
  - "--- a/pjmedia/src/pjmedia/rtcp.c\n+++ b/pjmedia/src/pjmedia/rtcp.c\n@@ -502,12\
    \ +502,22 @@ static void parse_rtcp_report( pjmedia_rtcp_session *sess,\n \n \
    \    /* Parse RTCP */\n     if (common->pt == RTCP_SR) {\n+        if (sizeof\
    \ (pjmedia_rtcp_common) + sizeof (pjmedia_rtcp_sr) > size) {\n+\t    TRACE_((sess->name,\
    \ \"Discarding RTCP SR due to truncated size \"\n+\t    \t\t\t\"%d bytes\", size));\n\
    +            return;\n+        }\n \tsr = (pjmedia_rtcp_sr*) (((char*)pkt) + sizeof(pjmedia_rtcp_common));\n\
    \ \tif (common->count > 0 && size >= (sizeof(pjmedia_rtcp_sr_pkt))) {\n \t   \
    \ rr = (pjmedia_rtcp_rr*)(((char*)pkt) + (sizeof(pjmedia_rtcp_common)\n \t\t\t\
    \t    + sizeof(pjmedia_rtcp_sr)));\n \t}\n     } else if (common->pt == RTCP_RR\
    \ && common->count > 0) {\n+\tif (sizeof (pjmedia_rtcp_common) + sizeof (pjmedia_rtcp_rr)\
    \ > size) {\n+\t    TRACE_((sess->name, \"Discarding RTCP RR due to truncated\
    \ size \"\n+\t    \t\t\t\"%d bytes\", size));\n+\t    return;\n+\t}\n \trr = (pjmedia_rtcp_rr*)(((char*)pkt)\
    \ + sizeof(pjmedia_rtcp_common));\n #if defined(PJMEDIA_HAS_RTCP_XR) && (PJMEDIA_HAS_RTCP_XR\
    \ != 0)\n     } else if (common->pt == RTCP_XR) {\n@@ -826,12 +836,20 @@ PJ_DEF(void)\
    \ pjmedia_rtcp_rx_rtcp( pjmedia_rtcp_session *sess,\n     p = (pj_uint8_t*)pkt;\n\
    \     p_end = p + size;\n     while (p < p_end) {\n-\tpjmedia_rtcp_common *common\
    \ = (pjmedia_rtcp_common*)p;\n+\tpjmedia_rtcp_common *common;\n \tunsigned len;\n\
    \ \n+\tif (p + sizeof(pjmedia_rtcp_common) > p_end) {\n+\t    TRACE_((sess->name,\
    \ \"Receiving truncated RTCP packet (1)\"));\n+\t    break;\n+\t}\n+\tcommon =\
    \ (pjmedia_rtcp_common*)p;\n+\n \tlen = (pj_ntohs((pj_uint16_t)common->length)+1)\
    \ * 4;\n-\tif (p + len > p_end)\n+\tif (p + len > p_end) {\n+\t    TRACE_((sess->name,\
    \ \"Receiving truncated RTCP packet (2)\"));\n \t    break;\n+\t}\n \n \tswitch(common->pt)\
    \ {\n \tcase RTCP_SR:"
  - "--- a/pjmedia/src/pjmedia/rtcp_fb.c\n+++ b/pjmedia/src/pjmedia/rtcp_fb.c\n@@\
    \ -631,7 +631,8 @@ PJ_DEF(pj_status_t) pjmedia_rtcp_fb_parse_nack(\n     if (hdr->pt\
    \ != RTCP_RTPFB || hdr->count != 1)\n \treturn PJ_ENOTFOUND;\n \n-    cnt = pj_ntohs((pj_uint16_t)hdr->length)\
    \ - 2;\n+    cnt = pj_ntohs((pj_uint16_t)hdr->length);\n+    if (cnt > 2) cnt\
    \ -= 2; else cnt = 0;\n     if (length < (cnt+3)*4)\n \treturn PJ_ETOOSMALL;\n\
    \ \n@@ -663,7 +664,9 @@ PJ_DEF(pj_status_t) pjmedia_rtcp_fb_parse_pli(\n     pjmedia_rtcp_common\
    \ *hdr = (pjmedia_rtcp_common*) buf;\n \n     PJ_ASSERT_RETURN(buf, PJ_EINVAL);\n\
    -    PJ_ASSERT_RETURN(length >= 12, PJ_ETOOSMALL);\n+\n+    if (length < 12)\n\
    +    \treturn PJ_ETOOSMALL;\n \n     /* PLI uses pt==RTCP_PSFB and FMT==1 */\n\
    \     if (hdr->pt != RTCP_PSFB || hdr->count != 1)"
  - "--- a/pjmedia/src/pjmedia/rtp.c\n+++ b/pjmedia/src/pjmedia/rtp.c\n@@ -190,6 +190,8\
    \ @@ PJ_DEF(pj_status_t) pjmedia_rtp_decode_rtp2(\n \n     /* Decode RTP extension.\
    \ */\n     if ((*hdr)->x) {\n+        if (offset + sizeof (pjmedia_rtp_ext_hdr)\
    \ > pkt_len)\n+            return PJMEDIA_RTP_EINLEN;\n         dec_hdr->ext_hdr\
    \ = (pjmedia_rtp_ext_hdr*)(((pj_uint8_t*)pkt) + offset);\n         dec_hdr->ext\
    \ = (pj_uint32_t*)(dec_hdr->ext_hdr + 1);\n         dec_hdr->ext_len = pj_ntohs((dec_hdr->ext_hdr)->length);"
  identifiers:
  - CVE-2022-21722
  - CWE-125
  overview: PJSIP is a free and open source multimedia communication library written
    in C language implementing standard based protocols such as SIP, SDP, RTP, STUN,
    TURN, and ICE. In version 2.11.1 and prior, there are various cases where it is
    possible that certain incoming RTP/RTCP packets can potentially cause out-of-bound
    read access. This issue affects all users that use PJMEDIA and accept incoming
    RTP/RTCP. A patch is available as a commit in the `master` branch. There are no
    known workarounds.
  references:
  - source: security-advisories@github.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/pjsip/pjproject/commit/22af44e68a0c7d190ac1e25075e1382f77e9397a
  - source: security-advisories@github.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/pjsip/pjproject/security/advisories/GHSA-m66q-q64c-hv36
  - source: security-advisories@github.com
    tags:
    - Mailing List
    - Third Party Advisory
    url: https://lists.debian.org/debian-lts-announce/2022/03/msg00035.html
  - source: security-advisories@github.com
    tags:
    - Mailing List
    - Third Party Advisory
    url: https://lists.debian.org/debian-lts-announce/2022/11/msg00021.html
  - source: security-advisories@github.com
    url: https://lists.debian.org/debian-lts-announce/2023/08/msg00038.html
  - source: security-advisories@github.com
    tags:
    - Third Party Advisory
    url: https://security.gentoo.org/glsa/202210-37
  - source: security-advisories@github.com
    tags:
    - Third Party Advisory
    url: https://www.debian.org/security/2022/dsa-5285
  title: PJSIP is a free and open source multimedia communication library written
    in C language implementing standard based protocols such as SIP, SDP, RTP, STUN,
    TURN, and ICE. In version 2.11.1 and prior, there are various cases where it is
    possible that certain incoming RTP/RTCP packets can potentially cause out-of-bound
    read access. This issue affects all users that use PJMEDIA and accept incoming
    RTP/RTCP. A patch is available as a commit in the `master` branch. There are no
    known workarounds.
- diff_content:
  - "--- a/pjlib-util/src/pjlib-util/scanner.c\n+++ b/pjlib-util/src/pjlib-util/scanner.c\n\
    @@ -444,16 +444,21 @@ PJ_DEF(void) pj_scan_get_n( pj_scanner *scanner,\n \n PJ_DEF(int)\
    \ pj_scan_get_char( pj_scanner *scanner )\n {\n-    int chr = *scanner->curptr;\n\
    +    register char *s = scanner->curptr;\n+    int chr;\n \n-    if (!chr) {\n\
    +    if (s >= scanner->end || !*s) {\n \tpj_scan_syntax_err(scanner);\n \treturn\
    \ 0;\n     }\n \n-    ++scanner->curptr;\n+    chr = *s;\n \n-    if (PJ_SCAN_IS_PROBABLY_SPACE(*scanner->curptr)\
    \ && scanner->skip_ws) {\n+    ++s;\n+    scanner->curptr = s;\n+    if (PJ_SCAN_CHECK_EOF(s)\
    \ && PJ_SCAN_IS_PROBABLY_SPACE(*s) &&\n+    \tscanner->skip_ws)\n+    {\n \tpj_scan_skip_whitespace(scanner);\n\
    \     }\n     return chr;"
  identifiers:
  - CVE-2022-21723
  - CWE-125
  overview: PJSIP is a free and open source multimedia communication library written
    in C language implementing standard based protocols such as SIP, SDP, RTP, STUN,
    TURN, and ICE. In versions 2.11.1 and prior, parsing an incoming SIP message that
    contains a malformed multipart can potentially cause out-of-bound read access.
    This issue affects all PJSIP users that accept SIP multipart. The patch is available
    as commit in the `master` branch. There are no known workarounds.
  references:
  - source: security-advisories@github.com
    tags:
    - Third Party Advisory
    - VDB Entry
    url: http://packetstormsecurity.com/files/166227/Asterisk-Project-Security-Advisory-AST-2022-006.html
  - source: security-advisories@github.com
    tags:
    - Mailing List
    - Patch
    - Third Party Advisory
    url: http://seclists.org/fulldisclosure/2022/Mar/2
  - source: security-advisories@github.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/pjsip/pjproject/commit/077b465c33f0aec05a49cd2ca456f9a1b112e896
  - source: security-advisories@github.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/pjsip/pjproject/security/advisories/GHSA-7fw8-54cv-r7pm
  - source: security-advisories@github.com
    tags:
    - Mailing List
    - Third Party Advisory
    url: https://lists.debian.org/debian-lts-announce/2022/03/msg00035.html
  - source: security-advisories@github.com
    tags:
    - Mailing List
    - Third Party Advisory
    url: https://lists.debian.org/debian-lts-announce/2022/11/msg00021.html
  - source: security-advisories@github.com
    url: https://lists.debian.org/debian-lts-announce/2023/08/msg00038.html
  - source: security-advisories@github.com
    tags:
    - Third Party Advisory
    url: https://security.gentoo.org/glsa/202210-37
  - source: security-advisories@github.com
    tags:
    - Third Party Advisory
    url: https://www.debian.org/security/2022/dsa-5285
  title: PJSIP is a free and open source multimedia communication library written
    in C language implementing standard based protocols such as SIP, SDP, RTP, STUN,
    TURN, and ICE. In versions 2.11.1 and prior, parsing an incoming SIP message that
    contains a malformed multipart can potentially cause out-of-bound read access.
    This issue affects all PJSIP users that accept SIP multipart. The patch is available
    as commit in the `master` branch. There are no known workarounds.
- diff_content:
  - "--- a/src/edit.c\n+++ b/src/edit.c\n@@ -4452,7 +4452,8 @@ bracketed_paste(paste_mode_T\
    \ mode, int drop, garray_T *gap)\n \t\t    break;\n \n \t\tcase PASTE_EX:\n-\t\
    \t    if (gap != NULL && ga_grow(gap, idx) == OK)\n+\t\t    // add one for the\
    \ NUL that is going to be appended\n+\t\t    if (gap != NULL && ga_grow(gap, idx\
    \ + 1) == OK)\n \t\t    {\n \t\t\tmch_memmove((char *)gap->ga_data + gap->ga_len,\n\
    \ \t\t\t\t\t\t\t     buf, (size_t)idx);"
  - "--- a/src/version.c\n+++ b/src/version.c\n@@ -750,6 +750,8 @@ static char *(features[])\
    \ =\n \n static int included_patches[] =\n {   /* Add new patch number below this\
    \ line */\n+/**/\n+    4218,\n /**/\n     4217,\n /**/"
  identifiers:
  - CVE-2022-0392
  - CWE-122
  overview: Heap-based Buffer Overflow in GitHub repository vim prior to 8.2.
  references:
  - source: security@huntr.dev
    tags:
    - Mailing List
    - Third Party Advisory
    url: http://seclists.org/fulldisclosure/2022/Oct/28
  - source: security@huntr.dev
    tags:
    - Mailing List
    - Third Party Advisory
    url: http://seclists.org/fulldisclosure/2022/Oct/41
  - source: security@huntr.dev
    tags:
    - Mailing List
    - Third Party Advisory
    url: http://seclists.org/fulldisclosure/2022/Oct/43
  - source: security@huntr.dev
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/vim/vim/commit/806d037671e133bd28a7864248763f643967973a
  - source: security@huntr.dev
    tags:
    - Exploit
    - Patch
    - Third Party Advisory
    url: https://huntr.dev/bounties/d00a2acd-1935-4195-9d5b-4115ef6b3126
  - source: security@huntr.dev
    tags:
    - Mailing List
    - Third Party Advisory
    url: https://lists.debian.org/debian-lts-announce/2022/11/msg00032.html
  - source: security@huntr.dev
    tags:
    - Third Party Advisory
    url: https://security.gentoo.org/glsa/202208-32
  - source: security@huntr.dev
    tags:
    - Vendor Advisory
    url: https://support.apple.com/kb/HT213444
  - source: security@huntr.dev
    tags:
    - Vendor Advisory
    url: https://support.apple.com/kb/HT213488
  title: Heap-based Buffer Overflow in GitHub repository vim prior to 8.2.
- diff_content:
  - "--- a/src/getchar.c\n+++ b/src/getchar.c\n@@ -252,8 +252,11 @@ add_buff(\n  \
    \   static void\n delete_buff_tail(buffheader_T *buf, int slen)\n {\n-    int\
    \ len = (int)STRLEN(buf->bh_curr->b_str);\n+    int len;\n \n+    if (buf->bh_curr\
    \ == NULL || buf->bh_curr->b_str == NULL)\n+\treturn;  // nothing to delete\n\
    +    len = (int)STRLEN(buf->bh_curr->b_str);\n     if (len >= slen)\n     {\n\
    \ \tbuf->bh_curr->b_str[len - slen] = NUL;"
  - "--- a/src/version.c\n+++ b/src/version.c\n@@ -750,6 +750,8 @@ static char *(features[])\
    \ =\n \n static int included_patches[] =\n {   /* Add new patch number below this\
    \ line */\n+/**/\n+    4233,\n /**/\n     4232,\n /**/"
  identifiers:
  - CVE-2022-0393
  - CWE-125
  overview: Out-of-bounds Read in GitHub repository vim/vim prior to 8.2.
  references:
  - source: security@huntr.dev
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/vim/vim/commit/a4bc2dd7cccf5a4a9f78b58b6f35a45d17164323
  - source: security@huntr.dev
    tags:
    - Exploit
    - Patch
    - Third Party Advisory
    url: https://huntr.dev/bounties/ecc8f488-01a0-477f-848f-e30b8e524bba
  - source: security@huntr.dev
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/7ZLEHVP4LNAGER4ZDGUDS5V5YVQD6INF/
  - source: security@huntr.dev
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/UFXFAILMLUIK4MBUEZO4HNBNKYZRJ5AP/
  - source: security@huntr.dev
    tags:
    - Third Party Advisory
    url: https://security.gentoo.org/glsa/202208-32
  title: Out-of-bounds Read in GitHub repository vim/vim prior to 8.2.
- diff_content:
  - "--- a/kernel/ucount.c\n+++ b/kernel/ucount.c\n@@ -190,6 +190,7 @@ struct ucounts\
    \ *alloc_ucounts(struct user_namespace *ns, kuid_t uid)\n \t\t\tkfree(new);\n\
    \ \t\t} else {\n \t\t\thlist_add_head(&new->node, hashent);\n+\t\t\tget_user_ns(new->ns);\n\
    \ \t\t\tspin_unlock_irq(&ucounts_lock);\n \t\t\treturn new;\n \t\t}\n@@ -210,6\
    \ +211,7 @@ void put_ucounts(struct ucounts *ucounts)\n \tif (atomic_dec_and_lock_irqsave(&ucounts->count,\
    \ &ucounts_lock, flags)) {\n \t\thlist_del_init(&ucounts->node);\n \t\tspin_unlock_irqrestore(&ucounts_lock,\
    \ flags);\n+\t\tput_user_ns(ucounts->ns);\n \t\tkfree(ucounts);\n \t}\n }"
  identifiers:
  - CVE-2022-24122
  - CWE-416
  overview: kernel/ucount.c in the Linux kernel 5.14 through 5.16.4, when unprivileged
    user namespaces are enabled, allows a use-after-free and privilege escalation
    because a ucounts object can outlive its namespace.
  references:
  - source: cve@mitre.org
    tags:
    - Mailing List
    - Patch
    - Vendor Advisory
    url: https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=f9d87929d451d3e649699d0f1d74f71f77ad38f5
  - source: cve@mitre.org
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/torvalds/linux/commit/f9d87929d451d3e649699d0f1d74f71f77ad38f5
  - source: cve@mitre.org
    tags:
    - Mailing List
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/HSR3AI2IQGRKZCHNKF6S25JGDKUEAWWL/
  - source: cve@mitre.org
    tags:
    - Mailing List
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/VVSZKUJAZ2VN6LJ35J2B6YD6BOPQTU3B/
  - source: cve@mitre.org
    tags:
    - Third Party Advisory
    url: https://security.netapp.com/advisory/ntap-20220221-0001/
  - source: cve@mitre.org
    tags:
    - Exploit
    - Mailing List
    - Third Party Advisory
    url: https://www.openwall.com/lists/oss-security/2022/01/29/1
  title: kernel/ucount.c in the Linux kernel 5.14 through 5.16.4, when unprivileged
    user namespaces are enabled, allows a use-after-free and privilege escalation
    because a ucounts object can outlive its namespace.
- diff_content:
  - "--- a/src/register.c\n+++ b/src/register.c\n@@ -1474,7 +1474,7 @@ yank_copy_line(struct\
    \ block_def *bd, long y_idx, int exclude_trailing_space)\n     {\n \tint s = bd->textlen\
    \ + bd->endspaces;\n \n-\twhile (VIM_ISWHITE(*(bd->textstart + s - 1)) && s >\
    \ 0)\n+\twhile (s > 0 && VIM_ISWHITE(*(bd->textstart + s - 1)))\n \t{\n \t   \
    \ s = s - (*mb_head_off)(bd->textstart, bd->textstart + s - 1) - 1;\n \t    pnew--;"
  - "--- a/src/version.c\n+++ b/src/version.c\n@@ -750,6 +750,8 @@ static char *(features[])\
    \ =\n \n static int included_patches[] =\n {   /* Add new patch number below this\
    \ line */\n+/**/\n+    4219,\n /**/\n     4218,\n /**/"
  identifiers:
  - CVE-2022-0407
  - CWE-122
  overview: Heap-based Buffer Overflow in GitHub repository vim/vim prior to 8.2.
  references:
  - source: security@huntr.dev
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/vim/vim/commit/44db8213d38c39877d2148eff6a72f4beccfb94e
  - source: security@huntr.dev
    tags:
    - Exploit
    - Patch
    - Third Party Advisory
    url: https://huntr.dev/bounties/81822bf7-aafe-4d37-b836-1255d46e572c
  - source: security@huntr.dev
    tags:
    - Third Party Advisory
    url: https://security.gentoo.org/glsa/202208-32
  title: Heap-based Buffer Overflow in GitHub repository vim/vim prior to 8.2.
- diff_content:
  - "--- a/src/spellsuggest.c\n+++ b/src/spellsuggest.c\n@@ -1205,7 +1205,7 @@ suggest_try_change(suginfo_T\
    \ *su)\n \n // Check the maximum score, if we go over it we won't try this change.\n\
    \ #define TRY_DEEPER(su, stack, depth, add) \\\n-\t\t(stack[depth].ts_score +\
    \ (add) < su->su_maxscore)\n+\t   (depth < MAXWLEN && stack[depth].ts_score +\
    \ (add) < su->su_maxscore)\n \n /*\n  * Try finding suggestions by adding/removing/swapping\
    \ letters.\n@@ -1277,6 +1277,9 @@ suggest_trie_walk(\n     char_u\tchangename[MAXWLEN][80];\n\
    \ #endif\n     int\t\tbreakcheckcount = 1000;\n+#ifdef FEAT_RELTIME\n+    proftime_T\t\
    time_limit;\n+#endif\n     int\t\tcompound_ok;\n \n     // Go through the whole\
    \ case-fold tree, try changes at each node.\n@@ -1321,6 +1324,11 @@ suggest_trie_walk(\n\
    \ \t    sp->ts_state = STATE_START;\n \t}\n     }\n+#ifdef FEAT_RELTIME\n+   \
    \ // The loop may take an indefinite amount of time. Break out after five\n+ \
    \   // sectonds. TODO: add an option for the time limit.\n+    profile_setlimit(5000,\
    \ &time_limit);\n+#endif\n \n     // Loop to find all suggestions.  At each round\
    \ we either:\n     // - For the current state try one operation, advance \"ts_curi\"\
    ,\n@@ -1355,7 +1363,8 @@ suggest_trie_walk(\n \n \t\t// At end of a prefix or\
    \ at start of prefixtree: check for\n \t\t// following word.\n-\t\tif (byts[arridx]\
    \ == 0 || n == (int)STATE_NOPREFIX)\n+\t\tif (depth < MAXWLEN\n+\t\t\t    && (byts[arridx]\
    \ == 0 || n == (int)STATE_NOPREFIX))\n \t\t{\n \t\t    // Set su->su_badflags\
    \ to the caps type at this position.\n \t\t    // Use the caps type until here\
    \ for the prefix itself.\n@@ -2649,6 +2658,10 @@ suggest_trie_walk(\n \t    {\n\
    \ \t\tui_breakcheck();\n \t\tbreakcheckcount = 1000;\n+#ifdef FEAT_RELTIME\n+\t\
    \tif (profile_passed_limit(&time_limit))\n+\t\t    got_int = TRUE;\n+#endif\n\
    \ \t    }\n \t}\n     }"
  - "--- a/src/version.c\n+++ b/src/version.c\n@@ -750,6 +750,8 @@ static char *(features[])\
    \ =\n \n static int included_patches[] =\n {   /* Add new patch number below this\
    \ line */\n+/**/\n+    4247,\n /**/\n     4246,\n /**/"
  identifiers:
  - CVE-2022-0408
  - CWE-121
  overview: Stack-based Buffer Overflow in GitHub repository vim/vim prior to 8.2.
  references:
  - source: security@huntr.dev
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/vim/vim/commit/06f15416bb8d5636200a10776f1752c4d6e49f31
  - source: security@huntr.dev
    tags:
    - Exploit
    - Patch
    - Third Party Advisory
    url: https://huntr.dev/bounties/5e635bad-5cf6-46cd-aeac-34ef224e179d
  - source: security@huntr.dev
    tags:
    - Mailing List
    - Third Party Advisory
    url: https://lists.debian.org/debian-lts-announce/2022/03/msg00018.html
  - source: security@huntr.dev
    tags:
    - Mailing List
    - Third Party Advisory
    url: https://lists.debian.org/debian-lts-announce/2022/11/msg00009.html
  - source: security@huntr.dev
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/7ZLEHVP4LNAGER4ZDGUDS5V5YVQD6INF/
  - source: security@huntr.dev
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/UFXFAILMLUIK4MBUEZO4HNBNKYZRJ5AP/
  - source: security@huntr.dev
    tags:
    - Third Party Advisory
    url: https://security.gentoo.org/glsa/202208-32
  title: Stack-based Buffer Overflow in GitHub repository vim/vim prior to 8.2.
- diff_content:
  - "--- a/src/ex_cmds.c\n+++ b/src/ex_cmds.c\n@@ -3687,6 +3687,7 @@ ex_substitute(exarg_T\
    \ *eap)\n     int\t\tsave_do_all;\t\t// remember user specified 'g' flag\n   \
    \  int\t\tsave_do_ask;\t\t// remember user specified 'c' flag\n     char_u\t*pat\
    \ = NULL, *sub = NULL;\t// init for GCC\n+    char_u\t*sub_copy = NULL;\n    \
    \ int\t\tdelimiter;\n     int\t\tsublen;\n     int\t\tgot_quit = FALSE;\n@@ -3980,11\
    \ +3981,20 @@ ex_substitute(exarg_T *eap)\n     sub_firstline = NULL;\n \n   \
    \  /*\n-     * ~ in the substitute pattern is replaced with the old pattern.\n\
    -     * We do it here once to avoid it to be replaced over and over again.\n-\
    \     * But don't do it when it starts with \"\\=\", then it's an expression.\n\
    +     * If the substitute pattern starts with \"\\=\" then it's an expression.\n\
    +     * Make a copy, a recursive function may free it.\n+     * Otherwise, '~'\
    \ in the substitute pattern is replaced with the old\n+     * pattern.  We do\
    \ it here once to avoid it to be replaced over and over\n+     * again.\n    \
    \  */\n-    if (!(sub[0] == '\\\\' && sub[1] == '='))\n+    if (sub[0] == '\\\\\
    ' && sub[1] == '=')\n+    {\n+\tsub = vim_strsave(sub);\n+\tif (sub == NULL)\n\
    +\t    return;\n+\tsub_copy = sub;\n+    }\n+    else\n \tsub = regtilde(sub,\
    \ magic_isset());\n \n     /*\n@@ -4790,6 +4800,7 @@ ex_substitute(exarg_T *eap)\n\
    \ #endif\n \n     vim_regfree(regmatch.regprog);\n+    vim_free(sub_copy);\n \n\
    \     // Restore the flag values, they can be used for \":&&\".\n     subflags.do_all\
    \ = save_do_all;"
  - "--- a/src/version.c\n+++ b/src/version.c\n@@ -750,6 +750,8 @@ static char *(features[])\
    \ =\n \n static int included_patches[] =\n {   /* Add new patch number below this\
    \ line */\n+/**/\n+    4253,\n /**/\n     4252,\n /**/"
  identifiers:
  - CVE-2022-0413
  - CWE-416
  overview: Use After Free in GitHub repository vim/vim prior to 8.2.
  references:
  - source: security@huntr.dev
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/vim/vim/commit/37f47958b8a2a44abc60614271d9537e7f14e51a
  - source: security@huntr.dev
    tags:
    - Exploit
    - Patch
    - Third Party Advisory
    url: https://huntr.dev/bounties/563d1e8f-5c3d-4669-941c-3216f4a87c38
  - source: security@huntr.dev
    tags:
    - Mailing List
    - Third Party Advisory
    url: https://lists.debian.org/debian-lts-announce/2022/05/msg00022.html
  - source: security@huntr.dev
    tags:
    - Mailing List
    - Third Party Advisory
    url: https://lists.debian.org/debian-lts-announce/2022/11/msg00009.html
  - source: security@huntr.dev
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/7ZLEHVP4LNAGER4ZDGUDS5V5YVQD6INF/
  - source: security@huntr.dev
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/UFXFAILMLUIK4MBUEZO4HNBNKYZRJ5AP/
  - source: security@huntr.dev
    tags:
    - Third Party Advisory
    url: https://security.gentoo.org/glsa/202208-32
  title: Use After Free in GitHub repository vim/vim prior to 8.2.
- diff_content:
  - "--- a/modules/juce_core/files/juce_TemporaryFile.cpp\n+++ b/modules/juce_core/files/juce_TemporaryFile.cpp\n\
    @@ -105,7 +105,7 @@ bool TemporaryFile::deleteTemporaryFile() const\n     // Have\
    \ a few attempts at deleting the file before giving up..\r\n     for (int i =\
    \ 5; --i >= 0;)\r\n     {\r\n-        if (temporaryFile.deleteFile())\r\n+   \
    \     if (temporaryFile.isDirectory() ? temporaryFile.deleteRecursively() : temporaryFile.deleteFile())\r\
    \n             return true;\r\n \r\n         Thread::sleep (50);\r"
  - "--- a/modules/juce_core/zip/juce_ZipFile.cpp\n+++ b/modules/juce_core/zip/juce_ZipFile.cpp\n\
    @@ -122,6 +122,19 @@ static int64 findCentralDirectoryFileHeader (InputStream&\
    \ input, int& numEntries\n     return 0;\r\n }\r\n \r\n+static bool hasSymbolicPart\
    \ (const File& root, const File& f)\r\n+{\r\n+    jassert (root == f || f.isAChildOf\
    \ (root));\r\n+\r\n+    for (auto p = f; p != root; p = p.getParentDirectory())\r\
    \n+    {\r\n+        if (p.isSymbolicLink())\r\n+            return true;\r\n\
    +    }\r\n+\r\n+    return false;\r\n+}\r\n+\r\n //==============================================================================\r\
    \n struct ZipFile::ZipInputStream  : public InputStream\r\n {\r\n@@ -400,6 +413,14\
    \ @@ Result ZipFile::uncompressTo (const File& targetDirectory,\n }\r\n \r\n Result\
    \ ZipFile::uncompressEntry (int index, const File& targetDirectory, bool shouldOverwriteFiles)\r\
    \n+{\r\n+    return uncompressEntry (index,\r\n+                            targetDirectory,\r\
    \n+                            shouldOverwriteFiles ? OverwriteFiles::yes : OverwriteFiles::no,\r\
    \n+                            FollowSymlinks::no);\r\n+}\r\n+\r\n+Result ZipFile::uncompressEntry\
    \ (int index, const File& targetDirectory, OverwriteFiles overwriteFiles, FollowSymlinks\
    \ followSymlinks)\r\n {\r\n     auto* zei = entries.getUnchecked (index);\r\n\
    \ \r\n@@ -414,6 +435,9 @@ Result ZipFile::uncompressEntry (int index, const File&\
    \ targetDirectory, bool sh\n \r\n     auto targetFile = targetDirectory.getChildFile\
    \ (entryPath);\r\n \r\n+    if (! targetFile.isAChildOf (targetDirectory))\r\n\
    +        return Result::fail (\"Entry \" + entryPath + \" is outside the target\
    \ directory\");\r\n+\r\n     if (entryPath.endsWithChar ('/') || entryPath.endsWithChar\
    \ ('\\\\'))\r\n         return targetFile.createDirectory(); // (entry is a directory,\
    \ not a file)\r\n \r\n@@ -424,13 +448,16 @@ Result ZipFile::uncompressEntry (int\
    \ index, const File& targetDirectory, bool sh\n \r\n     if (targetFile.exists())\r\
    \n     {\r\n-        if (! shouldOverwriteFiles)\r\n+        if (overwriteFiles\
    \ == OverwriteFiles::no)\r\n             return Result::ok();\r\n \r\n       \
    \  if (! targetFile.deleteFile())\r\n             return Result::fail (\"Failed\
    \ to write to target file: \" + targetFile.getFullPathName());\r\n     }\r\n \r\
    \n+    if (followSymlinks == FollowSymlinks::no && hasSymbolicPart (targetDirectory,\
    \ targetFile.getParentDirectory()))\r\n+        return Result::fail (\"Parent\
    \ directory leads through symlink for target file: \" + targetFile.getFullPathName());\r\
    \n+\r\n     if (! targetFile.getParentDirectory().createDirectory())\r\n     \
    \    return Result::fail (\"Failed to create target folder: \" + targetFile.getParentDirectory().getFullPathName());\r\
    \n \r\n@@ -649,12 +676,9 @@ struct ZIPTests   : public UnitTest\n         : UnitTest\
    \ (\"ZIP\", UnitTestCategories::compression)\r\n     {}\r\n \r\n-    void runTest()\
    \ override\r\n+    static MemoryBlock createZipMemoryBlock (const StringArray&\
    \ entryNames)\r\n     {\r\n-        beginTest (\"ZIP\");\r\n-\r\n         ZipFile::Builder\
    \ builder;\r\n-        StringArray entryNames { \"first\", \"second\", \"third\"\
    \ };\r\n         HashMap<String, MemoryBlock> blocks;\r\n \r\n         for (auto&\
    \ entryName : entryNames)\r\n@@ -669,8 +693,61 @@ struct ZIPTests   : public UnitTest\n\
    \         MemoryBlock data;\r\n         MemoryOutputStream mo (data, false);\r\
    \n         builder.writeToStream (mo, nullptr);\r\n+\r\n+        return data;\r\
    \n+    }\r\n+\r\n+    void runZipSlipTest()\r\n+    {\r\n+        const std::map<String,\
    \ bool> testCases = { { \"a\",                    true  },\r\n+#if JUCE_WINDOWS\r\
    \n+                                                   { \"C:/b\",            \
    \     false },\r\n+#else\r\n+                                                \
    \   { \"/b\",                   false },\r\n+#endif\r\n+                     \
    \                              { \"c/d\",                  true  },\r\n+     \
    \                                              { \"../e/f\",               false\
    \ },\r\n+                                                   { \"../../g/h\", \
    \           false },\r\n+                                                   {\
    \ \"i/../j\",               true  },\r\n+                                    \
    \               { \"k/l/../\",              true  },\r\n+                    \
    \                               { \"m/n/../../\",           false },\r\n+    \
    \                                               { \"o/p/../../../\",        false\
    \ } };\r\n+\r\n+        StringArray entryNames;\r\n+\r\n+        for (const auto&\
    \ testCase : testCases)\r\n+            entryNames.add (testCase.first);\r\n+\r\
    \n+        TemporaryFile tmpDir;\r\n+        tmpDir.getFile().createDirectory();\r\
    \n+        auto data = createZipMemoryBlock (entryNames);\r\n         MemoryInputStream\
    \ mi (data, false);\r\n+        ZipFile zip (mi);\r\n+\r\n+        for (int i\
    \ = 0; i < zip.getNumEntries(); ++i)\r\n+        {\r\n+            const auto\
    \ result = zip.uncompressEntry (i, tmpDir.getFile());\r\n+            const auto\
    \ caseIt = testCases.find (zip.getEntry (i)->filename);\r\n \r\n+            if\
    \ (caseIt != testCases.end())\r\n+            {\r\n+                expect (result.wasOk()\
    \ == caseIt->second,\r\n+                        zip.getEntry (i)->filename +\
    \ \" was unexpectedly \" + (result.wasOk() ? \"OK\" : \"not OK\"));\r\n+     \
    \       }\r\n+            else\r\n+            {\r\n+                expect (false);\r\
    \n+            }\r\n+        }\r\n+    }\r\n+\r\n+    void runTest() override\r\
    \n+    {\r\n+        beginTest (\"ZIP\");\r\n+\r\n+        StringArray entryNames\
    \ { \"first\", \"second\", \"third\" };\r\n+        auto data = createZipMemoryBlock\
    \ (entryNames);\r\n+        MemoryInputStream mi (data, false);\r\n         ZipFile\
    \ zip (mi);\r\n \r\n         expectEquals (zip.getNumEntries(), entryNames.size());\r\
    \n@@ -681,6 +758,9 @@ struct ZIPTests   : public UnitTest\n             std::unique_ptr<InputStream>\
    \ input (zip.createStreamForEntry (*entry));\r\n             expectEquals (input->readEntireStreamAsString(),\
    \ entryName);\r\n         }\r\n+\r\n+        beginTest (\"ZipSlip\");\r\n+   \
    \     runZipSlipTest();\r\n     }\r\n };\r\n \r"
  identifiers:
  - CVE-2021-23520
  - CWE-22
  overview: The package juce-framework/juce before 6.1.5 are vulnerable to Arbitrary
    File Write via Archive Extraction (Zip Slip) via the ZipFile::uncompressEntry
    function in juce_ZipFile.cpp. This vulnerability is triggered when the archive
    is extracted upon calling uncompressTo() on a ZipFile object.
  references:
  - source: report@snyk.io
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/juce-framework/JUCE/commit/2e874e80cba0152201aff6a4d0dc407997d10a7f
  - source: report@snyk.io
    tags:
    - Exploit
    - Technical Description
    - Third Party Advisory
    url: https://snyk.io/research/zip-slip-vulnerability
  - source: report@snyk.io
    tags:
    - Exploit
    - Patch
    - Third Party Advisory
    url: https://snyk.io/vuln/SNYK-UNMANAGED-JUCEFRAMEWORKJUCE-2388607
  title: The package juce-framework/juce before 6.1.5 are vulnerable to Arbitrary
    File Write via Archive Extraction (Zip Slip) via the ZipFile::uncompressEntry
    function in juce_ZipFile.cpp. This vulnerability is triggered when the archive
    is extracted upon calling uncompressTo() on a ZipFile object.
- diff_content:
  - "--- a/modules/juce_core/files/juce_TemporaryFile.cpp\n+++ b/modules/juce_core/files/juce_TemporaryFile.cpp\n\
    @@ -105,7 +105,7 @@ bool TemporaryFile::deleteTemporaryFile() const\n     // Have\
    \ a few attempts at deleting the file before giving up..\r\n     for (int i =\
    \ 5; --i >= 0;)\r\n     {\r\n-        if (temporaryFile.deleteFile())\r\n+   \
    \     if (temporaryFile.isDirectory() ? temporaryFile.deleteRecursively() : temporaryFile.deleteFile())\r\
    \n             return true;\r\n \r\n         Thread::sleep (50);\r"
  - "--- a/modules/juce_core/zip/juce_ZipFile.cpp\n+++ b/modules/juce_core/zip/juce_ZipFile.cpp\n\
    @@ -122,6 +122,19 @@ static int64 findCentralDirectoryFileHeader (InputStream&\
    \ input, int& numEntries\n     return 0;\r\n }\r\n \r\n+static bool hasSymbolicPart\
    \ (const File& root, const File& f)\r\n+{\r\n+    jassert (root == f || f.isAChildOf\
    \ (root));\r\n+\r\n+    for (auto p = f; p != root; p = p.getParentDirectory())\r\
    \n+    {\r\n+        if (p.isSymbolicLink())\r\n+            return true;\r\n\
    +    }\r\n+\r\n+    return false;\r\n+}\r\n+\r\n //==============================================================================\r\
    \n struct ZipFile::ZipInputStream  : public InputStream\r\n {\r\n@@ -400,6 +413,14\
    \ @@ Result ZipFile::uncompressTo (const File& targetDirectory,\n }\r\n \r\n Result\
    \ ZipFile::uncompressEntry (int index, const File& targetDirectory, bool shouldOverwriteFiles)\r\
    \n+{\r\n+    return uncompressEntry (index,\r\n+                            targetDirectory,\r\
    \n+                            shouldOverwriteFiles ? OverwriteFiles::yes : OverwriteFiles::no,\r\
    \n+                            FollowSymlinks::no);\r\n+}\r\n+\r\n+Result ZipFile::uncompressEntry\
    \ (int index, const File& targetDirectory, OverwriteFiles overwriteFiles, FollowSymlinks\
    \ followSymlinks)\r\n {\r\n     auto* zei = entries.getUnchecked (index);\r\n\
    \ \r\n@@ -414,6 +435,9 @@ Result ZipFile::uncompressEntry (int index, const File&\
    \ targetDirectory, bool sh\n \r\n     auto targetFile = targetDirectory.getChildFile\
    \ (entryPath);\r\n \r\n+    if (! targetFile.isAChildOf (targetDirectory))\r\n\
    +        return Result::fail (\"Entry \" + entryPath + \" is outside the target\
    \ directory\");\r\n+\r\n     if (entryPath.endsWithChar ('/') || entryPath.endsWithChar\
    \ ('\\\\'))\r\n         return targetFile.createDirectory(); // (entry is a directory,\
    \ not a file)\r\n \r\n@@ -424,13 +448,16 @@ Result ZipFile::uncompressEntry (int\
    \ index, const File& targetDirectory, bool sh\n \r\n     if (targetFile.exists())\r\
    \n     {\r\n-        if (! shouldOverwriteFiles)\r\n+        if (overwriteFiles\
    \ == OverwriteFiles::no)\r\n             return Result::ok();\r\n \r\n       \
    \  if (! targetFile.deleteFile())\r\n             return Result::fail (\"Failed\
    \ to write to target file: \" + targetFile.getFullPathName());\r\n     }\r\n \r\
    \n+    if (followSymlinks == FollowSymlinks::no && hasSymbolicPart (targetDirectory,\
    \ targetFile.getParentDirectory()))\r\n+        return Result::fail (\"Parent\
    \ directory leads through symlink for target file: \" + targetFile.getFullPathName());\r\
    \n+\r\n     if (! targetFile.getParentDirectory().createDirectory())\r\n     \
    \    return Result::fail (\"Failed to create target folder: \" + targetFile.getParentDirectory().getFullPathName());\r\
    \n \r\n@@ -649,12 +676,9 @@ struct ZIPTests   : public UnitTest\n         : UnitTest\
    \ (\"ZIP\", UnitTestCategories::compression)\r\n     {}\r\n \r\n-    void runTest()\
    \ override\r\n+    static MemoryBlock createZipMemoryBlock (const StringArray&\
    \ entryNames)\r\n     {\r\n-        beginTest (\"ZIP\");\r\n-\r\n         ZipFile::Builder\
    \ builder;\r\n-        StringArray entryNames { \"first\", \"second\", \"third\"\
    \ };\r\n         HashMap<String, MemoryBlock> blocks;\r\n \r\n         for (auto&\
    \ entryName : entryNames)\r\n@@ -669,8 +693,61 @@ struct ZIPTests   : public UnitTest\n\
    \         MemoryBlock data;\r\n         MemoryOutputStream mo (data, false);\r\
    \n         builder.writeToStream (mo, nullptr);\r\n+\r\n+        return data;\r\
    \n+    }\r\n+\r\n+    void runZipSlipTest()\r\n+    {\r\n+        const std::map<String,\
    \ bool> testCases = { { \"a\",                    true  },\r\n+#if JUCE_WINDOWS\r\
    \n+                                                   { \"C:/b\",            \
    \     false },\r\n+#else\r\n+                                                \
    \   { \"/b\",                   false },\r\n+#endif\r\n+                     \
    \                              { \"c/d\",                  true  },\r\n+     \
    \                                              { \"../e/f\",               false\
    \ },\r\n+                                                   { \"../../g/h\", \
    \           false },\r\n+                                                   {\
    \ \"i/../j\",               true  },\r\n+                                    \
    \               { \"k/l/../\",              true  },\r\n+                    \
    \                               { \"m/n/../../\",           false },\r\n+    \
    \                                               { \"o/p/../../../\",        false\
    \ } };\r\n+\r\n+        StringArray entryNames;\r\n+\r\n+        for (const auto&\
    \ testCase : testCases)\r\n+            entryNames.add (testCase.first);\r\n+\r\
    \n+        TemporaryFile tmpDir;\r\n+        tmpDir.getFile().createDirectory();\r\
    \n+        auto data = createZipMemoryBlock (entryNames);\r\n         MemoryInputStream\
    \ mi (data, false);\r\n+        ZipFile zip (mi);\r\n+\r\n+        for (int i\
    \ = 0; i < zip.getNumEntries(); ++i)\r\n+        {\r\n+            const auto\
    \ result = zip.uncompressEntry (i, tmpDir.getFile());\r\n+            const auto\
    \ caseIt = testCases.find (zip.getEntry (i)->filename);\r\n \r\n+            if\
    \ (caseIt != testCases.end())\r\n+            {\r\n+                expect (result.wasOk()\
    \ == caseIt->second,\r\n+                        zip.getEntry (i)->filename +\
    \ \" was unexpectedly \" + (result.wasOk() ? \"OK\" : \"not OK\"));\r\n+     \
    \       }\r\n+            else\r\n+            {\r\n+                expect (false);\r\
    \n+            }\r\n+        }\r\n+    }\r\n+\r\n+    void runTest() override\r\
    \n+    {\r\n+        beginTest (\"ZIP\");\r\n+\r\n+        StringArray entryNames\
    \ { \"first\", \"second\", \"third\" };\r\n+        auto data = createZipMemoryBlock\
    \ (entryNames);\r\n+        MemoryInputStream mi (data, false);\r\n         ZipFile\
    \ zip (mi);\r\n \r\n         expectEquals (zip.getNumEntries(), entryNames.size());\r\
    \n@@ -681,6 +758,9 @@ struct ZIPTests   : public UnitTest\n             std::unique_ptr<InputStream>\
    \ input (zip.createStreamForEntry (*entry));\r\n             expectEquals (input->readEntireStreamAsString(),\
    \ entryName);\r\n         }\r\n+\r\n+        beginTest (\"ZipSlip\");\r\n+   \
    \     runZipSlipTest();\r\n     }\r\n };\r\n \r"
  identifiers:
  - CVE-2021-23521
  - CWE-59
  overview: This affects the package juce-framework/JUCE before 6.1.5. This vulnerability
    is triggered when a malicious archive is crafted with an entry containing a symbolic
    link. When extracted, the symbolic link is followed outside of the target dir
    allowing writing arbitrary files on the target host. In some cases, this can allow
    an attacker to execute arbitrary code. The vulnerable code is in the ZipFile::uncompressEntry
    function in juce_ZipFile.cpp and is executed when the archive is extracted upon
    calling uncompressTo() on a ZipFile object.
  references:
  - source: report@snyk.io
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/juce-framework/JUCE/commit/2e874e80cba0152201aff6a4d0dc407997d10a7f
  - source: report@snyk.io
    tags:
    - Exploit
    - Patch
    - Third Party Advisory
    url: https://snyk.io/vuln/SNYK-UNMANAGED-JUCEFRAMEWORKJUCE-2388608
  title: This affects the package juce-framework/JUCE before 6.1.5. This vulnerability
    is triggered when a malicious archive is crafted with an entry containing a symbolic
    link. When extracted, the symbolic link is followed outside of the target dir
    allowing writing arbitrary files on the target host. In some cases, this can allow
    an attacker to execute arbitrary code. The vulnerable code is in the ZipFile::uncompressEntry
    function in juce_ZipFile.cpp and is executed when the archive is extracted upon
    calling uncompressTo() on a ZipFile object.
- diff_content:
  - "--- a/libr/bin/p/bin_xnu_kernelcache.c\n+++ b/libr/bin/p/bin_xnu_kernelcache.c\n\
    @@ -242,7 +242,9 @@ static bool load_buffer(RBinFile *bf, void **bin_obj, RBuffer\
    \ *buf, ut64 loadadd\n \n beach:\n \tr_buf_free (fbuf);\n-\tobj->cache_buf = NULL;\n\
    +\tif (obj) {\n+\t\tobj->cache_buf = NULL;\n+\t}\n \tMACH0_(mach0_free) (main_mach0);\n\
    \ \treturn false;\n }"
  identifiers:
  - CVE-2022-0419
  - CWE-476
  overview: NULL Pointer Dereference in GitHub repository radareorg/radare2 prior
    to 5.6.0.
  references:
  - source: security@huntr.dev
    tags:
    - Third Party Advisory
    url: http://www.openwall.com/lists/oss-security/2022/05/25/1
  - source: security@huntr.dev
    tags:
    - Exploit
    - Third Party Advisory
    url: https://census-labs.com/news/2022/05/24/multiple-vulnerabilities-in-radare2/
  - source: security@huntr.dev
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/radareorg/radare2/commit/feaa4e7f7399c51ee6f52deb84dc3f795b4035d6
  - source: security@huntr.dev
    tags:
    - Exploit
    - Issue Tracking
    - Patch
    - Third Party Advisory
    url: https://huntr.dev/bounties/1f84e79d-70e7-4b29-8b48-a108f81c89aa
  - source: security@huntr.dev
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/IQIRJ72UALGMSWH6MYPVJQQLXFGZ23RS/
  - source: security@huntr.dev
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/SKGIB52R4XPCPNEW6GF56EHW7ST24IJU/
  title: NULL Pointer Dereference in GitHub repository radareorg/radare2 prior to
    5.6.0.
- diff_content:
  - "--- a/lib/http3/server.c\n+++ b/lib/http3/server.c\n@@ -178,7 +178,7 @@ struct\
    \ st_h2o_http3_server_stream_t {\n     struct {\n         h2o_buffer_t *buf;\n\
    \         int (*handle_input)(struct st_h2o_http3_server_stream_t *stream, const\
    \ uint8_t **src, const uint8_t *src_end,\n-                            const char\
    \ **err_desc);\n+                            int in_generator, const char **err_desc);\n\
    \         uint64_t bytes_left_in_data_frame;\n     } recvbuf;\n     struct {\n\
    @@ -244,9 +244,9 @@ struct st_h2o_http3_server_stream_t {\n static void on_stream_destroy(quicly_stream_t\
    \ *qs, int err);\n static int retain_sendvecs(struct st_h2o_http3_server_stream_t\
    \ *stream);\n static int handle_input_post_trailers(struct st_h2o_http3_server_stream_t\
    \ *stream, const uint8_t **src, const uint8_t *src_end,\n-                   \
    \                   const char **err_desc);\n+                               \
    \       int in_generator, const char **err_desc);\n static int handle_input_expect_data(struct\
    \ st_h2o_http3_server_stream_t *stream, const uint8_t **src, const uint8_t *src_end,\n\
    -                                    const char **err_desc);\n+              \
    \                      int in_generator, const char **err_desc);\n static void\
    \ tunnel_write(struct st_h2o_http3_server_stream_t *stream);\n static void tunnel_write_delayed(h2o_timer_t\
    \ *timer);\n \n@@ -834,7 +834,7 @@ static void handle_buffered_input(struct st_h2o_http3_server_stream_t\
    \ *stream, i\n         while (src != src_end) {\n             int err;\n     \
    \        const char *err_desc = NULL;\n-            if ((err = stream->recvbuf.handle_input(stream,\
    \ &src, src_end, &err_desc)) != 0) {\n+            if ((err = stream->recvbuf.handle_input(stream,\
    \ &src, src_end, in_generator, &err_desc)) != 0) {\n                 if (err ==\
    \ H2O_HTTP3_ERROR_INCOMPLETE) {\n                     if (!quicly_recvstate_transfer_complete(&stream->quic->recvstate))\n\
    \                         break;\n@@ -1036,7 +1036,7 @@ static void run_delayed(h2o_timer_t\
    \ *timer)\n }\n \n int handle_input_post_trailers(struct st_h2o_http3_server_stream_t\
    \ *stream, const uint8_t **src, const uint8_t *src_end,\n-                   \
    \            const char **err_desc)\n+                               int in_generator,\
    \ const char **err_desc)\n {\n     h2o_http3_read_frame_t frame;\n     int ret;\n\
    @@ -1056,7 +1056,7 @@ int handle_input_post_trailers(struct st_h2o_http3_server_stream_t\
    \ *stream, cons\n }\n \n static int handle_input_expect_data_payload(struct st_h2o_http3_server_stream_t\
    \ *stream, const uint8_t **src,\n-                                           \
    \ const uint8_t *src_end, const char **err_desc)\n+                          \
    \                  const uint8_t *src_end, int in_generator, const char **err_desc)\n\
    \ {\n     size_t bytes_avail = src_end - *src;\n \n@@ -1079,7 +1079,7 @@ static\
    \ int handle_input_expect_data_payload(struct st_h2o_http3_server_stream_t\n }\n\
    \ \n int handle_input_expect_data(struct st_h2o_http3_server_stream_t *stream,\
    \ const uint8_t **src, const uint8_t *src_end,\n-                            \
    \ const char **err_desc)\n+                             int in_generator, const\
    \ char **err_desc)\n {\n     h2o_http3_read_frame_t frame;\n     int ret;\n@@\
    \ -1102,7 +1102,7 @@ int handle_input_expect_data(struct st_h2o_http3_server_stream_t\
    \ *stream, const\n             stream->req.content_length - stream->req.req_body_bytes_received\
    \ < frame.length) {\n             /* The only viable option here is to reset the\
    \ stream, as we might have already started streaming the request body\n      \
    \        * upstream. This behavior is consistent with what we do in HTTP/2. */\n\
    -            shutdown_stream(stream, H2O_HTTP3_ERROR_EARLY_RESPONSE, H2O_HTTP3_ERROR_GENERAL_PROTOCOL,\
    \ 0);\n+            shutdown_stream(stream, H2O_HTTP3_ERROR_EARLY_RESPONSE, H2O_HTTP3_ERROR_GENERAL_PROTOCOL,\
    \ in_generator);\n             return 0;\n         }\n         break;\n@@ -1134,8\
    \ +1134,10 @@ static int handle_input_expect_headers_send_http_error(struct st_h2o_http3_serve\n\
    \ }\n \n static int handle_input_expect_headers(struct st_h2o_http3_server_stream_t\
    \ *stream, const uint8_t **src, const uint8_t *src_end,\n-                   \
    \                    const char **err_desc)\n+                               \
    \        int in_generator, const char **err_desc)\n {\n+    assert(!in_generator);\
    \ /* this function is processing headers (before generators get assigned), not\
    \ trailers */\n+\n     struct st_h2o_http3_server_conn_t *conn = get_conn(stream);\n\
    \     h2o_http3_read_frame_t frame;\n     int header_exists_map = 0, ret;"
  identifiers:
  - CVE-2021-43848
  - CWE-908
  overview: h2o is an open source http server. In code prior to the `8c0eca3` commit
    h2o may attempt to access uninitialized memory. When receiving QUIC frames in
    certain order, HTTP/3 server-side implementation of h2o can be misguided to treat
    uninitialized memory as HTTP/3 frames that have been received. When h2o is used
    as a reverse proxy, an attacker can abuse this vulnerability to send internal
    state of h2o to backend servers controlled by the attacker or third party. Also,
    if there is an HTTP endpoint that reflects the traffic sent from the client, an
    attacker can use that reflector to obtain internal state of h2o. This internal
    state includes traffic of other connections in unencrypted form and TLS session
    tickets. This vulnerability exists in h2o server with HTTP/3 support, between
    commit 93af138 and d1f0f65. None of the released versions of h2o are affected
    by this vulnerability. There are no known workarounds. Users of unreleased versions
    of h2o using HTTP/3 are advised to upgrade immediately.
  references:
  - source: security-advisories@github.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/h2o/h2o/commit/8c0eca3
  - source: security-advisories@github.com
    tags:
    - Third Party Advisory
    url: https://github.com/h2o/h2o/security/advisories/GHSA-f9xw-j925-m4m4
  title: h2o is an open source http server. In code prior to the `8c0eca3` commit
    h2o may attempt to access uninitialized memory. When receiving QUIC frames in
    certain order, HTTP/3 server-side implementation of h2o can be misguided to treat
    uninitialized memory as HTTP/3 frames that have been received. When h2o is used
    as a reverse proxy, an attacker can abuse this vulnerability to send internal
    state of h2o to backend servers controlled by the attacker or third party. Also,
    if there is an HTTP endpoint that reflects the traffic sent from the client, an
    attacker can use that reflector to obtain internal state of h2o. This internal
    state includes traffic of other connections in unencrypted form and TLS session
    tickets. This vulnerability exists in h2o server with HTTP/3 support, between
    commit 93af138 and d1f0f65. None of the released versions of h2o are affected
    by this vulnerability. There are no known workarounds. Users of unreleased versions
    of h2o using HTTP/3 are advised to upgrade immediately.
- diff_content:
  - "--- a/src/indent.c\n+++ b/src/indent.c\n@@ -71,7 +71,7 @@ tabstop_set(char_u\
    \ *var, int **array)\n \tint n = atoi((char *)cp);\n \n \t// Catch negative values,\
    \ overflow and ridiculous big values.\n-\tif (n < 0 || n > 9999)\n+\tif (n < 0\
    \ || n > TABSTOP_MAX)\n \t{\n \t    semsg(_(e_invalid_argument_str), cp);\n \t\
    \    vim_free(*array);\n@@ -1649,7 +1649,7 @@ ex_retab(exarg_T *eap)\n \temsg(_(e_argument_must_be_positive));\n\
    \ \treturn;\n     }\n-    if (new_ts < 0 || new_ts > 9999)\n+    if (new_ts <\
    \ 0 || new_ts > TABSTOP_MAX)\n     {\n \tsemsg(_(e_invalid_argument_str), eap->arg);\n\
    \ \treturn;"
  - "--- a/src/option.c\n+++ b/src/option.c\n@@ -3752,6 +3752,11 @@ set_num_option(\n\
    \ \terrmsg = e_argument_must_be_positive;\n \tcurbuf->b_p_ts = 8;\n     }\n+ \
    \   else if (curbuf->b_p_ts > TABSTOP_MAX)\n+    {\n+\terrmsg = e_invalid_argument;\n\
    +\tcurbuf->b_p_ts = 8;\n+    }\n     if (p_tm < 0)\n     {\n \terrmsg = e_argument_must_be_positive;\n\
    @@ -5983,7 +5988,7 @@ buf_copy_options(buf_T *buf, int flags)\n \t    if (p_vsts\
    \ && p_vsts != empty_option)\n \t\t(void)tabstop_set(p_vsts, &buf->b_p_vsts_array);\n\
    \ \t    else\n-\t\tbuf->b_p_vsts_array = 0;\n+\t\tbuf->b_p_vsts_array = NULL;\n\
    \ \t    buf->b_p_vsts_nopaste = p_vsts_nopaste\n \t\t\t\t ? vim_strsave(p_vsts_nopaste)\
    \ : NULL;\n #endif\n@@ -6803,9 +6808,7 @@ paste_option_changed(void)\n \t    if\
    \ (buf->b_p_vsts)\n \t\tfree_string_option(buf->b_p_vsts);\n \t    buf->b_p_vsts\
    \ = empty_option;\n-\t    if (buf->b_p_vsts_array)\n-\t\tvim_free(buf->b_p_vsts_array);\n\
    -\t    buf->b_p_vsts_array = 0;\n+\t    VIM_CLEAR(buf->b_p_vsts_array);\n #endif\n\
    \ \t}\n \n@@ -6851,12 +6854,11 @@ paste_option_changed(void)\n \t\tfree_string_option(buf->b_p_vsts);\n\
    \ \t    buf->b_p_vsts = buf->b_p_vsts_nopaste\n \t\t\t ? vim_strsave(buf->b_p_vsts_nopaste)\
    \ : empty_option;\n-\t    if (buf->b_p_vsts_array)\n-\t\tvim_free(buf->b_p_vsts_array);\n\
    +\t    vim_free(buf->b_p_vsts_array);\n \t    if (buf->b_p_vsts && buf->b_p_vsts\
    \ != empty_option)\n \t\t(void)tabstop_set(buf->b_p_vsts, &buf->b_p_vsts_array);\n\
    \ \t    else\n-\t\tbuf->b_p_vsts_array = 0;\n+\t\tbuf->b_p_vsts_array = NULL;\n\
    \ #endif\n \t}\n "
  - "--- a/src/version.c\n+++ b/src/version.c\n@@ -750,6 +750,8 @@ static char *(features[])\
    \ =\n \n static int included_patches[] =\n {   /* Add new patch number below this\
    \ line */\n+/**/\n+    4245,\n /**/\n     4244,\n /**/"
  identifiers:
  - CVE-2022-0417
  - CWE-122
  overview: Heap-based Buffer Overflow GitHub repository vim/vim prior to 8.2.
  references:
  - source: security@huntr.dev
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/vim/vim/commit/652dee448618589de5528a9e9a36995803f5557a
  - source: security@huntr.dev
    tags:
    - Exploit
    - Patch
    - Third Party Advisory
    url: https://huntr.dev/bounties/fc86bc8d-c866-4ade-8b7f-e49cec306d1a
  - source: security@huntr.dev
    tags:
    - Mitigation
    - Third Party Advisory
    url: https://lists.debian.org/debian-lts-announce/2022/06/msg00014.html
  - source: security@huntr.dev
    tags:
    - Mailing List
    - Third Party Advisory
    url: https://lists.debian.org/debian-lts-announce/2022/11/msg00009.html
  - source: security@huntr.dev
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/7ZLEHVP4LNAGER4ZDGUDS5V5YVQD6INF/
  - source: security@huntr.dev
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/UFXFAILMLUIK4MBUEZO4HNBNKYZRJ5AP/
  - source: security@huntr.dev
    tags:
    - Third Party Advisory
    url: https://security.gentoo.org/glsa/202208-32
  title: Heap-based Buffer Overflow GitHub repository vim/vim prior to 8.2.
- diff_content:
  - "--- a/src/itemstackmetadata.cpp\n+++ b/src/itemstackmetadata.cpp\n@@ -21,6 +21,7\
    \ @@ with this program; if not, write to the Free Software Foundation, Inc.,\n\
    \ #include \"itemstackmetadata.h\"\n #include \"util/serialize.h\"\n #include\
    \ \"util/strfnd.h\"\n+#include <algorithm>\n \n #define DESERIALIZE_START '\\\
    x01'\n #define DESERIALIZE_KV_DELIM '\\x02'\n@@ -37,10 +38,22 @@ void ItemStackMetadata::clear()\n\
    \ \tupdateToolCapabilities();\n }\n \n+static void sanitize_string(std::string\
    \ &str)\n+{\n+\tstr.erase(std::remove(str.begin(), str.end(), DESERIALIZE_START),\
    \ str.end());\n+\tstr.erase(std::remove(str.begin(), str.end(), DESERIALIZE_KV_DELIM),\
    \ str.end());\n+\tstr.erase(std::remove(str.begin(), str.end(), DESERIALIZE_PAIR_DELIM),\
    \ str.end());\n+}\n+\n bool ItemStackMetadata::setString(const std::string &name,\
    \ const std::string &var)\n {\n-\tbool result = Metadata::setString(name, var);\n\
    -\tif (name == TOOLCAP_KEY)\n+\tstd::string clean_name = name;\n+\tstd::string\
    \ clean_var = var;\n+\tsanitize_string(clean_name);\n+\tsanitize_string(clean_var);\n\
    +\n+\tbool result = Metadata::setString(clean_name, clean_var);\n+\tif (clean_name\
    \ == TOOLCAP_KEY)\n \t\tupdateToolCapabilities();\n \treturn result;\n }"
  identifiers:
  - CVE-2022-24300
  - NVD-CWE-Other
  overview: Minetest before 5.4.0 allows attackers to add or modify arbitrary meta
    fields of the same item stack as saved user input, aka ItemStack meta injection.
  references:
  - source: cve@mitre.org
    tags:
    - Mailing List
    - Patch
    - Third Party Advisory
    url: https://bugs.debian.org/1004223
  - source: cve@mitre.org
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/minetest/minetest/commit/b5956bde259faa240a81060ff4e598e25ad52dae
  - source: cve@mitre.org
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/minetest/minetest/security/advisories/GHSA-hwj2-xf72-r4cf
  - source: cve@mitre.org
    tags:
    - Mailing List
    - Third Party Advisory
    url: https://www.debian.org/security/2022/dsa-5075
  title: Minetest before 5.4.0 allows attackers to add or modify arbitrary meta fields
    of the same item stack as saved user input, aka ItemStack meta injection.
- diff_content:
  - "--- a/src/network/serverpackethandler.cpp\n+++ b/src/network/serverpackethandler.cpp\n\
    @@ -630,13 +630,19 @@ void Server::handleCommand_InventoryAction(NetworkPacket*\
    \ pkt)\n \t\tif (ma->from_inv != ma->to_inv)\n \t\t\tm_inventory_mgr->setInventoryModified(ma->to_inv);\n\
    \ \n-\t\tbool from_inv_is_current_player =\n-\t\t\t(ma->from_inv.type == InventoryLocation::PLAYER)\
    \ &&\n-\t\t\t(ma->from_inv.name == player->getName());\n-\n-\t\tbool to_inv_is_current_player\
    \ =\n-\t\t\t(ma->to_inv.type == InventoryLocation::PLAYER) &&\n-\t\t\t(ma->to_inv.name\
    \ == player->getName());\n+\t\tbool from_inv_is_current_player = false;\n+\t\t\
    if (ma->from_inv.type == InventoryLocation::PLAYER) {\n+\t\t\tif (ma->from_inv.name\
    \ != player->getName())\n+\t\t\t\treturn;\n+\t\t\tfrom_inv_is_current_player =\
    \ true;\n+\t\t}\n+\t\t\n+\t\tbool to_inv_is_current_player = false;\n+\t\tif (ma->to_inv.type\
    \ == InventoryLocation::PLAYER) {\n+\t\t\tif (ma->to_inv.name != player->getName())\n\
    +\t\t\t\treturn;\n+\t\t\tto_inv_is_current_player = true;\n+\t\t}\n \n \t\tInventoryLocation\
    \ *remote = from_inv_is_current_player ?\n \t\t\t&ma->to_inv : &ma->from_inv;"
  identifiers:
  - CVE-2022-24301
  - CWE-276
  overview: In Minetest before 5.4.0, players can add or subtract items from a different
    player's inventory.
  references:
  - source: cve@mitre.org
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/minetest/minetest/commit/3693b6871eba268ecc79b3f52d00d3cefe761131
  - source: cve@mitre.org
    tags:
    - Third Party Advisory
    url: https://github.com/minetest/minetest/security/advisories/GHSA-fvwv-qcq6-wmp5
  - source: cve@mitre.org
    tags:
    - Mailing List
    - Third Party Advisory
    url: https://www.debian.org/security/2022/dsa-5075
  title: In Minetest before 5.4.0, players can add or subtract items from a different
    player's inventory.
- diff_content:
  - "--- a/jpgfile.c\n+++ b/jpgfile.c\n@@ -169,7 +169,10 @@ int ReadJpegSections (FILE\
    \ * infile, ReadMode_t ReadMode)\n \r\n         Sections[SectionsRead].Size =\
    \ itemlen;\r\n \r\n-        Data = (uchar *)malloc(itemlen);\r\n+        // Allocate\
    \ an extra 20 bytes more than needed, because sometimes when reading structures,\r\
    \n+        // if the section erroneously ends before short structures that should\
    \ be there, that can trip\r\n+        // memory checkers in combination with fuzzers.\r\
    \n+        Data = (uchar *)malloc(itemlen+20);\r\n         if (Data == NULL){\r\
    \n             ErrFatal(\"Could not allocate memory\");\r\n         }\r"
  identifiers:
  - CVE-2020-26208
  - CWE-787
  overview: JHEAD is a simple command line tool for displaying and some manipulation
    of EXIF header data embedded in Jpeg images from digital cameras. In affected
    versions there is a heap-buffer-overflow on jhead-3.04/jpgfile.c:285 ReadJpegSections.
    Crafted jpeg images can be provided to the user resulting in a program crash or
    potentially incorrect exif information retrieval. Users are advised to upgrade.
    There is no known workaround for this issue.
  references:
  - source: security-advisories@github.com
    tags:
    - Exploit
    - Third Party Advisory
    url: https://bugs.launchpad.net/ubuntu/+source/jhead/+bug/1900821
  - source: security-advisories@github.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/F-ZhaoYang/jhead/commit/5186ddcf9e35a7aa0ff0539489a930434a1325f4
  - source: security-advisories@github.com
    tags:
    - Exploit
    - Third Party Advisory
    url: https://github.com/F-ZhaoYang/jhead/security/advisories/GHSA-7pr6-xq4f-qhgc
  - source: security-advisories@github.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/Matthias-Wandel/jhead/issues/7
  title: JHEAD is a simple command line tool for displaying and some manipulation
    of EXIF header data embedded in Jpeg images from digital cameras. In affected
    versions there is a heap-buffer-overflow on jhead-3.04/jpgfile.c:285 ReadJpegSections.
    Crafted jpeg images can be provided to the user resulting in a program crash or
    potentially incorrect exif information retrieval. Users are advised to upgrade.
    There is no known workaround for this issue.
- diff_content:
  - "--- a/src/buffer.c\n+++ b/src/buffer.c\n@@ -1706,6 +1706,7 @@ set_curbuf(buf_T\
    \ *buf, int action)\n #endif\n     bufref_T\tnewbufref;\n     bufref_T\tprevbufref;\n\
    +    int\t\tvalid;\n \n     setpcmark();\n     if ((cmdmod.cmod_flags & CMOD_KEEPALT)\
    \ == 0)\n@@ -1763,13 +1764,19 @@ set_curbuf(buf_T *buf, int action)\n     // An\
    \ autocommand may have deleted \"buf\", already entered it (e.g., when\n     //\
    \ it did \":bunload\") or aborted the script processing.\n     // If curwin->w_buffer\
    \ is null, enter_buffer() will make it valid again\n-    if ((buf_valid(buf) &&\
    \ buf != curbuf\n+    valid = buf_valid(buf);\n+    if ((valid && buf != curbuf\n\
    \ #ifdef FEAT_EVAL\n \t\t&& !aborting()\n #endif\n \t) || curwin->w_buffer ==\
    \ NULL)\n     {\n-\tenter_buffer(buf);\n+\t// If the buffer is not valid but curwin->w_buffer\
    \ is NULL we must\n+\t// enter some buffer.  Using the last one is hopefully OK.\n\
    +\tif (!valid)\n+\t    enter_buffer(lastbuf);\n+\telse\n+\t    enter_buffer(buf);\n\
    \ #ifdef FEAT_SYN_HL\n \tif (old_tw != curbuf->b_p_tw)\n \t    check_colorcolumn(curwin);\n\
    @@ -2288,8 +2295,7 @@ free_buf_options(\n     clear_string_option(&buf->b_p_vsts);\n\
    \     vim_free(buf->b_p_vsts_nopaste);\n     buf->b_p_vsts_nopaste = NULL;\n-\
    \    vim_free(buf->b_p_vsts_array);\n-    buf->b_p_vsts_array = NULL;\n+    VIM_CLEAR(buf->b_p_vsts_array);\n\
    \     clear_string_option(&buf->b_p_vts);\n     VIM_CLEAR(buf->b_p_vts_array);\n\
    \ #endif"
  - "--- a/src/version.c\n+++ b/src/version.c\n@@ -746,6 +746,8 @@ static char *(features[])\
    \ =\n \n static int included_patches[] =\n {   /* Add new patch number below this\
    \ line */\n+/**/\n+    4281,\n /**/\n     4280,\n /**/"
  identifiers:
  - CVE-2022-0443
  - CWE-416
  overview: Use After Free in GitHub repository vim/vim prior to 8.2.
  references:
  - source: security@huntr.dev
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/vim/vim/commit/9b4a80a66544f2782040b641498754bcb5b8d461
  - source: security@huntr.dev
    tags:
    - Exploit
    - Patch
    - Third Party Advisory
    url: https://huntr.dev/bounties/b987c8cb-bbbe-4601-8a6c-54ff907c6b51
  - source: security@huntr.dev
    tags:
    - Mailing List
    - Third Party Advisory
    url: https://lists.debian.org/debian-lts-announce/2022/05/msg00022.html
  - source: security@huntr.dev
    tags:
    - Mailing List
    - Third Party Advisory
    url: https://lists.debian.org/debian-lts-announce/2022/11/msg00009.html
  - source: security@huntr.dev
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/7ZLEHVP4LNAGER4ZDGUDS5V5YVQD6INF/
  - source: security@huntr.dev
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/UFXFAILMLUIK4MBUEZO4HNBNKYZRJ5AP/
  - source: security@huntr.dev
    tags:
    - Third Party Advisory
    url: https://security.gentoo.org/glsa/202208-32
  title: Use After Free in GitHub repository vim/vim prior to 8.2.
- diff_content:
  - "--- a/fs/nfs/inode.c\n+++ b/fs/nfs/inode.c\n@@ -1180,7 +1180,6 @@ int nfs_open(struct\
    \ inode *inode, struct file *filp)\n \tnfs_fscache_open_file(inode, filp);\n \t\
    return 0;\n }\n-EXPORT_SYMBOL_GPL(nfs_open);\n \n /*\n  * This function is called\
    \ whenever some part of NFS notices that"
  - "--- a/fs/nfs/nfs4file.c\n+++ b/fs/nfs/nfs4file.c\n@@ -51,7 +51,7 @@ nfs4_file_open(struct\
    \ inode *inode, struct file *filp)\n \t\treturn err;\n \n \tif ((openflags & O_ACCMODE)\
    \ == 3)\n-\t\treturn nfs_open(inode, filp);\n+\t\topenflags--;\n \n \t/* We can't\
    \ create new files here */\n \topenflags &= ~(O_CREAT|O_EXCL);"
  - "--- a/fs/nfs/dir.c\n+++ b/fs/nfs/dir.c\n@@ -1994,6 +1994,19 @@ int nfs_atomic_open(struct\
    \ inode *dir, struct dentry *dentry,\n \n no_open:\n \tres = nfs_lookup(dir, dentry,\
    \ lookup_flags);\n+\tif (!res) {\n+\t\tinode = d_inode(dentry);\n+\t\tif ((lookup_flags\
    \ & LOOKUP_DIRECTORY) && inode &&\n+\t\t    !S_ISDIR(inode->i_mode))\n+\t\t\t\
    res = ERR_PTR(-ENOTDIR);\n+\t} else if (!IS_ERR(res)) {\n+\t\tinode = d_inode(res);\n\
    +\t\tif ((lookup_flags & LOOKUP_DIRECTORY) && inode &&\n+\t\t    !S_ISDIR(inode->i_mode))\
    \ {\n+\t\t\tdput(res);\n+\t\t\tres = ERR_PTR(-ENOTDIR);\n+\t\t}\n+\t}\n \tif (switched)\
    \ {\n \t\td_lookup_done(dentry);\n \t\tif (!res)"
  identifiers:
  - CVE-2022-24448
  - CWE-755
  overview: An issue was discovered in fs/nfs/dir.c in the Linux kernel before 5.16.5.
    If an application sets the O_DIRECTORY flag, and tries to open a regular file,
    nfs_atomic_open() performs a regular lookup. If a regular file is found, ENOTDIR
    should occur, but the server instead returns uninitialized data in the file descriptor.
  references:
  - source: cve@mitre.org
    tags:
    - Mailing List
    - Patch
    - Release Notes
    - Vendor Advisory
    url: https://cdn.kernel.org/pub/linux/kernel/v5.x/ChangeLog-5.16.5
  - source: cve@mitre.org
    tags:
    - Mailing List
    - Patch
    - Vendor Advisory
    url: https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=ac795161c93699d600db16c1a8cc23a65a1eceaf
  - source: cve@mitre.org
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/torvalds/linux/commit/ab0fc21bc7105b54bafd85bd8b82742f9e68898a
  - source: cve@mitre.org
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/torvalds/linux/commit/ac795161c93699d600db16c1a8cc23a65a1eceaf
  - source: cve@mitre.org
    tags:
    - Mailing List
    - Third Party Advisory
    url: https://lists.debian.org/debian-lts-announce/2022/03/msg00011.html
  - source: cve@mitre.org
    tags:
    - Mailing List
    - Third Party Advisory
    url: https://lists.debian.org/debian-lts-announce/2022/03/msg00012.html
  - source: cve@mitre.org
    url: https://lore.kernel.org/all/67d6a536-9027-1928-99b6-af512a36cd1a%40huawei.com/T/
  - source: cve@mitre.org
    tags:
    - Third Party Advisory
    url: https://www.debian.org/security/2022/dsa-5092
  - source: cve@mitre.org
    tags:
    - Third Party Advisory
    url: https://www.debian.org/security/2022/dsa-5096
  - source: cve@mitre.org
    tags:
    - Mailing List
    - Patch
    - Third Party Advisory
    url: https://www.spinics.net/lists/stable/msg531976.html
  title: An issue was discovered in fs/nfs/dir.c in the Linux kernel before 5.16.5.
    If an application sets the O_DIRECTORY flag, and tries to open a regular file,
    nfs_atomic_open() performs a regular lookup. If a regular file is found, ENOTDIR
    should occur, but the server instead returns uninitialized data in the file descriptor.
- diff_content:
  - "--- a/src/isomedia/box_code_base.c\n+++ b/src/isomedia/box_code_base.c\n@@ -11083,10\
    \ +11083,12 @@ void gitn_box_del(GF_Box *s)\n \tu32 i;\n \tGroupIdToNameBox *ptr\
    \ = (GroupIdToNameBox *)s;\n \tif (ptr == NULL) return;\n-\tfor (i=0; i<ptr->nb_entries;\
    \ i++) {\n-\t\tif (ptr->entries[i].name) gf_free(ptr->entries[i].name);\n+\tif\
    \ (ptr->entries) {\n+\t\tfor (i=0; i<ptr->nb_entries; i++) {\n+\t\t\tif (ptr->entries[i].name)\
    \ gf_free(ptr->entries[i].name);\n+\t\t}\n+\t\tgf_free(ptr->entries);\n \t}\n\
    -\tif (ptr->entries) gf_free(ptr->entries);\n \tgf_free(ptr);\n }\n "
  identifiers:
  - CVE-2021-4043
  - CWE-476
  overview: NULL Pointer Dereference in GitHub repository gpac/gpac prior to 1.1.0.
  references:
  - source: security@huntr.dev
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/gpac/gpac/commit/64a2e1b799352ac7d7aad1989bc06e7b0f2b01db
  - source: security@huntr.dev
    tags:
    - Exploit
    - Issue Tracking
    - Patch
    - Third Party Advisory
    url: https://huntr.dev/bounties/d7a534cb-df7a-48ba-8ce3-46b1551a9c47
  - source: security@huntr.dev
    url: https://www.debian.org/security/2023/dsa-5411
  title: NULL Pointer Dereference in GitHub repository gpac/gpac prior to 1.1.0.
- diff_content:
  - "--- a/mrbgems/mruby-compiler/core/codegen.c\n+++ b/mrbgems/mruby-compiler/core/codegen.c\n\
    @@ -1603,7 +1603,7 @@ gen_hash(codegen_scope *s, node *tree, int val, int limit)\n\
    \ \n   while (tree) {\n     if (nint(tree->car->car->car) == NODE_KW_REST_ARGS)\
    \ {\n-      if (len > 0) {\n+      if (val && len > 0) {\n         pop_n(len*2);\n\
    \         if (!update) {\n           genop_2(s, OP_HASH, cursp(), len);\n@@ -1615,7\
    \ +1615,7 @@ gen_hash(codegen_scope *s, node *tree, int val, int limit)\n    \
    \     push();\n       }\n       codegen(s, tree->car->cdr, val);\n-      if (len\
    \ > 0 || update) {\n+      if (val && (len > 0 || update)) {\n         pop();\
    \ pop();\n         genop_1(s, OP_HASHCAT, cursp());\n         push();"
  identifiers:
  - CVE-2022-0481
  - CWE-476
  overview: NULL Pointer Dereference in Homebrew mruby prior to 3.2.
  references:
  - source: security@huntr.dev
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/mruby/mruby/commit/ae3c99767a27f5c6c584162e2adc6a5d0eb2c54e
  - source: security@huntr.dev
    tags:
    - Exploit
    - Third Party Advisory
    url: https://huntr.dev/bounties/54725c8c-87f4-41b6-878c-01d8e0ee7027
  title: NULL Pointer Dereference in Homebrew mruby prior to 3.2.
- diff_content:
  - "--- a/tensorflow/lite/c/common.c\n+++ b/tensorflow/lite/c/common.c\n@@ -21,10\
    \ +21,10 @@ limitations under the License.\n #include <string.h>\n #endif  //\
    \ TF_LITE_STATIC_MEMORY\n \n-int TfLiteIntArrayGetSizeInBytes(int size) {\n+size_t\
    \ TfLiteIntArrayGetSizeInBytes(int size) {\n   static TfLiteIntArray dummy;\n\
    \ \n-  int computed_size = sizeof(dummy) + sizeof(dummy.data[0]) * size;\n+  size_t\
    \ computed_size = sizeof(dummy) + sizeof(dummy.data[0]) * size;\n #if defined(_MSC_VER)\n\
    \   // Context for why this is needed is in http://b/189926408#comment21\n   computed_size\
    \ -= sizeof(dummy.data[0]);\n@@ -51,7 +51,7 @@ int TfLiteIntArrayEqualsArray(const\
    \ TfLiteIntArray* a, int b_size,\n #ifndef TF_LITE_STATIC_MEMORY\n \n TfLiteIntArray*\
    \ TfLiteIntArrayCreate(int size) {\n-  int alloc_size = TfLiteIntArrayGetSizeInBytes(size);\n\
    +  size_t alloc_size = TfLiteIntArrayGetSizeInBytes(size);\n   if (alloc_size\
    \ <= 0) return NULL;\n   TfLiteIntArray* ret = (TfLiteIntArray*)malloc(alloc_size);\n\
    \   if (!ret) return ret;"
  identifiers:
  - CVE-2022-23558
  - CWE-190
  overview: Tensorflow is an Open Source Machine Learning Framework. An attacker can
    craft a TFLite model that would cause an integer overflow in `TfLiteIntArrayCreate`.
    The `TfLiteIntArrayGetSizeInBytes` returns an `int` instead of a `size_t. An attacker
    can control model inputs such that `computed_size` overflows the size of `int`
    datatype. The fix will be included in TensorFlow 2.8.0. We will also cherrypick
    this commit on TensorFlow 2.7.1, TensorFlow 2.6.3, and TensorFlow 2.5.3, as these
    are also affected and still in supported range.
  references:
  - source: security-advisories@github.com
    tags:
    - Exploit
    - Third Party Advisory
    url: https://github.com/tensorflow/tensorflow/blob/ca6f96b62ad84207fbec580404eaa7dd7403a550/tensorflow/lite/c/common.c#L24-L33
  - source: security-advisories@github.com
    tags:
    - Exploit
    - Third Party Advisory
    url: https://github.com/tensorflow/tensorflow/blob/ca6f96b62ad84207fbec580404eaa7dd7403a550/tensorflow/lite/c/common.c#L53-L60
  - source: security-advisories@github.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/tensorflow/tensorflow/commit/a1e1511dde36b3f8aa27a6ec630838e7ea40e091
  - source: security-advisories@github.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/tensorflow/tensorflow/security/advisories/GHSA-9gwq-6cwj-47h3
  title: Tensorflow is an Open Source Machine Learning Framework. An attacker can
    craft a TFLite model that would cause an integer overflow in `TfLiteIntArrayCreate`.
    The `TfLiteIntArrayGetSizeInBytes` returns an `int` instead of a `size_t. An attacker
    can control model inputs such that `computed_size` overflows the size of `int`
    datatype. The fix will be included in TensorFlow 2.8.0. We will also cherrypick
    this commit on TensorFlow 2.7.1, TensorFlow 2.6.3, and TensorFlow 2.5.3, as these
    are also affected and still in supported range.
- diff_content:
  - "--- a/sesman/sesman.c\n+++ b/sesman/sesman.c\n@@ -276,16 +276,17 @@ sesman_close_all(void)\n\
    \ static int\n sesman_data_in(struct trans *self)\n {\n+#define HEADER_SIZE 8\n\
    \     int version;\n     int size;\n \n     if (self->extra_flags == 0)\n    \
    \ {\n         in_uint32_be(self->in_s, version);\n         in_uint32_be(self->in_s,\
    \ size);\n-        if (size > self->in_s->size)\n+        if (size < HEADER_SIZE\
    \ || size > self->in_s->size)\n         {\n-            LOG(LOG_LEVEL_ERROR, \"\
    sesman_data_in: bad message size\");\n+            LOG(LOG_LEVEL_ERROR, \"sesman_data_in:\
    \ bad message size %d\", size);\n             return 1;\n         }\n        \
    \ self->header_size = size;\n@@ -302,11 +303,12 @@ sesman_data_in(struct trans\
    \ *self)\n             return 1;\n         }\n         /* reset for next message\
    \ */\n-        self->header_size = 8;\n+        self->header_size = HEADER_SIZE;\n\
    \         self->extra_flags = 0;\n         init_stream(self->in_s, 0); /* Reset\
    \ input stream pointers */\n     }\n     return 0;\n+#undef HEADER_SIZE\n }\n\
    \ \n /******************************************************************************/"
  identifiers:
  - CVE-2022-23613
  - CWE-191
  overview: xrdp is an open source remote desktop protocol (RDP) server. In affected
    versions an integer underflow leading to a heap overflow in the sesman server
    allows any unauthenticated attacker which is able to locally access a sesman server
    to execute code as root. This vulnerability has been patched in version 0.9.18.1
    and above. Users are advised to upgrade. There are no known workarounds.
  references:
  - source: security-advisories@github.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/neutrinolabs/xrdp/commit/4def30ab8ea445cdc06832a44c3ec40a506a0ffa
  - source: security-advisories@github.com
    tags:
    - Third Party Advisory
    url: https://github.com/neutrinolabs/xrdp/security/advisories/GHSA-8h98-h426-xf32
  - source: security-advisories@github.com
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/K5ONRGARKHGFU2CIEQ7E6M6VJZEM5XWW/
  - source: security-advisories@github.com
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/U3XGFJNQMNXHBD3J7CBM4YURYEDXROWZ/
  title: xrdp is an open source remote desktop protocol (RDP) server. In affected
    versions an integer underflow leading to a heap overflow in the sesman server
    allows any unauthenticated attacker which is able to locally access a sesman server
    to execute code as root. This vulnerability has been patched in version 0.9.18.1
    and above. Users are advised to upgrade. There are no known workarounds.
- diff_content:
  - "--- a/libr/io/io_bank.c\n+++ b/libr/io/io_bank.c\n@@ -230,7 +230,10 @@ R_API\
    \ bool r_io_bank_map_add_top(RIO *io, const ut32 bankid, const ut32 mapid) {\n\
    \ \t\t//delete all submaps that are completly included in sm\n \t\tRRBNode *next\
    \ = r_rbnode_next (entry);\n \t\t// this can be optimized, there is no need to\
    \ do search here\n-\t\tr_crbtree_delete (bank->submaps, entry->data, _find_sm_by_from_vaddr_cb,\
    \ NULL);\n+\t\tbool a = r_crbtree_delete (bank->submaps, entry->data, _find_sm_by_from_vaddr_cb,\
    \ NULL);\n+\t\tif (!a) {\n+\t\t\tbreak;\n+\t\t}\n \t\tentry = next;\n \t}\n \t\
    if (entry && r_io_submap_from (((RIOSubMap *)entry->data)) <= r_io_submap_to (sm))\
    \ {"
  identifiers:
  - CVE-2022-0139
  - CWE-416
  overview: Use After Free in GitHub repository radareorg/radare2 prior to 5.6.0.
  references:
  - source: security@huntr.dev
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/radareorg/radare2/commit/37897226a1a31f982bfefdc4aeefc2e50355c73c
  - source: security@huntr.dev
    tags:
    - Exploit
    - Patch
    - Third Party Advisory
    url: https://huntr.dev/bounties/3dcb6f40-45cd-403b-929f-db123fde32c0
  title: Use After Free in GitHub repository radareorg/radare2 prior to 5.6.0.
- diff_content:
  - "--- a/shlr/java/class.c\n+++ b/shlr/java/class.c\n@@ -3733,6 +3733,10 @@ R_API\
    \ RBinJavaAttrInfo *r_bin_java_inner_classes_attr_new(RBinJavaObj *bin, ut8\n\
    \ \tut64 offset = 0, curpos;\n \tattr = r_bin_java_default_attr_new (bin, buffer,\
    \ sz, buf_offset);\n \toffset += 6;\n+\tif (buf_offset + offset + 8 > sz) {\n\
    +\t\teprintf (\"Invalid amount of inner classes\\n\");\n+\t\treturn NULL;\n+\t\
    }\n \tif (attr == NULL) {\n \t\t// TODO eprintf\n \t\treturn attr;\n@@ -3743,7\
    \ +3747,7 @@ R_API RBinJavaAttrInfo *r_bin_java_inner_classes_attr_new(RBinJavaObj\
    \ *bin, ut8\n \tattr->info.inner_classes_attr.classes = r_list_newf (r_bin_java_inner_classes_attr_entry_free);\n\
    \ \tfor (i = 0; i < attr->info.inner_classes_attr.number_of_classes; i++) {\n\
    \ \t\tcurpos = buf_offset + offset;\n-\t\tif (offset + 8 > sz) {\n+\t\tif (buf_offset\
    \ + offset + 8 > sz) {\n \t\t\teprintf (\"Invalid amount of inner classes\\n\"\
    );\n \t\t\tbreak;\n \t\t}"
  identifiers:
  - CVE-2022-0518
  - CWE-787
  overview: Heap-based Buffer Overflow in GitHub repository radareorg/radare2 prior
    to 5.6.2.
  references:
  - source: security@huntr.dev
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/radareorg/radare2/commit/9650e3c352f675687bf6c6f65ff2c4a3d0e288fa
  - source: security@huntr.dev
    tags:
    - Exploit
    - Patch
    - Third Party Advisory
    url: https://huntr.dev/bounties/10051adf-7ddc-4042-8fd0-8e9e0c5b1184
  - source: security@huntr.dev
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/BZTIMAS53YT66FUS4QHQAFRJOBMUFG6D/
  - source: security@huntr.dev
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/E6YBRQ3UCFWJVSOYIKPVUDASZ544TFND/
  title: Heap-based Buffer Overflow in GitHub repository radareorg/radare2 prior to
    5.6.2.
- diff_content:
  - "--- a/shlr/java/class.c\n+++ b/shlr/java/class.c\n@@ -3627,6 +3627,9 @@ R_API\
    \ ut64 r_bin_java_signature_attr_calc_size(RBinJavaAttrInfo *attr) {\n \n R_API\
    \ RBinJavaAttrInfo *r_bin_java_enclosing_methods_attr_new(RBinJavaObj *bin, ut8\
    \ *buffer, ut64 sz, ut64 buf_offset) {\n \tut64 offset = 6;\n+\tif (sz < 8) {\n\
    +\t\treturn NULL;\n+\t}\n \tRBinJavaAttrInfo *attr = r_bin_java_default_attr_new\
    \ (bin, buffer, sz, buf_offset);\n \tif (!attr || sz < 10) {\n \t\tfree (attr);\n\
    @@ -3715,27 +3718,24 @@ R_API ut64 r_bin_java_exceptions_attr_calc_size(RBinJavaAttrInfo\
    \ *attr) {\n \n R_API RBinJavaAttrInfo *r_bin_java_inner_classes_attr_new(RBinJavaObj\
    \ *bin, ut8 *buffer, ut64 sz, ut64 buf_offset) {\n \tRBinJavaClassesAttribute\
    \ *icattr;\n-\tRBinJavaAttrInfo *attr = NULL;\n \tRBinJavaCPTypeObj *obj;\n \t\
    ut32 i = 0;\n \tut64 offset = 0, curpos;\n-\tattr = r_bin_java_default_attr_new\
    \ (bin, buffer, sz, buf_offset);\n-\toffset += 6;\n-\tif (buf_offset + offset\
    \ + 8 > sz) {\n-\t\teprintf (\"Invalid amount of inner classes\\n\");\n+\tif (sz\
    \ < 8) {\n \t\treturn NULL;\n \t}\n-\tif (attr == NULL) {\n-\t\t// TODO eprintf\n\
    -\t\treturn attr;\n+\tRBinJavaAttrInfo *attr = r_bin_java_default_attr_new (bin,\
    \ buffer, sz, buf_offset);\n+\tif (!attr) {\n+\t\treturn NULL;\n \t}\n+\toffset\
    \ += 6;\n \tattr->type = R_BIN_JAVA_ATTR_TYPE_INNER_CLASSES_ATTR;\n \tattr->info.inner_classes_attr.number_of_classes\
    \ = R_BIN_JAVA_USHORT (buffer, offset);\n \toffset += 2;\n \tattr->info.inner_classes_attr.classes\
    \ = r_list_newf (r_bin_java_inner_classes_attr_entry_free);\n \tfor (i = 0; i\
    \ < attr->info.inner_classes_attr.number_of_classes; i++) {\n \t\tcurpos = buf_offset\
    \ + offset;\n-\t\tif (buf_offset + offset + 8 > sz) {\n+\t\tif (offset + 8 > sz)\
    \ {\n \t\t\teprintf (\"Invalid amount of inner classes\\n\");\n \t\t\tbreak;\n\
    \ \t\t}\n@@ -3873,6 +3873,9 @@ R_API ut64 r_bin_java_line_number_table_attr_calc_size(RBinJavaAttrInfo\
    \ *attr) {\n \n R_API RBinJavaAttrInfo *r_bin_java_source_debug_attr_new(RBinJavaObj\
    \ *bin, ut8 *buffer, ut64 sz, ut64 buf_offset) {\n \tut64 offset = 6;\n+\tif (sz\
    \ < 8) {\n+\t\treturn NULL;\n+\t}\n \tRBinJavaAttrInfo *attr = r_bin_java_default_attr_new\
    \ (bin, buffer, sz, buf_offset);\n \tif (!attr) {\n \t\treturn NULL;\n@@ -3940,12\
    \ +3943,11 @@ R_API ut64 r_bin_java_local_variable_table_attr_calc_size(RBinJavaAttrInfo\
    \ *attr\n R_API RBinJavaAttrInfo *r_bin_java_local_variable_table_attr_new(RBinJavaObj\
    \ *bin, ut8 *buffer, ut64 sz, ut64 buf_offset) {\n \tRBinJavaLocalVariableAttribute\
    \ *lvattr;\n \tut64 curpos = 0, offset = 6;\n-\tRBinJavaAttrInfo *attr;\n \tut32\
    \ i = 0;\n-\tif (!buffer || sz < 1) {\n+\tif (!bin || !buffer || sz < 8) {\n \t\
    \treturn NULL;\n \t}\n-\tattr = r_bin_java_default_attr_new (bin, buffer, sz,\
    \ buf_offset);\n+\tRBinJavaAttrInfo *attr = r_bin_java_default_attr_new (bin,\
    \ buffer, sz, buf_offset);\n \tif (!attr) {\n \t\treturn NULL;\n \t}\n@@ -4019,6\
    \ +4021,9 @@ R_API ut64 r_bin_java_local_variable_type_table_attr_calc_size(RBinJavaAttrInfo\n\
    \ }\n \n R_API RBinJavaAttrInfo *r_bin_java_local_variable_type_table_attr_new(RBinJavaObj\
    \ *bin, ut8 *buffer, ut64 sz, ut64 buf_offset) {\n+\tif (sz < 8) {\n+\t\treturn\
    \ NULL;\n+\t}\n \tRBinJavaLocalVariableTypeAttribute *lvattr;\n \tut64 offset\
    \ = 6;\n \tut32 i = 0;\n@@ -4072,21 +4077,25 @@ R_API RBinJavaAttrInfo *r_bin_java_local_variable_type_table_attr_new(RBinJavaOb\n\
    \ }\n \n R_API RBinJavaAttrInfo *r_bin_java_source_code_file_attr_new(RBinJavaObj\
    \ *bin, ut8 *buffer, ut64 sz, ut64 buf_offset) {\n-\tif (!sz) {\n+\tif (!sz ||\
    \ sz == UT64_MAX) {\n+\t\treturn NULL;\n+\t}\n+#if 0\n+\t/// XXX this breaks tests\n\
    +\tif (sz < 8) {\n \t\treturn NULL;\n \t}\n+#endif\n \tut64 offset = 0;\n \tRBinJavaAttrInfo\
    \ *attr = r_bin_java_default_attr_new (bin, buffer, sz, buf_offset);\n \toffset\
    \ += 6;\n-\tif (!attr) {\n-\t\treturn NULL;\n+\tif (attr) {\n+\t\tattr->type =\
    \ R_BIN_JAVA_ATTR_TYPE_SOURCE_FILE_ATTR;\n+\t\tattr->info.source_file_attr.sourcefile_idx\
    \ = R_BIN_JAVA_USHORT (buffer, offset);\n+\t\toffset += 2;\n+\t\tattr->size =\
    \ offset;\n+\t\t// IFDBG r_bin_java_print_source_code_file_attr_summary(attr);\n\
    \ \t}\n-\tattr->type = R_BIN_JAVA_ATTR_TYPE_SOURCE_FILE_ATTR;\n-\t// if (buffer\
    \ + offset > buffer + sz) return NULL;\n-\tattr->info.source_file_attr.sourcefile_idx\
    \ = R_BIN_JAVA_USHORT (buffer, offset);\n-\toffset += 2;\n-\tattr->size = offset;\n\
    -\t// IFDBG r_bin_java_print_source_code_file_attr_summary(attr);\n \treturn attr;\n\
    \ }\n \n@@ -4095,14 +4104,15 @@ R_API ut64 r_bin_java_source_code_file_attr_calc_size(RBinJavaAttrInfo\
    \ *attr) {\n }\n \n R_API RBinJavaAttrInfo *r_bin_java_synthetic_attr_new(RBinJavaObj\
    \ *bin, ut8 *buffer, ut64 sz, ut64 buf_offset) {\n-\tut64 offset = 0;\n+\tif (sz\
    \ < 8) {\n+\t\treturn NULL;\n+\t}\n \tRBinJavaAttrInfo *attr = r_bin_java_default_attr_new\
    \ (bin, buffer, sz, buf_offset);\n \tif (!attr) {\n \t\treturn NULL;\n \t}\n-\t\
    offset += 6;\n \tattr->type = R_BIN_JAVA_ATTR_TYPE_SYNTHETIC_ATTR;\n-\tattr->size\
    \ = offset;\n+\tattr->size = 6;\n \treturn attr;\n }\n \n@@ -4133,24 +4143,21\
    \ @@ R_API RBinJavaInterfaceInfo *r_bin_java_interface_new(RBinJavaObj *bin, const\
    \ ut\n \n R_API RBinJavaVerificationObj *r_bin_java_verification_info_from_type(RBinJavaObj\
    \ *bin, R_BIN_JAVA_STACKMAP_TYPE type, ut32 value) {\n \tRBinJavaVerificationObj\
    \ *se = R_NEW0 (RBinJavaVerificationObj);\n-\tif (!se) {\n-\t\treturn NULL;\n\
    -\t}\n-\tse->tag = type;\n-\tif (se->tag == R_BIN_JAVA_STACKMAP_OBJECT) {\n-\t\
    \tse->info.obj_val_cp_idx = (ut16) value;\n-\t} else if (se->tag == R_BIN_JAVA_STACKMAP_UNINIT)\
    \ {\n-\t\t/*if (bin->offset_sz == 4) {\n-\t\tse->info.uninit_offset = value;\n\
    -\t\t} else {\n-\t\tse->info.uninit_offset = (ut16) value;\n-\t\t}*/\n-\t\tse->info.uninit_offset\
    \ = (ut16) value;\n+\tif (se) {\n+\t\tse->tag = type;\n+\t\tif (se->tag == R_BIN_JAVA_STACKMAP_OBJECT)\
    \ {\n+\t\t\tse->info.obj_val_cp_idx = (ut16) value;\n+\t\t} else if (se->tag ==\
    \ R_BIN_JAVA_STACKMAP_UNINIT) {\n+\t\t\tse->info.uninit_offset = (ut16) value;\n\
    +\t\t}\n \t}\n \treturn se;\n }\n \n R_API RBinJavaVerificationObj *r_bin_java_read_from_buffer_verification_info_new(ut8\
    \ *buffer, ut64 sz, ut64 buf_offset) {\n+\tif (sz < 8) {\n+\t\treturn NULL;\n\
    +\t}\n \tut64 offset = 0;\n \tRBinJavaVerificationObj *se = R_NEW0 (RBinJavaVerificationObj);\n\
    \ \tif (!se) {\n@@ -4270,6 +4277,9 @@ R_API ut64 r_bin_java_stack_map_frame_calc_size(RBinJavaStackMapFrame\
    \ *sf) {\n }\n \n R_API RBinJavaStackMapFrame *r_bin_java_stack_map_frame_new(ut8\
    \ *buffer, ut64 sz, RBinJavaStackMapFrame *p_frame, ut64 buf_offset) {\n+\tif\
    \ (sz < 8) {\n+\t\treturn NULL;\n+\t}\n \tRBinJavaStackMapFrame *stack_frame =\
    \ r_bin_java_default_stack_frame ();\n \tRBinJavaVerificationObj *se = NULL;\n\
    \ \tut64 offset = 0;\n@@ -4573,13 +4583,16 @@ R_API ut64 r_bin_java_stack_map_table_attr_calc_size(RBinJavaAttrInfo\
    \ *attr) {\n R_API RBinJavaAttrInfo *r_bin_java_stack_map_table_attr_new(RBinJavaObj\
    \ *bin, ut8 *buffer, ut64 sz, ut64 buf_offset) {\n \tut32 i = 0;\n \tut64 offset\
    \ = 0;\n+\tif (sz < 8) {\n+\t\treturn NULL;\n+\t}\n \tRBinJavaStackMapFrame *stack_frame\
    \ = NULL, *new_stack_frame = NULL;\n \tif (sz < 10) {\n \t\treturn NULL;\n \t\
    }\n \tRBinJavaAttrInfo *attr = r_bin_java_default_attr_new (bin, buffer, sz, buf_offset);\n\
    \ \toffset += 6;\n-\tIFDBG eprintf(\"r_bin_java_stack_map_table_attr_new: New\
    \ stack map allocated.\\n\");\n+\tIFDBG eprintf (\"r_bin_java_stack_map_table_attr_new:\
    \ New stack map allocated.\\n\");\n \tif (!attr) {\n \t\treturn NULL;\n \t}\n\
    @@ -6354,8 +6367,10 @@ R_API ut64 r_bin_java_annotation_default_attr_calc_size(RBinJavaAttrInfo\
    \ *attr)\n \n R_API RBinJavaAttrInfo *r_bin_java_annotation_default_attr_new(RBinJavaObj\
    \ *bin, ut8 *buffer, ut64 sz, ut64 buf_offset) {\n \tut64 offset = 0;\n-\tRBinJavaAttrInfo\
    \ *attr = NULL;\n-\tattr = r_bin_java_default_attr_new (bin, buffer, sz, buf_offset);\n\
    +\tif (sz < 8) {\n+\t\treturn NULL;\n+\t}\n+\tRBinJavaAttrInfo *attr = r_bin_java_default_attr_new\
    \ (bin, buffer, sz, buf_offset);\n \toffset += 6;\n \tif (attr && sz >= offset)\
    \ {\n \t\tattr->type = R_BIN_JAVA_ATTR_TYPE_ANNOTATION_DEFAULT_ATTR;\n@@ -6435,10\
    \ +6450,12 @@ R_API void r_bin_java_annotation_default_attr_free(void /*RBinJavaAttrInfo*/\
    \ *a)\n \n R_API RBinJavaAnnotation *r_bin_java_annotation_new(ut8 *buffer, ut64\
    \ sz, ut64 buf_offset) {\n \tut32 i = 0;\n-\tRBinJavaAnnotation *annotation =\
    \ NULL;\n \tRBinJavaElementValuePair *evps = NULL;\n \tut64 offset = 0;\n-\tannotation\
    \ = R_NEW0 (RBinJavaAnnotation);\n+\tif (sz < 8) {\n+\t\treturn NULL;\n+\t}\n\
    +\tRBinJavaAnnotation *annotation = R_NEW0 (RBinJavaAnnotation);\n \tif (!annotation)\
    \ {\n \t\treturn NULL;\n \t}\n@@ -6510,14 +6527,10 @@ R_API void r_bin_java_print_annotation_summary(RBinJavaAnnotation\
    \ *annotation) {\n }\n \n R_API ut64 r_bin_java_element_pair_calc_size(RBinJavaElementValuePair\
    \ *evp) {\n-\tut64 sz = 0;\n-\tif (evp == NULL) {\n-\t\treturn sz;\n-\t}\n-\t\
    // evp->element_name_idx = r_bin_java_read_short(bin, bin->b->cur);\n-\tsz +=\
    \ 2;\n-\t// evp->value = r_bin_java_element_value_new (bin, offset+2);\n-\tif\
    \ (evp->value) {\n+\tut64 sz = 2;\n+\tif (evp && evp->value) {\n+\t\t// evp->element_name_idx\
    \ = r_bin_java_read_short(bin, bin->b->cur);\n+\t\t// evp->value = r_bin_java_element_value_new\
    \ (bin, offset+2);\n \t\tsz += r_bin_java_element_value_calc_size (evp->value);\n\
    \ \t}\n \treturn sz;\n@@ -6596,6 +6609,9 @@ R_API ut64 r_bin_java_element_value_calc_size(RBinJavaElementValue\
    \ *element_valu\n R_API RBinJavaElementValue *r_bin_java_element_value_new(ut8\
    \ *buffer, ut64 sz, ut64 buf_offset) {\n \tut32 i = 0;\n \tut64 offset = 0;\n\
    +\tif (sz < 8) {\n+\t\treturn NULL;\n+\t}\n \tRBinJavaElementValue *element_value\
    \ = R_NEW0 (RBinJavaElementValue);\n \tif (!element_value) {\n \t\treturn NULL;\n\
    @@ -7011,7 +7027,7 @@ R_API RBinJavaAnnotationsArray *r_bin_java_annotation_array_new(ut8\
    \ *buffer, ut6\n R_API RBinJavaAttrInfo *r_bin_java_rtv_annotations_attr_new(RBinJavaObj\
    \ *bin, ut8 *buffer, ut64 sz, ut64 buf_offset) {\n \tut32 i = 0;\n \tut64 offset\
    \ = 0;\n-\tif (buf_offset + 8 > sz) {\n+\tif (sz < 8) {\n \t\treturn NULL;\n \t\
    }\n \tRBinJavaAttrInfo *attr = r_bin_java_default_attr_new (bin, buffer, sz, buf_offset);"
  identifiers:
  - CVE-2022-0519
  - CWE-119
  overview: Buffer Access with Incorrect Length Value in GitHub repository radareorg/radare2
    prior to 5.6.2.
  references:
  - source: security@huntr.dev
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/radareorg/radare2/commit/6c4428f018d385fc80a33ecddcb37becea685dd5
  - source: security@huntr.dev
    tags:
    - Exploit
    - Patch
    - Third Party Advisory
    url: https://huntr.dev/bounties/af85b9e1-d1cf-4c0e-ba12-525b82b7c1e3
  - source: security@huntr.dev
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/BZTIMAS53YT66FUS4QHQAFRJOBMUFG6D/
  - source: security@huntr.dev
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/E6YBRQ3UCFWJVSOYIKPVUDASZ544TFND/
  title: Buffer Access with Incorrect Length Value in GitHub repository radareorg/radare2
    prior to 5.6.2.
- diff_content:
  - "--- a/libr/bin/format/pyc/marshal.c\n+++ b/libr/bin/format/pyc/marshal.c\n@@\
    \ -1098,7 +1098,7 @@ static pyc_object *get_object(RBuffer *buffer) {\n \t\tbreak;\n\
    \ \tcase TYPE_UNKNOWN:\n \t\teprintf (\"Get not implemented for type 0x%x\\n\"\
    , type);\n-\t\tr_list_pop (refs);\n+\t\t// r_list_pop (refs);\n \t\tfree_object\
    \ (ret);\n \t\treturn NULL;\n \tcase 0:"
  identifiers:
  - CVE-2022-0520
  - CWE-416
  overview: Use After Free in NPM radare2.js prior to 5.6.2.
  references:
  - source: security@huntr.dev
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/radareorg/radare2/commit/8525ad0b9fd596f4b251bb3d7b114e6dc7ce1ee8
  - source: security@huntr.dev
    tags:
    - Exploit
    - Patch
    - Third Party Advisory
    url: https://huntr.dev/bounties/ce13c371-e5ef-4993-97f3-3d33dcd943a6
  - source: security@huntr.dev
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/BZTIMAS53YT66FUS4QHQAFRJOBMUFG6D/
  - source: security@huntr.dev
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/E6YBRQ3UCFWJVSOYIKPVUDASZ544TFND/
  title: Use After Free in NPM radare2.js prior to 5.6.2.
- diff_content:
  - "--- a/shlr/java/class.c\n+++ b/shlr/java/class.c\n@@ -3627,6 +3627,9 @@ R_API\
    \ ut64 r_bin_java_signature_attr_calc_size(RBinJavaAttrInfo *attr) {\n \n R_API\
    \ RBinJavaAttrInfo *r_bin_java_enclosing_methods_attr_new(RBinJavaObj *bin, ut8\
    \ *buffer, ut64 sz, ut64 buf_offset) {\n \tut64 offset = 6;\n+\tif (sz < 8) {\n\
    +\t\treturn NULL;\n+\t}\n \tRBinJavaAttrInfo *attr = r_bin_java_default_attr_new\
    \ (bin, buffer, sz, buf_offset);\n \tif (!attr || sz < 10) {\n \t\tfree (attr);\n\
    @@ -3715,27 +3718,24 @@ R_API ut64 r_bin_java_exceptions_attr_calc_size(RBinJavaAttrInfo\
    \ *attr) {\n \n R_API RBinJavaAttrInfo *r_bin_java_inner_classes_attr_new(RBinJavaObj\
    \ *bin, ut8 *buffer, ut64 sz, ut64 buf_offset) {\n \tRBinJavaClassesAttribute\
    \ *icattr;\n-\tRBinJavaAttrInfo *attr = NULL;\n \tRBinJavaCPTypeObj *obj;\n \t\
    ut32 i = 0;\n \tut64 offset = 0, curpos;\n-\tattr = r_bin_java_default_attr_new\
    \ (bin, buffer, sz, buf_offset);\n-\toffset += 6;\n-\tif (buf_offset + offset\
    \ + 8 > sz) {\n-\t\teprintf (\"Invalid amount of inner classes\\n\");\n+\tif (sz\
    \ < 8) {\n \t\treturn NULL;\n \t}\n-\tif (attr == NULL) {\n-\t\t// TODO eprintf\n\
    -\t\treturn attr;\n+\tRBinJavaAttrInfo *attr = r_bin_java_default_attr_new (bin,\
    \ buffer, sz, buf_offset);\n+\tif (!attr) {\n+\t\treturn NULL;\n \t}\n+\toffset\
    \ += 6;\n \tattr->type = R_BIN_JAVA_ATTR_TYPE_INNER_CLASSES_ATTR;\n \tattr->info.inner_classes_attr.number_of_classes\
    \ = R_BIN_JAVA_USHORT (buffer, offset);\n \toffset += 2;\n \tattr->info.inner_classes_attr.classes\
    \ = r_list_newf (r_bin_java_inner_classes_attr_entry_free);\n \tfor (i = 0; i\
    \ < attr->info.inner_classes_attr.number_of_classes; i++) {\n \t\tcurpos = buf_offset\
    \ + offset;\n-\t\tif (buf_offset + offset + 8 > sz) {\n+\t\tif (offset + 8 > sz)\
    \ {\n \t\t\teprintf (\"Invalid amount of inner classes\\n\");\n \t\t\tbreak;\n\
    \ \t\t}\n@@ -3873,6 +3873,9 @@ R_API ut64 r_bin_java_line_number_table_attr_calc_size(RBinJavaAttrInfo\
    \ *attr) {\n \n R_API RBinJavaAttrInfo *r_bin_java_source_debug_attr_new(RBinJavaObj\
    \ *bin, ut8 *buffer, ut64 sz, ut64 buf_offset) {\n \tut64 offset = 6;\n+\tif (sz\
    \ < 8) {\n+\t\treturn NULL;\n+\t}\n \tRBinJavaAttrInfo *attr = r_bin_java_default_attr_new\
    \ (bin, buffer, sz, buf_offset);\n \tif (!attr) {\n \t\treturn NULL;\n@@ -3940,12\
    \ +3943,11 @@ R_API ut64 r_bin_java_local_variable_table_attr_calc_size(RBinJavaAttrInfo\
    \ *attr\n R_API RBinJavaAttrInfo *r_bin_java_local_variable_table_attr_new(RBinJavaObj\
    \ *bin, ut8 *buffer, ut64 sz, ut64 buf_offset) {\n \tRBinJavaLocalVariableAttribute\
    \ *lvattr;\n \tut64 curpos = 0, offset = 6;\n-\tRBinJavaAttrInfo *attr;\n \tut32\
    \ i = 0;\n-\tif (!buffer || sz < 1) {\n+\tif (!bin || !buffer || sz < 8) {\n \t\
    \treturn NULL;\n \t}\n-\tattr = r_bin_java_default_attr_new (bin, buffer, sz,\
    \ buf_offset);\n+\tRBinJavaAttrInfo *attr = r_bin_java_default_attr_new (bin,\
    \ buffer, sz, buf_offset);\n \tif (!attr) {\n \t\treturn NULL;\n \t}\n@@ -4019,6\
    \ +4021,9 @@ R_API ut64 r_bin_java_local_variable_type_table_attr_calc_size(RBinJavaAttrInfo\n\
    \ }\n \n R_API RBinJavaAttrInfo *r_bin_java_local_variable_type_table_attr_new(RBinJavaObj\
    \ *bin, ut8 *buffer, ut64 sz, ut64 buf_offset) {\n+\tif (sz < 8) {\n+\t\treturn\
    \ NULL;\n+\t}\n \tRBinJavaLocalVariableTypeAttribute *lvattr;\n \tut64 offset\
    \ = 6;\n \tut32 i = 0;\n@@ -4072,21 +4077,25 @@ R_API RBinJavaAttrInfo *r_bin_java_local_variable_type_table_attr_new(RBinJavaOb\n\
    \ }\n \n R_API RBinJavaAttrInfo *r_bin_java_source_code_file_attr_new(RBinJavaObj\
    \ *bin, ut8 *buffer, ut64 sz, ut64 buf_offset) {\n-\tif (!sz) {\n+\tif (!sz ||\
    \ sz == UT64_MAX) {\n+\t\treturn NULL;\n+\t}\n+#if 0\n+\t/// XXX this breaks tests\n\
    +\tif (sz < 8) {\n \t\treturn NULL;\n \t}\n+#endif\n \tut64 offset = 0;\n \tRBinJavaAttrInfo\
    \ *attr = r_bin_java_default_attr_new (bin, buffer, sz, buf_offset);\n \toffset\
    \ += 6;\n-\tif (!attr) {\n-\t\treturn NULL;\n+\tif (attr) {\n+\t\tattr->type =\
    \ R_BIN_JAVA_ATTR_TYPE_SOURCE_FILE_ATTR;\n+\t\tattr->info.source_file_attr.sourcefile_idx\
    \ = R_BIN_JAVA_USHORT (buffer, offset);\n+\t\toffset += 2;\n+\t\tattr->size =\
    \ offset;\n+\t\t// IFDBG r_bin_java_print_source_code_file_attr_summary(attr);\n\
    \ \t}\n-\tattr->type = R_BIN_JAVA_ATTR_TYPE_SOURCE_FILE_ATTR;\n-\t// if (buffer\
    \ + offset > buffer + sz) return NULL;\n-\tattr->info.source_file_attr.sourcefile_idx\
    \ = R_BIN_JAVA_USHORT (buffer, offset);\n-\toffset += 2;\n-\tattr->size = offset;\n\
    -\t// IFDBG r_bin_java_print_source_code_file_attr_summary(attr);\n \treturn attr;\n\
    \ }\n \n@@ -4095,14 +4104,15 @@ R_API ut64 r_bin_java_source_code_file_attr_calc_size(RBinJavaAttrInfo\
    \ *attr) {\n }\n \n R_API RBinJavaAttrInfo *r_bin_java_synthetic_attr_new(RBinJavaObj\
    \ *bin, ut8 *buffer, ut64 sz, ut64 buf_offset) {\n-\tut64 offset = 0;\n+\tif (sz\
    \ < 8) {\n+\t\treturn NULL;\n+\t}\n \tRBinJavaAttrInfo *attr = r_bin_java_default_attr_new\
    \ (bin, buffer, sz, buf_offset);\n \tif (!attr) {\n \t\treturn NULL;\n \t}\n-\t\
    offset += 6;\n \tattr->type = R_BIN_JAVA_ATTR_TYPE_SYNTHETIC_ATTR;\n-\tattr->size\
    \ = offset;\n+\tattr->size = 6;\n \treturn attr;\n }\n \n@@ -4133,24 +4143,21\
    \ @@ R_API RBinJavaInterfaceInfo *r_bin_java_interface_new(RBinJavaObj *bin, const\
    \ ut\n \n R_API RBinJavaVerificationObj *r_bin_java_verification_info_from_type(RBinJavaObj\
    \ *bin, R_BIN_JAVA_STACKMAP_TYPE type, ut32 value) {\n \tRBinJavaVerificationObj\
    \ *se = R_NEW0 (RBinJavaVerificationObj);\n-\tif (!se) {\n-\t\treturn NULL;\n\
    -\t}\n-\tse->tag = type;\n-\tif (se->tag == R_BIN_JAVA_STACKMAP_OBJECT) {\n-\t\
    \tse->info.obj_val_cp_idx = (ut16) value;\n-\t} else if (se->tag == R_BIN_JAVA_STACKMAP_UNINIT)\
    \ {\n-\t\t/*if (bin->offset_sz == 4) {\n-\t\tse->info.uninit_offset = value;\n\
    -\t\t} else {\n-\t\tse->info.uninit_offset = (ut16) value;\n-\t\t}*/\n-\t\tse->info.uninit_offset\
    \ = (ut16) value;\n+\tif (se) {\n+\t\tse->tag = type;\n+\t\tif (se->tag == R_BIN_JAVA_STACKMAP_OBJECT)\
    \ {\n+\t\t\tse->info.obj_val_cp_idx = (ut16) value;\n+\t\t} else if (se->tag ==\
    \ R_BIN_JAVA_STACKMAP_UNINIT) {\n+\t\t\tse->info.uninit_offset = (ut16) value;\n\
    +\t\t}\n \t}\n \treturn se;\n }\n \n R_API RBinJavaVerificationObj *r_bin_java_read_from_buffer_verification_info_new(ut8\
    \ *buffer, ut64 sz, ut64 buf_offset) {\n+\tif (sz < 8) {\n+\t\treturn NULL;\n\
    +\t}\n \tut64 offset = 0;\n \tRBinJavaVerificationObj *se = R_NEW0 (RBinJavaVerificationObj);\n\
    \ \tif (!se) {\n@@ -4270,6 +4277,9 @@ R_API ut64 r_bin_java_stack_map_frame_calc_size(RBinJavaStackMapFrame\
    \ *sf) {\n }\n \n R_API RBinJavaStackMapFrame *r_bin_java_stack_map_frame_new(ut8\
    \ *buffer, ut64 sz, RBinJavaStackMapFrame *p_frame, ut64 buf_offset) {\n+\tif\
    \ (sz < 8) {\n+\t\treturn NULL;\n+\t}\n \tRBinJavaStackMapFrame *stack_frame =\
    \ r_bin_java_default_stack_frame ();\n \tRBinJavaVerificationObj *se = NULL;\n\
    \ \tut64 offset = 0;\n@@ -4573,13 +4583,16 @@ R_API ut64 r_bin_java_stack_map_table_attr_calc_size(RBinJavaAttrInfo\
    \ *attr) {\n R_API RBinJavaAttrInfo *r_bin_java_stack_map_table_attr_new(RBinJavaObj\
    \ *bin, ut8 *buffer, ut64 sz, ut64 buf_offset) {\n \tut32 i = 0;\n \tut64 offset\
    \ = 0;\n+\tif (sz < 8) {\n+\t\treturn NULL;\n+\t}\n \tRBinJavaStackMapFrame *stack_frame\
    \ = NULL, *new_stack_frame = NULL;\n \tif (sz < 10) {\n \t\treturn NULL;\n \t\
    }\n \tRBinJavaAttrInfo *attr = r_bin_java_default_attr_new (bin, buffer, sz, buf_offset);\n\
    \ \toffset += 6;\n-\tIFDBG eprintf(\"r_bin_java_stack_map_table_attr_new: New\
    \ stack map allocated.\\n\");\n+\tIFDBG eprintf (\"r_bin_java_stack_map_table_attr_new:\
    \ New stack map allocated.\\n\");\n \tif (!attr) {\n \t\treturn NULL;\n \t}\n\
    @@ -6354,8 +6367,10 @@ R_API ut64 r_bin_java_annotation_default_attr_calc_size(RBinJavaAttrInfo\
    \ *attr)\n \n R_API RBinJavaAttrInfo *r_bin_java_annotation_default_attr_new(RBinJavaObj\
    \ *bin, ut8 *buffer, ut64 sz, ut64 buf_offset) {\n \tut64 offset = 0;\n-\tRBinJavaAttrInfo\
    \ *attr = NULL;\n-\tattr = r_bin_java_default_attr_new (bin, buffer, sz, buf_offset);\n\
    +\tif (sz < 8) {\n+\t\treturn NULL;\n+\t}\n+\tRBinJavaAttrInfo *attr = r_bin_java_default_attr_new\
    \ (bin, buffer, sz, buf_offset);\n \toffset += 6;\n \tif (attr && sz >= offset)\
    \ {\n \t\tattr->type = R_BIN_JAVA_ATTR_TYPE_ANNOTATION_DEFAULT_ATTR;\n@@ -6435,10\
    \ +6450,12 @@ R_API void r_bin_java_annotation_default_attr_free(void /*RBinJavaAttrInfo*/\
    \ *a)\n \n R_API RBinJavaAnnotation *r_bin_java_annotation_new(ut8 *buffer, ut64\
    \ sz, ut64 buf_offset) {\n \tut32 i = 0;\n-\tRBinJavaAnnotation *annotation =\
    \ NULL;\n \tRBinJavaElementValuePair *evps = NULL;\n \tut64 offset = 0;\n-\tannotation\
    \ = R_NEW0 (RBinJavaAnnotation);\n+\tif (sz < 8) {\n+\t\treturn NULL;\n+\t}\n\
    +\tRBinJavaAnnotation *annotation = R_NEW0 (RBinJavaAnnotation);\n \tif (!annotation)\
    \ {\n \t\treturn NULL;\n \t}\n@@ -6510,14 +6527,10 @@ R_API void r_bin_java_print_annotation_summary(RBinJavaAnnotation\
    \ *annotation) {\n }\n \n R_API ut64 r_bin_java_element_pair_calc_size(RBinJavaElementValuePair\
    \ *evp) {\n-\tut64 sz = 0;\n-\tif (evp == NULL) {\n-\t\treturn sz;\n-\t}\n-\t\
    // evp->element_name_idx = r_bin_java_read_short(bin, bin->b->cur);\n-\tsz +=\
    \ 2;\n-\t// evp->value = r_bin_java_element_value_new (bin, offset+2);\n-\tif\
    \ (evp->value) {\n+\tut64 sz = 2;\n+\tif (evp && evp->value) {\n+\t\t// evp->element_name_idx\
    \ = r_bin_java_read_short(bin, bin->b->cur);\n+\t\t// evp->value = r_bin_java_element_value_new\
    \ (bin, offset+2);\n \t\tsz += r_bin_java_element_value_calc_size (evp->value);\n\
    \ \t}\n \treturn sz;\n@@ -6596,6 +6609,9 @@ R_API ut64 r_bin_java_element_value_calc_size(RBinJavaElementValue\
    \ *element_valu\n R_API RBinJavaElementValue *r_bin_java_element_value_new(ut8\
    \ *buffer, ut64 sz, ut64 buf_offset) {\n \tut32 i = 0;\n \tut64 offset = 0;\n\
    +\tif (sz < 8) {\n+\t\treturn NULL;\n+\t}\n \tRBinJavaElementValue *element_value\
    \ = R_NEW0 (RBinJavaElementValue);\n \tif (!element_value) {\n \t\treturn NULL;\n\
    @@ -7011,7 +7027,7 @@ R_API RBinJavaAnnotationsArray *r_bin_java_annotation_array_new(ut8\
    \ *buffer, ut6\n R_API RBinJavaAttrInfo *r_bin_java_rtv_annotations_attr_new(RBinJavaObj\
    \ *bin, ut8 *buffer, ut64 sz, ut64 buf_offset) {\n \tut32 i = 0;\n \tut64 offset\
    \ = 0;\n-\tif (buf_offset + 8 > sz) {\n+\tif (sz < 8) {\n \t\treturn NULL;\n \t\
    }\n \tRBinJavaAttrInfo *attr = r_bin_java_default_attr_new (bin, buffer, sz, buf_offset);"
  identifiers:
  - CVE-2022-0521
  - CWE-119
  overview: Access of Memory Location After End of Buffer in GitHub repository radareorg/radare2
    prior to 5.6.2.
  references:
  - source: security@huntr.dev
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/radareorg/radare2/commit/6c4428f018d385fc80a33ecddcb37becea685dd5
  - source: security@huntr.dev
    tags:
    - Exploit
    - Patch
    - Third Party Advisory
    url: https://huntr.dev/bounties/4d436311-bbf1-45a3-8774-bdb666d7f7ca
  - source: security@huntr.dev
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/BZTIMAS53YT66FUS4QHQAFRJOBMUFG6D/
  - source: security@huntr.dev
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/E6YBRQ3UCFWJVSOYIKPVUDASZ544TFND/
  title: Access of Memory Location After End of Buffer in GitHub repository radareorg/radare2
    prior to 5.6.2.
- diff_content:
  - "--- a/libr/anal/p/anal_arm_cs.c\n+++ b/libr/anal/p/anal_arm_cs.c\n@@ -1015,7\
    \ +1015,7 @@ static const char *arg(RAnal *a, csh *handle, cs_insn *insn, char\
    \ *buf, int n) {\n \n #define VEC64(n) insn->detail->arm64.operands[n].vess\n\
    \ #define VEC64_APPEND(sb, n, i) vector64_append(sb, handle, insn, n, i)\n-#define\
    \ VEC64_MASK(sh, sz) (bitmask_by_width[63]^(bitmask_by_width[sz-1]<<sh))\n+#define\
    \ VEC64_MASK(sh, sz) (bitmask_by_width[63]^(bitmask_by_width[sz>0?sz-1:0]<<sh))\n\
    \ \n static void vector64_append(RStrBuf *sb, csh *handle, cs_insn *insn, int\
    \ n, int i) {\n \tcs_arm64_op op = INSOP64 (n);"
  identifiers:
  - CVE-2022-0522
  - CWE-119
  overview: Access of Memory Location Before Start of Buffer in NPM radare2.js prior
    to 5.6.2.
  references:
  - source: security@huntr.dev
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/radareorg/radare2/commit/d17a7bdf166108a29a27cd89bf454f9fa6c050d6
  - source: security@huntr.dev
    tags:
    - Exploit
    - Patch
    - Third Party Advisory
    url: https://huntr.dev/bounties/2d45e589-d614-4875-bba1-be0f729e7ca9
  - source: security@huntr.dev
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/BZTIMAS53YT66FUS4QHQAFRJOBMUFG6D/
  - source: security@huntr.dev
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/E6YBRQ3UCFWJVSOYIKPVUDASZ544TFND/
  title: Access of Memory Location Before Start of Buffer in NPM radare2.js prior
    to 5.6.2.
- diff_content:
  - "--- a/libr/bin/format/pyc/marshal.c\n+++ b/libr/bin/format/pyc/marshal.c\n@@\
    \ -1,4 +1,4 @@\n-/* radare - LGPL3 - Copyright 2016-2021 - Matthieu (c0riolis)\
    \ Tardy - l0stb1t*/\n+/* radare - LGPL3 - Copyright 2016-2022 - Matthieu (c0riolis)\
    \ Tardy - l0stb1t */\n \n #include <r_io.h>\n #include <r_bin.h>\n@@ -9,9 +9,9\
    \ @@\n #define if_true_return(cond,ret) if(cond){return(ret);}\n \n // TODO: kill\
    \ globals\n-static ut32 magic_int;\n-static ut32 symbols_ordinal = 0;\n-static\
    \ RList *refs = NULL; // If you don't have a good reason, do not change this.\
    \ And also checkout !refs in get_code_object()\n+static R_TH_LOCAL ut32 magic_int;\n\
    +static R_TH_LOCAL ut32 symbols_ordinal = 0;\n+static R_TH_LOCAL RList *refs =\
    \ NULL; // If you don't have a good reason, do not change this. And also checkout\
    \ !refs in get_code_object()\n \n /* interned_table is used to handle TYPE_INTERNED\
    \ object */\n extern RList *interned_table;\n@@ -500,13 +500,9 @@ static pyc_object\
    \ *get_array_object_generic(RBuffer *buffer, ut32 size) {\n \t}\n \tfor (i = 0;\
    \ i < size; i++) {\n \t\ttmp = get_object (buffer);\n-\t\tif (!tmp) {\n-\t\t\t\
    r_list_free (ret->data);\n-\t\t\tR_FREE (ret);\n-\t\t\treturn NULL;\n-\t\t}\n\
    -\t\tif (!r_list_append (ret->data, tmp)) {\n+\t\tif (!tmp || !r_list_append (ret->data,\
    \ tmp)) {\n \t\t\tfree_object (tmp);\n+\t\t\t((RList*)ret->data)->free = NULL;\n\
    \ \t\t\tr_list_free (ret->data);\n \t\t\tfree (ret);\n \t\t\treturn NULL;\n@@\
    \ -516,7 +512,6 @@ static pyc_object *get_array_object_generic(RBuffer *buffer,\
    \ ut32 size) {\n }\n \n /* small TYPE_SMALL_TUPLE doesn't exist in python2 */\n\
    -/* */\n static pyc_object *get_small_tuple_object(RBuffer *buffer) {\n \tpyc_object\
    \ *ret = NULL;\n \tbool error = false;\n@@ -535,32 +530,26 @@ static pyc_object\
    \ *get_small_tuple_object(RBuffer *buffer) {\n }\n \n static pyc_object *get_tuple_object(RBuffer\
    \ *buffer) {\n-\tpyc_object *ret = NULL;\n \tbool error = false;\n-\tut32 n =\
    \ 0;\n-\n-\tn = get_ut32 (buffer, &error);\n+\tut32 n = get_ut32 (buffer, &error);\n\
    \ \tif (n > ST32_MAX) {\n \t\teprintf (\"bad marshal data (tuple size out of range)\\\
    n\");\n \t\treturn NULL;\n \t}\n \tif (error) {\n \t\treturn NULL;\n \t}\n-\t\
    ret = get_array_object_generic (buffer, n);\n+\tpyc_object *ret = get_array_object_generic\
    \ (buffer, n);\n \tif (ret) {\n \t\tret->type = TYPE_TUPLE;\n-\t\treturn ret;\n\
    \ \t}\n-\treturn NULL;\n+\treturn ret;\n }\n \n static pyc_object *get_list_object(RBuffer\
    \ *buffer) {\n \tpyc_object *ret = NULL;\n \tbool error = false;\n-\tut32 n =\
    \ 0;\n-\n-\tn = get_ut32 (buffer, &error);\n+\tut32 n = get_ut32 (buffer, &error);\n\
    \ \tif (n > ST32_MAX) {\n \t\teprintf (\"bad marshal data (list size out of range)\\\
    n\");\n \t\treturn NULL;\n@@ -616,7 +605,6 @@ static pyc_object *get_dict_object(RBuffer\
    \ *buffer) {\n }\n \n static pyc_object *get_set_object(RBuffer *buffer) {\n-\t\
    pyc_object *ret = NULL;\n \tbool error = false;\n \tut32 n = get_ut32 (buffer,\
    \ &error);\n \tif (n > ST32_MAX) {\n@@ -626,11 +614,10 @@ static pyc_object *get_set_object(RBuffer\
    \ *buffer) {\n \tif (error) {\n \t\treturn NULL;\n \t}\n-\tret = get_array_object_generic\
    \ (buffer, n);\n-\tif (!ret) {\n-\t\treturn NULL;\n+\tpyc_object *ret = get_array_object_generic\
    \ (buffer, n);\n+\tif (ret) {\n+\t\tret->type = TYPE_SET;\n \t}\n-\tret->type\
    \ = TYPE_SET;\n \treturn ret;\n }\n "
  identifiers:
  - CVE-2022-0523
  - CWE-416
  overview: Use After Free in GitHub repository radareorg/radare2 prior to 5.6.2.
  references:
  - source: security@huntr.dev
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/radareorg/radare2/commit/35482cb760db10f87a62569e2f8872dbd95e9269
  - source: security@huntr.dev
    tags:
    - Exploit
    - Patch
    - Third Party Advisory
    url: https://huntr.dev/bounties/9d8d6ae0-fe00-40b9-ae1e-b0e8103bac69
  - source: security@huntr.dev
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/BZTIMAS53YT66FUS4QHQAFRJOBMUFG6D/
  - source: security@huntr.dev
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/E6YBRQ3UCFWJVSOYIKPVUDASZ544TFND/
  title: Use After Free in GitHub repository radareorg/radare2 prior to 5.6.2.
- diff_content:
  - "--- a/mrbgems/mruby-compiler/core/codegen.c\n+++ b/mrbgems/mruby-compiler/core/codegen.c\n\
    @@ -1865,15 +1865,21 @@ gen_assignment(codegen_scope *s, node *tree, node *rhs,\
    \ int sp, int val)\n           }\n         }\n         if (tree->cdr->car) { \
    \      /* keyword arguments */\n+          if (n == 14) {\n+            pop_n(n);\n\
    +            genop_2(s, OP_ARRAY, cursp(), n);\n+            push();\n+      \
    \      n = 15;\n+          }\n           gen_hash(s, tree->cdr->car->cdr, VAL,\
    \ 0);\n           if (n < 14) {\n             n++;\n-            push();\n   \
    \        }\n           else {\n-            pop();\n+            pop_n(2);\n \
    \            genop_2(s, OP_ARYPUSH, cursp(), 1);\n           }\n+          push();\n\
    \         }\n       }\n       if (rhs) {"
  identifiers:
  - CVE-2022-0525
  - CWE-125
  overview: Out-of-bounds Read in Homebrew mruby prior to 3.2.
  references:
  - source: security@huntr.dev
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/mruby/mruby/commit/0849a2885f81cfd82134992c06df3ccd59052ac7
  - source: security@huntr.dev
    tags:
    - Exploit
    - Third Party Advisory
    url: https://huntr.dev/bounties/e19e109f-acf0-4048-8ee8-1b10a870f1e9
  title: Out-of-bounds Read in Homebrew mruby prior to 3.2.
- diff_content:
  - "--- a/arangod/GeneralServer/ServerSecurityFeature.cpp\n+++ b/arangod/GeneralServer/ServerSecurityFeature.cpp\n\
    @@ -37,7 +37,8 @@ ServerSecurityFeature::ServerSecurityFeature(\n     : ApplicationFeature(server,\
    \ \"ServerSecurity\"),\n       _enableFoxxApi(true),\n       _enableFoxxStore(true),\n\
    -      _hardenedRestApi(false) {\n+      _hardenedRestApi(false),\n+      _foxxAllowInstallFromRemote(false)\
    \ {\n   setOptional(false);\n   startsAfter<application_features::GreetingsFeaturePhase>();\n\
    \ }\n@@ -68,6 +69,16 @@ void ServerSecurityFeature::collectOptions(\n        \
    \               arangodb::options::Flags::OnCoordinator,\n                   \
    \    arangodb::options::Flags::OnSingle))\n       .setIntroducedIn(30500);\n+\
    \  options\n+      ->addOption(\n+          \"--foxx.allow-install-from-remote\"\
    ,\n+          \"allow installing Foxx apps from remote URLs other than Github\"\
    ,\n+          new BooleanParameter(&_foxxAllowInstallFromRemote),\n+         \
    \ arangodb::options::makeFlags(\n+              arangodb::options::Flags::DefaultNoComponents,\n\
    +              arangodb::options::Flags::OnCoordinator,\n+              arangodb::options::Flags::OnSingle))\n\
    +      .setIntroducedIn(30805);\n }\n \n bool ServerSecurityFeature::isFoxxApiDisabled()\
    \ const {\n@@ -95,3 +106,7 @@ bool ServerSecurityFeature::canAccessHardenedApi()\
    \ const {\n   }\n   return allowAccess;\n }\n+\n+bool ServerSecurityFeature::foxxAllowInstallFromRemote()\
    \ const {\n+  return _foxxAllowInstallFromRemote;\n+}"
  - "--- a/arangod/V8Server/v8-actions.cpp\n+++ b/arangod/V8Server/v8-actions.cpp\n\
    @@ -1911,6 +1911,19 @@ static void JS_IsFoxxStoreDisabled(\n   TRI_V8_TRY_CATCH_END\n\
    \ }\n \n+static void JS_FoxxAllowInstallFromRemote(\n+    v8::FunctionCallbackInfo<v8::Value>\
    \ const& args) {\n+  TRI_V8_TRY_CATCH_BEGIN(isolate)\n+  v8::HandleScope scope(isolate);\n\
    +\n+  TRI_GET_GLOBALS();\n+  ServerSecurityFeature& security =\n+      v8g->_server.getFeature<ServerSecurityFeature>();\n\
    +  TRI_V8_RETURN_BOOL(security.foxxAllowInstallFromRemote());\n+\n+  TRI_V8_TRY_CATCH_END\n\
    +}\n+\n static void JS_RunInRestrictedContext(\n     v8::FunctionCallbackInfo<v8::Value>\
    \ const& args) {\n   TRI_V8_TRY_CATCH_BEGIN(isolate)\n@@ -1998,6 +2011,10 @@ void\
    \ TRI_InitV8ServerUtils(v8::Isolate* isolate) {\n   TRI_AddGlobalFunctionVocbase(\n\
    \       isolate, TRI_V8_ASCII_STRING(isolate, \"SYS_IS_FOXX_STORE_DISABLED\"),\n\
    \       JS_IsFoxxStoreDisabled, true);\n+  TRI_AddGlobalFunctionVocbase(\n+  \
    \    isolate,\n+      TRI_V8_ASCII_STRING(isolate, \"SYS_FOXX_ALLOW_INSTALL_FROM_REMOTE\"\
    ),\n+      JS_FoxxAllowInstallFromRemote, true);\n   TRI_AddGlobalFunctionVocbase(\n\
    \       isolate, TRI_V8_ASCII_STRING(isolate, \"SYS_RUN_IN_RESTRICTED_CONTEXT\"\
    ),\n       JS_RunInRestrictedContext, true);"
  - "--- a/arangod/GeneralServer/ServerSecurityFeature.cpp\n+++ b/arangod/GeneralServer/ServerSecurityFeature.cpp\n\
    @@ -36,7 +36,8 @@ ServerSecurityFeature::ServerSecurityFeature(application_features::ApplicationSe\n\
    \     : ApplicationFeature(server, \"ServerSecurity\"),\n       _enableFoxxApi(true),\n\
    \       _enableFoxxStore(true),\n-      _hardenedRestApi(false) {\n+      _hardenedRestApi(false),\n\
    +      _foxxAllowInstallFromRemote(false) {\n   setOptional(false);\n   startsAfter<application_features::GreetingsFeaturePhase>();\n\
    \ }\n@@ -55,14 +56,22 @@ void ServerSecurityFeature::collectOptions(std::shared_ptr<ProgramOptions>\
    \ optio\n                      arangodb::options::Flags::OnCoordinator,\n    \
    \                  arangodb::options::Flags::OnSingle))\n                    \
    \  .setIntroducedIn(30500);\n+\n   options->addOption(\"--foxx.store\", \"enables\
    \ Foxx store in web interface\",\n                      new BooleanParameter(&_enableFoxxStore),\n\
    \                      arangodb::options::makeFlags(\n                      arangodb::options::Flags::DefaultNoComponents,\n\
    \                      arangodb::options::Flags::OnCoordinator,\n            \
    \          arangodb::options::Flags::OnSingle))\n                      .setIntroducedIn(30500);\n\
    -\n+  \n+  options->addOption(\"--foxx.allow-install-from-remote\", \"allow installing\
    \ Foxx apps from remote URLs other than Github\",\n+                     new BooleanParameter(&_foxxAllowInstallFromRemote),\n\
    +                     arangodb::options::makeFlags(\n+                     arangodb::options::Flags::DefaultNoComponents,\n\
    +                     arangodb::options::Flags::OnCoordinator,\n+            \
    \         arangodb::options::Flags::OnSingle))\n+                     .setIntroducedIn(30805);\n\
    \ }\n \n bool ServerSecurityFeature::isFoxxApiDisabled() const {\n@@ -90,3 +99,7\
    \ @@ bool ServerSecurityFeature::canAccessHardenedApi() const {\n   }\n   return\
    \ allowAccess;\n }\n+  \n+bool ServerSecurityFeature::foxxAllowInstallFromRemote()\
    \ const {\n+  return _foxxAllowInstallFromRemote;\n+}"
  - "--- a/arangod/V8Server/v8-actions.cpp\n+++ b/arangod/V8Server/v8-actions.cpp\n\
    @@ -1791,6 +1791,17 @@ static void JS_IsFoxxStoreDisabled(v8::FunctionCallbackInfo<v8::Value>\
    \ const& ar\n   TRI_V8_TRY_CATCH_END\n }\n \n+static void JS_FoxxAllowInstallFromRemote(v8::FunctionCallbackInfo<v8::Value>\
    \ const& args) {\n+  TRI_V8_TRY_CATCH_BEGIN(isolate)\n+  v8::HandleScope scope(isolate);\n\
    +\n+  TRI_GET_GLOBALS();\n+  ServerSecurityFeature& security = v8g->_server.getFeature<ServerSecurityFeature>();\n\
    +  TRI_V8_RETURN_BOOL(security.foxxAllowInstallFromRemote());\n+\n+  TRI_V8_TRY_CATCH_END\n\
    +}\n+\n static void JS_RunInRestrictedContext(v8::FunctionCallbackInfo<v8::Value>\
    \ const& args) {\n   TRI_V8_TRY_CATCH_BEGIN(isolate)\n   v8::HandleScope scope(isolate);\n\
    @@ -1868,6 +1879,8 @@ void TRI_InitV8ServerUtils(v8::Isolate* isolate) {\n   \
    \                             TRI_V8_ASCII_STRING(isolate, \"SYS_IS_FOXX_API_DISABLED\"\
    ), JS_IsFoxxApiDisabled, true);\n   TRI_AddGlobalFunctionVocbase(isolate,\n  \
    \                              TRI_V8_ASCII_STRING(isolate, \"SYS_IS_FOXX_STORE_DISABLED\"\
    ), JS_IsFoxxStoreDisabled, true);\n+  TRI_AddGlobalFunctionVocbase(isolate,\n\
    +                               TRI_V8_ASCII_STRING(isolate, \"SYS_FOXX_ALLOW_INSTALL_FROM_REMOTE\"\
    ), JS_FoxxAllowInstallFromRemote, true);\n   TRI_AddGlobalFunctionVocbase(isolate,\n\
    \                                TRI_V8_ASCII_STRING(isolate, \"SYS_RUN_IN_RESTRICTED_CONTEXT\"\
    ), JS_RunInRestrictedContext, true);\n   "
  identifiers:
  - CVE-2021-25939
  - CWE-918
  overview: In ArangoDB, versions v3.7.0 through v3.9.0-alpha.1 have a feature which
    allows downloading a Foxx service from a publicly available URL. This feature
    does not enforce proper filtering of requests performed internally, which can
    be abused by a highly-privileged attacker to perform blind SSRF and send internal
    requests to localhost.
  references:
  - source: vulnerabilitylab@mend.io
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/arangodb/arangodb/commit/d7b35a6884c6b2802d34d79fb2a79fb2c9ec2175
  - source: vulnerabilitylab@mend.io
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/arangodb/arangodb/commit/d9b7f019d2435f107b19a59190bf9cc27d5f34dd
  - source: vulnerabilitylab@mend.io
    tags:
    - Exploit
    - Third Party Advisory
    url: https://www.whitesourcesoftware.com/vulnerability-database/CVE-2021-25939
  title: In ArangoDB, versions v3.7.0 through v3.9.0-alpha.1 have a feature which
    allows downloading a Foxx service from a publicly available URL. This feature
    does not enforce proper filtering of requests performed internally, which can
    be abused by a highly-privileged attacker to perform blind SSRF and send internal
    requests to localhost.
- diff_content:
  - "--- a/src/buffer.c\n+++ b/src/buffer.c\n@@ -1430,8 +1430,14 @@ do_buffer_ext(\n\
    \ \t\tbuf = buflist_findnr(curwin->w_jumplist[jumpidx].fmark.fnum);\n \t\tif (buf\
    \ != NULL)\n \t\t{\n-\t\t    if (buf == curbuf || !buf->b_p_bl)\n-\t\t\tbuf =\
    \ NULL;\t// skip current and unlisted bufs\n+\t\t    // Skip current and unlisted\
    \ bufs.  Also skip a quickfix\n+\t\t    // buffer, it might be deleted soon.\n\
    +\t\t    if (buf == curbuf || !buf->b_p_bl\n+#if defined(FEAT_QUICKFIX)\n+\t\t\
    \t    || bt_quickfix(buf)\n+#endif\n+\t\t\t    )\n+\t\t\tbuf = NULL;\n \t\t  \
    \  else if (buf->b_ml.ml_mfp == NULL)\n \t\t    {\n \t\t\t// skip unloaded buf,\
    \ but may keep it for later\n@@ -1467,7 +1473,11 @@ do_buffer_ext(\n \t\t    continue;\n\
    \ \t\t}\n \t\t// in non-help buffer, try to skip help buffers, and vv\n-\t\tif\
    \ (buf->b_help == curbuf->b_help && buf->b_p_bl)\n+\t\tif (buf->b_help == curbuf->b_help\
    \ && buf->b_p_bl\n+#if defined(FEAT_QUICKFIX)\n+\t\t\t    && !bt_quickfix(buf)\n\
    +#endif\n+\t\t\t   )\n \t\t{\n \t\t    if (buf->b_ml.ml_mfp != NULL)   // found\
    \ loaded buffer\n \t\t\tbreak;\n@@ -1485,7 +1495,11 @@ do_buffer_ext(\n \tif (buf\
    \ == NULL)\t// No loaded buffer, find listed one\n \t{\n \t    FOR_ALL_BUFFERS(buf)\n\
    -\t\tif (buf->b_p_bl && buf != curbuf)\n+\t\tif (buf->b_p_bl && buf != curbuf\n\
    +#if defined(FEAT_QUICKFIX)\n+\t\t\t    && !bt_quickfix(buf)\n+#endif\n+\t\t \
    \      )\n \t\t    break;\n \t}\n \tif (buf == NULL)\t// Still no buffer, just\
    \ take one\n@@ -1494,6 +1508,10 @@ do_buffer_ext(\n \t\tbuf = curbuf->b_next;\n\
    \ \t    else\n \t\tbuf = curbuf->b_prev;\n+#if defined(FEAT_QUICKFIX)\n+\t   \
    \ if (bt_quickfix(buf))\n+\t\tbuf = NULL;\n+#endif\n \t}\n     }\n "
  - "--- a/src/version.c\n+++ b/src/version.c\n@@ -746,6 +746,8 @@ static char *(features[])\
    \ =\n \n static int included_patches[] =\n {   /* Add new patch number below this\
    \ line */\n+/**/\n+    4327,\n /**/\n     4326,\n /**/"
  identifiers:
  - CVE-2022-0554
  - CWE-823
  overview: Use of Out-of-range Pointer Offset in GitHub repository vim/vim prior
    to 8.2.
  references:
  - source: security@huntr.dev
    tags:
    - Mailing List
    - Third Party Advisory
    url: http://seclists.org/fulldisclosure/2022/Oct/28
  - source: security@huntr.dev
    tags:
    - Mailing List
    - Release Notes
    - Third Party Advisory
    url: http://seclists.org/fulldisclosure/2022/Oct/41
  - source: security@huntr.dev
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/vim/vim/commit/e3537aec2f8d6470010547af28dcbd83d41461b8
  - source: security@huntr.dev
    tags:
    - Exploit
    - Patch
    - Third Party Advisory
    url: https://huntr.dev/bounties/7e8f6cd0-b5ee-48a2-8255-6a86f4c46c71
  - source: security@huntr.dev
    tags:
    - Mailing List
    - Third Party Advisory
    url: https://lists.debian.org/debian-lts-announce/2022/03/msg00018.html
  - source: security@huntr.dev
    tags:
    - Mailing List
    - Third Party Advisory
    url: https://lists.debian.org/debian-lts-announce/2022/11/msg00009.html
  - source: security@huntr.dev
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/7ZLEHVP4LNAGER4ZDGUDS5V5YVQD6INF/
  - source: security@huntr.dev
    tags:
    - Third Party Advisory
    url: https://security.gentoo.org/glsa/202208-32
  - source: security@huntr.dev
    tags:
    - Release Notes
    - Third Party Advisory
    url: https://support.apple.com/kb/HT213488
  title: Use of Out-of-range Pointer Offset in GitHub repository vim/vim prior to
    8.2.
- diff_content:
  - "--- a/drivers/usb/gadget/legacy/inode.c\n+++ b/drivers/usb/gadget/legacy/inode.c\n\
    @@ -1875,8 +1875,8 @@ dev_config (struct file *fd, const char __user *buf, size_t\
    \ len, loff_t *ptr)\n \n \tvalue = usb_gadget_probe_driver(&gadgetfs_driver);\n\
    \ \tif (value != 0) {\n-\t\tkfree (dev->buf);\n-\t\tdev->buf = NULL;\n+\t\tspin_lock_irq(&dev->lock);\n\
    +\t\tgoto fail;\n \t} else {\n \t\t/* at this point \"good\" hardware has for\
    \ the first time\n \t\t * let the USB the host see us.  alternatively, if users\n\
    @@ -1893,6 +1893,9 @@ dev_config (struct file *fd, const char __user *buf, size_t\
    \ len, loff_t *ptr)\n \treturn value;\n \n fail:\n+\tdev->config = NULL;\n+\t\
    dev->hs_config = NULL;\n+\tdev->dev = NULL;\n \tspin_unlock_irq (&dev->lock);\n\
    \ \tpr_debug (\"%s: %s fail %zd, %p\\n\", shortname, __func__, value, dev);\n\
    \ \tkfree (dev->buf);"
  - "--- a/drivers/usb/gadget/legacy/inode.c\n+++ b/drivers/usb/gadget/legacy/inode.c\n\
    @@ -1826,8 +1826,9 @@ dev_config (struct file *fd, const char __user *buf, size_t\
    \ len, loff_t *ptr)\n \tspin_lock_irq (&dev->lock);\n \tvalue = -EINVAL;\n \t\
    if (dev->buf) {\n+\t\tspin_unlock_irq(&dev->lock);\n \t\tkfree(kbuf);\n-\t\tgoto\
    \ fail;\n+\t\treturn value;\n \t}\n \tdev->buf = kbuf;\n "
  identifiers:
  - CVE-2022-24958
  - CWE-763
  overview: drivers/usb/gadget/legacy/inode.c in the Linux kernel through 5.16.8 mishandles
    dev->buf release.
  references:
  - source: cve@mitre.org
    tags:
    - Patch
    - Vendor Advisory
    url: https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit?id=89f3594d0de58e8a57d92d497dea9fee3d4b9cda
  - source: cve@mitre.org
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/torvalds/linux/commit/501e38a5531efbd77d5c73c0ba838a889bfc1d74
  - source: cve@mitre.org
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/torvalds/linux/commit/89f3594d0de58e8a57d92d497dea9fee3d4b9cda
  - source: cve@mitre.org
    tags:
    - Mailing List
    - Third Party Advisory
    url: https://lists.debian.org/debian-lts-announce/2022/07/msg00000.html
  - source: cve@mitre.org
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/SUVZA2YVOQJBJTDIDQ5HF5TAU2C6WP6H/
  - source: cve@mitre.org
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/TCW2KZYJ2H6BKZE3CVLHRIXYDGNYYC5P/
  - source: cve@mitre.org
    tags:
    - Third Party Advisory
    url: https://security.netapp.com/advisory/ntap-20220225-0008/
  title: drivers/usb/gadget/legacy/inode.c in the Linux kernel through 5.16.8 mishandles
    dev->buf release.
- diff_content:
  - "--- a/drivers/net/hamradio/yam.c\n+++ b/drivers/net/hamradio/yam.c\n@@ -950,9\
    \ +950,7 @@ static int yam_siocdevprivate(struct net_device *dev, struct ifreq\
    \ *ifr, void __\n \t\tym = memdup_user(data, sizeof(struct yamdrv_ioctl_mcs));\n\
    \ \t\tif (IS_ERR(ym))\n \t\t\treturn PTR_ERR(ym);\n-\t\tif (ym->cmd != SIOCYAMSMCS)\n\
    -\t\t\treturn -EINVAL;\n-\t\tif (ym->bitrate > YAM_MAXBITRATE) {\n+\t\tif (ym->cmd\
    \ != SIOCYAMSMCS || ym->bitrate > YAM_MAXBITRATE) {\n \t\t\tkfree(ym);\n \t\t\t\
    return -EINVAL;\n \t\t}"
  identifiers:
  - CVE-2022-24959
  - CWE-401
  overview: An issue was discovered in the Linux kernel before 5.16.5. There is a
    memory leak in yam_siocdevprivate in drivers/net/hamradio/yam.c.
  references:
  - source: cve@mitre.org
    tags:
    - Release Notes
    - Vendor Advisory
    url: https://cdn.kernel.org/pub/linux/kernel/v5.x/ChangeLog-5.16.5
  - source: cve@mitre.org
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/torvalds/linux/commit/29eb31542787e1019208a2e1047bb7c76c069536
  - source: cve@mitre.org
    tags:
    - Mailing List
    - Third Party Advisory
    url: https://lists.debian.org/debian-lts-announce/2022/03/msg00012.html
  - source: cve@mitre.org
    tags:
    - Third Party Advisory
    url: https://www.debian.org/security/2022/dsa-5092
  - source: cve@mitre.org
    tags:
    - Third Party Advisory
    url: https://www.debian.org/security/2022/dsa-5096
  title: An issue was discovered in the Linux kernel before 5.16.5. There is a memory
    leak in yam_siocdevprivate in drivers/net/hamradio/yam.c.
- diff_content:
  - "--- a/net/tipc/socket.c\n+++ b/net/tipc/socket.c\n@@ -1461,6 +1461,8 @@ static\
    \ int __tipc_sendmsg(struct socket *sock, struct msghdr *m, size_t dlen)\n \t\t\
    msg_set_syn(hdr, 1);\n \t}\n \n+\tmemset(&skaddr, 0, sizeof(skaddr));\n+\n \t\
    /* Determine destination */\n \tif (atype == TIPC_SERVICE_RANGE) {\n \t\treturn\
    \ tipc_sendmcast(sock, ua, m, dlen, timeout);"
  identifiers:
  - CVE-2022-0382
  - CWE-909
  overview: An information leak flaw was found due to uninitialized memory in the
    Linux kernel's TIPC protocol subsystem, in the way a user sends a TIPC datagram
    to one or more destinations. This flaw allows a local user to read some kernel
    memory. This issue is limited to no more than 7 bytes, and the user cannot control
    what is read. This flaw affects the Linux kernel versions prior to 5.17-rc1.
  references:
  - source: secalert@redhat.com
    tags:
    - Exploit
    - Patch
    - Third Party Advisory
    url: https://github.com/torvalds/linux/commit/d6d86830705f173fca6087a3e67ceaf68db80523
  title: An information leak flaw was found due to uninitialized memory in the Linux
    kernel's TIPC protocol subsystem, in the way a user sends a TIPC datagram to one
    or more destinations. This flaw allows a local user to read some kernel memory.
    This issue is limited to no more than 7 bytes, and the user cannot control what
    is read. This flaw affects the Linux kernel versions prior to 5.17-rc1.
- diff_content:
  - "--- a/mrbgems/mruby-compiler/core/codegen.c\n+++ b/mrbgems/mruby-compiler/core/codegen.c\n\
    @@ -1551,7 +1551,7 @@ gen_values(codegen_scope *s, node *t, int val, int limit)\n\
    \   while (t) {\n     int is_splat = nint(t->car->car) == NODE_SPLAT;\n \n-  \
    \  if (is_splat || n > limit || cursp() >= slimit) { /* flush stack */\n+    if\
    \ (is_splat || cursp() >= slimit) { /* flush stack */\n       pop_n(n);\n    \
    \   if (first) {\n         if (n == 0) {\n@@ -1590,6 +1590,11 @@ gen_values(codegen_scope\
    \ *s, node *t, int val, int limit)\n     }\n     return -1;                  /*\
    \ variable length */\n   }\n+  else if (n > limit) {\n+    pop_n(n);\n+    genop_2(s,\
    \ OP_ARRAY, cursp(), n);\n+    return -1;\n+  }\n   return n;\n }\n "
  identifiers:
  - CVE-2022-0570
  - CWE-122
  overview: Heap-based Buffer Overflow in Homebrew mruby prior to 3.2.
  references:
  - source: security@huntr.dev
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/mruby/mruby/commit/38b164ace7d6ae1c367883a3d67d7f559783faad
  - source: security@huntr.dev
    tags:
    - Exploit
    - Third Party Advisory
    url: https://huntr.dev/bounties/65a7632e-f95b-4836-b1a7-9cb95e5124f1
  title: Heap-based Buffer Overflow in Homebrew mruby prior to 3.2.
- diff_content:
  - "--- a/src/indent.c\n+++ b/src/indent.c\n@@ -1750,6 +1750,11 @@ ex_retab(exarg_T\
    \ *eap)\n \t    if (ptr[col] == NUL)\n \t\tbreak;\n \t    vcol += chartabsize(ptr\
    \ + col, (colnr_T)vcol);\n+\t    if (vcol >= MAXCOL)\n+\t    {\n+\t\temsg(_(e_resulting_text_too_long));\n\
    +\t\tbreak;\n+\t    }\n \t    if (has_mbyte)\n \t\tcol += (*mb_ptr2len)(ptr +\
    \ col);\n \t    else"
  - "--- a/src/version.c\n+++ b/src/version.c\n@@ -750,6 +750,8 @@ static char *(features[])\
    \ =\n \n static int included_patches[] =\n {   /* Add new patch number below this\
    \ line */\n+/**/\n+    4359,\n /**/\n     4358,\n /**/"
  identifiers:
  - CVE-2022-0572
  - CWE-787
  overview: Heap-based Buffer Overflow in GitHub repository vim/vim prior to 8.2.
  references:
  - source: security@huntr.dev
    tags:
    - Mailing List
    - Third Party Advisory
    url: http://seclists.org/fulldisclosure/2022/Oct/28
  - source: security@huntr.dev
    tags:
    - Mailing List
    - Release Notes
    - Third Party Advisory
    url: http://seclists.org/fulldisclosure/2022/Oct/41
  - source: security@huntr.dev
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/vim/vim/commit/6e28703a8e41f775f64e442c5d11ce1ff599aa3f
  - source: security@huntr.dev
    tags:
    - Exploit
    - Patch
    - Third Party Advisory
    url: https://huntr.dev/bounties/bf3e0643-03e9-4436-a1c8-74e7111c32bf
  - source: security@huntr.dev
    tags:
    - Mailing List
    - Third Party Advisory
    url: https://lists.debian.org/debian-lts-announce/2022/05/msg00022.html
  - source: security@huntr.dev
    tags:
    - Mailing List
    - Third Party Advisory
    url: https://lists.debian.org/debian-lts-announce/2022/11/msg00009.html
  - source: security@huntr.dev
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/4GOY5YWTP5QUY2EFLCL7AUWA2CV57C37/
  - source: security@huntr.dev
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/7ZLEHVP4LNAGER4ZDGUDS5V5YVQD6INF/
  - source: security@huntr.dev
    tags:
    - Release Notes
    - Third Party Advisory
    url: https://support.apple.com/kb/HT213488
  title: Heap-based Buffer Overflow in GitHub repository vim/vim prior to 8.2.
- diff_content:
  - "--- a/modules/saslserv/main.c\n+++ b/modules/saslserv/main.c\n@@ -385,15 +385,15\
    \ @@ sasl_handle_login(struct sasl_session *const restrict p, struct user *const\
    \ u, s\n \t// Find the account if necessary\n \tif (! mu)\n \t{\n-\t\tif (! *p->authzeid)\n\
    +\t\tif (! *p->pendingeid)\n \t\t{\n-\t\t\t(void) slog(LG_INFO, \"%s: session\
    \ for '%s' without an authzeid (BUG)\",\n+\t\t\t(void) slog(LG_INFO, \"%s: session\
    \ for '%s' without an pendingeid (BUG)\",\n \t\t\t                     MOWGLI_FUNC_NAME,\
    \ u->nick);\n \t\t\t(void) notice(saslsvs->nick, u->nick, LOGIN_CANCELLED_STR);\n\
    \ \t\t\treturn false;\n \t\t}\n \n-\t\tif (! (mu = myuser_find_uid(p->authzeid)))\n\
    +\t\tif (! (mu = myuser_find_uid(p->pendingeid)))\n \t\t{\n \t\t\tif (*p->authzid)\n\
    \ \t\t\t\t(void) notice(saslsvs->nick, u->nick, \"Account %s dropped; login cancelled\"\
    ,\n@@ -638,6 +638,8 @@ sasl_process_packet(struct sasl_session *const restrict\
    \ p, char *const restrict\n \t\t\t\treturn false;\n \t\t\t}\n \n+\t\t\t(void)\
    \ mowgli_strlcpy(p->pendingeid, p->authzeid, sizeof p->pendingeid);\n+\n \t\t\t\
    /* If the user is already on the network, attempt to log them in immediately.\n\
    \ \t\t\t * Otherwise, we will log them in on introduction of user to network\n\
    \ \t\t\t */"
  identifiers:
  - CVE-2022-24976
  - CWE-287
  overview: Atheme IRC Services before 7.2.12, when used in conjunction with InspIRCd,
    allows authentication bypass by ending an IRC handshake at a certain point during
    a challenge-response login sequence.
  references:
  - source: cve@mitre.org
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/atheme/atheme/commit/4e664c75d0b280a052eb8b5e81aa41944e593c52
  - source: cve@mitre.org
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/atheme/atheme/compare/v7.2.11...v7.2.12
  - source: cve@mitre.org
    tags:
    - Exploit
    - Mailing List
    - Third Party Advisory
    url: https://www.openwall.com/lists/oss-security/2022/01/30/4
  title: Atheme IRC Services before 7.2.12, when used in conjunction with InspIRCd,
    allows authentication bypass by ending an IRC handshake at a certain point during
    a challenge-response login sequence.
- diff_content:
  - "--- a/jscompile.c\n+++ b/jscompile.c\n@@ -794,15 +794,19 @@ static void addjump(JF,\
    \ enum js_AstType type, js_Ast *target, int inst)\n \ttarget->jumps = jump;\n\
    \ }\n \n-static void labeljumps(JF, js_JumpList *jump, int baddr, int caddr)\n\
    +static void labeljumps(JF, js_Ast *stm, int baddr, int caddr)\n {\n+\tjs_JumpList\
    \ *jump = stm->jumps;\n \twhile (jump) {\n+\t\tjs_JumpList *next = jump->next;\n\
    \ \t\tif (jump->type == STM_BREAK)\n \t\t\tlabelto(J, F, jump->inst, baddr);\n\
    \ \t\tif (jump->type == STM_CONTINUE)\n \t\t\tlabelto(J, F, jump->inst, caddr);\n\
    -\t\tjump = jump->next;\n+\t\tjs_free(J, jump);\n+\t\tjump = next;\n \t}\n+\t\
    stm->jumps = NULL;\n }\n \n static int isloop(enum js_AstType T)\n@@ -1121,7 +1125,7\
    \ @@ static void cstm(JF, js_Ast *stm)\n \t\tcexp(J, F, stm->b);\n \t\temitline(J,\
    \ F, stm);\n \t\temitjumpto(J, F, OP_JTRUE, loop);\n-\t\tlabeljumps(J, F, stm->jumps,\
    \ here(J,F), cont);\n+\t\tlabeljumps(J, F, stm, here(J,F), cont);\n \t\tbreak;\n\
    \ \n \tcase STM_WHILE:\n@@ -1133,7 +1137,7 @@ static void cstm(JF, js_Ast *stm)\n\
    \ \t\temitline(J, F, stm);\n \t\temitjumpto(J, F, OP_JUMP, loop);\n \t\tlabel(J,\
    \ F, end);\n-\t\tlabeljumps(J, F, stm->jumps, here(J,F), loop);\n+\t\tlabeljumps(J,\
    \ F, stm, here(J,F), loop);\n \t\tbreak;\n \n \tcase STM_FOR:\n@@ -1164,7 +1168,7\
    \ @@ static void cstm(JF, js_Ast *stm)\n \t\temitjumpto(J, F, OP_JUMP, loop);\n\
    \ \t\tif (end)\n \t\t\tlabel(J, F, end);\n-\t\tlabeljumps(J, F, stm->jumps, here(J,F),\
    \ cont);\n+\t\tlabeljumps(J, F, stm, here(J,F), cont);\n \t\tbreak;\n \n \tcase\
    \ STM_FOR_IN:\n@@ -1189,12 +1193,12 @@ static void cstm(JF, js_Ast *stm)\n \t\t\
    \temitjumpto(J, F, OP_JUMP, loop);\n \t\t}\n \t\tlabel(J, F, end);\n-\t\tlabeljumps(J,\
    \ F, stm->jumps, here(J,F), loop);\n+\t\tlabeljumps(J, F, stm, here(J,F), loop);\n\
    \ \t\tbreak;\n \n \tcase STM_SWITCH:\n \t\tcswitch(J, F, stm->a, stm->b);\n-\t\
    \tlabeljumps(J, F, stm->jumps, here(J,F), 0);\n+\t\tlabeljumps(J, F, stm, here(J,F),\
    \ 0);\n \t\tbreak;\n \n \tcase STM_LABEL:\n@@ -1204,7 +1208,7 @@ static void cstm(JF,\
    \ js_Ast *stm)\n \t\t\tstm = stm->b;\n \t\t/* loops and switches have already\
    \ been labelled */\n \t\tif (!isloop(stm->type) && stm->type != STM_SWITCH)\n\
    -\t\t\tlabeljumps(J, F, stm->jumps, here(J,F), 0);\n+\t\t\tlabeljumps(J, F, stm,\
    \ here(J,F), 0);\n \t\tbreak;\n \n \tcase STM_BREAK:"
  identifiers:
  - CVE-2021-45005
  - CWE-787
  overview: Artifex MuJS v1.1.3 was discovered to contain a heap buffer overflow which
    is caused by conflicting JumpList of nested try/finally statements.
  references:
  - source: cve@mitre.org
    tags:
    - Permissions Required
    url: https://bugs.ghostscript.com/show_bug.cgi?id=704749
  - source: cve@mitre.org
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/ccxvii/mujs/commit/df8559e7bdbc6065276e786217eeee70f28fce66
  title: Artifex MuJS v1.1.3 was discovered to contain a heap buffer overflow which
    is caused by conflicting JumpList of nested try/finally statements.
- diff_content:
  - "--- a/src/njs_vmcode.c\n+++ b/src/njs_vmcode.c\n@@ -1516,6 +1516,7 @@ njs_vmcode_typeof(njs_vm_t\
    \ *vm, njs_value_t *value, njs_value_t *invld)\n         &njs_string_object,\n\
    \         &njs_string_object,\n         &njs_string_object,\n+        &njs_string_object,\n\
    \     };\n \n     vm->retval = *types[value->type];"
  - "--- a/src/test/njs_unit_test.c\n+++ b/src/test/njs_unit_test.c\n@@ -6390,6 +6390,9\
    \ @@ static njs_unit_test_t  njs_test[] =\n     { njs_str(\"(new DataView(new\
    \ ArrayBuffer(3)))\"),\n       njs_str(\"[object DataView]\") },\n \n+    { njs_str(\"\
    var x = new ArrayBuffer(3); [typeof x, typeof new DataView(x)]\"),\n+      njs_str(\"\
    object,object\") },\n+\n     { njs_str(\"(new DataView(new ArrayBuffer(3))).buffer\"\
    ),\n       njs_str(\"[object ArrayBuffer]\") },\n "
  identifiers:
  - CVE-2021-46461
  - CWE-119
  overview: njs through 0.7.0, used in NGINX, was discovered to contain an out-of-bounds
    array access via njs_vmcode_typeof in /src/njs_vmcode.c.
  references:
  - source: cve@mitre.org
    tags:
    - Patch
    - Vendor Advisory
    url: https://github.com/nginx/njs/commit/d457c9545e7e71ebb5c0479eb16b9d33175855e2
  - source: cve@mitre.org
    tags:
    - Exploit
    - Third Party Advisory
    url: https://github.com/nginx/njs/issues/450
  - source: cve@mitre.org
    tags:
    - Third Party Advisory
    url: https://security.netapp.com/advisory/ntap-20220303-0007/
  title: njs through 0.7.0, used in NGINX, was discovered to contain an out-of-bounds
    array access via njs_vmcode_typeof in /src/njs_vmcode.c.
- diff_content:
  - "--- a/src/njs_function.c\n+++ b/src/njs_function.c\n@@ -1385,18 +1385,10 @@ njs_function_prototype_apply(njs_vm_t\
    \ *vm, njs_value_t *args, njs_uint_t nargs,\n \n     if (njs_is_null_or_undefined(arr_like))\
    \ {\n         length = 0;\n-\n-        goto activate;\n-\n-    } else if (njs_is_array(arr_like))\
    \ {\n-        arr = arr_like->data.u.array;\n-\n-        args = arr->start;\n\
    -        length = arr->length;\n-\n         goto activate;\n+    }\n \n-    }\
    \ else if (njs_slow_path(!njs_is_object(arr_like))) {\n+    if (njs_slow_path(!njs_is_object(arr_like)))\
    \ {\n         njs_type_error(vm, \"second argument is not an array-like object\"\
    );\n         return NJS_ERROR;\n     }\n@@ -1406,6 +1398,11 @@ njs_function_prototype_apply(njs_vm_t\
    \ *vm, njs_value_t *args, njs_uint_t nargs,\n         return ret;\n     }\n \n\
    +    if (njs_slow_path(length > 1024)) {\n+        njs_internal_error(vm, \"argument\
    \ list is too long\");\n+        return NJS_ERROR;\n+    }\n+\n     arr = njs_array_alloc(vm,\
    \ 1, length, NJS_ARRAY_SPARE);\n     if (njs_slow_path(arr == NULL)) {\n     \
    \    return NJS_ERROR;"
  - "--- a/src/test/njs_unit_test.c\n+++ b/src/test/njs_unit_test.c\n@@ -10063,6 +10063,10\
    \ @@ static njs_unit_test_t  njs_test[] =\n                  \"f.apply(123, {})\"\
    ),\n       njs_str(\"123\") },\n \n+    { njs_str(\"(function(index, ...rest){\
    \ return rest[index];})\"\n+              \".apply({}, [1022].concat(Array(1023).fill(1).map((v,i)=>i.toString(16))))\"\
    ),\n+      njs_str(\"3fe\") },\n+\n     { njs_str(\"String.prototype.concat.apply('a',\
    \ \"\n                  \"{length:2, 0:{toString:function() {return 'b'}}, 1:'c'})\"\
    ),\n       njs_str(\"abc\") },"
  identifiers:
  - CVE-2021-46462
  - NVD-CWE-noinfo
  overview: njs through 0.7.1, used in NGINX, was discovered to contain a segmentation
    violation via njs_object_set_prototype in /src/njs_object.c.
  references:
  - source: cve@mitre.org
    tags:
    - Patch
    - Vendor Advisory
    url: https://github.com/nginx/njs/commit/39e8fa1b7db1680654527f8fa0e9ee93b334ecba
  - source: cve@mitre.org
    tags:
    - Exploit
    - Issue Tracking
    - Patch
    - Third Party Advisory
    url: https://github.com/nginx/njs/issues/449
  - source: cve@mitre.org
    tags:
    - Third Party Advisory
    url: https://security.netapp.com/advisory/ntap-20220303-0007/
  title: njs through 0.7.1, used in NGINX, was discovered to contain a segmentation
    violation via njs_object_set_prototype in /src/njs_object.c.
- diff_content:
  - "--- a/src/njs_promise.c\n+++ b/src/njs_promise.c\n@@ -771,25 +771,19 @@ njs_promise_resolve(njs_vm_t\
    \ *vm, njs_value_t *constructor, njs_value_t *x)\n {\n     njs_int_t         \
    \        ret;\n     njs_value_t               value;\n-    njs_object_t      \
    \        *object;\n     njs_promise_capability_t  *capability;\n \n     static\
    \ const njs_value_t  string_constructor = njs_string(\"constructor\");\n \n- \
    \   if (njs_is_object(x)) {\n-        object = njs_object_proto_lookup(njs_object(x),\
    \ NJS_PROMISE,\n-                                         njs_object_t);\n-\n\
    -        if (object != NULL) {\n-            ret = njs_value_property(vm, x, njs_value_arg(&string_constructor),\n\
    -                                     &value);\n-            if (njs_slow_path(ret\
    \ == NJS_ERROR)) {\n-                return NULL;\n-            }\n+    if (njs_is_promise(x))\
    \ {\n+        ret = njs_value_property(vm, x, njs_value_arg(&string_constructor),\n\
    +                                 &value);\n+        if (njs_slow_path(ret ==\
    \ NJS_ERROR)) {\n+            return NULL;\n+        }\n \n-            if (njs_values_same(&value,\
    \ constructor)) {\n-                return njs_promise(x);\n-            }\n+\
    \        if (njs_values_same(&value, constructor)) {\n+            return njs_promise(x);\n\
    \         }\n     }\n \n@@ -875,19 +869,12 @@ njs_promise_prototype_then(njs_vm_t\
    \ *vm, njs_value_t *args, njs_uint_t nargs,\n {\n     njs_int_t              \
    \   ret;\n     njs_value_t               *promise, *fulfilled, *rejected, constructor;\n\
    -    njs_object_t              *object;\n     njs_function_t            *function;\n\
    \     njs_promise_capability_t  *capability;\n \n     promise = njs_argument(args,\
    \ 0);\n \n-    if (njs_slow_path(!njs_is_object(promise))) {\n-        goto failed;\n\
    -    }\n-\n-    object = njs_object_proto_lookup(njs_object(promise), NJS_PROMISE,\n\
    -                                     njs_object_t);\n-    if (njs_slow_path(object\
    \ == NULL)) {\n+    if (njs_slow_path(!njs_is_promise(promise))) {\n         goto\
    \ failed;\n     }\n \n@@ -933,6 +920,8 @@ njs_promise_perform_then(njs_vm_t *vm,\
    \ njs_value_t *value,\n     njs_promise_data_t      *data;\n     njs_promise_reaction_t\
    \  *fulfilled_reaction, *rejected_reaction;\n \n+    njs_assert(njs_is_promise(value));\n\
    +\n     if (!njs_is_function(fulfilled)) {\n         fulfilled = njs_value_arg(&njs_value_undefined);\n\
    \     }"
  - "--- a/src/njs_vmcode.c\n+++ b/src/njs_vmcode.c\n@@ -1895,7 +1895,7 @@ njs_vmcode_await(njs_vm_t\
    \ *vm, njs_vmcode_await_t *await)\n     rejected->args_count = 1;\n     rejected->u.native\
    \ = njs_await_rejected;\n \n-    njs_set_object(&val, &promise->object);\n+  \
    \  njs_set_promise(&val, promise);\n     njs_set_function(&on_fulfilled, fulfilled);\n\
    \     njs_set_function(&on_rejected, rejected);\n "
  identifiers:
  - CVE-2021-46463
  - CWE-843
  overview: njs through 0.7.1, used in NGINX, was discovered to contain a control
    flow hijack caused by a Type Confusion vulnerability in njs_promise_perform_then().
  references:
  - source: cve@mitre.org
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/nginx/njs/commit/6a40a85ff239497c6458c7dbef18f6a2736fe992
  - source: cve@mitre.org
    tags:
    - Exploit
    - Issue Tracking
    - Patch
    - Third Party Advisory
    url: https://github.com/nginx/njs/issues/447
  - source: cve@mitre.org
    tags:
    - Third Party Advisory
    url: https://security.netapp.com/advisory/ntap-20220303-0007/
  title: njs through 0.7.1, used in NGINX, was discovered to contain a control flow
    hijack caused by a Type Confusion vulnerability in njs_promise_perform_then().
- diff_content:
  - "--- a/src/njs_async.c\n+++ b/src/njs_async.c\n@@ -29,9 +29,7 @@ njs_async_function_frame_invoke(njs_vm_t\
    \ *vm, njs_value_t *retval)\n         return NJS_ERROR;\n     }\n \n-    frame->function->context\
    \ = capability;\n-\n-    ret = njs_function_lambda_call(vm);\n+    ret = njs_function_lambda_call(vm,\
    \ capability, NULL);\n \n     if (ret == NJS_OK) {\n         ret = njs_function_call(vm,\
    \ njs_function(&capability->resolve),\n@@ -63,7 +61,6 @@ njs_await_fulfilled(njs_vm_t\
    \ *vm, njs_value_t *args, njs_uint_t nargs,\n     njs_int_t           ret;\n \
    \    njs_value_t         **cur_local, **cur_closures, **cur_temp, *value;\n  \
    \   njs_frame_t         *frame, *async_frame;\n-    njs_function_t      *function;\n\
    \     njs_async_ctx_t     *ctx;\n     njs_native_frame_t  *top, *async;\n \n@@\
    \ -78,8 +75,6 @@ njs_await_fulfilled(njs_vm_t *vm, njs_value_t *args, njs_uint_t\
    \ nargs,\n     async = &async_frame->native;\n     async->previous = vm->top_frame;\n\
    \ \n-    function = async->function;\n-\n     cur_local = vm->levels[NJS_LEVEL_LOCAL];\n\
    \     cur_closures = vm->levels[NJS_LEVEL_CLOSURE];\n     cur_temp = vm->levels[NJS_LEVEL_TEMP];\n\
    @@ -98,13 +93,7 @@ njs_await_fulfilled(njs_vm_t *vm, njs_value_t *args, njs_uint_t\
    \ nargs,\n \n     vm->top_frame->retval = &vm->retval;\n \n-    function->context\
    \ = ctx->capability;\n-    function->await = ctx;\n-\n-    ret = njs_vmcode_interpreter(vm,\
    \ ctx->pc);\n-\n-    function->context = NULL;\n-    function->await = NULL;\n\
    +    ret = njs_vmcode_interpreter(vm, ctx->pc, ctx->capability, ctx);\n \n   \
    \  vm->levels[NJS_LEVEL_LOCAL] = cur_local;\n     vm->levels[NJS_LEVEL_CLOSURE]\
    \ = cur_closures;"
  - "--- a/src/njs_function.c\n+++ b/src/njs_function.c\n@@ -608,7 +608,7 @@ njs_function_call2(njs_vm_t\
    \ *vm, njs_function_t *function,\n \n \n njs_int_t\n-njs_function_lambda_call(njs_vm_t\
    \ *vm)\n+njs_function_lambda_call(njs_vm_t *vm, void *promise_cap, void *async_ctx)\n\
    \ {\n     uint32_t               n;\n     njs_int_t              ret;\n@@ -622,6\
    \ +622,8 @@ njs_function_lambda_call(njs_vm_t *vm)\n     frame = (njs_frame_t\
    \ *) vm->top_frame;\n     function = frame->native.function;\n \n+    njs_assert(function->context\
    \ == NULL);\n+\n     if (function->global && !function->closure_copied) {\n  \
    \       ret = njs_function_capture_global_closures(vm, function);\n         if\
    \ (njs_slow_path(ret != NJS_OK)) {\n@@ -698,7 +700,7 @@ njs_function_lambda_call(njs_vm_t\
    \ *vm)\n         }\n     }\n \n-    ret = njs_vmcode_interpreter(vm, lambda->start);\n\
    +    ret = njs_vmcode_interpreter(vm, lambda->start, promise_cap, async_ctx);\n\
    \ \n     /* Restore current level. */\n     vm->levels[NJS_LEVEL_LOCAL] = cur_local;\n\
    @@ -775,7 +777,7 @@ njs_function_frame_invoke(njs_vm_t *vm, njs_value_t *retval)\n\
    \         return njs_function_native_call(vm);\n \n     } else {\n-        return\
    \ njs_function_lambda_call(vm);\n+        return njs_function_lambda_call(vm,\
    \ NULL, NULL);\n     }\n }\n "
  - "--- a/src/njs_vm.c\n+++ b/src/njs_vm.c\n@@ -490,7 +490,7 @@ njs_vm_start(njs_vm_t\
    \ *vm)\n         return ret;\n     }\n \n-    ret = njs_vmcode_interpreter(vm,\
    \ vm->start);\n+    ret = njs_vmcode_interpreter(vm, vm->start, NULL, NULL);\n\
    \ \n     return (ret == NJS_ERROR) ? NJS_ERROR : NJS_OK;\n }"
  - "--- a/src/njs_vmcode.c\n+++ b/src/njs_vmcode.c\n@@ -42,7 +42,8 @@ static njs_jump_off_t\
    \ njs_vmcode_debugger(njs_vm_t *vm);\n static njs_jump_off_t njs_vmcode_return(njs_vm_t\
    \ *vm, njs_value_t *invld,\n     njs_value_t *retval);\n \n-static njs_jump_off_t\
    \ njs_vmcode_await(njs_vm_t *vm, njs_vmcode_await_t *await);\n+static njs_jump_off_t\
    \ njs_vmcode_await(njs_vm_t *vm, njs_vmcode_await_t *await,\n+    njs_promise_capability_t\
    \ *pcap, njs_async_ctx_t *actx);\n \n static njs_jump_off_t njs_vmcode_try_start(njs_vm_t\
    \ *vm, njs_value_t *value,\n     njs_value_t *offset, u_char *pc);\n@@ -77,7 +78,8\
    \ @@ static njs_jump_off_t njs_function_frame_create(njs_vm_t *vm,\n \n \n njs_int_t\n\
    -njs_vmcode_interpreter(njs_vm_t *vm, u_char *pc)\n+njs_vmcode_interpreter(njs_vm_t\
    \ *vm, u_char *pc, void *promise_cap,\n+    void *async_ctx)\n {\n     u_char\
    \                       *catch;\n     double                       num, exponent;\n\
    @@ -826,7 +828,7 @@ njs_vmcode_interpreter(njs_vm_t *vm, u_char *pc)\n \n    \
    \         case NJS_VMCODE_AWAIT:\n                 await = (njs_vmcode_await_t\
    \ *) pc;\n-                return njs_vmcode_await(vm, await);\n+            \
    \    return njs_vmcode_await(vm, await, promise_cap, async_ctx);\n \n        \
    \     case NJS_VMCODE_TRY_START:\n                 ret = njs_vmcode_try_start(vm,\
    \ value1, value2, pc);\n@@ -1812,15 +1814,15 @@ njs_vmcode_return(njs_vm_t *vm,\
    \ njs_value_t *invld, njs_value_t *retval)\n \n \n static njs_jump_off_t\n-njs_vmcode_await(njs_vm_t\
    \ *vm, njs_vmcode_await_t *await)\n+njs_vmcode_await(njs_vm_t *vm, njs_vmcode_await_t\
    \ *await,\n+    njs_promise_capability_t *pcap, njs_async_ctx_t *ctx)\n {\n  \
    \   size_t              size;\n     njs_int_t           ret;\n     njs_frame_t\
    \         *frame;\n     njs_value_t         ctor, val, on_fulfilled, on_rejected,\
    \ *value;\n     njs_promise_t       *promise;\n     njs_function_t      *fulfilled,\
    \ *rejected;\n-    njs_async_ctx_t     *ctx;\n     njs_native_frame_t  *active;\n\
    \ \n     active = &vm->active_frame->native;\n@@ -1837,8 +1839,6 @@ njs_vmcode_await(njs_vm_t\
    \ *vm, njs_vmcode_await_t *await)\n         return NJS_ERROR;\n     }\n \n-  \
    \  ctx = active->function->await;\n-\n     if (ctx == NULL) {\n         ctx =\
    \ njs_mp_alloc(vm->mem_pool, sizeof(njs_async_ctx_t));\n         if (njs_slow_path(ctx\
    \ == NULL)) {\n@@ -1854,9 +1854,7 @@ njs_vmcode_await(njs_vm_t *vm, njs_vmcode_await_t\
    \ *await)\n         }\n \n         ctx->await = fulfilled->context;\n-       \
    \ ctx->capability = active->function->context;\n-\n-        active->function->context\
    \ = NULL;\n+        ctx->capability = pcap;\n \n         ret = njs_function_frame_save(vm,\
    \ ctx->await, NULL);\n         if (njs_slow_path(ret != NJS_OK)) {"
  identifiers:
  - CVE-2022-25139
  - CWE-416
  overview: njs through 0.7.0, used in NGINX, was discovered to contain a heap use-after-free
    in njs_await_fulfilled.
  references:
  - source: cve@mitre.org
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/nginx/njs/commit/6a07c2156a07ef307b6dcf3c2ca8571a5f1af7a6
  - source: cve@mitre.org
    tags:
    - Exploit
    - Issue Tracking
    - Patch
    - Third Party Advisory
    url: https://github.com/nginx/njs/issues/451
  - source: cve@mitre.org
    tags:
    - Third Party Advisory
    url: https://security.netapp.com/advisory/ntap-20220303-0007/
  title: njs through 0.7.0, used in NGINX, was discovered to contain a heap use-after-free
    in njs_await_fulfilled.
- diff_content:
  - "--- a/src/vm.c\n+++ b/src/vm.c\n@@ -2766,7 +2766,7 @@ mrb_vm_exec(mrb_state *mrb,\
    \ const struct RProc *proc, const mrb_code *pc)\n       int lim = a+b*2+1;\n \n\
    \       hash = regs[a];\n-      mrb_assert(mrb_hash_p(hash));\n+      mrb_ensure_hash_type(mrb,\
    \ hash);\n       for (i=a+1; i<lim; i+=2) {\n         mrb_hash_set(mrb, hash,\
    \ regs[i], regs[i+1]);\n       }"
  identifiers:
  - CVE-2022-0614
  - CWE-119
  overview: Use of Out-of-range Pointer Offset in Homebrew mruby prior to 3.2.
  references:
  - source: security@huntr.dev
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/mruby/mruby/commit/ff3a5ebed6ffbe3e70481531cfb969b497aa73ad
  - source: security@huntr.dev
    tags:
    - Exploit
    - Patch
    - Third Party Advisory
    url: https://huntr.dev/bounties/a980ce4d-c359-4425-92c4-e844c0055879
  title: Use of Out-of-range Pointer Offset in Homebrew mruby prior to 3.2.
- diff_content:
  - "--- a/libr/io/io_bank.c\n+++ b/libr/io/io_bank.c\n@@ -226,12 +226,18 @@ R_API\
    \ bool r_io_bank_map_add_top(RIO *io, const ut32 bankid, const ut32 mapid) {\n\
    \ \t\tr_io_submap_set_to (bd, r_io_submap_from (sm) - 1);\n \t\tentry = r_rbnode_next\
    \ (entry);\n \t}\n-\twhile (entry && r_io_submap_to (((RIOSubMap *)entry->data))\
    \ <= r_io_submap_to (sm)) {\n+\tut64 smto = r_io_submap_to (sm);\n+\twhile (entry\
    \ && r_io_submap_to (((RIOSubMap *)entry->data)) <= smto) {\n \t\t//delete all\
    \ submaps that are completly included in sm\n \t\tRRBNode *next = r_rbnode_next\
    \ (entry);\n \t\t// this can be optimized, there is no need to do search here\n\
    +\t\t// XXX this is a workaround to avoid an UAF in Reproducer: iobank-crash\n\
    +\t\tvoid *smfree = bank->submaps->free;\n+\t\tbank->submaps->free = NULL;\n \t\
    \tbool a = r_crbtree_delete (bank->submaps, entry->data, _find_sm_by_from_vaddr_cb,\
    \ NULL);\n+\t\tbank->submaps->free = smfree;\n \t\tif (!a) {\n+\t\t\tentry = NULL;\n\
    \ \t\t\tbreak;\n \t\t}\n \t\tentry = next;"
  - "--- a/libr/util/new_rbtree.c\n+++ b/libr/util/new_rbtree.c\n@@ -138,9 +138,9\
    \ @@ R_API bool r_crbtree_insert(RRBTree *tree, void *data, RRBComparator cmp,\
    \ void *\n \tr_return_val_if_fail (tree && data && cmp, false);\n \tbool inserted\
    \ = false;\n \n-\tif (tree->root == NULL) {\n+\tif (!tree->root) {\n \t\ttree->root\
    \ = _node_new (data, NULL);\n-\t\tif (tree->root == NULL) {\n+\t\tif (!tree->root)\
    \ {\n \t\t\treturn false;\n \t\t}\n \t\tinserted = true;"
  identifiers:
  - CVE-2022-0559
  - CWE-416
  overview: Use After Free in GitHub repository radareorg/radare2 prior to 5.6.2.
  references:
  - source: security@huntr.dev
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/radareorg/radare2/commit/b5cb90b28ec71fda3504da04e3cc94a362807f5e
  - source: security@huntr.dev
    tags:
    - Exploit
    - Patch
    - Third Party Advisory
    url: https://huntr.dev/bounties/aa80adb7-e900-44a5-ad05-91f3ccdfc81e
  - source: security@huntr.dev
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/BZTIMAS53YT66FUS4QHQAFRJOBMUFG6D/
  - source: security@huntr.dev
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/E6YBRQ3UCFWJVSOYIKPVUDASZ544TFND/
  title: Use After Free in GitHub repository radareorg/radare2 prior to 5.6.2.
- diff_content:
  - "--- a/drivers/tty/vt/vt_ioctl.c\n+++ b/drivers/tty/vt/vt_ioctl.c\n@@ -246,6 +246,8\
    \ @@ int vt_waitactive(int n)\n  *\n  * XXX It should at least call into the driver,\
    \ fbdev's definitely need to\n  * restore their engine state. --BenH\n+ *\n+ *\
    \ Called with the console lock held.\n  */\n static int vt_kdsetmode(struct vc_data\
    \ *vc, unsigned long mode)\n {\n@@ -262,7 +264,6 @@ static int vt_kdsetmode(struct\
    \ vc_data *vc, unsigned long mode)\n \t\treturn -EINVAL;\n \t}\n \n-\t/* FIXME:\
    \ this needs the console lock extending */\n \tif (vc->vc_mode == mode)\n \t\t\
    return 0;\n \n@@ -271,12 +272,10 @@ static int vt_kdsetmode(struct vc_data *vc,\
    \ unsigned long mode)\n \t\treturn 0;\n \n \t/* explicitly blank/unblank the screen\
    \ if switching modes */\n-\tconsole_lock();\n \tif (mode == KD_TEXT)\n \t\tdo_unblank_screen(1);\n\
    \ \telse\n \t\tdo_blank_screen(1);\n-\tconsole_unlock();\n \n \treturn 0;\n }\n\
    @@ -378,7 +377,10 @@ static int vt_k_ioctl(struct tty_struct *tty, unsigned int\
    \ cmd,\n \t\tif (!perm)\n \t\t\treturn -EPERM;\n \n-\t\treturn vt_kdsetmode(vc,\
    \ arg);\n+\t\tconsole_lock();\n+\t\tret = vt_kdsetmode(vc, arg);\n+\t\tconsole_unlock();\n\
    +\t\treturn ret;\n \n \tcase KDGETMODE:\n \t\treturn put_user(vc->vc_mode, (int\
    \ __user *)arg);"
  identifiers:
  - CVE-2021-3753
  - CWE-125
  overview: A race problem was seen in the vt_k_ioctl in drivers/tty/vt/vt_ioctl.c
    in the Linux kernel, which may cause an out of bounds read in vt as the write
    access to vc_mode is not protected by lock-in vt_ioctl (KDSETMDE). The highest
    threat from this vulnerability is to data confidentiality.
  references:
  - source: secalert@redhat.com
    tags:
    - Issue Tracking
    - Patch
    - Third Party Advisory
    url: https://bugzilla.redhat.com/show_bug.cgi?id=1999589
  - source: secalert@redhat.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/torvalds/linux/commit/2287a51ba822384834dafc1c798453375d1107c7
  - source: secalert@redhat.com
    tags:
    - Third Party Advisory
    url: https://security.netapp.com/advisory/ntap-20221028-0003/
  - source: secalert@redhat.com
    tags:
    - Exploit
    - Mailing List
    - Patch
    - Third Party Advisory
    url: https://www.openwall.com/lists/oss-security/2021/09/01/4
  title: A race problem was seen in the vt_k_ioctl in drivers/tty/vt/vt_ioctl.c in
    the Linux kernel, which may cause an out of bounds read in vt as the write access
    to vc_mode is not protected by lock-in vt_ioctl (KDSETMDE). The highest threat
    from this vulnerability is to data confidentiality.
- diff_content:
  - "--- a/drivers/usb/gadget/composite.c\n+++ b/drivers/usb/gadget/composite.c\n\
    @@ -1988,6 +1988,9 @@ composite_setup(struct usb_gadget *gadget, const struct\
    \ usb_ctrlrequest *ctrl)\n \t\t\t\tif (w_index != 0x5 || (w_value >> 8))\n \t\t\
    \t\t\tbreak;\n \t\t\t\tinterface = w_value & 0xFF;\n+\t\t\t\tif (interface >=\
    \ MAX_CONFIG_INTERFACES ||\n+\t\t\t\t    !os_desc_cfg->interface[interface])\n\
    +\t\t\t\t\tbreak;\n \t\t\t\tbuf[6] = w_index;\n \t\t\t\tcount = count_ext_prop(os_desc_cfg,\n\
    \ \t\t\t\t\tinterface);"
  identifiers:
  - CVE-2022-25258
  - CWE-476
  overview: An issue was discovered in drivers/usb/gadget/composite.c in the Linux
    kernel before 5.16.10. The USB Gadget subsystem lacks certain validation of interface
    OS descriptor requests (ones with a large array index and ones associated with
    NULL function pointer retrieval). Memory corruption might occur.
  references:
  - source: cve@mitre.org
    tags:
    - Release Notes
    - Vendor Advisory
    url: https://cdn.kernel.org/pub/linux/kernel/v5.x/ChangeLog-5.16.10
  - source: cve@mitre.org
    tags:
    - Issue Tracking
    - Third Party Advisory
    url: https://github.com/szymonh/d-os-descriptor
  - source: cve@mitre.org
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/torvalds/linux/commit/75e5b4849b81e19e9efe1654b30d7f3151c33c2c
  - source: cve@mitre.org
    tags:
    - Mailing List
    - Third Party Advisory
    url: https://lists.debian.org/debian-lts-announce/2022/03/msg00011.html
  - source: cve@mitre.org
    tags:
    - Mailing List
    - Third Party Advisory
    url: https://lists.debian.org/debian-lts-announce/2022/03/msg00012.html
  - source: cve@mitre.org
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/TCW2KZYJ2H6BKZE3CVLHRIXYDGNYYC5P/
  - source: cve@mitre.org
    tags:
    - Third Party Advisory
    url: https://security.netapp.com/advisory/ntap-20221028-0007/
  - source: cve@mitre.org
    tags:
    - Third Party Advisory
    url: https://www.debian.org/security/2022/dsa-5092
  - source: cve@mitre.org
    tags:
    - Third Party Advisory
    url: https://www.debian.org/security/2022/dsa-5096
  title: An issue was discovered in drivers/usb/gadget/composite.c in the Linux kernel
    before 5.16.10. The USB Gadget subsystem lacks certain validation of interface
    OS descriptor requests (ones with a large array index and ones associated with
    NULL function pointer retrieval). Memory corruption might occur.
- diff_content:
  - "--- a/src/vm.c\n+++ b/src/vm.c\n@@ -2766,7 +2766,7 @@ mrb_vm_exec(mrb_state *mrb,\
    \ const struct RProc *proc, const mrb_code *pc)\n       int lim = a+b*2+1;\n \n\
    \       hash = regs[a];\n-      mrb_assert(mrb_hash_p(hash));\n+      mrb_ensure_hash_type(mrb,\
    \ hash);\n       for (i=a+1; i<lim; i+=2) {\n         mrb_hash_set(mrb, hash,\
    \ regs[i], regs[i+1]);\n       }"
  identifiers:
  - CVE-2022-0623
  - CWE-125
  overview: Out-of-bounds Read in Homebrew mruby prior to 3.2.
  references:
  - source: security@huntr.dev
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/mruby/mruby/commit/ff3a5ebed6ffbe3e70481531cfb969b497aa73ad
  - source: security@huntr.dev
    tags:
    - Exploit
    - Patch
    - Third Party Advisory
    url: https://huntr.dev/bounties/5b908ac7-d8f1-4fcd-9355-85df565f7580
  title: Out-of-bounds Read in Homebrew mruby prior to 3.2.
- diff_content:
  - "--- a/src/testing.c\n+++ b/src/testing.c\n@@ -101,7 +101,7 @@ ga_concat_shorten_esc(garray_T\
    \ *gap, char_u *str)\n     {\n \tsame_len = 1;\n \ts = p;\n-\tc = mb_ptr2char_adv(&s);\n\
    +\tc = mb_cptr2char_adv(&s);\n \tclen = s - p;\n \twhile (*s != NUL && c == mb_ptr2char(s))\n\
    \ \t{"
  - "--- a/src/version.c\n+++ b/src/version.c\n@@ -750,6 +750,8 @@ static char *(features[])\
    \ =\n \n static int included_patches[] =\n {   /* Add new patch number below this\
    \ line */\n+/**/\n+    4397,\n /**/\n     4396,\n /**/"
  identifiers:
  - CVE-2022-0629
  - CWE-121
  overview: Stack-based Buffer Overflow in GitHub repository vim/vim prior to 8.2.
  references:
  - source: security@huntr.dev
    tags:
    - Mailing List
    - Third Party Advisory
    url: http://seclists.org/fulldisclosure/2022/Oct/28
  - source: security@huntr.dev
    tags:
    - Mailing List
    - Release Notes
    - Third Party Advisory
    url: http://seclists.org/fulldisclosure/2022/Oct/41
  - source: security@huntr.dev
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/vim/vim/commit/34f8117dec685ace52cd9e578e2729db278163fc
  - source: security@huntr.dev
    tags:
    - Exploit
    - Patch
    - Third Party Advisory
    url: https://huntr.dev/bounties/95e2b0da-e480-4ee8-9324-a93a2ab0a877
  - source: security@huntr.dev
    tags:
    - Third Party Advisory
    url: https://lists.debian.org/debian-lts-announce/2022/11/msg00032.html
  - source: security@huntr.dev
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/7ZLEHVP4LNAGER4ZDGUDS5V5YVQD6INF/
  - source: security@huntr.dev
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/UURGABNDL77YR5FRQKTFBYNBDQX2KO7Q/
  - source: security@huntr.dev
    tags:
    - Third Party Advisory
    url: https://security.gentoo.org/glsa/202208-32
  - source: security@huntr.dev
    tags:
    - Release Notes
    - Third Party Advisory
    url: https://support.apple.com/kb/HT213488
  title: Stack-based Buffer Overflow in GitHub repository vim/vim prior to 8.2.
- diff_content:
  - "--- a/mongoose.c\n+++ b/mongoose.c\n@@ -1142,34 +1142,6 @@ char *mg_http_etag(char\
    \ *buf, size_t len, size_t size, time_t mtime) {\n   return buf;\n }\n \n-#if\
    \ MG_ENABLE_FILE\n-int mg_http_upload(struct mg_connection *c, struct mg_http_message\
    \ *hm,\n-                   const char *dir) {\n-  char offset[40] = \"\", name[200]\
    \ = \"\", path[256];\n-  mg_http_get_var(&hm->query, \"offset\", offset, sizeof(offset));\n\
    -  mg_http_get_var(&hm->query, \"name\", name, sizeof(name));\n-  if (name[0]\
    \ == '\\0') {\n-    mg_http_reply(c, 400, \"\", \"%s\", \"name required\");\n\
    -    return -1;\n-  } else {\n-    FILE *fp;\n-    size_t oft = strtoul(offset,\
    \ NULL, 0);\n-    snprintf(path, sizeof(path), \"%s%c%s\", dir, MG_DIRSEP, name);\n\
    -    LOG(LL_DEBUG,\n-        (\"%p %d bytes @ %d [%s]\", c->fd, (int) hm->body.len,\
    \ (int) oft, name));\n-    if ((fp = fopen(path, oft == 0 ? \"wb\" : \"ab\"))\
    \ == NULL) {\n-      mg_http_reply(c, 400, \"\", \"fopen(%s): %d\", name, errno);\n\
    -      return -2;\n-    } else {\n-      fwrite(hm->body.ptr, 1, hm->body.len,\
    \ fp);\n-      fclose(fp);\n-      mg_http_reply(c, 200, \"\", \"\");\n-     \
    \ return (int) hm->body.len;\n-    }\n-  }\n-}\n-#endif\n-\n static void static_cb(struct\
    \ mg_connection *c, int ev, void *ev_data,\n                       void *fn_data)\
    \ {\n   if (ev == MG_EV_WRITE || ev == MG_EV_POLL) {\n@@ -1680,6 +1652,34 @@ void\
    \ mg_http_delete_chunk(struct mg_connection *c, struct mg_http_message *hm) {\n\
    \   c->recv.len -= ch.len;\n }\n \n+#if MG_ENABLE_FILE\n+int mg_http_upload(struct\
    \ mg_connection *c, struct mg_http_message *hm,\n+                   const char\
    \ *dir) {\n+  char offset[40] = \"\", name[200] = \"\", path[256];\n+  mg_http_get_var(&hm->query,\
    \ \"offset\", offset, sizeof(offset));\n+  mg_http_get_var(&hm->query, \"name\"\
    , name, sizeof(name));\n+  if (name[0] == '\\0') {\n+    mg_http_reply(c, 400,\
    \ \"\", \"%s\", \"name required\");\n+    return -1;\n+  } else {\n+    FILE *fp;\n\
    +    long oft = strtol(offset, NULL, 0);\n+    snprintf(path, sizeof(path), \"\
    %s%c%s\", dir, MG_DIRSEP, name);\n+    remove_double_dots(path);\n+    LOG(LL_DEBUG,\
    \ (\"%d bytes @ %ld [%s]\", (int) hm->body.len, oft, path));\n+    if ((fp = fopen(path,\
    \ oft == 0 ? \"wb\" : \"ab\")) == NULL) {\n+      mg_http_reply(c, 400, \"\",\
    \ \"fopen(%s): %d\", path, errno);\n+      return -2;\n+    } else {\n+      fwrite(hm->body.ptr,\
    \ 1, hm->body.len, fp);\n+      fclose(fp);\n+      mg_http_reply(c, 200, \"\"\
    , \"\");\n+      return (int) hm->body.len;\n+    }\n+  }\n+}\n+#endif\n+\n static\
    \ void http_cb(struct mg_connection *c, int ev, void *evd, void *fnd) {\n   if\
    \ (ev == MG_EV_READ || ev == MG_EV_CLOSE) {\n     struct mg_http_message hm;"
  - "--- a/src/http.c\n+++ b/src/http.c\n@@ -378,34 +378,6 @@ char *mg_http_etag(char\
    \ *buf, size_t len, size_t size, time_t mtime) {\n   return buf;\n }\n \n-#if\
    \ MG_ENABLE_FILE\n-int mg_http_upload(struct mg_connection *c, struct mg_http_message\
    \ *hm,\n-                   const char *dir) {\n-  char offset[40] = \"\", name[200]\
    \ = \"\", path[256];\n-  mg_http_get_var(&hm->query, \"offset\", offset, sizeof(offset));\n\
    -  mg_http_get_var(&hm->query, \"name\", name, sizeof(name));\n-  if (name[0]\
    \ == '\\0') {\n-    mg_http_reply(c, 400, \"\", \"%s\", \"name required\");\n\
    -    return -1;\n-  } else {\n-    FILE *fp;\n-    size_t oft = strtoul(offset,\
    \ NULL, 0);\n-    snprintf(path, sizeof(path), \"%s%c%s\", dir, MG_DIRSEP, name);\n\
    -    LOG(LL_DEBUG,\n-        (\"%p %d bytes @ %d [%s]\", c->fd, (int) hm->body.len,\
    \ (int) oft, name));\n-    if ((fp = fopen(path, oft == 0 ? \"wb\" : \"ab\"))\
    \ == NULL) {\n-      mg_http_reply(c, 400, \"\", \"fopen(%s): %d\", name, errno);\n\
    -      return -2;\n-    } else {\n-      fwrite(hm->body.ptr, 1, hm->body.len,\
    \ fp);\n-      fclose(fp);\n-      mg_http_reply(c, 200, \"\", \"\");\n-     \
    \ return (int) hm->body.len;\n-    }\n-  }\n-}\n-#endif\n-\n static void static_cb(struct\
    \ mg_connection *c, int ev, void *ev_data,\n                       void *fn_data)\
    \ {\n   if (ev == MG_EV_WRITE || ev == MG_EV_POLL) {\n@@ -916,6 +888,34 @@ void\
    \ mg_http_delete_chunk(struct mg_connection *c, struct mg_http_message *hm) {\n\
    \   c->recv.len -= ch.len;\n }\n \n+#if MG_ENABLE_FILE\n+int mg_http_upload(struct\
    \ mg_connection *c, struct mg_http_message *hm,\n+                   const char\
    \ *dir) {\n+  char offset[40] = \"\", name[200] = \"\", path[256];\n+  mg_http_get_var(&hm->query,\
    \ \"offset\", offset, sizeof(offset));\n+  mg_http_get_var(&hm->query, \"name\"\
    , name, sizeof(name));\n+  if (name[0] == '\\0') {\n+    mg_http_reply(c, 400,\
    \ \"\", \"%s\", \"name required\");\n+    return -1;\n+  } else {\n+    FILE *fp;\n\
    +    long oft = strtol(offset, NULL, 0);\n+    snprintf(path, sizeof(path), \"\
    %s%c%s\", dir, MG_DIRSEP, name);\n+    remove_double_dots(path);\n+    LOG(LL_DEBUG,\
    \ (\"%d bytes @ %ld [%s]\", (int) hm->body.len, oft, path));\n+    if ((fp = fopen(path,\
    \ oft == 0 ? \"wb\" : \"ab\")) == NULL) {\n+      mg_http_reply(c, 400, \"\",\
    \ \"fopen(%s): %d\", path, errno);\n+      return -2;\n+    } else {\n+      fwrite(hm->body.ptr,\
    \ 1, hm->body.len, fp);\n+      fclose(fp);\n+      mg_http_reply(c, 200, \"\"\
    , \"\");\n+      return (int) hm->body.len;\n+    }\n+  }\n+}\n+#endif\n+\n static\
    \ void http_cb(struct mg_connection *c, int ev, void *evd, void *fnd) {\n   if\
    \ (ev == MG_EV_READ || ev == MG_EV_CLOSE) {\n     struct mg_http_message hm;"
  - "--- a/test/unit_test.c\n+++ b/test/unit_test.c\n@@ -698,6 +697,21 @@ static void\
    \ test_http_server(void) {\n     remove(\"uploaded.txt\");\n   }\n \n+  {\n+ \
    \   // Test upload directory traversal\n+    char *p;\n+    remove(\"uploaded.txt\"\
    );\n+    ASSERT((p = mg_file_read(\"uploaded.txt\", NULL)) == NULL);\n+    ASSERT(fetch(&mgr,\
    \ buf, url,\n+                 \"POST /upload?name=../uploaded.txt HTTP/1.0\\\
    r\\n\"\n+                 \"Content-Length: 5\\r\\n\"\n+                 \"\\\
    r\\nhello\") == 200);\n+    ASSERT((p = mg_file_read(\"uploaded.txt\", NULL))\
    \ != NULL);\n+    ASSERT(strcmp(p, \"hello\") == 0);\n+    free(p);\n+    remove(\"\
    uploaded.txt\");\n+  }\n+\n   // HEAD request\n   ASSERT(fetch(&mgr, buf, url,\
    \ \"GET /a.txt HTTP/1.0\\n\\n\") == 200);\n   ASSERT(fetch(&mgr, buf, url, \"\
    HEAD /a.txt HTTP/1.0\\n\\n\") == 200);"
  identifiers:
  - CVE-2022-25299
  - CWE-552
  overview: This affects the package cesanta/mongoose before 7.6. The unsafe handling
    of file names during upload using mg_http_upload() method may enable attackers
    to write files to arbitrary locations outside the designated target folder.
  references:
  - source: report@snyk.io
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/cesanta/mongoose/commit/c65c8fdaaa257e0487ab0aaae9e8f6b439335945
  - source: report@snyk.io
    tags:
    - Exploit
    - Third Party Advisory
    url: https://snyk.io/vuln/SNYK-UNMANAGED-CESANTAMONGOOSE-2404180
  title: This affects the package cesanta/mongoose before 7.6. The unsafe handling
    of file names during upload using mg_http_upload() method may enable attackers
    to write files to arbitrary locations outside the designated target folder.
- diff_content:
  - "--- a/src/vm.c\n+++ b/src/vm.c\n@@ -689,9 +689,11 @@ mrb_f_send(mrb_state *mrb,\
    \ mrb_value self)\n   regs = mrb->c->ci->stack+1;\n \n   if (n == 0) {\n+  argnum_error:\n\
    \     mrb_argnum_error(mrb, 0, 1, -1);\n   }\n   else if (n == 15) {\n+    if\
    \ (RARRAY_LEN(regs[0]) == 0) goto argnum_error;\n     name = mrb_obj_to_sym(mrb,\
    \ RARRAY_PTR(regs[0])[0]);\n   }\n   else {"
  identifiers:
  - CVE-2022-0631
  - CWE-122
  overview: Heap-based Buffer Overflow in Homebrew mruby prior to 3.2.
  references:
  - source: security@huntr.dev
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/mruby/mruby/commit/47068ae07a5fa3aa9a1879cdfe98a9ce0f339299
  - source: security@huntr.dev
    tags:
    - Exploit
    - Patch
    - Third Party Advisory
    url: https://huntr.dev/bounties/9bdc49ca-6697-4adc-a785-081e1961bf40
  title: Heap-based Buffer Overflow in Homebrew mruby prior to 3.2.
- diff_content:
  - "--- a/src/swtpm/swtpm_nvstore.c\n+++ b/src/swtpm/swtpm_nvstore.c\n@@ -1075,6\
    \ +1075,7 @@ SWTPM_NVRAM_CheckHeader(unsigned char *data, uint32_t length,\n \
    \                        uint8_t *hdrversion, bool quiet)\n {\n     blobheader\
    \ *bh = (blobheader *)data;\n+    uint16_t hdrsize;\n \n     if (length < sizeof(bh))\
    \ {\n         if (!quiet)\n@@ -1100,8 +1101,16 @@ SWTPM_NVRAM_CheckHeader(unsigned\
    \ char *data, uint32_t length,\n         return TPM_BAD_VERSION;\n     }\n \n\
    +    hdrsize = ntohs(bh->hdrsize);\n+    if (hdrsize != sizeof(blobheader)) {\n\
    +        logprintf(STDERR_FILENO,\n+                  \"bad header size: %u !=\
    \ %zu\\n\",\n+                  hdrsize, sizeof(blobheader));\n+        return\
    \ TPM_BAD_DATASIZE;\n+    }\n+\n     *hdrversion = bh->version;\n-    *dataoffset\
    \ = ntohs(bh->hdrsize);\n+    *dataoffset = hdrsize;\n     *hdrflags = ntohs(bh->flags);\n\
    \ \n     return TPM_SUCCESS;"
  identifiers:
  - CVE-2022-23645
  - CWE-125
  overview: swtpm is a libtpms-based TPM emulator with socket, character device, and
    Linux CUSE interface. Versions prior to 0.5.3, 0.6.2, and 0.7.1 are vulnerable
    to out-of-bounds read. A specially crafted header of swtpm's state, where the
    blobheader's hdrsize indicator has an invalid value, may cause an out-of-bounds
    access when the byte array representing the state of the TPM is accessed. This
    will likely crash swtpm or prevent it from starting since the state cannot be
    understood. Users should upgrade to swtpm v0.5.3, v0.6.2, or v0.7.1 to receive
    a patch. There are currently no known workarounds.
  references:
  - source: security-advisories@github.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/stefanberger/swtpm/commit/9f740868fc36761de27df3935513bdebf8852d19
  - source: security-advisories@github.com
    tags:
    - Release Notes
    - Third Party Advisory
    url: https://github.com/stefanberger/swtpm/releases/tag/v0.5.3
  - source: security-advisories@github.com
    tags:
    - Release Notes
    - Third Party Advisory
    url: https://github.com/stefanberger/swtpm/releases/tag/v0.6.2
  - source: security-advisories@github.com
    tags:
    - Release Notes
    - Third Party Advisory
    url: https://github.com/stefanberger/swtpm/releases/tag/v0.7.1
  - source: security-advisories@github.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/stefanberger/swtpm/security/advisories/GHSA-2qgm-8xf4-3hqw
  - source: security-advisories@github.com
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/WL735FW266GO4C2JX4CJBOIOB7R7AY5A/
  title: swtpm is a libtpms-based TPM emulator with socket, character device, and
    Linux CUSE interface. Versions prior to 0.5.3, 0.6.2, and 0.7.1 are vulnerable
    to out-of-bounds read. A specially crafted header of swtpm's state, where the
    blobheader's hdrsize indicator has an invalid value, may cause an out-of-bounds
    access when the byte array representing the state of the TPM is accessed. This
    will likely crash swtpm or prevent it from starting since the state cannot be
    understood. Users should upgrade to swtpm v0.5.3, v0.6.2, or v0.7.1 to receive
    a patch. There are currently no known workarounds.
- diff_content:
  - "--- a/src/vm.c\n+++ b/src/vm.c\n@@ -2766,7 +2766,7 @@ mrb_vm_exec(mrb_state *mrb,\
    \ const struct RProc *proc, const mrb_code *pc)\n       int lim = a+b*2+1;\n \n\
    \       hash = regs[a];\n-      mrb_assert(mrb_hash_p(hash));\n+      mrb_ensure_hash_type(mrb,\
    \ hash);\n       for (i=a+1; i<lim; i+=2) {\n         mrb_hash_set(mrb, hash,\
    \ regs[i], regs[i+1]);\n       }"
  identifiers:
  - CVE-2022-0630
  - CWE-125
  overview: Out-of-bounds Read in Homebrew mruby prior to 3.2.
  references:
  - source: security@huntr.dev
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/mruby/mruby/commit/ff3a5ebed6ffbe3e70481531cfb969b497aa73ad
  - source: security@huntr.dev
    tags:
    - Exploit
    - Patch
    - Third Party Advisory
    url: https://huntr.dev/bounties/f7cdd680-1a7f-4992-b4b8-44b5e4ba3e32
  title: Out-of-bounds Read in Homebrew mruby prior to 3.2.
- diff_content:
  - "--- a/mrbgems/mruby-compiler/core/codegen.c\n+++ b/mrbgems/mruby-compiler/core/codegen.c\n\
    @@ -2954,19 +2954,20 @@ codegen(codegen_scope *s, node *tree, int val)\n     \
    \    if (tree->cdr->cdr) {\n           codegen(s, tree->cdr->cdr, VAL);\n    \
    \     }\n-        else if (!s2) {/* super at top-level */\n-          push();\
    \      /* no need to push block */\n-        }\n+        else if (s2) gen_blkmove(s,\
    \ s2->ainfo, lv);\n         else {\n-          gen_blkmove(s, s2->ainfo, lv);\n\
    +          genop_1(s, OP_LOADNIL, cursp());\n+          push();\n         }\n\
    -        st++;\n       }\n       else {\n-        if (!s2) push();\n-        else\
    \ gen_blkmove(s, s2->ainfo, lv);\n-        st++;\n+        if (s2) gen_blkmove(s,\
    \ s2->ainfo, lv);\n+        else {\n+          genop_1(s, OP_LOADNIL, cursp());\n\
    +          push();\n+        }\n       }\n+      st++;\n       pop_n(st+1);\n\
    \       genop_2(s, OP_SUPER, cursp(), n);\n       if (val) push();\n@@ -3218,6\
    \ +3219,7 @@ codegen(codegen_scope *s, node *tree, int val)\n         codegen_error(s,\
    \ \"no anonymous block argument\");\n       }\n       gen_move(s, cursp(), idx,\
    \ val);\n+      if (val) push();\n     }\n     else {\n       codegen(s, tree,\
    \ val);"
  identifiers:
  - CVE-2022-0632
  - CWE-476
  overview: NULL Pointer Dereference in Homebrew mruby prior to 3.2.
  references:
  - source: security@huntr.dev
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/mruby/mruby/commit/44f591aa8f7091e6ca6cb418e428ae6d4ceaf77d
  - source: security@huntr.dev
    tags:
    - Exploit
    - Patch
    - Third Party Advisory
    url: https://huntr.dev/bounties/3e5bb8f6-30fd-4553-86dd-761e9459ce1b
  title: NULL Pointer Dereference in Homebrew mruby prior to 3.2.
- diff_content:
  - "--- a/src/charset.c\n+++ b/src/charset.c\n@@ -1644,6 +1644,12 @@ vim_isupper(int\
    \ c)\n     return isupper(c);\n }\n \n+    int\n+vim_isalpha(int c)\n+{\n+   \
    \ return vim_islower(c) || vim_isupper(c);\n+}\n+\n     int\n vim_toupper(int\
    \ c)\n {"
  - "--- a/src/filepath.c\n+++ b/src/filepath.c\n@@ -3626,7 +3626,7 @@ unix_expandpath(\n\
    \ \telse if (path_end >= path + wildoff\n \t\t\t && (vim_strchr((char_u *)\"*?[{~$\"\
    , *path_end) != NULL\n \t\t\t     || (!p_fic && (flags & EW_ICASE)\n-\t\t\t\t\t\
    \     && isalpha(PTR2CHAR(path_end)))))\n+\t\t\t\t\t  && vim_isalpha(PTR2CHAR(path_end)))))\n\
    \ \t    e = p;\n \tif (has_mbyte)\n \t{"
  - "--- a/src/version.c\n+++ b/src/version.c\n@@ -750,6 +750,8 @@ static char *(features[])\
    \ =\n \n static int included_patches[] =\n {   /* Add new patch number below this\
    \ line */\n+/**/\n+    4418,\n /**/\n     4417,\n /**/"
  identifiers:
  - CVE-2022-0685
  - CWE-823
  overview: Use of Out-of-range Pointer Offset in GitHub repository vim/vim prior
    to 8.2.4418.
  references:
  - source: security@huntr.dev
    tags:
    - Mailing List
    - Third Party Advisory
    url: http://seclists.org/fulldisclosure/2022/Oct/28
  - source: security@huntr.dev
    tags:
    - Mailing List
    - Release Notes
    - Third Party Advisory
    url: http://seclists.org/fulldisclosure/2022/Oct/41
  - source: security@huntr.dev
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/vim/vim/commit/5921aeb5741fc6e84c870d68c7c35b93ad0c9f87
  - source: security@huntr.dev
    tags:
    - Exploit
    - Patch
    - Third Party Advisory
    url: https://huntr.dev/bounties/27230da3-9b1a-4d5d-8cdf-4b1e62fcd782
  - source: security@huntr.dev
    tags:
    - Mailing List
    - Third Party Advisory
    url: https://lists.debian.org/debian-lts-announce/2022/03/msg00018.html
  - source: security@huntr.dev
    tags:
    - Mailing List
    - Third Party Advisory
    url: https://lists.debian.org/debian-lts-announce/2022/11/msg00009.html
  - source: security@huntr.dev
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/7ZLEHVP4LNAGER4ZDGUDS5V5YVQD6INF/
  - source: security@huntr.dev
    tags:
    - Third Party Advisory
    url: https://security.gentoo.org/glsa/202208-32
  - source: security@huntr.dev
    tags:
    - Release Notes
    - Third Party Advisory
    url: https://support.apple.com/kb/HT213488
  title: Use of Out-of-range Pointer Offset in GitHub repository vim/vim prior to
    8.2.4418.
- diff_content:
  - "--- a/drivers/usb/gadget/function/rndis.c\n+++ b/drivers/usb/gadget/function/rndis.c\n\
    @@ -637,14 +637,17 @@ static int rndis_set_response(struct rndis_params *params,\n\
    \ \trndis_set_cmplt_type *resp;\n \trndis_resp_t *r;\n \n+\tBufLength = le32_to_cpu(buf->InformationBufferLength);\n\
    +\tBufOffset = le32_to_cpu(buf->InformationBufferOffset);\n+\tif ((BufLength >\
    \ RNDIS_MAX_TOTAL_SIZE) ||\n+\t    (BufOffset + 8 >= RNDIS_MAX_TOTAL_SIZE))\n\
    +\t\t    return -EINVAL;\n+\n \tr = rndis_add_response(params, sizeof(rndis_set_cmplt_type));\n\
    \ \tif (!r)\n \t\treturn -ENOMEM;\n \tresp = (rndis_set_cmplt_type *)r->buf;\n\
    \ \n-\tBufLength = le32_to_cpu(buf->InformationBufferLength);\n-\tBufOffset =\
    \ le32_to_cpu(buf->InformationBufferOffset);\n-\n #ifdef\tVERBOSE_DEBUG\n \tpr_debug(\"\
    %s: Length: %d\\n\", __func__, BufLength);\n \tpr_debug(\"%s: Offset: %d\\n\"\
    , __func__, BufOffset);"
  identifiers:
  - CVE-2022-25375
  - CWE-1284
  overview: An issue was discovered in drivers/usb/gadget/function/rndis.c in the
    Linux kernel before 5.16.10. The RNDIS USB gadget lacks validation of the size
    of the RNDIS_MSG_SET command. Attackers can obtain sensitive information from
    kernel memory.
  references:
  - source: cve@mitre.org
    tags:
    - Mailing List
    - Patch
    - Third Party Advisory
    url: http://www.openwall.com/lists/oss-security/2022/02/21/1
  - source: cve@mitre.org
    tags:
    - Patch
    - Release Notes
    - Vendor Advisory
    url: https://cdn.kernel.org/pub/linux/kernel/v5.x/ChangeLog-5.16.10
  - source: cve@mitre.org
    tags:
    - Third Party Advisory
    url: https://github.com/szymonh/rndis-co
  - source: cve@mitre.org
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/torvalds/linux/commit/38ea1eac7d88072bbffb630e2b3db83ca649b826
  - source: cve@mitre.org
    tags:
    - Mailing List
    - Third Party Advisory
    url: https://lists.debian.org/debian-lts-announce/2022/03/msg00011.html
  - source: cve@mitre.org
    tags:
    - Mailing List
    - Third Party Advisory
    url: https://lists.debian.org/debian-lts-announce/2022/03/msg00012.html
  - source: cve@mitre.org
    tags:
    - Third Party Advisory
    url: https://www.debian.org/security/2022/dsa-5092
  - source: cve@mitre.org
    tags:
    - Third Party Advisory
    url: https://www.debian.org/security/2022/dsa-5096
  title: An issue was discovered in drivers/usb/gadget/function/rndis.c in the Linux
    kernel before 5.16.10. The RNDIS USB gadget lacks validation of the size of the
    RNDIS_MSG_SET command. Attackers can obtain sensitive information from kernel
    memory.
- diff_content:
  - "--- a/src/evalvars.c\n+++ b/src/evalvars.c\n@@ -2199,12 +2199,7 @@ get_user_var_name(expand_T\
    \ *xp, int idx)\n     }\n \n     // b: variables\n-    ht =\n-#ifdef FEAT_CMDWIN\n\
    -\t// In cmdwin, the alternative buffer should be used.\n-\tis_in_cmdwin() ? &prevwin->w_buffer->b_vars->dv_hashtab\
    \ :\n-#endif\n-\t&curbuf->b_vars->dv_hashtab;\n+    ht = &prevwin_curwin()->w_buffer->b_vars->dv_hashtab;\n\
    \     if (bdone < ht->ht_used)\n     {\n \tif (bdone++ == 0)\n@@ -2217,12 +2212,7\
    \ @@ get_user_var_name(expand_T *xp, int idx)\n     }\n \n     // w: variables\n\
    -    ht =\n-#ifdef FEAT_CMDWIN\n-\t// In cmdwin, the alternative window should\
    \ be used.\n-\tis_in_cmdwin() ? &prevwin->w_vars->dv_hashtab :\n-#endif\n-\t&curwin->w_vars->dv_hashtab;\n\
    +    ht = &prevwin_curwin()->w_vars->dv_hashtab;\n     if (wdone < ht->ht_used)\n\
    \     {\n \tif (wdone++ == 0)"
  - "--- a/src/usercmd.c\n+++ b/src/usercmd.c\n@@ -141,11 +141,7 @@ find_ucmd(\n \
    \    /*\n      * Look for buffer-local user commands first, then global ones.\n\
    \      */\n-    gap =\n-#ifdef FEAT_CMDWIN\n-\tis_in_cmdwin() ? &prevwin->w_buffer->b_ucmds\
    \ :\n-#endif\n-\t&curbuf->b_ucmds;\n+    gap = &prevwin_curwin()->w_buffer->b_ucmds;\n\
    \     for (;;)\n     {\n \tfor (j = 0; j < gap->ga_len; ++j)\n@@ -358,11 +354,7\
    \ @@ expand_user_command_name(int idx)\n get_user_commands(expand_T *xp UNUSED,\
    \ int idx)\n {\n     // In cmdwin, the alternative buffer should be used.\n- \
    \   buf_T *buf =\n-#ifdef FEAT_CMDWIN\n-\tis_in_cmdwin() ? prevwin->w_buffer :\n\
    -#endif\n-\tcurbuf;\n+    buf_T *buf = prevwin_curwin()->w_buffer;\n \n     if\
    \ (idx < buf->b_ucmds.ga_len)\n \treturn USER_CMD_GA(&buf->b_ucmds, idx)->uc_name;\n\
    @@ -386,11 +378,7 @@ get_user_command_name(int idx, int cmdidx)\n     if (cmdidx\
    \ == CMD_USER_BUF)\n     {\n \t// In cmdwin, the alternative buffer should be\
    \ used.\n-\tbuf_T *buf =\n-#ifdef FEAT_CMDWIN\n-\t\t    is_in_cmdwin() ? prevwin->w_buffer\
    \ :\n-#endif\n-\t\t    curbuf;\n+\tbuf_T *buf = prevwin_curwin()->w_buffer;\n\
    \ \n \tif (idx < buf->b_ucmds.ga_len)\n \t    return USER_CMD_GA(&buf->b_ucmds,\
    \ idx)->uc_name;\n@@ -478,11 +466,7 @@ uc_list(char_u *name, size_t name_len)\n\
    \     garray_T\t*gap;\n \n     // In cmdwin, the alternative buffer should be\
    \ used.\n-    gap =\n-#ifdef FEAT_CMDWIN\n-\t    is_in_cmdwin() ? &prevwin->w_buffer->b_ucmds\
    \ :\n-#endif\n-\t    &curbuf->b_ucmds;\n+    gap = &prevwin_curwin()->w_buffer->b_ucmds;\n\
    \     for (;;)\n     {\n \tfor (i = 0; i < gap->ga_len; ++i)"
  - "--- a/src/version.c\n+++ b/src/version.c\n@@ -750,6 +750,8 @@ static char *(features[])\
    \ =\n \n static int included_patches[] =\n {   /* Add new patch number below this\
    \ line */\n+/**/\n+    4428,\n /**/\n     4427,\n /**/"
  - "--- a/src/window.c\n+++ b/src/window.c\n@@ -110,6 +110,21 @@ log_frame_layout(frame_T\
    \ *frame)\n }\n #endif\n \n+/*\n+ * Return the current window, unless in the cmdline\
    \ window and \"prevwin\" is\n+ * set, then return \"prevwin\".\n+ */\n+    win_T\
    \ *\n+prevwin_curwin(void)\n+{\n+    return\n+#ifdef FEAT_CMDWIN\n+\t// In cmdwin,\
    \ the alternative buffer should be used.\n+\tis_in_cmdwin() && prevwin != NULL\
    \ ? prevwin :\n+#endif\n+\tcurwin;\n+}\n+\n /*\n  * All CTRL-W window commands\
    \ are handled here, called from normal_cmd().\n  */\n@@ -3927,6 +3942,14 @@ win_new_tabpage(int\
    \ after)\n     tabpage_T\t*newtp;\n     int\t\tn;\n \n+#ifdef FEAT_CMDWIN\n+ \
    \   if (cmdwin_type != 0)\n+    {\n+\temsg(_(e_invalid_in_cmdline_window));\n\
    +\treturn FAIL;\n+    }\n+#endif\n+\n     newtp = alloc_tabpage();\n     if (newtp\
    \ == NULL)\n \treturn FAIL;\n@@ -4301,6 +4324,7 @@ goto_tabpage(int n)\n \ttext_locked_msg();\n\
    \ \treturn;\n     }\n+    CHECK_CMDWIN;\n \n     // If there is only one it can't\
    \ work.\n     if (first_tabpage->tp_next == NULL)\n@@ -4368,6 +4392,8 @@ goto_tabpage_tp(\n\
    \     int\t\ttrigger_enter_autocmds,\n     int\t\ttrigger_leave_autocmds)\n {\n\
    +    CHECK_CMDWIN;\n+\n     // Don't repeat a message in another tab page.\n \
    \    set_keep_msg(NULL, 0);\n "
  identifiers:
  - CVE-2022-0696
  - CWE-476
  overview: NULL Pointer Dereference in GitHub repository vim/vim prior to 8.2.4428.
  references:
  - source: security@huntr.dev
    tags:
    - Mailing List
    - Third Party Advisory
    url: http://seclists.org/fulldisclosure/2022/Oct/28
  - source: security@huntr.dev
    tags:
    - Mailing List
    - Release Notes
    - Third Party Advisory
    url: http://seclists.org/fulldisclosure/2022/Oct/41
  - source: security@huntr.dev
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/vim/vim/commit/0f6e28f686dbb59ab3b562408ab9b2234797b9b1
  - source: security@huntr.dev
    tags:
    - Exploit
    - Third Party Advisory
    url: https://huntr.dev/bounties/7416c2cb-1809-4834-8989-e84ff033f15f
  - source: security@huntr.dev
    tags:
    - Mailing List
    - Third Party Advisory
    url: https://lists.debian.org/debian-lts-announce/2022/11/msg00032.html
  - source: security@huntr.dev
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/7ZLEHVP4LNAGER4ZDGUDS5V5YVQD6INF/
  - source: security@huntr.dev
    tags:
    - Release Notes
    - Third Party Advisory
    url: https://support.apple.com/kb/HT213488
  title: NULL Pointer Dereference in GitHub repository vim/vim prior to 8.2.4428.
- diff_content:
  - "--- a/libr/bin/p/bin_dyldcache.c\n+++ b/libr/bin/p/bin_dyldcache.c\n@@ -1144,6\
    \ +1144,8 @@ static ut64 resolve_symbols_off(RDyldCache *cache, ut64 pa) {\n \n\
    \ static RList *create_cache_bins(RBinFile *bf, RDyldCache *cache) {\n \tRList\
    \ *bins = r_list_newf ((RListFree)free_bin);\n+\tut16 *depArray = NULL;\n+\tcache_imgxtr_t\
    \ *extras = NULL;\n \tif (!bins) {\n \t\treturn NULL;\n \t}\n@@ -1177,8 +1179,6\
    \ @@ static RList *create_cache_bins(RBinFile *bf, RDyldCache *cache) {\n \t\t\
    }\n \n \t\tut32 j;\n-\t\tut16 *depArray = NULL;\n-\t\tcache_imgxtr_t *extras =\
    \ NULL;\n \t\tif (target_libs) {\n \t\t\tHtPU *path_to_idx = NULL;\n \t\t\tif\
    \ (cache->accel) {\n@@ -1734,12 +1734,12 @@ static void populate_cache_maps(RDyldCache\
    \ *cache) {\n \tcache->n_maps = next_map;\n }\n \n-static cache_accel_t *read_cache_accel(RBuffer\
    \ *cache_buf, cache_hdr_t *hdr, cache_map_t *maps) {\n+static cache_accel_t *read_cache_accel(RBuffer\
    \ *cache_buf, cache_hdr_t *hdr, cache_map_t *maps, int n_maps) {\n \tif (!cache_buf\
    \ || !hdr || !hdr->accelerateInfoSize || !hdr->accelerateInfoAddr) {\n \t\treturn\
    \ NULL;\n \t}\n-\n-\tut64 offset = va2pa (hdr->accelerateInfoAddr, hdr->mappingCount,\
    \ maps, cache_buf, 0, NULL, NULL);\n+\tsize_t mc = R_MIN (hdr->mappingCount, n_maps);\n\
    +\tut64 offset = va2pa (hdr->accelerateInfoAddr, mc, maps, cache_buf, 0, NULL,\
    \ NULL);\n \tif (!offset) {\n \t\treturn NULL;\n \t}\n@@ -1895,7 +1895,7 @@ static\
    \ bool load_buffer(RBinFile *bf, void **bin_obj, RBuffer *buf, ut64 loadadd\n\
    \ \t\tr_dyldcache_free (cache);\n \t\treturn false;\n \t}\n-\tcache->accel = read_cache_accel\
    \ (cache->buf, cache->hdr, cache->maps);\n+\tcache->accel = read_cache_accel (cache->buf,\
    \ cache->hdr, cache->maps, cache->n_maps);\n \tcache->bins = create_cache_bins\
    \ (bf, cache);\n \tif (!cache->bins) {\n \t\tr_dyldcache_free (cache);"
  identifiers:
  - CVE-2022-0676
  - CWE-787
  overview: Heap-based Buffer Overflow in GitHub repository radareorg/radare2 prior
    to 5.6.4.
  references:
  - source: security@huntr.dev
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/radareorg/radare2/commit/c84b7232626badd075caf3ae29661b609164bac6
  - source: security@huntr.dev
    tags:
    - Exploit
    - Patch
    - Third Party Advisory
    url: https://huntr.dev/bounties/5ad814a1-5dd3-43f4-869b-33b8dab78485
  - source: security@huntr.dev
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/BZTIMAS53YT66FUS4QHQAFRJOBMUFG6D/
  - source: security@huntr.dev
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/E6YBRQ3UCFWJVSOYIKPVUDASZ544TFND/
  title: Heap-based Buffer Overflow in GitHub repository radareorg/radare2 prior to
    5.6.4.
- diff_content:
  - "--- a/libr/bin/p/bin_symbols.c\n+++ b/libr/bin/p/bin_symbols.c\n@@ -1,4 +1,4\
    \ @@\n-/* radare - LGPL - Copyright 2018 - pancake */\n+/* radare - LGPL - Copyright\
    \ 2018-2022 - pancake */\n \n #include <r_types.h>\n #include <r_util.h>\n@@ -361,6\
    \ +361,9 @@ static RList *symbols(RBinFile *bf) {\n \tbool found = false;\n \t\
    for (i = 0; i < element->hdr->n_lined_symbols; i++) {\n \t\tRCoreSymCacheElementSymbol\
    \ *sym = (RCoreSymCacheElementSymbol *)&element->lined_symbols[i];\n+\t\tif (!sym)\
    \ {\n+\t\t\tbreak;\n+\t\t}\n \t\tht_uu_find (hash, sym->paddr, &found);\n \t\t\
    if (found) {\n \t\t\tcontinue;"
  identifiers:
  - CVE-2022-0712
  - CWE-476
  overview: NULL Pointer Dereference in GitHub repository radareorg/radare2 prior
    to 5.6.4.
  references:
  - source: security@huntr.dev
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/radareorg/radare2/commit/515e592b9bea0612bc63d8e93239ff35bcf645c7
  - source: security@huntr.dev
    tags:
    - Exploit
    - Patch
    - Third Party Advisory
    url: https://huntr.dev/bounties/1e572820-e502-49d1-af0e-81833e2eb466
  - source: security@huntr.dev
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/BZTIMAS53YT66FUS4QHQAFRJOBMUFG6D/
  - source: security@huntr.dev
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/E6YBRQ3UCFWJVSOYIKPVUDASZ544TFND/
  title: NULL Pointer Dereference in GitHub repository radareorg/radare2 prior to
    5.6.4.
- diff_content:
  - "--- a/libr/bin/format/mach0/coresymbolication.c\n+++ b/libr/bin/format/mach0/coresymbolication.c\n\
    @@ -222,7 +222,7 @@ RCoreSymCacheElement *r_coresym_cache_element_new(RBinFile\
    \ *bf, RBuffer *buf, ut\n \t\t}\n \t\tsize_t i;\n \t\tut8 *cursor = b + R_CS_EL_OFF_SEGS;\n\
    -\t\tfor (i = 0; i < hdr->n_segments && cursor < end; i++) {\n+\t\tfor (i = 0;\
    \ i < hdr->n_segments && cursor + sizeof (RCoreSymCacheElementSegment) < end;\
    \ i++) {\n \t\t\tRCoreSymCacheElementSegment *seg = &result->segments[i];\n \t\
    \t\tseg->paddr = seg->vaddr = r_read_le64 (cursor);\n \t\t\tcursor += 8;"
  identifiers:
  - CVE-2022-0713
  - CWE-787
  overview: Heap-based Buffer Overflow in GitHub repository radareorg/radare2 prior
    to 5.6.4.
  references:
  - source: security@huntr.dev
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/radareorg/radare2/commit/a35f89f86ed12161af09330e92e5a213014e46a1
  - source: security@huntr.dev
    tags:
    - Exploit
    - Patch
    - Third Party Advisory
    url: https://huntr.dev/bounties/d35b3dff-768d-4a09-a742-c18ca8f56d3c
  - source: security@huntr.dev
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/BZTIMAS53YT66FUS4QHQAFRJOBMUFG6D/
  - source: security@huntr.dev
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/E6YBRQ3UCFWJVSOYIKPVUDASZ544TFND/
  title: Heap-based Buffer Overflow in GitHub repository radareorg/radare2 prior to
    5.6.4.
- diff_content:
  - "--- a/src/indent.c\n+++ b/src/indent.c\n@@ -1338,6 +1338,8 @@ change_indent(\n\
    \ \t\tnew_cursor_col += (*mb_ptr2len)(ptr + new_cursor_col);\n \t    else\n \t\
    \t++new_cursor_col;\n+\t    if (ptr[new_cursor_col] == NUL)\n+\t\tbreak;\n \t\
    \    vcol += lbr_chartabsize(ptr, ptr + new_cursor_col, (colnr_T)vcol);\n \t}\n\
    \ \tvcol = last_vcol;"
  - "--- a/src/version.c\n+++ b/src/version.c\n@@ -750,6 +750,8 @@ static char *(features[])\
    \ =\n \n static int included_patches[] =\n {   /* Add new patch number below this\
    \ line */\n+/**/\n+    4436,\n /**/\n     4435,\n /**/"
  identifiers:
  - CVE-2022-0714
  - CWE-122
  overview: Heap-based Buffer Overflow in GitHub repository vim/vim prior to 8.2.4436.
  references:
  - source: security@huntr.dev
    tags:
    - Mailing List
    - Third Party Advisory
    url: http://seclists.org/fulldisclosure/2022/Oct/28
  - source: security@huntr.dev
    tags:
    - Mailing List
    - Release Notes
    - Third Party Advisory
    url: http://seclists.org/fulldisclosure/2022/Oct/41
  - source: security@huntr.dev
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/vim/vim/commit/4e889f98e95ac05d7c8bd3ee933ab4d47820fdfa
  - source: security@huntr.dev
    tags:
    - Exploit
    - Third Party Advisory
    url: https://huntr.dev/bounties/db70e8db-f309-4f3c-986c-e69d2415c3b3
  - source: security@huntr.dev
    tags:
    - Mailing List
    - Third Party Advisory
    url: https://lists.debian.org/debian-lts-announce/2022/03/msg00018.html
  - source: security@huntr.dev
    tags:
    - Third Party Advisory
    url: https://lists.debian.org/debian-lts-announce/2022/11/msg00009.html
  - source: security@huntr.dev
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/7ZLEHVP4LNAGER4ZDGUDS5V5YVQD6INF/
  - source: security@huntr.dev
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/HBUYQBZ6GWAWJRWP7AODJ4KHW5BCKDVP/
  - source: security@huntr.dev
    tags:
    - Third Party Advisory
    url: https://security.gentoo.org/glsa/202208-32
  - source: security@huntr.dev
    tags:
    - Release Notes
    - Third Party Advisory
    url: https://support.apple.com/kb/HT213488
  title: Heap-based Buffer Overflow in GitHub repository vim/vim prior to 8.2.4436.
- diff_content:
  - "--- a/pjsip/src/pjsip/sip_ua_layer.c\n+++ b/pjsip/src/pjsip/sip_ua_layer.c\n\
    @@ -65,6 +65,9 @@ struct dlg_set\n     /* This is the buffer to store this entry\
    \ in the hash table. */\n     pj_hash_entry_buf ht_entry;\n \n+    /* Entry key\
    \ in the hash table */\n+    pj_str_t ht_key;\n+\n     /* List of dialog in this\
    \ dialog set. */\n     struct dlg_set_head  dlg_list;\n };\n@@ -327,15 +330,16\
    \ @@ PJ_DEF(pj_status_t) pjsip_ua_register_dlg( pjsip_user_agent *ua,\n \t   \
    \  * Create the dialog set and add this dialog to it.\n \t     */\n \t    dlg_set\
    \ = alloc_dlgset_node();\n+\t    dlg_set->ht_key = dlg->local.info->tag;\n \t\
    \    pj_list_init(&dlg_set->dlg_list);\n \t    pj_list_push_back(&dlg_set->dlg_list,\
    \ dlg);\n \n \t    dlg->dlg_set = dlg_set;\n \n \t    /* Register the dialog set\
    \ in the hash table. */\n \t    pj_hash_set_np_lower(mod_ua.dlg_table, \n-\t\t\
    \t         dlg->local.info->tag.ptr,\n-                                 (unsigned)dlg->local.info->tag.slen,\n\
    +\t\t\t         dlg_set->ht_key.ptr,\n+                                 (unsigned)dlg_set->ht_key.slen,\n\
    \ \t\t\t         dlg->local.tag_hval, dlg_set->ht_entry,\n                   \
    \               dlg_set);\n \t}\n@@ -345,14 +349,15 @@ PJ_DEF(pj_status_t) pjsip_ua_register_dlg(\
    \ pjsip_user_agent *ua,\n \tstruct dlg_set *dlg_set;\n \n \tdlg_set = alloc_dlgset_node();\n\
    +\tdlg_set->ht_key = dlg->local.info->tag;\n \tpj_list_init(&dlg_set->dlg_list);\n\
    \ \tpj_list_push_back(&dlg_set->dlg_list, dlg);\n \n \tdlg->dlg_set = dlg_set;\n\
    \ \n \tpj_hash_set_np_lower(mod_ua.dlg_table, \n-\t\t             dlg->local.info->tag.ptr,\n\
    -                             (unsigned)dlg->local.info->tag.slen,\n+\t\t    \
    \         dlg_set->ht_key.ptr,\n+                             (unsigned)dlg_set->ht_key.slen,\n\
    \ \t\t             dlg->local.tag_hval, dlg_set->ht_entry, dlg_set);\n     }\n\
    \ \n@@ -397,12 +402,43 @@ PJ_DEF(pj_status_t) pjsip_ua_unregister_dlg( pjsip_user_agent\
    \ *ua,\n \n     /* If dialog list is empty, remove the dialog set from the hash\
    \ table. */\n     if (pj_list_empty(&dlg_set->dlg_list)) {\n-\tpj_hash_set_lower(NULL,\
    \ mod_ua.dlg_table, dlg->local.info->tag.ptr,\n-\t\t          (unsigned)dlg->local.info->tag.slen,\
    \ \n+\n+\t/* Verify that the dialog set is valid */\n+\tpj_assert(pj_hash_get_lower(mod_ua.dlg_table,\
    \ dlg_set->ht_key.ptr,\n+\t\t\t\t    (unsigned)dlg_set->ht_key.slen,\n+\t\t\t\t\
    \    &dlg->local.tag_hval) == dlg_set);\n+\n+\tpj_hash_set_lower(NULL, mod_ua.dlg_table,\
    \ dlg_set->ht_key.ptr,\n+\t\t          (unsigned)dlg_set->ht_key.slen,\n \t\t\t\
    \  dlg->local.tag_hval, NULL);\n \n \t/* Return dlg_set to free nodes. */\n \t\
    pj_list_push_back(&mod_ua.free_dlgset_nodes, dlg_set);\n+    } else {\n+\t/* If\
    \ the just unregistered dialog is being used as hash key,\n+\t * reset the dlg_set\
    \ entry with a new key (i.e: from the first dialog\n+\t * in dlg_set).\n+\t */\n\
    +\tif (dlg_set->ht_key.ptr  == dlg->local.info->tag.ptr &&\n+\t    dlg_set->ht_key.slen\
    \ == dlg->local.info->tag.slen)\n+\t{\n+\t    pjsip_dialog* key_dlg = dlg_set->dlg_list.next;\n\
    +\n+\t    /* Verify that the old & new keys share the hash value */\n+\t    pj_assert(key_dlg->local.tag_hval\
    \ == dlg->local.tag_hval);\n+\n+\t    pj_hash_set_lower(NULL, mod_ua.dlg_table,\
    \ dlg_set->ht_key.ptr,\n+\t\t\t      (unsigned)dlg_set->ht_key.slen,\n+\t\t\t\
    \      dlg->local.tag_hval, NULL);\n+\n+\t    dlg_set->ht_key = key_dlg->local.info->tag;\n\
    +\n+\t    pj_hash_set_np_lower(mod_ua.dlg_table,\n+\t\t\t\t dlg_set->ht_key.ptr,\n\
    +\t\t\t\t (unsigned)dlg_set->ht_key.slen,\n+\t\t\t\t key_dlg->local.tag_hval,\
    \ dlg_set->ht_entry,\n+\t\t\t\t dlg_set);\n+\t}\n     }\n \n     /* Unlock user\
    \ agent. */"
  identifiers:
  - CVE-2022-23608
  - CWE-416
  overview: PJSIP is a free and open source multimedia communication library written
    in C language implementing standard based protocols such as SIP, SDP, RTP, STUN,
    TURN, and ICE. In versions up to and including 2.11.1 when in a dialog set (or
    forking) scenario, a hash key shared by multiple UAC dialogs can potentially be
    prematurely freed when one of the dialogs is destroyed . The issue may cause a
    dialog set to be registered in the hash table multiple times (with different hash
    keys) leading to undefined behavior such as dialog list collision which eventually
    leading to endless loop. A patch is available in commit db3235953baa56d2fb0e276ca510fefca751643f
    which will be included in the next release. There are no known workarounds for
    this issue.
  references:
  - source: security-advisories@github.com
    tags:
    - Third Party Advisory
    - VDB Entry
    url: http://packetstormsecurity.com/files/166226/Asterisk-Project-Security-Advisory-AST-2022-005.html
  - source: security-advisories@github.com
    tags:
    - Mailing List
    - Patch
    - Third Party Advisory
    url: http://seclists.org/fulldisclosure/2022/Mar/1
  - source: security-advisories@github.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/pjsip/pjproject/commit/db3235953baa56d2fb0e276ca510fefca751643f
  - source: security-advisories@github.com
    tags:
    - Issue Tracking
    - Patch
    - Third Party Advisory
    url: https://github.com/pjsip/pjproject/security/advisories/GHSA-ffff-m5fm-qm62
  - source: security-advisories@github.com
    tags:
    - Mailing List
    - Third Party Advisory
    url: https://lists.debian.org/debian-lts-announce/2022/03/msg00035.html
  - source: security-advisories@github.com
    tags:
    - Mailing List
    - Third Party Advisory
    url: https://lists.debian.org/debian-lts-announce/2022/03/msg00040.html
  - source: security-advisories@github.com
    tags:
    - Mailing List
    - Third Party Advisory
    url: https://lists.debian.org/debian-lts-announce/2022/11/msg00021.html
  - source: security-advisories@github.com
    url: https://lists.debian.org/debian-lts-announce/2023/08/msg00038.html
  - source: security-advisories@github.com
    tags:
    - Third Party Advisory
    url: https://security.gentoo.org/glsa/202210-37
  - source: security-advisories@github.com
    tags:
    - Third Party Advisory
    url: https://www.debian.org/security/2022/dsa-5285
  title: PJSIP is a free and open source multimedia communication library written
    in C language implementing standard based protocols such as SIP, SDP, RTP, STUN,
    TURN, and ICE. In versions up to and including 2.11.1 when in a dialog set (or
    forking) scenario, a hash key shared by multiple UAC dialogs can potentially be
    prematurely freed when one of the dialogs is destroyed . The issue may cause a
    dialog set to be registered in the hash table multiple times (with different hash
    keys) leading to undefined behavior such as dialog list collision which eventually
    leading to endless loop. A patch is available in commit db3235953baa56d2fb0e276ca510fefca751643f
    which will be included in the next release. There are no known workarounds for
    this issue.
- diff_content:
  - "--- a/mrbgems/mruby-compiler/core/codegen.c\n+++ b/mrbgems/mruby-compiler/core/codegen.c\n\
    @@ -1904,8 +1904,12 @@ gen_assignment(codegen_scope *s, node *tree, node *rhs,\
    \ int sp, int val)\n       if (val) {\n         gen_move(s, top, cursp(), 1);\n\
    \       }\n-      if (n < 14) {\n+      if (n < 15) {\n         n++;\n+      \
    \  if (n == 15) {\n+          pop_n(14);\n+          genop_2(s, OP_ARRAY, cursp(),\
    \ 15);\n+        }\n       }\n       else {\n         pop();"
  identifiers:
  - CVE-2022-0717
  - CWE-125
  overview: Out-of-bounds Read in GitHub repository mruby/mruby prior to 3.2.
  references:
  - source: security@huntr.dev
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/mruby/mruby/commit/f72315575f78a9a773adbce0ee7d3ec33434cb76
  - source: security@huntr.dev
    tags:
    - Exploit
    - Third Party Advisory
    url: https://huntr.dev/bounties/27a851a5-7ebf-409b-854f-b2614771e8f9
  title: Out-of-bounds Read in GitHub repository mruby/mruby prior to 3.2.
- diff_content:
  - "--- a/src/regexp_bt.c\n+++ b/src/regexp_bt.c\n@@ -4615,6 +4615,11 @@ regmatch(\n\
    \ \t\t\t    if (rex.input == rex.line)\n \t\t\t    {\n \t\t\t\t// backup to last\
    \ char of previous line\n+\t\t\t\tif (rex.lnum == 0)\n+\t\t\t\t{\n+\t\t\t\t  \
    \  status = RA_NOMATCH;\n+\t\t\t\t    break;\n+\t\t\t\t}\n \t\t\t\t--rex.lnum;\n\
    \ \t\t\t\trex.line = reg_getline(rex.lnum);\n \t\t\t\t// Just in case regrepeat()\
    \ didn't count"
  - "--- a/src/version.c\n+++ b/src/version.c\n@@ -750,6 +750,8 @@ static char *(features[])\
    \ =\n \n static int included_patches[] =\n {   /* Add new patch number below this\
    \ line */\n+/**/\n+    4440,\n /**/\n     4439,\n /**/"
  identifiers:
  - CVE-2022-0729
  - CWE-823
  overview: Use of Out-of-range Pointer Offset in GitHub repository vim/vim prior
    to 8.2.4440.
  references:
  - source: security@huntr.dev
    tags:
    - Mailing List
    - Third Party Advisory
    url: http://seclists.org/fulldisclosure/2022/Oct/28
  - source: security@huntr.dev
    tags:
    - Mailing List
    - Release Notes
    - Third Party Advisory
    url: http://seclists.org/fulldisclosure/2022/Oct/41
  - source: security@huntr.dev
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/vim/vim/commit/6456fae9ba8e72c74b2c0c499eaf09974604ff30
  - source: security@huntr.dev
    tags:
    - Exploit
    - Issue Tracking
    - Patch
    - Third Party Advisory
    url: https://huntr.dev/bounties/f3f3d992-7bd6-4ee5-a502-ae0e5f8016ea
  - source: security@huntr.dev
    tags:
    - Mailing List
    - Third Party Advisory
    url: https://lists.debian.org/debian-lts-announce/2022/03/msg00018.html
  - source: security@huntr.dev
    tags:
    - Mailing List
    - Third Party Advisory
    url: https://lists.debian.org/debian-lts-announce/2022/11/msg00009.html
  - source: security@huntr.dev
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/7ZLEHVP4LNAGER4ZDGUDS5V5YVQD6INF/
  - source: security@huntr.dev
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/HBUYQBZ6GWAWJRWP7AODJ4KHW5BCKDVP/
  - source: security@huntr.dev
    tags:
    - Third Party Advisory
    url: https://security.gentoo.org/glsa/202208-32
  - source: security@huntr.dev
    tags:
    - Release Notes
    - Third Party Advisory
    url: https://support.apple.com/kb/HT213488
  title: Use of Out-of-range Pointer Offset in GitHub repository vim/vim prior to
    8.2.4440.
- diff_content:
  - "--- a/libr/bin/format/mdmp/mdmp.c\n+++ b/libr/bin/format/mdmp/mdmp.c\n@@ -369,9\
    \ +369,15 @@ static bool r_bin_mdmp_init_hdr(struct r_bin_mdmp_obj *obj) {\n \t\
    return true;\n }\n \n-static void read_module(RBuffer *b, ut64 addr, struct minidump_module\
    \ *module) {\n+static struct minidump_module *read_module(RBuffer *b, ut64 addr)\
    \ {\n \tst64 o_addr = r_buf_seek (b, 0, R_BUF_CUR);\n-\tr_buf_seek (b, addr, R_BUF_SET);\n\
    +\tif (r_buf_seek (b, addr, R_BUF_SET) == -1) {\n+\t\treturn NULL;\n+\t}\n+\t\
    struct minidump_module *module = R_NEW0 (struct minidump_module);\n+\tif (!module)\
    \ {\n+\t\treturn NULL;\n+\t}\n \tmodule->base_of_image = r_buf_read_le64 (b);\n\
    \ \tmodule->size_of_image = r_buf_read_le32 (b);\n \tmodule->check_sum = r_buf_read_le32\
    \ (b);\n@@ -397,6 +403,7 @@ static void read_module(RBuffer *b, ut64 addr, struct\
    \ minidump_module *module) {\n \tmodule->reserved_0 = r_buf_read_le64 (b);\n \t\
    module->reserved_1 = r_buf_read_le64 (b);\n \tr_buf_seek (b, o_addr, R_BUF_SET);\n\
    +\treturn module;\n }\n \n static void read_memory64_list(RBuffer *b, ut64 addr,\
    \ struct minidump_memory64_list *memory64_list) {\n@@ -477,12 +484,11 @@ static\
    \ bool r_bin_mdmp_init_directory_entry(struct r_bin_mdmp_obj *obj, struct m\n\
    \ \t\t\t0);\n \n \t\toffset = entry->location.rva + sizeof (module_list);\n-\t\
    \tfor (i = 0; i < module_list.number_of_modules; i++) {\n-\t\t\tstruct minidump_module\
    \ *module = R_NEW (struct minidump_module);\n+\t\tfor (i = 0; i < module_list.number_of_modules\
    \ && offset < obj->size; i++) {\n+\t\t\tstruct minidump_module *module = read_module\
    \ (obj->b, offset);\n \t\t\tif (!module) {\n-\t\t\t\tbreak;\n+\t\t\t\tbreak;\t\
    \n \t\t\t}\n-\t\t\tread_module (obj->b, offset, module);\n \t\t\tr_list_append\
    \ (obj->streams.modules, module);\n \t\t\toffset += sizeof (*module);\n \t\t}\n\
    @@ -503,7 +509,7 @@ static bool r_bin_mdmp_init_directory_entry(struct r_bin_mdmp_obj\
    \ *obj, struct m\n \t\t\t0);\n \n \t\toffset = entry->location.rva + sizeof (memory_list);\n\
    -\t\tfor (i = 0; i < memory_list.number_of_memory_ranges; i++) {\n+\t\tfor (i\
    \ = 0; i < memory_list.number_of_memory_ranges && offset < obj->size; i++) {\n\
    \ \t\t\tstruct minidump_memory_descriptor *desc = R_NEW (struct minidump_memory_descriptor);\n\
    \ \t\t\tif (!desc) {\n \t\t\t\tbreak;\n@@ -586,7 +592,7 @@ static bool r_bin_mdmp_init_directory_entry(struct\
    \ r_bin_mdmp_obj *obj, struct m\n \t\t\t0);\n \n \t\toffset = entry->location.rva\
    \ + sizeof (thread_ex_list);\n-\t\tfor (i = 0; i < thread_ex_list.number_of_threads;\
    \ i++) {\n+\t\tfor (i = 0; i < thread_ex_list.number_of_threads && offset < obj->size;\
    \ i++) {\n \t\t\tstruct minidump_thread_ex *thread = R_NEW (struct minidump_thread_ex);\n\
    \ \t\t\tif (!thread) {\n \t\t\t\tbreak;\n@@ -613,7 +619,7 @@ static bool r_bin_mdmp_init_directory_entry(struct\
    \ r_bin_mdmp_obj *obj, struct m\n \n \t\tobj->streams.memories64.base_rva = memory64_list.base_rva;\n\
    \ \t\toffset = entry->location.rva + sizeof (memory64_list);\n-\t\tfor (i = 0;\
    \ i < memory64_list.number_of_memory_ranges; i++) {\n+\t\tfor (i = 0; i < memory64_list.number_of_memory_ranges\
    \ && offset < obj->size; i++) {\n \t\t\tstruct minidump_memory_descriptor64 *desc\
    \ = R_NEW (struct minidump_memory_descriptor64);\n \t\t\tif (!desc) {\n \t\t\t\
    \tbreak;\n@@ -708,7 +714,7 @@ static bool r_bin_mdmp_init_directory_entry(struct\
    \ r_bin_mdmp_obj *obj, struct m\n \t\t\t\"SizeOfHeader SizeOfEntry NumberOfEntries\"\
    , 0);\n \n \t\toffset = entry->location.rva + sizeof (unloaded_module_list);\n\
    -\t\tfor (i = 0; i < unloaded_module_list.number_of_entries; i++) {\n+\t\tfor\
    \ (i = 0; i < unloaded_module_list.number_of_entries && offset < obj->size; i++)\
    \ {\n \t\t\tstruct minidump_unloaded_module *module = R_NEW (struct minidump_unloaded_module);\n\
    \ \t\t\tif (!module) {\n \t\t\t\tbreak;\n@@ -763,7 +769,7 @@ static bool r_bin_mdmp_init_directory_entry(struct\
    \ r_bin_mdmp_obj *obj, struct m\n \t\t\t0);\n \n \t\toffset = entry->location.rva\
    \ + sizeof (memory_info_list);\n-\t\tfor (i = 0; i < memory_info_list.number_of_entries;\
    \ i++) {\n+\t\tfor (i = 0; i < memory_info_list.number_of_entries && offset <\
    \ obj->size; i++) {\n \t\t\tstruct minidump_memory_info *info = R_NEW (struct\
    \ minidump_memory_info);\n \t\t\tif (!info) {\n \t\t\t\tbreak;\n@@ -793,7 +799,7\
    \ @@ static bool r_bin_mdmp_init_directory_entry(struct r_bin_mdmp_obj *obj, struct\
    \ m\n \t\t\t\"SizeOfHeader SizeOfEntry NumberOfEntries\", 0);\n \n \t\toffset\
    \ = entry->location.rva + sizeof (thread_info_list);\n-\t\tfor (i = 0; i < thread_info_list.number_of_entries;\
    \ i++) {\n+\t\tfor (i = 0; i < thread_info_list.number_of_entries && offset <\
    \ obj->size; i++) {\n \t\t\tstruct minidump_thread_info *info = R_NEW (struct\
    \ minidump_thread_info);\n \t\t\tif (!info) {\n \t\t\t\tbreak;\n@@ -819,7 +825,7\
    \ @@ static bool r_bin_mdmp_init_directory_entry(struct r_bin_mdmp_obj *obj, struct\
    \ m\n \t\t\t\"SizeOfHeader SizeOfEntry NumberOfEntries Reserved\", 0);\n \n \t\
    \toffset = entry->location.rva + sizeof (handle_operation_list);\n-\t\tfor (i\
    \ = 0; i < handle_operation_list.number_of_entries; i++) {\n+\t\tfor (i = 0; i\
    \ < handle_operation_list.number_of_entries && offset < obj->size; i++) {\n \t\
    \t\tstruct avrf_handle_operation *op = R_NEW (struct avrf_handle_operation);\n\
    \ \t\t\tif (!op) {\n \t\t\t\tbreak;\n@@ -849,7 +855,7 @@ static bool r_bin_mdmp_init_directory_entry(struct\
    \ r_bin_mdmp_obj *obj, struct m\n \t\t\t\"TokenListSize TokenListEntries ListHeaderSize\
    \ ElementHeaderSize\", 0);\n \n \t\toffset = entry->location.rva + sizeof (token_info_list);\n\
    -\t\tfor (i = 0; i < token_info_list.number_of_entries; i++) {\n+\t\tfor (i =\
    \ 0; i < token_info_list.number_of_entries && offset < obj->size; i++) {\n \t\t\
    \tstruct minidump_token_info *info = R_NEW (struct minidump_token_info);\n \t\t\
    \tif (!info) {\n \t\t\t\tbreak;"
  identifiers:
  - CVE-2022-0476
  - CWE-400
  overview: Denial of Service in GitHub repository radareorg/radare2 prior to 5.6.4.
  references:
  - source: security@huntr.dev
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/radareorg/radare2/commit/27fe8031782d3a06c3998eaa94354867864f9f1b
  - source: security@huntr.dev
    tags:
    - Exploit
    - Patch
    - Third Party Advisory
    url: https://huntr.dev/bounties/81ddfbda-6c9f-4b69-83ff-85b15141e35d
  - source: security@huntr.dev
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/BZTIMAS53YT66FUS4QHQAFRJOBMUFG6D/
  - source: security@huntr.dev
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/E6YBRQ3UCFWJVSOYIKPVUDASZ544TFND/
  title: Denial of Service in GitHub repository radareorg/radare2 prior to 5.6.4.
- diff_content:
  - "--- a/libr/bin/format/pe/pe.c\n+++ b/libr/bin/format/pe/pe.c\n@@ -1,4 +1,4 @@\n\
    -/* radare - LGPL - Copyright 2008-2021 nibble, pancake, inisider */\n+/* radare\
    \ - LGPL - Copyright 2008-2022 nibble, pancake, inisider */\n \n #include <stdio.h>\n\
    \ #include <stdlib.h>\n@@ -278,15 +278,13 @@ struct r_bin_pe_addr_t *PE_(check_msvcseh)(RBinPEObj\
    \ *pe) {\n }\n \n struct r_bin_pe_addr_t *PE_(check_mingw)(RBinPEObj *pe) {\n\
    -\tstruct r_bin_pe_addr_t* entry;\n \tbool sw = false;\n-\tut8 b[1024];\n+\tut8\
    \ b[1024] = {0};\n \tsize_t n = 0;\n \tif (!pe || !pe->b) {\n \t\treturn 0LL;\n\
    \ \t}\n-\tentry = PE_(r_bin_pe_get_entrypoint) (pe);\n-\tZERO_FILL (b);\n+\tstruct\
    \ r_bin_pe_addr_t* entry = PE_(r_bin_pe_get_entrypoint) (pe);\n \tif (r_buf_read_at\
    \ (pe->b, entry->paddr, b, sizeof (b)) < 0) {\n \t\tpe_printf (\"Warning: Cannot\
    \ read entry at 0x%08\"PFMT64x \"\\n\", entry->paddr);\n \t\tfree (entry);\n@@\
    \ -339,11 +337,11 @@ struct r_bin_pe_addr_t *PE_(check_unknow)(RBinPEObj *pe)\
    \ {\n \tif (!pe || !pe->b) {\n \t\treturn 0LL;\n \t}\n-\tut8 b[512];\n+\tut8 b[512]\
    \ = {0};\n \tZERO_FILL (b);\n \tentry = PE_ (r_bin_pe_get_entrypoint) (pe);\n\
    \ \t// option2: /x 8bff558bec83ec20\n-\tif (r_buf_read_at (pe->b, entry->paddr,\
    \ b, 512) < 1) {\n+\tif (r_buf_read_at (pe->b, entry->paddr, b, sizeof (b)) !=\
    \ sizeof (b)) {\n \t\tpe_printf (\"Warning: Cannot read entry at 0x%08\"PFMT64x\"\
    \\n\", entry->paddr);\n \t\tfree (entry);\n \t\treturn NULL;\n@@ -537,7 +535,8\
    \ @@ static int bin_pe_parse_imports(RBinPEObj* pe,\n \t\t\t\tif (len < 1) {\n\
    \ \t\t\t\t\tpe_printf (\"Warning: read (import name)\\n\");\n \t\t\t\t\tgoto error;\n\
    -\t\t\t\t} else if (!*name) {\n+\t\t\t\t}\n+\t\t\t\tif (!*name) {\n \t\t\t\t\t\
    break;\n \t\t\t\t}\n \t\t\t\tname[PE_NAME_LENGTH] = '\\0';\n@@ -1820,7 +1818,7\
    \ @@ static Var* Pe_r_bin_pe_parse_var(RBinPEObj* pe, PE_DWord* curAddr) {\n \t\
    \tfree_Var (var);\n \t\treturn NULL;\n \t}\n-\tif (r_buf_read_at (pe->b, *curAddr,\
    \ (ut8*) var->szKey, TRANSLATION_UTF_16_LEN) < 1) {\n+\tif (r_buf_read_at (pe->b,\
    \ *curAddr, (ut8*) var->szKey, TRANSLATION_UTF_16_LEN) != TRANSLATION_UTF_16_LEN)\
    \ {\n \t\tpe_printf (\"Warning: read (Var szKey)\\n\");\n \t\tfree_Var (var);\n\
    \ \t\treturn NULL;"
  - "--- a/libr/bin/p/bin_dyldcache.c\n+++ b/libr/bin/p/bin_dyldcache.c\n@@ -587,7\
    \ +587,7 @@ static ut64 estimate_slide(RBinFile *bf, RDyldCache *cache, ut64 value_mask,\
    \ ut6\n \t\tint n_classes = classlist_sample_size / 8;\n \t\tut64 sect_offset\
    \ = sections[classlist_idx].offset + bin->hdr_offset;\n \n-\t\tif (r_buf_fread_at\
    \ (cache->buf, sect_offset, (ut8*) classlist, \"l\", n_classes) < classlist_sample_size)\
    \ {\n+\t\tif (r_buf_fread_at (cache->buf, sect_offset, (ut8*) classlist, \"l\"\
    , n_classes) != classlist_sample_size) {\n \t\t\tgoto next_bin;\n \t\t}\n "
  - "--- a/libr/bin/p/bin_psxexe.c\n+++ b/libr/bin/p/bin_psxexe.c\n@@ -57,7 +57,7\
    \ @@ static RList* sections(RBinFile* bf) {\n \t\treturn NULL;\n \t}\n \n-\tif\
    \ (r_buf_fread_at (bf->buf, 0, (ut8*)&psxheader, \"8c17i\", 1) < sizeof (psxexe_header))\
    \ {\n+\tif (r_buf_fread_at (bf->buf, 0, (ut8*)&psxheader, \"8c17i\", 1) != sizeof\
    \ (psxexe_header)) {\n \t\teprintf (\"Truncated Header\\n\");\n \t\tfree (sect);\n\
    \ \t\tr_list_free (ret);\n@@ -93,7 +93,7 @@ static RList* entries(RBinFile* bf)\
    \ {\n \t\treturn NULL;\n \t}\n \n-\tif (r_buf_fread_at (bf->buf, 0, (ut8*)&psxheader,\
    \ \"8c17i\", 1) < sizeof (psxexe_header)) {\n+\tif (r_buf_fread_at (bf->buf, 0,\
    \ (ut8*)&psxheader, \"8c17i\", 1) != sizeof (psxexe_header)) {\n \t\teprintf (\"\
    PSXEXE Header truncated\\n\");\n \t\tr_list_free (ret);\n \t\tfree (addr);"
  - "--- a/libr/bin/p/bin_qnx.c\n+++ b/libr/bin/p/bin_qnx.c\n@@ -7,7 +7,7 @@ static\
    \ int lmf_header_load(lmf_header *lmfh, RBuffer *buf, Sdb *db) {\n \tif (r_buf_size\
    \ (buf) < sizeof (lmf_header)) {\n \t\treturn false;\n \t}\n-\tif (r_buf_fread_at\
    \ (buf, QNX_HEADER_ADDR, (ut8 *) lmfh, \"iiiiiiiicccciiiicc\", 1) < QNX_HDR_SIZE)\
    \ {\n+\tif (r_buf_fread_at (buf, QNX_HEADER_ADDR, (ut8 *) lmfh, \"iiiiiiiicccciiiicc\"\
    , 1) != QNX_HDR_SIZE) {\n \t\treturn false;\n \t}\n \tr_strf_buffer (32);\n@@\
    \ -64,15 +64,15 @@ static bool load_buffer(RBinFile *bf, void **bin_obj, RBuffer\
    \ *buf, ut64 loadadd\n \t\tgoto beach;\n \t}\n \t// Read the first record\n-\t\
    if (r_buf_fread_at (bf->buf, 0, (ut8 *)&lrec, \"ccss\", 1) < QNX_RECORD_SIZE)\
    \ {\n+\tif (r_buf_fread_at (bf->buf, 0, (ut8 *)&lrec, \"ccss\", 1) != QNX_RECORD_SIZE)\
    \ {\n \t\tgoto beach;\n \t}\n \t// Load the header\n \tlmf_header_load (&qo->lmfh,\
    \ bf->buf, qo->kv);\n \toffset += lrec.data_nbytes;\n \n \tfor (;;) {\n-\t\tif\
    \ (r_buf_fread_at (bf->buf, offset, (ut8 *)&lrec, \"ccss\", 1) < QNX_RECORD_SIZE)\
    \ {\n+\t\tif (r_buf_fread_at (bf->buf, offset, (ut8 *)&lrec, \"ccss\", 1) != QNX_RECORD_SIZE)\
    \ {\n \t\t\tgoto beach;\n \t\t}\n \t\toffset += sizeof (lmf_record);\n@@ -84,7\
    \ +84,7 @@ static bool load_buffer(RBinFile *bf, void **bin_obj, RBuffer *buf,\
    \ ut64 loadadd\n \t\t\tif (!ptr) {\n \t\t\t\tgoto beach;\n \t\t\t}\n-\t\t\tif\
    \ (r_buf_fread_at (bf->buf, offset, (ut8 *)&lres, \"ssss\", 1) < sizeof (lmf_resource))\
    \ {\n+\t\t\tif (r_buf_fread_at (bf->buf, offset, (ut8 *)&lres, \"ssss\", 1) !=\
    \ sizeof (lmf_resource)) {\n \t\t\t\tgoto beach;\n \t\t\t}\n \t\t\tptr->name =\
    \ strdup (\"LMF_RESOURCE\");\n@@ -95,7 +95,7 @@ static bool load_buffer(RBinFile\
    \ *bf, void **bin_obj, RBuffer *buf, ut64 loadadd\n \t\t \tr_list_append (sections,\
    \ ptr);\n \t\t} else if (lrec.rec_type == LMF_LOAD_REC) {\n \t\t\tRBinSection\
    \ *ptr = R_NEW0 (RBinSection);\n-\t\t\tif (r_buf_fread_at (bf->buf, offset, (ut8\
    \ *)&ldata, \"si\", 1) < sizeof (lmf_data)) {\n+\t\t\tif (r_buf_fread_at (bf->buf,\
    \ offset, (ut8 *)&ldata, \"si\", 1) != sizeof (lmf_data)) {\n \t\t\t\tgoto beach;\n\
    \ \t\t\t}\n \t\t\tif (!ptr) {\n@@ -110,15 +110,15 @@ static bool load_buffer(RBinFile\
    \ *bf, void **bin_obj, RBuffer *buf, ut64 loadadd\n \t\t \tr_list_append (sections,\
    \ ptr);\n \t\t} else if (lrec.rec_type == LMF_FIXUP_REC) {\n \t\t\tRBinReloc *ptr\
    \ = R_NEW0 (RBinReloc);\n-\t\t\tif (!ptr || r_buf_fread_at (bf->buf, offset, (ut8\
    \ *)&ldata, \"si\", 1) < sizeof (lmf_data)) {\n+\t\t\tif (!ptr || r_buf_fread_at\
    \ (bf->buf, offset, (ut8 *)&ldata, \"si\", 1) != sizeof (lmf_data)) {\n \t\t\t\
    \tgoto beach;\n \t\t\t}\n \t\t\tptr->vaddr = ptr->paddr = ldata.offset;\n \t\t\
    \tptr->type = 'f'; // \"LMF_FIXUP\";\n \t\t\tr_list_append (fixups, ptr);\n \t\
    \t} else if (lrec.rec_type == LMF_8087_FIXUP_REC) {\n \t\t\tRBinReloc *ptr = R_NEW0\
    \ (RBinReloc);\n-\t\t\tif (!ptr || r_buf_fread_at (bf->buf, offset, (ut8 *)&ldata,\
    \ \"si\", 1) < sizeof (lmf_data)) {\n+\t\t\tif (!ptr || r_buf_fread_at (bf->buf,\
    \ offset, (ut8 *)&ldata, \"si\", 1) != sizeof (lmf_data)) {\n \t\t\t\tgoto beach;\n\
    \ \t\t\t}\n \t\t\tptr->vaddr = ptr->paddr = ldata.offset;"
  - "--- a/libr/util/buf.c\n+++ b/libr/util/buf.c\n@@ -516,10 +516,9 @@ static st64\
    \ buf_format(RBuffer *dst, RBuffer *src, const char *fmt, int n) {\n \t\t\t\t\
    ut32 d3;\n \t\t\t\tut64 d4;\n \t\t\t\tst64 r = r_buf_read (src, tmp, tsize);\n\
    -\t\t\t\tif (r < tsize) {\n+\t\t\t\tif (r != tsize) {\n \t\t\t\t\treturn -1;\n\
    \ \t\t\t\t}\n-\n \t\t\t\tswitch (tsize) {\n \t\t\t\tcase 1:\n \t\t\t\t\td1 = r_read_ble8\
    \ (tmp);\n@@ -566,7 +565,7 @@ R_API st64 r_buf_fread_at(RBuffer *b, ut64 addr,\
    \ ut8 *buf, const char *fmt, int\n \t\treturn r;\n \t}\n \tr = r_buf_fread (b,\
    \ buf, fmt, n);\n-\tr_buf_seek (b, o_addr, R_BUF_SET);\n+\t(void)r_buf_seek (b,\
    \ o_addr, R_BUF_SET);\n \treturn r;\n }\n "
  identifiers:
  - CVE-2022-0695
  - CWE-400
  overview: Denial of Service in GitHub repository radareorg/radare2 prior to 5.6.4.
  references:
  - source: security@huntr.dev
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/radareorg/radare2/commit/634b886e84a5c568d243e744becc6b3223e089cf
  - source: security@huntr.dev
    tags:
    - Exploit
    - Patch
    - Third Party Advisory
    url: https://huntr.dev/bounties/bdbddc0e-fb06-4211-a90b-7cbedcee2bea
  - source: security@huntr.dev
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/BZTIMAS53YT66FUS4QHQAFRJOBMUFG6D/
  - source: security@huntr.dev
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/E6YBRQ3UCFWJVSOYIKPVUDASZ544TFND/
  title: Denial of Service in GitHub repository radareorg/radare2 prior to 5.6.4.
- diff_content:
  - "--- a/seatd-launch/seatd-launch.c\n+++ b/seatd-launch/seatd-launch.c\n@@ -15,18\
    \ +15,13 @@ int main(int argc, char *argv[]) {\n \n \tconst char *usage = \"Usage:\
    \ seatd-launch [options] [--] command\\n\"\n \t\t\t    \"\\n\"\n-\t\t\t    \"\
    \  -h\t\tShow this help message\\n\"\n-\t\t\t    \"  -s <path>\tWhere to create\
    \ the seatd socket\\n\"\n-\t\t\t    \"  -v\t\tShow the version number\\n\"\n+\t\
    \t\t    \"  -h\tShow this help message\\n\"\n+\t\t\t    \"  -v\tShow the version\
    \ number\\n\"\n \t\t\t    \"\\n\";\n \n \tint c;\n-\tchar *sockpath = NULL;\n\
    -\twhile ((c = getopt(argc, argv, \"vhs:\")) != -1) {\n+\twhile ((c = getopt(argc,\
    \ argv, \"vh\")) != -1) {\n \t\tswitch (c) {\n-\t\tcase 's':\n-\t\t\tsockpath\
    \ = optarg;\n-\t\t\tbreak;\n \t\tcase 'v':\n \t\t\tprintf(\"seatd-launch version\
    \ %s\\n\", SEATD_VERSION);\n \t\t\treturn 0;\n@@ -47,11 +42,8 @@ int main(int\
    \ argc, char *argv[]) {\n \t}\n \tchar **command = &argv[optind];\n \n-\tchar\
    \ sockbuf[256];\n-\tif (sockpath == NULL) {\n-\t\tsprintf(sockbuf, \"/tmp/seatd.%d.sock\"\
    , getpid());\n-\t\tsockpath = sockbuf;\n-\t}\n+\tchar sockpath[256];\n+\tsprintf(sockpath,\
    \ \"/tmp/seatd.%d.sock\", getpid());\n \n \tint fds[2];\n \tif (pipe(fds) == -1)\
    \ {"
  - "--- a/seatd-launch/seatd-launch.c\n+++ b/seatd-launch/seatd-launch.c\n@@ -15,18\
    \ +15,13 @@ int main(int argc, char *argv[]) {\n \n \tconst char *usage = \"Usage:\
    \ seatd-launch [options] [--] command\\n\"\n \t\t\t    \"\\n\"\n-\t\t\t    \"\
    \  -h\t\tShow this help message\\n\"\n-\t\t\t    \"  -s <path>\tWhere to create\
    \ the seatd socket\\n\"\n-\t\t\t    \"  -v\t\tShow the version number\\n\"\n+\t\
    \t\t    \"  -h\tShow this help message\\n\"\n+\t\t\t    \"  -v\tShow the version\
    \ number\\n\"\n \t\t\t    \"\\n\";\n \n \tint c;\n-\tchar *sockpath = NULL;\n\
    -\twhile ((c = getopt(argc, argv, \"vhs:\")) != -1) {\n+\twhile ((c = getopt(argc,\
    \ argv, \"vh\")) != -1) {\n \t\tswitch (c) {\n-\t\tcase 's':\n-\t\t\tsockpath\
    \ = optarg;\n-\t\t\tbreak;\n \t\tcase 'v':\n \t\t\tprintf(\"seatd-launch version\
    \ %s\\n\", SEATD_VERSION);\n \t\t\treturn 0;\n@@ -47,11 +42,8 @@ int main(int\
    \ argc, char *argv[]) {\n \t}\n \tchar **command = &argv[optind];\n \n-\tchar\
    \ sockbuf[256];\n-\tif (sockpath == NULL) {\n-\t\tsprintf(sockbuf, \"/tmp/seatd.%d.sock\"\
    , getpid());\n-\t\tsockpath = sockbuf;\n-\t}\n+\tchar sockpath[256];\n+\tsprintf(sockpath,\
    \ \"/tmp/seatd.%d.sock\", getpid());\n \n \tunlink(sockpath);\n "
  identifiers:
  - CVE-2022-25643
  - CWE-668
  overview: seatd-launch in seatd 0.6.x before 0.6.4 allows removing files with escalated
    privileges when installed setuid root. The attack vector is a user-supplied socket
    pathname.
  references:
  - source: cve@mitre.org
    url: https://github.com/kennylevinsen/seatd/commit/10658dc5439db429af0088295a051c53925a4416
  - source: cve@mitre.org
    url: https://github.com/kennylevinsen/seatd/commit/7cffe0797fdb17a9c08922339465b1b187394335
  - source: cve@mitre.org
    tags:
    - Release Notes
    - Third Party Advisory
    url: https://github.com/kennylevinsen/seatd/compare/0.6.3...0.6.4
  - source: cve@mitre.org
    tags:
    - Third Party Advisory
    url: https://github.com/kennylevinsen/seatd/tags
  - source: cve@mitre.org
    tags:
    - Third Party Advisory
    url: https://lists.sr.ht/~kennylevinsen/seatd-announce/%3CETEO7R.QG8B1KGD531R1%40kl.wtf%3E
  - source: cve@mitre.org
    url: https://nvd.nist.gov/vuln/detail/CVE-2022-25643
  title: seatd-launch in seatd 0.6.x before 0.6.4 allows removing files with escalated
    privileges when installed setuid root. The attack vector is a user-supplied socket
    pathname.
- diff_content:
  - "--- a/coders/tiff.c\n+++ b/coders/tiff.c\n@@ -1894,7 +1894,7 @@ static Image\
    \ *ReadTIFFImage(const ImageInfo *image_info,\n         /*\n           Convert\
    \ stripped TIFF image.\n         */\n-        extent=2*TIFFStripSize(tiff);\n\
    +        extent=4*TIFFStripSize(tiff);\n #if defined(TIFF_VERSION_BIG)\n     \
    \    extent+=image->columns*sizeof(uint64);\n #else"
  identifiers:
  - CVE-2021-3610
  - CWE-787
  overview: A heap-based buffer overflow vulnerability was found in ImageMagick in
    versions prior to 7.0.11-14 in ReadTIFFImage() in coders/tiff.c. This issue is
    due to an incorrect setting of the pixel array size, which can lead to a crash
    and segmentation fault.
  references:
  - source: secalert@redhat.com
    tags:
    - Mailing List
    - Patch
    url: http://www.openwall.com/lists/oss-security/2023/05/29/4
  - source: secalert@redhat.com
    tags:
    - Mailing List
    - Patch
    url: http://www.openwall.com/lists/oss-security/2023/06/05/1
  - source: secalert@redhat.com
    tags:
    - Issue Tracking
    - Patch
    - Third Party Advisory
    url: https://bugzilla.redhat.com/show_bug.cgi?id=1973689
  - source: secalert@redhat.com
    tags:
    - Patch
    url: https://github.com/ImageMagick/ImageMagick/commit/930ff0d1a9bc42925a7856e9ea53f5fc9f318bf3
  title: A heap-based buffer overflow vulnerability was found in ImageMagick in versions
    prior to 7.0.11-14 in ReadTIFFImage() in coders/tiff.c. This issue is due to an
    incorrect setting of the pixel array size, which can lead to a crash and segmentation
    fault.
- diff_content:
  - "--- a/valid.c\n+++ b/valid.c\n@@ -479,6 +479,35 @@ nodeVPop(xmlValidCtxtPtr ctxt)\n\
    \     return (ret);\n }\n \n+/**\n+ * xmlValidNormalizeString:\n+ * @str: a string\n\
    + *\n+ * Normalize a string in-place.\n+ */\n+static void\n+xmlValidNormalizeString(xmlChar\
    \ *str) {\n+    xmlChar *dst;\n+    const xmlChar *src;\n+\n+    if (str == NULL)\n\
    +        return;\n+    src = str;\n+    dst = str;\n+\n+    while (*src == 0x20)\
    \ src++;\n+    while (*src != 0) {\n+\tif (*src == 0x20) {\n+\t    while (*src\
    \ == 0x20) src++;\n+\t    if (*src != 0)\n+\t\t*dst++ = 0x20;\n+\t} else {\n+\t\
    \    *dst++ = *src++;\n+\t}\n+    }\n+    *dst = 0;\n+}\n+\n #ifdef DEBUG_VALID_ALGO\n\
    \ static void\n xmlValidPrintNode(xmlNodePtr cur) {\n@@ -2607,6 +2636,24 @@ xmlDumpNotationTable(xmlBufferPtr\
    \ buf, xmlNotationTablePtr table) {\n \t    (xmlDictOwns(dict, (const xmlChar\
    \ *)(str)) == 0)))\t\\\n \t    xmlFree((char *)(str));\n \n+static int\n+xmlIsStreaming(xmlValidCtxtPtr\
    \ ctxt) {\n+    xmlParserCtxtPtr pctxt;\n+\n+    if (ctxt == NULL)\n+        return(0);\n\
    +    /*\n+     * These magic values are also abused to detect whether we're validating\n\
    +     * while parsing a document. In this case, userData points to the parser\n\
    +     * context.\n+     */\n+    if ((ctxt->finishDtd != XML_CTXT_FINISH_DTD_0)\
    \ &&\n+        (ctxt->finishDtd != XML_CTXT_FINISH_DTD_1))\n+        return(0);\n\
    +    pctxt = ctxt->userData;\n+    return(pctxt->parseMode == XML_PARSE_READER);\n\
    +}\n+\n /**\n  * xmlFreeID:\n  * @not:  A id\n@@ -2650,7 +2697,7 @@ xmlAddID(xmlValidCtxtPtr\
    \ ctxt, xmlDocPtr doc, const xmlChar *value,\n     if (doc == NULL) {\n \treturn(NULL);\n\
    \     }\n-    if (value == NULL) {\n+    if ((value == NULL) || (value[0] == 0))\
    \ {\n \treturn(NULL);\n     }\n     if (attr == NULL) {\n@@ -2681,7 +2728,7 @@\
    \ xmlAddID(xmlValidCtxtPtr ctxt, xmlDocPtr doc, const xmlChar *value,\n      */\n\
    \     ret->value = xmlStrdup(value);\n     ret->doc = doc;\n-    if ((ctxt !=\
    \ NULL) && (ctxt->vstateNr != 0)) {\n+    if (xmlIsStreaming(ctxt)) {\n \t/*\n\
    \ \t * Operating in streaming mode, attr is gonna disappear\n \t */\n@@ -2820,6\
    \ +2867,7 @@ xmlRemoveID(xmlDocPtr doc, xmlAttrPtr attr) {\n     ID = xmlNodeListGetString(doc,\
    \ attr->children, 1);\n     if (ID == NULL)\n         return(-1);\n+    xmlValidNormalizeString(ID);\n\
    \ \n     id = xmlHashLookup(table, ID);\n     if (id == NULL || id->attr != attr)\
    \ {\n@@ -3009,7 +3057,7 @@ xmlAddRef(xmlValidCtxtPtr ctxt, xmlDocPtr doc, const\
    \ xmlChar *value,\n      * fill the structure.\n      */\n     ret->value = xmlStrdup(value);\n\
    -    if ((ctxt != NULL) && (ctxt->vstateNr != 0)) {\n+    if (xmlIsStreaming(ctxt))\
    \ {\n \t/*\n \t * Operating in streaming mode, attr is gonna disappear\n \t */\n\
    @@ -4028,8 +4076,7 @@ xmlValidateAttributeValue2(xmlValidCtxtPtr ctxt, xmlDocPtr\
    \ doc,\n xmlChar *\n xmlValidCtxtNormalizeAttributeValue(xmlValidCtxtPtr ctxt,\
    \ xmlDocPtr doc,\n \t     xmlNodePtr elem, const xmlChar *name, const xmlChar\
    \ *value) {\n-    xmlChar *ret, *dst;\n-    const xmlChar *src;\n+    xmlChar\
    \ *ret;\n     xmlAttributePtr attrDecl = NULL;\n     int extsubset = 0;\n \n@@\
    \ -4070,19 +4117,7 @@ xmlValidCtxtNormalizeAttributeValue(xmlValidCtxtPtr ctxt,\
    \ xmlDocPtr doc,\n     ret = xmlStrdup(value);\n     if (ret == NULL)\n \treturn(NULL);\n\
    -    src = value;\n-    dst = ret;\n-    while (*src == 0x20) src++;\n-    while\
    \ (*src != 0) {\n-\tif (*src == 0x20) {\n-\t    while (*src == 0x20) src++;\n\
    -\t    if (*src != 0)\n-\t\t*dst++ = 0x20;\n-\t} else {\n-\t    *dst++ = *src++;\n\
    -\t}\n-    }\n-    *dst = 0;\n+    xmlValidNormalizeString(ret);\n     if ((doc->standalone)\
    \ && (extsubset == 1) && (!xmlStrEqual(value, ret))) {\n \txmlErrValidNode(ctxt,\
    \ elem, XML_DTD_NOT_STANDALONE,\n \"standalone: %s on %s value had to be normalized\
    \ based on external subset declaration\\n\",\n@@ -4114,8 +4149,7 @@ xmlValidCtxtNormalizeAttributeValue(xmlValidCtxtPtr\
    \ ctxt, xmlDocPtr doc,\n xmlChar *\n xmlValidNormalizeAttributeValue(xmlDocPtr\
    \ doc, xmlNodePtr elem,\n \t\t\t        const xmlChar *name, const xmlChar *value)\
    \ {\n-    xmlChar *ret, *dst;\n-    const xmlChar *src;\n+    xmlChar *ret;\n\
    \     xmlAttributePtr attrDecl = NULL;\n \n     if (doc == NULL) return(NULL);\n\
    @@ -4145,19 +4179,7 @@ xmlValidNormalizeAttributeValue(xmlDocPtr doc, xmlNodePtr\
    \ elem,\n     ret = xmlStrdup(value);\n     if (ret == NULL)\n \treturn(NULL);\n\
    -    src = value;\n-    dst = ret;\n-    while (*src == 0x20) src++;\n-    while\
    \ (*src != 0) {\n-\tif (*src == 0x20) {\n-\t    while (*src == 0x20) src++;\n\
    -\t    if (*src != 0)\n-\t\t*dst++ = 0x20;\n-\t} else {\n-\t    *dst++ = *src++;\n\
    -\t}\n-    }\n-    *dst = 0;\n+    xmlValidNormalizeString(ret);\n     return(ret);\n\
    \ }\n "
  identifiers:
  - CVE-2022-23308
  - CWE-416
  overview: valid.c in libxml2 before 2.9.13 has a use-after-free of ID and IDREF
    attributes.
  references:
  - source: cve@mitre.org
    tags:
    - Mailing List
    - Third Party Advisory
    url: http://seclists.org/fulldisclosure/2022/May/33
  - source: cve@mitre.org
    tags:
    - Mailing List
    - Third Party Advisory
    url: http://seclists.org/fulldisclosure/2022/May/34
  - source: cve@mitre.org
    tags:
    - Mailing List
    - Third Party Advisory
    url: http://seclists.org/fulldisclosure/2022/May/35
  - source: cve@mitre.org
    tags:
    - Mailing List
    - Third Party Advisory
    url: http://seclists.org/fulldisclosure/2022/May/36
  - source: cve@mitre.org
    tags:
    - Mailing List
    - Third Party Advisory
    url: http://seclists.org/fulldisclosure/2022/May/37
  - source: cve@mitre.org
    tags:
    - Mailing List
    - Third Party Advisory
    url: http://seclists.org/fulldisclosure/2022/May/38
  - source: cve@mitre.org
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/GNOME/libxml2/commit/652dd12a858989b14eed4e84e453059cd3ba340e
  - source: cve@mitre.org
    tags:
    - Release Notes
    - Third Party Advisory
    url: https://gitlab.gnome.org/GNOME/libxml2/-/blob/v2.9.13/NEWS
  - source: cve@mitre.org
    tags:
    - Mailing List
    - Third Party Advisory
    url: https://lists.debian.org/debian-lts-announce/2022/04/msg00004.html
  - source: cve@mitre.org
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/LA3MWWAYZADWJ5F6JOUBX65UZAMQB7RF/
  - source: cve@mitre.org
    tags:
    - Third Party Advisory
    url: https://security.gentoo.org/glsa/202210-03
  - source: cve@mitre.org
    tags:
    - Third Party Advisory
    url: https://security.netapp.com/advisory/ntap-20220331-0008/
  - source: cve@mitre.org
    tags:
    - Third Party Advisory
    url: https://support.apple.com/kb/HT213253
  - source: cve@mitre.org
    tags:
    - Third Party Advisory
    url: https://support.apple.com/kb/HT213254
  - source: cve@mitre.org
    tags:
    - Third Party Advisory
    url: https://support.apple.com/kb/HT213255
  - source: cve@mitre.org
    tags:
    - Third Party Advisory
    url: https://support.apple.com/kb/HT213256
  - source: cve@mitre.org
    tags:
    - Third Party Advisory
    url: https://support.apple.com/kb/HT213257
  - source: cve@mitre.org
    tags:
    - Third Party Advisory
    url: https://support.apple.com/kb/HT213258
  - source: cve@mitre.org
    tags:
    - Patch
    - Third Party Advisory
    url: https://www.oracle.com/security-alerts/cpujul2022.html
  title: valid.c in libxml2 before 2.9.13 has a use-after-free of ID and IDREF attributes.
- diff_content:
  - "--- a/src/audio_level/audio_level.c\n+++ b/src/audio_level/audio_level.c\n@@\
    \ -141,8 +141,8 @@ int audio_level_json(struct list *levell,\n \n \t\tja = jzon_alloc_object();\n\
    \ \t\tif (ja) {\n-\t\t\tjzon_add_str(ja, \"userid\", userid);\n-\t\t\tjzon_add_str(ja,\
    \ \"clientid\", clientid);\n+\t\t\tjzon_add_str(ja, \"userid\", \"%s\", userid);\n\
    +\t\t\tjzon_add_str(ja, \"clientid\", \"%s\", clientid);\n \t\t\tjzon_add_int(ja,\
    \ \"audio_level\",\n \t\t\t\t     (int32_t)a->aulevel_smooth);\n \t\t\tjzon_add_int(ja,\
    \ \"audio_level_now\","
  - "--- a/src/ecall/ecall.c\n+++ b/src/ecall/ecall.c\n@@ -2060,7 +2060,8 @@ int ecall_start(struct\
    \ ecall *ecall, enum icall_call_type call_type,\n {\n \tint err;\n \n-\tinfo(\"\
    ecall(%p): start\\n\", ecall);\n+\tinfo(\"ecall(%p): start call_type=%d cbr=%d\\\
    n\",\n+\t     ecall, call_type, audio_cbr);\n \n \tif (!ecall)\n \t\treturn EINVAL;\n\
    @@ -2149,7 +2150,7 @@ int ecall_answer(struct ecall *ecall, enum icall_call_type\
    \ call_type,\n #endif\n \t\n \n-\tinfo(\"ecall(%p): answer on pending econn %p\
    \ call_type=%d\\n\", ecall, ecall->econn, call_type);\n+\tinfo(\"ecall(%p): answer\
    \ on pending econn %p call_type=%d cbr=%d\\n\", ecall, ecall->econn, call_type,\
    \ audio_cbr);\n \n \tif (!ecall->econn) {\n \t\twarning(\"ecall: answer: econn\
    \ does not exist!\\n\");"
  - "--- a/src/econn_fmt/msg.c\n+++ b/src/econn_fmt/msg.c\n@@ -425,10 +424,10 @@ int\
    \ econn_message_encode(char **strp, const struct econn_message *msg)\n \n \t\t\
    jzon_add_bool(jobj, \"update\",\n \t\t\t      msg->u.confconn.update);\n-\t\t\
    jzon_add_str(jobj, \"tool\",\n-\t\t\t      msg->u.confconn.tool);\n+\t\tjzon_add_str(jobj,\
    \ \"tool\", \n+\t\t\t     \"%s\", msg->u.confconn.tool);\n \t\tjzon_add_str(jobj,\
    \ \"toolver\",\n-\t\t\t      msg->u.confconn.toolver);\n+\t\t\t     \"%s\", msg->u.confconn.toolver);\n\
    \ \t\tjzon_add_int(jobj, \"status\",\n \t\t\t      msg->u.confconn.status);\n\
    \ \t\tjzon_add_bool(jobj, \"selective_audio\","
  - "--- a/src/peerflow/cbr_detector_remote.cpp\n+++ b/src/peerflow/cbr_detector_remote.cpp\n\
    @@ -21,6 +21,9 @@\n \n #include \"cbr_detector_remote.h\"\n \n+#define MAX_MISSMATCH\
    \ 10\n+#define MIN_MATCH 100\n+\n namespace wire {\n \n CbrDetectorRemote::CbrDetectorRemote()\n\
    @@ -43,21 +46,26 @@ CbrDetectorRemote::Result CbrDetectorRemote::Decrypt(cricket::MediaType\
    \ media_ty\n \n \tif (media_type == cricket::MEDIA_TYPE_AUDIO) {\n \t\tif (data_len\
    \ == frame_size && frame_size >= 40) {\n+\t\t\tmissmatch_count = 0;\n \t\t\tframe_count++;\n\
    -\t\t\tif (frame_count > 200 && !detected) {\n+\t\t\tif (frame_count > MIN_MATCH\
    \ && !detected) {\n \t\t\t\tinfo(\"CBR detector: remote cbr detected\\n\");\n\
    \ \t\t\t\tdetected = true;\n \t\t\t}\n \t\t}\n \t\telse {\n-\t\t\tframe_count\
    \ = 0;\n-\t\t\tframe_size = data_len;\n-\t\t\tif (detected) {\n-\t\t\t\tinfo(\"\
    CBR detector: remote cbr detected disabled\\n\");\n-\t\t\t\tdetected = false;\n\
    +\t\t\tmissmatch_count++;\n+\t\t\tif (!detected\n+\t\t\t    || (detected && missmatch_count\
    \ > MAX_MISSMATCH)) {\n+\t\t\t\tframe_count = 0;\n+\t\t\t\tframe_size = data_len;\n\
    +\t\t\t\tmissmatch_count = 0;\n+\t\t\t\tif (detected) {\n+\t\t\t\t\tinfo(\"CBR\
    \ detector: remote cbr detected disabled\\n\");\n+\t\t\t\t\tdetected = false;\n\
    +\t\t\t\t}\n \t\t\t}\n \t\t}\n-\n \t}\n \n \tmemcpy(dst, src, data_len);"
  - "--- a/src/wcall/wcall.c\n+++ b/src/wcall/wcall.c\n@@ -2552,8 +2552,8 @@ int wcall_i_answer(struct\
    \ wcall *wcall,\n \tcall_type = (call_type == WCALL_CALL_TYPE_FORCED_AUDIO) ?\n\
    \ \t\t    WCALL_CALL_TYPE_NORMAL : call_type;\n \n-\tinfo(APITAG \"wcall(%p):\
    \ answer calltype=%s\\n\",\n-\t     wcall, wcall_call_type_name(call_type));\n\
    +\tinfo(APITAG \"wcall(%p): answer calltype=%s cbr=%d\\n\",\n+\t     wcall, wcall_call_type_name(call_type),\
    \ audio_cbr);\n \n \tif (wcall->disable_audio)\n \t\twcall->disable_audio = false;"
  - "--- a/test/test_acm.cpp\n+++ b/test/test_acm.cpp\n@@ -716,7 +716,6 @@ TEST(acm,\
    \ wifi_channel_20ms_20pct_loss)\n     EXPECT_LT( stats.avg_expand_rate, 25.0 );\n\
    \ }\n \n-#if 0\n TEST(acm, wifi_channel_20ms_20pct_loss_fec)\n {\n     float cpu_load;\n\
    @@ -749,4 +748,3 @@ TEST(acm, wifi_channel_20ms_20pct_loss_fec)\n     EXPECT_LT(\
    \ stats.max_expand_rate, 10.0 );\n     EXPECT_LT( stats.avg_expand_rate, 6.0 );\n\
    \ }\n-#endif"
  - "--- a/tools/aueffect/main.c\n+++ b/tools/aueffect/main.c\n@@ -0,0 +1,46 @@\n\
    +#include <ctype.h>\n+#include <getopt.h>\n+#include <stdlib.h>\n+#include <time.h>\n\
    +#include <re.h>\n+#include <avs.h>\n+\n+static void progress_handler(int progress,\
    \ void *arg)\n+{\n+\tprintf(\"Progress=%d\\n\", progress);\n+}\n+\n+\n+static\
    \ void log_handler(uint32_t level, const char *msg, void *arg)\n+{\n+\tfprintf(stdout,\
    \ msg, arg);\n+}\n+\n+\n+struct log log_def = {\n+\t.h = log_handler\n+}; \n+\n\
    +int main(int argc, char *argv[])\n+{\n+\tchar *wavin;\n+\tchar *wavout;\n+\t\
    int err;\n+\n+\tlog_set_min_level(LOG_LEVEL_DEBUG);\n+\t//log_register_handler(&log_def);\n\
    +\t\n+\tif (argc != 3) {\n+\t\tfprintf(stderr, \"Usage: %s wavin wavout\\n\",\
    \ argv[0]);\n+\t\treturn 22;\n+\t}\n+\n+\twavin = argv[1];\n+\twavout = argv[2];\n\
    +\n+\terr = apply_effect_to_wav(wavin, wavout, AUDIO_EFFECT_NONE, false,\n+\t\t\
    \t\t  progress_handler, NULL);\n+\tprintf(\"WAV completed with err=%d\\n\", err);\n\
    +\n+\treturn 0;\n+}"
  - "--- a/tools/netprobe/main.c\n+++ b/tools/netprobe/main.c\n@@ -0,0 +1,477 @@\n\
    +/*\n+* Wire\n+* Copyright (C) 2016 Wire Swiss GmbH\n+*\n+* This program is free\
    \ software: you can redistribute it and/or modify\n+* it under the terms of the\
    \ GNU General Public License as published by\n+* the Free Software Foundation,\
    \ either version 3 of the License, or\n+* (at your option) any later version.\n\
    +*\n+* This program is distributed in the hope that it will be useful,\n+* but\
    \ WITHOUT ANY WARRANTY; without even the implied warranty of\n+* MERCHANTABILITY\
    \ or FITNESS FOR A PARTICULAR PURPOSE. See the\n+* GNU General Public License\
    \ for more details.\n+*\n+* You should have received a copy of the GNU General\
    \ Public License\n+* along with this program. If not, see <http://www.gnu.org/licenses/>.\n\
    +*/\n+/* libavs -- Network Prober\n+ */\n+\n+#include <ctype.h>\n+#include <getopt.h>\n\
    +#include <stdlib.h>\n+#include <time.h>\n+#include <re.h>\n+#include <avs.h>\n\
    +\n+\n+/* Defaults for arguments\n+ */\n+#define DEFAULT_REQUEST_URL \"https://prod-nginz-https.wire.com\"\
    \n+#define DEFAULT_NOTIFICATION_URL \"https://prod-nginz-ssl.wire.com\"\n+#define\
    \ DEV_REQUEST_URL \"https://staging-nginz-https.zinfra.io\"\n+#define DEV_NOTIFICATION_URL\
    \ \"https://staging-nginz-ssl.zinfra.io\"\n+\n+\n+/* Globals\n+ */\n+\n+static\
    \ struct engine *engine = NULL;\n+static struct config *g_config = NULL;\n+static\
    \ struct probe_entry {\n+\tstruct netprobe *np;\n+\tstruct sa turn_srv;\n+\tbool\
    \ secure;\n+\tint proto;\n+} netprobev[32];\n+static size_t netprobec;\n+static\
    \ size_t netprobec_ok;\n+static const char *turn_uri;\n+\n+struct lookup_entry\
    \ {\n+\tstruct zapi_ice_server turn;\n+\tchar *host;\n+\tint port;\n+\tint proto;\n\
    +\tbool secure;\n+\tuint64_t ts;\n+\t\n+\tstruct le le;\n+};\n+\n+\n+static int\
    \ start_netprobe(const struct sa *turn_srv,\n+\t\t\t  int proto, bool secure,\n\
    +\t\t\t  const char *username, const char *password);\n+\n+static void dns_handler(int\
    \ dns_err, const struct sa *srv, void *arg)\n+{\n+\tstruct lookup_entry *lent\
    \ = arg;\n+\tstruct sa turn_srv;\n+\n+\tre_printf(\"DNS lookup for: %s err=%d\\\
    n\", lent->host, dns_err);\n+\tif (dns_err)\n+\t\tgoto out;\n+\n+\tsa_cpy(&turn_srv,\
    \ srv);\n+\tsa_set_port(&turn_srv, lent->port);\n+\n+\tre_printf(\"DNS lookup\
    \ success: %s -> %J(proto=%s secure=%d)\\n\",\n+\t\t  lent->host, &turn_srv, net_proto2name(lent->proto),\n\
    +\t\t  lent->secure);\n+\t\n+\tstart_netprobe(&turn_srv, lent->proto, lent->secure,\n\
    +\t\t       lent->turn.username, lent->turn.credential);\n+ out:\n+\tmem_deref(lent);\n\
    +}\n+\n+\n+static void lent_destructor(void *arg)\n+{\n+\tstruct lookup_entry\
    \ *lent = arg;\n+\n+\tmem_deref(lent->host);\n+}\n+\n+\n+static int turn_dns_lookup(struct\
    \ zapi_ice_server *turn,\n+\t\t\t   struct stun_uri *uri)\n+{\n+\tstruct lookup_entry\
    \ *lent;\n+\tint err = 0;\n+\n+\tlent = mem_zalloc(sizeof(*lent), lent_destructor);\n\
    +\tif (!lent)\n+\t\treturn ENOMEM;\n+\n+\tlent->turn = *turn;\n+\tlent->ts = tmr_jiffies();\n\
    +\tlent->proto = uri->proto;\n+\tlent->secure = uri->secure;\n+\tlent->port =\
    \ uri->port;\n+\terr = str_dup(&lent->host, uri->host);\n+\tif (err)\n+\t\tgoto\
    \ out;\n+\n+\tre_printf(\"dns_lookup for: %s:%d\\n\", lent->host, lent->port);\n\
    +\t\n+\terr = dns_lookup(lent->host, dns_handler, lent);\n+\tif (err) {\n+\t\t\
    warning(\"dns_lookup: failed: %m\\n\", err);\n+\t\tgoto out;\n+\t}\n+ out:\n+\t\
    if (err)\n+\t\tmem_deref(lent);\n+\n+\treturn err;\n+}\n+\n+\n+static void cfg_resp_handler(int\
    \ err, const struct http_msg *msg,\n+\t\t\t     struct mbuf *mb, struct json_object\
    \ *jobj,\n+\t\t\t     void *arg)\n+{\n+\tchar *json_str = NULL;\n+\tstruct zapi_ice_server\
    \ *servers;\n+\tsize_t nservers = 0;\n+\tsize_t i;\n+\n+\tre_printf(\"config ready!\
    \ err=%d\\n\");\n+\tif (err == ECONNABORTED)\n+\t\tgoto out;\n+\n+\tif (!err &&\
    \ jobj) {\n+\t\terr = jzon_encode(&json_str, jobj);\n+\t\tif (err)\n+\t\t\tgoto\
    \ out;\n+\t}\n+\n+\tre_printf(\"CONFIG: %s\\n\", json_str);\n+\n+\tconfig_update(g_config,\
    \ err, json_str, str_len(json_str));\n+\tmem_deref(json_str);\n+\t\n+\tservers\
    \ = config_get_iceservers(g_config, &nservers);\n+\tre_printf(\"Probing: %d servers\\\
    n\", nservers);\n+\n+\tfor (i = 0; i < nservers; ++i) {\n+\t\tstruct zapi_ice_server\
    \ *turn = &servers[i];\n+\t\tstruct stun_uri uri;\n+\n+\t\terr = stun_uri_decode(&uri,\
    \ turn->url);\n+\t\tif (err)\n+\t\t\terr = turn_dns_lookup(turn, &uri);\n+\t\t\
    else {\n+\t\t\tstart_netprobe(&uri.addr, uri.proto, uri.secure,\n+\t\t\t\t   \
    \    turn->username, turn->credential);\n+\t\t}\n+\t}\n+\n+\t\n+ out:\n+\tif (err)\n\
    +\t\terror(\"config request failed: %m\\n\", err);\n+}\n+\n+static int config_req_handler(void\
    \ *arg)\n+{\n+\tprintf(\"requesing config\\n\");\n+\treturn rest_request(NULL,\
    \ engine_get_restcli(engine), 0,\n+\t\t\t    \"GET\", cfg_resp_handler, NULL,\n\
    +\t\t\t    \"/calls/config/v2\", NULL);\n+\t\n+}\n+\n+\n+\n+\n+static void ready_handler(void\
    \ *arg)\n+{\n+\tstruct stun_uri uri;\n+\tint err;\n+\n+\tdns_init(NULL);\n+\t\n\
    +\t(void)uri;\n+\t(void)err;\n+\t\n+\tre_printf(\"engine ready.\\n\");\n+\n+\t\
    config_alloc(&g_config, config_req_handler, NULL, NULL);\n+\tconfig_start(g_config);\n\
    +\n+#if 0\n+\terr = stun_uri_decode(&uri, turn_uri);\n+\tif (err) {\n+\t\twarning(\"\
    netprobe: ready_handler: failed to parse URI: %s\\n\",\n+\t\t\tturn_uri);\n+\t\
    \treturn;\n+\t}\n+\n+\tstart_netprobe(&uri.addr, uri.proto, uri.secure, \"\",\
    \ \"\");\n+#endif\n+}\n+\n+\n+static void error_handler(int err, void *arg)\n\
    +{\n+\terror(\"Engine just broken: %m.\\n\", err);\n+}\n+\n+\n+static void engine_shutdown_handler(void\
    \ *arg)\n+{\n+\t(void) arg;\n+\n+\tre_printf(\"The engine shutted down.\\n\");\n\
    +\tre_cancel();\n+}\n+\n+\n+static void signal_handler(int sig)\n+{\n+\tstatic\
    \ bool term = false;\n+\n+\tif (term) {\n+\t\twarning(\"Aborted.\\n\");\n+\t\t\
    exit(0);\n+\t}\n+\n+\tterm = true;\n+\n+\twarning(\"Terminating ...\\n\");\n+\n\
    +\tengine_shutdown(engine);\n+}\n+\n+\n+static void netprobe_handler(int err,\
    \ const struct netprobe_result *result,\n+\t\t\t     void *arg)\n+{\n+\tstruct\
    \ probe_entry *np;\n+\tsize_t ix = (size_t)arg;\n+\n+\tif (err) {\n+\t\twarning(\"\
    netprobe failed (%m)\\n\", err);\n+\t\tgoto out;\n+\t}\n+\n+\tnp = &netprobev[ix];\n\
    +\n+\tre_printf(\"Network Probe results for %s TURN%s-server at %J\\n\",\n+\t\t\
    \  net_proto2name(np->proto),\n+\t\t  np->secure ? \"S\" : \"\", &np->turn_srv);\n\
    +\tre_printf(\"    Average RTT:   %.1f milliseconds\\n\",\n+\t\t  result->rtt_avg\
    \ / 1000.0);\n+\tre_printf(\"    transmitted:   %u packets\\n\", result->n_pkt_sent);\n\
    +\tre_printf(\"    received:      %u packets\\n\", result->n_pkt_recv);\n+\tre_printf(\"\
    \\n\");\n+\n+ out:\n+\tnetprobec_ok++;\n+\n+\tif (netprobec_ok >= netprobec) {\n\
    +\t\tinfo(\"netprobing done. shutting down..\\n\");\n+\t\tengine_shutdown(engine);\n\
    +\t}\n+}\n+\n+\n+static int start_netprobe(const struct sa *turn_srv,\n+\t\t\t\
    \  int proto, bool secure,\n+\t\t\t  const char *username, const char *password)\n\
    +{\n+\tint err;\n+\n+\tre_printf(\"starting netprobe with TURN%s-server %J\"\n\
    +\t\t  \" (proto=%s) ..\\n\",\n+\t\t  secure ? \"S\" : \"\", turn_srv,\n+\t\t\
    \  net_proto2name(proto));\n+\n+#define PACKET_COUNT 50\n+#define PACKET_INTERVAL\
    \ 20\n+\n+\tif (netprobec >= ARRAY_SIZE(netprobev)) {\n+\t\twarning(\"reached\
    \ maximum %zu netprobes\\n\", netprobec);\n+\t\treturn 0;\n+\t}\n+\n+\tnetprobev[netprobec].turn_srv\
    \ = *turn_srv;\n+\tnetprobev[netprobec].secure = secure;\n+\tnetprobev[netprobec].proto\
    \ = proto;\n+\t\n+\n+\terr = netprobe_alloc(&netprobev[netprobec].np,\n+\t\t\t\
    \     turn_srv, proto, secure,\n+\t\t\t     username, password,\n+\t\t\t     PACKET_COUNT,\
    \ PACKET_INTERVAL,\n+\t\t\t     netprobe_handler, (void *)netprobec);\n+\tif (err)\
    \ {\n+\t\twarning(\"could not create netprobe (%m)\\n\", err);\n+\t\tgoto out;\n\
    +\t}\n+\n+\tnetprobec++;\n+\n+ out:\n+\treturn err;\n+}\n+\n+\n+static void usage(void)\n\
    +{\n+\t(void)re_fprintf(stderr,\n+\t\t\t \"usage: netprobe [-dh] -e <email> -p\
    \ <password>\"\n+\t\t\t \" [-r <url> -n <url>] [-t] [-t] [-d] [-d]\"\n+\t\t\t\
    \ \" [-l <path>]\"\n+\t\t\t \"\\n\");\n+\t(void)re_fprintf(stderr, \"\\t-c <path>\
    \      config and cache \"\n+\t\t\t\t \t\t  \"directory\\n\");\n+\t(void)re_fprintf(stderr,\
    \ \"\\t-d             Turn on debugging \"\n+\t\t\t                          \"\
    (twice for more)\\n\");\n+\t(void)re_fprintf(stderr, \"\\t-e <email>     Email\
    \ address\\n\");\n+\t(void)re_fprintf(stderr, \"\\t-p <password>  Password\\n\"\
    );\n+\t(void)re_fprintf(stderr, \"\\t-l <path>      Send debug log to file\\n\"\
    );\n+\t(void)re_fprintf(stderr, \"\\t-n <url>       Backend notification URL\"\
    \n+\t\t\t\t \" (optional)\\n\");\n+\t(void)re_fprintf(stderr, \"\\t-r <url>  \
    \     Backend request URL\"\n+\t\t\t\t \" (optional)\\n\");\n+\t(void)re_fprintf(stderr,\
    \ \"\\t-D             Use dev environment\\n\");\n+\t(void)re_fprintf(stderr,\
    \ \"\\t-u <TURN>      Force a TURN uri\\n\");\n+\n+\t(void)re_fprintf(stderr,\
    \ \"\\t-h             Show options\\n\");\n+\t(void)re_fprintf(stderr, \"\\n\"\
    );\n+\t(void)re_fprintf(stderr, \"URLs default to regular backend.\\n\");\n+}\n\
    +\n+\n+int main(int argc, char *argv[])\n+{\n+\tconst char *email = NULL;\n+\t\
    const char *password = NULL;\n+\tconst char *request_uri = DEFAULT_REQUEST_URL;\n\
    +\tconst char *notification_uri = DEFAULT_NOTIFICATION_URL;\n+\tenum log_level\
    \ level = LOG_LEVEL_WARN;\n+\tsize_t i;\n+\n+\tint err = 0;\n+\n+\tfor (;;) {\n\
    +\t\tconst int c = getopt(argc, argv, \"de:l:n:p:r:tDu:\");\n+\t\tif (c < 0)\n\
    +\t\t\tbreak;\n+\n+\t\tswitch (c) {\n+\n+\t\tcase 'd':\n+\t\t\tif (level == LOG_LEVEL_INFO)\n\
    +\t\t\t\tlevel = LOG_LEVEL_DEBUG;\n+\t\t\telse\n+\t\t\t\tlevel = LOG_LEVEL_INFO;\n\
    +\t\t\tbreak;\n+\n+\t\tcase 'D':\n+\t\t\trequest_uri = DEV_REQUEST_URL;\n+\t\t\
    \tnotification_uri = DEV_NOTIFICATION_URL;\n+\t\t\tbreak;\n+\n+\t\tcase 'e':\n\
    +\t\t\temail = optarg;\n+\t\t\tbreak;\n+\n+\t\tcase 'n':\n+\t\t\tnotification_uri\
    \ = optarg;\n+\t\t\tbreak;\n+\n+\t\tcase 'p':\n+\t\t\tpassword = optarg;\n+\t\t\
    \tbreak;\n+\n+\t\tcase 'r':\n+\t\t\trequest_uri = optarg;\n+\t\t\tbreak;\n+\n\
    +\t\tcase 'u':\n+\t\t\tturn_uri = optarg;\n+\t\t\tbreak;\n+\n+\t\tcase '?':\n\
    +\t\t\terr = EINVAL;\n+\t\t\t/* fall through */\n+\t\tcase 'h':\n+\t\t\tusage();\n\
    +\t\t\treturn err;\n+\t\t}\n+\t}\n+\n+\tlog_set_min_level(level);\n+\n+\tif (email\
    \ == NULL) {\n+\t\t(void)re_fprintf(stderr, \"Missing email.\\n\");\n+\t\terr\
    \ = EINVAL;\n+\t\tgoto out;\n+\t}\n+\tif (password == NULL) {\n+\t\t(void)re_fprintf(stderr,\
    \ \"Missing password.\\n\");\n+\t\terr = EINVAL;\n+\t\tgoto out;\n+\t}\n+\n+\t\
    err = libre_init();\n+\tif (err) {\n+\t\t(void)re_fprintf(stderr, \"libre init\
    \ failed: %m\\n\", err);\n+\t\tgoto out;\n+\t}\n+\n+\terr = avs_init(AVS_FLAG_EXPERIMENTAL);\n\
    +\tif (err) {\n+\t\t(void)re_fprintf(stderr, \"avs init failed: %m\\n\", err);\n\
    +\t\tgoto out;\n+\t}\n+\n+\tsys_coredump_set(true);\n+\n+\terr = engine_init(\"\
    audummy\");\n+\tif (err) {\n+\t\t(void)re_fprintf(stderr, \"engine init failed:\
    \ %m\\n\", err);\n+\t\tgoto out;\n+\t}\n+\n+\terr = engine_alloc(&engine, request_uri,\
    \ notification_uri, email,\n+\t\t\t   password, NULL, false, false,\n+\t\t\t \
    \  \"netprobe/\" AVS_VERSION,\n+\t\t\t   ready_handler, error_handler,\n+\t\t\t\
    \   engine_shutdown_handler, 0);\n+\tif (err) {\n+\t\t(void)re_fprintf(stderr,\
    \ \"Engine init failed: %m\\n\", err);\n+\t\tgoto out;\n+\t}\n+\n+\terr = re_main(signal_handler);\n\
    +\n+ out:\n+\tfor (i=0; i<netprobec; i++)\n+\t\tmem_deref(netprobev[i].np);\n\
    +\n+\tmem_deref(g_config);\n+\tmem_deref(engine);\n+\n+\tengine_close();\n+\t\
    dns_close();\n+\n+\tlibre_close();\n+\n+\t/* check for memory leaks */\n+\tmem_debug();\n\
    +\ttmr_debug();\n+\n+\tif (err) {\n+\t\treturn 1;\n+\t}\n+\telse {\n+\t\treturn\
    \ 0;\n+\t}\n+}"
  - "--- a/tools/verifyd/main.c\n+++ b/tools/verifyd/main.c\n@@ -0,0 +1,448 @@\n+/*\n\
    +* Wire\n+* Copyright (C) 2016 Wire Swiss GmbH\n+*\n+* This program is free software:\
    \ you can redistribute it and/or modify\n+* it under the terms of the GNU General\
    \ Public License as published by\n+* the Free Software Foundation, either version\
    \ 3 of the License, or\n+* (at your option) any later version.\n+*\n+* This program\
    \ is distributed in the hope that it will be useful,\n+* but WITHOUT ANY WARRANTY;\
    \ without even the implied warranty of\n+* MERCHANTABILITY or FITNESS FOR A PARTICULAR\
    \ PURPOSE. See the\n+* GNU General Public License for more details.\n+*\n+* You\
    \ should have received a copy of the GNU General Public License\n+* along with\
    \ this program. If not, see <http://www.gnu.org/licenses/>.\n+*/\n+\n+#define\
    \ _BSD_SOURCE 1\n+#define _DEFAULT_SOURCE 1\n+#include <getopt.h>\n+#include <stdio.h>\n\
    +#include <re.h>\n+#include <avs.h>\n+\n+\n+struct ident_entry {\n+\tuint64_t\
    \ id;\n+\tchar *ident;\n+\n+\tstruct {\n+\t\tchar *publish;\n+\t\tchar *accept;\n\
    +\t} content;\n+};\n+\n+\n+static struct {\n+\tstruct http_sock *sock;\n+\tstruct\
    \ tmr tmr;\n+\tstruct dict *idents;\n+} verifyd = {\n+\t.sock = NULL,\n+};\n+\n\
    +\n+static void ie_destructor(void *arg)\n+{\n+\tstruct ident_entry *ie = arg;\n\
    +\n+\tmem_deref(ie->content.publish);\n+\tmem_deref(ie->content.accept);\n+\t\
    mem_deref(ie->ident);\n+}\n+\n+\n+static void handle_post_create(struct http_conn\
    \ *conn,\n+\t\t\t       struct mbuf *mb, size_t clen)\n+{\n+\tstruct ident_entry\
    \ *ie = NULL;\n+\tuint64_t ident;\n+\tchar key[256];\n+\tint err = 0;\n+\n+\t\
    ident = 1 + rand_u64() & 0xf;  // XXX for testing\n+\n+\tre_snprintf(key, sizeof(key),\
    \ \"%llu\", ident);\n+\n+\tinfo(\"POST: new pairing id %llu\\n\", ident);\n+\n\
    +\tie = mem_zalloc(sizeof(*ie), ie_destructor);\n+\n+\tie->id = ident;\n+\tstr_dup(&ie->ident,\
    \ key);\n+\n+\terr = dict_add(verifyd.idents, key, ie);\n+\tif (err)\n+\t\tgoto\
    \ out;\n+\n+\tmem_deref(ie); /* Owned by the dictionary */\n+\n+\thttp_creply(conn,\
    \ 200, \"OK\",\n+\t\t    \"application/json\",\n+\t\t    \"{\\\"pairid\\\":\\\"\
    %llu\\\"}\", ident);\n+\n+ out:\n+\tif (err) {\n+\t\twarning(\"internal error\
    \ (%m)\\n\" ,err);\n+\t}\n+}\n+\n+\n+static void handle_put_publish(struct http_conn\
    \ *conn,\n+\t\t\t       const struct http_msg *msg,\n+\t\t\t       struct mbuf\
    \ *mb, size_t clen)\n+{\n+\tstruct ident_entry *ie = NULL;\n+\tstruct pl pl;\n\
    +\tchar *key = NULL;\n+\tint err;\n+\n+\terr = re_regex(msg->prm.p, msg->prm.l,\
    \ \"?pairid=[0-9]+\", &pl);\n+\tif (err) {\n+\t\twarning(\"invalid input\\n\"\
    );\n+\t\tgoto out;\n+\t}\n+\n+\tpl_strdup(&key, &pl);\n+\n+\tie = dict_lookup(verifyd.idents,\
    \ key);\n+\tif (!ie) {\n+\t\tinfo(\"publish: pairing-id %s not found\\n\", key);\n\
    +\t\thttp_ereply(conn, 404, \"Not found\");\n+\t\tgoto out;\n+\t}\n+\n+\tdebug(\"\
    publish: saving content(%zu): %b\\n\",\n+\t\t  clen, mbuf_buf(mb), mbuf_get_left(mb));\n\
    +\n+\tmbuf_strdup(mb, &ie->content.publish, clen);\n+\n+\thttp_reply(conn, 200,\
    \ \"OK\", NULL);\n+\n+\thttp_conn_close(conn);\n+\n+ out:\n+\tmem_deref(key);\n\
    +}\n+\n+\n+static void handle_put_accept(struct http_conn *conn,\n+\t\t\t    \
    \  const struct http_msg *msg,\n+\t\t\t      struct mbuf *mb, size_t clen)\n+{\n\
    +\tstruct ident_entry *ie = NULL;\n+\tstruct pl pl;\n+\tchar *key = NULL;\n+\t\
    int err;\n+\n+\terr = re_regex(msg->prm.p, msg->prm.l, \"?pairid=[0-9]+\", &pl);\n\
    +\tif (err) {\n+\t\twarning(\"invalid input\\n\");\n+\t\tgoto out;\n+\t}\n+\n\
    +\tpl_strdup(&key, &pl);\n+\n+\tie = dict_lookup(verifyd.idents, key);\n+\tif\
    \ (!ie) {\n+\t\tinfo(\"accept: pairing-id %s not found\\n\", key);\n+\t\thttp_ereply(conn,\
    \ 404, \"Not found\");\n+\t\tgoto out;\n+\t}\n+\n+\tdebug(\"accept: saving content(%zu):\
    \ %b\\n\",\n+\t\t  clen, mbuf_buf(mb), mbuf_get_left(mb));\n+\n+\tmbuf_strdup(mb,\
    \ &ie->content.accept, clen);\n+\n+\thttp_reply(conn, 200, \"OK\", NULL);\n+\n\
    +\thttp_conn_close(conn);\n+\n+ out:\n+\tmem_deref(key);\n+}\n+\n+\n+static void\
    \ handle_get_publish(struct http_conn *conn,\n+\t\t\t       const struct http_msg\
    \ *msg,\n+\t\t\t       struct mbuf *mb, size_t clen)\n+{\n+\tstruct ident_entry\
    \ *ie = NULL;\n+\tstruct pl pl;\n+\tchar *key = NULL;\n+\tint err;\n+\n+\tinfo(\"\
    handle get publish\\n\");\n+\n+\terr = re_regex(msg->prm.p, msg->prm.l, \"?pairid=[0-9]+\"\
    , &pl);\n+\tif (err) {\n+\t\twarning(\"invalid input\\n\");\n+\t\tgoto out;\n\
    +\t}\n+\n+\tpl_strdup(&key, &pl);\n+\n+\tie = dict_lookup(verifyd.idents, key);\n\
    +\tif (!ie) {\n+\t\tinfo(\"publish: pairing-id %s not found\\n\", key);\n+\t\t\
    http_ereply(conn, 404, \"Not found\");\n+\t\tgoto out;\n+\t}\n+\n+\tdebug(\"handle\
    \ get publish (content=%s)\\n\", ie->content.publish);\n+\n+\tif (ie->content.publish)\
    \ {\n+\t\thttp_creply(conn, 200, \"OK\",\n+\t\t\t    \"application/json\", \"\
    %s\", ie->content.publish);\n+\t}\n+\telse {\n+\t\thttp_ereply(conn, 404, \"Not\
    \ Yet\");\n+\t}\n+\n+\thttp_conn_close(conn);\n+\n+ out:\n+\tmem_deref(key);\n\
    +}\n+\n+\n+static void handle_get_accept(struct http_conn *conn,\n+\t\t\t    \
    \  const struct http_msg *msg,\n+\t\t\t      struct mbuf *mb, size_t clen)\n+{\n\
    +\tstruct ident_entry *ie = NULL;\n+\tstruct pl pl;\n+\tchar *key = NULL;\n+\t\
    int err;\n+\n+\tinfo(\"handle get accept\\n\");\n+\n+\terr = re_regex(msg->prm.p,\
    \ msg->prm.l, \"?pairid=[0-9]+\", &pl);\n+\tif (err) {\n+\t\twarning(\"invalid\
    \ input\\n\");\n+\t\tgoto out;\n+\t}\n+\n+\tpl_strdup(&key, &pl);\n+\n+\tie =\
    \ dict_lookup(verifyd.idents, key);\n+\tif (!ie) {\n+\t\tinfo(\"accept: pairing-id\
    \ %s not found\\n\", key);\n+\t\thttp_ereply(conn, 404, \"Not found\");\n+\t\t\
    goto out;\n+\t}\n+\n+\tdebug(\"handle get accept (content=%s)\\n\", ie->content.accept);\n\
    +\n+\tif (ie->content.accept) {\n+\t\thttp_creply(conn, 200, \"OK\",\n+\t\t\t\
    \    \"application/json\", \"%s\", ie->content.accept);\n+\t}\n+\telse {\n+\t\t\
    http_ereply(conn, 404, \"Not Yet\");\n+\t}\n+\n+\thttp_conn_close(conn);\n+\n\
    + out:\n+\tmem_deref(key);\n+}\n+\n+\n+static void http_req_handler(struct http_conn\
    \ *conn,\n+\t\t\t     const struct http_msg *msg, void *arg)\n+{\n+\tstruct mbuf\
    \ *mb = mbuf_alloc(1024);\n+\tint err = 0;\n+\t(void)arg;\n+\n+\tinfo(\"restsrv:\
    \ request %r %r%r from %J\\n\",\n+\t     &msg->met, &msg->path, &msg->prm,\n+\t\
    \     http_conn_peer(conn));\n+\n+\tif (0 == pl_strcasecmp(&msg->met, \"POST\"\
    ) &&\n+\t    0 == pl_strcasecmp(&msg->path, \"/create\")) {\n+\n+\t\thandle_post_create(conn,\
    \ msg->mb, (size_t)msg->clen);\n+\t}\n+\telse if (0 == pl_strcasecmp(&msg->met,\
    \ \"PUT\") &&\n+\t\t 0 == pl_strcasecmp(&msg->path, \"/publish\")) {\n+\n+\t\t\
    handle_put_publish(conn, msg, msg->mb, (size_t)msg->clen);\n+\t}\n+\telse if (0\
    \ == pl_strcasecmp(&msg->met, \"PUT\") &&\n+\t\t 0 == pl_strcasecmp(&msg->path,\
    \ \"/accept\")) {\n+\n+\t\thandle_put_accept(conn, msg, msg->mb, (size_t)msg->clen);\n\
    +\t}\n+\telse if (0 == pl_strcasecmp(&msg->met, \"GET\") &&\n+\t\t 0 == pl_strcasecmp(&msg->path,\
    \ \"/publish\")) {\n+\n+\t\thandle_get_publish(conn, msg, msg->mb, (size_t)msg->clen);\n\
    +\t}\n+\telse if (0 == pl_strcasecmp(&msg->met, \"GET\") &&\n+\t\t 0 == pl_strcasecmp(&msg->path,\
    \ \"/accept\")) {\n+\n+\t\thandle_get_accept(conn, msg, msg->mb, (size_t)msg->clen);\n\
    +\t}\n+\telse {\n+\t\twarning(\"no such resource\\n\");\n+\t\terr = ENOENT;\n\
    +\t\tgoto out;\n+\t}\n+\n+ out:\n+\tif (err) {\n+\t\thttp_ereply(conn, 400, \"\
    Bad Request\");\n+\t\twarning(\"restsrv: response 400 Bad Request (%m)\\n\", err);\n\
    +\n+\t\thttp_conn_close(conn);\n+\t}\n+\n+\tmem_deref(mb);\n+}\n+\n+\n+static\
    \ int srv_init(uint16_t lport)\n+{\n+\tstruct sa laddr;\n+\tstruct tcp_sock *tsock;\n\
    +\tint err;\n+\n+\tinfo(\"srv_init: lport=%d\\n\", (int)lport);\n+\n+\terr = sa_set_str(&laddr,\
    \ \"0.0.0.0\", lport);\n+\tif (err)\n+\t\treturn err;\n+\n+\terr = http_listen(&verifyd.sock,\
    \ &laddr, http_req_handler, NULL);\n+\tif (err) {\n+\t\tre_fprintf(stderr, \"\
    http_listen: failed: %m\\n\", err);\n+\t\treturn err;\n+\t}\n+\n+\ttsock = http_sock_tcp(verifyd.sock);\n\
    +\tif (tsock) {\n+\t\ttcp_sock_local_get(tsock, &laddr);\n+\t}\n+\n+\tre_fprintf(stderr,\
    \ \"verifyd: listening on %J\\n\", &laddr);\n+\n+\treturn 0;\n+}\n+\n+\n+static\
    \ void srv_close(void)\n+{\n+\tverifyd.sock = mem_deref(verifyd.sock);\n+}\n+\n\
    +\n+static void signal_handler(int sig)\n+{\n+\tstatic bool term = false;\n+\n\
    +\tif (term) {\n+\t\twarning(\"Aborted.\\n\");\n+\t\texit(0);\n+\t}\n+\n+\tterm\
    \ = true;\n+\n+\twarning(\"Terminating ...\\n\");\n+\n+\tre_cancel();\n+}\n+\n\
    +\n+static void usage(const char *cmd)\n+{\n+\tre_fprintf(stderr, \"usage: %s\
    \ -p <port>\\n\", cmd);\n+}\n+\n+\n+static void init_timeout(void *arg)\n+{\n\
    +\tint local_port = *(int *)arg;\n+\n+\tinfo(\"init_timeout: srv_init\\n\");\n\
    +\tsrv_init((uint16_t)local_port);\n+}\n+\n+\n+int main(int argc, char **argv)\n\
    +{\n+\tint local_port = -1;\n+\tint err = 0;\n+\n+\tfor (;;) {\n+\t\tconst int\
    \ c = getopt(argc, argv, \"p:\");\n+\n+\t\tif (c < 0)\n+\t\t\tbreak;\n+\n+\t\t\
    switch (c) {\n+\n+\t\tcase 'p':\n+\t\t\tlocal_port = atoi(optarg);\n+\t\t\tbreak;\n\
    +\n+\t\tdefault:\n+\t\t\tbreak;\n+\n+\t\t}\n+\t}\n+\n+\tif (local_port == -1)\
    \ {\n+\t\tusage(argv[0]);\n+\t\terr = EINVAL;\n+\t\tgoto out;\n+\t}\n+\n+\terr\
    \ = libre_init();\n+\tif (err) {\n+\t\t(void)re_fprintf(stderr, \"libre init failed:\
    \ %m\\n\", err);\n+\t\tgoto out;\n+\t}\n+\n+\terr = avs_init(0);\n+\tif (err)\
    \ {\n+\t\t(void)re_fprintf(stderr, \"avs init failed: %m\\n\", err);\n+\t\tgoto\
    \ out;\n+\t}\n+\n+\terr = dict_alloc(&verifyd.idents);\n+\tif (err) {\n+\t\tre_fprintf(stderr,\n\
    +\t\t\t   \"%s: cannot alloc idetifier dictionary: %m\\n\",\n+\t\t\t   argv[0],\
    \ err);\n+\t\tgoto out;\n+\t}\n+\n+\tlog_set_min_level(LOG_LEVEL_INFO);\n+\n+\t\
    tmr_init(&verifyd.tmr);\n+\n+\ttmr_start(&verifyd.tmr, 1, init_timeout, &local_port);\n\
    +\n+\tre_printf(\"re_main\\n\");\n+\tre_main(signal_handler);\n+\tre_printf(\"\
    re_main DONE!\\n\");\n+\n+ out:\n+\ttmr_cancel(&verifyd.tmr);\n+\tmem_deref(verifyd.idents);\n\
    +\n+\tsrv_close();\n+\n+\tlibre_close();\n+\n+\t/* check for memory leaks */\n\
    +\tmem_debug();\n+\ttmr_debug();\n+\n+\treturn err;\n+}"
  - "--- a/tools/zcall/conv.c\n+++ b/tools/zcall/conv.c\n@@ -1277,6 +1276,10 @@ static\
    \ void prekey_handler(const char *userid,\n \t\t\t\terr);\n \t\t}\n \t}\n+\n+\t\
    if (last) {\n+\t\toutput(\"prekey_handler: all prekeys fetched\\n\");\n+\t}\n\
    \ }\n \n "
  identifiers:
  - CVE-2021-41193
  - CWE-134
  overview: wire-avs is the audio visual signaling (AVS) component of Wire, an open-source
    messenger. A remote format string vulnerability in versions prior to 7.1.12 allows
    an attacker to cause a denial of service or possibly execute arbitrary code. The
    issue has been fixed in wire-avs 7.1.12. There are currently no known workarounds.
  references:
  - source: security-advisories@github.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/wireapp/wire-avs/commit/40d373ede795443ae6f2f756e9fb1f4f4ae90bbe
  - source: security-advisories@github.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/wireapp/wire-avs/security/advisories/GHSA-2j6v-xpf3-xvrv
  title: wire-avs is the audio visual signaling (AVS) component of Wire, an open-source
    messenger. A remote format string vulnerability in versions prior to 7.1.12 allows
    an attacker to cause a denial of service or possibly execute arbitrary code. The
    issue has been fixed in wire-avs 7.1.12. There are currently no known workarounds.
- diff_content:
  - "--- a/src/devices/cmr113.c\n+++ b/src/devices/cmr113.c\n@@ -42,8 +42,8 @@ Kudos\
    \ to Jon Oxer for decoding this stream and putting it here:\n \n */\n \n-#define\
    \ COMPARE_BITS 83\n-#define COMPARE_BYTES (COMPARE_BITS/8)\n+#define COMPARE_BITS\
    \  83\n+#define COMPARE_BYTES ((COMPARE_BITS + 7) / 8)\n \n static int cmr113_decode(r_device\
    \ *decoder, bitbuffer_t *bitbuffer)\n {"
  - "--- a/src/devices/somfy_iohc.c\n+++ b/src/devices/somfy_iohc.c\n@@ -100,11 +100,12\
    \ @@ static int somfy_iohc_decode(r_device *decoder, bitbuffer_t *bitbuffer)\n\
    \     if (bitbuffer->num_rows != 1)\n         return DECODE_ABORT_EARLY;\n \n\
    -    int offset = bitbuffer_search(bitbuffer, 0, 0, preamble_pattern, 24) + 24;\n\
    -    if (offset >= bitbuffer->bits_per_row[0] - 19 * 10)\n+    unsigned offset\
    \ = bitbuffer_search(bitbuffer, 0, 0, preamble_pattern, 24) + 24;\n+    if (offset\
    \ + 19 * 10 >= bitbuffer->bits_per_row[0])\n         return DECODE_ABORT_EARLY;\n\
    \ \n-    int num_bits = bitbuffer->bits_per_row[0] - offset;\n+    unsigned num_bits\
    \ = bitbuffer->bits_per_row[0] - offset;\n+    num_bits = MIN(num_bits, sizeof\
    \ (b) * 8);\n \n     int len = extract_bytes_uart(bitbuffer->bb[0], offset, num_bits,\
    \ b);\n     if (len < 19)\n@@ -120,7 +121,7 @@ static int somfy_iohc_decode(r_device\
    \ *decoder, bitbuffer_t *bitbuffer)\n     // calculate and verify checksum\n \
    \    if (crc16lsb(b, len, 0x8408, 0x0000) != 0) // unreflected poly 0x1021\n \
    \        return DECODE_FAIL_MIC;\n-    bitrow_printf(b, len * 8, \"%s: offset\
    \ %d, num_bits %d, len %d, msg_len %d\\n\", __func__, offset, num_bits, len, msg_len);\n\
    +    bitrow_printf(b, len * 8, \"%s: offset %u, num_bits %u, len %d, msg_len %d\\\
    n\", __func__, offset, num_bits, len, msg_len);\n \n     int msg_type = (b[0]);\n\
    \     int dst_id   = ((unsigned)b[4] << 24) | (b[3] << 16) | (b[2] << 8) | (b[1]);\
    \ // assume Little-Endian"
  identifiers:
  - CVE-2022-25050
  - CWE-787
  overview: rtl_433 21.12 was discovered to contain a stack overflow in the function
    somfy_iohc_decode(). This vulnerability allows attackers to cause a Denial of
    Service (DoS) via a crafted file.
  references:
  - source: cve@mitre.org
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/merbanan/rtl_433/commit/2dad7b9fc67a1d0bfbe520fbd821678b8f8cc7a8
  - source: cve@mitre.org
    tags:
    - Issue Tracking
    - Patch
    - Third Party Advisory
    url: https://github.com/merbanan/rtl_433/issues/1960
  - source: cve@mitre.org
    tags:
    - Permissions Required
    - Third Party Advisory
    url: https://huntr.dev/bounties/6c9cd35f-a206-4fdf-b6d1-fcd50926c2d9/
  title: rtl_433 21.12 was discovered to contain a stack overflow in the function
    somfy_iohc_decode(). This vulnerability allows attackers to cause a Denial of
    Service (DoS) via a crafted file.
- diff_content:
  - "--- a/src/devices/cmr113.c\n+++ b/src/devices/cmr113.c\n@@ -42,8 +42,8 @@ Kudos\
    \ to Jon Oxer for decoding this stream and putting it here:\n \n */\n \n-#define\
    \ COMPARE_BITS 83\n-#define COMPARE_BYTES (COMPARE_BITS/8)\n+#define COMPARE_BITS\
    \  83\n+#define COMPARE_BYTES ((COMPARE_BITS + 7) / 8)\n \n static int cmr113_decode(r_device\
    \ *decoder, bitbuffer_t *bitbuffer)\n {"
  - "--- a/src/devices/somfy_iohc.c\n+++ b/src/devices/somfy_iohc.c\n@@ -100,11 +100,12\
    \ @@ static int somfy_iohc_decode(r_device *decoder, bitbuffer_t *bitbuffer)\n\
    \     if (bitbuffer->num_rows != 1)\n         return DECODE_ABORT_EARLY;\n \n\
    -    int offset = bitbuffer_search(bitbuffer, 0, 0, preamble_pattern, 24) + 24;\n\
    -    if (offset >= bitbuffer->bits_per_row[0] - 19 * 10)\n+    unsigned offset\
    \ = bitbuffer_search(bitbuffer, 0, 0, preamble_pattern, 24) + 24;\n+    if (offset\
    \ + 19 * 10 >= bitbuffer->bits_per_row[0])\n         return DECODE_ABORT_EARLY;\n\
    \ \n-    int num_bits = bitbuffer->bits_per_row[0] - offset;\n+    unsigned num_bits\
    \ = bitbuffer->bits_per_row[0] - offset;\n+    num_bits = MIN(num_bits, sizeof\
    \ (b) * 8);\n \n     int len = extract_bytes_uart(bitbuffer->bb[0], offset, num_bits,\
    \ b);\n     if (len < 19)\n@@ -120,7 +121,7 @@ static int somfy_iohc_decode(r_device\
    \ *decoder, bitbuffer_t *bitbuffer)\n     // calculate and verify checksum\n \
    \    if (crc16lsb(b, len, 0x8408, 0x0000) != 0) // unreflected poly 0x1021\n \
    \        return DECODE_FAIL_MIC;\n-    bitrow_printf(b, len * 8, \"%s: offset\
    \ %d, num_bits %d, len %d, msg_len %d\\n\", __func__, offset, num_bits, len, msg_len);\n\
    +    bitrow_printf(b, len * 8, \"%s: offset %u, num_bits %u, len %d, msg_len %d\\\
    n\", __func__, offset, num_bits, len, msg_len);\n \n     int msg_type = (b[0]);\n\
    \     int dst_id   = ((unsigned)b[4] << 24) | (b[3] << 16) | (b[2] << 8) | (b[1]);\
    \ // assume Little-Endian"
  identifiers:
  - CVE-2022-25051
  - CWE-193
  overview: An Off-by-one Error occurs in cmr113_decode of rtl_433 21.12 when decoding
    a crafted file.
  references:
  - source: cve@mitre.org
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/merbanan/rtl_433/commit/2dad7b9fc67a1d0bfbe520fbd821678b8f8cc7a8
  - source: cve@mitre.org
    tags:
    - Issue Tracking
    - Third Party Advisory
    url: https://github.com/merbanan/rtl_433/issues/1960
  - source: cve@mitre.org
    tags:
    - Permissions Required
    - Third Party Advisory
    url: https://huntr.dev/bounties/78eee103-bd61-4b4f-b054-04ad996b39e7/
  title: An Off-by-one Error occurs in cmr113_decode of rtl_433 21.12 when decoding
    a crafted file.
- diff_content:
  - "--- a/src/http_ana.c\n+++ b/src/http_ana.c\n@@ -3418,7 +3418,7 @@ static void\
    \ http_manage_server_side_cookies(struct stream *s, struct channel *re\n \twhile\
    \ (1) {\n \t\tint is_first = 1;\n \n-\t\tif (!http_find_header(htx, ist(\"Set-Cookie\"\
    ), &ctx, 1)) {\n+\t\tif (is_cookie2 || !http_find_header(htx, ist(\"Set-Cookie\"\
    ), &ctx, 1)) {\n \t\t\tif (!http_find_header(htx, ist(\"Set-Cookie2\"), &ctx,\
    \ 1))\n \t\t\t\tbreak;\n \t\t\tis_cookie2 = 1;"
  identifiers:
  - CVE-2022-0711
  - CWE-835
  overview: A flaw was found in the way HAProxy processed HTTP responses containing
    the "Set-Cookie2" header. This flaw could allow an attacker to send crafted HTTP
    response packets which lead to an infinite loop, eventually resulting in a denial
    of service condition. The highest threat from this vulnerability is availability.
  references:
  - source: secalert@redhat.com
    tags:
    - Third Party Advisory
    url: https://access.redhat.com/security/cve/cve-2022-0711
  - source: secalert@redhat.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/haproxy/haproxy/commit/bfb15ab34ead85f64cd6da0e9fb418c9cd14cee8
  - source: secalert@redhat.com
    tags:
    - Third Party Advisory
    url: https://www.debian.org/security/2022/dsa-5102
  - source: secalert@redhat.com
    url: https://www.mail-archive.com/haproxy%40formilux.org/msg41833.html
  title: A flaw was found in the way HAProxy processed HTTP responses containing the
    "Set-Cookie2" header. This flaw could allow an attacker to send crafted HTTP response
    packets which lead to an infinite loop, eventually resulting in a denial of service
    condition. The highest threat from this vulnerability is availability.
- diff_content:
  - "--- a/htmldoc/file.c\n+++ b/htmldoc/file.c\n@@ -304,6 +304,7 @@ const char *\t\
    \t\t/* O - File extension */\n file_extension(const char *s)\t/* I - Filename\
    \ or URL */\n {\n   const char\t*extension;\t/* Pointer to directory separator\
    \ */\n+  char\t\t*bufptr;\t/* Pointer into buffer */\n   static char\tbuf[1024];\t\
    /* Buffer for files with targets */\n \n \n@@ -334,7 +335,8 @@ file_extension(const\
    \ char *s)\t/* I - Filename or URL */\n \n   strlcpy(buf, extension, sizeof(buf));\n\
    \ \n-  *(char *)strchr(buf, '#') = '\\0';\n+  if ((bufptr = strchr(buf, '#'))\
    \ != NULL)\n+    *bufptr = '\\0';\n \n   return (buf);\n }"
  identifiers:
  - CVE-2021-23180
  - CWE-476
  overview: A flaw was found in htmldoc in v1.9.12 and before. Null pointer dereference
    in file_extension(),in file.c may lead to execute arbitrary code and denial of
    service.
  references:
  - source: secalert@redhat.com
    tags:
    - Issue Tracking
    - Patch
    - Third Party Advisory
    url: https://bugzilla.redhat.com/show_bug.cgi?id=1967041
  - source: secalert@redhat.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/michaelrsweet/htmldoc/commit/19c582fb32eac74b57e155cffbb529377a9e751a
  - source: secalert@redhat.com
    tags:
    - Exploit
    - Issue Tracking
    - Third Party Advisory
    url: https://github.com/michaelrsweet/htmldoc/issues/418
  - source: secalert@redhat.com
    tags:
    - Third Party Advisory
    url: https://ubuntu.com/security/CVE-2021-23180
  title: A flaw was found in htmldoc in v1.9.12 and before. Null pointer dereference
    in file_extension(),in file.c may lead to execute arbitrary code and denial of
    service.
- diff_content:
  - "--- a/htmldoc/file.c\n+++ b/htmldoc/file.c\n@@ -1010,8 +1010,15 @@ file_rlookup(const\
    \ char *filename)\t/* I - Filename */\n \n \n   for (i = web_files, wc = web_cache;\
    \ i > 0; i --, wc ++)\n+  {\n     if (!strcmp(wc->name, filename))\n-      return\
    \ (wc->url);\n+    {\n+      if (!strncmp(wc->url, \"data:\", 5))\n+        return\
    \ (\"data URL\");\n+      else\n+        return (wc->url);\n+    }\n+  }\n \n\
    \   return (filename);\n }"
  identifiers:
  - CVE-2021-23191
  - CWE-476
  overview: A security issue was found in htmldoc v1.9.12 and before. A NULL pointer
    dereference in the function image_load_jpeg() in image.cxx may result in denial
    of service.
  references:
  - source: secalert@redhat.com
    tags:
    - Issue Tracking
    - Patch
    - Third Party Advisory
    url: https://bugzilla.redhat.com/show_bug.cgi?id=1967022
  - source: secalert@redhat.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/michaelrsweet/htmldoc/commit/369b2ea1fd0d0537ba707f20a2f047b6afd2fbdc
  - source: secalert@redhat.com
    tags:
    - Exploit
    - Issue Tracking
    - Third Party Advisory
    url: https://github.com/michaelrsweet/htmldoc/issues/415
  - source: secalert@redhat.com
    tags:
    - Third Party Advisory
    url: https://ubuntu.com/security/CVE-2021-23191
  title: A security issue was found in htmldoc v1.9.12 and before. A NULL pointer
    dereference in the function image_load_jpeg() in image.cxx may result in denial
    of service.
- diff_content:
  - "--- a/src/interfaces/libpq/fe-connect.c\n+++ b/src/interfaces/libpq/fe-connect.c\n\
    @@ -3097,6 +3097,19 @@ PQconnectPoll(PGconn *conn)\n \t\t\t\tpollres = pqsecure_open_client(conn);\n\
    \ \t\t\t\tif (pollres == PGRES_POLLING_OK)\n \t\t\t\t{\n+\t\t\t\t\t/*\n+\t\t\t\
    \t\t * At this point we should have no data already buffered.\n+\t\t\t\t\t * If\
    \ we do, it was received before we performed the SSL\n+\t\t\t\t\t * handshake,\
    \ so it wasn't encrypted and indeed may have\n+\t\t\t\t\t * been injected by a\
    \ man-in-the-middle.\n+\t\t\t\t\t */\n+\t\t\t\t\tif (conn->inCursor != conn->inEnd)\n\
    +\t\t\t\t\t{\n+\t\t\t\t\t\tappendPQExpBufferStr(&conn->errorMessage,\n+\t\t\t\t\
    \t\t\t\t\t\t\t libpq_gettext(\"received unencrypted data after SSL response\\\
    n\"));\n+\t\t\t\t\t\tgoto error_return;\n+\t\t\t\t\t}\n+\n \t\t\t\t\t/* SSL handshake\
    \ done, ready to send startup packet */\n \t\t\t\t\tconn->status = CONNECTION_MADE;\n\
    \ \t\t\t\t\treturn PGRES_POLLING_WRITING;\n@@ -3196,6 +3209,19 @@ PQconnectPoll(PGconn\
    \ *conn)\n \t\t\t\tpollres = pqsecure_open_gss(conn);\n \t\t\t\tif (pollres ==\
    \ PGRES_POLLING_OK)\n \t\t\t\t{\n+\t\t\t\t\t/*\n+\t\t\t\t\t * At this point we\
    \ should have no data already buffered.\n+\t\t\t\t\t * If we do, it was received\
    \ before we performed the GSS\n+\t\t\t\t\t * handshake, so it wasn't encrypted\
    \ and indeed may have\n+\t\t\t\t\t * been injected by a man-in-the-middle.\n+\t\
    \t\t\t\t */\n+\t\t\t\t\tif (conn->inCursor != conn->inEnd)\n+\t\t\t\t\t{\n+\t\t\
    \t\t\t\tappendPQExpBufferStr(&conn->errorMessage,\n+\t\t\t\t\t\t\t\t\t\t\t libpq_gettext(\"\
    received unencrypted data after GSSAPI encryption response\\n\"));\n+\t\t\t\t\t\
    \tgoto error_return;\n+\t\t\t\t\t}\n+\n \t\t\t\t\t/* All set for startup packet\
    \ */\n \t\t\t\t\tconn->status = CONNECTION_MADE;\n \t\t\t\t\treturn PGRES_POLLING_WRITING;"
  identifiers:
  - CVE-2021-23222
  - CWE-522
  overview: A man-in-the-middle attacker can inject false responses to the client's
    first few queries, despite the use of SSL certificate verification and encryption.
  references:
  - source: secalert@redhat.com
    tags:
    - Issue Tracking
    - Third Party Advisory
    url: https://bugzilla.redhat.com/show_bug.cgi?id=2022675
  - source: secalert@redhat.com
    url: https://git.postgresql.org/gitweb/?p=postgresql.git%3Ba=commitdiff%3Bh=d83cdfdca9d918bbbd6bb209139b94c954da7228
  - source: secalert@redhat.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/postgres/postgres/commit/160c0258802d10b0600d7671b1bbea55d8e17d45
  - source: secalert@redhat.com
    tags:
    - Third Party Advisory
    url: https://security.gentoo.org/glsa/202211-04
  - source: secalert@redhat.com
    tags:
    - Release Notes
    - Vendor Advisory
    url: https://www.postgresql.org/support/security/CVE-2021-23222/
  title: A man-in-the-middle attacker can inject false responses to the client's first
    few queries, despite the use of SSL certificate verification and encryption.
- diff_content:
  - "--- a/src/tpm2/Unmarshal.c\n+++ b/src/tpm2/Unmarshal.c\n@@ -165,13 +165,15 @@\
    \ TPM_RC\n TPM_GENERATED_Unmarshal(TPM_GENERATED *target, BYTE **buffer, INT32\
    \ *size)\n {\n     TPM_RC rc = TPM_RC_SUCCESS;\n+    TPM_GENERATED orig_target\
    \ = *target; // libtpms added\n \n     if (rc == TPM_RC_SUCCESS) {\n \trc = UINT32_Unmarshal(target,\
    \ buffer, size);  \n     }\n     if (rc == TPM_RC_SUCCESS) {\n \tif (*target !=\
    \ TPM_GENERATED_VALUE) {\n \t    rc = TPM_RC_VALUE;\n+\t    *target = orig_target;\
    \ // libtpms added\n \t}\n     }\n     return rc;\n@@ -198,6 +200,7 @@ TPM_RC\n\
    \ TPM_ECC_CURVE_Unmarshal(TPM_ECC_CURVE *target, BYTE **buffer, INT32 *size)\n\
    \ {\n     TPM_RC rc = TPM_RC_SUCCESS;\n+    TPM_ECC_CURVE orig_target = *target;\
    \ // libtpms added\n \n     if (rc == TPM_RC_SUCCESS) {\n \trc = UINT16_Unmarshal(target,\
    \ buffer, size);\n@@ -216,6 +219,7 @@ TPM_ECC_CURVE_Unmarshal(TPM_ECC_CURVE *target,\
    \ BYTE **buffer, INT32 *size)\n \t    break;\n \t  default:\n \t    rc = TPM_RC_CURVE;\n\
    +\t    *target = orig_target; // libtpms added\n \t}\n     }\n     return rc;\n\
    @@ -241,6 +245,7 @@ TPM_RC\n TPM_CLOCK_ADJUST_Unmarshal(TPM_CLOCK_ADJUST *target,\
    \ BYTE **buffer, INT32 *size)\n {\n     TPM_RC rc = TPM_RC_SUCCESS;\n+    TPM_CLOCK_ADJUST\
    \ orig_target = *target; // libtpms added\n \n     if (rc == TPM_RC_SUCCESS) {\n\
    \ \trc = INT8_Unmarshal(target, buffer, size);  \n@@ -257,6 +262,7 @@ TPM_CLOCK_ADJUST_Unmarshal(TPM_CLOCK_ADJUST\
    \ *target, BYTE **buffer, INT32 *size)\n \t    break;\n \t  default:\n \t    rc\
    \ = TPM_RC_VALUE;\n+\t    *target = orig_target; // libtpms added\n \t}\n    \
    \ }\n     return rc;\n@@ -268,6 +274,7 @@ TPM_RC\n TPM_EO_Unmarshal(TPM_EO *target,\
    \ BYTE **buffer, INT32 *size)\n {\n     TPM_RC rc = TPM_RC_SUCCESS;\n+    TPM_EO\
    \ orig_target = *target; // libtpms added\n \n     if (rc == TPM_RC_SUCCESS) {\n\
    \ \trc = UINT16_Unmarshal(target, buffer, size);  \n@@ -289,6 +296,7 @@ TPM_EO_Unmarshal(TPM_EO\
    \ *target, BYTE **buffer, INT32 *size)\n \t    break;\n \t  default:\n \t    rc\
    \ = TPM_RC_VALUE;\n+\t    *target = orig_target; // libtpms added\n \t}\n    \
    \ }\n     return rc;\n@@ -300,6 +308,7 @@ TPM_RC\n TPM_ST_Unmarshal(TPM_ST *target,\
    \ BYTE **buffer, INT32 *size)\n {\n     TPM_RC rc = TPM_RC_SUCCESS;\n+    TPM_ST\
    \ orig_target = *target; // libtpms added\n \n     if (rc == TPM_RC_SUCCESS) {\n\
    \ \trc = UINT16_Unmarshal(target, buffer, size);  \n@@ -325,6 +334,7 @@ TPM_ST_Unmarshal(TPM_ST\
    \ *target, BYTE **buffer, INT32 *size)\n \t    break;\n \t  default:\n \t    rc\
    \ = TPM_RC_VALUE;\n+\t    *target = orig_target; // libtpms added\n \t}\n    \
    \ }\n     return rc;\n@@ -336,6 +346,7 @@ TPM_RC\n TPM_SU_Unmarshal(TPM_SU *target,\
    \ BYTE **buffer, INT32 *size)\n {\n     TPM_RC rc = TPM_RC_SUCCESS;\n+    TPM_SU\
    \ orig_target = *target; // libtpms added\n \n     if (rc == TPM_RC_SUCCESS) {\n\
    \ \trc = UINT16_Unmarshal(target, buffer, size);  \n@@ -347,6 +358,7 @@ TPM_SU_Unmarshal(TPM_SU\
    \ *target, BYTE **buffer, INT32 *size)\n \t    break;\n \t  default:\n \t    rc\
    \ = TPM_RC_VALUE;\n+\t    *target = orig_target; // libtpms added\n \t}\n    \
    \ }\n     return rc;\n@@ -358,6 +370,7 @@ TPM_RC\n TPM_SE_Unmarshal(TPM_SE *target,\
    \ BYTE **buffer, INT32 *size)\n {\n     TPM_RC rc = TPM_RC_SUCCESS;\n+    TPM_SE\
    \ orig_target = *target; // libtpms added\n \n     if (rc == TPM_RC_SUCCESS) {\n\
    \ \trc = UINT8_Unmarshal(target, buffer, size);  \n@@ -370,6 +383,7 @@ TPM_SE_Unmarshal(TPM_SE\
    \ *target, BYTE **buffer, INT32 *size)\n \t    break;\n \t  default:\n \t    rc\
    \ = TPM_RC_VALUE;\n+\t    *target = orig_target; // libtpms added\n \t}\n    \
    \ }\n     return rc;\n@@ -381,6 +395,7 @@ TPM_RC\n TPM_CAP_Unmarshal(TPM_CAP *target,\
    \ BYTE **buffer, INT32 *size)\n {\n     TPM_RC rc = TPM_RC_SUCCESS;\n+    TPM_CAP\
    \ orig_target = *target; // libtpms added\n \n     if (rc == TPM_RC_SUCCESS) {\n\
    \ \trc = UINT32_Unmarshal(target, buffer, size);  \n@@ -402,6 +417,7 @@ TPM_CAP_Unmarshal(TPM_CAP\
    \ *target, BYTE **buffer, INT32 *size)\n \t    break;\n \t  default:\n \t    rc\
    \ = TPM_RC_VALUE;\n+\t    *target = orig_target; // libtpms added\n \t}\n    \
    \ }\n     return rc;\n@@ -452,13 +468,15 @@ TPM_RC\n TPMA_ALGORITHM_Unmarshal(TPMA_ALGORITHM\
    \ *target, BYTE **buffer, INT32 *size)\n {\n     TPM_RC rc = TPM_RC_SUCCESS;\n\
    +    TPMA_ALGORITHM orig_target = *target; // libtpms added\n \n     if (rc ==\
    \ TPM_RC_SUCCESS) {\n \trc = UINT32_Unmarshal((UINT32 *)target, buffer, size);\
    \ /* libtpms changed */\n     }\n     if (rc == TPM_RC_SUCCESS) {\n \tif (*target\
    \ & TPMA_ALGORITHM_reserved) {\n \t    rc = TPM_RC_RESERVED_BITS;\n+\t    *target\
    \ = orig_target; // libtpms added\n \t}\n     }\n     return rc;\n@@ -470,13 +488,15\
    \ @@ TPM_RC\n TPMA_OBJECT_Unmarshal(TPMA_OBJECT *target, BYTE **buffer, INT32\
    \ *size)\n {\n     TPM_RC rc = TPM_RC_SUCCESS;\n+    TPMA_OBJECT orig_target =\
    \ *target; // libtpms added\n \n     if (rc == TPM_RC_SUCCESS) {\n \trc = UINT32_Unmarshal((UINT32\
    \ *)target, buffer, size); /* libtpms changed */\n     }\n     if (rc == TPM_RC_SUCCESS)\
    \ {\n \tif (*target & TPMA_OBJECT_reserved) {\n \t    rc = TPM_RC_RESERVED_BITS;\n\
    +\t    *target = orig_target; // libtpms added\n \t}\n     }\n     return rc;\n\
    @@ -488,13 +508,15 @@ TPM_RC\n TPMA_SESSION_Unmarshal(TPMA_SESSION *target, BYTE\
    \ **buffer, INT32 *size)\n {\n     TPM_RC rc = TPM_RC_SUCCESS;\n+    TPMA_SESSION\
    \ orig_target = *target; // libtpms added\n \n     if (rc == TPM_RC_SUCCESS) {\n\
    \ \trc = UINT8_Unmarshal((UINT8 *)target, buffer, size);  /* libtpms changed */\n\
    \     }\n     if (rc == TPM_RC_SUCCESS) {\n \tif (*target & TPMA_SESSION_reserved)\
    \ {\n \t    rc = TPM_RC_RESERVED_BITS;\n+\t    *target = orig_target; // libtpms\
    \ added\n \t}\n     }\n     return rc;\n@@ -519,13 +541,15 @@ TPM_RC\n TPMA_CC_Unmarshal(TPMA_CC\
    \ *target, BYTE **buffer, INT32 *size)\n {\n     TPM_RC rc = TPM_RC_SUCCESS;\n\
    +    TPMA_CC orig_target = *target; // libtpms added\n \n     if (rc == TPM_RC_SUCCESS)\
    \ {\n \trc = UINT32_Unmarshal((UINT32 *)target, buffer, size); /* libtpms changed\
    \ */\n     }\n     if (rc == TPM_RC_SUCCESS) {\n \tif (*target & TPMA_CC_reserved)\
    \ {\n \t    rc = TPM_RC_RESERVED_BITS;\n+\t    *target = orig_target; // libtpms\
    \ added\n \t}\n     }\n     return rc;\n@@ -537,6 +561,7 @@ TPM_RC\n TPMI_YES_NO_Unmarshal(TPMI_YES_NO\
    \ *target, BYTE **buffer, INT32 *size)\n {\n     TPM_RC rc = TPM_RC_SUCCESS;\n\
    +    TPMI_YES_NO orig_target = *target; // libtpms added\n \n     if (rc == TPM_RC_SUCCESS)\
    \ {\n \trc = UINT8_Unmarshal(target, buffer, size);  \n@@ -548,6 +573,7 @@ TPMI_YES_NO_Unmarshal(TPMI_YES_NO\
    \ *target, BYTE **buffer, INT32 *size)\n \t    break;\n \t  default:\n \t    rc\
    \ = TPM_RC_VALUE;\n+\t    *target = orig_target; // libtpms added\n \t}\n    \
    \ }\n     return rc;\n@@ -559,6 +585,7 @@ TPM_RC\n TPMI_DH_OBJECT_Unmarshal(TPMI_DH_OBJECT\
    \ *target, BYTE **buffer, INT32 *size, BOOL allowNull)\n {\n     TPM_RC rc = TPM_RC_SUCCESS;\n\
    +    TPMI_DH_OBJECT orig_target = *target; // libtpms added\n     \n     if (rc\
    \ == TPM_RC_SUCCESS) {\n \trc = TPM_HANDLE_Unmarshal(target, buffer, size);  \n\
    @@ -571,6 +598,7 @@ TPMI_DH_OBJECT_Unmarshal(TPMI_DH_OBJECT *target, BYTE **buffer,\
    \ INT32 *size, BOO\n \t    isNotPersistent &&\n \t    isNotLegalNull) {\n \t \
    \   rc = TPM_RC_VALUE;\n+\t    *target = orig_target; // libtpms added\n \t}\n\
    \     }\n     return rc;\n@@ -582,6 +610,7 @@ TPM_RC\n TPMI_DH_PARENT_Unmarshal(TPMI_DH_PARENT\
    \ *target, BYTE **buffer, INT32 *size, BOOL allowNull)\n {\n     TPM_RC rc = TPM_RC_SUCCESS;\n\
    +    TPMI_DH_PARENT orig_target = *target; // libtpms added\n     \n     if (rc\
    \ == TPM_RC_SUCCESS) {\n \trc = TPM_HANDLE_Unmarshal(target, buffer, size);  \n\
    @@ -600,6 +629,7 @@ TPMI_DH_PARENT_Unmarshal(TPMI_DH_PARENT *target, BYTE **buffer,\
    \ INT32 *size, BOO\n \t    isNotEndorsement && \n \t    isNotLegalNull) {\n \t\
    \    rc = TPM_RC_VALUE;\n+\t    *target = orig_target; // libtpms added\n \t}\n\
    \     }\n     return rc;\n@@ -611,6 +641,7 @@ TPM_RC\n TPMI_DH_PERSISTENT_Unmarshal(TPMI_DH_PERSISTENT\
    \ *target, BYTE **buffer, INT32 *size)\n {\n     TPM_RC rc = TPM_RC_SUCCESS;\n\
    +    TPMI_DH_PERSISTENT orig_target = *target; // libtpms added\n \n     if (rc\
    \ == TPM_RC_SUCCESS) {\n \trc = TPM_HANDLE_Unmarshal(target, buffer, size);  \n\
    @@ -619,6 +650,7 @@ TPMI_DH_PERSISTENT_Unmarshal(TPMI_DH_PERSISTENT *target, BYTE\
    \ **buffer, INT32 *s\n \tBOOL isNotPersistent = (*target < PERSISTENT_FIRST) ||\
    \ (*target > PERSISTENT_LAST);\n \tif (isNotPersistent) {\n \t    rc = TPM_RC_VALUE;\n\
    +\t    *target = orig_target; // libtpms added\n \t}\n     }\n     return rc;\n\
    @@ -630,6 +662,7 @@ TPM_RC\n TPMI_DH_ENTITY_Unmarshal(TPMI_DH_ENTITY *target,\
    \ BYTE **buffer, INT32 *size, BOOL allowNull)\n {\n     TPM_RC rc = TPM_RC_SUCCESS;\n\
    +    TPMI_DH_ENTITY orig_target = *target; // libtpms added\n \n     if (rc ==\
    \ TPM_RC_SUCCESS) {\n \trc = TPM_HANDLE_Unmarshal(target, buffer, size);  \n@@\
    \ -656,6 +689,7 @@ TPMI_DH_ENTITY_Unmarshal(TPMI_DH_ENTITY *target, BYTE **buffer,\
    \ INT32 *size, BOO\n \t    isNotAuth &&\n \t    isNotLegalNull) {\n \t    rc =\
    \ TPM_RC_VALUE;\n+\t    *target = orig_target; // libtpms added\n \t}\n     }\n\
    \     return rc;\n@@ -667,6 +701,7 @@ TPM_RC\n TPMI_DH_PCR_Unmarshal(TPMI_DH_PCR\
    \ *target, BYTE **buffer, INT32 *size, BOOL allowNull)\n {\n     TPM_RC rc = TPM_RC_SUCCESS;\n\
    +    TPMI_DH_PCR orig_target = *target; // libtpms added\n \n     if (rc == TPM_RC_SUCCESS)\
    \ {\n \trc = TPM_HANDLE_Unmarshal(target, buffer, size);  \n@@ -677,6 +712,7 @@\
    \ TPMI_DH_PCR_Unmarshal(TPMI_DH_PCR *target, BYTE **buffer, INT32 *size, BOOL\
    \ allo\n \tif (isNotPcr &&\n \t    isNotLegalNull) {\n \t    rc = TPM_RC_VALUE;\n\
    +\t    *target = orig_target; // libtpms added\n \t}\n     }\n     return rc;\n\
    @@ -688,6 +724,7 @@ TPM_RC\n TPMI_SH_AUTH_SESSION_Unmarshal(TPMI_SH_AUTH_SESSION\
    \ *target, BYTE **buffer, INT32 *size, BOOL allowPwd)\n {\n     TPM_RC rc = TPM_RC_SUCCESS;\n\
    +    TPMI_SH_AUTH_SESSION orig_target = *target; // libtpms added\n \n     if\
    \ (rc == TPM_RC_SUCCESS) {\n \trc = TPM_HANDLE_Unmarshal(target, buffer, size);\
    \  \n@@ -700,6 +737,7 @@ TPMI_SH_AUTH_SESSION_Unmarshal(TPMI_SH_AUTH_SESSION *target,\
    \ BYTE **buffer, INT3\n \t    isNotPolicySession &&\n \t    isNotLegalPwd) {\n\
    \ \t    rc = TPM_RC_VALUE;\n+\t    *target = orig_target; // libtpms added\n \t\
    }\n     }\n     return rc;\n@@ -711,6 +749,7 @@ TPM_RC\n TPMI_SH_HMAC_Unmarshal(TPMI_SH_HMAC\
    \ *target, BYTE **buffer, INT32 *size)\n {\n     TPM_RC rc = TPM_RC_SUCCESS;\n\
    +    TPMI_SH_HMAC orig_target = *target; // libtpms added\n     \n     if (rc\
    \ == TPM_RC_SUCCESS) {\n \trc = TPM_HANDLE_Unmarshal(target, buffer, size);  \n\
    @@ -719,6 +758,7 @@ TPMI_SH_HMAC_Unmarshal(TPMI_SH_HMAC *target, BYTE **buffer,\
    \ INT32 *size)\n \tBOOL isNotHmacSession = (*target < HMAC_SESSION_FIRST ) ||\
    \ (*target > HMAC_SESSION_LAST);\n \tif (isNotHmacSession) {\n \t    rc = TPM_RC_VALUE;\n\
    +\t    *target = orig_target; // libtpms added\n \t}\n     }\n     return rc;\n\
    @@ -730,6 +770,7 @@ TPM_RC\n TPMI_SH_POLICY_Unmarshal(TPMI_SH_POLICY *target,\
    \ BYTE **buffer, INT32 *size)\n {\n     TPM_RC rc = TPM_RC_SUCCESS;\n+    TPMI_SH_POLICY\
    \ orig_target = *target; // libtpms added\n     \n     if (rc == TPM_RC_SUCCESS)\
    \ {\n \trc = TPM_HANDLE_Unmarshal(target, buffer, size);  \n@@ -738,6 +779,7 @@\
    \ TPMI_SH_POLICY_Unmarshal(TPMI_SH_POLICY *target, BYTE **buffer, INT32 *size)\n\
    \ \tBOOL isNotPolicySession = (*target < POLICY_SESSION_FIRST) || (*target > POLICY_SESSION_LAST);\n\
    \ \tif (isNotPolicySession) {\n \t    rc = TPM_RC_VALUE;\n+\t    *target = orig_target;\
    \ // libtpms added\n \t}\n     }\n     return rc;\n@@ -749,6 +791,7 @@ TPM_RC\n\
    \ TPMI_DH_CONTEXT_Unmarshal(TPMI_DH_CONTEXT *target, BYTE **buffer, INT32 *size)\n\
    \ {\n     TPM_RC rc = TPM_RC_SUCCESS;\n+    TPMI_DH_CONTEXT orig_target = *target;\
    \ // libtpms added\n \n     if (rc == TPM_RC_SUCCESS) {\n \trc = TPM_HANDLE_Unmarshal(target,\
    \ buffer, size);  \n@@ -761,6 +804,7 @@ TPMI_DH_CONTEXT_Unmarshal(TPMI_DH_CONTEXT\
    \ *target, BYTE **buffer, INT32 *size)\n \t    isNotPolicySession &&\n \t    isNotTransient)\
    \ {\n \t    rc = TPM_RC_VALUE;\n+\t    *target = orig_target; // libtpms added\n\
    \ \t}\n     }\n     return rc;\n@@ -772,6 +816,7 @@ TPM_RC\n TPMI_DH_SAVED_Unmarshal(TPMI_DH_SAVED\
    \ *target, BYTE **buffer, INT32 *size, BOOL allowNull)\n {\n     TPM_RC rc = TPM_RC_SUCCESS;\n\
    +    TPMI_DH_SAVED orig_target = *target; // libtpms added\n     allowNull = allowNull;\n\
    \ \n     if (rc == TPM_RC_SUCCESS) {\n@@ -789,6 +834,7 @@ TPMI_DH_SAVED_Unmarshal(TPMI_DH_SAVED\
    \ *target, BYTE **buffer, INT32 *size, BOOL\n \t    isNotSequenceObject &&\n \t\
    \    isNotTransientStClear) {\n \t    rc = TPM_RC_VALUE;\n+\t    *target = orig_target;\
    \ // libtpms added\n \t}\n     }\n     return rc;\n@@ -800,6 +846,7 @@ TPM_RC\n\
    \ TPMI_RH_HIERARCHY_Unmarshal(TPMI_RH_HIERARCHY *target, BYTE **buffer, INT32\
    \ *size, BOOL allowNull)\n {\n     TPM_RC rc = TPM_RC_SUCCESS;\n+    TPMI_RH_HIERARCHY\
    \ orig_target = *target; // libtpms added\n \n     if (rc == TPM_RC_SUCCESS) {\n\
    \ \trc = TPM_HANDLE_Unmarshal(target, buffer, size);  \n@@ -816,6 +863,7 @@ TPMI_RH_HIERARCHY_Unmarshal(TPMI_RH_HIERARCHY\
    \ *target, BYTE **buffer, INT32 *siz\n \t    }\n \t  default:\n \t    rc = TPM_RC_VALUE;\n\
    +\t    *target = orig_target; // libtpms added\n \t}\n     }\n     return rc;\n\
    @@ -827,6 +875,7 @@ TPM_RC\n TPMI_RH_ENABLES_Unmarshal(TPMI_RH_ENABLES *target,\
    \ BYTE **buffer, INT32 *size, BOOL allowNull)\n {\n     TPM_RC rc = TPM_RC_SUCCESS;\n\
    +    TPMI_RH_ENABLES orig_target = *target; // libtpms added\n \n     if (rc ==\
    \ TPM_RC_SUCCESS) {\n \trc = TPM_HANDLE_Unmarshal(target, buffer, size);  \n@@\
    \ -844,6 +893,7 @@ TPMI_RH_ENABLES_Unmarshal(TPMI_RH_ENABLES *target, BYTE **buffer,\
    \ INT32 *size, B\n \t    }\n \t  default:\n \t    rc = TPM_RC_VALUE;\n+\t    *target\
    \ = orig_target; // libtpms added\n \t}\n     }\n     return rc;\n@@ -855,6 +905,7\
    \ @@ TPM_RC\n TPMI_RH_HIERARCHY_AUTH_Unmarshal(TPMI_RH_HIERARCHY_AUTH *target,\
    \ BYTE **buffer, INT32 *size)\n {\n     TPM_RC rc = TPM_RC_SUCCESS;\n+    TPMI_RH_HIERARCHY_AUTH\
    \ orig_target = *target; // libtpms added\n     \n     if (rc == TPM_RC_SUCCESS)\
    \ {\n \trc = TPM_HANDLE_Unmarshal(target, buffer, size);  \n@@ -868,6 +919,7 @@\
    \ TPMI_RH_HIERARCHY_AUTH_Unmarshal(TPMI_RH_HIERARCHY_AUTH *target, BYTE **buffer,\n\
    \ \t    break;\n \t  default:\n \t    rc = TPM_RC_VALUE;\n+\t    *target = orig_target;\
    \ // libtpms added\n \t}\n     }\n     return rc;\n@@ -879,6 +931,7 @@ TPM_RC\n\
    \ TPMI_RH_HIERARCHY_POLICY_Unmarshal(TPMI_RH_HIERARCHY_POLICY *target, BYTE **buffer,\
    \ INT32 *size)\n {\n     TPM_RC rc = TPM_RC_SUCCESS;\n+    TPMI_RH_HIERARCHY_POLICY\
    \ orig_target = *target; // libtpms added\n     \n     if (rc == TPM_RC_SUCCESS)\
    \ {\n \trc = TPM_HANDLE_Unmarshal(target, buffer, size);  \n@@ -895,6 +948,7 @@\
    \ TPMI_RH_HIERARCHY_POLICY_Unmarshal(TPMI_RH_HIERARCHY_POLICY *target, BYTE **buff\n\
    \ \t\t  BOOL isNotHP =  (*target < TPM_RH_ACT_0) || (*target > TPM_RH_ACT_F);\n\
    \ \t\t  if (isNotHP) {\n \t\t      rc = TPM_RC_VALUE;\n+\t\t      *target = orig_target;\
    \ // libtpms added\n \t\t  }\n \t      }\n \t}\n@@ -908,6 +962,7 @@ TPM_RC\n TPMI_RH_PLATFORM_Unmarshal(TPMI_RH_PLATFORM\
    \ *target, BYTE **buffer, INT32 *size)\n {\n     TPM_RC rc = TPM_RC_SUCCESS;\n\
    +    TPMI_RH_PLATFORM orig_target = *target; // libtpms added\n \n     if (rc\
    \ == TPM_RC_SUCCESS) {\n \trc = TPM_HANDLE_Unmarshal(target, buffer, size);  \n\
    @@ -918,6 +973,7 @@ TPMI_RH_PLATFORM_Unmarshal(TPMI_RH_PLATFORM *target, BYTE\
    \ **buffer, INT32 *size)\n \t    break;\n \t  default:\n \t    rc = TPM_RC_VALUE;\n\
    +\t    *target = orig_target; // libtpms added\n \t}\n     }\n     return rc;\n\
    @@ -929,6 +985,7 @@ TPM_RC\n TPMI_RH_ENDORSEMENT_Unmarshal(TPMI_RH_ENDORSEMENT\
    \ *target, BYTE **buffer, INT32 *size, BOOL allowNull)\n {\n     TPM_RC rc = TPM_RC_SUCCESS;\n\
    +    TPMI_RH_ENDORSEMENT orig_target = *target; // libtpms added\n \n     if (rc\
    \ == TPM_RC_SUCCESS) {\n \trc = TPM_HANDLE_Unmarshal(target, buffer, size);  \n\
    @@ -943,6 +1000,7 @@ TPMI_RH_ENDORSEMENT_Unmarshal(TPMI_RH_ENDORSEMENT *target,\
    \ BYTE **buffer, INT32\n \t    }\n \t  default:\n \t    rc = TPM_RC_VALUE;\n+\t\
    \    *target = orig_target; // libtpms added\n \t}\n     }\n     return rc;\n\
    @@ -954,6 +1012,7 @@ TPM_RC\n TPMI_RH_PROVISION_Unmarshal(TPMI_RH_PROVISION *target,\
    \ BYTE **buffer, INT32 *size)\n {\n     TPM_RC rc = TPM_RC_SUCCESS;\n+    TPMI_RH_PROVISION\
    \ orig_target = *target; // libtpms added\n \n     if (rc == TPM_RC_SUCCESS) {\n\
    \ \trc = TPM_HANDLE_Unmarshal(target, buffer, size);  \n@@ -965,6 +1024,7 @@ TPMI_RH_PROVISION_Unmarshal(TPMI_RH_PROVISION\
    \ *target, BYTE **buffer, INT32 *siz\n \t    break;\n \t  default:\n \t    rc\
    \ = TPM_RC_VALUE;\n+\t    *target = orig_target; // libtpms added\n \t}\n    \
    \ }\n     return rc;\n@@ -976,6 +1036,7 @@ TPM_RC\n TPMI_RH_CLEAR_Unmarshal(TPMI_RH_CLEAR\
    \ *target, BYTE **buffer, INT32 *size)\n {\n     TPM_RC rc = TPM_RC_SUCCESS;\n\
    +    TPMI_RH_CLEAR orig_target = *target; // libtpms added\n \n     if (rc ==\
    \ TPM_RC_SUCCESS) {\n \trc = TPM_HANDLE_Unmarshal(target, buffer, size);  \n@@\
    \ -987,6 +1048,7 @@ TPMI_RH_CLEAR_Unmarshal(TPMI_RH_CLEAR *target, BYTE **buffer,\
    \ INT32 *size)\n \t    break;\n \t  default:\n \t    rc = TPM_RC_VALUE;\n+\t \
    \   *target = orig_target; // libtpms added\n \t}\n     }\n     return rc;\n@@\
    \ -998,6 +1060,7 @@ TPM_RC\n TPMI_RH_NV_AUTH_Unmarshal(TPMI_RH_NV_AUTH *target,\
    \ BYTE **buffer, INT32 *size)\n {\n     TPM_RC rc = TPM_RC_SUCCESS;\n+    TPMI_RH_NV_AUTH\
    \ orig_target = *target; // libtpms added\n     \n     if (rc == TPM_RC_SUCCESS)\
    \ {\n \trc = TPM_HANDLE_Unmarshal(target, buffer, size);  \n@@ -1012,6 +1075,7\
    \ @@ TPMI_RH_NV_AUTH_Unmarshal(TPMI_RH_NV_AUTH *target, BYTE **buffer, INT32 *size)\n\
    \ \t\t  BOOL isNotNv = (*target < NV_INDEX_FIRST) || (*target > NV_INDEX_LAST);\n\
    \ \t\t  if (isNotNv) {\n \t\t      rc = TPM_RC_VALUE;\n+\t\t      *target = orig_target;\
    \ // libtpms added\n \t\t  }\n \t      }\n \t}\n@@ -1025,6 +1089,7 @@ TPM_RC\n\
    \ TPMI_RH_LOCKOUT_Unmarshal(TPMI_RH_LOCKOUT *target, BYTE **buffer, INT32 *size)\n\
    \ {\n     TPM_RC rc = TPM_RC_SUCCESS;\n+    TPMI_RH_LOCKOUT orig_target = *target;\
    \ // libtpms added\n \n     if (rc == TPM_RC_SUCCESS) {\n \trc = TPM_HANDLE_Unmarshal(target,\
    \ buffer, size);  \n@@ -1035,6 +1100,7 @@ TPMI_RH_LOCKOUT_Unmarshal(TPMI_RH_LOCKOUT\
    \ *target, BYTE **buffer, INT32 *size)\n \t    break;\n \t  default:\n \t    rc\
    \ = TPM_RC_VALUE;\n+\t    *target = orig_target; // libtpms added\n \t}\n    \
    \ }\n     return rc;\n@@ -1046,6 +1112,7 @@ TPM_RC\n TPMI_RH_NV_INDEX_Unmarshal(TPMI_RH_NV_INDEX\
    \ *target, BYTE **buffer, INT32 *size)\n {\n     TPM_RC rc = TPM_RC_SUCCESS;\n\
    +    TPMI_RH_NV_INDEX orig_target = *target; // libtpms added\n \n     if (rc\
    \ == TPM_RC_SUCCESS) {\n \trc = TPM_HANDLE_Unmarshal(target, buffer, size);  \n\
    @@ -1054,6 +1121,7 @@ TPMI_RH_NV_INDEX_Unmarshal(TPMI_RH_NV_INDEX *target, BYTE\
    \ **buffer, INT32 *size)\n \tBOOL isNotNv = (*target < NV_INDEX_FIRST) || (*target\
    \ > NV_INDEX_LAST);\n \tif (isNotNv) {\n \t    rc = TPM_RC_VALUE;\n+\t    *target\
    \ = orig_target; // libtpms added\n \t}\n     }\n     return rc;\n@@ -1065,6 +1133,7\
    \ @@ TPM_RC\n TPMI_RH_AC_Unmarshal(TPMI_RH_AC *target, BYTE **buffer, INT32 *size)\n\
    \ {\n     TPM_RC rc = TPM_RC_SUCCESS;\n+    TPMI_RH_AC orig_target = *target;\
    \ // libtpms added\n \n     if (rc == TPM_RC_SUCCESS) {\n \trc = TPM_HANDLE_Unmarshal(target,\
    \ buffer, size);  \n@@ -1073,6 +1142,7 @@ TPMI_RH_AC_Unmarshal(TPMI_RH_AC *target,\
    \ BYTE **buffer, INT32 *size)\n \tBOOL isNotAC = (*target < AC_FIRST) || (*target\
    \ > AC_LAST);\n \tif (isNotAC) {\n \t    rc = TPM_RC_VALUE;\n+\t    *target =\
    \ orig_target; // libtpms added\n \t}\n     }\n     return rc;\n@@ -1084,6 +1154,7\
    \ @@ TPM_RC\n TPMI_RH_ACT_Unmarshal( TPMI_RH_ACT *target, BYTE **buffer, INT32\
    \ *size)\n {\n     TPM_RC rc = TPM_RC_SUCCESS;\n+    TPMI_RH_ACT orig_target =\
    \ *target; // libtpms added\n \n     if (rc == TPM_RC_SUCCESS) {\n \trc = TPM_HANDLE_Unmarshal(target,\
    \ buffer, size);  \n@@ -1092,6 +1163,7 @@ TPMI_RH_ACT_Unmarshal( TPMI_RH_ACT *target,\
    \ BYTE **buffer, INT32 *size)\n \tBOOL isNotACT = (*target < TPM_RH_ACT_0) ||\
    \ (*target > TPM_RH_ACT_F);\n \tif (isNotACT) {\n \t    rc = TPM_RC_VALUE;\n+\t\
    \    *target = orig_target; // libtpms added\n \t}\n     }\n     return rc;\n\
    @@ -1103,6 +1175,7 @@ TPM_RC\n TPMI_ALG_HASH_Unmarshal(TPMI_ALG_HASH *target,\
    \ BYTE **buffer, INT32 *size, BOOL allowNull)\n {\n     TPM_RC rc = TPM_RC_SUCCESS;\n\
    +    TPMI_ALG_HASH orig_target = *target; // libtpms added\n \n     if (rc ==\
    \ TPM_RC_SUCCESS) {\n \trc = TPM_ALG_ID_Unmarshal(target, buffer, size);  \n@@\
    \ -1131,6 +1204,7 @@ TPMI_ALG_HASH_Unmarshal(TPMI_ALG_HASH *target, BYTE **buffer,\
    \ INT32 *size, BOOL\n \t    }\n \t  default:\n \t    rc = TPM_RC_HASH;\n+\t  \
    \  *target = orig_target; // libtpms added\n \t}\n     }\n     return rc;\n@@\
    \ -1142,6 +1216,7 @@ TPM_RC\n TPMI_ALG_SYM_Unmarshal(TPMI_ALG_SYM *target, BYTE\
    \ **buffer, INT32 *size, BOOL allowNull)\n {\n     TPM_RC rc = TPM_RC_SUCCESS;\n\
    +    TPMI_ALG_SYM orig_target = *target; // libtpms added\n \n     if (rc == TPM_RC_SUCCESS)\
    \ {\n \trc = TPM_ALG_ID_Unmarshal(target, buffer, size);  \n@@ -1170,6 +1245,7\
    \ @@ TPMI_ALG_SYM_Unmarshal(TPMI_ALG_SYM *target, BYTE **buffer, INT32 *size,\
    \ BOOL al\n \t    }\n \t  default:\n \t    rc = TPM_RC_SYMMETRIC;\n+\t    *target\
    \ = orig_target; // libtpms added\n \t}\n     }\n     return rc;\n@@ -1181,6 +1257,7\
    \ @@ TPM_RC\n TPMI_ALG_SYM_OBJECT_Unmarshal(TPMI_ALG_SYM_OBJECT *target, BYTE\
    \ **buffer, INT32 *size, BOOL allowNull)\n {\n     TPM_RC rc = TPM_RC_SUCCESS;\n\
    +    TPMI_ALG_SYM_OBJECT orig_target = *target; // libtpms added\n \n     if (rc\
    \ == TPM_RC_SUCCESS) {\n \trc = TPM_ALG_ID_Unmarshal(target, buffer, size);  \n\
    @@ -1206,6 +1283,7 @@ TPMI_ALG_SYM_OBJECT_Unmarshal(TPMI_ALG_SYM_OBJECT *target,\
    \ BYTE **buffer, INT32\n \t    }\n \t  default:\n \t    rc = TPM_RC_SYMMETRIC;\n\
    +\t    *target = orig_target; // libtpms added\n \t}\n     }\n     return rc;\n\
    @@ -1217,6 +1295,7 @@ TPM_RC\n TPMI_ALG_SYM_MODE_Unmarshal(TPMI_ALG_SYM_MODE *target,\
    \ BYTE **buffer, INT32 *size, BOOL allowNull)\n {\n     TPM_RC rc = TPM_RC_SUCCESS;\n\
    +    TPMI_ALG_SYM_MODE orig_target = *target; // libtpms added\n \n     if (rc\
    \ == TPM_RC_SUCCESS) {\n \trc = TPM_ALG_ID_Unmarshal(target, buffer, size);  \n\
    @@ -1248,6 +1327,7 @@ TPMI_ALG_SYM_MODE_Unmarshal(TPMI_ALG_SYM_MODE *target, BYTE\
    \ **buffer, INT32 *siz\n \t    }\n \t  default:\n \t    rc = TPM_RC_MODE;\n+\t\
    \    *target = orig_target; // libtpms added\n \t}\n     }\n     return rc;\n\
    @@ -1259,6 +1339,7 @@ TPM_RC\n TPMI_ALG_KDF_Unmarshal(TPMI_ALG_KDF *target, BYTE\
    \ **buffer, INT32 *size, BOOL allowNull)\n {\n     TPM_RC rc = TPM_RC_SUCCESS;\n\
    +    TPMI_ALG_KDF orig_target = *target; // libtpms added\n \n     if (rc == TPM_RC_SUCCESS)\
    \ {\n \trc = TPM_ALG_ID_Unmarshal(target, buffer, size);  \n@@ -1284,6 +1365,7\
    \ @@ TPMI_ALG_KDF_Unmarshal(TPMI_ALG_KDF *target, BYTE **buffer, INT32 *size,\
    \ BOOL al\n \t    }\n \t  default:\n \t    rc = TPM_RC_KDF;\n+\t    *target =\
    \ orig_target; // libtpms added\n \t}\n     }\n     return rc;\n@@ -1295,6 +1377,7\
    \ @@ TPM_RC\n TPMI_ALG_SIG_SCHEME_Unmarshal(TPMI_ALG_SIG_SCHEME *target, BYTE\
    \ **buffer, INT32 *size, BOOL allowNull)\n {\n     TPM_RC rc = TPM_RC_SUCCESS;\n\
    +    TPMI_ALG_SIG_SCHEME orig_target = *target; // libtpms added\n \n     if (rc\
    \ == TPM_RC_SUCCESS) {\n \trc = TPM_ALG_ID_Unmarshal(target, buffer, size);  \n\
    @@ -1329,6 +1412,7 @@ TPMI_ALG_SIG_SCHEME_Unmarshal(TPMI_ALG_SIG_SCHEME *target,\
    \ BYTE **buffer, INT32\n \t    }\n \t  default:\n \t    rc = TPM_RC_SCHEME;\n\
    +\t    *target = orig_target; // libtpms added\n \t}\n     }\n     return rc;\n\
    @@ -1340,6 +1424,7 @@ TPM_RC\n TPMI_ECC_KEY_EXCHANGE_Unmarshal(TPMI_ECC_KEY_EXCHANGE\
    \ *target, BYTE **buffer, INT32 *size, BOOL allowNull)\n {\n     TPM_RC rc = TPM_RC_SUCCESS;\n\
    +    TPMI_ECC_KEY_EXCHANGE orig_target = *target; // libtpms added\n \n     if\
    \ (rc == TPM_RC_SUCCESS) {\n \trc = TPM_ALG_ID_Unmarshal(target, buffer, size);\
    \  \n@@ -1362,6 +1447,7 @@ TPMI_ECC_KEY_EXCHANGE_Unmarshal(TPMI_ECC_KEY_EXCHANGE\
    \ *target, BYTE **buffer, IN\n \t    }\n \t  default:\n \t    rc = TPM_RC_SCHEME;\n\
    +\t    *target = orig_target; // libtpms added\n \t}\n     }\n     return rc;\n\
    @@ -1374,6 +1460,7 @@ TPM_RC\n TPMI_ST_COMMAND_TAG_Unmarshal(TPMI_ST_COMMAND_TAG\
    \ *target, BYTE **buffer, INT32 *size)\n {\n     TPM_RC rc = TPM_RC_SUCCESS;\n\
    +    TPMI_ST_COMMAND_TAG orig_target = *target; // libtpms added\n \n     if (rc\
    \ == TPM_RC_SUCCESS) {\n \trc = TPM_ST_Unmarshal(target, buffer, size);  \n@@\
    \ -1385,6 +1472,7 @@ TPMI_ST_COMMAND_TAG_Unmarshal(TPMI_ST_COMMAND_TAG *target,\
    \ BYTE **buffer, INT32\n \t    break;\n \t  default:\n \t    rc = TPM_RC_BAD_TAG;\n\
    +\t    *target = orig_target; // libtpms added\n \t}\n     }\n     return rc;\n\
    @@ -1396,6 +1484,7 @@ TPM_RC\n TPMI_ALG_MAC_SCHEME_Unmarshal(TPMI_ALG_MAC_SCHEME\
    \ *target, BYTE **buffer, INT32 *size, BOOL allowNull)\n {\n     TPM_RC rc = TPM_RC_SUCCESS;\n\
    +    TPMI_ALG_MAC_SCHEME orig_target = *target; // libtpms added\n \n     if (rc\
    \ == TPM_RC_SUCCESS) {\n \trc = TPM_ALG_ID_Unmarshal(target, buffer, size);  \n\
    @@ -1427,6 +1516,7 @@ TPMI_ALG_MAC_SCHEME_Unmarshal(TPMI_ALG_MAC_SCHEME *target,\
    \ BYTE **buffer, INT32\n \t    }\n \t  default:\n \t    rc = TPM_RC_SYMMETRIC;\n\
    +\t    *target = orig_target; // libtpms added\n \t}\n     }\n     return rc;\n\
    @@ -1438,6 +1528,7 @@ TPM_RC\n TPMI_ALG_CIPHER_MODE_Unmarshal(TPMI_ALG_CIPHER_MODE*target,\
    \ BYTE **buffer, INT32 *size, BOOL allowNull)\n {\n     TPM_RC rc = TPM_RC_SUCCESS;\n\
    +    TPMI_ALG_CIPHER_MODE orig_target = *target; // libtpms added\n \n     if\
    \ (rc == TPM_RC_SUCCESS) {\n \trc = TPM_ALG_ID_Unmarshal(target, buffer, size);\
    \  \n@@ -1466,6 +1557,7 @@ TPMI_ALG_CIPHER_MODE_Unmarshal(TPMI_ALG_CIPHER_MODE*target,\
    \ BYTE **buffer, INT32\n \t    }\n \t  default:\n \t    rc = TPM_RC_MODE;\n+\t\
    \    *target = orig_target; // libtpms added\n \t}\n     }\n     return rc;\n\
    @@ -1702,13 +1794,15 @@ TPM_RC\n TPMT_TK_CREATION_Unmarshal(TPMT_TK_CREATION *target,\
    \ BYTE **buffer, INT32 *size)\n {\n     TPM_RC rc = TPM_RC_SUCCESS;\n+    TPM_ST\
    \ orig_tag = target->tag; // libtpms added\n \n     if (rc == TPM_RC_SUCCESS)\
    \ {\n \trc = TPM_ST_Unmarshal(&target->tag, buffer, size);\n     }\n     if (rc\
    \ == TPM_RC_SUCCESS) {\n \tif (target->tag != TPM_ST_CREATION) {\n \t    rc =\
    \ TPM_RC_TAG;\n+\t    target->tag = orig_tag; // libtpms added\n \t}\n     }\n\
    \     if (rc == TPM_RC_SUCCESS) {\n@@ -1726,13 +1820,15 @@ TPM_RC\n TPMT_TK_VERIFIED_Unmarshal(TPMT_TK_VERIFIED\
    \ *target, BYTE **buffer, INT32 *size)\n {\n     TPM_RC rc = TPM_RC_SUCCESS;\n\
    +    TPM_ST orig_tag = target->tag; // libtpms added\n     \n     if (rc == TPM_RC_SUCCESS)\
    \ {\n \trc = TPM_ST_Unmarshal(&target->tag, buffer, size);\n     }\n     if (rc\
    \ == TPM_RC_SUCCESS) {\n \tif (target->tag != TPM_ST_VERIFIED) {\n \t    rc =\
    \ TPM_RC_TAG;\n+\t    target->tag = orig_tag; // libtpms added\n \t}\n     }\n\
    \     if (rc == TPM_RC_SUCCESS) {\n@@ -1750,6 +1846,7 @@ TPM_RC\n TPMT_TK_AUTH_Unmarshal(TPMT_TK_AUTH\
    \ *target, BYTE **buffer, INT32 *size)\n {\n     TPM_RC rc = TPM_RC_SUCCESS;\n\
    +    TPM_ST orig_tag = target->tag; // libtpms added\n \n     if (rc == TPM_RC_SUCCESS)\
    \ {\n \trc = TPM_ST_Unmarshal(&target->tag, buffer, size);\n@@ -1758,6 +1855,7\
    \ @@ TPMT_TK_AUTH_Unmarshal(TPMT_TK_AUTH *target, BYTE **buffer, INT32 *size)\n\
    \ \tif ((target->tag != TPM_ST_AUTH_SIGNED) &&\n \t    (target->tag != TPM_ST_AUTH_SECRET))\
    \ {\n \t    rc = TPM_RC_TAG;\n+\t    target->tag = orig_tag; // libtpms added\n\
    \ \t}\n     }\n     if (rc == TPM_RC_SUCCESS) {\n@@ -1775,13 +1873,15 @@ TPM_RC\n\
    \ TPMT_TK_HASHCHECK_Unmarshal(TPMT_TK_HASHCHECK *target, BYTE **buffer, INT32\
    \ *size)\n {\n     TPM_RC rc = TPM_RC_SUCCESS;\n+    TPM_ST orig_tag = target->tag;\
    \ // libtpms added\n \n     if (rc == TPM_RC_SUCCESS) {\n \trc = TPM_ST_Unmarshal(&target->tag,\
    \ buffer, size);\n     }\n     if (rc == TPM_RC_SUCCESS) {\n \tif (target->tag\
    \ != TPM_ST_HASHCHECK) {\n \t    rc = TPM_RC_TAG;\n+\t    target->tag = orig_tag;\
    \ // libtpms added\n \t}\n     }\n     if (rc == TPM_RC_SUCCESS) {\n@@ -2386,6\
    \ +2486,7 @@ TPM_RC\n TPMI_ST_ATTEST_Unmarshal(TPMI_ST_ATTEST *target, BYTE **buffer,\
    \ INT32 *size)\n {\n     TPM_RC rc = TPM_RC_SUCCESS;\n+    TPMI_ST_ATTEST orig_target\
    \ = *target; // libtpms added\n \n     if (rc == TPM_RC_SUCCESS) {\n \trc = TPM_ST_Unmarshal(target,\
    \ buffer, size);\n@@ -2402,6 +2503,7 @@ TPMI_ST_ATTEST_Unmarshal(TPMI_ST_ATTEST\
    \ *target, BYTE **buffer, INT32 *size)\n \t    break;\n \t  default:\n \t    rc\
    \ = TPM_RC_SELECTOR;\n+\t    *target = orig_target; // libtpms added\n \t}\n \
    \    }\n     return rc;\n@@ -2496,6 +2598,7 @@ TPM_RC\n TPMI_AES_KEY_BITS_Unmarshal(TPMI_AES_KEY_BITS\
    \ *target, BYTE **buffer, INT32 *size)\n {\n     TPM_RC rc = TPM_RC_SUCCESS;\n\
    +    TPMI_AES_KEY_BITS orig_target = *target; // libtpms added\n \n     if (rc\
    \ == TPM_RC_SUCCESS) {\n \trc = TPM_KEY_BITS_Unmarshal(target, buffer, size);\
    \  \n@@ -2507,6 +2610,7 @@ TPMI_AES_KEY_BITS_Unmarshal(TPMI_AES_KEY_BITS *target,\
    \ BYTE **buffer, INT32 *siz\n \t    break;\n \t  default:\n \t    rc = TPM_RC_VALUE;\n\
    +\t    *target = orig_target; // libtpms added\n \t}\n     }\n     return rc;\n\
    @@ -2518,6 +2622,7 @@ TPM_RC\n TPMI_CAMELLIA_KEY_BITS_Unmarshal(TPMI_CAMELLIA_KEY_BITS\
    \ *target, BYTE **buffer, INT32 *size)\n {\n     TPM_RC rc = TPM_RC_SUCCESS;\n\
    +    TPMI_CAMELLIA_KEY_BITS orig_target = *target; // libtpms added\n \n     if\
    \ (rc == TPM_RC_SUCCESS) {\n \trc = TPM_KEY_BITS_Unmarshal(target, buffer, size);\
    \  \n@@ -2528,6 +2633,7 @@ TPMI_CAMELLIA_KEY_BITS_Unmarshal(TPMI_CAMELLIA_KEY_BITS\
    \ *target, BYTE **buffer,\n \t    break;\n \t  default:\n \t    rc = TPM_RC_VALUE;\n\
    +\t    *target = orig_target; // libtpms added\n \t}\n     }\n     return rc;\n\
    @@ -2539,6 +2645,7 @@ TPM_RC\n TPMI_SM4_KEY_BITS_Unmarshal(TPMI_SM4_KEY_BITS *target,\
    \ BYTE **buffer, INT32 *size)\n {\n     TPM_RC rc = TPM_RC_SUCCESS;\n+    TPMI_SM4_KEY_BITS\
    \ orig_target = *target; // libtpms added\n \n     if (rc == TPM_RC_SUCCESS) {\n\
    \ \trc = TPM_KEY_BITS_Unmarshal(target, buffer, size);  \n@@ -2549,6 +2656,7 @@\
    \ TPMI_SM4_KEY_BITS_Unmarshal(TPMI_SM4_KEY_BITS *target, BYTE **buffer, INT32\
    \ *siz\n \t    break;\n \t  default:\n \t    rc = TPM_RC_VALUE;\n+\t    *target\
    \ = orig_target; // libtpms added\n \t}\n     }\n     return rc;\n@@ -2560,6 +2668,7\
    \ @@ TPM_RC\n TPMI_TDES_KEY_BITS_Unmarshal(TPMI_SM4_KEY_BITS *target, BYTE **buffer,\
    \ INT32 *size)\n {\n     TPM_RC rc = TPM_RC_SUCCESS;\n+    TPMI_SM4_KEY_BITS orig_target\
    \ = *target; // libtpms added\n \n     if (rc == TPM_RC_SUCCESS) {\n \trc = TPM_KEY_BITS_Unmarshal(target,\
    \ buffer, size);\n@@ -2571,6 +2680,7 @@ TPMI_TDES_KEY_BITS_Unmarshal(TPMI_SM4_KEY_BITS\
    \ *target, BYTE **buffer, INT32 *si\n \t    break;\n \t  default:\n \t    rc =\
    \ TPM_RC_VALUE;\n+\t    *target = orig_target; // libtpms added\n \t}\n     }\n\
    \     return rc;\n@@ -2843,6 +2953,7 @@ TPM_RC\n TPMI_ALG_KEYEDHASH_SCHEME_Unmarshal(TPMI_ALG_KEYEDHASH_SCHEME\
    \ *target, BYTE **buffer, INT32 *size, BOOL allowNull)\n {\n     TPM_RC rc = TPM_RC_SUCCESS;\n\
    +    TPMI_ALG_KEYEDHASH_SCHEME orig_target = *target; // libtpms added\n \n  \
    \   if (rc == TPM_RC_SUCCESS) {\n \trc = TPM_ALG_ID_Unmarshal(target, buffer,\
    \ size);  \n@@ -2862,6 +2973,7 @@ TPMI_ALG_KEYEDHASH_SCHEME_Unmarshal(TPMI_ALG_KEYEDHASH_SCHEME\
    \ *target, BYTE **bu\n \t    }\n \t  default:\n \t    rc = TPM_RC_VALUE;\n+\t\
    \    *target = orig_target; // libtpms added\n \t}\n     }\n     return rc;\n\
    @@ -3246,6 +3358,7 @@ TPM_RC\n TPMI_ALG_ASYM_SCHEME_Unmarshal(TPMI_ALG_ASYM_SCHEME\
    \ *target, BYTE **buffer, INT32 *size, BOOL allowNull)\n {\n     TPM_RC rc = TPM_RC_SUCCESS;\n\
    +    TPMI_ALG_ASYM_SCHEME orig_target = *target; // libtpms added\n \n     if\
    \ (rc == TPM_RC_SUCCESS) {\n \trc = TPM_ALG_ID_Unmarshal(target, buffer, size);\
    \  \n@@ -3289,6 +3402,7 @@ TPMI_ALG_ASYM_SCHEME_Unmarshal(TPMI_ALG_ASYM_SCHEME\
    \ *target, BYTE **buffer, INT3\n \t    }\n \t  default:\n \t    rc = TPM_RC_VALUE;\n\
    +\t    *target = orig_target; // libtpms added\n \t}\n     }\n     return rc;\n\
    @@ -3367,6 +3481,7 @@ TPM_RC\n TPMI_ALG_RSA_SCHEME_Unmarshal(TPMI_ALG_RSA_SCHEME\
    \ *target, BYTE **buffer, INT32 *size, BOOL allowNull)\n {\n     TPM_RC rc = TPM_RC_SUCCESS;\n\
    +    TPMI_ALG_RSA_SCHEME orig_target = *target; // libtpms added\n \n     if (rc\
    \ == TPM_RC_SUCCESS) {\n \trc = TPM_ALG_ID_Unmarshal(target, buffer, size);  \n\
    @@ -3392,6 +3507,7 @@ TPMI_ALG_RSA_SCHEME_Unmarshal(TPMI_ALG_RSA_SCHEME *target,\
    \ BYTE **buffer, INT32\n \t    }\n \t  default:\n \t    rc = TPM_RC_VALUE;\n+\t\
    \    *target = orig_target; // libtpms added\n \t}\n     }\n     return rc;\n\
    @@ -3419,6 +3535,7 @@ TPM_RC\n TPMI_ALG_RSA_DECRYPT_Unmarshal(TPMI_ALG_RSA_DECRYPT\
    \ *target, BYTE **buffer, INT32 *size, BOOL allowNull)\n {\n     TPM_RC rc = TPM_RC_SUCCESS;\n\
    +    TPMI_ALG_RSA_DECRYPT orig_target = *target; // libtpms added\n \n     if\
    \ (rc == TPM_RC_SUCCESS) {\n \trc = TPM_ALG_ID_Unmarshal(target, buffer, size);\
    \  \n@@ -3438,6 +3555,7 @@ TPMI_ALG_RSA_DECRYPT_Unmarshal(TPMI_ALG_RSA_DECRYPT\
    \ *target, BYTE **buffer, INT3\n \t    }\n \t  default:\n \t    rc = TPM_RC_VALUE;\n\
    +\t    *target = orig_target; // libtpms added\n \t}\n     }\n     return rc;\n\
    @@ -3478,6 +3596,7 @@ TPM_RC\n TPMI_RSA_KEY_BITS_Unmarshal(TPMI_RSA_KEY_BITS *target,\
    \ BYTE **buffer, INT32 *size)\n {\n     TPM_RC rc = TPM_RC_SUCCESS;\n+    TPMI_RSA_KEY_BITS\
    \ orig_target = *target; // libtpms added\n \n     if (rc == TPM_RC_SUCCESS) {\n\
    \ \trc = TPM_KEY_BITS_Unmarshal(target, buffer, size);  \n@@ -3490,6 +3609,7 @@\
    \ TPMI_RSA_KEY_BITS_Unmarshal(TPMI_RSA_KEY_BITS *target, BYTE **buffer, INT32\
    \ *siz\n \t    break;\n \t  default:\n \t    rc = TPM_RC_VALUE;\n+\t    *target\
    \ = orig_target; // libtpms added\n \t}\n     }\n     return rc;\n@@ -3574,6 +3694,7\
    \ @@ TPM_RC\n TPMI_ALG_ECC_SCHEME_Unmarshal(TPMI_ALG_ECC_SCHEME *target, BYTE\
    \ **buffer, INT32 *size, BOOL allowNull)\n {\n     TPM_RC rc = TPM_RC_SUCCESS;\n\
    +    TPMI_ALG_ECC_SCHEME orig_target = *target; // libtpms added\n \n     if (rc\
    \ == TPM_RC_SUCCESS) {\n \trc = TPM_ALG_ID_Unmarshal(target, buffer, size);  \n\
    @@ -3605,6 +3726,7 @@ TPMI_ALG_ECC_SCHEME_Unmarshal(TPMI_ALG_ECC_SCHEME *target,\
    \ BYTE **buffer, INT32\n \t    }\n \t  default:\n \t    rc = TPM_RC_SCHEME;\n\
    +\t    *target = orig_target; //  libtpms added\n \t}\n     }\n     return rc;\n\
    @@ -3616,6 +3738,7 @@ TPM_RC\n TPMI_ECC_CURVE_Unmarshal(TPMI_ECC_CURVE *target,\
    \ BYTE **buffer, INT32 *size)\n {\n     TPM_RC rc = TPM_RC_SUCCESS;\n+    TPMI_ECC_CURVE\
    \ orig_target = *target; // libtpms added\n \n     if (rc == TPM_RC_SUCCESS) {\n\
    \ \trc = TPM_ECC_CURVE_Unmarshal(target, buffer, size);  \n@@ -3652,6 +3775,7\
    \ @@ TPMI_ECC_CURVE_Unmarshal(TPMI_ECC_CURVE *target, BYTE **buffer, INT32 *size)\n\
    \ \t    break;\n \t  default:\n \t    rc = TPM_RC_CURVE;\n+\t    *target = orig_target;\
    \ // libtpms added\n \t}\n     }\n     return rc;\n@@ -3866,6 +3990,7 @@ TPM_RC\n\
    \ TPMI_ALG_PUBLIC_Unmarshal(TPMI_ALG_PUBLIC *target, BYTE **buffer, INT32 *size)\n\
    \ {\n     TPM_RC rc = TPM_RC_SUCCESS;\n+    TPMI_ALG_PUBLIC orig_target = *target;\
    \ // libtpms added\n \n     if (rc == TPM_RC_SUCCESS) {\n \trc = TPM_ALG_ID_Unmarshal(target,\
    \ buffer, size);  \n@@ -3887,6 +4012,7 @@ TPMI_ALG_PUBLIC_Unmarshal(TPMI_ALG_PUBLIC\
    \ *target, BYTE **buffer, INT32 *size)\n \t    break;\n \t  default:\n \t    rc\
    \ = TPM_RC_TYPE;\n+\t    *target = orig_target; // libtpms added\n \t}\n     }\n\
    \     return rc;\n@@ -4221,13 +4347,15 @@ TPM_RC\n TPMA_NV_Unmarshal(TPMA_NV *target,\
    \ BYTE **buffer, INT32 *size)\n {\n     TPM_RC rc = TPM_RC_SUCCESS;\n+    TPMA_NV\
    \ orig_target = *target; // libtpms added\n \n     if (rc == TPM_RC_SUCCESS) {\n\
    \ \trc = UINT32_Unmarshal((UINT32 *)target, buffer, size);  /* libtpms changed\
    \ */\n     }\n     if (rc == TPM_RC_SUCCESS) {\n \tif (*target & TPMA_NV_RESERVED)\
    \ {\n \t    rc = TPM_RC_RESERVED_BITS;\n+\t    *target = orig_target; // libtpms\
    \ added\n \t}\n     }\n     return rc;"
  - "--- a/src/tpm2/NVMarshal.c\n+++ b/src/tpm2/NVMarshal.c\n@@ -1528,6 +1528,7 @@\
    \ bn_prime_t_Unmarshal(bn_prime_t *data, BYTE **buffer, INT32 *size)\n       \
    \                          \"allocated %zu\\n\",\n                           \
    \      (size_t)data->size, (size_t)data->allocated);\n             rc = TPM_RC_SIZE;\n\
    +            data->size = 0;\n         }\n     }\n "
  - "--- a/src/tpm2/Unmarshal.c\n+++ b/src/tpm2/Unmarshal.c\n@@ -136,6 +136,7 @@ TPM2B_Unmarshal(TPM2B\
    \ *target, UINT16 targetSize, BYTE **buffer, INT32 *size)\n     if (rc == TPM_RC_SUCCESS)\
    \ {\n \tif (target->size > targetSize) {\n \t    rc = TPM_RC_SIZE;\n+\t    target->size\
    \ = 0; // libtpms added\n \t}\n     }\n     if (rc == TPM_RC_SUCCESS) {\n@@ -1686,6\
    \ +1687,7 @@ TPMS_PCR_SELECTION_Unmarshal(TPMS_PCR_SELECTION *target, BYTE **buffer,\
    \ INT32 *s\n \tif ((target->sizeofSelect < PCR_SELECT_MIN) ||\n \t    (target->sizeofSelect\
    \ > PCR_SELECT_MAX)) {\n \t    rc = TPM_RC_VALUE;\n+\t    target->sizeofSelect\
    \ = 0; // libtpms added\n \t}\n     }\n     if (rc == TPM_RC_SUCCESS) {\n@@ -1862,6\
    \ +1864,7 @@ TPML_CC_Unmarshal(TPML_CC *target, BYTE **buffer, INT32 *size)\n\
    \     if (rc == TPM_RC_SUCCESS) {\n \tif (target->count > MAX_CAP_CC) {\n \t \
    \   rc = TPM_RC_SIZE;\n+\t    target->count = 0; // libtpms added\n \t}\n    \
    \ }\n     for (i = 0 ; (rc == TPM_RC_SUCCESS) && (i < target->count) ; i++) {\n\
    @@ -1902,6 +1905,7 @@ TPML_CCA_Unmarshal(TPML_CCA *target, BYTE **buffer, INT32\
    \ *size)\n     if (rc == TPM_RC_SUCCESS) {\n \tif (target->count > MAX_CAP_CC)\
    \ {\n \t    rc = TPM_RC_SIZE;\n+\t    target->count = 0; // libtpms added\n \t\
    }\n     }\n     for (i = 0 ; (rc == TPM_RC_SUCCESS) && (i < target->count) ; i++)\
    \ {\n@@ -1925,6 +1929,7 @@ TPML_ALG_Unmarshal(TPML_ALG *target, BYTE **buffer,\
    \ INT32 *size)\n     if (rc == TPM_RC_SUCCESS) {\n \tif (target->count > MAX_ALG_LIST_SIZE)\
    \ {\n \t    rc = TPM_RC_SIZE;\n+\t    target->count = 0; // libtpms added\n \t\
    }\n     }\n     for (i = 0 ; (rc == TPM_RC_SUCCESS) && (i < target->count) ; i++)\
    \ {\n@@ -1948,6 +1953,7 @@ TPML_HANDLE_Unmarshal(TPML_HANDLE *target, BYTE **buffer,\
    \ INT32 *size)\n     if (rc == TPM_RC_SUCCESS) {\n \tif (target->count > MAX_CAP_HANDLES)\
    \ {\n \t    rc = TPM_RC_SIZE;\n+\t    target->count = 0; // libtpms added\n \t\
    }\n     }\n     for (i = 0 ; (rc == TPM_RC_SUCCESS) && (i < target->count) ; i++)\
    \ {\n@@ -1976,11 +1982,13 @@ TPML_DIGEST_Unmarshal(TPML_DIGEST *target, BYTE **buffer,\
    \ INT32 *size)\n \t/* TPM side is hard coded to 2 minimum */\n \tif (target->count\
    \ < 2) {\n \t    rc = TPM_RC_SIZE;\n+\t    target->count = 0; // libtpms added\n\
    \ \t}\n     }\n     if (rc == TPM_RC_SUCCESS) {\n \tif (target->count > 8) {\n\
    \ \t    rc = TPM_RC_SIZE;\n+\t    target->count = 0; // libtpms added\n \t}\n\
    \     }\n     for (i = 0 ; (rc == TPM_RC_SUCCESS) && (i < target->count) ; i++)\
    \ {\n@@ -2003,6 +2011,7 @@ TPML_DIGEST_VALUES_Unmarshal(TPML_DIGEST_VALUES *target,\
    \ BYTE **buffer, INT32 *s\n     if (rc == TPM_RC_SUCCESS) {\n \tif (target->count\
    \ > HASH_COUNT) {\n \t    rc = TPM_RC_SIZE;\n+\t    target->count = 0; // libtpms\
    \ added\n \t}\n     }\n     for (i = 0 ; (rc == TPM_RC_SUCCESS) && (i < target->count)\
    \ ; i++) {\n@@ -2025,6 +2034,7 @@ TPML_PCR_SELECTION_Unmarshal(TPML_PCR_SELECTION\
    \ *target, BYTE **buffer, INT32 *s\n     if (rc == TPM_RC_SUCCESS) {\n \tif (target->count\
    \ > HASH_COUNT) {\n \t    rc = TPM_RC_SIZE;\n+\t    target->count = 0; // libtpms\
    \ added\n \t}\n     }\n     for (i = 0 ; (rc == TPM_RC_SUCCESS) && (i < target->count)\
    \ ; i++) {\n@@ -2050,6 +2060,7 @@ TPML_ALG_PROPERTY_Unmarshal(TPML_ALG_PROPERTY\
    \ *target, BYTE **buffer, INT32 *siz\n     if (rc == TPM_RC_SUCCESS) {\n \tif\
    \ (target->count > MAX_CAP_ALGS) {\n \t    rc = TPM_RC_SIZE;\n+\t    target->count\
    \ = 0; // libtpms added\n \t}\n     }\n     for (i = 0 ; (rc == TPM_RC_SUCCESS)\
    \ && (i < target->count) ; i++) {\n@@ -2072,6 +2083,7 @@ TPML_TAGGED_TPM_PROPERTY_Unmarshal(TPML_TAGGED_TPM_PROPERTY\
    \  *target, BYTE **buf\n     if (rc == TPM_RC_SUCCESS) {\n \tif (target->count\
    \ > MAX_TPM_PROPERTIES) {\n \t    rc = TPM_RC_SIZE;\n+\t    target->count = 0;\
    \ // libtpms added\n \t}\n     }\n     for (i = 0 ; (rc == TPM_RC_SUCCESS) &&\
    \ (i < target->count) ; i++) {\n@@ -2094,6 +2106,7 @@ TPML_TAGGED_PCR_PROPERTY_Unmarshal(TPML_TAGGED_PCR_PROPERTY\
    \ *target, BYTE **buff\n     if (rc == TPM_RC_SUCCESS) {\n \tif (target->count\
    \ > MAX_PCR_PROPERTIES) {\n \t    rc = TPM_RC_SIZE;\n+\t    target->count = 0;\
    \ // libtpms added\n \t}\n     }\n     for (i = 0 ; (rc == TPM_RC_SUCCESS) &&\
    \ (i < target->count) ; i++) {\n@@ -2116,6 +2129,7 @@ TPML_ECC_CURVE_Unmarshal(TPML_ECC_CURVE\
    \ *target, BYTE **buffer, INT32 *size)\n     if (rc == TPM_RC_SUCCESS) {\n \t\
    if (target->count > MAX_ECC_CURVES) {\n \t    rc = TPM_RC_SIZE;\n+\t    target->count\
    \ = 0; // libtpms added\n \t}\n     }\n     for (i = 0 ; (rc == TPM_RC_SUCCESS)\
    \ && (i < target->count) ; i++) {\n@@ -2138,6 +2152,7 @@ TPML_TAGGED_POLICY_Unmarshal(TPML_TAGGED_POLICY\
    \ *target, BYTE **buffer, INT32 *s\n     if (rc == TPM_RC_SUCCESS) {\n \tif (target->count\
    \ > MAX_TAGGED_POLICIES) {\n \t    rc = TPM_RC_SIZE;\n+\t    target->count = 0;\
    \ // libtpms added\n \t}\n     }\n     for (i = 0 ; (rc == TPM_RC_SUCCESS) &&\
    \ (i < target->count) ; i++) {\n@@ -2787,6 +2802,7 @@ TPM2B_SENSITIVE_CREATE_Unmarshal(TPM2B_SENSITIVE_CREATE\
    \ *target, BYTE **buffer,\n     if (rc == TPM_RC_SUCCESS) {\n \tif (target->size\
    \ != startSize - *size) {\n \t    rc = TPM_RC_SIZE;\n+\t    target->size = 0;\
    \ // libtpms added\n \t}\n     }\n     return rc;\n@@ -3546,6 +3562,7 @@ TPM2B_ECC_POINT_Unmarshal(TPM2B_ECC_POINT\
    \ *target, BYTE **buffer, INT32 *size)\n     if (rc == TPM_RC_SUCCESS) {\n \t\
    if (target->size != startSize - *size) {\n \t    rc = TPM_RC_SIZE;\n+\t    target->size\
    \ = 0; // libtpms added\n \t}\n     }\n     return rc;\n@@ -4069,6 +4086,7 @@\
    \ TPM2B_PUBLIC_Unmarshal(TPM2B_PUBLIC *target, BYTE **buffer, INT32 *size, BOOL\
    \ al\n     if (rc == TPM_RC_SUCCESS) {\n \tif (target->size != startSize - *size)\
    \ {\n \t    rc = TPM_RC_SIZE;\n+\t    target->size = 0; // libtpms added\n \t\
    }\n     }\n     return rc;\n@@ -4164,6 +4182,7 @@ TPM2B_SENSITIVE_Unmarshal(TPM2B_SENSITIVE\
    \ *target, BYTE **buffer, INT32 *size)\n \tif (rc == TPM_RC_SUCCESS) {\n \t  \
    \  if (target->size != startSize - *size) {\n \t\trc = TPM_RC_SIZE;\n+\t\ttarget->size\
    \ = 0; // libtpms added\n \t    }\n \t}\n     }\n@@ -4239,6 +4258,7 @@ TPMS_NV_PUBLIC_Unmarshal(TPMS_NV_PUBLIC\
    \ *target, BYTE **buffer, INT32 *size)\n     if (rc == TPM_RC_SUCCESS) {\n \t\
    if (target->dataSize > MAX_NV_INDEX_SIZE) {\n \t    rc = TPM_RC_SIZE;\n+\t   \
    \ target->dataSize = 0; // libtpms added\n \t}\n     }\n     return rc;\n@@ -4269,6\
    \ +4289,7 @@ TPM2B_NV_PUBLIC_Unmarshal(TPM2B_NV_PUBLIC *target, BYTE **buffer,\
    \ INT32 *size)\n     if (rc == TPM_RC_SUCCESS) {\n \tif (target->size != startSize\
    \ - *size) {\n \t    rc = TPM_RC_SIZE;\n+\t    target->size = 0; // libtpms added\n\
    \ \t}\n     }\n     return rc;"
  - "--- a/src/tpm2/Marshal.c\n+++ b/src/tpm2/Marshal.c\n@@ -59,6 +59,7 @@\n /*\t\t\
    \t\t\t\t\t\t\t\t*/\n /********************************************************************************/\n\
    \ \n+#include <assert.h> // libtpms added\n #include <string.h>\n \n #include\
    \ \"Tpm.h\"\n@@ -176,9 +177,10 @@ Array_Marshal(BYTE *sourceBuffer, UINT16 sourceSize,\
    \ BYTE **buffer, INT32 *size)\n }\n \n UINT16\n-TPM2B_Marshal(TPM2B *source, BYTE\
    \ **buffer, INT32 *size)\n+TPM2B_Marshal(TPM2B *source, UINT32 maxSize, BYTE **buffer,\
    \ INT32 *size)\n {\n     UINT16 written = 0;\n+    assert(source->size <= maxSize);\
    \ // libtpms added\n     written += UINT16_Marshal(&(source->size), buffer, size);\n\
    \     written += Array_Marshal(source->buffer, source->size, buffer, size); \n\
    \     return written;\n@@ -503,7 +505,7 @@ UINT16\n TPM2B_DIGEST_Marshal(TPM2B_DIGEST\
    \ *source, BYTE **buffer, INT32 *size)\n {\n UINT16 written = 0;\n-written +=\
    \ TPM2B_Marshal(&source->b, buffer, size);\n+written += TPM2B_Marshal(&source->b,\
    \ sizeof(source->t.buffer), buffer, size); // libtpms changed\n return written;\n\
    \ }\n \n@@ -513,7 +515,7 @@ UINT16\n TPM2B_DATA_Marshal(TPM2B_DATA *source, BYTE\
    \ **buffer, INT32 *size)\n {\n UINT16 written = 0;\n-written += TPM2B_Marshal(&source->b,\
    \ buffer, size);\n+written += TPM2B_Marshal(&source->b, sizeof(source->t.buffer),\
    \ buffer, size); // libtpms changed\n return written;\n }\n \n@@ -543,7 +545,7\
    \ @@ UINT16\n TPM2B_MAX_BUFFER_Marshal(TPM2B_MAX_BUFFER *source, BYTE **buffer,\
    \ INT32 *size)\n {\n     UINT16 written = 0;\n-    written += TPM2B_Marshal(&source->b,\
    \ buffer, size);\n+    written += TPM2B_Marshal(&source->b, sizeof(source->t.buffer),\
    \ buffer, size); // libtpms changed\n     return written;\n }\n \n@@ -553,7 +555,7\
    \ @@ UINT16\n TPM2B_MAX_NV_BUFFER_Marshal(TPM2B_MAX_NV_BUFFER *source, BYTE **buffer,\
    \ INT32 *size)\n {\n     UINT16 written = 0;\n-    written += TPM2B_Marshal(&source->b,\
    \ buffer, size);\n+    written += TPM2B_Marshal(&source->b, sizeof(source->t.buffer),\
    \ buffer, size); // libtpms changed\n     return written;\n }\n \n@@ -562,7 +564,7\
    \ @@ UINT16\n TPM2B_TIMEOUT_Marshal(TPM2B_TIMEOUT *source, BYTE **buffer, INT32\
    \ *size)\n {\n     UINT16 written = 0;\n-    written += TPM2B_Marshal(&source->b,\
    \ buffer, size);\n+    written += TPM2B_Marshal(&source->b, sizeof(source->t.buffer),\
    \ buffer, size); // libtpms changed\n     return written;\n }\n \n@@ -572,7 +574,7\
    \ @@ UINT16\n TPM2B_IV_Marshal(TPM2B_IV *source, BYTE **buffer, INT32 *size)\n\
    \ {\n     UINT16 written = 0;\n-    written += TPM2B_Marshal(&source->b, buffer,\
    \ size);\n+    written += TPM2B_Marshal(&source->b, sizeof(source->t.buffer),\
    \ buffer, size); // libtpms changed\n     return written;\n }\n \n@@ -582,7 +584,7\
    \ @@ UINT16\n TPM2B_NAME_Marshal(TPM2B_NAME *source, BYTE **buffer, INT32 *size)\n\
    \ {\n     UINT16 written = 0;\n-    written += TPM2B_Marshal(&source->b, buffer,\
    \ size);\n+    written += TPM2B_Marshal(&source->b, sizeof(source->t.name), buffer,\
    \ size); // libtpms changed\n     return written;\n }\n \n@@ -1163,7 +1165,7 @@\
    \ UINT16\n TPM2B_ATTEST_Marshal(TPM2B_ATTEST *source, BYTE **buffer, INT32 *size)\n\
    \ {\n     UINT16 written = 0;\n-    written += TPM2B_Marshal(&source->b, buffer,\
    \ size);\n+    written += TPM2B_Marshal(&source->b, sizeof(source->t.attestationData),\
    \ buffer, size); // libtpms changed\n     return written;\n }\n \n@@ -1294,7 +1296,7\
    \ @@ UINT16\n TPM2B_SYM_KEY_Marshal(TPM2B_SYM_KEY *source, BYTE **buffer, INT32\
    \ *size)\n {\n     UINT16 written = 0;\n-    written += TPM2B_Marshal(&source->b,\
    \ buffer, size);\n+    written += TPM2B_Marshal(&source->b, sizeof(source->t.buffer),\
    \ buffer, size); // libtpms changed\n     return written;\n }\n \n@@ -1315,7 +1317,7\
    \ @@ UINT16\n TPM2B_SENSITIVE_DATA_Marshal(TPM2B_SENSITIVE_DATA *source, BYTE\
    \ **buffer, INT32 *size)\n {\n     UINT16 written = 0;\n-    written += TPM2B_Marshal(&source->b,\
    \ buffer, size);\n+    written += TPM2B_Marshal(&source->b, sizeof(source->t.buffer),\
    \ buffer, size); // libtpms changed\n     return written;\n }\n \n@@ -1673,7 +1675,7\
    \ @@ UINT16\n TPM2B_PUBLIC_KEY_RSA_Marshal(TPM2B_PUBLIC_KEY_RSA *source, BYTE\
    \ **buffer, INT32 *size)\n {\n     UINT16 written = 0;\n-    written += TPM2B_Marshal(&source->b,\
    \ buffer, size);\n+    written += TPM2B_Marshal(&source->b, sizeof(source->t.buffer),\
    \ buffer, size); // libtpms changed\n     return written;\n }\n \n@@ -1693,7 +1695,7\
    \ @@ UINT16\n TPM2B_PRIVATE_KEY_RSA_Marshal(TPM2B_PRIVATE_KEY_RSA *source, BYTE\
    \ **buffer, INT32 *size)\n {\n     UINT16 written = 0;\n-    written += TPM2B_Marshal(&source->b,\
    \ buffer, size);\n+    written += TPM2B_Marshal(&source->b, sizeof(source->t.buffer),\
    \ buffer, size); // libtpms changed\n     return written;\n }\n \n@@ -1703,7 +1705,7\
    \ @@ UINT16\n TPM2B_ECC_PARAMETER_Marshal(TPM2B_ECC_PARAMETER *source, BYTE **buffer,\
    \ INT32 *size)\n {\n     UINT16 written = 0;\n-    written += TPM2B_Marshal(&source->b,\
    \ buffer, size);\n+    written += TPM2B_Marshal(&source->b, sizeof(source->t.buffer),\
    \ buffer, size); // libtpms changed\n     return written;\n }\n \n@@ -1937,7 +1939,7\
    \ @@ UINT16\n TPM2B_ENCRYPTED_SECRET_Marshal(TPM2B_ENCRYPTED_SECRET *source, BYTE\
    \ **buffer, INT32 *size)\n {\n     UINT16 written = 0;\n-    written += TPM2B_Marshal(&source->b,\
    \ buffer, size);\n+    written += TPM2B_Marshal(&source->b, sizeof(source->t.secret),\
    \ buffer, size); // libtpms changed\n     return written;\n }\n  \n@@ -2148,7\
    \ +2150,7 @@ UINT16\n TPM2B_PRIVATE_Marshal(TPM2B_PRIVATE *source, BYTE **buffer,\
    \ INT32 *size)\n {\n     UINT16 written = 0;\n-    written += TPM2B_Marshal(&source->b,\
    \ buffer, size);\n+    written += TPM2B_Marshal(&source->b, sizeof(source->t.buffer),\
    \ buffer, size); // libtpms changed\n     return written;\n }\n \n@@ -2158,7 +2160,7\
    \ @@ UINT16\n TPM2B_ID_OBJECT_Marshal(TPM2B_ID_OBJECT *source, BYTE **buffer,\
    \ INT32 *size)\n {\n     UINT16 written = 0;\n-    written += TPM2B_Marshal(&source->b,\
    \ buffer, size);\n+    written += TPM2B_Marshal(&source->b, sizeof(source->t.credential),\
    \ buffer, size); // libtpms changed\n     return written;\n }\n \n@@ -2215,7 +2217,7\
    \ @@ UINT16\n TPM2B_CONTEXT_DATA_Marshal(TPM2B_CONTEXT_DATA  *source, BYTE **buffer,\
    \ INT32 *size)\n {\n     UINT16 written = 0;\n-    written += TPM2B_Marshal(&source->b,\
    \ buffer, size);\n+    written += TPM2B_Marshal(&source->b, sizeof(source->t.buffer),\
    \ buffer, size); // libtpms changed\n     return written;\n }\n "
  - "--- a/src/tpm2/NVMarshal.c\n+++ b/src/tpm2/NVMarshal.c\n@@ -278,7 +278,7 @@ static\
    \ UINT16\n TPM2B_PROOF_Marshal(TPM2B_PROOF *source, BYTE **buffer, INT32 *size)\n\
    \ {\n     UINT16 written = 0;\n-    written += TPM2B_Marshal(&source->b, buffer,\
    \ size);\n+    written += TPM2B_Marshal(&source->b, sizeof(source->t.buffer),\
    \ buffer, size);\n     return written;\n }\n \n@@ -1414,7 +1414,7 @@ STATE_RESET_DATA_Marshal(STATE_RESET_DATA\
    \ *data, BYTE **buffer, INT32 *size)\n                                 STATE_RESET_DATA_VERSION,\n\
    \                                 STATE_RESET_DATA_MAGIC, 4);\n     written +=\
    \ TPM2B_PROOF_Marshal(&data->nullProof, buffer, size);\n-    written += TPM2B_Marshal(&data->nullSeed.b,\
    \ buffer, size);\n+    written += TPM2B_Marshal(&data->nullSeed.b, sizeof(data->nullSeed.t.buffer),\
    \ buffer, size);\n     written += UINT32_Marshal(&data->clearCount, buffer, size);\n\
    \     written += UINT64_Marshal(&data->objectContextID, buffer, size);\n \n@@\
    \ -2203,7 +2203,7 @@ TPM2B_HASH_BLOCK_Marshal(TPM2B_HASH_BLOCK *data, BYTE **buffer,\
    \ INT32 *size)\n {\n     UINT16 written;\n \n-    written = TPM2B_Marshal(&data->b,\
    \ buffer, size);\n+    written = TPM2B_Marshal(&data->b, sizeof(data->t.buffer),\
    \ buffer, size);\n \n     return written;\n }\n@@ -3087,9 +3087,9 @@ VolatileState_Marshal(BYTE\
    \ **buffer, INT32 *size)\n \n     /* tie the volatile state to the EP,SP, and\
    \ PPSeed */\n     NvRead(&pd, NV_PERSISTENT_DATA, sizeof(pd));\n-    written +=\
    \ TPM2B_Marshal(&pd.EPSeed.b, buffer, size);\n-    written += TPM2B_Marshal(&pd.SPSeed.b,\
    \ buffer, size);\n-    written += TPM2B_Marshal(&pd.PPSeed.b, buffer, size);\n\
    +    written += TPM2B_Marshal(&pd.EPSeed.b, sizeof(pd.EPSeed.t.buffer), buffer,\
    \ size);\n+    written += TPM2B_Marshal(&pd.SPSeed.b, sizeof(pd.SPSeed.t.buffer),\
    \ buffer, size);\n+    written += TPM2B_Marshal(&pd.PPSeed.b, sizeof(pd.PPSeed.t.buffer),\
    \ buffer, size);\n \n     written += BLOCK_SKIP_WRITE_PUSH(TRUE, buffer, size);\
    \ /* v4 */\n \n@@ -3906,9 +3906,9 @@ PERSISTENT_DATA_Marshal(PERSISTENT_DATA *data,\
    \ BYTE **buffer, INT32 *size)\n     written += TPM2B_AUTH_Marshal(&data->ownerAuth,\
    \ buffer, size);\n     written += TPM2B_AUTH_Marshal(&data->endorsementAuth, buffer,\
    \ size);\n     written += TPM2B_AUTH_Marshal(&data->lockoutAuth, buffer, size);\n\
    -    written += TPM2B_Marshal(&data->EPSeed.b, buffer, size);\n-    written +=\
    \ TPM2B_Marshal(&data->SPSeed.b, buffer, size);\n-    written += TPM2B_Marshal(&data->PPSeed.b,\
    \ buffer, size);\n+    written += TPM2B_Marshal(&data->EPSeed.b, sizeof(data->EPSeed.t.buffer),\
    \ buffer, size);\n+    written += TPM2B_Marshal(&data->SPSeed.b, sizeof(data->SPSeed.t.buffer),\
    \ buffer, size);\n+    written += TPM2B_Marshal(&data->PPSeed.b, sizeof(data->PPSeed.t.buffer),\
    \ buffer, size);\n     written += TPM2B_PROOF_Marshal(&data->phProof, buffer,\
    \ size);\n     written += TPM2B_PROOF_Marshal(&data->shProof, buffer, size);\n\
    \     written += TPM2B_PROOF_Marshal(&data->ehProof, buffer, size);"
  identifiers:
  - CVE-2021-3623
  - CWE-787
  overview: A flaw was found in libtpms. The flaw can be triggered by specially-crafted
    TPM 2 command packets containing illegal values and may lead to an out-of-bounds
    access when the volatile state of the TPM 2 is marshalled/written or unmarshalled/read.
    The highest threat from this vulnerability is to system availability.
  references:
  - source: secalert@redhat.com
    tags:
    - Issue Tracking
    - Patch
    - Third Party Advisory
    url: https://bugzilla.redhat.com/show_bug.cgi?id=1976806
  - source: secalert@redhat.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/stefanberger/libtpms/commit/2e6173c
  - source: secalert@redhat.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/stefanberger/libtpms/commit/2f30d62
  - source: secalert@redhat.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/stefanberger/libtpms/commit/7981d9a
  - source: secalert@redhat.com
    tags:
    - Issue Tracking
    - Third Party Advisory
    url: https://github.com/stefanberger/libtpms/pull/223
  - source: secalert@redhat.com
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/Z7KZSYMTE7Z4BBEZUWO2DIMQDWMGEP46/
  title: A flaw was found in libtpms. The flaw can be triggered by specially-crafted
    TPM 2 command packets containing illegal values and may lead to an out-of-bounds
    access when the volatile state of the TPM 2 is marshalled/written or unmarshalled/read.
    The highest threat from this vulnerability is to system availability.
- diff_content:
  - "--- a/src/security/security_selinux.c\n+++ b/src/security/security_selinux.c\n\
    @@ -383,7 +383,15 @@ virSecuritySELinuxMCSFind(virSecurityManager *mgr,\n    \
    \     VIR_DEBUG(\"Try cat %s:c%d,c%d\", sens, c1 + catMin, c2 + catMin);\n \n\
    \         if (c1 == c2) {\n-            mcs = g_strdup_printf(\"%s:c%d\", sens,\
    \ catMin + c1);\n+            /*\n+             * A process can access a file\
    \ if the set of MCS categories\n+             * for the file is equal-to *or*\
    \ a subset-of, the set of\n+             * MCS categories for the process.\n+\
    \             *\n+             * IOW, we must discard case where the categories\
    \ are equal\n+             * because that is a subset of other category pairs.\n\
    +             */\n+            continue;\n         } else {\n             if (c1\
    \ > c2) {\n                 int t = c1;\n"
  identifiers:
  - CVE-2021-3631
  - CWE-732
  overview: A flaw was found in libvirt while it generates SELinux MCS category pairs
    for VMs' dynamic labels. This flaw allows one exploited guest to access files
    labeled for another guest, resulting in the breaking out of sVirt confinement.
    The highest threat from this vulnerability is to confidentiality and integrity.
  references:
  - source: secalert@redhat.com
    tags:
    - Vendor Advisory
    url: https://access.redhat.com/errata/RHSA-2021:3631
  - source: secalert@redhat.com
    tags:
    - Issue Tracking
    - Vendor Advisory
    url: https://bugzilla.redhat.com/show_bug.cgi?id=1977726
  - source: secalert@redhat.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://gitlab.com/libvirt/libvirt/-/commit/15073504dbb624d3f6c911e85557019d3620fdb2
  - source: secalert@redhat.com
    tags:
    - Exploit
    - Third Party Advisory
    url: https://gitlab.com/libvirt/libvirt/-/issues/153
  - source: secalert@redhat.com
    url: https://lists.debian.org/debian-lts-announce/2024/04/msg00000.html
  - source: secalert@redhat.com
    tags:
    - Third Party Advisory
    url: https://security.gentoo.org/glsa/202210-06
  - source: secalert@redhat.com
    tags:
    - Third Party Advisory
    url: https://security.netapp.com/advisory/ntap-20220331-0010/
  title: A flaw was found in libvirt while it generates SELinux MCS category pairs
    for VMs' dynamic labels. This flaw allows one exploited guest to access files
    labeled for another guest, resulting in the breaking out of sVirt confinement.
    The highest threat from this vulnerability is to confidentiality and integrity.
- diff_content:
  - "--- a/src/adapter.c\n+++ b/src/adapter.c\n@@ -560,7 +560,11 @@ static void settings_changed(struct\
    \ btd_adapter *adapter, uint32_t settings)\n \tif (changed_mask & MGMT_SETTING_DISCOVERABLE)\
    \ {\n \t\tg_dbus_emit_property_changed(dbus_conn, adapter->path,\n \t\t\t\t\t\
    ADAPTER_INTERFACE, \"Discoverable\");\n-\t\tstore_adapter_info(adapter);\n+\t\t\
    /* Only persist discoverable setting if it was not set\n+\t\t * temporarily by\
    \ discovery.\n+\t\t */\n+\t\tif (!adapter->discovery_discoverable)\n+\t\t\tstore_adapter_info(adapter);\n\
    \ \t\tbtd_adv_manager_refresh(adapter->adv_manager);\n \t}\n \n@@ -2162,8 +2166,6\
    \ @@ static bool filters_equal(struct mgmt_cp_start_service_discovery *a,\n static\
    \ int update_discovery_filter(struct btd_adapter *adapter)\n {\n \tstruct mgmt_cp_start_service_discovery\
    \ *sd_cp;\n-\tGSList *l;\n-\n \n \tDBG(\"\");\n \n@@ -2173,17 +2175,24 @@ static\
    \ int update_discovery_filter(struct btd_adapter *adapter)\n \t\treturn -ENOMEM;\n\
    \ \t}\n \n-\tfor (l = adapter->discovery_list; l; l = g_slist_next(l)) {\n-\t\t\
    struct discovery_client *client = l->data;\n+\t/* Only attempt to overwrite current\
    \ discoverable setting when not\n+\t * discoverable.\n+\t */\n+\tif (!(adapter->current_settings\
    \ & MGMT_OP_SET_DISCOVERABLE)) {\n+\t\tGSList *l;\n \n-\t\tif (!client->discovery_filter)\n\
    -\t\t\tcontinue;\n+\t\tfor (l = adapter->discovery_list; l; l = g_slist_next(l))\
    \ {\n+\t\t\tstruct discovery_client *client = l->data;\n \n-\t\tif (client->discovery_filter->discoverable)\n\
    -\t\t\tbreak;\n-\t}\n+\t\t\tif (!client->discovery_filter)\n+\t\t\t\tcontinue;\n\
    \ \n-\tset_discovery_discoverable(adapter, l ? true : false);\n+\t\t\tif (client->discovery_filter->discoverable)\
    \ {\n+\t\t\t\tset_discovery_discoverable(adapter, true);\n+\t\t\t\tbreak;\n+\t\
    \t\t}\n+\t\t}\n+\t}\n \n \t/*\n \t * If filters are equal, then don't update scan,\
    \ except for when\n@@ -2216,8 +2225,7 @@ static int discovery_stop(struct discovery_client\
    \ *client)\n \t\treturn 0;\n \t}\n \n-\tif (adapter->discovery_discoverable)\n\
    -\t\tset_discovery_discoverable(adapter, false);\n+\tset_discovery_discoverable(adapter,\
    \ false);\n \n \t/*\n \t * In the idle phase of a discovery, there is no need\
    \ to stop it\n@@ -6913,6 +6921,7 @@ static void adapter_stop(struct btd_adapter\
    \ *adapter)\n \tg_free(adapter->current_discovery_filter);\n \tadapter->current_discovery_filter\
    \ = NULL;\n \n+\tset_discovery_discoverable(adapter, false);\n \tadapter->discovering\
    \ = false;\n \n \twhile (adapter->connections) {"
  identifiers:
  - CVE-2021-3658
  - CWE-863
  overview: bluetoothd from bluez incorrectly saves adapters' Discoverable status
    when a device is powered down, and restores it when powered up. If a device is
    powered down while discoverable, it will be discoverable when powered on again.
    This could lead to inadvertent exposure of the bluetooth stack to physically nearby
    attackers.
  references:
  - source: secalert@redhat.com
    tags:
    - Issue Tracking
    - Patch
    - Third Party Advisory
    url: https://bugzilla.redhat.com/show_bug.cgi?id=1984728
  - source: secalert@redhat.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://git.kernel.org/pub/scm/bluetooth/bluez.git/commit/?id=b497b5942a8beb8f89ca1c359c54ad67ec843055
  - source: secalert@redhat.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/bluez/bluez/commit/b497b5942a8beb8f89ca1c359c54ad67ec843055
  - source: secalert@redhat.com
    tags:
    - Issue Tracking
    - Patch
    - Third Party Advisory
    url: https://gitlab.gnome.org/GNOME/gnome-bluetooth/-/issues/89
  - source: secalert@redhat.com
    tags:
    - Third Party Advisory
    url: https://security.netapp.com/advisory/ntap-20220407-0002/
  title: bluetoothd from bluez incorrectly saves adapters' Discoverable status when
    a device is powered down, and restores it when powered up. If a device is powered
    down while discoverable, it will be discoverable when powered on again. This could
    lead to inadvertent exposure of the bluetooth stack to physically nearby attackers.
- diff_content:
  - "--- a/src/storage/storage_driver.c\n+++ b/src/storage/storage_driver.c\n@@ -1738,8\
    \ +1738,10 @@ storagePoolLookupByTargetPath(virConnectPtr conn,\n            \
    \                                storagePoolLookupByTargetPathCallback,\n    \
    \                                        cleanpath))) {\n         def = virStoragePoolObjGetDef(obj);\n\
    -        if (virStoragePoolLookupByTargetPathEnsureACL(conn, def) < 0)\n+    \
    \    if (virStoragePoolLookupByTargetPathEnsureACL(conn, def) < 0) {\n+      \
    \      virStoragePoolObjEndAPI(&obj);\n             return NULL;\n+        }\n\
    \ \n         pool = virGetStoragePool(conn, def->name, def->uuid, NULL, NULL);\n\
    \         virStoragePoolObjEndAPI(&obj);\n"
  identifiers:
  - CVE-2021-3667
  - CWE-667
  overview: An improper locking issue was found in the virStoragePoolLookupByTargetPath
    API of libvirt. It occurs in the storagePoolLookupByTargetPath function where
    a locked virStoragePoolObj object is not properly released on ACL permission failure.
    Clients connecting to the read-write socket with limited ACL permissions could
    use this flaw to acquire the lock and prevent other users from accessing storage
    pool/volume APIs, resulting in a denial of service condition. The highest threat
    from this vulnerability is to system availability.
  references:
  - source: secalert@redhat.com
    tags:
    - Issue Tracking
    - Vendor Advisory
    url: https://bugzilla.redhat.com/show_bug.cgi?id=1986094
  - source: secalert@redhat.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://gitlab.com/libvirt/libvirt/-/commit/447f69dec47e1b0bd15ecd7cd49a9fd3b050fb87
  - source: secalert@redhat.com
    url: https://libvirt.org/git/?p=libvirt.git%3Ba=commit%3Bh=447f69dec47e1b0bd15ecd7cd49a9fd3b050fb87
  - source: secalert@redhat.com
    url: https://lists.debian.org/debian-lts-announce/2024/04/msg00000.html
  - source: secalert@redhat.com
    tags:
    - Third Party Advisory
    url: https://security.gentoo.org/glsa/202210-06
  - source: secalert@redhat.com
    tags:
    - Third Party Advisory
    url: https://security.netapp.com/advisory/ntap-20220331-0005/
  title: An improper locking issue was found in the virStoragePoolLookupByTargetPath
    API of libvirt. It occurs in the storagePoolLookupByTargetPath function where
    a locked virStoragePoolObj object is not properly released on ACL permission failure.
    Clients connecting to the read-write socket with limited ACL permissions could
    use this flaw to acquire the lock and prevent other users from accessing storage
    pool/volume APIs, resulting in a denial of service condition. The highest threat
    from this vulnerability is to system availability.
- diff_content:
  - "--- a/server/protocol-handshake-newstyle.c\n+++ b/server/protocol-handshake-newstyle.c\n\
    @@ -495,7 +495,8 @@ negotiate_handshake_newstyle_options (void)\n           return\
    \ -1;\n         conn->using_tls = true;\n         debug (\"using TLS on this connection\"\
    );\n-        /* Wipe out any cached default export name. */\n+        /* Wipe\
    \ out any cached state. */\n+        conn->structured_replies = false;\n     \
    \    for_each_backend (b) {\n           free (conn->default_exportname[b->i]);\n\
    \           conn->default_exportname[b->i] = NULL;\n"
  - "--- a/server/protocol-handshake-newstyle.c\n+++ b/server/protocol-handshake-newstyle.c\n\
    @@ -497,6 +497,9 @@ negotiate_handshake_newstyle_options (void)\n         debug\
    \ (\"using TLS on this connection\");\n         /* Wipe out any cached state.\
    \ */\n         conn->structured_replies = false;\n+        free (conn->exportname_from_set_meta_context);\n\
    +        conn->exportname_from_set_meta_context = NULL;\n+        conn->meta_context_base_allocation\
    \ = false;\n         for_each_backend (b) {\n           free (conn->default_exportname[b->i]);\n\
    \           conn->default_exportname[b->i] = NULL;\n"
  identifiers:
  - CVE-2021-3716
  - NVD-CWE-Other
  overview: A flaw was found in nbdkit due to to improperly caching plaintext state
    across the STARTTLS encryption boundary. A MitM attacker could use this flaw to
    inject a plaintext NBD_OPT_STRUCTURED_REPLY before proxying everything else a
    client sends to the server, potentially leading the client to terminate the NBD
    session. The highest threat from this vulnerability is to system availability.
  references:
  - source: secalert@redhat.com
    tags:
    - Issue Tracking
    - Patch
    - Third Party Advisory
    url: https://bugzilla.redhat.com/show_bug.cgi?id=1994695
  - source: secalert@redhat.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://gitlab.com/nbdkit/nbdkit/-/commit/09a13dafb7bb3a38ab52eb5501cba786365ba7fd
  - source: secalert@redhat.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://gitlab.com/nbdkit/nbdkit/-/commit/6c5faac6a37077cf2366388a80862bb00616d0d8
  - source: secalert@redhat.com
    tags:
    - Broken Link
    url: https://listman.redhat.com/archives/libguestfs/2021-August/msg00083.html
  - source: secalert@redhat.com
    tags:
    - Mailing List
    - Third Party Advisory
    url: https://www.openwall.com/lists/oss-security/2021/08/18/2
  title: A flaw was found in nbdkit due to to improperly caching plaintext state across
    the STARTTLS encryption boundary. A MitM attacker could use this flaw to inject
    a plaintext NBD_OPT_STRUCTURED_REPLY before proxying everything else a client
    sends to the server, potentially leading the client to terminate the NBD session.
    The highest threat from this vulnerability is to system availability.
- diff_content:
  - "--- a/net/sctp/sm_statefuns.c\n+++ b/net/sctp/sm_statefuns.c\n@@ -156,6 +156,12\
    \ @@ static enum sctp_disposition __sctp_sf_do_9_1_abort(\n \t\t\t\t\tvoid *arg,\n\
    \ \t\t\t\t\tstruct sctp_cmd_seq *commands);\n \n+static enum sctp_disposition\n\
    +__sctp_sf_do_9_2_reshutack(struct net *net, const struct sctp_endpoint *ep,\n\
    +\t\t\t   const struct sctp_association *asoc,\n+\t\t\t   const union sctp_subtype\
    \ type, void *arg,\n+\t\t\t   struct sctp_cmd_seq *commands);\n+\n /* Small helper\
    \ function that checks if the chunk length\n  * is of the appropriate length.\
    \  The 'required_length' argument\n  * is set to be the size of a specific chunk\
    \ we are testing.\n@@ -337,6 +343,14 @@ enum sctp_disposition sctp_sf_do_5_1B_init(struct\
    \ net *net,\n \tif (!chunk->singleton)\n \t\treturn sctp_sf_pdiscard(net, ep,\
    \ asoc, type, arg, commands);\n \n+\t/* Make sure that the INIT chunk has a valid\
    \ length.\n+\t * Normally, this would cause an ABORT with a Protocol Violation\n\
    +\t * error, but since we don't have an association, we'll\n+\t * just discard\
    \ the packet.\n+\t */\n+\tif (!sctp_chunk_length_valid(chunk, sizeof(struct sctp_init_chunk)))\n\
    +\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n+\n \t/* If\
    \ the packet is an OOTB packet which is temporarily on the\n \t * control endpoint,\
    \ respond with an ABORT.\n \t */\n@@ -351,14 +365,6 @@ enum sctp_disposition sctp_sf_do_5_1B_init(struct\
    \ net *net,\n \tif (chunk->sctp_hdr->vtag != 0)\n \t\treturn sctp_sf_tabort_8_4_8(net,\
    \ ep, asoc, type, arg, commands);\n \n-\t/* Make sure that the INIT chunk has\
    \ a valid length.\n-\t * Normally, this would cause an ABORT with a Protocol Violation\n\
    -\t * error, but since we don't have an association, we'll\n-\t * just discard\
    \ the packet.\n-\t */\n-\tif (!sctp_chunk_length_valid(chunk, sizeof(struct sctp_init_chunk)))\n\
    -\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n-\n \t/* If\
    \ the INIT is coming toward a closing socket, we'll send back\n \t * and ABORT.\
    \  Essentially, this catches the race of INIT being\n \t * backloged to the socket\
    \ at the same time as the user issues close().\n@@ -704,6 +710,9 @@ enum sctp_disposition\
    \ sctp_sf_do_5_1D_ce(struct net *net,\n \tstruct sock *sk;\n \tint error = 0;\n\
    \ \n+\tif (asoc && !sctp_vtag_verify(chunk, asoc))\n+\t\treturn sctp_sf_pdiscard(net,\
    \ ep, asoc, type, arg, commands);\n+\n \t/* If the packet is an OOTB packet which\
    \ is temporarily on the\n \t * control endpoint, respond with an ABORT.\n \t */\n\
    @@ -718,7 +727,8 @@ enum sctp_disposition sctp_sf_do_5_1D_ce(struct net *net,\n\
    \ \t * in sctp_unpack_cookie().\n \t */\n \tif (!sctp_chunk_length_valid(chunk,\
    \ sizeof(struct sctp_chunkhdr)))\n-\t\treturn sctp_sf_pdiscard(net, ep, asoc,\
    \ type, arg, commands);\n+\t\treturn sctp_sf_violation_chunklen(net, ep, asoc,\
    \ type, arg,\n+\t\t\t\t\t\t  commands);\n \n \t/* If the endpoint is not listening\
    \ or if the number of associations\n \t * on the TCP-style socket exceed the max\
    \ backlog, respond with an\n@@ -1524,20 +1534,16 @@ static enum sctp_disposition\
    \ sctp_sf_do_unexpected_init(\n \tif (!chunk->singleton)\n \t\treturn sctp_sf_pdiscard(net,\
    \ ep, asoc, type, arg, commands);\n \n+\t/* Make sure that the INIT chunk has\
    \ a valid length. */\n+\tif (!sctp_chunk_length_valid(chunk, sizeof(struct sctp_init_chunk)))\n\
    +\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n+\n \t/* 3.1\
    \ A packet containing an INIT chunk MUST have a zero Verification\n \t * Tag.\n\
    \ \t */\n \tif (chunk->sctp_hdr->vtag != 0)\n \t\treturn sctp_sf_tabort_8_4_8(net,\
    \ ep, asoc, type, arg, commands);\n \n-\t/* Make sure that the INIT chunk has\
    \ a valid length.\n-\t * In this case, we generate a protocol violation since\
    \ we have\n-\t * an association established.\n-\t */\n-\tif (!sctp_chunk_length_valid(chunk,\
    \ sizeof(struct sctp_init_chunk)))\n-\t\treturn sctp_sf_violation_chunklen(net,\
    \ ep, asoc, type, arg,\n-\t\t\t\t\t\t  commands);\n-\n \tif (SCTP_INPUT_CB(chunk->skb)->encap_port\
    \ != chunk->transport->encap_port)\n \t\treturn sctp_sf_new_encap_port(net, ep,\
    \ asoc, type, arg, commands);\n \n@@ -1882,9 +1888,9 @@ static enum sctp_disposition\
    \ sctp_sf_do_dupcook_a(\n \t * its peer.\n \t*/\n \tif (sctp_state(asoc, SHUTDOWN_ACK_SENT))\
    \ {\n-\t\tdisposition = sctp_sf_do_9_2_reshutack(net, ep, asoc,\n-\t\t\t\tSCTP_ST_CHUNK(chunk->chunk_hdr->type),\n\
    -\t\t\t\tchunk, commands);\n+\t\tdisposition = __sctp_sf_do_9_2_reshutack(net,\
    \ ep, asoc,\n+\t\t\t\t\t\t\t SCTP_ST_CHUNK(chunk->chunk_hdr->type),\n+\t\t\t\t\
    \t\t\t chunk, commands);\n \t\tif (SCTP_DISPOSITION_NOMEM == disposition)\n \t\
    \t\tgoto nomem;\n \n@@ -2202,9 +2208,11 @@ enum sctp_disposition sctp_sf_do_5_2_4_dupcook(\n\
    \ \t * enough for the chunk header.  Cookie length verification is\n \t * done\
    \ later.\n \t */\n-\tif (!sctp_chunk_length_valid(chunk, sizeof(struct sctp_chunkhdr)))\n\
    -\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n-\t\t\t\t\t\t\
    \  commands);\n+\tif (!sctp_chunk_length_valid(chunk, sizeof(struct sctp_chunkhdr)))\
    \ {\n+\t\tif (!sctp_vtag_verify(chunk, asoc))\n+\t\t\tasoc = NULL;\n+\t\treturn\
    \ sctp_sf_violation_chunklen(net, ep, asoc, type, arg, commands);\n+\t}\n \n \t\
    /* \"Decode\" the chunk.  We have no optional parameters so we\n \t * are in good\
    \ shape.\n@@ -2341,7 +2349,7 @@ enum sctp_disposition sctp_sf_shutdown_pending_abort(\n\
    \ \t */\n \tif (SCTP_ADDR_DEL ==\n \t\t    sctp_bind_addr_state(&asoc->base.bind_addr,\
    \ &chunk->dest))\n-\t\treturn sctp_sf_discard_chunk(net, ep, asoc, type, arg,\
    \ commands);\n+\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\
    \ \n \tif (!sctp_err_chunk_valid(chunk))\n \t\treturn sctp_sf_pdiscard(net, ep,\
    \ asoc, type, arg, commands);\n@@ -2387,7 +2395,7 @@ enum sctp_disposition sctp_sf_shutdown_sent_abort(\n\
    \ \t */\n \tif (SCTP_ADDR_DEL ==\n \t\t    sctp_bind_addr_state(&asoc->base.bind_addr,\
    \ &chunk->dest))\n-\t\treturn sctp_sf_discard_chunk(net, ep, asoc, type, arg,\
    \ commands);\n+\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\
    \ \n \tif (!sctp_err_chunk_valid(chunk))\n \t\treturn sctp_sf_pdiscard(net, ep,\
    \ asoc, type, arg, commands);\n@@ -2657,7 +2665,7 @@ enum sctp_disposition sctp_sf_do_9_1_abort(\n\
    \ \t */\n \tif (SCTP_ADDR_DEL ==\n \t\t    sctp_bind_addr_state(&asoc->base.bind_addr,\
    \ &chunk->dest))\n-\t\treturn sctp_sf_discard_chunk(net, ep, asoc, type, arg,\
    \ commands);\n+\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\
    \ \n \tif (!sctp_err_chunk_valid(chunk))\n \t\treturn sctp_sf_pdiscard(net, ep,\
    \ asoc, type, arg, commands);\n@@ -2970,13 +2978,11 @@ enum sctp_disposition sctp_sf_do_9_2_shut_ctsn(\n\
    \  * that belong to this association, it should discard the INIT chunk and\n \
    \ * retransmit the SHUTDOWN ACK chunk.\n  */\n-enum sctp_disposition sctp_sf_do_9_2_reshutack(\n\
    -\t\t\t\t\tstruct net *net,\n-\t\t\t\t\tconst struct sctp_endpoint *ep,\n-\t\t\
    \t\t\tconst struct sctp_association *asoc,\n-\t\t\t\t\tconst union sctp_subtype\
    \ type,\n-\t\t\t\t\tvoid *arg,\n-\t\t\t\t\tstruct sctp_cmd_seq *commands)\n+static\
    \ enum sctp_disposition\n+__sctp_sf_do_9_2_reshutack(struct net *net, const struct\
    \ sctp_endpoint *ep,\n+\t\t\t   const struct sctp_association *asoc,\n+\t\t\t\
    \   const union sctp_subtype type, void *arg,\n+\t\t\t   struct sctp_cmd_seq *commands)\n\
    \ {\n \tstruct sctp_chunk *chunk = arg;\n \tstruct sctp_chunk *reply;\n@@ -3010,6\
    \ +3016,26 @@ enum sctp_disposition sctp_sf_do_9_2_reshutack(\n \treturn SCTP_DISPOSITION_NOMEM;\n\
    \ }\n \n+enum sctp_disposition\n+sctp_sf_do_9_2_reshutack(struct net *net, const\
    \ struct sctp_endpoint *ep,\n+\t\t\t const struct sctp_association *asoc,\n+\t\
    \t\t const union sctp_subtype type, void *arg,\n+\t\t\t struct sctp_cmd_seq *commands)\n\
    +{\n+\tstruct sctp_chunk *chunk = arg;\n+\n+\tif (!chunk->singleton)\n+\t\treturn\
    \ sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n+\n+\tif (!sctp_chunk_length_valid(chunk,\
    \ sizeof(struct sctp_init_chunk)))\n+\t\treturn sctp_sf_pdiscard(net, ep, asoc,\
    \ type, arg, commands);\n+\n+\tif (chunk->sctp_hdr->vtag != 0)\n+\t\treturn sctp_sf_tabort_8_4_8(net,\
    \ ep, asoc, type, arg, commands);\n+\n+\treturn __sctp_sf_do_9_2_reshutack(net,\
    \ ep, asoc, type, arg, commands);\n+}\n+\n /*\n  * sctp_sf_do_ecn_cwr\n  *\n@@\
    \ -3662,6 +3688,9 @@ enum sctp_disposition sctp_sf_ootb(struct net *net,\n \n\
    \ \tSCTP_INC_STATS(net, SCTP_MIB_OUTOFBLUES);\n \n+\tif (asoc && !sctp_vtag_verify(chunk,\
    \ asoc))\n+\t\tasoc = NULL;\n+\n \tch = (struct sctp_chunkhdr *)chunk->chunk_hdr;\n\
    \ \tdo {\n \t\t/* Report violation if the chunk is less then minimal */\n@@ -3777,12\
    \ +3806,6 @@ static enum sctp_disposition sctp_sf_shut_8_4_5(\n \n \tSCTP_INC_STATS(net,\
    \ SCTP_MIB_OUTCTRLCHUNKS);\n \n-\t/* If the chunk length is invalid, we don't\
    \ want to process\n-\t * the reset of the packet.\n-\t */\n-\tif (!sctp_chunk_length_valid(chunk,\
    \ sizeof(struct sctp_chunkhdr)))\n-\t\treturn sctp_sf_pdiscard(net, ep, asoc,\
    \ type, arg, commands);\n-\n \t/* We need to discard the rest of the packet to\
    \ prevent\n \t * potential boomming attacks from additional bundled chunks.\n\
    \ \t * This is documented in SCTP Threats ID.\n@@ -3810,6 +3833,9 @@ enum sctp_disposition\
    \ sctp_sf_do_8_5_1_E_sa(struct net *net,\n {\n \tstruct sctp_chunk *chunk = arg;\n\
    \ \n+\tif (!sctp_vtag_verify(chunk, asoc))\n+\t\tasoc = NULL;\n+\n \t/* Make sure\
    \ that the SHUTDOWN_ACK chunk has a valid length. */\n \tif (!sctp_chunk_length_valid(chunk,\
    \ sizeof(struct sctp_chunkhdr)))\n \t\treturn sctp_sf_violation_chunklen(net,\
    \ ep, asoc, type, arg,\n@@ -3845,6 +3871,11 @@ enum sctp_disposition sctp_sf_do_asconf(struct\
    \ net *net,\n \t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\
    \ \t}\n \n+\t/* Make sure that the ASCONF ADDIP chunk has a valid length.  */\n\
    +\tif (!sctp_chunk_length_valid(chunk, sizeof(struct sctp_addip_chunk)))\n+\t\t\
    return sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n+\t\t\t\t\t\t  commands);\n\
    +\n \t/* ADD-IP: Section 4.1.1\n \t * This chunk MUST be sent in an authenticated\
    \ way by using\n \t * the mechanism defined in [I-D.ietf-tsvwg-sctp-auth]. If\
    \ this chunk\n@@ -3853,13 +3884,7 @@ enum sctp_disposition sctp_sf_do_asconf(struct\
    \ net *net,\n \t */\n \tif (!asoc->peer.asconf_capable ||\n \t    (!net->sctp.addip_noauth\
    \ && !chunk->auth))\n-\t\treturn sctp_sf_discard_chunk(net, ep, asoc, type, arg,\n\
    -\t\t\t\t\t     commands);\n-\n-\t/* Make sure that the ASCONF ADDIP chunk has\
    \ a valid length.  */\n-\tif (!sctp_chunk_length_valid(chunk, sizeof(struct sctp_addip_chunk)))\n\
    -\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n-\t\t\t\t\t\t\
    \  commands);\n+\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\
    \ \n \thdr = (struct sctp_addiphdr *)chunk->skb->data;\n \tserial = ntohl(hdr->serial);\n\
    @@ -3988,6 +4013,12 @@ enum sctp_disposition sctp_sf_do_asconf_ack(struct net\
    \ *net,\n \t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n \t\
    }\n \n+\t/* Make sure that the ADDIP chunk has a valid length.  */\n+\tif (!sctp_chunk_length_valid(asconf_ack,\n\
    +\t\t\t\t     sizeof(struct sctp_addip_chunk)))\n+\t\treturn sctp_sf_violation_chunklen(net,\
    \ ep, asoc, type, arg,\n+\t\t\t\t\t\t  commands);\n+\n \t/* ADD-IP, Section 4.1.2:\n\
    \ \t * This chunk MUST be sent in an authenticated way by using\n \t * the mechanism\
    \ defined in [I-D.ietf-tsvwg-sctp-auth]. If this chunk\n@@ -3996,14 +4027,7 @@\
    \ enum sctp_disposition sctp_sf_do_asconf_ack(struct net *net,\n \t */\n \tif\
    \ (!asoc->peer.asconf_capable ||\n \t    (!net->sctp.addip_noauth && !asconf_ack->auth))\n\
    -\t\treturn sctp_sf_discard_chunk(net, ep, asoc, type, arg,\n-\t\t\t\t\t     commands);\n\
    -\n-\t/* Make sure that the ADDIP chunk has a valid length.  */\n-\tif (!sctp_chunk_length_valid(asconf_ack,\n\
    -\t\t\t\t     sizeof(struct sctp_addip_chunk)))\n-\t\treturn sctp_sf_violation_chunklen(net,\
    \ ep, asoc, type, arg,\n-\t\t\t\t\t\t  commands);\n+\t\treturn sctp_sf_pdiscard(net,\
    \ ep, asoc, type, arg, commands);\n \n \taddip_hdr = (struct sctp_addiphdr *)asconf_ack->skb->data;\n\
    \ \trcvd_serial = ntohl(addip_hdr->serial);\n@@ -4575,6 +4599,9 @@ enum sctp_disposition\
    \ sctp_sf_discard_chunk(struct net *net,\n {\n \tstruct sctp_chunk *chunk = arg;\n\
    \ \n+\tif (asoc && !sctp_vtag_verify(chunk, asoc))\n+\t\treturn sctp_sf_pdiscard(net,\
    \ ep, asoc, type, arg, commands);\n+\n \t/* Make sure that the chunk has a valid\
    \ length.\n \t * Since we don't know the chunk type, we use a general\n \t * chunkhdr\
    \ structure to make a comparison.\n@@ -4642,6 +4669,9 @@ enum sctp_disposition\
    \ sctp_sf_violation(struct net *net,\n {\n \tstruct sctp_chunk *chunk = arg;\n\
    \ \n+\tif (!sctp_vtag_verify(chunk, asoc))\n+\t\treturn sctp_sf_pdiscard(net,\
    \ ep, asoc, type, arg, commands);\n+\n \t/* Make sure that the chunk has a valid\
    \ length. */\n \tif (!sctp_chunk_length_valid(chunk, sizeof(struct sctp_chunkhdr)))\n\
    \ \t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n@@ -6348,6\
    \ +6378,7 @@ static struct sctp_packet *sctp_ootb_pkt_new(\n \t\t * yet.\n \t\t\
    \ */\n \t\tswitch (chunk->chunk_hdr->type) {\n+\t\tcase SCTP_CID_INIT:\n \t\t\
    case SCTP_CID_INIT_ACK:\n \t\t{\n \t\t\tstruct sctp_initack_chunk *initack;"
  identifiers:
  - CVE-2021-3772
  - CWE-354
  overview: A flaw was found in the Linux SCTP stack. A blind attacker may be able
    to kill an existing SCTP association through invalid chunks if the attacker knows
    the IP-addresses and port numbers being used and the attacker can send packets
    with spoofed IP addresses.
  references:
  - source: secalert@redhat.com
    tags:
    - Issue Tracking
    - Patch
    - Third Party Advisory
    url: https://bugzilla.redhat.com/show_bug.cgi?id=2000694
  - source: secalert@redhat.com
    tags:
    - Mailing List
    - Patch
    - Vendor Advisory
    url: https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=32f8807a48ae55be0e76880cfe8607a18b5bb0df
  - source: secalert@redhat.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/torvalds/linux/commit/32f8807a48ae55be0e76880cfe8607a18b5bb0df
  - source: secalert@redhat.com
    tags:
    - Mailing List
    - Third Party Advisory
    url: https://lists.debian.org/debian-lts-announce/2022/03/msg00012.html
  - source: secalert@redhat.com
    tags:
    - Third Party Advisory
    url: https://security.netapp.com/advisory/ntap-20221007-0001/
  - source: secalert@redhat.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://ubuntu.com/security/CVE-2021-3772
  - source: secalert@redhat.com
    tags:
    - Third Party Advisory
    url: https://www.debian.org/security/2022/dsa-5096
  - source: secalert@redhat.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://www.oracle.com/security-alerts/cpujul2022.html
  title: A flaw was found in the Linux SCTP stack. A blind attacker may be able to
    kill an existing SCTP association through invalid chunks if the attacker knows
    the IP-addresses and port numbers being used and the attacker can send packets
    with spoofed IP addresses.
- diff_content:
  - "--- a/src/keys.c\n+++ b/src/keys.c\n@@ -267,20 +267,7 @@ find_by_thp(struct tang_keys_info*\
    \ tki, const char* target)\n             if (!thumbprint || strcmp(thumbprint,\
    \ target) != 0) {\n                 continue;\n             }\n-\n-          \
    \  if (jwk_valid_for_deriving_keys(jwk)) {\n-                return json_incref(jwk);\n\
    -            } else if (jwk_valid_for_signing(jwk)) {\n-                json_auto_t*\
    \ sign = json_deep_copy(tki->m_sign);\n-                if (json_array_append(sign,\
    \ jwk) == -1) {\n-                    return NULL;\n-                }\n-    \
    \            json_auto_t* jws = jwk_sign(tki->m_payload, sign);\n-           \
    \     if (!jws) {\n-                    return NULL;\n-                }\n-  \
    \              return json_incref(jws);\n-            }\n+            return json_incref(jwk);\n\
    \         }\n     }\n     return NULL;\n@@ -445,7 +432,21 @@ find_jws(struct tang_keys_info*\
    \ tki, const char* thp)\n         }\n         return json_incref(jws);\n     }\n\
    -    return find_by_thp(tki, thp);\n+\n+    json_auto_t* jwk = find_by_thp(tki,\
    \ thp);\n+    if (!jwk_valid_for_signing(jwk)) {\n+        return NULL;\n+   \
    \ }\n+\n+    json_auto_t* sign = json_deep_copy(tki->m_sign);\n+    if (json_array_append(sign,\
    \ jwk) == -1) {\n+        return NULL;\n+    }\n+    json_auto_t* jws = jwk_sign(tki->m_payload,\
    \ sign);\n+    if (!jws) {\n+        return NULL;\n+    }\n+    return json_incref(jws);\n\
    \ }\n \n json_t*"
  identifiers:
  - CVE-2021-4076
  - NVD-CWE-noinfo
  overview: A flaw exists in tang, a network-based cryptographic binding server, which
    could result in leak of private keys.
  references:
  - source: secalert@redhat.com
    tags:
    - Issue Tracking
    - Third Party Advisory
    url: https://bugzilla.redhat.com/show_bug.cgi?id=2029814
  - source: secalert@redhat.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/latchset/tang/commit/e82459fda10f0630c3414ed2afbc6320bb9ea7c9
  - source: secalert@redhat.com
    tags:
    - Issue Tracking
    - Patch
    - Third Party Advisory
    url: https://github.com/latchset/tang/pull/81
  title: A flaw exists in tang, a network-based cryptographic binding server, which
    could result in leak of private keys.
- diff_content:
  - "--- a/net/can/bcm.c\n+++ b/net/can/bcm.c\n@@ -785,6 +785,7 @@ static int bcm_delete_rx_op(struct\
    \ list_head *ops, struct bcm_msg_head *mh,\n \t\t\t\t\t\t  bcm_rx_handler, op);\n\
    \ \n \t\t\tlist_del(&op->list);\n+\t\t\tsynchronize_rcu();\n \t\t\tbcm_remove_op(op);\n\
    \ \t\t\treturn 1; /* done */\n \t\t}\n@@ -1533,9 +1534,13 @@ static int bcm_release(struct\
    \ socket *sock)\n \t\t\t\t\t  REGMASK(op->can_id),\n \t\t\t\t\t  bcm_rx_handler,\
    \ op);\n \n-\t\tbcm_remove_op(op);\n \t}\n \n+\tsynchronize_rcu();\n+\n+\tlist_for_each_entry_safe(op,\
    \ next, &bo->rx_ops, list)\n+\t\tbcm_remove_op(op);\n+\n #if IS_ENABLED(CONFIG_PROC_FS)\n\
    \ \t/* remove procfs entry */\n \tif (net->can.bcmproc_dir && bo->bcm_proc_read)"
  identifiers:
  - CVE-2021-3609
  - CWE-362
  overview: .A flaw was found in the CAN BCM networking protocol in the Linux kernel,
    where a local attacker can abuse a flaw in the CAN subsystem to corrupt memory,
    crash the system or escalate privileges. This race condition in net/can/bcm.c
    in the Linux kernel allows for local privilege escalation to root.
  references:
  - source: secalert@redhat.com
    tags:
    - Issue Tracking
    - Third Party Advisory
    url: https://bugzilla.redhat.com/show_bug.cgi?id=1971651
  - source: secalert@redhat.com
    tags:
    - Exploit
    - Technical Description
    - Third Party Advisory
    url: https://github.com/nrb547/kernel-exploitation/blob/main/cve-2021-3609/cve-2021-3609.md
  - source: secalert@redhat.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/torvalds/linux/commit/d5f9023fa61ee8b94f37a93f08e94b136cf1e463
  - source: secalert@redhat.com
    tags:
    - Third Party Advisory
    url: https://security.netapp.com/advisory/ntap-20220419-0004/
  - source: secalert@redhat.com
    tags:
    - Mailing List
    - Third Party Advisory
    url: https://www.openwall.com/lists/oss-security/2021/06/19/1
  title: .A flaw was found in the CAN BCM networking protocol in the Linux kernel,
    where a local attacker can abuse a flaw in the CAN subsystem to corrupt memory,
    crash the system or escalate privileges. This race condition in net/can/bcm.c
    in the Linux kernel allows for local privilege escalation to root.
- diff_content:
  - "--- a/net/bluetooth/sco.c\n+++ b/net/bluetooth/sco.c\n@@ -280,7 +280,8 @@ static\
    \ int sco_connect(struct hci_dev *hdev, struct sock *sk)\n \treturn err;\n }\n\
    \ \n-static int sco_send_frame(struct sock *sk, struct msghdr *msg, int len)\n\
    +static int sco_send_frame(struct sock *sk, void *buf, int len,\n+\t\t\t  unsigned\
    \ int msg_flags)\n {\n \tstruct sco_conn *conn = sco_pi(sk)->conn;\n \tstruct\
    \ sk_buff *skb;\n@@ -292,15 +293,11 @@ static int sco_send_frame(struct sock *sk,\
    \ struct msghdr *msg, int len)\n \n \tBT_DBG(\"sk %p len %d\", sk, len);\n \n\
    -\tskb = bt_skb_send_alloc(sk, len, msg->msg_flags & MSG_DONTWAIT, &err);\n+\t\
    skb = bt_skb_send_alloc(sk, len, msg_flags & MSG_DONTWAIT, &err);\n \tif (!skb)\n\
    \ \t\treturn err;\n \n-\tif (memcpy_from_msg(skb_put(skb, len), msg, len)) {\n\
    -\t\tkfree_skb(skb);\n-\t\treturn -EFAULT;\n-\t}\n-\n+\tmemcpy(skb_put(skb, len),\
    \ buf, len);\n \thci_send_sco(conn->hcon, skb);\n \n \treturn len;\n@@ -725,6\
    \ +722,7 @@ static int sco_sock_sendmsg(struct socket *sock, struct msghdr *msg,\n\
    \ \t\t\t    size_t len)\n {\n \tstruct sock *sk = sock->sk;\n+\tvoid *buf;\n \t\
    int err;\n \n \tBT_DBG(\"sock %p, sk %p\", sock, sk);\n@@ -736,14 +734,24 @@ static\
    \ int sco_sock_sendmsg(struct socket *sock, struct msghdr *msg,\n \tif (msg->msg_flags\
    \ & MSG_OOB)\n \t\treturn -EOPNOTSUPP;\n \n+\tbuf = kmalloc(len, GFP_KERNEL);\n\
    +\tif (!buf)\n+\t\treturn -ENOMEM;\n+\n+\tif (memcpy_from_msg(buf, msg, len))\
    \ {\n+\t\tkfree(buf);\n+\t\treturn -EFAULT;\n+\t}\n+\n \tlock_sock(sk);\n \n \t\
    if (sk->sk_state == BT_CONNECTED)\n-\t\terr = sco_send_frame(sk, msg, len);\n\
    +\t\terr = sco_send_frame(sk, buf, len, msg->msg_flags);\n \telse\n \t\terr =\
    \ -ENOTCONN;\n \n \trelease_sock(sk);\n+\tkfree(buf);\n \treturn err;\n }\n "
  identifiers:
  - CVE-2021-3640
  - CWE-362
  overview: A flaw use-after-free in function sco_sock_sendmsg() of the Linux kernel
    HCI subsystem was found in the way user calls ioct UFFDIO_REGISTER or other way
    triggers race condition of the call sco_conn_del() together with the call sco_sock_sendmsg()
    with the expected controllable faulting memory page. A privileged local user could
    use this flaw to crash the system or escalate their privileges on the system.
  references:
  - source: secalert@redhat.com
    tags:
    - Issue Tracking
    - Patch
    - Third Party Advisory
    url: https://bugzilla.redhat.com/show_bug.cgi?id=1980646
  - source: secalert@redhat.com
    tags:
    - Patch
    - Vendor Advisory
    url: https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/net/bluetooth/sco.c?h=v5.16&id=99c23da0eed4fd20cae8243f2b51e10e66aa0951
  - source: secalert@redhat.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/torvalds/linux/commit/99c23da0eed4fd20cae8243f2b51e10e66aa0951
  - source: secalert@redhat.com
    tags:
    - Mailing List
    - Third Party Advisory
    url: https://lists.debian.org/debian-lts-announce/2022/03/msg00011.html
  - source: secalert@redhat.com
    tags:
    - Mailing List
    - Third Party Advisory
    url: https://lists.debian.org/debian-lts-announce/2022/03/msg00012.html
  - source: secalert@redhat.com
    tags:
    - Third Party Advisory
    url: https://security.netapp.com/advisory/ntap-20220419-0003/
  - source: secalert@redhat.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://ubuntu.com/security/CVE-2021-3640
  - source: secalert@redhat.com
    tags:
    - Third Party Advisory
    url: https://www.debian.org/security/2022/dsa-5096
  - source: secalert@redhat.com
    tags:
    - Exploit
    - Mailing List
    - Third Party Advisory
    url: https://www.openwall.com/lists/oss-security/2021/07/22/1
  title: A flaw use-after-free in function sco_sock_sendmsg() of the Linux kernel
    HCI subsystem was found in the way user calls ioct UFFDIO_REGISTER or other way
    triggers race condition of the call sco_conn_del() together with the call sco_sock_sendmsg()
    with the expected controllable faulting memory page. A privileged local user could
    use this flaw to crash the system or escalate their privileges on the system.
- diff_content:
  - "--- a/src/backend/libpq/pqcomm.c\n+++ b/src/backend/libpq/pqcomm.c\n@@ -1141,6\
    \ +1141,18 @@ pq_discardbytes(size_t len)\n \treturn 0;\n }\n \n+/* --------------------------------\n\
    + *\t\tpq_buffer_has_data\t\t- is any buffered data available to read?\n+ *\n\
    + * This will *not* attempt to read more data.\n+ * --------------------------------\n\
    + */\n+bool\n+pq_buffer_has_data(void)\n+{\n+\treturn (PqRecvPointer < PqRecvLength);\n\
    +}\n+\n \n /* --------------------------------\n  *\t\tpq_startmsgread - begin\
    \ reading a message from the client."
  - "--- a/src/backend/postmaster/postmaster.c\n+++ b/src/backend/postmaster/postmaster.c\n\
    @@ -2110,6 +2110,18 @@ ProcessStartupPacket(Port *port, bool ssl_done, bool gss_done)\n\
    \ \t\t\treturn STATUS_ERROR;\n #endif\n \n+\t\t/*\n+\t\t * At this point we should\
    \ have no data already buffered.  If we do,\n+\t\t * it was received before we\
    \ performed the SSL handshake, so it wasn't\n+\t\t * encrypted and indeed may\
    \ have been injected by a man-in-the-middle.\n+\t\t * We report this case to the\
    \ client.\n+\t\t */\n+\t\tif (pq_buffer_has_data())\n+\t\t\tereport(FATAL,\n+\t\
    \t\t\t\t(errcode(ERRCODE_PROTOCOL_VIOLATION),\n+\t\t\t\t\t errmsg(\"received unencrypted\
    \ data after SSL request\"),\n+\t\t\t\t\t errdetail(\"This could be either a client-software\
    \ bug or evidence of an attempted man-in-the-middle attack.\")));\n+\n \t\t/*\n\
    \ \t\t * regular startup packet, cancel, etc packet should follow, but not\n \t\
    \t * another SSL negotiation request, and a GSS request should only\n@@ -2142,6\
    \ +2154,18 @@ ProcessStartupPacket(Port *port, bool ssl_done, bool gss_done)\n\
    \ \t\t\treturn STATUS_ERROR;\n #endif\n \n+\t\t/*\n+\t\t * At this point we should\
    \ have no data already buffered.  If we do,\n+\t\t * it was received before we\
    \ performed the GSS handshake, so it wasn't\n+\t\t * encrypted and indeed may\
    \ have been injected by a man-in-the-middle.\n+\t\t * We report this case to the\
    \ client.\n+\t\t */\n+\t\tif (pq_buffer_has_data())\n+\t\t\tereport(FATAL,\n+\t\
    \t\t\t\t(errcode(ERRCODE_PROTOCOL_VIOLATION),\n+\t\t\t\t\t errmsg(\"received unencrypted\
    \ data after GSSAPI encryption request\"),\n+\t\t\t\t\t errdetail(\"This could\
    \ be either a client-software bug or evidence of an attempted man-in-the-middle\
    \ attack.\")));\n+\n \t\t/*\n \t\t * regular startup packet, cancel, etc packet\
    \ should follow, but not\n \t\t * another GSS negotiation request, and an SSL\
    \ request should only"
  identifiers:
  - CVE-2021-23214
  - CWE-89
  overview: When the server is configured to use trust authentication with a clientcert
    requirement or to use cert authentication, a man-in-the-middle attacker can inject
    arbitrary SQL queries when a connection is first established, despite the use
    of SSL certificate verification and encryption.
  references:
  - source: secalert@redhat.com
    tags:
    - Issue Tracking
    - Patch
    - Third Party Advisory
    url: https://bugzilla.redhat.com/show_bug.cgi?id=2022666
  - source: secalert@redhat.com
    url: https://git.postgresql.org/gitweb/?p=postgresql.git%3Ba=commit%3Bh=28e24125541545483093819efae9bca603441951
  - source: secalert@redhat.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/postgres/postgres/commit/28e24125541545483093819efae9bca603441951
  - source: secalert@redhat.com
    tags:
    - Third Party Advisory
    url: https://security.gentoo.org/glsa/202211-04
  - source: secalert@redhat.com
    tags:
    - Vendor Advisory
    url: https://www.postgresql.org/support/security/CVE-2021-23214/
  title: When the server is configured to use trust authentication with a clientcert
    requirement or to use cert authentication, a man-in-the-middle attacker can inject
    arbitrary SQL queries when a connection is first established, despite the use
    of SSL certificate verification and encryption.
- diff_content:
  - "--- a/net/qrtr/qrtr.c\n+++ b/net/qrtr/qrtr.c\n@@ -493,7 +493,7 @@ int qrtr_endpoint_post(struct\
    \ qrtr_endpoint *ep, const void *data, size_t len)\n \t\tgoto err;\n \t}\n \n\
    -\tif (len != ALIGN(size, 4) + hdrlen)\n+\tif (!size || len != ALIGN(size, 4)\
    \ + hdrlen)\n \t\tgoto err;\n \n \tif (cb->dst_port != QRTR_PORT_CTRL && cb->type\
    \ != QRTR_TYPE_DATA &&"
  identifiers:
  - CVE-2021-3743
  - CWE-125
  overview: An out-of-bounds (OOB) memory read flaw was found in the Qualcomm IPC
    router protocol in the Linux kernel. A missing sanity check allows a local attacker
    to gain access to out-of-bounds memory, leading to a system crash or a leak of
    internal kernel information. The highest threat from this vulnerability is to
    system availability.
  references:
  - source: secalert@redhat.com
    tags:
    - Issue Tracking
    - Patch
    - Third Party Advisory
    url: https://bugzilla.redhat.com/show_bug.cgi?id=1997961
  - source: secalert@redhat.com
    tags:
    - Patch
    - Vendor Advisory
    url: https://git.kernel.org/pub/scm/linux/kernel/git/netdev/net.git/commit/?id=7e78c597c3eb
  - source: secalert@redhat.com
    tags:
    - Patch
    - Vendor Advisory
    url: https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=7e78c597c3ebfd0cb329aa09a838734147e4f117
  - source: secalert@redhat.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/torvalds/linux/commit/7e78c597c3ebfd0cb329aa09a838734147e4f117
  - source: secalert@redhat.com
    tags:
    - Exploit
    - Mailing List
    - Third Party Advisory
    url: https://lists.openwall.net/netdev/2021/08/17/124
  - source: secalert@redhat.com
    tags:
    - Third Party Advisory
    url: https://security.netapp.com/advisory/ntap-20220407-0007/
  - source: secalert@redhat.com
    tags:
    - Exploit
    - Mailing List
    - Patch
    - Third Party Advisory
    url: https://www.openwall.com/lists/oss-security/2021/08/27/2
  - source: secalert@redhat.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://www.oracle.com/security-alerts/cpujul2022.html
  title: An out-of-bounds (OOB) memory read flaw was found in the Qualcomm IPC router
    protocol in the Linux kernel. A missing sanity check allows a local attacker to
    gain access to out-of-bounds memory, leading to a system crash or a leak of internal
    kernel information. The highest threat from this vulnerability is to system availability.
- diff_content:
  - "--- a/drivers/crypto/ccp/ccp-ops.c\n+++ b/drivers/crypto/ccp/ccp-ops.c\n@@ -778,7\
    \ +778,7 @@ ccp_run_aes_gcm_cmd(struct ccp_cmd_queue *cmd_q, struct ccp_cmd *cmd)\n\
    \ \t\t\t\t    in_place ? DMA_BIDIRECTIONAL\n \t\t\t\t\t     : DMA_TO_DEVICE);\n\
    \ \t\tif (ret)\n-\t\t\tgoto e_ctx;\n+\t\t\tgoto e_aad;\n \n \t\tif (in_place)\
    \ {\n \t\t\tdst = src;\n@@ -863,7 +863,7 @@ ccp_run_aes_gcm_cmd(struct ccp_cmd_queue\
    \ *cmd_q, struct ccp_cmd *cmd)\n \top.u.aes.size = 0;\n \tret = cmd_q->ccp->vdata->perform->aes(&op);\n\
    \ \tif (ret)\n-\t\tgoto e_dst;\n+\t\tgoto e_final_wa;\n \n \tif (aes->action ==\
    \ CCP_AES_ACTION_ENCRYPT) {\n \t\t/* Put the ciphered tag after the ciphertext.\
    \ */\n@@ -873,17 +873,19 @@ ccp_run_aes_gcm_cmd(struct ccp_cmd_queue *cmd_q, struct\
    \ ccp_cmd *cmd)\n \t\tret = ccp_init_dm_workarea(&tag, cmd_q, authsize,\n \t\t\
    \t\t\t   DMA_BIDIRECTIONAL);\n \t\tif (ret)\n-\t\t\tgoto e_tag;\n+\t\t\tgoto e_final_wa;\n\
    \ \t\tret = ccp_set_dm_area(&tag, 0, p_tag, 0, authsize);\n-\t\tif (ret)\n-\t\t\
    \tgoto e_tag;\n+\t\tif (ret) {\n+\t\t\tccp_dm_free(&tag);\n+\t\t\tgoto e_final_wa;\n\
    +\t\t}\n \n \t\tret = crypto_memneq(tag.address, final_wa.address,\n \t\t\t\t\
    \    authsize) ? -EBADMSG : 0;\n \t\tccp_dm_free(&tag);\n \t}\n \n-e_tag:\n+e_final_wa:\n\
    \ \tccp_dm_free(&final_wa);\n \n e_dst:"
  identifiers:
  - CVE-2021-3744
  - CWE-401
  overview: A memory leak flaw was found in the Linux kernel in the ccp_run_aes_gcm_cmd()
    function in drivers/crypto/ccp/ccp-ops.c, which allows attackers to cause a denial
    of service (memory consumption). This vulnerability is similar with the older
    CVE-2019-18808.
  references:
  - source: secalert@redhat.com
    tags:
    - Exploit
    - Mailing List
    - Third Party Advisory
    url: http://www.openwall.com/lists/oss-security/2021/09/14/1
  - source: secalert@redhat.com
    tags:
    - Issue Tracking
    - Third Party Advisory
    url: https://bugzilla.redhat.com/show_bug.cgi?id=2000627
  - source: secalert@redhat.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/torvalds/linux/commit/505d9dcb0f7ddf9d075e729523a33d38642ae680
  - source: secalert@redhat.com
    tags:
    - Mailing List
    - Patch
    - Third Party Advisory
    url: https://kernel.googlesource.com/pub/scm/linux/kernel/git/herbert/crypto-2.6/+/505d9dcb0f7ddf9d075e729523a33d38642ae680%5E%21/#F0
  - source: secalert@redhat.com
    tags:
    - Mailing List
    - Third Party Advisory
    url: https://lists.debian.org/debian-lts-announce/2022/03/msg00012.html
  - source: secalert@redhat.com
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/7BLLVKYAIETEORUPTFO3TR3C33ZPFXQM/
  - source: secalert@redhat.com
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/LAT3RERO6QBKSPJBNNRWY3D4NCGTFOS7/
  - source: secalert@redhat.com
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/SYKURLXBB2555ASWMPDNMBUPD6AG2JKQ/
  - source: secalert@redhat.com
    tags:
    - Exploit
    - Mailing List
    - Patch
    - Third Party Advisory
    url: https://seclists.org/oss-sec/2021/q3/164
  - source: secalert@redhat.com
    tags:
    - Third Party Advisory
    url: https://www.debian.org/security/2022/dsa-5096
  - source: secalert@redhat.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://www.oracle.com/security-alerts/cpujul2022.html
  title: A memory leak flaw was found in the Linux kernel in the ccp_run_aes_gcm_cmd()
    function in drivers/crypto/ccp/ccp-ops.c, which allows attackers to cause a denial
    of service (memory consumption). This vulnerability is similar with the older
    CVE-2019-18808.
- diff_content:
  - "--- a/arch/x86/kvm/svm/nested.c\n+++ b/arch/x86/kvm/svm/nested.c\n@@ -158,6 +158,9\
    \ @@ void recalc_intercepts(struct vcpu_svm *svm)\n \t/* If SMI is not intercepted,\
    \ ignore guest SMI intercept as well  */\n \tif (!intercept_smi)\n \t\tvmcb_clr_intercept(c,\
    \ INTERCEPT_SMI);\n+\n+\tvmcb_set_intercept(c, INTERCEPT_VMLOAD);\n+\tvmcb_set_intercept(c,\
    \ INTERCEPT_VMSAVE);\n }\n \n static void copy_vmcb_control_area(struct vmcb_control_area\
    \ *dst,"
  identifiers:
  - CVE-2021-3656
  - CWE-862
  overview: A flaw was found in the KVM's AMD code for supporting SVM nested virtualization.
    The flaw occurs when processing the VMCB (virtual machine control block) provided
    by the L1 guest to spawn/handle a nested guest (L2). Due to improper validation
    of the "virt_ext" field, this issue could allow a malicious L1 to disable both
    VMLOAD/VMSAVE intercepts and VLS (Virtual VMLOAD/VMSAVE) for the L2 guest. As
    a result, the L2 guest would be allowed to read/write physical pages of the host,
    resulting in a crash of the entire system, leak of sensitive data or potential
    guest-to-host escape.
  references:
  - source: secalert@redhat.com
    tags:
    - Issue Tracking
    - Third Party Advisory
    url: https://bugzilla.redhat.com/show_bug.cgi?id=1983988
  - source: secalert@redhat.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://git.kernel.org/pub/scm/virt/kvm/kvm.git/commit/?id=c7dfa4009965a9b2d7b329ee970eb8da0d32f0bc
  - source: secalert@redhat.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/torvalds/linux/commit/c7dfa4009965a9b2d7b329ee970eb8da0d32f0bc
  - source: secalert@redhat.com
    tags:
    - Mailing List
    - Third Party Advisory
    url: https://www.openwall.com/lists/oss-security/2021/08/16/1
  title: A flaw was found in the KVM's AMD code for supporting SVM nested virtualization.
    The flaw occurs when processing the VMCB (virtual machine control block) provided
    by the L1 guest to spawn/handle a nested guest (L2). Due to improper validation
    of the "virt_ext" field, this issue could allow a malicious L1 to disable both
    VMLOAD/VMSAVE intercepts and VLS (Virtual VMLOAD/VMSAVE) for the L2 guest. As
    a result, the L2 guest would be allowed to read/write physical pages of the host,
    resulting in a crash of the entire system, leak of sensitive data or potential
    guest-to-host escape.
- diff_content:
  - "--- a/src/jsparse.c\n+++ b/src/jsparse.c\n@@ -952,7 +952,12 @@ static NO_INLINE\
    \ JsVar *jspGetNamedFieldInParents(JsVar *object, const char* nam\n     } else\
    \ if (strcmp(name, JSPARSE_INHERITS_VAR)==0) {\n       const char *objName = jswGetBasicObjectName(object);\n\
    \       if (objName) {\n-        child = jspNewPrototype(objName);\n+        JsVar\
    \ *p = jsvSkipNameAndUnLock(jspNewPrototype(objName));\n+        // jspNewPrototype\
    \ returns a 'prototype' name that's already a child of eg. an array\n+       \
    \ // Create a new 'name' called __proto__ that links to it\n+        JsVar *i\
    \ = jsvNewFromString(JSPARSE_INHERITS_VAR);\n+        if (p) child = jsvCreateNewChild(object,\
    \ i, p);\n+        jsvUnLock(i);\n       }\n     }\n   }\n@@ -1372,8 +1377,13\
    \ @@ NO_INLINE JsVar *jspeFactorDelete() {\n       if (!parent && jsvIsChild(execInfo.root,\
    \ a))\n         parent = jsvLockAgain(execInfo.root);\n \n-      if (jsvHasChildren(parent))\
    \ {\n+#ifdef DEBUG\n+      if (jsvHasChildren(parent)) assert(jsvIsChild(parent,\
    \ a));\n+#endif\n+      if (jsvHasChildren(parent) && jsvIsChild(parent, a)) {\n\
    \         // else remove properly.\n+        /* we use jsvIsChild here just in\
    \ case. delete probably isn't called\n+        that often so it pays to be safe\
    \ */\n         if (jsvIsArray(parent)) {\n           // For arrays, we must make\
    \ sure we don't change the length\n           JsVarInt l = jsvGetArrayLength(parent);\n\
    @@ -2848,7 +2858,7 @@ JsVar *jspNewBuiltin(const char *instanceOf) {\n   return\
    \ objFunc;\n }\n \n-/// Create a new Class of the given instance and return its\
    \ prototype\n+/// Create a new Class of the given instance and return its prototype\
    \ (as a name 'prototype')\n NO_INLINE JsVar *jspNewPrototype(const char *instanceOf)\
    \ {\n   JsVar *objFuncName = jsvFindChildFromString(execInfo.root, instanceOf,\
    \ true);\n   if (!objFuncName) // out of memory"
  - "--- a/src/jsvar.c\n+++ b/src/jsvar.c\n@@ -2555,6 +2555,7 @@ void jsvAddName(JsVar\
    \ *parent, JsVar *namedChild) {\n     }\n \n     if (insertAfter) {\n+      assert(jsvIsName(insertAfter));\n\
    \       if (jsvGetNextSibling(insertAfter)) {\n         // great, we're in the\
    \ middle...\n         JsVar *insertBefore = jsvLock(jsvGetNextSibling(insertAfter));\n\
    @@ -2761,6 +2762,9 @@ JsVar *jsvFindChildFromVar(JsVar *parent, JsVar *childName,\
    \ bool addIfNotFound)\n void jsvRemoveChild(JsVar *parent, JsVar *child) {\n \
    \  assert(jsvHasChildren(parent));\n   assert(jsvIsName(child));\n+#ifdef DEBUG\n\
    +  assert(jsvIsChild(parent, child));\n+#endif\n   JsVarRef childref = jsvGetRef(child);\n\
    \   bool wasChild = false;\n   // unlink from parent"
  identifiers:
  - CVE-2022-25044
  - CWE-787
  overview: Espruino 2v11.251 was discovered to contain a stack buffer overflow via
    src/jsvar.c in jsvNewFromString.
  references:
  - source: cve@mitre.org
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/espruino/Espruino/commit/e069be2ecc5060ef47391716e4de94999595b260
  - source: cve@mitre.org
    tags:
    - Exploit
    - Issue Tracking
    - Patch
    - Third Party Advisory
    url: https://github.com/espruino/Espruino/issues/2142
  title: Espruino 2v11.251 was discovered to contain a stack buffer overflow via src/jsvar.c
    in jsvNewFromString.
- diff_content:
  - "--- a/libr/anal/arch/kvx/kvx-dis.c\n+++ b/libr/anal/arch/kvx/kvx-dis.c\n@@ -94,9\
    \ +94,11 @@ static inline int kvx_is_tca_opcode(ut32 x) {\n \treturn (major >\
    \ 1) && (major < 8);\n }\n \n+#if UNUSED0\n static inline int kvx_is_nop_opcode(ut32\
    \ x) {\n \treturn ((x)<<1) == 0xFFFFFFFE;\n }\n+#endif\n \n static inline int\
    \ kvx_opc_match(const opc_t *opc, insn_t *insn) {\n \tint i;"
  - "--- a/libr/core/canal.c\n+++ b/libr/core/canal.c\n@@ -1,4 +1,4 @@\n-/* radare\
    \ - LGPL - Copyright 2009-2021 - pancake, nibble */\n+/* radare - LGPL - Copyright\
    \ 2009-2022 - pancake, nibble */\n \n #include <r_types.h>\n #include <r_list.h>\n\
    @@ -4727,7 +4727,7 @@ static bool myvalid(RIO *io, ut64 addr) {\n typedef struct\
    \ {\n \tRAnalOp *op;\n \tRAnalFunction *fcn;\n-\tconst char *spname;\n+\tchar\
    \ *spname;\n \tut64 initial_sp;\n } EsilBreakCtx;\n \n@@ -5099,7 +5099,7 @@ R_API\
    \ void r_core_anal_esil(RCore *core, const char *str, const char *target) {\n\
    \ \tbool gp_fixed = r_config_get_i (core->config, \"anal.gpfixed\");\n \tRAnalEsil\
    \ *ESIL = core->anal->esil;\n \tut64 refptr = 0LL;\n-\tconst char *pcname;\n+\t\
    char *pcname = NULL;\n \tRAnalOp op = R_EMPTY;\n \tut8 *buf = NULL;\n \tbool end_address_set\
    \ = false;\n@@ -5188,11 +5188,12 @@ R_API void r_core_anal_esil(RCore *core, const\
    \ char *str, const char *target) {\n \t\tr_core_cmd0 (core, \"aeim\");\n \t\t\
    ESIL = core->anal->esil;\n \t}\n-\tconst char *spname = r_reg_get_name (core->anal->reg,\
    \ R_REG_NAME_SP);\n-\tif (!spname) {\n+\tconst char *kspname = r_reg_get_name\
    \ (core->anal->reg, R_REG_NAME_SP);\n+\tif (R_STR_ISEMPTY (kspname)) {\n \t\t\
    eprintf (\"Error: No =SP defined in the reg profile.\\n\");\n \t\treturn;\n \t\
    }\n+\tchar *spname = strdup (kspname);\n \tEsilBreakCtx ctx = {\n \t\t&op,\n \t\
    \tfcn,\n@@ -5210,11 +5211,12 @@ R_API void r_core_anal_esil(RCore *core, const\
    \ char *str, const char *target) {\n \t}\n \t//eprintf (\"Analyzing ESIL refs\
    \ from 0x%\"PFMT64x\" - 0x%\"PFMT64x\"\\n\", addr, end);\n \t// TODO: backup/restore\
    \ register state before/after analysis\n-\tpcname = r_reg_get_name (core->anal->reg,\
    \ R_REG_NAME_PC);\n-\tif (!pcname || !*pcname) {\n+\tconst char *kpcname = r_reg_get_name\
    \ (core->anal->reg, R_REG_NAME_PC);\n+\tif (!kpcname || !*kpcname) {\n \t\teprintf\
    \ (\"Cannot find program counter register in the current profile.\\n\");\n \t\t\
    return;\n \t}\n+\tpcname = strdup (kpcname);\n \tesil_anal_stop = false;\n \t\
    r_cons_break_push (cccb, core);\n \n@@ -5299,11 +5301,9 @@ R_API void r_core_anal_esil(RCore\
    \ *core, const char *str, const char *target) {\n \t\tr_anal_op_fini (&op);\n\
    \ \t\tr_asm_set_pc (core->rasm, cur);\n \t\ti_old = i;\n-#if 1\n \t\tif (i > iend)\
    \ {\n \t\t\tgoto repeat;\n \t\t}\n-#endif\n \t\tif (!r_anal_op (core->anal, &op,\
    \ cur, buf + i, iend - i, R_ANAL_OP_MASK_ESIL | R_ANAL_OP_MASK_VAL | R_ANAL_OP_MASK_HINT))\
    \ {\n \t\t\ti += minopsize - 1; //   XXX dupe in op.size below\n \t\t}\n@@ -5544,6\
    \ +5544,8 @@ R_API void r_core_anal_esil(RCore *core, const char *str, const char\
    \ *target) {\n \t\t\tbreak;\n \t\t}\n \t} while (get_next_i (&ictx, &i));\n+\t\
    free (pcname);\n+\tfree (spname);\n \tr_list_free (ictx.bbl);\n \tr_list_free\
    \ (ictx.path);\n \tr_list_free (ictx.switch_path);"
  identifiers:
  - CVE-2022-0849
  - CWE-416
  overview: Use After Free in r_reg_get_name_idx in GitHub repository radareorg/radare2
    prior to 5.6.6.
  references:
  - source: security@huntr.dev
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/radareorg/radare2/commit/10517e3ff0e609697eb8cde60ec8dc999ee5ea24
  - source: security@huntr.dev
    tags:
    - Exploit
    - Issue Tracking
    - Patch
    - Third Party Advisory
    url: https://huntr.dev/bounties/29c5f76e-5f1f-43ab-a0c8-e31951e407b6
  title: Use After Free in r_reg_get_name_idx in GitHub repository radareorg/radare2
    prior to 5.6.6.
- diff_content:
  - "--- a/drivers/nfc/st21nfca/se.c\n+++ b/drivers/nfc/st21nfca/se.c\n@@ -316,6 +316,11\
    \ @@ int st21nfca_connectivity_event_received(struct nfc_hci_dev *hdev, u8 host,\n\
    \ \t\t\treturn -ENOMEM;\n \n \t\ttransaction->aid_len = skb->data[1];\n+\n+\t\t\
    /* Checking if the length of the AID is valid */\n+\t\tif (transaction->aid_len\
    \ > sizeof(transaction->aid))\n+\t\t\treturn -EINVAL;\n+\n \t\tmemcpy(transaction->aid,\
    \ &skb->data[2],\n \t\t       transaction->aid_len);\n \n@@ -325,6 +330,11 @@\
    \ int st21nfca_connectivity_event_received(struct nfc_hci_dev *hdev, u8 host,\n\
    \ \t\t\treturn -EPROTO;\n \n \t\ttransaction->params_len = skb->data[transaction->aid_len\
    \ + 3];\n+\n+\t\t/* Total size is allocated (skb->len - 2) minus fixed array members\
    \ */\n+\t\tif (transaction->params_len > ((skb->len - 2) - sizeof(struct nfc_evt_transaction)))\n\
    +\t\t\treturn -EINVAL;\n+\n \t\tmemcpy(transaction->params, skb->data +\n \t\t\
    \       transaction->aid_len + 4, transaction->params_len);\n "
  identifiers:
  - CVE-2022-26490
  - CWE-120
  overview: st21nfca_connectivity_event_received in drivers/nfc/st21nfca/se.c in the
    Linux kernel through 5.16.12 has EVT_TRANSACTION buffer overflows because of untrusted
    length parameters.
  references:
  - source: cve@mitre.org
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/torvalds/linux/commit/4fbcc1a4cb20fe26ad0225679c536c80f1648221
  - source: cve@mitre.org
    tags:
    - Mailing List
    - Third Party Advisory
    url: https://lists.debian.org/debian-lts-announce/2022/07/msg00000.html
  - source: cve@mitre.org
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/BG4J46EMFPDD5QHYXDUI3PJCZQ7HQAZR/
  - source: cve@mitre.org
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/C5AUUDGSDLGYU7SZSK4PFAN22NISQZBT/
  - source: cve@mitre.org
    tags:
    - Third Party Advisory
    url: https://security.netapp.com/advisory/ntap-20220429-0004/
  - source: cve@mitre.org
    tags:
    - Third Party Advisory
    url: https://www.debian.org/security/2022/dsa-5127
  - source: cve@mitre.org
    tags:
    - Third Party Advisory
    url: https://www.debian.org/security/2022/dsa-5173
  title: st21nfca_connectivity_event_received in drivers/nfc/st21nfca/se.c in the
    Linux kernel through 5.16.12 has EVT_TRANSACTION buffer overflows because of untrusted
    length parameters.
- diff_content:
  - "--- a/cmd/maddy-pam-helper/pam.c\n+++ b/cmd/maddy-pam-helper/pam.c\n@@ -1,3 +1,23\
    \ @@\n+//+build libpam\n+\n+/*\n+Maddy Mail Server - Composable all-in-one email\
    \ server.\n+Copyright \xA9 2019-2022 Max Mazurov <fox.cpp@disroot.org>, Maddy\
    \ Mail Server contributors\n+\n+This program is free software: you can redistribute\
    \ it and/or modify\n+it under the terms of the GNU General Public License as published\
    \ by\n+the Free Software Foundation, either version 3 of the License, or\n+(at\
    \ your option) any later version.\n+\n+This program is distributed in the hope\
    \ that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied\
    \ warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n\
    +GNU General Public License for more details.\n+\n+You should have received a\
    \ copy of the GNU General Public License\n+along with this program.  If not, see\
    \ <https://www.gnu.org/licenses/>.\n+*/\n+\n #define _POSIX_C_SOURCE 200809L\n\
    \ #include <stdio.h>\n #include <stdlib.h>\n@@ -46,6 +66,19 @@ struct error_obj\
    \ run_pam_auth(const char *username, char *password) {\n         return ret_val;\n\
    \     }\n \n+    status = pam_acct_mgmt(local_auth, PAM_SILENT|PAM_DISALLOW_NULL_AUTHTOK);\n\
    +    if (status != PAM_SUCCESS) {\n+        struct error_obj ret_val;\n+     \
    \   if (status == PAM_AUTH_ERR || status == PAM_USER_UNKNOWN || status == PAM_NEW_AUTHTOK_REQD)\
    \ {\n+            ret_val.status = 1;\n+        } else {\n+            ret_val.status\
    \ = 2;\n+        }\n+        ret_val.func_name = \"pam_acct_mgmt\";\n+       \
    \ ret_val.error_msg = pam_strerror(local_auth, status);\n+        return ret_val;\n\
    +    }\n+\n     status = pam_end(local_auth, status);\n     if (status != PAM_SUCCESS)\
    \ {\n         struct error_obj ret_val;"
  - "--- a/internal/auth/pam/pam.c\n+++ b/internal/auth/pam/pam.c\n@@ -2,7 +2,7 @@\n\
    \ \n /*\n Maddy Mail Server - Composable all-in-one email server.\n-Copyright\
    \ \xA9 2019-2020 Max Mazurov <fox.cpp@disroot.org>, Maddy Mail Server contributors\n\
    +Copyright \xA9 2019-2022 Max Mazurov <fox.cpp@disroot.org>, Maddy Mail Server\
    \ contributors\n \n This program is free software: you can redistribute it and/or\
    \ modify\n it under the terms of the GNU General Public License as published by\n\
    @@ -66,6 +66,19 @@ struct error_obj run_pam_auth(const char *username, char *password)\
    \ {\n         return ret_val;\n     }\n \n+    status = pam_acct_mgmt(local_auth,\
    \ PAM_SILENT|PAM_DISALLOW_NULL_AUTHTOK);\n+    if (status != PAM_SUCCESS) {\n\
    +        struct error_obj ret_val;\n+        if (status == PAM_AUTH_ERR || status\
    \ == PAM_USER_UNKNOWN || status == PAM_NEW_AUTHTOK_REQD) {\n+            ret_val.status\
    \ = 1;\n+        } else {\n+            ret_val.status = 2;\n+        }\n+   \
    \     ret_val.func_name = \"pam_acct_mgmt\";\n+        ret_val.error_msg = pam_strerror(local_auth,\
    \ status);\n+        return ret_val;\n+    }\n+\n     status = pam_end(local_auth,\
    \ status);\n     if (status != PAM_SUCCESS) {\n         struct error_obj ret_val;"
  identifiers:
  - CVE-2022-24732
  - CWE-324
  overview: Maddy Mail Server is an open source SMTP compatible email server. Versions
    of maddy prior to 0.5.4 do not implement password expiry or account expiry checking
    when authenticating using PAM. Users are advised to upgrade. Users unable to upgrade
    should manually remove expired accounts via existing filtering mechanisms.
  references:
  - source: security-advisories@github.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/foxcpp/maddy/commit/7ee6a39c6a1939b376545f030a5efd6f90913583
  - source: security-advisories@github.com
    tags:
    - Third Party Advisory
    url: https://github.com/foxcpp/maddy/security/advisories/GHSA-6cp7-g972-w9m9
  title: Maddy Mail Server is an open source SMTP compatible email server. Versions
    of maddy prior to 0.5.4 do not implement password expiry or account expiry checking
    when authenticating using PAM. Users are advised to upgrade. Users unable to upgrade
    should manually remove expired accounts via existing filtering mechanisms.
- diff_content:
  - "--- a/mrbgems/mruby-fiber/src/fiber.c\n+++ b/mrbgems/mruby-fiber/src/fiber.c\n\
    @@ -208,15 +208,22 @@ fiber_switch(mrb_state *mrb, mrb_value self, mrb_int len,\
    \ const mrb_value *a, mr\n     if (!c->ci->proc) {\n       mrb_raise(mrb, E_FIBER_ERROR,\
    \ \"double resume (current)\");\n     }\n-    mrb_stack_extend(mrb, len+2); /*\
    \ for receiver and (optional) block */\n-    b = c->stbase+1;\n-    e = b + len;\n\
    -    while (b<e) {\n-      *b++ = *a++;\n-    }\n     if (vmexec) {\n       c->ci--;\
    \                    /* pop dummy callinfo */\n     }\n+    if (len >= 15) {\n\
    +      mrb_stack_extend(mrb, 3);   /* for receiver, args and (optional) block\
    \ */\n+      c->stbase[1] = mrb_ary_new_from_values(mrb, len, a);\n+      len\
    \ = 15;\n+    }\n+    else {\n+      mrb_stack_extend(mrb, len+2); /* for receiver\
    \ and (optional) block */\n+      b = c->stbase+1;\n+      e = b + len;\n+   \
    \   while (b<e) {\n+        *b++ = *a++;\n+      }\n+    }\n     c->cibase->n\
    \ = len;\n     value = c->stbase[0] = MRB_PROC_ENV(c->cibase->proc)->stack[0];\n\
    \   }"
  identifiers:
  - CVE-2022-0890
  - CWE-476
  overview: NULL Pointer Dereference in GitHub repository mruby/mruby prior to 3.2.
  references:
  - source: security@huntr.dev
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/mruby/mruby/commit/da48e7dbb20024c198493b8724adae1b842083aa
  - source: security@huntr.dev
    tags:
    - Exploit
    - Patch
    - Third Party Advisory
    url: https://huntr.dev/bounties/68e09ec1-6cc7-48b8-981d-30f478c70276
  title: NULL Pointer Dereference in GitHub repository mruby/mruby prior to 3.2.
- diff_content:
  - "--- a/parse.c\n+++ b/parse.c\n@@ -2011,9 +2011,14 @@ static char txt_no_note[]\
    \ = \"No note in voice overlay\";\n \t\t\terror(1, s, \"Erroneous end of voice\
    \ overlap\");\n \t\t\treturn;\n \t\t}\n-\t\tif (p_voice->time != over_mxtime)\n\
    -\t\t\terror(1, s, tx_wrong_dur);\n \t\tcurvoice = &voice_tb[over_voice];\n+\t\
    \tif (p_voice->time != over_mxtime) {\n+\t\t\terror(1, s, tx_wrong_dur);\n+\t\t\
    \tif (p_voice->time > over_mxtime)\n+\t\t\t\tcurvoice->time = p_voice->time;\n\
    +\t\t\telse\n+\t\t\t\tp_voice->time = curvoice->time;\n+\t\t}\n \t\tover_mxtime\
    \ = 0;\n \t\tover_voice = -1;\n \t\tover_time = -1;"
  identifiers:
  - CVE-2021-32434
  - CWE-125
  overview: abcm2ps v8.14.11 was discovered to contain an out-of-bounds read in the
    function calculate_beam at draw.c.
  references:
  - source: cve@mitre.org
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/leesavide/abcm2ps/commit/2f56e1179cab6affeb8afa9d6c324008fe40d8e3
  - source: cve@mitre.org
    tags:
    - Exploit
    - Issue Tracking
    - Third Party Advisory
    url: https://github.com/leesavide/abcm2ps/issues/83
  - source: cve@mitre.org
    tags:
    - Third Party Advisory
    url: https://lists.debian.org/debian-lts-announce/2022/04/msg00015.html
  - source: cve@mitre.org
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/6333SXWMES3K22DBAOAW34G6EU6WIJEY/
  - source: cve@mitre.org
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/EVGJH4HMXI3TWMHQJQCG3M7KSXJWJM7R/
  - source: cve@mitre.org
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/YTF4FXCW22FFB5HNQO3GK3F4FFBLTZKE/
  title: abcm2ps v8.14.11 was discovered to contain an out-of-bounds read in the function
    calculate_beam at draw.c.
- diff_content:
  - "--- a/abcparse.c\n+++ b/abcparse.c\n@@ -2040,10 +2040,10 @@ static int parse_line(char\
    \ *p)\n \t\tcase CHAR_NOTE:\n \t\t\tp = parse_note(p - 1, flags);\n \t\t\tflags\
    \ &= ABC_F_GRACE;\n-\t\t\tparse.last_sym->u.note.slur_st = slur;\n-\t\t\tslur\
    \ = 0;\n-\t\t\tif (parse.last_sym->u.note.notes[0].len > 0) /* if not space */\n\
    -\t\t\t\tcurvoice->last_note = parse.last_sym;\n+\t\t\tif (slur && parse.last_sym->u.note.notes[0].len)\
    \ {\n+\t\t\t\tparse.last_sym->u.note.slur_st = slur;\n+\t\t\t\tslur = 0;\n+\t\t\
    \t}\n \t\t\tbreak;\n \t\tcase CHAR_SLASH:\t\t/* '/' */\n \t\t\tif (flags & ABC_F_GRACE)\n\
    @@ -2078,9 +2078,10 @@ static int parse_line(char *p)\n \t\t\tif (p[1] != ':')\
    \ {\n \t\t\t\tp = parse_note(p - 1, flags); /* chord */\n \t\t\t\tflags &= ABC_F_GRACE;\n\
    -\t\t\t\tparse.last_sym->u.note.slur_st = slur;\n-\t\t\t\tslur = 0;\n-\t\t\t\t\
    curvoice->last_note = parse.last_sym;\n+\t\t\t\tif (slur && parse.last_sym->u.note.notes[0].len)\
    \ {\n+\t\t\t\t\tparse.last_sym->u.note.slur_st = slur;\n+\t\t\t\t\tslur = 0;\n\
    +\t\t\t\t}\n \t\t\t\tbreak;\n \t\t\t}\n \n@@ -2511,6 +2512,8 @@ static char *parse_note(char\
    \ *p,\n \t\tsyntax(\"Not a note in grace note sequence\", p);\n \t\tgoto err;\n\
    \ \t}\n+\tif (s->u.note.notes[0].len > 0) /* if not space */\n+\t\tcurvoice->last_note\
    \ = s;\n \treturn p;\n \n err:"
  identifiers:
  - CVE-2021-32435
  - CWE-787
  overview: Stack-based buffer overflow in the function get_key in parse.c of abcm2ps
    v8.14.11 allows remote attackers to cause a Denial of Service (DoS) via unspecified
    vectors.
  references:
  - source: cve@mitre.org
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/leesavide/abcm2ps/commit/3169ace6d63f6f517a64e8df0298f44a490c4a15
  - source: cve@mitre.org
    tags:
    - Exploit
    - Issue Tracking
    - Third Party Advisory
    url: https://github.com/leesavide/abcm2ps/issues/84
  - source: cve@mitre.org
    tags:
    - Third Party Advisory
    url: https://lists.debian.org/debian-lts-announce/2022/04/msg00015.html
  - source: cve@mitre.org
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/6333SXWMES3K22DBAOAW34G6EU6WIJEY/
  - source: cve@mitre.org
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/EVGJH4HMXI3TWMHQJQCG3M7KSXJWJM7R/
  - source: cve@mitre.org
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/YTF4FXCW22FFB5HNQO3GK3F4FFBLTZKE/
  title: Stack-based buffer overflow in the function get_key in parse.c of abcm2ps
    v8.14.11 allows remote attackers to cause a Denial of Service (DoS) via unspecified
    vectors.
- diff_content:
  - "--- a/parse.c\n+++ b/parse.c\n@@ -2011,9 +2011,14 @@ static char txt_no_note[]\
    \ = \"No note in voice overlay\";\n \t\t\terror(1, s, \"Erroneous end of voice\
    \ overlap\");\n \t\t\treturn;\n \t\t}\n-\t\tif (p_voice->time != over_mxtime)\n\
    -\t\t\terror(1, s, tx_wrong_dur);\n \t\tcurvoice = &voice_tb[over_voice];\n+\t\
    \tif (p_voice->time != over_mxtime) {\n+\t\t\terror(1, s, tx_wrong_dur);\n+\t\t\
    \tif (p_voice->time > over_mxtime)\n+\t\t\t\tcurvoice->time = p_voice->time;\n\
    +\t\t\telse\n+\t\t\t\tp_voice->time = curvoice->time;\n+\t\t}\n \t\tover_mxtime\
    \ = 0;\n \t\tover_voice = -1;\n \t\tover_time = -1;"
  identifiers:
  - CVE-2021-32436
  - CWE-125
  overview: An out-of-bounds read in the function write_title() in subs.c of abcm2ps
    v8.14.11 allows remote attackers to cause a Denial of Service (DoS) via unspecified
    vectors.
  references:
  - source: cve@mitre.org
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/leesavide/abcm2ps/commit/2f56e1179cab6affeb8afa9d6c324008fe40d8e3
  - source: cve@mitre.org
    tags:
    - Exploit
    - Issue Tracking
    - Patch
    - Third Party Advisory
    url: https://github.com/leesavide/abcm2ps/issues/85
  - source: cve@mitre.org
    tags:
    - Third Party Advisory
    url: https://lists.debian.org/debian-lts-announce/2022/04/msg00015.html
  - source: cve@mitre.org
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/6333SXWMES3K22DBAOAW34G6EU6WIJEY/
  - source: cve@mitre.org
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/EVGJH4HMXI3TWMHQJQCG3M7KSXJWJM7R/
  - source: cve@mitre.org
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/YTF4FXCW22FFB5HNQO3GK3F4FFBLTZKE/
  title: An out-of-bounds read in the function write_title() in subs.c of abcm2ps
    v8.14.11 allows remote attackers to cause a Denial of Service (DoS) via unspecified
    vectors.
- diff_content:
  - "--- a/src/bridge/test-httpstream.c\n+++ b/src/bridge/test-httpstream.c\n@@ -34,7\
    \ +34,7 @@\n extern gboolean cockpit_webserver_want_certificate;\n \n /* JSON\
    \ dict snippet for headers that are present in every request */\n-#define STATIC_HEADERS\
    \ \"\\\"Cross-Origin-Resource-Policy\\\":\\\"same-origin\\\",\\\"Referrer-Policy\\\
    \":\\\"no-referrer\\\",\\\"X-Content-Type-Options\\\":\\\"nosniff\\\",\\\"X-DNS-Prefetch-Control\\\
    \":\\\"off\\\"\"\n+#define STATIC_HEADERS \"\\\"Cross-Origin-Resource-Policy\\\
    \":\\\"same-origin\\\",\\\"Referrer-Policy\\\":\\\"no-referrer\\\",\\\"X-Content-Type-Options\\\
    \":\\\"nosniff\\\",\\\"X-DNS-Prefetch-Control\\\":\\\"off\\\",\\\"X-Frame-Options\\\
    \":\\\"sameorigin\\\"\"\n \n static void\n on_closed_set_flag (CockpitChannel\
    \ *channel,"
  - "--- a/src/bridge/test-packages.c\n+++ b/src/bridge/test-packages.c\n@@ -47,7\
    \ +47,7 @@\n #define CHECKSUM_CSP            \"80921dc3cde9ff9f2acd2a5851f9b2a3b25ea7b4577128461d9e32fbdd671e16\"\
    \n \n /* JSON dict snippet for headers that are present in every request */\n\
    -#define STATIC_HEADERS \"\\\"X-DNS-Prefetch-Control\\\":\\\"off\\\",\\\"Referrer-Policy\\\
    \":\\\"no-referrer\\\",\\\"X-Content-Type-Options\\\":\\\"nosniff\\\",\\\"Cross-Origin-Resource-Policy\\\
    \": \\\"same-origin\\\"\"\n+#define STATIC_HEADERS \"\\\"X-DNS-Prefetch-Control\\\
    \":\\\"off\\\",\\\"Referrer-Policy\\\":\\\"no-referrer\\\",\\\"X-Content-Type-Options\\\
    \":\\\"nosniff\\\",\\\"Cross-Origin-Resource-Policy\\\": \\\"same-origin\\\",\\\
    \"X-Frame-Options\\\": \\\"sameorigin\\\"\"\n #define STATIC_HEADERS_CACHECONTROL\
    \ STATIC_HEADERS \",\\\"Cache-Control\\\":\\\"no-cache, no-store\\\"\"\n \n extern\
    \ const gchar **cockpit_bridge_data_dirs;"
  - "--- a/src/common/cockpitwebresponse.c\n+++ b/src/common/cockpitwebresponse.c\n\
    @@ -747,6 +747,7 @@ enum {\n     HEADER_REFERRER_POLICY = 1 << 5,\n     HEADER_CONTENT_TYPE_OPTIONS\
    \ = 1 << 6,\n     HEADER_CROSS_ORIGIN_RESOURCE_POLICY = 1 << 7,\n+    HEADER_X_FRAME_OPTIONS\
    \ = 1 << 8,\n };\n \n static GString *\n@@ -789,6 +790,8 @@ append_header (GString\
    \ *string,\n     return HEADER_CONTENT_TYPE_OPTIONS;\n   if (g_ascii_strcasecmp\
    \ (\"Cross-Origin-Resource-Policy\", name) == 0)\n     return HEADER_CROSS_ORIGIN_RESOURCE_POLICY;\n\
    +  if (g_ascii_strcasecmp (\"X-Frame-Options\", name) == 0)\n+    return HEADER_X_FRAME_OPTIONS;\n\
    \   if (g_ascii_strcasecmp (\"Content-Length\", name) == 0 ||\n       g_ascii_strcasecmp\
    \ (\"Transfer-Encoding\", name) == 0 ||\n       g_ascii_strcasecmp (\"Connection\"\
    , name) == 0)\n@@ -900,6 +903,9 @@ finish_headers (CockpitWebResponse *self,\n\
    \    * be able to read any resource. This does *not* affect embedding with <iframe>\
    \ */\n   if ((seen & HEADER_CROSS_ORIGIN_RESOURCE_POLICY) == 0)\n     g_string_append\
    \ (string, \"Cross-Origin-Resource-Policy: same-origin\\r\\n\");\n+  /* This is\
    \ the counterpart for iframe embedding, line of defence against clickjacking */\n\
    +  if ((seen & HEADER_X_FRAME_OPTIONS) == 0)\n+    g_string_append (string, \"\
    X-Frame-Options: sameorigin\\r\\n\");\n \n   g_string_append (string, \"\\r\\\
    n\");\n   return g_string_free_to_bytes (string);"
  - "--- a/src/common/test-webresponse.c\n+++ b/src/common/test-webresponse.c\n@@\
    \ -35,7 +35,7 @@\n #include <string.h>\n \n /* headers that are present in every\
    \ request */\n-#define STATIC_HEADERS \"X-DNS-Prefetch-Control: off\\r\\nReferrer-Policy:\
    \ no-referrer\\r\\nX-Content-Type-Options: nosniff\\r\\nCross-Origin-Resource-Policy:\
    \ same-origin\\r\\n\\r\\n\"\n+#define STATIC_HEADERS \"X-DNS-Prefetch-Control:\
    \ off\\r\\nReferrer-Policy: no-referrer\\r\\nX-Content-Type-Options: nosniff\\\
    r\\nCross-Origin-Resource-Policy: same-origin\\r\\nX-Frame-Options: sameorigin\\\
    r\\n\\r\\n\"\n static gchar *srcdir;\n \n typedef struct {"
  - "--- a/src/ws/test-channelresponse.c\n+++ b/src/ws/test-channelresponse.c\n@@\
    \ -53,7 +53,7 @@\n #define PASSWORD \"this is the password\"\n \n /* headers that\
    \ are present in every request */\n-#define STATIC_HEADERS \"X-Content-Type-Options:\
    \ nosniff\\r\\nX-DNS-Prefetch-Control: off\\r\\nReferrer-Policy: no-referrer\\\
    r\\nCross-Origin-Resource-Policy: same-origin\\r\\n\"\n+#define STATIC_HEADERS\
    \ \"X-Content-Type-Options: nosniff\\r\\nX-DNS-Prefetch-Control: off\\r\\nReferrer-Policy:\
    \ no-referrer\\r\\nCross-Origin-Resource-Policy: same-origin\\r\\nX-Frame-Options:\
    \ sameorigin\\r\\n\"\n \n typedef struct {\n   CockpitWebService *service;"
  identifiers:
  - CVE-2021-3660
  - CWE-1021
  overview: Cockpit (and its plugins) do not seem to protect itself against clickjacking.
    It is possible to render a page from a cockpit server via another website, inside
    an <iFrame> HTML entry. This may be used by a malicious website in clickjacking
    or similar attacks.
  references:
  - source: secalert@redhat.com
    tags:
    - Issue Tracking
    - Third Party Advisory
    url: https://bugzilla.redhat.com/show_bug.cgi?id=1980688
  - source: secalert@redhat.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/cockpit-project/cockpit/commit/8d9bc10d8128aae03dfde62fd00075fe492ead10
  - source: secalert@redhat.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/cockpit-project/cockpit/issues/16122
  title: Cockpit (and its plugins) do not seem to protect itself against clickjacking.
    It is possible to render a page from a cockpit server via another website, inside
    an <iFrame> HTML entry. This may be used by a malicious website in clickjacking
    or similar attacks.
- diff_content:
  - "--- a/fs/namespace.c\n+++ b/fs/namespace.c\n@@ -1938,6 +1938,20 @@ void drop_collected_mounts(struct\
    \ vfsmount *mnt)\n \tnamespace_unlock();\n }\n \n+static bool has_locked_children(struct\
    \ mount *mnt, struct dentry *dentry)\n+{\n+\tstruct mount *child;\n+\n+\tlist_for_each_entry(child,\
    \ &mnt->mnt_mounts, mnt_child) {\n+\t\tif (!is_subdir(child->mnt_mountpoint, dentry))\n\
    +\t\t\tcontinue;\n+\n+\t\tif (child->mnt.mnt_flags & MNT_LOCKED)\n+\t\t\treturn\
    \ true;\n+\t}\n+\treturn false;\n+}\n+\n /**\n  * clone_private_mount - create\
    \ a private clone of a path\n  * @path: path to clone\n@@ -1953,17 +1967,30 @@\
    \ struct vfsmount *clone_private_mount(const struct path *path)\n \tstruct mount\
    \ *old_mnt = real_mount(path->mnt);\n \tstruct mount *new_mnt;\n \n+\tdown_read(&namespace_sem);\n\
    \ \tif (IS_MNT_UNBINDABLE(old_mnt))\n-\t\treturn ERR_PTR(-EINVAL);\n+\t\tgoto\
    \ invalid;\n+\n+\tif (!check_mnt(old_mnt))\n+\t\tgoto invalid;\n+\n+\tif (has_locked_children(old_mnt,\
    \ path->dentry))\n+\t\tgoto invalid;\n \n \tnew_mnt = clone_mnt(old_mnt, path->dentry,\
    \ CL_PRIVATE);\n+\tup_read(&namespace_sem);\n+\n \tif (IS_ERR(new_mnt))\n \t\t\
    return ERR_CAST(new_mnt);\n \n \t/* Longterm mount to be removed by kern_unmount*()\
    \ */\n \tnew_mnt->mnt_ns = MNT_NS_INTERNAL;\n \n \treturn &new_mnt->mnt;\n+\n\
    +invalid:\n+\tup_read(&namespace_sem);\n+\treturn ERR_PTR(-EINVAL);\n }\n EXPORT_SYMBOL_GPL(clone_private_mount);\n\
    \ \n@@ -2315,19 +2342,6 @@ static int do_change_type(struct path *path, int ms_flags)\n\
    \ \treturn err;\n }\n \n-static bool has_locked_children(struct mount *mnt, struct\
    \ dentry *dentry)\n-{\n-\tstruct mount *child;\n-\tlist_for_each_entry(child,\
    \ &mnt->mnt_mounts, mnt_child) {\n-\t\tif (!is_subdir(child->mnt_mountpoint, dentry))\n\
    -\t\t\tcontinue;\n-\n-\t\tif (child->mnt.mnt_flags & MNT_LOCKED)\n-\t\t\treturn\
    \ true;\n-\t}\n-\treturn false;\n-}\n-\n static struct mount *__do_loopback(struct\
    \ path *old_path, int recurse)\n {\n \tstruct mount *mnt = ERR_PTR(-EINVAL), *old\
    \ = real_mount(old_path->mnt);"
  identifiers:
  - CVE-2021-3732
  - NVD-CWE-noinfo
  overview: A flaw was found in the Linux kernel's OverlayFS subsystem in the way
    the user mounts the TmpFS filesystem with OverlayFS. This flaw allows a local
    user to gain access to hidden files that should not be accessible.
  references:
  - source: secalert@redhat.com
    tags:
    - Issue Tracking
    - Patch
    - Third Party Advisory
    url: https://bugzilla.redhat.com/show_bug.cgi?id=1995249
  - source: secalert@redhat.com
    tags:
    - Mailing List
    - Patch
    - Vendor Advisory
    url: https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=427215d85e8d1476da1a86b8d67aceb485eb3631
  - source: secalert@redhat.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/torvalds/linux/commit/427215d85e8d1476da1a86b8d67aceb485eb3631
  - source: secalert@redhat.com
    tags:
    - Third Party Advisory
    url: https://ubuntu.com/security/CVE-2021-3732
  title: A flaw was found in the Linux kernel's OverlayFS subsystem in the way the
    user mounts the TmpFS filesystem with OverlayFS. This flaw allows a local user
    to gain access to hidden files that should not be accessible.
- diff_content:
  - "--- a/fs/btrfs/volumes.c\n+++ b/fs/btrfs/volumes.c\n@@ -2074,7 +2074,7 @@ int\
    \ btrfs_rm_device(struct btrfs_fs_info *fs_info, const char *device_path,\n \n\
    \ \tif (IS_ERR(device)) {\n \t\tif (PTR_ERR(device) == -ENOENT &&\n-\t\t    strcmp(device_path,\
    \ \"missing\") == 0)\n+\t\t    device_path && strcmp(device_path, \"missing\"\
    ) == 0)\n \t\t\tret = BTRFS_ERROR_DEV_MISSING_NOT_FOUND;\n \t\telse\n \t\t\tret\
    \ = PTR_ERR(device);"
  identifiers:
  - CVE-2021-3739
  - CWE-476
  overview: "A NULL pointer dereference flaw was found in the btrfs_rm_device function\
    \ in fs/btrfs/volumes.c in the Linux Kernel, where triggering the bug requires\
    \ \u2018CAP_SYS_ADMIN\u2019. This flaw allows a local attacker to crash the system\
    \ or leak kernel internal information. The highest threat from this vulnerability\
    \ is to system availability."
  references:
  - source: secalert@redhat.com
    tags:
    - Issue Tracking
    - Patch
    - Third Party Advisory
    url: https://bugzilla.redhat.com/show_bug.cgi?id=1997958
  - source: secalert@redhat.com
    tags:
    - Mailing List
    - Patch
    - Vendor Advisory
    url: https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=e4571b8c5e9ffa1e85c0c671995bd4dcc5c75091
  - source: secalert@redhat.com
    tags:
    - Exploit
    - Patch
    - Third Party Advisory
    url: https://github.com/torvalds/linux/commit/e4571b8c5e9ffa1e85c0c671995bd4dcc5c75091
  - source: secalert@redhat.com
    tags:
    - Third Party Advisory
    url: https://security.netapp.com/advisory/ntap-20220407-0006/
  - source: secalert@redhat.com
    tags:
    - Third Party Advisory
    url: https://ubuntu.com/security/CVE-2021-3739
  - source: secalert@redhat.com
    tags:
    - Mailing List
    - Patch
    - Third Party Advisory
    url: https://www.openwall.com/lists/oss-security/2021/08/25/3
  title: "A NULL pointer dereference flaw was found in the btrfs_rm_device function\
    \ in fs/btrfs/volumes.c in the Linux Kernel, where triggering the bug requires\
    \ \u2018CAP_SYS_ADMIN\u2019. This flaw allows a local attacker to crash the system\
    \ or leak kernel internal information. The highest threat from this vulnerability\
    \ is to system availability."
- diff_content:
  - "--- a/src/shared/gatt-server.c\n+++ b/src/shared/gatt-server.c\n@@ -779,6 +779,20\
    \ @@ static uint8_t authorize_req(struct bt_gatt_server *server,\n \t\t\t\t\t\t\
    server->authorize_data);\n }\n \n+static uint8_t check_length(uint16_t length,\
    \ uint16_t offset)\n+{\n+\tif (length > BT_ATT_MAX_VALUE_LEN)\n+\t\treturn BT_ATT_ERROR_INVALID_ATTRIBUTE_VALUE_LEN;\n\
    +\n+\tif (offset > BT_ATT_MAX_VALUE_LEN)\n+\t\treturn BT_ATT_ERROR_INVALID_OFFSET;\n\
    +\n+\tif (length + offset > BT_ATT_MAX_VALUE_LEN)\n+\t\treturn BT_ATT_ERROR_INVALID_ATTRIBUTE_VALUE_LEN;\n\
    +\n+\treturn 0;\n+}\n+\n static void write_cb(struct bt_att_chan *chan, uint8_t\
    \ opcode, const void *pdu,\n \t\t\t\t\tuint16_t length, void *user_data)\n {\n\
    @@ -809,6 +823,10 @@ static void write_cb(struct bt_att_chan *chan, uint8_t opcode,\
    \ const void *pdu,\n \t\t\t\t(opcode == BT_ATT_OP_WRITE_REQ) ? \"Req\" : \"Cmd\"\
    ,\n \t\t\t\thandle);\n \n+\tecode = check_length(length, 0);\n+\tif (ecode)\n\
    +\t\tgoto error;\n+\n \tecode = check_permissions(server, attr, BT_ATT_PERM_WRITE_MASK);\n\
    \ \tif (ecode)\n \t\tgoto error;\n@@ -1299,6 +1317,10 @@ static void prep_write_cb(struct\
    \ bt_att_chan *chan, uint8_t opcode,\n \tutil_debug(server->debug_callback, server->debug_data,\n\
    \ \t\t\t\t\"Prep Write Req - handle: 0x%04x\", handle);\n \n+\tecode = check_length(length,\
    \ offset);\n+\tif (ecode)\n+\t\tgoto error;\n+\n \tecode = check_permissions(server,\
    \ attr, BT_ATT_PERM_WRITE_MASK);\n \tif (ecode)\n \t\tgoto error;"
  identifiers:
  - CVE-2022-0204
  - CWE-190
  overview: A heap overflow vulnerability was found in bluez in versions prior to
    5.63. An attacker with local network access could pass specially crafted files
    causing an application to halt or crash, leading to a denial of service.
  references:
  - source: secalert@redhat.com
    tags:
    - Issue Tracking
    - Patch
    - Third Party Advisory
    url: https://bugzilla.redhat.com/show_bug.cgi?id=2039807
  - source: secalert@redhat.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/bluez/bluez/commit/591c546c536b42bef696d027f64aa22434f8c3f0
  - source: secalert@redhat.com
    tags:
    - Exploit
    - Third Party Advisory
    url: https://github.com/bluez/bluez/security/advisories/GHSA-479m-xcq5-9g2q
  - source: secalert@redhat.com
    tags:
    - Mailing List
    - Third Party Advisory
    url: https://lists.debian.org/debian-lts-announce/2022/10/msg00026.html
  - source: secalert@redhat.com
    tags:
    - Third Party Advisory
    url: https://security.gentoo.org/glsa/202209-16
  title: A heap overflow vulnerability was found in bluez in versions prior to 5.63.
    An attacker with local network access could pass specially crafted files causing
    an application to halt or crash, leading to a denial of service.
- diff_content:
  - "--- a/winvnc/winvnc/vncproperties.cpp\n+++ b/winvnc/winvnc/vncproperties.cpp\n\
    @@ -43,6 +43,7 @@\n #include \"vncConnDialog.h\"\r\n \r\n #include \"Localization.h\"\
    \ // ACT : Add localization on messages\r\n+#include \"shlwapi.h\"\r\n \r\n //extern\
    \ HINSTANCE g_hInst;\r\n \r\n@@ -719,7 +720,7 @@ vncProperties::DialogProc(HWND\
    \ hwnd,\n \r\n \t\t\t// Modif sf@2002\r\n \t\t\tSendMessage(GetDlgItem(hwnd, IDC_PLUGIN_CHECK),\
    \ BM_SETCHECK, _this->m_server->IsDSMPluginEnabled(), 0);\r\n-\t\t\tEnableWindow(GetDlgItem(hwnd,\
    \ IDC_PLUGIN_BUTTON), _this->m_server->IsDSMPluginEnabled());\r\n+\t\t\tEnableWindow(GetDlgItem(hwnd,\
    \ IDC_PLUGIN_BUTTON),  (_this->m_server->AuthClientCount() == 0 ? _this->m_server->IsDSMPluginEnabled():\
    \ false));\r\n \r\n \t\t\t// Query window option - Taken from TightVNC advanced\
    \ properties \r\n \t\t\tBOOL queryEnabled = (_this->m_server->QuerySetting() ==\
    \ 4);\r\n@@ -1285,8 +1286,9 @@ vncProperties::DialogProc(HWND hwnd,\n \t\t// sf@2002\
    \ - DSM Plugin\r\n \t\tcase IDC_PLUGIN_CHECK:\r\n \t\t\t{\r\n-\t\t\t\tEnableWindow(GetDlgItem(hwnd,\
    \ IDC_PLUGIN_BUTTON),\r\n-\t\t\t\t\tSendMessage(GetDlgItem(hwnd, IDC_PLUGIN_CHECK),\
    \ BM_GETCHECK, 0, 0) == BST_CHECKED);\r\n+\t\t\t\tEnableWindow(GetDlgItem(hwnd,\
    \ IDC_PLUGIN_BUTTON), _this->m_server->AuthClientCount() == 0 \r\n+\t\t\t\t\t\t\
    ? SendMessage(GetDlgItem(hwnd, IDC_PLUGIN_CHECK), BM_GETCHECK, 0, 0) == BST_CHECKED\
    \ \r\n+\t\t\t\t\t\t: BST_UNCHECKED);\r\n \t\t\t}\r\n \t\t\treturn TRUE;\r\n \t\
    \t\t// Marscha@2004 - authSSP: moved MSLogon checkbox back to admin props page\r\
    \n@@ -1368,6 +1370,8 @@ vncProperties::DialogProc(HWND hwnd,\n \t\t\t\t{\r\n \t\
    \t\t\t\tTCHAR szPlugin[MAX_PATH];\r\n \t\t\t\t\tGetDlgItemText(hwnd, IDC_PLUGINS_COMBO,\
    \ szPlugin, MAX_PATH);\r\n+\t\t\t\t\tPathStripPathA(szPlugin);\r\n+\r\n \t\t\t\
    \t\tif (!_this->m_server->GetDSMPluginPointer()->IsLoaded())\r\n \t\t\t\t\t\t\
    _this->m_server->GetDSMPluginPointer()->LoadPlugin(szPlugin, false);\r\n \t\t\t\
    \t\telse\r"
  identifiers:
  - CVE-2022-24750
  - CWE-269
  overview: UltraVNC is a free and open source remote pc access software. A vulnerability
    has been found in versions prior to 1.3.8.0 in which the DSM plugin module, which
    allows a local authenticated user to achieve local privilege escalation (LPE)
    on a vulnerable system. The vulnerability has been fixed to allow loading of plugins
    from the installed directory. Affected users should upgrade their UltraVNC to
    1.3.8.1. Users unable to upgrade should not install and run UltraVNC server as
    a service. It is advisable to create a scheduled task on a low privilege account
    to launch WinVNC.exe instead. There are no known workarounds if winvnc needs to
    be started as a service.
  references:
  - source: security-advisories@github.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/bowtiejicode/UltraVNC-DSMPlugin-LPE
  - source: security-advisories@github.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/ultravnc/UltraVNC/commit/36a31b37b98f70c1db0428f5ad83170d604fb352
  - source: security-advisories@github.com
    tags:
    - Third Party Advisory
    url: https://github.com/ultravnc/UltraVNC/security/advisories/GHSA-3mvp-cp5x-vj5g
  title: UltraVNC is a free and open source remote pc access software. A vulnerability
    has been found in versions prior to 1.3.8.0 in which the DSM plugin module, which
    allows a local authenticated user to achieve local privilege escalation (LPE)
    on a vulnerable system. The vulnerability has been fixed to allow loading of plugins
    from the installed directory. Affected users should upgrade their UltraVNC to
    1.3.8.1. Users unable to upgrade should not install and run UltraVNC server as
    a service. It is advisable to create a scheduled task on a low privilege account
    to launch WinVNC.exe instead. There are no known workarounds if winvnc needs to
    be started as a service.
- diff_content:
  - "--- a/libtiff/tif_dirread.c\n+++ b/libtiff/tif_dirread.c\n@@ -5091,7 +5091,10\
    \ @@ TIFFFetchNormalTag(TIFF* tif, TIFFDirEntry* dp, int recover)\n \t\t\t\t\t\
    \t\t\t_TIFFfree(data);\n \t\t\t\t\t\t\treturn(0);\n \t\t\t\t\t\t}\n-\t\t\t\t\t\
    \t_TIFFmemcpy(o,data,(uint32_t)dp->tdir_count);\n+\t\t\t\t\t\tif (dp->tdir_count\
    \ > 0 )\n+\t\t\t\t\t\t{\n+\t\t\t\t\t\t\t_TIFFmemcpy(o,data,(uint32_t)dp->tdir_count);\n\
    +\t\t\t\t\t\t}\n \t\t\t\t\t\to[(uint32_t)dp->tdir_count]=0;\n \t\t\t\t\t\tif (data!=0)\n\
    \ \t\t\t\t\t\t\t_TIFFfree(data);\n"
  identifiers:
  - CVE-2022-0908
  - CWE-476
  overview: Null source pointer passed as an argument to memcpy() function within
    TIFFFetchNormalTag () in tif_dirread.c in libtiff versions up to 4.3.0 could lead
    to Denial of Service via crafted TIFF file.
  references:
  - source: cve@gitlab.com
    tags:
    - Third Party Advisory
    url: https://gitlab.com/gitlab-org/cves/-/blob/master/2022/CVE-2022-0908.json
  - source: cve@gitlab.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://gitlab.com/libtiff/libtiff/-/commit/a95b799f65064e4ba2e2dfc206808f86faf93e85
  - source: cve@gitlab.com
    tags:
    - Exploit
    - Issue Tracking
    - Patch
    - Third Party Advisory
    url: https://gitlab.com/libtiff/libtiff/-/issues/383
  - source: cve@gitlab.com
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/RNT2GFNRLOMKJ5KXM6JIHKBNBFDVZPD3/
  - source: cve@gitlab.com
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/ZQ4E654ZYUUUQNBKYQFXNK2CV3CPWTM2/
  - source: cve@gitlab.com
    tags:
    - Third Party Advisory
    url: https://security.gentoo.org/glsa/202210-10
  - source: cve@gitlab.com
    tags:
    - Third Party Advisory
    url: https://security.netapp.com/advisory/ntap-20220506-0002/
  - source: cve@gitlab.com
    tags:
    - Third Party Advisory
    url: https://www.debian.org/security/2022/dsa-5108
  title: Null source pointer passed as an argument to memcpy() function within TIFFFetchNormalTag
    () in tif_dirread.c in libtiff versions up to 4.3.0 could lead to Denial of Service
    via crafted TIFF file.
- diff_content:
  - "--- a/pjsip/src/pjsip/sip_auth_aka.c\n+++ b/pjsip/src/pjsip/sip_auth_aka.c\n\
    @@ -57,18 +57,19 @@ PJ_DEF(pj_status_t) pjsip_auth_create_aka_response(\n    \
    \ pj_uint8_t xmac[PJSIP_AKA_MACLEN];\n     pjsip_cred_info aka_cred;\n     int\
    \ i, len;\n-    pj_status_t status;\n+    pj_status_t status = PJ_SUCCESS;\n \n\
    \     /* Check the algorithm is supported. */\n     if (chal->algorithm.slen==0\
    \ || pj_stricmp2(&chal->algorithm, \"md5\") == 0) {\n \t/*\n-\t * A normal MD5\
    \ authentication is requested. Fallbackt to the usual\n+\t * A normal MD5 authentication\
    \ is requested. Fallback to the usual\n \t * MD5 digest creation.\n \t */\n-\t\
    pjsip_auth_create_digest(&auth->response, &auth->nonce, &auth->nc,\n-\t\t\t\t\
    \ &auth->cnonce, &auth->qop, &auth->uri,\n-\t\t\t\t &auth->realm, cred, method);\n\
    -\treturn PJ_SUCCESS;\n+\tstatus = pjsip_auth_create_digest(&auth->response, &auth->nonce,\
    \ \n+\t\t\t         &auth->nc, &auth->cnonce, &auth->qop, \n+\t\t\t         &auth->uri,\
    \ &auth->realm, cred, method);\n+\n+\treturn status;\n \n     } else if (pj_stricmp(&chal->algorithm,\
    \ &pjsip_AKAv1_MD5) == 0) {\n \t/*\n@@ -147,9 +148,9 @@ PJ_DEF(pj_status_t) pjsip_auth_create_aka_response(\n\
    \ \taka_cred.data.ptr = (char*)res;\n \taka_cred.data.slen = PJSIP_AKA_RESLEN;\n\
    \ \n-\tpjsip_auth_create_digest(&auth->response, &chal->nonce, \n+\tstatus = pjsip_auth_create_digest(&auth->response,\
    \ &chal->nonce, \n \t\t\t\t &auth->nc, &auth->cnonce, &auth->qop, \n-\t\t\t\t\
    \ &auth->uri, &chal->realm, &aka_cred, method);\n+\t\t\t\t &auth->uri, &chal->realm,\
    \ &aka_cred, method);\t\n \n     } else if (aka_version == 2) {\n \n@@ -186,7\
    \ +187,7 @@ PJ_DEF(pj_status_t) pjsip_auth_create_aka_response(\n \t         \
    \        aka_cred.data.ptr, &len);\n \taka_cred.data.slen = hmac64_len;\n \n-\t\
    pjsip_auth_create_digest(&auth->response, &chal->nonce, \n+\tstatus = pjsip_auth_create_digest(&auth->response,\
    \ &chal->nonce, \n \t\t\t\t &auth->nc, &auth->cnonce, &auth->qop, \n \t\t\t\t\
    \ &auth->uri, &chal->realm, &aka_cred, method);\n \n@@ -196,7 +197,7 @@ PJ_DEF(pj_status_t)\
    \ pjsip_auth_create_aka_response(\n     }\n \n     /* Done */\n-    return PJ_SUCCESS;\n\
    +    return status;\n }\n \n "
  - "--- a/pjsip/src/pjsip/sip_auth_client.c\n+++ b/pjsip/src/pjsip/sip_auth_client.c\n\
    @@ -160,15 +160,15 @@ static void digestNtoStr(const unsigned char digest[], int\
    \ n, char *output)\n  * Create response digest based on the parameters and store\
    \ the\n  * digest ASCII in 'result'.\n  */\n-PJ_DEF(void) pjsip_auth_create_digest(\
    \ pj_str_t *result,\n-\t\t\t\t       const pj_str_t *nonce,\n-\t\t\t\t       const\
    \ pj_str_t *nc,\n-\t\t\t\t       const pj_str_t *cnonce,\n-\t\t\t\t       const\
    \ pj_str_t *qop,\n-\t\t\t\t       const pj_str_t *uri,\n-\t\t\t\t       const\
    \ pj_str_t *realm,\n-\t\t\t\t       const pjsip_cred_info *cred_info,\n-\t\t\t\
    \t       const pj_str_t *method)\n+PJ_DEF(pj_status_t) pjsip_auth_create_digest(\
    \ pj_str_t *result,\n+\t\t\t\t\t      const pj_str_t *nonce,\n+\t\t\t\t\t    \
    \  const pj_str_t *nc,\n+\t\t\t\t\t      const pj_str_t *cnonce,\n+\t\t\t\t\t\
    \      const pj_str_t *qop,\n+\t\t\t\t\t      const pj_str_t *uri,\n+\t\t\t\t\t\
    \      const pj_str_t *realm,\n+\t\t\t\t\t      const pjsip_cred_info *cred_info,\n\
    +\t\t\t\t\t      const pj_str_t *method)\n {\n     char ha1[PJSIP_MD5STRLEN];\n\
    \     char ha2[PJSIP_MD5STRLEN];\n@@ -194,10 +194,18 @@ PJ_DEF(void) pjsip_auth_create_digest(\
    \ pj_str_t *result,\n \tdigestNtoStr(digest, 16, ha1);\n \n     } else if ((cred_info->data_type\
    \ & PASSWD_MASK) == PJSIP_CRED_DATA_DIGEST) {\n-\tpj_assert(cred_info->data.slen\
    \ == 32);\n+\tif (cred_info->data.slen != 32) {\n+\t    pj_assert(!\"Invalid cred_info\
    \ data length\");\n+\t    pj_bzero(result->ptr, result->slen);\n+\t    result->slen\
    \ = 0;\n+\t    return PJ_EINVAL;\n+\t}\n \tpj_memcpy( ha1, cred_info->data.ptr,\
    \ cred_info->data.slen );\n     } else {\n \tpj_assert(!\"Invalid data_type\"\
    );\n+\tpj_bzero(result->ptr, result->slen);\n+\tresult->slen = 0;\n+\treturn PJ_EINVAL;\n\
    \     }\n \n     AUTH_TRACE_((THIS_FILE, \"  ha1=%.32s\", ha1));\n@@ -245,14 +253,15\
    \ @@ PJ_DEF(void) pjsip_auth_create_digest( pj_str_t *result,\n \n     AUTH_TRACE_((THIS_FILE,\
    \ \"  digest=%.32s\", result->ptr));\n     AUTH_TRACE_((THIS_FILE, \"Digest created\"\
    ));\n+    return PJ_SUCCESS;\n }\n \n \n /*\n  * Create response SHA-256 digest\
    \ based on the parameters and store the\n  * digest ASCII in 'result'.\n  */\n\
    -PJ_DEF(void) pjsip_auth_create_digestSHA256(pj_str_t *result,\n+PJ_DEF(pj_status_t)\
    \ pjsip_auth_create_digestSHA256(pj_str_t *result,\n \t\t\t\t\t    const pj_str_t\
    \ *nonce,\n \t\t\t\t\t    const pj_str_t *nc,\n \t\t\t\t\t    const pj_str_t *cnonce,\n\
    @@ -291,10 +300,18 @@ PJ_DEF(void) pjsip_auth_create_digestSHA256(pj_str_t *result,\n\
    \ \n     } else if ((cred_info->data_type & PASSWD_MASK) == PJSIP_CRED_DATA_DIGEST)\n\
    \     {\n-\tpj_assert(cred_info->data.slen == 32);\n+\tif (cred_info->data.slen\
    \ != 64) {\n+\t    pj_assert(!\"Invalid cred_info data length\");\n+\t    pj_bzero(result->ptr,\
    \ result->slen);\n+\t    result->slen = 0;\n+\t    return PJ_EINVAL;\n+\t}\n \t\
    pj_memcpy( ha1, cred_info->data.ptr, cred_info->data.slen );\n     } else {\n\
    \ \tpj_assert(!\"Invalid data_type\");\n+\tpj_bzero(result->ptr, result->slen);\n\
    +\tresult->slen = 0;\n+\treturn PJ_EINVAL;\n     }\n \n     AUTH_TRACE_((THIS_FILE,\
    \ \" ha1=%.64s\", ha1));\n@@ -354,6 +371,7 @@ PJ_DEF(void) pjsip_auth_create_digestSHA256(pj_str_t\
    \ *result,\n     PJ_UNUSED_ARG(cred_info);\n     PJ_UNUSED_ARG(method);\n #endif\n\
    +    return PJ_SUCCESS;\n }\n \n \n@@ -408,6 +426,7 @@ static pj_status_t respond_digest(\
    \ pj_pool_t *pool,\n {\n     const pj_str_t pjsip_AKAv1_MD5_STR = { \"AKAv1-MD5\"\
    , 9 };\n     pj_bool_t algo_sha256 = PJ_FALSE;\n+    pj_status_t status = PJ_SUCCESS;\n\
    \ \n     /* Check if algo is sha256 */\n #if PJSIP_AUTH_HAS_DIGEST_SHA256\n@@\
    \ -452,14 +471,14 @@ static pj_status_t respond_digest( pj_pool_t *pool,\n \t\
    else {\n \t    /* Convert digest to string and store in chal->response. */\n \t\
    \    if (algo_sha256) {\n-\t\tpjsip_auth_create_digestSHA256(\n+\t\tstatus = pjsip_auth_create_digestSHA256(\n\
    \ \t\t\t\t\t  &cred->response, &cred->nonce, NULL,\n \t\t\t\t\t  NULL,  NULL,\
    \ uri, &chal->realm,\n \t\t\t\t\t  cred_info, method);\n \t    } else {\n-\t\t\
    pjsip_auth_create_digest( &cred->response, &cred->nonce, NULL,\n-\t\t\t\t\t  NULL,\
    \  NULL, uri, &chal->realm,\n-\t\t\t\t\t  cred_info, method);\n+\t\tstatus = pjsip_auth_create_digest(\
    \ &cred->response, \n+\t\t\t\t\t  &cred->nonce, NULL, NULL, NULL, uri, \n+\t\t\
    \t\t\t  &chal->realm, cred_info, method);\n \t    }\n \t}\n \n@@ -486,18 +505,18\
    \ @@ static pj_status_t respond_digest( pj_pool_t *pool,\n \telse {\n \t    /*\
    \ Convert digest to string and store in chal->response. */\n \t    if (algo_sha256)\
    \ {\n-\t\tpjsip_auth_create_digestSHA256(\n+\t\tstatus = pjsip_auth_create_digestSHA256(\n\
    \ \t\t\t\t\t  &cred->response, &cred->nonce,\n \t\t\t\t\t  &cred->nc, &cred->cnonce,\n\
    \ \t\t\t\t\t  &pjsip_AUTH_STR, uri,\n \t\t\t\t\t  &chal->realm, cred_info,\n \t\
    \t\t\t\t  method);\n \t    } else {\n-\t\tpjsip_auth_create_digest( &cred->response,\
    \ &cred->nonce,\n-\t\t\t\t\t  &cred->nc, &cred->cnonce,\n-\t\t\t\t\t  &pjsip_AUTH_STR,\
    \ uri,\n-\t\t\t\t\t  &chal->realm, cred_info,\n-\t\t\t\t\t  method);\n+\t\tstatus\
    \ = pjsip_auth_create_digest( &cred->response, \n+\t\t\t\t\t  &cred->nonce, &cred->nc,\
    \ \n+\t\t\t\t          &cred->cnonce, &pjsip_AUTH_STR, \n+\t\t\t\t\t  uri, &chal->realm,\
    \ \n+\t\t\t\t\t  cred_info, method);\n \t    }\n \t}\n \n@@ -508,7 +527,7 @@ static\
    \ pj_status_t respond_digest( pj_pool_t *pool,\n \treturn PJSIP_EINVALIDQOP;\n\
    \     }\n \n-    return PJ_SUCCESS;\n+    return status;\n }\n \n #if defined(PJSIP_AUTH_QOP_SUPPORT)\
    \ && PJSIP_AUTH_QOP_SUPPORT!=0"
  - "--- a/pjsip/src/pjsip/sip_auth_server.c\n+++ b/pjsip/src/pjsip/sip_auth_server.c\n\
    @@ -79,6 +79,7 @@ static pj_status_t pjsip_auth_verify( const pjsip_authorization_hdr\
    \ *hdr,\n     if (pj_stricmp(&hdr->scheme, &pjsip_DIGEST_STR) == 0) {\n \tchar\
    \ digest_buf[PJSIP_MD5STRLEN];\n \tpj_str_t digest;\n+\tpj_status_t status;\n\
    \ \tconst pjsip_digest_credential *dig = &hdr->credential.digest;\n \n \t/* Check\
    \ that username and realm match. \n@@ -95,7 +96,7 @@ static pj_status_t pjsip_auth_verify(\
    \ const pjsip_authorization_hdr *hdr,\n \tdigest.slen = PJSIP_MD5STRLEN;\n \n\
    \ \t/* Create digest for comparison. */\n-\tpjsip_auth_create_digest(&digest,\
    \ \n+\tstatus = pjsip_auth_create_digest(&digest, \n \t\t\t\t &hdr->credential.digest.nonce,\n\
    \ \t\t\t\t &hdr->credential.digest.nc, \n \t\t\t\t &hdr->credential.digest.cnonce,\n\
    @@ -105,6 +106,9 @@ static pj_status_t pjsip_auth_verify( const pjsip_authorization_hdr\
    \ *hdr,\n \t\t\t\t cred_info, \n \t\t\t\t method );\n \n+\tif (status != PJ_SUCCESS)\n\
    +\t    return status;\n+\n \t/* Compare digest. */\n \treturn (pj_stricmp(&digest,\
    \ &hdr->credential.digest.response) == 0) ?\n \t       PJ_SUCCESS : PJSIP_EAUTHINVALIDDIGEST;"
  - "--- a/pjsip/src/pjsua-lib/pjsua_core.c\n+++ b/pjsip/src/pjsua-lib/pjsua_core.c\n\
    @@ -3126,7 +3126,8 @@ void pjsua_init_tpselector(pjsua_transport_id tp_id,\n \
    \    if (tp_id == PJSUA_INVALID_ID)\n \treturn;\n \n-    pj_assert(tp_id >= 0\
    \ && tp_id < (int)PJ_ARRAY_SIZE(pjsua_var.tpdata));\n+    PJ_ASSERT_RETURN(tp_id\
    \ >= 0 && \n+\t\t     tp_id < (int)PJ_ARRAY_SIZE(pjsua_var.tpdata), );\n     tpdata\
    \ = &pjsua_var.tpdata[tp_id];\n \n     flag = pjsip_transport_get_flag_from_type(tpdata->type);"
  identifiers:
  - CVE-2022-24754
  - CWE-120
  overview: PJSIP is a free and open source multimedia communication library written
    in C language. In versions prior to and including 2.12 PJSIP there is a stack-buffer
    overflow vulnerability which only impacts PJSIP users who accept hashed digest
    credentials (credentials with data_type `PJSIP_CRED_DATA_DIGEST`). This issue
    has been patched in the master branch of the PJSIP repository and will be included
    with the next release. Users unable to upgrade need to check that the hashed digest
    data length must be equal to `PJSIP_MD5STRLEN` before passing to PJSIP.
  references:
  - source: security-advisories@github.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/pjsip/pjproject/commit/d27f79da11df7bc8bb56c2f291d71e54df8d2c47
  - source: security-advisories@github.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/pjsip/pjproject/security/advisories/GHSA-73f7-48m9-w662
  - source: security-advisories@github.com
    tags:
    - Mailing List
    - Third Party Advisory
    url: https://lists.debian.org/debian-lts-announce/2022/03/msg00035.html
  - source: security-advisories@github.com
    url: https://lists.debian.org/debian-lts-announce/2023/08/msg00038.html
  - source: security-advisories@github.com
    tags:
    - Third Party Advisory
    url: https://security.gentoo.org/glsa/202210-37
  title: PJSIP is a free and open source multimedia communication library written
    in C language. In versions prior to and including 2.12 PJSIP there is a stack-buffer
    overflow vulnerability which only impacts PJSIP users who accept hashed digest
    credentials (credentials with data_type `PJSIP_CRED_DATA_DIGEST`). This issue
    has been patched in the master branch of the PJSIP repository and will be included
    with the next release. Users unable to upgrade need to check that the hashed digest
    data length must be equal to `PJSIP_MD5STRLEN` before passing to PJSIP.
- diff_content:
  - "--- a/src/spellsuggest.c\n+++ b/src/spellsuggest.c\n@@ -506,6 +506,10 @@ spell_suggest(int\
    \ count)\n \t    curwin->w_cursor.col = VIsual.col;\n \t++badlen;\n \tend_visual_mode();\n\
    +\t// make sure we don't include the NUL at the end of the line\n+\tline = ml_get_curline();\n\
    +\tif (badlen > STRLEN(line) - curwin->w_cursor.col)\n+\t    badlen = STRLEN(line)\
    \ - curwin->w_cursor.col;\n     }\n     // Find the start of the badly spelled\
    \ word.\n     else if (spell_move_to(curwin, FORWARD, TRUE, TRUE, NULL) == 0"
  - "--- a/src/version.c\n+++ b/src/version.c\n@@ -750,6 +750,8 @@ static char *(features[])\
    \ =\n \n static int included_patches[] =\n {   /* Add new patch number below this\
    \ line */\n+/**/\n+    4563,\n /**/\n     4562,\n /**/"
  identifiers:
  - CVE-2022-0943
  - CWE-122
  overview: Heap-based Buffer Overflow occurs in vim in GitHub repository vim/vim
    prior to 8.2.4563.
  references:
  - source: security@huntr.dev
    tags:
    - Mailing List
    - Third Party Advisory
    url: http://seclists.org/fulldisclosure/2022/Oct/28
  - source: security@huntr.dev
    tags:
    - Mailing List
    - Release Notes
    - Third Party Advisory
    url: http://seclists.org/fulldisclosure/2022/Oct/41
  - source: security@huntr.dev
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/vim/vim/commit/5c68617d395f9d7b824f68475b24ce3e38d653a3
  - source: security@huntr.dev
    tags:
    - Exploit
    - Third Party Advisory
    url: https://huntr.dev/bounties/9e4de32f-ad5f-4830-b3ae-9467b5ab90a1
  - source: security@huntr.dev
    tags:
    - Mailing List
    - Third Party Advisory
    url: https://lists.debian.org/debian-lts-announce/2022/06/msg00014.html
  - source: security@huntr.dev
    tags:
    - Mailing List
    - Third Party Advisory
    url: https://lists.debian.org/debian-lts-announce/2022/11/msg00009.html
  - source: security@huntr.dev
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/C3R36VSLO4TRX72SWB6IDJOD24BQXPX2/
  - source: security@huntr.dev
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/RAIQTUO35U5WO2NYMY47637EMCVDJRSL/
  - source: security@huntr.dev
    tags:
    - Third Party Advisory
    url: https://security.gentoo.org/glsa/202208-32
  - source: security@huntr.dev
    tags:
    - Release Notes
    - Third Party Advisory
    url: https://support.apple.com/kb/HT213488
  title: Heap-based Buffer Overflow occurs in vim in GitHub repository vim/vim prior
    to 8.2.4563.
- diff_content:
  - "--- a/drivers/usb/gadget/udc/udc-xilinx.c\n+++ b/drivers/usb/gadget/udc/udc-xilinx.c\n\
    @@ -1615,6 +1615,8 @@ static void xudc_getstatus(struct xusb_udc *udc)\n \t\t\
    break;\n \tcase USB_RECIP_ENDPOINT:\n \t\tepnum = udc->setup.wIndex & USB_ENDPOINT_NUMBER_MASK;\n\
    +\t\tif (epnum >= XUSB_MAX_ENDPOINTS)\n+\t\t\tgoto stall;\n \t\ttarget_ep = &udc->ep[epnum];\n\
    \ \t\tepcfgreg = udc->read_fn(udc->addr + target_ep->offset);\n \t\thalt = epcfgreg\
    \ & XUSB_EP_CFG_STALL_MASK;\n@@ -1682,6 +1684,10 @@ static void xudc_set_clear_feature(struct\
    \ xusb_udc *udc)\n \tcase USB_RECIP_ENDPOINT:\n \t\tif (!udc->setup.wValue) {\n\
    \ \t\t\tendpoint = udc->setup.wIndex & USB_ENDPOINT_NUMBER_MASK;\n+\t\t\tif (endpoint\
    \ >= XUSB_MAX_ENDPOINTS) {\n+\t\t\t\txudc_ep0_stall(udc);\n+\t\t\t\treturn;\n\
    +\t\t\t}\n \t\t\ttarget_ep = &udc->ep[endpoint];\n \t\t\toutinbit = udc->setup.wIndex\
    \ & USB_ENDPOINT_DIR_MASK;\n \t\t\toutinbit = outinbit >> 7;"
  identifiers:
  - CVE-2022-27223
  - CWE-129
  overview: In drivers/usb/gadget/udc/udc-xilinx.c in the Linux kernel before 5.16.12,
    the endpoint index is not validated and might be manipulated by the host for out-of-array
    access.
  references:
  - source: cve@mitre.org
    tags:
    - Mailing List
    - Release Notes
    - Vendor Advisory
    url: https://cdn.kernel.org/pub/linux/kernel/v5.x/ChangeLog-5.16.12
  - source: cve@mitre.org
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/torvalds/linux/commit/7f14c7227f342d9932f9b918893c8814f86d2a0d
  - source: cve@mitre.org
    tags:
    - Mailing List
    - Third Party Advisory
    url: https://lists.debian.org/debian-lts-announce/2022/07/msg00000.html
  - source: cve@mitre.org
    tags:
    - Third Party Advisory
    url: https://security.netapp.com/advisory/ntap-20220419-0001/
  title: In drivers/usb/gadget/udc/udc-xilinx.c in the Linux kernel before 5.16.12,
    the endpoint index is not validated and might be manipulated by the host for out-of-array
    access.
- diff_content:
  - "--- a/hw/net/e1000.c\n+++ b/hw/net/e1000.c\n@@ -670,6 +670,9 @@ process_tx_desc(E1000State\
    \ *s, struct e1000_tx_desc *dp)\n         msh = tp->tso_props.hdr_len + tp->tso_props.mss;\n\
    \         do {\n             bytes = split_size;\n+            if (tp->size >=\
    \ msh) {\n+                goto eop;\n+            }\n             if (tp->size\
    \ + bytes > msh)\n                 bytes = msh - tp->size;\n \n@@ -695,6 +698,7\
    \ @@ process_tx_desc(E1000State *s, struct e1000_tx_desc *dp)\n         tp->size\
    \ += split_size;\n     }\n \n+eop:\n     if (!(txd_lower & E1000_TXD_CMD_EOP))\n\
    \         return;\n     if (!(tp->cptse && tp->size < tp->tso_props.hdr_len))\
    \ {"
  identifiers:
  - CVE-2021-20257
  - CWE-835
  overview: An infinite loop flaw was found in the e1000 NIC emulator of the QEMU.
    This issue occurs while processing transmits (tx) descriptors in process_tx_desc
    if various descriptor fields are initialized with invalid values. This flaw allows
    a guest to consume CPU cycles on the host, resulting in a denial of service. The
    highest threat from this vulnerability is to system availability.
  references:
  - source: secalert@redhat.com
    tags:
    - Issue Tracking
    - Patch
    - Third Party Advisory
    url: https://bugzilla.redhat.com/show_bug.cgi?id=1930087
  - source: secalert@redhat.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/qemu/qemu/commit/3de46e6fc489c52c9431a8a832ad8170a7569bd8
  - source: secalert@redhat.com
    tags:
    - Mailing List
    - Third Party Advisory
    url: https://lists.debian.org/debian-lts-announce/2022/09/msg00008.html
  - source: secalert@redhat.com
    tags:
    - Mailing List
    - Patch
    - Vendor Advisory
    url: https://lists.gnu.org/archive/html/qemu-devel/2021-02/msg07428.html
  - source: secalert@redhat.com
    tags:
    - Third Party Advisory
    url: https://security.gentoo.org/glsa/202208-27
  - source: secalert@redhat.com
    tags:
    - Third Party Advisory
    url: https://security.netapp.com/advisory/ntap-20220425-0003/
  - source: secalert@redhat.com
    tags:
    - Mailing List
    - Patch
    - Third Party Advisory
    url: https://www.openwall.com/lists/oss-security/2021/02/25/2
  title: An infinite loop flaw was found in the e1000 NIC emulator of the QEMU. This
    issue occurs while processing transmits (tx) descriptors in process_tx_desc if
    various descriptor fields are initialized with invalid values. This flaw allows
    a guest to consume CPU cycles on the host, resulting in a denial of service. The
    highest threat from this vulnerability is to system availability.
- diff_content:
  - "--- a/OpenEXR/IlmImf/ImfMultiPartInputFile.cpp\n+++ b/OpenEXR/IlmImf/ImfMultiPartInputFile.cpp\n\
    @@ -340,6 +340,11 @@ MultiPartInputFile::initialize()\n     // Perform usual check\
    \ on headers.\n     //\n \n+    if ( _data->_headers.size() == 0)\n+    {\n+ \
    \       throw IEX_NAMESPACE::ArgExc (\"Files must contain at least one header\"\
    );\n+    }\n+\n     for (size_t i = 0; i < _data->_headers.size(); i++)\n    \
    \ {\n         //"
  identifiers:
  - CVE-2021-20299
  - CWE-476
  overview: A flaw was found in OpenEXR's Multipart input file functionality. A crafted
    multi-part input file with no actual parts can trigger a NULL pointer dereference.
    The highest threat from this vulnerability is to system availability.
  references:
  - source: secalert@redhat.com
    tags:
    - Mailing List
    - Patch
    - Third Party Advisory
    url: https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=25740
  - source: secalert@redhat.com
    tags:
    - Issue Tracking
    - Patch
    - Third Party Advisory
    url: https://bugzilla.redhat.com/show_bug.cgi?id=1939154
  - source: secalert@redhat.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/AcademySoftwareFoundation/openexr/commit/25e9515b06a6bc293d871622b8cafaee7af84e0f
  - source: secalert@redhat.com
    tags:
    - Mailing List
    - Third Party Advisory
    url: https://lists.debian.org/debian-lts-announce/2022/12/msg00022.html
  title: A flaw was found in OpenEXR's Multipart input file functionality. A crafted
    multi-part input file with no actual parts can trigger a NULL pointer dereference.
    The highest threat from this vulnerability is to system availability.
- diff_content:
  - "--- a/htmldoc/file.c\n+++ b/htmldoc/file.c\n@@ -1010,8 +1010,15 @@ file_rlookup(const\
    \ char *filename)\t/* I - Filename */\n \n \n   for (i = web_files, wc = web_cache;\
    \ i > 0; i --, wc ++)\n+  {\n     if (!strcmp(wc->name, filename))\n-      return\
    \ (wc->url);\n+    {\n+      if (!strncmp(wc->url, \"data:\", 5))\n+        return\
    \ (\"data URL\");\n+      else\n+        return (wc->url);\n+    }\n+  }\n \n\
    \   return (filename);\n }"
  identifiers:
  - CVE-2021-23158
  - CWE-415
  overview: A flaw was found in htmldoc in v1.9.12. Double-free in function pspdf_export(),in
    ps-pdf.cxx may result in a write-what-where condition, allowing an attacker to
    execute arbitrary code and denial of service.
  references:
  - source: secalert@redhat.com
    tags:
    - Issue Tracking
    - Third Party Advisory
    url: https://bugzilla.redhat.com/show_bug.cgi?id=1967018
  - source: secalert@redhat.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/michaelrsweet/htmldoc/commit/369b2ea1fd0d0537ba707f20a2f047b6afd2fbdc
  - source: secalert@redhat.com
    tags:
    - Exploit
    - Issue Tracking
    - Third Party Advisory
    url: https://github.com/michaelrsweet/htmldoc/issues/414
  title: A flaw was found in htmldoc in v1.9.12. Double-free in function pspdf_export(),in
    ps-pdf.cxx may result in a write-what-where condition, allowing an attacker to
    execute arbitrary code and denial of service.
- diff_content:
  - "--- a/hw/net/virtio-net.c\n+++ b/hw/net/virtio-net.c\n@@ -1870,6 +1870,7 @@ static\
    \ ssize_t virtio_net_receive_rcu(NetClientState *nc, const uint8_t *buf,\n \n\
    \ err:\n     for (j = 0; j < i; j++) {\n+        virtqueue_detach_element(q->rx_vq,\
    \ elems[j], lens[j]);\n         g_free(elems[j]);\n     }\n \n"
  identifiers:
  - CVE-2022-26353
  - CWE-772
  overview: 'A flaw was found in the virtio-net device of QEMU. This flaw was inadvertently
    introduced with the fix for CVE-2021-3748, which forgot to unmap the cached virtqueue
    elements on error, leading to memory leakage and other unexpected results. Affected
    QEMU version: 6.2.0.'
  references:
  - source: secalert@redhat.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://gitlab.com/qemu-project/qemu/-/commit/abe300d9d894f7138e1af7c8e9c88c04bfe98b37
  - source: secalert@redhat.com
    tags:
    - Mailing List
    - Patch
    - Vendor Advisory
    url: https://lists.nongnu.org/archive/html/qemu-devel/2022-03/msg02438.html
  - source: secalert@redhat.com
    tags:
    - Third Party Advisory
    url: https://security.gentoo.org/glsa/202208-27
  - source: secalert@redhat.com
    tags:
    - Third Party Advisory
    url: https://security.netapp.com/advisory/ntap-20220425-0003/
  - source: secalert@redhat.com
    tags:
    - Third Party Advisory
    url: https://www.debian.org/security/2022/dsa-5133
  title: 'A flaw was found in the virtio-net device of QEMU. This flaw was inadvertently
    introduced with the fix for CVE-2021-3748, which forgot to unmap the cached virtqueue
    elements on error, leading to memory leakage and other unexpected results. Affected
    QEMU version: 6.2.0.'
- diff_content:
  - "--- a/hw/virtio/vhost-vsock-common.c\n+++ b/hw/virtio/vhost-vsock-common.c\n\
    @@ -153,19 +153,23 @@ static void vhost_vsock_common_send_transport_reset(VHostVSockCommon\
    \ *vvc)\n     if (elem->out_num) {\n         error_report(\"invalid vhost-vsock\
    \ event virtqueue element with \"\n                      \"out buffers\");\n-\
    \        goto out;\n+        goto err;\n     }\n \n     if (iov_from_buf(elem->in_sg,\
    \ elem->in_num, 0,\n                      &event, sizeof(event)) != sizeof(event))\
    \ {\n         error_report(\"vhost-vsock event virtqueue element is too short\"\
    );\n-        goto out;\n+        goto err;\n     }\n \n     virtqueue_push(vq,\
    \ elem, sizeof(event));\n     virtio_notify(VIRTIO_DEVICE(vvc), vq);\n \n-out:\n\
    +    g_free(elem);\n+    return;\n+\n+err:\n+    virtqueue_detach_element(vq,\
    \ elem, 0);\n     g_free(elem);\n }\n \n"
  identifiers:
  - CVE-2022-26354
  - CWE-772
  overview: A flaw was found in the vhost-vsock device of QEMU. In case of error,
    an invalid element was not detached from the virtqueue before freeing its memory,
    leading to memory leakage and other unexpected results. Affected QEMU versions
    <= 6.2.0.
  references:
  - source: secalert@redhat.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://gitlab.com/qemu-project/qemu/-/commit/8d1b247f3748ac4078524130c6d7ae42b6140aaf
  - source: secalert@redhat.com
    tags:
    - Mailing List
    - Third Party Advisory
    url: https://lists.debian.org/debian-lts-announce/2022/04/msg00002.html
  - source: secalert@redhat.com
    tags:
    - Mailing List
    - Third Party Advisory
    url: https://lists.debian.org/debian-lts-announce/2022/09/msg00008.html
  - source: secalert@redhat.com
    tags:
    - Third Party Advisory
    url: https://security.gentoo.org/glsa/202208-27
  - source: secalert@redhat.com
    tags:
    - Third Party Advisory
    url: https://security.netapp.com/advisory/ntap-20220425-0003/
  - source: secalert@redhat.com
    tags:
    - Third Party Advisory
    url: https://www.debian.org/security/2022/dsa-5133
  title: A flaw was found in the vhost-vsock device of QEMU. In case of error, an
    invalid element was not detached from the virtqueue before freeing its memory,
    leading to memory leakage and other unexpected results. Affected QEMU versions
    <= 6.2.0.
- diff_content:
  - "--- a/src/txn.cpp\n+++ b/src/txn.cpp\n@@ -295,6 +295,8 @@ Nan::NAN_METHOD_RETURN_TYPE\
    \ TxnWrap::putCommon(Nan::NAN_METHOD_ARGS_TYPE info, v\n }\n \n NAN_METHOD(TxnWrap::putString)\
    \ {\n+    if (!info[2]->IsString())\n+        return Nan::ThrowError(\"Value must\
    \ be a string.\");\n     return putCommon(info, [](Nan::NAN_METHOD_ARGS_TYPE info,\
    \ MDB_val &data) -> void {\n         CustomExternalStringResource::writeTo(Local<String>::Cast(info[2]),\
    \ &data);\n     }, [](MDB_val &data) -> void {"
  identifiers:
  - CVE-2022-21164
  - NVD-CWE-noinfo
  overview: The package node-lmdb before 0.9.7 are vulnerable to Denial of Service
    (DoS) when defining a non-invokable ToString value, which will cause a crash during
    type check.
  references:
  - source: report@snyk.io
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/Venemo/node-lmdb/commit/97760104c0fd311206b88aecd91fa1f59fe2b85a
  - source: report@snyk.io
    tags:
    - Exploit
    - Patch
    - Third Party Advisory
    url: https://snyk.io/vuln/SNYK-JS-NODELMDB-2400723
  title: The package node-lmdb before 0.9.7 are vulnerable to Denial of Service (DoS)
    when defining a non-invokable ToString value, which will cause a crash during
    type check.
- diff_content:
  - "--- a/src/scheme/webauthn.c\n+++ b/src/scheme/webauthn.c\n@@ -2636,11 +2636,23\
    \ @@ static int check_assertion(struct config_module * config, json_t * j_params,\
    \ con\n         break;\n       }\n \n-      if (!o_base64url_decode((const unsigned\
    \ char *)json_string_value(json_object_get(json_object_get(json_object_get(j_scheme_data,\
    \ \"credential\"), \"response\"), \"signature\")), json_string_length(json_object_get(json_object_get(json_object_get(j_scheme_data,\
    \ \"credential\"), \"response\"), \"signature\")), sig, &sig_len)) {\n-      \
    \  y_log_message(Y_LOG_LEVEL_DEBUG, \"check_assertion - Error o_base64url_decode\
    \ signature\");\n+      if (!o_base64_decode((const unsigned char *)json_string_value(json_object_get(json_object_get(json_object_get(j_scheme_data,\
    \ \"credential\"), \"response\"), \"signature\")), json_string_length(json_object_get(json_object_get(json_object_get(j_scheme_data,\
    \ \"credential\"), \"response\"), \"signature\")), NULL, &sig_len)) {\n+     \
    \   y_log_message(Y_LOG_LEVEL_DEBUG, \"check_assertion - Invalid signature format\"\
    );\n         ret = G_ERROR_PARAM;\n         break;\n       }\n+      \n+     \
    \ if (sig_len > 128) {\n+        y_log_message(Y_LOG_LEVEL_DEBUG, \"check_assertion\
    \ - Invalid signature\");\n+        ret = G_ERROR_PARAM;\n+        break;\n+ \
    \     }\n+\n+      if (!o_base64_decode((const unsigned char *)json_string_value(json_object_get(json_object_get(json_object_get(j_scheme_data,\
    \ \"credential\"), \"response\"), \"signature\")), json_string_length(json_object_get(json_object_get(json_object_get(j_scheme_data,\
    \ \"credential\"), \"response\"), \"signature\")), sig, &sig_len)) {\n+      \
    \  y_log_message(Y_LOG_LEVEL_DEBUG, \"check_assertion - Error o_base64_decode\
    \ signature\");\n+        ret = G_ERROR;\n+        break;\n+      }\n \n     \
    \  memcpy(data_signed, auth_data, auth_data_len);\n       memcpy(data_signed+auth_data_len,\
    \ cdata_hash, cdata_hash_len);"
  identifiers:
  - CVE-2022-27240
  - CWE-120
  overview: scheme/webauthn.c in Glewlwyd SSO server 2.x before 2.6.2 has a buffer
    overflow associated with a webauthn assertion.
  references:
  - source: cve@mitre.org
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/babelouest/glewlwyd/commit/4c5597c155bfbaf6491cf6b83479d241ae66940a
  - source: cve@mitre.org
    tags:
    - Release Notes
    - Third Party Advisory
    url: https://github.com/babelouest/glewlwyd/releases/tag/v2.6.2
  title: scheme/webauthn.c in Glewlwyd SSO server 2.x before 2.6.2 has a buffer overflow
    associated with a webauthn assertion.
- diff_content:
  - "--- a/src/scene_manager/scene_dump.c\n+++ b/src/scene_manager/scene_dump.c\n\
    @@ -755,8 +755,7 @@ static void gf_dump_vrml_simple_field(GF_SceneDumper *sdump,\
    \ GF_FieldInfo field,\n \n \tswitch (field.fieldType) {\n \tcase GF_SG_VRML_SFNODE:\n\
    -\t\tassert ( *(GF_Node **)field.far_ptr);\n-\t\tgf_dump_vrml_node(sdump, *(GF_Node\
    \ **)field.far_ptr, 0, NULL);\n+\t\tgf_dump_vrml_node(sdump, field.far_ptr ? *(GF_Node\
    \ **)field.far_ptr : NULL, 0, NULL);\n \t\treturn;\n \tcase GF_SG_VRML_MFNODE:\n\
    \ \t\tlist = * ((GF_ChildNodeItem **) field.far_ptr);"
  identifiers:
  - CVE-2022-1035
  - CWE-476
  overview: Segmentation Fault caused by MP4Box -lsr in GitHub repository gpac/gpac
    prior to 2.1.0-DEV.
  references:
  - source: security@huntr.dev
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/gpac/gpac/commit/3718d583c6ade191dc7979c64f48c001ca6f0243
  - source: security@huntr.dev
    tags:
    - Exploit
    - Patch
    - Third Party Advisory
    url: https://huntr.dev/bounties/851942a4-1d64-4553-8fdc-9fccd167864b
  - source: security@huntr.dev
    url: https://www.debian.org/security/2023/dsa-5411
  title: Segmentation Fault caused by MP4Box -lsr in GitHub repository gpac/gpac prior
    to 2.1.0-DEV.
- diff_content:
  - "--- a/pjmedia/src/pjmedia/sdp.c\n+++ b/pjmedia/src/pjmedia/sdp.c\n@@ -733,12\
    \ +733,21 @@ static int print_media_desc(const pjmedia_sdp_media *m, char *buf,\
    \ pj_size_t len\n     pj_memcpy(p, m->desc.transport.ptr, m->desc.transport.slen);\n\
    \     p += m->desc.transport.slen;\n     for (i=0; i<m->desc.fmt_count; ++i) {\n\
    -\t*p++ = ' ';\n-\tpj_memcpy(p, m->desc.fmt[i].ptr, m->desc.fmt[i].slen);\n-\t\
    p += m->desc.fmt[i].slen;\n+\tif (end-p > m->desc.fmt[i].slen) {\n+\t    *p++\
    \ = ' ';\n+\t    pj_memcpy(p, m->desc.fmt[i].ptr, m->desc.fmt[i].slen);\n+\t \
    \   p += m->desc.fmt[i].slen;\n+\t} else {\n+\t    return -1;\n+\t}\n+    }\n\
    +\n+    if (end-p >= 2) {\n+\t*p++ = '\\r';\n+\t*p++ = '\\n';\n+    } else {\n\
    +\treturn -1;\n     }\n-    *p++ = '\\r';\n-    *p++ = '\\n';\n \n     /* print\
    \ connection info, if present. */\n     if (m->conn) {"
  identifiers:
  - CVE-2022-24764
  - CWE-120
  overview: PJSIP is a free and open source multimedia communication library written
    in C. Versions 2.12 and prior contain a stack buffer overflow vulnerability that
    affects PJSUA2 users or users that call the API `pjmedia_sdp_print(), pjmedia_sdp_media_print()`.
    Applications that do not use PJSUA2 and do not directly call `pjmedia_sdp_print()`
    or `pjmedia_sdp_media_print()` should not be affected. A patch is available on
    the `master` branch of the `pjsip/pjproject` GitHub repository. There are currently
    no known workarounds.
  references:
  - source: security-advisories@github.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/pjsip/pjproject/commit/560a1346f87aabe126509bb24930106dea292b00
  - source: security-advisories@github.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/pjsip/pjproject/security/advisories/GHSA-f5qg-pqcg-765m
  - source: security-advisories@github.com
    tags:
    - Mailing List
    - Third Party Advisory
    url: https://lists.debian.org/debian-lts-announce/2022/03/msg00035.html
  - source: security-advisories@github.com
    tags:
    - Mailing List
    - Third Party Advisory
    url: https://lists.debian.org/debian-lts-announce/2022/11/msg00021.html
  - source: security-advisories@github.com
    url: https://lists.debian.org/debian-lts-announce/2023/08/msg00038.html
  - source: security-advisories@github.com
    tags:
    - Third Party Advisory
    url: https://security.gentoo.org/glsa/202210-37
  - source: security-advisories@github.com
    tags:
    - Third Party Advisory
    url: https://www.debian.org/security/2022/dsa-5285
  title: PJSIP is a free and open source multimedia communication library written
    in C. Versions 2.12 and prior contain a stack buffer overflow vulnerability that
    affects PJSUA2 users or users that call the API `pjmedia_sdp_print(), pjmedia_sdp_media_print()`.
    Applications that do not use PJSUA2 and do not directly call `pjmedia_sdp_print()`
    or `pjmedia_sdp_media_print()` should not be affected. A patch is available on
    the `master` branch of the `pjsip/pjproject` GitHub repository. There are currently
    no known workarounds.
- diff_content:
  - "--- a/libr/anal/fcn.c\n+++ b/libr/anal/fcn.c\n@@ -882,6 +882,12 @@ static int\
    \ fcn_recurse(RAnal *anal, RAnalFunction *fcn, ut64 addr, ut64 len, int\n \t\t\
    \t// swapped parameters wtf\n \t\t\tr_anal_xrefs_set (anal, op->addr, op->ptr,\
    \ R_ANAL_REF_TYPE_DATA);\n \t\t}\n+\t\tif (anal->opt.vars && !varset) {\n+\t\t\
    \t// XXX uses op.src/dst and fails because regprofile invalidates the regitems\n\
    +\t\t\t// lets just call this BEFORE retpoline() to avoid such issue\n+\t\t\t\
    r_anal_extract_vars (anal, fcn, op);\n+\t\t}\n+\t\t// this call may cause regprofile\
    \ changes which cause ranalop.regitem references to be invalid\n \t\tanalyze_retpoline\
    \ (anal, op);\n \t\tswitch (op->type & R_ANAL_OP_TYPE_MASK) {\n \t\tcase R_ANAL_OP_TYPE_CMOV:\n\
    @@ -1404,10 +1410,13 @@ static int fcn_recurse(RAnal *anal, RAnalFunction *fcn,\
    \ ut64 addr, ut64 len, int\n \t\t\t\t}\n \t\t\t}\n \t\t}\n+#if 0\n \t\tif (anal->opt.vars\
    \ && !varset) {\n \t\t\t// XXX uses op.src/dst and fails because regprofile invalidates\
    \ the regitems\n+\t\t\t// we must ranalop in here to avoid uaf\n \t\t\tr_anal_extract_vars\
    \ (anal, fcn, op);\n \t\t}\n+#endif\n \t\tif (op->type != R_ANAL_OP_TYPE_MOV &&\
    \ op->type != R_ANAL_OP_TYPE_CMOV && op->type != R_ANAL_OP_TYPE_LEA) {\n \t\t\t\
    last_is_reg_mov_lea = false;\n \t\t}"
  - "--- a/libr/anal/var.c\n+++ b/libr/anal/var.c\n@@ -1048,7 +1048,7 @@ static void\
    \ extract_arg(RAnal *anal, RAnalFunction *fcn, RAnalOp *op, const char\n \t\t\
    free (vartype);\n \t} else {\n \t\tst64 frame_off = -(ptr + fcn->bp_off);\n-\t\
    \tif (maxstackframe != 0 && (frame_off > maxstackframe || frame_off < -maxstackframe))\
    \ {\n+\t\tif (maxstackframe > 0 && (frame_off > maxstackframe || frame_off < -maxstackframe))\
    \ {\n \t\t\tgoto beach;\n \t\t}\n \t\tRAnalVar *var = get_stack_var (fcn, frame_off);"
  identifiers:
  - CVE-2022-1031
  - CWE-416
  overview: Use After Free in op_is_set_bp in GitHub repository radareorg/radare2
    prior to 5.6.6.
  references:
  - source: security@huntr.dev
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/radareorg/radare2/commit/a7ce29647fcb38386d7439696375e16e093d6acb
  - source: security@huntr.dev
    tags:
    - Exploit
    - Third Party Advisory
    url: https://huntr.dev/bounties/37da2cd6-0b46-4878-a32e-acbfd8f6f457
  title: Use After Free in op_is_set_bp in GitHub repository radareorg/radare2 prior
    to 5.6.6.
- diff_content:
  - "--- a/net/ipv4/esp4.c\n+++ b/net/ipv4/esp4.c\n@@ -446,6 +446,7 @@ int esp_output_head(struct\
    \ xfrm_state *x, struct sk_buff *skb, struct esp_info *\n \tstruct page *page;\n\
    \ \tstruct sk_buff *trailer;\n \tint tailen = esp->tailen;\n+\tunsigned int allocsz;\n\
    \ \n \t/* this is non-NULL only with TCP/UDP Encapsulation */\n \tif (x->encap)\
    \ {\n@@ -455,6 +456,10 @@ int esp_output_head(struct xfrm_state *x, struct sk_buff\
    \ *skb, struct esp_info *\n \t\t\treturn err;\n \t}\n \n+\tallocsz = ALIGN(skb->data_len\
    \ + tailen, L1_CACHE_BYTES);\n+\tif (allocsz > ESP_SKB_FRAG_MAXSIZE)\n+\t\tgoto\
    \ cow;\n+\n \tif (!skb_cloned(skb)) {\n \t\tif (tailen <= skb_tailroom(skb)) {\n\
    \ \t\t\tnfrags = 1;"
  - "--- a/net/ipv6/esp6.c\n+++ b/net/ipv6/esp6.c\n@@ -482,6 +482,7 @@ int esp6_output_head(struct\
    \ xfrm_state *x, struct sk_buff *skb, struct esp_info\n \tstruct page *page;\n\
    \ \tstruct sk_buff *trailer;\n \tint tailen = esp->tailen;\n+\tunsigned int allocsz;\n\
    \ \n \tif (x->encap) {\n \t\tint err = esp6_output_encap(x, skb, esp);\n@@ -490,6\
    \ +491,10 @@ int esp6_output_head(struct xfrm_state *x, struct sk_buff *skb, struct\
    \ esp_info\n \t\t\treturn err;\n \t}\n \n+\tallocsz = ALIGN(skb->data_len + tailen,\
    \ L1_CACHE_BYTES);\n+\tif (allocsz > ESP_SKB_FRAG_MAXSIZE)\n+\t\tgoto cow;\n+\n\
    \ \tif (!skb_cloned(skb)) {\n \t\tif (tailen <= skb_tailroom(skb)) {\n \t\t\t\
    nfrags = 1;"
  identifiers:
  - CVE-2022-27666
  - CWE-787
  overview: A heap buffer overflow flaw was found in IPsec ESP transformation code
    in net/ipv4/esp4.c and net/ipv6/esp6.c. This flaw allows a local attacker with
    a normal user privilege to overwrite kernel heap objects and may cause a local
    privilege escalation threat.
  references:
  - source: cve@mitre.org
    tags:
    - Issue Tracking
    - Patch
    - Third Party Advisory
    url: https://bugzilla.redhat.com/show_bug.cgi?id=2061633
  - source: cve@mitre.org
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/torvalds/linux/commit/ebe48d368e97d007bfeb76fcb065d6cfc4c96645
  - source: cve@mitre.org
    tags:
    - Third Party Advisory
    url: https://security.netapp.com/advisory/ntap-20220429-0001/
  - source: cve@mitre.org
    tags:
    - Third Party Advisory
    url: https://www.debian.org/security/2022/dsa-5127
  - source: cve@mitre.org
    tags:
    - Third Party Advisory
    url: https://www.debian.org/security/2022/dsa-5173
  title: A heap buffer overflow flaw was found in IPsec ESP transformation code in
    net/ipv4/esp4.c and net/ipv6/esp6.c. This flaw allows a local attacker with a
    normal user privilege to overwrite kernel heap objects and may cause a local privilege
    escalation threat.
- diff_content:
  - "--- a/hw/net/virtio-net.c\n+++ b/hw/net/virtio-net.c\n@@ -1746,10 +1746,13 @@\
    \ static ssize_t virtio_net_receive_rcu(NetClientState *nc, const uint8_t *buf,\n\
    \     VirtIONet *n = qemu_get_nic_opaque(nc);\n     VirtIONetQueue *q = virtio_net_get_subqueue(nc);\n\
    \     VirtIODevice *vdev = VIRTIO_DEVICE(n);\n+    VirtQueueElement *elems[VIRTQUEUE_MAX_SIZE];\n\
    +    size_t lens[VIRTQUEUE_MAX_SIZE];\n     struct iovec mhdr_sg[VIRTQUEUE_MAX_SIZE];\n\
    \     struct virtio_net_hdr_mrg_rxbuf mhdr;\n     unsigned mhdr_cnt = 0;\n-  \
    \  size_t offset, i, guest_offset;\n+    size_t offset, i, guest_offset, j;\n\
    +    ssize_t err;\n \n     if (!virtio_net_can_receive(nc)) {\n         return\
    \ -1;\n@@ -1780,6 +1783,12 @@ static ssize_t virtio_net_receive_rcu(NetClientState\
    \ *nc, const uint8_t *buf,\n \n         total = 0;\n \n+        if (i == VIRTQUEUE_MAX_SIZE)\
    \ {\n+            virtio_error(vdev, \"virtio-net unexpected long buffer chain\"\
    );\n+            err = size;\n+            goto err;\n+        }\n+\n        \
    \ elem = virtqueue_pop(q->rx_vq, sizeof(VirtQueueElement));\n         if (!elem)\
    \ {\n             if (i) {\n@@ -1791,15 +1800,17 @@ static ssize_t virtio_net_receive_rcu(NetClientState\
    \ *nc, const uint8_t *buf,\n                              n->guest_hdr_len, n->host_hdr_len,\n\
    \                              vdev->guest_features);\n             }\n-     \
    \       return -1;\n+            err = -1;\n+            goto err;\n         }\n\
    \ \n         if (elem->in_num < 1) {\n             virtio_error(vdev,\n      \
    \                    \"virtio-net receive queue contains no in buffers\");\n \
    \            virtqueue_detach_element(q->rx_vq, elem, 0);\n             g_free(elem);\n\
    -            return -1;\n+            err = -1;\n+            goto err;\n    \
    \     }\n \n         sg = elem->in_sg;\n@@ -1836,12 +1847,13 @@ static ssize_t\
    \ virtio_net_receive_rcu(NetClientState *nc, const uint8_t *buf,\n         if\
    \ (!n->mergeable_rx_bufs && offset < size) {\n             virtqueue_unpop(q->rx_vq,\
    \ elem, total);\n             g_free(elem);\n-            return size;\n+    \
    \        err = size;\n+            goto err;\n         }\n \n-        /* signal\
    \ other side */\n-        virtqueue_fill(q->rx_vq, elem, total, i++);\n-     \
    \   g_free(elem);\n+        elems[i] = elem;\n+        lens[i] = total;\n+   \
    \     i++;\n     }\n \n     if (mhdr_cnt) {\n@@ -1851,10 +1863,23 @@ static ssize_t\
    \ virtio_net_receive_rcu(NetClientState *nc, const uint8_t *buf,\n           \
    \           &mhdr.num_buffers, sizeof mhdr.num_buffers);\n     }\n \n+    for\
    \ (j = 0; j < i; j++) {\n+        /* signal other side */\n+        virtqueue_fill(q->rx_vq,\
    \ elems[j], lens[j], j);\n+        g_free(elems[j]);\n+    }\n+\n     virtqueue_flush(q->rx_vq,\
    \ i);\n     virtio_notify(vdev, q->rx_vq);\n \n     return size;\n+\n+err:\n+\
    \    for (j = 0; j < i; j++) {\n+        g_free(elems[j]);\n+    }\n+\n+    return\
    \ err;\n }\n \n static ssize_t virtio_net_do_receive(NetClientState *nc, const\
    \ uint8_t *buf,"
  identifiers:
  - CVE-2021-3748
  - CWE-416
  overview: A use-after-free vulnerability was found in the virtio-net device of QEMU.
    It could occur when the descriptor's address belongs to the non direct access
    region, due to num_buffers being set after the virtqueue elem has been unmapped.
    A malicious guest could use this flaw to crash QEMU, resulting in a denial of
    service condition, or potentially execute code on the host with the privileges
    of the QEMU process.
  references:
  - source: secalert@redhat.com
    tags:
    - Issue Tracking
    - Patch
    - Third Party Advisory
    url: https://bugzilla.redhat.com/show_bug.cgi?id=1998514
  - source: secalert@redhat.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/qemu/qemu/commit/bedd7e93d01961fcb16a97ae45d93acf357e11f6
  - source: secalert@redhat.com
    tags:
    - Mailing List
    - Third Party Advisory
    url: https://lists.debian.org/debian-lts-announce/2022/04/msg00002.html
  - source: secalert@redhat.com
    tags:
    - Mailing List
    - Third Party Advisory
    url: https://lists.debian.org/debian-lts-announce/2022/09/msg00008.html
  - source: secalert@redhat.com
    tags:
    - Mailing List
    - Patch
    - Third Party Advisory
    url: https://lists.nongnu.org/archive/html/qemu-devel/2021-09/msg00388.html
  - source: secalert@redhat.com
    tags:
    - Third Party Advisory
    url: https://security.gentoo.org/glsa/202208-27
  - source: secalert@redhat.com
    tags:
    - Third Party Advisory
    url: https://security.netapp.com/advisory/ntap-20220425-0004/
  - source: secalert@redhat.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://ubuntu.com/security/CVE-2021-3748
  title: A use-after-free vulnerability was found in the virtio-net device of QEMU.
    It could occur when the descriptor's address belongs to the non direct access
    region, due to num_buffers being set after the virtqueue elem has been unmapped.
    A malicious guest could use this flaw to crash QEMU, resulting in a denial of
    service condition, or potentially execute code on the host with the privileges
    of the QEMU process.
- diff_content:
  - "--- a/libr/bin/p/bin_symbols.c\n+++ b/libr/bin/p/bin_symbols.c\n@@ -181,14 +181,17\
    \ @@ static RBinSymbol *bin_symbol_from_symbol(RCoreSymCacheElement *element,\
    \ RCoreSy\n \n static RCoreSymCacheElement *parseDragons(RBinFile *bf, RBuffer\
    \ *buf, int off, int bits, R_OWN char *file_name) {\n \tD eprintf (\"Dragons at\
    \ 0x%x\\n\", off);\n-\tut64 size = r_buf_size (buf);\n+\tst64 size = r_buf_size\
    \ (buf);\n \tif (off >= size) {\n \t\treturn NULL;\n \t}\n \tsize -= off;\n \t\
    if (!size) {\n \t\treturn NULL;\n \t}\n+\tif (size < 32) {\n+\t\treturn NULL;\n\
    +\t}\n \tut8 *b = malloc (size);\n \tif (!b) {\n \t\treturn NULL;"
  identifiers:
  - CVE-2022-1061
  - CWE-787
  overview: Heap Buffer Overflow in parseDragons in GitHub repository radareorg/radare2
    prior to 5.6.8.
  references:
  - source: security@huntr.dev
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/radareorg/radare2/commit/d4ce40b516ffd70cf2e9e36832d8de139117d522
  - source: security@huntr.dev
    tags:
    - Exploit
    - Patch
    - Third Party Advisory
    url: https://huntr.dev/bounties/a7546dae-01c5-4fb0-8a8e-c04ea4e9bac7
  title: Heap Buffer Overflow in parseDragons in GitHub repository radareorg/radare2
    prior to 5.6.8.
- diff_content:
  - "--- a/libr/bin/format/mach0/mach0.c\n+++ b/libr/bin/format/mach0/mach0.c\n@@\
    \ -1510,10 +1510,11 @@ static bool parse_chained_fixups(struct MACH0_(obj_t) *bin,\
    \ ut32 offset, ut32 si\n \tif (header.starts_offset > size) {\n \t\treturn false;\n\
    \ \t}\n-\tut32 segs_count;\n-\tif ((segs_count = r_buf_read_le32_at (bin->b, starts_at))\
    \ == UT32_MAX) {\n+\tut32 segs_count = r_buf_read_le32_at (bin->b, starts_at);\n\
    +\tif (segs_count == UT32_MAX || segs_count == 0) {\n \t\treturn false;\n \t}\n\
    +\tbin->segs_count = segs_count;\n \tbin->chained_starts = R_NEWS0 (struct r_dyld_chained_starts_in_segment\
    \ *, segs_count);\n \tif (!bin->chained_starts) {\n \t\treturn false;\n@@ -1699,6\
    \ +1700,7 @@ static bool reconstruct_chained_fixup(struct MACH0_(obj_t) *bin)\
    \ {\n \t}\n \tR_FREE (opcodes);\n \n+\tbin->segs_count = bin->nsegs;\n \treturn\
    \ true;\n }\n \n@@ -2124,7 +2126,7 @@ void *MACH0_(mach0_free)(struct MACH0_(obj_t)\
    \ *mo) {\n \tfree (mo->intrp);\n \tfree (mo->compiler);\n \tif (mo->chained_starts)\
    \ {\n-\t\tfor (i = 0; i < mo->nsegs; i++) {\n+\t\tfor (i = 0; i < mo->nsegs &&\
    \ i < mo->segs_count; i++) {\n \t\t\tif (mo->chained_starts[i]) {\n \t\t\t\tfree\
    \ (mo->chained_starts[i]->page_start);\n \t\t\t\tfree (mo->chained_starts[i]);\n\
    @@ -4558,7 +4560,7 @@ struct MACH0_(mach_header) *MACH0_(get_hdr)(RBuffer *buf)\
    \ {\n \n void MACH0_(iterate_chained_fixups)(struct MACH0_(obj_t) *bin, ut64 limit_start,\
    \ ut64 limit_end, ut32 event_mask, RFixupCallback callback, void * context) {\n\
    \ \tint i = 0;\n-\tfor (; i < bin->nsegs; i++) {\n+\tfor (; i < bin->nsegs &&\
    \ i < bin->segs_count; i++) {\n \t\tif (!bin->chained_starts[i]) {\n \t\t\tcontinue;\n\
    \ \t\t}"
  identifiers:
  - CVE-2022-1052
  - CWE-787
  overview: Heap Buffer Overflow in iterate_chained_fixups in GitHub repository radareorg/radare2
    prior to 5.6.6.
  references:
  - source: security@huntr.dev
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/radareorg/radare2/commit/0052500c1ed5bf8263b26b9fd7773dbdc6f170c4
  - source: security@huntr.dev
    tags:
    - Exploit
    - Third Party Advisory
    url: https://huntr.dev/bounties/3b3b7f77-ab8d-4de3-999b-eeec0a3eebe7
  title: Heap Buffer Overflow in iterate_chained_fixups in GitHub repository radareorg/radare2
    prior to 5.6.6.
- diff_content:
  - "--- a/deflate.c\n+++ b/deflate.c\n@@ -255,11 +255,6 @@ int ZEXPORT deflateInit2_(strm,\
    \ level, method, windowBits, memLevel, strategy,\n     int wrap = 1;\n     static\
    \ const char my_version[] = ZLIB_VERSION;\n \n-    ushf *overlay;\n-    /* We\
    \ overlay pending_buf and d_buf+l_buf. This works since the average\n-     * output\
    \ size for (length,distance) codes is <= 24 bits.\n-     */\n-\n     if (version\
    \ == Z_NULL || version[0] != my_version[0] ||\n         stream_size != sizeof(z_stream))\
    \ {\n         return Z_VERSION_ERROR;\n@@ -329,9 +324,47 @@ int ZEXPORT deflateInit2_(strm,\
    \ level, method, windowBits, memLevel, strategy,\n \n     s->lit_bufsize = 1 <<\
    \ (memLevel + 6); /* 16K elements by default */\n \n-    overlay = (ushf *) ZALLOC(strm,\
    \ s->lit_bufsize, sizeof(ush)+2);\n-    s->pending_buf = (uchf *) overlay;\n-\
    \    s->pending_buf_size = (ulg)s->lit_bufsize * (sizeof(ush)+2L);\n+    /* We\
    \ overlay pending_buf and sym_buf. This works since the average size\n+     *\
    \ for length/distance pairs over any compressed block is assured to be 31\n+ \
    \    * bits or less.\n+     *\n+     * Analysis: The longest fixed codes are a\
    \ length code of 8 bits plus 5\n+     * extra bits, for lengths 131 to 257. The\
    \ longest fixed distance codes are\n+     * 5 bits plus 13 extra bits, for distances\
    \ 16385 to 32768. The longest\n+     * possible fixed-codes length/distance pair\
    \ is then 31 bits total.\n+     *\n+     * sym_buf starts one-fourth of the way\
    \ into pending_buf. So there are\n+     * three bytes in sym_buf for every four\
    \ bytes in pending_buf. Each symbol\n+     * in sym_buf is three bytes -- two\
    \ for the distance and one for the\n+     * literal/length. As each symbol is\
    \ consumed, the pointer to the next\n+     * sym_buf value to read moves forward\
    \ three bytes. From that symbol, up to\n+     * 31 bits are written to pending_buf.\
    \ The closest the written pending_buf\n+     * bits gets to the next sym_buf symbol\
    \ to read is just before the last\n+     * code is written. At that time, 31*(n-2)\
    \ bits have been written, just\n+     * after 24*(n-2) bits have been consumed\
    \ from sym_buf. sym_buf starts at\n+     * 8*n bits into pending_buf. (Note that\
    \ the symbol buffer fills when n-1\n+     * symbols are written.) The closest\
    \ the writing gets to what is unread is\n+     * then n+14 bits. Here n is lit_bufsize,\
    \ which is 16384 by default, and\n+     * can range from 128 to 32768.\n+    \
    \ *\n+     * Therefore, at a minimum, there are 142 bits of space between what\
    \ is\n+     * written and what is read in the overlain buffers, so the symbols\
    \ cannot\n+     * be overwritten by the compressed data. That space is actually\
    \ 139 bits,\n+     * due to the three-bit fixed-code block header.\n+     *\n\
    +     * That covers the case where either Z_FIXED is specified, forcing fixed\n\
    +     * codes, or when the use of fixed codes is chosen, because that choice\n\
    +     * results in a smaller compressed block than dynamic codes. That latter\n\
    +     * condition then assures that the above analysis also covers all dynamic\n\
    +     * blocks. A dynamic-code block will only be chosen to be emitted if it has\n\
    +     * fewer bits than a fixed-code block would for the same set of symbols.\n\
    +     * Therefore its average symbol length is assured to be less than 31. So\n\
    +     * the compressed data for a dynamic block also cannot overwrite the\n+ \
    \    * symbols from which it is being constructed.\n+     */\n+\n+    s->pending_buf\
    \ = (uchf *) ZALLOC(strm, s->lit_bufsize, 4);\n+    s->pending_buf_size = (ulg)s->lit_bufsize\
    \ * 4;\n \n     if (s->window == Z_NULL || s->prev == Z_NULL || s->head == Z_NULL\
    \ ||\n         s->pending_buf == Z_NULL) {\n@@ -340,8 +373,12 @@ int ZEXPORT deflateInit2_(strm,\
    \ level, method, windowBits, memLevel, strategy,\n         deflateEnd (strm);\n\
    \         return Z_MEM_ERROR;\n     }\n-    s->d_buf = overlay + s->lit_bufsize/sizeof(ush);\n\
    -    s->l_buf = s->pending_buf + (1+sizeof(ush))*s->lit_bufsize;\n+    s->sym_buf\
    \ = s->pending_buf + s->lit_bufsize;\n+    s->sym_end = (s->lit_bufsize - 1) *\
    \ 3;\n+    /* We avoid equality with lit_bufsize*3 because of wraparound at 64K\n\
    +     * on 16 bit machines and because stored blocks are restricted to\n+    \
    \ * 64K-1 bytes.\n+     */\n \n     s->level = level;\n     s->strategy = strategy;\n\
    @@ -552,7 +589,7 @@ int ZEXPORT deflatePrime (strm, bits, value)\n \n     if (deflateStateCheck(strm))\
    \ return Z_STREAM_ERROR;\n     s = strm->state;\n-    if ((Bytef *)(s->d_buf)\
    \ < s->pending_out + ((Buf_size + 7) >> 3))\n+    if (s->sym_buf < s->pending_out\
    \ + ((Buf_size + 7) >> 3))\n         return Z_BUF_ERROR;\n     do {\n        \
    \ put = Buf_size - s->bi_valid;\n@@ -1113,7 +1150,6 @@ int ZEXPORT deflateCopy\
    \ (dest, source)\n #else\n     deflate_state *ds;\n     deflate_state *ss;\n-\
    \    ushf *overlay;\n \n \n     if (deflateStateCheck(source) || dest == Z_NULL)\
    \ {\n@@ -1133,8 +1169,7 @@ int ZEXPORT deflateCopy (dest, source)\n     ds->window\
    \ = (Bytef *) ZALLOC(dest, ds->w_size, 2*sizeof(Byte));\n     ds->prev   = (Posf\
    \ *)  ZALLOC(dest, ds->w_size, sizeof(Pos));\n     ds->head   = (Posf *)  ZALLOC(dest,\
    \ ds->hash_size, sizeof(Pos));\n-    overlay = (ushf *) ZALLOC(dest, ds->lit_bufsize,\
    \ sizeof(ush)+2);\n-    ds->pending_buf = (uchf *) overlay;\n+    ds->pending_buf\
    \ = (uchf *) ZALLOC(dest, ds->lit_bufsize, 4);\n \n     if (ds->window == Z_NULL\
    \ || ds->prev == Z_NULL || ds->head == Z_NULL ||\n         ds->pending_buf ==\
    \ Z_NULL) {\n@@ -1148,8 +1183,7 @@ int ZEXPORT deflateCopy (dest, source)\n  \
    \   zmemcpy(ds->pending_buf, ss->pending_buf, (uInt)ds->pending_buf_size);\n \n\
    \     ds->pending_out = ds->pending_buf + (ss->pending_out - ss->pending_buf);\n\
    -    ds->d_buf = overlay + ds->lit_bufsize/sizeof(ush);\n-    ds->l_buf = ds->pending_buf\
    \ + (1+sizeof(ush))*ds->lit_bufsize;\n+    ds->sym_buf = ds->pending_buf + ds->lit_bufsize;\n\
    \ \n     ds->l_desc.dyn_tree = ds->dyn_ltree;\n     ds->d_desc.dyn_tree = ds->dyn_dtree;\n\
    @@ -1925,7 +1959,7 @@ local block_state deflate_fast(s, flush)\n         FLUSH_BLOCK(s,\
    \ 1);\n         return finish_done;\n     }\n-    if (s->last_lit)\n+    if (s->sym_next)\n\
    \         FLUSH_BLOCK(s, 0);\n     return block_done;\n }\n@@ -2056,7 +2090,7\
    \ @@ local block_state deflate_slow(s, flush)\n         FLUSH_BLOCK(s, 1);\n \
    \        return finish_done;\n     }\n-    if (s->last_lit)\n+    if (s->sym_next)\n\
    \         FLUSH_BLOCK(s, 0);\n     return block_done;\n }\n@@ -2131,7 +2165,7\
    \ @@ local block_state deflate_rle(s, flush)\n         FLUSH_BLOCK(s, 1);\n  \
    \       return finish_done;\n     }\n-    if (s->last_lit)\n+    if (s->sym_next)\n\
    \         FLUSH_BLOCK(s, 0);\n     return block_done;\n }\n@@ -2170,7 +2204,7\
    \ @@ local block_state deflate_huff(s, flush)\n         FLUSH_BLOCK(s, 1);\n \
    \        return finish_done;\n     }\n-    if (s->last_lit)\n+    if (s->sym_next)\n\
    \         FLUSH_BLOCK(s, 0);\n     return block_done;\n }"
  - "--- a/trees.c\n+++ b/trees.c\n@@ -416,7 +416,7 @@ local void init_block(s)\n\
    \ \n     s->dyn_ltree[END_BLOCK].Freq = 1;\n     s->opt_len = s->static_len =\
    \ 0L;\n-    s->last_lit = s->matches = 0;\n+    s->sym_next = s->matches = 0;\n\
    \ }\n \n #define SMALLEST 1\n@@ -948,7 +948,7 @@ void ZLIB_INTERNAL _tr_flush_block(s,\
    \ buf, stored_len, last)\n \n         Tracev((stderr, \"\\nopt %lu(%lu) stat %lu(%lu)\
    \ stored %lu lit %u \",\n                 opt_lenb, s->opt_len, static_lenb, s->static_len,\
    \ stored_len,\n-                s->last_lit));\n+                s->sym_next /\
    \ 3));\n \n         if (static_lenb <= opt_lenb) opt_lenb = static_lenb;\n \n\
    @@ -1017,8 +1017,9 @@ int ZLIB_INTERNAL _tr_tally (s, dist, lc)\n     unsigned\
    \ dist;  /* distance of matched string */\n     unsigned lc;    /* match length-MIN_MATCH\
    \ or unmatched char (if dist==0) */\n {\n-    s->d_buf[s->last_lit] = (ush)dist;\n\
    -    s->l_buf[s->last_lit++] = (uch)lc;\n+    s->sym_buf[s->sym_next++] = dist;\n\
    +    s->sym_buf[s->sym_next++] = dist >> 8;\n+    s->sym_buf[s->sym_next++] =\
    \ lc;\n     if (dist == 0) {\n         /* lc is the unmatched char */\n      \
    \   s->dyn_ltree[lc].Freq++;\n@@ -1033,30 +1034,7 @@ int ZLIB_INTERNAL _tr_tally\
    \ (s, dist, lc)\n         s->dyn_ltree[_length_code[lc]+LITERALS+1].Freq++;\n\
    \         s->dyn_dtree[d_code(dist)].Freq++;\n     }\n-\n-#ifdef TRUNCATE_BLOCK\n\
    -    /* Try to guess if it is profitable to stop the current block here */\n-\
    \    if ((s->last_lit & 0x1fff) == 0 && s->level > 2) {\n-        /* Compute an\
    \ upper bound for the compressed length */\n-        ulg out_length = (ulg)s->last_lit*8L;\n\
    -        ulg in_length = (ulg)((long)s->strstart - s->block_start);\n-       \
    \ int dcode;\n-        for (dcode = 0; dcode < D_CODES; dcode++) {\n-        \
    \    out_length += (ulg)s->dyn_dtree[dcode].Freq *\n-                (5L+extra_dbits[dcode]);\n\
    -        }\n-        out_length >>= 3;\n-        Tracev((stderr,\"\\nlast_lit\
    \ %u, in %ld, out ~%ld(%ld%%) \",\n-               s->last_lit, in_length, out_length,\n\
    -               100L - out_length*100L/in_length));\n-        if (s->matches <\
    \ s->last_lit/2 && out_length < in_length/2) return 1;\n-    }\n-#endif\n-   \
    \ return (s->last_lit == s->lit_bufsize-1);\n-    /* We avoid equality with lit_bufsize\
    \ because of wraparound at 64K\n-     * on 16 bit machines and because stored\
    \ blocks are restricted to\n-     * 64K-1 bytes.\n-     */\n+    return (s->sym_next\
    \ == s->sym_end);\n }\n \n /* ===========================================================================\n\
    @@ -1069,13 +1047,14 @@ local void compress_block(s, ltree, dtree)\n {\n     unsigned\
    \ dist;      /* distance of matched string */\n     int lc;             /* match\
    \ length or unmatched char (if dist == 0) */\n-    unsigned lx = 0;    /* running\
    \ index in l_buf */\n+    unsigned sx = 0;    /* running index in sym_buf */\n\
    \     unsigned code;      /* the code to send */\n     int extra;          /*\
    \ number of extra bits to send */\n \n-    if (s->last_lit != 0) do {\n-     \
    \   dist = s->d_buf[lx];\n-        lc = s->l_buf[lx++];\n+    if (s->sym_next\
    \ != 0) do {\n+        dist = s->sym_buf[sx++] & 0xff;\n+        dist += (unsigned)(s->sym_buf[sx++]\
    \ & 0xff) << 8;\n+        lc = s->sym_buf[sx++];\n         if (dist == 0) {\n\
    \             send_code(s, lc, ltree); /* send a literal byte */\n           \
    \  Tracecv(isgraph(lc), (stderr,\" '%c' \", lc));\n@@ -1100,11 +1079,10 @@ local\
    \ void compress_block(s, ltree, dtree)\n             }\n         } /* literal\
    \ or match pair ? */\n \n-        /* Check that the overlay between pending_buf\
    \ and d_buf+l_buf is ok: */\n-        Assert((uInt)(s->pending) < s->lit_bufsize\
    \ + 2*lx,\n-               \"pendingBuf overflow\");\n+        /* Check that the\
    \ overlay between pending_buf and sym_buf is ok: */\n+        Assert(s->pending\
    \ < s->lit_bufsize + sx, \"pendingBuf overflow\");\n \n-    } while (lx < s->last_lit);\n\
    +    } while (sx < s->sym_next);\n \n     send_code(s, END_BLOCK, ltree);\n }"
  identifiers:
  - CVE-2018-25032
  - CWE-787
  overview: zlib before 1.2.12 allows memory corruption when deflating (i.e., when
    compressing) if the input has many distant matches.
  references:
  - source: cve@mitre.org
    tags:
    - Mailing List
    - Third Party Advisory
    url: http://seclists.org/fulldisclosure/2022/May/33
  - source: cve@mitre.org
    tags:
    - Mailing List
    - Third Party Advisory
    url: http://seclists.org/fulldisclosure/2022/May/35
  - source: cve@mitre.org
    tags:
    - Mailing List
    - Third Party Advisory
    url: http://seclists.org/fulldisclosure/2022/May/38
  - source: cve@mitre.org
    tags:
    - Mailing List
    - Third Party Advisory
    url: http://www.openwall.com/lists/oss-security/2022/03/25/2
  - source: cve@mitre.org
    tags:
    - Exploit
    - Mailing List
    - Third Party Advisory
    url: http://www.openwall.com/lists/oss-security/2022/03/26/1
  - source: cve@mitre.org
    tags:
    - Third Party Advisory
    url: https://cert-portal.siemens.com/productcert/pdf/ssa-333517.pdf
  - source: cve@mitre.org
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/madler/zlib/commit/5c44459c3b28a9bd3283aaceab7c615f8020c531
  - source: cve@mitre.org
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/madler/zlib/compare/v1.2.11...v1.2.12
  - source: cve@mitre.org
    tags:
    - Issue Tracking
    - Patch
    - Third Party Advisory
    url: https://github.com/madler/zlib/issues/605
  - source: cve@mitre.org
    tags:
    - Mailing List
    - Third Party Advisory
    url: https://lists.debian.org/debian-lts-announce/2022/04/msg00000.html
  - source: cve@mitre.org
    tags:
    - Mailing List
    - Third Party Advisory
    url: https://lists.debian.org/debian-lts-announce/2022/05/msg00008.html
  - source: cve@mitre.org
    tags:
    - Mailing List
    - Third Party Advisory
    url: https://lists.debian.org/debian-lts-announce/2022/09/msg00023.html
  - source: cve@mitre.org
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/DCZFIJBJTZ7CL5QXBFKTQ22Q26VINRUF/
  - source: cve@mitre.org
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/DF62MVMH3QUGMBDCB3DY2ERQ6EBHTADB/
  - source: cve@mitre.org
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/JZZPTWRYQULAOL3AW7RZJNVZ2UONXCV4/
  - source: cve@mitre.org
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/NS2D2GFPFGOJUL4WQ3DUAY7HF4VWQ77F/
  - source: cve@mitre.org
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/VOKNP2L734AEL47NRYGVZIKEFOUBQY5Y/
  - source: cve@mitre.org
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/XOKFMSNQ5D5WGMALBNBXU3GE442V74WU/
  - source: cve@mitre.org
    tags:
    - Third Party Advisory
    url: https://security.gentoo.org/glsa/202210-42
  - source: cve@mitre.org
    tags:
    - Third Party Advisory
    url: https://security.netapp.com/advisory/ntap-20220526-0009/
  - source: cve@mitre.org
    tags:
    - Third Party Advisory
    url: https://security.netapp.com/advisory/ntap-20220729-0004/
  - source: cve@mitre.org
    tags:
    - Third Party Advisory
    url: https://support.apple.com/kb/HT213255
  - source: cve@mitre.org
    tags:
    - Third Party Advisory
    url: https://support.apple.com/kb/HT213256
  - source: cve@mitre.org
    tags:
    - Third Party Advisory
    url: https://support.apple.com/kb/HT213257
  - source: cve@mitre.org
    tags:
    - Patch
    - Third Party Advisory
    url: https://www.debian.org/security/2022/dsa-5111
  - source: cve@mitre.org
    tags:
    - Mailing List
    - Third Party Advisory
    url: https://www.openwall.com/lists/oss-security/2022/03/24/1
  - source: cve@mitre.org
    tags:
    - Exploit
    - Mailing List
    - Third Party Advisory
    url: https://www.openwall.com/lists/oss-security/2022/03/28/1
  - source: cve@mitre.org
    tags:
    - Mailing List
    - Third Party Advisory
    url: https://www.openwall.com/lists/oss-security/2022/03/28/3
  - source: cve@mitre.org
    tags:
    - Patch
    - Third Party Advisory
    url: https://www.oracle.com/security-alerts/cpujul2022.html
  title: zlib before 1.2.12 allows memory corruption when deflating (i.e., when compressing)
    if the input has many distant matches.
- diff_content:
  - "--- a/src/vm.c\n+++ b/src/vm.c\n@@ -1394,14 +1394,16 @@ mrb_vm_exec(mrb_state\
    \ *mrb, const struct RProc *proc, const mrb_code *pc)\n         regs[a] = mrb_ary_entry(va,\
    \ mrb_integer(vb));\n         break;\n       case MRB_TT_HASH:\n-        regs[a]\
    \ = mrb_hash_get(mrb, va, vb);\n+        va = mrb_hash_get(mrb, va, vb);\n+  \
    \      regs[a] = va;\n         break;\n       case MRB_TT_STRING:\n         switch\
    \ (mrb_type(vb)) {\n         case MRB_TT_INTEGER:\n         case MRB_TT_STRING:\n\
    \         case MRB_TT_RANGE:\n-          regs[a] = mrb_str_aref(mrb, va, vb, mrb_undef_value());\n\
    +          va = mrb_str_aref(mrb, va, vb, mrb_undef_value());\n+          regs[a]\
    \ = va;\n           break;\n         default:\n           goto getidx_fallback;\n\
    @@ -1423,7 +1425,8 @@ mrb_vm_exec(mrb_state *mrb, const struct RProc *proc, const\
    \ mrb_code *pc)\n     }\n \n     CASE(OP_GETCONST, BB) {\n-      regs[a] = mrb_vm_const_get(mrb,\
    \ syms[b]);\n+      mrb_value v = mrb_vm_const_get(mrb, syms[b]);\n+      regs[a]\
    \ = v;\n       NEXT;\n     }\n \n@@ -1433,7 +1436,8 @@ mrb_vm_exec(mrb_state *mrb,\
    \ const struct RProc *proc, const mrb_code *pc)\n     }\n \n     CASE(OP_GETMCNST,\
    \ BB) {\n-      regs[a] = mrb_const_get(mrb, regs[a], syms[b]);\n+      mrb_value\
    \ v = mrb_const_get(mrb, regs[a], syms[b]);\n+      regs[a] = v;\n       NEXT;\n\
    \     }\n \n@@ -2014,14 +2018,15 @@ mrb_vm_exec(mrb_state *mrb, const struct RProc\
    \ *proc, const mrb_code *pc)\n     CASE(OP_KARG, BB) {\n       mrb_value k = mrb_symbol_value(syms[b]);\n\
    \       mrb_int kidx = mrb_ci_kidx(mrb->c->ci);\n-      mrb_value kdict;\n+  \
    \    mrb_value kdict, v;\n \n       if (kidx < 0 || !mrb_hash_p(kdict=regs[kidx])\
    \ || !mrb_hash_key_p(mrb, kdict, k)) {\n         mrb_value str = mrb_format(mrb,\
    \ \"missing keyword: %v\", k);\n         mrb_exc_set(mrb, mrb_exc_new_str(mrb,\
    \ E_ARGUMENT_ERROR, str));\n         goto L_RAISE;\n       }\n-      regs[a] =\
    \ mrb_hash_get(mrb, kdict, k);\n+      v = mrb_hash_get(mrb, kdict, k);\n+   \
    \   regs[a] = v;\n       mrb_hash_delete_key(mrb, kdict, k);\n       NEXT;\n \
    \    }"
  identifiers:
  - CVE-2022-1071
  - CWE-416
  overview: User after free in mrb_vm_exec in GitHub repository mruby/mruby prior
    to 3.2.
  references:
  - source: security@huntr.dev
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/mruby/mruby/commit/aaa28a508903041dd7399d4159a8ace9766b022f
  - source: security@huntr.dev
    tags:
    - Exploit
    - Patch
    - Third Party Advisory
    url: https://huntr.dev/bounties/6597ece9-07af-415b-809b-919ce0a17cf3
  title: User after free in mrb_vm_exec in GitHub repository mruby/mruby prior to
    3.2.
- diff_content:
  - "--- a/src/vm.c\n+++ b/src/vm.c\n@@ -2819,13 +2819,15 @@ mrb_vm_exec(mrb_state\
    \ *mrb, const struct RProc *proc, const mrb_code *pc)\n     }\n \n     CASE(OP_RANGE_INC,\
    \ B) {\n-      regs[a] = mrb_range_new(mrb, regs[a], regs[a+1], FALSE);\n+   \
    \   mrb_value v = mrb_range_new(mrb, regs[a], regs[a+1], FALSE);\n+      regs[a]\
    \ = v;\n       mrb_gc_arena_restore(mrb, ai);\n       NEXT;\n     }\n \n     CASE(OP_RANGE_EXC,\
    \ B) {\n-      regs[a] = mrb_range_new(mrb, regs[a], regs[a+1], TRUE);\n+    \
    \  mrb_value v = mrb_range_new(mrb, regs[a], regs[a+1], TRUE);\n+      regs[a]\
    \ = v;\n       mrb_gc_arena_restore(mrb, ai);\n       NEXT;\n     }"
  identifiers:
  - CVE-2022-1106
  - CWE-416
  overview: use after free in mrb_vm_exec in GitHub repository mruby/mruby prior to
    3.2.
  references:
  - source: security@huntr.dev
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/mruby/mruby/commit/7f5a490d09f4d56801ac3a3e4e39e03e1471b44c
  - source: security@huntr.dev
    tags:
    - Exploit
    - Patch
    - Third Party Advisory
    url: https://huntr.dev/bounties/16b9d0ea-71ed-41bc-8a88-2deb4c20be8f
  title: use after free in mrb_vm_exec in GitHub repository mruby/mruby prior to 3.2.
- diff_content:
  - "--- a/drivers/hid/hid-elo.c\n+++ b/drivers/hid/hid-elo.c\n@@ -262,6 +262,7 @@\
    \ static int elo_probe(struct hid_device *hdev, const struct hid_device_id *id)\n\
    \ \n \treturn 0;\n err_free:\n+\tusb_put_dev(udev);\n \tkfree(priv);\n \treturn\
    \ ret;\n }"
  identifiers:
  - CVE-2022-27950
  - CWE-401
  overview: In drivers/hid/hid-elo.c in the Linux kernel before 5.16.11, a memory
    leak exists for a certain hid_parse error condition.
  references:
  - source: cve@mitre.org
    tags:
    - Mailing List
    - Patch
    - Vendor Advisory
    url: https://cdn.kernel.org/pub/linux/kernel/v5.x/ChangeLog-5.16.11
  - source: cve@mitre.org
    tags:
    - Mailing List
    - Patch
    - Vendor Advisory
    url: https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=817b8b9c5396d2b2d92311b46719aad5d3339dbe
  - source: cve@mitre.org
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/torvalds/linux/commit/817b8b9c5396d2b2d92311b46719aad5d3339dbe
  - source: cve@mitre.org
    tags:
    - Mailing List
    - Patch
    - Third Party Advisory
    url: https://www.openwall.com/lists/oss-security/2022/03/13/1
  title: In drivers/hid/hid-elo.c in the Linux kernel before 5.16.11, a memory leak
    exists for a certain hid_parse error condition.
- diff_content:
  - "--- a/src/bifs/field_decode.c\n+++ b/src/bifs/field_decode.c\n@@ -205,6 +205,7\
    \ @@ GF_Err gf_bifs_dec_sf_field(GF_BifsDecoder * codec, GF_BitStream *bs, GF_Node\
    \ *n\n \t\tif (sfcb->buffer) {\n \t\t\tgf_free(sfcb->buffer);\n \t\t\tsfcb->buffer\
    \ = NULL;\n+\t\t\tsfcb->bufferSize = 0;\n \t\t}\n \t\twhile (gf_list_count(sfcb->commandList))\
    \ {\n \t\t\tGF_Command *com = (GF_Command*)gf_list_get(sfcb->commandList, 0);"
  identifiers:
  - CVE-2022-1172
  - CWE-476
  overview: Null Pointer Dereference Caused Segmentation Fault in GitHub repository
    gpac/gpac prior to 2.1.0-DEV.
  references:
  - source: security@huntr.dev
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/gpac/gpac/commit/55a183e6b8602369c04ea3836e05436a79fbc7f8
  - source: security@huntr.dev
    tags:
    - Exploit
    - Patch
    - Third Party Advisory
    url: https://huntr.dev/bounties/a26cb79c-9257-4fbf-98c5-a5a331efa264
  title: Null Pointer Dereference Caused Segmentation Fault in GitHub repository gpac/gpac
    prior to 2.1.0-DEV.
- diff_content:
  - "--- a/src/regexp_bt.c\n+++ b/src/regexp_bt.c\n@@ -3360,8 +3360,17 @@ regmatch(\n\
    \ \t\tint\tmark = OPERAND(scan)[0];\n \t\tint\tcmp = OPERAND(scan)[1];\n \t\t\
    pos_T\t*pos;\n+\t\tsize_t\tcol = REG_MULTI ? rex.input - rex.line : 0;\n \n \t\
    \tpos = getmark_buf(rex.reg_buf, mark, FALSE);\n+\n+\t\t// Line may have been\
    \ freed, get it again.\n+\t\tif (REG_MULTI)\n+\t\t{\n+\t\t    rex.line = reg_getline(rex.lnum);\n\
    +\t\t    rex.input = rex.line + col;\n+\t\t}\n+\n \t\tif (pos == NULL\t\t    \
    \ // mark doesn't exist\n \t\t\t|| pos->lnum <= 0)   // mark isn't set in reg_buf\n\
    \ \t\t{"
  - "--- a/src/version.c\n+++ b/src/version.c\n@@ -750,6 +750,8 @@ static char *(features[])\
    \ =\n \n static int included_patches[] =\n {   /* Add new patch number below this\
    \ line */\n+/**/\n+    4646,\n /**/\n     4645,\n /**/"
  identifiers:
  - CVE-2022-1154
  - CWE-416
  overview: Use after free in utf_ptr2char in GitHub repository vim/vim prior to 8.2.4646.
  references:
  - source: security@huntr.dev
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/vim/vim/commit/b55986c52d4cd88a22d0b0b0e8a79547ba13e1d5
  - source: security@huntr.dev
    tags:
    - Exploit
    - Patch
    - Third Party Advisory
    url: https://huntr.dev/bounties/7f0ec6bc-ea0e-45b0-8128-caac72d23425
  - source: security@huntr.dev
    tags:
    - Third Party Advisory
    url: https://lists.debian.org/debian-lts-announce/2022/05/msg00022.html
  - source: security@huntr.dev
    tags:
    - Mailing List
    - Third Party Advisory
    url: https://lists.debian.org/debian-lts-announce/2022/11/msg00009.html
  - source: security@huntr.dev
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/C2CQXRLBIC4S7JQVEIN5QXKQPYWB5E3J/
  - source: security@huntr.dev
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/RAIQTUO35U5WO2NYMY47637EMCVDJRSL/
  - source: security@huntr.dev
    tags:
    - Third Party Advisory
    url: https://security.gentoo.org/glsa/202208-32
  - source: security@huntr.dev
    url: https://security.gentoo.org/glsa/202305-16
  - source: security@huntr.dev
    tags:
    - Third Party Advisory
    url: https://www.oracle.com/security-alerts/cpujul2022.html
  title: Use after free in utf_ptr2char in GitHub repository vim/vim prior to 8.2.4646.
- diff_content:
  - "--- a/src/scriptfile.c\n+++ b/src/scriptfile.c\n@@ -1918,7 +1918,10 @@ get_one_sourceline(source_cookie_T\
    \ *sp)\n \t\tbreak;\t\t    // all the lines are processed\n \t    ga_concat(&ga,\
    \ ((char_u **)sp->buflines.ga_data)[sp->buf_lnum]);\n \t    sp->buf_lnum++;\n\
    +\t    if (ga_grow(&ga, 1) == FAIL)\n+\t\tbreak;\n \t    buf = (char_u *)ga.ga_data;\n\
    +\t    buf[ga.ga_len++] = NUL;\n \t}\n \telse\n \t{"
  - "--- a/src/version.c\n+++ b/src/version.c\n@@ -750,6 +750,8 @@ static char *(features[])\
    \ =\n \n static int included_patches[] =\n {   /* Add new patch number below this\
    \ line */\n+/**/\n+    4647,\n /**/\n     4646,\n /**/"
  identifiers:
  - CVE-2022-1160
  - CWE-122
  overview: heap buffer overflow in get_one_sourceline in GitHub repository vim/vim
    prior to 8.2.4647.
  references:
  - source: security@huntr.dev
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/vim/vim/commit/2bdad6126778f907c0b98002bfebf0e611a3f5db
  - source: security@huntr.dev
    tags:
    - Exploit
    - Patch
    - Third Party Advisory
    url: https://huntr.dev/bounties/a6f3222d-2472-439d-8881-111138a5694c
  - source: security@huntr.dev
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/C2CQXRLBIC4S7JQVEIN5QXKQPYWB5E3J/
  - source: security@huntr.dev
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/RAIQTUO35U5WO2NYMY47637EMCVDJRSL/
  - source: security@huntr.dev
    tags:
    - Third Party Advisory
    url: https://security.gentoo.org/glsa/202208-32
  - source: security@huntr.dev
    url: https://security.gentoo.org/glsa/202305-16
  title: heap buffer overflow in get_one_sourceline in GitHub repository vim/vim prior
    to 8.2.4647.
- diff_content:
  - "--- a/pjlib-util/src/pjlib-util/xml.c\n+++ b/pjlib-util/src/pjlib-util/xml.c\n\
    @@ -150,6 +150,8 @@ static pj_xml_node *xml_parse_node( pj_pool_t *pool, pj_scanner\
    \ *scanner)\n \tpj_scan_get_until_ch(scanner, ']', &node->content);\n \twhile\
    \ (pj_scan_strcmp(scanner, \"]]>\", 3)) {\n \t    pj_str_t dummy;\n+\n+\t    pj_scan_advance_n(scanner,\
    \ 1, PJ_FALSE);\n \t    pj_scan_get_until_ch(scanner, ']', &dummy);\n \t}\n \t\
    node->content.slen = scanner->curptr - node->content.ptr;"
  identifiers:
  - CVE-2022-24763
  - CWE-835
  overview: PJSIP is a free and open source multimedia communication library written
    in the C language. Versions 2.12 and prior contain a denial-of-service vulnerability
    that affects PJSIP users that consume PJSIP's XML parsing in their apps. Users
    are advised to update. There are no known workarounds.
  references:
  - source: security-advisories@github.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/pjsip/pjproject/commit/856f87c2e97a27b256482dbe0d748b1194355a21
  - source: security-advisories@github.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/pjsip/pjproject/security/advisories/GHSA-5x45-qp78-g4p4
  - source: security-advisories@github.com
    tags:
    - Mailing List
    - Third Party Advisory
    url: https://lists.debian.org/debian-lts-announce/2022/05/msg00047.html
  - source: security-advisories@github.com
    tags:
    - Mailing List
    - Third Party Advisory
    url: https://lists.debian.org/debian-lts-announce/2022/11/msg00021.html
  - source: security-advisories@github.com
    tags:
    - Mailing List
    - Third Party Advisory
    url: https://lists.debian.org/debian-lts-announce/2023/08/msg00038.html
  - source: security-advisories@github.com
    tags:
    - Third Party Advisory
    url: https://security.gentoo.org/glsa/202210-37
  - source: security-advisories@github.com
    tags:
    - Third Party Advisory
    url: https://www.debian.org/security/2022/dsa-5285
  title: PJSIP is a free and open source multimedia communication library written
    in the C language. Versions 2.12 and prior contain a denial-of-service vulnerability
    that affects PJSIP users that consume PJSIP's XML parsing in their apps. Users
    are advised to update. There are no known workarounds.
- diff_content:
  - "--- a/libr/anal/p/anal_cris.c\n+++ b/libr/anal/p/anal_cris.c\n@@ -1,4 +1,4 @@\n\
    -/* radare2 - LGPL - Copyright 2014-2015 - pancake */\n+/* radare2 - LGPL - Copyright\
    \ 2014-2022 - pancake */\n \n #include <r_asm.h>\n #include <r_lib.h>\n@@ -7,6\
    \ +7,9 @@ static int analop(RAnal *a, RAnalOp *op, ut64 addr, const ut8 *buf,\
    \ int len, RAn\n \tint opsize = -1;\n \top->type = -1;\n \topsize = 2;\n+\tif\
    \ (len < 1) {\n+\t\treturn -1;\n+\t}\n \tswitch (buf[0]) {\n \tcase 0x3f:\n \t\
    case 0x4f:\n@@ -46,6 +49,9 @@ static int analop(RAnal *a, RAnalOp *op, ut64 addr,\
    \ const ut8 *buf, int len, RAn\n \t\topsize = 6;\n \t\tbreak;\n \tcase 0x00:\n\
    +\t\tif (len < 2) {\n+\t\t\tbreak;\n+\t\t}\n \t\tif (buf[1] == 0x00) {\n \t\t\t\
    op->type = R_ANAL_OP_TYPE_TRAP;\n \t\t} else {\n@@ -57,11 +63,17 @@ static int\
    \ analop(RAnal *a, RAnalOp *op, ut64 addr, const ut8 *buf, int len, RAn\n \t\t\
    }\n \t\tbreak;\n \tcase 0xf0:\n-\t\tif (buf[1]==0xb9) {\n+\t\tif (len < 2) {\n\
    +\t\t\tbreak;\n+\t\t}\n+\t\tif (buf[1] == 0xb9) {\n \t\t\top->type = R_ANAL_OP_TYPE_RET;\n\
    \ \t\t}\n \t\tbreak;\n \tdefault:\n+\t\tif (len < 2) {\n+\t\t\tbreak;\n+\t\t}\n\
    \ \t\tswitch (buf[1]) {\n \t\tcase 0x00:\n \t\t\top->type = R_ANAL_OP_TYPE_CJMP;\
    \ // BCC\n@@ -242,6 +254,7 @@ static bool set_reg_profile(RAnal *anal) {\n \t\t\
    \"=PC\tpc\\n\"\n \t\t\"=SP\tr14\\n\" // XXX\n \t\t\"=BP\tsrp\\n\" // XXX\n+\t\t\
    \"=SN\tr0\\n\"\n \t\t\"=A0\tr0\\n\"\n \t\t\"=A1\tr1\\n\"\n \t\t\"=A2\tr2\\n\""
  identifiers:
  - CVE-2022-1207
  - CWE-125
  overview: Out-of-bounds read in GitHub repository radareorg/radare2 prior to 5.6.8.
    This vulnerability allows attackers to read sensitive information from outside
    the allocated buffer boundary.
  references:
  - source: security@huntr.dev
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/radareorg/radare2/commit/605785b65dd356d46d4487faa41dbf90943b8bc1
  - source: security@huntr.dev
    tags:
    - Exploit
    - Patch
    - Third Party Advisory
    url: https://huntr.dev/bounties/7b979e76-ae54-4132-b455-0833e45195eb
  title: Out-of-bounds read in GitHub repository radareorg/radare2 prior to 5.6.8.
    This vulnerability allows attackers to read sensitive information from outside
    the allocated buffer boundary.
- diff_content:
  - "--- a/src/video/SDL_pixels.c\n+++ b/src/video/SDL_pixels.c\n@@ -947,7 +947,7\
    \ @@ Map1to1(SDL_Palette * src, SDL_Palette * dst, int *identical)\n         }\n\
    \         *identical = 0;\n     }\n-    map = (Uint8 *) SDL_malloc(src->ncolors);\n\
    +    map = (Uint8 *) SDL_calloc(256, sizeof(Uint8));\n     if (map == NULL) {\n\
    \         SDL_OutOfMemory();\n         return (NULL);\n@@ -971,7 +971,7 @@ Map1toN(SDL_PixelFormat\
    \ * src, Uint8 Rmod, Uint8 Gmod, Uint8 Bmod, Uint8 Amod,\n     SDL_Palette *pal\
    \ = src->palette;\n \n     bpp = ((dst->BytesPerPixel == 3) ? 4 : dst->BytesPerPixel);\n\
    -    map = (Uint8 *) SDL_malloc(pal->ncolors * bpp);\n+    map = (Uint8 *) SDL_calloc(256,\
    \ bpp);\n     if (map == NULL) {\n         SDL_OutOfMemory();\n         return\
    \ (NULL);"
  identifiers:
  - CVE-2021-33657
  - CWE-787
  overview: There is a heap overflow problem in video/SDL_pixels.c in SDL (Simple
    DirectMedia Layer) 2.x to 2.0.18 versions. By crafting a malicious .BMP file,
    an attacker can cause the application using this library to crash, denial of service
    or Code execution.
  references:
  - source: securities@openeuler.org
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/libsdl-org/SDL/commit/8c91cf7dba5193f5ce12d06db1336515851c9ee9
  - source: securities@openeuler.org
    url: https://lists.debian.org/debian-lts-announce/2023/02/msg00008.html
  - source: securities@openeuler.org
    url: https://security.gentoo.org/glsa/202305-17
  - source: securities@openeuler.org
    url: https://security.gentoo.org/glsa/202305-18
  title: There is a heap overflow problem in video/SDL_pixels.c in SDL (Simple DirectMedia
    Layer) 2.x to 2.0.18 versions. By crafting a malicious .BMP file, an attacker
    can cause the application using this library to crash, denial of service or Code
    execution.
- diff_content:
  - "--- a/src/vm.c\n+++ b/src/vm.c\n@@ -1749,7 +1749,7 @@ mrb_vm_exec(mrb_state *mrb,\
    \ const struct RProc *proc, const mrb_code *pc)\n       }\n       else if (target_class->tt\
    \ == MRB_TT_MODULE) {\n         target_class = mrb_vm_ci_target_class(ci);\n-\
    \        if (target_class->tt != MRB_TT_ICLASS) {\n+        if (!target_class\
    \ || target_class->tt != MRB_TT_ICLASS) {\n           goto super_typeerror;\n\
    \         }\n       }"
  identifiers:
  - CVE-2022-1201
  - CWE-476
  overview: NULL Pointer Dereference in mrb_vm_exec with super in GitHub repository
    mruby/mruby prior to 3.2. This vulnerability is capable of making the mruby interpreter
    crash, thus affecting the availability of the system.
  references:
  - source: security@huntr.dev
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/mruby/mruby/commit/00acae117da1b45b318dc36531a7b0021b8097ae
  - source: security@huntr.dev
    tags:
    - Exploit
    - Third Party Advisory
    url: https://huntr.dev/bounties/6f930add-c9d8-4870-ae56-d4bd8354703b
  title: NULL Pointer Dereference in mrb_vm_exec with super in GitHub repository mruby/mruby
    prior to 3.2. This vulnerability is capable of making the mruby interpreter crash,
    thus affecting the availability of the system.
- diff_content:
  - "--- a/net/llc/af_llc.c\n+++ b/net/llc/af_llc.c\n@@ -311,6 +311,10 @@ static int\
    \ llc_ui_autobind(struct socket *sock, struct sockaddr_llc *addr)\n \tsock_reset_flag(sk,\
    \ SOCK_ZAPPED);\n \trc = 0;\n out:\n+\tif (rc) {\n+\t\tdev_put_track(llc->dev,\
    \ &llc->dev_tracker);\n+\t\tllc->dev = NULL;\n+\t}\n \treturn rc;\n }\n \n@@ -408,6\
    \ +412,10 @@ static int llc_ui_bind(struct socket *sock, struct sockaddr *uaddr,\
    \ int addrlen)\n out_put:\n \tllc_sap_put(sap);\n out:\n+\tif (rc) {\n+\t\tdev_put_track(llc->dev,\
    \ &llc->dev_tracker);\n+\t\tllc->dev = NULL;\n+\t}\n \trelease_sock(sk);\n \t\
    return rc;\n }"
  identifiers:
  - CVE-2022-28356
  - NVD-CWE-Other
  overview: In the Linux kernel before 5.17.1, a refcount leak bug was found in net/llc/af_llc.c.
  references:
  - source: cve@mitre.org
    tags:
    - Exploit
    - Mailing List
    - Third Party Advisory
    url: http://www.openwall.com/lists/oss-security/2022/04/06/1
  - source: cve@mitre.org
    tags:
    - Patch
    - Release Notes
    - Vendor Advisory
    url: https://cdn.kernel.org/pub/linux/kernel/v5.x/ChangeLog-5.17.1
  - source: cve@mitre.org
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/torvalds/linux/commit/764f4eb6846f5475f1244767d24d25dd86528a4a
  - source: cve@mitre.org
    tags:
    - Mailing List
    - Third Party Advisory
    url: https://lists.debian.org/debian-lts-announce/2022/07/msg00000.html
  - source: cve@mitre.org
    tags:
    - Third Party Advisory
    url: https://security.netapp.com/advisory/ntap-20220506-0006/
  - source: cve@mitre.org
    tags:
    - Third Party Advisory
    url: https://www.debian.org/security/2022/dsa-5127
  - source: cve@mitre.org
    tags:
    - Third Party Advisory
    url: https://www.debian.org/security/2022/dsa-5173
  title: In the Linux kernel before 5.17.1, a refcount leak bug was found in net/llc/af_llc.c.
- diff_content:
  - "--- a/drivers/net/can/usb/usb_8dev.c\n+++ b/drivers/net/can/usb/usb_8dev.c\n\
    @@ -663,9 +663,20 @@ static netdev_tx_t usb_8dev_start_xmit(struct sk_buff *skb,\n\
    \ \tatomic_inc(&priv->active_tx_urbs);\n \n \terr = usb_submit_urb(urb, GFP_ATOMIC);\n\
    -\tif (unlikely(err))\n-\t\tgoto failed;\n-\telse if (atomic_read(&priv->active_tx_urbs)\
    \ >= MAX_TX_URBS)\n+\tif (unlikely(err)) {\n+\t\tcan_free_echo_skb(netdev, context->echo_index,\
    \ NULL);\n+\n+\t\tusb_unanchor_urb(urb);\n+\t\tusb_free_coherent(priv->udev, size,\
    \ buf, urb->transfer_dma);\n+\n+\t\tatomic_dec(&priv->active_tx_urbs);\n+\n+\t\
    \tif (err == -ENODEV)\n+\t\t\tnetif_device_detach(netdev);\n+\t\telse\n+\t\t\t\
    netdev_warn(netdev, \"failed tx_urb %d\\n\", err);\n+\t\tstats->tx_dropped++;\n\
    +\t} else if (atomic_read(&priv->active_tx_urbs) >= MAX_TX_URBS)\n \t\t/* Slow\
    \ down tx path */\n \t\tnetif_stop_queue(netdev);\n \n@@ -684,19 +695,6 @@ static\
    \ netdev_tx_t usb_8dev_start_xmit(struct sk_buff *skb,\n \n \treturn NETDEV_TX_BUSY;\n\
    \ \n-failed:\n-\tcan_free_echo_skb(netdev, context->echo_index, NULL);\n-\n-\t\
    usb_unanchor_urb(urb);\n-\tusb_free_coherent(priv->udev, size, buf, urb->transfer_dma);\n\
    -\n-\tatomic_dec(&priv->active_tx_urbs);\n-\n-\tif (err == -ENODEV)\n-\t\tnetif_device_detach(netdev);\n\
    -\telse\n-\t\tnetdev_warn(netdev, \"failed tx_urb %d\\n\", err);\n-\n nomembuf:\n\
    \ \tusb_free_urb(urb);\n "
  identifiers:
  - CVE-2022-28388
  - CWE-415
  overview: usb_8dev_start_xmit in drivers/net/can/usb/usb_8dev.c in the Linux kernel
    through 5.17.1 has a double free.
  references:
  - source: cve@mitre.org
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/torvalds/linux/commit/3d3925ff6433f98992685a9679613a2cc97f3ce2
  - source: cve@mitre.org
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/6IHHC455LMSJNG4CSZ5CEAHYWY2DE5YW/
  - source: cve@mitre.org
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/LAWC35TO642FOP3UCA3C6IF7NAUFOVZ6/
  - source: cve@mitre.org
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/XFMPUI3WI4U2F7ONHRW36WDY4ZE7LGGT/
  - source: cve@mitre.org
    tags:
    - Third Party Advisory
    url: https://security.netapp.com/advisory/ntap-20220513-0001/
  - source: cve@mitre.org
    tags:
    - Third Party Advisory
    url: https://www.debian.org/security/2022/dsa-5127
  - source: cve@mitre.org
    tags:
    - Third Party Advisory
    url: https://www.debian.org/security/2022/dsa-5173
  title: usb_8dev_start_xmit in drivers/net/can/usb/usb_8dev.c in the Linux kernel
    through 5.17.1 has a double free.
- diff_content:
  - "--- a/drivers/net/can/usb/mcba_usb.c\n+++ b/drivers/net/can/usb/mcba_usb.c\n\
    @@ -364,7 +364,6 @@ static netdev_tx_t mcba_usb_start_xmit(struct sk_buff *skb,\n\
    \ xmit_failed:\n \tcan_free_echo_skb(priv->netdev, ctx->ndx, NULL);\n \tmcba_usb_free_ctx(ctx);\n\
    -\tdev_kfree_skb(skb);\n \tstats->tx_dropped++;\n \n \treturn NETDEV_TX_OK;"
  identifiers:
  - CVE-2022-28389
  - CWE-415
  overview: mcba_usb_start_xmit in drivers/net/can/usb/mcba_usb.c in the Linux kernel
    through 5.17.1 has a double free.
  references:
  - source: cve@mitre.org
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/torvalds/linux/commit/04c9b00ba83594a29813d6b1fb8fdc93a3915174
  - source: cve@mitre.org
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/6IHHC455LMSJNG4CSZ5CEAHYWY2DE5YW/
  - source: cve@mitre.org
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/LAWC35TO642FOP3UCA3C6IF7NAUFOVZ6/
  - source: cve@mitre.org
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/XFMPUI3WI4U2F7ONHRW36WDY4ZE7LGGT/
  - source: cve@mitre.org
    tags:
    - Third Party Advisory
    url: https://security.netapp.com/advisory/ntap-20220513-0001/
  - source: cve@mitre.org
    tags:
    - Third Party Advisory
    url: https://www.debian.org/security/2022/dsa-5127
  - source: cve@mitre.org
    tags:
    - Third Party Advisory
    url: https://www.debian.org/security/2022/dsa-5173
  title: mcba_usb_start_xmit in drivers/net/can/usb/mcba_usb.c in the Linux kernel
    through 5.17.1 has a double free.
- diff_content:
  - "--- a/drivers/net/can/usb/ems_usb.c\n+++ b/drivers/net/can/usb/ems_usb.c\n@@\
    \ -819,7 +819,6 @@ static netdev_tx_t ems_usb_start_xmit(struct sk_buff *skb,\
    \ struct net_device *ne\n \n \t\tusb_unanchor_urb(urb);\n \t\tusb_free_coherent(dev->udev,\
    \ size, buf, urb->transfer_dma);\n-\t\tdev_kfree_skb(skb);\n \n \t\tatomic_dec(&dev->active_tx_urbs);\n\
    \ "
  identifiers:
  - CVE-2022-28390
  - CWE-415
  overview: ems_usb_start_xmit in drivers/net/can/usb/ems_usb.c in the Linux kernel
    through 5.17.1 has a double free.
  references:
  - source: cve@mitre.org
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/torvalds/linux/commit/c70222752228a62135cee3409dccefd494a24646
  - source: cve@mitre.org
    tags:
    - Mailing List
    - Third Party Advisory
    url: https://lists.debian.org/debian-lts-announce/2022/07/msg00000.html
  - source: cve@mitre.org
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/6IHHC455LMSJNG4CSZ5CEAHYWY2DE5YW/
  - source: cve@mitre.org
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/LAWC35TO642FOP3UCA3C6IF7NAUFOVZ6/
  - source: cve@mitre.org
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/XFMPUI3WI4U2F7ONHRW36WDY4ZE7LGGT/
  - source: cve@mitre.org
    tags:
    - Third Party Advisory
    url: https://security.netapp.com/advisory/ntap-20220513-0001/
  - source: cve@mitre.org
    tags:
    - Third Party Advisory
    url: https://www.debian.org/security/2022/dsa-5127
  - source: cve@mitre.org
    tags:
    - Third Party Advisory
    url: https://www.debian.org/security/2022/dsa-5173
  title: ems_usb_start_xmit in drivers/net/can/usb/ems_usb.c in the Linux kernel through
    5.17.1 has a double free.
- diff_content:
  - "--- a/main.c\n+++ b/main.c\n@@ -26,6 +26,7 @@\n #include \"wlr-input-inhibitor-unstable-v1-client-protocol.h\"\
    \n #include \"wlr-layer-shell-unstable-v1-client-protocol.h\"\n #include \"xdg-output-unstable-v1-client-protocol.h\"\
    \n+#include \"ext-session-lock-v1-client-protocol.h\"\n \n static uint32_t parse_color(const\
    \ char *color) {\n \tif (color[0] == '#') {\n@@ -97,6 +98,9 @@ static void destroy_surface(struct\
    \ swaylock_surface *surface) {\n \tif (surface->layer_surface != NULL) {\n \t\t\
    zwlr_layer_surface_v1_destroy(surface->layer_surface);\n \t}\n+\tif (surface->ext_session_lock_surface_v1\
    \ != NULL) {\n+\t\text_session_lock_surface_v1_destroy(surface->ext_session_lock_surface_v1);\n\
    +\t}\n \tif (surface->surface != NULL) {\n \t\twl_surface_destroy(surface->surface);\n\
    \ \t}\n@@ -109,6 +113,7 @@ static void destroy_surface(struct swaylock_surface\
    \ *surface) {\n }\n \n static const struct zwlr_layer_surface_v1_listener layer_surface_listener;\n\
    +static const struct ext_session_lock_surface_v1_listener ext_session_lock_surface_v1_listener;\n\
    \ \n static cairo_surface_t *select_image(struct swaylock_state *state,\n \t\t\
    struct swaylock_surface *surface);\n@@ -120,7 +125,7 @@ static bool surface_is_opaque(struct\
    \ swaylock_surface *surface) {\n \treturn (surface->state->args.colors.background\
    \ & 0xff) == 0xff;\n }\n \n-static void create_layer_surface(struct swaylock_surface\
    \ *surface) {\n+static void create_surface(struct swaylock_surface *surface) {\n\
    \ \tstruct swaylock_state *state = surface->state;\n \n \tsurface->image = select_image(state,\
    \ surface);\n@@ -134,22 +139,28 @@ static void create_layer_surface(struct swaylock_surface\
    \ *surface) {\n \tassert(surface->subsurface);\n \twl_subsurface_set_sync(surface->subsurface);\n\
    \ \n-\tsurface->layer_surface = zwlr_layer_shell_v1_get_layer_surface(\n-\t\t\t\
    state->layer_shell, surface->surface, surface->output,\n-\t\t\tZWLR_LAYER_SHELL_V1_LAYER_OVERLAY,\
    \ \"lockscreen\");\n-\tassert(surface->layer_surface);\n-\n-\tzwlr_layer_surface_v1_set_size(surface->layer_surface,\
    \ 0, 0);\n-\tzwlr_layer_surface_v1_set_anchor(surface->layer_surface,\n-\t\t\t\
    ZWLR_LAYER_SURFACE_V1_ANCHOR_TOP |\n-\t\t\tZWLR_LAYER_SURFACE_V1_ANCHOR_RIGHT\
    \ |\n-\t\t\tZWLR_LAYER_SURFACE_V1_ANCHOR_BOTTOM |\n-\t\t\tZWLR_LAYER_SURFACE_V1_ANCHOR_LEFT);\n\
    -\tzwlr_layer_surface_v1_set_exclusive_zone(surface->layer_surface, -1);\n-\t\
    zwlr_layer_surface_v1_set_keyboard_interactivity(\n-\t\t\tsurface->layer_surface,\
    \ true);\n-\tzwlr_layer_surface_v1_add_listener(surface->layer_surface,\n-\t\t\
    \t&layer_surface_listener, surface);\n+\tif (state->ext_session_lock_v1) {\n+\t\
    \tsurface->ext_session_lock_surface_v1 = ext_session_lock_v1_get_lock_surface(\n\
    +\t\t\t\tstate->ext_session_lock_v1, surface->surface, surface->output);\n+\t\t\
    ext_session_lock_surface_v1_add_listener(surface->ext_session_lock_surface_v1,\n\
    +\t\t\t\t&ext_session_lock_surface_v1_listener, surface);\n+\t} else {\n+\t\t\
    surface->layer_surface = zwlr_layer_shell_v1_get_layer_surface(\n+\t\t\t\tstate->layer_shell,\
    \ surface->surface, surface->output,\n+\t\t\t\tZWLR_LAYER_SHELL_V1_LAYER_OVERLAY,\
    \ \"lockscreen\");\n+\n+\t\tzwlr_layer_surface_v1_set_size(surface->layer_surface,\
    \ 0, 0);\n+\t\tzwlr_layer_surface_v1_set_anchor(surface->layer_surface,\n+\t\t\
    \t\tZWLR_LAYER_SURFACE_V1_ANCHOR_TOP |\n+\t\t\t\tZWLR_LAYER_SURFACE_V1_ANCHOR_RIGHT\
    \ |\n+\t\t\t\tZWLR_LAYER_SURFACE_V1_ANCHOR_BOTTOM |\n+\t\t\t\tZWLR_LAYER_SURFACE_V1_ANCHOR_LEFT);\n\
    +\t\tzwlr_layer_surface_v1_set_exclusive_zone(surface->layer_surface, -1);\n+\t\
    \tzwlr_layer_surface_v1_set_keyboard_interactivity(\n+\t\t\t\tsurface->layer_surface,\
    \ true);\n+\t\tzwlr_layer_surface_v1_add_listener(surface->layer_surface,\n+\t\
    \t\t\t&layer_surface_listener, surface);\n+\t}\n \n \tif (surface_is_opaque(surface)\
    \ &&\n \t\t\tsurface->state->args.mode != BACKGROUND_MODE_CENTER &&\n@@ -161,7\
    \ +172,9 @@ static void create_layer_surface(struct swaylock_surface *surface)\
    \ {\n \t\twl_region_destroy(region);\n \t}\n \n-\twl_surface_commit(surface->surface);\n\
    +\tif (!state->ext_session_lock_v1) {\n+\t\twl_surface_commit(surface->surface);\n\
    +\t}\n }\n \n static void layer_surface_configure(void *data,\n@@ -188,6 +201,23\
    \ @@ static const struct zwlr_layer_surface_v1_listener layer_surface_listener\
    \ = {\n \t.closed = layer_surface_closed,\n };\n \n+static void ext_session_lock_surface_v1_handle_configure(void\
    \ *data,\n+\t\tstruct ext_session_lock_surface_v1 *lock_surface, uint32_t serial,\n\
    +\t\tuint32_t width, uint32_t height) {\n+\tstruct swaylock_surface *surface =\
    \ data;\n+\tsurface->width = width;\n+\tsurface->height = height;\n+\tsurface->indicator_width\
    \ = 0;\n+\tsurface->indicator_height = 0;\n+\text_session_lock_surface_v1_ack_configure(lock_surface,\
    \ serial);\n+\trender_frame_background(surface);\n+\trender_frame(surface);\n\
    +}\n+\n+static const struct ext_session_lock_surface_v1_listener ext_session_lock_surface_v1_listener\
    \ = {\n+\t.configure = ext_session_lock_surface_v1_handle_configure,\n+};\n+\n\
    \ static const struct wl_callback_listener surface_frame_listener;\n \n static\
    \ void surface_frame_handle_done(void *data, struct wl_callback *callback,\n@@\
    \ -302,6 +332,21 @@ struct zxdg_output_v1_listener _xdg_output_listener = {\n\
    \ \t.description = handle_xdg_output_description,\n };\n \n+static void ext_session_lock_v1_handle_locked(void\
    \ *data, struct ext_session_lock_v1 *lock) {\n+\t// Who cares\n+}\n+\n+static\
    \ void ext_session_lock_v1_handle_finished(void *data, struct ext_session_lock_v1\
    \ *lock) {\n+\tswaylock_log(LOG_ERROR, \"Failed to lock session -- \"\n+\t\t\t\
    \"is another lockscreen running?\");\n+\texit(2);\n+}\n+\n+static const struct\
    \ ext_session_lock_v1_listener ext_session_lock_v1_listener = {\n+\t.locked =\
    \ ext_session_lock_v1_handle_locked,\n+\t.finished = ext_session_lock_v1_handle_finished,\n\
    +};\n+\n static void handle_global(void *data, struct wl_registry *registry,\n\
    \ \t\tuint32_t name, const char *interface, uint32_t version) {\n \tstruct swaylock_state\
    \ *state = data;\n@@ -341,9 +386,12 @@ static void handle_global(void *data, struct\
    \ wl_registry *registry,\n \t\twl_list_insert(&state->surfaces, &surface->link);\n\
    \ \n \t\tif (state->run_display) {\n-\t\t\tcreate_layer_surface(surface);\n+\t\
    \t\tcreate_surface(surface);\n \t\t\twl_display_roundtrip(state->display);\n \t\
    \t}\n+\t} else if (strcmp(interface, ext_session_lock_manager_v1_interface.name)\
    \ == 0) {\n+\t\tstate->ext_session_lock_manager_v1 = wl_registry_bind(registry,\
    \ name,\n+\t\t\t\t&ext_session_lock_manager_v1_interface, 1);\n \t}\n }\n \n@@\
    \ -1182,20 +1230,34 @@ int main(int argc, char **argv) {\n \tstruct wl_registry\
    \ *registry = wl_display_get_registry(state.display);\n \twl_registry_add_listener(registry,\
    \ &registry_listener, &state);\n \twl_display_roundtrip(state.display);\n-\tassert(state.compositor\
    \ && state.layer_shell && state.shm);\n-\tif (!state.input_inhibit_manager) {\n\
    -\t\tfree(state.args.font);\n-\t\tswaylock_log(LOG_ERROR, \"Compositor does not\
    \ support the input \"\n-\t\t\t\t\"inhibitor protocol, refusing to run insecurely\"\
    );\n+\n+\tif (!state.compositor || !state.shm) {\n+\t\tswaylock_log(LOG_ERROR,\
    \ \"Missing wl_compositor or wl_shm\");\n+\t\treturn 1;\n+\t}\n+\n+\tif (state.ext_session_lock_manager_v1)\
    \ {\n+\t\tswaylock_log(LOG_DEBUG, \"Using ext-session-lock-v1\");\n+\t\tstate.ext_session_lock_v1\
    \ = ext_session_lock_manager_v1_lock(state.ext_session_lock_manager_v1);\n+\t\t\
    ext_session_lock_v1_add_listener(state.ext_session_lock_v1,\n+\t\t\t\t&ext_session_lock_v1_listener,\
    \ &state);\n+\t} else if (state.layer_shell && state.input_inhibit_manager) {\n\
    +\t\tswaylock_log(LOG_DEBUG, \"Using wlr-layer-shell + wlr-input-inhibitor\");\n\
    +\t\tzwlr_input_inhibit_manager_v1_get_inhibitor(state.input_inhibit_manager);\n\
    +\t} else {\n+\t\tswaylock_log(LOG_ERROR, \"Missing ext-session-lock-v1, wlr-layer-shell\
    \ \"\n+\t\t\t\t\"and wlr-input-inhibitor\");\n \t\treturn 1;\n \t}\n \n-\tzwlr_input_inhibit_manager_v1_get_inhibitor(state.input_inhibit_manager);\n\
    \ \tif (wl_display_roundtrip(state.display) == -1) {\n \t\tfree(state.args.font);\n\
    -\t\tswaylock_log(LOG_ERROR, \"Exiting - failed to inhibit input:\"\n-\t\t\t\t\
    \" is another lockscreen already running?\");\n-\t\treturn 2;\n+\t\tif (state.input_inhibit_manager)\
    \ {\n+\t\t\tswaylock_log(LOG_ERROR, \"Exiting - failed to inhibit input:\"\n+\t\
    \t\t\t\t\" is another lockscreen already running?\");\n+\t\t\treturn 2;\n+\t\t\
    }\n+\t\treturn 1;\n \t}\n \n \tif (state.zxdg_output_manager) {\n@@ -1214,7 +1276,7\
    \ @@ int main(int argc, char **argv) {\n \n \tstruct swaylock_surface *surface;\n\
    \ \twl_list_for_each(surface, &state.surfaces, link) {\n-\t\tcreate_layer_surface(surface);\n\
    +\t\tcreate_surface(surface);\n \t}\n \n \tif (state.args.daemonize) {\n@@ -1237,6\
    \ +1299,11 @@ int main(int argc, char **argv) {\n \t\tloop_poll(state.eventloop);\n\
    \ \t}\n \n+\tif (state.ext_session_lock_v1) {\n+\t\text_session_lock_v1_unlock_and_destroy(state.ext_session_lock_v1);\n\
    +\t\twl_display_flush(state.display);\n+\t}\n+\n \tfree(state.args.font);\n \t\
    return 0;\n }"
  identifiers:
  - CVE-2022-26530
  - NVD-CWE-noinfo
  overview: swaylock before 1.6 allows attackers to trigger a crash and achieve unlocked
    access to a Wayland compositor.
  references:
  - source: cve@mitre.org
    tags:
    - Issue Tracking
    - Third Party Advisory
    url: https://bugzilla.redhat.com/show_bug.cgi?id=2066596
  - source: cve@mitre.org
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/swaywm/swaylock/commit/1d1c75b6316d21933069a9d201f966d84099f6ca
  - source: cve@mitre.org
    tags:
    - Issue Tracking
    - Patch
    - Third Party Advisory
    url: https://github.com/swaywm/swaylock/pull/219
  title: swaylock before 1.6 allows attackers to trigger a crash and achieve unlocked
    access to a Wayland compositor.
- diff_content:
  - "--- a/src/media_tools/avilib.c\n+++ b/src/media_tools/avilib.c\n@@ -1884,8 +1884,8\
    \ @@ avi_t *AVI_open_fd(FILE *fd, int getIndex)\n \n int avi_parse_input_file(avi_t\
    \ *AVI, int getIndex)\n {\n-\tint i, rate, scale, idx_type;\n-\ts64 n;\n+\tint\
    \ rate, scale, idx_type;\n+\ts64 n, i;\n \tunsigned char *hdrl_data;\n \tu64 header_offset=0;\n\
    \ \tint hdrl_len=0;\n@@ -1939,6 +1939,7 @@ int avi_parse_input_file(avi_t *AVI,\
    \ int getIndex)\n \t\t\t\tn -= 4;\n \t\t\tif(strnicmp(data,\"hdrl\",4) == 0)\n\
    \ \t\t\t{\n+\t\t\t\tif (n>0xFFFFFFFF) ERR_EXIT(AVI_ERR_READ)\n \t\t\t\thdrl_len\
    \ = (u32) n;\n \t\t\t\thdrl_data = (unsigned char *) gf_malloc((u32)n);\n \t\t\
    \t\tif(hdrl_data==0) ERR_EXIT(AVI_ERR_NO_MEM);\n@@ -2091,8 +2092,10 @@ int avi_parse_input_file(avi_t\
    \ *AVI, int getIndex)\n \t\t\t\t\t\tAVI->compressor2[4] = 0;\n \n \t\t\t\t\t\t\
    if (n>40) {\n+\t\t\t\t\t\t\tif (n>0xFFFFFFFF) ERR_EXIT(AVI_ERR_READ)\n \t\t\t\t\
    \t\t\tAVI->extradata_size = (u32) (n - 40);\n \t\t\t\t\t\t\tAVI->extradata = gf_malloc(sizeof(u8)*\
    \ AVI->extradata_size);\n+\t\t\t\t\t\t\tif (!AVI->extradata) ERR_EXIT(AVI_ERR_NO_MEM)\n\
    \ \t\t\t\t\t\t\tmemcpy(AVI->extradata, hdrl_data + i + 40, AVI->extradata_size);\n\
    \ \t\t\t\t\t\t}\n "
  identifiers:
  - CVE-2022-1222
  - CWE-835
  overview: Inf loop in GitHub repository gpac/gpac prior to 2.1.0-DEV.
  references:
  - source: security@huntr.dev
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/gpac/gpac/commit/7f060bbb72966cae80d6fee338d0b07fa3fc06e1
  - source: security@huntr.dev
    tags:
    - Exploit
    - Issue Tracking
    - Third Party Advisory
    url: https://huntr.dev/bounties/f8cb85b8-7ff3-47f1-a9a6-7080eb371a3d
  - source: security@huntr.dev
    url: https://www.debian.org/security/2023/dsa-5411
  title: Inf loop in GitHub repository gpac/gpac prior to 2.1.0-DEV.
- diff_content:
  - "--- a/src/exec.c\n+++ b/src/exec.c\n@@ -304,8 +304,8 @@ crun_command_exec (struct\
    \ crun_global_arguments *global_args, int argc, char **a\n           capabilities->effective\
    \ = exec_options.cap;\n           capabilities->effective_len = exec_options.cap_size;\n\
    \ \n-          capabilities->inheritable = dup_array (exec_options.cap, exec_options.cap_size);\n\
    -          capabilities->inheritable_len = exec_options.cap_size;\n+         \
    \ capabilities->inheritable = NULL;\n+          capabilities->inheritable_len\
    \ = 0;\n \n           capabilities->bounding = dup_array (exec_options.cap, exec_options.cap_size);\n\
    \           capabilities->bounding_len = exec_options.cap_size;"
  identifiers:
  - CVE-2022-27650
  - CWE-276
  overview: A flaw was found in crun where containers were incorrectly started with
    non-empty default permissions. A vulnerability was found in Moby (Docker Engine)
    where containers were started incorrectly with non-empty inheritable Linux process
    capabilities. This flaw allows an attacker with access to programs with inheritable
    file capabilities to elevate those capabilities to the permitted set when execve(2)
    runs.
  references:
  - source: secalert@redhat.com
    tags:
    - Issue Tracking
    - Third Party Advisory
    url: https://bugzilla.redhat.com/show_bug.cgi?id=2066845
  - source: secalert@redhat.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/containers/crun/commit/1aeeed2e4fdeffb4875c0d0b439915894594c8c6
  - source: secalert@redhat.com
    tags:
    - Third Party Advisory
    url: https://github.com/containers/crun/security/advisories/GHSA-wr4f-w546-m398
  - source: secalert@redhat.com
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/HYIGABCZ7ZHAG2XCOGITTQRJU2ASWMFA/
  title: A flaw was found in crun where containers were incorrectly started with non-empty
    default permissions. A vulnerability was found in Moby (Docker Engine) where containers
    were started incorrectly with non-empty inheritable Linux process capabilities.
    This flaw allows an attacker with access to programs with inheritable file capabilities
    to elevate those capabilities to the permitted set when execve(2) runs.
- diff_content:
  - "--- a/lib/sbi/message.c\n+++ b/lib/sbi/message.c\n@@ -924,7 +924,7 @@ static\
    \ int parse_json(ogs_sbi_message_t *message,\n     ogs_log_print(OGS_LOG_TRACE,\
    \ \"%s\", json);\n     item = cJSON_Parse(json);\n     if (!item) {\n-       \
    \ ogs_error(\"JSON parse error\");\n+        ogs_error(\"JSON parse error [%s]\"\
    , json);\n         return OGS_ERROR;\n     }\n \n@@ -1833,18 +1833,16 @@ static\
    \ int on_header_value(\n     data = multipart_parser_get_data(parser);\n     ogs_assert(data);\n\
    \ \n-    if (at && length) {\n+    if (data->num_of_part < OGS_SBI_MAX_NUM_OF_PART\
    \ && at && length) {\n         SWITCH(data->header_field)\n         CASE(OGS_SBI_CONTENT_TYPE)\n\
    -            if (data->part[data->num_of_part].content_type)\n-              \
    \  ogs_free(data->part[data->num_of_part].content_type);\n+            ogs_assert(data->part[data->num_of_part].content_type\
    \ == NULL);\n             data->part[data->num_of_part].content_type =\n     \
    \            ogs_strndup(at, length);\n             ogs_assert(data->part[data->num_of_part].content_type);\n\
    \             break;\n         CASE(OGS_SBI_CONTENT_ID)\n-            if (data->part[data->num_of_part].content_id)\n\
    -                ogs_free(data->part[data->num_of_part].content_id);\n+      \
    \      ogs_assert(data->part[data->num_of_part].content_id == NULL);\n       \
    \      data->part[data->num_of_part].content_id =\n                 ogs_strndup(at,\
    \ length);\n             ogs_assert(data->part[data->num_of_part].content_id);\n\
    @@ -1867,7 +1865,7 @@ static int on_part_data(\n     data = multipart_parser_get_data(parser);\n\
    \     ogs_assert(data);\n \n-    if (at && length) {\n+    if (data->num_of_part\
    \ < OGS_SBI_MAX_NUM_OF_PART && at && length) {\n         SWITCH(data->part[data->num_of_part].content_type)\n\
    \         CASE(OGS_SBI_CONTENT_JSON_TYPE)\n         CASE(OGS_SBI_CONTENT_5GNAS_TYPE)\n\
    @@ -1901,9 +1899,9 @@ static int on_part_data(\n             break;\n \n     \
    \    DEFAULT\n-            ogs_log_hexdump(OGS_LOG_FATAL, (unsigned char *)at,\
    \ length);\n             ogs_error(\"Unknown content_type [%s]\",\n          \
    \           data->part[data->num_of_part].content_type);\n+            ogs_log_hexdump(OGS_LOG_ERROR,\
    \ (unsigned char *)at, length);\n         END\n     }\n     return 0;\n@@ -1917,7\
    \ +1915,9 @@ static int on_part_data_end(multipart_parser *parser)\n     data\
    \ = multipart_parser_get_data(parser);\n     ogs_assert(data);\n \n-    data->num_of_part++;\n\
    +    if (data->num_of_part < OGS_SBI_MAX_NUM_OF_PART) {\n+        data->num_of_part++;\n\
    +    }\n \n     return 0;\n }\n@@ -1967,6 +1967,11 @@ static int parse_multipart(\n\
    \     multipart_parser_free(parser);\n     ogs_free(boundary);\n \n+    if (data.num_of_part\
    \ > OGS_SBI_MAX_NUM_OF_PART) {\n+        /* Overflow Issues #1247 */\n+      \
    \  ogs_fatal(\"Overflow num_of_part[%d]\", data.num_of_part);\n+        ogs_assert_if_reached();\n\
    +    }\n     for (i = 0; i < data.num_of_part; i++) {\n         SWITCH(data.part[i].content_type)\n\
    \         CASE(OGS_SBI_CONTENT_JSON_TYPE)"
  - "--- a/src/amf/namf-handler.c\n+++ b/src/amf/namf-handler.c\n@@ -53,6 +53,8 @@\
    \ int amf_namf_comm_handle_n1_n2_message_transfer(\n     OpenAPI_n2_info_content_t\
    \ *n2InfoContent = NULL;\n     OpenAPI_ref_to_binary_data_t *ngapData = NULL;\n\
    \ \n+    OpenAPI_ngap_ie_type_e ngapIeType = OpenAPI_ngap_ie_type_NULL;\n+\n \
    \    ogs_assert(stream);\n     ogs_assert(recvmsg);\n \n@@ -117,12 +119,15 @@\
    \ int amf_namf_comm_handle_n1_n2_message_transfer(\n             ogs_error(\"\
    No smInfo\");\n             return OGS_ERROR;\n         }\n+\n         n2InfoContent\
    \ = smInfo->n2_info_content;\n         if (!n2InfoContent) {\n             ogs_error(\"\
    No n2InfoContent\");\n             return OGS_ERROR;\n         }\n \n+       \
    \ ngapIeType = n2InfoContent->ngap_ie_type;\n+\n         ngapData = n2InfoContent->ngap_data;\n\
    \         if (!ngapData || !ngapData->content_id) {\n             ogs_error(\"\
    No ngapData\");\n@@ -153,7 +158,7 @@ int amf_namf_comm_handle_n1_n2_message_transfer(\n\
    \ \n     sendmsg.N1N2MessageTransferRspData = &N1N2MessageTransferRspData;\n \n\
    -    switch (n2InfoContent->ngap_ie_type) {\n+    switch (ngapIeType) {\n    \
    \ case OpenAPI_ngap_ie_type_PDU_RES_SETUP_REQ:\n         if (!n2buf) {\n     \
    \        ogs_error(\"[%s] No N2 SM Content\", amf_ue->supi);\n@@ -390,8 +395,7\
    \ @@ int amf_namf_comm_handle_n1_n2_message_transfer(\n         break;\n \n  \
    \   default:\n-        ogs_error(\"Not implemented ngap_ie_type[%d]\",\n-    \
    \            n2InfoContent->ngap_ie_type);\n+        ogs_error(\"Not implemented\
    \ ngapIeType[%d]\", ngapIeType);\n         ogs_assert_if_reached();\n     }\n "
  identifiers:
  - CVE-2021-44108
  - CWE-476
  overview: A null pointer dereference in src/amf/namf-handler.c in Open5GS 2.3.6
    and earlier allows remote attackers to Denial of Service via a crafted sbi request
    to amf.
  references:
  - source: cve@mitre.org
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/open5gs/open5gs/commit/d919b2744cd05abae043490f0a3dd1946c1ccb8c
  - source: cve@mitre.org
    tags:
    - Exploit
    - Issue Tracking
    - Third Party Advisory
    url: https://github.com/open5gs/open5gs/issues/1247
  title: A null pointer dereference in src/amf/namf-handler.c in Open5GS 2.3.6 and
    earlier allows remote attackers to Denial of Service via a crafted sbi request
    to amf.
- diff_content:
  - "--- a/lib/sbi/message.c\n+++ b/lib/sbi/message.c\n@@ -924,7 +924,7 @@ static\
    \ int parse_json(ogs_sbi_message_t *message,\n     ogs_log_print(OGS_LOG_TRACE,\
    \ \"%s\", json);\n     item = cJSON_Parse(json);\n     if (!item) {\n-       \
    \ ogs_error(\"JSON parse error\");\n+        ogs_error(\"JSON parse error [%s]\"\
    , json);\n         return OGS_ERROR;\n     }\n \n@@ -1833,18 +1833,16 @@ static\
    \ int on_header_value(\n     data = multipart_parser_get_data(parser);\n     ogs_assert(data);\n\
    \ \n-    if (at && length) {\n+    if (data->num_of_part < OGS_SBI_MAX_NUM_OF_PART\
    \ && at && length) {\n         SWITCH(data->header_field)\n         CASE(OGS_SBI_CONTENT_TYPE)\n\
    -            if (data->part[data->num_of_part].content_type)\n-              \
    \  ogs_free(data->part[data->num_of_part].content_type);\n+            ogs_assert(data->part[data->num_of_part].content_type\
    \ == NULL);\n             data->part[data->num_of_part].content_type =\n     \
    \            ogs_strndup(at, length);\n             ogs_assert(data->part[data->num_of_part].content_type);\n\
    \             break;\n         CASE(OGS_SBI_CONTENT_ID)\n-            if (data->part[data->num_of_part].content_id)\n\
    -                ogs_free(data->part[data->num_of_part].content_id);\n+      \
    \      ogs_assert(data->part[data->num_of_part].content_id == NULL);\n       \
    \      data->part[data->num_of_part].content_id =\n                 ogs_strndup(at,\
    \ length);\n             ogs_assert(data->part[data->num_of_part].content_id);\n\
    @@ -1867,7 +1865,7 @@ static int on_part_data(\n     data = multipart_parser_get_data(parser);\n\
    \     ogs_assert(data);\n \n-    if (at && length) {\n+    if (data->num_of_part\
    \ < OGS_SBI_MAX_NUM_OF_PART && at && length) {\n         SWITCH(data->part[data->num_of_part].content_type)\n\
    \         CASE(OGS_SBI_CONTENT_JSON_TYPE)\n         CASE(OGS_SBI_CONTENT_5GNAS_TYPE)\n\
    @@ -1901,9 +1899,9 @@ static int on_part_data(\n             break;\n \n     \
    \    DEFAULT\n-            ogs_log_hexdump(OGS_LOG_FATAL, (unsigned char *)at,\
    \ length);\n             ogs_error(\"Unknown content_type [%s]\",\n          \
    \           data->part[data->num_of_part].content_type);\n+            ogs_log_hexdump(OGS_LOG_ERROR,\
    \ (unsigned char *)at, length);\n         END\n     }\n     return 0;\n@@ -1917,7\
    \ +1915,9 @@ static int on_part_data_end(multipart_parser *parser)\n     data\
    \ = multipart_parser_get_data(parser);\n     ogs_assert(data);\n \n-    data->num_of_part++;\n\
    +    if (data->num_of_part < OGS_SBI_MAX_NUM_OF_PART) {\n+        data->num_of_part++;\n\
    +    }\n \n     return 0;\n }\n@@ -1967,6 +1967,11 @@ static int parse_multipart(\n\
    \     multipart_parser_free(parser);\n     ogs_free(boundary);\n \n+    if (data.num_of_part\
    \ > OGS_SBI_MAX_NUM_OF_PART) {\n+        /* Overflow Issues #1247 */\n+      \
    \  ogs_fatal(\"Overflow num_of_part[%d]\", data.num_of_part);\n+        ogs_assert_if_reached();\n\
    +    }\n     for (i = 0; i < data.num_of_part; i++) {\n         SWITCH(data.part[i].content_type)\n\
    \         CASE(OGS_SBI_CONTENT_JSON_TYPE)"
  - "--- a/src/amf/namf-handler.c\n+++ b/src/amf/namf-handler.c\n@@ -53,6 +53,8 @@\
    \ int amf_namf_comm_handle_n1_n2_message_transfer(\n     OpenAPI_n2_info_content_t\
    \ *n2InfoContent = NULL;\n     OpenAPI_ref_to_binary_data_t *ngapData = NULL;\n\
    \ \n+    OpenAPI_ngap_ie_type_e ngapIeType = OpenAPI_ngap_ie_type_NULL;\n+\n \
    \    ogs_assert(stream);\n     ogs_assert(recvmsg);\n \n@@ -117,12 +119,15 @@\
    \ int amf_namf_comm_handle_n1_n2_message_transfer(\n             ogs_error(\"\
    No smInfo\");\n             return OGS_ERROR;\n         }\n+\n         n2InfoContent\
    \ = smInfo->n2_info_content;\n         if (!n2InfoContent) {\n             ogs_error(\"\
    No n2InfoContent\");\n             return OGS_ERROR;\n         }\n \n+       \
    \ ngapIeType = n2InfoContent->ngap_ie_type;\n+\n         ngapData = n2InfoContent->ngap_data;\n\
    \         if (!ngapData || !ngapData->content_id) {\n             ogs_error(\"\
    No ngapData\");\n@@ -153,7 +158,7 @@ int amf_namf_comm_handle_n1_n2_message_transfer(\n\
    \ \n     sendmsg.N1N2MessageTransferRspData = &N1N2MessageTransferRspData;\n \n\
    -    switch (n2InfoContent->ngap_ie_type) {\n+    switch (ngapIeType) {\n    \
    \ case OpenAPI_ngap_ie_type_PDU_RES_SETUP_REQ:\n         if (!n2buf) {\n     \
    \        ogs_error(\"[%s] No N2 SM Content\", amf_ue->supi);\n@@ -390,8 +395,7\
    \ @@ int amf_namf_comm_handle_n1_n2_message_transfer(\n         break;\n \n  \
    \   default:\n-        ogs_error(\"Not implemented ngap_ie_type[%d]\",\n-    \
    \            n2InfoContent->ngap_ie_type);\n+        ogs_error(\"Not implemented\
    \ ngapIeType[%d]\", ngapIeType);\n         ogs_assert_if_reached();\n     }\n "
  identifiers:
  - CVE-2021-44109
  - CWE-787
  overview: A buffer overflow in lib/sbi/message.c in Open5GS 2.3.6 and earlier allows
    remote attackers to Denial of Service via a crafted sbi request.
  references:
  - source: cve@mitre.org
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/open5gs/open5gs/commit/d919b2744cd05abae043490f0a3dd1946c1ccb8c
  - source: cve@mitre.org
    tags:
    - Exploit
    - Issue Tracking
    - Third Party Advisory
    url: https://github.com/open5gs/open5gs/issues/1247
  title: A buffer overflow in lib/sbi/message.c in Open5GS 2.3.6 and earlier allows
    remote attackers to Denial of Service via a crafted sbi request.
- diff_content:
  - "--- a/ext/yajl/yajl_gen.c\n+++ b/ext/yajl/yajl_gen.c\n@@ -178,7 +178,7 @@ yajl_gen_free(yajl_gen\
    \ g)\n     if (++(g->depth) >= YAJL_MAX_DEPTH) return yajl_max_depth_exceeded;\n\
    \ \n #define DECREMENT_DEPTH \\\n-    if (--(g->depth) >= YAJL_MAX_DEPTH) return\
    \ yajl_gen_error;\n+    if (--(g->depth) >= YAJL_MAX_DEPTH) return yajl_depth_underflow;\n\
    \ \n #define APPENDED_ATOM \\\n     switch (g->state[g->depth]) {            \
    \       \\"
  - "--- a/ext/yajl/yajl_lex.c\n+++ b/ext/yajl/yajl_lex.c\n@@ -43,6 +43,7 @@ const\
    \ char *yajl_tok_name(yajl_tok tok) {\n         case yajl_tok_bool: return \"\
    bool\";\n         case yajl_tok_colon: return \"colon\";\n         case yajl_tok_comma:\
    \ return \"comma\";\n+        case yajl_tok_comment: return \"comment\";\n   \
    \      case yajl_tok_eof: return \"eof\";\n         case yajl_tok_error: return\
    \ \"error\";\n         case yajl_tok_left_brace: return \"open_array\";"
  identifiers:
  - CVE-2022-24795
  - CWE-122
  overview: yajl-ruby is a C binding to the YAJL JSON parsing and generation library.
    The 1.x branch and the 2.x branch of `yajl` contain an integer overflow which
    leads to subsequent heap memory corruption when dealing with large (~2GB) inputs.
    The reallocation logic at `yajl_buf.c#L64` may result in the `need` 32bit integer
    wrapping to 0 when `need` approaches a value of 0x80000000 (i.e. ~2GB of data),
    which results in a reallocation of buf->alloc into a small heap chunk. These integers
    are declared as `size_t` in the 2.x branch of `yajl`, which practically prevents
    the issue from triggering on 64bit platforms, however this does not preclude this
    issue triggering on 32bit builds on which `size_t` is a 32bit integer. Subsequent
    population of this under-allocated heap chunk is based on the original buffer
    size, leading to heap memory corruption. This vulnerability mostly impacts process
    availability. Maintainers believe exploitation for arbitrary code execution is
    unlikely. A patch is available and anticipated to be part of yajl-ruby version
    1.4.2. As a workaround, avoid passing large inputs to YAJL.
  references:
  - source: security-advisories@github.com
    tags:
    - Exploit
    - Third Party Advisory
    url: https://github.com/brianmario/yajl-ruby/blob/7168bd79b888900aa94523301126f968a93eb3a6/ext/yajl/yajl_buf.c#L64
  - source: security-advisories@github.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/brianmario/yajl-ruby/commit/7168bd79b888900aa94523301126f968a93eb3a6
  - source: security-advisories@github.com
    tags:
    - Exploit
    - Third Party Advisory
    url: https://github.com/brianmario/yajl-ruby/security/advisories/GHSA-jj47-x69x-mxrm
  - source: security-advisories@github.com
    url: https://lists.debian.org/debian-lts-announce/2023/07/msg00013.html
  - source: security-advisories@github.com
    url: https://lists.debian.org/debian-lts-announce/2023/08/msg00003.html
  - source: security-advisories@github.com
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/KLE3C4CECEJ4EUYI56KXI6OWACWXX7WN/
  - source: security-advisories@github.com
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/YO32YDJ74DADC7CMJNLSLBVWN5EXGF5J/
  title: yajl-ruby is a C binding to the YAJL JSON parsing and generation library.
    The 1.x branch and the 2.x branch of `yajl` contain an integer overflow which
    leads to subsequent heap memory corruption when dealing with large (~2GB) inputs.
    The reallocation logic at `yajl_buf.c#L64` may result in the `need` 32bit integer
    wrapping to 0 when `need` approaches a value of 0x80000000 (i.e. ~2GB of data),
    which results in a reallocation of buf->alloc into a small heap chunk. These integers
    are declared as `size_t` in the 2.x branch of `yajl`, which practically prevents
    the issue from triggering on 64bit platforms, however this does not preclude this
    issue triggering on 32bit builds on which `size_t` is a 32bit integer. Subsequent
    population of this under-allocated heap chunk is based on the original buffer
    size, leading to heap memory corruption. This vulnerability mostly impacts process
    availability. Maintainers believe exploitation for arbitrary code execution is
    unlikely. A patch is available and anticipated to be part of yajl-ruby version
    1.4.2. As a workaround, avoid passing large inputs to YAJL.
- diff_content:
  - "--- a/libr/bin/p/bin_dyldcache.c\n+++ b/libr/bin/p/bin_dyldcache.c\n@@ -1247,7\
    \ +1247,8 @@ static RList *create_cache_bins(RBinFile *bf, RDyldCache *cache)\
    \ {\n \t\t\tif (deps && !deps[j]) {\n \t\t\t\tcontinue;\n \t\t\t}\n-\t\t\tut64\
    \ pa = va2pa (img[j].address, hdr->mappingCount, &cache->maps[maps_index], cache->buf,\
    \ 0, NULL, NULL);\n+\t\t\t// ut64 pa = va2pa (img[j].address, hdr->mappingCount,\
    \ &cache->maps[maps_index], cache->buf, 0, NULL, NULL);\n+\t\t\tut64 pa = va2pa\
    \ (img[j].address, cache->n_maps, &cache->maps[maps_index], cache->buf, 0, NULL,\
    \ NULL);\n \t\t\tif (pa == UT64_MAX) {\n \t\t\t\tcontinue;\n \t\t\t}"
  identifiers:
  - CVE-2022-1244
  - CWE-122
  overview: heap-buffer-overflow in GitHub repository radareorg/radare2 prior to 5.6.8.
    This vulnerability is capable of inducing denial of service.
  references:
  - source: security@huntr.dev
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/radareorg/radare2/commit/2b77b277d67ce061ee6ef839e7139ebc2103c1e3
  - source: security@huntr.dev
    tags:
    - Exploit
    - Third Party Advisory
    url: https://huntr.dev/bounties/8ae2c61a-2220-47a5-bfe8-fe6d41ab1f82
  title: heap-buffer-overflow in GitHub repository radareorg/radare2 prior to 5.6.8.
    This vulnerability is capable of inducing denial of service.
- diff_content:
  - "--- a/libr/bin/format/ne/ne.c\n+++ b/libr/bin/format/ne/ne.c\n@@ -1,4 +1,4 @@\n\
    -/* radare - LGPL - Copyright 2019 - GustavoLCR */\n+/* radare - LGPL - Copyright\
    \ 2019-2022 - GustavoLCR */\n \n #include \"ne.h\"\n \n@@ -425,7 +425,7 @@ RList\
    \ *r_bin_ne_get_relocs(r_bin_ne_obj_t *bin) {\n \t\treturn NULL;\n \t}\n \n-\t\
    ut16 *modref = malloc (bin->ne_header->ModRefs * sizeof (ut16));\n+\tut16 *modref\
    \ = calloc (bin->ne_header->ModRefs, sizeof (ut16));\n \tif (!modref) {\n \t\t\
    return NULL;\n \t}\n@@ -451,7 +451,8 @@ RList *r_bin_ne_get_relocs(r_bin_ne_obj_t\
    \ *bin) {\n \t\t\tcontinue;\n \t\t}\n \t\toff += 2;\n-\t\twhile (off < start +\
    \ length * sizeof (NE_image_reloc_item)) {\n+\t\tsize_t buf_size = r_buf_size\
    \ (bin->buf);\n+\t\twhile (off < start + length * sizeof (NE_image_reloc_item)\
    \ && off < buf_size) {\n \t\t\tRBinReloc *reloc = R_NEW0 (RBinReloc);\n \t\t\t\
    if (!reloc) {\n \t\t\t\treturn NULL;\n@@ -484,10 +485,11 @@ RList *r_bin_ne_get_relocs(r_bin_ne_obj_t\
    \ *bin) {\n \t\t\t\t\tbreak;\n \t\t\t\t}\n \t\t\t\tchar *name;\n-\t\t\t\tif (rel.index\
    \ > bin->ne_header->ModRefs) {\n+\t\t\t\tif (rel.index < 1 || rel.index > bin->ne_header->ModRefs)\
    \ {\n \t\t\t\t\tname = r_str_newf (\"UnknownModule%d_%x\", rel.index, off); //\
    \ ????\n \t\t\t\t} else {\n-\t\t\t\t\toffset = modref[rel.index - 1] + bin->header_offset\
    \ + bin->ne_header->ImportNameTable;\n+\t\t\t\t\tint index = rel.index;\n+\t\t\
    \t\t\toffset = modref[index - 1] + bin->header_offset + bin->ne_header->ImportNameTable;\n\
    \ \t\t\t\t\tname = __read_nonnull_str_at (bin->buf, offset);\n \t\t\t\t}\n \t\t\
    \t\tif (rel.flags & IMPORTED_ORD) {\n@@ -563,16 +565,31 @@ void __init(RBuffer\
    \ *buf, r_bin_ne_obj_t *bin) {\n \t\treturn;\n \t}\n \tbin->buf = buf;\n+\t//\
    \ XXX this is endian unsafe\n \tr_buf_read_at (buf, bin->header_offset, (ut8 *)bin->ne_header,\
    \ sizeof (NE_image_header));\n+\tif (bin->ne_header->FileAlnSzShftCnt > 8) {\n\
    +\t\tbin->ne_header->FileAlnSzShftCnt = 8;\n+\t}\n+\tif (bin->ne_header->ModRefs\
    \ * sizeof (ut16) >= r_buf_size (bin->buf)) {\n+\t\tbin->ne_header->ModRefs =\
    \ r_buf_size (bin->buf) / sizeof (ut16);\n+\t}\n \tbin->alignment = 1 << bin->ne_header->FileAlnSzShftCnt;\n\
    \ \tif (!bin->alignment) {\n \t\tbin->alignment = 1 << 9;\n \t}\n \tbin->os =\
    \ __get_target_os (bin);\n \n \tut16 offset = bin->ne_header->SegTableOffset +\
    \ bin->header_offset;\n-\tut16 size = bin->ne_header->SegCount * sizeof (NE_image_segment_entry);\n\
    +\tsize_t size = bin->ne_header->SegCount * sizeof (NE_image_segment_entry);\n\
    +\tif (offset >= r_buf_size (bin->buf)) {\n+\t\treturn;\n+\t}\n+\tsize_t remaining\
    \ = r_buf_size (bin->buf) - offset;\n+\tsize = R_MIN (remaining, size);\n \tbin->segment_entries\
    \ = calloc (1, size);\n+\tif (size >= remaining) {\n+\t\tbin->ne_header->SegCount\
    \ = size / sizeof (NE_image_segment_entry);\n+\t}\n \tif (!bin->segment_entries)\
    \ {\n \t\treturn;\n \t}"
  identifiers:
  - CVE-2022-1237
  - CWE-129
  overview: Improper Validation of Array Index in GitHub repository radareorg/radare2
    prior to 5.6.8. This vulnerability is heap overflow and may be exploitable. For
    more general description of heap buffer overflow, see [CWE](https://cwe.mitre.org/data/definitions/122.html).
  references:
  - source: security@huntr.dev
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/radareorg/radare2/commit/2d782cdaa2112c10b8dd5e7a93c134b2ada9c1a6
  - source: security@huntr.dev
    tags:
    - Exploit
    - Third Party Advisory
    url: https://huntr.dev/bounties/ad3c9c4c-76e7-40c8-bd4a-c095acd8bb40
  title: Improper Validation of Array Index in GitHub repository radareorg/radare2
    prior to 5.6.8. This vulnerability is heap overflow and may be exploitable. For
    more general description of heap buffer overflow, see [CWE](https://cwe.mitre.org/data/definitions/122.html).
- diff_content:
  - "--- a/libr/bin/format/ne/ne.c\n+++ b/libr/bin/format/ne/ne.c\n@@ -374,6 +374,9\
    \ @@ RList *r_bin_ne_get_entrypoints(r_bin_ne_obj_t *bin) {\n \t}\n \tint off\
    \ = 0;\n \twhile (off < bin->ne_header->EntryTableLength) {\n+\t\tif (bin->entry_table\
    \ + off + 32 >= r_buf_size (bin->buf)) {\n+\t\t\tbreak;\n+\t\t}\n \t\tut8 bundle_length\
    \ = *(ut8 *)(bin->entry_table + off);\n \t\tif (!bundle_length) {\n \t\t\tbreak;\n\
    @@ -398,7 +401,9 @@ RList *r_bin_ne_get_entrypoints(r_bin_ne_obj_t *bin) {\n \t\
    \t\t\tut8 segnum = *(bin->entry_table + off);\n \t\t\t\toff++;\n \t\t\t\tut16\
    \ segoff = *(ut16 *)(bin->entry_table + off);\n-\t\t\t\tentry->paddr = (ut64)bin->segment_entries[segnum\
    \ - 1].offset * bin->alignment + segoff;\n+\t\t\t\tif (segnum > 0) {\n+\t\t\t\t\
    \tentry->paddr = (ut64)bin->segment_entries[segnum - 1].offset * bin->alignment\
    \ + segoff;\n+\t\t\t\t}\n \t\t\t} else { // Fixed\n \t\t\t\tentry->paddr = (ut64)bin->segment_entries[bundle_type\
    \ - 1].offset * bin->alignment + *(ut16 *)(bin->entry_table + off);\n \t\t\t}"
  identifiers:
  - CVE-2022-1238
  - CWE-787
  overview: Out-of-bounds Write in libr/bin/format/ne/ne.c in GitHub repository radareorg/radare2
    prior to 5.6.8. This vulnerability is heap overflow and may be exploitable. For
    more general description of heap buffer overflow, see [CWE](https://cwe.mitre.org/data/definitions/122.html).
  references:
  - source: security@huntr.dev
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/radareorg/radare2/commit/c40a4f9862104ede15d0ba05ccbf805923070778
  - source: security@huntr.dev
    tags:
    - Exploit
    - Third Party Advisory
    url: https://huntr.dev/bounties/47422cdf-aad2-4405-a6a1-6f63a3a93200
  title: Out-of-bounds Write in libr/bin/format/ne/ne.c in GitHub repository radareorg/radare2
    prior to 5.6.8. This vulnerability is heap overflow and may be exploitable. For
    more general description of heap buffer overflow, see [CWE](https://cwe.mitre.org/data/definitions/122.html).
- diff_content:
  - "--- a/libr/bin/format/mach0/mach0.c\n+++ b/libr/bin/format/mach0/mach0.c\n@@\
    \ -3178,7 +3178,7 @@ static void parse_relocation_info(struct MACH0_(obj_t) *bin,\
    \ RSkipList *relocs,\n \tfor (i = 0; i < num; i++) {\n \t\tstruct relocation_info\
    \ a_info = info[i];\n \t\tut32 sym_num = a_info.r_symbolnum;\n-\t\tif (sym_num\
    \ > bin->nsymtab) {\n+\t\tif (sym_num >= bin->nsymtab) {\n \t\t\tcontinue;\n \t\
    \t}\n "
  identifiers:
  - CVE-2022-1240
  - CWE-787
  overview: Heap buffer overflow in libr/bin/format/mach0/mach0.c in GitHub repository
    radareorg/radare2 prior to 5.8.6. If address sanitizer is disabled during the
    compiling, the program should executes into the `r_str_ncpy` function. Therefore
    I think it is very likely to be exploitable. For more general description of heap
    buffer overflow, see [CWE](https://cwe.mitre.org/data/definitions/122.html).
  references:
  - source: security@huntr.dev
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/radareorg/radare2/commit/ca8d8b39f3e34a4fd943270330b80f1148129de4
  - source: security@huntr.dev
    tags:
    - Exploit
    - Issue Tracking
    - Patch
    - Third Party Advisory
    url: https://huntr.dev/bounties/e589bd97-4c74-4e79-93b5-0951a281facc
  title: Heap buffer overflow in libr/bin/format/mach0/mach0.c in GitHub repository
    radareorg/radare2 prior to 5.8.6. If address sanitizer is disabled during the
    compiling, the program should executes into the `r_str_ncpy` function. Therefore
    I think it is very likely to be exploitable. For more general description of heap
    buffer overflow, see [CWE](https://cwe.mitre.org/data/definitions/122.html).
- diff_content:
  - "--- a/pjmedia/src/pjmedia/rtcp.c\n+++ b/pjmedia/src/pjmedia/rtcp.c\n@@ -242,6\
    \ +242,11 @@ PJ_DEF(void) pjmedia_rtcp_init2( pjmedia_rtcp_session *sess,\n  \
    \   sess->rtcp_rr_pkt.common.pt = RTCP_RR;\n     sess->rtcp_rr_pkt.common.length\
    \ = pj_htons(7);\n \n+    /* Copy to RTCP FB common header */\n+    pj_memcpy(&sess->rtcp_fb_com,\
    \ &sr_pkt->common, \n+\t      sizeof(pjmedia_rtcp_common));\n+    sess->rtcp_fb_com.ssrc_src\
    \ = 0;\n+\n     /* Get time and timestamp base and frequency */\n     pj_gettimeofday(&now);\n\
    \     sess->tv_base = now;"
  - "--- a/pjmedia/src/pjmedia/rtcp_fb.c\n+++ b/pjmedia/src/pjmedia/rtcp_fb.c\n@@\
    \ -43,7 +43,7 @@ PJ_DEF(pj_status_t) pjmedia_rtcp_fb_build_nack(\n \t\t\t\t\t\
    unsigned nack_cnt,\n \t\t\t\t\tconst pjmedia_rtcp_fb_nack nack[])\n {\n-    pjmedia_rtcp_common\
    \ *hdr;\n+    pjmedia_rtcp_fb_common *hdr;\n     pj_uint8_t *p;\n     unsigned\
    \ len, i;\n \n@@ -54,11 +54,11 @@ PJ_DEF(pj_status_t) pjmedia_rtcp_fb_build_nack(\n\
    \ \treturn PJ_ETOOSMALL;\n \n     /* Build RTCP-FB NACK header */\n-    hdr =\
    \ (pjmedia_rtcp_common*)buf;\n-    pj_memcpy(hdr, &session->rtcp_rr_pkt.common,\
    \  sizeof(*hdr));\n-    hdr->pt = RTCP_RTPFB;\n-    hdr->count = 1; /* FMT = 1\
    \ */\n-    hdr->length = pj_htons((pj_uint16_t)(len/4 - 1));\n+    hdr = (pjmedia_rtcp_fb_common*)buf;\n\
    +    pj_memcpy(hdr, &session->rtcp_fb_com, sizeof(*hdr));\n+    hdr->rtcp_common.pt\
    \ = RTCP_RTPFB;\n+    hdr->rtcp_common.count = 1; /* FMT = 1 */\n+    hdr->rtcp_common.length\
    \ = pj_htons((pj_uint16_t)(len/4 - 1));\n \n     /* Build RTCP-FB NACK FCI */\n\
    \     p = (pj_uint8_t*)hdr + sizeof(*hdr);\n@@ -86,7 +86,7 @@ PJ_DEF(pj_status_t)\
    \ pjmedia_rtcp_fb_build_pli(\n \t\t\t\t\tvoid *buf,\n \t\t\t\t\tpj_size_t *length)\n\
    \ {\n-    pjmedia_rtcp_common *hdr;\n+    pjmedia_rtcp_fb_common *hdr;\n     unsigned\
    \ len;\n \n     PJ_ASSERT_RETURN(session && buf && length, PJ_EINVAL);\n@@ -96,11\
    \ +96,11 @@ PJ_DEF(pj_status_t) pjmedia_rtcp_fb_build_pli(\n \treturn PJ_ETOOSMALL;\n\
    \ \n     /* Build RTCP-FB PLI header */\n-    hdr = (pjmedia_rtcp_common*)buf;\n\
    -    pj_memcpy(hdr, &session->rtcp_rr_pkt.common,  sizeof(*hdr));\n-    hdr->pt\
    \ = RTCP_PSFB;\n-    hdr->count = 1; /* FMT = 1 */\n-    hdr->length = pj_htons((pj_uint16_t)(len/4\
    \ - 1));\n+    hdr = (pjmedia_rtcp_fb_common*)buf;\n+    pj_memcpy(hdr, &session->rtcp_fb_com,\
    \ sizeof(*hdr));\n+    hdr->rtcp_common.pt = RTCP_PSFB;\n+    hdr->rtcp_common.count\
    \ = 1; /* FMT = 1 */\n+    hdr->rtcp_common.length = pj_htons((pj_uint16_t)(len/4\
    \ - 1));\n \n     /* Finally */\n     *length = len;\n@@ -119,7 +119,7 @@ PJ_DEF(pj_status_t)\
    \ pjmedia_rtcp_fb_build_sli(\n \t\t\t\t\tunsigned sli_cnt,\n \t\t\t\t\tconst pjmedia_rtcp_fb_sli\
    \ sli[])\n {\n-    pjmedia_rtcp_common *hdr;\n+    pjmedia_rtcp_fb_common *hdr;\n\
    \     pj_uint8_t *p;\n     unsigned len, i;\n \n@@ -130,11 +130,11 @@ PJ_DEF(pj_status_t)\
    \ pjmedia_rtcp_fb_build_sli(\n \treturn PJ_ETOOSMALL;\n \n     /* Build RTCP-FB\
    \ SLI header */\n-    hdr = (pjmedia_rtcp_common*)buf;\n-    pj_memcpy(hdr, &session->rtcp_rr_pkt.common,\
    \  sizeof(*hdr));\n-    hdr->pt = RTCP_PSFB;\n-    hdr->count = 2; /* FMT = 2\
    \ */\n-    hdr->length = pj_htons((pj_uint16_t)(len/4 - 1));\n+    hdr = (pjmedia_rtcp_fb_common*)buf;\n\
    +    pj_memcpy(hdr, &session->rtcp_fb_com, sizeof(*hdr));\n+    hdr->rtcp_common.pt\
    \ = RTCP_PSFB;\n+    hdr->rtcp_common.count = 2; /* FMT = 2 */\n+    hdr->rtcp_common.length\
    \ = pj_htons((pj_uint16_t)(len/4 - 1));\n \n     /* Build RTCP-FB SLI FCI */\n\
    \     p = (pj_uint8_t*)hdr + sizeof(*hdr);\n@@ -166,7 +166,7 @@ PJ_DEF(pj_status_t)\
    \ pjmedia_rtcp_fb_build_rpsi(\n \t\t\t\t\t    pj_size_t *length,\n \t\t\t\t\t\
    \    const pjmedia_rtcp_fb_rpsi *rpsi)\n {\n-    pjmedia_rtcp_common *hdr;\n+\
    \    pjmedia_rtcp_fb_common *hdr;\n     pj_uint8_t *p;\n     unsigned bitlen,\
    \ padlen, len;\n \n@@ -179,11 +179,11 @@ PJ_DEF(pj_status_t) pjmedia_rtcp_fb_build_rpsi(\n\
    \ \treturn PJ_ETOOSMALL;\n \n     /* Build RTCP-FB RPSI header */\n-    hdr =\
    \ (pjmedia_rtcp_common*)buf;\n-    pj_memcpy(hdr, &session->rtcp_rr_pkt.common,\
    \  sizeof(*hdr));\n-    hdr->pt = RTCP_PSFB;\n-    hdr->count = 3; /* FMT = 3\
    \ */\n-    hdr->length = pj_htons((pj_uint16_t)(len/4 - 1));\n+    hdr = (pjmedia_rtcp_fb_common*)buf;\n\
    +    pj_memcpy(hdr, &session->rtcp_fb_com, sizeof(*hdr));\n+    hdr->rtcp_common.pt\
    \ = RTCP_PSFB;\n+    hdr->rtcp_common.count = 3; /* FMT = 3 */\n+    hdr->rtcp_common.length\
    \ = pj_htons((pj_uint16_t)(len/4 - 1));\n \n     /* Build RTCP-FB RPSI FCI */\n\
    \     p = (pj_uint8_t*)hdr + sizeof(*hdr);\n@@ -620,18 +620,18 @@ PJ_DEF(pj_status_t)\
    \ pjmedia_rtcp_fb_parse_nack(\n \t\t\t\t\tunsigned *nack_cnt,\n \t\t\t\t\tpjmedia_rtcp_fb_nack\
    \ nack[])\n {\n-    pjmedia_rtcp_common *hdr = (pjmedia_rtcp_common*) buf;\n+\
    \    pjmedia_rtcp_fb_common *hdr = (pjmedia_rtcp_fb_common*) buf;\n     pj_uint8_t\
    \ *p;\n     unsigned cnt, i;\n \n     PJ_ASSERT_RETURN(buf && nack_cnt && nack,\
    \ PJ_EINVAL);\n-    PJ_ASSERT_RETURN(length >= sizeof(pjmedia_rtcp_common), PJ_ETOOSMALL);\n\
    +    PJ_ASSERT_RETURN(length >= sizeof(pjmedia_rtcp_fb_common), PJ_ETOOSMALL);\n\
    \ \n     /* Generic NACK uses pt==RTCP_RTPFB and FMT==1 */\n-    if (hdr->pt !=\
    \ RTCP_RTPFB || hdr->count != 1)\n+    if (hdr->rtcp_common.pt != RTCP_RTPFB ||\
    \ hdr->rtcp_common.count != 1)\n \treturn PJ_ENOTFOUND;\n \n-    cnt = pj_ntohs((pj_uint16_t)hdr->length);\n\
    +    cnt = pj_ntohs((pj_uint16_t)hdr->rtcp_common.length);\n     if (cnt > 2)\
    \ cnt -= 2; else cnt = 0;\n     if (length < (cnt+3)*4)\n \treturn PJ_ETOOSMALL;\n\
    @@ -661,15 +661,15 @@ PJ_DEF(pj_status_t) pjmedia_rtcp_fb_parse_pli(\n \t\t\t\t\
    \tconst void *buf,\n \t\t\t\t\tpj_size_t length)\n {\n-    pjmedia_rtcp_common\
    \ *hdr = (pjmedia_rtcp_common*) buf;\n+    pjmedia_rtcp_fb_common *hdr = (pjmedia_rtcp_fb_common*)\
    \ buf;\n \n     PJ_ASSERT_RETURN(buf, PJ_EINVAL);\n \n     if (length < 12)\n\
    \     \treturn PJ_ETOOSMALL;\n \n     /* PLI uses pt==RTCP_PSFB and FMT==1 */\n\
    -    if (hdr->pt != RTCP_PSFB || hdr->count != 1)\n+    if (hdr->rtcp_common.pt\
    \ != RTCP_PSFB || hdr->rtcp_common.count != 1)\n \treturn PJ_ENOTFOUND;\n \n \
    \    return PJ_SUCCESS;\n@@ -686,18 +686,18 @@ PJ_DEF(pj_status_t) pjmedia_rtcp_fb_parse_sli(\n\
    \ \t\t\t\t\tunsigned *sli_cnt,\n \t\t\t\t\tpjmedia_rtcp_fb_sli sli[])\n {\n- \
    \   pjmedia_rtcp_common *hdr = (pjmedia_rtcp_common*) buf;\n+    pjmedia_rtcp_fb_common\
    \ *hdr = (pjmedia_rtcp_fb_common*) buf;\n     pj_uint8_t *p;\n     unsigned cnt,\
    \ i;\n \n     PJ_ASSERT_RETURN(buf && sli_cnt && sli, PJ_EINVAL);\n-    PJ_ASSERT_RETURN(length\
    \ >= sizeof(pjmedia_rtcp_common), PJ_ETOOSMALL);\n+    PJ_ASSERT_RETURN(length\
    \ >= sizeof(pjmedia_rtcp_fb_common), PJ_ETOOSMALL);\n \n     /* PLI uses pt==RTCP_PSFB\
    \ and FMT==2 */\n-    if (hdr->pt != RTCP_PSFB || hdr->count != 2)\n+    if (hdr->rtcp_common.pt\
    \ != RTCP_PSFB || hdr->rtcp_common.count != 2)\n \treturn PJ_ENOTFOUND;\n \n-\
    \    cnt = pj_ntohs((pj_uint16_t)hdr->length) - 2;\n+    cnt = pj_ntohs((pj_uint16_t)hdr->rtcp_common.length)\
    \ - 2;\n     if (length < (cnt+3)*4)\n \treturn PJ_ETOOSMALL;\n \n@@ -730,24 +730,43\
    \ @@ PJ_DEF(pj_status_t) pjmedia_rtcp_fb_parse_rpsi(\n \t\t\t\t\tpj_size_t length,\n\
    \ \t\t\t\t\tpjmedia_rtcp_fb_rpsi *rpsi)\n {\n-    pjmedia_rtcp_common *hdr = (pjmedia_rtcp_common*)\
    \ buf;\n+    pjmedia_rtcp_fb_common *hdr = (pjmedia_rtcp_fb_common*) buf;\n  \
    \   pj_uint8_t *p;\n     pj_uint8_t padlen;\n     pj_size_t rpsi_len;\n \n   \
    \  PJ_ASSERT_RETURN(buf && rpsi, PJ_EINVAL);\n-    PJ_ASSERT_RETURN(length >=\
    \ sizeof(pjmedia_rtcp_common), PJ_ETOOSMALL);\n+    PJ_ASSERT_RETURN(length >=\
    \ sizeof(pjmedia_rtcp_fb_common), PJ_ETOOSMALL);\n \n     /* RPSI uses pt==RTCP_PSFB\
    \ and FMT==3 */\n-    if (hdr->pt != RTCP_PSFB || hdr->count != 3)\n+    if (hdr->rtcp_common.pt\
    \ != RTCP_PSFB || hdr->rtcp_common.count != 3)\n \treturn PJ_ENOTFOUND;\n \n-\
    \    rpsi_len = (pj_ntohs((pj_uint16_t)hdr->length)-2) * 4;\n+    if (hdr->rtcp_common.length\
    \ < 3) {    \n+        PJ_PERROR(3, (THIS_FILE, PJ_ETOOSMALL,\n+             \
    \         \"Failed parsing FB RPSI, invalid header length\"));\n+\treturn PJ_ETOOSMALL;\n\
    +    }\n+\n+    rpsi_len = (pj_ntohs((pj_uint16_t)hdr->rtcp_common.length)-2)\
    \ * 4;\n     if (length < rpsi_len + 12)\n \treturn PJ_ETOOSMALL;\n \n     p =\
    \ (pj_uint8_t*)hdr + sizeof(*hdr);\n     padlen = *p++;\n+\n+    if (padlen >=\
    \ 32) {\n+        PJ_PERROR(3, (THIS_FILE, PJ_ETOOBIG,\n+                    \
    \  \"Failed parsing FB RPSI, invalid RPSI padding len\"));\n+\treturn PJ_ETOOBIG;\n\
    +    }\n+\n+    if ((rpsi_len * 8) < (unsigned)(16 + padlen)) {\n+        PJ_PERROR(3,\
    \ (THIS_FILE, PJ_ETOOSMALL,\n+                      \"Failed parsing FB RPSI,\
    \ invalid RPSI bit len\"));\n+\treturn PJ_ETOOSMALL;\n+    }\n+\n     rpsi->pt\
    \ = (*p++ & 0x7F);\n     rpsi->rpsi_bit_len = rpsi_len*8 - 16 - padlen;\n    \
    \ pj_strset(&rpsi->rpsi, (char*)p, (rpsi->rpsi_bit_len + 7)/8);"
  identifiers:
  - CVE-2022-24786
  - CWE-125
  overview: PJSIP is a free and open source multimedia communication library written
    in C. PJSIP versions 2.12 and prior do not parse incoming RTCP feedback RPSI (Reference
    Picture Selection Indication) packet, but any app that directly uses pjmedia_rtcp_fb_parse_rpsi()
    will be affected. A patch is available in the `master` branch of the `pjsip/pjproject`
    GitHub repository. There are currently no known workarounds.
  references:
  - source: security-advisories@github.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/pjsip/pjproject/commit/11559e49e65bdf00922ad5ae28913ec6a198d508
  - source: security-advisories@github.com
    tags:
    - Third Party Advisory
    url: https://github.com/pjsip/pjproject/security/advisories/GHSA-vhxv-phmx-g52q
  - source: security-advisories@github.com
    tags:
    - Mailing List
    - Third Party Advisory
    url: https://lists.debian.org/debian-lts-announce/2022/11/msg00021.html
  - source: security-advisories@github.com
    tags:
    - Third Party Advisory
    url: https://security.gentoo.org/glsa/202210-37
  - source: security-advisories@github.com
    tags:
    - Third Party Advisory
    url: https://www.debian.org/security/2022/dsa-5285
  title: PJSIP is a free and open source multimedia communication library written
    in C. PJSIP versions 2.12 and prior do not parse incoming RTCP feedback RPSI (Reference
    Picture Selection Indication) packet, but any app that directly uses pjmedia_rtcp_fb_parse_rpsi()
    will be affected. A patch is available in the `master` branch of the `pjsip/pjproject`
    GitHub repository. There are currently no known workarounds.
- diff_content:
  - "--- a/pjlib-util/src/pjlib-util/dns.c\n+++ b/pjlib-util/src/pjlib-util/dns.c\n\
    @@ -159,8 +159,13 @@ static pj_status_t get_name_len(int rec_counter, const pj_uint8_t\
    \ *pkt,\n \t} else {\n \t    unsigned label_len = *p;\n \n-\t    /* Check that\
    \ label length is valid */\n-\t    if (pkt+label_len > max)\n+\t    /* Check that\
    \ label length is valid.\n+\t     * Each label consists of an octet length (of\
    \ size 1) followed\n+\t     * by the octet of the specified length (label_len).\
    \ Then it\n+\t     * must be followed by either another label's octet length or\n\
    +\t     * a zero length octet (that terminates the sequence).\n+\t     */\n+\t\
    \    if (p+1+label_len+1 > max)\n \t\treturn PJLIB_UTIL_EDNSINNAMEPTR;\n \n \t\
    \    p += (label_len + 1);\n@@ -170,9 +175,6 @@ static pj_status_t get_name_len(int\
    \ rec_counter, const pj_uint8_t *pkt,\n \t\t++label_len;\n \t    \n \t    *name_len\
    \ += label_len;\n-\n-\t    if (p >= max)\n-\t\treturn PJLIB_UTIL_EDNSINSIZE;\n\
    \ \t}\n     }\n     ++p;\n@@ -222,8 +224,13 @@ static pj_status_t get_name(int\
    \ rec_counter, const pj_uint8_t *pkt,\n \t} else {\n \t    unsigned label_len\
    \ = *p;\n \n-\t    /* Check that label length is valid */\n-\t    if (pkt+label_len\
    \ > max)\n+\t    /* Check that label length is valid.\n+\t     * Each label consists\
    \ of an octet length (of size 1) followed\n+\t     * by the octet of the specified\
    \ length (label_len). Then it\n+\t     * must be followed by either another label's\
    \ octet length or\n+\t     * a zero length octet (that terminates the sequence).\n\
    +\t     */\n+\t    if (p+1+label_len+1 > max)\n \t\treturn PJLIB_UTIL_EDNSINNAMEPTR;\n\
    \ \n \t    pj_memcpy(name->ptr + name->slen, p+1, label_len);\n@@ -234,9 +241,6\
    \ @@ static pj_status_t get_name(int rec_counter, const pj_uint8_t *pkt,\n \t\t\
    *(name->ptr + name->slen) = '.';\n \t\t++name->slen;\n \t    }\n-\n-\t    if (p\
    \ >= max)\n-\t\treturn PJLIB_UTIL_EDNSINSIZE;\n \t}\n     }\n \n@@ -269,6 +273,10\
    \ @@ static pj_status_t parse_query(pj_dns_parsed_query *q, pj_pool_t *pool,\n\
    \ \n     p = (start + name_part_len);\n \n+    /* Check the size can accomodate\
    \ next few fields. */\n+    if (p + 4 > max)\n+    \treturn PJLIB_UTIL_EDNSINSIZE;\n\
    +\n     /* Get the type */\n     pj_memcpy(&q->type, p, 2);\n     q->type = pj_ntohs(q->type);"
  identifiers:
  - CVE-2022-24793
  - CWE-120
  overview: PJSIP is a free and open source multimedia communication library written
    in C. A buffer overflow vulnerability in versions 2.12 and prior affects applications
    that use PJSIP DNS resolution. It doesn't affect PJSIP users who utilize an external
    resolver. This vulnerability is related to CVE-2023-27585. The difference is that
    this issue is in parsing the query record `parse_rr()`, while the issue in CVE-2023-27585
    is in `parse_query()`. A patch is available in the `master` branch of the `pjsip/pjproject`
    GitHub repository. A workaround is to disable DNS resolution in PJSIP config (by
    setting `nameserver_count` to zero) or use an external resolver instead.
  references:
  - source: security-advisories@github.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/pjsip/pjproject/commit/9fae8f43accef8ea65d4a8ae9cdf297c46cfe29a
  - source: security-advisories@github.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/pjsip/pjproject/security/advisories/GHSA-p6g5-v97c-w5q4
  - source: security-advisories@github.com
    tags:
    - Mailing List
    - Third Party Advisory
    url: https://lists.debian.org/debian-lts-announce/2022/05/msg00047.html
  - source: security-advisories@github.com
    tags:
    - Mailing List
    - Third Party Advisory
    url: https://lists.debian.org/debian-lts-announce/2022/11/msg00021.html
  - source: security-advisories@github.com
    url: https://lists.debian.org/debian-lts-announce/2023/08/msg00038.html
  - source: security-advisories@github.com
    tags:
    - Third Party Advisory
    url: https://security.gentoo.org/glsa/202210-37
  - source: security-advisories@github.com
    tags:
    - Third Party Advisory
    url: https://www.debian.org/security/2022/dsa-5285
  title: PJSIP is a free and open source multimedia communication library written
    in C. A buffer overflow vulnerability in versions 2.12 and prior affects applications
    that use PJSIP DNS resolution. It doesn't affect PJSIP users who utilize an external
    resolver. This vulnerability is related to CVE-2023-27585. The difference is that
    this issue is in parsing the query record `parse_rr()`, while the issue in CVE-2023-27585
    is in `parse_query()`. A patch is available in the `master` branch of the `pjsip/pjproject`
    GitHub repository. A workaround is to disable DNS resolution in PJSIP config (by
    setting `nameserver_count` to zero) or use an external resolver instead.
- diff_content:
  - "--- a/fs/jbd2/transaction.c\n+++ b/fs/jbd2/transaction.c\n@@ -842,27 +842,38\
    \ @@ EXPORT_SYMBOL(jbd2_journal_restart);\n  */\n void jbd2_journal_wait_updates(journal_t\
    \ *journal)\n {\n-\ttransaction_t *commit_transaction = journal->j_running_transaction;\n\
    +\tDEFINE_WAIT(wait);\n \n-\tif (!commit_transaction)\n-\t\treturn;\n+\twhile\
    \ (1) {\n+\t\t/*\n+\t\t * Note that the running transaction can get freed under\
    \ us if\n+\t\t * this transaction is getting committed in\n+\t\t * jbd2_journal_commit_transaction()\
    \ ->\n+\t\t * jbd2_journal_free_transaction(). This can only happen when we\n\
    +\t\t * release j_state_lock -> schedule() -> acquire j_state_lock.\n+\t\t * Hence\
    \ we should everytime retrieve new j_running_transaction\n+\t\t * value (after\
    \ j_state_lock release acquire cycle), else it may\n+\t\t * lead to use-after-free\
    \ of old freed transaction.\n+\t\t */\n+\t\ttransaction_t *transaction = journal->j_running_transaction;\n\
    \ \n-\tspin_lock(&commit_transaction->t_handle_lock);\n-\twhile (atomic_read(&commit_transaction->t_updates))\
    \ {\n-\t\tDEFINE_WAIT(wait);\n+\t\tif (!transaction)\n+\t\t\tbreak;\n \n+\t\t\
    spin_lock(&transaction->t_handle_lock);\n \t\tprepare_to_wait(&journal->j_wait_updates,\
    \ &wait,\n-\t\t\t\t\tTASK_UNINTERRUPTIBLE);\n-\t\tif (atomic_read(&commit_transaction->t_updates))\
    \ {\n-\t\t\tspin_unlock(&commit_transaction->t_handle_lock);\n-\t\t\twrite_unlock(&journal->j_state_lock);\n\
    -\t\t\tschedule();\n-\t\t\twrite_lock(&journal->j_state_lock);\n-\t\t\tspin_lock(&commit_transaction->t_handle_lock);\n\
    +\t\t\t\tTASK_UNINTERRUPTIBLE);\n+\t\tif (!atomic_read(&transaction->t_updates))\
    \ {\n+\t\t\tspin_unlock(&transaction->t_handle_lock);\n+\t\t\tfinish_wait(&journal->j_wait_updates,\
    \ &wait);\n+\t\t\tbreak;\n \t\t}\n+\t\tspin_unlock(&transaction->t_handle_lock);\n\
    +\t\twrite_unlock(&journal->j_state_lock);\n+\t\tschedule();\n \t\tfinish_wait(&journal->j_wait_updates,\
    \ &wait);\n+\t\twrite_lock(&journal->j_state_lock);\n \t}\n-\tspin_unlock(&commit_transaction->t_handle_lock);\n\
    \ }\n \n /**\n@@ -877,8 +888,6 @@ void jbd2_journal_wait_updates(journal_t *journal)\n\
    \  */\n void jbd2_journal_lock_updates(journal_t *journal)\n {\n-\tDEFINE_WAIT(wait);\n\
    -\n \tjbd2_might_wait_for_commit(journal);\n \n \twrite_lock(&journal->j_state_lock);"
  identifiers:
  - CVE-2022-28796
  - CWE-362
  overview: jbd2_journal_wait_updates in fs/jbd2/transaction.c in the Linux kernel
    before 5.17.1 has a use-after-free caused by a transaction_t race condition.
  references:
  - source: cve@mitre.org
    tags:
    - Release Notes
    - Vendor Advisory
    url: https://cdn.kernel.org/pub/linux/kernel/v5.x/ChangeLog-5.17.1
  - source: cve@mitre.org
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/torvalds/linux/commit/cc16eecae687912238ee6efbff71ad31e2bc414e
  - source: cve@mitre.org
    tags:
    - Third Party Advisory
    url: https://security.netapp.com/advisory/ntap-20220506-0006/
  title: jbd2_journal_wait_updates in fs/jbd2/transaction.c in the Linux kernel before
    5.17.1 has a use-after-free caused by a transaction_t race condition.
- diff_content:
  - "--- a/lparser.c\n+++ b/lparser.c\n@@ -468,6 +468,7 @@ static void singlevar (LexState\
    \ *ls, expdesc *var) {\n     expdesc key;\n     singlevaraux(fs, ls->envn, var,\
    \ 1);  /* get environment variable */\n     lua_assert(var->k != VVOID);  /* this\
    \ one must exist */\n+    luaK_exp2anyregup(fs, var);  /* but could be a constant\
    \ */\n     codestring(&key, varname);  /* key is variable name */\n     luaK_indexed(fs,\
    \ var, &key);  /* env[varname] */\n   }"
  identifiers:
  - CVE-2022-28805
  - CWE-125
  overview: singlevar in lparser.c in Lua from (including) 5.4.0 up to (excluding)
    5.4.4 lacks a certain luaK_exp2anyregup call, leading to a heap-based buffer over-read
    that might affect a system that compiles untrusted Lua code.
  references:
  - source: cve@mitre.org
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/lua/lua/commit/1f3c6f4534c6411313361697d98d1145a1f030fa
  - source: cve@mitre.org
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/RJNJ66IFDUKWJJZXHGOLRGIA3HWWC36R/
  - source: cve@mitre.org
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/UHYZOEFDVLVAD6EEP4CDW6DNONIVVHPA/
  - source: cve@mitre.org
    tags:
    - Exploit
    - Mailing List
    - Third Party Advisory
    url: https://lua-users.org/lists/lua-l/2022-02/msg00001.html
  - source: cve@mitre.org
    tags:
    - Exploit
    - Mailing List
    - Third Party Advisory
    url: https://lua-users.org/lists/lua-l/2022-02/msg00070.html
  - source: cve@mitre.org
    tags:
    - Exploit
    - Mailing List
    - Third Party Advisory
    url: https://lua-users.org/lists/lua-l/2022-04/msg00009.html
  - source: cve@mitre.org
    url: https://security.gentoo.org/glsa/202305-23
  title: singlevar in lparser.c in Lua from (including) 5.4.0 up to (excluding) 5.4.4
    lacks a certain luaK_exp2anyregup call, leading to a heap-based buffer over-read
    that might affect a system that compiles untrusted Lua code.
- diff_content:
  - "--- a/libr/bin/format/ne/ne.c\n+++ b/libr/bin/format/ne/ne.c\n@@ -115,7 +115,7\
    \ @@ RList *r_bin_ne_get_symbols(r_bin_ne_obj_t *bin) {\n \t}\n \tRList *entries\
    \ = r_bin_ne_get_entrypoints (bin);\n \tbool resident = true, first = true;\n\
    -\twhile (true) {\n+\twhile (entries) {\n \t\tut8 sz = r_buf_read8_at (bin->buf,\
    \ off);\n \t\tif (!sz) {\n \t\t\tfirst = true;\n@@ -352,6 +352,9 @@ RList *r_bin_ne_get_imports(r_bin_ne_obj_t\
    \ *bin) {\n }\n \n RList *r_bin_ne_get_entrypoints(r_bin_ne_obj_t *bin) {\n+\t\
    if (!bin->entry_table) {\n+\t\treturn NULL;\n+\t}\n \tRList *entries = r_list_newf\
    \ (free);\n \tif (!entries) {\n \t\treturn NULL;"
  identifiers:
  - CVE-2022-1283
  - CWE-476
  overview: NULL Pointer Dereference in r_bin_ne_get_entrypoints function in GitHub
    repository radareorg/radare2 prior to 5.6.8. This vulnerability allows attackers
    to cause a denial of service (application crash).
  references:
  - source: security@huntr.dev
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/radareorg/radare2/commit/18d1d064bf599a255d55f09fca3104776fc34a67
  - source: security@huntr.dev
    tags:
    - Exploit
    - Patch
    - Third Party Advisory
    url: https://huntr.dev/bounties/bfeb8fb8-644d-4587-80d4-cb704c404013
  title: NULL Pointer Dereference in r_bin_ne_get_entrypoints function in GitHub repository
    radareorg/radare2 prior to 5.6.8. This vulnerability allows attackers to cause
    a denial of service (application crash).
- diff_content:
  - "--- a/libr/core/canal.c\n+++ b/libr/core/canal.c\n@@ -5295,10 +5295,6 @@ R_API\
    \ void r_core_anal_esil(RCore *core, const char *str, const char *target) {\n\
    \ \t\tarch = R2_ARCH_MIPS;\n \t}\n \n-\tconst char *sn = r_reg_get_name (core->anal->reg,\
    \ R_REG_NAME_SN);\n-\tif (!sn) {\n-\t\teprintf (\"Warning: No SN reg alias for\
    \ current architecture.\\n\");\n-\t}\n \tr_reg_arena_push (core->anal->reg);\n\
    \ \n \tIterCtx ictx = { start, end, fcn, NULL };\n@@ -5409,6 +5405,10 @@ R_API\
    \ void r_core_anal_esil(RCore *core, const char *str, const char *target) {\n\
    \ \t\t\t\tgoto repeat;\n \t\t\t}\n \t\t}\n+\t\tconst char *sn = r_reg_get_name\
    \ (core->anal->reg, R_REG_NAME_SN);\n+\t\tif (!sn) {\n+\t\t\teprintf (\"Warning:\
    \ No SN reg alias for current architecture.\\n\");\n+\t\t}\n \t\tif (sn && op.type\
    \ == R_ANAL_OP_TYPE_SWI) {\n \t\t\tr_strf_buffer (64);\n \t\t\tr_flag_space_set\
    \ (core->flags, R_FLAGS_FS_SYSCALLS);"
  identifiers:
  - CVE-2022-1284
  - CWE-416
  overview: heap-use-after-free in GitHub repository radareorg/radare2 prior to 5.6.8.
    This vulnerability is capable of inducing denial of service.
  references:
  - source: security@huntr.dev
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/radareorg/radare2/commit/64a82e284dddabaeb549228380103b57dead32a6
  - source: security@huntr.dev
    tags:
    - Exploit
    - Patch
    - Third Party Advisory
    url: https://huntr.dev/bounties/e98ad92c-3a64-48fb-84d4-d13afdbcbdd7
  title: heap-use-after-free in GitHub repository radareorg/radare2 prior to 5.6.8.
    This vulnerability is capable of inducing denial of service.
- diff_content:
  - "--- a/mrbgems/mruby-compiler/core/codegen.c\n+++ b/mrbgems/mruby-compiler/core/codegen.c\n\
    @@ -1905,7 +1905,7 @@ gen_assignment(codegen_scope *s, node *tree, node *rhs,\
    \ int sp, int val)\n           }\n         }\n         if (tree->cdr->car) { \
    \      /* keyword arguments */\n-          if (n == 14) {\n+          if (n ==\
    \ 13 || n == 14) {\n             pop_n(n);\n             genop_2(s, OP_ARRAY,\
    \ cursp(), n);\n             push();"
  identifiers:
  - CVE-2022-1276
  - CWE-125
  overview: Out-of-bounds Read in mrb_get_args in GitHub repository mruby/mruby prior
    to 3.2. Possible arbitrary code execution if being exploited.
  references:
  - source: security@huntr.dev
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/mruby/mruby/commit/c8c083cb750606b2da81582cd8e43b442bb143e6
  - source: security@huntr.dev
    tags:
    - Exploit
    - Third Party Advisory
    url: https://huntr.dev/bounties/6ea041d1-e2aa-472c-bf3e-da5fa8726c25
  title: Out-of-bounds Read in mrb_get_args in GitHub repository mruby/mruby prior
    to 3.2. Possible arbitrary code execution if being exploited.
- diff_content:
  - "--- a/src/class.c\n+++ b/src/class.c\n@@ -2361,7 +2361,10 @@ mrb_remove_method(mrb_state\
    \ *mrb, struct RClass *c, mrb_sym mid)\n   MRB_CLASS_ORIGIN(c);\n   h = c->mt;\n\
    \ \n-  if (h && mt_del(mrb, h, mid)) return;\n+  if (h && mt_del(mrb, h, mid))\
    \ {\n+    mrb_mc_clear_by_class(mrb, c);\n+    return;\n+  }\n   mrb_name_error(mrb,\
    \ mid, \"method '%n' not defined in %C\", mid, c);\n }\n "
  identifiers:
  - CVE-2022-1286
  - CWE-787
  overview: heap-buffer-overflow in mrb_vm_exec in mruby/mruby in GitHub repository
    mruby/mruby prior to 3.2. Possible arbitrary code execution if being exploited.
  references:
  - source: security@huntr.dev
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/mruby/mruby/commit/b1d0296a937fe278239bdfac840a3fd0e93b3ee9
  - source: security@huntr.dev
    tags:
    - Exploit
    - Third Party Advisory
    url: https://huntr.dev/bounties/f918376e-b488-4113-963d-ffe8716e4189
  title: heap-buffer-overflow in mrb_vm_exec in mruby/mruby in GitHub repository mruby/mruby
    prior to 3.2. Possible arbitrary code execution if being exploited.
- diff_content:
  - "--- a/src/gui/pattern.cpp\n+++ b/src/gui/pattern.cpp\n@@ -282,27 +282,33 @@ inline\
    \ void FurnaceGUI::patternRow(int i, bool isPlaying, float lineHeight, int\n \
    \          sprintf(id,\"..##PE%d_%d_%d\",k,i,j);\n           ImGui::PushStyleColor(ImGuiCol_Text,inactiveColor);\n\
    \         } else {\n-          sprintf(id,\"%.2X##PE%d_%d_%d\",pat->data[i][index],k,i,j);\n\
    -          if (pat->data[i][index]<0x10) {\n-            ImGui::PushStyleColor(ImGuiCol_Text,uiColors[fxColors[pat->data[i][index]]]);\n\
    -          } else if (pat->data[i][index]<0x20) {\n-            ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_EFFECT_SYS_PRIMARY]);\n\
    -          } else if (pat->data[i][index]<0x30) {\n-            ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_EFFECT_SYS_SECONDARY]);\n\
    -          } else if (pat->data[i][index]<0x48) {\n-            ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_EFFECT_SYS_PRIMARY]);\n\
    -          } else if (pat->data[i][index]<0x90) {\n-            ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_EFFECT_INVALID]);\n\
    -          } else if (pat->data[i][index]<0xa0) {\n-            ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_EFFECT_MISC]);\n\
    -          } else if (pat->data[i][index]<0xc0) {\n-            ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_EFFECT_INVALID]);\n\
    -          } else if (pat->data[i][index]<0xd0) {\n-            ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_EFFECT_SPEED]);\n\
    -          } else if (pat->data[i][index]<0xe0) {\n+          if (pat->data[i][index]>0xff)\
    \ {\n+            sprintf(id,\"??##PE%d_%d_%d\",k,i,j);\n             ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_EFFECT_INVALID]);\n\
    \           } else {\n-            ImGui::PushStyleColor(ImGuiCol_Text,uiColors[extFxColors[pat->data[i][index]-0xe0]]);\n\
    +            const unsigned char data=pat->data[i][index];\n+            sprintf(id,\"\
    %.2X##PE%d_%d_%d\",data,k,i,j);\n+            if (data<0x10) {\n+            \
    \  ImGui::PushStyleColor(ImGuiCol_Text,uiColors[fxColors[data]]);\n+         \
    \   } else if (data<0x20) {\n+              ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_EFFECT_SYS_PRIMARY]);\n\
    +            } else if (data<0x30) {\n+              ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_EFFECT_SYS_SECONDARY]);\n\
    +            } else if (data<0x48) {\n+              ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_EFFECT_SYS_PRIMARY]);\n\
    +            } else if (data<0x90) {\n+              ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_EFFECT_INVALID]);\n\
    +            } else if (data<0xa0) {\n+              ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_EFFECT_MISC]);\n\
    +            } else if (data<0xc0) {\n+              ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_EFFECT_INVALID]);\n\
    +            } else if (data<0xd0) {\n+              ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_EFFECT_SPEED]);\n\
    +            } else if (data<0xe0) {\n+              ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_EFFECT_INVALID]);\n\
    +            } else {\n+              ImGui::PushStyleColor(ImGuiCol_Text,uiColors[extFxColors[data-0xe0]]);\n\
    +            }\n           }\n         }\n         ImGui::SameLine(0.0f,0.0f);"
  identifiers:
  - CVE-2022-1289
  - NVD-CWE-noinfo
  overview: A denial of service vulnerability was found in tildearrow Furnace. It
    has been classified as problematic. This is due to an incomplete fix of CVE-2022-1211.
    It is possible to initiate the attack remotely but it requires user interaction.
    The issue got fixed with the patch 0eb02422d5161767e9983bdaa5c429762d3477ce.
  references:
  - source: cna@vuldb.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/tildearrow/furnace/commit/0eb02422d5161767e9983bdaa5c429762d3477ce
  - source: cna@vuldb.com
    tags:
    - Exploit
    - Issue Tracking
    - Third Party Advisory
    url: https://github.com/tildearrow/furnace/issues/325#issuecomment-1094139655
  - source: cna@vuldb.com
    tags:
    - Third Party Advisory
    url: https://vuldb.com/?id.196755
  title: A denial of service vulnerability was found in tildearrow Furnace. It has
    been classified as problematic. This is due to an incomplete fix of CVE-2022-1211.
    It is possible to initiate the attack remotely but it requires user interaction.
    The issue got fixed with the patch 0eb02422d5161767e9983bdaa5c429762d3477ce.
- diff_content:
  - "--- a/libr/bin/format/ne/ne.c\n+++ b/libr/bin/format/ne/ne.c\n@@ -1,7 +1,6 @@\n\
    \ /* radare - LGPL - Copyright 2019-2022 - GustavoLCR */\n \n #include \"ne.h\"\
    \n-#define NE_BUG 0\n \n static char *__get_target_os(r_bin_ne_obj_t *bin) {\n\
    \ \tswitch (bin->ne_header->targOS) {\n@@ -505,25 +504,18 @@ RList *r_bin_ne_get_relocs(r_bin_ne_obj_t\
    \ *bin) {\n \t\t\t\t\tfree (reloc);\n \t\t\t\t\tbreak;\n \t\t\t\t}\n-\t\t\t\t\
    char *name;\n-#if NE_BUG\n-\t\t\t\tif (rel.index > 0 && rel.index < bin->ne_header->ModRefs)\
    \ {\n-\t\t\t\t\toffset = modref[rel.index - 1] + bin->header_offset + bin->ne_header->ImportNameTable;\n\
    -\t\t\t\t\tname = __read_nonnull_str_at (bin->buf, offset);\n-\t\t\t\t} else {\n\
    -\t\t\t\t\tname = r_str_newf (\"UnknownModule%d_%x\", rel.index, off); // ????\n\
    -\t\t\t\t}\n-#else\n+\t\t\t\tchar *name = NULL;\n \t\t\t\tif (rel.index > bin->ne_header->ModRefs)\
    \ {\n \t\t\t\t\tname = r_str_newf (\"UnknownModule%d_%x\", rel.index, off); //\
    \ ????\n-\t\t\t\t} else {\n+\t\t\t\t} else if (rel.index > 0) {\n \t\t\t\t\toffset\
    \ = modref[rel.index - 1] + bin->header_offset + bin->ne_header->ImportNameTable;\n\
    \ \t\t\t\t\tname = __read_nonnull_str_at (bin->buf, offset);\n \t\t\t\t}\n-#endif\n\
    \ \t\t\t\tif (rel.flags & IMPORTED_ORD) {\n \t\t\t\t\timp->ordinal = rel.func_ord;\n\
    -\t\t\t\t\timp->name = r_str_newf (\"%s.%s\", name, __func_name_from_ord(name,\
    \ rel.func_ord));\n+\t\t\t\t\tchar *fname = __func_name_from_ord (name, rel.func_ord);\n\
    +\t\t\t\t\timp->name = r_str_newf (\"%s.%s\", name, fname);\n+\t\t\t\t\tfree (fname);\n\
    \ \t\t\t\t} else {\n \t\t\t\t\toffset = bin->header_offset + bin->ne_header->ImportNameTable\
    \ + rel.name_off;\n \t\t\t\t\tchar *func = __read_nonnull_str_at (bin->buf, offset);\n\
    @@ -566,6 +558,7 @@ RList *r_bin_ne_get_relocs(r_bin_ne_obj_t *bin) {\n \t\t\t\
    \tr_list_append (relocs, reloc);\n \t\t\t} else {\n \t\t\t\tdo {\n+#define NE_BUG\
    \ 0\n #if NE_BUG\n \t\t\t\t\tif (reloc->paddr + 4 < r_buf_size (bin->buf)) {\n\
    \ \t\t\t\t\t\tbreak;"
  identifiers:
  - CVE-2022-1296
  - CWE-125
  overview: Out-of-bounds read in `r_bin_ne_get_relocs` function in GitHub repository
    radareorg/radare2 prior to 5.6.8. This vulnerability may allow attackers to read
    sensitive information or cause a crash.
  references:
  - source: security@huntr.dev
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/radareorg/radare2/commit/153bcdc29f11cd8c90e7d639a7405450f644ddb6
  - source: security@huntr.dev
    tags:
    - Exploit
    - Third Party Advisory
    url: https://huntr.dev/bounties/52b57274-0e1a-4d61-ab29-1373b555fea0
  title: Out-of-bounds read in `r_bin_ne_get_relocs` function in GitHub repository
    radareorg/radare2 prior to 5.6.8. This vulnerability may allow attackers to read
    sensitive information or cause a crash.
- diff_content:
  - "--- a/libr/bin/format/ne/ne.c\n+++ b/libr/bin/format/ne/ne.c\n@@ -408,14 +408,21\
    \ @@ RList *r_bin_ne_get_entrypoints(r_bin_ne_obj_t *bin) {\n \t\t\t\toff += 2;\n\
    \ \t\t\t\tut8 segnum = *(bin->entry_table + off);\n \t\t\t\toff++;\n-\t\t\t\t\
    ut16 segoff = *(ut16 *)(bin->entry_table + off);\n-\t\t\t\tif (segnum > 0) {\n\
    +\t\t\t\tif (off > bin->ne_header->EntryTableLength) {\n+\t\t\t\t\tbreak;\n+\t\
    \t\t\t}\n+\t\t\t\tut16 segoff = r_read_le16 (bin->entry_table + off);\n+\t\t\t\
    \tif (segnum > 0 && segnum < bin->ne_header->SegCount) {\n \t\t\t\t\tentry->paddr\
    \ = (ut64)bin->segment_entries[segnum - 1].offset * bin->alignment + segoff;\n\
    \ \t\t\t\t}\n \t\t\t} else { // Fixed\n+\t\t\t\tif (off + 2 >= bin->ne_header->EntryTableLength)\
    \ {\n+\t\t\t\t\tbreak;\n+\t\t\t\t}\n+\t\t\t\tut16 delta = r_read_le16 (bin->entry_table\
    \ + off);\n \t\t\t\tif (bundle_type < bin->ne_header->SegCount) {\n \t\t\t\t\t\
    entry->paddr = (ut64)bin->segment_entries[bundle_type - 1].offset\n-\t\t\t\t\t\
    \t* bin->alignment + *(ut16 *)(bin->entry_table + off);\n+\t\t\t\t\t\t* bin->alignment\
    \ + delta;\n \t\t\t\t}\n \t\t\t}\n \t\t\toff += 2;"
  identifiers:
  - CVE-2022-1297
  - CWE-125
  overview: Out-of-bounds Read in r_bin_ne_get_entrypoints function in GitHub repository
    radareorg/radare2 prior to 5.6.8. This vulnerability may allow attackers to read
    sensitive information or cause a crash.
  references:
  - source: security@huntr.dev
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/radareorg/radare2/commit/0a557045476a2969c7079aec9eeb29d02f2809c6
  - source: security@huntr.dev
    tags:
    - Exploit
    - Third Party Advisory
    url: https://huntr.dev/bounties/ec538fa4-06c6-4050-a141-f60153ddeaac
  title: Out-of-bounds Read in r_bin_ne_get_entrypoints function in GitHub repository
    radareorg/radare2 prior to 5.6.8. This vulnerability may allow attackers to read
    sensitive information or cause a crash.
- diff_content:
  - "--- a/drivers/infiniband/ulp/rtrs/rtrs-clt.c\n+++ b/drivers/infiniband/ulp/rtrs/rtrs-clt.c\n\
    @@ -2682,6 +2682,8 @@ static void rtrs_clt_dev_release(struct device *dev)\n \t\
    struct rtrs_clt_sess *clt = container_of(dev, struct rtrs_clt_sess,\n \t\t\t\t\
    \t\t dev);\n \n+\tmutex_destroy(&clt->paths_ev_mutex);\n+\tmutex_destroy(&clt->paths_mutex);\n\
    \ \tkfree(clt);\n }\n \n@@ -2711,6 +2713,8 @@ static struct rtrs_clt_sess *alloc_clt(const\
    \ char *sessname, size_t paths_num,\n \t\treturn ERR_PTR(-ENOMEM);\n \t}\n \n\
    +\tclt->dev.class = rtrs_clt_dev_class;\n+\tclt->dev.release = rtrs_clt_dev_release;\n\
    \ \tuuid_gen(&clt->paths_uuid);\n \tINIT_LIST_HEAD_RCU(&clt->paths_list);\n \t\
    clt->paths_num = paths_num;\n@@ -2727,53 +2731,52 @@ static struct rtrs_clt_sess\
    \ *alloc_clt(const char *sessname, size_t paths_num,\n \tinit_waitqueue_head(&clt->permits_wait);\n\
    \ \tmutex_init(&clt->paths_ev_mutex);\n \tmutex_init(&clt->paths_mutex);\n+\t\
    device_initialize(&clt->dev);\n \n-\tclt->dev.class = rtrs_clt_dev_class;\n-\t\
    clt->dev.release = rtrs_clt_dev_release;\n \terr = dev_set_name(&clt->dev, \"\
    %s\", sessname);\n \tif (err)\n-\t\tgoto err;\n+\t\tgoto err_put;\n+\n \t/*\n\
    \ \t * Suppress user space notification until\n \t * sysfs files are created\n\
    \ \t */\n \tdev_set_uevent_suppress(&clt->dev, true);\n-\terr = device_register(&clt->dev);\n\
    -\tif (err) {\n-\t\tput_device(&clt->dev);\n-\t\tgoto err;\n-\t}\n+\terr = device_add(&clt->dev);\n\
    +\tif (err)\n+\t\tgoto err_put;\n \n \tclt->kobj_paths = kobject_create_and_add(\"\
    paths\", &clt->dev.kobj);\n \tif (!clt->kobj_paths) {\n \t\terr = -ENOMEM;\n-\t\
    \tgoto err_dev;\n+\t\tgoto err_del;\n \t}\n \terr = rtrs_clt_create_sysfs_root_files(clt);\n\
    \ \tif (err) {\n \t\tkobject_del(clt->kobj_paths);\n \t\tkobject_put(clt->kobj_paths);\n\
    -\t\tgoto err_dev;\n+\t\tgoto err_del;\n \t}\n \tdev_set_uevent_suppress(&clt->dev,\
    \ false);\n \tkobject_uevent(&clt->dev.kobj, KOBJ_ADD);\n \n \treturn clt;\n-err_dev:\n\
    -\tdevice_unregister(&clt->dev);\n-err:\n+err_del:\n+\tdevice_del(&clt->dev);\n\
    +err_put:\n \tfree_percpu(clt->pcpu_path);\n-\tkfree(clt);\n+\tput_device(&clt->dev);\n\
    \ \treturn ERR_PTR(err);\n }\n \n static void free_clt(struct rtrs_clt_sess *clt)\n\
    \ {\n \tfree_permits(clt);\n \tfree_percpu(clt->pcpu_path);\n-\tmutex_destroy(&clt->paths_ev_mutex);\n\
    -\tmutex_destroy(&clt->paths_mutex);\n-\t/* release callback will free clt in\
    \ last put */\n+\n+\t/*\n+\t * release callback will free clt and destroy mutexes\
    \ in last put\n+\t */\n \tdevice_unregister(&clt->dev);\n }\n "
  identifiers:
  - CVE-2022-29156
  - CWE-415
  overview: drivers/infiniband/ulp/rtrs/rtrs-clt.c in the Linux kernel before 5.16.12
    has a double free related to rtrs_clt_dev_release.
  references:
  - source: cve@mitre.org
    tags:
    - Mailing List
    - Vendor Advisory
    url: https://cdn.kernel.org/pub/linux/kernel/v5.x/ChangeLog-5.16.12
  - source: cve@mitre.org
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/torvalds/linux/commit/8700af2cc18c919b2a83e74e0479038fd113c15d
  - source: cve@mitre.org
    tags:
    - Third Party Advisory
    url: https://security.netapp.com/advisory/ntap-20220602-0002/
  title: drivers/infiniband/ulp/rtrs/rtrs-clt.c in the Linux kernel before 5.16.12
    has a double free related to rtrs_clt_dev_release.
- diff_content:
  - "--- a/src/njs_function.c\n+++ b/src/njs_function.c\n@@ -811,9 +811,13 @@ njs_function_frame_save(njs_vm_t\
    \ *vm, njs_frame_t *frame, u_char *pc)\n     njs_native_frame_t  *active, *native;\n\
    \ \n     *frame = *vm->active_frame;\n+\n     frame->previous_active_frame = NULL;\n\
    \ \n     native = &frame->native;\n+    native->size = 0;\n+    native->free =\
    \ NULL;\n+    native->free_size = 0;\n \n     active = &vm->active_frame->native;\n\
    \     value_count = njs_function_frame_value_count(active);"
  identifiers:
  - CVE-2022-27007
  - CWE-416
  overview: nginx njs 0.7.2 is affected suffers from Use-after-free in njs_function_frame_alloc()
    when it try to invoke from a restored frame saved with njs_function_frame_save().
  references:
  - source: cve@mitre.org
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/nginx/njs/commit/ad48705bf1f04b4221a5f5b07715ac48b3160d53
  - source: cve@mitre.org
    tags:
    - Exploit
    - Issue Tracking
    - Patch
    - Third Party Advisory
    url: https://github.com/nginx/njs/issues/469
  - source: cve@mitre.org
    tags:
    - Third Party Advisory
    url: https://security.netapp.com/advisory/ntap-20220519-0008/
  title: nginx njs 0.7.2 is affected suffers from Use-after-free in njs_function_frame_alloc()
    when it try to invoke from a restored frame saved with njs_function_frame_save().
- diff_content:
  - "--- a/src/njs_array.c\n+++ b/src/njs_array.c\n@@ -364,6 +364,8 @@ njs_array_expand(njs_vm_t\
    \ *vm, njs_array_t *array, uint32_t prepend,\n     uint64_t     size;\n     njs_value_t\
    \  *start, *old;\n \n+    njs_assert(array->object.fast_array);\n+\n     free_before\
    \ = array->start - array->data;\n     free_after = array->size - array->length\
    \ - free_before;\n \n@@ -1754,9 +1756,10 @@ njs_array_prototype_concat(njs_vm_t\
    \ *vm, njs_value_t *args, njs_uint_t nargs,\n                         njs_set_invalid(&retval);\n\
    \                     }\n \n-                    ret = njs_array_add(vm, array,\
    \ &retval);\n-                    if (njs_slow_path(ret != NJS_OK)) {\n-     \
    \                   return NJS_ERROR;\n+                    ret = njs_value_property_i64_set(vm,\
    \ &this, length,\n+                                                     &retval);\n\
    +                    if (njs_slow_path(ret == NJS_ERROR)) {\n+               \
    \         return ret;\n                     }\n                 }\n "
  - "--- a/src/test/njs_unit_test.c\n+++ b/src/test/njs_unit_test.c\n@@ -4253,6 +4253,11\
    \ @@ static njs_unit_test_t  njs_test[] =\n               \"njs.dump([a[0], a[33],a.length])\"\
    ),\n       njs_str(\"[1,1,65]\") },\n \n+    { njs_str(\"var a = [1]; a[1111111]\
    \ = 2;\"\n+              \"var a2 = [3].concat(a, [4]);\"\n+              \"njs.dump(a2)\"\
    ),\n+      njs_str(\"[3,1,<1111110 empty items>,2,4]\") },\n+\n     { njs_str(\"\
    var re = /abc/; re[Symbol.isConcatSpreadable] = true;\"\n               \"re[0]\
    \ = 1, re[1] = 2, re[2] = 3, re.length = 3;\"\n               \"[].concat(re)\"\
    ),"
  identifiers:
  - CVE-2022-27008
  - CWE-120
  overview: nginx njs 0.7.2 is vulnerable to Buffer Overflow. Type confused in Array.prototype.concat()
    when a slow array appended element is fast array.
  references:
  - source: cve@mitre.org
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/nginx/njs/commit/e673ae41a998d1391bd562edb2ed6d49db7cc716
  - source: cve@mitre.org
    tags:
    - Exploit
    - Issue Tracking
    - Patch
    - Third Party Advisory
    url: https://github.com/nginx/njs/issues/471
  - source: cve@mitre.org
    tags:
    - Third Party Advisory
    url: https://security.netapp.com/advisory/ntap-20220519-0008/
  title: nginx njs 0.7.2 is vulnerable to Buffer Overflow. Type confused in Array.prototype.concat()
    when a slow array appended element is fast array.
- diff_content:
  - "--- a/handler.c\n+++ b/handler.c\n@@ -404,9 +404,9 @@ static void mutt_decode_uuencoded\
    \ (STATE *s, LOFF_T len, int istext, iconv_t cd)\n     pt = tmps;\n     linelen\
    \ = decode_byte (*pt);\n     pt++;\n-    for (c = 0; c < linelen;)\n+    for (c\
    \ = 0; c < linelen && *pt;)\n     {\n-      for (l = 2; l <= 6; l += 2)\n+   \
    \   for (l = 2; l <= 6 && *pt && *(pt + 1); l += 2)\n       {\n \tout = decode_byte\
    \ (*pt) << l;\n \tpt++;\n"
  identifiers:
  - CVE-2022-1328
  - CWE-120
  overview: Buffer Overflow in uudecoder in Mutt affecting all versions starting from
    0.94.13 before 2.2.3 allows read past end of input line
  references:
  - source: cve@gitlab.com
    tags:
    - Third Party Advisory
    url: https://gitlab.com/gitlab-org/cves/-/blob/master/2022/CVE-2022-1328.json
  - source: cve@gitlab.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://gitlab.com/muttmua/mutt/-/commit/e5ed080c00e59701ca62ef9b2a6d2612ebf765a5
  - source: cve@gitlab.com
    tags:
    - Exploit
    - Issue Tracking
    - Patch
    - Third Party Advisory
    url: https://gitlab.com/muttmua/mutt/-/issues/404
  title: Buffer Overflow in uudecoder in Mutt affecting all versions starting from
    0.94.13 before 2.2.3 allows read past end of input line
- diff_content:
  - "--- a/lrzip.c\n+++ b/lrzip.c\n@@ -1338,7 +1338,7 @@ bool initialise_control(rzip_control\
    \ *control)\n \tcontrol->msgerr = stderr;\n \tregister_outputfile(control, control->msgout);\n\
    \ \tcontrol->flags = FLAG_SHOW_PROGRESS | FLAG_KEEP_FILES | FLAG_THRESHOLD;\n\
    -\tcontrol->suffix = \".lrz\";\n+\tcontrol->suffix = strdup(\".lrz\");\n \tcontrol->compression_level\
    \ = 7;\n \tcontrol->ramsize = get_ram(control);\n \tif (unlikely(control->ramsize\
    \ == -1))"
  - "--- a/main.c\n+++ b/main.c\n@@ -458,7 +458,8 @@ int main(int argc, char *argv[])\n\
    \ \t\t\tif (unlikely(STDOUT))\n \t\t\t\tfailure(\"Cannot specify an output filename\
    \ when outputting to stdout\\n\");\n \t\t\tcontrol->outname = optarg;\n-\t\t\t\
    control->suffix = \"\";\n+\t\t\tdealloc(control->suffix);\n+\t\t\tcontrol->suffix\
    \ = strdup(\"\");\n \t\t\tbreak;\n \t\tcase 'O':\n \t\t\tif (control->outname)\t\
    /* can't mix -o and -O */\n@@ -493,7 +494,8 @@ int main(int argc, char *argv[])\n\
    \ \t\t\t\tfailure(\"Specified output filename already, can't specify an extension.\\\
    n\");\n \t\t\tif (unlikely(STDOUT))\n \t\t\t\tfailure(\"Cannot specify a filename\
    \ suffix when outputting to stdout\\n\");\n-\t\t\tcontrol->suffix = optarg;\n\
    +\t\t\tdealloc(control->suffix);\n+\t\t\tcontrol->suffix = strdup(optarg);\n \t\
    \t\tbreak;\n \t\tcase 't':\n \t\t\tif (control->outname)"
  identifiers:
  - CVE-2022-28044
  - CWE-787
  overview: Irzip v0.640 was discovered to contain a heap memory corruption via the
    component lrzip.c:initialise_control.
  references:
  - source: cve@mitre.org
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/ckolivas/lrzip/commit/5faf80cd53ecfd16b636d653483144cd12004f46
  - source: cve@mitre.org
    tags:
    - Exploit
    - Issue Tracking
    - Patch
    - Third Party Advisory
    url: https://github.com/ckolivas/lrzip/issues/216
  - source: cve@mitre.org
    tags:
    - Mailing List
    - Third Party Advisory
    url: https://lists.debian.org/debian-lts-announce/2022/05/msg00016.html
  - source: cve@mitre.org
    tags:
    - Mailing List
    - Third Party Advisory
    url: https://www.debian.org/security/2022/dsa-5145
  title: Irzip v0.640 was discovered to contain a heap memory corruption via the component
    lrzip.c:initialise_control.
- diff_content:
  - "--- a/src/njs_vmcode.c\n+++ b/src/njs_vmcode.c\n@@ -1055,14 +1055,16 @@ njs_vmcode_array(njs_vm_t\
    \ *vm, u_char *pc)\n \n         if (code->ctor) {\n             /* Array of the\
    \ form [,,,], [1,,]. */\n-            value = array->start;\n-            length\
    \ = array->length;\n-\n-            do {\n-                njs_set_invalid(value);\n\
    -                value++;\n-                length--;\n-            } while (length\
    \ != 0);\n+            if (array->object.fast_array) {\n+                value\
    \ = array->start;\n+                length = array->length;\n+\n+            \
    \    do {\n+                    njs_set_invalid(value);\n+                   \
    \ value++;\n+                    length--;\n+                } while (length !=\
    \ 0);\n+            }\n \n         } else {\n             /* Array of the form\
    \ [], [,,1], [1,2,3]. */"
  - "--- a/src/test/njs_unit_test.c\n+++ b/src/test/njs_unit_test.c\n@@ -13154,6 +13154,10\
    \ @@ static njs_unit_test_t  njs_test[] =\n     { njs_str(\"(new Function('return\
    \ 5' + '** 1'.repeat(2**13)))()\"),\n       njs_str(\"5\") },\n \n+    { njs_str(\"\
    var a = (new Function('return [' + ','.repeat(2**16) + ']'))();\"\n+\t\t\t  \"\
    njs.dump(a)\"),\n+      njs_str(\"[<65536 empty items>]\") },\n+\n     { njs_str(\"\
    (new Function('var a = 7; return a' + '= a'.repeat(2**13)))()\"),\n       njs_str(\"\
    7\") },\n "
  identifiers:
  - CVE-2022-28049
  - CWE-476
  overview: NGINX NJS 0.7.2 was discovered to contain a NULL pointer dereference via
    the component njs_vmcode_array at /src/njs_vmcode.c.
  references:
  - source: cve@mitre.org
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/nginx/njs/commit/f65981b0b8fcf02d69a40bc934803c25c9f607ab
  - source: cve@mitre.org
    tags:
    - Exploit
    - Issue Tracking
    - Third Party Advisory
    url: https://github.com/nginx/njs/issues/473
  - source: cve@mitre.org
    tags:
    - Third Party Advisory
    url: https://security.netapp.com/advisory/ntap-20220519-0008/
  title: NGINX NJS 0.7.2 was discovered to contain a NULL pointer dereference via
    the component njs_vmcode_array at /src/njs_vmcode.c.
- diff_content:
  - "--- a/src/mms/iso_presentation/iso_presentation.c\n+++ b/src/mms/iso_presentation/iso_presentation.c\n\
    @@ -469,6 +469,10 @@ parseNormalModeParameters(IsoPresentation* self, uint8_t*\
    \ buffer, int totalLengt\n             if (DEBUG_PRES)\n                 printf(\"\
    PRES: pcd list\\n\");\n             bufPos = parsePresentationContextDefinitionList(self,\
    \ buffer, len, bufPos);\n+\n+            if (bufPos < 0)\n+                return\
    \ -1;\n+\n             break;\n \n         case 0xa5: /* context-definition-result-list\
    \ */"
  identifiers:
  - CVE-2022-21159
  - CWE-835
  overview: A denial of service vulnerability exists in the parseNormalModeParameters
    functionality of MZ Automation GmbH libiec61850 1.5.0. A specially-crafted series
    of network requests can lead to denial of service. An attacker can send a sequence
    of malformed iec61850 messages to trigger this vulnerability.
  references:
  - source: talos-cna@cisco.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/mz-automation/libiec61850/commit/cfa94cbf10302bedc779703f874ee2e8387a0721
  - source: talos-cna@cisco.com
    tags:
    - Exploit
    - Third Party Advisory
    url: https://talosintelligence.com/vulnerability_reports/TALOS-2022-1467
  - source: talos-cna@cisco.com
    tags:
    - Exploit
    - Third Party Advisory
    url: https://www.talosintelligence.com/vulnerability_reports/TALOS-2022-1467
  title: A denial of service vulnerability exists in the parseNormalModeParameters
    functionality of MZ Automation GmbH libiec61850 1.5.0. A specially-crafted series
    of network requests can lead to denial of service. An attacker can send a sequence
    of malformed iec61850 messages to trigger this vulnerability.
- diff_content:
  - "--- a/src/ex_docmd.c\n+++ b/src/ex_docmd.c\n@@ -2783,7 +2783,9 @@ parse_command_modifiers(\n\
    \ \tcmdmod_T    *cmod,\n \tint\t    skip_only)\n {\n+    char_u  *orig_cmd = eap->cmd;\n\
    \     char_u  *cmd_start = NULL;\n+    int\t    did_plus_cmd = FALSE;\n     char_u\
    \  *p;\n     int\t    starts_with_colon = FALSE;\n     int\t    vim9script = in_vim9script();\n\
    @@ -2819,6 +2821,7 @@ parse_command_modifiers(\n \t\t\t&& curwin->w_cursor.lnum\
    \ < curbuf->b_ml.ml_line_count)\n \t{\n \t    eap->cmd = (char_u *)\"+\";\n+\t\
    \    did_plus_cmd = TRUE;\n \t    if (!skip_only)\n \t\tex_pressedreturn = TRUE;\n\
    \ \t}\n@@ -3105,13 +3108,29 @@ parse_command_modifiers(\n \t    // Since the modifiers\
    \ have been parsed put the colon on top of the\n \t    // space: \"'<,'>mod cmd\"\
    \ -> \"mod:'<,'>cmd\n \t    // Put eap->cmd after the colon.\n-\t    mch_memmove(cmd_start\
    \ - 5, cmd_start, eap->cmd - cmd_start);\n-\t    eap->cmd -= 5;\n-\t    mch_memmove(eap->cmd\
    \ - 1, \":'<,'>\", 6);\n+\t    if (did_plus_cmd)\n+\t    {\n+\t\tsize_t len =\
    \ STRLEN(cmd_start);\n+\n+\t\t// Special case: empty command may have been changed\
    \ to \"+\":\n+\t\t//  \"'<,'>mod\" -> \"mod'<,'>+\n+\t\tmch_memmove(orig_cmd,\
    \ cmd_start, len);\n+\t\tSTRCPY(orig_cmd + len, \"'<,'>+\");\n+\t    }\n+\t  \
    \  else\n+\t    {\n+\t\tmch_memmove(cmd_start - 5, cmd_start, eap->cmd - cmd_start);\n\
    +\t\teap->cmd -= 5;\n+\t\tmch_memmove(eap->cmd - 1, \":'<,'>\", 6);\n+\t    }\n\
    \ \t}\n \telse\n-\t    // no modifiers, move the pointer back\n-\t    eap->cmd\
    \ -= 5;\n+\t    // No modifiers, move the pointer back.\n+\t    // Special case:\
    \ empty command may have been changed to \"+\".\n+\t    if (did_plus_cmd)\n+\t\
    \teap->cmd = (char_u *)\"'<,'>+\";\n+\t    else\n+\t\teap->cmd = orig_cmd;\n \
    \    }\n \n     return OK;"
  - "--- a/src/version.c\n+++ b/src/version.c\n@@ -746,6 +746,8 @@ static char *(features[])\
    \ =\n \n static int included_patches[] =\n {   /* Add new patch number below this\
    \ line */\n+/**/\n+    4763,\n /**/\n     4762,\n /**/"
  identifiers:
  - CVE-2022-1381
  - CWE-122
  overview: global heap buffer overflow in skip_range in GitHub repository vim/vim
    prior to 8.2.4763. This vulnerability is capable of crashing software, Bypass
    Protection Mechanism, Modify Memory, and possible remote execution
  references:
  - source: security@huntr.dev
    url: http://seclists.org/fulldisclosure/2022/Oct/28
  - source: security@huntr.dev
    tags:
    - Mailing List
    - Release Notes
    - Third Party Advisory
    url: http://seclists.org/fulldisclosure/2022/Oct/41
  - source: security@huntr.dev
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/vim/vim/commit/f50808ed135ab973296bca515ae4029b321afe47
  - source: security@huntr.dev
    tags:
    - Exploit
    - Patch
    - Third Party Advisory
    url: https://huntr.dev/bounties/55f9c0e8-c221-48b6-a00e-bdcaebaba4a4
  - source: security@huntr.dev
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/KVPZVE2CIE2NGCHZDMEHPBWN3LK2UQAA/
  - source: security@huntr.dev
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/X6E457NYOIRWBJHKB7ON44UY5AVTG4HU/
  - source: security@huntr.dev
    tags:
    - Third Party Advisory
    url: https://security.gentoo.org/glsa/202208-32
  - source: security@huntr.dev
    url: https://security.gentoo.org/glsa/202305-16
  - source: security@huntr.dev
    tags:
    - Release Notes
    - Third Party Advisory
    url: https://support.apple.com/kb/HT213488
  title: global heap buffer overflow in skip_range in GitHub repository vim/vim prior
    to 8.2.4763. This vulnerability is capable of crashing software, Bypass Protection
    Mechanism, Modify Memory, and possible remote execution
- diff_content:
  - "--- a/libr/bin/format/ne/ne.c\n+++ b/libr/bin/format/ne/ne.c\n@@ -77,7 +77,7\
    \ @@ static char *__func_name_from_ord(const char *module, ut16 ordinal) {\n \n\
    \ RList *r_bin_ne_get_segments(r_bin_ne_obj_t *bin) {\n \tint i;\n-\tif (!bin)\
    \ {\n+\tif (!bin || !bin->segment_entries) {\n \t\treturn NULL;\n \t}\n \tRList\
    \ *segments = r_list_newf (free);"
  identifiers:
  - CVE-2022-1382
  - CWE-476
  overview: NULL Pointer Dereference in GitHub repository radareorg/radare2 prior
    to 5.6.8. This vulnerability is capable of making the radare2 crash, thus affecting
    the availability of the system.
  references:
  - source: security@huntr.dev
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/radareorg/radare2/commit/48f0ea79f99174fb0a62cb2354e13496ce5b7c44
  - source: security@huntr.dev
    tags:
    - Exploit
    - Patch
    - Third Party Advisory
    url: https://huntr.dev/bounties/d8b6d239-6d7b-4783-b26b-5be848c01aa1
  title: NULL Pointer Dereference in GitHub repository radareorg/radare2 prior to
    5.6.8. This vulnerability is capable of making the radare2 crash, thus affecting
    the availability of the system.
- diff_content:
  - "--- a/libr/bin/format/mach0/coresymbolication.c\n+++ b/libr/bin/format/mach0/coresymbolication.c\n\
    @@ -274,12 +274,12 @@ RCoreSymCacheElement *r_coresym_cache_element_new(RBinFile\
    \ *bf, RBuffer *buf, ut\n \t\t\t\tsect->vaddr += page_zero_size;\n \t\t\t}\n \t\
    \t\tcursor += word_size;\n-\t\t\tif (cursor >= end) {\n+\t\t\tif (cursor + word_size\
    \ >= end) {\n \t\t\t\tbreak;\n \t\t\t}\n \t\t\tsect->size = r_read_ble (cursor,\
    \ false, bits);\n \t\t\tcursor += word_size;\n-\t\t\tif (cursor >= end) {\n+\t\
    \t\tif (cursor + word_size >= end) {\n \t\t\t\tbreak;\n \t\t\t}\n \t\t\tut64 sect_name_off\
    \ = r_read_ble (cursor, false, bits);\n@@ -291,7 +291,11 @@ RCoreSymCacheElement\
    \ *r_coresym_cache_element_new(RBinFile *bf, RBuffer *buf, ut\n \t\t\t\tcursor\
    \ += word_size;\n \t\t\t}\n \t\t\tstring_origin = relative_to_strings? b + start_of_strings\
    \ : sect_start;\n-\t\t\tsect->name = str_dup_safe (b, string_origin + (size_t)sect_name_off,\
    \ end);\n+\t\t\tif (sect_name_off < (ut64)(size_t)(end - string_origin)) {\n+\t\
    \t\t\tsect->name = str_dup_safe (b, string_origin + sect_name_off, end);\n+\t\t\
    \t} else {\n+\t\t\t\tsect->name = strdup (\"\");\n+\t\t\t}\n \t\t}\n \t}\n \t\
    if (hdr->n_symbols) {"
  identifiers:
  - CVE-2022-1383
  - CWE-787
  overview: Heap-based Buffer Overflow in GitHub repository radareorg/radare2 prior
    to 5.6.8. The bug causes the program reads data past the end of the intented buffer.
    Typically, this can allow attackers to read sensitive information from other memory
    locations or cause a crash.
  references:
  - source: security@huntr.dev
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/radareorg/radare2/commit/1dd65336f0f0c351d6ea853efcf73cf9c0030862
  - source: security@huntr.dev
    tags:
    - Exploit
    - Patch
    - Third Party Advisory
    url: https://huntr.dev/bounties/02b4b563-b946-4343-9092-38d1c5cd60c9
  title: Heap-based Buffer Overflow in GitHub repository radareorg/radare2 prior to
    5.6.8. The bug causes the program reads data past the end of the intented buffer.
    Typically, this can allow attackers to read sensitive information from other memory
    locations or cause a crash.
- diff_content:
  - "--- a/src/libopensc/card-idprime.c\n+++ b/src/libopensc/card-idprime.c\n@@ -418,6\
    \ +418,7 @@ static int idprime_get_token_name(sc_card_t* card, char** tname)\n\
    \ \tsc_path_t tinfo_path = {\"\\x00\\x00\", 2, 0, 0, SC_PATH_TYPE_PATH, {\"\"\
    , 0}};\n \tsc_file_t *file = NULL;\n \tu8 buf[2];\n+\tchar *name;\n \tint r;\n\
    \ \n \tLOG_FUNC_CALLED(card->ctx);\n@@ -445,20 +446,22 @@ static int idprime_get_token_name(sc_card_t*\
    \ card, char** tname)\n \t}\n \tsc_file_free(file);\n \n-\t*tname = malloc(buf[1]);\n\
    -\tif (*tname == NULL) {\n+\tname = malloc(buf[1]);\n+\tif (name == NULL) {\n\
    \ \t\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_OUT_OF_MEMORY);\n \t}\n \n-\tr = iso_ops->read_binary(card,\
    \ 2, (unsigned char *)*tname, buf[1], 0);\n+\tr = iso_ops->read_binary(card, 2,\
    \ (unsigned char *)name, buf[1], 0);\n \tif (r < 1) {\n-\t\tfree(*tname);\n+\t\
    \tfree(name);\n \t\tLOG_FUNC_RETURN(card->ctx, r);\n \t}\n \n-\tif ((*tname)[r-1]\
    \ != '\\0') {\n-\t\t(*tname)[r-1] = '\\0';\n+\tif (name[r-1] != '\\0') {\n+\t\t\
    name[r-1] = '\\0';\n \t}\n+\t*tname = name;\n+\n \tLOG_FUNC_RETURN(card->ctx,\
    \ SC_SUCCESS);\n }\n "
  identifiers:
  - CVE-2021-42778
  - CWE-415
  overview: A heap double free issue was found in Opensc before version 0.22.0 in
    sc_pkcs15_free_tokeninfo.
  references:
  - source: secalert@redhat.com
    tags:
    - Issue Tracking
    - Mailing List
    - Patch
    - Third Party Advisory
    url: https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=28185
  - source: secalert@redhat.com
    tags:
    - Issue Tracking
    - Patch
    - Third Party Advisory
    url: https://bugzilla.redhat.com/show_bug.cgi?id=2016083
  - source: secalert@redhat.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/OpenSC/OpenSC/commit/f015746d
  - source: secalert@redhat.com
    tags:
    - Third Party Advisory
    url: https://security.gentoo.org/glsa/202209-03
  title: A heap double free issue was found in Opensc before version 0.22.0 in sc_pkcs15_free_tokeninfo.
- diff_content:
  - "--- a/src/libopensc/pkcs15-oberthur.c\n+++ b/src/libopensc/pkcs15-oberthur.c\n\
    @@ -304,7 +304,7 @@ sc_oberthur_read_file(struct sc_pkcs15_card *p15card, const\
    \ char *in_path,\n \tif (verify_pin && rv == SC_ERROR_SECURITY_STATUS_NOT_SATISFIED)\
    \   {\n \t\tstruct sc_pkcs15_object *objs[0x10], *pin_obj = NULL;\n \t\tconst\
    \ struct sc_acl_entry *acl = sc_file_get_acl_entry(file, SC_AC_OP_READ);\n-\t\t\
    int ii;\n+\t\tint ii, nobjs;\n \n \t\tif (acl == NULL) {\n \t\t\tsc_file_free(file);\n\
    @@ -313,18 +313,19 @@ sc_oberthur_read_file(struct sc_pkcs15_card *p15card, const\
    \ char *in_path,\n \t\t\tLOG_FUNC_RETURN(ctx, SC_ERROR_INVALID_DATA);\n \t\t}\n\
    \ \n-\t\trv = sc_pkcs15_get_objects(p15card, SC_PKCS15_TYPE_AUTH_PIN, objs, 0x10);\n\
    -\t\tif (rv != SC_SUCCESS) {\n+\t\tnobjs = sc_pkcs15_get_objects(p15card, SC_PKCS15_TYPE_AUTH_PIN,\
    \ objs, 0x10);\n+\t\tif (nobjs < 1) {\n \t\t\tsc_file_free(file);\n \t\t\tfree(*out);\n\
    \ \t\t\t*out = NULL;\n-\t\t\tLOG_TEST_RET(ctx, rv, \"Cannot read oberthur file:\
    \ get AUTH objects error\");\n+\t\t\tLOG_TEST_RET(ctx, SC_ERROR_DATA_OBJECT_NOT_FOUND,\n\
    +\t\t\t\t\"Cannot read oberthur file: get AUTH objects error\");\n \t\t}\n \n\
    -\t\tfor (ii=0; ii<rv; ii++)   {\n+\t\tfor (ii = 0; ii < nobjs; ii++) {\n \t\t\
    \tstruct sc_pkcs15_auth_info *auth_info = (struct sc_pkcs15_auth_info *) objs[ii]->data;\n\
    \ \t\t\tsc_log(ctx, \"compare PIN/ACL refs:%i/%i, method:%i/%i\",\n-\t\t\t\t\t\
    auth_info->attrs.pin.reference, acl->key_ref, auth_info->auth_method, acl->method);\n\
    +\t\t\t\tauth_info->attrs.pin.reference, acl->key_ref, auth_info->auth_method,\
    \ acl->method);\n \t\t\tif (auth_info->attrs.pin.reference == (int)acl->key_ref\
    \ && auth_info->auth_method == (unsigned)acl->method)   {\n \t\t\t\tpin_obj =\
    \ objs[ii];\n \t\t\t\tbreak;"
  identifiers:
  - CVE-2021-42779
  - CWE-416
  overview: A heap use after free issue was found in Opensc before version 0.22.0
    in sc_file_valid.
  references:
  - source: secalert@redhat.com
    tags:
    - Issue Tracking
    - Mailing List
    - Patch
    - Third Party Advisory
    url: https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=28843
  - source: secalert@redhat.com
    tags:
    - Issue Tracking
    - Patch
    - Third Party Advisory
    url: https://bugzilla.redhat.com/show_bug.cgi?id=2016086
  - source: secalert@redhat.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/OpenSC/OpenSC/commit/1db88374
  - source: secalert@redhat.com
    url: https://lists.debian.org/debian-lts-announce/2023/06/msg00025.html
  - source: secalert@redhat.com
    tags:
    - Third Party Advisory
    url: https://security.gentoo.org/glsa/202209-03
  title: A heap use after free issue was found in Opensc before version 0.22.0 in
    sc_file_valid.
- diff_content:
  - "--- a/src/libopensc/pkcs15-tcos.c\n+++ b/src/libopensc/pkcs15-tcos.c\n@@ -242,13\
    \ +242,13 @@ static int insert_pin(\n \t\t\t\"Searching for PIN-Ref %02X\\n\"\
    , pin_reference);\n \t\twhile ((r = sc_read_record(card, ++rec_no, buf, sizeof(buf),\
    \ SC_RECORD_BY_REC_NR)) > 0) {\n \t\t\tint found = 0, fbz = -1;\n-\t\t\tif (buf[0]\
    \ != 0xA0)\n+\t\t\tif (r < 2 || buf[0] != 0xA0)\n \t\t\t\tcontinue;\n-\t\t\tfor\
    \ (i = 2; i < buf[1] + 2; i += 2 + buf[i + 1]) {\n+\t\t\tfor (i = 2; i < buf[1]\
    \ + 2 && (i + 2) < r; i += 2 + buf[i + 1]) {\n \t\t\t\tif (buf[i] == 0x83 && buf[i\
    \ + 1] == 1 && buf[i + 2] == pin_reference) {\n \t\t\t\t\t++found;\n \t\t\t\t\
    }\n-\t\t\t\tif (buf[i] == 0x90) {\n+\t\t\t\tif (buf[i] == 0x90 && (i + 1 + buf[i\
    \ + 1]) < r) {\n \t\t\t\t\tfbz = buf[i + 1 + buf[i + 1]];\n \t\t\t\t}\n \t\t\t\
    }"
  identifiers:
  - CVE-2021-42780
  - CWE-252
  overview: A use after return issue was found in Opensc before version 0.22.0 in
    insert_pin function that could potentially crash programs using the library.
  references:
  - source: secalert@redhat.com
    tags:
    - Issue Tracking
    - Mailing List
    - Patch
    - Third Party Advisory
    url: https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=28383
  - source: secalert@redhat.com
    tags:
    - Issue Tracking
    - Patch
    - Third Party Advisory
    url: https://bugzilla.redhat.com/show_bug.cgi?id=2016139
  - source: secalert@redhat.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/OpenSC/OpenSC/commit/5df913b7
  - source: secalert@redhat.com
    url: https://lists.debian.org/debian-lts-announce/2023/06/msg00025.html
  - source: secalert@redhat.com
    tags:
    - Third Party Advisory
    url: https://security.gentoo.org/glsa/202209-03
  title: A use after return issue was found in Opensc before version 0.22.0 in insert_pin
    function that could potentially crash programs using the library.
- diff_content:
  - "--- a/src/libopensc/pkcs15-oberthur.c\n+++ b/src/libopensc/pkcs15-oberthur.c\n\
    @@ -616,12 +616,14 @@ sc_pkcs15emu_oberthur_add_pubkey(struct sc_pkcs15_card *p15card,\n\
    \ \toffs += 2 + len;\n \n \t/* ID */\n-\tif (offs > info_len) {\n+\tif (offs +\
    \ 2 > info_len) {\n \t\tfree(info_blob);\n \t\tLOG_TEST_RET(ctx, SC_ERROR_UNKNOWN_DATA_RECEIVED,\
    \ \"Failed to add public key: no 'ID'\");\n \t}\n \tlen = *(info_blob + offs +\
    \ 1) + *(info_blob + offs) * 0x100;\n-\tif (!len || len > sizeof(key_info.id.value))\
    \ {\n+\tif (len == 0\n+\t\t\t|| len > sizeof(key_info.id.value)\n+\t\t\t|| offs\
    \ + 2 + len > info_len) {\n \t\tfree(info_blob);\n \t\tLOG_TEST_RET(ctx, SC_ERROR_INVALID_DATA,\
    \ \"Failed to add public key: invalid 'ID' length\");\n \t}"
  - "--- a/src/libopensc/pkcs15-oberthur.c\n+++ b/src/libopensc/pkcs15-oberthur.c\n\
    @@ -884,12 +884,16 @@ sc_pkcs15emu_oberthur_add_data(struct sc_pkcs15_card *p15card,\n\
    \ \toffs = 2;\n \n \t/* Label */\n-\tif (offs > info_len) {\n+\tif (offs + 2 >\
    \ info_len) {\n \t\tfree(info_blob);\n \t\tLOG_TEST_RET(ctx, SC_ERROR_UNKNOWN_DATA_RECEIVED,\
    \ \"Failed to add data: no 'label'\");\n \t}\n \tlabel = info_blob + offs + 2;\n\
    \ \tlabel_len = *(info_blob + offs + 1) + *(info_blob + offs) * 0x100;\n+\tif\
    \ (offs + 2 + label_len > info_len) {\n+\t\tfree(info_blob);\n+\t\tLOG_TEST_RET(ctx,\
    \ SC_ERROR_UNKNOWN_DATA_RECEIVED, \"Invalid length of 'label' received\");\n+\t\
    }\n \tif (label_len > sizeof(dobj.label) - 1)\n \t\tlabel_len = sizeof(dobj.label)\
    \ - 1;\n \toffs += 2 + *(info_blob + offs + 1);\n@@ -906,7 +910,7 @@ sc_pkcs15emu_oberthur_add_data(struct\
    \ sc_pkcs15_card *p15card,\n \toffs += 2 + app_len;\n \n \t/* OID encode like\
    \ DER(ASN.1(oid)) */\n-\tif (offs > info_len) {\n+\tif (offs + 1 > info_len) {\n\
    \ \t\tfree(info_blob);\n \t\tLOG_TEST_RET(ctx, SC_ERROR_UNKNOWN_DATA_RECEIVED,\
    \ \"Failed to add data: no 'OID'\");\n \t}"
  - "--- a/src/libopensc/pkcs15-oberthur.c\n+++ b/src/libopensc/pkcs15-oberthur.c\n\
    @@ -659,7 +659,7 @@ sc_pkcs15emu_oberthur_add_cert(struct sc_pkcs15_card *p15card,\
    \ unsigned int file\n \tstruct sc_context *ctx = p15card->card->ctx;\n \tstruct\
    \ sc_pkcs15_cert_info cinfo;\n \tstruct sc_pkcs15_object cobj;\n-\tunsigned char\
    \ *info_blob, *cert_blob;\n+\tunsigned char *info_blob = NULL, *cert_blob = NULL;\n\
    \ \tsize_t info_len, cert_len, len, offs;\n \tunsigned flags;\n \tint rv;\n@@\
    \ -675,31 +675,47 @@ sc_pkcs15emu_oberthur_add_cert(struct sc_pkcs15_card *p15card,\
    \ unsigned int file\n \trv = sc_oberthur_read_file(p15card, ch_tmp, &info_blob,\
    \ &info_len, 1);\n \tLOG_TEST_RET(ctx, rv, \"Failed to add certificate: read oberthur\
    \ file error\");\n \n-\tif (info_len < 2)\n+\tif (info_len < 2) {\n+\t\tfree(info_blob);\n\
    \ \t\tLOG_TEST_RET(ctx, SC_ERROR_UNKNOWN_DATA_RECEIVED, \"Failed to add certificate:\
    \ no 'tag'\");\n+\t}\n \tflags = *(info_blob + 0) * 0x100 + *(info_blob + 1);\n\
    \ \toffs = 2;\n \n \t/* Label */\n-\tif (offs + 2 > info_len)\n+\tif (offs + 2\
    \ > info_len) {\n+\t\tfree(info_blob);\n \t\tLOG_TEST_RET(ctx, SC_ERROR_UNKNOWN_DATA_RECEIVED,\
    \ \"Failed to add certificate: no 'CN'\");\n+\t}\n \tlen = *(info_blob + offs\
    \ + 1) + *(info_blob + offs) * 0x100;\n-\tif (len)   {\n+\tif (len + offs + 2\
    \ > info_len) {\n+\t\tfree(info_blob);\n+\t\tLOG_TEST_RET(ctx, SC_ERROR_UNKNOWN_DATA_RECEIVED,\
    \ \"Invalid 'CN' length\");\n+\t} else if (len) {\n \t\tif (len > sizeof(cobj.label)\
    \ - 1)\n \t\t\tlen = sizeof(cobj.label) - 1;\n \t\tmemcpy(cobj.label, info_blob\
    \ + offs + 2, len);\n \t}\n \toffs += 2 + len;\n \n \t/* ID */\n-\tif (offs >\
    \ info_len)\n+\tif (offs + 2 > info_len) {\n+\t\tfree(info_blob);\n \t\tLOG_TEST_RET(ctx,\
    \ SC_ERROR_UNKNOWN_DATA_RECEIVED, \"Failed to add certificate: no 'ID'\");\n+\t\
    }\n \tlen = *(info_blob + offs + 1) + *(info_blob + offs) * 0x100;\n-\tif (len\
    \ > sizeof(cinfo.id.value))\n+\tif (len + offs + 2 > info_len) {\n+\t\tfree(info_blob);\n\
    +\t\tLOG_TEST_RET(ctx, SC_ERROR_UNKNOWN_DATA_RECEIVED, \"Invalid 'ID' length\"\
    );\n+\t} else if (len > sizeof(cinfo.id.value)) {\n+\t\tfree(info_blob);\n \t\t\
    LOG_TEST_RET(ctx, SC_ERROR_INVALID_DATA, \"Failed to add certificate: invalid\
    \ 'ID' length\");\n+\t}\n \tmemcpy(cinfo.id.value, info_blob + offs + 2, len);\n\
    \ \tcinfo.id.len = len;\n \n+\tfree(info_blob);\n+\n \t/* Ignore subject, issuer\
    \ and serial */\n \n \tsnprintf(ch_tmp, sizeof(ch_tmp), \"%s%04X\", AWP_OBJECTS_DF_PUB,\
    \ file_id);\n@@ -784,15 +800,23 @@ sc_pkcs15emu_oberthur_add_prvkey(struct sc_pkcs15_card\
    \ *p15card,\n \trv = sc_oberthur_read_file(p15card, ch_tmp, &info_blob, &info_len,\
    \ 1);\n \tLOG_TEST_RET(ctx, rv, \"Failed to add private key: read oberthur file\
    \ error\");\n \n-\tif (info_len < 2)\n+\tif (info_len < 2) {\n+\t\tfree(info_blob);\n\
    \ \t\tLOG_TEST_RET(ctx, SC_ERROR_UNKNOWN_DATA_RECEIVED, \"Failed to add private\
    \ key: no 'tag'\");\n+\t}\n \tflags = *(info_blob + 0) * 0x100 + *(info_blob +\
    \ 1);\n \toffs = 2;\n \n \t/* CN */\n-\tif (offs > info_len)\n+\tif (offs + 2\
    \ > info_len) {\n+\t\tfree(info_blob);\n \t\tLOG_TEST_RET(ctx, SC_ERROR_UNKNOWN_DATA_RECEIVED,\
    \ \"Failed to add private key: no 'CN'\");\n+\t}\n \tlen = *(info_blob + offs\
    \ + 1) + *(info_blob + offs) * 0x100;\n+\tif (len + offs + 2 > info_len) {\n+\t\
    \tfree(info_blob);\n+\t\tLOG_TEST_RET(ctx, SC_ERROR_UNKNOWN_DATA_RECEIVED, \"\
    Invalid 'CN' length\");\n+\t}\n \tif (len && !strlen(kobj.label))   {\n \t\tif\
    \ (len > sizeof(kobj.label) - 1)\n \t\t\tlen = sizeof(kobj.label) - 1;\n@@ -801,13\
    \ +825,21 @@ sc_pkcs15emu_oberthur_add_prvkey(struct sc_pkcs15_card *p15card,\n\
    \ \toffs += 2 + len;\n \n \t/* ID */\n-\tif (offs > info_len)\n+\tif (offs + 2\
    \ > info_len) {\n+\t\tfree(info_blob);\n \t\tLOG_TEST_RET(ctx, SC_ERROR_UNKNOWN_DATA_RECEIVED,\
    \ \"Failed to add private key: no 'ID'\");\n+\t}\n \tlen = *(info_blob + offs\
    \ + 1) + *(info_blob + offs) * 0x100;\n-\tif (!len)\n+\tif (!len) {\n+\t\tfree(info_blob);\n\
    \ \t\tLOG_TEST_RET(ctx, SC_ERROR_UNKNOWN_DATA_RECEIVED, \"Failed to add private\
    \ key: zero length ID\");\n-\telse if (len > sizeof(kinfo.id.value))\n+\t} else\
    \ if (len + offs + 2 > info_len) {\n+\t\tfree(info_blob);\n+\t\tLOG_TEST_RET(ctx,\
    \ SC_ERROR_UNKNOWN_DATA_RECEIVED, \"Invalid 'ID' length\");\n+\t} else if (len\
    \ > sizeof(kinfo.id.value)) {\n+\t\tfree(info_blob);\n \t\tLOG_TEST_RET(ctx, SC_ERROR_INVALID_DATA,\
    \ \"Failed to add private key: invalid ID length\");\n+\t}\n \tmemcpy(kinfo.id.value,\
    \ info_blob + offs + 2, len);\n \tkinfo.id.len = len;\n \toffs += 2 + len;\n@@\
    \ -816,19 +848,28 @@ sc_pkcs15emu_oberthur_add_prvkey(struct sc_pkcs15_card *p15card,\n\
    \ \toffs += 16;\n \n \t/* Subject encoded in ASN1 */\n-\tif (offs > info_len)\n\
    -\t\treturn SC_ERROR_UNKNOWN_DATA_RECEIVED;\n+\tif (offs + 2 > info_len) {\n+\t\
    \tfree(info_blob);\n+\t\tLOG_TEST_RET(ctx, SC_ERROR_UNKNOWN_DATA_RECEIVED, \"\
    Failed to add private key: no 'subject'\");\n+\t}\n \tlen = *(info_blob + offs\
    \ + 1) + *(info_blob + offs) * 0x100;\n-\tif (len)   {\n+\tif (len + offs + 2\
    \ > info_len) {\n+\t\tfree(info_blob);\n+\t\tLOG_TEST_RET(ctx, SC_ERROR_UNKNOWN_DATA_RECEIVED,\
    \ \"Invalid 'subject' length\");\n+\t} else if (len) {\n \t\tkinfo.subject.value\
    \ = malloc(len);\n-\t\tif (!kinfo.subject.value)\n+\t\tif (!kinfo.subject.value)\
    \ {\n+\t\t\tfree(info_blob);\n \t\t\tLOG_TEST_RET(ctx, SC_ERROR_OUT_OF_MEMORY,\
    \ \"Failed to add private key: memory allocation error\");\n+\t\t}\n \t\tkinfo.subject.len\
    \ = len;\n \t\tmemcpy(kinfo.subject.value, info_blob + offs + 2, len);\n \t}\n\
    \ \n \t/* Modulus and exponent are ignored */\n \n+\tfree(info_blob);\n+\n \t\
    snprintf(ch_tmp, sizeof(ch_tmp), \"%s%04X\", AWP_OBJECTS_DF_PRV, file_id);\n \t\
    sc_format_path(ch_tmp, &kinfo.path);\n \tsc_log(ctx, \"Private key info path %s\"\
    , ch_tmp);\n@@ -899,22 +940,30 @@ sc_pkcs15emu_oberthur_add_data(struct sc_pkcs15_card\
    \ *p15card,\n \toffs += 2 + *(info_blob + offs + 1);\n \n \t/* Application */\n\
    -\tif (offs > info_len) {\n+\tif (offs + 2 > info_len) {\n \t\tfree(info_blob);\n\
    \ \t\tLOG_TEST_RET(ctx, SC_ERROR_UNKNOWN_DATA_RECEIVED, \"Failed to add data:\
    \ no 'application'\");\n \t}\n \tapp = info_blob + offs + 2;\n \tapp_len = *(info_blob\
    \ + offs + 1) + *(info_blob + offs) * 0x100;\n+\tif (offs + 2 + app_len > info_len)\
    \ {\n+\t\tfree(info_blob);\n+\t\tLOG_TEST_RET(ctx, SC_ERROR_UNKNOWN_DATA_RECEIVED,\
    \ \"Invalid length of 'application' received\");\n+\t}\n \tif (app_len > sizeof(dinfo.app_label)\
    \ - 1)\n \t\tapp_len = sizeof(dinfo.app_label) - 1;\n \toffs += 2 + app_len;\n\
    \ \n \t/* OID encode like DER(ASN.1(oid)) */\n-\tif (offs + 1 > info_len) {\n\
    +\tif (offs + 2 > info_len) {\n \t\tfree(info_blob);\n \t\tLOG_TEST_RET(ctx, SC_ERROR_UNKNOWN_DATA_RECEIVED,\
    \ \"Failed to add data: no 'OID'\");\n \t}\n \toid_len = *(info_blob + offs +\
    \ 1) + *(info_blob + offs) * 0x100;\n+\tif (offs + 2 + oid_len > info_len) {\n\
    +\t\tfree(info_blob);\n+\t\tLOG_TEST_RET(ctx, SC_ERROR_UNKNOWN_DATA_RECEIVED,\
    \ \"Invalid length of 'oid' received\");\n+\t}\n \tif (oid_len)   {\n \t\toid\
    \ = info_blob + offs + 2;\n \t\tif (*oid != 0x06 || (*(oid + 1) != oid_len - 2))\
    \ {"
  - "--- a/src/libopensc/pkcs15-oberthur.c\n+++ b/src/libopensc/pkcs15-oberthur.c\n\
    @@ -609,7 +609,10 @@ sc_pkcs15emu_oberthur_add_pubkey(struct sc_pkcs15_card *p15card,\n\
    \ \t\tLOG_TEST_RET(ctx, SC_ERROR_UNKNOWN_DATA_RECEIVED, \"Failed to add public\
    \ key: no 'Label'\");\n \t}\n \tlen = *(info_blob + offs + 1) + *(info_blob +\
    \ offs) * 0x100;\n-\tif (len)   {\n+\tif (offs + 2 + len > info_len) {\n+\t\t\
    free(info_blob);\n+\t\tLOG_TEST_RET(ctx, SC_ERROR_INVALID_DATA, \"Failed to add\
    \ public key: invalid 'Label' length\");\n+\t} else if (len) {\n \t\tif (len >\
    \ sizeof(key_obj.label) - 1)\n \t\t\tlen = sizeof(key_obj.label) - 1;\n \t\tmemcpy(key_obj.label,\
    \ info_blob + offs + 2, len);"
  - "--- a/src/libopensc/pkcs15-oberthur.c\n+++ b/src/libopensc/pkcs15-oberthur.c\n\
    @@ -973,7 +973,7 @@ sc_pkcs15emu_oberthur_add_data(struct sc_pkcs15_card *p15card,\n\
    \ \t\tfree(info_blob);\n \t\tLOG_TEST_RET(ctx, SC_ERROR_UNKNOWN_DATA_RECEIVED,\
    \ \"Invalid length of 'oid' received\");\n \t}\n-\tif (oid_len)   {\n+\tif (oid_len\
    \ > 2) {\n \t\toid = info_blob + offs + 2;\n \t\tif (*oid != 0x06 || (*(oid +\
    \ 1) != oid_len - 2)) {\n \t\t\tfree(info_blob);"
  identifiers:
  - CVE-2021-42781
  - CWE-787
  overview: Heap buffer overflow issues were found in Opensc before version 0.22.0
    in pkcs15-oberthur.c that could potentially crash programs using the library.
  references:
  - source: secalert@redhat.com
    tags:
    - Issue Tracking
    - Patch
    - Third Party Advisory
    url: https://bugzilla.redhat.com/show_bug.cgi?id=2016439
  - source: secalert@redhat.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/OpenSC/OpenSC/commit/05648b06
  - source: secalert@redhat.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/OpenSC/OpenSC/commit/17d8980c
  - source: secalert@redhat.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/OpenSC/OpenSC/commit/40c50a3a
  - source: secalert@redhat.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/OpenSC/OpenSC/commit/5d4daf6c
  - source: secalert@redhat.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/OpenSC/OpenSC/commit/cae5c71f
  - source: secalert@redhat.com
    url: https://lists.debian.org/debian-lts-announce/2023/06/msg00025.html
  - source: secalert@redhat.com
    tags:
    - Third Party Advisory
    url: https://security.gentoo.org/glsa/202209-03
  title: Heap buffer overflow issues were found in Opensc before version 0.22.0 in
    pkcs15-oberthur.c that could potentially crash programs using the library.
- diff_content:
  - "--- a/src/libopensc/card-cardos.c\n+++ b/src/libopensc/card-cardos.c\n@@ -159,7\
    \ +159,7 @@ static int cardos_have_2048bit_package(sc_card_t *card)\n \tsc_apdu_t\
    \ apdu;\n         u8        rbuf[SC_MAX_APDU_BUFFER_SIZE];\n         int     \
    \  r;\n-\tconst u8  *p = rbuf, *q;\n+\tconst u8  *p = rbuf, *q, *pp;\n \tsize_t\
    \    len, tlen = 0, ilen = 0;\n \n \tsc_format_apdu(card, &apdu, SC_APDU_CASE_2_SHORT,\
    \ 0xca, 0x01, 0x88);\n@@ -175,10 +175,10 @@ static int cardos_have_2048bit_package(sc_card_t\
    \ *card)\n \t\treturn 0;\n \n \twhile (len != 0) {\n-\t\tp = sc_asn1_find_tag(card->ctx,\
    \ p, len, 0xe1, &tlen);\n-\t\tif (p == NULL)\n+\t\tpp = sc_asn1_find_tag(card->ctx,\
    \ p, len, 0xe1, &tlen);\n+\t\tif (pp == NULL)\n \t\t\treturn 0;\n-\t\tq = sc_asn1_find_tag(card->ctx,\
    \ p, tlen, 0x01, &ilen);\n+\t\tq = sc_asn1_find_tag(card->ctx, pp, tlen, 0x01,\
    \ &ilen);\n \t\tif (q == NULL || ilen != 4)\n \t\t\treturn 0;\n \t\tif (q[0] ==\
    \ 0x1c)"
  - "--- a/src/libopensc/card-piv.c\n+++ b/src/libopensc/card-piv.c\n@@ -608,14 +608,12\
    \ @@ static int piv_generate_key(sc_card_t *card,\n \t\tconst u8 *cp;\n \t\tkeydata->exponent\
    \ = 0;\n \n-\t\t/* expected tag is 7f49.  */\n-\t\t/* we will whatever tag is\
    \ present */\n-\n \t\tcp = rbuf;\n \t\tin_len = r;\n \n+\t\t/* expected tag is\
    \ 0x7f49,returned as cla_out == 0x60 and tag_out = 0x1F49 */\n \t\tr = sc_asn1_read_tag(&cp,\
    \ in_len, &cla_out, &tag_out, &in_len);\n-\t\tif (cp == NULL) {\n+\t\tif (cp ==\
    \ NULL || in_len == 0 || cla_out != 0x60 || tag_out != 0x1f49) {\n \t\t\tr = SC_ERROR_ASN1_OBJECT_NOT_FOUND;\n\
    \ \t\t}\n \t\tif (r != SC_SUCCESS) {\n@@ -1032,7 +1030,7 @@ piv_cache_internal_data(sc_card_t\
    \ *card, int enumtag)\n \t\t\tpriv->obj_cache[enumtag].obj_len,\n \t\t\t0x53,\
    \ &bodylen);\n \n-\tif (body == NULL)\n+\tif (body == NULL || priv->obj_cache[enumtag].obj_data[0]\
    \ != 0x53)\n \t\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_OBJECT_NOT_VALID);\n \n \t\
    /* get the certificate out */\n@@ -1611,7 +1609,7 @@ static int piv_general_mutual_authenticate(sc_card_t\
    \ *card,\n \t/* Remove the encompassing outer TLV of 0x7C and get the data */\n\
    \ \tbody = sc_asn1_find_tag(card->ctx, rbuf,\n \t\tr, 0x7C, &body_len);\n-\tif\
    \ (!body) {\n+\tif (!body || rbuf[0] != 0x7C) {\n \t\tsc_debug(card->ctx, SC_LOG_DEBUG_VERBOSE,\
    \ \"Invalid Witness Data response of NULL\\n\");\n \t\tr =  SC_ERROR_INVALID_DATA;\n\
    \ \t\tgoto err;\n@@ -1753,7 +1751,7 @@ static int piv_general_mutual_authenticate(sc_card_t\
    \ *card,\n \t/* Remove the encompassing outer TLV of 0x7C and get the data */\n\
    \ \tbody = sc_asn1_find_tag(card->ctx, rbuf,\n \t\tr, 0x7C, &body_len);\n-\tif(!body)\
    \ {\n+\tif(!body || rbuf[0] != 0x7C) {\n \t\tsc_debug(card->ctx, SC_LOG_DEBUG_VERBOSE,\
    \ \"Could not find outer tag 0x7C in response\");\n \t\tr =  SC_ERROR_INVALID_DATA;\n\
    \ \t\tgoto err;\n@@ -1914,7 +1912,7 @@ static int piv_general_external_authenticate(sc_card_t\
    \ *card,\n \t/* Remove the encompassing outer TLV of 0x7C and get the data */\n\
    \ \tbody = sc_asn1_find_tag(card->ctx, rbuf,\n \t\tr, 0x7C, &body_len);\n-\tif\
    \ (!body) {\n+\tif (!body || rbuf[0] != 0x7C) {\n \t\tsc_debug(card->ctx, SC_LOG_DEBUG_VERBOSE,\
    \ \"Invalid Challenge Data response of NULL\\n\");\n \t\tr =  SC_ERROR_INVALID_DATA;\n\
    \ \t\tgoto err;\n@@ -2079,7 +2077,7 @@ piv_get_serial_nr_from_CHUI(sc_card_t*\
    \ card, sc_serial_number_t* serial)\n \tr = SC_ERROR_INTERNAL;\n \tif (rbuflen\
    \ != 0) {\n \t\tbody = sc_asn1_find_tag(card->ctx, rbuf, rbuflen, 0x53, &bodylen);\
    \ /* Pass the outer wrapper asn1 */\n-\t\tif (body != NULL && bodylen != 0) {\n\
    +\t\tif (body != NULL && bodylen != 0 && rbuf[0] == 0x53) {\n \t\t\tfascn = sc_asn1_find_tag(card->ctx,\
    \ body, bodylen, 0x30, &fascnlen); /* Find the FASC-N data */\n \t\t\tguid = sc_asn1_find_tag(card->ctx,\
    \ body, bodylen, 0x34, &guidlen);\n \n@@ -2311,10 +2309,10 @@ static int piv_validate_general_authentication(sc_card_t\
    \ *card,\n \tpiv_private_data_t * priv = PIV_DATA(card);\n \tint r, tmplen, tmplen2;\n\
    \ \tu8 *p;\n-\tconst u8 *tag;\n+\tconst unsigned char *p2;\n \tsize_t taglen;\n\
    -\tconst u8 *body;\n \tsize_t bodylen;\n+\tunsigned int cla, tag;\n \tunsigned\
    \ int real_alg_id, op_tag;\n \n \tu8 sbuf[4096]; /* needs work. for 3072 keys,\
    \ needs 384+10 or so */\n@@ -2367,20 +2365,28 @@ static int piv_validate_general_authentication(sc_card_t\
    \ *card,\n \n \tr = piv_general_io(card, 0x87, real_alg_id, priv->key_ref,\n \t\
    \t\tsbuf, p - sbuf, rbuf, sizeof rbuf);\n+\tif (r < 0)\n+\t\tgoto err;\n \n-\t\
    if (r >= 0) {\n-\t\tbody = sc_asn1_find_tag(card->ctx, rbuf, r, 0x7c, &bodylen);\n\
    -\t\tif (body) {\n-\t\t\ttag = sc_asn1_find_tag(card->ctx, body,  bodylen, 0x82,\
    \ &taglen);\n-\t\t\tif (tag) {\n-\t\t\t\tmemcpy(out, tag, taglen);\n-\t\t\t\t\
    r = taglen;\n-\t\t\t} else\n-\t\t\t\tr = SC_ERROR_INVALID_DATA;\n-\t\t} else\n\
    -\t\t\tr = SC_ERROR_INVALID_DATA;\n+\tp2 = rbuf;\n+\tr = sc_asn1_read_tag(&p2,\
    \ r, &cla, &tag, &bodylen);\n+\tif (p2 == NULL || r < 0 || bodylen == 0 || (cla|tag)\
    \ != 0x7C) {\n+\t\tLOG_TEST_GOTO_ERR(card->ctx, SC_ERROR_INVALID_DATA, \"Can't\
    \ find 0x7C\");\n+        }\n+\n+\tr = sc_asn1_read_tag(&p2, bodylen, &cla, &tag,\
    \ &taglen);\n+\tif (p2 == NULL || r < 0 || taglen == 0 || (cla|tag) != 0x82) {\n\
    +\t\tLOG_TEST_GOTO_ERR(card->ctx, SC_ERROR_INVALID_DATA, \"Can't find 0x82\");\n\
    \ \t}\n \n+\tif (taglen > outlen) {\n+\t\tLOG_TEST_GOTO_ERR(card->ctx, SC_ERROR_INVALID_DATA,\
    \ \"data read longer then buffer\");\n+\t}\n+\n+\tmemcpy(out, p2, taglen);\n+\t\
    r = taglen;\n+\n+err:\n \tLOG_FUNC_RETURN(card->ctx, r);\n }\n \n@@ -2394,19 +2400,19\
    \ @@ piv_compute_signature(sc_card_t *card, const u8 * data, size_t datalen,\n\
    \ \tint i;\n \tsize_t nLen;\n \tu8 rbuf[128]; /* For EC conversions  384 will\
    \ fit */\n-\tconst u8 * body;\n-\tsize_t bodylen;\n-\tconst u8 * tag;\n-\tsize_t\
    \ taglen;\n+\tconst unsigned char *pseq, *pint, *ptemp, *pend;\n+\tunsigned int\
    \ cla, tag;\n+\tsize_t seqlen;\n+\tsize_t intlen;\n+\tsize_t templen;\n \n \t\
    SC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);\n \n \t/* The PIV returns a DER\
    \ SEQUENCE{INTEGER, INTEGER}\n-\t * Which may have leading 00 to force positive\n\
    -\t * TODO: -DEE should check if PKCS15 want the same\n-\t * But PKCS11 just wants\
    \ 2* filed_length in bytes\n+\t * Which may have leading 00 to force a positive\
    \ integer\n+\t * But PKCS11 just wants 2* field_length in bytes\n \t * So we have\
    \ to strip out the integers\n-\t * if present and pad on left if too short.\n\
    +\t * and pad on left if too short.\n \t */\n \n \tif (priv->alg_id == 0x11 ||\
    \ priv->alg_id == 0x14 ) {\n@@ -2424,32 +2430,34 @@ piv_compute_signature(sc_card_t\
    \ *card, const u8 * data, size_t datalen,\n \t\tif (r < 0)\n \t\t\tgoto err;\n\
    \ \n-\t\tbody = sc_asn1_find_tag(card->ctx, rbuf, r, 0x30, &bodylen);\n-\n-\t\t\
    for (i = 0; i<2; i++) {\n-\t\t\tif (body) {\n-\t\t\t\ttag = sc_asn1_find_tag(card->ctx,\
    \ body,  bodylen, 0x02, &taglen);\n-\t\t\t\tif (tag) {\n-\t\t\t\t\tbodylen -=\
    \ taglen - (tag - body);\n-\t\t\t\t\tbody = tag + taglen;\n-\n-\t\t\t\t\tif (taglen\
    \ > nLen) { /* drop leading 00 if present */\n-\t\t\t\t\t\tif (*tag != 0x00) {\n\
    -\t\t\t\t\t\t\tr = SC_ERROR_INVALID_DATA;\n-\t\t\t\t\t\t\tgoto err;\n-\t\t\t\t\
    \t\t}\n-\t\t\t\t\t\ttag++;\n-\t\t\t\t\t\ttaglen--;\n-\t\t\t\t\t}\n-\t\t\t\t\t\
    memcpy(out + nLen*i + nLen - taglen , tag, taglen);\n-\t\t\t\t} else {\n+\t\t\
    pseq = rbuf;\n+\t\tr = sc_asn1_read_tag(&pseq, r, &cla, &tag, &seqlen);\n+\t\t\
    if (pseq == NULL || r < 0 || seqlen == 0 || (cla|tag) != 0x30)\n+\t\t\tLOG_TEST_GOTO_ERR(card->ctx,\
    \ SC_ERROR_INVALID_DATA, \"Can't find 0x30\");\n+\n+\t\tpint = pseq;\n+\t\tpend\
    \ = pseq + seqlen;\n+\t\tfor (i = 0; i < 2; i++) {\n+\t\t\tr = sc_asn1_read_tag(&pint,\
    \ (pend - pint), &cla, &tag, &intlen);\n+\t\t\tif (pint == NULL || r < 0 || intlen\
    \ == 0 || (cla|tag) != 0x02)\n+\t\t\t\tLOG_TEST_GOTO_ERR(card->ctx, SC_ERROR_INVALID_DATA,\
    \ \"Can't find 0x02\");\n+\t\t\tif (intlen > nLen + 1)\n+\t\t\t\tLOG_TEST_GOTO_ERR(card->ctx,\
    \ SC_ERROR_INVALID_DATA,\"Signature too long\");\n+\n+\t\t\tptemp = pint;\n+\t\
    \t\ttemplen = intlen;\n+\t\t\tif (intlen > nLen) { /* drop leading 00 if present\
    \ */\n+\t\t\t\tif (*ptemp != 0x00) {\n+\t\t\t\t\tLOG_TEST_GOTO_ERR(card->ctx,\
    \ SC_ERROR_INVALID_DATA,\"Signature too long\");\n \t\t\t\t\tr = SC_ERROR_INVALID_DATA;\n\
    \ \t\t\t\t\tgoto err;\n \t\t\t\t}\n-\t\t\t} else  {\n-\t\t\t\tr = SC_ERROR_INVALID_DATA;\n\
    -\t\t\t\tgoto err;\n+\t\t\t\tptemp++;\n+\t\t\t\ttemplen--;\n \t\t\t}\n+\t\t\t\
    memcpy(out + nLen*i + nLen - templen , ptemp, templen);\n+\t\t\tpint += intlen;\
    \ /* next integer */\n+\t\t\t\n \t\t}\n \t\tr = 2 * nLen;\n \t} else { /* RSA\
    \ is all set */"
  - "--- a/src/libopensc/pkcs15-coolkey.c\n+++ b/src/libopensc/pkcs15-coolkey.c\n\
    @@ -425,7 +425,8 @@ coolkey_get_public_key_from_certificate(sc_pkcs15_card_t *p15card,\
    \ sc_cardctl_co\n \tsc_pkcs15_pubkey_t *key = NULL;\n \tint r;\n \n-\tcert_info.value.value\
    \ = NULL;\n+\tmemset(&cert_info, 0, sizeof(cert_info));\n+\n \tr = coolkey_get_certificate(p15card->card,\
    \ obj, &cert_info.value);\n \tif (r < 0) {\n \t\tgoto fail;"
  - "--- a/src/libopensc/pkcs15-tcos.c\n+++ b/src/libopensc/pkcs15-tcos.c\n@@ -152,7\
    \ +152,7 @@ static int insert_key(\n \t\t\tsc_log(ctx, \"No EF_KEYD-Record found\\\
    n\");\n \t\t\treturn 1;\n \t\t}\n-\t\tfor (i = 0; i < r; i += 2 + buf[i + 1])\
    \ {\n+\t\tfor (i = 0; i + 1 < r; i += 2 + buf[i + 1]) {\n \t\t\tif (buf[i] ==\
    \ 0xB6)\n \t\t\t\tcan_sign++;\n \t\t\tif (buf[i] == 0xB8)"
  - "--- a/src/libopensc/card-iasecc.c\n+++ b/src/libopensc/card-iasecc.c\n@@ -1171,7\
    \ +1171,7 @@ iasecc_process_fci(struct sc_card *card, struct sc_file *file,\n\
    \ \telse\n \t\tacls = sc_asn1_find_tag(ctx, buf, buflen, IASECC_DOCP_TAG_ACLS_CONTACT,\
    \ &taglen);\n \n-\tif (!acls)   {\n+\tif (!acls || taglen < 7)   {\n \t\tsc_log(ctx,\n\
    \ \t\t       \"ACLs not found in data(%\"SC_FORMAT_LEN_SIZE_T\"u) %s\",\n \t\t\
    \       buflen, sc_dump_hex(buf, buflen));"
  identifiers:
  - CVE-2021-42782
  - CWE-787
  overview: Stack buffer overflow issues were found in Opensc before version 0.22.0
    in various places that could potentially crash programs using the library.
  references:
  - source: secalert@redhat.com
    tags:
    - Issue Tracking
    - Mailing List
    - Patch
    - Third Party Advisory
    url: https://bugzilla.redhat.com/show_bug.cgi?id=2016448
  - source: secalert@redhat.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/OpenSC/OpenSC/commit/1252aca9
  - source: secalert@redhat.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/OpenSC/OpenSC/commit/456ac566
  - source: secalert@redhat.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/OpenSC/OpenSC/commit/7114fb71
  - source: secalert@redhat.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/OpenSC/OpenSC/commit/78cdab94
  - source: secalert@redhat.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/OpenSC/OpenSC/commit/ae1cf0be
  - source: secalert@redhat.com
    url: https://lists.debian.org/debian-lts-announce/2023/06/msg00025.html
  - source: secalert@redhat.com
    tags:
    - Third Party Advisory
    url: https://security.gentoo.org/glsa/202209-03
  title: Stack buffer overflow issues were found in Opensc before version 0.22.0 in
    various places that could potentially crash programs using the library.
- diff_content:
  - "--- a/src/options.c\n+++ b/src/options.c\n@@ -335,6 +335,10 @@ void get_cmdln_options(int\
    \ argc, char *argv[]) {\n         pwd_entry=getpwuid(getuid());\n         if (pwd_entry!=NULL)\
    \ {\n             str=(char*)malloc(strlen(pwd_entry->pw_dir)+14);\n+        \
    \    if(!str) {\n+              printf(\"Fatal: failed to allocate %zu bytes.\\\
    n\", strlen(pwd_entry->pw_dir)+14);\n+              exit(EXIT_FAILURE);\n+   \
    \         }\n             snprintf(str,strlen(pwd_entry->pw_dir)+14,\"%s/.bwm-ng.conf\"\
    ,pwd_entry->pw_dir);\n             read_config(str);\n             free(str);"
  identifiers:
  - CVE-2022-1341
  - CWE-476
  overview: An issue was discovered in in bwm-ng v0.6.2. An arbitrary null write exists
    in get_cmdln_options() function in src/options.c.
  references:
  - source: secalert@redhat.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/vgropp/bwm-ng/commit/9774f23bf78a6e6d3ae4cfe3d73bad34f2fdcd17
  - source: secalert@redhat.com
    tags:
    - Exploit
    - Issue Tracking
    - Third Party Advisory
    url: https://github.com/vgropp/bwm-ng/issues/26
  title: An issue was discovered in in bwm-ng v0.6.2. An arbitrary null write exists
    in get_cmdln_options() function in src/options.c.
- diff_content:
  - "--- a/pam_tacplus.c\n+++ b/pam_tacplus.c\n@@ -516,6 +516,7 @@ int pam_sm_acct_mgmt\
    \ (pam_handle_t * pamh, int flags,\n     int tac_fd;\n \n     user = tty = r_addr\
    \ = NULL;\n+    memset(&arep, 0, sizeof(arep));\n \n     /* this also obtains\
    \ service name for authorization\n        this should be normally performed by\
    \ pam_get_item(PAM_SERVICE)"
  identifiers:
  - CVE-2016-20014
  - NVD-CWE-Other
  overview: In pam_tacplus.c in pam_tacplus before 1.4.1, pam_sm_acct_mgmt does not
    zero out the arep data structure.
  references:
  - source: cve@mitre.org
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/kravietz/pam_tacplus/commit/e4c00eba70a0f72c4de77b5f072c69708ec2beab
  title: In pam_tacplus.c in pam_tacplus before 1.4.1, pam_sm_acct_mgmt does not zero
    out the arep data structure.
- diff_content:
  - "--- a/src/eval.c\n+++ b/src/eval.c\n@@ -4102,19 +4102,23 @@ eval_lambda(\n \t\
    ++*arg;\n \tret = eval1(arg, rettv, evalarg);\n \t*arg = skipwhite_and_linebreak(*arg,\
    \ evalarg);\n-\tif (**arg == ')')\n+\tif (**arg != ')')\n \t{\n-\t    ++*arg;\n\
    +\t    emsg(_(e_missing_closing_paren));\n+\t    return FAIL;\n \t}\n-\telse\n\
    +\tif (rettv->v_type != VAR_STRING && rettv->v_type != VAR_FUNC\n+\t\t\t\t\t \
    \      && rettv->v_type != VAR_PARTIAL)\n \t{\n-\t    emsg(_(e_missing_closing_paren));\n\
    -\t    ret = FAIL;\n+\t    emsg(_(e_string_or_function_required_for_arrow_parens_expr));\n\
    +\t    return FAIL;\n \t}\n+\t++*arg;\n     }\n     if (ret != OK)\n \treturn\
    \ FAIL;\n-    else if (**arg != '(')\n+\n+    if (**arg != '(')\n     {\n \tif\
    \ (verbose)\n \t{"
  - "--- a/src/version.c\n+++ b/src/version.c\n@@ -746,6 +746,8 @@ static char *(features[])\
    \ =\n \n static int included_patches[] =\n {   /* Add new patch number below this\
    \ line */\n+/**/\n+    4774,\n /**/\n     4773,\n /**/"
  identifiers:
  - CVE-2022-1420
  - CWE-823
  overview: Use of Out-of-range Pointer Offset in GitHub repository vim/vim prior
    to 8.2.4774.
  references:
  - source: security@huntr.dev
    url: http://seclists.org/fulldisclosure/2022/Oct/28
  - source: security@huntr.dev
    tags:
    - Mailing List
    - Release Notes
    - Third Party Advisory
    url: http://seclists.org/fulldisclosure/2022/Oct/41
  - source: security@huntr.dev
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/vim/vim/commit/8b91e71441069b1dde9ac9ff9d9a829b1b4aecca
  - source: security@huntr.dev
    tags:
    - Exploit
    - Issue Tracking
    - Patch
    - Third Party Advisory
    url: https://huntr.dev/bounties/a4323ef8-90ea-4e1c-90e9-c778f0ecf326
  - source: security@huntr.dev
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/KVPZVE2CIE2NGCHZDMEHPBWN3LK2UQAA/
  - source: security@huntr.dev
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/X6E457NYOIRWBJHKB7ON44UY5AVTG4HU/
  - source: security@huntr.dev
    tags:
    - Third Party Advisory
    url: https://security.gentoo.org/glsa/202208-32
  - source: security@huntr.dev
    url: https://security.gentoo.org/glsa/202305-16
  - source: security@huntr.dev
    tags:
    - Release Notes
    - Third Party Advisory
    url: https://support.apple.com/kb/HT213488
  title: Use of Out-of-range Pointer Offset in GitHub repository vim/vim prior to
    8.2.4774.
- diff_content:
  - "--- a/libr/bin/format/mach0/coresymbolication.c\n+++ b/libr/bin/format/mach0/coresymbolication.c\n\
    @@ -269,6 +269,9 @@ RCoreSymCacheElement *r_coresym_cache_element_new(RBinFile\
    \ *bf, RBuffer *buf, ut\n \t\tfor (i = 0; i < hdr->n_sections && cursor < end;\
    \ i++) {\n \t\t\tut8 *sect_start = cursor;\n \t\t\tRCoreSymCacheElementSection\
    \ *sect = &result->sections[i];\n+\t\t\tif (cursor + (word_size * 4) > end) {\n\
    +\t\t\t\tgoto beach;\n+\t\t\t}\n \t\t\tsect->vaddr = sect->paddr = r_read_ble\
    \ (cursor, false, bits);\n \t\t\tif (sect->vaddr < page_zero_size) {\n \t\t\t\t\
    sect->vaddr += page_zero_size;\n@@ -359,6 +362,10 @@ RCoreSymCacheElement *r_coresym_cache_element_new(RBinFile\
    \ *bf, RBuffer *buf, ut\n \t\t\t\tcontinue;\n \t\t\t}\n \t\t\tstring_origin =\
    \ relative_to_strings? b + start_of_strings : cursor;\n+\t\t\tif (!string_origin)\
    \ {\n+\t\t\t\tcursor += R_CS_EL_SIZE_LSYM;\n+\t\t\t\tcontinue;\n+\t\t\t}\n \t\t\
    \tlsym->flc.file = str_dup_safe (b, string_origin + file_name_off, end);\n \t\t\
    \tif (!lsym->flc.file) {\n \t\t\t\tcursor += R_CS_EL_SIZE_LSYM;"
  - "--- a/libr/bin/p/bin_symbols.c\n+++ b/libr/bin/p/bin_symbols.c\n@@ -353,28 +353,30\
    \ @@ static bool check_buffer(RBinFile *bf, RBuffer *b) {\n }\n \n static RList\
    \ *symbols(RBinFile *bf) {\n-\tRList *res = r_list_newf ((RListFree)r_bin_symbol_free);\n\
    -\tr_return_val_if_fail (res && bf->o && bf->o->bin_obj, res);\n+\tr_return_val_if_fail\
    \ (bf && bf->o && bf->o->bin_obj, NULL);\n \tRCoreSymCacheElement *element = bf->o->bin_obj;\n\
    \ \tsize_t i;\n \tHtUU *hash = ht_uu_new0 ();\n \tif (!hash) {\n-\t\treturn res;\n\
    +\t\treturn NULL;\n \t}\n+\tRList *res = r_list_newf ((RListFree)r_bin_symbol_free);\n\
    \ \tbool found = false;\n-\tfor (i = 0; i < element->hdr->n_lined_symbols; i++)\
    \ {\n-\t\tRCoreSymCacheElementSymbol *sym = (RCoreSymCacheElementSymbol *)&element->lined_symbols[i];\n\
    -\t\tif (!sym) {\n-\t\t\tbreak;\n-\t\t}\n-\t\tht_uu_find (hash, sym->paddr, &found);\n\
    -\t\tif (found) {\n-\t\t\tcontinue;\n-\t\t}\n-\t\tRBinSymbol *s = bin_symbol_from_symbol\
    \ (element, sym);\n-\t\tif (s) {\n-\t\t\tr_list_append (res, s);\n-\t\t\tht_uu_insert\
    \ (hash, sym->paddr, 1);\n+\tif (element->lined_symbols) {\n+\t\tfor (i = 0; i\
    \ < element->hdr->n_lined_symbols; i++) {\n+\t\t\tRCoreSymCacheElementSymbol *sym\
    \ = (RCoreSymCacheElementSymbol *)&element->lined_symbols[i];\n+\t\t\tif (!sym)\
    \ {\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t\tht_uu_find (hash, sym->paddr, &found);\n\
    +\t\t\tif (found) {\n+\t\t\t\tcontinue;\n+\t\t\t}\n+\t\t\tRBinSymbol *s = bin_symbol_from_symbol\
    \ (element, sym);\n+\t\t\tif (s) {\n+\t\t\t\tr_list_append (res, s);\n+\t\t\t\t\
    ht_uu_insert (hash, sym->paddr, 1);\n+\t\t\t}\n \t\t}\n \t}\n \tif (element->symbols)\
    \ {"
  identifiers:
  - CVE-2022-1437
  - CWE-787
  overview: Heap-based Buffer Overflow in GitHub repository radareorg/radare2 prior
    to 5.7.0. The bug causes the program reads data past the end of the intented buffer.
    Typically, this can allow attackers to read sensitive information from other memory
    locations or cause a crash.
  references:
  - source: security@huntr.dev
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/radareorg/radare2/commit/669a404b6d98d5db409a5ebadae4e94b34ef5136
  - source: security@huntr.dev
    tags:
    - Exploit
    - Third Party Advisory
    url: https://huntr.dev/bounties/af6c3e9e-b7df-4d80-b48f-77fdd17b4038
  title: Heap-based Buffer Overflow in GitHub repository radareorg/radare2 prior to
    5.7.0. The bug causes the program reads data past the end of the intented buffer.
    Typically, this can allow attackers to read sensitive information from other memory
    locations or cause a crash.
- diff_content:
  - "--- a/fs/io_uring.c\n+++ b/fs/io_uring.c\n@@ -1736,12 +1736,11 @@ static __cold\
    \ void io_flush_timeouts(struct io_ring_ctx *ctx)\n \t__must_hold(&ctx->completion_lock)\n\
    \ {\n \tu32 seq = ctx->cached_cq_tail - atomic_read(&ctx->cq_timeouts);\n+\tstruct\
    \ io_kiocb *req, *tmp;\n \n \tspin_lock_irq(&ctx->timeout_lock);\n-\twhile (!list_empty(&ctx->timeout_list))\
    \ {\n+\tlist_for_each_entry_safe(req, tmp, &ctx->timeout_list, timeout.list) {\n\
    \ \t\tu32 events_needed, events_got;\n-\t\tstruct io_kiocb *req = list_first_entry(&ctx->timeout_list,\n\
    -\t\t\t\t\t\tstruct io_kiocb, timeout.list);\n \n \t\tif (io_is_timeout_noseq(req))\n\
    \ \t\t\tbreak;\n@@ -1758,7 +1757,6 @@ static __cold void io_flush_timeouts(struct\
    \ io_ring_ctx *ctx)\n \t\tif (events_got < events_needed)\n \t\t\tbreak;\n \n\
    -\t\tlist_del_init(&req->timeout.list);\n \t\tio_kill_timeout(req, 0);\n \t}\n\
    \ \tctx->cq_last_tm_flush = seq;\n@@ -6628,6 +6626,7 @@ static int io_timeout_prep(struct\
    \ io_kiocb *req, const struct io_uring_sqe *sqe,\n \tif (data->ts.tv_sec < 0 ||\
    \ data->ts.tv_nsec < 0)\n \t\treturn -EINVAL;\n \n+\tINIT_LIST_HEAD(&req->timeout.list);\n\
    \ \tdata->mode = io_translate_timeout_mode(flags);\n \thrtimer_init(&data->timer,\
    \ io_timeout_get_clock(data), data->mode);\n "
  identifiers:
  - CVE-2022-29582
  - CWE-362
  overview: In the Linux kernel before 5.17.3, fs/io_uring.c has a use-after-free
    due to a race condition in io_uring timeouts. This can be triggered by a local
    user who has no access to any user namespace; however, the race condition perhaps
    can only be exploited infrequently.
  references:
  - source: cve@mitre.org
    tags:
    - Mailing List
    - Third Party Advisory
    url: http://www.openwall.com/lists/oss-security/2022/04/22/4
  - source: cve@mitre.org
    tags:
    - Mailing List
    - Third Party Advisory
    url: http://www.openwall.com/lists/oss-security/2022/08/08/3
  - source: cve@mitre.org
    tags:
    - Mailing List
    - Vendor Advisory
    url: https://cdn.kernel.org/pub/linux/kernel/v5.x/ChangeLog-5.17.3
  - source: cve@mitre.org
    tags:
    - Mailing List
    - Patch
    - Vendor Advisory
    url: https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=e677edbcabee849bfdd43f1602bccbecf736a646
  - source: cve@mitre.org
    tags:
    - Third Party Advisory
    url: https://github.com/Ruia-ruia/CVE-2022-29582-Exploit
  - source: cve@mitre.org
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/torvalds/linux/commit/e677edbcabee849bfdd43f1602bccbecf736a646
  - source: cve@mitre.org
    tags:
    - Exploit
    - Third Party Advisory
    url: https://ruia-ruia.github.io/2022/08/05/CVE-2022-29582-io-uring/
  - source: cve@mitre.org
    tags:
    - Third Party Advisory
    url: https://www.debian.org/security/2022/dsa-5127
  - source: cve@mitre.org
    tags:
    - Mailing List
    - Third Party Advisory
    url: https://www.openwall.com/lists/oss-security/2022/04/22/3
  title: In the Linux kernel before 5.17.3, fs/io_uring.c has a use-after-free due
    to a race condition in io_uring timeouts. This can be triggered by a local user
    who has no access to any user namespace; however, the race condition perhaps can
    only be exploited infrequently.
- diff_content:
  - "--- a/src/vm.c\n+++ b/src/vm.c\n@@ -1750,10 +1750,7 @@ mrb_vm_exec(mrb_state\
    \ *mrb, const struct RProc *proc, const mrb_code *pc)\n         mrb_exc_set(mrb,\
    \ exc);\n         goto L_RAISE;\n       }\n-      if (target_class->flags & MRB_FL_CLASS_IS_PREPENDED)\
    \ {\n-        target_class = mrb_vm_ci_target_class(ci);\n-      }\n-      else\
    \ if (target_class->tt == MRB_TT_MODULE) {\n+      if ((target_class->flags &\
    \ MRB_FL_CLASS_IS_PREPENDED) || target_class->tt == MRB_TT_MODULE) {\n       \
    \  target_class = mrb_vm_ci_target_class(ci);\n         if (!target_class || target_class->tt\
    \ != MRB_TT_ICLASS) {\n           goto super_typeerror;"
  identifiers:
  - CVE-2022-1427
  - CWE-125
  overview: 'Out-of-bounds Read in mrb_obj_is_kind_of in in GitHub repository mruby/mruby
    prior to 3.2. # Impact: Possible arbitrary code execution if being exploited.'
  references:
  - source: security@huntr.dev
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/mruby/mruby/commit/a4d97934d51cb88954cc49161dc1d151f64afb6b
  - source: security@huntr.dev
    tags:
    - Exploit
    - Third Party Advisory
    url: https://huntr.dev/bounties/23b6f0a9-64f5-421e-a55f-b5b7a671f301
  title: 'Out-of-bounds Read in mrb_obj_is_kind_of in in GitHub repository mruby/mruby
    prior to 3.2. # Impact: Possible arbitrary code execution if being exploited.'
- diff_content:
  - "--- a/libr/util/new_rbtree.c\n+++ b/libr/util/new_rbtree.c\n@@ -138,9 +138,9\
    \ @@ R_API bool r_crbtree_insert(RRBTree *tree, void *data, RRBComparator cmp,\
    \ void *\n \tr_return_val_if_fail (tree && data && cmp, false);\n \tbool inserted\
    \ = false;\n \n-\tif (tree->root == NULL) {\n+\tif (!tree->root) {\n \t\ttree->root\
    \ = _node_new (data, NULL);\n-\t\tif (tree->root == NULL) {\n+\t\tif (!tree->root)\
    \ {\n \t\t\treturn false;\n \t\t}\n \t\tinserted = true;"
  identifiers:
  - CVE-2022-1444
  - CWE-416
  overview: heap-use-after-free in GitHub repository radareorg/radare2 prior to 5.7.0.
    This vulnerability is capable of inducing denial of service.
  references:
  - source: security@huntr.dev
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/radareorg/radare2/commit/14189710859c27981adb4c2c2aed2863c1859ec5
  - source: security@huntr.dev
    tags:
    - Exploit
    - Third Party Advisory
    url: https://huntr.dev/bounties/b438a940-f8a4-4872-b030-59bdd1ab72aa
  title: heap-use-after-free in GitHub repository radareorg/radare2 prior to 5.7.0.
    This vulnerability is capable of inducing denial of service.
- diff_content:
  - "--- a/shlr/java/class.c\n+++ b/shlr/java/class.c\n@@ -1957,10 +1957,10 @@ R_API\
    \ RBinJavaAttrInfo *r_bin_java_get_attr_from_field(RBinJavaField *field, R_B\n\
    \ }\n \n R_API ut8 *r_bin_java_get_attr_buf(RBinJavaObj *bin, ut64 sz, const ut64\
    \ offset, const ut8 *buf, const ut64 len) {\n-\tut8 *attr_buf = NULL;\n+\t// XXX\
    \ this pending is wrong and too expensive\n \tint pending = len - offset;\n \t\
    const ut8 *a_buf = offset + buf;\n-\tattr_buf = (ut8 *) calloc (pending + 1, 1);\n\
    +\tut8 *attr_buf = (ut8 *) calloc (pending + 1, 1);\n \tif (!attr_buf) {\n \t\t\
    eprintf (\"Unable to allocate enough bytes (0x%04\"PFMT64x\n \t\t\t\") to read\
    \ in the attribute.\\n\", sz);\n@@ -3559,7 +3559,9 @@ R_API RBinJavaAttrInfo *r_bin_java_constant_value_attr_new(RBinJavaObj\
    \ *bin, ut8\n \tRBinJavaAttrInfo *attr = r_bin_java_default_attr_new (bin, buffer,\
    \ sz, buf_offset);\n \tif (attr) {\n \t\tattr->type = R_BIN_JAVA_ATTR_TYPE_CONST_VALUE_ATTR;\n\
    -\t\tattr->info.constant_value_attr.constantvalue_idx = R_BIN_JAVA_USHORT (buffer,\
    \ offset);\n+\t\tif (offset + 4 < sz) {\n+\t\t\tattr->info.constant_value_attr.constantvalue_idx\
    \ = R_BIN_JAVA_USHORT (buffer, offset);\n+\t\t}\n \t\toffset += 2;\n \t\tattr->size\
    \ = offset;\n \t}\n@@ -7079,9 +7081,11 @@ R_API ut64 r_bin_java_rtv_annotations_attr_calc_size(RBinJavaAttrInfo\
    \ *attr) {\n \n R_API RBinJavaAttrInfo *r_bin_java_rti_annotations_attr_new(RBinJavaObj\
    \ *bin, ut8 *buffer, ut64 sz, ut64 buf_offset) {\n \tut32 i = 0;\n-\tRBinJavaAttrInfo\
    \ *attr = NULL;\n \tut64 offset = 0;\n-\tattr = r_bin_java_default_attr_new (bin,\
    \ buffer, sz, buf_offset);\n+\tif (buf_offset + 32 >= sz) {\n+\t\treturn NULL;\n\
    +\t}\n+\tRBinJavaAttrInfo *attr = r_bin_java_default_attr_new (bin, buffer, sz,\
    \ buf_offset);\n \toffset += 6;\n \tif (attr) {\n \t\tattr->type = R_BIN_JAVA_ATTR_TYPE_RUNTIME_INVISIBLE_ANNOTATION_ATTR;"
  identifiers:
  - CVE-2022-1451
  - CWE-125
  overview: 'Out-of-bounds Read in r_bin_java_constant_value_attr_new function in
    GitHub repository radareorg/radare2 prior to 5.7.0. The bug causes the program
    reads data past the end 2f the intented buffer. Typically, this can allow attackers
    to read sensitive information from other memory locations or cause a crash. More
    details see [CWE-125: Out-of-bounds read](https://cwe.mitre.org/data/definitions/125.html).'
  references:
  - source: security@huntr.dev
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/radareorg/radare2/commit/0927ed3ae99444e7b47b84e43118deb10fe37529
  - source: security@huntr.dev
    tags:
    - Exploit
    - Issue Tracking
    - Patch
    - Third Party Advisory
    url: https://huntr.dev/bounties/229a2e0d-9e5c-402f-9a24-57fa2eb1aaa7
  title: 'Out-of-bounds Read in r_bin_java_constant_value_attr_new function in GitHub
    repository radareorg/radare2 prior to 5.7.0. The bug causes the program reads
    data past the end 2f the intented buffer. Typically, this can allow attackers
    to read sensitive information from other memory locations or cause a crash. More
    details see [CWE-125: Out-of-bounds read](https://cwe.mitre.org/data/definitions/125.html).'
- diff_content:
  - "--- a/shlr/java/class.c\n+++ b/shlr/java/class.c\n@@ -6933,6 +6933,10 @@ R_API\
    \ RBinJavaAttrInfo *r_bin_java_bootstrap_methods_attr_new(RBinJavaObj *bin,\n\
    \ \toffset += 6;\n \tif (attr) {\n \t\tattr->type = R_BIN_JAVA_ATTR_TYPE_BOOTSTRAP_METHODS_ATTR;\n\
    +\t\tif (offset + 8 > sz)  {\n+\t\t\tfree (attr);\n+\t\t\treturn NULL;\n+\t\t\
    }\n \t\tattr->info.bootstrap_methods_attr.num_bootstrap_methods = R_BIN_JAVA_USHORT\
    \ (buffer, offset);\n \t\toffset += 2;\n \t\tattr->info.bootstrap_methods_attr.bootstrap_methods\
    \ = r_list_newf (r_bin_java_bootstrap_method_free);"
  identifiers:
  - CVE-2022-1452
  - CWE-125
  overview: 'Out-of-bounds Read in r_bin_java_bootstrap_methods_attr_new function
    in GitHub repository radareorg/radare2 prior to 5.7.0. The bug causes the program
    reads data past the end 2f the intented buffer. Typically, this can allow attackers
    to read sensitive information from other memory locations or cause a crash. More
    details see [CWE-125: Out-of-bounds read](https://cwe.mitre.org/data/definitions/125.html).'
  references:
  - source: security@huntr.dev
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/radareorg/radare2/commit/ecc44b6a2f18ee70ac133365de0e509d26d5e168
  - source: security@huntr.dev
    tags:
    - Exploit
    - Issue Tracking
    - Patch
    - Third Party Advisory
    url: https://huntr.dev/bounties/c8f4c2de-7d96-4ad4-857a-c099effca2d6
  title: 'Out-of-bounds Read in r_bin_java_bootstrap_methods_attr_new function in
    GitHub repository radareorg/radare2 prior to 5.7.0. The bug causes the program
    reads data past the end 2f the intented buffer. Typically, this can allow attackers
    to read sensitive information from other memory locations or cause a crash. More
    details see [CWE-125: Out-of-bounds read](https://cwe.mitre.org/data/definitions/125.html).'
- diff_content:
  - "--- a/src/cpu/x86/mp_init.c\n+++ b/src/cpu/x86/mp_init.c\n@@ -726,12 +726,21\
    \ @@ static void asmlinkage smm_do_relocation(void *arg)\n \t * the location of\
    \ the new SMBASE. If using SMM modules then this\n \t * calculation needs to match\
    \ that of the module loader.\n \t */\n+#if CONFIG(X86_SMM_LOADER_VERSION2)\n+\t\
    perm_smbase = smm_get_cpu_smbase(cpu);\n+\tmp_state.perm_smbase = perm_smbase;\n\
    +\tif (!perm_smbase) {\n+\t\tprintk(BIOS_ERR, \"%s: bad SMBASE for CPU %d\\n\"\
    , __func__, cpu);\n+\t\treturn;\n+\t}\n+#else\n \tperm_smbase = mp_state.perm_smbase;\n\
    \ \tperm_smbase -= cpu * runtime->save_state_size;\n-\n-\tprintk(BIOS_DEBUG, \"\
    New SMBASE 0x%08lx\\n\", perm_smbase);\n+#endif\n \n \t/* Setup code checks this\
    \ callback for validity. */\n+\tprintk(BIOS_INFO, \"%s : curr_smbase 0x%x perm_smbase\
    \ 0x%x, cpu = %d\\n\",\n+\t\t__func__, (int)curr_smbase, (int)perm_smbase, cpu);\n\
    \ \tmp_state.ops.relocation_handler(cpu, curr_smbase, perm_smbase);\n \n \tif\
    \ (CONFIG(STM)) {\n@@ -758,9 +767,17 @@ static void adjust_smm_apic_id_map(struct\
    \ smm_loader_params *smm_params)\n \n static int install_relocation_handler(int\
    \ num_cpus, size_t save_state_size)\n {\n+\tint cpus = num_cpus;\n+#if CONFIG(X86_SMM_LOADER_VERSION2)\n\
    +\t/* Default SMRAM size is not big enough to concurrently\n+\t * handle relocation\
    \ for more than ~32 CPU threads\n+\t * therefore, relocate 1 by 1. */\n+\tcpus\
    \ = 1;\n+#endif\n+\n \tstruct smm_loader_params smm_params = {\n \t\t.per_cpu_stack_size\
    \ = CONFIG_SMM_STUB_STACK_SIZE,\n-\t\t.num_concurrent_stacks = num_cpus,\n+\t\t\
    .num_concurrent_stacks = cpus,\n \t\t.per_cpu_save_state_size = save_state_size,\n\
    \ \t\t.num_concurrent_save_states = 1,\n \t\t.handler = smm_do_relocation,\n@@\
    \ -770,9 +787,10 @@ static int install_relocation_handler(int num_cpus, size_t\
    \ save_state_size)\n \tif (mp_state.ops.adjust_smm_params != NULL)\n \t\tmp_state.ops.adjust_smm_params(&smm_params,\
    \ 0);\n \n-\tif (smm_setup_relocation_handler(&smm_params))\n+\tif (smm_setup_relocation_handler(&smm_params))\
    \ {\n+\t\tprintk(BIOS_ERR, \"%s: smm setup failed\\n\", __func__);\n \t\treturn\
    \ -1;\n-\n+\t}\n \tadjust_smm_apic_id_map(&smm_params);\n \n \treturn 0;\n@@ -781,8\
    \ +799,13 @@ static int install_relocation_handler(int num_cpus, size_t save_state_size)\n\
    \ static int install_permanent_handler(int num_cpus, uintptr_t smbase,\n \t\t\t\
    \t\tsize_t smsize, size_t save_state_size)\n {\n-\t/* There are num_cpus concurrent\
    \ stacks and num_cpus concurrent save\n-\t * state areas. Lastly, set the stack\
    \ size to 1KiB. */\n+\t/*\n+\t * All the CPUs will relocate to permanaent handler\
    \ now. Set parameters\n+\t * needed for all CPUs. The placement of each CPUs entry\
    \ point is\n+\t * determined by the loader. This code simply provides the beginning\
    \ of\n+\t * SMRAM region, the number of CPUs who will use the handler, the stack\n\
    +\t * size and save state size for each CPU.\n+\t */\n \tstruct smm_loader_params\
    \ smm_params = {\n \t\t.per_cpu_stack_size = CONFIG_SMM_MODULE_STACK_SIZE,\n \t\
    \t.num_concurrent_stacks = num_cpus,\n@@ -794,7 +817,7 @@ static int install_permanent_handler(int\
    \ num_cpus, uintptr_t smbase,\n \tif (mp_state.ops.adjust_smm_params != NULL)\n\
    \ \t\tmp_state.ops.adjust_smm_params(&smm_params, 1);\n \n-\tprintk(BIOS_DEBUG,\
    \ \"Installing SMM handler to 0x%08lx\\n\", smbase);\n+\tprintk(BIOS_DEBUG, \"\
    Installing permanent SMM handler to 0x%08lx\\n\", smbase);\n \n \tif (smm_load_module((void\
    \ *)smbase, smsize, &smm_params))\n \t\treturn -1;"
  - "--- a/src/cpu/x86/smm/smm_module_loaderv2.c\n+++ b/src/cpu/x86/smm/smm_module_loaderv2.c\n\
    @@ -0,0 +1,655 @@\n+/* SPDX-License-Identifier: GPL-2.0-only */\n+\n+#include\
    \ <stdint.h>\n+#include <string.h>\n+#include <rmodule.h>\n+#include <cpu/x86/smm.h>\n\
    +#include <commonlib/helpers.h>\n+#include <console/console.h>\n+#include <security/intel/stm/SmmStm.h>\n\
    +\n+#define FXSAVE_SIZE 512\n+#define SMM_CODE_SEGMENT_SIZE 0x10000\n+/* FXSAVE\
    \ area during relocation. While it may not be strictly needed the\n+   SMM stub\
    \ code relies on the FXSAVE area being non-zero to enable SSE\n+   instructions\
    \ within SMM mode. */\n+static uint8_t fxsave_area_relocation[CONFIG_MAX_CPUS][FXSAVE_SIZE]\n\
    +__attribute__((aligned(16)));\n+\n+/*\n+ * Components that make up the SMRAM:\n\
    + * 1. Save state - the total save state memory used\n+ * 2. Stack - stacks for\
    \ the CPUs in the SMM handler\n+ * 3. Stub - SMM stub code for calling into handler\n\
    + * 4. Handler - C-based SMM handler.\n+ *\n+ * The components are assumed to\
    \ consist of one consecutive region.\n+ */\n+\n+/* These parameters are used by\
    \ the SMM stub code. A pointer to the params\n+ * is also passed to the C-base\
    \ handler. */\n+struct smm_stub_params {\n+\tu32 stack_size;\n+\tu32 stack_top;\n\
    +\tu32 c_handler;\n+\tu32 c_handler_arg;\n+\tu32 fxsave_area;\n+\tu32 fxsave_area_size;\n\
    +\tstruct smm_runtime runtime;\n+} __packed;\n+\n+/*\n+ * The stub is the entry\
    \ point that sets up protected mode and stacks for each\n+ * CPU. It then calls\
    \ into the SMM handler module. It is encoded as an rmodule.\n+ */\n+extern unsigned\
    \ char _binary_smmstub_start[];\n+\n+/* Per CPU minimum stack size. */\n+#define\
    \ SMM_MINIMUM_STACK_SIZE 32\n+\n+struct cpu_smm_info {\n+\tuint8_t active;\n+\t\
    uintptr_t smbase;\n+\tuintptr_t entry;\n+\tuintptr_t ss_start;\n+\tuintptr_t code_start;\n\
    +\tuintptr_t code_end;\n+};\n+struct cpu_smm_info cpus[CONFIG_MAX_CPUS] = { 0\
    \ };\n+\n+/*\n+ * This method creates a map of all the CPU entry points, save\
    \ state locations\n+ * and the beginning and end of code segments for each CPU.\
    \ This map is used\n+ * during relocation to properly align as many CPUs that\
    \ can fit into the SMRAM\n+ * region. For more information on how SMRAM works,\
    \ refer to the latest Intel\n+ * developer's manuals (volume 3, chapter 34). SMRAM\
    \ is divided up into the\n+ * following regions:\n+ * +-----------------+ Top\
    \ of SMRAM\n+ * |                 | <- MSEG, FXSAVE\n+ * +-----------------+\n\
    + * |    common       |\n+ * |  smi handler    | 64K\n+ * |                 |\n\
    + * +-----------------+\n+ * | CPU 0 code  seg |\n+ * +-----------------+\n+ *\
    \ | CPU 1 code seg  |\n+ * +-----------------+\n+ * | CPU x code seg  |\n+ * +-----------------+\n\
    + * |                 |\n+ * |                 |\n+ * +-----------------+\n+ *\
    \ |    stacks       |\n+ * +-----------------+ <- START of SMRAM\n+ *\n+ * The\
    \ code below checks when a code segment is full and begins placing the remainder\n\
    + * CPUs in the lower segments. The entry point for each CPU is smbase + 0x8000\n\
    + * and save state is smbase + 0x8000 + (0x8000 - state save size). Save state\n\
    + * area grows downward into the CPUs entry point.  Therefore staggering too many\n\
    + * CPUs in one 32K block will corrupt CPU0's entry code as the save states move\n\
    + * downward.\n+ * input : smbase of first CPU (all other CPUs\n+ *         will\
    \ go below this address)\n+ * input : num_cpus in the system. The map will\n+\
    \ *         be created from 0 to num_cpus.\n+ */\n+static int smm_create_map(uintptr_t\
    \ smbase, unsigned int num_cpus,\n+\t\t\tconst struct smm_loader_params *params)\n\
    +{\n+\tunsigned int i;\n+\tstruct rmodule smm_stub;\n+\tunsigned int ss_size =\
    \ params->per_cpu_save_state_size, stub_size;\n+\tunsigned int smm_entry_offset\
    \ = params->smm_main_entry_offset;\n+\tunsigned int seg_count = 0, segments =\
    \ 0, available;\n+\tunsigned int cpus_in_segment = 0;\n+\tunsigned int base =\
    \ smbase;\n+\n+\tif (rmodule_parse(&_binary_smmstub_start, &smm_stub)) {\n+\t\t\
    printk(BIOS_ERR, \"%s: unable to get SMM module size\\n\", __func__);\n+\t\treturn\
    \ 0;\n+\t}\n+\n+\tstub_size = rmodule_memory_size(&smm_stub);\n+\t/* How many\
    \ CPUs can fit into one 64K segment? */\n+\tavailable = 0xFFFF - smm_entry_offset\
    \ - ss_size - stub_size;\n+\tif (available > 0) {\n+\t\tcpus_in_segment = available\
    \ / ss_size;\n+\t\t/* minimum segments needed will always be 1 */\n+\t\tsegments\
    \ = num_cpus / cpus_in_segment + 1;\n+\t\tprintk(BIOS_DEBUG,\n+\t\t\t\"%s: cpus\
    \ allowed in one segment %d\\n\", __func__, cpus_in_segment);\n+\t\tprintk(BIOS_DEBUG,\n\
    +\t\t\t\"%s: min # of segments needed %d\\n\", __func__, segments);\n+\t} else\
    \ {\n+\t\tprintk(BIOS_ERR, \"%s: not enough space in SMM to setup all CPUs\\n\"\
    , __func__);\n+\t\tprintk(BIOS_ERR, \"    save state & stub size need to be reduced\\\
    n\");\n+\t\tprintk(BIOS_ERR, \"    or increase SMRAM size\\n\");\n+\t\treturn\
    \ 0;\n+\t}\n+\n+\tif (sizeof(cpus) / sizeof(struct cpu_smm_info) < num_cpus) {\n\
    +\t\tprintk(BIOS_ERR,\n+\t\t\t\"%s: increase MAX_CPUS in Kconfig\\n\", __func__);\n\
    +\t\treturn 0;\n+\t}\n+\n+\tfor (i = 0; i < num_cpus; i++) {\n+\t\tcpus[i].smbase\
    \ = base;\n+\t\tcpus[i].entry = base + smm_entry_offset;\n+\t\tcpus[i].ss_start\
    \ = cpus[i].entry + (smm_entry_offset - ss_size);\n+\t\tcpus[i].code_start = cpus[i].entry;\n\
    +\t\tcpus[i].code_end = cpus[i].entry + stub_size;\n+\t\tcpus[i].active = 1;\n\
    +\t\tbase -= ss_size;\n+\t\tseg_count++;\n+\t\tif (seg_count >= cpus_in_segment)\
    \ {\n+\t\t\tbase -= smm_entry_offset;\n+\t\t\tseg_count = 0;\n+\t\t}\n+\t}\n+\n\
    +\tif (CONFIG_DEFAULT_CONSOLE_LOGLEVEL >= BIOS_DEBUG) {\n+\t\tseg_count = 0;\n\
    +\t\tfor (i = 0; i < num_cpus; i++) {\n+\t\t\tprintk(BIOS_DEBUG, \"CPU 0x%x\\\
    n\", i);\n+\t\t\tprintk(BIOS_DEBUG,\n+\t\t\t\t\"    smbase %zx  entry %zx\\n\"\
    ,\n+\t\t\t\tcpus[i].smbase, cpus[i].entry);\n+\t\t\tprintk(BIOS_DEBUG,\n+\t\t\t\
    \t\"           ss_start %zx  code_end %zx\\n\",\n+\t\t\t\tcpus[i].ss_start, cpus[i].code_end);\n\
    +\t\t\tseg_count++;\n+\t\t\tif (seg_count >= cpus_in_segment) {\n+\t\t\t\tprintk(BIOS_DEBUG,\n\
    +\t\t\t\t\t\"-------------NEW CODE SEGMENT --------------\\n\");\n+\t\t\t\tseg_count\
    \ = 0;\n+\t\t\t}\n+\t\t}\n+\t}\n+\treturn 1;\n+}\n+\n+/*\n+ * This method expects\
    \ the smm relocation map to be complete.\n+ * This method does not read any HW\
    \ registers, it simply uses a\n+ * map that was created during SMM setup.\n+ *\
    \ input: cpu_num - cpu number which is used as an index into the\n+ *       map\
    \ to return the smbase\n+ */\n+u32 smm_get_cpu_smbase(unsigned int cpu_num)\n\
    +{\n+\tif (cpu_num < CONFIG_MAX_CPUS) {\n+\t\tif (cpus[cpu_num].active)\n+\t\t\
    \treturn cpus[cpu_num].smbase;\n+\t}\n+\treturn 0;\n+}\n+\n+/*\n+ * This method\
    \ assumes that at least 1 CPU has been set up from\n+ * which it will place other\
    \ CPUs below its smbase ensuring that\n+ * save state does not clobber the first\
    \ CPUs init code segment. The init\n+ * code which is the smm stub code is the\
    \ same for all CPUs. They enter\n+ * smm, setup stacks (based on their apic id),\
    \ enter protected mode\n+ * and then jump to the common smi handler.  The stack\
    \ is allocated\n+ * at the beginning of smram (aka tseg base, not smbase). The\
    \ stack\n+ * pointer for each CPU is calculated by using its apic id\n+ * (code\
    \ is in smm_stub.s)\n+ * Each entry point will now have the same stub code which,\
    \ sets up the CPU\n+ * stack, enters protected mode and then jumps to the smi\
    \ handler. It is\n+ * important to enter protected mode before the jump because\
    \ the \"jump to\n+ * address\" might be larger than the 20bit address supported\
    \ by real mode.\n+ * SMI entry right now is in real mode.\n+ * input: smbase -\
    \ this is the smbase of the first cpu not the smbase\n+ *        where tseg starts\
    \ (aka smram_start). All CPUs code segment\n+ *        and stack will be below\
    \ this point except for the common\n+ *        SMI handler which is one segment\
    \ above\n+ * input: num_cpus - number of cpus that need relocation including\n\
    + *        the first CPU (though its code is already loaded)\n+ * input: top of\
    \ stack (stacks work downward by default in Intel HW)\n+ * output: return -1,\
    \ if runtime smi code could not be installed. In\n+ *         this case SMM will\
    \ not work and any SMI's generated will\n+ *         cause a CPU shutdown or general\
    \ protection fault because\n+ *         the appropriate smi handling code was\
    \ not installed\n+ */\n+\n+static int smm_place_entry_code(uintptr_t smbase, unsigned\
    \ int num_cpus,\n+\t\t\t\tunsigned int stack_top, const struct smm_loader_params\
    \ *params)\n+{\n+\tunsigned int i;\n+\tunsigned int size;\n+\tif (smm_create_map(smbase,\
    \ num_cpus, params)) {\n+\t\t/*\n+\t\t * Ensure there was enough space and the\
    \ last CPUs smbase\n+\t\t * did not encroach upon the stack. Stack top is smram\
    \ start\n+\t\t * + size of stack.\n+\t\t */\n+\t\tif (cpus[num_cpus].active) {\n\
    +\t\t\tif (cpus[num_cpus - 1].smbase +\n+\t\t\t\tparams->smm_main_entry_offset\
    \ < stack_top) {\n+\t\t\t\tprintk(BIOS_ERR, \"%s: stack encroachment\\n\", __func__);\n\
    +\t\t\t\tprintk(BIOS_ERR, \"%s: smbase %zx, stack_top %x\\n\",\n+\t\t\t\t\t__func__,\
    \ cpus[num_cpus].smbase, stack_top);\n+\t\t\t\treturn 0;\n+\t\t\t}\n+\t\t}\n+\t\
    } else {\n+\t\tprintk(BIOS_ERR, \"%s: unable to place smm entry code\\n\", __func__);\n\
    +\t\treturn 0;\n+\t}\n+\n+\tprintk(BIOS_INFO, \"%s: smbase %zx, stack_top %x\\\
    n\",\n+\t\t__func__, cpus[num_cpus-1].smbase, stack_top);\n+\n+\t/* start at 1,\
    \ the first CPU stub code is already there */\n+\tsize = cpus[0].code_end - cpus[0].code_start;\n\
    +\tfor (i = 1; i < num_cpus; i++) {\n+\t\tmemcpy((int *)cpus[i].code_start, (int\
    \ *)cpus[0].code_start, size);\n+\t\tprintk(BIOS_DEBUG,\n+\t\t\t\"SMM Module:\
    \ placing smm entry code at %zx,  cpu # 0x%x\\n\",\n+\t\t\tcpus[i].code_start,\
    \ i);\n+\t\tprintk(BIOS_DEBUG, \"%s: copying from %zx to %zx 0x%x bytes\\n\",\n\
    +\t\t\t__func__, cpus[0].code_start, cpus[i].code_start, size);\n+\t}\n+\treturn\
    \ 1;\n+}\n+\n+/*\n+ * Place stacks in base -> base + size region, but ensure the\
    \ stacks don't\n+ * overlap the staggered entry points.\n+ */\n+static void *smm_stub_place_stacks(char\
    \ *base, size_t size,\n+\t\t\t\t   struct smm_loader_params *params)\n+{\n+\t\
    size_t total_stack_size;\n+\tchar *stacks_top;\n+\n+\t/* If stack space is requested\
    \ assume the space lives in the lower\n+\t * half of SMRAM. */\n+\ttotal_stack_size\
    \ = params->per_cpu_stack_size *\n+\t\t\t   params->num_concurrent_stacks;\n+\t\
    printk(BIOS_DEBUG, \"%s: cpus: %zx : stack space: needed -> %zx\\n\",\n+\t\t__func__,\
    \ params->num_concurrent_stacks,\n+\t\ttotal_stack_size);\n+\tprintk(BIOS_DEBUG,\
    \ \"  available -> %zx : per_cpu_stack_size : %zx\\n\",\n+\t\tsize, params->per_cpu_stack_size);\n\
    +\n+\t/* There has to be at least one stack user. */\n+\tif (params->num_concurrent_stacks\
    \ < 1)\n+\t\treturn NULL;\n+\n+\t/* Total stack size cannot fit. */\n+\tif (total_stack_size\
    \ > size)\n+\t\treturn NULL;\n+\n+\t/* Stacks extend down to SMBASE */\n+\tstacks_top\
    \ = &base[total_stack_size];\n+\tprintk(BIOS_DEBUG, \"%s: exit, stack_top %p\\\
    n\", __func__, stacks_top);\n+\n+\treturn stacks_top;\n+}\n+\n+/*\n+ * Place the\
    \ staggered entry points for each CPU. The entry points are\n+ * staggered by\
    \ the per CPU SMM save state size extending down from\n+ * SMM_ENTRY_OFFSET.\n\
    + */\n+static int smm_stub_place_staggered_entry_points(char *base,\n+\tconst\
    \ struct smm_loader_params *params, const struct rmodule *smm_stub)\n+{\n+\tsize_t\
    \ stub_entry_offset;\n+\tint rc = 1;\n+\tstub_entry_offset = rmodule_entry_offset(smm_stub);\n\
    +\t/* Each CPU now has its own stub code, which enters protected mode,\n+\t *\
    \ sets up the stack, and then jumps to common SMI handler\n+\t */\n+\tif (params->num_concurrent_save_states\
    \ > 1 || stub_entry_offset != 0) {\n+\t\trc = smm_place_entry_code((unsigned int)base,\n\
    +\t\t\tparams->num_concurrent_save_states,\n+\t\t\t(unsigned int)params->stack_top,\
    \ params);\n+\t}\n+\treturn rc;\n+}\n+\n+/*\n+ * The stub setup code assumes it\
    \ is completely contained within the\n+ * default SMRAM size (0x10000) for the\
    \ default SMI handler (entry at\n+ * 0x30000), but no assumption should be made\
    \ for the permanent SMI handler.\n+ * The placement of CPU entry points for permanent\
    \ handler are determined\n+ * by the number of CPUs in the system and the amount\
    \ of SMRAM.\n+ * There are potentially 3 regions to place\n+ * within the default\
    \ SMRAM size:\n+ * 1. Save state areas\n+ * 2. Stub code\n+ * 3. Stack areas\n\
    + *\n+ * The save state and smm stack are treated as contiguous for the number\
    \ of\n+ * concurrent areas requested. The save state always lives at the top of\
    \ the\n+ * the CPUS smbase (and the entry point is at offset 0x8000). This allows\
    \ only a certain\n+ * number of CPUs with staggered entry points until the save\
    \ state area comes\n+ * down far enough to overwrite/corrupt the entry code (stub\
    \ code). Therefore,\n+ * an SMM map is created to avoid this corruption, see smm_create_map()\
    \ above.\n+ * This module setup code works for the default (0x30000) SMM handler\
    \ setup and the\n+ * permanent SMM handler.\n+ */\n+static int smm_module_setup_stub(void\
    \ *smbase, size_t smm_size,\n+\t\t\t\t struct smm_loader_params *params,\n+\t\t\
    \t\t void *fxsave_area)\n+{\n+\tsize_t total_save_state_size;\n+\tsize_t smm_stub_size;\n\
    +\tsize_t stub_entry_offset;\n+\tchar *smm_stub_loc;\n+\tvoid *stacks_top;\n+\t\
    size_t size;\n+\tchar *base;\n+\tsize_t i;\n+\tstruct smm_stub_params *stub_params;\n\
    +\tstruct rmodule smm_stub;\n+\tunsigned int total_size_all;\n+\tbase = smbase;\n\
    +\tsize = smm_size;\n+\n+\t/* The number of concurrent stacks cannot exceed CONFIG_MAX_CPUS.\
    \ */\n+\tif (params->num_concurrent_stacks > CONFIG_MAX_CPUS) {\n+\t\tprintk(BIOS_ERR,\
    \ \"%s: not enough stacks\\n\", __func__);\n+\t\treturn -1;\n+\t}\n+\n+\t/* Fail\
    \ if can't parse the smm stub rmodule. */\n+\tif (rmodule_parse(&_binary_smmstub_start,\
    \ &smm_stub)) {\n+\t\tprintk(BIOS_ERR, \"%s: unable to parse smm stub\\n\", __func__);\n\
    +\t\treturn -1;\n+\t}\n+\n+\t/* Adjust remaining size to account for save state.\
    \ */\n+\ttotal_save_state_size = params->per_cpu_save_state_size *\n+\t\t\t\t\
    params->num_concurrent_save_states;\n+\tif (total_save_state_size > size) {\n\
    +\t\tprintk(BIOS_ERR,\n+\t\t\t\"%s: more state save space needed:need -> %zx:available->%zx\\\
    n\",\n+\t\t\t__func__, total_save_state_size, size);\n+\t\treturn -1;\n+\t}\n\
    +\n+\tsize -= total_save_state_size;\n+\n+\t/* The save state size encroached\
    \ over the first SMM entry point. */\n+\tif (size <= params->smm_main_entry_offset)\
    \ {\n+\t\tprintk(BIOS_ERR, \"%s: encroachment over SMM entry point\\n\", __func__);\n\
    +\t\tprintk(BIOS_ERR, \"%s: state save size: %zx : smm_entry_offset -> %x\\n\"\
    ,\n+\t\t\t__func__, size, params->smm_main_entry_offset);\n+\t\treturn -1;\n+\t\
    }\n+\n+\t/* Need a minimum stack size and alignment. */\n+\tif (params->per_cpu_stack_size\
    \ <= SMM_MINIMUM_STACK_SIZE ||\n+\t    (params->per_cpu_stack_size & 3) != 0)\
    \ {\n+\t\tprintk(BIOS_ERR, \"%s: need minimum stack size\\n\", __func__);\n+\t\
    \treturn -1;\n+\t}\n+\n+\tsmm_stub_loc = NULL;\n+\tsmm_stub_size = rmodule_memory_size(&smm_stub);\n\
    +\tstub_entry_offset = rmodule_entry_offset(&smm_stub);\n+\n+\t/* Put the stub\
    \ at the main entry point */\n+\tsmm_stub_loc = &base[params->smm_main_entry_offset];\n\
    +\n+\t/* Stub is too big to fit. */\n+\tif (smm_stub_size > (size - params->smm_main_entry_offset))\
    \ {\n+\t\tprintk(BIOS_ERR, \"%s: stub is too big to fit\\n\", __func__);\n+\t\t\
    return -1;\n+\t}\n+\n+\t/* The stacks, if requested, live in the lower half of\
    \ SMRAM space\n+\t * for default handler, but for relocated handler it lives at\
    \ the beginning\n+\t * of SMRAM which is TSEG base\n+\t */\n+\tsize = params->num_concurrent_stacks\
    \ * params->per_cpu_stack_size;\n+\tstacks_top = smm_stub_place_stacks((char *)params->smram_start,\
    \ size, params);\n+\tif (stacks_top == NULL) {\n+\t\tprintk(BIOS_ERR, \"%s: not\
    \ enough space for stacks\\n\", __func__);\n+\t\tprintk(BIOS_ERR, \"%s: ....need\
    \ -> %p : available -> %zx\\n\", __func__,\n+\t\t\tbase, size);\n+\t\treturn -1;\n\
    +\t}\n+\tparams->stack_top = stacks_top;\n+\t/* Load the stub. */\n+\tif (rmodule_load(smm_stub_loc,\
    \ &smm_stub)) {\n+\t\tprintk(BIOS_ERR, \"%s: load module failed\\n\", __func__);\n\
    +\t\treturn -1;\n+\t}\n+\n+\tif (!smm_stub_place_staggered_entry_points(base,\
    \ params, &smm_stub)) {\n+\t\tprintk(BIOS_ERR, \"%s: staggered entry points failed\\\
    n\", __func__);\n+\t\treturn -1;\n+\t}\n+\n+\t/* Setup the parameters for the\
    \ stub code. */\n+\tstub_params = rmodule_parameters(&smm_stub);\n+\tstub_params->stack_top\
    \ = (uintptr_t)stacks_top;\n+\tstub_params->stack_size = params->per_cpu_stack_size;\n\
    +\tstub_params->c_handler = (uintptr_t)params->handler;\n+\tstub_params->c_handler_arg\
    \ = (uintptr_t)params->handler_arg;\n+\tstub_params->fxsave_area = (uintptr_t)fxsave_area;\n\
    +\tstub_params->fxsave_area_size = FXSAVE_SIZE;\n+\tstub_params->runtime.smbase\
    \ = (uintptr_t)smbase;\n+\tstub_params->runtime.smm_size = smm_size;\n+\tstub_params->runtime.save_state_size\
    \ = params->per_cpu_save_state_size;\n+\tstub_params->runtime.num_cpus = params->num_concurrent_stacks;\n\
    +\n+\tprintk(BIOS_DEBUG, \"%s: stack_end = 0x%x\\n\",\n+\t\t__func__, stub_params->runtime.smbase);\n\
    +\tprintk(BIOS_DEBUG,\n+\t\t\"%s: stack_top = 0x%x\\n\", __func__, stub_params->stack_top);\n\
    +\tprintk(BIOS_DEBUG, \"%s: stack_size = 0x%x\\n\",\n+\t\t__func__, stub_params->stack_size);\n\
    +\tprintk(BIOS_DEBUG, \"%s: runtime.smbase = 0x%x\\n\",\n+\t\t__func__, stub_params->runtime.smbase);\n\
    +\tprintk(BIOS_DEBUG, \"%s: runtime.start32_offset = 0x%x\\n\", __func__,\n+\t\
    \tstub_params->runtime.start32_offset);\n+\tprintk(BIOS_DEBUG, \"%s: runtime.smm_size\
    \ = 0x%zx\\n\",\n+\t\t__func__, smm_size);\n+\tprintk(BIOS_DEBUG, \"%s: per_cpu_save_state_size\
    \ = 0x%x\\n\",\n+\t\t__func__, stub_params->runtime.save_state_size);\n+\tprintk(BIOS_DEBUG,\
    \ \"%s: num_cpus = 0x%x\\n\", __func__,\n+\t\tstub_params->runtime.num_cpus);\n\
    +\tprintk(BIOS_DEBUG, \"%s: total_save_state_size = 0x%x\\n\",\n+\t\t__func__,\
    \ (stub_params->runtime.save_state_size *\n+\t\tstub_params->runtime.num_cpus));\n\
    +\ttotal_size_all = stub_params->stack_size +\n+\t\t(stub_params->runtime.save_state_size\
    \ *\n+\t\tstub_params->runtime.num_cpus);\n+\tprintk(BIOS_DEBUG, \"%s: total_size_all\
    \ = 0x%x\\n\", __func__,\n+\t\ttotal_size_all);\n+\n+\t/* Initialize the APIC\
    \ id to CPU number table to be 1:1 */\n+\tfor (i = 0; i < params->num_concurrent_stacks;\
    \ i++)\n+\t\tstub_params->runtime.apic_id_to_cpu[i] = i;\n+\n+\t/* Allow the initiator\
    \ to manipulate SMM stub parameters. */\n+\tparams->runtime = &stub_params->runtime;\n\
    +\n+\tprintk(BIOS_DEBUG, \"SMM Module: stub loaded at %p. Will call %p(%p)\\n\"\
    ,\n+\t       smm_stub_loc, params->handler, params->handler_arg);\n+\treturn 0;\n\
    +}\n+\n+/*\n+ * smm_setup_relocation_handler assumes the callback is already loaded\
    \ in\n+ * memory. i.e. Another SMM module isn't chained to the stub. The other\n\
    + * assumption is that the stub will be entered from the default SMRAM\n+ * location:\
    \ 0x30000 -> 0x40000.\n+ */\n+int smm_setup_relocation_handler(struct smm_loader_params\
    \ *params)\n+{\n+\tvoid *smram = (void *)(SMM_DEFAULT_BASE);\n+\tprintk(BIOS_SPEW,\
    \ \"%s: enter\\n\", __func__);\n+\t/* There can't be more than 1 concurrent save\
    \ state for the relocation\n+\t * handler because all CPUs default to 0x30000\
    \ as SMBASE. */\n+\tif (params->num_concurrent_save_states > 1)\n+\t\treturn -1;\n\
    +\n+\t/* A handler has to be defined to call for relocation. */\n+\tif (params->handler\
    \ == NULL)\n+\t\treturn -1;\n+\n+\t/* Since the relocation handler always uses\
    \ stack, adjust the number\n+\t * of concurrent stack users to be CONFIG_MAX_CPUS.\
    \ */\n+\tif (params->num_concurrent_stacks == 0)\n+\t\tparams->num_concurrent_stacks\
    \ = CONFIG_MAX_CPUS;\n+\n+\tparams->smm_main_entry_offset = SMM_ENTRY_OFFSET;\n\
    +\tparams->smram_start = SMM_DEFAULT_BASE;\n+\tparams->smram_end = SMM_DEFAULT_BASE\
    \ + SMM_DEFAULT_SIZE;\n+\treturn smm_module_setup_stub(smram, SMM_DEFAULT_SIZE,\n\
    +\t\t\t\tparams, fxsave_area_relocation);\n+\tprintk(BIOS_SPEW, \"%s: exit\\n\"\
    , __func__);\n+}\n+\n+/*\n+ *The SMM module is placed within the provided region\
    \ in the following\n+ * manner:\n+ * +-----------------+ <- smram + size\n+ *\
    \ | BIOS resource   |\n+ * | list (STM)      |\n+ * +-----------------+\n+ * |\
    \  fxsave area    |\n+ * +-----------------+\n+ * |  smi handler    |\n+ * | \
    \     ...        |\n+ * +-----------------+ <- cpu0\n+ * |    stub code    | <-\
    \ cpu1\n+ * |    stub code    | <- cpu2\n+ * |    stub code    | <- cpu3, etc\n\
    + * |                 |\n+ * |                 |\n+ * |                 |\n+ *\
    \ |    stacks       |\n+ * +-----------------+ <- smram start\n+\n+ * It should\
    \ be noted that this algorithm will not work for\n+ * SMM_DEFAULT_SIZE SMRAM regions\
    \ such as the A segment. This algorithm\n+ * expects a region large enough to\
    \ encompass the handler and stacks\n+ * as well as the SMM_DEFAULT_SIZE.\n+ */\n\
    +int smm_load_module(void *smram, size_t size, struct smm_loader_params *params)\n\
    +{\n+\tstruct rmodule smm_mod;\n+\tsize_t total_stack_size;\n+\tsize_t handler_size;\n\
    +\tsize_t module_alignment;\n+\tsize_t alignment_size;\n+\tsize_t fxsave_size;\n\
    +\tvoid *fxsave_area;\n+\tsize_t total_size = 0;\n+\tchar *base;\n+\n+\tif (size\
    \ <= SMM_DEFAULT_SIZE)\n+\t\treturn -1;\n+\n+\t/* Load main SMI handler at the\
    \ top of SMRAM\n+\t * everything else will go below\n+\t */\n+\tbase = smram;\n\
    +\tbase += size;\n+\tparams->smram_start = (uintptr_t)smram;\n+\tparams->smram_end\
    \ = params->smram_start + size;\n+\tparams->smm_main_entry_offset = SMM_ENTRY_OFFSET;\n\
    +\n+\t/* Fail if can't parse the smm rmodule. */\n+\tif (rmodule_parse(&_binary_smm_start,\
    \ &smm_mod))\n+\t\treturn -1;\n+\n+\t/* Clear SMM region */\n+\tif (CONFIG(DEBUG_SMI))\n\
    +\t\tmemset(smram, 0xcd, size);\n+\n+\ttotal_stack_size = params->per_cpu_stack_size\
    \ *\n+\t\t\t   params->num_concurrent_stacks;\n+\ttotal_size += total_stack_size;\n\
    +\t/* Stacks are the base of SMRAM */\n+\tparams->stack_top = smram + total_stack_size;\n\
    +\n+\t/* MSEG starts at the top of SMRAM and works down */\n+\tif (CONFIG(STM))\
    \ {\n+\t\tbase -= CONFIG_MSEG_SIZE + CONFIG_BIOS_RESOURCE_LIST_SIZE;\n+\t\ttotal_size\
    \ += CONFIG_MSEG_SIZE + CONFIG_BIOS_RESOURCE_LIST_SIZE;\n+\t}\n+\n+\t/* FXSAVE\
    \ goes below MSEG */\n+\tif (CONFIG(SSE)) {\n+\t\tfxsave_size = FXSAVE_SIZE *\
    \ params->num_concurrent_stacks;\n+\t\tfxsave_area = base - fxsave_size;\n+\t\t\
    base -= fxsave_size;\n+\t\ttotal_size += fxsave_size;\n+\t} else {\n+\t\tfxsave_size\
    \ = 0;\n+\t\tfxsave_area = NULL;\n+\t}\n+\n+\n+\thandler_size = rmodule_memory_size(&smm_mod);\n\
    +\tbase -= handler_size;\n+\ttotal_size += handler_size;\n+\tmodule_alignment\
    \ = rmodule_load_alignment(&smm_mod);\n+\talignment_size = module_alignment -\n\
    +\t\t\t\t((uintptr_t)base % module_alignment);\n+\tif (alignment_size != module_alignment)\
    \ {\n+\t\thandler_size += alignment_size;\n+\t\tbase += alignment_size;\n+\t}\n\
    +\n+\tprintk(BIOS_DEBUG,\n+\t\t\"%s: total_smm_space_needed %zx, available ->\
    \ %zx\\n\",\n+\t\t __func__, total_size, size);\n+\n+\t/* Does the required amount\
    \ of memory exceed the SMRAM region size? */\n+\tif (total_size > size) {\n+\t\
    \tprintk(BIOS_ERR, \"%s: need more SMRAM\\n\", __func__);\n+\t\treturn -1;\n+\t\
    }\n+\tif (handler_size > SMM_CODE_SEGMENT_SIZE) {\n+\t\tprintk(BIOS_ERR, \"%s:\
    \ increase SMM_CODE_SEGMENT_SIZE: handler_size = %zx\\n\",\n+\t\t\t__func__, handler_size);\n\
    +\t\treturn -1;\n+\t}\n+\n+\tif (rmodule_load(base, &smm_mod))\n+\t\treturn -1;\n\
    +\n+\tparams->handler = rmodule_entry(&smm_mod);\n+\tparams->handler_arg = rmodule_parameters(&smm_mod);\n\
    +\n+\tprintk(BIOS_DEBUG, \"%s: smram_start: 0x%p\\n\",\n+\t\t __func__, smram);\n\
    +\tprintk(BIOS_DEBUG, \"%s: smram_end: %p\\n\",\n+\t\t __func__, smram + size);\n\
    +\tprintk(BIOS_DEBUG, \"%s: stack_top: %p\\n\",\n+\t\t __func__, params->stack_top);\n\
    +\tprintk(BIOS_DEBUG, \"%s: handler start %p\\n\",\n+\t\t __func__, params->handler);\n\
    +\tprintk(BIOS_DEBUG, \"%s: handler_size %zx\\n\",\n+\t\t __func__, handler_size);\n\
    +\tprintk(BIOS_DEBUG, \"%s: handler_arg %p\\n\",\n+\t\t __func__, params->handler_arg);\n\
    +\tprintk(BIOS_DEBUG, \"%s: fxsave_area %p\\n\",\n+\t\t __func__, fxsave_area);\n\
    +\tprintk(BIOS_DEBUG, \"%s: fxsave_size %zx\\n\",\n+\t\t __func__, fxsave_size);\n\
    +\tprintk(BIOS_DEBUG, \"%s: CONFIG_MSEG_SIZE 0x%x\\n\",\n+\t\t __func__, CONFIG_MSEG_SIZE);\n\
    +\tprintk(BIOS_DEBUG, \"%s: CONFIG_BIOS_RESOURCE_LIST_SIZE 0x%x\\n\",\n+\t\t __func__,\
    \ CONFIG_BIOS_RESOURCE_LIST_SIZE);\n+\n+\t/* CPU 0 smbase goes first, all other\
    \ CPUs\n+\t * will be staggered below\n+\t */\n+\tbase -= SMM_CODE_SEGMENT_SIZE;\n\
    +\tprintk(BIOS_DEBUG, \"%s: cpu0 entry: %p\\n\",\n+\t\t __func__, base);\n+\t\
    params->smm_entry = (uintptr_t)base + params->smm_main_entry_offset;\n+\treturn\
    \ smm_module_setup_stub(base, size, params, fxsave_area);\n+}"
  identifiers:
  - CVE-2022-29264
  - NVD-CWE-noinfo
  overview: An issue was discovered in coreboot 4.13 through 4.16. On APs, arbitrary
    code execution in SMM may occur.
  references:
  - source: cve@mitre.org
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/coreboot/coreboot/commit/afb7a814783cda12f5b72167163b9109ee1d15a7
  - source: cve@mitre.org
    tags:
    - Vendor Advisory
    url: https://review.coreboot.org/c/coreboot/+/63478
  title: An issue was discovered in coreboot 4.13 through 4.16. On APs, arbitrary
    code execution in SMM may occur.
- diff_content:
  - "--- a/pjlib/src/pj/file_io_ansi.c\n+++ b/pjlib/src/pj/file_io_ansi.c\n@@ -20,6\
    \ +20,7 @@\n #include <pj/file_io.h>\n #include <pj/assert.h>\n #include <pj/errno.h>\n\
    +#include <pj/limits.h>\n #include <stdio.h>\n #include <errno.h>\n \n@@ -124,6\
    \ +125,12 @@ PJ_DEF(pj_status_t) pj_file_setpos( pj_oshandle_t fd,\n {\n     int\
    \ mode;\n \n+    if ((sizeof(pj_off_t) > sizeof(long)) &&\n+        (offset >\
    \ PJ_MAXLONG || offset < PJ_MINLONG)) \n+    {\n+        return PJ_ENOTSUP;\n\
    +    }\n+\n     switch (whence) {\n     case PJ_SEEK_SET:\n         mode = SEEK_SET;\
    \ break;"
  - "--- a/pjmedia/src/pjmedia/avi_player.c\n+++ b/pjmedia/src/pjmedia/avi_player.c\n\
    @@ -282,7 +282,7 @@ pjmedia_avi_player_create_streams(pj_pool_t *pool,\n     /*\
    \ Read the headers of each stream. */\n     for (i = 0; i < avi_hdr.avih_hdr.num_streams;\
    \ i++) {\n         pj_size_t elem = 0;\n-        pj_ssize_t size_to_read;\n+ \
    \       pj_off_t size_to_read;\n \n         /* Read strl header */\n         status\
    \ = file_read(fport[0]->fd, &avi_hdr.strl_hdr[i],\n@@ -335,6 +335,7 @@ pjmedia_avi_player_create_streams(pj_pool_t\
    \ *pool,\n     do {\n         pjmedia_avi_subchunk ch;\n         int read = 0;\n\
    +        pj_off_t size_to_read;\n \n         status = file_read(fport[0]->fd,\
    \ &ch, sizeof(pjmedia_avi_subchunk));\n         if (status != PJ_SUCCESS) {\n\
    @@ -349,7 +350,15 @@ pjmedia_avi_player_create_streams(pj_pool_t *pool,\n    \
    \             break;\n         }\n \n-        status = pj_file_setpos(fport[0]->fd,\
    \ ch.len-read, PJ_SEEK_CUR);\n+        if (ch.len < read) {\n+            status\
    \ = PJ_EINVAL;\n+            goto on_error;\n+        }\n+        PJ_CHECK_OVERFLOW_UINT32_TO_LONG(ch.len\
    \ - read, \n+                                         status = PJ_EINVAL; goto\
    \ on_error;);\n+        size_to_read = (pj_off_t)ch.len - read;\n+\n+        status\
    \ = pj_file_setpos(fport[0]->fd, size_to_read, PJ_SEEK_CUR);\n         if (status\
    \ != PJ_SUCCESS) {\n             goto on_error;\n         }\n@@ -775,6 +784,8\
    \ @@ static pj_status_t avi_get_frame(pjmedia_port *this_port,\n         /* Read\
    \ new chunk data */\n         if (fport->size_left == 0) {\n             pj_off_t\
    \ pos;\n+            pj_off_t ch_len;\n+\n             pj_file_getpos(fport->fd,\
    \ &pos);\n \n             /* Data is padded to the nearest WORD boundary */\n\
    @@ -788,6 +799,10 @@ static pj_status_t avi_get_frame(pjmedia_port *this_port,\n\
    \                 size_read = 0;\n                 goto on_error2;\n         \
    \    }\n+            \n+            PJ_CHECK_OVERFLOW_UINT32_TO_LONG(ch.len, \n\
    +                                         status = PJ_EINVAL;  goto on_error2;);\n\
    +            ch_len = ch.len;\n \n             cid = (char *)&ch.id;\n       \
    \      if (cid[0] >= '0' && cid[0] <= '9' &&\n@@ -814,8 +829,7 @@ static pj_status_t\
    \ avi_get_frame(pjmedia_port *this_port,\n                     goto on_error2;\n\
    \                 }\n \n-                status = pj_file_setpos(fport->fd, ch.len,\n\
    -                                        PJ_SEEK_CUR);\n+                status\
    \ = pj_file_setpos(fport->fd, ch_len, PJ_SEEK_CUR);\n                 continue;\n\
    \             }\n             fport->size_left = ch.len;"
  - "--- a/pjmedia/src/pjmedia/wav_player.c\n+++ b/pjmedia/src/pjmedia/wav_player.c\n\
    @@ -188,7 +188,8 @@ PJ_DEF(pj_status_t) pjmedia_wav_player_port_create( pj_pool_t\
    \ *pool,\n \t\t\t\t\t\t     pjmedia_port **p_port )\n {\n     pjmedia_wave_hdr\
    \ wave_hdr;\n-    pj_ssize_t size_to_read, size_read;\n+    pj_ssize_t size_read;\n\
    +    pj_off_t size_to_read;\n     struct file_reader_port *fport;\n     pjmedia_audio_format_detail\
    \ *ad;\n     pj_off_t pos;\n@@ -234,7 +235,7 @@ PJ_DEF(pj_status_t) pjmedia_wav_player_port_create(\
    \ pj_pool_t *pool,\n \treturn status;\n \n     /* Read the file header plus fmt\
    \ header only. */\n-    size_read = size_to_read = sizeof(wave_hdr) - 8;\n+  \
    \  size_to_read = size_read = sizeof(wave_hdr) - 8;\n     status = pj_file_read(\
    \ fport->fd, &wave_hdr, &size_read);\n     if (status != PJ_SUCCESS) {\n \tpj_file_close(fport->fd);\n\
    @@ -297,7 +298,9 @@ PJ_DEF(pj_status_t) pjmedia_wav_player_port_create( pj_pool_t\
    \ *pool,\n      * fmt header data.\n      */\n     if (wave_hdr.fmt_hdr.len >\
    \ 16) {\n-\tsize_to_read = wave_hdr.fmt_hdr.len - 16;\n+\tPJ_CHECK_OVERFLOW_UINT32_TO_LONG(wave_hdr.fmt_hdr.len\
    \ - 16,\n+\t\t      pj_file_close(fport->fd); return PJMEDIA_ENOTVALIDWAVE;);\n\
    +\tsize_to_read = (pj_off_t)wave_hdr.fmt_hdr.len - 16;\n \tstatus = pj_file_setpos(fport->fd,\
    \ size_to_read, PJ_SEEK_CUR);\n \tif (status != PJ_SUCCESS) {\n \t    pj_file_close(fport->fd);\n\
    @@ -326,7 +329,10 @@ PJ_DEF(pj_status_t) pjmedia_wav_player_port_create( pj_pool_t\
    \ *pool,\n \t}\n \n \t/* Otherwise skip the chunk contents */\n+\tPJ_CHECK_OVERFLOW_UINT32_TO_LONG(subchunk.len,\
    \ \n+\t\t      pj_file_close(fport->fd); return PJMEDIA_ENOTVALIDWAVE;);\n \t\
    size_to_read = subchunk.len;\n+\n \tstatus = pj_file_setpos(fport->fd, size_to_read,\
    \ PJ_SEEK_CUR);\n \tif (status != PJ_SUCCESS) {\n \t    pj_file_close(fport->fd);"
  - "--- a/pjmedia/src/pjmedia/wav_playlist.c\n+++ b/pjmedia/src/pjmedia/wav_playlist.c\n\
    @@ -419,7 +419,8 @@ PJ_DEF(pj_status_t) pjmedia_wav_playlist_create(pj_pool_t\
    \ *pool,\n     for (index=file_count-1; index>=0; index--) {\n \n \tpjmedia_wave_hdr\
    \ wavehdr;\n-\tpj_ssize_t size_to_read, size_read;\n+\tpj_ssize_t size_read;\n\
    +\tpj_off_t size_to_read;\n \n \t/* we end with the last one so we are good to\
    \ go if still in function*/\n \tpj_memcpy(filename, file_list[index].ptr, file_list[index].slen);\n\
    @@ -442,7 +443,7 @@ PJ_DEF(pj_status_t) pjmedia_wav_playlist_create(pj_pool_t\
    \ *pool,\n \t    goto on_error;\n \t\n \t/* Read the file header plus fmt header\
    \ only. */\n-\tsize_read = size_to_read = sizeof(wavehdr) - 8;\n+\tsize_to_read\
    \ = size_read = sizeof(wavehdr) - 8;\t\n \tstatus = pj_file_read( fport->fd_list[index],\
    \ &wavehdr, &size_read);\n \tif (status != PJ_SUCCESS) {\n \t    goto on_error;\n\
    @@ -492,7 +493,9 @@ PJ_DEF(pj_status_t) pjmedia_wav_playlist_create(pj_pool_t\
    \ *pool,\n \t * fmt header data.\n \t */\n \tif (wavehdr.fmt_hdr.len > 16) {\n\
    -\t    size_to_read = wavehdr.fmt_hdr.len - 16;\n+\t    PJ_CHECK_OVERFLOW_UINT32_TO_LONG(wavehdr.fmt_hdr.len-16,\n\
    +\t\t\t       status = PJMEDIA_ENOTVALIDWAVE; goto on_error;);\n+\t    size_to_read\
    \ = (pj_off_t)wavehdr.fmt_hdr.len - 16;\n \t    status = pj_file_setpos(fport->fd_list[index],\
    \ size_to_read, \n \t\t\t\t    PJ_SEEK_CUR);\n \t    if (status != PJ_SUCCESS)\
    \ {\n@@ -522,7 +525,10 @@ PJ_DEF(pj_status_t) pjmedia_wav_playlist_create(pj_pool_t\
    \ *pool,\n \t    }\n \t    \n \t    /* Otherwise skip the chunk contents */\n\
    +\t    PJ_CHECK_OVERFLOW_UINT32_TO_LONG(subchunk.len, \n+\t\t\t       status =\
    \ PJMEDIA_ENOTVALIDWAVE; goto on_error;);\n \t    size_to_read = subchunk.len;\n\
    +\n \t    status = pj_file_setpos(fport->fd_list[index], size_to_read, \n \t\t\
    \t\t    PJ_SEEK_CUR);\n \t    if (status != PJ_SUCCESS) {"
  identifiers:
  - CVE-2022-24792
  - CWE-835
  overview: PJSIP is a free and open source multimedia communication library written
    in C. A denial-of-service vulnerability affects applications on a 32-bit systems
    that use PJSIP versions 2.12 and prior to play/read invalid WAV files. The vulnerability
    occurs when reading WAV file data chunks with length greater than 31-bit integers.
    The vulnerability does not affect 64-bit apps and should not affect apps that
    only plays trusted WAV files. A patch is available on the `master` branch of the
    `pjsip/project` GitHub repository. As a workaround, apps can reject a WAV file
    received from an unknown source or validate the file first.
  references:
  - source: security-advisories@github.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/pjsip/pjproject/commit/947bc1ee6d05be10204b918df75a503415fd3213
  - source: security-advisories@github.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/pjsip/pjproject/security/advisories/GHSA-rwgw-vwxg-q799
  - source: security-advisories@github.com
    tags:
    - Mailing List
    - Third Party Advisory
    url: https://lists.debian.org/debian-lts-announce/2022/05/msg00047.html
  - source: security-advisories@github.com
    tags:
    - Mailing List
    - Third Party Advisory
    url: https://lists.debian.org/debian-lts-announce/2022/11/msg00021.html
  - source: security-advisories@github.com
    tags:
    - Third Party Advisory
    url: https://security.gentoo.org/glsa/202210-37
  - source: security-advisories@github.com
    tags:
    - Mailing List
    - Third Party Advisory
    url: https://www.debian.org/security/2022/dsa-5285
  title: PJSIP is a free and open source multimedia communication library written
    in C. A denial-of-service vulnerability affects applications on a 32-bit systems
    that use PJSIP versions 2.12 and prior to play/read invalid WAV files. The vulnerability
    occurs when reading WAV file data chunks with length greater than 31-bit integers.
    The vulnerability does not affect 64-bit apps and should not affect apps that
    only plays trusted WAV files. A patch is available on the `master` branch of the
    `pjsip/project` GitHub repository. As a workaround, apps can reject a WAV file
    received from an unknown source or validate the file first.
- diff_content:
  - "--- a/src/isomedia/box_code_3gpp.c\n+++ b/src/isomedia/box_code_3gpp.c\n@@ -1128,20\
    \ +1128,12 @@ void diST_box_del(GF_Box *s)\n \n GF_Err diST_box_read(GF_Box *s,\
    \ GF_BitStream *bs)\n {\n-\tu32 i;\n-\tchar str[1024];\n \tGF_DIMSScriptTypesBox\
    \ *p = (GF_DIMSScriptTypesBox *)s;\n \n-\ti=0;\n-\tstr[0]=0;\n-\twhile (1) {\n\
    -\t\tstr[i] = gf_bs_read_u8(bs);\n-\t\tif (!str[i]) break;\n-\t\ti++;\n-\t}\n\
    -\tISOM_DECREASE_SIZE(p, i);\n-\n-\tp->content_script_types = gf_strdup(str);\n\
    +\tp->content_script_types = gf_malloc(sizeof(char) * (s->size+1));\n+\tif (!p->content_script_types)\
    \ return GF_OUT_OF_MEM;\n+\tgf_bs_read_data(bs, p->content_script_types, s->size);\n\
    +\tp->content_script_types[s->size] = 0;\n \treturn GF_OK;\n }\n "
  identifiers:
  - CVE-2022-1441
  - CWE-125
  overview: MP4Box is a component of GPAC-2.0.0, which is a widely-used third-party
    package on RPM Fusion. When MP4Box tries to parse a MP4 file, it calls the function
    `diST_box_read()` to read from video. In this function, it allocates a buffer
    `str` with fixed length. However, content read from `bs` is controllable by user,
    so is the length, which causes a buffer overflow.
  references:
  - source: secalert@redhat.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/gpac/gpac/commit/3dbe11b37d65c8472faf0654410068e5500b3adb
  - source: secalert@redhat.com
    tags:
    - Exploit
    - Issue Tracking
    - Third Party Advisory
    url: https://github.com/gpac/gpac/issues/2175
  - source: secalert@redhat.com
    tags:
    - Third Party Advisory
    url: https://www.debian.org/security/2023/dsa-5411
  title: MP4Box is a component of GPAC-2.0.0, which is a widely-used third-party package
    on RPM Fusion. When MP4Box tries to parse a MP4 file, it calls the function `diST_box_read()`
    to read from video. In this function, it allocates a buffer `str` with fixed length.
    However, content read from `bs` is controllable by user, so is the length, which
    causes a buffer overflow.
- diff_content:
  - "--- a/winpr/libwinpr/sspi/NTLM/ntlm_compute.c\n+++ b/winpr/libwinpr/sspi/NTLM/ntlm_compute.c\n\
    @@ -263,10 +263,11 @@ void ntlm_generate_timestamp(NTLM_CONTEXT* context)\n \t\
    \tntlm_current_time(context->Timestamp);\n }\n \n-static int ntlm_fetch_ntlm_v2_hash(NTLM_CONTEXT*\
    \ context, BYTE* hash)\n+static BOOL ntlm_fetch_ntlm_v2_hash(NTLM_CONTEXT* context,\
    \ BYTE* hash)\n {\n-\tWINPR_SAM* sam;\n-\tWINPR_SAM_ENTRY* entry;\n+\tBOOL rc\
    \ = FALSE;\n+\tWINPR_SAM* sam = NULL;\n+\tWINPR_SAM_ENTRY* entry = NULL;\n \t\
    SSPI_CREDENTIALS* credentials;\n \n \tWINPR_ASSERT(context);\n@@ -276,48 +277,39\
    \ @@ static int ntlm_fetch_ntlm_v2_hash(NTLM_CONTEXT* context, BYTE* hash)\n \t\
    sam = SamOpen(context->SamFile, TRUE);\n \n \tif (!sam)\n-\t\treturn -1;\n+\t\t\
    goto fail;\n \n \tentry = SamLookupUserW(\n-\t    sam, (LPWSTR)credentials->identity.User,\
    \ credentials->identity.UserLength * 2,\n-\t    (LPWSTR)credentials->identity.Domain,\
    \ credentials->identity.DomainLength * 2);\n+\t    sam, (LPWSTR)credentials->identity.User,\
    \ credentials->identity.UserLength * sizeof(WCHAR),\n+\t    (LPWSTR)credentials->identity.Domain,\
    \ credentials->identity.DomainLength * sizeof(WCHAR));\n \n-\tif (entry)\n+\t\
    if (!entry)\n \t{\n-#ifdef WITH_DEBUG_NTLM\n-\t\tWLog_VRB(TAG, \"NTLM Hash:\"\
    );\n-\t\twinpr_HexDump(TAG, WLOG_DEBUG, entry->NtHash, 16);\n-#endif\n-\t\tNTOWFv2FromHashW(entry->NtHash,\
    \ (LPWSTR)credentials->identity.User,\n-\t\t                 credentials->identity.UserLength\
    \ * 2, (LPWSTR)credentials->identity.Domain,\n-\t\t                 credentials->identity.DomainLength\
    \ * 2, (BYTE*)hash);\n-\t\tSamFreeEntry(sam, entry);\n-\t\tSamClose(sam);\n-\t\
    \treturn 1;\n+\t\tentry = SamLookupUserW(sam, (LPWSTR)credentials->identity.User,\n\
    +\t\t                       credentials->identity.UserLength * sizeof(WCHAR),\
    \ NULL, 0);\n \t}\n \n-\tentry = SamLookupUserW(sam, (LPWSTR)credentials->identity.User,\n\
    -\t                       credentials->identity.UserLength * 2, NULL, 0);\n+\t\
    if (!entry)\n+\t\tgoto fail;\n \n-\tif (entry)\n-\t{\n #ifdef WITH_DEBUG_NTLM\n\
    \ \t\tWLog_VRB(TAG, \"NTLM Hash:\");\n \t\twinpr_HexDump(TAG, WLOG_DEBUG, entry->NtHash,\
    \ 16);\n #endif\n-\t\tNTOWFv2FromHashW(entry->NtHash, (LPWSTR)credentials->identity.User,\n\
    -\t\t                 credentials->identity.UserLength * 2, (LPWSTR)credentials->identity.Domain,\n\
    -\t\t                 credentials->identity.DomainLength * 2, (BYTE*)hash);\n\
    -\t\tSamFreeEntry(sam, entry);\n-\t\tSamClose(sam);\n-\t\treturn 1;\n-\t}\n-\t\
    else\n-\t{\n-\t\tSamClose(sam);\n+\t    NTOWFv2FromHashW(entry->NtHash, (LPWSTR)credentials->identity.User,\n\
    +\t                     credentials->identity.UserLength * sizeof(WCHAR),\n+\t\
    \                     (LPWSTR)credentials->identity.Domain,\n+\t             \
    \        credentials->identity.DomainLength * sizeof(WCHAR), (BYTE*)hash);\n+\n\
    +\t    rc = TRUE;\n+\n+fail:\n+\tSamFreeEntry(sam, entry);\n+\tSamClose(sam);\n\
    +\tif (!rc)\n \t\tWLog_ERR(TAG, \"Error: Could not find user in SAM database\"\
    );\n-\t\treturn 0;\n-\t}\n+\n+\treturn rc;\n }\n \n static int ntlm_convert_password_hash(NTLM_CONTEXT*\
    \ context, BYTE* hash)"
  - "--- a/winpr/libwinpr/sspi/NTLM/ntlm_compute.c\n+++ b/winpr/libwinpr/sspi/NTLM/ntlm_compute.c\n\
    @@ -280,10 +280,11 @@ void ntlm_generate_timestamp(NTLM_CONTEXT* context)\n \t\
    \tntlm_current_time(context->Timestamp);\n }\n \n-static int ntlm_fetch_ntlm_v2_hash(NTLM_CONTEXT*\
    \ context, BYTE* hash)\n+static BOOL ntlm_fetch_ntlm_v2_hash(NTLM_CONTEXT* context,\
    \ BYTE* hash)\n {\n-\tWINPR_SAM* sam;\n-\tWINPR_SAM_ENTRY* entry;\n+\tBOOL rc\
    \ = FALSE;\n+\tWINPR_SAM* sam = NULL;\n+\tWINPR_SAM_ENTRY* entry = NULL;\n \t\
    SSPI_CREDENTIALS* credentials;\n \n \tWINPR_ASSERT(context);\n@@ -293,48 +294,39\
    \ @@ static int ntlm_fetch_ntlm_v2_hash(NTLM_CONTEXT* context, BYTE* hash)\n \t\
    sam = SamOpen(context->SamFile, TRUE);\n \n \tif (!sam)\n-\t\treturn -1;\n+\t\t\
    goto fail;\n \n \tentry = SamLookupUserW(\n-\t    sam, (LPWSTR)credentials->identity.User,\
    \ credentials->identity.UserLength * 2,\n-\t    (LPWSTR)credentials->identity.Domain,\
    \ credentials->identity.DomainLength * 2);\n+\t    sam, (LPWSTR)credentials->identity.User,\
    \ credentials->identity.UserLength * sizeof(WCHAR),\n+\t    (LPWSTR)credentials->identity.Domain,\
    \ credentials->identity.DomainLength * sizeof(WCHAR));\n \n-\tif (entry)\n+\t\
    if (!entry)\n \t{\n-#ifdef WITH_DEBUG_NTLM\n-\t\tWLog_VRB(TAG, \"NTLM Hash:\"\
    );\n-\t\twinpr_HexDump(TAG, WLOG_DEBUG, entry->NtHash, 16);\n-#endif\n-\t\tNTOWFv2FromHashW(entry->NtHash,\
    \ (LPWSTR)credentials->identity.User,\n-\t\t                 credentials->identity.UserLength\
    \ * 2, (LPWSTR)credentials->identity.Domain,\n-\t\t                 credentials->identity.DomainLength\
    \ * 2, (BYTE*)hash);\n-\t\tSamFreeEntry(sam, entry);\n-\t\tSamClose(sam);\n-\t\
    \treturn 1;\n+\t\tentry = SamLookupUserW(sam, (LPWSTR)credentials->identity.User,\n\
    +\t\t                       credentials->identity.UserLength * sizeof(WCHAR),\
    \ NULL, 0);\n \t}\n \n-\tentry = SamLookupUserW(sam, (LPWSTR)credentials->identity.User,\n\
    -\t                       credentials->identity.UserLength * 2, NULL, 0);\n+\t\
    if (!entry)\n+\t\tgoto fail;\n \n-\tif (entry)\n-\t{\n #ifdef WITH_DEBUG_NTLM\n\
    \ \t\tWLog_VRB(TAG, \"NTLM Hash:\");\n \t\twinpr_HexDump(TAG, WLOG_DEBUG, entry->NtHash,\
    \ 16);\n #endif\n-\t\tNTOWFv2FromHashW(entry->NtHash, (LPWSTR)credentials->identity.User,\n\
    -\t\t                 credentials->identity.UserLength * 2, (LPWSTR)credentials->identity.Domain,\n\
    -\t\t                 credentials->identity.DomainLength * 2, (BYTE*)hash);\n\
    -\t\tSamFreeEntry(sam, entry);\n-\t\tSamClose(sam);\n-\t\treturn 1;\n-\t}\n-\t\
    else\n-\t{\n-\t\tSamClose(sam);\n+\t    NTOWFv2FromHashW(entry->NtHash, (LPWSTR)credentials->identity.User,\n\
    +\t                     credentials->identity.UserLength * sizeof(WCHAR),\n+\t\
    \                     (LPWSTR)credentials->identity.Domain,\n+\t             \
    \        credentials->identity.DomainLength * sizeof(WCHAR), (BYTE*)hash);\n+\n\
    +\t    rc = TRUE;\n+\n+fail:\n+\tSamFreeEntry(sam, entry);\n+\tSamClose(sam);\n\
    +\tif (!rc)\n \t\tWLog_ERR(TAG, \"Error: Could not find user in SAM database\"\
    );\n-\t\treturn 0;\n-\t}\n+\n+\treturn rc;\n }\n \n static int ntlm_convert_password_hash(NTLM_CONTEXT*\
    \ context, BYTE* hash)"
  identifiers:
  - CVE-2022-24883
  - CWE-287
  overview: FreeRDP is a free implementation of the Remote Desktop Protocol (RDP).
    Prior to version 2.7.0, server side authentication against a `SAM` file might
    be successful for invalid credentials if the server has configured an invalid
    `SAM` file path. FreeRDP based clients are not affected. RDP server implementations
    using FreeRDP to authenticate against a `SAM` file are affected. Version 2.7.0
    contains a fix for this issue. As a workaround, use custom authentication via
    `HashCallback` and/or ensure the `SAM` database path configured is valid and the
    application has file handles left.
  references:
  - source: security-advisories@github.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/FreeRDP/FreeRDP/commit/4661492e5a617199457c8074bad22f766a116cdc
  - source: security-advisories@github.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/FreeRDP/FreeRDP/commit/6f473b273a4b6f0cb6aca32b95e22fd0de88e144
  - source: security-advisories@github.com
    tags:
    - Release Notes
    - Third Party Advisory
    url: https://github.com/FreeRDP/FreeRDP/releases/tag/2.7.0
  - source: security-advisories@github.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/FreeRDP/FreeRDP/security/advisories/GHSA-qxm3-v2r6-vmwf
  - source: security-advisories@github.com
    url: https://lists.debian.org/debian-lts-announce/2023/11/msg00010.html
  - source: security-advisories@github.com
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/AELSWWBAM2YONRPGLWVDY6UNTLJERJYL/
  - source: security-advisories@github.com
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/DOYKBQOHSRM7JQYUIYUWFOXI2JZ2J5RD/
  - source: security-advisories@github.com
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/PZWR6KSIKXO4B2TXBB3WH6YTNYHN46OY/
  - source: security-advisories@github.com
    tags:
    - Third Party Advisory
    url: https://security.gentoo.org/glsa/202210-24
  title: FreeRDP is a free implementation of the Remote Desktop Protocol (RDP). Prior
    to version 2.7.0, server side authentication against a `SAM` file might be successful
    for invalid credentials if the server has configured an invalid `SAM` file path.
    FreeRDP based clients are not affected. RDP server implementations using FreeRDP
    to authenticate against a `SAM` file are affected. Version 2.7.0 contains a fix
    for this issue. As a workaround, use custom authentication via `HashCallback`
    and/or ensure the `SAM` database path configured is valid and the application
    has file handles left.
- diff_content:
  - "--- a/libnsgif/libnsgif.c\n+++ b/libnsgif/libnsgif.c\n@@ -595,6 +595,12 @@ gif_internal_decode_frame(gif_animation\
    \ *gif,\n         unsigned int x, y, decode_y, burst_bytes;\n         register\
    \ unsigned char colour;\n \n+        /* If the GIF has no frame data, frame holders\
    \ will not be allocated in\n+         * gif_initialise() */\n+        if (gif->frames\
    \ == NULL) {\n+                return GIF_INSUFFICIENT_DATA;\n+        }\n+\n\
    \         /* Ensure this frame is supposed to be decoded */\n         if (gif->frames[frame].display\
    \ == false) {\n                 return GIF_OK;"
  identifiers:
  - CVE-2022-1507
  - CWE-476
  overview: 'chafa: NULL Pointer Dereference in function gif_internal_decode_frame
    at libnsgif.c:599 allows attackers to cause a denial of service (crash) via a
    crafted input file. in GitHub repository hpjansson/chafa prior to 1.10.2. chafa:
    NULL Pointer Dereference in function gif_internal_decode_frame at libnsgif.c:599
    allows attackers to cause a denial of service (crash) via a crafted input file.'
  references:
  - source: security@huntr.dev
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/hpjansson/chafa/commit/e4b777c7b7c144cd16a0ea96108267b1004fe6c9
  - source: security@huntr.dev
    tags:
    - Exploit
    - Issue Tracking
    - Patch
    - Third Party Advisory
    url: https://huntr.dev/bounties/104d8c5d-cac5-4baa-9ac9-291ea0bcab95
  - source: security@huntr.dev
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/3PLHKTQYK6AO3M5NAVM3CDVQTZZS6MCO/
  - source: security@huntr.dev
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/DIOAZPITFL2Y7Y6KHCZ4OIK7P7KWFN22/
  - source: security@huntr.dev
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/L54UEP5S254VP5FZWGFPHLTPMFJVOGYT/
  title: 'chafa: NULL Pointer Dereference in function gif_internal_decode_frame at
    libnsgif.c:599 allows attackers to cause a denial of service (crash) via a crafted
    input file. in GitHub repository hpjansson/chafa prior to 1.10.2. chafa: NULL
    Pointer Dereference in function gif_internal_decode_frame at libnsgif.c:599 allows
    attackers to cause a denial of service (crash) via a crafted input file.'
- diff_content:
  - "--- a/component/common/network/dhcp/dhcps.c\n+++ b/component/common/network/dhcp/dhcps.c\n\
    @@ -1,7 +1,8 @@\n \n #include \"dhcps.h\"\n #include \"tcpip.h\"\n-\n+#include\
    \ \"wifi_constants.h\"\n+extern rtw_mode_t wifi_mode;\n //static struct dhcp_server_state\
    \ dhcp_server_state_machine;\n static uint8_t dhcp_server_state_machine = DHCP_SERVER_STATE_IDLE;\n\
    \ /* recorded the client MAC addr(default sudo mac) */\n@@ -11,6 +12,7 @@ static\
    \ uint8_t dhcp_recorded_xid[4] = {0xff, 0xff, 0xff, 0xff};\n \n /* UDP Protocol\
    \ Control Block(PCB) */\n static struct udp_pcb *dhcps_pcb;\n+static struct udp_pcb\
    \ *dns_server_pcb;\n \n static struct ip_addr dhcps_send_broadcast_address;\n\
    \ static struct ip_addr dhcps_local_address;\n@@ -20,6 +22,7 @@ static struct\
    \ ip_addr dhcps_local_mask;\n static struct ip_addr dhcps_local_gateway;\n static\
    \ struct ip_addr dhcps_network_id;\n static struct ip_addr dhcps_subnet_broadcast;\
    \ \n+static struct eth_addr dhcps_allocated_client_ethaddr;\n static struct ip_addr\
    \ dhcps_allocated_client_address;\n static int dhcps_addr_pool_set = 0;\n static\
    \ struct ip_addr dhcps_addr_pool_start;\n@@ -73,7 +76,7 @@ static void mark_ip_in_table(uint8_t\
    \ d)\n \t\tprintf(\"\\r\\n ip_table.ip_range[3] = 0x%x\\r\\n\",ip_table.ip_range[3]);\n\
    \ #endif\t\n \t} else if(128 < d && d <= 160) {\n-\t\tip_table.ip_range[4] = MARK_RANGE5_IP_BIT(ip_table,\
    \ d);\t\n+\t\tip_table.ip_range[4] = MARK_RANGE5_IP_BIT(ip_table, (d - 128));\t\
    \n #if (debug_dhcps)\t\t\n \t\tprintf(\"\\r\\n ip_table.ip_range[4] = 0x%x\\r\\\
    n\",ip_table.ip_range[4]);\n #endif\t\n@@ -101,15 +104,24 @@ static void mark_ip_in_table(uint8_t\
    \ d)\n #ifdef CONFIG_DHCPS_KEPT_CLIENT_INFO\n static void save_client_addr(struct\
    \ ip_addr *client_ip, uint8_t *hwaddr)\n {\n+#if LWIP_VERSION_MAJOR >= 2\n+\t\
    uint8_t d = (uint8_t)ip4_addr4(ip_2_ip4(client_ip));\n+#else\n \tuint8_t d = (uint8_t)ip4_addr4(client_ip);\n\
    -\t\n+#endif\n \txSemaphoreTake(dhcps_ip_table_semaphore, portMAX_DELAY);\n \t\
    memcpy(ip_table.client_mac[d], hwaddr, 6); \n #if (debug_dhcps)\t\n-\tprintf(\"\
    \\r\\n%s: ip %d.%d.%d.%d, hwaddr %2.2x:%2.2x:%2.2x:%2.2x:%2.2x:%2.2x\\n\", __func__,\n\
    +#if LWIP_VERSION_MAJOR >= 2\n+\tprintf(\"\\r\\n%s: ip %d.%d.%d.%d, hwaddr 0x%02x:0x%02x:0x%02x:0x%02x:0x%02x:0x%02x\\\
    n\", __func__,\n+\t\tip4_addr1(ip_2_ip4(client_ip)), ip4_addr2(ip_2_ip4(client_ip)),\
    \ ip4_addr3(ip_2_ip4(client_ip)), ip4_addr4(ip_2_ip4(client_ip)),\n+\t\thwaddr[0],\
    \ hwaddr[1], hwaddr[2], hwaddr[3], hwaddr[4], hwaddr[5]);\n+#else\n+\tprintf(\"\
    \\r\\n%s: ip %d.%d.%d.%d, hwaddr 0x%02x:0x%02x:0x%02x:0x%02x:0x%02x:0x%02x\\n\"\
    , __func__,\n \t\tip4_addr1(client_ip), ip4_addr2(client_ip), ip4_addr3(client_ip),\
    \ ip4_addr4(client_ip),\n \t\thwaddr[0], hwaddr[1], hwaddr[2], hwaddr[3], hwaddr[4],\
    \ hwaddr[5]);\n-#endif\t\n+#endif\n+#endif\n \txSemaphoreGive(dhcps_ip_table_semaphore);\n\
    \ }\n \n@@ -142,6 +154,82 @@ static uint8_t check_client_request_ip(struct ip_addr\
    \ *client_req_ip, uint8_t *h\n Exit:\n \treturn ip_addr4;\n }\n+\n+static uint8_t\
    \ check_client_direct_request_ip(struct ip_addr *client_req_ip, uint8_t *hwaddr)\n\
    +{\n+\tint ip_addr4 = 0, i;\n+\n+#if (debug_dhcps)\t\n+#if LWIP_VERSION_MAJOR\
    \ >= 2\n+\tprintf(\"\\r\\n%s: ip %d.%d.%d.%d, hwaddr 0x%02x:0x%02x:0x%02x:0x%02x:0x%02x:0x%02x\\\
    n\", __func__,\n+\t\t\tip4_addr1(ip_2_ip4(client_req_ip)), ip4_addr2(ip_2_ip4(client_req_ip)),\
    \ ip4_addr3(ip_2_ip4(client_req_ip)), ip4_addr4(ip_2_ip4(client_req_ip)),\n+\t\
    \t\thwaddr[0], hwaddr[1], hwaddr[2], hwaddr[3], hwaddr[4], hwaddr[5]);\n+#else\n\
    +\tprintf(\"\\r\\n%s: ip %d.%d.%d.%d, hwaddr 0x%02x:0x%02x:0x%02x:0x%02x:0x%02x:0x%02x\\\
    n\", __func__,\n+\t\t\tip4_addr1(client_req_ip), ip4_addr2(client_req_ip), ip4_addr3(client_req_ip),\
    \ ip4_addr4(client_req_ip),\n+\t\t\thwaddr[0], hwaddr[1], hwaddr[2], hwaddr[3],\
    \ hwaddr[4], hwaddr[5]);\n+#endif\t\n+#endif\n+\n+#if LWIP_VERSION_MAJOR >= 2\n\
    +\tif( (ip4_addr1(ip_2_ip4(&dhcps_network_id)) != ip4_addr1(ip_2_ip4(client_req_ip)))\
    \ ||\n+\t\t(ip4_addr2(ip_2_ip4(&dhcps_network_id)) != ip4_addr2(ip_2_ip4(client_req_ip)))\
    \ ||\n+\t\t(ip4_addr3(ip_2_ip4(&dhcps_network_id)) != ip4_addr3(ip_2_ip4(client_req_ip))))\n\
    +#else\n+\tif( (ip4_addr1(&dhcps_network_id) != ip4_addr1(client_req_ip)) ||\n\
    +\t\t(ip4_addr2(&dhcps_network_id) != ip4_addr2(client_req_ip)) ||\n+\t\t(ip4_addr3(&dhcps_network_id)\
    \ != ip4_addr3(client_req_ip)))\n+#endif\n+\n+\t{\n+\t\tip_addr4 = 0;\n+\t\tgoto\
    \ Exit;\n+\t}\n+\n+\t// check if the requested ip is available\n+#if LWIP_VERSION_MAJOR\
    \ >= 2\n+\tip_addr4 = ip4_addr4(ip_2_ip4(client_req_ip));\n+#else\n+\tip_addr4\
    \ = ip4_addr4(client_req_ip);\n+#endif\n+\n+\tif (ip_addr4 < DHCP_POOL_START ||\
    \ ip_addr4 > DHCP_POOL_END) {\n+\t\tip_addr4 = 0;\n+\t\tgoto Exit;\n+\t}\n+\t\
    xSemaphoreTake(dhcps_ip_table_semaphore, portMAX_DELAY);\n+\tprintf(\"ip_table[%d]\
    \ = %x,%x,%x,%x,%x,%x\\n\",ip_addr4,ip_table.client_mac[ip_addr4][0],\n+\t\t\t\
    \t\t\t\t\t\t\t  \t\t\t     ip_table.client_mac[ip_addr4][1],\n+\t\t\t\t\t\t\t\t\
    \t\t  \t\t\t\t ip_table.client_mac[ip_addr4][2],\n+\t\t\t\t\t\t\t\t\t\t  \t\t\t\
    \t ip_table.client_mac[ip_addr4][3],\n+\t\t\t\t\t\t\t\t\t\t  \t\t\t\t ip_table.client_mac[ip_addr4][4],\n\
    +\t\t\t\t\t\t\t\t\t\t  \t\t\t\t ip_table.client_mac[ip_addr4][5]);\n+\tif(\t(\t\
    ip_table.client_mac[ip_addr4][0] == 0 &&\n+\t\t\tip_table.client_mac[ip_addr4][1]\
    \ == 0 &&\n+\t\t\tip_table.client_mac[ip_addr4][2] == 0 &&\n+\t\t\tip_table.client_mac[ip_addr4][3]\
    \ == 0 &&\n+\t\t\tip_table.client_mac[ip_addr4][4] == 0 &&\n+\t\t\tip_table.client_mac[ip_addr4][5]\
    \ == 0) ||\n+\t\t(\tip_table.client_mac[ip_addr4][0] == hwaddr[0] &&\n+\t\t\t\
    ip_table.client_mac[ip_addr4][1] == hwaddr[1] &&\n+\t\t\tip_table.client_mac[ip_addr4][2]\
    \ == hwaddr[2] &&\n+\t\t\tip_table.client_mac[ip_addr4][3] == hwaddr[3] &&\n+\t\
    \t\tip_table.client_mac[ip_addr4][4] == hwaddr[4] &&\n+\t\t\tip_table.client_mac[ip_addr4][5]\
    \ == hwaddr[5]))\n+\t{\n+\t\t// the ip is available or already allocated to this\
    \ client\n+\t}\n+\telse\n+\t{\n+\t\tip_addr4 = 0; // the ip is used\n+\t}\n+\t\
    \n+\txSemaphoreGive(dhcps_ip_table_semaphore);\n+\n+Exit:\n+\treturn ip_addr4;\n\
    +}\n+\n static void dump_client_table()\n {\n #if 0\n@@ -174,8 +262,14 @@ static\
    \ uint8_t search_next_ip(void)\n \tuint8_t start, end;\n \tuint8_t max_count;\n\
    \ \tif(dhcps_addr_pool_set){\n+#if LWIP_VERSION_MAJOR >= 2\n+\t\tstart = (uint8_t)ip4_addr4(ip_2_ip4(&dhcps_addr_pool_start));\n\
    +\t\tend = (uint8_t)ip4_addr4(ip_2_ip4(&dhcps_addr_pool_end));\n+#else\n \t\t\
    start = (uint8_t)ip4_addr4(&dhcps_addr_pool_start);\n \t\tend = (uint8_t)ip4_addr4(&dhcps_addr_pool_end);\n\
    +#endif\n+\n \t}else{\n \t\tstart = 0;\n \t\tend = 255;\n@@ -244,55 +338,101 @@\
    \ static uint8_t *fill_one_option_content(uint8_t *option_base_addr,\n /**\n \
    \  * @brief  fill in the needed content of the dhcp offer message. \n   * @param\
    \  optptr  the addr which the tail of dhcp magic field. \n-  * @retval the addr\
    \ represent to add the end of option.\n+  * @retval\t0, add ok\n+  *\t\t\t-1,\
    \ add fail\n   */\n-static void add_offer_options(uint8_t *option_start_address)\n\
    +static int8_t add_offer_options(uint8_t *option_start_address)\n {\n-\tuint8_t\
    \ *temp_option_addr;\n+\t// Total minimum len = 6+6+6+6+6+6+4+3+1 = 44\n+\tuint8_t\
    \ *temp_option_addr = option_start_address;\n+\tint max_addable_option_len = dhcp_message_total_options_lenth\
    \ - 4 - 3;\t// -magic-type\n+\n+\tif(option_start_address == NULL)\n+\t\tgoto\
    \ ERROR;\n+\n \t/* add DHCP options 1. \n \tThe subnet mask option specifies the\
    \ client's subnet mask */\n-\ttemp_option_addr = fill_one_option_content(option_start_address,\n\
    -\t\t\tDHCP_OPTION_CODE_SUBNET_MASK, DHCP_OPTION_LENGTH_FOUR,\n-\t\t\t\t\t(void\
    \ *)&dhcps_local_mask);\n+\tif(temp_option_addr + 6 -option_start_address <= max_addable_option_len)\
    \ {\n+\t\ttemp_option_addr = fill_one_option_content(option_start_address, DHCP_OPTION_CODE_SUBNET_MASK,\n\
    +\t\t\t\t\t\tDHCP_OPTION_LENGTH_FOUR,(void *)&dhcps_local_mask);\n+\t}else{\n\
    +\t\tgoto ERROR;\n+\t}\n \t\n         /* add DHCP options 3 (i.e router(gateway)).\
    \ The time server option \n         specifies a list of RFC 868 [6] time servers\
    \ available to the client. */\n-\ttemp_option_addr = fill_one_option_content(temp_option_addr,\n\
    -\t\t\tDHCP_OPTION_CODE_ROUTER, DHCP_OPTION_LENGTH_FOUR,\n-\t\t\t\t\t(void *)&dhcps_local_address);\n\
    +        if(temp_option_addr + 6 -option_start_address <= max_addable_option_len)\
    \ {\n+\t\ttemp_option_addr = fill_one_option_content(temp_option_addr, DHCP_OPTION_CODE_ROUTER,\n\
    +\t\t\t\t\t\tDHCP_OPTION_LENGTH_FOUR, (void *)&dhcps_local_address);\n+\t}else{\n\
    +\t\tgoto ERROR;\n+\t}\n \n \t/* add DHCP options 6 (i.e DNS). \n         The\
    \ option specifies a list of DNS servers available to the client. */\n-\ttemp_option_addr\
    \ = fill_one_option_content(temp_option_addr,\n-\t\t\tDHCP_OPTION_CODE_DNS_SERVER,\
    \ DHCP_OPTION_LENGTH_FOUR,\n-\t\t\t\t\t(void *)&dhcps_local_address);\t\n+\t if(temp_option_addr\
    \ + 6 -option_start_address <= max_addable_option_len) {\n+\t \ttemp_option_addr\
    \ = fill_one_option_content(temp_option_addr, DHCP_OPTION_CODE_DNS_SERVER,\n+\t\
    \t\t\t\t\tDHCP_OPTION_LENGTH_FOUR, (void *)&dhcps_local_address);\t\n+\t}else{\n\
    +\t\tgoto ERROR;\n+\t}\n+\t\n \t/* add DHCP options 51.\n \tThis option is used\
    \ to request a lease time for the IP address. */\n-\ttemp_option_addr = fill_one_option_content(temp_option_addr,\n\
    -\t\t\tDHCP_OPTION_CODE_LEASE_TIME, DHCP_OPTION_LENGTH_FOUR,\n-\t\t\t\t\t(void\
    \ *)&dhcp_option_lease_time);\n+\t if(temp_option_addr + 6 -option_start_address\
    \ <= max_addable_option_len) {\n+\t\ttemp_option_addr = fill_one_option_content(temp_option_addr,\
    \ DHCP_OPTION_CODE_LEASE_TIME,\n+\t\t\t\t\t\tDHCP_OPTION_LENGTH_FOUR, (void *)&dhcp_option_lease_time);\n\
    +\t}else{\n+\t\tgoto ERROR;\n+\t}\n+\t\n \t/* add DHCP options 54. \n \tThe identifier\
    \ is the IP address of the selected server. */\n-\ttemp_option_addr = fill_one_option_content(temp_option_addr,\n\
    -\t\t\tDHCP_OPTION_CODE_SERVER_ID, DHCP_OPTION_LENGTH_FOUR,\n-\t\t\t\t(void *)&dhcps_local_address);\n\
    +\t if(temp_option_addr + 6 -option_start_address <= max_addable_option_len) {\n\
    +\t\ttemp_option_addr = fill_one_option_content(temp_option_addr, DHCP_OPTION_CODE_SERVER_ID,\n\
    +\t\t\t\t\t\tDHCP_OPTION_LENGTH_FOUR, (void *)&dhcps_local_address);\n+\t}else{\n\
    +\t\tgoto ERROR;\n+\t}\n+\t\n \t/* add DHCP options 28. \n \tThis option specifies\
    \ the broadcast address in use on client's subnet.*/\n-\ttemp_option_addr = fill_one_option_content(temp_option_addr,\n\
    -\t\tDHCP_OPTION_CODE_BROADCAST_ADDRESS, DHCP_OPTION_LENGTH_FOUR,\n-\t\t\t\t(void\
    \ *)&dhcps_subnet_broadcast);\n+\tif(temp_option_addr + 6 -option_start_address\
    \ <= max_addable_option_len) {\n+\t\ttemp_option_addr = fill_one_option_content(temp_option_addr,\
    \ DHCP_OPTION_CODE_BROADCAST_ADDRESS,\n+\t\t\t\t\t\tDHCP_OPTION_LENGTH_FOUR, (void\
    \ *)&dhcps_subnet_broadcast);\n+\t}else{\n+\t\tgoto ERROR;\n+\t}\n+\t\n \t/* add\
    \ DHCP options 26. \n \tThis option specifies the Maximum transmission unit to\
    \ use */\n-\ttemp_option_addr = fill_one_option_content(temp_option_addr,\n-\t\
    \tDHCP_OPTION_CODE_INTERFACE_MTU, DHCP_OPTION_LENGTH_TWO,\n-\t\t\t\t\t(void *)\
    \ &dhcp_option_interface_mtu);//dhcp_option_interface_mtu_576);\n+\tif(temp_option_addr\
    \ + 4 -option_start_address <= max_addable_option_len) {\n+\t\ttemp_option_addr\
    \ = fill_one_option_content(temp_option_addr, DHCP_OPTION_CODE_INTERFACE_MTU,\n\
    +\t\t\t\t\t\tDHCP_OPTION_LENGTH_TWO, (void *) &dhcp_option_interface_mtu);//dhcp_option_interface_mtu_576);\n\
    +\t}else{\n+\t\tgoto ERROR;\n+\t}\n+\t\n \t/* add DHCP options 31.\n \tThis option\
    \ specifies whether or not the client should solicit routers */\n-\ttemp_option_addr\
    \ = fill_one_option_content(temp_option_addr,\n-\t\tDHCP_OPTION_CODE_PERFORM_ROUTER_DISCOVERY,\
    \ DHCP_OPTION_LENGTH_ONE,\n-\t\t\t\t\t\t\t\tNULL);\n+\tif(temp_option_addr + 3\
    \ -option_start_address <= max_addable_option_len) {\n+\t\ttemp_option_addr =\
    \ fill_one_option_content(temp_option_addr, DHCP_OPTION_CODE_PERFORM_ROUTER_DISCOVERY,\n\
    +\t\t\t\t\t\tDHCP_OPTION_LENGTH_ONE,\tNULL);\n+\t}else{\n+\t\tgoto ERROR;\n+\t\
    }\n+\n+\t// END\n+\tif(temp_option_addr + 1 -option_start_address <= max_addable_option_len)\
    \ {\n \t*temp_option_addr++ = DHCP_OPTION_CODE_END;\n+\t}else{\n+\t\tgoto ERROR;\n\
    +\t}\n+\treturn 0;\n \n+ERROR:\n+\tprintf(\"\\r\\n[%s] error: add options fail\
    \ !!\", __func__);\n+\treturn -1;\n }\n \n \n@@ -311,7 +451,6 @@ static void dhcps_initialize_message(struct\
    \ dhcp_msg *dhcp_message_repository)\n         memcpy((char *)dhcp_recorded_xid,\
    \ (char *) dhcp_message_repository->xid,\n \t\t\t\t\tsizeof(dhcp_message_repository->xid));\n\
    \         dhcp_message_repository->secs = 0;\n-        dhcp_message_repository->flags\
    \ = htons(BOOTP_BROADCAST);         \n \n \tmemcpy((char *)dhcp_message_repository->yiaddr,\n\
    \ \t\t\t(char *)&dhcps_allocated_client_address,\n@@ -341,9 +480,27 @@ static\
    \ void dhcps_initialize_message(struct dhcp_msg *dhcp_message_repository)\n static\
    \ void dhcps_send_offer(struct pbuf *packet_buffer)\n {\n \tuint8_t temp_ip =\
    \ 0;\n-\tdhcp_message_repository = (struct dhcp_msg *)packet_buffer->payload;\t\
    \n-#if (!IS_USE_FIXED_IP) \t\n+\tstruct pbuf *newly_malloc_packet_buffer = NULL;\n\
    +\n+\t// newly malloc a longer pbuf for dhcp offer rather than using the short\
    \ pbuf from dhcp discover\n+\tnewly_malloc_packet_buffer = pbuf_alloc(PBUF_TRANSPORT,\
    \ DHCP_MSG_LEN + DHCP_OPTION_TOTAL_LENGTH_MAX, PBUF_RAM);\n+\tif(newly_malloc_packet_buffer\
    \ == NULL)\n+\t{\n+\t\tprintf(\"\\r\\n[%s] error:  pbuf alloc fail !\", __func__);\n\
    +\t\treturn;\n+\t}\n+\tif(pbuf_copy(newly_malloc_packet_buffer, packet_buffer)\
    \ != ERR_OK)\n+\t{\n+\t\tprintf(\"\\r\\n[%s] error:  pbuf copy fail !\", __func__);\n\
    +\t\tpbuf_free(newly_malloc_packet_buffer);\t\n+\t\treturn;\n+\t}\t\n+\tdhcp_message_total_options_lenth\
    \ = DHCP_OPTION_TOTAL_LENGTH_MAX;\n+\tdhcp_message_repository = (struct dhcp_msg\
    \ *)newly_malloc_packet_buffer->payload;\t\n+#if (!IS_USE_FIXED_IP) \n+#ifdef\
    \ CONFIG_DHCPS_KEPT_CLIENT_INFO\n \ttemp_ip = check_client_request_ip(&client_request_ip,\
    \ client_addr);\n+#endif\n \t/* create new client ip */\n \tif(temp_ip == 0)\n\
    \ \t\ttemp_ip = search_next_ip();\n@@ -358,15 +515,55 @@ static void dhcps_send_offer(struct\
    \ pbuf *packet_buffer)\n #endif\t\n \t\tprintf(\"\\r\\n No useable ip!!!!\\r\\\
    n\");\n \t}\n-\tprintf(\"\\n\\r[%d]DHCP assign ip = %d.%d.%d.%d\\n\", xTaskGetTickCount(),\
    \ ip4_addr1(&dhcps_network_id),ip4_addr2(&dhcps_network_id),ip4_addr3(&dhcps_network_id),temp_ip);\n\
    +#if LWIP_VERSION_MAJOR >= 2\n+\tprintf(\"\\n\\r[%d]DHCP assign ip = %d.%d.%d.%d,\
    \ hwaddr 0x%02x:0x%02x:0x%02x:0x%02x:0x%02x:0x%02x\\n\", \\\n+\t\t\txTaskGetTickCount(),\
    \ ip4_addr1(ip_2_ip4(&dhcps_network_id)), \\\n+\t\t\tip4_addr2(ip_2_ip4(&dhcps_network_id)),\
    \ \\\n+\t\t\tip4_addr3(ip_2_ip4(&dhcps_network_id)), temp_ip, \\\n+\t\t\tclient_addr[0],\
    \ client_addr[1], client_addr[2], \\\n+\t\t\tclient_addr[3], client_addr[4], client_addr[5]);\n\
    +\tIP4_ADDR(ip_2_ip4(&dhcps_allocated_client_address), (ip4_addr1(ip_2_ip4(&dhcps_network_id))),\n\
    +\t\t\tip4_addr2(ip_2_ip4(&dhcps_network_id)), ip4_addr3(ip_2_ip4(&dhcps_network_id)),\
    \ temp_ip);\n+#else\n+\tprintf(\"\\n\\r[%d]DHCP assign ip = %d.%d.%d.%d, hwaddr\
    \ 0x%02x:0x%02x:0x%02x:0x%02x:0x%02x:0x%02x\\n\", \\\n+\t\t\txTaskGetTickCount(),\
    \ ip4_addr1(&dhcps_network_id), \\\n+\t\t\tip4_addr2(&dhcps_network_id), ip4_addr3(&dhcps_network_id),\
    \ temp_ip, \\\n+\t\t\tclient_addr[0], client_addr[1], client_addr[2], \\\n+\t\t\
    \tclient_addr[3], client_addr[4], client_addr[5]);\n \tIP4_ADDR(&dhcps_allocated_client_address,\
    \ (ip4_addr1(&dhcps_network_id)),\n \t\t\tip4_addr2(&dhcps_network_id), ip4_addr3(&dhcps_network_id),\
    \ temp_ip);\n+#endif\n+\n #endif   \n \tdhcps_initialize_message(dhcp_message_repository);\n\
    -\tadd_offer_options(add_msg_type(&dhcp_message_repository->options[4],\n-\t\t\
    \tDHCP_MESSAGE_TYPE_OFFER));\n-\tudp_sendto_if(dhcps_pcb, packet_buffer,\n-\t\t\
    \t&dhcps_send_broadcast_address, DHCP_CLIENT_PORT, dhcps_netif);\n+\tif(add_offer_options(add_msg_type(&dhcp_message_repository->options[4],\
    \ DHCP_MESSAGE_TYPE_OFFER)) == 0){\n+\t\tif(dhcp_message_repository->flags ==\
    \ 0x0){\n+\t\t\t// unicast\n+\t\t\tfor(int i=0;i<6;i++)\n+\t\t\t\tdhcps_allocated_client_ethaddr.addr[i]\
    \ = dhcp_message_repository->chaddr[i];\n+#if ETHARP_SUPPORT_STATIC_ENTRIES\n\
    +#if LWIP_VERSION_MAJOR >= 2\n+\t\t\t\tetharp_add_static_entry(ip_2_ip4(&dhcps_allocated_client_address),\
    \ &dhcps_allocated_client_ethaddr);\n+#else\n+\t\t\t\tetharp_add_static_entry(&dhcps_allocated_client_address,\
    \ &dhcps_allocated_client_ethaddr);\n+#endif\n+#endif\n+\t\t\t\tudp_sendto_if(dhcps_pcb,\
    \ newly_malloc_packet_buffer, &dhcps_allocated_client_address, DHCP_CLIENT_PORT,\
    \ dhcps_netif);\n+#if ETHARP_SUPPORT_STATIC_ENTRIES\t\n+#if LWIP_VERSION_MAJOR\
    \ >= 2\n+\t\t\t\tetharp_remove_static_entry(ip_2_ip4(&dhcps_allocated_client_address));\n\
    +#else\n+\t\t\t\tetharp_remove_static_entry(&dhcps_allocated_client_address);\n\
    +#endif\n+#endif\n+\n+\t\t}\n+\t\telse\n+\t\t\t// broadcast\n+\t\t\tudp_sendto_if(dhcps_pcb,\
    \ newly_malloc_packet_buffer, &dhcps_send_broadcast_address, DHCP_CLIENT_PORT,\
    \ dhcps_netif);\n+\t}\n+\n+\tpbuf_free(newly_malloc_packet_buffer);\t\n }\n \n\
    \ /**\n@@ -390,12 +587,50 @@ static void dhcps_send_nak(struct pbuf *packet_buffer)\n\
    \   */\n static void dhcps_send_ack(struct pbuf *packet_buffer)\n {\n-\tdhcp_message_repository\
    \ = (struct dhcp_msg *)packet_buffer->payload;\n+\tstruct pbuf *newly_malloc_packet_buffer\
    \ = NULL;\n+\n+\t// newly malloc a longer pbuf for dhcp ack rather than using\
    \ the short pbuf from dhcp request\n+\tnewly_malloc_packet_buffer = pbuf_alloc(PBUF_TRANSPORT,\
    \ DHCP_MSG_LEN + DHCP_OPTION_TOTAL_LENGTH_MAX, PBUF_RAM);\n+\tif(newly_malloc_packet_buffer\
    \ == NULL)\n+\t{\n+\t\tprintf(\"\\r\\n[%s] error:  pbuf alloc fail !\", __func__);\n\
    +\t\treturn;\n+\t}\n+\tif(pbuf_copy(newly_malloc_packet_buffer, packet_buffer)\
    \ != ERR_OK)\n+\t{\n+\t\tprintf(\"\\r\\n[%s] error:  pbuf copy fail !\", __func__);\n\
    +\t\tpbuf_free(newly_malloc_packet_buffer);\t\n+\t\treturn;\n+\t}\t\n+\tdhcp_message_total_options_lenth\
    \ = DHCP_OPTION_TOTAL_LENGTH_MAX;\n+\tdhcp_message_repository = (struct dhcp_msg\
    \ *)newly_malloc_packet_buffer->payload;\n \tdhcps_initialize_message(dhcp_message_repository);\n\
    -\tadd_offer_options(add_msg_type(&dhcp_message_repository->options[4],\n-\t\t\
    \t      \t\t\tDHCP_MESSAGE_TYPE_ACK));\n-\tudp_sendto_if(dhcps_pcb, packet_buffer,\n\
    -\t\t   &dhcps_send_broadcast_address, DHCP_CLIENT_PORT, dhcps_netif);\n+\tif(add_offer_options(add_msg_type(&dhcp_message_repository->options[4],\
    \ DHCP_MESSAGE_TYPE_ACK)) == 0){\n+\t\tif(dhcp_message_repository->flags == 0x0){\n\
    +\t\t\t// unicast\n+\t\t\tfor(int i=0;i<6;i++)\n+\t\t\t\tdhcps_allocated_client_ethaddr.addr[i]\
    \ = dhcp_message_repository->chaddr[i];\n+#if ETHARP_SUPPORT_STATIC_ENTRIES\n\
    +#if LWIP_VERSION_MAJOR >= 2\n+\t\t\tetharp_add_static_entry(ip_2_ip4(&dhcps_allocated_client_address),\
    \ &dhcps_allocated_client_ethaddr);\n+#else\n+\t\t\tetharp_add_static_entry(&dhcps_allocated_client_address,\
    \ &dhcps_allocated_client_ethaddr);\n+#endif\n+#endif\n+\t\t\tudp_sendto_if(dhcps_pcb,\
    \ newly_malloc_packet_buffer, &dhcps_allocated_client_address, DHCP_CLIENT_PORT,\
    \ dhcps_netif);\n+#if ETHARP_SUPPORT_STATIC_ENTRIES\t\n+#if LWIP_VERSION_MAJOR\
    \ >= 2\n+\t\t\tetharp_remove_static_entry(ip_2_ip4(&dhcps_allocated_client_address));\n\
    +#else\n+\t\t\tetharp_remove_static_entry(&dhcps_allocated_client_address);\n\
    +#endif\n+#endif\n+\t\t}\n+\t\telse\n+\t\t\t// broadcast\n+\t\t\tudp_sendto_if(dhcps_pcb,\
    \ newly_malloc_packet_buffer, &dhcps_send_broadcast_address, DHCP_CLIENT_PORT,\
    \ dhcps_netif);\n+\t}\n+\tpbuf_free(newly_malloc_packet_buffer);\n }\n \n /**\n\
    @@ -427,6 +662,18 @@ uint8_t dhcps_handle_state_machine_change(uint8_t option_message_type)\n\
    \ #if (!IS_USE_FIXED_IP) \t\n #if (debug_dhcps)\n \t\tprintf(\"\\r\\ndhcp_server_state_machine=%d\"\
    , dhcp_server_state_machine);\n+#if LWIP_VERSION_MAJOR >= 2\n+\t\tprintf(\"\\\
    r\\ndhcps_allocated_client_address=%d.%d.%d.%d\", \n+\t\t\t\tip4_addr1(ip_2_ip4(&dhcps_allocated_client_address)),\n\
    +\t\t\t\tip4_addr2(ip_2_ip4(&dhcps_allocated_client_address)),\n+\t\t\t\tip4_addr3(ip_2_ip4(&dhcps_allocated_client_address)),\n\
    +\t\t\t\tip4_addr4(ip_2_ip4(&dhcps_allocated_client_address)));\n+\t\tprintf(\"\
    \\r\\nclient_request_ip=%d.%d.%d.%d\\n\", \n+\t\t\t\tip4_addr1(ip_2_ip4(&client_request_ip)),\n\
    +\t\t\t\tip4_addr2(ip_2_ip4(&client_request_ip)),\n+\t\t\t\tip4_addr3(ip_2_ip4(&client_request_ip)),\n\
    +\t\t\t\tip4_addr4(ip_2_ip4(&client_request_ip)));\n+#else\n \t\tprintf(\"\\r\\\
    ndhcps_allocated_client_address=%d.%d.%d.%d\", \n \t\t\t\tip4_addr1(&dhcps_allocated_client_address),\n\
    \ \t\t\t\tip4_addr2(&dhcps_allocated_client_address),\n@@ -437,26 +684,71 @@ uint8_t\
    \ dhcps_handle_state_machine_change(uint8_t option_message_type)\n \t\t\t\tip4_addr2(&client_request_ip),\n\
    \ \t\t\t\tip4_addr3(&client_request_ip),\n \t\t\t\tip4_addr4(&client_request_ip));\n\
    +#endif\n+\n #endif\t\t\n+\n+\t\t// for renew\n+\t\tif((*(uint32_t *) dhcp_message_repository->ciaddr\
    \ != 0) && (*(uint32_t *)&client_request_ip == 0)) {\n+\t\t\tmemcpy(&client_request_ip,\
    \ dhcp_message_repository->ciaddr, sizeof(client_request_ip));\n+\t\t}\n+\n \t\
    \tif (dhcp_server_state_machine == DHCP_SERVER_STATE_OFFER) {\n-\t\t\tif (ip4_addr4(&dhcps_allocated_client_address)\
    \ != 0) { \n-\t\t\t\tif (memcmp((void *)&dhcps_allocated_client_address, (void\
    \ *)&client_request_ip, 4) == 0) {  \t\n+\t\t\tuint8_t ip_addr4 = check_client_direct_request_ip(&client_request_ip,\
    \ client_addr);\n+\n+\t\t\tif(ip_addr4 > 0){\n+#if LWIP_VERSION_MAJOR >= 2\n+\t\
    \t\t\tprintf(\"\\n\\r[%d] DHCP assign ip = %d.%d.%d.%d\\n\", xTaskGetTickCount(),\
    \ ip4_addr1(ip_2_ip4(&dhcps_network_id)),ip4_addr2(ip_2_ip4(&dhcps_network_id)),ip4_addr3(ip_2_ip4(&dhcps_network_id)),ip_addr4);\n\
    +\t\t\t\tIP4_ADDR(ip_2_ip4(&dhcps_allocated_client_address), (ip4_addr1(ip_2_ip4(&dhcps_network_id))),\n\
    +\t\t\t\t\t\tip4_addr2(ip_2_ip4(&dhcps_network_id)), ip4_addr3(ip_2_ip4(&dhcps_network_id)),\
    \ ip_addr4);\n+#else\n+\t\t\t\tprintf(\"\\n\\r[%d] DHCP assign ip = %d.%d.%d.%d\\\
    n\", xTaskGetTickCount(), ip4_addr1(&dhcps_network_id),ip4_addr2(&dhcps_network_id),ip4_addr3(&dhcps_network_id),ip_addr4);\n\
    +\t\t\t\tIP4_ADDR(&dhcps_allocated_client_address, (ip4_addr1(&dhcps_network_id)),\n\
    +\t\t\t\t\t\tip4_addr2(&dhcps_network_id), ip4_addr3(&dhcps_network_id), ip_addr4);\n\
    +#endif\n+\t\t\t\tdhcp_server_state_machine = DHCP_SERVER_STATE_ACK;\n+\t\t\t\t\
    break;\n+\t\t\t}\n+\n+#if LWIP_VERSION_MAJOR >= 2\n+\t\t\tif (ip4_addr4(ip_2_ip4(&dhcps_allocated_client_address))\
    \ != 0) \n+#else\n+\t\t\tif (ip4_addr4(&dhcps_allocated_client_address) != 0)\
    \ \n+#endif \n+\t\t\t{ \n+\t\t\t\tif (memcmp((void *)&dhcps_allocated_client_address,\
    \ (void *)&client_request_ip, 4) == 0) {  \n+#if LWIP_VERSION_MAJOR >= 2\n+\t\t\
    \t\t\tprintf(\"\\n\\r[%d] DHCP assign ip = %d.%d.%d.%d\\n\", xTaskGetTickCount(),\
    \ ip4_addr1(ip_2_ip4(&dhcps_network_id)),ip4_addr2(ip_2_ip4(&dhcps_network_id)),ip4_addr3(ip_2_ip4(&dhcps_network_id)),ip4_addr4(ip_2_ip4(&dhcps_allocated_client_address)));\n\
    +#else\n+\t\t\t\t\tprintf(\"\\n\\r[%d] DHCP assign ip = %d.%d.%d.%d\\n\", xTaskGetTickCount(),\
    \ ip4_addr1(&dhcps_network_id),ip4_addr2(&dhcps_network_id),ip4_addr3(&dhcps_network_id),ip4_addr4(&dhcps_allocated_client_address));\n\
    +#endif\n \t\t\t\t\tdhcp_server_state_machine = DHCP_SERVER_STATE_ACK;\n \t\t\t\
    \  \t} else {\n \t\t\t\t  \tdhcp_server_state_machine = DHCP_SERVER_STATE_NAK;\n\
    \ \t\t\t  \t}\n \t\t\t} else {\n \t\t\t  \tdhcp_server_state_machine = DHCP_SERVER_STATE_NAK;\n\
    \ \t\t\t}  \n+#ifdef CONFIG_DHCPS_KEPT_CLIENT_INFO\n \t\t} else if(dhcp_server_state_machine\
    \ == DHCP_SERVER_STATE_IDLE){\n-\t\t\tuint8_t ip_addr4 = check_client_request_ip(&client_request_ip,\
    \ client_addr);\n-\t\t\tif(ip_addr4 > 0){\n+\t\t\tuint8_t ip_addr4 = check_client_direct_request_ip(&client_request_ip,\
    \ client_addr);\n+\n+\t\t\tif(ip_addr4 > 0){\t\t\t\n+#if LWIP_VERSION_MAJOR >=\
    \ 2\n+\t\t\t\tprintf(\"\\n\\r[%d] DHCP assign ip = %d.%d.%d.%d\\n\", xTaskGetTickCount(),\
    \ ip4_addr1(ip_2_ip4(&dhcps_network_id)),ip4_addr2(ip_2_ip4(&dhcps_network_id)),ip4_addr3(ip_2_ip4(&dhcps_network_id)),ip_addr4);\n\
    +\t\t\t\tIP4_ADDR(ip_2_ip4(&dhcps_allocated_client_address), (ip4_addr1(ip_2_ip4(&dhcps_network_id))),\n\
    +\t\t\t\t\t\tip4_addr2(ip_2_ip4(&dhcps_network_id)), ip4_addr3(ip_2_ip4(&dhcps_network_id)),\
    \ ip_addr4);\n+#else\n+\t\t\t\tprintf(\"\\n\\r[%d] DHCP assign ip = %d.%d.%d.%d\\\
    n\", xTaskGetTickCount(), ip4_addr1(&dhcps_network_id),ip4_addr2(&dhcps_network_id),ip4_addr3(&dhcps_network_id),ip_addr4);\n\
    \ \t\t\t\tIP4_ADDR(&dhcps_allocated_client_address, (ip4_addr1(&dhcps_network_id)),\n\
    \ \t\t\t\t\t\tip4_addr2(&dhcps_network_id), ip4_addr3(&dhcps_network_id), ip_addr4);\n\
    +#endif\n+\n \t\t\t\tdhcp_server_state_machine = DHCP_SERVER_STATE_ACK;\n \t\t\
    \t}else{\n \t\t\t\tdhcp_server_state_machine = DHCP_SERVER_STATE_NAK;\n \t\t\t\
    }\n+#endif\n \t\t} else {\n \t\t\tdhcp_server_state_machine = DHCP_SERVER_STATE_NAK;\n\
    \ \t\t}\n@@ -556,6 +848,15 @@ struct pbuf *udp_packet_buffer, struct ip_addr *sender_addr,\
    \ uint16_t sender_por\n \t\treturn;  \n \t}\n \tif (sender_port == DHCP_CLIENT_PORT)\
    \ {\n+#if LWIP_VERSION_MAJOR >= 2\n+\t\tif(netif_get_idx(ip_current_input_netif())\
    \ == 0 && wifi_mode == RTW_MODE_STA_AP)\n+#else\n+\t\tif(netif_get_idx(ip_current_netif())\
    \ == 0 && wifi_mode == RTW_MODE_STA_AP)\n+#endif\n+\t\t{\n+\t\t\tpbuf_free(udp_packet_buffer);\n\
    +\t\t\treturn;\n+\t\t}\n \t\ttotal_length_of_packet_buffer = udp_packet_buffer->tot_len;\n\
    \ \t\tif (udp_packet_buffer->next != NULL) {\n \t\t\tmerged_packet_buffer = pbuf_coalesce(udp_packet_buffer,\n\
    @@ -565,6 +866,7 @@ struct pbuf *udp_packet_buffer, struct ip_addr *sender_addr,\
    \ uint16_t sender_por\n \t\t\t\tpbuf_free(udp_packet_buffer);\t\n \t\t\t\treturn;\n\
    \ \t\t\t}\n+\t\t\tudp_packet_buffer = merged_packet_buffer;\n \t\t}\n \t\tswitch\
    \ (dhcps_check_msg_and_handle_options(udp_packet_buffer)) {\n \t\tcase  DHCP_SERVER_STATE_OFFER:\n\
    @@ -579,7 +881,11 @@ struct pbuf *udp_packet_buffer, struct ip_addr *sender_addr,\
    \ uint16_t sender_por\n \t\t\t#endif\n \t\t\tdhcps_send_ack(udp_packet_buffer);\n\
    \ #if (!IS_USE_FIXED_IP)\n-\t\t\tmark_ip_in_table((uint8_t)ip4_addr4(&dhcps_allocated_client_address));\
    \ \t\t\t\n+#if LWIP_VERSION_MAJOR >= 2\n+\t\t\tmark_ip_in_table((uint8_t)ip4_addr4(ip_2_ip4(&dhcps_allocated_client_address)));\
    \ \n+#else\n+\t\t\tmark_ip_in_table((uint8_t)ip4_addr4(&dhcps_allocated_client_address));\
    \ \t\n+#endif\t\t\t\n \t#ifdef CONFIG_DHCPS_KEPT_CLIENT_INFO\n \t\t\tsave_client_addr(&dhcps_allocated_client_address,\
    \ client_addr);\n \t\t\tmemset(&client_request_ip, 0, sizeof(client_request_ip));\n\
    @@ -635,6 +941,65 @@ void dhcps_set_addr_pool(int addr_pool_set, struct ip_addr\
    \ * addr_pool_start, st\n \t\tdhcps_addr_pool_set = 0;\n \t}\n }\n+\n+\n+static\
    \ void dnss_receive_udp_packet_handler(void *arg, struct udp_pcb *udp_pcb,\n+struct\
    \ pbuf *udp_packet_buffer, struct ip_addr *sender_addr, uint16_t sender_port)\n\
    +{\n+\tint ret=0;\n+\tstruct dns_hdr *dns_rsp;\n+\n+/*\n+\tprintf(\"\\n%s: Receive\
    \ DNS query,ip = %d.%d.%d.%d, port = %d(%x)\\n\",__func__,\\\n+\t\t\tsender_addr->addr\
    \ & 0xff,\\\n+\t\t\tsender_addr->addr>>8 & 0xff,\\\n+\t\t\tsender_addr->addr>>16\
    \ & 0xff,\\\n+\t\t\tsender_addr->addr>>24 & 0xff,\\\n+\t\t\tsender_port,sender_port);\n\
    +*/\n+\n+\tdns_rsp = (struct dns_hdr*) udp_packet_buffer->payload;\n+\n+\tdns_rsp->flags1\
    \ |= 0x80; // 0x80 : Response;\n+\tdns_rsp->flags2 = 0x05;  //0x05 : Reply code\
    \ (Query Refused)\n+\n+\tret = udp_sendto(udp_pcb, udp_packet_buffer, sender_addr,\
    \ sender_port);\n+\n+\t/* free the UDP connection, so we can accept new clients\
    \ */\n+\tudp_disconnect(udp_pcb);\n+\n+\t/* Free the packet buffer */\n+\tpbuf_free(udp_packet_buffer);\n\
    +}\n+\n+\n+void dns_server_init(struct netif * pnetif)\n+{\n+\tuint8_t *ip;\n\
    +\n+\tif (dns_server_pcb != NULL) {\n+\t\tudp_remove(dns_server_pcb);\n+\t\tdns_server_pcb\
    \ = NULL;\n+\t}\n+\n+\tdns_server_pcb = udp_new();\n+\tif (dns_server_pcb == NULL)\
    \ {\n+\t\tprintf(\"\\n\\r Error!!!upd_new error \\n\\r\");\n+\t\treturn;\n+\t\
    }\n+\n+\tudp_bind(dns_server_pcb, IP_ADDR_ANY, DNS_SERVER_PORT);\n+\tudp_recv(dns_server_pcb,\
    \ dnss_receive_udp_packet_handler, NULL);\n+}\n+\n+void dns_server_deinit(void)\n\
    +{\n+\tif (dns_server_pcb != NULL) {\n+\t\tudp_remove(dns_server_pcb);\n+\t\t\
    dns_server_pcb = NULL;\n+\t}\n+}\n+\n /** \n   * @brief  Initialize dhcp server.\n\
    \   * @param  None.\n@@ -666,7 +1031,12 @@ void dhcps_init(struct netif * pnetif)\n\
    \ \t\tprintf(\"\\n\\r Error!!!upd_new error \\n\\r\");\n \t\treturn;\n \t}\n+#if\
    \ LWIP_VERSION_MAJOR >= 2\n+\tIP4_ADDR(ip_2_ip4(&dhcps_send_broadcast_address),\
    \ 255, 255, 255, 255);\n+#else\n \tIP4_ADDR(&dhcps_send_broadcast_address, 255,\
    \ 255, 255, 255);\n+#endif\n+\n \t/* get net info from net interface */\n \n \t\
    memcpy(&dhcps_local_address, &pnetif->ip_addr,\n@@ -678,6 +1048,15 @@ void dhcps_init(struct\
    \ netif * pnetif)\n \t\t\t\t\t\tsizeof(struct ip_addr));\n \n \t/* calculate the\
    \ usable network ip range */\n+#if LWIP_VERSION_MAJOR >= 2\n+\tip4_addr_set_u32(ip_2_ip4(&dhcps_network_id),\
    \ (ip_addr_get_ip4_u32(netif_ip_addr4(pnetif))&(ip_addr_get_ip4_u32(netif_ip_netmask4(pnetif)))));\n\
    +\tip4_addr_set_u32(ip_2_ip4(&dhcps_subnet_broadcast), (ip4_addr_get_u32(ip_2_ip4(&dhcps_network_id))\
    \ | ~(ip_addr_get_ip4_u32(netif_ip_netmask4(pnetif)))));\n+#if 1\n+\tip4_addr_set_u32(ip_2_ip4(&dhcps_owned_first_ip),\
    \ htonl(ntohl(ip4_addr_get_u32(ip_2_ip4(&dhcps_network_id))) + 1));\n+\tip4_addr_set_u32(ip_2_ip4(&dhcps_owned_last_ip),\
    \ htonl(ntohl(ip4_addr_get_u32(ip_2_ip4(&dhcps_subnet_broadcast))) - 1));\t\n\
    +\tdhcps_num_of_available_ips = (ntohl(ip4_addr_get_u32(ip_2_ip4(&dhcps_owned_last_ip)))\
    \ - ntohl(ip4_addr_get_u32(ip_2_ip4(&dhcps_owned_first_ip)))) + 1;\n+#endif\n\
    +#else\n \tdhcps_network_id.addr = ((pnetif->ip_addr.addr) &\n \t\t\t\t\t(pnetif->netmask.addr));\n\
    \ \t\n@@ -689,6 +1068,8 @@ void dhcps_init(struct netif * pnetif)\n \tdhcps_num_of_available_ips\
    \ = ((ntohl(dhcps_owned_last_ip.addr) \n \t\t\t\t- ntohl(dhcps_owned_first_ip.addr))\
    \ + 1); \n #endif\n+#endif\n+\n \n #if CONFIG_EXAMPLE_UART_ATCMD || CONFIG_EXAMPLE_SPI_ATCMD\
    \ \n #if IP_SOF_BROADCAST\n@@ -697,9 +1078,16 @@ void dhcps_init(struct netif\
    \ * pnetif)\n #endif\n \n #if IS_USE_FIXED_IP\n+#if LWIP_VERSION_MAJOR >= 2\n\
    +\tIP4_ADDR(ip_2_ip4(&dhcps_allocated_client_address), ip4_addr1(ip_2_ip4(&dhcps_local_address))\n\
    +\t\t, ip4_addr2(ip_2_ip4(&dhcps_local_address)), ip4_addr3(ip_2_ip4(&dhcps_local_address)),\n\
    +\t\t\t\t\t(ip4_addr4(ip_2_ip4(&dhcps_local_address))) + 1 );\n+#else\n \tIP4_ADDR(&dhcps_allocated_client_address,\
    \ ip4_addr1(&dhcps_local_address)\n \t\t, ip4_addr2(&dhcps_local_address), ip4_addr3(&dhcps_local_address),\n\
    \ \t\t\t\t\t(ip4_addr4(&dhcps_local_address)) + 1 );\n+#endif\n+\n #else\n \t\
    if (dhcps_ip_table_semaphore != NULL) {\t\n \t\tvSemaphoreDelete(dhcps_ip_table_semaphore);\n\
    @@ -709,15 +1097,26 @@ void dhcps_init(struct netif * pnetif)\n \n \t//dhcps_ip_table\
    \ = (struct ip_table *)(pvPortMalloc(sizeof(struct ip_table)));\n \tmemset(&ip_table,\
    \ 0, sizeof(struct table));\n+#if LWIP_VERSION_MAJOR >= 2\n+\tmark_ip_in_table((uint8_t)ip4_addr4(ip_2_ip4(&dhcps_local_address)));\n\
    +\tmark_ip_in_table((uint8_t)ip4_addr4(ip_2_ip4(&dhcps_local_gateway)));\n+#else\n\
    \ \tmark_ip_in_table((uint8_t)ip4_addr4(&dhcps_local_address));\n \tmark_ip_in_table((uint8_t)ip4_addr4(&dhcps_local_gateway));\n\
    +#endif\n+\n #if 0\n \tfor (i = 1; i < ip4_addr4(&dhcps_local_address); i++) {\n\
    \ \t\tmark_ip_in_table(i);\n \t}\n #endif\t\n #endif\n+#if LWIP_VERSION_MAJOR\
    \ >= 2\n+\tif(ip4_addr_get_u32(ip_2_ip4(&dhcps_addr_pool_start)) == 0 && ip4_addr_get_u32(ip_2_ip4(&dhcps_addr_pool_end))\
    \ == 0)\n+#else\n \tif(dhcps_addr_pool_start.addr== 0 && dhcps_addr_pool_end.addr\
    \ == 0)\n+#endif\n+\n \t{\t\t\n \t\tmemcpy(&dhcps_pool_start,&dhcps_local_address,sizeof(struct\
    \ ip_addr));\n \t\tip = (uint8_t *)&dhcps_pool_start;\n@@ -729,6 +1128,10 @@ void\
    \ dhcps_init(struct netif * pnetif)\n \t}\n \tudp_bind(dhcps_pcb, IP_ADDR_ANY,\
    \ DHCP_SERVER_PORT);\n \tudp_recv(dhcps_pcb, dhcps_receive_udp_packet_handler,\
    \ NULL);\n+\n+\t//DNS server init\n+\tdns_server_init(pnetif);\n+\n }\n \n void\
    \ dhcps_deinit(void)\n@@ -740,5 +1143,7 @@ void dhcps_deinit(void)\n \tif (dhcps_ip_table_semaphore\
    \ != NULL) {\t\n \t\tvSemaphoreDelete(dhcps_ip_table_semaphore);\n \t\tdhcps_ip_table_semaphore\
    \ = NULL;\n-\t}\t\t\n+\t}\t\t   \n+    //DNS server deinit\n+\tdns_server_deinit();\n\
    \ }"
  identifiers:
  - CVE-2022-29859
  - NVD-CWE-noinfo
  overview: component/common/network/dhcp/dhcps.c in ambiot amb1_sdk (aka SDK for
    Ameba1) before 2022-03-11 mishandles data structures for DHCP packet data.
  references:
  - source: cve@mitre.org
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/ambiot/amb1_sdk/commit/4b73f58f32914d0081d79a79e53a3215c8c1ea56
  - source: cve@mitre.org
    tags:
    - Third Party Advisory
    url: https://www.amebaiot.com/zh/security_bulletin/cve-2022-29859/
  title: component/common/network/dhcp/dhcps.c in ambiot amb1_sdk (aka SDK for Ameba1)
    before 2022-03-11 mishandles data structures for DHCP packet data.
- diff_content:
  - "--- a/mount.cifs.c\n+++ b/mount.cifs.c\n@@ -628,17 +628,13 @@ static int open_cred_file(char\
    \ *file_name,\n \t\t\t\tgoto return_i;\n \t\t\tbreak;\n \t\tcase CRED_DOM:\n-\t\
    \t\tif (parsed_info->verboseflag)\n-\t\t\t\tfprintf(stderr, \"domain=%s\\n\",\n\
    -\t\t\t\t\ttemp_val);\n \t\t\tstrlcpy(parsed_info->domain, temp_val,\n \t\t\t\t\
    sizeof(parsed_info->domain));\n \t\t\tbreak;\n \t\tcase CRED_UNPARSEABLE:\n \t\
    \t\tif (parsed_info->verboseflag)\n \t\t\t\tfprintf(stderr, \"Credential formatted\
    \ \"\n-\t\t\t\t\t\"incorrectly: %s\\n\",\n-\t\t\t\t\ttemp_val ? temp_val : \"\
    (null)\");\n+\t\t\t\t\t\"incorrectly\\n\");\n \t\t\tbreak;\n \t\t}\n \t}"
  identifiers:
  - CVE-2022-29869
  - CWE-532
  overview: cifs-utils through 6.14, with verbose logging, can cause an information
    leak when a file contains = (equal sign) characters but is not a valid credentials
    file.
  references:
  - source: cve@mitre.org
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/piastry/cifs-utils/commit/8acc963a2e7e9d63fe1f2e7f73f5a03f83d9c379
  - source: cve@mitre.org
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/piastry/cifs-utils/pull/7
  - source: cve@mitre.org
    tags:
    - Mailing List
    - Third Party Advisory
    url: https://lists.debian.org/debian-lts-announce/2022/05/msg00020.html
  - source: cve@mitre.org
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/5WBOLMANBYJILXQKRRK7OCR774PXJAYY/
  - source: cve@mitre.org
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/HXKZLJYJJEC3TIBFLXUORRMZUKG5W676/
  - source: cve@mitre.org
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/QIYZ4L6SLSYJQ446VJAO2VGAESURQNSP/
  - source: cve@mitre.org
    url: https://security.gentoo.org/glsa/202311-05
  - source: cve@mitre.org
    tags:
    - Third Party Advisory
    url: https://www.debian.org/security/2022/dsa-5157
  title: cifs-utils through 6.14, with verbose logging, can cause an information leak
    when a file contains = (equal sign) characters but is not a valid credentials
    file.
- diff_content:
  - "--- a/src/index.c\n+++ b/src/index.c\n@@ -961,17 +961,13 @@ MOBI_RET mobi_decode_infl(unsigned\
    \ char *decoded, int *decoded_size, const unsig\n             }\n            \
    \ pos -= c - 10;\n             dir = 0;\n-            if (pos < 0 || pos > *decoded_size)\
    \ {\n-                debug_print(\"Position setting failed (%s)\\n\", decoded);\n\
    -                return MOBI_DATA_CORRUPT;\n-            }\n         }\n     \
    \    else {\n             if (mod == 'i') {\n                 const unsigned char\
    \ *s = decoded + pos;\n                 unsigned char *d = decoded + pos + 1;\n\
    \                 const int l = *decoded_size - pos;\n-                if (l <\
    \ 0 || d + l > decoded + INDX_INFLBUF_SIZEMAX) {\n+                if (pos < 0\
    \ || l < 0 || d + l > decoded + INDX_INFLBUF_SIZEMAX) {\n                    \
    \ debug_print(\"Out of buffer in %s at pos: %i\\n\", decoded, pos);\n        \
    \             return MOBI_DATA_CORRUPT;\n                 }\n@@ -984,7 +980,7\
    \ @@ MOBI_RET mobi_decode_infl(unsigned char *decoded, int *decoded_size, const\
    \ unsig\n                 const unsigned char *s = decoded + pos + 1;\n      \
    \           unsigned char *d = decoded + pos;\n                 const int l =\
    \ *decoded_size - pos;\n-                if (l < 0 || d + l > decoded + INDX_INFLBUF_SIZEMAX)\
    \ {\n+                if (pos < 0 || l < 0 || s + l > decoded + INDX_INFLBUF_SIZEMAX)\
    \ {\n                     debug_print(\"Out of buffer in %s at pos: %i\\n\", decoded,\
    \ pos);\n                     return MOBI_DATA_CORRUPT;\n                 }"
  identifiers:
  - CVE-2022-1533
  - CWE-125
  overview: Buffer Over-read in GitHub repository bfabiszewski/libmobi prior to 0.11.
    This vulnerability is capable of arbitrary code execution.
  references:
  - source: security@huntr.dev
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/bfabiszewski/libmobi/commit/eafc415bc6067e72577f70d6dd5acbf057ce6e6f
  - source: security@huntr.dev
    tags:
    - Exploit
    - Issue Tracking
    - Patch
    - Third Party Advisory
    url: https://huntr.dev/bounties/cb574ce1-fbf7-42ea-9e6a-91e17adecdc3
  title: Buffer Over-read in GitHub repository bfabiszewski/libmobi prior to 0.11.
    This vulnerability is capable of arbitrary code execution.
- diff_content:
  - "--- a/src/parse_rawml.c\n+++ b/src/parse_rawml.c\n@@ -1413,6 +1413,10 @@ MOBI_RET\
    \ mobi_reconstruct_infl(char *outstring, const MOBIIndx *infl, const MOBI\n  \
    \           \n             unsigned char decoded[INDX_INFLBUF_SIZEMAX + 1];\n\
    \             memset(decoded, 0, INDX_INFLBUF_SIZEMAX + 1);\n+            if (parts[j]\
    \ >= infl->entries_count) {\n+                debug_print(\"%s\\n\", \"Invalid\
    \ entry offset\");\n+                return MOBI_DATA_CORRUPT;\n+            }\n\
    \             unsigned char *rule = (unsigned char *) infl->entries[parts[j]].label;\n\
    \             memcpy(decoded, label, label_length);\n             int decoded_length\
    \ = (int) label_length;"
  identifiers:
  - CVE-2022-1534
  - CWE-125
  overview: Buffer Over-read at parse_rawml.c:1416 in GitHub repository bfabiszewski/libmobi
    prior to 0.11. The bug causes the program reads data past the end of the intented
    buffer. Typically, this can allow attackers to read sensitive information from
    other memory locations or cause a crash.
  references:
  - source: security@huntr.dev
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/bfabiszewski/libmobi/commit/fb1ab50e448ddbed746fd27ae07469bc506d838b
  - source: security@huntr.dev
    tags:
    - Exploit
    - Issue Tracking
    - Patch
    - Third Party Advisory
    url: https://huntr.dev/bounties/9a90ffa1-38f5-4685-9c00-68ba9068ce3d
  title: Buffer Over-read at parse_rawml.c:1416 in GitHub repository bfabiszewski/libmobi
    prior to 0.11. The bug causes the program reads data past the end of the intented
    buffer. Typically, this can allow attackers to read sensitive information from
    other memory locations or cause a crash.
- diff_content:
  - "--- a/net/key/af_key.c\n+++ b/net/key/af_key.c\n@@ -1699,7 +1699,7 @@ static\
    \ int pfkey_register(struct sock *sk, struct sk_buff *skb, const struct sad\n\
    \ \n \txfrm_probe_algs();\n \n-\tsupp_skb = compose_sadb_supported(hdr, GFP_KERNEL);\n\
    +\tsupp_skb = compose_sadb_supported(hdr, GFP_KERNEL | __GFP_ZERO);\n \tif (!supp_skb)\
    \ {\n \t\tif (hdr->sadb_msg_satype != SADB_SATYPE_UNSPEC)\n \t\t\tpfk->registered\
    \ &= ~(1<<hdr->sadb_msg_satype);"
  identifiers:
  - CVE-2022-1353
  - NVD-CWE-noinfo
  overview: A vulnerability was found in the pfkey_register function in net/key/af_key.c
    in the Linux kernel. This flaw allows a local, unprivileged user to gain access
    to kernel memory, leading to a system crash or a leak of internal kernel information.
  references:
  - source: secalert@redhat.com
    tags:
    - Issue Tracking
    - Patch
    - Third Party Advisory
    url: https://bugzilla.redhat.com/show_bug.cgi?id=2066819
  - source: secalert@redhat.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/torvalds/linux/commit/9a564bccb78a76740ea9d75a259942df8143d02c
  - source: secalert@redhat.com
    tags:
    - Mailing List
    - Third Party Advisory
    url: https://lists.debian.org/debian-lts-announce/2022/07/msg00000.html
  - source: secalert@redhat.com
    tags:
    - Third Party Advisory
    url: https://security.netapp.com/advisory/ntap-20220629-0001/
  - source: secalert@redhat.com
    tags:
    - Third Party Advisory
    url: https://www.debian.org/security/2022/dsa-5127
  - source: secalert@redhat.com
    tags:
    - Third Party Advisory
    url: https://www.debian.org/security/2022/dsa-5173
  title: A vulnerability was found in the pfkey_register function in net/key/af_key.c
    in the Linux kernel. This flaw allows a local, unprivileged user to gain access
    to kernel memory, leading to a system crash or a leak of internal kernel information.
- diff_content:
  - "--- a/src/static_compressed_inmemory_website_callback.c\n+++ b/src/static_compressed_inmemory_website_callback.c\n\
    @@ -4,7 +4,7 @@\n  *\n  * Copyright 2020-2022 Nicolas Mora <mail@babelouest.org>\n\
    \  *\n- * Version 20220425\n+ * Version 20220428\n  *\n  * The MIT License (MIT)\n\
    \  *\n@@ -89,6 +89,8 @@\n  */\n #include <pthread.h>\n #include <zlib.h>\n+#include\
    \ <limits.h>\n+#include <stdlib.h>\n #include <string.h>\n #include <ulfius.h>\n\
    \ \n@@ -158,7 +160,7 @@ static void callback_static_file_uncompressed_stream_free(void\
    \ * cls) {\n static int callback_static_file_uncompressed (const struct _u_request\
    \ * request, struct _u_response * response, void * user_data) {\n   size_t length;\n\
    \   FILE * f;\n-  char * file_requested, * file_path, * url_dup_save;\n+  char\
    \ * file_requested, * file_path, * url_dup_save, * real_path = NULL;\n   const\
    \ char * content_type;\n   int ret = U_CALLBACK_CONTINUE;\n \n@@ -185,34 +187,40\
    \ @@ static int callback_static_file_uncompressed (const struct _u_request * request,\n\
    \     }\n \n     file_path = msprintf(\"%s/%s\", ((struct _u_compressed_inmemory_website_config\
    \ *)user_data)->files_path, file_requested);\n+    real_path = realpath(file_path,\
    \ NULL);\n+    if (0 == o_strncmp(((struct _u_compressed_inmemory_website_config\
    \ *)user_data)->files_path, real_path, o_strlen(((struct _u_compressed_inmemory_website_config\
    \ *)user_data)->files_path))) {\n+      f = fopen (file_path, \"rb\");\n+    \
    \  if (f) {\n+        fseek (f, 0, SEEK_END);\n+        length = ftell (f);\n\
    +        fseek (f, 0, SEEK_SET);\n+\n+        content_type = u_map_get_case(&((struct\
    \ _u_compressed_inmemory_website_config *)user_data)->mime_types, get_filename_ext(file_requested));\n\
    +        if (content_type == NULL) {\n+          content_type = u_map_get(&((struct\
    \ _u_compressed_inmemory_website_config *)user_data)->mime_types, \"*\");\n+ \
    \         y_log_message(Y_LOG_LEVEL_WARNING, \"Static File Server - Unknown mime\
    \ type for extension %s\", get_filename_ext(file_requested));\n+        }\n+ \
    \       u_map_put(response->map_header, \"Content-Type\", content_type);\n+  \
    \      u_map_copy_into(response->map_header, &((struct _u_compressed_inmemory_website_config\
    \ *)user_data)->map_header);\n \n-    f = fopen (file_path, \"rb\");\n-    if\
    \ (f) {\n-      fseek (f, 0, SEEK_END);\n-      length = ftell (f);\n-      fseek\
    \ (f, 0, SEEK_SET);\n-\n-      content_type = u_map_get_case(&((struct _u_compressed_inmemory_website_config\
    \ *)user_data)->mime_types, get_filename_ext(file_requested));\n-      if (content_type\
    \ == NULL) {\n-        content_type = u_map_get(&((struct _u_compressed_inmemory_website_config\
    \ *)user_data)->mime_types, \"*\");\n-        y_log_message(Y_LOG_LEVEL_WARNING,\
    \ \"Static File Server - Unknown mime type for extension %s\", get_filename_ext(file_requested));\n\
    -      }\n-      u_map_put(response->map_header, \"Content-Type\", content_type);\n\
    -      u_map_copy_into(response->map_header, &((struct _u_compressed_inmemory_website_config\
    \ *)user_data)->map_header);\n-\n-      if (ulfius_set_stream_response(response,\
    \ 200, callback_static_file_uncompressed_stream, callback_static_file_uncompressed_stream_free,\
    \ length, CHUNK, f) != U_OK) {\n-        y_log_message(Y_LOG_LEVEL_ERROR, \"Static\
    \ File Server - Error ulfius_set_stream_response\");\n-      }\n-    } else {\n\
    -      if (((struct _u_compressed_inmemory_website_config *)user_data)->redirect_on_404\
    \ == NULL) {\n-        ret = U_CALLBACK_IGNORE;\n+        if (ulfius_set_stream_response(response,\
    \ 200, callback_static_file_uncompressed_stream, callback_static_file_uncompressed_stream_free,\
    \ length, CHUNK, f) != U_OK) {\n+          y_log_message(Y_LOG_LEVEL_ERROR, \"\
    Static File Server - Error ulfius_set_stream_response\");\n+        }\n      \
    \ } else {\n-        ulfius_add_header_to_response(response, \"Location\", ((struct\
    \ _u_compressed_inmemory_website_config *)user_data)->redirect_on_404);\n-   \
    \     response->status = 302;\n+        if (((struct _u_compressed_inmemory_website_config\
    \ *)user_data)->redirect_on_404 == NULL) {\n+          ret = U_CALLBACK_IGNORE;\n\
    +        } else {\n+          ulfius_add_header_to_response(response, \"Location\"\
    , ((struct _u_compressed_inmemory_website_config *)user_data)->redirect_on_404);\n\
    +          response->status = 302;\n+        }\n       }\n+      o_free(url_dup_save);\n\
    +    } else {\n+      response->status = 403;\n     }\n     o_free(file_path);\n\
    -    o_free(url_dup_save);\n+    free(real_path); // realpath uses malloc\n+\n\
    \   } else {\n     y_log_message(Y_LOG_LEVEL_ERROR, \"Static File Server - Error,\
    \ user_data is NULL or inconsistent\");\n     ret = U_CALLBACK_ERROR;\n@@ -290,7\
    \ +298,7 @@ int callback_static_compressed_inmemory_website (const struct _u_request\
    \ * reque\n   unsigned char * file_content, * file_content_orig = NULL;\n   size_t\
    \ length, read_length, offset, data_zip_len = 0;\n   FILE * f;\n-  char * file_requested,\
    \ * file_path, * url_dup_save, * data_zip = NULL;\n+  char * file_requested, *\
    \ file_path, * url_dup_save, * data_zip = NULL, * real_path = NULL;\n   const\
    \ char * content_type;\n \n   /*\n@@ -352,120 +359,129 @@ int callback_static_compressed_inmemory_website\
    \ (const struct _u_request * reque\n             u_map_copy_into(response->map_header,\
    \ &config->map_header);\n           } else {\n             file_path = msprintf(\"\
    %s/%s\", ((struct _u_compressed_inmemory_website_config *)user_data)->files_path,\
    \ file_requested);\n+            real_path = realpath(file_path, NULL);\n+   \
    \         if (0 == o_strncmp(((struct _u_compressed_inmemory_website_config *)user_data)->files_path,\
    \ real_path, o_strlen(((struct _u_compressed_inmemory_website_config *)user_data)->files_path)))\
    \ {\n+              if (!pthread_mutex_lock(&config->lock)) {\n+             \
    \   f = fopen (file_path, \"rb\");\n+                if (f) {\n+             \
    \     content_type = u_map_get_case(&config->mime_types, get_filename_ext(file_requested));\n\
    +                  if (content_type == NULL) {\n+                    content_type\
    \ = u_map_get(&config->mime_types, \"*\");\n+                    y_log_message(Y_LOG_LEVEL_WARNING,\
    \ \"Static File Server - Unknown mime type for extension %s\", get_filename_ext(file_requested));\n\
    +                  }\n+                  if (!string_array_has_value((const char\
    \ **)config->mime_types_compressed, content_type)) {\n+                    compress_mode\
    \ = U_COMPRESS_NONE;\n+                  }\n \n-            if (!pthread_mutex_lock(&config->lock))\
    \ {\n-              f = fopen (file_path, \"rb\");\n-              if (f) {\n\
    -                content_type = u_map_get_case(&config->mime_types, get_filename_ext(file_requested));\n\
    -                if (content_type == NULL) {\n-                  content_type\
    \ = u_map_get(&config->mime_types, \"*\");\n-                  y_log_message(Y_LOG_LEVEL_WARNING,\
    \ \"Static File Server - Unknown mime type for extension %s\", get_filename_ext(file_requested));\n\
    -                }\n-                if (!string_array_has_value((const char **)config->mime_types_compressed,\
    \ content_type)) {\n-                  compress_mode = U_COMPRESS_NONE;\n-   \
    \             }\n-\n-                u_map_put(response->map_header, \"Content-Type\"\
    , content_type);\n-                u_map_copy_into(response->map_header, &config->map_header);\n\
    -                \n-                fseek (f, 0, SEEK_END);\n-               \
    \ offset = length = ftell (f);\n-                fseek (f, 0, SEEK_SET);\n-\n\
    -                if (length) {\n-                  if ((file_content_orig = file_content\
    \ = o_malloc(length)) != NULL && (data_zip = o_malloc((2*length)+20)) != NULL)\
    \ {\n-                    defstream.zalloc = u_zalloc;\n-                    defstream.zfree\
    \ = u_zfree;\n-                    defstream.opaque = Z_NULL;\n-             \
    \       defstream.avail_in = (uInt)length;\n-                    defstream.next_in\
    \ = (Bytef *)file_content;\n-                    while ((read_length = fread(file_content,\
    \ sizeof(char), offset, f))) {\n-                      file_content += read_length;\n\
    -                      offset -= read_length;\n-                    }\n-\n-  \
    \                  if (compress_mode == U_COMPRESS_GZIP) {\n-                \
    \      if (deflateInit2(&defstream,\n-                                       Z_DEFAULT_COMPRESSION,\n\
    -                                       Z_DEFLATED,\n-                       \
    \                U_GZIP_WINDOW_BITS | U_GZIP_ENCODING,\n-                    \
    \                   8,\n-                                       Z_DEFAULT_STRATEGY)\
    \ != Z_OK) {\n-                        y_log_message(Y_LOG_LEVEL_ERROR, \"callback_static_compressed_inmemory_website\
    \ - Error deflateInit (gzip)\");\n-                        ret = U_CALLBACK_ERROR;\n\
    -                      }\n-                    } else {\n-                   \
    \   if (deflateInit(&defstream, Z_BEST_COMPRESSION) != Z_OK) {\n-            \
    \            y_log_message(Y_LOG_LEVEL_ERROR, \"callback_static_compressed_inmemory_website\
    \ - Error deflateInit (deflate)\");\n-                        ret = U_CALLBACK_ERROR;\n\
    +                  u_map_put(response->map_header, \"Content-Type\", content_type);\n\
    +                  u_map_copy_into(response->map_header, &config->map_header);\n\
    +\n+                  fseek (f, 0, SEEK_END);\n+                  offset = length\
    \ = ftell (f);\n+                  fseek (f, 0, SEEK_SET);\n+\n+             \
    \     if (length) {\n+                    if ((file_content_orig = file_content\
    \ = o_malloc(length)) != NULL && (data_zip = o_malloc((2*length)+20)) != NULL)\
    \ {\n+                      defstream.zalloc = u_zalloc;\n+                  \
    \    defstream.zfree = u_zfree;\n+                      defstream.opaque = Z_NULL;\n\
    +                      defstream.avail_in = (uInt)length;\n+                 \
    \     defstream.next_in = (Bytef *)file_content;\n+                      while\
    \ ((read_length = fread(file_content, sizeof(char), offset, f))) {\n+        \
    \                file_content += read_length;\n+                        offset\
    \ -= read_length;\n                       }\n-                    }\n-       \
    \             if (ret == U_CALLBACK_CONTINUE) {\n-                      do {\n\
    -                        if ((data_zip = o_realloc(data_zip, data_zip_len+_U_W_BLOCK_SIZE))\
    \ != NULL) {\n-                          defstream.avail_out = _U_W_BLOCK_SIZE;\n\
    -                          defstream.next_out = ((Bytef *)data_zip)+data_zip_len;\n\
    -                          switch ((res = deflate(&defstream, Z_FINISH))) {\n\
    -                            case Z_OK:\n-                            case Z_STREAM_END:\n\
    -                            case Z_BUF_ERROR:\n-                            \
    \  break;\n-                            default:\n-                          \
    \    y_log_message(Y_LOG_LEVEL_ERROR, \"callback_static_compressed_inmemory_website\
    \ - Error deflate %d\", res);\n-                              ret = U_CALLBACK_ERROR;\n\
    -                              break;\n-                          }\n-       \
    \                   data_zip_len += _U_W_BLOCK_SIZE - defstream.avail_out;\n-\
    \                        } else {\n-                          y_log_message(Y_LOG_LEVEL_ERROR,\
    \ \"callback_static_compressed_inmemory_website - Error allocating resources for\
    \ data_zip\");\n+\n+                      if (compress_mode == U_COMPRESS_GZIP)\
    \ {\n+                        if (deflateInit2(&defstream,\n+                \
    \                         Z_DEFAULT_COMPRESSION,\n+                          \
    \               Z_DEFLATED,\n+                                         U_GZIP_WINDOW_BITS\
    \ | U_GZIP_ENCODING,\n+                                         8,\n+        \
    \                                 Z_DEFAULT_STRATEGY) != Z_OK) {\n+          \
    \                y_log_message(Y_LOG_LEVEL_ERROR, \"callback_static_compressed_inmemory_website\
    \ - Error deflateInit (gzip)\");\n                           ret = U_CALLBACK_ERROR;\n\
    \                         }\n-                      } while (U_CALLBACK_CONTINUE\
    \ == ret && defstream.avail_out == 0);\n-\n+                      } else {\n+\
    \                        if (deflateInit(&defstream, Z_BEST_COMPRESSION) != Z_OK)\
    \ {\n+                          y_log_message(Y_LOG_LEVEL_ERROR, \"callback_static_compressed_inmemory_website\
    \ - Error deflateInit (deflate)\");\n+                          ret = U_CALLBACK_ERROR;\n\
    +                        }\n+                      }\n                       if\
    \ (ret == U_CALLBACK_CONTINUE) {\n-                        if (compress_mode ==\
    \ U_COMPRESS_GZIP) {\n-                          if (config->allow_cache_compressed)\
    \ {\n-                            u_map_put_binary(&config->gzip_files, file_requested,\
    \ data_zip, 0, defstream.total_out);\n+                        do {\n+       \
    \                   if ((data_zip = o_realloc(data_zip, data_zip_len+_U_W_BLOCK_SIZE))\
    \ != NULL) {\n+                            defstream.avail_out = _U_W_BLOCK_SIZE;\n\
    +                            defstream.next_out = ((Bytef *)data_zip)+data_zip_len;\n\
    +                            switch ((res = deflate(&defstream, Z_FINISH))) {\n\
    +                              case Z_OK:\n+                              case\
    \ Z_STREAM_END:\n+                              case Z_BUF_ERROR:\n+         \
    \                       break;\n+                              default:\n+   \
    \                             y_log_message(Y_LOG_LEVEL_ERROR, \"callback_static_compressed_inmemory_website\
    \ - Error deflate %d\", res);\n+                                ret = U_CALLBACK_ERROR;\n\
    +                                break;\n+                            }\n+   \
    \                         data_zip_len += _U_W_BLOCK_SIZE - defstream.avail_out;\n\
    +                          } else {\n+                            y_log_message(Y_LOG_LEVEL_ERROR,\
    \ \"callback_static_compressed_inmemory_website - Error allocating resources for\
    \ data_zip\");\n+                            ret = U_CALLBACK_ERROR;\n       \
    \                    }\n-                          ulfius_set_binary_body_response(response,\
    \ 200, u_map_get(&config->gzip_files, file_requested), u_map_get_length(&config->gzip_files,\
    \ file_requested));\n-                        } else {\n-                    \
    \      if (config->allow_cache_compressed) {\n-                            u_map_put_binary(&config->deflate_files,\
    \ file_requested, data_zip, 0, defstream.total_out);\n+                      \
    \  } while (U_CALLBACK_CONTINUE == ret && defstream.avail_out == 0);\n+\n+   \
    \                     if (ret == U_CALLBACK_CONTINUE) {\n+                   \
    \       if (compress_mode == U_COMPRESS_GZIP) {\n+                           \
    \ if (config->allow_cache_compressed) {\n+                              u_map_put_binary(&config->gzip_files,\
    \ file_requested, data_zip, 0, defstream.total_out);\n+                      \
    \      }\n+                            ulfius_set_binary_body_response(response,\
    \ 200, u_map_get(&config->gzip_files, file_requested), u_map_get_length(&config->gzip_files,\
    \ file_requested));\n+                          } else {\n+                  \
    \          if (config->allow_cache_compressed) {\n+                          \
    \    u_map_put_binary(&config->deflate_files, file_requested, data_zip, 0, defstream.total_out);\n\
    +                            }\n+                            ulfius_set_binary_body_response(response,\
    \ 200, u_map_get(&config->deflate_files, file_requested), u_map_get_length(&config->deflate_files,\
    \ file_requested));\n                           }\n-                         \
    \ ulfius_set_binary_body_response(response, 200, u_map_get(&config->deflate_files,\
    \ file_requested), u_map_get_length(&config->deflate_files, file_requested));\n\
    +                          u_map_put(response->map_header, U_CONTENT_HEADER, compress_mode==U_COMPRESS_GZIP?U_ACCEPT_GZIP:U_ACCEPT_DEFLATE);\n\
    \                         }\n-                        u_map_put(response->map_header,\
    \ U_CONTENT_HEADER, compress_mode==U_COMPRESS_GZIP?U_ACCEPT_GZIP:U_ACCEPT_DEFLATE);\n\
    \                       }\n+                      deflateEnd(&defstream);\n+ \
    \                     o_free(data_zip);\n+                    } else {\n+    \
    \                  y_log_message(Y_LOG_LEVEL_ERROR, \"callback_static_compressed_inmemory_website\
    \ - Error allocating resource for file_content or data_zip\");\n+            \
    \          ret = U_CALLBACK_ERROR;\n                     }\n-                \
    \    deflateEnd(&defstream);\n-                    o_free(data_zip);\n+      \
    \              o_free(file_content_orig);\n+                  }\n+           \
    \       fclose(f);\n+                } else {\n+                  if (((struct\
    \ _u_compressed_inmemory_website_config *)user_data)->redirect_on_404 == NULL)\
    \ {\n+                    ret = U_CALLBACK_IGNORE;\n                   } else\
    \ {\n-                    y_log_message(Y_LOG_LEVEL_ERROR, \"callback_static_compressed_inmemory_website\
    \ - Error allocating resource for file_content or data_zip\");\n-            \
    \        ret = U_CALLBACK_ERROR;\n+                    ulfius_add_header_to_response(response,\
    \ \"Location\", ((struct _u_compressed_inmemory_website_config *)user_data)->redirect_on_404);\n\
    +                    response->status = 302;\n                   }\n-        \
    \          o_free(file_content_orig);\n                 }\n-                fclose(f);\n\
    +                pthread_mutex_unlock(&config->lock);\n               } else {\n\
    -                if (((struct _u_compressed_inmemory_website_config *)user_data)->redirect_on_404\
    \ == NULL) {\n-                  ret = U_CALLBACK_IGNORE;\n-                }\
    \ else {\n-                  ulfius_add_header_to_response(response, \"Location\"\
    , ((struct _u_compressed_inmemory_website_config *)user_data)->redirect_on_404);\n\
    -                  response->status = 302;\n-                }\n+            \
    \    y_log_message(Y_LOG_LEVEL_ERROR, \"callback_static_compressed_inmemory_website\
    \ - Error pthread_lock_mutex\");\n+                ret = U_CALLBACK_ERROR;\n \
    \              }\n-              pthread_mutex_unlock(&config->lock);\n      \
    \       } else {\n-              y_log_message(Y_LOG_LEVEL_ERROR, \"callback_static_compressed_inmemory_website\
    \ - Error pthread_lock_mutex\");\n-              ret = U_CALLBACK_ERROR;\n+  \
    \            response->status = 403;\n             }\n             o_free(file_path);\n\
    +            free(real_path); // realpath uses malloc\n           }\n        \
    \ } else {\n           ret = callback_static_file_uncompressed(request, response,\
    \ user_data);\n         }\n         free_string_array(accept_list);\n+      }\
    \ else {\n+        ret = callback_static_file_uncompressed(request, response,\
    \ user_data);\n       }\n+    } else {\n+      ret = callback_static_file_uncompressed(request,\
    \ response, user_data);\n     }\n     o_free(url_dup_save);\n   }"
  identifiers:
  - CVE-2022-29967
  - CWE-22
  overview: static_compressed_inmemory_website_callback.c in Glewlwyd through 2.6.2
    allows directory traversal.
  references:
  - source: cve@mitre.org
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/babelouest/glewlwyd/commit/e3f7245c33897bf9b3a75acfcdb8b7b93974bf11
  title: static_compressed_inmemory_website_callback.c in Glewlwyd through 2.6.2 allows
    directory traversal.
- diff_content:
  - "--- a/fs/io_uring.c\n+++ b/fs/io_uring.c\n@@ -3783,6 +3783,7 @@ static int io_rw_init_file(struct\
    \ io_kiocb *req, fmode_t mode)\n \t\tif (!(kiocb->ki_flags & IOCB_DIRECT) || !file->f_op->iopoll)\n\
    \ \t\t\treturn -EOPNOTSUPP;\n \n+\t\tkiocb->private = NULL;\n \t\tkiocb->ki_flags\
    \ |= IOCB_HIPRI | IOCB_ALLOC_CACHE;\n \t\tkiocb->ki_complete = io_complete_rw_iopoll;\n\
    \ \t\treq->iopoll_completed = 0;"
  identifiers:
  - CVE-2022-29968
  - CWE-909
  overview: An issue was discovered in the Linux kernel through 5.17.5. io_rw_init_file
    in fs/io_uring.c lacks initialization of kiocb->private.
  references:
  - source: cve@mitre.org
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/torvalds/linux/commit/32452a3eb8b64e01e2be717f518c0be046975b9d
  - source: cve@mitre.org
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/LU7MT7BPTA2NG24BTLZF5ZWYTLSO7BU3/
  - source: cve@mitre.org
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/TLWTG3TWIMLNQEVTA3ZQYVLLU2AJM3DY/
  - source: cve@mitre.org
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/XA7UZ3HS73KXVYCIKN5ZDH7LLLGPUMOZ/
  - source: cve@mitre.org
    tags:
    - Third Party Advisory
    url: https://security.netapp.com/advisory/ntap-20220715-0009/
  title: An issue was discovered in the Linux kernel through 5.17.5. io_rw_init_file
    in fs/io_uring.c lacks initialization of kiocb->private.
- diff_content:
  - "--- a/SDL_ttf.c\n+++ b/SDL_ttf.c\n@@ -1257,7 +1257,7 @@ static SDL_Surface* Create_Surface_Solid(int\
    \ width, int height, SDL_Color fg, Ui\n      */\n     void *pixels, *ptr;\n  \
    \   /* Worse case at the end of line pulling 'alignment' extra blank pixels */\n\
    -    Sint64 pitch = width + alignment;\n+    Sint64 pitch = (Sint64)width + (Sint64)alignment;\n\
    \     pitch += alignment;\n     pitch &= ~alignment;\n     size = height * pitch\
    \ + sizeof (void *) + alignment;\n@@ -1321,7 +1321,7 @@ static SDL_Surface* Create_Surface_Shaded(int\
    \ width, int height, SDL_Color fg, S\n      */\n     void *pixels, *ptr;\n   \
    \  /* Worse case at the end of line pulling 'alignment' extra blank pixels */\n\
    -    Sint64 pitch = width + alignment;\n+    Sint64 pitch = (Sint64)width + (Sint64)alignment;\n\
    \     pitch += alignment;\n     pitch &= ~alignment;\n     size = height * pitch\
    \ + sizeof (void *) + alignment;\n@@ -1418,7 +1418,7 @@ static SDL_Surface *Create_Surface_Blended(int\
    \ width, int height, SDL_Color fg,\n         Sint64 size;\n         void *pixels,\
    \ *ptr;\n         /* Worse case at the end of line pulling 'alignment' extra blank\
    \ pixels */\n-        Sint64 pitch = (width + alignment) * 4;\n+        Sint64\
    \ pitch = ((Sint64)width + (Sint64)alignment) * 4;\n         pitch += alignment;\n\
    \         pitch &= ~alignment;\n         size = height * pitch + sizeof (void\
    \ *) + alignment;"
  identifiers:
  - CVE-2022-27470
  - CWE-787
  overview: SDL_ttf v2.0.18 and below was discovered to contain an arbitrary memory
    write via the function TTF_RenderText_Solid(). This vulnerability is triggered
    via a crafted TTF file.
  references:
  - source: cve@mitre.org
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/libsdl-org/SDL_ttf/commit/db1b41ab8bde6723c24b866e466cad78c2fa0448
  - source: cve@mitre.org
    tags:
    - Exploit
    - Issue Tracking
    - Patch
    - Third Party Advisory
    url: https://github.com/libsdl-org/SDL_ttf/issues/187
  - source: cve@mitre.org
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/EAGMQMRQDTZFQW64JEW3O6HY3JYLAAHT/
  - source: cve@mitre.org
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/RXI3MDPR24W5557G34YHWOP2MOK6BTGB/
  - source: cve@mitre.org
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/XPYTEBBNHCDGPVFACC5RC5K2FZUCYTPZ/
  title: SDL_ttf v2.0.18 and below was discovered to contain an arbitrary memory write
    via the function TTF_RenderText_Solid(). This vulnerability is triggered via a
    crafted TTF file.
- diff_content:
  - "--- a/squirrel/sqbaselib.cpp\n+++ b/squirrel/sqbaselib.cpp\n@@ -1149,6 +1149,7\
    \ @@ static SQInteger thread_call(HSQUIRRELVM v)\n     SQObjectPtr o = stack_get(v,1);\n\
    \     if(sq_type(o) == OT_THREAD) {\n         SQInteger nparams = sq_gettop(v);\n\
    +        sq_reservestack(_thread(o), nparams + 3);\n         _thread(o)->Push(_thread(o)->_roottable);\n\
    \         for(SQInteger i = 2; i<(nparams+1); i++)\n             sq_move(_thread(o),v,i);"
  identifiers:
  - CVE-2022-30292
  - CWE-787
  overview: Heap-based buffer overflow in sqbaselib.cpp in SQUIRREL 3.2 due to lack
    of a certain sq_reservestack call.
  references:
  - source: cve@mitre.org
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/albertodemichelis/squirrel/commit/a6413aa690e0bdfef648c68693349a7b878fe60d
  - source: cve@mitre.org
    tags:
    - Third Party Advisory
    url: https://github.com/sprushed/CVE-2022-30292
  - source: cve@mitre.org
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/BV7SJJ44AGAX4ILIVPREIXPJ2GOG3FKV/
  - source: cve@mitre.org
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/DMIKSVTKNU5FRCUUNAYMCQLOJA3K3S2I/
  - source: cve@mitre.org
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/M3FQILX7UUEERSDPMZP3MKGTMY2E7ESU/
  - source: cve@mitre.org
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/WBUYGYXDQX3OSAYHP4TCG3JS7PJTIE75/
  title: Heap-based buffer overflow in sqbaselib.cpp in SQUIRREL 3.2 due to lack of
    a certain sq_reservestack call.
- diff_content:
  - "--- a/src/isomedia/avc_ext.c\n+++ b/src/isomedia/avc_ext.c\n@@ -3523,6 +3523,11\
    \ @@ GF_Err gf_isom_oinf_read_entry(void *entry, GF_BitStream *bs)\n \t\t\top->layers_info[j].layer_id\
    \ = gf_bs_read_int(bs, 6);\n \t\t\top->layers_info[j].is_outputlayer = gf_bs_read_int(bs,\
    \ 1) ? GF_TRUE : GF_FALSE;\n \t\t\top->layers_info[j].is_alternate_outputlayer\
    \ = gf_bs_read_int(bs, 1) ? GF_TRUE : GF_FALSE;\n+\n+\t\t\tif (gf_bs_is_overflow(bs))\
    \ {\n+\t\t\t\tgf_free(op);\n+\t\t\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n+\t\t\
    \t}\n \t\t}\n \t\top->minPicWidth = gf_bs_read_u16(bs);\n \t\top->minPicHeight\
    \ = gf_bs_read_u16(bs);\n@@ -3542,6 +3547,10 @@ GF_Err gf_isom_oinf_read_entry(void\
    \ *entry, GF_BitStream *bs)\n \t\t\top->maxBitRate = gf_bs_read_u32(bs);\n \t\t\
    \top->avgBitRate = gf_bs_read_u32(bs);\n \t\t}\n+\t\tif (gf_bs_is_overflow(bs))\
    \ {\n+\t\t\tgf_free(op);\n+\t\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n+\t\t}\n\
    \ \t\tgf_list_add(ptr->operating_points, op);\n \t}\n \tcount = gf_bs_read_u8(bs);\n\
    @@ -3561,6 +3570,10 @@ GF_Err gf_isom_oinf_read_entry(void *entry, GF_BitStream\
    \ *bs)\n \t\t\tif (ptr->scalability_mask & (1 << j))\n \t\t\t\tdep->dimension_identifier[j]\
    \ = gf_bs_read_u8(bs);\n \t\t}\n+\t\tif (gf_bs_is_overflow(bs)) {\n+\t\t\tgf_free(dep);\n\
    +\t\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n+\t\t}\n \t\tgf_list_add(ptr->dependency_layers,\
    \ dep);\n \t}\n "
  - "--- a/src/utils/bitstream.c\n+++ b/src/utils/bitstream.c\n@@ -375,9 +375,12 @@\
    \ static u8 BS_ReadByte(GF_BitStream *bs)\n \t\tbs_flush_write_cache(bs);\n \n\
    \ \tis_eos = gf_feof(bs->stream);\n+\t//cache not fully read, reset EOS\n+\tif\
    \ (bs->cache_read && (bs->cache_read_pos<bs->cache_read_size))\n+\t\tis_eos =\
    \ GF_FALSE;\n \n \t/*we are in FILE mode, test for end of file*/\n-\tif (!is_eos\
    \ || bs->cache_read) {\n+\tif (!is_eos) {\n \t\tu8 res;\n \t\tBool loc_eos=GF_FALSE;\n\
    \ \t\tassert(bs->position<=bs->size);\n@@ -408,7 +411,10 @@ static u8 BS_ReadByte(GF_BitStream\
    \ *bs)\n \t\tbs->EndOfStream(bs->par);\n \t\tif (!bs->overflow_state) bs->overflow_state\
    \ = 1;\n \t} else {\n-\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CORE, (\"[BS] Attempt to\
    \ overread bitstream\\n\"));\n+\t\tif (!bs->overflow_state) {\n+\t\t\tbs->overflow_state\
    \ = 1;\n+\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CORE, (\"[BS] Attempt to overread bitstream\\\
    n\"));\n+\t\t}\n \t}\n \tassert(bs->position <= 1+bs->size);\n \treturn 0;"
  identifiers:
  - CVE-2022-29339
  - CWE-617
  overview: In GPAC 2.1-DEV-rev87-g053aae8-master, function BS_ReadByte() in utils/bitstream.c
    has a failed assertion, which causes a Denial of Service. This vulnerability was
    fixed in commit 9ea93a2.
  references:
  - source: cve@mitre.org
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/gpac/gpac/commit/9ea93a2ec8f555ceed1ee27294cf94822f14f10f
  - source: cve@mitre.org
    tags:
    - Exploit
    - Issue Tracking
    - Third Party Advisory
    url: https://github.com/gpac/gpac/issues/2165
  title: In GPAC 2.1-DEV-rev87-g053aae8-master, function BS_ReadByte() in utils/bitstream.c
    has a failed assertion, which causes a Denial of Service. This vulnerability was
    fixed in commit 9ea93a2.
- diff_content:
  - "--- a/src/isomedia/box_funcs.c\n+++ b/src/isomedia/box_funcs.c\n@@ -310,8 +310,10\
    \ @@ GF_Err gf_isom_box_parse_ex(GF_Box **outBox, GF_BitStream *bs, u32 parent_type,\n\
    \ \tif (e && (e != GF_ISOM_INCOMPLETE_FILE)) {\n \t\tgf_isom_box_del(newBox);\n\
    \ \t\t*outBox = NULL;\n+\t\tif (is_root_box && (e==GF_SKIP_BOX))\n+\t\t\te = GF_ISOM_INVALID_FILE;\n\
    \ \n-\t\tif (!skip_logs) {\n+\t\tif (!skip_logs && (e!=GF_SKIP_BOX)) {\n \t\t\t\
    GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Read Box \\\"%s\\\" (start\
    \ \"LLU\") failed (%s) - skipping\\n\", gf_4cc_to_str(type), start, gf_error_to_string(e)));\n\
    \ \t\t}\n \t\t//we don't try to reparse known boxes that have been failing (too\
    \ dangerous)"
  - "--- a/src/isomedia/isom_intern.c\n+++ b/src/isomedia/isom_intern.c\n@@ -373,7\
    \ +373,8 @@ static GF_Err gf_isom_parse_movie_boxes_internal(GF_ISOFile *mov,\
    \ u32 *boxType,\n \t\te = gf_isom_parse_root_box(&a, mov->movieFileMap->bs, boxType,\
    \ bytesMissing, progressive_mode);\n \n \t\tif (e >= 0) {\n-\n+\t\t\t//safety\
    \ check, should never happen\n+\t\t\tif (!a) return GF_ISOM_INVALID_FILE;\n \t\
    \t} else if (e == GF_ISOM_INCOMPLETE_FILE) {\n \t\t\t/*our mdat is uncomplete,\
    \ only valid for READ ONLY files...*/\n \t\t\tif (mov->openMode != GF_ISOM_OPEN_READ)\
    \ {"
  identifiers:
  - CVE-2022-29340
  - CWE-476
  overview: GPAC 2.1-DEV-rev87-g053aae8-master. has a Null Pointer Dereference vulnerability
    in gf_isom_parse_movie_boxes_internal due to improper return value handling of
    GF_SKIP_BOX, which causes a Denial of Service. This vulnerability was fixed in
    commit 37592ad.
  references:
  - source: cve@mitre.org
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/gpac/gpac/commit/37592ad86c6ca934d34740012213e467acc4a3b0
  - source: cve@mitre.org
    tags:
    - Exploit
    - Issue Tracking
    - Third Party Advisory
    url: https://github.com/gpac/gpac/issues/2163
  title: GPAC 2.1-DEV-rev87-g053aae8-master. has a Null Pointer Dereference vulnerability
    in gf_isom_parse_movie_boxes_internal due to improper return value handling of
    GF_SKIP_BOX, which causes a Denial of Service. This vulnerability was fixed in
    commit 37592ad.
- diff_content:
  - "--- a/src/lib/ecdsa.c\n+++ b/src/lib/ecdsa.c\n@@ -135,6 +135,12 @@ void ecdsa_sign_legacy(ecdsa_signature_t\
    \ *signature, const ecc_int256_t *hash, c\n void ecdsa_verify_prepare_legacy(ecdsa_verify_context_t\
    \ *ctx, const ecc_int256_t *hash, const ecdsa_signature_t *signature) {\n   ecc_int256_t\
    \ w, u1, tmp;\n \n+  if (ecc_25519_gf_is_zero(&signature->s) || ecc_25519_gf_is_zero(&signature->r))\
    \ {\n+    // Signature is invalid, mark by setting ctx->r to an invalid value\n\
    +    memset(&ctx->r, 0, sizeof(ctx->r));\n+    return;\n+  }\n+\n   ctx->r = signature->r;\n\
    \ \n   ecc_25519_gf_recip(&w, &signature->s);\n@@ -149,6 +155,10 @@ bool ecdsa_verify_legacy(const\
    \ ecdsa_verify_context_t *ctx, const ecc_25519_work\n   ecc_25519_work_t s2, work;\n\
    \   ecc_int256_t w, tmp;\n \n+  // Signature was detected as invalid in prepare\
    \ step\n+  if (ecc_25519_gf_is_zero(&ctx->r))\n+    return false;\n+\n   ecc_25519_scalarmult(&s2,\
    \ &ctx->u2, pubkey);\n   ecc_25519_add(&work, &ctx->s1, &s2);\n   ecc_25519_store_xy_legacy(&w,\
    \ NULL, &work);"
  - "--- a/src/lib/ecdsa.c\n+++ b/src/lib/ecdsa.c\n@@ -135,6 +135,12 @@ void ecdsa_sign_legacy(ecdsa_signature_t\
    \ *signature, const ecc_int256_t *hash, c\n void ecdsa_verify_prepare_legacy(ecdsa_verify_context_t\
    \ *ctx, const ecc_int256_t *hash, const ecdsa_signature_t *signature) {\n   ecc_int256_t\
    \ w, u1, tmp;\n \n+  if (ecc_25519_gf_is_zero(&signature->s) || ecc_25519_gf_is_zero(&signature->r))\
    \ {\n+    // Signature is invalid, mark by setting ctx->r to an invalid value\n\
    +    memset(&ctx->r, 0, sizeof(ctx->r));\n+    return;\n+  }\n+\n   ctx->r = signature->r;\n\
    \ \n   ecc_25519_gf_recip(&w, &signature->s);\n@@ -149,6 +155,10 @@ bool ecdsa_verify_legacy(const\
    \ ecdsa_verify_context_t *ctx, const ecc_25519_work\n   ecc_25519_work_t s2, work;\n\
    \   ecc_int256_t w, tmp;\n \n+  // Signature was detected as invalid in prepare\
    \ step\n+  if (ecc_25519_gf_is_zero(&ctx->r))\n+    return false;\n+\n   ecc_25519_scalarmult(&s2,\
    \ &ctx->u2, pubkey);\n   ecc_25519_add(&work, &ctx->s1, &s2);\n   ecc_25519_store_xy_legacy(&w,\
    \ NULL, &work);"
  identifiers:
  - CVE-2022-24884
  - CWE-347
  overview: 'ecdsautils is a tiny collection of programs used for ECDSA (keygen, sign,
    verify). `ecdsa_verify_[prepare_]legacy()` does not check whether the signature
    values `r` and `s` are non-zero. A signature consisting only of zeroes is always
    considered valid, making it trivial to forge signatures. Requiring multiple signatures
    from different public keys does not mitigate the issue: `ecdsa_verify_list_legacy()`
    will accept an arbitrary number of such forged signatures. Both the `ecdsautil
    verify` CLI command and the libecdsautil library are affected. The issue has been
    fixed in ecdsautils 0.4.1. All older versions of ecdsautils (including versions
    before the split into a library and a CLI utility) are vulnerable.'
  references:
  - source: security-advisories@github.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/freifunk-gluon/ecdsautils/commit/1d4b091abdf15ad7b2312535b5b95ad70f6dbd08
  - source: security-advisories@github.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/freifunk-gluon/ecdsautils/commit/39b6d0a77414fd41614953a0e185c4eefa2f88ad
  - source: security-advisories@github.com
    tags:
    - Third Party Advisory
    url: https://github.com/freifunk-gluon/ecdsautils/security/advisories/GHSA-qhcg-9ffp-78pw
  - source: security-advisories@github.com
    tags:
    - Mailing List
    - Third Party Advisory
    url: https://lists.debian.org/debian-lts-announce/2022/05/msg00007.html
  - source: security-advisories@github.com
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/4AKQH5WCBMJA3ODCSNERY6HVX4BX3ITG/
  - source: security-advisories@github.com
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/G2JT57AAFIEL7JDO2ZBV25JKYME5NU54/
  - source: security-advisories@github.com
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/L7UBR3M4U3LA46BHXYSH7EN5GDG44GK7/
  - source: security-advisories@github.com
    tags:
    - Third Party Advisory
    url: https://www.debian.org/security/2022/dsa-5132
  title: 'ecdsautils is a tiny collection of programs used for ECDSA (keygen, sign,
    verify). `ecdsa_verify_[prepare_]legacy()` does not check whether the signature
    values `r` and `s` are non-zero. A signature consisting only of zeroes is always
    considered valid, making it trivial to forge signatures. Requiring multiple signatures
    from different public keys does not mitigate the issue: `ecdsa_verify_list_legacy()`
    will accept an arbitrary number of such forged signatures. Both the `ecdsautil
    verify` CLI command and the libecdsautil library are affected. The issue has been
    fixed in ecdsautils 0.4.1. All older versions of ecdsautils (including versions
    before the split into a library and a CLI utility) are vulnerable.'
- diff_content:
  - "--- a/lib/board/supervise.c\n+++ b/lib/board/supervise.c\n@@ -30,6 +30,63 @@\n\
    \ \n #ifndef EMULATOR\n \n+bool do_memory_ranges_overlap(size_t range1Start, size_t\
    \ range1End, size_t range2Start, size_t range2End) {\n+  if (range1Start <= range2Start)\
    \ {\n+    return range2Start < range1End;\n+  } else {\n+    return range1Start\
    \ < range2End;\n+  }\n+}\n+\n+bool allow_svhandler_flash_sector(const FlashSector*\
    \ sector) {\n+  return sector->use == FLASH_STORAGE1 ||\n+         sector->use\
    \ == FLASH_STORAGE2 ||\n+         sector->use == FLASH_STORAGE3 ||\n+        \
    \ sector->use == FLASH_UNUSED0 ||\n+         sector->use == FLASH_APP;\n+}\n+\n\
    +bool allow_svhandler_flash_sector_num(int sector) {\n+  for (const FlashSector\
    \ *s = flash_sector_map; s->use != FLASH_INVALID; s++) {\n+    if (s->sector ==\
    \ sector) return allow_svhandler_flash_sector(s);\n+  }\n+  return false;\n+}\n\
    +\n+bool allow_svhandler_flash_range(size_t start, size_t end) {\n+  // Protect\
    \ from overflow.\n+  if (start > end) return false;\n+\n+  // Disallow non-flash\
    \ writes.\n+  if (start < FLASH_ORIGIN || end > FLASH_END) return false;\n+\n\
    +  // Disallow writes to any sectors which aren't allowed.\n+  bool startAllowed\
    \ = false;\n+  bool endAllowed = false;\n+  for (const FlashSector* s = flash_sector_map;\
    \ s->use != FLASH_INVALID; s++) {\n+    if (allow_svhandler_flash_sector(s)) {\n\
    +      if (!startAllowed &&\n+          start + 1 > start &&\n+          do_memory_ranges_overlap(start,\
    \ start + 1, s->start, s->start + s->len)) {\n+        startAllowed = true;\n\
    +      }\n+      if (!endAllowed &&\n+          end - 1 < end &&\n+          do_memory_ranges_overlap(end\
    \ - 1, end, s->start, s->start + s->len)) {\n+        endAllowed = true;\n+  \
    \    }\n+    } else {\n+      if (do_memory_ranges_overlap(start, end, s->start,\
    \ s->start + s->len)) return false;\n+    }\n+  }\n+\n+  // Ensure writes start\
    \ and end in allowed sectors. As long as flash_sector_map consists of\n+  // contiguous\
    \ sectors, this will ensure no writes can target flash outside the map.\n+  if\
    \ (!startAllowed || !endAllowed) return false;\n+\n+  return true;\n+}\n+\n ///\
    \ Return context from user isr processing\n void svc_busr_return(void) {\n   __asm__\
    \ __volatile__(\"svc %0\" ::\"i\"(SVC_BUSR_RET) : \"memory\");\n@@ -76,13 +133,10\
    \ @@ bool svc_flash_pgm_word(uint32_t beginAddr, uint32_t data) {\n }\n \n void\
    \ svhandler_flash_erase_sector(void) {\n-  uint32_t sector = _param_1;\n+  uint8_t\
    \ sector = _param_1;\n \n-  // Do not allow firmware to erase bootstrap or bootloader\
    \ sectors.\n-  if ((sector == FLASH_BOOTSTRAP_SECTOR) ||\n-      (sector >= FLASH_BOOT_SECTOR_FIRST\
    \ && sector <= FLASH_BOOT_SECTOR_LAST)) {\n-    return;\n-  }\n+  // Verify requested\
    \ sector is allowed.\n+  if (!allow_svhandler_flash_sector_num(sector)) return;\n\
    \ \n   // Unlock flash.\n   flash_clear_status_flags();\n@@ -111,25 +165,8 @@\
    \ void svhandler_flash_pgm_blk(void) {\n   uint32_t data = _param_2;\n   uint32_t\
    \ length = _param_3;\n \n-  // Protect from overflow.\n-  if (beginAddr + length\
    \ < beginAddr) return;\n-\n-  // Do not allow firmware to erase bootstrap or bootloader\
    \ sectors.\n-  if (((beginAddr >= BSTRP_FLASH_SECT_START) &&\n-       (beginAddr\
    \ <= (BSTRP_FLASH_SECT_START + BSTRP_FLASH_SECT_LEN - 1))) ||\n-      (((beginAddr\
    \ + length) >= BSTRP_FLASH_SECT_START) &&\n-       ((beginAddr + length) <=\n\
    -        (BSTRP_FLASH_SECT_START + BSTRP_FLASH_SECT_LEN - 1)))) {\n-    return;\n\
    -  }\n-\n-  if (((beginAddr >= BLDR_FLASH_SECT_START) &&\n-       (beginAddr <=\
    \ (BLDR_FLASH_SECT_START + 2 * BLDR_FLASH_SECT_LEN - 1))) ||\n-      (((beginAddr\
    \ + length) >= BLDR_FLASH_SECT_START) &&\n-       ((beginAddr + length) <=\n-\
    \        (BLDR_FLASH_SECT_START + 2 * BLDR_FLASH_SECT_LEN - 1)))) {\n-    return;\n\
    -  }\n+  // Verify requested address range is allowed.\n+  if (!allow_svhandler_flash_range(beginAddr,\
    \ beginAddr + length)) return;\n \n   // Unlock flash.\n   flash_clear_status_flags();\n\
    @@ -157,16 +194,8 @@ void svhandler_flash_pgm_word(void) {\n   uint32_t dst =\
    \ _param_1;\n   uint32_t src = _param_2;\n \n-  // Do not allow firmware to erase\
    \ bootstrap or bootloader sectors.\n-  if ((dst >= BSTRP_FLASH_SECT_START) &&\n\
    -      (dst <= (BSTRP_FLASH_SECT_START + BSTRP_FLASH_SECT_LEN))) {\n-    return;\n\
    -  }\n-\n-  if ((dst >= BLDR_FLASH_SECT_START) &&\n-      (dst <= (BLDR_FLASH_SECT_START\
    \ + 2 * BLDR_FLASH_SECT_LEN))) {\n-    return;\n-  }\n+  // Verify requested address\
    \ range is allowed.\n+  if (!allow_svhandler_flash_range(dst, dst + sizeof(uint32_t)))\
    \ return;\n \n   // Unlock flash.\n   flash_clear_status_flags();"
  identifiers:
  - CVE-2022-30330
  - CWE-20
  overview: In the KeepKey firmware before 7.3.2,Flaws in the supervisor interface
    can be exploited to bypass important security restrictions on firmware operations.
    Using these flaws, malicious firmware code can elevate privileges, permanently
    make the device inoperable or overwrite the trusted bootloader code to compromise
    the hardware wallet across reboots or storage wipes.
  references:
  - source: cve@mitre.org
    tags:
    - Exploit
    - Patch
    - Third Party Advisory
    url: https://blog.inhq.net/posts/keepkey-CVE-2022-30330/
  - source: cve@mitre.org
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/keepkey/keepkey-firmware/commit/447c1f038a31378ab9589965c098467d9ea6cccc
  - source: cve@mitre.org
    tags:
    - Release Notes
    - Third Party Advisory
    url: https://github.com/keepkey/keepkey-firmware/releases/tag/v7.3.2
  title: In the KeepKey firmware before 7.3.2,Flaws in the supervisor interface can
    be exploited to bypass important security restrictions on firmware operations.
    Using these flaws, malicious firmware code can elevate privileges, permanently
    make the device inoperable or overwrite the trusted bootloader code to compromise
    the hardware wallet across reboots or storage wipes.
- diff_content:
  - "--- a/src/ex_docmd.c\n+++ b/src/ex_docmd.c\n@@ -3435,14 +3435,16 @@ append_command(char_u\
    \ *cmd)\n \n     STRCAT(IObuff, \": \");\n     d = IObuff + STRLEN(IObuff);\n\
    -    while (*s != NUL && d - IObuff < IOSIZE - 7)\n+    while (*s != NUL && d\
    \ - IObuff + 5 < IOSIZE)\n     {\n \tif (enc_utf8 ? (s[0] == 0xc2 && s[1] == 0xa0)\
    \ : *s == 0xa0)\n \t{\n \t    s += enc_utf8 ? 2 : 1;\n \t    STRCPY(d, \"<a0>\"\
    );\n \t    d += 4;\n \t}\n+\telse if (d - IObuff + (*mb_ptr2len)(s) + 1 >= IOSIZE)\n\
    +\t    break;\n \telse\n \t    MB_COPY_CHAR(s, d);\n     }"
  - "--- a/src/version.c\n+++ b/src/version.c\n@@ -746,6 +746,8 @@ static char *(features[])\
    \ =\n \n static int included_patches[] =\n {   /* Add new patch number below this\
    \ line */\n+/**/\n+    4895,\n /**/\n     4894,\n /**/"
  identifiers:
  - CVE-2022-1616
  - CWE-416
  overview: Use after free in append_command in GitHub repository vim/vim prior to
    8.2.4895. This vulnerability is capable of crashing software, Bypass Protection
    Mechanism, Modify Memory, and possible remote execution
  references:
  - source: security@huntr.dev
    tags:
    - Mailing List
    - Third Party Advisory
    url: http://seclists.org/fulldisclosure/2022/Oct/28
  - source: security@huntr.dev
    tags:
    - Mailing List
    - Release Notes
    - Third Party Advisory
    url: http://seclists.org/fulldisclosure/2022/Oct/41
  - source: security@huntr.dev
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/vim/vim/commit/d88934406c5375d88f8f1b65331c9f0cab68cc6c
  - source: security@huntr.dev
    tags:
    - Exploit
    - Patch
    - Third Party Advisory
    url: https://huntr.dev/bounties/40f1d75f-fb2f-4281-b585-a41017f217e2
  - source: security@huntr.dev
    tags:
    - Mailing List
    - Third Party Advisory
    url: https://lists.debian.org/debian-lts-announce/2022/05/msg00022.html
  - source: security@huntr.dev
    tags:
    - Mailing List
    - Third Party Advisory
    url: https://lists.debian.org/debian-lts-announce/2022/11/msg00009.html
  - source: security@huntr.dev
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/A6BY5P7ERZS7KXSBCGFCOXLMLGWUUJIH/
  - source: security@huntr.dev
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/HIP7KG7TVS5YF3QREAY2GOGUT3YUBZAI/
  - source: security@huntr.dev
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/JUN33257RUM4RS2I4GZETKFSAXPETATG/
  - source: security@huntr.dev
    tags:
    - Third Party Advisory
    url: https://security.gentoo.org/glsa/202208-32
  - source: security@huntr.dev
    url: https://security.gentoo.org/glsa/202305-16
  - source: security@huntr.dev
    tags:
    - Release Notes
    - Third Party Advisory
    url: https://support.apple.com/kb/HT213488
  title: Use after free in append_command in GitHub repository vim/vim prior to 8.2.4895.
    This vulnerability is capable of crashing software, Bypass Protection Mechanism,
    Modify Memory, and possible remote execution
- diff_content:
  - "--- a/src/ex_getln.c\n+++ b/src/ex_getln.c\n@@ -1082,10 +1082,13 @@ cmdline_erase_chars(\n\
    \ \t{\n \t    while (p > ccline.cmdbuff && vim_isspace(p[-1]))\n \t\t--p;\n-\t\
    \    i = vim_iswordc(p[-1]);\n-\t    while (p > ccline.cmdbuff && !vim_isspace(p[-1])\n\
    -\t\t    && vim_iswordc(p[-1]) == i)\n-\t\t--p;\n+\t    if (p > ccline.cmdbuff)\n\
    +\t    {\n+\t\ti = vim_iswordc(p[-1]);\n+\t\twhile (p > ccline.cmdbuff && !vim_isspace(p[-1])\n\
    +\t\t\t&& vim_iswordc(p[-1]) == i)\n+\t\t    --p;\n+\t    }\n \t}\n \telse\n \t\
    \    --p;"
  - "--- a/src/version.c\n+++ b/src/version.c\n@@ -746,6 +746,8 @@ static char *(features[])\
    \ =\n \n static int included_patches[] =\n {   /* Add new patch number below this\
    \ line */\n+/**/\n+    4899,\n /**/\n     4898,\n /**/"
  identifiers:
  - CVE-2022-1619
  - CWE-122
  overview: Heap-based Buffer Overflow in function cmdline_erase_chars in GitHub repository
    vim/vim prior to 8.2.4899. This vulnerabilities are capable of crashing software,
    modify memory, and possible remote execution
  references:
  - source: security@huntr.dev
    tags:
    - Mailing List
    - Third Party Advisory
    url: http://seclists.org/fulldisclosure/2022/Oct/28
  - source: security@huntr.dev
    tags:
    - Mailing List
    - Third Party Advisory
    url: http://seclists.org/fulldisclosure/2022/Oct/41
  - source: security@huntr.dev
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/vim/vim/commit/ef02f16609ff0a26ffc6e20263523424980898fe
  - source: security@huntr.dev
    tags:
    - Exploit
    - Third Party Advisory
    url: https://huntr.dev/bounties/b3200483-624e-4c76-a070-e246f62a7450
  - source: security@huntr.dev
    tags:
    - Mailing List
    - Third Party Advisory
    url: https://lists.debian.org/debian-lts-announce/2022/05/msg00022.html
  - source: security@huntr.dev
    tags:
    - Mailing List
    - Third Party Advisory
    url: https://lists.debian.org/debian-lts-announce/2022/11/msg00032.html
  - source: security@huntr.dev
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/A6BY5P7ERZS7KXSBCGFCOXLMLGWUUJIH/
  - source: security@huntr.dev
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/HIP7KG7TVS5YF3QREAY2GOGUT3YUBZAI/
  - source: security@huntr.dev
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/JUN33257RUM4RS2I4GZETKFSAXPETATG/
  - source: security@huntr.dev
    tags:
    - Third Party Advisory
    url: https://security.gentoo.org/glsa/202208-32
  - source: security@huntr.dev
    url: https://security.gentoo.org/glsa/202305-16
  - source: security@huntr.dev
    tags:
    - Third Party Advisory
    url: https://security.netapp.com/advisory/ntap-20220930-0007/
  - source: security@huntr.dev
    tags:
    - Vendor Advisory
    url: https://support.apple.com/kb/HT213488
  title: Heap-based Buffer Overflow in function cmdline_erase_chars in GitHub repository
    vim/vim prior to 8.2.4899. This vulnerabilities are capable of crashing software,
    modify memory, and possible remote execution
- diff_content:
  - "--- a/src/buffer.c\n+++ b/src/buffer.c\n@@ -2957,7 +2957,7 @@ fname_match(\n\
    \ \trmp->rm_ic = p_fic || ignore_case;\n \tif (vim_regexec(rmp, name, (colnr_T)0))\n\
    \ \t    match = name;\n-\telse\n+\telse if (rmp->regprog != NULL)\n \t{\n \t \
    \   // Replace $(HOME) with '~' and try matching again.\n \t    p = home_replace_save(NULL,\
    \ name);"
  - "--- a/src/version.c\n+++ b/src/version.c\n@@ -746,6 +746,8 @@ static char *(features[])\
    \ =\n \n static int included_patches[] =\n {   /* Add new patch number below this\
    \ line */\n+/**/\n+    4901,\n /**/\n     4900,\n /**/"
  identifiers:
  - CVE-2022-1620
  - CWE-476
  overview: NULL Pointer Dereference in function vim_regexec_string at regexp.c:2729
    in GitHub repository vim/vim prior to 8.2.4901. NULL Pointer Dereference in function
    vim_regexec_string at regexp.c:2729 allows attackers to cause a denial of service
    (application crash) via a crafted input.
  references:
  - source: security@huntr.dev
    url: http://seclists.org/fulldisclosure/2022/Oct/28
  - source: security@huntr.dev
    tags:
    - Mailing List
    - Third Party Advisory
    url: http://seclists.org/fulldisclosure/2022/Oct/41
  - source: security@huntr.dev
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/vim/vim/commit/8e4b76da1d7e987d43ca960dfbc372d1c617466f
  - source: security@huntr.dev
    tags:
    - Exploit
    - Third Party Advisory
    url: https://huntr.dev/bounties/7a4c59f3-fcc0-4496-995d-5ca6acd2da51
  - source: security@huntr.dev
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/A6BY5P7ERZS7KXSBCGFCOXLMLGWUUJIH/
  - source: security@huntr.dev
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/HIP7KG7TVS5YF3QREAY2GOGUT3YUBZAI/
  - source: security@huntr.dev
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/JUN33257RUM4RS2I4GZETKFSAXPETATG/
  - source: security@huntr.dev
    tags:
    - Third Party Advisory
    url: https://security.gentoo.org/glsa/202208-32
  - source: security@huntr.dev
    url: https://security.gentoo.org/glsa/202305-16
  - source: security@huntr.dev
    tags:
    - Third Party Advisory
    url: https://support.apple.com/kb/HT213488
  title: NULL Pointer Dereference in function vim_regexec_string at regexp.c:2729
    in GitHub repository vim/vim prior to 8.2.4901. NULL Pointer Dereference in function
    vim_regexec_string at regexp.c:2729 allows attackers to cause a denial of service
    (application crash) via a crafted input.
- diff_content:
  - "--- a/coders/cin.c\n+++ b/coders/cin.c\n@@ -451,6 +451,8 @@ static Image *ReadCINImage(const\
    \ ImageInfo *image_info,ExceptionInfo *exception)\n   image->endian=(magick[0]\
    \ == 0x80) && (magick[1] == 0x2a) &&\n     (magick[2] == 0x5f) && (magick[3] ==\
    \ 0xd7) ? MSBEndian : LSBEndian;\n   cin.file.image_offset=ReadBlobLong(image);\n\
    +  if (cin.file.image_offset < 712)\n+    ThrowReaderException(CorruptImageError,\"\
    ImproperImageHeader\");\n   offset+=4;\n   cin.file.generic_length=ReadBlobLong(image);\n\
    \   offset+=4;"
  - "--- a/coders/cin.c\n+++ b/coders/cin.c\n@@ -451,6 +451,8 @@ static Image *ReadCINImage(const\
    \ ImageInfo *image_info,ExceptionInfo *exception)\n   image->endian=(magick[0]\
    \ == 0x80) && (magick[1] == 0x2a) &&\n     (magick[2] == 0x5f) && (magick[3] ==\
    \ 0xd7) ? MSBEndian : LSBEndian;\n   cin.file.image_offset=ReadBlobLong(image);\n\
    +  if (cin.file.image_offset < 712)\n+    ThrowReaderException(CorruptImageError,\"\
    ImproperImageHeader\");\n   offset+=4;\n   cin.file.generic_length=ReadBlobLong(image);\n\
    \   offset+=4;"
  identifiers:
  - CVE-2022-28463
  - CWE-120
  overview: ImageMagick 7.1.0-27 is vulnerable to Buffer Overflow.
  references:
  - source: cve@mitre.org
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/ImageMagick/ImageMagick/commit/ca3654ebf7a439dc736f56f083c9aa98e4464b7f
  - source: cve@mitre.org
    tags:
    - Exploit
    - Issue Tracking
    - Third Party Advisory
    url: https://github.com/ImageMagick/ImageMagick/issues/4988
  - source: cve@mitre.org
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/ImageMagick/ImageMagick6/commit/e6ea5876e0228165ee3abc6e959aa174cee06680
  - source: cve@mitre.org
    tags:
    - Mailing List
    - Third Party Advisory
    url: https://lists.debian.org/debian-lts-announce/2022/05/msg00018.html
  - source: cve@mitre.org
    url: https://lists.debian.org/debian-lts-announce/2023/05/msg00020.html
  title: ImageMagick 7.1.0-27 is vulnerable to Buffer Overflow.
- diff_content:
  - "--- a/src/mbyte.c\n+++ b/src/mbyte.c\n@@ -4226,7 +4226,7 @@ utf_find_illegal(void)\n\
    \     convert_setup(&vimconv, NULL, NULL);\n }\n \n-#if defined(FEAT_GUI_GTK)\
    \ || defined(PROTO)\n+#if defined(FEAT_GUI_GTK) || defined(FEAT_SPELL) || defined(PROTO)\n\
    \ /*\n  * Return TRUE if string \"s\" is a valid utf-8 string.\n  * When \"end\"\
    \ is NULL stop at the first NUL."
  - "--- a/src/spellfile.c\n+++ b/src/spellfile.c\n@@ -4390,6 +4390,10 @@ store_word(\n\
    \     int\t\tres = OK;\n     char_u\t*p;\n \n+    // Avoid adding illegal bytes\
    \ to the word tree.\n+    if (enc_utf8 && !utf_valid_string(word, NULL))\n+\t\
    return FAIL;\n+\n     (void)spell_casefold(curwin, word, len, foldword, MAXWLEN);\n\
    \     for (p = pfxlist; res == OK; ++p)\n     {\n@@ -6190,6 +6194,12 @@ spell_add_word(\n\
    \     int\t\ti;\n     char_u\t*spf;\n \n+    if (enc_utf8 && !utf_valid_string(word,\
    \ NULL))\n+    {\n+\temsg(_(e_illegal_character_in_word));\n+\treturn;\n+    }\n\
    +\n     if (idx == 0)\t    // use internal wordlist\n     {\n \tif (int_wordlist\
    \ == NULL)"
  - "--- a/src/version.c\n+++ b/src/version.c\n@@ -746,6 +746,8 @@ static char *(features[])\
    \ =\n \n static int included_patches[] =\n {   /* Add new patch number below this\
    \ line */\n+/**/\n+    4919,\n /**/\n     4918,\n /**/"
  identifiers:
  - CVE-2022-1621
  - CWE-122
  overview: Heap buffer overflow in vim_strncpy find_word in GitHub repository vim/vim
    prior to 8.2.4919. This vulnerability is capable of crashing software, Bypass
    Protection Mechanism, Modify Memory, and possible remote execution
  references:
  - source: security@huntr.dev
    tags:
    - Mailing List
    - Third Party Advisory
    url: http://seclists.org/fulldisclosure/2022/Oct/28
  - source: security@huntr.dev
    tags:
    - Mailing List
    - Third Party Advisory
    url: http://seclists.org/fulldisclosure/2022/Oct/41
  - source: security@huntr.dev
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/vim/vim/commit/7c824682d2028432ee082703ef0ab399867a089b
  - source: security@huntr.dev
    tags:
    - Exploit
    - Third Party Advisory
    url: https://huntr.dev/bounties/520ce714-bfd2-4646-9458-f52cd22bb2fb
  - source: security@huntr.dev
    tags:
    - Mailing List
    - Third Party Advisory
    url: https://lists.debian.org/debian-lts-announce/2022/05/msg00022.html
  - source: security@huntr.dev
    tags:
    - Mailing List
    - Third Party Advisory
    url: https://lists.debian.org/debian-lts-announce/2022/11/msg00032.html
  - source: security@huntr.dev
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/HIP7KG7TVS5YF3QREAY2GOGUT3YUBZAI/
  - source: security@huntr.dev
    tags:
    - Third Party Advisory
    url: https://security.gentoo.org/glsa/202208-32
  - source: security@huntr.dev
    url: https://security.gentoo.org/glsa/202305-16
  - source: security@huntr.dev
    tags:
    - Third Party Advisory
    url: https://support.apple.com/kb/HT213488
  title: Heap buffer overflow in vim_strncpy find_word in GitHub repository vim/vim
    prior to 8.2.4919. This vulnerability is capable of crashing software, Bypass
    Protection Mechanism, Modify Memory, and possible remote execution
- diff_content:
  - "--- a/src/textobject.c\n+++ b/src/textobject.c\n@@ -1664,7 +1664,11 @@ find_next_quote(\n\
    \ \tif (c == NUL)\n \t    return -1;\n \telse if (escape != NULL && vim_strchr(escape,\
    \ c))\n+\t{\n \t    ++col;\n+\t    if (line[col] == NUL)\n+\t\treturn -1;\n+\t\
    }\n \telse if (c == quotechar)\n \t    break;\n \tif (has_mbyte)"
  - "--- a/src/version.c\n+++ b/src/version.c\n@@ -746,6 +746,8 @@ static char *(features[])\
    \ =\n \n static int included_patches[] =\n {   /* Add new patch number below this\
    \ line */\n+/**/\n+    4925,\n /**/\n     4924,\n /**/"
  identifiers:
  - CVE-2022-1629
  - CWE-126
  overview: Buffer Over-read in function find_next_quote in GitHub repository vim/vim
    prior to 8.2.4925. This vulnerabilities are capable of crashing software, Modify
    Memory, and possible remote execution
  references:
  - source: security@huntr.dev
    tags:
    - Mailing List
    - Third Party Advisory
    url: http://seclists.org/fulldisclosure/2022/Oct/28
  - source: security@huntr.dev
    tags:
    - Mailing List
    - Third Party Advisory
    url: http://seclists.org/fulldisclosure/2022/Oct/41
  - source: security@huntr.dev
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/vim/vim/commit/53a70289c2712808e6d4e88927e03cac01b470dd
  - source: security@huntr.dev
    tags:
    - Exploit
    - Third Party Advisory
    url: https://huntr.dev/bounties/e26d08d4-1886-41f0-9af4-f3e1bf3d52ee
  - source: security@huntr.dev
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/HIP7KG7TVS5YF3QREAY2GOGUT3YUBZAI/
  - source: security@huntr.dev
    tags:
    - Third Party Advisory
    url: https://security.gentoo.org/glsa/202208-32
  - source: security@huntr.dev
    tags:
    - Third Party Advisory
    url: https://security.gentoo.org/glsa/202305-16
  - source: security@huntr.dev
    tags:
    - Third Party Advisory
    url: https://support.apple.com/kb/HT213488
  title: Buffer Over-read in function find_next_quote in GitHub repository vim/vim
    prior to 8.2.4925. This vulnerabilities are capable of crashing software, Modify
    Memory, and possible remote execution
- diff_content:
  - "--- a/libr/bin/format/mach0/mach0.c\n+++ b/libr/bin/format/mach0/mach0.c\n@@\
    \ -4580,6 +4580,9 @@ void MACH0_(iterate_chained_fixups)(struct MACH0_(obj_t)\
    \ *bin, ut64 limit_start,\n \t\t\t\tif (page_idx >= bin->chained_starts[i]->page_count)\
    \ {\n \t\t\t\t\tbreak;\n \t\t\t\t}\n+\t\t\t\tif (!bin->chained_starts[i]->page_start)\
    \ {\n+\t\t\t\t\tbreak;\n+\t\t\t\t}\n \t\t\t\tut16 page_start = bin->chained_starts[i]->page_start[page_idx];\n\
    \ \t\t\t\tif (page_start == DYLD_CHAINED_PTR_START_NONE) {\n \t\t\t\t\tcontinue;"
  identifiers:
  - CVE-2022-1649
  - CWE-476
  overview: Null pointer dereference in libr/bin/format/mach0/mach0.c in radareorg/radare2
    in GitHub repository radareorg/radare2 prior to 5.7.0. It is likely to be exploitable.
    For more general description of heap buffer overflow, see [CWE](https://cwe.mitre.org/data/definitions/476.html).
  references:
  - source: security@huntr.dev
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/radareorg/radare2/commit/a5aafb99c3965259c84ddcf45a91144bf7eb4cf1
  - source: security@huntr.dev
    tags:
    - Exploit
    - Third Party Advisory
    url: https://huntr.dev/bounties/c07e4918-cf86-4d2e-8969-5fb63575b449
  title: Null pointer dereference in libr/bin/format/mach0/mach0.c in radareorg/radare2
    in GitHub repository radareorg/radare2 prior to 5.7.0. It is likely to be exploitable.
    For more general description of heap buffer overflow, see [CWE](https://cwe.mitre.org/data/definitions/476.html).
- diff_content:
  - "--- a/libtiff/tif_lzw.c\n+++ b/libtiff/tif_lzw.c\n@@ -140,6 +140,7 @@ typedef\
    \ struct {\n \tcode_t* dec_free_entp;\t\t/* next free entry */\n \tcode_t* dec_maxcodep;\t\
    \t/* max available entry */\n \tcode_t* dec_codetab;\t\t/* kept separate for small\
    \ machines */\n+\tint     read_error;         /* whether a read error has occured,\
    \ and which should cause further reads in the same strip/tile to be aborted */\n\
    \ \n \t/* Encoding specific data */\n \tint     enc_oldcode;\t\t/* last code encountered\
    \ */\n@@ -307,6 +308,7 @@ LZWPreDecode(TIFF* tif, uint16_t s)\n \t */\n \tsp->dec_oldcodep\
    \ = &sp->dec_codetab[0];\n \tsp->dec_maxcodep = &sp->dec_codetab[sp->dec_nbitsmask-1];\n\
    +\tsp->read_error = 0;\n \treturn (1);\n }\n \n@@ -399,7 +401,11 @@ LZWDecode(TIFF*\
    \ tif, uint8_t* op0, tmsize_t occ0, uint16_t s)\n \n \t(void) s;\n \tassert(sp\
    \ != NULL);\n-        assert(sp->dec_codetab != NULL);\n+\tassert(sp->dec_codetab\
    \ != NULL);\n+\n+\tif (sp->read_error) {\n+\t\treturn 0;\n+\t}\n \n \t/*\n \t\
    \ * Restart interrupted output operation.\n@@ -704,6 +710,7 @@ no_eoi:\n     \
    \                tif->tif_curstrip);\n     return 0;\n error_code:\n+    sp->read_error\
    \ = 1;\n     TIFFErrorExt(tif->tif_clientdata, tif->tif_name, \"Using code not\
    \ yet in table\");\n     return 0;\n }\n"
  identifiers:
  - CVE-2022-1622
  - CWE-125
  overview: LibTIFF master branch has an out-of-bounds read in LZWDecode in libtiff/tif_lzw.c:619,
    allowing attackers to cause a denial-of-service via a crafted tiff file. For users
    that compile libtiff from sources, the fix is available with commit b4e79bfa.
  references:
  - source: cve@gitlab.com
    url: http://seclists.org/fulldisclosure/2022/Oct/28
  - source: cve@gitlab.com
    url: http://seclists.org/fulldisclosure/2022/Oct/39
  - source: cve@gitlab.com
    tags:
    - Third Party Advisory
    url: http://seclists.org/fulldisclosure/2022/Oct/41
  - source: cve@gitlab.com
    tags:
    - Third Party Advisory
    url: https://gitlab.com/gitlab-org/cves/-/blob/master/2022/CVE-2022-1622.json
  - source: cve@gitlab.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://gitlab.com/libtiff/libtiff/-/commit/b4e79bfa0c7d2d08f6f1e7ec38143fc8cb11394a
  - source: cve@gitlab.com
    tags:
    - Exploit
    - Third Party Advisory
    url: https://gitlab.com/libtiff/libtiff/-/issues/410
  - source: cve@gitlab.com
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/C7IWZTB4J2N4F5OR5QY4VHDSKWKZSWN3/
  - source: cve@gitlab.com
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/UXAFOP6QQRNZD3HPZ6BMCEZZOM4YIZMK/
  - source: cve@gitlab.com
    tags:
    - Third Party Advisory
    url: https://security.netapp.com/advisory/ntap-20220616-0005/
  - source: cve@gitlab.com
    tags:
    - Release Notes
    - Third Party Advisory
    url: https://support.apple.com/kb/HT213443
  - source: cve@gitlab.com
    tags:
    - Release Notes
    - Third Party Advisory
    url: https://support.apple.com/kb/HT213444
  - source: cve@gitlab.com
    tags:
    - Release Notes
    - Third Party Advisory
    url: https://support.apple.com/kb/HT213446
  - source: cve@gitlab.com
    tags:
    - Release Notes
    - Third Party Advisory
    url: https://support.apple.com/kb/HT213486
  - source: cve@gitlab.com
    tags:
    - Release Notes
    - Third Party Advisory
    url: https://support.apple.com/kb/HT213487
  - source: cve@gitlab.com
    tags:
    - Release Notes
    - Third Party Advisory
    url: https://support.apple.com/kb/HT213488
  title: LibTIFF master branch has an out-of-bounds read in LZWDecode in libtiff/tif_lzw.c:619,
    allowing attackers to cause a denial-of-service via a crafted tiff file. For users
    that compile libtiff from sources, the fix is available with commit b4e79bfa.
- diff_content:
  - "--- a/libtiff/tif_lzw.c\n+++ b/libtiff/tif_lzw.c\n@@ -140,6 +140,7 @@ typedef\
    \ struct {\n \tcode_t* dec_free_entp;\t\t/* next free entry */\n \tcode_t* dec_maxcodep;\t\
    \t/* max available entry */\n \tcode_t* dec_codetab;\t\t/* kept separate for small\
    \ machines */\n+\tint     read_error;         /* whether a read error has occured,\
    \ and which should cause further reads in the same strip/tile to be aborted */\n\
    \ \n \t/* Encoding specific data */\n \tint     enc_oldcode;\t\t/* last code encountered\
    \ */\n@@ -307,6 +308,7 @@ LZWPreDecode(TIFF* tif, uint16_t s)\n \t */\n \tsp->dec_oldcodep\
    \ = &sp->dec_codetab[0];\n \tsp->dec_maxcodep = &sp->dec_codetab[sp->dec_nbitsmask-1];\n\
    +\tsp->read_error = 0;\n \treturn (1);\n }\n \n@@ -399,7 +401,11 @@ LZWDecode(TIFF*\
    \ tif, uint8_t* op0, tmsize_t occ0, uint16_t s)\n \n \t(void) s;\n \tassert(sp\
    \ != NULL);\n-        assert(sp->dec_codetab != NULL);\n+\tassert(sp->dec_codetab\
    \ != NULL);\n+\n+\tif (sp->read_error) {\n+\t\treturn 0;\n+\t}\n \n \t/*\n \t\
    \ * Restart interrupted output operation.\n@@ -704,6 +710,7 @@ no_eoi:\n     \
    \                tif->tif_curstrip);\n     return 0;\n error_code:\n+    sp->read_error\
    \ = 1;\n     TIFFErrorExt(tif->tif_clientdata, tif->tif_name, \"Using code not\
    \ yet in table\");\n     return 0;\n }\n"
  identifiers:
  - CVE-2022-1623
  - CWE-125
  overview: LibTIFF master branch has an out-of-bounds read in LZWDecode in libtiff/tif_lzw.c:624,
    allowing attackers to cause a denial-of-service via a crafted tiff file. For users
    that compile libtiff from sources, the fix is available with commit b4e79bfa.
  references:
  - source: cve@gitlab.com
    tags:
    - Third Party Advisory
    url: https://gitlab.com/gitlab-org/cves/-/blob/master/2022/CVE-2022-1623.json
  - source: cve@gitlab.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://gitlab.com/libtiff/libtiff/-/commit/b4e79bfa0c7d2d08f6f1e7ec38143fc8cb11394a
  - source: cve@gitlab.com
    tags:
    - Exploit
    - Third Party Advisory
    url: https://gitlab.com/libtiff/libtiff/-/issues/410
  - source: cve@gitlab.com
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/C7IWZTB4J2N4F5OR5QY4VHDSKWKZSWN3/
  - source: cve@gitlab.com
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/UXAFOP6QQRNZD3HPZ6BMCEZZOM4YIZMK/
  - source: cve@gitlab.com
    tags:
    - Third Party Advisory
    url: https://security.gentoo.org/glsa/202210-10
  - source: cve@gitlab.com
    tags:
    - Third Party Advisory
    url: https://security.netapp.com/advisory/ntap-20220616-0005/
  - source: cve@gitlab.com
    tags:
    - Third Party Advisory
    url: https://www.debian.org/security/2023/dsa-5333
  title: LibTIFF master branch has an out-of-bounds read in LZWDecode in libtiff/tif_lzw.c:624,
    allowing attackers to cause a denial-of-service via a crafted tiff file. For users
    that compile libtiff from sources, the fix is available with commit b4e79bfa.
- diff_content:
  - "--- a/bin/duck_client.c\n+++ b/bin/duck_client.c\n@@ -1,4 +1,4 @@\n-/* Copyright\
    \ (c) 2017 - 2021 LiteSpeed Technologies Inc.  See LICENSE. */\n+/* Copyright\
    \ (c) 2017 - 2022 LiteSpeed Technologies Inc.  See LICENSE. */\n /*\n  * duck_client.c\
    \ -- The siduck client.  See\n  *      https://tools.ietf.org/html/draft-pardue-quic-siduck-00"
  - "--- a/bin/duck_server.c\n+++ b/bin/duck_server.c\n@@ -1,4 +1,4 @@\n-/* Copyright\
    \ (c) 2017 - 2021 LiteSpeed Technologies Inc.  See LICENSE. */\n+/* Copyright\
    \ (c) 2017 - 2022 LiteSpeed Technologies Inc.  See LICENSE. */\n /*\n  * A duck\
    \ quacks!  The server for the siduck protocol:\n  *      https://tools.ietf.org/html/draft-pardue-quic-siduck-00"
  - "--- a/bin/echo_client.c\n+++ b/bin/echo_client.c\n@@ -1,4 +1,4 @@\n-/* Copyright\
    \ (c) 2017 - 2021 LiteSpeed Technologies Inc.  See LICENSE. */\n+/* Copyright\
    \ (c) 2017 - 2022 LiteSpeed Technologies Inc.  See LICENSE. */\n /*\n  * echo_client.c\
    \ -- This is really a \"line client:\" it connects to QUIC server\n  * and sends\
    \ it stuff, line by line.  It works in tandem with echo_server."
  - "--- a/bin/echo_server.c\n+++ b/bin/echo_server.c\n@@ -1,4 +1,4 @@\n-/* Copyright\
    \ (c) 2017 - 2021 LiteSpeed Technologies Inc.  See LICENSE. */\n+/* Copyright\
    \ (c) 2017 - 2022 LiteSpeed Technologies Inc.  See LICENSE. */\n /*\n  * echo_server.c\
    \ -- QUIC server that echoes back input line by line\n  */"
  - "--- a/bin/http_client.c\n+++ b/bin/http_client.c\n@@ -1,4 +1,4 @@\n-/* Copyright\
    \ (c) 2017 - 2021 LiteSpeed Technologies Inc.  See LICENSE. */\n+/* Copyright\
    \ (c) 2017 - 2022 LiteSpeed Technologies Inc.  See LICENSE. */\n /*\n  * http_client.c\
    \ -- A simple HTTP/QUIC client\n  */"
  - "--- a/bin/http_server.c\n+++ b/bin/http_server.c\n@@ -1,4 +1,4 @@\n-/* Copyright\
    \ (c) 2017 - 2021 LiteSpeed Technologies Inc.  See LICENSE. */\n+/* Copyright\
    \ (c) 2017 - 2022 LiteSpeed Technologies Inc.  See LICENSE. */\n /*\n  * http_server.c\
    \ -- A simple HTTP/QUIC server\n  *"
  - "--- a/bin/md5_client.c\n+++ b/bin/md5_client.c\n@@ -1,4 +1,4 @@\n-/* Copyright\
    \ (c) 2017 - 2021 LiteSpeed Technologies Inc.  See LICENSE. */\n+/* Copyright\
    \ (c) 2017 - 2022 LiteSpeed Technologies Inc.  See LICENSE. */\n /*\n  * md5_client.c\
    \ -- This client sends one or more files to MD5 QUIC server\n  *             \
    \    for MD5 sum calculation."
  - "--- a/bin/md5_server.c\n+++ b/bin/md5_server.c\n@@ -1,4 +1,4 @@\n-/* Copyright\
    \ (c) 2017 - 2021 LiteSpeed Technologies Inc.  See LICENSE. */\n+/* Copyright\
    \ (c) 2017 - 2022 LiteSpeed Technologies Inc.  See LICENSE. */\n /*\n  * md5_server.c\
    \ -- Read one or more streams from the client and return\n  *                \
    \ MD5 sum of the payload."
  - "--- a/bin/perf_client.c\n+++ b/bin/perf_client.c\n@@ -1,4 +1,4 @@\n-/* Copyright\
    \ (c) 2017 - 2021 LiteSpeed Technologies Inc.  See LICENSE. */\n+/* Copyright\
    \ (c) 2017 - 2022 LiteSpeed Technologies Inc.  See LICENSE. */\n /*\n  * perf_client.c\
    \ -- Implements the \"perf\" client, see\n  *      https://tools.ietf.org/html/draft-banks-quic-performance-00"
  - "--- a/bin/perf_server.c\n+++ b/bin/perf_server.c\n@@ -1,4 +1,4 @@\n-/* Copyright\
    \ (c) 2017 - 2021 LiteSpeed Technologies Inc.  See LICENSE. */\n+/* Copyright\
    \ (c) 2017 - 2022 LiteSpeed Technologies Inc.  See LICENSE. */\n /*\n  * perf_server.c\
    \ -- Implements the \"perf\" server, see\n  *      https://tools.ietf.org/html/draft-banks-quic-performance-00"
  - "--- a/bin/prog.c\n+++ b/bin/prog.c\n@@ -1,4 +1,4 @@\n-/* Copyright (c) 2017 -\
    \ 2021 LiteSpeed Technologies Inc.  See LICENSE. */\n+/* Copyright (c) 2017 -\
    \ 2022 LiteSpeed Technologies Inc.  See LICENSE. */\n #include <assert.h>\n #ifndef\
    \ WIN32\n #include <arpa/inet.h>"
  - "--- a/bin/test_cert.c\n+++ b/bin/test_cert.c\n@@ -1,4 +1,4 @@\n-/* Copyright\
    \ (c) 2017 - 2021 LiteSpeed Technologies Inc.  See LICENSE. */\n+/* Copyright\
    \ (c) 2017 - 2022 LiteSpeed Technologies Inc.  See LICENSE. */\n #include <errno.h>\n\
    \ #include <stdio.h>\n #include <stdlib.h>"
  - "--- a/bin/test_common.c\n+++ b/bin/test_common.c\n@@ -1,4 +1,4 @@\n-/* Copyright\
    \ (c) 2017 - 2021 LiteSpeed Technologies Inc.  See LICENSE. */\n+/* Copyright\
    \ (c) 2017 - 2022 LiteSpeed Technologies Inc.  See LICENSE. */\n #if __GNUC__\n\
    \ #define _GNU_SOURCE     /* For struct in6_pktinfo */\n #endif"
  - "--- a/src/liblsquic/common_cert_set_2.c\n+++ b/src/liblsquic/common_cert_set_2.c\n\
    @@ -1,4 +1,4 @@\n-/* Copyright (c) 2017 - 2021 LiteSpeed Technologies Inc.  See\
    \ LICENSE. */\n+/* Copyright (c) 2017 - 2022 LiteSpeed Technologies Inc.  See\
    \ LICENSE. */\n /* Copyright (c) 2015 The Chromium Authors. All rights reserved.\n\
    \  * Use of this source code is governed by a BSD-style license that can be\n\
    \  * found in the LICENSE.chrome file."
  - "--- a/src/liblsquic/common_cert_set_3.c\n+++ b/src/liblsquic/common_cert_set_3.c\n\
    @@ -1,4 +1,4 @@\n-/* Copyright (c) 2017 - 2021 LiteSpeed Technologies Inc.  See\
    \ LICENSE. */\n+/* Copyright (c) 2017 - 2022 LiteSpeed Technologies Inc.  See\
    \ LICENSE. */\n /* Copyright (c) 2015 The Chromium Authors. All rights reserved.\n\
    \  * Use of this source code is governed by a BSD-style license that can be\n\
    \  * found in the LICENSE.chrome file."
  - "--- a/src/liblsquic/ls-sfparser.c\n+++ b/src/liblsquic/ls-sfparser.c\n@@ -1,4\
    \ +1,4 @@\n-/* Copyright (c) 2017 - 2021 LiteSpeed Technologies Inc.  See LICENSE.\
    \ */\n+/* Copyright (c) 2017 - 2022 LiteSpeed Technologies Inc.  See LICENSE.\
    \ */\n #line 2 \"ls-sfparser.c\"\n #line 2 \"ls-sfparser.l\"\n /*"
  - "--- a/src/liblsquic/lsquic_adaptive_cc.c\n+++ b/src/liblsquic/lsquic_adaptive_cc.c\n\
    @@ -1,4 +1,4 @@\n-/* Copyright (c) 2017 - 2021 LiteSpeed Technologies Inc.  See\
    \ LICENSE. */\n+/* Copyright (c) 2017 - 2022 LiteSpeed Technologies Inc.  See\
    \ LICENSE. */\n /* lsquic_adaptive_cc.c -- adaptive congestion controller */\n\
    \ \n #include <inttypes.h>"
  - "--- a/src/liblsquic/lsquic_alarmset.c\n+++ b/src/liblsquic/lsquic_alarmset.c\n\
    @@ -1,4 +1,4 @@\n-/* Copyright (c) 2017 - 2021 LiteSpeed Technologies Inc.  See\
    \ LICENSE. */\n+/* Copyright (c) 2017 - 2022 LiteSpeed Technologies Inc.  See\
    \ LICENSE. */\n /*\n  * lsquic_alarmset.c -- A set of alarms\n  */"
  - "--- a/src/liblsquic/lsquic_arr.c\n+++ b/src/liblsquic/lsquic_arr.c\n@@ -1,4 +1,4\
    \ @@\n-/* Copyright (c) 2017 - 2021 LiteSpeed Technologies Inc.  See LICENSE.\
    \ */\n+/* Copyright (c) 2017 - 2022 LiteSpeed Technologies Inc.  See LICENSE.\
    \ */\n /*\n  * lsquic_arr.c\n  */"
  - "--- a/src/liblsquic/lsquic_attq.c\n+++ b/src/liblsquic/lsquic_attq.c\n@@ -1,4\
    \ +1,4 @@\n-/* Copyright (c) 2017 - 2021 LiteSpeed Technologies Inc.  See LICENSE.\
    \ */\n+/* Copyright (c) 2017 - 2022 LiteSpeed Technologies Inc.  See LICENSE.\
    \ */\n /*\n  * lsquic_attq.c -- Advisory Tick Time Queue\n  *"
  - "--- a/src/liblsquic/lsquic_bbr.c\n+++ b/src/liblsquic/lsquic_bbr.c\n@@ -1,4 +1,4\
    \ @@\n-/* Copyright (c) 2017 - 2021 LiteSpeed Technologies Inc.  See LICENSE.\
    \ */\n+/* Copyright (c) 2017 - 2022 LiteSpeed Technologies Inc.  See LICENSE.\
    \ */\n // Copyright 2016 The Chromium Authors. All rights reserved.\n // Use of\
    \ this source code is governed by a BSD-style license that can be\n // found in\
    \ the LICENSE.chrome file."
  - "--- a/src/liblsquic/lsquic_bw_sampler.c\n+++ b/src/liblsquic/lsquic_bw_sampler.c\n\
    @@ -1,4 +1,4 @@\n-/* Copyright (c) 2017 - 2021 LiteSpeed Technologies Inc.  See\
    \ LICENSE. */\n+/* Copyright (c) 2017 - 2022 LiteSpeed Technologies Inc.  See\
    \ LICENSE. */\n #include <assert.h>\n #include <inttypes.h>\n #include <stddef.h>"
  - "--- a/src/liblsquic/lsquic_cfcw.c\n+++ b/src/liblsquic/lsquic_cfcw.c\n@@ -1,4\
    \ +1,4 @@\n-/* Copyright (c) 2017 - 2021 LiteSpeed Technologies Inc.  See LICENSE.\
    \ */\n+/* Copyright (c) 2017 - 2022 LiteSpeed Technologies Inc.  See LICENSE.\
    \ */\n #include <inttypes.h>\n #include <stdint.h>\n #include <stdlib.h>"
  - "--- a/src/liblsquic/lsquic_chsk_stream.c\n+++ b/src/liblsquic/lsquic_chsk_stream.c\n\
    @@ -1,4 +1,4 @@\n-/* Copyright (c) 2017 - 2021 LiteSpeed Technologies Inc.  See\
    \ LICENSE. */\n+/* Copyright (c) 2017 - 2022 LiteSpeed Technologies Inc.  See\
    \ LICENSE. */\n /*\n  * Stream/crypto handshake adapter for the client side.\n\
    \  *"
  - "--- a/src/liblsquic/lsquic_conn.c\n+++ b/src/liblsquic/lsquic_conn.c\n@@ -1,4\
    \ +1,4 @@\n-/* Copyright (c) 2017 - 2021 LiteSpeed Technologies Inc.  See LICENSE.\
    \ */\n+/* Copyright (c) 2017 - 2022 LiteSpeed Technologies Inc.  See LICENSE.\
    \ */\n #include <assert.h>\n #include <inttypes.h>\n #include <string.h>"
  - "--- a/src/liblsquic/lsquic_crand.c\n+++ b/src/liblsquic/lsquic_crand.c\n@@ -1,4\
    \ +1,4 @@\n-/* Copyright (c) 2017 - 2021 LiteSpeed Technologies Inc.  See LICENSE.\
    \ */\n+/* Copyright (c) 2017 - 2022 LiteSpeed Technologies Inc.  See LICENSE.\
    \ */\n #include <openssl/rand.h>\n #include <stdint.h>\n "
  - "--- a/src/liblsquic/lsquic_crt_compress.c\n+++ b/src/liblsquic/lsquic_crt_compress.c\n\
    @@ -1,4 +1,4 @@\n-/* Copyright (c) 2017 - 2021 LiteSpeed Technologies Inc.  See\
    \ LICENSE. */\n+/* Copyright (c) 2017 - 2022 LiteSpeed Technologies Inc.  See\
    \ LICENSE. */\n #include <assert.h>\n #include <stdbool.h>\n #include <string.h>"
  - "--- a/src/liblsquic/lsquic_crypto.c\n+++ b/src/liblsquic/lsquic_crypto.c\n@@\
    \ -1,4 +1,4 @@\n-/* Copyright (c) 2017 - 2021 LiteSpeed Technologies Inc.  See\
    \ LICENSE. */\n+/* Copyright (c) 2017 - 2022 LiteSpeed Technologies Inc.  See\
    \ LICENSE. */\n #include <assert.h>\n #include <string.h>\n "
  - "--- a/src/liblsquic/lsquic_cubic.c\n+++ b/src/liblsquic/lsquic_cubic.c\n@@ -1,4\
    \ +1,4 @@\n-/* Copyright (c) 2017 - 2021 LiteSpeed Technologies Inc.  See LICENSE.\
    \ */\n+/* Copyright (c) 2017 - 2022 LiteSpeed Technologies Inc.  See LICENSE.\
    \ */\n /*\n  * lsquic_cubic.c -- LSQUIC CUBIC implementation.\n  */"
  - "--- a/src/liblsquic/lsquic_di_error.c\n+++ b/src/liblsquic/lsquic_di_error.c\n\
    @@ -1,4 +1,4 @@\n-/* Copyright (c) 2017 - 2021 LiteSpeed Technologies Inc.  See\
    \ LICENSE. */\n+/* Copyright (c) 2017 - 2022 LiteSpeed Technologies Inc.  See\
    \ LICENSE. */\n /*\n  * lsquic_di_error.c -- A placeholder when things go wrong\n\
    \  *"
  - "--- a/src/liblsquic/lsquic_di_hash.c\n+++ b/src/liblsquic/lsquic_di_hash.c\n\
    @@ -1,4 +1,4 @@\n-/* Copyright (c) 2017 - 2021 LiteSpeed Technologies Inc.  See\
    \ LICENSE. */\n+/* Copyright (c) 2017 - 2022 LiteSpeed Technologies Inc.  See\
    \ LICENSE. */\n /*\n  * lsquic_di_hash.c -- Copy incoming data into a hash\n \
    \ *"
  - "--- a/src/liblsquic/lsquic_di_nocopy.c\n+++ b/src/liblsquic/lsquic_di_nocopy.c\n\
    @@ -1,4 +1,4 @@\n-/* Copyright (c) 2017 - 2021 LiteSpeed Technologies Inc.  See\
    \ LICENSE. */\n+/* Copyright (c) 2017 - 2022 LiteSpeed Technologies Inc.  See\
    \ LICENSE. */\n /*\n  * lsquic_di_nocopy.c -- The \"no-copy\" data in stream.\n\
    \  *"
  - "--- a/src/liblsquic/lsquic_enc_sess_common.c\n+++ b/src/liblsquic/lsquic_enc_sess_common.c\n\
    @@ -1,4 +1,4 @@\n-/* Copyright (c) 2017 - 2021 LiteSpeed Technologies Inc.  See\
    \ LICENSE. */\n+/* Copyright (c) 2017 - 2022 LiteSpeed Technologies Inc.  See\
    \ LICENSE. */\n #include <stddef.h>\n #include <stdint.h>\n #include <string.h>"
  - "--- a/src/liblsquic/lsquic_enc_sess_ietf.c\n+++ b/src/liblsquic/lsquic_enc_sess_ietf.c\n\
    @@ -1,4 +1,4 @@\n-/* Copyright (c) 2017 - 2021 LiteSpeed Technologies Inc.  See\
    \ LICENSE. */\n+/* Copyright (c) 2017 - 2022 LiteSpeed Technologies Inc.  See\
    \ LICENSE. */\n /*\n  * lsquic_enc_sess_ietf.c -- Crypto session for IETF QUIC\n\
    \  */"
  - "--- a/src/liblsquic/lsquic_eng_hist.c\n+++ b/src/liblsquic/lsquic_eng_hist.c\n\
    @@ -1,4 +1,4 @@\n-/* Copyright (c) 2017 - 2021 LiteSpeed Technologies Inc.  See\
    \ LICENSE. */\n+/* Copyright (c) 2017 - 2022 LiteSpeed Technologies Inc.  See\
    \ LICENSE. */\n #include <time.h>\n #ifdef WIN32\n #include <vc_compat.h>"
  - "--- a/src/liblsquic/lsquic_engine.c\n+++ b/src/liblsquic/lsquic_engine.c\n@@\
    \ -1,4 +1,4 @@\n-/* Copyright (c) 2017 - 2021 LiteSpeed Technologies Inc.  See\
    \ LICENSE. */\n+/* Copyright (c) 2017 - 2022 LiteSpeed Technologies Inc.  See\
    \ LICENSE. */\n /*\n  * lsquic_engine.c - QUIC engine\n  */"
  - "--- a/src/liblsquic/lsquic_ev_log.c\n+++ b/src/liblsquic/lsquic_ev_log.c\n@@\
    \ -1,4 +1,4 @@\n-/* Copyright (c) 2017 - 2021 LiteSpeed Technologies Inc.  See\
    \ LICENSE. */\n+/* Copyright (c) 2017 - 2022 LiteSpeed Technologies Inc.  See\
    \ LICENSE. */\n #ifndef WIN32\n #include <arpa/inet.h>\n #else"
  - "--- a/src/liblsquic/lsquic_frab_list.c\n+++ b/src/liblsquic/lsquic_frab_list.c\n\
    @@ -1,4 +1,4 @@\n-/* Copyright (c) 2017 - 2021 LiteSpeed Technologies Inc.  See\
    \ LICENSE. */\n+/* Copyright (c) 2017 - 2022 LiteSpeed Technologies Inc.  See\
    \ LICENSE. */\n /*\n  * lsquic_frab_list.c -- List of buffer for simple reading\
    \ and writing\n  */"
  - "--- a/src/liblsquic/lsquic_frame_common.c\n+++ b/src/liblsquic/lsquic_frame_common.c\n\
    @@ -1,4 +1,4 @@\n-/* Copyright (c) 2017 - 2021 LiteSpeed Technologies Inc.  See\
    \ LICENSE. */\n+/* Copyright (c) 2017 - 2022 LiteSpeed Technologies Inc.  See\
    \ LICENSE. */\n #include <stdint.h>\n \n #include \"lsquic_frame_common.h\""
  - "--- a/src/liblsquic/lsquic_frame_reader.c\n+++ b/src/liblsquic/lsquic_frame_reader.c\n\
    @@ -1,4 +1,4 @@\n-/* Copyright (c) 2017 - 2021 LiteSpeed Technologies Inc.  See\
    \ LICENSE. */\n+/* Copyright (c) 2017 - 2022 LiteSpeed Technologies Inc.  See\
    \ LICENSE. */\n /*\n  * lsquic_frame_reader.c -- Read HTTP frames from stream\n\
    \  */"
  - "--- a/src/liblsquic/lsquic_frame_writer.c\n+++ b/src/liblsquic/lsquic_frame_writer.c\n\
    @@ -1,4 +1,4 @@\n-/* Copyright (c) 2017 - 2021 LiteSpeed Technologies Inc.  See\
    \ LICENSE. */\n+/* Copyright (c) 2017 - 2022 LiteSpeed Technologies Inc.  See\
    \ LICENSE. */\n /*\n  * lsquic_frame_writer.c -- write frames to HEADERS stream.\n\
    \  *"
  - "--- a/src/liblsquic/lsquic_full_conn.c\n+++ b/src/liblsquic/lsquic_full_conn.c\n\
    @@ -1,4 +1,4 @@\n-/* Copyright (c) 2017 - 2021 LiteSpeed Technologies Inc.  See\
    \ LICENSE. */\n+/* Copyright (c) 2017 - 2022 LiteSpeed Technologies Inc.  See\
    \ LICENSE. */\n /*\n  * lsquic_full_conn.c -- A \"full\" connection object has\
    \ full functionality\n  */"
  - "--- a/src/liblsquic/lsquic_full_conn_ietf.c\n+++ b/src/liblsquic/lsquic_full_conn_ietf.c\n\
    @@ -1,4 +1,4 @@\n-/* Copyright (c) 2017 - 2021 LiteSpeed Technologies Inc.  See\
    \ LICENSE. */\n+/* Copyright (c) 2017 - 2022 LiteSpeed Technologies Inc.  See\
    \ LICENSE. */\n /*\n  * lsquic_full_conn_ietf.c -- IETF QUIC connection.\n  */"
  - "--- a/src/liblsquic/lsquic_global.c\n+++ b/src/liblsquic/lsquic_global.c\n@@\
    \ -1,4 +1,4 @@\n-/* Copyright (c) 2017 - 2021 LiteSpeed Technologies Inc.  See\
    \ LICENSE. */\n+/* Copyright (c) 2017 - 2022 LiteSpeed Technologies Inc.  See\
    \ LICENSE. */\n /*\n  * Global state\n  */"
  - "--- a/src/liblsquic/lsquic_handshake.c\n+++ b/src/liblsquic/lsquic_handshake.c\n\
    @@ -1,4 +1,4 @@\n-/* Copyright (c) 2017 - 2021 LiteSpeed Technologies Inc.  See\
    \ LICENSE. */\n+/* Copyright (c) 2017 - 2022 LiteSpeed Technologies Inc.  See\
    \ LICENSE. */\n #define _GNU_SOURCE         /* for memmem */\n \n #include <assert.h>"
  - "--- a/src/liblsquic/lsquic_hash.c\n+++ b/src/liblsquic/lsquic_hash.c\n@@ -1,4\
    \ +1,4 @@\n-/* Copyright (c) 2017 - 2021 LiteSpeed Technologies Inc.  See LICENSE.\
    \ */\n+/* Copyright (c) 2017 - 2022 LiteSpeed Technologies Inc.  See LICENSE.\
    \ */\n /*\n  * lsquic_hash.c\n  */"
  - "--- a/src/liblsquic/lsquic_hcsi_reader.c\n+++ b/src/liblsquic/lsquic_hcsi_reader.c\n\
    @@ -1,4 +1,4 @@\n-/* Copyright (c) 2017 - 2021 LiteSpeed Technologies Inc.  See\
    \ LICENSE. */\n+/* Copyright (c) 2017 - 2022 LiteSpeed Technologies Inc.  See\
    \ LICENSE. */\n #include <assert.h>\n #include <inttypes.h>\n #include <stddef.h>"
  - "--- a/src/liblsquic/lsquic_hcso_writer.c\n+++ b/src/liblsquic/lsquic_hcso_writer.c\n\
    @@ -1,4 +1,4 @@\n-/* Copyright (c) 2017 - 2021 LiteSpeed Technologies Inc.  See\
    \ LICENSE. */\n+/* Copyright (c) 2017 - 2022 LiteSpeed Technologies Inc.  See\
    \ LICENSE. */\n /*\n  * lsquic_hcso_writer.c - write to outgoing HTTP Control\
    \ Stream\n  */"
  - "--- a/src/liblsquic/lsquic_headers_stream.c\n+++ b/src/liblsquic/lsquic_headers_stream.c\n\
    @@ -1,4 +1,4 @@\n-/* Copyright (c) 2017 - 2021 LiteSpeed Technologies Inc.  See\
    \ LICENSE. */\n+/* Copyright (c) 2017 - 2022 LiteSpeed Technologies Inc.  See\
    \ LICENSE. */\n /*\n  * HEADERS stream logic\n  */"
  - "--- a/src/liblsquic/lsquic_hkdf.c\n+++ b/src/liblsquic/lsquic_hkdf.c\n@@ -1,4\
    \ +1,4 @@\n-/* Copyright (c) 2017 - 2021 LiteSpeed Technologies Inc.  See LICENSE.\
    \ */\n+/* Copyright (c) 2017 - 2022 LiteSpeed Technologies Inc.  See LICENSE.\
    \ */\n #include <assert.h>\n #include <stddef.h>\n #include <string.h>"
  - "--- a/src/liblsquic/lsquic_hpi.c\n+++ b/src/liblsquic/lsquic_hpi.c\n@@ -1,4 +1,4\
    \ @@\n-/* Copyright (c) 2017 - 2021 LiteSpeed Technologies Inc.  See LICENSE.\
    \ */\n+/* Copyright (c) 2017 - 2022 LiteSpeed Technologies Inc.  See LICENSE.\
    \ */\n /*\n  * lsquic_hpi.c - implementation of (Extensible) HTTP Priority Iterator.\n\
    \  */"
  - "--- a/src/liblsquic/lsquic_hspack_valid.c\n+++ b/src/liblsquic/lsquic_hspack_valid.c\n\
    @@ -1,4 +1,4 @@\n-/* Copyright (c) 2017 - 2021 LiteSpeed Technologies Inc.  See\
    \ LICENSE. */\n+/* Copyright (c) 2017 - 2022 LiteSpeed Technologies Inc.  See\
    \ LICENSE. */\n /*\n  * lsquic_hspack_valid.c -- Handshake packet validator.\n\
    \  *"
  - "--- a/src/liblsquic/lsquic_http.c\n+++ b/src/liblsquic/lsquic_http.c\n@@ -1,4\
    \ +1,4 @@\n-/* Copyright (c) 2017 - 2021 LiteSpeed Technologies Inc.  See LICENSE.\
    \ */\n+/* Copyright (c) 2017 - 2022 LiteSpeed Technologies Inc.  See LICENSE.\
    \ */\n /* Various HTTP-related functions. */\n \n #include <stddef.h>"
  - "--- a/src/liblsquic/lsquic_http1x_if.c\n+++ b/src/liblsquic/lsquic_http1x_if.c\n\
    @@ -1,4 +1,4 @@\n-/* Copyright (c) 2017 - 2021 LiteSpeed Technologies Inc.  See\
    \ LICENSE. */\n+/* Copyright (c) 2017 - 2022 LiteSpeed Technologies Inc.  See\
    \ LICENSE. */\n #include <assert.h>\n #include <ctype.h>\n #include <stddef.h>"
  - "--- a/src/liblsquic/lsquic_logger.c\n+++ b/src/liblsquic/lsquic_logger.c\n@@\
    \ -1,4 +1,4 @@\n-/* Copyright (c) 2017 - 2021 LiteSpeed Technologies Inc.  See\
    \ LICENSE. */\n+/* Copyright (c) 2017 - 2022 LiteSpeed Technologies Inc.  See\
    \ LICENSE. */\n /*\n  * LSQUIC Logger implementation.\n  */"
  - "--- a/src/liblsquic/lsquic_malo.c\n+++ b/src/liblsquic/lsquic_malo.c\n@@ -1,4\
    \ +1,4 @@\n-/* Copyright (c) 2017 - 2021 LiteSpeed Technologies Inc.  See LICENSE.\
    \ */\n+/* Copyright (c) 2017 - 2022 LiteSpeed Technologies Inc.  See LICENSE.\
    \ */\n /*\n  * lsquic_malo.c -- malo allocator implementation.\n  *"
  - "--- a/src/liblsquic/lsquic_min_heap.c\n+++ b/src/liblsquic/lsquic_min_heap.c\n\
    @@ -1,4 +1,4 @@\n-/* Copyright (c) 2017 - 2021 LiteSpeed Technologies Inc.  See\
    \ LICENSE. */\n+/* Copyright (c) 2017 - 2022 LiteSpeed Technologies Inc.  See\
    \ LICENSE. */\n /*\n  * lsquic_min_heap.c\n  */"
  - "--- a/src/liblsquic/lsquic_mini_conn.c\n+++ b/src/liblsquic/lsquic_mini_conn.c\n\
    @@ -1,4 +1,4 @@\n-/* Copyright (c) 2017 - 2021 LiteSpeed Technologies Inc.  See\
    \ LICENSE. */\n+/* Copyright (c) 2017 - 2022 LiteSpeed Technologies Inc.  See\
    \ LICENSE. */\n /*\n  * lsquic_mini_conn.c -- Mini connection.\n  *"
  - "--- a/src/liblsquic/lsquic_mini_conn_ietf.c\n+++ b/src/liblsquic/lsquic_mini_conn_ietf.c\n\
    @@ -1,4 +1,4 @@\n-/* Copyright (c) 2017 - 2021 LiteSpeed Technologies Inc.  See\
    \ LICENSE. */\n+/* Copyright (c) 2017 - 2022 LiteSpeed Technologies Inc.  See\
    \ LICENSE. */\n /*\n  * lsquic_mini_conn_ietf.c -- Mini connection used by the\
    \ IETF QUIC\n  */"
  - "--- a/src/liblsquic/lsquic_minmax.c\n+++ b/src/liblsquic/lsquic_minmax.c\n@@\
    \ -1,4 +1,4 @@\n-/* Copyright (c) 2017 - 2021 LiteSpeed Technologies Inc.  See\
    \ LICENSE. */\n+/* Copyright (c) 2017 - 2022 LiteSpeed Technologies Inc.  See\
    \ LICENSE. */\n /*\n  * Based on Google code released under BSD license here:\n\
    \  *  https://groups.google.com/forum/#!topic/bbr-dev/3RTgkzi5ZD8"
  - "--- a/src/liblsquic/lsquic_mm.c\n+++ b/src/liblsquic/lsquic_mm.c\n@@ -1,4 +1,4\
    \ @@\n-/* Copyright (c) 2017 - 2021 LiteSpeed Technologies Inc.  See LICENSE.\
    \ */\n+/* Copyright (c) 2017 - 2022 LiteSpeed Technologies Inc.  See LICENSE.\
    \ */\n /*\n  * lsquic_mm.c -- Memory manager.\n  */"
  - "--- a/src/liblsquic/lsquic_pacer.c\n+++ b/src/liblsquic/lsquic_pacer.c\n@@ -1,4\
    \ +1,4 @@\n-/* Copyright (c) 2017 - 2021 LiteSpeed Technologies Inc.  See LICENSE.\
    \ */\n+/* Copyright (c) 2017 - 2022 LiteSpeed Technologies Inc.  See LICENSE.\
    \ */\n #include <assert.h>\n #include <inttypes.h>\n #include <stdint.h>"
  - "--- a/src/liblsquic/lsquic_packet_common.c\n+++ b/src/liblsquic/lsquic_packet_common.c\n\
    @@ -1,4 +1,4 @@\n-/* Copyright (c) 2017 - 2021 LiteSpeed Technologies Inc.  See\
    \ LICENSE. */\n+/* Copyright (c) 2017 - 2022 LiteSpeed Technologies Inc.  See\
    \ LICENSE. */\n /*\n  * lsquic_packet_common.c -- some common packet-related routines\n\
    \  */"
  - "--- a/src/liblsquic/lsquic_packet_gquic.c\n+++ b/src/liblsquic/lsquic_packet_gquic.c\n\
    @@ -1,4 +1,4 @@\n-/* Copyright (c) 2017 - 2021 LiteSpeed Technologies Inc.  See\
    \ LICENSE. */\n+/* Copyright (c) 2017 - 2022 LiteSpeed Technologies Inc.  See\
    \ LICENSE. */\n #include <stdint.h>\n #include <stdlib.h>\n "
  - "--- a/src/liblsquic/lsquic_packet_in.c\n+++ b/src/liblsquic/lsquic_packet_in.c\n\
    @@ -1,4 +1,4 @@\n-/* Copyright (c) 2017 - 2021 LiteSpeed Technologies Inc.  See\
    \ LICENSE. */\n+/* Copyright (c) 2017 - 2022 LiteSpeed Technologies Inc.  See\
    \ LICENSE. */\n #include <assert.h>\n #include <stdint.h>\n #include <string.h>"
  - "--- a/src/liblsquic/lsquic_packet_out.c\n+++ b/src/liblsquic/lsquic_packet_out.c\n\
    @@ -1,4 +1,4 @@\n-/* Copyright (c) 2017 - 2021 LiteSpeed Technologies Inc.  See\
    \ LICENSE. */\n+/* Copyright (c) 2017 - 2022 LiteSpeed Technologies Inc.  See\
    \ LICENSE. */\n /*\n  * lsquic_packet_out.c\n  */"
  - "--- a/src/liblsquic/lsquic_packet_resize.c\n+++ b/src/liblsquic/lsquic_packet_resize.c\n\
    @@ -1,4 +1,4 @@\n-/* Copyright (c) 2017 - 2021 LiteSpeed Technologies Inc.  See\
    \ LICENSE. */\n+/* Copyright (c) 2017 - 2022 LiteSpeed Technologies Inc.  See\
    \ LICENSE. */\n /* Functions to resize packets */\n \n #include <assert.h>"
  - "--- a/src/liblsquic/lsquic_parse_Q046.c\n+++ b/src/liblsquic/lsquic_parse_Q046.c\n\
    @@ -1,4 +1,4 @@\n-/* Copyright (c) 2017 - 2021 LiteSpeed Technologies Inc.  See\
    \ LICENSE. */\n+/* Copyright (c) 2017 - 2022 LiteSpeed Technologies Inc.  See\
    \ LICENSE. */\n /*\n  * lsquic_parse_Q046.c -- Parsing functions specific to GQUIC\
    \ Q046\n  */"
  - "--- a/src/liblsquic/lsquic_parse_Q050.c\n+++ b/src/liblsquic/lsquic_parse_Q050.c\n\
    @@ -1,4 +1,4 @@\n-/* Copyright (c) 2017 - 2021 LiteSpeed Technologies Inc.  See\
    \ LICENSE. */\n+/* Copyright (c) 2017 - 2022 LiteSpeed Technologies Inc.  See\
    \ LICENSE. */\n /*\n  * lsquic_parse_Q050.c -- Parsing functions specific to GQUIC\
    \ Q050\n  */"
  - "--- a/src/liblsquic/lsquic_parse_common.c\n+++ b/src/liblsquic/lsquic_parse_common.c\n\
    @@ -1,4 +1,4 @@\n-/* Copyright (c) 2017 - 2021 LiteSpeed Technologies Inc.  See\
    \ LICENSE. */\n+/* Copyright (c) 2017 - 2022 LiteSpeed Technologies Inc.  See\
    \ LICENSE. */\n #include <assert.h>\n #include <string.h>\n #include <sys/queue.h>"
  - "--- a/src/liblsquic/lsquic_parse_gquic_be.c\n+++ b/src/liblsquic/lsquic_parse_gquic_be.c\n\
    @@ -1,4 +1,4 @@\n-/* Copyright (c) 2017 - 2021 LiteSpeed Technologies Inc.  See\
    \ LICENSE. */\n+/* Copyright (c) 2017 - 2022 LiteSpeed Technologies Inc.  See\
    \ LICENSE. */\n /*\n  * lsquic_parse_gquic_be.c -- Parsing functions specific\
    \ to big-endian\n  *                              (now only Q043) GQUIC."
  - "--- a/src/liblsquic/lsquic_parse_gquic_common.c\n+++ b/src/liblsquic/lsquic_parse_gquic_common.c\n\
    @@ -1,4 +1,4 @@\n-/* Copyright (c) 2017 - 2021 LiteSpeed Technologies Inc.  See\
    \ LICENSE. */\n+/* Copyright (c) 2017 - 2022 LiteSpeed Technologies Inc.  See\
    \ LICENSE. */\n /*\n  * lsquic_parse_gquic_common.c -- Parsing functions common\
    \ to GQUIC\n  */"
  - "--- a/src/liblsquic/lsquic_parse_ietf_v1.c\n+++ b/src/liblsquic/lsquic_parse_ietf_v1.c\n\
    @@ -1,4 +1,4 @@\n-/* Copyright (c) 2017 - 2021 LiteSpeed Technologies Inc.  See\
    \ LICENSE. */\n+/* Copyright (c) 2017 - 2022 LiteSpeed Technologies Inc.  See\
    \ LICENSE. */\n /*\n  * lsquic_parse_ietf_v1.c -- Parsing functions specific to\
    \ IETF QUIC v1\n  */"
  - "--- a/src/liblsquic/lsquic_parse_iquic_common.c\n+++ b/src/liblsquic/lsquic_parse_iquic_common.c\n\
    @@ -1,4 +1,4 @@\n-/* Copyright (c) 2017 - 2021 LiteSpeed Technologies Inc.  See\
    \ LICENSE. */\n+/* Copyright (c) 2017 - 2022 LiteSpeed Technologies Inc.  See\
    \ LICENSE. */\n /*\n  * Parsing routines shared by all IETF QUIC versions.\n \
    \ */"
  - "--- a/src/liblsquic/lsquic_pr_queue.c\n+++ b/src/liblsquic/lsquic_pr_queue.c\n\
    @@ -1,4 +1,4 @@\n-/* Copyright (c) 2017 - 2021 LiteSpeed Technologies Inc.  See\
    \ LICENSE. */\n+/* Copyright (c) 2017 - 2022 LiteSpeed Technologies Inc.  See\
    \ LICENSE. */\n /*\n  * lsquic_pr_queue.c -- packet request queue.\n  */"
  - "--- a/src/liblsquic/lsquic_purga.c\n+++ b/src/liblsquic/lsquic_purga.c\n@@ -1,4\
    \ +1,4 @@\n-/* Copyright (c) 2017 - 2021 LiteSpeed Technologies Inc.  See LICENSE.\
    \ */\n+/* Copyright (c) 2017 - 2022 LiteSpeed Technologies Inc.  See LICENSE.\
    \ */\n #include <errno.h>\n #include <inttypes.h>\n #include <stddef.h>"
  - "--- a/src/liblsquic/lsquic_qdec_hdl.c\n+++ b/src/liblsquic/lsquic_qdec_hdl.c\n\
    @@ -1,4 +1,4 @@\n-/* Copyright (c) 2017 - 2021 LiteSpeed Technologies Inc.  See\
    \ LICENSE. */\n+/* Copyright (c) 2017 - 2022 LiteSpeed Technologies Inc.  See\
    \ LICENSE. */\n /*\n  * lsquic_qdec_hdl.c -- QPACK decoder streams handler\n \
    \ */"
  - "--- a/src/liblsquic/lsquic_qenc_hdl.c\n+++ b/src/liblsquic/lsquic_qenc_hdl.c\n\
    @@ -1,4 +1,4 @@\n-/* Copyright (c) 2017 - 2021 LiteSpeed Technologies Inc.  See\
    \ LICENSE. */\n+/* Copyright (c) 2017 - 2022 LiteSpeed Technologies Inc.  See\
    \ LICENSE. */\n /*\n  * lsquic_qenc_hdl.c -- QPACK encoder streams handler\n \
    \ */\n@@ -34,6 +34,7 @@\n #define LSQUIC_LOG_CONN_ID lsquic_conn_log_cid(qeh->qeh_conn)\n\
    \ #include \"lsquic_logger.h\"\n \n+#define QENC_MIN_DYN_TABLE_SIZE 32u\n \n static\
    \ int\n qeh_write_type (struct qpack_enc_hdl *qeh)\n@@ -123,6 +124,8 @@ lsquic_qeh_settings\
    \ (struct qpack_enc_hdl *qeh, unsigned max_table_size,\n     enc_opts = LSQPACK_ENC_OPT_STAGE_2\n\
    \              | (server ? LSQPACK_ENC_OPT_SERVER : 0);\n     qeh->qeh_tsu_sz\
    \ = sizeof(qeh->qeh_tsu_buf);\n+    if (QENC_MIN_DYN_TABLE_SIZE > dyn_table_size)\n\
    +        dyn_table_size = 0;\n     if (0 != lsqpack_enc_init(&qeh->qeh_encoder,\
    \ (void *) qeh->qeh_conn,\n                 max_table_size, dyn_table_size, max_risked_streams,\
    \ enc_opts,\n                 qeh->qeh_tsu_buf, &qeh->qeh_tsu_sz))"
  - "--- a/src/liblsquic/lsquic_qlog.c\n+++ b/src/liblsquic/lsquic_qlog.c\n@@ -1,4\
    \ +1,4 @@\n-/* Copyright (c) 2017 - 2021 LiteSpeed Technologies Inc.  See LICENSE.\
    \ */\n+/* Copyright (c) 2017 - 2022 LiteSpeed Technologies Inc.  See LICENSE.\
    \ */\n #include <stdlib.h>\n #include <stdio.h>\n #include <errno.h>"
  - "--- a/src/liblsquic/lsquic_qpack_exp.c\n+++ b/src/liblsquic/lsquic_qpack_exp.c\n\
    @@ -1,4 +1,4 @@\n-/* Copyright (c) 2017 - 2021 LiteSpeed Technologies Inc.  See\
    \ LICENSE. */\n+/* Copyright (c) 2017 - 2022 LiteSpeed Technologies Inc.  See\
    \ LICENSE. */\n #include <inttypes.h>\n #include <stdio.h>\n #include <stdlib.h>"
  - "--- a/src/liblsquic/lsquic_rechist.c\n+++ b/src/liblsquic/lsquic_rechist.c\n\
    @@ -1,4 +1,4 @@\n-/* Copyright (c) 2017 - 2021 LiteSpeed Technologies Inc.  See\
    \ LICENSE. */\n+/* Copyright (c) 2017 - 2022 LiteSpeed Technologies Inc.  See\
    \ LICENSE. */\n /*\n  * lsquic_rechist.c -- History of received packets.\n  */"
  - "--- a/src/liblsquic/lsquic_rtt.c\n+++ b/src/liblsquic/lsquic_rtt.c\n@@ -1,4 +1,4\
    \ @@\n-/* Copyright (c) 2017 - 2021 LiteSpeed Technologies Inc.  See LICENSE.\
    \ */\n+/* Copyright (c) 2017 - 2022 LiteSpeed Technologies Inc.  See LICENSE.\
    \ */\n /*\n  * lsquic_rtt.c -- RTT calculation\n  */"
  - "--- a/src/liblsquic/lsquic_send_ctl.c\n+++ b/src/liblsquic/lsquic_send_ctl.c\n\
    @@ -1,4 +1,4 @@\n-/* Copyright (c) 2017 - 2021 LiteSpeed Technologies Inc.  See\
    \ LICENSE. */\n+/* Copyright (c) 2017 - 2022 LiteSpeed Technologies Inc.  See\
    \ LICENSE. */\n /*\n  * lsquic_send_ctl.c -- Logic for sending and sent packets\n\
    \  */"
  - "--- a/src/liblsquic/lsquic_senhist.c\n+++ b/src/liblsquic/lsquic_senhist.c\n\
    @@ -1,4 +1,4 @@\n-/* Copyright (c) 2017 - 2021 LiteSpeed Technologies Inc.  See\
    \ LICENSE. */\n+/* Copyright (c) 2017 - 2022 LiteSpeed Technologies Inc.  See\
    \ LICENSE. */\n /*\n  * lsquic_senhist.c -- Sent history implementation\n  */"
  - "--- a/src/liblsquic/lsquic_set.c\n+++ b/src/liblsquic/lsquic_set.c\n@@ -1,4 +1,4\
    \ @@\n-/* Copyright (c) 2017 - 2021 LiteSpeed Technologies Inc.  See LICENSE.\
    \ */\n+/* Copyright (c) 2017 - 2022 LiteSpeed Technologies Inc.  See LICENSE.\
    \ */\n /*\n  * lsquic_set.c -- A set implementation.\n  *"
  - "--- a/src/liblsquic/lsquic_sfcw.c\n+++ b/src/liblsquic/lsquic_sfcw.c\n@@ -1,4\
    \ +1,4 @@\n-/* Copyright (c) 2017 - 2021 LiteSpeed Technologies Inc.  See LICENSE.\
    \ */\n+/* Copyright (c) 2017 - 2022 LiteSpeed Technologies Inc.  See LICENSE.\
    \ */\n #include <inttypes.h>\n #include <stdint.h>\n #include <stdlib.h>"
  - "--- a/src/liblsquic/lsquic_shsk_stream.c\n+++ b/src/liblsquic/lsquic_shsk_stream.c\n\
    @@ -1,4 +1,4 @@\n-/* Copyright (c) 2017 - 2021 LiteSpeed Technologies Inc.  See\
    \ LICENSE. */\n+/* Copyright (c) 2017 - 2022 LiteSpeed Technologies Inc.  See\
    \ LICENSE. */\n /*\n  * Stream/crypto handshake adapter for the server side. \
    \ Since on the server\n  * side, the handshake logic is handled in mini conn,\
    \ this adapter does not"
  - "--- a/src/liblsquic/lsquic_spi.c\n+++ b/src/liblsquic/lsquic_spi.c\n@@ -1,4 +1,4\
    \ @@\n-/* Copyright (c) 2017 - 2021 LiteSpeed Technologies Inc.  See LICENSE.\
    \ */\n+/* Copyright (c) 2017 - 2022 LiteSpeed Technologies Inc.  See LICENSE.\
    \ */\n /*\n  * lsquic_spi.c - implementation of Stream Priority Iterator.\n  */"
  - "--- a/src/liblsquic/lsquic_stock_shi.c\n+++ b/src/liblsquic/lsquic_stock_shi.c\n\
    @@ -1,4 +1,4 @@\n-/* Copyright (c) 2017 - 2021 LiteSpeed Technologies Inc.  See\
    \ LICENSE. */\n+/* Copyright (c) 2017 - 2022 LiteSpeed Technologies Inc.  See\
    \ LICENSE. */\n /*\n  * lsquic_stock_shi.c\n  */"
  - "--- a/src/liblsquic/lsquic_str.c\n+++ b/src/liblsquic/lsquic_str.c\n@@ -1,4 +1,4\
    \ @@\n-/* Copyright (c) 2017 - 2021 LiteSpeed Technologies Inc.  See LICENSE.\
    \ */\n+/* Copyright (c) 2017 - 2022 LiteSpeed Technologies Inc.  See LICENSE.\
    \ */\n /*\n  * lsquic_str.c\n  *"
  - "--- a/src/liblsquic/lsquic_stream.c\n+++ b/src/liblsquic/lsquic_stream.c\n@@\
    \ -1,4 +1,4 @@\n-/* Copyright (c) 2017 - 2021 LiteSpeed Technologies Inc.  See\
    \ LICENSE. */\n+/* Copyright (c) 2017 - 2022 LiteSpeed Technologies Inc.  See\
    \ LICENSE. */\n /*\n  * lsquic_stream.c -- stream processing\n  */"
  - "--- a/src/liblsquic/lsquic_tokgen.c\n+++ b/src/liblsquic/lsquic_tokgen.c\n@@\
    \ -1,4 +1,4 @@\n-/* Copyright (c) 2017 - 2021 LiteSpeed Technologies Inc.  See\
    \ LICENSE. */\n+/* Copyright (c) 2017 - 2022 LiteSpeed Technologies Inc.  See\
    \ LICENSE. */\n #include <assert.h>\n #include <stddef.h>\n #include <stdlib.h>"
  - "--- a/src/liblsquic/lsquic_trans_params.c\n+++ b/src/liblsquic/lsquic_trans_params.c\n\
    @@ -1,4 +1,4 @@\n-/* Copyright (c) 2017 - 2021 LiteSpeed Technologies Inc.  See\
    \ LICENSE. */\n+/* Copyright (c) 2017 - 2022 LiteSpeed Technologies Inc.  See\
    \ LICENSE. */\n /*\n  * lsquic_trans_params.c\n  */"
  - "--- a/src/liblsquic/lsquic_trechist.c\n+++ b/src/liblsquic/lsquic_trechist.c\n\
    @@ -1,4 +1,4 @@\n-/* Copyright (c) 2017 - 2021 LiteSpeed Technologies Inc.  See\
    \ LICENSE. */\n+/* Copyright (c) 2017 - 2022 LiteSpeed Technologies Inc.  See\
    \ LICENSE. */\n #include <assert.h>\n #include <limits.h>\n #include <stddef.h>"
  - "--- a/src/liblsquic/lsquic_util.c\n+++ b/src/liblsquic/lsquic_util.c\n@@ -1,4\
    \ +1,4 @@\n-/* Copyright (c) 2017 - 2021 LiteSpeed Technologies Inc.  See LICENSE.\
    \ */\n+/* Copyright (c) 2017 - 2022 LiteSpeed Technologies Inc.  See LICENSE.\
    \ */\n /*\n  * Utility functions\n  */"
  - "--- a/src/liblsquic/lsquic_varint.c\n+++ b/src/liblsquic/lsquic_varint.c\n@@\
    \ -1,4 +1,4 @@\n-/* Copyright (c) 2017 - 2021 LiteSpeed Technologies Inc.  See\
    \ LICENSE. */\n+/* Copyright (c) 2017 - 2022 LiteSpeed Technologies Inc.  See\
    \ LICENSE. */\n /*\n  * lsquic_varint.c -- routines dealing with IETF QUIC varint.\n\
    \  */"
  - "--- a/src/liblsquic/lsquic_version.c\n+++ b/src/liblsquic/lsquic_version.c\n\
    @@ -1,4 +1,4 @@\n-/* Copyright (c) 2017 - 2021 LiteSpeed Technologies Inc.  See\
    \ LICENSE. */\n+/* Copyright (c) 2017 - 2022 LiteSpeed Technologies Inc.  See\
    \ LICENSE. */\n #include <string.h>\n \n #include \"lsquic.h\""
  - "--- a/src/liblsquic/lsquic_xxhash.c\n+++ b/src/liblsquic/lsquic_xxhash.c\n@@\
    \ -1,4 +1,4 @@\n-/* Copyright (c) 2017 - 2021 LiteSpeed Technologies Inc.  See\
    \ LICENSE. */\n+/* Copyright (c) 2017 - 2022 LiteSpeed Technologies Inc.  See\
    \ LICENSE. */\n /*\n xxHash - Fast Hash algorithm\n Copyright (C) 2012-2014, Yann\
    \ Collet."
  - "--- a/tests/graph_cubic.c\n+++ b/tests/graph_cubic.c\n@@ -1,4 +1,4 @@\n-/* Copyright\
    \ (c) 2017 - 2021 LiteSpeed Technologies Inc.  See LICENSE. */\n+/* Copyright\
    \ (c) 2017 - 2022 LiteSpeed Technologies Inc.  See LICENSE. */\n /*\n  * This\
    \ is not really a test: this program prints out cwnd histogram\n  * for visual\
    \ inspection."
  - "--- a/tests/mini_parse.c\n+++ b/tests/mini_parse.c\n@@ -1,4 +1,4 @@\n-/* Copyright\
    \ (c) 2017 - 2021 LiteSpeed Technologies Inc.  See LICENSE. */\n+/* Copyright\
    \ (c) 2017 - 2022 LiteSpeed Technologies Inc.  See LICENSE. */\n /*\n  * Convert\
    \ from our hexdump format to binary:\n  *"
  - "--- a/tests/test_ack.c\n+++ b/tests/test_ack.c\n@@ -1,4 +1,4 @@\n-/* Copyright\
    \ (c) 2017 - 2021 LiteSpeed Technologies Inc.  See LICENSE. */\n+/* Copyright\
    \ (c) 2017 - 2022 LiteSpeed Technologies Inc.  See LICENSE. */\n /* Test both\
    \ generation and parsing of IETF ACK frames */\n \n #include <assert.h>"
  - "--- a/tests/test_ack_merge.c\n+++ b/tests/test_ack_merge.c\n@@ -1,4 +1,4 @@\n\
    -/* Copyright (c) 2017 - 2021 LiteSpeed Technologies Inc.  See LICENSE. */\n+/*\
    \ Copyright (c) 2017 - 2022 LiteSpeed Technologies Inc.  See LICENSE. */\n /*\
    \ Test ACK merge */\n \n #include <assert.h>"
  - "--- a/tests/test_ackgen_gquic_be.c\n+++ b/tests/test_ackgen_gquic_be.c\n@@ -1,4\
    \ +1,4 @@\n-/* Copyright (c) 2017 - 2021 LiteSpeed Technologies Inc.  See LICENSE.\
    \ */\n+/* Copyright (c) 2017 - 2022 LiteSpeed Technologies Inc.  See LICENSE.\
    \ */\n /*\n  * Test how ACK frame is encoded.  Receive history module is tested\
    \ by a\n  * separate unit test."
  - "--- a/tests/test_ackparse_gquic_be.c\n+++ b/tests/test_ackparse_gquic_be.c\n\
    @@ -1,4 +1,4 @@\n-/* Copyright (c) 2017 - 2021 LiteSpeed Technologies Inc.  See\
    \ LICENSE. */\n+/* Copyright (c) 2017 - 2022 LiteSpeed Technologies Inc.  See\
    \ LICENSE. */\n #include <assert.h>\n #include <stdio.h>\n #include <stdlib.h>"
  - "--- a/tests/test_ackparse_ietf.c\n+++ b/tests/test_ackparse_ietf.c\n@@ -1,4 +1,4\
    \ @@\n-/* Copyright (c) 2017 - 2021 LiteSpeed Technologies Inc.  See LICENSE.\
    \ */\n+/* Copyright (c) 2017 - 2022 LiteSpeed Technologies Inc.  See LICENSE.\
    \ */\n #include <assert.h>\n #include <stdio.h>\n #include <stdlib.h>"
  - "--- a/tests/test_alarmset.c\n+++ b/tests/test_alarmset.c\n@@ -1,4 +1,4 @@\n-/*\
    \ Copyright (c) 2017 - 2021 LiteSpeed Technologies Inc.  See LICENSE. */\n+/*\
    \ Copyright (c) 2017 - 2022 LiteSpeed Technologies Inc.  See LICENSE. */\n #include\
    \ <assert.h>\n #include <stdio.h>\n #include <stdlib.h>"
  - "--- a/tests/test_alt_svc_ver.c\n+++ b/tests/test_alt_svc_ver.c\n@@ -1,4 +1,4\
    \ @@\n-/* Copyright (c) 2017 - 2021 LiteSpeed Technologies Inc.  See LICENSE.\
    \ */\n+/* Copyright (c) 2017 - 2022 LiteSpeed Technologies Inc.  See LICENSE.\
    \ */\n #include <assert.h>\n #include <string.h>\n "
  - "--- a/tests/test_arr.c\n+++ b/tests/test_arr.c\n@@ -1,4 +1,4 @@\n-/* Copyright\
    \ (c) 2017 - 2021 LiteSpeed Technologies Inc.  See LICENSE. */\n+/* Copyright\
    \ (c) 2017 - 2022 LiteSpeed Technologies Inc.  See LICENSE. */\n #include <assert.h>\n\
    \ \n #include \"lsquic_arr.h\""
  - "--- a/tests/test_attq.c\n+++ b/tests/test_attq.c\n@@ -1,4 +1,4 @@\n-/* Copyright\
    \ (c) 2017 - 2021 LiteSpeed Technologies Inc.  See LICENSE. */\n+/* Copyright\
    \ (c) 2017 - 2022 LiteSpeed Technologies Inc.  See LICENSE. */\n #include <assert.h>\n\
    \ #include <stdlib.h>\n #include <sys/queue.h>"
  - "--- a/tests/test_blocked_gquic_be.c\n+++ b/tests/test_blocked_gquic_be.c\n@@\
    \ -1,4 +1,4 @@\n-/* Copyright (c) 2017 - 2021 LiteSpeed Technologies Inc.  See\
    \ LICENSE. */\n+/* Copyright (c) 2017 - 2022 LiteSpeed Technologies Inc.  See\
    \ LICENSE. */\n #include <assert.h>\n #include <stdio.h>\n #include <stdlib.h>"
  - "--- a/tests/test_bw_sampler.c\n+++ b/tests/test_bw_sampler.c\n@@ -1,4 +1,4 @@\n\
    -/* Copyright (c) 2017 - 2021 LiteSpeed Technologies Inc.  See LICENSE. */\n+/*\
    \ Copyright (c) 2017 - 2022 LiteSpeed Technologies Inc.  See LICENSE. */\n /*\
    \ Test adapted from Chromium bandwidth_sampler_test.cc */\n // Copyright 2016\
    \ The Chromium Authors. All rights reserved.\n "
  - "--- a/tests/test_chlo_gen.c\n+++ b/tests/test_chlo_gen.c\n@@ -1,4 +1,4 @@\n-/*\
    \ Copyright (c) 2017 - 2021 LiteSpeed Technologies Inc.  See LICENSE. */\n+/*\
    \ Copyright (c) 2017 - 2022 LiteSpeed Technologies Inc.  See LICENSE. */\n /*\n\
    \  * test_chlo_gen.c -- Test Client Hello generation.\n  */"
  - "--- a/tests/test_clear_aead.c\n+++ b/tests/test_clear_aead.c\n@@ -1,4 +1,4 @@\n\
    -/* Copyright (c) 2017 - 2021 LiteSpeed Technologies Inc.  See LICENSE. */\n+/*\
    \ Copyright (c) 2017 - 2022 LiteSpeed Technologies Inc.  See LICENSE. */\n /*\n\
    \  * See\n  *  https://github.com/quicwg/base-drafts/wiki/Test-Vector-for-the-Clear-Text-AEAD-key-derivation"
  - "--- a/tests/test_conn_close_gquic_be.c\n+++ b/tests/test_conn_close_gquic_be.c\n\
    @@ -1,4 +1,4 @@\n-/* Copyright (c) 2017 - 2021 LiteSpeed Technologies Inc.  See\
    \ LICENSE. */\n+/* Copyright (c) 2017 - 2022 LiteSpeed Technologies Inc.  See\
    \ LICENSE. */\n #include <assert.h>\n #include <stdio.h>\n #include <stdlib.h>"
  - "--- a/tests/test_conn_hash.c\n+++ b/tests/test_conn_hash.c\n@@ -1,4 +1,4 @@\n\
    -/* Copyright (c) 2017 - 2021 LiteSpeed Technologies Inc.  See LICENSE. */\n+/*\
    \ Copyright (c) 2017 - 2022 LiteSpeed Technologies Inc.  See LICENSE. */\n #include\
    \ <assert.h>\n #include <stdint.h>\n #include <stdio.h>"
  - "--- a/tests/test_crypto_gen.c\n+++ b/tests/test_crypto_gen.c\n@@ -1,4 +1,4 @@\n\
    -/* Copyright (c) 2017 - 2021 LiteSpeed Technologies Inc.  See LICENSE. */\n+/*\
    \ Copyright (c) 2017 - 2022 LiteSpeed Technologies Inc.  See LICENSE. */\n #include\
    \ <assert.h>\n #include <stdio.h>\n #include <stdlib.h>"
  - "--- a/tests/test_cubic.c\n+++ b/tests/test_cubic.c\n@@ -1,4 +1,4 @@\n-/* Copyright\
    \ (c) 2017 - 2021 LiteSpeed Technologies Inc.  See LICENSE. */\n+/* Copyright\
    \ (c) 2017 - 2022 LiteSpeed Technologies Inc.  See LICENSE. */\n #include <assert.h>\n\
    \ #include <stdio.h>\n #include <stdlib.h>"
  - "--- a/tests/test_dec.c\n+++ b/tests/test_dec.c\n@@ -1,4 +1,4 @@\n-/* Copyright\
    \ (c) 2017 - 2021 LiteSpeed Technologies Inc.  See LICENSE. */\n+/* Copyright\
    \ (c) 2017 - 2022 LiteSpeed Technologies Inc.  See LICENSE. */\n /*\n  * test_dec.c\
    \ -- Benchmark decryption using aligned and non-aligned buffers.\n  */"
  - "--- a/tests/test_di_nocopy.c\n+++ b/tests/test_di_nocopy.c\n@@ -1,4 +1,4 @@\n\
    -/* Copyright (c) 2017 - 2021 LiteSpeed Technologies Inc.  See LICENSE. */\n+/*\
    \ Copyright (c) 2017 - 2022 LiteSpeed Technologies Inc.  See LICENSE. */\n /*\n\
    \  * Test the \"nocopy\" data in stream\n  */"
  - "--- a/tests/test_elision.c\n+++ b/tests/test_elision.c\n@@ -1,4 +1,4 @@\n-/*\
    \ Copyright (c) 2017 - 2021 LiteSpeed Technologies Inc.  See LICENSE. */\n+/*\
    \ Copyright (c) 2017 - 2022 LiteSpeed Technologies Inc.  See LICENSE. */\n #include\
    \ <assert.h>\n #include <errno.h>\n #include <stdio.h>"
  - "--- a/tests/test_engine_ctor.c\n+++ b/tests/test_engine_ctor.c\n@@ -1,4 +1,4\
    \ @@\n-/* Copyright (c) 2017 - 2021 LiteSpeed Technologies Inc.  See LICENSE.\
    \ */\n+/* Copyright (c) 2017 - 2022 LiteSpeed Technologies Inc.  See LICENSE.\
    \ */\n #include <assert.h>\n #include <stdlib.h>\n #include <string.h>"
  - "--- a/tests/test_export_key.c\n+++ b/tests/test_export_key.c\n@@ -1,4 +1,4 @@\n\
    -/* Copyright (c) 2017 - 2021 LiteSpeed Technologies Inc.  See LICENSE. */\n+/*\
    \ Copyright (c) 2017 - 2022 LiteSpeed Technologies Inc.  See LICENSE. */\n #include\
    \ <assert.h>\n #include <stdlib.h>\n #include <string.h>"
  - "--- a/tests/test_frame_chop.c\n+++ b/tests/test_frame_chop.c\n@@ -1,4 +1,4 @@\n\
    -/* Copyright (c) 2017 - 2021 LiteSpeed Technologies Inc.  See LICENSE. */\n+/*\
    \ Copyright (c) 2017 - 2022 LiteSpeed Technologies Inc.  See LICENSE. */\n /*\n\
    \  * Write several things to HEADERS stream and check the results.  What\n  *\
    \ varies is the amount of bytes that are written to stream every time."
  - "--- a/tests/test_frame_reader.c\n+++ b/tests/test_frame_reader.c\n@@ -1,4 +1,4\
    \ @@\n-/* Copyright (c) 2017 - 2021 LiteSpeed Technologies Inc.  See LICENSE.\
    \ */\n+/* Copyright (c) 2017 - 2022 LiteSpeed Technologies Inc.  See LICENSE.\
    \ */\n #include <assert.h>\n #include <errno.h>\n #include <stdio.h>"
  - "--- a/tests/test_frame_rw.c\n+++ b/tests/test_frame_rw.c\n@@ -1,4 +1,4 @@\n-/*\
    \ Copyright (c) 2017 - 2021 LiteSpeed Technologies Inc.  See LICENSE. */\n+/*\
    \ Copyright (c) 2017 - 2022 LiteSpeed Technologies Inc.  See LICENSE. */\n /*\n\
    \  * Generate a few thousand headers, frame them using frame writer, read them\n\
    \  * using frame reader, parse them, and compare with the original list: the"
  - "--- a/tests/test_frame_writer.c\n+++ b/tests/test_frame_writer.c\n@@ -1,4 +1,4\
    \ @@\n-/* Copyright (c) 2017 - 2021 LiteSpeed Technologies Inc.  See LICENSE.\
    \ */\n+/* Copyright (c) 2017 - 2022 LiteSpeed Technologies Inc.  See LICENSE.\
    \ */\n #include <assert.h>\n #include <errno.h>\n #include <stdio.h>"
  - "--- a/tests/test_goaway_gquic_be.c\n+++ b/tests/test_goaway_gquic_be.c\n@@ -1,4\
    \ +1,4 @@\n-/* Copyright (c) 2017 - 2021 LiteSpeed Technologies Inc.  See LICENSE.\
    \ */\n+/* Copyright (c) 2017 - 2022 LiteSpeed Technologies Inc.  See LICENSE.\
    \ */\n #include <assert.h>\n #include <stdio.h>\n #include <stdlib.h>"
  - "--- a/tests/test_h3_framing.c\n+++ b/tests/test_h3_framing.c\n@@ -1,4 +1,4 @@\n\
    -/* Copyright (c) 2017 - 2021 LiteSpeed Technologies Inc.  See LICENSE. */\n+/*\
    \ Copyright (c) 2017 - 2022 LiteSpeed Technologies Inc.  See LICENSE. */\n /*\n\
    \  * test_h3_framing.c -- test generation of H3 frames\n  */"
  - "--- a/tests/test_hcsi_reader.c\n+++ b/tests/test_hcsi_reader.c\n@@ -1,4 +1,4\
    \ @@\n-/* Copyright (c) 2017 - 2021 LiteSpeed Technologies Inc.  See LICENSE.\
    \ */\n+/* Copyright (c) 2017 - 2022 LiteSpeed Technologies Inc.  See LICENSE.\
    \ */\n #include <assert.h>\n #include <inttypes.h>\n #include <stdlib.h>"
  - "--- a/tests/test_hkdf.c\n+++ b/tests/test_hkdf.c\n@@ -1,4 +1,4 @@\n-/* Copyright\
    \ (c) 2017 - 2021 LiteSpeed Technologies Inc.  See LICENSE. */\n+/* Copyright\
    \ (c) 2017 - 2022 LiteSpeed Technologies Inc.  See LICENSE. */\n #include <assert.h>\n\
    \ #include <string.h>\n #include <openssl/ssl.h>"
  - "--- a/tests/test_hpi.c\n+++ b/tests/test_hpi.c\n@@ -1,4 +1,4 @@\n-/* Copyright\
    \ (c) 2017 - 2021 LiteSpeed Technologies Inc.  See LICENSE. */\n+/* Copyright\
    \ (c) 2017 - 2022 LiteSpeed Technologies Inc.  See LICENSE. */\n #include <assert.h>\n\
    \ #include <errno.h>\n #include <stdio.h>"
  - "--- a/tests/test_lsquic_hash.c\n+++ b/tests/test_lsquic_hash.c\n@@ -1,4 +1,4\
    \ @@\n-/* Copyright (c) 2017 - 2021 LiteSpeed Technologies Inc.  See LICENSE.\
    \ */\n+/* Copyright (c) 2017 - 2022 LiteSpeed Technologies Inc.  See LICENSE.\
    \ */\n #include <assert.h>\n #include <stdint.h>\n #include <stdio.h>"
  - "--- a/tests/test_malo.c\n+++ b/tests/test_malo.c\n@@ -1,4 +1,4 @@\n-/* Copyright\
    \ (c) 2017 - 2021 LiteSpeed Technologies Inc.  See LICENSE. */\n+/* Copyright\
    \ (c) 2017 - 2022 LiteSpeed Technologies Inc.  See LICENSE. */\n #include <assert.h>\n\
    \ #include <stdint.h>\n #include <stdio.h>"
  - "--- a/tests/test_min_heap.c\n+++ b/tests/test_min_heap.c\n@@ -1,4 +1,4 @@\n-/*\
    \ Copyright (c) 2017 - 2021 LiteSpeed Technologies Inc.  See LICENSE. */\n+/*\
    \ Copyright (c) 2017 - 2022 LiteSpeed Technologies Inc.  See LICENSE. */\n /*\
    \ Test min heap or benchmark heap creation */\n \n /* Floyd mechanism has been\
    \ removed.  It's not faster. */"
  - "--- a/tests/test_minmax.c\n+++ b/tests/test_minmax.c\n@@ -1,4 +1,4 @@\n-/* Copyright\
    \ (c) 2017 - 2021 LiteSpeed Technologies Inc.  See LICENSE. */\n+/* Copyright\
    \ (c) 2017 - 2022 LiteSpeed Technologies Inc.  See LICENSE. */\n /* Tests adopted\
    \ from Chromium windowed_filter_test.cc */\n // Copyright (c) 2016 The Chromium\
    \ Authors. All rights reserved.\n "
  - "--- a/tests/test_packet_out.c\n+++ b/tests/test_packet_out.c\n@@ -1,4 +1,4 @@\n\
    -/* Copyright (c) 2017 - 2021 LiteSpeed Technologies Inc.  See LICENSE. */\n+/*\
    \ Copyright (c) 2017 - 2022 LiteSpeed Technologies Inc.  See LICENSE. */\n #include\
    \ <assert.h>\n #include <errno.h>\n #include <stdio.h>"
  - "--- a/tests/test_packet_resize.c\n+++ b/tests/test_packet_resize.c\n@@ -1,4 +1,4\
    \ @@\n-/* Copyright (c) 2017 - 2021 LiteSpeed Technologies Inc.  See LICENSE.\
    \ */\n+/* Copyright (c) 2017 - 2022 LiteSpeed Technologies Inc.  See LICENSE.\
    \ */\n /* Test packet resizing */\n \n #include <assert.h>"
  - "--- a/tests/test_packno_len.c\n+++ b/tests/test_packno_len.c\n@@ -1,4 +1,4 @@\n\
    -/* Copyright (c) 2017 - 2021 LiteSpeed Technologies Inc.  See LICENSE. */\n+/*\
    \ Copyright (c) 2017 - 2022 LiteSpeed Technologies Inc.  See LICENSE. */\n #include\
    \ <assert.h>\n #include <stdio.h>\n #include <stdlib.h>"
  - "--- a/tests/test_parse_packet_in.c\n+++ b/tests/test_parse_packet_in.c\n@@ -1,4\
    \ +1,4 @@\n-/* Copyright (c) 2017 - 2021 LiteSpeed Technologies Inc.  See LICENSE.\
    \ */\n+/* Copyright (c) 2017 - 2022 LiteSpeed Technologies Inc.  See LICENSE.\
    \ */\n #include <assert.h>\n #include <stdint.h>\n #include <stdlib.h>"
  - "--- a/tests/test_purga.c\n+++ b/tests/test_purga.c\n@@ -1,4 +1,4 @@\n-/* Copyright\
    \ (c) 2017 - 2021 LiteSpeed Technologies Inc.  See LICENSE. */\n+/* Copyright\
    \ (c) 2017 - 2022 LiteSpeed Technologies Inc.  See LICENSE. */\n #include <assert.h>\n\
    \ #include <stdlib.h>\n #include <string.h>"
  - "--- a/tests/test_qlog.c\n+++ b/tests/test_qlog.c\n@@ -1,4 +1,4 @@\n-/* Copyright\
    \ (c) 2017 - 2021 LiteSpeed Technologies Inc.  See LICENSE. */\n+/* Copyright\
    \ (c) 2017 - 2022 LiteSpeed Technologies Inc.  See LICENSE. */\n #include <assert.h>\n\
    \ #include <stdio.h>\n #include <stdlib.h>"
  - "--- a/tests/test_quic_be_floats.c\n+++ b/tests/test_quic_be_floats.c\n@@ -1,4\
    \ +1,4 @@\n-/* Copyright (c) 2017 - 2021 LiteSpeed Technologies Inc.  See LICENSE.\
    \ */\n+/* Copyright (c) 2017 - 2022 LiteSpeed Technologies Inc.  See LICENSE.\
    \ */\n #include <assert.h>\n #include <stdio.h>\n #include <stdlib.h>"
  - "--- a/tests/test_rechist.c\n+++ b/tests/test_rechist.c\n@@ -1,4 +1,4 @@\n-/*\
    \ Copyright (c) 2017 - 2021 LiteSpeed Technologies Inc.  See LICENSE. */\n+/*\
    \ Copyright (c) 2017 - 2022 LiteSpeed Technologies Inc.  See LICENSE. */\n #include\
    \ <assert.h>\n #include <inttypes.h>\n #include <stdio.h>"
  - "--- a/tests/test_reg_pkt_headergen.c\n+++ b/tests/test_reg_pkt_headergen.c\n\
    @@ -1,4 +1,4 @@\n-/* Copyright (c) 2017 - 2021 LiteSpeed Technologies Inc.  See\
    \ LICENSE. */\n+/* Copyright (c) 2017 - 2022 LiteSpeed Technologies Inc.  See\
    \ LICENSE. */\n #include <assert.h>\n #include <stdio.h>\n #include <stdlib.h>"
  - "--- a/tests/test_rst_stream_gquic_be.c\n+++ b/tests/test_rst_stream_gquic_be.c\n\
    @@ -1,4 +1,4 @@\n-/* Copyright (c) 2017 - 2021 LiteSpeed Technologies Inc.  See\
    \ LICENSE. */\n+/* Copyright (c) 2017 - 2022 LiteSpeed Technologies Inc.  See\
    \ LICENSE. */\n #include <assert.h>\n #include <stdio.h>\n #include <stdlib.h>"
  - "--- a/tests/test_rst_stream_ietf.c\n+++ b/tests/test_rst_stream_ietf.c\n@@ -1,4\
    \ +1,4 @@\n-/* Copyright (c) 2017 - 2021 LiteSpeed Technologies Inc.  See LICENSE.\
    \ */\n+/* Copyright (c) 2017 - 2022 LiteSpeed Technologies Inc.  See LICENSE.\
    \ */\n #include <assert.h>\n #include <stdio.h>\n #include <stdlib.h>"
  - "--- a/tests/test_rtt.c\n+++ b/tests/test_rtt.c\n@@ -1,4 +1,4 @@\n-/* Copyright\
    \ (c) 2017 - 2021 LiteSpeed Technologies Inc.  See LICENSE. */\n+/* Copyright\
    \ (c) 2017 - 2022 LiteSpeed Technologies Inc.  See LICENSE. */\n #include <assert.h>\n\
    \ #include <stdio.h>\n #include <stdlib.h>"
  - "--- a/tests/test_send_headers.c\n+++ b/tests/test_send_headers.c\n@@ -1,4 +1,4\
    \ @@\n-/* Copyright (c) 2017 - 2021 LiteSpeed Technologies Inc.  See LICENSE.\
    \ */\n+/* Copyright (c) 2017 - 2022 LiteSpeed Technologies Inc.  See LICENSE.\
    \ */\n /*\n  * test_send_headers.c -- Test what happens when lsquic_stream_send_headers()\n\
    \  * is called."
  - "--- a/tests/test_senhist.c\n+++ b/tests/test_senhist.c\n@@ -1,4 +1,4 @@\n-/*\
    \ Copyright (c) 2017 - 2021 LiteSpeed Technologies Inc.  See LICENSE. */\n+/*\
    \ Copyright (c) 2017 - 2022 LiteSpeed Technologies Inc.  See LICENSE. */\n #include\
    \ <assert.h>\n #include <stdio.h>\n #include <stdlib.h>"
  - "--- a/tests/test_set.c\n+++ b/tests/test_set.c\n@@ -1,4 +1,4 @@\n-/* Copyright\
    \ (c) 2017 - 2021 LiteSpeed Technologies Inc.  See LICENSE. */\n+/* Copyright\
    \ (c) 2017 - 2022 LiteSpeed Technologies Inc.  See LICENSE. */\n #include <assert.h>\n\
    \ #include <stdio.h>\n #include <stdlib.h>"
  - "--- a/tests/test_sfcw.c\n+++ b/tests/test_sfcw.c\n@@ -1,4 +1,4 @@\n-/* Copyright\
    \ (c) 2017 - 2021 LiteSpeed Technologies Inc.  See LICENSE. */\n+/* Copyright\
    \ (c) 2017 - 2022 LiteSpeed Technologies Inc.  See LICENSE. */\n #include <assert.h>\n\
    \ #include <stdio.h>\n #include <stdint.h>"
  - "--- a/tests/test_shi.c\n+++ b/tests/test_shi.c\n@@ -1,4 +1,4 @@\n-/* Copyright\
    \ (c) 2017 - 2021 LiteSpeed Technologies Inc.  See LICENSE. */\n+/* Copyright\
    \ (c) 2017 - 2022 LiteSpeed Technologies Inc.  See LICENSE. */\n #include <assert.h>\n\
    \ #include <stdlib.h>\n #include <string.h>"
  - "--- a/tests/test_some_packets.c\n+++ b/tests/test_some_packets.c\n@@ -1,4 +1,4\
    \ @@\n-/* Copyright (c) 2017 - 2021 LiteSpeed Technologies Inc.  See LICENSE.\
    \ */\n+/* Copyright (c) 2017 - 2022 LiteSpeed Technologies Inc.  See LICENSE.\
    \ */\n /* Tests in this file have been migrated out of maintest.c */\n /* TODO:\
    \ fix warnings */\n "
  - "--- a/tests/test_spi.c\n+++ b/tests/test_spi.c\n@@ -1,4 +1,4 @@\n-/* Copyright\
    \ (c) 2017 - 2021 LiteSpeed Technologies Inc.  See LICENSE. */\n+/* Copyright\
    \ (c) 2017 - 2022 LiteSpeed Technologies Inc.  See LICENSE. */\n #include <assert.h>\n\
    \ #include <errno.h>\n #include <stdio.h>"
  - "--- a/tests/test_stop_waiting_gquic_be.c\n+++ b/tests/test_stop_waiting_gquic_be.c\n\
    @@ -1,4 +1,4 @@\n-/* Copyright (c) 2017 - 2021 LiteSpeed Technologies Inc.  See\
    \ LICENSE. */\n+/* Copyright (c) 2017 - 2022 LiteSpeed Technologies Inc.  See\
    \ LICENSE. */\n #include <assert.h>\n #include <stdio.h>\n #include <stdlib.h>"
  - "--- a/tests/test_stream.c\n+++ b/tests/test_stream.c\n@@ -1,4 +1,4 @@\n-/* Copyright\
    \ (c) 2017 - 2021 LiteSpeed Technologies Inc.  See LICENSE. */\n+/* Copyright\
    \ (c) 2017 - 2022 LiteSpeed Technologies Inc.  See LICENSE. */\n #include <assert.h>\n\
    \ #include <errno.h>\n #include <stdio.h>"
  - "--- a/tests/test_streamgen.c\n+++ b/tests/test_streamgen.c\n@@ -1,4 +1,4 @@\n\
    -/* Copyright (c) 2017 - 2021 LiteSpeed Technologies Inc.  See LICENSE. */\n+/*\
    \ Copyright (c) 2017 - 2022 LiteSpeed Technologies Inc.  See LICENSE. */\n #include\
    \ <assert.h>\n #include <stdio.h>\n #include <stdlib.h>"
  - "--- a/tests/test_streamparse.c\n+++ b/tests/test_streamparse.c\n@@ -1,4 +1,4\
    \ @@\n-/* Copyright (c) 2017 - 2021 LiteSpeed Technologies Inc.  See LICENSE.\
    \ */\n+/* Copyright (c) 2017 - 2022 LiteSpeed Technologies Inc.  See LICENSE.\
    \ */\n #include <assert.h>\n #include <stdio.h>\n #include <stdlib.h>"
  - "--- a/tests/test_tokgen.c\n+++ b/tests/test_tokgen.c\n@@ -1,4 +1,4 @@\n-/* Copyright\
    \ (c) 2017 - 2021 LiteSpeed Technologies Inc.  See LICENSE. */\n+/* Copyright\
    \ (c) 2017 - 2022 LiteSpeed Technologies Inc.  See LICENSE. */\n #include <assert.h>\n\
    \ #include <stdio.h>\n #include <string.h>"
  - "--- a/tests/test_trapa.c\n+++ b/tests/test_trapa.c\n@@ -1,4 +1,4 @@\n-/* Copyright\
    \ (c) 2017 - 2021 LiteSpeed Technologies Inc.  See LICENSE. */\n+/* Copyright\
    \ (c) 2017 - 2022 LiteSpeed Technologies Inc.  See LICENSE. */\n /*\n  * test_trapa.c\
    \ -- Test transport parameters.\n  */"
  - "--- a/tests/test_trechist.c\n+++ b/tests/test_trechist.c\n@@ -1,4 +1,4 @@\n-/*\
    \ Copyright (c) 2017 - 2021 LiteSpeed Technologies Inc.  See LICENSE. */\n+/*\
    \ Copyright (c) 2017 - 2022 LiteSpeed Technologies Inc.  See LICENSE. */\n /*\
    \ Tests based on rechist tests */\n \n #include <assert.h>"
  - "--- a/tests/test_varint.c\n+++ b/tests/test_varint.c\n@@ -1,4 +1,4 @@\n-/* Copyright\
    \ (c) 2017 - 2021 LiteSpeed Technologies Inc.  See LICENSE. */\n+/* Copyright\
    \ (c) 2017 - 2022 LiteSpeed Technologies Inc.  See LICENSE. */\n #include <assert.h>\n\
    \ #include <stddef.h>\n #include <stdint.h>"
  - "--- a/tests/test_ver_nego.c\n+++ b/tests/test_ver_nego.c\n@@ -1,4 +1,4 @@\n-/*\
    \ Copyright (c) 2017 - 2021 LiteSpeed Technologies Inc.  See LICENSE. */\n+/*\
    \ Copyright (c) 2017 - 2022 LiteSpeed Technologies Inc.  See LICENSE. */\n #include\
    \ <assert.h>\n #include <stdio.h>\n #include <stdlib.h>"
  - "--- a/tests/test_wuf_gquic_be.c\n+++ b/tests/test_wuf_gquic_be.c\n@@ -1,4 +1,4\
    \ @@\n-/* Copyright (c) 2017 - 2021 LiteSpeed Technologies Inc.  See LICENSE.\
    \ */\n+/* Copyright (c) 2017 - 2022 LiteSpeed Technologies Inc.  See LICENSE.\
    \ */\n #include <assert.h>\n #include <stdio.h>\n #include <stdlib.h>"
  identifiers:
  - CVE-2022-30592
  - CWE-476
  overview: liblsquic/lsquic_qenc_hdl.c in LiteSpeed QUIC (aka LSQUIC) before 3.1.0
    mishandles MAX_TABLE_CAPACITY.
  references:
  - source: cve@mitre.org
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/litespeedtech/lsquic/commit/a74702c630e108125e71898398737baec8f02238#diff-73a138506faffe5f1efa8586346ab573c88e9dd2097774ecca5949a718a57cae
  - source: cve@mitre.org
    tags:
    - Release Notes
    - Third Party Advisory
    url: https://github.com/litespeedtech/lsquic/releases/tag/v3.1.0
  title: liblsquic/lsquic_qenc_hdl.c in LiteSpeed QUIC (aka LSQUIC) before 3.1.0 mishandles
    MAX_TABLE_CAPACITY.
- diff_content:
  - "--- a/kernel/ptrace.c\n+++ b/kernel/ptrace.c\n@@ -371,6 +371,26 @@ bool ptrace_may_access(struct\
    \ task_struct *task, unsigned int mode)\n \treturn !err;\n }\n \n+static int check_ptrace_options(unsigned\
    \ long data)\n+{\n+\tif (data & ~(unsigned long)PTRACE_O_MASK)\n+\t\treturn -EINVAL;\n\
    +\n+\tif (unlikely(data & PTRACE_O_SUSPEND_SECCOMP)) {\n+\t\tif (!IS_ENABLED(CONFIG_CHECKPOINT_RESTORE)\
    \ ||\n+\t\t    !IS_ENABLED(CONFIG_SECCOMP))\n+\t\t\treturn -EINVAL;\n+\n+\t\t\
    if (!capable(CAP_SYS_ADMIN))\n+\t\t\treturn -EPERM;\n+\n+\t\tif (seccomp_mode(&current->seccomp)\
    \ != SECCOMP_MODE_DISABLED ||\n+\t\t    current->ptrace & PT_SUSPEND_SECCOMP)\n\
    +\t\t\treturn -EPERM;\n+\t}\n+\treturn 0;\n+}\n+\n static int ptrace_attach(struct\
    \ task_struct *task, long request,\n \t\t\t unsigned long addr,\n \t\t\t unsigned\
    \ long flags)\n@@ -382,8 +402,16 @@ static int ptrace_attach(struct task_struct\
    \ *task, long request,\n \tif (seize) {\n \t\tif (addr != 0)\n \t\t\tgoto out;\n\
    +\t\t/*\n+\t\t * This duplicates the check in check_ptrace_options() because\n\
    +\t\t * ptrace_attach() and ptrace_setoptions() have historically\n+\t\t * used\
    \ different error codes for unknown ptrace options.\n+\t\t */\n \t\tif (flags\
    \ & ~(unsigned long)PTRACE_O_MASK)\n \t\t\tgoto out;\n+\t\tretval = check_ptrace_options(flags);\n\
    +\t\tif (retval)\n+\t\t\treturn retval;\n \t\tflags = PT_PTRACED | PT_SEIZED |\
    \ (flags << PT_OPT_FLAG_SHIFT);\n \t} else {\n \t\tflags = PT_PTRACED;\n@@ -654,22\
    \ +682,11 @@ int ptrace_writedata(struct task_struct *tsk, char __user *src, unsigned\
    \ long ds\n static int ptrace_setoptions(struct task_struct *child, unsigned long\
    \ data)\n {\n \tunsigned flags;\n+\tint ret;\n \n-\tif (data & ~(unsigned long)PTRACE_O_MASK)\n\
    -\t\treturn -EINVAL;\n-\n-\tif (unlikely(data & PTRACE_O_SUSPEND_SECCOMP)) {\n\
    -\t\tif (!IS_ENABLED(CONFIG_CHECKPOINT_RESTORE) ||\n-\t\t    !IS_ENABLED(CONFIG_SECCOMP))\n\
    -\t\t\treturn -EINVAL;\n-\n-\t\tif (!capable(CAP_SYS_ADMIN))\n-\t\t\treturn -EPERM;\n\
    -\n-\t\tif (seccomp_mode(&current->seccomp) != SECCOMP_MODE_DISABLED ||\n-\t\t\
    \    current->ptrace & PT_SUSPEND_SECCOMP)\n-\t\t\treturn -EPERM;\n-\t}\n+\tret\
    \ = check_ptrace_options(data);\n+\tif (ret)\n+\t\treturn ret;\n \n \t/* Avoid\
    \ intermediate state when all opts are cleared */\n \tflags = child->ptrace;"
  identifiers:
  - CVE-2022-30594
  - CWE-862
  overview: The Linux kernel before 5.17.2 mishandles seccomp permissions. The PTRACE_SEIZE
    code path allows attackers to bypass intended restrictions on setting the PT_SUSPEND_SECCOMP
    flag.
  references:
  - source: cve@mitre.org
    tags:
    - Third Party Advisory
    - VDB Entry
    url: http://packetstormsecurity.com/files/167386/Kernel-Live-Patch-Security-Notice-LSN-0086-1.html
  - source: cve@mitre.org
    tags:
    - Third Party Advisory
    - VDB Entry
    url: http://packetstormsecurity.com/files/170362/Linux-PT_SUSPEND_SECCOMP-Permission-Bypass-Ptracer-Death-Race.html
  - source: cve@mitre.org
    tags:
    - Exploit
    - Mailing List
    - Patch
    - Third Party Advisory
    url: https://bugs.chromium.org/p/project-zero/issues/detail?id=2276
  - source: cve@mitre.org
    tags:
    - Mailing List
    - Patch
    - Vendor Advisory
    url: https://cdn.kernel.org/pub/linux/kernel/v5.x/ChangeLog-5.17.2
  - source: cve@mitre.org
    tags:
    - Mailing List
    - Patch
    - Vendor Advisory
    url: https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=ee1fee900537b5d9560e9f937402de5ddc8412f3
  - source: cve@mitre.org
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/torvalds/linux/commit/ee1fee900537b5d9560e9f937402de5ddc8412f3
  - source: cve@mitre.org
    tags:
    - Mailing List
    - Third Party Advisory
    url: https://lists.debian.org/debian-lts-announce/2022/07/msg00000.html
  - source: cve@mitre.org
    tags:
    - Third Party Advisory
    url: https://security.netapp.com/advisory/ntap-20220707-0001/
  - source: cve@mitre.org
    tags:
    - Third Party Advisory
    url: https://www.debian.org/security/2022/dsa-5173
  title: The Linux kernel before 5.17.2 mishandles seccomp permissions. The PTRACE_SEIZE
    code path allows attackers to bypass intended restrictions on setting the PT_SUSPEND_SECCOMP
    flag.
- diff_content:
  - "--- a/src/buffer.c\n+++ b/src/buffer.c\n@@ -2932,7 +2932,7 @@ buflist_match(\n\
    \ \n     // First try the short file name, then the long file name.\n     match\
    \ = fname_match(rmp, buf->b_sfname, ignore_case);\n-    if (match == NULL)\n+\
    \    if (match == NULL && rmp->regprog != NULL)\n \tmatch = fname_match(rmp, buf->b_ffname,\
    \ ignore_case);\n \n     return match;"
  - "--- a/src/version.c\n+++ b/src/version.c\n@@ -746,6 +746,8 @@ static char *(features[])\
    \ =\n \n static int included_patches[] =\n {   /* Add new patch number below this\
    \ line */\n+/**/\n+    4938,\n /**/\n     4937,\n /**/"
  identifiers:
  - CVE-2022-1674
  - CWE-476
  overview: NULL Pointer Dereference in function vim_regexec_string at regexp.c:2733
    in GitHub repository vim/vim prior to 8.2.4938. NULL Pointer Dereference in function
    vim_regexec_string at regexp.c:2733 allows attackers to cause a denial of service
    (application crash) via a crafted input.
  references:
  - source: security@huntr.dev
    url: http://seclists.org/fulldisclosure/2022/Oct/28
  - source: security@huntr.dev
    tags:
    - Mailing List
    - Release Notes
    - Third Party Advisory
    url: http://seclists.org/fulldisclosure/2022/Oct/41
  - source: security@huntr.dev
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/vim/vim/commit/a59f2dfd0cf9ee1a584d3de5b7c2d47648e79060
  - source: security@huntr.dev
    tags:
    - Exploit
    - Patch
    - Third Party Advisory
    url: https://huntr.dev/bounties/a74ba4a4-7a39-4a22-bde3-d2f8ee07b385
  - source: security@huntr.dev
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/BFAZTAT5CZC2R6KYDYA2HBAVEDSIX6MW/
  - source: security@huntr.dev
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/IUPOLEX5GXC733HL4EFYMHFU7NISJJZG/
  - source: security@huntr.dev
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/ODXVYZC5Z4XRRZK7CK6B6IURYVYHA25U/
  - source: security@huntr.dev
    tags:
    - Third Party Advisory
    url: https://security.gentoo.org/glsa/202208-32
  - source: security@huntr.dev
    url: https://security.gentoo.org/glsa/202305-16
  - source: security@huntr.dev
    tags:
    - Release Notes
    - Third Party Advisory
    url: https://support.apple.com/kb/HT213488
  title: NULL Pointer Dereference in function vim_regexec_string at regexp.c:2733
    in GitHub repository vim/vim prior to 8.2.4938. NULL Pointer Dereference in function
    vim_regexec_string at regexp.c:2733 allows attackers to cause a denial of service
    (application crash) via a crafted input.
- diff_content:
  - "--- a/xs/sources/xsDataView.c\n+++ b/xs/sources/xsDataView.c\n@@ -773,7 +773,8\
    \ @@ void fx_DataView(txMachine* the)\n \t\tmxRangeError(\"out of range byteOffset\
    \ %ld\", offset);\n \tsize = fxArgToByteLength(the, 2, -1);\n \tif (size >= 0)\
    \ {\n-\t\tif (info->value.bufferInfo.length < (offset + size))\n+\t\ttxInteger\
    \ end = offset + size;\n+\t\tif ((info->value.bufferInfo.length < end) || (end\
    \ < offset))\n \t\t\tmxRangeError(\"out of range byteLength %ld\", size);\n \t\
    }\n \telse {\n@@ -793,7 +794,8 @@ void fx_DataView(txMachine* the)\n \t\tif (info->value.bufferInfo.length\
    \ < offset)\n \t\t\tmxRangeError(\"out of range byteOffset %ld\", offset);\n \t\
    \telse if (size >= 0) {\n-\t\t\tif (info->value.bufferInfo.length < (offset +\
    \ size))\n+\t\t\ttxInteger end = offset + size;\n+\t\t\tif ((info->value.bufferInfo.length\
    \ < end) || (end < offset))\n \t\t\t\tmxRangeError(\"out of range byteLength %ld\"\
    , size);\n \t\t}\n \t}\n@@ -1360,9 +1362,11 @@ void fx_TypedArray(txMachine* the)\n\
    \ \t\t\tsize = fxArgToByteLength(the, 2, -1);\n \t\t\tinfo = fxGetBufferInfo(the,\
    \ mxArgv(0));\n \t\t\tif (size >= 0) {\n-\t\t\t\tsize <<= shift;\n-\t\t\t\tif\
    \ (info->value.bufferInfo.length < (offset + size))\n-\t\t\t\t\tmxRangeError(\"\
    out of range byteLength %ld\", size);\n+\t\t\t\ttxInteger delta = size << shift;\n\
    +\t\t\t\ttxInteger end = offset + delta;\n+\t\t\t\tif ((info->value.bufferInfo.length\
    \ < end) || (end < offset))\n+\t\t\t\t\tmxRangeError(\"out of range length %ld\"\
    , size);\n+\t\t\t\tsize = delta;\n \t\t\t}\n \t\t\telse {\n \t\t\t\tif (info->value.bufferInfo.length\
    \ & ((1 << shift) - 1))"
  identifiers:
  - CVE-2022-29368
  - CWE-125
  overview: Moddable commit before 135aa9a4a6a9b49b60aa730ebc3bcc6247d75c45 was discovered
    to contain an out-of-bounds read via the function fxUint8Getter at /moddable/xs/sources/xsDataView.c.
  references:
  - source: cve@mitre.org
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/Moddable-OpenSource/moddable/commit/135aa9a4a6a9b49b60aa730ebc3bcc6247d75c45
  - source: cve@mitre.org
    tags:
    - Exploit
    - Third Party Advisory
    url: https://github.com/Moddable-OpenSource/moddable/issues/896
  title: Moddable commit before 135aa9a4a6a9b49b60aa730ebc3bcc6247d75c45 was discovered
    to contain an out-of-bounds read via the function fxUint8Getter at /moddable/xs/sources/xsDataView.c.
- diff_content:
  - "--- a/src/njs_vmcode.c\n+++ b/src/njs_vmcode.c\n@@ -700,7 +700,7 @@ njs_vmcode_interpreter(njs_vm_t\
    \ *vm, u_char *pc, void *promise_cap,\n                 ret = njs_object_prop_define(vm,\
    \ value1, &name, function,\n                                              accessor->type);\n\
    \                 if (njs_slow_path(ret != NJS_OK)) {\n-                    return\
    \ NJS_ERROR;\n+                    goto error;\n                 }\n \n      \
    \           ret = sizeof(njs_vmcode_prop_accessor_t);\n@@ -779,12 +779,12 @@ njs_vmcode_interpreter(njs_vm_t\
    \ *vm, u_char *pc, void *promise_cap,\n                 }\n \n               \
    \  if (njs_slow_path(!njs_is_function(&dst))) {\n-                    ret = njs_value_to_key(vm,\
    \ value2, value2);\n+                    ret = njs_value_to_key(vm, &dst, value2);\n\
    \                     if (njs_slow_path(ret != NJS_OK)) {\n-                 \
    \       return NJS_ERROR;\n+                        goto error;\n            \
    \         }\n \n-                    njs_key_string_get(vm, value2, &string);\n\
    +                    njs_key_string_get(vm, &dst, &string);\n                \
    \     njs_type_error(vm,\n                                \"(intermediate value)[\\\
    \"%V\\\"] is not a function\",\n                                &string);\n@@\
    \ -950,7 +950,8 @@ njs_vmcode_interpreter(njs_vm_t *vm, u_char *pc, void *promise_cap,\n\
    \                 if (njs_is_valid(value1)) {\n                     value1 = njs_mp_alloc(vm->mem_pool,\
    \ sizeof(njs_value_t));\n                     if (njs_slow_path(value1 == NULL))\
    \ {\n-                        return NJS_ERROR;\n+                        njs_memory_error(vm);\n\
    +                        goto error;\n                     }\n \n            \
    \         njs_scope_value_set(vm, var->dst, value1);\n@@ -967,7 +968,8 @@ njs_vmcode_interpreter(njs_vm_t\
    \ *vm, u_char *pc, void *promise_cap,\n \n                 value1 = njs_mp_alloc(vm->mem_pool,\
    \ sizeof(njs_value_t));\n                 if (njs_slow_path(value1 == NULL)) {\n\
    -                    return NJS_ERROR;\n+                    njs_memory_error(vm);\n\
    +                    goto error;\n                 }\n \n                 *value1\
    \ = *value2;"
  - "--- a/src/test/njs_unit_test.c\n+++ b/src/test/njs_unit_test.c\n@@ -3409,6 +3409,11\
    \ @@ static njs_unit_test_t  njs_test[] =\n \n     /**/\n \n+    { njs_str(\"\
    function f() { Object.prototype.toString = 1; };\"\n+              \"Object.prototype.toString\
    \ = f;\"\n+              \"(function () { try { 's'[{}](); } catch (e) { throw\
    \ e; } })()\"),\n+      njs_str(\"TypeError: Cannot convert object to primitive\
    \ value\") },\n+\n     { njs_str(\"var i; for (i = 0; i < 10; i++) { i += 1 }\
    \ i\"),\n       njs_str(\"10\") },\n "
  identifiers:
  - CVE-2022-29369
  - CWE-754
  overview: Nginx NJS v0.7.2 was discovered to contain a segmentation violation via
    njs_lvlhsh_bucket_find at njs_lvlhsh.c.
  references:
  - source: cve@mitre.org
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/nginx/njs/commit/222d6fdcf0c6485ec8e175f3a7b70d650c234b4e
  - source: cve@mitre.org
    tags:
    - Third Party Advisory
    url: https://github.com/nginx/njs/issues/467
  title: Nginx NJS v0.7.2 was discovered to contain a segmentation violation via njs_lvlhsh_bucket_find
    at njs_lvlhsh.c.
- diff_content:
  - "--- a/libr/anal/p/anal_msp430.c\n+++ b/libr/anal/p/anal_msp430.c\n@@ -10,17 +10,13\
    \ @@\n #include \"../arch/msp430/msp430_disas.h\"\n \n static int msp430_op(RAnal\
    \ *anal, RAnalOp *op, ut64 addr, const ut8 *buf, int len, RAnalOpMask mask) {\n\
    -\tint ret;\n-\tstruct msp430_cmd cmd;\n-\n-\tmemset (&cmd, 0, sizeof (cmd));\n\
    -\t//op->id = ???;\n+\tstruct msp430_cmd cmd = {0};\n \top->size = -1;\n \top->nopcode\
    \ = 1;\n \top->type = R_ANAL_OP_TYPE_UNK;\n \top->family = R_ANAL_OP_FAMILY_CPU;\n\
    \ \n-\tret = op->size = msp430_decode_command (buf, len, &cmd);\n+\tint ret =\
    \ op->size = msp430_decode_command (buf, len, &cmd);\n \tif (mask & R_ANAL_OP_MASK_DISASM)\
    \ {\n \t\tif (ret < 1) {\n \t\t\top->mnemonic = strdup (\"invalid\");\n@@ -59,7\
    \ +55,9 @@ static int msp430_op(RAnal *anal, RAnalOp *op, ut64 addr, const ut8\
    \ *buf, int le\n \t\tcase MSP430_CALL:\n \t\t\top->type = R_ANAL_OP_TYPE_CALL;\n\
    \ \t\t\top->fail = addr + op->size;\n-\t\t\top->jump = r_read_at_le16 (buf, 2);\n\
    +\t\t\tif (len > 4) {\n+\t\t\t\top->jump = r_read_at_le16 (buf, 2);\n+\t\t\t}\n\
    \ \t\t\tbreak;\n \t\tcase MSP430_RETI:\n \t\t\top->type = R_ANAL_OP_TYPE_RET;\n\
    @@ -111,6 +109,7 @@ static bool set_reg_profile(RAnal *anal) {\n \tconst char\
    \ *p = \\\n \t\t\"=PC\tpc\\n\"\n \t\t\"=SP\tsp\\n\"\n+\t\t\"=SN\tr0\\n\"\n \t\t\
    // this is the \"new\" ABI, the old was reverse order\n \t\t\"=A0\tr12\\n\"\n\
    \ \t\t\"=A1\tr13\\n\""
  - "--- a/libr/bin/format/elf/elf.c\n+++ b/libr/bin/format/elf/elf.c\n@@ -124,7 +124,7\
    \ @@ static bool init_ehdr(ELFOBJ *bin) {\n \tut8 ehdr[sizeof (Elf_(Ehdr))] =\
    \ {0};\n \tint i, len;\n \tif (r_buf_read_at (bin->b, 0, e_ident, EI_NIDENT) ==\
    \ -1) {\n-\t\tR_LOG_ERROR (\"read (magic)\");\n+\t\tR_LOG_DEBUG (\"read (magic)\"\
    );\n \t\treturn false;\n \t}\n \tsdb_set (bin->kv, \"elf_type.cparse\", \"enum\
    \ elf_type { ET_NONE=0, ET_REL=1,\"\n@@ -188,7 +188,7 @@ static bool init_ehdr(ELFOBJ\
    \ *bin) {\n \tmemset (&bin->ehdr, 0, sizeof (Elf_(Ehdr)));\n \tlen = r_buf_read_at\
    \ (bin->b, 0, ehdr, sizeof (ehdr));\n \tif (len < 32) { // tinyelf != sizeof (Elf_(Ehdr)))\
    \ {\n-\t\tR_LOG_ERROR (\"read (ehdr)\");\n+\t\tR_LOG_DEBUG (\"read (ehdr)\");\n\
    \ \t\treturn false;\n \t}\n \t// XXX no need to check twice\n@@ -257,7 +257,7\
    \ @@ static bool read_phdr(ELFOBJ *bin, bool linux_kernel_hack) {\n \t\tconst\
    \ size_t rsize = bin->ehdr.e_phoff + i * sizeof (Elf_(Phdr));\n \t\tint len =\
    \ r_buf_read_at (bin->b, rsize, phdr, sizeof (Elf_(Phdr)));\n \t\tif (len < 1)\
    \ {\n-\t\t\tR_LOG_ERROR (\"read (phdr)\");\n+\t\t\tR_LOG_DEBUG (\"read (phdr)\"\
    );\n \t\t\tR_FREE (bin->phdr);\n \t\t\treturn false;\n \t\t}\n@@ -397,7 +397,7\
    \ @@ static int init_shdr(ELFOBJ *bin) {\n \t\tj = 0;\n \t\tlen = r_buf_read_at\
    \ (bin->b, bin->ehdr.e_shoff + i * sizeof (Elf_(Shdr)), shdr, sizeof (Elf_(Shdr)));\n\
    \ \t\tif (len < 1) {\n-\t\t\tR_LOG_ERROR (\"read (shdr) at 0x%\" PFMT64x, (ut64)\
    \ bin->ehdr.e_shoff);\n+\t\t\tR_LOG_DEBUG (\"read (shdr) at 0x%\" PFMT64x, (ut64)\
    \ bin->ehdr.e_shoff);\n \t\t\tR_FREE (bin->shdr);\n \t\t\treturn false;\n \t\t\
    }\n@@ -475,7 +475,7 @@ static int init_strtab(ELFOBJ *bin) {\n \tint res = r_buf_read_at\
    \ (bin->b, bin->shstrtab_section->sh_offset, (ut8*)bin->shstrtab,\n \t\tbin->shstrtab_section->sh_size);\n\
    \ \tif (res < 1) {\n-\t\tR_LOG_ERROR (\"read (shstrtab) at 0x%\" PFMT64x, (ut64)\
    \ bin->shstrtab_section->sh_offset);\n+\t\tR_LOG_DEBUG (\"read (shstrtab) at 0x%\"\
    \ PFMT64x, (ut64) bin->shstrtab_section->sh_offset);\n \t\tR_FREE (bin->shstrtab);\n\
    \ \t\treturn false;\n \t}\n@@ -970,7 +970,7 @@ static Sdb *store_versioninfo_gnu_verdef(ELFOBJ\
    \ *bin, Elf_(Shdr) *shdr, int sz)\n \t}\n \tElf_(Verdef) *defs = calloc (shdr->sh_size,\
    \ 1);\n \tif (!defs) {\n-\t\tR_LOG_ERROR (\"Cannot allocate memory (Check Elf_(Verdef))\"\
    );\n+\t\tR_LOG_DEBUG (\"Cannot allocate memory (Check Elf_(Verdef))\");\n \t\t\
    return false;\n \t}\n \tif (bin->shstrtab && shdr->sh_name < bin->shstrtab_size)\
    \ {\n@@ -1798,7 +1798,7 @@ ut64 Elf_(r_bin_elf_get_init_offset)(ELFOBJ *bin) {\n\
    \ \t\treturn UT64_MAX;\n \t}\n \tif (r_buf_read_at (bin->b, entry + 16, buf, sizeof\
    \ (buf)) < 1) {\n-\t\tR_LOG_ERROR (\"read (init_offset)\");\n+\t\tR_LOG_DEBUG\
    \ (\"read (init_offset)\");\n \t\treturn 0;\n \t}\n \tif (buf[0] == 0x68) { //\
    \ push // x86 only"
  identifiers:
  - CVE-2022-1714
  - CWE-125
  overview: Out-of-bounds Read in GitHub repository radareorg/radare2 prior to 5.7.0.
    The bug causes the program reads data past the end of the intented buffer. Typically,
    this can allow attackers to read sensitive information from other memory locations
    or cause a crash.
  references:
  - source: security@huntr.dev
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/radareorg/radare2/commit/3ecdbf8e21186a9c5a4d3cfa3b1e9fd27045340e
  - source: security@huntr.dev
    tags:
    - Exploit
    - Patch
    - Third Party Advisory
    url: https://huntr.dev/bounties/1c22055b-b015-47a8-a57b-4982978751d0
  title: Out-of-bounds Read in GitHub repository radareorg/radare2 prior to 5.7.0.
    The bug causes the program reads data past the end of the intented buffer. Typically,
    this can allow attackers to read sensitive information from other memory locations
    or cause a crash.
- diff_content:
  - "--- a/net/nfs.c\n+++ b/net/nfs.c\n@@ -566,11 +566,15 @@ static int nfs_lookup_reply(uchar\
    \ *pkt, unsigned len)\n \t}\n \n \tif (supported_nfs_versions & NFSV2_FLAG) {\n\
    +\t\tif (((uchar *)&(rpc_pkt.u.reply.data[0]) - (uchar *)(&rpc_pkt) + NFS_FHSIZE)\
    \ > len)\n+\t\t\treturn -NFS_RPC_DROP;\n \t\tmemcpy(filefh, rpc_pkt.u.reply.data\
    \ + 1, NFS_FHSIZE);\n \t} else {  /* NFSV3_FLAG */\n \t\tfilefh3_length = ntohl(rpc_pkt.u.reply.data[1]);\n\
    \ \t\tif (filefh3_length > NFS3_FHSIZE)\n \t\t\tfilefh3_length  = NFS3_FHSIZE;\n\
    +\t\tif (((uchar *)&(rpc_pkt.u.reply.data[0]) - (uchar *)(&rpc_pkt) + filefh3_length)\
    \ > len)\n+\t\t\treturn -NFS_RPC_DROP;\n \t\tmemcpy(filefh, rpc_pkt.u.reply.data\
    \ + 2, filefh3_length);\n \t}\n "
  identifiers:
  - CVE-2022-30767
  - CWE-120
  overview: 'nfs_lookup_reply in net/nfs.c in Das U-Boot through 2022.04 (and through
    2022.07-rc2) has an unbounded memcpy with a failed length check, leading to a
    buffer overflow. NOTE: this issue exists because of an incorrect fix for CVE-2019-14196.'
  references:
  - source: cve@mitre.org
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/u-boot/u-boot/commit/5d14ee4e53a81055d34ba280cb8fd90330f22a96
  - source: cve@mitre.org
    tags:
    - Mailing List
    - Third Party Advisory
    url: https://lists.denx.de/pipermail/u-boot/2022-May/483952.html
  - source: cve@mitre.org
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/DF62MVMH3QUGMBDCB3DY2ERQ6EBHTADB/
  - source: cve@mitre.org
    tags:
    - Exploit
    - Third Party Advisory
    url: https://securitylab.github.com/research/uboot-rce-nfs-vulnerability/
  - source: cve@mitre.org
    tags:
    - Patch
    - Vendor Advisory
    url: https://source.denx.de/u-boot/u-boot/-/commit/bdbf7a05e26f3c5fd437c99e2755ffde186ddc80
  title: 'nfs_lookup_reply in net/nfs.c in Das U-Boot through 2022.04 (and through
    2022.07-rc2) has an unbounded memcpy with a failed length check, leading to a
    buffer overflow. NOTE: this issue exists because of an incorrect fix for CVE-2019-14196.'
- diff_content:
  - "--- a/src/pcre2_jit_compile.c\n+++ b/src/pcre2_jit_compile.c\n@@ -7489,7 +7489,7\
    \ @@ while (*cc != XCL_END)\n     {\n     SLJIT_ASSERT(*cc == XCL_PROP || *cc\
    \ == XCL_NOTPROP);\n     cc++;\n-    if (*cc == PT_CLIST && *cc == XCL_PROP)\n\
    +    if (*cc == PT_CLIST && cc[-1] == XCL_PROP)\n       {\n       other_cases\
    \ = PRIV(ucd_caseless_sets) + cc[1];\n       while (*other_cases != NOTACHAR)"
  identifiers:
  - CVE-2022-1586
  - CWE-125
  overview: An out-of-bounds read vulnerability was discovered in the PCRE2 library
    in the compile_xclass_matchingpath() function of the pcre2_jit_compile.c file.
    This involves a unicode property matching issue in JIT-compiled regular expressions.
    The issue occurs because the character was not fully read in case-less matching
    within JIT.
  references:
  - source: secalert@redhat.com
    url: https://bugzilla.redhat.com/show_bug.cgi?id=2077976%2C
  - source: secalert@redhat.com
    url: https://github.com/PCRE2Project/pcre2/commit/50a51cb7e67268e6ad417eb07c9de9bfea5cc55a%2C
  - source: secalert@redhat.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/PCRE2Project/pcre2/commit/d4fa336fbcc388f89095b184ba6d99422cfc676c
  - source: secalert@redhat.com
    url: https://lists.debian.org/debian-lts-announce/2023/03/msg00014.html
  - source: secalert@redhat.com
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/DWNG2NS3GINO6LQYUVC4BZLUQPJ3DYHA/
  - source: secalert@redhat.com
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/JXINO3KKI5DICQ45E2FKD6MKVMGJLEKJ/
  - source: secalert@redhat.com
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/KAX7767BCUFC7JMDGP7GOQ5GIZCAUGBB/
  - source: secalert@redhat.com
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/M2GLQQUEY5VFM57CFYXVIFOXN2HUZPDM/
  - source: secalert@redhat.com
    tags:
    - Third Party Advisory
    url: https://security.netapp.com/advisory/ntap-20221028-0009/
  title: An out-of-bounds read vulnerability was discovered in the PCRE2 library in
    the compile_xclass_matchingpath() function of the pcre2_jit_compile.c file. This
    involves a unicode property matching issue in JIT-compiled regular expressions.
    The issue occurs because the character was not fully read in case-less matching
    within JIT.
- diff_content:
  - "--- a/src/pcre2_jit_compile.c\n+++ b/src/pcre2_jit_compile.c\n@@ -413,6 +413,9\
    \ @@ typedef struct compiler_common {\n   /* Locals used by fast fail optimization.\
    \ */\n   sljit_s32 early_fail_start_ptr;\n   sljit_s32 early_fail_end_ptr;\n+\
    \  /* Variables used by recursive call generator. */\n+  sljit_s32 recurse_bitset_size;\n\
    +  uint8_t *recurse_bitset;\n \n   /* Flipped and lower case tables. */\n   const\
    \ sljit_u8 *fcc;\n@@ -2317,19 +2320,39 @@ for (i = 0; i < RECURSE_TMP_REG_COUNT;\
    \ i++)\n \n #undef RECURSE_TMP_REG_COUNT\n \n+static BOOL recurse_check_bit(compiler_common\
    \ *common, sljit_sw bit_index)\n+{\n+uint8_t *byte;\n+uint8_t mask;\n+\n+SLJIT_ASSERT((bit_index\
    \ & (sizeof(sljit_sw) - 1)) == 0);\n+\n+bit_index >>= SLJIT_WORD_SHIFT;\n+\n+mask\
    \ = 1 << (bit_index & 0x7);\n+byte = common->recurse_bitset + (bit_index >> 3);\n\
    +\n+if (*byte & mask)\n+  return FALSE;\n+\n+*byte |= mask;\n+return TRUE;\n+}\n\
    +\n static int get_recurse_data_length(compiler_common *common, PCRE2_SPTR cc,\
    \ PCRE2_SPTR ccend,\n   BOOL *needs_control_head, BOOL *has_quit, BOOL *has_accept)\n\
    \ {\n int length = 1;\n-int size;\n+int size, offset;\n PCRE2_SPTR alternative;\n\
    \ BOOL quit_found = FALSE;\n BOOL accept_found = FALSE;\n BOOL setsom_found =\
    \ FALSE;\n BOOL setmark_found = FALSE;\n-BOOL capture_last_found = FALSE;\n BOOL\
    \ control_head_found = FALSE;\n \n+memset(common->recurse_bitset, 0, common->recurse_bitset_size);\n\
    +\n #if defined DEBUG_FORCE_CONTROL_HEAD && DEBUG_FORCE_CONTROL_HEAD\n SLJIT_ASSERT(common->control_head_ptr\
    \ != 0);\n control_head_found = TRUE;\n@@ -2352,15 +2375,17 @@ while (cc < ccend)\n\
    \       setsom_found = TRUE;\n     if (common->mark_ptr != 0)\n       setmark_found\
    \ = TRUE;\n-    if (common->capture_last_ptr != 0)\n-      capture_last_found\
    \ = TRUE;\n+    if (common->capture_last_ptr != 0 && recurse_check_bit(common,\
    \ common->capture_last_ptr))\n+      length++;\n     cc += 1 + LINK_SIZE;\n  \
    \   break;\n \n     case OP_KET:\n-    if (PRIVATE_DATA(cc) != 0)\n+    offset\
    \ = PRIVATE_DATA(cc);\n+    if (offset != 0)\n       {\n-      length++;\n+  \
    \    if (recurse_check_bit(common, offset))\n+        length++;\n       SLJIT_ASSERT(PRIVATE_DATA(cc\
    \ + 1) != 0);\n       cc += PRIVATE_DATA(cc + 1);\n       }\n@@ -2379,39 +2404,55\
    \ @@ while (cc < ccend)\n     case OP_SBRA:\n     case OP_SBRAPOS:\n     case\
    \ OP_SCOND:\n-    length++;\n     SLJIT_ASSERT(PRIVATE_DATA(cc) != 0);\n+    if\
    \ (recurse_check_bit(common, PRIVATE_DATA(cc)))\n+      length++;\n     cc +=\
    \ 1 + LINK_SIZE;\n     break;\n \n     case OP_CBRA:\n     case OP_SCBRA:\n- \
    \   length += 2;\n-    if (common->capture_last_ptr != 0)\n-      capture_last_found\
    \ = TRUE;\n-    if (common->optimized_cbracket[GET2(cc, 1 + LINK_SIZE)] == 0)\n\
    +    offset = GET2(cc, 1 + LINK_SIZE);\n+    if (recurse_check_bit(common, OVECTOR(offset\
    \ << 1)))\n+      {\n+      SLJIT_ASSERT(recurse_check_bit(common, OVECTOR((offset\
    \ << 1) + 1)));\n+      length += 2;\n+      }\n+    if (common->optimized_cbracket[offset]\
    \ == 0 && recurse_check_bit(common, OVECTOR_PRIV(offset)))\n+      length++;\n\
    +    if (common->capture_last_ptr != 0 && recurse_check_bit(common, common->capture_last_ptr))\n\
    \       length++;\n     cc += 1 + LINK_SIZE + IMM2_SIZE;\n     break;\n \n   \
    \  case OP_CBRAPOS:\n     case OP_SCBRAPOS:\n-    length += 2 + 2;\n-    if (common->capture_last_ptr\
    \ != 0)\n-      capture_last_found = TRUE;\n+    offset = GET2(cc, 1 + LINK_SIZE);\n\
    +    if (recurse_check_bit(common, OVECTOR(offset << 1)))\n+      {\n+      SLJIT_ASSERT(recurse_check_bit(common,\
    \ OVECTOR((offset << 1) + 1)));\n+      length += 2;\n+      }\n+    if (recurse_check_bit(common,\
    \ OVECTOR_PRIV(offset)))\n+      length++;\n+    if (recurse_check_bit(common,\
    \ PRIVATE_DATA(cc)))\n+      length++;\n+    if (common->capture_last_ptr != 0\
    \ && recurse_check_bit(common, common->capture_last_ptr))\n+      length++;\n\
    \     cc += 1 + LINK_SIZE + IMM2_SIZE;\n     break;\n \n     case OP_COND:\n \
    \    /* Might be a hidden SCOND. */\n     alternative = cc + GET(cc, 1);\n-  \
    \  if (*alternative == OP_KETRMAX || *alternative == OP_KETRMIN)\n+    if ((*alternative\
    \ == OP_KETRMAX || *alternative == OP_KETRMIN) && recurse_check_bit(common, PRIVATE_DATA(cc)))\n\
    \       length++;\n     cc += 1 + LINK_SIZE;\n     break;\n \n     CASE_ITERATOR_PRIVATE_DATA_1\n\
    -    if (PRIVATE_DATA(cc) != 0)\n+    offset = PRIVATE_DATA(cc);\n+    if (offset\
    \ != 0 && recurse_check_bit(common, offset))\n       length++;\n     cc += 2;\n\
    \ #ifdef SUPPORT_UNICODE\n@@ -2420,38 +2461,55 @@ while (cc < ccend)\n     break;\n\
    \ \n     CASE_ITERATOR_PRIVATE_DATA_2A\n-    if (PRIVATE_DATA(cc) != 0)\n+   \
    \ offset = PRIVATE_DATA(cc);\n+    if (offset != 0 && recurse_check_bit(common,\
    \ offset))\n+      {\n+      SLJIT_ASSERT(recurse_check_bit(common, offset + sizeof(sljit_sw)));\n\
    \       length += 2;\n+      }\n     cc += 2;\n #ifdef SUPPORT_UNICODE\n     if\
    \ (common->utf && HAS_EXTRALEN(cc[-1])) cc += GET_EXTRALEN(cc[-1]);\n #endif\n\
    \     break;\n \n     CASE_ITERATOR_PRIVATE_DATA_2B\n-    if (PRIVATE_DATA(cc)\
    \ != 0)\n+    offset = PRIVATE_DATA(cc);\n+    if (offset != 0 && recurse_check_bit(common,\
    \ offset))\n+      {\n+      SLJIT_ASSERT(recurse_check_bit(common, offset + sizeof(sljit_sw)));\n\
    \       length += 2;\n+      }\n     cc += 2 + IMM2_SIZE;\n #ifdef SUPPORT_UNICODE\n\
    \     if (common->utf && HAS_EXTRALEN(cc[-1])) cc += GET_EXTRALEN(cc[-1]);\n #endif\n\
    \     break;\n \n     CASE_ITERATOR_TYPE_PRIVATE_DATA_1\n-    if (PRIVATE_DATA(cc)\
    \ != 0)\n+    offset = PRIVATE_DATA(cc);\n+    if (offset != 0 && recurse_check_bit(common,\
    \ offset))\n       length++;\n     cc += 1;\n     break;\n \n     CASE_ITERATOR_TYPE_PRIVATE_DATA_2A\n\
    -    if (PRIVATE_DATA(cc) != 0)\n+    offset = PRIVATE_DATA(cc);\n+    if (offset\
    \ != 0 && recurse_check_bit(common, offset))\n+      {\n+      SLJIT_ASSERT(recurse_check_bit(common,\
    \ offset + sizeof(sljit_sw)));\n       length += 2;\n+      }\n     cc += 1;\n\
    \     break;\n \n     CASE_ITERATOR_TYPE_PRIVATE_DATA_2B\n-    if (PRIVATE_DATA(cc)\
    \ != 0)\n+    offset = PRIVATE_DATA(cc);\n+    if (offset != 0 && recurse_check_bit(common,\
    \ offset))\n+      {\n+      SLJIT_ASSERT(recurse_check_bit(common, offset + sizeof(sljit_sw)));\n\
    \       length += 2;\n+      }\n     cc += 1 + IMM2_SIZE;\n     break;\n \n@@\
    \ -2463,7 +2521,9 @@ while (cc < ccend)\n #else\n     size = 1 + 32 / (int)sizeof(PCRE2_UCHAR);\n\
    \ #endif\n-    if (PRIVATE_DATA(cc) != 0)\n+\n+    offset = PRIVATE_DATA(cc);\n\
    +    if (offset != 0 && recurse_check_bit(common, offset))\n       length += get_class_iterator_size(cc\
    \ + size);\n     cc += size;\n     break;\n@@ -2498,8 +2558,7 @@ while (cc < ccend)\n\
    \     case OP_THEN:\n     SLJIT_ASSERT(common->control_head_ptr != 0);\n     quit_found\
    \ = TRUE;\n-    if (!control_head_found)\n-      control_head_found = TRUE;\n\
    +    control_head_found = TRUE;\n     cc++;\n     break;\n \n@@ -2519,8 +2578,6\
    \ @@ SLJIT_ASSERT(cc == ccend);\n \n if (control_head_found)\n   length++;\n-if\
    \ (capture_last_found)\n-  length++;\n if (quit_found)\n   {\n   if (setsom_found)\n\
    @@ -2553,14 +2610,12 @@ sljit_sw shared_srcw[3];\n sljit_sw kept_shared_srcw[2];\n\
    \ int private_count, shared_count, kept_shared_count;\n int from_sp, base_reg,\
    \ offset, i;\n-BOOL setsom_found = FALSE;\n-BOOL setmark_found = FALSE;\n-BOOL\
    \ capture_last_found = FALSE;\n-BOOL control_head_found = FALSE;\n+\n+memset(common->recurse_bitset,\
    \ 0, common->recurse_bitset_size);\n \n #if defined DEBUG_FORCE_CONTROL_HEAD &&\
    \ DEBUG_FORCE_CONTROL_HEAD\n SLJIT_ASSERT(common->control_head_ptr != 0);\n-control_head_found\
    \ = TRUE;\n+recurse_check_bit(common, common->control_head_ptr);\n #endif\n \n\
    \ switch (type)\n@@ -2648,45 +2703,42 @@ while (cc < ccend)\n     {\n     case\
    \ OP_SET_SOM:\n     SLJIT_ASSERT(common->has_set_som);\n-    if (has_quit && !setsom_found)\n\
    +    if (has_quit && recurse_check_bit(common, OVECTOR(0)))\n       {\n      \
    \ kept_shared_srcw[0] = OVECTOR(0);\n       kept_shared_count = 1;\n-      setsom_found\
    \ = TRUE;\n       }\n     cc += 1;\n     break;\n \n     case OP_RECURSE:\n  \
    \   if (has_quit)\n       {\n-      if (common->has_set_som && !setsom_found)\n\
    +      if (common->has_set_som && recurse_check_bit(common, OVECTOR(0)))\n   \
    \      {\n         kept_shared_srcw[0] = OVECTOR(0);\n         kept_shared_count\
    \ = 1;\n-        setsom_found = TRUE;\n         }\n-      if (common->mark_ptr\
    \ != 0 && !setmark_found)\n+      if (common->mark_ptr != 0 && recurse_check_bit(common,\
    \ common->mark_ptr))\n         {\n         kept_shared_srcw[kept_shared_count]\
    \ = common->mark_ptr;\n         kept_shared_count++;\n-        setmark_found =\
    \ TRUE;\n         }\n       }\n-    if (common->capture_last_ptr != 0 && !capture_last_found)\n\
    +    if (common->capture_last_ptr != 0 && recurse_check_bit(common, common->capture_last_ptr))\n\
    \       {\n       shared_srcw[0] = common->capture_last_ptr;\n       shared_count\
    \ = 1;\n-      capture_last_found = TRUE;\n       }\n     cc += 1 + LINK_SIZE;\n\
    \     break;\n \n     case OP_KET:\n-    if (PRIVATE_DATA(cc) != 0)\n+    private_srcw[0]\
    \ = PRIVATE_DATA(cc);\n+    if (private_srcw[0] != 0)\n       {\n-      private_count\
    \ = 1;\n-      private_srcw[0] = PRIVATE_DATA(cc);\n+      if (recurse_check_bit(common,\
    \ private_srcw[0]))\n+        private_count = 1;\n       SLJIT_ASSERT(PRIVATE_DATA(cc\
    \ + 1) != 0);\n       cc += PRIVATE_DATA(cc + 1);\n       }\n@@ -2705,50 +2757,66\
    \ @@ while (cc < ccend)\n     case OP_SBRA:\n     case OP_SBRAPOS:\n     case\
    \ OP_SCOND:\n-    private_count = 1;\n     private_srcw[0] = PRIVATE_DATA(cc);\n\
    +    if (recurse_check_bit(common, private_srcw[0]))\n+      private_count = 1;\n\
    \     cc += 1 + LINK_SIZE;\n     break;\n \n     case OP_CBRA:\n     case OP_SCBRA:\n\
    -    offset = (GET2(cc, 1 + LINK_SIZE)) << 1;\n-    shared_srcw[0] = OVECTOR(offset);\n\
    -    shared_srcw[1] = OVECTOR(offset + 1);\n-    shared_count = 2;\n+    offset\
    \ = GET2(cc, 1 + LINK_SIZE);\n+    shared_srcw[0] = OVECTOR(offset << 1);\n+ \
    \   if (recurse_check_bit(common, shared_srcw[0]))\n+      {\n+      shared_srcw[1]\
    \ = shared_srcw[0] + sizeof(sljit_sw);\n+      SLJIT_ASSERT(recurse_check_bit(common,\
    \ shared_srcw[1]));\n+      shared_count = 2;\n+      }\n \n-    if (common->capture_last_ptr\
    \ != 0 && !capture_last_found)\n+    if (common->capture_last_ptr != 0 && recurse_check_bit(common,\
    \ common->capture_last_ptr))\n       {\n-      shared_srcw[2] = common->capture_last_ptr;\n\
    -      shared_count = 3;\n-      capture_last_found = TRUE;\n+      shared_srcw[shared_count]\
    \ = common->capture_last_ptr;\n+      shared_count++;\n       }\n \n-    if (common->optimized_cbracket[GET2(cc,\
    \ 1 + LINK_SIZE)] == 0)\n+    if (common->optimized_cbracket[offset] == 0)\n \
    \      {\n-      private_count = 1;\n-      private_srcw[0] = OVECTOR_PRIV(GET2(cc,\
    \ 1 + LINK_SIZE));\n+      private_srcw[0] = OVECTOR_PRIV(offset);\n+      if\
    \ (recurse_check_bit(common, private_srcw[0]))\n+        private_count = 1;\n\
    \       }\n+\n     cc += 1 + LINK_SIZE + IMM2_SIZE;\n     break;\n \n     case\
    \ OP_CBRAPOS:\n     case OP_SCBRAPOS:\n-    offset = (GET2(cc, 1 + LINK_SIZE))\
    \ << 1;\n-    shared_srcw[0] = OVECTOR(offset);\n-    shared_srcw[1] = OVECTOR(offset\
    \ + 1);\n-    shared_count = 2;\n+    offset = GET2(cc, 1 + LINK_SIZE);\n+   \
    \ shared_srcw[0] = OVECTOR(offset << 1);\n+    if (recurse_check_bit(common, shared_srcw[0]))\n\
    +      {\n+      shared_srcw[1] = shared_srcw[0] + sizeof(sljit_sw);\n+      SLJIT_ASSERT(recurse_check_bit(common,\
    \ shared_srcw[1]));\n+      shared_count = 2;\n+      }\n \n-    if (common->capture_last_ptr\
    \ != 0 && !capture_last_found)\n+    if (common->capture_last_ptr != 0 && recurse_check_bit(common,\
    \ common->capture_last_ptr))\n       {\n-      shared_srcw[2] = common->capture_last_ptr;\n\
    -      shared_count = 3;\n-      capture_last_found = TRUE;\n+      shared_srcw[shared_count]\
    \ = common->capture_last_ptr;\n+      shared_count++;\n       }\n \n-    private_count\
    \ = 2;\n     private_srcw[0] = PRIVATE_DATA(cc);\n-    private_srcw[1] = OVECTOR_PRIV(GET2(cc,\
    \ 1 + LINK_SIZE));\n+    if (recurse_check_bit(common, private_srcw[0]))\n+  \
    \    private_count = 1;\n+\n+    offset = OVECTOR_PRIV(offset);\n+    if (recurse_check_bit(common,\
    \ offset))\n+      {\n+      private_srcw[private_count] = offset;\n+      private_count++;\n\
    +      }\n     cc += 1 + LINK_SIZE + IMM2_SIZE;\n     break;\n \n@@ -2757,30 +2825,30\
    \ @@ while (cc < ccend)\n     alternative = cc + GET(cc, 1);\n     if (*alternative\
    \ == OP_KETRMAX || *alternative == OP_KETRMIN)\n       {\n-      private_count\
    \ = 1;\n       private_srcw[0] = PRIVATE_DATA(cc);\n+      if (recurse_check_bit(common,\
    \ private_srcw[0]))\n+        private_count = 1;\n       }\n     cc += 1 + LINK_SIZE;\n\
    \     break;\n \n     CASE_ITERATOR_PRIVATE_DATA_1\n-    if (PRIVATE_DATA(cc))\n\
    -      {\n+    private_srcw[0] = PRIVATE_DATA(cc);\n+    if (private_srcw[0] !=\
    \ 0 && recurse_check_bit(common, private_srcw[0]))\n       private_count = 1;\n\
    -      private_srcw[0] = PRIVATE_DATA(cc);\n-      }\n     cc += 2;\n #ifdef SUPPORT_UNICODE\n\
    \     if (common->utf && HAS_EXTRALEN(cc[-1])) cc += GET_EXTRALEN(cc[-1]);\n #endif\n\
    \     break;\n \n     CASE_ITERATOR_PRIVATE_DATA_2A\n-    if (PRIVATE_DATA(cc))\n\
    +    private_srcw[0] = PRIVATE_DATA(cc);\n+    if (private_srcw[0] != 0 && recurse_check_bit(common,\
    \ private_srcw[0]))\n       {\n       private_count = 2;\n-      private_srcw[0]\
    \ = PRIVATE_DATA(cc);\n-      private_srcw[1] = PRIVATE_DATA(cc) + sizeof(sljit_sw);\n\
    +      private_srcw[1] = private_srcw[0] + sizeof(sljit_sw);\n+      SLJIT_ASSERT(recurse_check_bit(common,\
    \ private_srcw[1]));\n       }\n     cc += 2;\n #ifdef SUPPORT_UNICODE\n@@ -2789,11\
    \ +2857,12 @@ while (cc < ccend)\n     break;\n \n     CASE_ITERATOR_PRIVATE_DATA_2B\n\
    -    if (PRIVATE_DATA(cc))\n+    private_srcw[0] = PRIVATE_DATA(cc);\n+    if\
    \ (private_srcw[0] != 0 && recurse_check_bit(common, private_srcw[0]))\n     \
    \  {\n       private_count = 2;\n-      private_srcw[0] = PRIVATE_DATA(cc);\n\
    -      private_srcw[1] = PRIVATE_DATA(cc) + sizeof(sljit_sw);\n+      private_srcw[1]\
    \ = private_srcw[0] + sizeof(sljit_sw);\n+      SLJIT_ASSERT(recurse_check_bit(common,\
    \ private_srcw[1]));\n       }\n     cc += 2 + IMM2_SIZE;\n #ifdef SUPPORT_UNICODE\n\
    @@ -2802,30 +2871,30 @@ while (cc < ccend)\n     break;\n \n     CASE_ITERATOR_TYPE_PRIVATE_DATA_1\n\
    -    if (PRIVATE_DATA(cc))\n-      {\n+    private_srcw[0] = PRIVATE_DATA(cc);\n\
    +    if (private_srcw[0] != 0 && recurse_check_bit(common, private_srcw[0]))\n\
    \       private_count = 1;\n-      private_srcw[0] = PRIVATE_DATA(cc);\n-    \
    \  }\n     cc += 1;\n     break;\n \n     CASE_ITERATOR_TYPE_PRIVATE_DATA_2A\n\
    -    if (PRIVATE_DATA(cc))\n+    private_srcw[0] = PRIVATE_DATA(cc);\n+    if\
    \ (private_srcw[0] != 0 && recurse_check_bit(common, private_srcw[0]))\n     \
    \  {\n       private_count = 2;\n-      private_srcw[0] = PRIVATE_DATA(cc);\n\
    \       private_srcw[1] = private_srcw[0] + sizeof(sljit_sw);\n+      SLJIT_ASSERT(recurse_check_bit(common,\
    \ private_srcw[1]));\n       }\n     cc += 1;\n     break;\n \n     CASE_ITERATOR_TYPE_PRIVATE_DATA_2B\n\
    -    if (PRIVATE_DATA(cc))\n+    private_srcw[0] = PRIVATE_DATA(cc);\n+    if\
    \ (private_srcw[0] != 0 && recurse_check_bit(common, private_srcw[0]))\n     \
    \  {\n       private_count = 2;\n-      private_srcw[0] = PRIVATE_DATA(cc);\n\
    \       private_srcw[1] = private_srcw[0] + sizeof(sljit_sw);\n+      SLJIT_ASSERT(recurse_check_bit(common,\
    \ private_srcw[1]));\n       }\n     cc += 1 + IMM2_SIZE;\n     break;\n@@ -2842,14\
    \ +2911,17 @@ while (cc < ccend)\n       switch(get_class_iterator_size(cc + i))\n\
    \         {\n         case 1:\n-        private_count = 1;\n         private_srcw[0]\
    \ = PRIVATE_DATA(cc);\n         break;\n \n         case 2:\n-        private_count\
    \ = 2;\n         private_srcw[0] = PRIVATE_DATA(cc);\n-        private_srcw[1]\
    \ = private_srcw[0] + sizeof(sljit_sw);\n+        if (recurse_check_bit(common,\
    \ private_srcw[0]))\n+          {\n+          private_count = 2;\n+          private_srcw[1]\
    \ = private_srcw[0] + sizeof(sljit_sw);\n+          SLJIT_ASSERT(recurse_check_bit(common,\
    \ private_srcw[1]));\n+          }\n         break;\n \n         default:\n@@\
    \ -2864,36 +2936,33 @@ while (cc < ccend)\n     case OP_PRUNE_ARG:\n     case\
    \ OP_THEN_ARG:\n     SLJIT_ASSERT(common->mark_ptr != 0);\n-    if (has_quit &&\
    \ !setmark_found)\n+    if (has_quit && recurse_check_bit(common, common->mark_ptr))\n\
    \       {\n       kept_shared_srcw[0] = common->mark_ptr;\n       kept_shared_count\
    \ = 1;\n-      setmark_found = TRUE;\n       }\n-    if (common->control_head_ptr\
    \ != 0 && !control_head_found)\n+    if (common->control_head_ptr != 0 && recurse_check_bit(common,\
    \ common->control_head_ptr))\n       {\n       private_srcw[0] = common->control_head_ptr;\n\
    \       private_count = 1;\n-      control_head_found = TRUE;\n       }\n    \
    \ cc += 1 + 2 + cc[1];\n     break;\n \n     case OP_THEN:\n     SLJIT_ASSERT(common->control_head_ptr\
    \ != 0);\n-    if (!control_head_found)\n+    if (recurse_check_bit(common, common->control_head_ptr))\n\
    \       {\n       private_srcw[0] = common->control_head_ptr;\n       private_count\
    \ = 1;\n-      control_head_found = TRUE;\n       }\n     cc++;\n     break;\n\
    \ \n     default:\n     cc = next_opcode(common, cc);\n     SLJIT_ASSERT(cc !=\
    \ NULL);\n-    break;\n+    continue;\n     }\n \n   if (type != recurse_copy_shared_to_global\
    \ && type != recurse_copy_kept_shared_to_global)\n@@ -13852,6 +13921,7 @@ if (!compiler)\n\
    \ common->compiler = compiler;\n \n /* Main pcre2_jit_exec entry. */\n+SLJIT_ASSERT((private_data_size\
    \ & (sizeof(sljit_sw) - 1)) == 0);\n sljit_emit_enter(compiler, 0, SLJIT_ARGS1(W,\
    \ W), 5, 5, 0, 0, private_data_size);\n \n /* Register init. */\n@@ -14074,20\
    \ +14144,40 @@ common->early_fail_end_ptr = 0;\n common->currententry = common->entries;\n\
    \ common->local_quit_available = TRUE;\n quit_label = common->quit_label;\n-while\
    \ (common->currententry != NULL)\n+if (common->currententry != NULL)\n   {\n-\
    \  /* Might add new entries. */\n-  compile_recurse(common);\n-  if (SLJIT_UNLIKELY(sljit_get_compiler_error(compiler)))\n\
    +  /* A free bit for each private data. */\n+  common->recurse_bitset_size = ((private_data_size\
    \ / (int)sizeof(sljit_sw)) + 7) >> 3;\n+  SLJIT_ASSERT(common->recurse_bitset_size\
    \ > 0);\n+  common->recurse_bitset = (sljit_u8*)SLJIT_MALLOC(common->recurse_bitset_size,\
    \ allocator_data);;\n+\n+  if (common->recurse_bitset != NULL)\n+    {\n+    do\n\
    +      {\n+      /* Might add new entries. */\n+      compile_recurse(common);\n\
    +      if (SLJIT_UNLIKELY(sljit_get_compiler_error(compiler)))\n+        break;\n\
    +      flush_stubs(common);\n+      common->currententry = common->currententry->next;\n\
    +      }\n+    while (common->currententry != NULL);\n+\n+    SLJIT_FREE(common->recurse_bitset,\
    \ allocator_data);\n+    }\n+\n+  if (common->currententry != NULL)\n     {\n\
    +    /* The common->recurse_bitset has been freed. */\n+    SLJIT_ASSERT(sljit_get_compiler_error(compiler)\
    \ || common->recurse_bitset == NULL);\n+\n     sljit_free_compiler(compiler);\n\
    \     SLJIT_FREE(common->optimized_cbracket, allocator_data);\n     SLJIT_FREE(common->private_data_ptrs,\
    \ allocator_data);\n     PRIV(jit_free_rodata)(common->read_only_data_head, allocator_data);\n\
    \     return PCRE2_ERROR_NOMEMORY;\n     }\n-  flush_stubs(common);\n-  common->currententry\
    \ = common->currententry->next;\n   }\n common->local_quit_available = FALSE;\n\
    \ common->quit_label = quit_label;"
  - "--- a/src/pcre2_jit_test.c\n+++ b/src/pcre2_jit_test.c\n@@ -751,6 +751,7 @@ static\
    \ struct regression_test_case regression_test_cases[] = {\n \t{ MU, A, 0, 0, \"\
    ((?(R)a|(?1)){1,3}?)M\", \"aaaM\" },\n \t{ MU, A, 0, 0, \"((.)(?:.|\\\\2(?1))){0}#(?1)#\"\
    , \"#aabbccdde# #aabbccddee#\" },\n \t{ MU, A, 0, 0, \"((.)(?:\\\\2|\\\\2{4}b)){0}#(?:(?1))+#\"\
    , \"#aaaab# #aaaaab#\" },\n+\t{ MU, A, 0, 0 | F_NOMATCH, \"(?1)$((.|\\\\2xx){1,2})\"\
    , \"abc\" },\n \n \t/* 16 bit specific tests. */\n \t{ CM, A, 0, 0 | F_FORCECONV,\
    \ \"\\xc3\\xa1\", \"\\xc3\\x81\\xc3\\xa1\" },"
  identifiers:
  - CVE-2022-1587
  - CWE-125
  overview: An out-of-bounds read vulnerability was discovered in the PCRE2 library
    in the get_recurse_data_length() function of the pcre2_jit_compile.c file. This
    issue affects recursions in JIT-compiled regular expressions caused by duplicate
    data transfers.
  references:
  - source: secalert@redhat.com
    url: https://bugzilla.redhat.com/show_bug.cgi?id=2077983%2C
  - source: secalert@redhat.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/PCRE2Project/pcre2/commit/03654e751e7f0700693526b67dfcadda6b42c9d0
  - source: secalert@redhat.com
    url: https://lists.debian.org/debian-lts-announce/2023/03/msg00014.html
  - source: secalert@redhat.com
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/DWNG2NS3GINO6LQYUVC4BZLUQPJ3DYHA/
  - source: secalert@redhat.com
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/JXINO3KKI5DICQ45E2FKD6MKVMGJLEKJ/
  - source: secalert@redhat.com
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/KAX7767BCUFC7JMDGP7GOQ5GIZCAUGBB/
  - source: secalert@redhat.com
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/M2GLQQUEY5VFM57CFYXVIFOXN2HUZPDM/
  - source: secalert@redhat.com
    tags:
    - Third Party Advisory
    url: https://security.netapp.com/advisory/ntap-20221028-0009/
  title: An out-of-bounds read vulnerability was discovered in the PCRE2 library in
    the get_recurse_data_length() function of the pcre2_jit_compile.c file. This issue
    affects recursions in JIT-compiled regular expressions caused by duplicate data
    transfers.
- diff_content:
  - "--- a/src/cindent.c\n+++ b/src/cindent.c\n@@ -89,7 +89,7 @@ skip_string(char_u\
    \ *p)\n \t\twhile (vim_isdigit(p[i - 1]))   // '\\000'\n \t\t    ++i;\n \t   \
    \ }\n-\t    if (p[i] == '\\'')\t\t    // check for trailing '\n+\t    if (p[i\
    \ - 1] != NUL && p[i] == '\\'')    // check for trailing '\n \t    {\n \t\tp +=\
    \ i;\n \t\tcontinue;"
  - "--- a/src/version.c\n+++ b/src/version.c\n@@ -746,6 +746,8 @@ static char *(features[])\
    \ =\n \n static int included_patches[] =\n {   /* Add new patch number below this\
    \ line */\n+/**/\n+    4968,\n /**/\n     4967,\n /**/"
  identifiers:
  - CVE-2022-1733
  - CWE-122
  overview: Heap-based Buffer Overflow in GitHub repository vim/vim prior to 8.2.4968.
  references:
  - source: security@huntr.dev
    url: http://seclists.org/fulldisclosure/2022/Oct/28
  - source: security@huntr.dev
    tags:
    - Mailing List
    - Third Party Advisory
    url: http://seclists.org/fulldisclosure/2022/Oct/41
  - source: security@huntr.dev
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/vim/vim/commit/60ae0e71490c97f2871a6344aca61cacf220f813
  - source: security@huntr.dev
    tags:
    - Exploit
    - Third Party Advisory
    url: https://huntr.dev/bounties/6ff03b27-472b-4bef-a2bf-410fae65ff0a
  - source: security@huntr.dev
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/BFAZTAT5CZC2R6KYDYA2HBAVEDSIX6MW/
  - source: security@huntr.dev
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/IUPOLEX5GXC733HL4EFYMHFU7NISJJZG/
  - source: security@huntr.dev
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/QKIX5HYKWXWG6QBCPPTPQ53GNOFHSAIS/
  - source: security@huntr.dev
    tags:
    - Third Party Advisory
    url: https://security.gentoo.org/glsa/202208-32
  - source: security@huntr.dev
    url: https://security.gentoo.org/glsa/202305-16
  - source: security@huntr.dev
    tags:
    - Third Party Advisory
    url: https://support.apple.com/kb/HT213488
  title: Heap-based Buffer Overflow in GitHub repository vim/vim prior to 8.2.4968.
- diff_content:
  - "--- a/src/scriptfile.c\n+++ b/src/scriptfile.c\n@@ -1965,15 +1965,16 @@ get_one_sourceline(source_cookie_T\
    \ *sp)\n \t\tbreak;\n \t    buf = (char_u *)ga.ga_data;\n \t    buf[ga.ga_len++]\
    \ = NUL;\n+\t    len = ga.ga_len;\n \t}\n \telse\n \t{\n \t    buf = (char_u *)ga.ga_data;\n\
    \ \t    if (fgets((char *)buf + ga.ga_len, ga.ga_maxlen - ga.ga_len,\n \t\t\t\
    sp->fp) == NULL)\n \t\tbreak;\n+\t    len = ga.ga_len + (int)STRLEN(buf + ga.ga_len);\n\
    \ \t}\n-\tlen = ga.ga_len + (int)STRLEN(buf + ga.ga_len);\n #ifdef USE_CRNL\n\
    \ \t// Ignore a trailing CTRL-Z, when in Dos mode.\tOnly recognize the\n \t//\
    \ CTRL-Z by its own, or after a NL."
  - "--- a/src/version.c\n+++ b/src/version.c\n@@ -746,6 +746,8 @@ static char *(features[])\
    \ =\n \n static int included_patches[] =\n {   /* Add new patch number below this\
    \ line */\n+/**/\n+    4974,\n /**/\n     4973,\n /**/"
  identifiers:
  - CVE-2022-1769
  - CWE-126
  overview: Buffer Over-read in GitHub repository vim/vim prior to 8.2.4974.
  references:
  - source: security@huntr.dev
    tags:
    - Mailing List
    - Third Party Advisory
    url: http://seclists.org/fulldisclosure/2022/Oct/28
  - source: security@huntr.dev
    tags:
    - Mailing List
    - Third Party Advisory
    url: http://seclists.org/fulldisclosure/2022/Oct/41
  - source: security@huntr.dev
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/vim/vim/commit/4748c4bd64610cf943a431d215bb1aad51f8d0b4
  - source: security@huntr.dev
    tags:
    - Third Party Advisory
    url: https://huntr.dev/bounties/522076b2-96cb-4df6-a504-e6e2f64c171c
  - source: security@huntr.dev
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/BFAZTAT5CZC2R6KYDYA2HBAVEDSIX6MW/
  - source: security@huntr.dev
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/IUPOLEX5GXC733HL4EFYMHFU7NISJJZG/
  - source: security@huntr.dev
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/QKIX5HYKWXWG6QBCPPTPQ53GNOFHSAIS/
  - source: security@huntr.dev
    tags:
    - Third Party Advisory
    url: https://security.gentoo.org/glsa/202208-32
  - source: security@huntr.dev
    tags:
    - Third Party Advisory
    url: https://security.gentoo.org/glsa/202305-16
  - source: security@huntr.dev
    tags:
    - Third Party Advisory
    url: https://support.apple.com/kb/HT213488
  title: Buffer Over-read in GitHub repository vim/vim prior to 8.2.4974.
- diff_content:
  - "--- a/internal/providers/virtualbox/virtualbox.c\n+++ b/internal/providers/virtualbox/virtualbox.c\n\
    @@ -24,6 +24,10 @@\n #include <errno.h>\n #include \"virtualbox.h\"\n \n+// From\
    \ virtualbox/include/VBox/HostServices/GuestPropertySvc.h\n+#define GUEST_PROP_FN_GET_PROP\
    \ 1\n+#define GUEST_PROP_FN_DEL_PROP 4\n+\n static void _cleanup_close(int *fd)\
    \ {\n \tif (*fd != -1) {\n \t\tclose(*fd);\n@@ -86,13 +90,16 @@ static int connect(int\
    \ fd, uint32_t *client_id) {\n }\n \n static int get_prop(int fd, uint32_t client_id,\
    \ const char *name, void **value, size_t *size) {\n+\t// xref VbglR3GuestPropRead()\
    \ in\n+\t// virtualbox/src/VBox/Additions/common/VBoxGuest/lib/VBoxGuestR3LibGuestProp.cpp\n\
    +\n \t// init header\n \tsize_t msg_size = sizeof(struct vbg_ioctl_hgcm_call)\
    \ + 4 * sizeof(struct vmmdev_hgcm_function_parameter64);\n \tstruct vbg_ioctl_hgcm_call\
    \ _cleanup_free_ *msg = calloc(1, msg_size);\n \t// init_header re-adds the size\
    \ of msg->hdr\n \tinit_header(&msg->hdr, msg_size - sizeof(msg->hdr), msg_size\
    \ - sizeof(msg->hdr));\n \tmsg->client_id = client_id;\n-\tmsg->function = 1;\
    \     // GUEST_PROP_FN_GET_PROP\n+\tmsg->function = GUEST_PROP_FN_GET_PROP;\n\
    \ \tmsg->timeout_ms = -1;  // inf\n \tmsg->interruptible = 1;\n \tmsg->parm_count\
    \ = 4;\n@@ -147,6 +154,38 @@ static int get_prop(int fd, uint32_t client_id, const\
    \ char *name, void **value,\n \t}\n }\n \n+static int del_prop(int fd, uint32_t\
    \ client_id, const char *name) {\n+\t// xref VbglR3GuestPropDelete() in\n+\t//\
    \ virtualbox/src/VBox/Additions/common/VBoxGuest/lib/VBoxGuestR3LibGuestProp.cpp\n\
    +\n+\t// init header\n+\tsize_t msg_size = sizeof(struct vbg_ioctl_hgcm_call)\
    \ + sizeof(struct vmmdev_hgcm_function_parameter64);\n+\tstruct vbg_ioctl_hgcm_call\
    \ _cleanup_free_ *msg = calloc(1, msg_size);\n+\t// init_header re-adds the size\
    \ of msg->hdr\n+\tinit_header(&msg->hdr, msg_size - sizeof(msg->hdr), msg_size\
    \ - sizeof(msg->hdr));\n+\tmsg->client_id = client_id;\n+\tmsg->function = GUEST_PROP_FN_DEL_PROP;\n\
    +\tmsg->timeout_ms = -1;  // inf\n+\tmsg->interruptible = 1;\n+\tmsg->parm_count\
    \ = 1;\n+\n+\t// init arguments\n+\tstruct vmmdev_hgcm_function_parameter64 *params\
    \ = (void *) (msg + 1);\n+\t// property name (in)\n+\tparams[0].type = VMMDEV_HGCM_PARM_TYPE_LINADDR_IN;\n\
    +\tparams[0].u.pointer.size = strlen(name) + 1;\n+\tparams[0].u.pointer.u.linear_addr\
    \ = (uintptr_t) name;\n+\n+\t// delete value\n+\tif (ioctl(fd, VBG_IOCTL_HGCM_CALL_64(msg_size),\
    \ msg)) {\n+\t\treturn VERR_GENERAL_FAILURE;\n+\t}\n+\tif (msg->hdr.rc != VINF_SUCCESS)\
    \ {\n+\t\treturn msg->hdr.rc;\n+\t}\n+\treturn VINF_SUCCESS;\n+}\n+\n static int\
    \ disconnect(int fd, uint32_t client_id) {\n \tstruct vbg_ioctl_hgcm_disconnect\
    \ msg = {\n \t\t.u = {\n@@ -162,7 +201,7 @@ static int disconnect(int fd, uint32_t\
    \ client_id) {\n \treturn msg.hdr.rc;\n }\n \n-int virtualbox_get_guest_property(char\
    \ *name, void **value, size_t *size) {\n+static int start_connection(uint32_t\
    \ *client_id) {\n \t// clear any previous garbage in errno for error returns\n\
    \ \terrno = 0;\n \n@@ -179,12 +218,26 @@ int virtualbox_get_guest_property(char\
    \ *name, void **value, size_t *size) {\n \t}\n \n \t// connect to property service\n\
    -\tuint32_t client_id;\n-\tret = connect(fd, &client_id);\n+\tret = connect(fd,\
    \ client_id);\n \tif (ret != VINF_SUCCESS) {\n \t\treturn ret;\n \t}\n \n+\t//\
    \ return fd\n+\tret = fd;\n+\tfd = -1;\n+\treturn ret;\n+}\n+\n+int virtualbox_get_guest_property(char\
    \ *name, void **value, size_t *size) {\n+\t// connect\n+\tuint32_t client_id;\n\
    +\tint ret = start_connection(&client_id);\n+\tif (ret < 0) {\n+\t\treturn ret;\n\
    +\t}\n+\tint _cleanup_close_ fd = ret;\n+\n \t// get property\n \tret = get_prop(fd,\
    \ client_id, name, value, size);\n \tif (ret != VINF_SUCCESS) {\n@@ -206,3 +259,32\
    \ @@ int virtualbox_get_guest_property(char *name, void **value, size_t *size)\
    \ {\n \terrno = 0;\n \treturn 0;\n }\n+\n+int virtualbox_delete_guest_property(char\
    \ *name) {\n+\t// connect\n+\tuint32_t client_id;\n+\tint ret = start_connection(&client_id);\n\
    +\tif (ret < 0) {\n+\t\treturn ret;\n+\t}\n+\tint _cleanup_close_ fd = ret;\n\
    +\n+\t// delete property\n+\tret = del_prop(fd, client_id, name);\n+\tif (ret\
    \ != VINF_SUCCESS) {\n+\t\tdisconnect(fd, client_id);\n+\t\treturn ret;\n+\t}\n\
    +\n+\t// disconnect\n+\tret = disconnect(fd, client_id);\n+\tif (ret != VINF_SUCCESS)\
    \ {\n+\t\t// we could ignore the failure, but better to make sure bugs\n+\t\t\
    // are noticed\n+\t\treturn ret;\n+\t}\n+\n+\t// for clarity, ensure the Go error\
    \ return is nil\n+\terrno = 0;\n+\treturn 0;\n+}"
  identifiers:
  - CVE-2022-1706
  - CWE-863
  overview: A vulnerability was found in Ignition where ignition configs are accessible
    from unprivileged containers in VMs running on VMware products. This issue is
    only relevant in user environments where the Ignition config contains secrets.
    The highest threat from this vulnerability is to data confidentiality. Possible
    workaround is to not put secrets in the Ignition config.
  references:
  - source: secalert@redhat.com
    tags:
    - Issue Tracking
    - Vendor Advisory
    url: https://bugzilla.redhat.com/show_bug.cgi?id=2082274
  - source: secalert@redhat.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/coreos/ignition/commit/4b70b44b430ecf8377a276e89b5acd3a6957d4ea
  - source: secalert@redhat.com
    tags:
    - Third Party Advisory
    url: https://github.com/coreos/ignition/issues/1300
  - source: secalert@redhat.com
    tags:
    - Third Party Advisory
    url: https://github.com/coreos/ignition/issues/1315
  - source: secalert@redhat.com
    tags:
    - Third Party Advisory
    url: https://github.com/coreos/ignition/pull/1350
  - source: secalert@redhat.com
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/LY7LKGMQMXV6DGD263YQHNSLOJJ5VLV5/
  - source: secalert@redhat.com
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/NP765L7TJI7CD4XVOHUWZVRYRH3FYBOR/
  - source: secalert@redhat.com
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/T5QQXRGQKTN4YX2ZF3GQNEBDEOKJGCN3/
  title: A vulnerability was found in Ignition where ignition configs are accessible
    from unprivileged containers in VMs running on VMware products. This issue is
    only relevant in user environments where the Ignition config contains secrets.
    The highest threat from this vulnerability is to data confidentiality. Possible
    workaround is to not put secrets in the Ignition config.
- diff_content:
  - "--- a/src/change.c\n+++ b/src/change.c\n@@ -548,6 +548,9 @@ changed_common(\n\
    \ \tcurwin->w_changelistidx = curbuf->b_changelistlen;\n     }\n \n+    if (VIsual_active)\n\
    +\tcheck_visual_pos();\n+\n     FOR_ALL_TAB_WINDOWS(tp, wp)\n     {\n \tif (wp->w_buffer\
    \ == curbuf)"
  - "--- a/src/edit.c\n+++ b/src/edit.c\n@@ -2541,16 +2541,8 @@ stop_insert(\n \n\
    \ \t    // <C-S-Right> may have started Visual mode, adjust the position for\n\
    \ \t    // deleted characters.\n-\t    if (VIsual_active && VIsual.lnum == curwin->w_cursor.lnum)\n\
    -\t    {\n-\t\tint len = (int)STRLEN(ml_get_curline());\n-\n-\t\tif (VIsual.col\
    \ > len)\n-\t\t{\n-\t\t    VIsual.col = len;\n-\t\t    VIsual.coladd = 0;\n-\t\
    \t}\n-\t    }\n+\t    if (VIsual_active)\n+\t\tcheck_visual_pos();\n \t}\n   \
    \  }\n     did_ai = FALSE;"
  - "--- a/src/misc2.c\n+++ b/src/misc2.c\n@@ -622,6 +622,31 @@ check_cursor(void)\n\
    \     check_cursor_col();\n }\n \n+/*\n+ * Check if VIsual position is valid,\
    \ correct it if not.\n+ * Can be called when in Visual mode and a change has been\
    \ made.\n+ */\n+    void\n+check_visual_pos(void)\n+{\n+    if (VIsual.lnum >\
    \ curbuf->b_ml.ml_line_count)\n+    {\n+\tVIsual.lnum = curbuf->b_ml.ml_line_count;\n\
    +\tVIsual.col = 0;\n+\tVIsual.coladd = 0;\n+    }\n+    else\n+    {\n+\tint len\
    \ = (int)STRLEN(ml_get(VIsual.lnum));\n+\n+\tif (VIsual.col > len)\n+\t{\n+\t\
    \    VIsual.col = len;\n+\t    VIsual.coladd = 0;\n+\t}\n+    }\n+}\n+\n #if defined(FEAT_TEXTOBJ)\
    \ || defined(PROTO)\n /*\n  * Make sure curwin->w_cursor is not on the NUL at\
    \ the end of the line.\n@@ -2416,7 +2441,7 @@ get_user_name(char_u *buf, int len)\n\
    \     return OK;\n }\n \n-#if defined(EXITFREE) || defined(PROTOS)\n+#if defined(EXITFREE)\
    \ || defined(PROTO)\n /*\n  * Free the memory allocated by get_user_name()\n \
    \ */"
  - "--- a/src/version.c\n+++ b/src/version.c\n@@ -746,6 +746,8 @@ static char *(features[])\
    \ =\n \n static int included_patches[] =\n {   /* Add new patch number below this\
    \ line */\n+/**/\n+    4969,\n /**/\n     4968,\n /**/"
  identifiers:
  - CVE-2022-1735
  - CWE-120
  overview: Classic Buffer Overflow in GitHub repository vim/vim prior to 8.2.4969.
  references:
  - source: security@huntr.dev
    url: http://seclists.org/fulldisclosure/2022/Oct/28
  - source: security@huntr.dev
    tags:
    - Mailing List
    - Third Party Advisory
    url: http://seclists.org/fulldisclosure/2022/Oct/41
  - source: security@huntr.dev
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/vim/vim/commit/7ce5b2b590256ce53d6af28c1d203fb3bc1d2d97
  - source: security@huntr.dev
    tags:
    - Exploit
    - Patch
    - Third Party Advisory
    url: https://huntr.dev/bounties/c9f85608-ff11-48e4-933d-53d1759d44d9
  - source: security@huntr.dev
    tags:
    - Third Party Advisory
    url: https://security.gentoo.org/glsa/202208-32
  - source: security@huntr.dev
    url: https://security.gentoo.org/glsa/202305-16
  - source: security@huntr.dev
    tags:
    - Third Party Advisory
    url: https://support.apple.com/kb/HT213488
  title: Classic Buffer Overflow in GitHub repository vim/vim prior to 8.2.4969.
- diff_content:
  - "--- a/src/bifs/memory_decoder.c\n+++ b/src/bifs/memory_decoder.c\n@@ -178,7 +178,12\
    \ @@ static GF_Err BM_ParseGlobalQuantizer(GF_BifsDecoder *codec, GF_BitStream\
    \ *bs, G\n \tcodec->scenegraph->global_qp = NULL;\n \n \tif (gf_node_get_tag(node)\
    \ != TAG_MPEG4_QuantizationParameter) {\n-\t\tgf_node_unregister(node, NULL);\n\
    +\t\t//if node was just created (num_instances == 0), unregister\n+\t\t//otherwise\
    \ (USE node) don't do anything\n+\t\tif (!node->sgprivate->num_instances) {\n\
    +\t\t\tnode->sgprivate->num_instances = 1;\n+\t\t\tgf_node_unregister(node, NULL);\n\
    +\t\t}\n \t\treturn GF_NON_COMPLIANT_BITSTREAM;\n \t}\n \n@@ -188,7 +193,8 @@\
    \ static GF_Err BM_ParseGlobalQuantizer(GF_BifsDecoder *codec, GF_BitStream *bs,\
    \ G\n \tcodec->scenegraph->global_qp = node;\n \n \t/*register TWICE: once for\
    \ the command, and for the scenegraph globalQP*/\n-\tnode->sgprivate->num_instances\
    \ = 2;\n+\tgf_node_unregister(node, NULL);\n+\tgf_node_unregister(node, NULL);\n\
    \ \n \tcom = gf_sg_command_new(codec->current_graph, GF_SG_GLOBAL_QUANTIZER);\n\
    \ \tinf = gf_sg_command_field_new(com);"
  identifiers:
  - CVE-2022-1795
  - CWE-416
  overview: Use After Free in GitHub repository gpac/gpac prior to v2.1.0-DEV.
  references:
  - source: security@huntr.dev
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/gpac/gpac/commit/c535bad50d5812d27ee5b22b54371bddec411514
  - source: security@huntr.dev
    tags:
    - Exploit
    - Third Party Advisory
    url: https://huntr.dev/bounties/9c312763-41a6-4fc7-827b-269eb86efcbc
  - source: security@huntr.dev
    url: https://www.debian.org/security/2023/dsa-5411
  title: Use After Free in GitHub repository gpac/gpac prior to v2.1.0-DEV.
- diff_content:
  - "--- a/drivers/nfc/nfcmrvl/main.c\n+++ b/drivers/nfc/nfcmrvl/main.c\n@@ -183,6\
    \ +183,7 @@ void nfcmrvl_nci_unregister_dev(struct nfcmrvl_private *priv)\n {\n\
    \ \tstruct nci_dev *ndev = priv->ndev;\n \n+\tnci_unregister_device(ndev);\n \t\
    if (priv->ndev->nfc_dev->fw_download_in_progress)\n \t\tnfcmrvl_fw_dnld_abort(priv);\n\
    \ \n@@ -191,7 +192,6 @@ void nfcmrvl_nci_unregister_dev(struct nfcmrvl_private\
    \ *priv)\n \tif (gpio_is_valid(priv->config.reset_n_io))\n \t\tgpio_free(priv->config.reset_n_io);\n\
    \ \n-\tnci_unregister_device(ndev);\n \tnci_free_device(ndev);\n \tkfree(priv);\n\
    \ }"
  identifiers:
  - CVE-2022-1734
  - CWE-416
  overview: A flaw in Linux Kernel found in nfcmrvl_nci_unregister_dev() in drivers/nfc/nfcmrvl/main.c
    can lead to use after free both read or write when non synchronized between cleanup
    routine and firmware download routine.
  references:
  - source: secalert@redhat.com
    tags:
    - Exploit
    - Mailing List
    - Patch
    - Third Party Advisory
    url: http://www.openwall.com/lists/oss-security/2022/06/05/4
  - source: secalert@redhat.com
    tags:
    - Exploit
    - Mailing List
    - Patch
    - Third Party Advisory
    url: http://www.openwall.com/lists/oss-security/2022/06/09/1
  - source: secalert@redhat.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/torvalds/linux/commit/d270453a0d9ec10bb8a802a142fb1b3601a83098
  - source: secalert@redhat.com
    tags:
    - Mailing List
    - Third Party Advisory
    url: https://lists.debian.org/debian-lts-announce/2022/07/msg00000.html
  - source: secalert@redhat.com
    tags:
    - Third Party Advisory
    url: https://security.netapp.com/advisory/ntap-20220707-0007/
  - source: secalert@redhat.com
    tags:
    - Third Party Advisory
    url: https://www.debian.org/security/2022/dsa-5173
  title: A flaw in Linux Kernel found in nfcmrvl_nci_unregister_dev() in drivers/nfc/nfcmrvl/main.c
    can lead to use after free both read or write when non synchronized between cleanup
    routine and firmware download routine.
- diff_content:
  - "--- a/src/ex_getln.c\n+++ b/src/ex_getln.c\n@@ -1581,6 +1581,7 @@ getcmdline_int(\n\
    \     int\t\tindent,\t\t// indent for inside conditionals\n     int\t\tclear_ccline)\t\
    // clear ccline first\n {\n+    static int\tdepth = 0;\t    // call depth\n  \
    \   int\t\tc;\n     int\t\ti;\n     int\t\tj;\n@@ -1611,6 +1612,9 @@ getcmdline_int(\n\
    \     int\t\tcmdline_type;\n     int\t\twild_type;\n \n+    // one recursion level\
    \ deeper\n+    ++depth;\n+\n     if (ccline.cmdbuff != NULL)\n     {\n \t// Being\
    \ called recursively.  Since ccline is global, we need to save\n@@ -1641,6 +1645,13\
    \ @@ getcmdline_int(\n     if (init_ccline(firstc, indent) != OK)\n \tgoto theend;\t\
    // out of memory\n \n+    if (depth == 50)\n+    {\n+\t// Somehow got into a loop\
    \ recursively calling getcmdline(), bail out.\n+\temsg(_(e_command_too_recursive));\n\
    +\tgoto theend;\n+    }\n+\n     ExpandInit(&xpc);\n     ccline.xpc = &xpc;\n\
    \ \n@@ -2576,6 +2587,7 @@ getcmdline_int(\n     {\n \tchar_u *p = ccline.cmdbuff;\n\
    \ \n+\t--depth;\n \tif (did_save_ccline)\n \t    restore_cmdline(&save_ccline);\n\
    \ \telse"
  - "--- a/src/version.c\n+++ b/src/version.c\n@@ -746,6 +746,8 @@ static char *(features[])\
    \ =\n \n static int included_patches[] =\n {   /* Add new patch number below this\
    \ line */\n+/**/\n+    4975,\n /**/\n     4974,\n /**/"
  identifiers:
  - CVE-2022-1771
  - CWE-674
  overview: Uncontrolled Recursion in GitHub repository vim/vim prior to 8.2.4975.
  references:
  - source: security@huntr.dev
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/vim/vim/commit/51f0bfb88a3554ca2dde777d78a59880d1ee37a8
  - source: security@huntr.dev
    tags:
    - Exploit
    - Third Party Advisory
    url: https://huntr.dev/bounties/faa74175-5317-4b71-a363-dfc39094ecbb
  - source: security@huntr.dev
    tags:
    - Third Party Advisory
    url: https://security.gentoo.org/glsa/202208-32
  - source: security@huntr.dev
    url: https://security.gentoo.org/glsa/202305-16
  title: Uncontrolled Recursion in GitHub repository vim/vim prior to 8.2.4975.
- diff_content:
  - "--- a/src/ex_cmds.c\n+++ b/src/ex_cmds.c\n@@ -4412,12 +4412,17 @@ ex_substitute(exarg_T\
    \ *eap)\n \t\t// Save flags for recursion.  They can change for e.g.\n \t\t//\
    \ :s/^/\\=execute(\"s#^##gn\")\n \t\tsubflags_save = subflags;\n+\n+\t\t// Disallow\
    \ changing text or switching window in an expression.\n+\t\t++textwinlock;\n #endif\n\
    \ \t\t// get length of substitution part\n \t\tsublen = vim_regsub_multi(&regmatch,\n\
    \ \t\t\t\t    sub_firstlnum - regmatch.startpos[0].lnum,\n \t\t\t       sub, sub_firstline,\
    \ FALSE, magic_isset(), TRUE);\n #ifdef FEAT_EVAL\n+\t\t--textwinlock;\n+\n \t\
    \t// If getting the substitute string caused an error, don't do\n \t\t// the replacement.\n\
    \ \t\t// Don't keep flags set by a recursive call.\n@@ -4518,9 +4523,15 @@ ex_substitute(exarg_T\
    \ *eap)\n \t\tmch_memmove(new_end, sub_firstline + copycol, (size_t)copy_len);\n\
    \ \t\tnew_end += copy_len;\n \n+#ifdef FEAT_EVAL\n+\t\t++textwinlock;\n+#endif\n\
    \ \t\t(void)vim_regsub_multi(&regmatch,\n \t\t\t\t    sub_firstlnum - regmatch.startpos[0].lnum,\n\
    \ \t\t\t\t      sub, new_end, TRUE, magic_isset(), TRUE);\n+#ifdef FEAT_EVAL\n\
    +\t\t--textwinlock;\n+#endif\n \t\tsub_nsubs++;\n \t\tdid_sub = TRUE;\n "
  - "--- a/src/version.c\n+++ b/src/version.c\n@@ -746,6 +746,8 @@ static char *(features[])\
    \ =\n \n static int included_patches[] =\n {   /* Add new patch number below this\
    \ line */\n+/**/\n+    4977,\n /**/\n     4976,\n /**/"
  identifiers:
  - CVE-2022-1785
  - CWE-787
  overview: Out-of-bounds Write in GitHub repository vim/vim prior to 8.2.4977.
  references:
  - source: security@huntr.dev
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/vim/vim/commit/e2bd8600b873d2cd1f9d667c28cba8b1dba18839
  - source: security@huntr.dev
    tags:
    - Exploit
    - Third Party Advisory
    url: https://huntr.dev/bounties/8c969cba-eef2-4943-b44a-4e3089599109
  - source: security@huntr.dev
    tags:
    - Mailing List
    - Third Party Advisory
    url: https://lists.debian.org/debian-lts-announce/2022/11/msg00032.html
  - source: security@huntr.dev
    tags:
    - Third Party Advisory
    url: https://security.gentoo.org/glsa/202208-32
  - source: security@huntr.dev
    url: https://security.gentoo.org/glsa/202305-16
  title: Out-of-bounds Write in GitHub repository vim/vim prior to 8.2.4977.
- diff_content:
  - "--- a/src/version.c\n+++ b/src/version.c\n@@ -746,6 +746,8 @@ static char *(features[])\
    \ =\n \n static int included_patches[] =\n {   /* Add new patch number below this\
    \ line */\n+/**/\n+    4979,\n /**/\n     4978,\n /**/"
  - "--- a/src/window.c\n+++ b/src/window.c\n@@ -579,9 +579,16 @@ do_window(\n \t\t\
    CHECK_CMDWIN;\n \t\tif ((len = find_ident_under_cursor(&ptr, FIND_IDENT)) == 0)\n\
    \ \t\t    break;\n+\n+\t\t// Make a copy, if the line was changed it will be freed.\n\
    +\t\tptr = vim_strnsave(ptr, len);\n+\t\tif (ptr == NULL)\n+\t\t    break;\n+\n\
    \ \t\tfind_pattern_in_path(ptr, 0, len, TRUE,\n \t\t\tPrenum == 0 ? TRUE : FALSE,\
    \ type,\n \t\t\tPrenum1, ACTION_SPLIT, (linenr_T)1, (linenr_T)MAXLNUM);\n+\t\t\
    vim_free(ptr);\n \t\tcurwin->w_set_curswant = TRUE;\n \t\tbreak;\n #endif"
  identifiers:
  - CVE-2022-1796
  - CWE-416
  overview: Use After Free in GitHub repository vim/vim prior to 8.2.4979.
  references:
  - source: security@huntr.dev
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/vim/vim/commit/28d032cc688ccfda18c5bbcab8b50aba6e18cde5
  - source: security@huntr.dev
    tags:
    - Exploit
    - Third Party Advisory
    url: https://huntr.dev/bounties/f6739b58-49f9-4056-a843-bf76bbc1253e
  - source: security@huntr.dev
    tags:
    - Third Party Advisory
    url: https://security.gentoo.org/glsa/202208-32
  - source: security@huntr.dev
    tags:
    - Third Party Advisory
    url: https://security.gentoo.org/glsa/202305-16
  title: Use After Free in GitHub repository vim/vim prior to 8.2.4979.
- diff_content:
  - "--- a/src/generator/config/nodemanip.cpp\n+++ b/src/generator/config/nodemanip.cpp\n\
    @@ -51,7 +51,7 @@ int addNodes(std::string link, std::vector<Proxy> &allNodes,\
    \ int groupID, parse_\n     link = replaceAllDistinct(link, \"\\\"\", \"\");\n\
    \ \n     /// script:filepath,arg1,arg2,...\n-    script_safe_runner(parse_set.js_runtime,\
    \ parse_set.js_context, [&](qjs::Context &ctx)\n+    if(authorized) script_safe_runner(parse_set.js_runtime,\
    \ parse_set.js_context, [&](qjs::Context &ctx)\n     {\n         if(startsWith(link,\
    \ \"script:\")) /// process subscription with script\n         {\n@@ -380,7 +380,7\
    \ @@ void nodeRename(Proxy &node, const RegexMatchConfigs &rename_array, extra_settin\n\
    \ \n     for(const RegexMatchConfig &x : rename_array)\n     {\n-        if(!x.Script.empty())\n\
    +        if(!x.Script.empty() && ext.authorized)\n         {\n             script_safe_runner(ext.js_runtime,\
    \ ext.js_context, [&](qjs::Context &ctx)\n             {\n@@ -432,7 +432,7 @@\
    \ std::string addEmoji(const Proxy &node, const RegexMatchConfigs &emoji_array,\
    \ ex\n \n     for(const RegexMatchConfig &x : emoji_array)\n     {\n-        if(!x.Script.empty())\n\
    +        if(!x.Script.empty() && ext.authorized)\n         {\n             std::string\
    \ result;\n             script_safe_runner(ext.js_runtime, ext.js_context, [&](qjs::Context\
    \ &ctx)\n@@ -481,7 +481,7 @@ void preprocessNodes(std::vector<Proxy> &nodes, extra_settings\
    \ &ext)\n     if(ext.sort_flag)\n     {\n         bool failed = true;\n-     \
    \   if(ext.sort_script.size())\n+        if(ext.sort_script.size() && ext.authorized)\n\
    \         {\n             std::string script = ext.sort_script;\n            \
    \ if(startsWith(script, \"path:\"))"
  - "--- a/src/generator/config/subexport.cpp\n+++ b/src/generator/config/subexport.cpp\n\
    @@ -183,7 +183,7 @@ void groupGenerate(const std::string &rule, std::vector<Proxy>\
    \ &nodelist, string\n         filtered_nodelist.emplace_back(rule.substr(2));\n\
    \     }\n #ifndef NO_JS_RUNTIME\n-    else if(startsWith(rule, \"script:\"))\n\
    +    else if(startsWith(rule, \"script:\") && ext.authorized)\n     {\n      \
    \   script_safe_runner(ext.js_runtime, ext.js_context, [&](qjs::Context &ctx){\n\
    \             std::string script = fileGet(rule.substr(7), true);"
  - "--- a/src/handler/interfaces.cpp\n+++ b/src/handler/interfaces.cpp\n@@ -407,6\
    \ +407,7 @@ std::string subconverter(RESPONSE_CALLBACK_ARGS)\n     std::string\
    \ proxy = parseProxy(global.proxySubscription);\n \n     /// check other flags\n\
    +    ext.authorized = authorized;\n     ext.append_proxy_type = argAppendType.get(global.appendType);\n\
    \     if((argTarget == \"clash\" || argTarget == \"clashr\") && argGenClashScript.is_undef())\n\
    \         argExpandRulesets.define(true);"
  - "--- a/src/handler/settings.cpp\n+++ b/src/handler/settings.cpp\n@@ -577,6 +577,7\
    \ @@ void readYAMLConf(YAML::Node &node)\n         node[\"advanced\"][\"async_fetch_ruleset\"\
    ] >> global.asyncFetchRuleset;\n         node[\"advanced\"][\"skip_failed_links\"\
    ] >> global.skipFailedLinks;\n     }\n+    writeLog(0, \"Load preference settings\
    \ in YAML format completed.\", LOG_LEVEL_INFO);\n }\n \n template <class T, class...\
    \ U>\n@@ -786,13 +787,14 @@ void readTOMLConf(toml::value &root)\n     {\n   \
    \      global.cacheSubscription = global.cacheConfig = global.cacheRuleset = 0;\n\
    \     }\n+\n+    writeLog(0, \"Load preference settings in TOML format completed.\"\
    , LOG_LEVEL_INFO);\n }\n \n void readConf()\n {\n     guarded_mutex guard(gMutexConfigure);\n\
    -    //std::cerr<<\"Reading preference settings...\"<<std::endl;\n-    writeLog(0,\
    \ \"Reading preference settings...\", LOG_LEVEL_INFO);\n+    writeLog(0, \"Loading\
    \ preference settings...\", LOG_LEVEL_INFO);\n \n     eraseElements(global.excludeRemarks);\n\
    \     eraseElements(global.includeRemarks);\n@@ -815,11 +817,14 @@ void readConf()\n\
    \     catch (YAML::Exception &e)\n     {\n         //ignore yaml parse error\n\
    +        writeLog(0, e.what(), LOG_LEVEL_DEBUG);\n+        writeLog(0, \"Unable\
    \ to load preference settings as YAML.\", LOG_LEVEL_DEBUG);\n     }\n     catch\
    \ (toml::exception &e)\n     {\n         //ignore toml parse error\n         writeLog(0,\
    \ e.what(), LOG_LEVEL_DEBUG);\n+        writeLog(0, \"Unable to load preference\
    \ settings as TOML.\", LOG_LEVEL_DEBUG);\n     }\n \n     INIReader ini;\n@@ -828,8\
    \ +833,7 @@ void readConf()\n     int retVal = ini.ParseFile(global.prefPath);\n\
    \     if(retVal != INIREADER_EXCEPTION_NONE)\n     {\n-        //std::cerr<<\"\
    Unable to load preference settings. Reason: \"<<ini.GetLastError()<<\"\\n\";\n\
    -        writeLog(0, \"Unable to load preference settings. Reason: \" + ini.GetLastError(),\
    \ LOG_LEVEL_FATAL);\n+        writeLog(0, \"Unable to load preference settings\
    \ as INI. Reason: \" + ini.GetLastError(), LOG_LEVEL_FATAL);\n         return;\n\
    \     }\n \n@@ -1070,8 +1074,7 @@ void readConf()\n     ini.GetBoolIfExist(\"\
    async_fetch_ruleset\", global.asyncFetchRuleset);\n     ini.GetBoolIfExist(\"\
    skip_failed_links\", global.skipFailedLinks);\n \n-    //std::cerr<<\"Read preference\
    \ settings completed.\"<<std::endl;\n-    writeLog(0, \"Read preference settings\
    \ completed.\", LOG_LEVEL_INFO);\n+    writeLog(0, \"Load preference settings\
    \ in INI format completed.\", LOG_LEVEL_INFO);\n }\n \n int loadExternalYAML(YAML::Node\
    \ &node, ExternalConfig &ext)"
  identifiers:
  - CVE-2022-28927
  - CWE-434
  overview: A remote code execution (RCE) vulnerability in Subconverter v0.7.2 allows
    attackers to execute arbitrary code via crafted config and url parameters.
  references:
  - source: cve@mitre.org
    tags:
    - Exploit
    - Patch
    - Third Party Advisory
    url: https://gist.github.com/CwithW/01a726e5af709655d6ee0b2067cdae03
  - source: cve@mitre.org
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/tindy2013/subconverter/commit/ce8d2bd0f13f05fcbd2ed90755d097f402393dd3
  title: A remote code execution (RCE) vulnerability in Subconverter v0.7.2 allows
    attackers to execute arbitrary code via crafted config and url parameters.
- diff_content:
  - "--- a/ext/nokogiri/html4_sax_parser_context.c\n+++ b/ext/nokogiri/html4_sax_parser_context.c\n\
    @@ -19,9 +19,8 @@ parse_memory(VALUE klass, VALUE data, VALUE encoding)\n {\n\
    \   htmlParserCtxtPtr ctxt;\n \n-  if (NIL_P(data)) {\n-    rb_raise(rb_eArgError,\
    \ \"data cannot be nil\");\n-  }\n+  Check_Type(data, T_STRING);\n+\n   if (!(int)RSTRING_LEN(data))\
    \ {\n     rb_raise(rb_eRuntimeError, \"data cannot be empty\");\n   }"
  - "--- a/ext/nokogiri/xml_sax_parser_context.c\n+++ b/ext/nokogiri/xml_sax_parser_context.c\n\
    @@ -2,6 +2,8 @@\n \n VALUE cNokogiriXmlSaxParserContext ;\n \n+static ID id_read;\n\
    +\n static void\n deallocate(xmlParserCtxtPtr ctxt)\n {\n@@ -26,6 +28,10 @@ parse_io(VALUE\
    \ klass, VALUE io, VALUE encoding)\n   xmlParserCtxtPtr ctxt;\n   xmlCharEncoding\
    \ enc = (xmlCharEncoding)NUM2INT(encoding);\n \n+  if (!rb_respond_to(io, id_read))\
    \ {\n+    rb_raise(rb_eTypeError, \"argument expected to respond to :read\");\n\
    +  }\n+\n   ctxt = xmlCreateIOParserCtxt(NULL, NULL,\n                       \
    \         (xmlInputReadCallback)noko_io_read,\n                              \
    \  (xmlInputCloseCallback)noko_io_close,\n@@ -62,9 +68,8 @@ parse_memory(VALUE\
    \ klass, VALUE data)\n {\n   xmlParserCtxtPtr ctxt;\n \n-  if (NIL_P(data)) {\n\
    -    rb_raise(rb_eArgError, \"data cannot be nil\");\n-  }\n+  Check_Type(data,\
    \ T_STRING);\n+\n   if (!(int)RSTRING_LEN(data)) {\n     rb_raise(rb_eRuntimeError,\
    \ \"data cannot be empty\");\n   }\n@@ -278,4 +283,6 @@ noko_init_xml_sax_parser_context()\n\
    \   rb_define_method(cNokogiriXmlSaxParserContext, \"recovery\", get_recovery,\
    \ 0);\n   rb_define_method(cNokogiriXmlSaxParserContext, \"line\", line, 0);\n\
    \   rb_define_method(cNokogiriXmlSaxParserContext, \"column\", column, 0);\n+\n\
    +  id_read = rb_intern(\"read\");\n }"
  identifiers:
  - CVE-2022-29181
  - CWE-241
  overview: Nokogiri is an open source XML and HTML library for Ruby. Nokogiri prior
    to version 1.13.6 does not type-check all inputs into the XML and HTML4 SAX parsers,
    allowing specially crafted untrusted inputs to cause illegal memory access errors
    (segfault) or reads from unrelated memory. Version 1.13.6 contains a patch for
    this issue. As a workaround, ensure the untrusted input is a `String` by calling
    `#to_s` or equivalent.
  references:
  - source: security-advisories@github.com
    tags:
    - Mailing List
    - Third Party Advisory
    url: http://seclists.org/fulldisclosure/2022/Dec/23
  - source: security-advisories@github.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/sparklemotion/nokogiri/commit/db05ba9a1bd4b90aa6c76742cf6102a7c7297267
  - source: security-advisories@github.com
    tags:
    - Release Notes
    - Third Party Advisory
    url: https://github.com/sparklemotion/nokogiri/releases/tag/v1.13.6
  - source: security-advisories@github.com
    tags:
    - Issue Tracking
    - Third Party Advisory
    url: https://github.com/sparklemotion/nokogiri/security/advisories/GHSA-xh29-r2w5-wx8m
  - source: security-advisories@github.com
    tags:
    - Third Party Advisory
    url: https://security.gentoo.org/glsa/202208-29
  - source: security-advisories@github.com
    tags:
    - Exploit
    - Third Party Advisory
    url: https://securitylab.github.com/advisories/GHSL-2022-031_GHSL-2022-032_Nokogiri/
  - source: security-advisories@github.com
    tags:
    - Third Party Advisory
    url: https://support.apple.com/kb/HT213532
  title: Nokogiri is an open source XML and HTML library for Ruby. Nokogiri prior
    to version 1.13.6 does not type-check all inputs into the XML and HTML4 SAX parsers,
    allowing specially crafted untrusted inputs to cause illegal memory access errors
    (segfault) or reads from unrelated memory. Version 1.13.6 contains a patch for
    this issue. As a workaround, ensure the untrusted input is a `String` by calling
    `#to_s` or equivalent.
- diff_content:
  - "--- a/libr/anal/vtable.c\n+++ b/libr/anal/vtable.c\n@@ -58,6 +58,8 @@ R_API bool\
    \ r_anal_vtable_begin(RAnal *anal, RVTableContext *context) {\n \t\tcontext->read_addr\
    \ = be? vtable_read_addr_be64 : vtable_read_addr_le64;\n \t\tbreak;\n \tdefault:\n\
    +\t\t// cant be null. assume 32bit \"->read_addr = NULL;\n+\t\tcontext->read_addr\
    \ = be? vtable_read_addr_be32 : vtable_read_addr_le32;\n \t\treturn false;\n \t\
    }\n \treturn true;\n@@ -72,7 +74,7 @@ static bool vtable_addr_in_text_section(RVTableContext\
    \ *context, ut64 curAddress\n \n static bool vtable_is_value_in_text_section(RVTableContext\
    \ *context, ut64 curAddress, ut64 *value) {\n \t//value at the current address\n\
    -\tut64 curAddressValue;\n+\tut64 curAddressValue = UT64_MAX;\n \tif (!context->read_addr\
    \ (context->anal, curAddress, &curAddressValue)) {\n \t\treturn false;\n \t}\n\
    @@ -132,6 +134,7 @@ static bool vtable_is_addr_vtable_start_itanium(RVTableContext\
    \ *context, RBinSec\n }\n \n static bool vtable_is_addr_vtable_start_msvc(RVTableContext\
    \ *context, ut64 curAddress) {\n+\tut8 buf[VTABLE_BUFF_SIZE];\n \tRAnalRef *xref;\n\
    \ \tRListIter *xrefIter;\n \n@@ -150,19 +153,14 @@ static bool vtable_is_addr_vtable_start_msvc(RVTableContext\
    \ *context, ut64 curAd\n \tr_list_foreach (xrefs, xrefIter, xref) {\n \t\t// section\
    \ in which currenct xref lies\n \t\tif (vtable_addr_in_text_section (context,\
    \ xref->addr)) {\n-\t\t\tut8 buf[VTABLE_BUFF_SIZE];\n-\t\t\tcontext->anal->iob.read_at\
    \ (context->anal->iob.io, xref->addr, buf, sizeof(buf));\n-\n+\t\t\tcontext->anal->iob.read_at\
    \ (context->anal->iob.io, xref->addr, buf, sizeof (buf));\n \t\t\tRAnalOp analop\
    \ = {0};\n-\t\t\tr_anal_op (context->anal, &analop, xref->addr, buf, sizeof(buf),\
    \ R_ANAL_OP_MASK_BASIC);\n-\n-\t\t\tif (analop.type == R_ANAL_OP_TYPE_MOV\n-\t\
    \t\t\t|| analop.type == R_ANAL_OP_TYPE_LEA) {\n+\t\t\tr_anal_op (context->anal,\
    \ &analop, xref->addr, buf, sizeof (buf), R_ANAL_OP_MASK_BASIC);\n+\t\t\tif (analop.type\
    \ == R_ANAL_OP_TYPE_MOV || analop.type == R_ANAL_OP_TYPE_LEA) {\n \t\t\t\tr_list_free\
    \ (xrefs);\n \t\t\t\tr_anal_op_fini (&analop);\n \t\t\t\treturn true;\n \t\t\t\
    }\n-\n \t\t\tr_anal_op_fini (&analop);\n \t\t}\n \t}\n@@ -286,7 +284,7 @@ R_API\
    \ RList *r_anal_vtable_search(RVTableContext *context) {\n }\n \n R_API void r_anal_list_vtables(RAnal\
    \ *anal, int rad) {\n-\tRVTableContext context;\n+\tRVTableContext context = {0};\n\
    \ \tr_anal_vtable_begin (anal, &context);\n \n \tconst char *noMethodName = \"\
    No Name found\";"
  identifiers:
  - CVE-2022-1809
  - CWE-824
  overview: Access of Uninitialized Pointer in GitHub repository radareorg/radare2
    prior to 5.7.0.
  references:
  - source: security@huntr.dev
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/radareorg/radare2/commit/919e3ac1a13f753c73e7a8e8d8bb4a143218732d
  - source: security@huntr.dev
    tags:
    - Exploit
    - Third Party Advisory
    url: https://huntr.dev/bounties/0730a95e-c485-4ff2-9a5d-bb3abfda0b17
  title: Access of Uninitialized Pointer in GitHub repository radareorg/radare2 prior
    to 5.7.0.
- diff_content:
  - "--- a/gost_ec_keyx.c\n+++ b/gost_ec_keyx.c\n@@ -292,6 +292,8 @@ static int pkey_GOST_ECcp_encrypt(EVP_PKEY_CTX\
    \ *pctx, unsigned char *out,\n     int key_is_ephemeral = 1;\n     gost_ctx cctx;\n\
    \     EVP_PKEY *sec_key = EVP_PKEY_CTX_get0_peerkey(pctx);\n+    int res_len =\
    \ 0;\n+\n     if (data->shared_ukm_size) {\n         memcpy(ukm, data->shared_ukm,\
    \ 8);\n     } else {\n@@ -373,8 +375,26 @@ static int pkey_GOST_ECcp_encrypt(EVP_PKEY_CTX\
    \ *pctx, unsigned char *out,\n             goto err;\n         }\n     }\n-  \
    \  if ((*out_len = i2d_GOST_KEY_TRANSPORT(gkt, out ? &out : NULL)) > 0)\n+   \
    \ res_len = i2d_GOST_KEY_TRANSPORT(gkt, NULL);\n+    if (res_len <= 0) {\n+  \
    \      GOSTerr(GOST_F_PKEY_GOST_ECCP_ENCRYPT, ERR_R_ASN1_LIB);\n+        goto\
    \ err;\n+    }\n+\n+    if (out == NULL) {\n+        *out_len = res_len;\n   \
    \      ret = 1;\n+    } else {\n+        if ((size_t)res_len > *out_len) {\n+\
    \            GOSTerr(GOST_F_PKEY_GOST_ECCP_ENCRYPT, GOST_R_INVALID_BUFFER_SIZE);\n\
    +            goto err;\n+        }\n+        if ((*out_len = i2d_GOST_KEY_TRANSPORT(gkt,\
    \ &out)) > 0)\n+            ret = 1;\n+        else\n+            GOSTerr(GOST_F_PKEY_GOST_ECCP_ENCRYPT,\
    \ ERR_R_ASN1_LIB);\n+    }\n+\n     OPENSSL_cleanse(shared_key, sizeof(shared_key));\n\
    \     GOST_KEY_TRANSPORT_free(gkt);\n     return ret;"
  - "--- a/gost_ec_keyx.c\n+++ b/gost_ec_keyx.c\n@@ -589,10 +589,6 @@ static int pkey_GOST_ECcp_decrypt(EVP_PKEY_CTX\
    \ *pctx, unsigned char *key,\n     EVP_PKEY *eph_key = NULL, *peerkey = NULL;\n\
    \     int dgst_nid = NID_undef;\n \n-    if (!key) {\n-        *key_len = 32;\n\
    -        return 1;\n-    }\n     gkt = d2i_GOST_KEY_TRANSPORT(NULL, (const unsigned\
    \ char **)&p, in_len);\n     if (!gkt) {\n         GOSTerr(GOST_F_PKEY_GOST_ECCP_DECRYPT,\n\
    @@ -652,6 +648,7 @@ static int pkey_GOST_ECcp_decrypt(EVP_PKEY_CTX *pctx, unsigned\
    \ char *key,\n         goto err;\n     }\n \n+    *key_len = 32;\n     ret = 1;\n\
    \  err:\n     OPENSSL_cleanse(sharedKey, sizeof(sharedKey));\n@@ -701,10 +698,6\
    \ @@ static int pkey_gost2018_decrypt(EVP_PKEY_CTX *pctx, unsigned char *key,\n\
    \         return -1;\n         break;\n     }\n-    if (!key) {\n-        *key_len\
    \ = 32;\n-        return 1;\n-    }\n \n     pst = d2i_PSKeyTransport_gost(NULL,\
    \ (const unsigned char **)&p, in_len);\n     if (!pst) {\n@@ -756,6 +749,7 @@\
    \ static int pkey_gost2018_decrypt(EVP_PKEY_CTX *pctx, unsigned char *key,\n \
    \        goto err;\n     }\n \n+    *key_len = 32;\n     ret = 1;\n  err:\n  \
    \   OPENSSL_cleanse(expkeys, sizeof(expkeys));\n@@ -768,6 +762,17 @@ int pkey_gost_decrypt(EVP_PKEY_CTX\
    \ *pctx, unsigned char *key,\n                       size_t *key_len, const unsigned\
    \ char *in, size_t in_len)\n {\n     struct gost_pmeth_data *gctx = EVP_PKEY_CTX_get_data(pctx);\n\
    +\n+    if (key == NULL) {\n+        *key_len = 32;\n+        return 1;\n+   \
    \ }\n+\n+    if (key != NULL && *key_len < 32) {\n+        GOSTerr(GOST_F_PKEY_GOST2018_ENCRYPT,\
    \ GOST_R_INVALID_BUFFER_SIZE);\n+        return 0;\n+    }\n+\n     switch (gctx->cipher_nid)\n\
    \     {\n         case NID_id_Gost28147_89:"
  - "--- a/e_gost_err.c\n+++ b/e_gost_err.c\n@@ -141,6 +141,7 @@ static ERR_STRING_DATA\
    \ GOST_str_reasons[] = {\n     {ERR_PACK(0, 0, GOST_R_ERROR_SETTING_PEER_KEY),\
    \ \"error setting peer key\"},\n     {ERR_PACK(0, 0, GOST_R_INCOMPATIBLE_ALGORITHMS),\
    \ \"incompatible algorithms\"},\n     {ERR_PACK(0, 0, GOST_R_INCOMPATIBLE_PEER_KEY),\
    \ \"incompatible peer key\"},\n+    {ERR_PACK(0, 0, GOST_R_INVALID_BUFFER_SIZE),\
    \ \"invalid buffer size\"},\n     {ERR_PACK(0, 0, GOST_R_INVALID_CIPHER), \"invalid\
    \ cipher\"},\n     {ERR_PACK(0, 0, GOST_R_INVALID_CIPHER_PARAMS), \"invalid cipher\
    \ params\"},\n     {ERR_PACK(0, 0, GOST_R_INVALID_CIPHER_PARAM_OID),"
  - "--- a/gost_ec_keyx.c\n+++ b/gost_ec_keyx.c\n@@ -406,6 +406,7 @@ static int pkey_gost2018_encrypt(EVP_PKEY_CTX\
    \ *pctx, unsigned char *out,\n     int exp_len = 0, iv_len = 0;\n     unsigned\
    \ char *exp_buf = NULL;\n     int key_is_ephemeral = 0;\n+    int res_len = 0;\n\
    \ \n     switch (data->cipher_nid) {\n     case NID_magma_ctr:\n@@ -499,8 +500,26\
    \ @@ static int pkey_gost2018_encrypt(EVP_PKEY_CTX *pctx, unsigned char *out,\n\
    \         goto err;\n     }\n \n-    if ((*out_len = i2d_PSKeyTransport_gost(pst,\
    \ out ? &out : NULL)) > 0)\n+    res_len = i2d_PSKeyTransport_gost(pst, NULL);\n\
    +    if (res_len <= 0) {\n+        GOSTerr(GOST_F_PKEY_GOST2018_ENCRYPT, ERR_R_ASN1_LIB);\n\
    +        goto err;\n+    }\n+\n+    if (out == NULL) {\n+        *out_len = res_len;\n\
    \         ret = 1;\n+    } else {\n+        if ((size_t)res_len > *out_len) {\n\
    +            GOSTerr(GOST_F_PKEY_GOST2018_ENCRYPT, GOST_R_INVALID_BUFFER_SIZE);\n\
    +            goto err;\n+        }\n+        if ((*out_len = i2d_PSKeyTransport_gost(pst,\
    \ &out)) > 0)\n+            ret = 1;\n+        else\n+            GOSTerr(GOST_F_PKEY_GOST2018_ENCRYPT,\
    \ ERR_R_ASN1_LIB);\n+    }\n+\n  err:\n     OPENSSL_cleanse(expkeys, sizeof(expkeys));\n\
    \     if (key_is_ephemeral)"
  identifiers:
  - CVE-2022-29242
  - CWE-120
  overview: GOST engine is a reference implementation of the Russian GOST crypto algorithms
    for OpenSSL. TLS clients using GOST engine when ciphersuite `TLS_GOSTR341112_256_WITH_KUZNYECHIK_CTR_OMAC`
    is agreed and the server uses 512 bit GOST secret keys are vulnerable to buffer
    overflow. GOST engine version 3.0.1 contains a patch for this issue. Disabling
    ciphersuite `TLS_GOSTR341112_256_WITH_KUZNYECHIK_CTR_OMAC` is a possible workaround.
  references:
  - source: security-advisories@github.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/gost-engine/engine/commit/7df766124f87768b43b9e8947c5a01e17545772c
  - source: security-advisories@github.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/gost-engine/engine/commit/b2b4d629f100eaee9f5942a106b1ccefe85b8808
  - source: security-advisories@github.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/gost-engine/engine/commit/c6655a0b620a3e31f085cc906f8073fe81b2fad3
  - source: security-advisories@github.com
    tags:
    - Release Notes
    - Third Party Advisory
    url: https://github.com/gost-engine/engine/releases/tag/v3.0.1
  - source: security-advisories@github.com
    tags:
    - Third Party Advisory
    url: https://github.com/gost-engine/engine/security/advisories/GHSA-2rmw-8wpg-vgw5
  title: GOST engine is a reference implementation of the Russian GOST crypto algorithms
    for OpenSSL. TLS clients using GOST engine when ciphersuite `TLS_GOSTR341112_256_WITH_KUZNYECHIK_CTR_OMAC`
    is agreed and the server uses 512 bit GOST secret keys are vulnerable to buffer
    overflow. GOST engine version 3.0.1 contains a patch for this issue. Disabling
    ciphersuite `TLS_GOSTR341112_256_WITH_KUZNYECHIK_CTR_OMAC` is a possible workaround.
- diff_content:
  - "--- a/src/textformat.c\n+++ b/src/textformat.c\n@@ -870,6 +870,9 @@ op_format(\n\
    \     {\n \tcurwin->w_cursor = saved_cursor;\n \tsaved_cursor.lnum = 0;\n+\n+\t\
    // formatting may have made the cursor position invalid\n+\tcheck_cursor();\n\
    \     }\n \n     if (oap->is_VIsual)"
  - "--- a/src/version.c\n+++ b/src/version.c\n@@ -734,6 +734,8 @@ static char *(features[])\
    \ =\n \n static int included_patches[] =\n {   /* Add new patch number below this\
    \ line */\n+/**/\n+    5013,\n /**/\n     5012,\n /**/"
  identifiers:
  - CVE-2022-1851
  - CWE-125
  overview: Out-of-bounds Read in GitHub repository vim/vim prior to 8.2.
  references:
  - source: security@huntr.dev
    tags:
    - Mailing List
    - Third Party Advisory
    url: http://seclists.org/fulldisclosure/2022/Oct/28
  - source: security@huntr.dev
    tags:
    - Mailing List
    - Third Party Advisory
    url: http://seclists.org/fulldisclosure/2022/Oct/41
  - source: security@huntr.dev
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/vim/vim/commit/78d52883e10d71f23ab72a3d8b9733b00da8c9ad
  - source: security@huntr.dev
    tags:
    - Exploit
    - Patch
    - Third Party Advisory
    url: https://huntr.dev/bounties/f8af901a-9a46-440d-942a-8f815b59394d
  - source: security@huntr.dev
    tags:
    - Mailing List
    - Third Party Advisory
    url: https://lists.debian.org/debian-lts-announce/2022/06/msg00014.html
  - source: security@huntr.dev
    tags:
    - Mailing List
    - Third Party Advisory
    url: https://lists.debian.org/debian-lts-announce/2022/11/msg00009.html
  - source: security@huntr.dev
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/OZSLFIKFYU5Y2KM5EJKQNYHWRUBDQ4GJ/
  - source: security@huntr.dev
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/QMFHBC5OQXDPV2SDYA2JUQGVCPYASTJB/
  - source: security@huntr.dev
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/TYNK6SDCMOLQJOI3B4AOE66P2G2IH4ZM/
  - source: security@huntr.dev
    tags:
    - Third Party Advisory
    url: https://security.gentoo.org/glsa/202208-32
  - source: security@huntr.dev
    url: https://security.gentoo.org/glsa/202305-16
  - source: security@huntr.dev
    tags:
    - Third Party Advisory
    url: https://support.apple.com/kb/HT213488
  title: Out-of-bounds Read in GitHub repository vim/vim prior to 8.2.
- diff_content:
  - "--- a/src/njs_module.c\n+++ b/src/njs_module.c\n@@ -118,7 +118,7 @@ njs_module_path(njs_vm_t\
    \ *vm, const njs_str_t *dir, njs_module_info_t *info)\n     length = info->name.length;\n\
    \ \n     if (dir != NULL) {\n-        length = dir->length;\n+        length +=\
    \ dir->length;\n \n         if (length == 0) {\n             return NJS_DECLINED;"
  identifiers:
  - CVE-2022-29379
  - CWE-787
  overview: 'Nginx NJS v0.7.3 was discovered to contain a stack overflow in the function
    njs_default_module_loader at /src/njs/src/njs_module.c. NOTE: multiple third parties
    dispute this report, e.g., the behavior is only found in unreleased development
    code that was not part of the 0.7.2, 0.7.3, or 0.7.4 release'
  references:
  - source: cve@mitre.org
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/nginx/njs/commit/ab1702c7af9959366a5ddc4a75b4357d4e9ebdc1
  - source: cve@mitre.org
    tags:
    - Issue Tracking
    - Third Party Advisory
    url: https://github.com/nginx/njs/issues/491
  - source: cve@mitre.org
    tags:
    - Exploit
    - Issue Tracking
    - Patch
    - Third Party Advisory
    url: https://github.com/nginx/njs/issues/493
  title: 'Nginx NJS v0.7.3 was discovered to contain a stack overflow in the function
    njs_default_module_loader at /src/njs/src/njs_module.c. NOTE: multiple third parties
    dispute this report, e.g., the behavior is only found in unreleased development
    code that was not part of the 0.7.2, 0.7.3, or 0.7.4 release'
- diff_content:
  - "--- a/net/ipv4/tcp_output.c\n+++ b/net/ipv4/tcp_output.c\n@@ -968,6 +968,8 @@\
    \ enum hrtimer_restart tcp_pace_kick(struct hrtimer *timer)\n \n static void tcp_internal_pacing(struct\
    \ sock *sk, const struct sk_buff *skb)\n {\n+\tstruct tcp_sock *tp = tcp_sk(sk);\n\
    +\tktime_t expire, now;\n \tu64 len_ns;\n \tu32 rate;\n \n@@ -979,12 +981,28 @@\
    \ static void tcp_internal_pacing(struct sock *sk, const struct sk_buff *skb)\n\
    \ \n \tlen_ns = (u64)skb->len * NSEC_PER_SEC;\n \tdo_div(len_ns, rate);\n-\thrtimer_start(&tcp_sk(sk)->pacing_timer,\n\
    -\t\t      ktime_add_ns(ktime_get(), len_ns),\n+\tnow = ktime_get();\n+\t/* If\
    \ hrtimer is already armed, then our caller has not\n+\t * used tcp_pacing_check().\n\
    +\t */\n+\tif (unlikely(hrtimer_is_queued(&tp->pacing_timer))) {\n+\t\texpire\
    \ = hrtimer_get_softexpires(&tp->pacing_timer);\n+\t\tif (ktime_after(expire,\
    \ now))\n+\t\t\tnow = expire;\n+\t\tif (hrtimer_try_to_cancel(&tp->pacing_timer)\
    \ == 1)\n+\t\t\t__sock_put(sk);\n+\t}\n+\thrtimer_start(&tp->pacing_timer, ktime_add_ns(now,\
    \ len_ns),\n \t\t      HRTIMER_MODE_ABS_PINNED_SOFT);\n \tsock_hold(sk);\n }\n\
    \ \n+static bool tcp_pacing_check(const struct sock *sk)\n+{\n+\treturn tcp_needs_internal_pacing(sk)\
    \ &&\n+\t       hrtimer_is_queued(&tcp_sk(sk)->pacing_timer);\n+}\n+\n static\
    \ void tcp_update_skb_after_send(struct tcp_sock *tp, struct sk_buff *skb)\n {\n\
    \ \tskb->skb_mstamp = tp->tcp_mstamp;\n@@ -2121,6 +2139,9 @@ static int tcp_mtu_probe(struct\
    \ sock *sk)\n \tif (!tcp_can_coalesce_send_queue_head(sk, probe_size))\n \t\t\
    return -1;\n \n+\tif (tcp_pacing_check(sk))\n+\t\treturn -1;\n+\n \t/* We're allowed\
    \ to probe.  Build it now. */\n \tnskb = sk_stream_alloc_skb(sk, probe_size, GFP_ATOMIC,\
    \ false);\n \tif (!nskb)\n@@ -2194,12 +2215,6 @@ static int tcp_mtu_probe(struct\
    \ sock *sk)\n \treturn -1;\n }\n \n-static bool tcp_pacing_check(const struct\
    \ sock *sk)\n-{\n-\treturn tcp_needs_internal_pacing(sk) &&\n-\t       hrtimer_is_queued(&tcp_sk(sk)->pacing_timer);\n\
    -}\n-\n /* TCP Small Queues :\n  * Control number of packets in qdisc/devices\
    \ to two packets / or ~1 ms.\n  * (These limits are doubled for retransmits)"
  identifiers:
  - CVE-2022-1678
  - NVD-CWE-Other
  overview: An issue was discovered in the Linux Kernel from 4.18 to 4.19, an improper
    update of sock reference in TCP pacing can lead to memory/netns leak, which can
    be used by remote clients.
  references:
  - source: security@openanolis.org
    tags:
    - Third Party Advisory
    url: https://anas.openanolis.cn/cves/detail/CVE-2022-1678
  - source: security@openanolis.org
    tags:
    - Third Party Advisory
    url: https://anas.openanolis.cn/errata/detail/ANSA-2022:0143
  - source: security@openanolis.org
    tags:
    - Issue Tracking
    - Patch
    - Third Party Advisory
    url: https://bugzilla.openanolis.cn/show_bug.cgi?id=61
  - source: security@openanolis.org
    tags:
    - Permissions Required
    url: https://gitee.com/anolis/cloud-kernel/commit/bed537da691b
  - source: security@openanolis.org
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/torvalds/linux/commit/0a70f118475e037732557796accd0878a00fc25a
  - source: security@openanolis.org
    url: https://lore.kernel.org/all/20200602080425.93712-1-kerneljasonxing%40gmail.com/
  - source: security@openanolis.org
    tags:
    - Third Party Advisory
    url: https://security.netapp.com/advisory/ntap-20220715-0001/
  title: An issue was discovered in the Linux Kernel from 4.18 to 4.19, an improper
    update of sock reference in TCP pacing can lead to memory/netns leak, which can
    be used by remote clients.
- diff_content:
  - "--- a/codestream/aclosslessscan.cpp\n+++ b/codestream/aclosslessscan.cpp\n@@\
    \ -42,7 +42,7 @@\n **\n ** Represents the scan including the scan header.\n **\n\
    -** $Id: aclosslessscan.cpp,v 1.42 2020/08/31 07:50:43 thor Exp $\n+** $Id: aclosslessscan.cpp,v\
    \ 1.43 2022/05/23 05:56:51 thor Exp $\n **\n */\n \n@@ -359,7 +359,9 @@ void ACLosslessScan::ParseMCU(struct\
    \ Line **prev,struct Line **top)\n             //\n             while(m_Coder.Get(mset.X[i]))\
    \ {\n               m <<= 1;\n-              i++;\n+              if (++i >= QMContextSet::MagnitudeSet::MagnitudeContexts)\n\
    +                JPG_THROW(MALFORMED_STREAM,\"ACLosslessScan::ParseMCU\",\n+ \
    \                         \"received an out-of-bounds signal while parsing an\
    \ AC-coded lossless symbol\");\n             }\n             //\n            \
    \ m >>= 1;"
  - "--- a/codestream/acsequentialscan.cpp\n+++ b/codestream/acsequentialscan.cpp\n\
    @@ -42,7 +42,7 @@\n **\n ** Represents the scan including the scan header.\n **\n\
    -** $Id: acsequentialscan.cpp,v 1.51 2016/10/28 13:58:53 thor Exp $\n+** $Id:\
    \ acsequentialscan.cpp,v 1.52 2022/05/23 05:56:51 thor Exp $\n **\n */\n \n@@\
    \ -582,8 +582,7 @@ void ACSequentialScan::DecodeBlock(LONG *block,\n         \n\
    \         while(m_Coder.Get(m_Context[dc].DCMagnitude.X[i])) {\n           m <<=\
    \ 1;\n-          i++;\n-          if (m == 0) \n+          if(++i >= QMContextSet::DCContextMagnitudeSet::MagnitudeContexts)\n\
    \             JPG_THROW(MALFORMED_STREAM,\"ACSequentialScan::DecodeBlock\",\n\
    \                       \"QMDecoder is out of sync\");\n         }\n@@ -653,8\
    \ +652,7 @@ void ACSequentialScan::DecodeBlock(LONG *block,\n           \n   \
    \        while(m_Coder.Get(acm.X[i])) {\n             m <<= 1;\n-            i++;\n\
    -            if (m == 0)\n+            if(++i >= QMContextSet::ACContextMagnitudeSet::MagnitudeContexts)\n\
    \               JPG_THROW(MALFORMED_STREAM,\"ACSequentialScan::DecodeBlock\",\n\
    \                         \"QMDecoder is out of sync\");\n           }"
  - "--- a/codestream/losslessscan.cpp\n+++ b/codestream/losslessscan.cpp\n@@ -42,7\
    \ +42,7 @@\n **\n ** Represents the scan including the scan header.\n **\n-**\
    \ $Id: losslessscan.cpp,v 1.50 2015/03/25 08:45:43 thor Exp $\n+** $Id: losslessscan.cpp,v\
    \ 1.51 2022/05/23 05:56:51 thor Exp $\n **\n */\n \n@@ -377,6 +377,9 @@ void LosslessScan::ParseMCU(struct\
    \ Line **prev,struct Line **top)\n           v = 0;\n         } else if (symbol\
    \ == 16) {\n           v = -32768;\n+        } else if (symbol > 16) {\n+    \
    \      JPG_THROW(MALFORMED_STREAM,\"LosslessScan::ParseMCU\",\n+             \
    \       \"received an out-of-bounds symbol in a lossless JPEG scan\");\n     \
    \    } else {\n           LONG thre = 1L << (symbol - 1);\n           LONG diff\
    \ = m_Stream.Get(symbol); // get the number of bits "
  identifiers:
  - CVE-2022-31620
  - CWE-617
  overview: In libjpeg before 1.64, BitStream<false>::Get in bitstream.hpp has an
    assertion failure that may cause denial of service. This is related to out-of-bounds
    array access during arithmetically coded lossless scan or arithmetically coded
    sequential scan.
  references:
  - source: cve@mitre.org
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/thorfdbg/libjpeg/commit/ef4a29a62ab48b8dc235f4af52cfd6319eda9a6a
  - source: cve@mitre.org
    tags:
    - Exploit
    - Issue Tracking
    - Third Party Advisory
    url: https://github.com/thorfdbg/libjpeg/issues/70
  title: In libjpeg before 1.64, BitStream<false>::Get in bitstream.hpp has an assertion
    failure that may cause denial of service. This is related to out-of-bounds array
    access during arithmetically coded lossless scan or arithmetically coded sequential
    scan.
- diff_content:
  - "--- a/plugin/server_audit/server_audit.c\n+++ b/plugin/server_audit/server_audit.c\n\
    @@ -301,8 +301,6 @@ static char logging;\n static volatile int internal_stop_logging=\
    \ 0;\n static char incl_user_buffer[1024];\n static char excl_user_buffer[1024];\n\
    -static char *big_buffer= NULL;\n-static size_t big_buffer_alloced= 0;\n static\
    \ unsigned int query_log_limit= 0;\n \n static char servhost[256];\n@@ -555,20\
    \ +553,16 @@ static struct st_mysql_show_var audit_status[]=\n /* These belong\
    \ to the service initialization */\n static PSI_mutex_key key_LOCK_operations;\n\
    \ static PSI_mutex_key key_LOCK_atomic;\n-static PSI_mutex_key key_LOCK_bigbuffer;\n\
    \ static PSI_mutex_info mutex_key_list[]=\n {\n   { &key_LOCK_operations, \"SERVER_AUDIT_plugin::lock_operations\"\
    ,\n     PSI_FLAG_GLOBAL},\n   { &key_LOCK_atomic, \"SERVER_AUDIT_plugin::lock_atomic\"\
    ,\n     PSI_FLAG_GLOBAL},\n-  { &key_LOCK_bigbuffer, \"SERVER_AUDIT_plugin::lock_bigbuffer\"\
    ,\n-    PSI_FLAG_GLOBAL}\n };\n #endif\n static mysql_mutex_t lock_operations;\n\
    \ static mysql_mutex_t lock_atomic;\n-static mysql_mutex_t lock_bigbuffer;\n \n\
    \ /* The Percona server and partly MySQL don't support         */\n /* launching\
    \ client errors in the 'update_variable' methods. */\n@@ -1700,7 +1694,7 @@ static\
    \ int log_statement_ex(const struct connection_info *cn,\n                   \
    \          int error_code, const char *type, int take_lock)\n {\n   size_t csize;\n\
    -  char message_loc[1024];\n+  char message_loc[2048];\n   char *message= message_loc;\n\
    \   size_t message_size= sizeof(message_loc);\n   char *uh_buffer;\n@@ -1709,6\
    \ +1703,7 @@ static int log_statement_ex(const struct connection_info *cn,\n \
    \  unsigned int db_length;\n   long long query_id;\n   int result;\n+  char *big_buffer=\
    \ NULL;\n \n   if ((db= cn->db))\n     db_length= cn->db_length;\n@@ -1791,17\
    \ +1786,9 @@ static int log_statement_ex(const struct connection_info *cn,\n \n\
    \   if (query_len > (message_size - csize)/2)\n   {\n-    flogger_mutex_lock(&lock_bigbuffer);\n\
    -    if (big_buffer_alloced < (query_len * 2 + csize))\n-    {\n-      big_buffer_alloced=\
    \ (query_len * 2 + csize + 4095) & ~4095L;\n-      big_buffer= realloc(big_buffer,\
    \ big_buffer_alloced);\n-      if (big_buffer == NULL)\n-      {\n-        big_buffer_alloced=\
    \ 0;\n-        return 0;\n-      }\n-    }\n+    size_t big_buffer_alloced= (query_len\
    \ * 2 + csize + 4095) & ~4095L;\n+    if(!(big_buffer= malloc(big_buffer_alloced)))\n\
    +      return 0;\n \n     memcpy(big_buffer, message, csize);\n     message= big_buffer;\n\
    @@ -1846,8 +1833,8 @@ static int log_statement_ex(const struct connection_info\
    \ *cn,\n                       \"\\',%d\", error_code);\n   message[csize]= '\\\
    n';\n   result= write_log(message, csize + 1, take_lock);\n-  if (message == big_buffer)\n\
    -    flogger_mutex_unlock(&lock_bigbuffer);\n+  if (big_buffer)\n+    free(big_buffer);\n\
    \ \n   return result;\n }\n@@ -2496,7 +2483,6 @@ static int server_audit_init(void\
    \ *p __attribute__((unused)))\n #endif\n   flogger_mutex_init(key_LOCK_operations,\
    \ &lock_operations, MY_MUTEX_INIT_FAST);\n   flogger_mutex_init(key_LOCK_operations,\
    \ &lock_atomic, MY_MUTEX_INIT_FAST);\n-  flogger_mutex_init(key_LOCK_operations,\
    \ &lock_bigbuffer, MY_MUTEX_INIT_FAST);\n \n   coll_init(&incl_user_coll);\n \
    \  coll_init(&excl_user_coll);\n@@ -2581,10 +2567,8 @@ static int server_audit_deinit(void\
    \ *p __attribute__((unused)))\n   else if (output_type == OUTPUT_SYSLOG)\n   \
    \  closelog();\n \n-  (void) free(big_buffer);\n   flogger_mutex_destroy(&lock_operations);\n\
    \   flogger_mutex_destroy(&lock_atomic);\n-  flogger_mutex_destroy(&lock_bigbuffer);\n\
    \ \n   error_header();\n   fprintf(stderr, \"STOPPED\\n\");"
  identifiers:
  - CVE-2022-31624
  - CWE-667
  overview: MariaDB Server before 10.7 is vulnerable to Denial of Service. While executing
    the plugin/server_audit/server_audit.c method log_statement_ex, the held lock
    lock_bigbuffer is not released correctly, which allows local users to trigger
    a denial of service due to the deadlock.
  references:
  - source: cve@mitre.org
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/MariaDB/server/commit/d627d00b13ab2f2c0954ea7b77202470cb102944
  - source: cve@mitre.org
    tags:
    - Issue Tracking
    - Permissions Required
    - Third Party Advisory
    url: https://jira.mariadb.org/browse/MDEV-26556?filter=-2
  - source: cve@mitre.org
    tags:
    - Third Party Advisory
    url: https://security.netapp.com/advisory/ntap-20220707-0006/
  title: MariaDB Server before 10.7 is vulnerable to Denial of Service. While executing
    the plugin/server_audit/server_audit.c method log_statement_ex, the held lock
    lock_bigbuffer is not released correctly, which allows local users to trigger
    a denial of service due to the deadlock.
- diff_content:
  - "--- a/src/register.c\n+++ b/src/register.c\n@@ -2219,9 +2219,12 @@ do_put(\n\
    \ \t    len = STRLEN(y_array[y_size - 1]);\n \t    col = (colnr_T)len - lendiff;\n\
    \ \t    if (col > 1)\n-\t\tcurbuf->b_op_end.col = col - 1\n-\t\t\t\t- mb_head_off(y_array[y_size\
    \ - 1],\n+\t    {\n+\t\tcurbuf->b_op_end.col = col - 1;\n+\t\tif (len > 0)\n+\t\
    \t    curbuf->b_op_end.col -= mb_head_off(y_array[y_size - 1],\n \t\t\t\t\t\t\
    y_array[y_size - 1] + len - 1);\n+\t    }\n \t    else\n \t\tcurbuf->b_op_end.col\
    \ = 0;\n "
  - "--- a/src/version.c\n+++ b/src/version.c\n@@ -734,6 +734,8 @@ static char *(features[])\
    \ =\n \n static int included_patches[] =\n {   /* Add new patch number below this\
    \ line */\n+/**/\n+    5016,\n /**/\n     5015,\n /**/"
  identifiers:
  - CVE-2022-1886
  - CWE-122
  overview: Heap-based Buffer Overflow in GitHub repository vim/vim prior to 8.2.
  references:
  - source: security@huntr.dev
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/vim/vim/commit/2a585c85013be22f59f184d49612074fd9b115d7
  - source: security@huntr.dev
    tags:
    - Exploit
    - Patch
    - Third Party Advisory
    url: https://huntr.dev/bounties/fa0ad526-b608-45b3-9ebc-f2b607834d6a
  - source: security@huntr.dev
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/TYNK6SDCMOLQJOI3B4AOE66P2G2IH4ZM/
  - source: security@huntr.dev
    tags:
    - Third Party Advisory
    url: https://security.gentoo.org/glsa/202208-32
  - source: security@huntr.dev
    url: https://security.gentoo.org/glsa/202305-16
  title: Heap-based Buffer Overflow in GitHub repository vim/vim prior to 8.2.
- diff_content:
  - "--- a/libr/bin/bfile.c\n+++ b/libr/bin/bfile.c\n@@ -178,27 +178,27 @@ static\
    \ int string_scan_range(RList *list, RBinFile *bf, int min,\n \tfree (charset);\n\
    \ \tRConsIsBreaked is_breaked = (bin && bin->consb.is_breaked)? bin->consb.is_breaked:\
    \ NULL;\n \t// may oobread\n-\twhile (needle < to) {\n+\twhile (needle < to &&\
    \ needle < UT64_MAX - 4) {\n \t\tif (is_breaked && is_breaked ()) {\n \t\t\tbreak;\n\
    \ \t\t}\n \t\t// smol optimization\n-\t\tif (needle + 4 < to) {\n-\t\t\tut32 n1\
    \ = r_read_le32 (buf + needle - from);\n+\t\tif (needle < to - 4) {\n+\t\t\tut32\
    \ n1 = r_read_le32 (buf + (needle - from));\n \t\t\tif (!n1) {\n \t\t\t\tneedle\
    \ += 4;\n \t\t\t\tcontinue;\n \t\t\t}\n \t\t}\n-\t\trc = r_utf8_decode (buf +\
    \ needle - from, to - needle, NULL);\n+\t\trc = r_utf8_decode (buf + (needle -\
    \ from), to - needle, NULL);\n \t\tif (!rc) {\n \t\t\tneedle++;\n \t\t\tcontinue;\n\
    \ \t\t}\n \t\tbool addr_aligned = !(needle % 4);\n \n \t\tif (type == R_STRING_TYPE_DETECT)\
    \ {\n-\t\t\tchar *w = (char *)buf + needle + rc - from;\n+\t\t\tchar *w = (char\
    \ *)buf + (needle + rc - from);\n \t\t\tif (((to - needle) > 8 + rc)) {\n \t\t\
    \t\t// TODO: support le and be\n \t\t\t\tbool is_wide32le = (needle + rc + 2 <\
    \ to) && (!w[0] && !w[1] && !w[2] && w[3] && !w[4]);\n@@ -248,7 +248,7 @@ static\
    \ int string_scan_range(RList *list, RBinFile *bf, int min,\n \t\t\t\t\trc = 2;\n\
    \ \t\t\t\t}\n \t\t\t} else {\n-\t\t\t\trc = r_utf8_decode (buf + needle - from,\
    \ to - needle, &r);\n+\t\t\t\trc = r_utf8_decode (buf + (needle - from), to -\
    \ needle, &r);\n \t\t\t\tif (rc > 1) {\n \t\t\t\t\tstr_type = R_STRING_TYPE_UTF8;\n\
    \ \t\t\t\t}"
  identifiers:
  - CVE-2022-1899
  - CWE-125
  overview: Out-of-bounds Read in GitHub repository radareorg/radare2 prior to 5.7.0.
  references:
  - source: security@huntr.dev
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/radareorg/radare2/commit/193f4fe01d7f626e2ea937450f2e0c4604420e9d
  - source: security@huntr.dev
    tags:
    - Exploit
    - Third Party Advisory
    url: https://huntr.dev/bounties/8a3dc5cb-08b3-4807-82b2-77f08c137a04
  title: Out-of-bounds Read in GitHub repository radareorg/radare2 prior to 5.7.0.
- diff_content:
  - "--- a/scheduler/cert.c\n+++ b/scheduler/cert.c\n@@ -444,5 +444,12 @@ ctcompare(const\
    \ char *a,\t\t/* I - First string */\n     b ++;\n   }\n \n-  return (result);\n\
    + /*\n+  * The while loop finishes when *a == '\\0' or *b == '\\0'\n+  * so after\
    \ the while loop either both *a and *b == '\\0',\n+  * or one points inside a\
    \ string, so when we apply logical OR on *a,\n+  * *b and result, we get a non-zero\
    \ return value if the compared strings don't match.\n+  */\n+\n+  return (result\
    \ | *a | *b);\n }"
  identifiers:
  - CVE-2022-26691
  - CWE-697
  overview: A logic issue was addressed with improved state management. This issue
    is fixed in Security Update 2022-003 Catalina, macOS Monterey 12.3, macOS Big
    Sur 11.6.5. An application may be able to gain elevated privileges.
  references:
  - source: product-security@apple.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/OpenPrinting/cups/commit/de4f8c196106033e4c372dce3e91b9d42b0b9444
  - source: product-security@apple.com
    tags:
    - Third Party Advisory
    url: https://github.com/mandiant/Vulnerability-Disclosures/blob/master/2022/MNDT-2022-0026/MNDT-2022-0026.md
  - source: product-security@apple.com
    tags:
    - Mailing List
    - Third Party Advisory
    url: https://lists.debian.org/debian-lts-announce/2022/05/msg00039.html
  - source: product-security@apple.com
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/KQ6TD7F3VRITPEHFDHZHK7MU6FEBMZ5U/
  - source: product-security@apple.com
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/YQRIT4H75XV6M42K7ZTARWZ7YLLYQHPO/
  - source: product-security@apple.com
    tags:
    - Release Notes
    - Vendor Advisory
    url: https://support.apple.com/en-us/HT213183
  - source: product-security@apple.com
    tags:
    - Release Notes
    - Vendor Advisory
    url: https://support.apple.com/en-us/HT213184
  - source: product-security@apple.com
    tags:
    - Release Notes
    - Vendor Advisory
    url: https://support.apple.com/en-us/HT213185
  - source: product-security@apple.com
    tags:
    - Third Party Advisory
    url: https://www.debian.org/security/2022/dsa-5149
  title: A logic issue was addressed with improved state management. This issue is
    fixed in Security Update 2022-003 Catalina, macOS Monterey 12.3, macOS Big Sur
    11.6.5. An application may be able to gain elevated privileges.
- diff_content:
  - "--- a/src/normal.c\n+++ b/src/normal.c\n@@ -4464,6 +4464,11 @@ nv_brackets(cmdarg_T\
    \ *cap)\n \t    clearop(cap->oap);\n \telse\n \t{\n+\t    // Make a copy, if the\
    \ line was changed it will be freed.\n+\t    ptr = vim_strnsave(ptr, len);\n+\t\
    \    if (ptr == NULL)\n+\t\treturn;\n+\n \t    find_pattern_in_path(ptr, 0, len,\
    \ TRUE,\n \t\tcap->count0 == 0 ? !isupper(cap->nchar) : FALSE,\n \t\t((cap->nchar\
    \ & 0xf) == ('d' & 0xf)) ?  FIND_DEFINE : FIND_ANY,\n@@ -4472,6 +4477,7 @@ nv_brackets(cmdarg_T\
    \ *cap)\n \t\t\t    islower(cap->nchar) ? ACTION_SHOW : ACTION_GOTO,\n \t\tcap->cmdchar\
    \ == ']' ? curwin->w_cursor.lnum + 1 : (linenr_T)1,\n \t\t(linenr_T)MAXLNUM);\n\
    +\t    vim_free(ptr);\n \t    curwin->w_set_curswant = TRUE;\n \t}\n     }"
  - "--- a/src/version.c\n+++ b/src/version.c\n@@ -734,6 +734,8 @@ static char *(features[])\
    \ =\n \n static int included_patches[] =\n {   /* Add new patch number below this\
    \ line */\n+/**/\n+    5024,\n /**/\n     5023,\n /**/"
  identifiers:
  - CVE-2022-1898
  - CWE-416
  overview: Use After Free in GitHub repository vim/vim prior to 8.2.
  references:
  - source: security@huntr.dev
    tags:
    - Mailing List
    - Third Party Advisory
    url: http://seclists.org/fulldisclosure/2022/Oct/28
  - source: security@huntr.dev
    tags:
    - Mailing List
    - Third Party Advisory
    url: http://seclists.org/fulldisclosure/2022/Oct/41
  - source: security@huntr.dev
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/vim/vim/commit/e2fa213cf571041dbd04ab0329303ffdc980678a
  - source: security@huntr.dev
    tags:
    - Exploit
    - Issue Tracking
    - Patch
    - Third Party Advisory
    url: https://huntr.dev/bounties/45aad635-c2f1-47ca-a4f9-db5b25979cea
  - source: security@huntr.dev
    tags:
    - Mailing List
    - Third Party Advisory
    url: https://lists.debian.org/debian-lts-announce/2022/06/msg00014.html
  - source: security@huntr.dev
    tags:
    - Mailing List
    - Third Party Advisory
    url: https://lists.debian.org/debian-lts-announce/2022/11/msg00009.html
  - source: security@huntr.dev
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/OZSLFIKFYU5Y2KM5EJKQNYHWRUBDQ4GJ/
  - source: security@huntr.dev
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/QMFHBC5OQXDPV2SDYA2JUQGVCPYASTJB/
  - source: security@huntr.dev
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/TYNK6SDCMOLQJOI3B4AOE66P2G2IH4ZM/
  - source: security@huntr.dev
    tags:
    - Third Party Advisory
    url: https://security.gentoo.org/glsa/202208-32
  - source: security@huntr.dev
    url: https://security.gentoo.org/glsa/202305-16
  - source: security@huntr.dev
    tags:
    - Third Party Advisory
    url: https://support.apple.com/kb/HT213488
  title: Use After Free in GitHub repository vim/vim prior to 8.2.
- diff_content:
  - "--- a/src/parse_rawml.c\n+++ b/src/parse_rawml.c\n@@ -107,7 +107,7 @@ MOBI_RET\
    \ mobi_search_links_kf7(MOBIResult *result, const unsigned char *data_sta\n  \
    \                   result->value[i++] = (char) *data++;\n                 }\n\
    \                 /* self closing tag '/>' */\n-                if (*(data - 1)\
    \ == '/' && *data == '>') {\n+                if (data <= data_end && *(data -\
    \ 1) == '/' && *data == '>') {\n                     --data; --i;\n          \
    \       }\n                 result->end = data;\n@@ -182,7 +182,7 @@ MOBI_RET\
    \ mobi_find_attrvalue(MOBIResult *result, const unsigned char *data_start\n  \
    \               result->value[i++] = (char) *data++;\n             }\n       \
    \      /* self closing tag '/>' */\n-            if (*(data - 1) == '/' && *data\
    \ == '>') {\n+            if (data <= data_end && *(data - 1) == '/' && *data\
    \ == '>') {\n                 --data; --i;\n             }\n             result->end\
    \ = data;\n@@ -354,7 +354,7 @@ size_t mobi_get_attribute_value(char *value, const\
    \ unsigned char *data, const si\n                 length--;\n             }\n\
    \             /* self closing tag '/>' */\n-            if (*(data - 1) == '/'\
    \ && *data == '>') {\n+            if (length && *(data - 1) == '/' && *data ==\
    \ '>') {\n                 value--;\n             }\n             *value = '\\\
    0';"
  identifiers:
  - CVE-2022-1907
  - CWE-125
  overview: Buffer Over-read in GitHub repository bfabiszewski/libmobi prior to 0.11.
  references:
  - source: security@huntr.dev
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/bfabiszewski/libmobi/commit/1e0378e6f9e4ae415cedc9eb10850888897c5dba
  - source: security@huntr.dev
    tags:
    - Exploit
    - Issue Tracking
    - Patch
    - Third Party Advisory
    url: https://huntr.dev/bounties/4eb0fa3e-4480-4fb5-8ec0-fbcd71de6012
  title: Buffer Over-read in GitHub repository bfabiszewski/libmobi prior to 0.11.
- diff_content:
  - "--- a/src/parse_rawml.c\n+++ b/src/parse_rawml.c\n@@ -107,7 +107,7 @@ MOBI_RET\
    \ mobi_search_links_kf7(MOBIResult *result, const unsigned char *data_sta\n  \
    \                   result->value[i++] = (char) *data++;\n                 }\n\
    \                 /* self closing tag '/>' */\n-                if (*(data - 1)\
    \ == '/' && *data == '>') {\n+                if (data <= data_end && *(data -\
    \ 1) == '/' && *data == '>') {\n                     --data; --i;\n          \
    \       }\n                 result->end = data;\n@@ -182,7 +182,7 @@ MOBI_RET\
    \ mobi_find_attrvalue(MOBIResult *result, const unsigned char *data_start\n  \
    \               result->value[i++] = (char) *data++;\n             }\n       \
    \      /* self closing tag '/>' */\n-            if (*(data - 1) == '/' && *data\
    \ == '>') {\n+            if (data <= data_end && *(data - 1) == '/' && *data\
    \ == '>') {\n                 --data; --i;\n             }\n             result->end\
    \ = data;\n@@ -354,7 +354,7 @@ size_t mobi_get_attribute_value(char *value, const\
    \ unsigned char *data, const si\n                 length--;\n             }\n\
    \             /* self closing tag '/>' */\n-            if (*(data - 1) == '/'\
    \ && *data == '>') {\n+            if (length && *(data - 1) == '/' && *data ==\
    \ '>') {\n                 value--;\n             }\n             *value = '\\\
    0';"
  identifiers:
  - CVE-2022-1908
  - CWE-125
  overview: Buffer Over-read in GitHub repository bfabiszewski/libmobi prior to 0.11.
  references:
  - source: security@huntr.dev
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/bfabiszewski/libmobi/commit/1e0378e6f9e4ae415cedc9eb10850888897c5dba
  - source: security@huntr.dev
    tags:
    - Exploit
    - Issue Tracking
    - Patch
    - Third Party Advisory
    url: https://huntr.dev/bounties/a7436e88-0488-4bd4-816f-2e2c803e93e8
  title: Buffer Over-read in GitHub repository bfabiszewski/libmobi prior to 0.11.
- diff_content:
  - "--- a/src/normal.c\n+++ b/src/normal.c\n@@ -183,6 +183,22 @@ find_command(int\
    \ cmdchar)\n     return idx;\n }\n \n+/*\n+ * If currently editing a cmdline or\
    \ text is locked: beep and give an error\n+ * message, return TRUE.\n+ */\n+ \
    \   static int\n+check_text_locked(oparg_T *oap)\n+{\n+    if (text_locked())\n\
    +    {\n+\tclearopbeep(oap);\n+\ttext_locked_msg();\n+\treturn TRUE;\n+    }\n\
    +    return FALSE;\n+}\n+\n /*\n  * Handle the count before a normal command and\
    \ set cap->count0.\n  */\n@@ -802,14 +818,9 @@ normal_cmd(\n \tgoto normal_end;\n\
    \     }\n \n-    if (text_locked() && (nv_cmds[idx].cmd_flags & NV_NCW))\n-  \
    \  {\n-\t// This command is not allowed while editing a cmdline: beep.\n-\tclearopbeep(oap);\n\
    -\ttext_locked_msg();\n-\tgoto normal_end;\n-    }\n-    if ((nv_cmds[idx].cmd_flags\
    \ & NV_NCW) && curbuf_locked())\n+    if ((nv_cmds[idx].cmd_flags & NV_NCW)\n\
    +\t\t\t\t&& (check_text_locked(oap) || curbuf_locked()))\n+\t// this command is\
    \ not allowed now\n \tgoto normal_end;\n \n     // In Visual/Select mode, a few\
    \ keys are handled in a special way.\n@@ -4049,12 +4060,8 @@ nv_gotofile(cmdarg_T\
    \ *cap)\n     char_u\t*ptr;\n     linenr_T\tlnum = -1;\n \n-    if (text_locked())\n\
    -    {\n-\tclearopbeep(cap->oap);\n-\ttext_locked_msg();\n+    if (check_text_locked(cap->oap))\n\
    \ \treturn;\n-    }\n     if (curbuf_locked())\n     {\n \tclearop(cap->oap);\n\
    @@ -6182,14 +6189,7 @@ nv_g_cmd(cmdarg_T *cap)\n \n     // \"gQ\": improved Ex\
    \ mode\n     case 'Q':\n-\tif (text_locked())\n-\t{\n-\t    clearopbeep(cap->oap);\n\
    -\t    text_locked_msg();\n-\t    break;\n-\t}\n-\n-\tif (!checkclearopq(oap))\n\
    +\tif (!check_text_locked(cap->oap) && !checkclearopq(oap))\n \t    do_exmode(TRUE);\n\
    \ \tbreak;\n "
  - "--- a/src/undo.c\n+++ b/src/undo.c\n@@ -2327,6 +2327,12 @@ undo_time(\n     int\t\
    \t    above = FALSE;\n     int\t\t    did_undo = TRUE;\n \n+    if (text_locked())\n\
    +    {\n+\ttext_locked_msg();\n+\treturn;\n+    }\n+\n     // First make sure\
    \ the current undoable change is synced.\n     if (curbuf->b_u_synced == FALSE)\n\
    \ \tu_sync(TRUE);"
  - "--- a/src/version.c\n+++ b/src/version.c\n@@ -734,6 +734,8 @@ static char *(features[])\
    \ =\n \n static int included_patches[] =\n {   /* Add new patch number below this\
    \ line */\n+/**/\n+    5023,\n /**/\n     5022,\n /**/"
  identifiers:
  - CVE-2022-1897
  - CWE-787
  overview: Out-of-bounds Write in GitHub repository vim/vim prior to 8.2.
  references:
  - source: security@huntr.dev
    tags:
    - Mailing List
    - Third Party Advisory
    url: http://seclists.org/fulldisclosure/2022/Oct/28
  - source: security@huntr.dev
    tags:
    - Mailing List
    - Third Party Advisory
    url: http://seclists.org/fulldisclosure/2022/Oct/41
  - source: security@huntr.dev
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/vim/vim/commit/338f1fc0ee3ca929387448fe464579d6113fa76a
  - source: security@huntr.dev
    tags:
    - Exploit
    - Patch
    - Third Party Advisory
    url: https://huntr.dev/bounties/82c12151-c283-40cf-aa05-2e39efa89118
  - source: security@huntr.dev
    tags:
    - Mailing List
    - Third Party Advisory
    url: https://lists.debian.org/debian-lts-announce/2022/11/msg00032.html
  - source: security@huntr.dev
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/OZSLFIKFYU5Y2KM5EJKQNYHWRUBDQ4GJ/
  - source: security@huntr.dev
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/QMFHBC5OQXDPV2SDYA2JUQGVCPYASTJB/
  - source: security@huntr.dev
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/TYNK6SDCMOLQJOI3B4AOE66P2G2IH4ZM/
  - source: security@huntr.dev
    tags:
    - Third Party Advisory
    url: https://security.gentoo.org/glsa/202208-32
  - source: security@huntr.dev
    url: https://security.gentoo.org/glsa/202305-16
  - source: security@huntr.dev
    tags:
    - Third Party Advisory
    url: https://support.apple.com/kb/HT213488
  title: Out-of-bounds Write in GitHub repository vim/vim prior to 8.2.
- diff_content:
  - "--- a/src/ex_docmd.c\n+++ b/src/ex_docmd.c\n@@ -3280,6 +3280,8 @@ parse_cmd_address(exarg_T\
    \ *eap, char **errormsg, int silent)\n {\n     int\t\taddress_count = 1;\n   \
    \  linenr_T\tlnum;\n+    int\t\tneed_check_cursor = FALSE;\n+    int\t\tret =\
    \ FAIL;\n \n     // Repeat for all ',' or ';' separated addresses.\n     for (;;)\n\
    @@ -3290,7 +3292,7 @@ parse_cmd_address(exarg_T *eap, char **errormsg, int silent)\n\
    \ \tlnum = get_address(eap, &eap->cmd, eap->addr_type, eap->skip, silent,\n \t\
    \t\t\t\teap->addr_count == 0, address_count++);\n \tif (eap->cmd == NULL)\t//\
    \ error detected\n-\t    return FAIL;\n+\t    goto theend;\n \tif (lnum == MAXLNUM)\n\
    \ \t{\n \t    if (*eap->cmd == '%')   // '%' - all lines\n@@ -3335,14 +3337,14\
    \ @@ parse_cmd_address(exarg_T *eap, char **errormsg, int silent)\n \t\t\t   \
    \ // there is no Vim command which uses '%' and\n \t\t\t    // ADDR_WINDOWS or\
    \ ADDR_TABS\n \t\t\t    *errormsg = _(e_invalid_range);\n-\t\t\t    return FAIL;\n\
    +\t\t\t    goto theend;\n \t\t\t}\n \t\t\tbreak;\n \t\t    case ADDR_TABS_RELATIVE:\n\
    \ \t\t    case ADDR_UNSIGNED:\n \t\t    case ADDR_QUICKFIX:\n \t\t\t*errormsg\
    \ = _(e_invalid_range);\n-\t\t\treturn FAIL;\n+\t\t\tgoto theend;\n \t\t    case\
    \ ADDR_ARGUMENTS:\n \t\t\tif (ARGCOUNT == 0)\n \t\t\t    eap->line1 = eap->line2\
    \ = 0;\n@@ -3374,19 +3376,19 @@ parse_cmd_address(exarg_T *eap, char **errormsg,\
    \ int silent)\n \t\tif (eap->addr_type != ADDR_LINES)\n \t\t{\n \t\t    *errormsg\
    \ = _(e_invalid_range);\n-\t\t    return FAIL;\n+\t\t    goto theend;\n \t\t}\n\
    \ \n \t\t++eap->cmd;\n \t\tif (!eap->skip)\n \t\t{\n \t\t    fp = getmark('<',\
    \ FALSE);\n \t\t    if (check_mark(fp) == FAIL)\n-\t\t\treturn FAIL;\n+\t\t\t\
    goto theend;\n \t\t    eap->line1 = fp->lnum;\n \t\t    fp = getmark('>', FALSE);\n\
    \ \t\t    if (check_mark(fp) == FAIL)\n-\t\t\treturn FAIL;\n+\t\t\tgoto theend;\n\
    \ \t\t    eap->line2 = fp->lnum;\n \t\t    ++eap->addr_count;\n \t\t}\n@@ -3401,10\
    \ +3403,13 @@ parse_cmd_address(exarg_T *eap, char **errormsg, int silent)\n \t\
    \    if (!eap->skip)\n \t    {\n \t\tcurwin->w_cursor.lnum = eap->line2;\n+\n\
    \ \t\t// Don't leave the cursor on an illegal line or column, but do\n \t\t//\
    \ accept zero as address, so 0;/PATTERN/ works correctly.\n+\t\t// Check the cursor\
    \ position before returning.\n \t\tif (eap->line2 > 0)\n \t\t    check_cursor();\n\
    +\t\tneed_check_cursor = TRUE;\n \t    }\n \t}\n \telse if (*eap->cmd != ',')\n\
    @@ -3420,7 +3425,12 @@ parse_cmd_address(exarg_T *eap, char **errormsg, int silent)\n\
    \ \tif (lnum == MAXLNUM)\n \t    eap->addr_count = 0;\n     }\n-    return OK;\n\
    +    ret = OK;\n+\n+theend:\n+    if (need_check_cursor)\n+\tcheck_cursor();\n\
    +    return ret;\n }\n \n /*"
  - "--- a/src/version.c\n+++ b/src/version.c\n@@ -734,6 +734,8 @@ static char *(features[])\
    \ =\n \n static int included_patches[] =\n {   /* Add new patch number below this\
    \ line */\n+/**/\n+    5037,\n /**/\n     5036,\n /**/"
  identifiers:
  - CVE-2022-1927
  - CWE-126
  overview: Buffer Over-read in GitHub repository vim/vim prior to 8.2.
  references:
  - source: security@huntr.dev
    url: http://seclists.org/fulldisclosure/2022/Oct/28
  - source: security@huntr.dev
    tags:
    - Mailing List
    - Third Party Advisory
    url: http://seclists.org/fulldisclosure/2022/Oct/41
  - source: security@huntr.dev
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/vim/vim/commit/4d97a565ae8be0d4debba04ebd2ac3e75a0c8010
  - source: security@huntr.dev
    tags:
    - Exploit
    - Patch
    - Third Party Advisory
    url: https://huntr.dev/bounties/945107ef-0b27-41c7-a03c-db99def0e777
  - source: security@huntr.dev
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/OZSLFIKFYU5Y2KM5EJKQNYHWRUBDQ4GJ/
  - source: security@huntr.dev
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/QMFHBC5OQXDPV2SDYA2JUQGVCPYASTJB/
  - source: security@huntr.dev
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/TYNK6SDCMOLQJOI3B4AOE66P2G2IH4ZM/
  - source: security@huntr.dev
    tags:
    - Third Party Advisory
    url: https://security.gentoo.org/glsa/202208-32
  - source: security@huntr.dev
    url: https://security.gentoo.org/glsa/202305-16
  - source: security@huntr.dev
    tags:
    - Third Party Advisory
    url: https://support.apple.com/kb/HT213488
  title: Buffer Over-read in GitHub repository vim/vim prior to 8.2.
- diff_content:
  - "--- a/src/vm.c\n+++ b/src/vm.c\n@@ -1159,18 +1159,20 @@ check_target_class(mrb_state\
    \ *mrb)\n   return target;\n }\n \n+#define regs (mrb->c->ci->stack)\n+\n static\
    \ mrb_value\n-hash_new_from_values(mrb_state *mrb, mrb_int argc, mrb_value *regs)\n\
    +hash_new_from_regs(mrb_state *mrb, mrb_int argc, mrb_int idx)\n {\n   mrb_value\
    \ hash = mrb_hash_new_capa(mrb, argc);\n   while (argc--) {\n-    mrb_hash_set(mrb,\
    \ hash, regs[0], regs[1]);\n-    regs += 2;\n+    mrb_hash_set(mrb, hash, regs[idx+0],\
    \ regs[idx+1]);\n+    idx += 2;\n   }\n   return hash;\n }\n \n-#define ARGUMENT_NORMALIZE(arg_base,\
    \ arg_info, insn) do { \\\n+#define ARGUMENT_NORMALIZE(arg_base, arg_info, insn)\
    \ do {       \\\n   int n = *(arg_info)&0xf; \\\n   int nk = (*(arg_info)>>4)&0xf;\
    \ \\\n   mrb_int bidx = (arg_base) + mrb_bidx(*(arg_info)); \\\n@@ -1179,7 +1181,7\
    \ @@ hash_new_from_values(mrb_state *mrb, mrb_int argc, mrb_value *regs)\n   }\
    \ \\\n   else if (nk > 0) {  /* pack keyword arguments */ \\\n     mrb_int kidx\
    \ = (arg_base)+(n==CALL_MAXARGS?1:n)+1; \\\n-    mrb_value kdict = hash_new_from_values(mrb,\
    \ nk, regs+kidx); \\\n+    mrb_value kdict = hash_new_from_regs(mrb, nk, kidx);\
    \ \\\n     regs[kidx] = kdict; \\\n     nk = CALL_MAXARGS; \\\n     *(arg_info)\
    \ = n | (nk<<4); \\\n@@ -1242,7 +1244,6 @@ mrb_vm_exec(mrb_state *mrb, const struct\
    \ RProc *proc, const mrb_code *pc)\n   mrb->jmp = &c_jmp;\n   mrb_vm_ci_proc_set(mrb->c->ci,\
    \ proc);\n \n-#define regs (mrb->c->ci->stack)\n   INIT_DISPATCH {\n     CASE(OP_NOP,\
    \ Z) {\n       /* do nothing */"
  identifiers:
  - CVE-2022-1934
  - CWE-416
  overview: Use After Free in GitHub repository mruby/mruby prior to 3.2.
  references:
  - source: security@huntr.dev
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/mruby/mruby/commit/aa7f98dedb68d735a1665d3a289036c88b0c47ce
  - source: security@huntr.dev
    tags:
    - Exploit
    - Patch
    - Third Party Advisory
    url: https://huntr.dev/bounties/99e6df06-b9f7-4c53-a722-6bb89fbfb51f
  title: Use After Free in GitHub repository mruby/mruby prior to 3.2.
- diff_content:
  - "--- a/src/buffer.c\n+++ b/src/buffer.c\n@@ -2407,12 +2407,7 @@ buflist_getfile(\n\
    \     if (buf == curbuf)\n \treturn OK;\n \n-    if (text_locked())\n-    {\n\
    -\ttext_locked_msg();\n-\treturn FAIL;\n-    }\n-    if (curbuf_locked())\n+ \
    \   if (text_or_buf_locked())\n \treturn FAIL;\n \n     // altfpos may be changed\
    \ by getfile(), get it now"
  - "--- a/src/ex_getln.c\n+++ b/src/ex_getln.c\n@@ -2739,6 +2739,21 @@ get_text_locked_msg(void)\n\
    \     return e_not_allowed_to_change_text_or_change_window;\n }\n \n+/*\n+ * Check\
    \ for text, window or buffer locked.\n+ * Give an error message and return TRUE\
    \ if something is locked.\n+ */\n+    int\n+text_or_buf_locked(void)\n+{\n+  \
    \  if (text_locked())\n+    {\n+\ttext_locked_msg();\n+\treturn TRUE;\n+    }\n\
    +    return curbuf_locked();\n+}\n+\n /*\n  * Check if \"curbuf_lock\" or \"allbuf_lock\"\
    \ is set and return TRUE when it is\n  * and give an error message.\n@@ -4379,6\
    \ +4394,10 @@ open_cmdwin(void)\n     int\t\t\tsave_KeyTyped;\n #endif\n \n+ \
    \   // Can't do this when text or buffer is locked.\n+    if (text_or_buf_locked())\n\
    +\treturn K_IGNORE;\n+\n     // Can't do this recursively.  Can't do it when typing\
    \ a password.\n     if (cmdwin_type != 0\n # if defined(FEAT_CRYPT) || defined(FEAT_EVAL)"
  - "--- a/src/version.c\n+++ b/src/version.c\n@@ -734,6 +734,8 @@ static char *(features[])\
    \ =\n \n static int included_patches[] =\n {   /* Add new patch number below this\
    \ line */\n+/**/\n+    5043,\n /**/\n     5042,\n /**/"
  - "--- a/src/window.c\n+++ b/src/window.c\n@@ -4585,14 +4585,11 @@ win_goto(win_T\
    \ *wp)\n \treturn;\n     }\n #endif\n-    if (text_locked())\n+    if (text_or_buf_locked())\n\
    \     {\n \tbeep_flush();\n-\ttext_locked_msg();\n \treturn;\n     }\n-    if\
    \ (curbuf_locked())\n-\treturn;\n \n     if (wp->w_buffer != curbuf)\n \treset_VIsual_and_resel();"
  identifiers:
  - CVE-2022-1942
  - CWE-122
  overview: Heap-based Buffer Overflow in GitHub repository vim/vim prior to 8.2.
  references:
  - source: security@huntr.dev
    tags:
    - Mailing List
    - Third Party Advisory
    url: http://seclists.org/fulldisclosure/2022/Oct/28
  - source: security@huntr.dev
    tags:
    - Mailing List
    - Third Party Advisory
    url: http://seclists.org/fulldisclosure/2022/Oct/41
  - source: security@huntr.dev
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/vim/vim/commit/71223e2db87c2bf3b09aecb46266b56cda26191d
  - source: security@huntr.dev
    tags:
    - Exploit
    - Patch
    - Third Party Advisory
    url: https://huntr.dev/bounties/67ca4d3b-9175-43c1-925c-72a7091bc071
  - source: security@huntr.dev
    tags:
    - Mailing List
    - Third Party Advisory
    url: https://lists.debian.org/debian-lts-announce/2022/11/msg00032.html
  - source: security@huntr.dev
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/TYNK6SDCMOLQJOI3B4AOE66P2G2IH4ZM/
  - source: security@huntr.dev
    tags:
    - Third Party Advisory
    url: https://security.gentoo.org/glsa/202208-32
  - source: security@huntr.dev
    url: https://security.gentoo.org/glsa/202305-16
  - source: security@huntr.dev
    tags:
    - Third Party Advisory
    url: https://support.apple.com/kb/HT213488
  title: Heap-based Buffer Overflow in GitHub repository vim/vim prior to 8.2.
- diff_content:
  - "--- a/libsofia-sip-ua/url/url.c\n+++ b/libsofia-sip-ua/url/url.c\n@@ -364,7 +364,12\
    \ @@ char *url_canonize2(char *d, char const * const s, size_t n,\n       continue;\n\
    \     }\n \n-    h1 = s[i + 1], h2 = s[i + 2];\n+    h1 = s[i + 1];\n+    if (!h1)\
    \ {\n+        *d = '\\0';\n+        return NULL;\n+    }\n+    h2 = s[i + 2];\n\
    \ \n     if (!IS_HEX(h1) || !IS_HEX(h2)) {\n       *d = '\\0';\n@@ -422,7 +427,12\
    \ @@ char *url_canonize3(char *d, char const * const s, size_t n,\n       continue;\n\
    \     }\n \n-    h1 = s[i + 1], h2 = s[i + 2];\n+    h1 = s[i + 1];\n+    if (!h1)\
    \ {\n+        *d = '\\0';\n+        return NULL;\n+    }\n+    h2 = s[i + 2];\n\
    \ \n     if (!IS_HEX(h1) || !IS_HEX(h2)) {\n       *d = '\\0';"
  identifiers:
  - CVE-2022-31002
  - CWE-125
  overview: Sofia-SIP is an open-source Session Initiation Protocol (SIP) User-Agent
    library. Prior to version 1.13.8, an attacker can send a message with evil sdp
    to FreeSWITCH, which may cause a crash. This type of crash may be caused by a
    URL ending with `%`. Version 1.13.8 contains a patch for this issue.
  references:
  - source: security-advisories@github.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/freeswitch/sofia-sip/commit/51841eb53679434a386fb2dcbca925dcc48d58ba
  - source: security-advisories@github.com
    tags:
    - Exploit
    - Third Party Advisory
    url: https://github.com/freeswitch/sofia-sip/security/advisories/GHSA-g3x6-p824-x6hm
  - source: security-advisories@github.com
    tags:
    - Mailing List
    - Third Party Advisory
    url: https://lists.debian.org/debian-lts-announce/2022/09/msg00001.html
  - source: security-advisories@github.com
    tags:
    - Third Party Advisory
    url: https://security.gentoo.org/glsa/202210-18
  - source: security-advisories@github.com
    url: https://www.debian.org/security/2023/dsa-5410
  title: Sofia-SIP is an open-source Session Initiation Protocol (SIP) User-Agent
    library. Prior to version 1.13.8, an attacker can send a message with evil sdp
    to FreeSWITCH, which may cause a crash. This type of crash may be caused by a
    URL ending with `%`. Version 1.13.8 contains a patch for this issue.
- diff_content:
  - "--- a/libsofia-sip-ua/sip/sip_parser.c\n+++ b/libsofia-sip-ua/sip/sip_parser.c\n\
    @@ -454,6 +454,10 @@ sip_method_t sip_method_d(char **ss, char const **return_name)\n\
    \ \n #undef MATCH\n \n+  if (strlen(s) < n) {\n+    return sip_method_invalid;\n\
    +  }\n+\n   if (IS_NON_WS(s[n]))\n     /* Unknown method */\n     code = sip_method_unknown;"
  identifiers:
  - CVE-2022-31001
  - CWE-125
  overview: Sofia-SIP is an open-source Session Initiation Protocol (SIP) User-Agent
    library. Prior to version 1.13.8, an attacker can send a message with evil sdp
    to FreeSWITCH, which may cause crash. This type of crash may be caused by `#define
    MATCH(s, m) (strncmp(s, m, n = sizeof(m) - 1) == 0)`, which will make `n` bigger
    and trigger out-of-bound access when `IS_NON_WS(s[n])`. Version 1.13.8 contains
    a patch for this issue.
  references:
  - source: security-advisories@github.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/freeswitch/sofia-sip/commit/a99804b336d0e16d26ab7119d56184d2d7110a36
  - source: security-advisories@github.com
    tags:
    - Exploit
    - Third Party Advisory
    url: https://github.com/freeswitch/sofia-sip/security/advisories/GHSA-79jq-hh82-cv9g
  - source: security-advisories@github.com
    tags:
    - Mailing List
    - Third Party Advisory
    url: https://lists.debian.org/debian-lts-announce/2022/09/msg00001.html
  - source: security-advisories@github.com
    tags:
    - Third Party Advisory
    url: https://security.gentoo.org/glsa/202210-18
  - source: security-advisories@github.com
    tags:
    - Third Party Advisory
    url: https://www.debian.org/security/2023/dsa-5410
  title: Sofia-SIP is an open-source Session Initiation Protocol (SIP) User-Agent
    library. Prior to version 1.13.8, an attacker can send a message with evil sdp
    to FreeSWITCH, which may cause crash. This type of crash may be caused by `#define
    MATCH(s, m) (strncmp(s, m, n = sizeof(m) - 1) == 0)`, which will make `n` bigger
    and trigger out-of-bound access when `IS_NON_WS(s[n])`. Version 1.13.8 contains
    a patch for this issue.
- diff_content:
  - "--- a/libsofia-sip-ua/sdp/sdp_parse.c\n+++ b/libsofia-sip-ua/sdp/sdp_parse.c\n\
    @@ -396,6 +396,10 @@ static void parse_message(sdp_parser_t *p)\n        record\
    \ = next(&message, CRLF, strip)) {\n     field = record[0];\n \n+    if (strlen(record)\
    \ < 2) {\n+      return;\n+    }\n+\n     rest = record + 2; rest += strspn(rest,\
    \ strip);\n \n     if (record[1] != '=') {\n@@ -1763,6 +1767,10 @@ static void\
    \ parse_descs(sdp_parser_t *p,\n        record = next(&message, CRLF, strip))\
    \ {\n     char field = record[0];\n \n+    if (strlen(record) < 2) {\n+      return;\n\
    +    }\n+\n     rest = record + 2; rest += strspn(rest, strip);\n \n     if (record[1]\
    \ == '=') switch (field) {"
  identifiers:
  - CVE-2022-31003
  - CWE-122
  overview: Sofia-SIP is an open-source Session Initiation Protocol (SIP) User-Agent
    library. Prior to version 1.13.8, when parsing each line of a sdp message, `rest
    = record + 2` will access the memory behind `\0` and cause an out-of-bounds write.
    An attacker can send a message with evil sdp to FreeSWITCH, causing a crash or
    more serious consequence, such as remote code execution. Version 1.13.8 contains
    a patch for this issue.
  references:
  - source: security-advisories@github.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/freeswitch/sofia-sip/commit/907f2ac0ee504c93ebfefd676b4632a3575908c9
  - source: security-advisories@github.com
    tags:
    - Exploit
    - Third Party Advisory
    url: https://github.com/freeswitch/sofia-sip/security/advisories/GHSA-8w5j-6g2j-pxcp
  - source: security-advisories@github.com
    tags:
    - Mailing List
    - Third Party Advisory
    url: https://lists.debian.org/debian-lts-announce/2022/09/msg00001.html
  - source: security-advisories@github.com
    tags:
    - Third Party Advisory
    url: https://security.gentoo.org/glsa/202210-18
  - source: security-advisories@github.com
    url: https://www.debian.org/security/2023/dsa-5410
  title: Sofia-SIP is an open-source Session Initiation Protocol (SIP) User-Agent
    library. Prior to version 1.13.8, when parsing each line of a sdp message, `rest
    = record + 2` will access the memory behind `\0` and cause an out-of-bounds write.
    An attacker can send a message with evil sdp to FreeSWITCH, causing a crash or
    more serious consequence, such as remote code execution. Version 1.13.8 contains
    a patch for this issue.
- diff_content:
  - "--- a/src/search.c\n+++ b/src/search.c\n@@ -3305,6 +3305,21 @@ update_search_stat(\n\
    \ }\n \n #if defined(FEAT_FIND_ID) || defined(PROTO)\n+\n+/*\n+ * Get line \"\
    lnum\" and copy it into \"buf[LSIZE]\".\n+ * The copy is made because the regexp\
    \ may make the line invalid when using a\n+ * mark.\n+ */\n+    static char_u\
    \ *\n+get_line_and_copy(linenr_T lnum, char_u *buf)\n+{\n+    char_u *line = ml_get(lnum);\n\
    +\n+    vim_strncpy(buf, line, LSIZE - 1);\n+    return buf;\n+}\n+\n /*\n  *\
    \ Find identifiers or defines in included files.\n  * If p_ic && compl_status_sol()\
    \ then ptr must be in lowercase.\n@@ -3409,7 +3424,7 @@ find_pattern_in_path(\n\
    \ \tend_lnum = curbuf->b_ml.ml_line_count;\n     if (lnum > end_lnum)\t\t// do\
    \ at least one line\n \tlnum = end_lnum;\n-    line = ml_get(lnum);\n+    line\
    \ = get_line_and_copy(lnum, file_line);\n \n     for (;;)\n     {\n@@ -3738,7\
    \ +3753,7 @@ find_pattern_in_path(\n \t\t    {\n \t\t\tif (lnum >= end_lnum)\n\
    \ \t\t\t    goto exit_matched;\n-\t\t\tline = ml_get(++lnum);\n+\t\t\tline = get_line_and_copy(++lnum,\
    \ file_line);\n \t\t    }\n \t\t    else if (vim_fgets(line = file_line,\n \t\t\
    \t\t\t\t      LSIZE, files[depth].fp))\n@@ -3950,7 +3965,7 @@ find_pattern_in_path(\n\
    \ \t{\n \t    if (++lnum > end_lnum)\n \t\tbreak;\n-\t    line = ml_get(lnum);\n\
    +\t    line = get_line_and_copy(lnum, file_line);\n \t}\n \talready = NULL;\n\
    \     }"
  - "--- a/src/version.c\n+++ b/src/version.c\n@@ -734,6 +734,8 @@ static char *(features[])\
    \ =\n \n static int included_patches[] =\n {   /* Add new patch number below this\
    \ line */\n+/**/\n+    5050,\n /**/\n     5049,\n /**/"
  identifiers:
  - CVE-2022-1968
  - CWE-416
  overview: Use After Free in GitHub repository vim/vim prior to 8.2.
  references:
  - source: security@huntr.dev
    tags:
    - Mailing List
    - Third Party Advisory
    url: http://seclists.org/fulldisclosure/2022/Oct/28
  - source: security@huntr.dev
    tags:
    - Mailing List
    - Third Party Advisory
    url: http://seclists.org/fulldisclosure/2022/Oct/41
  - source: security@huntr.dev
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/vim/vim/commit/409510c588b1eec1ae33511ae97a21eb8e110895
  - source: security@huntr.dev
    tags:
    - Exploit
    - Third Party Advisory
    url: https://huntr.dev/bounties/949090e5-f4ea-4edf-bd79-cd98f0498a5b
  - source: security@huntr.dev
    tags:
    - Mailing List
    - Third Party Advisory
    url: https://lists.debian.org/debian-lts-announce/2022/06/msg00014.html
  - source: security@huntr.dev
    tags:
    - Mailing List
    - Third Party Advisory
    url: https://lists.debian.org/debian-lts-announce/2022/11/msg00009.html
  - source: security@huntr.dev
    tags:
    - Third Party Advisory
    url: https://security.gentoo.org/glsa/202208-32
  - source: security@huntr.dev
    url: https://security.gentoo.org/glsa/202305-16
  - source: security@huntr.dev
    tags:
    - Third Party Advisory
    url: https://support.apple.com/kb/HT213488
  title: Use After Free in GitHub repository vim/vim prior to 8.2.
- diff_content:
  - "--- a/uc.c\n+++ b/uc.c\n@@ -388,6 +388,7 @@ uc_err uc_open(uc_arch arch, uc_mode\
    \ mode, uc_engine **result)\n         }\n \n         if (uc->init_arch == NULL)\
    \ {\n+            free(uc);\n             return UC_ERR_ARCH;\n         }\n "
  identifiers:
  - CVE-2022-29693
  - CWE-401
  overview: Unicorn Engine v2.0.0-rc7 and below was discovered to contain a memory
    leak via the function uc_close at /my/unicorn/uc.c.
  references:
  - source: cve@mitre.org
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/unicorn-engine/unicorn/commit/469fc4c35a0cfabdbefb158e22d145f4ee6f77b9
  - source: cve@mitre.org
    tags:
    - Exploit
    - Issue Tracking
    - Third Party Advisory
    url: https://github.com/unicorn-engine/unicorn/issues/1586
  title: Unicorn Engine v2.0.0-rc7 and below was discovered to contain a memory leak
    via the function uc_close at /my/unicorn/uc.c.
- diff_content:
  - "--- a/qemu/exec.c\n+++ b/qemu/exec.c\n@@ -42,7 +42,7 @@\n #include \"exec/ram_addr.h\"\
    \n \n #include \"qemu/range.h\"\n-\n+#include \"qemu/rcu_queue.h\"\n #include\
    \ \"uc_priv.h\"\n \n typedef struct PhysPageEntry PhysPageEntry;\n@@ -966,7 +966,7\
    \ @@ static ram_addr_t find_ram_offset(struct uc_struct *uc, ram_addr_t size)\n\
    \ \n     assert(size != 0); /* it would hand out same offset multiple times */\n\
    \ \n-    if (QLIST_EMPTY(&uc->ram_list.blocks)) {\n+    if (QLIST_EMPTY_RCU(&uc->ram_list.blocks))\
    \ {\n         return 0;\n     }\n \n@@ -1043,6 +1043,8 @@ static void ram_block_add(struct\
    \ uc_struct *uc, RAMBlock *new_block)\n         new_block->host = phys_mem_alloc(uc,\
    \ new_block->max_length,\n                 &new_block->mr->align);\n         if\
    \ (!new_block->host) {\n+            // mmap fails.\n+            uc->invalid_error\
    \ = UC_ERR_NOMEM;\n             // error_setg_errno(errp, errno,\n           \
    \  //         \"cannot set up guest memory '%s'\",\n             //         memory_region_name(new_block->mr));\n\
    @@ -1062,11 +1064,11 @@ static void ram_block_add(struct uc_struct *uc, RAMBlock\
    \ *new_block)\n         }\n     }\n     if (block) {\n-        QLIST_INSERT_BEFORE(block,\
    \ new_block, next);\n+        QLIST_INSERT_BEFORE_RCU(block, new_block, next);\n\
    \     } else if (last_block) {\n-        QLIST_INSERT_AFTER(last_block, new_block,\
    \ next);\n+        QLIST_INSERT_AFTER_RCU(last_block, new_block, next);\n    \
    \ } else { /* list is empty */\n-        QLIST_INSERT_HEAD(&uc->ram_list.blocks,\
    \ new_block, next);\n+        QLIST_INSERT_HEAD_RCU(&uc->ram_list.blocks, new_block,\
    \ next);\n     }\n     uc->ram_list.mru_block = NULL;\n \n@@ -1099,8 +1101,15\
    \ @@ RAMBlock *qemu_ram_alloc_from_ptr(struct uc_struct *uc, ram_addr_t size,\
    \ void *h\n     if (host) {\n         new_block->flags |= RAM_PREALLOC;\n    \
    \ }\n+\n+    uc->invalid_addr = UC_ERR_OK;\n     ram_block_add(mr->uc, new_block);\n\
    \ \n+    if (uc->invalid_error != UC_ERR_OK) {\n+        g_free(new_block);\n\
    +        return NULL;\n+    }\n+\n     return new_block;\n }\n \n@@ -1130,7 +1139,7\
    \ @@ void qemu_ram_free(struct uc_struct *uc, RAMBlock *block)\n     //    ram_block_notify_remove(block->host,\
    \ block->max_length);\n     //}\n \n-    QLIST_REMOVE(block, next);\n+    QLIST_REMOVE_RCU(block,\
    \ next);\n     uc->ram_list.mru_block = NULL;\n     /* Write list before version\
    \ */\n     //smp_wmb();"
  - "--- a/qemu/softmmu/memory.c\n+++ b/qemu/softmmu/memory.c\n@@ -43,8 +43,9 @@ MemoryRegion\
    \ *memory_map(struct uc_struct *uc, hwaddr begin, size_t size, uint32\n     MemoryRegion\
    \ *ram = g_new(MemoryRegion, 1);\n \n     memory_region_init_ram(uc, ram, size,\
    \ perms);\n-    if (ram->addr == -1) {\n+    if (ram->addr == -1 || !ram->ram_block)\
    \ {\n         // out of memory\n+        g_free(ram);\n         return NULL;\n\
    \     }\n \n@@ -63,8 +64,9 @@ MemoryRegion *memory_map_ptr(struct uc_struct *uc,\
    \ hwaddr begin, size_t size, ui\n \n     memory_region_init_ram_ptr(uc, ram, size,\
    \ ptr);\n     ram->perms = perms;\n-    if (ram->addr == -1) {\n+    if (ram->addr\
    \ == -1 || !ram->ram_block) {\n         // out of memory\n+        g_free(ram);\n\
    \         return NULL;\n     }\n "
  - "--- a/tests/unit/test_mem.c\n+++ b/tests/unit/test_mem.c\n@@ -175,6 +175,18 @@\
    \ static void test_map_wrap(void)\n     OK(uc_close(uc));\n }\n \n+static void\
    \ test_map_big_memory(void)\n+{\n+    uc_engine *uc;\n+\n+    OK(uc_open(UC_ARCH_X86,\
    \ UC_MODE_64, &uc));\n+\n+    uc_assert_err(UC_ERR_NOMEM,\n+                 \
    \ uc_mem_map(uc, 0x0, 0xfffffffffffff000, UC_PROT_ALL));\n+\n+    OK(uc_close(uc));\n\
    +}\n+\n TEST_LIST = {{\"test_map_correct\", test_map_correct},\n             \
    \ {\"test_map_wrapping\", test_map_wrapping},\n              {\"test_mem_protect\"\
    , test_mem_protect},\n@@ -183,4 +195,5 @@ TEST_LIST = {{\"test_map_correct\",\
    \ test_map_correct},\n              {\"test_mem_protect_map_ptr\", test_mem_protect_map_ptr},\n\
    \              {\"test_map_at_the_end\", test_map_at_the_end},\n             \
    \ {\"test_map_wrap\", test_map_wrap},\n+             {\"test_map_big_memory\"\
    , test_map_big_memory},\n              {NULL, NULL}};"
  identifiers:
  - CVE-2022-29694
  - CWE-476
  overview: Unicorn Engine v2.0.0-rc7 and below was discovered to contain a NULL pointer
    dereference via qemu_ram_free.
  references:
  - source: cve@mitre.org
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/unicorn-engine/unicorn/commit/3d3deac5e6d38602b689c4fef5dac004f07a2e63
  - source: cve@mitre.org
    tags:
    - Exploit
    - Issue Tracking
    - Third Party Advisory
    url: https://github.com/unicorn-engine/unicorn/issues/1588
  - source: cve@mitre.org
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/unicorn-engine/unicorn/pull/1593/commits/31389e59457f304be3809f9679f91a42daa7ebaa
  - source: cve@mitre.org
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/unicorn-engine/unicorn/pull/1593/commits/6a879a082d4d67a5d13f1233ae0334cde0a7f844
  - source: cve@mitre.org
    tags:
    - Exploit
    - Technical Description
    - Third Party Advisory
    url: https://violentbinary.github.io/posts/2-simple-analysis-of-software-virtualization-of-memory-in-unicorn-engine/
  title: Unicorn Engine v2.0.0-rc7 and below was discovered to contain a NULL pointer
    dereference via qemu_ram_free.
- diff_content:
  - "--- a/DesktopEditor/common/File.cpp\n+++ b/DesktopEditor/common/File.cpp\n@@\
    \ -159,60 +159,90 @@ namespace NSFile\n             else if (0x00 == (byteMain\
    \ & 0x20))\n             {\n                 // 2 byte\n-                int val\
    \ = (int)(((byteMain & 0x1F) << 6) |\n-                    (pBuffer[lIndex + 1]\
    \ & 0x3F));\n+                int val = 0;\n+                if ((lIndex + 1)\
    \ < lCount)\n+                {\n+                    val = (int)(((byteMain &\
    \ 0x1F) << 6) |\n+                                (pBuffer[lIndex + 1] & 0x3F));\n\
    +                }\n+\n                 pUnicodeString[lIndexUnicode++] = (WCHAR)(val);\n\
    \                 lIndex += 2;\n             }\n             else if (0x00 ==\
    \ (byteMain & 0x10))\n             {\n                 // 3 byte\n-          \
    \      int val = (int)(((byteMain & 0x0F) << 12) |\n-                    ((pBuffer[lIndex\
    \ + 1] & 0x3F) << 6) |\n-                    (pBuffer[lIndex + 2] & 0x3F));\n\
    +                int val = 0;\n+                if ((lIndex + 2) < lCount)\n+\
    \                {\n+                    val = (int)(((byteMain & 0x0F) << 12)\
    \ |\n+                                ((pBuffer[lIndex + 1] & 0x3F) << 6) |\n\
    +                                (pBuffer[lIndex + 2] & 0x3F));\n+           \
    \     }\n+\n                 pUnicodeString[lIndexUnicode++] = (WCHAR)(val);\n\
    \                 lIndex += 3;\n             }\n             else if (0x00 ==\
    \ (byteMain & 0x0F))\n             {\n                 // 4 byte\n-          \
    \      int val = (int)(((byteMain & 0x07) << 18) |\n-                    ((pBuffer[lIndex\
    \ + 1] & 0x3F) << 12) |\n-                    ((pBuffer[lIndex + 2] & 0x3F) <<\
    \ 6) |\n-                    (pBuffer[lIndex + 3] & 0x3F));\n+               \
    \ int val = 0;\n+                if ((lIndex + 3) < lCount)\n+               \
    \ {\n+                    val = (int)(((byteMain & 0x07) << 18) |\n+         \
    \                       ((pBuffer[lIndex + 1] & 0x3F) << 12) |\n+            \
    \                    ((pBuffer[lIndex + 2] & 0x3F) << 6) |\n+                \
    \                (pBuffer[lIndex + 3] & 0x3F));\n+                }\n+\n     \
    \            pUnicodeString[lIndexUnicode++] = (WCHAR)(val);\n               \
    \  lIndex += 4;\n             }\n             else if (0x00 == (byteMain & 0x08))\n\
    \             {\n                 // 4 byte\n-                int val = (int)(((byteMain\
    \ & 0x07) << 18) |\n-                    ((pBuffer[lIndex + 1] & 0x3F) << 12)\
    \ |\n-                    ((pBuffer[lIndex + 2] & 0x3F) << 6) |\n-           \
    \         (pBuffer[lIndex + 3] & 0x3F));\n+                int val = 0;\n+   \
    \             if ((lIndex + 3) < lCount)\n+                {\n+              \
    \      val = (int)(((byteMain & 0x07) << 18) |\n+                            \
    \    ((pBuffer[lIndex + 1] & 0x3F) << 12) |\n+                               \
    \ ((pBuffer[lIndex + 2] & 0x3F) << 6) |\n+                                (pBuffer[lIndex\
    \ + 3] & 0x3F));\n+                }\n+\n                 pUnicodeString[lIndexUnicode++]\
    \ = (WCHAR)(val);\n                 lIndex += 4;\n             }\n           \
    \  else if (0x00 == (byteMain & 0x04))\n             {\n                 // 5\
    \ byte\n-                int val = (int)(((byteMain & 0x03) << 24) |\n-      \
    \              ((pBuffer[lIndex + 1] & 0x3F) << 18) |\n-                    ((pBuffer[lIndex\
    \ + 2] & 0x3F) << 12) |\n-                    ((pBuffer[lIndex + 3] & 0x3F) <<\
    \ 6) |\n-                    (pBuffer[lIndex + 4] & 0x3F));\n+               \
    \ int val = 0;\n+                if ((lIndex + 4) < lCount)\n+               \
    \ {\n+                    val = (int)(((byteMain & 0x03) << 24) |\n+         \
    \                       ((pBuffer[lIndex + 1] & 0x3F) << 18) |\n+            \
    \                    ((pBuffer[lIndex + 2] & 0x3F) << 12) |\n+               \
    \                 ((pBuffer[lIndex + 3] & 0x3F) << 6) |\n+                   \
    \             (pBuffer[lIndex + 4] & 0x3F));\n+                }\n+\n        \
    \         pUnicodeString[lIndexUnicode++] = (WCHAR)(val);\n                 lIndex\
    \ += 5;\n             }\n             else\n             {\n                 //\
    \ 6 byte\n-                int val = (int)(((byteMain & 0x01) << 30) |\n-    \
    \                ((pBuffer[lIndex + 1] & 0x3F) << 24) |\n-                   \
    \ ((pBuffer[lIndex + 2] & 0x3F) << 18) |\n-                    ((pBuffer[lIndex\
    \ + 3] & 0x3F) << 12) |\n-                    ((pBuffer[lIndex + 4] & 0x3F) <<\
    \ 6) |\n-                    (pBuffer[lIndex + 5] & 0x3F));\n+               \
    \ int val = 0;\n+                if ((lIndex + 5) < lCount)\n+               \
    \ {\n+                    val = (int)(((byteMain & 0x01) << 30) |\n+         \
    \                       ((pBuffer[lIndex + 1] & 0x3F) << 24) |\n+            \
    \                    ((pBuffer[lIndex + 2] & 0x3F) << 18) |\n+               \
    \                 ((pBuffer[lIndex + 3] & 0x3F) << 12) |\n+                  \
    \              ((pBuffer[lIndex + 4] & 0x3F) << 6) |\n+                      \
    \          (pBuffer[lIndex + 5] & 0x3F));\n+                }\n+\n           \
    \      pUnicodeString[lIndexUnicode++] = (WCHAR)(val);\n                 lIndex\
    \ += 5;\n             }\n@@ -242,64 +272,89 @@ namespace NSFile\n            \
    \ else if (0x00 == (byteMain & 0x20))\n             {\n                 // 2 byte\n\
    -                int val = (int)(((byteMain & 0x1F) << 6) |\n-               \
    \     (pBuffer[lIndex + 1] & 0x3F));\n+                int val = 0;\n+       \
    \         if ((lIndex + 1) < lCount)\n+                {\n+                  \
    \  val = (int)(((byteMain & 0x1F) << 6) |\n+                                (pBuffer[lIndex\
    \ + 1] & 0x3F));\n+                }\n+\n                 *pUnicodeString++ =\
    \ (WCHAR)(val);\n                 lIndex += 2;\n             }\n             else\
    \ if (0x00 == (byteMain & 0x10))\n             {\n                 // 3 byte\n\
    -                int val = (int)(((byteMain & 0x0F) << 12) |\n-              \
    \      ((pBuffer[lIndex + 1] & 0x3F) << 6) |\n-                    (pBuffer[lIndex\
    \ + 2] & 0x3F));\n+                int val = 0;\n+                if ((lIndex\
    \ + 2) < lCount)\n+                {\n+                    val = (int)(((byteMain\
    \ & 0x0F) << 12) |\n+                                ((pBuffer[lIndex + 1] & 0x3F)\
    \ << 6) |\n+                                (pBuffer[lIndex + 2] & 0x3F));\n+\
    \                }\n \n                 WriteUtf16_WCHAR(val, pUnicodeString);\n\
    \                 lIndex += 3;\n             }\n             else if (0x00 ==\
    \ (byteMain & 0x0F))\n             {\n                 // 4 byte\n-          \
    \      int val = (int)(((byteMain & 0x07) << 18) |\n-                    ((pBuffer[lIndex\
    \ + 1] & 0x3F) << 12) |\n-                    ((pBuffer[lIndex + 2] & 0x3F) <<\
    \ 6) |\n-                    (pBuffer[lIndex + 3] & 0x3F));\n+               \
    \ int val = 0;\n+                if ((lIndex + 3) < lCount)\n+               \
    \ {\n+                    val = (int)(((byteMain & 0x07) << 18) |\n+         \
    \                       ((pBuffer[lIndex + 1] & 0x3F) << 12) |\n+            \
    \                    ((pBuffer[lIndex + 2] & 0x3F) << 6) |\n+                \
    \                (pBuffer[lIndex + 3] & 0x3F));\n+                }\n \n     \
    \            WriteUtf16_WCHAR(val, pUnicodeString);\n                 lIndex +=\
    \ 4;\n             }\n             else if (0x00 == (byteMain & 0x08))\n     \
    \        {\n                 // 4 byte\n-                int val = (int)(((byteMain\
    \ & 0x07) << 18) |\n-                    ((pBuffer[lIndex + 1] & 0x3F) << 12)\
    \ |\n-                    ((pBuffer[lIndex + 2] & 0x3F) << 6) |\n-           \
    \         (pBuffer[lIndex + 3] & 0x3F));\n+                int val = 0;\n+   \
    \             if ((lIndex + 3) < lCount)\n+                {\n+              \
    \      val = (int)(((byteMain & 0x07) << 18) |\n+                            \
    \    ((pBuffer[lIndex + 1] & 0x3F) << 12) |\n+                               \
    \ ((pBuffer[lIndex + 2] & 0x3F) << 6) |\n+                                (pBuffer[lIndex\
    \ + 3] & 0x3F));\n+                }\n \n                 WriteUtf16_WCHAR(val,\
    \ pUnicodeString);\n                 lIndex += 4;\n             }\n          \
    \   else if (0x00 == (byteMain & 0x04))\n             {\n                 // 5\
    \ byte\n-                int val = (int)(((byteMain & 0x03) << 24) |\n-      \
    \              ((pBuffer[lIndex + 1] & 0x3F) << 18) |\n-                    ((pBuffer[lIndex\
    \ + 2] & 0x3F) << 12) |\n-                    ((pBuffer[lIndex + 3] & 0x3F) <<\
    \ 6) |\n-                    (pBuffer[lIndex + 4] & 0x3F));\n+               \
    \ int val = 0;\n+                if ((lIndex + 4) < lCount)\n+               \
    \ {\n+                    val = (int)(((byteMain & 0x03) << 24) |\n+         \
    \                       ((pBuffer[lIndex + 1] & 0x3F) << 18) |\n+            \
    \                    ((pBuffer[lIndex + 2] & 0x3F) << 12) |\n+               \
    \                 ((pBuffer[lIndex + 3] & 0x3F) << 6) |\n+                   \
    \             (pBuffer[lIndex + 4] & 0x3F));\n+                }\n \n        \
    \         WriteUtf16_WCHAR(val, pUnicodeString);\n                 lIndex += 5;\n\
    \             }\n             else\n             {\n                 // 6 byte\n\
    -                int val = (int)(((byteMain & 0x01) << 30) |\n-              \
    \      ((pBuffer[lIndex + 1] & 0x3F) << 24) |\n-                    ((pBuffer[lIndex\
    \ + 2] & 0x3F) << 18) |\n-                    ((pBuffer[lIndex + 3] & 0x3F) <<\
    \ 12) |\n-                    ((pBuffer[lIndex + 4] & 0x3F) << 6) |\n-       \
    \             (pBuffer[lIndex + 5] & 0x3F));\n+                int val = 0;\n\
    +                if ((lIndex + 5) < lCount)\n+                {\n+           \
    \         val = (int)(((byteMain & 0x01) << 30) |\n+                         \
    \       ((pBuffer[lIndex + 1] & 0x3F) << 24) |\n+                            \
    \    ((pBuffer[lIndex + 2] & 0x3F) << 18) |\n+                               \
    \ ((pBuffer[lIndex + 3] & 0x3F) << 12) |\n+                                ((pBuffer[lIndex\
    \ + 4] & 0x3F) << 6) |\n+                                (pBuffer[lIndex + 5]\
    \ & 0x3F));\n+                }\n \n                 WriteUtf16_WCHAR(val, pUnicodeString);\n\
    \                 lIndex += 5;"
  - "--- a/DesktopEditor/cximage/CxImage/ximabmp.cpp\n+++ b/DesktopEditor/cximage/CxImage/ximabmp.cpp\n\
    @@ -133,15 +133,15 @@ bool CxImageBMP::Decode(CxFile * hFile)\n         if (bIsOldBmp){\r\
    \n              // convert a old color table (3 byte entries) to a new\r\n   \
    \           // color table (4 byte entries)\r\n-            hFile->Read((void*)pRgb,DibNumColors(&bmpHeader)\
    \ * sizeof(RGBTRIPLE),1);\r\n+            hFile->Read((void*)pRgb,DibNumColors(&bmpHeader)\
    \ * sizeof(RGBTRIPLE),1,GetDIB(),GetDIBLimit());\r\n             for (int32_t\
    \ i=DibNumColors(&head)-1; i>=0; i--){\r\n                 pRgb[i].rgbRed    \
    \  = ((RGBTRIPLE *)pRgb)[i].rgbtRed;\r\n                 pRgb[i].rgbBlue     =\
    \ ((RGBTRIPLE *)pRgb)[i].rgbtBlue;\r\n                 pRgb[i].rgbGreen    = ((RGBTRIPLE\
    \ *)pRgb)[i].rgbtGreen;\r\n                 pRgb[i].rgbReserved = (uint8_t)0;\r\
    \n             }\r\n         } else {\r\n-            hFile->Read((void*)pRgb,DibNumColors(&bmpHeader)\
    \ * sizeof(RGBQUAD),1);\r\n+            hFile->Read((void*)pRgb,DibNumColors(&bmpHeader)\
    \ * sizeof(RGBQUAD),1,GetDIB(),GetDIBLimit());\r\n \t\t\t//force rgbReserved=0,\
    \ to avoid problems with some WinXp bitmaps\r\n \t\t\tfor (uint32_t i=0; i<head.biClrUsed;\
    \ i++) pRgb[i].rgbReserved=0;\r\n         }\r\n@@ -165,7 +165,7 @@ bool CxImageBMP::Decode(CxFile\
    \ * hFile)\n \t\t\t\tint32_t imagesize=4*head.biHeight*head.biWidth;\r\n \t\t\t\
    \tuint8_t* buff32=(uint8_t*)malloc(imagesize);\r\n \t\t\t\tif (buff32){\r\n-\t\
    \t\t\t\thFile->Read(buff32, imagesize,1); // read in the pixels\r\n+         \
    \           hFile->Read(buff32, imagesize,1,GetDIB(),GetDIBLimit()); // read in\
    \ the pixels\r\n \r\n #if CXIMAGE_SUPPORT_ALPHA\r\n \t\t\t\t\tif (dwCompression\
    \ == BI_RGB){\r\n@@ -195,7 +195,7 @@ bool CxImageBMP::Decode(CxFile * hFile)\n\
    \ \t\tcase 24 :\r\n \t\t\tif (bf.bfOffBits != 0L) hFile->Seek(off + bf.bfOffBits,SEEK_SET);\r\
    \n \t\t\tif (dwCompression == BI_RGB){\r\n-\t\t\t\thFile->Read(info.pImage, head.biSizeImage,1);\
    \ // read in the pixels\r\n+                hFile->Read(info.pImage, head.biSizeImage,1,GetDIB(),GetDIBLimit());\
    \ // read in the pixels\r\n \t\t\t} else cx_throw(\"unknown compression\");\r\n\
    \ \t\t\tbreak;\r\n \t\tcase 16 :\r\n@@ -210,7 +210,7 @@ bool CxImageBMP::Decode(CxFile\
    \ * hFile)\n \t\t\t// bf.bfOffBits required after the bitfield mask <Cui Ying\
    \ Jie>\r\n \t\t\tif (bf.bfOffBits != 0L) hFile->Seek(off + bf.bfOffBits,SEEK_SET);\r\
    \n \t\t\t// read in the pixels\r\n-\t\t\thFile->Read(info.pImage, head.biHeight*((head.biWidth+1)/2)*4,1);\r\
    \n+            hFile->Read(info.pImage, head.biHeight*((head.biWidth+1)/2)*4,1,GetDIB(),GetDIBLimit());\r\
    \n \t\t\t// transform into RGB\r\n \t\t\tBitfield2RGB(info.pImage,bfmask[0],bfmask[1],bfmask[2],16);\r\
    \n \t\t\tbreak;\r\n@@ -229,7 +229,7 @@ bool CxImageBMP::Decode(CxFile * hFile)\n\
    \ \t\t\t}\r\n \t\tswitch (dwCompression) {\r\n \t\t\tcase BI_RGB :\r\n-\t\t\t\t\
    hFile->Read(info.pImage, head.biSizeImage,1); // read in the pixels\r\n+     \
    \           hFile->Read(info.pImage, head.biSizeImage,1,GetDIB(),GetDIBLimit());\
    \ // read in the pixels\r\n \t\t\t\tbreak;\r\n \t\t\tcase BI_RLE4 :\r\n \t\t\t\
    {\r\n@@ -355,7 +355,7 @@ bool CxImageBMP::Decode(CxFile * hFile)\n \t\t\t\t\t\t\
    \t\t\tbreak;\r\n \t\t\t\t\t\t\t\t}\r\n \t\t\t\t\t\t\t\tdefault :\r\n-\t\t\t\t\t\
    \t\t\t\thFile->Read((void *)(iter.GetRow(scanline) + bits), sizeof(uint8_t) *\
    \ status_byte, 1);\r\n+                                    hFile->Read((void *)(iter.GetRow(scanline)\
    \ + bits), sizeof(uint8_t) * status_byte, 1,GetDIB(),GetDIBLimit());\r\n \t\t\t\
    \t\t\t\t\t\t// align run length to even number of bytes \r\n \t\t\t\t\t\t\t\t\t\
    if ((status_byte & 1) == 1)\r\n \t\t\t\t\t\t\t\t\t\thFile->Read(&second_byte,\
    \ sizeof(uint8_t), 1);\t\t\t\t\t\t\t\t\t\t\t\t\r"
  - "--- a/DesktopEditor/cximage/CxImage/ximage.cpp\n+++ b/DesktopEditor/cximage/CxImage/ximage.cpp\n\
    @@ -21,7 +21,7 @@\n void CxImage::Startup(uint32_t imagetype)\r\n {\r\n \t//init\
    \ pointers\r\n-\tpDib = pSelection = pAlpha = NULL;\r\n+    pDib = pDibLimit =\
    \ pSelection = pAlpha = NULL;\r\n \tppLayers = ppFrames = NULL;\r\n \t//init structures\r\
    \n \tmemset(&head,0,sizeof(BITMAPINFOHEADER));\r\n@@ -232,6 +232,7 @@ void* CxImage::Create(uint32_t\
    \ dwWidth, uint32_t dwHeight, uint32_t wBpp, uint32\n \t\tstrcpy(info.szLastError,\"\
    CxImage::Create can't allocate memory\");\r\n \t\treturn NULL;\r\n \t}\r\n+  \
    \  pDibLimit = (void*)((uint8_t*)pDib + GetSize());\r\n \r\n \t//clear the palette\r\
    \n \tRGBQUAD* pal=GetPalette();\r\n@@ -278,9 +279,12 @@ uint8_t* CxImage::GetBits(uint32_t\
    \ row)\n /**\r\n  * \\return the size in bytes of the internal pDib object\r\n\
    \  */\r\n-int32_t CxImage::GetSize()\r\n+uint32_t CxImage::GetSize()\r\n {\r\n\
    -\treturn head.biSize + head.biSizeImage + GetPaletteSize();\r\n+    uint64_t\
    \ size64 = head.biSize + head.biSizeImage + GetPaletteSize();\r\n+    if (size64\
    \ > 0xFFFFFFFF)\r\n+        return 0xFFFFFFFF;\r\n+    return (uint32_t)size64;\r\
    \n }\r\n ////////////////////////////////////////////////////////////////////////////////\r\
    \n /**\r\n@@ -324,13 +328,14 @@ bool CxImage::Transfer(CxImage &from, bool bTransferFrames\
    \ /*=true*/)\n \tmemcpy(&info,&from.info,sizeof(CXIMAGEINFO));\r\n \r\n \tpDib\
    \ = from.pDib;\r\n+    pDib = from.pDibLimit;\r\n \tpSelection = from.pSelection;\r\
    \n \tpAlpha = from.pAlpha;\r\n \tppLayers = from.ppLayers;\r\n \r\n \tmemset(&from.head,0,sizeof(BITMAPINFOHEADER));\r\
    \n \tmemset(&from.info,0,sizeof(CXIMAGEINFO));\r\n-\tfrom.pDib = from.pSelection\
    \ = from.pAlpha = NULL;\r\n+    from.pDib = from.pDibLimit = from.pSelection =\
    \ from.pAlpha = NULL;\r\n \tfrom.ppLayers = NULL;\r\n \r\n \tif (bTransferFrames){\r\
    \n@@ -352,6 +357,7 @@ void CxImage::Ghost(const CxImage *from)\n \t\tmemcpy(&head,&from->head,sizeof(BITMAPINFOHEADER));\r\
    \n \t\tmemcpy(&info,&from->info,sizeof(CXIMAGEINFO));\r\n \t\tpDib = from->pDib;\r\
    \n+        pDibLimit = from->pDibLimit;\r\n \t\tpSelection = from->pSelection;\r\
    \n \t\tpAlpha = from->pAlpha;\r\n \t\tppLayers = from->ppLayers;\r"
  - "--- a/DesktopEditor/cximage/CxImage/ximaico.cpp\n+++ b/DesktopEditor/cximage/CxImage/ximaico.cpp\n\
    @@ -95,9 +95,15 @@ bool CxImageICO::Decode(CxFile *hFile)\n \t\t\t\t// read the\
    \ palette\r\n \t\t\t\tRGBQUAD pal[256];\r\n \t\t\t\tif (bih.biClrUsed)\r\n-\t\t\
    \t\t\thFile->Read(pal,bih.biClrUsed*sizeof(RGBQUAD), 1);\r\n+                {\r\
    \n+                    DWORD _count = bih.biClrUsed; if (_count > 256) _count\
    \ = 256;\r\n+                    hFile->Read(pal,_count*sizeof(RGBQUAD), 1);\r\
    \n+                }\r\n \t\t\t\telse\r\n-\t\t\t\t\thFile->Read(pal,head.biClrUsed*sizeof(RGBQUAD),\
    \ 1);\r\n+                {\r\n+                    DWORD _count = head.biClrUsed;\
    \ if (_count > 256) _count = 256;\r\n+                    hFile->Read(pal,_count*sizeof(RGBQUAD),\
    \ 1);\r\n+                }\r\n \r\n \t\t\t\tSetPalette(pal,head.biClrUsed);\t\
    //palette assign\r\n \r"
  - "--- a/DesktopEditor/cximage/CxImage/ximainfo.cpp\n+++ b/DesktopEditor/cximage/CxImage/ximainfo.cpp\n\
    @@ -181,6 +181,10 @@ void* CxImage::GetDIB() const\n {\r\n \treturn pDib;\r\n\
    \ }\r\n+void* CxImage::GetDIBLimit() const\r\n+{\r\n+    return pDibLimit;\r\n\
    +}\r\n ////////////////////////////////////////////////////////////////////////////////\r\
    \n uint32_t CxImage::GetHeight() const\r\n {\r"
  - "--- a/DesktopEditor/cximage/CxImage/ximapcx.cpp\n+++ b/DesktopEditor/cximage/CxImage/ximapcx.cpp\n\
    @@ -50,6 +50,9 @@ bool CxImagePCX::Decode(CxFile *hFile)\n \tinfo.xDPI = pcxHeader.Hres;\r\
    \n \tinfo.yDPI = pcxHeader.Vres;\r\n \r\n+    if (Width <= 0 || Height <= 0)\r\
    \n+        cx_throw(\"Error: Not a PCX file\");\r\n+\r\n \tif (info.nEscape ==\
    \ -1){\r\n \t\thead.biWidth = Width;\r\n \t\thead.biHeight= Height;\r\n@@ -76,7\
    \ +79,11 @@ bool CxImagePCX::Decode(CxFile *hFile)\n \r\n \t//Read the image and\
    \ check if it's ok\r\n     nbytes = pcxHeader.BytesPerLine * pcxHeader.ColorPlanes\
    \ * Height;\r\n+    uint32_t pcximage_size = nbytes;\r\n     lpHead1 = pcximage\
    \ = (uint8_t*)malloc(nbytes);\r\n+    if (!pcximage)\r\n+        cx_throw(\"Cancelled\"\
    );\r\n+\r\n     while (nbytes > 0){\r\n \t\tif (hFile == NULL || hFile->Eof())\
    \ cx_throw(\"corrupted PCX\");\r\n \r\n@@ -119,6 +126,9 @@ bool CxImagePCX::Decode(CxFile\
    \ *hFile)\n \tfor (uint32_t idx=0; idx<head.biClrUsed; idx++) SetPaletteColor((uint8_t)idx,ColorMap[idx][0],ColorMap[idx][1],ColorMap[idx][2]);\r\
    \n \r\n     lpHead2 = pcxpixels = (uint8_t *)malloc(Width + pcxHeader.BytesPerLine\
    \ * 8);\r\n+    if (!pcxpixels)\r\n+        cx_throw(\"Cancelled\");\r\n+\r\n\
    \     // Convert the image\r\n     for (y = 0; y < Height; y++){\r\n \r\n@@ -138,7\
    \ +148,11 @@ bool CxImagePCX::Decode(CxFile *hFile)\n \t\t} else if (pcxHeader.ColorPlanes\
    \ == 4 && pcxHeader.BitsPerPixel == 8){\r\n \t\t\tfor (x = 0; x < Width; x++){\r\
    \n \t\t\t\tSetPixelColor(x,y2,RGB(pcxplanes[x],pcxplanes[pcxHeader.BytesPerLine\
    \ + x],pcxplanes[2*pcxHeader.BytesPerLine + x]));\r\n-\t\t\t\tAlphaSet(x,y2,pcxplanes[3*pcxHeader.BytesPerLine\
    \ + x]);\r\n+\r\n+                uint32_t alphaIndex = 3*pcxHeader.BytesPerLine\
    \ + x;\r\n+\r\n+                if (alphaIndex < pcximage_size)\r\n+         \
    \           AlphaSet(x,y2,pcxplanes[alphaIndex]);\r\n \t\t\t}\r\n \t\t\tcontinue;\r\
    \n #endif //CXIMAGE_SUPPORT_ALPHA\r"
  - "--- a/DesktopEditor/cximage/CxImage/ximatif.cpp\n+++ b/DesktopEditor/cximage/CxImage/ximatif.cpp\n\
    @@ -301,14 +301,16 @@ bool CxImageTIF::Decode(CxFile * hFile)\n \t\t\ttilebuf\
    \ = (uint8_t*)malloc(TIFFTileSize(m_tif));\r\n \t\t}\r\n \t\t\r\n-\t\tbits = (uint8_t*)malloc(bitspersample==16?\
    \ bitsize*2 : bitsize); // * VK\r\n+        int32_t bitsize_correct = bitspersample==16?\
    \ bitsize*2 : bitsize;\r\n+        bits = (uint8_t*)malloc(bitsize_correct); //\
    \ * VK\r\n \t\tuint8_t * bits16 = NULL;\t\t\t\t\t\t\t\t\t\t  // + VK\r\n \t\t\
    int32_t line16    = 0;\t\t\t\t\t\t\t\t\t\t\t  // + VK\r\n \r\n \t\tif (!tiled_image\
    \ && bitspersample==16) {\t\t\t\t\t  // + VK +\r\n \t\t\tline16 = line;\r\n \t\
    \t\tline   = CalculateLine(width, 8 * samplesperpixel);\r\n \t\t\tbits16 = bits;\r\
    \n+            bitsize_correct = bitsize;\r\n \t\t\tbits   = (uint8_t*)malloc(bitsize);\r\
    \n \t\t}\r\n \r\n@@ -454,9 +456,18 @@ bool CxImageTIF::Decode(CxFile * hFile)\n\
    \ \t\t\t\t\tdouble p,cx,cy,cz,cr,cg,cb;\r\n \t\t\t\t\twhile (ii</*line*/width){\t\
    \t// * VK\r\n \t\t\t\t\t\tbitsoffset = ii*samplesperpixel+offset;\r\n-\t\t\t\t\
    \t\tl=bits[bitsoffset];\r\n-\t\t\t\t\t\ta=bits[bitsoffset+1];\r\n-\t\t\t\t\t\t\
    b=bits[bitsoffset+2];\r\n+                        if (bitsoffset + 2 < bitsize_correct)\r\
    \n+                        {\r\n+                            l=bits[bitsoffset];\r\
    \n+                            a=bits[bitsoffset+1];\r\n+                    \
    \        b=bits[bitsoffset+2];\r\n+                        }\r\n+            \
    \            else\r\n+                        {\r\n+                         \
    \   l=0;\r\n+                            a=0;\r\n+                           \
    \ b=0;\r\n+                        }\r\n \t\t\t\t\t\tif (a>127) a-=256;\r\n \t\
    \t\t\t\t\tif (b>127) b-=256;\r\n \t\t\t\t\t\t// lab to xyz\r"
  - "--- a/DesktopEditor/cximage/CxImage/xmemfile.cpp\n+++ b/DesktopEditor/cximage/CxImage/xmemfile.cpp\n\
    @@ -45,15 +45,15 @@ uint8_t* CxMemFile::GetBuffer(bool bDetachBuffer)\n \treturn\
    \ m_pBuffer;\r\n }\r\n //////////////////////////////////////////////////////////\r\
    \n-size_t CxMemFile::Read(void *buffer, size_t size, size_t count)\r\n+size_t\
    \ CxMemFile::Read(void *buffer, size_t size, size_t count, void* limit_start,\
    \ void* limit_end)\r\n {\r\n \tif (buffer==NULL) return 0;\r\n \r\n \tif (m_pBuffer==NULL)\
    \ return 0;\r\n \tif (m_Position >= (int32_t)m_Size){\r\n \t\tm_bEOF = true;\r\
    \n \t\treturn 0;\r\n-\t}\r\n+    }\r\n \r\n \tint32_t nCount = (int32_t)(count*size);\r\
    \n \tif (nCount == 0) return 0;\r"
  - "--- a/DesktopEditor/cximage/jasper/jpc/jpc_dec.c\n+++ b/DesktopEditor/cximage/jasper/jpc/jpc_dec.c\n\
    @@ -2171,7 +2171,12 @@ int jpc_ppxstab_insert(jpc_ppxstab_t *tab, jpc_ppxstabent_t\
    \ *ent)\n \tint inspt;\n \tint i;\n \n-\tfor (i = 0; i < tab->numents; ++i) {\n\
    +    // check on MAX_INT\n+    int correct_num_ents = tab->numents;\n+    if (correct_num_ents\
    \ > 0x7FFFFFFE)\n+        correct_num_ents = 0x7FFFFFFE;\n+\n+    for (i = 0;\
    \ i < correct_num_ents; ++i) {\n \t\tif (tab->ents[i]->ind > ent->ind) {\n \t\t\
    \tbreak;\n \t\t}"
  - "--- a/DesktopEditor/cximage/raw/libdcr.c\n+++ b/DesktopEditor/cximage/raw/libdcr.c\n\
    @@ -3518,20 +3518,21 @@ void DCR_CLASS dcr_cam_xyz_coeff (DCRAW* p, double cam_xyz[4][3])\n\
    \ {\r\n \tdouble cam_rgb[4][3], inverse[4][3], num;\r\n \tint i, j, k;\r\n-\r\n\
    -\tfor (i=0; i < p->colors; i++)\t\t/* Multiply out XYZ colorspace */\r\n+   \
    \ int max_colors = p->colors;\r\n+    if (max_colors > 4) max_colors = 4;\r\n\
    +    for (i=0; i < max_colors; i++)\t\t/* Multiply out XYZ colorspace */\r\n \t\
    \tfor (j=0; j < 3; j++)\r\n \t\t\tfor (cam_rgb[i][j] = k=0; k < 3; k++)\r\n \t\
    \t\t\tcam_rgb[i][j] += cam_xyz[i][k] * xyz_rgb[k][j];\r\n \r\n-\tfor (i=0; i <\
    \ p->colors; i++) {\t\t/* Normalize cam_rgb so that */\r\n+    for (i=0; i < max_colors;\
    \ i++) {\t\t/* Normalize cam_rgb so that */\r\n \t\tfor (num=j=0; j < 3; j++)\t\
    \t/* cam_rgb * (1,1,1) is (1,1,1,1) */\r\n \t\t\tnum += cam_rgb[i][j];\r\n \t\t\
    for (j=0; j < 3; j++)\r\n \t\t\tcam_rgb[i][j] /= num;\r\n \t\tp->pre_mul[i] =\
    \ 1 / (float)num;\r\n \t}\r\n-\tdcr_pseudoinverse (cam_rgb, inverse, p->colors);\r\
    \n+    dcr_pseudoinverse (cam_rgb, inverse, max_colors);\r\n \tfor (p->raw_color\
    \ = i=0; i < 3; i++)\r\n \t\tfor (j=0; j < p->colors; j++)\r\n \t\t\tp->rgb_cam[i][j]\
    \ = (float)inverse[j][i];\r\n@@ -5391,16 +5392,20 @@ void DCR_CLASS dcr_parse_tiff\
    \ (DCRAW* p, int base)\n \t\tp->tiff_ifd[raw].phint == 1) p->is_raw = 0;\r\n \t\
    if (p->tiff_bps == 8 && p->tiff_samples == 4) p->is_raw = 0;\r\n \tfor (i=0; i\
    \ < (int)p->tiff_nifds; i++)\r\n+    {\r\n+        int sqr_1 = SQR(p->tiff_ifd[i].bps+1);\
    \ if (sqr_1 == 0) sqr_1 = 1;\r\n+        int sqr_2 = SQR(p->thumb_misc+1); if\
    \ (sqr_2 == 0) sqr_2 = 1;\r\n \t\tif (i != raw && p->tiff_ifd[i].samples == max_samp\
    \ &&\r\n-\t\t\tp->tiff_ifd[i].width * p->tiff_ifd[i].height / SQR(p->tiff_ifd[i].bps+1)\
    \ >\r\n-\t\t\t(int)(p->thumb_width *       p->thumb_height / SQR(p->thumb_misc+1)))\
    \ {\r\n+            p->tiff_ifd[i].width * p->tiff_ifd[i].height / sqr_1 >\r\n\
    +            (int)(p->thumb_width *       p->thumb_height / sqr_2)) {\r\n \t\t\
    \tp->thumb_width  = p->tiff_ifd[i].width;\r\n \t\t\tp->thumb_height = p->tiff_ifd[i].height;\r\
    \n \t\t\tp->thumb_offset = p->tiff_ifd[i].offset;\r\n \t\t\tp->thumb_length =\
    \ p->tiff_ifd[i].bytes;\r\n \t\t\tp->thumb_misc   = p->tiff_ifd[i].bps;\r\n \t\
    \t\tthm = i;\r\n \t\t}\r\n+    }\r\n \tif (thm >= 0) {\r\n \t\tp->thumb_misc |=\
    \ p->tiff_ifd[thm].samples << 5;\r\n \t\tswitch (p->tiff_ifd[thm].comp) {\r\n\
    @@ -5845,10 +5850,16 @@ void DCR_CLASS dcr_parse_riff(DCRAW* p)\n \t{ \"Jan\"\
    ,\"Feb\",\"Mar\",\"Apr\",\"May\",\"Jun\",\"Jul\",\"Aug\",\"Sep\",\"Oct\",\"Nov\"\
    ,\"Dec\" };\r\n \tstruct tm t;\r\n \r\n+    if (dcr_feof(p->obj_))\r\n+    {\r\
    \n+        fprintf (stderr,_(\"Unexpected end of file\\n\"));\r\n+        return;\r\
    \n+    }\r\n+\r\n \tp->order = 0x4949;\r\n \tdcr_fread(p->obj_, tag, 4, 1);\r\n\
    \ \tsize = dcr_get4(p);\r\n-\tend = dcr_ftell(p->obj_) + size;\r\n+    end = dcr_ftell(p->obj_)\
    \ + size;\r\n \tif (!memcmp(tag,\"RIFF\",4) || !memcmp(tag,\"LIST\",4)) {\r\n\
    \ \t\tdcr_get4(p);\r\n \t\twhile (dcr_ftell(p->obj_)+7 < (long)end)\r"
  - "--- a/DesktopEditor/cximage/tiff/tif_dirread.c\n+++ b/DesktopEditor/cximage/tiff/tif_dirread.c\n\
    @@ -205,7 +205,7 @@ TIFFReadDirectory(TIFF* tif)\n \t\t    && fix < tif->tif_nfields)\
    \ {\n \t\t\tif (fip->field_type == TIFF_ANY)\t/* wildcard */\n \t\t\t\tbreak;\n\
    -\t\t\tfip = tif->tif_fieldinfo[++fix];\n+            ++fix; fip = (fix >= tif->tif_nfields)\
    \ ? 0 : tif->tif_fieldinfo[++fix];\n \t\t\tif (fix >= tif->tif_nfields ||\n \t\
    \t\t    fip->field_tag != dp->tdir_tag) {\n \t\t\t\tTIFFWarningExt(tif->tif_clientdata,\
    \ module,\n@@ -333,7 +333,7 @@ TIFFReadDirectory(TIFF* tif)\n \t\t    && fix <\
    \ tif->tif_nfields) {\n \t\t\tif (fip->field_type == TIFF_ANY)\t/* wildcard */\n\
    \ \t\t\t\tbreak;\n-\t\t\tfip = tif->tif_fieldinfo[++fix];\n+            ++fix;\
    \ fip = (fix >= tif->tif_nfields) ? 0 : tif->tif_fieldinfo[++fix];\n \t\t\tif\
    \ (fix >= tif->tif_nfields ||\n \t\t\t    fip->field_tag != dp->tdir_tag) {\n\
    \ \t\t\t\tTIFFWarningExt(tif->tif_clientdata, module,\n@@ -887,7 +887,7 @@ TIFFReadCustomDirectory(TIFF*\
    \ tif, toff_t diroff,\n                        && fix < tif->tif_nfields) {\n\
    \ \t\t\tif (fip->field_type == TIFF_ANY)\t/* wildcard */\n \t\t\t\tbreak;\n- \
    \                       fip = tif->tif_fieldinfo[++fix];\n+            ++fix;\
    \ fip = (fix >= tif->tif_nfields) ? 0 : tif->tif_fieldinfo[++fix];\n \t\t\tif\
    \ (fix >= tif->tif_nfields ||\n \t\t\t    fip->field_tag != dp->tdir_tag) {\n\
    \ \t\t\t\tTIFFWarningExt(tif->tif_clientdata, module,"
  - "--- a/DesktopEditor/cximage/tiff/tif_ojpeg.c\n+++ b/DesktopEditor/cximage/tiff/tif_ojpeg.c\n\
    @@ -1920,7 +1920,9 @@ OJPEGReadBufferFill(OJPEGState* sp)\n \t\t\t\t\t\t\tsp->in_buffer_file_pos=0;\n\
    \ \t\t\t\t\t\telse\n \t\t\t\t\t\t{\n-\t\t\t\t\t\t\tsp->in_buffer_file_togo=sp->tif->tif_dir.td_stripbytecount[sp->in_buffer_next_strile];\
    \  \n+                            sp->in_buffer_file_togo=0;\n+              \
    \              if (sp->tif->tif_dir.td_stripbytecount)\n+                    \
    \            sp->in_buffer_file_togo=sp->tif->tif_dir.td_stripbytecount[sp->in_buffer_next_strile];\n\
    \ \t\t\t\t\t\t\tif (sp->in_buffer_file_togo==0)\n \t\t\t\t\t\t\t\tsp->in_buffer_file_pos=0;\n\
    \ \t\t\t\t\t\t\telse if (sp->in_buffer_file_pos+sp->in_buffer_file_togo>sp->file_size)"
  - "--- a/DesktopEditor/fontengine/fontconverter/FontFileType1.cpp\n+++ b/DesktopEditor/fontengine/fontconverter/FontFileType1.cpp\n\
    @@ -633,13 +633,16 @@ namespace NSFontConverter\n         // (\u043F\u0440\u043E\
    \u0431\u0435\u043B, \u0442\u0430\u0431, \u043F\u0435\u0440\u0435\u043D\u043E\u0441\
    \ \u043A\u0430\u0440\u0435\u0442\u043A\u0438 \u0438\u043B\u0438 \u043F\u0435\u0440\
    \u0435\u043D\u043E\u0441 \u0441\u0442\u0440\u043E\u043A\u0438).\n         unsigned\
    \ char *sCur = (unsigned char*)(*ppEexecBuffer);\n         while( sCur < (unsigned\
    \ char*)(*ppEexecBuffer) + nLen && ( ' ' == *sCur || '\\t' == *sCur || '\\r' ==\
    \ *sCur || '\\n' == *sCur ) )\n+        {\n             ++sCur;\n+           \
    \ --nLen;\n+        }\n \n         // \u0422\u0435\u043F\u0435\u0440\u044C \u043D\
    \u0430\u043C \u043D\u0430\u0434\u043E \u043E\u043F\u0440\u0435\u0434\u0435\u043B\
    \u0438\u0442\u044C \u0432 \u043A\u0430\u043A\u043E\u043C \u0444\u043E\u0440\u043C\
    \u0430\u0442\u0435 \u0443 \u043D\u0430\u0441 \u0434\u0430\u043D\u043D\u044B\u0435\
    : ASKII \u0438\u043B\u0438 \u0431\u0438\u043D\u0430\u0440\u043D\u044B\u0435 \u0434\
    \u0430\u043D\u043D\u044B\u0435.\n         // \u0415\u0441\u043B\u0438 \u043F\u0435\
    \u0440\u0432\u044B\u0435 \u0447\u0435\u0442\u044B\u0440\u0435 \u0431\u0430\u0439\
    \u0442\u0430 \u044F\u0432\u043B\u044F\u044E\u0442\u0441\u044F \u0448\u0435\u0441\
    \u0442\u043D\u0430\u0434\u0446\u0430\u0442\u0438\u0440\u0438\u0447\u043D\u044B\
    \u043C\u0438 \u0441\u0438\u043C\u0432\u043E\u043B\u0430\u043C\u0438, \u0437\u043D\
    \u0430\u0447\u0438\u0442, \u043A\u043E\u0434\u0438\u0440\u043E\u0432\u043A\u0430\
    \ ASCII.\n         bool bASCII = false;\n \n-        if ( isxdigit( sCur[0] )\
    \ && isxdigit( sCur[1] ) && isxdigit( sCur[2] ) && isxdigit( sCur[3] ) )\n+  \
    \      if ( nLen > 3 && isxdigit( sCur[0] ) && isxdigit( sCur[1] ) && isxdigit(\
    \ sCur[2] ) && isxdigit( sCur[3] ) )\n             bASCII = true;\n \n       \
    \  if ( bASCII )"
  identifiers:
  - CVE-2022-29776
  - CWE-787
  overview: Onlyoffice Document Server v6.0.0 and below and Core 6.1.0.26 and below
    were discovered to contain a stack overflow via the component DesktopEditor/common/File.cpp.
  references:
  - source: cve@mitre.org
    tags:
    - Release Notes
    - Third Party Advisory
    url: https://github.com/ONLYOFFICE/DocumentServer/blob/master/CHANGELOG.md#601
  - source: cve@mitre.org
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/ONLYOFFICE/core/commit/88cf60a3ed4a2b40d71a1c2ced72fa3902a30967
  - source: cve@mitre.org
    tags:
    - Exploit
    - Third Party Advisory
    url: https://github.com/moehw/poc_exploits/tree/master/CVE-2022-29776
  title: Onlyoffice Document Server v6.0.0 and below and Core 6.1.0.26 and below were
    discovered to contain a stack overflow via the component DesktopEditor/common/File.cpp.
- diff_content:
  - "--- a/DesktopEditor/fontengine/fontconverter/FontFileType1.cpp\n+++ b/DesktopEditor/fontengine/fontconverter/FontFileType1.cpp\n\
    @@ -397,6 +397,7 @@ namespace NSFontConverter\n                             char\
    \ nChar = *pTemp;\n                             *pTemp = '\\0';\n            \
    \                 nCode = atoi( pCur );\n+\t\t\t\t\t\t\tif (nCode < 0) nCode =\
    \ 0;\t\t\t\t\t\t\t\t\n                             *pTemp = nChar;\n         \
    \                    if ( nCode == 8 && *pTemp == '#')\n                     \
    \        {\n@@ -612,7 +613,7 @@ namespace NSFontConverter\n                  \
    \       sToken.clear();\n                         sGlyph.clear();\n \n-      \
    \                  while ( ( nChar = sEexec[++nIndex] ) != ' ' )\n+          \
    \              while ( nIndex < nEexecLen && ( nChar = sEexec[++nIndex] ) != '\
    \ ' )\n                             sGlyph.push_back( (wchar_t)nChar );\n    \
    \                 }\n                 }\n@@ -656,7 +657,7 @@ namespace NSFontConverter\n\
    \         int nChar = 0;\n \n         unsigned char *sBuffer = NULL;\n-      \
    \  int nBufLen = 0;\n+        unsigned int nBufLen = 0;\n \n         while ( nBlockType\
    \ != PFB_DONE )\n         {"
  identifiers:
  - CVE-2022-29777
  - CWE-787
  overview: Onlyoffice Document Server v6.0.0 and below and Core 6.1.0.26 and below
    were discovered to contain a heap overflow via the component DesktopEditor/fontengine/fontconverter/FontFileBase.h.
  references:
  - source: cve@mitre.org
    tags:
    - Release Notes
    - Third Party Advisory
    url: https://github.com/ONLYOFFICE/DocumentServer/blob/master/CHANGELOG.md#601
  - source: cve@mitre.org
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/ONLYOFFICE/core/commit/b17d5e860f30e8be2caeb0022b63be4c76660178
  - source: cve@mitre.org
    tags:
    - Exploit
    - Third Party Advisory
    url: https://github.com/moehw/poc_exploits/tree/master/CVE-2022-29777
  title: Onlyoffice Document Server v6.0.0 and below and Core 6.1.0.26 and below were
    discovered to contain a heap overflow via the component DesktopEditor/fontengine/fontconverter/FontFileBase.h.
- diff_content:
  - "--- a/src/njs_array.c\n+++ b/src/njs_array.c\n@@ -1284,6 +1284,11 @@ njs_array_prototype_splice(njs_vm_t\
    \ *vm, njs_value_t *args, njs_uint_t nargs,\n                 if (njs_slow_path(ret\
    \ == NJS_ERROR)) {\n                     return ret;\n                 }\n+\n\
    +            } else {\n+                if (deleted->object.fast_array) {\n+ \
    \                   njs_set_invalid(&deleted->start[i]);\n+                }\n\
    \             }\n         }\n "
  - "--- a/src/test/njs_unit_test.c\n+++ b/src/test/njs_unit_test.c\n@@ -4869,6 +4869,15\
    \ @@ static njs_unit_test_t  njs_test[] =\n               \"Array.prototype.splice.call(obj,\
    \ 2**53-2, 0, 'C');\"),\n       njs_str(\"TypeError: Invalid length\") },\n \n\
    +    { njs_str(\"var a = {1: 'B', length: 2};\"\n+              \"Array.prototype.splice.call(a,\
    \ 0)\"),\n+      njs_str(\",B\") },\n+\n+    { njs_str(\"var a = new Uint8Array();\"\
    \n+              \"a.__proto__ = [1,2,3];\"\n+              \"a.splice(0)\"),\n\
    +      njs_str(\",,\") },\n+\n     { njs_str(\"var a = []; a.reverse()\"),\n \
    \      njs_str(\"\") },\n "
  identifiers:
  - CVE-2022-29779
  - NVD-CWE-noinfo
  overview: Nginx NJS v0.7.2 was discovered to contain a segmentation violation in
    the function njs_value_own_enumerate at src/njs_value.c.
  references:
  - source: cve@mitre.org
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/nginx/njs/commit/2e00e95473861846aa8538be87db07699d9f676d
  - source: cve@mitre.org
    tags:
    - Exploit
    - Third Party Advisory
    url: https://github.com/nginx/njs/issues/485
  title: Nginx NJS v0.7.2 was discovered to contain a segmentation violation in the
    function njs_value_own_enumerate at src/njs_value.c.
- diff_content:
  - "--- a/src/njs_array.c\n+++ b/src/njs_array.c\n@@ -2696,7 +2696,7 @@ njs_array_prototype_sort(njs_vm_t\
    \ *vm, njs_value_t *args, njs_uint_t nargs,\n         goto exception;\n     }\n\
    \ \n-    if (njs_fast_path(fast_path)) {\n+    if (njs_fast_path(fast_path &&\
    \ njs_is_fast_array(this))) {\n         array = njs_array(this);\n         start\
    \ = array->start;\n "
  - "--- a/src/test/njs_unit_test.c\n+++ b/src/test/njs_unit_test.c\n@@ -6989,6 +6989,9\
    \ @@ static njs_unit_test_t  njs_test[] =\n     { njs_str(\"[1,2].sort(1)\"),\n\
    \       njs_str(\"TypeError: comparefn must be callable or undefined\") },\n \n\
    +    { njs_str(\"var a = [1,2]; a.sort(() => {a.length = 65535}); a.length\"),\n\
    +      njs_str(\"65535\") },\n+\n     /*\n       Array.prototype.keys()\n    \
    \   Array.prototype.values()"
  identifiers:
  - CVE-2022-29780
  - NVD-CWE-noinfo
  overview: Nginx NJS v0.7.2 was discovered to contain a segmentation violation in
    the function njs_array_prototype_sort at src/njs_array.c.
  references:
  - source: cve@mitre.org
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/nginx/njs/commit/8b39afdad9a0761e0a5d4af1a762bd9a6daef572
  - source: cve@mitre.org
    tags:
    - Exploit
    - Third Party Advisory
    url: https://github.com/nginx/njs/issues/486
  title: Nginx NJS v0.7.2 was discovered to contain a segmentation violation in the
    function njs_array_prototype_sort at src/njs_array.c.
- diff_content:
  - "--- a/src/index.c\n+++ b/src/index.c\n@@ -1057,7 +1057,7 @@ MOBI_RET mobi_trie_insert_infl(MOBITrie\
    \ **root, const MOBIIndx *indx, size_t i)\n     for (size_t j = 0; j < e.tags_count;\
    \ j++) {\n         MOBIIndexTag t = e.tags[j];\n         if (t.tagid == INDX_TAGARR_INFL_PARTS_V1)\
    \ {\n-            for (size_t k = 0; k < t.tagvalues_count - 1; k += 2) {\n+ \
    \           for (size_t k = 0; k + 1 < t.tagvalues_count; k += 2) {\n        \
    \         uint32_t len = t.tagvalues[k];\n                 uint32_t offset = t.tagvalues[k\
    \ + 1];\n                 char *base = mobi_get_cncx_string_flat(indx->cncx_record,\
    \ offset, len);"
  identifiers:
  - CVE-2022-29788
  - CWE-476
  overview: libmobi before v0.10 contains a NULL pointer dereference via the component
    mobi_buffer_getpointer. This vulnerability allows attackers to cause a Denial
    of Service (DoS) via a crafted mobi file.
  references:
  - source: cve@mitre.org
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/bfabiszewski/libmobi/commit/ce0ab6586069791b1e8e2a42f44318e581c39939
  title: libmobi before v0.10 contains a NULL pointer dereference via the component
    mobi_buffer_getpointer. This vulnerability allows attackers to cause a Denial
    of Service (DoS) via a crafted mobi file.
- diff_content:
  - "--- a/src/njs_typed_array.c\n+++ b/src/njs_typed_array.c\n@@ -702,8 +702,6 @@\
    \ njs_typed_array_set_value(njs_vm_t *vm, njs_typed_array_t *array,\n \n     njs_typed_array_prop_set(vm,\
    \ array, index, num);\n \n-    njs_set_number(setval, num);\n-\n     return NJS_OK;\n\
    \ }\n "
  - "--- a/src/test/njs_unit_test.c\n+++ b/src/test/njs_unit_test.c\n@@ -5409,6 +5409,9\
    \ @@ static njs_unit_test_t  njs_test[] =\n                  \"Array.prototype.fill.call(o,\
    \ 2).a\"),\n       njs_str(\"4\") },\n \n+    { njs_str(\"Array.prototype.fill.call(new\
    \ Int32Array(1))\"),\n+      njs_str(\"0\") },\n+\n     { njs_str(\"ArrayBuffer()\"\
    ),\n       njs_str(\"TypeError: Constructor ArrayBuffer requires 'new'\") },\n\
    \ "
  identifiers:
  - CVE-2022-30503
  - NVD-CWE-noinfo
  overview: Nginx NJS v0.7.2 was discovered to contain a segmentation violation in
    the function njs_set_number at src/njs_value.h.
  references:
  - source: cve@mitre.org
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/nginx/njs/commit/5c6130a2a0b4c41ab415f6b8992aa323636338b9
  - source: cve@mitre.org
    tags:
    - Third Party Advisory
    url: https://github.com/nginx/njs/issues/478
  title: Nginx NJS v0.7.2 was discovered to contain a segmentation violation in the
    function njs_set_number at src/njs_value.h.
- diff_content:
  - "--- a/liblouis/compileTranslationTable.c\n+++ b/liblouis/compileTranslationTable.c\n\
    @@ -3736,12 +3736,14 @@ compileRule(FileInfo *file, TranslationTableHeader **table,\n\
    \ \n \t\tcase CTO_SeqAfterExpression:\n \t\t\tif (!getRuleCharsText(file, &ruleChars))\
    \ return 0;\n-\t\t\tfor ((*table)->seqAfterExpressionLength = 0;\n-\t\t\t\t\t\
    (*table)->seqAfterExpressionLength < ruleChars.length;\n-\t\t\t\t\t(*table)->seqAfterExpressionLength++)\n\
    -\t\t\t\t(*table)->seqAfterExpression[(*table)->seqAfterExpressionLength] =\n\
    -\t\t\t\t\t\truleChars.chars[(*table)->seqAfterExpressionLength];\n-\t\t\t(*table)->seqAfterExpression[(*table)->seqAfterExpressionLength]\
    \ = 0;\n+\t\t\tif ((ruleChars.length + 1) > SEQPATTERNSIZE) {\n+\t\t\t\tcompileError(file,\
    \ \"More than %d characters\", SEQPATTERNSIZE);\n+\t\t\t\treturn 0;\n+\t\t\t}\n\
    +\t\t\tfor (int k = 0; k < ruleChars.length; k++)\n+\t\t\t\t(*table)->seqAfterExpression[k]\
    \ = ruleChars.chars[k];\n+\t\t\t(*table)->seqAfterExpression[ruleChars.length]\
    \ = 0;\n+\t\t\t(*table)->seqAfterExpressionLength = ruleChars.length;\n \t\t\t\
    return 1;\n \n \t\tcase CTO_CapsModeChars:"
  identifiers:
  - CVE-2022-31783
  - CWE-787
  overview: Liblouis 3.21.0 has an out-of-bounds write in compileRule in compileTranslationTable.c,
    as demonstrated by lou_trace.
  references:
  - source: cve@mitre.org
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/liblouis/liblouis/commit/ff747ec5e1ac54d54194846f6fe5bfc689192a85
  - source: cve@mitre.org
    tags:
    - Exploit
    - Third Party Advisory
    url: https://github.com/liblouis/liblouis/issues/1214
  - source: cve@mitre.org
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/CFD2KIHESDUCNWTEW3USFB5GKTWT624L/
  - source: cve@mitre.org
    tags:
    - Third Party Advisory
    url: https://security.gentoo.org/glsa/202301-06
  title: Liblouis 3.21.0 has an out-of-bounds write in compileRule in compileTranslationTable.c,
    as demonstrated by lou_trace.
- diff_content:
  - "--- a/control/hierarchicalbitmaprequester.cpp\n+++ b/control/hierarchicalbitmaprequester.cpp\n\
    @@ -45,7 +45,7 @@\n ** decoding. It also keeps the top-level color transformer\
    \ and the\n ** toplevel subsampling expander.\n **\n-** $Id: hierarchicalbitmaprequester.cpp,v\
    \ 1.42 2020/04/08 10:05:41 thor Exp $\n+** $Id: hierarchicalbitmaprequester.cpp,v\
    \ 1.43 2022/05/24 05:42:35 thor Exp $\n **\n */\n \n@@ -245,6 +245,16 @@ void\
    \ HierarchicalBitmapRequester::PrepareForDecoding(void)\n       UBYTE sx = comp->SubXOf();\n\
    \       UBYTE sy = comp->SubYOf();\n \n+      if (m_pLargestScale) {\n+      \
    \  class Frame *frame = m_pLargestScale->FrameOf();\n+        while(frame) {\n\
    +          if (frame->ComponentOf(i)->SubXOf() != sx || frame->ComponentOf(i)->SubYOf()\
    \ != sy)\n+            JPG_THROW(MALFORMED_STREAM,\"HierarchicalBitmapRequester::PrepareForDecoding\"\
    ,\n+                      \"component subsampling is inconsistent across hierarchical\
    \ levels\");\n+          frame = frame->NextOf();\n+        }\n+      }\n+\n \
    \      if (sx > 1 || sy > 1) {\n         m_ppUpsampler[i] = UpsamplerBase::CreateUpsampler(m_pEnviron,sx,sy,\n\
    \                                                           m_ulPixelWidth,m_ulPixelHeight,"
  identifiers:
  - CVE-2022-31796
  - CWE-125
  overview: libjpeg 1.63 has a heap-based buffer over-read in HierarchicalBitmapRequester::FetchRegion
    in hierarchicalbitmaprequester.cpp because the MCU size can be different between
    allocation and use.
  references:
  - source: cve@mitre.org
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/thorfdbg/libjpeg/commit/187035b9726710b4fe11d565c7808975c930895d
  - source: cve@mitre.org
    tags:
    - Third Party Advisory
    url: https://github.com/thorfdbg/libjpeg/issues/71
  title: libjpeg 1.63 has a heap-based buffer over-read in HierarchicalBitmapRequester::FetchRegion
    in hierarchicalbitmaprequester.cpp because the MCU size can be different between
    allocation and use.
- diff_content:
  - "--- a/src/lib/libdwarf/dwarf_global.c\n+++ b/src/lib/libdwarf/dwarf_global.c\n\
    @@ -83,6 +82,33 @@ _dwarf_fix_up_offset_irix(Dwarf_Debug dbg,\n }\n #endif /*\
    \ __sgi */\n \n+#if 0\n+/*  Debugging only. Requires start. can calulate one of\
    \ len, end */\n+static void\n+debug_print_range(const char *msg,\n+    int lineno,\n\
    +    void *start, signed long len,\n+    void *end)\n+{\n+\n+    char *st = (char\
    \ *)start;\n+    char *en = (char *)end;\n+    signed long le = len;\n+\n+   \
    \ if (len) {\n+        if (en) {\n+            le = (long)(en-st);\n+        }\
    \ else {\n+            en= start+len;\n+        }\n+    } else if (en) {\n+  \
    \      le = (long)(en-st);\n+    }\n+    printf(\"RANGEdebug %s  st=0x%lx le=%ld\
    \ en=0x%lx line %d\\n\",\n+        msg,(unsigned long)st,le,(unsigned long)en,lineno);\n\
    +}\n+#endif\n+\n static void\n dealloc_globals_chain(Dwarf_Debug dbg,\n     Dwarf_Chain\
    \ head_chain)\n@@ -287,9 +313,9 @@ _dwarf_internal_get_pubnames_like_data(Dwarf_Debug\
    \ dbg,\n     Dwarf_Off pubnames_section_offset = 0;\n     Dwarf_Small *section_end_ptr\
    \ = section_data_ptr +section_length;\n \n-    /*  Points to the context for the\
    \ current set of global names, and\n-        contains information to identify\
    \ the compilation-unit that the\n-        set refers to. */\n+    /*  Points to\
    \ the context for the current set of global names,\n+        and contains information\
    \ to identify the compilation-unit\n+        that the set refers to. */\n    \
    \ Dwarf_Global_Context pubnames_context = 0;\n     Dwarf_Bool           pubnames_context_on_list\
    \ = FALSE;\n \n@@ -301,6 +327,10 @@ _dwarf_internal_get_pubnames_like_data(Dwarf_Debug\
    \ dbg,\n \n     Dwarf_Unsigned global_count = 0;\n \n+    /*  The count is just\
    \ to improve the error message\n+        a few lines above. */\n+    Dwarf_Unsigned\
    \ context_count = 0;\n+\n     /*  Used to chain the Dwarf_Global_s structs for\n\
    \         creating contiguous list of pointers to the structs. */\n     Dwarf_Chain\
    \ head_chain = 0;\n@@ -384,6 +414,41 @@ _dwarf_internal_get_pubnames_like_data(Dwarf_Debug\
    \ dbg,\n             }\n             return mres;\n         }\n+        {\n+ \
    \           Dwarf_Small * localend =pubnames_like_ptr + length;\n+\n+        \
    \    if ((length > section_length) ||\n+                (localend > section_end_ptr)){\n\
    +                /*  The length field  is corrupted */\n+                dwarfstring\
    \ m;\n+\n+                dwarfstring_constructor(&m);\n+                dwarfstring_append_printf_u(&m,\n\
    +                    \"DW_DLE_PUBNAMES_LENGTH_BAD (or similar) \"\n+         \
    \           \"A DWARF length field in cu context %u \",\n+                   \
    \ context_count);\n+                dwarfstring_append_printf_s(&m,\"of section\
    \ %s \",\n+                    (char *)secname);\n+                dwarfstring_append_printf_u(&m,\"\
    of \"\n+                    \"%u bytes \",length);\n+                dwarfstring_append_printf_u(&m,\n\
    +                    \"runs off the end of \"\n+                    \"the %u bytes\
    \ of the real section\",\n+                    section_length);\n+           \
    \     _dwarf_error_string(dbg, error,length_err_num,\n+                    dwarfstring_string(&m));\n\
    +                dwarfstring_destructor(&m);\n+                dealloc_globals_chain(dbg,head_chain);\n\
    +                if (!pubnames_context_on_list) {\n+                    dwarf_dealloc(dbg,pubnames_context,\n\
    +                        context_DLA_code);\n+                }\n+           \
    \     return DW_DLV_ERROR;\n+            }\n+        }\n+        /*  The count\
    \ is just to improve the error message\n+            a few lines above. */\n+\
    \        ++context_count;\n         pubnames_context->pu_alloc_type = context_DLA_code;\n\
    \         pubnames_context->pu_length_size = local_length_size;\n         pubnames_context->pu_length\
    \ = length;\n@@ -393,8 +458,7 @@ _dwarf_internal_get_pubnames_like_data(Dwarf_Debug\
    \ dbg,\n         pubnames_ptr_past_end_cu = pubnames_like_ptr + length;\n    \
    \     pubnames_context->pu_pub_entries_end_ptr =\n             pubnames_ptr_past_end_cu;\n\
    -\n-        if ((pubnames_like_ptr + (DWARF_HALF_SIZE) ) >\n+        if ((pubnames_like_ptr\
    \ + (DWARF_HALF_SIZE) ) >=\n             /* A minimum size needed */\n       \
    \      section_end_ptr) {\n             pubnames_error_length(dbg,error,\n@@ -554,6\
    \ +618,7 @@ _dwarf_internal_get_pubnames_like_data(Dwarf_Debug dbg,\n        \
    \ while (die_offset_in_cu) {\n             int res = 0;\n             unsigned\
    \ char *glname = 0;\n+            Dwarf_Unsigned nstrlen = 0;\n \n           \
    \  /*  non-zero die_offset_in_cu already read, so\n                 pubnames_like_ptr\
    \ points to a string.  */\n@@ -570,8 +635,8 @@ _dwarf_internal_get_pubnames_like_data(Dwarf_Debug\
    \ dbg,\n                 return res;\n             }\n             glname = (unsigned\
    \ char *)pubnames_like_ptr;\n-            pubnames_like_ptr = pubnames_like_ptr\
    \ +\n-                strlen((char *) pubnames_like_ptr) + 1;\n+            nstrlen\
    \ = strlen((char *)pubnames_like_ptr);\n+            pubnames_like_ptr += nstrlen\
    \ + 1;\n             /*  Already read offset and verified string, glname\n   \
    \              now points to the string. */\n             res = _dwarf_make_global_add_to_chain(dbg,"
  identifiers:
  - CVE-2022-32200
  - CWE-125
  overview: libdwarf 0.4.0 has a heap-based buffer over-read in _dwarf_check_string_valid
    in dwarf_util.c.
  references:
  - source: cve@mitre.org
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/davea42/libdwarf-code/commit/8151575a6ace77d005ca5bb5d71c1bfdba3f7069
  - source: cve@mitre.org
    tags:
    - Exploit
    - Issue Tracking
    - Third Party Advisory
    url: https://github.com/davea42/libdwarf-code/issues/116
  - source: cve@mitre.org
    tags:
    - Product
    - Third Party Advisory
    url: https://www.prevanders.net/dwarfbug.html
  title: libdwarf 0.4.0 has a heap-based buffer over-read in _dwarf_check_string_valid
    in dwarf_util.c.
- diff_content:
  - "--- a/codestream/entropyparser.cpp\n+++ b/codestream/entropyparser.cpp\n@@ -43,7\
    \ +43,7 @@\n ** This class represents the interface for parsing the\n ** entropy\
    \ coded data in JPEG as part of a single scan.\n **\n-** $Id: entropyparser.cpp,v\
    \ 1.24 2021/09/08 10:30:06 thor Exp $\n+** $Id: entropyparser.cpp,v 1.25 2022/05/30\
    \ 14:05:58 thor Exp $\n **\n */\n \n@@ -62,7 +62,7 @@ EntropyParser::EntropyParser(class\
    \ Frame *frame,class Scan *scan)\n {\n   m_ucCount = scan->ComponentsInScan();\n\
    \ \n-  // The residual scan uses all components here, not just for, but\n+  //\
    \ The residual scan uses all components here, not just four, but\n   // it does\
    \ not require the component count either.\n   for(volatile UBYTE i = 0;i < m_ucCount\
    \ && i < 4;i++) {\n     JPG_TRY {"
  - "--- a/marker/scan.cpp\n+++ b/marker/scan.cpp\n@@ -42,7 +42,7 @@\n **\n ** Represents\
    \ all data in a single scan, and hence is the SOS marker.\n **\n-** $Id: scan.cpp,v\
    \ 1.117 2021/11/15 07:39:43 thor Exp $\n+** $Id: scan.cpp,v 1.118 2022/05/30 14:06:11\
    \ thor Exp $\n **\n */\n \n@@ -338,6 +338,14 @@ void Scan::CreateParser(void)\n\
    \   //\n   assert(m_pParser == NULL);\n   //\n+  // Check whether all components\
    \ are there.\n+  for(UBYTE i = 0;i < m_ucCount && i < 4;i++) {\n+    if (ComponentOf(i)\
    \ == NULL) {\n+      JPG_THROW(MALFORMED_STREAM,\"Scan::CreateParser\",\n+   \
    \             \"found a component ID in a scan that does not exist\");\n+    }\n\
    +  }\n+  //\n   switch(type) {\n   case Baseline:\n     m_pParser = new(m_pEnviron)\
    \ class SequentialScan(m_pFrame,this,"
  identifiers:
  - CVE-2022-32201
  - CWE-476
  overview: In libjpeg 1.63, there is a NULL pointer dereference in Component::SubXOf
    in component.hpp.
  references:
  - source: cve@mitre.org
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/thorfdbg/libjpeg/commit/ea6315164b1649ff932a396b7600eac4bffcfaba
  - source: cve@mitre.org
    tags:
    - Exploit
    - Issue Tracking
    - Third Party Advisory
    url: https://github.com/thorfdbg/libjpeg/issues/73
  title: In libjpeg 1.63, there is a NULL pointer dereference in Component::SubXOf
    in component.hpp.
- diff_content:
  - "--- a/control/linebitmaprequester.cpp\n+++ b/control/linebitmaprequester.cpp\n\
    @@ -43,7 +43,7 @@\n ** This class pulls blocks from the frame and reconstructs\
    \ from those\n ** quantized block lines or encodes from them.\n **\n-** $Id: linebitmaprequester.cpp,v\
    \ 1.36 2021/07/22 13:18:36 thor Exp $\n+** $Id: linebitmaprequester.cpp,v 1.37\
    \ 2022/05/31 10:16:52 thor Exp $\n **\n */\n \n@@ -562,7 +562,11 @@ void LineBitmapRequester::ReconstructRegion(const\
    \ RectAngle<LONG> &orgregion,con\n           LONG *dst = m_ppCTemp[i];\n     \
    \      if (i >= rr->rr_usFirstComponent && i <= rr->rr_usLastComponent) {\n  \
    \           ExtractBitmap(m_ppTempIBM[i],r,i);\n-            FetchRegion(x,*m_pppImage[i],dst);\n\
    +            if (*m_pppImage[i]) {\n+              FetchRegion(x,*m_pppImage[i],dst);\n\
    +            } else {\n+              memset(dst,0,sizeof(LONG) * 64);\n+    \
    \        }\n           } else {\n             memset(dst,0,sizeof(LONG) * 64);\n\
    \           }"
  identifiers:
  - CVE-2022-32202
  - CWE-476
  overview: In libjpeg 1.63, there is a NULL pointer dereference in LineBuffer::FetchRegion
    in linebuffer.cpp.
  references:
  - source: cve@mitre.org
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/thorfdbg/libjpeg/commit/51c3241b6da39df30f016b63f43f31c4011222c7
  - source: cve@mitre.org
    tags:
    - Exploit
    - Issue Tracking
    - Third Party Advisory
    url: https://github.com/thorfdbg/libjpeg/issues/74
  title: In libjpeg 1.63, there is a NULL pointer dereference in LineBuffer::FetchRegion
    in linebuffer.cpp.
- diff_content:
  - "--- a/src/index.c\n+++ b/src/index.c\n@@ -29,11 +29,11 @@\n /**\n  @brief Read\
    \ index entry label from buffer pointing at index record data\n  \n- @param[in,out]\
    \ output Output string\n+ @param[in,out] output Output buffer (INDX_LABEL_SIZEMAX\
    \ + 1 bytes)\n  @param[in,out] buf MOBIBuffer structure, offset pointing at index\
    \ entry label\n  @param[in] length Number of bytes to be read\n  @param[in] has_ligatures\
    \ Decode ligatures if true\n- @return Size of read label\n+ @return Length of\
    \ output string (without null terminator), on error buf->error set to MOBI_RET\
    \ status\n  */\n size_t mobi_indx_get_label(unsigned char *output, MOBIBuffer\
    \ *buf, const size_t length, const size_t has_ligatures) {\n     if (!output)\
    \ {\n@@ -248,9 +248,9 @@ uint16_t mobi_ordt_lookup(const MOBIOrdt *ordt, const\
    \ uint16_t offset) {\n  \n  @param[in] ordt MOBIOrdt structure (ORDT data and\
    \ metadata)\n  @param[in,out] buf MOBIBuffer structure with input string\n- @param[in,out]\
    \ output Output buffer (INDX_LABEL_SIZEMAX bytes)\n+ @param[in,out] output Output\
    \ buffer (INDX_LABEL_SIZEMAX + 1 bytes)\n  @param[in] length Length of input string\
    \ contained in buf\n- @return Number of bytes read\n+ @return Length of output\
    \ string (without null terminator)\n  */\n size_t mobi_getstring_ordt(const MOBIOrdt\
    \ *ordt, MOBIBuffer *buf, unsigned char *output, size_t length) {\n     size_t\
    \ i = 0;\n@@ -362,12 +362,16 @@ static MOBI_RET mobi_parse_index_entry(MOBIIndx\
    \ *indx, const MOBIIdxt idxt, cons\n         debug_print(\"Label length too long:\
    \ %zu\\n\", label_length);\n         return MOBI_DATA_CORRUPT;\n     }\n-    char\
    \ text[INDX_LABEL_SIZEMAX];\n+    char text[INDX_LABEL_SIZEMAX + 1];\n     /*\
    \ FIXME: what is ORDT1 for? */\n     if (ordt->ordt2) {\n         label_length\
    \ = mobi_getstring_ordt(ordt, buf, (unsigned char*) text, label_length);\n   \
    \  } else {\n         label_length = mobi_indx_get_label((unsigned char*) text,\
    \ buf, label_length, indx->ligt_entries_count);\n+        if (buf->error != MOBI_SUCCESS)\
    \ {\n+            debug_print(\"Buffer error reading label: %d\\n\", buf->error);\n\
    +            return MOBI_DATA_CORRUPT;\n+        }\n     }\n     indx->entries[entry_number].label\
    \ = malloc(label_length + 1);\n     if (indx->entries[entry_number].label == NULL)\
    \ {"
  identifiers:
  - CVE-2022-1987
  - CWE-125
  overview: Buffer Over-read in GitHub repository bfabiszewski/libmobi prior to 0.11.
  references:
  - source: security@huntr.dev
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/bfabiszewski/libmobi/commit/612562bc1ea38f1708b044e7a079c47a05b1291d
  - source: security@huntr.dev
    tags:
    - Exploit
    - Patch
    - Third Party Advisory
    url: https://huntr.dev/bounties/e8197737-7557-443e-a59f-2a86e8dda75f
  title: Buffer Over-read in GitHub repository bfabiszewski/libmobi prior to 0.11.
- diff_content:
  - "--- a/src/filters/isoffin_read.c\n+++ b/src/filters/isoffin_read.c\n@@ -1453,6\
    \ +1453,13 @@ static GF_Err isoffin_process(GF_Filter *filter)\n \t\t\t\t\tgf_filter_pid_set_eos(ch->pid);\n\
    \ \t\t\t\t}\n \t\t\t\tbreak;\n+\t\t\t} else if (ch->last_state==GF_ISOM_INVALID_FILE)\
    \ {\n+\t\t\t\tif (!ch->eos_sent) {\n+\t\t\t\t\tch->eos_sent = GF_TRUE;\n+\t\t\t\
    \t\tread->eos_signaled = GF_TRUE;\n+\t\t\t\t\tgf_filter_pid_set_eos(ch->pid);\n\
    +\t\t\t\t}\n+\t\t\t\treturn ch->last_state;\n \t\t\t} else {\n \t\t\t\tread->force_fetch\
    \ = GF_TRUE;\n \t\t\t\tbreak;"
  - "--- a/src/filters/isoffin_read_ch.c\n+++ b/src/filters/isoffin_read_ch.c\n@@\
    \ -479,6 +479,10 @@ void isor_reader_get_sample(ISOMChannel *ch)\n \t\t\t\tif\
    \ (!ch->has_edit_list && ch->sample_num)\n \t\t\t\t\tch->sample_num--;\n \t\t\t\
    } else {\n+\t\t\t\tif (ch->to_init && ch->sample_num) {\n+\t\t\t\t\tGF_LOG(GF_LOG_ERROR,\
    \ GF_LOG_CONTAINER, (\"[IsoMedia] Failed to fetch initial sample %d for track\
    \ %d\\n\"));\n+\t\t\t\t\tch->last_state = GF_ISOM_INVALID_FILE;\n+\t\t\t\t}\n\
    \ \t\t\t\tif (ch->sample_num >= gf_isom_get_sample_count(ch->owner->mov, ch->track))\
    \ {\n \t\t\t\t\tch->last_state = GF_EOS;\n \t\t\t\t}"
  identifiers:
  - CVE-2021-40592
  - CWE-835
  overview: GPAC version before commit 71460d72ec07df766dab0a4d52687529f3efcf0a (version
    v1.0.1 onwards) contains loop with unreachable exit condition ('infinite loop')
    vulnerability in ISOBMFF reader filter, isoffin_read.c. Function isoffin_process()
    can result in DoS by infinite loop. To exploit, the victim must open a specially
    crafted mp4 file.
  references:
  - source: cve@mitre.org
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/gpac/gpac/commit/71460d72ec07df766dab0a4d52687529f3efcf0a
  - source: cve@mitre.org
    tags:
    - Exploit
    - Issue Tracking
    - Third Party Advisory
    url: https://github.com/gpac/gpac/issues/1876
  - source: cve@mitre.org
    url: https://www.debian.org/security/2023/dsa-5411
  title: GPAC version before commit 71460d72ec07df766dab0a4d52687529f3efcf0a (version
    v1.0.1 onwards) contains loop with unreachable exit condition ('infinite loop')
    vulnerability in ISOBMFF reader filter, isoffin_read.c. Function isoffin_process()
    can result in DoS by infinite loop. To exploit, the victim must open a specially
    crafted mp4 file.
- diff_content:
  - "--- a/src/protocol.c\n+++ b/src/protocol.c\n@@ -275,8 +275,10 @@ int trilogy_parse_handshake_packet(const\
    \ uint8_t *buff, size_t len, trilogy_hand\n     if (out_packet->capabilities &\
    \ TRILOGY_CAPABILITIES_SECURE_CONNECTION && auth_data_len > 8) {\n         uint8_t\
    \ remaining_auth_data_len = auth_data_len - 8;\n \n-        if (remaining_auth_data_len\
    \ > 13) {\n-            remaining_auth_data_len = 13;\n+        // The auth plugins\
    \ we support all provide exactly 21 bytes of\n+        // auth_data. Reject any\
    \ other values for auth_data_len.\n+        if (SCRAMBLE_LEN + 1 != auth_data_len)\
    \ {\n+            return TRILOGY_PROTOCOL_VIOLATION;\n         }\n \n        \
    \ CHECKED(trilogy_reader_copy_buffer(&reader, remaining_auth_data_len, out_packet->scramble\
    \ + 8));"
  identifiers:
  - CVE-2022-31026
  - CWE-908
  overview: Trilogy is a client library for MySQL. When authenticating, a malicious
    server could return a specially crafted authentication packet, causing the client
    to read and return up to 12 bytes of data from an uninitialized variable in stack
    memory. Users of the trilogy gem should upgrade to version 2.1.1 This issue can
    be avoided by only connecting to trusted servers.
  references:
  - source: security-advisories@github.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/github/trilogy/commit/6bed62789eaf119902b0fe247d2a91d56c31a962
  - source: security-advisories@github.com
    tags:
    - Third Party Advisory
    url: https://github.com/github/trilogy/security/advisories/GHSA-5g4r-2qhx-vqfm
  title: Trilogy is a client library for MySQL. When authenticating, a malicious server
    could return a specially crafted authentication packet, causing the client to
    read and return up to 12 bytes of data from an uninitialized variable in stack
    memory. Users of the trilogy gem should upgrade to version 2.1.1 This issue can
    be avoided by only connecting to trusted servers.
- diff_content:
  - "--- a/src/ex_docmd.c\n+++ b/src/ex_docmd.c\n@@ -3441,9 +3441,17 @@ parse_cmd_address(exarg_T\
    \ *eap, char **errormsg, int silent)\n     static void\n append_command(char_u\
    \ *cmd)\n {\n-    char_u *s = cmd;\n-    char_u *d;\n+    size_t  len = STRLEN(IObuff);\n\
    +    char_u  *s = cmd;\n+    char_u  *d;\n \n+    if (len > IOSIZE - 100)\n+ \
    \   {\n+\t// Not enough space, truncate and put in \"...\".\n+\td = IObuff + IOSIZE\
    \ - 100;\n+\td -= mb_head_off(IObuff, d);\n+\tSTRCPY(d, \"...\");\n+    }\n  \
    \   STRCAT(IObuff, \": \");\n     d = IObuff + STRLEN(IObuff);\n     while (*s\
    \ != NUL && d - IObuff + 5 < IOSIZE)"
  - "--- a/src/version.c\n+++ b/src/version.c\n@@ -734,6 +734,8 @@ static char *(features[])\
    \ =\n \n static int included_patches[] =\n {   /* Add new patch number below this\
    \ line */\n+/**/\n+    5063,\n /**/\n     5062,\n /**/"
  identifiers:
  - CVE-2022-2000
  - CWE-787
  overview: Out-of-bounds Write in GitHub repository vim/vim prior to 8.2.
  references:
  - source: security@huntr.dev
    tags:
    - Mailing List
    - Third Party Advisory
    url: http://seclists.org/fulldisclosure/2022/Oct/28
  - source: security@huntr.dev
    tags:
    - Mailing List
    - Third Party Advisory
    url: http://seclists.org/fulldisclosure/2022/Oct/41
  - source: security@huntr.dev
    tags:
    - Mailing List
    - Third Party Advisory
    url: http://seclists.org/fulldisclosure/2022/Oct/43
  - source: security@huntr.dev
    tags:
    - Mailing List
    - Third Party Advisory
    url: http://seclists.org/fulldisclosure/2022/Oct/45
  - source: security@huntr.dev
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/vim/vim/commit/44a3f3353e0407e9fffee138125a6927d1c9e7e5
  - source: security@huntr.dev
    tags:
    - Exploit
    - Third Party Advisory
    url: https://huntr.dev/bounties/f61a64e2-d163-461b-a77e-46ab38e021f0
  - source: security@huntr.dev
    tags:
    - Mailing List
    - Third Party Advisory
    url: https://lists.debian.org/debian-lts-announce/2022/11/msg00032.html
  - source: security@huntr.dev
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/4JJNUS4AEVYSEJMCK6JZB57QHD5V2G4O/
  - source: security@huntr.dev
    tags:
    - Third Party Advisory
    url: https://security.gentoo.org/glsa/202208-32
  - source: security@huntr.dev
    url: https://security.gentoo.org/glsa/202305-16
  - source: security@huntr.dev
    tags:
    - Third Party Advisory
    url: https://support.apple.com/kb/HT213443
  - source: security@huntr.dev
    tags:
    - Third Party Advisory
    url: https://support.apple.com/kb/HT213444
  - source: security@huntr.dev
    tags:
    - Third Party Advisory
    url: https://support.apple.com/kb/HT213488
  title: Out-of-bounds Write in GitHub repository vim/vim prior to 8.2.
- diff_content:
  - "--- a/pjlib-util/src/pjlib-util/stun_simple.c\n+++ b/pjlib-util/src/pjlib-util/stun_simple.c\n\
    @@ -54,6 +54,7 @@ PJ_DEF(pj_status_t) pjstun_parse_msg( void *buf, pj_size_t buf_len,\n\
    \ {\n     pj_uint16_t msg_type, msg_len;\n     char *p_attr;\n+    int attr_max_cnt\
    \ = PJ_ARRAY_SIZE(msg->attr);\n \n     PJ_CHECK_STACK();\n \n@@ -83,7 +84,7 @@\
    \ PJ_DEF(pj_status_t) pjstun_parse_msg( void *buf, pj_size_t buf_len,\n     msg->attr_count\
    \ = 0;\n     p_attr = (char*)buf + sizeof(pjstun_msg_hdr);\n \n-    while (msg_len\
    \ > 0) {\n+    while (msg_len > 0 && msg->attr_count < attr_max_cnt) {\n \tpjstun_attr_hdr\
    \ **attr = &msg->attr[msg->attr_count];\n \tpj_uint32_t len;\n \tpj_uint16_t attr_type;\n\
    @@ -111,6 +112,10 @@ PJ_DEF(pj_status_t) pjstun_parse_msg( void *buf, pj_size_t\
    \ buf_len,\n \tp_attr += len;\n \t++msg->attr_count;\n     }\n+    if (msg->attr_count\
    \ == attr_max_cnt) {\n+\tPJ_LOG(4, (THIS_FILE, \"Warning: max number attribute\
    \ %d reached.\",\n+\t\t   attr_max_cnt));\n+    }\n \n     return PJ_SUCCESS;\n\
    \ }"
  identifiers:
  - CVE-2022-31031
  - CWE-120
  overview: 'PJSIP is a free and open source multimedia communication library written
    in C language implementing standard based protocols such as SIP, SDP, RTP, STUN,
    TURN, and ICE. In versions prior to and including 2.12.1 a stack buffer overflow
    vulnerability affects PJSIP users that use STUN in their applications, either
    by: setting a STUN server in their account/media config in PJSUA/PJSUA2 level,
    or directly using `pjlib-util/stun_simple` API. A patch is available in commit
    450baca which should be included in the next release. There are no known workarounds
    for this issue.'
  references:
  - source: security-advisories@github.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/pjsip/pjproject/commit/450baca94f475345542c6953832650c390889202
  - source: security-advisories@github.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/pjsip/pjproject/security/advisories/GHSA-26j7-ww69-c4qj
  - source: security-advisories@github.com
    tags:
    - Mailing List
    url: https://lists.debian.org/debian-lts-announce/2023/02/msg00029.html
  - source: security-advisories@github.com
    url: https://lists.debian.org/debian-lts-announce/2023/08/msg00038.html
  - source: security-advisories@github.com
    tags:
    - Third Party Advisory
    url: https://security.gentoo.org/glsa/202210-37
  - source: security-advisories@github.com
    tags:
    - Third Party Advisory
    url: https://www.debian.org/security/2023/dsa-5358
  title: 'PJSIP is a free and open source multimedia communication library written
    in C language implementing standard based protocols such as SIP, SDP, RTP, STUN,
    TURN, and ICE. In versions prior to and including 2.12.1 a stack buffer overflow
    vulnerability affects PJSIP users that use STUN in their applications, either
    by: setting a STUN server in their account/media config in PJSUA/PJSUA2 level,
    or directly using `pjlib-util/stun_simple` API. A patch is available in commit
    450baca which should be included in the next release. There are no known workarounds
    for this issue.'
- diff_content:
  - "--- a/codestream/sampleinterleavedlsscan.cpp\n+++ b/codestream/sampleinterleavedlsscan.cpp\n\
    @@ -42,7 +42,7 @@\n ** A JPEG LS scan interleaving samples of several components,\n\
    \ ** sample by sample.\n **\n-** $Id: sampleinterleavedlsscan.cpp,v 1.15 2014/11/14\
    \ 15:41:32 thor Exp $\n+** $Id: sampleinterleavedlsscan.cpp,v 1.16 2022/06/08\
    \ 10:54:55 thor Exp $\n **\n */\n \n@@ -112,9 +112,12 @@ bool SampleInterleavedLSScan::ParseMCU(void)\n\
    \   if (lines > 8) {\n     lines = 8;\n   }\n+\n+  if (lines == 0)\n+    return\
    \ false;\n+  \n   if (m_pFrame->HeightOf() > 0)\n     m_ulRemaining[0] -= lines;\n\
    -  assert(lines > 0);\n   assert(m_ucCount < 4);\n \n   //"
  - "--- a/codestream/singlecomponentlsscan.cpp\n+++ b/codestream/singlecomponentlsscan.cpp\n\
    @@ -41,7 +41,7 @@\n /*\n ** A JPEG LS scan covering only a single component.\n\
    \ **\n-** $Id: singlecomponentlsscan.cpp,v 1.18 2014/11/14 15:41:32 thor Exp $\n\
    +** $Id: singlecomponentlsscan.cpp,v 1.19 2022/06/08 10:54:55 thor Exp $\n **\n\
    \ */\n \n@@ -96,8 +96,9 @@ bool SingleComponentLSScan::ParseMCU(void)\n   }\n\
    \   if (m_pFrame->HeightOf() > 0)\n     m_ulRemaining[0] -= lines;\n-  \n-  assert(lines\
    \ > 0);\n+\n+  if (lines == 0)\n+    return false;\n \n   // Loop over lines and\
    \ columns\n   do {"
  identifiers:
  - CVE-2022-32978
  - CWE-617
  overview: There is an assertion failure in SingleComponentLSScan::ParseMCU in singlecomponentlsscan.cpp
    in libjpeg before 1.64 via an empty JPEG-LS scan.
  references:
  - source: cve@mitre.org
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/thorfdbg/libjpeg/commit/4746b577931e926a49e50de9720a4946de3069a7
  - source: cve@mitre.org
    tags:
    - Exploit
    - Issue Tracking
    - Third Party Advisory
    url: https://github.com/thorfdbg/libjpeg/issues/75
  title: There is an assertion failure in SingleComponentLSScan::ParseMCU in singlecomponentlsscan.cpp
    in libjpeg before 1.64 via an empty JPEG-LS scan.
- diff_content:
  - "--- a/src/spell.c\n+++ b/src/spell.c\n@@ -1275,7 +1275,7 @@ spell_move_to(\n\
    \     char_u\t*line;\n     char_u\t*p;\n     char_u\t*endp;\n-    hlf_T\tattr;\n\
    +    hlf_T\tattr = 0;\n     int\t\tlen;\n #ifdef FEAT_SYN_HL\n     int\t\thas_syntax\
    \ = syntax_present(wp);\n@@ -1308,6 +1308,8 @@ spell_move_to(\n \n     while (!got_int)\n\
    \     {\n+\tint empty_line;\n+\n \tline = ml_get_buf(wp->w_buffer, lnum, FALSE);\n\
    \ \n \tlen = (int)STRLEN(line);\n@@ -1340,7 +1342,9 @@ spell_move_to(\n \t}\n\
    \ \n \t// Copy the line into \"buf\" and append the start of the next line if\n\
    -\t// possible.\n+\t// possible.  Note: this ml_get_buf() may make \"line\" invalid,\
    \ check\n+\t// for empty line first.\n+\tempty_line = *skipwhite(line) == NUL;\n\
    \ \tSTRCPY(buf, line);\n \tif (lnum < wp->w_buffer->b_ml.ml_line_count)\n \t \
    \   spell_cat_line(buf + STRLEN(buf),\n@@ -1487,7 +1491,7 @@ spell_move_to(\n\
    \ \t    --capcol;\n \n \t    // But after empty line check first word in next\
    \ line\n-\t    if (*skipwhite(line) == NUL)\n+\t    if (empty_line)\n \t\tcapcol\
    \ = 0;\n \t}\n "
  - "--- a/src/version.c\n+++ b/src/version.c\n@@ -734,6 +734,8 @@ static char *(features[])\
    \ =\n \n static int included_patches[] =\n {   /* Add new patch number below this\
    \ line */\n+/**/\n+    5072,\n /**/\n     5071,\n /**/"
  identifiers:
  - CVE-2022-2042
  - CWE-416
  overview: Use After Free in GitHub repository vim/vim prior to 8.2.
  references:
  - source: security@huntr.dev
    tags:
    - Mailing List
    - Third Party Advisory
    url: http://seclists.org/fulldisclosure/2022/Oct/28
  - source: security@huntr.dev
    tags:
    - Mailing List
    - Third Party Advisory
    url: http://seclists.org/fulldisclosure/2022/Oct/41
  - source: security@huntr.dev
    tags:
    - Mailing List
    - Third Party Advisory
    url: http://seclists.org/fulldisclosure/2022/Oct/43
  - source: security@huntr.dev
    tags:
    - Mailing List
    - Third Party Advisory
    url: http://seclists.org/fulldisclosure/2022/Oct/45
  - source: security@huntr.dev
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/vim/vim/commit/2813f38e021c6e6581c0c88fcf107e41788bc835
  - source: security@huntr.dev
    tags:
    - Exploit
    - Patch
    - Third Party Advisory
    url: https://huntr.dev/bounties/8628b4cd-4055-4059-aed4-64f7fdc10eba
  - source: security@huntr.dev
    tags:
    - Third Party Advisory
    url: https://security.gentoo.org/glsa/202208-32
  - source: security@huntr.dev
    url: https://security.gentoo.org/glsa/202305-16
  - source: security@huntr.dev
    tags:
    - Third Party Advisory
    url: https://support.apple.com/kb/HT213443
  - source: security@huntr.dev
    tags:
    - Third Party Advisory
    url: https://support.apple.com/kb/HT213444
  - source: security@huntr.dev
    tags:
    - Third Party Advisory
    url: https://support.apple.com/kb/HT213488
  title: Use After Free in GitHub repository vim/vim prior to 8.2.
- diff_content:
  - "--- a/libnsgif/lzw.c\n+++ b/libnsgif/lzw.c\n@@ -329,6 +329,10 @@ lzw_result lzw_decode(struct\
    \ lzw_ctx *ctx,\n \t\t/* Code is invalid */\n \t\treturn LZW_BAD_CODE;\n \n+\t\
    } else if (code_new >= 1 << LZW_CODE_MAX) {\n+\t\t/* Don't access out of bound\
    \ */\n+\t\treturn LZW_BAD_CODE;\n+\n \t} else if (code_new < current_entry) {\n\
    \ \t\t/* Code is in table */\n \t\tcode_out = code_new;"
  identifiers:
  - CVE-2022-2061
  - CWE-787
  overview: Heap-based Buffer Overflow in GitHub repository hpjansson/chafa prior
    to 1.12.0.
  references:
  - source: security@huntr.dev
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/hpjansson/chafa/commit/e6ce3746cdcf0836b9dae659a5aed15d73a080d8
  - source: security@huntr.dev
    tags:
    - Exploit
    - Patch
    - Third Party Advisory
    url: https://huntr.dev/bounties/365ab61f-9a63-421c-97e6-21d4653021f0
  title: Heap-based Buffer Overflow in GitHub repository hpjansson/chafa prior to
    1.12.0.
- diff_content:
  - "--- a/drivers/android/binder.c\n+++ b/drivers/android/binder.c\n@@ -2236,10 +2236,12\
    \ @@ static void binder_deferred_fd_close(int fd)\n \t\treturn;\n \tinit_task_work(&twcb->twork,\
    \ binder_do_fd_close);\n \t__close_fd_get_file(fd, &twcb->file);\n-\tif (twcb->file)\n\
    +\tif (twcb->file) {\n+\t\tfilp_close(twcb->file, current->files);\n \t\ttask_work_add(current,\
    \ &twcb->twork, TWA_RESUME);\n-\telse\n+\t} else {\n \t\tkfree(twcb);\n+\t}\n\
    \ }\n \n static void binder_transaction_buffer_release(struct binder_proc *proc,"
  - "--- a/fs/file.c\n+++ b/fs/file.c\n@@ -650,7 +650,9 @@ int __close_fd(struct files_struct\
    \ *files, unsigned fd)\n EXPORT_SYMBOL(__close_fd); /* for ksys_close() */\n \n\
    \ /*\n- * variant of __close_fd that gets a ref on the file for later fput\n+\
    \ * variant of __close_fd that gets a ref on the file for later fput.\n+ * The\
    \ caller must ensure that filp_close() called on the file, and then\n+ * an fput().\n\
    \  */\n int __close_fd_get_file(unsigned int fd, struct file **res)\n {\n@@ -670,7\
    \ +672,7 @@ int __close_fd_get_file(unsigned int fd, struct file **res)\n \tspin_unlock(&files->file_lock);\n\
    \ \tget_file(file);\n \t*res = file;\n-\treturn filp_close(file, files);\n+\t\
    return 0;\n \n out_unlock:\n \tspin_unlock(&files->file_lock);"
  identifiers:
  - CVE-2022-21504
  - CWE-416
  overview: 'The code in UEK6 U3 was missing an appropiate file descriptor count to
    be missing. This resulted in a use count error that allowed a file descriptor
    to a socket to be closed and freed while it was still in use by another portion
    of the kernel. An attack with local access can operate on the socket, and cause
    a denial of service. CVSS 3.1 Base Score 5.5 (Availability impacts). CVSS Vector:
    (CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H).'
  references:
  - source: secalert_us@oracle.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/oracle/linux-uek/commit/49c68f5f892d8c2be00e0a89ff2a035422c03b59
  title: 'The code in UEK6 U3 was missing an appropiate file descriptor count to be
    missing. This resulted in a use count error that allowed a file descriptor to
    a socket to be closed and freed while it was still in use by another portion of
    the kernel. An attack with local access can operate on the socket, and cause a
    denial of service. CVSS 3.1 Base Score 5.5 (Availability impacts). CVSS Vector:
    (CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H).'
- diff_content:
  - "--- a/coders/psd.c\n+++ b/coders/psd.c\n@@ -1022,7 +1022,7 @@ static MagickBooleanType\
    \ ReadPSDChannelPixels(Image *image,const ssize_t row,\n           number_bits=8;\n\
    \         for (bit = 0; bit < (ssize_t) number_bits; bit++)\n         {\n-   \
    \       SetPSDPixel(image,channel,packet_size,(((unsigned char) pixel)\n+    \
    \      SetPSDPixel(image,channel,packet_size,(((unsigned char)((ssize_t)pixel))\n\
    \             & (0x01 << (7-bit))) != 0 ? 0 : QuantumRange,q,exception);\n   \
    \        q+=GetPixelChannels(image);\n           x++;"
  - "--- a/coders/emf.c\n+++ b/coders/emf.c\n@@ -411,7 +411,8 @@ static HENHMETAFILE\
    \ ReadEnhMetaFile(const char *path,ssize_t *width,\n     }\n   ReadFile(hFile,pBits,dwSize,&dwSize,NULL);\n\
    \   CloseHandle(hFile);\n-  if (((PAPMHEADER) pBits)->dwKey != 0x9ac6cdd7l)\n\
    +  if (((PAPMHEADER) pBits)->dwKey != 0x9ac6cdd7l ||\n+      (((PAPMHEADER) pBits)->wInch\
    \ == 0))\n     {\n       pBits=(BYTE *) DestroyString((char *) pBits);\n     \
    \  return((HENHMETAFILE) NULL);"
  - "--- a/coders/psd.c\n+++ b/coders/psd.c\n@@ -1048,8 +1048,9 @@ static MagickBooleanType\
    \ ReadPSDChannelPixels(Image *image,\n           number_bits=8;\n         for\
    \ (bit=0; bit < number_bits; bit++)\n         {\n-          SetPSDPixel(image,channels,type,packet_size,(((unsigned\
    \ char) pixel)\n-            & (0x01 << (7-bit))) != 0 ? 0 : QuantumRange,q++,indexes,x++);\n\
    +          SetPSDPixel(image,channels,type,packet_size,\n+            (((unsigned\
    \ char) ((ssize_t) pixel)) & (0x01 << (7-bit))) != 0 ? 0 :\n+            QuantumRange,q++,indexes,x++);\n\
    \         }\n         if (x != (ssize_t) image->columns)\n           x--;"
  - "--- a/magick/widget.c\n+++ b/magick/widget.c\n@@ -7861,6 +7861,8 @@ MagickExport\
    \ int XMenuWidget(Display *display,XWindows *windows,\n             break;\n \
    \          }\n         state&=(~InactiveWidgetState);\n+        if (selection_info.height\
    \ == 0)\n+          break;\n         id=(event.xbutton.y-top_offset)/(int) selection_info.height;\n\
    \         selection_info.id=id;\n         if ((id < 0) || (id >= (int) number_selections))\n\
    @@ -7914,6 +7916,8 @@ MagickExport int XMenuWidget(Display *display,XWindows *windows,\n\
    \         if (event.xcrossing.state == 0)\n           break;\n         state&=(~InactiveWidgetState);\n\
    +        if (selection_info.height == 0)\n+          break;\n         id=((event.xcrossing.y-top_offset)/(int)\
    \ selection_info.height);\n         if ((selection_info.id >= 0) &&\n        \
    \     (selection_info.id < (int) number_selections))\n@@ -8000,6 +8004,8 @@ MagickExport\
    \ int XMenuWidget(Display *display,XWindows *windows,\n           break;\n   \
    \      if (state & InactiveWidgetState)\n           break;\n+        if (selection_info.height\
    \ == 0)\n+          break;\n         id=(event.xmotion.y-top_offset)/(int) selection_info.height;\n\
    \         if ((selection_info.id >= 0) &&\n             (selection_info.id < (int)\
    \ number_selections))"
  - "--- a/wand/animate.c\n+++ b/wand/animate.c\n@@ -1143,7 +1143,10 @@ WandExport\
    \ MagickBooleanType AnimateImageCommand(ImageInfo *image_info,\n             if\
    \ (i == (ssize_t) argc)\n               ThrowAnimateException(OptionError,\"MissingArgument\"\
    ,option);\n             if (XRemoteCommand(display,resource_info.window_id,argv[i])\
    \ != 0)\n-              return(MagickFalse);\n+              {\n+            \
    \    DestroyAnimate();\n+                return(MagickFalse);\n+             \
    \ }\n             i--;\n             break;\n           }"
  - "--- a/wand/display.c\n+++ b/wand/display.c\n@@ -1491,7 +1491,10 @@ WandExport\
    \ MagickBooleanType DisplayImageCommand(ImageInfo *image_info,\n             if\
    \ (i == (ssize_t) argc)\n               ThrowDisplayException(OptionError,\"MissingArgument\"\
    ,option);\n             if (XRemoteCommand(display,resource_info.window_id,argv[i])\
    \ != 0)\n-              return(MagickFalse);\n+              {\n+            \
    \    DestroyDisplay();\n+                return(MagickFalse);\n+             \
    \ }\n             i--;\n             break;\n           }"
  identifiers:
  - CVE-2022-32545
  - CWE-190
  overview: A vulnerability was found in ImageMagick, causing an outside the range
    of representable values of type 'unsigned char' at coders/psd.c, when crafted
    or untrusted input is processed. This leads to a negative impact to application
    availability or other problems related to undefined behavior.
  references:
  - source: secalert@redhat.com
    tags:
    - Issue Tracking
    - Patch
    - Third Party Advisory
    url: https://bugzilla.redhat.com/show_bug.cgi?id=2091811
  - source: secalert@redhat.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/ImageMagick/ImageMagick/commit/9c9a84cec4ab28ee0b57c2b9266d6fbe68183512
  - source: secalert@redhat.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/ImageMagick/ImageMagick6/commit/450949ed017f009b399c937cf362f0058eacc5fa
  - source: secalert@redhat.com
    url: https://lists.debian.org/debian-lts-announce/2023/05/msg00020.html
  title: A vulnerability was found in ImageMagick, causing an outside the range of
    representable values of type 'unsigned char' at coders/psd.c, when crafted or
    untrusted input is processed. This leads to a negative impact to application availability
    or other problems related to undefined behavior.
- diff_content:
  - "--- a/coders/pcl.c\n+++ b/coders/pcl.c\n@@ -295,8 +295,8 @@ static Image *ReadPCLImage(const\
    \ ImageInfo *image_info,ExceptionInfo *exception)\n     /*\n       Set PCL render\
    \ geometry.\n     */\n-    width=(size_t) floor(bounds.x2-bounds.x1+0.5);\n- \
    \   height=(size_t) floor(bounds.y2-bounds.y1+0.5);\n+    width=(size_t)CastDoubleToLong(floor(bounds.x2-bounds.x1+0.5));\n\
    +    height=(size_t)CastDoubleToLong(floor(bounds.y2-bounds.y1+0.5));\n     if\
    \ (width > page.width)\n       page.width=width;\n     if (height > page.height)"
  - "--- a/coders/pcl.c\n+++ b/coders/pcl.c\n@@ -295,8 +295,8 @@ static Image *ReadPCLImage(const\
    \ ImageInfo *image_info,ExceptionInfo *exception)\n     /*\n       Set PCL render\
    \ geometry.\n     */\n-    width=(size_t) floor(bounds.x2-bounds.x1+0.5);\n- \
    \   height=(size_t) floor(bounds.y2-bounds.y1+0.5);\n+    width=(size_t) CastDoubleToLong(floor(bounds.x2-bounds.x1+0.5));\n\
    +    height=(size_t) CastDoubleToLong(floor(bounds.y2-bounds.y1+0.5));\n     if\
    \ (width > page.width)\n       page.width=width;\n     if (height > page.height)"
  identifiers:
  - CVE-2022-32546
  - CWE-190
  overview: A vulnerability was found in ImageMagick, causing an outside the range
    of representable values of type 'unsigned long' at coders/pcl.c, when crafted
    or untrusted input is processed. This leads to a negative impact to application
    availability or other problems related to undefined behavior.
  references:
  - source: secalert@redhat.com
    tags:
    - Issue Tracking
    - Patch
    - Third Party Advisory
    url: https://bugzilla.redhat.com/show_bug.cgi?id=2091812
  - source: secalert@redhat.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/ImageMagick/ImageMagick/commit/f221ea0fa3171f0f4fdf74ac9d81b203b9534c23
  - source: secalert@redhat.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/ImageMagick/ImageMagick6/commit/29c8abce0da56b536542f76a9ddfebdaab5b2943
  - source: secalert@redhat.com
    url: https://lists.debian.org/debian-lts-announce/2023/05/msg00020.html
  title: A vulnerability was found in ImageMagick, causing an outside the range of
    representable values of type 'unsigned long' at coders/pcl.c, when crafted or
    untrusted input is processed. This leads to a negative impact to application availability
    or other problems related to undefined behavior.
- diff_content:
  - "--- a/MagickCore/property.c\n+++ b/MagickCore/property.c\n@@ -1545,12 +1545,12\
    \ @@ static MagickBooleanType GetEXIFProperty(const Image *image,\n          \
    \   }\n             case EXIF_FMT_SINGLE:\n             {\n-              EXIFMultipleValues(4,\"\
    %f\",(double) *(float *) p1);\n+              EXIFMultipleValues(4,\"%f\",(double)ReadPropertySignedLong(endian,p1));\n\
    \               break;\n             }\n             case EXIF_FMT_DOUBLE:\n \
    \            {\n-              EXIFMultipleValues(8,\"%f\",*(double *) p1);\n\
    +              EXIFMultipleValues(8,\"%f\",(double)ReadPropertySignedLong(endian,p1));\n\
    \               break;\n             }\n             case EXIF_FMT_STRING:"
  - "--- a/magick/property.c\n+++ b/magick/property.c\n@@ -1526,12 +1526,14 @@ static\
    \ MagickBooleanType GetEXIFProperty(const Image *image,\n             }\n    \
    \         case EXIF_FMT_SINGLE:\n             {\n-              EXIFMultipleValues(4,\"\
    %f\",(double) *(float *) p1);\n+              EXIFMultipleValues(4,\"%.20g\",(double)\n\
    +                ReadPropertySignedLong(endian,p1));\n               break;\n\
    \             }\n             case EXIF_FMT_DOUBLE:\n             {\n-       \
    \       EXIFMultipleValues(8,\"%f\",*(double *) p1);\n+              EXIFMultipleValues(8,\"\
    %.20g\",(double)\n+                ReadPropertySignedLong(endian,p1));\n     \
    \          break;\n             }\n             case EXIF_FMT_STRING:"
  identifiers:
  - CVE-2022-32547
  - CWE-704
  overview: In ImageMagick, there is load of misaligned address for type 'double',
    which requires 8 byte alignment and for type 'float', which requires 4 byte alignment
    at MagickCore/property.c. Whenever crafted or untrusted input is processed by
    ImageMagick, this causes a negative impact to application availability or other
    problems related to undefined behavior.
  references:
  - source: secalert@redhat.com
    tags:
    - Issue Tracking
    - Patch
    - Third Party Advisory
    url: https://bugzilla.redhat.com/show_bug.cgi?id=2091813
  - source: secalert@redhat.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/ImageMagick/ImageMagick/commit/eac8ce4d873f28bb6a46aa3a662fb196b49b95d0
  - source: secalert@redhat.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/ImageMagick/ImageMagick6/commit/dc070da861a015d3c97488fdcca6063b44d47a7b
  - source: secalert@redhat.com
    url: https://lists.debian.org/debian-lts-announce/2023/05/msg00020.html
  title: In ImageMagick, there is load of misaligned address for type 'double', which
    requires 8 byte alignment and for type 'float', which requires 4 byte alignment
    at MagickCore/property.c. Whenever crafted or untrusted input is processed by
    ImageMagick, this causes a negative impact to application availability or other
    problems related to undefined behavior.
- diff_content:
  - "--- a/rdppm.c\n+++ b/rdppm.c\n@@ -5,7 +5,7 @@\n  * Copyright (C) 1991-1997, Thomas\
    \ G. Lane.\n  * Modified 2009 by Bill Allombert, Guido Vollbeding.\n  * libjpeg-turbo\
    \ Modifications:\n- * Copyright (C) 2015-2017, 2020, D. R. Commander.\n+ * Copyright\
    \ (C) 2015-2017, 2020-2021, D. R. Commander.\n  * For conditions of distribution\
    \ and use, see the accompanying README.ijg\n  * file.\n  *\n@@ -516,6 +516,11\
    \ @@ get_word_rgb_row(j_compress_ptr cinfo, cjpeg_source_ptr sinfo)\n   register\
    \ JSAMPLE *rescale = source->rescale;\n   JDIMENSION col;\n   unsigned int maxval\
    \ = source->maxval;\n+  register int rindex = rgb_red[cinfo->in_color_space];\n\
    +  register int gindex = rgb_green[cinfo->in_color_space];\n+  register int bindex\
    \ = rgb_blue[cinfo->in_color_space];\n+  register int aindex = alpha_index[cinfo->in_color_space];\n\
    +  register int ps = rgb_pixelsize[cinfo->in_color_space];\n \n   if (!ReadOK(source->pub.input_file,\
    \ source->iobuffer, source->buffer_width))\n     ERREXIT(cinfo, JERR_INPUT_EOF);\n\
    @@ -527,17 +532,20 @@ get_word_rgb_row(j_compress_ptr cinfo, cjpeg_source_ptr\
    \ sinfo)\n     temp |= UCH(*bufferptr++);\n     if (temp > maxval)\n       ERREXIT(cinfo,\
    \ JERR_PPM_OUTOFRANGE);\n-    *ptr++ = rescale[temp];\n+    ptr[rindex] = rescale[temp];\n\
    \     temp  = UCH(*bufferptr++) << 8;\n     temp |= UCH(*bufferptr++);\n     if\
    \ (temp > maxval)\n       ERREXIT(cinfo, JERR_PPM_OUTOFRANGE);\n-    *ptr++ =\
    \ rescale[temp];\n+    ptr[gindex] = rescale[temp];\n     temp  = UCH(*bufferptr++)\
    \ << 8;\n     temp |= UCH(*bufferptr++);\n     if (temp > maxval)\n       ERREXIT(cinfo,\
    \ JERR_PPM_OUTOFRANGE);\n-    *ptr++ = rescale[temp];\n+    ptr[bindex] = rescale[temp];\n\
    +    if (aindex >= 0)\n+      ptr[aindex] = 0xFF;\n+    ptr += ps;\n   }\n   return\
    \ 1;\n }\n@@ -624,7 +632,10 @@ start_input_ppm(j_compress_ptr cinfo, cjpeg_source_ptr\
    \ sinfo)\n       cinfo->in_color_space = JCS_GRAYSCALE;\n     TRACEMS2(cinfo,\
    \ 1, JTRC_PGM, w, h);\n     if (maxval > 255) {\n-      source->pub.get_pixel_rows\
    \ = get_word_gray_row;\n+      if (cinfo->in_color_space == JCS_GRAYSCALE)\n+\
    \        source->pub.get_pixel_rows = get_word_gray_row;\n+      else\n+     \
    \   ERREXIT(cinfo, JERR_BAD_IN_COLORSPACE);\n     } else if (maxval == MAXJSAMPLE\
    \ && sizeof(JSAMPLE) == sizeof(U_CHAR) &&\n                cinfo->in_color_space\
    \ == JCS_GRAYSCALE) {\n       source->pub.get_pixel_rows = get_raw_row;\n@@ -647,7\
    \ +658,10 @@ start_input_ppm(j_compress_ptr cinfo, cjpeg_source_ptr sinfo)\n \
    \      cinfo->in_color_space = JCS_EXT_RGB;\n     TRACEMS2(cinfo, 1, JTRC_PPM,\
    \ w, h);\n     if (maxval > 255) {\n-      source->pub.get_pixel_rows = get_word_rgb_row;\n\
    +      if (IsExtRGB(cinfo->in_color_space))\n+        source->pub.get_pixel_rows\
    \ = get_word_rgb_row;\n+      else\n+        ERREXIT(cinfo, JERR_BAD_IN_COLORSPACE);\n\
    \     } else if (maxval == MAXJSAMPLE && sizeof(JSAMPLE) == sizeof(U_CHAR) &&\n\
    \ #if RGB_RED == 0 && RGB_GREEN == 1 && RGB_BLUE == 2 && RGB_PIXELSIZE == 3\n\
    \                (cinfo->in_color_space == JCS_EXT_RGB ||"
  identifiers:
  - CVE-2021-46822
  - CWE-787
  overview: The PPM reader in libjpeg-turbo through 2.0.90 mishandles use of tjLoadImage
    for loading a 16-bit binary PPM file into a grayscale buffer and loading a 16-bit
    binary PGM file into an RGB buffer. This is related to a heap-based buffer overflow
    in the get_word_rgb_row function in rdppm.c.
  references:
  - source: cve@mitre.org
    tags:
    - Third Party Advisory
    - VDB Entry
    url: https://exchange.xforce.ibmcloud.com/vulnerabilities/221567
  - source: cve@mitre.org
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/libjpeg-turbo/libjpeg-turbo/commit/f35fd27ec641c42d6b115bfa595e483ec58188d2
  title: The PPM reader in libjpeg-turbo through 2.0.90 mishandles use of tjLoadImage
    for loading a 16-bit binary PPM file into a grayscale buffer and loading a 16-bit
    binary PGM file into an RGB buffer. This is related to a heap-based buffer overflow
    in the get_word_rgb_row function in rdppm.c.
- diff_content:
  - "--- a/drivers/block/floppy.c\n+++ b/drivers/block/floppy.c\n@@ -2982,6 +2982,8\
    \ @@ static const char *drive_name(int type, int drive)\n \t\treturn \"(null)\"\
    ;\n }\n \n+#ifdef CONFIG_BLK_DEV_FD_RAWCMD\n+\n /* raw commands */\n static void\
    \ raw_cmd_done(int flag)\n {\n@@ -3181,6 +3183,35 @@ static int raw_cmd_ioctl(int\
    \ cmd, void __user *param)\n \treturn ret;\n }\n \n+static int floppy_raw_cmd_ioctl(int\
    \ type, int drive, int cmd,\n+\t\t\t\tvoid __user *param)\n+{\n+\tint ret;\n+\n\
    +\tpr_warn_once(\"Note: FDRAWCMD is deprecated and will be removed from the kernel\
    \ in the near future.\\n\");\n+\n+\tif (type)\n+\t\treturn -EINVAL;\n+\tif (lock_fdc(drive))\n\
    +\t\treturn -EINTR;\n+\tset_floppy(drive);\n+\tret = raw_cmd_ioctl(cmd, param);\n\
    +\tif (ret == -EINTR)\n+\t\treturn -EINTR;\n+\tprocess_fd_request();\n+\treturn\
    \ ret;\n+}\n+\n+#else /* CONFIG_BLK_DEV_FD_RAWCMD */\n+\n+static int floppy_raw_cmd_ioctl(int\
    \ type, int drive, int cmd,\n+\t\t\t\tvoid __user *param)\n+{\n+\treturn -EOPNOTSUPP;\n\
    +}\n+\n+#endif\n+\n static int invalidate_drive(struct block_device *bdev)\n {\n\
    \ \t/* invalidate the buffer track to force a reread */\n@@ -3369,7 +3400,6 @@\
    \ static int fd_locked_ioctl(struct block_device *bdev, fmode_t mode, unsigned\
    \ int\n {\n \tint drive = (long)bdev->bd_disk->private_data;\n \tint type = ITYPE(drive_state[drive].fd_device);\n\
    -\tint i;\n \tint ret;\n \tint size;\n \tunion inparam {\n@@ -3520,16 +3550,7\
    \ @@ static int fd_locked_ioctl(struct block_device *bdev, fmode_t mode, unsigned\
    \ int\n \t\toutparam = &write_errors[drive];\n \t\tbreak;\n \tcase FDRAWCMD:\n\
    -\t\tif (type)\n-\t\t\treturn -EINVAL;\n-\t\tif (lock_fdc(drive))\n-\t\t\treturn\
    \ -EINTR;\n-\t\tset_floppy(drive);\n-\t\ti = raw_cmd_ioctl(cmd, (void __user *)param);\n\
    -\t\tif (i == -EINTR)\n-\t\t\treturn -EINTR;\n-\t\tprocess_fd_request();\n-\t\t\
    return i;\n+\t\treturn floppy_raw_cmd_ioctl(type, drive, cmd, (void __user *)param);\n\
    \ \tcase FDTWADDLE:\n \t\tif (lock_fdc(drive))\n \t\t\treturn -EINTR;"
  identifiers:
  - CVE-2022-33981
  - CWE-416
  overview: drivers/block/floppy.c in the Linux kernel before 5.17.6 is vulnerable
    to a denial of service, because of a concurrency use-after-free flaw after deallocating
    raw_cmd in the raw_cmd_ioctl function.
  references:
  - source: cve@mitre.org
    tags:
    - Release Notes
    - Vendor Advisory
    url: https://cdn.kernel.org/pub/linux/kernel/v5.x/ChangeLog-5.17.6
  - source: cve@mitre.org
    tags:
    - Third Party Advisory
    - VDB Entry
    url: https://exchange.xforce.ibmcloud.com/vulnerabilities/225362
  - source: cve@mitre.org
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/torvalds/linux/commit/233087ca063686964a53c829d547c7571e3f67bf
  - source: cve@mitre.org
    tags:
    - Mailing List
    - Third Party Advisory
    url: https://lists.debian.org/debian-lts-announce/2022/07/msg00000.html
  - source: cve@mitre.org
    tags:
    - Exploit
    - Mailing List
    - Patch
    - Third Party Advisory
    url: https://seclists.org/oss-sec/2022/q2/66
  - source: cve@mitre.org
    tags:
    - Third Party Advisory
    url: https://www.debian.org/security/2022/dsa-5173
  title: drivers/block/floppy.c in the Linux kernel before 5.17.6 is vulnerable to
    a denial of service, because of a concurrency use-after-free flaw after deallocating
    raw_cmd in the raw_cmd_ioctl function.
- diff_content:
  - "--- a/src/textobject.c\n+++ b/src/textobject.c\n@@ -1798,11 +1798,17 @@ current_quote(\n\
    \ \n \t// Find out if we have a quote in the selection.\n \twhile (i <= col_end)\n\
    +\t{\n+\t    // check for going over the end of the line, which can happen if\n\
    +\t    // the line was changed after the Visual area was selected.\n+\t    if\
    \ (line[i] == NUL)\n+\t\tbreak;\n \t    if (line[i++] == quotechar)\n \t    {\n\
    \ \t\tselected_quote = TRUE;\n \t\tbreak;\n \t    }\n+\t}\n     }\n \n     if\
    \ (!vis_empty && line[col_start] == quotechar)"
  - "--- a/src/version.c\n+++ b/src/version.c\n@@ -734,6 +734,8 @@ static char *(features[])\
    \ =\n \n static int included_patches[] =\n {   /* Add new patch number below this\
    \ line */\n+/**/\n+    5120,\n /**/\n     5119,\n /**/"
  identifiers:
  - CVE-2022-2124
  - CWE-126
  overview: Buffer Over-read in GitHub repository vim/vim prior to 8.2.
  references:
  - source: security@huntr.dev
    tags:
    - Mailing List
    - Third Party Advisory
    url: http://seclists.org/fulldisclosure/2022/Oct/28
  - source: security@huntr.dev
    tags:
    - Mailing List
    - Third Party Advisory
    url: http://seclists.org/fulldisclosure/2022/Oct/41
  - source: security@huntr.dev
    tags:
    - Mailing List
    - Third Party Advisory
    url: http://seclists.org/fulldisclosure/2022/Oct/43
  - source: security@huntr.dev
    tags:
    - Mailing List
    - Third Party Advisory
    url: http://seclists.org/fulldisclosure/2022/Oct/45
  - source: security@huntr.dev
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/vim/vim/commit/2f074f4685897ab7212e25931eeeb0212292829f
  - source: security@huntr.dev
    tags:
    - Exploit
    - Patch
    - Third Party Advisory
    url: https://huntr.dev/bounties/8e9e056d-f733-4540-98b6-414bf36e0b42
  - source: security@huntr.dev
    tags:
    - Mailing List
    - Third Party Advisory
    url: https://lists.debian.org/debian-lts-announce/2022/06/msg00014.html
  - source: security@huntr.dev
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/GFD2A4YLBR7OIRHTL7CK6YNMEIQ264CN/
  - source: security@huntr.dev
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/U743FMJGFQ35GBPCQ6OWMVZEJPDFVEWM/
  - source: security@huntr.dev
    tags:
    - Third Party Advisory
    url: https://security.gentoo.org/glsa/202208-32
  - source: security@huntr.dev
    tags:
    - Third Party Advisory
    url: https://security.gentoo.org/glsa/202305-16
  - source: security@huntr.dev
    tags:
    - Third Party Advisory
    url: https://support.apple.com/kb/HT213443
  - source: security@huntr.dev
    tags:
    - Third Party Advisory
    url: https://support.apple.com/kb/HT213444
  - source: security@huntr.dev
    tags:
    - Third Party Advisory
    url: https://support.apple.com/kb/HT213488
  title: Buffer Over-read in GitHub repository vim/vim prior to 8.2.
- diff_content:
  - "--- a/src/indent.c\n+++ b/src/indent.c\n@@ -2029,6 +2029,8 @@ get_lisp_indent(void)\n\
    \ \t\t\t    }\n \t\t\t}\n \t\t    }\n+\t\t    if (*that == NUL)\n+\t\t\tbreak;\n\
    \ \t\t}\n \t\tif (*that == '(' || *that == '[')\n \t\t    ++parencount;"
  - "--- a/src/version.c\n+++ b/src/version.c\n@@ -734,6 +734,8 @@ static char *(features[])\
    \ =\n \n static int included_patches[] =\n {   /* Add new patch number below this\
    \ line */\n+/**/\n+    5122,\n /**/\n     5121,\n /**/"
  identifiers:
  - CVE-2022-2125
  - CWE-122
  overview: Heap-based Buffer Overflow in GitHub repository vim/vim prior to 8.2.
  references:
  - source: security@huntr.dev
    tags:
    - Mailing List
    - Third Party Advisory
    url: http://seclists.org/fulldisclosure/2022/Oct/28
  - source: security@huntr.dev
    tags:
    - Mailing List
    - Third Party Advisory
    url: http://seclists.org/fulldisclosure/2022/Oct/41
  - source: security@huntr.dev
    tags:
    - Mailing List
    - Third Party Advisory
    url: http://seclists.org/fulldisclosure/2022/Oct/43
  - source: security@huntr.dev
    tags:
    - Mailing List
    - Third Party Advisory
    url: http://seclists.org/fulldisclosure/2022/Oct/45
  - source: security@huntr.dev
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/vim/vim/commit/0e8e938d497260dd57be67b4966cb27a5f72376f
  - source: security@huntr.dev
    tags:
    - Exploit
    - Patch
    - Third Party Advisory
    url: https://huntr.dev/bounties/17dab24d-beec-464d-9a72-5b6b11283705
  - source: security@huntr.dev
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/GFD2A4YLBR7OIRHTL7CK6YNMEIQ264CN/
  - source: security@huntr.dev
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/U743FMJGFQ35GBPCQ6OWMVZEJPDFVEWM/
  - source: security@huntr.dev
    tags:
    - Third Party Advisory
    url: https://security.gentoo.org/glsa/202208-32
  - source: security@huntr.dev
    url: https://security.gentoo.org/glsa/202305-16
  - source: security@huntr.dev
    tags:
    - Third Party Advisory
    url: https://support.apple.com/kb/HT213443
  - source: security@huntr.dev
    tags:
    - Third Party Advisory
    url: https://support.apple.com/kb/HT213444
  - source: security@huntr.dev
    tags:
    - Third Party Advisory
    url: https://support.apple.com/kb/HT213488
  title: Heap-based Buffer Overflow in GitHub repository vim/vim prior to 8.2.
- diff_content:
  - "--- a/src/spellsuggest.c\n+++ b/src/spellsuggest.c\n@@ -1973,7 +1973,8 @@ suggest_trie_walk(\n\
    \ \t\t\t    sp->ts_isdiff = (newscore != 0)\n \t\t\t\t\t\t       ? DIFF_YES :\
    \ DIFF_NONE;\n \t\t\t}\n-\t\t\telse if (sp->ts_isdiff == DIFF_INSERT)\n+\t\t\t\
    else if (sp->ts_isdiff == DIFF_INSERT\n+\t\t\t\t\t\t\t    && sp->ts_fidx > 0)\n\
    \ \t\t\t    // When inserting trail bytes don't advance in the\n \t\t\t    //\
    \ bad word.\n \t\t\t    --sp->ts_fidx;"
  - "--- a/src/version.c\n+++ b/src/version.c\n@@ -734,6 +734,8 @@ static char *(features[])\
    \ =\n \n static int included_patches[] =\n {   /* Add new patch number below this\
    \ line */\n+/**/\n+    5123,\n /**/\n     5122,\n /**/"
  identifiers:
  - CVE-2022-2126
  - CWE-125
  overview: Out-of-bounds Read in GitHub repository vim/vim prior to 8.2.
  references:
  - source: security@huntr.dev
    tags:
    - Mailing List
    - Third Party Advisory
    url: http://seclists.org/fulldisclosure/2022/Oct/28
  - source: security@huntr.dev
    tags:
    - Mailing List
    - Third Party Advisory
    url: http://seclists.org/fulldisclosure/2022/Oct/41
  - source: security@huntr.dev
    tags:
    - Mailing List
    - Third Party Advisory
    url: http://seclists.org/fulldisclosure/2022/Oct/43
  - source: security@huntr.dev
    tags:
    - Mailing List
    - Third Party Advisory
    url: http://seclists.org/fulldisclosure/2022/Oct/45
  - source: security@huntr.dev
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/vim/vim/commit/156d3911952d73b03d7420dc3540215247db0fe8
  - source: security@huntr.dev
    tags:
    - Exploit
    - Patch
    - Third Party Advisory
    url: https://huntr.dev/bounties/8d196d9b-3d10-41d2-9f70-8ef0d08c946e
  - source: security@huntr.dev
    tags:
    - Mailing List
    - Third Party Advisory
    url: https://lists.debian.org/debian-lts-announce/2022/06/msg00014.html
  - source: security@huntr.dev
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/GFD2A4YLBR7OIRHTL7CK6YNMEIQ264CN/
  - source: security@huntr.dev
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/U743FMJGFQ35GBPCQ6OWMVZEJPDFVEWM/
  - source: security@huntr.dev
    tags:
    - Third Party Advisory
    url: https://security.gentoo.org/glsa/202208-32
  - source: security@huntr.dev
    url: https://security.gentoo.org/glsa/202305-16
  - source: security@huntr.dev
    tags:
    - Third Party Advisory
    url: https://support.apple.com/kb/HT213443
  - source: security@huntr.dev
    tags:
    - Third Party Advisory
    url: https://support.apple.com/kb/HT213444
  - source: security@huntr.dev
    tags:
    - Third Party Advisory
    url: https://support.apple.com/kb/HT213488
  title: Out-of-bounds Read in GitHub repository vim/vim prior to 8.2.
- diff_content:
  - "--- a/src/ex_docmd.c\n+++ b/src/ex_docmd.c\n@@ -7138,9 +7138,10 @@ do_exedit(\n\
    \ #endif\n \t    )\n     {\n-\t// Can't edit another file when \"curbuf_lock\"\
    \ is set.  Only \":edit\"\n-\t// can bring us here, others are stopped earlier.\n\
    -\tif (*eap->arg != NUL && curbuf_locked())\n+\t// Can't edit another file when\
    \ \"textlock\" or \"curbuf_lock\" is set.\n+\t// Only \":edit\" or \":script\"\
    \ can bring us here, others are stopped\n+\t// earlier.\n+\tif (*eap->arg != NUL\
    \ && text_or_buf_locked())\n \t    return;\n \n \tn = readonlymode;"
  - "--- a/src/version.c\n+++ b/src/version.c\n@@ -734,6 +734,8 @@ static char *(features[])\
    \ =\n \n static int included_patches[] =\n {   /* Add new patch number below this\
    \ line */\n+/**/\n+    5126,\n /**/\n     5125,\n /**/"
  identifiers:
  - CVE-2022-2129
  - CWE-787
  overview: Out-of-bounds Write in GitHub repository vim/vim prior to 8.2.
  references:
  - source: security@huntr.dev
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/vim/vim/commit/d6211a52ab9f53b82f884561ed43d2fe4d24ff7d
  - source: security@huntr.dev
    tags:
    - Exploit
    - Patch
    - Third Party Advisory
    url: https://huntr.dev/bounties/3aaf06e7-9ae1-454d-b8ca-8709c98e5352
  - source: security@huntr.dev
    tags:
    - Mailing List
    - Third Party Advisory
    url: https://lists.debian.org/debian-lts-announce/2022/11/msg00032.html
  - source: security@huntr.dev
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/GFD2A4YLBR7OIRHTL7CK6YNMEIQ264CN/
  - source: security@huntr.dev
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/U743FMJGFQ35GBPCQ6OWMVZEJPDFVEWM/
  - source: security@huntr.dev
    tags:
    - Third Party Advisory
    url: https://security.gentoo.org/glsa/202208-32
  - source: security@huntr.dev
    url: https://security.gentoo.org/glsa/202305-16
  title: Out-of-bounds Write in GitHub repository vim/vim prior to 8.2.
- diff_content:
  - "--- a/src/normal.c\n+++ b/src/normal.c\n@@ -3671,9 +3671,16 @@ get_visual_text(\n\
    \ \t}\n \tif (**pp == NUL)\n \t    *lenp = 0;\n-\tif (has_mbyte && *lenp > 0)\n\
    -\t    // Correct the length to include all bytes of the last character.\n-\t\
    \    *lenp += (*mb_ptr2len)(*pp + (*lenp - 1)) - 1;\n+\tif (*lenp > 0)\n+\t{\n\
    +\t    if (has_mbyte)\n+\t\t// Correct the length to include all bytes of the\
    \ last\n+\t\t// character.\n+\t\t*lenp += (*mb_ptr2len)(*pp + (*lenp - 1)) - 1;\n\
    +\t    else if ((*pp)[*lenp - 1] == NUL)\n+\t\t// Do not include a trailing NUL.\n\
    +\t\t*lenp -= 1;\n+\t}\n     }\n     reset_VIsual_and_resel();\n     return OK;"
  - "--- a/src/version.c\n+++ b/src/version.c\n@@ -746,6 +746,8 @@ static char *(features[])\
    \ =\n \n static int included_patches[] =\n {   /* Add new patch number below this\
    \ line */\n+/**/\n+    4956,\n /**/\n     4955,\n /**/"
  identifiers:
  - CVE-2022-1720
  - CWE-126
  overview: Buffer Over-read in function grab_file_name in GitHub repository vim/vim
    prior to 8.2.4956. This vulnerability is capable of crashing the software, memory
    modification, and possible remote execution.
  references:
  - source: security@huntr.dev
    tags:
    - Mailing List
    - Third Party Advisory
    url: http://seclists.org/fulldisclosure/2022/Oct/28
  - source: security@huntr.dev
    tags:
    - Mailing List
    - Third Party Advisory
    url: http://seclists.org/fulldisclosure/2022/Oct/41
  - source: security@huntr.dev
    tags:
    - Mailing List
    - Third Party Advisory
    url: http://seclists.org/fulldisclosure/2022/Oct/43
  - source: security@huntr.dev
    tags:
    - Mailing List
    - Third Party Advisory
    url: http://seclists.org/fulldisclosure/2022/Oct/45
  - source: security@huntr.dev
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/vim/vim/commit/395bd1f6d3edc9f7edb5d1f2d7deaf5a9e3ab93c
  - source: security@huntr.dev
    tags:
    - Exploit
    - Patch
    - Third Party Advisory
    url: https://huntr.dev/bounties/5ccfb386-7eb9-46e5-98e5-243ea4b358a8
  - source: security@huntr.dev
    tags:
    - Mailing List
    - Third Party Advisory
    url: https://lists.debian.org/debian-lts-announce/2022/06/msg00014.html
  - source: security@huntr.dev
    tags:
    - Mailing List
    - Third Party Advisory
    url: https://lists.debian.org/debian-lts-announce/2022/11/msg00009.html
  - source: security@huntr.dev
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/GFD2A4YLBR7OIRHTL7CK6YNMEIQ264CN/
  - source: security@huntr.dev
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/U743FMJGFQ35GBPCQ6OWMVZEJPDFVEWM/
  - source: security@huntr.dev
    tags:
    - Third Party Advisory
    url: https://security.gentoo.org/glsa/202208-32
  - source: security@huntr.dev
    tags:
    - Third Party Advisory
    url: https://security.gentoo.org/glsa/202305-16
  - source: security@huntr.dev
    tags:
    - Third Party Advisory
    url: https://support.apple.com/kb/HT213443
  - source: security@huntr.dev
    tags:
    - Third Party Advisory
    url: https://support.apple.com/kb/HT213444
  - source: security@huntr.dev
    tags:
    - Third Party Advisory
    url: https://support.apple.com/kb/HT213488
  title: Buffer Over-read in function grab_file_name in GitHub repository vim/vim
    prior to 8.2.4956. This vulnerability is capable of crashing the software, memory
    modification, and possible remote execution.
- diff_content:
  - "--- a/src/njs_array.c\n+++ b/src/njs_array.c\n@@ -142,6 +142,10 @@ njs_array_convert_to_slow_array(njs_vm_t\
    \ *vm, njs_array_t *array)\n     njs_value_t        index, value;\n     njs_object_prop_t\
    \  *prop;\n \n+    if (njs_slow_path(!array->object.fast_array)) {\n+        return\
    \ NJS_OK;\n+    }\n+\n     njs_set_array(&value, array);\n     array->object.fast_array\
    \ = 0;\n "
  - "--- a/src/test/njs_unit_test.c\n+++ b/src/test/njs_unit_test.c\n@@ -13837,6 +13837,16\
    \ @@ static njs_unit_test_t  njs_test[] =\n               \"d.enumerable && d.writable\
    \ && d.configurable\"),\n       njs_str(\"true\") },\n \n+    { njs_str(\"const\
    \ arr = [1,2];\"\n+              \"function f(arg) {\"\n+              \"    \
    \    const desc = {get: arg};\"\n+              \"        Object.defineProperty(desc,\
    \ 'set', desc);\"\n+              \"        Object.defineProperty(arr, 1, desc);\"\
    \n+              \"}\"\n+              \"f(f);\"\n+              \"njs.dump(arr)\"\
    ),\n+      njs_str(\"[1,'[Getter]']\") },\n+\n     { njs_str(\"Object.defineProperties()\"\
    ),\n       njs_str(\"TypeError: Object.defineProperties is called on non-object\"\
    ) },\n "
  identifiers:
  - CVE-2022-31306
  - CWE-416
  overview: Nginx NJS v0.7.2 was discovered to contain a segmentation violation in
    the function njs_array_convert_to_slow_array at src/njs_array.c.
  references:
  - source: cve@mitre.org
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/nginx/njs/commit/81af26364c21c196dd21fb5e14c7fa9ce7debd17
  - source: cve@mitre.org
    tags:
    - Exploit
    - Issue Tracking
    - Third Party Advisory
    url: https://github.com/nginx/njs/issues/481
  title: Nginx NJS v0.7.2 was discovered to contain a segmentation violation in the
    function njs_array_convert_to_slow_array at src/njs_array.c.
- diff_content:
  - "--- a/src/njs_iterator.c\n+++ b/src/njs_iterator.c\n@@ -560,11 +560,14 @@ njs_object_iterate_reverse(njs_vm_t\
    \ *vm, njs_iterator_args_t *args,\n         } else {\n             /* UTF-8 string.\
    \ */\n \n-            p = njs_string_offset(string_prop.start, end, from);\n-\
    \            p = njs_utf8_next(p, end);\n-\n+            p = NULL;\n         \
    \    i = from + 1;\n \n+            if (i > to) {\n+                p = njs_string_offset(string_prop.start,\
    \ end, from);\n+                p = njs_utf8_next(p, end);\n+            }\n+\n\
    \             while (i-- > to) {\n                 pos = njs_utf8_prev(p);\n "
  - "--- a/src/test/njs_unit_test.c\n+++ b/src/test/njs_unit_test.c\n@@ -5103,6 +5103,9\
    \ @@ static njs_unit_test_t  njs_test[] =\n     { njs_str(\"Array.prototype.lastIndexOf.call({0:'undefined',\
    \ length:0}, 'undefined')\"),\n       njs_str(\"-1\") },\n \n+    { njs_str(\"\
    [1,0,-1,-2].map(v => Array.prototype.lastIndexOf.call('\u0424', '\u0424', v))\"\
    ),\n+      njs_str(\"0,0,0,-1\") },\n+\n     { njs_str(\"[''].lastIndexOf.call('00000000000000000000000000000\u0430\
    00')\"),\n       njs_str(\"-1\") },\n "
  identifiers:
  - CVE-2022-31307
  - CWE-416
  overview: Nginx NJS v0.7.2 was discovered to contain a segmentation violation in
    the function njs_string_offset at src/njs_string.c.
  references:
  - source: cve@mitre.org
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/nginx/njs/commit/eafe4c7a326b163612f10861392622b5da5b1792
  - source: cve@mitre.org
    tags:
    - Exploit
    - Issue Tracking
    - Third Party Advisory
    url: https://github.com/nginx/njs/issues/482
  title: Nginx NJS v0.7.2 was discovered to contain a segmentation violation in the
    function njs_string_offset at src/njs_string.c.
- diff_content:
  - "--- a/src/njs_promise.c\n+++ b/src/njs_promise.c\n@@ -1369,6 +1369,10 @@ njs_promise_perform_all_handler(njs_vm_t\
    \ *vm, njs_iterator_args_t *args,\n     njs_promise_all_context_t    *context;\n\
    \     njs_promise_iterator_args_t  *pargs;\n \n+    if (!njs_is_valid(value))\
    \ {\n+        value = njs_value_arg(&njs_value_undefined);\n+    }\n+\n     pargs\
    \ = (njs_promise_iterator_args_t *) args;\n \n     capability = pargs->capability;\n\
    @@ -1459,6 +1463,10 @@ njs_promise_perform_all_settled_handler(njs_vm_t *vm, njs_iterator_args_t\
    \ *args,\n     njs_promise_all_context_t    *context;\n     njs_promise_iterator_args_t\
    \  *pargs;\n \n+    if (!njs_is_valid(value)) {\n+        value = njs_value_arg(&njs_value_undefined);\n\
    +    }\n+\n     pargs = (njs_promise_iterator_args_t *) args;\n \n     capability\
    \ = pargs->capability;\n@@ -1598,6 +1606,10 @@ njs_promise_perform_any_handler(njs_vm_t\
    \ *vm, njs_iterator_args_t *args,\n     njs_promise_all_context_t    *context;\n\
    \     njs_promise_iterator_args_t  *pargs;\n \n+    if (!njs_is_valid(value))\
    \ {\n+        value = njs_value_arg(&njs_value_undefined);\n+    }\n+\n     pargs\
    \ = (njs_promise_iterator_args_t *) args;\n \n     capability = pargs->capability;\n\
    @@ -1745,6 +1757,10 @@ njs_promise_perform_race_handler(njs_vm_t *vm, njs_iterator_args_t\
    \ *args,\n     njs_promise_capability_t     *capability;\n     njs_promise_iterator_args_t\
    \  *pargs;\n \n+    if (!njs_is_valid(value)) {\n+        value = njs_value_arg(&njs_value_undefined);\n\
    +    }\n+\n     pargs = (njs_promise_iterator_args_t *) args;\n \n     ret = njs_function_call(vm,\
    \ pargs->function, pargs->constructor, value,"
  - "--- a/src/test/njs_unit_test.c\n+++ b/src/test/njs_unit_test.c\n@@ -21149,6 +21149,13\
    \ @@ static njs_unit_test_t  njs_externals_test[] =\n               \"}))\"\n\
    \               \".then(v => $r.retval(v))\"),\n       njs_str(\"a:async:pr:async2:pr:r,b:async:pr:async2:pr:r,c:async:pr:async2:pr:r\"\
    ) },\n+\n+    { njs_str(\"async function f () {\"\n+              \"    var p\
    \ = await Promise.race({length:1});\"\n+              \"    for (const v in 'test')\
    \ { }\"\n+              \"};\"\n+              \"f().then(v => $r.retval('done'))\"\
    ),\n+      njs_str(\"done\") },\n };\n \n "
  identifiers:
  - CVE-2022-32414
  - CWE-416
  overview: Nginx NJS v0.7.2 was discovered to contain a segmentation violation in
    the function njs_vmcode_interpreter at src/njs_vmcode.c.
  references:
  - source: cve@mitre.org
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/nginx/njs/commit/31ed93a5623f24ca94e6d47e895ba735d9d97d46
  - source: cve@mitre.org
    tags:
    - Exploit
    - Issue Tracking
    - Third Party Advisory
    url: https://github.com/nginx/njs/issues/483
  title: Nginx NJS v0.7.2 was discovered to contain a segmentation violation in the
    function njs_vmcode_interpreter at src/njs_vmcode.c.
- diff_content:
  - "--- a/src/ex_getln.c\n+++ b/src/ex_getln.c\n@@ -1206,6 +1206,7 @@ cmdline_insert_reg(int\
    \ *gotesc UNUSED)\n {\n     int\t\ti;\n     int\t\tc;\n+    int\t\tsave_new_cmdpos\
    \ = new_cmdpos;\n \n #ifdef USE_ON_FLY_SCROLL\n     dont_scroll = TRUE;\t// disallow\
    \ scrolling here\n@@ -1224,8 +1225,6 @@ cmdline_insert_reg(int *gotesc UNUSED)\n\
    \ #ifdef FEAT_EVAL\n     /*\n      * Insert the result of an expression.\n-  \
    \   * Need to save the current command line, to be able to enter\n-     * a new\
    \ one...\n      */\n     new_cmdpos = -1;\n     if (c == '=')\n@@ -1266,6 +1265,8\
    \ @@ cmdline_insert_reg(int *gotesc UNUSED)\n \t}\n #endif\n     }\n+    new_cmdpos\
    \ = save_new_cmdpos;\n+\n     // remove the double quote\n     redrawcmd();\n "
  - "--- a/src/version.c\n+++ b/src/version.c\n@@ -734,6 +734,8 @@ static char *(features[])\
    \ =\n \n static int included_patches[] =\n {   /* Add new patch number below this\
    \ line */\n+/**/\n+    5148,\n /**/\n     5147,\n /**/"
  identifiers:
  - CVE-2022-2175
  - CWE-125
  overview: Buffer Over-read in GitHub repository vim/vim prior to 8.2.
  references:
  - source: security@huntr.dev
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/vim/vim/commit/6046aded8da002b08d380db29de2ba0268b6616e
  - source: security@huntr.dev
    tags:
    - Exploit
    - Patch
    - Third Party Advisory
    url: https://huntr.dev/bounties/7f0481c2-8b57-4324-b47c-795d1ea67e55
  - source: security@huntr.dev
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/GFD2A4YLBR7OIRHTL7CK6YNMEIQ264CN/
  - source: security@huntr.dev
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/U743FMJGFQ35GBPCQ6OWMVZEJPDFVEWM/
  - source: security@huntr.dev
    tags:
    - Third Party Advisory
    url: https://security.gentoo.org/glsa/202208-32
  - source: security@huntr.dev
    tags:
    - Third Party Advisory
    url: https://security.gentoo.org/glsa/202305-16
  title: Buffer Over-read in GitHub repository vim/vim prior to 8.2.
- diff_content:
  - "--- a/src/t_stream.c\n+++ b/src/t_stream.c\n@@ -401,7 +401,7 @@ void streamGetEdgeID(stream\
    \ *s, int first, int skip_tombstones, streamID *edge_i\n         streamID min_id\
    \ = {0, 0}, max_id = {UINT64_MAX, UINT64_MAX};\n         *edge_id = first ? max_id\
    \ : min_id;\n     }\n-\n+    streamIteratorStop(&si);\n }\n \n /* Adds a new item\
    \ into the stream 's' having the specified number of"
  identifiers:
  - CVE-2022-33105
  - CWE-401
  overview: Redis v7.0 was discovered to contain a memory leak via the component streamGetEdgeID.
  references:
  - source: cve@mitre.org
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/redis/redis/commit/4a7a4e42db8ff757cdf3f4a824f66426036034ef
  - source: cve@mitre.org
    tags:
    - Exploit
    - Issue Tracking
    - Patch
    - Third Party Advisory
    url: https://github.com/redis/redis/pull/10753
  - source: cve@mitre.org
    tags:
    - Exploit
    - Issue Tracking
    - Release Notes
    - Third Party Advisory
    url: https://github.com/redis/redis/pull/10829
  - source: cve@mitre.org
    tags:
    - Release Notes
    - Third Party Advisory
    url: https://raw.githubusercontent.com/redis/redis/7.0.1/00-RELEASENOTES
  - source: cve@mitre.org
    tags:
    - Third Party Advisory
    url: https://security.gentoo.org/glsa/202209-17
  - source: cve@mitre.org
    tags:
    - Third Party Advisory
    url: https://security.netapp.com/advisory/ntap-20220729-0005/
  title: Redis v7.0 was discovered to contain a memory leak via the component streamGetEdgeID.
- diff_content:
  - "--- a/ne_mesg.c\n+++ b/ne_mesg.c\n@@ -5,6 +5,7 @@\n  *\n  * Author: Feike W.\
    \ Dillema, feico@dillema.net.\n  *         based on newbie code by Yusuke DOI,\
    \ Keio Univ. Murai Lab.\n+ * Modified by: Gabor Lencse, see details below\n  ****************************************************************************/\n\
    \ \n /*\n@@ -18,19 +19,62 @@ static int dname_copy (u_char *, u_char *, int);\n\
    \ static u_char *dname_redirect (u_char *, u_char *);\n static u_char *mesg_read_sec\
    \ (G_List *, u_char *, int, u_char *, int);\n \n-uint16_t mesg_id (void) {\n-\t\
    static uint16_t id = 0;\n-\n-\tif (!id) {\n-\t\tsrandom (time (NULL));\n-\t\t\
    id = random ();\n-\t}\n-\tid++;\n+/* Modifications made by Gabor Lencse, lencse@sze.hu\
    \ for adding random Transaction IDs */\n+/* For more details, see our paper (currently\
    \ under review): */\n+/* G. Lencse and S. Repas, \"Improving the Performance and\
    \ Security of the TOTD DNS64 Implementation\" */\n+/* http://www.hit.bme.hu/~lencse/publications/Improving-TOTD-for-review.pdf\
    \ */ \n+\n+#define ARRAY_SIZE 0x8000\t/* Size of the static array storing permutations\
    \ */\n+#define NUM_USE 0x4000\t\t/* Number of elements used up from the array\
    \ of permutations */\n+#define LOW_START 0x0000\t/* Starting value of the lower\
    \ range */\n+#define HIGH_START 0x8000\t/* Starting value of the higher range\
    \ */\n+\n+static uint16_t permutation[ARRAY_SIZE]; /* The static array for storing\
    \ random permutations */\n+\n+/* Prepare a random permutation of the integers\
    \ [start, start + ARRAY_SIZE - 1] into the static array */\n+/* Algorithm: http://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle#The_.22inside-out.22_algorithm\
    \ */\n+void make_random_permutation(int start) {\n+        int i, j;\n+\n+   \
    \     permutation[0] = start;\t\n+        for (i = 1; i < ARRAY_SIZE; i++) {\n\
    +                j = random() * (double)(i + 1) / RAND_MAX; /* random number from\
    \ the range [0, i] */\n+                if (j != i) { \n+                  permutation[i]\
    \ = permutation[j];\n+                }\n+                permutation[j] = start\
    \ + i;\n+        }\n+}\n \n-\tif (T.debug > 4)\n-\t\tsyslog (LOG_DEBUG, \"mesg_id()\
    \ = %d\", id);\n-\treturn id;\n+/* Provide hard to predict unique random DNS Transaction\
    \ IDs */\n+/* by using random permutations and alternating ranges */\n+uint16_t\
    \ mesg_id (void) {\n+        static int range = 0; /* indicates that no permutation\
    \ has been generated yet */\n+        static int index;\n+\n+        if (!range)\
    \ {\n+                srandom(time(0)); \t/* initialize random number generator\
    \ seed */\n+                range = 1;\t\t/* choose the lower range first */\n\
    +                make_random_permutation(LOW_START);\n+                index =\
    \ 0;\t\t/* start from the first element */\n+        }\n+        if ( index ==\
    \ NUM_USE ) {\t/* if the pool is exhasuted */\n+                if (range == 1)\
    \ {\n+                        range = 2;\t/* choose the higher range */\n+   \
    \                     make_random_permutation(HIGH_START);\n+                }\n\
    +                else {\n+                        range = 1;\t/* choose the lower\
    \ range */\n+                        make_random_permutation(LOW_START);\n+  \
    \              }\n+                index = 0;\n+        }\n+\tif (T.debug > 4)\
    \ { \n+\t\tsyslog (LOG_DEBUG, \"mesg_id() = %d\", permutation[index]);\n+    \
    \    }\n+        return permutation[index++];\n }\n+/* End of modifications by\
    \ Gabor Lencse */\n \n int mesg_make_query (u_char *qname, uint16_t qtype, uint16_t\
    \ qclass,\n \t\t     uint32_t id, int rd, u_char *buf, int buflen) {\n@@ -39,10\
    \ +83,10 @@ int mesg_make_query (u_char *qname, uint16_t qtype, uint16_t qclass,\n\
    \ \tint i, written_len;\n \tMesg_Hdr *hdr;\n \n-\tif (T.debug > 4)\n+\tif (T.debug\
    \ > 4) { \n \t\tsyslog (LOG_DEBUG, \"%s: (qtype: %s, id: %d): start\", fn,\n \t\
    \t\tstring_rtype (qtype), id);\n-\n+        }\n \thdr = (Mesg_Hdr *) buf;\n \n\
    \ \t/* write header */"
  - "--- a/read_config.c\n+++ b/read_config.c\n@@ -125,7 +125,8 @@ int read_config\
    \ (char *config_file) {\n \t\t\t\terrcnt++;\n \t\t\t}\n \n-\t\t\tfor (i = 0; T.iflist[i]\
    \ && i < MAXINTERFACES; i++);\n+\t\t\tfor (i = 0; T.iflist[i] && i < MAXINTERFACES;\
    \ i++) { \n+                        };\n \n \t\t \tif (i + argcnt-1 > MAXINTERFACES)\
    \ {\n \t\t\t\tsyslog (LOG_ERR, \"line %d: to many interfaces, more than %d\",\
    \ linenum, MAXINTERFACES);"
  identifiers:
  - CVE-2022-34295
  - CWE-330
  overview: totd before 1.5.3 does not properly randomize mesg IDs.
  references:
  - source: cve@mitre.org
    tags:
    - Exploit
    - Technical Description
    - Third Party Advisory
    url: http://www.hit.bme.hu/~lencse/publications/JCST-Apr14-2.pdf
  - source: cve@mitre.org
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/fwdillema/totd/commit/afd8a10a6a21f82a70940d1b43cff48143250399
  - source: cve@mitre.org
    tags:
    - Patch
    - Release Notes
    - Third Party Advisory
    url: https://github.com/fwdillema/totd/releases/tag/1.5.3
  - source: cve@mitre.org
    tags:
    - Vendor Advisory
    url: https://www.usenix.org/conference/usenixsecurity22/presentation/jeitner
  title: totd before 1.5.3 does not properly randomize mesg IDs.
- diff_content:
  - "--- a/src/lib/libdwarf/dwarf_form.c\n+++ b/src/lib/libdwarf/dwarf_form.c\n@@\
    \ -837,6 +836,13 @@ dwarf_global_formref_b(Dwarf_Attribute attr,\n         Dwarf_Bool\
    \ t_is_info = TRUE;\n         Dwarf_Unsigned t_offset = 0;\n \n+        if ((attr->ar_debug_ptr\
    \ + sizeof(Dwarf_Sig8)) > section_end) {\n+            _dwarf_error_string(dbg,\
    \ error,\n+                DW_DLE_REF_SIG8_NOT_HANDLED,\n+                \"DW_DLE_REF_SIG8_NOT_HANDLED:\
    \ \"\n+                \" Dwarf_Sig8 content runs off the end of its section\"\
    );\n+            return DW_DLV_ERROR;\n+        }\n         memcpy(&sig8,attr->ar_debug_ptr,sizeof(Dwarf_Sig8));\n\
    \         res = find_sig8_target_as_global_offset(attr,\n             &sig8,&t_is_info,&t_offset,error);"
  identifiers:
  - CVE-2022-34299
  - CWE-125
  overview: There is a heap-based buffer over-read in libdwarf 0.4.0. This issue is
    related to dwarf_global_formref_b.
  references:
  - source: cve@mitre.org
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/davea42/libdwarf-code/commit/7ef09e1fc9ba07653dd078edb2408631c7969162
  - source: cve@mitre.org
    tags:
    - Exploit
    - Issue Tracking
    - Third Party Advisory
    url: https://github.com/davea42/libdwarf-code/issues/119
  title: There is a heap-based buffer over-read in libdwarf 0.4.0. This issue is related
    to dwarf_global_formref_b.
- diff_content:
  - "--- a/src/ex_docmd.c\n+++ b/src/ex_docmd.c\n@@ -3411,10 +3411,13 @@ parse_cmd_address(exarg_T\
    \ *eap, char **errormsg, int silent)\n \t\tcurwin->w_cursor.lnum = eap->line2;\n\
    \ \n \t\t// Don't leave the cursor on an illegal line or column, but do\n-\t\t\
    // accept zero as address, so 0;/PATTERN/ works correctly.\n+\t\t// accept zero\
    \ as address, so 0;/PATTERN/ works correctly\n+\t\t// (where zero usually means\
    \ to use the first line).\n \t\t// Check the cursor position before returning.\n\
    \ \t\tif (eap->line2 > 0)\n \t\t    check_cursor();\n+\t\telse\n+\t\t    check_cursor_col();\n\
    \ \t\tneed_check_cursor = TRUE;\n \t    }\n \t}"
  - "--- a/src/version.c\n+++ b/src/version.c\n@@ -734,6 +734,8 @@ static char *(features[])\
    \ =\n \n static int included_patches[] =\n {   /* Add new patch number below this\
    \ line */\n+/**/\n+    5150,\n /**/\n     5149,\n /**/"
  identifiers:
  - CVE-2022-2182
  - CWE-122
  overview: Heap-based Buffer Overflow in GitHub repository vim/vim prior to 8.2.
  references:
  - source: security@huntr.dev
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/vim/vim/commit/f7c7c3fad6d2135d558f3b36d0d1a943118aeb5e
  - source: security@huntr.dev
    tags:
    - Exploit
    - Patch
    - Third Party Advisory
    url: https://huntr.dev/bounties/238d8650-3beb-4831-a8f7-6f0b597a6fb8
  - source: security@huntr.dev
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/GFD2A4YLBR7OIRHTL7CK6YNMEIQ264CN/
  - source: security@huntr.dev
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/U743FMJGFQ35GBPCQ6OWMVZEJPDFVEWM/
  - source: security@huntr.dev
    tags:
    - Third Party Advisory
    url: https://security.gentoo.org/glsa/202208-32
  - source: security@huntr.dev
    url: https://security.gentoo.org/glsa/202305-16
  title: Heap-based Buffer Overflow in GitHub repository vim/vim prior to 8.2.
- diff_content:
  - "--- a/src/indent.c\n+++ b/src/indent.c\n@@ -2076,8 +2076,11 @@ get_lisp_indent(void)\n\
    \ \t\t    amount += 2;\n \t\telse\n \t\t{\n-\t\t    that++;\n-\t\t    amount++;\n\
    +\t\t    if (*that != NUL)\n+\t\t    {\n+\t\t\tthat++;\n+\t\t\tamount++;\n+\t\t\
    \    }\n \t\t    firsttry = amount;\n \n \t\t    while (VIM_ISWHITE(*that))"
  - "--- a/src/version.c\n+++ b/src/version.c\n@@ -734,6 +734,8 @@ static char *(features[])\
    \ =\n \n static int included_patches[] =\n {   /* Add new patch number below this\
    \ line */\n+/**/\n+    5151,\n /**/\n     5150,\n /**/"
  identifiers:
  - CVE-2022-2183
  - CWE-125
  overview: Out-of-bounds Read in GitHub repository vim/vim prior to 8.2.
  references:
  - source: security@huntr.dev
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/vim/vim/commit/8eba2bd291b347e3008aa9e565652d51ad638cfa
  - source: security@huntr.dev
    tags:
    - Exploit
    - Patch
    - Third Party Advisory
    url: https://huntr.dev/bounties/d74ca3f9-380d-4c0a-b61c-11113cc98975
  - source: security@huntr.dev
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/GFD2A4YLBR7OIRHTL7CK6YNMEIQ264CN/
  - source: security@huntr.dev
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/U743FMJGFQ35GBPCQ6OWMVZEJPDFVEWM/
  - source: security@huntr.dev
    tags:
    - Third Party Advisory
    url: https://security.gentoo.org/glsa/202208-32
  - source: security@huntr.dev
    url: https://security.gentoo.org/glsa/202305-16
  title: Out-of-bounds Read in GitHub repository vim/vim prior to 8.2.
- diff_content:
  - "--- a/drivers/rpmsg/virtio_rpmsg_bus.c\n+++ b/drivers/rpmsg/virtio_rpmsg_bus.c\n\
    @@ -851,7 +851,7 @@ static struct rpmsg_device *rpmsg_virtio_add_ctrl_dev(struct\
    \ virtio_device *vdev\n \n \terr = rpmsg_ctrldev_register_device(rpdev_ctrl);\n\
    \ \tif (err) {\n-\t\tkfree(vch);\n+\t\t/* vch will be free in virtio_rpmsg_release_device()\
    \ */\n \t\treturn ERR_PTR(err);\n \t}\n "
  identifiers:
  - CVE-2022-34494
  - CWE-415
  overview: rpmsg_virtio_add_ctrl_dev in drivers/rpmsg/virtio_rpmsg_bus.c in the Linux
    kernel before 5.18.4 has a double free.
  references:
  - source: cve@mitre.org
    tags:
    - Patch
    - Vendor Advisory
    url: https://cdn.kernel.org/pub/linux/kernel/v5.x/ChangeLog-5.18.4
  - source: cve@mitre.org
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/torvalds/linux/commit/1680939e9ecf7764fba8689cfb3429c2fe2bb23c
  title: rpmsg_virtio_add_ctrl_dev in drivers/rpmsg/virtio_rpmsg_bus.c in the Linux
    kernel before 5.18.4 has a double free.
- diff_content:
  - "--- a/drivers/rpmsg/virtio_rpmsg_bus.c\n+++ b/drivers/rpmsg/virtio_rpmsg_bus.c\n\
    @@ -973,7 +973,8 @@ static int rpmsg_probe(struct virtio_device *vdev)\n \n \t\
    \terr = rpmsg_ns_register_device(rpdev_ns);\n \t\tif (err)\n-\t\t\tgoto free_vch;\n\
    +\t\t\t/* vch will be free in virtio_rpmsg_release_device() */\n+\t\t\tgoto free_ctrldev;\n\
    \ \t}\n \n \t/*\n@@ -997,8 +998,6 @@ static int rpmsg_probe(struct virtio_device\
    \ *vdev)\n \n \treturn 0;\n \n-free_vch:\n-\tkfree(vch);\n free_ctrldev:\n \t\
    rpmsg_virtio_del_ctrl_dev(rpdev_ctrl);\n free_coherent:"
  identifiers:
  - CVE-2022-34495
  - CWE-415
  overview: rpmsg_probe in drivers/rpmsg/virtio_rpmsg_bus.c in the Linux kernel before
    5.18.4 has a double free.
  references:
  - source: cve@mitre.org
    tags:
    - Patch
    - Release Notes
    - Vendor Advisory
    url: https://cdn.kernel.org/pub/linux/kernel/v5.x/ChangeLog-5.18.4
  - source: cve@mitre.org
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/torvalds/linux/commit/c2eecefec5df1306eafce28ccdf1ca159a552ecc
  title: rpmsg_probe in drivers/rpmsg/virtio_rpmsg_bus.c in the Linux kernel before
    5.18.4 has a double free.
- diff_content:
  - "--- a/src/term.c\n+++ b/src/term.c\n@@ -3366,6 +3366,12 @@ check_shellsize(void)\n\
    \     if (Rows < min_rows())\t// need room for one window and command line\n \t\
    Rows = min_rows();\n     limit_screen_size();\n+\n+    // make sure these values\
    \ are not invalid\n+    if (cmdline_row >= Rows)\n+\tcmdline_row = Rows - 1;\n\
    +    if (msg_row >= Rows)\n+\tmsg_row = Rows - 1;\n }\n \n /*"
  - "--- a/src/version.c\n+++ b/src/version.c\n@@ -735,6 +735,8 @@ static char *(features[])\
    \ =\n \n static int included_patches[] =\n {   /* Add new patch number below this\
    \ line */\n+/**/\n+    5160,\n /**/\n     5159,\n /**/"
  identifiers:
  - CVE-2022-2206
  - CWE-125
  overview: Out-of-bounds Read in GitHub repository vim/vim prior to 8.2.
  references:
  - source: security@huntr.dev
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/vim/vim/commit/e178af5a586ea023622d460779fdcabbbfac0908
  - source: security@huntr.dev
    tags:
    - Exploit
    - Patch
    - Third Party Advisory
    url: https://huntr.dev/bounties/01d01e74-55d0-4d9e-878e-79ba599be668
  - source: security@huntr.dev
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/GFD2A4YLBR7OIRHTL7CK6YNMEIQ264CN/
  - source: security@huntr.dev
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/U743FMJGFQ35GBPCQ6OWMVZEJPDFVEWM/
  - source: security@huntr.dev
    tags:
    - Third Party Advisory
    url: https://security.gentoo.org/glsa/202208-32
  - source: security@huntr.dev
    url: https://security.gentoo.org/glsa/202305-16
  title: Out-of-bounds Read in GitHub repository vim/vim prior to 8.2.
- diff_content:
  - "--- a/src/edit.c\n+++ b/src/edit.c\n@@ -4183,7 +4183,7 @@ ins_bs(\n #endif\n\
    \ \n \t    // delete characters until we are at or before want_vcol\n-\t    while\
    \ (vcol > want_vcol\n+\t    while (vcol > want_vcol && curwin->w_cursor.col >\
    \ 0\n \t\t    && (cc = *(ml_get_cursor() - 1), VIM_ISWHITE(cc)))\n \t\tins_bs_one(&vcol);\n\
    \ "
  - "--- a/src/version.c\n+++ b/src/version.c\n@@ -735,6 +735,8 @@ static char *(features[])\
    \ =\n \n static int included_patches[] =\n {   /* Add new patch number below this\
    \ line */\n+/**/\n+    5162,\n /**/\n     5161,\n /**/"
  identifiers:
  - CVE-2022-2207
  - CWE-122
  overview: Heap-based Buffer Overflow in GitHub repository vim/vim prior to 8.2.
  references:
  - source: security@huntr.dev
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/vim/vim/commit/0971c7a4e537ea120a6bb2195960be8d0815e97b
  - source: security@huntr.dev
    tags:
    - Exploit
    - Patch
    - Third Party Advisory
    url: https://huntr.dev/bounties/05bc6051-4dc3-483b-ae56-cf23346b97b9
  - source: security@huntr.dev
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/GFD2A4YLBR7OIRHTL7CK6YNMEIQ264CN/
  - source: security@huntr.dev
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/U743FMJGFQ35GBPCQ6OWMVZEJPDFVEWM/
  - source: security@huntr.dev
    tags:
    - Third Party Advisory
    url: https://security.gentoo.org/glsa/202208-32
  - source: security@huntr.dev
    url: https://security.gentoo.org/glsa/202305-16
  title: Heap-based Buffer Overflow in GitHub repository vim/vim prior to 8.2.
- diff_content:
  - "--- a/src/diff.c\n+++ b/src/diff.c\n@@ -119,7 +119,12 @@ diff_buf_delete(buf_T\
    \ *buf)\n \t    tp->tp_diffbuf[i] = NULL;\n \t    tp->tp_diff_invalid = TRUE;\n\
    \ \t    if (tp == curtab)\n-\t\tdiff_redraw(TRUE);\n+\t    {\n+\t\t// don't redraw\
    \ right away, more might change or buffer state\n+\t\t// is invalid right now\n\
    +\t\tneed_diff_redraw = TRUE;\n+\t\tredraw_later(VALID);\n+\t    }\n \t}\n   \
    \  }\n }\n@@ -670,7 +675,8 @@ diff_redraw(\n \n     need_diff_redraw = FALSE;\n\
    \     FOR_ALL_WINDOWS(wp)\n-\tif (wp->w_p_diff)\n+\t// when closing windows or\
    \ wiping buffers skip invalid window\n+\tif (wp->w_p_diff && buf_valid(wp->w_buffer))\n\
    \ \t{\n \t    redraw_win_later(wp, SOME_VALID);\n \t    if (wp != curwin)"
  - "--- a/src/version.c\n+++ b/src/version.c\n@@ -735,6 +735,8 @@ static char *(features[])\
    \ =\n \n static int included_patches[] =\n {   /* Add new patch number below this\
    \ line */\n+/**/\n+    5163,\n /**/\n     5162,\n /**/"
  identifiers:
  - CVE-2022-2208
  - CWE-476
  overview: NULL Pointer Dereference in GitHub repository vim/vim prior to 8.2.5163.
  references:
  - source: security@huntr.dev
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/vim/vim/commit/cd38bb4d83c942c4bad596835c6766cbf32e5195
  - source: security@huntr.dev
    tags:
    - Exploit
    - Patch
    - Third Party Advisory
    url: https://huntr.dev/bounties/7bfe3d5b-568f-4c34-908f-a39909638cc1
  - source: security@huntr.dev
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/GFD2A4YLBR7OIRHTL7CK6YNMEIQ264CN/
  - source: security@huntr.dev
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/U743FMJGFQ35GBPCQ6OWMVZEJPDFVEWM/
  - source: security@huntr.dev
    tags:
    - Third Party Advisory
    url: https://security.gentoo.org/glsa/202208-32
  - source: security@huntr.dev
    url: https://security.gentoo.org/glsa/202305-16
  title: NULL Pointer Dereference in GitHub repository vim/vim prior to 8.2.5163.
- diff_content:
  - "--- a/src/diff.c\n+++ b/src/diff.c\n@@ -403,9 +403,9 @@ diff_mark_adjust_tp(\n\
    \ \t\t// 2. 3. 4. 5.: inserted/deleted lines touching this diff.\n \t\tif (deleted\
    \ > 0)\n \t\t{\n+\t\t    off = 0;\n \t\t    if (dp->df_lnum[idx] >= line1)\n \t\
    \t    {\n-\t\t\toff = dp->df_lnum[idx] - lnum_deleted;\n \t\t\tif (last <= line2)\n\
    \ \t\t\t{\n \t\t\t    // 4. delete all lines of diff\n@@ -426,6 +426,7 @@ diff_mark_adjust_tp(\n\
    \ \t\t\telse\n \t\t\t{\n \t\t\t    // 5. delete lines at or just before top of\
    \ diff\n+\t\t\t    off = dp->df_lnum[idx] - lnum_deleted;\n \t\t\t    n = off;\n\
    \ \t\t\t    dp->df_count[idx] -= line2 - dp->df_lnum[idx] + 1;\n \t\t\t    check_unchanged\
    \ = TRUE;\n@@ -434,7 +435,6 @@ diff_mark_adjust_tp(\n \t\t    }\n \t\t    else\n\
    \ \t\t    {\n-\t\t\toff = 0;\n \t\t\tif (last < line2)\n \t\t\t{\n \t\t\t    //\
    \ 2. delete at end of diff"
  - "--- a/src/version.c\n+++ b/src/version.c\n@@ -735,6 +735,8 @@ static char *(features[])\
    \ =\n \n static int included_patches[] =\n {   /* Add new patch number below this\
    \ line */\n+/**/\n+    5164,\n /**/\n     5163,\n /**/"
  identifiers:
  - CVE-2022-2210
  - CWE-787
  overview: Out-of-bounds Write in GitHub repository vim/vim prior to 8.2.
  references:
  - source: security@huntr.dev
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/vim/vim/commit/c101abff4c6756db4f5e740fde289decb9452efa
  - source: security@huntr.dev
    tags:
    - Exploit
    - Patch
    - Third Party Advisory
    url: https://huntr.dev/bounties/020845f8-f047-4072-af0f-3726fe1aea25
  - source: security@huntr.dev
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/GFD2A4YLBR7OIRHTL7CK6YNMEIQ264CN/
  - source: security@huntr.dev
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/U743FMJGFQ35GBPCQ6OWMVZEJPDFVEWM/
  - source: security@huntr.dev
    tags:
    - Third Party Advisory
    url: https://security.gentoo.org/glsa/202208-32
  - source: security@huntr.dev
    url: https://security.gentoo.org/glsa/202305-16
  title: Out-of-bounds Write in GitHub repository vim/vim prior to 8.2.
- diff_content:
  - "--- a/src/eval.c\n+++ b/src/eval.c\n@@ -2387,27 +2387,32 @@ eval0_retarg(\n \n\
    \     p = skipwhite(arg);\n     ret = eval1(&p, rettv, evalarg);\n-    expr_end\
    \ = p;\n-    p = skipwhite(p);\n \n-    // In Vim9 script a command block is not\
    \ split at NL characters for\n-    // commands using an expression argument. \
    \ Skip over a '#' comment to check\n-    // for a following NL.  Require white\
    \ space before the '#'.\n-    if (in_vim9script() && p > expr_end && retarg ==\
    \ NULL)\n-\twhile (*p == '#')\n-\t{\n-\t    char_u *nl = vim_strchr(p, NL);\n\
    +    if (ret != FAIL)\n+    {\n+\texpr_end = p;\n+\tp = skipwhite(p);\n \n-\t\
    \    if (nl == NULL)\n-\t\tbreak;\n-\t    p = skipwhite(nl + 1);\n-\t    if (eap\
    \ != NULL && *p != NUL)\n-\t\teap->nextcmd = p;\n-\t    check_for_end = FALSE;\n\
    -\t}\n+\t// In Vim9 script a command block is not split at NL characters for\n\
    +\t// commands using an expression argument.  Skip over a '#' comment to\n+\t\
    // check for a following NL.  Require white space before the '#'.\n+\tif (in_vim9script()\
    \ && p > expr_end && retarg == NULL)\n+\t    while (*p == '#')\n+\t    {\n+\t\t\
    char_u *nl = vim_strchr(p, NL);\n+\n+\t\tif (nl == NULL)\n+\t\t    break;\n+\t\
    \tp = skipwhite(nl + 1);\n+\t\tif (eap != NULL && *p != NUL)\n+\t\t    eap->nextcmd\
    \ = p;\n+\t\tcheck_for_end = FALSE;\n+\t    }\n+\n+\tif (check_for_end)\n+\t \
    \   end_error = !ends_excmd2(arg, p);\n+    }\n \n-    if (ret != FAIL && check_for_end)\n\
    -\tend_error = !ends_excmd2(arg, p);\n     if (ret == FAIL || end_error)\n   \
    \  {\n \tif (ret != FAIL)\n@@ -2433,7 +2438,8 @@ eval0_retarg(\n \t// Some of\
    \ the expression may not have been consumed.  Do not check for\n \t// a next command\
    \ to avoid more errors, unless \"|\" is following, which\n \t// could only be\
    \ a command separator.\n-\tif (eap != NULL && skipwhite(p)[0] == '|' && skipwhite(p)[1]\
    \ != '|')\n+\tif (eap != NULL && p != NULL\n+\t\t\t  &&  skipwhite(p)[0] == '|'\
    \ && skipwhite(p)[1] != '|')\n \t    eap->nextcmd = check_nextcmd(p);\n \treturn\
    \ FAIL;\n     }"
  - "--- a/src/version.c\n+++ b/src/version.c\n@@ -735,6 +735,8 @@ static char *(features[])\
    \ =\n \n static int included_patches[] =\n {   /* Add new patch number below this\
    \ line */\n+/**/\n+    5169,\n /**/\n     5168,\n /**/"
  identifiers:
  - CVE-2022-2231
  - CWE-476
  overview: NULL Pointer Dereference in GitHub repository vim/vim prior to 8.2.
  references:
  - source: security@huntr.dev
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/vim/vim/commit/79481367a457951aabd9501b510fd7e3eb29c3d8
  - source: security@huntr.dev
    tags:
    - Exploit
    - Patch
    - Third Party Advisory
    url: https://huntr.dev/bounties/8dae6ab4-7a7a-4716-a65c-9b090fa057b5
  - source: security@huntr.dev
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/GFD2A4YLBR7OIRHTL7CK6YNMEIQ264CN/
  - source: security@huntr.dev
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/U743FMJGFQ35GBPCQ6OWMVZEJPDFVEWM/
  - source: security@huntr.dev
    tags:
    - Third Party Advisory
    url: https://security.gentoo.org/glsa/202208-32
  - source: security@huntr.dev
    url: https://security.gentoo.org/glsa/202305-16
  title: NULL Pointer Dereference in GitHub repository vim/vim prior to 8.2.
- diff_content:
  - "--- a/cmd/i2c.c\n+++ b/cmd/i2c.c\n@@ -200,10 +200,10 @@ void i2c_init_board(void)\n\
    \  *\n  * Returns the address length.\n  */\n-static uint get_alen(char *arg,\
    \ int default_len)\n+static uint get_alen(char *arg, uint default_len)\n {\n-\t\
    int\tj;\n-\tint\talen;\n+\tuint\tj;\n+\tuint\talen;\n \n \talen = default_len;\n\
    \ \tfor (j = 0; j < 8; j++) {\n@@ -247,7 +247,7 @@ static int do_i2c_read(struct\
    \ cmd_tbl *cmdtp, int flag, int argc,\n {\n \tuint\tchip;\n \tuint\tdevaddr, length;\n\
    -\tint alen;\n+\tuint\talen;\n \tu_char  *memaddr;\n \tint ret;\n #if CONFIG_IS_ENABLED(DM_I2C)\n\
    @@ -301,7 +301,7 @@ static int do_i2c_write(struct cmd_tbl *cmdtp, int flag, int\
    \ argc,\n {\n \tuint\tchip;\n \tuint\tdevaddr, length;\n-\tint alen;\n+\tuint\t\
    alen;\n \tu_char  *memaddr;\n \tint ret;\n #if CONFIG_IS_ENABLED(DM_I2C)\n@@ -469,8\
    \ +469,8 @@ static int do_i2c_md(struct cmd_tbl *cmdtp, int flag, int argc,\n\
    \ {\n \tuint\tchip;\n \tuint\taddr, length;\n-\tint alen;\n-\tint\tj, nbytes,\
    \ linebytes;\n+\tuint\talen;\n+\tuint\tj, nbytes, linebytes;\n \tint ret;\n #if\
    \ CONFIG_IS_ENABLED(DM_I2C)\n \tstruct udevice *dev;\n@@ -589,9 +589,9 @@ static\
    \ int do_i2c_mw(struct cmd_tbl *cmdtp, int flag, int argc,\n {\n \tuint\tchip;\n\
    \ \tulong\taddr;\n-\tint\talen;\n+\tuint\talen;\n \tuchar\tbyte;\n-\tint\tcount;\n\
    +\tuint\tcount;\n \tint ret;\n #if CONFIG_IS_ENABLED(DM_I2C)\n \tstruct udevice\
    \ *dev;\n@@ -676,8 +676,8 @@ static int do_i2c_crc(struct cmd_tbl *cmdtp, int\
    \ flag, int argc,\n {\n \tuint\tchip;\n \tulong\taddr;\n-\tint\talen;\n-\tint\t\
    count;\n+\tuint\talen;\n+\tuint\tcount;\n \tuchar\tbyte;\n \tulong\tcrc;\n \t\
    ulong\terr;\n@@ -985,7 +985,7 @@ static int do_i2c_loop(struct cmd_tbl *cmdtp,\
    \ int flag, int argc,\n \t\t       char *const argv[])\n {\n \tuint\tchip;\n-\t\
    int alen;\n+\tuint\talen;\n \tuint\taddr;\n \tuint\tlength;\n \tu_char\tbytes[16];"
  identifiers:
  - CVE-2022-34835
  - CWE-787
  overview: In Das U-Boot through 2022.07-rc5, an integer signedness error and resultant
    stack-based buffer overflow in the "i2c md" command enables the corruption of
    the return address pointer of the do_i2c_md function.
  references:
  - source: cve@mitre.org
    tags:
    - Exploit
    - Patch
    - Third Party Advisory
    url: https://github.com/u-boot/u-boot/commit/8f8c04bf1ebbd2f72f1643e7ad9617dafa6e5409
  - source: cve@mitre.org
    tags:
    - Exploit
    - Patch
    - Vendor Advisory
    url: https://lists.denx.de/pipermail/u-boot/2022-June/486113.html
  - source: cve@mitre.org
    tags:
    - Patch
    - Vendor Advisory
    url: https://source.denx.de/u-boot/u-boot/-/commit/8f8c04bf1ebbd2f72f1643e7ad9617dafa6e5409
  title: In Das U-Boot through 2022.07-rc5, an integer signedness error and resultant
    stack-based buffer overflow in the "i2c md" command enables the corruption of
    the return address pointer of the do_i2c_md function.
- diff_content:
  - "--- a/arch/x86/kvm/x86.c\n+++ b/arch/x86/kvm/x86.c\n@@ -8296,7 +8296,7 @@ int\
    \ kvm_skip_emulated_instruction(struct kvm_vcpu *vcpu)\n }\n EXPORT_SYMBOL_GPL(kvm_skip_emulated_instruction);\n\
    \ \n-static bool kvm_vcpu_check_breakpoint(struct kvm_vcpu *vcpu, int *r)\n+static\
    \ bool kvm_vcpu_check_code_breakpoint(struct kvm_vcpu *vcpu, int *r)\n {\n \t\
    if (unlikely(vcpu->guest_debug & KVM_GUESTDBG_USE_HW_BP) &&\n \t    (vcpu->arch.guest_debug_dr7\
    \ & DR7_BP_EN_MASK)) {\n@@ -8365,25 +8365,23 @@ static bool is_vmware_backdoor_opcode(struct\
    \ x86_emulate_ctxt *ctxt)\n }\n \n /*\n- * Decode to be emulated instruction.\
    \ Return EMULATION_OK if success.\n+ * Decode an instruction for emulation.  The\
    \ caller is responsible for handling\n+ * code breakpoints.  Note, manually detecting\
    \ code breakpoints is unnecessary\n+ * (and wrong) when emulating on an intercepted\
    \ fault-like exception[*], as\n+ * code breakpoints have higher priority and thus\
    \ have already been done by\n+ * hardware.\n+ *\n+ * [*] Except #MC, which is\
    \ higher priority, but KVM should never emulate in\n+ *     response to a machine\
    \ check.\n  */\n int x86_decode_emulated_instruction(struct kvm_vcpu *vcpu, int\
    \ emulation_type,\n \t\t\t\t    void *insn, int insn_len)\n {\n-\tint r = EMULATION_OK;\n\
    \ \tstruct x86_emulate_ctxt *ctxt = vcpu->arch.emulate_ctxt;\n+\tint r;\n \n \t\
    init_emulate_ctxt(vcpu);\n \n-\t/*\n-\t * We will reenter on the same instruction\
    \ since we do not set\n-\t * complete_userspace_io. This does not handle watchpoints\
    \ yet,\n-\t * those would be handled in the emulate_ops.\n-\t */\n-\tif (!(emulation_type\
    \ & EMULTYPE_SKIP) &&\n-\t    kvm_vcpu_check_breakpoint(vcpu, &r))\n-\t\treturn\
    \ r;\n-\n \tr = x86_decode_insn(ctxt, insn, insn_len, emulation_type);\n \n \t\
    trace_kvm_emulate_insn_start(vcpu);\n@@ -8416,6 +8414,15 @@ int x86_emulate_instruction(struct\
    \ kvm_vcpu *vcpu, gpa_t cr2_or_gpa,\n \tif (!(emulation_type & EMULTYPE_NO_DECODE))\
    \ {\n \t\tkvm_clear_exception_queue(vcpu);\n \n+\t\t/*\n+\t\t * Return immediately\
    \ if RIP hits a code breakpoint, such #DBs\n+\t\t * are fault-like and are higher\
    \ priority than any faults on\n+\t\t * the code fetch itself.\n+\t\t */\n+\t\t\
    if (!(emulation_type & EMULTYPE_SKIP) &&\n+\t\t    kvm_vcpu_check_code_breakpoint(vcpu,\
    \ &r))\n+\t\t\treturn r;\n+\n \t\tr = x86_decode_emulated_instruction(vcpu, emulation_type,\n\
    \ \t\t\t\t\t\t    insn, insn_len);\n \t\tif (r != EMULATION_OK)  {"
  identifiers:
  - CVE-2022-1852
  - CWE-476
  overview: "A NULL pointer dereference flaw was found in the Linux kernel\u2019s\
    \ KVM module, which can lead to a denial of service in the x86_emulate_insn in\
    \ arch/x86/kvm/emulate.c. This flaw occurs while executing an illegal instruction\
    \ in guest in the Intel CPU."
  references:
  - source: secalert@redhat.com
    tags:
    - Issue Tracking
    - Third Party Advisory
    url: https://bugzilla.redhat.com/show_bug.cgi?id=2089815
  - source: secalert@redhat.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/torvalds/linux/commit/fee060cd52d69c114b62d1a2948ea9648b5131f9
  title: "A NULL pointer dereference flaw was found in the Linux kernel\u2019s KVM\
    \ module, which can lead to a denial of service in the x86_emulate_insn in arch/x86/kvm/emulate.c.\
    \ This flaw occurs while executing an illegal instruction in guest in the Intel\
    \ CPU."
- diff_content:
  - "--- a/src/message.c\n+++ b/src/message.c\n@@ -1820,8 +1820,8 @@ str2special(\n\
    \ \t    *sp = str + 1;\n     }\n     else\n-\t// single-byte character or illegal\
    \ byte\n-\t*sp = str + 1;\n+\t// single-byte character, NUL or illegal byte\n\
    +\t*sp = str + (*str == NUL ? 0 : 1);\n \n     // Make special keys and C0 control\
    \ characters in <> form, also <M-Space>.\n     // Use <Space> only for lhs of\
    \ a mapping."
  - "--- a/src/version.c\n+++ b/src/version.c\n@@ -735,6 +735,8 @@ static char *(features[])\
    \ =\n \n static int included_patches[] =\n {   /* Add new patch number below this\
    \ line */\n+/**/\n+    9,\n /**/\n     8,\n /**/"
  identifiers:
  - CVE-2022-2257
  - CWE-125
  overview: Out-of-bounds Read in GitHub repository vim/vim prior to 9.0.
  references:
  - source: security@huntr.dev
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/vim/vim/commit/083692d598139228e101b8c521aaef7bcf256e9a
  - source: security@huntr.dev
    tags:
    - Exploit
    - Third Party Advisory
    url: https://huntr.dev/bounties/ca581f80-03ba-472a-b820-78f7fd05fe89
  - source: security@huntr.dev
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/43Y3VJPOTTY3NTREDIFUPITM2POG4ZLP/
  - source: security@huntr.dev
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/UXPO5EHDV6J4B27E65DOQGZFELUFPRSK/
  - source: security@huntr.dev
    tags:
    - Third Party Advisory
    url: https://security.gentoo.org/glsa/202208-32
  - source: security@huntr.dev
    url: https://security.gentoo.org/glsa/202305-16
  title: Out-of-bounds Read in GitHub repository vim/vim prior to 9.0.
- diff_content:
  - "--- a/src/opf.c\n+++ b/src/opf.c\n@@ -1152,24 +1152,30 @@ MOBI_RET mobi_build_opf_metadata(OPF\
    \ *opf,  const MOBIData *m, const MOBIRawml *\n     if (mobi_is_dictionary(m))\
    \ {\n         if (opf->metadata->x_meta->dictionary_in_lang == NULL) {\n     \
    \        if (m->mh && m->mh->dict_input_lang) {\n-                opf->metadata->x_meta->dictionary_in_lang\
    \ = calloc(OPF_META_MAX_TAGS, sizeof(char*));\n-                if (opf->metadata->x_meta->dictionary_in_lang\
    \ == NULL) {\n-                    debug_print(\"%s\\n\", \"Memory allocation\
    \ failed\");\n-                    return MOBI_MALLOC_FAILED;\n-             \
    \   }\n                 uint32_t dict_lang_in = *m->mh->dict_input_lang;\n-  \
    \              opf->metadata->x_meta->dictionary_in_lang[0] = strdup(mobi_get_locale_string(dict_lang_in));\n\
    +                const char *lang = mobi_get_locale_string(dict_lang_in);\n+ \
    \               if (lang) {\n+                    opf->metadata->x_meta->dictionary_in_lang\
    \ = calloc(OPF_META_MAX_TAGS, sizeof(char*));\n+                    if (opf->metadata->x_meta->dictionary_in_lang\
    \ == NULL) {\n+                        debug_print(\"%s\\n\", \"Memory allocation\
    \ failed\");\n+                        return MOBI_MALLOC_FAILED;\n+         \
    \           }\n+                    opf->metadata->x_meta->dictionary_in_lang[0]\
    \ = strdup(lang);\n+                }\n             }\n         }\n         if\
    \ (opf->metadata->x_meta->dictionary_out_lang == NULL) {\n             if (m->mh\
    \ && m->mh->dict_output_lang) {\n-                opf->metadata->x_meta->dictionary_out_lang\
    \ = calloc(OPF_META_MAX_TAGS, sizeof(char*));\n-                if (opf->metadata->x_meta->dictionary_out_lang\
    \ == NULL) {\n-                    debug_print(\"%s\\n\", \"Memory allocation\
    \ failed\");\n-                    return MOBI_MALLOC_FAILED;\n+             \
    \   uint32_t dict_lang_out = *m->mh->dict_output_lang;\n+                const\
    \ char *lang = mobi_get_locale_string(dict_lang_out);\n+                if (lang)\
    \ {\n+                    opf->metadata->x_meta->dictionary_out_lang = calloc(OPF_META_MAX_TAGS,\
    \ sizeof(char*));\n+                    if (opf->metadata->x_meta->dictionary_out_lang\
    \ == NULL) {\n+                        debug_print(\"%s\\n\", \"Memory allocation\
    \ failed\");\n+                        return MOBI_MALLOC_FAILED;\n+         \
    \           }\n+                    opf->metadata->x_meta->dictionary_out_lang[0]\
    \ = strdup(lang);\n                 }\n-                uint32_t dict_lang_in\
    \ = *m->mh->dict_output_lang;\n-                opf->metadata->x_meta->dictionary_out_lang[0]\
    \ = strdup(mobi_get_locale_string(dict_lang_in));\n             }\n         }\n\
    \         if (rawml->orth->orth_index_name) {"
  - "--- a/src/util.c\n+++ b/src/util.c\n@@ -641,7 +641,7 @@ static const char *mobi_locale[MOBI_LANG_MAX][MOBI_REGION_MAX]\
    \ = {\n  See mobi_locale array.\n  \n  @param[in] locale_number Mobipocket locale\
    \ number (as stored in MOBI header)\n- @return Pointer to locale string in mobi_locale\
    \ array\n+ @return Pointer to locale string in mobi_locale array or NULL on error\n\
    \  */\n const char * mobi_get_locale_string(const uint32_t locale_number) {\n\
    \     uint8_t lang_code = locale_number & 0xffU;"
  - "--- a/tools/common.c\n+++ b/tools/common.c\n@@ -330,7 +330,7 @@ void print_summary(const\
    \ MOBIData *m) {\n             *m->mh->dict_input_lang && *m->mh->dict_output_lang)\
    \ {\n             const char *locale_in = mobi_get_locale_string(*m->mh->dict_input_lang);\n\
    \             const char *locale_out = mobi_get_locale_string(*m->mh->dict_output_lang);\n\
    -            printf(\": %s => %s\", locale_in, locale_out);\n+            printf(\"\
    : %s => %s\", locale_in ? locale_in : \"unknown\", locale_out ? locale_out : \"\
    unknown\");\n         }\n         printf(\"\\n\");\n     }"
  identifiers:
  - CVE-2022-2279
  - CWE-476
  overview: NULL Pointer Dereference in GitHub repository bfabiszewski/libmobi prior
    to 0.11.
  references:
  - source: security@huntr.dev
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/bfabiszewski/libmobi/commit/c0699c8693c47f14a2e57dec7292e862ac7adf9c
  - source: security@huntr.dev
    tags:
    - Exploit
    - Third Party Advisory
    url: https://huntr.dev/bounties/68c249e2-779d-4871-b7e3-851f03aca2de
  title: NULL Pointer Dereference in GitHub repository bfabiszewski/libmobi prior
    to 0.11.
- diff_content:
  - "--- a/src/register.c\n+++ b/src/register.c\n@@ -1918,6 +1918,8 @@ do_put(\n \t\
    \t    vim_memset(ptr, ' ', (size_t)spaces);\n \t\t    ptr += spaces;\n \t\t}\n\
    +\t\telse\n+\t\t    totlen -= spaces;  // didn't use these spaces\n \t    }\n\
    \ \n \t    // may insert some spaces after the new text"
  - "--- a/src/version.c\n+++ b/src/version.c\n@@ -735,6 +735,8 @@ static char *(features[])\
    \ =\n \n static int included_patches[] =\n {   /* Add new patch number below this\
    \ line */\n+/**/\n+    11,\n /**/\n     10,\n /**/"
  identifiers:
  - CVE-2022-2264
  - CWE-122
  overview: Heap-based Buffer Overflow in GitHub repository vim/vim prior to 9.0.
  references:
  - source: security@huntr.dev
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/vim/vim/commit/d25f003342aca9889067f2e839963dfeccf1fe05
  - source: security@huntr.dev
    tags:
    - Exploit
    - Issue Tracking
    - Patch
    - Third Party Advisory
    url: https://huntr.dev/bounties/2241c773-02c9-4708-b63e-54aef99afa6c
  - source: security@huntr.dev
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/43Y3VJPOTTY3NTREDIFUPITM2POG4ZLP/
  - source: security@huntr.dev
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/UXPO5EHDV6J4B27E65DOQGZFELUFPRSK/
  - source: security@huntr.dev
    tags:
    - Third Party Advisory
    url: https://security.gentoo.org/glsa/202208-32
  - source: security@huntr.dev
    url: https://security.gentoo.org/glsa/202305-16
  title: Heap-based Buffer Overflow in GitHub repository vim/vim prior to 9.0.
- diff_content:
  - "--- a/ldebug.c\n+++ b/ldebug.c\n@@ -824,8 +824,11 @@ l_noret luaG_runerror (lua_State\
    \ *L, const char *fmt, ...) {\n   va_start(argp, fmt);\n   msg = luaO_pushvfstring(L,\
    \ fmt, argp);  /* format message */\n   va_end(argp);\n-  if (isLua(ci))  /* if\
    \ Lua function, add source:line information */\n+  if (isLua(ci)) {  /* if Lua\
    \ function, add source:line information */\n     luaG_addinfo(L, msg, ci_func(ci)->p->source,\
    \ getcurrentline(ci));\n+    setobjs2s(L, L->top - 2, L->top - 1);  /* remove\
    \ 'msg' from the stack */\n+    L->top--;\n+  }\n   luaG_errormsg(L);\n }\n "
  - "--- a/lvm.c\n+++ b/lvm.c\n@@ -656,8 +656,10 @@ void luaV_concat (lua_State *L,\
    \ int total) {\n       /* collect total length and number of strings */\n    \
    \   for (n = 1; n < total && tostring(L, s2v(top - n - 1)); n++) {\n         size_t\
    \ l = vslen(s2v(top - n - 1));\n-        if (l_unlikely(l >= (MAX_SIZE/sizeof(char))\
    \ - tl))\n+        if (l_unlikely(l >= (MAX_SIZE/sizeof(char)) - tl)) {\n+   \
    \       L->top = top - total;  /* pop strings to avoid wasting stack */\n    \
    \       luaG_runerror(L, \"string length overflow\");\n+        }\n         tl\
    \ += l;\n       }\n       if (tl <= LUAI_MAXSHORTLEN) {  /* is result a short\
    \ string? */\n@@ -672,7 +674,7 @@ void luaV_concat (lua_State *L, int total) {\n\
    \       setsvalue2s(L, top - n, ts);  /* create result */\n     }\n     total\
    \ -= n-1;  /* got 'n' strings to create 1 new */\n-    L->top -= n-1;  /* popped\
    \ 'n' strings and pushed one */\n+    L->top = top - (n - 1);  /* popped 'n' strings\
    \ and pushed one */\n   } while (total > 1);  /* repeat until only 1 result left\
    \ */\n }\n "
  identifiers:
  - CVE-2022-33099
  - CWE-787
  overview: An issue in the component luaG_runerror of Lua v5.4.4 and below leads
    to a heap-buffer overflow when a recursive error occurs.
  references:
  - source: cve@mitre.org
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/lua/lua/commit/42d40581dd919fb134c07027ca1ce0844c670daf
  - source: cve@mitre.org
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/RJNJ66IFDUKWJJZXHGOLRGIA3HWWC36R/
  - source: cve@mitre.org
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/UHYZOEFDVLVAD6EEP4CDW6DNONIVVHPA/
  - source: cve@mitre.org
    tags:
    - Exploit
    - Mailing List
    - Vendor Advisory
    url: https://lua-users.org/lists/lua-l/2022-05/msg00035.html
  - source: cve@mitre.org
    tags:
    - Exploit
    - Mailing List
    - Vendor Advisory
    url: https://lua-users.org/lists/lua-l/2022-05/msg00042.html
  - source: cve@mitre.org
    tags:
    - Exploit
    - Mailing List
    - Vendor Advisory
    url: https://lua-users.org/lists/lua-l/2022-05/msg00073.html
  - source: cve@mitre.org
    url: https://www.lua.org/bugs.html#Lua-stack%20overflow%20when%20C%20stack%20overflows%20while%20handling%20an%20error:~:text=Lua-stack%20overflow%20when%20C%20stack%20overflows%20while%20handling%20an%20error
  title: An issue in the component luaG_runerror of Lua v5.4.4 and below leads to
    a heap-buffer overflow when a recursive error occurs.
- diff_content:
  - "--- a/src/version.c\n+++ b/src/version.c\n@@ -735,6 +735,8 @@ static char *(features[])\
    \ =\n \n static int included_patches[] =\n {   /* Add new patch number below this\
    \ line */\n+/**/\n+    17,\n /**/\n     16,\n /**/"
  - "--- a/src/window.c\n+++ b/src/window.c\n@@ -2594,6 +2594,8 @@ win_close(win_T\
    \ *win, int free_buf)\n \t */\n \tif (wp->w_buffer != curbuf)\n \t{\n+\t    reset_VIsual_and_resel();\t\
    // stop Visual mode\n+\n \t    other_buffer = TRUE;\n \t    win->w_closing = TRUE;\n\
    \ \t    apply_autocmds(EVENT_BUFLEAVE, NULL, NULL, FALSE, curbuf);"
  identifiers:
  - CVE-2022-2284
  - CWE-122
  overview: Heap-based Buffer Overflow in GitHub repository vim/vim prior to 9.0.
  references:
  - source: security@huntr.dev
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/vim/vim/commit/3d51ce18ab1be4f9f6061568a4e7fabf00b21794
  - source: security@huntr.dev
    tags:
    - Exploit
    - Patch
    - Third Party Advisory
    url: https://huntr.dev/bounties/571d25ce-8d53-4fa0-b620-27f2a8a14874
  - source: security@huntr.dev
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/43Y3VJPOTTY3NTREDIFUPITM2POG4ZLP/
  - source: security@huntr.dev
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/UXPO5EHDV6J4B27E65DOQGZFELUFPRSK/
  - source: security@huntr.dev
    tags:
    - Third Party Advisory
    url: https://security.gentoo.org/glsa/202208-32
  - source: security@huntr.dev
    url: https://security.gentoo.org/glsa/202305-16
  title: Heap-based Buffer Overflow in GitHub repository vim/vim prior to 9.0.
- diff_content:
  - "--- a/src/term.c\n+++ b/src/term.c\n@@ -5393,6 +5393,7 @@ check_termcode(\n \t\
    if (*tp == ESC && !p_ek && (State & MODE_INSERT))\n \t    continue;\n \n+\ttp[len]\
    \ = NUL;\n \tkey_name[0] = NUL;\t// no key name found yet\n \tkey_name[1] = NUL;\t\
    // no key name found yet\n \tmodifiers = 0;\t\t// no modifiers yet"
  - "--- a/src/version.c\n+++ b/src/version.c\n@@ -735,6 +735,8 @@ static char *(features[])\
    \ =\n \n static int included_patches[] =\n {   /* Add new patch number below this\
    \ line */\n+/**/\n+    18,\n /**/\n     17,\n /**/"
  identifiers:
  - CVE-2022-2285
  - CWE-190
  overview: Integer Overflow or Wraparound in GitHub repository vim/vim prior to 9.0.
  references:
  - source: security@huntr.dev
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/vim/vim/commit/27efc62f5d86afcb2ecb7565587fe8dea4b036fe
  - source: security@huntr.dev
    tags:
    - Exploit
    - Patch
    - Third Party Advisory
    url: https://huntr.dev/bounties/64574b28-1779-458d-a221-06c434042736
  - source: security@huntr.dev
    tags:
    - Mailing List
    - Third Party Advisory
    url: https://lists.debian.org/debian-lts-announce/2022/11/msg00009.html
  - source: security@huntr.dev
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/43Y3VJPOTTY3NTREDIFUPITM2POG4ZLP/
  - source: security@huntr.dev
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/UXPO5EHDV6J4B27E65DOQGZFELUFPRSK/
  - source: security@huntr.dev
    tags:
    - Third Party Advisory
    url: https://security.gentoo.org/glsa/202208-32
  - source: security@huntr.dev
    url: https://security.gentoo.org/glsa/202305-16
  title: Integer Overflow or Wraparound in GitHub repository vim/vim prior to 9.0.
- diff_content:
  - "--- a/src/insexpand.c\n+++ b/src/insexpand.c\n@@ -2209,11 +2209,21 @@ ins_compl_stop(int\
    \ c, int prev_mode, int retval)\n     // but only do this, if the Popup is still\
    \ visible\n     if (c == Ctrl_E)\n     {\n+\tchar_u *p = NULL;\n+\n \tins_compl_delete();\n\
    \ \tif (compl_leader != NULL)\n-\t    ins_bytes(compl_leader + get_compl_len());\n\
    +\t    p = compl_leader;\n \telse if (compl_first_match != NULL)\n-\t    ins_bytes(compl_orig_text\
    \ + get_compl_len());\n+\t    p = compl_orig_text;\n+\tif (p != NULL)\n+\t{\n\
    +\t    int\t    compl_len = get_compl_len();\n+\t    int\t    len = (int)STRLEN(p);\n\
    +\n+\t    if (len > compl_len)\n+\t\tins_bytes_len(p + compl_len, len - compl_len);\n\
    +\t}\n \tretval = TRUE;\n     }\n "
  - "--- a/src/version.c\n+++ b/src/version.c\n@@ -735,6 +735,8 @@ static char *(features[])\
    \ =\n \n static int included_patches[] =\n {   /* Add new patch number below this\
    \ line */\n+/**/\n+    20,\n /**/\n     19,\n /**/"
  identifiers:
  - CVE-2022-2286
  - CWE-125
  overview: Out-of-bounds Read in GitHub repository vim/vim prior to 9.0.
  references:
  - source: security@huntr.dev
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/vim/vim/commit/f12129f1714f7d2301935bb21d896609bdac221c
  - source: security@huntr.dev
    tags:
    - Exploit
    - Patch
    - Third Party Advisory
    url: https://huntr.dev/bounties/fe7681fb-2318-436b-8e65-daf66cd597d8
  - source: security@huntr.dev
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/43Y3VJPOTTY3NTREDIFUPITM2POG4ZLP/
  - source: security@huntr.dev
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/UXPO5EHDV6J4B27E65DOQGZFELUFPRSK/
  - source: security@huntr.dev
    tags:
    - Third Party Advisory
    url: https://security.gentoo.org/glsa/202208-32
  - source: security@huntr.dev
    url: https://security.gentoo.org/glsa/202305-16
  title: Out-of-bounds Read in GitHub repository vim/vim prior to 9.0.
- diff_content:
  - "--- a/src/spellfile.c\n+++ b/src/spellfile.c\n@@ -4366,6 +4366,23 @@ wordtree_alloc(spellinfo_T\
    \ *spin)\n     return (wordnode_T *)getroom(spin, sizeof(wordnode_T), TRUE);\n\
    \ }\n \n+/*\n+ * Return TRUE if \"word\" contains valid word characters.\n+ *\
    \ Control characters and trailing '/' are invalid.  Space is OK.\n+ */\n+    static\
    \ int\n+valid_spell_word(char_u *word)\n+{\n+    char_u *p;\n+\n+    if (enc_utf8\
    \ && !utf_valid_string(word, NULL))\n+\treturn FALSE;\n+    for (p = word; *p\
    \ != NUL; p += mb_ptr2len(p))\n+\tif (*p < ' ' || (p[0] == '/' && p[1] == NUL))\n\
    +\t    return FALSE;\n+    return TRUE;\n+}\n+\n /*\n  * Store a word in the tree(s).\n\
    \  * Always store it in the case-folded tree.  For a keep-case word this is\n\
    @@ -4391,7 +4408,7 @@ store_word(\n     char_u\t*p;\n \n     // Avoid adding illegal\
    \ bytes to the word tree.\n-    if (enc_utf8 && !utf_valid_string(word, NULL))\n\
    +    if (!valid_spell_word(word))\n \treturn FAIL;\n \n     (void)spell_casefold(curwin,\
    \ word, len, foldword, MAXWLEN);\n@@ -6194,7 +6211,7 @@ spell_add_word(\n    \
    \ int\t\ti;\n     char_u\t*spf;\n \n-    if (enc_utf8 && !utf_valid_string(word,\
    \ NULL))\n+    if (!valid_spell_word(word))\n     {\n \temsg(_(e_illegal_character_in_word));\n\
    \ \treturn;"
  - "--- a/src/version.c\n+++ b/src/version.c\n@@ -735,6 +735,8 @@ static char *(features[])\
    \ =\n \n static int included_patches[] =\n {   /* Add new patch number below this\
    \ line */\n+/**/\n+    21,\n /**/\n     20,\n /**/"
  identifiers:
  - CVE-2022-2287
  - CWE-125
  overview: Out-of-bounds Read in GitHub repository vim/vim prior to 9.0.
  references:
  - source: security@huntr.dev
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/vim/vim/commit/5e59ea54c0c37c2f84770f068d95280069828774
  - source: security@huntr.dev
    tags:
    - Exploit
    - Patch
    - Third Party Advisory
    url: https://huntr.dev/bounties/654aa069-3a9d-45d3-9a52-c1cf3490c284
  - source: security@huntr.dev
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/43Y3VJPOTTY3NTREDIFUPITM2POG4ZLP/
  - source: security@huntr.dev
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/UXPO5EHDV6J4B27E65DOQGZFELUFPRSK/
  - source: security@huntr.dev
    tags:
    - Third Party Advisory
    url: https://security.gentoo.org/glsa/202208-32
  - source: security@huntr.dev
    url: https://security.gentoo.org/glsa/202305-16
  title: Out-of-bounds Read in GitHub repository vim/vim prior to 9.0.
- diff_content:
  - "--- a/src/ex_docmd.c\n+++ b/src/ex_docmd.c\n@@ -3118,9 +3118,11 @@ parse_command_modifiers(\n\
    \ \t\tsize_t len = STRLEN(cmd_start);\n \n \t\t// Special case: empty command\
    \ uses \"+\":\n-\t\t//  \"'<,'>mods\" -> \"mods'<,'>+\n+\t\t//  \"'<,'>mods\"\
    \ -> \"mods *+\n+\t\t//  Use \"*\" instead of \"'<,'>\" to avoid the command getting\n\
    +\t\t//  longer, in case is was allocated.\n \t\tmch_memmove(orig_cmd, cmd_start,\
    \ len);\n-\t\tSTRCPY(orig_cmd + len, \"'<,'>+\");\n+\t\tSTRCPY(orig_cmd + len,\
    \ \" *+\");\n \t    }\n \t    else\n \t    {"
  - "--- a/src/version.c\n+++ b/src/version.c\n@@ -735,6 +735,8 @@ static char *(features[])\
    \ =\n \n static int included_patches[] =\n {   /* Add new patch number below this\
    \ line */\n+/**/\n+    25,\n /**/\n     24,\n /**/"
  identifiers:
  - CVE-2022-2288
  - CWE-787
  overview: Out-of-bounds Write in GitHub repository vim/vim prior to 9.0.
  references:
  - source: security@huntr.dev
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/vim/vim/commit/c6fdb15d423df22e1776844811d082322475e48a
  - source: security@huntr.dev
    tags:
    - Exploit
    - Third Party Advisory
    url: https://huntr.dev/bounties/a71bdcb7-4e9b-4650-ab6a-fe8e3e9852ad
  - source: security@huntr.dev
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/43Y3VJPOTTY3NTREDIFUPITM2POG4ZLP/
  - source: security@huntr.dev
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/UXPO5EHDV6J4B27E65DOQGZFELUFPRSK/
  - source: security@huntr.dev
    tags:
    - Third Party Advisory
    url: https://security.gentoo.org/glsa/202208-32
  - source: security@huntr.dev
    url: https://security.gentoo.org/glsa/202305-16
  title: Out-of-bounds Write in GitHub repository vim/vim prior to 9.0.
- diff_content:
  - "--- a/src/diff.c\n+++ b/src/diff.c\n@@ -2642,6 +2642,20 @@ nv_diffgetput(int\
    \ put, long count)\n     ex_diffgetput(&ea);\n }\n \n+/*\n+ * Return TRUE if \"\
    diff\" appears in the list of diff blocks of the current tab.\n+ */\n+    static\
    \ int\n+valid_diff(diff_T *diff)\n+{\n+    diff_T\t*dp;\n+\n+    for (dp = curtab->tp_first_diff;\
    \ dp != NULL; dp = dp->df_next)\n+\tif (dp == diff)\n+\t    return TRUE;\n+  \
    \  return FALSE;\n+}\n+\n /*\n  * \":diffget\"\n  * \":diffput\"\n@@ -2923,7 +2937,13\
    \ @@ ex_diffgetput(exarg_T *eap)\n #endif\n \t\tvim_free(dfree);\n \t    }\n-\t\
    \    else\n+\n+\t    // mark_adjust() may have made \"dp\" invalid.  We don't\
    \ know where\n+\t    // to continue then, bail out.\n+\t    if (added != 0 &&\
    \ !valid_diff(dp))\n+\t\tbreak;\n+\n+\t    if (dfree == NULL)\n \t\t// mark_adjust()\
    \ may have changed the count in a wrong way\n \t\tdp->df_count[idx_to] = new_count;\n\
    \ "
  - "--- a/src/version.c\n+++ b/src/version.c\n@@ -735,6 +735,8 @@ static char *(features[])\
    \ =\n \n static int included_patches[] =\n {   /* Add new patch number below this\
    \ line */\n+/**/\n+    26,\n /**/\n     25,\n /**/"
  identifiers:
  - CVE-2022-2289
  - CWE-416
  overview: Use After Free in GitHub repository vim/vim prior to 9.0.
  references:
  - source: security@huntr.dev
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/vim/vim/commit/c5274dd12224421f2430b30c53b881b9403d649e
  - source: security@huntr.dev
    tags:
    - Exploit
    - Third Party Advisory
    url: https://huntr.dev/bounties/7447d2ea-db5b-4883-adf4-1eaf7deace64
  - source: security@huntr.dev
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/43Y3VJPOTTY3NTREDIFUPITM2POG4ZLP/
  - source: security@huntr.dev
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/UXPO5EHDV6J4B27E65DOQGZFELUFPRSK/
  - source: security@huntr.dev
    tags:
    - Third Party Advisory
    url: https://security.gentoo.org/glsa/202208-32
  - source: security@huntr.dev
    url: https://security.gentoo.org/glsa/202305-16
  title: Use After Free in GitHub repository vim/vim prior to 9.0.
- diff_content:
  - "--- a/tools/chafa/xwd-loader.c\n+++ b/tools/chafa/xwd-loader.c\n@@ -165,67 +165,91\
    \ @@ compute_pixel_type (XwdLoader *loader)\n }\n \n #define ASSERT_HEADER(x)\
    \ if (!(x)) return FALSE\n+#define UNPACK_FIELD_U32(dest, src, field) ((dest)->field\
    \ = GUINT32_FROM_BE ((src)->field))\n+#define UNPACK_FIELD_S32(dest, src, field)\
    \ ((dest)->field = GINT32_FROM_BE ((src)->field))\n \n static gboolean\n-load_header\
    \ (XwdLoader *loader) // gconstpointer in, gsize in_max_len, XwdHeader *header_out)\n\
    +load_header (XwdLoader *loader)\n {\n     XwdHeader *h = &loader->header;\n \
    \    XwdHeader in;\n-    const guint32 *p = (const guint32 *) &in;\n+    const\
    \ XwdHeader *inp;\n \n     if (!file_mapping_taste (loader->mapping, &in, 0, sizeof\
    \ (in)))\n         return FALSE;\n \n-    h->header_size = g_ntohl (*(p++));\n\
    -    h->file_version = g_ntohl (*(p++));\n-    h->pixmap_format = g_ntohl (*(p++));\n\
    -    h->pixmap_depth = g_ntohl (*(p++));\n-    h->pixmap_width = g_ntohl (*(p++));\n\
    -    h->pixmap_height = g_ntohl (*(p++));\n-    h->x_offset = g_ntohl (*(p++));\n\
    -    h->byte_order = g_ntohl (*(p++));\n-    h->bitmap_unit = g_ntohl (*(p++));\n\
    -    h->bitmap_bit_order = g_ntohl (*(p++));\n-    h->bitmap_pad = g_ntohl (*(p++));\n\
    -    h->bits_per_pixel = g_ntohl (*(p++));\n-    h->bytes_per_line = g_ntohl (*(p++));\n\
    -    h->visual_class = g_ntohl (*(p++));\n-    h->red_mask = g_ntohl (*(p++));\n\
    -    h->green_mask = g_ntohl (*(p++));\n-    h->blue_mask = g_ntohl (*(p++));\n\
    -    h->bits_per_rgb = g_ntohl (*(p++));\n-    h->color_map_entries = g_ntohl\
    \ (*(p++));\n-    h->n_colors = g_ntohl (*(p++));\n-    h->window_width = g_ntohl\
    \ (*(p++));\n-    h->window_height = g_ntohl (*(p++));\n-    h->window_x = g_ntohl\
    \ (*(p++));\n-    h->window_y = g_ntohl (*(p++));\n-    h->window_border_width\
    \ = g_ntohl (*(p++));\n+    inp = &in;\n+\n+    UNPACK_FIELD_U32 (h, inp, header_size);\n\
    +    UNPACK_FIELD_U32 (h, inp, file_version);\n+    UNPACK_FIELD_U32 (h, inp,\
    \ pixmap_format);\n+    UNPACK_FIELD_U32 (h, inp, pixmap_depth);\n+    UNPACK_FIELD_U32\
    \ (h, inp, pixmap_width);\n+    UNPACK_FIELD_U32 (h, inp, pixmap_height);\n+ \
    \   UNPACK_FIELD_U32 (h, inp, x_offset);\n+    UNPACK_FIELD_U32 (h, inp, byte_order);\n\
    +    UNPACK_FIELD_U32 (h, inp, bitmap_unit);\n+    UNPACK_FIELD_U32 (h, inp, bitmap_bit_order);\n\
    +    UNPACK_FIELD_U32 (h, inp, bitmap_pad);\n+    UNPACK_FIELD_U32 (h, inp, bits_per_pixel);\n\
    +    UNPACK_FIELD_U32 (h, inp, bytes_per_line);\n+    UNPACK_FIELD_U32 (h, inp,\
    \ visual_class);\n+    UNPACK_FIELD_U32 (h, inp, red_mask);\n+    UNPACK_FIELD_U32\
    \ (h, inp, green_mask);\n+    UNPACK_FIELD_U32 (h, inp, blue_mask);\n+    UNPACK_FIELD_U32\
    \ (h, inp, bits_per_rgb);\n+    UNPACK_FIELD_U32 (h, inp, color_map_entries);\n\
    +    UNPACK_FIELD_U32 (h, inp, n_colors);\n+    UNPACK_FIELD_U32 (h, inp, window_width);\n\
    +    UNPACK_FIELD_U32 (h, inp, window_height);\n+    UNPACK_FIELD_S32 (h, inp,\
    \ window_x);\n+    UNPACK_FIELD_S32 (h, inp, window_y);\n+    UNPACK_FIELD_U32\
    \ (h, inp, window_border_width);\n \n     /* Only support the most common/useful\
    \ subset of XWD files out there;\n-     * namely, that corresponding to screen\
    \ dumps from modern X.Org servers. */\n+     * namely, that corresponding to screen\
    \ dumps from modern X.Org servers.\n+     * We could check visual_class == 5 too,\
    \ but the other fields convey all\n+     * the info we need. */\n \n     ASSERT_HEADER\
    \ (h->header_size >= sizeof (XwdHeader));\n+    ASSERT_HEADER (h->header_size\
    \ <= 65535);\n     ASSERT_HEADER (h->file_version == 7);\n     ASSERT_HEADER (h->pixmap_depth\
    \ == 24);\n \n+    /* Should be zero for truecolor/directcolor. Cap it to prevent\
    \ overflows. */\n+    ASSERT_HEADER (h->color_map_entries <= 256);\n+\n     /*\
    \ Xvfb sets bits_per_rgb to 8, but 'convert' uses 24 for the same image data.\
    \ One\n      * of them is likely misunderstanding. Let's be lenient and accept\
    \ either. */\n     ASSERT_HEADER (h->bits_per_rgb == 8 || h->bits_per_rgb == 24);\n\
    \ \n+    /* These are the pixel formats we allow. */\n+    ASSERT_HEADER (h->bits_per_pixel\
    \ == 24 || h->bits_per_pixel == 32);\n+\n+    /* Enforce sane dimensions. */\n\
    +    ASSERT_HEADER (h->pixmap_width >= 1 && h->pixmap_width <= 65535);\n+    ASSERT_HEADER\
    \ (h->pixmap_height >= 1 && h->pixmap_height <= 65535);\n+\n+    /* Make sure\
    \ rowstride can actually hold a row's worth of data but is not padded to\n+  \
    \   * something ridiculous. */\n     ASSERT_HEADER (h->bytes_per_line >= h->pixmap_width\
    \ * (h->bits_per_pixel / 8));\n+    ASSERT_HEADER (h->bytes_per_line <= h->pixmap_width\
    \ * (h->bits_per_pixel / 8) + 1024);\n+\n+    /* Make sure the total allocation/map\
    \ is not too big. */\n+    ASSERT_HEADER (h->bytes_per_line * h->pixmap_height\
    \ < (1UL << 31) - 65536 - 256 * 32);\n+\n     ASSERT_HEADER (compute_pixel_type\
    \ (loader) < CHAFA_PIXEL_MAX);\n \n     loader->file_data = file_mapping_get_data\
    \ (loader->mapping, &loader->file_data_len);\n     if (!loader->file_data)\n \
    \        return FALSE;\n \n     ASSERT_HEADER (loader->file_data_len >= h->header_size\n\
    -                   + h->n_colors * sizeof (XwdColor)\n-                   + h->pixmap_height\
    \ * h->bytes_per_line);\n+                   + h->color_map_entries * sizeof (XwdColor)\n\
    +                   + h->pixmap_height * (gsize) h->bytes_per_line);\n \n    \
    \ loader->image_data = (const guint8 *) loader->file_data\n-        + h->header_size\
    \ + h->n_colors * sizeof (XwdColor);\n+        + h->header_size + h->color_map_entries\
    \ * sizeof (XwdColor);\n \n     return TRUE;\n }"
  identifiers:
  - CVE-2022-2301
  - CWE-125
  overview: Buffer Over-read in GitHub repository hpjansson/chafa prior to 1.10.3.
  references:
  - source: security@huntr.dev
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/hpjansson/chafa/commit/56fabfa18a6880b4cb66047fa6557920078048d9
  - source: security@huntr.dev
    tags:
    - Exploit
    - Issue Tracking
    - Patch
    - Third Party Advisory
    url: https://huntr.dev/bounties/f6b9114b-671d-4948-b946-ffe5c9aeb816
  title: Buffer Over-read in GitHub repository hpjansson/chafa prior to 1.10.3.
- diff_content:
  - "--- a/src/spell.c\n+++ b/src/spell.c\n@@ -3996,9 +3996,10 @@ spell_dump_compl(\n\
    \ \t\t    n = arridx[depth] + curi[depth];\n \t\t    ++curi[depth];\n \t\t   \
    \ c = byts[n];\n-\t\t    if (c == 0)\n+\t\t    if (c == 0 || depth >= MAXWLEN\
    \ - 1)\n \t\t    {\n-\t\t\t// End of word, deal with the word.\n+\t\t\t// End\
    \ of word or reached maximum length, deal with the\n+\t\t\t// word.\n \t\t\t//\
    \ Don't use keep-case words in the fold-case tree,\n \t\t\t// they will appear\
    \ in the keep-case tree.\n \t\t\t// Only use the word when the region matches."
  - "--- a/src/version.c\n+++ b/src/version.c\n@@ -735,6 +735,8 @@ static char *(features[])\
    \ =\n \n static int included_patches[] =\n {   /* Add new patch number below this\
    \ line */\n+/**/\n+    35,\n /**/\n     34,\n /**/"
  identifiers:
  - CVE-2022-2304
  - CWE-121
  overview: Stack-based Buffer Overflow in GitHub repository vim/vim prior to 9.0.
  references:
  - source: security@huntr.dev
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/vim/vim/commit/54e5fed6d27b747ff152cdb6edfb72ff60e70939
  - source: security@huntr.dev
    tags:
    - Exploit
    - Third Party Advisory
    url: https://huntr.dev/bounties/eb7402f3-025a-402f-97a7-c38700d9548a
  - source: security@huntr.dev
    tags:
    - Mailing List
    - Third Party Advisory
    url: https://lists.debian.org/debian-lts-announce/2022/11/msg00009.html
  - source: security@huntr.dev
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/43Y3VJPOTTY3NTREDIFUPITM2POG4ZLP/
  - source: security@huntr.dev
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/UXPO5EHDV6J4B27E65DOQGZFELUFPRSK/
  - source: security@huntr.dev
    tags:
    - Third Party Advisory
    url: https://security.gentoo.org/glsa/202208-32
  - source: security@huntr.dev
    url: https://security.gentoo.org/glsa/202305-16
  title: Stack-based Buffer Overflow in GitHub repository vim/vim prior to 9.0.
- diff_content:
  - "--- a/lib/ultrajsondec.c\n+++ b/lib/ultrajsondec.c\n@@ -41,7 +41,6 @@ Numeric\
    \ decoder derived from from TCL library\n #include <assert.h>\n #include <string.h>\n\
    \ #include <limits.h>\n-#include <wchar.h>\n #include <stdlib.h>\n #include <errno.h>\n\
    \ #include <stdint.h>\n@@ -58,8 +57,8 @@ struct DecoderState\n {\n   char *start;\n\
    \   char *end;\n-  wchar_t *escStart;\n-  wchar_t *escEnd;\n+  JSUINT32 *escStart;\n\
    +  JSUINT32 *escEnd;\n   int escHeap;\n   int lastType;\n   JSUINT32 objDepth;\n\
    @@ -361,14 +360,12 @@ static const JSUINT8 g_decoderLookup[256] =\n static FASTCALL_ATTR\
    \ JSOBJ FASTCALL_MSVC decode_string ( struct DecoderState *ds)\n {\n   int index;\n\
    -  wchar_t *escOffset;\n-  wchar_t *escStart;\n+  JSUINT32 *escOffset;\n+  JSUINT32\
    \ *escStart;\n   size_t escLen = (ds->escEnd - ds->escStart);\n   JSUINT8 *inputOffset;\n\
    \   JSUTF16 ch = 0;\n-#if WCHAR_MAX >= 0x10FFFF\n   JSUINT8 *lastHighSurrogate\
    \ = NULL;\n-#endif\n   JSUINT8 oct;\n   JSUTF32 ucs;\n   ds->lastType = JT_INVALID;\n\
    @@ -380,11 +377,11 @@ static FASTCALL_ATTR JSOBJ FASTCALL_MSVC decode_string (\
    \ struct DecoderState *ds\n \n     if (ds->escHeap)\n     {\n-      if (newSize\
    \ > (SIZE_MAX / sizeof(wchar_t)))\n+      if (newSize > (SIZE_MAX / sizeof(JSUINT32)))\n\
    \       {\n         return SetError(ds, -1, \"Could not reserve memory block\"\
    );\n       }\n-      escStart = (wchar_t *)ds->dec->realloc(ds->escStart, newSize\
    \ * sizeof(wchar_t));\n+      escStart = (JSUINT32 *)ds->dec->realloc(ds->escStart,\
    \ newSize * sizeof(JSUINT32));\n       if (!escStart)\n       {\n         ds->dec->free(ds->escStart);\n\
    @@ -394,18 +391,18 @@ static FASTCALL_ATTR JSOBJ FASTCALL_MSVC decode_string (\
    \ struct DecoderState *ds\n     }\n     else\n     {\n-      wchar_t *oldStart\
    \ = ds->escStart;\n-      if (newSize > (SIZE_MAX / sizeof(wchar_t)))\n+     \
    \ JSUINT32 *oldStart = ds->escStart;\n+      if (newSize > (SIZE_MAX / sizeof(JSUINT32)))\n\
    \       {\n         return SetError(ds, -1, \"Could not reserve memory block\"\
    );\n       }\n-      ds->escStart = (wchar_t *) ds->dec->malloc(newSize * sizeof(wchar_t));\n\
    +      ds->escStart = (JSUINT32 *) ds->dec->malloc(newSize * sizeof(JSUINT32));\n\
    \       if (!ds->escStart)\n       {\n         return SetError(ds, -1, \"Could\
    \ not reserve memory block\");\n       }\n       ds->escHeap = 1;\n-      memcpy(ds->escStart,\
    \ oldStart, escLen * sizeof(wchar_t));\n+      memcpy(ds->escStart, oldStart,\
    \ escLen * sizeof(JSUINT32));\n     }\n \n     ds->escEnd = ds->escStart + newSize;\n\
    @@ -438,14 +435,14 @@ static FASTCALL_ATTR JSOBJ FASTCALL_MSVC decode_string (\
    \ struct DecoderState *ds\n         inputOffset ++;\n         switch (*inputOffset)\n\
    \         {\n-          case '\\\\': *(escOffset++) = L'\\\\'; inputOffset++;\
    \ continue;\n-          case '\\\"': *(escOffset++) = L'\\\"'; inputOffset++;\
    \ continue;\n-          case '/':  *(escOffset++) = L'/';  inputOffset++; continue;\n\
    -          case 'b':  *(escOffset++) = L'\\b'; inputOffset++; continue;\n-   \
    \       case 'f':  *(escOffset++) = L'\\f'; inputOffset++; continue;\n-      \
    \    case 'n':  *(escOffset++) = L'\\n'; inputOffset++; continue;\n-         \
    \ case 'r':  *(escOffset++) = L'\\r'; inputOffset++; continue;\n-          case\
    \ 't':  *(escOffset++) = L'\\t'; inputOffset++; continue;\n+          case '\\\
    \\': *(escOffset++) = '\\\\'; inputOffset++; continue;\n+          case '\\\"\
    ': *(escOffset++) = '\\\"'; inputOffset++; continue;\n+          case '/':  *(escOffset++)\
    \ = '/';  inputOffset++; continue;\n+          case 'b':  *(escOffset++) = '\\\
    b'; inputOffset++; continue;\n+          case 'f':  *(escOffset++) = '\\f'; inputOffset++;\
    \ continue;\n+          case 'n':  *(escOffset++) = '\\n'; inputOffset++; continue;\n\
    +          case 'r':  *(escOffset++) = '\\r'; inputOffset++; continue;\n+    \
    \      case 't':  *(escOffset++) = '\\t'; inputOffset++; continue;\n \n      \
    \     case 'u':\n           {\n@@ -494,24 +491,20 @@ static FASTCALL_ATTR JSOBJ\
    \ FASTCALL_MSVC decode_string ( struct DecoderState *ds\n               inputOffset\
    \ ++;\n             }\n \n-#if WCHAR_MAX >= 0x10FFFF\n             if ((ch & 0xfc00)\
    \ == 0xdc00 && lastHighSurrogate == inputOffset - 6 * sizeof(*inputOffset))\n\
    \             {\n               // Low surrogate immediately following a high\
    \ surrogate\n               // Overwrite existing high surrogate with combined\
    \ character\n               *(escOffset-1) = (((*(escOffset-1) - 0xd800) <<10)\
    \ | (ch - 0xdc00)) + 0x10000;\n             }\n             else\n-#endif\n  \
    \           {\n-              *(escOffset++) = (wchar_t) ch;\n+              *(escOffset++)\
    \ = (JSUINT32) ch;\n             }\n-#if WCHAR_MAX >= 0x10FFFF\n             if\
    \ ((ch & 0xfc00) == 0xd800)\n             {\n               lastHighSurrogate\
    \ = inputOffset;\n             }\n-#endif\n             break;\n           }\n\
    \ \n@@ -523,7 +516,7 @@ static FASTCALL_ATTR JSOBJ FASTCALL_MSVC decode_string\
    \ ( struct DecoderState *ds\n \n       case 1:\n       {\n-        *(escOffset++)\
    \ = (wchar_t) (*inputOffset++);\n+        *(escOffset++) = (JSUINT32) (*inputOffset++);\n\
    \         break;\n       }\n \n@@ -537,7 +530,7 @@ static FASTCALL_ATTR JSOBJ\
    \ FASTCALL_MSVC decode_string ( struct DecoderState *ds\n         }\n        \
    \ ucs |= (*inputOffset++) & 0x3f;\n         if (ucs < 0x80) return SetError (ds,\
    \ -1, \"Overlong 2 byte UTF-8 sequence detected when decoding 'string'\");\n-\
    \        *(escOffset++) = (wchar_t) ucs;\n+        *(escOffset++) = (JSUINT32)\
    \ ucs;\n         break;\n       }\n \n@@ -560,7 +553,7 @@ static FASTCALL_ATTR\
    \ JSOBJ FASTCALL_MSVC decode_string ( struct DecoderState *ds\n         }\n \n\
    \         if (ucs < 0x800) return SetError (ds, -1, \"Overlong 3 byte UTF-8 sequence\
    \ detected when encoding string\");\n-        *(escOffset++) = (wchar_t) ucs;\n\
    +        *(escOffset++) = (JSUINT32) ucs;\n         break;\n       }\n \n@@ -584,20\
    \ +577,7 @@ static FASTCALL_ATTR JSOBJ FASTCALL_MSVC decode_string ( struct DecoderState\
    \ *ds\n \n         if (ucs < 0x10000) return SetError (ds, -1, \"Overlong 4 byte\
    \ UTF-8 sequence detected when decoding 'string'\");\n \n-#if WCHAR_MAX == 0xffff\n\
    -        if (ucs >= 0x10000)\n-        {\n-          ucs -= 0x10000;\n-      \
    \    *(escOffset++) = (wchar_t) (ucs >> 10) + 0xd800;\n-          *(escOffset++)\
    \ = (wchar_t) (ucs & 0x3ff) + 0xdc00;\n-        }\n-        else\n-        {\n\
    -          *(escOffset++) = (wchar_t) ucs;\n-        }\n-#else\n-        *(escOffset++)\
    \ = (wchar_t) ucs;\n-#endif\n+        *(escOffset++) = (JSUINT32) ucs;\n     \
    \    break;\n       }\n     }\n@@ -810,14 +790,14 @@ JSOBJ JSON_DecodeObject(JSONObjectDecoder\
    \ *dec, const char *buffer, size_t cbBuf\n   /*\n   FIXME: Base the size of escBuffer\
    \ of that of cbBuffer so that the unicode escaping doesn't run into the wall each\
    \ time */\n   struct DecoderState ds;\n-  wchar_t escBuffer[(JSON_MAX_STACK_BUFFER_SIZE\
    \ / sizeof(wchar_t))];\n+  JSUINT32 escBuffer[(JSON_MAX_STACK_BUFFER_SIZE / sizeof(JSUINT32))];\n\
    \   JSOBJ ret;\n \n   ds.start = (char *) buffer;\n   ds.end = ds.start + cbBuffer;\n\
    \ \n   ds.escStart = escBuffer;\n-  ds.escEnd = ds.escStart + (JSON_MAX_STACK_BUFFER_SIZE\
    \ / sizeof(wchar_t));\n+  ds.escEnd = ds.escStart + (JSON_MAX_STACK_BUFFER_SIZE\
    \ / sizeof(JSUINT32));\n   ds.escHeap = 0;\n   ds.prv = dec->prv;\n   ds.dec =\
    \ dec;"
  - "--- a/python/JSONtoObj.c\n+++ b/python/JSONtoObj.c\n@@ -59,9 +59,18 @@ static\
    \ void Object_arrayAddItem(void *prv, JSOBJ obj, JSOBJ value)\n   return;\n }\n\
    \ \n-static JSOBJ Object_newString(void *prv, wchar_t *start, wchar_t *end)\n\
    +/*\n+Check that Py_UCS4 is the same as JSUINT32, else Object_newString will fail.\n\
    +Based on Linux's check in vbox_vmmdev_types.h.\n+This should be replaced with\n\
    +  _Static_assert(sizeof(Py_UCS4) == sizeof(JSUINT32));\n+when C11 is made mandatory\
    \ (CPython 3.11+, PyPy ?).\n+*/\n+typedef char assert_py_ucs4_is_jsuint32[1 -\
    \ 2*!(sizeof(Py_UCS4) == sizeof(JSUINT32))];\n+\n+static JSOBJ Object_newString(void\
    \ *prv, JSUINT32 *start, JSUINT32 *end)\n {\n-  return PyUnicode_FromWideChar\
    \ (start, (end - start));\n+  return PyUnicode_FromKindAndData (PyUnicode_4BYTE_KIND,\
    \ (Py_UCS4 *) start, (end - start));\n }\n \n static JSOBJ Object_newTrue(void\
    \ *prv)"
  identifiers:
  - CVE-2022-31116
  - CWE-670
  overview: UltraJSON is a fast JSON encoder and decoder written in pure C with bindings
    for Python 3.7+. Affected versions were found to improperly decode certain characters.
    JSON strings that contain escaped surrogate characters not part of a proper surrogate
    pair were decoded incorrectly. Besides corrupting strings, this allowed for potential
    key confusion and value overwriting in dictionaries. All users parsing JSON from
    untrusted sources are vulnerable. From version 5.4.0, UltraJSON decodes lone surrogates
    in the same way as the standard library's `json` module does, preserving them
    in the parsed output. Users are advised to upgrade. There are no known workarounds
    for this issue.
  references:
  - source: security-advisories@github.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/ultrajson/ultrajson/commit/67ec07183342589d602e0fcf7bb1ff3e19272687
  - source: security-advisories@github.com
    tags:
    - Exploit
    - Third Party Advisory
    url: https://github.com/ultrajson/ultrajson/security/advisories/GHSA-wpqr-jcpx-745r
  - source: security-advisories@github.com
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/NAU5N4A7EUK2AMUCOLYDD5ARXAJYZBD2/
  - source: security-advisories@github.com
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/OPPU5FZP3LCTXYORFH7NHUMYA5X66IA7/
  title: UltraJSON is a fast JSON encoder and decoder written in pure C with bindings
    for Python 3.7+. Affected versions were found to improperly decode certain characters.
    JSON strings that contain escaped surrogate characters not part of a proper surrogate
    pair were decoded incorrectly. Besides corrupting strings, this allowed for potential
    key confusion and value overwriting in dictionaries. All users parsing JSON from
    untrusted sources are vulnerable. From version 5.4.0, UltraJSON decodes lone surrogates
    in the same way as the standard library's `json` module does, preserving them
    in the parsed output. Users are advised to upgrade. There are no known workarounds
    for this issue.
- diff_content:
  - "--- a/lib/ultrajsondec.c\n+++ b/lib/ultrajsondec.c\n@@ -384,7 +384,7 @@ static\
    \ FASTCALL_ATTR JSOBJ FASTCALL_MSVC decode_string ( struct DecoderState *ds\n\
    \       escStart = (JSUINT32 *)ds->dec->realloc(ds->escStart, newSize * sizeof(JSUINT32));\n\
    \       if (!escStart)\n       {\n-        ds->dec->free(ds->escStart);\n+   \
    \     // Don't free ds->escStart here; it gets handled in JSON_DecodeObject.\n\
    \         return SetError(ds, -1, \"Could not reserve memory block\");\n     \
    \  }\n       ds->escStart = escStart;"
  identifiers:
  - CVE-2022-31117
  - CWE-415
  overview: UltraJSON is a fast JSON encoder and decoder written in pure C with bindings
    for Python 3.7+. In versions prior to 5.4.0 an error occurring while reallocating
    a buffer for string decoding can cause the buffer to get freed twice. Due to how
    UltraJSON uses the internal decoder, this double free is impossible to trigger
    from Python. This issue has been resolved in version 5.4.0 and all users should
    upgrade to UltraJSON 5.4.0. There are no known workarounds for this issue.
  references:
  - source: security-advisories@github.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/ultrajson/ultrajson/commit/9c20de0f77b391093967e25d01fb48671104b15b
  - source: security-advisories@github.com
    tags:
    - Third Party Advisory
    url: https://github.com/ultrajson/ultrajson/security/advisories/GHSA-fm67-cv37-96ff
  - source: security-advisories@github.com
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/NAU5N4A7EUK2AMUCOLYDD5ARXAJYZBD2/
  - source: security-advisories@github.com
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/OPPU5FZP3LCTXYORFH7NHUMYA5X66IA7/
  title: UltraJSON is a fast JSON encoder and decoder written in pure C with bindings
    for Python 3.7+. In versions prior to 5.4.0 an error occurring while reallocating
    a buffer for string decoding can cause the buffer to get freed twice. Due to how
    UltraJSON uses the internal decoder, this double free is impossible to trigger
    from Python. This issue has been resolved in version 5.4.0 and all users should
    upgrade to UltraJSON 5.4.0. There are no known workarounds for this issue.
- diff_content:
  - "--- a/net/rose/rose_timer.c\n+++ b/net/rose/rose_timer.c\n@@ -31,89 +31,89 @@\
    \ static void rose_idletimer_expiry(struct timer_list *);\n \n void rose_start_heartbeat(struct\
    \ sock *sk)\n {\n-\tdel_timer(&sk->sk_timer);\n+\tsk_stop_timer(sk, &sk->sk_timer);\n\
    \ \n \tsk->sk_timer.function = rose_heartbeat_expiry;\n \tsk->sk_timer.expires\
    \  = jiffies + 5 * HZ;\n \n-\tadd_timer(&sk->sk_timer);\n+\tsk_reset_timer(sk,\
    \ &sk->sk_timer, sk->sk_timer.expires);\n }\n \n void rose_start_t1timer(struct\
    \ sock *sk)\n {\n \tstruct rose_sock *rose = rose_sk(sk);\n \n-\tdel_timer(&rose->timer);\n\
    +\tsk_stop_timer(sk, &rose->timer);\n \n \trose->timer.function = rose_timer_expiry;\n\
    \ \trose->timer.expires  = jiffies + rose->t1;\n \n-\tadd_timer(&rose->timer);\n\
    +\tsk_reset_timer(sk, &rose->timer, rose->timer.expires);\n }\n \n void rose_start_t2timer(struct\
    \ sock *sk)\n {\n \tstruct rose_sock *rose = rose_sk(sk);\n \n-\tdel_timer(&rose->timer);\n\
    +\tsk_stop_timer(sk, &rose->timer);\n \n \trose->timer.function = rose_timer_expiry;\n\
    \ \trose->timer.expires  = jiffies + rose->t2;\n \n-\tadd_timer(&rose->timer);\n\
    +\tsk_reset_timer(sk, &rose->timer, rose->timer.expires);\n }\n \n void rose_start_t3timer(struct\
    \ sock *sk)\n {\n \tstruct rose_sock *rose = rose_sk(sk);\n \n-\tdel_timer(&rose->timer);\n\
    +\tsk_stop_timer(sk, &rose->timer);\n \n \trose->timer.function = rose_timer_expiry;\n\
    \ \trose->timer.expires  = jiffies + rose->t3;\n \n-\tadd_timer(&rose->timer);\n\
    +\tsk_reset_timer(sk, &rose->timer, rose->timer.expires);\n }\n \n void rose_start_hbtimer(struct\
    \ sock *sk)\n {\n \tstruct rose_sock *rose = rose_sk(sk);\n \n-\tdel_timer(&rose->timer);\n\
    +\tsk_stop_timer(sk, &rose->timer);\n \n \trose->timer.function = rose_timer_expiry;\n\
    \ \trose->timer.expires  = jiffies + rose->hb;\n \n-\tadd_timer(&rose->timer);\n\
    +\tsk_reset_timer(sk, &rose->timer, rose->timer.expires);\n }\n \n void rose_start_idletimer(struct\
    \ sock *sk)\n {\n \tstruct rose_sock *rose = rose_sk(sk);\n \n-\tdel_timer(&rose->idletimer);\n\
    +\tsk_stop_timer(sk, &rose->idletimer);\n \n \tif (rose->idle > 0) {\n \t\trose->idletimer.function\
    \ = rose_idletimer_expiry;\n \t\trose->idletimer.expires  = jiffies + rose->idle;\n\
    \ \n-\t\tadd_timer(&rose->idletimer);\n+\t\tsk_reset_timer(sk, &rose->idletimer,\
    \ rose->idletimer.expires);\n \t}\n }\n \n void rose_stop_heartbeat(struct sock\
    \ *sk)\n {\n-\tdel_timer(&sk->sk_timer);\n+\tsk_stop_timer(sk, &sk->sk_timer);\n\
    \ }\n \n void rose_stop_timer(struct sock *sk)\n {\n-\tdel_timer(&rose_sk(sk)->timer);\n\
    +\tsk_stop_timer(sk, &rose_sk(sk)->timer);\n }\n \n void rose_stop_idletimer(struct\
    \ sock *sk)\n {\n-\tdel_timer(&rose_sk(sk)->idletimer);\n+\tsk_stop_timer(sk,\
    \ &rose_sk(sk)->idletimer);\n }\n \n static void rose_heartbeat_expiry(struct\
    \ timer_list *t)\n@@ -130,6 +130,7 @@ static void rose_heartbeat_expiry(struct\
    \ timer_list *t)\n \t\t    (sk->sk_state == TCP_LISTEN && sock_flag(sk, SOCK_DEAD)))\
    \ {\n \t\t\tbh_unlock_sock(sk);\n \t\t\trose_destroy_socket(sk);\n+\t\t\tsock_put(sk);\n\
    \ \t\t\treturn;\n \t\t}\n \t\tbreak;\n@@ -152,6 +153,7 @@ static void rose_heartbeat_expiry(struct\
    \ timer_list *t)\n \n \trose_start_heartbeat(sk);\n \tbh_unlock_sock(sk);\n+\t\
    sock_put(sk);\n }\n \n static void rose_timer_expiry(struct timer_list *t)\n@@\
    \ -181,6 +183,7 @@ static void rose_timer_expiry(struct timer_list *t)\n \t\t\
    break;\n \t}\n \tbh_unlock_sock(sk);\n+\tsock_put(sk);\n }\n \n static void rose_idletimer_expiry(struct\
    \ timer_list *t)\n@@ -205,4 +208,5 @@ static void rose_idletimer_expiry(struct\
    \ timer_list *t)\n \t\tsock_set_flag(sk, SOCK_DEAD);\n \t}\n \tbh_unlock_sock(sk);\n\
    +\tsock_put(sk);\n }"
  identifiers:
  - CVE-2022-2318
  - CWE-416
  overview: There are use-after-free vulnerabilities caused by timer handler in net/rose/rose_timer.c
    of linux that allow attackers to crash linux kernel without any privileges.
  references:
  - source: secalert@redhat.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/torvalds/linux/commit/9cc02ede696272c5271a401e4f27c262359bc2f6
  - source: secalert@redhat.com
    tags:
    - Mailing List
    - Third Party Advisory
    url: https://lists.debian.org/debian-lts-announce/2022/10/msg00000.html
  - source: secalert@redhat.com
    tags:
    - Third Party Advisory
    url: https://security.netapp.com/advisory/ntap-20230120-0001/
  - source: secalert@redhat.com
    tags:
    - Third Party Advisory
    url: https://www.debian.org/security/2022/dsa-5191
  title: There are use-after-free vulnerabilities caused by timer handler in net/rose/rose_timer.c
    of linux that allow attackers to crash linux kernel without any privileges.
- diff_content:
  - "--- a/core/src/packets.cpp\n+++ b/core/src/packets.cpp\n@@ -378,7 +378,7 @@ void\
    \ AOClient::pktRemoveEvidence(AreaData* area, int argc, QStringList argv, AOP\n\
    \         return;\n     bool is_int = false;\n     int idx = argv[0].toInt(&is_int);\n\
    -    if (is_int && idx <= area->evidence().size() && idx >= 0) {\n+    if (is_int\
    \ && idx < area->evidence().size() && idx >= 0) {\n         area->deleteEvidence(idx);\n\
    \     }\n     sendEvidenceList(area);\n@@ -391,7 +391,7 @@ void AOClient::pktEditEvidence(AreaData*\
    \ area, int argc, QStringList argv, AOPac\n     bool is_int = false;\n     int\
    \ idx = argv[0].toInt(&is_int);\n     AreaData::Evidence evi = {argv[1], argv[2],\
    \ argv[3]};\n-    if (is_int && idx <= area->evidence().size() && idx >= 0) {\n\
    +    if (is_int && idx < area->evidence().size() && idx >= 0) {\n         area->replaceEvidence(idx,\
    \ evi);\n     }\n     sendEvidenceList(area);"
  identifiers:
  - CVE-2022-31135
  - CWE-129
  overview: Akashi is an open source server implementation of the Attorney Online
    video game based on the Ace Attorney universe. Affected versions of Akashi are
    subject to a denial of service attack. An attacker can use a specially crafted
    evidence packet to make an illegal modification, causing a server crash. This
    can be used to mount a denial-of-service exploit. Users are advised to upgrade.
    There is no known workaround for this issue.
  references:
  - source: security-advisories@github.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/AttorneyOnline/akashi/commit/5566cdfedddef1f219aee33477d9c9690bf2f78b
  - source: security-advisories@github.com
    tags:
    - Issue Tracking
    - Third Party Advisory
    url: https://github.com/AttorneyOnline/akashi/security/advisories/GHSA-vj86-vfmg-q68v
  title: Akashi is an open source server implementation of the Attorney Online video
    game based on the Ace Attorney universe. Affected versions of Akashi are subject
    to a denial of service attack. An attacker can use a specially crafted evidence
    packet to make an illegal modification, causing a server crash. This can be used
    to mount a denial-of-service exploit. Users are advised to upgrade. There is no
    known workaround for this issue.
- diff_content:
  - "--- a/src/insexpand.c\n+++ b/src/insexpand.c\n@@ -524,29 +524,32 @@ ins_compl_accept_char(int\
    \ c)\n \n /*\n  * Get the completed text by inferring the case of the originally\
    \ typed text.\n+ * If the result is in allocated memory \"tofree\" is set to it.\n\
    \  */\n     static char_u *\n ins_compl_infercase_gettext(\n \tchar_u\t*str,\n\
    -\tint\tactual_len,\n-\tint\tactual_compl_length,\n-\tint\tmin_len)\n+\tint\t\
    char_len,\n+\tint\tcompl_char_len,\n+\tint\tmin_len,\n+\tchar_u  **tofree)\n {\n\
    \     int\t\t*wca;\t\t\t// Wide character array.\n     char_u\t*p;\n     int\t\
    \ti, c;\n     int\t\thas_lower = FALSE;\n     int\t\twas_letter = FALSE;\n+  \
    \  garray_T\tgap;\n \n     IObuff[0] = NUL;\n \n     // Allocate wide character\
    \ array for the completion and fill it.\n-    wca = ALLOC_MULT(int, actual_len);\n\
    +    wca = ALLOC_MULT(int, char_len);\n     if (wca == NULL)\n \treturn IObuff;\n\
    \ \n     p = str;\n-    for (i = 0; i < actual_len; ++i)\n+    for (i = 0; i <\
    \ char_len; ++i)\n \tif (has_mbyte)\n \t    wca[i] = mb_ptr2char_adv(&p);\n \t\
    else\n@@ -566,7 +569,7 @@ ins_compl_infercase_gettext(\n \t    if (MB_ISUPPER(wca[i]))\n\
    \ \t    {\n \t\t// Rule 1 is satisfied.\n-\t\tfor (i = actual_compl_length; i\
    \ < actual_len; ++i)\n+\t\tfor (i = compl_char_len; i < char_len; ++i)\n \t\t\
    \    wca[i] = MB_TOLOWER(wca[i]);\n \t\tbreak;\n \t    }\n@@ -587,7 +590,7 @@\
    \ ins_compl_infercase_gettext(\n \t    if (was_letter && MB_ISUPPER(c) && MB_ISLOWER(wca[i]))\n\
    \ \t    {\n \t\t// Rule 2 is satisfied.\n-\t\tfor (i = actual_compl_length; i\
    \ < actual_len; ++i)\n+\t\tfor (i = compl_char_len; i < char_len; ++i)\n \t\t\
    \    wca[i] = MB_TOUPPER(wca[i]);\n \t\tbreak;\n \t    }\n@@ -610,20 +613,52 @@\
    \ ins_compl_infercase_gettext(\n     }\n \n     // Generate encoding specific\
    \ output from wide character array.\n-    // Multi-byte characters can occupy\
    \ up to five bytes more than\n-    // ASCII characters, and we also need one byte\
    \ for NUL, so stay\n-    // six bytes away from the edge of IObuff.\n     p =\
    \ IObuff;\n     i = 0;\n-    while (i < actual_len && (p - IObuff + 6) < IOSIZE)\n\
    -\tif (has_mbyte)\n+    ga_init2(&gap, 1, 500);\n+    while (i < char_len)\n+\
    \    {\n+\tif (gap.ga_data != NULL)\n+\t{\n+\t    if (ga_grow(&gap, 10) == FAIL)\n\
    +\t    {\n+\t\tga_clear(&gap);\n+\t\treturn (char_u *)\"[failed]\";\n+\t    }\n\
    +\t    p = (char_u *)gap.ga_data + gap.ga_len;\n+\t    if (has_mbyte)\n+\t\tgap.ga_len\
    \ += (*mb_char2bytes)(wca[i++], p);\n+\t    else\n+\t    {\n+\t\t*p = wca[i++];\n\
    +\t\t++gap.ga_len;\n+\t    }\n+\t}\n+\telse if ((p - IObuff) + 6 >= IOSIZE)\n\
    +\t{\n+\t    // Multi-byte characters can occupy up to five bytes more than\n\
    +\t    // ASCII characters, and we also need one byte for NUL, so when\n+\t  \
    \  // getting to six bytes from the edge of IObuff switch to using a\n+\t    //\
    \ growarray.  Add the character in the next round.\n+\t    if (ga_grow(&gap, IOSIZE)\
    \ == FAIL)\n+\t\treturn (char_u *)\"[failed]\";\n+\t    STRCPY(gap.ga_data, IObuff);\n\
    +\t    gap.ga_len = STRLEN(IObuff);\n+\t}\n+\telse if (has_mbyte)\n \t    p +=\
    \ (*mb_char2bytes)(wca[i++], p);\n \telse\n \t    *(p++) = wca[i++];\n-    *p\
    \ = NUL;\n-\n+    }\n     vim_free(wca);\n \n+    if (gap.ga_data != NULL)\n+\
    \    {\n+\t*tofree = gap.ga_data;\n+\treturn gap.ga_data;\n+    }\n+\n+    *p\
    \ = NUL;\n     return IObuff;\n }\n \n@@ -644,10 +679,12 @@ ins_compl_add_infercase(\n\
    \ {\n     char_u\t*str = str_arg;\n     char_u\t*p;\n-    int\t\tactual_len;\t\
    \t// Take multi-byte characters\n-    int\t\tactual_compl_length;\t// into account.\n\
    +    int\t\tchar_len;\t\t// count multi-byte characters\n+    int\t\tcompl_char_len;\n\
    \     int\t\tmin_len;\n     int\t\tflags = 0;\n+    int\t\tres;\n+    char_u\t\
    *tofree = NULL;\n \n     if (p_ic && curbuf->b_p_inf && len > 0)\n     {\n@@ -657,44\
    \ +694,45 @@ ins_compl_add_infercase(\n \tif (has_mbyte)\n \t{\n \t    p = str;\n\
    -\t    actual_len = 0;\n+\t    char_len = 0;\n \t    while (*p != NUL)\n \t  \
    \  {\n \t\tMB_PTR_ADV(p);\n-\t\t++actual_len;\n+\t\t++char_len;\n \t    }\n \t\
    }\n \telse\n-\t    actual_len = len;\n+\t    char_len = len;\n \n \t// Find actual\
    \ length of original text.\n \tif (has_mbyte)\n \t{\n \t    p = compl_orig_text;\n\
    -\t    actual_compl_length = 0;\n+\t    compl_char_len = 0;\n \t    while (*p\
    \ != NUL)\n \t    {\n \t\tMB_PTR_ADV(p);\n-\t\t++actual_compl_length;\n+\t\t++compl_char_len;\n\
    \ \t    }\n \t}\n \telse\n-\t    actual_compl_length = compl_length;\n+\t    compl_char_len\
    \ = compl_length;\n \n-\t// \"actual_len\" may be smaller than \"actual_compl_length\"\
    \ when using\n+\t// \"char_len\" may be smaller than \"compl_char_len\" when using\n\
    \ \t// thesaurus, only use the minimum when comparing.\n-\tmin_len = actual_len\
    \ < actual_compl_length\n-\t\t\t\t\t   ? actual_len : actual_compl_length;\n+\t\
    min_len = char_len < compl_char_len ? char_len : compl_char_len;\n \n-\tstr =\
    \ ins_compl_infercase_gettext(str, actual_len, actual_compl_length,\n-\t\t\t\t\
    \t\t\t\tmin_len);\n+\tstr = ins_compl_infercase_gettext(str, char_len,\n+\t\t\t\
    \t\t  compl_char_len, min_len, &tofree);\n     }\n     if (cont_s_ipos)\n \tflags\
    \ |= CP_CONT_S_IPOS;\n     if (icase)\n \tflags |= CP_ICASE;\n \n-    return ins_compl_add(str,\
    \ len, fname, NULL, NULL, dir, flags, FALSE);\n+    res = ins_compl_add(str, len,\
    \ fname, NULL, NULL, dir, flags, FALSE);\n+    vim_free(tofree);\n+    return\
    \ res;\n }\n \n /*"
  - "--- a/src/version.c\n+++ b/src/version.c\n@@ -735,6 +735,8 @@ static char *(features[])\
    \ =\n \n static int included_patches[] =\n {   /* Add new patch number below this\
    \ line */\n+/**/\n+    45,\n /**/\n     44,\n /**/"
  identifiers:
  - CVE-2022-2343
  - CWE-122
  overview: Heap-based Buffer Overflow in GitHub repository vim/vim prior to 9.0.0044.
  references:
  - source: security@huntr.dev
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/vim/vim/commit/caea66442d86e7bbba3bf3dc202c3c0d549b9853
  - source: security@huntr.dev
    tags:
    - Exploit
    - Patch
    - Third Party Advisory
    url: https://huntr.dev/bounties/2ecb4345-2fc7-4e7f-adb0-83a20bb458f5
  - source: security@huntr.dev
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/43Y3VJPOTTY3NTREDIFUPITM2POG4ZLP/
  - source: security@huntr.dev
    tags:
    - Third Party Advisory
    url: https://security.gentoo.org/glsa/202208-32
  - source: security@huntr.dev
    url: https://security.gentoo.org/glsa/202305-16
  title: Heap-based Buffer Overflow in GitHub repository vim/vim prior to 9.0.0044.
- diff_content:
  - "--- a/src/insexpand.c\n+++ b/src/insexpand.c\n@@ -786,7 +786,8 @@ ins_compl_add(\n\
    \ \t{\n \t    if (!match_at_original_text(match)\n \t\t    && STRNCMP(match->cp_str,\
    \ str, len) == 0\n-\t\t    && match->cp_str[len] == NUL)\n+\t\t    && ((int)STRLEN(match->cp_str)\
    \ <= len\n+\t\t\t\t\t\t || match->cp_str[len] == NUL))\n \t\treturn NOTDONE;\n\
    \ \t    match = match->cp_next;\n \t} while (match != NULL && !is_first_match(match));"
  - "--- a/src/version.c\n+++ b/src/version.c\n@@ -735,6 +735,8 @@ static char *(features[])\
    \ =\n \n static int included_patches[] =\n {   /* Add new patch number below this\
    \ line */\n+/**/\n+    46,\n /**/\n     45,\n /**/"
  identifiers:
  - CVE-2022-2344
  - CWE-122
  overview: Heap-based Buffer Overflow in GitHub repository vim/vim prior to 9.0.0045.
  references:
  - source: security@huntr.dev
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/vim/vim/commit/baefde14550231f6468ac2ed2ed495bc381c0c92
  - source: security@huntr.dev
    tags:
    - Exploit
    - Patch
    - Third Party Advisory
    url: https://huntr.dev/bounties/4a095ed9-3125-464a-b656-c31b437e1996
  - source: security@huntr.dev
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/43Y3VJPOTTY3NTREDIFUPITM2POG4ZLP/
  - source: security@huntr.dev
    tags:
    - Third Party Advisory
    url: https://security.gentoo.org/glsa/202208-32
  - source: security@huntr.dev
    url: https://security.gentoo.org/glsa/202305-16
  title: Heap-based Buffer Overflow in GitHub repository vim/vim prior to 9.0.0045.
- diff_content:
  - "--- a/src/ex_cmds.c\n+++ b/src/ex_cmds.c\n@@ -3994,7 +3994,16 @@ ex_substitute(exarg_T\
    \ *eap)\n \tsub_copy = sub;\n     }\n     else\n-\tsub = regtilde(sub, magic_isset());\n\
    +    {\n+\tchar_u *newsub = regtilde(sub, magic_isset());\n+\n+\tif (newsub !=\
    \ sub)\n+\t{\n+\t    // newsub was allocated, free it later.\n+\t    sub_copy\
    \ = newsub;\n+\t    sub = newsub;\n+\t}\n+    }\n \n     /*\n      * Check for\
    \ a match on each line."
  - "--- a/src/regexp.c\n+++ b/src/regexp.c\n@@ -1766,11 +1766,11 @@ regtilde(char_u\
    \ *source, int magic)\n \t}\n     }\n \n+    // Store a copy of newsub  in reg_prev_sub.\
    \  It is always allocated,\n+    // because recursive calls may make the returned\
    \ string invalid.\n     vim_free(reg_prev_sub);\n-    if (newsub != source)\t\
    // newsub was allocated, just keep it\n-\treg_prev_sub = newsub;\n-    else\t\t\
    \t// no ~ found, need to save newsub\n-\treg_prev_sub = vim_strsave(newsub);\n\
    +    reg_prev_sub = vim_strsave(newsub);\n+\n     return newsub;\n }\n "
  - "--- a/src/version.c\n+++ b/src/version.c\n@@ -735,6 +735,8 @@ static char *(features[])\
    \ =\n \n static int included_patches[] =\n {   /* Add new patch number below this\
    \ line */\n+/**/\n+    47,\n /**/\n     46,\n /**/"
  identifiers:
  - CVE-2022-2345
  - CWE-416
  overview: Use After Free in GitHub repository vim/vim prior to 9.0.0046.
  references:
  - source: security@huntr.dev
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/vim/vim/commit/32acf1f1a72ebb9d8942b9c9d80023bf1bb668ea
  - source: security@huntr.dev
    tags:
    - Exploit
    - Patch
    - Third Party Advisory
    url: https://huntr.dev/bounties/1eed7009-db6d-487b-bc41-8f2fd260483f
  - source: security@huntr.dev
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/43Y3VJPOTTY3NTREDIFUPITM2POG4ZLP/
  - source: security@huntr.dev
    tags:
    - Third Party Advisory
    url: https://security.gentoo.org/glsa/202208-32
  - source: security@huntr.dev
    url: https://security.gentoo.org/glsa/202305-16
  title: Use After Free in GitHub repository vim/vim prior to 9.0.0046.
- diff_content:
  - "--- a/target/loongarch/cpu.c\n+++ b/target/loongarch/cpu.c\n@@ -479,6 +479,7\
    \ @@ static void loongarch_cpu_reset(DeviceState *dev)\n \n #ifndef CONFIG_USER_ONLY\n\
    \     env->pc = 0x1c000000;\n+    memset(env->tlb, 0, sizeof(env->tlb));\n #endif\n\
    \ \n     restore_fp_status(env);"
  - "--- a/target/loongarch/cpu.c\n+++ b/target/loongarch/cpu.c\n@@ -479,6 +479,7\
    \ @@ static void loongarch_cpu_reset(DeviceState *dev)\n \n #ifndef CONFIG_USER_ONLY\n\
    \     env->pc = 0x1c000000;\n+    memset(env->tlb, 0, sizeof(env->tlb));\n #endif\n\
    \ \n     restore_fp_status(env);"
  - "--- a/softmmu/physmem.c\n+++ b/softmmu/physmem.c\n@@ -669,7 +669,7 @@ void tcg_iommu_init_notifier_list(CPUState\
    \ *cpu)\n \n /* Called from RCU critical section */\n MemoryRegionSection *\n\
    -address_space_translate_for_iotlb(CPUState *cpu, int asidx, hwaddr addr,\n+address_space_translate_for_iotlb(CPUState\
    \ *cpu, int asidx, hwaddr orig_addr,\n                                   hwaddr\
    \ *xlat, hwaddr *plen,\n                                   MemTxAttrs attrs, int\
    \ *prot)\n {\n@@ -678,6 +678,7 @@ address_space_translate_for_iotlb(CPUState *cpu,\
    \ int asidx, hwaddr addr,\n     IOMMUMemoryRegionClass *imrc;\n     IOMMUTLBEntry\
    \ iotlb;\n     int iommu_idx;\n+    hwaddr addr = orig_addr;\n     AddressSpaceDispatch\
    \ *d =\n         qatomic_rcu_read(&cpu->cpu_ases[asidx].memory_dispatch);\n \n\
    @@ -722,6 +723,16 @@ address_space_translate_for_iotlb(CPUState *cpu, int asidx,\
    \ hwaddr addr,\n     return section;\n \n translate_fail:\n+    /*\n+     * We\
    \ should be given a page-aligned address -- certainly\n+     * tlb_set_page_with_attrs()\
    \ does so.  The page offset of xlat\n+     * is used to index sections[], and\
    \ PHYS_SECTION_UNASSIGNED = 0.\n+     * The page portion of xlat will be logged\
    \ by memory_region_access_valid()\n+     * when this memory access is rejected,\
    \ so use the original untranslated\n+     * physical address.\n+     */\n+   \
    \ assert((orig_addr & ~TARGET_PAGE_MASK) == 0);\n+    *xlat = orig_addr;\n   \
    \  return &d->map.sections[PHYS_SECTION_UNASSIGNED];\n }\n "
  identifiers:
  - CVE-2022-35414
  - CWE-908
  overview: 'softmmu/physmem.c in QEMU through 7.0.0 can perform an uninitialized
    read on the translate_fail path, leading to an io_readx or io_writex crash. NOTE:
    a third party states that the Non-virtualization Use Case in the qemu.org reference
    applies here, i.e., "Bugs affecting the non-virtualization use case are not considered
    security bugs at this time.'
  references:
  - source: cve@mitre.org
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/qemu/qemu/blob/f200ff158d5abcb974a6b597a962b6b2fbea2b06/softmmu/physmem.c
  - source: cve@mitre.org
    tags:
    - Release Notes
    - Third Party Advisory
    url: https://github.com/qemu/qemu/blob/v7.0.0/include/exec/cpu-all.h#L145-L148
  - source: cve@mitre.org
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/qemu/qemu/commit/3517fb726741c109cae7995f9ea46f0cab6187d6#diff-83c563ed6330dc5d49876f1116e7518b5c16654bbc6e9b4ea8e28f5833d576fcR482
  - source: cve@mitre.org
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/qemu/qemu/commit/3517fb726741c109cae7995f9ea46f0cab6187d6#diff-83c563ed6330dc5d49876f1116e7518b5c16654bbc6e9b4ea8e28f5833d576fcR482.aa
  - source: cve@mitre.org
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/qemu/qemu/commit/418ade7849ce7641c0f7333718caf5091a02fd4c
  - source: cve@mitre.org
    tags:
    - Issue Tracking
    - Mitigation
    - Patch
    - Third Party Advisory
    url: https://gitlab.com/qemu-project/qemu/-/issues/1065
  - source: cve@mitre.org
    tags:
    - Mailing List
    - Third Party Advisory
    url: https://lists.debian.org/debian-lts-announce/2022/09/msg00008.html
  - source: cve@mitre.org
    tags:
    - Exploit
    - Patch
    - Third Party Advisory
    url: https://sick.codes/sick-2022-113
  - source: cve@mitre.org
    url: https://www.mail-archive.com/qemu-devel%40nongnu.org/msg895266.html
  - source: cve@mitre.org
    tags:
    - Vendor Advisory
    url: https://www.qemu.org/docs/master/system/security.html#non-virtualization-use-case
  title: 'softmmu/physmem.c in QEMU through 7.0.0 can perform an uninitialized read
    on the translate_fail path, leading to an io_readx or io_writex crash. NOTE: a
    third party states that the Non-virtualization Use Case in the qemu.org reference
    applies here, i.e., "Bugs affecting the non-virtualization use case are not considered
    security bugs at this time.'
- diff_content:
  - "--- a/src/jwe.c\n+++ b/src/jwe.c\n@@ -1843,11 +1843,21 @@ static int r_jwe_aesgcm_key_unwrap(jwe_t\
    \ * jwe, jwa_alg alg, jwk_t * jwk, int x5\n         ret = RHN_ERROR;\n       \
    \  break;\n       }\n+      if (!o_base64url_decode((const unsigned char *)r_jwe_get_header_str_value(jwe,\
    \ \"iv\"), o_strlen(r_jwe_get_header_str_value(jwe, \"iv\")), NULL, &iv_len) ||\
    \ iv_len > 96) {\n+        y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_aesgcm_key_unwrap\
    \ - Invalid header iv\");\n+        ret = RHN_ERROR_INVALID;\n+        break;\n\
    +      }\n       if (!o_base64url_decode((const unsigned char *)r_jwe_get_header_str_value(jwe,\
    \ \"iv\"), o_strlen(r_jwe_get_header_str_value(jwe, \"iv\")), iv, &iv_len)) {\n\
    \         y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_aesgcm_key_unwrap - Error o_base64url_decode\
    \ iv\");\n         ret = RHN_ERROR_INVALID;\n         break;\n       }\n+    \
    \  if (!o_base64url_decode((const unsigned char *)jwe->encrypted_key_b64url, o_strlen((const\
    \ char *)jwe->encrypted_key_b64url), NULL, &cipherkey_len) || cipherkey_len >\
    \ 64) {\n+        y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_aesgcm_key_unwrap -\
    \ Invalid cipherkey\");\n+        ret = RHN_ERROR_INVALID;\n+        break;\n\
    +      }\n       if (!o_base64url_decode((const unsigned char *)jwe->encrypted_key_b64url,\
    \ o_strlen((const char *)jwe->encrypted_key_b64url), cipherkey, &cipherkey_len))\
    \ {\n         y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_aesgcm_key_unwrap - Error\
    \ o_base64url_decode cipherkey\");\n         ret = RHN_ERROR_INVALID;"
  identifiers:
  - CVE-2022-32096
  - CWE-120
  overview: Rhonabwy before v1.1.5 was discovered to contain a buffer overflow via
    the component r_jwe_aesgcm_key_unwrap. This vulnerability allows attackers to
    cause a Denial of Service (DoS) via a crafted JWE token.
  references:
  - source: cve@mitre.org
    tags:
    - Third Party Advisory
    url: https://github.com/babelouest/rhonabwy/
  - source: cve@mitre.org
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/babelouest/rhonabwy/commit/b4c2923a1ba4fabf9b55a89244127e153a3e549b
  title: Rhonabwy before v1.1.5 was discovered to contain a buffer overflow via the
    component r_jwe_aesgcm_key_unwrap. This vulnerability allows attackers to cause
    a Denial of Service (DoS) via a crafted JWE token.
- diff_content:
  - "--- a/src/input-bmp.c\n+++ b/src/input-bmp.c\n@@ -667,7 +667,11 @@ static unsigned\
    \ char *ReadImage(FILE * fd, int width, int height,\n           *(temp++) = row_buf[xpos\
    \ * 3 + 1];\n           *(temp++) = row_buf[xpos * 3];\n         }\n-        --ypos;\
    \                 /* next line */\n+\n+\tif (ypos == 0)\n+\t  break;\n+\n+   \
    \     --ypos; /* next line */\n       }\n     }\n     break;"
  identifiers:
  - CVE-2022-32323
  - CWE-787
  overview: AutoTrace v0.40.0 was discovered to contain a heap overflow via the ReadImage
    function at input-bmp.c:660.
  references:
  - source: cve@mitre.org
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/autotrace/autotrace/commit/2b44c173027736c64b3f379bd154c41bab745423
  - source: cve@mitre.org
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/4CZVCQH4L7KC5GXLU6SCESXR5TGSKQ2H/
  - source: cve@mitre.org
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/UKZPC4WCDOJ7BPJOMZ46AV27RCABZRYA/
  title: AutoTrace v0.40.0 was discovered to contain a heap overflow via the ReadImage
    function at input-bmp.c:660.
- diff_content:
  - "--- a/src/bifs/field_decode.c\n+++ b/src/bifs/field_decode.c\n@@ -427,64 +427,71\
    \ @@ GF_Err BD_DecMFFieldVec(GF_BifsDecoder * codec, GF_BitStream *bs, GF_Node\
    \ *node,\n \t\t\te = gf_bifs_dec_sf_field(codec, bs, node, &sffield, GF_FALSE);\n\
    \ \t\t\tif (e) return e;\n \t\t}\n-\t} else {\n-\t\tlast = NULL;\n-\t\tfor (i=0;\
    \ i<nbFields; i++) {\n-\t\t\tGF_Node *new_node = gf_bifs_dec_node(codec, bs, field->NDTtype);\n\
    -\t\t\tif (new_node) {\n-\t\t\t\te = gf_node_register(new_node, is_mem_com ? NULL\
    \ : node);\n-\t\t\t\tif (e) return e;\n-\n-\t\t\t\tif (node) {\n-\t\t\t\t\t/*special\
    \ case for QP, register as the current QP*/\n-\t\t\t\t\tif (gf_node_get_tag(new_node)\
    \ == TAG_MPEG4_QuantizationParameter) {\n-\t\t\t\t\t\tqp_local = ((M_QuantizationParameter\
    \ *)new_node)->isLocal;\n-\t\t\t\t\t\t/*we have a QP in the same scope, remove\
    \ previous\n-\t\t\t\t\t\tNB: we assume this is the right behavior, the spec doesn't\
    \ say\n-\t\t\t\t\t\twhether QP is cumulative or not*/\n-\t\t\t\t\t\tif (qp_on)\
    \ gf_bifs_dec_qp_remove(codec, GF_FALSE);\n+\t\treturn GF_OK;\n+\t}\n \n-\t\t\t\
    \t\t\te = gf_bifs_dec_qp_set(codec, new_node);\n-\t\t\t\t\t\tif (e) return e;\n\
    -\t\t\t\t\t\tqp_on = 1;\n-\t\t\t\t\t\tif (qp_local) qp_local = 2;\n-\t\t\t\t\t\
    \tif (codec->force_keep_qp) {\n-\t\t\t\t\t\t\te = gf_node_list_add_child_last(field->far_ptr,\
    \ new_node, &last);\n-\t\t\t\t\t\t\tif (e) return e;\n-\t\t\t\t\t\t} else {\n\
    -\t\t\t\t\t\t\tgf_node_register(new_node, NULL);\n-\t\t\t\t\t\t\tgf_node_unregister(new_node,\
    \ node);\n-\t\t\t\t\t\t}\n-\t\t\t\t\t} else {\n+\te = GF_OK;\n+\tlast = NULL;\n\
    +\tfor (i=0; i<nbFields; i++) {\n+\t\tGF_Node *new_node = gf_bifs_dec_node(codec,\
    \ bs, field->NDTtype);\n+\t\tif (new_node) {\n+\t\t\te = gf_node_register(new_node,\
    \ is_mem_com ? NULL : node);\n+\t\t\tif (e) goto exit;\n+\n+\t\t\tif (node) {\n\
    +\t\t\t\t/*special case for QP, register as the current QP*/\n+\t\t\t\tif (gf_node_get_tag(new_node)\
    \ == TAG_MPEG4_QuantizationParameter) {\n+\t\t\t\t\tqp_local = ((M_QuantizationParameter\
    \ *)new_node)->isLocal;\n+\t\t\t\t\t/*we have a QP in the same scope, remove previous\n\
    +\t\t\t\t\tNB: we assume this is the right behavior, the spec doesn't say\n+\t\
    \t\t\t\twhether QP is cumulative or not*/\n+\t\t\t\t\tif (qp_on) gf_bifs_dec_qp_remove(codec,\
    \ GF_FALSE);\n+\n+\t\t\t\t\te = gf_bifs_dec_qp_set(codec, new_node);\n+\t\t\t\t\
    \tif (e) goto exit;\n+\t\t\t\t\tqp_on = 1;\n+\t\t\t\t\tif (qp_local) qp_local\
    \ = 2;\n+\t\t\t\t\tif (codec->force_keep_qp) {\n \t\t\t\t\t\te = gf_node_list_add_child_last(field->far_ptr,\
    \ new_node, &last);\n-\t\t\t\t\t\tif (e) return e;\n+\t\t\t\t\t\tif (e) goto exit;\n\
    +\t\t\t\t\t} else {\n+\t\t\t\t\t\tgf_node_register(new_node, NULL);\n+\t\t\t\t\
    \t\tgf_node_unregister(new_node, node);\n \t\t\t\t\t}\n+\t\t\t\t} else {\n+\t\t\
    \t\t\te = gf_node_list_add_child_last(field->far_ptr, new_node, &last);\n+\t\t\
    \t\t\tif (e) goto exit;\n \t\t\t\t}\n-\t\t\t\t/*proto coding*/\n-\t\t\t\telse\
    \ if (codec->pCurrentProto) {\n-\t\t\t\t\t/*TO DO: what happens if this is a QP\
    \ node on the interface ?*/\n-\t\t\t\t\te = gf_node_list_add_child_last( (GF_ChildNodeItem\
    \ **)field->far_ptr, new_node, &last);\n-\t\t\t\t\tif (e) return e;\n-\t\t\t\t\
    }\n-\t\t\t} else {\n-\t\t\t\treturn codec->LastError ? codec->LastError : GF_NON_COMPLIANT_BITSTREAM;\n\
    \ \t\t\t}\n+\t\t\t/*proto coding*/\n+\t\t\telse if (codec->pCurrentProto) {\n\
    +\t\t\t\t/*TO DO: what happens if this is a QP node on the interface ?*/\n+\t\t\
    \t\te = gf_node_list_add_child_last( (GF_ChildNodeItem **)field->far_ptr, new_node,\
    \ &last);\n+\t\t\t\tif (e)goto exit;\n+\t\t\t}\n+\t\t} else {\n+\t\t\te = codec->LastError\
    \ ? codec->LastError : GF_NON_COMPLIANT_BITSTREAM;\n+\t\t\tgoto exit;\n \t\t}\n\
    -\t\t/*according to the spec, the QP applies to the current node itself, not just\
    \ children.\n-\t\tIf IsLocal is TRUE remove the node*/\n-\t\tif (qp_on && qp_local)\
    \ {\n-\t\t\tif (qp_local == 2) {\n+\t}\n+\n+exit:\n+\n+\t/*according to the spec,\
    \ the QP applies to the current node itself, not just children.\n+\tIf IsLocal\
    \ is TRUE remove the node*/\n+\tif (qp_on && qp_local) {\n+\t\tif (qp_local ==\
    \ 2) {\n //\t\t\t\tqp_local = 1;\n-\t\t\t} else {\n-\t\t\t\t//ask to get rid of\
    \ QP and reactivate if we had a QP when entering the node\n-\t\t\t\tgf_bifs_dec_qp_remove(codec,\
    \ initial_qp);\n+\t\t} else {\n+\t\t\t//ask to get rid of QP and reactivate if\
    \ we had a QP when entering the node\n+\t\t\tgf_bifs_dec_qp_remove(codec, initial_qp);\n\
    \ //\t\t\t\tqp_local = 0;\n-\t\t\t}\n \t\t}\n \t}\n+\n \t/*finally delete the\
    \ QP if any (local or not) as we get out of this node*/\n \tif (qp_on) gf_bifs_dec_qp_remove(codec,\
    \ GF_TRUE);\n-\treturn GF_OK;\n+\treturn e;\n }\n \n "
  identifiers:
  - CVE-2022-2453
  - CWE-416
  overview: Use After Free in GitHub repository gpac/gpac prior to 2.1-DEV.
  references:
  - source: security@huntr.dev
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/gpac/gpac/commit/dc7de8d3d604426c7a6e628d90cb9fb88e7b4c2c
  - source: security@huntr.dev
    tags:
    - Exploit
    - Issue Tracking
    - Patch
    - Third Party Advisory
    url: https://huntr.dev/bounties/c8c964de-046a-41b2-9ff5-e25cfdb36b5a
  title: Use After Free in GitHub repository gpac/gpac prior to 2.1-DEV.
- diff_content:
  - "--- a/src/laser/lsr_dec.c\n+++ b/src/laser/lsr_dec.c\n@@ -838,6 +838,8 @@ static\
    \ void lsr_read_id(GF_LASeRCodec *lsr, GF_Node *n)\n \n static Fixed lsr_translate_coords(GF_LASeRCodec\
    \ *lsr, u32 val, u32 nb_bits)\n {\n+\tif (!nb_bits) return 0;\n+\t\n #ifdef GPAC_FIXED_POINT\n\
    \ \tif (val >> (nb_bits-1) ) {\n \t\ts32 neg = (s32) val - (1<<nb_bits);"
  identifiers:
  - CVE-2022-2454
  - CWE-190
  overview: Integer Overflow or Wraparound in GitHub repository gpac/gpac prior to
    2.1-DEV.
  references:
  - source: security@huntr.dev
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/gpac/gpac/commit/faa75edde3dfeba1e2cf6ffa48e45a50f1042096
  - source: security@huntr.dev
    tags:
    - Exploit
    - Issue Tracking
    - Patch
    - Third Party Advisory
    url: https://huntr.dev/bounties/105d40d0-46d7-461e-9f8e-20c4cdea925f
  - source: security@huntr.dev
    url: https://www.debian.org/security/2023/dsa-5411
  title: Integer Overflow or Wraparound in GitHub repository gpac/gpac prior to 2.1-DEV.
- diff_content:
  - "--- a/lib/gssapi/server.c\n+++ b/lib/gssapi/server.c\n@@ -218,6 +218,9 @@ _gsasl_gssapi_server_step\
    \ (Gsasl_session * sctx,\n          FALSE, and responds with the generated output_message.\
    \  The\n          client can then consider the server authenticated. */\n \n+\
    \      if (bufdesc2.length < 4)\n+\treturn GSASL_AUTHENTICATION_ERROR;\n+\n  \
    \     if ((((char *) bufdesc2.value)[0] & GSASL_QOP_AUTH) == 0)\n \t{\n \t  /*\
    \ Integrity or privacy unsupported */\n"
  identifiers:
  - CVE-2022-2469
  - CWE-125
  overview: GNU SASL libgsasl server-side read-out-of-bounds with malicious authenticated
    GSS-API client
  references:
  - source: cve@gitlab.com
    tags:
    - Third Party Advisory
    - VDB Entry
    url: https://gitlab.com/gitlab-org/cves/-/blob/master/2022/CVE-2022-2469.json
  - source: cve@gitlab.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://gitlab.com/gsasl/gsasl/-/commit/796e4197f696261c1f872d7576371232330bcc30
  - source: cve@gitlab.com
    tags:
    - Third Party Advisory
    url: https://www.debian.org/security/2022/dsa-5189
  title: GNU SASL libgsasl server-side read-out-of-bounds with malicious authenticated
    GSS-API client
- diff_content:
  - "--- a/src/autocmd.c\n+++ b/src/autocmd.c\n@@ -2209,9 +2209,13 @@ apply_autocmds_group(\n\
    \ \t    ap->last = FALSE;\n \tap->last = TRUE;\n \n+\t// Make sure cursor and\
    \ topline are valid.  The first time the current\n+\t// values are saved, restored\
    \ by reset_lnums().  When nested only the\n+\t// values are corrected when needed.\n\
    \ \tif (nesting == 1)\n-\t    // make sure cursor and topline are valid\n \t \
    \   check_lnums(TRUE);\n+\telse\n+\t    check_lnums_nested(TRUE);\n \n \tsave_did_emsg\
    \ = did_emsg;\n "
  - "--- a/src/version.c\n+++ b/src/version.c\n@@ -735,6 +735,8 @@ static char *(features[])\
    \ =\n \n static int included_patches[] =\n {   /* Add new patch number below this\
    \ line */\n+/**/\n+    61,\n /**/\n     60,\n /**/"
  - "--- a/src/window.c\n+++ b/src/window.c\n@@ -6770,34 +6770,55 @@ only_one_window(void)\n\
    \ }\n \n /*\n- * Correct the cursor line number in other windows.  Used after\
    \ changing the\n- * current buffer, and before applying autocommands.\n- * When\
    \ \"do_curwin\" is TRUE, also check current window.\n+ * Implementation of check_lnums()\
    \ and check_lnums_nested().\n  */\n-    void\n-check_lnums(int do_curwin)\n+ \
    \   static void\n+check_lnums_both(int do_curwin, int nested)\n {\n     win_T\t\
    *wp;\n     tabpage_T\t*tp;\n \n     FOR_ALL_TAB_WINDOWS(tp, wp)\n \tif ((do_curwin\
    \ || wp != curwin) && wp->w_buffer == curbuf)\n \t{\n-\t    // save the original\
    \ cursor position and topline\n-\t    wp->w_save_cursor.w_cursor_save = wp->w_cursor;\n\
    -\t    wp->w_save_cursor.w_topline_save = wp->w_topline;\n+\t    if (!nested)\n\
    +\t    {\n+\t\t// save the original cursor position and topline\n+\t\twp->w_save_cursor.w_cursor_save\
    \ = wp->w_cursor;\n+\t\twp->w_save_cursor.w_topline_save = wp->w_topline;\n+\t\
    \    }\n \n \t    if (wp->w_cursor.lnum > curbuf->b_ml.ml_line_count)\n \t\twp->w_cursor.lnum\
    \ = curbuf->b_ml.ml_line_count;\n \t    if (wp->w_topline > curbuf->b_ml.ml_line_count)\n\
    \ \t\twp->w_topline = curbuf->b_ml.ml_line_count;\n \n-\t    // save the corrected\
    \ cursor position and topline\n+\t    // save the (corrected) cursor position\
    \ and topline\n \t    wp->w_save_cursor.w_cursor_corr = wp->w_cursor;\n \t   \
    \ wp->w_save_cursor.w_topline_corr = wp->w_topline;\n \t}\n }\n \n+/*\n+ * Correct\
    \ the cursor line number in other windows.  Used after changing the\n+ * current\
    \ buffer, and before applying autocommands.\n+ * When \"do_curwin\" is TRUE, also\
    \ check current window.\n+ */\n+    void\n+check_lnums(int do_curwin)\n+{\n+ \
    \   check_lnums_both(do_curwin, FALSE);\n+}\n+\n+/*\n+ * Like check_lnums() but\
    \ for when check_lnums() was already called.\n+ */\n+    void\n+check_lnums_nested(int\
    \ do_curwin)\n+{\n+    check_lnums_both(do_curwin, TRUE);\n+}\n+\n /*\n  * Reset\
    \ cursor and topline to its stored values from check_lnums().\n  * check_lnums()\
    \ must have been called first!"
  - "--- a/src/insexpand.c\n+++ b/src/insexpand.c\n@@ -642,6 +642,7 @@ ins_compl_infercase_gettext(\n\
    \ \t    // growarray.  Add the character in the next round.\n \t    if (ga_grow(&gap,\
    \ IOSIZE) == FAIL)\n \t\treturn (char_u *)\"[failed]\";\n+\t    *p = NUL;\n \t\
    \    STRCPY(gap.ga_data, IObuff);\n \t    gap.ga_len = (int)STRLEN(IObuff);\n\
    \ \t}"
  - "--- a/src/version.c\n+++ b/src/version.c\n@@ -735,6 +735,8 @@ static char *(features[])\
    \ =\n \n static int included_patches[] =\n {   /* Add new patch number below this\
    \ line */\n+/**/\n+    60,\n /**/\n     59,\n /**/"
  identifiers:
  - CVE-2022-2522
  - CWE-122
  overview: Heap-based Buffer Overflow in GitHub repository vim/vim prior to 9.0.0061.
  references:
  - source: security@huntr.dev
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/vim/vim/commit/5fa9f23a63651a8abdb074b4fc2ec9b1adc6b089
  - source: security@huntr.dev
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/vim/vim/commit/b9e717367c395490149495cf375911b5d9de889e
  - source: security@huntr.dev
    tags:
    - Exploit
    - Patch
    - Third Party Advisory
    url: https://huntr.dev/bounties/3a2d83af-9542-4d93-8784-98b115135a22
  - source: security@huntr.dev
    tags:
    - Exploit
    - Third Party Advisory
    url: https://huntr.dev/bounties/3a2d83af-9542-4d93-8784-98b115135a22/
  - source: security@huntr.dev
    url: https://security.gentoo.org/glsa/202305-16
  title: Heap-based Buffer Overflow in GitHub repository vim/vim prior to 9.0.0061.
- diff_content:
  - "--- a/net/xfrm/xfrm_policy.c\n+++ b/net/xfrm/xfrm_policy.c\n@@ -2678,8 +2678,10\
    \ @@ static int xfrm_expand_policies(const struct flowi *fl, u16 family,\n \t\t\
    *num_xfrms = 0;\n \t\treturn 0;\n \t}\n-\tif (IS_ERR(pols[0]))\n+\tif (IS_ERR(pols[0]))\
    \ {\n+\t\t*num_pols = 0;\n \t\treturn PTR_ERR(pols[0]);\n+\t}\n \n \t*num_xfrms\
    \ = pols[0]->xfrm_nr;\n \n@@ -2694,6 +2696,7 @@ static int xfrm_expand_policies(const\
    \ struct flowi *fl, u16 family,\n \t\tif (pols[1]) {\n \t\t\tif (IS_ERR(pols[1]))\
    \ {\n \t\t\t\txfrm_pols_put(pols, *num_pols);\n+\t\t\t\t*num_pols = 0;\n \t\t\t\
    \treturn PTR_ERR(pols[1]);\n \t\t\t}\n \t\t\t(*num_pols)++;"
  identifiers:
  - CVE-2022-36879
  - NVD-CWE-Other
  overview: An issue was discovered in the Linux kernel through 5.18.14. xfrm_expand_policies
    in net/xfrm/xfrm_policy.c can cause a refcount to be dropped twice.
  references:
  - source: cve@mitre.org
    tags:
    - Mailing List
    - Patch
    - Third Party Advisory
    url: https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit?id=f85daf0e725358be78dfd208dea5fd665d8cb901
  - source: cve@mitre.org
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/torvalds/linux/commit/f85daf0e725358be78dfd208dea5fd665d8cb901
  - source: cve@mitre.org
    tags:
    - Mailing List
    - Third Party Advisory
    url: https://lists.debian.org/debian-lts-announce/2022/09/msg00011.html
  - source: cve@mitre.org
    tags:
    - Mailing List
    - Third Party Advisory
    url: https://lists.debian.org/debian-lts-announce/2022/10/msg00000.html
  - source: cve@mitre.org
    tags:
    - Third Party Advisory
    url: https://security.netapp.com/advisory/ntap-20220901-0007/
  - source: cve@mitre.org
    tags:
    - Third Party Advisory
    url: https://www.debian.org/security/2022/dsa-5207
  title: An issue was discovered in the Linux kernel through 5.18.14. xfrm_expand_policies
    in net/xfrm/xfrm_policy.c can cause a refcount to be dropped twice.
- diff_content:
  - "--- a/src/scene_manager/scene_dump.c\n+++ b/src/scene_manager/scene_dump.c\n\
    @@ -785,7 +785,7 @@ static void gf_dump_vrml_simple_field(GF_SceneDumper *sdump,\
    \ GF_FieldInfo field,\n \t\t} else {\n \t\t\tStartAttribute(sdump, \"value\");\n\
    \ \t\t}\n-\t\tfor (i=0; i<mffield->count; i++) {\n+\t\tfor (i=0; mffield && (i<mffield->count);\
    \ i++) {\n \t\t\tif (i) gf_fprintf(sdump->trace, \" \");\n \t\t\tgf_sg_vrml_mf_get_item(field.far_ptr,\
    \ field.fieldType, &slot_ptr, i);\n \t\t\t/*this is to cope with single MFString\
    \ which shall appear as SF in XMT*/\n@@ -938,12 +938,10 @@ static void gf_dump_vrml_field(GF_SceneDumper\
    \ *sdump, GF_Node *node, GF_FieldInf\n \t\t}\n \n \t\tif (!sdump->XMLDump) gf_fprintf(sdump->trace,\
    \ \"[\");\n-\t\tif (mffield) {\n-\t\t\tfor (i=0; i<mffield->count; i++) {\n-\t\
    \t\t\tif (i) gf_fprintf(sdump->trace, \" \");\n-\t\t\t\tgf_sg_vrml_mf_get_item(field.far_ptr,\
    \ field.fieldType, &slot_ptr, i);\n-\t\t\t\tgf_dump_vrml_sffield(sdump, sf_type,\
    \ slot_ptr, 1, node);\n-\t\t\t}\n+\t\tfor (i=0; mffield && (i<mffield->count);\
    \ i++) {\n+\t\t\tif (i) gf_fprintf(sdump->trace, \" \");\n+\t\t\tgf_sg_vrml_mf_get_item(field.far_ptr,\
    \ field.fieldType, &slot_ptr, i);\n+\t\t\tgf_dump_vrml_sffield(sdump, sf_type,\
    \ slot_ptr, 1, node);\n \t\t}\n \t\tif (!sdump->XMLDump) gf_fprintf(sdump->trace,\
    \ \"]\");\n \n@@ -1150,7 +1148,7 @@ static void gf_dump_vrml_dyn_field(GF_SceneDumper\
    \ *sdump, GF_Node *node, GF_Fiel\n \t\t\t\t\tsdump->indent--;\n \t\t\t\t\tDUMP_IND(sdump);\n\
    \ \t\t\t\t} else {\n-\t\t\t\t\tfor (i=0; i<mffield->count; i++) {\n+\t\t\t\t\t\
    for (i=0; mffield && (i<mffield->count); i++) {\n \t\t\t\t\t\tif (i) gf_fprintf(sdump->trace,\
    \ \" \");\n \t\t\t\t\t\tif (field.fieldType != GF_SG_VRML_MFNODE) {\n \t\t\t\t\
    \t\t\tgf_sg_vrml_mf_get_item(field.far_ptr, field.fieldType, &slot_ptr, i);\n\
    @@ -1191,7 +1189,7 @@ static void gf_dump_vrml_dyn_field(GF_SceneDumper *sdump,\
    \ GF_Node *node, GF_Fiel\n \t\t\t\t\t} else {\n \t\t\t\t\t\tgf_fprintf(sdump->trace,\
    \ \" %s=\\\"\", GetXMTFieldTypeValueName(field.fieldType));\n \t\t\t\t\t}\n-\t\
    \t\t\t\tfor (i=0; i<mffield->count; i++) {\n+\t\t\t\t\tfor (i=0; mffield && (i<mffield->count);\
    \ i++) {\n \t\t\t\t\t\tif (i) gf_fprintf(sdump->trace, \" \");\n \t\t\t\t\t\t\
    if (field.fieldType != GF_SG_VRML_MFNODE) {\n \t\t\t\t\t\t\tgf_sg_vrml_mf_get_item(field.far_ptr,\
    \ field.fieldType, &slot_ptr, i);\n@@ -1262,13 +1260,11 @@ static void gf_dump_vrml_proto_field(GF_SceneDumper\
    \ *sdump, GF_Node *node, GF_Fi\n \t\t\t\t} else {\n \t\t\t\t\tgf_fprintf(sdump->trace,\
    \ \" %s=\\\"\", GetXMTFieldTypeValueName(field.fieldType));\n \t\t\t\t}\n-\t\t\
    \t\tif (mffield) {\n-\t\t\t\t\tfor (i=0; i<mffield->count; i++) {\n-\t\t\t\t\t\
    \tif (i) gf_fprintf(sdump->trace, \" \");\n-\t\t\t\t\t\tif (field.fieldType !=\
    \ GF_SG_VRML_MFNODE) {\n-\t\t\t\t\t\t\tgf_sg_vrml_mf_get_item(field.far_ptr, field.fieldType,\
    \ &slot_ptr, i);\n-\t\t\t\t\t\t\tgf_dump_vrml_sffield(sdump, sf_type, slot_ptr,\
    \ (mffield->count>1) ? 1 : 0, node);\n-\t\t\t\t\t\t}\n+\t\t\t\tfor (i=0; mffield\
    \ && (i<mffield->count); i++) {\n+\t\t\t\t\tif (i) gf_fprintf(sdump->trace, \"\
    \ \");\n+\t\t\t\t\tif (field.fieldType != GF_SG_VRML_MFNODE) {\n+\t\t\t\t\t\t\
    gf_sg_vrml_mf_get_item(field.far_ptr, field.fieldType, &slot_ptr, i);\n+\t\t\t\
    \t\t\tgf_dump_vrml_sffield(sdump, sf_type, slot_ptr, (mffield->count>1) ? 1 :\
    \ 0, node);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tgf_fprintf(sdump->trace, \"\\\"\
    />\\n\");"
  identifiers:
  - CVE-2022-2549
  - CWE-476
  overview: NULL Pointer Dereference in GitHub repository gpac/gpac prior to v2.1.0-DEV.
  references:
  - source: security@huntr.dev
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/gpac/gpac/commit/0102c5d4db7fdbf08b5b591b2a6264de33867a07
  - source: security@huntr.dev
    tags:
    - Exploit
    - Issue Tracking
    - Patch
    - Third Party Advisory
    url: https://huntr.dev/bounties/c93083dc-177c-4ba0-ba83-9d7fb29a5537
  title: NULL Pointer Dereference in GitHub repository gpac/gpac prior to v2.1.0-DEV.
- diff_content:
  - "--- a/src/main.c\n+++ b/src/main.c\n@@ -364,7 +364,7 @@ static int setup_config(int\
    \ type)\n \tif (rv < 0)\n \t\tgoto out;\n \n-\tif (is_auth_req()) {\n+\tif (booth_conf->authfile[0]\
    \ != '\\0') {\n \t\trv = read_authkey();\n \t\tif (rv < 0)\n \t\t\tgoto out;"
  identifiers:
  - CVE-2022-2553
  - CWE-287
  overview: The authfile directive in the booth config file is ignored, preventing
    use of authentication in communications from node to node. As a result, nodes
    that do not have the correct authentication key are not prevented from communicating
    with other nodes in the cluster.
  references:
  - source: secalert@redhat.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/ClusterLabs/booth/commit/35bf0b7b048d715f671eb68974fb6b4af6528c67
  - source: secalert@redhat.com
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/J4T4TTXAABVUCMPUL7XQ2PH5EYYOOQZY/
  - source: secalert@redhat.com
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/OHDOFX7NQFH3UGZZA3SGW5SVMDDHIUVD/
  - source: secalert@redhat.com
    tags:
    - Third Party Advisory
    url: https://www.debian.org/security/2022/dsa-5194
  title: The authfile directive in the booth config file is ignored, preventing use
    of authentication in communications from node to node. As a result, nodes that
    do not have the correct authentication key are not prevented from communicating
    with other nodes in the cluster.
- diff_content:
  - "--- a/squirrel/sqclass.cpp\n+++ b/squirrel/sqclass.cpp\n@@ -61,6 +61,9 @@ bool\
    \ SQClass::NewSlot(SQSharedState *ss,const SQObjectPtr &key,const SQObjectPtr\n\
    \         _defaultvalues[_member_idx(temp)].val = val;\n         return true;\n\
    \     }\n+\tif (_members->CountUsed() >= MEMBER_MAX_COUNT) {\n+\t\treturn false;\n\
    +\t}\n     if(belongs_to_static_table) {\n         SQInteger mmidx;\n        \
    \ if((sq_type(val) == OT_CLOSURE || sq_type(val) == OT_NATIVECLOSURE) &&"
  identifiers:
  - CVE-2021-41556
  - CWE-125
  overview: sqclass.cpp in Squirrel through 2.2.5 and 3.x through 3.1 allows an out-of-bounds
    read (in the core interpreter) that can lead to Code Execution. If a victim executes
    an attacker-controlled squirrel script, it is possible for the attacker to break
    out of the squirrel script sandbox even if all dangerous functionality such as
    File System functions has been disabled. An attacker might abuse this bug to target
    (for example) Cloud services that allow customization via SquirrelScripts, or
    distribute malware through video games that embed a Squirrel Engine.
  references:
  - source: cve@mitre.org
    tags:
    - Third Party Advisory
    url: http://www.squirrel-lang.org/#download
  - source: cve@mitre.org
    tags:
    - Exploit
    - Third Party Advisory
    url: https://blog.sonarsource.com/squirrel-vm-sandbox-escape/
  - source: cve@mitre.org
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/albertodemichelis/squirrel/commit/23a0620658714b996d20da3d4dd1a0dcf9b0bd98
  - source: cve@mitre.org
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/BV7SJJ44AGAX4ILIVPREIXPJ2GOG3FKV/
  - source: cve@mitre.org
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/M3FQILX7UUEERSDPMZP3MKGTMY2E7ESU/
  title: sqclass.cpp in Squirrel through 2.2.5 and 3.x through 3.1 allows an out-of-bounds
    read (in the core interpreter) that can lead to Code Execution. If a victim executes
    an attacker-controlled squirrel script, it is possible for the attacker to break
    out of the squirrel script sandbox even if all dangerous functionality such as
    File System functions has been disabled. An attacker might abuse this bug to target
    (for example) Cloud services that allow customization via SquirrelScripts, or
    distribute malware through video games that embed a Squirrel Engine.
- diff_content:
  - "--- a/png2webp.c\n+++ b/png2webp.c\n@@ -1,6 +1,6 @@\n // anti-copyright Lucy\
    \ Phipps 2022\n // vi: sw=2 tw=80\n-#define VERSION \"v1.0.4\"\n+#define VERSION\
    \ \"v1.0.5\"\n #include <errno.h>\n #include <inttypes.h>\n #include <limits.h>\n\
    @@ -319,6 +319,14 @@ static bool w2p(char *ip, char *op) {\n   }\n   size_t l\
    \ = ((uint32_t)(i[4] | (i[5] << 8) | (i[6] << 16) | (i[7] << 24))) + 8;\n   //\
    \ ^ RIFF header size\n+  if(l <= 12\n+#ifdef SSIZE_MAX\n+    || l - 12 > SSIZE_MAX\n\
    +#endif\n+  ) {\n+    PF(\"ERROR reading %s: %s\", IP, k[2]);\n+    goto w2p_close;\n\
    +  }\n   x = malloc(l);\n   if(!x) {\n     PF(\"ERROR reading %s: %s\", IP, *k);"
  identifiers:
  - CVE-2022-36752
  - CWE-787
  overview: png2webp v1.0.4 was discovered to contain an out-of-bounds write via the
    function w2p. This vulnerability is exploitable via a crafted png file.
  references:
  - source: cve@mitre.org
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/landfillbaby/png2webp/commit/8f21ad79b0cd98fc22d5b49734543101946abbff
  - source: cve@mitre.org
    tags:
    - Exploit
    - Issue Tracking
    - Patch
    - Third Party Advisory
    url: https://github.com/landfillbaby/png2webp/issues/3
  title: png2webp v1.0.4 was discovered to contain an out-of-bounds write via the
    function w2p. This vulnerability is exploitable via a crafted png file.
- diff_content:
  - "--- a/arch/x86/boot/compressed/ident_map_64.c\n+++ b/arch/x86/boot/compressed/ident_map_64.c\n\
    @@ -110,6 +110,7 @@ void kernel_add_identity_map(unsigned long start, unsigned\
    \ long end)\n void initialize_identity_maps(void *rmode)\n {\n \tunsigned long\
    \ cmdline;\n+\tstruct setup_data *sd;\n \n \t/* Exclude the encryption mask from\
    \ __PHYSICAL_MASK */\n \tphysical_mask &= ~sme_me_mask;\n@@ -163,6 +164,18 @@\
    \ void initialize_identity_maps(void *rmode)\n \tcmdline = get_cmd_line_ptr();\n\
    \ \tkernel_add_identity_map(cmdline, cmdline + COMMAND_LINE_SIZE);\n \n+\t/*\n\
    +\t * Also map the setup_data entries passed via boot_params in case they\n+\t\
    \ * need to be accessed by uncompressed kernel via the identity mapping.\n+\t\
    \ */\n+\tsd = (struct setup_data *)boot_params->hdr.setup_data;\n+\twhile (sd)\
    \ {\n+\t\tunsigned long sd_addr = (unsigned long)sd;\n+\n+\t\tkernel_add_identity_map(sd_addr,\
    \ sd_addr + sizeof(*sd) + sd->len);\n+\t\tsd = (struct setup_data *)sd->next;\n\
    +\t}\n+\n \tsev_prep_identity_maps(top_level_pgt);\n \n \t/* Load the new page-table.\
    \ */"
  - "--- a/arch/x86/kernel/head64.c\n+++ b/arch/x86/kernel/head64.c\n@@ -426,10 +426,12\
    \ @@ void __init do_early_exception(struct pt_regs *regs, int trapnr)\n \n /*\
    \ Don't add a printk in there. printk relies on the PDA which is not initialized\
    \ \n    yet. */\n-static void __init clear_bss(void)\n+void __init clear_bss(void)\n\
    \ {\n \tmemset(__bss_start, 0,\n \t       (unsigned long) __bss_stop - (unsigned\
    \ long) __bss_start);\n+\tmemset(__brk_base, 0,\n+\t       (unsigned long) __brk_limit\
    \ - (unsigned long) __brk_base);\n }\n \n static unsigned long get_cmd_line_ptr(void)"
  - "--- a/arch/x86/xen/enlighten_pv.c\n+++ b/arch/x86/xen/enlighten_pv.c\n@@ -1183,15\
    \ +1183,19 @@ static void __init xen_domu_set_legacy_features(void)\n extern void\
    \ early_xen_iret_patch(void);\n \n /* First C function to be called on Xen boot\
    \ */\n-asmlinkage __visible void __init xen_start_kernel(void)\n+asmlinkage __visible\
    \ void __init xen_start_kernel(struct start_info *si)\n {\n \tstruct physdev_set_iopl\
    \ set_iopl;\n \tunsigned long initrd_start = 0;\n \tint rc;\n \n-\tif (!xen_start_info)\n\
    +\tif (!si)\n \t\treturn;\n \n+\tclear_bss();\n+\n+\txen_start_info = si;\n+\n\
    \ \t__text_gen_insn(&early_xen_iret_patch,\n \t\t\tJMP32_INSN_OPCODE, &early_xen_iret_patch,\
    \ &xen_iret,\n \t\t\tJMP32_INSN_SIZE);"
  - "--- a/tools/objtool/check.c\n+++ b/tools/objtool/check.c\n@@ -3826,8 +3826,7\
    \ @@ static int validate_ibt(struct objtool_file *file)\n \t\t    !strcmp(sec->name,\
    \ \"__bug_table\")\t\t\t||\n \t\t    !strcmp(sec->name, \"__ex_table\")\t\t\t\
    ||\n \t\t    !strcmp(sec->name, \"__jump_table\")\t\t\t||\n-\t\t    !strcmp(sec->name,\
    \ \"__mcount_loc\")\t\t\t||\n-\t\t    !strcmp(sec->name, \"__tracepoints\"))\n\
    +\t\t    !strcmp(sec->name, \"__mcount_loc\"))\n \t\t\tcontinue;\n \n \t\tlist_for_each_entry(reloc,\
    \ &sec->reloc->reloc_list, list)"
  - "--- a/arch/x86/kernel/head64.c\n+++ b/arch/x86/kernel/head64.c\n@@ -426,7 +426,7\
    \ @@ void __init do_early_exception(struct pt_regs *regs, int trapnr)\n \n /*\
    \ Don't add a printk in there. printk relies on the PDA which is not initialized\
    \ \n    yet. */\n-static void __init clear_bss(void)\n+void __init clear_bss(void)\n\
    \ {\n \tmemset(__bss_start, 0,\n \t       (unsigned long) __bss_stop - (unsigned\
    \ long) __bss_start);"
  - "--- a/arch/x86/xen/enlighten_pv.c\n+++ b/arch/x86/xen/enlighten_pv.c\n@@ -1183,15\
    \ +1183,19 @@ static void __init xen_domu_set_legacy_features(void)\n extern void\
    \ early_xen_iret_patch(void);\n \n /* First C function to be called on Xen boot\
    \ */\n-asmlinkage __visible void __init xen_start_kernel(void)\n+asmlinkage __visible\
    \ void __init xen_start_kernel(struct start_info *si)\n {\n \tstruct physdev_set_iopl\
    \ set_iopl;\n \tunsigned long initrd_start = 0;\n \tint rc;\n \n-\tif (!xen_start_info)\n\
    +\tif (!si)\n \t\treturn;\n \n+\tclear_bss();\n+\n+\txen_start_info = si;\n+\n\
    \ \t__text_gen_insn(&early_xen_iret_patch,\n \t\t\tJMP32_INSN_OPCODE, &early_xen_iret_patch,\
    \ &xen_iret,\n \t\t\tJMP32_INSN_SIZE);"
  identifiers:
  - CVE-2022-36123
  - NVD-CWE-noinfo
  overview: The Linux kernel before 5.18.13 lacks a certain clear operation for the
    block starting symbol (.bss). This allows Xen PV guest OS users to cause a denial
    of service or gain privileges.
  references:
  - source: cve@mitre.org
    tags:
    - Release Notes
    - Third Party Advisory
    url: https://cdn.kernel.org/pub/linux/kernel/v5.x/ChangeLog-5.18.13
  - source: cve@mitre.org
    tags:
    - Exploit
    - Patch
    - Third Party Advisory
    url: https://github.com/sickcodes/security/blob/master/advisories/SICK-2022-128.md
  - source: cve@mitre.org
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/torvalds/linux/commit/74a0032b8524ee2bd4443128c0bf9775928680b0
  - source: cve@mitre.org
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/torvalds/linux/commit/96e8fc5818686d4a1591bb6907e7fdb64ef29884
  - source: cve@mitre.org
    tags:
    - Third Party Advisory
    url: https://security.netapp.com/advisory/ntap-20220901-0003/
  - source: cve@mitre.org
    tags:
    - Exploit
    - Patch
    - Third Party Advisory
    url: https://sick.codes/sick-2022-128
  title: The Linux kernel before 5.18.13 lacks a certain clear operation for the block
    starting symbol (.bss). This allows Xen PV guest OS users to cause a denial of
    service or gain privileges.
- diff_content:
  - "--- a/src/insexpand.c\n+++ b/src/insexpand.c\n@@ -3501,7 +3501,7 @@ ins_comp_get_next_word_or_line(\n\
    \     {\n \tchar_u\t*tmp_ptr = ptr;\n \n-\tif (compl_status_adding())\n+\tif (compl_status_adding()\
    \ && compl_length <= (int)STRLEN(tmp_ptr))\n \t{\n \t    tmp_ptr += compl_length;\n\
    \ \t    // Skip if already inside a word."
  - "--- a/src/version.c\n+++ b/src/version.c\n@@ -735,6 +735,8 @@ static char *(features[])\
    \ =\n \n static int included_patches[] =\n {   /* Add new patch number below this\
    \ line */\n+/**/\n+    102,\n /**/\n     101,\n /**/"
  identifiers:
  - CVE-2022-2571
  - CWE-122
  overview: Heap-based Buffer Overflow in GitHub repository vim/vim prior to 9.0.0101.
  references:
  - source: security@huntr.dev
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/vim/vim/commit/a6f9e300161f4cb54713da22f65b261595e8e614
  - source: security@huntr.dev
    tags:
    - Exploit
    - Patch
    - Third Party Advisory
    url: https://huntr.dev/bounties/2e5a1dc4-2dfb-4e5f-8c70-e1ede21f3571
  title: Heap-based Buffer Overflow in GitHub repository vim/vim prior to 9.0.0101.
- diff_content:
  - "--- a/src/typval.c\n+++ b/src/typval.c\n@@ -2090,7 +2090,19 @@ eval_string(char_u\
    \ **arg, typval_T *rettv, int evaluate, int interpolate)\n \t    // to 9 characters\
    \ (6 for the char and 3 for a modifier):\n \t    // reserve space for 5 extra.\n\
    \ \t    if (*p == '<')\n+\t    {\n+\t\tint\t\tmodifiers = 0;\n+\t\tint\t\tflags\
    \ = FSK_KEYCODE | FSK_IN_STRING;\n+\n \t\textra += 5;\n+\n+\t\t// Skip to the\
    \ '>' to avoid using '{' inside for string\n+\t\t// interpolation.\n+\t\tif (p[1]\
    \ != '*')\n+\t\t    flags |= FSK_SIMPLIFY;\n+\t\tif (find_special_key(&p, &modifiers,\
    \ flags, NULL) != 0)\n+\t\t    --p;  // leave \"p\" on the \">\"\n+\t    }\n \t\
    }\n \telse if (interpolate && (*p == '{' || *p == '}'))\n \t{"
  - "--- a/src/version.c\n+++ b/src/version.c\n@@ -735,6 +735,8 @@ static char *(features[])\
    \ =\n \n static int included_patches[] =\n {   /* Add new patch number below this\
    \ line */\n+/**/\n+    104,\n /**/\n     103,\n /**/"
  identifiers:
  - CVE-2022-2580
  - CWE-122
  overview: Heap-based Buffer Overflow in GitHub repository vim/vim prior to 9.0.0102.
  references:
  - source: security@huntr.dev
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/vim/vim/commit/1e56bda9048a9625bce6e660938c834c5c15b07d
  - source: security@huntr.dev
    tags:
    - Exploit
    - Patch
    - Third Party Advisory
    url: https://huntr.dev/bounties/c5f2f1d4-0441-4881-b19c-055acaa16249
  title: Heap-based Buffer Overflow in GitHub repository vim/vim prior to 9.0.0102.
- diff_content:
  - "--- a/src/regexp.c\n+++ b/src/regexp.c\n@@ -1641,7 +1641,11 @@ cstrchr(char_u\
    \ *s, int c)\n \t{\n \t    if (enc_utf8 && c > 0x80)\n \t    {\n-\t\tif (utf_fold(utf_ptr2char(p))\
    \ == cc)\n+\t\tint uc = utf_ptr2char(p);\n+\n+\t\t// Do not match an illegal byte.\
    \  E.g. 0xff matches 0xc3 0xbf,\n+\t\t// not 0xff.\n+\t\tif ((uc < 0x80 || uc\
    \ != *p) && utf_fold(uc) == cc)\n \t\t    return p;\n \t    }\n \t    else if\
    \ (*p == c || *p == cc)"
  - "--- a/src/version.c\n+++ b/src/version.c\n@@ -735,6 +735,8 @@ static char *(features[])\
    \ =\n \n static int included_patches[] =\n {   /* Add new patch number below this\
    \ line */\n+/**/\n+    105,\n /**/\n     104,\n /**/"
  identifiers:
  - CVE-2022-2581
  - CWE-125
  overview: Out-of-bounds Read in GitHub repository vim/vim prior to 9.0.0104.
  references:
  - source: security@huntr.dev
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/vim/vim/commit/f50940531dd57135fe60aa393ac9d3281f352d88
  - source: security@huntr.dev
    tags:
    - Exploit
    - Patch
    - Third Party Advisory
    url: https://huntr.dev/bounties/0bedbae2-82ae-46ae-aa68-1c28b309b60b
  title: Out-of-bounds Read in GitHub repository vim/vim prior to 9.0.0104.
- diff_content:
  - "--- a/src/diff.c\n+++ b/src/diff.c\n@@ -464,7 +464,10 @@ diff_mark_adjust_tp(\n\
    \ \t\t    for (i = 0; i < DB_COUNT; ++i)\n \t\t\tif (tp->tp_diffbuf[i] != NULL\
    \ && i != idx)\n \t\t\t{\n-\t\t\t    dp->df_lnum[i] -= off;\n+\t\t\t    if (dp->df_lnum[i]\
    \ > off)\n+\t\t\t\tdp->df_lnum[i] -= off;\n+\t\t\t    else\n+\t\t\t\tdp->df_lnum[i]\
    \ = 1;\n \t\t\t    dp->df_count[i] += n;\n \t\t\t}\n \t\t}\n@@ -2863,8 +2866,8\
    \ @@ ex_diffgetput(exarg_T *eap)\n \t    {\n \t\t// remember deleting the last\
    \ line of the buffer\n \t\tbuf_empty = curbuf->b_ml.ml_line_count == 1;\n-\t\t\
    ml_delete(lnum);\n-\t\t--added;\n+\t\tif (ml_delete(lnum) == OK)\n+\t\t    --added;\n\
    \ \t    }\n \t    for (i = 0; i < dp->df_count[idx_from] - start_skip - end_skip;\
    \ ++i)\n \t    {"
  - "--- a/src/version.c\n+++ b/src/version.c\n@@ -735,6 +735,8 @@ static char *(features[])\
    \ =\n \n static int included_patches[] =\n {   /* Add new patch number below this\
    \ line */\n+/**/\n+    101,\n /**/\n     100,\n /**/"
  identifiers:
  - CVE-2022-2598
  - CWE-787
  overview: 'Out-of-bounds Write to API in GitHub repository vim/vim prior to 9.0.0100.


    '
  references:
  - source: security@huntr.dev
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/vim/vim/commit/4e677b9c40ccbc5f090971b31dc2fe07bf05541d
  - source: security@huntr.dev
    tags:
    - Exploit
    - Patch
    - Third Party Advisory
    url: https://huntr.dev/bounties/2f08363a-47a2-422d-a7de-ce96a89ad08e
  - source: security@huntr.dev
    tags:
    - Mailing List
    - Third Party Advisory
    url: https://lists.debian.org/debian-lts-announce/2022/11/msg00009.html
  title: 'Out-of-bounds Write to API in GitHub repository vim/vim prior to 9.0.0100.


    '
- diff_content:
  - "--- a/src/milkyplay/LoaderXM.cpp\n+++ b/src/milkyplay/LoaderXM.cpp\n@@ -478,7\
    \ +478,7 @@ mp_sint32 LoaderXM::load(XMFileBase& f, XModule* module)\n \t\t\n\
    \ \t\t\tf.readDwords(&instr[y].size,1);\n \t\t\t\n-\t\t\tif (instr[y].size < 29)\n\
    +\t\t\tif (instr[y].size >= 4 && instr[y].size < 29)\n \t\t\t{\n \t\t\t\tmp_ubyte\
    \ buffer[29];\n \t\t\t\tmemset(buffer, 0, sizeof(buffer));"
  identifiers:
  - CVE-2022-34927
  - CWE-787
  overview: MilkyTracker v1.03.00 was discovered to contain a stack overflow via the
    component LoaderXM::load. This vulnerability is triggered when the program is
    supplied a crafted XM module file.
  references:
  - source: cve@mitre.org
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/milkytracker/MilkyTracker/commit/3a5474f9102cbdc10fbd9e7b1b2c8d3f3f45d91b
  - source: cve@mitre.org
    tags:
    - Exploit
    - Issue Tracking
    - Mitigation
    - Patch
    - Third Party Advisory
    url: https://github.com/milkytracker/MilkyTracker/issues/275
  title: MilkyTracker v1.03.00 was discovered to contain a stack overflow via the
    component LoaderXM::load. This vulnerability is triggered when the program is
    supplied a crafted XM module file.
- diff_content:
  - "--- a/Linux/src/aescrypt.c\n+++ b/Linux/src/aescrypt.c\n@@ -1,6 +1,6 @@\n /*\n\
    \  *  AES Crypt for Linux\n- *  Copyright (C) 2007-2017\n+ *  Copyright (C) 2007-2022\n\
    \  *\n  *  Contributors:\n  *      Glenn Washburn <crass@berlios.de>\n@@ -20,6\
    \ +20,8 @@\n \n #ifdef HAVE_CONFIG_H\n #include <config.h>\n+#else\n+#include\
    \ \"version.h\"\n #endif\n #include <stdio.h>\n #include <string.h>\n@@ -204,12\
    \ +206,10 @@ int encrypt_stream(FILE *infp, FILE *outfp, unsigned char* passwd,\
    \ int passlen)\n             aesrandom_close(aesrand);\n             return -1;\n\
    \         }\n-        sha256_update(  &sha_ctx,\n-                        buffer,\n\
    -                        32);\n+        sha256_update(&sha_ctx, buffer, 32);\n\
    \     }\n \n-    sha256_finish(  &sha_ctx, digest);\n+    sha256_finish(&sha_ctx,\
    \ digest);\n \n     memcpy(IV, digest, 16);\n \n@@ -222,19 +222,16 @@ int encrypt_stream(FILE\
    \ *infp, FILE *outfp, unsigned char* passwd, int passlen)\n         fprintf(stderr,\
    \ \"Error: Could not write out initialization vector\\n\");\n         return -1;\n\
    \     }\n-    \n+\n     /* Hash the IV and password 8192 times */\n     memset(digest,\
    \ 0, 32);\n     memcpy(digest, IV, 16);\n-    for(i=0; i<8192; i++)\n+    for\
    \ (i = 0; i < 8192; i++)\n     {\n-        sha256_starts(  &sha_ctx);\n-     \
    \   sha256_update(  &sha_ctx, digest, 32);\n-        sha256_update(  &sha_ctx,\n\
    -                        passwd,\n-                        (unsigned long)passlen);\n\
    -        sha256_finish(  &sha_ctx,\n-                        digest);\n+     \
    \   sha256_starts(&sha_ctx);\n+        sha256_update(&sha_ctx, digest, 32);\n\
    +        sha256_update(&sha_ctx, passwd, (unsigned long) passlen);\n+        sha256_finish(&sha_ctx,\
    \ digest);\n     }\n \n     /* Set the AES encryption key */\n@@ -427,14 +424,14\
    \ @@ int decrypt_stream(FILE *infp, FILE *outfp, unsigned char* passwd, int passlen)\n\
    \     unsigned char *head, *tail;\n     unsigned char ipad[64], opad[64];\n  \
    \   int reached_eof = 0;\n-    \n+\n     /* Read the file header */\n     if ((bytes_read\
    \ = fread(&aeshdr, 1, sizeof(aeshdr), infp)) !=\n          sizeof(aescrypt_hdr))\n\
    \     {\n         if (feof(infp))\n         {\n-            fprintf(stderr, \"\
    Error: Input file is too short.\\n\");\n+            fprintf(stderr, \"Error:\
    \ Input file is too short\\n\");\n         }\n         else\n         {\n@@ -446,7\
    \ +443,12 @@ int decrypt_stream(FILE *infp, FILE *outfp, unsigned char* passwd,\
    \ int passlen)\n     if (!(aeshdr.aes[0] == 'A' && aeshdr.aes[1] == 'E' &&\n \
    \          aeshdr.aes[2] == 'S'))\n     {\n-        fprintf(stderr, \"Error: Bad\
    \ file header (not aescrypt file or is corrupted? [%x, %x, %x])\\n\", aeshdr.aes[0],\
    \ aeshdr.aes[1], aeshdr.aes[2]);\n+        fprintf(stderr,\n+                \"\
    Error: Bad file header (not aescrypt file or is corrupted? \"\n+             \
    \   \"[%x, %x, %x])\\n\",\n+                aeshdr.aes[0],\n+                aeshdr.aes[1],\n\
    +                aeshdr.aes[2]);\n         return -1;\n     }\n \n@@ -475,7 +477,7\
    \ @@ int decrypt_stream(FILE *infp, FILE *outfp, unsigned char* passwd, int passlen)\n\
    \             {\n                 if (feof(infp))\n                 {\n-     \
    \               fprintf(stderr, \"Error: Input file is too short.\\n\");\n+  \
    \                  fprintf(stderr, \"Error: Input file is too short\\n\");\n \
    \                }\n                 else\n                 {\n@@ -491,7 +493,7\
    \ @@ int decrypt_stream(FILE *infp, FILE *outfp, unsigned char* passwd, int passlen)\n\
    \                 {\n                     if (feof(infp))\n                  \
    \   {\n-                        fprintf(stderr, \"Error: Input file is too short.\\\
    n\");\n+                        fprintf(stderr, \"Error: Input file is too short\\\
    n\");\n                     }\n                     else\n                   \
    \  {\n@@ -508,7 +510,7 @@ int decrypt_stream(FILE *infp, FILE *outfp, unsigned\
    \ char* passwd, int passlen)\n     {\n         if (feof(infp))\n         {\n-\
    \            fprintf(stderr, \"Error: Input file is too short.\\n\");\n+     \
    \       fprintf(stderr, \"Error: Input file is too short\\n\");\n         }\n\
    \         else\n         {\n@@ -520,15 +522,12 @@ int decrypt_stream(FILE *infp,\
    \ FILE *outfp, unsigned char* passwd, int passlen)\n     /* Hash the IV and password\
    \ 8192 times */\n     memset(digest, 0, 32);\n     memcpy(digest, IV, 16);\n-\
    \    for(i=0; i<8192; i++)\n+    for (i = 0; i < 8192; i++)\n     {\n-       \
    \ sha256_starts(  &sha_ctx);\n-        sha256_update(  &sha_ctx, digest, 32);\n\
    -        sha256_update(  &sha_ctx,\n-                        passwd,\n-      \
    \                  passlen);\n-        sha256_finish(  &sha_ctx,\n-          \
    \              digest);\n+        sha256_starts(&sha_ctx);\n+        sha256_update(&sha_ctx,\
    \ digest, 32);\n+        sha256_update(&sha_ctx, passwd, passlen);\n+        sha256_finish(&sha_ctx,\
    \ digest);\n     }\n \n     /* Set the AES encryption key */\n@@ -555,13 +554,13\
    \ @@ int decrypt_stream(FILE *infp, FILE *outfp, unsigned char* passwd, int passlen)\n\
    \      */\n     if (aeshdr.version >= 0x01)\n     {\n-        for(i=0; i<48; i+=16)\n\
    +        for (i = 0; i < 48; i += 16)\n         {\n             if ((bytes_read\
    \ = fread(buffer, 1, 16, infp)) != 16)\n             {\n                 if (feof(infp))\n\
    \                 {\n-                    fprintf(stderr, \"Error: Input file\
    \ is too short.\\n\");\n+                    fprintf(stderr, \"Error: Input file\
    \ is too short\\n\");\n                 }\n                 else\n           \
    \      {\n@@ -599,7 +598,7 @@ int decrypt_stream(FILE *infp, FILE *outfp, unsigned\
    \ char* passwd, int passlen)\n         {\n             if (feof(infp))\n     \
    \        {\n-                fprintf(stderr, \"Error: Input file is too short.\\\
    n\");\n+                fprintf(stderr, \"Error: Input file is too short\\n\"\
    );\n             }\n             else\n             {\n@@ -610,7 +609,9 @@ int\
    \ decrypt_stream(FILE *infp, FILE *outfp, unsigned char* passwd, int passlen)\n\
    \ \n         if (memcmp(digest, buffer, 32))\n         {\n-            fprintf(stderr,\
    \ \"Error: Message has been altered or password is incorrect\\n\");\n+       \
    \     fprintf(stderr,\n+                    \"Error: Message has been altered\
    \ or password is \"\n+                    \"incorrect\\n\");\n             return\
    \ -1;\n         }\n \n@@ -663,12 +664,12 @@ int decrypt_stream(FILE *infp, FILE\
    \ *outfp, unsigned char* passwd, int passlen)\n             /*\n             \
    \ * If there are less than 48 octets, the only valid count\n              * is\
    \ 32 for version 0 (HMAC) and 33 for version 1 or\n-             * greater files\
    \ ( file size modulo + HMAC)\n+             * greater files (file size modulo\
    \ + HMAC)\n              */\n             if ((aeshdr.version == 0x00 && bytes_read\
    \ != 32) ||\n                 (aeshdr.version >= 0x01 && bytes_read != 33))\n\
    \             {\n-                fprintf(stderr, \"Error: Input file is corrupt\
    \ (1:%u).\\n\",\n+                fprintf(stderr, \"Error: Input file is corrupt\
    \ (1:%u)\\n\",\n                         (unsigned) bytes_read);\n           \
    \      return -1;\n             }\n@@ -693,7 +694,7 @@ int decrypt_stream(FILE\
    \ *infp, FILE *outfp, unsigned char* passwd, int passlen)\n                  */\n\
    \                 if (aeshdr.last_block_size != 0)\n                 {\n-    \
    \                fprintf(stderr, \"Error: Input file is corrupt (2).\\n\");\n\
    +                    fprintf(stderr, \"Error: Input file is corrupt (2)\\n\");\n\
    \                     return -1;\n                 }\n             }\n@@ -724,7\
    \ +725,7 @@ int decrypt_stream(FILE *infp, FILE *outfp, unsigned char* passwd,\
    \ int passlen)\n                 if ((aeshdr.version == 0x00 && bytes_read > 0)\
    \ ||\n                     (aeshdr.version >= 0x01 && bytes_read != 1))\n    \
    \             {\n-                    fprintf(stderr, \"Error: Input file is corrupt\
    \ (3:%u).\\n\",\n+                    fprintf(stderr, \"Error: Input file is corrupt\
    \ (3:%u)\\n\",\n                             (unsigned) bytes_read);\n       \
    \              return -1;\n                 }\n@@ -844,11 +845,15 @@ int decrypt_stream(FILE\
    \ *infp, FILE *outfp, unsigned char* passwd, int passlen)\n     {\n         if\
    \ (aeshdr.version == 0x00)\n         {\n-            fprintf(stderr, \"Error:\
    \ Message has been altered or password is incorrect\\n\");\n+            fprintf(stderr,\n\
    +                    \"Error: Message has been altered or password is \"\n+  \
    \                  \"incorrect\\n\");\n         }\n         else\n         {\n\
    -            fprintf(stderr, \"Error: Message has been altered and should not\
    \ be trusted\\n\");\n+            fprintf(stderr,\n+                    \"Error:\
    \ Message has been altered and should not be \"\n+                    \"trusted\\\
    n\");\n         }\n \n         return -1;\n@@ -885,7 +890,9 @@ void usage(const\
    \ char *progname)\n         progname_real++;\n     }\n \n-    fprintf(stderr,\
    \ \"\\nusage: %s {-e|-d} [ { -p <password> | -k <keyfile> } ] { [-o <output filename>]\
    \ <file> | <file> [<file> ...] }\\n\\n\",\n+    fprintf(stderr,\n+           \
    \ \"\\nusage: %s {-e|-d} [ { -p <password> | -k <keyfile> } ] { [-o \"\n+    \
    \        \"<output filename>] <file> | <file> [<file> ...] }\\n\\n\",\n      \
    \       progname_real);\n }\n \n@@ -946,22 +953,25 @@ int main(int argc, char\
    \ *argv[])\n \n     /* Initialize the output filename */\n     outfile[0] = '\\\
    0';\n-    \n+\n     while ((rc = getopt(argc, argv, \"vhdek:p:o:\")) != -1)\n\
    \     {\n         switch (rc)\n         {\n             case 'h':\n          \
    \       usage(argv[0]);\n+                memset_secure(pass, 0, MAX_PASSWD_BUF);\n\
    \                 return 0;\n             case 'v':\n                 version(argv[0]);\n\
    +                memset_secure(pass, 0, MAX_PASSWD_BUF);\n                 return\
    \ 0;\n             case 'd':\n                 if (mode != UNINIT)\n         \
    \        {\n                     fprintf(stderr, \"Error: only specify one of\
    \ -d or -e\\n\");\n                     cleanup(outfile);\n+                 \
    \   memset_secure(pass, 0, MAX_PASSWD_BUF);\n                     return -1;\n\
    \                 }\n                 mode = DEC;\n@@ -971,6 +981,7 @@ int main(int\
    \ argc, char *argv[])\n                 {\n                     fprintf(stderr,\
    \ \"Error: only specify one of -d or -e\\n\");\n                     cleanup(outfile);\n\
    +                    memset_secure(pass, 0, MAX_PASSWD_BUF);\n               \
    \      return -1;\n                 }\n                 mode = ENC;\n@@ -980,6\
    \ +991,7 @@ int main(int argc, char *argv[])\n                 {\n           \
    \          fprintf(stderr, \"Error: password supplied twice\\n\");\n         \
    \            cleanup(outfile);\n+                    memset_secure(pass, 0, MAX_PASSWD_BUF);\n\
    \                     return -1;\n                 }\n                 if (optarg\
    \ != 0)\n@@ -989,13 +1001,15 @@ int main(int argc, char *argv[])\n           \
    \              fprintf(stderr,\n                                 \"Error: keyfile\
    \ cannot be read from stdin\\n\");\n                         cleanup(outfile);\n\
    +                        memset_secure(pass, 0, MAX_PASSWD_BUF);\n           \
    \              return -1;\n                     }\n \n                     passlen\
    \ = ReadKeyFile(optarg, pass);\n                     if (passlen < 0)\n      \
    \               {\n                         cleanup(outfile);\n+             \
    \           memset_secure(pass, 0, MAX_PASSWD_BUF);\n                        \
    \ return -1;\n                     }\n                     password_acquired =\
    \ 1;\n@@ -1006,17 +1020,19 @@ int main(int argc, char *argv[])\n             \
    \    {\n                     fprintf(stderr, \"Error: password supplied twice\\\
    n\");\n                     cleanup(outfile);\n+                    memset_secure(pass,\
    \ 0, MAX_PASSWD_BUF);\n                     return -1;\n                 }\n \
    \                if (optarg != 0)\n                 {\n-                    passlen\
    \ = passwd_to_utf16(  (unsigned char*) optarg,\n-                            \
    \                    strlen((char *)optarg),\n-                              \
    \                  MAX_PASSWD_LEN,\n-                                        \
    \        pass);\n+                    passlen = passwd_to_utf16((unsigned char\
    \ *) optarg,\n+                                              strlen((char *) optarg),\n\
    +                                              MAX_PASSWD_LEN,\n+            \
    \                                  pass);\n                     if (passlen <\
    \ 0)\n                     {\n                         cleanup(outfile);\n+  \
    \                      memset_secure(pass, 0, MAX_PASSWD_BUF);\n             \
    \            return -1;\n                     }\n                     password_acquired\
    \ = 1;\n@@ -1034,6 +1050,7 @@ int main(int argc, char *argv[])\n             \
    \        fprintf(stderr, \"Error opening output file %s:\", optarg);\n       \
    \              perror(\"\");\n                     cleanup(outfile);\n+      \
    \              memset_secure(pass, 0, MAX_PASSWD_BUF);\n                     return\
    \ -1;\n                 }\n                 strncpy(outfile, optarg, 1024);\n\
    @@ -1043,12 +1060,13 @@ int main(int argc, char *argv[])\n                 fprintf(stderr,\
    \ \"Error: Unknown option '%c'\\n\", rc);\n         }\n     }\n-    \n+\n    \
    \ if (optind >= argc)\n     {\n         fprintf(stderr, \"Error: No file argument\
    \ specified\\n\");\n         usage(argv[0]);\n         cleanup(outfile);\n+  \
    \      memset_secure(pass, 0, MAX_PASSWD_BUF);\n         return -1;\n     }\n\
    \ \n@@ -1057,6 +1075,7 @@ int main(int argc, char *argv[])\n         fprintf(stderr,\
    \ \"Error: -e or -d not specified\\n\");\n         usage(argv[0]);\n         cleanup(outfile);\n\
    +        memset_secure(pass, 0, MAX_PASSWD_BUF);\n         return -1;\n     }\n\
    \ \n@@ -1068,8 +1087,9 @@ int main(int argc, char *argv[])\n         switch (passlen)\n\
    \         {\n             case 0: /* no password in input */\n-              \
    \  fprintf(stderr, \"Error: No password supplied.\\n\");\n+                fprintf(stderr,\
    \ \"Error: No password supplied\\n\");\n                 cleanup(outfile);\n+\
    \                memset_secure(pass, 0, MAX_PASSWD_BUF);\n                 return\
    \ -1;\n             case AESCRYPT_READPWD_FOPEN:\n             case AESCRYPT_READPWD_FILENO:\n\
    @@ -1078,23 +1098,22 @@ int main(int argc, char *argv[])\n             case AESCRYPT_READPWD_FGETC:\n\
    \             case AESCRYPT_READPWD_TOOLONG:\n             case AESCRYPT_READPWD_ICONV:\n\
    -                fprintf(stderr, \"Error in read_password: %s.\\n\",\n+      \
    \          fprintf(stderr, \"Error in read_password: %s\\n\",\n              \
    \           read_password_error(passlen));\n                 cleanup(outfile);\n\
    +                memset_secure(pass, 0, MAX_PASSWD_BUF);\n                 return\
    \ -1;\n             case AESCRYPT_READPWD_NOMATCH:\n-                fprintf(stderr,\
    \ \"Error: Passwords don't match.\\n\");\n+                fprintf(stderr, \"\
    Error: Passwords don't match\\n\");\n                 cleanup(outfile);\n+   \
    \             memset_secure(pass, 0, MAX_PASSWD_BUF);\n                 return\
    \ -1;\n         }\n \n-        passlen = passwd_to_utf16(  pass,\n-          \
    \                          strlen((char*)pass),\n-                           \
    \         MAX_PASSWD_LEN,\n-                                    pass);\n-\n+ \
    \       // We should never get here, but \"just in case\"\n         if (passlen\
    \ < 0)\n         {\n+            fprintf(stderr, \"Error: unexpected problem reading\
    \ password\\n\");\n             cleanup(outfile);\n             /* For security\
    \ reasons, erase the password */\n             memset_secure(pass, 0, MAX_PASSWD_BUF);\n\
    @@ -1109,7 +1128,9 @@ int main(int argc, char *argv[])\n         {\n         \
    \    fclose(outfp);\n         }\n-        fprintf(stderr, \"Error: A single output\
    \ file may not be specified with multiple input files.\\n\");\n+        fprintf(stderr,\n\
    +                \"Error: A single output file may not be specified with \"\n\
    +                \"multiple input files\\n\");\n         usage(argv[0]);\n   \
    \      cleanup(outfile);\n         /* For security reasons, erase the password\
    \ */\n@@ -1129,7 +1150,9 @@ int main(int argc, char *argv[])\n               \
    \  {\n                     fclose(outfp);\n                 }\n-             \
    \   fprintf(stderr, \"Error: STDIN may not be specified with multiple input files.\\\
    n\");\n+                fprintf(stderr,\n+                        \"Error: STDIN\
    \ may not be specified with multiple input \"\n+                        \"files\\\
    n\");\n                 usage(argv[0]);\n                 cleanup(outfile);\n\
    \                 /* For security reasons, erase the password */\n@@ -1233,14\
    \ +1256,14 @@ int main(int argc, char *argv[])\n             return -1;\n    \
    \     }\n \n-        /* Reset input/output file names and desriptors */\n+   \
    \     /* Reset input/output file names and descriptors */\n         outfile[0]\
    \ = '\\0';\n         infp = NULL;\n         outfp = NULL;\n     }\n \n     /*\
    \ For security reasons, erase the password */\n     memset_secure(pass, 0, MAX_PASSWD_BUF);\n\
    -    \n+\n     return rc;\n }"
  - "--- a/Linux/src/aescrypt_keygen.c\n+++ b/Linux/src/aescrypt_keygen.c\n@@ -1,6\
    \ +1,6 @@\n /*\n  *  AES Crypt Key File Generator\n- *  Copyright (C) 2007-2017\n\
    + *  Copyright (C) 2007-2022\n  *  Paul E. Jones <paulej@packetizer.com>\n  *\n\
    \  * This software is licensed as \"freeware.\"  Permission to distribute\n@@\
    \ -24,6 +24,8 @@\n \n #ifdef HAVE_CONFIG_H\n #include <config.h>\n+#else\n+#include\
    \ \"version.h\"\n #endif\n #include <stdlib.h>\n #include <stdio.h>\n@@ -89,16\
    \ +91,13 @@ int generate_password(int length, unsigned char *password)\n     fclose(randfp);\n\
    \ \n     /* Now ensure each octet is uses the defined character set */\n-    for(i\
    \ = 0, p = pwtemp; i < length; i++, p++)\n+    for (i = 0, p = pwtemp; i < length;\
    \ i++, p++)\n     {\n         *p = pwchars[((int)(*p)) % 64];\n     }\n \n   \
    \  /* Convert the password to UTF-16LE */\n-    passlen = passwd_to_utf16(  pwtemp,\n\
    -                                length,\n-                                MAX_PASSWD_LEN,\n\
    -                                password);\n+    passlen = passwd_to_utf16(pwtemp,\
    \ length, MAX_PASSWD_LEN, password);\n \n     return passlen;\n }"
  - "--- a/Linux/src/password.c\n+++ b/Linux/src/password.c\n@@ -1,6 +1,6 @@\n /*\n\
    \  * AES Crypt for Linux\n- * Copyright (C) 2007-2017\n+ * Copyright (C) 2007-2022\n\
    \  *\n  * Contributors:\n  *     Glenn Washburn <crass@berlios.de>\n@@ -110,16\
    \ +109,10 @@ int read_password(unsigned char* buffer, encryptmode_t mode)\n #ifndef\
    \ WIN32\n     /* Open the tty */\n     ftty = fopen(\"/dev/tty\", \"r+\");\n-\
    \    if (ftty == NULL)\n-    {\n-        return AESCRYPT_READPWD_FOPEN;\n-   \
    \ }\n+    if (ftty == NULL) return AESCRYPT_READPWD_FOPEN;\n     tty = fileno(ftty);\n\
    -    if (tty < 0)\n-    {\n-        return AESCRYPT_READPWD_FILENO;\n-    }\n\
    - \n+    if (tty < 0) return AESCRYPT_READPWD_FILENO;\n+\n     /* Get the tty\
    \ attrs */\n     if (tcgetattr(tty, &t) < 0)\n     {\n@@ -222,8 +215,7 @@ int\
    \ read_password(unsigned char* buffer, encryptmode_t mode)\n             /* For\
    \ security reasons, erase the password */\n             memset_secure(pwd, 0,\
    \ MAX_PASSWD_BUF);\n             memset_secure(pwd_confirm, 0, MAX_PASSWD_BUF);\n\
    -            if (ftty != stderr)\n-                fclose(ftty);\n+          \
    \  if (ftty != stderr) fclose(ftty);\n             return AESCRYPT_READPWD_FGETC;\n\
    \         }\n \n@@ -236,39 +228,31 @@ int read_password(unsigned char* buffer,\
    \ encryptmode_t mode)\n             /* For security reasons, erase the password\
    \ */\n             memset_secure(pwd, 0, MAX_PASSWD_BUF);\n             memset_secure(pwd_confirm,\
    \ 0, MAX_PASSWD_BUF);\n-            if (ftty != stderr)\n-                fclose(ftty);\n\
    +            if (ftty != stderr) fclose(ftty);\n             return AESCRYPT_READPWD_TOOLONG;\n\
    \         }\n     }\n \n     /* Close the tty */\n-    if (ftty != stderr)\n-\
    \        fclose(ftty);\n+    if (ftty != stderr) fclose(ftty);\n \n     /* Password\
    \ must be compared only when encrypting */\n     if (mode == ENC)\n     {\n  \
    \       /* Check if passwords match */\n-        match = strcmp((char*)pwd, (char*)pwd_confirm);\n\
    +        match = strcmp((char *) pwd, (char *) pwd_confirm);\n+\n+        /* Securely\
    \ erase the memory for the confirmed password */\n         memset_secure(pwd_confirm,\
    \ 0, MAX_PASSWD_BUF);\n \n-        if (match != 0)\n-        {\n-            /*\
    \ For security reasons, erase the password */\n-            memset_secure(pwd,\
    \ 0, MAX_PASSWD_BUF);\n-            return AESCRYPT_READPWD_NOMATCH;\n-      \
    \  }\n+        /* For security reasons, erase the password */\n+        if (match\
    \ != 0) return AESCRYPT_READPWD_NOMATCH;\n     }\n \n #ifdef WIN32\n     chars_read\
    \ *= 2;\n #else\n-    chars_read = passwd_to_utf16(\n-       pwd,\n-       chars_read,\n\
    -       MAX_PASSWD_LEN,\n-       buffer);\n+    chars_read = passwd_to_utf16(pwd,\
    \ chars_read, MAX_PASSWD_LEN, buffer);\n \n     if (chars_read < 0) {\n      \
    \   memset_secure(pwd_confirm, 0, MAX_PASSWD_BUF);\n@@ -290,29 +274,35 @@ int\
    \ passwd_to_utf16(unsigned char *in_passwd,\n                     int max_length,\n\
    \                     unsigned char *out_passwd)\n {\n+    // Perform a password\
    \ length check before proceeding\n+    if (length > max_length)\n+    {\n+   \
    \     fprintf(stderr, \"Error: password too long\\n\");\n+        return -1;\n\
    +    }\n+\n #ifdef WIN32\n     int ret;\n     (void)length;\n-    ret = MultiByteToWideChar(\n\
    -        CP_ACP,\n-        0,\n-        (LPCSTR)in_passwd,\n-        -1,\n-  \
    \      (LPWSTR)out_passwd,\n-        max_length / 2\n-    );\n+    ret = MultiByteToWideChar(CP_ACP,\n\
    +                              0,\n+                              (LPCSTR) in_passwd,\n\
    +                              -1,\n+                              (LPWSTR) out_passwd,\n\
    +                              max_length / 2);\n     if (ret == 0)\n        \
    \ return AESCRYPT_READPWD_ICONV;\n     return ret * 2;\n #else\n #ifndef ENABLE_ICONV\n\
    \     /* support only latin */\n     int i;\n-    for (i=0;i<length+1;i++) {\n\
    -        out_passwd[i*2] = in_passwd[i];\n-        out_passwd[i*2+1] = 0;\n+ \
    \   for (i = 0; i < length + 1; i++)\n+    {\n+        out_passwd[i * 2] = in_passwd[i];\n\
    +        out_passwd[i * 2 + 1] = 0;\n     }\n-    return length*2;\n+    return\
    \ length * 2;\n #else\n     unsigned char *ic_outbuf,\n                   *ic_inbuf;"
  identifiers:
  - CVE-2022-35928
  - CWE-1284
  overview: AES Crypt is a file encryption software for multiple platforms. AES Crypt
    for Linux built using the source on GitHub and having the version number 3.11
    has a vulnerability with respect to reading user-provided passwords and confirmations
    via command-line prompts. Passwords lengths were not checked before being read.
    This vulnerability may lead to buffer overruns. This does _not_ affect source
    code found on aescrypt.com, nor is the vulnerability present when providing a
    password or a key via the `-p` or `-k` command-line options. The problem was fixed
    via in commit 68761851b and will be included in release 3.16. Users are advised
    to upgrade. Users unable to upgrade should us the `-p` or `-k` options to provide
    a password or key.
  references:
  - source: security-advisories@github.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/paulej/AESCrypt/commit/68761851b595e96c68c3f46bfc21167e72c6a22c
  - source: security-advisories@github.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/paulej/AESCrypt/security/advisories/GHSA-r7fv-72pg-fwrq
  title: AES Crypt is a file encryption software for multiple platforms. AES Crypt
    for Linux built using the source on GitHub and having the version number 3.11
    has a vulnerability with respect to reading user-provided passwords and confirmations
    via command-line prompts. Passwords lengths were not checked before being read.
    This vulnerability may lead to buffer overruns. This does _not_ affect source
    code found on aescrypt.com, nor is the vulnerability present when providing a
    password or a key via the `-p` or `-k` command-line options. The problem was fixed
    via in commit 68761851b and will be included in release 3.16. Users are advised
    to upgrade. Users unable to upgrade should us the `-p` or `-k` options to provide
    a password or key.
- diff_content:
  - "--- a/v4l2loopback.c\n+++ b/v4l2loopback.c\n@@ -756,7 +756,7 @@ static int vidioc_querycap(struct\
    \ file *file, void *priv,\n \t__u32 capabilities = V4L2_CAP_STREAMING | V4L2_CAP_READWRITE;\n\
    \ \n \tstrlcpy(cap->driver, \"v4l2 loopback\", sizeof(cap->driver));\n-\tsnprintf(cap->card,\
    \ labellen, dev->card_label);\n+\tsnprintf(cap->card, labellen, \"%s\", dev->card_label);\n\
    \ \tsnprintf(cap->bus_info, sizeof(cap->bus_info),\n \t\t \"platform:v4l2loopback-%03d\"\
    , device_nr);\n \n@@ -2494,7 +2494,7 @@ static int v4l2_loopback_add(struct v4l2_loopback_config\
    \ *conf, int *ret_nr)\n \t}\n \n \tMARK();\n-\tsnprintf(dev->vdev->name, sizeof(dev->vdev->name),\
    \ dev->card_label);\n+\tsnprintf(dev->vdev->name, sizeof(dev->vdev->name), \"\
    %s\", dev->card_label);\n \n \tvdev_priv->device_nr = nr;\n "
  identifiers:
  - CVE-2022-2652
  - CWE-134
  overview: Depending on the way the format strings in the card label are crafted
    it's possible to leak kernel stack memory. There is also the possibility for DoS
    due to the v4l2loopback kernel module crashing when providing the card label on
    request (reproduce e.g. with many %s modifiers in a row).
  references:
  - source: security@huntr.dev
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/umlaeute/v4l2loopback/commit/e4cd225557486c420f6a34411f98c575effd43dd
  - source: security@huntr.dev
    tags:
    - Exploit
    - Issue Tracking
    - Patch
    - Third Party Advisory
    url: https://huntr.dev/bounties/1b055da5-7a9e-4409-99d7-030280d242d5
  title: Depending on the way the format strings in the card label are crafted it's
    possible to leak kernel stack memory. There is also the possibility for DoS due
    to the v4l2loopback kernel module crashing when providing the card label on request
    (reproduce e.g. with many %s modifiers in a row).
- diff_content:
  - "--- a/inflate.c\n+++ b/inflate.c\n@@ -763,9 +763,10 @@ int flush;\n         \
    \        copy = state->length;\n                 if (copy > have) copy = have;\n\
    \                 if (copy) {\n+                    len = state->head->extra_len\
    \ - state->length;\n                     if (state->head != Z_NULL &&\n-     \
    \                   state->head->extra != Z_NULL) {\n-                       \
    \ len = state->head->extra_len - state->length;\n+                        state->head->extra\
    \ != Z_NULL &&\n+                        len < state->head->extra_max) {\n   \
    \                      zmemcpy(state->head->extra + len, next,\n             \
    \                    len + copy > state->head->extra_max ?\n                 \
    \                state->head->extra_max - len : copy);"
  identifiers:
  - CVE-2022-37434
  - CWE-787
  overview: 'zlib through 1.2.12 has a heap-based buffer over-read or buffer overflow
    in inflate in inflate.c via a large gzip header extra field. NOTE: only applications
    that call inflateGetHeader are affected. Some common applications bundle the affected
    zlib source code but may be unable to call inflateGetHeader (e.g., see the nodejs/node
    reference).'
  references:
  - source: cve@mitre.org
    tags:
    - Mailing List
    - Third Party Advisory
    url: http://seclists.org/fulldisclosure/2022/Oct/37
  - source: cve@mitre.org
    tags:
    - Mailing List
    - Third Party Advisory
    url: http://seclists.org/fulldisclosure/2022/Oct/38
  - source: cve@mitre.org
    tags:
    - Mailing List
    - Third Party Advisory
    url: http://seclists.org/fulldisclosure/2022/Oct/41
  - source: cve@mitre.org
    tags:
    - Mailing List
    - Third Party Advisory
    url: http://seclists.org/fulldisclosure/2022/Oct/42
  - source: cve@mitre.org
    tags:
    - Mailing List
    - Third Party Advisory
    url: http://www.openwall.com/lists/oss-security/2022/08/05/2
  - source: cve@mitre.org
    tags:
    - Mailing List
    - Patch
    - Third Party Advisory
    url: http://www.openwall.com/lists/oss-security/2022/08/09/1
  - source: cve@mitre.org
    tags:
    - Exploit
    - Issue Tracking
    - Third Party Advisory
    url: https://github.com/curl/curl/issues/9271
  - source: cve@mitre.org
    tags:
    - Exploit
    - Third Party Advisory
    url: https://github.com/ivd38/zlib_overflow
  - source: cve@mitre.org
    tags:
    - Exploit
    - Third Party Advisory
    url: https://github.com/madler/zlib/blob/21767c654d31d2dccdde4330529775c6c5fd5389/zlib.h#L1062-L1063
  - source: cve@mitre.org
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/madler/zlib/commit/eff308af425b67093bab25f80f1ae950166bece1
  - source: cve@mitre.org
    tags:
    - Exploit
    - Third Party Advisory
    url: https://github.com/nodejs/node/blob/75b68c6e4db515f76df73af476eccf382bbcb00a/deps/zlib/inflate.c#L762-L764
  - source: cve@mitre.org
    tags:
    - Mailing List
    - Third Party Advisory
    url: https://lists.debian.org/debian-lts-announce/2022/09/msg00012.html
  - source: cve@mitre.org
    tags:
    - Mailing List
    - Third Party Advisory
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/JWN4VE3JQR4O2SOUS5TXNLANRPMHWV4I/
  - source: cve@mitre.org
    tags:
    - Mailing List
    - Third Party Advisory
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/NMBOJ77A7T7PQCARMDUK75TE6LLESZ3O/
  - source: cve@mitre.org
    tags:
    - Mailing List
    - Third Party Advisory
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/PAVPQNCG3XRLCLNSQRM3KAN5ZFMVXVTY/
  - source: cve@mitre.org
    tags:
    - Mailing List
    - Third Party Advisory
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/X5U7OTKZSHY2I3ZFJSR2SHFHW72RKGDK/
  - source: cve@mitre.org
    tags:
    - Mailing List
    - Third Party Advisory
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/YRQAI7H4M4RQZ2IWZUEEXECBE5D56BH2/
  - source: cve@mitre.org
    tags:
    - Third Party Advisory
    url: https://security.netapp.com/advisory/ntap-20220901-0005/
  - source: cve@mitre.org
    tags:
    - Third Party Advisory
    url: https://security.netapp.com/advisory/ntap-20230427-0007/
  - source: cve@mitre.org
    tags:
    - Third Party Advisory
    url: https://support.apple.com/kb/HT213488
  - source: cve@mitre.org
    tags:
    - Third Party Advisory
    url: https://support.apple.com/kb/HT213489
  - source: cve@mitre.org
    tags:
    - Third Party Advisory
    url: https://support.apple.com/kb/HT213490
  - source: cve@mitre.org
    tags:
    - Third Party Advisory
    url: https://support.apple.com/kb/HT213491
  - source: cve@mitre.org
    tags:
    - Third Party Advisory
    url: https://support.apple.com/kb/HT213493
  - source: cve@mitre.org
    tags:
    - Third Party Advisory
    url: https://support.apple.com/kb/HT213494
  - source: cve@mitre.org
    tags:
    - Third Party Advisory
    url: https://www.debian.org/security/2022/dsa-5218
  title: 'zlib through 1.2.12 has a heap-based buffer over-read or buffer overflow
    in inflate in inflate.c via a large gzip header extra field. NOTE: only applications
    that call inflateGetHeader are affected. Some common applications bundle the affected
    zlib source code but may be unable to call inflateGetHeader (e.g., see the nodejs/node
    reference).'
- diff_content:
  - "--- a/src/src/auths/call_pam.c\n+++ b/src/src/auths/call_pam.c\n@@ -88,7 +88,7\
    \ @@ for (int i = 0; i < num_msg; i++)\n \targ = US\"\";\n \tpam_arg_ended = TRUE;\n\
    \ \t}\n-      reply[i].resp = CS string_copy_malloc(arg); /* PAM frees resp */\n\
    +      reply[i].resp = strdup(CCS arg); /* Use libc malloc, PAM frees resp directly*/\n\
    \       reply[i].resp_retcode = PAM_SUCCESS;\n       break;\n "
  identifiers:
  - CVE-2022-37451
  - CWE-763
  overview: Exim before 4.96 has an invalid free in pam_converse in auths/call_pam.c
    because store_free is not used after store_malloc.
  references:
  - source: cve@mitre.org
    tags:
    - Third Party Advisory
    url: https://cwe.mitre.org/data/definitions/762.html
  - source: cve@mitre.org
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/Exim/exim/commit/51be321b27825c01829dffd90f11bfff256f7e42
  - source: cve@mitre.org
    tags:
    - Release Notes
    - Third Party Advisory
    url: https://github.com/Exim/exim/compare/exim-4.95...exim-4.96
  - source: cve@mitre.org
    tags:
    - Release Notes
    - Third Party Advisory
    url: https://github.com/Exim/exim/wiki/EximSecurity
  - source: cve@mitre.org
    tags:
    - Exploit
    - Patch
    - Third Party Advisory
    url: https://github.com/ivd38/exim_invalid_free
  - source: cve@mitre.org
    tags:
    - Mailing List
    - Release Notes
    - Vendor Advisory
    url: https://lists.exim.org/lurker/message/20220625.141825.d6de6074.en.html
  - source: cve@mitre.org
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/LETR5CVDPFOFQHXCJP6NFLG52JZHQYDY/
  - source: cve@mitre.org
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/XSWDF4QEXD4TDWQLYQOWCHBJKTDQR4Z7/
  - source: cve@mitre.org
    tags:
    - Vendor Advisory
    url: https://www.exim.org/static/doc/security/
  - source: cve@mitre.org
    tags:
    - Mailing List
    - Third Party Advisory
    url: https://www.openwall.com/lists/oss-security/2022/08/06/1
  title: Exim before 4.96 has an invalid free in pam_converse in auths/call_pam.c
    because store_free is not used after store_malloc.
- diff_content:
  - "--- a/src/src/host.c\n+++ b/src/src/host.c\n@@ -1582,7 +1582,7 @@ Put it in permanent\
    \ memory. */\n \n   if (hosts->h_aliases)\n     {\n-    int count = 1;\n+    int\
    \ count = 1;  /* need 1 more for terminating NULL */\n     uschar **ptr;\n \n\
    \     for (uschar ** aliases = USS hosts->h_aliases; *aliases; aliases++) count++;\n\
    @@ -1691,7 +1691,7 @@ while ((ordername = string_nextinlist(&list, &sep, NULL,\
    \ 0)))\n       {\n       uschar **aptr = NULL;\n       int ssize = 264;\n-   \
    \   int count = 0;\n+      int count = 1;  /* need 1 more for terminating NULL\
    \ */\n       int old_pool = store_pool;\n \n       sender_host_dnssec = dns_is_secure(dnsa);"
  identifiers:
  - CVE-2022-37452
  - CWE-787
  overview: Exim before 4.95 has a heap-based buffer overflow for the alias list in
    host_name_lookup in host.c when sender_host_name is set.
  references:
  - source: cve@mitre.org
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/Exim/exim/commit/d4bc023436e4cce7c23c5f8bb5199e178b4cc743
  - source: cve@mitre.org
    tags:
    - Patch
    - Release Notes
    - Third Party Advisory
    url: https://github.com/Exim/exim/compare/exim-4.94...exim-4.95
  - source: cve@mitre.org
    tags:
    - Release Notes
    - Third Party Advisory
    url: https://github.com/Exim/exim/wiki/EximSecurity
  - source: cve@mitre.org
    tags:
    - Exploit
    - Patch
    - Third Party Advisory
    url: https://github.com/ivd38/exim_overflow
  - source: cve@mitre.org
    tags:
    - Mailing List
    - Third Party Advisory
    url: https://lists.debian.org/debian-lts-announce/2022/08/msg00014.html
  - source: cve@mitre.org
    tags:
    - Vendor Advisory
    url: https://www.exim.org/static/doc/security/
  - source: cve@mitre.org
    tags:
    - Mailing List
    - Third Party Advisory
    url: https://www.openwall.com/lists/oss-security/2022/08/06/8
  title: Exim before 4.95 has a heap-based buffer overflow for the alias list in host_name_lookup
    in host.c when sender_host_name is set.
- diff_content:
  - "--- a/src/version.c\n+++ b/src/version.c\n@@ -735,6 +735,8 @@ static char *(features[])\
    \ =\n \n static int included_patches[] =\n {   /* Add new patch number below this\
    \ line */\n+/**/\n+    211,\n /**/\n     210,\n /**/"
  - "--- a/src/vim9cmds.c\n+++ b/src/vim9cmds.c\n@@ -188,10 +188,17 @@ compile_lock_unlock(\n\
    \     size_t\tlen;\n     char_u\t*buf;\n     isntype_T\tisn = ISN_EXEC;\n+   \
    \ char\t*cmd = eap->cmdidx == CMD_lockvar ? \"lockvar\" : \"unlockvar\";\n \n\
    \     if (cctx->ctx_skip == SKIP_YES)\n \treturn OK;\n \n+    if (*p == NUL)\n\
    +    {\n+\tsemsg(_(e_argument_required_for_str), cmd);\n+\treturn FAIL;\n+   \
    \ }\n+\n     // Cannot use :lockvar and :unlockvar on local variables.\n     if\
    \ (p[1] != ':')\n     {\n@@ -223,8 +230,6 @@ compile_lock_unlock(\n \tret = FAIL;\n\
    \     else\n     {\n-\tchar *cmd = eap->cmdidx == CMD_lockvar ? \"lockvar\" :\
    \ \"unlockvar\";\n-\n \tif (deep < 0)\n \t    vim_snprintf((char *)buf, len, \"\
    %s! %s\", cmd, p);\n \telse"
  identifiers:
  - CVE-2022-2819
  - CWE-122
  overview: Heap-based Buffer Overflow in GitHub repository vim/vim prior to 9.0.0211.
  references:
  - source: security@huntr.dev
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/vim/vim/commit/d1d8f6bacb489036d0fd479c9dd3c0102c988889
  - source: security@huntr.dev
    tags:
    - Exploit
    - Patch
    - Third Party Advisory
    url: https://huntr.dev/bounties/0a9bd71e-66b8-4eb1-9566-7dfd9b097e59
  - source: security@huntr.dev
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/CHFAR6OY6G77M6GXCJT75A4KITLNR6GO/
  - source: security@huntr.dev
    url: https://security.gentoo.org/glsa/202305-16
  title: Heap-based Buffer Overflow in GitHub repository vim/vim prior to 9.0.0211.
- diff_content:
  - "--- a/src/script/lua_api/l_settings.cpp\n+++ b/src/script/lua_api/l_settings.cpp\n\
    @@ -27,9 +27,11 @@ with this program; if not, write to the Free Software Foundation,\
    \ Inc.,\n #include \"log.h\"\n \n \n-/* This protects:\n- * 'secure.*' settings\
    \ from being set\n- * some mapgen settings from being set\n+/* This protects the\
    \ following from being set:\n+ * 'secure.*' settings\n+ * some security-relevant\
    \ settings\n+ *   (better solution pending)\n+ * some mapgen settings\n  *   (not\
    \ security-criticial, just to avoid messing up user configs)\n  */\n #define CHECK_SETTING_SECURITY(L,\
    \ name) \\\n@@ -41,7 +43,7 @@ with this program; if not, write to the Free Software\
    \ Foundation, Inc.,\n static inline int checkSettingSecurity(lua_State* L, const\
    \ std::string &name)\n {\n \tif (ScriptApiSecurity::isSecure(L) && name.compare(0,\
    \ 7, \"secure.\") == 0)\n-\t\tthrow LuaError(\"Attempt to set secure setting.\"\
    );\n+\t\tthrow LuaError(\"Attempted to set secure setting.\");\n \n \tbool is_mainmenu\
    \ = false;\n #ifndef SERVER\n@@ -54,6 +56,17 @@ static inline int checkSettingSecurity(lua_State*\
    \ L, const std::string &name)\n \t\treturn -1;\n \t}\n \n+\tconst char *disallowed[]\
    \ = {\n+\t\t\"main_menu_script\", \"shader_path\", \"texture_path\", \"screenshot_path\"\
    ,\n+\t\t\"serverlist_file\", \"serverlist_url\", \"map-dir\", \"contentdb_url\"\
    ,\n+\t};\n+\tif (!is_mainmenu) {\n+\t\tfor (const char *name2 : disallowed) {\n\
    +\t\t\tif (name == name2)\n+\t\t\t\tthrow LuaError(\"Attempted to set disallowed\
    \ setting.\");\n+\t\t}\n+\t}\n+\n \treturn 0;\n }\n "
  identifiers:
  - CVE-2022-35978
  - NVD-CWE-noinfo
  overview: Minetest is a free open-source voxel game engine with easy modding and
    game creation. In **single player**, a mod can set a global setting that controls
    the Lua script loaded to display the main menu. The script is then loaded as soon
    as the game session is exited. The Lua environment the menu runs in is not sandboxed
    and can directly interfere with the user's system. There are currently no known
    workarounds.
  references:
  - source: security-advisories@github.com
    tags:
    - Release Notes
    - Vendor Advisory
    url: https://dev.minetest.net/Changelog#5.5.0_.E2.86.92_5.6.0
  - source: security-advisories@github.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/minetest/minetest/commit/da71e86633d0b27cd02d7aac9fdac625d141ca13
  - source: security-advisories@github.com
    tags:
    - Third Party Advisory
    url: https://github.com/minetest/minetest/security/advisories/GHSA-663q-pcjw-27cc
  title: Minetest is a free open-source voxel game engine with easy modding and game
    creation. In **single player**, a mod can set a global setting that controls the
    Lua script loaded to display the main menu. The script is then loaded as soon
    as the game session is exited. The Lua environment the menu runs in is not sandboxed
    and can directly interfere with the user's system. There are currently no known
    workarounds.
- diff_content:
  - "--- a/src/version.c\n+++ b/src/version.c\n@@ -735,6 +735,8 @@ static char *(features[])\
    \ =\n \n static int included_patches[] =\n {   /* Add new patch number below this\
    \ line */\n+/**/\n+    212,\n /**/\n     211,\n /**/"
  - "--- a/src/vim9cmds.c\n+++ b/src/vim9cmds.c\n@@ -92,6 +92,12 @@ free_locals(cctx_T\
    \ *cctx)\n     int\n check_vim9_unlet(char_u *name)\n {\n+    if (*name == NUL)\n\
    +    {\n+\tsemsg(_(e_argument_required_for_str), \"unlet\");\n+\treturn FAIL;\n\
    +    }\n+\n     if (name[1] != ':' || vim_strchr((char_u *)\"gwtb\", *name) ==\
    \ NULL)\n     {\n \t// \"unlet s:var\" is allowed in legacy script."
  identifiers:
  - CVE-2022-2816
  - CWE-125
  overview: Out-of-bounds Read in GitHub repository vim/vim prior to 9.0.0212.
  references:
  - source: security@huntr.dev
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/vim/vim/commit/dbdd16b62560413abcc3c8e893cc3010ccf31666
  - source: security@huntr.dev
    tags:
    - Exploit
    - Patch
    - Third Party Advisory
    url: https://huntr.dev/bounties/e2a83037-fcf9-4218-b2b9-b7507dacde58
  - source: security@huntr.dev
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/CHFAR6OY6G77M6GXCJT75A4KITLNR6GO/
  - source: security@huntr.dev
    url: https://security.gentoo.org/glsa/202305-16
  title: Out-of-bounds Read in GitHub repository vim/vim prior to 9.0.0212.
- diff_content:
  - "--- a/src/testing.c\n+++ b/src/testing.c\n@@ -597,6 +597,7 @@ f_assert_fails(typval_T\
    \ *argvars, typval_T *rettv)\n     int\t\tsave_trylevel = trylevel;\n     int\t\
    \tcalled_emsg_before = called_emsg;\n     char\t*wrong_arg_msg = NULL;\n+    char_u\t\
    *tofree = NULL;\n \n     if (check_for_string_or_number_arg(argvars, 0) == FAIL\n\
    \ \t    || check_for_opt_string_or_list_arg(argvars, 1) == FAIL\n@@ -660,13 +661,17\
    \ @@ f_assert_fails(typval_T *argvars, typval_T *rettv)\n \t    }\n \t    else\
    \ if (list->lv_len == 2)\n \t    {\n-\t\ttv = &list->lv_u.mat.lv_last->li_tv;\n\
    -\t\tactual = get_vim_var_str(VV_ERRMSG);\n-\t\texpected = tv_get_string_buf_chk(tv,\
    \ buf);\n-\t\tif (!pattern_match(expected, actual, FALSE))\n+\t\t// make a copy,\
    \ an error in pattern_match() may free it\n+\t\ttofree = actual = vim_strsave(get_vim_var_str(VV_ERRMSG));\n\
    +\t\tif (actual != NULL)\n \t\t{\n-\t\t    error_found = TRUE;\n-\t\t    expected_str\
    \ = expected;\n+\t\t    tv = &list->lv_u.mat.lv_last->li_tv;\n+\t\t    expected\
    \ = tv_get_string_buf_chk(tv, buf);\n+\t\t    if (!pattern_match(expected, actual,\
    \ FALSE))\n+\t\t    {\n+\t\t\terror_found = TRUE;\n+\t\t\texpected_str = expected;\n\
    +\t\t    }\n \t\t}\n \t    }\n \t}\n@@ -749,6 +754,7 @@ f_assert_fails(typval_T\
    \ *argvars, typval_T *rettv)\n     msg_scrolled = 0;\n     lines_left = Rows;\n\
    \     VIM_CLEAR(emsg_assert_fails_msg);\n+    vim_free(tofree);\n     set_vim_var_string(VV_ERRMSG,\
    \ NULL, 0);\n     if (wrong_arg_msg != NULL)\n \temsg(_(wrong_arg_msg));"
  - "--- a/src/version.c\n+++ b/src/version.c\n@@ -735,6 +735,8 @@ static char *(features[])\
    \ =\n \n static int included_patches[] =\n {   /* Add new patch number below this\
    \ line */\n+/**/\n+    213,\n /**/\n     212,\n /**/"
  identifiers:
  - CVE-2022-2817
  - CWE-416
  overview: Use After Free in GitHub repository vim/vim prior to 9.0.0213.
  references:
  - source: security@huntr.dev
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/vim/vim/commit/249e1b903a9c0460d618f6dcc59aeb8c03b24b20
  - source: security@huntr.dev
    tags:
    - Exploit
    - Patch
    - Third Party Advisory
    url: https://huntr.dev/bounties/a7b7d242-3d88-4bde-a681-6c986aff886f
  - source: security@huntr.dev
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/CHFAR6OY6G77M6GXCJT75A4KITLNR6GO/
  - source: security@huntr.dev
    url: https://security.gentoo.org/glsa/202305-16
  title: Use After Free in GitHub repository vim/vim prior to 9.0.0213.
- diff_content:
  - "--- a/src/base/LogHandler.cpp\n+++ b/src/base/LogHandler.cpp\n@@ -48,6 +48,10\
    \ @@ string LogHandler::stderrToFile(const string &pathPrefix) {\n   string current_time(buffer);\n\
    \   string stderrFilename = pathPrefix + \"_stderr_\" + current_time;\n   FILE\
    \ *stderr_stream = freopen(stderrFilename.c_str(), \"w\", stderr);\n+  fs::permissions(\n\
    +      stderrFilename,\n+      fs::perms::owner_read | fs::perms::owner_write\
    \ | fs::perms::group_read,\n+      fs::perm_options::replace);\n   if (!stderr_stream)\
    \ {\n     STFATAL << \"Invalid filename \" << stderrFilename;\n   }"
  - "--- a/src/base/PipeSocketHandler.cpp\n+++ b/src/base/PipeSocketHandler.cpp\n\
    @@ -13,7 +13,7 @@ int PipeSocketHandler::connect(const SocketEndpoint& endpoint)\
    \ {\n   FATAL_FAIL(sockFd);\n   initSocket(sockFd);\n   remote.sun_family = AF_UNIX;\n\
    -  strcpy(remote.sun_path, pipePath.c_str());\n+  strncpy(remote.sun_path, pipePath.c_str(),\
    \ sizeof(remote.sun_path));\n \n   VLOG(3) << \"Connecting to \" << endpoint <<\
    \ \" with fd \" << sockFd;\n   int result =\n@@ -104,7 +104,7 @@ set<int> PipeSocketHandler::listen(const\
    \ SocketEndpoint& endpoint) {\n   FATAL_FAIL(fd);\n   initServerSocket(fd);\n\
    \   local.sun_family = AF_UNIX; /* local is declared before socket() ^ */\n- \
    \ strcpy(local.sun_path, pipePath.c_str());\n+  strncpy(local.sun_path, pipePath.c_str(),\
    \ sizeof(local.sun_path));\n   unlink(local.sun_path);\n \n   FATAL_FAIL(::bind(fd,\
    \ (struct sockaddr*)&local, sizeof(sockaddr_un)));"
  - "--- a/src/terminal/TerminalClient.cpp\n+++ b/src/terminal/TerminalClient.cpp\n\
    @@ -14,7 +14,7 @@ vector<PortForwardSourceRequest> parseRangesToRequests(const\
    \ string& input) {\n           sourceDestination[1].find_first_not_of(\"0123456789-\"\
    ) !=\n               string::npos) {\n         PortForwardSourceRequest pfsr;\n\
    -        pfsr.mutable_source()->set_name(sourceDestination[0]);\n+        pfsr.set_environmentvariable(sourceDestination[0]);\n\
    \         pfsr.mutable_destination()->set_name(sourceDestination[1]);\n      \
    \   pfsrs.push_back(pfsr);\n       } else if (sourceDestination[0].find('-') !=\
    \ string::npos &&"
  - "--- a/src/terminal/UserTerminalRouter.cpp\n+++ b/src/terminal/UserTerminalRouter.cpp\n\
    @@ -16,6 +16,7 @@ UserTerminalRouter::UserTerminalRouter(\n }\n \n IdKeyPair UserTerminalRouter::acceptNewConnection()\
    \ {\n+  lock_guard<recursive_mutex> guard(routerMutex);\n   LOG(INFO) << \"Listening\
    \ to id/key FIFO\";\n   int terminalFd = socketHandler->accept(serverFd);\n  \
    \ if (terminalFd < 0) {\n@@ -49,6 +50,7 @@ IdKeyPair UserTerminalRouter::acceptNewConnection()\
    \ {\n }\n \n TerminalUserInfo UserTerminalRouter::getInfoForId(const string &id)\
    \ {\n+  lock_guard<recursive_mutex> guard(routerMutex);\n   auto it = idInfoMap.find(id);\n\
    \   if (it == idInfoMap.end()) {\n     STFATAL << \" Tried to read from an id\
    \ that no longer exists\";"
  - "--- a/src/terminal/forwarding/PortForwardHandler.cpp\n+++ b/src/terminal/forwarding/PortForwardHandler.cpp\n\
    @@ -45,6 +45,10 @@ PortForwardSourceResponse PortForwardHandler::createSource(\n\
    \     SocketEndpoint source;\n     if (pfsr.has_source()) {\n       source = pfsr.source();\n\
    +      if (source.has_name()) {\n+        throw runtime_error(\n+            \"\
    Named socket tunneling is only allowed with temporary filenames.\");\n+      }\n\
    \     } else {\n       // Make a random file to forward the pipe\n       string\
    \ sourcePattern ="
  identifiers:
  - CVE-2022-24949
  - CWE-120
  overview: A privilege escalation to root exists in Eternal Terminal prior to version
    6.2.0. This is due to the combination of a race condition, buffer overflow, and
    logic bug all in PipeSocketHandler::listen().
  references:
  - source: cve-assign@fb.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/MisterTea/EternalTerminal/commit/900348bb8bc96e1c7ba4888ac8480f643c43d3c3
  - source: cve-assign@fb.com
    tags:
    - Exploit
    - Third Party Advisory
    url: https://github.com/metaredteam/external-disclosures/security/advisories/GHSA-hxg8-4r3q-p9rv
  title: A privilege escalation to root exists in Eternal Terminal prior to version
    6.2.0. This is due to the combination of a race condition, buffer overflow, and
    logic bug all in PipeSocketHandler::listen().
- diff_content:
  - "--- a/src/base/LogHandler.cpp\n+++ b/src/base/LogHandler.cpp\n@@ -48,6 +48,10\
    \ @@ string LogHandler::stderrToFile(const string &pathPrefix) {\n   string current_time(buffer);\n\
    \   string stderrFilename = pathPrefix + \"_stderr_\" + current_time;\n   FILE\
    \ *stderr_stream = freopen(stderrFilename.c_str(), \"w\", stderr);\n+  fs::permissions(\n\
    +      stderrFilename,\n+      fs::perms::owner_read | fs::perms::owner_write\
    \ | fs::perms::group_read,\n+      fs::perm_options::replace);\n   if (!stderr_stream)\
    \ {\n     STFATAL << \"Invalid filename \" << stderrFilename;\n   }"
  - "--- a/src/base/PipeSocketHandler.cpp\n+++ b/src/base/PipeSocketHandler.cpp\n\
    @@ -13,7 +13,7 @@ int PipeSocketHandler::connect(const SocketEndpoint& endpoint)\
    \ {\n   FATAL_FAIL(sockFd);\n   initSocket(sockFd);\n   remote.sun_family = AF_UNIX;\n\
    -  strcpy(remote.sun_path, pipePath.c_str());\n+  strncpy(remote.sun_path, pipePath.c_str(),\
    \ sizeof(remote.sun_path));\n \n   VLOG(3) << \"Connecting to \" << endpoint <<\
    \ \" with fd \" << sockFd;\n   int result =\n@@ -104,7 +104,7 @@ set<int> PipeSocketHandler::listen(const\
    \ SocketEndpoint& endpoint) {\n   FATAL_FAIL(fd);\n   initServerSocket(fd);\n\
    \   local.sun_family = AF_UNIX; /* local is declared before socket() ^ */\n- \
    \ strcpy(local.sun_path, pipePath.c_str());\n+  strncpy(local.sun_path, pipePath.c_str(),\
    \ sizeof(local.sun_path));\n   unlink(local.sun_path);\n \n   FATAL_FAIL(::bind(fd,\
    \ (struct sockaddr*)&local, sizeof(sockaddr_un)));"
  - "--- a/src/terminal/TerminalClient.cpp\n+++ b/src/terminal/TerminalClient.cpp\n\
    @@ -14,7 +14,7 @@ vector<PortForwardSourceRequest> parseRangesToRequests(const\
    \ string& input) {\n           sourceDestination[1].find_first_not_of(\"0123456789-\"\
    ) !=\n               string::npos) {\n         PortForwardSourceRequest pfsr;\n\
    -        pfsr.mutable_source()->set_name(sourceDestination[0]);\n+        pfsr.set_environmentvariable(sourceDestination[0]);\n\
    \         pfsr.mutable_destination()->set_name(sourceDestination[1]);\n      \
    \   pfsrs.push_back(pfsr);\n       } else if (sourceDestination[0].find('-') !=\
    \ string::npos &&"
  - "--- a/src/terminal/UserTerminalRouter.cpp\n+++ b/src/terminal/UserTerminalRouter.cpp\n\
    @@ -16,6 +16,7 @@ UserTerminalRouter::UserTerminalRouter(\n }\n \n IdKeyPair UserTerminalRouter::acceptNewConnection()\
    \ {\n+  lock_guard<recursive_mutex> guard(routerMutex);\n   LOG(INFO) << \"Listening\
    \ to id/key FIFO\";\n   int terminalFd = socketHandler->accept(serverFd);\n  \
    \ if (terminalFd < 0) {\n@@ -49,6 +50,7 @@ IdKeyPair UserTerminalRouter::acceptNewConnection()\
    \ {\n }\n \n TerminalUserInfo UserTerminalRouter::getInfoForId(const string &id)\
    \ {\n+  lock_guard<recursive_mutex> guard(routerMutex);\n   auto it = idInfoMap.find(id);\n\
    \   if (it == idInfoMap.end()) {\n     STFATAL << \" Tried to read from an id\
    \ that no longer exists\";"
  - "--- a/src/terminal/forwarding/PortForwardHandler.cpp\n+++ b/src/terminal/forwarding/PortForwardHandler.cpp\n\
    @@ -45,6 +45,10 @@ PortForwardSourceResponse PortForwardHandler::createSource(\n\
    \     SocketEndpoint source;\n     if (pfsr.has_source()) {\n       source = pfsr.source();\n\
    +      if (source.has_name()) {\n+        throw runtime_error(\n+            \"\
    Named socket tunneling is only allowed with temporary filenames.\");\n+      }\n\
    \     } else {\n       // Make a random file to forward the pipe\n       string\
    \ sourcePattern ="
  identifiers:
  - CVE-2022-24950
  - CWE-362
  overview: A race condition exists in Eternal Terminal prior to version 6.2.0 that
    allows an authenticated attacker to hijack other users' SSH authorization socket,
    enabling the attacker to login to other systems as the targeted users. The bug
    is in UserTerminalRouter::getInfoForId().
  references:
  - source: cve-assign@fb.com
    url: http://www.openwall.com/lists/oss-security/2023/02/16/1
  - source: cve-assign@fb.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/MisterTea/EternalTerminal/commit/900348bb8bc96e1c7ba4888ac8480f643c43d3c3
  - source: cve-assign@fb.com
    tags:
    - Exploit
    - Third Party Advisory
    url: https://github.com/metaredteam/external-disclosures/security/advisories/GHSA-85gw-pchc-4rf3
  title: A race condition exists in Eternal Terminal prior to version 6.2.0 that allows
    an authenticated attacker to hijack other users' SSH authorization socket, enabling
    the attacker to login to other systems as the targeted users. The bug is in UserTerminalRouter::getInfoForId().
- diff_content:
  - "--- a/src/edit.c\n+++ b/src/edit.c\n@@ -1746,8 +1746,9 @@ edit_unputchar(void)\n\
    \  * Only works when cursor is in the line that changes.\n  */\n     void\n-display_dollar(colnr_T\
    \ col)\n+display_dollar(colnr_T col_arg)\n {\n+    colnr_T col = col_arg < 0 ?\
    \ 0 : col_arg;\n     colnr_T save_col;\n \n     if (!redrawing())"
  - "--- a/src/version.c\n+++ b/src/version.c\n@@ -735,6 +735,8 @@ static char *(features[])\
    \ =\n \n static int included_patches[] =\n {   /* Add new patch number below this\
    \ line */\n+/**/\n+    218,\n /**/\n     217,\n /**/"
  identifiers:
  - CVE-2022-2845
  - CWE-1284
  overview: 'Improper Validation of Specified Quantity in Input in GitHub repository
    vim/vim prior to 9.0.0218.


    '
  references:
  - source: security@huntr.dev
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/vim/vim/commit/e98c88c44c308edaea5994b8ad4363e65030968c
  - source: security@huntr.dev
    tags:
    - Exploit
    - Patch
    - Third Party Advisory
    url: https://huntr.dev/bounties/3e1d31ac-1cfd-4a9f-bc5c-213376b69445
  - source: security@huntr.dev
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/C72HDIMR3KTTAO7QGTXWUMPBNFUFIBRD/
  - source: security@huntr.dev
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/XWOJOA7PZZAMBI5GFTL6PWHXMWSDLUXL/
  - source: security@huntr.dev
    tags:
    - Third Party Advisory
    url: https://security.gentoo.org/glsa/202305-16
  title: 'Improper Validation of Specified Quantity in Input in GitHub repository
    vim/vim prior to 9.0.0218.


    '
- diff_content:
  - "--- a/src/mbyte.c\n+++ b/src/mbyte.c\n@@ -1077,24 +1077,28 @@ dbcs_char2bytes(int\
    \ c, char_u *buf)\n }\n \n /*\n- * mb_ptr2len() function pointer.\n- * Get byte\
    \ length of character at \"*p\" but stop at a NUL.\n- * For UTF-8 this includes\
    \ following composing characters.\n- * Returns 0 when *p is NUL.\n+ * Get byte\
    \ length of character at \"*p\".  Returns zero when \"*p\" is NUL.\n+ * Used for\
    \ mb_ptr2len() when 'encoding' latin.\n  */\n     int\n latin_ptr2len(char_u *p)\n\
    \ {\n- return MB_BYTE2LEN(*p);\n+    return *p == NUL ? 0 : 1;\n }\n \n+/*\n+\
    \ * Get byte length of character at \"*p\".  Returns zero when \"*p\" is NUL.\n\
    + * Used for mb_ptr2len() when 'encoding' DBCS.\n+ */\n     static int\n-dbcs_ptr2len(\n\
    -    char_u\t*p)\n+dbcs_ptr2len(char_u *p)\n {\n     int\t\tlen;\n \n-    // Check\
    \ if second byte is not missing.\n+    if (*p == NUL)\n+\treturn 0;\n+\n+    //\
    \ if the second byte is missing the length is 1\n     len = MB_BYTE2LEN(*p);\n\
    \     if (len == 2 && p[1] == NUL)\n \tlen = 1;\n@@ -2105,6 +2109,7 @@ utf_ptr2len_len(char_u\
    \ *p, int size)\n /*\n  * Return the number of bytes the UTF-8 encoding of the\
    \ character at \"p\" takes.\n  * This includes following composing characters.\n\
    + * Returns zero for NUL.\n  */\n     int\n utfc_ptr2len(char_u *p)"
  - "--- a/src/version.c\n+++ b/src/version.c\n@@ -735,6 +735,8 @@ static char *(features[])\
    \ =\n \n static int included_patches[] =\n {   /* Add new patch number below this\
    \ line */\n+/**/\n+    220,\n /**/\n     219,\n /**/"
  identifiers:
  - CVE-2022-2849
  - CWE-122
  overview: Heap-based Buffer Overflow in GitHub repository vim/vim prior to 9.0.0220.
  references:
  - source: security@huntr.dev
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/vim/vim/commit/f6d39c31d2177549a986d170e192d8351bd571e2
  - source: security@huntr.dev
    tags:
    - Exploit
    - Issue Tracking
    - Patch
    - Third Party Advisory
    url: https://huntr.dev/bounties/389aeccd-deb9-49ae-9b6a-24c12d79b02e
  - source: security@huntr.dev
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/XWOJOA7PZZAMBI5GFTL6PWHXMWSDLUXL/
  - source: security@huntr.dev
    url: https://security.gentoo.org/glsa/202305-16
  title: Heap-based Buffer Overflow in GitHub repository vim/vim prior to 9.0.0220.
- diff_content:
  - "--- a/src/version.c\n+++ b/src/version.c\n@@ -735,6 +735,8 @@ static char *(features[])\
    \ =\n \n static int included_patches[] =\n {   /* Add new patch number below this\
    \ line */\n+/**/\n+    221,\n /**/\n     220,\n /**/"
  - "--- a/src/vim9compile.c\n+++ b/src/vim9compile.c\n@@ -830,6 +830,7 @@ compile_nested_function(exarg_T\
    \ *eap, cctx_T *cctx, garray_T *lines_to_free)\n     int\t\tr = FAIL;\n     compiletype_T\
    \   compile_type;\n     isn_T\t*funcref_isn = NULL;\n+    lvar_T\t*lvar = NULL;\n\
    \ \n     if (eap->forceit)\n     {\n@@ -936,9 +937,8 @@ compile_nested_function(exarg_T\
    \ *eap, cctx_T *cctx, garray_T *lines_to_free)\n     else\n     {\n \t// Define\
    \ a local variable for the function reference.\n-\tlvar_T\t*lvar = reserve_local(cctx,\
    \ func_name, name_end - name_start,\n+\tlvar = reserve_local(cctx, func_name,\
    \ name_end - name_start,\n \t\t\t\t\t\t    TRUE, ufunc->uf_func_type);\n-\n \t\
    if (lvar == NULL)\n \t    goto theend;\n \tif (generate_FUNCREF(cctx, ufunc, &funcref_isn)\
    \ == FAIL)\n@@ -957,6 +957,9 @@ compile_nested_function(exarg_T *eap, cctx_T *cctx,\
    \ garray_T *lines_to_free)\n \t    && compile_def_function(ufunc, TRUE, compile_type,\
    \ cctx) == FAIL)\n     {\n \tfunc_ptr_unref(ufunc);\n+\tif (lvar != NULL)\n+\t\
    \    // Now the local variable can't be used.\n+\t    *lvar->lv_name = '/';  //\
    \ impossible value\n \tgoto theend;\n     }\n "
  identifiers:
  - CVE-2022-2862
  - CWE-416
  overview: Use After Free in GitHub repository vim/vim prior to 9.0.0221.
  references:
  - source: security@huntr.dev
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/vim/vim/commit/1889f499a4f248cd84e0e0bf6d0d820016774494
  - source: security@huntr.dev
    tags:
    - Exploit
    - Issue Tracking
    - Patch
    - Third Party Advisory
    url: https://huntr.dev/bounties/71180988-1ab6-4311-bca8-e9a879b06765
  - source: security@huntr.dev
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/XWOJOA7PZZAMBI5GFTL6PWHXMWSDLUXL/
  - source: security@huntr.dev
    url: https://security.gentoo.org/glsa/202305-16
  title: Use After Free in GitHub repository vim/vim prior to 9.0.0221.
- diff_content:
  - "--- a/src/njs_generator.c\n+++ b/src/njs_generator.c\n@@ -4495,6 +4495,11 @@\
    \ njs_generate_try_catch(njs_vm_t *vm, njs_generator_t *generator,\n         \
    \                                    NJS_GENERATOR_ALL,\n                    \
    \                         &ctx->try_exit_label);\n \n+            /*\n+      \
    \       * block can be NULL when &ctx->try_exit_label is \"@return\"\n+      \
    \       * for outermost try-catch block.\n+             */\n+\n             if\
    \ (block != NULL) {\n                 patch = njs_generate_make_exit_patch(vm,\
    \ block,\n                                                      &ctx->try_exit_label,\n\
    @@ -4503,6 +4508,26 @@ njs_generate_try_catch(njs_vm_t *vm, njs_generator_t *generator,\n\
    \                 if (njs_slow_path(patch == NULL)) {\n                     return\
    \ NJS_ERROR;\n                 }\n+\n+            } else {\n+\n+             \
    \   /*\n+                 * when block == NULL, we still want to patch the \"\
    finally\"\n+                 * instruction break_offset.\n+                 */\n\
    +\n+                block = njs_generate_find_block(vm, generator->block,\n+ \
    \                                               NJS_GENERATOR_ALL,\n+        \
    \                                        &no_label);\n+\n+                if (block\
    \ != NULL) {\n+                    patch = njs_generate_make_exit_patch(vm, block,\
    \ &no_label,\n+                                njs_code_offset(generator, finally)\n\
    +                                + offsetof(njs_vmcode_finally_t, break_offset));\n\
    +                    if (njs_slow_path(patch == NULL)) {\n+                  \
    \      return NJS_ERROR;\n+                    }\n+                }\n       \
    \      }\n         }\n     }\n@@ -4669,15 +4694,27 @@ njs_generate_try_end(njs_vm_t\
    \ *vm, njs_generator_t *generator,\n          * outermost try-catch block.\n \
    \         */\n         block = njs_generate_find_block(vm, generator->block,\n\
    -                                        NJS_GENERATOR_ALL\n-                \
    \                        | NJS_GENERATOR_TRY, dest_label);\n+                \
    \                        NJS_GENERATOR_ALL, dest_label);\n         if (block !=\
    \ NULL) {\n             patch = njs_generate_make_exit_patch(vm, block, dest_label,\n\
    \                             njs_code_offset(generator, finally)\n          \
    \                   + offsetof(njs_vmcode_finally_t, break_offset));\n       \
    \      if (njs_slow_path(patch == NULL)) {\n                 return NJS_ERROR;\n\
    \             }\n+\n+        } else {\n+\n+            block = njs_generate_find_block(vm,\
    \ generator->block,\n+                                            NJS_GENERATOR_ALL,\
    \ &no_label);\n+            if (block != NULL) {\n+                patch = njs_generate_make_exit_patch(vm,\
    \ block, &no_label,\n+                                njs_code_offset(generator,\
    \ finally)\n+                                + offsetof(njs_vmcode_finally_t,\
    \ break_offset));\n+                if (njs_slow_path(patch == NULL)) {\n+   \
    \                 return NJS_ERROR;\n+                }\n+            }\n    \
    \     }\n     }\n "
  - "--- a/src/test/njs_unit_test.c\n+++ b/src/test/njs_unit_test.c\n@@ -3411,20 +3411,52\
    \ @@ static njs_unit_test_t  njs_test[] =\n       njs_str(\"a,2\") },\n \n   \
    \  { njs_str(\"function f(n) { \"\n-                 \"  var r1 = 0, r2 = 0, r3\
    \ = 0;\"\n-                 \"  a:{ try { try { \"\n-                 \"     \
    \         if (n == 0) { break a; } \"\n-                 \"              if (n\
    \ == 1) { throw 'a'; } \"\n-                 \"            } \"\n-           \
    \      \"            catch (e) { break a; } finally { r1++; } } \"\n-        \
    \         \"      catch (e) {} \"\n-                 \"      finally { r2++; }\
    \ \"\n-                 \"      r3++;  \"\n-                 \"  }; \"\n-    \
    \             \"return [r1, r2, r3]\"\n-                 \"}; njs.dump([f(0),\
    \ f(1), f(3)])\"),\n+              \"  var r1 = 0, r2 = 0, r3 = 0;\"\n+      \
    \        \"  a:{ try { try { \"\n+              \"              if (n == 0) {\
    \ break a; } \"\n+              \"              if (n == 1) { throw 'a'; } \"\n\
    +              \"            } \"\n+              \"            catch (e) { break\
    \ a; } finally { r1++; } } \"\n+              \"      catch (e) {} \"\n+     \
    \         \"      finally { r2++; } \"\n+              \"      r3++;  \"\n+  \
    \            \"  }; \"\n+              \"return [r1, r2, r3]\"\n+            \
    \  \"}; njs.dump([f(0), f(1), f(3)])\"),\n       njs_str(\"[[1,1,0],[1,1,0],[1,1,1]]\"\
    ) },\n \n+\n+    { njs_str(\"function f(n) {\"\n+              \"    while (1)\"\
    \n+              \"           try {\"\n+              \"              if (n ==\
    \ 0) { break; }\"\n+              \"              if (n == 1) { throw 'a'; }\"\
    \n+              \"\"\n+              \"              try { return 42; }\"\n+\
    \              \"              catch (a) {}\"\n+              \"\"\n+        \
    \      \"            } catch (b) { return b; }\"\n+              \"};\"\n+   \
    \           \"njs.dump([f(0), f(1), f(2)])\"),\n+      njs_str(\"[undefined,'a',42]\"\
    ) },\n+\n+    { njs_str(\"function f(n, r) {\"\n+              \"    while (1)\"\
    \n+              \"           try {\"\n+              \"              if (n ==\
    \ 0) { break; }\"\n+              \"              if (n == 1) { throw 'a'; }\"\
    \n+              \"\"\n+              \"              try { return 42; }\"\n+\
    \              \"              catch (a) {}\"\n+              \"             \
    \ finally { r.push('in');}\"\n+              \"\"\n+              \"         \
    \   } catch (b) { return b; }\"\n+              \"            finally { r.push('out');\
    \ }\"\n+              \"};\"\n+              \"function g(n) { var r = []; return\
    \ [f(n, r), r]}\"\n+              \"njs.dump([g(0), g(1), g(2)])\"),\n+      njs_str(\"\
    [[undefined,['out']],['a',['out']],[42,['in','out']]]\") },\n+\n     /**/\n \n\
    \     { njs_str(\"function f() { Object.prototype.toString = 1; };\""
  identifiers:
  - CVE-2022-35173
  - CWE-754
  overview: An issue was discovered in Nginx NJS v0.7.5. The JUMP offset for a break
    instruction was not set to a correct offset during code generation, leading to
    a segmentation violation.
  references:
  - source: cve@mitre.org
    tags:
    - Patch
    - Third Party Advisory
    url: http://hg.nginx.org/njs/rev/b7c4e0f714a9
  - source: cve@mitre.org
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/nginx/njs/commit/404553896792b8f5f429dc8852d15784a59d8d3e
  - source: cve@mitre.org
    tags:
    - Exploit
    - Issue Tracking
    - Third Party Advisory
    url: https://github.com/nginx/njs/issues/553
  title: An issue was discovered in Nginx NJS v0.7.5. The JUMP offset for a break
    instruction was not set to a correct offset during code generation, leading to
    a segmentation violation.
- diff_content:
  - "--- a/src/version.c\n+++ b/src/version.c\n@@ -731,6 +731,8 @@ static char *(features[])\
    \ =\n \n static int included_patches[] =\n {   /* Add new patch number below this\
    \ line */\n+/**/\n+    224,\n /**/\n     223,\n /**/"
  - "--- a/src/vim9compile.c\n+++ b/src/vim9compile.c\n@@ -1165,11 +1165,14 @@ generate_loadvar(\n\
    \ \t    generate_LOADV(cctx, name + 2);\n \t    break;\n \tcase dest_local:\n\
    -\t    if (lvar->lv_from_outer > 0)\n-\t\tgenerate_LOADOUTER(cctx, lvar->lv_idx,\
    \ lvar->lv_from_outer,\n+\t    if (cctx->ctx_skip != SKIP_YES)\n+\t    {\n+\t\t\
    if (lvar->lv_from_outer > 0)\n+\t\t    generate_LOADOUTER(cctx, lvar->lv_idx,\
    \ lvar->lv_from_outer,\n \t\t\t\t\t\t\t\t\t type);\n-\t    else\n-\t\tgenerate_LOAD(cctx,\
    \ ISN_LOAD, lvar->lv_idx, NULL, type);\n+\t\telse\n+\t\t    generate_LOAD(cctx,\
    \ ISN_LOAD, lvar->lv_idx, NULL, type);\n+\t    }\n \t    break;\n \tcase dest_expr:\n\
    \ \t    // list or dict value should already be on the stack.\n@@ -1952,6 +1955,9\
    \ @@ compile_assign_unlet(\n \t}\n     }\n \n+    if (cctx->ctx_skip == SKIP_YES)\n\
    +\treturn OK;\n+\n     // Load the dict or list.  On the stack we then have:\n\
    \     // - value (for assignment, not for :unlet)\n     // - index"
  identifiers:
  - CVE-2022-2874
  - CWE-476
  overview: NULL Pointer Dereference in GitHub repository vim/vim prior to 9.0.0224.
  references:
  - source: security@huntr.dev
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/vim/vim/commit/4875d6ab068f09df88d24d81de40dcd8d56e243d
  - source: security@huntr.dev
    tags:
    - Exploit
    - Patch
    - Third Party Advisory
    url: https://huntr.dev/bounties/95f97dfe-247d-475d-9740-b7adc71f4c79
  - source: security@huntr.dev
    url: https://security.gentoo.org/glsa/202305-16
  title: NULL Pointer Dereference in GitHub repository vim/vim prior to 9.0.0224.
- diff_content:
  - "--- a/src/p_lx_elf.cpp\n+++ b/src/p_lx_elf.cpp\n@@ -1639,8 +1639,8 @@ PackLinuxElf32::invert_pt_dynamic(Elf32_Dyn\
    \ const *dynp)\n         unsigned const *const buckets = &hashtab[2];\n      \
    \   unsigned const *const chains = &buckets[nbucket]; (void)chains;\n \n-    \
    \    unsigned const v_sym = get_te32(&dynp0[-1+ x_sym].d_val);\n-        if (!nbucket\n\
    +        unsigned const v_sym = !x_sym ? 0 : get_te32(&dynp0[-1+ x_sym].d_val);\n\
    +        if (!nbucket || !v_sym\n         || (nbucket>>31) || (file_size/sizeof(unsigned))\
    \ <= (2*nbucket)  // FIXME: weak\n         || ((v_hsh < v_sym) && (v_sym - v_hsh)\
    \ < (sizeof(unsigned)*2  // headers\n                 + sizeof(*buckets)*nbucket\
    \  // buckets\n@@ -1670,8 +1670,8 @@ PackLinuxElf32::invert_pt_dynamic(Elf32_Dyn\
    \ const *dynp)\n         unsigned     const *const hasharr = &buckets[n_bucket];\
    \ (void)hasharr;\n       //unsigned     const *const gashend = &hasharr[n_bucket];\
    \  // minimum\n \n-        unsigned const v_sym = get_te32(&dynp0[-1+ x_sym].d_val);\n\
    -        if (!n_bucket || !n_bitmask\n+        unsigned const v_sym = !x_sym ?\
    \ 0 : get_te32(&dynp0[-1+ x_sym].d_val);\n+        if (!n_bucket || !n_bitmask\
    \ || !v_sym\n         || (-1+ n_bitmask) & n_bitmask  // not a power of 2\n  \
    \       || 8*sizeof(unsigned) <= gnu_shift  // shifted result always == 0\n  \
    \       || (n_bucket>>30)  // fie on fuzzers\n@@ -5139,8 +5139,8 @@ PackLinuxElf64::invert_pt_dynamic(Elf64_Dyn\
    \ const *dynp)\n         unsigned const *const buckets = &hashtab[2];\n      \
    \   unsigned const *const chains = &buckets[nbucket]; (void)chains;\n \n-    \
    \    unsigned const v_sym = get_te32(&dynp0[-1+ x_sym].d_val);\n-        if (!nbucket\n\
    +        unsigned const v_sym = !x_sym ? 0 : get_te32(&dynp0[-1+ x_sym].d_val);\n\
    +        if (!nbucket || !v_sym\n         || (nbucket>>31) || (file_size/sizeof(unsigned))\
    \ <= (2*nbucket)  // FIXME: weak\n         || ((v_hsh < v_sym) && (v_sym - v_hsh)\
    \ < (sizeof(unsigned)*2  // headers\n                 + sizeof(*buckets)*nbucket\
    \  // buckets\n@@ -5170,8 +5170,8 @@ PackLinuxElf64::invert_pt_dynamic(Elf64_Dyn\
    \ const *dynp)\n         unsigned     const *const hasharr = &buckets[n_bucket];\
    \ (void)hasharr;\n       //unsigned     const *const gashend = &hasharr[n_bucket];\
    \  // minimum\n \n-        upx_uint64_t const v_sym = get_te64(&dynp0[-1+ x_sym].d_val);\n\
    -        if (!n_bucket || !n_bitmask\n+        upx_uint64_t const v_sym = !x_sym\
    \ ? 0 : get_te64(&dynp0[-1+ x_sym].d_val);\n+        if (!n_bucket || !n_bitmask\
    \ || !v_sym\n         || (-1+ n_bitmask) & n_bitmask  // not a power of 2\n  \
    \       || 8*sizeof(upx_uint64_t) <= gnu_shift  // shifted result always == 0\n\
    \         || (n_bucket>>30)  // fie on fuzzers"
  identifiers:
  - CVE-2020-27787
  - NVD-CWE-noinfo
  overview: A Segmentaation fault was found in UPX in invert_pt_dynamic() function
    in p_lx_elf.cpp. An attacker with a crafted input file allows invalid memory address
    access that could lead to a denial of service.
  references:
  - source: secalert@redhat.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/upx/upx/commit/e2f60adc95334f47e286838dac33160819c5d74d
  - source: secalert@redhat.com
    tags:
    - Exploit
    - Issue Tracking
    - Patch
    - Third Party Advisory
    url: https://github.com/upx/upx/issues/333
  title: A Segmentaation fault was found in UPX in invert_pt_dynamic() function in
    p_lx_elf.cpp. An attacker with a crafted input file allows invalid memory address
    access that could lead to a denial of service.
- diff_content:
  - "--- a/src/p_lx_elf.cpp\n+++ b/src/p_lx_elf.cpp\n@@ -1614,9 +1614,17 @@ PackLinuxElf32::invert_pt_dynamic(Elf32_Dyn\
    \ const *dynp)\n         unsigned const  z_sym = dt_table[Elf32_Dyn::DT_SYMENT];\n\
    \         unsigned const sz_sym = !z_sym ? sizeof(Elf32_Sym)\n             : get_te32(&dynp0[-1+\
    \ z_sym].d_val);\n+        if (sz_sym < sizeof(Elf32_Sym)) {\n+            char\
    \ msg[50]; snprintf(msg, sizeof(msg),\n+                \"bad DT_SYMENT %x\",\
    \ sz_sym);\n+            throwCantPack(msg);\n+        }\n         if (v_sym <\
    \ v_str) {\n             symnum_end = (v_str - v_sym) / sz_sym;\n         }\n\
    +        if (symnum_end < 1) {\n+            throwCantPack(\"bad DT_SYMTAB\");\n\
    +        }\n     }\n     // DT_HASH often ends at DT_SYMTAB\n     unsigned const\
    \ v_hsh = elf_unsigned_dynamic(Elf32_Dyn::DT_HASH);\n@@ -5104,9 +5112,17 @@ PackLinuxElf64::invert_pt_dynamic(Elf64_Dyn\
    \ const *dynp)\n         unsigned const  z_sym = dt_table[Elf64_Dyn::DT_SYMENT];\n\
    \         unsigned const sz_sym = !z_sym ? sizeof(Elf64_Sym)\n             : get_te64(&dynp0[-1+\
    \ z_sym].d_val);\n+        if (sz_sym < sizeof(Elf64_Sym)) {\n+            char\
    \ msg[50]; snprintf(msg, sizeof(msg),\n+                \"bad DT_SYMENT %x\",\
    \ sz_sym);\n+            throwCantPack(msg);\n+        }\n         if (v_sym <\
    \ v_str) {\n             symnum_end = (v_str - v_sym) / sz_sym;\n         }\n\
    +        if (symnum_end < 1) {\n+            throwCantPack(\"bad DT_SYMTAB\");\n\
    +        }\n     }\n     // DT_HASH often ends at DT_SYMTAB\n     unsigned const\
    \ v_hsh = elf_unsigned_dynamic(Elf64_Dyn::DT_HASH);"
  identifiers:
  - CVE-2020-27790
  - CWE-369
  overview: A floating point exception issue was discovered in UPX in PackLinuxElf64::invert_pt_dynamic()
    function of p_lx_elf.cpp file. An attacker with a crafted input file could trigger
    this issue that could cause a crash leading to a denial of service. The highest
    impact is to Availability.
  references:
  - source: secalert@redhat.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/upx/upx/commit/eb90eab6325d009004ffb155e3e33f22d4d3ca26
  - source: secalert@redhat.com
    tags:
    - Exploit
    - Issue Tracking
    - Patch
    - Third Party Advisory
    url: https://github.com/upx/upx/issues/331
  title: A floating point exception issue was discovered in UPX in PackLinuxElf64::invert_pt_dynamic()
    function of p_lx_elf.cpp file. An attacker with a crafted input file could trigger
    this issue that could cause a crash leading to a denial of service. The highest
    impact is to Availability.
- diff_content:
  - "--- a/src/p_lx_elf.cpp\n+++ b/src/p_lx_elf.cpp\n@@ -2039,11 +2039,12 @@ bool\
    \ PackLinuxElf32::canPack()\n             if (sec_strndx) {\n                \
    \ unsigned const sh_name = get_te32(&sec_strndx->sh_name);\n                 if\
    \ (Elf32_Shdr::SHT_STRTAB != get_te32(&sec_strndx->sh_type)\n-               \
    \ || (u32_t)file_size <= sh_name  // FIXME: weak\n+                || (u32_t)file_size\
    \ <= (sizeof(\".shstrtab\")\n+                    + sh_name + (shstrtab - (const\
    \ char *)&file_image[0]))\n                 || (sh_name\n                   &&\
    \ 0!=strcmp((char const *)\".shstrtab\", &shstrtab[sh_name]))\n              \
    \   ) {\n-                    throwCantPack(\"bad e_shstrndx\");\n+          \
    \          throwCantPack(\"bad e_shstrtab\");\n                 }\n          \
    \   }\n         }\n@@ -2388,11 +2389,12 @@ PackLinuxElf64::canPack()\n       \
    \      if (sec_strndx) {\n                 unsigned const sh_name = get_te32(&sec_strndx->sh_name);\n\
    \                 if (Elf64_Shdr::SHT_STRTAB != get_te32(&sec_strndx->sh_type)\n\
    -                || (u32_t)file_size <= sh_name  // FIXME: weak\n+           \
    \     || (u32_t)file_size <= (sizeof(\".shstrtab\")\n+                    + sh_name\
    \ + (shstrtab - (const char *)&file_image[0]))\n                 || (sh_name\n\
    \                   && 0!=strcmp((char const *)\".shstrtab\", &shstrtab[sh_name]))\n\
    \                 ) {\n-                    throwCantPack(\"bad e_shstrndx\");\n\
    +                    throwCantPack(\"bad e_shstrtab\");\n                 }\n\
    \             }\n         }"
  identifiers:
  - CVE-2020-27788
  - CWE-125
  overview: An out-of-bounds read access vulnerability was discovered in UPX in PackLinuxElf64::canPack()
    function of p_lx_elf.cpp file. An attacker with a crafted input file could trigger
    this issue that could cause a crash leading to a denial of service.
  references:
  - source: secalert@redhat.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/upx/upx/commit/1bb93d4fce9f1d764ba57bf5ac154af515b3fc83
  - source: secalert@redhat.com
    tags:
    - Exploit
    - Issue Tracking
    - Patch
    - Third Party Advisory
    url: https://github.com/upx/upx/issues/332
  title: An out-of-bounds read access vulnerability was discovered in UPX in PackLinuxElf64::canPack()
    function of p_lx_elf.cpp file. An attacker with a crafted input file could trigger
    this issue that could cause a crash leading to a denial of service.
- diff_content:
  - "--- a/src/eval.c\n+++ b/src/eval.c\n@@ -353,6 +353,63 @@ eval_to_string_skip(\n\
    \     return retval;\n }\n \n+/*\n+ * Initialize \"evalarg\" for use.\n+ */\n\
    +    void\n+init_evalarg(evalarg_T *evalarg)\n+{\n+    CLEAR_POINTER(evalarg);\n\
    +    ga_init2(&evalarg->eval_tofree_ga, sizeof(char_u *), 20);\n+}\n+\n+/*\n+\
    \ * If \"evalarg->eval_tofree\" is not NULL free it later.\n+ * Caller is expected\
    \ to overwrite \"evalarg->eval_tofree\" next.\n+ */\n+    static void\n+free_eval_tofree_later(evalarg_T\
    \ *evalarg)\n+{\n+    if (evalarg->eval_tofree != NULL)\n+    {\n+\tif (ga_grow(&evalarg->eval_tofree_ga,\
    \ 1) == OK)\n+\t    ((char_u **)evalarg->eval_tofree_ga.ga_data)\n+\t\t[evalarg->eval_tofree_ga.ga_len++]\n\
    +\t\t= evalarg->eval_tofree;\n+\telse\n+\t    vim_free(evalarg->eval_tofree);\n\
    +    }\n+}\n+\n+/*\n+ * After using \"evalarg\" filled from \"eap\": free the\
    \ memory.\n+ */\n+    void\n+clear_evalarg(evalarg_T *evalarg, exarg_T *eap)\n\
    +{\n+    if (evalarg != NULL)\n+    {\n+\tif (evalarg->eval_tofree != NULL)\n\
    +\t{\n+\t    if (eap != NULL)\n+\t    {\n+\t\t// We may need to keep the original\
    \ command line, e.g. for\n+\t\t// \":let\" it has the variable names.  But we\
    \ may also need the\n+\t\t// new one, \"nextcmd\" points into it.  Keep both.\n\
    +\t\tvim_free(eap->cmdline_tofree);\n+\t\teap->cmdline_tofree = *eap->cmdlinep;\n\
    +\t\t*eap->cmdlinep = evalarg->eval_tofree;\n+\t    }\n+\t    else\n+\t\tvim_free(evalarg->eval_tofree);\n\
    +\t    evalarg->eval_tofree = NULL;\n+\t}\n+\n+\tga_clear_strings(&evalarg->eval_tofree_ga);\n\
    +\tVIM_CLEAR(evalarg->eval_tofree_lambda);\n+    }\n+}\n+\n /*\n  * Skip over\
    \ an expression at \"*pp\".\n  * Return FAIL for an error, OK otherwise.\n@@ -435,8\
    \ +492,8 @@ skip_expr_concatenate(\n \t\t// Do not free the first line, the caller\
    \ can still use it.\n \t\t*((char_u **)gap->ga_data) = NULL;\n \t\t// Do not free\
    \ the last line, \"arg\" points into it, free it\n-\t\t// later.\n-\t\tvim_free(evalarg->eval_tofree);\n\
    +\t\t// later.  Also free \"eval_tofree\" later if needed.\n+\t\tfree_eval_tofree_later(evalarg);\n\
    \ \t\tevalarg->eval_tofree =\n \t\t\t\t    ((char_u **)gap->ga_data)[gap->ga_len\
    \ - 1];\n \t\t((char_u **)gap->ga_data)[gap->ga_len - 1] = NULL;\n@@ -2274,7 +2331,7\
    \ @@ eval_next_line(char_u *arg, evalarg_T *evalarg)\n     }\n     else if (evalarg->eval_cookie\
    \ != NULL)\n     {\n-\tvim_free(evalarg->eval_tofree);\n+\tfree_eval_tofree_later(evalarg);\n\
    \ \tevalarg->eval_tofree = line;\n     }\n \n@@ -2301,45 +2358,6 @@ skipwhite_and_linebreak(char_u\
    \ *arg, evalarg_T *evalarg)\n     return p;\n }\n \n-/*\n- * Initialize \"evalarg\"\
    \ for use.\n- */\n-    void\n-init_evalarg(evalarg_T *evalarg)\n-{\n-    CLEAR_POINTER(evalarg);\n\
    -    ga_init2(&evalarg->eval_tofree_ga, sizeof(char_u *), 20);\n-}\n-\n-/*\n-\
    \ * After using \"evalarg\" filled from \"eap\": free the memory.\n- */\n-   \
    \ void\n-clear_evalarg(evalarg_T *evalarg, exarg_T *eap)\n-{\n-    if (evalarg\
    \ != NULL)\n-    {\n-\tif (evalarg->eval_tofree != NULL)\n-\t{\n-\t    if (eap\
    \ != NULL)\n-\t    {\n-\t\t// We may need to keep the original command line, e.g.\
    \ for\n-\t\t// \":let\" it has the variable names.  But we may also need the\n\
    -\t\t// new one, \"nextcmd\" points into it.  Keep both.\n-\t\tvim_free(eap->cmdline_tofree);\n\
    -\t\teap->cmdline_tofree = *eap->cmdlinep;\n-\t\t*eap->cmdlinep = evalarg->eval_tofree;\n\
    -\t    }\n-\t    else\n-\t\tvim_free(evalarg->eval_tofree);\n-\t    evalarg->eval_tofree\
    \ = NULL;\n-\t}\n-\n-\tga_clear_strings(&evalarg->eval_tofree_ga);\n-\tVIM_CLEAR(evalarg->eval_tofree_lambda);\n\
    -    }\n-}\n-\n /*\n  * The \"evaluate\" argument: When FALSE, the argument is\
    \ only parsed but not\n  * executed.  The function may return OK, but the rettv\
    \ will be of type"
  - "--- a/src/userfunc.c\n+++ b/src/userfunc.c\n@@ -1372,7 +1372,6 @@ get_lambda_tv(\n\
    \     char_u\t*start, *end;\n     int\t\t*old_eval_lavars = eval_lavars_used;\n\
    \     int\t\teval_lavars = FALSE;\n-    char_u\t*tofree1 = NULL;\n     char_u\t\
    *tofree2 = NULL;\n     int\t\tequal_arrow = **arg == '(';\n     int\t\twhite_error\
    \ = FALSE;\n@@ -1457,12 +1456,6 @@ get_lambda_tv(\n     ret = skip_expr_concatenate(arg,\
    \ &start, &end, evalarg);\n     if (ret == FAIL)\n \tgoto errret;\n-    if (evalarg\
    \ != NULL)\n-    {\n-\t// avoid that the expression gets freed when another line\
    \ break follows\n-\ttofree1 = evalarg->eval_tofree;\n-\tevalarg->eval_tofree =\
    \ NULL;\n-    }\n \n     if (!equal_arrow)\n     {\n@@ -1585,10 +1578,6 @@ get_lambda_tv(\n\
    \ \n theend:\n     eval_lavars_used = old_eval_lavars;\n-    if (evalarg != NULL\
    \ && evalarg->eval_tofree == NULL)\n-\tevalarg->eval_tofree = tofree1;\n-    else\n\
    -\tvim_free(tofree1);\n     vim_free(tofree2);\n     if (types_optional)\n \t\
    ga_clear_strings(&argtypes);\n@@ -1607,10 +1596,6 @@ get_lambda_tv(\n     }\n\
    \     vim_free(fp);\n     vim_free(pt);\n-    if (evalarg != NULL && evalarg->eval_tofree\
    \ == NULL)\n-\tevalarg->eval_tofree = tofree1;\n-    else\n-\tvim_free(tofree1);\n\
    \     vim_free(tofree2);\n     eval_lavars_used = old_eval_lavars;\n     return\
    \ FAIL;"
  - "--- a/src/version.c\n+++ b/src/version.c\n@@ -731,6 +731,8 @@ static char *(features[])\
    \ =\n \n static int included_patches[] =\n {   /* Add new patch number below this\
    \ line */\n+/**/\n+    225,\n /**/\n     224,\n /**/"
  identifiers:
  - CVE-2022-2889
  - CWE-416
  overview: Use After Free in GitHub repository vim/vim prior to 9.0.0225.
  references:
  - source: security@huntr.dev
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/vim/vim/commit/91c7cbfe31bbef57d5fcf7d76989fc159f73ef15
  - source: security@huntr.dev
    tags:
    - Exploit
    - Patch
    - Third Party Advisory
    url: https://huntr.dev/bounties/d1ac9817-825d-49ce-b514-1d5b12b6bdaa
  - source: security@huntr.dev
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/C72HDIMR3KTTAO7QGTXWUMPBNFUFIBRD/
  - source: security@huntr.dev
    url: https://security.gentoo.org/glsa/202305-16
  title: Use After Free in GitHub repository vim/vim prior to 9.0.0225.
- diff_content:
  - "--- a/libr/core/p/core_java.c\n+++ b/libr/core/p/core_java.c\n@@ -1465,7 +1465,7\
    \ @@ static int r_cmd_java_call(void *user, const char *input) {\n \tif (input[4]\
    \ != ' ') {\n \t\treturn r_cmd_java_handle_help (core, input);\n \t}\n-\tfor (;\
    \ i < END_CMDS; i++) {\n+\tfor (; i < END_CMDS - 1; i++) {\n \t\t//IFDBG r_cons_printf\
    \ (\"Checking cmd: %s %d %s\\n\", JAVA_CMDS[i].name, JAVA_CMDS[i].name_len, p);\n\
    \ \t\tIFDBG r_cons_printf (\"Checking cmd: %s %d\\n\", JAVA_CMDS[i].name,\n \t\
    \t\tstrncmp (input+5, JAVA_CMDS[i].name, JAVA_CMDS[i].name_len));"
  identifiers:
  - CVE-2020-27793
  - CWE-193
  overview: An off-by-one overflow flaw was found in radare2 due to mismatched array
    length in core_java.c. This could allow an attacker to cause a crash, and perform
    a denail of service attack.
  references:
  - source: secalert@redhat.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/radareorg/radare2/commit/ced0223c7a1b3b5344af315715cd28fe7c0d9ebc
  - source: secalert@redhat.com
    tags:
    - Exploit
    - Issue Tracking
    - Patch
    - Third Party Advisory
    url: https://github.com/radareorg/radare2/issues/16304
  title: An off-by-one overflow flaw was found in radare2 due to mismatched array
    length in core_java.c. This could allow an attacker to cause a crash, and perform
    a denail of service attack.
- diff_content:
  - "--- a/libr/core/core.c\n+++ b/libr/core/core.c\n@@ -2842,7 +2842,7 @@ R_API void\
    \ r_core_fini(RCore *c) {\n \t// TODO: sync all dbs?\n \t//r_core_file_free (c->file);\n\
    \ \t//c->file = NULL;\n-\tfree (c->table_query);\n+\tR_FREE (c->table_query);\n\
    \ \tr_list_free (c->files);\n \tr_list_free (c->watchers);\n \tr_list_free (c->scriptstack);"
  identifiers:
  - CVE-2020-27794
  - CWE-415
  overview: A double free issue was discovered in radare2 in cmd_info.c:cmd_info().
    Successful exploitation could lead to modification of unexpected memory locations
    and potentially causing a crash.
  references:
  - source: secalert@redhat.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/radareorg/radare2/commit/cb8b683758edddae2d2f62e8e63a738c39f92683
  - source: secalert@redhat.com
    tags:
    - Exploit
    - Issue Tracking
    - Patch
    - Third Party Advisory
    url: https://github.com/radareorg/radare2/issues/16303
  title: A double free issue was discovered in radare2 in cmd_info.c:cmd_info(). Successful
    exploitation could lead to modification of unexpected memory locations and potentially
    causing a crash.
- diff_content:
  - "--- a/libr/core/cmd_anal.c\n+++ b/libr/core/cmd_anal.c\n@@ -9235,12 +9235,12\
    \ @@ static int cmd_anal_all(RCore *core, const char *input) {\n }\n \n static\
    \ bool anal_fcn_data (RCore *core, const char *input) {\n-\tRAnalFunction *fcn\
    \ = r_anal_get_fcn_in (core->anal, core->offset, -1);\n-\tut32 fcn_size = r_anal_function_size_from_entry\
    \ (fcn);\n+\tRAnalFunction *fcn = r_anal_get_fcn_in (core->anal, core->offset,\
    \ R_ANAL_FCN_TYPE_ANY);\n \tif (fcn) {\n \t\tint i;\n \t\tbool gap = false;\n\
    \ \t\tut64 gap_addr = UT64_MAX;\n+\t\tut32 fcn_size = r_anal_function_size_from_entry\
    \ (fcn);\n \t\tchar *bitmap = calloc (1, fcn_size);\n \t\tif (bitmap) {\n \t\t\
    \tRAnalBlock *b;"
  identifiers:
  - CVE-2020-27795
  - CWE-908
  overview: A segmentation fault was discovered in radare2 with adf command. In libr/core/cmd_anal.c,
    when command "adf" has no or wrong argument, anal_fcn_data (core, input + 1) -->
    RAnalFunction *fcn = r_anal_get_fcn_in (core->anal, core->offset, -1); returns
    null pointer for fcn causing segmentation fault later in ensure_fcn_range (fcn).
  references:
  - source: secalert@redhat.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/radareorg/radare2/commit/4d3811681a80f92a53e795f6a64c4b0fc2c8dd22
  - source: secalert@redhat.com
    tags:
    - Exploit
    - Issue Tracking
    - Patch
    - Third Party Advisory
    url: https://github.com/radareorg/radare2/issues/16215
  - source: secalert@redhat.com
    tags:
    - Issue Tracking
    - Patch
    - Third Party Advisory
    url: https://github.com/radareorg/radare2/pull/16230
  title: A segmentation fault was discovered in radare2 with adf command. In libr/core/cmd_anal.c,
    when command "adf" has no or wrong argument, anal_fcn_data (core, input + 1) -->
    RAnalFunction *fcn = r_anal_get_fcn_in (core->anal, core->offset, -1); returns
    null pointer for fcn causing segmentation fault later in ensure_fcn_range (fcn).
- diff_content:
  - "--- a/src/jwe.c\n+++ b/src/jwe.c\n@@ -364,6 +364,11 @@ rsa_oaep_sha1_decrypt(const\
    \ struct rsa_private_key *key,\n   int res;\n   struct sha1_ctx ctx;\n \n+  if\
    \ (nettle_mpz_sizeinbase_256_u (gibberish) > key->size ||\n+      key->size <\
    \ (2*SHA1_DIGEST_SIZE)+2) {\n+    return 0;\n+  }\n+\n   mpz_init(m);\n   rsa_compute_root(key,\
    \ m, gibberish);\n \n@@ -384,6 +389,11 @@ rsa_oaep_sha256_decrypt(const struct\
    \ rsa_private_key *key,\n   int res;\n   struct sha256_ctx ctx;\n \n+  if (nettle_mpz_sizeinbase_256_u\
    \ (gibberish) > key->size ||\n+      key->size < (2*SHA1_DIGEST_SIZE)+2) {\n+\
    \    return 0;\n+  }\n+\n   mpz_init(m);\n   rsa_compute_root(key, m, gibberish);\n\
    \ "
  identifiers:
  - CVE-2022-38493
  - CWE-327
  overview: Rhonabwy 0.9.99 through 1.1.x before 1.1.7 doesn't check the RSA private
    key length before RSA-OAEP decryption. This allows attackers to cause a Denial
    of Service via a crafted JWE (JSON Web Encryption) token.
  references:
  - source: cve@mitre.org
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/babelouest/rhonabwy/commit/dd528b3aabd13863f855a68e76966e4e019fc399
  title: Rhonabwy 0.9.99 through 1.1.x before 1.1.7 doesn't check the RSA private
    key length before RSA-OAEP decryption. This allows attackers to cause a Denial
    of Service via a crafted JWE (JSON Web Encryption) token.
- diff_content:
  - "--- a/rpmio/rpmpgp.c\n+++ b/rpmio/rpmpgp.c\n@@ -1062,37 +1062,121 @@ static pgpDigParams\
    \ pgpDigParamsNew(uint8_t tag)\n     return digp;\n }\n \n+static int hashKey(DIGEST_CTX\
    \ hash, const struct pgpPkt *pkt, int exptag)\n+{\n+    int rc = -1;\n+    if\
    \ (pkt->tag == exptag) {\n+\tuint8_t head[] = {\n+\t    0x99,\n+\t    (pkt->blen\
    \ >> 8),\n+\t    (pkt->blen     ),\n+\t};\n+\n+\trpmDigestUpdate(hash, head, 3);\n\
    +\trpmDigestUpdate(hash, pkt->body, pkt->blen);\n+\trc = 0;\n+    }\n+    return\
    \ rc;\n+}\n+\n+static int pgpVerifySelf(pgpDigParams key, pgpDigParams selfsig,\n\
    +\t\t\tconst struct pgpPkt *all, int i)\n+{\n+    int rc = -1;\n+    DIGEST_CTX\
    \ hash = NULL;\n+\n+    switch (selfsig->sigtype) {\n+    case PGPSIGTYPE_SUBKEY_BINDING:\n\
    +\thash = rpmDigestInit(selfsig->hash_algo, 0);\n+\tif (hash) {\n+\t    rc = hashKey(hash,\
    \ &all[0], PGPTAG_PUBLIC_KEY);\n+\t    if (!rc)\n+\t\trc = hashKey(hash, &all[i-1],\
    \ PGPTAG_PUBLIC_SUBKEY);\n+\t}\n+\tbreak;\n+    default:\n+\t/* ignore types we\
    \ can't handle */\n+\trc = 0;\n+\tbreak;\n+    }\n+\n+    if (hash && rc == 0)\n\
    +\trc = pgpVerifySignature(key, selfsig, hash);\n+\n+    rpmDigestFinal(hash,\
    \ NULL, NULL, 0);\n+\n+    return rc;\n+}\n+\n int pgpPrtParams(const uint8_t\
    \ * pkts, size_t pktlen, unsigned int pkttype,\n \t\t pgpDigParams * ret)\n {\n\
    \     const uint8_t *p = pkts;\n     const uint8_t *pend = pkts + pktlen;\n  \
    \   pgpDigParams digp = NULL;\n-    struct pgpPkt pkt;\n+    pgpDigParams selfsig\
    \ = NULL;\n+    int i = 0;\n+    int alloced = 16; /* plenty for normal cases\
    \ */\n+    struct pgpPkt *all = xmalloc(alloced * sizeof(*all));\n     int rc\
    \ = -1; /* assume failure */\n+    int expect = 0;\n+    int prevtag = 0;\n \n\
    \     while (p < pend) {\n-\tif (decodePkt(p, (pend - p), &pkt))\n+\tstruct pgpPkt\
    \ *pkt = &all[i];\n+\tif (decodePkt(p, (pend - p), pkt))\n \t    break;\n \n \t\
    if (digp == NULL) {\n-\t    if (pkttype && pkt.tag != pkttype) {\n+\t    if (pkttype\
    \ && pkt->tag != pkttype) {\n \t\tbreak;\n \t    } else {\n-\t\tdigp = pgpDigParamsNew(pkt.tag);\n\
    +\t\tdigp = pgpDigParamsNew(pkt->tag);\n \t    }\n \t}\n \n-\tif (pgpPrtPkt(&pkt,\
    \ digp))\n+\tif (expect) {\n+\t    if (pkt->tag != expect)\n+\t\tbreak;\n+\t \
    \   selfsig = pgpDigParamsNew(pkt->tag);\n+\t}\n+\n+\tif (pgpPrtPkt(pkt, selfsig\
    \ ? selfsig : digp))\n \t    break;\n \n-\tp += (pkt.body - pkt.head) + pkt.blen;\n\
    +\tif (selfsig) {\n+\t    /* subkeys must be followed by binding signature */\n\
    +\t    if (prevtag == PGPTAG_PUBLIC_SUBKEY) {\n+\t\tif (selfsig->sigtype != PGPSIGTYPE_SUBKEY_BINDING)\n\
    +\t\t    break;\n+\t    }\n+\n+\t    int xx = pgpVerifySelf(digp, selfsig, all,\
    \ i);\n+\n+\t    selfsig = pgpDigParamsFree(selfsig);\n+\t    if (xx)\n+\t\tbreak;\n\
    +\t    expect = 0;\n+\t}\n+\n+\tif (pkt->tag == PGPTAG_PUBLIC_SUBKEY)\n+\t   \
    \ expect = PGPTAG_SIGNATURE;\n+\tprevtag = pkt->tag;\n+\n+\ti++;\n+\tp += (pkt->body\
    \ - pkt->head) + pkt->blen;\n \tif (pkttype == PGPTAG_SIGNATURE)\n \t    break;\n\
    +\n+\tif (alloced <= i) {\n+\t    alloced *= 2;\n+\t    all = xrealloc(all, alloced\
    \ * sizeof(*all));\n+\t}\n     }\n \n-    rc = (digp && (p == pend)) ? 0 : -1;\n\
    +    rc = (digp && (p == pend) && expect == 0) ? 0 : -1;\n \n+    free(all);\n\
    \     if (ret && rc == 0) {\n \t*ret = digp;\n     } else {"
  identifiers:
  - CVE-2021-3521
  - CWE-347
  overview: There is a flaw in RPM's signature functionality. OpenPGP subkeys are
    associated with a primary key via a "binding signature." RPM does not check the
    binding signature of subkeys prior to importing them. If an attacker is able to
    add or socially engineer another party to add a malicious subkey to a legitimate
    public key, RPM could wrongly trust a malicious signature. The greatest impact
    of this flaw is to data integrity. To exploit this flaw, an attacker must either
    compromise an RPM repository or convince an administrator to install an untrusted
    RPM or public key. It is strongly recommended to only use RPMs and public keys
    from trusted sources.
  references:
  - source: secalert@redhat.com
    tags:
    - Third Party Advisory
    url: https://access.redhat.com/security/cve/CVE-2021-3521
  - source: secalert@redhat.com
    tags:
    - Issue Tracking
    - Patch
    - Third Party Advisory
    url: https://bugzilla.redhat.com/show_bug.cgi?id=1941098
  - source: secalert@redhat.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/rpm-software-management/rpm/commit/bd36c5dc9fb6d90c46fbfed8c2d67516fc571ec8
  - source: secalert@redhat.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/rpm-software-management/rpm/pull/1795/
  - source: secalert@redhat.com
    tags:
    - Third Party Advisory
    url: https://security.gentoo.org/glsa/202210-22
  title: There is a flaw in RPM's signature functionality. OpenPGP subkeys are associated
    with a primary key via a "binding signature." RPM does not check the binding signature
    of subkeys prior to importing them. If an attacker is able to add or socially
    engineer another party to add a malicious subkey to a legitimate public key, RPM
    could wrongly trust a malicious signature. The greatest impact of this flaw is
    to data integrity. To exploit this flaw, an attacker must either compromise an
    RPM repository or convince an administrator to install an untrusted RPM or public
    key. It is strongly recommended to only use RPMs and public keys from trusted
    sources.
- diff_content:
  - "--- a/auth_mellon_util.c\n+++ b/auth_mellon_util.c\n@@ -927,6 +927,10 @@ int\
    \ am_check_url(request_rec *r, const char *url)\n {\n     const char *i;\n \n\
    +    if (url == NULL) {\n+        return HTTP_BAD_REQUEST;\n+    }\n+\n     for\
    \ (i = url; *i; i++) {\n         if (*i >= 0 && *i < ' ') {\n             /* Deny\
    \ all control-characters. */\n@@ -943,6 +947,12 @@ int am_check_url(request_rec\
    \ *r, const char *url)\n         }\n     }\n \n+    if (strstr(url, \"///\") ==\
    \ url) {\n+        AM_LOG_RERROR(APLOG_MARK, APLOG_ERR, HTTP_BAD_REQUEST, r,\n\
    +                          \"URL starts with '///'\");\n+        return HTTP_BAD_REQUEST;\n\
    +    }\n+\n     return OK;\n }\n "
  identifiers:
  - CVE-2021-3639
  - CWE-601
  overview: A flaw was found in mod_auth_mellon where it does not sanitize logout
    URLs properly. This issue could be used by an attacker to facilitate phishing
    attacks by tricking users into visiting a trusted web application URL that redirects
    to an external and potentially malicious server. The highest threat from this
    liability is to confidentiality and integrity.
  references:
  - source: secalert@redhat.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://access.redhat.com/security/cve/CVE-2021-3639
  - source: secalert@redhat.com
    tags:
    - Issue Tracking
    - Third Party Advisory
    url: https://bugzilla.redhat.com/show_bug.cgi?id=1980648
  - source: secalert@redhat.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/latchset/mod_auth_mellon/commit/42a11261b9dad2e48d70bdff7c53dd57a12db6f5
  title: A flaw was found in mod_auth_mellon where it does not sanitize logout URLs
    properly. This issue could be used by an attacker to facilitate phishing attacks
    by tricking users into visiting a trusted web application URL that redirects to
    an external and potentially malicious server. The highest threat from this liability
    is to confidentiality and integrity.
- diff_content:
  - "--- a/src/spellfile.c\n+++ b/src/spellfile.c\n@@ -5585,10 +5585,12 @@ sug_filltree(spellinfo_T\
    \ *spin, slang_T *slang)\n \n     /*\n      * Go through the whole case-folded\
    \ tree, soundfold each word and put it\n-     * in the trie.\n+     * in the trie.\
    \  Bail out if the tree is empty.\n      */\n     byts = slang->sl_fbyts;\n  \
    \   idxs = slang->sl_fidxs;\n+    if (byts == NULL || idxs == NULL)\n+\treturn\
    \ FAIL;\n \n     arridx[0] = 0;\n     curi[0] = 1;"
  - "--- a/src/version.c\n+++ b/src/version.c\n@@ -731,6 +731,8 @@ static char *(features[])\
    \ =\n \n static int included_patches[] =\n {   /* Add new patch number below this\
    \ line */\n+/**/\n+    240,\n /**/\n     239,\n /**/"
  identifiers:
  - CVE-2022-2923
  - CWE-476
  overview: NULL Pointer Dereference in GitHub repository vim/vim prior to 9.0.0240.
  references:
  - source: security@huntr.dev
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/vim/vim/commit/6669de1b235843968e88844ca6d3c8dec4b01a9e
  - source: security@huntr.dev
    tags:
    - Exploit
    - Third Party Advisory
    url: https://huntr.dev/bounties/fd3a3ab8-ab0f-452f-afea-8c613e283fd2
  - source: security@huntr.dev
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/C72HDIMR3KTTAO7QGTXWUMPBNFUFIBRD/
  - source: security@huntr.dev
    url: https://security.gentoo.org/glsa/202305-16
  title: NULL Pointer Dereference in GitHub repository vim/vim prior to 9.0.0240.
- diff_content:
  - "--- a/plugins/ua_config_default.c\n+++ b/plugins/ua_config_default.c\n@@ -59,13\
    \ +59,13 @@ UA_Server_new() {\n /*******************************/\n \n const UA_ConnectionConfig\
    \ UA_ConnectionConfig_default = {\n-    0,     /* .protocolVersion */\n-    65535,\
    \ /* .sendBufferSize, 64k per chunk */\n-    65535, /* .recvBufferSize, 64k per\
    \ chunk */\n-    0,     /* .localMaxMessageSize, 0 -> unlimited */\n-    0,  \
    \   /* .remoteMaxMessageSize, 0 -> unlimited */\n-    0,     /* .localMaxChunkCount,\
    \ 0 -> unlimited */\n-    0      /* .remoteMaxChunkCount, 0 -> unlimited */\n\
    +    0,       /* .protocolVersion */\n+    2 << 16, /* .sendBufferSize, 64k per\
    \ chunk */\n+    2 << 16, /* .recvBufferSize, 64k per chunk */\n+    2 << 29,\
    \ /* .localMaxMessageSize, 512 MB */\n+    2 << 29, /* .remoteMaxMessageSize,\
    \ 512 MB */\n+    2 << 14, /* .localMaxChunkCount, 16k */\n+    2 << 14  /* .remoteMaxChunkCount,\
    \ 16k */\n };\n \n /***************************/"
  - "--- a/tests/check_securechannel.c\n+++ b/tests/check_securechannel.c\n@@ -45,7\
    \ +45,8 @@ setup_secureChannel(void) {\n     UA_SecureChannel_init(&testChannel,\
    \ &UA_ConnectionConfig_default);\n     UA_SecureChannel_setSecurityPolicy(&testChannel,\
    \ &dummyPolicy, &dummyCertificate);\n \n-    testingConnection = createDummyConnection(65535,\
    \ &sentData);\n+    testingConnection =\n+        createDummyConnection(UA_ConnectionConfig_default.sendBufferSize,\
    \ &sentData);\n     UA_Connection_attachSecureChannel(&testingConnection, &testChannel);\n\
    \     testChannel.connection = &testingConnection;\n "
  identifiers:
  - CVE-2022-25761
  - CWE-770
  overview: The package open62541/open62541 before 1.2.5, from 1.3-rc1 and before
    1.3.1 are vulnerable to Denial of Service (DoS) due to a missing limitation on
    the number of received chunks - per single session or in total for all concurrent
    sessions. An attacker can exploit this vulnerability by sending an unlimited number
    of huge chunks (e.g. 2GB each) without sending the Final closing chunk.
  references:
  - source: report@snyk.io
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/open62541/open62541/commit/b79db1ac78146fc06b0b8435773d3967de2d659c
  - source: report@snyk.io
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/open62541/open62541/pull/5173
  - source: report@snyk.io
    tags:
    - Release Notes
    - Third Party Advisory
    url: https://github.com/open62541/open62541/releases/tag/v1.2.5
  - source: report@snyk.io
    tags:
    - Release Notes
    - Third Party Advisory
    url: https://github.com/open62541/open62541/releases/tag/v1.3.1
  - source: report@snyk.io
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/JNUV4FDVDBQHCPMOOEVKLMQK5SLKPK2L/
  - source: report@snyk.io
    tags:
    - Patch
    - Third Party Advisory
    url: https://security.snyk.io/vuln/SNYK-UNMANAGED-OPEN62541OPEN62541-2988719
  title: The package open62541/open62541 before 1.2.5, from 1.3-rc1 and before 1.3.1
    are vulnerable to Denial of Service (DoS) due to a missing limitation on the number
    of received chunks - per single session or in total for all concurrent sessions.
    An attacker can exploit this vulnerability by sending an unlimited number of huge
    chunks (e.g. 2GB each) without sending the Final closing chunk.
- diff_content:
  - "--- a/OpenEXR/IlmImf/ImfB44Compressor.cpp\n+++ b/OpenEXR/IlmImf/ImfB44Compressor.cpp\n\
    @@ -494,7 +494,7 @@ B44Compressor::B44Compressor\n     //\n \n     _tmpBuffer\
    \ = new unsigned short\n-        [checkArraySize (uiMult (maxScanLineSize, numScanLines),\n\
    +        [checkArraySize (uiMult (maxScanLineSize / sizeof(unsigned short), numScanLines),\n\
    \                          sizeof (unsigned short))];\n \n     const ChannelList\
    \ &channels = header().channels();"
  identifiers:
  - CVE-2021-20298
  - CWE-787
  overview: A flaw was found in OpenEXR's B44Compressor. This flaw allows an attacker
    who can submit a crafted file to be processed by OpenEXR, to exhaust all memory
    accessible to the application. The highest threat from this vulnerability is to
    system availability.
  references:
  - source: secalert@redhat.com
    tags:
    - Third Party Advisory
    url: https://access.redhat.com/security/cve/CVE-2021-20298
  - source: secalert@redhat.com
    tags:
    - Mailing List
    - Third Party Advisory
    url: https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=25913
  - source: secalert@redhat.com
    tags:
    - Issue Tracking
    - Third Party Advisory
    url: https://bugzilla.redhat.com/show_bug.cgi?id=1939156
  - source: secalert@redhat.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/AcademySoftwareFoundation/openexr/commit/85fd638ae0d5fa132434f4cbf32590261c1dba97
  - source: secalert@redhat.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/AcademySoftwareFoundation/openexr/pull/843
  - source: secalert@redhat.com
    tags:
    - Mailing List
    - Third Party Advisory
    url: https://lists.debian.org/debian-lts-announce/2022/12/msg00022.html
  title: A flaw was found in OpenEXR's B44Compressor. This flaw allows an attacker
    who can submit a crafted file to be processed by OpenEXR, to exhaust all memory
    accessible to the application. The highest threat from this vulnerability is to
    system availability.
- diff_content:
  - "--- a/OpenEXR/IlmImf/ImfHuf.cpp\n+++ b/OpenEXR/IlmImf/ImfHuf.cpp\n@@ -910,6 +910,11\
    \ @@ hufDecode\n \t\t//\n \n \t\tlc -= pl.len;\n+\n+\t\tif ( lc < 0 )\n+\t\t{\n\
    +\t\t\tinvalidCode(); // code length too long\n+\t\t}\n \t\tgetCode (pl.lit, rlc,\
    \ c, lc, in, out, outb, oe);\n \t    }\n \t    else\n@@ -967,6 +972,10 @@ hufDecode\n\
    \ \tif (pl.len)\n \t{\n \t    lc -= pl.len;\n+            if ( lc < 0 )\n+   \
    \         {\n+   \t        invalidCode(); // code length too long\n+         \
    \   }\n \t    getCode (pl.lit, rlc, c, lc, in, out, outb, oe);\n \t}\n \telse"
  - "--- a/OpenEXR/IlmImfTest/testHuf.cpp\n+++ b/OpenEXR/IlmImfTest/testHuf.cpp\n\
    @@ -245,70 +245,86 @@ testHuf (const std::string&)\n \n \tIMATH_NAMESPACE::Rand48\
    \ rand48 (0);\n \n-\tconst int N = 1000000;\n-\tArray <unsigned short> raw (N);\n\
    -\n-\tfill1 (raw, N, 1, rand48);\t  // test various symbol distributions\n-\t\
    compressUncompress (raw, N);\n-\tcompressUncompressSubset (raw, N);\n-\tfill1\
    \ (raw, N, 10, rand48);\n-\tcompressUncompress (raw, N);\n-\tcompressUncompressSubset\
    \ (raw, N);\n-\tfill1 (raw, N, 100, rand48);\n-\tcompressUncompress (raw, N);\n\
    -\tcompressUncompressSubset (raw, N);\n-\tfill1 (raw, N, 1000, rand48);\n-\tcompressUncompress\
    \ (raw, N);\n-\tcompressUncompressSubset (raw, N);\n-\n-\tfill2 (raw, N, 1, rand48);\n\
    -\tcompressUncompress (raw, N);\n-\tcompressUncompressSubset (raw, N);\n-\tfill2\
    \ (raw, N, 10, rand48);\n-\tcompressUncompress (raw, N);\n-\tcompressUncompressSubset\
    \ (raw, N);\n-\tfill2 (raw, N, 100, rand48);\n-\tcompressUncompress (raw, N);\n\
    -\tcompressUncompressSubset (raw, N);\n-\tfill2 (raw, N, 1000, rand48);\n-\tcompressUncompress\
    \ (raw, N);\n-\tcompressUncompressSubset (raw, N);\n-\n-\tfill3 (raw, N, 0);\n\
    -\tcompressUncompress (raw, N);\n-\tcompressUncompressSubset (raw, N);\n-\tfill3\
    \ (raw, N, 1);\n-\tcompressUncompress (raw, N);\n-\tcompressUncompressSubset (raw,\
    \ N);\n-\tfill3 (raw, N, USHRT_MAX - 1);\n-\tcompressUncompress (raw, N);\n-\t\
    compressUncompressSubset (raw, N);\n-\tfill3 (raw, N, USHRT_MAX);\n-\tcompressUncompress\
    \ (raw, N);\n-\tcompressUncompressSubset (raw, N);\n-\n-\tfill4 (raw, USHRT_MAX\
    \ + 1);\n-        compressVerify(raw, USHRT_MAX + 1, HUF_COMPRESS_DEK_HASH_FOR_FILL4_USHRT_MAX_PLUS_ONE);\n\
    -\tcompressUncompress (raw, USHRT_MAX + 1);\n-\tcompressUncompressSubset (raw,\
    \ USHRT_MAX + 1);\n-\tfill4 (raw, N);\n-        compressVerify(raw, N, HUF_COMPRESS_DEK_HASH_FOR_FILL4_N);\n\
    -\tcompressUncompress (raw, N);\n-\tcompressUncompressSubset (raw, N);\n-\n-\t\
    fill4 (raw, 0);\n-\tcompressUncompress (raw, 0);\t// test small input data sets\n\
    -\tfill4 (raw, 1);\n-\tcompressUncompress (raw, 1);\n-\tfill4 (raw, 2);\n-\tcompressUncompress\
    \ (raw, 2);\n-\tfill4 (raw, 3);\n-\tcompressUncompress (raw, 3);\n-\n-\tfill5\
    \ (raw, N);\t\t\t// test run-length coding of code table\n-        compressVerify(raw,\
    \ N, HUF_COMPRESS_DEK_HASH_FOR_FILL5_N);\n-\tcompressUncompress (raw, N);\n-\t\
    compressUncompressSubset (raw, N);\n+        //\n+        // FastHufDecoder is\
    \ used for more than 128 bits, so first test with fewer than 128 bits,\n+    \
    \    // then test FastHufDecoder\n+        //\n+        for (int pass = 0 ; pass\
    \ < 2 ; ++pass)\n+        {\n+\n+            int N = pass==0 ? 12 : 1000000;\n\
    +            Array <unsigned short> raw (N);\n+\n+            fill1 (raw, N, 1,\
    \ rand48);\t  // test various symbol distributions\n+            compressUncompress\
    \ (raw, N);\n+            compressUncompressSubset (raw, N);\n+            fill1\
    \ (raw, N, 10, rand48);\n+            compressUncompress (raw, N);\n+        \
    \    compressUncompressSubset (raw, N);\n+            fill1 (raw, N, 100, rand48);\n\
    +            compressUncompress (raw, N);\n+            compressUncompressSubset\
    \ (raw, N);\n+            fill1 (raw, N, 1000, rand48);\n+            compressUncompress\
    \ (raw, N);\n+            compressUncompressSubset (raw, N);\n+\n+           \
    \ fill2 (raw, N, 1, rand48);\n+            compressUncompress (raw, N);\n+   \
    \         compressUncompressSubset (raw, N);\n+            fill2 (raw, N, 10,\
    \ rand48);\n+            compressUncompress (raw, N);\n+            compressUncompressSubset\
    \ (raw, N);\n+            fill2 (raw, N, 100, rand48);\n+            compressUncompress\
    \ (raw, N);\n+            compressUncompressSubset (raw, N);\n+            fill2\
    \ (raw, N, 1000, rand48);\n+            compressUncompress (raw, N);\n+      \
    \      compressUncompressSubset (raw, N);\n+\n+            fill3 (raw, N, 0);\n\
    +            compressUncompress (raw, N);\n+            compressUncompressSubset\
    \ (raw, N);\n+            fill3 (raw, N, 1);\n+            compressUncompress\
    \ (raw, N);\n+            compressUncompressSubset (raw, N);\n+            fill3\
    \ (raw, N, USHRT_MAX - 1);\n+            compressUncompress (raw, N);\n+     \
    \       compressUncompressSubset (raw, N);\n+            fill3 (raw, N, USHRT_MAX);\n\
    +            compressUncompress (raw, N);\n+            compressUncompressSubset\
    \ (raw, N);\n+\n+            if (pass==1)\n+            {\n+                fill4\
    \ (raw, USHRT_MAX + 1);\n+                compressVerify(raw, USHRT_MAX + 1, HUF_COMPRESS_DEK_HASH_FOR_FILL4_USHRT_MAX_PLUS_ONE);\n\
    +\n+                compressUncompress (raw, USHRT_MAX + 1);\n+              \
    \  compressUncompressSubset (raw, USHRT_MAX + 1);\n+                fill4 (raw,\
    \ N);\n+                compressVerify(raw, N, HUF_COMPRESS_DEK_HASH_FOR_FILL4_N);\n\
    +            }\n+            compressUncompress (raw, N);\n+            compressUncompressSubset\
    \ (raw, N);\n+\n+            fill4 (raw, 0);\n+            compressUncompress\
    \ (raw, 0);\t// test small input data sets\n+            fill4 (raw, 1);\n+  \
    \          compressUncompress (raw, 1);\n+            fill4 (raw, 2);\n+     \
    \       compressUncompress (raw, 2);\n+            fill4 (raw, 3);\n+        \
    \    compressUncompress (raw, 3);\n+\n+            fill5 (raw, N);\t\t\t// test\
    \ run-length coding of code table\n+            if (pass==1)\n+            {\n\
    +                compressVerify(raw, N, HUF_COMPRESS_DEK_HASH_FOR_FILL5_N);\n\
    +            }\n+            compressUncompress (raw, N);\n+            compressUncompressSubset\
    \ (raw, N);\n+\n+        }\n \n \tcout << \"ok\\n\" << endl;\n     }"
  identifiers:
  - CVE-2021-20304
  - CWE-190
  overview: A flaw was found in OpenEXR's hufDecode functionality. This flaw allows
    an attacker who can pass a crafted file to be processed by OpenEXR, to trigger
    an undefined right shift error. The highest threat from this vulnerability is
    to system availability.
  references:
  - source: secalert@redhat.com
    tags:
    - Third Party Advisory
    url: https://access.redhat.com/security/cve/CVE-2021-20304
  - source: secalert@redhat.com
    tags:
    - Exploit
    - Mailing List
    - Third Party Advisory
    url: https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=26229
  - source: secalert@redhat.com
    tags:
    - Issue Tracking
    - Third Party Advisory
    url: https://bugzilla.redhat.com/show_bug.cgi?id=1939157
  - source: secalert@redhat.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/AcademySoftwareFoundation/openexr/commit/51a92d67f53c08230734e74564c807043cbfe41e
  - source: secalert@redhat.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/AcademySoftwareFoundation/openexr/pull/849
  - source: secalert@redhat.com
    tags:
    - Third Party Advisory
    url: https://security.gentoo.org/glsa/202210-31
  title: A flaw was found in OpenEXR's hufDecode functionality. This flaw allows an
    attacker who can pass a crafted file to be processed by OpenEXR, to trigger an
    undefined right shift error. The highest threat from this vulnerability is to
    system availability.
- diff_content:
  - "--- a/libarchive/archive_disk_acl_freebsd.c\n+++ b/libarchive/archive_disk_acl_freebsd.c\n\
    @@ -319,7 +319,7 @@ translate_acl(struct archive_read_disk *a,\n \n static int\n\
    \ set_acl(struct archive *a, int fd, const char *name,\n-    struct archive_acl\
    \ *abstract_acl,\n+    struct archive_acl *abstract_acl, __LA_MODE_T mode,\n \
    \    int ae_requested_type, const char *tname)\n {\n \tint\t\t acl_type = 0;\n\
    @@ -364,6 +364,13 @@ set_acl(struct archive *a, int fd, const char *name,\n \t\
    \treturn (ARCHIVE_FAILED);\n \t}\n \n+\tif (acl_type == ACL_TYPE_DEFAULT && !S_ISDIR(mode))\
    \ {\n+\t\terrno = EINVAL;\n+\t\tarchive_set_error(a, errno,\n+\t\t    \"Cannot\
    \ set default ACL on non-directory\");\n+\t\treturn (ARCHIVE_WARN);\n+\t}\n+\n\
    \ \tacl = acl_init(entries);\n \tif (acl == (acl_t)NULL) {\n \t\tarchive_set_error(a,\
    \ errno,\n@@ -542,7 +549,10 @@ set_acl(struct archive *a, int fd, const char *name,\n\
    \ \telse if (acl_set_link_np(name, acl_type, acl) != 0)\n #else\n \t/* FreeBSD\
    \ older than 8.0 */\n-\telse if (acl_set_file(name, acl_type, acl) != 0)\n+\t\
    else if (S_ISLNK(mode)) {\n+\t    /* acl_set_file() follows symbolic links, skip\
    \ */\n+\t    ret = ARCHIVE_OK;\n+\t} else if (acl_set_file(name, acl_type, acl)\
    \ != 0)\n #endif\n \t{\n \t\tif (errno == EOPNOTSUPP) {\n@@ -677,14 +687,14 @@\
    \ archive_write_disk_set_acls(struct archive *a, int fd, const char *name,\n \t\
    \    & ARCHIVE_ENTRY_ACL_TYPE_POSIX1E) != 0) {\n \t\tif ((archive_acl_types(abstract_acl)\n\
    \ \t\t    & ARCHIVE_ENTRY_ACL_TYPE_ACCESS) != 0) {\n-\t\t\tret = set_acl(a, fd,\
    \ name, abstract_acl,\n+\t\t\tret = set_acl(a, fd, name, abstract_acl, mode,\n\
    \ \t\t\t    ARCHIVE_ENTRY_ACL_TYPE_ACCESS, \"access\");\n \t\t\tif (ret != ARCHIVE_OK)\n\
    \ \t\t\t\treturn (ret);\n \t\t}\n \t\tif ((archive_acl_types(abstract_acl)\n \t\
    \t    & ARCHIVE_ENTRY_ACL_TYPE_DEFAULT) != 0)\n-\t\t\tret = set_acl(a, fd, name,\
    \ abstract_acl,\n+\t\t\tret = set_acl(a, fd, name, abstract_acl, mode,\n \t\t\t\
    \    ARCHIVE_ENTRY_ACL_TYPE_DEFAULT, \"default\");\n \n \t\t/* Simultaneous POSIX.1e\
    \ and NFSv4 is not supported */\n@@ -693,7 +703,7 @@ archive_write_disk_set_acls(struct\
    \ archive *a, int fd, const char *name,\n #if ARCHIVE_ACL_FREEBSD_NFS4\n \telse\
    \ if ((archive_acl_types(abstract_acl) &\n \t    ARCHIVE_ENTRY_ACL_TYPE_NFS4)\
    \ != 0) {\n-\t\tret = set_acl(a, fd, name, abstract_acl,\n+\t\tret = set_acl(a,\
    \ fd, name, abstract_acl, mode,\n \t\t    ARCHIVE_ENTRY_ACL_TYPE_NFS4, \"nfs4\"\
    );\n \t}\n #endif"
  - "--- a/libarchive/archive_disk_acl_linux.c\n+++ b/libarchive/archive_disk_acl_linux.c\n\
    @@ -343,6 +343,11 @@ set_richacl(struct archive *a, int fd, const char *name,\n\
    \ \t\treturn (ARCHIVE_FAILED);\n \t}\n \n+\tif (S_ISLNK(mode)) {\n+\t\t/* Linux\
    \ does not support RichACLs on symbolic links */\n+\t\treturn (ARCHIVE_OK);\n\
    +\t}\n+\n \trichacl = richacl_alloc(entries);\n \tif (richacl == NULL) {\n \t\t\
    archive_set_error(a, errno,\n@@ -455,7 +460,7 @@ set_richacl(struct archive *a,\
    \ int fd, const char *name,\n #if ARCHIVE_ACL_LIBACL\n static int\n set_acl(struct\
    \ archive *a, int fd, const char *name,\n-    struct archive_acl *abstract_acl,\n\
    +    struct archive_acl *abstract_acl, __LA_MODE_T mode,\n     int ae_requested_type,\
    \ const char *tname)\n {\n \tint\t\t acl_type = 0;\n@@ -488,6 +493,18 @@ set_acl(struct\
    \ archive *a, int fd, const char *name,\n \t\treturn (ARCHIVE_FAILED);\n \t}\n\
    \ \n+\tif (S_ISLNK(mode)) {\n+\t\t/* Linux does not support ACLs on symbolic links\
    \ */\n+\t\treturn (ARCHIVE_OK);\n+\t}\n+\n+\tif (acl_type == ACL_TYPE_DEFAULT\
    \ && !S_ISDIR(mode)) {\n+\t\terrno = EINVAL;\n+\t\tarchive_set_error(a, errno,\n\
    +\t\t    \"Cannot set default ACL on non-directory\");\n+\t\treturn (ARCHIVE_WARN);\n\
    +\t}\n+\n \tacl = acl_init(entries);\n \tif (acl == (acl_t)NULL) {\n \t\tarchive_set_error(a,\
    \ errno,\n@@ -727,14 +744,14 @@ archive_write_disk_set_acls(struct archive *a,\
    \ int fd, const char *name,\n \t    & ARCHIVE_ENTRY_ACL_TYPE_POSIX1E) != 0) {\n\
    \ \t\tif ((archive_acl_types(abstract_acl)\n \t\t    & ARCHIVE_ENTRY_ACL_TYPE_ACCESS)\
    \ != 0) {\n-\t\t\tret = set_acl(a, fd, name, abstract_acl,\n+\t\t\tret = set_acl(a,\
    \ fd, name, abstract_acl, mode,\n \t\t\t    ARCHIVE_ENTRY_ACL_TYPE_ACCESS, \"\
    access\");\n \t\t\tif (ret != ARCHIVE_OK)\n \t\t\t\treturn (ret);\n \t\t}\n \t\
    \tif ((archive_acl_types(abstract_acl)\n \t\t    & ARCHIVE_ENTRY_ACL_TYPE_DEFAULT)\
    \ != 0)\n-\t\t\tret = set_acl(a, fd, name, abstract_acl,\n+\t\t\tret = set_acl(a,\
    \ fd, name, abstract_acl, mode,\n \t\t\t    ARCHIVE_ENTRY_ACL_TYPE_DEFAULT, \"\
    default\");\n \t}\n #endif\t/* ARCHIVE_ACL_LIBACL */"
  - "--- a/libarchive/archive_disk_acl_sunos.c\n+++ b/libarchive/archive_disk_acl_sunos.c\n\
    @@ -443,7 +443,7 @@ translate_acl(struct archive_read_disk *a,\n \n static int\n\
    \ set_acl(struct archive *a, int fd, const char *name,\n-    struct archive_acl\
    \ *abstract_acl,\n+    struct archive_acl *abstract_acl, __LA_MODE_T mode,\n \
    \    int ae_requested_type, const char *tname)\n {\n \taclent_t\t *aclent;\n@@\
    \ -492,6 +491,12 @@ set_acl(struct archive *a, int fd, const char *name,\n \t\t\
    return (ARCHIVE_FAILED);\n \t}\n \n+        if (S_ISLNK(mode)) {\n+          \
    \      /* Skip ACLs on symbolic links */\n+\t\tret = ARCHIVE_OK;\n+\t\tgoto exit_free;\n\
    +        }\n+\n \te = 0;\n \n \twhile (archive_acl_next(a, abstract_acl, ae_requested_type,\
    \ &ae_type,\n@@ -801,7 +806,7 @@ archive_write_disk_set_acls(struct archive *a,\
    \ int fd, const char *name,\n \tif ((archive_acl_types(abstract_acl)\n \t    &\
    \ ARCHIVE_ENTRY_ACL_TYPE_POSIX1E) != 0) {\n \t\t/* Solaris writes POSIX.1e access\
    \ and default ACLs together */\n-\t\tret = set_acl(a, fd, name, abstract_acl,\n\
    +\t\tret = set_acl(a, fd, name, abstract_acl, mode,\n \t\t    ARCHIVE_ENTRY_ACL_TYPE_POSIX1E,\
    \ \"posix1e\");\n \n \t\t/* Simultaneous POSIX.1e and NFSv4 is not supported */\n\
    @@ -810,7 +815,7 @@ archive_write_disk_set_acls(struct archive *a, int fd, const\
    \ char *name,\n #if ARCHIVE_ACL_SUNOS_NFS4\n \telse if ((archive_acl_types(abstract_acl)\
    \ &\n \t    ARCHIVE_ENTRY_ACL_TYPE_NFS4) != 0) {\n-\t\tret = set_acl(a, fd, name,\
    \ abstract_acl,\n+\t\tret = set_acl(a, fd, name, abstract_acl, mode,\n \t\t  \
    \  ARCHIVE_ENTRY_ACL_TYPE_NFS4, \"nfs4\");\n \t}\n #endif"
  identifiers:
  - CVE-2021-23177
  - CWE-59
  overview: An improper link resolution flaw while extracting an archive can lead
    to changing the access control list (ACL) of the target of the link. An attacker
    may provide a malicious archive to a victim user, who would trigger this flaw
    when trying to extract the archive. A local attacker may use this flaw to change
    the ACL of a file on the system and gain more privileges.
  references:
  - source: secalert@redhat.com
    tags:
    - Third Party Advisory
    url: https://access.redhat.com/security/cve/CVE-2021-23177
  - source: secalert@redhat.com
    tags:
    - Issue Tracking
    - Patch
    - Third Party Advisory
    url: https://bugzilla.redhat.com/show_bug.cgi?id=2024245
  - source: secalert@redhat.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/libarchive/libarchive/commit/fba4f123cc456d2b2538f811bb831483bf336bad
  - source: secalert@redhat.com
    tags:
    - Issue Tracking
    - Patch
    - Third Party Advisory
    url: https://github.com/libarchive/libarchive/issues/1565
  - source: secalert@redhat.com
    tags:
    - Mailing List
    - Third Party Advisory
    url: https://lists.debian.org/debian-lts-announce/2022/11/msg00030.html
  title: An improper link resolution flaw while extracting an archive can lead to
    changing the access control list (ACL) of the target of the link. An attacker
    may provide a malicious archive to a victim user, who would trigger this flaw
    when trying to extract the archive. A local attacker may use this flaw to change
    the ACL of a file on the system and gain more privileges.
- diff_content:
  - "--- a/libarchive/archive_write_disk_posix.c\n+++ b/libarchive/archive_write_disk_posix.c\n\
    @@ -2461,6 +2461,7 @@ _archive_write_disk_close(struct archive *_a)\n {\n \tstruct\
    \ archive_write_disk *a = (struct archive_write_disk *)_a;\n \tstruct fixup_entry\
    \ *next, *p;\n+\tstruct stat st;\n \tint fd, ret;\n \n \tarchive_check_magic(&a->archive,\
    \ ARCHIVE_WRITE_DISK_MAGIC,\n@@ -2478,6 +2479,20 @@ _archive_write_disk_close(struct\
    \ archive *_a)\n \t\t    (TODO_TIMES | TODO_MODE_BASE | TODO_ACLS | TODO_FFLAGS))\
    \ {\n \t\t\tfd = open(p->name,\n \t\t\t    O_WRONLY | O_BINARY | O_NOFOLLOW |\
    \ O_CLOEXEC);\n+\t\t\tif (fd == -1) {\n+\t\t\t\t/* If we cannot lstat, skip entry\
    \ */\n+\t\t\t\tif (lstat(p->name, &st) != 0)\n+\t\t\t\t\tgoto skip_fixup_entry;\n\
    +\t\t\t\t/*\n+\t\t\t\t * If we deal with a symbolic link, mark\n+\t\t\t\t * it\
    \ in the fixup mode to ensure no\n+\t\t\t\t * modifications are made to its target.\n\
    +\t\t\t\t */\n+\t\t\t\tif (S_ISLNK(st.st_mode)) {\n+\t\t\t\t\tp->mode &= ~S_IFMT;\n\
    +\t\t\t\t\tp->mode |= S_IFLNK;\n+\t\t\t\t}\n+\t\t\t}\n \t\t}\n \t\tif (p->fixup\
    \ & TODO_TIMES) {\n \t\t\tset_times(a, fd, p->mode, p->name,\n@@ -2492,7 +2507,12\
    \ @@ _archive_write_disk_close(struct archive *_a)\n \t\t\t\tfchmod(fd, p->mode);\n\
    \ \t\t\telse\n #endif\n-\t\t\tchmod(p->name, p->mode);\n+#ifdef HAVE_LCHMOD\n\
    +\t\t\tlchmod(p->name, p->mode);\n+#else\n+\t\t\tif (!S_ISLNK(p->mode))\n+\t\t\
    \t\tchmod(p->name, p->mode);\n+#endif\n \t\t}\n \t\tif (p->fixup & TODO_ACLS)\n\
    \ \t\t\tarchive_write_disk_set_acls(&a->archive, fd,\n@@ -2503,6 +2523,7 @@ _archive_write_disk_close(struct\
    \ archive *_a)\n \t\tif (p->fixup & TODO_MAC_METADATA)\n \t\t\tset_mac_metadata(a,\
    \ p->name, p->mac_metadata,\n \t\t\t\t\t p->mac_metadata_size);\n+skip_fixup_entry:\n\
    \ \t\tnext = p->next;\n \t\tarchive_acl_clear(&p->acl);\n \t\tfree(p->mac_metadata);\n\
    @@ -2643,6 +2664,7 @@ new_fixup(struct archive_write_disk *a, const char *pathname)\n\
    \ \tfe->next = a->fixup_list;\n \ta->fixup_list = fe;\n \tfe->fixup = 0;\n+\t\
    fe->mode = 0;\n \tfe->name = strdup(pathname);\n \treturn (fe);\n }"
  - "--- a/libarchive/test/test_write_disk_fixup.c\n+++ b/libarchive/test/test_write_disk_fixup.c\n\
    @@ -0,0 +1,77 @@\n+/*-\n+ * Copyright (c) 2021 Martin Matuska\n+ * All rights\
    \ reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with\
    \ or without\n+ * modification, are permitted provided that the following conditions\n\
    + * are met:\n+ * 1. Redistributions of source code must retain the above copyright\n\
    + *    notice, this list of conditions and the following disclaimer.\n+ * 2. Redistributions\
    \ in binary form must reproduce the above copyright\n+ *    notice, this list\
    \ of conditions and the following disclaimer in the\n+ *    documentation and/or\
    \ other materials provided with the distribution.\n+ *\n+ * THIS SOFTWARE IS PROVIDED\
    \ BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR\n+ * IMPLIED WARRANTIES, INCLUDING,\
    \ BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS\
    \ FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n+ * IN NO EVENT SHALL THE AUTHOR(S)\
    \ BE LIABLE FOR ANY DIRECT, INDIRECT,\n+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR\
    \ CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE\
    \ GOODS OR SERVICES; LOSS OF USE,\n+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\
    \ HOWEVER CAUSED AND ON ANY\n+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\
    \ LIABILITY, OR TORT\n+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\
    \ OUT OF THE USE OF\n+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\
    \ SUCH DAMAGE.\n+ */\n+#include \"test.h\"\n+\n+/*\n+ * Test fixup entries don't\
    \ follow symlinks\n+ */\n+DEFINE_TEST(test_write_disk_fixup)\n+{\n+\tstruct archive\
    \ *ad;\n+\tstruct archive_entry *ae;\n+\tint r;\n+\n+\tif (!canSymlink()) {\n\
    +\t\tskipping(\"Symlinks not supported\");\n+\t\treturn;\n+\t}\n+\n+\t/* Write\
    \ entries to disk. */\n+\tassert((ad = archive_write_disk_new()) != NULL);\n+\n\
    +\t/*\n+\t * Create a file\n+\t */\n+\tassertMakeFile(\"victim\", 0600, \"a\"\
    );\n+\n+\t/*\n+\t * Create a directory and a symlink with the same name\n+\t */\n\
    +\n+\t/* Directory: dir */\n+        assert((ae = archive_entry_new()) != NULL);\n\
    +        archive_entry_copy_pathname(ae, \"dir\");\n+        archive_entry_set_mode(ae,\
    \ AE_IFDIR | 0606);\n+\tassertEqualIntA(ad, 0, archive_write_header(ad, ae));\n\
    +\tassertEqualIntA(ad, 0, archive_write_finish_entry(ad));\n+        archive_entry_free(ae);\n\
    +\n+\t/* Symbolic Link: dir -> foo */\n+\tassert((ae = archive_entry_new()) !=\
    \ NULL);\n+\tarchive_entry_copy_pathname(ae, \"dir\");\n+\tarchive_entry_set_mode(ae,\
    \ AE_IFLNK | 0777);\n+\tarchive_entry_set_size(ae, 0);\n+\tarchive_entry_copy_symlink(ae,\
    \ \"victim\");\n+\tassertEqualIntA(ad, 0, r = archive_write_header(ad, ae));\n\
    +\tif (r >= ARCHIVE_WARN)\n+\t\tassertEqualIntA(ad, 0, archive_write_finish_entry(ad));\n\
    +\tarchive_entry_free(ae);\n+\n+\tassertEqualInt(ARCHIVE_OK, archive_write_free(ad));\n\
    +\n+\t/* Test the entries on disk. */\n+\tassertIsSymlink(\"dir\", \"victim\"\
    , 0);\n+\tassertFileMode(\"victim\", 0600);\n+}"
  identifiers:
  - CVE-2021-31566
  - CWE-59
  overview: An improper link resolution flaw can occur while extracting an archive
    leading to changing modes, times, access control lists, and flags of a file outside
    of the archive. An attacker may provide a malicious archive to a victim user,
    who would trigger this flaw when trying to extract the archive. A local attacker
    may use this flaw to gain more privileges in a system.
  references:
  - source: secalert@redhat.com
    tags:
    - Third Party Advisory
    url: https://access.redhat.com/security/cve/CVE-2021-31566
  - source: secalert@redhat.com
    tags:
    - Issue Tracking
    - Patch
    - Third Party Advisory
    url: https://bugzilla.redhat.com/show_bug.cgi?id=2024237
  - source: secalert@redhat.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/libarchive/libarchive/commit/b41daecb5ccb4c8e3b2c53fd6147109fc12c3043
  - source: secalert@redhat.com
    tags:
    - Issue Tracking
    - Patch
    - Third Party Advisory
    url: https://github.com/libarchive/libarchive/issues/1566
  - source: secalert@redhat.com
    tags:
    - Mailing List
    - Third Party Advisory
    url: https://lists.debian.org/debian-lts-announce/2022/11/msg00030.html
  title: An improper link resolution flaw can occur while extracting an archive leading
    to changing modes, times, access control lists, and flags of a file outside of
    the archive. An attacker may provide a malicious archive to a victim user, who
    would trigger this flaw when trying to extract the archive. A local attacker may
    use this flaw to gain more privileges in a system.
- diff_content:
  - "--- a/lib/ldb/ldb_key_value/ldb_kv.c\n+++ b/lib/ldb/ldb_key_value/ldb_kv.c\n\
    @@ -2078,6 +2078,8 @@ static int ldb_kv_handle_request(struct ldb_module *module,\n\
    \ \t\t}\n \t}\n \n+\tac->timeout_timeval = tv;\n+\n \t/* set a spy so that we\
    \ do not try to use the request context\n \t * if it is freed before ltdb_callback\
    \ fires */\n \tac->spy = talloc(req, struct ldb_kv_req_spy);\n"
  - "--- a/lib/ldb/ldb_key_value/ldb_kv_index.c\n+++ b/lib/ldb/ldb_key_value/ldb_kv_index.c\n\
    @@ -2352,6 +2352,47 @@ static int ldb_kv_index_filter(struct ldb_kv_private *ldb_kv,\n\
    \ \tfor (i = 0; i < num_keys; i++) {\n \t\tint ret;\n \t\tbool matched;\n+\n+\t\
    \t/*\n+\t\t * Check the time every 64 records, to reduce calls to\n+\t\t * gettimeofday().\
    \  This is a compromise, not all\n+\t\t * calls to ldb_match_message() will take\
    \ the same\n+\t\t * time, most will run quickly but by luck it might be\n+\t\t\
    \ * possible to have 64 records that are slow, doing a\n+\t\t * recursive search\
    \ via LDAP_MATCHING_RULE_IN_CHAIN.\n+\t\t *\n+\t\t * Thankfully this is after\
    \ index processing so only\n+\t\t * on the subset that matches some index (but\
    \ still\n+\t\t * possibly a big one like objectclass=user)\n+\t\t */\n+\t\tif\
    \ (i % 64 == 0) {\n+\t\t\tstruct timeval now = tevent_timeval_current();\n+\t\t\
    \tint timeval_cmp = tevent_timeval_compare(&ac->timeout_timeval,\n+\t\t\t\t\t\t\
    \t\t &now);\n+\n+\t\t\t/*\n+\t\t\t * The search has taken too long.  This is the\n\
    +\t\t\t * most likely place for our time to expire,\n+\t\t\t * as we are checking\
    \ the records after the\n+\t\t\t * index set intersection.  This is now the\n\
    +\t\t\t * slow process of checking if the records\n+\t\t\t * actually match.\n\
    +\t\t\t *\n+\t\t\t * The tevent based timeout is not likely to\n+\t\t\t * be hit,\
    \ sadly, as we don't run an event\n+\t\t\t * loop.\n+\t\t\t *\n+\t\t\t * While\
    \ we are indexed and most of the work\n+\t\t\t * should have been done already,\
    \ the\n+\t\t\t * ldb_match_* calls can be quite expensive if\n+\t\t\t * the caller\
    \ uses LDAP_MATCHING_RULE_IN_CHAIN\n+\t\t\t */\n+\t\t\tif (timeval_cmp <= 0) {\n\
    +\t\t\t\ttalloc_free(keys);\n+\t\t\t\treturn LDB_ERR_TIME_LIMIT_EXCEEDED;\n+\t\
    \t\t}\n+\t\t}\n+\n \t\tmsg = ldb_msg_new(ac);\n \t\tif (!msg) {\n \t\t\ttalloc_free(keys);\n"
  - "--- a/lib/ldb/ldb_key_value/ldb_kv_search.c\n+++ b/lib/ldb/ldb_key_value/ldb_kv_search.c\n\
    @@ -314,7 +314,8 @@ static int search_func(_UNUSED_ struct ldb_kv_private *ldb_kv,\n\
    \ \tstruct ldb_context *ldb;\n \tstruct ldb_kv_context *ac;\n \tstruct ldb_message\
    \ *msg, *filtered_msg;\n-\tint ret;\n+\tstruct timeval now;\n+\tint ret, timeval_cmp;\n\
    \ \tbool matched;\n \n \tac = talloc_get_type(state, struct ldb_kv_context);\n\
    @@ -341,6 +342,36 @@ static int search_func(_UNUSED_ struct ldb_kv_private *ldb_kv,\n\
    \ \t\treturn 0;\n \t}\n \n+\t/*\n+\t * Check the time every 64 records, to reduce\
    \ calls to\n+\t * gettimeofday().  This is a compromise, not all calls to\n+\t\
    \ * ldb_match_message() will take the same time, most will fail\n+\t * quickly\
    \ but by luck it might be possible to have 64 records\n+\t * that are slow, doing\
    \ a recursive search via\n+\t * LDAP_MATCHING_RULE_IN_CHAIN.\n+\t */\n+\tif (ac->timeout_counter++\
    \ % 64 == 0) {\n+\t\tnow = tevent_timeval_current();\n+\t\ttimeval_cmp = tevent_timeval_compare(&ac->timeout_timeval,\n\
    +\t\t\t\t\t\t     &now);\n+\n+\t\t/*\n+\t\t * The search has taken too long. \
    \ This is the most\n+\t\t * likely place for our time to expire, as we are in\n\
    +\t\t * an un-indexed search and we return the data from\n+\t\t * within this\
    \ loop.  The tevent based timeout is not\n+\t\t * likely to be hit, sadly.\n+\t\
    \t *\n+\t\t * ldb_match_msg_error() can be quite expensive if a\n+\t\t * LDAP_MATCHING_RULE_IN_CHAIN\
    \ extended match was\n+\t\t * specified.\n+\t\t */\n+\t\tif (timeval_cmp <= 0)\
    \ {\n+\t\t\tac->error = LDB_ERR_TIME_LIMIT_EXCEEDED;\n+\t\t\treturn -1;\n+\t\t\
    }\n+\t}\n+\n \tmsg = ldb_msg_new(ac);\n \tif (!msg) {\n \t\tac->error = LDB_ERR_OPERATIONS_ERROR;\n"
  - "--- a/source4/ldap_server/ldap_backend.c\n+++ b/source4/ldap_server/ldap_backend.c\n\
    @@ -729,9 +729,6 @@ static NTSTATUS ldapsrv_SearchRequest(struct ldapsrv_call\
    \ *call)\n \tunsigned int i;\n \tint extended_type = 1;\n \n-\tDEBUG(10, (\"SearchRequest\"\
    ));\n-\tDEBUGADD(10, (\" basedn: %s\", req->basedn));\n-\tDEBUGADD(10, (\" filter:\
    \ %s\\n\", ldb_filter_from_tree(call, req->tree)));\n \n \tlocal_ctx = talloc_new(call);\n\
    \ \tNT_STATUS_HAVE_NO_MEMORY(local_ctx);\n"
  - "--- a/source4/ldap_server/ldap_backend.c\n+++ b/source4/ldap_server/ldap_backend.c\n\
    @@ -729,6 +729,15 @@ static NTSTATUS ldapsrv_SearchRequest(struct ldapsrv_call\
    \ *call)\n \tunsigned int i;\n \tint extended_type = 1;\n \n+\t/*\n+\t * Warn\
    \ for searches that are longer than 1/4 of the\n+\t * search_timeout, being 30sec\
    \ by default\n+\t */\n+\tstruct timeval start_time = timeval_current();\n+\tstruct\
    \ timeval warning_time\n+\t\t= timeval_add(&start_time,\n+\t\t\t      call->conn->limits.search_timeout\
    \ / 4,\n+\t\t\t      0);\n \n \tlocal_ctx = talloc_new(call);\n \tNT_STATUS_HAVE_NO_MEMORY(local_ctx);\n\
    @@ -736,29 +745,27 @@ static NTSTATUS ldapsrv_SearchRequest(struct ldapsrv_call\
    \ *call)\n \tbasedn = ldb_dn_new(local_ctx, samdb, req->basedn);\n \tNT_STATUS_HAVE_NO_MEMORY(basedn);\n\
    \ \n-\tDEBUG(10, (\"SearchRequest: basedn: [%s]\\n\", req->basedn));\n-\tDEBUG(10,\
    \ (\"SearchRequest: filter: [%s]\\n\", ldb_filter_from_tree(call, req->tree)));\n\
    -\n \tswitch (req->scope) {\n-\t\tcase LDAP_SEARCH_SCOPE_BASE:\n-\t\t\tscope_str\
    \ = \"BASE\";\n-\t\t\tscope = LDB_SCOPE_BASE;\n-\t\t\tbreak;\n-\t\tcase LDAP_SEARCH_SCOPE_SINGLE:\n\
    -\t\t\tscope_str = \"ONE\";\n-\t\t\tscope = LDB_SCOPE_ONELEVEL;\n-\t\t\tbreak;\n\
    -\t\tcase LDAP_SEARCH_SCOPE_SUB:\n-\t\t\tscope_str = \"SUB\";\n-\t\t\tscope =\
    \ LDB_SCOPE_SUBTREE;\n-\t\t\tbreak;\n-\t        default:\n-\t\t\tresult = LDAP_PROTOCOL_ERROR;\n\
    -\t\t\tmap_ldb_error(local_ctx, LDB_ERR_PROTOCOL_ERROR, NULL,\n-\t\t\t\t&errstr);\n\
    -\t\t\terrstr = talloc_asprintf(local_ctx,\n-\t\t\t\t\"%s. Invalid scope\", errstr);\n\
    -\t\t\tgoto reply;\n+\tcase LDAP_SEARCH_SCOPE_BASE:\n+\t\tscope_str = \"BASE\"\
    ;\n+\t\tscope = LDB_SCOPE_BASE;\n+\t\tbreak;\n+\tcase LDAP_SEARCH_SCOPE_SINGLE:\n\
    +\t\tscope_str = \"ONE\";\n+\t\tscope = LDB_SCOPE_ONELEVEL;\n+\t\tbreak;\n+\t\
    case LDAP_SEARCH_SCOPE_SUB:\n+\t\tscope_str = \"SUB\";\n+\t\tscope = LDB_SCOPE_SUBTREE;\n\
    +\t\tbreak;\n+\tdefault:\n+\t\tresult = LDAP_PROTOCOL_ERROR;\n+\t\tmap_ldb_error(local_ctx,\
    \ LDB_ERR_PROTOCOL_ERROR, NULL,\n+\t\t\t      &errstr);\n+\t\tscope_str = \"<Invalid\
    \ scope>\";\n+\t\terrstr = talloc_asprintf(local_ctx,\n+\t\t\t\t\t \"%s. Invalid\
    \ scope\", errstr);\n+\t\tgoto reply;\n \t}\n \tDEBUG(10,(\"SearchRequest: scope:\
    \ [%s]\\n\", scope_str));\n \n@@ -911,6 +918,76 @@ static NTSTATUS ldapsrv_SearchRequest(struct\
    \ ldapsrv_call *call)\n \t}\n \n reply:\n+\n+\t/*\n+\t * This looks like duplicated\
    \ code - because it is - but\n+\t * otherwise the work in the parameters will\
    \ be done\n+\t * regardless, this way the functions only execuate when the\n+\t\
    \ * log level is set.\n+\t *\n+\t * The basedn is re-obtained as a string to escape\
    \ it\n+\t */\n+\tif ((req->timelimit == 0 || call->conn->limits.search_timeout\
    \ < req->timelimit)\n+\t    && ldb_ret == LDB_ERR_TIME_LIMIT_EXCEEDED) {\n+\t\t\
    struct dom_sid_buf sid_buf;\n+\t\tDBG_WARNING(\"MaxQueryDuration(%d) timeout exceeded\
    \ \"\n+\t\t\t    \"in SearchRequest by %s from %s filter: [%s] \"\n+\t\t\t   \
    \ \"basedn: [%s] \"\n+\t\t\t    \"scope: [%s]\\n\",\n+\t\t\t    call->conn->limits.search_timeout,\n\
    +\t\t\t    dom_sid_str_buf(&call->conn->session_info->security_token->sids[0],\n\
    +\t\t\t\t\t    &sid_buf),\n+\t\t\t    tsocket_address_string(call->conn->connection->remote_address,\n\
    +\t\t\t\t\t\t   call),\n+\t\t\t    ldb_filter_from_tree(call, req->tree),\n+\t\
    \t\t    ldb_dn_get_extended_linearized(call, basedn, 1),\n+\t\t\t    scope_str);\n\
    +\t\tfor (i=0; i < req->num_attributes; i++) {\n+\t\t\tDBG_WARNING(\"MaxQueryDuration\
    \ timeout exceeded attrs: [%s]\\n\",\n+\t\t\t\t    req->attributes[i]);\n+\t\t\
    }\n+\n+\t} else if (timeval_expired(&warning_time)) {\n+\t\tstruct dom_sid_buf\
    \ sid_buf;\n+\t\tDBG_NOTICE(\"Long LDAP Query: Duration was %.2fs, \"\n+\t\t\t\
    \   \"MaxQueryDuration(%d)/4 == %d \"\n+\t\t\t   \"in SearchRequest by %s from\
    \ %s filter: [%s] \"\n+\t\t\t   \"basedn: [%s] \"\n+\t\t\t   \"scope: [%s] \"\n\
    +\t\t\t   \"result: %s\\n\",\n+\t\t\t   timeval_elapsed(&start_time),\n+\t\t\t\
    \   call->conn->limits.search_timeout,\n+\t\t\t   call->conn->limits.search_timeout\
    \ / 4,\n+\t\t\t   dom_sid_str_buf(&call->conn->session_info->security_token->sids[0],\n\
    +\t\t\t\t\t   &sid_buf),\n+\t\t\t   tsocket_address_string(call->conn->connection->remote_address,\n\
    +\t\t\t\t\t\t  call),\n+\t\t\t   ldb_filter_from_tree(call, req->tree),\n+\t\t\
    \t   ldb_dn_get_extended_linearized(call, basedn, 1),\n+\t\t\t   scope_str,\n\
    +\t\t\t   ldb_strerror(ldb_ret));\n+\t\tfor (i=0; i < req->num_attributes; i++)\
    \ {\n+\t\t\tDBG_NOTICE(\"Long LDAP Query attrs: [%s]\\n\",\n+\t\t\t\t   req->attributes[i]);\n\
    +\t\t}\n+\t} else {\n+\t\tstruct dom_sid_buf sid_buf;\n+\t\tDBG_INFO(\"LDAP Query:\
    \ Duration was %.2fs, \"\n+\t\t\t \"SearchRequest by %s from %s filter: [%s] \"\
    \n+\t\t\t \"basedn: [%s] \"\n+\t\t\t \"scope: [%s] \"\n+\t\t\t \"result: %s\\\
    n\",\n+\t\t\t timeval_elapsed(&start_time),\n+\t\t\t dom_sid_str_buf(&call->conn->session_info->security_token->sids[0],\n\
    +\t\t\t\t\t &sid_buf),\n+\t\t\t tsocket_address_string(call->conn->connection->remote_address,\n\
    +\t\t\t\t\t\tcall),\n+\t\t\t ldb_filter_from_tree(call, req->tree),\n+\t\t\t ldb_dn_get_extended_linearized(call,\
    \ basedn, 1),\n+\t\t\t scope_str,\n+\t\t\t ldb_strerror(ldb_ret));\n+\t}\n+\n\
    \ \tDLIST_REMOVE(call->conn->pending_calls, call);\n \tcall->notification.busy\
    \ = false;\n \n"
  - "--- a/source4/dsdb/samdb/ldb_modules/anr.c\n+++ b/source4/dsdb/samdb/ldb_modules/anr.c\n\
    @@ -148,8 +148,6 @@ static int anr_replace_value(struct anr_context *ac,\n \t\t\
    return LDB_ERR_OPERATIONS_ERROR;\n \t}\n \n-\tac->found_anr = true;\n-\n \tif\
    \ (match->length > 1 && match->data[0] == '=') {\n \t\tstruct ldb_val *match2\
    \ = talloc(mem_ctx, struct ldb_val);\n \t\tif (match2 == NULL){\n@@ -285,6 +283,49\
    \ @@ static int anr_replace_subtrees(struct anr_context *ac,\n \treturn LDB_SUCCESS;\n\
    \ }\n \n+struct anr_present_ctx {\n+\tbool found_anr;\n+\tconst char *attr;\n\
    +};\n+\n+/*\n+  callback to determine if ANR is in use at all\n+ */\n+static int\
    \ parse_tree_anr_present(struct ldb_parse_tree *tree, void *private_context)\n\
    +{\n+\tstruct anr_present_ctx *ctx = private_context;\n+\tswitch (tree->operation)\
    \ {\n+\tcase LDB_OP_EQUALITY:\n+\tcase LDB_OP_GREATER:\n+\tcase LDB_OP_LESS:\n\
    +\tcase LDB_OP_APPROX:\n+\t\tif (ldb_attr_cmp(tree->u.equality.attr, ctx->attr)\
    \ == 0) {\n+\t\t\tctx->found_anr = true;\n+\t\t}\n+\t\tbreak;\n+\tcase LDB_OP_SUBSTRING:\n\
    +\t\tif (ldb_attr_cmp(tree->u.substring.attr, ctx->attr) == 0) {\n+\t\t\tctx->found_anr\
    \ = true;\n+\t\t}\n+\t\tbreak;\n+\tcase LDB_OP_PRESENT:\n+\t\tif (ldb_attr_cmp(tree->u.present.attr,\
    \ ctx->attr) == 0) {\n+\t\t\tctx->found_anr = true;\n+\t\t}\n+\t\tbreak;\n+\t\
    case LDB_OP_EXTENDED:\n+\t\tif (tree->u.extended.attr &&\n+\t\t    ldb_attr_cmp(tree->u.extended.attr,\
    \ ctx->attr) == 0) {\n+\t\t\tctx->found_anr = true;\n+\t\t}\n+\t\tbreak;\n+\t\
    default:\n+\t\tbreak;\n+\t}\n+\treturn LDB_SUCCESS;\n+}\n+\n+\n static int anr_search_callback(struct\
    \ ldb_request *req, struct ldb_reply *ares)\n {\n \tstruct anr_context *ac;\n\
    @@ -322,8 +363,21 @@ static int anr_search(struct ldb_module *module, struct ldb_request\
    \ *req)\n \tstruct ldb_parse_tree *anr_tree;\n \tstruct ldb_request *down_req;\n\
    \ \tstruct anr_context *ac;\n+\tstruct anr_present_ctx ctx;\n+\tconst char *attr\
    \ = \"anr\";\n \tint ret;\n \n+\tctx.found_anr = false;\n+\tctx.attr = attr;\n\
    +\n+\tldb_parse_tree_walk(req->op.search.tree,\n+\t\t\t    parse_tree_anr_present,\n\
    +\t\t\t    &ctx);\n+\n+\tif (!ctx.found_anr) {\n+\t\treturn ldb_next_request(module,\
    \ req);\n+\t}\n+\n \tldb = ldb_module_get_ctx(module);\n \n \tac = talloc(req,\
    \ struct anr_context);\n@@ -333,20 +387,23 @@ static int anr_search(struct ldb_module\
    \ *module, struct ldb_request *req)\n \n \tac->module = module;\n \tac->req =\
    \ req;\n-\tac->found_anr = false;\n \n #if 0\n \tprintf(\"oldanr : %s\\n\", ldb_filter_from_tree\
    \ (0, req->op.search.tree));\n #endif\n \n-\tret = anr_replace_subtrees(ac, req->op.search.tree,\
    \ \"anr\", &anr_tree);\n-\tif (ret != LDB_SUCCESS) {\n+\t/* First make a copy,\
    \ so we don't overwrite caller memory */\n+\n+\tanr_tree = ldb_parse_tree_copy_shallow(ac,\
    \ req->op.search.tree);\n+\n+\tif (anr_tree == NULL) {\n \t\treturn ldb_operr(ldb);\n\
    \ \t}\n \n-\tif (!ac->found_anr) {\n-\t\ttalloc_free(ac);\n-\t\treturn ldb_next_request(module,\
    \ req);\n+\t/* Now expand 'anr' out */\n+\tret = anr_replace_subtrees(ac, anr_tree,\
    \ attr, &anr_tree);\n+\tif (ret != LDB_SUCCESS) {\n+\t\treturn ldb_operr(ldb);\n\
    \ \t}\n \n \tret = ldb_build_search_req_ex(&down_req,\n"
  - "--- a/source4/ldap_server/ldap_backend.c\n+++ b/source4/ldap_server/ldap_backend.c\n\
    @@ -869,7 +869,17 @@ static NTSTATUS ldapsrv_SearchRequest(struct ldapsrv_call\
    \ *call)\n \t\t}\n \t}\n \n-\tldb_set_timeout(samdb, lreq, req->timelimit);\n\
    +\t{\n+\t\ttime_t timeout = call->conn->limits.search_timeout;\n+\n+\t\tif (timeout\
    \ == 0\n+\t\t    || (req->timelimit != 0\n+\t\t\t&& req->timelimit < timeout))\n\
    +\t\t{\n+\t\t\ttimeout = req->timelimit;\n+\t\t}\n+\t\tldb_set_timeout(samdb,\
    \ lreq, timeout);\n+\t}\n \n \tif (!call->conn->is_privileged) {\n \t\tldb_req_mark_untrusted(lreq);\n"
  - "--- a/source4/ldap_server/ldap_server.c\n+++ b/source4/ldap_server/ldap_server.c\n\
    @@ -255,7 +255,9 @@ static int ldapsrv_load_limits(struct ldapsrv_connection *conn)\n\
    \ \t\t\tcontinue;\n \t\t}\n \t\tif (strcasecmp(\"MaxQueryDuration\", policy_name)\
    \ == 0) {\n-\t\t\tconn->limits.search_timeout = policy_value;\n+\t\t\tif (policy_value\
    \ > 0) {\n+\t\t\t\tconn->limits.search_timeout = policy_value;\n+\t\t\t}\n \t\t\
    \tcontinue;\n \t\t}\n \t}\n"
  identifiers:
  - CVE-2021-3670
  - NVD-CWE-noinfo
  overview: MaxQueryDuration not honoured in Samba AD DC LDAP
  references:
  - source: secalert@redhat.com
    tags:
    - Issue Tracking
    - Patch
    - Third Party Advisory
    url: https://bugzilla.redhat.com/show_bug.cgi?id=2077533
  - source: secalert@redhat.com
    tags:
    - Issue Tracking
    - Patch
    - Vendor Advisory
    url: https://bugzilla.samba.org/show_bug.cgi?id=14694
  - source: secalert@redhat.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://gitlab.com/samba-team/samba/-/commit/1d5b155619bc532c46932965b215bd73a920e56f
  - source: secalert@redhat.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://gitlab.com/samba-team/samba/-/commit/2b3af3b560c9617a233c131376c870fce146c002
  - source: secalert@redhat.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://gitlab.com/samba-team/samba/-/commit/3507e96b3dcf0c0b8eff7b2c08ffccaf0812a393
  - source: secalert@redhat.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://gitlab.com/samba-team/samba/-/commit/5f0590362c5c0c5ee20503a67467f9be2d50e73b
  - source: secalert@redhat.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://gitlab.com/samba-team/samba/-/commit/86fe9d48883f87c928bf31ccbd275db420386803
  - source: secalert@redhat.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://gitlab.com/samba-team/samba/-/commit/dcfcafdbf756e12d9077ad7920eea25478c29f81
  - source: secalert@redhat.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://gitlab.com/samba-team/samba/-/commit/e1ab0c43629686d1d2c0b0b2bcdc90057a792049
  - source: secalert@redhat.com
    url: https://security.gentoo.org/glsa/202309-06
  title: MaxQueryDuration not honoured in Samba AD DC LDAP
- diff_content:
  - "--- a/samples/vfio-mdev/mbochs.c\n+++ b/samples/vfio-mdev/mbochs.c\n@@ -129,7\
    \ +129,7 @@ static dev_t\t\tmbochs_devt;\n static struct class\t*mbochs_class;\n\
    \ static struct cdev\tmbochs_cdev;\n static struct device\tmbochs_dev;\n-static\
    \ int\t\tmbochs_used_mbytes;\n+static atomic_t mbochs_avail_mbytes;\n static const\
    \ struct vfio_device_ops mbochs_dev_ops;\n \n struct vfio_region_info_ext {\n\
    @@ -507,18 +507,22 @@ static int mbochs_reset(struct mdev_state *mdev_state)\n\
    \ \n static int mbochs_probe(struct mdev_device *mdev)\n {\n+\tint avail_mbytes\
    \ = atomic_read(&mbochs_avail_mbytes);\n \tconst struct mbochs_type *type =\n\
    \ \t\t&mbochs_types[mdev_get_type_group_id(mdev)];\n \tstruct device *dev = mdev_dev(mdev);\n\
    \ \tstruct mdev_state *mdev_state;\n \tint ret = -ENOMEM;\n \n-\tif (type->mbytes\
    \ + mbochs_used_mbytes > max_mbytes)\n-\t\treturn -ENOMEM;\n+\tdo {\n+\t\tif (avail_mbytes\
    \ < type->mbytes)\n+\t\t\treturn -ENOSPC;\n+\t} while (!atomic_try_cmpxchg(&mbochs_avail_mbytes,\
    \ &avail_mbytes,\n+\t\t\t\t     avail_mbytes - type->mbytes));\n \n \tmdev_state\
    \ = kzalloc(sizeof(struct mdev_state), GFP_KERNEL);\n \tif (mdev_state == NULL)\n\
    -\t\treturn -ENOMEM;\n+\t\tgoto err_avail;\n \tvfio_init_group_dev(&mdev_state->vdev,\
    \ &mdev->dev, &mbochs_dev_ops);\n \n \tmdev_state->vconfig = kzalloc(MBOCHS_CONFIG_SPACE_SIZE,\
    \ GFP_KERNEL);\n@@ -549,26 +553,26 @@ static int mbochs_probe(struct mdev_device\
    \ *mdev)\n \tmbochs_create_config_space(mdev_state);\n \tmbochs_reset(mdev_state);\n\
    \ \n-\tmbochs_used_mbytes += type->mbytes;\n-\n \tret = vfio_register_group_dev(&mdev_state->vdev);\n\
    \ \tif (ret)\n \t\tgoto err_mem;\n \tdev_set_drvdata(&mdev->dev, mdev_state);\n\
    \ \treturn 0;\n-\n err_mem:\n+\tkfree(mdev_state->pages);\n \tkfree(mdev_state->vconfig);\n\
    \ \tkfree(mdev_state);\n+err_avail:\n+\tatomic_add(type->mbytes, &mbochs_avail_mbytes);\n\
    \ \treturn ret;\n }\n \n static void mbochs_remove(struct mdev_device *mdev)\n\
    \ {\n \tstruct mdev_state *mdev_state = dev_get_drvdata(&mdev->dev);\n \n-\tmbochs_used_mbytes\
    \ -= mdev_state->type->mbytes;\n \tvfio_unregister_group_dev(&mdev_state->vdev);\n\
    +\tatomic_add(mdev_state->type->mbytes, &mbochs_avail_mbytes);\n \tkfree(mdev_state->pages);\n\
    \ \tkfree(mdev_state->vconfig);\n \tkfree(mdev_state);\n@@ -1351,7 +1355,7 @@\
    \ static ssize_t available_instances_show(struct mdev_type *mtype,\n {\n \tconst\
    \ struct mbochs_type *type =\n \t\t&mbochs_types[mtype_get_type_group_id(mtype)];\n\
    -\tint count = (max_mbytes - mbochs_used_mbytes) / type->mbytes;\n+\tint count\
    \ = atomic_read(&mbochs_avail_mbytes) / type->mbytes;\n \n \treturn sprintf(buf,\
    \ \"%d\\n\", count);\n }\n@@ -1433,6 +1437,8 @@ static int __init mbochs_dev_init(void)\n\
    \ {\n \tint ret = 0;\n \n+\tatomic_set(&mbochs_avail_mbytes, max_mbytes);\n+\n\
    \ \tret = alloc_chrdev_region(&mbochs_devt, 0, MINORMASK + 1, MBOCHS_NAME);\n\
    \ \tif (ret < 0) {\n \t\tpr_err(\"Error: failed to register mbochs_dev, err: %d\\\
    n\", ret);"
  identifiers:
  - CVE-2021-3736
  - CWE-401
  overview: A flaw was found in the Linux kernel. A memory leak problem was found
    in mbochs_ioctl in samples/vfio-mdev/mbochs.c in Virtual Function I/O (VFIO) Mediated
    devices. This flaw could allow a local attacker to leak internal kernel information.
  references:
  - source: secalert@redhat.com
    tags:
    - Third Party Advisory
    url: https://access.redhat.com/security/cve/CVE-2021-3736
  - source: secalert@redhat.com
    tags:
    - Issue Tracking
    - Third Party Advisory
    url: https://bugzilla.redhat.com/show_bug.cgi?id=1995570
  - source: secalert@redhat.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/torvalds/linux/commit/de5494af4815a4c9328536c72741229b7de88e7f
  title: A flaw was found in the Linux kernel. A memory leak problem was found in
    mbochs_ioctl in samples/vfio-mdev/mbochs.c in Virtual Function I/O (VFIO) Mediated
    devices. This flaw could allow a local attacker to leak internal kernel information.
- diff_content:
  - "--- a/drivers/crypto/ccp/ccp-ops.c\n+++ b/drivers/crypto/ccp/ccp-ops.c\n@@ -778,7\
    \ +778,7 @@ ccp_run_aes_gcm_cmd(struct ccp_cmd_queue *cmd_q, struct ccp_cmd *cmd)\n\
    \ \t\t\t\t    in_place ? DMA_BIDIRECTIONAL\n \t\t\t\t\t     : DMA_TO_DEVICE);\n\
    \ \t\tif (ret)\n-\t\t\tgoto e_ctx;\n+\t\t\tgoto e_aad;\n \n \t\tif (in_place)\
    \ {\n \t\t\tdst = src;\n@@ -863,7 +863,7 @@ ccp_run_aes_gcm_cmd(struct ccp_cmd_queue\
    \ *cmd_q, struct ccp_cmd *cmd)\n \top.u.aes.size = 0;\n \tret = cmd_q->ccp->vdata->perform->aes(&op);\n\
    \ \tif (ret)\n-\t\tgoto e_dst;\n+\t\tgoto e_final_wa;\n \n \tif (aes->action ==\
    \ CCP_AES_ACTION_ENCRYPT) {\n \t\t/* Put the ciphered tag after the ciphertext.\
    \ */\n@@ -873,17 +873,19 @@ ccp_run_aes_gcm_cmd(struct ccp_cmd_queue *cmd_q, struct\
    \ ccp_cmd *cmd)\n \t\tret = ccp_init_dm_workarea(&tag, cmd_q, authsize,\n \t\t\
    \t\t\t   DMA_BIDIRECTIONAL);\n \t\tif (ret)\n-\t\t\tgoto e_tag;\n+\t\t\tgoto e_final_wa;\n\
    \ \t\tret = ccp_set_dm_area(&tag, 0, p_tag, 0, authsize);\n-\t\tif (ret)\n-\t\t\
    \tgoto e_tag;\n+\t\tif (ret) {\n+\t\t\tccp_dm_free(&tag);\n+\t\t\tgoto e_final_wa;\n\
    +\t\t}\n \n \t\tret = crypto_memneq(tag.address, final_wa.address,\n \t\t\t\t\
    \    authsize) ? -EBADMSG : 0;\n \t\tccp_dm_free(&tag);\n \t}\n \n-e_tag:\n+e_final_wa:\n\
    \ \tccp_dm_free(&final_wa);\n \n e_dst:"
  identifiers:
  - CVE-2021-3764
  - CWE-401
  overview: A memory leak flaw was found in the Linux kernel's ccp_run_aes_gcm_cmd()
    function that allows an attacker to cause a denial of service. The vulnerability
    is similar to the older CVE-2019-18808. The highest threat from this vulnerability
    is to system availability.
  references:
  - source: secalert@redhat.com
    tags:
    - Third Party Advisory
    url: https://access.redhat.com/security/cve/CVE-2021-3764
  - source: secalert@redhat.com
    tags:
    - Issue Tracking
    - Third Party Advisory
    url: https://bugzilla.redhat.com/show_bug.cgi?id=1997467
  - source: secalert@redhat.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/torvalds/linux/commit/505d9dcb0f7ddf9d075e729523a33d38642ae680
  - source: secalert@redhat.com
    tags:
    - Third Party Advisory
    url: https://security-tracker.debian.org/tracker/CVE-2021-3764
  title: A memory leak flaw was found in the Linux kernel's ccp_run_aes_gcm_cmd()
    function that allows an attacker to cause a denial of service. The vulnerability
    is similar to the older CVE-2019-18808. The highest threat from this vulnerability
    is to system availability.
- diff_content:
  - "--- a/usr/lib/soft_stdll/soft_specific.c\n+++ b/usr/lib/soft_stdll/soft_specific.c\n\
    @@ -4365,6 +4365,12 @@ static CK_RV fill_ec_key_from_pubkey(EC_KEY *ec_key, const\
    \ CK_BYTE *data,\n         goto out;\n     }\n \n+    if (!EC_KEY_check_key(ec_key))\
    \ {\n+        TRACE_ERROR(\"EC_KEY_check_key failed\\n\");\n+        rc = CKR_PUBLIC_KEY_INVALID;\n\
    +        goto out;\n+    }\n+\n out:\n     if (allocated && ecpoint != NULL)\n\
    \         free(ecpoint);\n@@ -4404,6 +4410,12 @@ static CK_RV fill_ec_key_from_privkey(EC_KEY\
    \ *ec_key, const CK_BYTE *data,\n         goto out;\n     }\n \n+    if (!EC_KEY_check_key(ec_key))\
    \ {\n+        TRACE_ERROR(\"EC_KEY_check_key failed\\n\");\n+        rc = CKR_FUNCTION_FAILED;\n\
    +        goto out;\n+    }\n+\n out:\n     if (point != NULL)\n         EC_POINT_free(point);"
  identifiers:
  - CVE-2021-3798
  - NVD-CWE-Other
  overview: A flaw was found in openCryptoki. The openCryptoki Soft token does not
    check if an EC key is valid when an EC key is created via C_CreateObject, nor
    when C_DeriveKey is used with ECDH public data. This may allow a malicious user
    to extract the private key by performing an invalid curve attack.
  references:
  - source: secalert@redhat.com
    tags:
    - Third Party Advisory
    url: https://access.redhat.com/security/cve/CVE-2021-3798
  - source: secalert@redhat.com
    tags:
    - Issue Tracking
    - Patch
    - Third Party Advisory
    url: https://bugzilla.redhat.com/show_bug.cgi?id=1990591
  - source: secalert@redhat.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/opencryptoki/opencryptoki/commit/4e3b43c3d8844402c04a66b55c6c940f965109f0
  - source: secalert@redhat.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/opencryptoki/opencryptoki/pull/402
  title: A flaw was found in openCryptoki. The openCryptoki Soft token does not check
    if an EC key is valid when an EC key is created via C_CreateObject, nor when C_DeriveKey
    is used with ECDH public data. This may allow a malicious user to extract the
    private key by performing an invalid curve attack.
- diff_content:
  - "--- a/lib/vhost/vhost_user.c\n+++ b/lib/vhost/vhost_user.c\n@@ -2883,6 +2883,9\
    \ @@ vhost_user_check_and_alloc_queue_pair(struct virtio_net *dev,\n \tcase VHOST_USER_SET_VRING_ADDR:\n\
    \ \t\tvring_idx = ctx->msg.payload.addr.index;\n \t\tbreak;\n+\tcase VHOST_USER_SET_INFLIGHT_FD:\n\
    +\t\tvring_idx = ctx->msg.payload.inflight.num_queues - 1;\n+\t\tbreak;\n \tdefault:\n\
    \ \t\treturn 0;\n \t}"
  identifiers:
  - CVE-2021-3839
  - CWE-125
  overview: A flaw was found in the vhost library in DPDK. Function vhost_user_set_inflight_fd()
    does not validate `msg->payload.inflight.num_queues`, possibly causing out-of-bounds
    memory read/write. Any software using DPDK vhost library may crash as a result
    of this vulnerability.
  references:
  - source: secalert@redhat.com
    tags:
    - Third Party Advisory
    url: https://access.redhat.com/security/cve/CVE-2021-3839
  - source: secalert@redhat.com
    tags:
    - Issue Tracking
    - Patch
    - Third Party Advisory
    url: https://bugzilla.redhat.com/show_bug.cgi?id=2025882
  - source: secalert@redhat.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/DPDK/dpdk/commit/6442c329b9d2ded0f44b27d2016aaba8ba5844c5
  title: A flaw was found in the vhost library in DPDK. Function vhost_user_set_inflight_fd()
    does not validate `msg->payload.inflight.num_queues`, possibly causing out-of-bounds
    memory read/write. Any software using DPDK vhost library may crash as a result
    of this vulnerability.
- diff_content:
  - "--- a/lib/ipf.c\n+++ b/lib/ipf.c\n@@ -943,6 +943,8 @@ ipf_extract_frags_from_batch(struct\
    \ ipf *ipf, struct dp_packet_batch *pb,\n             ovs_mutex_lock(&ipf->ipf_lock);\n\
    \             if (!ipf_handle_frag(ipf, pkt, dl_type, zone, now, hash_basis))\
    \ {\n                 dp_packet_batch_refill(pb, pkt, pb_idx);\n+            }\
    \ else {\n+                dp_packet_delete(pkt);\n             }\n          \
    \   ovs_mutex_unlock(&ipf->ipf_lock);\n         } else {"
  identifiers:
  - CVE-2021-3905
  - CWE-401
  overview: A memory leak was found in Open vSwitch (OVS) during userspace IP fragmentation
    processing. An attacker could use this flaw to potentially exhaust available memory
    by keeping sending packet fragments.
  references:
  - source: secalert@redhat.com
    tags:
    - Third Party Advisory
    url: https://access.redhat.com/security/cve/CVE-2021-3905
  - source: secalert@redhat.com
    tags:
    - Issue Tracking
    - Patch
    - Third Party Advisory
    url: https://bugzilla.redhat.com/show_bug.cgi?id=2019692
  - source: secalert@redhat.com
    tags:
    - Exploit
    - Issue Tracking
    - Patch
    - Third Party Advisory
    url: https://github.com/openvswitch/ovs-issues/issues/226
  - source: secalert@redhat.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/openvswitch/ovs/commit/803ed12e31b0377c37d7aa8c94b3b92f2081e349
  - source: secalert@redhat.com
    url: https://security.gentoo.org/glsa/202311-16
  - source: secalert@redhat.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://ubuntu.com/security/CVE-2021-3905
  title: A memory leak was found in Open vSwitch (OVS) during userspace IP fragmentation
    processing. An attacker could use this flaw to potentially exhaust available memory
    by keeping sending packet fragments.
- diff_content:
  - "--- a/src/tag.c\n+++ b/src/tag.c\n@@ -281,6 +281,7 @@ do_tag(\n     char_u\t\
    *buf_ffname = curbuf->b_ffname;\t    // name to use for\n \t\t\t\t\t\t    // priority\
    \ computation\n     int\t\tuse_tfu = 1;\n+    char_u\t*tofree = NULL;\n \n   \
    \  // remember the matches for the last used tag\n     static int\t\tnum_matches\
    \ = 0;\n@@ -630,7 +631,12 @@ do_tag(\n \t * When desired match not found yet,\
    \ try to find it (and others).\n \t */\n \tif (use_tagstack)\n-\t    name = tagstack[tagstackidx].tagname;\n\
    +\t{\n+\t    // make a copy, the tagstack may change in 'tagfunc'\n+\t    name\
    \ = vim_strsave(tagstack[tagstackidx].tagname);\n+\t    vim_free(tofree);\n+\t\
    \    tofree = name;\n+\t}\n #if defined(FEAT_QUICKFIX)\n \telse if (g_do_tagpreview\
    \ != 0)\n \t    name = ptag_entry.tagname;\n@@ -922,6 +928,7 @@ do_tag(\n    \
    \ g_do_tagpreview = 0;\t// don't do tag preview next time\n # endif\n \n+    vim_free(tofree);\n\
    \ #ifdef FEAT_CSCOPE\n     return jumped_to_tag;\n #else"
  - "--- a/src/version.c\n+++ b/src/version.c\n@@ -731,6 +731,8 @@ static char *(features[])\
    \ =\n \n static int included_patches[] =\n {   /* Add new patch number below this\
    \ line */\n+/**/\n+    246,\n /**/\n     245,\n /**/"
  identifiers:
  - CVE-2022-2946
  - CWE-416
  overview: Use After Free in GitHub repository vim/vim prior to 9.0.0246.
  references:
  - source: security@huntr.dev
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/vim/vim/commit/adce965162dd89bf29ee0e5baf53652e7515762c
  - source: security@huntr.dev
    tags:
    - Exploit
    - Patch
    - Third Party Advisory
    url: https://huntr.dev/bounties/5d389a18-5026-47df-a5d0-1548a9b555d5
  - source: security@huntr.dev
    tags:
    - Mailing List
    - Third Party Advisory
    url: https://lists.debian.org/debian-lts-announce/2022/11/msg00009.html
  - source: security@huntr.dev
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/C72HDIMR3KTTAO7QGTXWUMPBNFUFIBRD/
  - source: security@huntr.dev
    url: https://security.gentoo.org/glsa/202305-16
  title: Use After Free in GitHub repository vim/vim prior to 9.0.0246.
- diff_content:
  - "--- a/src/qemu/qemu_process.c\n+++ b/src/qemu/qemu_process.c\n@@ -318,7 +318,9\
    \ @@ qemuProcessHandleMonitorEOF(qemuMonitorPtr mon,\n     /* We don't want this\
    \ EOF handler to be called over and over while the\n      * thread is waiting\
    \ for a job.\n      */\n+    virObjectLock(mon);\n     qemuMonitorUnregister(mon);\n\
    +    virObjectUnlock(mon);\n \n     /* We don't want any cleanup from EOF handler\
    \ (or any other\n      * thread) to enter qemu namespace. */"
  identifiers:
  - CVE-2021-3975
  - CWE-416
  overview: A use-after-free flaw was found in libvirt. The qemuMonitorUnregister()
    function in qemuProcessHandleMonitorEOF is called using multiple threads without
    being adequately protected by a monitor lock. This flaw could be triggered by
    the virConnectGetAllDomainStats API when the guest is shutting down. An unprivileged
    client with a read-only connection could use this flaw to perform a denial of
    service attack by causing the libvirt daemon to crash.
  references:
  - source: secalert@redhat.com
    tags:
    - Issue Tracking
    - Third Party Advisory
    url: https://access.redhat.com/security/cve/CVE-2021-3975
  - source: secalert@redhat.com
    tags:
    - Issue Tracking
    - Patch
    - Third Party Advisory
    url: https://bugzilla.redhat.com/show_bug.cgi?id=2024326
  - source: secalert@redhat.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/libvirt/libvirt/commit/1ac703a7d0789e46833f4013a3876c2e3af18ec7
  - source: secalert@redhat.com
    url: https://lists.debian.org/debian-lts-announce/2024/04/msg00000.html
  - source: secalert@redhat.com
    tags:
    - Third Party Advisory
    url: https://security.netapp.com/advisory/ntap-20221201-0002/
  - source: secalert@redhat.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://ubuntu.com/security/CVE-2021-3975
  title: A use-after-free flaw was found in libvirt. The qemuMonitorUnregister() function
    in qemuProcessHandleMonitorEOF is called using multiple threads without being
    adequately protected by a monitor lock. This flaw could be triggered by the virConnectGetAllDomainStats
    API when the guest is shutting down. An unprivileged client with a read-only connection
    could use this flaw to perform a denial of service attack by causing the libvirt
    daemon to crash.
- diff_content:
  - "--- a/libmount/src/context_umount.c\n+++ b/libmount/src/context_umount.c\n@@\
    \ -452,10 +452,7 @@ static int is_fuse_usermount(struct libmnt_context *cxt, int\
    \ *errsv)\n \tstruct libmnt_ns *ns_old;\n \tconst char *type = mnt_fs_get_fstype(cxt->fs);\n\
    \ \tconst char *optstr;\n-\tchar *user_id = NULL;\n-\tsize_t sz;\n-\tuid_t uid;\n\
    -\tchar uidstr[sizeof(stringify_value(ULONG_MAX))];\n+\tuid_t uid, entry_uid;\n\
    \ \n \t*errsv = 0;\n \n@@ -472,11 +469,7 @@ static int is_fuse_usermount(struct\
    \ libmnt_context *cxt, int *errsv)\n \toptstr = mnt_fs_get_fs_options(cxt->fs);\n\
    \ \tif (!optstr)\n \t\treturn 0;\n-\n-\tif (mnt_optstr_get_option(optstr, \"user_id\"\
    , &user_id, &sz) != 0)\n-\t\treturn 0;\n-\n-\tif (sz == 0 || user_id == NULL)\n\
    +\tif (mnt_optstr_get_uid(optstr, \"user_id\", &entry_uid) != 0)\n \t\treturn\
    \ 0;\n \n \t/* get current user */\n@@ -493,8 +486,7 @@ static int is_fuse_usermount(struct\
    \ libmnt_context *cxt, int *errsv)\n \t\treturn 0;\n \t}\n \n-\tsnprintf(uidstr,\
    \ sizeof(uidstr), \"%lu\", (unsigned long) uid);\n-\treturn strncmp(user_id, uidstr,\
    \ sz) == 0;\n+\treturn uid == entry_uid;\n }\n \n /*"
  - "--- a/libmount/src/optstr.c\n+++ b/libmount/src/optstr.c\n@@ -1083,6 +1083,48\
    \ @@ int mnt_optstr_fix_user(char **optstr)\n \treturn rc;\n }\n \n+/*\n+ * Converts\
    \ value from @optstr addressed by @name to uid.\n+ *\n+ * Returns: 0 on success,\
    \ 1 if not found, <0 on error\n+ */\n+int mnt_optstr_get_uid(const char *optstr,\
    \ const char *name, uid_t *uid)\n+{\n+\tchar *value = NULL;\n+\tsize_t valsz =\
    \ 0;\n+\tchar buf[sizeof(stringify_value(UINT64_MAX))];\n+\tint rc;\n+\tuint64_t\
    \ num;\n+\n+\tassert(optstr);\n+\tassert(name);\n+\tassert(uid);\n+\n+\trc = mnt_optstr_get_option(optstr,\
    \ name, &value, &valsz);\n+\tif (rc != 0)\n+\t\tgoto fail;\n+\n+\tif (valsz >\
    \ sizeof(buf) - 1) {\n+\t\trc = -ERANGE;\n+\t\tgoto fail;\n+\t}\n+\tmem2strcpy(buf,\
    \ value, valsz, sizeof(buf));\n+\n+\trc = ul_strtou64(buf, &num, 10);\n+\tif (rc\
    \ != 0)\n+\t\tgoto fail;\n+\tif (num > ULONG_MAX || (uid_t) num != num) {\n+\t\
    \trc = -ERANGE;\n+\t\tgoto fail;\n+\t}\n+\t*uid = (uid_t) num;\n+\n+\treturn 0;\n\
    +fail:\n+\tDBG(UTILS, ul_debug(\"failed to convert '%s'= to number [rc=%d]\",\
    \ name, rc));\n+\treturn rc;\n+}\n+\n /**\n  * mnt_match_options:\n  * @optstr:\
    \ options string"
  identifiers:
  - CVE-2021-3995
  - CWE-552
  overview: A logic error was found in the libmount library of util-linux in the function
    that allows an unprivileged user to unmount a FUSE filesystem. This flaw allows
    an unprivileged local attacker to unmount FUSE filesystems that belong to certain
    other users who have a UID that is a prefix of the UID of the attacker in its
    string form. An attacker may use this flaw to cause a denial of service to applications
    that use the affected filesystems.
  references:
  - source: secalert@redhat.com
    tags:
    - Third Party Advisory
    - VDB Entry
    url: http://packetstormsecurity.com/files/170176/snap-confine-must_mkdir_and_open_with_perms-Race-Condition.html
  - source: secalert@redhat.com
    tags:
    - Mailing List
    - Third Party Advisory
    url: http://seclists.org/fulldisclosure/2022/Dec/4
  - source: secalert@redhat.com
    tags:
    - Mailing List
    - Third Party Advisory
    url: http://www.openwall.com/lists/oss-security/2022/11/30/2
  - source: secalert@redhat.com
    tags:
    - Broken Link
    - Issue Tracking
    url: https://bugzilla.redhat.com/show_bug.cgi?id=2024631https://access.redhat.com/security/cve/CVE-2021-3995
  - source: secalert@redhat.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/util-linux/util-linux/commit/57202f5713afa2af20ffbb6ab5331481d0396f8d
  - source: secalert@redhat.com
    tags:
    - Release Notes
    - Vendor Advisory
    url: https://mirrors.edge.kernel.org/pub/linux/utils/util-linux/v2.37/v2.37.3-ReleaseNotes
  - source: secalert@redhat.com
    url: https://security.gentoo.org/glsa/202401-08
  - source: secalert@redhat.com
    tags:
    - Third Party Advisory
    url: https://security.netapp.com/advisory/ntap-20221209-0002/
  - source: secalert@redhat.com
    tags:
    - Exploit
    - Mailing List
    - Patch
    - Third Party Advisory
    url: https://www.openwall.com/lists/oss-security/2022/01/24/2
  title: A logic error was found in the libmount library of util-linux in the function
    that allows an unprivileged user to unmount a FUSE filesystem. This flaw allows
    an unprivileged local attacker to unmount FUSE filesystems that belong to certain
    other users who have a UID that is a prefix of the UID of the attacker in its
    string form. An attacker may use this flaw to cause a denial of service to applications
    that use the affected filesystems.
- diff_content:
  - "--- a/libmount/src/fs.c\n+++ b/libmount/src/fs.c\n@@ -651,17 +651,6 @@ int mnt_fs_is_regularfs(struct\
    \ libmnt_fs *fs)\n \t\t || mnt_fs_is_swaparea(fs));\n }\n \n-/**\n- * mnt_fs_is_deleted:\n\
    - * @fs: filesystem\n- *\n- * Returns: 1 if the filesystem target is a marked\
    \ as deleted by kernel\n- */\n-int mnt_fs_is_deleted(struct libmnt_fs *fs)\n-{\n\
    -\treturn mnt_fs_get_flags(fs) & MNT_FS_DELETED;\n-}\n-\n /**\n  * mnt_fs_get_fstype:\n\
    \  * @fs: fstab/mtab/mountinfo entry pointer"
  - "--- a/libmount/src/tab_parse.c\n+++ b/libmount/src/tab_parse.c\n@@ -227,13 +227,6\
    \ @@ static int mnt_parse_mountinfo_line(struct libmnt_fs *fs, const char *s)\n\
    \ \t\tgoto fail;\n \t}\n \n-\t/* remove \"\\040(deleted)\" suffix */\n-\tp = (char\
    \ *) endswith(fs->target, PATH_DELETED_SUFFIX);\n-\tif (p && *p) {\n-\t\t*p =\
    \ '\\0';\n-\t\tfs->flags |= MNT_FS_DELETED;\n-\t}\n-\n \ts = skip_separator(s);\n\
    \ \n \t/* (6) vfs options (fs-independent) */"
  - "--- a/misc-utils/findmnt.c\n+++ b/misc-utils/findmnt.c\n@@ -55,7 +55,6 @@\n enum\
    \ {\n \tCOL_ACTION,\n \tCOL_AVAIL,\n-\tCOL_DELETED,\n \tCOL_FREQ,\n \tCOL_FSROOT,\n\
    \ \tCOL_FSTYPE,\n@@ -103,7 +102,6 @@ struct colinfo {\n static struct colinfo\
    \ infos[] = {\n \t[COL_ACTION]       = { \"ACTION\",         10, SCOLS_FL_STRICTWIDTH,\
    \ N_(\"action detected by --poll\") },\n \t[COL_AVAIL]        = { \"AVAIL\", \
    \          5, SCOLS_FL_RIGHT, N_(\"filesystem size available\") },\n-\t[COL_DELETED]\
    \      = { \"DELETED\",         1, SCOLS_FL_RIGHT, N_(\"filesystem target marked\
    \ as deleted\") },\n \t[COL_FREQ]         = { \"FREQ\",            1, SCOLS_FL_RIGHT,\
    \ N_(\"dump(8) period in days [fstab only]\") },\n \t[COL_FSROOT]       = { \"\
    FSROOT\",       0.25, SCOLS_FL_NOEXTREMES, N_(\"filesystem root\") },\n \t[COL_FSTYPE]\
    \       = { \"FSTYPE\",       0.10, SCOLS_FL_TRUNC, N_(\"filesystem type\") },\n\
    @@ -677,9 +675,6 @@ static char *get_data(struct libmnt_fs *fs, int num)\n \t\t\
    if (!mnt_fs_is_kernel(fs))\n \t\t\txasprintf(&str, \"%d\", mnt_fs_get_passno(fs));\n\
    \ \t\tbreak;\n-\tcase COL_DELETED:\n-\t\tstr = xstrdup(mnt_fs_is_deleted(fs) ?\
    \ \"1\" : \"0\");\n-\t\tbreak;\n \tdefault:\n \t\tbreak;\n \t}\n@@ -1033,9 +1028,6\
    \ @@ static int match_func(struct libmnt_fs *fs,\n \t\t\treturn rc;\n \t}\n \n\
    -\tif ((flags & FL_DELETED) && !mnt_fs_is_deleted(fs))\n-\t\treturn rc;\n-\n \t\
    return !rc;\n }\n \n@@ -1304,7 +1296,6 @@ static void __attribute__((__noreturn__))\
    \ usage(void)\n \tfputs(_(\" -b, --bytes            print sizes in bytes rather\
    \ than in human readable format\\n\"), out);\n \tfputs(_(\" -C, --nocanonicalize\
    \   don't canonicalize when comparing paths\\n\"), out);\n \tfputs(_(\" -c, --canonicalize\
    \     canonicalize printed paths\\n\"), out);\n-\tfputs(_(\"     --deleted   \
    \       print filesystems with mountpoint marked as deleted\\n\"), out);\n \t\
    fputs(_(\" -D, --df               imitate the output of df(1)\\n\"), out);\n \t\
    fputs(_(\" -d, --direction <word> direction of search, 'forward' or 'backward'\\\
    n\"), out);\n \tfputs(_(\" -e, --evaluate         convert tags (LABEL,UUID,PARTUUID,PARTLABEL)\
    \ \\n\"\n@@ -1373,16 +1364,14 @@ int main(int argc, char *argv[])\n \t\tFINDMNT_OPT_PSEUDO,\n\
    \ \t\tFINDMNT_OPT_REAL,\n \t\tFINDMNT_OPT_VFS_ALL,\n-\t\tFINDMNT_OPT_SHADOWED,\n\
    -\t\tFINDMNT_OPT_DELETED,\n+\t\tFINDMNT_OPT_SHADOWED\n \t};\n \n \tstatic const\
    \ struct option longopts[] = {\n \t\t{ \"all\",\t    no_argument,       NULL,\
    \ 'A'\t\t },\n \t\t{ \"ascii\",\t    no_argument,       NULL, 'a'\t\t },\n \t\t\
    { \"bytes\",\t    no_argument,       NULL, 'b'\t\t },\n \t\t{ \"canonicalize\"\
    ,   no_argument,       NULL, 'c'\t\t },\n-\t\t{ \"deleted\",        no_argument,\
    \       NULL, FINDMNT_OPT_DELETED },\n \t\t{ \"direction\",\t    required_argument,\
    \ NULL, 'd'\t\t },\n \t\t{ \"df\",\t\t    no_argument,       NULL, 'D'\t\t },\n\
    \ \t\t{ \"evaluate\",\t    no_argument,       NULL, 'e'\t\t },\n@@ -1601,9 +1590,6\
    \ @@ int main(int argc, char *argv[])\n \t\tcase FINDMNT_OPT_SHADOWED:\n \t\t\t\
    flags |= FL_SHADOWED;\n \t\t\tbreak;\n-\t\tcase FINDMNT_OPT_DELETED:\n-\t\t\t\
    flags |= FL_DELETED;\n-\t\t\tbreak;\n \t\tcase 'h':\n \t\t\tusage();\n \t\tcase\
    \ 'V':\n@@ -1776,9 +1762,6 @@ int main(int argc, char *argv[])\n \t\t\tcase COL_TID:\n\
    \ \t\t\t\tscols_column_set_json_type(cl, SCOLS_JSON_NUMBER);\n \t\t\t\tbreak;\n\
    -\t\t\tcase COL_DELETED:\n-\t\t\t\tscols_column_set_json_type(cl, SCOLS_JSON_BOOLEAN);\n\
    -\t\t\t\tbreak;\n \t\t\tdefault:\n \t\t\t\tif (fl & SCOLS_FL_WRAP)\n \t\t\t\t\t\
    scols_column_set_json_type(cl, SCOLS_JSON_ARRAY_STRING);"
  identifiers:
  - CVE-2021-3996
  - CWE-552
  overview: A logic error was found in the libmount library of util-linux in the function
    that allows an unprivileged user to unmount a FUSE filesystem. This flaw allows
    a local user on a vulnerable system to unmount other users' filesystems that are
    either world-writable themselves (like /tmp) or mounted in a world-writable directory.
    An attacker may use this flaw to cause a denial of service to applications that
    use the affected filesystems.
  references:
  - source: secalert@redhat.com
    tags:
    - Third Party Advisory
    url: http://packetstormsecurity.com/files/170176/snap-confine-must_mkdir_and_open_with_perms-Race-Condition.html
  - source: secalert@redhat.com
    tags:
    - Mailing List
    - Third Party Advisory
    url: http://seclists.org/fulldisclosure/2022/Dec/4
  - source: secalert@redhat.com
    tags:
    - Mailing List
    - Third Party Advisory
    url: http://www.openwall.com/lists/oss-security/2022/11/30/2
  - source: secalert@redhat.com
    tags:
    - Issue Tracking
    - Third Party Advisory
    url: https://access.redhat.com/security/cve/CVE-2021-3996
  - source: secalert@redhat.com
    tags:
    - Issue Tracking
    - Patch
    - Third Party Advisory
    url: https://bugzilla.redhat.com/show_bug.cgi?id=2024628
  - source: secalert@redhat.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/util-linux/util-linux/commit/166e87368ae88bf31112a30e078cceae637f4cdb
  - source: secalert@redhat.com
    tags:
    - Release Notes
    - Vendor Advisory
    url: https://mirrors.edge.kernel.org/pub/linux/utils/util-linux/v2.37/v2.37.3-ReleaseNotes
  - source: secalert@redhat.com
    url: https://security.gentoo.org/glsa/202401-08
  - source: secalert@redhat.com
    tags:
    - Broken Link
    - Third Party Advisory
    url: https://security.netapp.com/advisory/ntap-20221209-0002/
  - source: secalert@redhat.com
    tags:
    - Exploit
    - Mailing List
    - Patch
    - Third Party Advisory
    url: https://www.openwall.com/lists/oss-security/2022/01/24/2
  title: A logic error was found in the libmount library of util-linux in the function
    that allows an unprivileged user to unmount a FUSE filesystem. This flaw allows
    a local user on a vulnerable system to unmount other users' filesystems that are
    either world-writable themselves (like /tmp) or mounted in a world-writable directory.
    An attacker may use this flaw to cause a denial of service to applications that
    use the affected filesystems.
- diff_content:
  - "--- a/src/shared/rm-rf.c\n+++ b/src/shared/rm-rf.c\n@@ -116,12 +115,13 @@ int\
    \ fstatat_harder(int dfd,\n         return 0;\n }\n \n-static int rm_rf_children_inner(\n\
    +static int rm_rf_inner_child(\n                 int fd,\n                 const\
    \ char *fname,\n                 int is_dir,\n                 RemoveFlags flags,\n\
    -                const struct stat *root_dev) {\n+                const struct\
    \ stat *root_dev,\n+                bool allow_recursion) {\n \n         struct\
    \ stat st;\n         int r, q = 0;\n@@ -141,9 +141,7 @@ static int rm_rf_children_inner(\n\
    \         }\n \n         if (is_dir) {\n-                _cleanup_close_ int subdir_fd\
    \ = -1;\n-\n-                /* if root_dev is set, remove subdirectories only\
    \ if device is same */\n+                /* If root_dev is set, remove subdirectories\
    \ only if device is same */\n                 if (root_dev && st.st_dev != root_dev->st_dev)\n\
    \                         return 0;\n \n@@ -169,13 +166,16 @@ static int rm_rf_children_inner(\n\
    \                                 return 1;\n                 }\n \n-        \
    \        subdir_fd = openat(fd, fname, O_RDONLY|O_NONBLOCK|O_DIRECTORY|O_CLOEXEC|O_NOFOLLOW|O_NOATIME);\n\
    +                if (!allow_recursion)\n+                        return -EISDIR;\n\
    +\n+                int subdir_fd = openat(fd, fname, O_RDONLY|O_NONBLOCK|O_DIRECTORY|O_CLOEXEC|O_NOFOLLOW|O_NOATIME);\n\
    \                 if (subdir_fd < 0)\n                         return -errno;\n\
    \ \n                 /* We pass REMOVE_PHYSICAL here, to avoid doing the fstatfs()\
    \ to check the file system type\n                  * again for each directory\
    \ */\n-                q = rm_rf_children(TAKE_FD(subdir_fd), flags | REMOVE_PHYSICAL,\
    \ root_dev);\n+                q = rm_rf_children(subdir_fd, flags | REMOVE_PHYSICAL,\
    \ root_dev);\n \n         } else if (flags & REMOVE_ONLY_DIRECTORIES)\n      \
    \           return 0;\n@@ -188,62 +188,127 @@ static int rm_rf_children_inner(\n\
    \         return 1;\n }\n \n+typedef struct TodoEntry {\n+        DIR *dir;  \
    \       /* A directory that we were operating on. */\n+        char *dirname;\
    \    /* The filename of that directory itself. */\n+} TodoEntry;\n+\n+static void\
    \ free_todo_entries(TodoEntry **todos) {\n+        for (TodoEntry *x = *todos;\
    \ x && x->dir; x++) {\n+                closedir(x->dir);\n+                free(x->dirname);\n\
    +        }\n+\n+        freep(todos);\n+}\n+\n int rm_rf_children(\n         \
    \        int fd,\n                 RemoveFlags flags,\n                 const\
    \ struct stat *root_dev) {\n \n-        _cleanup_closedir_ DIR *d = NULL;\n+ \
    \       _cleanup_(free_todo_entries) TodoEntry *todos = NULL;\n+        size_t\
    \ n_todo = 0;\n+        _cleanup_free_ char *dirname = NULL; /* Set when we are\
    \ recursing and want to delete ourselves */\n         int ret = 0, r;\n \n-  \
    \      assert(fd >= 0);\n+        /* Return the first error we run into, but nevertheless\
    \ try to go on.\n+         * The passed fd is closed in all cases, including on\
    \ failure. */\n+\n+        for (;;) {  /* This loop corresponds to the directory\
    \ nesting level. */\n+                _cleanup_closedir_ DIR *d = NULL;\n+\n+\
    \                if (n_todo > 0) {\n+                        /* We know that we\
    \ are in recursion here, because n_todo is set.\n+                         * We\
    \ need to remove the inner directory we were operating on. */\n+             \
    \           assert(dirname);\n+                        r = unlinkat_harder(dirfd(todos[n_todo-1].dir),\
    \ dirname, AT_REMOVEDIR, flags);\n+                        if (r < 0 && r != -ENOENT\
    \ && ret == 0)\n+                                ret = r;\n+                 \
    \       dirname = mfree(dirname);\n+\n+                        /* And now let's\
    \ back out one level up */\n+                        n_todo --;\n+           \
    \             d = TAKE_PTR(todos[n_todo].dir);\n+                        dirname\
    \ = TAKE_PTR(todos[n_todo].dirname);\n+\n+                        assert(d);\n\
    +                        fd = dirfd(d); /* Retrieve the file descriptor from the\
    \ DIR object */\n+                        assert(fd >= 0);\n+                }\
    \ else {\n+        next_fd:\n+                        assert(fd >= 0);\n+    \
    \                    d = fdopendir(fd);\n+                        if (!d) {\n\
    +                                safe_close(fd);\n+                          \
    \      return -errno;\n+                        }\n+                        fd\
    \ = dirfd(d); /* We donated the fd to fdopendir(). Let's make sure we sure we\
    \ have\n+                                        * the right descriptor even if\
    \ it were to internally invalidate the\n+                                    \
    \    * one we passed. */\n+\n+                        if (!(flags & REMOVE_PHYSICAL))\
    \ {\n+                                struct statfs sfs;\n+\n+               \
    \                 if (fstatfs(fd, &sfs) < 0)\n+                              \
    \          return -errno;\n+\n+                                if (is_physical_fs(&sfs))\
    \ {\n+                                        /* We refuse to clean physical file\
    \ systems with this call, unless\n+                                         *\
    \ explicitly requested. This is extra paranoia just to be sure we\n+         \
    \                                * never ever remove non-state data. */\n+\n+\
    \                                        _cleanup_free_ char *path = NULL;\n+\n\
    +                                        (void) fd_get_path(fd, &path);\n+   \
    \                                     return log_error_errno(SYNTHETIC_ERRNO(EPERM),\n\
    +                                                               \"Attempted to\
    \ remove disk file system under \\\"%s\\\", and we can't allow that.\",\n+   \
    \                                                            strna(path));\n+\
    \                                }\n+                        }\n+            \
    \    }\n \n-        /* This returns the first error we run into, but nevertheless\
    \ tries to go on. This closes the passed\n-         * fd, in all cases, including\
    \ on failure. */\n+                FOREACH_DIRENT_ALL(de, d, return -errno) {\n\
    +                        int is_dir;\n \n-        d = fdopendir(fd);\n-      \
    \  if (!d) {\n-                safe_close(fd);\n-                return -errno;\n\
    -        }\n+                        if (dot_or_dot_dot(de->d_name))\n+      \
    \                          continue;\n \n-        if (!(flags & REMOVE_PHYSICAL))\
    \ {\n-                struct statfs sfs;\n+                        is_dir = de->d_type\
    \ == DT_UNKNOWN ? -1 : de->d_type == DT_DIR;\n \n-                if (fstatfs(dirfd(d),\
    \ &sfs) < 0)\n-                        return -errno;\n+                     \
    \   r = rm_rf_inner_child(fd, de->d_name, is_dir, flags, root_dev, false);\n+\
    \                        if (r == -EISDIR) {\n+                              \
    \  /* Push the current working state onto the todo list */\n \n-             \
    \   if (is_physical_fs(&sfs)) {\n-                        /* We refuse to clean\
    \ physical file systems with this call, unless explicitly\n-                 \
    \        * requested. This is extra paranoia just to be sure we never ever remove\
    \ non-state\n-                         * data. */\n+                         \
    \        if (!GREEDY_REALLOC0(todos, n_todo + 2))\n+                         \
    \                return log_oom();\n \n-                        _cleanup_free_\
    \ char *path = NULL;\n+                                 _cleanup_free_ char *newdirname\
    \ = strdup(de->d_name);\n+                                 if (!newdirname)\n\
    +                                         return log_oom();\n \n-            \
    \            (void) fd_get_path(fd, &path);\n-                        return log_error_errno(SYNTHETIC_ERRNO(EPERM),\n\
    -                                               \"Attempted to remove disk file\
    \ system under \\\"%s\\\", and we can't allow that.\",\n-                    \
    \                           strna(path));\n-                }\n-        }\n+ \
    \                                int newfd = openat(fd, de->d_name,\n+       \
    \                                             O_RDONLY|O_NONBLOCK|O_DIRECTORY|O_CLOEXEC|O_NOFOLLOW|O_NOATIME);\n\
    +                                 if (newfd >= 0) {\n+                       \
    \                  todos[n_todo++] = (TodoEntry) { TAKE_PTR(d), TAKE_PTR(dirname)\
    \ };\n+                                         fd = newfd;\n+               \
    \                          dirname = TAKE_PTR(newdirname);\n \n-        FOREACH_DIRENT_ALL(de,\
    \ d, return -errno) {\n-                int is_dir;\n+                       \
    \                  goto next_fd;\n \n-                if (dot_or_dot_dot(de->d_name))\n\
    -                        continue;\n+                                 } else if\
    \ (errno != -ENOENT && ret == 0)\n+                                         ret\
    \ = -errno;\n \n-                is_dir =\n-                        de->d_type\
    \ == DT_UNKNOWN ? -1 :\n-                        de->d_type == DT_DIR;\n+    \
    \                    } else if (r < 0 && r != -ENOENT && ret == 0)\n+        \
    \                        ret = r;\n+                }\n \n-                r =\
    \ rm_rf_children_inner(dirfd(d), de->d_name, is_dir, flags, root_dev);\n-    \
    \            if (r < 0 && r != -ENOENT && ret == 0)\n-                       \
    \ ret = r;\n-        }\n+                if (FLAGS_SET(flags, REMOVE_SYNCFS) &&\
    \ syncfs(fd) < 0 && ret >= 0)\n+                        ret = -errno;\n \n-  \
    \      if (FLAGS_SET(flags, REMOVE_SYNCFS) && syncfs(dirfd(d)) < 0 && ret >= 0)\n\
    -                ret = -errno;\n+                if (n_todo == 0)\n+         \
    \               break;\n+        }\n \n         return ret;\n }\n@@ -335,5 +400,5\
    \ @@ int rm_rf_child(int fd, const char *name, RemoveFlags flags) {\n        \
    \ if (FLAGS_SET(flags, REMOVE_ONLY_DIRECTORIES|REMOVE_SUBVOLUME))\n          \
    \       return -EINVAL;\n \n-        return rm_rf_children_inner(fd, name, -1,\
    \ flags, NULL);\n+        return rm_rf_inner_child(fd, name, -1, flags, NULL,\
    \ true);\n }"
  identifiers:
  - CVE-2021-3997
  - CWE-674
  overview: A flaw was found in systemd. An uncontrolled recursion in systemd-tmpfiles
    may lead to a denial of service at boot time when too many nested directories
    are created in /tmp.
  references:
  - source: secalert@redhat.com
    tags:
    - Issue Tracking
    - Third Party Advisory
    url: https://access.redhat.com/security/cve/CVE-2021-3997
  - source: secalert@redhat.com
    tags:
    - Issue Tracking
    - Patch
    - Third Party Advisory
    url: https://bugzilla.redhat.com/show_bug.cgi?id=2024639
  - source: secalert@redhat.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/systemd/systemd/commit/5b1cf7a9be37e20133c0208005274ce4a5b5c6a1
  - source: secalert@redhat.com
    url: https://security.gentoo.org/glsa/202305-15
  - source: secalert@redhat.com
    tags:
    - Exploit
    - Mailing List
    - Third Party Advisory
    url: https://www.openwall.com/lists/oss-security/2022/01/10/2
  title: A flaw was found in systemd. An uncontrolled recursion in systemd-tmpfiles
    may lead to a denial of service at boot time when too many nested directories
    are created in /tmp.
- diff_content:
  - "--- a/lib/luks2/luks2_json_metadata.c\n+++ b/lib/luks2/luks2_json_metadata.c\n\
    @@ -1389,24 +1389,63 @@ int LUKS2_config_set_flags(struct crypt_device *cd, struct\
    \ luks2_hdr *hdr, uint3\n  */\n \n /* LUKS2 library requirements */\n-static const\
    \ struct  {\n+struct requirement_flag {\n \tuint32_t flag;\n+\tuint32_t version;\n\
    \ \tconst char *description;\n-} requirements_flags[] = {\n-\t{ CRYPT_REQUIREMENT_OFFLINE_REENCRYPT,\
    \ \"offline-reencrypt\" },\n-\t{ CRYPT_REQUIREMENT_ONLINE_REENCRYPT, \"online-reencrypt\"\
    \ },\n-\t{ 0, NULL }\n };\n \n-static uint32_t get_requirement_by_name(const char\
    \ *requirement)\n+static const struct requirement_flag unknown_requirement_flag\
    \ = { CRYPT_REQUIREMENT_UNKNOWN, 0, NULL };\n+\n+static const struct requirement_flag\
    \ requirements_flags[] = {\n+\t{ CRYPT_REQUIREMENT_OFFLINE_REENCRYPT,1, \"offline-reencrypt\"\
    \ },\n+\t{ CRYPT_REQUIREMENT_ONLINE_REENCRYPT, 2, \"online-reencrypt-v2\" },\n\
    +\t{ CRYPT_REQUIREMENT_ONLINE_REENCRYPT, 1, \"online-reencrypt\" },\n+\t{ 0, 0,\
    \ NULL }\n+};\n+\n+static const struct requirement_flag *get_requirement_by_name(const\
    \ char *requirement)\n {\n \tint i;\n \n \tfor (i = 0; requirements_flags[i].description;\
    \ i++)\n \t\tif (!strcmp(requirement, requirements_flags[i].description))\n-\t\
    \t\treturn requirements_flags[i].flag;\n+\t\t\treturn requirements_flags + i;\n\
    \ \n-\treturn CRYPT_REQUIREMENT_UNKNOWN;\n+\treturn &unknown_requirement_flag;\n\
    +}\n+\n+static const struct requirement_flag *stored_requirement_name_by_id(struct\
    \ crypt_device *cd, struct luks2_hdr *hdr, uint32_t req_id)\n+{\n+\tjson_object\
    \ *jobj_config, *jobj_requirements, *jobj_mandatory, *jobj;\n+\tint i, len;\n\
    +\tconst struct requirement_flag *req;\n+\n+\tassert(hdr);\n+\tif (!hdr)\n+\t\t\
    return NULL;\n+\n+\tif (!json_object_object_get_ex(hdr->jobj, \"config\", &jobj_config))\n\
    +\t\treturn NULL;\n+\n+\tif (!json_object_object_get_ex(jobj_config, \"requirements\"\
    , &jobj_requirements))\n+\t\treturn NULL;\n+\n+\tif (!json_object_object_get_ex(jobj_requirements,\
    \ \"mandatory\", &jobj_mandatory))\n+\t\treturn NULL;\n+\n+\tlen = (int) json_object_array_length(jobj_mandatory);\n\
    +\tif (len <= 0)\n+\t\treturn 0;\n+\n+\tfor (i = 0; i < len; i++) {\n+\t\tjobj\
    \ = json_object_array_get_idx(jobj_mandatory, i);\n+\t\treq = get_requirement_by_name(json_object_get_string(jobj));\n\
    +\t\tif (req->flag == req_id)\n+\t\t\treturn req;\n+\t}\n+\n+\treturn NULL;\n\
    \ }\n \n /*\n@@ -1416,7 +1455,7 @@ int LUKS2_config_get_requirements(struct crypt_device\
    \ *cd, struct luks2_hdr *hdr\n {\n \tjson_object *jobj_config, *jobj_requirements,\
    \ *jobj_mandatory, *jobj;\n \tint i, len;\n-\tuint32_t req;\n+\tconst struct requirement_flag\
    \ *req;\n \n \tassert(hdr);\n \tif (!hdr || !reqs)\n@@ -1443,8 +1482,8 @@ int\
    \ LUKS2_config_get_requirements(struct crypt_device *cd, struct luks2_hdr *hdr\n\
    \ \t\tjobj = json_object_array_get_idx(jobj_mandatory, i);\n \t\treq = get_requirement_by_name(json_object_get_string(jobj));\n\
    \ \t\tlog_dbg(cd, \"%s - %sknown\", json_object_get_string(jobj),\n-\t\t\t\t \
    \       reqs_unknown(req) ? \"un\" : \"\");\n-\t\t*reqs |= req;\n+\t\t\t\t   \
    \     reqs_unknown(req->flag) ? \"un\" : \"\");\n+\t\t*reqs |= req->flag;\n \t\
    }\n \n \treturn 0;\n@@ -1454,6 +1493,8 @@ int LUKS2_config_set_requirements(struct\
    \ crypt_device *cd, struct luks2_hdr *hdr\n {\n \tjson_object *jobj_config, *jobj_requirements,\
    \ *jobj_mandatory, *jobj;\n \tint i, r = -EINVAL;\n+\tconst struct requirement_flag\
    \ *req;\n+\tuint32_t req_id;\n \n \tif (!hdr)\n \t\treturn -EINVAL;\n@@ -1463,8\
    \ +1504,14 @@ int LUKS2_config_set_requirements(struct crypt_device *cd, struct\
    \ luks2_hdr *hdr\n \t\treturn -ENOMEM;\n \n \tfor (i = 0; requirements_flags[i].description;\
    \ i++) {\n-\t\tif (reqs & requirements_flags[i].flag) {\n-\t\t\tjobj = json_object_new_string(requirements_flags[i].description);\n\
    +\t\treq_id = reqs & requirements_flags[i].flag;\n+\t\tif (req_id) {\n+\t\t\t\
    /* retain already stored version of requirement flag */\n+\t\t\treq = stored_requirement_name_by_id(cd,\
    \ hdr, req_id);\n+\t\t\tif (req)\n+\t\t\t\tjobj = json_object_new_string(req->description);\n\
    +\t\t\telse\n+\t\t\t\tjobj = json_object_new_string(requirements_flags[i].description);\n\
    \ \t\t\tif (!jobj) {\n \t\t\t\tr = -ENOMEM;\n \t\t\t\tgoto err;\n"
  - "--- a/lib/luks2/luks2_keyslot.c\n+++ b/lib/luks2/luks2_keyslot.c\n@@ -288,19\
    \ +288,9 @@ crypt_keyslot_info LUKS2_keyslot_info(struct luks2_hdr *hdr, int keyslot)\n\
    \ \treturn CRYPT_SLOT_ACTIVE;\n }\n \n-int LUKS2_keyslot_area(struct luks2_hdr\
    \ *hdr,\n-\tint keyslot,\n-\tuint64_t *offset,\n-\tuint64_t *length)\n+int LUKS2_keyslot_jobj_area(json_object\
    \ *jobj_keyslot, uint64_t *offset, uint64_t *length)\n {\n-\tjson_object *jobj_keyslot,\
    \ *jobj_area, *jobj;\n-\n-\tif(LUKS2_keyslot_info(hdr, keyslot) == CRYPT_SLOT_INVALID)\n\
    -\t\treturn -EINVAL;\n-\n-\tjobj_keyslot = LUKS2_get_keyslot_jobj(hdr, keyslot);\n\
    -\tif (!jobj_keyslot)\n-\t\treturn -ENOENT;\n+\tjson_object *jobj_area, *jobj;\n\
    \ \n \tif (!json_object_object_get_ex(jobj_keyslot, \"area\", &jobj_area))\n \t\
    \treturn -EINVAL;\n@@ -316,6 +306,23 @@ int LUKS2_keyslot_area(struct luks2_hdr\
    \ *hdr,\n \treturn 0;\n }\n \n+int LUKS2_keyslot_area(struct luks2_hdr *hdr,\n\
    +\tint keyslot,\n+\tuint64_t *offset,\n+\tuint64_t *length)\n+{\n+\tjson_object\
    \ *jobj_keyslot;\n+\n+\tif (LUKS2_keyslot_info(hdr, keyslot) == CRYPT_SLOT_INVALID)\n\
    +\t\treturn -EINVAL;\n+\n+\tjobj_keyslot = LUKS2_get_keyslot_jobj(hdr, keyslot);\n\
    +\tif (!jobj_keyslot)\n+\t\treturn -ENOENT;\n+\n+\treturn LUKS2_keyslot_jobj_area(jobj_keyslot,\
    \ offset, length);\n+}\n+\n static int _open_and_verify(struct crypt_device *cd,\n\
    \ \tstruct luks2_hdr *hdr,\n \tconst keyslot_handler *h,\n"
  - "--- a/lib/luks2/luks2_keyslot_reenc.c\n+++ b/lib/luks2/luks2_keyslot_reenc.c\n\
    @@ -176,9 +176,17 @@ static int reenc_keyslot_store(struct crypt_device *cd,\n\
    \ \treturn r < 0 ? r : keyslot;\n }\n \n-static int reenc_keyslot_wipe(struct\
    \ crypt_device *cd __attribute__((unused)),\n-\tint keyslot __attribute__((unused)))\n\
    +static int reenc_keyslot_wipe(struct crypt_device *cd,\n+\tint keyslot)\n {\n\
    +\tstruct luks2_hdr *hdr;\n+\n+\tif (!(hdr = crypt_get_hdr(cd, CRYPT_LUKS2)))\n\
    +\t\treturn -EINVAL;\n+\n+\t/* remove reencryption verification data */\n+\tLUKS2_digest_assign(cd,\
    \ hdr, keyslot, CRYPT_ANY_DIGEST, 0, 0);\n+\n \treturn 0;\n }\n \n"
  - "--- a/lib/luks2/luks2_reencrypt.c\n+++ b/lib/luks2/luks2_reencrypt.c\n@@ -95,6\
    \ +95,7 @@ struct luks2_reencrypt {\n static int reencrypt_keyslot_update(struct\
    \ crypt_device *cd,\n \tconst struct luks2_reencrypt *rh)\n {\n+\tint r;\n \t\
    json_object *jobj_keyslot, *jobj_area, *jobj_area_type;\n \tstruct luks2_hdr *hdr;\n\
    \ \n@@ -124,7 +125,11 @@ static int reencrypt_keyslot_update(struct crypt_device\
    \ *cd,\n \t} else\n \t\tlog_dbg(cd, \"No update of reencrypt keyslot needed.\"\
    );\n \n-\treturn 0;\n+\tr = LUKS2_keyslot_reencrypt_digest_create(cd, hdr, rh->vks);\n\
    +\tif (r < 0)\n+\t\tlog_err(cd, \"Failed to refresh reencryption verification\
    \ digest.\");\n+\n+\treturn r;\n }\n \n static json_object *reencrypt_segment(struct\
    \ luks2_hdr *hdr, unsigned new)\n@@ -2484,6 +2489,10 @@ static int reencrypt_init(struct\
    \ crypt_device *cd,\n \tif (r < 0)\n \t\tgoto out;\n \n+\tr = LUKS2_keyslot_reencrypt_digest_create(cd,\
    \ hdr, *vks);\n+\tif (r < 0)\n+\t\tgoto out;\n+\n \tif (name && params->mode !=\
    \ CRYPT_REENCRYPT_ENCRYPT) {\n \t\tr = reencrypt_verify_and_upload_keys(cd, hdr,\
    \ LUKS2_reencrypt_digest_old(hdr), LUKS2_reencrypt_digest_new(hdr), *vks);\n \t\
    \tif (r)\n@@ -2614,20 +2623,28 @@ static int reencrypt_context_update(struct crypt_device\
    \ *cd,\n static int reencrypt_load(struct crypt_device *cd, struct luks2_hdr *hdr,\n\
    \ \t\tuint64_t device_size,\n \t\tconst struct crypt_params_reencrypt *params,\n\
    +\t\tstruct volume_key *vks,\n \t\tstruct luks2_reencrypt **rh)\n {\n \tint r;\n\
    \ \tstruct luks2_reencrypt *tmp = NULL;\n \tcrypt_reencrypt_info ri = LUKS2_reencrypt_status(hdr);\n\
    \ \n+\tif (ri == CRYPT_REENCRYPT_NONE) {\n+\t\tlog_err(cd, _(\"Device not marked\
    \ for LUKS2 reencryption.\"));\n+\t\treturn -EINVAL;\n+\t} else if (ri == CRYPT_REENCRYPT_INVALID)\n\
    +\t\treturn -EINVAL;\n+\n+\tr = LUKS2_reencrypt_digest_verify(cd, hdr, vks);\n\
    +\tif (r < 0)\n+\t\treturn r;\n+\n \tif (ri == CRYPT_REENCRYPT_CLEAN)\n \t\tr\
    \ = reencrypt_load_clean(cd, hdr, device_size, &tmp, params);\n \telse if (ri\
    \ == CRYPT_REENCRYPT_CRASH)\n \t\tr = reencrypt_load_crashed(cd, hdr, device_size,\
    \ &tmp);\n-\telse if (ri == CRYPT_REENCRYPT_NONE) {\n-\t\tlog_err(cd, _(\"Device\
    \ not marked for LUKS2 reencryption.\"));\n-\t\treturn -EINVAL;\n-\t} else\n+\t\
    else\n \t\tr = -EINVAL;\n \n \tif (r < 0 || !tmp) {\n@@ -2876,7 +2893,7 @@ static\
    \ int reencrypt_load_by_passphrase(struct crypt_device *cd,\n \t\trparams.device_size\
    \ = required_size;\n \t}\n \n-\tr = reencrypt_load(cd, hdr, device_size, &rparams,\
    \ &rh);\n+\tr = reencrypt_load(cd, hdr, device_size, &rparams, *vks, &rh);\n \t\
    if (r < 0 || !rh)\n \t\tgoto err;\n \n@@ -3096,13 +3113,6 @@ static reenc_status_t\
    \ reencrypt_step(struct crypt_device *cd,\n {\n \tint r;\n \n-\t/* update reencrypt\
    \ keyslot protection parameters in memory only */\n-\tr = reencrypt_keyslot_update(cd,\
    \ rh);\n-\tif (r < 0) {\n-\t\tlog_dbg(cd, \"Keyslot update failed.\");\n-\t\t\
    return REENC_ERR;\n-\t}\n-\n \t/* in memory only */\n \tr = reencrypt_make_segments(cd,\
    \ hdr, rh, device_size);\n \tif (r)\n@@ -3370,6 +3380,15 @@ int crypt_reencrypt_run(\n\
    \ \n \trs = REENC_OK;\n \n+\t/* update reencrypt keyslot protection parameters\
    \ in memory only */\n+\tif (!quit && (rh->device_size > rh->progress)) {\n+\t\t\
    r = reencrypt_keyslot_update(cd, rh);\n+\t\tif (r < 0) {\n+\t\t\tlog_dbg(cd, \"\
    Keyslot update failed.\");\n+\t\t\treturn reencrypt_teardown(cd, hdr, rh, REENC_ERR,\
    \ quit, progress, usrptr);\n+\t\t}\n+\t}\n+\n \twhile (!quit && (rh->device_size\
    \ > rh->progress)) {\n \t\trs = reencrypt_step(cd, hdr, rh, rh->device_size, rh->online);\n\
    \ \t\tif (rs != REENC_OK)\n@@ -3409,7 +3428,7 @@ static int reencrypt_recovery(struct\
    \ crypt_device *cd,\n \tint r;\n \tstruct luks2_reencrypt *rh = NULL;\n \n-\t\
    r = reencrypt_load(cd, hdr, device_size, NULL, &rh);\n+\tr = reencrypt_load(cd,\
    \ hdr, device_size, NULL, vks, &rh);\n \tif (r < 0) {\n \t\tlog_err(cd, _(\"Failed\
    \ to load LUKS2 reencryption context.\"));\n \t\treturn r;\n"
  - "--- a/lib/luks2/luks2_reencrypt_digest.c\n+++ b/lib/luks2/luks2_reencrypt_digest.c\n\
    @@ -0,0 +1,381 @@\n+/*\n+ * LUKS - Linux Unified Key Setup v2, reencryption digest\
    \ helpers\n+ *\n+ * Copyright (C) 2022, Red Hat, Inc. All rights reserved.\n+\
    \ * Copyright (C) 2022, Ondrej Kozina\n+ * Copyright (C) 2022, Milan Broz\n+ *\n\
    + * This program is free software; you can redistribute it and/or\n+ * modify\
    \ it under the terms of the GNU General Public License\n+ * as published by the\
    \ Free Software Foundation; either version 2\n+ * of the License, or (at your\
    \ option) any later version.\n+ *\n+ * This program is distributed in the hope\
    \ that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied\
    \ warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n\
    + * GNU General Public License for more details.\n+ *\n+ * You should have received\
    \ a copy of the GNU General Public License\n+ * along with this program; if not,\
    \ write to the Free Software\n+ * Foundation, Inc., 51 Franklin Street, Fifth\
    \ Floor, Boston, MA 02110-1301 USA.\n+ */\n+\n+#include \"luks2_internal.h\"\n\
    +#include <assert.h>\n+\n+#define MAX_STR 64\n+\n+struct jtype {\n+\tenum { JNONE\
    \ = 0, JSTR, JU64, JX64, JU32 } type;\n+\tjson_object *jobj;\n+\tconst char *id;\n\
    +};\n+\n+static size_t sr(struct jtype *j, uint8_t *ptr)\n+{\n+\tjson_object *jobj;\n\
    +\tsize_t len = 0;\n+\tuint64_t u64;\n+\tuint32_t u32;\n+\n+\tif (!json_object_is_type(j->jobj,\
    \ json_type_object))\n+\t\treturn 0;\n+\n+\tif (!json_object_object_get_ex(j->jobj,\
    \ j->id, &jobj))\n+\t\treturn 0;\n+\n+\tswitch(j->type) {\n+\tcase JSTR: /* JSON\
    \ string */\n+\t\tif (!json_object_is_type(jobj, json_type_string))\n+\t\t\treturn\
    \ 0;\n+\t\tlen = strlen(json_object_get_string(jobj));\n+\t\tif (len > MAX_STR)\n\
    +\t\t\treturn 0;\n+\t\tif (ptr)\n+\t\t\tmemcpy(ptr, json_object_get_string(jobj),\
    \ len);\n+\t\tbreak;\n+\tcase JU64: /* Unsigned 64bit integer stored as string\
    \ */\n+\t\tif (!json_object_is_type(jobj, json_type_string))\n+\t\t\tbreak;\n\
    +\t\tlen = sizeof(u64);\n+\t\tif (ptr) {\n+\t\t\tu64 = cpu_to_be64(crypt_jobj_get_uint64(jobj));\n\
    +\t\t\tmemcpy(ptr, &u64, len);\n+\t\t}\n+\t\tbreak;\n+\tcase JX64: /* Unsigned\
    \ 64bit segment size (allows \"dynamic\") */\n+\t\tif (!json_object_is_type(jobj,\
    \ json_type_string))\n+\t\t\tbreak;\n+\t\tif (!strcmp(json_object_get_string(jobj),\
    \ \"dynamic\")) {\n+\t\t\tlen = strlen(\"dynamic\");\n+\t\t\tif (ptr)\n+\t\t\t\
    \tmemcpy(ptr, json_object_get_string(jobj), len);\n+\t\t} else {\n+\t\t\tlen =\
    \ sizeof(u64);\n+\t\t\tu64 = cpu_to_be64(crypt_jobj_get_uint64(jobj));\n+\t\t\t\
    if (ptr)\n+\t\t\t\tmemcpy(ptr, &u64, len);\n+\t\t}\n+\t\tbreak;\n+\tcase JU32:\
    \ /* Unsigned 32bit integer, stored as JSON int */\n+\t\tif (!json_object_is_type(jobj,\
    \ json_type_int))\n+\t\t\treturn 0;\n+\t\tlen =  sizeof(u32);\n+\t\tif (ptr) {\n\
    +\t\t\tu32 = cpu_to_be32(crypt_jobj_get_uint32(jobj));\n+\t\t\tmemcpy(ptr, &u32,\
    \ len);\n+\t\t}\n+\t\tbreak;\n+\tcase JNONE:\n+\t\treturn 0;\n+\t};\n+\n+\treturn\
    \ len;\n+}\n+\n+static size_t srs(struct jtype j[], uint8_t *ptr)\n+{\n+\tsize_t\
    \ l, len = 0;\n+\n+\twhile(j->jobj) {\n+\t\tl = sr(j, ptr);\n+\t\tif (!l)\n+\t\
    \t\treturn 0;\n+\t\tlen += l;\n+\t\tif (ptr)\n+\t\t\tptr += l;\n+\t\tj++;\n+\t\
    }\n+\treturn len;\n+}\n+\n+static size_t segment_linear_serialize(json_object\
    \ *jobj_segment, uint8_t *buffer)\n+{\n+\tstruct jtype j[] = {\n+\t\t{ JSTR, jobj_segment,\
    \ \"type\" },\n+\t\t{ JU64, jobj_segment, \"offset\" },\n+\t\t{ JX64, jobj_segment,\
    \ \"size\" },\n+\t\t{}\n+\t};\n+\treturn srs(j, buffer);\n+}\n+\n+static size_t\
    \ segment_crypt_serialize(json_object *jobj_segment, uint8_t *buffer)\n+{\n+\t\
    struct jtype j[] = {\n+\t\t{ JSTR, jobj_segment, \"type\" },\n+\t\t{ JU64, jobj_segment,\
    \ \"offset\" },\n+\t\t{ JX64, jobj_segment, \"size\" },\n+\t\t{ JU64, jobj_segment,\
    \ \"iv_tweak\" },\n+\t\t{ JSTR, jobj_segment, \"encryption\" },\n+\t\t{ JU32,\
    \ jobj_segment, \"sector_size\" },\n+\t\t{}\n+\t};\n+\treturn srs(j, buffer);\n\
    +}\n+\n+static size_t segment_serialize(json_object *jobj_segment, uint8_t *buffer)\n\
    +{\n+\tjson_object *jobj_type;\n+\tconst char *segment_type;\n+\n+\tif (!json_object_object_get_ex(jobj_segment,\
    \ \"type\", &jobj_type))\n+\t\treturn 0;\n+\n+\tif (!(segment_type = json_object_get_string(jobj_type)))\n\
    +\t\treturn 0;\n+\n+\tif (!strcmp(segment_type, \"crypt\"))\n+\t\treturn segment_crypt_serialize(jobj_segment,\
    \ buffer);\n+\telse if (!strcmp(segment_type, \"linear\"))\n+\t\treturn segment_linear_serialize(jobj_segment,\
    \ buffer);\n+\n+\treturn 0;\n+}\n+\n+static size_t backup_segments_serialize(struct\
    \ luks2_hdr *hdr, uint8_t *buffer)\n+{\n+\tjson_object *jobj_segment;\n+\tsize_t\
    \ l, len = 0;\n+\n+\tjobj_segment = LUKS2_get_segment_by_flag(hdr, \"backup-previous\"\
    );\n+\tif (!jobj_segment || !(l = segment_serialize(jobj_segment, buffer)))\n\
    +\t\treturn 0;\n+\tlen += l;\n+\tif (buffer)\n+\t\tbuffer += l;\n+\n+\tjobj_segment\
    \ = LUKS2_get_segment_by_flag(hdr, \"backup-final\");\n+\tif (!jobj_segment ||\
    \ !(l = segment_serialize(jobj_segment, buffer)))\n+\t\treturn 0;\n+\tlen += l;\n\
    +\tif (buffer)\n+\t\tbuffer += l;\n+\n+\tjobj_segment = LUKS2_get_segment_by_flag(hdr,\
    \ \"backup-moved-segment\");\n+\tif (jobj_segment) {\n+\t\tif (!(l = segment_serialize(jobj_segment,\
    \ buffer)))\n+\t\t\treturn 0;\n+\t\tlen += l;\n+\t}\n+\n+\treturn len;\n+}\n+\n\
    +static size_t reenc_keyslot_serialize(struct luks2_hdr *hdr, uint8_t *buffer)\n\
    +{\n+\tjson_object *jobj_keyslot, *jobj_area, *jobj_type;\n+\tconst char *area_type;\n\
    +\tint keyslot_reencrypt;\n+\n+\tkeyslot_reencrypt = LUKS2_find_keyslot(hdr, \"\
    reencrypt\");\n+\tif (keyslot_reencrypt < 0)\n+\t\treturn 0;\n+\n+\tif (!(jobj_keyslot\
    \ = LUKS2_get_keyslot_jobj(hdr, keyslot_reencrypt)))\n+\t\treturn 0;\n+\n+\tif\
    \ (!json_object_object_get_ex(jobj_keyslot, \"area\", &jobj_area))\n+\t\treturn\
    \ 0;\n+\n+\tif (!json_object_object_get_ex(jobj_area, \"type\", &jobj_type))\n\
    +\t\treturn 0;\n+\n+\tif (!(area_type = json_object_get_string(jobj_type)))\n\
    +\t\treturn 0;\n+\n+\tstruct jtype j[] = {\n+\t\t{ JSTR, jobj_keyslot, \"mode\"\
    \ },\n+\t\t{ JSTR, jobj_keyslot, \"direction\" },\n+\t\t{ JSTR, jobj_area,   \
    \ \"type\" },\n+\t\t{ JU64, jobj_area,    \"offset\" },\n+\t\t{ JU64, jobj_area,\
    \    \"size\" },\n+\t\t{}\n+\t};\n+\tstruct jtype j_datashift[] = {\n+\t\t{ JSTR,\
    \ jobj_keyslot, \"mode\" },\n+\t\t{ JSTR, jobj_keyslot, \"direction\" },\n+\t\t\
    { JSTR, jobj_area,    \"type\" },\n+\t\t{ JU64, jobj_area,    \"offset\" },\n\
    +\t\t{ JU64, jobj_area,    \"size\" },\n+\t\t{ JU64, jobj_area,    \"shift_size\"\
    \ },\n+\t\t{}\n+\t};\n+\tstruct jtype j_checksum[] = {\n+\t\t{ JSTR, jobj_keyslot,\
    \ \"mode\" },\n+\t\t{ JSTR, jobj_keyslot, \"direction\" },\n+\t\t{ JSTR, jobj_area,\
    \    \"type\" },\n+\t\t{ JU64, jobj_area,    \"offset\" },\n+\t\t{ JU64, jobj_area,\
    \    \"size\" },\n+\t\t{ JSTR, jobj_area,    \"hash\" },\n+\t\t{ JU32, jobj_area,\
    \    \"sector_size\" },\n+\t\t{}\n+\t};\n+\n+\tif (!strcmp(area_type, \"datashift\"\
    ))\n+\t\treturn srs(j_datashift, buffer);\n+\telse if (!strcmp(area_type, \"checksum\"\
    ))\n+\t\treturn srs(j_checksum, buffer);\n+\n+\treturn srs(j, buffer);\n+}\n+\n\
    +static size_t blob_serialize(void *blob, size_t length, uint8_t *buffer)\n+{\n\
    +\tif (buffer)\n+\t\tmemcpy(buffer, blob, length);\n+\n+\treturn length;\n+}\n\
    +\n+static int reencrypt_assembly_verification_data(struct crypt_device *cd,\n\
    +\tstruct luks2_hdr *hdr,\n+\tstruct volume_key *vks,\n+\tstruct volume_key **verification_data)\n\
    +{\n+\tuint8_t *ptr;\n+\tint digest_new, digest_old;\n+\tstruct volume_key *data\
    \ = NULL, *vk_old = NULL, *vk_new = NULL;\n+\tsize_t keyslot_data_len, segments_data_len,\
    \ data_len = 2;\n+\n+\t/* Keys - calculate length */\n+\tdigest_new = LUKS2_reencrypt_digest_new(hdr);\n\
    +\tdigest_old = LUKS2_reencrypt_digest_old(hdr);\n+\n+\tif (digest_old >= 0) {\n\
    +\t\tvk_old = crypt_volume_key_by_id(vks, digest_old);\n+\t\tif (!vk_old)\n+\t\
    \t\treturn -EINVAL;\n+\t\tdata_len += blob_serialize(vk_old->key, vk_old->keylength,\
    \ NULL);\n+\t}\n+\n+\tif (digest_new >= 0 && digest_old != digest_new) {\n+\t\t\
    vk_new = crypt_volume_key_by_id(vks, digest_new);\n+\t\tif (!vk_new)\n+\t\t\t\
    return -EINVAL;\n+\t\tdata_len += blob_serialize(vk_new->key, vk_new->keylength,\
    \ NULL);\n+\t}\n+\n+\tif (data_len == 2)\n+\t\treturn -EINVAL;\n+\n+\t/* Metadata\
    \ - calculate length */\n+\tif (!(keyslot_data_len = reenc_keyslot_serialize(hdr,\
    \ NULL)))\n+\t\treturn -EINVAL;\n+\tdata_len += keyslot_data_len;\n+\n+\tif (!(segments_data_len\
    \ = backup_segments_serialize(hdr, NULL)))\n+\t\treturn -EINVAL;\n+\tdata_len\
    \ += segments_data_len;\n+\n+\t/* Alloc and fill serialization data */\n+\tdata\
    \ = crypt_alloc_volume_key(data_len, NULL);\n+\tif (!data)\n+\t\treturn -ENOMEM;\n\
    +\n+\tptr = (uint8_t*)data->key;\n+\n+\t/* v2 */\n+\t*ptr++ = 0x76;\n+\t*ptr++\
    \ = 0x32;\n+\n+\tif (vk_old)\n+\t\tptr += blob_serialize(vk_old->key, vk_old->keylength,\
    \ ptr);\n+\n+\tif (vk_new)\n+\t\tptr += blob_serialize(vk_new->key, vk_new->keylength,\
    \ ptr);\n+\n+\tif (!reenc_keyslot_serialize(hdr, ptr))\n+\t\tgoto bad;\n+\tptr\
    \ += keyslot_data_len;\n+\n+\tif (!backup_segments_serialize(hdr, ptr))\n+\t\t\
    goto bad;\n+\tptr += segments_data_len;\n+\n+\tassert((size_t)(ptr - (uint8_t*)data->key)\
    \ == data_len);\n+\n+\t*verification_data = data;\n+\n+\treturn 0;\n+bad:\n+\t\
    crypt_free_volume_key(data);\n+\treturn -EINVAL;\n+}\n+\n+int LUKS2_keyslot_reencrypt_digest_create(struct\
    \ crypt_device *cd,\n+\tstruct luks2_hdr *hdr,\n+\tstruct volume_key *vks)\n+{\n\
    +\tint digest_reencrypt, keyslot_reencrypt, r;\n+\tstruct volume_key *data;\n\
    +\n+\tkeyslot_reencrypt = LUKS2_find_keyslot(hdr, \"reencrypt\");\n+\tif (keyslot_reencrypt\
    \ < 0)\n+\t\treturn keyslot_reencrypt;\n+\n+\tr = reencrypt_assembly_verification_data(cd,\
    \ hdr, vks, &data);\n+\tif (r < 0)\n+\t\treturn r;\n+\n+\tr = LUKS2_digest_create(cd,\
    \ \"pbkdf2\", hdr, data);\n+\tcrypt_free_volume_key(data);\n+\tif (r < 0)\n+\t\
    \treturn r;\n+\n+\tdigest_reencrypt = r;\n+\n+\tr = LUKS2_digest_assign(cd, hdr,\
    \ keyslot_reencrypt, CRYPT_ANY_DIGEST, 0, 0);\n+\tif (r < 0)\n+\t\treturn r;\n\
    +\n+\treturn LUKS2_digest_assign(cd, hdr, keyslot_reencrypt, digest_reencrypt,\
    \ 1, 0);\n+}\n+\n+int LUKS2_reencrypt_digest_verify(struct crypt_device *cd,\n\
    +\tstruct luks2_hdr *hdr,\n+\tstruct volume_key *vks)\n+{\n+\tint r, keyslot_reencrypt;\n\
    +\tstruct volume_key *data;\n+\n+\tkeyslot_reencrypt = LUKS2_find_keyslot(hdr,\
    \ \"reencrypt\");\n+\tif (keyslot_reencrypt < 0)\n+\t\treturn keyslot_reencrypt;\n\
    +\n+\tr = reencrypt_assembly_verification_data(cd, hdr, vks, &data);\n+\tif (r\
    \ < 0)\n+\t\treturn r;\n+\n+\tr = LUKS2_digest_verify(cd, hdr, data, keyslot_reencrypt);\n\
    +\tcrypt_free_volume_key(data);\n+\n+\tif (r < 0) {\n+\t\tif (r == -ENOENT)\n\
    +\t\t\tlog_dbg(cd, \"Reencryption digest is missing.\");\n+\t\tlog_err(cd, _(\"\
    Reencryption metadata is invalid.\"));\n+\t} else\n+\t\tlog_dbg(cd, \"Reencryption\
    \ metadata verified.\");\n+\n+\treturn r;\n+}\n"
  - "--- a/lib/setup.c\n+++ b/lib/setup.c\n@@ -4131,6 +4131,12 @@ static int _open_and_activate_reencrypt_device(struct\
    \ crypt_device *cd,\n \t\t\tkeyslot = r;\n \t}\n \n+\tif (r >= 0) {\n+\t\tr =\
    \ LUKS2_reencrypt_digest_verify(cd, hdr, vks);\n+\t\tif (r < 0)\n+\t\t\tgoto out;\n\
    +\t}\n+\n \tlog_dbg(cd, \"Entering clean reencryption state mode.\");\n \n \t\
    if (r >= 0)\n@@ -4158,8 +4164,9 @@ static int _open_and_activate_luks2(struct\
    \ crypt_device *cd,\n \tuint32_t flags)\n {\n \tcrypt_reencrypt_info ri;\n-\t\
    int r;\n+\tint r, rv;\n \tstruct luks2_hdr *hdr = &cd->u.luks2.hdr;\n+\tstruct\
    \ volume_key *vks = NULL;\n \n \tri = LUKS2_reencrypt_status(hdr);\n \tif (ri\
    \ == CRYPT_REENCRYPT_INVALID)\n@@ -4169,9 +4176,17 @@ static int _open_and_activate_luks2(struct\
    \ crypt_device *cd,\n \t\tif (name)\n \t\t\tr = _open_and_activate_reencrypt_device(cd,\
    \ hdr, keyslot, name, passphrase,\n \t\t\t\t\tpassphrase_size, flags);\n-\t\t\
    else\n+\t\telse {\n \t\t\tr = _open_all_keys(cd, hdr, keyslot, passphrase,\n-\t\
    \t\t\t\t   passphrase_size, flags, NULL);\n+\t\t\t\t\t   passphrase_size, flags,\
    \ &vks);\n+\t\t\tif (r < 0)\n+\t\t\t\treturn r;\n+\n+\t\t\trv = LUKS2_reencrypt_digest_verify(cd,\
    \ hdr, vks);\n+\t\t\tcrypt_free_volume_key(vks);\n+\t\t\tif (rv < 0)\n+\t\t\t\t\
    return rv;\n+\t\t}\n \t} else\n \t\tr = _open_and_activate(cd, keyslot, name,\
    \ passphrase,\n \t\t\t\tpassphrase_size, flags);\n"
  identifiers:
  - CVE-2021-4122
  - CWE-345
  overview: It was found that a specially crafted LUKS header could trick cryptsetup
    into disabling encryption during the recovery of the device. An attacker with
    physical access to the medium, such as a flash disk, could use this flaw to force
    a user into permanently disabling the encryption layer of that medium.
  references:
  - source: secalert@redhat.com
    tags:
    - Third Party Advisory
    url: https://access.redhat.com/security/cve/CVE-2021-4122
  - source: secalert@redhat.com
    tags:
    - Permissions Required
    - Third Party Advisory
    url: https://bugzilla.redhat.com/show_bug.cgi?id=2031859
  - source: secalert@redhat.com
    tags:
    - Issue Tracking
    - Third Party Advisory
    url: https://bugzilla.redhat.com/show_bug.cgi?id=2032401
  - source: secalert@redhat.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://gitlab.com/cryptsetup/cryptsetup/-/commit/0113ac2d889c5322659ad0596d4cfc6da53e356c
  - source: secalert@redhat.com
    tags:
    - Release Notes
    - Vendor Advisory
    url: https://mirrors.edge.kernel.org/pub/linux/utils/cryptsetup/v2.4/v2.4.3-ReleaseNotes
  title: It was found that a specially crafted LUKS header could trick cryptsetup
    into disabling encryption during the recovery of the device. An attacker with
    physical access to the medium, such as a flash disk, could use this flaw to force
    a user into permanently disabling the encryption layer of that medium.
- diff_content:
  - "--- a/hw/acpi/pcihp.c\n+++ b/hw/acpi/pcihp.c\n@@ -491,6 +491,9 @@ static void\
    \ pci_write(void *opaque, hwaddr addr, uint64_t data,\n         }\n \n       \
    \  bus = acpi_pcihp_find_hotplug_bus(s, s->hotplug_select);\n+        if (!bus)\
    \ {\n+            break;\n+        }\n         QTAILQ_FOREACH_SAFE(kid, &bus->qbus.children,\
    \ sibling, next) {\n             Object *o = OBJECT(kid->child);\n           \
    \  PCIDevice *dev = PCI_DEVICE(o);\n"
  identifiers:
  - CVE-2021-4158
  - CWE-476
  overview: A NULL pointer dereference issue was found in the ACPI code of QEMU. A
    malicious, privileged user within the guest could use this flaw to crash the QEMU
    process on the host, resulting in a denial of service condition.
  references:
  - source: secalert@redhat.com
    tags:
    - Third Party Advisory
    url: https://access.redhat.com/security/cve/CVE-2021-4158
  - source: secalert@redhat.com
    tags:
    - Issue Tracking
    - Patch
    - Third Party Advisory
    url: https://bugzilla.redhat.com/show_bug.cgi?id=2035002
  - source: secalert@redhat.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://gitlab.com/qemu-project/qemu/-/commit/9bd6565ccee68f72d5012e24646e12a1c662827e
  - source: secalert@redhat.com
    tags:
    - Exploit
    - Third Party Advisory
    url: https://gitlab.com/qemu-project/qemu/-/issues/770
  - source: secalert@redhat.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://www.mail-archive.com/qemu-devel%40nongnu.org/msg857944.html
  title: A NULL pointer dereference issue was found in the ACPI code of QEMU. A malicious,
    privileged user within the guest could use this flaw to crash the QEMU process
    on the host, resulting in a denial of service condition.
- diff_content:
  - "--- a/lib/nettle/mac.c\n+++ b/lib/nettle/mac.c\n@@ -788,7 +788,9 @@ static int\
    \ wrap_nettle_hash_fast(gnutls_digest_algorithm_t algo,\n \tif (ret < 0)\n \t\t\
    return gnutls_assert_val(ret);\n \n-\tctx.update(&ctx, text_size, text);\n+\t\
    if (text_size > 0) {\n+\t\tctx.update(&ctx, text_size, text);\n+\t}\n \tctx.digest(&ctx,\
    \ ctx.length, digest);\n \n \treturn 0;\n"
  identifiers:
  - CVE-2021-4209
  - CWE-476
  overview: A NULL pointer dereference flaw was found in GnuTLS. As Nettle's hash
    update functions internally call memcpy, providing zero-length input may cause
    undefined behavior. This flaw leads to a denial of service after authentication
    in rare circumstances.
  references:
  - source: secalert@redhat.com
    tags:
    - Third Party Advisory
    url: https://access.redhat.com/security/cve/CVE-2021-4209
  - source: secalert@redhat.com
    tags:
    - Issue Tracking
    - Third Party Advisory
    url: https://bugzilla.redhat.com/show_bug.cgi?id=2044156
  - source: secalert@redhat.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://gitlab.com/gnutls/gnutls/-/commit/3db352734472d851318944db13be73da61300568
  - source: secalert@redhat.com
    tags:
    - Third Party Advisory
    url: https://gitlab.com/gnutls/gnutls/-/issues/1306
  - source: secalert@redhat.com
    tags:
    - Third Party Advisory
    url: https://gitlab.com/gnutls/gnutls/-/merge_requests/1503
  - source: secalert@redhat.com
    tags:
    - Third Party Advisory
    url: https://security.netapp.com/advisory/ntap-20220915-0005/
  title: A NULL pointer dereference flaw was found in GnuTLS. As Nettle's hash update
    functions internally call memcpy, providing zero-length input may cause undefined
    behavior. This flaw leads to a denial of service after authentication in rare
    circumstances.
- diff_content:
  - "--- a/fs/pipe.c\n+++ b/fs/pipe.c\n@@ -1245,30 +1245,33 @@ unsigned int round_pipe_size(unsigned\
    \ long size)\n \n /*\n  * Resize the pipe ring to a number of slots.\n+ *\n+ *\
    \ Note the pipe can be reduced in capacity, but only if the current\n+ * occupancy\
    \ doesn't exceed nr_slots; if it does, EBUSY will be\n+ * returned instead.\n\
    \  */\n int pipe_resize_ring(struct pipe_inode_info *pipe, unsigned int nr_slots)\n\
    \ {\n \tstruct pipe_buffer *bufs;\n \tunsigned int head, tail, mask, n;\n \n-\t\
    /*\n-\t * We can shrink the pipe, if arg is greater than the ring occupancy.\n\
    -\t * Since we don't expect a lot of shrink+grow operations, just free and\n-\t\
    \ * allocate again like we would do for growing.  If the pipe currently\n-\t *\
    \ contains more buffers than arg, then return busy.\n-\t */\n-\tmask = pipe->ring_size\
    \ - 1;\n-\thead = pipe->head;\n-\ttail = pipe->tail;\n-\tn = pipe_occupancy(pipe->head,\
    \ pipe->tail);\n-\tif (nr_slots < n)\n-\t\treturn -EBUSY;\n-\n \tbufs = kcalloc(nr_slots,\
    \ sizeof(*bufs),\n \t\t       GFP_KERNEL_ACCOUNT | __GFP_NOWARN);\n \tif (unlikely(!bufs))\n\
    \ \t\treturn -ENOMEM;\n \n+\tspin_lock_irq(&pipe->rd_wait.lock);\n+\tmask = pipe->ring_size\
    \ - 1;\n+\thead = pipe->head;\n+\ttail = pipe->tail;\n+\n+\tn = pipe_occupancy(head,\
    \ tail);\n+\tif (nr_slots < n) {\n+\t\tspin_unlock_irq(&pipe->rd_wait.lock);\n\
    +\t\tkfree(bufs);\n+\t\treturn -EBUSY;\n+\t}\n+\n \t/*\n \t * The pipe array wraps\
    \ around, so just start the new one at zero\n \t * and adjust the indices.\n@@\
    \ -1300,6 +1303,8 @@ int pipe_resize_ring(struct pipe_inode_info *pipe, unsigned\
    \ int nr_slots)\n \tpipe->tail = tail;\n \tpipe->head = head;\n \n+\tspin_unlock_irq(&pipe->rd_wait.lock);\n\
    +\n \t/* This might have made more room for writers */\n \twake_up_interruptible(&pipe->wr_wait);\n\
    \ \treturn 0;"
  identifiers:
  - CVE-2022-2959
  - CWE-362
  overview: A race condition was found in the Linux kernel's watch queue due to a
    missing lock in pipe_resize_ring(). The specific flaw exists within the handling
    of pipe buffers. The issue results from the lack of proper locking when performing
    operations on an object. This flaw allows a local user to crash the system or
    escalate their privileges on the system.
  references:
  - source: secalert@redhat.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/torvalds/linux/commit/189b0ddc245139af81198d1a3637cac74f96e13a
  - source: secalert@redhat.com
    tags:
    - Third Party Advisory
    url: https://security.netapp.com/advisory/ntap-20230214-0005/
  - source: secalert@redhat.com
    tags:
    - Third Party Advisory
    - VDB Entry
    url: https://www.zerodayinitiative.com/advisories/ZDI-22-1165/
  title: A race condition was found in the Linux kernel's watch queue due to a missing
    lock in pipe_resize_ring(). The specific flaw exists within the handling of pipe
    buffers. The issue results from the lack of proper locking when performing operations
    on an object. This flaw allows a local user to crash the system or escalate their
    privileges on the system.
- diff_content:
  - "--- a/MagickCore/quantum-export.c\n+++ b/MagickCore/quantum-export.c\n@@ -2530,28\
    \ +2530,28 @@ static void ExportIndexQuantum(const Image *image,QuantumInfo *quantum_info,\n\
    \ \n       for (x=((ssize_t) number_pixels-7); x > 0; x-=8)\n       {\n-     \
    \   pixel=(unsigned char) GetPixelIndex(image,p);\n+        pixel=(unsigned char)\
    \ ((ssize_t) GetPixelIndex(image,p));\n         *q=((pixel & 0x01) << 7);\n  \
    \       p+=GetPixelChannels(image);\n-        pixel=(unsigned char) GetPixelIndex(image,p);\n\
    +        pixel=(unsigned char) ((ssize_t) GetPixelIndex(image,p));\n         *q|=((pixel\
    \ & 0x01) << 6);\n         p+=GetPixelChannels(image);\n-        pixel=(unsigned\
    \ char) GetPixelIndex(image,p);\n+        pixel=(unsigned char) ((ssize_t) GetPixelIndex(image,p));\n\
    \         *q|=((pixel & 0x01) << 5);\n         p+=GetPixelChannels(image);\n-\
    \        pixel=(unsigned char) GetPixelIndex(image,p);\n+        pixel=(unsigned\
    \ char) ((ssize_t) GetPixelIndex(image,p));\n         *q|=((pixel & 0x01) << 4);\n\
    \         p+=GetPixelChannels(image);\n-        pixel=(unsigned char) GetPixelIndex(image,p);\n\
    +        pixel=(unsigned char) ((ssize_t) GetPixelIndex(image,p));\n         *q|=((pixel\
    \ & 0x01) << 3);\n         p+=GetPixelChannels(image);\n-        pixel=(unsigned\
    \ char) GetPixelIndex(image,p);\n+        pixel=(unsigned char) ((ssize_t) GetPixelIndex(image,p));\n\
    \         *q|=((pixel & 0x01) << 2);\n         p+=GetPixelChannels(image);\n-\
    \        pixel=(unsigned char) GetPixelIndex(image,p);\n+        pixel=(unsigned\
    \ char) ((ssize_t) GetPixelIndex(image,p));\n         *q|=((pixel & 0x01) << 1);\n\
    \         p+=GetPixelChannels(image);\n-        pixel=(unsigned char) GetPixelIndex(image,p);\n\
    +        pixel=(unsigned char) ((ssize_t) GetPixelIndex(image,p));\n         *q|=((pixel\
    \ & 0x01) << 0);\n         p+=GetPixelChannels(image);\n         q++;\n@@ -2561,7\
    \ +2561,7 @@ static void ExportIndexQuantum(const Image *image,QuantumInfo *quantum_info,\n\
    \           *q='\\0';\n           for (bit=7; bit >= (ssize_t) (8-(number_pixels\
    \ % 8)); bit--)\n           {\n-            pixel=(unsigned char) GetPixelIndex(image,p);\n\
    +            pixel=(unsigned char) ((ssize_t) GetPixelIndex(image,p));\n     \
    \        *q|=((pixel & 0x01) << (unsigned char) bit);\n             p+=GetPixelChannels(image);\n\
    \           }\n@@ -2576,17 +2576,17 @@ static void ExportIndexQuantum(const Image\
    \ *image,QuantumInfo *quantum_info,\n \n       for (x=0; x < (ssize_t) (number_pixels-1)\
    \ ; x+=2)\n       {\n-        pixel=(unsigned char) GetPixelIndex(image,p);\n\
    +        pixel=(unsigned char) ((ssize_t) GetPixelIndex(image,p));\n         *q=((pixel\
    \ & 0xf) << 4);\n         p+=GetPixelChannels(image);\n-        pixel=(unsigned\
    \ char) GetPixelIndex(image,p);\n+        pixel=(unsigned char) ((ssize_t) GetPixelIndex(image,p));\n\
    \         *q|=((pixel & 0xf) << 0);\n         p+=GetPixelChannels(image);\n  \
    \       q++;\n       }\n       if ((number_pixels % 2) != 0)\n         {\n-  \
    \        pixel=(unsigned char) GetPixelIndex(image,p);\n+          pixel=(unsigned\
    \ char) ((ssize_t) GetPixelIndex(image,p));\n           *q=((pixel & 0xf) << 4);\n\
    \           p+=GetPixelChannels(image);\n           q++;\n@@ -2597,7 +2597,7 @@\
    \ static void ExportIndexQuantum(const Image *image,QuantumInfo *quantum_info,\n\
    \     {\n       for (x=0; x < (ssize_t) number_pixels; x++)\n       {\n-     \
    \   q=PopCharPixel((unsigned char) GetPixelIndex(image,p),q);\n+        q=PopCharPixel((unsigned\
    \ char) ((ssize_t) GetPixelIndex(image,p)),q);\n         p+=GetPixelChannels(image);\n\
    \         q+=quantum_info->pad;\n       }"
  - "--- a/magick/quantum-export.c\n+++ b/magick/quantum-export.c\n@@ -2516,21 +2516,21\
    \ @@ static void ExportIndexQuantum(const Image *image,QuantumInfo *quantum_info,\n\
    \ \n       for (x=((ssize_t) number_pixels-7); x > 0; x-=8)\n       {\n-     \
    \   pixel=(unsigned char) *indexes++;\n+        pixel=(unsigned char) ((ssize_t)\
    \ *indexes++);\n         *q=((pixel & 0x01) << 7);\n-        pixel=(unsigned char)\
    \ *indexes++;\n+        pixel=(unsigned char) ((ssize_t) *indexes++);\n      \
    \   *q|=((pixel & 0x01) << 6);\n-        pixel=(unsigned char) *indexes++;\n+\
    \        pixel=(unsigned char) ((ssize_t) *indexes++);\n         *q|=((pixel &\
    \ 0x01) << 5);\n-        pixel=(unsigned char) *indexes++;\n+        pixel=(unsigned\
    \ char) ((ssize_t) *indexes++);\n         *q|=((pixel & 0x01) << 4);\n-      \
    \  pixel=(unsigned char) *indexes++;\n+        pixel=(unsigned char) ((ssize_t)\
    \ *indexes++);\n         *q|=((pixel & 0x01) << 3);\n-        pixel=(unsigned\
    \ char) *indexes++;\n+        pixel=(unsigned char) ((ssize_t) *indexes++);\n\
    \         *q|=((pixel & 0x01) << 2);\n-        pixel=(unsigned char) *indexes++;\n\
    +        pixel=(unsigned char) ((ssize_t) *indexes++);\n         *q|=((pixel &\
    \ 0x01) << 1);\n-        pixel=(unsigned char) *indexes++;\n+        pixel=(unsigned\
    \ char) ((ssize_t) *indexes++);\n         *q|=((pixel & 0x01) << 0);\n       \
    \  q++;\n       }\n@@ -2539,7 +2539,7 @@ static void ExportIndexQuantum(const\
    \ Image *image,QuantumInfo *quantum_info,\n           *q='\\0';\n           for\
    \ (bit=7; bit >= (ssize_t) (8-(number_pixels % 8)); bit--)\n           {\n-  \
    \          pixel=(unsigned char) *indexes++;\n+            pixel=(unsigned char)\
    \ ((ssize_t) *indexes++);\n             *q|=((pixel & 0x01) << (unsigned char)\
    \ bit);\n           }\n           q++;\n@@ -2553,15 +2553,15 @@ static void ExportIndexQuantum(const\
    \ Image *image,QuantumInfo *quantum_info,\n \n       for (x=0; x < (ssize_t) (number_pixels-1)\
    \ ; x+=2)\n       {\n-        pixel=(unsigned char) *indexes++;\n+        pixel=(unsigned\
    \ char) ((ssize_t) *indexes++);\n         *q=((pixel & 0xf) << 4);\n-        pixel=(unsigned\
    \ char) *indexes++;\n+        pixel=(unsigned char) ((ssize_t) *indexes++);\n\
    \         *q|=((pixel & 0xf) << 0);\n         q++;\n       }\n       if ((number_pixels\
    \ % 2) != 0)\n         {\n-          pixel=(unsigned char) *indexes++;\n+    \
    \      pixel=(unsigned char) ((ssize_t) *indexes++);\n           *q=((pixel &\
    \ 0xf) << 4);\n           q++;\n         }\n@@ -2669,25 +2669,25 @@ static void\
    \ ExportIndexAlphaQuantum(const Image *image,\n \n       for (x=((ssize_t) number_pixels-3);\
    \ x > 0; x-=4)\n       {\n-        pixel=(unsigned char) *indexes++;\n+      \
    \  pixel=(unsigned char) ((ssize_t) *indexes++);\n         *q=((pixel & 0x01)\
    \ << 7);\n         pixel=(unsigned char) (GetPixelOpacity(p) == (Quantum)\n  \
    \         TransparentOpacity ? 1 : 0);\n         *q|=((pixel & 0x01) << 6);\n\
    \         p++;\n-        pixel=(unsigned char) *indexes++;\n+        pixel=(unsigned\
    \ char) ((ssize_t) *indexes++);\n         *q|=((pixel & 0x01) << 5);\n       \
    \  pixel=(unsigned char) (GetPixelOpacity(p) == (Quantum)\n           TransparentOpacity\
    \ ? 1 : 0);\n         *q|=((pixel & 0x01) << 4);\n         p++;\n-        pixel=(unsigned\
    \ char) *indexes++;\n+        pixel=(unsigned char) ((ssize_t) *indexes++);\n\
    \         *q|=((pixel & 0x01) << 3);\n         pixel=(unsigned char) (GetPixelOpacity(p)\
    \ == (Quantum)\n           TransparentOpacity ? 1 : 0);\n         *q|=((pixel\
    \ & 0x01) << 2);\n         p++;\n-        pixel=(unsigned char) *indexes++;\n\
    +        pixel=(unsigned char) ((ssize_t) *indexes++);\n         *q|=((pixel &\
    \ 0x01) << 1);\n         pixel=(unsigned char) (GetPixelOpacity(p) == (Quantum)\n\
    \           TransparentOpacity ? 1 : 0);\n@@ -2700,7 +2700,7 @@ static void ExportIndexAlphaQuantum(const\
    \ Image *image,\n           *q='\\0';\n           for (bit=3; bit >= (ssize_t)\
    \ (4-(number_pixels % 4)); bit-=2)\n           {\n-            pixel=(unsigned\
    \ char) *indexes++;\n+            pixel=(unsigned char) ((ssize_t) *indexes++);\n\
    \             *q|=((pixel & 0x01) << (unsigned char) (bit+4));\n             pixel=(unsigned\
    \ char) (GetPixelOpacity(p) == (Quantum)\n               TransparentOpacity ?\
    \ 1 : 0);\n@@ -2718,10 +2718,10 @@ static void ExportIndexAlphaQuantum(const Image\
    \ *image,\n \n       for (x=0; x < (ssize_t) number_pixels ; x++)\n       {\n\
    -        pixel=(unsigned char) *indexes++;\n+        pixel=(unsigned char) ((ssize_t)\
    \ *indexes++);\n         *q=((pixel & 0xf) << 4);\n-        pixel=(unsigned char)\
    \ (16*QuantumScale*((Quantum) (QuantumRange-\n-          GetPixelOpacity(p)))+0.5);\n\
    +        pixel=(unsigned char) ((ssize_t) (16*QuantumScale*((Quantum)\n+     \
    \     (QuantumRange-GetPixelOpacity(p)))+0.5));\n         *q|=((pixel & 0xf) <<\
    \ 0);\n         p++;\n         q++;\n@@ -2752,7 +2752,8 @@ static void ExportIndexAlphaQuantum(const\
    \ Image *image,\n         {\n           for (x=0; x < (ssize_t) number_pixels;\
    \ x++)\n           {\n-            q=PopShortPixel(quantum_info->endian,(unsigned\
    \ short) GetPixelIndex(indexes+x),q);\n+            q=PopShortPixel(quantum_info->endian,(unsigned\
    \ short)\n+              ((ssize_t) GetPixelIndex(indexes+x)),q);\n          \
    \   pixel=SinglePrecisionToHalf(QuantumScale*GetPixelAlpha(p));\n            \
    \ q=PopShortPixel(quantum_info->endian,pixel,q);\n             p++;\n@@ -2762,7\
    \ +2763,8 @@ static void ExportIndexAlphaQuantum(const Image *image,\n       \
    \  }\n       for (x=0; x < (ssize_t) number_pixels; x++)\n       {\n-        q=PopShortPixel(quantum_info->endian,(unsigned\
    \ short) GetPixelIndex(indexes+x),q);\n+        q=PopShortPixel(quantum_info->endian,(unsigned\
    \ short)\n+          ((ssize_t) GetPixelIndex(indexes+x)),q);\n         pixel=ScaleQuantumToShort((Quantum)\
    \ (QuantumRange-GetPixelOpacity(p)));\n         q=PopShortPixel(quantum_info->endian,pixel,q);\n\
    \         p++;\n@@ -2792,7 +2794,8 @@ static void ExportIndexAlphaQuantum(const\
    \ Image *image,\n         }\n       for (x=0; x < (ssize_t) number_pixels; x++)\n\
    \       {\n-        q=PopLongPixel(quantum_info->endian,(unsigned int) GetPixelIndex(indexes+x),q);\n\
    +        q=PopLongPixel(quantum_info->endian,(unsigned int)\n+          GetPixelIndex(indexes+x),q);\n\
    \         pixel=ScaleQuantumToLong((Quantum) (QuantumRange-GetPixelOpacity(p)));\n\
    \         q=PopLongPixel(quantum_info->endian,pixel,q);\n         p++;\n@@ -2827,10\
    \ +2830,9 @@ static void ExportIndexAlphaQuantum(const Image *image,\n       range=GetQuantumRange(quantum_info->depth);\n\
    \       for (x=0; x < (ssize_t) number_pixels; x++)\n       {\n-        q=PopQuantumPixel(quantum_info,\n\
    -          GetPixelIndex(indexes+x),q);\n-        q=PopQuantumPixel(quantum_info,\n\
    -          ScaleQuantumToAny((Quantum) (GetPixelAlpha(p)),range),q);\n+      \
    \  q=PopQuantumPixel(quantum_info,GetPixelIndex(indexes+x),q);\n+        q=PopQuantumPixel(quantum_info,ScaleQuantumToAny((Quantum)\n\
    +          (GetPixelAlpha(p)),range),q);\n         p++;\n         q+=quantum_info->pad;\n\
    \       }\n@@ -3035,8 +3037,8 @@ static void ExportRedQuantum(QuantumInfo *quantum_info,\n\
    \       range=GetQuantumRange(quantum_info->depth);\n       for (x=0; x < (ssize_t)\
    \ number_pixels; x++)\n       {\n-        q=PopQuantumPixel(quantum_info,\n- \
    \         ScaleQuantumToAny(GetPixelRed(p),range),q);\n+        q=PopQuantumPixel(quantum_info,ScaleQuantumToAny(GetPixelRed(p),range),\n\
    +          q);\n         p++;\n         q+=quantum_info->pad;\n       }\n@@ -3150,7\
    \ +3152,8 @@ static void ExportRGBQuantum(QuantumInfo *quantum_info,\n       \
    \          break;\n               }\n             }\n-            q=PopShortPixel(quantum_info->endian,(unsigned\
    \ short) (pixel << 4),q);\n+            q=PopShortPixel(quantum_info->endian,(unsigned\
    \ short) (pixel << 4),\n+              q);\n             switch ((x+1) % 3)\n\
    \             {\n               default:\n@@ -3171,7 +3174,8 @@ static void ExportRGBQuantum(QuantumInfo\
    \ *quantum_info,\n                 break;\n               }\n             }\n\
    -            q=PopShortPixel(quantum_info->endian,(unsigned short) (pixel << 4),q);\n\
    +            q=PopShortPixel(quantum_info->endian,(unsigned short) (pixel << 4),\n\
    +              q);\n             q+=quantum_info->pad;\n           }\n       \
    \    for (bit=0; bit < (ssize_t) (3*number_pixels % 2); bit++)\n@@ -3196,7 +3200,8\
    \ @@ static void ExportRGBQuantum(QuantumInfo *quantum_info,\n               \
    \  break;\n               }\n             }\n-            q=PopShortPixel(quantum_info->endian,(unsigned\
    \ short) (pixel << 4),q);\n+            q=PopShortPixel(quantum_info->endian,(unsigned\
    \ short) (pixel << 4),\n+              q);\n             q+=quantum_info->pad;\n\
    \           }\n           if (bit != 0)"
  identifiers:
  - CVE-2021-20224
  - CWE-190
  overview: An integer overflow issue was discovered in ImageMagick's ExportIndexQuantum()
    function in MagickCore/quantum-export.c. Function calls to GetPixelIndex() could
    result in values outside the range of representable for the 'unsigned char'. When
    ImageMagick processes a crafted pdf file, this could lead to an undefined behaviour
    or a crash.
  references:
  - source: secalert@redhat.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/ImageMagick/ImageMagick/commit/5af1dffa4b6ab984b5f13d1e91c95760d75f12a6
  - source: secalert@redhat.com
    tags:
    - Issue Tracking
    - Patch
    - Third Party Advisory
    url: https://github.com/ImageMagick/ImageMagick/pull/3083
  - source: secalert@redhat.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/ImageMagick/ImageMagick6/commit/553054c1cb1e4e05ec86237afef76a32cd7c464d
  - source: secalert@redhat.com
    url: https://lists.debian.org/debian-lts-announce/2023/03/msg00008.html
  title: An integer overflow issue was discovered in ImageMagick's ExportIndexQuantum()
    function in MagickCore/quantum-export.c. Function calls to GetPixelIndex() could
    result in values outside the range of representable for the 'unsigned char'. When
    ImageMagick processes a crafted pdf file, this could lead to an undefined behaviour
    or a crash.
- diff_content:
  - "--- a/lib/fsm.c\n+++ b/lib/fsm.c\n@@ -990,6 +990,14 @@ int rpmPackageFilesInstall(rpmts\
    \ ts, rpmte te, rpmfiles files,\n                     rc = RPMERR_UNKNOWN_FILETYPE;\n\
    \             }\n \n+\t    if (!rc && fd == -1 && !S_ISLNK(fp->sb.st_mode)) {\n\
    +\t\t/* Only follow safe symlinks, and never on temporary files */\n+\t\tfd =\
    \ fsmOpenat(di.dirfd, fp->fpath,\n+\t\t\t\tfp->suffix ? AT_SYMLINK_NOFOLLOW :\
    \ 0);\n+\t\tif (fd < 0)\n+\t\t    rc = RPMERR_OPEN_FAILED;\n+\t    }\n+\n setmeta:\n\
    \ \t    if (!rc && fp->setmeta) {\n \t\trc = fsmSetmeta(fd, di.dirfd, fp->fpath,"
  identifiers:
  - CVE-2021-35938
  - CWE-59
  overview: A symbolic link issue was found in rpm. It occurs when rpm sets the desired
    permissions and credentials after installing a file. A local unprivileged user
    could use this flaw to exchange the original file with a symbolic link to a security-critical
    file and escalate their privileges on the system. The highest threat from this
    vulnerability is to data confidentiality and integrity as well as system availability.
  references:
  - source: secalert@redhat.com
    tags:
    - Vendor Advisory
    url: https://access.redhat.com/security/cve/CVE-2021-35938
  - source: secalert@redhat.com
    tags:
    - Issue Tracking
    - Vendor Advisory
    url: https://bugzilla.redhat.com/show_bug.cgi?id=1964114
  - source: secalert@redhat.com
    tags:
    - Exploit
    - Issue Tracking
    - Third Party Advisory
    url: https://bugzilla.suse.com/show_bug.cgi?id=1157880
  - source: secalert@redhat.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/rpm-software-management/rpm/commit/25a435e90844ea98fe5eb7bef22c1aecf3a9c033
  - source: secalert@redhat.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/rpm-software-management/rpm/pull/1919
  - source: secalert@redhat.com
    tags:
    - Release Notes
    url: https://rpm.org/wiki/Releases/4.18.0
  - source: secalert@redhat.com
    tags:
    - Third Party Advisory
    url: https://security.gentoo.org/glsa/202210-22
  title: A symbolic link issue was found in rpm. It occurs when rpm sets the desired
    permissions and credentials after installing a file. A local unprivileged user
    could use this flaw to exchange the original file with a symbolic link to a security-critical
    file and escalate their privileges on the system. The highest threat from this
    vulnerability is to data confidentiality and integrity as well as system availability.
- diff_content:
  - "--- a/hw/nvme/ctrl.c\n+++ b/hw/nvme/ctrl.c\n@@ -357,6 +357,24 @@ static inline\
    \ void *nvme_addr_to_pmr(NvmeCtrl *n, hwaddr addr)\n     return memory_region_get_ram_ptr(&n->pmr.dev->mr)\
    \ + (addr - n->pmr.cba);\n }\n \n+static inline bool nvme_addr_is_iomem(NvmeCtrl\
    \ *n, hwaddr addr)\n+{\n+    hwaddr hi, lo;\n+\n+    /*\n+     * The purpose of\
    \ this check is to guard against invalid \"local\" access to\n+     * the iomem\
    \ (i.e. controller registers). Thus, we check against the range\n+     * covered\
    \ by the 'bar0' MemoryRegion since that is currently composed of\n+     * two\
    \ subregions (the NVMe \"MBAR\" and the MSI-X table/pba). Note, however,\n+  \
    \   * that if the device model is ever changed to allow the CMB to be located\n\
    +     * in BAR0 as well, then this must be changed.\n+     */\n+    lo = n->bar0.addr;\n\
    +    hi = lo + int128_get64(n->bar0.size);\n+\n+    return addr >= lo && addr\
    \ < hi;\n+}\n+\n static int nvme_addr_read(NvmeCtrl *n, hwaddr addr, void *buf,\
    \ int size)\n {\n     hwaddr hi = addr + size - 1;\n@@ -614,6 +632,10 @@ static\
    \ uint16_t nvme_map_addr(NvmeCtrl *n, NvmeSg *sg, hwaddr addr, size_t len)\n \n\
    \     trace_pci_nvme_map_addr(addr, len);\n \n+    if (nvme_addr_is_iomem(n, addr))\
    \ {\n+        return NVME_DATA_TRAS_ERROR;\n+    }\n+\n     if (nvme_addr_is_cmb(n,\
    \ addr)) {\n         cmb = true;\n     } else if (nvme_addr_is_pmr(n, addr)) {\n"
  identifiers:
  - CVE-2021-3929
  - CWE-416
  overview: A DMA reentrancy issue was found in the NVM Express Controller (NVME)
    emulation in QEMU. This CVE is similar to CVE-2021-3750 and, just like it, when
    the reentrancy write triggers the reset function nvme_ctrl_reset(), data structs
    will be freed leading to a use-after-free issue. A malicious guest could use this
    flaw to crash the QEMU process on the host, resulting in a denial of service condition
    or, potentially, executing arbitrary code within the context of the QEMU process
    on the host.
  references:
  - source: secalert@redhat.com
    tags:
    - Third Party Advisory
    url: https://access.redhat.com/security/cve/CVE-2021-3929
  - source: secalert@redhat.com
    tags:
    - Issue Tracking
    - Patch
    - Third Party Advisory
    url: https://bugzilla.redhat.com/show_bug.cgi?id=2020298
  - source: secalert@redhat.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://gitlab.com/qemu-project/qemu/-/commit/736b01642d85be832385
  - source: secalert@redhat.com
    tags:
    - Issue Tracking
    - Third Party Advisory
    url: https://gitlab.com/qemu-project/qemu/-/issues/556
  - source: secalert@redhat.com
    tags:
    - Exploit
    - Issue Tracking
    - Patch
    - Third Party Advisory
    url: https://gitlab.com/qemu-project/qemu/-/issues/782
  - source: secalert@redhat.com
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/XHNN7QJCEQH7AQG5AQP2GEFAQE6K635I/
  title: A DMA reentrancy issue was found in the NVM Express Controller (NVME) emulation
    in QEMU. This CVE is similar to CVE-2021-3750 and, just like it, when the reentrancy
    write triggers the reset function nvme_ctrl_reset(), data structs will be freed
    leading to a use-after-free issue. A malicious guest could use this flaw to crash
    the QEMU process on the host, resulting in a denial of service condition or, potentially,
    executing arbitrary code within the context of the QEMU process on the host.
- diff_content:
  - "--- a/src/mouse.c\n+++ b/src/mouse.c\n@@ -471,74 +471,77 @@ do_mouse(\n \n  \
    \   start_visual.lnum = 0;\n \n-    // Check for clicking in the tab page line.\n\
    -    if (mouse_row == 0 && firstwin->w_winrow > 0)\n+    if (TabPageIdxs != NULL)\
    \  // only when initialized\n     {\n-\tif (is_drag)\n+\t// Check for clicking\
    \ in the tab page line.\n+\tif (mouse_row == 0 && firstwin->w_winrow > 0)\n \t\
    {\n-\t    if (in_tab_line)\n+\t    if (is_drag)\n \t    {\n-\t\tc1 = TabPageIdxs[mouse_col];\n\
    -\t\ttabpage_move(c1 <= 0 ? 9999 : c1 < tabpage_index(curtab)\n-\t\t\t\t\t\t\t\
    \t? c1 - 1 : c1);\n+\t\tif (in_tab_line)\n+\t\t{\n+\t\t    c1 = TabPageIdxs[mouse_col];\n\
    +\t\t    tabpage_move(c1 <= 0 ? 9999 : c1 < tabpage_index(curtab)\n+\t\t\t\t\t\
    \t\t\t    ? c1 - 1 : c1);\n+\t\t}\n+\t\treturn FALSE;\n \t    }\n-\t    return\
    \ FALSE;\n-\t}\n \n-\t// click in a tab selects that tab page\n-\tif (is_click\n\
    +\t    // click in a tab selects that tab page\n+\t    if (is_click\n # ifdef\
    \ FEAT_CMDWIN\n-\t\t&& cmdwin_type == 0\n+\t\t    && cmdwin_type == 0\n # endif\n\
    -\t\t&& mouse_col < Columns)\n-\t{\n-\t    in_tab_line = TRUE;\n-\t    c1 = TabPageIdxs[mouse_col];\n\
    -\t    if (c1 >= 0)\n+\t\t    && mouse_col < Columns)\n \t    {\n-\t\tif ((mod_mask\
    \ & MOD_MASK_MULTI_CLICK) == MOD_MASK_2CLICK)\n-\t\t{\n-\t\t    // double click\
    \ opens new page\n-\t\t    end_visual_mode_keep_button();\n-\t\t    tabpage_new();\n\
    -\t\t    tabpage_move(c1 == 0 ? 9999 : c1 - 1);\n-\t\t}\n-\t\telse\n+\t\tin_tab_line\
    \ = TRUE;\n+\t\tc1 = TabPageIdxs[mouse_col];\n+\t\tif (c1 >= 0)\n \t\t{\n-\t\t\
    \    // Go to specified tab page, or next one if not clicking\n-\t\t    // on\
    \ a label.\n-\t\t    goto_tabpage(c1);\n-\n-\t\t    // It's like clicking on the\
    \ status line of a window.\n-\t\t    if (curwin != old_curwin)\n+\t\t    if ((mod_mask\
    \ & MOD_MASK_MULTI_CLICK) == MOD_MASK_2CLICK)\n+\t\t    {\n+\t\t\t// double click\
    \ opens new page\n \t\t\tend_visual_mode_keep_button();\n-\t\t}\n-\t    }\n-\t\
    \    else\n-\t    {\n-\t\ttabpage_T\t*tp;\n+\t\t\ttabpage_new();\n+\t\t\ttabpage_move(c1\
    \ == 0 ? 9999 : c1 - 1);\n+\t\t    }\n+\t\t    else\n+\t\t    {\n+\t\t\t// Go\
    \ to specified tab page, or next one if not clicking\n+\t\t\t// on a label.\n\
    +\t\t\tgoto_tabpage(c1);\n \n-\t\t// Close the current or specified tab page.\n\
    -\t\tif (c1 == -999)\n-\t\t    tp = curtab;\n+\t\t\t// It's like clicking on the\
    \ status line of a window.\n+\t\t\tif (curwin != old_curwin)\n+\t\t\t    end_visual_mode_keep_button();\n\
    +\t\t    }\n+\t\t}\n \t\telse\n-\t\t    tp = find_tabpage(-c1);\n-\t\tif (tp ==\
    \ curtab)\n \t\t{\n-\t\t    if (first_tabpage->tp_next != NULL)\n-\t\t\ttabpage_close(FALSE);\n\
    +\t\t    tabpage_T\t*tp;\n+\n+\t\t    // Close the current or specified tab page.\n\
    +\t\t    if (c1 == -999)\n+\t\t\ttp = curtab;\n+\t\t    else\n+\t\t\ttp = find_tabpage(-c1);\n\
    +\t\t    if (tp == curtab)\n+\t\t    {\n+\t\t\tif (first_tabpage->tp_next != NULL)\n\
    +\t\t\t    tabpage_close(FALSE);\n+\t\t    }\n+\t\t    else if (tp != NULL)\n\
    +\t\t\ttabpage_close_other(tp, FALSE);\n \t\t}\n-\t\telse if (tp != NULL)\n-\t\
    \t    tabpage_close_other(tp, FALSE);\n \t    }\n+\t    return TRUE;\n+\t}\n+\t\
    else if (is_drag && in_tab_line)\n+\t{\n+\t    c1 = TabPageIdxs[mouse_col];\n\
    +\t    tabpage_move(c1 <= 0 ? 9999 : c1 - 1);\n+\t    return FALSE;\n \t}\n-\t\
    return TRUE;\n-    }\n-    else if (is_drag && in_tab_line)\n-    {\n-\tc1 = TabPageIdxs[mouse_col];\n\
    -\ttabpage_move(c1 <= 0 ? 9999 : c1 - 1);\n-\treturn FALSE;\n     }\n \n     //\
    \ When 'mousemodel' is \"popup\" or \"popup_setpos\", translate mouse events:"
  - "--- a/src/version.c\n+++ b/src/version.c\n@@ -731,6 +731,8 @@ static char *(features[])\
    \ =\n \n static int included_patches[] =\n {   /* Add new patch number below this\
    \ line */\n+/**/\n+    259,\n /**/\n     258,\n /**/"
  identifiers:
  - CVE-2022-2980
  - CWE-476
  overview: NULL Pointer Dereference in GitHub repository vim/vim prior to 9.0.0259.
  references:
  - source: security@huntr.dev
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/vim/vim/commit/80525751c5ce9ed82c41d83faf9ef38667bf61b1
  - source: security@huntr.dev
    tags:
    - Exploit
    - Issue Tracking
    - Patch
    - Third Party Advisory
    url: https://huntr.dev/bounties/6e7b12a5-242c-453d-b39e-9625d563b0ea
  - source: security@huntr.dev
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/XWOJOA7PZZAMBI5GFTL6PWHXMWSDLUXL/
  - source: security@huntr.dev
    url: https://security.gentoo.org/glsa/202305-16
  title: NULL Pointer Dereference in GitHub repository vim/vim prior to 9.0.0259.
- diff_content:
  - "--- a/src/quickfix.c\n+++ b/src/quickfix.c\n@@ -4674,6 +4674,11 @@ call_qftf_func(qf_list_T\
    \ *qfl, int qf_winid, long start_idx, long end_idx)\n {\n     callback_T\t*cb\
    \ = &qftf_cb;\n     list_T\t*qftf_list = NULL;\n+    static int\trecursive = FALSE;\n\
    +\n+    if (recursive)\n+\treturn NULL;  // this doesn't work properly recursively\n\
    +    recursive = TRUE;\n \n     // If 'quickfixtextfunc' is set, then use the\
    \ user-supplied function to get\n     // the text to display. Use the local value\
    \ of 'quickfixtextfunc' if it is\n@@ -4688,7 +4693,10 @@ call_qftf_func(qf_list_T\
    \ *qfl, int qf_winid, long start_idx, long end_idx)\n \n \t// create the dict\
    \ argument\n \tif ((d = dict_alloc_lock(VAR_FIXED)) == NULL)\n+\t{\n+\t    recursive\
    \ = FALSE;\n \t    return NULL;\n+\t}\n \tdict_add_number(d, \"quickfix\", (long)IS_QF_LIST(qfl));\n\
    \ \tdict_add_number(d, \"winid\", (long)qf_winid);\n \tdict_add_number(d, \"id\"\
    , (long)qfl->qf_id);\n@@ -4711,6 +4719,7 @@ call_qftf_func(qf_list_T *qfl, int\
    \ qf_winid, long start_idx, long end_idx)\n \tdict_unref(d);\n     }\n \n+   \
    \ recursive = FALSE;\n     return qftf_list;\n }\n "
  - "--- a/src/version.c\n+++ b/src/version.c\n@@ -731,6 +731,8 @@ static char *(features[])\
    \ =\n \n static int included_patches[] =\n {   /* Add new patch number below this\
    \ line */\n+/**/\n+    260,\n /**/\n     259,\n /**/"
  identifiers:
  - CVE-2022-2982
  - CWE-416
  overview: Use After Free in GitHub repository vim/vim prior to 9.0.0260.
  references:
  - source: security@huntr.dev
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/vim/vim/commit/d6c67629ed05aae436164eec474832daf8ba7420
  - source: security@huntr.dev
    tags:
    - Exploit
    - Issue Tracking
    - Patch
    - Third Party Advisory
    url: https://huntr.dev/bounties/53f53d9a-ba8a-4985-b7ba-23efbe6833be
  - source: security@huntr.dev
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/XWOJOA7PZZAMBI5GFTL6PWHXMWSDLUXL/
  - source: security@huntr.dev
    url: https://security.gentoo.org/glsa/202305-16
  title: Use After Free in GitHub repository vim/vim prior to 9.0.0260.
- diff_content:
  - "--- a/bfd/elf.c\n+++ b/bfd/elf.c\n@@ -6886,6 +6886,66 @@ _bfd_elf_symbol_from_bfd_symbol\
    \ (bfd *abfd, asymbol **asym_ptr_ptr)\n   return idx;\n }\n \n+static inline bfd_vma\n\
    +segment_size (Elf_Internal_Phdr *segment)\n+{\n+  return (segment->p_memsz >\
    \ segment->p_filesz\n+\t  ? segment->p_memsz : segment->p_filesz);\n+}\n+\n+\n\
    +/* Returns the end address of the segment + 1.  */\n+static inline bfd_vma\n\
    +segment_end (Elf_Internal_Phdr *segment, bfd_vma start)\n+{\n+  return start\
    \ + segment_size (segment);\n+}\n+\n+static inline bfd_size_type\n+section_size\
    \ (asection *section, Elf_Internal_Phdr *segment)\n+{\n+  if ((section->flags\
    \ & SEC_HAS_CONTENTS) != 0\n+      || (section->flags & SEC_THREAD_LOCAL) == 0\n\
    +      || segment->p_type == PT_TLS)\n+    return section->size;\n+  return 0;\n\
    +}\n+\n+/* Returns TRUE if the given section is contained within the given\n+\
    \   segment.  LMA addresses are compared against PADDR when\n+   bed->want_p_paddr_set_to_zero\
    \ is false, VMA against VADDR when true.  */\n+static bool\n+is_contained_by (asection\
    \ *section, Elf_Internal_Phdr *segment,\n+\t\t bfd_vma paddr, bfd_vma vaddr, unsigned\
    \ int opb,\n+\t\t const struct elf_backend_data *bed)\n+{\n+  bfd_vma seg_addr\
    \ = !bed->want_p_paddr_set_to_zero ? paddr : vaddr;\n+  bfd_vma addr = !bed->want_p_paddr_set_to_zero\
    \ ? section->lma : section->vma;\n+  bfd_vma octet;\n+  if (_bfd_mul_overflow\
    \ (addr, opb, &octet))\n+    return false;\n+  /* The third and fourth lines below\
    \ are testing that the section end\n+     address is within the segment.  It's\
    \ written this way to avoid\n+     overflow.  Add seg_addr + section_size to both\
    \ sides of the\n+     inequality to make it obvious.  */\n+  return (octet >=\
    \ seg_addr\n+\t  && segment_size (segment) >= section_size (section, segment)\n\
    +\t  && (octet - seg_addr\n+\t      <= segment_size (segment) - section_size (section,\
    \ segment)));\n+}\n+\n+/* Handle PT_NOTE segment.  */\n+static bool\n+is_note\
    \ (Elf_Internal_Phdr *p, asection *s)\n+{\n+  return (p->p_type == PT_NOTE\n+\t\
    \  && elf_section_type (s) == SHT_NOTE\n+\t  && (ufile_ptr) s->filepos >= p->p_offset\n\
    +\t  && p->p_filesz >= s->size\n+\t  && ((ufile_ptr) s->filepos - p->p_offset\n\
    +\t      <= p->p_filesz - s->size));\n+}\n+\n /* Rewrite program header information.\
    \  */\n \n static bool\n@@ -6914,47 +6974,6 @@ rewrite_elf_program_header (bfd\
    \ *ibfd, bfd *obfd, bfd_vma maxpagesize)\n \n   num_segments = elf_elfheader (ibfd)->e_phnum;\n\
    \ \n-  /* Returns the end address of the segment + 1.  */\n-#define SEGMENT_END(segment,\
    \ start)\t\t\t\t\t\\\n-  (start + (segment->p_memsz > segment->p_filesz\t\t\t\\\
    \n-\t    ? segment->p_memsz : segment->p_filesz))\n-\n-#define SECTION_SIZE(section,\
    \ segment)\t\t\t\t\t\\\n-  (((section->flags & (SEC_HAS_CONTENTS | SEC_THREAD_LOCAL))\t\
    \t\\\n-    != SEC_THREAD_LOCAL || segment->p_type == PT_TLS)\t\t\t\\\n-   ? section->size\
    \ : 0)\n-\n-  /* Returns TRUE if the given section is contained within\n-    \
    \ the given segment.  VMA addresses are compared.  */\n-#define IS_CONTAINED_BY_VMA(section,\
    \ segment, opb)\t\t\t\\\n-  (section->vma * (opb) >= segment->p_vaddr\t\t\t\t\\\
    \n-   && (section->vma * (opb) + SECTION_SIZE (section, segment)\t\t\\\n-    \
    \   <= (SEGMENT_END (segment, segment->p_vaddr))))\n-\n-  /* Returns TRUE if the\
    \ given section is contained within\n-     the given segment.  LMA addresses are\
    \ compared.  */\n-#define IS_CONTAINED_BY_LMA(section, segment, base, opb)\t\t\
    \\\n-  (section->lma * (opb) >= base\t\t\t\t\t\t\\\n-   && (section->lma + SECTION_SIZE\
    \ (section, segment) / (opb) >= section->lma) \\\n-   && (section->lma * (opb)\
    \ + SECTION_SIZE (section, segment)\t\t\\\n-       <= SEGMENT_END (segment, base)))\n\
    -\n-  /* Handle PT_NOTE segment.  */\n-#define IS_NOTE(p, s)\t\t\t\t\t\t\t\\\n\
    -  (p->p_type == PT_NOTE\t\t\t\t\t\t\t\\\n-   && elf_section_type (s) == SHT_NOTE\t\
    \t\t\t\t\\\n-   && (bfd_vma) s->filepos >= p->p_offset\t\t\t\t\\\n-   && ((bfd_vma)\
    \ s->filepos + s->size\t\t\t\t\t\\\n-       <= p->p_offset + p->p_filesz))\n-\n\
    -  /* Special case: corefile \"NOTE\" section containing regs, prpsinfo\n-   \
    \  etc.  */\n-#define IS_COREFILE_NOTE(p, s)\t\t\t\t\t\t\\\n-  (IS_NOTE (p, s)\t\
    \t\t\t\t\t\t\\\n-   && bfd_get_format (ibfd) == bfd_core\t\t\t\t\t\\\n-   && s->vma\
    \ == 0\t\t\t\t\t\t\t\\\n-   && s->lma == 0)\n-\n   /* The complicated case when\
    \ p_vaddr is 0 is to handle the Solaris\n      linker, which generates a PT_INTERP\
    \ section with p_vaddr and\n      p_memsz set to 0.  */\n@@ -6983,19 +7002,18\
    \ @@ rewrite_elf_program_header (bfd *ibfd, bfd *obfd, bfd_vma maxpagesize)\n\
    \        8. PT_DYNAMIC should not contain empty sections at the beginning\n \t\
    \  (with the possible exception of .dynamic).  */\n #define IS_SECTION_IN_INPUT_SEGMENT(section,\
    \ segment, bed, opb)\t\t\\\n-  ((((segment->p_paddr\t\t\t\t\t\t\t\\\n-      ?\
    \ IS_CONTAINED_BY_LMA (section, segment, segment->p_paddr, opb)\t\\\n-      :\
    \ IS_CONTAINED_BY_VMA (section, segment, opb))\t\t\t\\\n+  (((is_contained_by\
    \ (section, segment, segment->p_paddr,\t\t\\\n+\t\t      segment->p_vaddr, opb,\
    \ bed)\t\t\t\\\n      && (section->flags & SEC_ALLOC) != 0)\t\t\t\t\\\n-    ||\
    \ IS_NOTE (segment, section))\t\t\t\t\t\\\n+    || is_note (segment, section))\t\
    \t\t\t\t\\\n    && segment->p_type != PT_GNU_STACK\t\t\t\t\t\\\n    && (segment->p_type\
    \ != PT_TLS\t\t\t\t\t\\\n        || (section->flags & SEC_THREAD_LOCAL))\t\t\t\
    \t\\\n    && (segment->p_type == PT_LOAD\t\t\t\t\t\\\n        || segment->p_type\
    \ == PT_TLS\t\t\t\t\t\\\n        || (section->flags & SEC_THREAD_LOCAL) == 0)\t\
    \t\t\\\n    && (segment->p_type != PT_DYNAMIC\t\t\t\t\t\\\n-       || SECTION_SIZE\
    \ (section, segment) > 0\t\t\t\t\\\n+       || section_size (section, segment)\
    \ > 0\t\t\t\t\\\n        || (segment->p_paddr\t\t\t\t\t\t\\\n \t   ? segment->p_paddr\
    \ != section->lma * (opb)\t\t\t\\\n \t   : segment->p_vaddr != section->vma *\
    \ (opb))\t\t\t\\\n@@ -7010,7 +7028,7 @@ rewrite_elf_program_header (bfd *ibfd,\
    \ bfd *obfd, bfd_vma maxpagesize)\n \n   /* Returns TRUE iff seg1 starts after\
    \ the end of seg2.  */\n #define SEGMENT_AFTER_SEGMENT(seg1, seg2, field)\t\t\t\
    \\\n-  (seg1->field >= SEGMENT_END (seg2, seg2->field))\n+  (seg1->field >= segment_end\
    \ (seg2, seg2->field))\n \n   /* Returns TRUE iff seg1 and seg2 overlap. Segments\
    \ overlap iff both\n      their VMA address ranges and their LMA address ranges\
    \ overlap.\n@@ -7090,8 +7108,8 @@ rewrite_elf_program_header (bfd *ibfd, bfd *obfd,\
    \ bfd_vma maxpagesize)\n \t    {\n \t      /* Extend SEGMENT2 to include SEGMENT\
    \ and then delete\n \t\t SEGMENT.  */\n-\t      extra_length = (SEGMENT_END (segment,\
    \ segment->p_vaddr)\n-\t\t\t      - SEGMENT_END (segment2, segment2->p_vaddr));\n\
    +\t      extra_length = (segment_end (segment, segment->p_vaddr)\n+\t\t\t    \
    \  - segment_end (segment2, segment2->p_vaddr));\n \n \t      if (extra_length\
    \ > 0)\n \t\t{\n@@ -7110,8 +7128,8 @@ rewrite_elf_program_header (bfd *ibfd, bfd\
    \ *obfd, bfd_vma maxpagesize)\n \t    {\n \t      /* Extend SEGMENT to include\
    \ SEGMENT2 and then delete\n \t\t SEGMENT2.  */\n-\t      extra_length = (SEGMENT_END\
    \ (segment2, segment2->p_vaddr)\n-\t\t\t      - SEGMENT_END (segment, segment->p_vaddr));\n\
    +\t      extra_length = (segment_end (segment2, segment2->p_vaddr)\n+\t\t\t  \
    \    - segment_end (segment, segment->p_vaddr));\n \n \t      if (extra_length\
    \ > 0)\n \t\t{\n@@ -7311,11 +7329,9 @@ rewrite_elf_program_header (bfd *ibfd,\
    \ bfd *obfd, bfd_vma maxpagesize)\n \n \t      /* Match up the physical address\
    \ of the segment with the\n \t\t LMA address of the output section.  */\n-\t \
    \     if (IS_CONTAINED_BY_LMA (output_section, segment, map->p_paddr,\n-\t\t\t\
    \t       opb)\n-\t\t  || IS_COREFILE_NOTE (segment, section)\n-\t\t  || (bed->want_p_paddr_set_to_zero\n\
    -\t\t      && IS_CONTAINED_BY_VMA (output_section, segment, opb)))\n+\t      if\
    \ (is_contained_by (output_section, segment, map->p_paddr,\n+\t\t\t\t   map->p_paddr\
    \ + map->p_vaddr_offset, opb, bed)\n+\t\t  || is_note (segment, section))\n \t\
    \t{\n \t\t  if (matching_lma == NULL\n \t\t      || output_section->lma < matching_lma->lma)\n\
    @@ -7431,9 +7447,9 @@ rewrite_elf_program_header (bfd *ibfd, bfd *obfd, bfd_vma\
    \ maxpagesize)\n \n \t      BFD_ASSERT (output_section != NULL);\n \n-\t     \
    \ if (IS_CONTAINED_BY_LMA (output_section, segment, map->p_paddr,\n-\t\t\t\t \
    \      opb)\n-\t\t  || IS_COREFILE_NOTE (segment, section))\n+\t      if (is_contained_by\
    \ (output_section, segment, map->p_paddr,\n+\t\t\t\t   map->p_paddr + map->p_vaddr_offset,\
    \ opb, bed)\n+\t\t  || is_note (segment, section))\n \t\t{\n \t\t  if (map->count\
    \ == 0)\n \t\t    {\n@@ -7556,12 +7572,6 @@ rewrite_elf_program_header (bfd *ibfd,\
    \ bfd *obfd, bfd_vma maxpagesize)\n \t  }\n     }\n \n-#undef SEGMENT_END\n-#undef\
    \ SECTION_SIZE\n-#undef IS_CONTAINED_BY_VMA\n-#undef IS_CONTAINED_BY_LMA\n-#undef\
    \ IS_NOTE\n-#undef IS_COREFILE_NOTE\n #undef IS_SOLARIS_PT_INTERP\n #undef IS_SECTION_IN_INPUT_SEGMENT\n\
    \ #undef INCLUDE_SECTION_IN_SEGMENT"
  identifiers:
  - CVE-2022-38533
  - CWE-787
  overview: In GNU Binutils before 2.40, there is a heap-buffer-overflow in the error
    function bfd_getl32 when called from the strip_main function in strip-new via
    a crafted file.
  references:
  - source: cve@mitre.org
    url: https://github.com/bminor/binutils-gdb/commit/45d92439aebd0386ef8af76e1796d08cfe457e1d
  - source: cve@mitre.org
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/6AKZ2DTS3ATVN5PANNVLKLE5OP4OF25Q/
  - source: cve@mitre.org
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/7MTEHT3G6YKJ7F7MSGWYSI4UM3XBAYXZ/
  - source: cve@mitre.org
    url: https://security.gentoo.org/glsa/202309-15
  - source: cve@mitre.org
    tags:
    - Third Party Advisory
    url: https://security.netapp.com/advisory/ntap-20221104-0007/
  - source: cve@mitre.org
    tags:
    - Issue Tracking
    - Patch
    - Third Party Advisory
    url: https://sourceware.org/bugzilla/show_bug.cgi?id=29482
  - source: cve@mitre.org
    tags:
    - Issue Tracking
    - Patch
    - Third Party Advisory
    url: https://sourceware.org/bugzilla/show_bug.cgi?id=29482#c2
  - source: cve@mitre.org
    url: https://sourceware.org/bugzilla/show_bug.cgi?id=29495
  - source: cve@mitre.org
    url: https://sourceware.org/git/gitweb.cgi?p=binutils-gdb.git%3Bh=45d92439aebd0386ef8af76e1796d08cfe457e1d
  title: In GNU Binutils before 2.40, there is a heap-buffer-overflow in the error
    function bfd_getl32 when called from the strip_main function in strip-new via
    a crafted file.
- diff_content:
  - "--- a/lib/fsm.c\n+++ b/lib/fsm.c\n@@ -8,6 +8,7 @@\n #include <inttypes.h>\n #include\
    \ <utime.h>\n #include <errno.h>\n+#include <fcntl.h>\n #if WITH_CAP\n #include\
    \ <sys/capability.h>\n #endif\n@@ -20,6 +21,7 @@\n #include \"rpmio/rpmio_internal.h\"\
    \t/* fdInit/FiniDigest */\n #include \"lib/fsm.h\"\n #include \"lib/rpmte_internal.h\"\
    \t/* XXX rpmfs */\n+#include \"lib/rpmfi_internal.h\" /* rpmfiSetOnChdir */\n\
    \ #include \"lib/rpmplugins.h\"\t/* rpm plugins hooks */\n #include \"lib/rpmug.h\"\
    \n \n@@ -406,17 +408,118 @@ static int fsmRmdir(const char *path)\n     return\
    \ rc;\n }\n \n-static int fsmMkdir(const char *path, mode_t mode)\n+static int\
    \ fsmMkdir(int dirfd, const char *path, mode_t mode)\n {\n-    int rc = mkdir(path,\
    \ (mode & 07777));\n+    int rc = mkdirat(dirfd, path, (mode & 07777));\n    \
    \ if (_fsm_debug)\n-\trpmlog(RPMLOG_DEBUG, \" %8s (%s, 0%04o) %s\\n\", __func__,\n\
    -\t       path, (unsigned)(mode & 07777),\n+\trpmlog(RPMLOG_DEBUG, \" %8s (%d\
    \ %s, 0%04o) %s\\n\", __func__,\n+\t       dirfd, path, (unsigned)(mode & 07777),\n\
    \ \t       (rc < 0 ? strerror(errno) : \"\"));\n     if (rc < 0)\trc = RPMERR_MKDIR_FAILED;\n\
    \     return rc;\n }\n \n+static int fsmOpenat(int dirfd, const char *path, int\
    \ flags)\n+{\n+    struct stat lsb, sb;\n+    int sflags = flags | O_NOFOLLOW;\n\
    +    int fd = openat(dirfd, path, sflags);\n+\n+    /*\n+     * Only ever follow\
    \ symlinks by root or target owner. Since we can't\n+     * open the symlink itself,\
    \ the order matters: we stat the link *after*\n+     * opening the target, and\
    \ if the link ownership changed between the calls\n+     * it could've only been\
    \ the link owner or root.\n+     */\n+    if (fd < 0 && errno == ELOOP && flags\
    \ != sflags) {\n+\tint ffd = openat(dirfd, path, flags);\n+\tif (ffd >= 0 && fstatat(dirfd,\
    \ path, &lsb, AT_SYMLINK_NOFOLLOW) == 0) {\n+\t    if (fstat(ffd, &sb) == 0) {\n\
    +\t\tif (lsb.st_uid == 0 || lsb.st_uid == sb.st_uid) {\n+\t\t    fd = ffd;\n+\t\
    \t} else {\n+\t\t    close(ffd);\n+\t\t}\n+\t    }\n+\t}\n+    }\n+    return\
    \ fd;\n+}\n+\n+static int fsmDoMkDir(rpmPlugins plugins, int dirfd, const char\
    \ *dn,\n+\t\t\tint owned, mode_t mode)\n+{\n+    int rc;\n+    rpmFsmOp op = (FA_CREATE);\n\
    +    if (!owned)\n+\top |= FAF_UNOWNED;\n+\n+    /* Run fsm file pre hook for\
    \ all plugins */\n+    rc = rpmpluginsCallFsmFilePre(plugins, NULL, dn, mode,\
    \ op);\n+\n+    if (!rc)\n+\trc = fsmMkdir(dirfd, dn, mode);\n+\n+    if (!rc)\
    \ {\n+\trc = rpmpluginsCallFsmFilePrepare(plugins, NULL, dn, dn, mode, op);\n\
    +    }\n+\n+    /* Run fsm file post hook for all plugins */\n+    rpmpluginsCallFsmFilePost(plugins,\
    \ NULL, dn, mode, op, rc);\n+\n+    if (!rc) {\n+\trpmlog(RPMLOG_DEBUG,\n+\t\t\
    \"%s directory created with perms %04o\\n\",\n+\t\tdn, (unsigned)(mode & 07777));\n\
    +    }\n+\n+    return rc;\n+}\n+\n+static int ensureDir(rpmPlugins plugins, const\
    \ char *p, int owned, int create)\n+{\n+    char *path = xstrdup(p);\n+    char\
    \ *dp = path;\n+    char *sp = NULL, *bn;\n+    int oflags = O_RDONLY;\n+\n+ \
    \   int dirfd = fsmOpenat(-1, \"/\", oflags);\n+    int fd = dirfd; /* special\
    \ case of \"/\" */\n+\n+    while ((bn = strtok_r(dp, \"/\", &sp)) != NULL) {\n\
    +\tstruct stat sb;\n+\tfd = fsmOpenat(dirfd, bn, oflags);\n+\n+\tif (fd < 0 &&\
    \ errno == ENOENT && create) {\n+\t    mode_t mode = S_IFDIR | (_dirPerms & 07777);\n\
    +\t    if (fsmDoMkDir(plugins, dirfd, bn, owned, mode) == 0) {\n+\t\tfd = fsmOpenat(dirfd,\
    \ bn, oflags|O_NOFOLLOW);\n+\t    }\n+\t}\n+\n+\tif (fd >= 0 && fstat(fd, &sb)\
    \ == 0 && !S_ISDIR(sb.st_mode)) {\n+\t    close(fd);\n+\t    errno = ENOTDIR;\n\
    +\t    fd = -1;\n+\t}\n+\n+\tclose(dirfd);\n+\tif (fd >= 0) {\n+\t    dirfd =\
    \ fd;\n+\t} else {\n+\t    dirfd = -1;\n+\t    rpmlog(RPMLOG_ERR, _(\"failed to\
    \ open dir %s of %s: %s\\n\"),\n+\t\t\t\tbn, p, strerror(errno));\n+\t    break;\n\
    +\t}\n+\n+\tdp = NULL;\n+    }\n+\n+    free(path);\n+    return dirfd;\n+}\n\
    +\n static int fsmMkfifo(const char *path, mode_t mode)\n {\n     int rc = mkfifo(path,\
    \ (mode & 07777));\n@@ -507,7 +610,7 @@ static int fsmMkdirs(rpmfiles files, rpmfs\
    \ fs, rpmPlugins plugins)\n \t\trc = rpmpluginsCallFsmFilePre(plugins, NULL, dn,\
    \ mode, op);\n \n \t\tif (!rc)\n-\t\t    rc = fsmMkdir(dn, mode);\n+\t\t    rc\
    \ = fsmMkdir(-1, dn, mode);\n \n \t\tif (!rc) {\n \t\t    rc = rpmpluginsCallFsmFilePrepare(plugins,\
    \ NULL, dn, dn,\n@@ -874,6 +977,21 @@ static void setFileState(rpmfs fs, int i)\n\
    \     }\n }\n \n+struct diriter_s {\n+    int dirfd;\n+};\n+\n+static int onChdir(rpmfi\
    \ fi, void *data)\n+{\n+    struct diriter_s *di = data;\n+\n+    if (di->dirfd\
    \ >= 0) {\n+\tclose(di->dirfd);\n+\tdi->dirfd = -1;\n+    }\n+    return 0;\n\
    +}\n+\n int rpmPackageFilesInstall(rpmts ts, rpmte te, rpmfiles files,\n     \
    \          rpmpsm psm, char ** failedFile)\n {\n@@ -890,6 +1008,7 @@ int rpmPackageFilesInstall(rpmts\
    \ ts, rpmte te, rpmfiles files,\n     char *tid = NULL;\n     struct filedata_s\
    \ *fdata = xcalloc(fc, sizeof(*fdata));\n     struct filedata_s *firstlink = NULL;\n\
    +    struct diriter_s di = { -1 };\n \n     /* transaction id used for temporary\
    \ path suffix while installing */\n     rasprintf(&tid, \";%08x\", (unsigned)rpmtsGetTid(ts));\n\
    @@ -932,6 +1051,7 @@ int rpmPackageFilesInstall(rpmts ts, rpmte te, rpmfiles files,\n\
    \         rc = RPMERR_BAD_MAGIC;\n         goto exit;\n     }\n+    rpmfiSetOnChdir(fi,\
    \ onChdir, &di);\n \n     /* Detect and create directories not explicitly in package.\
    \ */\n     if (!rc)\n@@ -946,6 +1066,16 @@ int rpmPackageFilesInstall(rpmts ts,\
    \ rpmte te, rpmfiles files,\n \t    if (!fp->suffix) {\n \t\trc = fsmBackup(fi,\
    \ fp->action);\n \t    }\n+\n+\t    if (di.dirfd == -1) {\n+\t\tdi.dirfd = ensureDir(plugins,\
    \ rpmfiDN(fi), 0,\n+\t\t\t\t    (fp->action == FA_CREATE));\n+\t\tif (di.dirfd\
    \ == -1) {\n+\t\t    rc = RPMERR_OPEN_FAILED;\n+\t\t    break;\n+\t\t}\n+\t  \
    \  }\n+\n \t    /* Assume file does't exist when tmp suffix is in use */\n \t\
    \    if (!fp->suffix) {\n \t\tif (fp->action == FA_TOUCH) {\n@@ -980,7 +1110,7\
    \ @@ int rpmPackageFilesInstall(rpmts ts, rpmte te, rpmfiles files,\n        \
    \             mode_t mode = fp->sb.st_mode;\n                     mode &= ~07777;\n\
    \                     mode |=  00700;\n-                    rc = fsmMkdir(fp->fpath,\
    \ mode);\n+                    rc = fsmMkdir(di.dirfd, fp->fpath, mode);\n   \
    \              }\n             } else if (S_ISLNK(fp->sb.st_mode)) {\n \t\tif\
    \ (rc == RPMERR_ENOENT) {\n@@ -1022,6 +1152,8 @@ int rpmPackageFilesInstall(rpmts\
    \ ts, rpmte te, rpmfiles files,\n \tfp->stage = FILE_UNPACK;\n     }\n     fi\
    \ = rpmfiFree(fi);\n+    close(di.dirfd);\n+    di.dirfd = -1;\n \n     if (!rc\
    \ && fx < 0 && fx != RPMERR_ITER_END)\n \trc = fx;"
  identifiers:
  - CVE-2021-35939
  - CWE-59
  overview: 'It was found that the fix for CVE-2017-7500 and CVE-2017-7501 was incomplete:
    the check was only implemented for the parent directory of the file to be created.
    A local unprivileged user who owns another ancestor directory could potentially
    use this flaw to gain root privileges. The highest threat from this vulnerability
    is to data confidentiality and integrity as well as system availability.'
  references:
  - source: secalert@redhat.com
    tags:
    - Third Party Advisory
    url: https://access.redhat.com/security/cve/CVE-2021-35939
  - source: secalert@redhat.com
    tags:
    - Exploit
    - Issue Tracking
    - Third Party Advisory
    url: https://bugzilla.redhat.com/show_bug.cgi?id=1964129
  - source: secalert@redhat.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/rpm-software-management/rpm/commit/96ec957e281220f8e137a2d5eb23b83a6377d556
  - source: secalert@redhat.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/rpm-software-management/rpm/pull/1919
  - source: secalert@redhat.com
    tags:
    - Release Notes
    - Vendor Advisory
    url: https://rpm.org/wiki/Releases/4.18.0
  - source: secalert@redhat.com
    tags:
    - Third Party Advisory
    url: https://security.gentoo.org/glsa/202210-22
  title: 'It was found that the fix for CVE-2017-7500 and CVE-2017-7501 was incomplete:
    the check was only implemented for the parent directory of the file to be created.
    A local unprivileged user who owns another ancestor directory could potentially
    use this flaw to gain root privileges. The highest threat from this vulnerability
    is to data confidentiality and integrity as well as system availability.'
- diff_content:
  - "--- a/coders/tiff.c\n+++ b/coders/tiff.c\n@@ -1360,6 +1360,11 @@ static Image\
    \ *ReadTIFFImage(const ImageInfo *image_info,\n         TIFFClose(tiff);\n   \
    \      ThrowReaderException(CorruptImageError,\"UnsupportedBitsPerPixel\");\n\
    \       }\n+    if (samples_per_pixel > MaxPixelChannels)\n+      {\n+       \
    \ TIFFClose(tiff);\n+        ThrowReaderException(CorruptImageError,\"MaximumChannelsExceeded\"\
    );\n+      }\n     if (sample_format == SAMPLEFORMAT_IEEEFP)\n       (void) SetImageProperty(image,\"\
    quantum:format\",\"floating-point\",\n         exception);\n@@ -1728,11 +1733,6\
    \ @@ static Image *ReadTIFFImage(const ImageInfo *image_info,\n       }\n    \
    \ if (image->alpha_trait != UndefinedPixelTrait)\n       (void) SetImageAlphaChannel(image,OpaqueAlphaChannel,exception);\n\
    -    if (samples_per_pixel > MaxPixelChannels)\n-      {\n-        TIFFClose(tiff);\n\
    -        ThrowReaderException(CorruptImageError,\"MaximumChannelsExceeded\");\n\
    -      }\n     method=ReadGenericMethod;\n     rows_per_strip=(uint32) image->rows;\n\
    \     if (TIFFGetField(tiff,TIFFTAG_ROWSPERSTRIP,&rows_per_strip) == 1)"
  - "--- a/coders/tiff.c\n+++ b/coders/tiff.c\n@@ -1245,6 +1245,11 @@ static Image\
    \ *ReadTIFFImage(const ImageInfo *image_info,\n         TIFFClose(tiff);\n   \
    \      ThrowReaderException(CorruptImageError,\"UnsupportedBitsPerPixel\");\n\
    \       }\n+    if (samples_per_pixel > MaxPixelChannels)\n+      {\n+       \
    \ TIFFClose(tiff);\n+        ThrowReaderException(CorruptImageError,\"MaximumChannelsExceeded\"\
    );\n+      }\n     if (sample_format == SAMPLEFORMAT_IEEEFP)\n       (void) SetImageProperty(image,\"\
    quantum:format\",\"floating-point\");\n     switch (photometric)\n@@ -1617,11\
    \ +1622,6 @@ static Image *ReadTIFFImage(const ImageInfo *image_info,\n      \
    \ }\n     if (image->matte != MagickFalse)\n       (void) SetImageAlphaChannel(image,OpaqueAlphaChannel);\n\
    -    if (samples_per_pixel > MaxPixelChannels)\n-      {\n-        TIFFClose(tiff);\n\
    -        ThrowReaderException(CorruptImageError,\"MaximumChannelsExceeded\");\n\
    -      }\n     method=ReadGenericMethod;\n     rows_per_strip=(uint32) image->rows;\n\
    \     if (TIFFGetField(tiff,TIFFTAG_ROWSPERSTRIP,&rows_per_strip) == 1)"
  identifiers:
  - CVE-2021-3574
  - CWE-401
  overview: A vulnerability was found in ImageMagick-7.0.11-5, where executing a crafted
    file with the convert command, ASAN detects memory leaks.
  references:
  - source: secalert@redhat.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/ImageMagick/ImageMagick/commit/c6ad94fbb7b280f39c2fbbdc1c140e51b1b466e9
  - source: secalert@redhat.com
    tags:
    - Exploit
    - Issue Tracking
    - Third Party Advisory
    url: https://github.com/ImageMagick/ImageMagick/issues/3540
  - source: secalert@redhat.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/ImageMagick/ImageMagick6/commit/cd7f9fb7751b0d59d5a74b12d971155caad5a792
  - source: secalert@redhat.com
    url: https://lists.debian.org/debian-lts-announce/2023/03/msg00008.html
  - source: secalert@redhat.com
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/4Q6MJAMGHGB552KSFTQKXEKJVQNM4MCT/
  - source: secalert@redhat.com
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/5C6XAGUFPUF4SNVCI2T4OJK3EFIENBGP/
  - source: secalert@redhat.com
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/LNVDNM4ZEIYPT3SLZHPYN7OG4CZLEXZJ/
  title: A vulnerability was found in ImageMagick-7.0.11-5, where executing a crafted
    file with the convert command, ASAN detects memory leaks.
- diff_content:
  - "--- a/source/tools/muraster.c\n+++ b/source/tools/muraster.c\n@@ -1003,8 +1003,9\
    \ @@ initialise_banding(fz_context *ctx, render_details *render, int color)\n\
    \ \n \tw = render->ibounds.x1 - render->ibounds.x0;\n \tmin_band_mem = (size_t)bpp\
    \ * w * min_band_height;\n-\treps = (int)(max_band_memory / min_band_mem);\n-\t\
    if (reps < 1)\n+\tif (min_band_mem > 0)\n+\t\treps = (int)(max_band_memory / min_band_mem);\n\
    +\tif (min_band_mem == 0 || reps < 1)\n \t\treps = 1;\n \n \t/* Adjust reps to\
    \ even out the work between threads */"
  identifiers:
  - CVE-2021-4216
  - CWE-369
  overview: A Floating point exception (division-by-zero) flaw was found in Mupdf
    for zero width pages in muraster.c. It is fixed in Mupdf-1.20.0-rc1 upstream.
  references:
  - source: secalert@redhat.com
    tags:
    - Permissions Required
    url: https://bugs.ghostscript.com/show_bug.cgi?id=704834
  - source: secalert@redhat.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/ArtifexSoftware/mupdf/commit/22c47acbd52949421f8c7cb46ea1556827d0fcbf
  title: A Floating point exception (division-by-zero) flaw was found in Mupdf for
    zero width pages in muraster.c. It is fixed in Mupdf-1.20.0-rc1 upstream.
- diff_content:
  - "--- a/hw/scsi/lsi53c895a.c\n+++ b/hw/scsi/lsi53c895a.c\n@@ -1030,7 +1030,7 @@\
    \ static void lsi_do_msgout(LSIState *s)\n             trace_lsi_do_msgout_abort(current_tag);\n\
    \             if (current_req && current_req->req) {\n                 scsi_req_cancel(current_req->req);\n\
    -                current_req->req = NULL;\n+                current_req = NULL;\n\
    \             }\n             lsi_disconnect(s);\n             break;\n@@ -1056,6\
    \ +1056,7 @@ static void lsi_do_msgout(LSIState *s)\n             /* clear the\
    \ current I/O process */\n             if (s->current) {\n                 scsi_req_cancel(s->current->req);\n\
    +                current_req = NULL;\n             }\n \n             /* As the\
    \ current implemented devices scsi_disk and scsi_generic\n"
  - "--- a/tests/qtest/fuzz-lsi53c895a-test.c\n+++ b/tests/qtest/fuzz-lsi53c895a-test.c\n\
    @@ -8,6 +8,79 @@\n #include \"qemu/osdep.h\"\n #include \"libqtest.h\"\n \n+/*\n\
    + * This used to trigger a UAF in lsi_do_msgout()\n+ * https://gitlab.com/qemu-project/qemu/-/issues/972\n\
    + */\n+static void test_lsi_do_msgout_cancel_req(void)\n+{\n+    QTestState *s;\n\
    +\n+    if (sizeof(void *) == 4) {\n+        g_test_skip(\"memory size too big\
    \ for 32-bit build\");\n+        return;\n+    }\n+\n+    s = qtest_init(\"-M\
    \ q35 -m 4G -display none -nodefaults \"\n+                   \"-device lsi53c895a,id=scsi\
    \ \"\n+                   \"-device scsi-hd,drive=disk0 \"\n+                \
    \   \"-drive file=null-co://,id=disk0,if=none,format=raw\");\n+\n+    qtest_outl(s,\
    \ 0xcf8, 0x80000810);\n+    qtest_outl(s, 0xcf8, 0xc000);\n+    qtest_outl(s,\
    \ 0xcf8, 0x80000810);\n+    qtest_outw(s, 0xcfc, 0x7);\n+    qtest_outl(s, 0xcf8,\
    \ 0x80000810);\n+    qtest_outl(s, 0xcfc, 0xc000);\n+    qtest_outl(s, 0xcf8,\
    \ 0x80000804);\n+    qtest_outw(s, 0xcfc, 0x05);\n+    qtest_writeb(s, 0x69736c10,\
    \ 0x08);\n+    qtest_writeb(s, 0x69736c13, 0x58);\n+    qtest_writeb(s, 0x69736c1a,\
    \ 0x01);\n+    qtest_writeb(s, 0x69736c1b, 0x06);\n+    qtest_writeb(s, 0x69736c22,\
    \ 0x01);\n+    qtest_writeb(s, 0x69736c23, 0x07);\n+    qtest_writeb(s, 0x69736c2b,\
    \ 0x02);\n+    qtest_writeb(s, 0x69736c48, 0x08);\n+    qtest_writeb(s, 0x69736c4b,\
    \ 0x58);\n+    qtest_writeb(s, 0x69736c52, 0x04);\n+    qtest_writeb(s, 0x69736c53,\
    \ 0x06);\n+    qtest_writeb(s, 0x69736c5b, 0x02);\n+    qtest_outl(s, 0xc02d,\
    \ 0x697300);\n+    qtest_writeb(s, 0x5a554662, 0x01);\n+    qtest_writeb(s, 0x5a554663,\
    \ 0x07);\n+    qtest_writeb(s, 0x5a55466a, 0x10);\n+    qtest_writeb(s, 0x5a55466b,\
    \ 0x22);\n+    qtest_writeb(s, 0x5a55466c, 0x5a);\n+    qtest_writeb(s, 0x5a55466d,\
    \ 0x5a);\n+    qtest_writeb(s, 0x5a55466e, 0x34);\n+    qtest_writeb(s, 0x5a55466f,\
    \ 0x5a);\n+    qtest_writeb(s, 0x5a345a5a, 0x77);\n+    qtest_writeb(s, 0x5a345a5b,\
    \ 0x55);\n+    qtest_writeb(s, 0x5a345a5c, 0x51);\n+    qtest_writeb(s, 0x5a345a5d,\
    \ 0x27);\n+    qtest_writeb(s, 0x27515577, 0x41);\n+    qtest_outl(s, 0xc02d,\
    \ 0x5a5500);\n+    qtest_writeb(s, 0x364001d0, 0x08);\n+    qtest_writeb(s, 0x364001d3,\
    \ 0x58);\n+    qtest_writeb(s, 0x364001da, 0x01);\n+    qtest_writeb(s, 0x364001db,\
    \ 0x26);\n+    qtest_writeb(s, 0x364001dc, 0x0d);\n+    qtest_writeb(s, 0x364001dd,\
    \ 0xae);\n+    qtest_writeb(s, 0x364001de, 0x41);\n+    qtest_writeb(s, 0x364001df,\
    \ 0x5a);\n+    qtest_writeb(s, 0x5a41ae0d, 0xf8);\n+    qtest_writeb(s, 0x5a41ae0e,\
    \ 0x36);\n+    qtest_writeb(s, 0x5a41ae0f, 0xd7);\n+    qtest_writeb(s, 0x5a41ae10,\
    \ 0x36);\n+    qtest_writeb(s, 0x36d736f8, 0x0c);\n+    qtest_writeb(s, 0x36d736f9,\
    \ 0x80);\n+    qtest_writeb(s, 0x36d736fa, 0x0d);\n+    qtest_outl(s, 0xc02d,\
    \ 0x364000);\n+\n+    qtest_quit(s);\n+}\n+\n /*\n  * This used to trigger the\
    \ assert in lsi_do_dma()\n  * https://bugs.launchpad.net/qemu/+bug/697510\n@@\
    \ -44,5 +117,8 @@ int main(int argc, char **argv)\n     qtest_add_func(\"fuzz/lsi53c895a/lsi_do_dma_empty_queue\"\
    ,\n                    test_lsi_do_dma_empty_queue);\n \n+    qtest_add_func(\"\
    fuzz/lsi53c895a/lsi_do_msgout_cancel_req\",\n+                   test_lsi_do_msgout_cancel_req);\n\
    +\n     return g_test_run();\n }\n"
  identifiers:
  - CVE-2022-0216
  - CWE-416
  overview: A use-after-free vulnerability was found in the LSI53C895A SCSI Host Bus
    Adapter emulation of QEMU. The flaw occurs while processing repeated messages
    to cancel the current SCSI request via the lsi_do_msgout function. This flaw allows
    a malicious privileged user within the guest to crash the QEMU process on the
    host, resulting in a denial of service.
  references:
  - source: secalert@redhat.com
    tags:
    - Third Party Advisory
    url: https://access.redhat.com/security/cve/CVE-2022-0216
  - source: secalert@redhat.com
    tags:
    - Issue Tracking
    - Third Party Advisory
    url: https://bugzilla.redhat.com/show_bug.cgi?id=2036953
  - source: secalert@redhat.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://gitlab.com/qemu-project/qemu/-/commit/4367a20cc4
  - source: secalert@redhat.com
    tags:
    - Exploit
    - Third Party Advisory
    url: https://gitlab.com/qemu-project/qemu/-/issues/972
  - source: secalert@redhat.com
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/ZTY7TVHX62OJWF6IOBCIGLR2N5K4QN3E/
  - source: secalert@redhat.com
    tags:
    - Exploit
    - Third Party Advisory
    url: https://starlabs.sg/advisories/22/22-0216/
  title: A use-after-free vulnerability was found in the LSI53C895A SCSI Host Bus
    Adapter emulation of QEMU. The flaw occurs while processing repeated messages
    to cancel the current SCSI request via the lsi_do_msgout function. This flaw allows
    a malicious privileged user within the guest to crash the QEMU process on the
    host, resulting in a denial of service.
- diff_content:
  - "--- a/print-vrrp.c\n+++ b/print-vrrp.c\n@@ -152,9 +152,11 @@ vrrp_print(netdissect_options\
    \ *ndo,\n \t\tif (version == 3 && ND_TTEST2(bp[0], len)) {\n \t\t\tuint16_t cksum\
    \ = nextproto4_cksum(ndo, (const struct ip *)bp2, bp,\n \t\t\t\tlen, len, IPPROTO_VRRP);\n\
    -\t\t\tif (cksum)\n+\t\t\tif (cksum) {\n+\t\t\t\tND_TCHECK_16BITS(&bp[6]);\n \t\
    \t\t\tND_PRINT((ndo, \", (bad vrrp cksum %x)\",\n \t\t\t\t\tEXTRACT_16BITS(&bp[6])));\n\
    +\t\t\t}\n \t\t}\n \n \t\tND_PRINT((ndo, \", addrs\"));"
  identifiers:
  - CVE-2019-15167
  - CWE-125
  overview: The VRRP parser in tcpdump before 4.9.3 has a buffer over-read in print-vrrp.c:vrrp_print()
    for VRRP version 3, a different vulnerability than CVE-2018-14463.
  references:
  - source: cve@mitre.org
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/the-tcpdump-group/tcpdump/commit/a152aebfd1114376ba266ed30416be596ef9d806
  title: The VRRP parser in tcpdump before 4.9.3 has a buffer over-read in print-vrrp.c:vrrp_print()
    for VRRP version 3, a different vulnerability than CVE-2018-14463.
- diff_content:
  - "--- a/src/quickfix.c\n+++ b/src/quickfix.c\n@@ -594,6 +594,7 @@ enum {\n    \
    \ QF_NOMEM = 3,\n     QF_IGNORE_LINE = 4,\n     QF_MULTISCAN = 5,\n+    QF_ABORT\
    \ = 6\n };\n \n /*\n@@ -3153,7 +3154,7 @@ qf_jump_to_usable_window(int qf_fnum,\
    \ int newwin, int *opened_window)\n /*\n  * Edit the selected file or help file.\n\
    \  * Returns OK if successfully edited the file, FAIL on failing to open the\n\
    - * buffer and NOTDONE if the quickfix/location list was freed by an autocmd\n\
    + * buffer and QF_ABORT if the quickfix/location list was freed by an autocmd\n\
    \  * when opening the buffer.\n  */\n     static int\n@@ -3199,14 +3200,14 @@\
    \ qf_jump_edit_buffer(\n \t{\n \t    emsg(_(e_current_window_was_closed));\n \t\
    \    *opened_window = FALSE;\n-\t    return NOTDONE;\n+\t    return QF_ABORT;\n\
    \ \t}\n     }\n \n     if (qfl_type == QFLT_QUICKFIX && !qflist_valid(NULL, save_qfid))\n\
    \     {\n \temsg(_(e_current_quickfix_list_was_changed));\n-\treturn NOTDONE;\n\
    +\treturn QF_ABORT;\n     }\n \n     // Check if the list was changed.  The pointers\
    \ may happen to be identical,\n@@ -3219,7 +3220,7 @@ qf_jump_edit_buffer(\n \t\
    \    emsg(_(e_current_quickfix_list_was_changed));\n \telse\n \t    emsg(_(e_current_location_list_was_changed));\n\
    -\treturn NOTDONE;\n+\treturn QF_ABORT;\n     }\n \n     return retval;\n@@ -3317,7\
    \ +3318,8 @@ qf_jump_print_msg(\n  * a new window.\n  * Returns OK if successfully\
    \ jumped or opened a window. Returns FAIL if not\n  * able to jump/open a window.\
    \  Returns NOTDONE if a file is not associated\n- * with the entry.\n+ * with\
    \ the entry.  Returns QF_ABORT if the quickfix/location list was modified\n+ *\
    \ by an autocmd.\n  */\n     static int\n qf_jump_open_window(\n@@ -3344,7 +3346,7\
    \ @@ qf_jump_open_window(\n \t    emsg(_(e_current_quickfix_list_was_changed));\n\
    \ \telse\n \t    emsg(_(e_current_location_list_was_changed));\n-\treturn FAIL;\n\
    +\treturn QF_ABORT;\n     }\n \n     // If currently in the quickfix window, find\
    \ another window to show the\n@@ -3368,7 +3370,7 @@ qf_jump_open_window(\n \t\
    \    emsg(_(e_current_quickfix_list_was_changed));\n \telse\n \t    emsg(_(e_current_location_list_was_changed));\n\
    -\treturn FAIL;\n+\treturn QF_ABORT;\n     }\n \n     return OK;\n@@ -3379,7 +3381,7\
    \ @@ qf_jump_open_window(\n  * particular line/column, adjust the folds and display\
    \ a message about the\n  * jump.\n  * Returns OK on success and FAIL on failing\
    \ to open the file/buffer.  Returns\n- * NOTDONE if the quickfix/location list\
    \ is freed by an autocmd when opening\n+ * QF_ABORT if the quickfix/location list\
    \ is freed by an autocmd when opening\n  * the file.\n  */\n     static int\n\
    @@ -3508,14 +3510,20 @@ qf_jump_newwin(qf_info_T\t*qi,\n     retval = qf_jump_open_window(qi,\
    \ qf_ptr, newwin, &opened_window);\n     if (retval == FAIL)\n \tgoto failed;\n\
    +    if (retval == QF_ABORT)\n+    {\n+\tqi = NULL;\n+\tqf_ptr = NULL;\n+\tgoto\
    \ theend;\n+    }\n     if (retval == NOTDONE)\n \tgoto theend;\n \n     retval\
    \ = qf_jump_to_buffer(qi, qf_index, qf_ptr, forceit, prev_winid,\n \t\t\t\t  &opened_window,\
    \ old_KeyTyped, print_message);\n-    if (retval == NOTDONE)\n+    if (retval\
    \ == QF_ABORT)\n     {\n-\t// Quickfix/location list is freed by an autocmd\n\
    +\t// Quickfix/location list was modified by an autocmd\n \tqi = NULL;\n \tqf_ptr\
    \ = NULL;\n     }"
  - "--- a/src/version.c\n+++ b/src/version.c\n@@ -707,6 +707,8 @@ static char *(features[])\
    \ =\n \n static int included_patches[] =\n {   /* Add new patch number below this\
    \ line */\n+/**/\n+    286,\n /**/\n     285,\n /**/"
  identifiers:
  - CVE-2022-3016
  - CWE-416
  overview: Use After Free in GitHub repository vim/vim prior to 9.0.0286.
  references:
  - source: security@huntr.dev
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/vim/vim/commit/6d24a51b94beb1991cddce221f90b455e2d50db7
  - source: security@huntr.dev
    tags:
    - Exploit
    - Patch
    - Third Party Advisory
    url: https://huntr.dev/bounties/260516c2-5c4a-4b7f-a01c-04b1aeeea371
  - source: security@huntr.dev
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/XWOJOA7PZZAMBI5GFTL6PWHXMWSDLUXL/
  - source: security@huntr.dev
    url: https://security.gentoo.org/glsa/202305-16
  title: Use After Free in GitHub repository vim/vim prior to 9.0.0286.
- diff_content:
  - "--- a/coders/xpm.c\n+++ b/coders/xpm.c\n@@ -773,7 +773,7 @@ static MagickBooleanType\
    \ WritePICONImage(const ImageInfo *image_info,\n               break;\n      \
    \       for (x=0; x < (ssize_t) picon->columns; x++)\n             {\n-      \
    \        if (GetPixelAlpha(image,q) == (Quantum) TransparentAlpha)\n+        \
    \      if (GetPixelAlpha(picon,q) == (Quantum) TransparentAlpha)\n           \
    \      transparent=MagickTrue;\n               else\n                 SetPixelAlpha(picon,OpaqueAlpha,q);\n\
    @@ -804,7 +804,7 @@ static MagickBooleanType WritePICONImage(const ImageInfo *image_info,\n\
    \           break;\n         for (x=0; x < (ssize_t) picon->columns; x++)\n  \
    \       {\n-          if (GetPixelAlpha(image,q) == (Quantum) TransparentAlpha)\n\
    +          if (GetPixelAlpha(picon,q) == (Quantum) TransparentAlpha)\n       \
    \      SetPixelIndex(picon,(Quantum) picon->colors,q);\n           q+=GetPixelChannels(picon);\n\
    \         }"
  identifiers:
  - CVE-2022-0284
  - CWE-125
  overview: A heap-based-buffer-over-read flaw was found in ImageMagick's GetPixelAlpha()
    function of 'pixel-accessor.h'. This vulnerability is triggered when an attacker
    passes a specially crafted Tagged Image File Format (TIFF) image to convert it
    into a PICON file format. This issue can potentially lead to a denial of service
    and information disclosure.
  references:
  - source: secalert@redhat.com
    tags:
    - Issue Tracking
    - Third Party Advisory
    url: https://access.redhat.com/security/cve/CVE-2022-0284
  - source: secalert@redhat.com
    tags:
    - Issue Tracking
    - Patch
    - Third Party Advisory
    url: https://bugzilla.redhat.com/show_bug.cgi?id=2045943
  - source: secalert@redhat.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/ImageMagick/ImageMagick/commit/e50f19fd73c792ebe912df8ab83aa51a243a3da7
  - source: secalert@redhat.com
    tags:
    - Exploit
    - Issue Tracking
    - Third Party Advisory
    url: https://github.com/ImageMagick/ImageMagick/issues/4729
  title: A heap-based-buffer-over-read flaw was found in ImageMagick's GetPixelAlpha()
    function of 'pixel-accessor.h'. This vulnerability is triggered when an attacker
    passes a specially crafted Tagged Image File Format (TIFF) image to convert it
    into a PICON file format. This issue can potentially lead to a denial of service
    and information disclosure.
- diff_content:
  - "--- a/source4/dsdb/samdb/ldb_modules/samldb.c\n+++ b/source4/dsdb/samdb/ldb_modules/samldb.c\n\
    @@ -4006,8 +4006,7 @@ static int samldb_spn_uniqueness_check(struct samldb_ctx\
    \ *ac,\n \t\t\t\t\t\t ac->msg->dn);\n \t\tif (ret == LDB_ERR_COMPARE_TRUE) {\n\
    \ \t\t\tDBG_INFO(\"SPN %s re-added to the same object\\n\", spn);\n-\t\t\ttalloc_free(tmp_ctx);\n\
    -\t\t\treturn LDB_SUCCESS;\n+\t\t\tcontinue;\n \t\t}\n \t\tif (ret != LDB_SUCCESS)\
    \ {\n \t\t\tDBG_ERR(\"SPN %s failed direct uniqueness check\\n\", spn);"
  identifiers:
  - CVE-2022-0336
  - CWE-276
  overview: The Samba AD DC includes checks when adding service principals names (SPNs)
    to an account to ensure that SPNs do not alias with those already in the database.
    Some of these checks are able to be bypassed if an account modification re-adds
    an SPN that was previously present on that account, such as one added when a computer
    is joined to a domain. An attacker who has the ability to write to an account
    can exploit this to perform a denial-of-service attack by adding an SPN that matches
    an existing service. Additionally, an attacker who can intercept traffic can impersonate
    existing services, resulting in a loss of confidentiality and integrity.
  references:
  - source: secalert@redhat.com
    tags:
    - Issue Tracking
    - Third Party Advisory
    url: https://access.redhat.com/security/cve/CVE-2022-0336
  - source: secalert@redhat.com
    tags:
    - Issue Tracking
    - Third Party Advisory
    url: https://bugzilla.redhat.com/show_bug.cgi?id=2046134
  - source: secalert@redhat.com
    tags:
    - Issue Tracking
    - Patch
    - Vendor Advisory
    url: https://bugzilla.samba.org/show_bug.cgi?id=14950
  - source: secalert@redhat.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/samba-team/samba/commit/1a5dc817c0c9379bbaab14c676681b42b0039a3c
  - source: secalert@redhat.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/samba-team/samba/commit/c58ede44f382bd0125f761f0479c8d48156be400
  - source: secalert@redhat.com
    url: https://security.gentoo.org/glsa/202309-06
  - source: secalert@redhat.com
    tags:
    - Vendor Advisory
    url: https://www.samba.org/samba/security/CVE-2022-0336.html
  title: The Samba AD DC includes checks when adding service principals names (SPNs)
    to an account to ensure that SPNs do not alias with those already in the database.
    Some of these checks are able to be bypassed if an account modification re-adds
    an SPN that was previously present on that account, such as one added when a computer
    is joined to a domain. An attacker who has the ability to write to an account
    can exploit this to perform a denial-of-service attack by adding an SPN that matches
    an existing service. Additionally, an attacker who can intercept traffic can impersonate
    existing services, resulting in a loss of confidentiality and integrity.
- diff_content:
  - "--- a/tools/virtiofsd/passthrough_ll.c\n+++ b/tools/virtiofsd/passthrough_ll.c\n\
    @@ -54,6 +54,7 @@\n #include <sys/wait.h>\n #include <sys/xattr.h>\n #include\
    \ <syslog.h>\n+#include <grp.h>\n \n #include \"qemu/cutils.h\"\n #include \"\
    passthrough_helpers.h\"\n@@ -1161,6 +1162,30 @@ static void lo_lookup(fuse_req_t\
    \ req, fuse_ino_t parent, const char *name)\n #define OURSYS_setresuid SYS_setresuid\n\
    \ #endif\n \n+static void drop_supplementary_groups(void)\n+{\n+    int ret;\n\
    +\n+    ret = getgroups(0, NULL);\n+    if (ret == -1) {\n+        fuse_log(FUSE_LOG_ERR,\
    \ \"getgroups() failed with error=%d:%s\\n\",\n+                 errno, strerror(errno));\n\
    +        exit(1);\n+    }\n+\n+    if (!ret) {\n+        return;\n+    }\n+\n\
    +    /* Drop all supplementary groups. We should not need it */\n+    ret = setgroups(0,\
    \ NULL);\n+    if (ret == -1) {\n+        fuse_log(FUSE_LOG_ERR, \"setgroups()\
    \ failed with error=%d:%s\\n\",\n+                 errno, strerror(errno));\n\
    +        exit(1);\n+    }\n+}\n+\n /*\n  * Change to uid/gid of caller so that\
    \ file is created with\n  * ownership of caller.\n@@ -3926,6 +3951,8 @@ int main(int\
    \ argc, char *argv[])\n \n     qemu_init_exec_dir(argv[0]);\n \n+    drop_supplementary_groups();\n\
    +\n     pthread_mutex_init(&lo.mutex, NULL);\n     lo.inodes = g_hash_table_new(lo_key_hash,\
    \ lo_key_equal);\n     lo.root.fd = -1;\n"
  identifiers:
  - CVE-2022-0358
  - CWE-273
  overview: A flaw was found in the QEMU virtio-fs shared file system daemon (virtiofsd)
    implementation. This flaw is strictly related to CVE-2018-13405. A local guest
    user can create files in the directories shared by virtio-fs with unintended group
    ownership in a scenario where a directory is SGID to a certain group and is writable
    by a user who is not a member of the group. This could allow a malicious unprivileged
    user inside the guest to gain access to resources accessible to the root group,
    potentially escalating their privileges within the guest. A malicious local user
    in the host might also leverage this unexpected executable file created by the
    guest to escalate their privileges on the host system.
  references:
  - source: secalert@redhat.com
    tags:
    - Third Party Advisory
    url: https://access.redhat.com/security/cve/CVE-2022-0358
  - source: secalert@redhat.com
    tags:
    - Issue Tracking
    - Patch
    - Third Party Advisory
    url: https://bugzilla.redhat.com/show_bug.cgi?id=2044863
  - source: secalert@redhat.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://gitlab.com/qemu-project/qemu/-/commit/449e8171f96a6a944d1f3b7d3627ae059eae21ca
  - source: secalert@redhat.com
    tags:
    - Third Party Advisory
    url: https://security.netapp.com/advisory/ntap-20221007-0008/
  title: A flaw was found in the QEMU virtio-fs shared file system daemon (virtiofsd)
    implementation. This flaw is strictly related to CVE-2018-13405. A local guest
    user can create files in the directories shared by virtio-fs with unintended group
    ownership in a scenario where a directory is SGID to a certain group and is writable
    by a user who is not a member of the group. This could allow a malicious unprivileged
    user inside the guest to gain access to resources accessible to the root group,
    potentially escalating their privileges within the guest. A malicious local user
    in the host might also leverage this unexpected executable file created by the
    guest to escalate their privileges on the host system.
- diff_content:
  - "--- a/src/modbus.c\n+++ b/src/modbus.c\n@@ -961,7 +961,7 @@ int modbus_reply(modbus_t\
    \ *ctx, const uint8_t *req,\n                 nb_write, nb, MODBUS_MAX_WR_WRITE_REGISTERS,\
    \ MODBUS_MAX_WR_READ_REGISTERS);\n         } else if (mapping_address < 0 ||\n\
    \                    (mapping_address + nb) > mb_mapping->nb_registers ||\n- \
    \                  mapping_address < 0 ||\n+                   mapping_address_write\
    \ < 0 ||\n                    (mapping_address_write + nb_write) > mb_mapping->nb_registers)\
    \ {\n             rsp_length = response_exception(\n                 ctx, &sft,\
    \ MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS, rsp, FALSE,"
  identifiers:
  - CVE-2022-0367
  - CWE-787
  overview: A heap-based buffer overflow flaw was found in libmodbus in function modbus_reply()
    in src/modbus.c.
  references:
  - source: secalert@redhat.com
    tags:
    - Issue Tracking
    - Third Party Advisory
    url: https://bugzilla.redhat.com/show_bug.cgi?id=2045571
  - source: secalert@redhat.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/stephane/libmodbus/commit/b4ef4c17d618eba0adccc4c7d9e9a1ef809fc9b6
  - source: secalert@redhat.com
    tags:
    - Exploit
    - Issue Tracking
    - Patch
    - Third Party Advisory
    url: https://github.com/stephane/libmodbus/issues/614
  - source: secalert@redhat.com
    tags:
    - Mailing List
    - Third Party Advisory
    url: https://lists.debian.org/debian-lts-announce/2022/09/msg00007.html
  title: A heap-based buffer overflow flaw was found in libmodbus in function modbus_reply()
    in src/modbus.c.
- diff_content:
  - "--- a/copy/file-ops.c\n+++ b/copy/file-ops.c\n@@ -591,10 +591,8 @@ file_asynch_read\
    \ (struct rw *rw,\n \n   file_synch_read (rw, slice_ptr (command->slice),\n  \
    \                  command->slice.len, command->offset);\n-  if (cb.callback (cb.user_data,\
    \ &dummy) == -1) {\n-    perror (rw->name);\n-    exit (EXIT_FAILURE);\n-  }\n\
    +  /* file_synch_read called exit() on error */\n+  cb.callback (cb.user_data,\
    \ &dummy);\n }\n \n static void\n@@ -606,10 +604,8 @@ file_asynch_write (struct\
    \ rw *rw,\n \n   file_synch_write (rw, slice_ptr (command->slice),\n         \
    \            command->slice.len, command->offset);\n-  if (cb.callback (cb.user_data,\
    \ &dummy) == -1) {\n-    perror (rw->name);\n-    exit (EXIT_FAILURE);\n-  }\n\
    +  /* file_synch_write called exit() on error */\n+  cb.callback (cb.user_data,\
    \ &dummy);\n }\n \n static bool\n@@ -620,10 +616,7 @@ file_asynch_zero (struct\
    \ rw *rw, struct command *command,\n \n   if (!file_synch_zero (rw, command->offset,\
    \ command->slice.len, allocate))\n     return false;\n-  if (cb.callback (cb.user_data,\
    \ &dummy) == -1) {\n-    perror (rw->name);\n-    exit (EXIT_FAILURE);\n-  }\n\
    +  cb.callback (cb.user_data, &dummy);\n   return true;\n }\n \n"
  - "--- a/copy/multi-thread-copying.c\n+++ b/copy/multi-thread-copying.c\n@@ -28,6\
    \ +28,7 @@\n #include <errno.h>\n #include <assert.h>\n #include <sys/stat.h>\n\
    +#include <inttypes.h>\n \n #include <pthread.h>\n \n@@ -376,6 +377,12 @@ finished_read\
    \ (void *vp, int *error)\n {\n   struct command *command = vp;\n \n+  if (*error)\
    \ {\n+    fprintf (stderr, \"read at offset %\" PRId64 \" failed: %s\\n\",\n+\
    \             command->offset, strerror (*error));\n+    exit (EXIT_FAILURE);\n\
    +  }\n+\n   if (allocated || sparse_size == 0) {\n     /* If sparseness detection\
    \ (see below) is turned off then we write\n      * the whole command.\n@@ -548,6\
    \ +555,12 @@ free_command (void *vp, int *error)\n   struct command *command =\
    \ vp;\n   struct buffer *buffer = command->slice.buffer;\n \n+  if (*error) {\n\
    +    fprintf (stderr, \"write at offset %\" PRId64 \" failed: %s\\n\",\n+    \
    \         command->offset, strerror (*error));\n+    exit (EXIT_FAILURE);\n+ \
    \ }\n+\n   if (buffer != NULL) {\n     if (--buffer->refs == 0) {\n       free\
    \ (buffer->data);\n"
  - "--- a/copy/null-ops.c\n+++ b/copy/null-ops.c\n@@ -119,10 +119,7 @@ null_asynch_write\
    \ (struct rw *rw,\n {\n   int dummy = 0;\n \n-  if (cb.callback (cb.user_data,\
    \ &dummy) == -1) {\n-    perror (rw->name);\n-    exit (EXIT_FAILURE);\n-  }\n\
    +  cb.callback (cb.user_data, &dummy);\n }\n \n static bool\n@@ -131,10 +128,7\
    \ @@ null_asynch_zero (struct rw *rw, struct command *command,\n {\n   int dummy\
    \ = 0;\n \n-  if (cb.callback (cb.user_data, &dummy) == -1) {\n-    perror (rw->name);\n\
    -    exit (EXIT_FAILURE);\n-  }\n+  cb.callback (cb.user_data, &dummy);\n   return\
    \ true;\n }\n \n"
  identifiers:
  - CVE-2022-0485
  - CWE-252
  overview: A flaw was found in the copying tool `nbdcopy` of libnbd. When performing
    multi-threaded copies using asynchronous nbd calls, nbdcopy was blindly treating
    the completion of an asynchronous command as successful, rather than checking
    the *error parameter. This could result in the silent creation of a corrupted
    destination image.
  references:
  - source: secalert@redhat.com
    tags:
    - Vendor Advisory
    url: https://access.redhat.com/security/cve/CVE-2022-0485
  - source: secalert@redhat.com
    tags:
    - Exploit
    - Issue Tracking
    - Vendor Advisory
    url: https://bugzilla.redhat.com/show_bug.cgi?id=2046194
  - source: secalert@redhat.com
    tags:
    - Issue Tracking
    - Vendor Advisory
    url: https://bugzilla.redhat.com/show_bug.cgi?id=2050324
  - source: secalert@redhat.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://gitlab.com/nbdkit/libnbd/-/commit/8d444b41d09a700c7ee6f9182a649f3f2d325abb
  - source: secalert@redhat.com
    tags:
    - Patch
    - Vendor Advisory
    url: https://listman.redhat.com/archives/libguestfs/2022-February/msg00104.html
  title: A flaw was found in the copying tool `nbdcopy` of libnbd. When performing
    multi-threaded copies using asynchronous nbd calls, nbdcopy was blindly treating
    the completion of an asynchronous command as successful, rather than checking
    the *error parameter. This could result in the silent creation of a corrupted
    destination image.
- diff_content:
  - "--- a/lib/vhost/vhost_user.c\n+++ b/lib/vhost/vhost_user.c\n@@ -1602,6 +1602,9\
    \ @@ vhost_user_get_inflight_fd(struct virtio_net **pdev,\n \tint numa_node =\
    \ SOCKET_ID_ANY;\n \tvoid *addr;\n \n+\tif (validate_msg_fds(dev, ctx, 0) != 0)\n\
    +\t\treturn RTE_VHOST_MSG_RESULT_ERR;\n+\n \tif (ctx->msg.size != sizeof(ctx->msg.payload.inflight))\
    \ {\n \t\tVHOST_LOG_CONFIG(ERR, \"(%s) invalid get_inflight_fd message size is\
    \ %d\\n\",\n \t\t\tdev->ifname, ctx->msg.size);\n@@ -1699,6 +1702,9 @@ vhost_user_set_inflight_fd(struct\
    \ virtio_net **pdev,\n \tint fd, i;\n \tint numa_node = SOCKET_ID_ANY;\n \n+\t\
    if (validate_msg_fds(dev, ctx, 1) != 0)\n+\t\treturn RTE_VHOST_MSG_RESULT_ERR;\n\
    +\n \tfd = ctx->fds[0];\n \tif (ctx->msg.size != sizeof(ctx->msg.payload.inflight)\
    \ || fd < 0) {\n \t\tVHOST_LOG_CONFIG(ERR, \"(%s) invalid set_inflight_fd message\
    \ size is %d,fd is %d\\n\","
  identifiers:
  - CVE-2022-0669
  - NVD-CWE-noinfo
  overview: A flaw was found in dpdk. This flaw allows a malicious vhost-user master
    to attach an unexpected number of fds as ancillary data to VHOST_USER_GET_INFLIGHT_FD
    / VHOST_USER_SET_INFLIGHT_FD messages that are not closed by the vhost-user slave.
    By sending such messages continuously, the vhost-user master exhausts available
    fd in the vhost-user slave process, leading to a denial of service.
  references:
  - source: secalert@redhat.com
    tags:
    - Third Party Advisory
    url: https://access.redhat.com/security/cve/CVE-2022-0669
  - source: secalert@redhat.com
    tags:
    - Patch
    - Vendor Advisory
    url: https://bugs.dpdk.org/show_bug.cgi?id=922
  - source: secalert@redhat.com
    tags:
    - Issue Tracking
    - Patch
    - Third Party Advisory
    url: https://bugzilla.redhat.com/show_bug.cgi?id=2055793
  - source: secalert@redhat.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/DPDK/dpdk/commit/af74f7db384ed149fe42b21dbd7975f8a54ef227
  - source: secalert@redhat.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://security-tracker.debian.org/tracker/CVE-2022-0669
  title: A flaw was found in dpdk. This flaw allows a malicious vhost-user master
    to attach an unexpected number of fds as ancillary data to VHOST_USER_GET_INFLIGHT_FD
    / VHOST_USER_SET_INFLIGHT_FD messages that are not closed by the vhost-user slave.
    By sending such messages continuously, the vhost-user master exhausts available
    fd in the vhost-user slave process, leading to a denial of service.
- diff_content:
  - "--- a/fs/io_uring.c\n+++ b/fs/io_uring.c\n@@ -9843,10 +9843,11 @@ static int\
    \ io_register_personality(struct io_ring_ctx *ctx)\n \n \tret = xa_alloc_cyclic(&ctx->personalities,\
    \ &id, (void *)creds,\n \t\t\tXA_LIMIT(0, USHRT_MAX), &ctx->pers_next, GFP_KERNEL);\n\
    -\tif (!ret)\n-\t\treturn id;\n-\tput_cred(creds);\n-\treturn ret;\n+\tif (ret\
    \ < 0) {\n+\t\tput_cred(creds);\n+\t\treturn ret;\n+\t}\n+\treturn id;\n }\n \n\
    \ static int io_register_restrictions(struct io_ring_ctx *ctx, void __user *arg,"
  identifiers:
  - CVE-2022-1043
  - CWE-416
  overview: "A flaw was found in the Linux kernel\u2019s io_uring implementation.\
    \ This flaw allows an attacker with a local account to corrupt system memory,\
    \ crash the system or escalate privileges."
  references:
  - source: secalert@redhat.com
    tags:
    - Exploit
    - Third Party Advisory
    - VDB Entry
    url: http://packetstormsecurity.com/files/170834/io_uring-Same-Type-Object-Reuse-Privilege-Escalation.html
  - source: secalert@redhat.com
    tags:
    - Third Party Advisory
    url: https://access.redhat.com/security/cve/CVE-2022-1043
  - source: secalert@redhat.com
    tags:
    - Issue Tracking
    - Third Party Advisory
    url: https://bugzilla.redhat.com/show_bug.cgi?id=1997328
  - source: secalert@redhat.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/torvalds/linux/commit/a30f895ad3239f45012e860d4f94c1a388b36d14
  - source: secalert@redhat.com
    tags:
    - Third Party Advisory
    - VDB Entry
    url: https://www.zerodayinitiative.com/advisories/ZDI-22-362/
  title: "A flaw was found in the Linux kernel\u2019s io_uring implementation. This\
    \ flaw allows an attacker with a local account to corrupt system memory, crash\
    \ the system or escalate privileges."
- diff_content:
  - "--- a/coders/tiff.c\n+++ b/coders/tiff.c\n@@ -1987,7 +1987,7 @@ static Image\
    \ *ReadTIFFImage(const ImageInfo *image_info,\n         number_pixels=(MagickSizeType)\
    \ columns*rows;\n         if (HeapOverflowSanityCheck(rows,sizeof(*tile_pixels))\
    \ != MagickFalse)\n           ThrowTIFFException(ResourceLimitError,\"MemoryAllocationFailed\"\
    );\n-        extent=MagickMax(rows*TIFFTileRowSize(tiff),TIFFTileSize(tiff));\n\
    +        extent=4*MagickMax(rows*TIFFTileRowSize(tiff),TIFFTileSize(tiff));\n\
    \ #if defined(TIFF_VERSION_BIG)\n         extent+=image->columns*sizeof(uint64);\n\
    \ #else"
  - "--- a/coders/tiff.c\n+++ b/coders/tiff.c\n@@ -1894,7 +1894,7 @@ static Image\
    \ *ReadTIFFImage(const ImageInfo *image_info,\n         number_pixels=(MagickSizeType)\
    \ columns*rows;\n         if (HeapOverflowSanityCheck(rows,sizeof(*tile_pixels))\
    \ != MagickFalse)\n           ThrowTIFFException(ResourceLimitError,\"MemoryAllocationFailed\"\
    );\n-        extent=MagickMax(rows*TIFFTileRowSize(tiff),TIFFTileSize(tiff));\n\
    +        extent=4*MagickMax(rows*TIFFTileRowSize(tiff),TIFFTileSize(tiff));\n\
    \ #if defined(TIFF_VERSION_BIG)\n         extent+=image->columns*sizeof(uint64);\n\
    \ #else"
  identifiers:
  - CVE-2022-1115
  - CWE-787
  overview: "A heap-buffer-overflow flaw was found in ImageMagick\u2019s PushShortPixel()\
    \ function of quantum-private.h file. This vulnerability is triggered when an\
    \ attacker passes a specially crafted TIFF image file to ImageMagick for conversion,\
    \ potentially leading to a denial of service."
  references:
  - source: secalert@redhat.com
    tags:
    - Issue Tracking
    - Third Party Advisory
    url: https://access.redhat.com/security/cve/CVE-2022-1115
  - source: secalert@redhat.com
    tags:
    - Issue Tracking
    - Third Party Advisory
    url: https://bugzilla.redhat.com/show_bug.cgi?id=2067022
  - source: secalert@redhat.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/ImageMagick/ImageMagick/commit/c8718305f120293d8bf13724f12eed885d830b09
  - source: secalert@redhat.com
    tags:
    - Exploit
    - Issue Tracking
    - Third Party Advisory
    url: https://github.com/ImageMagick/ImageMagick/issues/4974
  - source: secalert@redhat.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/ImageMagick/ImageMagick6/commit/1f860f52bd8d58737ad883072203391096b30b51
  title: "A heap-buffer-overflow flaw was found in ImageMagick\u2019s PushShortPixel()\
    \ function of quantum-private.h file. This vulnerability is triggered when an\
    \ attacker passes a specially crafted TIFF image file to ImageMagick for conversion,\
    \ potentially leading to a denial of service."
- diff_content:
  - "--- a/net/ax25/af_ax25.c\n+++ b/net/ax25/af_ax25.c\n@@ -77,6 +77,7 @@ static\
    \ void ax25_kill_by_device(struct net_device *dev)\n {\n \tax25_dev *ax25_dev;\n\
    \ \tax25_cb *s;\n+\tstruct sock *sk;\n \n \tif ((ax25_dev = ax25_dev_ax25dev(dev))\
    \ == NULL)\n \t\treturn;\n@@ -85,13 +86,15 @@ static void ax25_kill_by_device(struct\
    \ net_device *dev)\n again:\n \tax25_for_each(s, &ax25_list) {\n \t\tif (s->ax25_dev\
    \ == ax25_dev) {\n+\t\t\tsk = s->sk;\n+\t\t\tsock_hold(sk);\n \t\t\tspin_unlock_bh(&ax25_list_lock);\n\
    -\t\t\tlock_sock(s->sk);\n+\t\t\tlock_sock(sk);\n \t\t\ts->ax25_dev = NULL;\n\
    -\t\t\trelease_sock(s->sk);\n+\t\t\trelease_sock(sk);\n \t\t\tax25_disconnect(s,\
    \ ENETUNREACH);\n \t\t\tspin_lock_bh(&ax25_list_lock);\n-\n+\t\t\tsock_put(sk);\n\
    \ \t\t\t/* The entry could have been deleted from the\n \t\t\t * list meanwhile\
    \ and thus the next pointer is\n \t\t\t * no longer valid.  Play it safe and restart"
  - "--- a/net/ax25/af_ax25.c\n+++ b/net/ax25/af_ax25.c\n@@ -87,6 +87,13 @@ static\
    \ void ax25_kill_by_device(struct net_device *dev)\n \tax25_for_each(s, &ax25_list)\
    \ {\n \t\tif (s->ax25_dev == ax25_dev) {\n \t\t\tsk = s->sk;\n+\t\t\tif (!sk)\
    \ {\n+\t\t\t\tspin_unlock_bh(&ax25_list_lock);\n+\t\t\t\ts->ax25_dev = NULL;\n\
    +\t\t\t\tax25_disconnect(s, ENETUNREACH);\n+\t\t\t\tspin_lock_bh(&ax25_list_lock);\n\
    +\t\t\t\tgoto again;\n+\t\t\t}\n \t\t\tsock_hold(sk);\n \t\t\tspin_unlock_bh(&ax25_list_lock);\n\
    \ \t\t\tlock_sock(sk);"
  identifiers:
  - CVE-2022-1199
  - CWE-416
  overview: A flaw was found in the Linux kernel. This flaw allows an attacker to
    crash the Linux kernel by simulating amateur radio from the user space, resulting
    in a null-ptr-deref vulnerability and a use-after-free vulnerability.
  references:
  - source: secalert@redhat.com
    tags:
    - Third Party Advisory
    url: https://access.redhat.com/security/cve/CVE-2022-1199
  - source: secalert@redhat.com
    tags:
    - Issue Tracking
    - Third Party Advisory
    url: https://bugzilla.redhat.com/show_bug.cgi?id=2070694
  - source: secalert@redhat.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/torvalds/linux/commit/4e0f718daf97d47cf7dec122da1be970f145c809
  - source: secalert@redhat.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/torvalds/linux/commit/71171ac8eb34ce7fe6b3267dce27c313ab3cb3ac
  - source: secalert@redhat.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/torvalds/linux/commit/7ec02f5ac8a5be5a3f20611731243dc5e1d9ba10
  - source: secalert@redhat.com
    tags:
    - Third Party Advisory
    url: https://security.netapp.com/advisory/ntap-20221228-0006/
  - source: secalert@redhat.com
    tags:
    - Mailing List
    - Third Party Advisory
    url: https://www.openwall.com/lists/oss-security/2022/04/02/5
  title: A flaw was found in the Linux kernel. This flaw allows an attacker to crash
    the Linux kernel by simulating amateur radio from the user space, resulting in
    a null-ptr-deref vulnerability and a use-after-free vulnerability.
- diff_content:
  - "--- a/tools/tiffcrop.c\n+++ b/tools/tiffcrop.c\n@@ -108,12 +108,12 @@\n  *  \
    \              lower level, scanline level routines. Debug reports a limited set\n\
    \  *                of messages to monitor progress without enabling dump logs.\n\
    \  * \n- * Note:    The (-X|-Y), -Z and -z options are mutually exclusive.\n+\
    \ * Note:    The (-X|-Y), -Z, -z and -S options are mutually exclusive.\n  * \
    \         In no case should the options be applied to a given selection successively.\n\
    \  */\n \n-static   char tiffcrop_version_id[] = \"2.5\";\n-static   char tiffcrop_rev_date[]\
    \ = \"02-09-2022\";\n+static   char tiffcrop_version_id[] = \"2.5.1\";\n+static\
    \   char tiffcrop_rev_date[] = \"15-08-2022\";\n \n #include \"tif_config.h\"\n\
    \ #include \"libport.h\"\n@@ -173,12 +173,12 @@ static   char tiffcrop_rev_date[]\
    \ = \"02-09-2022\";\n #define ROTATECW_270 32\n #define ROTATE_ANY (ROTATECW_90\
    \ | ROTATECW_180 | ROTATECW_270)\n \n-#define CROP_NONE     0\n-#define CROP_MARGINS\
    \  1\n-#define CROP_WIDTH    2\n-#define CROP_LENGTH   4\n-#define CROP_ZONES\
    \    8\n-#define CROP_REGIONS 16\n+#define CROP_NONE     0     /* \"-S\" -> Page_MODE_ROWSCOLS\
    \ and page->rows/->cols != 0 */\n+#define CROP_MARGINS  1     /* \"-m\" */\n+#define\
    \ CROP_WIDTH    2     /* \"-X\" */\n+#define CROP_LENGTH   4     /* \"-Y\" */\n\
    +#define CROP_ZONES    8     /* \"-Z\" */\n+#define CROP_REGIONS 16     /* \"\
    -z\" */\n #define CROP_ROTATE  32\n #define CROP_MIRROR  64\n #define CROP_INVERT\
    \ 128\n@@ -316,7 +316,7 @@ struct crop_mask {\n #define PAGE_MODE_RESOLUTION \
    \  1\n #define PAGE_MODE_PAPERSIZE    2\n #define PAGE_MODE_MARGINS      4\n-#define\
    \ PAGE_MODE_ROWSCOLS     8\n+#define PAGE_MODE_ROWSCOLS     8    /* for -S option\
    \ */\n \n #define INVERT_DATA_ONLY      10\n #define INVERT_DATA_AND_TAG   11\n\
    @@ -781,7 +781,7 @@ static const char usage_info[] =\n \"             The four\
    \ debug/dump options are independent, though it makes little sense to\\n\"\n \"\
    \             specify a dump file without specifying a detail level.\\n\"\n \"\
    \\n\"\n-\"Note:        The (-X|-Y), -Z and -z options are mutually exclusive.\\\
    n\"\n+\"Note:        The (-X|-Y), -Z, -z and -S options are mutually exclusive.\\\
    n\"\n \"             In no case should the options be applied to a given selection\
    \ successively.\\n\"\n \"\\n\"\n ;\n@@ -2131,13 +2131,14 @@ void  process_command_opts\
    \ (int argc, char *argv[], char *mp, char *mode, uint32\n \t\t/*NOTREACHED*/\n\
    \       }\n     }\n-    /*-- Check for not allowed combinations (e.g. -X, -Y and\
    \ -Z and -z are mutually exclusive) --*/\n-    char XY, Z, R;\n-    XY = ((crop_data->crop_mode\
    \ & CROP_WIDTH) || (crop_data->crop_mode & CROP_LENGTH));\n-    Z = (crop_data->crop_mode\
    \ & CROP_ZONES);\n-    R = (crop_data->crop_mode & CROP_REGIONS);\n-    if ((XY\
    \ && Z) || (XY && R) || (Z && R)) {\n-        TIFFError(\"tiffcrop input error\"\
    , \"The crop options(-X|-Y), -Z and -z are mutually exclusive.->Exit\");\n+  \
    \  /*-- Check for not allowed combinations (e.g. -X, -Y and -Z, -z and -S are\
    \ mutually exclusive) --*/\n+    char XY, Z, R, S;\n+    XY = ((crop_data->crop_mode\
    \ & CROP_WIDTH) || (crop_data->crop_mode & CROP_LENGTH)) ? 1 : 0;\n+    Z = (crop_data->crop_mode\
    \ & CROP_ZONES) ? 1 : 0;\n+    R = (crop_data->crop_mode & CROP_REGIONS) ? 1 :\
    \ 0;\n+    S = (page->mode & PAGE_MODE_ROWSCOLS) ? 1 : 0;\n+    if (XY + Z + R\
    \ + S > 1) {\n+        TIFFError(\"tiffcrop input error\", \"The crop options(-X|-Y),\
    \ -Z, -z and -S are mutually exclusive.->Exit\");\n         exit(EXIT_FAILURE);\n\
    \     }\n   }  /* end process_command_opts */\n"
  identifiers:
  - CVE-2022-2953
  - CWE-125
  overview: LibTIFF 4.4.0 has an out-of-bounds read in extractImageSection in tools/tiffcrop.c:6905,
    allowing attackers to cause a denial-of-service via a crafted tiff file. For users
    that compile libtiff from sources, the fix is available with commit 48d6ece8.
  references:
  - source: cve@gitlab.com
    tags:
    - Exploit
    - Issue Tracking
    - Patch
    - VDB Entry
    url: https://gitlab.com/gitlab-org/cves/-/blob/master/2022/CVE-2022-2953.json
  - source: cve@gitlab.com
    tags:
    - Patch
    url: https://gitlab.com/libtiff/libtiff/-/commit/48d6ece8389b01129e7d357f0985c8f938ce3da3
  - source: cve@gitlab.com
    tags:
    - Exploit
    - Issue Tracking
    - Patch
    - Third Party Advisory
    url: https://gitlab.com/libtiff/libtiff/-/issues/414
  - source: cve@gitlab.com
    tags:
    - Third Party Advisory
    url: https://security.netapp.com/advisory/ntap-20221014-0008/
  - source: cve@gitlab.com
    tags:
    - Third Party Advisory
    url: https://www.debian.org/security/2023/dsa-5333
  title: LibTIFF 4.4.0 has an out-of-bounds read in extractImageSection in tools/tiffcrop.c:6905,
    allowing attackers to cause a denial-of-service via a crafted tiff file. For users
    that compile libtiff from sources, the fix is available with commit 48d6ece8.
- diff_content:
  - "--- a/jdapistd.c\n+++ b/jdapistd.c\n@@ -4,7 +4,7 @@\n  * This file was part of\
    \ the Independent JPEG Group's software:\n  * Copyright (C) 1994-1996, Thomas\
    \ G. Lane.\n  * libjpeg-turbo Modifications:\n- * Copyright (C) 2010, 2015-2018,\
    \ D. R. Commander.\n+ * Copyright (C) 2010, 2015-2018, 2020, D. R. Commander.\n\
    \  * Copyright (C) 2015, Google, Inc.\n  * For conditions of distribution and\
    \ use, see the accompanying README.ijg\n  * file.\n@@ -21,6 +21,8 @@\n #include\
    \ \"jinclude.h\"\n #include \"jdmainct.h\"\n #include \"jdcoefct.h\"\n+#include\
    \ \"jdmaster.h\"\n+#include \"jdmerge.h\"\n #include \"jdsample.h\"\n #include\
    \ \"jmemsys.h\"\n \n@@ -304,6 +306,16 @@ noop_quantize(j_decompress_ptr cinfo,\
    \ JSAMPARRAY input_buf,\n }\n \n \n+/* Dummy postprocessing function used by jpeg_skip_scanlines()\
    \ */\n+LOCAL(void)\n+noop_post_process (j_decompress_ptr cinfo, JSAMPIMAGE input_buf,\n\
    +                   JDIMENSION *in_row_group_ctr,\n+                   JDIMENSION\
    \ in_row_groups_avail, JSAMPARRAY output_buf,\n+                   JDIMENSION\
    \ *out_row_ctr, JDIMENSION out_rows_avail)\n+{\n+}\n+\n+\n /*\n  * In some cases,\
    \ it is best to call jpeg_read_scanlines() and discard the\n  * output, rather\
    \ than skipping the scanlines, because this allows us to\n@@ -316,11 +328,17 @@\
    \ LOCAL(void)\n read_and_discard_scanlines(j_decompress_ptr cinfo, JDIMENSION\
    \ num_lines)\n {\n   JDIMENSION n;\n+  my_master_ptr master = (my_master_ptr)cinfo->master;\n\
    \   void (*color_convert) (j_decompress_ptr cinfo, JSAMPIMAGE input_buf,\n   \
    \                       JDIMENSION input_row, JSAMPARRAY output_buf,\n       \
    \                   int num_rows) = NULL;\n   void (*color_quantize) (j_decompress_ptr\
    \ cinfo, JSAMPARRAY input_buf,\n                           JSAMPARRAY output_buf,\
    \ int num_rows) = NULL;\n+  void (*post_process_data) (j_decompress_ptr cinfo,\
    \ JSAMPIMAGE input_buf,\n+                             JDIMENSION *in_row_group_ctr,\n\
    +                             JDIMENSION in_row_groups_avail,\n+             \
    \                JSAMPARRAY output_buf, JDIMENSION *out_row_ctr,\n+          \
    \                   JDIMENSION out_rows_avail) = NULL;\n \n   if (cinfo->cconvert\
    \ && cinfo->cconvert->color_convert) {\n     color_convert = cinfo->cconvert->color_convert;\n\
    @@ -332,6 +350,12 @@ read_and_discard_scanlines(j_decompress_ptr cinfo, JDIMENSION\
    \ num_lines)\n     cinfo->cquantize->color_quantize = noop_quantize;\n   }\n \n\
    +  if (master->using_merged_upsample && cinfo->post &&\n+      cinfo->post->post_process_data)\
    \ {\n+    post_process_data = cinfo->post->post_process_data;\n+    cinfo->post->post_process_data\
    \ = noop_post_process;\n+  }\n+\n   for (n = 0; n < num_lines; n++)\n     jpeg_read_scanlines(cinfo,\
    \ NULL, 1);\n \n@@ -340,6 +364,9 @@ read_and_discard_scanlines(j_decompress_ptr\
    \ cinfo, JDIMENSION num_lines)\n \n   if (color_quantize)\n     cinfo->cquantize->color_quantize\
    \ = color_quantize;\n+\n+  if (post_process_data)\n+    cinfo->post->post_process_data\
    \ = post_process_data;\n }\n \n \n@@ -382,7 +409,7 @@ jpeg_skip_scanlines(j_decompress_ptr\
    \ cinfo, JDIMENSION num_lines)\n {\n   my_main_ptr main_ptr = (my_main_ptr)cinfo->main;\n\
    \   my_coef_ptr coef = (my_coef_ptr)cinfo->coef;\n-  my_upsample_ptr upsample\
    \ = (my_upsample_ptr)cinfo->upsample;\n+  my_master_ptr master = (my_master_ptr)cinfo->master;\n\
    \   JDIMENSION i, x;\n   int y;\n   JDIMENSION lines_per_iMCU_row, lines_left_in_iMCU_row,\
    \ lines_after_iMCU_row;\n@@ -445,8 +472,16 @@ jpeg_skip_scanlines(j_decompress_ptr\
    \ cinfo, JDIMENSION num_lines)\n     main_ptr->buffer_full = FALSE;\n     main_ptr->rowgroup_ctr\
    \ = 0;\n     main_ptr->context_state = CTX_PREPARE_FOR_IMCU;\n-    upsample->next_row_out\
    \ = cinfo->max_v_samp_factor;\n-    upsample->rows_to_go = cinfo->output_height\
    \ - cinfo->output_scanline;\n+    if (master->using_merged_upsample) {\n+    \
    \  my_merged_upsample_ptr upsample =\n+        (my_merged_upsample_ptr)cinfo->upsample;\n\
    +      upsample->spare_full = FALSE;\n+      upsample->rows_to_go = cinfo->output_height\
    \ - cinfo->output_scanline;\n+    } else {\n+      my_upsample_ptr upsample =\
    \ (my_upsample_ptr)cinfo->upsample;\n+      upsample->next_row_out = cinfo->max_v_samp_factor;\n\
    +      upsample->rows_to_go = cinfo->output_height - cinfo->output_scanline;\n\
    +    }\n   }\n \n   /* Skipping is much simpler when context rows are not required.\
    \ */\n@@ -458,8 +493,16 @@ jpeg_skip_scanlines(j_decompress_ptr cinfo, JDIMENSION\
    \ num_lines)\n       cinfo->output_scanline += lines_left_in_iMCU_row;\n     \
    \  main_ptr->buffer_full = FALSE;\n       main_ptr->rowgroup_ctr = 0;\n-     \
    \ upsample->next_row_out = cinfo->max_v_samp_factor;\n-      upsample->rows_to_go\
    \ = cinfo->output_height - cinfo->output_scanline;\n+      if (master->using_merged_upsample)\
    \ {\n+        my_merged_upsample_ptr upsample =\n+          (my_merged_upsample_ptr)cinfo->upsample;\n\
    +        upsample->spare_full = FALSE;\n+        upsample->rows_to_go = cinfo->output_height\
    \ - cinfo->output_scanline;\n+      } else {\n+        my_upsample_ptr upsample\
    \ = (my_upsample_ptr)cinfo->upsample;\n+        upsample->next_row_out = cinfo->max_v_samp_factor;\n\
    +        upsample->rows_to_go = cinfo->output_height - cinfo->output_scanline;\n\
    +      }\n     }\n   }\n \n@@ -494,7 +537,14 @@ jpeg_skip_scanlines(j_decompress_ptr\
    \ cinfo, JDIMENSION num_lines)\n       cinfo->output_iMCU_row += lines_to_skip\
    \ / lines_per_iMCU_row;\n       increment_simple_rowgroup_ctr(cinfo, lines_to_read);\n\
    \     }\n-    upsample->rows_to_go = cinfo->output_height - cinfo->output_scanline;\n\
    +    if (master->using_merged_upsample) {\n+      my_merged_upsample_ptr upsample\
    \ =\n+        (my_merged_upsample_ptr)cinfo->upsample;\n+      upsample->rows_to_go\
    \ = cinfo->output_height - cinfo->output_scanline;\n+    } else {\n+      my_upsample_ptr\
    \ upsample = (my_upsample_ptr)cinfo->upsample;\n+      upsample->rows_to_go =\
    \ cinfo->output_height - cinfo->output_scanline;\n+    }\n     return num_lines;\n\
    \   }\n \n@@ -535,7 +585,13 @@ jpeg_skip_scanlines(j_decompress_ptr cinfo, JDIMENSION\
    \ num_lines)\n    * bit odd, since \"rows_to_go\" seems to be redundantly keeping\
    \ track of\n    * output_scanline.\n    */\n-  upsample->rows_to_go = cinfo->output_height\
    \ - cinfo->output_scanline;\n+  if (master->using_merged_upsample) {\n+    my_merged_upsample_ptr\
    \ upsample = (my_merged_upsample_ptr)cinfo->upsample;\n+    upsample->rows_to_go\
    \ = cinfo->output_height - cinfo->output_scanline;\n+  } else {\n+    my_upsample_ptr\
    \ upsample = (my_upsample_ptr)cinfo->upsample;\n+    upsample->rows_to_go = cinfo->output_height\
    \ - cinfo->output_scanline;\n+  }\n \n   /* Always skip the requested number of\
    \ lines. */\n   return num_lines;"
  - "--- a/jdmerge.c\n+++ b/jdmerge.c\n@@ -5,7 +5,7 @@\n  * Copyright (C) 1994-1996,\
    \ Thomas G. Lane.\n  * libjpeg-turbo Modifications:\n  * Copyright 2009 Pierre\
    \ Ossman <ossman@cendio.se> for Cendio AB\n- * Copyright (C) 2009, 2011, 2014-2015,\
    \ D. R. Commander.\n+ * Copyright (C) 2009, 2011, 2014-2015, 2020, D. R. Commander.\n\
    \  * Copyright (C) 2013, Linaro Limited.\n  * For conditions of distribution and\
    \ use, see the accompanying README.ijg\n  * file.\n@@ -40,41 +40,13 @@\n #define\
    \ JPEG_INTERNALS\n #include \"jinclude.h\"\n #include \"jpeglib.h\"\n+#include\
    \ \"jdmerge.h\"\n #include \"jsimd.h\"\n #include \"jconfigint.h\"\n \n #ifdef\
    \ UPSAMPLE_MERGING_SUPPORTED\n \n \n-/* Private subobject */\n-\n-typedef struct\
    \ {\n-  struct jpeg_upsampler pub;    /* public fields */\n-\n-  /* Pointer to\
    \ routine to do actual upsampling/conversion of one row group */\n-  void (*upmethod)\
    \ (j_decompress_ptr cinfo, JSAMPIMAGE input_buf,\n-                    JDIMENSION\
    \ in_row_group_ctr, JSAMPARRAY output_buf);\n-\n-  /* Private state for YCC->RGB\
    \ conversion */\n-  int *Cr_r_tab;                /* => table for Cr to R conversion\
    \ */\n-  int *Cb_b_tab;                /* => table for Cb to B conversion */\n\
    -  JLONG *Cr_g_tab;              /* => table for Cr to G conversion */\n-  JLONG\
    \ *Cb_g_tab;              /* => table for Cb to G conversion */\n-\n-  /* For\
    \ 2:1 vertical sampling, we produce two output rows at a time.\n-   * We need\
    \ a \"spare\" row buffer to hold the second output row if the\n-   * application\
    \ provides just a one-row buffer; we also use the spare\n-   * to discard the\
    \ dummy last row if the image height is odd.\n-   */\n-  JSAMPROW spare_row;\n\
    -  boolean spare_full;           /* T if spare buffer is occupied */\n-\n-  JDIMENSION\
    \ out_row_width;     /* samples per output row */\n-  JDIMENSION rows_to_go; \
    \       /* counts rows remaining in image */\n-} my_upsampler;\n-\n-typedef my_upsampler\
    \ *my_upsample_ptr;\n-\n #define SCALEBITS       16      /* speediest right-shift\
    \ on some machines */\n #define ONE_HALF        ((JLONG)1 << (SCALEBITS - 1))\n\
    \ #define FIX(x)          ((JLONG)((x) * (1L << SCALEBITS) + 0.5))\n@@ -189,7\
    \ +161,7 @@ typedef my_upsampler *my_upsample_ptr;\n LOCAL(void)\n build_ycc_rgb_table(j_decompress_ptr\
    \ cinfo)\n {\n-  my_upsample_ptr upsample = (my_upsample_ptr)cinfo->upsample;\n\
    +  my_merged_upsample_ptr upsample = (my_merged_upsample_ptr)cinfo->upsample;\n\
    \   int i;\n   JLONG x;\n   SHIFT_TEMPS\n@@ -232,7 +204,7 @@ build_ycc_rgb_table(j_decompress_ptr\
    \ cinfo)\n METHODDEF(void)\n start_pass_merged_upsample(j_decompress_ptr cinfo)\n\
    \ {\n-  my_upsample_ptr upsample = (my_upsample_ptr)cinfo->upsample;\n+  my_merged_upsample_ptr\
    \ upsample = (my_merged_upsample_ptr)cinfo->upsample;\n \n   /* Mark the spare\
    \ buffer empty */\n   upsample->spare_full = FALSE;\n@@ -254,7 +226,7 @@ merged_2v_upsample(j_decompress_ptr\
    \ cinfo, JSAMPIMAGE input_buf,\n                    JDIMENSION *out_row_ctr, JDIMENSION\
    \ out_rows_avail)\n /* 2:1 vertical sampling case: may need a spare row. */\n\
    \ {\n-  my_upsample_ptr upsample = (my_upsample_ptr)cinfo->upsample;\n+  my_merged_upsample_ptr\
    \ upsample = (my_merged_upsample_ptr)cinfo->upsample;\n   JSAMPROW work_ptrs[2];\n\
    \   JDIMENSION num_rows;          /* number of rows returned to caller */\n \n\
    @@ -305,7 +277,7 @@ merged_1v_upsample(j_decompress_ptr cinfo, JSAMPIMAGE input_buf,\n\
    \                    JDIMENSION *out_row_ctr, JDIMENSION out_rows_avail)\n /*\
    \ 1:1 vertical sampling case: much easier, never need a spare row. */\n {\n- \
    \ my_upsample_ptr upsample = (my_upsample_ptr)cinfo->upsample;\n+  my_merged_upsample_ptr\
    \ upsample = (my_merged_upsample_ptr)cinfo->upsample;\n \n   /* Just do the upsampling.\
    \ */\n   (*upsample->upmethod) (cinfo, input_buf, *in_row_group_ctr,\n@@ -566,11\
    \ +538,11 @@ h2v2_merged_upsample_565D(j_decompress_ptr cinfo, JSAMPIMAGE input_buf,\n\
    \ GLOBAL(void)\n jinit_merged_upsampler(j_decompress_ptr cinfo)\n {\n-  my_upsample_ptr\
    \ upsample;\n+  my_merged_upsample_ptr upsample;\n \n-  upsample = (my_upsample_ptr)\n\
    +  upsample = (my_merged_upsample_ptr)\n     (*cinfo->mem->alloc_small) ((j_common_ptr)cinfo,\
    \ JPOOL_IMAGE,\n-                                sizeof(my_upsampler));\n+   \
    \                             sizeof(my_merged_upsampler));\n   cinfo->upsample\
    \ = (struct jpeg_upsampler *)upsample;\n   upsample->pub.start_pass = start_pass_merged_upsample;\n\
    \   upsample->pub.need_context_rows = FALSE;"
  - "--- a/jdmrg565.c\n+++ b/jdmrg565.c\n@@ -5,7 +5,7 @@\n  * Copyright (C) 1994-1996,\
    \ Thomas G. Lane.\n  * libjpeg-turbo Modifications:\n  * Copyright (C) 2013, Linaro\
    \ Limited.\n- * Copyright (C) 2014-2015, 2018, D. R. Commander.\n+ * Copyright\
    \ (C) 2014-2015, 2018, 2020, D. R. Commander.\n  * For conditions of distribution\
    \ and use, see the accompanying README.ijg\n  * file.\n  *\n@@ -19,7 +19,7 @@\
    \ h2v1_merged_upsample_565_internal(j_decompress_ptr cinfo, JSAMPIMAGE input_buf,\n\
    \                                   JDIMENSION in_row_group_ctr,\n           \
    \                        JSAMPARRAY output_buf)\n {\n-  my_upsample_ptr upsample\
    \ = (my_upsample_ptr)cinfo->upsample;\n+  my_merged_upsample_ptr upsample = (my_merged_upsample_ptr)cinfo->upsample;\n\
    \   register int y, cred, cgreen, cblue;\n   int cb, cr;\n   register JSAMPROW\
    \ outptr;\n@@ -90,7 +90,7 @@ h2v1_merged_upsample_565D_internal(j_decompress_ptr\
    \ cinfo,\n                                    JDIMENSION in_row_group_ctr,\n \
    \                                   JSAMPARRAY output_buf)\n {\n-  my_upsample_ptr\
    \ upsample = (my_upsample_ptr)cinfo->upsample;\n+  my_merged_upsample_ptr upsample\
    \ = (my_merged_upsample_ptr)cinfo->upsample;\n   register int y, cred, cgreen,\
    \ cblue;\n   int cb, cr;\n   register JSAMPROW outptr;\n@@ -163,7 +163,7 @@ h2v2_merged_upsample_565_internal(j_decompress_ptr\
    \ cinfo, JSAMPIMAGE input_buf,\n                                   JDIMENSION\
    \ in_row_group_ctr,\n                                   JSAMPARRAY output_buf)\n\
    \ {\n-  my_upsample_ptr upsample = (my_upsample_ptr)cinfo->upsample;\n+  my_merged_upsample_ptr\
    \ upsample = (my_merged_upsample_ptr)cinfo->upsample;\n   register int y, cred,\
    \ cgreen, cblue;\n   int cb, cr;\n   register JSAMPROW outptr0, outptr1;\n@@ -259,7\
    \ +259,7 @@ h2v2_merged_upsample_565D_internal(j_decompress_ptr cinfo,\n     \
    \                               JDIMENSION in_row_group_ctr,\n               \
    \                     JSAMPARRAY output_buf)\n {\n-  my_upsample_ptr upsample\
    \ = (my_upsample_ptr)cinfo->upsample;\n+  my_merged_upsample_ptr upsample = (my_merged_upsample_ptr)cinfo->upsample;\n\
    \   register int y, cred, cgreen, cblue;\n   int cb, cr;\n   register JSAMPROW\
    \ outptr0, outptr1;"
  - "--- a/jdmrgext.c\n+++ b/jdmrgext.c\n@@ -4,7 +4,7 @@\n  * This file was part of\
    \ the Independent JPEG Group's software:\n  * Copyright (C) 1994-1996, Thomas\
    \ G. Lane.\n  * libjpeg-turbo Modifications:\n- * Copyright (C) 2011, 2015, D.\
    \ R. Commander.\n+ * Copyright (C) 2011, 2015, 2020, D. R. Commander.\n  * For\
    \ conditions of distribution and use, see the accompanying README.ijg\n  * file.\n\
    \  *\n@@ -25,7 +25,7 @@ h2v1_merged_upsample_internal(j_decompress_ptr cinfo,\
    \ JSAMPIMAGE input_buf,\n                               JDIMENSION in_row_group_ctr,\n\
    \                               JSAMPARRAY output_buf)\n {\n-  my_upsample_ptr\
    \ upsample = (my_upsample_ptr)cinfo->upsample;\n+  my_merged_upsample_ptr upsample\
    \ = (my_merged_upsample_ptr)cinfo->upsample;\n   register int y, cred, cgreen,\
    \ cblue;\n   int cb, cr;\n   register JSAMPROW outptr;\n@@ -97,7 +97,7 @@ h2v2_merged_upsample_internal(j_decompress_ptr\
    \ cinfo, JSAMPIMAGE input_buf,\n                               JDIMENSION in_row_group_ctr,\n\
    \                               JSAMPARRAY output_buf)\n {\n-  my_upsample_ptr\
    \ upsample = (my_upsample_ptr)cinfo->upsample;\n+  my_merged_upsample_ptr upsample\
    \ = (my_merged_upsample_ptr)cinfo->upsample;\n   register int y, cred, cgreen,\
    \ cblue;\n   int cb, cr;\n   register JSAMPROW outptr0, outptr1;"
  identifiers:
  - CVE-2020-35538
  - CWE-476
  overview: A crafted input file could cause a null pointer dereference in jcopy_sample_rows()
    when processed by libjpeg-turbo.
  references:
  - source: secalert@redhat.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/libjpeg-turbo/libjpeg-turbo/commit/9120a247436e84c0b4eea828cb11e8f665fcde30
  - source: secalert@redhat.com
    tags:
    - Issue Tracking
    - Third Party Advisory
    url: https://github.com/libjpeg-turbo/libjpeg-turbo/issues/441
  title: A crafted input file could cause a null pointer dereference in jcopy_sample_rows()
    when processed by libjpeg-turbo.
- diff_content:
  - "--- a/net/ax25/af_ax25.c\n+++ b/net/ax25/af_ax25.c\n@@ -1053,6 +1053,11 @@ static\
    \ int ax25_release(struct socket *sock)\n \t\tax25_destroy_socket(ax25);\n \t\
    }\n \tif (ax25_dev) {\n+\t\tdel_timer_sync(&ax25->timer);\n+\t\tdel_timer_sync(&ax25->t1timer);\n\
    +\t\tdel_timer_sync(&ax25->t2timer);\n+\t\tdel_timer_sync(&ax25->t3timer);\n+\t\
    \tdel_timer_sync(&ax25->idletimer);\n \t\tdev_put_track(ax25_dev->dev, &ax25_dev->dev_tracker);\n\
    \ \t\tax25_dev_put(ax25_dev);\n \t}"
  - "--- a/net/ax25/ax25_subr.c\n+++ b/net/ax25/ax25_subr.c\n@@ -261,12 +261,20 @@\
    \ void ax25_disconnect(ax25_cb *ax25, int reason)\n {\n \tax25_clear_queues(ax25);\n\
    \ \n-\tif (!ax25->sk || !sock_flag(ax25->sk, SOCK_DESTROY))\n-\t\tax25_stop_heartbeat(ax25);\n\
    -\tax25_stop_t1timer(ax25);\n-\tax25_stop_t2timer(ax25);\n-\tax25_stop_t3timer(ax25);\n\
    -\tax25_stop_idletimer(ax25);\n+\tif (reason == ENETUNREACH) {\n+\t\tdel_timer_sync(&ax25->timer);\n\
    +\t\tdel_timer_sync(&ax25->t1timer);\n+\t\tdel_timer_sync(&ax25->t2timer);\n+\t\
    \tdel_timer_sync(&ax25->t3timer);\n+\t\tdel_timer_sync(&ax25->idletimer);\n+\t\
    } else {\n+\t\tif (!ax25->sk || !sock_flag(ax25->sk, SOCK_DESTROY))\n+\t\t\tax25_stop_heartbeat(ax25);\n\
    +\t\tax25_stop_t1timer(ax25);\n+\t\tax25_stop_t2timer(ax25);\n+\t\tax25_stop_t3timer(ax25);\n\
    +\t\tax25_stop_idletimer(ax25);\n+\t}\n \n \tax25->state = AX25_STATE_0;\n "
  identifiers:
  - CVE-2022-1205
  - CWE-476
  overview: "A NULL pointer dereference flaw was found in the Linux kernel\u2019s\
    \ Amateur Radio AX.25 protocol functionality in the way a user connects with the\
    \ protocol. This flaw allows a local user to crash the system."
  references:
  - source: secalert@redhat.com
    tags:
    - Third Party Advisory
    url: https://access.redhat.com/security/cve/CVE-2022-1205
  - source: secalert@redhat.com
    tags:
    - Issue Tracking
    - Patch
    - Third Party Advisory
    url: https://bugzilla.redhat.com/show_bug.cgi?id=2071047
  - source: secalert@redhat.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/torvalds/linux/commit/82e31755e55fbcea6a9dfaae5fe4860ade17cbc0
  - source: secalert@redhat.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/torvalds/linux/commit/fc6d01ff9ef03b66d4a3a23b46fc3c3d8cf92009
  - source: secalert@redhat.com
    tags:
    - Exploit
    - Mailing List
    - Third Party Advisory
    url: https://www.openwall.com/lists/oss-security/2022/04/02/4
  title: "A NULL pointer dereference flaw was found in the Linux kernel\u2019s Amateur\
    \ Radio AX.25 protocol functionality in the way a user connects with the protocol.\
    \ This flaw allows a local user to crash the system."
- diff_content:
  - "--- a/libtiff/tif_dirread.c\n+++ b/libtiff/tif_dirread.c\n@@ -3794,50 +3794,7\
    \ @@ TIFFReadDirectory(TIFF* tif)\n \t\tMissingRequired(tif,\"ImageLength\");\n\
    \ \t\tgoto bad;\n \t}\n-\t/*\n-\t * Setup appropriate structures (by strip or\
    \ by tile)\n-\t */\n-\tif (!TIFFFieldSet(tif, FIELD_TILEDIMENSIONS)) {\n-\t\t\
    tif->tif_dir.td_nstrips = TIFFNumberOfStrips(tif);  \n-\t\ttif->tif_dir.td_tilewidth\
    \ = tif->tif_dir.td_imagewidth;\n-\t\ttif->tif_dir.td_tilelength = tif->tif_dir.td_rowsperstrip;\n\
    -\t\ttif->tif_dir.td_tiledepth = tif->tif_dir.td_imagedepth;\n-\t\ttif->tif_flags\
    \ &= ~TIFF_ISTILED;\n-\t} else {\n-\t\ttif->tif_dir.td_nstrips = TIFFNumberOfTiles(tif);\n\
    -\t\ttif->tif_flags |= TIFF_ISTILED;\n-\t}\n-\tif (!tif->tif_dir.td_nstrips) {\n\
    -\t\tTIFFErrorExt(tif->tif_clientdata, module,\n-\t\t    \"Cannot handle zero\
    \ number of %s\",\n-\t\t    isTiled(tif) ? \"tiles\" : \"strips\");\n-\t\tgoto\
    \ bad;\n-\t}\n-\ttif->tif_dir.td_stripsperimage = tif->tif_dir.td_nstrips;\n-\t\
    if (tif->tif_dir.td_planarconfig == PLANARCONFIG_SEPARATE)\n-\t\ttif->tif_dir.td_stripsperimage\
    \ /= tif->tif_dir.td_samplesperpixel;\n-\tif (!TIFFFieldSet(tif, FIELD_STRIPOFFSETS))\
    \ {\n-#ifdef OJPEG_SUPPORT\n-\t\tif ((tif->tif_dir.td_compression==COMPRESSION_OJPEG)\
    \ &&\n-\t\t    (isTiled(tif)==0) &&\n-\t\t    (tif->tif_dir.td_nstrips==1)) {\n\
    -\t\t\t/*\n-\t\t\t * XXX: OJPEG hack.\n-\t\t\t * If a) compression is OJPEG, b)\
    \ it's not a tiled TIFF,\n-\t\t\t * and c) the number of strips is 1,\n-\t\t\t\
    \ * then we tolerate the absence of stripoffsets tag,\n-\t\t\t * because, presumably,\
    \ all required data is in the\n-\t\t\t * JpegInterchangeFormat stream.\n-\t\t\t\
    \ */\n-\t\t\tTIFFSetFieldBit(tif, FIELD_STRIPOFFSETS);\n-\t\t} else\n-#endif\n\
    -        {\n-\t\t\tMissingRequired(tif,\n-\t\t\t\tisTiled(tif) ? \"TileOffsets\"\
    \ : \"StripOffsets\");\n-\t\t\tgoto bad;\n-\t\t}\n-\t}\n+\n \t/*\n \t * Second\
    \ pass: extract other information.\n \t */\n@@ -4042,41 +3999,6 @@ TIFFReadDirectory(TIFF*\
    \ tif)\n \t\t\t} /* -- if (!dp->tdir_ignore) */\n \t\t} /* -- for-loop -- */\n\
    \ \n-        if( tif->tif_mode == O_RDWR &&\n-            tif->tif_dir.td_stripoffset_entry.tdir_tag\
    \ != 0 &&\n-            tif->tif_dir.td_stripoffset_entry.tdir_count == 0 &&\n\
    -            tif->tif_dir.td_stripoffset_entry.tdir_type == 0 &&\n-          \
    \  tif->tif_dir.td_stripoffset_entry.tdir_offset.toff_long8 == 0 &&\n-       \
    \     tif->tif_dir.td_stripbytecount_entry.tdir_tag != 0 &&\n-            tif->tif_dir.td_stripbytecount_entry.tdir_count\
    \ == 0 &&\n-            tif->tif_dir.td_stripbytecount_entry.tdir_type == 0 &&\n\
    -            tif->tif_dir.td_stripbytecount_entry.tdir_offset.toff_long8 == 0\
    \ )\n-        {\n-            /* Directory typically created with TIFFDeferStrileArrayWriting()\
    \ */\n-            TIFFSetupStrips(tif);\n-        }\n-        else if( !(tif->tif_flags&TIFF_DEFERSTRILELOAD)\
    \ )\n-        {\n-            if( tif->tif_dir.td_stripoffset_entry.tdir_tag !=\
    \ 0 )\n-            {\n-                if (!TIFFFetchStripThing(tif,&(tif->tif_dir.td_stripoffset_entry),\n\
    -                                         tif->tif_dir.td_nstrips,\n-        \
    \                                 &tif->tif_dir.td_stripoffset_p))\n-        \
    \        {\n-                    goto bad;\n-                }\n-            }\n\
    -            if( tif->tif_dir.td_stripbytecount_entry.tdir_tag != 0 )\n-     \
    \       {\n-                if (!TIFFFetchStripThing(tif,&(tif->tif_dir.td_stripbytecount_entry),\n\
    -                                         tif->tif_dir.td_nstrips,\n-        \
    \                                 &tif->tif_dir.td_stripbytecount_p))\n-     \
    \           {\n-                    goto bad;\n-                }\n-         \
    \   }\n-        }\n-\n \t/*\n \t * OJPEG hack:\n \t * - If a) compression is OJPEG,\
    \ and b) photometric tag is missing,\n@@ -4147,6 +4069,88 @@ TIFFReadDirectory(TIFF*\
    \ tif)\n \t\t}\n \t}\n \n+\t/*\n+\t * Setup appropriate structures (by strip or\
    \ by tile)\n+\t * We do that only after the above OJPEG hack which alters SamplesPerPixel\n\
    +\t * and thus influences the number of strips in the separate planarconfig.\n\
    +\t */\n+\tif (!TIFFFieldSet(tif, FIELD_TILEDIMENSIONS)) {\n+\t\ttif->tif_dir.td_nstrips\
    \ = TIFFNumberOfStrips(tif);  \n+\t\ttif->tif_dir.td_tilewidth = tif->tif_dir.td_imagewidth;\n\
    +\t\ttif->tif_dir.td_tilelength = tif->tif_dir.td_rowsperstrip;\n+\t\ttif->tif_dir.td_tiledepth\
    \ = tif->tif_dir.td_imagedepth;\n+\t\ttif->tif_flags &= ~TIFF_ISTILED;\n+\t} else\
    \ {\n+\t\ttif->tif_dir.td_nstrips = TIFFNumberOfTiles(tif);\n+\t\ttif->tif_flags\
    \ |= TIFF_ISTILED;\n+\t}\n+\tif (!tif->tif_dir.td_nstrips) {\n+\t\tTIFFErrorExt(tif->tif_clientdata,\
    \ module,\n+\t\t    \"Cannot handle zero number of %s\",\n+\t\t    isTiled(tif)\
    \ ? \"tiles\" : \"strips\");\n+\t\tgoto bad;\n+\t}\n+\ttif->tif_dir.td_stripsperimage\
    \ = tif->tif_dir.td_nstrips;\n+\tif (tif->tif_dir.td_planarconfig == PLANARCONFIG_SEPARATE)\n\
    +\t\ttif->tif_dir.td_stripsperimage /= tif->tif_dir.td_samplesperpixel;\n+\tif\
    \ (!TIFFFieldSet(tif, FIELD_STRIPOFFSETS)) {\n+#ifdef OJPEG_SUPPORT\n+\t\tif ((tif->tif_dir.td_compression==COMPRESSION_OJPEG)\
    \ &&\n+\t\t    (isTiled(tif)==0) &&\n+\t\t    (tif->tif_dir.td_nstrips==1)) {\n\
    +\t\t\t/*\n+\t\t\t * XXX: OJPEG hack.\n+\t\t\t * If a) compression is OJPEG, b)\
    \ it's not a tiled TIFF,\n+\t\t\t * and c) the number of strips is 1,\n+\t\t\t\
    \ * then we tolerate the absence of stripoffsets tag,\n+\t\t\t * because, presumably,\
    \ all required data is in the\n+\t\t\t * JpegInterchangeFormat stream.\n+\t\t\t\
    \ */\n+\t\t\tTIFFSetFieldBit(tif, FIELD_STRIPOFFSETS);\n+\t\t} else\n+#endif\n\
    +        {\n+\t\t\tMissingRequired(tif,\n+\t\t\t\tisTiled(tif) ? \"TileOffsets\"\
    \ : \"StripOffsets\");\n+\t\t\tgoto bad;\n+\t\t}\n+\t}\n+\n+        if( tif->tif_mode\
    \ == O_RDWR &&\n+            tif->tif_dir.td_stripoffset_entry.tdir_tag != 0 &&\n\
    +            tif->tif_dir.td_stripoffset_entry.tdir_count == 0 &&\n+         \
    \   tif->tif_dir.td_stripoffset_entry.tdir_type == 0 &&\n+            tif->tif_dir.td_stripoffset_entry.tdir_offset.toff_long8\
    \ == 0 &&\n+            tif->tif_dir.td_stripbytecount_entry.tdir_tag != 0 &&\n\
    +            tif->tif_dir.td_stripbytecount_entry.tdir_count == 0 &&\n+      \
    \      tif->tif_dir.td_stripbytecount_entry.tdir_type == 0 &&\n+            tif->tif_dir.td_stripbytecount_entry.tdir_offset.toff_long8\
    \ == 0 )\n+        {\n+            /* Directory typically created with TIFFDeferStrileArrayWriting()\
    \ */\n+            TIFFSetupStrips(tif);\n+        }\n+        else if( !(tif->tif_flags&TIFF_DEFERSTRILELOAD)\
    \ )\n+        {\n+            if( tif->tif_dir.td_stripoffset_entry.tdir_tag !=\
    \ 0 )\n+            {\n+                if (!TIFFFetchStripThing(tif,&(tif->tif_dir.td_stripoffset_entry),\n\
    +                                         tif->tif_dir.td_nstrips,\n+        \
    \                                 &tif->tif_dir.td_stripoffset_p))\n+        \
    \        {\n+                    goto bad;\n+                }\n+            }\n\
    +            if( tif->tif_dir.td_stripbytecount_entry.tdir_tag != 0 )\n+     \
    \       {\n+                if (!TIFFFetchStripThing(tif,&(tif->tif_dir.td_stripbytecount_entry),\n\
    +                                         tif->tif_dir.td_nstrips,\n+        \
    \                                 &tif->tif_dir.td_stripbytecount_p))\n+     \
    \           {\n+                    goto bad;\n+                }\n+         \
    \   }\n+        }\n+\n \t/*\n \t * Make sure all non-color channels are extrasamples.\n\
    \ \t * If it's not the case, define them as such.\n"
  identifiers:
  - CVE-2022-1354
  - CWE-125
  overview: A heap buffer overflow flaw was found in Libtiffs' tiffinfo.c in TIFFReadRawDataStriped()
    function. This flaw allows an attacker to pass a crafted TIFF file to the tiffinfo
    tool, triggering a heap buffer overflow issue and causing a crash that leads to
    a denial of service.
  references:
  - source: secalert@redhat.com
    tags:
    - Issue Tracking
    - Third Party Advisory
    url: https://access.redhat.com/security/cve/CVE-2022-1354
  - source: secalert@redhat.com
    tags:
    - Exploit
    - Issue Tracking
    - Patch
    - Third Party Advisory
    url: https://bugzilla.redhat.com/show_bug.cgi?id=2074404
  - source: secalert@redhat.com
    tags:
    - Patch
    url: https://gitlab.com/libtiff/libtiff/-/commit/87f580f39011109b3bb5f6eca13fac543a542798
  - source: secalert@redhat.com
    tags:
    - Exploit
    - Issue Tracking
    - Patch
    - Third Party Advisory
    url: https://gitlab.com/libtiff/libtiff/-/issues/319
  - source: secalert@redhat.com
    tags:
    - Mailing List
    - Third Party Advisory
    url: https://lists.debian.org/debian-lts-announce/2023/01/msg00018.html
  - source: secalert@redhat.com
    tags:
    - Third Party Advisory
    url: https://security.gentoo.org/glsa/202210-10
  - source: secalert@redhat.com
    tags:
    - Third Party Advisory
    url: https://security.netapp.com/advisory/ntap-20221014-0007/
  - source: secalert@redhat.com
    tags:
    - Third Party Advisory
    url: https://www.debian.org/security/2023/dsa-5333
  title: A heap buffer overflow flaw was found in Libtiffs' tiffinfo.c in TIFFReadRawDataStriped()
    function. This flaw allows an attacker to pass a crafted TIFF file to the tiffinfo
    tool, triggering a heap buffer overflow issue and causing a crash that leads to
    a denial of service.
- diff_content:
  - "--- a/net/nfc/core.c\n+++ b/net/nfc/core.c\n@@ -38,7 +38,7 @@ int nfc_fw_download(struct\
    \ nfc_dev *dev, const char *firmware_name)\n \n \tdevice_lock(&dev->dev);\n \n\
    -\tif (!device_is_registered(&dev->dev)) {\n+\tif (dev->shutting_down) {\n \t\t\
    rc = -ENODEV;\n \t\tgoto error;\n \t}\n@@ -94,7 +94,7 @@ int nfc_dev_up(struct\
    \ nfc_dev *dev)\n \n \tdevice_lock(&dev->dev);\n \n-\tif (!device_is_registered(&dev->dev))\
    \ {\n+\tif (dev->shutting_down) {\n \t\trc = -ENODEV;\n \t\tgoto error;\n \t}\n\
    @@ -142,7 +142,7 @@ int nfc_dev_down(struct nfc_dev *dev)\n \n \tdevice_lock(&dev->dev);\n\
    \ \n-\tif (!device_is_registered(&dev->dev)) {\n+\tif (dev->shutting_down) {\n\
    \ \t\trc = -ENODEV;\n \t\tgoto error;\n \t}\n@@ -207,7 +207,7 @@ int nfc_start_poll(struct\
    \ nfc_dev *dev, u32 im_protocols, u32 tm_protocols)\n \n \tdevice_lock(&dev->dev);\n\
    \ \n-\tif (!device_is_registered(&dev->dev)) {\n+\tif (dev->shutting_down) {\n\
    \ \t\trc = -ENODEV;\n \t\tgoto error;\n \t}\n@@ -246,7 +246,7 @@ int nfc_stop_poll(struct\
    \ nfc_dev *dev)\n \n \tdevice_lock(&dev->dev);\n \n-\tif (!device_is_registered(&dev->dev))\
    \ {\n+\tif (dev->shutting_down) {\n \t\trc = -ENODEV;\n \t\tgoto error;\n \t}\n\
    @@ -291,7 +291,7 @@ int nfc_dep_link_up(struct nfc_dev *dev, int target_index,\
    \ u8 comm_mode)\n \n \tdevice_lock(&dev->dev);\n \n-\tif (!device_is_registered(&dev->dev))\
    \ {\n+\tif (dev->shutting_down) {\n \t\trc = -ENODEV;\n \t\tgoto error;\n \t}\n\
    @@ -335,7 +335,7 @@ int nfc_dep_link_down(struct nfc_dev *dev)\n \n \tdevice_lock(&dev->dev);\n\
    \ \n-\tif (!device_is_registered(&dev->dev)) {\n+\tif (dev->shutting_down) {\n\
    \ \t\trc = -ENODEV;\n \t\tgoto error;\n \t}\n@@ -401,7 +401,7 @@ int nfc_activate_target(struct\
    \ nfc_dev *dev, u32 target_idx, u32 protocol)\n \n \tdevice_lock(&dev->dev);\n\
    \ \n-\tif (!device_is_registered(&dev->dev)) {\n+\tif (dev->shutting_down) {\n\
    \ \t\trc = -ENODEV;\n \t\tgoto error;\n \t}\n@@ -448,7 +448,7 @@ int nfc_deactivate_target(struct\
    \ nfc_dev *dev, u32 target_idx, u8 mode)\n \n \tdevice_lock(&dev->dev);\n \n-\t\
    if (!device_is_registered(&dev->dev)) {\n+\tif (dev->shutting_down) {\n \t\trc\
    \ = -ENODEV;\n \t\tgoto error;\n \t}\n@@ -495,7 +495,7 @@ int nfc_data_exchange(struct\
    \ nfc_dev *dev, u32 target_idx, struct sk_buff *skb,\n \n \tdevice_lock(&dev->dev);\n\
    \ \n-\tif (!device_is_registered(&dev->dev)) {\n+\tif (dev->shutting_down) {\n\
    \ \t\trc = -ENODEV;\n \t\tkfree_skb(skb);\n \t\tgoto error;\n@@ -552,7 +552,7\
    \ @@ int nfc_enable_se(struct nfc_dev *dev, u32 se_idx)\n \n \tdevice_lock(&dev->dev);\n\
    \ \n-\tif (!device_is_registered(&dev->dev)) {\n+\tif (dev->shutting_down) {\n\
    \ \t\trc = -ENODEV;\n \t\tgoto error;\n \t}\n@@ -601,7 +601,7 @@ int nfc_disable_se(struct\
    \ nfc_dev *dev, u32 se_idx)\n \n \tdevice_lock(&dev->dev);\n \n-\tif (!device_is_registered(&dev->dev))\
    \ {\n+\tif (dev->shutting_down) {\n \t\trc = -ENODEV;\n \t\tgoto error;\n \t}\n\
    @@ -1134,6 +1134,7 @@ int nfc_register_device(struct nfc_dev *dev)\n \t\t\tdev->rfkill\
    \ = NULL;\n \t\t}\n \t}\n+\tdev->shutting_down = false;\n \tdevice_unlock(&dev->dev);\n\
    \ \n \trc = nfc_genl_device_added(dev);\n@@ -1166,12 +1167,10 @@ void nfc_unregister_device(struct\
    \ nfc_dev *dev)\n \t\trfkill_unregister(dev->rfkill);\n \t\trfkill_destroy(dev->rfkill);\n\
    \ \t}\n+\tdev->shutting_down = true;\n \tdevice_unlock(&dev->dev);\n \n \tif (dev->ops->check_presence)\
    \ {\n-\t\tdevice_lock(&dev->dev);\n-\t\tdev->shutting_down = true;\n-\t\tdevice_unlock(&dev->dev);\n\
    \ \t\tdel_timer_sync(&dev->check_pres_timer);\n \t\tcancel_work_sync(&dev->check_pres_work);\n\
    \ \t}"
  identifiers:
  - CVE-2022-1974
  - CWE-367
  overview: A use-after-free flaw was found in the Linux kernel's NFC core functionality
    due to a race condition between kobject creation and delete. This vulnerability
    allows a local attacker with CAP_NET_ADMIN privilege to leak kernel information.
  references:
  - source: secalert@redhat.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/torvalds/linux/commit/da5c0f119203ad9728920456a0f52a6d850c01cd
  title: A use-after-free flaw was found in the Linux kernel's NFC core functionality
    due to a race condition between kobject creation and delete. This vulnerability
    allows a local attacker with CAP_NET_ADMIN privilege to leak kernel information.
- diff_content:
  - "--- a/net/nfc/netlink.c\n+++ b/net/nfc/netlink.c\n@@ -1244,7 +1244,7 @@ int nfc_genl_fw_download_done(struct\
    \ nfc_dev *dev, const char *firmware_name,\n \tstruct sk_buff *msg;\n \tvoid *hdr;\n\
    \ \n-\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n+\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE,\
    \ GFP_ATOMIC);\n \tif (!msg)\n \t\treturn -ENOMEM;\n \n@@ -1260,7 +1260,7 @@ int\
    \ nfc_genl_fw_download_done(struct nfc_dev *dev, const char *firmware_name,\n\
    \ \n \tgenlmsg_end(msg, hdr);\n \n-\tgenlmsg_multicast(&nfc_genl_family, msg,\
    \ 0, 0, GFP_KERNEL);\n+\tgenlmsg_multicast(&nfc_genl_family, msg, 0, 0, GFP_ATOMIC);\n\
    \ \n \treturn 0;\n "
  identifiers:
  - CVE-2022-1975
  - NVD-CWE-noinfo
  overview: There is a sleep-in-atomic bug in /net/nfc/netlink.c that allows an attacker
    to crash the Linux kernel by simulating a nfc device from user-space.
  references:
  - source: secalert@redhat.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/torvalds/linux/commit/4071bf121d59944d5cd2238de0642f3d7995a997
  title: There is a sleep-in-atomic bug in /net/nfc/netlink.c that allows an attacker
    to crash the Linux kernel by simulating a nfc device from user-space.
- diff_content:
  - "--- a/arch/x86/kvm/lapic.c\n+++ b/arch/x86/kvm/lapic.c\n@@ -1024,6 +1024,10 @@\
    \ bool kvm_irq_delivery_to_apic_fast(struct kvm *kvm, struct kvm_lapic *src,\n\
    \ \t*r = -1;\n \n \tif (irq->shorthand == APIC_DEST_SELF) {\n+\t\tif (KVM_BUG_ON(!src,\
    \ kvm)) {\n+\t\t\t*r = 0;\n+\t\t\treturn true;\n+\t\t}\n \t\t*r = kvm_apic_set_irq(src->vcpu,\
    \ irq, dest_map);\n \t\treturn true;\n \t}"
  - "--- a/arch/x86/kvm/hyperv.c\n+++ b/arch/x86/kvm/hyperv.c\n@@ -449,6 +449,9 @@\
    \ static int synic_set_irq(struct kvm_vcpu_hv_synic *synic, u32 sint)\n \tstruct\
    \ kvm_lapic_irq irq;\n \tint ret, vector;\n \n+\tif (KVM_BUG_ON(!lapic_in_kernel(vcpu),\
    \ vcpu->kvm))\n+\t\treturn -EINVAL;\n+\n \tif (sint >= ARRAY_SIZE(synic->sint))\n\
    \ \t\treturn -EINVAL;\n "
  - "--- a/arch/x86/kvm/hyperv.c\n+++ b/arch/x86/kvm/hyperv.c\n@@ -239,7 +239,7 @@\
    \ static int synic_set_msr(struct kvm_vcpu_hv_synic *synic,\n \tstruct kvm_vcpu\
    \ *vcpu = hv_synic_to_vcpu(synic);\n \tint ret;\n \n-\tif (!synic->active && !host)\n\
    +\tif (!synic->active && (!host || data))\n \t\treturn 1;\n \n \ttrace_kvm_hv_synic_set_msr(vcpu->vcpu_id,\
    \ msr, data, host);\n@@ -285,6 +285,9 @@ static int synic_set_msr(struct kvm_vcpu_hv_synic\
    \ *synic,\n \tcase HV_X64_MSR_EOM: {\n \t\tint i;\n \n+\t\tif (!synic->active)\n\
    +\t\t\tbreak;\n+\n \t\tfor (i = 0; i < ARRAY_SIZE(synic->sint); i++)\n \t\t\t\
    kvm_hv_notify_acked_sint(vcpu, i);\n \t\tbreak;\n@@ -664,7 +667,7 @@ static int\
    \ stimer_set_config(struct kvm_vcpu_hv_stimer *stimer, u64 config,\n \tstruct\
    \ kvm_vcpu_hv *hv_vcpu = to_hv_vcpu(vcpu);\n \tstruct kvm_vcpu_hv_synic *synic\
    \ = to_hv_synic(vcpu);\n \n-\tif (!synic->active && !host)\n+\tif (!synic->active\
    \ && (!host || config))\n \t\treturn 1;\n \n \tif (unlikely(!host && hv_vcpu->enforce_cpuid\
    \ && new_config.direct_mode &&\n@@ -693,7 +696,7 @@ static int stimer_set_count(struct\
    \ kvm_vcpu_hv_stimer *stimer, u64 count,\n \tstruct kvm_vcpu *vcpu = hv_stimer_to_vcpu(stimer);\n\
    \ \tstruct kvm_vcpu_hv_synic *synic = to_hv_synic(vcpu);\n \n-\tif (!synic->active\
    \ && !host)\n+\tif (!synic->active && (!host || count))\n \t\treturn 1;\n \n \t\
    trace_kvm_hv_stimer_set_count(hv_stimer_to_vcpu(stimer)->vcpu_id,"
  identifiers:
  - CVE-2022-2153
  - CWE-476
  overview: "A flaw was found in the Linux kernel\u2019s KVM when attempting to set\
    \ a SynIC IRQ. This issue makes it possible for a misbehaving VMM to write to\
    \ SYNIC/STIMER MSRs, causing a NULL pointer dereference. This flaw allows an unprivileged\
    \ local attacker on the host to issue specific ioctl calls, causing a kernel oops\
    \ condition that results in a denial of service."
  references:
  - source: secalert@redhat.com
    tags:
    - Issue Tracking
    - Patch
    - Third Party Advisory
    url: https://bugzilla.redhat.com/show_bug.cgi?id=2069736
  - source: secalert@redhat.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/torvalds/linux/commit/00b5f37189d24ac3ed46cb7f11742094778c46ce
  - source: secalert@redhat.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/torvalds/linux/commit/7ec37d1cbe17d8189d9562178d8b29167fe1c31a
  - source: secalert@redhat.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/torvalds/linux/commit/b1e34d325397a33d97d845e312d7cf2a8b646b44
  - source: secalert@redhat.com
    tags:
    - Mailing List
    - Third Party Advisory
    url: https://lists.debian.org/debian-lts-announce/2022/10/msg00000.html
  - source: secalert@redhat.com
    tags:
    - Mailing List
    - Third Party Advisory
    url: https://lists.debian.org/debian-lts-announce/2022/11/msg00001.html
  - source: secalert@redhat.com
    tags:
    - Exploit
    - Mailing List
    - Patch
    - Third Party Advisory
    url: https://www.openwall.com/lists/oss-security/2022/06/22/1
  title: "A flaw was found in the Linux kernel\u2019s KVM when attempting to set a\
    \ SynIC IRQ. This issue makes it possible for a misbehaving VMM to write to SYNIC/STIMER\
    \ MSRs, causing a NULL pointer dereference. This flaw allows an unprivileged local\
    \ attacker on the host to issue specific ioctl calls, causing a kernel oops condition\
    \ that results in a denial of service."
- diff_content:
  - "--- a/net/key/af_key.c\n+++ b/net/key/af_key.c\n@@ -1697,9 +1697,12 @@ static\
    \ int pfkey_register(struct sock *sk, struct sk_buff *skb, const struct sad\n\
    \ \t\tpfk->registered |= (1<<hdr->sadb_msg_satype);\n \t}\n \n+\tmutex_lock(&pfkey_mutex);\n\
    \ \txfrm_probe_algs();\n \n \tsupp_skb = compose_sadb_supported(hdr, GFP_KERNEL\
    \ | __GFP_ZERO);\n+\tmutex_unlock(&pfkey_mutex);\n+\n \tif (!supp_skb) {\n \t\t\
    if (hdr->sadb_msg_satype != SADB_SATYPE_UNSPEC)\n \t\t\tpfk->registered &= ~(1<<hdr->sadb_msg_satype);"
  identifiers:
  - CVE-2022-3028
  - CWE-362
  overview: A race condition was found in the Linux kernel's IP framework for transforming
    packets (XFRM subsystem) when multiple calls to xfrm_probe_algs occurred simultaneously.
    This flaw could allow a local attacker to potentially trigger an out-of-bounds
    write or leak kernel heap memory by performing an out-of-bounds read and copying
    it into a socket.
  references:
  - source: secalert@redhat.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/torvalds/linux/commit/ba953a9d89a00c078b85f4b190bc1dde66fe16b5
  - source: secalert@redhat.com
    tags:
    - Mailing List
    - Third Party Advisory
    url: https://lists.debian.org/debian-lts-announce/2022/10/msg00000.html
  - source: secalert@redhat.com
    tags:
    - Mailing List
    - Third Party Advisory
    url: https://lists.debian.org/debian-lts-announce/2022/11/msg00001.html
  - source: secalert@redhat.com
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/F3MYP7WX4PNE6RCITVXA43CECBZT4CL6/
  - source: secalert@redhat.com
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/JKVA75UHKVOHNOEPCLUHTFGWCOOUBDM3/
  - source: secalert@redhat.com
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/PEQYVCNYUWB4CJ2YRAYNF2GGFQ7SUYC4/
  - source: secalert@redhat.com
    url: https://lore.kernel.org/all/YtoWqEkKzvimzWS5%40gondor.apana.org.au/T/
  - source: secalert@redhat.com
    tags:
    - Third Party Advisory
    url: https://security.netapp.com/advisory/ntap-20230214-0004/
  title: A race condition was found in the Linux kernel's IP framework for transforming
    packets (XFRM subsystem) when multiple calls to xfrm_probe_algs occurred simultaneously.
    This flaw could allow a local attacker to potentially trigger an out-of-bounds
    write or leak kernel heap memory by performing an out-of-bounds read and copying
    it into a socket.
- diff_content:
  - "--- a/src/x3f/x3f_utils_patched.cpp\n+++ b/src/x3f/x3f_utils_patched.cpp\n@@\
    \ -179,6 +179,7 @@ static void new_huffman_tree(x3f_hufftree_t *HTP, int bits)\n\
    \   int leaves = 1 << bits;\n \n   HTP->free_node_index = 0;\n+  HTP->total_node_index\
    \ = HUF_TREE_MAX_NODES(leaves);\n   HTP->nodes = (x3f_huffnode_t *)calloc(1, HUF_TREE_MAX_NODES(leaves)\
    \ *\n                                                sizeof(x3f_huffnode_t));\n\
    \ }\n@@ -708,6 +709,8 @@ static char *display_code(int length, uint32_t code,\
    \ char *buffer)\n \n static x3f_huffnode_t *new_node(x3f_hufftree_t *tree)\n {\n\
    +\tif (tree->free_node_index >= tree->total_node_index)\n+\t\tthrow LIBRAW_EXCEPTION_IO_CORRUPT;\n\
    \   x3f_huffnode_t *t = &tree->nodes[tree->free_node_index];\n \n   t->branch[0]\
    \ = NULL;"
  identifiers:
  - CVE-2020-35530
  - CWE-787
  overview: In LibRaw, there is an out-of-bounds write vulnerability within the "new_node()"
    function (libraw\src\x3f\x3f_utils_patched.cpp) that can be triggered via a crafted
    X3F file.
  references:
  - source: secalert@redhat.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/LibRaw/LibRaw/commit/11c4db253ef2c9bb44247b578f5caa57c66a1eeb
  - source: secalert@redhat.com
    tags:
    - Exploit
    - Issue Tracking
    - Patch
    - Third Party Advisory
    url: https://github.com/LibRaw/LibRaw/issues/272
  - source: secalert@redhat.com
    tags:
    - Mailing List
    - Third Party Advisory
    url: https://lists.debian.org/debian-lts-announce/2022/09/msg00024.html
  title: In LibRaw, there is an out-of-bounds write vulnerability within the "new_node()"
    function (libraw\src\x3f\x3f_utils_patched.cpp) that can be triggered via a crafted
    X3F file.
- diff_content:
  - "--- a/src/x3f/x3f_utils_patched.cpp\n+++ b/src/x3f/x3f_utils_patched.cpp\n@@\
    \ -1042,6 +1042,8 @@ static void huffman_decode_row(x3f_info_t *I, x3f_directory_entry_t\
    \ *DE,\n   int col;\n   bit_state_t BS;\n \n+  if (HUF->row_offsets.element[row]\
    \ > ID->data_size - 1)\n+\t  throw LIBRAW_EXCEPTION_IO_CORRUPT;\n   set_bit_state(&BS,\
    \ (uint8_t *)ID->data + HUF->row_offsets.element[row]);\n \n   for (col = 0; col\
    \ < ID->columns; col++)"
  identifiers:
  - CVE-2020-35531
  - CWE-125
  overview: In LibRaw, an out-of-bounds read vulnerability exists within the get_huffman_diff()
    function (libraw\src\x3f\x3f_utils_patched.cpp) when reading data from an image
    file.
  references:
  - source: secalert@redhat.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/LibRaw/LibRaw/commit/d75af00681a74dcc8b929207eb895611a6eceb68
  - source: secalert@redhat.com
    tags:
    - Issue Tracking
    - Patch
    - Third Party Advisory
    url: https://github.com/LibRaw/LibRaw/issues/270
  - source: secalert@redhat.com
    tags:
    - Mailing List
    - Third Party Advisory
    url: https://lists.debian.org/debian-lts-announce/2022/09/msg00024.html
  title: In LibRaw, an out-of-bounds read vulnerability exists within the get_huffman_diff()
    function (libraw\src\x3f\x3f_utils_patched.cpp) when reading data from an image
    file.
- diff_content:
  - "--- a/src/x3f/x3f_utils_patched.cpp\n+++ b/src/x3f/x3f_utils_patched.cpp\n@@\
    \ -1122,6 +1122,8 @@ static void simple_decode_row(x3f_info_t *I, x3f_directory_entry_t\
    \ *DE,\n   x3f_image_data_t *ID = &DEH->data_subsection.image_data;\n   x3f_huffman_t\
    \ *HUF = ID->huffman;\n \n+  if (row*row_stride > ID->data_size - (ID->columns*sizeof(uint32_t)))\n\
    +\t  throw LIBRAW_EXCEPTION_IO_CORRUPT;\n   uint32_t *data = (uint32_t *)((unsigned\
    \ char *)ID->data + row * row_stride);\n \n   uint16_t c[3] = {0, 0, 0};"
  identifiers:
  - CVE-2020-35532
  - CWE-125
  overview: In LibRaw, an out-of-bounds read vulnerability exists within the "simple_decode_row()"
    function (libraw\src\x3f\x3f_utils_patched.cpp) which can be triggered via an
    image with a large row_stride field.
  references:
  - source: secalert@redhat.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/LibRaw/LibRaw/commit/5ab45b085898e379fedc6b113e2e82a890602b1e
  - source: secalert@redhat.com
    tags:
    - Exploit
    - Issue Tracking
    - Patch
    - Third Party Advisory
    url: https://github.com/LibRaw/LibRaw/issues/271
  - source: secalert@redhat.com
    tags:
    - Mailing List
    - Third Party Advisory
    url: https://lists.debian.org/debian-lts-announce/2022/09/msg00024.html
  title: In LibRaw, an out-of-bounds read vulnerability exists within the "simple_decode_row()"
    function (libraw\src\x3f\x3f_utils_patched.cpp) which can be triggered via an
    image with a large row_stride field.
- diff_content:
  - "--- a/src/decoders/decoders_dcraw.cpp\n+++ b/src/decoders/decoders_dcraw.cpp\n\
    @@ -344,7 +344,7 @@ int LibRaw::ljpeg_start(struct jhead *jh, int info_only)\n\
    \     FORC(4) jh->huff[2 + c] = jh->huff[1];\n     FORC(jh->sraw) jh->huff[1 +\
    \ c] = jh->huff[0];\n   }\n-  jh->row = (ushort *)calloc(jh->wide * jh->clrs,\
    \ 4);\n+  jh->row = (ushort *)calloc(jh->wide * jh->clrs, 16);\n   merror(jh->row,\
    \ \"ljpeg_start()\");\n   return zero_after_ff = 1;\n }"
  identifiers:
  - CVE-2020-35533
  - CWE-125
  overview: In LibRaw, an out-of-bounds read vulnerability exists within the "LibRaw::adobe_copy_pixel()"
    function (libraw\src\decoders\dng.cpp) when reading data from the image file.
  references:
  - source: secalert@redhat.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/LibRaw/LibRaw/commit/a6937d4046a7c4742b683a04c8564605fd9be4fb
  - source: secalert@redhat.com
    tags:
    - Issue Tracking
    - Patch
    - Third Party Advisory
    url: https://github.com/LibRaw/LibRaw/issues/273
  - source: secalert@redhat.com
    tags:
    - Mailing List
    - Third Party Advisory
    url: https://lists.debian.org/debian-lts-announce/2022/09/msg00024.html
  title: In LibRaw, an out-of-bounds read vulnerability exists within the "LibRaw::adobe_copy_pixel()"
    function (libraw\src\decoders\dng.cpp) when reading data from the image file.
- diff_content:
  - "--- a/src/decoders/crx.cpp\n+++ b/src/decoders/crx.cpp\n@@ -153,6 +153,10 @@\
    \ struct CrxImage\n   int16_t *outBufs[4]; // one per plane\r\n   int16_t *planeBuf;\r\
    \n   LibRaw_abstract_datastream *input;\r\n+#ifdef LIBRAW_CR3_MEMPOOL\r\n+  libraw_memmgr\
    \ memmgr;\r\n+  CrxImage() : memmgr(0){}\r\n+#endif\r\n };\r\n \r\n enum TileFlags\r\
    \n@@ -1737,14 +1741,22 @@ void crxConvertPlaneLine(CrxImage *img, int imageRow,\
    \ int imageCol = 0,\n   }\r\n }\r\n \r\n-int crxParamInit(CrxBandParam **param,\
    \ uint64_t subbandMdatOffset,\r\n+int crxParamInit(\r\n+#ifdef LIBRAW_CR3_MEMPOOL\r\
    \n+\tlibraw_memmgr&  mm,\r\n+#endif\t\r\n+\tCrxBandParam **param, uint64_t subbandMdatOffset,\r\
    \n                  uint64_t subbandDataSize, uint32_t subbandWidth,\r\n     \
    \             uint32_t subbandHeight, int32_t supportsPartial,\r\n           \
    \       uint32_t roundedBitsMask, LibRaw_abstract_datastream *input)\r\n {\r\n\
    \   int32_t progrDataSize = supportsPartial ? 0 : sizeof(int32_t) * subbandWidth;\r\
    \n   int32_t paramLength = 2 * subbandWidth + 4;\r\n-  uint8_t *paramBuf = (uint8_t\
    \ *)calloc(\r\n+  uint8_t *paramBuf = (uint8_t *)\r\n+#ifdef LIBRAW_CR3_MEMPOOL\r\
    \n+\t  mm.\r\n+#endif\r\n+\t  calloc(\r\n       1, sizeof(CrxBandParam) + sizeof(int32_t)\
    \ * paramLength + progrDataSize);\r\n \r\n   if (!paramBuf)\r\n@@ -1813,7 +1825,11\
    \ @@ int crxSetupSubbandData(CrxImage *img, CrxPlaneComp *planeComp,\n   }\r\n\
    \ \r\n   // buffer allocation\r\n-  planeComp->compBuf = (uint8_t *)malloc(compDataSize);\r\
    \n+  planeComp->compBuf = (uint8_t *)\r\n+#ifdef LIBRAW_CR3_MEMPOOL\r\n+\t  img->memmgr.\r\
    \n+#endif\r\n+\t  malloc(compDataSize);\r\n   if (!planeComp->compBuf)\r\n   \
    \  return -1;\r\n \r\n@@ -1895,7 +1911,11 @@ int crxSetupSubbandData(CrxImage\
    \ *img, CrxPlaneComp *planeComp,\n         roundedBitsMask = planeComp->roundedBitsMask;\r\
    \n         supportsPartial = 1;\r\n       }\r\n-      if (crxParamInit(&subbands[subbandNum].bandParam,\r\
    \n+      if (crxParamInit(\r\n+#ifdef LIBRAW_CR3_MEMPOOL\r\n+\t\t  img->memmgr,\r\
    \n+#endif\r\n+\t\t  &subbands[subbandNum].bandParam,\r\n                     \
    \   subbands[subbandNum].mdatOffset,\r\n                        subbands[subbandNum].dataSize,\r\
    \n                        subbands[subbandNum].width, subbands[subbandNum].height,\r\
    \n@@ -2087,10 +2107,14 @@ int crxReadImageHeaders(crx_data_header_t *hdr, CrxImage\
    \ *img, uint8_t *mdatPtr,\n \r\n   if (!img->tiles)\r\n   {\r\n-    img->tiles\
    \ = (CrxTile *)malloc(\r\n+    img->tiles = (CrxTile *)\r\n+#ifdef LIBRAW_CR3_MEMPOOL\r\
    \n+\t\timg->memmgr.\r\n+#endif\r\n+\t\tcalloc(\r\n         sizeof(CrxTile) * nTiles\
    \ +\r\n         sizeof(CrxPlaneComp) * nTiles * img->nPlanes +\r\n-        sizeof(CrxSubband)\
    \ * nTiles * img->nPlanes * img->subbandCount);\r\n+        sizeof(CrxSubband)\
    \ * nTiles * img->nPlanes * img->subbandCount,1);\r\n     if (!img->tiles)\r\n\
    \       return -1;\r\n \r\n@@ -2282,7 +2306,11 @@ int crxSetupImageData(crx_data_header_t\
    \ *hdr, CrxImage *img, int16_t *outBuf,\n   if (img->encType == 3 && img->nPlanes\
    \ == 4 && img->nBits > 8)\r\n   {\r\n     img->planeBuf =\r\n-        (int16_t\
    \ *)malloc(img->planeHeight * img->planeWidth * img->nPlanes *\r\n+        (int16_t\
    \ *)\r\n+#ifdef LIBRAW_CR3_MEMPOOL\r\n+\t\timg->memmgr.\r\n+#endif\r\n+\t\tmalloc(img->planeHeight\
    \ * img->planeWidth * img->nPlanes *\r\n                           ((img->samplePrecision\
    \ + 7) >> 3));\r\n     if (!img->planeBuf)\r\n       return -1;\r\n@@ -2335,6\
    \ +2363,9 @@ int crxSetupImageData(crx_data_header_t *hdr, CrxImage *img, int16_t\
    \ *outBuf,\n \r\n int crxFreeImageData(CrxImage *img)\r\n {\r\n+#ifdef LIBRAW_CR3_MEMPOOL\r\
    \n+\timg->memmgr.cleanup();\r\n+#else\r\n   CrxTile *tile = img->tiles;\r\n  \
    \ int nTiles = img->tileRows * img->tileCols;\r\n \r\n@@ -2353,9 +2384,10 @@ int\
    \ crxFreeImageData(CrxImage *img)\n     free(img->planeBuf);\r\n     img->planeBuf\
    \ = 0;\r\n   }\r\n-\r\n+#endif\r\n   return 0;\r\n }\r\n+\r\n void LibRaw::crxLoadDecodeLoop(void\
    \ *img, int nPlanes)\r\n {\r\n #ifdef LIBRAW_USE_OPENMP\r"
  identifiers:
  - CVE-2020-35534
  - CWE-770
  overview: In LibRaw, there is a memory corruption vulnerability within the "crxFreeSubbandData()"
    function (libraw\src\decoders\crx.cpp) when processing cr3 files.
  references:
  - source: secalert@redhat.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/LibRaw/LibRaw/commit/e41f331e90b383e3208cefb74e006df44bf3a4b8
  - source: secalert@redhat.com
    tags:
    - Issue Tracking
    - Patch
    - Third Party Advisory
    url: https://github.com/LibRaw/LibRaw/issues/279
  title: In LibRaw, there is a memory corruption vulnerability within the "crxFreeSubbandData()"
    function (libraw\src\decoders\crx.cpp) when processing cr3 files.
- diff_content:
  - "--- a/src/metadata/sony.cpp\n+++ b/src/metadata/sony.cpp\n@@ -1799,6 +1799,14\
    \ @@ void LibRaw::parseSonySR2(uchar *cbuf_SR2, unsigned SR2SubIFDOffset,\n  \
    \ float num;\n   int i;\n   int WBCTC_count;\n+#define CHECKBUFFER_N(offset,N)\
    \                                     \\\n+  do                              \
    \                                  \\\n+  {                                  \
    \                               \\\n+    if ((((offset) + (N)) > SR2SubIFDLength)\
    \ || ((offset) < 0))     \\\n+      return;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n+ \
    \ } while (0)\n+\n+  CHECKBUFFER_N(0, 2);\n   entries = sget2(cbuf_SR2);\n   if\
    \ (entries > 1000)\n     return;\n@@ -1812,43 +1820,52 @@ void LibRaw::parseSonySR2(uchar\
    \ *cbuf_SR2, unsigned SR2SubIFDOffset,\n       if (dng_writer == nonDNG) {\n \
    \        switch (tag_id) {\n         case 0x7300:\n-          FORC4 cblack[c]\
    \ = sget2(cbuf_SR2 + tag_dataoffset + tag_dataunitlen * c);\n+\t\t\tCHECKBUFFER_N(tag_dataoffset\
    \ + tag_dataunitlen * 4,0);\n+\t\t\tFORC4 cblack[c] = sget2(cbuf_SR2 + tag_dataoffset\
    \ + tag_dataunitlen * c);\n           TagProcessed = 1;\n           break;\n \
    \        case 0x7303:\n-          FORC4 cam_mul[GRBG_2_RGBG(c)] = sget2(cbuf_SR2\
    \ + tag_dataoffset + tag_dataunitlen * c);\n+\t\t\tCHECKBUFFER_N(tag_dataoffset\
    \ + tag_dataunitlen * 4, 0);\n+\t\t\tFORC4 cam_mul[GRBG_2_RGBG(c)] = sget2(cbuf_SR2\
    \ + tag_dataoffset + tag_dataunitlen * c);\n           TagProcessed = 1;\n   \
    \        break;\n         case 0x7310:\n-          FORC4 cblack[RGGB_2_RGBG(c)]\
    \ = sget2(cbuf_SR2 + tag_dataoffset + tag_dataunitlen * c);\n+\t\t\tCHECKBUFFER_N(tag_dataoffset\
    \ + tag_dataunitlen * 4, 0);\n+\t\t\tFORC4 cblack[RGGB_2_RGBG(c)] = sget2(cbuf_SR2\
    \ + tag_dataoffset + tag_dataunitlen * c);\n           i = cblack[3];\n      \
    \     FORC3 if (i > cblack[c]) i = cblack[c];\n           FORC4 cblack[c] -= i;\n\
    \           black = i;\n           TagProcessed = 1;\n           break;\n    \
    \     case 0x7313:\n-          FORC4 cam_mul[RGGB_2_RGBG(c)] = sget2(cbuf_SR2\
    \ + tag_dataoffset + tag_dataunitlen * c);\n+\t\t\tCHECKBUFFER_N(tag_dataoffset\
    \ + tag_dataunitlen * 4, 0);\n+\t\t\tFORC4 cam_mul[RGGB_2_RGBG(c)] = sget2(cbuf_SR2\
    \ + tag_dataoffset + tag_dataunitlen * c);\n           TagProcessed = 1;\n   \
    \        break;\n         case 0x74a0:\n-          ilm.MaxAp4MaxFocal = sgetreal(tag_type,\
    \ cbuf_SR2 + tag_dataoffset);\n+\t\t\tCHECKBUFFER_N(tag_dataoffset, 4);\n+\t\t\
    \tilm.MaxAp4MaxFocal = sgetreal(tag_type, cbuf_SR2 + tag_dataoffset);\n      \
    \     TagProcessed = 1;\n           break;\n         case 0x74a1:\n-         \
    \ ilm.MaxAp4MinFocal = sgetreal(tag_type, cbuf_SR2 + tag_dataoffset);\n+\t\t\t\
    CHECKBUFFER_N(tag_dataoffset, 4);\n+\t\t\tilm.MaxAp4MinFocal = sgetreal(tag_type,\
    \ cbuf_SR2 + tag_dataoffset);\n           TagProcessed = 1;\n           break;\n\
    \         case 0x74a2:\n-          ilm.MaxFocal = sgetreal(tag_type, cbuf_SR2\
    \ + tag_dataoffset);\n+\t\t\tCHECKBUFFER_N(tag_dataoffset, 4);\n+\t\t\tilm.MaxFocal\
    \ = sgetreal(tag_type, cbuf_SR2 + tag_dataoffset);\n           TagProcessed =\
    \ 1;\n           break;\n         case 0x74a3:\n-          ilm.MinFocal = sgetreal(tag_type,\
    \ cbuf_SR2 + tag_dataoffset);\n+\t\t\tCHECKBUFFER_N(tag_dataoffset, 4);\n+\t\t\
    \tilm.MinFocal = sgetreal(tag_type, cbuf_SR2 + tag_dataoffset);\n           TagProcessed\
    \ = 1;\n           break;\n         case 0x7800:\n-          for (i = 0; i < 3;\
    \ i++)\n+\t\t\tCHECKBUFFER_N(tag_dataoffset + tag_dataunitlen * 8, 2);\n+\t\t\
    \  for (i = 0; i < 3; i++)\n           {\n             num = 0.0;\n          \
    \   for (c = 0; c < 3; c++)\n@@ -1865,12 +1882,14 @@ void LibRaw::parseSonySR2(uchar\
    \ *cbuf_SR2, unsigned SR2SubIFDOffset,\n         case 0x787f:\n           if (tag_datalen\
    \ == 3)\n           {\n-            FORC3 imgdata.color.linear_max[c] = sget2(cbuf_SR2\
    \ + tag_dataoffset + tag_dataunitlen * c);\n+\t\t\t  CHECKBUFFER_N(tag_dataoffset\
    \ + tag_dataunitlen * 2, 2);\n+\t\t\t  FORC3 imgdata.color.linear_max[c] = sget2(cbuf_SR2\
    \ + tag_dataoffset + tag_dataunitlen * c);\n             imgdata.color.linear_max[3]\
    \ = imgdata.color.linear_max[1];\n           }\n           else if (tag_datalen\
    \ == 1)\n           {\n-            imgdata.color.linear_max[0] = imgdata.color.linear_max[1]\
    \ =\n+\t\t\t  CHECKBUFFER_N(tag_dataoffset, 2);\n+\t\t\t  imgdata.color.linear_max[0]\
    \ = imgdata.color.linear_max[1] =\n                 imgdata.color.linear_max[2]\
    \ = imgdata.color.linear_max[3] =\n                     sget2(cbuf_SR2 + tag_dataoffset);\n\
    \           }\n@@ -1884,37 +1903,44 @@ void LibRaw::parseSonySR2(uchar *cbuf_SR2,\
    \ unsigned SR2SubIFDOffset,\n           i = tag_id - 0x7480;\n           if (Sony_SR2_wb_list[i]\
    \ > 255) {\n             icWBCCTC[WBCTC_count][0] = Sony_SR2_wb_list[i];\n-  \
    \          FORC3 icWBCCTC[WBCTC_count][c + 1] = sget2(cbuf_SR2 + tag_dataoffset\
    \ + tag_dataunitlen * c);\n+\t\t\tCHECKBUFFER_N(tag_dataoffset + tag_dataunitlen\
    \ * 2, 2);\n+\t\t\tFORC3 icWBCCTC[WBCTC_count][c + 1] = sget2(cbuf_SR2 + tag_dataoffset\
    \ + tag_dataunitlen * c);\n             icWBCCTC[WBCTC_count][4] = icWBCCTC[WBCTC_count][2];\n\
    \             WBCTC_count++;\n           } else {\n-            FORC3 icWBC[Sony_SR2_wb_list[i]][c]\
    \ = sget2(cbuf_SR2 + tag_dataoffset + tag_dataunitlen * c);\n+\t\t\t  CHECKBUFFER_N(tag_dataoffset\
    \ + tag_dataunitlen * 2, 2);\n+\t\t\t  FORC3 icWBC[Sony_SR2_wb_list[i]][c] = sget2(cbuf_SR2\
    \ + tag_dataoffset + tag_dataunitlen * c);\n             icWBC[Sony_SR2_wb_list[i]][3]\
    \ = icWBC[Sony_SR2_wb_list[i]][1];\n           }\n         } else if ((tag_id\
    \ >= 0x7820) && (tag_id <= 0x782d)) {\n           i = tag_id - 0x7820;\n     \
    \      if (Sony_SR2_wb_list1[i] > 255) {\n             icWBCCTC[WBCTC_count][0]\
    \ = Sony_SR2_wb_list1[i];\n-            FORC3 icWBCCTC[WBCTC_count][c + 1] = sget2(cbuf_SR2\
    \ + tag_dataoffset + tag_dataunitlen * c);\n+\t\t\tCHECKBUFFER_N(tag_dataoffset\
    \ + tag_dataunitlen * 2, 2);\n+\t\t\tFORC3 icWBCCTC[WBCTC_count][c + 1] = sget2(cbuf_SR2\
    \ + tag_dataoffset + tag_dataunitlen * c);\n             icWBCCTC[WBCTC_count][4]\
    \ = icWBCCTC[WBCTC_count][2];\n             if (Sony_SR2_wb_list1[i] == 3200)\
    \ {\n               FORC3 icWBC[LIBRAW_WBI_StudioTungsten][c] = icWBCCTC[WBCTC_count][c\
    \ + 1];\n               icWBC[LIBRAW_WBI_StudioTungsten][3] = icWBC[LIBRAW_WBI_StudioTungsten][1];\n\
    \             }\n             WBCTC_count++;\n           } else {\n-         \
    \   FORC3 icWBC[Sony_SR2_wb_list1[i]][c] = sget2(cbuf_SR2 + tag_dataoffset + tag_dataunitlen\
    \ * c);\n+\t\t\t  CHECKBUFFER_N(tag_dataoffset + tag_dataunitlen * 2, 2);\n+\t\
    \t\t  FORC3 icWBC[Sony_SR2_wb_list1[i]][c] = sget2(cbuf_SR2 + tag_dataoffset +\
    \ tag_dataunitlen * c);\n             icWBC[Sony_SR2_wb_list1[i]][3] = icWBC[Sony_SR2_wb_list1[i]][1];\n\
    \           }\n         } else if (tag_id == 0x7302) {\n-          FORC4 icWBC[LIBRAW_WBI_Auto][GRBG_2_RGBG(c)]\
    \ = sget2(cbuf_SR2 + tag_dataoffset + tag_dataunitlen * c);\n+\t\t\tCHECKBUFFER_N(tag_dataoffset\
    \ + tag_dataunitlen * 3, 2);\n+\t\t\tFORC4 icWBC[LIBRAW_WBI_Auto][GRBG_2_RGBG(c)]\
    \ = sget2(cbuf_SR2 + tag_dataoffset + tag_dataunitlen * c);\n         } else if\
    \ (tag_id == 0x7312) {\n-          FORC4 icWBC[LIBRAW_WBI_Auto][RGGB_2_RGBG(c)]\
    \ = sget2(cbuf_SR2 + tag_dataoffset + tag_dataunitlen * c);\n+\t\t\tCHECKBUFFER_N(tag_dataoffset\
    \ + tag_dataunitlen * 3, 2);\n+\t\t\tFORC4 icWBC[LIBRAW_WBI_Auto][RGGB_2_RGBG(c)]\
    \ = sget2(cbuf_SR2 + tag_dataoffset + tag_dataunitlen * c);\n         }\n    \
    \   }\n     }\n   }\n }\n+#undef CHECKBUFFER_N\n \n void LibRaw::parseSonySRF(unsigned\
    \ len)\n {\n@@ -1935,10 +1961,10 @@ void LibRaw::parseSonySRF(unsigned len)\n\
    \   INT64 srf_offset, tag_offset, tag_data, tag_dataoffset;\n   int tag_dataunitlen;\n\
    \   uchar *srf_buf;\n-  short entries;\n+  ushort entries;\n   unsigned tag_id,\
    \ tag_type, tag_datalen;\n \n-  srf_buf = (uchar *)malloc(len);\n+  srf_buf =\
    \ (uchar *)malloc(len+64);\n   fread(srf_buf, len, 1, ifp);\n \n   offset += srf_buf[offset]\
    \ << 2;\n@@ -1995,9 +2021,11 @@ void LibRaw::parseSonySRF(unsigned len)\n    \
    \                &tag_offset, &tag_id, &tag_type, &tag_dataoffset,\n         \
    \           &tag_datalen, &tag_dataunitlen) == 0) {\n       if (tag_id == 0x0000)\
    \ {\n-        SRF2Key = sget4(srf_buf + tag_dataoffset);\n+\t\t  CHECKBUFFER_SGET4(tag_dataoffset);\n\
    +\t\t  SRF2Key = sget4(srf_buf + tag_dataoffset);\n       } else if (tag_id ==\
    \ 0x0001) {\n-        RawDataKey = sget4(srf_buf + tag_dataoffset);\n+\t\t  CHECKBUFFER_SGET4(tag_dataoffset);\n\
    +\t\t  RawDataKey = sget4(srf_buf + tag_dataoffset);\n       }\n     } else goto\
    \ restore_after_parseSonySRF;\n   }\n@@ -2019,20 +2047,22 @@ void LibRaw::parseSonySRF(unsigned\
    \ len)\n   tag_offset = offset;\n \n   while (entries--) {\n-    if (tiff_sget\
    \ (save, srf_buf, len,\n+\t  if (tiff_sget(save, srf_buf, len,\n             \
    \       &tag_offset, &tag_id, &tag_type, &tag_dataoffset,\n                  \
    \  &tag_datalen, &tag_dataunitlen) == 0) {\n       if ((tag_id >= 0x00c0) && (tag_id\
    \ <= 0x00ce)) {\n         i = (tag_id - 0x00c0) % 3;\n         nWB = (tag_id -\
    \ 0x00c0) / 3;\n-        icWBC[Sony_SRF_wb_list[nWB]][i] = sget4(srf_buf + tag_dataoffset);\n\
    +\t\tCHECKBUFFER_SGET4(tag_dataoffset);\n+\t\ticWBC[Sony_SRF_wb_list[nWB]][i]\
    \ = sget4(srf_buf + tag_dataoffset);\n         if (i == 1) {\n           icWBC[Sony_SRF_wb_list[nWB]][3]\
    \ =\n             icWBC[Sony_SRF_wb_list[nWB]][i];\n         }\n       } else\
    \ if ((tag_id >= 0x00d0) && (tag_id <= 0x00d2)) {\n         i = (tag_id - 0x00d0)\
    \ % 3;\n-        cam_mul[i] = sget4(srf_buf + tag_dataoffset);\n+\t\tCHECKBUFFER_SGET4(tag_dataoffset);\n\
    +\t\tcam_mul[i] = sget4(srf_buf + tag_dataoffset);\n         if (i == 1) {\n \
    \          cam_mul[3] = cam_mul[i];\n         }\n@@ -2044,16 +2074,20 @@ void\
    \ LibRaw::parseSonySRF(unsigned len)\n         0x0005  RawDataLength\n       \
    \  */\n       case 0x0043:\n-        ilm.MaxAp4MaxFocal = sgetreal(tag_type, srf_buf\
    \ + tag_dataoffset);\n+\t\t  CHECKBUFFER_SGET4(tag_dataoffset); // need to add\
    \ extra space\n+\t\t  ilm.MaxAp4MaxFocal = sgetreal(tag_type, srf_buf + tag_dataoffset);\n\
    \         break;\n       case 0x0044:\n-         ilm.MaxAp4MinFocal = sgetreal(tag_type,\
    \ srf_buf + tag_dataoffset);\n+\t\t  CHECKBUFFER_SGET4(tag_dataoffset);\n+\t\t\
    \  ilm.MaxAp4MinFocal = sgetreal(tag_type, srf_buf + tag_dataoffset);\n      \
    \   break;\n       case 0x0045:\n-        ilm.MinFocal = sgetreal(tag_type, srf_buf\
    \ + tag_dataoffset);\n+\t\t  CHECKBUFFER_SGET4(tag_dataoffset);\n+\t\t  ilm.MinFocal\
    \ = sgetreal(tag_type, srf_buf + tag_dataoffset);\n         break;\n       case\
    \ 0x0046:\n-        ilm.MaxFocal = sgetreal(tag_type, srf_buf + tag_dataoffset);\n\
    +\t\t  CHECKBUFFER_SGET4(tag_dataoffset);\n+\t\t  ilm.MaxFocal = sgetreal(tag_type,\
    \ srf_buf + tag_dataoffset);\n         break;\n       }\n     } else goto restore_after_parseSonySRF;"
  identifiers:
  - CVE-2020-35535
  - CWE-125
  overview: In LibRaw, there is an out-of-bounds read vulnerability within the "LibRaw::parseSonySRF()"
    function (libraw\src\metadata\sony.cpp) when processing srf files.
  references:
  - source: secalert@redhat.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/LibRaw/LibRaw/commit/c243f4539233053466c1309bde606815351bee81
  - source: secalert@redhat.com
    tags:
    - Exploit
    - Issue Tracking
    - Patch
    - Third Party Advisory
    url: https://github.com/LibRaw/LibRaw/issues/283
  title: In LibRaw, there is an out-of-bounds read vulnerability within the "LibRaw::parseSonySRF()"
    function (libraw\src\metadata\sony.cpp) when processing srf files.
- diff_content:
  - "--- a/net/openvswitch/flow_netlink.c\n+++ b/net/openvswitch/flow_netlink.c\n\
    @@ -2465,7 +2465,7 @@ static struct nlattr *reserve_sfa_size(struct sw_flow_actions\
    \ **sfa,\n \tnew_acts_size = max(next_offset + req_size, ksize(*sfa) * 2);\n \n\
    \ \tif (new_acts_size > MAX_ACTIONS_BUFSIZE) {\n-\t\tif ((MAX_ACTIONS_BUFSIZE\
    \ - next_offset) < req_size) {\n+\t\tif ((next_offset + req_size) > MAX_ACTIONS_BUFSIZE)\
    \ {\n \t\t\tOVS_NLERR(log, \"Flow action size exceeds max %u\",\n \t\t\t\t  MAX_ACTIONS_BUFSIZE);\n\
    \ \t\t\treturn ERR_PTR(-EMSGSIZE);"
  identifiers:
  - CVE-2022-2639
  - CWE-681
  overview: An integer coercion error was found in the openvswitch kernel module.
    Given a sufficiently large number of actions, while copying and reserving memory
    for a new action of a new flow, the reserve_sfa_size() function does not return
    -EMSGSIZE as expected, potentially leading to an out-of-bounds write access. This
    flaw allows a local user to crash or potentially escalate their privileges on
    the system.
  references:
  - source: secalert@redhat.com
    tags:
    - Issue Tracking
    - Patch
    - Third Party Advisory
    url: https://bugzilla.redhat.com/show_bug.cgi?id=2084479
  - source: secalert@redhat.com
    tags:
    - Exploit
    - Patch
    url: https://github.com/torvalds/linux/commit/cefa91b2332d7009bc0be5d951d6cbbf349f90f8
  title: An integer coercion error was found in the openvswitch kernel module. Given
    a sufficiently large number of actions, while copying and reserving memory for
    a new action of a new flow, the reserve_sfa_size() function does not return -EMSGSIZE
    as expected, potentially leading to an out-of-bounds write access. This flaw allows
    a local user to crash or potentially escalate their privileges on the system.
- diff_content:
  - "--- a/arch/x86/kvm/svm/svm.c\n+++ b/arch/x86/kvm/svm/svm.c\n@@ -4263,6 +4263,8\
    \ @@ static int svm_check_intercept(struct kvm_vcpu *vcpu,\n \n static void svm_handle_exit_irqoff(struct\
    \ kvm_vcpu *vcpu)\n {\n+\tif (to_svm(vcpu)->vmcb->control.exit_code == SVM_EXIT_INTR)\n\
    +\t\tvcpu->arch.at_instruction_boundary = true;\n }\n \n static void svm_sched_in(struct\
    \ kvm_vcpu *vcpu, int cpu)"
  - "--- a/arch/x86/kvm/vmx/vmx.c\n+++ b/arch/x86/kvm/vmx/vmx.c\n@@ -6547,6 +6547,7\
    \ @@ static void handle_external_interrupt_irqoff(struct kvm_vcpu *vcpu)\n \t\t\
    return;\n \n \thandle_interrupt_nmi_irqoff(vcpu, gate_offset(desc));\n+\tvcpu->arch.at_instruction_boundary\
    \ = true;\n }\n \n static void vmx_handle_exit_irqoff(struct kvm_vcpu *vcpu)"
  - "--- a/arch/x86/kvm/x86.c\n+++ b/arch/x86/kvm/x86.c\n@@ -296,6 +296,8 @@ const\
    \ struct _kvm_stats_desc kvm_vcpu_stats_desc[] = {\n \tSTATS_DESC_COUNTER(VCPU,\
    \ nested_run),\n \tSTATS_DESC_COUNTER(VCPU, directed_yield_attempted),\n \tSTATS_DESC_COUNTER(VCPU,\
    \ directed_yield_successful),\n+\tSTATS_DESC_COUNTER(VCPU, preemption_reported),\n\
    +\tSTATS_DESC_COUNTER(VCPU, preemption_other),\n \tSTATS_DESC_ICOUNTER(VCPU, guest_mode)\n\
    \ };\n \n@@ -4625,6 +4627,19 @@ static void kvm_steal_time_set_preempted(struct\
    \ kvm_vcpu *vcpu)\n \tstruct kvm_memslots *slots;\n \tstatic const u8 preempted\
    \ = KVM_VCPU_PREEMPTED;\n \n+\t/*\n+\t * The vCPU can be marked preempted if and\
    \ only if the VM-Exit was on\n+\t * an instruction boundary and will not trigger\
    \ guest emulation of any\n+\t * kind (see vcpu_run).  Vendor specific code controls\
    \ (conservatively)\n+\t * when this is true, for example allowing the vCPU to\
    \ be marked\n+\t * preempted if and only if the VM-Exit was due to a host interrupt.\n\
    +\t */\n+\tif (!vcpu->arch.at_instruction_boundary) {\n+\t\tvcpu->stat.preemption_other++;\n\
    +\t\treturn;\n+\t}\n+\n+\tvcpu->stat.preemption_reported++;\n \tif (!(vcpu->arch.st.msr_val\
    \ & KVM_MSR_ENABLED))\n \t\treturn;\n \n@@ -10424,6 +10439,13 @@ static int vcpu_run(struct\
    \ kvm_vcpu *vcpu)\n \tvcpu->arch.l1tf_flush_l1d = true;\n \n \tfor (;;) {\n+\t\
    \t/*\n+\t\t * If another guest vCPU requests a PV TLB flush in the middle\n+\t\
    \t * of instruction emulation, the rest of the emulation could\n+\t\t * use a\
    \ stale page translation. Assume that any code after\n+\t\t * this point can start\
    \ executing an instruction.\n+\t\t */\n+\t\tvcpu->arch.at_instruction_boundary\
    \ = false;\n \t\tif (kvm_vcpu_running(vcpu)) {\n \t\t\tr = vcpu_enter_guest(vcpu);\n\
    \ \t\t} else {"
  identifiers:
  - CVE-2022-39189
  - NVD-CWE-noinfo
  overview: An issue was discovered the x86 KVM subsystem in the Linux kernel before
    5.18.17. Unprivileged guest users can compromise the guest kernel because TLB
    flush operations are mishandled in certain KVM_VCPU_PREEMPTED situations.
  references:
  - source: cve@mitre.org
    tags:
    - Issue Tracking
    - Patch
    - Third Party Advisory
    url: https://bugs.chromium.org/p/project-zero/issues/detail?id=2309
  - source: cve@mitre.org
    tags:
    - Patch
    - Release Notes
    - Vendor Advisory
    url: https://cdn.kernel.org/pub/linux/kernel/v5.x/ChangeLog-5.18.17
  - source: cve@mitre.org
    tags:
    - Patch
    - Vendor Advisory
    url: https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=6cd88243c7e03845a450795e134b488fc2afb736
  - source: cve@mitre.org
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/torvalds/linux/commit/6cd88243c7e03845a450795e134b488fc2afb736
  - source: cve@mitre.org
    url: https://lists.debian.org/debian-lts-announce/2023/10/msg00027.html
  - source: cve@mitre.org
    tags:
    - Third Party Advisory
    url: https://security.netapp.com/advisory/ntap-20230214-0007/
  - source: cve@mitre.org
    tags:
    - Third Party Advisory
    - VDB Entry
    url: https://www.debian.org/security/2023/dsa-5480
  title: An issue was discovered the x86 KVM subsystem in the Linux kernel before
    5.18.17. Unprivileged guest users can compromise the guest kernel because TLB
    flush operations are mishandled in certain KVM_VCPU_PREEMPTED situations.
- diff_content:
  - "--- a/net/netfilter/nf_tables_api.c\n+++ b/net/netfilter/nf_tables_api.c\n@@\
    \ -9711,6 +9711,8 @@ static int nft_verdict_init(const struct nft_ctx *ctx, struct\
    \ nft_data *data,\n \t\t\treturn PTR_ERR(chain);\n \t\tif (nft_is_base_chain(chain))\n\
    \ \t\t\treturn -EOPNOTSUPP;\n+\t\tif (nft_chain_is_bound(chain))\n+\t\t\treturn\
    \ -EINVAL;\n \t\tif (desc->flags & NFT_DATA_DESC_SETELEM &&\n \t\t    chain->flags\
    \ & NFT_CHAIN_BINDING)\n \t\t\treturn -EINVAL;"
  identifiers:
  - CVE-2022-39190
  - NVD-CWE-Other
  overview: An issue was discovered in net/netfilter/nf_tables_api.c in the Linux
    kernel before 5.19.6. A denial of service can occur upon binding to an already
    bound chain.
  references:
  - source: cve@mitre.org
    tags:
    - Patch
    - Release Notes
    - Vendor Advisory
    url: https://cdn.kernel.org/pub/linux/kernel/v5.x/ChangeLog-5.19.6
  - source: cve@mitre.org
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/torvalds/linux/commit/e02f0d3970404bfea385b6edb86f2d936db0ea2b
  - source: cve@mitre.org
    tags:
    - Mailing List
    - Third Party Advisory
    url: https://lists.debian.org/debian-lts-announce/2022/11/msg00001.html
  - source: cve@mitre.org
    url: https://lore.kernel.org/all/20220824220330.64283-12-pablo%40netfilter.org/
  - source: cve@mitre.org
    tags:
    - Third Party Advisory
    url: https://twitter.com/pr0Ln
  title: An issue was discovered in net/netfilter/nf_tables_api.c in the Linux kernel
    before 5.19.6. A denial of service can occur upon binding to an already bound
    chain.
- diff_content:
  - "--- a/libvncclient/vncviewer.c\n+++ b/libvncclient/vncviewer.c\n@@ -534,6 +534,8\
    \ @@ void rfbClientCleanup(rfbClient* client) {\n     client->clientData = next;\n\
    \   }\n \n+  free(client->vncRec);\n+\n   if (client->sock != RFB_INVALID_SOCKET)\n\
    \     rfbCloseSocket(client->sock);\n   if (client->listenSock != RFB_INVALID_SOCKET)"
  identifiers:
  - CVE-2020-29260
  - CWE-400
  overview: libvncclient v0.9.13 was discovered to contain a memory leak via the function
    rfbClientCleanup().
  references:
  - source: cve@mitre.org
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/LibVNC/libvncserver/commit/bef41f6ec4097a8ee094f90a1b34a708fbd757ec
  - source: cve@mitre.org
    tags:
    - Mailing List
    - Third Party Advisory
    url: https://lists.debian.org/debian-lts-announce/2022/09/msg00035.html
  title: libvncclient v0.9.13 was discovered to contain a memory leak via the function
    rfbClientCleanup().
- diff_content:
  - "--- a/src/ex_docmd.c\n+++ b/src/ex_docmd.c\n@@ -1068,7 +1068,7 @@ do_cmdline(\n\
    \ \n \t\t    // Check for the next breakpoint at or after the \":while\"\n \t\t\
    \    // or \":for\".\n-\t\t    if (breakpoint != NULL)\n+\t\t    if (breakpoint\
    \ != NULL && lines_ga.ga_len > current_line)\n \t\t    {\n \t\t\t*breakpoint =\
    \ dbg_find_breakpoint(\n \t\t\t       getline_equal(fgetline, cookie, getsourceline),"
  - "--- a/src/version.c\n+++ b/src/version.c\n@@ -707,6 +707,8 @@ static char *(features[])\
    \ =\n \n static int included_patches[] =\n {   /* Add new patch number below this\
    \ line */\n+/**/\n+    360,\n /**/\n     359,\n /**/"
  identifiers:
  - CVE-2022-3099
  - CWE-416
  overview: Use After Free in GitHub repository vim/vim prior to 9.0.0360.
  references:
  - source: security@huntr.dev
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/vim/vim/commit/35d21c6830fc2d68aca838424a0e786821c5891c
  - source: security@huntr.dev
    tags:
    - Exploit
    - Patch
    - Third Party Advisory
    url: https://huntr.dev/bounties/403210c7-6cc7-4874-8934-b57f88bd4f5e
  - source: security@huntr.dev
    tags:
    - Mailing List
    - Third Party Advisory
    url: https://lists.debian.org/debian-lts-announce/2022/11/msg00009.html
  - source: security@huntr.dev
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/DVWBI4BVTBUMNW4NMB3WZZDQJBKIGXI3/
  - source: security@huntr.dev
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/LLK2RMZEECKKWUQK7J46D2FQZOXFQLTC/
  - source: security@huntr.dev
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/XWOJOA7PZZAMBI5GFTL6PWHXMWSDLUXL/
  - source: security@huntr.dev
    url: https://security.gentoo.org/glsa/202305-16
  title: Use After Free in GitHub repository vim/vim prior to 9.0.0360.
- diff_content:
  - "--- a/drivers/video/fbdev/pxa3xx-gcu.c\n+++ b/drivers/video/fbdev/pxa3xx-gcu.c\n\
    @@ -381,7 +381,7 @@ pxa3xx_gcu_write(struct file *file, const char *buff,\n \t\
    struct pxa3xx_gcu_batch\t*buffer;\n \tstruct pxa3xx_gcu_priv *priv = to_pxa3xx_gcu_priv(file);\n\
    \ \n-\tint words = count / 4;\n+\tsize_t words = count / 4;\n \n \t/* Does not\
    \ need to be atomic. There's a lock in user space,\n \t * but anyhow, this is\
    \ just for statistics. */"
  identifiers:
  - CVE-2022-39842
  - CWE-190
  overview: 'An issue was discovered in the Linux kernel before 5.19. In pxa3xx_gcu_write
    in drivers/video/fbdev/pxa3xx-gcu.c, the count parameter has a type conflict of
    size_t versus int, causing an integer overflow and bypassing the size check. After
    that, because it is used as the third argument to copy_from_user(), a heap overflow
    may occur. NOTE: the original discoverer disputes that the overflow can actually
    happen.'
  references:
  - source: cve@mitre.org
    tags:
    - Release Notes
    - Vendor Advisory
    url: https://cdn.kernel.org/pub/linux/kernel/v5.x/ChangeLog-5.19
  - source: cve@mitre.org
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/torvalds/linux/commit/a09d2d00af53b43c6f11e6ab3cb58443c2cac8a7
  - source: cve@mitre.org
    tags:
    - Mailing List
    - Third Party Advisory
    url: https://lists.debian.org/debian-lts-announce/2022/10/msg00000.html
  - source: cve@mitre.org
    tags:
    - Mailing List
    - Third Party Advisory
    url: https://lists.debian.org/debian-lts-announce/2022/11/msg00001.html
  - source: cve@mitre.org
    url: https://lore.kernel.org/all/YylaC1wHHyLw22D3%40kadam/T/
  - source: cve@mitre.org
    tags:
    - Third Party Advisory
    url: https://www.debian.org/security/2022/dsa-5257
  title: 'An issue was discovered in the Linux kernel before 5.19. In pxa3xx_gcu_write
    in drivers/video/fbdev/pxa3xx-gcu.c, the count parameter has a type conflict of
    size_t versus int, causing an integer overflow and bypassing the size check. After
    that, because it is used as the third argument to copy_from_user(), a heap overflow
    may occur. NOTE: the original discoverer disputes that the overflow can actually
    happen.'
- diff_content:
  - "--- a/lib/fribidi-char-sets-cap-rtl.c\n+++ b/lib/fribidi-char-sets-cap-rtl.c\n\
    @@ -232,7 +232,12 @@ fribidi_cap_rtl_to_unicode (\n \t    }\n \t}\n       else\n\
    -\tus[j++] = caprtl_to_unicode[(int) s[i]];\n+      {\n+        if ((int)s[i]\
    \ < 0)\n+          us[j++] = '?';\n+        else\n+          us[j++] = caprtl_to_unicode[(int)\
    \ s[i]];\n+      }\n     }\n \n   return j;"
  identifiers:
  - CVE-2022-25309
  - CWE-122
  overview: A heap-based buffer overflow flaw was found in the Fribidi package and
    affects the fribidi_cap_rtl_to_unicode() function of the fribidi-char-sets-cap-rtl.c
    file. This flaw allows an attacker to pass a specially crafted file to the Fribidi
    application with the '--caprtl' option, leading to a crash and causing a denial
    of service.
  references:
  - source: secalert@redhat.com
    tags:
    - Third Party Advisory
    url: https://access.redhat.com/security/cve/CVE-2022-25309
  - source: secalert@redhat.com
    tags:
    - Exploit
    - Issue Tracking
    - Third Party Advisory
    url: https://bugzilla.redhat.com/show_bug.cgi?id=2047896
  - source: secalert@redhat.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/fribidi/fribidi/commit/f22593b82b5d1668d1997dbccd10a9c31ffea3b3
  - source: secalert@redhat.com
    tags:
    - Exploit
    - Third Party Advisory
    url: https://github.com/fribidi/fribidi/issues/182
  title: A heap-based buffer overflow flaw was found in the Fribidi package and affects
    the fribidi_cap_rtl_to_unicode() function of the fribidi-char-sets-cap-rtl.c file.
    This flaw allows an attacker to pass a specially crafted file to the Fribidi application
    with the '--caprtl' option, leading to a crash and causing a denial of service.
- diff_content:
  - "--- a/librz/bin/format/dex/dex.c\n+++ b/librz/bin/format/dex/dex.c\n@@ -81,6\
    \ +81,10 @@ static DexString *dex_string_new(RzBuffer *buf, ut64 offset, st64\
    \ *pread) {\n \tDexString *string = NULL;\n \n \tread = rz_buf_uleb128(buf, &size);\n\
    +\tif (UT64_ADD_OVFCHK(size, 1)) {\n+\t\treturn NULL;\n+\t}\n+\n \tdata = malloc(size\
    \ + 1);\n \tif (!data || rz_buf_read(buf, (ut8 *)data, size) != size) {\n \t\t\
    free(data);\n@@ -905,7 +909,9 @@ static char *dex_resolve_library(const char *library)\
    \ {\n \t}\n \tchar *demangled = strdup(library + 1);\n \trz_str_replace_ch(demangled,\
    \ '/', '.', 1);\n-\tdemangled[strlen(demangled) - 1] = 0;\n+\tif (RZ_STR_ISNOTEMPTY(demangled))\
    \ {\n+\t\tdemangled[strlen(demangled) - 1] = 0;\n+\t}\n \treturn demangled;\n\
    \ }\n "
  identifiers:
  - CVE-2022-36039
  - CWE-787
  overview: Rizin is a UNIX-like reverse engineering framework and command-line toolset.
    Versions 0.4.0 and prior are vulnerable to out-of-bounds write when parsing DEX
    files. A user opening a malicious DEX file could be affected by this vulnerability,
    allowing an attacker to execute code on the user's machine. A patch is available
    on the `dev` branch of the repository.
  references:
  - source: security-advisories@github.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/rizinorg/rizin/commit/1524f85211445e41506f98180f8f69f7bf115406
  - source: security-advisories@github.com
    tags:
    - Third Party Advisory
    url: https://github.com/rizinorg/rizin/issues/2969
  - source: security-advisories@github.com
    tags:
    - Third Party Advisory
    url: https://github.com/rizinorg/rizin/security/advisories/GHSA-pr85-hv85-45pg
  - source: security-advisories@github.com
    tags:
    - Third Party Advisory
    url: https://security.gentoo.org/glsa/202209-06
  title: Rizin is a UNIX-like reverse engineering framework and command-line toolset.
    Versions 0.4.0 and prior are vulnerable to out-of-bounds write when parsing DEX
    files. A user opening a malicious DEX file could be affected by this vulnerability,
    allowing an attacker to execute code on the user's machine. A patch is available
    on the `dev` branch of the repository.
- diff_content:
  - "--- a/librz/bin/format/mach0/dyldcache.c\n+++ b/librz/bin/format/mach0/dyldcache.c\n\
    @@ -995,7 +995,7 @@ static RzDyldRebaseInfos *get_rebase_infos(RzDyldCache *cache)\
    \ {\n \t}\n \n \tif (!cache->hdr->slideInfoOffset || !cache->hdr->slideInfoSize)\
    \ {\n-\t\tut32 total_slide_infos = 0;\n+\t\tsize_t total_slide_infos = 0;\n \t\
    \tut32 n_slide_infos[MAX_N_HDR];\n \n \t\tut32 i;\n@@ -1004,7 +1004,12 @@ static\
    \ RzDyldRebaseInfos *get_rebase_infos(RzDyldCache *cache) {\n \t\t\tif (!rz_buf_read_le32_at(cache->buf,\
    \ 0x13c + hdr_offset, &n_slide_infos[i])) {\n \t\t\t\tgoto beach;\n \t\t\t}\n\
    -\t\t\ttotal_slide_infos += n_slide_infos[i];\n+\t\t\tut32 total = total_slide_infos\
    \ + n_slide_infos[i];\n+\t\t\tif (total < total_slide_infos) {\n+\t\t\t\t// overflow\n\
    +\t\t\t\tgoto beach;\n+\t\t\t}\n+\t\t\ttotal_slide_infos = total;\n \t\t}\n \n\
    \ \t\tif (!total_slide_infos) {"
  identifiers:
  - CVE-2022-36042
  - CWE-787
  overview: Rizin is a UNIX-like reverse engineering framework and command-line toolset.
    Versions 0.4.0 and prior are vulnerable to an out-of-bounds write when getting
    data from dyld cache files. A user opening a malicious dyld cache file could be
    affected by this vulnerability, allowing an attacker to execute code on the user's
    machine. Commit number 556ca2f9eef01ec0f4a76d1fbacfcf3a87a44810 contains a patch.
  references:
  - source: security-advisories@github.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/rizinorg/rizin/commit/556ca2f9eef01ec0f4a76d1fbacfcf3a87a44810
  - source: security-advisories@github.com
    tags:
    - Third Party Advisory
    url: https://github.com/rizinorg/rizin/security/advisories/GHSA-pf72-jg54-8gvp
  - source: security-advisories@github.com
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/WQZLMHEI5D7EJASA5UW6XN4ODHLRHK6N/
  - source: security-advisories@github.com
    tags:
    - Third Party Advisory
    url: https://security.gentoo.org/glsa/202209-06
  title: Rizin is a UNIX-like reverse engineering framework and command-line toolset.
    Versions 0.4.0 and prior are vulnerable to an out-of-bounds write when getting
    data from dyld cache files. A user opening a malicious dyld cache file could be
    affected by this vulnerability, allowing an attacker to execute code on the user's
    machine. Commit number 556ca2f9eef01ec0f4a76d1fbacfcf3a87a44810 contains a patch.
- diff_content:
  - "--- a/librz/bin/format/pyc/marshal.c\n+++ b/librz/bin/format/pyc/marshal.c\n\
    @@ -313,7 +313,6 @@ static pyc_object *get_binary_float_object(RzBuffer *buffer)\
    \ {\n static pyc_object *get_complex_object(RzBinPycObj *pyc, RzBuffer *buffer)\
    \ {\n \tpyc_object *ret = NULL;\n \tbool error = false;\n-\tut32 size = 0;\n \t\
    ut32 n1 = 0;\n \tut32 n2 = 0;\n \n@@ -327,7 +326,7 @@ static pyc_object *get_complex_object(RzBinPycObj\
    \ *pyc, RzBuffer *buffer) {\n \t} else {\n \t\tn1 = get_st32(buffer, &error);\n\
    \ \t}\n-\tif (error) {\n+\tif (error || UT32_ADD_OVFCHK(n1, 1)) {\n \t\tfree(ret);\n\
    \ \t\treturn NULL;\n \t}\n@@ -336,8 +335,7 @@ static pyc_object *get_complex_object(RzBinPycObj\
    \ *pyc, RzBuffer *buffer) {\n \t\treturn NULL;\n \t}\n \t/* object contain string\
    \ representation of the number */\n-\tsize = rz_buf_read(buffer, s1, n1);\n-\t\
    if (size != n1) {\n+\tif (rz_buf_read(buffer, s1, n1) != n1) {\n \t\tRZ_FREE(s1);\n\
    \ \t\tRZ_FREE(ret);\n \t\treturn NULL;\n@@ -346,18 +344,18 @@ static pyc_object\
    \ *get_complex_object(RzBinPycObj *pyc, RzBuffer *buffer) {\n \n \tif ((pyc->magic_int\
    \ & 0xffff) <= 62061) {\n \t\tn2 = get_ut8(buffer, &error);\n-\t} else\n+\t} else\
    \ {\n \t\tn2 = get_st32(buffer, &error);\n-\tif (error) {\n+\t}\n+\tif (error\
    \ || UT32_ADD_OVFCHK(n2, 1)) {\n \t\treturn NULL;\n \t}\n \tut8 *s2 = malloc(n2\
    \ + 1);\n \tif (!s2) {\n \t\treturn NULL;\n \t}\n \t/* object contain string representation\
    \ of the number */\n-\tsize = rz_buf_read(buffer, s2, n2);\n-\tif (size != n2)\
    \ {\n+\tif (rz_buf_read(buffer, s2, n2) != n2) {\n \t\tRZ_FREE(s1);\n \t\tRZ_FREE(s2);\n\
    \ \t\tRZ_FREE(ret);"
  identifiers:
  - CVE-2022-36040
  - CWE-787
  overview: Rizin is a UNIX-like reverse engineering framework and command-line toolset.
    Versions 0.4.0 and prior are vulnerable to an out-of-bounds write when getting
    data from PYC(python) files. A user opening a malicious PYC file could be affected
    by this vulnerability, allowing an attacker to execute code on the user's machine.
    Commit number 68948017423a12786704e54227b8b2f918c2fd27 contains a patch.
  references:
  - source: security-advisories@github.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/rizinorg/rizin/commit/68948017423a12786704e54227b8b2f918c2fd27
  - source: security-advisories@github.com
    tags:
    - Third Party Advisory
    url: https://github.com/rizinorg/rizin/issues/2963
  - source: security-advisories@github.com
    tags:
    - Third Party Advisory
    url: https://github.com/rizinorg/rizin/security/advisories/GHSA-h897-rhm9-rpmw
  - source: security-advisories@github.com
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/WQZLMHEI5D7EJASA5UW6XN4ODHLRHK6N/
  - source: security-advisories@github.com
    tags:
    - Third Party Advisory
    url: https://security.gentoo.org/glsa/202209-06
  title: Rizin is a UNIX-like reverse engineering framework and command-line toolset.
    Versions 0.4.0 and prior are vulnerable to an out-of-bounds write when getting
    data from PYC(python) files. A user opening a malicious PYC file could be affected
    by this vulnerability, allowing an attacker to execute code on the user's machine.
    Commit number 68948017423a12786704e54227b8b2f918c2fd27 contains a patch.
- diff_content:
  - "--- a/librz/bin/format/mach0/mach0.c\n+++ b/librz/bin/format/mach0/mach0.c\n\
    @@ -1597,7 +1597,7 @@ static bool reconstruct_chained_fixup(struct MACH0_(obj_t)\
    \ * bin) {\n \t\t\t\t\t\tcur_seg->page_size = ps;\n \t\t\t\t\t\tcur_seg->page_count\
    \ = ((bin->segs[seg_idx].vmsize + (ps - 1)) & ~(ps - 1)) / ps;\n \t\t\t\t\t\t\
    if (cur_seg->page_count > 0) {\n-\t\t\t\t\t\t\tcur_seg->page_start = malloc(sizeof(ut16)\
    \ * cur_seg->page_count);\n+\t\t\t\t\t\t\tcur_seg->page_start = RZ_NEWS0(ut16,\
    \ cur_seg->page_count);\n \t\t\t\t\t\t\tif (!cur_seg->page_start) {\n \t\t\t\t\
    \t\t\t\tbreak;\n \t\t\t\t\t\t\t}\n@@ -1607,8 +1607,7 @@ static bool reconstruct_chained_fixup(struct\
    \ MACH0_(obj_t) * bin) {\n \t\t\t\t}\n \t\t\t\tif (cur_seg) {\n \t\t\t\t\tut32\
    \ page_index = (ut32)(seg_off / ps);\n-\t\t\t\t\tsize_t maxsize = cur_seg->page_count\
    \ * sizeof(ut16);\n-\t\t\t\t\tif (page_index < maxsize) {\n+\t\t\t\t\tif (page_index\
    \ < cur_seg->page_count) {\n \t\t\t\t\t\tcur_seg->page_start[page_index] = seg_off\
    \ & 0xfff;\n \t\t\t\t\t}\n \t\t\t\t}"
  identifiers:
  - CVE-2022-36041
  - CWE-787
  overview: Rizin is a UNIX-like reverse engineering framework and command-line toolset.
    Versions 0.4.0 and prior are vulnerable to an out-of-bounds write when parsing
    Mach-O files. A user opening a malicious Mach-O file could be affected by this
    vulnerability, allowing an attacker to execute code on the user's machine. Commit
    number 7323e64d68ecccfb0ed3ee480f704384c38676b2 contains a patch.
  references:
  - source: security-advisories@github.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/rizinorg/rizin/commit/7323e64d68ecccfb0ed3ee480f704384c38676b2
  - source: security-advisories@github.com
    tags:
    - Third Party Advisory
    url: https://github.com/rizinorg/rizin/issues/2956
  - source: security-advisories@github.com
    tags:
    - Third Party Advisory
    url: https://github.com/rizinorg/rizin/security/advisories/GHSA-2c7m-2f37-mr5m
  - source: security-advisories@github.com
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/WQZLMHEI5D7EJASA5UW6XN4ODHLRHK6N/
  - source: security-advisories@github.com
    tags:
    - Third Party Advisory
    url: https://security.gentoo.org/glsa/202209-06
  title: Rizin is a UNIX-like reverse engineering framework and command-line toolset.
    Versions 0.4.0 and prior are vulnerable to an out-of-bounds write when parsing
    Mach-O files. A user opening a malicious Mach-O file could be affected by this
    vulnerability, allowing an attacker to execute code on the user's machine. Commit
    number 7323e64d68ecccfb0ed3ee480f704384c38676b2 contains a patch.
- diff_content:
  - "--- a/librz/bin/p/bin_qnx.c\n+++ b/librz/bin/p/bin_qnx.c\n@@ -191,7 +191,21 @@\
    \ static RzBinInfo *info(RzBinFile *bf) {\n static RzList *relocs(RzBinFile *bf)\
    \ {\n \trz_return_val_if_fail(bf && bf->o, NULL);\n \tQnxObj *qo = bf->o->bin_obj;\n\
    -\treturn rz_list_clone(qo->fixups);\n+\tRzBinReloc *reloc = NULL;\n+\tRzListIter\
    \ *it = NULL;\n+\tRzList *relocs = rz_list_newf(free);\n+\tif (!relocs) {\n+\t\
    \treturn NULL;\n+\t}\n+\n+\trz_list_foreach (qo->fixups, it, reloc) {\n+\t\tRzBinReloc\
    \ *copy = RZ_NEW0(RzBinReloc);\n+\t\tcopy->vaddr = reloc->vaddr;\n+\t\tcopy->paddr\
    \ = reloc->paddr;\n+\t\tcopy->type = reloc->type;\n+\t\trz_list_append(relocs,\
    \ copy);\n+\t}\n+\treturn relocs;\n }\n \n static void header(RzBinFile *bf) {"
  identifiers:
  - CVE-2022-36043
  - CWE-415
  overview: Rizin is a UNIX-like reverse engineering framework and command-line toolset.
    Versions 0.4.0 and prior are vulnerable to a double free in bobj.c:rz_bin_reloc_storage_free()
    when freeing relocations generated from qnx binary plugin. A user opening a malicious
    qnx binary could be affected by this vulnerability, allowing an attacker to execute
    code on the user's machine. Commit number a3d50c1ea185f3f642f2d8180715f82d98840784
    contains a patch for this issue.
  references:
  - source: security-advisories@github.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/rizinorg/rizin/commit/a3d50c1ea185f3f642f2d8180715f82d98840784
  - source: security-advisories@github.com
    tags:
    - Third Party Advisory
    url: https://github.com/rizinorg/rizin/issues/2964
  - source: security-advisories@github.com
    tags:
    - Third Party Advisory
    url: https://github.com/rizinorg/rizin/security/advisories/GHSA-rjhv-mj4g-j4p5
  - source: security-advisories@github.com
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/WQZLMHEI5D7EJASA5UW6XN4ODHLRHK6N/
  - source: security-advisories@github.com
    tags:
    - Third Party Advisory
    url: https://security.gentoo.org/glsa/202209-06
  title: Rizin is a UNIX-like reverse engineering framework and command-line toolset.
    Versions 0.4.0 and prior are vulnerable to a double free in bobj.c:rz_bin_reloc_storage_free()
    when freeing relocations generated from qnx binary plugin. A user opening a malicious
    qnx binary could be affected by this vulnerability, allowing an attacker to execute
    code on the user's machine. Commit number a3d50c1ea185f3f642f2d8180715f82d98840784
    contains a patch for this issue.
- diff_content:
  - "--- a/librz/bin/format/luac/luac_bin.c\n+++ b/librz/bin/format/luac/luac_bin.c\n\
    @@ -70,12 +70,6 @@ void luac_add_string(RzList *string_list, char *string, ut64\
    \ offset, ut64 size)\n \trz_list_append(string_list, bin_string);\n }\n \n-static\
    \ void try_free_empty_list(RzList *list) {\n-\tif (list != NULL) {\n-\t\trz_list_free(list);\n\
    -\t}\n-}\n-\n static void free_rz_section(RzBinSection *section) {\n \tif (!section)\
    \ {\n \t\treturn;\n@@ -111,6 +105,17 @@ static void free_rz_addr(RzBinAddr *addr)\
    \ {\n \tRZ_FREE(addr);\n }\n \n+void luac_build_info_free(LuacBinInfo *bin_info)\
    \ {\n+\tif (!bin_info) {\n+\t\treturn;\n+\t}\n+\trz_list_free(bin_info->entry_list);\n\
    +\trz_list_free(bin_info->symbol_list);\n+\trz_list_free(bin_info->section_list);\n\
    +\trz_list_free(bin_info->string_list);\n+\tfree(bin_info);\n+}\n+\n LuacBinInfo\
    \ *luac_build_info(LuaProto *proto) {\n \tif (!proto) {\n \t\tRZ_LOG_ERROR(\"\
    Invalid luac file\\n\");\n@@ -128,10 +133,10 @@ LuacBinInfo *luac_build_info(LuaProto\
    \ *proto) {\n \tret->string_list = rz_list_newf((RzListFree)free_rz_string);\n\
    \ \n \tif (!(ret->entry_list && ret->symbol_list && ret->section_list && ret->string_list))\
    \ {\n-\t\ttry_free_empty_list(ret->entry_list);\n-\t\ttry_free_empty_list(ret->symbol_list);\n\
    -\t\ttry_free_empty_list(ret->section_list);\n-\t\ttry_free_empty_list(ret->string_list);\n\
    +\t\trz_list_free(ret->entry_list);\n+\t\trz_list_free(ret->symbol_list);\n+\t\
    \trz_list_free(ret->section_list);\n+\t\trz_list_free(ret->string_list);\n \t\
    }\n \n \t_luac_build_info(proto, ret);\n@@ -227,13 +232,13 @@ void _luac_build_info(LuaProto\
    \ *proto, LuacBinInfo *info) {\n \tchar *section_name;\n \tchar *symbol_name;\n\
    \ \tchar *proto_name;\n+\tchar **upvalue_names = NULL;\n \tRzListIter *iter;\n\
    +\tint i = 0; // iter\n \n \tut64 current_offset;\n \tut64 current_size;\n \n\
    -\tint i = 0; // iter\n-\n \t// 0. check if stripped (proto name is lost)\n \t\
    if (proto->name_size == 0 || proto->proto_name == NULL) {\n \t\t// replace name\
    \ with current offset\n@@ -295,21 +300,25 @@ void _luac_build_info(LuaProto *proto,\
    \ LuacBinInfo *info) {\n \t}\n \n \t// 2.2 parse debug_upvalues\n-\tchar **upvalue_names;\n\
    -\tint real_upvalue_cnt;\n-\tLuaDbgUpvalueEntry *debug_upv_entry;\n-\treal_upvalue_cnt\
    \ = rz_list_length(proto->upvalue_entries);\n-\tupvalue_names = RZ_NEWS0(char\
    \ *, real_upvalue_cnt);\n-\tif (!upvalue_names) {\n-\t\treturn;\n-\t}\n-\trz_list_foreach\
    \ (proto->dbg_upvalue_entries, iter, debug_upv_entry) {\n-\t\tupvalue_names[i]\
    \ = (char *)debug_upv_entry->upvalue_name;\n-\t\tluac_add_string(\n-\t\t\tinfo->string_list,\n\
    -\t\t\tupvalue_names[i],\n-\t\t\tdebug_upv_entry->offset,\n-\t\t\tdebug_upv_entry->name_len);\n\
    +\tsize_t real_upvalue_cnt = rz_list_length(proto->upvalue_entries);\n+\tif (real_upvalue_cnt\
    \ > 0) {\n+\t\tLuaDbgUpvalueEntry *debug_upv_entry;\n+\t\tupvalue_names = RZ_NEWS0(char\
    \ *, real_upvalue_cnt);\n+\t\tif (!upvalue_names) {\n+\t\t\tfree(proto_name);\n\
    +\t\t\treturn;\n+\t\t}\n+\n+\t\ti = 0;\n+\t\trz_list_foreach (proto->dbg_upvalue_entries,\
    \ iter, debug_upv_entry) {\n+\t\t\tupvalue_names[i] = (char *)debug_upv_entry->upvalue_name;\n\
    +\t\t\tluac_add_string(\n+\t\t\t\tinfo->string_list,\n+\t\t\t\tupvalue_names[i],\n\
    +\t\t\t\tdebug_upv_entry->offset,\n+\t\t\t\tdebug_upv_entry->name_len);\n+\t\t\
    \ti++;\n+\t\t}\n \t}\n \n \t// 3.1 construct constant symbols\n@@ -352,5 +361,6\
    \ @@ void _luac_build_info(LuaProto *proto, LuacBinInfo *info) {\n \t\t_luac_build_info(sub_proto,\
    \ info);\n \t}\n \n-\tRZ_FREE(proto_name);\n+\tfree(upvalue_names);\n+\tfree(proto_name);\n\
    \ }"
  - "--- a/librz/bin/p/bin_luac.c\n+++ b/librz/bin/p/bin_luac.c\n@@ -100,7 +100,7\
    \ @@ static RzList *symbols(RzBinFile *bf) {\n \t\treturn NULL;\n \t}\n \n-\t\
    return bin_info_obj->symbol_list;\n+\treturn rz_list_clone(bin_info_obj->symbol_list);\n\
    \ }\n \n static RzList *entries(RzBinFile *bf) {\n@@ -112,7 +112,7 @@ static RzList\
    \ *entries(RzBinFile *bf) {\n \t\treturn NULL;\n \t}\n \n-\treturn bin_info_obj->entry_list;\n\
    +\treturn rz_list_clone(bin_info_obj->entry_list);\n }\n \n static RzList *strings(RzBinFile\
    \ *bf) {\n@@ -124,7 +124,12 @@ static RzList *strings(RzBinFile *bf) {\n \t\t\
    return NULL;\n \t}\n \n-\treturn bin_info_obj->string_list;\n+\treturn rz_list_clone(bin_info_obj->string_list);\n\
    +}\n+\n+static void destroy(RzBinFile *bf) {\n+\tLuacBinInfo *bin_info_obj = GET_INTERNAL_BIN_INFO_OBJ(bf);\n\
    +\tluac_build_info_free(bin_info_obj);\n }\n \n RzBinPlugin rz_bin_plugin_luac\
    \ = {\n@@ -133,6 +138,7 @@ RzBinPlugin rz_bin_plugin_luac = {\n \t.license = \"\
    LGPL3\",\n \t.get_sdb = NULL,\n \t.load_buffer = &load_buffer,\n+\t.destroy =\
    \ &destroy,\n \t.check_buffer = &check_buffer,\n \t.baddr = NULL,\n \t.entries\
    \ = &entries,"
  - "--- a/librz/bin/bobj.c\n+++ b/librz/bin/bobj.c\n@@ -244,7 +244,7 @@ static RzList\
    \ *classes_from_symbols(RzBinFile *bf) {\n \tRzBinSymbol *sym;\n \tRzListIter\
    \ *iter;\n \trz_list_foreach (bf->o->symbols, iter, sym) {\n-\t\tif (sym->name[0]\
    \ != '_') {\n+\t\tif (!sym->name || sym->name[0] != '_') {\n \t\t\tcontinue;\n\
    \ \t\t}\n \t\tconst char *cn = sym->classname;"
  - "--- a/librz/bin/format/luac/luac_bin.c\n+++ b/librz/bin/format/luac/luac_bin.c\n\
    @@ -303,7 +303,7 @@ void _luac_build_info(LuaProto *proto, LuacBinInfo *info)\
    \ {\n \t}\n \n \t// 2.2 parse debug_upvalues\n-\tsize_t real_upvalue_cnt = rz_list_length(proto->upvalue_entries);\n\
    +\tsize_t real_upvalue_cnt = RZ_MAX(rz_list_length(proto->upvalue_entries), rz_list_length(proto->dbg_upvalue_entries));\n\
    \ \tif (real_upvalue_cnt > 0) {\n \t\tLuaDbgUpvalueEntry *debug_upv_entry;\n \t\
    \tupvalue_names = RZ_NEWS0(char *, real_upvalue_cnt);\n@@ -328,6 +328,9 @@ void\
    \ _luac_build_info(LuaProto *proto, LuacBinInfo *info) {\n \tLuaConstEntry *const_entry;\n\
    \ \trz_list_foreach (proto->const_entries, iter, const_entry) {\n \t\tsymbol_name\
    \ = get_constant_symbol_name(proto_name, const_entry);\n+\t\tif (!symbol_name)\
    \ {\n+\t\t\tcontinue;\n+\t\t}\n \t\tluac_add_symbol(\n \t\t\tinfo->symbol_list,\n\
    \ \t\t\tsymbol_name,"
  identifiers:
  - CVE-2022-36044
  - CWE-787
  overview: Rizin is a UNIX-like reverse engineering framework and command-line toolset.
    Versions 0.4.0 and prior are vulnerable to an out-of-bounds write when getting
    data from Luac files. A user opening a malicious Luac file could be affected by
    this vulnerability, allowing an attacker to execute code on the user's machine.
    Commits 07b43bc8aa1ffebd9b68d60624c9610cf7e460c7 and 05bbd147caccc60162d6fba9baaaf24befa281cd
    contain fixes for the issue.
  references:
  - source: security-advisories@github.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/rizinorg/rizin/commit/05bbd147caccc60162d6fba9baaaf24befa281cd
  - source: security-advisories@github.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/rizinorg/rizin/commit/07b43bc8aa1ffebd9b68d60624c9610cf7e460c7
  - source: security-advisories@github.com
    tags:
    - Third Party Advisory
    url: https://github.com/rizinorg/rizin/security/advisories/GHSA-mqcj-82c6-gh5q
  - source: security-advisories@github.com
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/WQZLMHEI5D7EJASA5UW6XN4ODHLRHK6N/
  - source: security-advisories@github.com
    tags:
    - Third Party Advisory
    url: https://security.gentoo.org/glsa/202209-06
  title: Rizin is a UNIX-like reverse engineering framework and command-line toolset.
    Versions 0.4.0 and prior are vulnerable to an out-of-bounds write when getting
    data from Luac files. A user opening a malicious Luac file could be affected by
    this vulnerability, allowing an attacker to execute code on the user's machine.
    Commits 07b43bc8aa1ffebd9b68d60624c9610cf7e460c7 and 05bbd147caccc60162d6fba9baaaf24befa281cd
    contain fixes for the issue.
- diff_content:
  - "--- a/src/tag.c\n+++ b/src/tag.c\n@@ -690,6 +690,16 @@ do_tag(\n \t\tmax_num_matches\
    \ = MAXCOL; // If less than max_num_matches\n \t\t\t\t\t  // found: all matches\
    \ found.\n \n+\t    // A tag function may do anything, which may cause various\n\
    +\t    // information to become invalid.  At least check for the tagstack\n+\t\
    \    // to still be the same.\n+\t    if (tagstack != curwin->w_tagstack)\n+\t\
    \    {\n+\t\temsg(_(e_window_unexpectedly_close_while_searching_for_tags));\n\
    +\t\tFreeWild(new_num_matches, new_matches);\n+\t\tbreak;\n+\t    }\n+\n \t  \
    \  // If there already were some matches for the same name, move them\n \t   \
    \ // to the start.  Avoids that the order changes when using\n \t    // \":tnext\"\
    \ and jumping to another file."
  - "--- a/src/version.c\n+++ b/src/version.c\n@@ -703,6 +703,8 @@ static char *(features[])\
    \ =\n \n static int included_patches[] =\n {   /* Add new patch number below this\
    \ line */\n+/**/\n+    389,\n /**/\n     388,\n /**/"
  identifiers:
  - CVE-2022-3134
  - CWE-416
  overview: Use After Free in GitHub repository vim/vim prior to 9.0.0389.
  references:
  - source: security@huntr.dev
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/vim/vim/commit/ccfde4d028e891a41e3548323c3d47b06fb0b83e
  - source: security@huntr.dev
    tags:
    - Exploit
    - Third Party Advisory
    url: https://huntr.dev/bounties/6ec79e49-c7ab-4cd6-a517-e7934c2eb9dc
  - source: security@huntr.dev
    tags:
    - Mailing List
    - Third Party Advisory
    url: https://lists.debian.org/debian-lts-announce/2022/11/msg00009.html
  - source: security@huntr.dev
    tags:
    - Third Party Advisory
    url: https://security.gentoo.org/glsa/202305-16
  title: Use After Free in GitHub repository vim/vim prior to 9.0.0389.
- diff_content:
  - "--- a/src/testing.c\n+++ b/src/testing.c\n@@ -616,6 +616,11 @@ f_assert_fails(typval_T\
    \ *argvars, typval_T *rettv)\n     in_assert_fails = TRUE;\n \n     do_cmdline_cmd(cmd);\n\
    +\n+    // reset here for any errors reported below\n+    trylevel = save_trylevel;\n\
    +    suppress_errthrow = FALSE;\n+\n     if (called_emsg == called_emsg_before)\n\
    \     {\n \tprepare_assert_error(&ga);\n@@ -654,6 +659,8 @@ f_assert_fails(typval_T\
    \ *argvars, typval_T *rettv)\n \t    CHECK_LIST_MATERIALIZE(list);\n \t    tv\
    \ = &list->lv_first->li_tv;\n \t    expected = tv_get_string_buf_chk(tv, buf);\n\
    +\t    if (expected == NULL)\n+\t\tgoto theend;\n \t    if (!pattern_match(expected,\
    \ actual, FALSE))\n \t    {\n \t\terror_found = TRUE;\n@@ -667,6 +674,8 @@ f_assert_fails(typval_T\
    \ *argvars, typval_T *rettv)\n \t\t{\n \t\t    tv = &list->lv_u.mat.lv_last->li_tv;\n\
    \ \t\t    expected = tv_get_string_buf_chk(tv, buf);\n+\t\t    if (expected ==\
    \ NULL)\n+\t\t\tgoto theend;\n \t\t    if (!pattern_match(expected, actual, FALSE))\n\
    \ \t\t    {\n \t\t\terror_found = TRUE;"
  - "--- a/src/version.c\n+++ b/src/version.c\n@@ -703,6 +703,8 @@ static char *(features[])\
    \ =\n \n static int included_patches[] =\n {   /* Add new patch number below this\
    \ line */\n+/**/\n+    404,\n /**/\n     403,\n /**/"
  identifiers:
  - CVE-2022-3153
  - CWE-476
  overview: NULL Pointer Dereference in GitHub repository vim/vim prior to 9.0.0404.
  references:
  - source: security@huntr.dev
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/vim/vim/commit/1540d334a04d874c2aa9d26b82dbbcd4bc5a78de
  - source: security@huntr.dev
    tags:
    - Exploit
    - Patch
    - Third Party Advisory
    url: https://huntr.dev/bounties/68331124-620d-48bc-a8fa-cd947b26270a
  - source: security@huntr.dev
    url: https://security.gentoo.org/glsa/202305-16
  title: NULL Pointer Dereference in GitHub repository vim/vim prior to 9.0.0404.
- diff_content:
  - "--- a/drivers/firmware/efi/capsule-loader.c\n+++ b/drivers/firmware/efi/capsule-loader.c\n\
    @@ -242,29 +242,6 @@ static ssize_t efi_capsule_write(struct file *file, const\
    \ char __user *buff,\n \treturn ret;\n }\n \n-/**\n- * efi_capsule_flush - called\
    \ by file close or file flush\n- * @file: file pointer\n- * @id: not used\n- *\n\
    - *\tIf a capsule is being partially uploaded then calling this function\n- *\t\
    will be treated as upload termination and will free those completed\n- *\tbuffer\
    \ pages and -ECANCELED will be returned.\n- **/\n-static int efi_capsule_flush(struct\
    \ file *file, fl_owner_t id)\n-{\n-\tint ret = 0;\n-\tstruct capsule_info *cap_info\
    \ = file->private_data;\n-\n-\tif (cap_info->index > 0) {\n-\t\tpr_err(\"capsule\
    \ upload not complete\\n\");\n-\t\tefi_free_all_buff_pages(cap_info);\n-\t\tret\
    \ = -ECANCELED;\n-\t}\n-\n-\treturn ret;\n-}\n-\n /**\n  * efi_capsule_release\
    \ - called by file close\n  * @inode: not used\n@@ -277,6 +254,13 @@ static int\
    \ efi_capsule_release(struct inode *inode, struct file *file)\n {\n \tstruct capsule_info\
    \ *cap_info = file->private_data;\n \n+\tif (cap_info->index > 0 &&\n+\t    (cap_info->header.headersize\
    \ == 0 ||\n+\t     cap_info->count < cap_info->total_size)) {\n+\t\tpr_err(\"\
    capsule upload not complete\\n\");\n+\t\tefi_free_all_buff_pages(cap_info);\n\
    +\t}\n+\n \tkfree(cap_info->pages);\n \tkfree(cap_info->phys);\n \tkfree(file->private_data);\n\
    @@ -324,7 +308,6 @@ static const struct file_operations efi_capsule_fops = {\n\
    \ \t.owner = THIS_MODULE,\n \t.open = efi_capsule_open,\n \t.write = efi_capsule_write,\n\
    -\t.flush = efi_capsule_flush,\n \t.release = efi_capsule_release,\n \t.llseek\
    \ = no_llseek,\n };"
  identifiers:
  - CVE-2022-40307
  - CWE-362
  overview: An issue was discovered in the Linux kernel through 5.19.8. drivers/firmware/efi/capsule-loader.c
    has a race condition with a resultant use-after-free.
  references:
  - source: cve@mitre.org
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/torvalds/linux/commit/9cb636b5f6a8cc6d1b50809ec8f8d33ae0c84c95
  - source: cve@mitre.org
    tags:
    - Mailing List
    - Third Party Advisory
    url: https://lists.debian.org/debian-lts-announce/2022/10/msg00000.html
  - source: cve@mitre.org
    tags:
    - Mailing List
    - Third Party Advisory
    url: https://lists.debian.org/debian-lts-announce/2022/11/msg00001.html
  - source: cve@mitre.org
    tags:
    - Third Party Advisory
    url: https://www.debian.org/security/2022/dsa-5257
  title: An issue was discovered in the Linux kernel through 5.19.8. drivers/firmware/efi/capsule-loader.c
    has a race condition with a resultant use-after-free.
- diff_content:
  - "--- a/src/resolve/resolved-dns-stream.c\n+++ b/src/resolve/resolved-dns-stream.c\n\
    @@ -46,6 +46,8 @@ static int dns_stream_update_io(DnsStream *s) {\n }\n \n static\
    \ int dns_stream_complete(DnsStream *s, int error) {\n+        _cleanup_(dns_stream_unrefp)\
    \ _unused_ DnsStream *ref = dns_stream_ref(s); /* Protect stream while we process\
    \ it */\n+\n         assert(s);\n \n #if ENABLE_DNS_OVER_TLS\n@@ -273,7 +275,7\
    \ @@ static int on_stream_timeout(sd_event_source *es, usec_t usec, void *userdata)\
    \ {\n }\n \n static int on_stream_io(sd_event_source *es, int fd, uint32_t revents,\
    \ void *userdata) {\n-        DnsStream *s = userdata;\n+        _cleanup_(dns_stream_unrefp)\
    \ DnsStream *s = dns_stream_ref(userdata); /* Protect stream while we process\
    \ it */\n         int r;\n \n         assert(s);"
  identifiers:
  - CVE-2022-2526
  - CWE-416
  overview: A use-after-free vulnerability was found in systemd. This issue occurs
    due to the on_stream_io() function and dns_stream_complete() function in 'resolved-dns-stream.c'
    not incrementing the reference counting for the DnsStream object. Therefore, other
    functions and callbacks called can dereference the DNSStream object, causing the
    use-after-free when the reference is still used later.
  references:
  - source: secalert@redhat.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/systemd/systemd/commit/d973d94dec349fb676fdd844f6fe2ada3538f27c
  - source: secalert@redhat.com
    tags:
    - Third Party Advisory
    url: https://security.netapp.com/advisory/ntap-20221111-0005/
  title: A use-after-free vulnerability was found in systemd. This issue occurs due
    to the on_stream_io() function and dns_stream_complete() function in 'resolved-dns-stream.c'
    not incrementing the reference counting for the DnsStream object. Therefore, other
    functions and callbacks called can dereference the DNSStream object, causing the
    use-after-free when the reference is still used later.
- diff_content:
  - "--- a/drivers/i2c/busses/i2c-ismt.c\n+++ b/drivers/i2c/busses/i2c-ismt.c\n@@\
    \ -528,6 +528,9 @@ static int ismt_access(struct i2c_adapter *adap, u16 addr,\n\
    \ \n \tcase I2C_SMBUS_BLOCK_PROC_CALL:\n \t\tdev_dbg(dev, \"I2C_SMBUS_BLOCK_PROC_CALL\\\
    n\");\n+\t\tif (data->block[0] > I2C_SMBUS_BLOCK_MAX)\n+\t\t\treturn -EINVAL;\n\
    +\n \t\tdma_size = I2C_SMBUS_BLOCK_MAX;\n \t\tdesc->tgtaddr_rw = ISMT_DESC_ADDR_RW(addr,\
    \ 1);\n \t\tdesc->wr_len_cmd = data->block[0] + 1;"
  identifiers:
  - CVE-2022-3077
  - CWE-120
  overview: "A buffer overflow vulnerability was found in the Linux kernel Intel\u2019\
    s iSMT SMBus host controller driver in the way it handled the I2C_SMBUS_BLOCK_PROC_CALL\
    \ case (via the ioctl I2C_SMBUS) with malicious input data. This flaw could allow\
    \ a local user to crash the system."
  references:
  - source: secalert@redhat.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/torvalds/linux/commit/690b2549b19563ec5ad53e5c82f6a944d910086e
  title: "A buffer overflow vulnerability was found in the Linux kernel Intel\u2019\
    s iSMT SMBus host controller driver in the way it handled the I2C_SMBUS_BLOCK_PROC_CALL\
    \ case (via the ioctl I2C_SMBUS) with malicious input data. This flaw could allow\
    \ a local user to crash the system."
- diff_content:
  - "--- a/src/convolve.c\n+++ b/src/convolve.c\n@@ -114,17 +114,18 @@ static void\
    \ blocksumLow(l_uint32 *datad, l_int32 w, l_int32 h, l_int32 wpl,\n /*!\n  * \\\
    brief   pixBlockconv()\n  *\n- * \\param[in]    pix 8    or 32 bpp; or 2, 4 or\
    \ 8 bpp with colormap\n+ * \\param[in]    pix      8 or 32 bpp; or 2, 4 or 8 bpp\
    \ with colormap\n  * \\param[in]    wc, hc   half width/height of convolution\
    \ kernel\n  * \\return  pixd, or NULL on error\n  *\n  * <pre>\n  * Notes:\n \
    \ *      (1) The full width and height of the convolution kernel\n  *        \
    \  are (2 * wc + 1) and (2 * hc + 1)\n- *      (2) Returns a copy if both wc and\
    \ hc are 0\n+ *      (2) Returns a copy if either wc or hc are 0\n  *      (3)\
    \ Require that w >= 2 * wc + 1 and h >= 2 * hc + 1,\n- *          where (w,h)\
    \ are the dimensions of pixs.\n+ *          where (w,h) are the dimensions of\
    \ pixs.  Otherwise,\n+ *          return a copy.\n  * </pre>\n  */\n PIX  *\n\
    @@ -139,17 +140,14 @@ PIX     *pixs, *pixd, *pixr, *pixrc, *pixg, *pixgc, *pixb,\
    \ *pixbc;\n \n     if (!pix)\n         return (PIX *)ERROR_PTR(\"pix not defined\"\
    , procName, NULL);\n-    if (wc < 0) wc = 0;\n-    if (hc < 0) hc = 0;\n+    if\
    \ (wc <= 0 || hc <= 0)\n+        return pixCopy(NULL, pix);\n     pixGetDimensions(pix,\
    \ &w, &h, &d);\n     if (w < 2 * wc + 1 || h < 2 * hc + 1) {\n-        wc = L_MIN(wc,\
    \ (w - 1) / 2);\n-        hc = L_MIN(hc, (h - 1) / 2);\n-        L_WARNING(\"\
    kernel too large; reducing!\\n\", procName);\n-        L_INFO(\"wc = %d, hc =\
    \ %d\\n\", procName, wc, hc);\n+        L_ERROR(\"kernel is too large: w = %d,\
    \ wc = %d, h = %d, hc = %d\\n\",\n+                procName, w, wc, h, hc);\n\
    +        return pixCopy(NULL, pix);  /* no-op */\n     }\n-    if (wc == 0 &&\
    \ hc == 0)   /* no-op */\n-        return pixCopy(NULL, pix);\n \n         /*\
    \ Remove colormap if necessary */\n     if ((d == 2 || d == 4 || d == 8) && pixGetColormap(pix))\
    \ {\n@@ -205,9 +203,10 @@ PIX     *pixs, *pixd, *pixr, *pixrc, *pixg, *pixgc,\
    \ *pixb, *pixbc;\n  *          returning; otherwise, just use the input accum\
    \ pix.\n  *      (2) The full width and height of the convolution kernel\n  *\
    \          are (2 * wc + 1) and (2 * hc + 1).\n- *      (3) Returns a copy if\
    \ both wc and hc are 0.\n+ *      (3) Returns a copy if either wc or hc are 0\n\
    \  *      (4) Require that w >= 2 * wc + 1 and h >= 2 * hc + 1,\n- *         \
    \ where (w,h) are the dimensions of pixs.\n+ *          where (w,h) are the dimensions\
    \ of pixs.  Otherwise,\n+ *          return a copy.\n  * </pre>\n  */\n PIX *\n\
    @@ -227,13 +226,11 @@ PIX       *pixd, *pixt;\n     pixGetDimensions(pixs, &w,\
    \ &h, &d);\n     if (d != 8)\n         return (PIX *)ERROR_PTR(\"pixs not 8 bpp\"\
    , procName, NULL);\n-    if (wc < 0) wc = 0;\n-    if (hc < 0) hc = 0;\n-    if\
    \ (wc == 0 && hc == 0)   /* no-op */\n+    if (wc <= 0 || hc <= 0)   /* no-op\
    \ */\n         return pixCopy(NULL, pixs);\n     if (w < 2 * wc + 1 || h < 2 *\
    \ hc + 1) {\n-        L_WARNING(\"kernel too large; returning a copy\\n\", procName);\n\
    -        L_INFO(\"w = %d, wc = %d, h = %d, hc = %d\\n\", procName, w, wc, h, hc);\n\
    +        L_ERROR(\"kernel is too large: w = %d, wc = %d, h = %d, hc = %d\\n\"\
    ,\n+                procName, w, wc, h, hc);\n         return pixCopy(NULL, pixs);\n\
    \     }\n \n@@ -612,7 +609,7 @@ l_uint32  *lines, *lined, *linedp;\n  *      \
    \    are (2 * wc + 1) and (2 * hc + 1).\n  *      (2) Require that w >= 2 * wc\
    \ + 1 and h >= 2 * hc + 1,\n  *          where (w,h) are the dimensions of pixs.\n\
    - *      (3) Returns a copy if both wc and hc are 0.\n+ *      (3) Returns a copy\
    \ if either wc or hc are 0.\n  *      (3) Adds mirrored border to avoid treating\
    \ the boundary pixels\n  *          specially.  Note that we add wc + 1 pixels\
    \ to the left\n  *          and wc to the right.  The added width is 2 * wc +\
    \ 1 pixels,\n@@ -650,16 +647,13 @@ PIX       *pixsb, *pixacc, *pixd;\n     pixGetDimensions(pixs,\
    \ &w, &h, &d);\n     if (d != 8)\n         return (PIX *)ERROR_PTR(\"pixs not\
    \ 8 bpp\", procName, NULL);\n-    if (wc < 0) wc = 0;\n-    if (hc < 0) hc = 0;\n\
    +    if (wc <= 0 || hc <= 0)  /* no-op */\n+        return pixCopy(NULL, pixs);\n\
    \     if (w < 2 * wc + 1 || h < 2 * hc + 1) {\n-        wc = L_MIN(wc, (w - 1)\
    \ / 2);\n-        hc = L_MIN(hc, (h - 1) / 2);\n-        L_WARNING(\"kernel too\
    \ large; reducing!\\n\", procName);\n-        L_INFO(\"wc = %d, hc = %d\\n\",\
    \ procName, wc, hc);\n-    }\n-    if (wc == 0 && hc == 0)   /* no-op */\n+  \
    \      L_ERROR(\"kernel is too large: w = %d, wc = %d, h = %d, hc = %d\\n\",\n\
    +                procName, w, wc, h, hc);\n         return pixCopy(NULL, pixs);\n\
    +    }\n \n     if ((pixsb = pixAddMirroredBorder(pixs, wc + 1, wc, hc + 1, hc))\
    \ == NULL)\n         return (PIX *)ERROR_PTR(\"pixsb not made\", procName, NULL);\n\
    @@ -707,9 +701,10 @@ PIX       *pixsb, *pixacc, *pixd;\n  * Notes:\n  *      (1)\
    \ The full width and height of the convolution kernel\n  *          are (2 * wc\
    \ + 1) and (2 * hc + 1)\n- *      (2) Returns a copy if both wc and hc are 0\n\
    + *      (2) Returns a copy if either wc or hc are 0.\n  *      (3) Require that\
    \ w >= 2 * wc + 1 and h >= 2 * hc + 1,\n- *          where (w,h) are the dimensions\
    \ of pixs.\n+ *          where (w,h) are the dimensions of pixs.  Otherwise,\n\
    + *          return a copy.\n  *      (4) For nx == ny == 1, this defaults to\
    \ pixBlockconv(), which\n  *          is typically about twice as fast, and gives\
    \ nearly\n  *          identical results as pixBlockconvGrayTile().\n@@ -741,19\
    \ +736,16 @@ PIXTILING  *pt;\n \n     if (!pix)\n         return (PIX *)ERROR_PTR(\"\
    pix not defined\", procName, NULL);\n-    if (wc < 0) wc = 0;\n-    if (hc < 0)\
    \ hc = 0;\n-    pixGetDimensions(pix, &w, &h, &d);\n-    if (w < 2 * wc + 3 ||\
    \ h < 2 * hc + 3) {\n-        wc = L_MAX(0, L_MIN(wc, (w - 3) / 2));\n-      \
    \  hc = L_MAX(0, L_MIN(hc, (h - 3) / 2));\n-        L_WARNING(\"kernel too large;\
    \ reducing!\\n\", procName);\n-        L_INFO(\"wc = %d, hc = %d\\n\", procName,\
    \ wc, hc);\n-    }\n-    if (wc == 0 && hc == 0)   /* no-op */\n+    if (wc <=\
    \ 0 || hc <= 0)   /* no-op */\n         return pixCopy(NULL, pix);\n     if (nx\
    \ <= 1 && ny <= 1)\n         return pixBlockconv(pix, wc, hc);\n+    pixGetDimensions(pix,\
    \ &w, &h, &d);\n+    if (w < 2 * wc + 3 || h < 2 * hc + 3) {\n+        L_ERROR(\"\
    kernel is too large: w = %d, wc = %d, h = %d, hc = %d\\n\",\n+               \
    \ procName, w, wc, h, hc);\n+        return pixCopy(NULL, pix);\n+    }\n \n \
    \        /* Test to see if the tiles are too small.  The required\n          *\
    \ condition is that the tile dimensions must be at least\n@@ -846,9 +838,10 @@\
    \ PIXTILING  *pt;\n  *          left and right, and with (hc + 1) pixels on top\
    \ and bottom.\n  *          The returned pix has these stripped off; they are\
    \ only used\n  *          for computation.\n- *      (3) Returns a copy if both\
    \ wc and hc are 0\n- *      (4) Require that w > 2 * wc + 1 and h > 2 * hc + 1,\n\
    - *          where (w,h) are the dimensions of pixs.\n+ *      (3) Returns a copy\
    \ if either wc or hc are 0.\n+ *      (4) Require that w > 2 * wc + 3 and h >\
    \ 2 * hc + 3,\n+ *          where (w,h) are the dimensions of pixs.  Otherwise,\n\
    + *          return a copy.\n  * </pre>\n  */\n PIX *\n@@ -870,16 +863,13 @@ PIX\
    \       *pixt, *pixd;\n     pixGetDimensions(pixs, &w, &h, &d);\n     if (d !=\
    \ 8)\n         return (PIX *)ERROR_PTR(\"pixs not 8 bpp\", procName, NULL);\n\
    -    if (wc < 0) wc = 0;\n-    if (hc < 0) hc = 0;\n+    if (wc <= 0 || hc <=\
    \ 0)  /* no-op */\n+        return pixCopy(NULL, pixs);\n     if (w < 2 * wc +\
    \ 3 || h < 2 * hc + 3) {\n-        wc = L_MAX(0, L_MIN(wc, (w - 3) / 2));\n- \
    \       hc = L_MAX(0, L_MIN(hc, (h - 3) / 2));\n-        L_WARNING(\"kernel too\
    \ large; reducing!\\n\", procName);\n-        L_INFO(\"wc = %d, hc = %d\\n\",\
    \ procName, wc, hc);\n-    }\n-    if (wc == 0 && hc == 0)\n+        L_ERROR(\"\
    kernel is too large: w = %d, wc = %d, h = %d, hc = %d\\n\",\n+               \
    \ procName, w, wc, h, hc);\n         return pixCopy(NULL, pixs);\n+    }\n   \
    \  wd = w - 2 * wc;\n     hd = h - 2 * hc;\n "
  identifiers:
  - CVE-2022-38266
  - CWE-369
  overview: An issue in the Leptonica linked library (v1.79.0) allows attackers to
    cause an arithmetic exception leading to a Denial of Service (DoS) via a crafted
    JPEG file.
  references:
  - source: cve@mitre.org
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/DanBloomberg/leptonica/commit/f062b42c0ea8dddebdc6a152fd16152de215d614
  - source: cve@mitre.org
    tags:
    - Exploit
    - Issue Tracking
    - Third Party Advisory
    url: https://github.com/tesseract-ocr/tesseract/issues/3498
  - source: cve@mitre.org
    tags:
    - Mailing List
    - Third Party Advisory
    url: https://lists.debian.org/debian-lts-announce/2022/12/msg00018.html
  - source: cve@mitre.org
    url: https://security.gentoo.org/glsa/202312-01
  title: An issue in the Leptonica linked library (v1.79.0) allows attackers to cause
    an arithmetic exception leading to a Denial of Service (DoS) via a crafted JPEG
    file.
- diff_content:
  - "--- a/src/isomedia/box_code_base.c\n+++ b/src/isomedia/box_code_base.c\n@@ -12886,11\
    \ +12886,12 @@ GF_Err xtra_box_read(GF_Box *s, GF_BitStream *bs)\n \t\t\tprop_type\
    \ = gf_bs_read_u16(bs);\n \t\t\tprop_size -= 6;\n \t\t\tISOM_DECREASE_SIZE_NO_ERR(ptr,\
    \ prop_size)\n-\t\t\t//add 2 extra bytes for UTF16 case string dump\n-\t\t\tdata2\
    \ = gf_malloc(sizeof(char) * (prop_size+2));\n+\t\t\t//add 3 extra bytes for UTF16\
    \ case string dump (3 because we need 0-aligned short value)\n+\t\t\tdata2 = gf_malloc(sizeof(char)\
    \ * (prop_size+3));\n \t\t\tgf_bs_read_data(bs, data2, prop_size);\n \t\t\tdata2[prop_size]\
    \ = 0;\n \t\t\tdata2[prop_size+1] = 0;\n+\t\t\tdata2[prop_size+2] = 0;\n \t\t\t\
    tag_size-=prop_size;\n \t\t} else {\n \t\t\tprop_size = 0;"
  identifiers:
  - CVE-2022-3178
  - CWE-125
  overview: Buffer Over-read in GitHub repository gpac/gpac prior to 2.1.0-DEV.
  references:
  - source: security@huntr.dev
    tags:
    - Patch
    url: https://github.com/gpac/gpac/commit/77510778516803b7f7402d7423c6d6bef50254c3
  - source: security@huntr.dev
    tags:
    - Exploit
    - Patch
    - Third Party Advisory
    url: https://huntr.dev/bounties/f022fc50-3dfd-450a-ab47-3d75d2bf44c0
  title: Buffer Over-read in GitHub repository gpac/gpac prior to 2.1.0-DEV.
- diff_content:
  - "--- a/sound/core/control.c\n+++ b/sound/core/control.c\n@@ -391,7 +391,7 @@ static\
    \ unsigned long get_ctl_id_hash(const struct snd_ctl_elem_id *id)\n \th = id->iface;\n\
    \ \th = MULTIPLIER * h + id->device;\n \th = MULTIPLIER * h + id->subdevice;\n\
    -\tfor (i = 0; id->name[i] && i < SNDRV_CTL_ELEM_ID_NAME_MAXLEN; i++)\n+\tfor\
    \ (i = 0; i < SNDRV_CTL_ELEM_ID_NAME_MAXLEN && id->name[i]; i++)\n \t\th = MULTIPLIER\
    \ * h + id->name[i];\n \th = MULTIPLIER * h + id->index;\n \th &= LONG_MAX;"
  - "--- a/sound/core/control.c\n+++ b/sound/core/control.c\n@@ -385,14 +385,14 @@\
    \ static bool elem_id_matches(const struct snd_kcontrol *kctl,\n #define MULTIPLIER\t\
    37\n static unsigned long get_ctl_id_hash(const struct snd_ctl_elem_id *id)\n\
    \ {\n+\tint i;\n \tunsigned long h;\n-\tconst unsigned char *p;\n \n \th = id->iface;\n\
    \ \th = MULTIPLIER * h + id->device;\n \th = MULTIPLIER * h + id->subdevice;\n\
    -\tfor (p = id->name; *p; p++)\n-\t\th = MULTIPLIER * h + *p;\n+\tfor (i = 0;\
    \ id->name[i] && i < SNDRV_CTL_ELEM_ID_NAME_MAXLEN; i++)\n+\t\th = MULTIPLIER\
    \ * h + id->name[i];\n \th = MULTIPLIER * h + id->index;\n \th &= LONG_MAX;\n\
    \ \treturn h;"
  identifiers:
  - CVE-2022-3170
  - CWE-125
  overview: An out-of-bounds access issue was found in the Linux kernel sound subsystem.
    It could occur when the 'id->name' provided by the user did not end with '\0'.
    A privileged local user could pass a specially crafted name through ioctl() interface
    and crash the system or potentially escalate their privileges on the system.
  references:
  - source: secalert@redhat.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/torvalds/linux/commit/5934d9a0383619c14df91af8fd76261dc3de2f5f
  - source: secalert@redhat.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/torvalds/linux/commit/6ab55ec0a938c7f943a4edba3d6514f775983887
  title: An out-of-bounds access issue was found in the Linux kernel sound subsystem.
    It could occur when the 'id->name' provided by the user did not end with '\0'.
    A privileged local user could pass a specially crafted name through ioctl() interface
    and crash the system or potentially escalate their privileges on the system.
- diff_content:
  - "--- a/hw/net/tulip.c\n+++ b/hw/net/tulip.c\n@@ -70,7 +70,7 @@ static const VMStateDescription\
    \ vmstate_pci_tulip = {\n static void tulip_desc_read(TULIPState *s, hwaddr p,\n\
    \         struct tulip_descriptor *desc)\n {\n-    const MemTxAttrs attrs = MEMTXATTRS_UNSPECIFIED;\n\
    +    const MemTxAttrs attrs = { .memory = true };\n \n     if (s->csr[0] & CSR0_DBO)\
    \ {\n         ldl_be_pci_dma(&s->dev, p, &desc->status, attrs);\n@@ -88,7 +88,7\
    \ @@ static void tulip_desc_read(TULIPState *s, hwaddr p,\n static void tulip_desc_write(TULIPState\
    \ *s, hwaddr p,\n         struct tulip_descriptor *desc)\n {\n-    const MemTxAttrs\
    \ attrs = MEMTXATTRS_UNSPECIFIED;\n+    const MemTxAttrs attrs = { .memory = true\
    \ };\n \n     if (s->csr[0] & CSR0_DBO) {\n         stl_be_pci_dma(&s->dev, p,\
    \ desc->status, attrs);\n"
  identifiers:
  - CVE-2022-2962
  - CWE-662
  overview: A DMA reentrancy issue was found in the Tulip device emulation in QEMU.
    When Tulip reads or writes to the rx/tx descriptor or copies the rx/tx frame,
    it doesn't check whether the destination address is its own MMIO address. This
    can cause the device to trigger MMIO handlers multiple times, possibly leading
    to a stack or heap overflow. A malicious guest could use this flaw to crash the
    QEMU process on the host, resulting in a denial of service condition.
  references:
  - source: secalert@redhat.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://gitlab.com/qemu-project/qemu/-/commit/36a894aeb64a2e02871016da1c37d4a4ca109182
  - source: secalert@redhat.com
    tags:
    - Exploit
    - Issue Tracking
    - Third Party Advisory
    url: https://gitlab.com/qemu-project/qemu/-/issues/1171
  title: A DMA reentrancy issue was found in the Tulip device emulation in QEMU. When
    Tulip reads or writes to the rx/tx descriptor or copies the rx/tx frame, it doesn't
    check whether the destination address is its own MMIO address. This can cause
    the device to trigger MMIO handlers multiple times, possibly leading to a stack
    or heap overflow. A malicious guest could use this flaw to crash the QEMU process
    on the host, resulting in a denial of service condition.
- diff_content:
  - "--- a/src/helper.cpp\n+++ b/src/helper.cpp\n@@ -190,6 +190,10 @@ void Helper::startBenchmarkTest(int\
    \ measuringTime, int fileSize, int randomReadP\n \n QVariantMap Helper::flushPageCache()\n\
    \ {\n+    if (!isCallerAuthorized()) {\n+        return {};\n+    }\n+\n     QVariantMap\
    \ reply;\n     reply[QStringLiteral(\"success\")] = true;\n "
  identifiers:
  - CVE-2022-40673
  - CWE-862
  overview: KDiskMark before 3.1.0 lacks authorization checking for D-Bus methods
    such as Helper::flushPageCache.
  references:
  - source: cve@mitre.org
    tags:
    - Exploit
    - Issue Tracking
    - Mailing List
    - Third Party Advisory
    url: http://www.openwall.com/lists/oss-security/2022/09/14/1
  - source: cve@mitre.org
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/JonMagon/KDiskMark/commit/3c90083a4f5ba3f240a797e509d818221542bbdc
  - source: cve@mitre.org
    tags:
    - Release Notes
    - Third Party Advisory
    url: https://github.com/JonMagon/KDiskMark/compare/3.0.0...3.1.0
  - source: cve@mitre.org
    tags:
    - Release Notes
    - Third Party Advisory
    url: https://github.com/JonMagon/KDiskMark/releases/tag/3.1.0
  - source: cve@mitre.org
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/YYO3GWTNPHNCLHSI562Q3KX43PW7FQ4Q/
  title: KDiskMark before 3.1.0 lacks authorization checking for D-Bus methods such
    as Helper::flushPageCache.
- diff_content:
  - "--- a/fs/jfs/inode.c\n+++ b/fs/jfs/inode.c\n@@ -146,12 +146,13 @@ void jfs_evict_inode(struct\
    \ inode *inode)\n \t\tdquot_initialize(inode);\n \n \t\tif (JFS_IP(inode)->fileset\
    \ == FILESYSTEM_I) {\n+\t\t\tstruct inode *ipimap = JFS_SBI(inode->i_sb)->ipimap;\n\
    \ \t\t\ttruncate_inode_pages_final(&inode->i_data);\n \n \t\t\tif (test_cflag(COMMIT_Freewmap,\
    \ inode))\n \t\t\t\tjfs_free_zero_link(inode);\n \n-\t\t\tif (JFS_SBI(inode->i_sb)->ipimap)\n\
    +\t\t\tif (ipimap && JFS_IP(ipimap)->i_imap)\n \t\t\t\tdiFree(inode);\n \n \t\t\
    \t/*"
  identifiers:
  - CVE-2022-3202
  - CWE-476
  overview: A NULL pointer dereference flaw in diFree in fs/jfs/inode.c in Journaled
    File System (JFS)in the Linux kernel. This could allow a local attacker to crash
    the system or leak kernel internal information.
  references:
  - source: secalert@redhat.com
    tags:
    - Patch
    url: https://github.com/torvalds/linux/commit/a53046291020ec41e09181396c1e829287b48d47
  - source: secalert@redhat.com
    tags:
    - Third Party Advisory
    url: https://security.netapp.com/advisory/ntap-20221228-0007/
  title: A NULL pointer dereference flaw in diFree in fs/jfs/inode.c in Journaled
    File System (JFS)in the Linux kernel. This could allow a local attacker to crash
    the system or leak kernel internal information.
- diff_content:
  - "--- a/src/bifs/script_dec.c\n+++ b/src/bifs/script_dec.c\n@@ -40,6 +40,7 @@ typedef\
    \ struct\n \tGF_List *identifiers;\n \tchar *new_line;\n \tu32 indent;\n+\tu32\
    \ expr_stack_size;\n } ScriptParser;\n \n \n@@ -169,6 +170,7 @@ GF_Err SFScript_Parse(GF_BifsDecoder\
    \ *codec, SFScript *script_field, GF_BitStrea\n \te = GF_OK;\n \tif (gf_node_get_tag(n)\
    \ != TAG_MPEG4_Script) return GF_NON_COMPLIANT_BITSTREAM;\n \n+\tmemset(&parser,\
    \ 0, sizeof(ScriptParser));\n \tparser.codec = codec;\n \tparser.script = n;\n\
    \ \tparser.bs = bs;\n@@ -209,6 +211,10 @@ GF_Err SFScript_Parse(GF_BifsDecoder\
    \ *codec, SFScript *script_field, GF_BitStrea\n \t\tSFS_Space(&parser);\n \t\t\
    SFS_StatementBlock(&parser, GF_TRUE);\n \t\tSFS_Line(&parser);\n+\t\tif (codec->LastError)\
    \ {\n+\t\t\te = codec->LastError;\n+\t\t\tgoto exit;\n+\t\t}\n \t}\n \n \tSFS_Line(&parser);\n\
    @@ -418,6 +424,7 @@ void SFS_CompoundExpression(ScriptParser *parser)\n \tif (parser->codec->LastError)\
    \ return;\n \tSFS_Expression(parser);\n \tif (! gf_bs_read_int(parser->bs, 1))\
    \ return;\n+\tif (parser->codec->LastError) return;\n \tSFS_AddString(parser,\
    \ \",\");\n \tSFS_CompoundExpression(parser);\n }\n@@ -430,12 +437,20 @@ void\
    \ SFS_OptionalExpression(ScriptParser *parser)\n \t}\n }\n \n-\n+#define MAX_EXPR_STACK\t\
    500\n void SFS_Expression(ScriptParser *parser)\n {\n \tu32 val = gf_bs_read_int(parser->bs,\
    \ NUMBITS_EXPR_TYPE);\n \tif (parser->codec->LastError) return;\n \n+\t//limit\
    \ max expression stack size\n+\tparser->expr_stack_size++;\n+\tif (parser->expr_stack_size>MAX_EXPR_STACK)\
    \ {\n+\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODEC, (\"[BIFS] Max stack size %d reached\
    \ for expressions, not supported\\n\", MAX_EXPR_STACK))\n+\t\tparser->codec->LastError\
    \ = GF_NON_COMPLIANT_BITSTREAM;\n+\t\treturn;\n+\t}\n+\n \tswitch(val) {\n \t\
    case ET_CURVED_EXPR:\n \t\tSFS_AddString(parser, \"(\");\n@@ -675,6 +690,7 @@\
    \ void SFS_Expression(ScriptParser *parser)\n \t\tparser->codec->LastError = GF_NON_COMPLIANT_BITSTREAM;\n\
    \ \t\tbreak;\n \t}\n+\tparser->expr_stack_size--;\n }\n \n void SFS_NewObject(ScriptParser\
    \ *parser)\n@@ -691,6 +707,7 @@ void SFS_ArrayDeref(ScriptParser *parser)\n {\n\
    \ \tif (parser->codec->LastError) return;\n \tSFS_Expression(parser);\n+\tif (parser->codec->LastError)\
    \ return;\n \tSFS_AddString(parser, \"[\");\n \tSFS_CompoundExpression(parser);\n\
    \ \tSFS_AddString(parser, \"]\");\n@@ -709,6 +726,7 @@ void SFS_ObjectMemberAccess(ScriptParser\
    \ *parser)\n {\n \tif (parser->codec->LastError) return;\n \tSFS_Expression(parser);\n\
    +\tif (parser->codec->LastError) return;\n \tSFS_AddString(parser, \".\");\n \t\
    SFS_Identifier(parser);\n }\n@@ -718,6 +736,7 @@ void SFS_ObjectMethodCall(ScriptParser\
    \ *parser)\n {\n \tif (parser->codec->LastError) return;\n \tSFS_Expression(parser);\n\
    +\tif (parser->codec->LastError) return;\n \tSFS_AddString(parser, \".\");\n \t\
    SFS_Identifier(parser);\n \tSFS_AddString(parser, \"(\");\n@@ -732,6 +751,7 @@\
    \ void SFS_Params(ScriptParser *parser)\n \tval = gf_bs_read_int(parser->bs, 1);\n\
    \ \twhile (val) {\n \t\tSFS_Expression(parser);\n+\t\tif (parser->codec->LastError)\
    \ return;\n \t\tval = gf_bs_read_int(parser->bs, 1);\n \t\tif(val) SFS_AddString(parser,\
    \ \",\");\n \t}"
  identifiers:
  - CVE-2022-3222
  - CWE-674
  overview: Uncontrolled Recursion in GitHub repository gpac/gpac prior to 2.1.0-DEV.
  references:
  - source: security@huntr.dev
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/gpac/gpac/commit/4e7736d7ec7bf64026daa611da951993bb42fdaf
  - source: security@huntr.dev
    tags:
    - Exploit
    - Patch
    - Third Party Advisory
    url: https://huntr.dev/bounties/b29c69fa-3eac-41e4-9d4f-d861aba18235
  - source: security@huntr.dev
    url: https://www.debian.org/security/2023/dsa-5411
  title: Uncontrolled Recursion in GitHub repository gpac/gpac prior to 2.1.0-DEV.
- diff_content:
  - "--- a/src/inlines.c\n+++ b/src/inlines.c\n@@ -41,6 +41,8 @@ typedef struct bracket\
    \ {\n   bool image;\n   bool active;\n   bool bracket_after;\n+  bool in_bracket_image0;\n\
    +  bool in_bracket_image1;\n } bracket;\n \n typedef struct subject{\n@@ -516,6\
    \ +518,8 @@ static void push_bracket(subject *subj, bool image, cmark_node *inl_text)\
    \ {\n   bracket *b = (bracket *)subj->mem->calloc(1, sizeof(bracket));\n   if\
    \ (subj->last_bracket != NULL) {\n     subj->last_bracket->bracket_after = true;\n\
    +    b->in_bracket_image0 = subj->last_bracket->in_bracket_image0;\n+    b->in_bracket_image1\
    \ = subj->last_bracket->in_bracket_image1;\n   }\n   b->image = image;\n   b->active\
    \ = true;\n@@ -524,6 +528,11 @@ static void push_bracket(subject *subj, bool image,\
    \ cmark_node *inl_text) {\n   b->previous_delimiter = subj->last_delim;\n   b->position\
    \ = subj->pos;\n   b->bracket_after = false;\n+  if (image) {\n+    b->in_bracket_image1\
    \ = true;\n+  } else {\n+    b->in_bracket_image0 = true;\n+  }\n   subj->last_bracket\
    \ = b;\n }\n \n@@ -1254,6 +1263,17 @@ static cmark_node *handle_close_bracket(cmark_parser\
    \ *parser, subject *subj) {\n       }\n       opener = opener->previous;\n   \
    \  }\n+    bool in_bracket_image1 = false;\n+    if (opener) {\n+      in_bracket_image1\
    \ = opener->in_bracket_image1;\n+    }\n+    bracket *opener2 = subj->last_bracket;\n\
    +    while (opener2 != opener) {\n+      if (opener2->image) {\n+        opener2->in_bracket_image1\
    \ = in_bracket_image1;\n+      }\n+      opener2 = opener2->previous;\n+    }\n\
    \   }\n \n   return NULL;\n@@ -1662,10 +1682,15 @@ cmark_chunk *cmark_inline_parser_get_chunk(cmark_inline_parser\
    \ *parser) {\n }\n \n int cmark_inline_parser_in_bracket(cmark_inline_parser *parser,\
    \ int image) {\n-  for (bracket *b = parser->last_bracket; b; b = b->previous)\n\
    -    if (b->active && b->image == (image != 0))\n-      return 1;\n-  return 0;\n\
    +  bracket *b = parser->last_bracket;\n+  if (!b) {\n+    return 0;\n+  }\n+ \
    \ if (image != 0) {\n+    return b->in_bracket_image1;\n+  } else {\n+    return\
    \ b->in_bracket_image0;\n+  }\n }\n \n void cmark_node_unput(cmark_node *node,\
    \ int n) {"
  identifiers:
  - CVE-2022-39209
  - CWE-407
  overview: cmark-gfm is GitHub's fork of cmark, a CommonMark parsing and rendering
    library and program in C. In versions prior to 0.29.0.gfm.6 a polynomial time
    complexity issue in cmark-gfm's autolink extension may lead to unbounded resource
    exhaustion and subsequent denial of service. Users may verify the patch by running
    `python3 -c 'print("![l"* 100000 + "\n")' | ./cmark-gfm -e autolink`, which will
    resource exhaust on unpatched cmark-gfm but render correctly on patched cmark-gfm.
    This vulnerability has been patched in 0.29.0.gfm.6. Users are advised to upgrade.
    Users unable to upgrade should disable the use of the autolink extension.
  references:
  - source: security-advisories@github.com
    tags:
    - Third Party Advisory
    url: https://en.wikipedia.org/wiki/Time_complexity
  - source: security-advisories@github.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/github/cmark-gfm/commit/9d57d8a23142b316282bdfc954cb0ecda40a8655
  - source: security-advisories@github.com
    tags:
    - Third Party Advisory
    url: https://github.com/github/cmark-gfm/security/advisories/GHSA-cgh3-p57x-9q7q
  - source: security-advisories@github.com
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/JIUCZN3PEKUCT2JQYQTYOVIJG2KSD6G7/
  - source: security-advisories@github.com
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/JMGP65NANDVKPDMXMKYO2ZV2H2HZJY4P/
  - source: security-advisories@github.com
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/UEAAAI4OULDYQ2TA3HOXH54PC3DCBFZS/
  title: cmark-gfm is GitHub's fork of cmark, a CommonMark parsing and rendering library
    and program in C. In versions prior to 0.29.0.gfm.6 a polynomial time complexity
    issue in cmark-gfm's autolink extension may lead to unbounded resource exhaustion
    and subsequent denial of service. Users may verify the patch by running `python3
    -c 'print("![l"* 100000 + "\n")' | ./cmark-gfm -e autolink`, which will resource
    exhaust on unpatched cmark-gfm but render correctly on patched cmark-gfm. This
    vulnerability has been patched in 0.29.0.gfm.6. Users are advised to upgrade.
    Users unable to upgrade should disable the use of the autolink extension.
- diff_content:
  - "--- a/src/ops.c\n+++ b/src/ops.c\n@@ -1173,6 +1173,8 @@ op_replace(oparg_T *oap,\
    \ int c)\n \n \twhile (LTOREQ_POS(curwin->w_cursor, oap->end))\n \t{\n+\t    int\
    \ done = FALSE;\n+\n \t    n = gchar_cursor();\n \t    if (n != NUL)\n \t    {\n\
    @@ -1186,6 +1188,7 @@ op_replace(oparg_T *oap, int c)\n \t\t    if (curwin->w_cursor.lnum\
    \ == oap->end.lnum)\n \t\t\toap->end.col += new_byte_len - old_byte_len;\n \t\t\
    \    replace_character(c);\n+\t\t    done = TRUE;\n \t\t}\n \t\telse\n \t\t{\n\
    @@ -1204,10 +1207,15 @@ op_replace(oparg_T *oap, int c)\n \t\t\tif (curwin->w_cursor.lnum\
    \ == oap->end.lnum)\n \t\t\t    getvpos(&oap->end, end_vcol);\n \t\t    }\n-\t\
    \t    PBYTE(curwin->w_cursor, c);\n+\t\t    // with \"coladd\" set may move to\
    \ just after a TAB\n+\t\t    if (gchar_cursor() != NUL)\n+\t\t    {\n+\t\t\tPBYTE(curwin->w_cursor,\
    \ c);\n+\t\t\tdone = TRUE;\n+\t\t    }\n \t\t}\n \t    }\n-\t    else if (virtual_op\
    \ && curwin->w_cursor.lnum == oap->end.lnum)\n+\t    if (!done && virtual_op &&\
    \ curwin->w_cursor.lnum == oap->end.lnum)\n \t    {\n \t\tint virtcols = oap->end.coladd;\n\
    \ "
  - "--- a/src/version.c\n+++ b/src/version.c\n@@ -703,6 +703,8 @@ static char *(features[])\
    \ =\n \n static int included_patches[] =\n {   /* Add new patch number below this\
    \ line */\n+/**/\n+    483,\n /**/\n     482,\n /**/"
  identifiers:
  - CVE-2022-3234
  - CWE-122
  overview: Heap-based Buffer Overflow in GitHub repository vim/vim prior to 9.0.0483.
  references:
  - source: security@huntr.dev
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/vim/vim/commit/c249913edc35c0e666d783bfc21595cf9f7d9e0d
  - source: security@huntr.dev
    tags:
    - Exploit
    - Patch
    - Third Party Advisory
    url: https://huntr.dev/bounties/90fdf374-bf04-4386-8a23-38c83b88f0da
  - source: security@huntr.dev
    tags:
    - Mailing List
    - Third Party Advisory
    url: https://lists.debian.org/debian-lts-announce/2022/11/msg00009.html
  - source: security@huntr.dev
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/4QI7AETXBHPC7SGA77Q7O5IEGULWYET7/
  - source: security@huntr.dev
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/GTBVD4J2SKVSWK4VBN5JP5OEVK6GDS3N/
  - source: security@huntr.dev
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/LSSEWQLK55MCNT4Z2IIJEJYEI5HLCODI/
  - source: security@huntr.dev
    url: https://security.gentoo.org/glsa/202305-16
  title: Heap-based Buffer Overflow in GitHub repository vim/vim prior to 9.0.0483.
- diff_content:
  - "--- a/src/ex_getln.c\n+++ b/src/ex_getln.c\n@@ -1587,6 +1587,7 @@ getcmdline_int(\n\
    \ #endif\n     expand_T\txpc;\n     long\t*b_im_ptr = NULL;\n+    buf_T\t*b_im_ptr_buf\
    \ = NULL;\t// buffer where b_im_ptr is valid\n     cmdline_info_T save_ccline;\n\
    \     int\t\tdid_save_ccline = FALSE;\n     int\t\tcmdline_type;\n@@ -1683,6 +1684,7\
    \ @@ getcmdline_int(\n \t    b_im_ptr = &curbuf->b_p_iminsert;\n \telse\n \t \
    \   b_im_ptr = &curbuf->b_p_imsearch;\n+\tb_im_ptr_buf = curbuf;\n \tif (*b_im_ptr\
    \ == B_IMODE_LMAP)\n \t    State |= MODE_LANGMAP;\n #ifdef HAVE_INPUT_METHOD\n\
    @@ -2034,7 +2036,8 @@ getcmdline_int(\n \t\tgoto cmdline_not_changed;\n \n \t\
    case Ctrl_HAT:\n-\t\tcmdline_toggle_langmap(b_im_ptr);\n+\t\tcmdline_toggle_langmap(\n\
    +\t\t\t\t    buf_valid(b_im_ptr_buf) ? b_im_ptr : NULL);\n \t\tgoto cmdline_not_changed;\n\
    \ \n //\tcase '@':   only in very old vi\n@@ -2544,7 +2547,8 @@ getcmdline_int(\n\
    \ #endif\n \n #ifdef HAVE_INPUT_METHOD\n-    if (b_im_ptr != NULL && *b_im_ptr\
    \ != B_IMODE_LMAP)\n+    if (b_im_ptr != NULL && buf_valid(b_im_ptr_buf)\n+\t\t\
    \t\t\t\t  && *b_im_ptr != B_IMODE_LMAP)\n \tim_save_status(b_im_ptr);\n     im_set_active(FALSE);\n\
    \ #endif"
  - "--- a/src/version.c\n+++ b/src/version.c\n@@ -703,6 +703,8 @@ static char *(features[])\
    \ =\n \n static int included_patches[] =\n {   /* Add new patch number below this\
    \ line */\n+/**/\n+    490,\n /**/\n     489,\n /**/"
  identifiers:
  - CVE-2022-3235
  - CWE-416
  overview: Use After Free in GitHub repository vim/vim prior to 9.0.0490.
  references:
  - source: security@huntr.dev
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/vim/vim/commit/1c3dd8ddcba63c1af5112e567215b3cec2de11d0
  - source: security@huntr.dev
    tags:
    - Exploit
    - Patch
    - Third Party Advisory
    url: https://huntr.dev/bounties/96d5f7a0-a834-4571-b73b-0fe523b941af
  - source: security@huntr.dev
    tags:
    - Mailing List
    - Third Party Advisory
    url: https://lists.debian.org/debian-lts-announce/2022/11/msg00032.html
  - source: security@huntr.dev
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/4QI7AETXBHPC7SGA77Q7O5IEGULWYET7/
  - source: security@huntr.dev
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/GTBVD4J2SKVSWK4VBN5JP5OEVK6GDS3N/
  - source: security@huntr.dev
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/LSSEWQLK55MCNT4Z2IIJEJYEI5HLCODI/
  - source: security@huntr.dev
    url: https://security.gentoo.org/glsa/202305-16
  title: Use After Free in GitHub repository vim/vim prior to 9.0.0490.
- diff_content:
  - "--- a/coders/tiff.c\n+++ b/coders/tiff.c\n@@ -1892,7 +1892,7 @@ static Image\
    \ *ReadTIFFImage(const ImageInfo *image_info,\n         /*\n           Convert\
    \ stripped TIFF image.\n         */\n-        extent=4*(samples_per_pixel+1)*TIFFStripSize(tiff);\n\
    +        extent=4*((image->depth+7)/8)*(samples_per_pixel+1)*TIFFStripSize(tiff);\n\
    \         strip_pixels=(unsigned char *) AcquireQuantumMemory(extent,\n      \
    \     sizeof(*strip_pixels));\n         if (strip_pixels == (unsigned char *)\
    \ NULL)"
  - "--- a/coders/tiff.c\n+++ b/coders/tiff.c\n@@ -1798,7 +1798,7 @@ static Image\
    \ *ReadTIFFImage(const ImageInfo *image_info,\n         /*\n           Convert\
    \ stripped TIFF image.\n         */\n-        extent=4*(samples_per_pixel+1)*TIFFStripSize(tiff);\n\
    +        extent=4*((image->depth+7)/8)*(samples_per_pixel+1)*TIFFStripSize(tiff);\n\
    \         strip_pixels=(unsigned char *) AcquireQuantumMemory(extent,\n      \
    \     sizeof(*strip_pixels));\n         if (strip_pixels == (unsigned char *)\
    \ NULL)"
  identifiers:
  - CVE-2022-3213
  - CWE-787
  overview: A heap buffer overflow issue was found in ImageMagick. When an application
    processes a malformed TIFF file, it could lead to undefined behavior or a crash
    causing a denial of service.
  references:
  - source: secalert@redhat.com
    tags:
    - Third Party Advisory
    url: https://access.redhat.com/security/cve/CVE-2022-3213
  - source: secalert@redhat.com
    tags:
    - Issue Tracking
    - Patch
    - Third Party Advisory
    url: https://bugzilla.redhat.com/show_bug.cgi?id=2126824
  - source: secalert@redhat.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/ImageMagick/ImageMagick/commit/30ccf9a0da1f47161b5935a95be854fe84e6c2a2
  - source: secalert@redhat.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/ImageMagick/ImageMagick6/commit/1aea203eb36409ce6903b9e41fe7cb70030e8750
  title: A heap buffer overflow issue was found in ImageMagick. When an application
    processes a malformed TIFF file, it could lead to undefined behavior or a crash
    causing a denial of service.
- diff_content:
  - "--- a/bgpd/bgp_open.c\n+++ b/bgpd/bgp_open.c\n@@ -26,6 +26,7 @@ Software Foundation,\
    \ Inc., 59 Temple Place - Suite 330, Boston, MA\n #include \"thread.h\"\n #include\
    \ \"log.h\"\n #include \"command.h\"\n+#include \"memory.h\"\n \n #include \"\
    bgpd/bgpd.h\"\n #include \"bgpd/bgp_attr.h\"\n@@ -50,25 +51,28 @@ bgp_capability_vty_out\
    \ (struct vty *vty, struct peer *peer)\n {\n   char *pnt;\n   char *end;\n-  struct\
    \ capability cap;\n+  struct capability_mp_data mpc;\n+  struct capability_header\
    \ *hdr;\n \n   pnt = peer->notify.data;\n   end = pnt + peer->notify.length;\n\
    -\n+  \n   while (pnt < end)\n     {\n-      memcpy(&cap, pnt, sizeof(struct capability));\n\
    -\n-      if (pnt + 2 > end)\n+      if (pnt + sizeof (struct capability_mp_data)\
    \ + 2 > end)\n \treturn;\n-      if (pnt + (cap.length + 2) > end)\n+      \n\
    +      hdr = (struct capability_header *)pnt;\n+      if (pnt + hdr->length +\
    \ 2 > end)\n \treturn;\n \n-      if (cap.code == CAPABILITY_CODE_MP)\n+     \
    \ memcpy (&mpc, pnt + 2, sizeof(struct capability_mp_data));\n+\n+      if (hdr->code\
    \ == CAPABILITY_CODE_MP)\n \t{\n \t  vty_out (vty, \"  Capability error for: Multi\
    \ protocol \");\n \n-\t  switch (ntohs (cap.mpc.afi))\n+\t  switch (ntohs (mpc.afi))\n\
    \ \t    {\n \t    case AFI_IP:\n \t      vty_out (vty, \"AFI IPv4, \");\n@@ -77,10\
    \ +81,10 @@ bgp_capability_vty_out (struct vty *vty, struct peer *peer)\n \t \
    \     vty_out (vty, \"AFI IPv6, \");\n \t      break;\n \t    default:\n-\t  \
    \    vty_out (vty, \"AFI Unknown %d, \", ntohs (cap.mpc.afi));\n+\t      vty_out\
    \ (vty, \"AFI Unknown %d, \", ntohs (mpc.afi));\n \t      break;\n \t    }\n-\t\
    \  switch (cap.mpc.safi)\n+\t  switch (mpc.safi)\n \t    {\n \t    case SAFI_UNICAST:\n\
    \ \t      vty_out (vty, \"SAFI Unicast\");\n@@ -95,88 +99,87 @@ bgp_capability_vty_out\
    \ (struct vty *vty, struct peer *peer)\n \t      vty_out (vty, \"SAFI MPLS-VPN\"\
    );\n \t      break;\n \t    default:\n-\t      vty_out (vty, \"SAFI Unknown %d\
    \ \", cap.mpc.safi);\n+\t      vty_out (vty, \"SAFI Unknown %d \", mpc.safi);\n\
    \ \t      break;\n \t    }\n \t  vty_out (vty, \"%s\", VTY_NEWLINE);\n \t}\n-\
    \      else if (cap.code >= 128)\n+      else if (hdr->code >= 128)\n \tvty_out\
    \ (vty, \"  Capability error: vendor specific capability code %d\",\n-\t\t cap.code);\n\
    +\t\t hdr->code);\n       else\n \tvty_out (vty, \"  Capability error: unknown\
    \ capability code %d\", \n-\t\t cap.code);\n+\t\t hdr->code);\n \n-      pnt +=\
    \ cap.length + 2;\n+      pnt += hdr->length + 2;\n     }\n }\n \n-/* Set negotiated\
    \ capability value. */\n-static int\n-bgp_capability_mp (struct peer *peer, struct\
    \ capability *cap)\n+static void \n+bgp_capability_mp_data (struct stream *s,\
    \ struct capability_mp_data *mpc)\n {\n-  if (ntohs (cap->mpc.afi) == AFI_IP)\n\
    -    {\n-      if (cap->mpc.safi == SAFI_UNICAST)\n-\t{\n-\t  peer->afc_recv[AFI_IP][SAFI_UNICAST]\
    \ = 1;\n-\n-\t  if (peer->afc[AFI_IP][SAFI_UNICAST])\n-\t    peer->afc_nego[AFI_IP][SAFI_UNICAST]\
    \ = 1;\n-\t  else\n-\t    return -1;\n-\t}\n-      else if (cap->mpc.safi == SAFI_MULTICAST)\
    \ \n-\t{\n-\t  peer->afc_recv[AFI_IP][SAFI_MULTICAST] = 1;\n-\n-\t  if (peer->afc[AFI_IP][SAFI_MULTICAST])\n\
    -\t    peer->afc_nego[AFI_IP][SAFI_MULTICAST] = 1;\n-\t  else\n-\t    return -1;\n\
    -\t}\n-      else if (cap->mpc.safi == BGP_SAFI_VPNV4)\n-\t{\n-\t  peer->afc_recv[AFI_IP][SAFI_MPLS_VPN]\
    \ = 1;\n+  mpc->afi = stream_getw (s);\n+  mpc->reserved = stream_getc (s);\n\
    +  mpc->safi = stream_getc (s);\n+}\n \n-\t  if (peer->afc[AFI_IP][SAFI_MPLS_VPN])\n\
    -\t    peer->afc_nego[AFI_IP][SAFI_MPLS_VPN] = 1;\n-\t  else\n-\t    return -1;\n\
    -\t}\n-      else\n-\treturn -1;\n-    }\n-#ifdef HAVE_IPV6\n-  else if (ntohs\
    \ (cap->mpc.afi) == AFI_IP6)\n+int\n+bgp_afi_safi_valid_indices (afi_t afi, safi_t\
    \ *safi)\n+{\n+  /* VPNvX are AFI specific */\n+  if ((afi == AFI_IP6 && *safi\
    \ == BGP_SAFI_VPNV4)\n+      || (afi == AFI_IP && *safi == BGP_SAFI_VPNV6))\n\
    \     {\n-      if (cap->mpc.safi == SAFI_UNICAST)\n-\t{\n-\t  peer->afc_recv[AFI_IP6][SAFI_UNICAST]\
    \ = 1;\n-\n-\t  if (peer->afc[AFI_IP6][SAFI_UNICAST])\n-\t    peer->afc_nego[AFI_IP6][SAFI_UNICAST]\
    \ = 1;\n-\t  else\n-\t    return -1;\n-\t}\n-      else if (cap->mpc.safi == SAFI_MULTICAST)\n\
    -\t{\n-\t  peer->afc_recv[AFI_IP6][SAFI_MULTICAST] = 1;\n-\n-\t  if (peer->afc[AFI_IP6][SAFI_MULTICAST])\n\
    -\t    peer->afc_nego[AFI_IP6][SAFI_MULTICAST] = 1;\n-\t  else\n-\t    return\
    \ -1;\n-\t}\n-      else\n-\treturn -1;\n+      zlog_warn (\"Invalid afi/safi\
    \ combination (%u/%u)\", afi, *safi);\n+      return 0;\n     }\n-#endif /* HAVE_IPV6\
    \ */\n-  else\n+  \n+  switch (afi)\n     {\n-      /* Unknown Address Family.\
    \ */\n-      return -1;\n+      case AFI_IP:\n+#ifdef HAVE_IPV6\n+      case AFI_IP6:\n\
    +#endif\n+        switch (*safi)\n+          {\n+            /* BGP VPNvX SAFI\
    \ isn't contigious with others, remap */\n+            case BGP_SAFI_VPNV4:\n\
    +            case BGP_SAFI_VPNV6:\n+              *safi = SAFI_MPLS_VPN;\n+  \
    \          case SAFI_UNICAST:\n+            case SAFI_MULTICAST:\n+          \
    \  case SAFI_MPLS_VPN:\n+              return 1;\n+          }\n     }\n+  zlog_debug\
    \ (\"unknown afi/safi (%u/%u)\", afi, *safi);\n+  \n+  return 0;\n+}\n+\n+/* Set\
    \ negotiated capability value. */\n+static int\n+bgp_capability_mp (struct peer\
    \ *peer, struct capability_header *hdr)\n+{\n+  struct capability_mp_data mpc;\n\
    +  struct stream *s = BGP_INPUT (peer);\n+  \n+  bgp_capability_mp_data (s, &mpc);\n\
    +  \n+  if (BGP_DEBUG (normal, NORMAL))\n+    zlog_debug (\"%s OPEN has MP_EXT\
    \ CAP for afi/safi: %u/%u\",\n+               peer->host, mpc.afi, mpc.safi);\n\
    +  \n+  if (!bgp_afi_safi_valid_indices (mpc.afi, &mpc.safi))\n+    return -1;\n\
    +   \n+  /* Now safi remapped, and afi/safi are valid array indices */\n+  peer->afc_recv[mpc.afi][mpc.safi]\
    \ = 1;\n+  \n+  if (peer->afc[mpc.afi][mpc.safi])\n+    peer->afc_nego[mpc.safi][mpc.safi]\
    \ = 1;\n+  else \n+    return -1;\n \n   return 0;\n }\n@@ -190,98 +193,133 @@\
    \ bgp_capability_orf_not_support (struct peer *peer, afi_t afi, safi_t safi,\n\
    \ \t       peer->host, afi, safi, type, mode);\n }\n \n+static struct message\
    \ orf_type_str[] =\n+{\n+  { ORF_TYPE_PREFIX,\t\t\"Prefixlist\"\t\t},\n+  { ORF_TYPE_PREFIX_OLD,\t\
    \"Prefixlist (old)\"\t},\n+};\n+static int orf_type_str_max = sizeof(orf_type_str)/sizeof(orf_type_str[0]);\n\
    +\n+static struct message orf_mode_str[] =\n+{\n+  { ORF_MODE_RECEIVE,\t\"Receive\"\
    \t},\n+  { ORF_MODE_SEND,\t\"Send\"\t\t},\n+  { ORF_MODE_BOTH,\t\"Both\"\t\t},\n\
    +};\n+static int orf_mode_str_max = sizeof(orf_mode_str)/sizeof(orf_mode_str[0]);\n\
    +\n static int\n-bgp_capability_orf (struct peer *peer, struct capability *cap,\n\
    -\t\t    u_char *pnt)\n+bgp_capability_orf_entry (struct peer *peer, struct capability_header\
    \ *hdr)\n {\n-  afi_t afi = ntohs(cap->mpc.afi);\n-  safi_t safi = cap->mpc.safi;\n\
    -  u_char number_of_orfs;\n+  struct stream *s = BGP_INPUT (peer);\n+  struct\
    \ capability_orf_entry entry;\n+  afi_t afi;\n+  safi_t safi;\n   u_char type;\n\
    \   u_char mode;\n   u_int16_t sm_cap = 0; /* capability send-mode receive */\n\
    \   u_int16_t rm_cap = 0; /* capability receive-mode receive */ \n   int i;\n\
    \ \n-  /* Check length. */\n-  if (cap->length < 7)\n-    {\n-      zlog_info\
    \ (\"%s ORF Capability length error %d\",\n-\t\t peer->host, cap->length);\n-\t\
    \t bgp_notify_send (peer, BGP_NOTIFY_CEASE, 0);\n-      return -1;\n-    }\n-\n\
    +  /* ORF Entry header */\n+  bgp_capability_mp_data (s, &entry.mpc);\n+  entry.num\
    \ = stream_getc (s);\n+  afi = entry.mpc.afi;\n+  safi = entry.mpc.safi;\n+  \n\
    \   if (BGP_DEBUG (normal, NORMAL))\n-    zlog_debug (\"%s OPEN has ORF CAP(%s)\
    \ for afi/safi: %u/%u\",\n-\t       peer->host, (cap->code == CAPABILITY_CODE_ORF\
    \ ?\n-                       \"new\" : \"old\"), afi, safi);\n+    zlog_debug\
    \ (\"%s ORF Cap entry for afi/safi: %u/%u\",\n+\t        peer->host, entry.mpc.afi,\
    \ entry.mpc.safi);\n \n   /* Check AFI and SAFI. */\n-  if ((afi != AFI_IP &&\
    \ afi != AFI_IP6)\n-      || (safi != SAFI_UNICAST && safi != SAFI_MULTICAST\n\
    -\t  && safi != BGP_SAFI_VPNV4))\n+  if (!bgp_afi_safi_valid_indices (entry.mpc.afi,\
    \ &safi))\n+    {\n+      zlog_info (\"%s Addr-family %d/%d not supported.\"\n\
    +                 \" Ignoring the ORF capability\",\n+                 peer->host,\
    \ entry.mpc.afi, entry.mpc.safi);\n+      return 0;\n+    }\n+  \n+  /* validate\
    \ number field */\n+  if (sizeof (struct capability_orf_entry) + (entry.num *\
    \ 2) > hdr->length)\n     {\n-      zlog_info (\"%s Addr-family %d/%d not supported.\
    \ Ignoring the ORF capability\",\n-                 peer->host, afi, safi);\n\
    +      zlog_info (\"%s ORF Capability entry length error,\"\n+               \
    \  \" Cap length %u, num %u\",\n+                 peer->host, hdr->length, entry.num);\n\
    +      bgp_notify_send (peer, BGP_NOTIFY_CEASE, 0);\n       return -1;\n     }\n\
    \ \n-  number_of_orfs = *pnt++;\n-\n-  for (i = 0 ; i < number_of_orfs ; i++)\n\
    +  for (i = 0 ; i < entry.num ; i++)\n     {\n-      type = *pnt++;\n-      mode\
    \ = *pnt++;\n-\n+      type = stream_getc(s);\n+      mode = stream_getc(s);\n\
    +      \n       /* ORF Mode error check */\n-      if (mode != ORF_MODE_BOTH &&\
    \ mode != ORF_MODE_SEND\n-\t  && mode != ORF_MODE_RECEIVE)\n-\t{\n-\t  bgp_capability_orf_not_support\
    \ (peer, afi, safi, type, mode);\n-\t  continue;\n+      switch (mode)\n+    \
    \    {\n+          case ORF_MODE_BOTH:\n+          case ORF_MODE_SEND:\n+    \
    \      case ORF_MODE_RECEIVE:\n+            break;\n+          default:\n+\t \
    \   bgp_capability_orf_not_support (peer, afi, safi, type, mode);\n+\t    continue;\n\
    \ \t}\n+      /* ORF Type and afi/safi error checks */\n+      /* capcode versus\
    \ type */\n+      switch (hdr->code)\n+        {\n+          case CAPABILITY_CODE_ORF:\n\
    +            switch (type)\n+              {\n+                case ORF_TYPE_PREFIX:\n\
    +                  break;\n+                default:\n+                  bgp_capability_orf_not_support\
    \ (peer, afi, safi, type, mode);\n+                  continue;\n+            \
    \  }\n+            break;\n+          case CAPABILITY_CODE_ORF_OLD:\n+       \
    \     switch (type)\n+              {\n+                case ORF_TYPE_PREFIX_OLD:\n\
    +                  break;\n+                default:\n+                  bgp_capability_orf_not_support\
    \ (peer, afi, safi, type, mode);\n+                  continue;\n+            \
    \  }\n+            break;\n+          default:\n+            bgp_capability_orf_not_support\
    \ (peer, afi, safi, type, mode);\n+            continue;\n+        }\n+      \
    \          \n+      /* AFI vs SAFI */\n+      if (!((afi == AFI_IP && safi ==\
    \ SAFI_UNICAST)\n+            || (afi == AFI_IP && safi == SAFI_MULTICAST)\n+\
    \            || (afi == AFI_IP6 && safi == SAFI_UNICAST)))\n+        {\n+    \
    \      bgp_capability_orf_not_support (peer, afi, safi, type, mode);\n+      \
    \    continue;\n+        }\n+      \n+      if (BGP_DEBUG (normal, NORMAL))\n\
    +        zlog_debug (\"%s OPEN has %s ORF capability\"\n+                    \"\
    \ as %s for afi/safi: %d/%d\",\n+                    peer->host, LOOKUP (orf_type_str,\
    \ type),\n+                    LOOKUP (orf_mode_str, mode),\n+               \
    \     entry.mpc.afi, safi);\n \n-      /* ORF Type and afi/safi error check */\n\
    -      if (cap->code == CAPABILITY_CODE_ORF)\n+      if (hdr->code == CAPABILITY_CODE_ORF)\n\
    \ \t{\n-\t  if (type == ORF_TYPE_PREFIX &&\n-\t      ((afi == AFI_IP && safi ==\
    \ SAFI_UNICAST)\n-\t\t|| (afi == AFI_IP && safi == SAFI_MULTICAST)\n-\t\t|| (afi\
    \ == AFI_IP6 && safi == SAFI_UNICAST)))\n-\t    {\n-\t      sm_cap = PEER_CAP_ORF_PREFIX_SM_RCV;\n\
    -\t      rm_cap = PEER_CAP_ORF_PREFIX_RM_RCV;\n-\t      if (BGP_DEBUG (normal,\
    \ NORMAL))\n-\t\tzlog_debug (\"%s OPEN has Prefixlist ORF(%d) capability as %s\
    \ for afi/safi: %d/%d\",\n-\t\t\t   peer->host, ORF_TYPE_PREFIX, (mode == ORF_MODE_SEND\
    \ ? \"SEND\" :\n-\t\t\t   mode == ORF_MODE_RECEIVE ? \"RECEIVE\" : \"BOTH\") ,\
    \ afi, safi);\n-\t    }\n-\t  else\n-\t    {\n-\t      bgp_capability_orf_not_support\
    \ (peer, afi, safi, type, mode);\n-\t      continue;\n-\t    }\n+          sm_cap\
    \ = PEER_CAP_ORF_PREFIX_SM_RCV;\n+          rm_cap = PEER_CAP_ORF_PREFIX_RM_RCV;\n\
    \ \t}\n-      else if (cap->code == CAPABILITY_CODE_ORF_OLD)\n+      else if (hdr->code\
    \ == CAPABILITY_CODE_ORF_OLD)\n \t{\n-\t  if (type == ORF_TYPE_PREFIX_OLD &&\n\
    -\t      ((afi == AFI_IP && safi == SAFI_UNICAST)\n-\t\t|| (afi == AFI_IP && safi\
    \ == SAFI_MULTICAST)\n-\t\t|| (afi == AFI_IP6 && safi == SAFI_UNICAST)))\n-\t\
    \    {\n-\t      sm_cap = PEER_CAP_ORF_PREFIX_SM_OLD_RCV;\n-\t      rm_cap = PEER_CAP_ORF_PREFIX_RM_OLD_RCV;\n\
    -\t      if (BGP_DEBUG (normal, NORMAL))\n-\t\tzlog_debug (\"%s OPEN has Prefixlist\
    \ ORF(%d) capability as %s for afi/safi: %d/%d\",\n-\t\t\t   peer->host, ORF_TYPE_PREFIX_OLD,\
    \ (mode == ORF_MODE_SEND ? \"SEND\" :\n-\t\t\t   mode == ORF_MODE_RECEIVE ? \"\
    RECEIVE\" : \"BOTH\") , afi, safi);\n-\t    }\n-\t  else\n-\t    {\n-\t      bgp_capability_orf_not_support\
    \ (peer, afi, safi, type, mode);\n-\t      continue;\n-\t    }\n+          sm_cap\
    \ = PEER_CAP_ORF_PREFIX_SM_OLD_RCV;\n+          rm_cap = PEER_CAP_ORF_PREFIX_RM_OLD_RCV;\n\
    \ \t}\n       else\n \t{\n@@ -306,206 +344,258 @@ bgp_capability_orf (struct peer\
    \ *peer, struct capability *cap,\n   return 0;\n }\n \n-/* Parse given capability.\
    \ */\n static int\n-bgp_capability_parse (struct peer *peer, u_char *pnt, u_char\
    \ length,\n-\t\t      u_char **error)\n+bgp_capability_orf (struct peer *peer,\
    \ struct capability_header *hdr)\n {\n-  int ret;\n-  u_char *end;\n-  struct\
    \ capability cap;\n-\n-  end = pnt + length;\n-\n-  while (pnt < end)\n+  struct\
    \ stream *s = BGP_INPUT (peer);\n+  size_t end = stream_get_getp (s) + hdr->length;\n\
    +  \n+  assert (stream_get_getp(s) + sizeof(struct capability_orf_entry) <= end);\n\
    +  \n+  /* We must have at least one ORF entry, as the caller has already done\n\
    +   * minimum length validation for the capability code - for ORF there must\n\
    +   * at least one ORF entry (header and unknown number of pairs of bytes).\n\
    +   */\n+  do\n     {\n-      afi_t afi;\n-      safi_t safi;\n+      if (bgp_capability_orf_entry\
    \ (peer, hdr) == -1)\n+        return -1;\n+    } \n+  while (stream_get_getp(s)\
    \ + sizeof(struct capability_orf_entry) < end);\n+  \n+  return 0;\n+}\n \n- \
    \     /* Fetch structure to the byte stream. */\n-      memcpy (&cap, pnt, sizeof\
    \ (struct capability));\n+static int\n+bgp_capability_restart (struct peer *peer,\
    \ struct capability_header *caphdr)\n+{\n+  struct stream *s = BGP_INPUT (peer);\n\
    +  u_int16_t restart_flag_time;\n+  int restart_bit = 0;\n+  size_t end = stream_get_getp\
    \ (s) + caphdr->length;\n+\n+  SET_FLAG (peer->cap, PEER_CAP_RESTART_RCV);\n+\
    \  restart_flag_time = stream_getw(s);\n+  if (CHECK_FLAG (restart_flag_time,\
    \ RESTART_R_BIT))\n+    restart_bit = 1;\n+  UNSET_FLAG (restart_flag_time, 0xF000);\n\
    +  peer->v_gr_restart = restart_flag_time;\n \n-      afi = ntohs(cap.mpc.afi);\n\
    -      safi = cap.mpc.safi;\n+  if (BGP_DEBUG (normal, NORMAL))\n+    {\n+   \
    \   zlog_debug (\"%s OPEN has Graceful Restart capability\", peer->host);\n+ \
    \     zlog_debug (\"%s Peer has%srestarted. Restart Time : %d\",\n+          \
    \        peer->host, restart_bit ? \" \" : \" not \",\n+                  peer->v_gr_restart);\n\
    +    }\n \n-      if (BGP_DEBUG (normal, NORMAL))\n-\tzlog_debug (\"%s OPEN has\
    \ CAPABILITY code: %d, length %d\",\n-\t\t   peer->host, cap.code, cap.length);\n\
    +  while (stream_get_getp (s) + 4 < end)\n+    {\n+      afi_t afi = stream_getw\
    \ (s);\n+      safi_t safi = stream_getc (s);\n+      u_char flag = stream_getc\
    \ (s);\n+      \n+      if (!bgp_afi_safi_valid_indices (afi, &safi))\n+     \
    \   {\n+          if (BGP_DEBUG (normal, NORMAL))\n+            zlog_debug (\"\
    %s Addr-family %d/%d(afi/safi) not supported.\"\n+                        \" Ignore\
    \ the Graceful Restart capability\",\n+                        peer->host, afi,\
    \ safi);\n+        }\n+      else if (!peer->afc[afi][safi])\n+        {\n+  \
    \        if (BGP_DEBUG (normal, NORMAL))\n+            zlog_debug (\"%s Addr-family\
    \ %d/%d(afi/safi) not enabled.\"\n+                        \" Ignore the Graceful\
    \ Restart capability\",\n+                        peer->host, afi, safi);\n+ \
    \       }\n+      else\n+        {\n+          if (BGP_DEBUG (normal, NORMAL))\n\
    +            zlog_debug (\"%s Address family %s is%spreserved\", peer->host,\n\
    +                        afi_safi_print (afi, safi),\n+                      \
    \  CHECK_FLAG (peer->af_cap[afi][safi],\n+                                   \
    \ PEER_CAP_RESTART_AF_PRESERVE_RCV)\n+                        ? \" \" : \" not\
    \ \");\n+\n+          SET_FLAG (peer->af_cap[afi][safi], PEER_CAP_RESTART_AF_RCV);\n\
    +          if (CHECK_FLAG (flag, RESTART_F_BIT))\n+            SET_FLAG (peer->af_cap[afi][safi],\
    \ PEER_CAP_RESTART_AF_PRESERVE_RCV);\n+          \n+        }\n+    }\n+  return\
    \ 0;\n+}\n \n+static struct message capcode_str[] =\n+{\n+  { 0,\t\"\"},\n+  {\
    \ CAPABILITY_CODE_MP,\t\t\t\"MultiProtocol Extensions\"\t},\n+  { CAPABILITY_CODE_REFRESH,\t\
    \t\"Route Refresh\"\t\t\t},\n+  { CAPABILITY_CODE_ORF,\t\t\"Cooperative Route\
    \ Filtering\" \t},\n+  { CAPABILITY_CODE_RESTART,\t\t\"Graceful Restart\"\t\t\
    },\n+  { CAPABILITY_CODE_AS4,\t\t\"4-octet AS number\"\t\t},\n+  { CAPABILITY_CODE_DYNAMIC,\t\
    \t\"Dynamic\"\t\t\t},\n+  { CAPABILITY_CODE_REFRESH_OLD,\t\"Route Refresh (Old)\"\
    \t\t},\n+  { CAPABILITY_CODE_ORF_OLD,\t\t\"ORF (Old)\"\t\t\t},\n+};\n+int capcode_str_max\
    \ = sizeof(capcode_str)/sizeof(capcode_str[0]);\n+\n+/* Minimum sizes for length\
    \ field of each cap (so not inc. the header) */\n+static size_t cap_minsizes[]\
    \ = \n+{\n+  [CAPABILITY_CODE_MP]\t\t= sizeof (struct capability_mp_data),\n+\
    \  [CAPABILITY_CODE_REFRESH]\t= CAPABILITY_CODE_REFRESH_LEN,\n+  [CAPABILITY_CODE_ORF]\t\
    \t= sizeof (struct capability_orf_entry),\n+  [CAPABILITY_CODE_RESTART]\t= sizeof\
    \ (struct capability_gr) - 2,\n+  [CAPABILITY_CODE_AS4]\t\t= CAPABILITY_CODE_AS4_LEN,\n\
    +  [CAPABILITY_CODE_DYNAMIC]\t= CAPABILITY_CODE_DYNAMIC_LEN,\n+  [CAPABILITY_CODE_REFRESH_OLD]\t\
    = CAPABILITY_CODE_REFRESH_LEN,\n+  [CAPABILITY_CODE_ORF_OLD]\t= sizeof (struct\
    \ capability_orf_entry),\n+};\n+\n+/* Parse given capability.\n+ * XXX: This is\
    \ reading into a stream, but not using stream API\n+ */\n+static int\n+bgp_capability_parse\
    \ (struct peer *peer, size_t length, u_char **error)\n+{\n+  int ret;\n+  struct\
    \ stream *s = BGP_INPUT (peer);\n+  size_t end = stream_get_getp (s) + length;\n\
    +  \n+  assert (STREAM_READABLE (s) >= length);\n+  \n+  while (stream_get_getp\
    \ (s) < end)\n+    {\n+      size_t start;\n+      u_char *sp = stream_pnt (s);\n\
    +      struct capability_header caphdr;\n+      \n       /* We need at least capability\
    \ code and capability length. */\n-      if (pnt + 2 > end)\n+      if (stream_get_getp(s)\
    \ + 2 > end)\n \t{\n-\t  zlog_info (\"%s Capability length error\", peer->host);\n\
    +\t  zlog_info (\"%s Capability length error (< header)\", peer->host);\n \t \
    \ bgp_notify_send (peer, BGP_NOTIFY_CEASE, 0);\n \t  return -1;\n \t}\n-\n-  \
    \    /* Capability length check. */\n-      if (pnt + (cap.length + 2) > end)\n\
    +      \n+      caphdr.code = stream_getc (s);\n+      caphdr.length = stream_getc\
    \ (s);\n+      start = stream_get_getp (s);\n+      \n+      /* Capability length\
    \ check sanity check. */\n+      if (start + caphdr.length > end)\n \t{\n-\t \
    \ zlog_info (\"%s Capability length error\", peer->host);\n+\t  zlog_info (\"\
    %s Capability length error (< length)\", peer->host);\n \t  bgp_notify_send (peer,\
    \ BGP_NOTIFY_CEASE, 0);\n \t  return -1;\n \t}\n-\n-      /* We know MP Capability\
    \ Code. */\n-      if (cap.code == CAPABILITY_CODE_MP)\n-\t{\n-\t  if (BGP_DEBUG\
    \ (normal, NORMAL))\n-\t    zlog_debug (\"%s OPEN has MP_EXT CAP for afi/safi:\
    \ %u/%u\",\n-\t\t       peer->host, afi, safi);\n-\n-\t  /* Ignore capability\
    \ when override-capability is set. */\n-\t  if (! CHECK_FLAG (peer->flags, PEER_FLAG_OVERRIDE_CAPABILITY))\n\
    -\t    {\n-\t      /* Set negotiated value. */\n-\t      ret = bgp_capability_mp\
    \ (peer, &cap);\n-\n-\t      /* Unsupported Capability. */\n-\t      if (ret <\
    \ 0)\n-\t\t{\n-\t\t  /* Store return data. */\n-\t\t  memcpy (*error, &cap, cap.length\
    \ + 2);\n-\t\t  *error += cap.length + 2;\n-\t\t}\n-\t    }\n-\t}\n-      else\
    \ if (cap.code == CAPABILITY_CODE_REFRESH\n-\t       || cap.code == CAPABILITY_CODE_REFRESH_OLD)\n\
    -\t{\n-\t  /* Check length. */\n-\t  if (cap.length != CAPABILITY_CODE_REFRESH_LEN)\n\
    -\t    {\n-\t      zlog_info (\"%s Route Refresh Capability length error %d\"\
    ,\n-\t\t\t peer->host, cap.length);\n-\t      bgp_notify_send (peer, BGP_NOTIFY_CEASE,\
    \ 0);\n-\t      return -1;\n-\t    }\n-\n-\t  if (BGP_DEBUG (normal, NORMAL))\n\
    -\t    zlog_debug (\"%s OPEN has ROUTE-REFRESH capability(%s) for all address-families\"\
    ,\n-\t\t       peer->host,\n-\t\t       cap.code == CAPABILITY_CODE_REFRESH_OLD\
    \ ? \"old\" : \"new\");\n-\n-\t  /* BGP refresh capability */\n-\t  if (cap.code\
    \ == CAPABILITY_CODE_REFRESH_OLD)\n-\t    SET_FLAG (peer->cap, PEER_CAP_REFRESH_OLD_RCV);\n\
    -\t  else\n-\t    SET_FLAG (peer->cap, PEER_CAP_REFRESH_NEW_RCV);\n-\t}\n-   \
    \   else if (cap.code == CAPABILITY_CODE_ORF\n-\t       || cap.code == CAPABILITY_CODE_ORF_OLD)\n\
    -\tbgp_capability_orf (peer, &cap, pnt + sizeof (struct capability));\n-     \
    \ else if (cap.code == CAPABILITY_CODE_RESTART)\n-       {\n-         struct graceful_restart_af\
    \ graf;\n-         u_int16_t restart_flag_time;\n-         int restart_bit = 0;\n\
    -         u_char *restart_pnt;\n-         u_char *restart_end;\n-\n-         /*\
    \ Check length. */\n-         if (cap.length < CAPABILITY_CODE_RESTART_LEN)\n\
    -           {\n-             zlog_info (\"%s Graceful Restart Capability length\
    \ error %d\",\n-                        peer->host, cap.length);\n-          \
    \   bgp_notify_send (peer, BGP_NOTIFY_CEASE, 0);\n-             return -1;\n-\
    \           }\n-\n-         SET_FLAG (peer->cap, PEER_CAP_RESTART_RCV);\n-   \
    \      restart_flag_time = ntohs(cap.mpc.afi);\n-         if (CHECK_FLAG (restart_flag_time,\
    \ RESTART_R_BIT))\n-           restart_bit = 1;\n-         UNSET_FLAG (restart_flag_time,\
    \ 0xF000);\n-\t peer->v_gr_restart = restart_flag_time;\n-\n-         if (BGP_DEBUG\
    \ (normal, NORMAL))\n-           {\n-             zlog_debug (\"%s OPEN has Graceful\
    \ Restart capability\", peer->host);\n-             zlog_debug (\"%s Peer has%srestarted.\
    \ Restart Time : %d\",\n-                        peer->host, restart_bit ? \"\
    \ \" : \" not \",\n-\t\t\tpeer->v_gr_restart);\n-           }\n-\n-         restart_pnt\
    \ = pnt + 4;\n-         restart_end = pnt + cap.length + 2;\n-\n-         while\
    \ (restart_pnt < restart_end)\n-           {\n-             memcpy (&graf, restart_pnt,\
    \ sizeof (struct graceful_restart_af));\n-\n-             afi = ntohs(graf.afi);\n\
    -             safi = graf.safi;\n-\n-             if (CHECK_FLAG (graf.flag, RESTART_F_BIT))\n\
    -\t\tSET_FLAG (peer->af_cap[afi][safi], PEER_CAP_RESTART_AF_PRESERVE_RCV);\n-\n\
    -             if (strcmp (afi_safi_print (afi, safi), \"Unknown\") == 0)\n-  \
    \             {\n-                  if (BGP_DEBUG (normal, NORMAL))\n-       \
    \             zlog_debug (\"%s Addr-family %d/%d(afi/safi) not supported. I gnore\
    \ the Graceful Restart capability\",\n-                               peer->host,\
    \ afi, safi);\n-               }\n-             else if (! peer->afc[afi][safi])\n\
    -               {\n-                  if (BGP_DEBUG (normal, NORMAL))\n-     \
    \                zlog_debug (\"%s Addr-family %d/%d(afi/safi) not enabled. Ignore\
    \ the Graceful Restart capability\",\n-                                peer->host,\
    \ afi, safi);\n-               }\n-             else\n-               {\n-   \
    \              if (BGP_DEBUG (normal, NORMAL))\n-                   zlog_debug\
    \ (\"%s Address family %s is%spreserved\", peer->host,\n-\t\t\t       afi_safi_print\
    \ (afi, safi),\n-\t\t\t       CHECK_FLAG (peer->af_cap[afi][safi],\n-\t\t\t  \
    \     PEER_CAP_RESTART_AF_PRESERVE_RCV)\n-\t\t\t       ? \" \" : \" not \");\n\
    -\n-                   SET_FLAG (peer->af_cap[afi][safi], PEER_CAP_RESTART_AF_RCV);\n\
    -               }\n-             restart_pnt += 4;\n-           }\n-       }\n\
    -      else if (cap.code == CAPABILITY_CODE_DYNAMIC)\n-\t{\n-\t  /* Check length.\
    \ */\n-\t  if (cap.length != CAPABILITY_CODE_DYNAMIC_LEN)\n-\t    {\n-\t     \
    \ zlog_info (\"%s Dynamic Capability length error %d\",\n-\t\t\t peer->host, cap.length);\n\
    -\t      bgp_notify_send (peer, BGP_NOTIFY_CEASE, 0);\n-\t      return -1;\n-\t\
    \    }\n-\n-\t  if (BGP_DEBUG (normal, NORMAL))\n-\t    zlog_debug (\"%s OPEN\
    \ has DYNAMIC capability\", peer->host);\n-\n-\t  SET_FLAG (peer->cap, PEER_CAP_DYNAMIC_RCV);\n\
    -\t}\n- \n-      else if (cap.code > 128)\n-\t{\n-\t  /* We don't send Notification\
    \ for unknown vendor specific\n-\t     capabilities.  It seems reasonable for\
    \ now...  */\n-\t  zlog_warn (\"%s Vendor specific capability %d\",\n-\t\t   \
    \  peer->host, cap.code);\n-\t}\n-      else\n-\t{\n-\t  zlog_warn (\"%s unrecognized\
    \ capability code: %d - ignored\",\n-\t\t     peer->host, cap.code);\n-\t  memcpy\
    \ (*error, &cap, cap.length + 2);\n-\t  *error += cap.length + 2;\n-\t}\n-\n-\
    \      pnt += cap.length + 2;\n+      \n+      if (BGP_DEBUG (normal, NORMAL))\n\
    +\tzlog_debug (\"%s OPEN has %s capability (%u), length %u\",\n+\t\t   peer->host,\n\
    +\t\t   LOOKUP (capcode_str, caphdr.code),\n+\t\t   caphdr.code, caphdr.length);\n\
    +      \n+      /* Length sanity check, type-specific, for known capabilities\
    \ */\n+      switch (caphdr.code)\n+        {\n+          case CAPABILITY_CODE_MP:\n\
    +          case CAPABILITY_CODE_REFRESH:\n+          case CAPABILITY_CODE_REFRESH_OLD:\n\
    +          case CAPABILITY_CODE_ORF:\n+          case CAPABILITY_CODE_ORF_OLD:\n\
    +          case CAPABILITY_CODE_RESTART:\n+          case CAPABILITY_CODE_DYNAMIC:\n\
    +              /* Check length. */\n+              if (caphdr.length < cap_minsizes[caphdr.code])\n\
    +                {\n+                  zlog_info (\"%s %s Capability length error:\
    \ got %u,\"\n+                             \" expected at least %u\",\n+     \
    \                        peer->host, \n+                             LOOKUP (capcode_str,\
    \ caphdr.code),\n+                             caphdr.length, cap_minsizes[caphdr.code]);\n\
    +                  bgp_notify_send (peer, BGP_NOTIFY_CEASE, 0);\n+           \
    \       return -1;\n+                }\n+          /* we deliberately ignore unknown\
    \ codes, see below */\n+          default:\n+            break;\n+        }\n\
    +      \n+      switch (caphdr.code)\n+        {\n+          case CAPABILITY_CODE_MP:\n\
    +            {\n+              /* Ignore capability when override-capability is\
    \ set. */\n+              if (! CHECK_FLAG (peer->flags, PEER_FLAG_OVERRIDE_CAPABILITY))\n\
    +                {\n+                  /* Set negotiated value. */\n+        \
    \          ret = bgp_capability_mp (peer, &caphdr);\n+\n+                  /*\
    \ Unsupported Capability. */\n+                  if (ret < 0)\n+             \
    \       {\n+                      /* Store return data. */\n+                \
    \      memcpy (*error, sp, caphdr.length + 2);\n+                      *error\
    \ += caphdr.length + 2;\n+                    }\n+                }\n+       \
    \     }\n+            break;\n+          case CAPABILITY_CODE_REFRESH:\n+    \
    \      case CAPABILITY_CODE_REFRESH_OLD:\n+            {\n+              /* BGP\
    \ refresh capability */\n+              if (caphdr.code == CAPABILITY_CODE_REFRESH_OLD)\n\
    +                SET_FLAG (peer->cap, PEER_CAP_REFRESH_OLD_RCV);\n+          \
    \    else\n+                SET_FLAG (peer->cap, PEER_CAP_REFRESH_NEW_RCV);\n\
    +            }\n+            break;\n+          case CAPABILITY_CODE_ORF:\n+ \
    \         case CAPABILITY_CODE_ORF_OLD:\n+            if (bgp_capability_orf (peer,\
    \ &caphdr))\n+              return -1;\n+            break;\n+          case CAPABILITY_CODE_RESTART:\n\
    +            if (bgp_capability_restart (peer, &caphdr))\n+              return\
    \ -1;\n+            break;\n+          case CAPABILITY_CODE_DYNAMIC:\n+      \
    \      SET_FLAG (peer->cap, PEER_CAP_DYNAMIC_RCV);\n+            break;\n+   \
    \       default:\n+            if (caphdr.code > 128)\n+              {\n+   \
    \             /* We don't send Notification for unknown vendor specific\n+   \
    \                capabilities.  It seems reasonable for now...  */\n+        \
    \        zlog_warn (\"%s Vendor specific capability %d\",\n+                 \
    \          peer->host, caphdr.code);\n+              }\n+            else\n+ \
    \             {\n+                zlog_warn (\"%s unrecognized capability code:\
    \ %d - ignored\",\n+                           peer->host, caphdr.code);\n+  \
    \              memcpy (*error, sp, caphdr.length + 2);\n+                *error\
    \ += caphdr.length + 2;\n+              }\n+          }\n+      if (stream_get_getp(s)\
    \ != (start + caphdr.length))\n+        {\n+          if (stream_get_getp(s) >\
    \ (start + caphdr.length))\n+            zlog_warn (\"%s Cap-parser for %s read\
    \ past cap-length, %u!\",\n+                       peer->host, LOOKUP (capcode_str,\
    \ caphdr.code),\n+                       caphdr.length);\n+          stream_set_getp\
    \ (s, start + caphdr.length);\n+        }\n     }\n   return 0;\n }\n \n static\
    \ int\n-bgp_auth_parse (struct peer *peer, u_char *pnt, size_t length)\n+bgp_auth_parse\
    \ (struct peer *peer, size_t length)\n {\n   bgp_notify_send (peer, \n \t\t  \
    \ BGP_NOTIFY_OPEN_ERR, \n@@ -530,42 +620,37 @@ int\n bgp_open_option_parse (struct\
    \ peer *peer, u_char length, int *capability)\n {\n   int ret;\n-  u_char *end;\n\
    -  u_char opt_type;\n-  u_char opt_length;\n-  u_char *pnt;\n   u_char *error;\n\
    \   u_char error_data[BGP_MAX_PACKET_SIZE];\n-\n-  /* Fetch pointer. */\n-  pnt\
    \ = stream_pnt (peer->ibuf);\n+  struct stream *s = BGP_INPUT(peer);\n+  size_t\
    \ end = stream_get_getp (s) + length;\n \n   ret = 0;\n-  opt_type = 0;\n-  opt_length\
    \ = 0;\n-  end = pnt + length;\n   error = error_data;\n \n   if (BGP_DEBUG (normal,\
    \ NORMAL))\n     zlog_debug (\"%s rcv OPEN w/ OPTION parameter len: %u\",\n \t\
    \       peer->host, length);\n   \n-  while (pnt < end) \n+  while (stream_get_getp(s)\
    \ < end)\n     {\n-      /* Check the length. */\n-      if (pnt + 2 > end)\n\
    +      u_char opt_type;\n+      u_char opt_length;\n+      \n+      /* Must have\
    \ at least an OPEN option header */\n+      if (STREAM_READABLE(s) < 2)\n \t{\n\
    \ \t  zlog_info (\"%s Option length error\", peer->host);\n \t  bgp_notify_send\
    \ (peer, BGP_NOTIFY_CEASE, 0);\n \t  return -1;\n \t}\n \n       /* Fetch option\
    \ type and length. */\n-      opt_type = *pnt++;\n-      opt_length = *pnt++;\n\
    +      opt_type = stream_getc (s);\n+      opt_length = stream_getc (s);\n   \
    \    \n       /* Option length check. */\n-      if (pnt + opt_length > end)\n\
    +      if (STREAM_READABLE (s) < opt_length)\n \t{\n \t  zlog_info (\"%s Option\
    \ length error\", peer->host);\n \t  bgp_notify_send (peer, BGP_NOTIFY_CEASE,\
    \ 0);\n@@ -582,10 +667,10 @@ bgp_open_option_parse (struct peer *peer, u_char\
    \ length, int *capability)\n       switch (opt_type)\n \t{\n \tcase BGP_OPEN_OPT_AUTH:\n\
    -\t  ret = bgp_auth_parse (peer, pnt, opt_length);\n+\t  ret = bgp_auth_parse\
    \ (peer, opt_length);\n \t  break;\n \tcase BGP_OPEN_OPT_CAP:\n-\t  ret = bgp_capability_parse\
    \ (peer, pnt, opt_length, &error);\n+\t  ret = bgp_capability_parse (peer, opt_length,\
    \ &error);\n \t  *capability = 1;\n \t  break;\n \tdefault:\n@@ -602,9 +687,6\
    \ @@ bgp_open_option_parse (struct peer *peer, u_char length, int *capability)\n\
    \          error and erro_data pointer, like below.  */\n       if (ret < 0)\n\
    \ \treturn -1;\n-\n-      /* Forward pointer. */\n-      pnt += opt_length;\n\
    \     }\n \n   /* All OPEN option is parsed.  Check capability when strict compare"
  - "--- a/bgpd/bgp_packet.c\n+++ b/bgpd/bgp_packet.c\n@@ -1371,8 +1371,6 @@ bgp_open_receive\
    \ (struct peer *peer, bgp_size_t size)\n       ret = bgp_open_option_parse (peer,\
    \ optlen, &capability);\n       if (ret < 0)\n \treturn ret;\n-\n-      stream_forward_getp\
    \ (peer->ibuf, optlen);\n     }\n   else\n     {\n@@ -1991,7 +1989,8 @@ static\
    \ int\n bgp_capability_msg_parse (struct peer *peer, u_char *pnt, bgp_size_t length)\n\
    \ {\n   u_char *end;\n-  struct capability cap;\n+  struct capability_mp_data\
    \ mpc;\n+  struct capability_header *hdr;\n   u_char action;\n   struct bgp *bgp;\n\
    \   afi_t afi;\n@@ -2001,20 +2000,17 @@ bgp_capability_msg_parse (struct peer\
    \ *peer, u_char *pnt, bgp_size_t length)\n   end = pnt + length;\n \n   while\
    \ (pnt < end)\n-    {\n+    {      \n       /* We need at least action, capability\
    \ code and capability length. */\n       if (pnt + 3 > end)\n         {\n    \
    \       zlog_info (\"%s Capability length error\", peer->host);\n           bgp_notify_send\
    \ (peer, BGP_NOTIFY_CEASE, 0);\n           return -1;\n         }\n-\n       action\
    \ = *pnt;\n-\n-      /* Fetch structure to the byte stream. */\n-      memcpy\
    \ (&cap, pnt + 1, sizeof (struct capability));\n-\n+      hdr = (struct capability_header\
    \ *)(pnt + 1);\n+      \n       /* Action value check.  */\n       if (action\
    \ != CAPABILITY_ACTION_SET\n \t  && action != CAPABILITY_ACTION_UNSET)\n@@ -2027,77\
    \ +2023,77 @@ bgp_capability_msg_parse (struct peer *peer, u_char *pnt, bgp_size_t\
    \ length)\n \n       if (BGP_DEBUG (normal, NORMAL))\n \tzlog_debug (\"%s CAPABILITY\
    \ has action: %d, code: %u, length %u\",\n-\t\t   peer->host, action, cap.code,\
    \ cap.length);\n+\t\t   peer->host, action, hdr->code, hdr->length);\n \n    \
    \   /* Capability length check. */\n-      if (pnt + (cap.length + 3) > end)\n\
    +      if ((pnt + hdr->length + 3) > end)\n         {\n           zlog_info (\"\
    %s Capability length error\", peer->host);\n           bgp_notify_send (peer,\
    \ BGP_NOTIFY_CEASE, 0);\n           return -1;\n         }\n \n+      /* Fetch\
    \ structure to the byte stream. */\n+      memcpy (&mpc, pnt + 3, sizeof (struct\
    \ capability_mp_data));\n+\n       /* We know MP Capability Code. */\n-      if\
    \ (cap.code == CAPABILITY_CODE_MP)\n+      if (hdr->code == CAPABILITY_CODE_MP)\n\
    \         {\n-\t  afi = ntohs (cap.mpc.afi);\n-\t  safi = cap.mpc.safi;\n+\t \
    \ afi = ntohs (mpc.afi);\n+\t  safi = mpc.safi;\n \n           /* Ignore capability\
    \ when override-capability is set. */\n           if (CHECK_FLAG (peer->flags,\
    \ PEER_FLAG_OVERRIDE_CAPABILITY))\n \t    continue;\n-\n+          \n+       \
    \   if (!bgp_afi_safi_valid_indices (afi, &safi))\n+            {\n+         \
    \     if (BGP_DEBUG (normal, NORMAL))\n+                zlog_debug (\"%s Dynamic\
    \ Capability MP_EXT afi/safi invalid\",\n+                            peer->host,\
    \ afi, safi);\n+              continue;\n+            }\n+          \n \t  /*\
    \ Address family check.  */\n-\t  if ((afi == AFI_IP \n-\t       || afi == AFI_IP6)\n\
    -\t      && (safi == SAFI_UNICAST \n-\t\t  || safi == SAFI_MULTICAST \n-\t\t \
    \ || safi == BGP_SAFI_VPNV4))\n-\t    {\n-\t      if (BGP_DEBUG (normal, NORMAL))\n\
    -\t\tzlog_debug (\"%s CAPABILITY has %s MP_EXT CAP for afi/safi: %u/%u\",\n-\t\
    \t\t   peer->host,\n-\t\t\t   action == CAPABILITY_ACTION_SET \n-\t\t\t   ? \"\
    Advertising\" : \"Removing\",\n-\t\t\t   ntohs(cap.mpc.afi) , cap.mpc.safi);\n\
    -\t\t  \n-\t      /* Adjust safi code. */\n-\t      if (safi == BGP_SAFI_VPNV4)\n\
    -\t\tsafi = SAFI_MPLS_VPN;\n-\t      \n-\t      if (action == CAPABILITY_ACTION_SET)\n\
    -\t\t{\n-\t\t  peer->afc_recv[afi][safi] = 1;\n-\t\t  if (peer->afc[afi][safi])\n\
    -\t\t    {\n-\t\t      peer->afc_nego[afi][safi] = 1;\n-\t\t      bgp_announce_route\
    \ (peer, afi, safi);\n-\t\t    }\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  peer->afc_recv[afi][safi]\
    \ = 0;\n-\t\t  peer->afc_nego[afi][safi] = 0;\n-\n-\t\t  if (peer_active_nego\
    \ (peer))\n-\t\t    bgp_clear_route (peer, afi, safi);\n-\t\t  else\n-\t\t   \
    \ BGP_EVENT_ADD (peer, BGP_Stop);\n-\t\t} \n-\t    }\n+          if (BGP_DEBUG\
    \ (normal, NORMAL))\n+            zlog_debug (\"%s CAPABILITY has %s MP_EXT CAP\
    \ for afi/safi: %u/%u\",\n+                       peer->host,\n+             \
    \          action == CAPABILITY_ACTION_SET \n+                       ? \"Advertising\"\
    \ : \"Removing\",\n+                       ntohs(mpc.afi) , mpc.safi);\n+    \
    \          \n+          if (action == CAPABILITY_ACTION_SET)\n+            {\n\
    +              peer->afc_recv[afi][safi] = 1;\n+              if (peer->afc[afi][safi])\n\
    +                {\n+                  peer->afc_nego[afi][safi] = 1;\n+     \
    \             bgp_announce_route (peer, afi, safi);\n+                }\n+   \
    \         }\n+          else\n+            {\n+              peer->afc_recv[afi][safi]\
    \ = 0;\n+              peer->afc_nego[afi][safi] = 0;\n+\n+              if (peer_active_nego\
    \ (peer))\n+                bgp_clear_route (peer, afi, safi);\n+            \
    \  else\n+                BGP_EVENT_ADD (peer, BGP_Stop);\n+            }\n  \
    \       }\n       else\n         {\n           zlog_warn (\"%s unrecognized capability\
    \ code: %d - ignored\",\n-                     peer->host, cap.code);\n+     \
    \                peer->host, hdr->code);\n         }\n-      pnt += cap.length\
    \ + 3;\n+      pnt += hdr->length + 3;\n     }\n   return 0;\n }\n \n /* Dynamic\
    \ Capability is received. */\n-static void\n+int\n bgp_capability_receive (struct\
    \ peer *peer, bgp_size_t size)\n {\n   u_char *pnt;\n@@ -2130,7 +2126,7 @@ bgp_capability_receive\
    \ (struct peer *peer, bgp_size_t size)\n     }\n \n   /* Parse packet. */\n- \
    \ ret = bgp_capability_msg_parse (peer, pnt, size);\n+  return bgp_capability_msg_parse\
    \ (peer, pnt, size);\n }\n \f\n /* BGP read utility function. */"
  - "--- a/bgpd/bgp_vty.c\n+++ b/bgpd/bgp_vty.c\n@@ -6681,14 +6681,14 @@ bgp_show_summary\
    \ (struct vty *vty, struct bgp *bgp, int afi, int safi)\n \n \t  vty_out (vty,\
    \ \"4 \");\n \n-\t  vty_out (vty, \"%5d %7d %7d %8d %4d %4ld \",\n+\t  vty_out\
    \ (vty, \"%5d %7d %7d %8d %4d %4lu \",\n \t\t   peer->as,\n \t\t   peer->open_in\
    \ + peer->update_in + peer->keepalive_in\n \t\t   + peer->notify_in + peer->refresh_in\
    \ + peer->dynamic_cap_in,\n \t\t   peer->open_out + peer->update_out + peer->keepalive_out\n\
    \ \t\t   + peer->notify_out + peer->refresh_out\n \t\t   + peer->dynamic_cap_out,\n\
    -\t\t   0, 0, peer->obuf->count);\n+\t\t   0, 0, (unsigned long)peer->obuf->count);\n\
    \ \n \t  vty_out (vty, \"%8s\", \n \t\t   peer_uptime (peer->uptime, timebuf,\
    \ BGP_UPTIME_LEN));\n@@ -7403,7 +7403,7 @@ bgp_show_peer (struct vty *vty, struct\
    \ peer *p)\n   /* Packet counts. */\n   vty_out (vty, \"  Message statistics:%s\"\
    , VTY_NEWLINE);\n   vty_out (vty, \"    Inq depth is 0%s\", VTY_NEWLINE);\n- \
    \ vty_out (vty, \"    Outq depth is %ld%s\", p->obuf->count, VTY_NEWLINE);\n+\
    \  vty_out (vty, \"    Outq depth is %lu%s\", (unsigned long)p->obuf->count, VTY_NEWLINE);\n\
    \   vty_out (vty, \"                         Sent       Rcvd%s\", VTY_NEWLINE);\n\
    \   vty_out (vty, \"    Opens:         %10d %10d%s\", p->open_out, p->open_in,\
    \ VTY_NEWLINE);\n   vty_out (vty, \"    Notifications: %10d %10d%s\", p->notify_out,\
    \ p->notify_in, VTY_NEWLINE);"
  - "--- a/lib/log.c\n+++ b/lib/log.c\n@@ -769,7 +769,7 @@ mes_lookup (struct message\
    \ *meslist, int max, int index)\n       {\n \tif (meslist->key == index)\n \t\
    \  {\n-\t    zlog_warn(\"message index %d [%s] found in position %d (max is %d)\"\
    ,\n+\t    zlog_debug (\"message index %d [%s] found in position %d (max is %d)\"\
    ,\n \t\t      index, meslist->str, i, max);\n \t    return meslist->str;\n \t\
    \  }"
  - "--- a/bgpd/bgp_packet.c\n+++ b/bgpd/bgp_packet.c\n@@ -2620,6 +2620,14 @@ static\
    \ int bgp_capability_msg_parse(struct peer *peer, uint8_t *pnt,\n \t\t\t\t\"%s\
    \ CAPABILITY has action: %d, code: %u, length %u\",\n \t\t\t\tpeer->host, action,\
    \ hdr->code, hdr->length);\n \n+\t\tif (hdr->length < sizeof(struct capability_mp_data))\
    \ {\n+\t\t\tzlog_info(\n+\t\t\t\t\"%pBP Capability structure is not properly filled\
    \ out, expected at least %zu bytes but header length specified is %d\",\n+\t\t\
    \t\tpeer, sizeof(struct capability_mp_data),\n+\t\t\t\thdr->length);\n+\t\t\t\
    return BGP_Stop;\n+\t\t}\n+\n \t\t/* Capability length check. */\n \t\tif ((pnt\
    \ + hdr->length + 3) > end) {\n \t\t\tzlog_info(\"%s Capability length error\"\
    , peer->host);"
  identifiers:
  - CVE-2022-37032
  - CWE-125
  overview: An out-of-bounds read in the BGP daemon of FRRouting FRR before 8.4 may
    lead to a segmentation fault and denial of service. This occurs in bgp_capability_msg_parse
    in bgpd/bgp_packet.c.
  references:
  - source: cve@mitre.org
    tags:
    - Exploit
    - Issue Tracking
    - Third Party Advisory
    url: https://bugzilla.suse.com/show_bug.cgi?id=1202023
  - source: cve@mitre.org
    tags:
    - Patch
    url: https://github.com/FRRouting/frr/commit/6d58272b4cf96f0daa846210dd2104877900f921
  - source: cve@mitre.org
    tags:
    - Patch
    url: https://github.com/FRRouting/frr/commit/ff6db1027f8f36df657ff2e5ea167773752537ed
  - source: cve@mitre.org
    tags:
    - Mailing List
    - Third Party Advisory
    url: https://lists.debian.org/debian-lts-announce/2022/11/msg00039.html
  - source: cve@mitre.org
    tags:
    - Third Party Advisory
    url: https://www.debian.org/security/2023/dsa-5362
  title: An out-of-bounds read in the BGP daemon of FRRouting FRR before 8.4 may lead
    to a segmentation fault and denial of service. This occurs in bgp_capability_msg_parse
    in bgpd/bgp_packet.c.
- diff_content:
  - "--- a/src/mark.c\n+++ b/src/mark.c\n@@ -221,17 +221,19 @@ movemark(int count)\n\
    \ \t    fname2fnum(jmp);\n \tif (jmp->fmark.fnum != curbuf->b_fnum)\n \t{\n-\t\
    \    // jump to other file\n-\t    if (buflist_findnr(jmp->fmark.fnum) == NULL)\n\
    +\t    // Make a copy, an autocommand may make \"jmp\" invalid.\n+\t    fmark_T\
    \ fmark = jmp->fmark;\n+\n+\t    // jump to the file with the mark\n+\t    if\
    \ (buflist_findnr(fmark.fnum) == NULL)\n \t    {\t\t\t\t\t     // Skip this one\
    \ ..\n \t\tcount += count < 0 ? -1 : 1;\n \t\tcontinue;\n \t    }\n-\t    if (buflist_getfile(jmp->fmark.fnum,\
    \ jmp->fmark.mark.lnum,\n-\t\t\t\t\t\t\t    0, FALSE) == FAIL)\n+\t    if (buflist_getfile(fmark.fnum,\
    \ fmark.mark.lnum, 0, FALSE) == FAIL)\n \t\treturn (pos_T *)NULL;\n \t    // Set\
    \ lnum again, autocommands my have changed it\n-\t    curwin->w_cursor = jmp->fmark.mark;\n\
    +\t    curwin->w_cursor = fmark.mark;\n \t    pos = (pos_T *)-1;\n \t}\n \telse"
  - "--- a/src/version.c\n+++ b/src/version.c\n@@ -699,6 +699,8 @@ static char *(features[])\
    \ =\n \n static int included_patches[] =\n {   /* Add new patch number below this\
    \ line */\n+/**/\n+    530,\n /**/\n     529,\n /**/"
  identifiers:
  - CVE-2022-3256
  - CWE-416
  overview: Use After Free in GitHub repository vim/vim prior to 9.0.0530.
  references:
  - source: security@huntr.dev
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/vim/vim/commit/8ecfa2c56b4992c7f067b92488aa9acea5a454ad
  - source: security@huntr.dev
    tags:
    - Exploit
    - Third Party Advisory
    url: https://huntr.dev/bounties/8336a3df-212a-4f8d-ae34-76ef1f936bb3
  - source: security@huntr.dev
    tags:
    - Mailing List
    - Third Party Advisory
    url: https://lists.debian.org/debian-lts-announce/2022/11/msg00032.html
  - source: security@huntr.dev
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/4QI7AETXBHPC7SGA77Q7O5IEGULWYET7/
  - source: security@huntr.dev
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/GTBVD4J2SKVSWK4VBN5JP5OEVK6GDS3N/
  - source: security@huntr.dev
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/LSSEWQLK55MCNT4Z2IIJEJYEI5HLCODI/
  - source: security@huntr.dev
    url: https://security.gentoo.org/glsa/202305-16
  title: Use After Free in GitHub repository vim/vim prior to 9.0.0530.
- diff_content:
  - "--- a/libavformat/mov.c\n+++ b/libavformat/mov.c\n@@ -3967,8 +3967,11 @@ static\
    \ int build_open_gop_key_points(AVStream *st)\n \n     /* Build an unrolled index\
    \ of the samples */\n     sc->sample_offsets_count = 0;\n-    for (uint32_t i\
    \ = 0; i < sc->ctts_count; i++)\n+    for (uint32_t i = 0; i < sc->ctts_count;\
    \ i++) {\n+        if (sc->ctts_data[i].count > INT_MAX - sc->sample_offsets_count)\n\
    +            return AVERROR(ENOMEM);\n         sc->sample_offsets_count += sc->ctts_data[i].count;\n\
    +    }\n     av_freep(&sc->sample_offsets);\n     sc->sample_offsets = av_calloc(sc->sample_offsets_count,\
    \ sizeof(*sc->sample_offsets));\n     if (!sc->sample_offsets)\n@@ -3987,8 +3990,11\
    \ @@ static int build_open_gop_key_points(AVStream *st)\n     /* Build a list\
    \ of open-GOP key samples */\n     sc->open_key_samples_count = 0;\n     for (uint32_t\
    \ i = 0; i < sc->sync_group_count; i++)\n-        if (sc->sync_group[i].index\
    \ == cra_index)\n+        if (sc->sync_group[i].index == cra_index) {\n+     \
    \       if (sc->sync_group[i].count > INT_MAX - sc->open_key_samples_count)\n\
    +                return AVERROR(ENOMEM);\n             sc->open_key_samples_count\
    \ += sc->sync_group[i].count;\n+        }\n     av_freep(&sc->open_key_samples);\n\
    \     sc->open_key_samples = av_calloc(sc->open_key_samples_count, sizeof(*sc->open_key_samples));\n\
    \     if (!sc->open_key_samples)\n@@ -3999,6 +4005,8 @@ static int build_open_gop_key_points(AVStream\
    \ *st)\n         if (sg->index == cra_index)\n             for (uint32_t j = 0;\
    \ j < sg->count; j++)\n                 sc->open_key_samples[k++] = sample_id;\n\
    +        if (sg->count > INT_MAX - sample_id)\n+            return AVERROR_PATCHWELCOME;\n\
    \         sample_id += sg->count;\n     }\n "
  identifiers:
  - CVE-2022-2566
  - CWE-190
  overview: A heap out-of-bounds memory write exists in FFMPEG since version 5.1.
    The size calculation in `build_open_gop_key_points()` goes through all entries
    in the loop and adds `sc->ctts_data[i].count` to `sc->sample_offsets_count`. This
    can lead to an integer overflow resulting in a small allocation with `av_calloc()`.
    An attacker can cause remote code execution via a malicious mp4 file. We recommend
    upgrading past commit c953baa084607dd1d84c3bfcce3cf6a87c3e6e05
  references:
  - source: cve-coordination@google.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/FFmpeg/FFmpeg/commit/c953baa084607dd1d84c3bfcce3cf6a87c3e6e05
  title: A heap out-of-bounds memory write exists in FFMPEG since version 5.1. The
    size calculation in `build_open_gop_key_points()` goes through all entries in
    the loop and adds `sc->ctts_data[i].count` to `sc->sample_offsets_count`. This
    can lead to an integer overflow resulting in a small allocation with `av_calloc()`.
    An attacker can cause remote code execution via a malicious mp4 file. We recommend
    upgrading past commit c953baa084607dd1d84c3bfcce3cf6a87c3e6e05
- diff_content:
  - "--- a/src/eval.c\n+++ b/src/eval.c\n@@ -253,7 +253,7 @@ eval_expr_typval(typval_T\
    \ *expr, typval_T *argv, int argc, typval_T *rettv)\n \t    if (fc == NULL)\n\
    \ \t\treturn FAIL;\n \n-\t    // Shortcut to call a compiled function without\
    \ overhead.\n+\t    // Shortcut to call a compiled function with minimal overhead.\n\
    \ \t    r = call_def_function(partial->pt_func, argc, argv,\n \t\t\t\t\t  DEF_USE_PT_ARGV,\
    \ partial, fc, rettv);\n \t    remove_funccal();\n@@ -2291,7 +2291,7 @@ eval_next_non_blank(char_u\
    \ *arg, evalarg_T *evalarg, int *getnext)\n \n \tif (next != NULL)\n \t{\n-\t\
    \    *getnext = TRUE;\n+\t    *getnext = *p != NL;\n \t    return skipwhite(next);\n\
    \ \t}\n     }"
  - "--- a/src/version.c\n+++ b/src/version.c\n@@ -699,6 +699,8 @@ static char *(features[])\
    \ =\n \n static int included_patches[] =\n {   /* Add new patch number below this\
    \ line */\n+/**/\n+    552,\n /**/\n     551,\n /**/"
  identifiers:
  - CVE-2022-3278
  - CWE-476
  overview: NULL Pointer Dereference in GitHub repository vim/vim prior to 9.0.0552.
  references:
  - source: security@huntr.dev
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/vim/vim/commit/69082916c8b5d321545d60b9f5facad0a2dd5a4e
  - source: security@huntr.dev
    tags:
    - Exploit
    - Patch
    - Third Party Advisory
    url: https://huntr.dev/bounties/a9fad77e-f245-4ce9-ba15-c7d4c86c4612
  - source: security@huntr.dev
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/4QI7AETXBHPC7SGA77Q7O5IEGULWYET7/
  - source: security@huntr.dev
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/GTBVD4J2SKVSWK4VBN5JP5OEVK6GDS3N/
  - source: security@huntr.dev
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/LSSEWQLK55MCNT4Z2IIJEJYEI5HLCODI/
  - source: security@huntr.dev
    url: https://security.gentoo.org/glsa/202305-16
  title: NULL Pointer Dereference in GitHub repository vim/vim prior to 9.0.0552.
- diff_content:
  - "--- a/src/ex_eval.c\n+++ b/src/ex_eval.c\n@@ -1935,128 +1935,127 @@ ex_finally(exarg_T\
    \ *eap)\n     if (cmdmod_error(FALSE))\n \treturn;\n \n-    if (cstack->cs_trylevel\
    \ <= 0 || cstack->cs_idx < 0)\n+    for (idx = cstack->cs_idx; idx >= 0; --idx)\n\
    +\tif (cstack->cs_flags[idx] & CSF_TRY)\n+\t    break;\n+    if (cstack->cs_trylevel\
    \ <= 0 || idx < 0)\n+    {\n \teap->errmsg = _(e_finally_without_try);\n-    else\n\
    +\treturn;\n+    }\n+\n+    if (!(cstack->cs_flags[cstack->cs_idx] & CSF_TRY))\n\
    \     {\n-\tif (!(cstack->cs_flags[cstack->cs_idx] & CSF_TRY))\n-\t{\n-\t    eap->errmsg\
    \ = get_end_emsg(cstack);\n-\t    for (idx = cstack->cs_idx - 1; idx > 0; --idx)\n\
    -\t\tif (cstack->cs_flags[idx] & CSF_TRY)\n-\t\t    break;\n-\t    // Make this\
    \ error pending, so that the commands in the following\n-\t    // finally clause\
    \ can be executed.  This overrules also a pending\n-\t    // \":continue\", \"\
    :break\", \":return\", or \":finish\".\n-\t    pending = CSTP_ERROR;\n-\t}\n-\t\
    else\n-\t    idx = cstack->cs_idx;\n+\teap->errmsg = get_end_emsg(cstack);\n+\t\
    // Make this error pending, so that the commands in the following\n+\t// finally\
    \ clause can be executed.  This overrules also a pending\n+\t// \":continue\"\
    , \":break\", \":return\", or \":finish\".\n+\tpending = CSTP_ERROR;\n+    }\n\
    \ \n-\tif (cstack->cs_flags[idx] & CSF_FINALLY)\n+    if (cstack->cs_flags[idx]\
    \ & CSF_FINALLY)\n+    {\n+\t// Give up for a multiple \":finally\" and ignore\
    \ it.\n+\teap->errmsg = _(e_multiple_finally);\n+\treturn;\n+    }\n+    rewind_conditionals(cstack,\
    \ idx, CSF_WHILE | CSF_FOR,\n+\t\t\t\t\t\t   &cstack->cs_looplevel);\n+\n+   \
    \ /*\n+     * Don't do something when the corresponding try block never got active\n\
    +     * (because of an inactive surrounding conditional or after an error or\n\
    +     * interrupt or throw) or for a \":finally\" without \":try\" or a multiple\n\
    +     * \":finally\".  After every other error (did_emsg or the conditional\n\
    +     * errors detected above) or after an interrupt (got_int) or an\n+     *\
    \ exception (did_throw), the finally clause must be executed.\n+     */\n+   \
    \ skip = !(cstack->cs_flags[cstack->cs_idx] & CSF_TRUE);\n+\n+    if (!skip)\n\
    +    {\n+\t// When debugging or a breakpoint was encountered, display the\n+\t\
    // debug prompt (if not already done).  The user then knows that the\n+\t// finally\
    \ clause is executed.\n+\tif (dbg_check_skipped(eap))\n \t{\n-\t    // Give up\
    \ for a multiple \":finally\" and ignore it.\n-\t    eap->errmsg = _(e_multiple_finally);\n\
    -\t    return;\n+\t    // Handle a \">quit\" debug command as if an interrupt\
    \ had\n+\t    // occurred before the \":finally\".  That is, discard the\n+\t\
    \    // original exception and replace it by an interrupt\n+\t    // exception.\n\
    +\t    (void)do_intthrow(cstack);\n \t}\n-\trewind_conditionals(cstack, idx, CSF_WHILE\
    \ | CSF_FOR,\n-\t\t\t\t\t\t       &cstack->cs_looplevel);\n \n \t/*\n-\t * Don't\
    \ do something when the corresponding try block never got active\n-\t * (because\
    \ of an inactive surrounding conditional or after an error or\n-\t * interrupt\
    \ or throw) or for a \":finally\" without \":try\" or a multiple\n-\t * \":finally\"\
    .  After every other error (did_emsg or the conditional\n-\t * errors detected\
    \ above) or after an interrupt (got_int) or an\n-\t * exception (did_throw), the\
    \ finally clause must be executed.\n+\t * If there is a preceding catch clause\
    \ and it caught the exception,\n+\t * finish the exception now.  This happens\
    \ also after errors except\n+\t * when this is a multiple \":finally\" or one\
    \ not within a \":try\".\n+\t * After an error or interrupt, this also discards\
    \ a pending\n+\t * \":continue\", \":break\", \":finish\", or \":return\" from\
    \ the preceding\n+\t * try block or catch clause.\n \t */\n-\tskip = !(cstack->cs_flags[cstack->cs_idx]\
    \ & CSF_TRUE);\n+\tcleanup_conditionals(cstack, CSF_TRY, FALSE);\n \n-\tif (!skip)\n\
    +\tif (cstack->cs_idx >= 0\n+\t\t\t   && (cstack->cs_flags[cstack->cs_idx] & CSF_TRY))\n\
    \ \t{\n-\t    // When debugging or a breakpoint was encountered, display the\n\
    -\t    // debug prompt (if not already done).  The user then knows that the\n\
    -\t    // finally clause is executed.\n-\t    if (dbg_check_skipped(eap))\n-\t\
    \    {\n-\t\t// Handle a \">quit\" debug command as if an interrupt had\n-\t\t\
    // occurred before the \":finally\".  That is, discard the\n-\t\t// original exception\
    \ and replace it by an interrupt\n-\t\t// exception.\n-\t\t(void)do_intthrow(cstack);\n\
    -\t    }\n-\n-\t    /*\n-\t     * If there is a preceding catch clause and it\
    \ caught the exception,\n-\t     * finish the exception now.  This happens also\
    \ after errors except\n-\t     * when this is a multiple \":finally\" or one not\
    \ within a \":try\".\n-\t     * After an error or interrupt, this also discards\
    \ a pending\n-\t     * \":continue\", \":break\", \":finish\", or \":return\"\
    \ from the preceding\n-\t     * try block or catch clause.\n-\t     */\n-\t  \
    \  cleanup_conditionals(cstack, CSF_TRY, FALSE);\n+\t    // Variables declared\
    \ in the previous block can no longer be\n+\t    // used.\n+\t    leave_block(cstack);\n\
    +\t    enter_block(cstack);\n+\t}\n \n-\t    if (cstack->cs_idx >= 0\n-\t\t\t\
    \       && (cstack->cs_flags[cstack->cs_idx] & CSF_TRY))\n+\t/*\n+\t * Make did_emsg,\
    \ got_int, did_throw pending.  If set, they overrule\n+\t * a pending \":continue\"\
    , \":break\", \":return\", or \":finish\".  Then\n+\t * we have particularly to\
    \ discard a pending return value (as done\n+\t * by the call to cleanup_conditionals()\
    \ above when did_emsg or\n+\t * got_int is set).  The pending values are restored\
    \ by the\n+\t * \":endtry\", except if there is a new error, interrupt, exception,\n\
    +\t * \":continue\", \":break\", \":return\", or \":finish\" in the following\n\
    +\t * finally clause.  A missing \":endwhile\", \":endfor\" or \":endif\"\n+\t\
    \ * detected here is treated as if did_emsg and did_throw had\n+\t * already been\
    \ set, respectively in case that the error is not\n+\t * converted to an exception,\
    \ did_throw had already been unset.\n+\t * We must not set did_emsg here since\
    \ that would suppress the\n+\t * error message.\n+\t */\n+\tif (pending == CSTP_ERROR\
    \ || did_emsg || got_int || did_throw)\n+\t{\n+\t    if (cstack->cs_pending[cstack->cs_idx]\
    \ == CSTP_RETURN)\n \t    {\n-\t\t// Variables declared in the previous block\
    \ can no longer be\n-\t\t// used.\n-\t\tleave_block(cstack);\n-\t\tenter_block(cstack);\n\
    +\t\treport_discard_pending(CSTP_RETURN,\n+\t\t\t\t       cstack->cs_rettv[cstack->cs_idx]);\n\
    +\t\tdiscard_pending_return(cstack->cs_rettv[cstack->cs_idx]);\n \t    }\n-\n\
    -\t    /*\n-\t     * Make did_emsg, got_int, did_throw pending.  If set, they\
    \ overrule\n-\t     * a pending \":continue\", \":break\", \":return\", or \"\
    :finish\".  Then\n-\t     * we have particularly to discard a pending return value\
    \ (as done\n-\t     * by the call to cleanup_conditionals() above when did_emsg\
    \ or\n-\t     * got_int is set).  The pending values are restored by the\n-\t\
    \     * \":endtry\", except if there is a new error, interrupt, exception,\n-\t\
    \     * \":continue\", \":break\", \":return\", or \":finish\" in the following\n\
    -\t     * finally clause.  A missing \":endwhile\", \":endfor\" or \":endif\"\n\
    -\t     * detected here is treated as if did_emsg and did_throw had\n-\t     *\
    \ already been set, respectively in case that the error is not\n-\t     * converted\
    \ to an exception, did_throw had already been unset.\n-\t     * We must not set\
    \ did_emsg here since that would suppress the\n-\t     * error message.\n-\t \
    \    */\n-\t    if (pending == CSTP_ERROR || did_emsg || got_int || did_throw)\n\
    -\t    {\n-\t\tif (cstack->cs_pending[cstack->cs_idx] == CSTP_RETURN)\n-\t\t{\n\
    -\t\t    report_discard_pending(CSTP_RETURN,\n-\t\t\t\t\t   cstack->cs_rettv[cstack->cs_idx]);\n\
    -\t\t    discard_pending_return(cstack->cs_rettv[cstack->cs_idx]);\n-\t\t}\n-\t\
    \tif (pending == CSTP_ERROR && !did_emsg)\n-\t\t    pending |= (THROW_ON_ERROR)\
    \ ? CSTP_THROW : 0;\n-\t\telse\n-\t\t    pending |= did_throw ? CSTP_THROW : 0;\n\
    -\t\tpending |= did_emsg  ? CSTP_ERROR     : 0;\n-\t\tpending |= got_int   ? CSTP_INTERRUPT\
    \ : 0;\n-\t\tcstack->cs_pending[cstack->cs_idx] = pending;\n-\n-\t\t// It's mandatory\
    \ that the current exception is stored in the\n-\t\t// cstack so that it can be\
    \ rethrown at the \":endtry\" or be\n-\t\t// discarded if the finally clause is\
    \ left by a \":continue\",\n-\t\t// \":break\", \":return\", \":finish\", error,\
    \ interrupt, or another\n-\t\t// exception.  When emsg() is called for a missing\
    \ \":endif\" or\n-\t\t// a missing \":endwhile\"/\":endfor\" detected here, the\n\
    -\t\t// exception will be discarded.\n-\t\tif (did_throw && cstack->cs_exception[cstack->cs_idx]\n\
    -\t\t\t\t\t\t\t != current_exception)\n-\t\t    internal_error(\"ex_finally()\"\
    );\n-\t    }\n-\n-\t    /*\n-\t     * Set CSL_HAD_FINA, so do_cmdline() will reset\
    \ did_emsg,\n-\t     * got_int, and did_throw and make the finally clause active.\n\
    -\t     * This will happen after emsg() has been called for a missing\n-\t   \
    \  * \":endif\" or a missing \":endwhile\"/\":endfor\" detected here, so\n-\t\
    \     * that the following finally clause will be executed even then.\n-\t   \
    \  */\n-\t    cstack->cs_lflags |= CSL_HAD_FINA;\n+\t    if (pending == CSTP_ERROR\
    \ && !did_emsg)\n+\t\tpending |= (THROW_ON_ERROR) ? CSTP_THROW : 0;\n+\t    else\n\
    +\t\tpending |= did_throw ? CSTP_THROW : 0;\n+\t    pending |= did_emsg  ? CSTP_ERROR\
    \     : 0;\n+\t    pending |= got_int   ? CSTP_INTERRUPT : 0;\n+\t    cstack->cs_pending[cstack->cs_idx]\
    \ = pending;\n+\n+\t    // It's mandatory that the current exception is stored\
    \ in the\n+\t    // cstack so that it can be rethrown at the \":endtry\" or be\n\
    +\t    // discarded if the finally clause is left by a \":continue\",\n+\t   \
    \ // \":break\", \":return\", \":finish\", error, interrupt, or another\n+\t \
    \   // exception.  When emsg() is called for a missing \":endif\" or\n+\t    //\
    \ a missing \":endwhile\"/\":endfor\" detected here, the\n+\t    // exception\
    \ will be discarded.\n+\t    if (did_throw && cstack->cs_exception[cstack->cs_idx]\n\
    +\t\t\t\t\t\t     != current_exception)\n+\t\tinternal_error(\"ex_finally()\"\
    );\n \t}\n+\n+\t/*\n+\t * Set CSL_HAD_FINA, so do_cmdline() will reset did_emsg,\n\
    +\t * got_int, and did_throw and make the finally clause active.\n+\t * This will\
    \ happen after emsg() has been called for a missing\n+\t * \":endif\" or a missing\
    \ \":endwhile\"/\":endfor\" detected here, so\n+\t * that the following finally\
    \ clause will be executed even then.\n+\t */\n+\tcstack->cs_lflags |= CSL_HAD_FINA;\n\
    \     }\n }\n \n@@ -2076,185 +2075,183 @@ ex_endtry(exarg_T *eap)\n     if (cmdmod_error(FALSE))\n\
    \ \treturn;\n \n-    if (cstack->cs_trylevel <= 0 || cstack->cs_idx < 0)\n-\t\
    eap->errmsg = _(e_endtry_without_try);\n-    else\n+    for (idx = cstack->cs_idx;\
    \ idx >= 0; --idx)\n+\tif (cstack->cs_flags[idx] & CSF_TRY)\n+\t    break;\n+\
    \    if (cstack->cs_trylevel <= 0 || idx < 0)\n     {\n-\t/*\n-\t * Don't do something\
    \ after an error, interrupt or throw in the try\n-\t * block, catch clause, or\
    \ finally clause preceding this \":endtry\" or\n-\t * when an error or interrupt\
    \ occurred after a \":continue\", \":break\",\n-\t * \":return\", or \":finish\"\
    \ in a try block or catch clause preceding this\n-\t * \":endtry\" or when the\
    \ try block never got active (because of an\n-\t * inactive surrounding conditional\
    \ or after an error or interrupt or\n-\t * throw) or when there is a surrounding\
    \ conditional and it has been\n-\t * made inactive by a \":continue\", \":break\"\
    , \":return\", or \":finish\" in\n-\t * the finally clause.  The latter case need\
    \ not be tested since then\n-\t * anything pending has already been discarded.\
    \ */\n-\tskip = did_emsg || got_int || did_throw\n+\teap->errmsg = _(e_endtry_without_try);\n\
    +\treturn;\n+    }\n+\n+    /*\n+     * Don't do something after an error, interrupt\
    \ or throw in the try\n+     * block, catch clause, or finally clause preceding\
    \ this \":endtry\" or\n+     * when an error or interrupt occurred after a \"\
    :continue\", \":break\",\n+     * \":return\", or \":finish\" in a try block or\
    \ catch clause preceding this\n+     * \":endtry\" or when the try block never\
    \ got active (because of an\n+     * inactive surrounding conditional or after\
    \ an error or interrupt or\n+     * throw) or when there is a surrounding conditional\
    \ and it has been\n+     * made inactive by a \":continue\", \":break\", \":return\"\
    , or \":finish\" in\n+     * the finally clause.  The latter case need not be\
    \ tested since then\n+     * anything pending has already been discarded. */\n\
    +    skip = did_emsg || got_int || did_throw\n \t\t\t     || !(cstack->cs_flags[cstack->cs_idx]\
    \ & CSF_TRUE);\n \n-\tif (!(cstack->cs_flags[cstack->cs_idx] & CSF_TRY))\n-\t\
    {\n-\t    eap->errmsg = get_end_emsg(cstack);\n+    if (!(cstack->cs_flags[cstack->cs_idx]\
    \ & CSF_TRY))\n+    {\n+\teap->errmsg = get_end_emsg(cstack);\n \n-\t    // Find\
    \ the matching \":try\" and report what's missing.\n-\t    idx = cstack->cs_idx;\n\
    -\t    do\n-\t\t--idx;\n-\t    while (idx > 0 && !(cstack->cs_flags[idx] & CSF_TRY));\n\
    -\t    rewind_conditionals(cstack, idx, CSF_WHILE | CSF_FOR,\n-\t\t\t\t\t\t  \
    \     &cstack->cs_looplevel);\n-\t    skip = TRUE;\n+\t// Find the matching \"\
    :try\" and report what's missing.\n+\trewind_conditionals(cstack, idx, CSF_WHILE\
    \ | CSF_FOR,\n+\t\t\t\t\t\t\t&cstack->cs_looplevel);\n+\tskip = TRUE;\n \n-\t\
    \    /*\n-\t     * If an exception is being thrown, discard it to prevent it from\n\
    -\t     * being rethrown at the end of this function.  It would be\n-\t     *\
    \ discarded by the error message, anyway.  Resets did_throw.\n-\t     * This does\
    \ not affect the script termination due to the error\n-\t     * since \"trylevel\"\
    \ is decremented after emsg() has been called.\n-\t     */\n-\t    if (did_throw)\n\
    -\t\tdiscard_current_exception();\n+\t/*\n+\t * If an exception is being thrown,\
    \ discard it to prevent it from\n+\t * being rethrown at the end of this function.\
    \  It would be\n+\t * discarded by the error message, anyway.  Resets did_throw.\n\
    +\t * This does not affect the script termination due to the error\n+\t * since\
    \ \"trylevel\" is decremented after emsg() has been called.\n+\t */\n+\tif (did_throw)\n\
    +\t    discard_current_exception();\n \n-\t    // report eap->errmsg, also when\
    \ there already was an error\n-\t    did_emsg = FALSE;\n-\t}\n-\telse\n-\t{\n\
    -\t    idx = cstack->cs_idx;\n+\t// report eap->errmsg, also when there already\
    \ was an error\n+\tdid_emsg = FALSE;\n+    }\n+    else\n+    {\n+\tidx = cstack->cs_idx;\n\
    \ \n-\t    // Check the flags only when not in a skipped block.\n-\t    if (!skip\
    \ && in_vim9script()\n+\t// Check the flags only when not in a skipped block.\n\
    +\tif (!skip && in_vim9script()\n \t\t     && (cstack->cs_flags[idx] & (CSF_CATCH|CSF_FINALLY))\
    \ == 0)\n-\t    {\n-\t\t// try/endtry without any catch or finally: give an error\
    \ and\n-\t\t// continue.\n-\t\teap->errmsg = _(e_missing_catch_or_finally);\n\
    -\t    }\n-\n-\t    /*\n-\t     * If we stopped with the exception currently being\
    \ thrown at this\n-\t     * try conditional since we didn't know that it doesn't\
    \ have\n-\t     * a finally clause, we need to rethrow it after closing the try\n\
    -\t     * conditional.\n-\t     */\n-\t    if (did_throw && (cstack->cs_flags[idx]\
    \ & CSF_TRUE)\n-\t\t    && !(cstack->cs_flags[idx] & CSF_FINALLY))\n-\t\trethrow\
    \ = TRUE;\n-\t}\n-\n-\t// If there was no finally clause, show the user when debugging\
    \ or\n-\t// a breakpoint was encountered that the end of the try conditional has\n\
    -\t// been reached: display the debug prompt (if not already done).  Do\n-\t//\
    \ this on normal control flow or when an exception was thrown, but not\n-\t//\
    \ on an interrupt or error not converted to an exception or when\n-\t// a \":break\"\
    , \":continue\", \":return\", or \":finish\" is pending.  These\n-\t// actions\
    \ are carried out immediately.\n-\tif ((rethrow || (!skip\n-\t\t\t&& !(cstack->cs_flags[idx]\
    \ & CSF_FINALLY)\n-\t\t\t&& !cstack->cs_pending[idx]))\n-\t\t&& dbg_check_skipped(eap))\n\
    \ \t{\n-\t    // Handle a \">quit\" debug command as if an interrupt had occurred\n\
    -\t    // before the \":endtry\".  That is, throw an interrupt exception and\n\
    -\t    // set \"skip\" and \"rethrow\".\n-\t    if (got_int)\n-\t    {\n-\t\t\
    skip = TRUE;\n-\t\t(void)do_intthrow(cstack);\n-\t\t// The do_intthrow() call\
    \ may have reset did_throw or\n-\t\t// cstack->cs_pending[idx].\n-\t\trethrow\
    \ = FALSE;\n-\t\tif (did_throw && !(cstack->cs_flags[idx] & CSF_FINALLY))\n-\t\
    \t    rethrow = TRUE;\n-\t    }\n+\t    // try/endtry without any catch or finally:\
    \ give an error and\n+\t    // continue.\n+\t    eap->errmsg = _(e_missing_catch_or_finally);\n\
    \ \t}\n \n \t/*\n-\t * If a \":return\" is pending, we need to resume it after\
    \ closing the\n-\t * try conditional; remember the return value.  If there was\
    \ a finally\n-\t * clause making an exception pending, we need to rethrow it.\
    \  Make it\n-\t * the exception currently being thrown.\n+\t * If we stopped with\
    \ the exception currently being thrown at this\n+\t * try conditional since we\
    \ didn't know that it doesn't have\n+\t * a finally clause, we need to rethrow\
    \ it after closing the try\n+\t * conditional.\n \t */\n-\tif (!skip)\n+\tif (did_throw\
    \ && (cstack->cs_flags[idx] & CSF_TRUE)\n+\t\t&& !(cstack->cs_flags[idx] & CSF_FINALLY))\n\
    +\t    rethrow = TRUE;\n+    }\n+\n+    // If there was no finally clause, show\
    \ the user when debugging or\n+    // a breakpoint was encountered that the end\
    \ of the try conditional has\n+    // been reached: display the debug prompt (if\
    \ not already done).  Do\n+    // this on normal control flow or when an exception\
    \ was thrown, but not\n+    // on an interrupt or error not converted to an exception\
    \ or when\n+    // a \":break\", \":continue\", \":return\", or \":finish\" is\
    \ pending.  These\n+    // actions are carried out immediately.\n+    if ((rethrow\
    \ || (!skip && !(cstack->cs_flags[idx] & CSF_FINALLY)\n+\t\t    && !cstack->cs_pending[idx]))\n\
    +\t    && dbg_check_skipped(eap))\n+    {\n+\t// Handle a \">quit\" debug command\
    \ as if an interrupt had occurred\n+\t// before the \":endtry\".  That is, throw\
    \ an interrupt exception and\n+\t// set \"skip\" and \"rethrow\".\n+\tif (got_int)\n\
    \ \t{\n-\t    pending = cstack->cs_pending[idx];\n-\t    cstack->cs_pending[idx]\
    \ = CSTP_NONE;\n-\t    if (pending == CSTP_RETURN)\n-\t\trettv = cstack->cs_rettv[idx];\n\
    -\t    else if (pending & CSTP_THROW)\n-\t\tcurrent_exception = cstack->cs_exception[idx];\n\
    +\t    skip = TRUE;\n+\t    (void)do_intthrow(cstack);\n+\t    // The do_intthrow()\
    \ call may have reset did_throw or\n+\t    // cstack->cs_pending[idx].\n+\t  \
    \  rethrow = FALSE;\n+\t    if (did_throw && !(cstack->cs_flags[idx] & CSF_FINALLY))\n\
    +\t\trethrow = TRUE;\n \t}\n+    }\n \n-\t/*\n-\t * Discard anything pending on\
    \ an error, interrupt, or throw in the\n-\t * finally clause.  If there was no\
    \ \":finally\", discard a pending\n-\t * \":continue\", \":break\", \":return\"\
    , or \":finish\" if an error or\n-\t * interrupt occurred afterwards, but before\
    \ the \":endtry\" was reached.\n-\t * If an exception was caught by the last of\
    \ the catch clauses and there\n-\t * was no finally clause, finish the exception\
    \ now.  This happens also\n-\t * after errors except when this \":endtry\" is\
    \ not within a \":try\".\n-\t * Restore \"emsg_silent\" if it has been reset by\
    \ this try conditional.\n-\t */\n-\t(void)cleanup_conditionals(cstack, CSF_TRY\
    \ | CSF_SILENT, TRUE);\n+    /*\n+     * If a \":return\" is pending, we need\
    \ to resume it after closing the\n+     * try conditional; remember the return\
    \ value.  If there was a finally\n+     * clause making an exception pending,\
    \ we need to rethrow it.  Make it\n+     * the exception currently being thrown.\n\
    +     */\n+    if (!skip)\n+    {\n+\tpending = cstack->cs_pending[idx];\n+\t\
    cstack->cs_pending[idx] = CSTP_NONE;\n+\tif (pending == CSTP_RETURN)\n+\t    rettv\
    \ = cstack->cs_rettv[idx];\n+\telse if (pending & CSTP_THROW)\n+\t    current_exception\
    \ = cstack->cs_exception[idx];\n+    }\n \n-\tif (cstack->cs_idx >= 0\n-\t\t\t\
    \       && (cstack->cs_flags[cstack->cs_idx] & CSF_TRY))\n-\t    leave_block(cstack);\n\
    -\t--cstack->cs_trylevel;\n+    /*\n+     * Discard anything pending on an error,\
    \ interrupt, or throw in the\n+     * finally clause.  If there was no \":finally\"\
    , discard a pending\n+     * \":continue\", \":break\", \":return\", or \":finish\"\
    \ if an error or\n+     * interrupt occurred afterwards, but before the \":endtry\"\
    \ was reached.\n+     * If an exception was caught by the last of the catch clauses\
    \ and there\n+     * was no finally clause, finish the exception now.  This happens\
    \ also\n+     * after errors except when this \":endtry\" is not within a \":try\"\
    .\n+     * Restore \"emsg_silent\" if it has been reset by this try conditional.\n\
    +     */\n+    (void)cleanup_conditionals(cstack, CSF_TRY | CSF_SILENT, TRUE);\n\
    \ \n-\tif (!skip)\n-\t{\n-\t    report_resume_pending(pending,\n+    if (cstack->cs_idx\
    \ >= 0 && (cstack->cs_flags[cstack->cs_idx] & CSF_TRY))\n+\tleave_block(cstack);\n\
    +    --cstack->cs_trylevel;\n+\n+    if (!skip)\n+    {\n+\treport_resume_pending(pending,\n\
    \ \t\t    (pending == CSTP_RETURN) ? rettv :\n \t\t    (pending & CSTP_THROW)\
    \ ? (void *)current_exception : NULL);\n-\t    switch (pending)\n-\t    {\n-\t\
    \tcase CSTP_NONE:\n-\t\t    break;\n+\tswitch (pending)\n+\t{\n+\t    case CSTP_NONE:\n\
    +\t\tbreak;\n \n-\t\t// Reactivate a pending \":continue\", \":break\", \":return\"\
    ,\n-\t\t// \":finish\" from the try block or a catch clause of this try\n-\t\t\
    // conditional.  This is skipped, if there was an error in an\n-\t\t// (unskipped)\
    \ conditional command or an interrupt afterwards\n-\t\t// or if the finally clause\
    \ is present and executed a new error,\n-\t\t// interrupt, throw, \":continue\"\
    , \":break\", \":return\", or\n-\t\t// \":finish\".\n-\t\tcase CSTP_CONTINUE:\n\
    -\t\t    ex_continue(eap);\n-\t\t    break;\n-\t\tcase CSTP_BREAK:\n-\t\t    ex_break(eap);\n\
    -\t\t    break;\n-\t\tcase CSTP_RETURN:\n-\t\t    do_return(eap, FALSE, FALSE,\
    \ rettv);\n-\t\t    break;\n-\t\tcase CSTP_FINISH:\n-\t\t    do_finish(eap, FALSE);\n\
    -\t\t    break;\n+\t    // Reactivate a pending \":continue\", \":break\", \"\
    :return\",\n+\t    // \":finish\" from the try block or a catch clause of this\
    \ try\n+\t    // conditional.  This is skipped, if there was an error in an\n\
    +\t    // (unskipped) conditional command or an interrupt afterwards\n+\t    //\
    \ or if the finally clause is present and executed a new error,\n+\t    // interrupt,\
    \ throw, \":continue\", \":break\", \":return\", or\n+\t    // \":finish\".\n\
    +\t    case CSTP_CONTINUE:\n+\t\tex_continue(eap);\n+\t\tbreak;\n+\t    case CSTP_BREAK:\n\
    +\t\tex_break(eap);\n+\t\tbreak;\n+\t    case CSTP_RETURN:\n+\t\tdo_return(eap,\
    \ FALSE, FALSE, rettv);\n+\t\tbreak;\n+\t    case CSTP_FINISH:\n+\t\tdo_finish(eap,\
    \ FALSE);\n+\t\tbreak;\n \n-\t\t// When the finally clause was entered due to\
    \ an error,\n-\t\t// interrupt or throw (as opposed to a \":continue\", \":break\"\
    ,\n-\t\t// \":return\", or \":finish\"), restore the pending values of\n-\t\t\
    // did_emsg, got_int, and did_throw.  This is skipped, if there\n-\t\t// was a\
    \ new error, interrupt, throw, \":continue\", \":break\",\n-\t\t// \":return\"\
    , or \":finish\".  in the finally clause.\n-\t\tdefault:\n-\t\t    if (pending\
    \ & CSTP_ERROR)\n-\t\t\tdid_emsg = TRUE;\n-\t\t    if (pending & CSTP_INTERRUPT)\n\
    -\t\t\tgot_int = TRUE;\n-\t\t    if (pending & CSTP_THROW)\n-\t\t\trethrow = TRUE;\n\
    -\t\t    break;\n-\t    }\n+\t    // When the finally clause was entered due to\
    \ an error,\n+\t    // interrupt or throw (as opposed to a \":continue\", \":break\"\
    ,\n+\t    // \":return\", or \":finish\"), restore the pending values of\n+\t\
    \    // did_emsg, got_int, and did_throw.  This is skipped, if there\n+\t    //\
    \ was a new error, interrupt, throw, \":continue\", \":break\",\n+\t    // \"\
    :return\", or \":finish\".  in the finally clause.\n+\t    default:\n+\t\tif (pending\
    \ & CSTP_ERROR)\n+\t\t    did_emsg = TRUE;\n+\t\tif (pending & CSTP_INTERRUPT)\n\
    +\t\t    got_int = TRUE;\n+\t\tif (pending & CSTP_THROW)\n+\t\t    rethrow = TRUE;\n\
    +\t\tbreak;\n \t}\n-\n-\tif (rethrow)\n-\t    // Rethrow the current exception\
    \ (within this cstack).\n-\t    do_throw(cstack);\n     }\n+\n+    if (rethrow)\n\
    +\t// Rethrow the current exception (within this cstack).\n+\tdo_throw(cstack);\n\
    \ }\n \n /*"
  - "--- a/src/version.c\n+++ b/src/version.c\n@@ -699,6 +699,8 @@ static char *(features[])\
    \ =\n \n static int included_patches[] =\n {   /* Add new patch number below this\
    \ line */\n+/**/\n+    577,\n /**/\n     576,\n /**/"
  identifiers:
  - CVE-2022-3296
  - CWE-121
  overview: Stack-based Buffer Overflow in GitHub repository vim/vim prior to 9.0.0577.
  references:
  - source: security@huntr.dev
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/vim/vim/commit/96b9bf8f74af8abf1e30054f996708db7dc285be
  - source: security@huntr.dev
    tags:
    - Exploit
    - Patch
    - Third Party Advisory
    url: https://huntr.dev/bounties/958866b8-526a-4979-9471-39392e0c9077
  - source: security@huntr.dev
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/4QI7AETXBHPC7SGA77Q7O5IEGULWYET7/
  - source: security@huntr.dev
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/GTBVD4J2SKVSWK4VBN5JP5OEVK6GDS3N/
  - source: security@huntr.dev
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/LSSEWQLK55MCNT4Z2IIJEJYEI5HLCODI/
  - source: security@huntr.dev
    url: https://security.gentoo.org/glsa/202305-16
  title: Stack-based Buffer Overflow in GitHub repository vim/vim prior to 9.0.0577.
- diff_content:
  - "--- a/src/insexpand.c\n+++ b/src/insexpand.c\n@@ -2490,7 +2490,8 @@ ins_compl_next_buf(buf_T\
    \ *buf, int flag)\n \n     if (flag == 'w')\t\t// just windows\n     {\n-\tif\
    \ (buf == curbuf || wp == NULL)  // first call for this flag/expansion\n+\tif\
    \ (buf == curbuf || !win_valid(wp))\n+\t    // first call for this flag/expansion\
    \ or window was closed\n \t    wp = curwin;\n \twhile ((wp = (wp->w_next != NULL\
    \ ? wp->w_next : firstwin)) != curwin\n \t\t&& wp->w_buffer->b_scanned)\n@@ -3188,9\
    \ +3189,10 @@ enum\n  */\n typedef struct\n {\n-    char_u\t*e_cpt;\t\t\t// current\
    \ entry in 'complete'\n+    char_u\t*e_cpt_copy;\t\t// copy of 'complete'\n+ \
    \   char_u\t*e_cpt;\t\t\t// current entry in \"e_cpt_copy\"\n     buf_T\t*ins_buf;\t\
    \t// buffer being scanned\n-    pos_T\t*cur_match_pos;\t\t\t// current match position\n\
    +    pos_T\t*cur_match_pos;\t\t// current match position\n     pos_T\tprev_match_pos;\t\
    \t// previous match position\n     int\t\tset_match_pos;\t\t// save first_match_pos/last_match_pos\n\
    \     pos_T\tfirst_match_pos;\t// first match position\n@@ -3257,7 +3259,8 @@\
    \ process_next_cpt_value(\n \tst->set_match_pos = TRUE;\n     }\n     else if\
    \ (vim_strchr((char_u *)\"buwU\", *st->e_cpt) != NULL\n-\t    && (st->ins_buf\
    \ = ins_compl_next_buf(st->ins_buf, *st->e_cpt)) != curbuf)\n+\t    && (st->ins_buf\
    \ = ins_compl_next_buf(\n+\t\t\t\t\t   st->ins_buf, *st->e_cpt)) != curbuf)\n\
    \     {\n \t// Scan a buffer, but not the current one.\n \tif (st->ins_buf->b_ml.ml_mfp\
    \ != NULL)   // loaded buffer\n@@ -3756,19 +3759,30 @@ get_next_completion_match(int\
    \ type, ins_compl_next_state_T *st, pos_T *ini)\n     static int\n ins_compl_get_exp(pos_T\
    \ *ini)\n {\n-    static ins_compl_next_state_T st;\n+    static ins_compl_next_state_T\
    \   st;\n+    static int\t\t\t    st_cleared = FALSE;\n     int\t\ti;\n     int\t\
    \tfound_new_match;\n     int\t\ttype = ctrl_x_mode;\n \n     if (!compl_started)\n\
    \     {\n-\tFOR_ALL_BUFFERS(st.ins_buf)\n-\t    st.ins_buf->b_scanned = 0;\n+\t\
    buf_T *buf;\n+\n+\tFOR_ALL_BUFFERS(buf)\n+\t    buf->b_scanned = 0;\n+\tif (!st_cleared)\n\
    +\t{\n+\t    CLEAR_FIELD(st);\n+\t    st_cleared = TRUE;\n+\t}\n \tst.found_all\
    \ = FALSE;\n \tst.ins_buf = curbuf;\n-\tst.e_cpt = (compl_cont_status & CONT_LOCAL)\n\
    -\t\t\t\t\t    ? (char_u *)\".\" : curbuf->b_p_cpt;\n+\tvim_free(st.e_cpt_copy);\n\
    +\t// Make a copy of 'complete', if case the buffer is wiped out.\n+\tst.e_cpt_copy\
    \ = vim_strsave((compl_cont_status & CONT_LOCAL)\n+\t\t\t\t\t    ? (char_u *)\"\
    .\" : curbuf->b_p_cpt);\n+\tst.e_cpt = st.e_cpt_copy == NULL ? (char_u *)\"\"\
    \ : st.e_cpt_copy;\n \tst.last_match_pos = st.first_match_pos = *ini;\n     }\n\
    \     else if (st.ins_buf != curbuf && !buf_valid(st.ins_buf))\n@@ -4112,6 +4126,7\
    \ @@ ins_compl_next(\n     int\t    todo = count;\n     int\t    advance;\n  \
    \   int\t    started = compl_started;\n+    buf_T   *orig_curbuf = curbuf;\n \n\
    \     // When user complete function return -1 for findstart which is next\n \
    \    // time of 'always', compl_shown_match become NULL.\n@@ -4144,6 +4159,13\
    \ @@ ins_compl_next(\n \t\t\t\t\t\t\t&num_matches) == -1)\n \treturn -1;\n \n\
    +    if (curbuf != orig_curbuf)\n+    {\n+\t// In case some completion function\
    \ switched buffer, don't want to\n+\t// insert the completion elsewhere.\n+\t\
    return -1;\n+    }\n+\n     // Insert the text of the new completion, or the compl_leader.\n\
    \     if (compl_no_insert && !started)\n     {"
  - "--- a/src/move.c\n+++ b/src/move.c\n@@ -683,6 +683,7 @@ cursor_valid(void)\n\
    \     void\n validate_cursor(void)\n {\n+    check_cursor();\n     check_cursor_moved(curwin);\n\
    \     if ((curwin->w_valid & (VALID_WCOL|VALID_WROW)) != (VALID_WCOL|VALID_WROW))\n\
    \ \tcurs_columns(TRUE);"
  - "--- a/src/version.c\n+++ b/src/version.c\n@@ -699,6 +699,8 @@ static char *(features[])\
    \ =\n \n static int included_patches[] =\n {   /* Add new patch number below this\
    \ line */\n+/**/\n+    579,\n /**/\n     578,\n /**/"
  identifiers:
  - CVE-2022-3297
  - CWE-416
  overview: Use After Free in GitHub repository vim/vim prior to 9.0.0579.
  references:
  - source: security@huntr.dev
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/vim/vim/commit/0ff01835a40f549c5c4a550502f62a2ac9ac447c
  - source: security@huntr.dev
    tags:
    - Exploit
    - Patch
    - Third Party Advisory
    url: https://huntr.dev/bounties/1aa9ec92-0355-4710-bf85-5bce9effa01c
  - source: security@huntr.dev
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/4QI7AETXBHPC7SGA77Q7O5IEGULWYET7/
  - source: security@huntr.dev
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/GTBVD4J2SKVSWK4VBN5JP5OEVK6GDS3N/
  - source: security@huntr.dev
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/LSSEWQLK55MCNT4Z2IIJEJYEI5HLCODI/
  - source: security@huntr.dev
    url: https://security.gentoo.org/glsa/202305-16
  title: Use After Free in GitHub repository vim/vim prior to 9.0.0579.
- diff_content:
  - "--- a/lib/sbi/client.c\n+++ b/lib/sbi/client.c\n@@ -44,6 +44,7 @@ typedef struct\
    \ connection_s {\n \n     char *memory;\n     size_t size;\n+    bool memory_overflow;\n\
    \ \n     char *location;\n \n@@ -533,6 +534,8 @@ static void check_multi_info(ogs_sbi_client_t\
    \ *client)\n \n             res = resource->data.result;\n             if (res\
    \ == CURLE_OK) {\n+                ogs_log_level_e level = OGS_LOG_DEBUG;\n+\n\
    \                 response = ogs_sbi_response_new();\n                 ogs_assert(response);\n\
    \ \n@@ -546,7 +549,17 @@ static void check_multi_info(ogs_sbi_client_t *client)\n\
    \                 response->h.uri = ogs_strdup(url);\n                 ogs_assert(response->h.uri);\n\
    \ \n-                ogs_debug(\"[%d:%s] %s\",\n+                if (content_type)\n\
    +                    ogs_sbi_header_set(response->http.headers,\n+           \
    \                 OGS_SBI_CONTENT_TYPE, content_type);\n+                if (conn->location)\n\
    +                    ogs_sbi_header_set(response->http.headers,\n+           \
    \                 OGS_SBI_LOCATION, conn->location);\n+\n+                if (conn->memory_overflow\
    \ == true)\n+                    level = OGS_LOG_ERROR;\n+\n+                ogs_log_message(level,\
    \ 0, \"[%d:%s] %s\",\n                         response->status, response->h.method,\
    \ response->h.uri);\n \n                 if (conn->memory) {\n@@ -557,16 +570,17\
    \ @@ static void check_multi_info(ogs_sbi_client_t *client)\n                \
    \     ogs_assert(response->http.content_length);\n                 }\n \n-   \
    \             ogs_debug(\"RECEIVED[%d]\", (int)response->http.content_length);\n\
    +                ogs_log_message(level, 0, \"RECEIVED[%d]\",\n+              \
    \          (int)response->http.content_length);\n                 if (response->http.content_length\
    \ && response->http.content)\n-                    ogs_debug(\"%s\", response->http.content);\n\
    +                    ogs_log_message(level, 0, \"%s\", response->http.content);\n\
    +\n+                if (conn->memory_overflow == true) {\n+                  \
    \  ogs_sbi_response_free(response);\n+                    connection_remove(conn);\n\
    +                    break;\n+                }\n \n-                if (content_type)\n\
    -                    ogs_sbi_header_set(response->http.headers,\n-           \
    \                 OGS_SBI_CONTENT_TYPE, content_type);\n-                if (conn->location)\n\
    -                    ogs_sbi_header_set(response->http.headers,\n-           \
    \                 OGS_SBI_LOCATION, conn->location);\n             } else\n  \
    \               ogs_warn(\"[%d] %s\", res, conn->error);\n \n@@ -727,8 +741,12\
    \ @@ static size_t write_cb(void *contents, size_t size, size_t nmemb, void *data)\n\
    \     realsize = size * nmemb;\n     ptr = ogs_realloc(conn->memory, conn->size\
    \ + realsize + 1);\n     if(!ptr) {\n-        ogs_fatal(\"not enough memory (realloc\
    \ returned NULL)\");\n-        ogs_assert_if_reached();\n+        conn->memory_overflow\
    \ = true;\n+\n+        ogs_error(\"Overflow : conn->size[%d], realsize[%d]\",\n\
    +                    (int)conn->size, (int)realsize);\n+        ogs_log_hexdump(OGS_LOG_ERROR,\
    \ contents, realsize);\n+\n         return 0;\n     }\n "
  - "--- a/lib/sbi/nghttp2-server.c\n+++ b/lib/sbi/nghttp2-server.c\n@@ -82,6 +82,7\
    \ @@ typedef struct ogs_sbi_stream_s {\n \n     int32_t                 stream_id;\n\
    \     ogs_sbi_request_t       *request;\n+    bool                    memory_overflow;\n\
    \ \n     ogs_sbi_session_t       *session;\n } ogs_sbi_stream_t;\n@@ -791,12 +792,23\
    \ @@ static int on_frame_recv(nghttp2_session *session,\n     case NGHTTP2_DATA:\n\
    \         /* HEADERS or DATA frame with +END_STREAM flag */\n         if (frame->hd.flags\
    \ & NGHTTP2_FLAG_END_STREAM) {\n+            ogs_log_level_e level = OGS_LOG_DEBUG;\n\
    \ \n-            ogs_debug(\"[%s] %s\", request->h.method, request->h.uri);\n\
    +            if (stream->memory_overflow == true)\n+                level = OGS_LOG_ERROR;\n\
    +\n+            ogs_log_message(level, 0,\n+                    \"[%s] %s\", request->h.method,\
    \ request->h.uri);\n \n             if (request->http.content_length && request->http.content)\
    \ {\n-                ogs_debug(\"RECEIVED: %d\", (int)request->http.content_length);\n\
    -                ogs_debug(\"%s\", request->http.content);\n+                ogs_log_message(level,\
    \ 0,\n+                        \"RECEIVED: %d\", (int)request->http.content_length);\n\
    +                ogs_log_message(level, 0, \"%s\", request->http.content);\n+\
    \            }\n+\n+            if (stream->memory_overflow == true) {\n+    \
    \            ogs_error(\"[DROP] Overflow\");\n+                break;\n      \
    \       }\n \n             if (server->cb(request, stream) != OGS_OK) {\n@@ -967,23\
    \ +979,30 @@ static int on_data_chunk_recv(nghttp2_session *session, uint8_t flags,\n\
    \     ogs_assert(len);\n \n     if (request->http.content == NULL) {\n-      \
    \  request->http.content_length = len;\n-        request->http.content =\n-  \
    \          (char*)ogs_malloc(request->http.content_length + 1);\n-        ogs_assert(request->http.content);\n\
    +        ogs_assert(request->http.content_length == 0);\n+        ogs_assert(offset\
    \ == 0);\n+\n+        request->http.content = (char*)ogs_malloc(len + 1);\n  \
    \   } else {\n-        offset = request->http.content_length;\n-        if ((request->http.content_length\
    \ + len) > OGS_HUGE_LEN) {\n-            ogs_error(\"Overflow : Content-Length[%d],\
    \ len[%d]\",\n-                        (int)request->http.content_length, (int)len);\n\
    -            ogs_assert_if_reached();\n-        }\n-        request->http.content_length\
    \ += len;\n-        request->http.content = (char *)ogs_realloc(\n-          \
    \      request->http.content, request->http.content_length + 1);\n-        ogs_assert(request->http.content);\n\
    +        ogs_assert(request->http.content_length != 0);\n+\n+        request->http.content\
    \ = (char*)ogs_realloc(\n+                request->http.content, request->http.content_length\
    \ + len + 1);\n     }\n \n+    if (!request->http.content) {\n+        stream->memory_overflow\
    \ = true;\n+\n+        ogs_error(\"Overflow : Content-Length[%d], len[%d]\",\n\
    +                    (int)request->http.content_length, (int)len);\n+        ogs_log_hexdump(OGS_LOG_ERROR,\
    \ data, len);\n+\n+        return 0;\n+    }\n+\n+    offset = request->http.content_length;\n\
    +    request->http.content_length += len;\n+\n     memcpy(request->http.content\
    \ + offset, data, len);\n     request->http.content[request->http.content_length]\
    \ = '\\0';\n "
  identifiers:
  - CVE-2022-3299
  - CWE-404
  overview: A vulnerability was found in Open5GS up to 2.4.10. It has been declared
    as problematic. Affected by this vulnerability is an unknown functionality in
    the library lib/sbi/client.c of the component AMF. The manipulation leads to denial
    of service. The attack can be launched remotely. The name of the patch is 724fa568435dae45ef0c3a48b2aabde052afae88.
    It is recommended to apply a patch to fix this issue. The identifier VDB-209545
    was assigned to this vulnerability.
  references:
  - source: cna@vuldb.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/open5gs/open5gs/commit/724fa568435dae45ef0c3a48b2aabde052afae88
  - source: cna@vuldb.com
    tags:
    - Exploit
    - Issue Tracking
    - Third Party Advisory
    url: https://github.com/open5gs/open5gs/issues/1769
  - source: cna@vuldb.com
    tags:
    - Permissions Required
    - Third Party Advisory
    url: https://vuldb.com/?id.209545
  title: A vulnerability was found in Open5GS up to 2.4.10. It has been declared as
    problematic. Affected by this vulnerability is an unknown functionality in the
    library lib/sbi/client.c of the component AMF. The manipulation leads to denial
    of service. The attack can be launched remotely. The name of the patch is 724fa568435dae45ef0c3a48b2aabde052afae88.
    It is recommended to apply a patch to fix this issue. The identifier VDB-209545
    was assigned to this vulnerability.
- diff_content:
  - "--- a/src/version.c\n+++ b/src/version.c\n@@ -699,6 +699,8 @@ static char *(features[])\
    \ =\n \n static int included_patches[] =\n {   /* Add new patch number below this\
    \ line */\n+/**/\n+    598,\n /**/\n     597,\n /**/"
  - "--- a/src/window.c\n+++ b/src/window.c\n@@ -2089,6 +2089,8 @@ win_equal_rec(\n\
    \ \t\tif (hnc)\t    // add next_curwin size\n \t\t{\n \t\t    next_curwin_size\
    \ -= p_wiw - (m - n);\n+\t\t    if (next_curwin_size < 0)\n+\t\t\tnext_curwin_size\
    \ = 0;\n \t\t    new_size += next_curwin_size;\n \t\t    room -= new_size - next_curwin_size;\n\
    \ \t\t}\n@@ -6611,7 +6613,8 @@ scroll_to_fraction(win_T *wp, int prev_height)\n\
    \     void\n win_new_width(win_T *wp, int width)\n {\n-    wp->w_width = width;\n\
    +    // Should we give an error if width < 0?\n+    wp->w_width = width < 0 ?\
    \ 0 : width;\n     wp->w_lines_valid = 0;\n     changed_line_abv_curs_win(wp);\n\
    \     // Handled in win_fix_scroll()"
  identifiers:
  - CVE-2022-3324
  - CWE-121
  overview: Stack-based Buffer Overflow in GitHub repository vim/vim prior to 9.0.0598.
  references:
  - source: security@huntr.dev
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/vim/vim/commit/8279af514ca7e5fd3c31cf13b0864163d1a0bfeb
  - source: security@huntr.dev
    tags:
    - Exploit
    - Third Party Advisory
    url: https://huntr.dev/bounties/e414e55b-f332-491f-863b-c18dca97403c
  - source: security@huntr.dev
    tags:
    - Mailing List
    - Third Party Advisory
    url: https://lists.debian.org/debian-lts-announce/2022/11/msg00009.html
  - source: security@huntr.dev
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/4QI7AETXBHPC7SGA77Q7O5IEGULWYET7/
  - source: security@huntr.dev
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/GTBVD4J2SKVSWK4VBN5JP5OEVK6GDS3N/
  - source: security@huntr.dev
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/LSSEWQLK55MCNT4Z2IIJEJYEI5HLCODI/
  - source: security@huntr.dev
    url: https://security.gentoo.org/glsa/202305-16
  title: Stack-based Buffer Overflow in GitHub repository vim/vim prior to 9.0.0598.
- diff_content:
  - "--- a/PowerEditor/src/MISC/Exception/MiniDumper.cpp\n+++ b/PowerEditor/src/MISC/Exception/MiniDumper.cpp\n\
    @@ -34,7 +34,7 @@ bool MiniDumper::writeDump(EXCEPTION_POINTERS * pExceptionInfo)\n\
    \ \tLPCTSTR szResult = NULL;\r\n \tbool retval = false;\r\n \r\n-\tHMODULE hDll\
    \ = ::LoadLibrary( TEXT(\"DBGHELP.DLL\") );\t//that wont work on older windows\
    \ version than XP, #care :)\r\n+\tHMODULE hDll = ::LoadLibraryEx(TEXT(\"DBGHELP.DLL\"\
    ), nullptr, LOAD_LIBRARY_SEARCH_SYSTEM32);\t//that wont work on older windows\
    \ version than XP, #care :)\r\n \r\n \tif (hDll)\r\n \t{\r"
  - "--- a/PowerEditor/src/Parameters.cpp\n+++ b/PowerEditor/src/Parameters.cpp\n\
    @@ -1169,7 +1169,7 @@ bool NppParameters::load()\n \t//---------------------------------------------//\r\
    \n \t// Dlg theme texture function for xp and vista //\r\n \t//---------------------------------------------//\r\
    \n-\t_hUXTheme = ::LoadLibrary(TEXT(\"uxtheme.dll\"));\r\n+\t_hUXTheme = ::LoadLibraryEx(TEXT(\"\
    uxtheme.dll\"), nullptr, LOAD_LIBRARY_SEARCH_SYSTEM32);\r\n \tif (_hUXTheme)\r\
    \n \t\t_enableThemeDialogTextureFuncAddr = (WNDPROC)::GetProcAddress(_hUXTheme,\
    \ \"EnableThemeDialogTexture\");\r\n \r"
  identifiers:
  - CVE-2022-32168
  - CWE-427
  overview: Notepad++ versions 8.4.1 and before are vulnerable to DLL hijacking where
    an attacker can replace the vulnerable dll (UxTheme.dll) with his own dll and
    run arbitrary code in the context of Notepad++.
  references:
  - source: vulnerabilitylab@mend.io
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/notepad-plus-plus/notepad-plus-plus/commit/85d7215d9b3e0d5a8433fc31aec4f2966821051e
  - source: vulnerabilitylab@mend.io
    tags:
    - Exploit
    - Third Party Advisory
    url: https://www.mend.io/vulnerability-database/CVE-2022-32168
  title: Notepad++ versions 8.4.1 and before are vulnerable to DLL hijacking where
    an attacker can replace the vulnerable dll (UxTheme.dll) with his own dll and
    run arbitrary code in the context of Notepad++.
- diff_content:
  - "--- a/lib/flow.c\n+++ b/lib/flow.c\n@@ -1,5 +1,5 @@\n /*\n- * Copyright (c) 2008,\
    \ 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2017 Nicira, Inc.\n+ * Copyright (c)\
    \ 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2017, 2019 Nicira, Inc.\n  *\n\
    \  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you\
    \ may not use this file except in compliance with the License.\n@@ -3506,8 +3506,21\
    \ @@ minimask_expand(const struct minimask *mask, struct flow_wildcards *wc)\n\
    \ bool\n minimask_equal(const struct minimask *a, const struct minimask *b)\n\
    \ {\n-    return !memcmp(a, b, sizeof *a\n-                   + MINIFLOW_VALUES_SIZE(miniflow_n_values(&a->masks)));\n\
    +    /* At first glance, it might seem that this can be reasonably optimized\n\
    +     * into a single memcmp() for the total size of the region.  Such an\n+ \
    \    * optimization will work OK with most implementations of memcmp() that\n\
    +     * proceed from the start of the regions to be compared to the end in\n+\
    \     * reasonably sized chunks.  However, memcmp() is not required to be\n+ \
    \    * implemented that way, and an implementation that, for example, compares\n\
    +     * all of the bytes in both regions without early exit when it finds a\n\
    +     * difference, or one that compares, say, 64 bytes at a time, could access\n\
    +     * an unmapped region of memory if minimasks 'a' and 'b' have different\n\
    +     * lengths.  By first checking that the maps are the same with the first\n\
    +     * memcmp(), we verify that 'a' and 'b' have the same length and therefore\n\
    +     * ensure that the second memcmp() is safe. */\n+    return (!memcmp(a, b,\
    \ sizeof *a)\n+            && !memcmp(a + 1, b + 1,\n+                       MINIFLOW_VALUES_SIZE(miniflow_n_values(&a->masks))));\n\
    \ }\n \n /* Returns true if at least one bit matched by 'b' is wildcarded by 'a',"
  identifiers:
  - CVE-2022-32166
  - CWE-125
  overview: "In ovs versions v0.90.0 through v2.5.0 are vulnerable to heap buffer\
    \ over-read in flow.c. An unsafe comparison of \u201Cminimasks\u201D function\
    \ could lead access to an unmapped region of memory. This vulnerability is capable\
    \ of crashing the software, memory modification, and possible remote execution."
  references:
  - source: vulnerabilitylab@mend.io
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/cloudbase/ovs/commit/2ed6505555cdcb46f9b1f0329d1491b75290fc73
  - source: vulnerabilitylab@mend.io
    tags:
    - Mailing List
    - Third Party Advisory
    url: https://lists.debian.org/debian-lts-announce/2022/10/msg00036.html
  - source: vulnerabilitylab@mend.io
    tags:
    - Third Party Advisory
    url: https://www.mend.io/vulnerability-database/CVE-2022-32166
  title: "In ovs versions v0.90.0 through v2.5.0 are vulnerable to heap buffer over-read\
    \ in flow.c. An unsafe comparison of \u201Cminimasks\u201D function could lead\
    \ access to an unmapped region of memory. This vulnerability is capable of crashing\
    \ the software, memory modification, and possible remote execution."
- diff_content:
  - "--- a/libfwupdplugin/fu-plugin.c\n+++ b/libfwupdplugin/fu-plugin.c\n@@ -9,6 +9,7\
    \ @@\n #include \"config.h\"\n \n #include <errno.h>\n+#include <fcntl.h>\n #include\
    \ <fwupd.h>\n #include <glib/gstdio.h>\n #include <gmodule.h>\n@@ -2417,6 +2418,46\
    \ @@ fu_plugin_set_config_value(FuPlugin *self, const gchar *key, const gchar\
    \ *value,\n \treturn g_key_file_save_to_file(keyfile, conf_path, error);\n }\n\
    \ \n+#if !GLIB_CHECK_VERSION(2, 66, 0)\n+\n+#define G_FILE_SET_CONTENTS_CONSISTENT\
    \ 0\n+typedef guint GFileSetContentsFlags;\n+static gboolean\n+g_file_set_contents_full(const\
    \ gchar *filename,\n+\t\t\t const gchar *contents,\n+\t\t\t gssize length,\n+\t\
    \t\t GFileSetContentsFlags flags,\n+\t\t\t int mode,\n+\t\t\t GError **error)\n\
    +{\n+\tgint fd;\n+\tgssize wrote;\n+\n+\tif (length < 0)\n+\t\tlength = strlen(contents);\n\
    +\tfd = g_open(filename, O_CREAT, mode);\n+\tif (fd <= 0) {\n+\t\tg_set_error(error,\n\
    +\t\t\t    G_IO_ERROR,\n+\t\t\t    G_IO_ERROR_FAILED,\n+\t\t\t    \"could not\
    \ open %s file\",\n+\t\t\t    filename);\n+\t\treturn FALSE;\n+\t}\n+\twrote =\
    \ write(fd, contents, length);\n+\tif (wrote != length) {\n+\t\tg_set_error(error,\n\
    +\t\t\t    G_IO_ERROR,\n+\t\t\t    G_IO_ERROR_FAILED,\n+\t\t\t    \"did not write\
    \ %s file\",\n+\t\t\t    filename);\n+\t\tg_close(fd, NULL);\n+\t\treturn FALSE;\n\
    +\t}\n+\treturn g_close(fd, error);\n+}\n+#endif\n+\n /**\n  * fu_plugin_set_secure_config_value:\n\
    \  * @self: a #FuPlugin\n@@ -2438,7 +2479,8 @@ fu_plugin_set_secure_config_value(FuPlugin\
    \ *self,\n \t\t\t\t  GError **error)\n {\n \tg_autofree gchar *conf_path = fu_plugin_get_config_filename(self);\n\
    -\tgint ret;\n+\tg_autofree gchar *data = NULL;\n+\tg_autoptr(GKeyFile) keyfile\
    \ = g_key_file_new();\n \n \tg_return_val_if_fail(FU_IS_PLUGIN(self), FALSE);\n\
    \ \tg_return_val_if_fail(error == NULL || *error == NULL, FALSE);\n@@ -2447,17\
    \ +2489,18 @@ fu_plugin_set_secure_config_value(FuPlugin *self,\n \t\tg_set_error(error,\
    \ FWUPD_ERROR, FWUPD_ERROR_NOT_FOUND, \"%s is missing\", conf_path);\n \t\treturn\
    \ FALSE;\n \t}\n-\tret = g_chmod(conf_path, 0660);\n-\tif (ret == -1) {\n-\t\t\
    g_set_error(error,\n-\t\t\t    FWUPD_ERROR,\n-\t\t\t    FWUPD_ERROR_INTERNAL,\n\
    -\t\t\t    \"failed to set permissions on %s\",\n-\t\t\t    conf_path);\n+\tif\
    \ (!g_key_file_load_from_file(keyfile, conf_path, G_KEY_FILE_KEEP_COMMENTS, error))\n\
    \ \t\treturn FALSE;\n-\t}\n-\n-\treturn fu_plugin_set_config_value(self, key,\
    \ value, error);\n+\tg_key_file_set_string(keyfile, fu_plugin_get_name(self),\
    \ key, value);\n+\tdata = g_key_file_to_data(keyfile, NULL, error);\n+\tif (data\
    \ == NULL)\n+\t\treturn FALSE;\n+\treturn g_file_set_contents_full(conf_path,\n\
    +\t\t\t\t\tdata,\n+\t\t\t\t\t-1,\n+\t\t\t\t\tG_FILE_SET_CONTENTS_CONSISTENT,\n\
    +\t\t\t\t\t0660,\n+\t\t\t\t\terror);\n }\n \n /**"
  - "--- a/libfwupdplugin/fu-self-test.c\n+++ b/libfwupdplugin/fu-self-test.c\n@@\
    \ -674,6 +674,62 @@ _plugin_device_added_cb(FuPlugin *plugin, FuDevice *device,\
    \ gpointer user_data)\n \tfu_test_loop_quit();\n }\n \n+static void\n+fu_plugin_config_func(void)\n\
    +{\n+\tGStatBuf statbuf = {0};\n+\tgboolean ret;\n+\tgint rc;\n+\tg_autofree gchar\
    \ *conf_dir = NULL;\n+\tg_autofree gchar *conf_file = NULL;\n+\tg_autofree gchar\
    \ *fn = NULL;\n+\tg_autofree gchar *testdatadir = NULL;\n+\tg_autofree gchar *value\
    \ = NULL;\n+\tg_autoptr(FuPlugin) plugin = fu_plugin_new(NULL);\n+\tg_autoptr(GError)\
    \ error = NULL;\n+\n+\t/* this is a build file */\n+\ttestdatadir = g_test_build_filename(G_TEST_BUILT,\
    \ \"tests\", NULL);\n+\t(void)g_setenv(\"FWUPD_SYSCONFDIR\", testdatadir, TRUE);\n\
    +\tconf_dir = fu_path_from_kind(FU_PATH_KIND_SYSCONFDIR_PKG);\n+\n+\t/* remove\
    \ existing file */\n+\tfu_plugin_set_name(plugin, \"test\");\n+\tconf_file = g_strdup_printf(\"\
    %s.conf\", fu_plugin_get_name(plugin));\n+\tfn = g_build_filename(conf_dir, conf_file,\
    \ NULL);\n+\tret = fu_path_mkdir_parent(fn, &error);\n+\tg_assert_no_error(error);\n\
    +\tg_assert_true(ret);\n+\tg_remove(fn);\n+\tret = g_file_set_contents(fn, \"\"\
    , -1, &error);\n+\tg_assert_no_error(error);\n+\tg_assert_true(ret);\n+\n+\t/*\
    \ set a value */\n+\tret = fu_plugin_set_config_value(plugin, \"Key\", \"True\"\
    , &error);\n+\tg_assert_no_error(error);\n+\tg_assert_true(ret);\n+\tg_assert_true(g_file_test(fn,\
    \ G_FILE_TEST_EXISTS));\n+\n+\t/* check it is world readable */\n+\trc = g_stat(fn,\
    \ &statbuf);\n+\tg_assert_cmpint(rc, ==, 0);\n+\tg_assert_cmpint(statbuf.st_mode\
    \ & 0777, ==, 0644);\n+\n+\t/* read back the value */\n+\tvalue = fu_plugin_get_config_value(plugin,\
    \ \"Key\");\n+\tg_assert_cmpstr(value, ==, \"True\");\n+\tg_assert_true(fu_plugin_get_config_value_boolean(plugin,\
    \ \"Key\"));\n+\n+\t/* check it is private, i.e. only readable by the user/group\
    \ */\n+\tret = fu_plugin_set_secure_config_value(plugin, \"Key\", \"False\", &error);\n\
    +\tg_assert_no_error(error);\n+\tg_assert_true(ret);\n+\trc = g_stat(fn, &statbuf);\n\
    +\tg_assert_cmpint(rc, ==, 0);\n+\tg_assert_cmpint(statbuf.st_mode & 0777, ==,\
    \ 0640);\n+}\n+\n static void\n fu_plugin_devices_func(void)\n {\n@@ -3598,6 +3654,7\
    \ @@ main(int argc, char **argv)\n \tg_test_add_func(\"/fwupd/progress{finish}\"\
    , fu_progress_finish_func);\n \tg_test_add_func(\"/fwupd/bios-attrs{load}\", fu_bios_settings_load_func);\n\
    \ \tg_test_add_func(\"/fwupd/security-attrs{hsi}\", fu_security_attrs_hsi_func);\n\
    +\tg_test_add_func(\"/fwupd/plugin{config}\", fu_plugin_config_func);\n \tg_test_add_func(\"\
    /fwupd/plugin{devices}\", fu_plugin_devices_func);\n \tg_test_add_func(\"/fwupd/plugin{device-inhibit-children}\"\
    ,\n \t\t\tfu_plugin_device_inhibit_children_func);"
  identifiers:
  - CVE-2022-3287
  - CWE-552
  overview: When creating an OPERATOR user account on the BMC, the redfish plugin
    saved the auto-generated password to /etc/fwupd/redfish.conf without proper restriction,
    allowing any user on the system to read the same configuration file.
  references:
  - source: secalert@redhat.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/fwupd/fwupd/commit/ea676855f2119e36d433fbd2ed604039f53b2091
  title: When creating an OPERATOR user account on the BMC, the redfish plugin saved
    the auto-generated password to /etc/fwupd/redfish.conf without proper restriction,
    allowing any user on the system to read the same configuration file.
- diff_content:
  - "--- a/src/encryption/Olm.cpp\n+++ b/src/encryption/Olm.cpp\n@@ -342,10 +342,13\
    \ @@ handle_olm_message(const OlmMessage &msg, const UserKeyCache &otherUserDeviceKey\n\
    \                 if (msg.sender != local_user.to_string())\n                \
    \     return;\n \n-                auto secret_name = request_id_to_secret_name.find(e->content.request_id);\n\
    +                auto secret_name_it = request_id_to_secret_name.find(e->content.request_id);\n\
    \ \n-                if (secret_name != request_id_to_secret_name.end()) {\n-\
    \                    nhlog::crypto()->info(\"Received secret: {}\", secret_name->second);\n\
    +                if (secret_name_it != request_id_to_secret_name.end()) {\n+ \
    \                   auto secret_name = secret_name_it->second;\n+            \
    \        request_id_to_secret_name.erase(secret_name_it);\n+\n+              \
    \      nhlog::crypto()->info(\"Received secret: {}\", secret_name);\n \n     \
    \                mtx::events::msg::SecretRequest secretRequest{};\n          \
    \           secretRequest.action = mtx::events::msg::RequestAction::Cancellation;\n\
    @@ -358,15 +361,24 @@ handle_olm_message(const OlmMessage &msg, const UserKeyCache\
    \ &otherUserDeviceKey\n                         return;\n \n                 \
    \    auto deviceKeys = cache::userKeys(local_user.to_string());\n+           \
    \         if (!deviceKeys)\n+                        return;\n+\n            \
    \         std::string sender_device_id;\n-                    if (deviceKeys)\
    \ {\n-                        for (auto &[dev, key] : deviceKeys->device_keys)\
    \ {\n-                            if (key.keys[\"curve25519:\" + dev] == msg.sender_key)\
    \ {\n-                                sender_device_id = dev;\n-             \
    \                   break;\n-                            }\n+                \
    \    for (auto &[dev, key] : deviceKeys->device_keys) {\n+                   \
    \     if (key.keys[\"curve25519:\" + dev] == msg.sender_key) {\n+            \
    \                sender_device_id = dev;\n+                            break;\n\
    \                         }\n                     }\n+                    if (!verificationStatus->verified_devices.count(sender_device_id)\
    \ ||\n+                        !verificationStatus->verified_device_keys.count(msg.sender_key)\
    \ ||\n+                        verificationStatus->verified_device_keys.at(msg.sender_key)\
    \ !=\n+                          crypto::Trust::Verified) {\n+               \
    \         nhlog::net()->critical(\n+                          \"Received secret\
    \ from unverified device {}! Ignoring!\", sender_device_id);\n+              \
    \          return;\n+                    }\n \n                     std::map<mtx::identifiers::User,\n\
    \                              std::map<std::string, mtx::events::msg::SecretRequest>>\n\
    @@ -380,19 +392,17 @@ handle_olm_message(const OlmMessage &msg, const UserKeyCache\
    \ &otherUserDeviceKey\n                     http::client()->send_to_device<mtx::events::msg::SecretRequest>(\n\
    \                       http::client()->generate_txn_id(),\n                 \
    \      body,\n-                      [name = secret_name->second](mtx::http::RequestErr\
    \ err) {\n+                      [secret_name](mtx::http::RequestErr err) {\n\
    \                           if (err) {\n                               nhlog::net()->error(\"\
    Failed to send request cancellation \"\n                                     \
    \              \"for secrect \"\n                                            \
    \       \"'{}'\",\n-                                                  name);\n\
    +                                                  secret_name);\n           \
    \                }\n                       });\n \n-                    nhlog::crypto()->info(\"\
    Storing secret {}\", secret_name->second);\n-                    cache::client()->storeSecret(secret_name->second,\
    \ e->content.secret);\n-\n-                    request_id_to_secret_name.erase(secret_name);\n\
    +                    nhlog::crypto()->info(\"Storing secret {}\", secret_name);\n\
    +                    cache::client()->storeSecret(secret_name, e->content.secret);\n\
    \                 }\n \n             } else if (auto sec_req = std::get_if<DeviceEvent<msg::SecretRequest>>(&device_event))\
    \ {"
  identifiers:
  - CVE-2022-39264
  - CWE-287
  overview: nheko is a desktop client for the Matrix communication application. All
    versions below 0.10.2 are vulnerable homeservers inserting malicious secrets,
    which could lead to man-in-the-middle attacks. Users can upgrade to version 0.10.2
    to protect against this issue. As a workaround, one may apply the patch manually,
    avoid doing verifications of one's own devices, and/or avoid pressing the request
    button in the settings menu.
  references:
  - source: security-advisories@github.com
    tags:
    - Patch
    url: https://github.com/Nheko-Reborn/nheko/commit/67bee15a389f9b8a9f6c3a340558d1e2319e7199
  - source: security-advisories@github.com
    tags:
    - Release Notes
    url: https://github.com/Nheko-Reborn/nheko/releases/tag/v0.10.2
  - source: security-advisories@github.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/Nheko-Reborn/nheko/security/advisories/GHSA-8jcp-8jq4-5mm7
  - source: security-advisories@github.com
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/TA6A5ADUVAYKD3ZFLF2JPZOTIOFJOEU7/
  - source: security-advisories@github.com
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/YBOL6OOQGPZD2RLYT4EHAWTFXNIHLYEN/
  title: nheko is a desktop client for the Matrix communication application. All versions
    below 0.10.2 are vulnerable homeservers inserting malicious secrets, which could
    lead to man-in-the-middle attacks. Users can upgrade to version 0.10.2 to protect
    against this issue. As a workaround, one may apply the patch manually, avoid doing
    verifications of one's own devices, and/or avoid pressing the request button in
    the settings menu.
- diff_content:
  - "--- a/src/buffer.c\n+++ b/src/buffer.c\n@@ -2642,13 +2642,15 @@ buflist_findpat(\n\
    \ \t\tif (*p == '^' && !(attempt & 1))\t // add/remove '^'\n \t\t    ++p;\n \t\
    \tregmatch.regprog = vim_regcomp(p, magic_isset() ? RE_MAGIC : 0);\n-\t\tif (regmatch.regprog\
    \ == NULL)\n-\t\t{\n-\t\t    vim_free(pat);\n-\t\t    return -1;\n-\t\t}\n \n\
    \ \t\tFOR_ALL_BUFS_FROM_LAST(buf)\n+\t\t{\n+\t\t    if (regmatch.regprog == NULL)\n\
    +\t\t    {\n+\t\t\t// invalid pattern, possibly after switching engine\n+\t\t\t\
    vim_free(pat);\n+\t\t\treturn -1;\n+\t\t    }\n \t\t    if (buf->b_p_bl == find_listed\n\
    \ #ifdef FEAT_DIFF\n \t\t\t    && (!diffmode || diff_mode_buf(buf))\n@@ -2674,6\
    \ +2676,7 @@ buflist_findpat(\n \t\t\t}\n \t\t\tmatch = buf->b_fnum;\t// remember\
    \ first match\n \t\t    }\n+\t\t}\n \n \t\tvim_regfree(regmatch.regprog);\n \t\
    \tif (match >= 0)\t\t\t// found one match\n@@ -2766,12 +2769,6 @@ ExpandBufnames(\n\
    \ \t    if (attempt > 0 && patc == pat)\n \t\tbreak;\t// there was no anchor,\
    \ no need to try again\n \t    regmatch.regprog = vim_regcomp(patc + attempt *\
    \ 11, RE_MAGIC);\n-\t    if (regmatch.regprog == NULL)\n-\t    {\n-\t\tif (patc\
    \ != pat)\n-\t\t    vim_free(patc);\n-\t\treturn FAIL;\n-\t    }\n \t}\n \n \t\
    // round == 1: Count the matches.\n@@ -2792,7 +2789,16 @@ ExpandBufnames(\n #endif\n\
    \ \n \t\tif (!fuzzy)\n+\t\t{\n+\t\t    if (regmatch.regprog == NULL)\n+\t\t  \
    \  {\n+\t\t\t// invalid pattern, possibly after recompiling\n+\t\t\tif (patc !=\
    \ pat)\n+\t\t\t    vim_free(patc);\n+\t\t\treturn FAIL;\n+\t\t    }\n \t\t   \
    \ p = buflist_match(&regmatch, buf, p_wic);\n+\t\t}\n \t\telse\n \t\t{\n \t\t\
    \    p = NULL;\n@@ -2921,6 +2927,7 @@ ExpandBufnames(\n \n /*\n  * Check for a\
    \ match on the file name for buffer \"buf\" with regprog \"prog\".\n+ * Note that\
    \ rmp->regprog may become NULL when switching regexp engine.\n  */\n     static\
    \ char_u *\n buflist_match(\n@@ -2939,7 +2946,8 @@ buflist_match(\n }\n \n /*\n\
    - * Try matching the regexp in \"prog\" with file name \"name\".\n+ * Try matching\
    \ the regexp in \"rmp->regprog\" with file name \"name\".\n+ * Note that rmp->regprog\
    \ may become NULL when switching regexp engine.\n  * Return \"name\" when there\
    \ is a match, NULL when not.\n  */\n     static char_u *\n@@ -2951,7 +2959,8 @@\
    \ fname_match(\n     char_u\t*match = NULL;\n     char_u\t*p;\n \n-    if (name\
    \ != NULL)\n+    // extra check for valid arguments\n+    if (name != NULL &&\
    \ rmp->regprog != NULL)\n     {\n \t// Ignore case when 'fileignorecase' or the\
    \ argument is set.\n \trmp->rm_ic = p_fic || ignore_case;"
  - "--- a/src/version.c\n+++ b/src/version.c\n@@ -746,6 +746,8 @@ static char *(features[])\
    \ =\n \n static int included_patches[] =\n {   /* Add new patch number below this\
    \ line */\n+/**/\n+    4959,\n /**/\n     4958,\n /**/"
  identifiers:
  - CVE-2022-1725
  - CWE-476
  overview: NULL Pointer Dereference in GitHub repository vim/vim prior to 8.2.4959.
  references:
  - source: security@huntr.dev
    tags:
    - Mailing List
    - Third Party Advisory
    url: http://seclists.org/fulldisclosure/2022/Oct/28
  - source: security@huntr.dev
    tags:
    - Mailing List
    - Release Notes
    - Third Party Advisory
    url: http://seclists.org/fulldisclosure/2022/Oct/41
  - source: security@huntr.dev
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/vim/vim/commit/b62dc5e7825bc195efe3041d5b3a9f1528359e1c
  - source: security@huntr.dev
    tags:
    - Exploit
    - Third Party Advisory
    url: https://huntr.dev/bounties/4363cf07-233e-4d0a-a1d5-c731a400525c
  - source: security@huntr.dev
    tags:
    - Third Party Advisory
    url: https://security.gentoo.org/glsa/202305-16
  - source: security@huntr.dev
    tags:
    - Release Notes
    - Third Party Advisory
    url: https://support.apple.com/kb/HT213488
  title: NULL Pointer Dereference in GitHub repository vim/vim prior to 8.2.4959.
- diff_content:
  - "--- a/src/buffer.c\n+++ b/src/buffer.c\n@@ -468,7 +468,12 @@ can_unload_buffer(buf_T\
    \ *buf)\n \t    }\n     }\n     if (!can_unload)\n-\tsemsg(_(e_attempt_to_delete_buffer_that_is_in_use_str),\
    \ buf->b_fname);\n+    {\n+\tchar_u *fname = buf->b_fname != NULL ? buf->b_fname\
    \ : buf->b_ffname;\n+\n+\tsemsg(_(e_attempt_to_delete_buffer_that_is_in_use_str),\n\
    +\t\t\t\tfname != NULL ? fname : (char_u *)\"[No Name]\");\n+    }\n     return\
    \ can_unload;\n }\n "
  - "--- a/src/spell.c\n+++ b/src/spell.c\n@@ -1568,6 +1568,10 @@ spell_load_lang(char_u\
    \ *lang)\n     sl.sl_slang = NULL;\n     sl.sl_nobreak = FALSE;\n \n+    // Disallow\
    \ deleting the current buffer.  Autocommands can do weird things\n+    // and\
    \ cause \"lang\" to be freed.\n+    ++curbuf->b_locked;\n+\n     // We may retry\
    \ when no spell file is found for the language, an\n     // autocommand may load\
    \ it then.\n     for (round = 1; round <= 2; ++round)\n@@ -1621,6 +1625,8 @@ spell_load_lang(char_u\
    \ *lang)\n \tSTRCPY(fname_enc + STRLEN(fname_enc) - 3, \"add.spl\");\n \tdo_in_runtimepath(fname_enc,\
    \ DIP_ALL, spell_load_cb, &sl);\n     }\n+\n+    --curbuf->b_locked;\n }\n \n\
    \ /*"
  - "--- a/src/version.c\n+++ b/src/version.c\n@@ -699,6 +699,8 @@ static char *(features[])\
    \ =\n \n static int included_patches[] =\n {   /* Add new patch number below this\
    \ line */\n+/**/\n+    614,\n /**/\n     613,\n /**/"
  identifiers:
  - CVE-2022-3352
  - CWE-416
  overview: Use After Free in GitHub repository vim/vim prior to 9.0.0614.
  references:
  - source: security@huntr.dev
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/vim/vim/commit/ef976323e770315b5fca544efb6b2faa25674d15
  - source: security@huntr.dev
    tags:
    - Exploit
    - Patch
    - Third Party Advisory
    url: https://huntr.dev/bounties/d058f182-a49b-40c7-9234-43d4c5a29f60
  - source: security@huntr.dev
    tags:
    - Mailing List
    - Third Party Advisory
    url: https://lists.debian.org/debian-lts-announce/2022/11/msg00032.html
  - source: security@huntr.dev
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/4QI7AETXBHPC7SGA77Q7O5IEGULWYET7/
  - source: security@huntr.dev
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/GTBVD4J2SKVSWK4VBN5JP5OEVK6GDS3N/
  - source: security@huntr.dev
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/LSSEWQLK55MCNT4Z2IIJEJYEI5HLCODI/
  - source: security@huntr.dev
    url: https://security.gentoo.org/glsa/202305-16
  title: Use After Free in GitHub repository vim/vim prior to 9.0.0614.
- diff_content:
  - "--- a/pjlib-util/src/pjlib-util/scanner.c\n+++ b/pjlib-util/src/pjlib-util/scanner.c\n\
    @@ -195,7 +195,13 @@ PJ_DEF(void) pj_scan_skip_whitespace( pj_scanner *scanner\
    \ )\n \n PJ_DEF(void) pj_scan_skip_line( pj_scanner *scanner )\n {\n-    char\
    \ *s = pj_memchr(scanner->curptr, '\\n', scanner->end - scanner->curptr);\n+ \
    \   char *s;\n+\n+    if (pj_scan_is_eof(scanner)) {\n+        return;\n+    }\n\
    +\n+    s = pj_memchr(scanner->curptr, '\\n', scanner->end - scanner->curptr);\n\
    \     if (!s) {\n \tscanner->curptr = scanner->end;\n     } else {\n@@ -264,8\
    \ +270,7 @@ PJ_DEF(void) pj_scan_get( pj_scanner *scanner,\n \n     pj_assert(pj_cis_match(spec,0)==0);\n\
    \ \n-    /* EOF is detected implicitly */\n-    if (!pj_cis_match(spec, *s)) {\n\
    +    if (pj_scan_is_eof(scanner) || !pj_cis_match(spec, *s)) {\n \tpj_scan_syntax_err(scanner);\n\
    \ \treturn;\n     }\n@@ -299,8 +304,7 @@ PJ_DEF(void) pj_scan_get_unescape( pj_scanner\
    \ *scanner,\n     /* Must not match character '%' */\n     pj_assert(pj_cis_match(spec,'%')==0);\n\
    \ \n-    /* EOF is detected implicitly */\n-    if (!pj_cis_match(spec, *s) &&\
    \ *s != '%') {\n+    if (pj_scan_is_eof(scanner) || !pj_cis_match(spec, *s) &&\
    \ *s != '%') {\n \tpj_scan_syntax_err(scanner);\n \treturn;\n     }\n@@ -436,7\
    \ +440,9 @@ PJ_DEF(void) pj_scan_get_n( pj_scanner *scanner,\n     \n     scanner->curptr\
    \ += N;\n \n-    if (PJ_SCAN_IS_PROBABLY_SPACE(*scanner->curptr) && scanner->skip_ws)\
    \ {\n+    if (!pj_scan_is_eof(scanner) &&\n+\tPJ_SCAN_IS_PROBABLY_SPACE(*scanner->curptr)\
    \ && scanner->skip_ws)\n+    {\n \tpj_scan_skip_whitespace(scanner);\n     }\n\
    \ }\n@@ -467,15 +473,16 @@ PJ_DEF(int) pj_scan_get_char( pj_scanner *scanner )\n\
    \ \n PJ_DEF(void) pj_scan_get_newline( pj_scanner *scanner )\n {\n-    if (!PJ_SCAN_IS_NEWLINE(*scanner->curptr))\
    \ {\n+    if (pj_scan_is_eof(scanner) || !PJ_SCAN_IS_NEWLINE(*scanner->curptr))\
    \ {\n \tpj_scan_syntax_err(scanner);\n \treturn;\n     }\n \n+    /* We have checked\
    \ scanner->curptr validity above */\n     if (*scanner->curptr == '\\r') {\n \t\
    ++scanner->curptr;\n     }\n-    if (*scanner->curptr == '\\n') {\n+    if (!pj_scan_is_eof(scanner)\
    \ && *scanner->curptr == '\\n') {\n \t++scanner->curptr;\n     }\n \n@@ -520,7\
    \ +527,9 @@ PJ_DEF(void) pj_scan_get_until( pj_scanner *scanner,\n \n     scanner->curptr\
    \ = s;\n \n-    if (PJ_SCAN_IS_PROBABLY_SPACE(*s) && scanner->skip_ws) {\n+  \
    \  if (!pj_scan_is_eof(scanner) && PJ_SCAN_IS_PROBABLY_SPACE(*s) &&\n+\tscanner->skip_ws)\n\
    +    {\n \tpj_scan_skip_whitespace(scanner);\n     }\n }\n@@ -544,7 +553,9 @@\
    \ PJ_DEF(void) pj_scan_get_until_ch( pj_scanner *scanner,\n \n     scanner->curptr\
    \ = s;\n \n-    if (PJ_SCAN_IS_PROBABLY_SPACE(*s) && scanner->skip_ws) {\n+  \
    \  if (!pj_scan_is_eof(scanner) && PJ_SCAN_IS_PROBABLY_SPACE(*s) &&\n+\tscanner->skip_ws)\n\
    +    {\n \tpj_scan_skip_whitespace(scanner);\n     }\n }\n@@ -570,7 +581,9 @@\
    \ PJ_DEF(void) pj_scan_get_until_chr( pj_scanner *scanner,\n \n     scanner->curptr\
    \ = s;\n \n-    if (PJ_SCAN_IS_PROBABLY_SPACE(*s) && scanner->skip_ws) {\n+  \
    \  if (!pj_scan_is_eof(scanner) && PJ_SCAN_IS_PROBABLY_SPACE(*s) &&\n+\tscanner->skip_ws)\n\
    +    {\n \tpj_scan_skip_whitespace(scanner);\n     }\n }\n@@ -585,7 +598,9 @@\
    \ PJ_DEF(void) pj_scan_advance_n( pj_scanner *scanner,\n \n     scanner->curptr\
    \ += N;\n \n-    if (PJ_SCAN_IS_PROBABLY_SPACE(*scanner->curptr) && skip_ws) {\n\
    +    if (!pj_scan_is_eof(scanner) && \n+\tPJ_SCAN_IS_PROBABLY_SPACE(*scanner->curptr)\
    \ && skip_ws)\n+    {\n \tpj_scan_skip_whitespace(scanner);\n     }\n }"
  - "--- a/pjmedia/src/pjmedia/rtp.c\n+++ b/pjmedia/src/pjmedia/rtp.c\n@@ -188,6 +188,11\
    \ @@ PJ_DEF(pj_status_t) pjmedia_rtp_decode_rtp2(\n     /* Payload is located\
    \ right after header plus CSRC */\n     offset = sizeof(pjmedia_rtp_hdr) + ((*hdr)->cc\
    \ * sizeof(pj_uint32_t));\n \n+    /* Check that offset is less than packet size\
    \ */\n+    if (offset >= pkt_len) {\n+        return PJMEDIA_RTP_EINLEN;\n+  \
    \  }\n+\n     /* Decode RTP extension. */\n     if ((*hdr)->x) {\n         if\
    \ (offset + sizeof (pjmedia_rtp_ext_hdr) > (unsigned)pkt_len)\n@@ -202,8 +207,8\
    \ @@ PJ_DEF(pj_status_t) pjmedia_rtp_decode_rtp2(\n \tdec_hdr->ext_len = 0;\n\
    \     }\n \n-    /* Check that offset is less than packet size */\n-    if (offset\
    \ > pkt_len)\n+    /* Check again that offset is still less than packet size */\n\
    +    if (offset >= pkt_len)\n \treturn PJMEDIA_RTP_EINLEN;\n \n     /* Find and\
    \ set payload. */"
  - "--- a/pjmedia/src/pjmedia/sdp.c\n+++ b/pjmedia/src/pjmedia/sdp.c\n@@ -983,13\
    \ +983,13 @@ static void parse_version(pj_scanner *scanner,\n     ctx->last_error\
    \ = PJMEDIA_SDP_EINVER;\n \n     /* check equal sign */\n-    if (*(scanner->curptr+1)\
    \ != '=') {\n+    if (scanner->curptr+1 >= scanner->end || *(scanner->curptr+1)\
    \ != '=') {\n \ton_scanner_error(scanner);\n \treturn;\n     }\n \n     /* check\
    \ version is 0 */\n-    if (*(scanner->curptr+2) != '0') {\n+    if (scanner->curptr+2\
    \ >= scanner->end || *(scanner->curptr+2) != '0') {\n \ton_scanner_error(scanner);\n\
    \ \treturn;\n     }\n@@ -1006,7 +1006,7 @@ static void parse_origin(pj_scanner\
    \ *scanner, pjmedia_sdp_session *ses,\n     ctx->last_error = PJMEDIA_SDP_EINORIGIN;\n\
    \ \n     /* check equal sign */\n-    if (*(scanner->curptr+1) != '=') {\n+  \
    \  if (scanner->curptr+1 >= scanner->end || *(scanner->curptr+1) != '=') {\n \t\
    on_scanner_error(scanner);\n \treturn;\n     }\n@@ -1052,7 +1052,7 @@ static void\
    \ parse_time(pj_scanner *scanner, pjmedia_sdp_session *ses,\n     ctx->last_error\
    \ = PJMEDIA_SDP_EINTIME;\n \n     /* check equal sign */\n-    if (*(scanner->curptr+1)\
    \ != '=') {\n+    if (scanner->curptr+1 >= scanner->end || *(scanner->curptr+1)\
    \ != '=') {\n \ton_scanner_error(scanner);\n \treturn;\n     }\n@@ -1080,7 +1080,7\
    \ @@ static void parse_generic_line(pj_scanner *scanner, pj_str_t *str,\n    \
    \ ctx->last_error = PJMEDIA_SDP_EINSDP;\n \n     /* check equal sign */\n-   \
    \ if (*(scanner->curptr+1) != '=') {\n+    if ((scanner->curptr+1 >= scanner->end)\
    \ || *(scanner->curptr+1) != '=') {\n \ton_scanner_error(scanner);\n \treturn;\n\
    \     }\n@@ -1149,7 +1149,7 @@ static void parse_media(pj_scanner *scanner, pjmedia_sdp_media\
    \ *med,\n     ctx->last_error = PJMEDIA_SDP_EINMEDIA;\n \n     /* check the equal\
    \ sign */\n-    if (*(scanner->curptr+1) != '=') {\n+    if (scanner->curptr+1\
    \ >= scanner->end || *(scanner->curptr+1) != '=') {\n \ton_scanner_error(scanner);\n\
    \ \treturn;\n     }\n@@ -1164,6 +1164,10 @@ static void parse_media(pj_scanner\
    \ *scanner, pjmedia_sdp_media *med,\n     /* port */\n     pj_scan_get(scanner,\
    \ &cs_token, &str);\n     med->desc.port = (unsigned short)pj_strtoul(&str);\n\
    +    if (pj_scan_is_eof(scanner)) {\n+        on_scanner_error(scanner);\n+  \
    \      return;\n+    }\n     if (*scanner->curptr == '/') {\n \t/* port count\
    \ */\n \tpj_scan_get_char(scanner);\n@@ -1175,15 +1179,15 @@ static void parse_media(pj_scanner\
    \ *scanner, pjmedia_sdp_media *med,\n     }\n \n     if (pj_scan_get_char(scanner)\
    \ != ' ') {\n-\tPJ_THROW(SYNTAX_ERROR);\n+\ton_scanner_error(scanner);\n     }\n\
    \ \n     /* transport */\n     pj_scan_get_until_chr(scanner, \" \\t\\r\\n\",\
    \ &med->desc.transport);\n \n     /* format list */\n     med->desc.fmt_count\
    \ = 0;\n-    while (*scanner->curptr == ' ') {\n+    while (scanner->curptr <\
    \ scanner->end && *scanner->curptr == ' ') {\n \tpj_str_t fmt;\n \n \tpj_scan_get_char(scanner);\n\
    @@ -1223,7 +1227,7 @@ static pjmedia_sdp_attr *parse_attr( pj_pool_t *pool, pj_scanner\
    \ *scanner,\n     attr = PJ_POOL_ALLOC_T(pool, pjmedia_sdp_attr);\n \n     /*\
    \ check equal sign */\n-    if (*(scanner->curptr+1) != '=') {\n+    if (scanner->curptr+1\
    \ >= scanner->end || *(scanner->curptr+1) != '=') {\n \ton_scanner_error(scanner);\n\
    \ \treturn NULL;\n     }\n@@ -1242,7 +1246,7 @@ static pjmedia_sdp_attr *parse_attr(\
    \ pj_pool_t *pool, pj_scanner *scanner,\n \t    pj_scan_get_char(scanner);\n \n\
    \ \t/* get value */\n-\tif (*scanner->curptr != '\\r' && *scanner->curptr != '\\\
    n') {\n+\tif (!pj_scan_is_eof(scanner) && *scanner->curptr != '\\r' && *scanner->curptr\
    \ != '\\n') {\n \t    pj_scan_get_until_chr(scanner, \"\\r\\n\", &attr->value);\n\
    \ \t} else {\n \t    attr->value.ptr = NULL;"
  identifiers:
  - CVE-2022-39244
  - CWE-120
  overview: PJSIP is a free and open source multimedia communication library written
    in C. In versions of PJSIP prior to 2.13 the PJSIP parser, PJMEDIA RTP decoder,
    and PJMEDIA SDP parser are affeced by a buffer overflow vulnerability. Users connecting
    to untrusted clients are at risk. This issue has been patched and is available
    as commit c4d3498 in the master branch and will be included in releases 2.13 and
    later. Users are advised to upgrade. There are no known workarounds for this issue.
  references:
  - source: security-advisories@github.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/pjsip/pjproject/commit/c4d34984ec92b3d5252a7d5cddd85a1d3a8001ae
  - source: security-advisories@github.com
    tags:
    - Third Party Advisory
    url: https://github.com/pjsip/pjproject/security/advisories/GHSA-fq45-m3f7-3mhj
  - source: security-advisories@github.com
    url: https://lists.debian.org/debian-lts-announce/2023/02/msg00029.html
  - source: security-advisories@github.com
    url: https://lists.debian.org/debian-lts-announce/2023/08/msg00038.html
  - source: security-advisories@github.com
    tags:
    - Third Party Advisory
    url: https://security.gentoo.org/glsa/202210-37
  - source: security-advisories@github.com
    url: https://www.debian.org/security/2023/dsa-5358
  title: PJSIP is a free and open source multimedia communication library written
    in C. In versions of PJSIP prior to 2.13 the PJSIP parser, PJMEDIA RTP decoder,
    and PJMEDIA SDP parser are affeced by a buffer overflow vulnerability. Users connecting
    to untrusted clients are at risk. This issue has been patched and is available
    as commit c4d3498 in the master branch and will be included in releases 2.13 and
    later. Users are advised to upgrade. There are no known workarounds for this issue.
- diff_content:
  - "--- a/src/mac/LoRaMac.c\n+++ b/src/mac/LoRaMac.c\n@@ -938,6 +938,14 @@ static\
    \ void ProcessRadioRxDone( void )\n         }\r\n     }\r\n \r\n+    // Abort\
    \ on empty radio frames\r\n+    if( size == 0 )\r\n+    {\r\n+        MacCtx.McpsIndication.Status\
    \ = LORAMAC_EVENT_INFO_STATUS_ERROR;\r\n+        PrepareRxDoneAbort( );\r\n+ \
    \       return;\r\n+    }\r\n+\r\n     macHdr.Value = payload[pktHeaderLen++];\r\
    \n \r\n     // Accept frames of LoRaWAN Major Version 1 only\r"
  identifiers:
  - CVE-2022-39274
  - CWE-193
  overview: LoRaMac-node is a reference implementation and documentation of a LoRa
    network node. Versions of LoRaMac-node prior to 4.7.0 are vulnerable to a buffer
    overflow. Improper size validation of the incoming radio frames can lead to an
    65280-byte out-of-bounds write. The function `ProcessRadioRxDone` implicitly expects
    incoming radio frames to have at least a payload of one byte or more. An empty
    payload leads to a 1-byte out-of-bounds read of user controlled content when the
    payload buffer is reused. This allows an attacker to craft a FRAME_TYPE_PROPRIETARY
    frame with size -1 which results in an 65280-byte out-of-bounds memcopy likely
    with partially controlled attacker data. Corrupting a large part if the data section
    is likely to cause a DoS. If the large out-of-bounds write does not immediately
    crash the attacker may gain control over the execution due to now controlling
    large parts of the data section. Users are advised to upgrade either by updating
    their package or by manually applying the patch commit `e851b079`.
  references:
  - source: security-advisories@github.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/Lora-net/LoRaMac-node/commit/e851b079c82ba1bcf3f4d291ab69a571b0bf458a
  - source: security-advisories@github.com
    tags:
    - Broken Link
    - Third Party Advisory
    url: https://github.com/Lora-net/LoRaMac-node/releases/tag/v4.7.0
  - source: security-advisories@github.com
    tags:
    - Exploit
    - Third Party Advisory
    url: https://github.com/Lora-net/LoRaMac-node/security/advisories/GHSA-7vv8-73pc-63c2
  title: LoRaMac-node is a reference implementation and documentation of a LoRa network
    node. Versions of LoRaMac-node prior to 4.7.0 are vulnerable to a buffer overflow.
    Improper size validation of the incoming radio frames can lead to an 65280-byte
    out-of-bounds write. The function `ProcessRadioRxDone` implicitly expects incoming
    radio frames to have at least a payload of one byte or more. An empty payload
    leads to a 1-byte out-of-bounds read of user controlled content when the payload
    buffer is reused. This allows an attacker to craft a FRAME_TYPE_PROPRIETARY frame
    with size -1 which results in an 65280-byte out-of-bounds memcopy likely with
    partially controlled attacker data. Corrupting a large part if the data section
    is likely to cause a DoS. If the large out-of-bounds write does not immediately
    crash the attacker may gain control over the execution due to now controlling
    large parts of the data section. Users are advised to upgrade either by updating
    their package or by manually applying the patch commit `e851b079`.
- diff_content:
  - "--- a/mm/rmap.c\n+++ b/mm/rmap.c\n@@ -93,7 +93,8 @@ static inline struct anon_vma\
    \ *anon_vma_alloc(void)\n \tanon_vma = kmem_cache_alloc(anon_vma_cachep, GFP_KERNEL);\n\
    \ \tif (anon_vma) {\n \t\tatomic_set(&anon_vma->refcount, 1);\n-\t\tanon_vma->degree\
    \ = 1;\t/* Reference for first vma */\n+\t\tanon_vma->num_children = 0;\n+\t\t\
    anon_vma->num_active_vmas = 0;\n \t\tanon_vma->parent = anon_vma;\n \t\t/*\n \t\
    \t * Initialise the anon_vma root to point to itself. If called\n@@ -201,6 +202,7\
    \ @@ int __anon_vma_prepare(struct vm_area_struct *vma)\n \t\tanon_vma = anon_vma_alloc();\n\
    \ \t\tif (unlikely(!anon_vma))\n \t\t\tgoto out_enomem_free_avc;\n+\t\tanon_vma->num_children++;\
    \ /* self-parent link for new root */\n \t\tallocated = anon_vma;\n \t}\n \n@@\
    \ -210,8 +212,7 @@ int __anon_vma_prepare(struct vm_area_struct *vma)\n \tif (likely(!vma->anon_vma))\
    \ {\n \t\tvma->anon_vma = anon_vma;\n \t\tanon_vma_chain_link(vma, avc, anon_vma);\n\
    -\t\t/* vma reference or self-parent link for new root */\n-\t\tanon_vma->degree++;\n\
    +\t\tanon_vma->num_active_vmas++;\n \t\tallocated = NULL;\n \t\tavc = NULL;\n\
    \ \t}\n@@ -296,19 +297,19 @@ int anon_vma_clone(struct vm_area_struct *dst, struct\
    \ vm_area_struct *src)\n \t\tanon_vma_chain_link(dst, avc, anon_vma);\n \n \t\t\
    /*\n-\t\t * Reuse existing anon_vma if its degree lower than two,\n-\t\t * that\
    \ means it has no vma and only one anon_vma child.\n+\t\t * Reuse existing anon_vma\
    \ if it has no vma and only one\n+\t\t * anon_vma child.\n \t\t *\n-\t\t * Do\
    \ not choose parent anon_vma, otherwise first child\n-\t\t * will always reuse\
    \ it. Root anon_vma is never reused:\n+\t\t * Root anon_vma is never reused:\n\
    \ \t\t * it has self-parent reference and at least one child.\n \t\t */\n \t\t\
    if (!dst->anon_vma && src->anon_vma &&\n-\t\t    anon_vma != src->anon_vma &&\
    \ anon_vma->degree < 2)\n+\t\t    anon_vma->num_children < 2 &&\n+\t\t    anon_vma->num_active_vmas\
    \ == 0)\n \t\t\tdst->anon_vma = anon_vma;\n \t}\n \tif (dst->anon_vma)\n-\t\t\
    dst->anon_vma->degree++;\n+\t\tdst->anon_vma->num_active_vmas++;\n \tunlock_anon_vma_root(root);\n\
    \ \treturn 0;\n \n@@ -358,6 +359,7 @@ int anon_vma_fork(struct vm_area_struct\
    \ *vma, struct vm_area_struct *pvma)\n \tanon_vma = anon_vma_alloc();\n \tif (!anon_vma)\n\
    \ \t\tgoto out_error;\n+\tanon_vma->num_active_vmas++;\n \tavc = anon_vma_chain_alloc(GFP_KERNEL);\n\
    \ \tif (!avc)\n \t\tgoto out_error_free_anon_vma;\n@@ -378,7 +380,7 @@ int anon_vma_fork(struct\
    \ vm_area_struct *vma, struct vm_area_struct *pvma)\n \tvma->anon_vma = anon_vma;\n\
    \ \tanon_vma_lock_write(anon_vma);\n \tanon_vma_chain_link(vma, avc, anon_vma);\n\
    -\tanon_vma->parent->degree++;\n+\tanon_vma->parent->num_children++;\n \tanon_vma_unlock_write(anon_vma);\n\
    \ \n \treturn 0;\n@@ -410,15 +412,15 @@ void unlink_anon_vmas(struct vm_area_struct\
    \ *vma)\n \t\t * to free them outside the lock.\n \t\t */\n \t\tif (RB_EMPTY_ROOT(&anon_vma->rb_root.rb_root))\
    \ {\n-\t\t\tanon_vma->parent->degree--;\n+\t\t\tanon_vma->parent->num_children--;\n\
    \ \t\t\tcontinue;\n \t\t}\n \n \t\tlist_del(&avc->same_vma);\n \t\tanon_vma_chain_free(avc);\n\
    \ \t}\n \tif (vma->anon_vma) {\n-\t\tvma->anon_vma->degree--;\n+\t\tvma->anon_vma->num_active_vmas--;\n\
    \ \n \t\t/*\n \t\t * vma would still be needed after unlink, and anon_vma will\
    \ be prepared\n@@ -436,7 +438,8 @@ void unlink_anon_vmas(struct vm_area_struct\
    \ *vma)\n \tlist_for_each_entry_safe(avc, next, &vma->anon_vma_chain, same_vma)\
    \ {\n \t\tstruct anon_vma *anon_vma = avc->anon_vma;\n \n-\t\tVM_WARN_ON(anon_vma->degree);\n\
    +\t\tVM_WARN_ON(anon_vma->num_children);\n+\t\tVM_WARN_ON(anon_vma->num_active_vmas);\n\
    \ \t\tput_anon_vma(anon_vma);\n \n \t\tlist_del(&avc->same_vma);"
  identifiers:
  - CVE-2022-42703
  - CWE-416
  overview: mm/rmap.c in the Linux kernel before 5.19.7 has a use-after-free related
    to leaf anon_vma double reuse.
  references:
  - source: cve@mitre.org
    tags:
    - Exploit
    - Mailing List
    - Third Party Advisory
    url: https://bugs.chromium.org/p/project-zero/issues/detail?id=2351
  - source: cve@mitre.org
    tags:
    - Mailing List
    - Patch
    - Vendor Advisory
    url: https://cdn.kernel.org/pub/linux/kernel/v5.x/ChangeLog-5.19.7
  - source: cve@mitre.org
    tags:
    - Mailing List
    - Patch
    - Vendor Advisory
    url: https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=2555283eb40df89945557273121e9393ef9b542b
  - source: cve@mitre.org
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/torvalds/linux/commit/2555283eb40df89945557273121e9393ef9b542b
  - source: cve@mitre.org
    tags:
    - Exploit
    - Technical Description
    - Third Party Advisory
    url: https://googleprojectzero.blogspot.com/2022/12/exploiting-CVE-2022-42703-bringing-back-the-stack-attack.html
  title: mm/rmap.c in the Linux kernel before 5.19.7 has a use-after-free related
    to leaf anon_vma double reuse.
- diff_content:
  - "--- a/external/llvh/lib/Support/SmallVector.cpp\n+++ b/external/llvh/lib/Support/SmallVector.cpp\n\
    @@ -42,13 +42,16 @@ static_assert(sizeof(SmallVector<void *, 1>) ==\n /// on POD-like\
    \ datatypes and is out of line to reduce code duplication.\n void SmallVectorBase::grow_pod(void\
    \ *FirstEl, size_t MinCapacity,\n                                size_t TSize)\
    \ {\n-  // Ensure we can fit the new capacity in 32 bits.\n-  if (MinCapacity\
    \ > UINT32_MAX)\n-    report_bad_alloc_error(\"SmallVector capacity overflow during\
    \ allocation\");\n+  constexpr size_t MinGrowth = 1;\n+  size_t NewCapacity =\
    \ 2 * capacity() + MinGrowth; // Always grow.\n+  NewCapacity = static_cast<unsigned>(std::max(NewCapacity,\
    \ MinCapacity));\n \n-  size_t NewCapacity = 2 * capacity() + 1; // Always grow.\n\
    -  NewCapacity =\n-      std::min(std::max(NewCapacity, MinCapacity), size_t(UINT32_MAX));\n\
    +  // Ensure that NewCapacity did not overflow an unsigned int,\n+  // and that\
    \ the capacity in bytes will not overflow a size_t.\n+  if (NewCapacity <= this->capacity()\
    \ ||\n+      NewCapacity < MinCapacity ||\n+      NewCapacity > size_t(-1) / TSize)\n\
    +    report_bad_alloc_error(\"SmallVector capacity overflow during allocation\"\
    );\n \n   void *NewElts;\n   if (BeginX == FirstEl) {"
  identifiers:
  - CVE-2022-32234
  - CWE-787
  overview: An out of bounds write in hermes, while handling large arrays, prior to
    commit 06eaec767e376bfdb883d912cb15e987ddf2bda1 allows attackers to potentially
    execute arbitrary code via crafted JavaScript. Note that this is only exploitable
    if the application using Hermes permits evaluation of untrusted JavaScript. Hence,
    most React Native applications are not affected.
  references:
  - source: cve-assign@fb.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/facebook/hermes/commit/06eaec767e376bfdb883d912cb15e987ddf2bda1
  - source: cve-assign@fb.com
    tags:
    - Vendor Advisory
    url: https://www.facebook.com/security/advisories/CVE-2022-32234
  title: An out of bounds write in hermes, while handling large arrays, prior to commit
    06eaec767e376bfdb883d912cb15e987ddf2bda1 allows attackers to potentially execute
    arbitrary code via crafted JavaScript. Note that this is only exploitable if the
    application using Hermes permits evaluation of untrusted JavaScript. Hence, most
    React Native applications are not affected.
- diff_content:
  - "--- a/lib/VM/detail/IdentifierHashTable.cpp\n+++ b/lib/VM/detail/IdentifierHashTable.cpp\n\
    @@ -138,6 +138,10 @@ void IdentifierHashTable::remove(const StringPrimitive *str)\
    \ {\n }\n \n void IdentifierHashTable::growAndRehash(uint32_t newCapacity) {\n\
    +  // Guard against potential overflow in the calculation of new capacity.\n+\
    \  if (LLVM_UNLIKELY(newCapacity <= capacity())) {\n+    hermes_fatal(\"too many\
    \ identifiers created\");\n+  }\n   assert(llvh::isPowerOf2_32(newCapacity) &&\
    \ \"capacity must be power of 2\");\n   CompactTable tmpTable(newCapacity, table_.getCurrentScale());\n\
    \   tmpTable.swap(table_);"
  identifiers:
  - CVE-2022-35289
  - CWE-190
  overview: A write-what-where condition in hermes caused by an integer overflow,
    prior to commit 5b6255ae049fa4641791e47fad994e8e8c4da374 allows attackers to potentially
    execute arbitrary code via crafted JavaScript. Note that this is only exploitable
    if the application using Hermes permits evaluation of untrusted JavaScript. Hence,
    most React Native applications are not affected.
  references:
  - source: cve-assign@fb.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/facebook/hermes/commit/5b6255ae049fa4641791e47fad994e8e8c4da374
  - source: cve-assign@fb.com
    tags:
    - Vendor Advisory
    url: https://www.facebook.com/security/advisories/CVE-2022-35289
  title: A write-what-where condition in hermes caused by an integer overflow, prior
    to commit 5b6255ae049fa4641791e47fad994e8e8c4da374 allows attackers to potentially
    execute arbitrary code via crafted JavaScript. Note that this is only exploitable
    if the application using Hermes permits evaluation of untrusted JavaScript. Hence,
    most React Native applications are not affected.
- diff_content:
  - "--- a/lib/BCGen/HBC/BytecodeGenerator.cpp\n+++ b/lib/BCGen/HBC/BytecodeGenerator.cpp\n\
    @@ -217,6 +217,8 @@ void BytecodeModuleGenerator::setFunctionGenerator(\n   assert(\n\
    \       functionGenerators_.find(F) == functionGenerators_.end() &&\n       \"\
    Adding same function twice.\");\n+  assert(\n+      !BFG->hasEncodingError() &&\
    \ \"Error should have been reported already.\");\n   functionGenerators_[F] =\
    \ std::move(BFG);\n }\n "
  - "--- a/lib/BCGen/HBC/BytecodeProviderFromSrc.cpp\n+++ b/lib/BCGen/HBC/BytecodeProviderFromSrc.cpp\n\
    @@ -236,8 +236,11 @@ BCProviderFromSrc::createBCProviderFromSrcImpl(\n   opts.staticBuiltinsEnabled\
    \ =\n       context->getOptimizationSettings().staticBuiltins;\n   opts.verifyIR\
    \ = compileFlags.verifyIR;\n-  auto bytecode = createBCProviderFromSrc(\n-   \
    \   hbc::generateBytecodeModule(&M, M.getTopLevelFunction(), opts));\n+  auto\
    \ BM = hbc::generateBytecodeModule(&M, M.getTopLevelFunction(), opts);\n+  if\
    \ (context->getSourceErrorManager().getErrorCount() > 0) {\n+    return {nullptr,\
    \ getErrorString()};\n+  }\n+  auto bytecode = createBCProviderFromSrc(std::move(BM));\n\
    \   bytecode->singleFunction_ = isSingleFunctionExpression(parsed.getValue());\n\
    \   return {std::move(bytecode), std::string{}};\n }"
  - "--- a/lib/BCGen/HBC/HBC.cpp\n+++ b/lib/BCGen/HBC/HBC.cpp\n@@ -313,6 +313,11 @@\
    \ std::unique_ptr<BytecodeModule> hbc::generateBytecodeModule(\n       debugCache\
    \ = hbciSel.getDebugCache();\n     }\n \n+    if (funcGen->hasEncodingError())\
    \ {\n+      M->getContext().getSourceErrorManager().error(\n+          F.getSourceRange().Start,\
    \ \"Error encoding bytecode\");\n+      return nullptr;\n+    }\n     BMGen.setFunctionGenerator(&F,\
    \ std::move(funcGen));\n   }\n \n@@ -335,6 +340,10 @@ std::unique_ptr<BytecodeModule>\
    \ hbc::generateBytecode(\n       sourceMapGen,\n       std::move(baseBCProvider));\n\
    \ \n+  if (!BM) {\n+    return {};\n+  }\n+\n   if (options.format == OutputFormatKind::EmitBundle)\
    \ {\n     assert(BM != nullptr);\n     BytecodeSerializer BS{OS, options};"
  - "--- a/lib/BCGen/HBC/ISel.cpp\n+++ b/lib/BCGen/HBC/ISel.cpp\n@@ -1337,6 +1337,10\
    \ @@ void HBCISel::generateHBCResolveEnvironment(\n       \"Cannot access variables\
    \ in inner scopes\");\n   int32_t delta = curScopeDepth.getValue() - instScopeDepth.getValue();\n\
    \   assert(delta > 0 && \"HBCResolveEnvironment for current scope\");\n+  if (std::numeric_limits<uint8_t>::max()\
    \ < delta) {\n+    F_->getContext().getSourceErrorManager().error(\n+        Inst->getLocation(),\
    \ \"Variable environment is out-of-reach\");\n+  }\n   BCFGen_->emitGetEnvironment(encodeValue(Inst),\
    \ delta - 1);\n }\n void HBCISel::generateHBCStoreToEnvironmentInst("
  - "--- a/lib/CompilerDriver/CompilerDriver.cpp\n+++ b/lib/CompilerDriver/CompilerDriver.cpp\n\
    @@ -1694,9 +1694,15 @@ CompileResult generateBytecodeForExecution(\n   std::shared_ptr<Context>\
    \ context = M.shareContext();\n   CompileResult result{Success};\n   if (cl::BytecodeFormat\
    \ == cl::BytecodeFormatKind::HBC) {\n-    result.bytecodeProvider = hbc::BCProviderFromSrc::createBCProviderFromSrc(\n\
    -        hbc::generateBytecodeModule(&M, M.getTopLevelFunction(), genOptions));\n\
    +    auto BM =\n+        hbc::generateBytecodeModule(&M, M.getTopLevelFunction(),\
    \ genOptions);\n+    if (auto N = context->getSourceErrorManager().getErrorCount())\
    \ {\n+      llvh::errs() << \"Emitted \" << N << \" errors in the backend. exiting.\\\
    n\";\n+      return BackendError;\n+    }\n \n+    result.bytecodeProvider =\n\
    +        hbc::BCProviderFromSrc::createBCProviderFromSrc(std::move(BM));\n   }\
    \ else {\n     llvm_unreachable(\"Invalid bytecode kind for execution\");\n  \
    \   result = InvalidFlags;\n@@ -1735,6 +1741,11 @@ CompileResult generateBytecodeForSerialization(\n\
    \         sourceMapGenOrNull,\n         std::move(baseBCProvider));\n \n+    if\
    \ (auto N = M.getContext().getSourceErrorManager().getErrorCount()) {\n+     \
    \ llvh::errs() << \"Emitted \" << N << \" errors in the backend. exiting.\\n\"\
    ;\n+      return BackendError;\n+    }\n+\n     if (cl::DumpTarget == DumpBytecode)\
    \ {\n       disassembleBytecode(hbc::BCProviderFromSrc::createBCProviderFromSrc(\n\
    \           std::move(bytecodeModule)));"
  - "--- a/lib/VM/Callable.cpp\n+++ b/lib/VM/Callable.cpp\n@@ -1395,7 +1395,11 @@\
    \ CallResult<PseudoHandle<>> GeneratorInnerFunction::callInnerFunction(\n   //\
    \ Note that this will do nothing after the very first time a lazy function\n \
    \  // is called, so we only resize before we save any registers at all.\n   if\
    \ (LLVM_UNLIKELY(selfHandle->getCodeBlock(runtime)->isLazy())) {\n-    selfHandle->getCodeBlock(runtime)->lazyCompile(runtime);\n\
    +    if (LLVM_UNLIKELY(\n+            selfHandle->getCodeBlock(runtime)->lazyCompile(runtime)\
    \ ==\n+            ExecutionStatus::EXCEPTION)) {\n+      return ExecutionStatus::EXCEPTION;\n\
    +    }\n     if (LLVM_UNLIKELY(\n             ArrayStorage::resize(\n        \
    \         ctx,"
  - "--- a/lib/VM/CodeBlock.cpp\n+++ b/lib/VM/CodeBlock.cpp\n@@ -14,6 +14,7 @@\n #include\
    \ \"hermes/IRGen/IRGen.h\"\n #include \"hermes/Support/Conversions.h\"\n #include\
    \ \"hermes/Support/PerfSection.h\"\n+#include \"hermes/Support/SimpleDiagHandler.h\"\
    \n #include \"hermes/VM/GCPointer-inline.h\"\n #include \"hermes/VM/Runtime.h\"\
    \n #include \"hermes/VM/RuntimeModule.h\"\n@@ -330,14 +331,24 @@ std::unique_ptr<hbc::BytecodeModule>\
    \ compileLazyFunction(\n }\n } // namespace\n \n-void CodeBlock::lazyCompileImpl(Runtime\
    \ &runtime) {\n+ExecutionStatus CodeBlock::lazyCompileImpl(Runtime &runtime) {\n\
    \   assert(isLazy() && \"Laziness has not been checked\");\n   PerfSection perf(\"\
    Lazy function compilation\");\n   auto *provider = (hbc::BCProviderLazy *)runtimeModule_->getBytecode();\n\
    \   auto *func = provider->getBytecodeFunction();\n   auto *lazyData = func->getLazyCompilationData();\n\
    +  SourceErrorManager &manager = lazyData->context->getSourceErrorManager();\n\
    +  SimpleDiagHandlerRAII outputManager{manager};\n   auto bcModule = compileLazyFunction(lazyData);\n\
    \ \n+  if (manager.getErrorCount()) {\n+    // Raise a SyntaxError to be consistent\
    \ with eval().\n+    return runtime.raiseSyntaxError(\n+        llvh::StringRef{outputManager.getErrorString()});\n\
    +  }\n+\n+  assert(bcModule && \"No errors, yet no bcModule\");\n+\n   runtimeModule_->initializeLazyMayAllocate(\n\
    \       hbc::BCProviderFromSrc::createBCProviderFromSrc(std::move(bcModule)));\n\
    \   // Reset all meta lazyData of the CodeBlock to point to the newly\n@@ -346,6\
    \ +357,8 @@ void CodeBlock::lazyCompileImpl(Runtime &runtime) {\n   functionHeader_\
    \ =\n       runtimeModule_->getBytecode()->getFunctionHeader(functionID_);\n \
    \  bytecode_ = runtimeModule_->getBytecode()->getBytecode(functionID_);\n+\n+\
    \  return ExecutionStatus::RETURNED;\n }\n #endif // HERMESVM_LEAN\n "
  - "--- a/lib/VM/Debugger/Debugger.cpp\n+++ b/lib/VM/Debugger/Debugger.cpp\n@@ -1147,7\
    \ +1147,12 @@ bool Debugger::resolveBreakpointLocation(Breakpoint &breakpoint)\
    \ const {\n            (start.col <= request.column && request.column <= end.col)))\
    \ {\n         // The code block probably contains the breakpoint we want to set.\n\
    \         // First, we compile it.\n-        codeBlock->lazyCompile(runtime_);\n\
    +        if (LLVM_UNLIKELY(\n+                codeBlock->lazyCompile(runtime_)\
    \ ==\n+                ExecutionStatus::EXCEPTION)) {\n+          // TODO: how\
    \ to better handle this?\n+          runtime_.clearThrownValue();\n+        }\n\
    \ \n         // We've found the codeBlock at this level and expanded it,\n   \
    \      // so there's no point continuing the search."
  - "--- a/lib/VM/Interpreter.cpp\n+++ b/lib/VM/Interpreter.cpp\n@@ -785,7 +785,10\
    \ @@ static inline const Inst *nextInstCall(const Inst *ip) {\n \n CallResult<HermesValue>\
    \ Runtime::interpretFunctionImpl(\n     CodeBlock *newCodeBlock) {\n-  newCodeBlock->lazyCompile(*this);\n\
    +  if (LLVM_UNLIKELY(\n+          newCodeBlock->lazyCompile(*this) == ExecutionStatus::EXCEPTION))\
    \ {\n+    return ExecutionStatus::EXCEPTION;\n+  }\n \n #if defined(HERMES_MEMORY_INSTRUMENTATION)\
    \ || !defined(NDEBUG)\n   // We always call getCurrentIP() in a debug build as\
    \ this has the effect\n@@ -1584,7 +1587,10 @@ CallResult<HermesValue> Interpreter::interpretFunction(\n\
    \ #endif\n \n         CodeBlock *calleeBlock = func->getCodeBlock(runtime);\n\
    -        CAPTURE_IP(calleeBlock->lazyCompile(runtime));\n+        CAPTURE_IP_ASSIGN(auto\
    \ res, calleeBlock->lazyCompile(runtime));\n+        if (LLVM_UNLIKELY(res ==\
    \ ExecutionStatus::EXCEPTION)) {\n+          goto exception;\n+        }\n   \
    \      curCodeBlock = calleeBlock;\n         CAPTURE_IP_SET();\n         goto\
    \ tailCall;\n@@ -1637,7 +1643,10 @@ CallResult<HermesValue> Interpreter::interpretFunction(\n\
    \ \n         assert(!SingleStep && \"can't single-step a call\");\n \n-      \
    \  CAPTURE_IP(calleeBlock->lazyCompile(runtime));\n+        CAPTURE_IP_ASSIGN(auto\
    \ res, calleeBlock->lazyCompile(runtime));\n+        if (LLVM_UNLIKELY(res ==\
    \ ExecutionStatus::EXCEPTION)) {\n+          goto exception;\n+        }\n   \
    \      curCodeBlock = calleeBlock;\n         CAPTURE_IP_SET();\n         goto\
    \ tailCall;"
  - "--- a/lib/VM/Operations.cpp\n+++ b/lib/VM/Operations.cpp\n@@ -1679,7 +1679,9\
    \ @@ CallResult<bool> isConstructor(Runtime &runtime, Callable *callable) {\n\
    \     auto *cb = func->getCodeBlock(runtime);\n     // Even though it doesn't\
    \ make sense logically, we need to compile the\n     // function in order to access\
    \ it flags.\n-    cb->lazyCompile(runtime);\n+    if (LLVM_UNLIKELY(cb->lazyCompile(runtime)\
    \ == ExecutionStatus::EXCEPTION)) {\n+      return ExecutionStatus::EXCEPTION;\n\
    +    }\n     return !func->getCodeBlock(runtime)->getHeaderFlags().isCallProhibited(\n\
    \         true);\n   }"
  identifiers:
  - CVE-2022-40138
  - CWE-681
  overview: An integer conversion error in Hermes bytecode generation, prior to commit
    6aa825e480d48127b480b08d13adf70033237097, could have been used to perform Out-Of-Bounds
    operations and subsequently execute arbitrary code. Note that this is only exploitable
    in cases where Hermes is used to execute untrusted JavaScript. Hence, most React
    Native applications are not affected.
  references:
  - source: cve-assign@fb.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/facebook/hermes/commit/6aa825e480d48127b480b08d13adf70033237097
  - source: cve-assign@fb.com
    tags:
    - Vendor Advisory
    url: https://www.facebook.com/security/advisories/CVE-2022-40138
  title: An integer conversion error in Hermes bytecode generation, prior to commit
    6aa825e480d48127b480b08d13adf70033237097, could have been used to perform Out-Of-Bounds
    operations and subsequently execute arbitrary code. Note that this is only exploitable
    in cases where Hermes is used to execute untrusted JavaScript. Hence, most React
    Native applications are not affected.
- diff_content:
  - "--- a/contrib/shpsort.c\n+++ b/contrib/shpsort.c\n@@ -113,7 +113,6 @@ static\
    \ char ** split(const char *arg, const char *delim) {\n \tfree(result[--i]);\n\
    \       }\n       free(result);\n-      free(copy);\n       return NULL;\n   \
    \  }\n     result = tmp;"
  identifiers:
  - CVE-2022-0699
  - CWE-415
  overview: A double-free condition exists in contrib/shpsort.c of shapelib 1.5.0
    and older releases. This issue may allow an attacker to cause a denial of service
    or have other unspecified impact via control over malloc.
  references:
  - source: patrick@puiterwijk.org
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/OSGeo/shapelib/commit/c75b9281a5b9452d92e1682bdfe6019a13ed819f
  - source: patrick@puiterwijk.org
    tags:
    - Exploit
    - Issue Tracking
    - Third Party Advisory
    url: https://github.com/OSGeo/shapelib/issues/39
  title: A double-free condition exists in contrib/shpsort.c of shapelib 1.5.0 and
    older releases. This issue may allow an attacker to cause a denial of service
    or have other unspecified impact via control over malloc.
- diff_content:
  - "--- a/ui/vnc.c\n+++ b/ui/vnc.c\n@@ -2456,8 +2456,13 @@ static int protocol_client_msg(VncState\
    \ *vs, uint8_t *data, size_t len)\n         }\n \n         if (read_s32(data,\
    \ 4) < 0) {\n-            vnc_client_cut_text_ext(vs, abs(read_s32(data, 4)),\n\
    -                                    read_u32(data, 8), data + 12);\n+       \
    \     if (dlen < 4) {\n+                error_report(\"vnc: malformed payload\
    \ (header less than 4 bytes)\"\n+                             \" in extended clipboard\
    \ pseudo-encoding.\");\n+                vnc_client_error(vs);\n+            \
    \    break;\n+            }\n+            vnc_client_cut_text_ext(vs, dlen, read_u32(data,\
    \ 8), data + 12);\n             break;\n         }\n         vnc_client_cut_text(vs,\
    \ read_u32(data, 4), data + 8);\n"
  identifiers:
  - CVE-2022-3165
  - CWE-191
  overview: An integer underflow issue was found in the QEMU VNC server while processing
    ClientCutText messages in the extended format. A malicious client could use this
    flaw to make QEMU unresponsive by sending a specially crafted payload message,
    resulting in a denial of service.
  references:
  - source: secalert@redhat.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://gitlab.com/qemu-project/qemu/-/commit/d307040b18
  - source: secalert@redhat.com
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/I36LKZA7Z65J3LJU2P37LVTWDFTXBMPU/
  - source: secalert@redhat.com
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/ZTY7TVHX62OJWF6IOBCIGLR2N5K4QN3E/
  - source: secalert@redhat.com
    tags:
    - Third Party Advisory
    url: https://security.netapp.com/advisory/ntap-20221223-0006/
  title: An integer underflow issue was found in the QEMU VNC server while processing
    ClientCutText messages in the extended format. A malicious client could use this
    flaw to make QEMU unresponsive by sending a specially crafted payload message,
    resulting in a denial of service.
- diff_content:
  - "--- a/net/sched/sch_sfb.c\n+++ b/net/sched/sch_sfb.c\n@@ -135,15 +135,15 @@ static\
    \ void increment_one_qlen(u32 sfbhash, u32 slot, struct sfb_sched_data *q)\n \t\
    }\n }\n \n-static void increment_qlen(const struct sk_buff *skb, struct sfb_sched_data\
    \ *q)\n+static void increment_qlen(const struct sfb_skb_cb *cb, struct sfb_sched_data\
    \ *q)\n {\n \tu32 sfbhash;\n \n-\tsfbhash = sfb_hash(skb, 0);\n+\tsfbhash = cb->hashes[0];\n\
    \ \tif (sfbhash)\n \t\tincrement_one_qlen(sfbhash, 0, q);\n \n-\tsfbhash = sfb_hash(skb,\
    \ 1);\n+\tsfbhash = cb->hashes[1];\n \tif (sfbhash)\n \t\tincrement_one_qlen(sfbhash,\
    \ 1, q);\n }\n@@ -283,6 +283,7 @@ static int sfb_enqueue(struct sk_buff *skb,\
    \ struct Qdisc *sch,\n \tstruct sfb_sched_data *q = qdisc_priv(sch);\n \tstruct\
    \ Qdisc *child = q->qdisc;\n \tstruct tcf_proto *fl;\n+\tstruct sfb_skb_cb cb;\n\
    \ \tint i;\n \tu32 p_min = ~0;\n \tu32 minqlen = ~0;\n@@ -399,11 +400,12 @@ static\
    \ int sfb_enqueue(struct sk_buff *skb, struct Qdisc *sch,\n \t}\n \n enqueue:\n\
    +\tmemcpy(&cb, sfb_skb_cb(skb), sizeof(cb));\n \tret = qdisc_enqueue(skb, child,\
    \ to_free);\n \tif (likely(ret == NET_XMIT_SUCCESS)) {\n \t\tqdisc_qstats_backlog_inc(sch,\
    \ skb);\n \t\tsch->q.qlen++;\n-\t\tincrement_qlen(skb, q);\n+\t\tincrement_qlen(&cb,\
    \ q);\n \t} else if (net_xmit_drop_count(ret)) {\n \t\tq->stats.childdrop++;\n\
    \ \t\tqdisc_qstats_drop(sch);"
  identifiers:
  - CVE-2022-3586
  - CWE-416
  overview: "A flaw was found in the Linux kernel\u2019s networking code. A use-after-free\
    \ was found in the way the sch_sfb enqueue function used the socket buffer (SKB)\
    \ cb field after the same SKB had been enqueued (and freed) into a child qdisc.\
    \ This flaw allows a local, unprivileged user to crash the system, causing a denial\
    \ of service."
  references:
  - source: secalert@redhat.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/torvalds/linux/commit/9efd23297cca
  - source: secalert@redhat.com
    tags:
    - Mailing List
    - Third Party Advisory
    url: https://lists.debian.org/debian-lts-announce/2022/11/msg00001.html
  - source: secalert@redhat.com
    tags:
    - Third Party Advisory
    - VDB Entry
    url: https://www.zerodayinitiative.com/advisories/upcoming/
  title: "A flaw was found in the Linux kernel\u2019s networking code. A use-after-free\
    \ was found in the way the sch_sfb enqueue function used the socket buffer (SKB)\
    \ cb field after the same SKB had been enqueued (and freed) into a child qdisc.\
    \ This flaw allows a local, unprivileged user to crash the system, causing a denial\
    \ of service."
- diff_content:
  - "--- a/tools/tiffcrop.c\n+++ b/tools/tiffcrop.c\n@@ -112,8 +112,8 @@\n  *    \
    \      In no case should the options be applied to a given selection successively.\n\
    \  */\n \n-static   char tiffcrop_version_id[] = \"2.5.1\";\n-static   char tiffcrop_rev_date[]\
    \ = \"15-08-2022\";\n+static   char tiffcrop_version_id[] = \"2.5.2\";\n+static\
    \   char tiffcrop_rev_date[] = \"22-08-2022\";\n \n #include \"tif_config.h\"\n\
    \ #include \"libport.h\"\n@@ -210,6 +210,10 @@ static   char tiffcrop_rev_date[]\
    \ = \"15-08-2022\";\n \n #define TIFF_DIR_MAX  65534\n \n+/* Some conversion subroutines\
    \ require image buffers, which are at least 3 bytes\n+ * larger than the necessary\
    \ size for the image itself. */\n+#define NUM_BUFF_OVERSIZE_BYTES   3\n+\n /*\
    \ Offsets into buffer for margins and fixed width and length segments */\n struct\
    \ offset {\n   uint32_t  tmargin;\n@@ -231,7 +235,7 @@ struct offset {\n  */\n\
    \ \n struct  buffinfo {\n-  uint32_t size;           /* size of this buffer */\n\
    +  uint64_t size;           /* size of this buffer */\n   unsigned char *buffer;\
    \ /* address of the allocated buffer */\n };\n \n@@ -805,8 +809,8 @@ static int\
    \ readContigTilesIntoBuffer (TIFF* in, uint8_t* buf,\n   uint32_t dst_rowsize,\
    \ shift_width;\n   uint32_t bytes_per_sample, bytes_per_pixel;\n   uint32_t trailing_bits,\
    \ prev_trailing_bits;\n-  uint32_t tile_rowsize  = TIFFTileRowSize(in);\n-  uint32_t\
    \ src_offset, dst_offset;\n+  tmsize_t tile_rowsize  = TIFFTileRowSize(in);\n\
    +  tmsize_t src_offset, dst_offset;\n   uint32_t row_offset, col_offset;\n   uint8_t\
    \ *bufp = (uint8_t*) buf;\n   unsigned char *src = NULL;\n@@ -856,7 +860,7 @@\
    \ static int readContigTilesIntoBuffer (TIFF* in, uint8_t* buf,\n       TIFFError(\"\
    readContigTilesIntoBuffer\", \"Integer overflow when calculating buffer size.\"\
    );\n       exit(EXIT_FAILURE);\n   }\n-  tilebuf = limitMalloc(tile_buffsize +\
    \ 3);\n+  tilebuf = limitMalloc(tile_buffsize + NUM_BUFF_OVERSIZE_BYTES);\n  \
    \ if (tilebuf == 0)\n     return 0;\n   tilebuf[tile_buffsize] = 0;\n@@ -1019,7\
    \ +1023,7 @@ static int  readSeparateTilesIntoBuffer (TIFF* in, uint8_t *obuf,\n\
    \   for (sample = 0; (sample < spp) && (sample < MAX_SAMPLES); sample++)\n   \
    \  {\n     srcbuffs[sample] = NULL;\n-    tbuff = (unsigned char *)limitMalloc(tilesize\
    \ + 8);\n+    tbuff = (unsigned char *)limitMalloc(tilesize + NUM_BUFF_OVERSIZE_BYTES);\n\
    \     if (!tbuff)\n       {\n       TIFFError (\"readSeparateTilesIntoBuffer\"\
    , \n@@ -1212,7 +1216,8 @@ writeBufferToSeparateStrips (TIFF* out, uint8_t* buf,\n\
    \   }\n   rowstripsize = rowsperstrip * bytes_per_sample * (width + 1); \n \n\
    -  obuf = limitMalloc (rowstripsize);\n+  /* Add 3 padding bytes for extractContigSamples32bits\
    \ */\n+  obuf = limitMalloc (rowstripsize + NUM_BUFF_OVERSIZE_BYTES);\n   if (obuf\
    \ == NULL)\n     return 1;\n   \n@@ -1224,7 +1229,7 @@ writeBufferToSeparateStrips\
    \ (TIFF* out, uint8_t* buf,\n \n       stripsize = TIFFVStripSize(out, nrows);\n\
    \       src = buf + (row * rowsize);\n-      memset (obuf, '\\0', rowstripsize);\n\
    +      memset (obuf, '\\0',rowstripsize + NUM_BUFF_OVERSIZE_BYTES);\n       if\
    \ (extractContigSamplesToBuffer(obuf, src, nrows, width, s, spp, bps, dump))\n\
    \         {\n         _TIFFfree(obuf);\n@@ -1232,10 +1237,15 @@ writeBufferToSeparateStrips\
    \ (TIFF* out, uint8_t* buf,\n \t}\n       if ((dump->outfile != NULL) && (dump->level\
    \ == 1))\n         {\n-        dump_info(dump->outfile, dump->format,\"\", \n\
    +          if (scanlinesize > 0x0ffffffffULL) {\n+              dump_info(dump->infile,\
    \ dump->format, \"loadImage\",\n+                  \"Attention: scanlinesize %\"\
    PRIu64\" is larger than UINT32_MAX.\\nFollowing dump might be wrong.\",\n+   \
    \               scanlinesize);\n+          }\n+          dump_info(dump->outfile,\
    \ dump->format,\"\",\n                   \"Sample %2d, Strip: %2d, bytes: %4d,\
    \ Row %4d, bytes: %4d, Input offset: %6d\", \n-                  s + 1, strip\
    \ + 1, stripsize, row + 1, scanlinesize, src - buf);\n-        dump_buffer(dump->outfile,\
    \ dump->format, nrows, scanlinesize, row, obuf);\n+                  s + 1, strip\
    \ + 1, stripsize, row + 1, (uint32_t)scanlinesize, src - buf);\n+        dump_buffer(dump->outfile,\
    \ dump->format, nrows, (uint32_t)scanlinesize, row, obuf);\n \t}\n \n       if\
    \ (TIFFWriteEncodedStrip(out, strip++, obuf, stripsize) < 0)\n@@ -1262,7 +1272,7\
    \ @@ static int writeBufferToContigTiles (TIFF* out, uint8_t* buf, uint32_t imageleng\n\
    \   uint32_t tl, tw;\n   uint32_t row, col, nrow, ncol;\n   uint32_t src_rowsize,\
    \ col_offset;\n-  uint32_t tile_rowsize  = TIFFTileRowSize(out);\n+  tmsize_t\
    \ tile_rowsize  = TIFFTileRowSize(out);\n   uint8_t* bufp = (uint8_t*) buf;\n\
    \   tsize_t tile_buffsize = 0;\n   tsize_t tilesize = TIFFTileSize(out);\n@@ -1305,9\
    \ +1315,11 @@ static int writeBufferToContigTiles (TIFF* out, uint8_t* buf, uint32_t\
    \ imageleng\n   }\n   src_rowsize = ((imagewidth * spp * bps) + 7U) / 8;\n \n\
    -  tilebuf = limitMalloc(tile_buffsize);\n+  /* Add 3 padding bytes for extractContigSamples32bits\
    \ */\n+  tilebuf = limitMalloc(tile_buffsize + NUM_BUFF_OVERSIZE_BYTES);\n   if\
    \ (tilebuf == 0)\n     return 1;\n+  memset(tilebuf, 0, tile_buffsize + NUM_BUFF_OVERSIZE_BYTES);\n\
    \   for (row = 0; row < imagelength; row += tl)\n     {\n     nrow = (row + tl\
    \ > imagelength) ? imagelength - row : tl;\n@@ -1353,7 +1365,8 @@ static int writeBufferToSeparateTiles\
    \ (TIFF* out, uint8_t* buf, uint32_t imagele\n                               \
    \         uint32_t imagewidth, tsample_t spp,\n                              \
    \          struct dump_opts * dump)\n   {\n-  tdata_t obuf = limitMalloc(TIFFTileSize(out));\n\
    +  /* Add 3 padding bytes for extractContigSamples32bits */\n+  tdata_t obuf =\
    \ limitMalloc(TIFFTileSize(out) + NUM_BUFF_OVERSIZE_BYTES);\n   uint32_t tl, tw;\n\
    \   uint32_t row, col, nrow, ncol;\n   uint32_t src_rowsize, col_offset;\n@@ -1363,6\
    \ +1376,7 @@ static int writeBufferToSeparateTiles (TIFF* out, uint8_t* buf, uint32_t\
    \ imagele\n \n   if (obuf == NULL)\n     return 1;\n+  memset(obuf, 0, TIFFTileSize(out)\
    \ + NUM_BUFF_OVERSIZE_BYTES);\n \n   if( !TIFFGetField(out, TIFFTAG_TILELENGTH,\
    \ &tl) ||\n       !TIFFGetField(out, TIFFTAG_TILEWIDTH, &tw) ||\n@@ -1788,14 +1802,14\
    \ @@ void  process_command_opts (int argc, char *argv[], char *mp, char *mode,\
    \ uint32\n                       \n                     *opt_offset = '\\0';\n\
    \                     /* convert option to lowercase */\n-                   \
    \ end = strlen (opt_ptr);\n+                    end = (unsigned int)strlen (opt_ptr);\n\
    \                     for (i = 0; i < end; i++)\n                       *(opt_ptr\
    \ + i) = tolower((int) *(opt_ptr + i));\n                     /* Look for dump\
    \ format specification */\n                     if (strncmp(opt_ptr, \"for\",\
    \ 3) == 0)\n                       {\n \t\t      /* convert value to lowercase\
    \ */\n-                      end = strlen (opt_offset + 1);\n+               \
    \       end = (unsigned int)strlen (opt_offset + 1);\n                       for\
    \ (i = 1; i <= end; i++)\n                         *(opt_offset + i) = tolower((int)\
    \ *(opt_offset + i));\n                       /* check dump format value */\n\
    @@ -2138,7 +2152,7 @@ void  process_command_opts (int argc, char *argv[], char\
    \ *mp, char *mode, uint32\n     R = (crop_data->crop_mode & CROP_REGIONS) ? 1\
    \ : 0;\n     S = (page->mode & PAGE_MODE_ROWSCOLS) ? 1 : 0;\n     if (XY + Z +\
    \ R + S > 1) {\n-        TIFFError(\"tiffcrop input error\", \"The crop options(-X|-Y),\
    \ -Z, -z and -S are mutually exclusive.->Exit\");\n+        TIFFError(\"tiffcrop\
    \ input error\", \"The crop options(-X|-Y), -Z, -z and -S are mutually exclusive.->exit\"\
    );\n         exit(EXIT_FAILURE);\n     }\n   }  /* end process_command_opts */\n\
    @@ -2257,6 +2271,8 @@ main(int argc, char* argv[])\n   size_t length;\n   char\
    \   temp_filename[PATH_MAX + 16]; /* Extra space keeps the compiler from complaining\
    \ */\n \n+  assert(NUM_BUFF_OVERSIZE_BYTES >= 3);\n+\n   little_endian = *((unsigned\
    \ char *)&little_endian) & '1';\n \n   initImageData(&image);\n@@ -3209,13 +3225,13\
    \ @@ extractContigSamples32bits (uint8_t *in, uint8_t *out, uint32_t cols,\n \
    \      /* If we have a full buffer's worth, write it out */\n       if (ready_bits\
    \ >= 32)\n         {\n-        bytebuff1 = (buff2 >> 56);\n+        bytebuff1\
    \ = (uint8_t)(buff2 >> 56);\n         *dst++ = bytebuff1;\n-        bytebuff2\
    \ = (buff2 >> 48);\n+        bytebuff2 = (uint8_t)(buff2 >> 48);\n         *dst++\
    \ = bytebuff2;\n-        bytebuff3 = (buff2 >> 40);\n+        bytebuff3 = (uint8_t)(buff2\
    \ >> 40);\n         *dst++ = bytebuff3;\n-        bytebuff4 = (buff2 >> 32);\n\
    +        bytebuff4 = (uint8_t)(buff2 >> 32);\n         *dst++ = bytebuff4;\n \
    \        ready_bits -= 32;\n                     \n@@ -3624,13 +3640,13 @@ extractContigSamplesShifted32bits\
    \ (uint8_t *in, uint8_t *out, uint32_t cols,\n         }\n       else  /* If we\
    \ have a full buffer's worth, write it out */\n         {\n-        bytebuff1\
    \ = (buff2 >> 56);\n+        bytebuff1 = (uint8_t)(buff2 >> 56);\n         *dst++\
    \ = bytebuff1;\n-        bytebuff2 = (buff2 >> 48);\n+        bytebuff2 = (uint8_t)(buff2\
    \ >> 48);\n         *dst++ = bytebuff2;\n-        bytebuff3 = (buff2 >> 40);\n\
    +        bytebuff3 = (uint8_t)(buff2 >> 40);\n         *dst++ = bytebuff3;\n-\
    \        bytebuff4 = (buff2 >> 32);\n+        bytebuff4 = (uint8_t)(buff2 >> 32);\n\
    \         *dst++ = bytebuff4;\n         ready_bits -= 32;\n                  \
    \   \n@@ -3807,10 +3823,10 @@ extractContigSamplesToTileBuffer(uint8_t *out, uint8_t\
    \ *in, uint32_t rows, uint3\n static int readContigStripsIntoBuffer (TIFF* in,\
    \ uint8_t* buf)\n {\n         uint8_t* bufp = buf;\n-        int32_t  bytes_read\
    \ = 0;\n+        tmsize_t  bytes_read = 0;\n         uint32_t strip, nstrips \
    \  = TIFFNumberOfStrips(in);\n-        uint32_t stripsize = TIFFStripSize(in);\n\
    -        uint32_t rows = 0;\n+        tmsize_t stripsize = TIFFStripSize(in);\n\
    +        tmsize_t rows = 0;\n         uint32_t rps = TIFFGetFieldDefaulted(in,\
    \ TIFFTAG_ROWSPERSTRIP, &rps);\n         tsize_t scanline_size = TIFFScanlineSize(in);\n\
    \ \n@@ -3823,11 +3839,11 @@ static int readContigStripsIntoBuffer (TIFF* in, uint8_t*\
    \ buf)\n                 bytes_read = TIFFReadEncodedStrip (in, strip, bufp, -1);\n\
    \                 rows = bytes_read / scanline_size;\n                 if ((strip\
    \ < (nstrips - 1)) && (bytes_read != (int32_t)stripsize))\n-                 \
    \       TIFFError(\"\", \"Strip %\"PRIu32\": read %\"PRId32\" bytes, strip size\
    \ %\"PRIu32,\n+                        TIFFError(\"\", \"Strip %\"PRIu32\": read\
    \ %\"PRId64\" bytes, strip size %\"PRIu64,\n                                 \
    \  strip + 1, bytes_read, stripsize);\n \n                 if (bytes_read < 0\
    \ && !ignore) {\n-                        TIFFError(\"\", \"Error reading strip\
    \ %\"PRIu32\" after %\"PRIu32\" rows\",\n+                        TIFFError(\"\
    \", \"Error reading strip %\"PRIu32\" after %\"PRIu64\" rows\",\n            \
    \                       strip, rows);\n                         return 0;\n  \
    \               }\n@@ -4292,13 +4308,13 @@ combineSeparateSamples32bits (uint8_t\
    \ *in[], uint8_t *out, uint32_t cols,\n \t/* If we have a full buffer's worth,\
    \ write it out */\n \tif (ready_bits >= 32)\n \t  {\n-\t  bytebuff1 = (buff2 >>\
    \ 56);\n+\t  bytebuff1 = (uint8_t)(buff2 >> 56);\n \t  *dst++ = bytebuff1;\n-\t\
    \  bytebuff2 = (buff2 >> 48);\n+\t  bytebuff2 = (uint8_t)(buff2 >> 48);\n \t \
    \ *dst++ = bytebuff2;\n-\t  bytebuff3 = (buff2 >> 40);\n+\t  bytebuff3 = (uint8_t)(buff2\
    \ >> 40);\n \t  *dst++ = bytebuff3;\n-\t  bytebuff4 = (buff2 >> 32);\n+\t  bytebuff4\
    \ = (uint8_t)(buff2 >> 32);\n \t  *dst++ = bytebuff4;\n \t  ready_bits -= 32;\n\
    \                     \n@@ -4341,10 +4357,10 @@ combineSeparateSamples32bits (uint8_t\
    \ *in[], uint8_t *out, uint32_t cols,\n \t         \"Row %3d, Col %3d, Src byte\
    \ offset %3d  bit offset %2d  Dst offset %3d\",\n \t\t row + 1, col + 1, src_byte,\
    \ src_bit, dst - out);\n \n-      dump_long (dumpfile, format, \"Match bits \"\
    , matchbits);\n+      dump_wide (dumpfile, format, \"Match bits \", matchbits);\n\
    \       dump_data (dumpfile, format, \"Src   bits \", src, 4);\n-      dump_long\
    \ (dumpfile, format, \"Buff1 bits \", buff1);\n-      dump_long (dumpfile, format,\
    \ \"Buff2 bits \", buff2);\n+      dump_wide (dumpfile, format, \"Buff1 bits \"\
    , buff1);\n+      dump_wide (dumpfile, format, \"Buff2 bits \", buff2);\n    \
    \   dump_byte (dumpfile, format, \"Write bits1\", bytebuff1);\n       dump_byte\
    \ (dumpfile, format, \"Write bits2\", bytebuff2);\n       dump_info (dumpfile,\
    \ format, \"\", \"Ready bits:  %2d\", ready_bits); \n@@ -4817,13 +4833,13 @@ combineSeparateTileSamples32bits\
    \ (uint8_t *in[], uint8_t *out, uint32_t cols,\n \t/* If we have a full buffer's\
    \ worth, write it out */\n \tif (ready_bits >= 32)\n \t  {\n-\t  bytebuff1 = (buff2\
    \ >> 56);\n+\t  bytebuff1 = (uint8_t)(buff2 >> 56);\n \t  *dst++ = bytebuff1;\n\
    -\t  bytebuff2 = (buff2 >> 48);\n+\t  bytebuff2 = (uint8_t)(buff2 >> 48);\n \t\
    \  *dst++ = bytebuff2;\n-\t  bytebuff3 = (buff2 >> 40);\n+\t  bytebuff3 = (uint8_t)(buff2\
    \ >> 40);\n \t  *dst++ = bytebuff3;\n-\t  bytebuff4 = (buff2 >> 32);\n+\t  bytebuff4\
    \ = (uint8_t)(buff2 >> 32);\n \t  *dst++ = bytebuff4;\n \t  ready_bits -= 32;\n\
    \                     \n@@ -4866,10 +4882,10 @@ combineSeparateTileSamples32bits\
    \ (uint8_t *in[], uint8_t *out, uint32_t cols,\n \t         \"Row %3d, Col %3d,\
    \ Src byte offset %3d  bit offset %2d  Dst offset %3d\",\n \t\t row + 1, col +\
    \ 1, src_byte, src_bit, dst - out);\n \n-      dump_long (dumpfile, format, \"\
    Match bits \", matchbits);\n+      dump_wide (dumpfile, format, \"Match bits \"\
    , matchbits);\n       dump_data (dumpfile, format, \"Src   bits \", src, 4);\n\
    -      dump_long (dumpfile, format, \"Buff1 bits \", buff1);\n-      dump_long\
    \ (dumpfile, format, \"Buff2 bits \", buff2);\n+      dump_wide (dumpfile, format,\
    \ \"Buff1 bits \", buff1);\n+      dump_wide (dumpfile, format, \"Buff2 bits \"\
    , buff2);\n       dump_byte (dumpfile, format, \"Write bits1\", bytebuff1);\n\
    \       dump_byte (dumpfile, format, \"Write bits2\", bytebuff2);\n       dump_info\
    \ (dumpfile, format, \"\", \"Ready bits:  %2d\", ready_bits); \n@@ -4892,7 +4908,7\
    \ @@ static int readSeparateStripsIntoBuffer (TIFF *in, uint8_t *obuf, uint32_t\
    \ lengt\n   {\n   int i, bytes_per_sample, bytes_per_pixel, shift_width, result\
    \ = 1;\n   uint32_t j;\n-  int32_t  bytes_read = 0;\n+  tmsize_t  bytes_read =\
    \ 0;\n   uint16_t bps = 0, planar;\n   uint32_t nstrips;\n   uint32_t strips_per_sample;\n\
    @@ -4958,7 +4974,7 @@ static int readSeparateStripsIntoBuffer (TIFF *in, uint8_t\
    \ *obuf, uint32_t lengt\n   for (s = 0; (s < spp) && (s < MAX_SAMPLES); s++)\n\
    \     {\n     srcbuffs[s] = NULL;\n-    buff = limitMalloc(stripsize + 3);\n+\
    \    buff = limitMalloc(stripsize + NUM_BUFF_OVERSIZE_BYTES);\n     if (!buff)\n\
    \       {\n       TIFFError (\"readSeparateStripsIntoBuffer\", \n@@ -4981,7 +4997,7\
    \ @@ static int readSeparateStripsIntoBuffer (TIFF *in, uint8_t *obuf, uint32_t\
    \ lengt\n       buff = srcbuffs[s];\n       strip = (s * strips_per_sample) +\
    \ j; \n       bytes_read = TIFFReadEncodedStrip (in, strip, buff, stripsize);\n\
    -      rows_this_strip = bytes_read / src_rowsize;\n+      rows_this_strip = (uint32_t)(bytes_read\
    \ / src_rowsize);\n       if (bytes_read < 0 && !ignore)\n         {\n       \
    \  TIFFError(TIFFFileName(in),\n@@ -6044,13 +6060,14 @@ loadImage(TIFF* in, struct\
    \ image_data *image, struct dump_opts *dump, unsigned c\n   uint16_t   input_compression\
    \ = 0, input_photometric = 0;\n   uint16_t   subsampling_horiz, subsampling_vert;\n\
    \   uint32_t   width = 0, length = 0;\n-  uint32_t   stsize = 0, tlsize = 0, buffsize\
    \ = 0, scanlinesize = 0;\n+  tmsize_t   stsize = 0, tlsize = 0, buffsize = 0;\n\
    +  tmsize_t   scanlinesize = 0;\n   uint32_t   tw = 0, tl = 0;       /* Tile width\
    \ and length */\n-  uint32_t   tile_rowsize = 0;\n+  tmsize_t   tile_rowsize =\
    \ 0;\n   unsigned char *read_buff = NULL;\n   unsigned char *new_buff  = NULL;\n\
    \   int      readunit = 0;\n-  static   uint32_t  prev_readsize = 0;\n+  static\
    \   tmsize_t  prev_readsize = 0;\n \n   TIFFGetFieldDefaulted(in, TIFFTAG_BITSPERSAMPLE,\
    \ &bps);\n   TIFFGetFieldDefaulted(in, TIFFTAG_SAMPLESPERPIXEL, &spp);\n@@ -6307,6\
    \ +6324,8 @@ loadImage(TIFF* in, struct image_data *image, struct dump_opts *dump,\
    \ unsigned c\n     /* The buffsize_check and the possible adaptation of buffsize\
    \ \n      * has to account also for padding of each line to a byte boundary. \n\
    \      * This is assumed by mirrorImage() and rotateImage().\n+     * Furthermore,\
    \ functions like extractContigSamplesShifted32bits()\n+     * need a buffer, which\
    \ is at least 3 bytes larger than the actual image.\n      * Otherwise buffer-overflow\
    \ might occur there.\n      */\n     buffsize_check = length * (uint32_t)(((width\
    \ * spp * bps) + 7) / 8);\n@@ -6358,7 +6377,7 @@ loadImage(TIFF* in, struct image_data\
    \ *image, struct dump_opts *dump, unsigned c\n         TIFFError(\"loadImage\"\
    , \"Unable to allocate/reallocate read buffer\");\n         return (-1);\n   \
    \  }\n-    read_buff = (unsigned char *)limitMalloc(buffsize+3);\n+    read_buff\
    \ = (unsigned char *)limitMalloc(buffsize + NUM_BUFF_OVERSIZE_BYTES);\n   }\n\
    \   else\n     {\n@@ -6369,11 +6388,11 @@ loadImage(TIFF* in, struct image_data\
    \ *image, struct dump_opts *dump, unsigned c\n           TIFFError(\"loadImage\"\
    , \"Unable to allocate/reallocate read buffer\");\n           return (-1);\n \
    \      }\n-      new_buff = _TIFFrealloc(read_buff, buffsize+3);\n+      new_buff\
    \ = _TIFFrealloc(read_buff, buffsize + NUM_BUFF_OVERSIZE_BYTES);\n       if (!new_buff)\n\
    \         {\n \tfree (read_buff);\n-        read_buff = (unsigned char *)limitMalloc(buffsize+3);\n\
    +        read_buff = (unsigned char *)limitMalloc(buffsize + NUM_BUFF_OVERSIZE_BYTES);\n\
    \         }\n       else\n         read_buff = new_buff;\n@@ -6446,8 +6465,13\
    \ @@ loadImage(TIFF* in, struct image_data *image, struct dump_opts *dump, unsigned\
    \ c\n     dump_info  (dump->infile, dump->format, \"\", \n                 \"\
    Bits per sample %\"PRIu16\", Samples per pixel %\"PRIu16, bps, spp);\n \n+   \
    \ if (scanlinesize > 0x0ffffffffULL) {\n+        dump_info(dump->infile, dump->format,\
    \ \"loadImage\",\n+            \"Attention: scanlinesize %\"PRIu64\" is larger\
    \ than UINT32_MAX.\\nFollowing dump might be wrong.\",\n+            scanlinesize);\n\
    +    }\n     for (i = 0; i < length; i++)\n-      dump_buffer(dump->infile, dump->format,\
    \ 1, scanlinesize, \n+      dump_buffer(dump->infile, dump->format, 1, (uint32_t)scanlinesize,\
    \ \n                   i, read_buff + (i * scanlinesize));\n     }\n   return\
    \ (0);\n@@ -7467,13 +7491,13 @@ writeSingleSection(TIFF *in, TIFF *out, struct\
    \ image_data *image,\n      if (TIFFGetField(in, TIFFTAG_NUMBEROFINKS, &ninks))\
    \ {\n        TIFFSetField(out, TIFFTAG_NUMBEROFINKS, ninks);\n        if (TIFFGetField(in,\
    \ TIFFTAG_INKNAMES, &inknames)) {\n-\t int inknameslen = strlen(inknames) + 1;\n\
    +\t int inknameslen = (int)strlen(inknames) + 1;\n \t const char* cp = inknames;\n\
    \ \t while (ninks > 1) {\n \t   cp = strchr(cp, '\\0');\n \t   if (cp) {\n \t\
    \     cp++;\n-\t     inknameslen += (strlen(cp) + 1);\n+\t     inknameslen +=\
    \ ((int)strlen(cp) + 1);\n \t   }\n \t   ninks--;\n          }\n@@ -7536,23 +7560,23\
    \ @@ createImageSection(uint32_t sectsize, unsigned char **sect_buff_ptr)\n \n\
    \   if (!sect_buff)\n     {\n-    sect_buff = (unsigned char *)limitMalloc(sectsize);\n\
    +    sect_buff = (unsigned char *)limitMalloc(sectsize + NUM_BUFF_OVERSIZE_BYTES);\n\
    \     if (!sect_buff)\n     {\n         TIFFError(\"createImageSection\", \"Unable\
    \ to allocate/reallocate section buffer\");\n         return (-1);\n     }\n-\
    \    _TIFFmemset(sect_buff, 0, sectsize);\n+    _TIFFmemset(sect_buff, 0, sectsize\
    \ + NUM_BUFF_OVERSIZE_BYTES);\n     }\n   else\n     {\n     if (prev_sectsize\
    \ < sectsize)\n       {\n-      new_buff = _TIFFrealloc(sect_buff, sectsize);\n\
    +      new_buff = _TIFFrealloc(sect_buff, sectsize + NUM_BUFF_OVERSIZE_BYTES);\n\
    \       if (!new_buff)\n         {\n           _TIFFfree (sect_buff);\n-     \
    \   sect_buff = (unsigned char *)limitMalloc(sectsize);\n+        sect_buff =\
    \ (unsigned char *)limitMalloc(sectsize + NUM_BUFF_OVERSIZE_BYTES);\n        \
    \ }\n       else\n         sect_buff = new_buff;\n@@ -7562,7 +7586,7 @@ createImageSection(uint32_t\
    \ sectsize, unsigned char **sect_buff_ptr)\n           TIFFError(\"createImageSection\"\
    , \"Unable to allocate/reallocate section buffer\");\n           return (-1);\n\
    \       }\n-      _TIFFmemset(sect_buff, 0, sectsize);\n+      _TIFFmemset(sect_buff,\
    \ 0, sectsize + NUM_BUFF_OVERSIZE_BYTES);\n       }\n     }\n \n@@ -7593,17 +7617,17\
    \ @@ processCropSelections(struct image_data *image, struct crop_mask *crop,\n\
    \     cropsize = crop->bufftotal;\n     crop_buff = seg_buffs[0].buffer; \n  \
    \   if (!crop_buff)\n-      crop_buff = (unsigned char *)limitMalloc(cropsize);\n\
    +      crop_buff = (unsigned char *)limitMalloc(cropsize + NUM_BUFF_OVERSIZE_BYTES);\n\
    \     else\n       {\n       prev_cropsize = seg_buffs[0].size;\n       if (prev_cropsize\
    \ < cropsize)\n         {\n-        next_buff = _TIFFrealloc(crop_buff, cropsize);\n\
    +        next_buff = _TIFFrealloc(crop_buff, cropsize + NUM_BUFF_OVERSIZE_BYTES);\n\
    \         if (! next_buff)\n           {\n           _TIFFfree (crop_buff);\n\
    -          crop_buff = (unsigned char *)limitMalloc(cropsize);\n+          crop_buff\
    \ = (unsigned char *)limitMalloc(cropsize + NUM_BUFF_OVERSIZE_BYTES);\n      \
    \     }\n         else\n           crop_buff = next_buff;\n@@ -7616,7 +7640,7\
    \ @@ processCropSelections(struct image_data *image, struct crop_mask *crop,\n\
    \       return (-1);\n       }\n  \n-    _TIFFmemset(crop_buff, 0, cropsize);\n\
    +    _TIFFmemset(crop_buff, 0, cropsize + NUM_BUFF_OVERSIZE_BYTES);\n     seg_buffs[0].buffer\
    \ = crop_buff;\n     seg_buffs[0].size = cropsize;\n \n@@ -7696,17 +7720,17 @@\
    \ processCropSelections(struct image_data *image, struct crop_mask *crop,\n  \
    \       cropsize = crop->bufftotal;\n       crop_buff = seg_buffs[i].buffer; \n\
    \       if (!crop_buff)\n-        crop_buff = (unsigned char *)limitMalloc(cropsize);\n\
    +        crop_buff = (unsigned char *)limitMalloc(cropsize + NUM_BUFF_OVERSIZE_BYTES);\n\
    \       else\n         {\n         prev_cropsize = seg_buffs[0].size;\n      \
    \   if (prev_cropsize < cropsize)\n           {\n-          next_buff = _TIFFrealloc(crop_buff,\
    \ cropsize);\n+          next_buff = _TIFFrealloc(crop_buff, cropsize + NUM_BUFF_OVERSIZE_BYTES);\n\
    \           if (! next_buff)\n             {\n             _TIFFfree (crop_buff);\n\
    -            crop_buff = (unsigned char *)limitMalloc(cropsize);\n+          \
    \  crop_buff = (unsigned char *)limitMalloc(cropsize + NUM_BUFF_OVERSIZE_BYTES);\n\
    \             }\n           else\n             crop_buff = next_buff;\n@@ -7719,7\
    \ +7743,7 @@ processCropSelections(struct image_data *image, struct crop_mask\
    \ *crop,\n         return (-1);\n         }\n  \n-      _TIFFmemset(crop_buff,\
    \ 0, cropsize);\n+      _TIFFmemset(crop_buff, 0, cropsize + NUM_BUFF_OVERSIZE_BYTES);\n\
    \       seg_buffs[i].buffer = crop_buff;\n       seg_buffs[i].size = cropsize;\n\
    \ \n@@ -7835,24 +7859,24 @@ createCroppedImage(struct image_data *image, struct\
    \ crop_mask *crop,\n   crop_buff = *crop_buff_ptr;\n   if (!crop_buff)\n     {\n\
    -    crop_buff = (unsigned char *)limitMalloc(cropsize);\n+    crop_buff = (unsigned\
    \ char *)limitMalloc(cropsize + NUM_BUFF_OVERSIZE_BYTES);\n     if (!crop_buff)\n\
    \     {\n         TIFFError(\"createCroppedImage\", \"Unable to allocate/reallocate\
    \ crop buffer\");\n         return (-1);\n     }\n-    _TIFFmemset(crop_buff,\
    \ 0, cropsize);\n+    _TIFFmemset(crop_buff, 0, cropsize + NUM_BUFF_OVERSIZE_BYTES);\n\
    \     prev_cropsize = cropsize;\n     }\n   else\n     {\n     if (prev_cropsize\
    \ < cropsize)\n       {\n-      new_buff = _TIFFrealloc(crop_buff, cropsize);\n\
    +      new_buff = _TIFFrealloc(crop_buff, cropsize + NUM_BUFF_OVERSIZE_BYTES);\n\
    \       if (!new_buff)\n         {\n \tfree (crop_buff);\n-        crop_buff =\
    \ (unsigned char *)limitMalloc(cropsize);\n+        crop_buff = (unsigned char\
    \ *)limitMalloc(cropsize + NUM_BUFF_OVERSIZE_BYTES);\n         }\n       else\n\
    \         crop_buff = new_buff;\n@@ -7861,7 +7885,7 @@ createCroppedImage(struct\
    \ image_data *image, struct crop_mask *crop,\n           TIFFError(\"createCroppedImage\"\
    , \"Unable to allocate/reallocate crop buffer\");\n           return (-1);\n \
    \      }\n-      _TIFFmemset(crop_buff, 0, cropsize);\n+      _TIFFmemset(crop_buff,\
    \ 0, cropsize + NUM_BUFF_OVERSIZE_BYTES);\n       }\n     }\n \n@@ -8159,13 +8183,13\
    \ @@ writeCroppedImage(TIFF *in, TIFF *out, struct image_data *image,\n      if\
    \ (TIFFGetField(in, TIFFTAG_NUMBEROFINKS, &ninks)) {\n        TIFFSetField(out,\
    \ TIFFTAG_NUMBEROFINKS, ninks);\n        if (TIFFGetField(in, TIFFTAG_INKNAMES,\
    \ &inknames)) {\n-\t int inknameslen = strlen(inknames) + 1;\n+\t int inknameslen\
    \ = (int)strlen(inknames) + 1;\n \t const char* cp = inknames;\n \t while (ninks\
    \ > 1) {\n \t   cp = strchr(cp, '\\0');\n \t   if (cp) {\n \t     cp++;\n-\t \
    \    inknameslen += (strlen(cp) + 1);\n+\t     inknameslen += ((int)strlen(cp)\
    \ + 1);\n \t   }\n \t   ninks--;\n          }\n@@ -8550,13 +8574,13 @@ rotateContigSamples32bits(uint16_t\
    \ rotation, uint16_t spp, uint16_t bps, uint32_\n         }\n       else /* If\
    \ we have a full buffer's worth, write it out */\n         {\n-        bytebuff1\
    \ = (buff2 >> 56);\n+        bytebuff1 = (uint8_t)(buff2 >> 56);\n         *dst++\
    \ = bytebuff1;\n-        bytebuff2 = (buff2 >> 48);\n+        bytebuff2 = (uint8_t)(buff2\
    \ >> 48);\n         *dst++ = bytebuff2;\n-        bytebuff3 = (buff2 >> 40);\n\
    +        bytebuff3 = (uint8_t)(buff2 >> 40);\n         *dst++ = bytebuff3;\n-\
    \        bytebuff4 = (buff2 >> 32);\n+        bytebuff4 = (uint8_t)(buff2 >> 32);\n\
    \         *dst++ = bytebuff4;\n         ready_bits -= 32;\n                  \
    \   \n@@ -8625,12 +8649,13 @@ rotateImage(uint16_t rotation, struct image_data\
    \ *image, uint32_t *img_width,\n               return (-1);\n     }\n \n-  if\
    \ (!(rbuff = (unsigned char *)limitMalloc(buffsize)))\n+  /* Add 3 padding bytes\
    \ for extractContigSamplesShifted32bits */\n+  if (!(rbuff = (unsigned char *)limitMalloc(buffsize\
    \ + NUM_BUFF_OVERSIZE_BYTES)))\n     {\n-    TIFFError(\"rotateImage\", \"Unable\
    \ to allocate rotation buffer of %1u bytes\", buffsize);\n+    TIFFError(\"rotateImage\"\
    , \"Unable to allocate rotation buffer of %1u bytes\", buffsize + NUM_BUFF_OVERSIZE_BYTES);\n\
    \     return (-1);\n     }\n-  _TIFFmemset(rbuff, '\\0', buffsize);\n+  _TIFFmemset(rbuff,\
    \ '\\0', buffsize + NUM_BUFF_OVERSIZE_BYTES);\n \n   ibuff = *ibuff_ptr;\n   switch\
    \ (rotation)\n@@ -9158,13 +9183,13 @@ reverseSamples32bits (uint16_t spp, uint16_t\
    \ bps, uint32_t width,\n         }\n       else /* If we have a full buffer's\
    \ worth, write it out */\n         {\n-        bytebuff1 = (buff2 >> 56);\n+ \
    \       bytebuff1 = (uint8_t)(buff2 >> 56);\n         *dst++ = bytebuff1;\n- \
    \       bytebuff2 = (buff2 >> 48);\n+        bytebuff2 = (uint8_t)(buff2 >> 48);\n\
    \         *dst++ = bytebuff2;\n-        bytebuff3 = (buff2 >> 40);\n+        bytebuff3\
    \ = (uint8_t)(buff2 >> 40);\n         *dst++ = bytebuff3;\n-        bytebuff4\
    \ = (buff2 >> 32);\n+        bytebuff4 = (uint8_t)(buff2 >> 32);\n         *dst++\
    \ = bytebuff4;\n         ready_bits -= 32;\n                     \n@@ -9255,12\
    \ +9280,13 @@ mirrorImage(uint16_t spp, uint16_t bps, uint16_t mirror, uint32_t\
    \ width, uint32_\n     {\n     case MIRROR_BOTH:\n     case MIRROR_VERT: \n- \
    \            line_buff = (unsigned char *)limitMalloc(rowsize);\n+           \
    \  line_buff = (unsigned char *)limitMalloc(rowsize + NUM_BUFF_OVERSIZE_BYTES);\n\
    \              if (line_buff == NULL)\n                {\n-\t       TIFFError\
    \ (\"mirrorImage\", \"Unable to allocate mirror line buffer of %1u bytes\", rowsize);\n\
    +\t       TIFFError (\"mirrorImage\", \"Unable to allocate mirror line buffer\
    \ of %1u bytes\", rowsize + NUM_BUFF_OVERSIZE_BYTES);\n                return\
    \ (-1);\n                }\n+             _TIFFmemset(line_buff, '\\0', rowsize\
    \ + NUM_BUFF_OVERSIZE_BYTES);\n \n              dst = ibuff + (rowsize * (length\
    \ - 1));\n              for (row = 0; row < length / 2; row++)\n@@ -9292,11 +9318,12\
    \ @@ mirrorImage(uint16_t spp, uint16_t bps, uint16_t mirror, uint32_t width,\
    \ uint32_\n \t\t}\n \t      else\n                 { /* non 8 bit per sample \
    \ data */\n-                if (!(line_buff = (unsigned char *)limitMalloc(rowsize\
    \ + 1)))\n+                if (!(line_buff = (unsigned char *)limitMalloc(rowsize\
    \ + NUM_BUFF_OVERSIZE_BYTES)))\n                   {\n                   TIFFError(\"\
    mirrorImage\", \"Unable to allocate mirror line buffer\");\n                 \
    \  return (-1);\n                   }\n+                _TIFFmemset(line_buff,\
    \ '\\0', rowsize + NUM_BUFF_OVERSIZE_BYTES);\n                 bytes_per_sample\
    \ = (bps + 7) / 8;\n                 bytes_per_pixel  = ((bps * spp) + 7) / 8;\n\
    \                 if (bytes_per_pixel < (bytes_per_sample + 1))\n@@ -9308,7 +9335,7\
    \ @@ mirrorImage(uint16_t spp, uint16_t bps, uint16_t mirror, uint32_t width,\
    \ uint32_\n                   {\n \t\t  row_offset = row * rowsize;\n        \
    \           src = ibuff + row_offset;\n-                  _TIFFmemset (line_buff,\
    \ '\\0', rowsize);\n+                  _TIFFmemset (line_buff, '\\0', rowsize\
    \ + NUM_BUFF_OVERSIZE_BYTES);\n                   switch (shift_width)\n     \
    \                {\n                     case 1: if (reverseSamples16bits(spp,\
    \ bps, width, src, line_buff))\n"
  identifiers:
  - CVE-2022-3570
  - CWE-787
  overview: Multiple heap buffer overflows in tiffcrop.c utility in libtiff library
    Version 4.4.0 allows attacker to trigger unsafe or out of bounds memory access
    via crafted TIFF image file which could result into application crash, potential
    information disclosure or any other context-dependent impact
  references:
  - source: cve@gitlab.com
    tags:
    - Third Party Advisory
    - VDB Entry
    url: https://gitlab.com/gitlab-org/cves/-/blob/master/2022/CVE-2022-3570.json
  - source: cve@gitlab.com
    tags:
    - Patch
    url: https://gitlab.com/libtiff/libtiff/-/commit/bd94a9b383d8755a27b5a1bc27660b8ad10b094c
  - source: cve@gitlab.com
    tags:
    - Exploit
    - Issue Tracking
    - Patch
    - Third Party Advisory
    url: https://gitlab.com/libtiff/libtiff/-/issues/381
  - source: cve@gitlab.com
    tags:
    - Exploit
    - Issue Tracking
    - Patch
    - Third Party Advisory
    url: https://gitlab.com/libtiff/libtiff/-/issues/386
  - source: cve@gitlab.com
    tags:
    - Mailing List
    - Third Party Advisory
    url: https://lists.debian.org/debian-lts-announce/2023/01/msg00018.html
  - source: cve@gitlab.com
    tags:
    - Third Party Advisory
    url: https://security.netapp.com/advisory/ntap-20230203-0002/
  - source: cve@gitlab.com
    tags:
    - Third Party Advisory
    url: https://www.debian.org/security/2023/dsa-5333
  title: Multiple heap buffer overflows in tiffcrop.c utility in libtiff library Version
    4.4.0 allows attacker to trigger unsafe or out of bounds memory access via crafted
    TIFF image file which could result into application crash, potential information
    disclosure or any other context-dependent impact
- diff_content:
  - "--- a/tools/tiffcrop.c\n+++ b/tools/tiffcrop.c\n@@ -107,13 +107,15 @@\n  *  \
    \              selects which functions dump data, with higher numbers selecting\n\
    \  *                lower level, scanline level routines. Debug reports a limited\
    \ set\n  *                of messages to monitor progress without enabling dump\
    \ logs.\n- * \n- * Note:    The (-X|-Y), -Z, -z and -S options are mutually exclusive.\n\
    + *\n+ * Note 1:  The (-X|-Y), -Z, -z and -S options are mutually exclusive.\n\
    \  *          In no case should the options be applied to a given selection successively.\n\
    - */\n+ * Note 2:  Any of the -X, -Y, -Z and -z options together with other PAGE_MODE_x\
    \ options\n+ *          such as -H, -V, -P, -J or -K are not supported and may\
    \ cause buffer overflows.\n+  */\n \n-static   char tiffcrop_version_id[] = \"\
    2.5.1\";\n-static   char tiffcrop_rev_date[] = \"15-08-2022\";\n+static   char\
    \ tiffcrop_version_id[] = \"2.5.3\";\n+static   char tiffcrop_rev_date[] = \"\
    26-08-2022\";\n \n #include \"tif_config.h\"\n #include \"libport.h\"\n@@ -781,9\
    \ +783,12 @@ static const char usage_info[] =\n \"             The four debug/dump\
    \ options are independent, though it makes little sense to\\n\"\n \"         \
    \    specify a dump file without specifying a detail level.\\n\"\n \"\\n\"\n-\"\
    Note:        The (-X|-Y), -Z, -z and -S options are mutually exclusive.\\n\"\n\
    +\"Note 1:      The (-X|-Y), -Z, -z and -S options are mutually exclusive.\\n\"\
    \n \"             In no case should the options be applied to a given selection\
    \ successively.\\n\"\n \"\\n\"\n+\"Note 2:      Any of the -X, -Y, -Z and -z options\
    \ together with other PAGE_MODE_x options\\n\"\n+\"             such as - H, -V,\
    \ -P, -J or -K are not supported and may cause buffer overflows.\\n\"\n+\"\\n\"\
    \n ;\n \n /* This function could be modified to pass starting sample offset \n\
    @@ -2138,9 +2143,20 @@ void  process_command_opts (int argc, char *argv[], char\
    \ *mp, char *mode, uint32\n     R = (crop_data->crop_mode & CROP_REGIONS) ? 1\
    \ : 0;\n     S = (page->mode & PAGE_MODE_ROWSCOLS) ? 1 : 0;\n     if (XY + Z +\
    \ R + S > 1) {\n-        TIFFError(\"tiffcrop input error\", \"The crop options(-X|-Y),\
    \ -Z, -z and -S are mutually exclusive.->Exit\");\n+        TIFFError(\"tiffcrop\
    \ input error\", \"The crop options(-X|-Y), -Z, -z and -S are mutually exclusive.->exit\"\
    );\n         exit(EXIT_FAILURE);\n     }\n+\n+    /* Check for not allowed combination:\n\
    +     * Any of the -X, -Y, -Z and -z options together with other PAGE_MODE_x options\n\
    +     * such as -H, -V, -P, -J or -K are not supported and may cause buffer overflows.\n\
    +.    */\n+    if ((XY + Z + R > 0) && page->mode != PAGE_MODE_NONE) {\n+    \
    \    TIFFError(\"tiffcrop input error\",\n+            \"Any of the crop options\
    \ -X, -Y, -Z and -z together with other PAGE_MODE_x options such as - H, -V, -P,\
    \ -J or -K is not supported and may cause buffer overflows..->exit\");\n+    \
    \    exit(EXIT_FAILURE);\n+    }\n+\n   }  /* end process_command_opts */\n \n\
    \ /* Start a new output file if one has not been previously opened or\n@@ -2411,6\
    \ +2427,7 @@ main(int argc, char* argv[])\n         exit (EXIT_FAILURE);\n \t\
    }\n \n+      /* Crop input image and copy zones and regions from input image into\
    \ seg_buffs or crop_buff. */\n       if (crop.selections > 0)\n         {\n  \
    \       if (processCropSelections(&image, &crop, &read_buff, seg_buffs))\n@@ -2427,6\
    \ +2444,7 @@ main(int argc, char* argv[])\n           exit (EXIT_FAILURE);\n \t\
    \  }\n \t}\n+      /* Format and write selected image parts to output file(s).\
    \ */\n       if (page.mode == PAGE_MODE_NONE)\n         {  /* Whole image or sections\
    \ not based on output page size */\n         if (crop.selections > 0)\n"
  identifiers:
  - CVE-2022-3597
  - CWE-787
  overview: LibTIFF 4.4.0 has an out-of-bounds write in _TIFFmemcpy in libtiff/tif_unix.c:346
    when called from extractImageSection, tools/tiffcrop.c:6826, allowing attackers
    to cause a denial-of-service via a crafted tiff file. For users that compile libtiff
    from sources, the fix is available with commit 236b7191.
  references:
  - source: cve@gitlab.com
    tags:
    - Third Party Advisory
    - VDB Entry
    url: https://gitlab.com/gitlab-org/cves/-/blob/master/2022/CVE-2022-3597.json
  - source: cve@gitlab.com
    tags:
    - Patch
    url: https://gitlab.com/libtiff/libtiff/-/commit/236b7191f04c60d09ee836ae13b50f812c841047
  - source: cve@gitlab.com
    tags:
    - Exploit
    - Issue Tracking
    - Patch
    - Third Party Advisory
    url: https://gitlab.com/libtiff/libtiff/-/issues/413
  - source: cve@gitlab.com
    tags:
    - Third Party Advisory
    url: https://lists.debian.org/debian-lts-announce/2023/01/msg00018.html
  - source: cve@gitlab.com
    tags:
    - Third Party Advisory
    url: https://security.netapp.com/advisory/ntap-20230110-0001/
  - source: cve@gitlab.com
    tags:
    - Third Party Advisory
    url: https://www.debian.org/security/2023/dsa-5333
  title: LibTIFF 4.4.0 has an out-of-bounds write in _TIFFmemcpy in libtiff/tif_unix.c:346
    when called from extractImageSection, tools/tiffcrop.c:6826, allowing attackers
    to cause a denial-of-service via a crafted tiff file. For users that compile libtiff
    from sources, the fix is available with commit 236b7191.
- diff_content:
  - "--- a/tools/tiffcrop.c\n+++ b/tools/tiffcrop.c\n@@ -114,8 +114,8 @@\n  *    \
    \      such as -H, -V, -P, -J or -K are not supported and may cause buffer overflows.\n\
    \   */\n \n-static   char tiffcrop_version_id[] = \"2.5.3\";\n-static   char tiffcrop_rev_date[]\
    \ = \"26-08-2022\";\n+static   char tiffcrop_version_id[] = \"2.5.4\";\n+static\
    \   char tiffcrop_rev_date[] = \"27-08-2022\";\n \n #include \"tif_config.h\"\n\
    \ #include \"libport.h\"\n@@ -212,6 +212,10 @@ static   char tiffcrop_rev_date[]\
    \ = \"26-08-2022\";\n \n #define TIFF_DIR_MAX  65534\n \n+/* Some conversion subroutines\
    \ require image buffers, which are at least 3 bytes\n+ * larger than the necessary\
    \ size for the image itself. */\n+#define NUM_BUFF_OVERSIZE_BYTES   3\n+\n /*\
    \ Offsets into buffer for margins and fixed width and length segments */\n struct\
    \ offset {\n   uint32_t  tmargin;\n@@ -233,7 +237,7 @@ struct offset {\n  */\n\
    \ \n struct  buffinfo {\n-  uint32_t size;           /* size of this buffer */\n\
    +  size_t size;           /* size of this buffer */\n   unsigned char *buffer;\
    \ /* address of the allocated buffer */\n };\n \n@@ -810,8 +814,8 @@ static int\
    \ readContigTilesIntoBuffer (TIFF* in, uint8_t* buf,\n   uint32_t dst_rowsize,\
    \ shift_width;\n   uint32_t bytes_per_sample, bytes_per_pixel;\n   uint32_t trailing_bits,\
    \ prev_trailing_bits;\n-  uint32_t tile_rowsize  = TIFFTileRowSize(in);\n-  uint32_t\
    \ src_offset, dst_offset;\n+  tmsize_t tile_rowsize  = TIFFTileRowSize(in);\n\
    +  tmsize_t src_offset, dst_offset;\n   uint32_t row_offset, col_offset;\n   uint8_t\
    \ *bufp = (uint8_t*) buf;\n   unsigned char *src = NULL;\n@@ -861,7 +865,7 @@\
    \ static int readContigTilesIntoBuffer (TIFF* in, uint8_t* buf,\n       TIFFError(\"\
    readContigTilesIntoBuffer\", \"Integer overflow when calculating buffer size.\"\
    );\n       exit(EXIT_FAILURE);\n   }\n-  tilebuf = limitMalloc(tile_buffsize +\
    \ 3);\n+  tilebuf = limitMalloc(tile_buffsize + NUM_BUFF_OVERSIZE_BYTES);\n  \
    \ if (tilebuf == 0)\n     return 0;\n   tilebuf[tile_buffsize] = 0;\n@@ -1024,7\
    \ +1028,7 @@ static int  readSeparateTilesIntoBuffer (TIFF* in, uint8_t *obuf,\n\
    \   for (sample = 0; (sample < spp) && (sample < MAX_SAMPLES); sample++)\n   \
    \  {\n     srcbuffs[sample] = NULL;\n-    tbuff = (unsigned char *)limitMalloc(tilesize\
    \ + 8);\n+    tbuff = (unsigned char *)limitMalloc(tilesize + NUM_BUFF_OVERSIZE_BYTES);\n\
    \     if (!tbuff)\n       {\n       TIFFError (\"readSeparateTilesIntoBuffer\"\
    , \n@@ -1217,7 +1221,8 @@ writeBufferToSeparateStrips (TIFF* out, uint8_t* buf,\n\
    \   }\n   rowstripsize = rowsperstrip * bytes_per_sample * (width + 1); \n \n\
    -  obuf = limitMalloc (rowstripsize);\n+  /* Add 3 padding bytes for extractContigSamples32bits\
    \ */\n+  obuf = limitMalloc (rowstripsize + NUM_BUFF_OVERSIZE_BYTES);\n   if (obuf\
    \ == NULL)\n     return 1;\n   \n@@ -1229,7 +1234,7 @@ writeBufferToSeparateStrips\
    \ (TIFF* out, uint8_t* buf,\n \n       stripsize = TIFFVStripSize(out, nrows);\n\
    \       src = buf + (row * rowsize);\n-      memset (obuf, '\\0', rowstripsize);\n\
    +      memset (obuf, '\\0',rowstripsize + NUM_BUFF_OVERSIZE_BYTES);\n       if\
    \ (extractContigSamplesToBuffer(obuf, src, nrows, width, s, spp, bps, dump))\n\
    \         {\n         _TIFFfree(obuf);\n@@ -1237,10 +1242,15 @@ writeBufferToSeparateStrips\
    \ (TIFF* out, uint8_t* buf,\n \t}\n       if ((dump->outfile != NULL) && (dump->level\
    \ == 1))\n         {\n-        dump_info(dump->outfile, dump->format,\"\", \n\
    +          if (scanlinesize > 0x0ffffffffULL) {\n+              dump_info(dump->infile,\
    \ dump->format, \"loadImage\",\n+                  \"Attention: scanlinesize %\"\
    PRIu64\" is larger than UINT32_MAX.\\nFollowing dump might be wrong.\",\n+   \
    \               scanlinesize);\n+          }\n+          dump_info(dump->outfile,\
    \ dump->format,\"\",\n                   \"Sample %2d, Strip: %2d, bytes: %4d,\
    \ Row %4d, bytes: %4d, Input offset: %6d\", \n-                  s + 1, strip\
    \ + 1, stripsize, row + 1, scanlinesize, src - buf);\n-        dump_buffer(dump->outfile,\
    \ dump->format, nrows, scanlinesize, row, obuf);\n+                  s + 1, strip\
    \ + 1, stripsize, row + 1, (uint32_t)scanlinesize, src - buf);\n+        dump_buffer(dump->outfile,\
    \ dump->format, nrows, (uint32_t)scanlinesize, row, obuf);\n \t}\n \n       if\
    \ (TIFFWriteEncodedStrip(out, strip++, obuf, stripsize) < 0)\n@@ -1267,7 +1277,7\
    \ @@ static int writeBufferToContigTiles (TIFF* out, uint8_t* buf, uint32_t imageleng\n\
    \   uint32_t tl, tw;\n   uint32_t row, col, nrow, ncol;\n   uint32_t src_rowsize,\
    \ col_offset;\n-  uint32_t tile_rowsize  = TIFFTileRowSize(out);\n+  tmsize_t\
    \ tile_rowsize  = TIFFTileRowSize(out);\n   uint8_t* bufp = (uint8_t*) buf;\n\
    \   tsize_t tile_buffsize = 0;\n   tsize_t tilesize = TIFFTileSize(out);\n@@ -1310,9\
    \ +1320,11 @@ static int writeBufferToContigTiles (TIFF* out, uint8_t* buf, uint32_t\
    \ imageleng\n   }\n   src_rowsize = ((imagewidth * spp * bps) + 7U) / 8;\n \n\
    -  tilebuf = limitMalloc(tile_buffsize);\n+  /* Add 3 padding bytes for extractContigSamples32bits\
    \ */\n+  tilebuf = limitMalloc(tile_buffsize + NUM_BUFF_OVERSIZE_BYTES);\n   if\
    \ (tilebuf == 0)\n     return 1;\n+  memset(tilebuf, 0, tile_buffsize + NUM_BUFF_OVERSIZE_BYTES);\n\
    \   for (row = 0; row < imagelength; row += tl)\n     {\n     nrow = (row + tl\
    \ > imagelength) ? imagelength - row : tl;\n@@ -1358,7 +1370,8 @@ static int writeBufferToSeparateTiles\
    \ (TIFF* out, uint8_t* buf, uint32_t imagele\n                               \
    \         uint32_t imagewidth, tsample_t spp,\n                              \
    \          struct dump_opts * dump)\n   {\n-  tdata_t obuf = limitMalloc(TIFFTileSize(out));\n\
    +  /* Add 3 padding bytes for extractContigSamples32bits */\n+  tdata_t obuf =\
    \ limitMalloc(TIFFTileSize(out) + NUM_BUFF_OVERSIZE_BYTES);\n   uint32_t tl, tw;\n\
    \   uint32_t row, col, nrow, ncol;\n   uint32_t src_rowsize, col_offset;\n@@ -1368,6\
    \ +1381,7 @@ static int writeBufferToSeparateTiles (TIFF* out, uint8_t* buf, uint32_t\
    \ imagele\n \n   if (obuf == NULL)\n     return 1;\n+  memset(obuf, 0, TIFFTileSize(out)\
    \ + NUM_BUFF_OVERSIZE_BYTES);\n \n   if( !TIFFGetField(out, TIFFTAG_TILELENGTH,\
    \ &tl) ||\n       !TIFFGetField(out, TIFFTAG_TILEWIDTH, &tw) ||\n@@ -1793,14 +1807,14\
    \ @@ void  process_command_opts (int argc, char *argv[], char *mp, char *mode,\
    \ uint32\n                       \n                     *opt_offset = '\\0';\n\
    \                     /* convert option to lowercase */\n-                   \
    \ end = strlen (opt_ptr);\n+                    end = (unsigned int)strlen (opt_ptr);\n\
    \                     for (i = 0; i < end; i++)\n                       *(opt_ptr\
    \ + i) = tolower((int) *(opt_ptr + i));\n                     /* Look for dump\
    \ format specification */\n                     if (strncmp(opt_ptr, \"for\",\
    \ 3) == 0)\n                       {\n \t\t      /* convert value to lowercase\
    \ */\n-                      end = strlen (opt_offset + 1);\n+               \
    \       end = (unsigned int)strlen (opt_offset + 1);\n                       for\
    \ (i = 1; i <= end; i++)\n                         *(opt_offset + i) = tolower((int)\
    \ *(opt_offset + i));\n                       /* check dump format value */\n\
    @@ -2273,6 +2287,8 @@ main(int argc, char* argv[])\n   size_t length;\n   char\
    \   temp_filename[PATH_MAX + 16]; /* Extra space keeps the compiler from complaining\
    \ */\n \n+  assert(NUM_BUFF_OVERSIZE_BYTES >= 3);\n+\n   little_endian = *((unsigned\
    \ char *)&little_endian) & '1';\n \n   initImageData(&image);\n@@ -3227,13 +3243,13\
    \ @@ extractContigSamples32bits (uint8_t *in, uint8_t *out, uint32_t cols,\n \
    \      /* If we have a full buffer's worth, write it out */\n       if (ready_bits\
    \ >= 32)\n         {\n-        bytebuff1 = (buff2 >> 56);\n+        bytebuff1\
    \ = (uint8_t)(buff2 >> 56);\n         *dst++ = bytebuff1;\n-        bytebuff2\
    \ = (buff2 >> 48);\n+        bytebuff2 = (uint8_t)(buff2 >> 48);\n         *dst++\
    \ = bytebuff2;\n-        bytebuff3 = (buff2 >> 40);\n+        bytebuff3 = (uint8_t)(buff2\
    \ >> 40);\n         *dst++ = bytebuff3;\n-        bytebuff4 = (buff2 >> 32);\n\
    +        bytebuff4 = (uint8_t)(buff2 >> 32);\n         *dst++ = bytebuff4;\n \
    \        ready_bits -= 32;\n                     \n@@ -3642,13 +3658,13 @@ extractContigSamplesShifted32bits\
    \ (uint8_t *in, uint8_t *out, uint32_t cols,\n         }\n       else  /* If we\
    \ have a full buffer's worth, write it out */\n         {\n-        bytebuff1\
    \ = (buff2 >> 56);\n+        bytebuff1 = (uint8_t)(buff2 >> 56);\n         *dst++\
    \ = bytebuff1;\n-        bytebuff2 = (buff2 >> 48);\n+        bytebuff2 = (uint8_t)(buff2\
    \ >> 48);\n         *dst++ = bytebuff2;\n-        bytebuff3 = (buff2 >> 40);\n\
    +        bytebuff3 = (uint8_t)(buff2 >> 40);\n         *dst++ = bytebuff3;\n-\
    \        bytebuff4 = (buff2 >> 32);\n+        bytebuff4 = (uint8_t)(buff2 >> 32);\n\
    \         *dst++ = bytebuff4;\n         ready_bits -= 32;\n                  \
    \   \n@@ -3825,10 +3841,10 @@ extractContigSamplesToTileBuffer(uint8_t *out, uint8_t\
    \ *in, uint32_t rows, uint3\n static int readContigStripsIntoBuffer (TIFF* in,\
    \ uint8_t* buf)\n {\n         uint8_t* bufp = buf;\n-        int32_t  bytes_read\
    \ = 0;\n+        tmsize_t  bytes_read = 0;\n         uint32_t strip, nstrips \
    \  = TIFFNumberOfStrips(in);\n-        uint32_t stripsize = TIFFStripSize(in);\n\
    -        uint32_t rows = 0;\n+        tmsize_t stripsize = TIFFStripSize(in);\n\
    +        tmsize_t rows = 0;\n         uint32_t rps = TIFFGetFieldDefaulted(in,\
    \ TIFFTAG_ROWSPERSTRIP, &rps);\n         tsize_t scanline_size = TIFFScanlineSize(in);\n\
    \ \n@@ -3841,11 +3857,11 @@ static int readContigStripsIntoBuffer (TIFF* in, uint8_t*\
    \ buf)\n                 bytes_read = TIFFReadEncodedStrip (in, strip, bufp, -1);\n\
    \                 rows = bytes_read / scanline_size;\n                 if ((strip\
    \ < (nstrips - 1)) && (bytes_read != (int32_t)stripsize))\n-                 \
    \       TIFFError(\"\", \"Strip %\"PRIu32\": read %\"PRId32\" bytes, strip size\
    \ %\"PRIu32,\n+                        TIFFError(\"\", \"Strip %\"PRIu32\": read\
    \ %\"PRId64\" bytes, strip size %\"PRIu64,\n                                 \
    \  strip + 1, bytes_read, stripsize);\n \n                 if (bytes_read < 0\
    \ && !ignore) {\n-                        TIFFError(\"\", \"Error reading strip\
    \ %\"PRIu32\" after %\"PRIu32\" rows\",\n+                        TIFFError(\"\
    \", \"Error reading strip %\"PRIu32\" after %\"PRIu64\" rows\",\n            \
    \                       strip, rows);\n                         return 0;\n  \
    \               }\n@@ -4310,13 +4326,13 @@ combineSeparateSamples32bits (uint8_t\
    \ *in[], uint8_t *out, uint32_t cols,\n \t/* If we have a full buffer's worth,\
    \ write it out */\n \tif (ready_bits >= 32)\n \t  {\n-\t  bytebuff1 = (buff2 >>\
    \ 56);\n+\t  bytebuff1 = (uint8_t)(buff2 >> 56);\n \t  *dst++ = bytebuff1;\n-\t\
    \  bytebuff2 = (buff2 >> 48);\n+\t  bytebuff2 = (uint8_t)(buff2 >> 48);\n \t \
    \ *dst++ = bytebuff2;\n-\t  bytebuff3 = (buff2 >> 40);\n+\t  bytebuff3 = (uint8_t)(buff2\
    \ >> 40);\n \t  *dst++ = bytebuff3;\n-\t  bytebuff4 = (buff2 >> 32);\n+\t  bytebuff4\
    \ = (uint8_t)(buff2 >> 32);\n \t  *dst++ = bytebuff4;\n \t  ready_bits -= 32;\n\
    \                     \n@@ -4359,10 +4375,10 @@ combineSeparateSamples32bits (uint8_t\
    \ *in[], uint8_t *out, uint32_t cols,\n \t         \"Row %3d, Col %3d, Src byte\
    \ offset %3d  bit offset %2d  Dst offset %3d\",\n \t\t row + 1, col + 1, src_byte,\
    \ src_bit, dst - out);\n \n-      dump_long (dumpfile, format, \"Match bits \"\
    , matchbits);\n+      dump_wide (dumpfile, format, \"Match bits \", matchbits);\n\
    \       dump_data (dumpfile, format, \"Src   bits \", src, 4);\n-      dump_long\
    \ (dumpfile, format, \"Buff1 bits \", buff1);\n-      dump_long (dumpfile, format,\
    \ \"Buff2 bits \", buff2);\n+      dump_wide (dumpfile, format, \"Buff1 bits \"\
    , buff1);\n+      dump_wide (dumpfile, format, \"Buff2 bits \", buff2);\n    \
    \   dump_byte (dumpfile, format, \"Write bits1\", bytebuff1);\n       dump_byte\
    \ (dumpfile, format, \"Write bits2\", bytebuff2);\n       dump_info (dumpfile,\
    \ format, \"\", \"Ready bits:  %2d\", ready_bits); \n@@ -4835,13 +4851,13 @@ combineSeparateTileSamples32bits\
    \ (uint8_t *in[], uint8_t *out, uint32_t cols,\n \t/* If we have a full buffer's\
    \ worth, write it out */\n \tif (ready_bits >= 32)\n \t  {\n-\t  bytebuff1 = (buff2\
    \ >> 56);\n+\t  bytebuff1 = (uint8_t)(buff2 >> 56);\n \t  *dst++ = bytebuff1;\n\
    -\t  bytebuff2 = (buff2 >> 48);\n+\t  bytebuff2 = (uint8_t)(buff2 >> 48);\n \t\
    \  *dst++ = bytebuff2;\n-\t  bytebuff3 = (buff2 >> 40);\n+\t  bytebuff3 = (uint8_t)(buff2\
    \ >> 40);\n \t  *dst++ = bytebuff3;\n-\t  bytebuff4 = (buff2 >> 32);\n+\t  bytebuff4\
    \ = (uint8_t)(buff2 >> 32);\n \t  *dst++ = bytebuff4;\n \t  ready_bits -= 32;\n\
    \                     \n@@ -4884,10 +4900,10 @@ combineSeparateTileSamples32bits\
    \ (uint8_t *in[], uint8_t *out, uint32_t cols,\n \t         \"Row %3d, Col %3d,\
    \ Src byte offset %3d  bit offset %2d  Dst offset %3d\",\n \t\t row + 1, col +\
    \ 1, src_byte, src_bit, dst - out);\n \n-      dump_long (dumpfile, format, \"\
    Match bits \", matchbits);\n+      dump_wide (dumpfile, format, \"Match bits \"\
    , matchbits);\n       dump_data (dumpfile, format, \"Src   bits \", src, 4);\n\
    -      dump_long (dumpfile, format, \"Buff1 bits \", buff1);\n-      dump_long\
    \ (dumpfile, format, \"Buff2 bits \", buff2);\n+      dump_wide (dumpfile, format,\
    \ \"Buff1 bits \", buff1);\n+      dump_wide (dumpfile, format, \"Buff2 bits \"\
    , buff2);\n       dump_byte (dumpfile, format, \"Write bits1\", bytebuff1);\n\
    \       dump_byte (dumpfile, format, \"Write bits2\", bytebuff2);\n       dump_info\
    \ (dumpfile, format, \"\", \"Ready bits:  %2d\", ready_bits); \n@@ -4910,7 +4926,7\
    \ @@ static int readSeparateStripsIntoBuffer (TIFF *in, uint8_t *obuf, uint32_t\
    \ lengt\n   {\n   int i, bytes_per_sample, bytes_per_pixel, shift_width, result\
    \ = 1;\n   uint32_t j;\n-  int32_t  bytes_read = 0;\n+  tmsize_t  bytes_read =\
    \ 0;\n   uint16_t bps = 0, planar;\n   uint32_t nstrips;\n   uint32_t strips_per_sample;\n\
    @@ -4976,7 +4992,7 @@ static int readSeparateStripsIntoBuffer (TIFF *in, uint8_t\
    \ *obuf, uint32_t lengt\n   for (s = 0; (s < spp) && (s < MAX_SAMPLES); s++)\n\
    \     {\n     srcbuffs[s] = NULL;\n-    buff = limitMalloc(stripsize + 3);\n+\
    \    buff = limitMalloc(stripsize + NUM_BUFF_OVERSIZE_BYTES);\n     if (!buff)\n\
    \       {\n       TIFFError (\"readSeparateStripsIntoBuffer\", \n@@ -4999,7 +5015,7\
    \ @@ static int readSeparateStripsIntoBuffer (TIFF *in, uint8_t *obuf, uint32_t\
    \ lengt\n       buff = srcbuffs[s];\n       strip = (s * strips_per_sample) +\
    \ j; \n       bytes_read = TIFFReadEncodedStrip (in, strip, buff, stripsize);\n\
    -      rows_this_strip = bytes_read / src_rowsize;\n+      rows_this_strip = (uint32_t)(bytes_read\
    \ / src_rowsize);\n       if (bytes_read < 0 && !ignore)\n         {\n       \
    \  TIFFError(TIFFFileName(in),\n@@ -6062,13 +6078,14 @@ loadImage(TIFF* in, struct\
    \ image_data *image, struct dump_opts *dump, unsigned c\n   uint16_t   input_compression\
    \ = 0, input_photometric = 0;\n   uint16_t   subsampling_horiz, subsampling_vert;\n\
    \   uint32_t   width = 0, length = 0;\n-  uint32_t   stsize = 0, tlsize = 0, buffsize\
    \ = 0, scanlinesize = 0;\n+  tmsize_t   stsize = 0, tlsize = 0, buffsize = 0;\n\
    +  tmsize_t   scanlinesize = 0;\n   uint32_t   tw = 0, tl = 0;       /* Tile width\
    \ and length */\n-  uint32_t   tile_rowsize = 0;\n+  tmsize_t   tile_rowsize =\
    \ 0;\n   unsigned char *read_buff = NULL;\n   unsigned char *new_buff  = NULL;\n\
    \   int      readunit = 0;\n-  static   uint32_t  prev_readsize = 0;\n+  static\
    \   tmsize_t  prev_readsize = 0;\n \n   TIFFGetFieldDefaulted(in, TIFFTAG_BITSPERSAMPLE,\
    \ &bps);\n   TIFFGetFieldDefaulted(in, TIFFTAG_SAMPLESPERPIXEL, &spp);\n@@ -6325,6\
    \ +6342,8 @@ loadImage(TIFF* in, struct image_data *image, struct dump_opts *dump,\
    \ unsigned c\n     /* The buffsize_check and the possible adaptation of buffsize\
    \ \n      * has to account also for padding of each line to a byte boundary. \n\
    \      * This is assumed by mirrorImage() and rotateImage().\n+     * Furthermore,\
    \ functions like extractContigSamplesShifted32bits()\n+     * need a buffer, which\
    \ is at least 3 bytes larger than the actual image.\n      * Otherwise buffer-overflow\
    \ might occur there.\n      */\n     buffsize_check = length * (uint32_t)(((width\
    \ * spp * bps) + 7) / 8);\n@@ -6376,7 +6395,7 @@ loadImage(TIFF* in, struct image_data\
    \ *image, struct dump_opts *dump, unsigned c\n         TIFFError(\"loadImage\"\
    , \"Unable to allocate/reallocate read buffer\");\n         return (-1);\n   \
    \  }\n-    read_buff = (unsigned char *)limitMalloc(buffsize+3);\n+    read_buff\
    \ = (unsigned char *)limitMalloc(buffsize + NUM_BUFF_OVERSIZE_BYTES);\n   }\n\
    \   else\n     {\n@@ -6387,11 +6406,11 @@ loadImage(TIFF* in, struct image_data\
    \ *image, struct dump_opts *dump, unsigned c\n           TIFFError(\"loadImage\"\
    , \"Unable to allocate/reallocate read buffer\");\n           return (-1);\n \
    \      }\n-      new_buff = _TIFFrealloc(read_buff, buffsize+3);\n+      new_buff\
    \ = _TIFFrealloc(read_buff, buffsize + NUM_BUFF_OVERSIZE_BYTES);\n       if (!new_buff)\n\
    \         {\n \tfree (read_buff);\n-        read_buff = (unsigned char *)limitMalloc(buffsize+3);\n\
    +        read_buff = (unsigned char *)limitMalloc(buffsize + NUM_BUFF_OVERSIZE_BYTES);\n\
    \         }\n       else\n         read_buff = new_buff;\n@@ -6464,8 +6483,13\
    \ @@ loadImage(TIFF* in, struct image_data *image, struct dump_opts *dump, unsigned\
    \ c\n     dump_info  (dump->infile, dump->format, \"\", \n                 \"\
    Bits per sample %\"PRIu16\", Samples per pixel %\"PRIu16, bps, spp);\n \n+   \
    \ if (scanlinesize > 0x0ffffffffULL) {\n+        dump_info(dump->infile, dump->format,\
    \ \"loadImage\",\n+            \"Attention: scanlinesize %\"PRIu64\" is larger\
    \ than UINT32_MAX.\\nFollowing dump might be wrong.\",\n+            scanlinesize);\n\
    +    }\n     for (i = 0; i < length; i++)\n-      dump_buffer(dump->infile, dump->format,\
    \ 1, scanlinesize, \n+      dump_buffer(dump->infile, dump->format, 1, (uint32_t)scanlinesize,\
    \ \n                   i, read_buff + (i * scanlinesize));\n     }\n   return\
    \ (0);\n@@ -7485,13 +7509,13 @@ writeSingleSection(TIFF *in, TIFF *out, struct\
    \ image_data *image,\n      if (TIFFGetField(in, TIFFTAG_NUMBEROFINKS, &ninks))\
    \ {\n        TIFFSetField(out, TIFFTAG_NUMBEROFINKS, ninks);\n        if (TIFFGetField(in,\
    \ TIFFTAG_INKNAMES, &inknames)) {\n-\t int inknameslen = strlen(inknames) + 1;\n\
    +\t int inknameslen = (int)strlen(inknames) + 1;\n \t const char* cp = inknames;\n\
    \ \t while (ninks > 1) {\n \t   cp = strchr(cp, '\\0');\n \t   if (cp) {\n \t\
    \     cp++;\n-\t     inknameslen += (strlen(cp) + 1);\n+\t     inknameslen +=\
    \ ((int)strlen(cp) + 1);\n \t   }\n \t   ninks--;\n          }\n@@ -7554,23 +7578,23\
    \ @@ createImageSection(uint32_t sectsize, unsigned char **sect_buff_ptr)\n \n\
    \   if (!sect_buff)\n     {\n-    sect_buff = (unsigned char *)limitMalloc(sectsize);\n\
    +    sect_buff = (unsigned char *)limitMalloc(sectsize + NUM_BUFF_OVERSIZE_BYTES);\n\
    \     if (!sect_buff)\n     {\n         TIFFError(\"createImageSection\", \"Unable\
    \ to allocate/reallocate section buffer\");\n         return (-1);\n     }\n-\
    \    _TIFFmemset(sect_buff, 0, sectsize);\n+    _TIFFmemset(sect_buff, 0, sectsize\
    \ + NUM_BUFF_OVERSIZE_BYTES);\n     }\n   else\n     {\n     if (prev_sectsize\
    \ < sectsize)\n       {\n-      new_buff = _TIFFrealloc(sect_buff, sectsize);\n\
    +      new_buff = _TIFFrealloc(sect_buff, sectsize + NUM_BUFF_OVERSIZE_BYTES);\n\
    \       if (!new_buff)\n         {\n           _TIFFfree (sect_buff);\n-     \
    \   sect_buff = (unsigned char *)limitMalloc(sectsize);\n+        sect_buff =\
    \ (unsigned char *)limitMalloc(sectsize + NUM_BUFF_OVERSIZE_BYTES);\n        \
    \ }\n       else\n         sect_buff = new_buff;\n@@ -7580,7 +7604,7 @@ createImageSection(uint32_t\
    \ sectsize, unsigned char **sect_buff_ptr)\n           TIFFError(\"createImageSection\"\
    , \"Unable to allocate/reallocate section buffer\");\n           return (-1);\n\
    \       }\n-      _TIFFmemset(sect_buff, 0, sectsize);\n+      _TIFFmemset(sect_buff,\
    \ 0, sectsize + NUM_BUFF_OVERSIZE_BYTES);\n       }\n     }\n \n@@ -7611,17 +7635,17\
    \ @@ processCropSelections(struct image_data *image, struct crop_mask *crop,\n\
    \     cropsize = crop->bufftotal;\n     crop_buff = seg_buffs[0].buffer; \n  \
    \   if (!crop_buff)\n-      crop_buff = (unsigned char *)limitMalloc(cropsize);\n\
    +      crop_buff = (unsigned char *)limitMalloc(cropsize + NUM_BUFF_OVERSIZE_BYTES);\n\
    \     else\n       {\n       prev_cropsize = seg_buffs[0].size;\n       if (prev_cropsize\
    \ < cropsize)\n         {\n-        next_buff = _TIFFrealloc(crop_buff, cropsize);\n\
    +        next_buff = _TIFFrealloc(crop_buff, cropsize + NUM_BUFF_OVERSIZE_BYTES);\n\
    \         if (! next_buff)\n           {\n           _TIFFfree (crop_buff);\n\
    -          crop_buff = (unsigned char *)limitMalloc(cropsize);\n+          crop_buff\
    \ = (unsigned char *)limitMalloc(cropsize + NUM_BUFF_OVERSIZE_BYTES);\n      \
    \     }\n         else\n           crop_buff = next_buff;\n@@ -7634,7 +7658,7\
    \ @@ processCropSelections(struct image_data *image, struct crop_mask *crop,\n\
    \       return (-1);\n       }\n  \n-    _TIFFmemset(crop_buff, 0, cropsize);\n\
    +    _TIFFmemset(crop_buff, 0, cropsize + NUM_BUFF_OVERSIZE_BYTES);\n     seg_buffs[0].buffer\
    \ = crop_buff;\n     seg_buffs[0].size = cropsize;\n \n@@ -7714,17 +7738,17 @@\
    \ processCropSelections(struct image_data *image, struct crop_mask *crop,\n  \
    \       cropsize = crop->bufftotal;\n       crop_buff = seg_buffs[i].buffer; \n\
    \       if (!crop_buff)\n-        crop_buff = (unsigned char *)limitMalloc(cropsize);\n\
    +        crop_buff = (unsigned char *)limitMalloc(cropsize + NUM_BUFF_OVERSIZE_BYTES);\n\
    \       else\n         {\n         prev_cropsize = seg_buffs[0].size;\n      \
    \   if (prev_cropsize < cropsize)\n           {\n-          next_buff = _TIFFrealloc(crop_buff,\
    \ cropsize);\n+          next_buff = _TIFFrealloc(crop_buff, cropsize + NUM_BUFF_OVERSIZE_BYTES);\n\
    \           if (! next_buff)\n             {\n             _TIFFfree (crop_buff);\n\
    -            crop_buff = (unsigned char *)limitMalloc(cropsize);\n+          \
    \  crop_buff = (unsigned char *)limitMalloc(cropsize + NUM_BUFF_OVERSIZE_BYTES);\n\
    \             }\n           else\n             crop_buff = next_buff;\n@@ -7737,7\
    \ +7761,7 @@ processCropSelections(struct image_data *image, struct crop_mask\
    \ *crop,\n         return (-1);\n         }\n  \n-      _TIFFmemset(crop_buff,\
    \ 0, cropsize);\n+      _TIFFmemset(crop_buff, 0, cropsize + NUM_BUFF_OVERSIZE_BYTES);\n\
    \       seg_buffs[i].buffer = crop_buff;\n       seg_buffs[i].size = cropsize;\n\
    \ \n@@ -7853,24 +7877,24 @@ createCroppedImage(struct image_data *image, struct\
    \ crop_mask *crop,\n   crop_buff = *crop_buff_ptr;\n   if (!crop_buff)\n     {\n\
    -    crop_buff = (unsigned char *)limitMalloc(cropsize);\n+    crop_buff = (unsigned\
    \ char *)limitMalloc(cropsize + NUM_BUFF_OVERSIZE_BYTES);\n     if (!crop_buff)\n\
    \     {\n         TIFFError(\"createCroppedImage\", \"Unable to allocate/reallocate\
    \ crop buffer\");\n         return (-1);\n     }\n-    _TIFFmemset(crop_buff,\
    \ 0, cropsize);\n+    _TIFFmemset(crop_buff, 0, cropsize + NUM_BUFF_OVERSIZE_BYTES);\n\
    \     prev_cropsize = cropsize;\n     }\n   else\n     {\n     if (prev_cropsize\
    \ < cropsize)\n       {\n-      new_buff = _TIFFrealloc(crop_buff, cropsize);\n\
    +      new_buff = _TIFFrealloc(crop_buff, cropsize + NUM_BUFF_OVERSIZE_BYTES);\n\
    \       if (!new_buff)\n         {\n \tfree (crop_buff);\n-        crop_buff =\
    \ (unsigned char *)limitMalloc(cropsize);\n+        crop_buff = (unsigned char\
    \ *)limitMalloc(cropsize + NUM_BUFF_OVERSIZE_BYTES);\n         }\n       else\n\
    \         crop_buff = new_buff;\n@@ -7879,7 +7903,7 @@ createCroppedImage(struct\
    \ image_data *image, struct crop_mask *crop,\n           TIFFError(\"createCroppedImage\"\
    , \"Unable to allocate/reallocate crop buffer\");\n           return (-1);\n \
    \      }\n-      _TIFFmemset(crop_buff, 0, cropsize);\n+      _TIFFmemset(crop_buff,\
    \ 0, cropsize + NUM_BUFF_OVERSIZE_BYTES);\n       }\n     }\n \n@@ -8177,13 +8201,13\
    \ @@ writeCroppedImage(TIFF *in, TIFF *out, struct image_data *image,\n      if\
    \ (TIFFGetField(in, TIFFTAG_NUMBEROFINKS, &ninks)) {\n        TIFFSetField(out,\
    \ TIFFTAG_NUMBEROFINKS, ninks);\n        if (TIFFGetField(in, TIFFTAG_INKNAMES,\
    \ &inknames)) {\n-\t int inknameslen = strlen(inknames) + 1;\n+\t int inknameslen\
    \ = (int)strlen(inknames) + 1;\n \t const char* cp = inknames;\n \t while (ninks\
    \ > 1) {\n \t   cp = strchr(cp, '\\0');\n \t   if (cp) {\n \t     cp++;\n-\t \
    \    inknameslen += (strlen(cp) + 1);\n+\t     inknameslen += ((int)strlen(cp)\
    \ + 1);\n \t   }\n \t   ninks--;\n          }\n@@ -8568,13 +8592,13 @@ rotateContigSamples32bits(uint16_t\
    \ rotation, uint16_t spp, uint16_t bps, uint32_\n         }\n       else /* If\
    \ we have a full buffer's worth, write it out */\n         {\n-        bytebuff1\
    \ = (buff2 >> 56);\n+        bytebuff1 = (uint8_t)(buff2 >> 56);\n         *dst++\
    \ = bytebuff1;\n-        bytebuff2 = (buff2 >> 48);\n+        bytebuff2 = (uint8_t)(buff2\
    \ >> 48);\n         *dst++ = bytebuff2;\n-        bytebuff3 = (buff2 >> 40);\n\
    +        bytebuff3 = (uint8_t)(buff2 >> 40);\n         *dst++ = bytebuff3;\n-\
    \        bytebuff4 = (buff2 >> 32);\n+        bytebuff4 = (uint8_t)(buff2 >> 32);\n\
    \         *dst++ = bytebuff4;\n         ready_bits -= 32;\n                  \
    \   \n@@ -8643,12 +8667,13 @@ rotateImage(uint16_t rotation, struct image_data\
    \ *image, uint32_t *img_width,\n               return (-1);\n     }\n \n-  if\
    \ (!(rbuff = (unsigned char *)limitMalloc(buffsize)))\n+  /* Add 3 padding bytes\
    \ for extractContigSamplesShifted32bits */\n+  if (!(rbuff = (unsigned char *)limitMalloc(buffsize\
    \ + NUM_BUFF_OVERSIZE_BYTES)))\n     {\n-    TIFFError(\"rotateImage\", \"Unable\
    \ to allocate rotation buffer of %1u bytes\", buffsize);\n+    TIFFError(\"rotateImage\"\
    , \"Unable to allocate rotation buffer of %1u bytes\", buffsize + NUM_BUFF_OVERSIZE_BYTES);\n\
    \     return (-1);\n     }\n-  _TIFFmemset(rbuff, '\\0', buffsize);\n+  _TIFFmemset(rbuff,\
    \ '\\0', buffsize + NUM_BUFF_OVERSIZE_BYTES);\n \n   ibuff = *ibuff_ptr;\n   switch\
    \ (rotation)\n@@ -9176,13 +9201,13 @@ reverseSamples32bits (uint16_t spp, uint16_t\
    \ bps, uint32_t width,\n         }\n       else /* If we have a full buffer's\
    \ worth, write it out */\n         {\n-        bytebuff1 = (buff2 >> 56);\n+ \
    \       bytebuff1 = (uint8_t)(buff2 >> 56);\n         *dst++ = bytebuff1;\n- \
    \       bytebuff2 = (buff2 >> 48);\n+        bytebuff2 = (uint8_t)(buff2 >> 48);\n\
    \         *dst++ = bytebuff2;\n-        bytebuff3 = (buff2 >> 40);\n+        bytebuff3\
    \ = (uint8_t)(buff2 >> 40);\n         *dst++ = bytebuff3;\n-        bytebuff4\
    \ = (buff2 >> 32);\n+        bytebuff4 = (uint8_t)(buff2 >> 32);\n         *dst++\
    \ = bytebuff4;\n         ready_bits -= 32;\n                     \n@@ -9273,12\
    \ +9298,13 @@ mirrorImage(uint16_t spp, uint16_t bps, uint16_t mirror, uint32_t\
    \ width, uint32_\n     {\n     case MIRROR_BOTH:\n     case MIRROR_VERT: \n- \
    \            line_buff = (unsigned char *)limitMalloc(rowsize);\n+           \
    \  line_buff = (unsigned char *)limitMalloc(rowsize + NUM_BUFF_OVERSIZE_BYTES);\n\
    \              if (line_buff == NULL)\n                {\n-\t       TIFFError\
    \ (\"mirrorImage\", \"Unable to allocate mirror line buffer of %1u bytes\", rowsize);\n\
    +\t       TIFFError (\"mirrorImage\", \"Unable to allocate mirror line buffer\
    \ of %1u bytes\", rowsize + NUM_BUFF_OVERSIZE_BYTES);\n                return\
    \ (-1);\n                }\n+             _TIFFmemset(line_buff, '\\0', rowsize\
    \ + NUM_BUFF_OVERSIZE_BYTES);\n \n              dst = ibuff + (rowsize * (length\
    \ - 1));\n              for (row = 0; row < length / 2; row++)\n@@ -9310,11 +9336,12\
    \ @@ mirrorImage(uint16_t spp, uint16_t bps, uint16_t mirror, uint32_t width,\
    \ uint32_\n \t\t}\n \t      else\n                 { /* non 8 bit per sample \
    \ data */\n-                if (!(line_buff = (unsigned char *)limitMalloc(rowsize\
    \ + 1)))\n+                if (!(line_buff = (unsigned char *)limitMalloc(rowsize\
    \ + NUM_BUFF_OVERSIZE_BYTES)))\n                   {\n                   TIFFError(\"\
    mirrorImage\", \"Unable to allocate mirror line buffer\");\n                 \
    \  return (-1);\n                   }\n+                _TIFFmemset(line_buff,\
    \ '\\0', rowsize + NUM_BUFF_OVERSIZE_BYTES);\n                 bytes_per_sample\
    \ = (bps + 7) / 8;\n                 bytes_per_pixel  = ((bps * spp) + 7) / 8;\n\
    \                 if (bytes_per_pixel < (bytes_per_sample + 1))\n@@ -9326,7 +9353,7\
    \ @@ mirrorImage(uint16_t spp, uint16_t bps, uint16_t mirror, uint32_t width,\
    \ uint32_\n                   {\n \t\t  row_offset = row * rowsize;\n        \
    \           src = ibuff + row_offset;\n-                  _TIFFmemset (line_buff,\
    \ '\\0', rowsize);\n+                  _TIFFmemset (line_buff, '\\0', rowsize\
    \ + NUM_BUFF_OVERSIZE_BYTES);\n                   switch (shift_width)\n     \
    \                {\n                     case 1: if (reverseSamples16bits(spp,\
    \ bps, width, src, line_buff))\n"
  identifiers:
  - CVE-2022-3598
  - CWE-787
  overview: LibTIFF 4.4.0 has an out-of-bounds write in extractContigSamplesShifted24bits
    in tools/tiffcrop.c:3604, allowing attackers to cause a denial-of-service via
    a crafted tiff file. For users that compile libtiff from sources, the fix is available
    with commit cfbb883b.
  references:
  - source: cve@gitlab.com
    tags:
    - Third Party Advisory
    - VDB Entry
    url: https://gitlab.com/gitlab-org/cves/-/blob/master/2022/CVE-2022-3598.json
  - source: cve@gitlab.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://gitlab.com/libtiff/libtiff/-/commit/cfbb883bf6ea7bedcb04177cc4e52d304522fdff
  - source: cve@gitlab.com
    tags:
    - Exploit
    - Issue Tracking
    - Patch
    - Third Party Advisory
    url: https://gitlab.com/libtiff/libtiff/-/issues/435
  - source: cve@gitlab.com
    tags:
    - Third Party Advisory
    url: https://lists.debian.org/debian-lts-announce/2023/01/msg00018.html
  - source: cve@gitlab.com
    tags:
    - Third Party Advisory
    url: https://security.netapp.com/advisory/ntap-20230110-0001/
  title: LibTIFF 4.4.0 has an out-of-bounds write in extractContigSamplesShifted24bits
    in tools/tiffcrop.c:3604, allowing attackers to cause a denial-of-service via
    a crafted tiff file. For users that compile libtiff from sources, the fix is available
    with commit cfbb883b.
- diff_content:
  - "--- a/libtiff/tif_dir.c\n+++ b/libtiff/tif_dir.c\n@@ -136,32 +136,30 @@ setExtraSamples(TIFF*\
    \ tif, va_list ap, uint32_t* v)\n }\n \n /*\n- * Confirm we have \"samplesperpixel\"\
    \ ink names separated by \\0.  Returns \n+ * Count ink names separated by \\0.\
    \  Returns\n  * zero if the ink names are not as expected.\n  */\n-static uint32_t\n\
    -checkInkNamesString(TIFF* tif, uint32_t slen, const char* s)\n+static uint16_t\n\
    +countInkNamesString(TIFF *tif, uint32_t slen, const char *s)\n {\n-\tTIFFDirectory*\
    \ td = &tif->tif_dir;\n-\tuint16_t i = td->td_samplesperpixel;\n+\tuint16_t i\
    \ = 0;\n+\tconst char *ep = s + slen;\n+\tconst char *cp = s;\n \n \tif (slen\
    \ > 0) {\n-\t\tconst char* ep = s+slen;\n-\t\tconst char* cp = s;\n-\t\tfor (;\
    \ i > 0; i--) {\n+\t\tdo {\n \t\t\tfor (; cp < ep && *cp != '\\0'; cp++) {}\n\
    \ \t\t\tif (cp >= ep)\n \t\t\t\tgoto bad;\n \t\t\tcp++;\t\t\t\t/* skip \\0 */\n\
    -\t\t}\n-\t\treturn ((uint32_t)(cp - s));\n+\t\t\ti++;\n+\t\t} while (cp < ep);\n\
    +\t\treturn (i);\n \t}\n bad:\n \tTIFFErrorExt(tif->tif_clientdata, \"TIFFSetField\"\
    ,\n-\t    \"%s: Invalid InkNames value; expecting %\"PRIu16\" names, found %\"\
    PRIu16,\n-\t    tif->tif_name,\n-\t    td->td_samplesperpixel,\n-\t    (uint16_t)(td->td_samplesperpixel-i));\n\
    +\t\t\"%s: Invalid InkNames value; no NUL at given buffer end location %\"PRIu32\"\
    , after %\"PRIu16\" ink\",\n+\t\ttif->tif_name, slen, i);\n \treturn (0);\n }\n\
    \ \n@@ -478,13 +476,61 @@ _TIFFVSetField(TIFF* tif, uint32_t tag, va_list ap)\n\
    \ \t\t_TIFFsetFloatArray(&td->td_refblackwhite, va_arg(ap, float*), 6);\n \t\t\
    break;\n \tcase TIFFTAG_INKNAMES:\n-\t\tv = (uint16_t) va_arg(ap, uint16_vap);\n\
    -\t\ts = va_arg(ap, char*);\n-\t\tv = checkInkNamesString(tif, v, s);\n-\t\tstatus\
    \ = v > 0;\n-\t\tif( v > 0 ) {\n-\t\t\t_TIFFsetNString(&td->td_inknames, s, v);\n\
    -\t\t\ttd->td_inknameslen = v;\n+\t\t{\n+\t\t\tv = (uint16_t) va_arg(ap, uint16_vap);\n\
    +\t\t\ts = va_arg(ap, char*);\n+\t\t\tuint16_t ninksinstring;\n+\t\t\tninksinstring\
    \ = countInkNamesString(tif, v, s);\n+\t\t\tstatus = ninksinstring > 0;\n+\t\t\
    \tif(ninksinstring > 0 ) {\n+\t\t\t\t_TIFFsetNString(&td->td_inknames, s, v);\n\
    +\t\t\t\ttd->td_inknameslen = v;\n+\t\t\t\t/* Set NumberOfInks to the value ninksinstring\
    \ */\n+\t\t\t\tif (TIFFFieldSet(tif, FIELD_NUMBEROFINKS))\n+\t\t\t\t{\n+\t\t\t\
    \t\tif (td->td_numberofinks != ninksinstring) {\n+\t\t\t\t\t\tTIFFErrorExt(tif->tif_clientdata,\
    \ module,\n+\t\t\t\t\t\t\t\"Warning %s; Tag %s:\\n  Value %\"PRIu16\" of NumberOfInks\
    \ is different from the number of inks %\"PRIu16\".\\n  -> NumberOfInks value\
    \ adapted to %\"PRIu16\"\",\n+\t\t\t\t\t\t\ttif->tif_name, fip->field_name, td->td_numberofinks,\
    \ ninksinstring, ninksinstring);\n+\t\t\t\t\t\ttd->td_numberofinks = ninksinstring;\n\
    +\t\t\t\t\t}\n+\t\t\t\t} else {\n+\t\t\t\t\ttd->td_numberofinks = ninksinstring;\n\
    +\t\t\t\t\tTIFFSetFieldBit(tif, FIELD_NUMBEROFINKS);\n+\t\t\t\t}\n+\t\t\t\tif\
    \ (TIFFFieldSet(tif, FIELD_SAMPLESPERPIXEL))\n+\t\t\t\t{\n+\t\t\t\t\tif (td->td_numberofinks\
    \ != td->td_samplesperpixel) {\n+\t\t\t\t\t\tTIFFErrorExt(tif->tif_clientdata,\
    \ module,\n+\t\t\t\t\t\t\t\"Warning %s; Tag %s:\\n  Value %\"PRIu16\" of NumberOfInks\
    \ is different from the SamplesPerPixel value %\"PRIu16\"\",\n+\t\t\t\t\t\t\t\
    tif->tif_name, fip->field_name, td->td_numberofinks, td->td_samplesperpixel);\n\
    +\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\tbreak;\n+\tcase TIFFTAG_NUMBEROFINKS:\n\
    +\t\tv = (uint16_t)va_arg(ap, uint16_vap);\n+\t\t/* If InkNames already set also\
    \ NumberOfInks is set accordingly and should be equal */\n+\t\tif (TIFFFieldSet(tif,\
    \ FIELD_INKNAMES))\n+\t\t{\n+\t\t\tif (v != td->td_numberofinks) {\n+\t\t\t\t\
    TIFFErrorExt(tif->tif_clientdata, module,\n+\t\t\t\t\t\"Error %s; Tag %s:\\n \
    \ It is not possible to set the value %\"PRIu32\" for NumberOfInks\\n  which is\
    \ different from the number of inks in the InkNames tag (%\"PRIu16\")\",\n+\t\t\
    \t\t\ttif->tif_name, fip->field_name, v, td->td_numberofinks);\n+\t\t\t\t/* Do\
    \ not set / overwrite number of inks already set by InkNames case accordingly.\
    \ */\n+\t\t\t\tstatus = 0;\n+\t\t\t}\n+\t\t} else {\n+\t\t\ttd->td_numberofinks\
    \ = (uint16_t)v;\n+\t\t\tif (TIFFFieldSet(tif, FIELD_SAMPLESPERPIXEL))\n+\t\t\t\
    {\n+\t\t\t\tif (td->td_numberofinks != td->td_samplesperpixel) {\n+\t\t\t\t\t\
    TIFFErrorExt(tif->tif_clientdata, module,\n+\t\t\t\t\t\t\"Warning %s; Tag %s:\\\
    n  Value %\"PRIu32\" of NumberOfInks is different from the SamplesPerPixel value\
    \ %\"PRIu16\"\",\n+\t\t\t\t\t\ttif->tif_name, fip->field_name, v, td->td_samplesperpixel);\n\
    +\t\t\t\t}\n+\t\t\t}\n \t\t}\n \t\tbreak;\n \tcase TIFFTAG_PERSAMPLE:\n@@ -986,34\
    \ +1032,6 @@ _TIFFVGetField(TIFF* tif, uint32_t tag, va_list ap)\n \tif (fip->field_bit\
    \ == FIELD_CUSTOM) {\n \t\tstandard_tag = 0;\n \t}\n-\t\n-        if( standard_tag\
    \ == TIFFTAG_NUMBEROFINKS )\n-        {\n-            int i;\n-            for\
    \ (i = 0; i < td->td_customValueCount; i++) {\n-                uint16_t val;\n\
    -                TIFFTagValue *tv = td->td_customValues + i;\n-              \
    \  if (tv->info->field_tag != standard_tag)\n-                    continue;\n\
    -                if( tv->value == NULL )\n-                    return 0;\n-  \
    \              val = *(uint16_t *)tv->value;\n-                /* Truncate to\
    \ SamplesPerPixel, since the */\n-                /* setting code for INKNAMES\
    \ assume that there are SamplesPerPixel */\n-                /* inknames. */\n\
    -                /* Fixes http://bugzilla.maptools.org/show_bug.cgi?id=2599 */\n\
    -                if( val > td->td_samplesperpixel )\n-                {\n-   \
    \                 TIFFWarningExt(tif->tif_clientdata,\"_TIFFVGetField\",\n-  \
    \                                 \"Truncating NumberOfInks from %u to %\"PRIu16,\n\
    -                                   val, td->td_samplesperpixel);\n-         \
    \           val = td->td_samplesperpixel;\n-                }\n-             \
    \   *va_arg(ap, uint16_t*) = val;\n-                return 1;\n-            }\n\
    -            return 0;\n-        }\n \n \tswitch (standard_tag) {\n \t\tcase TIFFTAG_SUBFILETYPE:\n\
    @@ -1195,6 +1213,9 @@ _TIFFVGetField(TIFF* tif, uint32_t tag, va_list ap)\n \t\
    \tcase TIFFTAG_INKNAMES:\n \t\t\t*va_arg(ap, const char**) = td->td_inknames;\n\
    \ \t\t\tbreak;\n+\t\tcase TIFFTAG_NUMBEROFINKS:\n+\t\t\t*va_arg(ap, uint16_t *)\
    \ = td->td_numberofinks;\n+\t\t\tbreak;\n \t\tdefault:\n \t\t\t{\n \t\t\t\tint\
    \ i;\n"
  - "--- a/libtiff/tif_dirinfo.c\n+++ b/libtiff/tif_dirinfo.c\n@@ -114,7 +114,7 @@\
    \ tiffFields[] = {\n \t{ TIFFTAG_SUBIFD, -1, -1, TIFF_IFD8, 0, TIFF_SETGET_C16_IFD8,\
    \ TIFF_SETGET_UNDEFINED, FIELD_SUBIFD, 1, 1, \"SubIFD\", (TIFFFieldArray*) &tiffFieldArray\
    \ },\n \t{ TIFFTAG_INKSET, 1, 1, TIFF_SHORT, 0, TIFF_SETGET_UINT16, TIFF_SETGET_UNDEFINED,\
    \ FIELD_CUSTOM, 0, 0, \"InkSet\", NULL },\n \t{ TIFFTAG_INKNAMES, -1, -1, TIFF_ASCII,\
    \ 0, TIFF_SETGET_C16_ASCII, TIFF_SETGET_UNDEFINED, FIELD_INKNAMES, 1, 1, \"InkNames\"\
    , NULL },\n-\t{ TIFFTAG_NUMBEROFINKS, 1, 1, TIFF_SHORT, 0, TIFF_SETGET_UINT16,\
    \ TIFF_SETGET_UNDEFINED, FIELD_CUSTOM, 1, 0, \"NumberOfInks\", NULL },\n+\t{ TIFFTAG_NUMBEROFINKS,\
    \ 1, 1, TIFF_SHORT, 0, TIFF_SETGET_UINT16, TIFF_SETGET_UNDEFINED, FIELD_NUMBEROFINKS,\
    \ 1, 0, \"NumberOfInks\", NULL },\n \t{ TIFFTAG_DOTRANGE, 2, 2, TIFF_SHORT, 0,\
    \ TIFF_SETGET_UINT16_PAIR, TIFF_SETGET_UNDEFINED, FIELD_CUSTOM, 0, 0, \"DotRange\"\
    , NULL },\n \t{ TIFFTAG_TARGETPRINTER, -1, -1, TIFF_ASCII, 0, TIFF_SETGET_ASCII,\
    \ TIFF_SETGET_UNDEFINED, FIELD_CUSTOM, 1, 0, \"TargetPrinter\", NULL },\n \t{\
    \ TIFFTAG_EXTRASAMPLES, -1, -1, TIFF_SHORT, 0, TIFF_SETGET_C16_UINT16, TIFF_SETGET_UNDEFINED,\
    \ FIELD_EXTRASAMPLES, 0, 1, \"ExtraSamples\", NULL },\n"
  - "--- a/libtiff/tif_dirwrite.c\n+++ b/libtiff/tif_dirwrite.c\n@@ -626,6 +626,11\
    \ @@ TIFFWriteDirectorySec(TIFF* tif, int isimage, int imagedone, uint64_t* pdiroff)\n\
    \ \t\t\t\tif (!TIFFWriteDirectoryTagAscii(tif,&ndir,dir,TIFFTAG_INKNAMES,tif->tif_dir.td_inknameslen,tif->tif_dir.td_inknames))\n\
    \ \t\t\t\t\tgoto bad;\n \t\t\t}\n+\t\t\tif (TIFFFieldSet(tif, FIELD_NUMBEROFINKS))\n\
    +\t\t\t{\n+\t\t\t\tif (!TIFFWriteDirectoryTagShort(tif, &ndir, dir, TIFFTAG_NUMBEROFINKS,\
    \ tif->tif_dir.td_numberofinks))\n+\t\t\t\t\tgoto bad;\n+\t\t\t}\n \t\t\tif (TIFFFieldSet(tif,FIELD_SUBIFD))\n\
    \ \t\t\t{\n \t\t\t\tif (!TIFFWriteDirectoryTagSubifd(tif,&ndir,dir))\n"
  - "--- a/libtiff/tif_print.c\n+++ b/libtiff/tif_print.c\n@@ -397,6 +397,10 @@ TIFFPrintDirectory(TIFF*\
    \ tif, FILE* fd, long flags)\n \t\t}\n                 fputs(\"\\n\", fd);\n \t\
    }\n+\tif (TIFFFieldSet(tif, FIELD_NUMBEROFINKS)) {\n+\t\tfprintf(fd, \"  NumberOfInks:\
    \ %d\\n\",\n+\t\t\ttd->td_numberofinks);\n+\t}\n \tif (TIFFFieldSet(tif,FIELD_THRESHHOLDING))\
    \ {\n \t\tfprintf(fd, \"  Thresholding: \");\n \t\tswitch (td->td_threshholding)\
    \ {\n"
  identifiers:
  - CVE-2022-3599
  - CWE-125
  overview: LibTIFF 4.4.0 has an out-of-bounds read in writeSingleSection in tools/tiffcrop.c:7345,
    allowing attackers to cause a denial-of-service via a crafted tiff file. For users
    that compile libtiff from sources, the fix is available with commit e8131125.
  references:
  - source: cve@gitlab.com
    tags:
    - Third Party Advisory
    - VDB Entry
    url: https://gitlab.com/gitlab-org/cves/-/blob/master/2022/CVE-2022-3599.json
  - source: cve@gitlab.com
    tags:
    - Patch
    url: https://gitlab.com/libtiff/libtiff/-/commit/e813112545942107551433d61afd16ac094ff246
  - source: cve@gitlab.com
    tags:
    - Exploit
    - Issue Tracking
    - Patch
    - Third Party Advisory
    url: https://gitlab.com/libtiff/libtiff/-/issues/398
  - source: cve@gitlab.com
    tags:
    - Third Party Advisory
    url: https://lists.debian.org/debian-lts-announce/2023/01/msg00018.html
  - source: cve@gitlab.com
    tags:
    - Third Party Advisory
    url: https://security.netapp.com/advisory/ntap-20230110-0001/
  - source: cve@gitlab.com
    tags:
    - Third Party Advisory
    url: https://www.debian.org/security/2023/dsa-5333
  title: LibTIFF 4.4.0 has an out-of-bounds read in writeSingleSection in tools/tiffcrop.c:7345,
    allowing attackers to cause a denial-of-service via a crafted tiff file. For users
    that compile libtiff from sources, the fix is available with commit e8131125.
- diff_content:
  - "--- a/tools/tiffcrop.c\n+++ b/tools/tiffcrop.c\n@@ -107,13 +107,15 @@\n  *  \
    \              selects which functions dump data, with higher numbers selecting\n\
    \  *                lower level, scanline level routines. Debug reports a limited\
    \ set\n  *                of messages to monitor progress without enabling dump\
    \ logs.\n- * \n- * Note:    The (-X|-Y), -Z, -z and -S options are mutually exclusive.\n\
    + *\n+ * Note 1:  The (-X|-Y), -Z, -z and -S options are mutually exclusive.\n\
    \  *          In no case should the options be applied to a given selection successively.\n\
    - */\n+ * Note 2:  Any of the -X, -Y, -Z and -z options together with other PAGE_MODE_x\
    \ options\n+ *          such as -H, -V, -P, -J or -K are not supported and may\
    \ cause buffer overflows.\n+  */\n \n-static   char tiffcrop_version_id[] = \"\
    2.5.1\";\n-static   char tiffcrop_rev_date[] = \"15-08-2022\";\n+static   char\
    \ tiffcrop_version_id[] = \"2.5.3\";\n+static   char tiffcrop_rev_date[] = \"\
    26-08-2022\";\n \n #include \"tif_config.h\"\n #include \"libport.h\"\n@@ -781,9\
    \ +783,12 @@ static const char usage_info[] =\n \"             The four debug/dump\
    \ options are independent, though it makes little sense to\\n\"\n \"         \
    \    specify a dump file without specifying a detail level.\\n\"\n \"\\n\"\n-\"\
    Note:        The (-X|-Y), -Z, -z and -S options are mutually exclusive.\\n\"\n\
    +\"Note 1:      The (-X|-Y), -Z, -z and -S options are mutually exclusive.\\n\"\
    \n \"             In no case should the options be applied to a given selection\
    \ successively.\\n\"\n \"\\n\"\n+\"Note 2:      Any of the -X, -Y, -Z and -z options\
    \ together with other PAGE_MODE_x options\\n\"\n+\"             such as - H, -V,\
    \ -P, -J or -K are not supported and may cause buffer overflows.\\n\"\n+\"\\n\"\
    \n ;\n \n /* This function could be modified to pass starting sample offset \n\
    @@ -2138,9 +2143,20 @@ void  process_command_opts (int argc, char *argv[], char\
    \ *mp, char *mode, uint32\n     R = (crop_data->crop_mode & CROP_REGIONS) ? 1\
    \ : 0;\n     S = (page->mode & PAGE_MODE_ROWSCOLS) ? 1 : 0;\n     if (XY + Z +\
    \ R + S > 1) {\n-        TIFFError(\"tiffcrop input error\", \"The crop options(-X|-Y),\
    \ -Z, -z and -S are mutually exclusive.->Exit\");\n+        TIFFError(\"tiffcrop\
    \ input error\", \"The crop options(-X|-Y), -Z, -z and -S are mutually exclusive.->exit\"\
    );\n         exit(EXIT_FAILURE);\n     }\n+\n+    /* Check for not allowed combination:\n\
    +     * Any of the -X, -Y, -Z and -z options together with other PAGE_MODE_x options\n\
    +     * such as -H, -V, -P, -J or -K are not supported and may cause buffer overflows.\n\
    +.    */\n+    if ((XY + Z + R > 0) && page->mode != PAGE_MODE_NONE) {\n+    \
    \    TIFFError(\"tiffcrop input error\",\n+            \"Any of the crop options\
    \ -X, -Y, -Z and -z together with other PAGE_MODE_x options such as - H, -V, -P,\
    \ -J or -K is not supported and may cause buffer overflows..->exit\");\n+    \
    \    exit(EXIT_FAILURE);\n+    }\n+\n   }  /* end process_command_opts */\n \n\
    \ /* Start a new output file if one has not been previously opened or\n@@ -2411,6\
    \ +2427,7 @@ main(int argc, char* argv[])\n         exit (EXIT_FAILURE);\n \t\
    }\n \n+      /* Crop input image and copy zones and regions from input image into\
    \ seg_buffs or crop_buff. */\n       if (crop.selections > 0)\n         {\n  \
    \       if (processCropSelections(&image, &crop, &read_buff, seg_buffs))\n@@ -2427,6\
    \ +2444,7 @@ main(int argc, char* argv[])\n           exit (EXIT_FAILURE);\n \t\
    \  }\n \t}\n+      /* Format and write selected image parts to output file(s).\
    \ */\n       if (page.mode == PAGE_MODE_NONE)\n         {  /* Whole image or sections\
    \ not based on output page size */\n         if (crop.selections > 0)\n"
  identifiers:
  - CVE-2022-3626
  - CWE-787
  overview: LibTIFF 4.4.0 has an out-of-bounds write in _TIFFmemset in libtiff/tif_unix.c:340
    when called from processCropSelections, tools/tiffcrop.c:7619, allowing attackers
    to cause a denial-of-service via a crafted tiff file. For users that compile libtiff
    from sources, the fix is available with commit 236b7191.
  references:
  - source: cve@gitlab.com
    tags:
    - Third Party Advisory
    - VDB Entry
    url: https://gitlab.com/gitlab-org/cves/-/blob/master/2022/CVE-2022-3626.json
  - source: cve@gitlab.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://gitlab.com/libtiff/libtiff/-/commit/236b7191f04c60d09ee836ae13b50f812c841047
  - source: cve@gitlab.com
    tags:
    - Exploit
    - Issue Tracking
    - Patch
    - Third Party Advisory
    url: https://gitlab.com/libtiff/libtiff/-/issues/426
  - source: cve@gitlab.com
    tags:
    - Mailing List
    - Third Party Advisory
    url: https://lists.debian.org/debian-lts-announce/2023/01/msg00018.html
  - source: cve@gitlab.com
    tags:
    - Third Party Advisory
    url: https://security.netapp.com/advisory/ntap-20230110-0001/
  title: LibTIFF 4.4.0 has an out-of-bounds write in _TIFFmemset in libtiff/tif_unix.c:340
    when called from processCropSelections, tools/tiffcrop.c:7619, allowing attackers
    to cause a denial-of-service via a crafted tiff file. For users that compile libtiff
    from sources, the fix is available with commit 236b7191.
- diff_content:
  - "--- a/tools/tiffcrop.c\n+++ b/tools/tiffcrop.c\n@@ -107,13 +107,15 @@\n  *  \
    \              selects which functions dump data, with higher numbers selecting\n\
    \  *                lower level, scanline level routines. Debug reports a limited\
    \ set\n  *                of messages to monitor progress without enabling dump\
    \ logs.\n- * \n- * Note:    The (-X|-Y), -Z, -z and -S options are mutually exclusive.\n\
    + *\n+ * Note 1:  The (-X|-Y), -Z, -z and -S options are mutually exclusive.\n\
    \  *          In no case should the options be applied to a given selection successively.\n\
    - */\n+ * Note 2:  Any of the -X, -Y, -Z and -z options together with other PAGE_MODE_x\
    \ options\n+ *          such as -H, -V, -P, -J or -K are not supported and may\
    \ cause buffer overflows.\n+  */\n \n-static   char tiffcrop_version_id[] = \"\
    2.5.1\";\n-static   char tiffcrop_rev_date[] = \"15-08-2022\";\n+static   char\
    \ tiffcrop_version_id[] = \"2.5.3\";\n+static   char tiffcrop_rev_date[] = \"\
    26-08-2022\";\n \n #include \"tif_config.h\"\n #include \"libport.h\"\n@@ -781,9\
    \ +783,12 @@ static const char usage_info[] =\n \"             The four debug/dump\
    \ options are independent, though it makes little sense to\\n\"\n \"         \
    \    specify a dump file without specifying a detail level.\\n\"\n \"\\n\"\n-\"\
    Note:        The (-X|-Y), -Z, -z and -S options are mutually exclusive.\\n\"\n\
    +\"Note 1:      The (-X|-Y), -Z, -z and -S options are mutually exclusive.\\n\"\
    \n \"             In no case should the options be applied to a given selection\
    \ successively.\\n\"\n \"\\n\"\n+\"Note 2:      Any of the -X, -Y, -Z and -z options\
    \ together with other PAGE_MODE_x options\\n\"\n+\"             such as - H, -V,\
    \ -P, -J or -K are not supported and may cause buffer overflows.\\n\"\n+\"\\n\"\
    \n ;\n \n /* This function could be modified to pass starting sample offset \n\
    @@ -2138,9 +2143,20 @@ void  process_command_opts (int argc, char *argv[], char\
    \ *mp, char *mode, uint32\n     R = (crop_data->crop_mode & CROP_REGIONS) ? 1\
    \ : 0;\n     S = (page->mode & PAGE_MODE_ROWSCOLS) ? 1 : 0;\n     if (XY + Z +\
    \ R + S > 1) {\n-        TIFFError(\"tiffcrop input error\", \"The crop options(-X|-Y),\
    \ -Z, -z and -S are mutually exclusive.->Exit\");\n+        TIFFError(\"tiffcrop\
    \ input error\", \"The crop options(-X|-Y), -Z, -z and -S are mutually exclusive.->exit\"\
    );\n         exit(EXIT_FAILURE);\n     }\n+\n+    /* Check for not allowed combination:\n\
    +     * Any of the -X, -Y, -Z and -z options together with other PAGE_MODE_x options\n\
    +     * such as -H, -V, -P, -J or -K are not supported and may cause buffer overflows.\n\
    +.    */\n+    if ((XY + Z + R > 0) && page->mode != PAGE_MODE_NONE) {\n+    \
    \    TIFFError(\"tiffcrop input error\",\n+            \"Any of the crop options\
    \ -X, -Y, -Z and -z together with other PAGE_MODE_x options such as - H, -V, -P,\
    \ -J or -K is not supported and may cause buffer overflows..->exit\");\n+    \
    \    exit(EXIT_FAILURE);\n+    }\n+\n   }  /* end process_command_opts */\n \n\
    \ /* Start a new output file if one has not been previously opened or\n@@ -2411,6\
    \ +2427,7 @@ main(int argc, char* argv[])\n         exit (EXIT_FAILURE);\n \t\
    }\n \n+      /* Crop input image and copy zones and regions from input image into\
    \ seg_buffs or crop_buff. */\n       if (crop.selections > 0)\n         {\n  \
    \       if (processCropSelections(&image, &crop, &read_buff, seg_buffs))\n@@ -2427,6\
    \ +2444,7 @@ main(int argc, char* argv[])\n           exit (EXIT_FAILURE);\n \t\
    \  }\n \t}\n+      /* Format and write selected image parts to output file(s).\
    \ */\n       if (page.mode == PAGE_MODE_NONE)\n         {  /* Whole image or sections\
    \ not based on output page size */\n         if (crop.selections > 0)\n"
  identifiers:
  - CVE-2022-3627
  - CWE-787
  overview: LibTIFF 4.4.0 has an out-of-bounds write in _TIFFmemcpy in libtiff/tif_unix.c:346
    when called from extractImageSection, tools/tiffcrop.c:6860, allowing attackers
    to cause a denial-of-service via a crafted tiff file. For users that compile libtiff
    from sources, the fix is available with commit 236b7191.
  references:
  - source: cve@gitlab.com
    tags:
    - Third Party Advisory
    - VDB Entry
    url: https://gitlab.com/gitlab-org/cves/-/blob/master/2022/CVE-2022-3627.json
  - source: cve@gitlab.com
    tags:
    - Patch
    url: https://gitlab.com/libtiff/libtiff/-/commit/236b7191f04c60d09ee836ae13b50f812c841047
  - source: cve@gitlab.com
    tags:
    - Exploit
    - Patch
    - Third Party Advisory
    url: https://gitlab.com/libtiff/libtiff/-/issues/411
  - source: cve@gitlab.com
    tags:
    - Third Party Advisory
    url: https://lists.debian.org/debian-lts-announce/2023/01/msg00018.html
  - source: cve@gitlab.com
    tags:
    - Third Party Advisory
    url: https://security.netapp.com/advisory/ntap-20230110-0001/
  - source: cve@gitlab.com
    tags:
    - Third Party Advisory
    url: https://www.debian.org/security/2023/dsa-5333
  title: LibTIFF 4.4.0 has an out-of-bounds write in _TIFFmemcpy in libtiff/tif_unix.c:346
    when called from extractImageSection, tools/tiffcrop.c:6860, allowing attackers
    to cause a denial-of-service via a crafted tiff file. For users that compile libtiff
    from sources, the fix is available with commit 236b7191.
- diff_content:
  - "--- a/src/debug.c\n+++ b/src/debug.c\n@@ -1123,73 +1123,88 @@ void bugReportStart(void)\
    \ {\n }\n \n #ifdef HAVE_BACKTRACE\n-static void *getMcontextEip(ucontext_t *uc)\
    \ {\n+\n+/* Returns the current eip and set it to the given new value (if its\
    \ not NULL) */\n+static void* getAndSetMcontextEip(ucontext_t *uc, void *eip)\
    \ {\n #define NOT_SUPPORTED() do {\\\n     UNUSED(uc);\\\n+    UNUSED(eip);\\\n\
    \     return NULL;\\\n } while(0)\n+#define GET_SET_RETURN(target_var, new_val)\
    \ do {\\\n+    void *old_val = (void*)target_var; \\\n+    if (new_val) { \\\n\
    +        void **temp = (void**)&target_var; \\\n+        *temp = new_val; \\\n\
    +    } \\\n+    return old_val; \\\n+} while(0)\n #if defined(__APPLE__) && !defined(MAC_OS_X_VERSION_10_6)\n\
    \     /* OSX < 10.6 */\n     #if defined(__x86_64__)\n-    return (void*) uc->uc_mcontext->__ss.__rip;\n\
    +    GET_SET_RETURN(uc->uc_mcontext->__ss.__rip, eip);\n     #elif defined(__i386__)\n\
    -    return (void*) uc->uc_mcontext->__ss.__eip;\n+    GET_SET_RETURN(uc->uc_mcontext->__ss.__eip,\
    \ eip);\n     #else\n-    return (void*) uc->uc_mcontext->__ss.__srr0;\n+    GET_SET_RETURN(uc->uc_mcontext->__ss.__srr0,\
    \ eip);\n     #endif\n #elif defined(__APPLE__) && defined(MAC_OS_X_VERSION_10_6)\n\
    \     /* OSX >= 10.6 */\n     #if defined(_STRUCT_X86_THREAD_STATE64) && !defined(__i386__)\n\
    -    return (void*) uc->uc_mcontext->__ss.__rip;\n+    GET_SET_RETURN(uc->uc_mcontext->__ss.__rip,\
    \ eip);\n     #elif defined(__i386__)\n-    return (void*) uc->uc_mcontext->__ss.__eip;\n\
    +    GET_SET_RETURN(uc->uc_mcontext->__ss.__eip, eip);\n     #else\n     /* OSX\
    \ ARM64 */\n-    return (void*) arm_thread_state64_get_pc(uc->uc_mcontext->__ss);\n\
    +    void *old_val = (void*)arm_thread_state64_get_pc(uc->uc_mcontext->__ss);\n\
    +    if (eip) {\n+        arm_thread_state64_set_pc_fptr(uc->uc_mcontext->__ss,\
    \ eip);\n+    }\n+    return old_val;\n     #endif\n #elif defined(__linux__)\n\
    \     /* Linux */\n     #if defined(__i386__) || ((defined(__X86_64__) || defined(__x86_64__))\
    \ && defined(__ILP32__))\n-    return (void*) uc->uc_mcontext.gregs[14]; /* Linux\
    \ 32 */\n+    GET_SET_RETURN(uc->uc_mcontext.gregs[14], eip);\n     #elif defined(__X86_64__)\
    \ || defined(__x86_64__)\n-    return (void*) uc->uc_mcontext.gregs[16]; /* Linux\
    \ 64 */\n+    GET_SET_RETURN(uc->uc_mcontext.gregs[16], eip);\n     #elif defined(__ia64__)\
    \ /* Linux IA64 */\n-    return (void*) uc->uc_mcontext.sc_ip;\n+    GET_SET_RETURN(uc->uc_mcontext.sc_ip,\
    \ eip);\n     #elif defined(__arm__) /* Linux ARM */\n-    return (void*) uc->uc_mcontext.arm_pc;\n\
    +    GET_SET_RETURN(uc->uc_mcontext.arm_pc, eip);\n     #elif defined(__aarch64__)\
    \ /* Linux AArch64 */\n-    return (void*) uc->uc_mcontext.pc;\n+    GET_SET_RETURN(uc->uc_mcontext.pc,\
    \ eip);\n     #else\n     NOT_SUPPORTED();\n     #endif\n #elif defined(__FreeBSD__)\n\
    \     /* FreeBSD */\n     #if defined(__i386__)\n-    return (void*) uc->uc_mcontext.mc_eip;\n\
    +    GET_SET_RETURN(uc->uc_mcontext.mc_eip, eip);\n     #elif defined(__x86_64__)\n\
    -    return (void*) uc->uc_mcontext.mc_rip;\n+    GET_SET_RETURN(uc->uc_mcontext.mc_rip,\
    \ eip);\n     #else\n     NOT_SUPPORTED();\n     #endif\n #elif defined(__OpenBSD__)\n\
    \     /* OpenBSD */\n     #if defined(__i386__)\n-    return (void*) uc->sc_eip;\n\
    +    GET_SET_RETURN(uc->sc_eip, eip);\n     #elif defined(__x86_64__)\n-    return\
    \ (void*) uc->sc_rip;\n+    GET_SET_RETURN(uc->sc_rip, eip);\n     #else\n   \
    \  NOT_SUPPORTED();\n     #endif\n #elif defined(__NetBSD__)\n     #if defined(__i386__)\n\
    -    return (void*) uc->uc_mcontext.__gregs[_REG_EIP];\n+    GET_SET_RETURN(uc->uc_mcontext.__gregs[_REG_EIP],\
    \ eip);\n     #elif defined(__x86_64__)\n-    return (void*) uc->uc_mcontext.__gregs[_REG_RIP];\n\
    +    GET_SET_RETURN(uc->uc_mcontext.__gregs[_REG_RIP], eip);\n     #else\n   \
    \  NOT_SUPPORTED();\n     #endif\n #elif defined(__DragonFly__)\n-    return (void*)\
    \ uc->uc_mcontext.mc_rip;\n+    GET_SET_RETURN(uc->uc_mcontext.mc_rip, eip);\n\
    \ #else\n     NOT_SUPPORTED();\n #endif\n@@ -1951,6 +1966,10 @@ void dumpCodeAroundEIP(void\
    \ *eip) {\n     }\n }\n \n+void invalidFunctionWasCalled() {}\n+\n+typedef void\
    \ (*invalidFunctionWasCalledType)();\n+\n void sigsegvHandler(int sig, siginfo_t\
    \ *info, void *secret) {\n     UNUSED(secret);\n     UNUSED(info);\n@@ -1968,13\
    \ +1987,30 @@ void sigsegvHandler(int sig, siginfo_t *info, void *secret) {\n\
    \ \n #ifdef HAVE_BACKTRACE\n     ucontext_t *uc = (ucontext_t*) secret;\n-   \
    \ void *eip = getMcontextEip(uc);\n+    void *eip = getAndSetMcontextEip(uc, NULL);\n\
    \     if (eip != NULL) {\n         serverLog(LL_WARNING,\n         \"Crashed running\
    \ the instruction at: %p\", eip);\n     }\n \n-    logStackTrace(getMcontextEip(uc),\
    \ 1);\n+    if (eip == info->si_addr) {\n+        /* When eip matches the bad\
    \ address, it's an indication that we crashed when calling a non-mapped\n+   \
    \      * function pointer. In that case the call to backtrace will crash trying\
    \ to access that address and we\n+         * won't get a crash report logged.\
    \ Set it to a valid point to avoid that crash. */\n+\n+        /* This trick allow\
    \ to avoid compiler warning */\n+        void *ptr;\n+        invalidFunctionWasCalledType\
    \ *ptr_ptr = (invalidFunctionWasCalledType*)&ptr;\n+        *ptr_ptr = invalidFunctionWasCalled;\n\
    +        getAndSetMcontextEip(uc, ptr);\n+    }\n+\n+    logStackTrace(eip, 1);\n\
    +\n+    if (eip == info->si_addr) {\n+        /* Restore old eip */\n+       \
    \ getAndSetMcontextEip(uc, eip);\n+    }\n \n     logRegisters(uc);\n #endif\n\
    @@ -2079,7 +2115,7 @@ void watchdogSignalHandler(int sig, siginfo_t *info, void\
    \ *secret) {\n \n     serverLogFromHandler(LL_WARNING,\"\\n--- WATCHDOG TIMER\
    \ EXPIRED ---\");\n #ifdef HAVE_BACKTRACE\n-    logStackTrace(getMcontextEip(uc),\
    \ 1);\n+    logStackTrace(getAndSetMcontextEip(uc, NULL), 1);\n #else\n     serverLogFromHandler(LL_WARNING,\"\
    Sorry: no support for backtrace().\");\n #endif"
  identifiers:
  - CVE-2022-3647
  - CWE-404
  overview: '** DISPUTED ** A vulnerability, which was classified as problematic,
    was found in Redis up to 6.2.7/7.0.5. Affected is the function sigsegvHandler
    of the file debug.c of the component Crash Report. The manipulation leads to denial
    of service. The complexity of an attack is rather high. The exploitability is
    told to be difficult. The real existence of this vulnerability is still doubted
    at the moment. Upgrading to version 6.2.8 and 7.0.6 is able to address this issue.
    The patch is identified as 0bf90d944313919eb8e63d3588bf63a367f020a3. It is recommended
    to apply a patch to fix this issue. VDB-211962 is the identifier assigned to this
    vulnerability. NOTE: The vendor claims that this is not a DoS because it applies
    to the crash logging mechanism which is triggered after a crash has occurred.'
  references:
  - source: cna@vuldb.com
    tags:
    - Exploit
    - Patch
    - Third Party Advisory
    url: https://github.com/redis/redis/commit/0bf90d944313919eb8e63d3588bf63a367f020a3
  - source: cna@vuldb.com
    tags:
    - Permissions Required
    - Third Party Advisory
    - VDB Entry
    url: https://vuldb.com/?ctiid.211962
  - source: cna@vuldb.com
    tags:
    - Third Party Advisory
    - VDB Entry
    url: https://vuldb.com/?id.211962
  title: '** DISPUTED ** A vulnerability, which was classified as problematic, was
    found in Redis up to 6.2.7/7.0.5. Affected is the function sigsegvHandler of the
    file debug.c of the component Crash Report. The manipulation leads to denial of
    service. The complexity of an attack is rather high. The exploitability is told
    to be difficult. The real existence of this vulnerability is still doubted at
    the moment. Upgrading to version 6.2.8 and 7.0.6 is able to address this issue.
    The patch is identified as 0bf90d944313919eb8e63d3588bf63a367f020a3. It is recommended
    to apply a patch to fix this issue. VDB-211962 is the identifier assigned to this
    vulnerability. NOTE: The vendor claims that this is not a DoS because it applies
    to the crash logging mechanism which is triggered after a crash has occurred.'
- diff_content:
  - "--- a/src/json/iwjson.c\n+++ b/src/json/iwjson.c\n@@ -26,7 +26,7 @@ static void\
    \ _jbn_add_item(JBL_NODE parent, JBL_NODE node);\n \n void iwjson_ftoa(long double\
    \ val, char buf[static IWNUMBUF_SIZE], size_t *out_len) {\n   // TODO: review\n\
    -  int len = snprintf(buf, 64, \"%.8Lf\", val);\n+  int len = snprintf(buf, IWNUMBUF_SIZE,\
    \ \"%.8Lf\", val);\n   if (len <= 0) {\n     buf[0] = '\\0';\n     *out_len =\
    \ 0;"
  identifiers:
  - CVE-2022-23462
  - CWE-787
  overview: IOWOW is a C utility library and persistent key/value storage engine.
    Versions 1.4.15 and prior contain a stack buffer overflow vulnerability that allows
    for Denial of Service (DOS) when it parses scientific notation numbers present
    in JSON. A patch for this issue is available at commit a79d31e4cff1d5a08f665574b29fd885897a28fd
    in the `master` branch of the repository. There are no workarounds other than
    applying the patch.
  references:
  - source: security-advisories@github.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/Softmotions/iowow/commit/a79d31e4cff1d5a08f665574b29fd885897a28fd
  - source: security-advisories@github.com
    tags:
    - Exploit
    - Third Party Advisory
    url: https://securitylab.github.com/advisories/GHSL-2022-066_iowow/
  title: IOWOW is a C utility library and persistent key/value storage engine. Versions
    1.4.15 and prior contain a stack buffer overflow vulnerability that allows for
    Denial of Service (DOS) when it parses scientific notation numbers present in
    JSON. A patch for this issue is available at commit a79d31e4cff1d5a08f665574b29fd885897a28fd
    in the `master` branch of the repository. There are no workarounds other than
    applying the patch.
- diff_content:
  - "--- a/drivers/usb/mon/mon_bin.c\n+++ b/drivers/usb/mon/mon_bin.c\n@@ -1268,6\
    \ +1268,11 @@ static int mon_bin_mmap(struct file *filp, struct vm_area_struct\
    \ *vma)\n {\n \t/* don't do anything here: \"fault\" will set up page table entries\
    \ */\n \tvma->vm_ops = &mon_bin_vm_ops;\n+\n+\tif (vma->vm_flags & VM_WRITE)\n\
    +\t\treturn -EPERM;\n+\n+\tvma->vm_flags &= ~VM_MAYWRITE;\n \tvma->vm_flags |=\
    \ VM_DONTEXPAND | VM_DONTDUMP;\n \tvma->vm_private_data = filp->private_data;\n\
    \ \tmon_bin_vma_open(vma);"
  identifiers:
  - CVE-2022-43750
  - CWE-787
  overview: drivers/usb/mon/mon_bin.c in usbmon in the Linux kernel before 5.19.15
    and 6.x before 6.0.1 allows a user-space client to corrupt the monitor's internal
    memory.
  references:
  - source: cve@mitre.org
    tags:
    - Release Notes
    - Vendor Advisory
    url: https://cdn.kernel.org/pub/linux/kernel/v5.x/ChangeLog-5.19.15
  - source: cve@mitre.org
    tags:
    - Release Notes
    - Vendor Advisory
    url: https://cdn.kernel.org/pub/linux/kernel/v6.x/ChangeLog-6.0.1
  - source: cve@mitre.org
    tags:
    - Patch
    - Vendor Advisory
    url: https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=a659daf63d16aa883be42f3f34ff84235c302198
  - source: cve@mitre.org
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/torvalds/linux/commit/a659daf63d16aa883be42f3f34ff84235c302198
  - source: cve@mitre.org
    tags:
    - Mailing List
    - Third Party Advisory
    url: https://lists.debian.org/debian-lts-announce/2022/11/msg00001.html
  - source: cve@mitre.org
    tags:
    - Mailing List
    - Third Party Advisory
    url: https://lists.debian.org/debian-lts-announce/2022/12/msg00034.html
  title: drivers/usb/mon/mon_bin.c in usbmon in the Linux kernel before 5.19.15 and
    6.x before 6.0.1 allows a user-space client to corrupt the monitor's internal
    memory.
- diff_content:
  - "--- a/src/quickfix.c\n+++ b/src/quickfix.c\n@@ -4595,6 +4595,9 @@ qf_update_buffer(qf_info_T\
    \ *qi, qfline_T *old_last)\n \t    qf_winid = win->w_id;\n \t}\n \n+\t// autocommands\
    \ may cause trouble\n+\tincr_quickfix_busy();\n+\n \tif (old_last == NULL)\n \t\
    \    // set curwin/curbuf to buf and save a few things\n \t    aucmd_prepbuf(&aco,\
    \ buf);\n@@ -4616,6 +4619,9 @@ qf_update_buffer(qf_info_T *qi, qfline_T *old_last)\n\
    \ \t// when the added lines are not visible.\n \tif ((win = qf_find_win(qi)) !=\
    \ NULL && old_line_count < win->w_botline)\n \t    redraw_buf_later(buf, UPD_NOT_VALID);\n\
    +\n+\t// always called after incr_quickfix_busy()\n+\tdecr_quickfix_busy();\n\
    \     }\n }\n "
  - "--- a/src/version.c\n+++ b/src/version.c\n@@ -695,6 +695,8 @@ static char *(features[])\
    \ =\n \n static int included_patches[] =\n {   /* Add new patch number below this\
    \ line */\n+/**/\n+    805,\n /**/\n     804,\n /**/"
  identifiers:
  - CVE-2022-3705
  - CWE-119
  overview: A vulnerability was found in vim and classified as problematic. Affected
    by this issue is the function qf_update_buffer of the file quickfix.c of the component
    autocmd Handler. The manipulation leads to use after free. The attack may be launched
    remotely. Upgrading to version 9.0.0805 is able to address this issue. The name
    of the patch is d0fab10ed2a86698937e3c3fed2f10bd9bb5e731. It is recommended to
    upgrade the affected component. The identifier of this vulnerability is VDB-212324.
  references:
  - source: cna@vuldb.com
    tags:
    - Third Party Advisory
    url: http://seclists.org/fulldisclosure/2023/Jan/19
  - source: cna@vuldb.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/vim/vim/commit/d0fab10ed2a86698937e3c3fed2f10bd9bb5e731
  - source: cna@vuldb.com
    tags:
    - Mailing List
    - Third Party Advisory
    url: https://lists.debian.org/debian-lts-announce/2022/11/msg00009.html
  - source: cna@vuldb.com
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/4JCW33NOLMELTTTDJH7WGDIFJZ5YEEMK/
  - source: cna@vuldb.com
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/GTBVD4J2SKVSWK4VBN5JP5OEVK6GDS3N/
  - source: cna@vuldb.com
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/JYEK5RNMH7MVQH6RPBKLSCCA6NMIKHDV/
  - source: cna@vuldb.com
    url: https://security.gentoo.org/glsa/202305-16
  - source: cna@vuldb.com
    tags:
    - Third Party Advisory
    url: https://security.netapp.com/advisory/ntap-20221223-0004/
  - source: cna@vuldb.com
    tags:
    - Third Party Advisory
    url: https://support.apple.com/kb/HT213605
  - source: cna@vuldb.com
    tags:
    - Permissions Required
    - Third Party Advisory
    url: https://vuldb.com/?id.212324
  title: A vulnerability was found in vim and classified as problematic. Affected
    by this issue is the function qf_update_buffer of the file quickfix.c of the component
    autocmd Handler. The manipulation leads to use after free. The attack may be launched
    remotely. Upgrading to version 9.0.0805 is able to address this issue. The name
    of the patch is d0fab10ed2a86698937e3c3fed2f10bd9bb5e731. It is recommended to
    upgrade the affected component. The identifier of this vulnerability is VDB-212324.
- diff_content:
  - "--- a/src/njs_json.c\n+++ b/src/njs_json.c\n@@ -28,27 +28,17 @@ typedef struct\
    \ {\n     int64_t                    length;\n     njs_array_t               \
    \ *keys;\n     njs_value_t                *key;\n-    njs_object_prop_t      \
    \    *prop;\n+    njs_value_t                prop;\n } njs_json_state_t;\n \n\
    \ \n-typedef struct {\n-    njs_value_t                retval;\n-\n-    njs_uint_t\
    \                 depth;\n-#define NJS_JSON_MAX_DEPTH     32\n-    njs_json_state_t\
    \           states[NJS_JSON_MAX_DEPTH];\n-\n-    njs_function_t             *function;\n\
    -} njs_json_parse_t;\n-\n-\n typedef struct {\n     njs_value_t              \
    \  retval;\n \n     njs_vm_t                   *vm;\n \n     njs_uint_t      \
    \           depth;\n+#define NJS_JSON_MAX_DEPTH     32\n     njs_json_state_t\
    \           states[NJS_JSON_MAX_DEPTH];\n \n     njs_value_t                replacer;\n\
    @@ -72,10 +62,9 @@ njs_inline uint32_t njs_json_unicode(const u_char *p);\n static\
    \ const u_char *njs_json_skip_space(const u_char *start,\n     const u_char *end);\n\
    \ \n-static njs_int_t njs_json_parse_iterator(njs_vm_t *vm, njs_json_parse_t *parse,\n\
    -    njs_value_t *value);\n-static njs_int_t njs_json_parse_iterator_call(njs_vm_t\
    \ *vm,\n-    njs_json_parse_t *parse, njs_json_state_t *state);\n+static njs_int_t\
    \ njs_json_internalize_property(njs_vm_t *vm,\n+    njs_function_t *reviver, njs_value_t\
    \ *holder, njs_value_t *name,\n+    njs_int_t depth, njs_value_t *retval);\n static\
    \ void njs_json_parse_exception(njs_json_parse_ctx_t *ctx,\n     const char *msg,\
    \ const u_char *pos);\n \n@@ -108,15 +97,13 @@ njs_json_parse(njs_vm_t *vm, njs_value_t\
    \ *args, njs_uint_t nargs,\n     njs_index_t unused)\n {\n     njs_int_t     \
    \        ret;\n-    njs_value_t           *text, value, lvalue;\n+    njs_value_t\
    \           *text, value, lvalue, wrapper;\n+    njs_object_t          *obj;\n\
    \     const u_char          *p, *end;\n-    njs_json_parse_t      *parse, json_parse;\n\
    \     const njs_value_t     *reviver;\n     njs_string_prop_t     string;\n  \
    \   njs_json_parse_ctx_t  ctx;\n \n-    parse = &json_parse;\n-\n     text = njs_lvalue_arg(&lvalue,\
    \ args, nargs, 1);\n \n     if (njs_slow_path(!njs_is_string(text))) {\n@@ -156,11\
    \ +143,16 @@ njs_json_parse(njs_vm_t *vm, njs_value_t *args, njs_uint_t nargs,\n\
    \ \n     reviver = njs_arg(args, nargs, 2);\n \n-    if (njs_slow_path(njs_is_function(reviver)\
    \ && njs_is_object(&value))) {\n-        parse->function = njs_function(reviver);\n\
    -        parse->depth = 0;\n+    if (njs_slow_path(njs_is_function(reviver)))\
    \ {\n+        obj = njs_json_wrap_value(vm, &wrapper, &value);\n+        if (njs_slow_path(obj\
    \ == NULL)) {\n+            return NJS_ERROR;\n+        }\n \n-        return\
    \ njs_json_parse_iterator(vm, parse, &value);\n+        return njs_json_internalize_property(vm,\
    \ njs_function(reviver),\n+                                             &wrapper,\n\
    +                                             njs_value_arg(&njs_string_empty),\n\
    +                                             0, &vm->retval);\n     }\n \n  \
    \   vm->retval = value;\n@@ -851,195 +843,106 @@ njs_json_skip_space(const u_char\
    \ *start, const u_char *end)\n }\n \n \n-static njs_json_state_t *\n-njs_json_push_parse_state(njs_vm_t\
    \ *vm, njs_json_parse_t *parse,\n-    njs_value_t *value)\n-{\n-    njs_json_state_t\
    \  *state;\n-\n-    if (njs_slow_path(parse->depth >= NJS_JSON_MAX_DEPTH)) {\n\
    -        njs_type_error(vm, \"Nested too deep or a cyclic structure\");\n-   \
    \     return NULL;\n-    }\n-\n-    state = &parse->states[parse->depth++];\n\
    -    state->value = *value;\n-    state->index = 0;\n-    state->prop = NULL;\n\
    -    state->keys = njs_value_own_enumerate(vm, value, NJS_ENUM_KEYS,\n-      \
    \                                    NJS_ENUM_STRING, 0);\n-    if (state->keys\
    \ == NULL) {\n-        return NULL;\n-    }\n-\n-    return state;\n-}\n-\n-\n\
    -njs_inline njs_json_state_t *\n-njs_json_pop_parse_state(njs_vm_t *vm, njs_json_parse_t\
    \ *parse)\n-{\n-    njs_json_state_t  *state;\n-\n-    state = &parse->states[parse->depth\
    \ - 1];\n-    njs_array_destroy(vm, state->keys);\n-    state->keys = NULL;\n\
    -\n-    if (parse->depth > 1) {\n-        parse->depth--;\n-        return &parse->states[parse->depth\
    \ - 1];\n-    }\n-\n-    return NULL;\n-}\n-\n-\n static njs_int_t\n-njs_json_parse_iterator(njs_vm_t\
    \ *vm, njs_json_parse_t *parse,\n-    njs_value_t *object)\n+njs_json_internalize_property(njs_vm_t\
    \ *vm, njs_function_t *reviver,\n+    njs_value_t *holder, njs_value_t *name,\
    \ njs_int_t depth,\n+    njs_value_t *retval)\n {\n-    njs_int_t            \
    \ ret;\n-    njs_value_t           *key, wrapper;\n-    njs_object_t         \
    \ *obj;\n-    njs_json_state_t      *state;\n-    njs_object_prop_t     *prop;\n\
    -    njs_property_query_t  pq;\n+    int64_t       k, length;\n+    njs_int_t\
    \     ret;\n+    njs_value_t   val, new_elem, index;\n+    njs_value_t   arguments[3];\n\
    +    njs_array_t   *keys;\n \n-    obj = njs_json_wrap_value(vm, &wrapper, object);\n\
    -    if (njs_slow_path(obj == NULL)) {\n+    if (njs_slow_path(depth++ >= NJS_JSON_MAX_DEPTH))\
    \ {\n+        njs_type_error(vm, \"Nested too deep or a cyclic structure\");\n\
    \         return NJS_ERROR;\n     }\n \n-    state = njs_json_push_parse_state(vm,\
    \ parse, &wrapper);\n-    if (njs_slow_path(state == NULL)) {\n+    ret = njs_value_property(vm,\
    \ holder, name, &val);\n+    if (njs_slow_path(ret == NJS_ERROR)) {\n        \
    \ return NJS_ERROR;\n     }\n \n-    for ( ;; ) {\n-        if (state->index <\
    \ state->keys->length) {\n-            njs_property_query_init(&pq, NJS_PROPERTY_QUERY_SET,\
    \ 0);\n-\n-            key = &state->keys->start[state->index];\n-\n-        \
    \    ret = njs_property_query(vm, &pq, &state->value, key);\n-            if (njs_slow_path(ret\
    \ != NJS_OK)) {\n-                if (ret == NJS_DECLINED) {\n-              \
    \      state->index++;\n-                    continue;\n-                }\n+\
    \    keys = NULL;\n \n+    if (njs_is_object(&val)) {\n+        if (!njs_is_array(&val))\
    \ {\n+            keys = njs_array_keys(vm, &val, 0);\n+            if (njs_slow_path(keys\
    \ == NULL)) {\n                 return NJS_ERROR;\n             }\n \n-      \
    \      prop = pq.lhq.value;\n-\n-            if (prop->type == NJS_WHITEOUT) {\n\
    -                state->index++;\n-                continue;\n-            }\n\
    -\n-            state->prop = prop;\n+            for (k = 0; k < keys->length;\
    \ k++) {\n+                ret = njs_json_internalize_property(vm, reviver, &val,\n\
    +                                                    &keys->start[k], depth,\n\
    +                                                    &new_elem);\n \n-       \
    \     if (prop->type == NJS_PROPERTY && njs_is_object(&prop->value)) {\n-    \
    \            state = njs_json_push_parse_state(vm, parse, &prop->value);\n-  \
    \              if (state == NULL) {\n-                    return NJS_ERROR;\n\
    +                if (njs_slow_path(ret != NJS_OK)) {\n+                    goto\
    \ done;\n                 }\n \n-                continue;\n-            }\n+\
    \                if (njs_is_undefined(&new_elem)) {\n+                    ret\
    \ = njs_value_property_delete(vm, &val, &keys->start[k],\n+                  \
    \                                  NULL, 0);\n \n-            if (prop->type ==\
    \ NJS_PROPERTY_REF\n-                && njs_is_object(prop->value.data.u.value))\n\
    -            {\n-                state = njs_json_push_parse_state(vm, parse,\n\
    -                                                  prop->value.data.u.value);\n\
    -                if (state == NULL) {\n-                    return NJS_ERROR;\n\
    +                } else {\n+                    ret = njs_value_property_set(vm,\
    \ &val, &keys->start[k],\n+                                                 &new_elem);\n\
    \                 }\n \n-                continue;\n+                if (njs_slow_path(ret\
    \ == NJS_ERROR)) {\n+                    goto done;\n+                }\n    \
    \         }\n \n         } else {\n-            state = njs_json_pop_parse_state(vm,\
    \ parse);\n-            if (state == NULL) {\n-                vm->retval = parse->retval;\n\
    -                return NJS_OK;\n-            }\n-        }\n-\n-        ret =\
    \ njs_json_parse_iterator_call(vm, parse, state);\n-        if (njs_slow_path(ret\
    \ != NJS_OK)) {\n-            return ret;\n-        }\n-    }\n-}\n-\n \n-static\
    \ njs_int_t\n-njs_json_parse_iterator_call(njs_vm_t *vm, njs_json_parse_t *parse,\n\
    -    njs_json_state_t *state)\n-{\n-    njs_int_t          ret;\n-    njs_value_t\
    \        arguments[3], *value;\n-    njs_object_prop_t  *prop;\n-\n-    prop =\
    \ state->prop;\n-\n-    arguments[0] = state->value;\n-    arguments[1] = state->keys->start[state->index++];\n\
    -\n-    switch (prop->type) {\n-    case NJS_PROPERTY:\n-        arguments[2]\
    \ = prop->value;\n+            ret = njs_object_length(vm, &val, &length);\n+\
    \            if (njs_slow_path(ret == NJS_ERROR)) {\n+                return NJS_ERROR;\n\
    +            }\n \n-        ret = njs_function_apply(vm, parse->function, arguments,\
    \ 3,\n-                                 &parse->retval);\n-        if (njs_slow_path(ret\
    \ != NJS_OK)) {\n-            return ret;\n-        }\n+            for (k = 0;\
    \ k < length; k++) {\n+                ret = njs_int64_to_string(vm, &index, k);\n\
    +                if (njs_slow_path(ret != NJS_OK)) {\n+                    return\
    \ NJS_ERROR;\n+                }\n \n-        if (njs_is_undefined(&parse->retval))\
    \ {\n-            prop->type = NJS_WHITEOUT;\n+                ret = njs_json_internalize_property(vm,\
    \ reviver, &val, &index,\n+                                                  \
    \  depth, &new_elem);\n \n-        } else {\n-            prop->value = parse->retval;\n\
    -        }\n+                if (njs_slow_path(ret != NJS_OK)) {\n+          \
    \          return NJS_ERROR;\n+                }\n \n-        break;\n+      \
    \          if (njs_is_undefined(&new_elem)) {\n+                    ret = njs_value_property_delete(vm,\
    \ &val, &index, NULL, 0);\n \n-    case NJS_PROPERTY_REF:\n-        value = prop->value.data.u.value;\n\
    -        arguments[2] = *value;\n+                } else {\n+                \
    \    ret = njs_value_property_set(vm, &val, &index, &new_elem);\n+           \
    \     }\n \n-        ret = njs_function_apply(vm, parse->function, arguments,\
    \ 3,\n-                                 &parse->retval);\n-        if (njs_slow_path(ret\
    \ != NJS_OK)) {\n-            return ret;\n+                if (njs_slow_path(ret\
    \ == NJS_ERROR)) {\n+                    return NJS_ERROR;\n+                }\n\
    +            }\n         }\n+    }\n \n-        if (njs_is_undefined(&parse->retval))\
    \ {\n-            ret = njs_value_property_i64_delete(vm, &state->value,\n-  \
    \                                              state->index - 1, NULL);\n-\n-\
    \        } else {\n-            ret = njs_value_property_i64_set(vm, &state->value,\n\
    -                                             state->index - 1, &parse->retval);\n\
    -        }\n+    njs_value_assign(&arguments[0], holder);\n+    njs_value_assign(&arguments[1],\
    \ name);\n+    njs_value_assign(&arguments[2], &val);\n \n-        if (njs_slow_path(ret\
    \ == NJS_ERROR)) {\n-            return NJS_ERROR;\n-        }\n+    ret = njs_function_apply(vm,\
    \ reviver, arguments, 3, retval);\n \n-        break;\n+done:\n \n-    default:\n\
    -        njs_internal_error(vm, \"njs_json_parse_iterator_call() unexpected \"\
    \n-                         \"property type:%s\", njs_prop_type_string(prop->type));\n\
    +    if (keys != NULL) {\n+        njs_array_destroy(vm, keys);\n     }\n \n-\
    \    return NJS_OK;\n+    return ret;\n }\n \n "
  - "--- a/src/test/njs_benchmark.c\n+++ b/src/test/njs_benchmark.c\n@@ -208,6 +208,16\
    \ @@ static njs_benchmark_test_t  njs_test[] =\n       njs_str(\"123\"),\n   \
    \    1000000 },\n \n+    { \"JSON.parse large\",\n+      njs_str(\"JSON.parse(JSON.stringify([Array(2**16)]))[0].length\"\
    ),\n+      njs_str(\"65536\"),\n+      10 },\n+\n+    { \"JSON.parse reviver large\"\
    ,\n+      njs_str(\"JSON.parse(JSON.stringify([Array(2**16)]), v=>v)\"),\n+  \
    \    njs_str(\"\"),\n+      10 },\n+\n     { \"for loop 100M\",\n       njs_str(\"\
    var i; for (i = 0; i < 100000000; i++); i\"),\n       njs_str(\"100000000\"),"
  - "--- a/src/test/njs_unit_test.c\n+++ b/src/test/njs_unit_test.c\n@@ -17203,6 +17203,31\
    \ @@ static njs_unit_test_t  njs_test[] =\n               \"JSON.parse('[1]',\
    \ func);\"),\n       njs_str(\"\") },\n \n+    { njs_str(\"JSON.parse(JSON.stringify([Array(2**16)]),\
    \ v => v)\"),\n+      njs_str(\"\") },\n+\n+    { njs_str(\"var order = []; function\
    \ reviver(k, v) { order.push(k); };\"\n+              \"JSON.parse('{\\\"p1\\\"\
    :0,\\\"p2\\\":0,\\\"p1\\\":0,\\\"2\\\":0,\\\"1\\\":0}', reviver);\"\n+       \
    \       \"order\"),\n+      njs_str(\"1,2,p1,p2,\") },\n+\n+    { njs_str(\"function\
    \ reviver(k, v) {\"\n+              \"    if (k == '0') Object.defineProperty(this,\
    \ '1', {configurable: false});\"\n+              \"    if (k == '1') return;\"\
    \n+              \"    return v;\"\n+              \" };\"\n+              \"\
    JSON.parse('[1, 2]', reviver)\"),\n+      njs_str(\"1,2\") },\n+\n+    { njs_str(\"\
    JSON.parse('0', (k, v) => {throw 'Oops'})\"),\n+      njs_str(\"Oops\") },\n+\n\
    +    { njs_str(\"JSON.parse('{\\\"a\\\":1}', (k, v) => {if (k == 'a') {throw 'Oops'};\
    \ return v;})\"),\n+      njs_str(\"Oops\") },\n+\n+    { njs_str(\"JSON.parse('[2,3,43]',\
    \ (k, v) => {if (v == 43) {throw 'Oops'}; return v;})\"),\n+      njs_str(\"Oops\"\
    ) },\n+\n     /* JSON.stringify() */\n \n     { njs_str(\"JSON.stringify()\"),"
  identifiers:
  - CVE-2022-43286
  - CWE-416
  overview: Nginx NJS v0.7.2 was discovered to contain a heap-use-after-free bug caused
    by illegal memory copy in the function njs_json_parse_iterator_call at njs_json.c.
  references:
  - source: cve@mitre.org
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/nginx/njs/commit/2ad0ea24a58d570634e09c2e58c3b314505eaa6a
  - source: cve@mitre.org
    tags:
    - Exploit
    - Issue Tracking
    - Patch
    - Third Party Advisory
    url: https://github.com/nginx/njs/issues/480
  title: Nginx NJS v0.7.2 was discovered to contain a heap-use-after-free bug caused
    by illegal memory copy in the function njs_json_parse_iterator_call at njs_json.c.
- diff_content:
  - "--- a/src/ObjectByteWriterWithPosition.cpp\n+++ b/src/ObjectByteWriterWithPosition.cpp\n\
    @@ -52,21 +52,29 @@ IOBasicTypes::LongBufferSizeType ObjectByteWriterWithPosition::Write(const\
    \ IOBas\n     \n     Local<Value> args[1];\n     args[0] = anArray;\n-    \n-\t\
    Local<Value> result = func->Call(GET_CURRENT_CONTEXT,  OBJECT_FROM_PERSISTENT(mObject),\
    \ 1, args).ToLocalChecked();\n+    MaybeLocal<Value> maybe;\n+    TryCatch try_catch(Isolate::GetCurrent());\n\
    +\n+    maybe = func->Call(GET_CURRENT_CONTEXT,  OBJECT_FROM_PERSISTENT(mObject),\
    \ 1, args);\n+    Local <Value> result;\n+\n+    if (!maybe.ToLocal(&result))\
    \ {\n+       try_catch.ReThrow();\n+       return 0;\n+    }\n     if(result.IsEmpty())\n\
    \     {\n-\t\tTHROW_EXCEPTION(\"wrong return value. it's empty. return the number\
    \ of written characters\");\n-\t\treturn 0;\n+        THROW_EXCEPTION(\"wrong\
    \ return value. it's empty. return the number of written characters\");\n+   \
    \     return 0;\n     }\n     else if(result->IsNumber())\n     {\n         return\
    \ TO_UINT32(result)->Value();\n     }\n     else\n     {\n-\t\tTHROW_EXCEPTION(\"\
    wrong return value. write should return the number of written characters\");\n\
    -\t\treturn 0;\n+        THROW_EXCEPTION(\"wrong return value. write should return\
    \ the number of written characters\");\n+        return 0;\n     }\n }\n "
  identifiers:
  - CVE-2022-25885
  - NVD-CWE-noinfo
  overview: The package muhammara before 2.6.0; all versions of package hummus are
    vulnerable to Denial of Service (DoS) when PDFStreamForResponse() is used with
    invalid data.
  references:
  - source: report@snyk.io
    tags:
    - Exploit
    - Issue Tracking
    - Third Party Advisory
    url: https://github.com/galkahana/HummusJS/issues/439
  - source: report@snyk.io
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/julianhille/MuhammaraJS/commit/0a6427eec82ef2978995e453de2dc0d6224dd46c
  - source: report@snyk.io
    tags:
    - Exploit
    - Issue Tracking
    - Third Party Advisory
    url: https://github.com/julianhille/MuhammaraJS/issues/188
  - source: report@snyk.io
    tags:
    - Third Party Advisory
    url: https://security.snyk.io/vuln/SNYK-JS-HUMMUS-3091139
  - source: report@snyk.io
    tags:
    - Third Party Advisory
    url: https://security.snyk.io/vuln/SNYK-JS-MUHAMMARA-3091137
  title: The package muhammara before 2.6.0; all versions of package hummus are vulnerable
    to Denial of Service (DoS) when PDFStreamForResponse() is used with invalid data.
- diff_content:
  - "--- a/src/deps/PDFWriter/PDFParser.cpp\n+++ b/src/deps/PDFWriter/PDFParser.cpp\n\
    @@ -352,6 +352,12 @@ EStatusCode PDFParser::ParseLastXrefPosition()\n \t\tmObjectParser.ResetReadState();\n\
    \ \t\tRefCountPtr<PDFObject> anObject(mObjectParser.ParseNewObject());\n \n+\t\
    \tif (!anObject) {\n+\t\t\tstatus = PDFHummus::eFailure;\n+\t\t\tTRACE_LOG(\"\
    PDFParser::ParseXrefPosition: Unable to find any object\");\n+\t\t\tbreak;\n+\t\
    \t}\n+\n \t\tif(anObject->GetType() == PDFObject::ePDFObjectInteger)\n \t\t{\n\
    \ \t\t\tmLastXrefPosition = (LongFilePositionType)((PDFInteger*)anObject.GetPtr())->GetValue();"
  - "--- a/src/deps/PDFWriter/PDFParser.cpp\n+++ b/src/deps/PDFWriter/PDFParser.cpp\n\
    @@ -352,6 +352,12 @@ EStatusCode PDFParser::ParseLastXrefPosition()\n \t\tmObjectParser.ResetReadState();\n\
    \ \t\tRefCountPtr<PDFObject> anObject(mObjectParser.ParseNewObject());\n \n+\t\
    \tif (!anObject) {\n+\t\t\tstatus = PDFHummus::eFailure;\n+\t\t\tTRACE_LOG(\"\
    PDFParser::ParseXrefPosition: Unable to find any object\");\n+\t\t\tbreak;\n+\t\
    \t}\n+\n \t\tif(anObject->GetType() == PDFObject::ePDFObjectInteger)\n \t\t{\n\
    \ \t\t\tmLastXrefPosition = (LongFilePositionType)((PDFInteger*)anObject.GetPtr())->GetValue();"
  identifiers:
  - CVE-2022-25892
  - NVD-CWE-noinfo
  overview: The package muhammara before 2.6.1, from 3.0.0 and before 3.1.1; all versions
    of package hummus are vulnerable to Denial of Service (DoS) when supplied with
    a maliciously crafted PDF file to be parsed.
  references:
  - source: report@snyk.io
    tags:
    - Issue Tracking
    - Third Party Advisory
    url: https://github.com/galkahana/HummusJS/issues/463
  - source: report@snyk.io
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/julianhille/MuhammaraJS/commit/1890fb555eaf171db79b73fdc3ea543bbd63c002
  - source: report@snyk.io
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/julianhille/MuhammaraJS/commit/90b278d09f16062d93a4160ef0a54d449d739c51
  - source: report@snyk.io
    tags:
    - Issue Tracking
    - Patch
    - Third Party Advisory
    url: https://github.com/julianhille/MuhammaraJS/issues/214
  - source: report@snyk.io
    tags:
    - Third Party Advisory
    url: https://security.snyk.io/vuln/SNYK-JS-HUMMUS-3091138
  - source: report@snyk.io
    tags:
    - Third Party Advisory
    url: https://security.snyk.io/vuln/SNYK-JS-MUHAMMARA-3060320
  title: The package muhammara before 2.6.1, from 3.0.0 and before 3.1.1; all versions
    of package hummus are vulnerable to Denial of Service (DoS) when supplied with
    a maliciously crafted PDF file to be parsed.
- diff_content:
  - "--- a/plugins/sudoers/auth/passwd.c\n+++ b/plugins/sudoers/auth/passwd.c\n@@\
    \ -63,7 +63,7 @@ sudo_passwd_init(struct passwd *pw, sudo_auth *auth)\n int\n\
    \ sudo_passwd_verify(struct passwd *pw, char *pass, sudo_auth *auth, struct sudo_conv_callback\
    \ *callback)\n {\n-    char sav, *epass;\n+    char des_pass[9], *epass;\n   \
    \  char *pw_epasswd = auth->data;\n     size_t pw_len;\n     int matched = 0;\n\
    @@ -75,20 +75,19 @@ sudo_passwd_verify(struct passwd *pw, char *pass, sudo_auth\
    \ *auth, struct sudo_c\n \n     /*\n      * Truncate to 8 chars if standard DES\
    \ since not all crypt()'s do this.\n-     * If this turns out not to be safe we\
    \ will have to use OS #ifdef's (sigh).\n      */\n-    sav = pass[8];\n     pw_len\
    \ = strlen(pw_epasswd);\n-    if (pw_len == DESLEN || HAS_AGEINFO(pw_epasswd,\
    \ pw_len))\n-\tpass[8] = '\\0';\n+    if (pw_len == DESLEN || HAS_AGEINFO(pw_epasswd,\
    \ pw_len)) {\n+\tstrlcpy(des_pass, pass, sizeof(des_pass));\n+\tpass = des_pass;\n\
    +    }\n \n     /*\n      * Normal UN*X password check.\n      * HP-UX may add\
    \ aging info (separated by a ',') at the end so\n      * only compare the first\
    \ DESLEN characters in that case.\n      */\n     epass = (char *) crypt(pass,\
    \ pw_epasswd);\n-    pass[8] = sav;\n     if (epass != NULL) {\n \tif (HAS_AGEINFO(pw_epasswd,\
    \ pw_len) && strlen(epass) == DESLEN)\n \t    matched = !strncmp(pw_epasswd, epass,\
    \ DESLEN);"
  identifiers:
  - CVE-2022-43995
  - CWE-125
  overview: Sudo 1.8.0 through 1.9.12, with the crypt() password backend, contains
    a plugins/sudoers/auth/passwd.c array-out-of-bounds error that can result in a
    heap-based buffer over-read. This can be triggered by arbitrary local users with
    access to Sudo by entering a password of seven characters or fewer. The impact
    could vary depending on the system libraries, compiler, and processor architecture.
  references:
  - source: cve@mitre.org
    tags:
    - Issue Tracking
    - Third Party Advisory
    url: https://bugzilla.redhat.com/show_bug.cgi?id=2139911
  - source: cve@mitre.org
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/sudo-project/sudo/commit/bd209b9f16fcd1270c13db27ae3329c677d48050
  - source: cve@mitre.org
    tags:
    - Third Party Advisory
    url: https://news.ycombinator.com/item?id=33465707
  - source: cve@mitre.org
    tags:
    - Third Party Advisory
    url: https://security.gentoo.org/glsa/202211-08
  - source: cve@mitre.org
    tags:
    - Vendor Advisory
    url: https://www.sudo.ws/security/advisories/
  title: Sudo 1.8.0 through 1.9.12, with the crypt() password backend, contains a
    plugins/sudoers/auth/passwd.c array-out-of-bounds error that can result in a heap-based
    buffer over-read. This can be triggered by arbitrary local users with access to
    Sudo by entering a password of seven characters or fewer. The impact could vary
    depending on the system libraries, compiler, and processor architecture.
- diff_content:
  - "--- a/src/file_io/jpeg.cpp\n+++ b/src/file_io/jpeg.cpp\n@@ -24,31 +24,40 @@\n\
    \ #include \"diplib/file_io.h\"\n \n #include \"jpeglib.h\"\n-#include <setjmp.h>\n\
    -\n-namespace dip {\n-\n-namespace {\n+#include <csetjmp>\n \n // JPEG error handling\
    \ stuff - modified from example.c in libjpeg source\n+extern \"C\" {\n+   static\
    \ void my_error_exit( j_common_ptr cinfo );\n+   static void my_output_message(\
    \ j_common_ptr );\n+}\n+\n struct my_error_mgr {\n-   struct jpeg_error_mgr pub;\
    \   // \"public\" fields\n-   jmp_buf setjmp_buffer;      // for return to caller\n\
    +   struct jpeg_error_mgr pub; // \"public\" fields\n+   std::jmp_buf setjmp_buffer;\
    \     // for return to caller\n };\n using my_error_ptr = struct my_error_mgr*;\n\
    \ \n-void my_error_exit( j_common_ptr cinfo ) {\n+static void my_error_exit( j_common_ptr\
    \ cinfo ) {\n    // cinfo->err really points to a my_error_mgr struct, so coerce\
    \ pointer\n-   my_error_ptr myerr = reinterpret_cast<my_error_ptr>(cinfo->err);\n\
    +   my_error_ptr myerr = reinterpret_cast<my_error_ptr>( cinfo->err );\n    //\
    \ Return control to the setjmp point\n    longjmp( myerr->setjmp_buffer, 1 );\n\
    \ }\n \n-void my_output_message( j_common_ptr ) {} // Don't do anything with messages!\n\
    +static void my_output_message( j_common_ptr ) {} // Don't do anything with messages!\n\
    +\n+#define DIP__DECLARE_JPEG_EXIT( message ) \\\n+std::jmp_buf setjmp_buffer;\
    \ if( setjmp( setjmp_buffer )) { DIP_THROW_RUNTIME( message ); }\n+\n+\n+namespace\
    \ dip {\n+\n+namespace {\n \n class JpegInput {\n    public:\n-      JpegInput(\
    \ String filename ) : filename_( std::move( filename )) {\n+      JpegInput( String\
    \ filename, std::jmp_buf const& setjmp_buffer ) : filename_( std::move( filename\
    \ )) {\n          infile_ = std::fopen( filename_.c_str(), \"rb\" );\n       \
    \   if( infile_ == nullptr ) {\n             if( !FileHasExtension( filename_\
    \ )) {\n@@ -66,10 +75,7 @@ class JpegInput {\n          cinfo_.err = jpeg_std_error(\
    \ &jerr_.pub );\n          jerr_.pub.error_exit = my_error_exit;\n          jerr_.pub.output_message\
    \ = my_output_message;\n-         if( setjmp( jerr_.setjmp_buffer )) {\n-    \
    \        // If we get here, the JPEG code has signaled an error.\n-          \
    \  DIP_THROW_RUNTIME( \"Error reading JPEG file.\" );\n-         }\n+        \
    \ std::memcpy( jerr_.setjmp_buffer, setjmp_buffer, sizeof( setjmp_buffer ));\n\
    \          jpeg_create_decompress( &cinfo_ );\n          initialized_ = true;\n\
    \          jpeg_stdio_src( &cinfo_, infile_ );\n@@ -102,7 +108,7 @@ class JpegInput\
    \ {\n \n class JpegOutput {\n    public:\n-      explicit JpegOutput( String const&\
    \ filename ) {\n+      explicit JpegOutput( String const& filename, std::jmp_buf\
    \ const& setjmp_buffer ) {\n          // Open the file for writing\n         \
    \ if( FileHasExtension( filename )) {\n             outfile_ = std::fopen(filename.c_str(),\
    \ \"wb\");\n@@ -115,10 +121,7 @@ class JpegOutput {\n          cinfo_.err = jpeg_std_error(\
    \ &jerr_.pub );\n          jerr_.pub.error_exit = my_error_exit;\n          jerr_.pub.output_message\
    \ = my_output_message;\n-         if( setjmp( jerr_.setjmp_buffer )) {\n-    \
    \        // If we get here, the JPEG code has signaled an error.\n-          \
    \  DIP_THROW_RUNTIME( \"Error writing JPEG file.\" );\n-         }\n+        \
    \ std::memcpy( jerr_.setjmp_buffer, setjmp_buffer, sizeof( setjmp_buffer ));\n\
    \          jpeg_create_compress( &cinfo_ );\n          initialized_ = true;\n\
    \          jpeg_stdio_dest( &cinfo_, outfile_ );\n@@ -178,7 +181,8 @@ FileInformation\
    \ ImageReadJPEG(\n       String const& filename\n ) {\n    // Open the file\n\
    -   JpegInput jpeg( filename );\n+   DIP__DECLARE_JPEG_EXIT( \"Error reading JPEG\
    \ file\" );\n+   JpegInput jpeg( filename, setjmp_buffer );\n \n    // Get info\n\
    \    FileInformation info = GetJPEGInfo( jpeg );\n@@ -223,14 +227,16 @@ FileInformation\
    \ ImageReadJPEG(\n }\n \n FileInformation ImageReadJPEGInfo( String const& filename\
    \ ) {\n-   JpegInput jpeg( filename );\n+   DIP__DECLARE_JPEG_EXIT( \"Error reading\
    \ JPEG file\" );\n+   JpegInput jpeg( filename, setjmp_buffer );\n    FileInformation\
    \ info = GetJPEGInfo( jpeg );\n    return info;\n }\n \n bool ImageIsJPEG( String\
    \ const& filename ) {\n    try {\n-      JpegInput jpeg( filename );\n+      DIP__DECLARE_JPEG_EXIT(\
    \ \"Error reading JPEG file\" );\n+      JpegInput jpeg( filename, setjmp_buffer\
    \ );\n    } catch( ... ) {\n       return false;\n    }\n@@ -244,10 +250,10 @@\
    \ void ImageWriteJPEG(\n ) {\n    DIP_THROW_IF( !image.IsForged(), E::IMAGE_NOT_FORGED\
    \ );\n    DIP_THROW_IF( image.Dimensionality() != 2, E::DIMENSIONALITY_NOT_SUPPORTED\
    \ );\n-   jpegLevel = clamp< dip::uint >( jpegLevel, 1, 100 );\n \n    // Open\
    \ the file\n-   JpegOutput jpeg( filename );\n+   DIP__DECLARE_JPEG_EXIT( \"Error\
    \ writing JPEG file\" );\n+   JpegOutput jpeg( filename, setjmp_buffer );\n \n\
    \    // Set image properties\n    int nchan = static_cast< int >( image.TensorElements()\
    \ );\n@@ -256,7 +262,7 @@ void ImageWriteJPEG(\n    jpeg.cinfo().input_components\
    \ = nchan;\n    jpeg.cinfo().in_color_space = nchan > 1 ? JCS_RGB : JCS_GRAYSCALE;\n\
    \    jpeg_set_defaults( jpeg.cinfoptr() );\n-   jpeg_set_quality( jpeg.cinfoptr(),\
    \ static_cast< int >( jpegLevel ), FALSE );\n+   jpeg_set_quality( jpeg.cinfoptr(),\
    \ static_cast< int >( clamp< dip::uint >( jpegLevel, 1, 100 )), FALSE );\n   \
    \ jpeg.cinfo().density_unit = 2; // dots per cm\n    jpeg.cinfo().X_density =\
    \ static_cast< UINT16 >( 0.01 / image.PixelSize( 0 ).RemovePrefix().magnitude\
    \ ); // let's assume it's meter\n    jpeg.cinfo().Y_density = static_cast< UINT16\
    \ >( 0.01 / image.PixelSize( 1 ).RemovePrefix().magnitude );"
  identifiers:
  - CVE-2021-39432
  - CWE-415
  overview: diplib v3.0.0 is vulnerable to Double Free.
  references:
  - source: cve@mitre.org
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/DIPlib/diplib/commit/8b9a2670ce66ff2fd5addf592f7825e1f5adb5b5
  - source: cve@mitre.org
    tags:
    - Exploit
    - Issue Tracking
    - Patch
    - Third Party Advisory
    url: https://github.com/DIPlib/diplib/issues/80
  title: diplib v3.0.0 is vulnerable to Double Free.
- diff_content:
  - "--- a/src/basic/time-util.c\n+++ b/src/basic/time-util.c\n@@ -591,7 +591,7 @@\
    \ char *format_timespan(char *buf, size_t l, usec_t t, usec_t accuracy) {\n  \
    \                       t = b;\n                 }\n \n-                n = MIN((size_t)\
    \ k, l);\n+                n = MIN((size_t) k, l-1);\n \n                 l -=\
    \ n;\n                 p += n;"
  - "--- a/src/test/test-time-util.c\n+++ b/src/test/test-time-util.c\n@@ -238,6 +238,11\
    \ @@ TEST(format_timespan) {\n         test_format_timespan_accuracy(1);\n   \
    \      test_format_timespan_accuracy(USEC_PER_MSEC);\n         test_format_timespan_accuracy(USEC_PER_SEC);\n\
    +\n+        /* See issue #23928. */\n+        _cleanup_free_ char *buf;\n+   \
    \     assert_se(buf = new(char, 5));\n+        assert_se(buf == format_timespan(buf,\
    \ 5, 100005, 1000));\n }\n \n TEST(verify_timezone) {"
  identifiers:
  - CVE-2022-3821
  - CWE-193
  overview: An off-by-one Error issue was discovered in Systemd in format_timespan()
    function of time-util.c. An attacker could supply specific values for time and
    accuracy that leads to buffer overrun in format_timespan(), leading to a Denial
    of Service.
  references:
  - source: secalert@redhat.com
    tags:
    - Issue Tracking
    - Third Party Advisory
    url: https://bugzilla.redhat.com/show_bug.cgi?id=2139327
  - source: secalert@redhat.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/systemd/systemd/commit/9102c625a673a3246d7e73d8737f3494446bad4e
  - source: secalert@redhat.com
    tags:
    - Exploit
    - Issue Tracking
    - Third Party Advisory
    url: https://github.com/systemd/systemd/issues/23928
  - source: secalert@redhat.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/systemd/systemd/pull/23933
  - source: secalert@redhat.com
    url: https://lists.debian.org/debian-lts-announce/2023/06/msg00036.html
  - source: secalert@redhat.com
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/RVBQC2VLSDVQAPJTEMTREXDL4HYLXG2P/
  - source: secalert@redhat.com
    url: https://security.gentoo.org/glsa/202305-15
  title: An off-by-one Error issue was discovered in Systemd in format_timespan()
    function of time-util.c. An attacker could supply specific values for time and
    accuracy that leads to buffer overrun in format_timespan(), leading to a Denial
    of Service.
- diff_content:
  - "--- a/libredex/DexLoader.cpp\n+++ b/libredex/DexLoader.cpp\n@@ -31,6 +31,10 @@\
    \ DexLoader::DexLoader(const DexLocation* location)\n static void validate_dex_header(const\
    \ dex_header* dh,\n                                 size_t dexsize,\n        \
    \                         int support_dex_version) {\n+  always_assert_log(sizeof(dex_header)\
    \ <= dexsize,\n+                    \"Header size (%lu) is larger than file size\
    \ (%zu)\\n\",\n+                    dexsize,\n+                    sizeof(dex_header));\n\
    \   bool supported = false;\n   switch (support_dex_version) {\n   case 38:\n\
    @@ -56,10 +60,41 @@ static void validate_dex_header(const dex_header* dh,\n  \
    \     \"Reported size in header (%zu) does not match file size (%u)\\n\",\n  \
    \     dexsize,\n       dh->file_size);\n-  auto off = (uint64_t)dh->class_defs_off;\n\
    -  auto limit = off + dh->class_defs_size * sizeof(dex_class_def);\n-  always_assert_log(off\
    \ < dexsize, \"class_defs_off out of range\");\n-  always_assert_log(limit <=\
    \ dexsize, \"invalid class_defs_size\");\n+\n+  auto str_ids_off = (uint64_t)dh->string_ids_off;\n\
    +  auto str_ids_limit =\n+      str_ids_off + dh->string_ids_size * sizeof(dex_string_id);\n\
    +  always_assert_log(str_ids_off < dexsize, \"string_ids_off out of range\");\n\
    +  always_assert_log(str_ids_limit <= dexsize, \"invalid string_ids_size\");\n\
    +\n+  auto type_ids_off = (uint64_t)dh->type_ids_off;\n+  auto type_ids_limit\
    \ = type_ids_off + dh->type_ids_size * sizeof(dex_type_id);\n+  always_assert_log(type_ids_off\
    \ < dexsize, \"type_ids_off out of range\");\n+  always_assert_log(type_ids_limit\
    \ <= dexsize, \"invalid type_ids_size\");\n+\n+  auto proto_ids_off = (uint64_t)dh->proto_ids_off;\n\
    +  auto proto_ids_limit =\n+      proto_ids_off + dh->proto_ids_size * sizeof(dex_proto_id);\n\
    +  always_assert_log(proto_ids_off < dexsize, \"proto_ids_off out of range\");\n\
    +  always_assert_log(proto_ids_limit <= dexsize, \"invalid proto_ids_size\");\n\
    +\n+  auto field_ids_off = (uint64_t)dh->field_ids_off;\n+  auto field_ids_limit\
    \ =\n+      field_ids_off + dh->field_ids_size * sizeof(dex_field_id);\n+  always_assert_log(field_ids_off\
    \ < dexsize, \"field_ids_off out of range\");\n+  always_assert_log(field_ids_limit\
    \ <= dexsize, \"invalid field_ids_size\");\n+\n+  auto meth_ids_off = (uint64_t)dh->method_ids_off;\n\
    +  auto meth_ids_limit =\n+      meth_ids_off + dh->method_ids_size * sizeof(dex_method_id);\n\
    +  always_assert_log(meth_ids_off < dexsize, \"method_ids_off out of range\");\n\
    +  always_assert_log(meth_ids_limit <= dexsize, \"invalid method_ids_size\");\n\
    +\n+  auto cls_defs_off = (uint64_t)dh->class_defs_off;\n+  auto cls_defs_limit\
    \ =\n+      cls_defs_off + dh->class_defs_size * sizeof(dex_class_def);\n+  always_assert_log(cls_defs_off\
    \ < dexsize, \"class_defs_off out of range\");\n+  always_assert_log(cls_defs_limit\
    \ <= dexsize, \"invalid class_defs_size\");\n }\n \n void DexLoader::gather_input_stats(dex_stats_t*\
    \ stats, const dex_header* dh) {"
  identifiers:
  - CVE-2022-36938
  - CWE-1284
  overview: DexLoader function get_stringidx_fromdex() in Redex prior to commit 3b44c64
    can load an out of bound address when loading the string index table, potentially
    allowing remote code execution during processing of a 3rd party Android APK file.
  references:
  - source: cve-assign@fb.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/facebook/redex/commit/3b44c640346b77bfb7ef36e2413688dd460288d2
  title: DexLoader function get_stringidx_fromdex() in Redex prior to commit 3b44c64
    can load an out of bound address when loading the string index table, potentially
    allowing remote code execution during processing of a 3rd party Android APK file.
- diff_content:
  - "--- a/src/scene_manager/loader_svg.c\n+++ b/src/scene_manager/loader_svg.c\n\
    @@ -449,6 +449,7 @@ static Bool svg_parse_animation(GF_SVG_Parser *parser, GF_SceneGraph\
    \ *sg, SVG_De\n \t\tif (anim->to) {\n \t\t\t/* now that we have a target, if there\
    \ is a to value to parse, create the attribute and parse it */\n \t\t\tgf_node_get_attribute_by_tag((GF_Node\
    \ *)anim->animation_elt, TAG_SVG_ATT_to, GF_TRUE, GF_FALSE, &info);\n+\t\t\tif\
    \ (!info.name) info.name = \"to\";\n \t\t\tgf_svg_parse_attribute((GF_Node *)anim->animation_elt,\
    \ &info, anim->to, anim_value_type);\n \t\t\tif (anim_value_type==XMLRI_datatype)\
    \ {\n \t\t\t\tsvg_post_process_href(parser, (GF_Node *) anim->target, (XMLRI*)((SMIL_AnimateValue\
    \ *)info.far_ptr)->value);\n@@ -457,20 +458,23 @@ static Bool svg_parse_animation(GF_SVG_Parser\
    \ *parser, GF_SceneGraph *sg, SVG_De\n \t\tif (anim->from) {\n \t\t\t/* now that\
    \ we have a target, if there is a from value to parse, create the attribute and\
    \ parse it */\n \t\t\tgf_node_get_attribute_by_tag((GF_Node *)anim->animation_elt,\
    \ TAG_SVG_ATT_from, GF_TRUE, GF_FALSE, &info);\n+\t\t\tif (!info.name) info.name\
    \ = \"from\";\n \t\t\tgf_svg_parse_attribute((GF_Node *)anim->animation_elt, &info,\
    \ anim->from, anim_value_type);\n \t\t\tif (anim_value_type==XMLRI_datatype)\n\
    \ \t\t\t\tsvg_post_process_href(parser,  (GF_Node *) anim->target, (XMLRI*)((SMIL_AnimateValue\
    \ *)info.far_ptr)->value);\n \t\t}\n \t\tif (anim->by) {\n \t\t\t/* now that we\
    \ have a target, if there is a by value to parse, create the attribute and parse\
    \ it */\n \t\t\tgf_node_get_attribute_by_tag((GF_Node *)anim->animation_elt, TAG_SVG_ATT_by,\
    \ GF_TRUE, GF_FALSE, &info);\n+\t\t\tif (!info.name) info.name = \"by\";\n \t\t\
    \tgf_svg_parse_attribute((GF_Node *)anim->animation_elt, &info, anim->by, anim_value_type);\n\
    \ \t\t\tif (anim_value_type==XMLRI_datatype)\n \t\t\t\tsvg_post_process_href(parser,\
    \  (GF_Node *) anim->target, (XMLRI*)((SMIL_AnimateValue *)info.far_ptr)->value);\n\
    \ \t\t}\n \t\tif (anim->values) {\n \t\t\t/* now that we have a target, if there\
    \ is a 'values' value to parse, create the attribute and parse it */\n \t\t\t\
    gf_node_get_attribute_by_tag((GF_Node *)anim->animation_elt, TAG_SVG_ATT_values,\
    \ GF_TRUE, GF_FALSE, &info);\n+\t\t\tif (!info.name) info.name = \"values\";\n\
    \ \t\t\tgf_svg_parse_attribute((GF_Node *)anim->animation_elt, &info, anim->values,\
    \ anim_value_type);\n \t\t\tif (anim_value_type==XMLRI_datatype) {\n \t\t\t\t\
    u32 i, count;"
  - "--- a/src/scenegraph/svg_attributes.c\n+++ b/src/scenegraph/svg_attributes.c\n\
    @@ -2994,7 +2994,7 @@ static void svg_parse_preserveaspectratio(SVG_PreserveAspectRatio\
    \ *par, char *at\n \twhile (*content == ' ') content++;\n \tif (strstr(content,\
    \ \"defer\")) {\n \t\tpar->defer = 1;\n-\t\tcontent += 4;\n+\t\tcontent += 5;\n\
    \ \t} else {\n \t\tcontent = attribute_content;\n \t}\n@@ -3587,11 +3587,14 @@\
    \ GF_Err gf_svg_parse_attribute(GF_Node *n, GF_FieldInfo *info, char *attribute_co\n\
    \ \t\t*(SVG_String *)info->far_ptr = gf_strdup(attribute_content);\n \t\tbreak;\n\
    \ \tdefault:\n-\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (\"[SVG Parsing] Cannot\
    \ parse attribute %s\\n\", info->name ? info->name : \"\"));\n-\t\tbreak;\n+\t\
    \tGF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (\"[SVG Parsing] Cannot parse attribute\
    \ \\\"%s\\\"\\n\", info->name ? info->name : \"\"));\n+\t\treturn GF_OK;\n \t\
    }\n \tif (e) {\n-\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_PARSER, (\"[SVG Parsing] Cannot\
    \ parse attribute %s value %s: %s\\n\", info->name ? info->name : \"\", attribute_content,\
    \ gf_error_to_string(e)));\n+\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_PARSER, (\"[SVG Parsing]\
    \ Cannot parse attribute \\\"%s\\\" value %s: %s\\n\", info->name ? info->name\
    \ : \"\", attribute_content, gf_error_to_string(e)));\n+\t\t//continue parsing\
    \ if not test mode\n+\t\tif (!gf_sys_is_test_mode())\n+\t\t\te = GF_OK;\n \t}\n\
    \ \treturn e;\n }"
  identifiers:
  - CVE-2022-3957
  - CWE-404
  overview: A vulnerability classified as problematic was found in GPAC. Affected
    by this vulnerability is the function svg_parse_preserveaspectratio of the file
    scenegraph/svg_attributes.c of the component SVG Parser. The manipulation leads
    to memory leak. The attack can be launched remotely. The name of the patch is
    2191e66aa7df750e8ef01781b1930bea87b713bb. It is recommended to apply a patch to
    fix this issue. The associated identifier of this vulnerability is VDB-213463.
  references:
  - source: cna@vuldb.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/gpac/gpac/commit/2191e66aa7df750e8ef01781b1930bea87b713bb
  - source: cna@vuldb.com
    tags:
    - Permissions Required
    - Third Party Advisory
    - VDB Entry
    url: https://vuldb.com/?id.213463
  - source: cna@vuldb.com
    url: https://www.debian.org/security/2023/dsa-5411
  title: A vulnerability classified as problematic was found in GPAC. Affected by
    this vulnerability is the function svg_parse_preserveaspectratio of the file scenegraph/svg_attributes.c
    of the component SVG Parser. The manipulation leads to memory leak. The attack
    can be launched remotely. The name of the patch is 2191e66aa7df750e8ef01781b1930bea87b713bb.
    It is recommended to apply a patch to fix this issue. The associated identifier
    of this vulnerability is VDB-213463.
- diff_content:
  - "--- a/libtiff/tif_getimage.c\n+++ b/libtiff/tif_getimage.c\n@@ -3016,15 +3016,15\
    \ @@ TIFFReadRGBATileExt(TIFF* tif, uint32_t col, uint32_t row, uint32_t * raster,\
    \ in\n         return( ok );\n \n     for( i_row = 0; i_row < read_ysize; i_row++\
    \ ) {\n-        memmove( raster + (tile_ysize - i_row - 1) * tile_xsize,\n-  \
    \               raster + (read_ysize - i_row - 1) * read_xsize,\n+        memmove(\
    \ raster + (size_t)(tile_ysize - i_row - 1) * tile_xsize,\n+                 raster\
    \ + (size_t)(read_ysize - i_row - 1) * read_xsize,\n                  read_xsize\
    \ * sizeof(uint32_t) );\n-        _TIFFmemset( raster + (tile_ysize - i_row -\
    \ 1) * tile_xsize+read_xsize,\n+        _TIFFmemset( raster + (size_t)(tile_ysize\
    \ - i_row - 1) * tile_xsize+read_xsize,\n                      0, sizeof(uint32_t)\
    \ * (tile_xsize - read_xsize) );\n     }\n \n     for( i_row = read_ysize; i_row\
    \ < tile_ysize; i_row++ ) {\n-        _TIFFmemset( raster + (tile_ysize - i_row\
    \ - 1) * tile_xsize,\n+        _TIFFmemset( raster + (size_t)(tile_ysize - i_row\
    \ - 1) * tile_xsize,\n                      0, sizeof(uint32_t) * tile_xsize );\n\
    \     }\n \n"
  identifiers:
  - CVE-2022-3970
  - CWE-189
  overview: A vulnerability was found in LibTIFF. It has been classified as critical.
    This affects the function TIFFReadRGBATileExt of the file libtiff/tif_getimage.c.
    The manipulation leads to integer overflow. It is possible to initiate the attack
    remotely. The exploit has been disclosed to the public and may be used. The name
    of the patch is 227500897dfb07fb7d27f7aa570050e62617e3be. It is recommended to
    apply a patch to fix this issue. The identifier VDB-213549 was assigned to this
    vulnerability.
  references:
  - source: cna@vuldb.com
    tags:
    - Exploit
    - Issue Tracking
    - Third Party Advisory
    url: https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=53137
  - source: cna@vuldb.com
    tags:
    - Patch
    url: https://gitlab.com/libtiff/libtiff/-/commit/227500897dfb07fb7d27f7aa570050e62617e3be
  - source: cna@vuldb.com
    tags:
    - Mailing List
    - Third Party Advisory
    url: https://lists.debian.org/debian-lts-announce/2023/01/msg00018.html
  - source: cna@vuldb.com
    tags:
    - Product
    url: https://oss-fuzz.com/download?testcase_id=5738253143900160
  - source: cna@vuldb.com
    tags:
    - Third Party Advisory
    url: https://security.netapp.com/advisory/ntap-20221215-0009/
  - source: cna@vuldb.com
    tags:
    - Release Notes
    - Third Party Advisory
    url: https://support.apple.com/kb/HT213841
  - source: cna@vuldb.com
    tags:
    - Release Notes
    - Third Party Advisory
    url: https://support.apple.com/kb/HT213843
  - source: cna@vuldb.com
    tags:
    - Third Party Advisory
    - VDB Entry
    url: https://vuldb.com/?id.213549
  title: A vulnerability was found in LibTIFF. It has been classified as critical.
    This affects the function TIFFReadRGBATileExt of the file libtiff/tif_getimage.c.
    The manipulation leads to integer overflow. It is possible to initiate the attack
    remotely. The exploit has been disclosed to the public and may be used. The name
    of the patch is 227500897dfb07fb7d27f7aa570050e62617e3be. It is recommended to
    apply a patch to fix this issue. The identifier VDB-213549 was assigned to this
    vulnerability.
- diff_content:
  - "--- a/src/mms/iso_mms/client/mms_client_files.c\n+++ b/src/mms/iso_mms/client/mms_client_files.c\n\
    @@ -125,38 +124,48 @@ mmsClient_handleFileOpenRequest(\n \n     if (hasFileName)\
    \ {\n \n-        MmsFileReadStateMachine* frsm = getFreeFrsm(connection);\n+ \
    \       if (mmsMsg_isFilenameSave(filename) == false) {\n+            /* potential\
    \ attack */\n \n-        if (frsm != NULL) {\n+            if (DEBUG_MMS_CLIENT)\n\
    +                printf(\"MMS_CLIENT: client provided unsave filename -> rejected\\\
    n\");\n \n-            MmsOutstandingCall obtainFileCall = mmsClient_getMatchingObtainFileRequest(connection,\
    \ filename);\n+             mmsMsg_createServiceErrorPdu(invokeId, response, MMS_ERROR_FILE_FILE_NON_EXISTENT);\n\
    +        }\n+        else {\n+            MmsFileReadStateMachine* frsm = getFreeFrsm(connection);\n\
    \ \n-            if (obtainFileCall) {\n+            if (frsm != NULL) {\n \n\
    -                if (DEBUG_MMS_CLIENT)\n-                    printf(\"MMS_CLIENT:\
    \ file open is matching obtain file request for file %s\\n\", filename);\n+  \
    \              MmsOutstandingCall obtainFileCall = mmsClient_getMatchingObtainFileRequest(connection,\
    \ filename);\n \n-                obtainFileCall->timeout = Hal_getTimeInMs()\
    \ + connection->requestTimeout;\n-            }\n+                if (obtainFileCall)\
    \ {\n \n-            FileHandle fileHandle = mmsMsg_openFile(MmsConnection_getFilestoreBasepath(connection),\
    \ filename, false);\n+                    if (DEBUG_MMS_CLIENT)\n+           \
    \             printf(\"MMS_CLIENT: file open is matching obtain file request for\
    \ file %s\\n\", filename);\n \n-            if (fileHandle != NULL) {\n+     \
    \               obtainFileCall->timeout = Hal_getTimeInMs() + connection->requestTimeout;\n\
    +                }\n \n-                frsm->fileHandle = fileHandle;\n-    \
    \            frsm->readPosition = filePosition;\n-                frsm->frsmId\
    \ = getNextFrsmId(connection);\n-                frsm->obtainRequest = obtainFileCall;\n\
    +                FileHandle fileHandle = mmsMsg_openFile(MmsConnection_getFilestoreBasepath(connection),\
    \ filename, false);\n+\n+                if (fileHandle != NULL) {\n+\n+     \
    \               frsm->fileHandle = fileHandle;\n+                    frsm->readPosition\
    \ = filePosition;\n+                    frsm->frsmId = getNextFrsmId(connection);\n\
    +                    frsm->obtainRequest = obtainFileCall;\n+\n+             \
    \       mmsMsg_createFileOpenResponse(MmsConnection_getFilestoreBasepath(connection),\n\
    +                            invokeId, response, filename, frsm);\n+         \
    \       }\n+                else\n+                    mmsMsg_createServiceErrorPdu(invokeId,\
    \ response, MMS_ERROR_FILE_FILE_NON_EXISTENT);\n \n-                mmsMsg_createFileOpenResponse(MmsConnection_getFilestoreBasepath(connection),\n\
    -                        invokeId, response, filename, frsm);\n             }\n\
    \             else\n-                mmsMsg_createServiceErrorPdu(invokeId, response,\
    \ MMS_ERROR_FILE_FILE_NON_EXISTENT);\n-\n+                mmsMsg_createServiceErrorPdu(invokeId,\
    \ response, MMS_ERROR_RESOURCE_OTHER);\n         }\n-        else\n-         \
    \   mmsMsg_createServiceErrorPdu(invokeId, response, MMS_ERROR_RESOURCE_OTHER);\n\
    \     }\n     else\n         goto exit_invalid_parameter;"
  - "--- a/src/mms/iso_mms/common/mms_common_msg.c\n+++ b/src/mms/iso_mms/common/mms_common_msg.c\n\
    @@ -570,6 +570,24 @@ mmsMsg_createExtendedFilename(const char* basepath, int bufSize,\
    \ char* extendedF\n #endif\n }\n \n+bool\n+mmsMsg_isFilenameSave(const char* filename)\n\
    +{\n+    if (filename)\n+    {\n+        if (strstr(filename, \"..\"))\n+    \
    \        return false;\n+\n+        if (strstr(filename, \"./\"))\n+         \
    \   return false;\n+\n+        return true;\n+    }\n+    else {\n+        return\
    \ false;\n+    }\n+}\n+\n FileHandle\n mmsMsg_openFile(const char* basepath, char*\
    \ fileName, bool readWrite)\n {\n@@ -620,7 +638,7 @@ mmsMsg_parseFileName(char*\
    \ filename, uint8_t* buffer, int* bufPos, int maxBufPos\n      * characters.\n\
    \      */\n     if (strstr(filename, \"..\") != NULL) {\n-        mmsMsg_createServiceErrorPdu(invokeId,\
    \ response, MMS_ERROR_FILE_FILENAME_SYNTAX_ERROR);\n+        mmsMsg_createServiceErrorPdu(invokeId,\
    \ response, MMS_ERROR_FILE_FILE_NON_EXISTENT);\n         return false;\n     }\n\
    \ "
  - "--- a/src/mms/iso_mms/server/mms_file_service.c\n+++ b/src/mms/iso_mms/server/mms_file_service.c\n\
    @@ -266,6 +264,16 @@ mmsServer_handleFileDeleteRequest(\n     if (DEBUG_MMS_SERVER)\n\
    \         printf(\"MMS_SERVER: mms_file_service.c: Delete file (%s)\\n\", filename);\n\
    \ \n+    if (mmsMsg_isFilenameSave(filename) == false)\n+    {\n+        if (DEBUG_MMS_SERVER)\n\
    +            printf(\"MMS_SERVER: remote provided unsave filename -> rejected\\\
    n\");\n+\n+        mmsMsg_createServiceErrorPdu(invokeId, response, MMS_ERROR_FILE_FILE_NON_EXISTENT);\n\
    +\n+        return;\n+    }\n+\n     if (connection->server->fileAccessHandler\
    \ != NULL) {\n         MmsError access = connection->server->fileAccessHandler(connection->server->fileAccessHandlerParameter,\n\
    \                             connection, MMS_FILE_ACCESS_TYPE_DELETE, filename,\
    \ NULL);\n@@ -344,6 +352,17 @@ mmsServer_handleFileOpenRequest(\n \n     if (hasFileName)\
    \ {\n \n+        if (mmsMsg_isFilenameSave(filename) == false) {\n+          \
    \  /* potential attack */\n+\n+            if (DEBUG_MMS_CLIENT)\n+          \
    \      printf(\"MMS_SERVER: remote provided unsave filename -> rejected\\n\");\n\
    +\n+             mmsMsg_createServiceErrorPdu(invokeId, response, MMS_ERROR_FILE_FILE_NON_EXISTENT);\n\
    +\n+             return;\n+        }\n+\n         if (connection->server->fileAccessHandler\
    \ != NULL) {\n             MmsError access = connection->server->fileAccessHandler(connection->server->fileAccessHandlerParameter,\n\
    \                                 connection, MMS_FILE_ACCESS_TYPE_OPEN, filename,\
    \ NULL);\n@@ -690,6 +709,15 @@ mmsServer_handleObtainFileRequest(\n \n     if\
    \ (hasSourceFileName && hasDestinationFilename) {\n \n+        if (mmsMsg_isFilenameSave(destinationFilename)\
    \ == false) {\n+            /* potential attack */\n+\n+            if (DEBUG_MMS_SERVER)\n\
    +                printf(\"MMS_SERVER: remote provided unsave filename -> rejected\\\
    n\");\n+\n+            goto exit_invalid_parameter;\n+        }\n+\n         /*\
    \ Call user to check if access is allowed */\n         if (connection->server->fileAccessHandler\
    \ != NULL) {\n             MmsError access = connection->server->fileAccessHandler(connection->server->fileAccessHandlerParameter,\n\
    @@ -1023,6 +1051,17 @@ createFileDirectoryResponse(const char* basepath, uint32_t\
    \ invokeId, ByteBuffer*\n             continueAfterFileName = NULL;\n     }\n\
    \ \n+    if ((directoryName && mmsMsg_isFilenameSave(directoryName) == false)\
    \ || \n+        (continueAfterFileName && mmsMsg_isFilenameSave(continueAfterFileName)\
    \ == false))\n+    {\n+        if (DEBUG_MMS_SERVER)\n+            printf(\"MMS_SERVER:\
    \ remote provided unsave filename -> rejected\\n\");\n+\n+       mmsMsg_createServiceErrorPdu(invokeId,\
    \ response, MMS_ERROR_FILE_FILE_NON_EXISTENT);\n+\n+       return;\n+    }\n+\n\
    \     tempCurPos = addFileEntriesToResponse(basepath, buffer, tempCurPos, maxSize,\
    \ directoryName, &continueAfterFileName, &moreFollows);\n \n \tif (tempCurPos\
    \ < 0) {\n@@ -1128,6 +1167,16 @@ mmsServer_handleFileRenameRequest(\n \n     if\
    \ ((strlen(currentFileName) != 0) && (strlen(newFileName) != 0)) {\n \n+     \
    \   if ((mmsMsg_isFilenameSave(currentFileName) == false) || (mmsMsg_isFilenameSave(newFileName)\
    \ == false))\n+        {\n+            if (DEBUG_MMS_SERVER)\n+              \
    \  printf(\"MMS_SERVER: remote provided unsave filename -> rejected\\n\");\n+\n\
    +            mmsMsg_createServiceErrorPdu(invokeId, response, MMS_ERROR_FILE_FILE_NON_EXISTENT);\n\
    +\n+            return;\n+        }\n+\n         /* Call user to check if access\
    \ is allowed */\n         if (connection->server->fileAccessHandler != NULL) {\n\
    \             MmsError access = connection->server->fileAccessHandler(connection->server->fileAccessHandlerParameter,"
  identifiers:
  - CVE-2022-3976
  - CWE-22
  overview: A vulnerability has been found in MZ Automation libiec61850 up to 1.4
    and classified as critical. This vulnerability affects unknown code of the file
    src/mms/iso_mms/client/mms_client_files.c of the component MMS File Services.
    The manipulation of the argument filename leads to path traversal. Upgrading to
    version 1.5 is able to address this issue. The name of the patch is 10622ba36bb3910c151348f1569f039ecdd8786f.
    It is recommended to upgrade the affected component. The identifier of this vulnerability
    is VDB-213556.
  references:
  - source: cna@vuldb.com
    tags:
    - Third Party Advisory
    url: https://github.com/mz-automation/libiec61850
  - source: cna@vuldb.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/mz-automation/libiec61850/commit/10622ba36bb3910c151348f1569f039ecdd8786f
  - source: cna@vuldb.com
    tags:
    - Third Party Advisory
    url: https://vuldb.com/?id.213556
  title: A vulnerability has been found in MZ Automation libiec61850 up to 1.4 and
    classified as critical. This vulnerability affects unknown code of the file src/mms/iso_mms/client/mms_client_files.c
    of the component MMS File Services. The manipulation of the argument filename
    leads to path traversal. Upgrading to version 1.5 is able to address this issue.
    The name of the patch is 10622ba36bb3910c151348f1569f039ecdd8786f. It is recommended
    to upgrade the affected component. The identifier of this vulnerability is VDB-213556.
- diff_content:
  - "--- a/libfreerdp/codec/zgfx.c\n+++ b/libfreerdp/codec/zgfx.c\n@@ -230,19 +230,19\
    \ @@ static BOOL zgfx_decompress_segment(ZGFX_CONTEXT* zgfx, wStream* stream,\
    \ size_t\n \tBYTE* pbSegment;\n \tsize_t cbSegment;\n \n-\tif (!zgfx || !stream)\n\
    +\tif (!zgfx || !stream || (segmentSize < 2))\n \t\treturn FALSE;\n \n \tcbSegment\
    \ = segmentSize - 1;\n \n-\tif ((Stream_GetRemainingLength(stream) < segmentSize)\
    \ || (segmentSize < 1) ||\n-\t    (segmentSize > UINT32_MAX))\n+\tif ((Stream_GetRemainingLength(stream)\
    \ < segmentSize) || (segmentSize > UINT32_MAX))\n \t\treturn FALSE;\n \n \tStream_Read_UINT8(stream,\
    \ flags); /* header (1 byte) */\n \tzgfx->OutputCount = 0;\n \tpbSegment = Stream_Pointer(stream);\n\
    -\tStream_Seek(stream, cbSegment);\n+\tif (!Stream_SafeSeek(stream, cbSegment))\n\
    +\t\treturn FALSE;\n \n \tif (!(flags & PACKET_COMPRESSED))\n \t{\n@@ -346,6 +346,9\
    \ @@ static BOOL zgfx_decompress_segment(ZGFX_CONTEXT* zgfx, wStream* stream,\
    \ size_t\n \t\t\t\t\t\tif (count > sizeof(zgfx->OutputBuffer) - zgfx->OutputCount)\n\
    \ \t\t\t\t\t\t\treturn FALSE;\n \n+\t\t\t\t\t\tif (count > zgfx->cBitsRemaining\
    \ / 8)\n+\t\t\t\t\t\t\treturn FALSE;\n+\n \t\t\t\t\t\tCopyMemory(&(zgfx->OutputBuffer[zgfx->OutputCount]),\
    \ zgfx->pbInputCurrent,\n \t\t\t\t\t\t           count);\n \t\t\t\t\t\tzgfx_history_buffer_ring_write(zgfx,\
    \ zgfx->pbInputCurrent, count);"
  identifiers:
  - CVE-2022-39316
  - CWE-125
  overview: FreeRDP is a free remote desktop protocol library and clients. In affected
    versions there is an out of bound read in ZGFX decoder component of FreeRDP. A
    malicious server can trick a FreeRDP based client to read out of bound data and
    try to decode it likely resulting in a crash. This issue has been addressed in
    the 2.9.0 release. Users are advised to upgrade.
  references:
  - source: security-advisories@github.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/FreeRDP/FreeRDP/commit/e865c24efc40ebc52e75979c94cdd4ee2c1495b0
  - source: security-advisories@github.com
    tags:
    - Third Party Advisory
    url: https://github.com/FreeRDP/FreeRDP/security/advisories/GHSA-5w4j-mrrh-jjrm
  - source: security-advisories@github.com
    url: https://lists.debian.org/debian-lts-announce/2023/11/msg00010.html
  - source: security-advisories@github.com
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/UDOTAOJBCZKREZJPT6VZ25GESI5T6RBG/
  - source: security-advisories@github.com
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/YGQN3OWQNHSMWKOF4D35PF5ASKNLC74B/
  - source: security-advisories@github.com
    url: https://security.gentoo.org/glsa/202401-16
  title: FreeRDP is a free remote desktop protocol library and clients. In affected
    versions there is an out of bound read in ZGFX decoder component of FreeRDP. A
    malicious server can trick a FreeRDP based client to read out of bound data and
    try to decode it likely resulting in a crash. This issue has been addressed in
    the 2.9.0 release. Users are advised to upgrade.
- diff_content:
  - "--- a/channels/drive/client/drive_file.c\n+++ b/channels/drive/client/drive_file.c\n\
    @@ -61,10 +61,14 @@\n \t} while (0)\n #endif\n \n-static void drive_file_fix_path(WCHAR*\
    \ path)\n+static BOOL drive_file_fix_path(WCHAR* path, size_t length)\n {\n \t\
    size_t i;\n-\tsize_t length = _wcslen(path);\n+\n+\tif ((length == 0) || (length\
    \ > UINT32_MAX))\n+\t\treturn FALSE;\n+\n+\tWINPR_ASSERT(path);\n \n \tfor (i\
    \ = 0; i < length; i++)\n \t{\n@@ -75,71 +79,94 @@ static void drive_file_fix_path(WCHAR*\
    \ path)\n #ifdef WIN32\n \n \tif ((length == 3) && (path[1] == L':') && (path[2]\
    \ == L'/'))\n-\t\treturn;\n+\t\treturn FALSE;\n \n #else\n \n \tif ((length ==\
    \ 1) && (path[0] == L'/'))\n-\t\treturn;\n+\t\treturn FALSE;\n \n #endif\n \n\
    \ \tif ((length > 0) && (path[length - 1] == L'/'))\n \t\tpath[length - 1] = L'\\\
    0';\n+\n+\treturn TRUE;\n }\n \n static WCHAR* drive_file_combine_fullpath(const\
    \ WCHAR* base_path, const WCHAR* path,\n-                                    \
    \      size_t PathLength)\n+                                          size_t PathWCharLength)\n\
    \ {\n-\tWCHAR* fullpath;\n-\tsize_t base_path_length;\n+\tBOOL ok = FALSE;\n+\t\
    WCHAR* fullpath = NULL;\n+\tsize_t length;\n \n-\tif (!base_path || (!path &&\
    \ (PathLength > 0)))\n-\t\treturn NULL;\n+\tif (!base_path || (!path && (PathWCharLength\
    \ > 0)))\n+\t\tgoto fail;\n \n-\tbase_path_length = _wcslen(base_path) * 2;\n\
    -\tfullpath = (WCHAR*)calloc(1, base_path_length + PathLength + sizeof(WCHAR));\n\
    +\tconst size_t base_path_length = _wcsnlen(base_path, MAX_PATH);\n+\tlength =\
    \ base_path_length + PathWCharLength + 1;\n+\tfullpath = (WCHAR*)calloc(length,\
    \ sizeof(WCHAR));\n \n \tif (!fullpath)\n+\t\tgoto fail;\n+\n+\tCopyMemory(fullpath,\
    \ base_path, base_path_length * sizeof(WCHAR));\n+\tif (path)\n+\t\tCopyMemory(&fullpath[base_path_length],\
    \ path, PathWCharLength * sizeof(WCHAR));\n+\n+\tif (!drive_file_fix_path(fullpath,\
    \ length))\n+\t\tgoto fail;\n+\n+\t/* Ensure the path does not contain sequences\
    \ like '..' */\n+\tconst WCHAR dotdot[] = { '.', '.', '\\0' };\n+\tif (_wcsstr(&fullpath[base_path_length],\
    \ dotdot))\n \t{\n-\t\tWLog_ERR(TAG, \"malloc failed!\");\n-\t\treturn NULL;\n\
    +\t\tchar abuffer[MAX_PATH] = { 0 };\n+\t\tConvertFromUnicode(CP_UTF8, 0, &fullpath[base_path_length],\
    \ -1, (char**)&abuffer,\n+\t\t                   ARRAYSIZE(abuffer) - 1, NULL,\
    \ NULL);\n+\n+\t\tWLog_WARN(TAG, \"[rdpdr] received invalid file path '%s' from\
    \ server, aborting!\",\n+\t\t          &abuffer[base_path_length]);\n+\t\tgoto\
    \ fail;\n \t}\n \n-\tCopyMemory(fullpath, base_path, base_path_length);\n-\tif\
    \ (path)\n-\t\tCopyMemory((char*)fullpath + base_path_length, path, PathLength);\n\
    -\tdrive_file_fix_path(fullpath);\n+\tok = TRUE;\n+fail:\n+\tif (!ok)\n+\t{\n\
    +\t\tfree(fullpath);\n+\t\tfullpath = NULL;\n+\t}\n \treturn fullpath;\n }\n \n\
    \ static BOOL drive_file_remove_dir(const WCHAR* path)\n {\n-\tWIN32_FIND_DATAW\
    \ findFileData;\n+\tWIN32_FIND_DATAW findFileData = { 0 };\n \tBOOL ret = TRUE;\n\
    -\tHANDLE dir;\n-\tWCHAR* fullpath;\n-\tWCHAR* path_slash;\n-\tsize_t base_path_length;\n\
    +\tHANDLE dir = INVALID_HANDLE_VALUE;\n+\tWCHAR* fullpath = NULL;\n+\tWCHAR* path_slash\
    \ = NULL;\n+\tsize_t base_path_length = 0;\n \n \tif (!path)\n \t\treturn FALSE;\n\
    \ \n-\tbase_path_length = _wcslen(path) * 2;\n-\tpath_slash = (WCHAR*)calloc(1,\
    \ base_path_length + sizeof(WCHAR) * 3);\n+\tbase_path_length = _wcslen(path);\n\
    +\tpath_slash = (WCHAR*)calloc(base_path_length + 3, sizeof(WCHAR));\n \n \tif\
    \ (!path_slash)\n \t{\n \t\tWLog_ERR(TAG, \"malloc failed!\");\n \t\treturn FALSE;\n\
    \ \t}\n \n-\tCopyMemory(path_slash, path, base_path_length);\n-\tpath_slash[base_path_length\
    \ / 2] = L'/';\n-\tpath_slash[base_path_length / 2 + 1] = L'*';\n+\tCopyMemory(path_slash,\
    \ path, base_path_length * sizeof(WCHAR));\n+\tpath_slash[base_path_length] =\
    \ L'/';\n+\tpath_slash[base_path_length + 1] = L'*';\n \tDEBUG_WSTR(\"Search in\
    \ %s\", path_slash);\n \tdir = FindFirstFileW(path_slash, &findFileData);\n-\t\
    path_slash[base_path_length / 2 + 1] = 0;\n \n \tif (dir == INVALID_HANDLE_VALUE)\n\
    \ \t{\n@@ -149,15 +176,15 @@ static BOOL drive_file_remove_dir(const WCHAR* path)\n\
    \ \n \tdo\n \t{\n-\t\tsize_t len = _wcslen(findFileData.cFileName);\n+\t\tconst\
    \ size_t len = _wcsnlen(findFileData.cFileName, ARRAYSIZE(findFileData.cFileName));\n\
    \ \n \t\tif ((len == 1 && findFileData.cFileName[0] == L'.') ||\n \t\t    (len\
    \ == 2 && findFileData.cFileName[0] == L'.' && findFileData.cFileName[1] == L'.'))\n\
    \ \t\t{\n \t\t\tcontinue;\n \t\t}\n \n-\t\tfullpath = drive_file_combine_fullpath(path_slash,\
    \ findFileData.cFileName, len * 2);\n+\t\tfullpath = drive_file_combine_fullpath(path_slash,\
    \ findFileData.cFileName, len);\n \t\tDEBUG_WSTR(\"Delete %s\", fullpath);\n \n\
    \ \t\tif (findFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)\n@@ -333,13\
    \ +360,13 @@ static BOOL drive_file_init(DRIVE_FILE* file)\n \treturn file->file_handle\
    \ != INVALID_HANDLE_VALUE;\n }\n \n-DRIVE_FILE* drive_file_new(const WCHAR* base_path,\
    \ const WCHAR* path, UINT32 PathLength, UINT32 id,\n-                        \
    \   UINT32 DesiredAccess, UINT32 CreateDisposition, UINT32 CreateOptions,\n- \
    \                          UINT32 FileAttributes, UINT32 SharedAccess)\n+DRIVE_FILE*\
    \ drive_file_new(const WCHAR* base_path, const WCHAR* path, UINT32 PathWCharLength,\n\
    +                           UINT32 id, UINT32 DesiredAccess, UINT32 CreateDisposition,\n\
    +                           UINT32 CreateOptions, UINT32 FileAttributes, UINT32\
    \ SharedAccess)\n {\n \tDRIVE_FILE* file;\n \n-\tif (!base_path || (!path && (PathLength\
    \ > 0)))\n+\tif (!base_path || (!path && (PathWCharLength > 0)))\n \t\treturn\
    \ NULL;\n \n \tfile = (DRIVE_FILE*)calloc(1, sizeof(DRIVE_FILE));\n@@ -359,7 +386,7\
    \ @@ DRIVE_FILE* drive_file_new(const WCHAR* base_path, const WCHAR* path, UINT32\
    \ Pat\n \tfile->CreateDisposition = CreateDisposition;\n \tfile->CreateOptions\
    \ = CreateOptions;\n \tfile->SharedAccess = SharedAccess;\n-\tdrive_file_set_fullpath(file,\
    \ drive_file_combine_fullpath(base_path, path, PathLength));\n+\tdrive_file_set_fullpath(file,\
    \ drive_file_combine_fullpath(base_path, path, PathWCharLength));\n \n \tif (!drive_file_init(file))\n\
    \ \t{\n@@ -714,13 +741,10 @@ BOOL drive_file_set_information(DRIVE_FILE* file,\
    \ UINT32 FsInformationClass, UIN\n \t\t\t\treturn FALSE;\n \n \t\t\tfullpath =\
    \ drive_file_combine_fullpath(file->basepath, (WCHAR*)Stream_Pointer(input),\n\
    -\t\t\t                                       FileNameLength);\n+\t\t\t      \
    \                                 FileNameLength / sizeof(WCHAR));\n \n \t\t\t\
    if (!fullpath)\n-\t\t\t{\n-\t\t\t\tWLog_ERR(TAG, \"drive_file_combine_fullpath\
    \ failed!\");\n \t\t\t\treturn FALSE;\n-\t\t\t}\n \n #ifdef _WIN32\n \n@@ -759,7\
    \ +783,7 @@ BOOL drive_file_set_information(DRIVE_FILE* file, UINT32 FsInformationClass,\
    \ UIN\n }\n \n BOOL drive_file_query_directory(DRIVE_FILE* file, UINT32 FsInformationClass,\
    \ BYTE InitialQuery,\n-                                const WCHAR* path, UINT32\
    \ PathLength, wStream* output)\n+                                const WCHAR*\
    \ path, UINT32 PathWCharLength, wStream* output)\n {\n \tsize_t length;\n \tWCHAR*\
    \ ent_path;\n@@ -773,7 +797,7 @@ BOOL drive_file_query_directory(DRIVE_FILE* file,\
    \ UINT32 FsInformationClass, BYT\n \t\tif (file->find_handle != INVALID_HANDLE_VALUE)\n\
    \ \t\t\tFindClose(file->find_handle);\n \n-\t\tent_path = drive_file_combine_fullpath(file->basepath,\
    \ path, PathLength);\n+\t\tent_path = drive_file_combine_fullpath(file->basepath,\
    \ path, PathWCharLength);\n \t\t/* open new search handle and retrieve the first\
    \ entry */\n \t\tfile->find_handle = FindFirstFileW(ent_path, &file->find_data);\n\
    \ \t\tfree(ent_path);"
  - "--- a/channels/drive/client/drive_main.c\n+++ b/channels/drive/client/drive_main.c\n\
    @@ -184,8 +184,8 @@ static UINT drive_process_irp_create(DRIVE_DEVICE* drive,\
    \ IRP* irp)\n \n \tpath = (const WCHAR*)Stream_Pointer(irp->input);\n \tFileId\
    \ = irp->devman->id_sequence++;\n-\tfile = drive_file_new(drive->path, path, PathLength,\
    \ FileId, DesiredAccess, CreateDisposition,\n-\t                      CreateOptions,\
    \ FileAttributes, SharedAccess);\n+\tfile = drive_file_new(drive->path, path,\
    \ PathLength / sizeof(WCHAR), FileId, DesiredAccess,\n+\t                    \
    \  CreateDisposition, CreateOptions, FileAttributes, SharedAccess);\n \n \tif\
    \ (!file)\n \t{\n@@ -639,8 +639,8 @@ static UINT drive_process_irp_query_directory(DRIVE_DEVICE*\
    \ drive, IRP* irp)\n \t\tirp->IoStatus = STATUS_UNSUCCESSFUL;\n \t\tStream_Write_UINT32(irp->output,\
    \ 0); /* Length */\n \t}\n-\telse if (!drive_file_query_directory(file, FsInformationClass,\
    \ InitialQuery, path, PathLength,\n-\t                                     irp->output))\n\
    +\telse if (!drive_file_query_directory(file, FsInformationClass, InitialQuery,\
    \ path,\n+\t                                     PathLength / sizeof(WCHAR), irp->output))\n\
    \ \t{\n \t\tirp->IoStatus = drive_map_windows_err(GetLastError());\n \t}"
  identifiers:
  - CVE-2022-39347
  - CWE-22
  overview: FreeRDP is a free remote desktop protocol library and clients. Affected
    versions of FreeRDP are missing path canonicalization and base path check for
    `drive` channel. A malicious server can trick a FreeRDP based client to read files
    outside the shared directory. This issue has been addressed in version 2.9.0 and
    all users are advised to upgrade. Users unable to upgrade should not use the `/drive`,
    `/drives` or `+home-drive` redirection switch.
  references:
  - source: security-advisories@github.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/FreeRDP/FreeRDP/commit/027424c2c6c0991cb9c22f9511478229c9b17e5d
  - source: security-advisories@github.com
    tags:
    - Third Party Advisory
    url: https://github.com/FreeRDP/FreeRDP/security/advisories/GHSA-c5xq-8v35-pffg
  - source: security-advisories@github.com
    url: https://lists.debian.org/debian-lts-announce/2023/11/msg00010.html
  - source: security-advisories@github.com
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/UDOTAOJBCZKREZJPT6VZ25GESI5T6RBG/
  - source: security-advisories@github.com
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/YGQN3OWQNHSMWKOF4D35PF5ASKNLC74B/
  - source: security-advisories@github.com
    url: https://security.gentoo.org/glsa/202401-16
  title: FreeRDP is a free remote desktop protocol library and clients. Affected versions
    of FreeRDP are missing path canonicalization and base path check for `drive` channel.
    A malicious server can trick a FreeRDP based client to read files outside the
    shared directory. This issue has been addressed in version 2.9.0 and all users
    are advised to upgrade. Users unable to upgrade should not use the `/drive`, `/drives`
    or `+home-drive` redirection switch.
- diff_content:
  - "--- a/channels/drive/client/drive_main.c\n+++ b/channels/drive/client/drive_main.c\n\
    @@ -629,6 +629,9 @@ static UINT drive_process_irp_query_directory(DRIVE_DEVICE*\
    \ drive, IRP* irp)\n \tStream_Read_UINT32(irp->input, PathLength);\n \tStream_Seek(irp->input,\
    \ 23); /* Padding */\n \tpath = (WCHAR*)Stream_Pointer(irp->input);\n+\tif (!Stream_CheckAndLogRequiredLength(TAG,\
    \ irp->input, PathLength))\n+\t\treturn ERROR_INVALID_DATA;\n+\n \tfile = drive_get_file_by_id(drive,\
    \ irp->FileId);\n \n \tif (file == NULL)"
  identifiers:
  - CVE-2022-41877
  - CWE-1284
  overview: FreeRDP is a free remote desktop protocol library and clients. Affected
    versions of FreeRDP are missing input length validation in `drive` channel. A
    malicious server can trick a FreeRDP based client to read out of bound data and
    send it back to the server. This issue has been addressed in version 2.9.0 and
    all users are advised to upgrade. Users unable to upgrade should not use the drive
    redirection channel - command line options `/drive`, `+drives` or `+home-drive`.
  references:
  - source: security-advisories@github.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/FreeRDP/FreeRDP/commit/6655841cf2a00b764f855040aecb8803cfc5eaba
  - source: security-advisories@github.com
    tags:
    - Third Party Advisory
    url: https://github.com/FreeRDP/FreeRDP/security/advisories/GHSA-pmv3-wpw4-pw5h
  - source: security-advisories@github.com
    url: https://lists.debian.org/debian-lts-announce/2023/11/msg00010.html
  - source: security-advisories@github.com
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/UDOTAOJBCZKREZJPT6VZ25GESI5T6RBG/
  - source: security-advisories@github.com
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/YGQN3OWQNHSMWKOF4D35PF5ASKNLC74B/
  - source: security-advisories@github.com
    url: https://security.gentoo.org/glsa/202401-16
  title: FreeRDP is a free remote desktop protocol library and clients. Affected versions
    of FreeRDP are missing input length validation in `drive` channel. A malicious
    server can trick a FreeRDP based client to read out of bound data and send it
    back to the server. This issue has been addressed in version 2.9.0 and all users
    are advised to upgrade. Users unable to upgrade should not use the drive redirection
    channel - command line options `/drive`, `+drives` or `+home-drive`.
- diff_content:
  - "--- a/channels/urbdrc/client/libusb/libusb_udevice.c\n+++ b/channels/urbdrc/client/libusb/libusb_udevice.c\n\
    @@ -1221,12 +1221,18 @@ static int libusb_udev_isoch_transfer(IUDEVICE* idev,\
    \ URBDRC_CHANNEL_CALLBACK* c\n \tif (!Buffer)\n \t\tStream_Seek(user_data->data,\
    \ (NumberOfPackets * 12));\n \n-\tiso_packet_size = BufferSize / NumberOfPackets;\n\
    -\tiso_transfer = libusb_alloc_transfer(NumberOfPackets);\n+\tif (NumberOfPackets\
    \ > 0)\n+\t{\n+\t\tiso_packet_size = BufferSize / NumberOfPackets;\n+\t\tiso_transfer\
    \ = libusb_alloc_transfer((int)NumberOfPackets);\n+\t}\n \n \tif (iso_transfer\
    \ == NULL)\n \t{\n-\t\tWLog_Print(urbdrc->log, WLOG_ERROR, \"Error: libusb_alloc_transfer.\"\
    );\n+\t\tWLog_Print(urbdrc->log, WLOG_ERROR,\n+\t\t           \"Error: libusb_alloc_transfer\
    \ [NumberOfPackets=%\" PRIu32 \", BufferSize=%\" PRIu32\n+\t\t           \" ]\"\
    ,\n+\t\t           NumberOfPackets, BufferSize);\n \t\tasync_transfer_user_data_free(user_data);\n\
    \ \t\treturn -1;\n \t}"
  identifiers:
  - CVE-2022-39318
  - CWE-20
  overview: FreeRDP is a free remote desktop protocol library and clients. Affected
    versions of FreeRDP are missing input validation in `urbdrc` channel. A malicious
    server can trick a FreeRDP based client to crash with division by zero. This issue
    has been addressed in version 2.9.0. All users are advised to upgrade. Users unable
    to upgrade should not use the `/usb` redirection switch.
  references:
  - source: security-advisories@github.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/FreeRDP/FreeRDP/commit/80adde17ddc4b596ed1dae0922a0c54ab3d4b8ea
  - source: security-advisories@github.com
    tags:
    - Third Party Advisory
    url: https://github.com/FreeRDP/FreeRDP/security/advisories/GHSA-387j-8j96-7q35
  - source: security-advisories@github.com
    url: https://lists.debian.org/debian-lts-announce/2023/11/msg00010.html
  - source: security-advisories@github.com
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/UDOTAOJBCZKREZJPT6VZ25GESI5T6RBG/
  - source: security-advisories@github.com
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/YGQN3OWQNHSMWKOF4D35PF5ASKNLC74B/
  - source: security-advisories@github.com
    url: https://security.gentoo.org/glsa/202401-16
  title: FreeRDP is a free remote desktop protocol library and clients. Affected versions
    of FreeRDP are missing input validation in `urbdrc` channel. A malicious server
    can trick a FreeRDP based client to crash with division by zero. This issue has
    been addressed in version 2.9.0. All users are advised to upgrade. Users unable
    to upgrade should not use the `/usb` redirection switch.
- diff_content:
  - "--- a/channels/urbdrc/client/data_transfer.c\n+++ b/channels/urbdrc/client/data_transfer.c\n\
    @@ -247,6 +247,10 @@ static UINT urbdrc_process_io_control(IUDEVICE* pdev, URBDRC_CHANNEL_CALLBACK*\
    \ c\n \n \tStream_Read_UINT32(s, OutputBufferSize);\n \tStream_Read_UINT32(s,\
    \ RequestId);\n+\n+\tif (OutputBufferSize > UINT32_MAX - 4)\n+\t\treturn ERROR_INVALID_DATA;\n\
    +\n \tInterfaceId = ((STREAM_ID_PROXY << 30) | pdev->get_ReqCompletion(pdev));\n\
    \ \tout = urb_create_iocompletion(InterfaceId, MessageId, RequestId, OutputBufferSize\
    \ + 4);\n \n@@ -726,6 +730,15 @@ static UINT urb_bulk_or_interrupt_transfer(IUDEVICE*\
    \ pdev, URBDRC_CHANNEL_CALLBA\n \tStream_Read_UINT32(s, TransferFlags); /** TransferFlags\
    \ */\n \tStream_Read_UINT32(s, OutputBufferSize);\n \tEndpointAddress = (PipeHandle\
    \ & 0x000000ff);\n+\n+\tif (transferDir == USBD_TRANSFER_DIRECTION_OUT)\n+\t{\n\
    +\t\tif (!Stream_CheckAndLogRequiredLength(TAG, s, OutputBufferSize))\n+\t\t{\n\
    +\t\t\treturn ERROR_INVALID_DATA;\n+\t\t}\n+\t}\n+\n \t/**  process TS_URB_BULK_OR_INTERRUPT_TRANSFER\
    \ */\n \treturn pdev->bulk_or_interrupt_transfer(\n \t    pdev, callback, MessageId,\
    \ RequestId, EndpointAddress, TransferFlags, noAck,\n@@ -810,6 +823,13 @@ static\
    \ UINT urb_isoch_transfer(IUDEVICE* pdev, URBDRC_CHANNEL_CALLBACK* callback\n\
    \ \tpacketDescriptorData = Stream_Pointer(s);\n \tStream_Seek(s, NumberOfPackets\
    \ * 12);\n \tStream_Read_UINT32(s, OutputBufferSize);\n+\n+\tif (transferDir ==\
    \ USBD_TRANSFER_DIRECTION_OUT)\n+\t{\n+\t\tif (!Stream_CheckAndLogRequiredLength(TAG,\
    \ s, OutputBufferSize))\n+\t\t\treturn ERROR_INVALID_DATA;\n+\t}\n+\n \treturn\
    \ pdev->isoch_transfer(\n \t    pdev, callback, MessageId, RequestId, EndpointAddress,\
    \ TransferFlags, StartFrame,\n \t    ErrorCount, noAck, packetDescriptorData,\
    \ NumberOfPackets, OutputBufferSize,"
  identifiers:
  - CVE-2022-39319
  - CWE-125
  overview: FreeRDP is a free remote desktop protocol library and clients. Affected
    versions of FreeRDP are missing input length validation in the `urbdrc` channel.
    A malicious server can trick a FreeRDP based client to read out of bound data
    and send it back to the server. This issue has been addressed in version 2.9.0
    and all users are advised to upgrade. Users unable to upgrade should not use the
    `/usb` redirection switch.
  references:
  - source: security-advisories@github.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/FreeRDP/FreeRDP/commit/11555828d2cf289b350baba5ad1f462f10b80b76
  - source: security-advisories@github.com
    tags:
    - Third Party Advisory
    url: https://github.com/FreeRDP/FreeRDP/security/advisories/GHSA-mvxm-wfj2-5fvh
  - source: security-advisories@github.com
    url: https://lists.debian.org/debian-lts-announce/2023/11/msg00010.html
  - source: security-advisories@github.com
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/UDOTAOJBCZKREZJPT6VZ25GESI5T6RBG/
  - source: security-advisories@github.com
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/YGQN3OWQNHSMWKOF4D35PF5ASKNLC74B/
  - source: security-advisories@github.com
    url: https://security.gentoo.org/glsa/202401-16
  title: FreeRDP is a free remote desktop protocol library and clients. Affected versions
    of FreeRDP are missing input length validation in the `urbdrc` channel. A malicious
    server can trick a FreeRDP based client to read out of bound data and send it
    back to the server. This issue has been addressed in version 2.9.0 and all users
    are advised to upgrade. Users unable to upgrade should not use the `/usb` redirection
    switch.
- diff_content:
  - "--- a/src/controller.cpp\n+++ b/src/controller.cpp\n@@ -68,6 +68,7 @@ THE SOFTWARE.\n\
    \ #include <boost/log/sinks.hpp>\n #include <boost/log/sources/logger.hpp>\n #include\
    \ <boost/algorithm/string/replace.hpp>\n+#include <boost/filesystem.hpp>\n \n\
    \ #if defined(__clang__)\n     #pragma clang diagnostic pop\n@@ -1006,6 +1007,13\
    \ @@ namespace drachtio {\n                     ));\n                        \
    \        \n                     logging::core::get()->add_sink(m_sinkTextFile);\n\
    +                    boost::filesystem::permissions(name,\n+                 \
    \       boost::filesystem::perms::owner_read |\n+                        boost::filesystem::perms::owner_write\
    \ |\n+                        boost::filesystem::perms::group_read |\n+      \
    \                  boost::filesystem::perms::group_write\n+                  \
    \  );\n+\n                 }\n                 logging::core::get()->set_filter(\n\
    \                    expr::attr<severity_levels>(\"Severity\") <= m_current_severity_threshold"
  identifiers:
  - CVE-2022-45473
  - NVD-CWE-noinfo
  overview: In drachtio-server 0.8.18, /var/log/drachtio has mode 0777 and drachtio.log
    has mode 0666.
  references:
  - source: cve@mitre.org
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/drachtio/drachtio-server/commit/f791a9313c58a911ce09f465f4bba594243b29ec
  - source: cve@mitre.org
    tags:
    - Exploit
    - Issue Tracking
    - Third Party Advisory
    url: https://github.com/drachtio/drachtio-server/issues/241
  title: In drachtio-server 0.8.18, /var/log/drachtio has mode 0777 and drachtio.log
    has mode 0666.
- diff_content:
  - "--- a/src/request-handler.cpp\n+++ b/src/request-handler.cpp\n@@ -267,6 +267,7\
    \ @@ namespace drachtio {\n   void event_cb(drachtio::RequestHandler::GlobalInfo\
    \ *g, curl_socket_t s,\n                        int action, const boost::system::error_code\
    \ & error,\n                        int *fdp) {\n+    int f = *fdp;\n     std::shared_ptr<RequestHandler>\
    \ p = RequestHandler::getInstance() ;\n     std::map<curl_socket_t, boost::asio::ip::tcp::socket\
    \ *>& socket_map = p->getSocketMap() ;\n     boost::asio::deadline_timer& timer\
    \ = p->getTimer() ;\n@@ -277,7 +278,7 @@ namespace drachtio {\n     }\n \n   \
    \  /* make sure the event matches what are wanted */\n-    if(*fdp == action ||\
    \ *fdp == CURL_POLL_INOUT) {\n+    if(f == action || f == CURL_POLL_INOUT) {\n\
    \       CURLMcode rc;\n       if(error)\n         action = CURL_CSELECT_ERR;\n\
    @@ -294,7 +295,7 @@ namespace drachtio {\n        * the socket may have been closed\
    \ and/or fdp may have been changed\n        * in curl_multi_socket_action(), so\
    \ check them both */\n       if(!error && socket_map.find(s) != socket_map.end()\
    \ &&\n-         (*fdp == action || *fdp == CURL_POLL_INOUT)) {\n+         (f ==\
    \ action || f == CURL_POLL_INOUT)) {\n         boost::asio::ip::tcp::socket *tcp_socket\
    \ = socket_map.find(s)->second;\n \n         if(action == CURL_POLL_IN) {\n@@\
    \ -498,6 +498,7 @@ namespace drachtio {\n     strncpy(conn->body, body.c_str(),\
    \ HTTP_BODY_LEN);\n     strncpy(conn->transactionId, transactionId.c_str(), TXNID_LEN);\n\
    \     conn->hdr_list = NULL ;\n+    *conn->response = '\\0' ;\n \n     curl_easy_setopt(easy,\
    \ CURLOPT_URL, conn->url);\n     curl_easy_setopt(easy, CURLOPT_WRITEFUNCTION,\
    \ write_cb);"
  identifiers:
  - CVE-2022-45474
  - CWE-416
  overview: drachtio-server 0.8.18 has a request-handler.cpp event_cb use-after-free
    for any request.
  references:
  - source: cve@mitre.org
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/drachtio/drachtio-server/commit/860f025468feb31c43227153d8fb3f34210a522e
  - source: cve@mitre.org
    tags:
    - Exploit
    - Issue Tracking
    - Third Party Advisory
    url: https://github.com/drachtio/drachtio-server/issues/240
  title: drachtio-server 0.8.18 has a request-handler.cpp event_cb use-after-free
    for any request.
- diff_content:
  - "--- a/src/onion/response.c\n+++ b/src/onion/response.c\n@@ -431,9 +431,9 @@ int\
    \ onion_response_flush(onion_response * res) {\n     char tmp[16];\n     snprintf(tmp,\
    \ sizeof(tmp), \"%X\\r\\n\", (unsigned int)res->buffer_pos);\n     if ((w = write(req,\
    \ tmp, strlen(tmp))) <= 0) {\n-      ONION_WARNING(\"Error writing chunk encoding\
    \ length (%X) %s. Aborting write.\",\n-\n-\t\t    (unsigned int)res->buffer_pos,\
    \ strerror(errno));\n+      ONION_CALL_MAX_ONCE_PER_T_COUNT(1, ONION_WARNING,\
    \ \"Error writing chunk encoding length (%X) %s. Aborting write. (x%u)\",\n+ \
    \       (unsigned int)res->buffer_pos, strerror(errno));\n+      \n       return\
    \ OCS_CLOSE_CONNECTION;\n     }\n     ONION_DEBUG0(\"Write %d-%d bytes\", res->buffer_pos,\
    \ w);"
  identifiers:
  - CVE-2022-4066
  - CWE-404
  overview: A vulnerability was found in davidmoreno onion. It has been rated as problematic.
    Affected by this issue is the function onion_response_flush of the file src/onion/response.c
    of the component Log Handler. The manipulation leads to allocation of resources.
    The name of the patch is de8ea938342b36c28024fd8393ebc27b8442a161. It is recommended
    to apply a patch to fix this issue. The identifier of this vulnerability is VDB-214028.
  references:
  - source: cna@vuldb.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/davidmoreno/onion/commit/de8ea938342b36c28024fd8393ebc27b8442a161
  - source: cna@vuldb.com
    tags:
    - Exploit
    - Patch
    - Third Party Advisory
    url: https://github.com/davidmoreno/onion/pull/308
  - source: cna@vuldb.com
    tags:
    - Third Party Advisory
    url: https://vuldb.com/?id.214028
  title: A vulnerability was found in davidmoreno onion. It has been rated as problematic.
    Affected by this issue is the function onion_response_flush of the file src/onion/response.c
    of the component Log Handler. The manipulation leads to allocation of resources.
    The name of the patch is de8ea938342b36c28024fd8393ebc27b8442a161. It is recommended
    to apply a patch to fix this issue. The identifier of this vulnerability is VDB-214028.
- diff_content:
  - "--- a/src/net/tls.c\n+++ b/src/net/tls.c\n@@ -2821,8 +2821,8 @@ static int tls_new_ciphertext\
    \ ( struct tls_connection *tls,\n \tif ( is_block_cipher ( cipher ) ) {\n \t\t\
    pad_len = tls_verify_padding ( tls, last );\n \t\tif ( pad_len < 0 ) {\n-\t\t\t\
    rc = pad_len;\n-\t\t\treturn rc;\n+\t\t\t/* Assume zero padding length to avoid\
    \ timing attacks */\n+\t\t\tpad_len = 0;\n \t\t}\n \t\tiob_unput ( last, pad_len\
    \ );\n \t\tlen -= pad_len;"
  identifiers:
  - CVE-2022-4087
  - CWE-203
  overview: A vulnerability was found in iPXE. It has been declared as problematic.
    This vulnerability affects the function tls_new_ciphertext of the file src/net/tls.c
    of the component TLS. The manipulation of the argument pad_len leads to information
    exposure through discrepancy. The name of the patch is 186306d6199096b7a7c4b4574d4be8cdb8426729.
    It is recommended to apply a patch to fix this issue. VDB-214054 is the identifier
    assigned to this vulnerability.
  references:
  - source: cna@vuldb.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/ipxe/ipxe/commit/186306d6199096b7a7c4b4574d4be8cdb8426729
  - source: cna@vuldb.com
    tags:
    - Third Party Advisory
    url: https://vuldb.com/?id.214054
  title: A vulnerability was found in iPXE. It has been declared as problematic. This
    vulnerability affects the function tls_new_ciphertext of the file src/net/tls.c
    of the component TLS. The manipulation of the argument pad_len leads to information
    exposure through discrepancy. The name of the patch is 186306d6199096b7a7c4b4574d4be8cdb8426729.
    It is recommended to apply a patch to fix this issue. VDB-214054 is the identifier
    assigned to this vulnerability.
- diff_content:
  - "--- a/io_uring/msg_ring.c\n+++ b/io_uring/msg_ring.c\n@@ -165,7 +165,8 @@ int\
    \ io_msg_ring(struct io_kiocb *req, unsigned int issue_flags)\n \t\treq_set_fail(req);\n\
    \ \tio_req_set_res(req, ret, 0);\n \t/* put file to avoid an attempt to IOPOLL\
    \ the req */\n-\tio_put_file(req->file);\n+\tif (!(req->flags & REQ_F_FIXED_FILE))\n\
    +\t\tio_put_file(req->file);\n \treq->file = NULL;\n \treturn IOU_OK;\n }"
  identifiers:
  - CVE-2022-3910
  - NVD-CWE-Other
  overview: "Use After Free vulnerability in Linux Kernel allows Privilege Escalation.\
    \ An improper Update of Reference Count in io_uring leads to Use-After-Free and\
    \ Local Privilege Escalation.\nWhen io_msg_ring was invoked with a fixed file,\
    \ it called io_fput_file() which improperly decreased its reference count (leading\
    \ to Use-After-Free and Local Privilege Escalation). Fixed files are permanently\
    \ registered to the ring, and should not be put separately.\n\nWe recommend upgrading\
    \ past commit  https://github.com/torvalds/linux/commit/fc7222c3a9f56271fba02aabbfbae999042f1679\
    \ https://github.com/torvalds/linux/commit/fc7222c3a9f56271fba02aabbfbae999042f1679\
    \ \n"
  references:
  - source: cve-coordination@google.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/torvalds/linux/commit/fc7222c3a9f56271fba02aabbfbae999042f1679
  - source: cve-coordination@google.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://kernel.dance/#fc7222c3a9f56271fba02aabbfbae999042f1679
  title: "Use After Free vulnerability in Linux Kernel allows Privilege Escalation.\
    \ An improper Update of Reference Count in io_uring leads to Use-After-Free and\
    \ Local Privilege Escalation.\nWhen io_msg_ring was invoked with a fixed file,\
    \ it called io_fput_file() which improperly decreased its reference count (leading\
    \ to Use-After-Free and Local Privilege Escalation). Fixed files are permanently\
    \ registered to the ring, and should not be put separately.\n\nWe recommend upgrading\
    \ past commit  https://github.com/torvalds/linux/commit/fc7222c3a9f56271fba02aabbfbae999042f1679\
    \ https://github.com/torvalds/linux/commit/fc7222c3a9f56271fba02aabbfbae999042f1679\
    \ \n"
- diff_content:
  - "--- a/net/bluetooth/l2cap_core.c\n+++ b/net/bluetooth/l2cap_core.c\n@@ -3764,7\
    \ +3764,8 @@ static int l2cap_parse_conf_req(struct l2cap_chan *chan, void *data,\
    \ size_t data\n \t\t\tl2cap_add_conf_opt(&ptr, L2CAP_CONF_RFC,\n \t\t\t\t\t  \
    \ sizeof(rfc), (unsigned long) &rfc, endptr - ptr);\n \n-\t\t\tif (test_bit(FLAG_EFS_ENABLE,\
    \ &chan->flags)) {\n+\t\t\tif (remote_efs &&\n+\t\t\t    test_bit(FLAG_EFS_ENABLE,\
    \ &chan->flags)) {\n \t\t\t\tchan->remote_id = efs.id;\n \t\t\t\tchan->remote_stype\
    \ = efs.stype;\n \t\t\t\tchan->remote_msdu = le16_to_cpu(efs.msdu);"
  identifiers:
  - CVE-2022-42895
  - CWE-824
  overview: "There is an infoleak vulnerability in the Linux kernel's net/bluetooth/l2cap_core.c's\
    \ l2cap_parse_conf_req function which can be used to leak kernel pointers remotely.\n\
    We recommend upgrading past commit\_ https://github.com/torvalds/linux/commit/b1a2cd50c0357f243b7435a732b4e62ba3157a2e\
    \ https://www.google.com/url \n\n"
  references:
  - source: cve-coordination@google.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/torvalds/linux/commit/b1a2cd50c0357f243b7435a732b4e62ba3157a2e
  - source: cve-coordination@google.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://kernel.dance/#b1a2cd50c0357f243b7435a732b4e62ba3157a2e
  title: "There is an infoleak vulnerability in the Linux kernel's net/bluetooth/l2cap_core.c's\
    \ l2cap_parse_conf_req function which can be used to leak kernel pointers remotely.\n\
    We recommend upgrading past commit\_ https://github.com/torvalds/linux/commit/b1a2cd50c0357f243b7435a732b4e62ba3157a2e\
    \ https://www.google.com/url \n\n"
- diff_content:
  - "--- a/net/bluetooth/l2cap_core.c\n+++ b/net/bluetooth/l2cap_core.c\n@@ -5813,6\
    \ +5813,19 @@ static int l2cap_le_connect_req(struct l2cap_conn *conn,\n \tBT_DBG(\"\
    psm 0x%2.2x scid 0x%4.4x mtu %u mps %u\", __le16_to_cpu(psm),\n \t       scid,\
    \ mtu, mps);\n \n+\t/* BLUETOOTH CORE SPECIFICATION Version 5.3 | Vol 3, Part\
    \ A\n+\t * page 1059:\n+\t *\n+\t * Valid range: 0x0001-0x00ff\n+\t *\n+\t * Table\
    \ 4.15: L2CAP_LE_CREDIT_BASED_CONNECTION_REQ SPSM ranges\n+\t */\n+\tif (!psm\
    \ || __le16_to_cpu(psm) > L2CAP_PSM_LE_DYN_END) {\n+\t\tresult = L2CAP_CR_LE_BAD_PSM;\n\
    +\t\tchan = NULL;\n+\t\tgoto response;\n+\t}\n+\n \t/* Check if we have socket\
    \ listening on psm */\n \tpchan = l2cap_global_chan_by_psm(BT_LISTEN, psm, &conn->hcon->src,\n\
    \ \t\t\t\t\t &conn->hcon->dst, LE_LINK);\n@@ -6001,6 +6014,18 @@ static inline\
    \ int l2cap_ecred_conn_req(struct l2cap_conn *conn,\n \n \tpsm  = req->psm;\n\
    \ \n+\t/* BLUETOOTH CORE SPECIFICATION Version 5.3 | Vol 3, Part A\n+\t * page\
    \ 1059:\n+\t *\n+\t * Valid range: 0x0001-0x00ff\n+\t *\n+\t * Table 4.15: L2CAP_LE_CREDIT_BASED_CONNECTION_REQ\
    \ SPSM ranges\n+\t */\n+\tif (!psm || __le16_to_cpu(psm) > L2CAP_PSM_LE_DYN_END)\
    \ {\n+\t\tresult = L2CAP_CR_LE_BAD_PSM;\n+\t\tgoto response;\n+\t}\n+\n \tBT_DBG(\"\
    psm 0x%2.2x mtu %u mps %u\", __le16_to_cpu(psm), mtu, mps);\n \n \tmemset(&pdu,\
    \ 0, sizeof(pdu));"
  identifiers:
  - CVE-2022-42896
  - CWE-416
  overview: "There are use-after-free vulnerabilities in the Linux kernel's net/bluetooth/l2cap_core.c's\
    \ l2cap_connect and l2cap_le_connect_req functions which may allow code execution\
    \ and leaking kernel memory (respectively) remotely via Bluetooth.\_A remote attacker\
    \ could execute code leaking kernel memory via Bluetooth if within proximity of\
    \ the victim.\n\nWe recommend upgrading past commit\_  https://www.google.com/url\
    \  https://github.com/torvalds/linux/commit/711f8c3fb3db61897080468586b970c87c61d9e4\
    \ https://www.google.com/url \n\n"
  references:
  - source: cve-coordination@google.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/torvalds/linux/commit/711f8c3fb3db61897080468586b970c87c61d9e4
  - source: cve-coordination@google.com
    tags:
    - Patch
    - Vendor Advisory
    url: https://kernel.dance/#711f8c3fb3db61897080468586b970c87c61d9e4
  title: "There are use-after-free vulnerabilities in the Linux kernel's net/bluetooth/l2cap_core.c's\
    \ l2cap_connect and l2cap_le_connect_req functions which may allow code execution\
    \ and leaking kernel memory (respectively) remotely via Bluetooth.\_A remote attacker\
    \ could execute code leaking kernel memory via Bluetooth if within proximity of\
    \ the victim.\n\nWe recommend upgrading past commit\_  https://www.google.com/url\
    \  https://github.com/torvalds/linux/commit/711f8c3fb3db61897080468586b970c87c61d9e4\
    \ https://www.google.com/url \n\n"
- diff_content:
  - "--- a/qpress.cpp\n+++ b/qpress.cpp\n@@ -183,7 +183,9 @@ unsigned long long bench_size;\n\
    \ unsigned long long recovery_file_written;\r\n unsigned long long recovery_bad_bytes\
    \ = 0;\r\n unsigned long long current_file_payload;\r\n-char tmp[200000];\r\n\
    +const long NAME_BUFFER_SIZE = 200000;\r\n+char tmp[NAME_BUFFER_SIZE];\r\n+\r\n\
    \ \r\n enum {FATAL_ERROR, COUNTER_UPDATE, FILES_PROCESSED, RESULT, WARNING};\r\
    \n \r\n@@ -935,6 +937,21 @@ void compress_directory(string base_dir, string pattern)\n\
    \ \t}\r\n  }\r\n \r\n+bool check_if_path_has_dir_traversal(char * new_path)\r\n\
    +{\r\n+    bool ret_val = false;\r\n+    char *found_template1 = NULL;\r\n+\t\
    found_template1 = strstr (new_path,\"../\");\r\n+\t#ifdef WINDOWS \r\n+\t    char\
    \ *found_template2 = NULL;\r\n+\t    found_template2 = strstr (new_path,\"..\\\
    \\\");\r\n+\t    ret_val = (found_template1 !=  NULL) || (found_template2 != NULL);\r\
    \n+\t#else\r\n+\t    ret_val = found_template1 !=  NULL;\r\n+\t#endif\r\n+   \
    \ \r\n+    return ret_val;\r\n+}\r\n \r\n void decompress_directory(string extract_dir,\
    \ bool std_out)\r\n {\r\n@@ -955,9 +972,21 @@ void decompress_directory(string\
    \ extract_dir, bool std_out)\n         {\r\n \t\t\t// read directory name, append\
    \ it to current path and create the directory\r\n             chunk_size = fread32();\r\
    \n+\t\t\tif(NAME_BUFFER_SIZE < chunk_size + 1)\r\n+            {\r\n+        \
    \        abort(\"File path string is bigger than buffer size\");\r\n+        \
    \    }\r\n             try_aread(tmp, chunk_size + 1);\r\n             curdir\
    \ = curdir + DELIM_STR + tmp;\r\n             PRINT(FILES_PROCESSED, \"%s%s%s\\\
    n\", BLANK_LINE, remove_leading_curdir(curdir).c_str(), DELIM_STR);\r\n+\t\t\t\
    /* RDS security fix: https://rds-jira.amazon.com/browse/MMCP-231\r\n+\t \t\tNeed\
    \ to check if we try to decompress file or directory outside working directory\r\
    \n+\t \t\t*/\r\n+\t        if(true == check_if_path_has_dir_traversal(tmp)) \r\
    \n+            {\r\n+\t            abort(\"Directory path contains directory traversal\
    \ which is not allowed.\");\r\n+\t        }\r\n+\t        /* End of RDS security\
    \ fix*/\r\n             if(!std_out)\r\n             {\r\n #ifdef WINDOWS\r\n\
    @@ -972,7 +1001,19 @@ void decompress_directory(string extract_dir, bool std_out)\n\
    \         else if(c == 'F')\r\n         {\r\n             chunk_size = fread32();\
    \ // read length of file name\r\n-            try_aread(tmp, chunk_size + 1);\
    \ // read file name\r\n+            if(NAME_BUFFER_SIZE < chunk_size + 1)\r\n\
    +\t             {\r\n+\t                 abort(\"File path string is bigger than\
    \ buffer size\");\r\n+\t             }\r\n+\t             try_aread(tmp, chunk_size\
    \ + 1); // read file name to 'tmp' with size 'chunk_size + 1'\r\n+\t         /*\
    \ RDS security fix: https://rds-jira.amazon.com/browse/MMCP-231\r\n+\t \t\t  \
    \ Need to check if we try to decompress file or directory outside working directory\r\
    \n+\t \t\t*/\r\n+\t         if(true == check_if_path_has_dir_traversal(tmp)) \r\
    \n+\t         {\r\n+\t             abort(\"File path contains directory traversal\
    \ which is not allowed.\");\r\n+\t         }\r\n+\t         /* End of RDS security\
    \ fix*/\r\n             string buf2 = curdir + DELIM_STR + tmp;\r\n          \
    \   PRINT(FILES_PROCESSED, \"%s    %s\\n\", BLANK_LINE, tmp);\r\n            \
    \ if(!std_out)\r"
  identifiers:
  - CVE-2022-45866
  - CWE-22
  overview: qpress before PierreLvx/qpress 20220819 and before version 11.3, as used
    in Percona XtraBackup and other products, allows directory traversal via ../ in
    a .qp file.
  references:
  - source: cve@mitre.org
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/EvgeniyPatlan/qpress/commit/ddb312090ebd5794e81bc6fb1dfb4e79eda48761
  - source: cve@mitre.org
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/PierreLvx/qpress/compare/20170415...20220819
  - source: cve@mitre.org
    tags:
    - Exploit
    - Third Party Advisory
    url: https://github.com/PierreLvx/qpress/pull/6
  - source: cve@mitre.org
    tags:
    - Exploit
    - Third Party Advisory
    url: https://github.com/percona/percona-xtrabackup/pull/1366
  - source: cve@mitre.org
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/BQWF7635AJSDKEIGLB73XAH643POGTFY/
  - source: cve@mitre.org
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/G4RXO3VYIFRTNIFHWIAZWND6ZXQ5OYOB/
  - source: cve@mitre.org
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/UUZ73XT2FXLHC7I4ODLOVB4O4QN7Q7JB/
  - source: cve@mitre.org
    tags:
    - Product
    url: https://pkgs.org/download/qpress
  title: qpress before PierreLvx/qpress 20220819 and before version 11.3, as used
    in Percona XtraBackup and other products, allows directory traversal via ../ in
    a .qp file.
- diff_content:
  - "--- a/jsobject.c\n+++ b/jsobject.c\n@@ -134,25 +134,25 @@ static void O_getOwnPropertyDescriptor(js_State\
    \ *J)\n \t\tjs_newobject(J);\n \t\tif (!ref->getter && !ref->setter) {\n \t\t\t\
    js_pushvalue(J, ref->value);\n-\t\t\tjs_setproperty(J, -2, \"value\");\n+\t\t\t\
    js_defproperty(J, -2, \"value\", 0);\n \t\t\tjs_pushboolean(J, !(ref->atts & JS_READONLY));\n\
    -\t\t\tjs_setproperty(J, -2, \"writable\");\n+\t\t\tjs_defproperty(J, -2, \"writable\"\
    , 0);\n \t\t} else {\n \t\t\tif (ref->getter)\n \t\t\t\tjs_pushobject(J, ref->getter);\n\
    \ \t\t\telse\n \t\t\t\tjs_pushundefined(J);\n-\t\t\tjs_setproperty(J, -2, \"get\"\
    );\n+\t\t\tjs_defproperty(J, -2, \"get\", 0);\n \t\t\tif (ref->setter)\n \t\t\t\
    \tjs_pushobject(J, ref->setter);\n \t\t\telse\n \t\t\t\tjs_pushundefined(J);\n\
    -\t\t\tjs_setproperty(J, -2, \"set\");\n+\t\t\tjs_defproperty(J, -2, \"set\",\
    \ 0);\n \t\t}\n \t\tjs_pushboolean(J, !(ref->atts & JS_DONTENUM));\n-\t\tjs_setproperty(J,\
    \ -2, \"enumerable\");\n+\t\tjs_defproperty(J, -2, \"enumerable\", 0);\n \t\t\
    js_pushboolean(J, !(ref->atts & JS_DONTCONF));\n-\t\tjs_setproperty(J, -2, \"\
    configurable\");\n+\t\tjs_defproperty(J, -2, \"configurable\", 0);\n \t}\n }\n\
    \ \n@@ -248,7 +248,7 @@ static void ToPropertyDescriptor(js_State *J, js_Object\
    \ *obj, const char *name,\n \t}\n \tif (js_hasproperty(J, -1, \"value\")) {\n\
    \ \t\thasvalue = 1;\n-\t\tjs_setproperty(J, -3, name);\n+\t\tjs_defproperty(J,\
    \ -3, name, 0);\n \t}\n \n \tif (!writable) atts |= JS_READONLY;"
  identifiers:
  - CVE-2022-44789
  - CWE-787
  overview: A logical issue in O_getOwnPropertyDescriptor() in Artifex MuJS 1.0.0
    through 1.3.x before 1.3.2 allows an attacker to achieve Remote Code Execution
    through memory corruption, via the loading of a crafted JavaScript file.
  references:
  - source: cve@mitre.org
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/alalng/CVE-2022-44789/blob/main/PublicReferenceURL.txt
  - source: cve@mitre.org
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/ccxvii/mujs/commit/edb50ad66f7601ca9a3544a0e9045e8a8c60561f
  - source: cve@mitre.org
    tags:
    - Release Notes
    - Third Party Advisory
    url: https://github.com/ccxvii/mujs/releases/tag/1.3.2
  - source: cve@mitre.org
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/MC6PLHTXHZ7GW7QQGTLBHLXL47UHTHXO/
  - source: cve@mitre.org
    tags:
    - Third Party Advisory
    url: https://www.debian.org/security/2022/dsa-5291
  title: A logical issue in O_getOwnPropertyDescriptor() in Artifex MuJS 1.0.0 through
    1.3.x before 1.3.2 allows an attacker to achieve Remote Code Execution through
    memory corruption, via the loading of a crafted JavaScript file.
- diff_content:
  - "--- a/src/shared/elf-util.c\n+++ b/src/shared/elf-util.c\n@@ -30,6 +30,9 @@\n\
    \ #define THREADS_MAX 64\n #define ELF_PACKAGE_METADATA_ID 0xcafe1a7e\n \n+/*\
    \ The amount of data we're willing to write to each of the output pipes. */\n\
    +#define COREDUMP_PIPE_MAX (1024*1024U)\n+\n static void *dw_dl = NULL;\n static\
    \ void *elf_dl = NULL;\n \n@@ -759,13 +762,13 @@ int parse_elf_object(int fd,\
    \ const char *executable, bool fork_disable_dump, cha\n                 return\
    \ r;\n \n         if (ret) {\n-                r = RET_NERRNO(pipe2(return_pipe,\
    \ O_CLOEXEC));\n+                r = RET_NERRNO(pipe2(return_pipe, O_CLOEXEC|O_NONBLOCK));\n\
    \                 if (r < 0)\n                         return r;\n         }\n\
    \ \n         if (ret_package_metadata) {\n-                r = RET_NERRNO(pipe2(json_pipe,\
    \ O_CLOEXEC));\n+                r = RET_NERRNO(pipe2(json_pipe, O_CLOEXEC|O_NONBLOCK));\n\
    \                 if (r < 0)\n                         return r;\n         }\n\
    @@ -809,8 +812,24 @@ int parse_elf_object(int fd, const char *executable, bool\
    \ fork_disable_dump, cha\n                         goto child_fail;\n \n     \
    \            if (buf) {\n-                        r = loop_write(return_pipe[1],\
    \ buf, strlen(buf), false);\n-                        if (r < 0)\n+          \
    \              size_t len = strlen(buf);\n+\n+                        if (len\
    \ > COREDUMP_PIPE_MAX) {\n+                                /* This is iffy. A\
    \ backtrace can be a few hundred kilobytes, but too much is\n+               \
    \                  * too much. Let's log a warning and ignore the rest. */\n+\
    \                                log_warning(\"Generated backtrace is %zu bytes\
    \ (more than the limit of %u bytes), backtrace will be truncated.\",\n+      \
    \                                      len, COREDUMP_PIPE_MAX);\n+           \
    \                     len = COREDUMP_PIPE_MAX;\n+                        }\n+\n\
    +                        /* Bump the space for the returned string.\n+       \
    \                  * Failure is ignored, because partial output is still useful.\
    \ */\n+                        (void) fcntl(return_pipe[1], F_SETPIPE_SZ, len);\n\
    +\n+                        r = loop_write(return_pipe[1], buf, len, false);\n\
    +                        if (r == -EAGAIN)\n+                                log_warning(\"\
    Write failed, backtrace will be truncated.\");\n+                        else\
    \ if (r < 0)\n                                 goto child_fail;\n \n         \
    \                return_pipe[1] = safe_close(return_pipe[1]);\n@@ -819,13 +838,19\
    \ @@ int parse_elf_object(int fd, const char *executable, bool fork_disable_dump,\
    \ cha\n                 if (package_metadata) {\n                         _cleanup_fclose_\
    \ FILE *json_out = NULL;\n \n+                        /* Bump the space for the\
    \ returned string. We don't know how much space we'll need in\n+             \
    \            * advance, so we'll just try to write as much as possible and maybe\
    \ fail later. */\n+                        (void) fcntl(json_pipe[1], F_SETPIPE_SZ,\
    \ COREDUMP_PIPE_MAX);\n+\n                         json_out = take_fdopen(&json_pipe[1],\
    \ \"w\");\n                         if (!json_out) {\n                       \
    \          r = -errno;\n                                 goto child_fail;\n  \
    \                       }\n \n-                        json_variant_dump(package_metadata,\
    \ JSON_FORMAT_FLUSH, json_out, NULL);\n+                        r = json_variant_dump(package_metadata,\
    \ JSON_FORMAT_FLUSH, json_out, NULL);\n+                        if (r < 0)\n+\
    \                                log_warning_errno(r, \"Failed to write JSON package\
    \ metadata, ignoring: %m\");\n                 }\n \n                 _exit(EXIT_SUCCESS);\n\
    @@ -860,7 +885,7 @@ int parse_elf_object(int fd, const char *executable, bool\
    \ fork_disable_dump, cha\n \n                 r = json_parse_file(json_in, NULL,\
    \ 0, &package_metadata, NULL, NULL);\n                 if (r < 0 && r != -ENODATA)\
    \ /* ENODATA: json was empty, so we got nothing, but that's ok */\n-         \
    \               return r;\n+                        log_warning_errno(r, \"Failed\
    \ to read or parse json metadata, ignoring: %m\");\n         }\n \n         if\
    \ (ret)"
  identifiers:
  - CVE-2022-45873
  - CWE-400
  overview: systemd 250 and 251 allows local users to achieve a systemd-coredump deadlock
    by triggering a crash that has a long backtrace. This occurs in parse_elf_object
    in shared/elf-util.c. The exploitation methodology is to crash a binary calling
    the same function recursively, and put it in a deeply nested directory to make
    its backtrace large enough to cause the deadlock. This must be done 16 times when
    MaxConnections=16 is set for the systemd/units/systemd-coredump.socket file.
  references:
  - source: cve@mitre.org
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/systemd/systemd/commit/076b807be472630692c5348c60d0c2b7b28ad437
  - source: cve@mitre.org
    tags:
    - Issue Tracking
    - Patch
    - Third Party Advisory
    url: https://github.com/systemd/systemd/pull/24853#issuecomment-1326561497
  - source: cve@mitre.org
    tags:
    - Issue Tracking
    - Patch
    - Third Party Advisory
    url: https://github.com/systemd/systemd/pull/25055#issuecomment-1313733553
  - source: cve@mitre.org
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/MS5N5SLYAHKENLAJWYBDKU55ICU3SVZF/
  title: systemd 250 and 251 allows local users to achieve a systemd-coredump deadlock
    by triggering a crash that has a long backtrace. This occurs in parse_elf_object
    in shared/elf-util.c. The exploitation methodology is to crash a binary calling
    the same function recursively, and put it in a deeply nested directory to make
    its backtrace large enough to cause the deadlock. This must be done 16 times when
    MaxConnections=16 is set for the systemd/units/systemd-coredump.socket file.
- diff_content:
  - "--- a/src/normal.c\n+++ b/src/normal.c\n@@ -188,13 +188,33 @@ check_text_locked(oparg_T\
    \ *oap)\n {\n     if (text_locked())\n     {\n-\tclearopbeep(oap);\n+\tif (oap\
    \ != NULL)\n+\t    clearopbeep(oap);\n \ttext_locked_msg();\n \treturn TRUE;\n\
    \     }\n     return FALSE;\n }\n \n+/*\n+ * If text is locked, \"curbuf_lock\"\
    \ or \"allbuf_lock\" is set:\n+ * Give an error message, possibly beep and return\
    \ TRUE.\n+ * \"oap\" may be NULL.\n+ */\n+    int\n+check_text_or_curbuf_locked(oparg_T\
    \ *oap)\n+{\n+    if (check_text_locked(oap))\n+\treturn TRUE;\n+    if (curbuf_locked())\n\
    +    {\n+\tif (oap != NULL)\n+\t    clearop(oap);\n+\treturn TRUE;\n+    }\n+\
    \    return FALSE;\n+}\n+\n /*\n  * Handle the count before a normal command and\
    \ set cap->count0.\n  */\n@@ -798,8 +818,7 @@ normal_cmd(\n \tgoto normal_end;\n\
    \     }\n \n-    if ((nv_cmds[idx].cmd_flags & NV_NCW)\n-\t\t\t\t&& (check_text_locked(oap)\
    \ || curbuf_locked()))\n+    if ((nv_cmds[idx].cmd_flags & NV_NCW) && check_text_or_curbuf_locked(oap))\n\
    \ \t// this command is not allowed now\n \tgoto normal_end;\n \n@@ -4026,13 +4045,9\
    \ @@ nv_gotofile(cmdarg_T *cap)\n     char_u\t*ptr;\n     linenr_T\tlnum = -1;\n\
    \ \n-    if (check_text_locked(cap->oap))\n-\treturn;\n-    if (curbuf_locked())\n\
    -    {\n-\tclearop(cap->oap);\n+    if (check_text_or_curbuf_locked(cap->oap))\n\
    \ \treturn;\n-    }\n+\n #ifdef FEAT_PROP_POPUP\n     if (ERROR_IF_TERM_POPUP_WINDOW)\n\
    \ \treturn;"
  - "--- a/src/version.c\n+++ b/src/version.c\n@@ -695,6 +695,8 @@ static char *(features[])\
    \ =\n \n static int included_patches[] =\n {   /* Add new patch number below this\
    \ line */\n+/**/\n+    947,\n /**/\n     946,\n /**/"
  - "--- a/src/window.c\n+++ b/src/window.c\n@@ -567,6 +567,8 @@ do_window(\n    \
    \ case Ctrl_F:\n wingotofile:\n \t\tCHECK_CMDWIN;\n+\t\tif (check_text_or_curbuf_locked(NULL))\n\
    +\t\t    break;\n \n \t\tptr = grab_file_name(Prenum1, &lnum);\n \t\tif (ptr !=\
    \ NULL)\n@@ -885,7 +887,7 @@ win_split(int size, int flags)\n  * When \"new_wp\"\
    \ is NULL: split the current window in two.\n  * When \"new_wp\" is not NULL:\
    \ insert this window at the far\n  * top/left/right/bottom.\n- * return FAIL for\
    \ failure, OK otherwise\n+ * Return FAIL for failure, OK otherwise.\n  */\n  \
    \   int\n win_split_ins("
  identifiers:
  - CVE-2022-4141
  - CWE-122
  overview: Heap based buffer overflow in vim/vim 9.0.0946 and below by allowing an
    attacker to CTRL-W gf in the expression used in the RHS of the substitute command.
  references:
  - source: security@huntr.dev
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/vim/vim/commit/cc762a48d42b579fb7bdec2c614636b830342dd5
  - source: security@huntr.dev
    tags:
    - Exploit
    - Issue Tracking
    - Patch
    - Third Party Advisory
    url: https://huntr.dev/bounties/20ece512-c600-45ac-8a84-d0931e05541f
  - source: security@huntr.dev
    url: https://lists.debian.org/debian-lts-announce/2023/06/msg00015.html
  - source: security@huntr.dev
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/AZ3JMSUCR6Y7626RDWQ2HNSUFIQOJ33G/
  - source: security@huntr.dev
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/V6ZNKVN4GICORTVFKVCM4MSOXCYWNHUC/
  - source: security@huntr.dev
    url: https://security.gentoo.org/glsa/202305-16
  title: Heap based buffer overflow in vim/vim 9.0.0946 and below by allowing an attacker
    to CTRL-W gf in the expression used in the RHS of the substitute command.
- diff_content:
  - "--- a/torch/csrc/jit/frontend/script_type_parser.cpp\n+++ b/torch/csrc/jit/frontend/script_type_parser.cpp\n\
    @@ -316,7 +316,7 @@ std::vector<IValue> ScriptTypeParser::evaluateDefaults(\n\
    \   // We then run constant prop on this graph and check the results are\n   //\
    \ constant. This approach avoids having to have separate handling of\n   // default\
    \ arguments from standard expressions by piecing together existing\n-  // machinery\
    \ for graph generation, constant propgation, and constant\n+  // machinery for\
    \ graph generation, constant propagation, and constant\n   // extraction.\n  \
    \ auto tuple_type = Subscript::create(\n       r,"
  identifiers:
  - CVE-2022-45907
  - CWE-94
  overview: In PyTorch before trunk/89695, torch.jit.annotations.parse_type_line can
    cause arbitrary code execution because eval is used unsafely.
  references:
  - source: cve@mitre.org
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/pytorch/pytorch/commit/767f6aa49fe20a2766b9843d01e3b7f7793df6a3
  - source: cve@mitre.org
    tags:
    - Exploit
    - Issue Tracking
    - Patch
    - Third Party Advisory
    url: https://github.com/pytorch/pytorch/issues/88868
  title: In PyTorch before trunk/89695, torch.jit.annotations.parse_type_line can
    cause arbitrary code execution because eval is used unsafely.
- diff_content:
  - "--- a/src/drachtio.cpp\n+++ b/src/drachtio.cpp\n@@ -54,6 +54,8 @@ THE SOFTWARE.\n\
    \ \n #define MAX_LINELEN 2047\n \n+#define MAX_SIP_URI_LEN (1024)\n+\n #define\
    \ BOOST_UUID (1)\n \n using namespace std ;\n@@ -336,8 +338,8 @@ namespace drachtio\
    \ {\n     bool normalizeSipUri( std::string& uri, int brackets ) {\n         su_home_t*\
    \ home = theOneAndOnlyController->getHome() ;\n         char *s ;\n-        char\
    \ buf[255];\n-        char obuf[255] ;\n+        char buf[MAX_SIP_URI_LEN];\n\
    +        char obuf[MAX_SIP_URI_LEN] ;\n         char hp[64] ;\n         char const\
    \ *display = NULL;\n         url_t url[1];\n@@ -346,7 +348,7 @@ namespace drachtio\
    \ {\n         int rc ;\n \n         // buf gets passed into sip_name_addr_d which\
    \ puts NULs in various locations so the url_t members can point to their bits\n\
    -        s = strncpy( buf, uri.c_str(), 255 ) ;\n+        s = strncpy( buf, uri.c_str(),\
    \ MAX_SIP_URI_LEN ) ;\n \n         // first we decode the string\n         rc\
    \ = sip_name_addr_d(home, &s, &display, url, &params, &comment) ;\n@@ -374,14\
    \ +376,14 @@ namespace drachtio {\n             return false ;\n         }\n \
    \        uri.assign( obuf ) ;\n-        return true ;\n+        return uri.length()\
    \ < MAX_SIP_URI_LEN ;\n     }\n \n     bool replaceHostInUri( std::string& uri,\
    \ const char* szHost, const char* szPort ) {\n         su_home_t* home = theOneAndOnlyController->getHome()\
    \ ;\n         char *s ;\n-        char buf[255];\n-        char obuf[255] ;\n\
    +        char buf[MAX_SIP_URI_LEN];\n+        char obuf[MAX_SIP_URI_LEN] ;\n \
    \        char hp[64] ;\n         char const *display = NULL;\n         url_t url[1];\n\
    @@ -404,7 +406,7 @@ namespace drachtio {\n         url->url_port = szPort ;\n\
    \ \n         // now we re-encode it\n-        int nChars = sip_name_addr_e(obuf,\
    \ 255, 0, display, 1, url, params, comment) ;\n+        int nChars = sip_name_addr_e(obuf,\
    \ MAX_SIP_URI_LEN, 0, display, 1, url, params, comment) ;\n \n         // cleanup:\
    \ free the msg_params if any were allocated        \n         if( params ) {"
  - "--- a/src/sip-dialog-controller.cpp\n+++ b/src/sip-dialog-controller.cpp\n@@\
    \ -529,7 +529,9 @@ namespace drachtio {\n              }\n \n             //prevent\
    \ looping messages\n-            normalizeSipUri( requestUri, 0 ) ;\n+       \
    \     if (!normalizeSipUri( requestUri, 0 )) {\n+                throw std::runtime_error(string(\"\
    invalid request-uri: \") + requestUri ) ;\n+            }\n             if( isLocalSipUri(\
    \ requestUri ) ) {\n                 throw std::runtime_error(\"can not send request\
    \ to myself\") ;\n             }"
  identifiers:
  - CVE-2022-45909
  - CWE-125
  overview: drachtio-server before 0.8.19 has a heap-based buffer over-read via a
    long Request-URI in an INVITE request.
  references:
  - source: cve@mitre.org
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/drachtio/drachtio-server/commit/a63d01854987d9fd846cdc9265af38ee9eb72490
  - source: cve@mitre.org
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/drachtio/drachtio-server/compare/v0.8.18...v0.8.19
  - source: cve@mitre.org
    tags:
    - Third Party Advisory
    url: https://github.com/drachtio/drachtio-server/pull/238
  title: drachtio-server before 0.8.19 has a heap-based buffer over-read via a long
    Request-URI in an INVITE request.
- diff_content:
  - "--- a/fs/io_uring.c\n+++ b/fs/io_uring.c\n@@ -7973,6 +7973,9 @@ static int io_files_update_with_index_alloc(struct\
    \ io_kiocb *req,\n \tstruct file *file;\n \tint ret, fd;\n \n+\tif (!req->ctx->file_data)\n\
    +\t\treturn -ENXIO;\n+\n \tfor (done = 0; done < req->rsrc_update.nr_args; done++)\
    \ {\n \t\tif (copy_from_user(&fd, &fds[done], sizeof(fd))) {\n \t\t\tret = -EFAULT;"
  identifiers:
  - CVE-2022-4127
  - CWE-476
  overview: A NULL pointer dereference issue was discovered in the Linux kernel in
    io_files_update_with_index_alloc. A local user could use this flaw to potentially
    crash the system causing a denial of service.
  references:
  - source: secalert@redhat.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/torvalds/linux/commit/d785a773bed966a75ca1f11d108ae1897189975b
  - source: secalert@redhat.com
    url: https://lore.kernel.org/all/d5a19c1e-9968-e22e-5917-c3139c5e7e89%40kernel.dk/
  title: A NULL pointer dereference issue was discovered in the Linux kernel in io_files_update_with_index_alloc.
    A local user could use this flaw to potentially crash the system causing a denial
    of service.
- diff_content:
  - "--- a/net/mptcp/protocol.c\n+++ b/net/mptcp/protocol.c\n@@ -2919,12 +2919,12\
    \ @@ static void mptcp_copy_inaddrs(struct sock *msk, const struct sock *ssk)\n\
    \ \n static int mptcp_disconnect(struct sock *sk, int flags)\n {\n-\tstruct mptcp_subflow_context\
    \ *subflow;\n+\tstruct mptcp_subflow_context *subflow, *tmp;\n \tstruct mptcp_sock\
    \ *msk = mptcp_sk(sk);\n \n \tinet_sk_state_store(sk, TCP_CLOSE);\n \n-\tmptcp_for_each_subflow(msk,\
    \ subflow) {\n+\tlist_for_each_entry_safe(subflow, tmp, &msk->conn_list, node)\
    \ {\n \t\tstruct sock *ssk = mptcp_subflow_tcp_sock(subflow);\n \n \t\t__mptcp_close_ssk(sk,\
    \ ssk, subflow, MPTCP_CF_FASTCLOSE);"
  identifiers:
  - CVE-2022-4128
  - CWE-476
  overview: A NULL pointer dereference issue was discovered in the Linux kernel in
    the MPTCP protocol when traversing the subflow list at disconnect time. A local
    user could use this flaw to potentially crash the system causing a denial of service.
  references:
  - source: secalert@redhat.com
    tags:
    - Patch
    - Vendor Advisory
    url: https://github.com/torvalds/linux/commit/5c835bb142d4
  - source: secalert@redhat.com
    url: https://lore.kernel.org/netdev/20220708233610.410786-2-mathew.j.martineau%40linux.intel.com/
  title: A NULL pointer dereference issue was discovered in the Linux kernel in the
    MPTCP protocol when traversing the subflow list at disconnect time. A local user
    could use this flaw to potentially crash the system causing a denial of service.
- diff_content:
  - "--- a/src/laser/lsr_dec.c\n+++ b/src/laser/lsr_dec.c\n@@ -300,11 +300,21 @@ static\
    \ void lsr_read_extension(GF_LASeRCodec *lsr, const char *name)\n \n static void\
    \ lsr_read_extend_class(GF_LASeRCodec *lsr, char **out_data, u32 *out_len, const\
    \ char *name)\n {\n-\tu32 len;\n+\tu32 len, blen;\n \tGF_LSR_READ_INT(lsr, len,\
    \ lsr->info->cfg.extensionIDBits, \"reserved\");\n \tlen = lsr_read_vluimsbf5(lsr,\
    \ \"len\");\n-//\twhile (len) gf_bs_read_int(lsr->bs, 1);\n-\tgf_bs_read_long_int(lsr->bs,\
    \ len);\n+\twhile (len && !gf_bs_is_align(lsr->bs)) {\n+\t\tgf_bs_read_int(lsr->bs,\
    \ len);\n+\t\tlen--;\n+\t}\n+\tblen = len / 8;\n+\tgf_bs_skip_bytes(lsr->bs, blen);\n\
    +\tlen -= blen*8;\n+\n+\twhile (len) {\n+\t\tgf_bs_read_int(lsr->bs, 1);\n+\t\t\
    len--;\n+\t}\n \tif (out_data) *out_data = NULL;\n \tif (out_len) *out_len = 0;\n\
    \ }\n@@ -839,10 +849,11 @@ static void lsr_read_id(GF_LASeRCodec *lsr, GF_Node\
    \ *n)\n static Fixed lsr_translate_coords(GF_LASeRCodec *lsr, u32 val, u32 nb_bits)\n\
    \ {\n \tif (!nb_bits) return 0;\n-\t\n+\tif (nb_bits>=32) return 0;\n+\n #ifdef\
    \ GPAC_FIXED_POINT\n \tif (val >> (nb_bits-1) ) {\n-\t\ts32 neg = (s32) val -\
    \ (1<<nb_bits);\n+\t\ts64 neg = (s64) val - (0x00000001UL << nb_bits);\n \t\t\
    if (neg < -FIX_ONE / 2)\n \t\t\treturn 2 * gf_divfix(INT2FIX(neg/2), lsr->res_factor);\n\
    \ \t\treturn gf_divfix(INT2FIX(neg), lsr->res_factor);\n@@ -853,18 +864,18 @@\
    \ static Fixed lsr_translate_coords(GF_LASeRCodec *lsr, u32 val, u32 nb_bits)\n\
    \ \t}\n #else\n \tif (val >> (nb_bits-1) ) {\n-\t\ts32 neg = (s32) val - (1<<nb_bits);\n\
    -\t\treturn gf_divfix(INT2FIX(neg), lsr->res_factor);\n+\t\ts64 neg = (s64) val\
    \ - (0x00000001UL << nb_bits);\n+\t\treturn ((Fixed)neg) / lsr->res_factor;\n\
    \ \t} else {\n-\t\treturn gf_divfix(INT2FIX(val), lsr->res_factor);\n+\t\treturn\
    \ ((Fixed)val) / lsr->res_factor;\n \t}\n #endif\n }\n \n static Fixed lsr_translate_scale(GF_LASeRCodec\
    \ *lsr, u32 val)\n {\n \tif (val >> (lsr->coord_bits-1) ) {\n-\t\ts32 v = val\
    \ - (1<<lsr->coord_bits);\n+\t\ts64 v = val - (0x00000001UL << lsr->coord_bits);\n\
    \ \t\treturn INT2FIX(v) / 256 ;\n \t} else {\n \t\treturn INT2FIX(val) / 256;"
  identifiers:
  - CVE-2022-4202
  - CWE-189
  overview: A vulnerability, which was classified as problematic, was found in GPAC
    2.1-DEV-rev490-g68064e101-master. Affected is the function lsr_translate_coords
    of the file laser/lsr_dec.c. The manipulation leads to integer overflow. It is
    possible to launch the attack remotely. The exploit has been disclosed to the
    public and may be used. The name of the patch is b3d821c4ae9ba62b3a194d9dcb5e99f17bd56908.
    It is recommended to apply a patch to fix this issue. VDB-214518 is the identifier
    assigned to this vulnerability.
  references:
  - source: cna@vuldb.com
    tags:
    - Exploit
    - Third Party Advisory
    url: https://drive.google.com/file/d/1HVWa6IpAbvsMS5rx091RfjUB4GfXrMLE/view
  - source: cna@vuldb.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/gpac/gpac/commit/b3d821c4ae9ba62b3a194d9dcb5e99f17bd56908
  - source: cna@vuldb.com
    tags:
    - Exploit
    - Patch
    - Third Party Advisory
    url: https://github.com/gpac/gpac/issues/2333
  - source: cna@vuldb.com
    tags:
    - Third Party Advisory
    url: https://vuldb.com/?id.214518
  - source: cna@vuldb.com
    url: https://www.debian.org/security/2023/dsa-5411
  title: A vulnerability, which was classified as problematic, was found in GPAC 2.1-DEV-rev490-g68064e101-master.
    Affected is the function lsr_translate_coords of the file laser/lsr_dec.c. The
    manipulation leads to integer overflow. It is possible to launch the attack remotely.
    The exploit has been disclosed to the public and may be used. The name of the
    patch is b3d821c4ae9ba62b3a194d9dcb5e99f17bd56908. It is recommended to apply
    a patch to fix this issue. VDB-214518 is the identifier assigned to this vulnerability.
- diff_content:
  - "--- a/core/tee/entry_std.c\n+++ b/core/tee/entry_std.c\n@@ -254,7 +254,7 @@ static\
    \ void cleanup_shm_refs(const uint64_t *saved_attr,\n {\n \tsize_t n;\n \n-\t\
    for (n = 0; n < num_params; n++) {\n+\tfor (n = 0; n < MIN((unsigned int)TEE_NUM_PARAMS,\
    \ num_params); n++) {\n \t\tswitch (saved_attr[n]) {\n \t\tcase OPTEE_MSG_ATTR_TYPE_TMEM_INPUT:\n\
    \ \t\tcase OPTEE_MSG_ATTR_TYPE_TMEM_OUTPUT:"
  identifiers:
  - CVE-2022-46152
  - CWE-129
  overview: OP-TEE Trusted OS is the secure side implementation of OP-TEE project,
    a Trusted Execution Environment. Versions prior to 3.19.0, contain an Improper
    Validation of Array Index vulnerability. The function `cleanup_shm_refs()` is
    called by both `entry_invoke_command()` and `entry_open_session()`. The commands
    `OPTEE_MSG_CMD_OPEN_SESSION` and `OPTEE_MSG_CMD_INVOKE_COMMAND` can be executed
    from the normal world via an OP-TEE SMC. This function is not validating the `num_params`
    argument, which is only limited to `OPTEE_MSG_MAX_NUM_PARAMS` (127) in the function
    `get_cmd_buffer()`. Therefore, an attacker in the normal world can craft an SMC
    call that will cause out-of-bounds reading in `cleanup_shm_refs` and potentially
    freeing of fake-objects in the function `mobj_put()`. A normal-world attacker
    with permission to execute SMC instructions may exploit this flaw. Maintainers
    believe this problem permits local privilege escalation from the normal world
    to the secure world. Version 3.19.0 contains a fix for this issue. There are no
    known workarounds.
  references:
  - source: security-advisories@github.com
    tags:
    - Third Party Advisory
    url: https://github.com/OP-TEE/optee_os/blob/c2d449482de098f1c894b94f338440e5a327813d/core/tee/entry_std.c#L257
  - source: security-advisories@github.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/OP-TEE/optee_os/commit/728616b28df659cf0bdde6e58a471f6ef25d023c
  - source: security-advisories@github.com
    tags:
    - Exploit
    - Third Party Advisory
    url: https://github.com/OP-TEE/optee_os/security/advisories/GHSA-65w8-6mrg-52g7
  - source: security-advisories@github.com
    tags:
    - Third Party Advisory
    - US Government Resource
    url: https://nvd.nist.gov/vuln-metrics/cvss/v3-calculator?vector=AV:L/AC:L/PR:H/UI:N/S:C/C:H/I:H/A:H/E:U/RL:X/RC:X/CR:M/IR:M/AR:M/MAV:L/MAC:L/MPR:H/MUI:N/MS:C/MC:H/MI:H/MA:H&version=3.1
  title: OP-TEE Trusted OS is the secure side implementation of OP-TEE project, a
    Trusted Execution Environment. Versions prior to 3.19.0, contain an Improper Validation
    of Array Index vulnerability. The function `cleanup_shm_refs()` is called by both
    `entry_invoke_command()` and `entry_open_session()`. The commands `OPTEE_MSG_CMD_OPEN_SESSION`
    and `OPTEE_MSG_CMD_INVOKE_COMMAND` can be executed from the normal world via an
    OP-TEE SMC. This function is not validating the `num_params` argument, which is
    only limited to `OPTEE_MSG_MAX_NUM_PARAMS` (127) in the function `get_cmd_buffer()`.
    Therefore, an attacker in the normal world can craft an SMC call that will cause
    out-of-bounds reading in `cleanup_shm_refs` and potentially freeing of fake-objects
    in the function `mobj_put()`. A normal-world attacker with permission to execute
    SMC instructions may exploit this flaw. Maintainers believe this problem permits
    local privilege escalation from the normal world to the secure world. Version
    3.19.0 contains a fix for this issue. There are no known workarounds.
- diff_content:
  - "--- a/hw/acpi/erst.c\n+++ b/hw/acpi/erst.c\n@@ -635,7 +635,7 @@ static unsigned\
    \ read_erst_record(ERSTDeviceState *s)\n         if (record_length < UEFI_CPER_RECORD_MIN_SIZE)\
    \ {\n             rc = STATUS_FAILED;\n         }\n-        if ((s->record_offset\
    \ + record_length) > exchange_length) {\n+        if (record_length > exchange_length\
    \ - s->record_offset) {\n             rc = STATUS_FAILED;\n         }\n      \
    \   /* If all is ok, copy the record to the exchange buffer */\n@@ -684,7 +684,7\
    \ @@ static unsigned write_erst_record(ERSTDeviceState *s)\n     if (record_length\
    \ < UEFI_CPER_RECORD_MIN_SIZE) {\n         return STATUS_FAILED;\n     }\n-  \
    \  if ((s->record_offset + record_length) > exchange_length) {\n+    if (record_length\
    \ > exchange_length - s->record_offset) {\n         return STATUS_FAILED;\n  \
    \   }\n \n@@ -716,7 +716,7 @@ static unsigned write_erst_record(ERSTDeviceState\
    \ *s)\n     if (nvram) {\n         /* Write the record into the slot */\n    \
    \     memcpy(nvram, exchange, record_length);\n-        memset(nvram + record_length,\
    \ exchange_length - record_length, 0xFF);\n+        memset(nvram + record_length,\
    \ 0xFF, exchange_length - record_length);\n         /* If a new record, increment\
    \ the record_count */\n         if (!record_found) {\n             uint32_t record_count;\n"
  identifiers:
  - CVE-2022-4172
  - CWE-120
  overview: An integer overflow and buffer overflow issues were found in the ACPI
    Error Record Serialization Table (ERST) device of QEMU in the read_erst_record()
    and write_erst_record() functions. Both issues may allow the guest to overrun
    the host buffer allocated for the ERST memory device. A malicious guest could
    use these flaws to crash the QEMU process on the host.
  references:
  - source: secalert@redhat.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://gitlab.com/qemu-project/qemu/-/commit/defb7098
  - source: secalert@redhat.com
    tags:
    - Exploit
    - Issue Tracking
    - Third Party Advisory
    url: https://gitlab.com/qemu-project/qemu/-/issues/1268
  - source: secalert@redhat.com
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/I7J5IRXJYLELW7D43A75LOWRUE5EU54O/
  - source: secalert@redhat.com
    url: https://lore.kernel.org/qemu-devel/20221024154233.1043347-1-lk%40c--e.de/
  - source: secalert@redhat.com
    tags:
    - Third Party Advisory
    url: https://security.netapp.com/advisory/ntap-20230127-0013/
  title: An integer overflow and buffer overflow issues were found in the ACPI Error
    Record Serialization Table (ERST) device of QEMU in the read_erst_record() and
    write_erst_record() functions. Both issues may allow the guest to overrun the
    host buffer allocated for the ERST memory device. A malicious guest could use
    these flaws to crash the QEMU process on the host.
- diff_content:
  - "--- a/src/buffer.c\n+++ b/src/buffer.c\n@@ -1351,6 +1351,13 @@ do_buffer_ext(\n\
    \     if ((flags & DOBUF_NOPOPUP) && bt_popup(buf) && !bt_terminal(buf))\n \t\
    return OK;\n #endif\n+    if ((action == DOBUF_GOTO || action == DOBUF_SPLIT)\n\
    +\t\t\t\t\t\t  && (buf->b_flags & BF_DUMMY))\n+    {\n+\t// disallow navigating\
    \ to the dummy buffer\n+\tsemsg(_(e_buffer_nr_does_not_exist), count);\n+\treturn\
    \ FAIL;\n+    }\n \n #ifdef FEAT_GUI\n     need_mouse_correct = TRUE;"
  - "--- a/src/version.c\n+++ b/src/version.c\n@@ -695,6 +695,8 @@ static char *(features[])\
    \ =\n \n static int included_patches[] =\n {   /* Add new patch number below this\
    \ line */\n+/**/\n+    789,\n /**/\n     788,\n /**/"
  identifiers:
  - CVE-2022-3591
  - CWE-416
  overview: Use After Free in GitHub repository vim/vim prior to 9.0.0789.
  references:
  - source: security@huntr.dev
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/vim/vim/commit/8f3c3c6cd044e3b5bf08dbfa3b3f04bb3f711bad
  - source: security@huntr.dev
    tags:
    - Permissions Required
    - Third Party Advisory
    url: https://huntr.dev/bounties/a5a998c2-4b07-47a7-91be-dbc1886b3921
  - source: security@huntr.dev
    url: https://security.gentoo.org/glsa/202305-16
  title: Use After Free in GitHub repository vim/vim prior to 9.0.0789.
- diff_content:
  - "--- a/src/register.c\n+++ b/src/register.c\n@@ -1960,6 +1960,8 @@ do_put(\n \t\
    // adjust '] mark\n \tcurbuf->b_op_end.lnum = curwin->w_cursor.lnum - 1;\n \t\
    curbuf->b_op_end.col = bd.textcol + totlen - 1;\n+\tif (curbuf->b_op_end.col <\
    \ 0)\n+\t    curbuf->b_op_end.col = 0;\n \tcurbuf->b_op_end.coladd = 0;\n \tif\
    \ (flags & PUT_CURSEND)\n \t{"
  - "--- a/src/version.c\n+++ b/src/version.c\n@@ -695,6 +695,8 @@ static char *(features[])\
    \ =\n \n static int included_patches[] =\n {   /* Add new patch number below this\
    \ line */\n+/**/\n+    765,\n /**/\n     764,\n /**/"
  identifiers:
  - CVE-2022-3520
  - CWE-122
  overview: Heap-based Buffer Overflow in GitHub repository vim/vim prior to 9.0.0765.
  references:
  - source: security@huntr.dev
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/vim/vim/commit/36343ae0fb7247e060abfd35fb8e4337b33abb4b
  - source: security@huntr.dev
    tags:
    - Exploit
    - Patch
    - Third Party Advisory
    url: https://huntr.dev/bounties/c1db3b70-f4fe-481f-8a24-0b1449c94246
  - source: security@huntr.dev
    url: https://security.gentoo.org/glsa/202305-16
  title: Heap-based Buffer Overflow in GitHub repository vim/vim prior to 9.0.0765.
- diff_content:
  - "--- a/src/version.c\n+++ b/src/version.c\n@@ -699,6 +699,8 @@ static char *(features[])\
    \ =\n \n static int included_patches[] =\n {   /* Add new patch number below this\
    \ line */\n+/**/\n+    742,\n /**/\n     741,\n /**/"
  - "--- a/src/vim9cmds.c\n+++ b/src/vim9cmds.c\n@@ -2412,34 +2412,37 @@ compile_redir(char_u\
    \ *line, exarg_T *eap, cctx_T *cctx)\n     {\n \tif (STRNCMP(arg, \"END\", 3)\
    \ == 0)\n \t{\n-\t    if (lhs->lhs_append)\n+\t    if (cctx->ctx_skip != SKIP_YES)\n\
    \ \t    {\n-\t\t// First load the current variable value.\n-\t\tif (compile_load_lhs_with_index(lhs,\
    \ lhs->lhs_whole,\n+\t\tif (lhs->lhs_append)\n+\t\t{\n+\t\t    // First load the\
    \ current variable value.\n+\t\t    if (compile_load_lhs_with_index(lhs, lhs->lhs_whole,\n\
    \ \t\t\t\t\t\t\t\t cctx) == FAIL)\n-\t\t    return NULL;\n-\t    }\n+\t\t\treturn\
    \ NULL;\n+\t\t}\n \n-\t    // Gets the redirected text and put it on the stack,\
    \ then store it\n-\t    // in the variable.\n-\t    generate_instr_type(cctx,\
    \ ISN_REDIREND, &t_string);\n+\t\t// Gets the redirected text and put it on the\
    \ stack, then store\n+\t\t// it in the variable.\n+\t\tgenerate_instr_type(cctx,\
    \ ISN_REDIREND, &t_string);\n \n-\t    if (lhs->lhs_append)\n-\t\tgenerate_CONCAT(cctx,\
    \ 2);\n+\t\tif (lhs->lhs_append)\n+\t\t    generate_CONCAT(cctx, 2);\n \n-\t \
    \   if (lhs->lhs_has_index)\n-\t    {\n-\t\t// Use the info in \"lhs\" to store\
    \ the value at the index in the\n-\t\t// list or dict.\n-\t\tif (compile_assign_unlet(lhs->lhs_whole,\
    \ lhs, TRUE,\n+\t\tif (lhs->lhs_has_index)\n+\t\t{\n+\t\t    // Use the info in\
    \ \"lhs\" to store the value at the index in\n+\t\t    // the list or dict.\n\
    +\t\t    if (compile_assign_unlet(lhs->lhs_whole, lhs, TRUE,\n \t\t\t\t\t\t  \
    \    &t_string, cctx) == FAIL)\n+\t\t\treturn NULL;\n+\t\t}\n+\t\telse if (generate_store_lhs(cctx,\
    \ lhs, -1, FALSE) == FAIL)\n \t\t    return NULL;\n-\t    }\n-\t    else if (generate_store_lhs(cctx,\
    \ lhs, -1, FALSE) == FAIL)\n-\t\treturn NULL;\n \n-\t    VIM_CLEAR(lhs->lhs_name);\n\
    -\t    VIM_CLEAR(lhs->lhs_whole);\n+\t\tVIM_CLEAR(lhs->lhs_name);\n+\t\tVIM_CLEAR(lhs->lhs_whole);\n\
    +\t    }\n \t    return arg + 3;\n \t}\n \temsg(_(e_cannot_nest_redir));\n@@ -2465,13\
    \ +2468,20 @@ compile_redir(char_u *line, exarg_T *eap, cctx_T *cctx)\n \tif (need_type(&t_string,\
    \ lhs->lhs_member_type,\n \t\t\t\t\t    -1, 0, cctx, FALSE, FALSE) == FAIL)\n\
    \ \t    return NULL;\n-\tgenerate_instr(cctx, ISN_REDIRSTART);\n-\tlhs->lhs_append\
    \ = append;\n-\tif (lhs->lhs_has_index)\n+\tif (cctx->ctx_skip == SKIP_YES)\n\
    \ \t{\n-\t    lhs->lhs_whole = vim_strnsave(arg, lhs->lhs_varlen_total);\n-\t\
    \    if (lhs->lhs_whole == NULL)\n-\t\treturn NULL;\n+\t    VIM_CLEAR(lhs->lhs_name);\n\
    +\t}\n+\telse\n+\t{\n+\t    generate_instr(cctx, ISN_REDIRSTART);\n+\t    lhs->lhs_append\
    \ = append;\n+\t    if (lhs->lhs_has_index)\n+\t    {\n+\t\tlhs->lhs_whole = vim_strnsave(arg,\
    \ lhs->lhs_varlen_total);\n+\t\tif (lhs->lhs_whole == NULL)\n+\t\t    return NULL;\n\
    +\t    }\n \t}\n \n \treturn arg + lhs->lhs_varlen_total;"
  - "--- a/src/vim9compile.c\n+++ b/src/vim9compile.c\n@@ -1283,6 +1283,19 @@ vim9_declare_error(char_u\
    \ *name)\n     semsg(_(e_cannot_declare_a_scope_variable), scope, name);\n }\n\
    \ \n+/*\n+ * Return TRUE if \"name\" is a valid register to use.\n+ * Return FALSE\
    \ and give an error message if not.\n+ */\n+    static int\n+valid_dest_reg(int\
    \ name)\n+{\n+    if ((name == '@' || valid_yank_reg(name, FALSE)) && name !=\
    \ '.')\n+\treturn TRUE;\n+    emsg_invreg(name);\n+    return FAIL;\n+}\n+\n /*\n\
    \  * For one assignment figure out the type of destination.  Return it in \"dest\"\
    .\n  * When not recognized \"dest\" is not set.\n@@ -1364,12 +1377,8 @@ get_var_dest(\n\
    \     }\n     else if (*name == '@')\n     {\n-\tif (name[1] != '@'\n-\t\t\t&&\
    \ (!valid_yank_reg(name[1], FALSE) || name[1] == '.'))\n-\t{\n-\t    emsg_invreg(name[1]);\n\
    +\tif (!valid_dest_reg(name[1]))\n \t    return FAIL;\n-\t}\n \t*dest = dest_reg;\n\
    \ \t*type = name[1] == '#' ? &t_number_or_string : &t_string;\n     }\n@@ -1445,7\
    \ +1454,11 @@ compile_lhs(\n     // \"var_end\" is the end of the variable/option/etc.\
    \ name.\n     lhs->lhs_dest_end = skip_var_one(var_start, FALSE);\n     if (*var_start\
    \ == '@')\n+    {\n+\tif (!valid_dest_reg(var_start[1]))\n+\t    return FAIL;\n\
    \ \tvar_end = var_start + 2;\n+    }\n     else\n     {\n \t// skip over the leading\
    \ \"&\", \"&l:\", \"&g:\" and \"$\""
  identifiers:
  - CVE-2022-3491
  - CWE-122
  overview: Heap-based Buffer Overflow in GitHub repository vim/vim prior to 9.0.0742.
  references:
  - source: security@huntr.dev
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/vim/vim/commit/3558afe9e9e904cabb8475392d859f2d2fc21041
  - source: security@huntr.dev
    tags:
    - Exploit
    - Patch
    - Third Party Advisory
    url: https://huntr.dev/bounties/6e6e05c2-2cf7-4aa5-a817-a62007bf92cb
  - source: security@huntr.dev
    url: https://security.gentoo.org/glsa/202305-16
  title: Heap-based Buffer Overflow in GitHub repository vim/vim prior to 9.0.0742.
- diff_content:
  - "--- a/src/spell.c\n+++ b/src/spell.c\n@@ -2110,8 +2110,8 @@ did_set_spelllang(win_T\
    \ *wp)\n \t    {\n \t\tspell_load_lang(lang);\n \t\t// SpellFileMissing autocommands\
    \ may do anything, including\n-\t\t// destroying the buffer we are using...\n\
    -\t\tif (!bufref_valid(&bufref))\n+\t\t// destroying the buffer we are using or\
    \ closing the window.\n+\t\tif (!bufref_valid(&bufref) || !win_valid_any_tab(wp))\n\
    \ \t\t{\n \t\t    ret_msg = N_(e_spellfilemising_autocommand_deleted_buffer);\n\
    \ \t\t    goto theend;"
  - "--- a/src/version.c\n+++ b/src/version.c\n@@ -695,6 +695,8 @@ static char *(features[])\
    \ =\n \n static int included_patches[] =\n {   /* Add new patch number below this\
    \ line */\n+/**/\n+    882,\n /**/\n     881,\n /**/"
  identifiers:
  - CVE-2022-4292
  - CWE-416
  overview: Use After Free in GitHub repository vim/vim prior to 9.0.0882.
  references:
  - source: security@huntr.dev
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/vim/vim/commit/c3d27ada14acd02db357f2d16347acc22cb17e93
  - source: security@huntr.dev
    tags:
    - Exploit
    - Patch
    - Third Party Advisory
    url: https://huntr.dev/bounties/da3d4c47-e57a-451e-993d-9df0ed31f57b
  - source: security@huntr.dev
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/WYC22GGZ6QA66HLNLHCTAJU265TT3O33/
  - source: security@huntr.dev
    url: https://security.gentoo.org/glsa/202305-16
  - source: security@huntr.dev
    tags:
    - Third Party Advisory
    url: https://security.netapp.com/advisory/ntap-20230113-0005/
  title: Use After Free in GitHub repository vim/vim prior to 9.0.0882.
- diff_content:
  - "--- a/src/eval.c\n+++ b/src/eval.c\n@@ -66,6 +66,12 @@ num_divide(varnumber_T\
    \ n1, varnumber_T n2, int *failed)\n \telse\n \t    result = VARNUM_MAX;\n   \
    \  }\n+    else if (n1 == VARNUM_MIN && n2 == -1)\n+    {\n+\t// specific case:\
    \ trying to do VARNUM_MIN / -1 results in a positive\n+\t// number that doesn't\
    \ fit in varnumber_T and causes an FPE\n+\tresult = VARNUM_MAX;\n+    }\n    \
    \ else\n \tresult = n1 / n2;\n \n@@ -6023,7 +6029,7 @@ var2fpos(\n }\n \n /*\n\
    - * Convert list in \"arg\" into position \"psop\" and optional file number \"\
    fnump\".\n+ * Convert list in \"arg\" into position \"posp\" and optional file\
    \ number \"fnump\".\n  * When \"fnump\" is NULL there is no file number, only\
    \ 3 items: [lnum, col, off]\n  * Note that the column is passed on as-is, the\
    \ caller may want to decrement\n  * it to use 1 for the first column."
  - "--- a/src/version.c\n+++ b/src/version.c\n@@ -695,6 +695,8 @@ static char *(features[])\
    \ =\n \n static int included_patches[] =\n {   /* Add new patch number below this\
    \ line */\n+/**/\n+    804,\n /**/\n     803,\n /**/"
  identifiers:
  - CVE-2022-4293
  - CWE-1077
  overview: Floating Point Comparison with Incorrect Operator in GitHub repository
    vim/vim prior to 9.0.0804.
  references:
  - source: security@huntr.dev
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/vim/vim/commit/cdef1cefa2a440911c727558562f83ed9b00e16b
  - source: security@huntr.dev
    tags:
    - Exploit
    - Patch
    - Third Party Advisory
    url: https://huntr.dev/bounties/385a835f-6e33-4d00-acce-ac99f3939143
  - source: security@huntr.dev
    url: https://security.gentoo.org/glsa/202305-16
  - source: security@huntr.dev
    url: https://security.netapp.com/advisory/ntap-20230203-0007/
  title: Floating Point Comparison with Incorrect Operator in GitHub repository vim/vim
    prior to 9.0.0804.
- diff_content:
  - "--- a/driver/razercommon.c\n+++ b/driver/razercommon.c\n@@ -107,6 +107,14 @@\
    \ int razer_get_usb_response(struct usb_device *usb_dev, uint report_index, struct\n\
    \         result = 1;\n     }\n \n+    if (WARN_ONCE(response_report->data_size\
    \ > ARRAY_SIZE(response_report->arguments),\n+                  \"Field data_size\
    \ %d in response is bigger than arguments\\n\",\n+                  response_report->data_size))\
    \ {\n+        /* Sanitize the value since at the moment callers don't respect\
    \ the return code */\n+        response_report->data_size = ARRAY_SIZE(response_report->arguments);\n\
    +        return -EINVAL;\n+    }\n+\n     return result;\n }\n "
  identifiers:
  - CVE-2022-23467
  - CWE-125
  overview: OpenRazer is an open source driver and user-space daemon to control Razer
    device lighting and other features on GNU/Linux. Using a modified USB device an
    attacker can leak stack addresses of the `razer_attr_read_dpi_stages`, potentially
    bypassing KASLR. To exploit this vulnerability an attacker would need to access
    to a users keyboard or mouse or would need to convince a user to use a modified
    device. The issue has been patched in v3.5.1. Users are advised to upgrade and
    should be reminded not to plug in unknown USB devices.
  references:
  - source: security-advisories@github.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/openrazer/openrazer/commit/33aa7f07d54ae066f201c6d298cb4a2181cb90e6
  - source: security-advisories@github.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/openrazer/openrazer/security/advisories/GHSA-39hg-jvc9-fg7h
  title: OpenRazer is an open source driver and user-space daemon to control Razer
    device lighting and other features on GNU/Linux. Using a modified USB device an
    attacker can leak stack addresses of the `razer_attr_read_dpi_stages`, potentially
    bypassing KASLR. To exploit this vulnerability an attacker would need to access
    to a users keyboard or mouse or would need to convince a user to use a modified
    device. The issue has been patched in v3.5.1. Users are advised to upgrade and
    should be reminded not to plug in unknown USB devices.
- diff_content:
  - "--- a/ext/nokogiri/xml_reader.c\n+++ b/ext/nokogiri/xml_reader.c\n@@ -212,6 +212,10\
    \ @@ rb_xml_reader_attribute_hash(VALUE rb_reader)\n   }\n \n   c_node = xmlTextReaderExpand(c_reader);\n\
    +  if (c_node == NULL) {\n+    return Qnil;\n+  }\n+\n   c_property = c_node->properties;\n\
    \   while (c_property != NULL) {\n     VALUE rb_name = NOKOGIRI_STR_NEW2(c_property->name);"
  - "--- a/ext/nokogiri/xml_reader.c\n+++ b/ext/nokogiri/xml_reader.c\n@@ -212,6 +212,10\
    \ @@ rb_xml_reader_attribute_hash(VALUE rb_reader)\n   }\n \n   c_node = xmlTextReaderExpand(c_reader);\n\
    +  if (c_node == NULL) {\n+    return Qnil;\n+  }\n+\n   c_property = c_node->properties;\n\
    \   while (c_property != NULL) {\n     VALUE rb_name = NOKOGIRI_STR_NEW2(c_property->name);"
  identifiers:
  - CVE-2022-23476
  - CWE-252
  overview: Nokogiri is an open source XML and HTML library for the Ruby programming
    language. Nokogiri `1.13.8` and `1.13.9` fail to check the return value from `xmlTextReaderExpand`
    in the method `Nokogiri::XML::Reader#attribute_hash`. This can lead to a null
    pointer exception when invalid markup is being parsed. For applications using
    `XML::Reader` to parse untrusted inputs, this may potentially be a vector for
    a denial of service attack. Users are advised to upgrade to Nokogiri `>= 1.13.10`.
    Users may be able to search their code for calls to either `XML::Reader#attributes`
    or `XML::Reader#attribute_hash` to determine if they are affected.
  references:
  - source: security-advisories@github.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/sparklemotion/nokogiri/commit/85410e38410f670cbbc8c5b00d07b843caee88ce
  - source: security-advisories@github.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/sparklemotion/nokogiri/commit/9fe0761c47c0d4270d1a5220cfd25de080350d50
  - source: security-advisories@github.com
    tags:
    - Third Party Advisory
    url: https://github.com/sparklemotion/nokogiri/security/advisories/GHSA-qv4q-mr5r-qprj
  title: Nokogiri is an open source XML and HTML library for the Ruby programming
    language. Nokogiri `1.13.8` and `1.13.9` fail to check the return value from `xmlTextReaderExpand`
    in the method `Nokogiri::XML::Reader#attribute_hash`. This can lead to a null
    pointer exception when invalid markup is being parsed. For applications using
    `XML::Reader` to parse untrusted inputs, this may potentially be a vector for
    a denial of service attack. Users are advised to upgrade to Nokogiri `>= 1.13.10`.
    Users may be able to search their code for calls to either `XML::Reader#attributes`
    or `XML::Reader#attribute_hash` to determine if they are affected.
- diff_content:
  - "--- a/libr/core/canal.c\n+++ b/libr/core/canal.c\n@@ -1390,6 +1390,10 @@ static\
    \ char *core_anal_graph_label(RCore *core, RAnalBlock *bb, int opts) {\n \t\t\t\
    \tfilestr = r_file_slurp_line (file, line, 0);\n \t\t\t\tif (filestr) {\n \t\t\
    \t\t\tint flen = strlen (filestr);\n+\t\t\t\t\tif (idx < 0 || ST32_ADD_OVFCHK\
    \ (idx, flen + 8)) {\n+\t\t\t\t\t\tR_LOG_WARN (\"integer overflow detected\");\n\
    +\t\t\t\t\t\tbreak;\n+\t\t\t\t\t}\n \t\t\t\t\tcmdstr = realloc (cmdstr, idx +\
    \ flen + 8);\n \t\t\t\t\tmemcpy (cmdstr + idx, filestr, flen);\n \t\t\t\t\tidx\
    \ += flen;"
  identifiers:
  - CVE-2022-4398
  - CWE-190
  overview: Integer Overflow or Wraparound in GitHub repository radareorg/radare2
    prior to 5.8.0.
  references:
  - source: security@huntr.dev
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/radareorg/radare2/commit/b53a1583d05c3a5bfe5fa60da133fe59dfbb02b8
  - source: security@huntr.dev
    tags:
    - Third Party Advisory
    url: https://huntr.dev/bounties/c6f8d3ef-5420-4eba-9a5f-aba5e2b5fea2
  title: Integer Overflow or Wraparound in GitHub repository radareorg/radare2 prior
    to 5.8.0.
- diff_content:
  - "--- a/src/db.c\n+++ b/src/db.c\n@@ -285,18 +285,36 @@ int db_update(char* name,\
    \ char* value)\n \t * if it's meant to be encrypted, then crypt_key will be set\
    \ */\n \tif (crypt_key) {\n \t\tvalue = note_encrypt(value,crypt_key);\n-\t\t\
    r = asprintf(&sql, \"UPDATE nodau set text='%s' , encrypted='true' WHERE name='%s'\"\
    , value, name);\n-\t\tfree(value);\n-\t\tif (r < 0)\n+\t\tif (asprintf(&sql, \"\
    UPDATE nodau set text=?, encrypted='true' WHERE name=?\") < 0)\n \t\t\treturn\
    \ 1;\n \t}else{\n-\t\tif (asprintf(&sql, \"UPDATE nodau set text='%s' , encrypted='false'\
    \ WHERE name='%s'\", value, name) < 0)\n+\t\tif (asprintf(&sql, \"UPDATE nodau\
    \ set text=?, encrypted='false' WHERE name=?\") < 0)\n \t\t\treturn 1;\n \t}\n\
    \ \n+\tsqlite3_stmt *compiled_statement;\n+\tr = sqlite3_prepare_v2(db_data.db,\
    \ sql, -1, &compiled_statement, NULL);\n+\tif (r != SQLITE_OK)\n+\t\treturn 1;\n\
    +\n+\tr= sqlite3_bind_text(compiled_statement, 1, value, -1, NULL);\n+\tr= sqlite3_bind_text(compiled_statement,\
    \ 2, name, -1, NULL);\n+\tif (r != SQLITE_OK)\n+\t\treturn 1;\n+\n \t/* do it\
    \ */\n-\tr = sqlite3_exec(db_data.db, sql, NULL, 0, &db_data.error_msg);\n+\t\
    r = sqlite3_step(compiled_statement);\n+\tif (r != SQLITE_DONE) {\n+\t\tfprintf(stderr,\
    \ \"Error #%d: %s\\n\", r, db_err());\n+\t\treturn 1;\n+\t}\n+\tr = sqlite3_finalize(compiled_statement);\n\
    +\tif (r != SQLITE_OK)\n+\t\tfprintf(stderr, \"Error #%d: %s\\n\", r, db_err());\n\
    +\n \tfree(sql);\n+\tif (crypt_key)\n+\t\tfree(value);\n \treturn r;\n }\n "
  - "--- a/src/edit.c\n+++ b/src/edit.c\n@@ -193,7 +193,8 @@ static int edit_ext(char*\
    \ editor, char* name, char* date, char* data)\n \t\t\t\tif (l) {\n \t\t\t\t\t\
    /* save the note */\n \t\t\t\t\tl += 6;\n-\t\t\t\t\tif (db_update(name,l))\n+\t\
    \t\t\t\tint r = db_update(name,l);\n+\t\t\t\t\tif (r != SQLITE_DONE && r != SQLITE_OK)\n\
    \ \t\t\t\t\t\treturn 1;\n \n \t\t\t\t\t/* let the user know */"
  identifiers:
  - CVE-2022-4399
  - CWE-89
  overview: A vulnerability was found in TicklishHoneyBee nodau. It has been rated
    as critical. Affected by this issue is some unknown functionality of the file
    src/db.c. The manipulation of the argument value/name leads to sql injection.
    The name of the patch is 7a7d737a3929f335b9717ddbd31db91151b69ad2. It is recommended
    to apply a patch to fix this issue. The identifier of this vulnerability is VDB-215252.
  references:
  - source: cna@vuldb.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/TicklishHoneyBee/nodau/commit/7a7d737a3929f335b9717ddbd31db91151b69ad2
  - source: cna@vuldb.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/TicklishHoneyBee/nodau/pull/26
  - source: cna@vuldb.com
    tags:
    - Third Party Advisory
    - VDB Entry
    url: https://vuldb.com/?id.215252
  title: A vulnerability was found in TicklishHoneyBee nodau. It has been rated as
    critical. Affected by this issue is some unknown functionality of the file src/db.c.
    The manipulation of the argument value/name leads to sql injection. The name of
    the patch is 7a7d737a3929f335b9717ddbd31db91151b69ad2. It is recommended to apply
    a patch to fix this issue. The identifier of this vulnerability is VDB-215252.
- diff_content:
  - "--- a/ruby/ext/google/protobuf_c/message.c\n+++ b/ruby/ext/google/protobuf_c/message.c\n\
    @@ -1263,15 +1263,20 @@ VALUE build_module_from_enumdesc(VALUE _enumdesc) {\n\
    \   int n = upb_EnumDef_ValueCount(e);\n   for (int i = 0; i < n; i++) {\n   \
    \  const upb_EnumValueDef* ev = upb_EnumDef_Value(e, i);\n-    const char* name\
    \ = upb_EnumValueDef_Name(ev);\n+    char* name = strdup(upb_EnumValueDef_Name(ev));\n\
    \     int32_t value = upb_EnumValueDef_Number(ev);\n     if (name[0] < 'A' ||\
    \ name[0] > 'Z') {\n-      rb_warn(\n+      if (name[0] >= 'a' && name[0] <= 'z')\
    \ {\n+        name[0] -= 32; // auto capitalize\n+      } else {\n+        rb_warn(\n\
    \           \"Enum value '%s' does not start with an uppercase letter \"\n   \
    \        \"as is required for Ruby constants.\",\n           name);\n+      }\n\
    \     }\n     rb_define_const(mod, name, INT2NUM(value));\n+    free(name);\n\
    \   }\n \n   rb_define_singleton_method(mod, \"lookup\", enum_lookup, 1);"
  identifiers:
  - CVE-2022-3510
  - NVD-CWE-noinfo
  overview: 'A parsing issue similar to CVE-2022-3171, but with Message-Type Extensions
    in protobuf-java core and lite versions prior to 3.21.7, 3.20.3, 3.19.6 and 3.16.3
    can lead to a denial of service attack. Inputs containing multiple instances of
    non-repeated embedded messages with repeated or unknown fields causes objects
    to be converted back-n-forth between mutable and immutable forms, resulting in
    potentially long garbage collection pauses. We recommend updating to the versions
    mentioned above.


    '
  references:
  - source: cve-coordination@google.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/protocolbuffers/protobuf/commit/db7c17803320525722f45c1d26fc08bc41d1bf48
  title: 'A parsing issue similar to CVE-2022-3171, but with Message-Type Extensions
    in protobuf-java core and lite versions prior to 3.21.7, 3.20.3, 3.19.6 and 3.16.3
    can lead to a denial of service attack. Inputs containing multiple instances of
    non-repeated embedded messages with repeated or unknown fields causes objects
    to be converted back-n-forth between mutable and immutable forms, resulting in
    potentially long garbage collection pauses. We recommend updating to the versions
    mentioned above.


    '
- diff_content:
  - "--- a/crypto/x509/pcy_map.c\n+++ b/crypto/x509/pcy_map.c\n@@ -73,10 +73,6 @@\
    \ int ossl_policy_cache_set_mapping(X509 *x, POLICY_MAPPINGS *maps)\n \n     ret\
    \ = 1;\n  bad_mapping:\n-    if (ret == -1 && CRYPTO_THREAD_write_lock(x->lock))\
    \ {\n-        x->ex_flags |= EXFLAG_INVALID_POLICY;\n-        CRYPTO_THREAD_unlock(x->lock);\n\
    -    }\n     sk_POLICY_MAPPING_pop_free(maps, POLICY_MAPPING_free);\n     return\
    \ ret;\n "
  identifiers:
  - CVE-2022-3996
  - CWE-667
  overview: 'If an X.509 certificate contains a malformed policy constraint and

    policy processing is enabled, then a write lock will be taken twice

    recursively.  On some operating systems (most widely: Windows) this

    results in a denial of service when the affected process hangs.  Policy

    processing being enabled on a publicly facing server is not considered

    to be a common setup.


    Policy processing is enabled by passing the `-policy''

    argument to the command line utilities or by calling the

    `X509_VERIFY_PARAM_set1_policies()'' function.


    Update (31 March 2023): The description of the policy processing enablement

    was corrected based on CVE-2023-0466.'
  references:
  - source: openssl-security@openssl.org
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/openssl/openssl/commit/7725e7bfe6f2ce8146b6552b44e0d226be7638e7
  - source: openssl-security@openssl.org
    tags:
    - Vendor Advisory
    url: https://www.openssl.org/news/secadv/20221213.txt
  title: 'If an X.509 certificate contains a malformed policy constraint and

    policy processing is enabled, then a write lock will be taken twice

    recursively.  On some operating systems (most widely: Windows) this

    results in a denial of service when the affected process hangs.  Policy

    processing being enabled on a publicly facing server is not considered

    to be a common setup.


    Policy processing is enabled by passing the `-policy''

    argument to the command line utilities or by calling the

    `X509_VERIFY_PARAM_set1_policies()'' function.


    Update (31 March 2023): The description of the policy processing enablement

    was corrected based on CVE-2023-0466.'
- diff_content:
  - "--- a/src/pacparser.c\n+++ b/src/pacparser.c\n@@ -442,11 +442,11 @@ pacparser_find_proxy(const\
    \ char *url, const char *host)\n   // Hostname shouldn't have single quotes in\
    \ them\n   if (strchr(host, '\\'')) {\n     print_error(\"%s %s\\n\", error_prefix,\n\
    -\t\t\"Invalid hostname: hostname can't have single quotes.\");\n+      \"Invalid\
    \ hostname: hostname can't have single quotes.\");\n     return NULL;\n   }\n\
    \ \n-  script = (char*) malloc(32 + strlen(url) + strlen(host));\n+  script =\
    \ (char*) malloc(32 + strlen(sanitized_url) + strlen(host));\n   script[0] = '\\\
    0';\n   strcat(script, \"findProxyForURL('\");\n   strcat(script, sanitized_url);"
  identifiers:
  - CVE-2019-25078
  - CWE-120
  overview: A vulnerability classified as problematic was found in pacparser up to
    1.3.x. Affected by this vulnerability is the function pacparser_find_proxy of
    the file src/pacparser.c. The manipulation of the argument url leads to buffer
    overflow. Attacking locally is a requirement. Upgrading to version 1.4.0 is able
    to address this issue. The name of the patch is 853e8f45607cb07b877ffd270c63dbcdd5201ad9.
    It is recommended to upgrade the affected component. The associated identifier
    of this vulnerability is VDB-215443.
  references:
  - source: cna@vuldb.com
    tags:
    - Patch
    url: https://github.com/manugarg/pacparser/commit/853e8f45607cb07b877ffd270c63dbcdd5201ad9
  - source: cna@vuldb.com
    tags:
    - Exploit
    - Issue Tracking
    - Third Party Advisory
    url: https://github.com/manugarg/pacparser/issues/99
  - source: cna@vuldb.com
    tags:
    - Release Notes
    url: https://github.com/manugarg/pacparser/releases/tag/v1.4.0
  - source: cna@vuldb.com
    tags:
    - Permissions Required
    - Third Party Advisory
    url: https://vuldb.com/?id.215443
  title: A vulnerability classified as problematic was found in pacparser up to 1.3.x.
    Affected by this vulnerability is the function pacparser_find_proxy of the file
    src/pacparser.c. The manipulation of the argument url leads to buffer overflow.
    Attacking locally is a requirement. Upgrading to version 1.4.0 is able to address
    this issue. The name of the patch is 853e8f45607cb07b877ffd270c63dbcdd5201ad9.
    It is recommended to upgrade the affected component. The associated identifier
    of this vulnerability is VDB-215443.
- diff_content:
  - "--- a/libavcodec/vp3.c\n+++ b/libavcodec/vp3.c\n@@ -2679,8 +2679,13 @@ static\
    \ int vp3_decode_frame(AVCodecContext *avctx,\n                              \
    \           AV_GET_BUFFER_FLAG_REF)) < 0)\n         goto error;\n \n-    if (!s->edge_emu_buffer)\n\
    +    if (!s->edge_emu_buffer) {\n         s->edge_emu_buffer = av_malloc(9 * FFABS(s->current_frame.f->linesize[0]));\n\
    +        if (!s->edge_emu_buffer) {\n+            ret = AVERROR(ENOMEM);\n+  \
    \          goto error;\n+        }\n+    }\n \n     if (s->keyframe) {\n     \
    \    if (!s->theora) {"
  identifiers:
  - CVE-2022-3109
  - CWE-476
  overview: An issue was discovered in the FFmpeg package, where vp3_decode_frame
    in libavcodec/vp3.c lacks check of the return value of av_malloc() and will cause
    a null pointer dereference, impacting availability.
  references:
  - source: secalert@redhat.com
    tags:
    - Issue Tracking
    - Patch
    - Third Party Advisory
    url: https://bugzilla.redhat.com/show_bug.cgi?id=2153551
  - source: secalert@redhat.com
    tags:
    - Patch
    url: https://github.com/FFmpeg/FFmpeg/commit/656cb0450aeb73b25d7d26980af342b37ac4c568
  - source: secalert@redhat.com
    url: https://lists.debian.org/debian-lts-announce/2023/06/msg00016.html
  - source: secalert@redhat.com
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/KOMB6WRUC55VWV25IKJTV22KARBUGWGQ/
  - source: secalert@redhat.com
    url: https://www.debian.org/security/2023/dsa-5394
  title: An issue was discovered in the FFmpeg package, where vp3_decode_frame in
    libavcodec/vp3.c lacks check of the return value of av_malloc() and will cause
    a null pointer dereference, impacting availability.
- diff_content:
  - "--- a/src/controller.cpp\n+++ b/src/controller.cpp\n@@ -273,7 +273,7 @@ namespace\
    \ drachtio {\n         if( complete ) {\n             m_os.flush() ;\n       \
    \      m_sipMessage = m_os.str() ;\n-            m_sipMessage.resize( m_sipMessage.length()\
    \ - 1) ;\n+            if (m_sipMessage.length() > 1) m_sipMessage.resize( m_sipMessage.length()\
    \ - 1) ;\n             boost::replace_all(m_sipMessage, \"\\n\", DR_CRLF);\n \
    \        }\n         else if( 0 == strcmp(szLine, \"\\n\") ) {"
  identifiers:
  - CVE-2022-47515
  - NVD-CWE-noinfo
  overview: An issue was discovered in drachtio-server before 0.8.20. It allows remote
    attackers to cause a denial of service (daemon crash) via a long message in a
    TCP request that leads to std::length_error.
  references:
  - source: cve@mitre.org
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/drachtio/drachtio-server/commit/4cf9fe2c420b86c16442215d449d40be777c1911
  - source: cve@mitre.org
    tags:
    - Exploit
    - Third Party Advisory
    url: https://github.com/drachtio/drachtio-server/issues/245
  title: An issue was discovered in drachtio-server before 0.8.20. It allows remote
    attackers to cause a denial of service (daemon crash) via a long message in a
    TCP request that leads to std::length_error.
- diff_content:
  - "--- a/libsofia-sip-ua/tport/tport.c\n+++ b/libsofia-sip-ua/tport/tport.c\n@@\
    \ -3310,8 +3310,6 @@ tport_t *tport_tsend(tport_t *self,\n   tp_name_t tpn[1];\n\
    \   struct sigcomp_compartment *cc;\n \n-  assert(self);\n-\n   if (!self || !msg\
    \ || !_tpn) {\n     msg_set_errno(msg, EINVAL);\n     return NULL;"
  identifiers:
  - CVE-2022-47516
  - CWE-617
  overview: An issue was discovered in the libsofia-sip fork in drachtio-server before
    0.8.20. It allows remote attackers to cause a denial of service (daemon crash)
    via a crafted UDP message that leads to a failure of the libsofia-sip-ua/tport/tport.c
    self assertion.
  references:
  - source: cve@mitre.org
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/davehorton/sofia-sip/commit/13b2a135287caa2d67ac6cd5155626821e25b377
  - source: cve@mitre.org
    tags:
    - Exploit
    - Third Party Advisory
    url: https://github.com/drachtio/drachtio-server/issues/244
  - source: cve@mitre.org
    url: https://lists.debian.org/debian-lts-announce/2023/02/msg00028.html
  - source: cve@mitre.org
    url: https://www.debian.org/security/2023/dsa-5410
  title: An issue was discovered in the libsofia-sip fork in drachtio-server before
    0.8.20. It allows remote attackers to cause a denial of service (daemon crash)
    via a crafted UDP message that leads to a failure of the libsofia-sip-ua/tport/tport.c
    self assertion.
- diff_content:
  - "--- a/libsofia-sip-ua/url/url.c\n+++ b/libsofia-sip-ua/url/url.c\n@@ -364,6 +364,7\
    \ @@ char *url_canonize2(char *d, char const * const s, size_t n,\n       continue;\n\
    \     }\n \n+    if (i >= strlen(s) - 1) return NULL;\n     h1 = s[i + 1], h2\
    \ = s[i + 2];\n \n     if (!IS_HEX(h1) || !IS_HEX(h2)) {"
  - "--- a/libsofia-sip-ua/url/url.c\n+++ b/libsofia-sip-ua/url/url.c\n@@ -364,8 +364,12\
    \ @@ char *url_canonize2(char *d, char const * const s, size_t n,\n       continue;\n\
    \     }\n \n-    if (i >= strlen(s) - 1) return NULL;\n-    h1 = s[i + 1], h2\
    \ = s[i + 2];\n+    h1 = s[i + 1];\n+    if (!h1) {\n+        *d = '\\0';\n+ \
    \       return NULL;\n+    }\n+    h2 = s[i + 2];\n \n     if (!IS_HEX(h1) ||\
    \ !IS_HEX(h2)) {\n       *d = '\\0';"
  identifiers:
  - CVE-2022-47517
  - CWE-193
  overview: An issue was discovered in the libsofia-sip fork in drachtio-server before
    0.8.19. It allows remote attackers to cause a denial of service (daemon crash)
    via a crafted UDP message that causes a url_canonize2 heap-based buffer over-read
    because of an off-by-one error.
  references:
  - source: cve@mitre.org
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/davehorton/sofia-sip/commit/22c1bd191f0acbf11f0c0fbea1845d9bf9dcd47e
  - source: cve@mitre.org
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/davehorton/sofia-sip/commit/bfc79d85c8f3a4798a3305fb98f5a11c11d0d29f
  - source: cve@mitre.org
    tags:
    - Exploit
    - Third Party Advisory
    url: https://github.com/drachtio/drachtio-server/issues/243
  title: An issue was discovered in the libsofia-sip fork in drachtio-server before
    0.8.19. It allows remote attackers to cause a denial of service (daemon crash)
    via a crafted UDP message that causes a url_canonize2 heap-based buffer over-read
    because of an off-by-one error.
- diff_content:
  - "--- a/drivers/net/wireless/microchip/wilc1000/cfg80211.c\n+++ b/drivers/net/wireless/microchip/wilc1000/cfg80211.c\n\
    @@ -981,19 +981,29 @@ static inline void wilc_wfi_cfg_parse_ch_attr(u8 *buf, u32\
    \ len, u8 sta_ch)\n \t}\n \n \tif (ch_list_idx) {\n-\t\tu16 attr_size;\n-\t\t\
    struct wilc_ch_list_elem *e;\n-\t\tint i;\n+\t\tu16 elem_size;\n \n \t\tch_list\
    \ = (struct wilc_attr_ch_list *)&buf[ch_list_idx];\n-\t\tattr_size = le16_to_cpu(ch_list->attr_len);\n\
    -\t\tfor (i = 0; i < attr_size;) {\n+\t\t/* the number of bytes following the\
    \ final 'elem' member */\n+\t\telem_size = le16_to_cpu(ch_list->attr_len) -\n\
    +\t\t\t(sizeof(*ch_list) - sizeof(struct wilc_attr_entry));\n+\t\tfor (unsigned\
    \ int i = 0; i < elem_size;) {\n+\t\t\tstruct wilc_ch_list_elem *e;\n+\n \t\t\t\
    e = (struct wilc_ch_list_elem *)(ch_list->elem + i);\n+\n+\t\t\ti += sizeof(*e);\n\
    +\t\t\tif (i > elem_size)\n+\t\t\t\tbreak;\n+\n+\t\t\ti += e->no_of_channels;\n\
    +\t\t\tif (i > elem_size)\n+\t\t\t\tbreak;\n+\n \t\t\tif (e->op_class == WILC_WLAN_OPERATING_CLASS_2_4GHZ)\
    \ {\n \t\t\t\tmemset(e->ch_list, sta_ch, e->no_of_channels);\n \t\t\t\tbreak;\n\
    \ \t\t\t}\n-\t\t\ti += e->no_of_channels;\n \t\t}\n \t}\n "
  identifiers:
  - CVE-2022-47518
  - CWE-787
  overview: An issue was discovered in the Linux kernel before 6.0.11. Missing validation
    of the number of channels in drivers/net/wireless/microchip/wilc1000/cfg80211.c
    in the WILC1000 wireless driver can trigger a heap-based buffer overflow when
    copying the list of operating channels from Wi-Fi management frames.
  references:
  - source: cve@mitre.org
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/torvalds/linux/commit/0cdfa9e6f0915e3d243e2393bfa8a22e12d553b0
  - source: cve@mitre.org
    tags:
    - Mailing List
    - Third Party Advisory
    url: https://lists.debian.org/debian-lts-announce/2022/12/msg00031.html
  - source: cve@mitre.org
    url: https://lore.kernel.org/r/20221123153543.8568-5-philipturnbull%40github.com
  - source: cve@mitre.org
    tags:
    - Third Party Advisory
    url: https://security.netapp.com/advisory/ntap-20230113-0007/
  title: An issue was discovered in the Linux kernel before 6.0.11. Missing validation
    of the number of channels in drivers/net/wireless/microchip/wilc1000/cfg80211.c
    in the WILC1000 wireless driver can trigger a heap-based buffer overflow when
    copying the list of operating channels from Wi-Fi management frames.
- diff_content:
  - "--- a/drivers/net/wireless/microchip/wilc1000/cfg80211.c\n+++ b/drivers/net/wireless/microchip/wilc1000/cfg80211.c\n\
    @@ -959,14 +959,24 @@ static inline void wilc_wfi_cfg_parse_ch_attr(u8 *buf, u32\
    \ len, u8 sta_ch)\n \t\treturn;\n \n \twhile (index + sizeof(*e) <= len) {\n+\t\
    \tu16 attr_size;\n+\n \t\te = (struct wilc_attr_entry *)&buf[index];\n+\t\tattr_size\
    \ = le16_to_cpu(e->attr_len);\n+\n+\t\tif (index + sizeof(*e) + attr_size > len)\n\
    +\t\t\treturn;\n+\n \t\tif (e->attr_type == IEEE80211_P2P_ATTR_CHANNEL_LIST)\n\
    \ \t\t\tch_list_idx = index;\n-\t\telse if (e->attr_type == IEEE80211_P2P_ATTR_OPER_CHANNEL)\n\
    +\t\telse if (e->attr_type == IEEE80211_P2P_ATTR_OPER_CHANNEL &&\n+\t\t\t attr_size\
    \ == (sizeof(struct wilc_attr_oper_ch) - sizeof(*e)))\n \t\t\top_ch_idx = index;\n\
    +\n \t\tif (ch_list_idx && op_ch_idx)\n \t\t\tbreak;\n-\t\tindex += le16_to_cpu(e->attr_len)\
    \ + sizeof(*e);\n+\n+\t\tindex += sizeof(*e) + attr_size;\n \t}\n \n \tif (ch_list_idx)\
    \ {"
  identifiers:
  - CVE-2022-47519
  - CWE-787
  overview: An issue was discovered in the Linux kernel before 6.0.11. Missing validation
    of IEEE80211_P2P_ATTR_OPER_CHANNEL in drivers/net/wireless/microchip/wilc1000/cfg80211.c
    in the WILC1000 wireless driver can trigger an out-of-bounds write when parsing
    the channel list attribute from Wi-Fi management frames.
  references:
  - source: cve@mitre.org
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/torvalds/linux/commit/051ae669e4505abbe05165bebf6be7922de11f41
  - source: cve@mitre.org
    tags:
    - Mailing List
    - Third Party Advisory
    url: https://lists.debian.org/debian-lts-announce/2022/12/msg00031.html
  - source: cve@mitre.org
    url: https://lore.kernel.org/r/20221123153543.8568-3-philipturnbull%40github.com
  - source: cve@mitre.org
    tags:
    - Third Party Advisory
    url: https://security.netapp.com/advisory/ntap-20230113-0007/
  title: An issue was discovered in the Linux kernel before 6.0.11. Missing validation
    of IEEE80211_P2P_ATTR_OPER_CHANNEL in drivers/net/wireless/microchip/wilc1000/cfg80211.c
    in the WILC1000 wireless driver can trigger an out-of-bounds write when parsing
    the channel list attribute from Wi-Fi management frames.
- diff_content:
  - "--- a/drivers/net/wireless/microchip/wilc1000/hif.c\n+++ b/drivers/net/wireless/microchip/wilc1000/hif.c\n\
    @@ -482,14 +482,25 @@ void *wilc_parse_join_bss_param(struct cfg80211_bss *bss,\n\
    \ \n \trsn_ie = cfg80211_find_ie(WLAN_EID_RSN, ies->data, ies->len);\n \tif (rsn_ie)\
    \ {\n+\t\tint rsn_ie_len = sizeof(struct element) + rsn_ie[1];\n \t\tint offset\
    \ = 8;\n \n-\t\tparam->mode_802_11i = 2;\n-\t\tparam->rsn_found = true;\n \t\t\
    /* extract RSN capabilities */\n-\t\toffset += (rsn_ie[offset] * 4) + 2;\n-\t\t\
    offset += (rsn_ie[offset] * 4) + 2;\n-\t\tmemcpy(param->rsn_cap, &rsn_ie[offset],\
    \ 2);\n+\t\tif (offset < rsn_ie_len) {\n+\t\t\t/* skip over pairwise suites */\n\
    +\t\t\toffset += (rsn_ie[offset] * 4) + 2;\n+\n+\t\t\tif (offset < rsn_ie_len)\
    \ {\n+\t\t\t\t/* skip over authentication suites */\n+\t\t\t\toffset += (rsn_ie[offset]\
    \ * 4) + 2;\n+\n+\t\t\t\tif (offset + 1 < rsn_ie_len) {\n+\t\t\t\t\tparam->mode_802_11i\
    \ = 2;\n+\t\t\t\t\tparam->rsn_found = true;\n+\t\t\t\t\tmemcpy(param->rsn_cap,\
    \ &rsn_ie[offset], 2);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \t}\n \n \tif (param->rsn_found)\
    \ {"
  identifiers:
  - CVE-2022-47520
  - CWE-125
  overview: An issue was discovered in the Linux kernel before 6.0.11. Missing offset
    validation in drivers/net/wireless/microchip/wilc1000/hif.c in the WILC1000 wireless
    driver can trigger an out-of-bounds read when parsing a Robust Security Network
    (RSN) information element from a Netlink packet.
  references:
  - source: cve@mitre.org
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/torvalds/linux/commit/cd21d99e595ec1d8721e1058dcdd4f1f7de1d793
  - source: cve@mitre.org
    tags:
    - Mailing List
    - Third Party Advisory
    url: https://lists.debian.org/debian-lts-announce/2022/12/msg00031.html
  - source: cve@mitre.org
    url: https://lore.kernel.org/r/20221123153543.8568-2-philipturnbull%40github.com
  - source: cve@mitre.org
    tags:
    - Third Party Advisory
    url: https://security.netapp.com/advisory/ntap-20230113-0007/
  title: An issue was discovered in the Linux kernel before 6.0.11. Missing offset
    validation in drivers/net/wireless/microchip/wilc1000/hif.c in the WILC1000 wireless
    driver can trigger an out-of-bounds read when parsing a Robust Security Network
    (RSN) information element from a Netlink packet.
- diff_content:
  - "--- a/drivers/net/wireless/microchip/wilc1000/cfg80211.c\n+++ b/drivers/net/wireless/microchip/wilc1000/cfg80211.c\n\
    @@ -967,7 +967,8 @@ static inline void wilc_wfi_cfg_parse_ch_attr(u8 *buf, u32\
    \ len, u8 sta_ch)\n \t\tif (index + sizeof(*e) + attr_size > len)\n \t\t\treturn;\n\
    \ \n-\t\tif (e->attr_type == IEEE80211_P2P_ATTR_CHANNEL_LIST)\n+\t\tif (e->attr_type\
    \ == IEEE80211_P2P_ATTR_CHANNEL_LIST &&\n+\t\t    attr_size >= (sizeof(struct\
    \ wilc_attr_ch_list) - sizeof(*e)))\n \t\t\tch_list_idx = index;\n \t\telse if\
    \ (e->attr_type == IEEE80211_P2P_ATTR_OPER_CHANNEL &&\n \t\t\t attr_size == (sizeof(struct\
    \ wilc_attr_oper_ch) - sizeof(*e)))"
  identifiers:
  - CVE-2022-47521
  - CWE-787
  overview: An issue was discovered in the Linux kernel before 6.0.11. Missing validation
    of IEEE80211_P2P_ATTR_CHANNEL_LIST in drivers/net/wireless/microchip/wilc1000/cfg80211.c
    in the WILC1000 wireless driver can trigger a heap-based buffer overflow when
    parsing the operating channel attribute from Wi-Fi management frames.
  references:
  - source: cve@mitre.org
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/torvalds/linux/commit/f9b62f9843c7b0afdaecabbcebf1dbba18599408
  - source: cve@mitre.org
    tags:
    - Mailing List
    - Third Party Advisory
    url: https://lists.debian.org/debian-lts-announce/2022/12/msg00031.html
  - source: cve@mitre.org
    url: https://lore.kernel.org/r/20221123153543.8568-4-philipturnbull%40github.com
  - source: cve@mitre.org
    tags:
    - Third Party Advisory
    url: https://security.netapp.com/advisory/ntap-20230113-0007/
  title: An issue was discovered in the Linux kernel before 6.0.11. Missing validation
    of IEEE80211_P2P_ATTR_CHANNEL_LIST in drivers/net/wireless/microchip/wilc1000/cfg80211.c
    in the WILC1000 wireless driver can trigger a heap-based buffer overflow when
    parsing the operating channel attribute from Wi-Fi management frames.
- diff_content:
  - "--- a/pppdump/pppdump.c\n+++ b/pppdump/pppdump.c\n@@ -297,6 +297,10 @@ dumpppp(f)\n\
    \ \t\t\t    printf(\"%s aborted packet:\\n     \", dir);\n \t\t\t    q = \"  \
    \  \";\n \t\t\t}\n+\t\t\tif (pkt->cnt >= sizeof(pkt->buf)) {\n+\t\t\t    printf(\"\
    %s over-long packet truncated:\\n     \", dir);\n+\t\t\t    q = \"    \";\n+\t\
    \t\t}\n \t\t\tnb = pkt->cnt;\n \t\t\tp = pkt->buf;\n \t\t\tpkt->cnt = 0;\n@@ -400,7\
    \ +404,8 @@ dumpppp(f)\n \t\t\tc ^= 0x20;\n \t\t\tpkt->esc = 0;\n \t\t    }\n\
    -\t\t    pkt->buf[pkt->cnt++] = c;\n+\t\t    if (pkt->cnt < sizeof(pkt->buf))\n\
    +\t\t\tpkt->buf[pkt->cnt++] = c;\n \t\t    break;\n \t\t}\n \t    }"
  identifiers:
  - CVE-2022-4603
  - CWE-119
  overview: 'A vulnerability classified as problematic has been found in ppp. Affected
    is the function dumpppp of the file pppdump/pppdump.c of the component pppdump.
    The manipulation of the argument spkt.buf/rpkt.buf leads to improper validation
    of array index. The real existence of this vulnerability is still doubted at the
    moment. The name of the patch is a75fb7b198eed50d769c80c36629f38346882cbf. It
    is recommended to apply a patch to fix this issue. VDB-216198 is the identifier
    assigned to this vulnerability. NOTE: pppdump is not used in normal process of
    setting up a PPP connection, is not installed setuid-root, and is not invoked
    automatically in any scenario.'
  references:
  - source: cna@vuldb.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/ppp-project/ppp/commit/a75fb7b198eed50d769c80c36629f38346882cbf
  - source: cna@vuldb.com
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/J43NP7ABHOCIWOFHWCH6ZCZOYKZH6723/
  - source: cna@vuldb.com
    tags:
    - Third Party Advisory
    url: https://vuldb.com/?id.216198
  title: 'A vulnerability classified as problematic has been found in ppp. Affected
    is the function dumpppp of the file pppdump/pppdump.c of the component pppdump.
    The manipulation of the argument spkt.buf/rpkt.buf leads to improper validation
    of array index. The real existence of this vulnerability is still doubted at the
    moment. The name of the patch is a75fb7b198eed50d769c80c36629f38346882cbf. It
    is recommended to apply a patch to fix this issue. VDB-216198 is the identifier
    assigned to this vulnerability. NOTE: pppdump is not used in normal process of
    setting up a PPP connection, is not installed setuid-root, and is not invoked
    automatically in any scenario.'
- diff_content:
  - "--- a/parse.c\n+++ b/parse.c\n@@ -97,8 +97,11 @@ uint32_t sftp_parse_path(struct\
    \ sftpjob *job, char **strp) {\n uint32_t sftp_parse_handle(struct sftpjob *job,\
    \ struct handleid *id) {\n   uint32_t len, rc;\n \n-  if((rc = sftp_parse_uint32(job,\
    \ &len)) != SSH_FX_OK || len != 8 ||\n-     (rc = sftp_parse_uint32(job, &id->id))\
    \ != SSH_FX_OK ||\n+  if((rc = sftp_parse_uint32(job, &len)) != SSH_FX_OK)\n+\
    \    return rc;\n+  if(len != 8)\n+    return SSH_FX_BAD_MESSAGE;\n+  if((rc =\
    \ sftp_parse_uint32(job, &id->id)) != SSH_FX_OK ||\n      (rc = sftp_parse_uint32(job,\
    \ &id->tag) != SSH_FX_OK))\n     return rc;\n   return SSH_FX_OK;"
  identifiers:
  - CVE-2020-36617
  - CWE-908
  overview: 'A vulnerability was found in ewxrjk sftpserver. It has been declared
    as problematic. Affected by this vulnerability is the function sftp_parse_path
    of the file parse.c. The manipulation leads to uninitialized pointer. The real
    existence of this vulnerability is still doubted at the moment. The name of the
    patch is bf4032f34832ee11d79aa60a226cc018e7ec5eed. It is recommended to apply
    a patch to fix this issue. The identifier VDB-216205 was assigned to this vulnerability.
    NOTE: In some deployment models this would be a vulnerability. README specifically
    warns about avoiding such deployment models.'
  references:
  - source: cna@vuldb.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/ewxrjk/sftpserver/commit/bf4032f34832ee11d79aa60a226cc018e7ec5eed
  - source: cna@vuldb.com
    tags:
    - Third Party Advisory
    url: https://vuldb.com/?id.216205
  title: 'A vulnerability was found in ewxrjk sftpserver. It has been declared as
    problematic. Affected by this vulnerability is the function sftp_parse_path of
    the file parse.c. The manipulation leads to uninitialized pointer. The real existence
    of this vulnerability is still doubted at the moment. The name of the patch is
    bf4032f34832ee11d79aa60a226cc018e7ec5eed. It is recommended to apply a patch to
    fix this issue. The identifier VDB-216205 was assigned to this vulnerability.
    NOTE: In some deployment models this would be a vulnerability. README specifically
    warns about avoiding such deployment models.'
- diff_content:
  - "--- a/demod_flex.c\n+++ b/demod_flex.c\n@@ -558,6 +558,17 @@ unsigned int add_ch(unsigned\
    \ char ch, unsigned char* buf, unsigned int idx) {\n         buf[idx + 1] = 'r';\n\
    \         return 2;\n     }\n+    // unixinput.c::_verbprintf uses this output\
    \ as a format string\n+    // which introduces an uncontrolled format string vulnerability\n\
    +    // and also, generally, risks stack corruption\n+    if (ch == '%') {\n+\
    \        if (idx < (MAX_ALN - 2)) {\n+            buf[idx] = '%';\n+         \
    \   buf[idx + 1] = '%';\n+            return 2;\n+        }\n+        return 0;\n\
    +    }\n     // only store ASCII printable\n     if (ch >= 32 && ch <= 126) {\n\
    \         buf[idx] = ch;"
  identifiers:
  - CVE-2020-36619
  - CWE-134
  overview: A vulnerability was found in multimon-ng. It has been rated as critical.
    This issue affects the function add_ch of the file demod_flex.c. The manipulation
    of the argument ch leads to format string. Upgrading to version 1.2.0 is able
    to address this issue. The name of the patch is e5a51c508ef952e81a6da25b43034dd1ed023c07.
    It is recommended to upgrade the affected component. The identifier VDB-216269
    was assigned to this vulnerability.
  references:
  - source: cna@vuldb.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/EliasOenal/multimon-ng/commit/e5a51c508ef952e81a6da25b43034dd1ed023c07
  - source: cna@vuldb.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/EliasOenal/multimon-ng/pull/160
  - source: cna@vuldb.com
    tags:
    - Release Notes
    - Third Party Advisory
    url: https://github.com/EliasOenal/multimon-ng/releases/tag/1.2.0
  - source: cna@vuldb.com
    tags:
    - Permissions Required
    - Third Party Advisory
    - VDB Entry
    url: https://vuldb.com/?id.216269
  title: A vulnerability was found in multimon-ng. It has been rated as critical.
    This issue affects the function add_ch of the file demod_flex.c. The manipulation
    of the argument ch leads to format string. Upgrading to version 1.2.0 is able
    to address this issue. The name of the patch is e5a51c508ef952e81a6da25b43034dd1ed023c07.
    It is recommended to upgrade the affected component. The identifier VDB-216269
    was assigned to this vulnerability.
- diff_content:
  - "--- a/pjnath/src/pjnath/stun_msg.c\n+++ b/pjnath/src/pjnath/stun_msg.c\n@@ -746,7\
    \ +746,7 @@ PJ_DEF(int) pj_stun_set_padding_char(int chr)\n \n #define INIT_ATTR(a,t,l)\
    \    (a)->hdr.type=(pj_uint16_t)(t), \\\n                             (a)->hdr.length=(pj_uint16_t)(l)\n\
    -#define ATTR_HDR_LEN        4\n+#define ATTR_HDR_LEN        sizeof(pj_stun_attr_hdr)\n\
    \ \n static pj_uint16_t GETVAL16H(const pj_uint8_t *buf, unsigned pos)\n {\n@@\
    \ -2327,6 +2327,14 @@ PJ_DEF(pj_status_t) pj_stun_msg_decode(pj_pool_t *pool,\n\
    \         status = pj_stun_msg_check(pdu, pdu_len, options);\n         if (status\
    \ != PJ_SUCCESS)\n             return status;\n+    } else {\n+        /* For\
    \ safety, verify packet length at least */\n+        pj_uint32_t msg_len = GETVAL16H(pdu,\
    \ 2) + 20;\n+        if (msg_len > pdu_len ||\n+            ((options & PJ_STUN_IS_DATAGRAM)\
    \ && msg_len != pdu_len))\n+        {\n+            return PJNATH_EINSTUNMSGLEN;\n\
    +        }\n     }\n \n     /* Create the message, copy the header, and convert\
    \ to host byte order */\n@@ -2345,7 +2353,7 @@ PJ_DEF(pj_status_t) pj_stun_msg_decode(pj_pool_t\
    \ *pool,\n         p_response = NULL;\n \n     /* Parse attributes */\n-    while\
    \ (pdu_len >= 4) {\n+    while (pdu_len >= ATTR_HDR_LEN) {\n         unsigned\
    \ attr_type, attr_val_len;\n         const struct attr_desc *adesc;\n \n@@ -2357,7\
    \ +2365,7 @@ PJ_DEF(pj_status_t) pj_stun_msg_decode(pj_pool_t *pool,\n       \
    \  attr_val_len = (attr_val_len + 3) & (~3);\n \n         /* Check length */\n\
    -        if (pdu_len < attr_val_len) {\n+        if (pdu_len < attr_val_len +\
    \ ATTR_HDR_LEN) {\n             pj_str_t err_msg;\n             char err_msg_buf[80];\n\
    \ "
  identifiers:
  - CVE-2022-23537
  - CWE-122
  overview: PJSIP is a free and open source multimedia communication library written
    in C language implementing standard based protocols such as SIP, SDP, RTP, STUN,
    TURN, and ICE. Buffer overread is possible when parsing a specially crafted STUN
    message with unknown attribute. The vulnerability affects applications that uses
    STUN including PJNATH and PJSUA-LIB. The patch is available as a commit in the
    master branch (2.13.1).
  references:
  - source: security-advisories@github.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/pjsip/pjproject/commit/d8440f4d711a654b511f50f79c0445b26f9dd1e1
  - source: security-advisories@github.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/pjsip/pjproject/security/advisories/GHSA-9pfh-r8x4-w26w
  - source: security-advisories@github.com
    tags:
    - Mailing List
    - Third Party Advisory
    url: https://lists.debian.org/debian-lts-announce/2023/08/msg00038.html
  title: PJSIP is a free and open source multimedia communication library written
    in C language implementing standard based protocols such as SIP, SDP, RTP, STUN,
    TURN, and ICE. Buffer overread is possible when parsing a specially crafted STUN
    message with unknown attribute. The vulnerability affects applications that uses
    STUN including PJNATH and PJSUA-LIB. The patch is available as a commit in the
    master branch (2.13.1).
- diff_content:
  - "--- a/probe.c\n+++ b/probe.c\n@@ -116,7 +116,7 @@ void hexdump(msg_info msg_info,\
    \ const char *mem, unsigned int len)\n             }\n             str[c++] =\
    \ '\\n';\n             str[c++] = 0;\n-            print_message(msg_info, str);\n\
    +            print_message(msg_info, \"%s\", str);\n             c = 0;\n    \
    \     }\n     }"
  identifiers:
  - CVE-2022-4639
  - CWE-134
  overview: A vulnerability, which was classified as critical, has been found in sslh.
    This issue affects the function hexdump of the file probe.c of the component Packet
    Dumping Handler. The manipulation of the argument msg_info leads to format string.
    The attack may be initiated remotely. The name of the patch is b19f8a6046b080e4c2e28354a58556bb26040c6f.
    It is recommended to apply a patch to fix this issue. The identifier VDB-216497
    was assigned to this vulnerability.
  references:
  - source: cna@vuldb.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/yrutschle/sslh/commit/b19f8a6046b080e4c2e28354a58556bb26040c6f
  - source: cna@vuldb.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/yrutschle/sslh/pull/353
  - source: cna@vuldb.com
    tags:
    - Third Party Advisory
    url: https://vuldb.com/?id.216497
  title: A vulnerability, which was classified as critical, has been found in sslh.
    This issue affects the function hexdump of the file probe.c of the component Packet
    Dumping Handler. The manipulation of the argument msg_info leads to format string.
    The attack may be initiated remotely. The name of the patch is b19f8a6046b080e4c2e28354a58556bb26040c6f.
    It is recommended to apply a patch to fix this issue. The identifier VDB-216497
    was assigned to this vulnerability.
- diff_content:
  - "--- a/pjnath/src/pjnath/stun_msg.c\n+++ b/pjnath/src/pjnath/stun_msg.c\n@@ -1757,14\
    \ +1757,15 @@ static pj_status_t decode_errcode_attr(pj_pool_t *pool,\n     attr\
    \ = PJ_POOL_ZALLOC_T(pool, pj_stun_errcode_attr);\n     GETATTRHDR(buf, &attr->hdr);\n\
    \ \n+    /* Check that the attribute length is valid */\n+    if (attr->hdr.length\
    \ < 4)\n+        return PJNATH_ESTUNINATTRLEN;\n+\n     attr->err_code = buf[6]\
    \ * 100 + buf[7];\n \n     /* Get pointer to the string in the message */\n  \
    \   value.ptr = ((char*)buf + ATTR_HDR_LEN + 4);\n     value.slen = attr->hdr.length\
    \ - 4;\n-    /* Make sure the length is never negative */\n-    if (value.slen\
    \ < 0)\n-        value.slen = 0;\n \n     /* Copy the string to the attribute\
    \ */\n     pj_strdup(pool, &attr->reason, &value);"
  identifiers:
  - CVE-2022-23547
  - CWE-122
  overview: PJSIP is a free and open source multimedia communication library written
    in C language implementing standard based protocols such as SIP, SDP, RTP, STUN,
    TURN, and ICE. This issue is similar to GHSA-9pfh-r8x4-w26w. Possible buffer overread
    when parsing a certain STUN message. The vulnerability affects applications that
    uses STUN including PJNATH and PJSUA-LIB. The patch is available as commit in
    the master branch.
  references:
  - source: security-advisories@github.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/pjsip/pjproject/commit/bc4812d31a67d5e2f973fbfaf950d6118226cf36
  - source: security-advisories@github.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/pjsip/pjproject/security/advisories/GHSA-9pfh-r8x4-w26w
  - source: security-advisories@github.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/pjsip/pjproject/security/advisories/GHSA-cxwq-5g9x-x7fr
  - source: security-advisories@github.com
    url: https://lists.debian.org/debian-lts-announce/2023/08/msg00038.html
  title: PJSIP is a free and open source multimedia communication library written
    in C language implementing standard based protocols such as SIP, SDP, RTP, STUN,
    TURN, and ICE. This issue is similar to GHSA-9pfh-r8x4-w26w. Possible buffer overread
    when parsing a certain STUN message. The vulnerability affects applications that
    uses STUN including PJNATH and PJSUA-LIB. The patch is available as commit in
    the master branch.
- diff_content:
  - "--- a/fs/ksmbd/smb2misc.c\n+++ b/fs/ksmbd/smb2misc.c\n@@ -90,11 +90,6 @@ static\
    \ int smb2_get_data_area_len(unsigned int *off, unsigned int *len,\n \t*off =\
    \ 0;\n \t*len = 0;\n \n-\t/* error reqeusts do not have data area */\n-\tif (hdr->Status\
    \ && hdr->Status != STATUS_MORE_PROCESSING_REQUIRED &&\n-\t    (((struct smb2_err_rsp\
    \ *)hdr)->StructureSize) == SMB2_ERROR_STRUCTURE_SIZE2_LE)\n-\t\treturn ret;\n\
    -\n \t/*\n \t * Following commands have data areas so we have to get the location\n\
    \ \t * of the data buffer offset and data buffer length for the particular"
  identifiers:
  - CVE-2022-47938
  - CWE-125
  overview: An issue was discovered in ksmbd in the Linux kernel 5.15 through 5.19
    before 5.19.2. fs/ksmbd/smb2misc.c has an out-of-bounds read and OOPS for SMB2_TREE_CONNECT.
  references:
  - source: cve@mitre.org
    tags:
    - Mailing List
    - Third Party Advisory
    url: http://www.openwall.com/lists/oss-security/2022/12/23/10
  - source: cve@mitre.org
    tags:
    - Mailing List
    - Patch
    - Vendor Advisory
    url: https://cdn.kernel.org/pub/linux/kernel/v5.x/ChangeLog-5.19.2
  - source: cve@mitre.org
    tags:
    - Mailing List
    - Patch
    - Vendor Advisory
    url: https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=824d4f64c20093275f72fc8101394d75ff6a249e
  - source: cve@mitre.org
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/torvalds/linux/commit/824d4f64c20093275f72fc8101394d75ff6a249e
  - source: cve@mitre.org
    tags:
    - Third Party Advisory
    - VDB Entry
    url: https://www.zerodayinitiative.com/advisories/ZDI-22-1689/
  title: An issue was discovered in ksmbd in the Linux kernel 5.15 through 5.19 before
    5.19.2. fs/ksmbd/smb2misc.c has an out-of-bounds read and OOPS for SMB2_TREE_CONNECT.
- diff_content:
  - "--- a/fs/ksmbd/smb2pdu.c\n+++ b/fs/ksmbd/smb2pdu.c\n@@ -2057,6 +2057,7 @@ int\
    \ smb2_tree_disconnect(struct ksmbd_work *work)\n \n \tksmbd_close_tree_conn_fds(work);\n\
    \ \tksmbd_tree_conn_disconnect(sess, tcon);\n+\twork->tcon = NULL;\n \treturn\
    \ 0;\n }\n "
  identifiers:
  - CVE-2022-47939
  - CWE-416
  overview: An issue was discovered in ksmbd in the Linux kernel 5.15 through 5.19
    before 5.19.2. fs/ksmbd/smb2pdu.c has a use-after-free and OOPS for SMB2_TREE_DISCONNECT.
  references:
  - source: cve@mitre.org
    tags:
    - Mailing List
    - Third Party Advisory
    url: http://www.openwall.com/lists/oss-security/2022/12/23/10
  - source: cve@mitre.org
    tags:
    - Mailing List
    - Patch
    - Vendor Advisory
    url: https://cdn.kernel.org/pub/linux/kernel/v5.x/ChangeLog-5.19.2
  - source: cve@mitre.org
    tags:
    - Mailing List
    - Patch
    - Vendor Advisory
    url: https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=cf6531d98190fa2cf92a6d8bbc8af0a4740a223c
  - source: cve@mitre.org
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/torvalds/linux/commit/cf6531d98190fa2cf92a6d8bbc8af0a4740a223c
  - source: cve@mitre.org
    tags:
    - Third Party Advisory
    url: https://www.secpod.com/blog/zero-day-server-message-block-smb-server-in-linux-kernel-5-15-has-a-critical-vulnerability-patch-ksmbd-immediately/
  - source: cve@mitre.org
    tags:
    - Third Party Advisory
    - VDB Entry
    url: https://www.zerodayinitiative.com/advisories/ZDI-22-1690/
  title: An issue was discovered in ksmbd in the Linux kernel 5.15 through 5.19 before
    5.19.2. fs/ksmbd/smb2pdu.c has a use-after-free and OOPS for SMB2_TREE_DISCONNECT.
- diff_content:
  - "--- a/fs/ksmbd/smb2pdu.c\n+++ b/fs/ksmbd/smb2pdu.c\n@@ -6328,23 +6328,18 @@ static\
    \ noinline int smb2_write_pipe(struct ksmbd_work *work)\n \tlength = le32_to_cpu(req->Length);\n\
    \ \tid = req->VolatileFileId;\n \n-\tif (le16_to_cpu(req->DataOffset) ==\n-\t\
    \    offsetof(struct smb2_write_req, Buffer)) {\n-\t\tdata_buf = (char *)&req->Buffer[0];\n\
    -\t} else {\n-\t\tif ((u64)le16_to_cpu(req->DataOffset) + length >\n-\t\t    get_rfc1002_len(work->request_buf))\
    \ {\n-\t\t\tpr_err(\"invalid write data offset %u, smb_len %u\\n\",\n-\t\t\t \
    \      le16_to_cpu(req->DataOffset),\n-\t\t\t       get_rfc1002_len(work->request_buf));\n\
    -\t\t\terr = -EINVAL;\n-\t\t\tgoto out;\n-\t\t}\n-\n-\t\tdata_buf = (char *)(((char\
    \ *)&req->hdr.ProtocolId) +\n-\t\t\t\tle16_to_cpu(req->DataOffset));\n+\tif ((u64)le16_to_cpu(req->DataOffset)\
    \ + length >\n+\t    get_rfc1002_len(work->request_buf)) {\n+\t\tpr_err(\"invalid\
    \ write data offset %u, smb_len %u\\n\",\n+\t\t       le16_to_cpu(req->DataOffset),\n\
    +\t\t       get_rfc1002_len(work->request_buf));\n+\t\terr = -EINVAL;\n+\t\tgoto\
    \ out;\n \t}\n \n+\tdata_buf = (char *)(((char *)&req->hdr.ProtocolId) +\n+\t\t\
    \t   le16_to_cpu(req->DataOffset));\n+\n \trpc_resp = ksmbd_rpc_write(work->sess,\
    \ id, data_buf, length);\n \tif (rpc_resp) {\n \t\tif (rpc_resp->flags == KSMBD_RPC_ENOTIMPLEMENTED)\
    \ {\n@@ -6489,22 +6484,16 @@ int smb2_write(struct ksmbd_work *work)\n \n \tif\
    \ (req->Channel != SMB2_CHANNEL_RDMA_V1 &&\n \t    req->Channel != SMB2_CHANNEL_RDMA_V1_INVALIDATE)\
    \ {\n-\t\tif (le16_to_cpu(req->DataOffset) ==\n-\t\t    offsetof(struct smb2_write_req,\
    \ Buffer)) {\n-\t\t\tdata_buf = (char *)&req->Buffer[0];\n-\t\t} else {\n-\t\t\
    \tif ((u64)le16_to_cpu(req->DataOffset) + length >\n-\t\t\t    get_rfc1002_len(work->request_buf))\
    \ {\n-\t\t\t\tpr_err(\"invalid write data offset %u, smb_len %u\\n\",\n-\t\t\t\
    \t       le16_to_cpu(req->DataOffset),\n-\t\t\t\t       get_rfc1002_len(work->request_buf));\n\
    -\t\t\t\terr = -EINVAL;\n-\t\t\t\tgoto out;\n-\t\t\t}\n-\n-\t\t\tdata_buf = (char\
    \ *)(((char *)&req->hdr.ProtocolId) +\n-\t\t\t\t\tle16_to_cpu(req->DataOffset));\n\
    +\t\tif ((u64)le16_to_cpu(req->DataOffset) + length >\n+\t\t    get_rfc1002_len(work->request_buf))\
    \ {\n+\t\t\tpr_err(\"invalid write data offset %u, smb_len %u\\n\",\n+\t\t\t \
    \      le16_to_cpu(req->DataOffset),\n+\t\t\t       get_rfc1002_len(work->request_buf));\n\
    +\t\t\terr = -EINVAL;\n+\t\t\tgoto out;\n \t\t}\n+\t\tdata_buf = (char *)(((char\
    \ *)&req->hdr.ProtocolId) +\n+\t\t\t\t    le16_to_cpu(req->DataOffset));\n \n\
    \ \t\tksmbd_debug(SMB, \"flags %u\\n\", le32_to_cpu(req->Flags));\n \t\tif (le32_to_cpu(req->Flags)\
    \ & SMB2_WRITEFLAG_WRITE_THROUGH)"
  identifiers:
  - CVE-2022-47940
  - CWE-125
  overview: An issue was discovered in ksmbd in the Linux kernel 5.15 through 5.18
    before 5.18.18. fs/ksmbd/smb2pdu.c lacks length validation in the non-padding
    case in smb2_write.
  references:
  - source: cve@mitre.org
    tags:
    - Mailing List
    - Third Party Advisory
    url: http://www.openwall.com/lists/oss-security/2022/12/23/10
  - source: cve@mitre.org
    tags:
    - Mailing List
    - Patch
    - Vendor Advisory
    url: https://cdn.kernel.org/pub/linux/kernel/v5.x/ChangeLog-5.18.18
  - source: cve@mitre.org
    tags:
    - Mailing List
    - Patch
    - Vendor Advisory
    url: https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=158a66b245739e15858de42c0ba60fcf3de9b8e6
  - source: cve@mitre.org
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/torvalds/linux/commit/158a66b245739e15858de42c0ba60fcf3de9b8e6
  title: An issue was discovered in ksmbd in the Linux kernel 5.15 through 5.18 before
    5.18.18. fs/ksmbd/smb2pdu.c lacks length validation in the non-padding case in
    smb2_write.
- diff_content:
  - "--- a/fs/ksmbd/smb2pdu.c\n+++ b/fs/ksmbd/smb2pdu.c\n@@ -1142,12 +1142,16 @@ int\
    \ smb2_handle_negotiate(struct ksmbd_work *work)\n \t\t\t       status);\n \t\t\
    \trsp->hdr.Status = status;\n \t\t\trc = -EINVAL;\n+\t\t\tkfree(conn->preauth_info);\n\
    +\t\t\tconn->preauth_info = NULL;\n \t\t\tgoto err_out;\n \t\t}\n \n \t\trc =\
    \ init_smb3_11_server(conn);\n \t\tif (rc < 0) {\n \t\t\trsp->hdr.Status = STATUS_INVALID_PARAMETER;\n\
    +\t\t\tkfree(conn->preauth_info);\n+\t\t\tconn->preauth_info = NULL;\n \t\t\t\
    goto err_out;\n \t\t}\n "
  identifiers:
  - CVE-2022-47941
  - CWE-401
  overview: An issue was discovered in ksmbd in the Linux kernel 5.15 through 5.19
    before 5.19.2. fs/ksmbd/smb2pdu.c omits a kfree call in certain smb2_handle_negotiate
    error conditions, aka a memory leak.
  references:
  - source: cve@mitre.org
    tags:
    - Mailing List
    - Third Party Advisory
    url: http://www.openwall.com/lists/oss-security/2022/12/23/10
  - source: cve@mitre.org
    tags:
    - Mailing List
    - Patch
    - Vendor Advisory
    url: https://cdn.kernel.org/pub/linux/kernel/v5.x/ChangeLog-5.19.2
  - source: cve@mitre.org
    tags:
    - Mailing List
    - Patch
    - Vendor Advisory
    url: https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=aa7253c2393f6dcd6a1468b0792f6da76edad917
  - source: cve@mitre.org
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/torvalds/linux/commit/aa7253c2393f6dcd6a1468b0792f6da76edad917
  - source: cve@mitre.org
    tags:
    - Third Party Advisory
    - VDB Entry
    url: https://www.zerodayinitiative.com/advisories/ZDI-22-1687/
  title: An issue was discovered in ksmbd in the Linux kernel 5.15 through 5.19 before
    5.19.2. fs/ksmbd/smb2pdu.c omits a kfree call in certain smb2_handle_negotiate
    error conditions, aka a memory leak.
- diff_content:
  - "--- a/fs/ksmbd/smb2pdu.c\n+++ b/fs/ksmbd/smb2pdu.c\n@@ -535,9 +535,10 @@ int\
    \ smb2_allocate_rsp_buf(struct ksmbd_work *work)\n \t\tstruct smb2_query_info_req\
    \ *req;\n \n \t\treq = smb2_get_msg(work->request_buf);\n-\t\tif (req->InfoType\
    \ == SMB2_O_INFO_FILE &&\n-\t\t    (req->FileInfoClass == FILE_FULL_EA_INFORMATION\
    \ ||\n-\t\t     req->FileInfoClass == FILE_ALL_INFORMATION))\n+\t\tif ((req->InfoType\
    \ == SMB2_O_INFO_FILE &&\n+\t\t     (req->FileInfoClass == FILE_FULL_EA_INFORMATION\
    \ ||\n+\t\t     req->FileInfoClass == FILE_ALL_INFORMATION)) ||\n+\t\t    req->InfoType\
    \ == SMB2_O_INFO_SECURITY)\n \t\t\tsz = large_sz;\n \t}\n \n@@ -2988,7 +2989,7\
    \ @@ int smb2_open(struct ksmbd_work *work)\n \t\t\t\t\t\tgoto err_out;\n \n \t\
    \t\t\t\trc = build_sec_desc(user_ns,\n-\t\t\t\t\t\t\t    pntsd, NULL,\n+\t\t\t\
    \t\t\t\t    pntsd, NULL, 0,\n \t\t\t\t\t\t\t    OWNER_SECINFO |\n \t\t\t\t\t\t\
    \t    GROUP_SECINFO |\n \t\t\t\t\t\t\t    DACL_SECINFO,\n@@ -3833,6 +3834,15 @@\
    \ static int verify_info_level(int info_level)\n \treturn 0;\n }\n \n+static int\
    \ smb2_resp_buf_len(struct ksmbd_work *work, unsigned short hdr2_len)\n+{\n+\t\
    int free_len;\n+\n+\tfree_len = (int)(work->response_sz -\n+\t\t(get_rfc1002_len(work->response_buf)\
    \ + 4)) - hdr2_len;\n+\treturn free_len;\n+}\n+\n static int smb2_calc_max_out_buf_len(struct\
    \ ksmbd_work *work,\n \t\t\t\t     unsigned short hdr2_len,\n \t\t\t\t     unsigned\
    \ int out_buf_len)\n@@ -3842,9 +3852,7 @@ static int smb2_calc_max_out_buf_len(struct\
    \ ksmbd_work *work,\n \tif (out_buf_len > work->conn->vals->max_trans_size)\n\
    \ \t\treturn -EINVAL;\n \n-\tfree_len = (int)(work->response_sz -\n-\t\t\t (get_rfc1002_len(work->response_buf)\
    \ + 4)) -\n-\t\thdr2_len;\n+\tfree_len = smb2_resp_buf_len(work, hdr2_len);\n\
    \ \tif (free_len < 0)\n \t\treturn -EINVAL;\n \n@@ -5107,10 +5115,10 @@ static\
    \ int smb2_get_info_sec(struct ksmbd_work *work,\n \tstruct smb_ntsd *pntsd =\
    \ (struct smb_ntsd *)rsp->Buffer, *ppntsd = NULL;\n \tstruct smb_fattr fattr =\
    \ {{0}};\n \tstruct inode *inode;\n-\t__u32 secdesclen;\n+\t__u32 secdesclen =\
    \ 0;\n \tunsigned int id = KSMBD_NO_FID, pid = KSMBD_NO_FID;\n \tint addition_info\
    \ = le32_to_cpu(req->AdditionalInformation);\n-\tint rc;\n+\tint rc = 0, ppntsd_size\
    \ = 0;\n \n \tif (addition_info & ~(OWNER_SECINFO | GROUP_SECINFO | DACL_SECINFO\
    \ |\n \t\t\t      PROTECTED_DACL_SECINFO |\n@@ -5156,11 +5164,14 @@ static int\
    \ smb2_get_info_sec(struct ksmbd_work *work,\n \n \tif (test_share_config_flag(work->tcon->share_conf,\n\
    \ \t\t\t\t   KSMBD_SHARE_FLAG_ACL_XATTR))\n-\t\tksmbd_vfs_get_sd_xattr(work->conn,\
    \ user_ns,\n-\t\t\t\t       fp->filp->f_path.dentry, &ppntsd);\n-\n-\trc = build_sec_desc(user_ns,\
    \ pntsd, ppntsd, addition_info,\n-\t\t\t    &secdesclen, &fattr);\n+\t\tppntsd_size\
    \ = ksmbd_vfs_get_sd_xattr(work->conn, user_ns,\n+\t\t\t\t\t\t     fp->filp->f_path.dentry,\n\
    +\t\t\t\t\t\t     &ppntsd);\n+\n+\t/* Check if sd buffer size exceeds response\
    \ buffer size */\n+\tif (smb2_resp_buf_len(work, 8) > ppntsd_size)\n+\t\trc =\
    \ build_sec_desc(user_ns, pntsd, ppntsd, ppntsd_size,\n+\t\t\t\t    addition_info,\
    \ &secdesclen, &fattr);\n \tposix_acl_release(fattr.cf_acls);\n \tposix_acl_release(fattr.cf_dacls);\n\
    \ \tkfree(ppntsd);"
  - "--- a/fs/ksmbd/smbacl.c\n+++ b/fs/ksmbd/smbacl.c\n@@ -690,6 +690,7 @@ static\
    \ void set_posix_acl_entries_dacl(struct user_namespace *user_ns,\n static void\
    \ set_ntacl_dacl(struct user_namespace *user_ns,\n \t\t\t   struct smb_acl *pndacl,\n\
    \ \t\t\t   struct smb_acl *nt_dacl,\n+\t\t\t   unsigned int aces_size,\n \t\t\t\
    \   const struct smb_sid *pownersid,\n \t\t\t   const struct smb_sid *pgrpsid,\n\
    \ \t\t\t   struct smb_fattr *fattr)\n@@ -703,9 +704,19 @@ static void set_ntacl_dacl(struct\
    \ user_namespace *user_ns,\n \tif (nt_num_aces) {\n \t\tntace = (struct smb_ace\
    \ *)((char *)nt_dacl + sizeof(struct smb_acl));\n \t\tfor (i = 0; i < nt_num_aces;\
    \ i++) {\n-\t\t\tmemcpy((char *)pndace + size, ntace, le16_to_cpu(ntace->size));\n\
    -\t\t\tsize += le16_to_cpu(ntace->size);\n-\t\t\tntace = (struct smb_ace *)((char\
    \ *)ntace + le16_to_cpu(ntace->size));\n+\t\t\tunsigned short nt_ace_size;\n+\n\
    +\t\t\tif (offsetof(struct smb_ace, access_req) > aces_size)\n+\t\t\t\tbreak;\n\
    +\n+\t\t\tnt_ace_size = le16_to_cpu(ntace->size);\n+\t\t\tif (nt_ace_size > aces_size)\n\
    +\t\t\t\tbreak;\n+\n+\t\t\tmemcpy((char *)pndace + size, ntace, nt_ace_size);\n\
    +\t\t\tsize += nt_ace_size;\n+\t\t\taces_size -= nt_ace_size;\n+\t\t\tntace =\
    \ (struct smb_ace *)((char *)ntace + nt_ace_size);\n \t\t\tnum_aces++;\n \t\t\
    }\n \t}\n@@ -878,7 +889,7 @@ int parse_sec_desc(struct user_namespace *user_ns,\
    \ struct smb_ntsd *pntsd,\n /* Convert permission bits from mode to equivalent\
    \ CIFS ACL */\n int build_sec_desc(struct user_namespace *user_ns,\n \t\t   struct\
    \ smb_ntsd *pntsd, struct smb_ntsd *ppntsd,\n-\t\t   int addition_info, __u32\
    \ *secdesclen,\n+\t\t   int ppntsd_size, int addition_info, __u32 *secdesclen,\n\
    \ \t\t   struct smb_fattr *fattr)\n {\n \tint rc = 0;\n@@ -938,15 +949,25 @@ int\
    \ build_sec_desc(struct user_namespace *user_ns,\n \n \t\tif (!ppntsd) {\n \t\t\
    \tset_mode_dacl(user_ns, dacl_ptr, fattr);\n-\t\t} else if (!ppntsd->dacloffset)\
    \ {\n-\t\t\tgoto out;\n \t\t} else {\n \t\t\tstruct smb_acl *ppdacl_ptr;\n+\t\t\
    \tunsigned int dacl_offset = le32_to_cpu(ppntsd->dacloffset);\n+\t\t\tint ppdacl_size,\
    \ ntacl_size = ppntsd_size - dacl_offset;\n+\n+\t\t\tif (!dacl_offset ||\n+\t\t\
    \t    (dacl_offset + sizeof(struct smb_acl) > ppntsd_size))\n+\t\t\t\tgoto out;\n\
    +\n+\t\t\tppdacl_ptr = (struct smb_acl *)((char *)ppntsd + dacl_offset);\n+\t\t\
    \tppdacl_size = le16_to_cpu(ppdacl_ptr->size);\n+\t\t\tif (ppdacl_size > ntacl_size\
    \ ||\n+\t\t\t    ppdacl_size < sizeof(struct smb_acl))\n+\t\t\t\tgoto out;\n \n\
    -\t\t\tppdacl_ptr = (struct smb_acl *)((char *)ppntsd +\n-\t\t\t\t\t\tle32_to_cpu(ppntsd->dacloffset));\n\
    \ \t\t\tset_ntacl_dacl(user_ns, dacl_ptr, ppdacl_ptr,\n-\t\t\t\t       nowner_sid_ptr,\
    \ ngroup_sid_ptr, fattr);\n+\t\t\t\t       ntacl_size - sizeof(struct smb_acl),\n\
    +\t\t\t\t       nowner_sid_ptr, ngroup_sid_ptr,\n+\t\t\t\t       fattr);\n \t\t\
    }\n \t\tpntsd->dacloffset = cpu_to_le32(offset);\n \t\toffset += le16_to_cpu(dacl_ptr->size);\n\
    @@ -980,24 +1001,31 @@ int smb_inherit_dacl(struct ksmbd_conn *conn,\n \tstruct\
    \ smb_sid owner_sid, group_sid;\n \tstruct dentry *parent = path->dentry->d_parent;\n\
    \ \tstruct user_namespace *user_ns = mnt_user_ns(path->mnt);\n-\tint inherited_flags\
    \ = 0, flags = 0, i, ace_cnt = 0, nt_size = 0;\n-\tint rc = 0, num_aces, dacloffset,\
    \ pntsd_type, acl_len;\n+\tint inherited_flags = 0, flags = 0, i, ace_cnt = 0,\
    \ nt_size = 0, pdacl_size;\n+\tint rc = 0, num_aces, dacloffset, pntsd_type, pntsd_size,\
    \ acl_len, aces_size;\n \tchar *aces_base;\n \tbool is_dir = S_ISDIR(d_inode(path->dentry)->i_mode);\n\
    \ \n-\tacl_len = ksmbd_vfs_get_sd_xattr(conn, user_ns,\n-\t\t\t\t\t parent, &parent_pntsd);\n\
    -\tif (acl_len <= 0)\n+\tpntsd_size = ksmbd_vfs_get_sd_xattr(conn, user_ns,\n\
    +\t\t\t\t\t    parent, &parent_pntsd);\n+\tif (pntsd_size <= 0)\n \t\treturn -ENOENT;\n\
    \ \tdacloffset = le32_to_cpu(parent_pntsd->dacloffset);\n-\tif (!dacloffset) {\n\
    +\tif (!dacloffset || (dacloffset + sizeof(struct smb_acl) > pntsd_size)) {\n\
    \ \t\trc = -EINVAL;\n \t\tgoto free_parent_pntsd;\n \t}\n \n \tparent_pdacl =\
    \ (struct smb_acl *)((char *)parent_pntsd + dacloffset);\n+\tacl_len = pntsd_size\
    \ - dacloffset;\n \tnum_aces = le32_to_cpu(parent_pdacl->num_aces);\n \tpntsd_type\
    \ = le16_to_cpu(parent_pntsd->type);\n+\tpdacl_size = le16_to_cpu(parent_pdacl->size);\n\
    +\n+\tif (pdacl_size > acl_len || pdacl_size < sizeof(struct smb_acl)) {\n+\t\t\
    rc = -EINVAL;\n+\t\tgoto free_parent_pntsd;\n+\t}\n \n \taces_base = kmalloc(sizeof(struct\
    \ smb_ace) * num_aces * 2, GFP_KERNEL);\n \tif (!aces_base) {\n@@ -1008,11 +1036,23\
    \ @@ int smb_inherit_dacl(struct ksmbd_conn *conn,\n \taces = (struct smb_ace\
    \ *)aces_base;\n \tparent_aces = (struct smb_ace *)((char *)parent_pdacl +\n \t\
    \t\tsizeof(struct smb_acl));\n+\taces_size = acl_len - sizeof(struct smb_acl);\n\
    \ \n \tif (pntsd_type & DACL_AUTO_INHERITED)\n \t\tinherited_flags = INHERITED_ACE;\n\
    \ \n \tfor (i = 0; i < num_aces; i++) {\n+\t\tint pace_size;\n+\n+\t\tif (offsetof(struct\
    \ smb_ace, access_req) > aces_size)\n+\t\t\tbreak;\n+\n+\t\tpace_size = le16_to_cpu(parent_aces->size);\n\
    +\t\tif (pace_size > aces_size)\n+\t\t\tbreak;\n+\n+\t\taces_size -= pace_size;\n\
    +\n \t\tflags = parent_aces->flags;\n \t\tif (!smb_inherit_flags(flags, is_dir))\n\
    \ \t\t\tgoto pass;\n@@ -1057,8 +1097,7 @@ int smb_inherit_dacl(struct ksmbd_conn\
    \ *conn,\n \t\taces = (struct smb_ace *)((char *)aces + le16_to_cpu(aces->size));\n\
    \ \t\tace_cnt++;\n pass:\n-\t\tparent_aces =\n-\t\t\t(struct smb_ace *)((char\
    \ *)parent_aces + le16_to_cpu(parent_aces->size));\n+\t\tparent_aces = (struct\
    \ smb_ace *)((char *)parent_aces + pace_size);\n \t}\n \n \tif (nt_size > 0) {\n\
    @@ -1153,7 +1192,7 @@ int smb_check_perm_dacl(struct ksmbd_conn *conn, struct\
    \ path *path,\n \tstruct smb_ntsd *pntsd = NULL;\n \tstruct smb_acl *pdacl;\n\
    \ \tstruct posix_acl *posix_acls;\n-\tint rc = 0, acl_size;\n+\tint rc = 0, pntsd_size,\
    \ acl_size, aces_size, pdacl_size, dacl_offset;\n \tstruct smb_sid sid;\n \tint\
    \ granted = le32_to_cpu(*pdaccess & ~FILE_MAXIMAL_ACCESS_LE);\n \tstruct smb_ace\
    \ *ace;\n@@ -1162,49 +1201,50 @@ int smb_check_perm_dacl(struct ksmbd_conn *conn,\
    \ struct path *path,\n \tstruct smb_ace *others_ace = NULL;\n \tstruct posix_acl_entry\
    \ *pa_entry;\n \tunsigned int sid_type = SIDOWNER;\n-\tchar *end_of_acl;\n+\t\
    unsigned short ace_size;\n \n \tksmbd_debug(SMB, \"check permission using windows\
    \ acl\\n\");\n-\tacl_size = ksmbd_vfs_get_sd_xattr(conn, user_ns,\n-\t\t\t\t\t\
    \  path->dentry, &pntsd);\n-\tif (acl_size <= 0 || !pntsd || !pntsd->dacloffset)\
    \ {\n-\t\tkfree(pntsd);\n-\t\treturn 0;\n-\t}\n+\tpntsd_size = ksmbd_vfs_get_sd_xattr(conn,\
    \ user_ns,\n+\t\t\t\t\t    path->dentry, &pntsd);\n+\tif (pntsd_size <= 0 || !pntsd)\n\
    +\t\tgoto err_out;\n+\n+\tdacl_offset = le32_to_cpu(pntsd->dacloffset);\n+\tif\
    \ (!dacl_offset ||\n+\t    (dacl_offset + sizeof(struct smb_acl) > pntsd_size))\n\
    +\t\tgoto err_out;\n \n \tpdacl = (struct smb_acl *)((char *)pntsd + le32_to_cpu(pntsd->dacloffset));\n\
    -\tend_of_acl = ((char *)pntsd) + acl_size;\n-\tif (end_of_acl <= (char *)pdacl)\
    \ {\n-\t\tkfree(pntsd);\n-\t\treturn 0;\n-\t}\n+\tacl_size = pntsd_size - dacl_offset;\n\
    +\tpdacl_size = le16_to_cpu(pdacl->size);\n \n-\tif (end_of_acl < (char *)pdacl\
    \ + le16_to_cpu(pdacl->size) ||\n-\t    le16_to_cpu(pdacl->size) < sizeof(struct\
    \ smb_acl)) {\n-\t\tkfree(pntsd);\n-\t\treturn 0;\n-\t}\n+\tif (pdacl_size > acl_size\
    \ || pdacl_size < sizeof(struct smb_acl))\n+\t\tgoto err_out;\n \n \tif (!pdacl->num_aces)\
    \ {\n-\t\tif (!(le16_to_cpu(pdacl->size) - sizeof(struct smb_acl)) &&\n+\t\tif\
    \ (!(pdacl_size - sizeof(struct smb_acl)) &&\n \t\t    *pdaccess & ~(FILE_READ_CONTROL_LE\
    \ | FILE_WRITE_DAC_LE)) {\n \t\t\trc = -EACCES;\n \t\t\tgoto err_out;\n \t\t}\n\
    -\t\tkfree(pntsd);\n-\t\treturn 0;\n+\t\tgoto err_out;\n \t}\n \n \tif (*pdaccess\
    \ & FILE_MAXIMAL_ACCESS_LE) {\n \t\tgranted = READ_CONTROL | WRITE_DAC | FILE_READ_ATTRIBUTES\
    \ |\n \t\t\tDELETE;\n \n \t\tace = (struct smb_ace *)((char *)pdacl + sizeof(struct\
    \ smb_acl));\n+\t\taces_size = acl_size - sizeof(struct smb_acl);\n \t\tfor (i\
    \ = 0; i < le32_to_cpu(pdacl->num_aces); i++) {\n+\t\t\tif (offsetof(struct smb_ace,\
    \ access_req) > aces_size)\n+\t\t\t\tbreak;\n+\t\t\tace_size = le16_to_cpu(ace->size);\n\
    +\t\t\tif (ace_size > aces_size)\n+\t\t\t\tbreak;\n+\t\t\taces_size -= ace_size;\n\
    \ \t\t\tgranted |= le32_to_cpu(ace->access_req);\n \t\t\tace = (struct smb_ace\
    \ *)((char *)ace + le16_to_cpu(ace->size));\n-\t\t\tif (end_of_acl < (char *)ace)\n\
    -\t\t\t\tgoto err_out;\n \t\t}\n \n \t\tif (!pdacl->num_aces)\n@@ -1216,7 +1256,15\
    \ @@ int smb_check_perm_dacl(struct ksmbd_conn *conn, struct path *path,\n \t\
    id_to_sid(uid, sid_type, &sid);\n \n \tace = (struct smb_ace *)((char *)pdacl\
    \ + sizeof(struct smb_acl));\n+\taces_size = acl_size - sizeof(struct smb_acl);\n\
    \ \tfor (i = 0; i < le32_to_cpu(pdacl->num_aces); i++) {\n+\t\tif (offsetof(struct\
    \ smb_ace, access_req) > aces_size)\n+\t\t\tbreak;\n+\t\tace_size = le16_to_cpu(ace->size);\n\
    +\t\tif (ace_size > aces_size)\n+\t\t\tbreak;\n+\t\taces_size -= ace_size;\n+\n\
    \ \t\tif (!compare_sids(&sid, &ace->sid) ||\n \t\t    !compare_sids(&sid_unix_NFS_mode,\
    \ &ace->sid)) {\n \t\t\tfound = 1;\n@@ -1226,8 +1274,6 @@ int smb_check_perm_dacl(struct\
    \ ksmbd_conn *conn, struct path *path,\n \t\t\tothers_ace = ace;\n \n \t\tace\
    \ = (struct smb_ace *)((char *)ace + le16_to_cpu(ace->size));\n-\t\tif (end_of_acl\
    \ < (char *)ace)\n-\t\t\tgoto err_out;\n \t}\n \n \tif (*pdaccess & FILE_MAXIMAL_ACCESS_LE\
    \ && found) {"
  - "--- a/fs/ksmbd/vfs.c\n+++ b/fs/ksmbd/vfs.c\n@@ -1539,6 +1539,11 @@ int ksmbd_vfs_get_sd_xattr(struct\
    \ ksmbd_conn *conn,\n \t}\n \n \t*pntsd = acl.sd_buf;\n+\tif (acl.sd_size < sizeof(struct\
    \ smb_ntsd)) {\n+\t\tpr_err(\"sd size is invalid\\n\");\n+\t\tgoto out_free;\n\
    +\t}\n+\n \t(*pntsd)->osidoffset = cpu_to_le32(le32_to_cpu((*pntsd)->osidoffset)\
    \ -\n \t\t\t\t\t   NDR_NTSD_OFFSETOF);\n \t(*pntsd)->gsidoffset = cpu_to_le32(le32_to_cpu((*pntsd)->gsidoffset)\
    \ -"
  identifiers:
  - CVE-2022-47942
  - CWE-787
  overview: An issue was discovered in ksmbd in the Linux kernel 5.15 through 5.19
    before 5.19.2. There is a heap-based buffer overflow in set_ntacl_dacl, related
    to use of SMB2_QUERY_INFO_HE after a malformed SMB2_SET_INFO_HE command.
  references:
  - source: cve@mitre.org
    tags:
    - Mailing List
    - Third Party Advisory
    url: http://www.openwall.com/lists/oss-security/2022/12/23/10
  - source: cve@mitre.org
    tags:
    - Mailing List
    - Third Party Advisory
    - Vendor Advisory
    url: https://cdn.kernel.org/pub/linux/kernel/v5.x/ChangeLog-5.19.2
  - source: cve@mitre.org
    tags:
    - Mailing List
    - Patch
    - Third Party Advisory
    - Vendor Advisory
    url: https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=8f0541186e9ad1b62accc9519cc2b7a7240272a7
  - source: cve@mitre.org
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/torvalds/linux/commit/8f0541186e9ad1b62accc9519cc2b7a7240272a7
  - source: cve@mitre.org
    tags:
    - Third Party Advisory
    - VDB Entry
    url: https://www.zerodayinitiative.com/advisories/ZDI-22-1688/
  title: An issue was discovered in ksmbd in the Linux kernel 5.15 through 5.19 before
    5.19.2. There is a heap-based buffer overflow in set_ntacl_dacl, related to use
    of SMB2_QUERY_INFO_HE after a malformed SMB2_SET_INFO_HE command.
- diff_content:
  - "--- a/fs/ksmbd/smb2misc.c\n+++ b/fs/ksmbd/smb2misc.c\n@@ -136,8 +136,11 @@ static\
    \ int smb2_get_data_area_len(unsigned int *off, unsigned int *len,\n \t\t*len\
    \ = le16_to_cpu(((struct smb2_read_req *)hdr)->ReadChannelInfoLength);\n \t\t\
    break;\n \tcase SMB2_WRITE:\n-\t\tif (((struct smb2_write_req *)hdr)->DataOffset)\
    \ {\n-\t\t\t*off = le16_to_cpu(((struct smb2_write_req *)hdr)->DataOffset);\n\
    +\t\tif (((struct smb2_write_req *)hdr)->DataOffset ||\n+\t\t    ((struct smb2_write_req\
    \ *)hdr)->Length) {\n+\t\t\t*off = max_t(unsigned int,\n+\t\t\t\t     le16_to_cpu(((struct\
    \ smb2_write_req *)hdr)->DataOffset),\n+\t\t\t\t     offsetof(struct smb2_write_req,\
    \ Buffer));\n \t\t\t*len = le32_to_cpu(((struct smb2_write_req *)hdr)->Length);\n\
    \ \t\t\tbreak;\n \t\t}"
  - "--- a/fs/ksmbd/smb2pdu.c\n+++ b/fs/ksmbd/smb2pdu.c\n@@ -6514,14 +6514,12 @@ int\
    \ smb2_write(struct ksmbd_work *work)\n \t\twritethrough = true;\n \n \tif (is_rdma_channel\
    \ == false) {\n-\t\tif ((u64)le16_to_cpu(req->DataOffset) + length >\n-\t\t  \
    \  get_rfc1002_len(work->request_buf)) {\n-\t\t\tpr_err(\"invalid write data offset\
    \ %u, smb_len %u\\n\",\n-\t\t\t       le16_to_cpu(req->DataOffset),\n-\t\t\t \
    \      get_rfc1002_len(work->request_buf));\n+\t\tif (le16_to_cpu(req->DataOffset)\
    \ <\n+\t\t    offsetof(struct smb2_write_req, Buffer)) {\n \t\t\terr = -EINVAL;\n\
    \ \t\t\tgoto out;\n \t\t}\n+\n \t\tdata_buf = (char *)(((char *)&req->hdr.ProtocolId)\
    \ +\n \t\t\t\t    le16_to_cpu(req->DataOffset));\n "
  identifiers:
  - CVE-2022-47943
  - CWE-125
  overview: An issue was discovered in ksmbd in the Linux kernel 5.15 through 5.19
    before 5.19.2. There is an out-of-bounds read and OOPS for SMB2_WRITE, when there
    is a large length in the zero DataOffset case.
  references:
  - source: cve@mitre.org
    tags:
    - Mailing List
    - Third Party Advisory
    url: http://www.openwall.com/lists/oss-security/2022/12/23/10
  - source: cve@mitre.org
    tags:
    - Mailing List
    - Patch
    - Vendor Advisory
    url: https://cdn.kernel.org/pub/linux/kernel/v5.x/ChangeLog-5.19.2
  - source: cve@mitre.org
    tags:
    - Mailing List
    - Patch
    - Vendor Advisory
    url: https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=ac60778b87e45576d7bfdbd6f53df902654e6f09
  - source: cve@mitre.org
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/torvalds/linux/commit/ac60778b87e45576d7bfdbd6f53df902654e6f09
  - source: cve@mitre.org
    tags:
    - Third Party Advisory
    url: https://security.netapp.com/advisory/ntap-20230216-0006/
  - source: cve@mitre.org
    tags:
    - Third Party Advisory
    - VDB Entry
    url: https://www.zerodayinitiative.com/advisories/ZDI-22-1691/
  title: An issue was discovered in ksmbd in the Linux kernel 5.15 through 5.19 before
    5.19.2. There is an out-of-bounds read and OOPS for SMB2_WRITE, when there is
    a large length in the zero DataOffset case.
- diff_content:
  - "--- a/src/lib/krb5/krb/pac.c\n+++ b/src/lib/krb5/krb/pac.c\n@@ -28,6 +28,8 @@\n\
    \ #include \"int-proto.h\"\n #include \"authdata.h\"\n \n+#define MAX_BUFFERS\
    \ 4096\n+\n /* draft-brezak-win2k-krb-authz-00 */\n \n /*\n@@ -317,6 +319,9 @@\
    \ krb5_pac_parse(krb5_context context,\n     if (version != 0)\n         return\
    \ EINVAL;\n \n+    if (cbuffers < 1 || cbuffers > MAX_BUFFERS)\n+        return\
    \ ERANGE;\n+\n     header_len = PACTYPE_LENGTH + (cbuffers * PAC_INFO_BUFFER_LENGTH);\n\
    \     if (len < header_len)\n         return ERANGE;\n@@ -349,8 +354,8 @@ krb5_pac_parse(krb5_context\
    \ context,\n             krb5_pac_free(context, pac);\n             return EINVAL;\n\
    \         }\n-        if (buffer->Offset < header_len ||\n-            buffer->Offset\
    \ + buffer->cbBufferSize > len) {\n+        if (buffer->Offset < header_len ||\
    \ buffer->Offset > len ||\n+            buffer->cbBufferSize > len - buffer->Offset)\
    \ {\n             krb5_pac_free(context, pac);\n             return ERANGE;\n\
    \         }"
  - "--- a/src/lib/krb5/krb/t_pac.c\n+++ b/src/lib/krb5/krb/t_pac.c\n@@ -431,6 +431,16\
    \ @@ static const unsigned char s4u_pac_ent_xrealm[] = {\n     0x8a, 0x81, 0x9c,\
    \ 0x9c, 0x00, 0x00, 0x00, 0x00\n };\n \n+static const unsigned char fuzz1[] =\
    \ {\n+    0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00,\n+    0x06, 0xff, 0xff,\
    \ 0xff, 0x00, 0x00, 0xf5\n+};\n+\n+static const unsigned char fuzz2[] = {\n+ \
    \   0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00,\n+    0x20, 0x20\n+};\n+\n\
    \ static const char *s4u_principal = \"w2k8u@ACME.COM\";\n static const char *s4u_enterprise\
    \ = \"w2k8u@abc@ACME.COM\";\n \n@@ -828,6 +838,14 @@ main(int argc, char **argv)\n\
    \         krb5_free_principal(context, sep);\n     }\n \n+    /* Check problematic\
    \ PACs found by fuzzing. */\n+    ret = krb5_pac_parse(context, fuzz1, sizeof(fuzz1),\
    \ &pac);\n+    if (!ret)\n+        err(context, ret, \"krb5_pac_parse should have\
    \ failed\");\n+    ret = krb5_pac_parse(context, fuzz2, sizeof(fuzz2), &pac);\n\
    +    if (!ret)\n+        err(context, ret, \"krb5_pac_parse should have failed\"\
    );\n+\n     /*\n      * Test empty free\n      */"
  identifiers:
  - CVE-2022-42898
  - CWE-190
  overview: PAC parsing in MIT Kerberos 5 (aka krb5) before 1.19.4 and 1.20.x before
    1.20.1 has integer overflows that may lead to remote code execution (in KDC, kadmind,
    or a GSS or Kerberos application server) on 32-bit platforms (which have a resultant
    heap-based buffer overflow), and cause a denial of service on other platforms.
    This occurs in krb5_pac_parse in lib/krb5/krb/pac.c. Heimdal before 7.7.1 has
    "a similar bug."
  references:
  - source: cve@mitre.org
    tags:
    - Exploit
    - Issue Tracking
    - Patch
    - Third Party Advisory
    url: https://bugzilla.samba.org/show_bug.cgi?id=15203
  - source: cve@mitre.org
    tags:
    - Third Party Advisory
    url: https://github.com/heimdal/heimdal/security/advisories/GHSA-64mq-fvfj-5x3c
  - source: cve@mitre.org
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/krb5/krb5/commit/ea92d2f0fcceb54a70910fa32e9a0d7a5afc3583
  - source: cve@mitre.org
    url: https://security.gentoo.org/glsa/202309-06
  - source: cve@mitre.org
    url: https://security.gentoo.org/glsa/202310-06
  - source: cve@mitre.org
    url: https://security.netapp.com/advisory/ntap-20230216-0008/
  - source: cve@mitre.org
    url: https://security.netapp.com/advisory/ntap-20230223-0001/
  - source: cve@mitre.org
    tags:
    - Vendor Advisory
    url: https://web.mit.edu/kerberos/advisories/
  - source: cve@mitre.org
    tags:
    - Release Notes
    - Vendor Advisory
    url: https://web.mit.edu/kerberos/krb5-1.19/
  - source: cve@mitre.org
    tags:
    - Vendor Advisory
    url: https://web.mit.edu/kerberos/krb5-1.20/README-1.20.1.txt
  - source: cve@mitre.org
    tags:
    - Third Party Advisory
    url: https://www.samba.org/samba/security/CVE-2022-42898.html
  title: PAC parsing in MIT Kerberos 5 (aka krb5) before 1.19.4 and 1.20.x before
    1.20.1 has integer overflows that may lead to remote code execution (in KDC, kadmind,
    or a GSS or Kerberos application server) on 32-bit platforms (which have a resultant
    heap-based buffer overflow), and cause a denial of service on other platforms.
    This occurs in krb5_pac_parse in lib/krb5/krb/pac.c. Heimdal before 7.7.1 has
    "a similar bug."
- diff_content:
  - "--- a/src/DSCIOManager.cpp\n+++ b/src/DSCIOManager.cpp\n@@ -214,6 +214,9 @@ DSCIOManager::dsc_import_input_from_source()\
    \ {\n     \n     string node = bfs::initial_path().filename().generic_string();\n\
    \     string server = bfs::initial_path().parent_path().filename().generic_string();\n\
    +    //fix potential sql injection\n+    replace(node.begin(), node.end(), '\\\
    '', '_');\n+    replace(server.begin(), server.end(), '\\'', '_');\n     //transform\
    \ to 'internal' name\n     replace(server.begin(), server.end(), '-', '_');\n\
    \     replace_string(server, \".\", \"__\");"
  identifiers:
  - CVE-2021-4276
  - CWE-89
  overview: "** UNSUPPORTED WHEN ASSIGNED ** A vulnerability was found in dns-stats\
    \ hedgehog. It has been rated as problematic. Affected by this issue is the function\
    \ DSCIOManager::dsc_import_input_from_source of the file src/DSCIOManager.cpp.\
    \ The manipulation leads to sql injection. The attack may be launched remotely.\
    \ The exploit has been disclosed to the public and may be used. The real existence\
    \ of this vulnerability is still doubted at the moment. The name of the patch\
    \ is 58922c345d3d1fe89bb2020111873a3e07ca93ac. It is recommended to apply a patch\
    \ to fix this issue. VDB-216746 is the identifier assigned to this vulnerability.\
    \ NOTE: This vulnerability only affects products that are no longer supported\
    \ by the maintainer. NOTE: We do assume that the Data Manager server can only\
    \ be accessed by authorised users. Because of this, we don\u2019t believe this\
    \ specific attack is possible without such a compromise of the Data Manager server."
  references:
  - source: cna@vuldb.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/dns-stats/hedgehog/commit/58922c345d3d1fe89bb2020111873a3e07ca93ac
  - source: cna@vuldb.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/dns-stats/hedgehog/pull/190
  - source: cna@vuldb.com
    tags:
    - Third Party Advisory
    url: https://vuldb.com/?id.216746
  title: "** UNSUPPORTED WHEN ASSIGNED ** A vulnerability was found in dns-stats hedgehog.\
    \ It has been rated as problematic. Affected by this issue is the function DSCIOManager::dsc_import_input_from_source\
    \ of the file src/DSCIOManager.cpp. The manipulation leads to sql injection. The\
    \ attack may be launched remotely. The exploit has been disclosed to the public\
    \ and may be used. The real existence of this vulnerability is still doubted at\
    \ the moment. The name of the patch is 58922c345d3d1fe89bb2020111873a3e07ca93ac.\
    \ It is recommended to apply a patch to fix this issue. VDB-216746 is the identifier\
    \ assigned to this vulnerability. NOTE: This vulnerability only affects products\
    \ that are no longer supported by the maintainer. NOTE: We do assume that the\
    \ Data Manager server can only be accessed by authorised users. Because of this,\
    \ we don\u2019t believe this specific attack is possible without such a compromise\
    \ of the Data Manager server."
- diff_content:
  - "--- a/lib/gssapi/spnego/accept_sec_context.c\n+++ b/lib/gssapi/spnego/accept_sec_context.c\n\
    @@ -619,13 +619,15 @@ acceptor_start\n \t    if (ret == 0)\n \t\tbreak;\n \t}\n\
    -\tif (preferred_mech_type == GSS_C_NO_OID) {\n-\t    HEIMDAL_MUTEX_unlock(&ctx->ctx_id_mutex);\n\
    -\t    free_NegotiationToken(&nt);\n-\t    return ret;\n-\t}\n+    }\n+\n+   \
    \ ctx->preferred_mech_type = preferred_mech_type;\n \n-\tctx->preferred_mech_type\
    \ = preferred_mech_type;\n+    if (preferred_mech_type == GSS_C_NO_OID) {\n+ \
    \       send_reject(minor_status, output_token);\n+        HEIMDAL_MUTEX_unlock(&ctx->ctx_id_mutex);\n\
    +        free_NegotiationToken(&nt);\n+        return ret;\n     }\n \n     /*"
  identifiers:
  - CVE-2021-44758
  - CWE-476
  overview: Heimdal before 7.7.1 allows attackers to cause a NULL pointer dereference
    in a SPNEGO acceptor via a preferred_mech_type of GSS_C_NO_OID and a nonzero initial_response
    value to send_accept.
  references:
  - source: cve@mitre.org
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/heimdal/heimdal/commit/f9ec7002cdd526ae84fbacbf153162e118f22580
  - source: cve@mitre.org
    tags:
    - Third Party Advisory
    url: https://github.com/heimdal/heimdal/security/advisories/GHSA-69h9-669w-88xv
  - source: cve@mitre.org
    url: https://security.gentoo.org/glsa/202310-06
  title: Heimdal before 7.7.1 allows attackers to cause a NULL pointer dereference
    in a SPNEGO acceptor via a preferred_mech_type of GSS_C_NO_OID and a nonzero initial_response
    value to send_accept.
- diff_content:
  - "--- a/usr/src/uts/common/fs/tmpfs/tmp_dir.c\n+++ b/usr/src/uts/common/fs/tmpfs/tmp_dir.c\n\
    @@ -55,6 +55,11 @@ static int tdiraddentry(struct tmpnode *, struct tmpnode *,\
    \ char *,\n #define\tT_HASH_SIZE\t8192\t\t/* must be power of 2 */\n #define\t\
    T_MUTEX_SIZE\t64\n \n+/* Non-static so compilers won't constant-fold these away.\
    \ */\n+clock_t tmpfs_rename_backoff_delay = 1;\n+unsigned int tmpfs_rename_backoff_tries\
    \ = 0;\n+unsigned long tmpfs_rename_loops = 0;\n+\n static struct tdirent\t*t_hashtable[T_HASH_SIZE];\n\
    \ static kmutex_t\t\t t_hashmutex[T_MUTEX_SIZE];\n \n@@ -267,8 +272,65 @@ tdirenter(\n\
    \ \t * to see if it has been removed while it was unlocked.\n \t */\n \tif (op\
    \ == DE_LINK || op == DE_RENAME) {\n-\t\tif (tp != dir)\n-\t\t\trw_enter(&tp->tn_rwlock,\
    \ RW_WRITER);\n+\t\tif (tp != dir) {\n+\t\t\tunsigned int tries = 0;\n+\n+\t\t\
    \t/*\n+\t\t\t * If we are acquiring tp->tn_rwlock (for SOURCE)\n+\t\t\t * inside\
    \ here, we must consider the following:\n+\t\t\t *\n+\t\t\t * - dir->tn_rwlock\
    \ (TARGET) is already HELD (see\n+\t\t\t * above ASSERT()).\n+\t\t\t *\n+\t\t\t\
    \ * - It is possible our SOURCE is a parent of our\n+\t\t\t * TARGET. Yes it's\
    \ unusual, but it will return an\n+\t\t\t * error below via tdircheckpath().\n\
    +\t\t\t *\n+\t\t\t * - It is also possible that another thread,\n+\t\t\t * concurrent\
    \ to this one, is performing\n+\t\t\t * rmdir(TARGET), which means it will first\
    \ acquire\n+\t\t\t * SOURCE's lock, THEN acquire TARGET's lock, which\n+\t\t\t\
    \ * could result in this thread holding TARGET and\n+\t\t\t * trying for SOURCE,\
    \ but the other thread holding\n+\t\t\t * SOURCE and trying for TARGET.  This\
    \ is deadlock,\n+\t\t\t * and it's inducible.\n+\t\t\t *\n+\t\t\t * To prevent\
    \ this, we borrow some techniques from UFS\n+\t\t\t * and rw_tryenter(), delaying\
    \ if we fail, and\n+\t\t\t * if someone tweaks the number of backoff tries to\
    \ be\n+\t\t\t * nonzero, return EBUSY after that number of tries.\n+\t\t\t */\n\
    +\t\t\twhile (!rw_tryenter(&tp->tn_rwlock, RW_WRITER)) {\n+\t\t\t\t/*\n+\t\t\t\
    \t * Sloppy, but this is a diagnostic so atomic\n+\t\t\t\t * increment would be\
    \ overkill.\n+\t\t\t\t */\n+\t\t\t\ttmpfs_rename_loops++;\n+\n+\t\t\t\tif (tmpfs_rename_backoff_tries\
    \ != 0) {\n+\t\t\t\t\tif (tries > tmpfs_rename_backoff_tries)\n+\t\t\t\t\t\treturn\
    \ (EBUSY);\n+\t\t\t\t\ttries++;\n+\t\t\t\t}\n+\t\t\t\t/*\n+\t\t\t\t * NOTE: We're\
    \ still holding dir->tn_rwlock,\n+\t\t\t\t * so drop it over the delay, so any\
    \ other\n+\t\t\t\t * thread can get its business done.\n+\t\t\t\t *\n+\t\t\t\t\
    \ * No state change or state inspection happens\n+\t\t\t\t * prior to here, so\
    \ it is not wholly dangerous\n+\t\t\t\t * to release-and-reacquire dir->tn_rwlock.\n\
    +\t\t\t\t *\n+\t\t\t\t * Hold the vnode of dir in case it gets\n+\t\t\t\t * released\
    \ by another thread, though.\n+\t\t\t\t */\n+\t\t\t\tVN_HOLD(TNTOV(dir));\n+\t\
    \t\t\trw_exit(&dir->tn_rwlock);\n+\t\t\t\tdelay(tmpfs_rename_backoff_delay);\n\
    +\t\t\t\trw_enter(&dir->tn_rwlock, RW_WRITER);\n+\t\t\t\tVN_RELE(TNTOV(dir));\n\
    +\t\t\t}\n+\t\t}\n \t\tmutex_enter(&tp->tn_tlock);\n \t\tif (tp->tn_nlink == 0)\
    \ {\n \t\t\tmutex_exit(&tp->tn_tlock);"
  identifiers:
  - CVE-2021-43395
  - CWE-667
  overview: An issue was discovered in illumos before f859e7171bb5db34321e45585839c6c3200ebb90,
    OmniOS Community Edition r151038, OpenIndiana Hipster 2021.04, and SmartOS 20210923.
    A local unprivileged user can cause a deadlock and kernel panic via crafted rename
    and rmdir calls on tmpfs filesystems. Oracle Solaris 10 and 11 is also affected.
  references:
  - source: cve@mitre.org
    tags:
    - Release Notes
    - Third Party Advisory
    url: http://www.tribblix.org/relnotes.html
  - source: cve@mitre.org
    tags:
    - Exploit
    - Third Party Advisory
    url: https://github.com/illumos/illumos-gate/blob/069654420de4aade43c63c43cd2896e66945fc8a/usr/src/uts/common/fs/tmpfs/tmp_vnops.c
  - source: cve@mitre.org
    tags:
    - Exploit
    - Third Party Advisory
    url: https://github.com/illumos/illumos-gate/blob/b3403853e80914bd0aade9b5b605da4878078173/usr/src/uts/common/fs/tmpfs/tmp_dir.c
  - source: cve@mitre.org
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/illumos/illumos-gate/commit/f859e7171bb5db34321e45585839c6c3200ebb90
  - source: cve@mitre.org
    tags:
    - Vendor Advisory
    url: https://illumos.topicbox.com/groups/developer/T1c9e4f27f8c2f959/security-heads-up-illumos14424
  - source: cve@mitre.org
    tags:
    - Third Party Advisory
    url: https://jgardner100.wordpress.com/2022/01/20/security-heads-up/
  - source: cve@mitre.org
    tags:
    - Third Party Advisory
    url: https://kebe.com/blog/?p=505
  - source: cve@mitre.org
    tags:
    - Issue Tracking
    - Patch
    - Vendor Advisory
    url: https://www.illumos.org/issues/14424
  - source: cve@mitre.org
    tags:
    - Patch
    - Third Party Advisory
    url: https://www.oracle.com/security-alerts/cpujan2022.html
  title: An issue was discovered in illumos before f859e7171bb5db34321e45585839c6c3200ebb90,
    OmniOS Community Edition r151038, OpenIndiana Hipster 2021.04, and SmartOS 20210923.
    A local unprivileged user can cause a deadlock and kernel panic via crafted rename
    and rmdir calls on tmpfs filesystems. Oracle Solaris 10 and 11 is also affected.
- diff_content:
  - "--- a/gvdb-builder.c\n+++ b/gvdb-builder.c\n@@ -608,7 +608,9 @@ gvdb_table_write_contents_async\
    \ (GHashTable          *table,\n   g_task_set_task_data (task, data, (GDestroyNotify)write_contents_data_free);\n\
    \   g_task_set_source_tag (task, gvdb_table_write_contents_async);\n \n-  g_file_replace_contents_async\
    \ (file, str->str, str->len,\n+  g_file_replace_contents_async (file,\n+     \
    \                            g_bytes_get_data (bytes, NULL),\n+              \
    \                   g_bytes_get_size (bytes),\n                              \
    \    NULL, FALSE,\n                                  G_FILE_CREATE_PRIVATE | G_FILE_CREATE_REPLACE_DESTINATION,\n\
    \                                  cancellable, replace_contents_cb, g_steal_pointer\
    \ (&task));"
  identifiers:
  - CVE-2019-25085
  - CWE-416
  overview: A vulnerability was found in GNOME gvdb. It has been classified as critical.
    This affects the function gvdb_table_write_contents_async of the file gvdb-builder.c.
    The manipulation leads to use after free. It is possible to initiate the attack
    remotely. The name of the patch is d83587b2a364eb9a9a53be7e6a708074e252de14. It
    is recommended to apply a patch to fix this issue. The identifier VDB-216789 was
    assigned to this vulnerability.
  references:
  - source: cna@vuldb.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/GNOME/gvdb/commit/d83587b2a364eb9a9a53be7e6a708074e252de14
  - source: cna@vuldb.com
    tags:
    - Third Party Advisory
    url: https://vuldb.com/?ctiid.216789
  - source: cna@vuldb.com
    tags:
    - Third Party Advisory
    url: https://vuldb.com/?id.216789
  title: A vulnerability was found in GNOME gvdb. It has been classified as critical.
    This affects the function gvdb_table_write_contents_async of the file gvdb-builder.c.
    The manipulation leads to use after free. It is possible to initiate the attack
    remotely. The name of the patch is d83587b2a364eb9a9a53be7e6a708074e252de14. It
    is recommended to apply a patch to fix this issue. The identifier VDB-216789 was
    assigned to this vulnerability.
- diff_content:
  - "--- a/src/HTTPServer.cpp\n+++ b/src/HTTPServer.cpp\n@@ -440,7 +440,7 @@ void\
    \ HTTPServer::handleRequest(Client *cl, HTTPRequest* req) {\n \tstd::cout << \"\
    [\" << cl->getClientIP() << \"] \" << req->methodIntToStr(req->getMethod()) <<\
    \ \" \" << req->getRequestUri() << std::endl;\n \t/*std::cout << \"Headers:\"\
    \ << std::endl;\n \tfor(int i = 0; i < req->getNumHeaders(); i++) {\n-\t\tstd::cout\
    \ << req->getHeaderStr(i) << std::endl;\n+\t\tstd::cout << \"\\t\" << req->getHeaderStr(i)\
    \ << std::endl;\n \t}\n \tstd::cout << std::endl;*/\n "
  - "--- a/src/ResourceHost.cpp\n+++ b/src/ResourceHost.cpp\n@@ -183,6 +183,9 @@ Resource*\
    \ ResourceHost::getResource(std::string uri) {\n \tif (uri.length() > 255 || uri.empty())\n\
    \ \t\treturn NULL;\n \n+\tif (uri.find(\"../\") != std::string::npos)\n+\t\treturn\
    \ NULL;\n+\n \tstd::string path = baseDiskPath + uri;\n \tResource* res = NULL;\n\
    \ "
  identifiers:
  - CVE-2019-25087
  - CWE-22
  overview: 'A vulnerability was found in RamseyK httpserver. It has been rated as
    critical. This issue affects the function ResourceHost::getResource of the file
    src/ResourceHost.cpp of the component URI Handler. The manipulation of the argument
    uri leads to path traversal: ''../filedir''. The attack may be initiated remotely.
    The name of the patch is 1a0de56e4dafff9c2f9c8f6b130a764f7a50df52. It is recommended
    to apply a patch to fix this issue. The associated identifier of this vulnerability
    is VDB-216863.'
  references:
  - source: cna@vuldb.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/RamseyK/httpserver/commit/1a0de56e4dafff9c2f9c8f6b130a764f7a50df52
  - source: cna@vuldb.com
    tags:
    - Third Party Advisory
    url: https://vuldb.com/?ctiid.216863
  - source: cna@vuldb.com
    tags:
    - Third Party Advisory
    url: https://vuldb.com/?id.216863
  title: 'A vulnerability was found in RamseyK httpserver. It has been rated as critical.
    This issue affects the function ResourceHost::getResource of the file src/ResourceHost.cpp
    of the component URI Handler. The manipulation of the argument uri leads to path
    traversal: ''../filedir''. The attack may be initiated remotely. The name of the
    patch is 1a0de56e4dafff9c2f9c8f6b130a764f7a50df52. It is recommended to apply
    a patch to fix this issue. The associated identifier of this vulnerability is
    VDB-216863.'
- diff_content:
  - "--- a/src/main.cpp\n+++ b/src/main.cpp\n@@ -480,9 +480,9 @@ bool CTransaction::CheckTransaction()\
    \ const\n }\n \n \n-bool CTxMemPool::accept(CTxDB& txdb, CTransaction &tx, bool\
    \ fCheckInputs,\n-                        bool* pfMissingInputs)\n-{\n+bool CTxMemPool::accept(CTxDB\
    \ &txdb, CTransaction &tx, bool fCheckInputs,\n+  bool fLimitFree, bool *pfMissingInputs)\
    \ {\n+\n     if (pfMissingInputs)\n         *pfMissingInputs = false;\n \n@@ -566,32\
    \ +566,29 @@ bool CTxMemPool::accept(CTxDB& txdb, CTransaction &tx, bool fCheckInputs,\n\
    \         unsigned int nTxSize = ::GetSerializeSize(tx, SER_NETWORK, PROTOCOL_VERSION);\n\
    \ \n         // Don't accept it if it can't get into a block\n-        if(nFees\
    \ < tx.GetMinFee(nTxSize, true, GMF_RELAY))\n-            return error(\"CTxMemPool::accept()\
    \ : not enough fees\");\n+        if(fLimitFree && (nFees < tx.GetMinFee(nTxSize,\
    \ true, GMF_RELAY)))\n+          return(error(\"CTxMemPool::accept() : not enough\
    \ fees\"));\n \n         // Continuously rate-limit free transactions\n      \
    \   // This mitigates 'penny-flooding' -- sending thousands of free transactions\
    \ just to\n         // be annoying or make other's transactions take longer to\
    \ confirm.\n-        if (nFees < MIN_RELAY_TX_FEE)\n-        {\n-            static\
    \ CCriticalSection cs;\n+        if(fLimitFree && (nFees < MIN_RELAY_TX_FEE))\
    \ {\n             static double dFreeCount;\n             static int64 nLastTime;\n\
    \             int64 nNow = GetTime();\n \n-            {\n-                LOCK(cs);\n\
    -                // Use an exponentially decaying ~10-minute window:\n-      \
    \          dFreeCount *= pow(1.0 - 1.0/600.0, (double)(nNow - nLastTime));\n-\
    \                nLastTime = nNow;\n-                // -limitfreerelay unit is\
    \ thousand-bytes-per-minute\n-                // At default rate it would take\
    \ over a month to fill 1GB\n-                if (dFreeCount > GetArg(\"-limitfreerelay\"\
    , 15)*10*1000 && !IsFromMe(tx))\n-                    return error(\"CTxMemPool::accept()\
    \ : free transaction rejected by rate limiter\");\n-                if (fDebug)\n\
    -                    printf(\"Rate limit dFreeCount: %g => %g\\n\", dFreeCount,\
    \ dFreeCount+nTxSize);\n-                dFreeCount += nTxSize;\n-           \
    \ }\n+            LOCK(cs);\n+\n+            // Use an exponentially decaying\
    \ ~10-minute window:\n+            dFreeCount *= pow(1.0 - 1.0 / 600.0, (double)(nNow\
    \ - nLastTime));\n+            nLastTime = nNow;\n+            // -limitfreerelay\
    \ unit is thousand-bytes-per-minute\n+            // At default rate it would\
    \ take over a month to fill 1GB\n+            if(dFreeCount > GetArg(\"-limitfreerelay\"\
    , 15) * 10 * 1000)\n+              return(error(\"CTxMemPool::accept() : free\
    \ transaction rejected by rate limiter\"));\n+            if(fDebug)\n+      \
    \        printf(\"Rate limit dFreeCount: %g => %g\\n\", dFreeCount, dFreeCount\
    \ + nTxSize);\n+            dFreeCount += nTxSize;\n         }\n \n         //\
    \ Check against previous transactions\n@@ -624,9 +621,10 @@ bool CTxMemPool::accept(CTxDB&\
    \ txdb, CTransaction &tx, bool fCheckInputs,\n     return true;\n }\n \n-bool\
    \ CTransaction::AcceptToMemoryPool(CTxDB& txdb, bool fCheckInputs, bool* pfMissingInputs)\n\
    -{\n-    return mempool.accept(txdb, *this, fCheckInputs, pfMissingInputs);\n\
    +bool CTransaction::AcceptToMemoryPool(CTxDB &txdb, bool fCheckInputs, bool fLimitFree,\n\
    +  bool *pfMissingInputs) {\n+\n+    return mempool.accept(txdb, *this, fCheckInputs,\
    \ fLimitFree, pfMissingInputs);\n }\n \n bool CTxMemPool::addUnchecked(const uint256&\
    \ hash, CTransaction &tx)\n@@ -730,9 +728,9 @@ int CMerkleTx::GetBlocksToMaturity()\
    \ const\n }\n \n \n-bool CMerkleTx::AcceptToMemoryPool(CTxDB &txdb, bool fCheckInputs)\
    \ {\n+bool CMerkleTx::AcceptToMemoryPool(CTxDB &txdb, bool fCheckInputs, bool\
    \ fLimitFree) {\n \n-    return(CTransaction::AcceptToMemoryPool(txdb, fCheckInputs));\n\
    +    return(CTransaction::AcceptToMemoryPool(txdb, fCheckInputs, fLimitFree));\n\
    \ }\n \n bool CMerkleTx::AcceptToMemoryPool()\n@@ -755,10 +753,10 @@ bool CWalletTx::AcceptWalletTransaction(CTxDB&\
    \ txdb, bool fCheckInputs)\n             {\n                 uint256 hash = tx.GetHash();\n\
    \                 if (!mempool.exists(hash) && !txdb.ContainsTx(hash))\n-    \
    \                tx.AcceptToMemoryPool(txdb, fCheckInputs);\n+               \
    \     tx.AcceptToMemoryPool(txdb, fCheckInputs, false);\n             }\n    \
    \     }\n-        return AcceptToMemoryPool(txdb, fCheckInputs);\n+        return(AcceptToMemoryPool(txdb,\
    \ fCheckInputs, false));\n     }\n     return false;\n }\n@@ -1581,7 +1579,7 @@\
    \ bool static Reorganize(CTxDB& txdb, CBlockIndex* pindexNew)\n \n     // Resurrect\
    \ memory transactions that were in the disconnected branch\n     BOOST_FOREACH(CTransaction&\
    \ tx, vResurrect)\n-        tx.AcceptToMemoryPool(txdb, false);\n+      tx.AcceptToMemoryPool(txdb,\
    \ true, false);\n \n     // Delete redundant memory transactions that are in the\
    \ connected branch\n     BOOST_FOREACH(CTransaction &tx, vDelete) {\n@@ -3022,8\
    \ +3020,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream&\
    \ vRecv)\n         }\n \n         bool fMissingInputs = false;\n-        if (tx.AcceptToMemoryPool(txdb,\
    \ true, &fMissingInputs))\n-        {\n+        if(tx.AcceptToMemoryPool(txdb,\
    \ true, true, &fMissingInputs)) {\n             SyncWithWallets(tx, NULL, true);\n\
    \             RelayMessage(inv, vMsg);\n             mapAlreadyAskedFor.erase(inv);\n\
    @@ -3044,20 +3041,18 @@ bool static ProcessMessage(CNode* pfrom, string strCommand,\
    \ CDataStream& vRecv)\n                     CInv inv(MSG_TX, tx.GetHash());\n\
    \                     bool fMissingInputs2 = false;\n \n-                    if\
    \ (tx.AcceptToMemoryPool(txdb, true, &fMissingInputs2))\n-                   \
    \ {\n+                    if(tx.AcceptToMemoryPool(txdb, true, true, &fMissingInputs2))\
    \ {\n                         printf(\"   accepted orphan tx %s\\n\", inv.hash.ToString().substr(0,10).c_str());\n\
    \                         SyncWithWallets(tx, NULL, true);\n                 \
    \        RelayMessage(inv, vMsg);\n                         mapAlreadyAskedFor.erase(inv);\n\
    \                         vWorkQueue.push_back(inv.hash);\n                  \
    \       vEraseQueue.push_back(inv.hash);\n                     }\n-          \
    \          else if (!fMissingInputs2)\n-                    {\n-             \
    \           // invalid orphan\n+                    else if(!fMissingInputs2)\
    \ {\n+                        /* Invalid or insufficient fee orphan */\n     \
    \                    vEraseQueue.push_back(inv.hash);\n-                     \
    \   printf(\"   removed invalid orphan tx %s\\n\", inv.hash.ToString().substr(0,10).c_str());\n\
    +                        printf(\"   removed orphan tx %s\\n\", inv.hash.ToString().substr(0,10).c_str());\n\
    \                     }\n                 }\n             }"
  - "--- a/src/rpcrawtransaction.cpp\n+++ b/src/rpcrawtransaction.cpp\n@@ -494,8 +494,8\
    \ @@ Value sendrawtransaction(const Array& params, bool fHelp)\n     {\n     \
    \    // push to local node\n         CTxDB txdb(\"r\");\n-        if (!tx.AcceptToMemoryPool(txdb))\n\
    -            throw JSONRPCError(-22, \"TX rejected\");\n+        if(!tx.AcceptToMemoryPool(txdb,\
    \ true, false))\n+          throw(JSONRPCError(-22, \"TX rejected\"));\n \n  \
    \       SyncWithWallets(tx, NULL, true);\n     }"
  - "--- a/src/wallet.cpp\n+++ b/src/wallet.cpp\n@@ -1251,8 +1251,8 @@ bool CWallet::CommitTransaction(CWalletTx&\
    \ wtxNew, CReserveKey& reservekey)\n         mapRequestCount[wtxNew.GetHash()]\
    \ = 0;\n \n         // Broadcast\n-        if (!wtxNew.AcceptToMemoryPool())\n\
    -        {\n+        CTxDB txdb(\"r\");\n+        if(!wtxNew.AcceptToMemoryPool(txdb,\
    \ true, false)) {\n             // This must not fail. The transaction has already\
    \ been signed and recorded.\n             printf(\"CommitTransaction() : Error:\
    \ Transaction not valid\");\n             return false;"
  identifiers:
  - CVE-2017-20154
  - CWE-404
  overview: A vulnerability was found in ghostlander Phoenixcoin. It has been classified
    as problematic. Affected is the function CTxMemPool::accept of the file src/main.cpp.
    The manipulation leads to denial of service. Upgrading to version 0.6.6.1-pxc
    is able to address this issue. The name of the patch is 987dd68f71a7d8276cef3b6c3d578fd4845b5699.
    It is recommended to upgrade the affected component. The identifier of this vulnerability
    is VDB-217068.
  references:
  - source: cna@vuldb.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/ghostlander/Phoenixcoin/commit/987dd68f71a7d8276cef3b6c3d578fd4845b5699
  - source: cna@vuldb.com
    tags:
    - Release Notes
    - Third Party Advisory
    url: https://github.com/ghostlander/Phoenixcoin/releases/tag/v0.6.6.1-pxc
  - source: cna@vuldb.com
    tags:
    - Third Party Advisory
    url: https://vuldb.com/?ctiid.217068
  - source: cna@vuldb.com
    tags:
    - Third Party Advisory
    url: https://vuldb.com/?id.217068
  title: A vulnerability was found in ghostlander Phoenixcoin. It has been classified
    as problematic. Affected is the function CTxMemPool::accept of the file src/main.cpp.
    The manipulation leads to denial of service. Upgrading to version 0.6.6.1-pxc
    is able to address this issue. The name of the patch is 987dd68f71a7d8276cef3b6c3d578fd4845b5699.
    It is recommended to upgrade the affected component. The identifier of this vulnerability
    is VDB-217068.
- diff_content:
  - "--- a/net/xfrm/xfrm_user.c\n+++ b/net/xfrm/xfrm_user.c\n@@ -1553,31 +1553,33\
    \ @@ static int dump_one_policy(struct xfrm_policy *xp, int dir, int count, void\
    \ *ptr\n \n static int xfrm_dump_policy_done(struct netlink_callback *cb)\n {\n\
    -\tstruct xfrm_policy_walk *walk = (struct xfrm_policy_walk *) &cb->args[1];\n\
    +\tstruct xfrm_policy_walk *walk = (struct xfrm_policy_walk *)cb->args;\n \n \t\
    xfrm_policy_walk_done(walk);\n \treturn 0;\n }\n \n+static int xfrm_dump_policy_start(struct\
    \ netlink_callback *cb)\n+{\n+\tstruct xfrm_policy_walk *walk = (struct xfrm_policy_walk\
    \ *)cb->args;\n+\n+\tBUILD_BUG_ON(sizeof(*walk) > sizeof(cb->args));\n+\n+\txfrm_policy_walk_init(walk,\
    \ XFRM_POLICY_TYPE_ANY);\n+\treturn 0;\n+}\n+\n static int xfrm_dump_policy(struct\
    \ sk_buff *skb, struct netlink_callback *cb)\n {\n \tstruct net *net = sock_net(skb->sk);\n\
    -\tstruct xfrm_policy_walk *walk = (struct xfrm_policy_walk *) &cb->args[1];\n\
    +\tstruct xfrm_policy_walk *walk = (struct xfrm_policy_walk *)cb->args;\n \tstruct\
    \ xfrm_dump_info info;\n \n-\tBUILD_BUG_ON(sizeof(struct xfrm_policy_walk) >\n\
    -\t\t     sizeof(cb->args) - sizeof(cb->args[0]));\n-\n \tinfo.in_skb = cb->skb;\n\
    \ \tinfo.out_skb = skb;\n \tinfo.nlmsg_seq = cb->nlh->nlmsg_seq;\n \tinfo.nlmsg_flags\
    \ = NLM_F_MULTI;\n \n-\tif (!cb->args[0]) {\n-\t\tcb->args[0] = 1;\n-\t\txfrm_policy_walk_init(walk,\
    \ XFRM_POLICY_TYPE_ANY);\n-\t}\n-\n \t(void) xfrm_policy_walk(net, walk, dump_one_policy,\
    \ &info);\n \n \treturn skb->len;\n@@ -2341,6 +2343,7 @@ static const struct nla_policy\
    \ xfrma_policy[XFRMA_MAX+1] = {\n \n static const struct xfrm_link {\n \tint (*doit)(struct\
    \ sk_buff *, struct nlmsghdr *, struct nlattr **);\n+\tint (*start)(struct netlink_callback\
    \ *);\n \tint (*dump)(struct sk_buff *, struct netlink_callback *);\n \tint (*done)(struct\
    \ netlink_callback *);\n } xfrm_dispatch[XFRM_NR_MSGTYPES] = {\n@@ -2352,6 +2355,7\
    \ @@ static const struct xfrm_link {\n \t[XFRM_MSG_NEWPOLICY   - XFRM_MSG_BASE]\
    \ = { .doit = xfrm_add_policy    },\n \t[XFRM_MSG_DELPOLICY   - XFRM_MSG_BASE]\
    \ = { .doit = xfrm_get_policy    },\n \t[XFRM_MSG_GETPOLICY   - XFRM_MSG_BASE]\
    \ = { .doit = xfrm_get_policy,\n+\t\t\t\t\t\t   .start = xfrm_dump_policy_start,\n\
    \ \t\t\t\t\t\t   .dump = xfrm_dump_policy,\n \t\t\t\t\t\t   .done = xfrm_dump_policy_done\
    \ },\n \t[XFRM_MSG_ALLOCSPI    - XFRM_MSG_BASE] = { .doit = xfrm_alloc_userspi\
    \ },\n@@ -2395,6 +2399,7 @@ static int xfrm_user_rcv_msg(struct sk_buff *skb,\
    \ struct nlmsghdr *nlh)\n \n \t\t{\n \t\t\tstruct netlink_dump_control c = {\n\
    +\t\t\t\t.start = link->start,\n \t\t\t\t.dump = link->dump,\n \t\t\t\t.done =\
    \ link->done,\n \t\t\t};"
  identifiers:
  - CVE-2018-25062
  - CWE-404
  overview: A vulnerability classified as problematic has been found in flar2 ElementalX
    up to 6.x on Nexus 9. Affected is the function xfrm_dump_policy_done of the file
    net/xfrm/xfrm_user.c of the component ipsec. The manipulation leads to denial
    of service. Upgrading to version 7.00 is able to address this issue. The name
    of the patch is 1df72c9f0f61304437f4f1037df03b5fb36d5a79. It is recommended to
    upgrade the affected component. The identifier of this vulnerability is VDB-217152.
  references:
  - source: cna@vuldb.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/flar2/ElementalX-N9/commit/1df72c9f0f61304437f4f1037df03b5fb36d5a79
  - source: cna@vuldb.com
    tags:
    - Third Party Advisory
    url: https://vuldb.com/?ctiid.217152
  - source: cna@vuldb.com
    tags:
    - Third Party Advisory
    url: https://vuldb.com/?id.217152
  title: A vulnerability classified as problematic has been found in flar2 ElementalX
    up to 6.x on Nexus 9. Affected is the function xfrm_dump_policy_done of the file
    net/xfrm/xfrm_user.c of the component ipsec. The manipulation leads to denial
    of service. Upgrading to version 7.00 is able to address this issue. The name
    of the patch is 1df72c9f0f61304437f4f1037df03b5fb36d5a79. It is recommended to
    upgrade the affected component. The identifier of this vulnerability is VDB-217152.
- diff_content:
  - "--- a/src/bitcoinrpc.cpp\n+++ b/src/bitcoinrpc.cpp\n@@ -479,7 +479,7 @@ bool\
    \ HTTPAuthorized(map<string, string>& mapHeaders)\n         return false;\n  \
    \   string strUserPass64 = strAuth.substr(6); boost::trim(strUserPass64);\n  \
    \   string strUserPass = DecodeBase64(strUserPass64);\n-    return strUserPass\
    \ == strRPCUserColonPass;\n+    return TimingResistantEqual(strUserPass, strRPCUserColonPass);\n\
    \ }\n \n //"
  - "--- a/src/test/util_tests.cpp\n+++ b/src/test/util_tests.cpp\n@@ -323,4 +323,15\
    \ @@ BOOST_AUTO_TEST_CASE(util_seed_insecure_rand)\n     }\n }\n \n+BOOST_AUTO_TEST_CASE(util_TimingResistantEqual)\n\
    +{\n+    BOOST_CHECK(TimingResistantEqual(std::string(\"\"), std::string(\"\"\
    )));\n+    BOOST_CHECK(!TimingResistantEqual(std::string(\"abc\"), std::string(\"\
    \")));\n+    BOOST_CHECK(!TimingResistantEqual(std::string(\"\"), std::string(\"\
    abc\")));\n+    BOOST_CHECK(!TimingResistantEqual(std::string(\"a\"), std::string(\"\
    aa\")));\n+    BOOST_CHECK(!TimingResistantEqual(std::string(\"aa\"), std::string(\"\
    a\")));\n+    BOOST_CHECK(TimingResistantEqual(std::string(\"abc\"), std::string(\"\
    abc\")));\n+    BOOST_CHECK(!TimingResistantEqual(std::string(\"abc\"), std::string(\"\
    aba\")));\n+}\n+\n BOOST_AUTO_TEST_SUITE_END()"
  identifiers:
  - CVE-2013-10006
  - CWE-208
  overview: A vulnerability classified as problematic was found in Ziftr primecoin
    up to 0.8.4rc1. Affected by this vulnerability is the function HTTPAuthorized
    of the file src/bitcoinrpc.cpp. The manipulation of the argument strUserPass/strRPCUserColonPass
    leads to observable timing discrepancy. The complexity of an attack is rather
    high. The exploitation appears to be difficult. Upgrading to version 0.8.4rc2
    is able to address this issue. The patch is named cdb3441b5cd2c1bae49fae671dc4a496f7c96322.
    It is recommended to upgrade the affected component. The associated identifier
    of this vulnerability is VDB-217171.
  references:
  - source: cna@vuldb.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/Ziftr/primecoin/commit/cdb3441b5cd2c1bae49fae671dc4a496f7c96322
  - source: cna@vuldb.com
    tags:
    - Release Notes
    - Third Party Advisory
    url: https://github.com/Ziftr/primecoin/releases/tag/v0.8.4rc2
  - source: cna@vuldb.com
    tags:
    - Permissions Required
    - Third Party Advisory
    url: https://vuldb.com/?ctiid.217171
  - source: cna@vuldb.com
    tags:
    - Permissions Required
    - Third Party Advisory
    url: https://vuldb.com/?id.217171
  title: A vulnerability classified as problematic was found in Ziftr primecoin up
    to 0.8.4rc1. Affected by this vulnerability is the function HTTPAuthorized of
    the file src/bitcoinrpc.cpp. The manipulation of the argument strUserPass/strRPCUserColonPass
    leads to observable timing discrepancy. The complexity of an attack is rather
    high. The exploitation appears to be difficult. Upgrading to version 0.8.4rc2
    is able to address this issue. The patch is named cdb3441b5cd2c1bae49fae671dc4a496f7c96322.
    It is recommended to upgrade the affected component. The associated identifier
    of this vulnerability is VDB-217171.
- diff_content:
  - "--- a/main.c\n+++ b/main.c\n@@ -91,8 +91,10 @@ static unsigned char scrambleAsciiTables[16][256];\n\
    \ static unsigned char unscrambleAsciiTables[16][256];\n static char isCrypting\
    \ = 1;\n static char scrambling = 1;\n+static char usingKeyFile = 0;\n static\
    \ char isCodingInverted = 0;\n static long numberOfBuffer;\n+static char scramblingTablesOrder[BUFFER_SIZE];\n\
    \ \n char passPhrase[16384];\n uint64_t passIndex = 0;\n@@ -109,10 +111,10 @@\
    \ static void usage(int status)\n \n \tif(status == 0){\n \t\tfprintf(dest,\n\
    -\t\t\t\"%s(1)\\t\\t\\tcopyright <Pierre-Fran\xE7ois Monville>\\t\\t\\t%s(1)\\\
    n\\nNAME\\n\\t%s -- crypt or decrypt any data\\n\\nSYNOPSIS\\n\\t%s [-h | --help]\
    \ FILE [-s | --standard | KEYFILE]\\n\\nDESCRIPTION\\n\\t(FR) permet de chiffrer\
    \ et de d\xE9chiffrer toutes les donn\xE9es entr\xE9es en param\xE8tre le mot\
    \ de passe demand\xE9 au d\xE9but est hash\xE9 puis sert de graine pour le PRNG\
    \ le PRNG permet de fournir une cl\xE9 unique \xE9gale \xE0 la longueur du fichier\
    \ \xE0 coder. La cl\xE9 unique subit un xor avec le mot de passe (le mot de passe\
    \ est r\xE9p\xE9t\xE9 autant de fois que n\xE9c\xE9ssaire). Le fichier subit un\
    \ xor avec cette cl\xE9 Puis un brouilleur est utilis\xE9, il m\xE9lange la table\
    \ des caract\xE8res (ascii) en utilisant le PRNG ou en utilisant le keyFile fourni.\\\
    n\\t(EN) Can crypt and decrypt any data given in argument. The password asked\
    \ is hashed to be used as a seed for the PRNG. The PRNG gives a unique key which\
    \ has the same length as the source file. The key is xored with the password (the\
    \ password is repeated as long as necessary). The file is then xored with this\
    \ new key, then a scrambler is used. It scrambles the ascii table using the PRNG\
    \ or the keyFile given\\n\\nOPTIONS\\n\\tthe options are as follows:\\n\\n\\t-h\
    \ | --help\\tfurther help.\\n\\n\\t-s | --standard\\tput the scrambler on off.\\\
    n\\n\\t-i | --inverted\\tinverts the coding/decoding process, first it xors then\
    \ it scrambles.\\n\\nEXIT STATUS\\n\\tthe %s program exits 0 on success, and anything\
    \ else if an error occurs.\\n\\nEXAMPLES\\n\\tthe command:\\t%s file1\\n\\n\\\
    tlets you choose between crypting or decrypting then it will prompt for a password\
    \ that crypt/decrypt file1 as xfile1 in the same folder, file1 is not modified.\\\
    n\\n\\tthe command:\\t%s file2 keyfile1\\n\\n\\tlets you choose between crypting\
    \ or decrypting, will prompt for the password that crypt/decrypt file2, uses keyfile1\
    \ to generate the scrambler then crypt/decrypt file2 as file2x in the same folder,\
    \ file2 is not modified.\\n\\n\\tthe command:\\t%s file3 -s\\n\\n\\tlets you choose\
    \ between crypting or decrypting, will prompt for a password that crypt/decrypt\
    \ the file without using the scrambler, resulting in using the unique key only.\\\
    n\", progName, progName, progName, progName, progName, progName, progName, progName);\n\
    +\t\t\t\"%s(1)\\t\\t\\tcopyright <Pierre-Fran\xE7ois Monville>\\t\\t\\t%s(1)\\\
    n\\nNAME\\n\\t%s -- crypt or decrypt any data\\n\\nSYNOPSIS\\n\\t%s [-h | --help]\
    \ FILE [-s | --standard | KEYFILE]\\n\\nDESCRIPTION\\n\\t(FR) permet de chiffrer\
    \ et de d\xE9chiffrer toutes les donn\xE9es entr\xE9es en param\xE8tre le mot\
    \ de passe demand\xE9 au d\xE9but est hash\xE9 puis sert de graine pour le PRNG\
    \ le PRNG permet de fournir une cl\xE9 unique \xE9gale \xE0 la longueur du fichier\
    \ \xE0 coder. La cl\xE9 unique subit un xor avec le mot de passe (le mot de passe\
    \ est r\xE9p\xE9t\xE9 autant de fois que n\xE9c\xE9ssaire). Le fichier subit un\
    \ xor avec cette cl\xE9 Puis un brouilleur est utilis\xE9, il m\xE9lange la table\
    \ des caract\xE8res (ascii) en utilisant le PRNG ou en utilisant le keyFile fourni.\\\
    n\\t(EN) Can crypt and decrypt any data given in argument. The password asked\
    \ is hashed to be used as a seed for the PRNG. The PRNG gives a unique key which\
    \ has the same length as the source file. The key is xored with the password (the\
    \ password is repeated as long as necessary). The file is then xored with this\
    \ new key, then a scrambler is used. It scrambles the ascii table using the PRNG\
    \ or the keyFile given\\n\\nOPTIONS\\n\\tthe options are as follows:\\n\\n\\t-h\
    \ | --help\\tfurther help.\\n\\n\\t-s | --standard\\tput the scrambler on off.\\\
    n\\n\\t-i | --inverted\\tinverts the coding/decoding process, first it xors then\
    \ it scrambles.\\n\\n\\tKEYFILE    \\tthe path to a file which will be used to\
    \ scramble the substitution's tables and choose in which order they will be used\
    \ instead of the PRNG only (starting at 2.5 ko for the keyfile is great, however\
    \ not interesting to be too heavy) \\n\\nEXIT STATUS\\n\\tthe %s program exits\
    \ 0 on success, and anything else if an error occurs.\\n\\nEXAMPLES\\n\\tthe command:\\\
    t%s file1\\n\\n\\tlets you choose between crypting or decrypting then it will\
    \ prompt for a password that crypt/decrypt file1 as xfile1 in the same folder,\
    \ file1 is not modified.\\n\\n\\tthe command:\\t%s file2 keyfile1\\n\\n\\tlets\
    \ you choose between crypting or decrypting, will prompt for the password that\
    \ crypt/decrypt file2, uses keyfile1 to generate the scrambler then crypt/decrypt\
    \ file2 as file2x in the same folder, file2 is not modified.\\n\\n\\tthe command:\\\
    t%s file3 -s\\n\\n\\tlets you choose between crypting or decrypting, will prompt\
    \ for a password that crypt/decrypt the file without using the scrambler, resulting\
    \ in using the unique key only.\\n\", progName, progName, progName, progName,\
    \ progName, progName, progName, progName);\n \t} else{\n \t\tfprintf(dest,\n-\t\
    \t\t\"Usage : %s [-h | --help] FILE [-s | --standard | -i | --inverted] [KEYFILE]\\\
    nOptions :\\n  -h --help :\\t\\tfurther help\\n  -s --standard :\\tput the scrambler\
    \ off\\n  -i --inverted :\\tinverts the coding/decoding process\\n  KEYFILE :\\\
    t\\tpath to a keyfile that generates the scrambler instead of the password\\n\"\
    , progName);\n+\t\t\t\"Version : 2.3\\nUsage : %s [-h | --help] FILE [-s | --standard\
    \ | -i | --inverted] [KEYFILE]\\nOptions :\\n  -h --help :\\t\\tfurther help\\\
    n  -s --standard :\\tput the scrambler off\\n  -i --inverted :\\tinverts the coding/decoding\
    \ process\\n  KEYFILE :\\t\\tpath to a keyfile that scrambles the substitution's\
    \ tables and choose they order instead of the PRNG only\\n\", progName);\n \t\
    }\n \texit(status);\n }\n@@ -316,6 +318,7 @@ void getSeed(char* password){\n \t\
    have been switched\n  */\n void scramble(FILE* keyFile){\n+\tprintf(\"scrambling\
    \ substitution's tables...\\n\");\n \tfor (int j = 0; j < 16; ++j)\n \t{\n \t\t\
    char temp = 0;\n@@ -325,15 +328,17 @@ void scramble(FILE* keyFile){\n \t\t\tscrambleAsciiTables[j][i]\
    \ = i;\n \t\t}\n \n-\t\tif (keyFile != NULL){\n+\t\tif (usingKeyFile){\n \t\t\t\
    int size;\n \t\t\tchar extractedString[BUFFER_SIZE] = \"\";\n+\t\t\tunsigned char\
    \ random256;\n \t\t\twhile((size = fread(extractedString, 1, BUFFER_SIZE, keyFile))\
    \ > 0){\n \t\t\t\tfor (int i = 0; i < size; ++i)\n \t\t\t\t{\n+\t\t\t\t\trandom256\
    \ = generateNumber() ^ extractedString[i];\n \t\t\t\t\ttemp = scrambleAsciiTables[j][i%256];\n\
    -\t\t\t\t\tscrambleAsciiTables[j][i%256] = scrambleAsciiTables[j][(unsigned char)(extractedString[i])];\n\
    -\t\t\t\t\tscrambleAsciiTables[j][(unsigned char)(extractedString[i])] = temp;\n\
    +\t\t\t\t\tscrambleAsciiTables[j][i%256] = scrambleAsciiTables[j][random256];\n\
    +\t\t\t\t\tscrambleAsciiTables[j][random256] = temp;\n \t\t\t\t}\n \t\t\t}\n \t\
    \t\trewind(keyFile);\n@@ -350,6 +355,25 @@ void scramble(FILE* keyFile){\n \t\t\
    \t}\n \t\t}\n \t}\n+\tif(usingKeyFile){\n+\t\tint j = 0;\n+\t\tchar temp[BUFFER_SIZE];\n\
    +\t\twhile(j < BUFFER_SIZE){\n+\t\t\tint charactersRead = fread(temp, 1, BUFFER_SIZE,\
    \ keyFile);\n+\t\t\tif(charactersRead == 0){\n+\t\t\t\trewind(keyFile);\n+\t\t\
    \t\tcontinue;\n+\t\t\t}\n+\t\t\tfor (int i = 0; i < charactersRead; ++i)\n+\t\t\
    \t{\n+\t\t\t\tscramblingTablesOrder[j] = temp[i] & (1+2+4+8);\n+\t\t\t\tj++;\n\
    +\t\t\t\tif(j == BUFFER_SIZE){\n+\t\t\t\t\tbreak;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\
    }\n+\t}\n }\n \n \n@@ -393,16 +417,23 @@ void unscramble(){\n void codingXOR(char*\
    \ extractedString, char* keyString, char* xoredString, int bufferLength)\n {\n\
    \ \tint i;\n+\tchar* tablenumber;\n+\n+\tif(usingKeyFile){\n+\t\ttablenumber =\
    \ scramblingTablesOrder;\n+\t}else{\n+\t\ttablenumber = keyString;\n+\t}\n \n\
    \ \tif(isCodingInverted){\n \t\tfor (i = 0; i < bufferLength; ++i)\n \t\t{\n-\t\
    \t\txoredString[i] = scrambleAsciiTables[keyString[i] & (1+2+4+8)][(unsigned char)(extractedString[i]\
    \ ^ keyString[i])];\n+\t\t\txoredString[i] = scrambleAsciiTables[tablenumber[i]\
    \ & (1+2+4+8)][(unsigned char)(extractedString[i] ^ keyString[i])];\n \t\t}\n\
    \ \t}else{\n \t\tfor (i = 0; i < bufferLength; ++i)\n \t\t{\n-\t\t\txoredString[i]\
    \ = scrambleAsciiTables[keyString[i] & (1+2+4+8)][(unsigned char)extractedString[i]]\
    \ ^ keyString[i];\n+\t\t\txoredString[i] = scrambleAsciiTables[tablenumber[i]\
    \ & (1+2+4+8)][(unsigned char)extractedString[i]] ^ keyString[i];\n \t\t}\n \t\
    }\n }\n@@ -426,16 +457,23 @@ void codingXOR(char* extractedString, char* keyString,\
    \ char* xoredString, int bu\n void decodingXOR(char* extractedString, char* keyString,\
    \ char* xoredString, int bufferLength)\n {\n \tint i;\n+\tchar* tablenumber;\n\
    +\n+\tif(usingKeyFile){\n+\t\ttablenumber = scramblingTablesOrder;\n+\t}else{\n\
    +\t\ttablenumber = keyString;\n+\t}\n \n \tif(isCodingInverted){\n \t\tfor (i\
    \ = 0; i < bufferLength; ++i)\n \t\t{\n-\t\t\txoredString[i] = unscrambleAsciiTables[keyString[i]\
    \ & (1+2+4+8)][(unsigned char)extractedString[i]] ^ keyString[i];\n+\t\t\txoredString[i]\
    \ = unscrambleAsciiTables[tablenumber[i] & (1+2+4+8)][(unsigned char)extractedString[i]]\
    \ ^ keyString[i];\n \t\t}\n \t}else{\n \t\tfor (i = 0; i < bufferLength; ++i)\n\
    \ \t\t{\n-\t\t\txoredString[i] = unscrambleAsciiTables[keyString[i] & (1+2+4+8)][(unsigned\
    \ char)(extractedString[i] ^ keyString[i])];\n+\t\t\txoredString[i] = unscrambleAsciiTables[tablenumber[i]\
    \ & (1+2+4+8)][(unsigned char)(extractedString[i] ^ keyString[i])];\n \t\t}\n\
    \ \t}\n }\n@@ -475,7 +513,7 @@ void standardXOR(char* extractedString, char* keyString,\
    \ char* xoredString, int\n \tmainFile : pointer to the file given by the user\n\
    \ \textractedString : will contains the data extracted from the source file in\
    \ a string format\n \tkeyString : will contains a part of the unique key in a\
    \ string format\n-\treturned value : the size of the data reed\n+\treturned value\
    \ : the size of the data read\n \n \tread a packet of data from the source file\n\
    \ \treturn the length of the packet which is the buffer size (BUFFER_SIZE)\n@@\
    \ -782,6 +820,10 @@ int main(int argc, char const *argv[])\n \t\t\tprintf(\"Error:\
    \ Too many arguments\\n\");\n \t\t\tusage(1);\n \t\t}\n+\n+\t\tif(keyFile != NULL){\n\
    +\t\t\tusingKeyFile = 1;\n+\t\t}\n \t\t\n \t}\n "
  identifiers:
  - CVE-2016-15006
  - CWE-337
  overview: A vulnerability, which was classified as problematic, has been found in
    enigmaX up to 2.2. This issue affects the function getSeed of the file main.c
    of the component Scrambling Table Handler. The manipulation leads to predictable
    seed in pseudo-random number generator (prng). The attack may be initiated remotely.
    The complexity of an attack is rather high. The exploitation is known to be difficult.
    Upgrading to version 2.3 is able to address this issue. The identifier of the
    patch is 922bf90ca14a681629ba0b807a997a81d70225b5. It is recommended to upgrade
    the affected component. The identifier VDB-217181 was assigned to this vulnerability.
  references:
  - source: cna@vuldb.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/pfmonville/enigmaX/commit/922bf90ca14a681629ba0b807a997a81d70225b5
  - source: cna@vuldb.com
    tags:
    - Release Notes
    - Third Party Advisory
    url: https://github.com/pfmonville/enigmaX/releases/tag/2.3
  - source: cna@vuldb.com
    tags:
    - Third Party Advisory
    url: https://vuldb.com/?ctiid.217181
  - source: cna@vuldb.com
    tags:
    - Third Party Advisory
    url: https://vuldb.com/?id.217181
  title: A vulnerability, which was classified as problematic, has been found in enigmaX
    up to 2.2. This issue affects the function getSeed of the file main.c of the component
    Scrambling Table Handler. The manipulation leads to predictable seed in pseudo-random
    number generator (prng). The attack may be initiated remotely. The complexity
    of an attack is rather high. The exploitation is known to be difficult. Upgrading
    to version 2.3 is able to address this issue. The identifier of the patch is 922bf90ca14a681629ba0b807a997a81d70225b5.
    It is recommended to upgrade the affected component. The identifier VDB-217181
    was assigned to this vulnerability.
- diff_content:
  - "--- a/macgeiger.c\n+++ b/macgeiger.c\n@@ -563,6 +563,19 @@ static void dump_wlan_info(unsigned\
    \ wlanidx) {\n \tunlock();\n }\n \n+static void sanitize_string(char *s, char\
    \ *new) {\n+\tsize_t i,j, l = strlen(s), ls=l;\n+\tfor(i=0,j=0;i<ls;i++) {\n+\t\
    \tif(s[i] < ' ' || s[i] > 127) {\n+\t\t\tsprintf(new + j, \"\\\\x%02x\", s[i]\
    \ & 0xff);\n+\t\t\tj  += 3;\n+\t\t} else new[j] = s[i];\n+\t\tj++;\n+\t}\n+\t\
    new[j] = 0;\n+}\n+\n+\n static void dump_wlan_at(unsigned wlanidx, unsigned line)\
    \ {\n \tconsole_goto(t, 0, line);\n \tconsole_setcolor(t, 0, BGCOL);\n@@ -588,9\
    \ +601,11 @@ static void dump_wlan_at(unsigned wlanidx, unsigned line) {\n \n\
    \ \tchar macbuf[18];\n \n-\tif(*w->essid)\n-\t\tconsole_printf(t, \"%*s\", ESSID_PRINT_LEN,\
    \ w->essid);\n-\telse\n+\tif(*w->essid) {\n+\t\tchar essid_san[32*4+1];\n+\t\t\
    sanitize_string(w->essid, essid_san);\n+\t\tconsole_printf(t, \"%*s\", ESSID_PRINT_LEN,\
    \ essid_san);\n+\t} else\n \t\tconsole_printf(t, \"<hidden> %*s\", ESSID_PRINT_LEN-9,\
    \ mac2str(w->mac, macbuf));\n \n \tconsole_goto(t, ESSID_PRINT_END +1, line);"
  identifiers:
  - CVE-2017-20161
  - CWE-74
  overview: A vulnerability classified as problematic has been found in rofl0r MacGeiger.
    Affected is the function dump_wlan_at of the file macgeiger.c of the component
    ESSID Handler. The manipulation leads to injection. Access to the local network
    is required for this attack to succeed. The complexity of an attack is rather
    high. The exploitability is told to be difficult. The name of the patch is 57f1dd50a4821b8c8e676e8020006ae4bfd3c9cb.
    It is recommended to apply a patch to fix this issue. The identifier of this vulnerability
    is VDB-217188.
  references:
  - source: cna@vuldb.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/rofl0r/MacGeiger/commit/57f1dd50a4821b8c8e676e8020006ae4bfd3c9cb
  - source: cna@vuldb.com
    tags:
    - Third Party Advisory
    url: https://vuldb.com/?ctiid.217188
  - source: cna@vuldb.com
    tags:
    - Permissions Required
    - Third Party Advisory
    url: https://vuldb.com/?id.217188
  title: A vulnerability classified as problematic has been found in rofl0r MacGeiger.
    Affected is the function dump_wlan_at of the file macgeiger.c of the component
    ESSID Handler. The manipulation leads to injection. Access to the local network
    is required for this attack to succeed. The complexity of an attack is rather
    high. The exploitability is told to be difficult. The name of the patch is 57f1dd50a4821b8c8e676e8020006ae4bfd3c9cb.
    It is recommended to apply a patch to fix this issue. The identifier of this vulnerability
    is VDB-217188.
- diff_content:
  - "--- a/src/buffer.c\n+++ b/src/buffer.c\n@@ -4617,6 +4617,8 @@ build_stl_str_hl(\n\
    \ #endif\n \tif (vim_strchr(STL_ALL, *s) == NULL)\n \t{\n+\t    if (*s == NUL)\
    \  // can happen with \"%0\"\n+\t\tbreak;\n \t    s++;\n \t    continue;\n \t}"
  - "--- a/src/version.c\n+++ b/src/version.c\n@@ -695,6 +695,8 @@ static char *(features[])\
    \ =\n \n static int included_patches[] =\n {   /* Add new patch number below this\
    \ line */\n+/**/\n+    1143,\n /**/\n     1142,\n /**/"
  identifiers:
  - CVE-2023-0049
  - CWE-125
  overview: Out-of-bounds Read in GitHub repository vim/vim prior to 9.0.1143.
  references:
  - source: security@huntr.dev
    url: http://seclists.org/fulldisclosure/2023/Mar/17
  - source: security@huntr.dev
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/vim/vim/commit/7b17eb4b063a234376c1ec909ee293e42cff290c
  - source: security@huntr.dev
    tags:
    - Exploit
    - Third Party Advisory
    url: https://huntr.dev/bounties/5e6f325c-ba54-4bf0-b050-dca048fd3fd9
  - source: security@huntr.dev
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/3Y752EAVACVC5XY2TMGGOAIU25VQRPDW/
  - source: security@huntr.dev
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/T33LLWHLH63XDCO5OME7NWN63RA4U5HF/
  - source: security@huntr.dev
    url: https://security.gentoo.org/glsa/202305-16
  - source: security@huntr.dev
    url: https://support.apple.com/kb/HT213670
  title: Out-of-bounds Read in GitHub repository vim/vim prior to 9.0.1143.
- diff_content:
  - "--- a/src/message.c\n+++ b/src/message.c\n@@ -3055,7 +3055,8 @@ msg_puts_printf(char_u\
    \ *str, int maxlen)\n     {\n \tchar_u *tofree = NULL;\n \n-\tif (maxlen > 0 &&\
    \ STRLEN(p) > (size_t)maxlen)\n+\tif (maxlen > 0 && vim_strlen_maxlen((char *)p,\
    \ (size_t)maxlen)\n+\t\t\t\t\t\t\t     >= (size_t)maxlen)\n \t{\n \t    tofree\
    \ = vim_strnsave(p, (size_t)maxlen);\n \t    p = tofree;"
  - "--- a/src/strings.c\n+++ b/src/strings.c\n@@ -525,6 +525,19 @@ vim_strcat(char_u\
    \ *to, char_u *from, size_t tosize)\n \tmch_memmove(to + tolen, from, fromlen\
    \ + 1);\n }\n \n+/*\n+ * A version of strlen() that has a maximum length.\n+ */\n\
    +    size_t\n+vim_strlen_maxlen(char *s, size_t maxlen)\n+{\n+    size_t i;\n\
    +    for (i = 0; i < maxlen; ++i)\n+\tif (s[i] == NUL)\n+\t    break;\n+    return\
    \ i;\n+}\n+\n #if (!defined(HAVE_STRCASECMP) && !defined(HAVE_STRICMP)) || defined(PROTO)\n\
    \ /*\n  * Compare two strings, ignoring case, using current locale."
  - "--- a/src/version.c\n+++ b/src/version.c\n@@ -695,6 +695,8 @@ static char *(features[])\
    \ =\n \n static int included_patches[] =\n {   /* Add new patch number below this\
    \ line */\n+/**/\n+    1144,\n /**/\n     1143,\n /**/"
  identifiers:
  - CVE-2023-0051
  - CWE-122
  overview: Heap-based Buffer Overflow in GitHub repository vim/vim prior to 9.0.1144.
  references:
  - source: security@huntr.dev
    url: http://seclists.org/fulldisclosure/2023/Mar/17
  - source: security@huntr.dev
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/vim/vim/commit/c32949b0779106ed5710ae3bffc5053e49083ab4
  - source: security@huntr.dev
    tags:
    - Exploit
    - Third Party Advisory
    url: https://huntr.dev/bounties/1c8686db-baa6-42dc-ba45-aed322802de9
  - source: security@huntr.dev
    url: https://security.gentoo.org/glsa/202305-16
  - source: security@huntr.dev
    url: https://support.apple.com/kb/HT213670
  title: Heap-based Buffer Overflow in GitHub repository vim/vim prior to 9.0.1144.
- diff_content:
  - "--- a/src/eval.c\n+++ b/src/eval.c\n@@ -7312,6 +7312,11 @@ do_string_sub(\n \t\
    \     * - The text after the match.\n \t     */\n \t    sublen = vim_regsub(&regmatch,\
    \ sub, expr, tail, 0, REGSUB_MAGIC);\n+\t    if (sublen <= 0)\n+\t    {\n+\t\t\
    ga_clear(&ga);\n+\t\tbreak;\n+\t    }\n \t    if (ga_grow(&ga, (int)((end - tail)\
    \ + sublen -\n \t\t\t    (regmatch.endp[0] - regmatch.startp[0]))) == FAIL)\n\
    \ \t    {"
  - "--- a/src/version.c\n+++ b/src/version.c\n@@ -695,6 +695,8 @@ static char *(features[])\
    \ =\n \n static int included_patches[] =\n {   /* Add new patch number below this\
    \ line */\n+/**/\n+    1145,\n /**/\n     1144,\n /**/"
  identifiers:
  - CVE-2023-0054
  - CWE-787
  overview: Out-of-bounds Write in GitHub repository vim/vim prior to 9.0.1145.
  references:
  - source: security@huntr.dev
    url: http://seclists.org/fulldisclosure/2023/Mar/17
  - source: security@huntr.dev
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/vim/vim/commit/3ac1d97a1d9353490493d30088256360435f7731
  - source: security@huntr.dev
    tags:
    - Exploit
    - Third Party Advisory
    url: https://huntr.dev/bounties/b289ee0f-fd16-4147-bd01-c6289c45e49d
  - source: security@huntr.dev
    url: https://lists.debian.org/debian-lts-announce/2023/06/msg00015.html
  - source: security@huntr.dev
    url: https://security.gentoo.org/glsa/202305-16
  - source: security@huntr.dev
    url: https://support.apple.com/kb/HT213670
  title: Out-of-bounds Write in GitHub repository vim/vim prior to 9.0.1145.
- diff_content:
  - "--- a/src/main.cpp\n+++ b/src/main.cpp\n@@ -2099,6 +2099,7 @@ bool CBlock::AddToBlockIndex(unsigned\
    \ int nFile, unsigned int nBlockPos, const u\n \n \n bool CBlock::CheckBlock()\
    \ const {\n+    uint i;\n \n     // These are checks that are independent of context\n\
    \     // that can be verified before saving an orphan block.\n@@ -2107,44 +2108,35\
    \ @@ bool CBlock::CheckBlock() const {\n     if (vtx.empty() || vtx.size() > MAX_BLOCK_SIZE\
    \ || ::GetSerializeSize(*this, SER_NETWORK, PROTOCOL_VERSION) > MAX_BLOCK_SIZE)\n\
    \         return DoS(100, error(\"CheckBlock() : size limits failed\"));\n \n\
    -    if(IsProofOfWork()) {\n-\n-        /* Proof-of-work verification against\
    \ target */\n-        if(!CheckProofOfWork(GetHashPoW(), nBits))\n-          return(DoS(50,\
    \ error(\"CheckBlock() : proof-of-work verification failed\")));\n-\n-       \
    \ /* Proof-of-work block signature verification */\n-        if(!CheckBlockSignature())\n\
    -          return(DoS(100, error(\"CheckBlock() : bad proof-of-work block signature\"\
    )));\n-    }\n-\n     // Check timestamp\n     if (GetBlockTime() > FutureDrift(GetAdjustedTime()))\n\
    \         return error(\"CheckBlock() : block timestamp too far in the future\"\
    );\n \n     // First transaction must be coinbase, the rest must not be\n    \
    \ if (vtx.empty() || !vtx[0].IsCoinBase())\n         return DoS(100, error(\"\
    CheckBlock() : first tx is not coinbase\"));\n-    for (unsigned int i = 1; i\
    \ < vtx.size(); i++)\n-        if (vtx[i].IsCoinBase())\n-            return DoS(100,\
    \ error(\"CheckBlock() : more than one coinbase\"));\n+    for(i = 1; i < vtx.size();\
    \ i++) {\n+        if(vtx[i].IsCoinBase())\n+          return(DoS(100, error(\"\
    CheckBlock() : more than one coin base\")));\n+    }\n \n     // Check coinbase\
    \ timestamp\n     if (GetBlockTime() > FutureDrift((int64_t)vtx[0].nTime))\n \
    \        return DoS(50, error(\"CheckBlock() : coinbase timestamp is too early\"\
    ));\n \n-    if (IsProofOfStake())\n-    {\n+    if(IsProofOfStake()) {\n+\n \
    \        // Coinbase output should be empty if proof-of-stake block\n        \
    \ if (vtx[0].vout.size() != 1 || !vtx[0].vout[0].IsEmpty())\n             return\
    \ DoS(100, error(\"CheckBlock() : coinbase output not empty for proof-of-stake\
    \ block\"));\n \n         // Second transaction must be coinstake, the rest must\
    \ not be\n         if (vtx.empty() || !vtx[1].IsCoinStake())\n             return\
    \ DoS(100, error(\"CheckBlock() : second tx is not coinstake\"));\n-        for\
    \ (unsigned int i = 2; i < vtx.size(); i++)\n-            if (vtx[i].IsCoinStake())\n\
    -                return DoS(100, error(\"CheckBlock() : more than one coinstake\"\
    ));\n+        for(i = 2; i < vtx.size(); i++) {\n+            if(vtx[i].IsCoinStake())\n\
    +              return(DoS(100, error(\"CheckBlock() : more than one coin stake\"\
    )));\n+        }\n \n         // Check coinstake timestamp\n         if (!CheckCoinStakeTimestamp(GetBlockTime(),\
    \ (int64_t)vtx[1].nTime))\n@@ -2153,6 +2145,22 @@ bool CBlock::CheckBlock() const\
    \ {\n         // NovaCoin: check proof-of-stake block signature\n         if(!CheckBlockSignature())\n\
    \             return DoS(100, error(\"CheckBlock() : bad proof-of-stake block\
    \ signature\"));\n+\n+    } else {\n+\n+        /* No coin stakes in PoW blocks\
    \ */\n+        for(i = 1; i < vtx.size(); i++) {\n+            if(vtx[i].IsCoinStake()\
    \ && (vtx[i].nTime > 1626307200))\n+              return(DoS(100, error(\"CheckBlock()\
    \ : rogue coin stake\")));\n+        }\n+\n+        /* Proof-of-work verification\
    \ against target */\n+        if(!CheckProofOfWork(GetHashPoW(), nBits))\n+  \
    \        return(DoS(50, error(\"CheckBlock() : proof-of-work verification failed\"\
    )));\n+\n+        /* Proof-of-work block signature verification */\n+        if(!CheckBlockSignature())\n\
    +          return(DoS(100, error(\"CheckBlock() : bad proof-of-work block signature\"\
    )));\n     }\n \n     // Check transactions"
  identifiers:
  - CVE-2021-4300
  - NVD-CWE-Other
  overview: A vulnerability has been found in ghostlander Halcyon and classified as
    critical. Affected by this vulnerability is the function CBlock::AddToBlockIndex
    of the file src/main.cpp of the component Block Verification. The manipulation
    leads to improper access controls. The attack can be launched remotely. Upgrading
    to version 1.1.1.0-hal is able to address this issue. The identifier of the patch
    is 0675b25ae9cc10b5fdc8ea3a32c642979762d45e. It is recommended to upgrade the
    affected component. The identifier VDB-217417 was assigned to this vulnerability.
  references:
  - source: cna@vuldb.com
    tags:
    - Patch
    url: https://github.com/ghostlander/Halcyon/commit/0675b25ae9cc10b5fdc8ea3a32c642979762d45e
  - source: cna@vuldb.com
    tags:
    - Release Notes
    url: https://github.com/ghostlander/Halcyon/releases/tag/v1.1.1.0-hal
  - source: cna@vuldb.com
    tags:
    - Permissions Required
    - Third Party Advisory
    url: https://vuldb.com/?ctiid.217417
  - source: cna@vuldb.com
    tags:
    - Permissions Required
    - Third Party Advisory
    url: https://vuldb.com/?id.217417
  title: A vulnerability has been found in ghostlander Halcyon and classified as critical.
    Affected by this vulnerability is the function CBlock::AddToBlockIndex of the
    file src/main.cpp of the component Block Verification. The manipulation leads
    to improper access controls. The attack can be launched remotely. Upgrading to
    version 1.1.1.0-hal is able to address this issue. The identifier of the patch
    is 0675b25ae9cc10b5fdc8ea3a32c642979762d45e. It is recommended to upgrade the
    affected component. The identifier VDB-217417 was assigned to this vulnerability.
- diff_content:
  - "--- a/main.c\n+++ b/main.c\n@@ -188,6 +188,14 @@ void blog_index(void) {\n }\n\
    \ \n void blog_post(char post_path[]) {\n+\tif(strlen(post_path) != 0 || post_path[0]\
    \ == '.'\n+\t\t\t|| strchr(post_path, '/') == NULL) {\n+\t\tsend_header(\"Content-type\"\
    , \"text/plain\");\n+\t\tterminate_headers();\n+\t\tprintf(\"No, my dear h4xxx0r\
    \ :)\\nYou won\\'t do that :p\\n\");\n+\t\treturn;\n+\t}\n+\n \tif(file_exists(post_path)\
    \ > 0) {\n \t\tstruct blogpost post = make_blogpost(post_path);\n "
  identifiers:
  - CVE-2014-125059
  - CWE-73
  overview: 'A vulnerability, which was classified as problematic, has been found
    in sternenseemann sternenblog. This issue affects the function blog_index of the
    file main.c. The manipulation of the argument post_path leads to file inclusion.
    The attack may be initiated remotely. The complexity of an attack is rather high.
    The exploitation is known to be difficult. Upgrading to version 0.1.0 is able
    to address this issue. The identifier of the patch is cf715d911d8ce17969a7926dea651e930c27e71a.
    It is recommended to upgrade the affected component. The identifier VDB-217613
    was assigned to this vulnerability. NOTE: This case is rather theoretical and
    probably won''t happen. Maybe only on obscure Web servers.'
  references:
  - source: cna@vuldb.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/sternenseemann/sternenblog/commit/cf715d911d8ce17969a7926dea651e930c27e71a
  - source: cna@vuldb.com
    tags:
    - Release Notes
    - Third Party Advisory
    url: https://github.com/sternenseemann/sternenblog/releases/tag/0.1.0
  - source: cna@vuldb.com
    tags:
    - Third Party Advisory
    url: https://vuldb.com/?ctiid.217613
  - source: cna@vuldb.com
    tags:
    - Third Party Advisory
    url: https://vuldb.com/?id.217613
  title: 'A vulnerability, which was classified as problematic, has been found in
    sternenseemann sternenblog. This issue affects the function blog_index of the
    file main.c. The manipulation of the argument post_path leads to file inclusion.
    The attack may be initiated remotely. The complexity of an attack is rather high.
    The exploitation is known to be difficult. Upgrading to version 0.1.0 is able
    to address this issue. The identifier of the patch is cf715d911d8ce17969a7926dea651e930c27e71a.
    It is recommended to upgrade the affected component. The identifier VDB-217613
    was assigned to this vulnerability. NOTE: This case is rather theoretical and
    probably won''t happen. Maybe only on obscure Web servers.'
- diff_content:
  - "--- a/calenderServer.cpp\n+++ b/calenderServer.cpp\n@@ -245,7 +245,7 @@ string\
    \ handleGet(map<string, string>* reqHeaders) {\n       cout << \"Bad session ID,\
    \ redirecting to login.\" << endl;\n       body = getLogin();\n     } else\n-\
    \      uid = sessionMap[sessionId];\n+      uid = usersessionIt->second;\n   }\n\
    \   map<string, string> resHeaders;\n   resHeaders[\"Server\"] = \"CSE461\";\n\
    @@ -289,7 +289,9 @@ string handlePost(map<string, string>* reqHeaders) {\n   \
    \  string cookies = (*reqHeaders)[\"Cookie\"];\n     string sessionIdString =\
    \ cookies.substr(cookies.find(\"=\") + 1);\n     sessionId = stoll(sessionIdString,\
    \ nullptr);\n-    uid = sessionMap[sessionId];\n+    auto sessionIt = sessionMap.find(sessionId);\n\
    +    if(sessionIt != sessionMap.end())\n+      uid = sessionIt->second;\n   }\n\
    \   map<string, string> resHeaders;\n   resHeaders[\"Server\"] = \"CSE461\";"
  identifiers:
  - CVE-2014-125060
  - CWE-287
  overview: A vulnerability, which was classified as critical, was found in holdennb
    CollabCal. Affected is the function handleGet of the file calenderServer.cpp.
    The manipulation leads to improper authentication. It is possible to launch the
    attack remotely. The patch is identified as b80f6d1893607c99e5113967592417d0fe310ce6.
    It is recommended to apply a patch to fix this issue. VDB-217614 is the identifier
    assigned to this vulnerability.
  references:
  - source: cna@vuldb.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/holdennb/CollabCal/commit/b80f6d1893607c99e5113967592417d0fe310ce6
  - source: cna@vuldb.com
    tags:
    - Third Party Advisory
    url: https://vuldb.com/?ctiid.217614
  - source: cna@vuldb.com
    tags:
    - Third Party Advisory
    url: https://vuldb.com/?id.217614
  title: A vulnerability, which was classified as critical, was found in holdennb
    CollabCal. Affected is the function handleGet of the file calenderServer.cpp.
    The manipulation leads to improper authentication. It is possible to launch the
    attack remotely. The patch is identified as b80f6d1893607c99e5113967592417d0fe310ce6.
    It is recommended to apply a patch to fix this issue. VDB-217614 is the identifier
    assigned to this vulnerability.
- diff_content:
  - "--- a/Source/ZenLib/Ztring.cpp\n+++ b/Source/ZenLib/Ztring.cpp\n@@ -1364,6 +1364,8\
    \ @@ Ztring& Ztring::Date_From_Seconds_1970_Local (const int32u Value)\n     #endif\r\
    \n     Ztring DateT;\r\n     Ztring Date;\r\n+    if (Gmt)\r\n+    {\r\n     Date+=Ztring::ToZtring((Gmt->tm_year+1900));\r\
    \n     Date+=__T(\"-\");\r\n     DateT.From_Number(Gmt->tm_mon+1); if (DateT.size()<2){DateT=Ztring(__T(\"\
    0\"))+Ztring::ToZtring(Gmt->tm_mon+1);}\r\n@@ -1381,6 +1383,7 @@ Ztring& Ztring::Date_From_Seconds_1970_Local\
    \ (const int32u Value)\n     DateT.From_Number(Gmt->tm_sec); if (DateT.size()<2){DateT=Ztring(__T(\"\
    0\"))+Ztring::ToZtring(Gmt->tm_sec);}\r\n     Date+=DateT;\r\n     assign (Date.c_str());\r\
    \n+    }\r\n     return *this;\r\n }\r\n \r"
  identifiers:
  - CVE-2020-36646
  - CWE-476
  overview: A vulnerability classified as problematic has been found in MediaArea
    ZenLib up to 0.4.38. This affects the function Ztring::Date_From_Seconds_1970_Local
    of the file Source/ZenLib/Ztring.cpp. The manipulation of the argument Value leads
    to unchecked return value to null pointer dereference. Upgrading to version 0.4.39
    is able to address this issue. The identifier of the patch is 6475fcccd37c9cf17e0cfe263b5fe0e2e47a8408.
    It is recommended to upgrade the affected component. The identifier VDB-217629
    was assigned to this vulnerability.
  references:
  - source: cna@vuldb.com
    tags:
    - Patch
    url: https://github.com/MediaArea/ZenLib/commit/6475fcccd37c9cf17e0cfe263b5fe0e2e47a8408
  - source: cna@vuldb.com
    tags:
    - Patch
    url: https://github.com/MediaArea/ZenLib/pull/119
  - source: cna@vuldb.com
    tags:
    - Release Notes
    url: https://github.com/MediaArea/ZenLib/releases/tag/v0.4.39
  - source: cna@vuldb.com
    tags:
    - Third Party Advisory
    - VDB Entry
    url: https://vuldb.com/?ctiid.217629
  - source: cna@vuldb.com
    tags:
    - Third Party Advisory
    - VDB Entry
    url: https://vuldb.com/?id.217629
  title: A vulnerability classified as problematic has been found in MediaArea ZenLib
    up to 0.4.38. This affects the function Ztring::Date_From_Seconds_1970_Local of
    the file Source/ZenLib/Ztring.cpp. The manipulation of the argument Value leads
    to unchecked return value to null pointer dereference. Upgrading to version 0.4.39
    is able to address this issue. The identifier of the patch is 6475fcccd37c9cf17e0cfe263b5fe0e2e47a8408.
    It is recommended to upgrade the affected component. The identifier VDB-217629
    was assigned to this vulnerability.
- diff_content:
  - "--- a/src/coredump/coredump.c\n+++ b/src/coredump/coredump.c\n@@ -4,6 +4,7 @@\n\
    \ #include <stdio.h>\n #include <sys/prctl.h>\n #include <sys/statvfs.h>\n+#include\
    \ <sys/auxv.h>\n #include <sys/xattr.h>\n #include <unistd.h>\n \n@@ -107,24 +108,27\
    \ @@ enum {\n \n         META_EXE = _META_MANDATORY_MAX,\n         META_UNIT,\n\
    +        META_PROC_AUXV,\n         _META_MAX\n };\n \n static const char * const\
    \ meta_field_names[_META_MAX] = {\n-        [META_ARGV_PID]          = \"COREDUMP_PID=\"\
    ,\n-        [META_ARGV_UID]          = \"COREDUMP_UID=\",\n-        [META_ARGV_GID]\
    \          = \"COREDUMP_GID=\",\n-        [META_ARGV_SIGNAL]       = \"COREDUMP_SIGNAL=\"\
    ,\n-        [META_ARGV_TIMESTAMP]    = \"COREDUMP_TIMESTAMP=\",\n-        [META_ARGV_RLIMIT]\
    \       = \"COREDUMP_RLIMIT=\",\n-        [META_ARGV_HOSTNAME]     = \"COREDUMP_HOSTNAME=\"\
    ,\n-        [META_COMM]              = \"COREDUMP_COMM=\",\n-        [META_EXE]\
    \               = \"COREDUMP_EXE=\",\n-        [META_UNIT]              = \"COREDUMP_UNIT=\"\
    ,\n+        [META_ARGV_PID]       = \"COREDUMP_PID=\",\n+        [META_ARGV_UID]\
    \       = \"COREDUMP_UID=\",\n+        [META_ARGV_GID]       = \"COREDUMP_GID=\"\
    ,\n+        [META_ARGV_SIGNAL]    = \"COREDUMP_SIGNAL=\",\n+        [META_ARGV_TIMESTAMP]\
    \ = \"COREDUMP_TIMESTAMP=\",\n+        [META_ARGV_RLIMIT]    = \"COREDUMP_RLIMIT=\"\
    ,\n+        [META_ARGV_HOSTNAME]  = \"COREDUMP_HOSTNAME=\",\n+        [META_COMM]\
    \           = \"COREDUMP_COMM=\",\n+        [META_EXE]            = \"COREDUMP_EXE=\"\
    ,\n+        [META_UNIT]           = \"COREDUMP_UNIT=\",\n+        [META_PROC_AUXV]\
    \      = \"COREDUMP_PROC_AUXV=\",\n };\n \n typedef struct Context {\n       \
    \  const char *meta[_META_MAX];\n+        size_t meta_size[_META_MAX];\n     \
    \    pid_t pid;\n         bool is_pid1;\n         bool is_journald;\n@@ -186,13\
    \ +190,16 @@ static uint64_t storage_size_max(void) {\n         return 0;\n }\n\
    \ \n-static int fix_acl(int fd, uid_t uid) {\n+static int fix_acl(int fd, uid_t\
    \ uid, bool allow_user) {\n+        assert(fd >= 0);\n+        assert(uid_is_valid(uid));\n\
    \ \n #if HAVE_ACL\n         int r;\n \n-        assert(fd >= 0);\n-        assert(uid_is_valid(uid));\n\
    +        /* We don't allow users to read coredumps if the uid or capabilities\
    \ were changed. */\n+        if (!allow_user)\n+                return 0;\n \n\
    \         if (uid_is_system(uid) || uid_is_dynamic(uid) || uid == UID_NOBODY)\n\
    \                 return 0;\n@@ -252,7 +259,8 @@ static int fix_permissions(\n\
    \                 const char *filename,\n                 const char *target,\n\
    \                 const Context *context,\n-                uid_t uid) {\n+  \
    \              uid_t uid,\n+                bool allow_user) {\n \n         int\
    \ r;\n \n@@ -262,7 +270,7 @@ static int fix_permissions(\n \n         /* Ignore\
    \ errors on these */\n         (void) fchmod(fd, 0640);\n-        (void) fix_acl(fd,\
    \ uid);\n+        (void) fix_acl(fd, uid, allow_user);\n         (void) fix_xattr(fd,\
    \ context);\n \n         r = fsync_full(fd);\n@@ -332,6 +340,153 @@ static int\
    \ make_filename(const Context *context, char **ret) {\n         return 0;\n }\n\
    \ \n+static int parse_auxv64(\n+                const uint64_t *auxv,\n+     \
    \           size_t size_bytes,\n+                int *at_secure,\n+          \
    \      uid_t *uid,\n+                uid_t *euid,\n+                gid_t *gid,\n\
    +                gid_t *egid) {\n+\n+        assert(auxv || size_bytes == 0);\n\
    +\n+        if (size_bytes % (2 * sizeof(uint64_t)) != 0)\n+                return\
    \ log_warning_errno(SYNTHETIC_ERRNO(EIO), \"Incomplete auxv structure (%zu bytes).\"\
    , size_bytes);\n+\n+        size_t words = size_bytes / sizeof(uint64_t);\n+\n\
    +        /* Note that we set output variables even on error. */\n+\n+        for\
    \ (size_t i = 0; i + 1 < words; i += 2)\n+                switch (auxv[i]) {\n\
    +                case AT_SECURE:\n+                        *at_secure = auxv[i\
    \ + 1] != 0;\n+                        break;\n+                case AT_UID:\n\
    +                        *uid = auxv[i + 1];\n+                        break;\n\
    +                case AT_EUID:\n+                        *euid = auxv[i + 1];\n\
    +                        break;\n+                case AT_GID:\n+            \
    \            *gid = auxv[i + 1];\n+                        break;\n+         \
    \       case AT_EGID:\n+                        *egid = auxv[i + 1];\n+      \
    \                  break;\n+                case AT_NULL:\n+                 \
    \       if (auxv[i + 1] != 0)\n+                                goto error;\n\
    +                        return 0;\n+                }\n+ error:\n+        return\
    \ log_warning_errno(SYNTHETIC_ERRNO(ENODATA),\n+                             \
    \    \"AT_NULL terminator not found, cannot parse auxv structure.\");\n+}\n+\n\
    +static int parse_auxv32(\n+                const uint32_t *auxv,\n+         \
    \       size_t size_bytes,\n+                int *at_secure,\n+              \
    \  uid_t *uid,\n+                uid_t *euid,\n+                gid_t *gid,\n\
    +                gid_t *egid) {\n+\n+        assert(auxv || size_bytes == 0);\n\
    +\n+        size_t words = size_bytes / sizeof(uint32_t);\n+\n+        if (size_bytes\
    \ % (2 * sizeof(uint32_t)) != 0)\n+                return log_warning_errno(SYNTHETIC_ERRNO(EIO),\
    \ \"Incomplete auxv structure (%zu bytes).\", size_bytes);\n+\n+        /* Note\
    \ that we set output variables even on error. */\n+\n+        for (size_t i =\
    \ 0; i + 1 < words; i += 2)\n+                switch (auxv[i]) {\n+          \
    \      case AT_SECURE:\n+                        *at_secure = auxv[i + 1] != 0;\n\
    +                        break;\n+                case AT_UID:\n+            \
    \            *uid = auxv[i + 1];\n+                        break;\n+         \
    \       case AT_EUID:\n+                        *euid = auxv[i + 1];\n+      \
    \                  break;\n+                case AT_GID:\n+                  \
    \      *gid = auxv[i + 1];\n+                        break;\n+               \
    \ case AT_EGID:\n+                        *egid = auxv[i + 1];\n+            \
    \            break;\n+                case AT_NULL:\n+                       \
    \ if (auxv[i + 1] != 0)\n+                                goto error;\n+     \
    \                   return 0;\n+                }\n+ error:\n+        return log_warning_errno(SYNTHETIC_ERRNO(ENODATA),\n\
    +                                 \"AT_NULL terminator not found, cannot parse\
    \ auxv structure.\");\n+}\n+\n+static int grant_user_access(int core_fd, const\
    \ Context *context) {\n+        int at_secure = -1;\n+        uid_t uid = UID_INVALID,\
    \ euid = UID_INVALID;\n+        uid_t gid = GID_INVALID, egid = GID_INVALID;\n\
    +        int r;\n+\n+        assert(core_fd >= 0);\n+        assert(context);\n\
    +\n+        if (!context->meta[META_PROC_AUXV])\n+                return log_warning_errno(SYNTHETIC_ERRNO(ENODATA),\
    \ \"No auxv data, not adjusting permissions.\");\n+\n+        uint8_t elf[EI_NIDENT];\n\
    +        errno = 0;\n+        if (pread(core_fd, &elf, sizeof(elf), 0) != sizeof(elf))\n\
    +                return log_warning_errno(errno_or_else(EIO),\n+             \
    \                            \"Failed to pread from coredump fd: %s\", STRERROR_OR_EOF(errno));\n\
    +\n+        if (elf[EI_MAG0] != ELFMAG0 ||\n+            elf[EI_MAG1] != ELFMAG1\
    \ ||\n+            elf[EI_MAG2] != ELFMAG2 ||\n+            elf[EI_MAG3] != ELFMAG3\
    \ ||\n+            elf[EI_VERSION] != EV_CURRENT)\n+                return log_info_errno(SYNTHETIC_ERRNO(EUCLEAN),\n\
    +                                      \"Core file does not have ELF header, not\
    \ adjusting permissions.\");\n+        if (!IN_SET(elf[EI_CLASS], ELFCLASS32,\
    \ ELFCLASS64) ||\n+            !IN_SET(elf[EI_DATA], ELFDATA2LSB, ELFDATA2MSB))\n\
    +                return log_info_errno(SYNTHETIC_ERRNO(EUCLEAN),\n+          \
    \                            \"Core file has strange ELF class, not adjusting\
    \ permissions.\");\n+\n+        if ((elf[EI_DATA] == ELFDATA2LSB) != (__BYTE_ORDER\
    \ == __LITTLE_ENDIAN))\n+                return log_info_errno(SYNTHETIC_ERRNO(EUCLEAN),\n\
    +                                      \"Core file has non-native endianness,\
    \ not adjusting permissions.\");\n+\n+        if (elf[EI_CLASS] == ELFCLASS64)\n\
    +                r = parse_auxv64((const uint64_t*) context->meta[META_PROC_AUXV],\n\
    +                                 context->meta_size[META_PROC_AUXV],\n+     \
    \                            &at_secure, &uid, &euid, &gid, &egid);\n+       \
    \ else\n+                r = parse_auxv32((const uint32_t*) context->meta[META_PROC_AUXV],\n\
    +                                 context->meta_size[META_PROC_AUXV],\n+     \
    \                            &at_secure, &uid, &euid, &gid, &egid);\n+       \
    \ if (r < 0)\n+                return r;\n+\n+        /* We allow access if we\
    \ got all the data and at_secure is not set and\n+         * the uid/gid matches\
    \ euid/egid. */\n+        bool ret =\n+                at_secure == 0 &&\n+  \
    \              uid != UID_INVALID && euid != UID_INVALID && uid == euid &&\n+\
    \                gid != GID_INVALID && egid != GID_INVALID && gid == egid;\n+\
    \        log_debug(\"Will %s access (uid=\"UID_FMT \" euid=\"UID_FMT \" gid=\"\
    GID_FMT \" egid=\"GID_FMT \" at_secure=%s)\",\n+                  ret ? \"permit\"\
    \ : \"restrict\",\n+                  uid, euid, gid, egid, yes_no(at_secure));\n\
    +        return ret;\n+}\n+\n static int save_external_coredump(\n           \
    \      const Context *context,\n                 int input_fd,\n@@ -454,6 +609,8\
    \ @@ static int save_external_coredump(\n                                 context->meta[META_ARGV_PID],\
    \ context->meta[META_COMM]);\n         truncated = r == 1;\n \n+        bool allow_user\
    \ = grant_user_access(fd, context) > 0;\n+\n #if HAVE_COMPRESSION\n         if\
    \ (arg_compress) {\n                 _cleanup_(unlink_and_freep) char *tmp_compressed\
    \ = NULL;\n@@ -491,7 +648,7 @@ static int save_external_coredump(\n          \
    \               uncompressed_size += partial_uncompressed_size;\n            \
    \     }\n \n-                r = fix_permissions(fd_compressed, tmp_compressed,\
    \ fn_compressed, context, uid);\n+                r = fix_permissions(fd_compressed,\
    \ tmp_compressed, fn_compressed, context, uid, allow_user);\n                \
    \ if (r < 0)\n                         return r;\n \n@@ -518,7 +675,7 @@ static\
    \ int save_external_coredump(\n                            \"SIZE_LIMIT=%\"PRIu64,\
    \ max_size,\n                            \"MESSAGE_ID=\" SD_MESSAGE_TRUNCATED_CORE_STR);\n\
    \ \n-        r = fix_permissions(fd, tmp, fn, context, uid);\n+        r = fix_permissions(fd,\
    \ tmp, fn, context, uid, allow_user);\n         if (r < 0)\n                 return\
    \ log_error_errno(r, \"Failed to fix permissions and finalize coredump %s into\
    \ %s: %m\", coredump_tmpfile_name(tmp), fn);\n \n@@ -766,7 +923,7 @@ static int\
    \ change_uid_gid(const Context *context) {\n }\n \n static int submit_coredump(\n\
    -                Context *context,\n+                const Context *context,\n\
    \                 struct iovec_wrapper *iovw,\n                 int input_fd)\
    \ {\n \n@@ -945,16 +1102,15 @@ static int save_context(Context *context, const\
    \ struct iovec_wrapper *iovw) {\n                 struct iovec *iovec = iovw->iovec\
    \ + n;\n \n                 for (size_t i = 0; i < ELEMENTSOF(meta_field_names);\
    \ i++) {\n-                        char *p;\n-\n                         /* Note\
    \ that these strings are NUL terminated, because we made sure that a\n       \
    \                   * trailing NUL byte is in the buffer, though not included\
    \ in the iov_len\n                          * count (see process_socket() and\
    \ gather_pid_metadata_*()) */\n                         assert(((char*) iovec->iov_base)[iovec->iov_len]\
    \ == 0);\n \n-                        p = startswith(iovec->iov_base, meta_field_names[i]);\n\
    +                        const char *p = startswith(iovec->iov_base, meta_field_names[i]);\n\
    \                         if (p) {\n                                 context->meta[i]\
    \ = p;\n+                                context->meta_size[i] = iovec->iov_len\
    \ - strlen(meta_field_names[i]);\n                                 break;\n  \
    \                       }\n                 }\n@@ -1191,6 +1347,7 @@ static int\
    \ gather_pid_metadata(struct iovec_wrapper *iovw, Context *context) {\n      \
    \   uid_t owner_uid;\n         pid_t pid;\n         char *t;\n+        size_t\
    \ size;\n         const char *p;\n         int r;\n \n@@ -1255,13 +1412,26 @@\
    \ static int gather_pid_metadata(struct iovec_wrapper *iovw, Context *context)\
    \ {\n                 (void) iovw_put_string_field_free(iovw, \"COREDUMP_PROC_LIMITS=\"\
    , t);\n \n         p = procfs_file_alloca(pid, \"cgroup\");\n-        if (read_full_virtual_file(p,\
    \ &t, NULL) >=0)\n+        if (read_full_virtual_file(p, &t, NULL) >= 0)\n   \
    \              (void) iovw_put_string_field_free(iovw, \"COREDUMP_PROC_CGROUP=\"\
    , t);\n \n         p = procfs_file_alloca(pid, \"mountinfo\");\n-        if (read_full_virtual_file(p,\
    \ &t, NULL) >=0)\n+        if (read_full_virtual_file(p, &t, NULL) >= 0)\n   \
    \              (void) iovw_put_string_field_free(iovw, \"COREDUMP_PROC_MOUNTINFO=\"\
    , t);\n \n+        /* We attach /proc/auxv here. ELF coredumps also contain a\
    \ note for this (NT_AUXV), see elf(5). */\n+        p = procfs_file_alloca(pid,\
    \ \"auxv\");\n+        if (read_full_virtual_file(p, &t, &size) >= 0) {\n+   \
    \             char *buf = malloc(strlen(\"COREDUMP_PROC_AUXV=\") + size + 1);\n\
    +                if (buf) {\n+                        /* Add a dummy terminator\
    \ to make save_context() happy. */\n+                        *((uint8_t*) mempcpy(stpcpy(buf,\
    \ \"COREDUMP_PROC_AUXV=\"), t, size)) = '\\0';\n+                        (void)\
    \ iovw_consume(iovw, buf, size + strlen(\"COREDUMP_PROC_AUXV=\"));\n+        \
    \        }\n+\n+                free(t);\n+        }\n+\n         if (get_process_cwd(pid,\
    \ &t) >= 0)\n                 (void) iovw_put_string_field_free(iovw, \"COREDUMP_CWD=\"\
    , t);\n "
  identifiers:
  - CVE-2022-4415
  - NVD-CWE-noinfo
  overview: A vulnerability was found in systemd. This security flaw can cause a local
    information leak due to systemd-coredump not respecting the fs.suid_dumpable kernel
    setting.
  references:
  - source: secalert@redhat.com
    tags:
    - Exploit
    - Patch
    - Third Party Advisory
    url: https://github.com/systemd/systemd/commit/b7641425659243c09473cd8fb3aef2c0d4a3eb9c
  - source: secalert@redhat.com
    tags:
    - Mailing List
    - Third Party Advisory
    url: https://www.openwall.com/lists/oss-security/2022/12/21/3
  title: A vulnerability was found in systemd. This security flaw can cause a local
    information leak due to systemd-coredump not respecting the fs.suid_dumpable kernel
    setting.
- diff_content:
  - "--- a/libavformat/nutdec.c\n+++ b/libavformat/nutdec.c\n@@ -351,8 +351,12 @@\
    \ static int decode_main_header(NUTContext *nut)\n         ret = AVERROR(ENOMEM);\n\
    \         goto fail;\n     }\n-    for (i = 0; i < stream_count; i++)\n-     \
    \   avformat_new_stream(s, NULL);\n+    for (i = 0; i < stream_count; i++) {\n\
    +        if (!avformat_new_stream(s, NULL)) {\n+            ret = AVERROR(ENOMEM);\n\
    +            goto fail;\n+        }\n+    }\n \n     return 0;\n fail:\n@@ -800,19\
    \ +804,23 @@ static int nut_read_header(AVFormatContext *s)\n     NUTContext *nut\
    \ = s->priv_data;\n     AVIOContext *bc = s->pb;\n     int64_t pos;\n-    int\
    \ initialized_stream_count;\n+    int initialized_stream_count, ret;\n \n    \
    \ nut->avf = s;\n \n     /* main header */\n     pos = 0;\n+    ret = 0;\n   \
    \  do {\n+        if (ret == AVERROR(ENOMEM))\n+            return ret;\n+\n \
    \        pos = find_startcode(bc, MAIN_STARTCODE, pos) + 1;\n         if (pos\
    \ < 0 + 1) {\n             av_log(s, AV_LOG_ERROR, \"No main startcode found.\\\
    n\");\n             return AVERROR_INVALIDDATA;\n         }\n-    } while (decode_main_header(nut)\
    \ < 0);\n+    } while ((ret = decode_main_header(nut)) < 0);\n \n     /* stream\
    \ headers */\n     pos = 0;"
  identifiers:
  - CVE-2022-3341
  - CWE-476
  overview: A null pointer dereference issue was discovered in 'FFmpeg' in decode_main_header()
    function of libavformat/nutdec.c file. The flaw occurs because the function lacks
    check of the return value of avformat_new_stream() and triggers the null pointer
    dereference error, causing an application to crash.
  references:
  - source: patrick@puiterwijk.org
    tags:
    - Issue Tracking
    - Patch
    - Third Party Advisory
    url: https://bugzilla.redhat.com/show_bug.cgi?id=2157054
  - source: patrick@puiterwijk.org
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/FFmpeg/FFmpeg/commit/9cf652cef49d74afe3d454f27d49eb1a1394951e
  - source: patrick@puiterwijk.org
    url: https://lists.debian.org/debian-lts-announce/2023/06/msg00016.html
  title: A null pointer dereference issue was discovered in 'FFmpeg' in decode_main_header()
    function of libavformat/nutdec.c file. The flaw occurs because the function lacks
    check of the return value of avformat_new_stream() and triggers the null pointer
    dereference error, causing an application to crash.
- diff_content:
  - "--- a/src/render/opengles/SDL_render_gles.c\n+++ b/src/render/opengles/SDL_render_gles.c\n\
    @@ -359,6 +359,9 @@ GLES_CreateTexture(SDL_Renderer * renderer, SDL_Texture *\
    \ texture)\n     renderdata->glGenTextures(1, &data->texture);\n     result =\
    \ renderdata->glGetError();\n     if (result != GL_NO_ERROR) {\n+        if (texture->access\
    \ == SDL_TEXTUREACCESS_STREAMING) {\n+            SDL_free(data->pixels);\n+ \
    \       }\n         SDL_free(data);\n         return GLES_SetError(\"glGenTextures()\"\
    , result);\n     }\n@@ -387,6 +390,9 @@ GLES_CreateTexture(SDL_Renderer * renderer,\
    \ SDL_Texture * texture)\n \n     result = renderdata->glGetError();\n     if\
    \ (result != GL_NO_ERROR) {\n+        if (texture->access == SDL_TEXTUREACCESS_STREAMING)\
    \ {\n+            SDL_free(data->pixels);\n+        }\n         SDL_free(data);\n\
    \         return GLES_SetError(\"glTexImage2D()\", result);\n     }"
  identifiers:
  - CVE-2022-4743
  - CWE-401
  overview: A potential memory leak issue was discovered in SDL2 in GLES_CreateTexture()
    function in SDL_render_gles.c. The vulnerability allows an attacker to cause a
    denial of service attack. The vulnerability affects SDL2 v2.0.4 and above. SDL-1.x
    are not affected.
  references:
  - source: secalert@redhat.com
    tags:
    - Third Party Advisory
    url: https://access.redhat.com/security/cve/CVE-2022-4743
  - source: secalert@redhat.com
    tags:
    - Issue Tracking
    - Patch
    - Third Party Advisory
    url: https://bugzilla.redhat.com/show_bug.cgi?id=2156290
  - source: secalert@redhat.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/libsdl-org/SDL/commit/00b67f55727bc0944c3266e2b875440da132ce4b
  - source: secalert@redhat.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/libsdl-org/SDL/pull/6269
  - source: secalert@redhat.com
    url: https://lists.debian.org/debian-lts-announce/2023/02/msg00008.html
  - source: secalert@redhat.com
    url: https://security.gentoo.org/glsa/202305-18
  title: A potential memory leak issue was discovered in SDL2 in GLES_CreateTexture()
    function in SDL_render_gles.c. The vulnerability allows an attacker to cause a
    denial of service attack. The vulnerability affects SDL2 v2.0.4 and above. SDL-1.x
    are not affected.
- diff_content:
  - "--- a/src/p_tmt.cpp\n+++ b/src/p_tmt.cpp\n@@ -139,7 +139,8 @@ int PackTmt::readFileHeader()\
    \ {\n     unsigned const imagesize = ih.imagesize;\n     unsigned const entry\
    \ = ih.entry;\n     unsigned const relocsize = ih.relocsize;\n-    if (!imagesize\
    \ || file_size <= imagesize || file_size <= entry || file_size <= relocsize) {\n\
    +    if (imagesize < sizeof(ih) || entry < sizeof(ih) || file_size <= imagesize\
    \ ||\n+        file_size <= entry || file_size <= relocsize) {\n         printWarn(getName(),\
    \ \"bad header; imagesize=%#x  entry=%#x  relocsize=%#x\", imagesize,\n      \
    \             entry, relocsize);\n         return 0;\n@@ -172,15 +173,15 @@ void\
    \ PackTmt::pack(OutputFile *fo) {\n     obuf.allocForCompression(usize + rsize\
    \ + 128);\n \n     MemBuffer mb_wrkmem;\n-    mb_wrkmem.alloc(rsize + EXTRA_INFO);\
    \ // relocations\n+    mb_wrkmem.alloc(rsize + EXTRA_INFO + 4); // relocations\
    \ + original entry point + relocsize\n     SPAN_S_VAR(upx_byte, wrkmem, mb_wrkmem);\n\
    \ \n     fi->seek(adam_offset + sizeof(ih), SEEK_SET);\n     fi->readx(ibuf, usize);\n\
    \     fi->readx(wrkmem + 4, rsize);\n     const unsigned overlay = file_size -\
    \ fi->tell();\n \n-    if (find_le32(ibuf, 128, get_le32(\"UPX \")) >= 0)\n+ \
    \   if (find_le32(ibuf, UPX_MIN(128u, usize), get_le32(\"UPX \")) >= 0)\n    \
    \     throwAlreadyPacked();\n     if (rsize == 0)\n         throwCantPack(\"file\
    \ is already compressed with another packer\");"
  identifiers:
  - CVE-2023-23456
  - CWE-787
  overview: A heap-based buffer overflow issue was discovered in UPX in PackTmt::pack()
    in p_tmt.cpp file. The flow allows an attacker to cause a denial of service (abort)
    via a crafted file.
  references:
  - source: patrick@puiterwijk.org
    tags:
    - Issue Tracking
    - Third Party Advisory
    url: https://bugzilla.redhat.com/show_bug.cgi?id=2160381
  - source: patrick@puiterwijk.org
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/upx/upx/commit/510505a85cbe45e51fbd470f1aa8b02157c429d4
  - source: patrick@puiterwijk.org
    tags:
    - Exploit
    - Third Party Advisory
    url: https://github.com/upx/upx/issues/632
  - source: patrick@puiterwijk.org
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/EL3BVKIGG3SH6I3KPOYQAWCBD4UMPOPI/
  - source: patrick@puiterwijk.org
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/TGEP3FBNRZXGLIA2B2ICMB32JVMPREFZ/
  title: A heap-based buffer overflow issue was discovered in UPX in PackTmt::pack()
    in p_tmt.cpp file. The flow allows an attacker to cause a denial of service (abort)
    via a crafted file.
- diff_content:
  - "--- a/src/p_lx_elf.cpp\n+++ b/src/p_lx_elf.cpp\n@@ -256,7 +256,8 @@ PackLinuxElf32::PackLinuxElf32help1(InputFile\
    \ *f)\n     e_phnum = get_te16(&ehdri.e_phnum);\n     e_shnum = get_te16(&ehdri.e_shnum);\n\
    \     unsigned const e_phentsize = get_te16(&ehdri.e_phentsize);\n-    if (ehdri.e_ident[Elf32_Ehdr::EI_CLASS]!=Elf32_Ehdr::ELFCLASS32\n\
    +    if (memcmp((char const *)&ehdri, \"\\x7f\\x45\\x4c\\x46\", 4)  // \"\\177ELF\"\
    \n+    || ehdri.e_ident[Elf32_Ehdr::EI_CLASS]!=Elf32_Ehdr::ELFCLASS32\n     ||\
    \ sizeof(Elf32_Phdr) != e_phentsize\n     || (Elf32_Ehdr::ELFDATA2MSB == ehdri.e_ident[Elf32_Ehdr::EI_DATA]\n\
    \             && &N_BELE_RTP::be_policy != bele)\n@@ -761,7 +762,8 @@ PackLinuxElf64::PackLinuxElf64help1(InputFile\
    \ *f)\n     e_phnum = get_te16(&ehdri.e_phnum);\n     e_shnum = get_te16(&ehdri.e_shnum);\n\
    \     unsigned const e_phentsize = get_te16(&ehdri.e_phentsize);\n-    if (ehdri.e_ident[Elf64_Ehdr::EI_CLASS]!=Elf64_Ehdr::ELFCLASS64\n\
    +    if (memcmp((char const *)&ehdri, \"\\x7f\\x45\\x4c\\x46\", 4)  // \"\\177ELF\"\
    \n+    || ehdri.e_ident[Elf64_Ehdr::EI_CLASS]!=Elf64_Ehdr::ELFCLASS64\n     ||\
    \ sizeof(Elf64_Phdr) != e_phentsize\n     || (Elf64_Ehdr::ELFDATA2MSB == ehdri.e_ident[Elf64_Ehdr::EI_DATA]\n\
    \             && &N_BELE_RTP::be_policy != bele)\n@@ -5780,7 +5782,7 @@ PackLinuxElf64::invert_pt_dynamic(Elf64_Dyn\
    \ const *dynp, upx_uint64_t headway)\n         }\n         if (file_size <= dt_offsets[n_off])\
    \ {\n             char msg[60]; snprintf(msg, sizeof(msg), \"bad DT_{%#x} = %#x\
    \ (beyond EOF)\",\n-                dt_names[k], dt_offsets[n_off]);\n+      \
    \          k, dt_offsets[n_off]);\n                 throwCantPack(msg);\n    \
    \     }\n         n_off += !!dt_offsets[n_off];"
  identifiers:
  - CVE-2023-23457
  - CWE-119
  overview: A Segmentation fault was found in UPX in PackLinuxElf64::invert_pt_dynamic()
    in p_lx_elf.cpp. An attacker with a crafted input file allows invalid memory address
    access that could lead to a denial of service.
  references:
  - source: patrick@puiterwijk.org
    tags:
    - Issue Tracking
    - Patch
    - Third Party Advisory
    url: https://bugzilla.redhat.com/show_bug.cgi?id=2160382
  - source: patrick@puiterwijk.org
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/upx/upx/commit/779b648c5f6aa9b33f4728f79dd4d0efec0bf860
  - source: patrick@puiterwijk.org
    tags:
    - Exploit
    - Patch
    - Third Party Advisory
    url: https://github.com/upx/upx/issues/631
  - source: patrick@puiterwijk.org
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/EL3BVKIGG3SH6I3KPOYQAWCBD4UMPOPI/
  - source: patrick@puiterwijk.org
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/TGEP3FBNRZXGLIA2B2ICMB32JVMPREFZ/
  title: A Segmentation fault was found in UPX in PackLinuxElf64::invert_pt_dynamic()
    in p_lx_elf.cpp. An attacker with a crafted input file allows invalid memory address
    access that could lead to a denial of service.
- diff_content:
  - "--- a/src/normal.c\n+++ b/src/normal.c\n@@ -3729,7 +3729,8 @@ nv_scroll(cmdarg_T\
    \ *cap)\n \t\t{\n \t\t    (void)hasFolding(curwin->w_cursor.lnum,\n \t\t\t\t\t\
    \t&curwin->w_cursor.lnum, NULL);\n-\t\t    --curwin->w_cursor.lnum;\n+\t\t   \
    \ if (curwin->w_cursor.lnum > curwin->w_topline)\n+\t\t\t--curwin->w_cursor.lnum;\n\
    \ \t\t}\n \t    }\n \t    else"
  - "--- a/src/version.c\n+++ b/src/version.c\n@@ -695,6 +695,8 @@ static char *(features[])\
    \ =\n \n static int included_patches[] =\n {   /* Add new patch number below this\
    \ line */\n+/**/\n+    1189,\n /**/\n     1188,\n /**/"
  identifiers:
  - CVE-2023-0288
  - CWE-122
  overview: Heap-based Buffer Overflow in GitHub repository vim/vim prior to 9.0.1189.
  references:
  - source: security@huntr.dev
    url: http://seclists.org/fulldisclosure/2023/Mar/17
  - source: security@huntr.dev
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/vim/vim/commit/232bdaaca98c34a99ffadf27bf6ee08be6cc8f6a
  - source: security@huntr.dev
    tags:
    - Exploit
    - Issue Tracking
    - Patch
    - Third Party Advisory
    url: https://huntr.dev/bounties/550a0852-9be0-4abe-906c-f803b34e41d3
  - source: security@huntr.dev
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/WYC22GGZ6QA66HLNLHCTAJU265TT3O33/
  - source: security@huntr.dev
    url: https://support.apple.com/kb/HT213670
  title: Heap-based Buffer Overflow in GitHub repository vim/vim prior to 9.0.1189.
- diff_content:
  - "--- a/libr/anal/meta.c\n+++ b/libr/anal/meta.c\n@@ -111,12 +111,13 @@ static\
    \ bool meta_set(RAnal *a, RAnalMetaType type, int subtype, ut64 from, ut64\n \t\
    item->subtype = subtype;\n \titem->space = space;\n \tfree (item->str);\n-\titem->str\
    \ = str ? strdup (str) : NULL;\n-\tif (str && !item->str) {\n-\t\tif (!node) {\
    \ // If we just created this\n-\t\t\tfree (item);\n-\t\t}\n-\t\treturn false;\n\
    +\tif (R_STR_ISNOTEMPTY (str)) {\n+\t\titem->str = strdup (str);\n+\t\t// this\
    \ breaks the `ecHw` command\n+\t\t// (highlights word in current instruction,\
    \ which uses ansi\n+\t\t// r_str_ansi_strip (item->str);\n+\t} else {\n+\t\titem->str\
    \ = NULL;\n \t}\n \tR_DIRTY (a);\n \tif (!node) {"
  - "--- a/libr/bin/dwarf.c\n+++ b/libr/bin/dwarf.c\n@@ -431,6 +431,7 @@ static const\
    \ ut8 *parse_line_header_source(RBinFile *bf, const ut8 *buf, const u\n \tint\
    \ i = 0;\n \tsize_t count;\n \tconst ut8 *tmp_buf = NULL;\n+\tchar *fn = NULL;\n\
    \ \n \tif (mode == R_MODE_PRINT) {\n \t\tprint (\" The Directory Table:\\n\");\n\
    @@ -464,10 +465,12 @@ static const ut8 *parse_line_header_source(RBinFile *bf,\
    \ const ut8 *buf, const u\n \n \tfor (i = 0; i < 2; i++) {\n \t\twhile (buf +\
    \ 1 < buf_end) {\n-\t\t\tconst char *filename = (const char *)buf;\n \t\t\tsize_t\
    \ maxlen = R_MIN ((size_t) (buf_end - buf - 1), 0xfff);\n \t\t\tut64 id_idx, mod_time,\
    \ file_len;\n-\t\t\tsize_t len = r_str_nlen (filename, maxlen);\n+\t\t\tfree (fn);\n\
    +\t\t\tfn = r_str_ndup ((const char *)buf, maxlen);\n+\t\t\tr_str_ansi_strip (fn);\n\
    +\t\t\tsize_t len = strlen (fn);\n \n \t\t\tif (!len) {\n \t\t\t\tbuf++;\n@@ -512,7\
    \ +515,7 @@ static const ut8 *parse_line_header_source(RBinFile *bf, const ut8\
    \ *buf, const u\n \t\t\t\t}\n \n \t\t\t\tif (hdr->file_names) {\n-\t\t\t\t\thdr->file_names[count].name\
    \ = r_str_newf(\"%s/%s\", r_str_get (include_dir), filename);\n+\t\t\t\t\thdr->file_names[count].name\
    \ = r_str_newf(\"%s/%s\", r_str_get (include_dir), fn);\n \t\t\t\t\thdr->file_names[count].id_idx\
    \ = id_idx;\n \t\t\t\t\thdr->file_names[count].mod_time = mod_time;\n \t\t\t\t\
    \thdr->file_names[count].file_len = file_len;\n@@ -525,7 +528,8 @@ static const\
    \ ut8 *parse_line_header_source(RBinFile *bf, const ut8 *buf, const u\n \t\t\t\
    }\n \t\t\tcount++;\n \t\t\tif (mode == R_MODE_PRINT && i) {\n-\t\t\t\tprint (\"\
    \  %d     %\" PFMT64d \"       %\" PFMT64d \"         %\" PFMT64d \"         \
    \ %s\\n\", entry_index++, id_idx, mod_time, file_len, filename);\n+\t\t\t\tprint\
    \ (\"  %d     %\" PFMT64d \"       %\" PFMT64d \"         %\" PFMT64d \"     \
    \     %s\\n\",\n+\t\t\t\t\t\tentry_index++, id_idx, mod_time, file_len, fn);\n\
    \ \t\t\t}\n \t\t}\n \t\tif (i == 0) {\n@@ -544,6 +548,7 @@ static const ut8 *parse_line_header_source(RBinFile\
    \ *bf, const ut8 *buf, const u\n \t}\n \n beach:\n+\tfree (fn);\n \tsdb_free (sdb);\n\
    \ \n \treturn buf;\n@@ -677,7 +682,6 @@ static const ut8 *parse_line_header(\n\
    \ \n static inline void add_sdb_addrline(Sdb *s, ut64 addr, const char *file,\
    \ ut64 line, int mode, PrintfCallback print) {\n \tconst char *p;\n-\tchar *fileline;\n\
    \ \tchar offset[SDB_NUM_BUFSZ];\n \tchar *offset_ptr;\n \n@@ -706,7 +710,10 @@\
    \ static inline void add_sdb_addrline(Sdb *s, ut64 addr, const char *file, ut64\
    \ li\n #else\n \tp = file;\n #endif\n-\tfileline = r_str_newf (\"%s|%\"PFMT64d,\
    \ p, line);\n+\tchar *fileline = r_str_newf (\"%s|%\"PFMT64d, p, line);\n+\tr_str_ansi_strip\
    \ (fileline);\n+\tr_str_replace_ch (fileline, '\\n', 0, true);\n+\tr_str_replace_ch\
    \ (fileline, '\\t', 0, true);\n \toffset_ptr = sdb_itoa (addr, 16, offset, sizeof\
    \ (offset));\n \tsdb_add (s, offset_ptr, fileline, 0);\n \tsdb_add (s, fileline,\
    \ offset_ptr, 0);\n@@ -1666,7 +1673,15 @@ static const ut8 *parse_attr_value(const\
    \ ut8 *obuf, int obuf_len,\n \t\tbreak;\n \tcase DW_FORM_string:\n \t\tvalue->kind\
    \ = DW_AT_KIND_STRING;\n-\t\tvalue->string.content = *buf ? r_str_ndup ((const\
    \ char *)buf, buf_end - buf) : NULL;\n+\t\tif (*buf) {\n+\t\t\tchar *name = r_str_ndup\
    \ ((const char *)buf, buf_end - buf);\n+\t\t\tr_str_ansi_strip (name);\n+\t\t\t\
    r_str_replace_ch (name, '\\n', 0, true);\n+\t\t\tr_str_replace_ch (name, '\\t',\
    \ 0, true);\n+\t\t\tvalue->string.content = name;\n+\t\t} else {\n+\t\t\tvalue->string.content\
    \ = NULL;\n+\t\t}\n \t\tif (value->string.content) {\n \t\t\tbuf += strlen (value->string.content)\
    \ + 1;\n \t\t}\n@@ -1711,8 +1726,15 @@ static const ut8 *parse_attr_value(const\
    \ ut8 *obuf, int obuf_len,\n \t\tvalue->kind = DW_AT_KIND_STRING;\n \t\tvalue->string.offset\
    \ = dwarf_read_offset (hdr->is_64bit, &buf, buf_end);\n \t\tif (debug_str && value->string.offset\
    \ < debug_str_len) {\n-\t\t\tconst char *ds = (const char *)(debug_str + value->string.offset);\n\
    -\t\t\tvalue->string.content = strdup (ds); // r_str_ndup (ds, debug_str_len -\
    \ value->string.offset);\n+\t\t\tchar *ds = r_str_ndup ((const char *)(debug_str\
    \ + value->string.offset), debug_str_len);\n+\t\t\tif (ds) {\n+\t\t\t\tr_str_ansi_strip\
    \ (ds);\n+\t\t\t\tr_str_replace_ch (ds, '\\n', 0, true);\n+\t\t\t\tr_str_replace_ch\
    \ (ds, '\\t', 0, true);\n+\t\t\t\tvalue->string.content = ds;\n+\t\t\t} else {\n\
    +\t\t\t\tvalue->string.content = NULL;\n+\t\t\t}\n \t\t} else {\n \t\t\tvalue->string.content\
    \ = NULL; // Means malformed DWARF, should we print error message?\n \t\t}\n@@\
    \ -1903,8 +1925,11 @@ static const ut8 *parse_die(const ut8 *buf, const ut8 *buf_end,\
    \ RBinDwarfAbbrevD\n \t\t// Or atleast it needs to rework becase there will be\n\
    \ \t\t// more comp units -> more comp dirs and only the last one will be kept\n\
    \ \t\tif (attribute->attr_name == DW_AT_comp_dir && is_valid_string_form) {\n\
    -\t\t\tconst char *name = attribute->string.content;\n-\t\t\tsdb_set (sdb, \"\
    DW_AT_comp_dir\", name, 0);\n+\t\t\tchar *name = strdup (attribute->string.content);\n\
    +\t\t\tr_str_ansi_strip (name);\n+\t\t\tr_str_replace_ch (name, '\\n', 0, true);\n\
    +\t\t\tr_str_replace_ch (name, '\\t', 0, true);\n+\t\t\tsdb_set_owned (sdb, \"\
    DW_AT_comp_dir\", name, 0);\n \t\t}\n \t\tdie->count++;\n \t}"
  - "--- a/libr/cons/hud.c\n+++ b/libr/cons/hud.c\n@@ -1,4 +1,4 @@\n-/* radare - LGPL\
    \ - Copyright 2008-2021 - pancake */\n+/* radare - LGPL - Copyright 2008-2023\
    \ - pancake */\n \n #include <r_cons.h>\n #include <ctype.h>\n@@ -9,6 +9,7 @@\n\
    \ R_API char *r_cons_hud_file(const char *f) {\n \tchar *s = r_file_slurp (f,\
    \ NULL);\n \tif (s) {\n+\t\tr_str_ansi_strip (s);\n \t\tchar *ret = r_cons_hud_string\
    \ (s);\n \t\tfree (s);\n \t\treturn ret;\n@@ -29,6 +30,7 @@ R_API char *r_cons_hud_line_string(const\
    \ char *s) {\n \t}\n \tr_str_replace_ch (o, '\\r', 0, true);\n \tr_str_replace_ch\
    \ (o, '\\t', 0, true);\n+\tr_str_ansi_strip (o);\n \tRList *fl = r_list_new ();\n\
    \ \tint i;\n \tif (!fl) {\n@@ -66,6 +68,7 @@ R_API char *r_cons_hud_string(const\
    \ char *s) {\n \tif (!o) {\n \t\treturn NULL;\n \t}\n+\tr_str_ansi_strip (o);\n\
    \ \tr_str_replace_ch (o, '\\r', 0, true);\n \tr_str_replace_ch (o, '\\t', 0, true);\n\
    \ \tRList *fl = r_list_new ();"
  - "--- a/libr/core/cmd_meta.c\n+++ b/libr/core/cmd_meta.c\n@@ -539,10 +539,10 @@\
    \ static int cmd_meta_comment(RCore *core, const char *input) {\n \t\tbreak;\n\
    \ \tcase '!':\n \t\t{\n-\t\t\tchar *out;\n \t\t\tconst char *comment = r_meta_get_string\
    \ (core->anal, R_META_TYPE_COMMENT, addr);\n-\t\t\tout = r_core_editor (core,\
    \ NULL, comment);\n+\t\t\tchar *out = r_core_editor (core, NULL, comment);\n \t\
    \t\tif (out) {\n+\t\t\t\tr_str_ansi_strip (out);\n \t\t\t\t//r_meta_set (core->anal->meta,\
    \ R_META_TYPE_COMMENT, addr, 0, out);\n \t\t\t\tr_core_cmdf (core, \"CC-@0x%08\"\
    PFMT64x, addr);\n \t\t\t\t//r_meta_del (core->anal->meta, input[0], addr, addr+1);\n\
    @@ -560,6 +560,7 @@ static int cmd_meta_comment(RCore *core, const char *input)\
    \ {\n \t\tchar *text;\n \t\tchar *nc = strdup (newcomment);\n \t\tr_str_unescape\
    \ (nc);\n+\t\tr_str_ansi_strip (nc);\n \t\tif (comment) {\n \t\t\ttext = malloc\
    \ (strlen (comment) + strlen (newcomment) + 2);\n \t\t\tif (text) {"
  - "--- a/libr/core/cmd_print.c\n+++ b/libr/core/cmd_print.c\n@@ -1,4 +1,4 @@\n-/*\
    \ radare - LGPL - Copyright 2009-2022 - pancake */\n+/* radare - LGPL - Copyright\
    \ 2009-2023 - pancake */\n \n #include <r_core.h>\n #include <limits.h>"
  - "--- a/libr/util/str.c\n+++ b/libr/util/str.c\n@@ -1957,14 +1957,16 @@ R_API size_t\
    \ r_str_ansi_nlen(const char *str, size_t slen) {\n }\n \n // remove ansi escape\
    \ codes from string, decolorizing it\n+// TODO : optimize by just using two counter\
    \ variables instead of strcpy()\n R_API size_t r_str_ansi_strip(char *str) {\n\
    \ \tsize_t i = 0;\n \twhile (str[i]) {\n \t\tsize_t chlen = __str_ansi_length\
    \ (str + i);\n \t\tif (chlen > 1) {\n-\t\t\tr_str_cpy (str + i + 1, str + i +\
    \ chlen);\n+\t\t\tr_str_cpy (str + i, str + i + chlen);\n+\t\t} else {\n+\t\t\t\
    i++;\n \t\t}\n-\t\ti++;\n \t}\n \treturn i;\n }"
  identifiers:
  - CVE-2023-0302
  - CWE-74
  overview: Failure to Sanitize Special Elements into a Different Plane (Special Element
    Injection) in GitHub repository radareorg/radare2 prior to 5.8.2.
  references:
  - source: security@huntr.dev
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/radareorg/radare2/commit/961f0e723903011d4f54c2396e44efa91fcc74ce
  - source: security@huntr.dev
    tags:
    - Exploit
    - Issue Tracking
    - Patch
    - Third Party Advisory
    url: https://huntr.dev/bounties/583133af-7ae6-4a21-beef-a4b0182cf82e
  title: Failure to Sanitize Special Elements into a Different Plane (Special Element
    Injection) in GitHub repository radareorg/radare2 prior to 5.8.2.
- diff_content:
  - "--- a/drivers/net/slip/slip.c\n+++ b/drivers/net/slip/slip.c\n@@ -469,7 +469,7\
    \ @@ static void sl_tx_timeout(struct net_device *dev, unsigned int txqueue)\n\
    \ \tspin_lock(&sl->lock);\n \n \tif (netif_queue_stopped(dev)) {\n-\t\tif (!netif_running(dev))\n\
    +\t\tif (!netif_running(dev) || !sl->tty)\n \t\t\tgoto out;\n \n \t\t/* May be\
    \ we must check transmitter timeout here ?"
  identifiers:
  - CVE-2022-41858
  - CWE-476
  overview: A flaw was found in the Linux kernel. A NULL pointer dereference may occur
    while a slip driver is in progress to detach in sl_tx_timeout in drivers/net/slip/slip.c.
    This issue could allow an attacker to crash the system or leak internal kernel
    information.
  references:
  - source: secalert@redhat.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/torvalds/linux/commit/ec4eb8a86ade4d22633e1da2a7d85a846b7d1798
  - source: secalert@redhat.com
    tags:
    - Third Party Advisory
    url: https://security.netapp.com/advisory/ntap-20230223-0006/
  title: A flaw was found in the Linux kernel. A NULL pointer dereference may occur
    while a slip driver is in progress to detach in sl_tx_timeout in drivers/net/slip/slip.c.
    This issue could allow an attacker to crash the system or leak internal kernel
    information.
- diff_content:
  - "--- a/src/modules/rlm_eap/types/rlm_eap_pwd/eap_pwd.c\n+++ b/src/modules/rlm_eap/types/rlm_eap_pwd/eap_pwd.c\n\
    @@ -248,18 +248,16 @@ int compute_password_element (REQUEST *request, pwd_session_t\
    \ *session, uint16_t\n \t\t\t      char const *id_peer, int id_peer_len,\n \t\t\
    \t      uint32_t *token)\n {\n-\tBIGNUM *x_candidate = NULL, *rnd = NULL, *y_sqrd\
    \ = NULL, *qr = NULL, *qnr = NULL;\n-\tHMAC_CTX *ctx = NULL;\n-\tuint8_t pwe_digest[SHA256_DIGEST_LENGTH],\
    \ *prfbuf = NULL, *xbuf = NULL, *pm1buf = NULL, ctr;\n-\tint nid, is_odd, primebitlen,\
    \ primebytelen, ret = 0, found = 0, mask;\n-\tint save, i, rbits, qr_or_qnr, save_is_odd\
    \ = 0, cmp;\n-\tunsigned int skip;\n-\n-\tctx = HMAC_CTX_new();\n-\tif (ctx ==\
    \ NULL) {\n-\t\tDEBUG(\"failed allocating HMAC context\");\n-\t\tgoto fail;\n\
    -\t}\n+\tBIGNUM\t\t*x_candidate = NULL, *rnd = NULL, *y_sqrd = NULL, *qr = NULL,\
    \ *qnr = NULL, *y1 = NULL, *y2 = NULL, *y = NULL, *exp = NULL;\n+\tEVP_MD_CTX\t\
    *hmac_ctx;\n+\tEVP_PKEY\t*hmac_pkey;\n+\tuint8_t\t\tpwe_digest[SHA256_DIGEST_LENGTH],\
    \ *prfbuf = NULL, *xbuf = NULL, *pm1buf = NULL, *y1buf = NULL, *y2buf = NULL,\
    \ *ybuf = NULL, ctr;\n+\tint\t\tnid, is_odd, primebitlen, primebytelen, ret =\
    \ 0, found = 0, mask;\n+\tint\t\tsave, i, rbits, qr_or_qnr, save_is_odd = 0, cmp;\n\
    +\tunsigned int\tskip;\n+\n+\tMEM(hmac_ctx = EVP_MD_CTX_new());\n+\tMEM(hmac_pkey\
    \ = EVP_PKEY_new_mac_key(EVP_PKEY_HMAC, NULL, allzero, sizeof(allzero)));\n \n\
    \ \tswitch (grp_num) { /* from IANA registry for IKE D-H groups */\n \tcase 19:\n\
    @@ -303,7 +301,11 @@ int compute_password_element (REQUEST *request, pwd_session_t\
    \ *session, uint16_t\n \t    ((qr = consttime_BN()) == NULL) ||\n \t    ((qnr\
    \ = consttime_BN()) == NULL) ||\n \t    ((x_candidate = consttime_BN()) == NULL)\
    \ ||\n-\t    ((y_sqrd = consttime_BN()) == NULL)) {\n+\t    ((y_sqrd = consttime_BN())\
    \ == NULL) ||\n+\t    ((y1 = consttime_BN()) == NULL) ||\n+\t    ((y2 = consttime_BN())\
    \ == NULL) ||\n+\t    ((y = consttime_BN()) == NULL) ||\n+        ((exp = consttime_BN())\
    \ == NULL)) {\n \t\tDEBUG(\"unable to create bignums\");\n \t\tgoto fail;\n \t\
    }\n@@ -332,6 +334,19 @@ int compute_password_element (REQUEST *request, pwd_session_t\
    \ *session, uint16_t\n \t\tDEBUG(\"unable to alloc space for pm1 buffer\");\n\
    \ \t\tgoto fail;\n \t}\n+\tif ((y1buf = talloc_zero_array(request, uint8_t, primebytelen))\
    \ == NULL) {\n+\t\tDEBUG(\"unable to alloc space for y1 buffer\");\n+\t\tgoto\
    \ fail;\n+\t}\n+\tif ((y2buf = talloc_zero_array(request, uint8_t, primebytelen))\
    \ == NULL) {\n+\t\tDEBUG(\"unable to alloc space for y2 buffer\");\n+\t\tgoto\
    \ fail;\n+\t}\n+\tif ((ybuf = talloc_zero_array(request, uint8_t, primebytelen))\
    \ == NULL) {\n+\t\tDEBUG(\"unable to alloc space for y buffer\");\n+\t\tgoto fail;\n\
    +\t}\n+\n \n \t/*\n \t* derive random quadradic residue and quadratic non-residue\n\
    @@ -361,13 +376,19 @@ int compute_password_element (REQUEST *request, pwd_session_t\
    \ *session, uint16_t\n \t\t *\tpwd-seed = H(token | peer-id | server-id | password\
    \ |\n \t\t *\t\t     counter)\n \t\t */\n-\t\tHMAC_Init_ex(ctx, allzero, SHA256_DIGEST_LENGTH,\
    \ EVP_sha256(),NULL);\n-\t\tHMAC_Update(ctx, (uint8_t *)token, sizeof(*token));\n\
    -\t\tHMAC_Update(ctx, (uint8_t const *)id_peer, id_peer_len);\n-\t\tHMAC_Update(ctx,\
    \ (uint8_t const *)id_server, id_server_len);\n-\t\tHMAC_Update(ctx, (uint8_t\
    \ const *)password, password_len);\n-\t\tHMAC_Update(ctx, (uint8_t *)&ctr, sizeof(ctr));\n\
    -\t\tpwd_hmac_final(ctx, pwe_digest);\n+\t\tEVP_DigestSignInit(hmac_ctx, NULL,\
    \ EVP_sha256(), NULL, hmac_pkey);\n+\t\tEVP_DigestSignUpdate(hmac_ctx, (uint8_t\
    \ *)token, sizeof(*token));\n+\t\tEVP_DigestSignUpdate(hmac_ctx, (uint8_t const\
    \ *)id_peer, id_peer_len);\n+\t\tEVP_DigestSignUpdate(hmac_ctx, (uint8_t const\
    \ *)id_server, id_server_len);\n+\t\tEVP_DigestSignUpdate(hmac_ctx, (uint8_t const\
    \ *)password, password_len);\n+\t\tEVP_DigestSignUpdate(hmac_ctx, (uint8_t *)&ctr,\
    \ sizeof(ctr));\n+\n+\t\t{\n+\t\t\tsize_t mdlen = SHA256_DIGEST_LENGTH;\n+\n+\t\
    \t\tEVP_DigestSignFinal(hmac_ctx, pwe_digest, &mdlen);\n+\t\t\tEVP_MD_CTX_reset(hmac_ctx);\n\
    +\t\t}\n \n \t\tBN_bin2bn(pwe_digest, SHA256_DIGEST_LENGTH, rnd);\n \t\teap_pwd_kdf(pwe_digest,\
    \ SHA256_DIGEST_LENGTH, \"EAP-pwd Hunting And Pecking\",\n@@ -401,7 +422,7 @@\
    \ int compute_password_element (REQUEST *request, pwd_session_t *session, uint16_t\n\
    \ \t\t* need to unambiguously identify the solution, if there is\n \t\t* one..\n\
    \ \t\t*/\n-\t\tis_odd = BN_is_odd(rnd) ? 1 : 0;\n+\t\tis_odd = BN_is_odd(rnd);\n\
    \ \n \t\t/*\n \t\t* check whether x^3 + a*x + b is a quadratic residue\n@@ -444,8\
    \ +465,21 @@ int compute_password_element (REQUEST *request, pwd_session_t *session,\
    \ uint16_t\n \t* now we can savely construct PWE\n \t*/\n \tBN_bin2bn(xbuf, primebytelen,\
    \ x_candidate);\n-\tif (!EC_POINT_set_compressed_coordinates(session->group, session->pwe,\n\
    -\t\t\t\t\t\t     x_candidate, save_is_odd, NULL)) {\n+\tdo_equation(session->group,\
    \ y_sqrd, x_candidate, session->bnctx);\n+\tif ( !BN_add(exp, session->prime,\
    \ BN_value_one()) ||\n+\t\t !BN_rshift(exp, exp, 2) ||\n+\t\t !BN_mod_exp_mont_consttime(y1,\
    \ y_sqrd, exp, session->prime, session->bnctx, NULL) ||\n+\t\t !BN_sub(y2, session->prime,\
    \ y1) ||\n+\t\t !BN_bn2bin(y1, y1buf) ||\n+\t\t !BN_bn2bin(y2, y2buf)) {\n+\t\t\
    DEBUG(\"unable to compute y\");\n+\t\tgoto fail;\n+\t}\n+\tmask = const_time_eq(save_is_odd,\
    \ BN_is_odd(y1));\n+\tconst_time_select_bin(mask, y1buf, y2buf, primebytelen,\
    \ ybuf);\n+\tif (BN_bin2bn(ybuf, primebytelen, y) == NULL ||\n+\t\t!EC_POINT_set_affine_coordinates(session->group,\
    \ session->pwe, x_candidate, y, session->bnctx)) {\n+\t\tDEBUG(\"unable to set\
    \ point coordinate\");\n \t\tgoto fail;\n \t}\n \n@@ -461,12 +495,20 @@ int compute_password_element\
    \ (REQUEST *request, pwd_session_t *session, uint16_t\n \tBN_clear_free(qr);\n\
    \ \tBN_clear_free(qnr);\n \tBN_clear_free(rnd);\n+\tBN_clear_free(y1);\n+\tBN_clear_free(y2);\n\
    +\tBN_clear_free(y);\n+\tBN_clear_free(exp);\n \n \tif (prfbuf) talloc_free(prfbuf);\n\
    \ \tif (xbuf) talloc_free(xbuf);\n \tif (pm1buf) talloc_free(pm1buf);\n+\tif (y1buf)\
    \ talloc_free(y1buf);\n+\tif (y2buf) talloc_free(y2buf);\n+\tif (ybuf) talloc_free(ybuf);\n\
    \ \n-\tHMAC_CTX_free(ctx);\n+\tEVP_MD_CTX_free(hmac_ctx);\n+\tEVP_PKEY_free(hmac_pkey);\n\
    \ \n \treturn ret;\n }"
  identifiers:
  - CVE-2022-41859
  - CWE-522
  overview: In freeradius, the EAP-PWD function compute_password_element() leaks information
    about the password which allows an attacker to substantially reduce the size of
    an offline dictionary attack.
  references:
  - source: secalert@redhat.com
    tags:
    - Patch
    - Vendor Advisory
    url: https://freeradius.org/security/
  - source: secalert@redhat.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/FreeRADIUS/freeradius-server/commit/9e5e8f2f
  title: In freeradius, the EAP-PWD function compute_password_element() leaks information
    about the password which allows an attacker to substantially reduce the size of
    an offline dictionary attack.
- diff_content:
  - "--- a/src/modules/rlm_eap/libeap/eapsimlib.c\n+++ b/src/modules/rlm_eap/libeap/eapsimlib.c\n\
    @@ -307,42 +307,77 @@ int unmap_eapsim_basictypes(RADIUS_PACKET *r,\n \tnewvp->vp_length\
    \ = 1;\n \tfr_pair_add(&(r->vps), newvp);\n \n+\t/*\n+\t *\tEAP-SIM has a 1 octet\
    \ of subtype, and 2 octets\n+\t *\treserved.\n+\t */\n \tattr     += 3;\n \tattrlen\
    \  -= 3;\n \n-\t/* now, loop processing each attribute that we find */\n-\twhile(attrlen\
    \ > 0) {\n+\t/*\n+\t *\tLoop over each attribute.  The format is:\n+\t *\n+\t\
    \ *\t1 octet of type\n+\t *\t1 octet of length (value 1..255)\n+\t *\t((4 * length)\
    \ - 2) octets of data.\n+\t */\n+\twhile (attrlen > 0) {\n \t\tuint8_t *p;\n \n\
    -\t\tif(attrlen < 2) {\n+\t\tif (attrlen < 2) {\n \t\t\tfr_strerror_printf(\"\
    EAP-Sim attribute %d too short: %d < 2\", es_attribute_count, attrlen);\n \t\t\
    \treturn 0;\n \t\t}\n \n+\t\tif (!attr[1]) {\n+\t\t\tfr_strerror_printf(\"EAP-Sim\
    \ attribute %d (no.%d) has no data\", eapsim_attribute,\n+\t\t\t\t\t   es_attribute_count);\n\
    +\t\t\treturn 0;\n+\t\t}\n+\n \t\teapsim_attribute = attr[0];\n \t\teapsim_len\
    \ = attr[1] * 4;\n \n+\t\t/*\n+\t\t *\tThe length includes the 2-byte header.\n\
    +\t\t */\n \t\tif (eapsim_len > attrlen) {\n \t\t\tfr_strerror_printf(\"EAP-Sim\
    \ attribute %d (no.%d) has length longer than data (%d > %d)\",\n \t\t\t\t\t \
    \  eapsim_attribute, es_attribute_count, eapsim_len, attrlen);\n \t\t\treturn\
    \ 0;\n \t\t}\n \n-\t\tif(eapsim_len > MAX_STRING_LEN) {\n-\t\t\teapsim_len = MAX_STRING_LEN;\n\
    -\t\t}\n-\t\tif (eapsim_len < 2) {\n-\t\t\tfr_strerror_printf(\"EAP-Sim attribute\
    \ %d (no.%d) has length too small\", eapsim_attribute,\n-\t\t\t\t\t   es_attribute_count);\n\
    -\t\t\treturn 0;\n-\t\t}\n+\t\tnewvp = fr_pair_afrom_num(r, eapsim_attribute +\
    \ PW_EAP_SIM_BASE, 0);\n+\t\tif (!newvp) {\n+\t\t\t/*\n+\t\t\t *\tRFC 4186 Section\
    \ 8.1 says 0..127 are\n+\t\t\t *\t\"non-skippable\".  If one such\n+\t\t\t *\t\
    attribute is found and we don't\n+\t\t\t *\tunderstand it, the server has to send:\n\
    +\t\t\t *\n+\t\t\t *\tEAP-Request/SIM/Notification packet with an\n+\t\t\t *\t\
    (AT_NOTIFICATION code, which implies general failure (\"General\n+\t\t\t *\tfailure\
    \ after authentication\" (0), or \"General failure\" (16384),\n+\t\t\t *\tdepending\
    \ on the phase of the exchange), which terminates the\n+\t\t\t *\tauthentication\
    \ exchange.\n+\t\t\t */\n+\t\t\tif (eapsim_attribute <= 127) {\n+\t\t\t\tfr_strerror_printf(\"\
    Unknown mandatory attribute %d, failing\",\n+\t\t\t\t\t\t   eapsim_attribute);\n\
    +\t\t\t\treturn 0;\n+\t\t\t}\n \n-\t\tnewvp = fr_pair_afrom_num(r, eapsim_attribute+PW_EAP_SIM_BASE,\
    \ 0);\n-\t\tnewvp->vp_length = eapsim_len-2;\n-\t\tnewvp->vp_octets = p = talloc_array(newvp,\
    \ uint8_t, newvp->vp_length);\n-\t\tmemcpy(p, &attr[2], eapsim_len-2);\n-\t\t\
    fr_pair_add(&(r->vps), newvp);\n-\t\tnewvp = NULL;\n+\t\t} else {\n+\t\t\t/*\n\
    +\t\t\t *\tIt's known, ccount for header, and\n+\t\t\t *\tcopy the value over.\n\
    +\t\t\t */\n+\t\t\tnewvp->vp_length = eapsim_len - 2;\n+\n+\t\t\tnewvp->vp_octets\
    \ = p = talloc_array(newvp, uint8_t, newvp->vp_length);\n+\t\t\tmemcpy(p, &attr[2],\
    \ newvp->vp_length);\n+\t\t\tfr_pair_add(&(r->vps), newvp);\n+\t\t}\n \n \t\t\
    /* advance pointers, decrement length */\n \t\tattr += eapsim_len;"
  identifiers:
  - CVE-2022-41860
  - CWE-476
  overview: In freeradius, when an EAP-SIM supplicant sends an unknown SIM option,
    the server will try to look that option up in the internal dictionaries. This
    lookup will fail, but the SIM code will not check for that failure. Instead, it
    will dereference a NULL pointer, and cause the server to crash.
  references:
  - source: secalert@redhat.com
    tags:
    - Patch
    - Vendor Advisory
    url: https://freeradius.org/security/
  - source: secalert@redhat.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/FreeRADIUS/freeradius-server/commit/f1cdbb33ec61c4a64a
  title: In freeradius, when an EAP-SIM supplicant sends an unknown SIM option, the
    server will try to look that option up in the internal dictionaries. This lookup
    will fail, but the SIM code will not check for that failure. Instead, it will
    dereference a NULL pointer, and cause the server to crash.
- diff_content:
  - "--- a/src/lib/filters.c\n+++ b/src/lib/filters.c\n@@ -1205,13 +1205,19 @@ void\
    \ print_abinary(char *out, size_t outlen, uint8_t const *data, size_t len, in\n\
    \ \t\t\t}\n \t\t}\n \t} else if (filter->type == RAD_FILTER_GENERIC) {\n-\t\t\
    int count;\n+\t\tsize_t count, masklen;\n+\n+\t\tmasklen = ntohs(filter->u.generic.len);\n\
    +\t\tif (masklen >= sizeof(filter->u.generic.mask)) {\n+\t\t\t*p = '\\0';\n+\t\
    \t\treturn;\n+\t\t}\n \n \t\ti = snprintf(p, outlen, \" %u \", (unsigned int)\
    \ ntohs(filter->u.generic.offset));\n \t\tp += i;\n \n \t\t/* show the mask */\n\
    -\t\tfor (count = 0; count < ntohs(filter->u.generic.len); count++) {\n+\t\tfor\
    \ (count = 0; count < masklen; count++) {\n \t\t\ti = snprintf(p, outlen, \"%02x\"\
    , filter->u.generic.mask[count]);\n \t\t\tp += i;\n \t\t\toutlen -= i;\n@@ -1222,7\
    \ +1228,7 @@ void print_abinary(char *out, size_t outlen, uint8_t const *data,\
    \ size_t len, in\n \t\toutlen--;\n \n \t\t/* show the value */\n-\t\tfor (count\
    \ = 0; count < ntohs(filter->u.generic.len); count++) {\n+\t\tfor (count = 0;\
    \ count < masklen; count++) {\n \t\t\ti = snprintf(p, outlen, \"%02x\", filter->u.generic.value[count]);\n\
    \ \t\t\tp += i;\n \t\t\toutlen -= i;"
  identifiers:
  - CVE-2022-41861
  - CWE-20
  overview: A flaw was found in freeradius. A malicious RADIUS client or home server
    can send a malformed abinary attribute which can cause the server to crash.
  references:
  - source: secalert@redhat.com
    tags:
    - Patch
    - Vendor Advisory
    url: https://freeradius.org/security/
  - source: secalert@redhat.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/FreeRADIUS/freeradius-server/commit/0ec2b39d260e
  title: A flaw was found in freeradius. A malicious RADIUS client or home server
    can send a malformed abinary attribute which can cause the server to crash.
- diff_content:
  - "--- a/src/low-level/imap/mailimap_types.c\n+++ b/src/low-level/imap/mailimap_types.c\n\
    @@ -1389,9 +1389,11 @@ void\n mailimap_mailbox_data_status_free(struct mailimap_mailbox_data_status\
    \ * info)\n {\n   mailimap_mailbox_free(info->st_mailbox);\n-  clist_foreach(info->st_info_list,\
    \ (clist_func) mailimap_status_info_free,\n-\t\t NULL);\n-  clist_free(info->st_info_list);\n\
    +  if (info->st_info_list != NULL) {\n+    clist_foreach(info->st_info_list, (clist_func)\
    \ mailimap_status_info_free,\n+      NULL);\n+    clist_free(info->st_info_list);\n\
    +  }\n   free(info);\n }\n "
  identifiers:
  - CVE-2022-4121
  - CWE-476
  overview: In libetpan a null pointer dereference in mailimap_mailbox_data_status_free
    in low-level/imap/mailimap_types.c was found that could lead to a remote denial
    of service or other potential consequences.
  references:
  - source: patrick@puiterwijk.org
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/dinhvh/libetpan/commit/5c9eb6b6ba64c4eb927d7a902317410181aacbba
  - source: patrick@puiterwijk.org
    tags:
    - Exploit
    - Issue Tracking
    - Patch
    - Third Party Advisory
    url: https://github.com/dinhvh/libetpan/issues/420
  title: In libetpan a null pointer dereference in mailimap_mailbox_data_status_free
    in low-level/imap/mailimap_types.c was found that could lead to a remote denial
    of service or other potential consequences.
- diff_content:
  - "--- a/attr.c\n+++ b/attr.c\n@@ -24,7 +24,7 @@ static const char git_attr__unknown[]\
    \ = \"(builtin)unknown\";\n #define ATTR__UNKNOWN git_attr__unknown\n \n struct\
    \ git_attr {\n-\tint attr_nr; /* unique attribute number */\n+\tunsigned int attr_nr;\
    \ /* unique attribute number */\n \tchar name[FLEX_ARRAY]; /* attribute name */\n\
    \ };\n \n@@ -206,7 +206,7 @@ static void report_invalid_attr(const char *name,\
    \ size_t len,\n  * dictionary.  If no entry is found, create a new attribute and\
    \ store it in\n  * the dictionary.\n  */\n-static const struct git_attr *git_attr_internal(const\
    \ char *name, int namelen)\n+static const struct git_attr *git_attr_internal(const\
    \ char *name, size_t namelen)\n {\n \tstruct git_attr *a;\n \n@@ -222,8 +222,8\
    \ @@ static const struct git_attr *git_attr_internal(const char *name, int namelen)\n\
    \ \t\ta->attr_nr = hashmap_get_size(&g_attr_hashmap.map);\n \n \t\tattr_hashmap_add(&g_attr_hashmap,\
    \ a->name, namelen, a);\n-\t\tassert(a->attr_nr ==\n-\t\t       (hashmap_get_size(&g_attr_hashmap.map)\
    \ - 1));\n+\t\tif (a->attr_nr != hashmap_get_size(&g_attr_hashmap.map) - 1)\n\
    +\t\t\tdie(_(\"unable to add additional attribute\"));\n \t}\n \n \thashmap_unlock(&g_attr_hashmap);\n\
    @@ -268,7 +268,7 @@ struct match_attr {\n \t\tconst struct git_attr *attr;\n \t\
    } u;\n \tchar is_macro;\n-\tunsigned num_attr;\n+\tsize_t num_attr;\n \tstruct\
    \ attr_state state[FLEX_ARRAY];\n };\n \n@@ -289,7 +289,7 @@ static const char\
    \ *parse_attr(const char *src, int lineno, const char *cp,\n \t\t\t      struct\
    \ attr_state *e)\n {\n \tconst char *ep, *equals;\n-\tint len;\n+\tsize_t len;\n\
    \ \n \tep = cp + strcspn(cp, blank);\n \tequals = strchr(cp, '=');\n@@ -333,8\
    \ +333,7 @@ static const char *parse_attr(const char *src, int lineno, const char\
    \ *cp,\n static struct match_attr *parse_attr_line(const char *line, const char\
    \ *src,\n \t\t\t\t\t  int lineno, unsigned flags)\n {\n-\tint namelen;\n-\tint\
    \ num_attr, i;\n+\tsize_t namelen, num_attr, i;\n \tconst char *cp, *name, *states;\n\
    \ \tstruct match_attr *res = NULL;\n \tint is_macro;\n@@ -345,6 +344,11 @@ static\
    \ struct match_attr *parse_attr_line(const char *line, const char *src,\n \t\t\
    return NULL;\n \tname = cp;\n \n+\tif (strlen(line) >= ATTR_MAX_LINE_LENGTH) {\n\
    +\t\twarning(_(\"ignoring overly long attributes line %d\"), lineno);\n+\t\treturn\
    \ NULL;\n+\t}\n+\n \tif (*cp == '\"' && !unquote_c_style(&pattern, name, &states))\
    \ {\n \t\tname = pattern.buf;\n \t\tnamelen = pattern.len;\n@@ -381,10 +385,9\
    \ @@ static struct match_attr *parse_attr_line(const char *line, const char *src,\n\
    \ \t\t\tgoto fail_return;\n \t}\n \n-\tres = xcalloc(1,\n-\t\t      sizeof(*res)\
    \ +\n-\t\t      sizeof(struct attr_state) * num_attr +\n-\t\t      (is_macro ?\
    \ 0 : namelen + 1));\n+\tres = xcalloc(1, st_add3(sizeof(*res),\n+\t\t\t\t st_mult(sizeof(struct\
    \ attr_state), num_attr),\n+\t\t\t\t is_macro ? 0 : namelen + 1));\n \tif (is_macro)\
    \ {\n \t\tres->u.attr = git_attr_internal(name, namelen);\n \t} else {\n@@ -447,11\
    \ +450,12 @@ struct attr_stack {\n \n static void attr_stack_free(struct attr_stack\
    \ *e)\n {\n-\tint i;\n+\tunsigned i;\n \tfree(e->origin);\n \tfor (i = 0; i <\
    \ e->num_matches; i++) {\n \t\tstruct match_attr *a = e->attrs[i];\n-\t\tint j;\n\
    +\t\tsize_t j;\n+\n \t\tfor (j = 0; j < a->num_attr; j++) {\n \t\t\tconst char\
    \ *setto = a->state[j].setto;\n \t\t\tif (setto == ATTR__TRUE ||\n@@ -660,8 +664,8\
    \ @@ static void handle_attr_line(struct attr_stack *res,\n \ta = parse_attr_line(line,\
    \ src, lineno, flags);\n \tif (!a)\n \t\treturn;\n-\tALLOC_GROW(res->attrs, res->num_matches\
    \ + 1, res->alloc);\n-\tres->attrs[res->num_matches++] = a;\n+\tALLOC_GROW_BY(res->attrs,\
    \ res->num_matches, 1, res->alloc);\n+\tres->attrs[res->num_matches - 1] = a;\n\
    \ }\n \n static struct attr_stack *read_attr_from_array(const char **list)\n@@\
    \ -701,11 +705,12 @@ void git_attr_set_direction(enum git_attr_direction new_direction)\n\
    \ \n static struct attr_stack *read_attr_from_file(const char *path, unsigned\
    \ flags)\n {\n+\tstruct strbuf buf = STRBUF_INIT;\n \tint fd;\n \tFILE *fp;\n\
    \ \tstruct attr_stack *res;\n-\tchar buf[2048];\n \tint lineno = 0;\n+\tstruct\
    \ stat st;\n \n \tif (flags & READ_ATTR_NOFOLLOW)\n \t\tfd = open_nofollow(path,\
    \ O_RDONLY);\n@@ -717,15 +722,26 @@ static struct attr_stack *read_attr_from_file(const\
    \ char *path, unsigned flags)\n \t\treturn NULL;\n \t}\n \tfp = xfdopen(fd, \"\
    r\");\n+\tif (fstat(fd, &st)) {\n+\t\twarning_errno(_(\"cannot fstat gitattributes\
    \ file '%s'\"), path);\n+\t\tfclose(fp);\n+\t\treturn NULL;\n+\t}\n+\tif (st.st_size\
    \ >= ATTR_MAX_FILE_SIZE) {\n+\t\twarning(_(\"ignoring overly large gitattributes\
    \ file '%s'\"), path);\n+\t\tfclose(fp);\n+\t\treturn NULL;\n+\t}\n \n \tCALLOC_ARRAY(res,\
    \ 1);\n-\twhile (fgets(buf, sizeof(buf), fp)) {\n-\t\tchar *bufp = buf;\n-\t\t\
    if (!lineno)\n-\t\t\tskip_utf8_bom(&bufp, strlen(bufp));\n-\t\thandle_attr_line(res,\
    \ bufp, path, ++lineno, flags);\n+\twhile (strbuf_getline(&buf, fp) != EOF) {\n\
    +\t\tif (!lineno && starts_with(buf.buf, utf8_bom))\n+\t\t\tstrbuf_remove(&buf,\
    \ 0, strlen(utf8_bom));\n+\t\thandle_attr_line(res, buf.buf, path, ++lineno, flags);\n\
    \ \t}\n+\n \tfclose(fp);\n+\tstrbuf_release(&buf);\n \treturn res;\n }\n \n@@\
    \ -736,6 +752,7 @@ static struct attr_stack *read_attr_from_index(struct index_state\
    \ *istate,\n \tstruct attr_stack *res;\n \tchar *buf, *sp;\n \tint lineno = 0;\n\
    +\tunsigned long size;\n \n \tif (!istate)\n \t\treturn NULL;\n@@ -754,9 +771,13\
    \ @@ static struct attr_stack *read_attr_from_index(struct index_state *istate,\n\
    \ \tif (!path_in_cone_mode_sparse_checkout(path, istate))\n \t\treturn NULL;\n\
    \ \n-\tbuf = read_blob_data_from_index(istate, path, NULL);\n+\tbuf = read_blob_data_from_index(istate,\
    \ path, &size);\n \tif (!buf)\n \t\treturn NULL;\n+\tif (size >= ATTR_MAX_FILE_SIZE)\
    \ {\n+\t\twarning(_(\"ignoring overly large gitattributes blob '%s'\"), path);\n\
    +\t\treturn NULL;\n+\t}\n \n \tCALLOC_ARRAY(res, 1);\n \tfor (sp = buf; *sp; )\
    \ {\n@@ -999,12 +1020,12 @@ static int macroexpand_one(struct all_attrs_item *all_attrs,\
    \ int nr, int rem);\n static int fill_one(struct all_attrs_item *all_attrs,\n\
    \ \t\t    const struct match_attr *a, int rem)\n {\n-\tint i;\n+\tsize_t i;\n\
    \ \n-\tfor (i = a->num_attr - 1; rem > 0 && i >= 0; i--) {\n-\t\tconst struct\
    \ git_attr *attr = a->state[i].attr;\n+\tfor (i = a->num_attr; rem > 0 && i >\
    \ 0; i--) {\n+\t\tconst struct git_attr *attr = a->state[i - 1].attr;\n \t\tconst\
    \ char **n = &(all_attrs[attr->attr_nr].value);\n-\t\tconst char *v = a->state[i].setto;\n\
    +\t\tconst char *v = a->state[i - 1].setto;\n \n \t\tif (*n == ATTR__UNKNOWN)\
    \ {\n \t\t\t*n = v;\n@@ -1020,11 +1041,11 @@ static int fill(const char *path,\
    \ int pathlen, int basename_offset,\n \t\tstruct all_attrs_item *all_attrs, int\
    \ rem)\n {\n \tfor (; rem > 0 && stack; stack = stack->prev) {\n-\t\tint i;\n\
    +\t\tunsigned i;\n \t\tconst char *base = stack->origin ? stack->origin : \"\"\
    ;\n \n-\t\tfor (i = stack->num_matches - 1; 0 < rem && 0 <= i; i--) {\n-\t\t\t\
    const struct match_attr *a = stack->attrs[i];\n+\t\tfor (i = stack->num_matches;\
    \ 0 < rem && 0 < i; i--) {\n+\t\t\tconst struct match_attr *a = stack->attrs[i\
    \ - 1];\n \t\t\tif (a->is_macro)\n \t\t\t\tcontinue;\n \t\t\tif (path_matches(path,\
    \ pathlen, basename_offset,\n@@ -1055,11 +1076,11 @@ static void determine_macros(struct\
    \ all_attrs_item *all_attrs,\n \t\t\t     const struct attr_stack *stack)\n {\n\
    \ \tfor (; stack; stack = stack->prev) {\n-\t\tint i;\n-\t\tfor (i = stack->num_matches\
    \ - 1; i >= 0; i--) {\n-\t\t\tconst struct match_attr *ma = stack->attrs[i];\n\
    +\t\tunsigned i;\n+\t\tfor (i = stack->num_matches; i > 0; i--) {\n+\t\t\tconst\
    \ struct match_attr *ma = stack->attrs[i - 1];\n \t\t\tif (ma->is_macro) {\n-\t\
    \t\t\tint n = ma->u.attr->attr_nr;\n+\t\t\t\tunsigned int n = ma->u.attr->attr_nr;\n\
    \ \t\t\t\tif (!all_attrs[n].macro) {\n \t\t\t\t\tall_attrs[n].macro = ma;\n \t\
    \t\t\t}\n@@ -1111,7 +1132,7 @@ void git_check_attr(struct index_state *istate,\n\
    \ \tcollect_some_attrs(istate, path, check);\n \n \tfor (i = 0; i < check->nr;\
    \ i++) {\n-\t\tsize_t n = check->items[i].attr->attr_nr;\n+\t\tunsigned int n\
    \ = check->items[i].attr->attr_nr;\n \t\tconst char *value = check->all_attrs[n].value;\n\
    \ \t\tif (value == ATTR__UNKNOWN)\n \t\t\tvalue = ATTR__UNSET;"
  - "--- a/column.c\n+++ b/column.c\n@@ -23,7 +23,7 @@ struct column_data {\n /* return\
    \ length of 's' in letters, ANSI escapes stripped */\n static int item_length(const\
    \ char *s)\n {\n-\treturn utf8_strnwidth(s, -1, 1);\n+\treturn utf8_strnwidth(s,\
    \ strlen(s), 1);\n }\n \n /*"
  - "--- a/fsck.c\n+++ b/fsck.c\n@@ -2,6 +2,7 @@\n #include \"object-store.h\"\n #include\
    \ \"repository.h\"\n #include \"object.h\"\n+#include \"attr.h\"\n #include \"\
    blob.h\"\n #include \"tree.h\"\n #include \"tree-walk.h\"\n@@ -614,17 +615,22\
    \ @@ static int fsck_tree(const struct object_id *tree_oid,\n \t\t\t\t\t\t \"\
    .gitmodules is a symbolic link\");\n \t\t}\n \n+\t\tif (is_hfs_dotgitattributes(name)\
    \ || is_ntfs_dotgitattributes(name)) {\n+\t\t\tif (!S_ISLNK(mode))\n+\t\t\t\t\
    oidset_insert(&options->gitattributes_found,\n+\t\t\t\t\t      entry_oid);\n+\t\
    \t\telse\n+\t\t\t\tretval += report(options, tree_oid, OBJ_TREE,\n+\t\t\t\t\t\t\
    \ FSCK_MSG_GITATTRIBUTES_SYMLINK,\n+\t\t\t\t\t\t \".gitattributes is a symlink\"\
    );\n+\t\t}\n+\n \t\tif (S_ISLNK(mode)) {\n \t\t\tif (is_hfs_dotgitignore(name)\
    \ ||\n \t\t\t    is_ntfs_dotgitignore(name))\n \t\t\t\tretval += report(options,\
    \ tree_oid, OBJ_TREE,\n \t\t\t\t\t\t FSCK_MSG_GITIGNORE_SYMLINK,\n \t\t\t\t\t\t\
    \ \".gitignore is a symlink\");\n-\t\t\tif (is_hfs_dotgitattributes(name) ||\n\
    -\t\t\t    is_ntfs_dotgitattributes(name))\n-\t\t\t\tretval += report(options,\
    \ tree_oid, OBJ_TREE,\n-\t\t\t\t\t\t FSCK_MSG_GITATTRIBUTES_SYMLINK,\n-\t\t\t\t\
    \t\t \".gitattributes is a symlink\");\n \t\t\tif (is_hfs_dotmailmap(name) ||\n\
    \ \t\t\t    is_ntfs_dotmailmap(name))\n \t\t\t\tretval += report(options, tree_oid,\
    \ OBJ_TREE,\n@@ -1159,38 +1165,70 @@ static int fsck_gitmodules_fn(const char\
    \ *var, const char *value, void *vdata)\n static int fsck_blob(const struct object_id\
    \ *oid, const char *buf,\n \t\t     unsigned long size, struct fsck_options *options)\n\
    \ {\n-\tstruct fsck_gitmodules_data data;\n-\tstruct config_options config_opts\
    \ = { 0 };\n-\n-\tif (!oidset_contains(&options->gitmodules_found, oid))\n-\t\t\
    return 0;\n-\toidset_insert(&options->gitmodules_done, oid);\n+\tint ret = 0;\n\
    \ \n \tif (object_on_skiplist(options, oid))\n \t\treturn 0;\n \n-\tif (!buf)\
    \ {\n-\t\t/*\n-\t\t * A missing buffer here is a sign that the caller found the\n\
    -\t\t * blob too gigantic to load into memory. Let's just consider\n-\t\t * that\
    \ an error.\n-\t\t */\n-\t\treturn report(options, oid, OBJ_BLOB,\n-\t\t\t   \
    \   FSCK_MSG_GITMODULES_LARGE,\n-\t\t\t      \".gitmodules too large to parse\"\
    );\n+\tif (oidset_contains(&options->gitmodules_found, oid)) {\n+\t\tstruct config_options\
    \ config_opts = { 0 };\n+\t\tstruct fsck_gitmodules_data data;\n+\n+\t\toidset_insert(&options->gitmodules_done,\
    \ oid);\n+\n+\t\tif (!buf) {\n+\t\t\t/*\n+\t\t\t * A missing buffer here is a\
    \ sign that the caller found the\n+\t\t\t * blob too gigantic to load into memory.\
    \ Let's just consider\n+\t\t\t * that an error.\n+\t\t\t */\n+\t\t\treturn report(options,\
    \ oid, OBJ_BLOB,\n+\t\t\t\t\tFSCK_MSG_GITMODULES_LARGE,\n+\t\t\t\t\t\".gitmodules\
    \ too large to parse\");\n+\t\t}\n+\n+\t\tdata.oid = oid;\n+\t\tdata.options =\
    \ options;\n+\t\tdata.ret = 0;\n+\t\tconfig_opts.error_action = CONFIG_ERROR_SILENT;\n\
    +\t\tif (git_config_from_mem(fsck_gitmodules_fn, CONFIG_ORIGIN_BLOB,\n+\t\t\t\t\
    \t\".gitmodules\", buf, size, &data, &config_opts))\n+\t\t\tdata.ret |= report(options,\
    \ oid, OBJ_BLOB,\n+\t\t\t\t\tFSCK_MSG_GITMODULES_PARSE,\n+\t\t\t\t\t\"could not\
    \ parse gitmodules blob\");\n+\t\tret |= data.ret;\n \t}\n \n-\tdata.oid = oid;\n\
    -\tdata.options = options;\n-\tdata.ret = 0;\n-\tconfig_opts.error_action = CONFIG_ERROR_SILENT;\n\
    -\tif (git_config_from_mem(fsck_gitmodules_fn, CONFIG_ORIGIN_BLOB,\n-\t\t\t\t\"\
    .gitmodules\", buf, size, &data, &config_opts))\n-\t\tdata.ret |= report(options,\
    \ oid, OBJ_BLOB,\n-\t\t\t\t   FSCK_MSG_GITMODULES_PARSE,\n-\t\t\t\t   \"could\
    \ not parse gitmodules blob\");\n-\n-\treturn data.ret;\n+\tif (oidset_contains(&options->gitattributes_found,\
    \ oid)) {\n+\t\tconst char *ptr;\n+\n+\t\toidset_insert(&options->gitattributes_done,\
    \ oid);\n+\n+\t\tif (!buf || size > ATTR_MAX_FILE_SIZE) {\n+\t\t\t/*\n+\t\t\t\
    \ * A missing buffer here is a sign that the caller found the\n+\t\t\t * blob\
    \ too gigantic to load into memory. Let's just consider\n+\t\t\t * that an error.\n\
    +\t\t\t */\n+\t\t\treturn report(options, oid, OBJ_BLOB,\n+\t\t\t\t\tFSCK_MSG_GITATTRIBUTES_LARGE,\n\
    +\t\t\t\t\t\".gitattributes too large to parse\");\n+\t\t}\n+\n+\t\tfor (ptr =\
    \ buf; *ptr; ) {\n+\t\t\tconst char *eol = strchrnul(ptr, '\\n');\n+\t\t\tif (eol\
    \ - ptr >= ATTR_MAX_LINE_LENGTH) {\n+\t\t\t\tret |= report(options, oid, OBJ_BLOB,\n\
    +\t\t\t\t\t      FSCK_MSG_GITATTRIBUTES_LINE_LENGTH,\n+\t\t\t\t\t      \".gitattributes\
    \ has too long lines to parse\");\n+\t\t\t\tbreak;\n+\t\t\t}\n+\n+\t\t\tptr =\
    \ *eol ? eol + 1 : eol;\n+\t\t}\n+\t}\n+\n+\treturn ret;\n }\n \n int fsck_object(struct\
    \ object *obj, void *data, unsigned long size,\n@@ -1229,45 +1267,58 @@ int fsck_error_function(struct\
    \ fsck_options *o,\n \treturn 1;\n }\n \n-int fsck_finish(struct fsck_options\
    \ *options)\n+static int fsck_blobs(struct oidset *blobs_found, struct oidset\
    \ *blobs_done,\n+\t\t      enum fsck_msg_id msg_missing, enum fsck_msg_id msg_type,\n\
    +\t\t      struct fsck_options *options, const char *blob_type)\n {\n \tint ret\
    \ = 0;\n \tstruct oidset_iter iter;\n \tconst struct object_id *oid;\n \n-\toidset_iter_init(&options->gitmodules_found,\
    \ &iter);\n+\toidset_iter_init(blobs_found, &iter);\n \twhile ((oid = oidset_iter_next(&iter)))\
    \ {\n \t\tenum object_type type;\n \t\tunsigned long size;\n \t\tchar *buf;\n\
    \ \n-\t\tif (oidset_contains(&options->gitmodules_done, oid))\n+\t\tif (oidset_contains(blobs_done,\
    \ oid))\n \t\t\tcontinue;\n \n \t\tbuf = read_object_file(oid, &type, &size);\n\
    \ \t\tif (!buf) {\n \t\t\tif (is_promisor_object(oid))\n \t\t\t\tcontinue;\n \t\
    \t\tret |= report(options,\n-\t\t\t\t      oid, OBJ_BLOB,\n-\t\t\t\t      FSCK_MSG_GITMODULES_MISSING,\n\
    -\t\t\t\t      \"unable to read .gitmodules blob\");\n+\t\t\t\t      oid, OBJ_BLOB,\
    \ msg_missing,\n+\t\t\t\t      \"unable to read %s blob\", blob_type);\n \t\t\t\
    continue;\n \t\t}\n \n \t\tif (type == OBJ_BLOB)\n \t\t\tret |= fsck_blob(oid,\
    \ buf, size, options);\n \t\telse\n-\t\t\tret |= report(options,\n-\t\t\t\t  \
    \    oid, type,\n-\t\t\t\t      FSCK_MSG_GITMODULES_BLOB,\n-\t\t\t\t      \"non-blob\
    \ found at .gitmodules\");\n+\t\t\tret |= report(options, oid, type, msg_type,\n\
    +\t\t\t\t      \"non-blob found at %s\", blob_type);\n \t\tfree(buf);\n \t}\n\
    \ \n+\toidset_clear(blobs_found);\n+\toidset_clear(blobs_done);\n+\n+\treturn\
    \ ret;\n+}\n+\n+int fsck_finish(struct fsck_options *options)\n+{\n+\tint ret\
    \ = 0;\n+\n+\tret |= fsck_blobs(&options->gitmodules_found, &options->gitmodules_done,\n\
    +\t\t\t  FSCK_MSG_GITMODULES_MISSING, FSCK_MSG_GITMODULES_BLOB,\n+\t\t\t  options,\
    \ \".gitmodules\");\n+\tret |= fsck_blobs(&options->gitattributes_found, &options->gitattributes_done,\n\
    +\t\t\t  FSCK_MSG_GITATTRIBUTES_MISSING, FSCK_MSG_GITATTRIBUTES_BLOB,\n+\t\t\t\
    \  options, \".gitattributes\");\n \n-\toidset_clear(&options->gitmodules_found);\n\
    -\toidset_clear(&options->gitmodules_done);\n \treturn ret;\n }\n "
  - "--- a/pretty.c\n+++ b/pretty.c\n@@ -14,6 +14,13 @@\n #include \"trailer.h\"\n\
    \ #include \"run-command.h\"\n \n+/*\n+ * The limit for formatting directives,\
    \ which enable the caller to append\n+ * arbitrarily many bytes to the formatted\
    \ buffer. This includes padding\n+ * and wrapping formatters.\n+ */\n+#define\
    \ FORMATTING_LIMIT (16 * 1024)\n+\n static char *user_format;\n static struct\
    \ cmt_fmt_map {\n \tconst char *name;\n@@ -994,7 +1001,9 @@ static void strbuf_wrap(struct\
    \ strbuf *sb, size_t pos,\n \tif (pos)\n \t\tstrbuf_add(&tmp, sb->buf, pos);\n\
    \ \tstrbuf_add_wrapped_text(&tmp, sb->buf + pos,\n-\t\t\t\t(int) indent1, (int)\
    \ indent2, (int) width);\n+\t\t\t\tcast_size_t_to_int(indent1),\n+\t\t\t\tcast_size_t_to_int(indent2),\n\
    +\t\t\t\tcast_size_t_to_int(width));\n \tstrbuf_swap(&tmp, sb);\n \tstrbuf_release(&tmp);\n\
    \ }\n@@ -1120,9 +1129,18 @@ static size_t parse_padding_placeholder(const char\
    \ *placeholder,\n \t\tconst char *end = start + strcspn(start, \",)\");\n \t\t\
    char *next;\n \t\tint width;\n-\t\tif (!end || end == start)\n+\t\tif (!*end ||\
    \ end == start)\n \t\t\treturn 0;\n \t\twidth = strtol(start, &next, 10);\n+\n\
    +\t\t/*\n+\t\t * We need to limit the amount of padding, or otherwise this\n+\t\
    \t * would allow the user to pad the buffer by arbitrarily many\n+\t\t * bytes\
    \ and thus cause resource exhaustion.\n+\t\t */\n+\t\tif (width < -FORMATTING_LIMIT\
    \ || width > FORMATTING_LIMIT)\n+\t\t\treturn 0;\n+\n \t\tif (next == start ||\
    \ width == 0)\n \t\t\treturn 0;\n \t\tif (width < 0) {\n@@ -1405,6 +1423,16 @@\
    \ static size_t format_commit_one(struct strbuf *sb, /* in UTF-8 */\n \t\t\t\t\
    if (*next != ')')\n \t\t\t\t\treturn 0;\n \t\t\t}\n+\n+\t\t\t/*\n+\t\t\t * We\
    \ need to limit the format here as it allows the\n+\t\t\t * user to prepend arbitrarily\
    \ many bytes to the buffer\n+\t\t\t * when rewrapping.\n+\t\t\t */\n+\t\t\tif\
    \ (width > FORMATTING_LIMIT ||\n+\t\t\t    indent1 > FORMATTING_LIMIT ||\n+\t\t\
    \t    indent2 > FORMATTING_LIMIT)\n+\t\t\t\treturn 0;\n \t\t\trewrap_message_tail(sb,\
    \ c, width, indent1, indent2);\n \t\t\treturn end - placeholder + 1;\n \t\t} else\n\
    @@ -1670,19 +1698,21 @@ static size_t format_and_pad_commit(struct strbuf *sb,\
    \ /* in UTF-8 */\n \t\t\t\t    struct format_commit_context *c)\n {\n \tstruct\
    \ strbuf local_sb = STRBUF_INIT;\n-\tint total_consumed = 0, len, padding = c->padding;\n\
    +\tsize_t total_consumed = 0;\n+\tint len, padding = c->padding;\n+\n \tif (padding\
    \ < 0) {\n \t\tconst char *start = strrchr(sb->buf, '\\n');\n \t\tint occupied;\n\
    \ \t\tif (!start)\n \t\t\tstart = sb->buf;\n-\t\toccupied = utf8_strnwidth(start,\
    \ -1, 1);\n+\t\toccupied = utf8_strnwidth(start, strlen(start), 1);\n \t\toccupied\
    \ += c->pretty_ctx->graph_width;\n \t\tpadding = (-padding) - occupied;\n \t}\n\
    \ \twhile (1) {\n \t\tint modifier = *placeholder == 'C';\n-\t\tint consumed =\
    \ format_commit_one(&local_sb, placeholder, c);\n+\t\tsize_t consumed = format_commit_one(&local_sb,\
    \ placeholder, c);\n \t\ttotal_consumed += consumed;\n \n \t\tif (!modifier)\n\
    @@ -1694,7 +1724,7 @@ static size_t format_and_pad_commit(struct strbuf *sb, /*\
    \ in UTF-8 */\n \t\tplaceholder++;\n \t\ttotal_consumed++;\n \t}\n-\tlen = utf8_strnwidth(local_sb.buf,\
    \ -1, 1);\n+\tlen = utf8_strnwidth(local_sb.buf, local_sb.len, 1);\n \n \tif (c->flush_type\
    \ == flush_left_and_steal) {\n \t\tconst char *ch = sb->buf + sb->len - 1;\n@@\
    \ -1709,7 +1739,7 @@ static size_t format_and_pad_commit(struct strbuf *sb, /*\
    \ in UTF-8 */\n \t\t\tif (*ch != 'm')\n \t\t\t\tbreak;\n \t\t\tp = ch - 1;\n-\t\
    \t\twhile (ch - p < 10 && *p != '\\033')\n+\t\t\twhile (p > sb->buf && ch - p\
    \ < 10 && *p != '\\033')\n \t\t\t\tp--;\n \t\t\tif (*p != '\\033' ||\n \t\t\t\
    \    ch + 1 - p != display_mode_esc_sequence_len(p))\n@@ -1748,7 +1778,7 @@ static\
    \ size_t format_and_pad_commit(struct strbuf *sb, /* in UTF-8 */\n \t\t}\n \t\t\
    strbuf_addbuf(sb, &local_sb);\n \t} else {\n-\t\tint sb_len = sb->len, offset\
    \ = 0;\n+\t\tsize_t sb_len = sb->len, offset = 0;\n \t\tif (c->flush_type == flush_left)\n\
    \ \t\t\toffset = padding - len;\n \t\telse if (c->flush_type == flush_both)\n\
    @@ -1771,8 +1801,7 @@ static size_t format_commit_item(struct strbuf *sb, /* in\
    \ UTF-8 */\n \t\t\t\t const char *placeholder,\n \t\t\t\t void *context)\n {\n\
    -\tint consumed;\n-\tsize_t orig_len;\n+\tsize_t consumed, orig_len;\n \tenum\
    \ {\n \t\tNO_MAGIC,\n \t\tADD_LF_BEFORE_NON_EMPTY,\n@@ -1793,9 +1822,21 @@ static\
    \ size_t format_commit_item(struct strbuf *sb, /* in UTF-8 */\n \tdefault:\n \t\
    \tbreak;\n \t}\n-\tif (magic != NO_MAGIC)\n+\tif (magic != NO_MAGIC) {\n \t\t\
    placeholder++;\n \n+\t\tswitch (placeholder[0]) {\n+\t\tcase 'w':\n+\t\t\t/*\n\
    +\t\t\t * `%+w()` cannot ever expand to a non-empty string,\n+\t\t\t * and it\
    \ potentially changes the layout of preceding\n+\t\t\t * contents. We're thus\
    \ not able to handle the magic in\n+\t\t\t * this combination and refuse the pattern.\n\
    +\t\t\t */\n+\t\t\treturn 0;\n+\t\t};\n+\t}\n+\n \torig_len = sb->len;\n \tif\
    \ (((struct format_commit_context *)context)->flush_type != no_flush)\n \t\tconsumed\
    \ = format_and_pad_commit(sb, placeholder, context);"
  - "--- a/utf8.c\n+++ b/utf8.c\n@@ -206,26 +206,34 @@ int utf8_width(const char **start,\
    \ size_t *remainder_p)\n  * string, assuming that the string is utf8.  Returns\
    \ strlen() instead\n  * if the string does not look like a valid utf8 string.\n\
    \  */\n-int utf8_strnwidth(const char *string, int len, int skip_ansi)\n+int utf8_strnwidth(const\
    \ char *string, size_t len, int skip_ansi)\n {\n-\tint width = 0;\n \tconst char\
    \ *orig = string;\n+\tsize_t width = 0;\n \n-\tif (len == -1)\n-\t\tlen = strlen(string);\n\
    \ \twhile (string && string < orig + len) {\n-\t\tint skip;\n+\t\tint glyph_width;\n\
    +\t\tsize_t skip;\n+\n \t\twhile (skip_ansi &&\n \t\t       (skip = display_mode_esc_sequence_len(string))\
    \ != 0)\n \t\t\tstring += skip;\n-\t\twidth += utf8_width(&string, NULL);\n+\n\
    +\t\tglyph_width = utf8_width(&string, NULL);\n+\t\tif (glyph_width > 0)\n+\t\t\
    \twidth += glyph_width;\n \t}\n-\treturn string ? width : len;\n+\n+\t/*\n+\t\
    \ * TODO: fix the interface of this function and `utf8_strwidth()` to\n+\t * return\
    \ `size_t` instead of `int`.\n+\t */\n+\treturn cast_size_t_to_int(string ? width\
    \ : len);\n }\n \n int utf8_strwidth(const char *string)\n {\n-\treturn utf8_strnwidth(string,\
    \ -1, 0);\n+\treturn utf8_strnwidth(string, strlen(string), 0);\n }\n \n int is_utf8(const\
    \ char *text)\n@@ -357,51 +365,52 @@ void strbuf_add_wrapped_bytes(struct strbuf\
    \ *buf, const char *data, int len,\n void strbuf_utf8_replace(struct strbuf *sb_src,\
    \ int pos, int width,\n \t\t\t const char *subst)\n {\n-\tstruct strbuf sb_dst\
    \ = STRBUF_INIT;\n-\tchar *src = sb_src->buf;\n-\tchar *end = src + sb_src->len;\n\
    -\tchar *dst;\n-\tint w = 0, subst_len = 0;\n+\tconst char *src = sb_src->buf,\
    \ *end = sb_src->buf + sb_src->len;\n+\tstruct strbuf dst;\n+\tint w = 0;\n \n\
    -\tif (subst)\n-\t\tsubst_len = strlen(subst);\n-\tstrbuf_grow(&sb_dst, sb_src->len\
    \ + subst_len);\n-\tdst = sb_dst.buf;\n+\tstrbuf_init(&dst, sb_src->len);\n \n\
    \ \twhile (src < end) {\n-\t\tchar *old;\n+\t\tconst char *old;\n+\t\tint glyph_width;\n\
    \ \t\tsize_t n;\n \n \t\twhile ((n = display_mode_esc_sequence_len(src))) {\n\
    -\t\t\tmemcpy(dst, src, n);\n+\t\t\tstrbuf_add(&dst, src, n);\n \t\t\tsrc += n;\n\
    -\t\t\tdst += n;\n \t\t}\n \n \t\tif (src >= end)\n \t\t\tbreak;\n \n \t\told\
    \ = src;\n-\t\tn = utf8_width((const char**)&src, NULL);\n-\t\tif (!src) \t/*\
    \ broken utf-8, do nothing */\n+\t\tglyph_width = utf8_width((const char**)&src,\
    \ NULL);\n+\t\tif (!src) /* broken utf-8, do nothing */\n \t\t\tgoto out;\n-\t\
    \tif (n && w >= pos && w < pos + width) {\n+\n+\t\t/*\n+\t\t * In case we see\
    \ a control character we copy it into the\n+\t\t * buffer, but don't add it to\
    \ the width.\n+\t\t */\n+\t\tif (glyph_width < 0)\n+\t\t\tglyph_width = 0;\n+\n\
    +\t\tif (glyph_width && w >= pos && w < pos + width) {\n \t\t\tif (subst) {\n\
    -\t\t\t\tmemcpy(dst, subst, subst_len);\n-\t\t\t\tdst += subst_len;\n+\t\t\t\t\
    strbuf_addstr(&dst, subst);\n \t\t\t\tsubst = NULL;\n \t\t\t}\n-\t\t\tw += n;\n\
    -\t\t\tcontinue;\n+\t\t} else {\n+\t\t\tstrbuf_add(&dst, old, src - old);\n \t\
    \t}\n-\t\tmemcpy(dst, old, src - old);\n-\t\tdst += src - old;\n-\t\tw += n;\n\
    +\n+\t\tw += glyph_width;\n \t}\n-\tstrbuf_setlen(&sb_dst, dst - sb_dst.buf);\n\
    -\tstrbuf_swap(sb_src, &sb_dst);\n+\n+\tstrbuf_swap(sb_src, &dst);\n out:\n-\t\
    strbuf_release(&sb_dst);\n+\tstrbuf_release(&dst);\n }\n \n /*\n@@ -796,7 +805,7\
    \ @@ int skip_utf8_bom(char **text, size_t len)\n void strbuf_utf8_align(struct\
    \ strbuf *buf, align_type position, unsigned int width,\n \t\t       const char\
    \ *s)\n {\n-\tint slen = strlen(s);\n+\tsize_t slen = strlen(s);\n \tint display_len\
    \ = utf8_strnwidth(s, slen, 0);\n \tint utf8_compensation = slen - display_len;\n\
    \ "
  identifiers:
  - CVE-2022-41953
  - CWE-426
  overview: Git GUI is a convenient graphical tool that comes with Git for Windows.
    Its target audience is users who are uncomfortable with using Git on the command-line.
    Git GUI has a function to clone repositories. Immediately after the local clone
    is available, Git GUI will automatically post-process it, among other things running
    a spell checker called `aspell.exe` if it was found. Git GUI is implemented as
    a Tcl/Tk script. Due to the unfortunate design of Tcl on Windows, the search path
    when looking for an executable _always includes the current directory_. Therefore,
    malicious repositories can ship with an `aspell.exe` in their top-level directory
    which is executed by Git GUI without giving the user a chance to inspect it first,
    i.e. running untrusted code. This issue has been addressed in version 2.39.1.
    Users are advised to upgrade. Users unable to upgrade should avoid using Git GUI
    for cloning. If that is not a viable option, at least avoid cloning from untrusted
    sources.
  references:
  - source: security-advisories@github.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/git-for-windows/git/commit/7360767e8dfc1895a932324079f7d45d7791d39f
  - source: security-advisories@github.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/git-for-windows/git/pull/4219
  - source: security-advisories@github.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/git-for-windows/git/security/advisories/GHSA-v4px-mx59-w99c
  - source: security-advisories@github.com
    tags:
    - Third Party Advisory
    url: https://www.tcl.tk/man/tcl8.6/TclCmd/exec.html#M23
  title: Git GUI is a convenient graphical tool that comes with Git for Windows. Its
    target audience is users who are uncomfortable with using Git on the command-line.
    Git GUI has a function to clone repositories. Immediately after the local clone
    is available, Git GUI will automatically post-process it, among other things running
    a spell checker called `aspell.exe` if it was found. Git GUI is implemented as
    a Tcl/Tk script. Due to the unfortunate design of Tcl on Windows, the search path
    when looking for an executable _always includes the current directory_. Therefore,
    malicious repositories can ship with an `aspell.exe` in their top-level directory
    which is executed by Git GUI without giving the user a chance to inspect it first,
    i.e. running untrusted code. This issue has been addressed in version 2.39.1.
    Users are advised to upgrade. Users unable to upgrade should avoid using Git GUI
    for cloning. If that is not a viable option, at least avoid cloning from untrusted
    sources.
- diff_content:
  - "--- a/validator/my_validator.cpp\n+++ b/validator/my_validator.cpp\n@@ -55,7\
    \ +55,8 @@ int init_result(RESULT & result, void*& data) {\n \tlog_messages.printf(MSG_DEBUG,\
    \ \"Check result\\n\");\n \n \tchar buff[256];\n-\tn = fscanf(f, \"%s\", buff);\n\
    +\t//n = fscanf(f, \"%s\", buff);\n+\tfgets(buff, 256, f);\n \tchar * pch;\n \t\
    pch = strtok(buff, \" ,\");\n \tif (pch != NULL) {"
  identifiers:
  - CVE-2015-10065
  - CWE-120
  overview: A vulnerability classified as critical was found in AenBleidd FiND. This
    vulnerability affects the function init_result of the file validator/my_validator.cpp.
    The manipulation leads to buffer overflow. The patch is identified as ee2eef34a83644f286c9adcaf30437f92e9c48f1.
    It is recommended to apply a patch to fix this issue. VDB-218458 is the identifier
    assigned to this vulnerability.
  references:
  - source: cna@vuldb.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/AenBleidd/FiND/commit/ee2eef34a83644f286c9adcaf30437f92e9c48f1
  - source: cna@vuldb.com
    tags:
    - Permissions Required
    - Third Party Advisory
    - VDB Entry
    url: https://vuldb.com/?ctiid.218458
  - source: cna@vuldb.com
    tags:
    - Permissions Required
    - Third Party Advisory
    - VDB Entry
    url: https://vuldb.com/?id.218458
  title: A vulnerability classified as critical was found in AenBleidd FiND. This
    vulnerability affects the function init_result of the file validator/my_validator.cpp.
    The manipulation leads to buffer overflow. The patch is identified as ee2eef34a83644f286c9adcaf30437f92e9c48f1.
    It is recommended to apply a patch to fix this issue. VDB-218458 is the identifier
    assigned to this vulnerability.
- diff_content:
  - "--- a/attr.c\n+++ b/attr.c\n@@ -24,7 +24,7 @@ static const char git_attr__unknown[]\
    \ = \"(builtin)unknown\";\n #define ATTR__UNKNOWN git_attr__unknown\n \n struct\
    \ git_attr {\n-\tint attr_nr; /* unique attribute number */\n+\tunsigned int attr_nr;\
    \ /* unique attribute number */\n \tchar name[FLEX_ARRAY]; /* attribute name */\n\
    \ };\n \n@@ -206,7 +206,7 @@ static void report_invalid_attr(const char *name,\
    \ size_t len,\n  * dictionary.  If no entry is found, create a new attribute and\
    \ store it in\n  * the dictionary.\n  */\n-static const struct git_attr *git_attr_internal(const\
    \ char *name, int namelen)\n+static const struct git_attr *git_attr_internal(const\
    \ char *name, size_t namelen)\n {\n \tstruct git_attr *a;\n \n@@ -222,8 +222,8\
    \ @@ static const struct git_attr *git_attr_internal(const char *name, int namelen)\n\
    \ \t\ta->attr_nr = hashmap_get_size(&g_attr_hashmap.map);\n \n \t\tattr_hashmap_add(&g_attr_hashmap,\
    \ a->name, namelen, a);\n-\t\tassert(a->attr_nr ==\n-\t\t       (hashmap_get_size(&g_attr_hashmap.map)\
    \ - 1));\n+\t\tif (a->attr_nr != hashmap_get_size(&g_attr_hashmap.map) - 1)\n\
    +\t\t\tdie(_(\"unable to add additional attribute\"));\n \t}\n \n \thashmap_unlock(&g_attr_hashmap);\n\
    @@ -268,7 +268,7 @@ struct match_attr {\n \t\tconst struct git_attr *attr;\n \t\
    } u;\n \tchar is_macro;\n-\tunsigned num_attr;\n+\tsize_t num_attr;\n \tstruct\
    \ attr_state state[FLEX_ARRAY];\n };\n \n@@ -289,7 +289,7 @@ static const char\
    \ *parse_attr(const char *src, int lineno, const char *cp,\n \t\t\t      struct\
    \ attr_state *e)\n {\n \tconst char *ep, *equals;\n-\tint len;\n+\tsize_t len;\n\
    \ \n \tep = cp + strcspn(cp, blank);\n \tequals = strchr(cp, '=');\n@@ -333,8\
    \ +333,7 @@ static const char *parse_attr(const char *src, int lineno, const char\
    \ *cp,\n static struct match_attr *parse_attr_line(const char *line, const char\
    \ *src,\n \t\t\t\t\t  int lineno, unsigned flags)\n {\n-\tint namelen;\n-\tint\
    \ num_attr, i;\n+\tsize_t namelen, num_attr, i;\n \tconst char *cp, *name, *states;\n\
    \ \tstruct match_attr *res = NULL;\n \tint is_macro;\n@@ -345,6 +344,11 @@ static\
    \ struct match_attr *parse_attr_line(const char *line, const char *src,\n \t\t\
    return NULL;\n \tname = cp;\n \n+\tif (strlen(line) >= ATTR_MAX_LINE_LENGTH) {\n\
    +\t\twarning(_(\"ignoring overly long attributes line %d\"), lineno);\n+\t\treturn\
    \ NULL;\n+\t}\n+\n \tif (*cp == '\"' && !unquote_c_style(&pattern, name, &states))\
    \ {\n \t\tname = pattern.buf;\n \t\tnamelen = pattern.len;\n@@ -381,10 +385,9\
    \ @@ static struct match_attr *parse_attr_line(const char *line, const char *src,\n\
    \ \t\t\tgoto fail_return;\n \t}\n \n-\tres = xcalloc(1,\n-\t\t      sizeof(*res)\
    \ +\n-\t\t      sizeof(struct attr_state) * num_attr +\n-\t\t      (is_macro ?\
    \ 0 : namelen + 1));\n+\tres = xcalloc(1, st_add3(sizeof(*res),\n+\t\t\t\t st_mult(sizeof(struct\
    \ attr_state), num_attr),\n+\t\t\t\t is_macro ? 0 : namelen + 1));\n \tif (is_macro)\
    \ {\n \t\tres->u.attr = git_attr_internal(name, namelen);\n \t} else {\n@@ -447,11\
    \ +450,12 @@ struct attr_stack {\n \n static void attr_stack_free(struct attr_stack\
    \ *e)\n {\n-\tint i;\n+\tunsigned i;\n \tfree(e->origin);\n \tfor (i = 0; i <\
    \ e->num_matches; i++) {\n \t\tstruct match_attr *a = e->attrs[i];\n-\t\tint j;\n\
    +\t\tsize_t j;\n+\n \t\tfor (j = 0; j < a->num_attr; j++) {\n \t\t\tconst char\
    \ *setto = a->state[j].setto;\n \t\t\tif (setto == ATTR__TRUE ||\n@@ -660,8 +664,8\
    \ @@ static void handle_attr_line(struct attr_stack *res,\n \ta = parse_attr_line(line,\
    \ src, lineno, flags);\n \tif (!a)\n \t\treturn;\n-\tALLOC_GROW(res->attrs, res->num_matches\
    \ + 1, res->alloc);\n-\tres->attrs[res->num_matches++] = a;\n+\tALLOC_GROW_BY(res->attrs,\
    \ res->num_matches, 1, res->alloc);\n+\tres->attrs[res->num_matches - 1] = a;\n\
    \ }\n \n static struct attr_stack *read_attr_from_array(const char **list)\n@@\
    \ -701,11 +705,12 @@ void git_attr_set_direction(enum git_attr_direction new_direction)\n\
    \ \n static struct attr_stack *read_attr_from_file(const char *path, unsigned\
    \ flags)\n {\n+\tstruct strbuf buf = STRBUF_INIT;\n \tint fd;\n \tFILE *fp;\n\
    \ \tstruct attr_stack *res;\n-\tchar buf[2048];\n \tint lineno = 0;\n+\tstruct\
    \ stat st;\n \n \tif (flags & READ_ATTR_NOFOLLOW)\n \t\tfd = open_nofollow(path,\
    \ O_RDONLY);\n@@ -717,15 +722,26 @@ static struct attr_stack *read_attr_from_file(const\
    \ char *path, unsigned flags)\n \t\treturn NULL;\n \t}\n \tfp = xfdopen(fd, \"\
    r\");\n+\tif (fstat(fd, &st)) {\n+\t\twarning_errno(_(\"cannot fstat gitattributes\
    \ file '%s'\"), path);\n+\t\tfclose(fp);\n+\t\treturn NULL;\n+\t}\n+\tif (st.st_size\
    \ >= ATTR_MAX_FILE_SIZE) {\n+\t\twarning(_(\"ignoring overly large gitattributes\
    \ file '%s'\"), path);\n+\t\tfclose(fp);\n+\t\treturn NULL;\n+\t}\n \n \tCALLOC_ARRAY(res,\
    \ 1);\n-\twhile (fgets(buf, sizeof(buf), fp)) {\n-\t\tchar *bufp = buf;\n-\t\t\
    if (!lineno)\n-\t\t\tskip_utf8_bom(&bufp, strlen(bufp));\n-\t\thandle_attr_line(res,\
    \ bufp, path, ++lineno, flags);\n+\twhile (strbuf_getline(&buf, fp) != EOF) {\n\
    +\t\tif (!lineno && starts_with(buf.buf, utf8_bom))\n+\t\t\tstrbuf_remove(&buf,\
    \ 0, strlen(utf8_bom));\n+\t\thandle_attr_line(res, buf.buf, path, ++lineno, flags);\n\
    \ \t}\n+\n \tfclose(fp);\n+\tstrbuf_release(&buf);\n \treturn res;\n }\n \n@@\
    \ -736,6 +752,7 @@ static struct attr_stack *read_attr_from_index(struct index_state\
    \ *istate,\n \tstruct attr_stack *res;\n \tchar *buf, *sp;\n \tint lineno = 0;\n\
    +\tsize_t size;\n \n \tif (!istate)\n \t\treturn NULL;\n@@ -754,9 +771,13 @@ static\
    \ struct attr_stack *read_attr_from_index(struct index_state *istate,\n \tif (!path_in_cone_mode_sparse_checkout(path,\
    \ istate))\n \t\treturn NULL;\n \n-\tbuf = read_blob_data_from_index(istate, path,\
    \ NULL);\n+\tbuf = read_blob_data_from_index(istate, path, &size);\n \tif (!buf)\n\
    \ \t\treturn NULL;\n+\tif (size >= ATTR_MAX_FILE_SIZE) {\n+\t\twarning(_(\"ignoring\
    \ overly large gitattributes blob '%s'\"), path);\n+\t\treturn NULL;\n+\t}\n \n\
    \ \tCALLOC_ARRAY(res, 1);\n \tfor (sp = buf; *sp; ) {\n@@ -999,12 +1020,12 @@\
    \ static int macroexpand_one(struct all_attrs_item *all_attrs, int nr, int rem);\n\
    \ static int fill_one(struct all_attrs_item *all_attrs,\n \t\t    const struct\
    \ match_attr *a, int rem)\n {\n-\tint i;\n+\tsize_t i;\n \n-\tfor (i = a->num_attr\
    \ - 1; rem > 0 && i >= 0; i--) {\n-\t\tconst struct git_attr *attr = a->state[i].attr;\n\
    +\tfor (i = a->num_attr; rem > 0 && i > 0; i--) {\n+\t\tconst struct git_attr\
    \ *attr = a->state[i - 1].attr;\n \t\tconst char **n = &(all_attrs[attr->attr_nr].value);\n\
    -\t\tconst char *v = a->state[i].setto;\n+\t\tconst char *v = a->state[i - 1].setto;\n\
    \ \n \t\tif (*n == ATTR__UNKNOWN) {\n \t\t\t*n = v;\n@@ -1020,11 +1041,11 @@ static\
    \ int fill(const char *path, int pathlen, int basename_offset,\n \t\tstruct all_attrs_item\
    \ *all_attrs, int rem)\n {\n \tfor (; rem > 0 && stack; stack = stack->prev) {\n\
    -\t\tint i;\n+\t\tunsigned i;\n \t\tconst char *base = stack->origin ? stack->origin\
    \ : \"\";\n \n-\t\tfor (i = stack->num_matches - 1; 0 < rem && 0 <= i; i--) {\n\
    -\t\t\tconst struct match_attr *a = stack->attrs[i];\n+\t\tfor (i = stack->num_matches;\
    \ 0 < rem && 0 < i; i--) {\n+\t\t\tconst struct match_attr *a = stack->attrs[i\
    \ - 1];\n \t\t\tif (a->is_macro)\n \t\t\t\tcontinue;\n \t\t\tif (path_matches(path,\
    \ pathlen, basename_offset,\n@@ -1055,11 +1076,11 @@ static void determine_macros(struct\
    \ all_attrs_item *all_attrs,\n \t\t\t     const struct attr_stack *stack)\n {\n\
    \ \tfor (; stack; stack = stack->prev) {\n-\t\tint i;\n-\t\tfor (i = stack->num_matches\
    \ - 1; i >= 0; i--) {\n-\t\t\tconst struct match_attr *ma = stack->attrs[i];\n\
    +\t\tunsigned i;\n+\t\tfor (i = stack->num_matches; i > 0; i--) {\n+\t\t\tconst\
    \ struct match_attr *ma = stack->attrs[i - 1];\n \t\t\tif (ma->is_macro) {\n-\t\
    \t\t\tint n = ma->u.attr->attr_nr;\n+\t\t\t\tunsigned int n = ma->u.attr->attr_nr;\n\
    \ \t\t\t\tif (!all_attrs[n].macro) {\n \t\t\t\t\tall_attrs[n].macro = ma;\n \t\
    \t\t\t}\n@@ -1111,7 +1132,7 @@ void git_check_attr(struct index_state *istate,\n\
    \ \tcollect_some_attrs(istate, path, check);\n \n \tfor (i = 0; i < check->nr;\
    \ i++) {\n-\t\tsize_t n = check->items[i].attr->attr_nr;\n+\t\tunsigned int n\
    \ = check->items[i].attr->attr_nr;\n \t\tconst char *value = check->all_attrs[n].value;\n\
    \ \t\tif (value == ATTR__UNKNOWN)\n \t\t\tvalue = ATTR__UNSET;"
  - "--- a/column.c\n+++ b/column.c\n@@ -23,7 +23,7 @@ struct column_data {\n /* return\
    \ length of 's' in letters, ANSI escapes stripped */\n static int item_length(const\
    \ char *s)\n {\n-\treturn utf8_strnwidth(s, -1, 1);\n+\treturn utf8_strnwidth(s,\
    \ strlen(s), 1);\n }\n \n /*"
  - "--- a/fsck.c\n+++ b/fsck.c\n@@ -2,6 +2,7 @@\n #include \"object-store.h\"\n #include\
    \ \"repository.h\"\n #include \"object.h\"\n+#include \"attr.h\"\n #include \"\
    blob.h\"\n #include \"tree.h\"\n #include \"tree-walk.h\"\n@@ -614,17 +615,22\
    \ @@ static int fsck_tree(const struct object_id *tree_oid,\n \t\t\t\t\t\t \"\
    .gitmodules is a symbolic link\");\n \t\t}\n \n+\t\tif (is_hfs_dotgitattributes(name)\
    \ || is_ntfs_dotgitattributes(name)) {\n+\t\t\tif (!S_ISLNK(mode))\n+\t\t\t\t\
    oidset_insert(&options->gitattributes_found,\n+\t\t\t\t\t      entry_oid);\n+\t\
    \t\telse\n+\t\t\t\tretval += report(options, tree_oid, OBJ_TREE,\n+\t\t\t\t\t\t\
    \ FSCK_MSG_GITATTRIBUTES_SYMLINK,\n+\t\t\t\t\t\t \".gitattributes is a symlink\"\
    );\n+\t\t}\n+\n \t\tif (S_ISLNK(mode)) {\n \t\t\tif (is_hfs_dotgitignore(name)\
    \ ||\n \t\t\t    is_ntfs_dotgitignore(name))\n \t\t\t\tretval += report(options,\
    \ tree_oid, OBJ_TREE,\n \t\t\t\t\t\t FSCK_MSG_GITIGNORE_SYMLINK,\n \t\t\t\t\t\t\
    \ \".gitignore is a symlink\");\n-\t\t\tif (is_hfs_dotgitattributes(name) ||\n\
    -\t\t\t    is_ntfs_dotgitattributes(name))\n-\t\t\t\tretval += report(options,\
    \ tree_oid, OBJ_TREE,\n-\t\t\t\t\t\t FSCK_MSG_GITATTRIBUTES_SYMLINK,\n-\t\t\t\t\
    \t\t \".gitattributes is a symlink\");\n \t\t\tif (is_hfs_dotmailmap(name) ||\n\
    \ \t\t\t    is_ntfs_dotmailmap(name))\n \t\t\t\tretval += report(options, tree_oid,\
    \ OBJ_TREE,\n@@ -1159,38 +1165,70 @@ static int fsck_gitmodules_fn(const char\
    \ *var, const char *value, void *vdata)\n static int fsck_blob(const struct object_id\
    \ *oid, const char *buf,\n \t\t     unsigned long size, struct fsck_options *options)\n\
    \ {\n-\tstruct fsck_gitmodules_data data;\n-\tstruct config_options config_opts\
    \ = { 0 };\n-\n-\tif (!oidset_contains(&options->gitmodules_found, oid))\n-\t\t\
    return 0;\n-\toidset_insert(&options->gitmodules_done, oid);\n+\tint ret = 0;\n\
    \ \n \tif (object_on_skiplist(options, oid))\n \t\treturn 0;\n \n-\tif (!buf)\
    \ {\n-\t\t/*\n-\t\t * A missing buffer here is a sign that the caller found the\n\
    -\t\t * blob too gigantic to load into memory. Let's just consider\n-\t\t * that\
    \ an error.\n-\t\t */\n-\t\treturn report(options, oid, OBJ_BLOB,\n-\t\t\t   \
    \   FSCK_MSG_GITMODULES_LARGE,\n-\t\t\t      \".gitmodules too large to parse\"\
    );\n+\tif (oidset_contains(&options->gitmodules_found, oid)) {\n+\t\tstruct config_options\
    \ config_opts = { 0 };\n+\t\tstruct fsck_gitmodules_data data;\n+\n+\t\toidset_insert(&options->gitmodules_done,\
    \ oid);\n+\n+\t\tif (!buf) {\n+\t\t\t/*\n+\t\t\t * A missing buffer here is a\
    \ sign that the caller found the\n+\t\t\t * blob too gigantic to load into memory.\
    \ Let's just consider\n+\t\t\t * that an error.\n+\t\t\t */\n+\t\t\treturn report(options,\
    \ oid, OBJ_BLOB,\n+\t\t\t\t\tFSCK_MSG_GITMODULES_LARGE,\n+\t\t\t\t\t\".gitmodules\
    \ too large to parse\");\n+\t\t}\n+\n+\t\tdata.oid = oid;\n+\t\tdata.options =\
    \ options;\n+\t\tdata.ret = 0;\n+\t\tconfig_opts.error_action = CONFIG_ERROR_SILENT;\n\
    +\t\tif (git_config_from_mem(fsck_gitmodules_fn, CONFIG_ORIGIN_BLOB,\n+\t\t\t\t\
    \t\".gitmodules\", buf, size, &data, &config_opts))\n+\t\t\tdata.ret |= report(options,\
    \ oid, OBJ_BLOB,\n+\t\t\t\t\tFSCK_MSG_GITMODULES_PARSE,\n+\t\t\t\t\t\"could not\
    \ parse gitmodules blob\");\n+\t\tret |= data.ret;\n \t}\n \n-\tdata.oid = oid;\n\
    -\tdata.options = options;\n-\tdata.ret = 0;\n-\tconfig_opts.error_action = CONFIG_ERROR_SILENT;\n\
    -\tif (git_config_from_mem(fsck_gitmodules_fn, CONFIG_ORIGIN_BLOB,\n-\t\t\t\t\"\
    .gitmodules\", buf, size, &data, &config_opts))\n-\t\tdata.ret |= report(options,\
    \ oid, OBJ_BLOB,\n-\t\t\t\t   FSCK_MSG_GITMODULES_PARSE,\n-\t\t\t\t   \"could\
    \ not parse gitmodules blob\");\n-\n-\treturn data.ret;\n+\tif (oidset_contains(&options->gitattributes_found,\
    \ oid)) {\n+\t\tconst char *ptr;\n+\n+\t\toidset_insert(&options->gitattributes_done,\
    \ oid);\n+\n+\t\tif (!buf || size > ATTR_MAX_FILE_SIZE) {\n+\t\t\t/*\n+\t\t\t\
    \ * A missing buffer here is a sign that the caller found the\n+\t\t\t * blob\
    \ too gigantic to load into memory. Let's just consider\n+\t\t\t * that an error.\n\
    +\t\t\t */\n+\t\t\treturn report(options, oid, OBJ_BLOB,\n+\t\t\t\t\tFSCK_MSG_GITATTRIBUTES_LARGE,\n\
    +\t\t\t\t\t\".gitattributes too large to parse\");\n+\t\t}\n+\n+\t\tfor (ptr =\
    \ buf; *ptr; ) {\n+\t\t\tconst char *eol = strchrnul(ptr, '\\n');\n+\t\t\tif (eol\
    \ - ptr >= ATTR_MAX_LINE_LENGTH) {\n+\t\t\t\tret |= report(options, oid, OBJ_BLOB,\n\
    +\t\t\t\t\t      FSCK_MSG_GITATTRIBUTES_LINE_LENGTH,\n+\t\t\t\t\t      \".gitattributes\
    \ has too long lines to parse\");\n+\t\t\t\tbreak;\n+\t\t\t}\n+\n+\t\t\tptr =\
    \ *eol ? eol + 1 : eol;\n+\t\t}\n+\t}\n+\n+\treturn ret;\n }\n \n int fsck_object(struct\
    \ object *obj, void *data, unsigned long size,\n@@ -1229,45 +1267,58 @@ int fsck_error_function(struct\
    \ fsck_options *o,\n \treturn 1;\n }\n \n-int fsck_finish(struct fsck_options\
    \ *options)\n+static int fsck_blobs(struct oidset *blobs_found, struct oidset\
    \ *blobs_done,\n+\t\t      enum fsck_msg_id msg_missing, enum fsck_msg_id msg_type,\n\
    +\t\t      struct fsck_options *options, const char *blob_type)\n {\n \tint ret\
    \ = 0;\n \tstruct oidset_iter iter;\n \tconst struct object_id *oid;\n \n-\toidset_iter_init(&options->gitmodules_found,\
    \ &iter);\n+\toidset_iter_init(blobs_found, &iter);\n \twhile ((oid = oidset_iter_next(&iter)))\
    \ {\n \t\tenum object_type type;\n \t\tunsigned long size;\n \t\tchar *buf;\n\
    \ \n-\t\tif (oidset_contains(&options->gitmodules_done, oid))\n+\t\tif (oidset_contains(blobs_done,\
    \ oid))\n \t\t\tcontinue;\n \n \t\tbuf = read_object_file(oid, &type, &size);\n\
    \ \t\tif (!buf) {\n \t\t\tif (is_promisor_object(oid))\n \t\t\t\tcontinue;\n \t\
    \t\tret |= report(options,\n-\t\t\t\t      oid, OBJ_BLOB,\n-\t\t\t\t      FSCK_MSG_GITMODULES_MISSING,\n\
    -\t\t\t\t      \"unable to read .gitmodules blob\");\n+\t\t\t\t      oid, OBJ_BLOB,\
    \ msg_missing,\n+\t\t\t\t      \"unable to read %s blob\", blob_type);\n \t\t\t\
    continue;\n \t\t}\n \n \t\tif (type == OBJ_BLOB)\n \t\t\tret |= fsck_blob(oid,\
    \ buf, size, options);\n \t\telse\n-\t\t\tret |= report(options,\n-\t\t\t\t  \
    \    oid, type,\n-\t\t\t\t      FSCK_MSG_GITMODULES_BLOB,\n-\t\t\t\t      \"non-blob\
    \ found at .gitmodules\");\n+\t\t\tret |= report(options, oid, type, msg_type,\n\
    +\t\t\t\t      \"non-blob found at %s\", blob_type);\n \t\tfree(buf);\n \t}\n\
    \ \n+\toidset_clear(blobs_found);\n+\toidset_clear(blobs_done);\n+\n+\treturn\
    \ ret;\n+}\n+\n+int fsck_finish(struct fsck_options *options)\n+{\n+\tint ret\
    \ = 0;\n+\n+\tret |= fsck_blobs(&options->gitmodules_found, &options->gitmodules_done,\n\
    +\t\t\t  FSCK_MSG_GITMODULES_MISSING, FSCK_MSG_GITMODULES_BLOB,\n+\t\t\t  options,\
    \ \".gitmodules\");\n+\tret |= fsck_blobs(&options->gitattributes_found, &options->gitattributes_done,\n\
    +\t\t\t  FSCK_MSG_GITATTRIBUTES_MISSING, FSCK_MSG_GITATTRIBUTES_BLOB,\n+\t\t\t\
    \  options, \".gitattributes\");\n \n-\toidset_clear(&options->gitmodules_found);\n\
    -\toidset_clear(&options->gitmodules_done);\n \treturn ret;\n }\n "
  - "--- a/pretty.c\n+++ b/pretty.c\n@@ -14,6 +14,13 @@\n #include \"trailer.h\"\n\
    \ #include \"run-command.h\"\n \n+/*\n+ * The limit for formatting directives,\
    \ which enable the caller to append\n+ * arbitrarily many bytes to the formatted\
    \ buffer. This includes padding\n+ * and wrapping formatters.\n+ */\n+#define\
    \ FORMATTING_LIMIT (16 * 1024)\n+\n static char *user_format;\n static struct\
    \ cmt_fmt_map {\n \tconst char *name;\n@@ -994,7 +1001,9 @@ static void strbuf_wrap(struct\
    \ strbuf *sb, size_t pos,\n \tif (pos)\n \t\tstrbuf_add(&tmp, sb->buf, pos);\n\
    \ \tstrbuf_add_wrapped_text(&tmp, sb->buf + pos,\n-\t\t\t\t(int) indent1, (int)\
    \ indent2, (int) width);\n+\t\t\t\tcast_size_t_to_int(indent1),\n+\t\t\t\tcast_size_t_to_int(indent2),\n\
    +\t\t\t\tcast_size_t_to_int(width));\n \tstrbuf_swap(&tmp, sb);\n \tstrbuf_release(&tmp);\n\
    \ }\n@@ -1120,9 +1129,18 @@ static size_t parse_padding_placeholder(const char\
    \ *placeholder,\n \t\tconst char *end = start + strcspn(start, \",)\");\n \t\t\
    char *next;\n \t\tint width;\n-\t\tif (!end || end == start)\n+\t\tif (!*end ||\
    \ end == start)\n \t\t\treturn 0;\n \t\twidth = strtol(start, &next, 10);\n+\n\
    +\t\t/*\n+\t\t * We need to limit the amount of padding, or otherwise this\n+\t\
    \t * would allow the user to pad the buffer by arbitrarily many\n+\t\t * bytes\
    \ and thus cause resource exhaustion.\n+\t\t */\n+\t\tif (width < -FORMATTING_LIMIT\
    \ || width > FORMATTING_LIMIT)\n+\t\t\treturn 0;\n+\n \t\tif (next == start ||\
    \ width == 0)\n \t\t\treturn 0;\n \t\tif (width < 0) {\n@@ -1405,6 +1423,16 @@\
    \ static size_t format_commit_one(struct strbuf *sb, /* in UTF-8 */\n \t\t\t\t\
    if (*next != ')')\n \t\t\t\t\treturn 0;\n \t\t\t}\n+\n+\t\t\t/*\n+\t\t\t * We\
    \ need to limit the format here as it allows the\n+\t\t\t * user to prepend arbitrarily\
    \ many bytes to the buffer\n+\t\t\t * when rewrapping.\n+\t\t\t */\n+\t\t\tif\
    \ (width > FORMATTING_LIMIT ||\n+\t\t\t    indent1 > FORMATTING_LIMIT ||\n+\t\t\
    \t    indent2 > FORMATTING_LIMIT)\n+\t\t\t\treturn 0;\n \t\t\trewrap_message_tail(sb,\
    \ c, width, indent1, indent2);\n \t\t\treturn end - placeholder + 1;\n \t\t} else\n\
    @@ -1670,19 +1698,21 @@ static size_t format_and_pad_commit(struct strbuf *sb,\
    \ /* in UTF-8 */\n \t\t\t\t    struct format_commit_context *c)\n {\n \tstruct\
    \ strbuf local_sb = STRBUF_INIT;\n-\tint total_consumed = 0, len, padding = c->padding;\n\
    +\tsize_t total_consumed = 0;\n+\tint len, padding = c->padding;\n+\n \tif (padding\
    \ < 0) {\n \t\tconst char *start = strrchr(sb->buf, '\\n');\n \t\tint occupied;\n\
    \ \t\tif (!start)\n \t\t\tstart = sb->buf;\n-\t\toccupied = utf8_strnwidth(start,\
    \ -1, 1);\n+\t\toccupied = utf8_strnwidth(start, strlen(start), 1);\n \t\toccupied\
    \ += c->pretty_ctx->graph_width;\n \t\tpadding = (-padding) - occupied;\n \t}\n\
    \ \twhile (1) {\n \t\tint modifier = *placeholder == 'C';\n-\t\tint consumed =\
    \ format_commit_one(&local_sb, placeholder, c);\n+\t\tsize_t consumed = format_commit_one(&local_sb,\
    \ placeholder, c);\n \t\ttotal_consumed += consumed;\n \n \t\tif (!modifier)\n\
    @@ -1694,7 +1724,7 @@ static size_t format_and_pad_commit(struct strbuf *sb, /*\
    \ in UTF-8 */\n \t\tplaceholder++;\n \t\ttotal_consumed++;\n \t}\n-\tlen = utf8_strnwidth(local_sb.buf,\
    \ -1, 1);\n+\tlen = utf8_strnwidth(local_sb.buf, local_sb.len, 1);\n \n \tif (c->flush_type\
    \ == flush_left_and_steal) {\n \t\tconst char *ch = sb->buf + sb->len - 1;\n@@\
    \ -1709,7 +1739,7 @@ static size_t format_and_pad_commit(struct strbuf *sb, /*\
    \ in UTF-8 */\n \t\t\tif (*ch != 'm')\n \t\t\t\tbreak;\n \t\t\tp = ch - 1;\n-\t\
    \t\twhile (ch - p < 10 && *p != '\\033')\n+\t\t\twhile (p > sb->buf && ch - p\
    \ < 10 && *p != '\\033')\n \t\t\t\tp--;\n \t\t\tif (*p != '\\033' ||\n \t\t\t\
    \    ch + 1 - p != display_mode_esc_sequence_len(p))\n@@ -1748,7 +1778,7 @@ static\
    \ size_t format_and_pad_commit(struct strbuf *sb, /* in UTF-8 */\n \t\t}\n \t\t\
    strbuf_addbuf(sb, &local_sb);\n \t} else {\n-\t\tint sb_len = sb->len, offset\
    \ = 0;\n+\t\tsize_t sb_len = sb->len, offset = 0;\n \t\tif (c->flush_type == flush_left)\n\
    \ \t\t\toffset = padding - len;\n \t\telse if (c->flush_type == flush_both)\n\
    @@ -1771,8 +1801,7 @@ static size_t format_commit_item(struct strbuf *sb, /* in\
    \ UTF-8 */\n \t\t\t\t const char *placeholder,\n \t\t\t\t void *context)\n {\n\
    -\tint consumed;\n-\tsize_t orig_len;\n+\tsize_t consumed, orig_len;\n \tenum\
    \ {\n \t\tNO_MAGIC,\n \t\tADD_LF_BEFORE_NON_EMPTY,\n@@ -1793,9 +1822,21 @@ static\
    \ size_t format_commit_item(struct strbuf *sb, /* in UTF-8 */\n \tdefault:\n \t\
    \tbreak;\n \t}\n-\tif (magic != NO_MAGIC)\n+\tif (magic != NO_MAGIC) {\n \t\t\
    placeholder++;\n \n+\t\tswitch (placeholder[0]) {\n+\t\tcase 'w':\n+\t\t\t/*\n\
    +\t\t\t * `%+w()` cannot ever expand to a non-empty string,\n+\t\t\t * and it\
    \ potentially changes the layout of preceding\n+\t\t\t * contents. We're thus\
    \ not able to handle the magic in\n+\t\t\t * this combination and refuse the pattern.\n\
    +\t\t\t */\n+\t\t\treturn 0;\n+\t\t};\n+\t}\n+\n \torig_len = sb->len;\n \tif\
    \ (((struct format_commit_context *)context)->flush_type != no_flush)\n \t\tconsumed\
    \ = format_and_pad_commit(sb, placeholder, context);"
  - "--- a/utf8.c\n+++ b/utf8.c\n@@ -206,26 +206,34 @@ int utf8_width(const char **start,\
    \ size_t *remainder_p)\n  * string, assuming that the string is utf8.  Returns\
    \ strlen() instead\n  * if the string does not look like a valid utf8 string.\n\
    \  */\n-int utf8_strnwidth(const char *string, int len, int skip_ansi)\n+int utf8_strnwidth(const\
    \ char *string, size_t len, int skip_ansi)\n {\n-\tint width = 0;\n \tconst char\
    \ *orig = string;\n+\tsize_t width = 0;\n \n-\tif (len == -1)\n-\t\tlen = strlen(string);\n\
    \ \twhile (string && string < orig + len) {\n-\t\tint skip;\n+\t\tint glyph_width;\n\
    +\t\tsize_t skip;\n+\n \t\twhile (skip_ansi &&\n \t\t       (skip = display_mode_esc_sequence_len(string))\
    \ != 0)\n \t\t\tstring += skip;\n-\t\twidth += utf8_width(&string, NULL);\n+\n\
    +\t\tglyph_width = utf8_width(&string, NULL);\n+\t\tif (glyph_width > 0)\n+\t\t\
    \twidth += glyph_width;\n \t}\n-\treturn string ? width : len;\n+\n+\t/*\n+\t\
    \ * TODO: fix the interface of this function and `utf8_strwidth()` to\n+\t * return\
    \ `size_t` instead of `int`.\n+\t */\n+\treturn cast_size_t_to_int(string ? width\
    \ : len);\n }\n \n int utf8_strwidth(const char *string)\n {\n-\treturn utf8_strnwidth(string,\
    \ -1, 0);\n+\treturn utf8_strnwidth(string, strlen(string), 0);\n }\n \n int is_utf8(const\
    \ char *text)\n@@ -357,51 +365,52 @@ void strbuf_add_wrapped_bytes(struct strbuf\
    \ *buf, const char *data, int len,\n void strbuf_utf8_replace(struct strbuf *sb_src,\
    \ int pos, int width,\n \t\t\t const char *subst)\n {\n-\tstruct strbuf sb_dst\
    \ = STRBUF_INIT;\n-\tchar *src = sb_src->buf;\n-\tchar *end = src + sb_src->len;\n\
    -\tchar *dst;\n-\tint w = 0, subst_len = 0;\n+\tconst char *src = sb_src->buf,\
    \ *end = sb_src->buf + sb_src->len;\n+\tstruct strbuf dst;\n+\tint w = 0;\n \n\
    -\tif (subst)\n-\t\tsubst_len = strlen(subst);\n-\tstrbuf_grow(&sb_dst, sb_src->len\
    \ + subst_len);\n-\tdst = sb_dst.buf;\n+\tstrbuf_init(&dst, sb_src->len);\n \n\
    \ \twhile (src < end) {\n-\t\tchar *old;\n+\t\tconst char *old;\n+\t\tint glyph_width;\n\
    \ \t\tsize_t n;\n \n \t\twhile ((n = display_mode_esc_sequence_len(src))) {\n\
    -\t\t\tmemcpy(dst, src, n);\n+\t\t\tstrbuf_add(&dst, src, n);\n \t\t\tsrc += n;\n\
    -\t\t\tdst += n;\n \t\t}\n \n \t\tif (src >= end)\n \t\t\tbreak;\n \n \t\told\
    \ = src;\n-\t\tn = utf8_width((const char**)&src, NULL);\n-\t\tif (!src) \t/*\
    \ broken utf-8, do nothing */\n+\t\tglyph_width = utf8_width((const char**)&src,\
    \ NULL);\n+\t\tif (!src) /* broken utf-8, do nothing */\n \t\t\tgoto out;\n-\t\
    \tif (n && w >= pos && w < pos + width) {\n+\n+\t\t/*\n+\t\t * In case we see\
    \ a control character we copy it into the\n+\t\t * buffer, but don't add it to\
    \ the width.\n+\t\t */\n+\t\tif (glyph_width < 0)\n+\t\t\tglyph_width = 0;\n+\n\
    +\t\tif (glyph_width && w >= pos && w < pos + width) {\n \t\t\tif (subst) {\n\
    -\t\t\t\tmemcpy(dst, subst, subst_len);\n-\t\t\t\tdst += subst_len;\n+\t\t\t\t\
    strbuf_addstr(&dst, subst);\n \t\t\t\tsubst = NULL;\n \t\t\t}\n-\t\t\tw += n;\n\
    -\t\t\tcontinue;\n+\t\t} else {\n+\t\t\tstrbuf_add(&dst, old, src - old);\n \t\
    \t}\n-\t\tmemcpy(dst, old, src - old);\n-\t\tdst += src - old;\n-\t\tw += n;\n\
    +\n+\t\tw += glyph_width;\n \t}\n-\tstrbuf_setlen(&sb_dst, dst - sb_dst.buf);\n\
    -\tstrbuf_swap(sb_src, &sb_dst);\n+\n+\tstrbuf_swap(sb_src, &dst);\n out:\n-\t\
    strbuf_release(&sb_dst);\n+\tstrbuf_release(&dst);\n }\n \n /*\n@@ -796,7 +805,7\
    \ @@ int skip_utf8_bom(char **text, size_t len)\n void strbuf_utf8_align(struct\
    \ strbuf *buf, align_type position, unsigned int width,\n \t\t       const char\
    \ *s)\n {\n-\tint slen = strlen(s);\n+\tsize_t slen = strlen(s);\n \tint display_len\
    \ = utf8_strnwidth(s, slen, 0);\n \tint utf8_compensation = slen - display_len;\n\
    \ "
  identifiers:
  - CVE-2022-23521
  - CWE-190
  overview: Git is distributed revision control system. gitattributes are a mechanism
    to allow defining attributes for paths. These attributes can be defined by adding
    a `.gitattributes` file to the repository, which contains a set of file patterns
    and the attributes that should be set for paths matching this pattern. When parsing
    gitattributes, multiple integer overflows can occur when there is a huge number
    of path patterns, a huge number of attributes for a single pattern, or when the
    declared attribute names are huge. These overflows can be triggered via a crafted
    `.gitattributes` file that may be part of the commit history. Git silently splits
    lines longer than 2KB when parsing gitattributes from a file, but not when parsing
    them from the index. Consequentially, the failure mode depends on whether the
    file exists in the working tree, the index or both. This integer overflow can
    result in arbitrary heap reads and writes, which may result in remote code execution.
    The problem has been patched in the versions published on 2023-01-17, going back
    to v2.30.7. Users are advised to upgrade. There are no known workarounds for this
    issue.
  references:
  - source: security-advisories@github.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/git/git/commit/508386c6c5857b4faa2c3e491f422c98cc69ae76
  - source: security-advisories@github.com
    tags:
    - Third Party Advisory
    url: https://github.com/git/git/security/advisories/GHSA-c738-c5qq-xg89
  - source: security-advisories@github.com
    url: https://security.gentoo.org/glsa/202312-15
  title: Git is distributed revision control system. gitattributes are a mechanism
    to allow defining attributes for paths. These attributes can be defined by adding
    a `.gitattributes` file to the repository, which contains a set of file patterns
    and the attributes that should be set for paths matching this pattern. When parsing
    gitattributes, multiple integer overflows can occur when there is a huge number
    of path patterns, a huge number of attributes for a single pattern, or when the
    declared attribute names are huge. These overflows can be triggered via a crafted
    `.gitattributes` file that may be part of the commit history. Git silently splits
    lines longer than 2KB when parsing gitattributes from a file, but not when parsing
    them from the index. Consequentially, the failure mode depends on whether the
    file exists in the working tree, the index or both. This integer overflow can
    result in arbitrary heap reads and writes, which may result in remote code execution.
    The problem has been patched in the versions published on 2023-01-17, going back
    to v2.30.7. Users are advised to upgrade. There are no known workarounds for this
    issue.
- diff_content:
  - "--- a/attr.c\n+++ b/attr.c\n@@ -24,7 +24,7 @@ static const char git_attr__unknown[]\
    \ = \"(builtin)unknown\";\n #define ATTR__UNKNOWN git_attr__unknown\n \n struct\
    \ git_attr {\n-\tint attr_nr; /* unique attribute number */\n+\tunsigned int attr_nr;\
    \ /* unique attribute number */\n \tchar name[FLEX_ARRAY]; /* attribute name */\n\
    \ };\n \n@@ -206,7 +206,7 @@ static void report_invalid_attr(const char *name,\
    \ size_t len,\n  * dictionary.  If no entry is found, create a new attribute and\
    \ store it in\n  * the dictionary.\n  */\n-static const struct git_attr *git_attr_internal(const\
    \ char *name, int namelen)\n+static const struct git_attr *git_attr_internal(const\
    \ char *name, size_t namelen)\n {\n \tstruct git_attr *a;\n \n@@ -222,8 +222,8\
    \ @@ static const struct git_attr *git_attr_internal(const char *name, int namelen)\n\
    \ \t\ta->attr_nr = hashmap_get_size(&g_attr_hashmap.map);\n \n \t\tattr_hashmap_add(&g_attr_hashmap,\
    \ a->name, namelen, a);\n-\t\tassert(a->attr_nr ==\n-\t\t       (hashmap_get_size(&g_attr_hashmap.map)\
    \ - 1));\n+\t\tif (a->attr_nr != hashmap_get_size(&g_attr_hashmap.map) - 1)\n\
    +\t\t\tdie(_(\"unable to add additional attribute\"));\n \t}\n \n \thashmap_unlock(&g_attr_hashmap);\n\
    @@ -268,7 +268,7 @@ struct match_attr {\n \t\tconst struct git_attr *attr;\n \t\
    } u;\n \tchar is_macro;\n-\tunsigned num_attr;\n+\tsize_t num_attr;\n \tstruct\
    \ attr_state state[FLEX_ARRAY];\n };\n \n@@ -289,7 +289,7 @@ static const char\
    \ *parse_attr(const char *src, int lineno, const char *cp,\n \t\t\t      struct\
    \ attr_state *e)\n {\n \tconst char *ep, *equals;\n-\tint len;\n+\tsize_t len;\n\
    \ \n \tep = cp + strcspn(cp, blank);\n \tequals = strchr(cp, '=');\n@@ -333,8\
    \ +333,7 @@ static const char *parse_attr(const char *src, int lineno, const char\
    \ *cp,\n static struct match_attr *parse_attr_line(const char *line, const char\
    \ *src,\n \t\t\t\t\t  int lineno, unsigned flags)\n {\n-\tint namelen;\n-\tint\
    \ num_attr, i;\n+\tsize_t namelen, num_attr, i;\n \tconst char *cp, *name, *states;\n\
    \ \tstruct match_attr *res = NULL;\n \tint is_macro;\n@@ -345,6 +344,11 @@ static\
    \ struct match_attr *parse_attr_line(const char *line, const char *src,\n \t\t\
    return NULL;\n \tname = cp;\n \n+\tif (strlen(line) >= ATTR_MAX_LINE_LENGTH) {\n\
    +\t\twarning(_(\"ignoring overly long attributes line %d\"), lineno);\n+\t\treturn\
    \ NULL;\n+\t}\n+\n \tif (*cp == '\"' && !unquote_c_style(&pattern, name, &states))\
    \ {\n \t\tname = pattern.buf;\n \t\tnamelen = pattern.len;\n@@ -381,10 +385,9\
    \ @@ static struct match_attr *parse_attr_line(const char *line, const char *src,\n\
    \ \t\t\tgoto fail_return;\n \t}\n \n-\tres = xcalloc(1,\n-\t\t      sizeof(*res)\
    \ +\n-\t\t      sizeof(struct attr_state) * num_attr +\n-\t\t      (is_macro ?\
    \ 0 : namelen + 1));\n+\tres = xcalloc(1, st_add3(sizeof(*res),\n+\t\t\t\t st_mult(sizeof(struct\
    \ attr_state), num_attr),\n+\t\t\t\t is_macro ? 0 : namelen + 1));\n \tif (is_macro)\
    \ {\n \t\tres->u.attr = git_attr_internal(name, namelen);\n \t} else {\n@@ -447,11\
    \ +450,12 @@ struct attr_stack {\n \n static void attr_stack_free(struct attr_stack\
    \ *e)\n {\n-\tint i;\n+\tunsigned i;\n \tfree(e->origin);\n \tfor (i = 0; i <\
    \ e->num_matches; i++) {\n \t\tstruct match_attr *a = e->attrs[i];\n-\t\tint j;\n\
    +\t\tsize_t j;\n+\n \t\tfor (j = 0; j < a->num_attr; j++) {\n \t\t\tconst char\
    \ *setto = a->state[j].setto;\n \t\t\tif (setto == ATTR__TRUE ||\n@@ -660,8 +664,8\
    \ @@ static void handle_attr_line(struct attr_stack *res,\n \ta = parse_attr_line(line,\
    \ src, lineno, flags);\n \tif (!a)\n \t\treturn;\n-\tALLOC_GROW(res->attrs, res->num_matches\
    \ + 1, res->alloc);\n-\tres->attrs[res->num_matches++] = a;\n+\tALLOC_GROW_BY(res->attrs,\
    \ res->num_matches, 1, res->alloc);\n+\tres->attrs[res->num_matches - 1] = a;\n\
    \ }\n \n static struct attr_stack *read_attr_from_array(const char **list)\n@@\
    \ -701,11 +705,12 @@ void git_attr_set_direction(enum git_attr_direction new_direction)\n\
    \ \n static struct attr_stack *read_attr_from_file(const char *path, unsigned\
    \ flags)\n {\n+\tstruct strbuf buf = STRBUF_INIT;\n \tint fd;\n \tFILE *fp;\n\
    \ \tstruct attr_stack *res;\n-\tchar buf[2048];\n \tint lineno = 0;\n+\tstruct\
    \ stat st;\n \n \tif (flags & READ_ATTR_NOFOLLOW)\n \t\tfd = open_nofollow(path,\
    \ O_RDONLY);\n@@ -717,15 +722,26 @@ static struct attr_stack *read_attr_from_file(const\
    \ char *path, unsigned flags)\n \t\treturn NULL;\n \t}\n \tfp = xfdopen(fd, \"\
    r\");\n+\tif (fstat(fd, &st)) {\n+\t\twarning_errno(_(\"cannot fstat gitattributes\
    \ file '%s'\"), path);\n+\t\tfclose(fp);\n+\t\treturn NULL;\n+\t}\n+\tif (st.st_size\
    \ >= ATTR_MAX_FILE_SIZE) {\n+\t\twarning(_(\"ignoring overly large gitattributes\
    \ file '%s'\"), path);\n+\t\tfclose(fp);\n+\t\treturn NULL;\n+\t}\n \n \tCALLOC_ARRAY(res,\
    \ 1);\n-\twhile (fgets(buf, sizeof(buf), fp)) {\n-\t\tchar *bufp = buf;\n-\t\t\
    if (!lineno)\n-\t\t\tskip_utf8_bom(&bufp, strlen(bufp));\n-\t\thandle_attr_line(res,\
    \ bufp, path, ++lineno, flags);\n+\twhile (strbuf_getline(&buf, fp) != EOF) {\n\
    +\t\tif (!lineno && starts_with(buf.buf, utf8_bom))\n+\t\t\tstrbuf_remove(&buf,\
    \ 0, strlen(utf8_bom));\n+\t\thandle_attr_line(res, buf.buf, path, ++lineno, flags);\n\
    \ \t}\n+\n \tfclose(fp);\n+\tstrbuf_release(&buf);\n \treturn res;\n }\n \n@@\
    \ -736,6 +752,7 @@ static struct attr_stack *read_attr_from_index(struct index_state\
    \ *istate,\n \tstruct attr_stack *res;\n \tchar *buf, *sp;\n \tint lineno = 0;\n\
    +\tsize_t size;\n \n \tif (!istate)\n \t\treturn NULL;\n@@ -754,9 +771,13 @@ static\
    \ struct attr_stack *read_attr_from_index(struct index_state *istate,\n \tif (!path_in_cone_mode_sparse_checkout(path,\
    \ istate))\n \t\treturn NULL;\n \n-\tbuf = read_blob_data_from_index(istate, path,\
    \ NULL);\n+\tbuf = read_blob_data_from_index(istate, path, &size);\n \tif (!buf)\n\
    \ \t\treturn NULL;\n+\tif (size >= ATTR_MAX_FILE_SIZE) {\n+\t\twarning(_(\"ignoring\
    \ overly large gitattributes blob '%s'\"), path);\n+\t\treturn NULL;\n+\t}\n \n\
    \ \tCALLOC_ARRAY(res, 1);\n \tfor (sp = buf; *sp; ) {\n@@ -999,12 +1020,12 @@\
    \ static int macroexpand_one(struct all_attrs_item *all_attrs, int nr, int rem);\n\
    \ static int fill_one(struct all_attrs_item *all_attrs,\n \t\t    const struct\
    \ match_attr *a, int rem)\n {\n-\tint i;\n+\tsize_t i;\n \n-\tfor (i = a->num_attr\
    \ - 1; rem > 0 && i >= 0; i--) {\n-\t\tconst struct git_attr *attr = a->state[i].attr;\n\
    +\tfor (i = a->num_attr; rem > 0 && i > 0; i--) {\n+\t\tconst struct git_attr\
    \ *attr = a->state[i - 1].attr;\n \t\tconst char **n = &(all_attrs[attr->attr_nr].value);\n\
    -\t\tconst char *v = a->state[i].setto;\n+\t\tconst char *v = a->state[i - 1].setto;\n\
    \ \n \t\tif (*n == ATTR__UNKNOWN) {\n \t\t\t*n = v;\n@@ -1020,11 +1041,11 @@ static\
    \ int fill(const char *path, int pathlen, int basename_offset,\n \t\tstruct all_attrs_item\
    \ *all_attrs, int rem)\n {\n \tfor (; rem > 0 && stack; stack = stack->prev) {\n\
    -\t\tint i;\n+\t\tunsigned i;\n \t\tconst char *base = stack->origin ? stack->origin\
    \ : \"\";\n \n-\t\tfor (i = stack->num_matches - 1; 0 < rem && 0 <= i; i--) {\n\
    -\t\t\tconst struct match_attr *a = stack->attrs[i];\n+\t\tfor (i = stack->num_matches;\
    \ 0 < rem && 0 < i; i--) {\n+\t\t\tconst struct match_attr *a = stack->attrs[i\
    \ - 1];\n \t\t\tif (a->is_macro)\n \t\t\t\tcontinue;\n \t\t\tif (path_matches(path,\
    \ pathlen, basename_offset,\n@@ -1055,11 +1076,11 @@ static void determine_macros(struct\
    \ all_attrs_item *all_attrs,\n \t\t\t     const struct attr_stack *stack)\n {\n\
    \ \tfor (; stack; stack = stack->prev) {\n-\t\tint i;\n-\t\tfor (i = stack->num_matches\
    \ - 1; i >= 0; i--) {\n-\t\t\tconst struct match_attr *ma = stack->attrs[i];\n\
    +\t\tunsigned i;\n+\t\tfor (i = stack->num_matches; i > 0; i--) {\n+\t\t\tconst\
    \ struct match_attr *ma = stack->attrs[i - 1];\n \t\t\tif (ma->is_macro) {\n-\t\
    \t\t\tint n = ma->u.attr->attr_nr;\n+\t\t\t\tunsigned int n = ma->u.attr->attr_nr;\n\
    \ \t\t\t\tif (!all_attrs[n].macro) {\n \t\t\t\t\tall_attrs[n].macro = ma;\n \t\
    \t\t\t}\n@@ -1111,7 +1132,7 @@ void git_check_attr(struct index_state *istate,\n\
    \ \tcollect_some_attrs(istate, path, check);\n \n \tfor (i = 0; i < check->nr;\
    \ i++) {\n-\t\tsize_t n = check->items[i].attr->attr_nr;\n+\t\tunsigned int n\
    \ = check->items[i].attr->attr_nr;\n \t\tconst char *value = check->all_attrs[n].value;\n\
    \ \t\tif (value == ATTR__UNKNOWN)\n \t\t\tvalue = ATTR__UNSET;"
  - "--- a/column.c\n+++ b/column.c\n@@ -23,7 +23,7 @@ struct column_data {\n /* return\
    \ length of 's' in letters, ANSI escapes stripped */\n static int item_length(const\
    \ char *s)\n {\n-\treturn utf8_strnwidth(s, -1, 1);\n+\treturn utf8_strnwidth(s,\
    \ strlen(s), 1);\n }\n \n /*"
  - "--- a/fsck.c\n+++ b/fsck.c\n@@ -2,6 +2,7 @@\n #include \"object-store.h\"\n #include\
    \ \"repository.h\"\n #include \"object.h\"\n+#include \"attr.h\"\n #include \"\
    blob.h\"\n #include \"tree.h\"\n #include \"tree-walk.h\"\n@@ -614,17 +615,22\
    \ @@ static int fsck_tree(const struct object_id *tree_oid,\n \t\t\t\t\t\t \"\
    .gitmodules is a symbolic link\");\n \t\t}\n \n+\t\tif (is_hfs_dotgitattributes(name)\
    \ || is_ntfs_dotgitattributes(name)) {\n+\t\t\tif (!S_ISLNK(mode))\n+\t\t\t\t\
    oidset_insert(&options->gitattributes_found,\n+\t\t\t\t\t      entry_oid);\n+\t\
    \t\telse\n+\t\t\t\tretval += report(options, tree_oid, OBJ_TREE,\n+\t\t\t\t\t\t\
    \ FSCK_MSG_GITATTRIBUTES_SYMLINK,\n+\t\t\t\t\t\t \".gitattributes is a symlink\"\
    );\n+\t\t}\n+\n \t\tif (S_ISLNK(mode)) {\n \t\t\tif (is_hfs_dotgitignore(name)\
    \ ||\n \t\t\t    is_ntfs_dotgitignore(name))\n \t\t\t\tretval += report(options,\
    \ tree_oid, OBJ_TREE,\n \t\t\t\t\t\t FSCK_MSG_GITIGNORE_SYMLINK,\n \t\t\t\t\t\t\
    \ \".gitignore is a symlink\");\n-\t\t\tif (is_hfs_dotgitattributes(name) ||\n\
    -\t\t\t    is_ntfs_dotgitattributes(name))\n-\t\t\t\tretval += report(options,\
    \ tree_oid, OBJ_TREE,\n-\t\t\t\t\t\t FSCK_MSG_GITATTRIBUTES_SYMLINK,\n-\t\t\t\t\
    \t\t \".gitattributes is a symlink\");\n \t\t\tif (is_hfs_dotmailmap(name) ||\n\
    \ \t\t\t    is_ntfs_dotmailmap(name))\n \t\t\t\tretval += report(options, tree_oid,\
    \ OBJ_TREE,\n@@ -1159,38 +1165,70 @@ static int fsck_gitmodules_fn(const char\
    \ *var, const char *value, void *vdata)\n static int fsck_blob(const struct object_id\
    \ *oid, const char *buf,\n \t\t     unsigned long size, struct fsck_options *options)\n\
    \ {\n-\tstruct fsck_gitmodules_data data;\n-\tstruct config_options config_opts\
    \ = { 0 };\n-\n-\tif (!oidset_contains(&options->gitmodules_found, oid))\n-\t\t\
    return 0;\n-\toidset_insert(&options->gitmodules_done, oid);\n+\tint ret = 0;\n\
    \ \n \tif (object_on_skiplist(options, oid))\n \t\treturn 0;\n \n-\tif (!buf)\
    \ {\n-\t\t/*\n-\t\t * A missing buffer here is a sign that the caller found the\n\
    -\t\t * blob too gigantic to load into memory. Let's just consider\n-\t\t * that\
    \ an error.\n-\t\t */\n-\t\treturn report(options, oid, OBJ_BLOB,\n-\t\t\t   \
    \   FSCK_MSG_GITMODULES_LARGE,\n-\t\t\t      \".gitmodules too large to parse\"\
    );\n+\tif (oidset_contains(&options->gitmodules_found, oid)) {\n+\t\tstruct config_options\
    \ config_opts = { 0 };\n+\t\tstruct fsck_gitmodules_data data;\n+\n+\t\toidset_insert(&options->gitmodules_done,\
    \ oid);\n+\n+\t\tif (!buf) {\n+\t\t\t/*\n+\t\t\t * A missing buffer here is a\
    \ sign that the caller found the\n+\t\t\t * blob too gigantic to load into memory.\
    \ Let's just consider\n+\t\t\t * that an error.\n+\t\t\t */\n+\t\t\treturn report(options,\
    \ oid, OBJ_BLOB,\n+\t\t\t\t\tFSCK_MSG_GITMODULES_LARGE,\n+\t\t\t\t\t\".gitmodules\
    \ too large to parse\");\n+\t\t}\n+\n+\t\tdata.oid = oid;\n+\t\tdata.options =\
    \ options;\n+\t\tdata.ret = 0;\n+\t\tconfig_opts.error_action = CONFIG_ERROR_SILENT;\n\
    +\t\tif (git_config_from_mem(fsck_gitmodules_fn, CONFIG_ORIGIN_BLOB,\n+\t\t\t\t\
    \t\".gitmodules\", buf, size, &data, &config_opts))\n+\t\t\tdata.ret |= report(options,\
    \ oid, OBJ_BLOB,\n+\t\t\t\t\tFSCK_MSG_GITMODULES_PARSE,\n+\t\t\t\t\t\"could not\
    \ parse gitmodules blob\");\n+\t\tret |= data.ret;\n \t}\n \n-\tdata.oid = oid;\n\
    -\tdata.options = options;\n-\tdata.ret = 0;\n-\tconfig_opts.error_action = CONFIG_ERROR_SILENT;\n\
    -\tif (git_config_from_mem(fsck_gitmodules_fn, CONFIG_ORIGIN_BLOB,\n-\t\t\t\t\"\
    .gitmodules\", buf, size, &data, &config_opts))\n-\t\tdata.ret |= report(options,\
    \ oid, OBJ_BLOB,\n-\t\t\t\t   FSCK_MSG_GITMODULES_PARSE,\n-\t\t\t\t   \"could\
    \ not parse gitmodules blob\");\n-\n-\treturn data.ret;\n+\tif (oidset_contains(&options->gitattributes_found,\
    \ oid)) {\n+\t\tconst char *ptr;\n+\n+\t\toidset_insert(&options->gitattributes_done,\
    \ oid);\n+\n+\t\tif (!buf || size > ATTR_MAX_FILE_SIZE) {\n+\t\t\t/*\n+\t\t\t\
    \ * A missing buffer here is a sign that the caller found the\n+\t\t\t * blob\
    \ too gigantic to load into memory. Let's just consider\n+\t\t\t * that an error.\n\
    +\t\t\t */\n+\t\t\treturn report(options, oid, OBJ_BLOB,\n+\t\t\t\t\tFSCK_MSG_GITATTRIBUTES_LARGE,\n\
    +\t\t\t\t\t\".gitattributes too large to parse\");\n+\t\t}\n+\n+\t\tfor (ptr =\
    \ buf; *ptr; ) {\n+\t\t\tconst char *eol = strchrnul(ptr, '\\n');\n+\t\t\tif (eol\
    \ - ptr >= ATTR_MAX_LINE_LENGTH) {\n+\t\t\t\tret |= report(options, oid, OBJ_BLOB,\n\
    +\t\t\t\t\t      FSCK_MSG_GITATTRIBUTES_LINE_LENGTH,\n+\t\t\t\t\t      \".gitattributes\
    \ has too long lines to parse\");\n+\t\t\t\tbreak;\n+\t\t\t}\n+\n+\t\t\tptr =\
    \ *eol ? eol + 1 : eol;\n+\t\t}\n+\t}\n+\n+\treturn ret;\n }\n \n int fsck_object(struct\
    \ object *obj, void *data, unsigned long size,\n@@ -1229,45 +1267,58 @@ int fsck_error_function(struct\
    \ fsck_options *o,\n \treturn 1;\n }\n \n-int fsck_finish(struct fsck_options\
    \ *options)\n+static int fsck_blobs(struct oidset *blobs_found, struct oidset\
    \ *blobs_done,\n+\t\t      enum fsck_msg_id msg_missing, enum fsck_msg_id msg_type,\n\
    +\t\t      struct fsck_options *options, const char *blob_type)\n {\n \tint ret\
    \ = 0;\n \tstruct oidset_iter iter;\n \tconst struct object_id *oid;\n \n-\toidset_iter_init(&options->gitmodules_found,\
    \ &iter);\n+\toidset_iter_init(blobs_found, &iter);\n \twhile ((oid = oidset_iter_next(&iter)))\
    \ {\n \t\tenum object_type type;\n \t\tunsigned long size;\n \t\tchar *buf;\n\
    \ \n-\t\tif (oidset_contains(&options->gitmodules_done, oid))\n+\t\tif (oidset_contains(blobs_done,\
    \ oid))\n \t\t\tcontinue;\n \n \t\tbuf = read_object_file(oid, &type, &size);\n\
    \ \t\tif (!buf) {\n \t\t\tif (is_promisor_object(oid))\n \t\t\t\tcontinue;\n \t\
    \t\tret |= report(options,\n-\t\t\t\t      oid, OBJ_BLOB,\n-\t\t\t\t      FSCK_MSG_GITMODULES_MISSING,\n\
    -\t\t\t\t      \"unable to read .gitmodules blob\");\n+\t\t\t\t      oid, OBJ_BLOB,\
    \ msg_missing,\n+\t\t\t\t      \"unable to read %s blob\", blob_type);\n \t\t\t\
    continue;\n \t\t}\n \n \t\tif (type == OBJ_BLOB)\n \t\t\tret |= fsck_blob(oid,\
    \ buf, size, options);\n \t\telse\n-\t\t\tret |= report(options,\n-\t\t\t\t  \
    \    oid, type,\n-\t\t\t\t      FSCK_MSG_GITMODULES_BLOB,\n-\t\t\t\t      \"non-blob\
    \ found at .gitmodules\");\n+\t\t\tret |= report(options, oid, type, msg_type,\n\
    +\t\t\t\t      \"non-blob found at %s\", blob_type);\n \t\tfree(buf);\n \t}\n\
    \ \n+\toidset_clear(blobs_found);\n+\toidset_clear(blobs_done);\n+\n+\treturn\
    \ ret;\n+}\n+\n+int fsck_finish(struct fsck_options *options)\n+{\n+\tint ret\
    \ = 0;\n+\n+\tret |= fsck_blobs(&options->gitmodules_found, &options->gitmodules_done,\n\
    +\t\t\t  FSCK_MSG_GITMODULES_MISSING, FSCK_MSG_GITMODULES_BLOB,\n+\t\t\t  options,\
    \ \".gitmodules\");\n+\tret |= fsck_blobs(&options->gitattributes_found, &options->gitattributes_done,\n\
    +\t\t\t  FSCK_MSG_GITATTRIBUTES_MISSING, FSCK_MSG_GITATTRIBUTES_BLOB,\n+\t\t\t\
    \  options, \".gitattributes\");\n \n-\toidset_clear(&options->gitmodules_found);\n\
    -\toidset_clear(&options->gitmodules_done);\n \treturn ret;\n }\n "
  - "--- a/pretty.c\n+++ b/pretty.c\n@@ -14,6 +14,13 @@\n #include \"trailer.h\"\n\
    \ #include \"run-command.h\"\n \n+/*\n+ * The limit for formatting directives,\
    \ which enable the caller to append\n+ * arbitrarily many bytes to the formatted\
    \ buffer. This includes padding\n+ * and wrapping formatters.\n+ */\n+#define\
    \ FORMATTING_LIMIT (16 * 1024)\n+\n static char *user_format;\n static struct\
    \ cmt_fmt_map {\n \tconst char *name;\n@@ -994,7 +1001,9 @@ static void strbuf_wrap(struct\
    \ strbuf *sb, size_t pos,\n \tif (pos)\n \t\tstrbuf_add(&tmp, sb->buf, pos);\n\
    \ \tstrbuf_add_wrapped_text(&tmp, sb->buf + pos,\n-\t\t\t\t(int) indent1, (int)\
    \ indent2, (int) width);\n+\t\t\t\tcast_size_t_to_int(indent1),\n+\t\t\t\tcast_size_t_to_int(indent2),\n\
    +\t\t\t\tcast_size_t_to_int(width));\n \tstrbuf_swap(&tmp, sb);\n \tstrbuf_release(&tmp);\n\
    \ }\n@@ -1120,9 +1129,18 @@ static size_t parse_padding_placeholder(const char\
    \ *placeholder,\n \t\tconst char *end = start + strcspn(start, \",)\");\n \t\t\
    char *next;\n \t\tint width;\n-\t\tif (!end || end == start)\n+\t\tif (!*end ||\
    \ end == start)\n \t\t\treturn 0;\n \t\twidth = strtol(start, &next, 10);\n+\n\
    +\t\t/*\n+\t\t * We need to limit the amount of padding, or otherwise this\n+\t\
    \t * would allow the user to pad the buffer by arbitrarily many\n+\t\t * bytes\
    \ and thus cause resource exhaustion.\n+\t\t */\n+\t\tif (width < -FORMATTING_LIMIT\
    \ || width > FORMATTING_LIMIT)\n+\t\t\treturn 0;\n+\n \t\tif (next == start ||\
    \ width == 0)\n \t\t\treturn 0;\n \t\tif (width < 0) {\n@@ -1405,6 +1423,16 @@\
    \ static size_t format_commit_one(struct strbuf *sb, /* in UTF-8 */\n \t\t\t\t\
    if (*next != ')')\n \t\t\t\t\treturn 0;\n \t\t\t}\n+\n+\t\t\t/*\n+\t\t\t * We\
    \ need to limit the format here as it allows the\n+\t\t\t * user to prepend arbitrarily\
    \ many bytes to the buffer\n+\t\t\t * when rewrapping.\n+\t\t\t */\n+\t\t\tif\
    \ (width > FORMATTING_LIMIT ||\n+\t\t\t    indent1 > FORMATTING_LIMIT ||\n+\t\t\
    \t    indent2 > FORMATTING_LIMIT)\n+\t\t\t\treturn 0;\n \t\t\trewrap_message_tail(sb,\
    \ c, width, indent1, indent2);\n \t\t\treturn end - placeholder + 1;\n \t\t} else\n\
    @@ -1670,19 +1698,21 @@ static size_t format_and_pad_commit(struct strbuf *sb,\
    \ /* in UTF-8 */\n \t\t\t\t    struct format_commit_context *c)\n {\n \tstruct\
    \ strbuf local_sb = STRBUF_INIT;\n-\tint total_consumed = 0, len, padding = c->padding;\n\
    +\tsize_t total_consumed = 0;\n+\tint len, padding = c->padding;\n+\n \tif (padding\
    \ < 0) {\n \t\tconst char *start = strrchr(sb->buf, '\\n');\n \t\tint occupied;\n\
    \ \t\tif (!start)\n \t\t\tstart = sb->buf;\n-\t\toccupied = utf8_strnwidth(start,\
    \ -1, 1);\n+\t\toccupied = utf8_strnwidth(start, strlen(start), 1);\n \t\toccupied\
    \ += c->pretty_ctx->graph_width;\n \t\tpadding = (-padding) - occupied;\n \t}\n\
    \ \twhile (1) {\n \t\tint modifier = *placeholder == 'C';\n-\t\tint consumed =\
    \ format_commit_one(&local_sb, placeholder, c);\n+\t\tsize_t consumed = format_commit_one(&local_sb,\
    \ placeholder, c);\n \t\ttotal_consumed += consumed;\n \n \t\tif (!modifier)\n\
    @@ -1694,7 +1724,7 @@ static size_t format_and_pad_commit(struct strbuf *sb, /*\
    \ in UTF-8 */\n \t\tplaceholder++;\n \t\ttotal_consumed++;\n \t}\n-\tlen = utf8_strnwidth(local_sb.buf,\
    \ -1, 1);\n+\tlen = utf8_strnwidth(local_sb.buf, local_sb.len, 1);\n \n \tif (c->flush_type\
    \ == flush_left_and_steal) {\n \t\tconst char *ch = sb->buf + sb->len - 1;\n@@\
    \ -1709,7 +1739,7 @@ static size_t format_and_pad_commit(struct strbuf *sb, /*\
    \ in UTF-8 */\n \t\t\tif (*ch != 'm')\n \t\t\t\tbreak;\n \t\t\tp = ch - 1;\n-\t\
    \t\twhile (ch - p < 10 && *p != '\\033')\n+\t\t\twhile (p > sb->buf && ch - p\
    \ < 10 && *p != '\\033')\n \t\t\t\tp--;\n \t\t\tif (*p != '\\033' ||\n \t\t\t\
    \    ch + 1 - p != display_mode_esc_sequence_len(p))\n@@ -1748,7 +1778,7 @@ static\
    \ size_t format_and_pad_commit(struct strbuf *sb, /* in UTF-8 */\n \t\t}\n \t\t\
    strbuf_addbuf(sb, &local_sb);\n \t} else {\n-\t\tint sb_len = sb->len, offset\
    \ = 0;\n+\t\tsize_t sb_len = sb->len, offset = 0;\n \t\tif (c->flush_type == flush_left)\n\
    \ \t\t\toffset = padding - len;\n \t\telse if (c->flush_type == flush_both)\n\
    @@ -1771,8 +1801,7 @@ static size_t format_commit_item(struct strbuf *sb, /* in\
    \ UTF-8 */\n \t\t\t\t const char *placeholder,\n \t\t\t\t void *context)\n {\n\
    -\tint consumed;\n-\tsize_t orig_len;\n+\tsize_t consumed, orig_len;\n \tenum\
    \ {\n \t\tNO_MAGIC,\n \t\tADD_LF_BEFORE_NON_EMPTY,\n@@ -1793,9 +1822,21 @@ static\
    \ size_t format_commit_item(struct strbuf *sb, /* in UTF-8 */\n \tdefault:\n \t\
    \tbreak;\n \t}\n-\tif (magic != NO_MAGIC)\n+\tif (magic != NO_MAGIC) {\n \t\t\
    placeholder++;\n \n+\t\tswitch (placeholder[0]) {\n+\t\tcase 'w':\n+\t\t\t/*\n\
    +\t\t\t * `%+w()` cannot ever expand to a non-empty string,\n+\t\t\t * and it\
    \ potentially changes the layout of preceding\n+\t\t\t * contents. We're thus\
    \ not able to handle the magic in\n+\t\t\t * this combination and refuse the pattern.\n\
    +\t\t\t */\n+\t\t\treturn 0;\n+\t\t};\n+\t}\n+\n \torig_len = sb->len;\n \tif\
    \ (((struct format_commit_context *)context)->flush_type != no_flush)\n \t\tconsumed\
    \ = format_and_pad_commit(sb, placeholder, context);"
  - "--- a/utf8.c\n+++ b/utf8.c\n@@ -206,26 +206,34 @@ int utf8_width(const char **start,\
    \ size_t *remainder_p)\n  * string, assuming that the string is utf8.  Returns\
    \ strlen() instead\n  * if the string does not look like a valid utf8 string.\n\
    \  */\n-int utf8_strnwidth(const char *string, int len, int skip_ansi)\n+int utf8_strnwidth(const\
    \ char *string, size_t len, int skip_ansi)\n {\n-\tint width = 0;\n \tconst char\
    \ *orig = string;\n+\tsize_t width = 0;\n \n-\tif (len == -1)\n-\t\tlen = strlen(string);\n\
    \ \twhile (string && string < orig + len) {\n-\t\tint skip;\n+\t\tint glyph_width;\n\
    +\t\tsize_t skip;\n+\n \t\twhile (skip_ansi &&\n \t\t       (skip = display_mode_esc_sequence_len(string))\
    \ != 0)\n \t\t\tstring += skip;\n-\t\twidth += utf8_width(&string, NULL);\n+\n\
    +\t\tglyph_width = utf8_width(&string, NULL);\n+\t\tif (glyph_width > 0)\n+\t\t\
    \twidth += glyph_width;\n \t}\n-\treturn string ? width : len;\n+\n+\t/*\n+\t\
    \ * TODO: fix the interface of this function and `utf8_strwidth()` to\n+\t * return\
    \ `size_t` instead of `int`.\n+\t */\n+\treturn cast_size_t_to_int(string ? width\
    \ : len);\n }\n \n int utf8_strwidth(const char *string)\n {\n-\treturn utf8_strnwidth(string,\
    \ -1, 0);\n+\treturn utf8_strnwidth(string, strlen(string), 0);\n }\n \n int is_utf8(const\
    \ char *text)\n@@ -357,51 +365,52 @@ void strbuf_add_wrapped_bytes(struct strbuf\
    \ *buf, const char *data, int len,\n void strbuf_utf8_replace(struct strbuf *sb_src,\
    \ int pos, int width,\n \t\t\t const char *subst)\n {\n-\tstruct strbuf sb_dst\
    \ = STRBUF_INIT;\n-\tchar *src = sb_src->buf;\n-\tchar *end = src + sb_src->len;\n\
    -\tchar *dst;\n-\tint w = 0, subst_len = 0;\n+\tconst char *src = sb_src->buf,\
    \ *end = sb_src->buf + sb_src->len;\n+\tstruct strbuf dst;\n+\tint w = 0;\n \n\
    -\tif (subst)\n-\t\tsubst_len = strlen(subst);\n-\tstrbuf_grow(&sb_dst, sb_src->len\
    \ + subst_len);\n-\tdst = sb_dst.buf;\n+\tstrbuf_init(&dst, sb_src->len);\n \n\
    \ \twhile (src < end) {\n-\t\tchar *old;\n+\t\tconst char *old;\n+\t\tint glyph_width;\n\
    \ \t\tsize_t n;\n \n \t\twhile ((n = display_mode_esc_sequence_len(src))) {\n\
    -\t\t\tmemcpy(dst, src, n);\n+\t\t\tstrbuf_add(&dst, src, n);\n \t\t\tsrc += n;\n\
    -\t\t\tdst += n;\n \t\t}\n \n \t\tif (src >= end)\n \t\t\tbreak;\n \n \t\told\
    \ = src;\n-\t\tn = utf8_width((const char**)&src, NULL);\n-\t\tif (!src) \t/*\
    \ broken utf-8, do nothing */\n+\t\tglyph_width = utf8_width((const char**)&src,\
    \ NULL);\n+\t\tif (!src) /* broken utf-8, do nothing */\n \t\t\tgoto out;\n-\t\
    \tif (n && w >= pos && w < pos + width) {\n+\n+\t\t/*\n+\t\t * In case we see\
    \ a control character we copy it into the\n+\t\t * buffer, but don't add it to\
    \ the width.\n+\t\t */\n+\t\tif (glyph_width < 0)\n+\t\t\tglyph_width = 0;\n+\n\
    +\t\tif (glyph_width && w >= pos && w < pos + width) {\n \t\t\tif (subst) {\n\
    -\t\t\t\tmemcpy(dst, subst, subst_len);\n-\t\t\t\tdst += subst_len;\n+\t\t\t\t\
    strbuf_addstr(&dst, subst);\n \t\t\t\tsubst = NULL;\n \t\t\t}\n-\t\t\tw += n;\n\
    -\t\t\tcontinue;\n+\t\t} else {\n+\t\t\tstrbuf_add(&dst, old, src - old);\n \t\
    \t}\n-\t\tmemcpy(dst, old, src - old);\n-\t\tdst += src - old;\n-\t\tw += n;\n\
    +\n+\t\tw += glyph_width;\n \t}\n-\tstrbuf_setlen(&sb_dst, dst - sb_dst.buf);\n\
    -\tstrbuf_swap(sb_src, &sb_dst);\n+\n+\tstrbuf_swap(sb_src, &dst);\n out:\n-\t\
    strbuf_release(&sb_dst);\n+\tstrbuf_release(&dst);\n }\n \n /*\n@@ -796,7 +805,7\
    \ @@ int skip_utf8_bom(char **text, size_t len)\n void strbuf_utf8_align(struct\
    \ strbuf *buf, align_type position, unsigned int width,\n \t\t       const char\
    \ *s)\n {\n-\tint slen = strlen(s);\n+\tsize_t slen = strlen(s);\n \tint display_len\
    \ = utf8_strnwidth(s, slen, 0);\n \tint utf8_compensation = slen - display_len;\n\
    \ "
  identifiers:
  - CVE-2022-41903
  - CWE-190
  overview: Git is distributed revision control system. `git log` can display commits
    in an arbitrary format using its `--format` specifiers. This functionality is
    also exposed to `git archive` via the `export-subst` gitattribute. When processing
    the padding operators, there is a integer overflow in `pretty.c::format_and_pad_commit()`
    where a `size_t` is stored improperly as an `int`, and then added as an offset
    to a `memcpy()`. This overflow can be triggered directly by a user running a command
    which invokes the commit formatting machinery (e.g., `git log --format=...`).
    It may also be triggered indirectly through git archive via the export-subst mechanism,
    which expands format specifiers inside of files within the repository during a
    git archive. This integer overflow can result in arbitrary heap writes, which
    may result in arbitrary code execution. The problem has been patched in the versions
    published on 2023-01-17, going back to v2.30.7. Users are advised to upgrade.
    Users who are unable to upgrade should disable `git archive` in untrusted repositories.
    If you expose git archive via `git daemon`, disable it by running `git config
    --global daemon.uploadArch false`.
  references:
  - source: security-advisories@github.com
    tags:
    - Vendor Advisory
    url: https://git-scm.com/book/en/v2/Customizing-Git-Git-Attributes#_export_subst
  - source: security-advisories@github.com
    tags:
    - Vendor Advisory
    url: https://git-scm.com/docs/pretty-formats#Documentation/pretty-formats.txt-emltltNgttruncltruncmtruncem
  - source: security-advisories@github.com
    tags:
    - Patch
    - Release Notes
    - Third Party Advisory
    url: https://github.com/git/git/commit/508386c6c5857b4faa2c3e491f422c98cc69ae76
  - source: security-advisories@github.com
    tags:
    - Third Party Advisory
    url: https://github.com/git/git/security/advisories/GHSA-475x-2q3q-hvwq
  - source: security-advisories@github.com
    url: https://security.gentoo.org/glsa/202312-15
  title: Git is distributed revision control system. `git log` can display commits
    in an arbitrary format using its `--format` specifiers. This functionality is
    also exposed to `git archive` via the `export-subst` gitattribute. When processing
    the padding operators, there is a integer overflow in `pretty.c::format_and_pad_commit()`
    where a `size_t` is stored improperly as an `int`, and then added as an offset
    to a `memcpy()`. This overflow can be triggered directly by a user running a command
    which invokes the commit formatting machinery (e.g., `git log --format=...`).
    It may also be triggered indirectly through git archive via the export-subst mechanism,
    which expands format specifiers inside of files within the repository during a
    git archive. This integer overflow can result in arbitrary heap writes, which
    may result in arbitrary code execution. The problem has been patched in the versions
    published on 2023-01-17, going back to v2.30.7. Users are advised to upgrade.
    Users who are unable to upgrade should disable `git archive` in untrusted repositories.
    If you expose git archive via `git daemon`, disable it by running `git config
    --global daemon.uploadArch false`.
- diff_content:
  - "--- a/src/odf/descriptors.c\n+++ b/src/odf/descriptors.c\n@@ -1395,12 +1395,12\
    \ @@ GF_VVCConfig *gf_odf_vvc_cfg_read_bs(GF_BitStream *bs)\n \t\t\tgf_list_add(cfg->param_array,\
    \ ar);\n \t\t\tbreak;\n \t\tdefault:\n-\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CODING,\
    \ (\"[VVC] Invalid NALU type in vvcC - ignoring\\n\", ar->nalus));\n+\t\t\tGF_LOG(GF_LOG_WARNING,\
    \ GF_LOG_CODING, (\"[VVC] Invalid NALU type %d in vvcC - ignoring\\n\", ar->type));\n\
    \ \t\t\tgf_free(ar);\n \t\t\tbreak;\n \t\t}\n \n-\t\tif ((ar->type != GF_VVC_NALU_DEC_PARAM)\
    \ && (ar->type != GF_VVC_NALU_OPI))\n+\t\tif (!valid || ((ar->type != GF_VVC_NALU_DEC_PARAM)\
    \ && (ar->type != GF_VVC_NALU_OPI)))\n \t\t\tnalucount = gf_bs_read_int(bs, 16);\n\
    \ \t\telse\n \t\t\tnalucount = 1;"
  identifiers:
  - CVE-2023-0358
  - CWE-416
  overview: Use After Free in GitHub repository gpac/gpac prior to 2.3.0-DEV.
  references:
  - source: security@huntr.dev
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/gpac/gpac/commit/9971fb125cf91cefd081a080c417b90bbe4a467b
  - source: security@huntr.dev
    tags:
    - Exploit
    - Patch
    - Third Party Advisory
    url: https://huntr.dev/bounties/93e128ed-253f-4c42-81ff-fbac7fd8f355
  title: Use After Free in GitHub repository gpac/gpac prior to 2.3.0-DEV.
- diff_content:
  - "--- a/libsofia-sip-ua/stun/stun_common.c\n+++ b/libsofia-sip-ua/stun/stun_common.c\n\
    @@ -87,6 +87,13 @@ int stun_parse_message(stun_msg_t *msg)\n \n   /* parse header\
    \ first */\n   p = msg->enc_buf.data;\n+\n+  if (get16(p, 2) > (msg->enc_buf.size\
    \ - 20))\n+  {\n+    SU_DEBUG_3((\"%s: Error STUN Message Length is too big.\\\
    n\", __func__));\n+    return -1;\n+  }\n+\n   msg->stun_hdr.msg_type = get16(p,\
    \ 0);\n   msg->stun_hdr.msg_len = get16(p, 2);\n   memcpy(msg->stun_hdr.tran_id,\
    \ p + 4, STUN_TID_BYTES);\n@@ -98,8 +105,8 @@ int stun_parse_message(stun_msg_t\
    \ *msg)\n   len = msg->stun_hdr.msg_len;\n   p = msg->enc_buf.data + 20;\n   msg->stun_attr\
    \ = NULL;\n-  while (len > 0) {\n-    i = stun_parse_attribute(msg, p);\n+  while\
    \ (len >= 4) {  // Type (2) + Length (2) + Value (variable) min attribute size\n\
    +    i = stun_parse_attribute(msg, p, len);\n     if (i <= 0 || i > len) {\n \
    \      SU_DEBUG_3((\"%s: Error parsing attribute.\\n\", __func__));\n       return\
    \ -1;\n@@ -111,7 +118,7 @@ int stun_parse_message(stun_msg_t *msg)\n   return\
    \ 0;\n }\n \n-int stun_parse_attribute(stun_msg_t *msg, unsigned char *p)\n+int\
    \ stun_parse_attribute(stun_msg_t *msg, unsigned char *p, size_t left_len)\n {\n\
    \   int len;\n   uint16_t attr_type;\n@@ -120,6 +127,12 @@ int stun_parse_attribute(stun_msg_t\
    \ *msg, unsigned char *p)\n   attr_type = get16(p, 0);\n   len = get16(p, 2);\n\
    \ \n+  if ((left_len - 4) < len) // make sure we have enough space for attribute\n\
    +  {\n+    SU_DEBUG_3((\"%s: Error STUN attr len is too big.\\n\", __func__));\n\
    +    return -1;\n+  }\n+\n   SU_DEBUG_5((\"%s: received attribute: Type %02X,\
    \ Length %d - %s\\n\",\n \t      __func__, attr_type, len, stun_attr_phrase(attr_type)));\n\
    \ "
  identifiers:
  - CVE-2023-22741
  - CWE-120
  overview: 'Sofia-SIP is an open-source SIP User-Agent library, compliant with the
    IETF RFC3261 specification. In affected versions Sofia-SIP **lacks both message
    length and attributes length checks** when it handles STUN packets, leading to
    controllable heap-over-flow. For example, in stun_parse_attribute(), after we
    get the attribute''s type and length value, the length will be used directly to
    copy from the heap, regardless of the message''s left size. Since network users
    control the overflowed length, and the data is written to heap chunks later, attackers
    may achieve remote code execution by heap grooming or other exploitation methods.
    The bug was introduced 16 years ago in sofia-sip 1.12.4 (plus some patches through
    12/21/2006) to in tree libs with git-svn-id: http://svn.freeswitch.org/svn/freeswitch/trunk@3774
    d0543943-73ff-0310-b7d9-9358b9ac24b2. Users are advised to upgrade. There are
    no known workarounds for this vulnerability.'
  references:
  - source: security-advisories@github.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/freeswitch/sofia-sip/commit/da53e4fbcb138b080a75576dd49c1fff2ada2764
  - source: security-advisories@github.com
    tags:
    - Exploit
    - Patch
    - Third Party Advisory
    url: https://github.com/freeswitch/sofia-sip/security/advisories/GHSA-8599-x7rq-fr54
  - source: security-advisories@github.com
    url: https://www.debian.org/security/2023/dsa-5410
  title: 'Sofia-SIP is an open-source SIP User-Agent library, compliant with the IETF
    RFC3261 specification. In affected versions Sofia-SIP **lacks both message length
    and attributes length checks** when it handles STUN packets, leading to controllable
    heap-over-flow. For example, in stun_parse_attribute(), after we get the attribute''s
    type and length value, the length will be used directly to copy from the heap,
    regardless of the message''s left size. Since network users control the overflowed
    length, and the data is written to heap chunks later, attackers may achieve remote
    code execution by heap grooming or other exploitation methods. The bug was introduced
    16 years ago in sofia-sip 1.12.4 (plus some patches through 12/21/2006) to in
    tree libs with git-svn-id: http://svn.freeswitch.org/svn/freeswitch/trunk@3774
    d0543943-73ff-0310-b7d9-9358b9ac24b2. Users are advised to upgrade. There are
    no known workarounds for this vulnerability.'
- diff_content:
  - "--- a/src/tss2-rc/tss2_rc.c\n+++ b/src/tss2-rc/tss2_rc.c\n@@ -1,5 +1,8 @@\n /*\
    \ SPDX-License-Identifier: BSD-2-Clause */\n-\n+#ifdef HAVE_CONFIG_H\n+#include\
    \ \"config.h\"\n+#endif\n+#include <assert.h>\n #include <stdarg.h>\n #include\
    \ <stdbool.h>\n #include <stdio.h>\n@@ -846,7 +849,7 @@ tss_err_handler (TSS2_RC\
    \ rc)\n static struct {\n     char name[TSS2_ERR_LAYER_NAME_MAX];\n     TSS2_RC_HANDLER\
    \ handler;\n-} layer_handler[TPM2_ERROR_TSS2_RC_LAYER_COUNT] = {\n+} layer_handler[TPM2_ERROR_TSS2_RC_LAYER_COUNT\
    \ + 1] = {\n     ADD_HANDLER(\"tpm\" , tpm2_ehandler),\n     ADD_NULL_HANDLER,\
    \                       /* layer 1  is unused */\n     ADD_NULL_HANDLER,     \
    \                  /* layer 2  is unused */\n@@ -881,7 +884,7 @@ unknown_layer_handler(TSS2_RC\
    \ rc)\n     static __thread char buf[32];\n \n     clearbuf(buf);\n-    catbuf(buf,\
    \ \"0x%X\", tpm2_error_get(rc));\n+    catbuf(buf, \"0x%X\", rc);\n \n     return\
    \ buf;\n }\n@@ -978,19 +981,27 @@ Tss2_RC_Decode(TSS2_RC rc)\n         catbuf(buf,\
    \ \"%u:\", layer);\n     }\n \n-    handler = !handler ? unknown_layer_handler\
    \ : handler;\n-\n     /*\n      * Handlers only need the error bits. This way\
    \ they don't\n      * need to concern themselves with masking off the layer\n\
    \      * bits or anything else.\n      */\n-    UINT16 err_bits = tpm2_error_get(rc);\n\
    -    const char *e = err_bits ? handler(err_bits) : \"success\";\n-    if (e)\
    \ {\n-        catbuf(buf, \"%s\", e);\n+    if (handler) {\n+        UINT16 err_bits\
    \ = tpm2_error_get(rc);\n+        const char *e = err_bits ? handler(err_bits)\
    \ : \"success\";\n+        if (e) {\n+            catbuf(buf, \"%s\", e);\n+ \
    \       } else {\n+            catbuf(buf, \"0x%X\", err_bits);\n+        }\n\
    \     } else {\n-        catbuf(buf, \"0x%X\", err_bits);\n+        /*\n+    \
    \     * we don't want to drop any bits if we don't know what to do with it\n+\
    \         * so drop the layer byte since we we already have that.\n+         */\n\
    +        const char *e = unknown_layer_handler(rc >> 8);\n+        assert(e);\n\
    +        catbuf(buf, \"%s\", e);\n     }\n \n     return buf;"
  - "--- a/test/unit/test_tss2_rc.c\n+++ b/test/unit/test_tss2_rc.c\n@@ -197,7 +197,7\
    \ @@ test_custom_handler(void **state)\n      * Test an unknown layer\n      */\n\
    \     e = Tss2_RC_Decode(rc);\n-    assert_string_equal(e, \"1:0x2A\");\n+   \
    \ assert_string_equal(e, \"1:0x100\");\n }\n \n static void\n@@ -407,6 +407,23\
    \ @@ test_info_str_null(void **state)\n     assert_null(m);\n }\n \n+static void\n\
    +test_all_FFs(void **state)\n+{\n+    (void) state;\n+\n+    const char *e = Tss2_RC_Decode(0xFFFFFFFF);\n\
    +    assert_string_equal(e, \"255:0xFFFFFF\");\n+}\n+\n+static void\n+test_all_FFs_set_handler(void\
    \ **state)\n+{\n+    (void) state;\n+    Tss2_RC_SetHandler(0xFF, \"garbage\"\
    , custom_err_handler);\n+    Tss2_RC_SetHandler(0xFF, NULL, NULL);\n+}\n+\n /*\
    \ link required symbol, but tpm2_tool.c declares it AND main, which\n  * we have\
    \ a main below for cmocka tests.\n  */\n@@ -449,6 +466,8 @@ main(int argc, char*\
    \ argv[])\n             cmocka_unit_test(test_info_str_fmt0_warn),\n         \
    \    cmocka_unit_test(test_info_str_fmt0_ff),\n             cmocka_unit_test(test_info_str_null),\n\
    +            cmocka_unit_test(test_all_FFs),\n+            cmocka_unit_test(test_all_FFs_set_handler)\n\
    \     };\n \n     return cmocka_run_group_tests(tests, NULL, NULL);"
  identifiers:
  - CVE-2023-22745
  - CWE-120
  overview: tpm2-tss is an open source software implementation of the Trusted Computing
    Group (TCG) Trusted Platform Module (TPM) 2 Software Stack (TSS2). In affected
    versions `Tss2_RC_SetHandler` and `Tss2_RC_Decode` both index into `layer_handler`
    with an 8 bit layer number, but the array only has `TPM2_ERROR_TSS2_RC_LAYER_COUNT`
    entries, so trying to add a handler for higher-numbered layers or decode a response
    code with such a layer number reads/writes past the end of the buffer. This Buffer
    overrun, could result in arbitrary code execution. An example attack would be
    a MiTM bus attack that returns 0xFFFFFFFF for the RC. Given the common use case
    of TPM modules an attacker must have local access to the target machine with local
    system privileges which allows access to the TPM system. Usually TPM access requires
    administrative privilege.
  references:
  - source: security-advisories@github.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/tpm2-software/tpm2-tss/commit/306490c8d848c367faa2d9df81f5e69dab46ffb5
  - source: security-advisories@github.com
    tags:
    - Exploit
    - Third Party Advisory
    url: https://github.com/tpm2-software/tpm2-tss/security/advisories/GHSA-4j3v-fh23-vx67
  title: tpm2-tss is an open source software implementation of the Trusted Computing
    Group (TCG) Trusted Platform Module (TPM) 2 Software Stack (TSS2). In affected
    versions `Tss2_RC_SetHandler` and `Tss2_RC_Decode` both index into `layer_handler`
    with an 8 bit layer number, but the array only has `TPM2_ERROR_TSS2_RC_LAYER_COUNT`
    entries, so trying to add a handler for higher-numbered layers or decode a response
    code with such a layer number reads/writes past the end of the buffer. This Buffer
    overrun, could result in arbitrary code execution. An example attack would be
    a MiTM bus attack that returns 0xFFFFFFFF for the RC. Given the common use case
    of TPM modules an attacker must have local access to the target machine with local
    system privileges which allows access to the TPM system. Usually TPM access requires
    administrative privilege.
- diff_content:
  - "--- a/src/sort.c\n+++ b/src/sort.c\n@@ -328,8 +328,10 @@ void sortCommandGeneric(client\
    \ *c, int readonly) {\n     default: vectorlen = 0; serverPanic(\"Bad SORT type\"\
    ); /* Avoid GCC warning */\n     }\n \n-    /* Perform LIMIT start,count sanity\
    \ checking. */\n-    start = (limit_start < 0) ? 0 : limit_start;\n+    /* Perform\
    \ LIMIT start,count sanity checking.\n+     * And avoid integer overflow by limiting\
    \ inputs to object sizes. */\n+    start = min(max(limit_start, 0), vectorlen);\n\
    +    limit_count = min(max(limit_count, -1), vectorlen);\n     end = (limit_count\
    \ < 0) ? vectorlen-1 : start+limit_count-1;\n     if (start >= vectorlen) {\n\
    \         start = vectorlen-1;"
  - "--- a/src/t_string.c\n+++ b/src/t_string.c\n@@ -37,8 +37,14 @@ int getGenericCommand(client\
    \ *c);\n  * String Commands\n  *----------------------------------------------------------------------------*/\n\
    \ \n-static int checkStringLength(client *c, long long size) {\n-    if (!mustObeyClient(c)\
    \ && size > server.proto_max_bulk_len) {\n+static int checkStringLength(client\
    \ *c, long long size, long long append) {\n+    if (mustObeyClient(c))\n+    \
    \    return C_OK;\n+    /* 'uint64_t' cast is there just to prevent undefined\
    \ behavior on overflow */\n+    long long total = (uint64_t)size + append;\n+\
    \    /* Test configured max-bulk-len represending a limit of the biggest string\
    \ object,\n+     * and also test for overflow. */\n+    if (total > server.proto_max_bulk_len\
    \ || total < size || total < append) {\n         addReplyError(c,\"string exceeds\
    \ maximum allowed size (proto-max-bulk-len)\");\n         return C_ERR;\n    \
    \ }\n@@ -454,7 +460,7 @@ void setrangeCommand(client *c) {\n         }\n \n  \
    \       /* Return when the resulting string exceeds allowed size */\n-       \
    \ if (checkStringLength(c,offset+sdslen(value)) != C_OK)\n+        if (checkStringLength(c,offset,sdslen(value))\
    \ != C_OK)\n             return;\n \n         o = createObject(OBJ_STRING,sdsnewlen(NULL,\
    \ offset+sdslen(value)));\n@@ -474,7 +480,7 @@ void setrangeCommand(client *c)\
    \ {\n         }\n \n         /* Return when the resulting string exceeds allowed\
    \ size */\n-        if (checkStringLength(c,offset+sdslen(value)) != C_OK)\n+\
    \        if (checkStringLength(c,offset,sdslen(value)) != C_OK)\n            \
    \ return;\n \n         /* Create a copy when the object is shared or encoded.\
    \ */\n@@ -703,8 +709,7 @@ void appendCommand(client *c) {\n \n         /* \"append\"\
    \ is an argument, so always an sds */\n         append = c->argv[2];\n-      \
    \  totlen = stringObjectLen(o)+sdslen(append->ptr);\n-        if (checkStringLength(c,totlen)\
    \ != C_OK)\n+        if (checkStringLength(c,stringObjectLen(o),sdslen(append->ptr))\
    \ != C_OK)\n             return;\n \n         /* Append the value */"
  identifiers:
  - CVE-2022-35977
  - CWE-190
  overview: Redis is an in-memory database that persists on disk. Authenticated users
    issuing specially crafted `SETRANGE` and `SORT(_RO)` commands can trigger an integer
    overflow, resulting with Redis attempting to allocate impossible amounts of memory
    and abort with an out-of-memory (OOM) panic. The problem is fixed in Redis versions
    7.0.8, 6.2.9 and 6.0.17. Users are advised to upgrade. There are no known workarounds
    for this vulnerability.
  references:
  - source: security-advisories@github.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/redis/redis/commit/1ec82e6e97e1db06a72ca505f9fbf6b981f31ef7
  - source: security-advisories@github.com
    tags:
    - Release Notes
    - Third Party Advisory
    url: https://github.com/redis/redis/releases/tag/6.0.17
  - source: security-advisories@github.com
    tags:
    - Release Notes
    - Third Party Advisory
    url: https://github.com/redis/redis/releases/tag/6.2.9
  - source: security-advisories@github.com
    tags:
    - Release Notes
    - Third Party Advisory
    url: https://github.com/redis/redis/releases/tag/7.0.8
  - source: security-advisories@github.com
    tags:
    - Third Party Advisory
    url: https://github.com/redis/redis/security/advisories/GHSA-mrcw-fhw9-fj8j
  title: Redis is an in-memory database that persists on disk. Authenticated users
    issuing specially crafted `SETRANGE` and `SORT(_RO)` commands can trigger an integer
    overflow, resulting with Redis attempting to allocate impossible amounts of memory
    and abort with an out-of-memory (OOM) panic. The problem is fixed in Redis versions
    7.0.8, 6.2.9 and 6.0.17. Users are advised to upgrade. There are no known workarounds
    for this vulnerability.
- diff_content:
  - "--- a/src/opusfile.c\n+++ b/src/opusfile.c\n@@ -148,6 +148,7 @@ static int op_get_data(OggOpusFile\
    \ *_of,int _nbytes){\n   int            nbytes;\n   OP_ASSERT(_nbytes>0);\n  \
    \ buffer=(unsigned char *)ogg_sync_buffer(&_of->oy,_nbytes);\n+  if(OP_UNLIKELY(buffer==NULL))return\
    \ OP_EFAULT;\n   nbytes=(int)(*_of->callbacks.read)(_of->stream,buffer,_nbytes);\n\
    \   OP_ASSERT(nbytes<=_nbytes);\n   if(OP_LIKELY(nbytes>0))ogg_sync_wrote(&_of->oy,nbytes);\n\
    @@ -1527,6 +1528,7 @@ static int op_open1(OggOpusFile *_of,\n   if(_initial_bytes>0){\n\
    \     char *buffer;\n     buffer=ogg_sync_buffer(&_of->oy,(long)_initial_bytes);\n\
    +    if(OP_UNLIKELY(buffer==NULL))return OP_EFAULT;\n     memcpy(buffer,_initial_data,_initial_bytes*sizeof(*buffer));\n\
    \     ogg_sync_wrote(&_of->oy,(long)_initial_bytes);\n   }"
  identifiers:
  - CVE-2022-47021
  - CWE-476
  overview: A null pointer dereference issue was discovered in functions op_get_data
    and op_open1 in opusfile.c in xiph opusfile 0.9 thru 0.12 allows attackers to
    cause denial of service or other unspecified impacts.
  references:
  - source: cve@mitre.org
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/xiph/opusfile/commit/0a4cd796df5b030cb866f3f4a5e41a4b92caddf5
  - source: cve@mitre.org
    tags:
    - Exploit
    - Issue Tracking
    - Patch
    - Third Party Advisory
    url: https://github.com/xiph/opusfile/issues/36
  - source: cve@mitre.org
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/2ODIA6QRIRBNF2HRXOE5VCZ2AFP4ZB4R/
  - source: cve@mitre.org
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/4LIKBLOE433RA44YTYUZLED4IOWJG5DV/
  - source: cve@mitre.org
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/ED4CWLBR2WQ2IXXTHZ24UYZBRNCLMJXH/
  - source: cve@mitre.org
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/MYPAQANM2ZNPXRBFOS5NFXNJ7O4Q3OBD/
  title: A null pointer dereference issue was discovered in functions op_get_data
    and op_open1 in opusfile.c in xiph opusfile 0.9 thru 0.12 allows attackers to
    cause denial of service or other unspecified impacts.
- diff_content:
  - "--- a/src/gui_x11.c\n+++ b/src/gui_x11.c\n@@ -2231,10 +2231,14 @@ gui_x11_create_blank_mouse(void)\n\
    \ {\n     Pixmap blank_pixmap = XCreatePixmap(gui.dpy, gui.wid, 1, 1, 1);\n  \
    \   GC gc = XCreateGC(gui.dpy, blank_pixmap, (unsigned long)0, (XGCValues*)0);\n\
    -    XDrawPoint(gui.dpy, blank_pixmap, gc, 0, 0);\n-    XFreeGC(gui.dpy, gc);\n\
    +\n+    if (gc != NULL)\n+    {\n+\tXDrawPoint(gui.dpy, blank_pixmap, gc, 0, 0);\n\
    +\tXFreeGC(gui.dpy, gc);\n+    }\n     return XCreatePixmapCursor(gui.dpy, blank_pixmap,\
    \ blank_pixmap,\n-\t    (XColor*)&gui.norm_pixel, (XColor*)&gui.norm_pixel, 0,\
    \ 0);\n+\t\t     (XColor*)&gui.norm_pixel, (XColor*)&gui.norm_pixel, 0, 0);\n\
    \ }\n \n /*"
  - "--- a/src/version.c\n+++ b/src/version.c\n@@ -707,6 +707,8 @@ static char *(features[])\
    \ =\n \n static int included_patches[] =\n {   /* Add new patch number below this\
    \ line */\n+/**/\n+    339,\n /**/\n     338,\n /**/"
  identifiers:
  - CVE-2022-47024
  - CWE-476
  overview: A null pointer dereference issue was discovered in function gui_x11_create_blank_mouse
    in gui_x11.c in vim 8.1.2269 thru 9.0.0339 allows attackers to cause denial of
    service or other unspecified impacts.
  references:
  - source: cve@mitre.org
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/vim/vim/commit/a63ad78ed31e36dbdf3a9cd28071dcdbefce7d19
  - source: cve@mitre.org
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/4EX6N2DB75A73MQGVW3CS4VTNPAYVM2M/
  - source: cve@mitre.org
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/PZWIJBSQX53P7DHV77KRXJIXA4GH7XHC/
  - source: cve@mitre.org
    url: https://security.gentoo.org/glsa/202305-16
  title: A null pointer dereference issue was discovered in function gui_x11_create_blank_mouse
    in gui_x11.c in vim 8.1.2269 thru 9.0.0339 allows attackers to cause denial of
    service or other unspecified impacts.
- diff_content:
  - "--- a/src/t_hash.c\n+++ b/src/t_hash.c\n@@ -1120,8 +1120,13 @@ void hrandfieldCommand(client\
    \ *c) {\n         if (c->argc > 4 || (c->argc == 4 && strcasecmp(c->argv[3]->ptr,\"\
    withvalues\"))) {\n             addReplyErrorObject(c,shared.syntaxerr);\n   \
    \          return;\n-        } else if (c->argc == 4)\n+        } else if (c->argc\
    \ == 4) {\n             withvalues = 1;\n+            if (l < LONG_MIN/2 || l\
    \ > LONG_MAX/2) {\n+                addReplyError(c,\"value is out of range\"\
    );\n+                return;\n+            }\n+        }\n         hrandfieldWithCountCommand(c,\
    \ l, withvalues);\n         return;\n     }"
  - "--- a/src/t_zset.c\n+++ b/src/t_zset.c\n@@ -4317,8 +4317,13 @@ void zrandmemberCommand(client\
    \ *c) {\n         if (c->argc > 4 || (c->argc == 4 && strcasecmp(c->argv[3]->ptr,\"\
    withscores\"))) {\n             addReplyErrorObject(c,shared.syntaxerr);\n   \
    \          return;\n-        } else if (c->argc == 4)\n+        } else if (c->argc\
    \ == 4) {\n             withscores = 1;\n+            if (l < LONG_MIN/2 || l\
    \ > LONG_MAX/2) {\n+                addReplyError(c,\"value is out of range\"\
    );\n+                return;\n+            }\n+        }\n         zrandmemberWithCountCommand(c,\
    \ l, withscores);\n         return;\n     }"
  identifiers:
  - CVE-2023-22458
  - CWE-190
  overview: Redis is an in-memory database that persists on disk. Authenticated users
    can issue a `HRANDFIELD` or `ZRANDMEMBER` command with specially crafted arguments
    to trigger a denial-of-service by crashing Redis with an assertion failure. This
    problem affects Redis versions 6.2 or newer up to but not including 6.2.9 as well
    as versions 7.0 up to but not including 7.0.8. Users are advised to upgrade. There
    are no known workarounds for this vulnerability.
  references:
  - source: security-advisories@github.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/redis/redis/commit/16f408b1a0121cacd44cbf8aee275d69dc627f02
  - source: security-advisories@github.com
    tags:
    - Release Notes
    - Third Party Advisory
    url: https://github.com/redis/redis/releases/tag/6.2.9
  - source: security-advisories@github.com
    tags:
    - Release Notes
    - Third Party Advisory
    url: https://github.com/redis/redis/releases/tag/7.0.8
  - source: security-advisories@github.com
    tags:
    - Third Party Advisory
    url: https://github.com/redis/redis/security/advisories/GHSA-r8w2-2m53-gprj
  title: Redis is an in-memory database that persists on disk. Authenticated users
    can issue a `HRANDFIELD` or `ZRANDMEMBER` command with specially crafted arguments
    to trigger a denial-of-service by crashing Redis with an assertion failure. This
    problem affects Redis versions 6.2 or newer up to but not including 6.2.9 as well
    as versions 7.0 up to but not including 7.0.8. Users are advised to upgrade. There
    are no known workarounds for this vulnerability.
- diff_content:
  - "--- a/src/media_tools/av_parsers.c\n+++ b/src/media_tools/av_parsers.c\n@@ -5677,10\
    \ +5677,10 @@ static s32 avc_parse_slice(GF_BitStream *bs, AVCState *avc, Bool\
    \ svc_idr_flag, A\n \tif (si->slice_type > 9) return -1;\n \n \tpps_id = gf_bs_read_ue_log(bs,\
    \ \"pps_id\");\n-\tif ((pps_id<0) || (pps_id > 255)) return -1;\n+\tif ((pps_id<0)\
    \ || (pps_id >= 255)) return -1;\n \tsi->pps = &avc->pps[pps_id];\n \tif (!si->pps->slice_group_count)\
    \ return -2;\n-\tif (si->pps->sps_id>=255) return -1;\n+\tif (si->pps->sps_id>=32)\
    \ return -1;\n \tsi->sps = &avc->sps[si->pps->sps_id];\n \tif (!si->sps->log2_max_frame_num)\
    \ return -2;\n \tavc->sps_active_idx = si->pps->sps_id;\n@@ -5787,7 +5787,7 @@\
    \ static s32 svc_parse_slice(GF_BitStream *bs, AVCState *avc, AVCSliceInfo *si)\n\
    \ \tif (si->slice_type > 9) return -1;\n \n \tpps_id = gf_bs_read_ue_log(bs, \"\
    pps_id\");\n-\tif ((pps_id<0) || (pps_id > 255))\n+\tif ((pps_id<0) || (pps_id\
    \ >= 255))\n \t\treturn -1;\n \tsi->pps = &avc->pps[pps_id];\n \tsi->pps->id =\
    \ pps_id;"
  identifiers:
  - CVE-2023-23143
  - CWE-120
  overview: Buffer overflow vulnerability in function avc_parse_slice in file media_tools/av_parsers.c.
    GPAC version 2.3-DEV-rev1-g4669ba229-master.
  references:
  - source: cve@mitre.org
    tags:
    - Exploit
    - Patch
    - Third Party Advisory
    url: https://github.com/gpac/gpac/commit/af6a5e7a96ee01a139cce6c9e4edfc069aad17a6
  - source: cve@mitre.org
    url: https://www.debian.org/security/2023/dsa-5411
  title: Buffer overflow vulnerability in function avc_parse_slice in file media_tools/av_parsers.c.
    GPAC version 2.3-DEV-rev1-g4669ba229-master.
- diff_content:
  - "--- a/src/bifs/unquantize.c\n+++ b/src/bifs/unquantize.c\n@@ -2,7 +2,7 @@\n \
    \ *\t\t\tGPAC - Multimedia Framework C SDK\n  *\n  *\t\t\tAuthors: Jean Le Feuvre\n\
    - *\t\t\tCopyright (c) Telecom ParisTech 2000-2012\n+ *\t\t\tCopyright (c) Telecom\
    \ ParisTech 2000-2023\n  *\t\t\t\t\tAll rights reserved\n  *\n  *  This file is\
    \ part of GPAC / BIFS codec sub-project\n@@ -284,7 +284,7 @@ GF_Err Q_DecCoordOnUnitSphere(GF_BifsDecoder\
    \ *codec, GF_BitStream *bs, u32 NbBit\n \ts32 value;\n \tFixed tang[4], delta;\n\
    \ \ts32 dir;\n-\n+\tif (NbBits>32) return GF_NON_COMPLIANT_BITSTREAM;\n \tif (NbComp\
    \ != 2 && NbComp != 3) return GF_BAD_PARAM;\n \n \t//only 2 or 3 comp in the quantized\
    \ version"
  identifiers:
  - CVE-2023-23144
  - CWE-190
  overview: Integer overflow vulnerability in function Q_DecCoordOnUnitSphere file
    bifs/unquantize.c in GPAC version 2.2-rev0-gab012bbfb-master.
  references:
  - source: cve@mitre.org
    tags:
    - Exploit
    - Patch
    - Third Party Advisory
    url: https://github.com/gpac/gpac/commit/3a2458a49b3e6399709d456d7b35e7a6f50cfb86
  - source: cve@mitre.org
    url: https://www.debian.org/security/2023/dsa-5411
  title: Integer overflow vulnerability in function Q_DecCoordOnUnitSphere file bifs/unquantize.c
    in GPAC version 2.2-rev0-gab012bbfb-master.
- diff_content:
  - "--- a/src/laser/lsr_dec.c\n+++ b/src/laser/lsr_dec.c\n@@ -2,7 +2,7 @@\n  *\t\t\
    \tGPAC - Multimedia Framework C SDK\n  *\n  *\t\t\tAuthors: Jean Le Feuvre\n-\
    \ *\t\t\tCopyright (c) Telecom ParisTech 2005-2022\n+ *\t\t\tCopyright (c) Telecom\
    \ ParisTech 2005-2023\n  *\t\t\t\t\tAll rights reserved\n  *\n  *  This file is\
    \ part of GPAC / LASeR codec sub-project\n@@ -1539,8 +1539,8 @@ static void lsr_read_rare_full(GF_LASeRCodec\
    \ *lsr, GF_Node *n)\n \t\t\t} else {\n \t\t\t\tda->type=SVG_STROKEDASHARRAY_ARRAY;\n\
    \ \t\t\t\tda->array.count = lsr_read_vluimsbf5(lsr, \"len\");\n-\t\t\t\tda->array.vals\
    \ = (Fixed*)gf_malloc(sizeof(Fixed)*da->array.count);\n-\t\t\t\tda->array.units\
    \ = (u8*)gf_malloc(sizeof(u8)*da->array.count);\n+\t\t\t\tda->array.vals = (Fixed*)gf_realloc(da->array.vals,\
    \ sizeof(Fixed)*da->array.count);\n+\t\t\t\tda->array.units = (u8*)gf_realloc(da->array.units,\
    \ sizeof(u8)*da->array.count);\n \t\t\t\tif (!da->array.vals || !da->array.units)\
    \ {\n \t\t\t\t\tlsr->last_error = GF_OUT_OF_MEM;\n \t\t\t\t\treturn;"
  identifiers:
  - CVE-2023-23145
  - CWE-401
  overview: GPAC version 2.2-rev0-gab012bbfb-master was discovered to contain a memory
    leak in lsr_read_rare_full function.
  references:
  - source: cve@mitre.org
    tags:
    - Exploit
    - Patch
    - Third Party Advisory
    url: https://github.com/gpac/gpac/commit/4ade98128cbc41d5115b97a41ca2e59529c8dd5f
  - source: cve@mitre.org
    url: https://www.debian.org/security/2023/dsa-5411
  title: GPAC version 2.2-rev0-gab012bbfb-master was discovered to contain a memory
    leak in lsr_read_rare_full function.
- diff_content:
  - "--- a/branches/remotes/tags/2.6.8/apache2/msc_util.c\n+++ b/branches/remotes/tags/2.6.8/apache2/msc_util.c\n\
    @@ -445,6 +445,7 @@ int sql_hex2bytes_inplace(unsigned char *data, int len) {\n\
    \             }\n         } else  {\n             *d++ = data[i];\n+         \
    \   found = 0;\n         }\n \n         count++;"
  identifiers:
  - CVE-2023-24021
  - NVD-CWE-Other
  overview: Incorrect handling of '\0' bytes in file uploads in ModSecurity before
    2.9.7 may allow for Web Application Firewall bypasses and buffer over-reads on
    the Web Application Firewall when executing rules that read the FILES_TMP_CONTENT
    collection.
  references:
  - source: cve@mitre.org
    tags:
    - Issue Tracking
    - Patch
    url: https://github.com/SpiderLabs/ModSecurity/pull/2857
  - source: cve@mitre.org
    tags:
    - Patch
    url: https://github.com/SpiderLabs/ModSecurity/pull/2857/commits/4324f0ac59f8225aa44bc5034df60dbeccd1d334
  - source: cve@mitre.org
    tags:
    - Release Notes
    url: https://github.com/SpiderLabs/ModSecurity/releases/tag/v2.9.7
  - source: cve@mitre.org
    tags:
    - Mailing List
    - Third Party Advisory
    url: https://lists.debian.org/debian-lts-announce/2023/01/msg00023.html
  - source: cve@mitre.org
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/52TGCZCOHYBDCVWJYNN2PS4QLOHCXWTQ/
  - source: cve@mitre.org
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/SYRTXTOQQI6SB2TLI5QXU76DURSLS4XI/
  - source: cve@mitre.org
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/WCH6JM4I4MD4YABYFHSBDDOUFDGIFJKL/
  title: Incorrect handling of '\0' bytes in file uploads in ModSecurity before 2.9.7
    may allow for Web Application Firewall bypasses and buffer over-reads on the Web
    Application Firewall when executing rules that read the FILES_TMP_CONTENT collection.
- diff_content:
  - "--- a/src/libgit2/transports/ssh.c\n+++ b/src/libgit2/transports/ssh.c\n@@ -421,37\
    \ +421,345 @@ static int request_creds(git_credential **out, ssh_subtransport\
    \ *t, const char *\n \treturn 0;\n }\n \n+#define KNOWN_HOSTS_FILE \".ssh/known_hosts\"\
    \n+\n+/*\n+ * Load the known_hosts file.\n+ *\n+ * Returns success but leaves\
    \ the output NULL if we couldn't find the file.\n+ */\n+static int load_known_hosts(LIBSSH2_KNOWNHOSTS\
    \ **hosts, LIBSSH2_SESSION *session)\n+{\n+\tgit_str path = GIT_STR_INIT, home\
    \ = GIT_STR_INIT;\n+\tLIBSSH2_KNOWNHOSTS *known_hosts = NULL;\n+\tint error;\n\
    +\n+\tGIT_ASSERT_ARG(hosts);\n+\n+\tif ((error = git__getenv(&home, \"HOME\"))\
    \ < 0)\n+\t\treturn error;\n+\n+\tif ((error = git_str_joinpath(&path, git_str_cstr(&home),\
    \ KNOWN_HOSTS_FILE)) < 0)\n+\t\tgoto out;\n+\n+\tif ((known_hosts = libssh2_knownhost_init(session))\
    \ == NULL) {\n+\t\tssh_error(session, \"error initializing known hosts\");\n+\t\
    \terror = -1;\n+\t\tgoto out;\n+\t}\n+\n+\t/*\n+\t * Try to read the file and\
    \ consider not finding it as not trusting the\n+\t * host rather than an error.\n\
    +\t */\n+\terror = libssh2_knownhost_readfile(known_hosts, git_str_cstr(&path),\
    \ LIBSSH2_KNOWNHOST_FILE_OPENSSH);\n+\tif (error == LIBSSH2_ERROR_FILE)\n+\t\t\
    error = 0;\n+\tif (error < 0)\n+\t\tssh_error(session, \"error reading known_hosts\"\
    );\n+\n+out:\n+\t*hosts = known_hosts;\n+\n+\tgit_str_clear(&home);\n+\tgit_str_clear(&path);\n\
    +\n+\treturn error;\n+}\n+\n+static const char *hostkey_type_to_string(int type)\n\
    +{\n+\tswitch (type) {\n+\tcase LIBSSH2_KNOWNHOST_KEY_SSHRSA:\n+\t\treturn \"\
    ssh-rsa\";\n+\tcase LIBSSH2_KNOWNHOST_KEY_SSHDSS:\n+\t\treturn \"ssh-dss\";\n\
    +#ifdef LIBSSH2_KNOWNHOST_KEY_ECDSA_256\n+\tcase LIBSSH2_KNOWNHOST_KEY_ECDSA_256:\n\
    +\t\treturn \"ecdsa-sha2-nistp256\";\n+\tcase LIBSSH2_KNOWNHOST_KEY_ECDSA_384:\n\
    +\t\treturn \"ecdsa-sha2-nistp384\";\n+\tcase LIBSSH2_KNOWNHOST_KEY_ECDSA_521:\n\
    +\t\treturn \"ecdsa-sha2-nistp521\";\n+#endif\n+#ifdef LIBSSH2_KNOWNHOST_KEY_ED25519\n\
    +\tcase LIBSSH2_KNOWNHOST_KEY_ED25519:\n+\t\treturn \"ssh-ed25519\";\n+#endif\n\
    +\t}\n+\n+\treturn NULL;\n+}\n+\n+/*\n+ * We figure out what kind of key we want\
    \ to ask the remote for by trying to\n+ * look it up with a nonsense key and using\
    \ that mismatch to figure out what key\n+ * we do have stored for the host.\n\
    + *\n+ * Returns the string to pass to libssh2_session_method_pref or NULL if\
    \ we were\n+ * unable to find anything or an error happened.\n+ */\n+static const\
    \ char *find_hostkey_preference(LIBSSH2_KNOWNHOSTS *known_hosts, const char *hostname,\
    \ int port)\n+{\n+\tstruct libssh2_knownhost *host = NULL;\n+\t/* Specify no key\
    \ type so we don't filter on that */\n+\tint type = LIBSSH2_KNOWNHOST_TYPE_PLAIN\
    \ | LIBSSH2_KNOWNHOST_KEYENC_RAW;\n+\tconst char key = '\\0';\n+\tint error;\n\
    +\n+\t/*\n+\t * In case of mismatch, we can find the type of key from known_hosts\
    \ in\n+\t * the returned host's information as it means that an entry was found\n\
    +\t * but our nonsense key obviously didn't match.\n+\t */\n+\terror = libssh2_knownhost_checkp(known_hosts,\
    \ hostname, port, &key, 1, type, &host);\n+\tif (error == LIBSSH2_KNOWNHOST_CHECK_MISMATCH)\n\
    +\t\treturn hostkey_type_to_string(host->typemask & LIBSSH2_KNOWNHOST_KEY_MASK);\n\
    +\n+\treturn NULL;\n+}\n+\n static int _git_ssh_session_create(\n \tLIBSSH2_SESSION\
    \ **session,\n+\tLIBSSH2_KNOWNHOSTS **hosts,\n+\tconst char *hostname,\n+\tint\
    \ port,\n \tgit_stream *io)\n {\n \tint rc = 0;\n \tLIBSSH2_SESSION *s;\n+\tLIBSSH2_KNOWNHOSTS\
    \ *known_hosts;\n \tgit_socket_stream *socket = GIT_CONTAINER_OF(io, git_socket_stream,\
    \ parent);\n+\tconst char *keytype = NULL;\n \n \tGIT_ASSERT_ARG(session);\n+\t\
    GIT_ASSERT_ARG(hosts);\n \n \ts = libssh2_session_init();\n \tif (!s) {\n \t\t\
    git_error_set(GIT_ERROR_NET, \"failed to initialize SSH session\");\n \t\treturn\
    \ -1;\n \t}\n \n+\tif ((rc = load_known_hosts(&known_hosts, s)) < 0) {\n+\t\t\
    ssh_error(s, \"error loading known_hosts\");\n+\t\tlibssh2_session_free(s);\n\
    +\t\treturn -1;\n+\t}\n+\n+\tif ((keytype = find_hostkey_preference(known_hosts,\
    \ hostname, port)) != NULL) {\n+\t\tdo {\n+\t\t\trc = libssh2_session_method_pref(s,\
    \ LIBSSH2_METHOD_HOSTKEY, keytype);\n+\t\t} while (LIBSSH2_ERROR_EAGAIN == rc\
    \ || LIBSSH2_ERROR_TIMEOUT == rc);\n+\t\tif (rc != LIBSSH2_ERROR_NONE) {\n+\t\t\
    \tssh_error(s, \"failed to set hostkey preference\");\n+\t\t\tgoto on_error;\n\
    +\t\t}\n+\t}\n+\n+\n \tdo {\n \t\trc = libssh2_session_handshake(s, socket->s);\n\
    \ \t} while (LIBSSH2_ERROR_EAGAIN == rc || LIBSSH2_ERROR_TIMEOUT == rc);\n \n\
    \ \tif (rc != LIBSSH2_ERROR_NONE) {\n \t\tssh_error(s, \"failed to start SSH session\"\
    );\n-\t\tlibssh2_session_free(s);\n-\t\treturn -1;\n+\t\tgoto on_error;\n \t}\n\
    \ \n \tlibssh2_session_set_blocking(s, 1);\n \n \t*session = s;\n+\t*hosts = known_hosts;\n\
    \ \n \treturn 0;\n+\n+on_error:\n+\tlibssh2_knownhost_free(known_hosts);\n+\t\
    libssh2_session_free(s);\n+\treturn -1;\n+}\n+\n+\n+/*\n+ * Returns the typemask\
    \ argument to pass to libssh2_knownhost_check{,p} based on\n+ * the type of key\
    \ that libssh2_session_hostkey returns.\n+ */\n+static int fingerprint_type_mask(int\
    \ keytype)\n+{\n+\tint mask = LIBSSH2_KNOWNHOST_TYPE_PLAIN | LIBSSH2_KNOWNHOST_KEYENC_RAW;\n\
    +\treturn mask;\n+\n+\tswitch (keytype) {\n+\tcase LIBSSH2_HOSTKEY_TYPE_RSA:\n\
    +\t\tmask |= LIBSSH2_KNOWNHOST_KEY_SSHRSA;\n+\t\tbreak;\n+\tcase LIBSSH2_HOSTKEY_TYPE_DSS:\n\
    +\t\tmask |= LIBSSH2_KNOWNHOST_KEY_SSHDSS;\n+\t\tbreak;\n+#ifdef LIBSSH2_HOSTKEY_TYPE_ECDSA_256\n\
    +\tcase LIBSSH2_HOSTKEY_TYPE_ECDSA_256:\n+\t\tmask |= LIBSSH2_KNOWNHOST_KEY_ECDSA_256;\n\
    +\t\tbreak;\n+\tcase LIBSSH2_HOSTKEY_TYPE_ECDSA_384:\n+\t\tmask |= LIBSSH2_KNOWNHOST_KEY_ECDSA_384;\n\
    +\t\tbreak;\n+\tcase LIBSSH2_HOSTKEY_TYPE_ECDSA_521:\n+\t\tmask |= LIBSSH2_KNOWNHOST_KEY_ECDSA_521;\n\
    +\t\tbreak;\n+#endif\n+#ifdef LIBSSH2_HOSTKEY_TYPE_ED25519\n+\tcase LIBSSH2_HOSTKEY_TYPE_ED25519:\n\
    +\t\tmask |= LIBSSH2_KNOWNHOST_KEY_ED25519;\n+\t\tbreak;\n+#endif\n+\t}\n+\n+\t\
    return mask;\n+}\n+\n+/*\n+ * Check the host against the user's known_hosts file.\n\
    + *\n+ * Returns 1/0 for valid/''not-valid or <0 for an error\n+ */\n+static int\
    \ check_against_known_hosts(\n+\tLIBSSH2_SESSION *session,\n+\tLIBSSH2_KNOWNHOSTS\
    \ *known_hosts,\n+\tconst char *hostname,\n+\tint port,\n+\tconst char *key,\n\
    +\tsize_t key_len,\n+\tint key_type)\n+{\n+\tint check, typemask, ret = 0;\n+\t\
    struct libssh2_knownhost *host = NULL;\n+\n+\tif (known_hosts == NULL)\n+\t\t\
    return 0;\n+\n+\ttypemask = fingerprint_type_mask(key_type);\n+\tcheck = libssh2_knownhost_checkp(known_hosts,\
    \ hostname, port, key, key_len, typemask, &host);\n+\tif (check == LIBSSH2_KNOWNHOST_CHECK_FAILURE)\
    \ {\n+\t\tssh_error(session, \"error checking for known host\");\n+\t\treturn\
    \ -1;\n+\t}\n+\n+\tret = check == LIBSSH2_KNOWNHOST_CHECK_MATCH ? 1 : 0;\n+\n\
    +\treturn ret;\n+}\n+\n+/*\n+ * Perform the check for the session's certificate\
    \ against known hosts if\n+ * possible and then ask the user if they have a callback.\n\
    + *\n+ * Returns 1/0 for valid/not-valid or <0 for an error\n+ */\n+static int\
    \ check_certificate(\n+\tLIBSSH2_SESSION *session,\n+\tLIBSSH2_KNOWNHOSTS *known_hosts,\n\
    +\tgit_transport_certificate_check_cb check_cb,\n+\tvoid *check_cb_payload,\n\
    +\tconst char *host,\n+\tint port)\n+{\n+\tgit_cert_hostkey cert = {{ 0 }};\n\
    +\tconst char *key;\n+\tsize_t cert_len;\n+\tint cert_type, cert_valid = 0, error\
    \ = 0;\n+\n+\tif ((key = libssh2_session_hostkey(session, &cert_len, &cert_type))\
    \ == NULL) {\n+\t\tssh_error(session, \"failed to retrieve hostkey\");\n+\t\t\
    return -1;\n+\t}\n+\n+\tif ((cert_valid = check_against_known_hosts(session, known_hosts,\
    \ host, port, key, cert_len, cert_type)) < 0)\n+\t\treturn -1;\n+\n+\tcert.parent.cert_type\
    \ = GIT_CERT_HOSTKEY_LIBSSH2;\n+\tif (key != NULL) {\n+\t\tcert.type |= GIT_CERT_SSH_RAW;\n\
    +\t\tcert.hostkey = key;\n+\t\tcert.hostkey_len = cert_len;\n+\t\tswitch (cert_type)\
    \ {\n+\t\tcase LIBSSH2_HOSTKEY_TYPE_RSA:\n+\t\t\tcert.raw_type = GIT_CERT_SSH_RAW_TYPE_RSA;\n\
    +\t\t\tbreak;\n+\t\tcase LIBSSH2_HOSTKEY_TYPE_DSS:\n+\t\t\tcert.raw_type = GIT_CERT_SSH_RAW_TYPE_DSS;\n\
    +\t\t\tbreak;\n+\n+#ifdef LIBSSH2_HOSTKEY_TYPE_ECDSA_256\n+\t\tcase LIBSSH2_HOSTKEY_TYPE_ECDSA_256:\n\
    +\t\t\tcert.raw_type = GIT_CERT_SSH_RAW_TYPE_KEY_ECDSA_256;\n+\t\t\tbreak;\n+\t\
    \tcase LIBSSH2_HOSTKEY_TYPE_ECDSA_384:\n+\t\t\tcert.raw_type = GIT_CERT_SSH_RAW_TYPE_KEY_ECDSA_384;\n\
    +\t\t\tbreak;\n+\t\tcase LIBSSH2_KNOWNHOST_KEY_ECDSA_521:\n+\t\t\tcert.raw_type\
    \ = GIT_CERT_SSH_RAW_TYPE_KEY_ECDSA_521;\n+\t\t\tbreak;\n+#endif\n+\n+#ifdef LIBSSH2_HOSTKEY_TYPE_ED25519\n\
    +\t\tcase LIBSSH2_HOSTKEY_TYPE_ED25519:\n+\t\t\tcert.raw_type = GIT_CERT_SSH_RAW_TYPE_KEY_ED25519;\n\
    +\t\t\tbreak;\n+#endif\n+\t\tdefault:\n+\t\t\tcert.raw_type = GIT_CERT_SSH_RAW_TYPE_UNKNOWN;\n\
    +\t\t}\n+\t}\n+\n+#ifdef LIBSSH2_HOSTKEY_HASH_SHA256\n+\tkey = libssh2_hostkey_hash(session,\
    \ LIBSSH2_HOSTKEY_HASH_SHA256);\n+\tif (key != NULL) {\n+\t\tcert.type |= GIT_CERT_SSH_SHA256;\n\
    +\t\tmemcpy(&cert.hash_sha256, key, 32);\n+\t}\n+#endif\n+\n+\tkey = libssh2_hostkey_hash(session,\
    \ LIBSSH2_HOSTKEY_HASH_SHA1);\n+\tif (key != NULL) {\n+\t\tcert.type |= GIT_CERT_SSH_SHA1;\n\
    +\t\tmemcpy(&cert.hash_sha1, key, 20);\n+\t}\n+\n+\tkey = libssh2_hostkey_hash(session,\
    \ LIBSSH2_HOSTKEY_HASH_MD5);\n+\tif (key != NULL) {\n+\t\tcert.type |= GIT_CERT_SSH_MD5;\n\
    +\t\tmemcpy(&cert.hash_md5, key, 16);\n+\t}\n+\n+\tif (cert.type == 0) {\n+\t\t\
    git_error_set(GIT_ERROR_SSH, \"unable to get the host key\");\n+\t\treturn -1;\n\
    +\t}\n+\n+\tgit_error_clear();\n+\terror = 0;\n+\tif (!cert_valid) {\n+\t\tgit_error_set(GIT_ERROR_SSH,\
    \ \"invalid or unknown remote ssh hostkey\");\n+\t\terror = GIT_ECERTIFICATE;\n\
    +\t}\n+\n+\tif (check_cb != NULL) {\n+\t\tgit_cert_hostkey *cert_ptr = &cert;\n\
    +\t\tgit_error_state previous_error = {0};\n+\n+\t\tgit_error_state_capture(&previous_error,\
    \ error);\n+\t\terror = check_cb((git_cert *) cert_ptr, cert_valid, host, check_cb_payload);\n\
    +\t\tif (error == GIT_PASSTHROUGH) {\n+\t\t\terror = git_error_state_restore(&previous_error);\n\
    +\t\t} else if (error < 0 && !git_error_last()) {\n+\t\t\tgit_error_set(GIT_ERROR_NET,\
    \ \"user canceled hostkey check\");\n+\t\t}\n+\n+\t\tgit_error_state_free(&previous_error);\n\
    +\t}\n+\n+\treturn error;\n }\n \n #define SSH_DEFAULT_PORT \"22\"\n@@ -462,11\
    \ +770,12 @@ static int _git_ssh_setup_conn(\n \tconst char *cmd,\n \tgit_smart_subtransport_stream\
    \ **stream)\n {\n-\tint auth_methods, error = 0;\n+\tint auth_methods, error =\
    \ 0, port;\n \tssh_stream *s;\n \tgit_credential *cred = NULL;\n \tLIBSSH2_SESSION\
    \ *session=NULL;\n \tLIBSSH2_CHANNEL *channel=NULL;\n+\tLIBSSH2_KNOWNHOSTS *known_hosts\
    \ = NULL;\n \n \tt->current_stream = NULL;\n \n@@ -490,96 +799,20 @@ static int\
    \ _git_ssh_setup_conn(\n \t    (error = git_stream_connect(s->io)) < 0)\n \t\t\
    goto done;\n \n-\tif ((error = _git_ssh_session_create(&session, s->io)) < 0)\n\
    -\t\tgoto done;\n-\n-\tif (t->owner->connect_opts.callbacks.certificate_check\
    \ != NULL) {\n-\t\tgit_cert_hostkey cert = {{ 0 }}, *cert_ptr;\n-\t\tconst char\
    \ *key;\n-\t\tsize_t cert_len;\n-\t\tint cert_type;\n-\n-\t\tcert.parent.cert_type\
    \ = GIT_CERT_HOSTKEY_LIBSSH2;\n-\n-\t\tkey = libssh2_session_hostkey(session,\
    \ &cert_len, &cert_type);\n-\t\tif (key != NULL) {\n-\t\t\tcert.type |= GIT_CERT_SSH_RAW;\n\
    -\t\t\tcert.hostkey = key;\n-\t\t\tcert.hostkey_len = cert_len;\n-\t\t\tswitch\
    \ (cert_type) {\n-\t\t\t\tcase LIBSSH2_HOSTKEY_TYPE_RSA:\n-\t\t\t\t\tcert.raw_type\
    \ = GIT_CERT_SSH_RAW_TYPE_RSA;\n-\t\t\t\t\tbreak;\n-\t\t\t\tcase LIBSSH2_HOSTKEY_TYPE_DSS:\n\
    -\t\t\t\t\tcert.raw_type = GIT_CERT_SSH_RAW_TYPE_DSS;\n-\t\t\t\t\tbreak;\n-\n\
    -#ifdef LIBSSH2_HOSTKEY_TYPE_ECDSA_256\n-\t\t\t\tcase LIBSSH2_HOSTKEY_TYPE_ECDSA_256:\n\
    -\t\t\t\t\tcert.raw_type = GIT_CERT_SSH_RAW_TYPE_KEY_ECDSA_256;\n-\t\t\t\t\tbreak;\n\
    -\t\t\t\tcase LIBSSH2_HOSTKEY_TYPE_ECDSA_384:\n-\t\t\t\t\tcert.raw_type = GIT_CERT_SSH_RAW_TYPE_KEY_ECDSA_384;\n\
    -\t\t\t\t\tbreak;\n-\t\t\t\tcase LIBSSH2_KNOWNHOST_KEY_ECDSA_521:\n-\t\t\t\t\t\
    cert.raw_type = GIT_CERT_SSH_RAW_TYPE_KEY_ECDSA_521;\n-\t\t\t\t\tbreak;\n-#endif\n\
    -\n-#ifdef LIBSSH2_HOSTKEY_TYPE_ED25519\n-\t\t\t\tcase LIBSSH2_HOSTKEY_TYPE_ED25519:\n\
    -\t\t\t\t\tcert.raw_type = GIT_CERT_SSH_RAW_TYPE_KEY_ED25519;\n-\t\t\t\t\tbreak;\n\
    -#endif\n-\t\t\t\tdefault:\n-\t\t\t\t\tcert.raw_type = GIT_CERT_SSH_RAW_TYPE_UNKNOWN;\n\
    -\t\t\t}\n-\t\t}\n-\n-#ifdef LIBSSH2_HOSTKEY_HASH_SHA256\n-\t\tkey = libssh2_hostkey_hash(session,\
    \ LIBSSH2_HOSTKEY_HASH_SHA256);\n-\t\tif (key != NULL) {\n-\t\t\tcert.type |=\
    \ GIT_CERT_SSH_SHA256;\n-\t\t\tmemcpy(&cert.hash_sha256, key, 32);\n-\t\t}\n-#endif\n\
    -\n-\t\tkey = libssh2_hostkey_hash(session, LIBSSH2_HOSTKEY_HASH_SHA1);\n-\t\t\
    if (key != NULL) {\n-\t\t\tcert.type |= GIT_CERT_SSH_SHA1;\n-\t\t\tmemcpy(&cert.hash_sha1,\
    \ key, 20);\n-\t\t}\n-\n-\t\tkey = libssh2_hostkey_hash(session, LIBSSH2_HOSTKEY_HASH_MD5);\n\
    -\t\tif (key != NULL) {\n-\t\t\tcert.type |= GIT_CERT_SSH_MD5;\n-\t\t\tmemcpy(&cert.hash_md5,\
    \ key, 16);\n-\t\t}\n-\n-\t\tif (cert.type == 0) {\n-\t\t\tgit_error_set(GIT_ERROR_SSH,\
    \ \"unable to get the host key\");\n-\t\t\terror = -1;\n-\t\t\tgoto done;\n-\t\
    \t}\n-\n-\t\t/* We don't currently trust any hostkeys */\n-\t\tgit_error_clear();\n\
    -\n-\t\tcert_ptr = &cert;\n-\n-\t\terror = t->owner->connect_opts.callbacks.certificate_check(\n\
    -\t\t\t(git_cert *)cert_ptr,\n-\t\t\t0,\n-\t\t\ts->url.host,\n-\t\t\tt->owner->connect_opts.callbacks.payload);\n\
    +\t/*\n+\t * Try to parse the port as a number, if we can't then fall back to\n\
    +\t * default. It would be nice if we could get the port that was resolved\n+\t\
    \ * as part of the stream connection, but that's not something that's\n+\t * exposed.\n\
    +\t */\n+\tif (git__strntol32(&port, s->url.port, strlen(s->url.port), NULL, 10)\
    \ < 0)\n+\t\tport = -1;\n \n-\t\tif (error < 0 && error != GIT_PASSTHROUGH) {\n\
    -\t\t\tif (!git_error_last())\n-\t\t\t\tgit_error_set(GIT_ERROR_NET, \"user cancelled\
    \ hostkey check\");\n+\tif ((error = _git_ssh_session_create(&session, &known_hosts,\
    \ s->url.host, port, s->io)) < 0)\n+\t\tgoto done;\n \n-\t\t\tgoto done;\n-\t\t\
    }\n-\t}\n+\tif ((error = check_certificate(session, known_hosts, t->owner->connect_opts.callbacks.certificate_check,\
    \ t->owner->connect_opts.callbacks.payload, s->url.host, port)) < 0)\n+\t\tgoto\
    \ done;\n \n \t/* we need the username to ask for auth methods */\n \tif (!s->url.username)\
    \ {\n@@ -651,6 +884,8 @@ static int _git_ssh_setup_conn(\n \tif (error < 0) {\n\
    \ \t\tssh_stream_free(*stream);\n \n+\t\tif (known_hosts)\n+\t\t\tlibssh2_knownhost_free(known_hosts);\n\
    \ \t\tif (session)\n \t\t\tlibssh2_session_free(session);\n \t}"
  - "--- a/src/transports/ssh.c\n+++ b/src/transports/ssh.c\n@@ -421,37 +421,345 @@\
    \ static int request_creds(git_credential **out, ssh_subtransport *t, const char\
    \ *\n \treturn 0;\n }\n \n+#define KNOWN_HOSTS_FILE \".ssh/known_hosts\"\n+\n\
    +/*\n+ * Load the known_hosts file.\n+ *\n+ * Returns success but leaves the output\
    \ NULL if we couldn't find the file.\n+ */\n+static int load_known_hosts(LIBSSH2_KNOWNHOSTS\
    \ **hosts, LIBSSH2_SESSION *session)\n+{\n+\tgit_str path = GIT_STR_INIT, home\
    \ = GIT_STR_INIT;\n+\tLIBSSH2_KNOWNHOSTS *known_hosts = NULL;\n+\tint error;\n\
    +\n+\tGIT_ASSERT_ARG(hosts);\n+\n+\tif ((error = git__getenv(&home, \"HOME\"))\
    \ < 0)\n+\t\treturn error;\n+\n+\tif ((error = git_str_joinpath(&path, git_str_cstr(&home),\
    \ KNOWN_HOSTS_FILE)) < 0)\n+\t\tgoto out;\n+\n+\tif ((known_hosts = libssh2_knownhost_init(session))\
    \ == NULL) {\n+\t\tssh_error(session, \"error initializing known hosts\");\n+\t\
    \terror = -1;\n+\t\tgoto out;\n+\t}\n+\n+\t/*\n+\t * Try to read the file and\
    \ consider not finding it as not trusting the\n+\t * host rather than an error.\n\
    +\t */\n+\terror = libssh2_knownhost_readfile(known_hosts, git_str_cstr(&path),\
    \ LIBSSH2_KNOWNHOST_FILE_OPENSSH);\n+\tif (error == LIBSSH2_ERROR_FILE)\n+\t\t\
    error = 0;\n+\tif (error < 0)\n+\t\tssh_error(session, \"error reading known_hosts\"\
    );\n+\n+out:\n+\t*hosts = known_hosts;\n+\n+\tgit_str_clear(&home);\n+\tgit_str_clear(&path);\n\
    +\n+\treturn error;\n+}\n+\n+static const char *hostkey_type_to_string(int type)\n\
    +{\n+\tswitch (type) {\n+\tcase LIBSSH2_KNOWNHOST_KEY_SSHRSA:\n+\t\treturn \"\
    ssh-rsa\";\n+\tcase LIBSSH2_KNOWNHOST_KEY_SSHDSS:\n+\t\treturn \"ssh-dss\";\n\
    +#ifdef LIBSSH2_KNOWNHOST_KEY_ECDSA_256\n+\tcase LIBSSH2_KNOWNHOST_KEY_ECDSA_256:\n\
    +\t\treturn \"ecdsa-sha2-nistp256\";\n+\tcase LIBSSH2_KNOWNHOST_KEY_ECDSA_384:\n\
    +\t\treturn \"ecdsa-sha2-nistp384\";\n+\tcase LIBSSH2_KNOWNHOST_KEY_ECDSA_521:\n\
    +\t\treturn \"ecdsa-sha2-nistp521\";\n+#endif\n+#ifdef LIBSSH2_KNOWNHOST_KEY_ED25519\n\
    +\tcase LIBSSH2_KNOWNHOST_KEY_ED25519:\n+\t\treturn \"ssh-ed25519\";\n+#endif\n\
    +\t}\n+\n+\treturn NULL;\n+}\n+\n+/*\n+ * We figure out what kind of key we want\
    \ to ask the remote for by trying to\n+ * look it up with a nonsense key and using\
    \ that mismatch to figure out what key\n+ * we do have stored for the host.\n\
    + *\n+ * Returns the string to pass to libssh2_session_method_pref or NULL if\
    \ we were\n+ * unable to find anything or an error happened.\n+ */\n+static const\
    \ char *find_hostkey_preference(LIBSSH2_KNOWNHOSTS *known_hosts, const char *hostname,\
    \ int port)\n+{\n+\tstruct libssh2_knownhost *host = NULL;\n+\t/* Specify no key\
    \ type so we don't filter on that */\n+\tint type = LIBSSH2_KNOWNHOST_TYPE_PLAIN\
    \ | LIBSSH2_KNOWNHOST_KEYENC_RAW;\n+\tconst char key = '\\0';\n+\tint error;\n\
    +\n+\t/*\n+\t * In case of mismatch, we can find the type of key from known_hosts\
    \ in\n+\t * the returned host's information as it means that an entry was found\n\
    +\t * but our nonsense key obviously didn't match.\n+\t */\n+\terror = libssh2_knownhost_checkp(known_hosts,\
    \ hostname, port, &key, 1, type, &host);\n+\tif (error == LIBSSH2_KNOWNHOST_CHECK_MISMATCH)\n\
    +\t\treturn hostkey_type_to_string(host->typemask & LIBSSH2_KNOWNHOST_KEY_MASK);\n\
    +\n+\treturn NULL;\n+}\n+\n static int _git_ssh_session_create(\n \tLIBSSH2_SESSION\
    \ **session,\n+\tLIBSSH2_KNOWNHOSTS **hosts,\n+\tconst char *hostname,\n+\tint\
    \ port,\n \tgit_stream *io)\n {\n \tint rc = 0;\n \tLIBSSH2_SESSION *s;\n+\tLIBSSH2_KNOWNHOSTS\
    \ *known_hosts;\n \tgit_socket_stream *socket = GIT_CONTAINER_OF(io, git_socket_stream,\
    \ parent);\n+\tconst char *keytype = NULL;\n \n \tGIT_ASSERT_ARG(session);\n+\t\
    GIT_ASSERT_ARG(hosts);\n \n \ts = libssh2_session_init();\n \tif (!s) {\n \t\t\
    git_error_set(GIT_ERROR_NET, \"failed to initialize SSH session\");\n \t\treturn\
    \ -1;\n \t}\n \n+\tif ((rc = load_known_hosts(&known_hosts, s)) < 0) {\n+\t\t\
    ssh_error(s, \"error loading known_hosts\");\n+\t\tlibssh2_session_free(s);\n\
    +\t\treturn -1;\n+\t}\n+\n+\tif ((keytype = find_hostkey_preference(known_hosts,\
    \ hostname, port)) != NULL) {\n+\t\tdo {\n+\t\t\trc = libssh2_session_method_pref(s,\
    \ LIBSSH2_METHOD_HOSTKEY, keytype);\n+\t\t} while (LIBSSH2_ERROR_EAGAIN == rc\
    \ || LIBSSH2_ERROR_TIMEOUT == rc);\n+\t\tif (rc != LIBSSH2_ERROR_NONE) {\n+\t\t\
    \tssh_error(s, \"failed to set hostkey preference\");\n+\t\t\tgoto on_error;\n\
    +\t\t}\n+\t}\n+\n+\n \tdo {\n \t\trc = libssh2_session_handshake(s, socket->s);\n\
    \ \t} while (LIBSSH2_ERROR_EAGAIN == rc || LIBSSH2_ERROR_TIMEOUT == rc);\n \n\
    \ \tif (rc != LIBSSH2_ERROR_NONE) {\n \t\tssh_error(s, \"failed to start SSH session\"\
    );\n-\t\tlibssh2_session_free(s);\n-\t\treturn -1;\n+\t\tgoto on_error;\n \t}\n\
    \ \n \tlibssh2_session_set_blocking(s, 1);\n \n \t*session = s;\n+\t*hosts = known_hosts;\n\
    \ \n \treturn 0;\n+\n+on_error:\n+\tlibssh2_knownhost_free(known_hosts);\n+\t\
    libssh2_session_free(s);\n+\treturn -1;\n+}\n+\n+\n+/*\n+ * Returns the typemask\
    \ argument to pass to libssh2_knownhost_check{,p} based on\n+ * the type of key\
    \ that libssh2_session_hostkey returns.\n+ */\n+static int fingerprint_type_mask(int\
    \ keytype)\n+{\n+\tint mask = LIBSSH2_KNOWNHOST_TYPE_PLAIN | LIBSSH2_KNOWNHOST_KEYENC_RAW;\n\
    +\treturn mask;\n+\n+\tswitch (keytype) {\n+\tcase LIBSSH2_HOSTKEY_TYPE_RSA:\n\
    +\t\tmask |= LIBSSH2_KNOWNHOST_KEY_SSHRSA;\n+\t\tbreak;\n+\tcase LIBSSH2_HOSTKEY_TYPE_DSS:\n\
    +\t\tmask |= LIBSSH2_KNOWNHOST_KEY_SSHDSS;\n+\t\tbreak;\n+#ifdef LIBSSH2_HOSTKEY_TYPE_ECDSA_256\n\
    +\tcase LIBSSH2_HOSTKEY_TYPE_ECDSA_256:\n+\t\tmask |= LIBSSH2_KNOWNHOST_KEY_ECDSA_256;\n\
    +\t\tbreak;\n+\tcase LIBSSH2_HOSTKEY_TYPE_ECDSA_384:\n+\t\tmask |= LIBSSH2_KNOWNHOST_KEY_ECDSA_384;\n\
    +\t\tbreak;\n+\tcase LIBSSH2_HOSTKEY_TYPE_ECDSA_521:\n+\t\tmask |= LIBSSH2_KNOWNHOST_KEY_ECDSA_521;\n\
    +\t\tbreak;\n+#endif\n+#ifdef LIBSSH2_HOSTKEY_TYPE_ED25519\n+\tcase LIBSSH2_HOSTKEY_TYPE_ED25519:\n\
    +\t\tmask |= LIBSSH2_KNOWNHOST_KEY_ED25519;\n+\t\tbreak;\n+#endif\n+\t}\n+\n+\t\
    return mask;\n+}\n+\n+/*\n+ * Check the host against the user's known_hosts file.\n\
    + *\n+ * Returns 1/0 for valid/''not-valid or <0 for an error\n+ */\n+static int\
    \ check_against_known_hosts(\n+\tLIBSSH2_SESSION *session,\n+\tLIBSSH2_KNOWNHOSTS\
    \ *known_hosts,\n+\tconst char *hostname,\n+\tint port,\n+\tconst char *key,\n\
    +\tsize_t key_len,\n+\tint key_type)\n+{\n+\tint check, typemask, ret = 0;\n+\t\
    struct libssh2_knownhost *host = NULL;\n+\n+\tif (known_hosts == NULL)\n+\t\t\
    return 0;\n+\n+\ttypemask = fingerprint_type_mask(key_type);\n+\tcheck = libssh2_knownhost_checkp(known_hosts,\
    \ hostname, port, key, key_len, typemask, &host);\n+\tif (check == LIBSSH2_KNOWNHOST_CHECK_FAILURE)\
    \ {\n+\t\tssh_error(session, \"error checking for known host\");\n+\t\treturn\
    \ -1;\n+\t}\n+\n+\tret = check == LIBSSH2_KNOWNHOST_CHECK_MATCH ? 1 : 0;\n+\n\
    +\treturn ret;\n+}\n+\n+/*\n+ * Perform the check for the session's certificate\
    \ against known hosts if\n+ * possible and then ask the user if they have a callback.\n\
    + *\n+ * Returns 1/0 for valid/not-valid or <0 for an error\n+ */\n+static int\
    \ check_certificate(\n+\tLIBSSH2_SESSION *session,\n+\tLIBSSH2_KNOWNHOSTS *known_hosts,\n\
    +\tgit_transport_certificate_check_cb check_cb,\n+\tvoid *check_cb_payload,\n\
    +\tconst char *host,\n+\tint port)\n+{\n+\tgit_cert_hostkey cert = {{ 0 }};\n\
    +\tconst char *key;\n+\tsize_t cert_len;\n+\tint cert_type, cert_valid = 0, error\
    \ = 0;\n+\n+\tif ((key = libssh2_session_hostkey(session, &cert_len, &cert_type))\
    \ == NULL) {\n+\t\tssh_error(session, \"failed to retrieve hostkey\");\n+\t\t\
    return -1;\n+\t}\n+\n+\tif ((cert_valid = check_against_known_hosts(session, known_hosts,\
    \ host, port, key, cert_len, cert_type)) < 0)\n+\t\treturn -1;\n+\n+\tcert.parent.cert_type\
    \ = GIT_CERT_HOSTKEY_LIBSSH2;\n+\tif (key != NULL) {\n+\t\tcert.type |= GIT_CERT_SSH_RAW;\n\
    +\t\tcert.hostkey = key;\n+\t\tcert.hostkey_len = cert_len;\n+\t\tswitch (cert_type)\
    \ {\n+\t\tcase LIBSSH2_HOSTKEY_TYPE_RSA:\n+\t\t\tcert.raw_type = GIT_CERT_SSH_RAW_TYPE_RSA;\n\
    +\t\t\tbreak;\n+\t\tcase LIBSSH2_HOSTKEY_TYPE_DSS:\n+\t\t\tcert.raw_type = GIT_CERT_SSH_RAW_TYPE_DSS;\n\
    +\t\t\tbreak;\n+\n+#ifdef LIBSSH2_HOSTKEY_TYPE_ECDSA_256\n+\t\tcase LIBSSH2_HOSTKEY_TYPE_ECDSA_256:\n\
    +\t\t\tcert.raw_type = GIT_CERT_SSH_RAW_TYPE_KEY_ECDSA_256;\n+\t\t\tbreak;\n+\t\
    \tcase LIBSSH2_HOSTKEY_TYPE_ECDSA_384:\n+\t\t\tcert.raw_type = GIT_CERT_SSH_RAW_TYPE_KEY_ECDSA_384;\n\
    +\t\t\tbreak;\n+\t\tcase LIBSSH2_KNOWNHOST_KEY_ECDSA_521:\n+\t\t\tcert.raw_type\
    \ = GIT_CERT_SSH_RAW_TYPE_KEY_ECDSA_521;\n+\t\t\tbreak;\n+#endif\n+\n+#ifdef LIBSSH2_HOSTKEY_TYPE_ED25519\n\
    +\t\tcase LIBSSH2_HOSTKEY_TYPE_ED25519:\n+\t\t\tcert.raw_type = GIT_CERT_SSH_RAW_TYPE_KEY_ED25519;\n\
    +\t\t\tbreak;\n+#endif\n+\t\tdefault:\n+\t\t\tcert.raw_type = GIT_CERT_SSH_RAW_TYPE_UNKNOWN;\n\
    +\t\t}\n+\t}\n+\n+#ifdef LIBSSH2_HOSTKEY_HASH_SHA256\n+\tkey = libssh2_hostkey_hash(session,\
    \ LIBSSH2_HOSTKEY_HASH_SHA256);\n+\tif (key != NULL) {\n+\t\tcert.type |= GIT_CERT_SSH_SHA256;\n\
    +\t\tmemcpy(&cert.hash_sha256, key, 32);\n+\t}\n+#endif\n+\n+\tkey = libssh2_hostkey_hash(session,\
    \ LIBSSH2_HOSTKEY_HASH_SHA1);\n+\tif (key != NULL) {\n+\t\tcert.type |= GIT_CERT_SSH_SHA1;\n\
    +\t\tmemcpy(&cert.hash_sha1, key, 20);\n+\t}\n+\n+\tkey = libssh2_hostkey_hash(session,\
    \ LIBSSH2_HOSTKEY_HASH_MD5);\n+\tif (key != NULL) {\n+\t\tcert.type |= GIT_CERT_SSH_MD5;\n\
    +\t\tmemcpy(&cert.hash_md5, key, 16);\n+\t}\n+\n+\tif (cert.type == 0) {\n+\t\t\
    git_error_set(GIT_ERROR_SSH, \"unable to get the host key\");\n+\t\treturn -1;\n\
    +\t}\n+\n+\tgit_error_clear();\n+\terror = 0;\n+\tif (!cert_valid) {\n+\t\tgit_error_set(GIT_ERROR_SSH,\
    \ \"invalid or unknown remote ssh hostkey\");\n+\t\terror = GIT_ECERTIFICATE;\n\
    +\t}\n+\n+\tif (check_cb != NULL) {\n+\t\tgit_cert_hostkey *cert_ptr = &cert;\n\
    +\t\tgit_error_state previous_error = {0};\n+\n+\t\tgit_error_state_capture(&previous_error,\
    \ error);\n+\t\terror = check_cb((git_cert *) cert_ptr, cert_valid, host, check_cb_payload);\n\
    +\t\tif (error == GIT_PASSTHROUGH) {\n+\t\t\terror = git_error_state_restore(&previous_error);\n\
    +\t\t} else if (error < 0 && !git_error_last()) {\n+\t\t\tgit_error_set(GIT_ERROR_NET,\
    \ \"user canceled hostkey check\");\n+\t\t}\n+\n+\t\tgit_error_state_free(&previous_error);\n\
    +\t}\n+\n+\treturn error;\n }\n \n #define SSH_DEFAULT_PORT \"22\"\n@@ -462,11\
    \ +770,12 @@ static int _git_ssh_setup_conn(\n \tconst char *cmd,\n \tgit_smart_subtransport_stream\
    \ **stream)\n {\n-\tint auth_methods, error = 0;\n+\tint auth_methods, error =\
    \ 0, port;\n \tssh_stream *s;\n \tgit_credential *cred = NULL;\n \tLIBSSH2_SESSION\
    \ *session=NULL;\n \tLIBSSH2_CHANNEL *channel=NULL;\n+\tLIBSSH2_KNOWNHOSTS *known_hosts\
    \ = NULL;\n \n \tt->current_stream = NULL;\n \n@@ -490,96 +799,20 @@ static int\
    \ _git_ssh_setup_conn(\n \t    (error = git_stream_connect(s->io)) < 0)\n \t\t\
    goto done;\n \n-\tif ((error = _git_ssh_session_create(&session, s->io)) < 0)\n\
    -\t\tgoto done;\n-\n-\tif (t->owner->connect_opts.callbacks.certificate_check\
    \ != NULL) {\n-\t\tgit_cert_hostkey cert = {{ 0 }}, *cert_ptr;\n-\t\tconst char\
    \ *key;\n-\t\tsize_t cert_len;\n-\t\tint cert_type;\n-\n-\t\tcert.parent.cert_type\
    \ = GIT_CERT_HOSTKEY_LIBSSH2;\n-\n-\t\tkey = libssh2_session_hostkey(session,\
    \ &cert_len, &cert_type);\n-\t\tif (key != NULL) {\n-\t\t\tcert.type |= GIT_CERT_SSH_RAW;\n\
    -\t\t\tcert.hostkey = key;\n-\t\t\tcert.hostkey_len = cert_len;\n-\t\t\tswitch\
    \ (cert_type) {\n-\t\t\t\tcase LIBSSH2_HOSTKEY_TYPE_RSA:\n-\t\t\t\t\tcert.raw_type\
    \ = GIT_CERT_SSH_RAW_TYPE_RSA;\n-\t\t\t\t\tbreak;\n-\t\t\t\tcase LIBSSH2_HOSTKEY_TYPE_DSS:\n\
    -\t\t\t\t\tcert.raw_type = GIT_CERT_SSH_RAW_TYPE_DSS;\n-\t\t\t\t\tbreak;\n-\n\
    -#ifdef LIBSSH2_HOSTKEY_TYPE_ECDSA_256\n-\t\t\t\tcase LIBSSH2_HOSTKEY_TYPE_ECDSA_256:\n\
    -\t\t\t\t\tcert.raw_type = GIT_CERT_SSH_RAW_TYPE_KEY_ECDSA_256;\n-\t\t\t\t\tbreak;\n\
    -\t\t\t\tcase LIBSSH2_HOSTKEY_TYPE_ECDSA_384:\n-\t\t\t\t\tcert.raw_type = GIT_CERT_SSH_RAW_TYPE_KEY_ECDSA_384;\n\
    -\t\t\t\t\tbreak;\n-\t\t\t\tcase LIBSSH2_KNOWNHOST_KEY_ECDSA_521:\n-\t\t\t\t\t\
    cert.raw_type = GIT_CERT_SSH_RAW_TYPE_KEY_ECDSA_521;\n-\t\t\t\t\tbreak;\n-#endif\n\
    -\n-#ifdef LIBSSH2_HOSTKEY_TYPE_ED25519\n-\t\t\t\tcase LIBSSH2_HOSTKEY_TYPE_ED25519:\n\
    -\t\t\t\t\tcert.raw_type = GIT_CERT_SSH_RAW_TYPE_KEY_ED25519;\n-\t\t\t\t\tbreak;\n\
    -#endif\n-\t\t\t\tdefault:\n-\t\t\t\t\tcert.raw_type = GIT_CERT_SSH_RAW_TYPE_UNKNOWN;\n\
    -\t\t\t}\n-\t\t}\n-\n-#ifdef LIBSSH2_HOSTKEY_HASH_SHA256\n-\t\tkey = libssh2_hostkey_hash(session,\
    \ LIBSSH2_HOSTKEY_HASH_SHA256);\n-\t\tif (key != NULL) {\n-\t\t\tcert.type |=\
    \ GIT_CERT_SSH_SHA256;\n-\t\t\tmemcpy(&cert.hash_sha256, key, 32);\n-\t\t}\n-#endif\n\
    -\n-\t\tkey = libssh2_hostkey_hash(session, LIBSSH2_HOSTKEY_HASH_SHA1);\n-\t\t\
    if (key != NULL) {\n-\t\t\tcert.type |= GIT_CERT_SSH_SHA1;\n-\t\t\tmemcpy(&cert.hash_sha1,\
    \ key, 20);\n-\t\t}\n-\n-\t\tkey = libssh2_hostkey_hash(session, LIBSSH2_HOSTKEY_HASH_MD5);\n\
    -\t\tif (key != NULL) {\n-\t\t\tcert.type |= GIT_CERT_SSH_MD5;\n-\t\t\tmemcpy(&cert.hash_md5,\
    \ key, 16);\n-\t\t}\n-\n-\t\tif (cert.type == 0) {\n-\t\t\tgit_error_set(GIT_ERROR_SSH,\
    \ \"unable to get the host key\");\n-\t\t\terror = -1;\n-\t\t\tgoto done;\n-\t\
    \t}\n-\n-\t\t/* We don't currently trust any hostkeys */\n-\t\tgit_error_clear();\n\
    -\n-\t\tcert_ptr = &cert;\n-\n-\t\terror = t->owner->connect_opts.callbacks.certificate_check(\n\
    -\t\t\t(git_cert *)cert_ptr,\n-\t\t\t0,\n-\t\t\ts->url.host,\n-\t\t\tt->owner->connect_opts.callbacks.payload);\n\
    +\t/*\n+\t * Try to parse the port as a number, if we can't then fall back to\n\
    +\t * default. It would be nice if we could get the port that was resolved\n+\t\
    \ * as part of the stream connection, but that's not something that's\n+\t * exposed.\n\
    +\t */\n+\tif (git__strntol32(&port, s->url.port, strlen(s->url.port), NULL, 10)\
    \ < 0)\n+\t\tport = -1;\n \n-\t\tif (error < 0 && error != GIT_PASSTHROUGH) {\n\
    -\t\t\tif (!git_error_last())\n-\t\t\t\tgit_error_set(GIT_ERROR_NET, \"user cancelled\
    \ hostkey check\");\n+\tif ((error = _git_ssh_session_create(&session, &known_hosts,\
    \ s->url.host, port, s->io)) < 0)\n+\t\tgoto done;\n \n-\t\t\tgoto done;\n-\t\t\
    }\n-\t}\n+\tif ((error = check_certificate(session, known_hosts, t->owner->connect_opts.callbacks.certificate_check,\
    \ t->owner->connect_opts.callbacks.payload, s->url.host, port)) < 0)\n+\t\tgoto\
    \ done;\n \n \t/* we need the username to ask for auth methods */\n \tif (!s->url.username)\
    \ {\n@@ -651,6 +884,8 @@ static int _git_ssh_setup_conn(\n \tif (error < 0) {\n\
    \ \t\tssh_stream_free(*stream);\n \n+\t\tif (known_hosts)\n+\t\t\tlibssh2_knownhost_free(known_hosts);\n\
    \ \t\tif (session)\n \t\t\tlibssh2_session_free(session);\n \t}"
  identifiers:
  - CVE-2023-22742
  - CWE-347
  overview: libgit2 is a cross-platform, linkable library implementation of Git. When
    using an SSH remote with the optional libssh2 backend, libgit2 does not perform
    certificate checking by default. Prior versions of libgit2 require the caller
    to set the `certificate_check` field of libgit2's `git_remote_callbacks` structure
    - if a certificate check callback is not set, libgit2 does not perform any certificate
    checking. This means that by default - without configuring a certificate check
    callback, clients will not perform validation on the server SSH keys and may be
    subject to a man-in-the-middle attack. Users are encouraged to upgrade to v1.4.5
    or v1.5.1. Users unable to upgrade should ensure that all relevant certificates
    are manually checked.
  references:
  - source: security-advisories@github.com
    url: http://www.openwall.com/lists/oss-security/2023/11/06/5
  - source: security-advisories@github.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/libgit2/libgit2/commit/42e5db98b963ae503229c63e44e06e439df50e56
  - source: security-advisories@github.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/libgit2/libgit2/commit/cd6f679af401eda1f172402006ef8265f8bd58ea
  - source: security-advisories@github.com
    tags:
    - Release Notes
    - Third Party Advisory
    url: https://github.com/libgit2/libgit2/releases/tag/v1.4.5
  - source: security-advisories@github.com
    tags:
    - Release Notes
    - Third Party Advisory
    url: https://github.com/libgit2/libgit2/releases/tag/v1.5.1
  - source: security-advisories@github.com
    tags:
    - Third Party Advisory
    url: https://github.com/libgit2/libgit2/security/advisories/GHSA-8643-3wh5-rmjq
  - source: security-advisories@github.com
    tags:
    - Third Party Advisory
    url: https://www.libssh2.org
  title: libgit2 is a cross-platform, linkable library implementation of Git. When
    using an SSH remote with the optional libssh2 backend, libgit2 does not perform
    certificate checking by default. Prior versions of libgit2 require the caller
    to set the `certificate_check` field of libgit2's `git_remote_callbacks` structure
    - if a certificate check callback is not set, libgit2 does not perform any certificate
    checking. This means that by default - without configuring a certificate check
    callback, clients will not perform validation on the server SSH keys and may be
    subject to a man-in-the-middle attack. Users are encouraged to upgrade to v1.4.5
    or v1.5.1. Users unable to upgrade should ensure that all relevant certificates
    are manually checked.
- diff_content:
  - "--- a/src/textformat.c\n+++ b/src/textformat.c\n@@ -540,6 +540,9 @@ same_leader(\n\
    \     if (leader1_len == 0)\n \treturn (leader2_len == 0);\n \n+    char_u  *lnum_line\
    \ = NULL;\n+    int\t    line_len = 0;\n+\n     // If first leader has 'f' flag,\
    \ the lines can be joined only if the\n     // second line does not have a leader.\n\
    \     // If first leader has 'e' flag, the lines can never be joined.\n@@ -555,7\
    \ +558,12 @@ same_leader(\n \t\treturn FALSE;\n \t    if (*p == COM_START)\n \t\
    \    {\n-\t\tif (*(ml_get(lnum) + leader1_len) == NUL)\n+\t\tif (lnum_line ==\
    \ NULL)\n+\t\t{\n+\t\t    lnum_line = ml_get(lnum);\n+\t\t    line_len = (int)STRLEN(lnum_line);\n\
    +\t\t}\n+\t\tif (line_len <= leader1_len)\n \t\t    return FALSE;\n \t\tif (leader2_flags\
    \ == NULL || leader2_len == 0)\n \t\t    return FALSE;"
  - "--- a/src/version.c\n+++ b/src/version.c\n@@ -695,6 +695,8 @@ static char *(features[])\
    \ =\n \n static int included_patches[] =\n {   /* Add new patch number below this\
    \ line */\n+/**/\n+    1225,\n /**/\n     1224,\n /**/"
  identifiers:
  - CVE-2023-0433
  - CWE-122
  overview: Heap-based Buffer Overflow in GitHub repository vim/vim prior to 9.0.1225.
  references:
  - source: security@huntr.dev
    url: http://seclists.org/fulldisclosure/2023/Mar/17
  - source: security@huntr.dev
    url: http://seclists.org/fulldisclosure/2023/Mar/18
  - source: security@huntr.dev
    url: http://seclists.org/fulldisclosure/2023/Mar/21
  - source: security@huntr.dev
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/vim/vim/commit/11977f917506d950b7e0cae558bd9189260b253b
  - source: security@huntr.dev
    tags:
    - Exploit
    - Third Party Advisory
    url: https://huntr.dev/bounties/ae933869-a1ec-402a-bbea-d51764c6618e
  - source: security@huntr.dev
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/4EX6N2DB75A73MQGVW3CS4VTNPAYVM2M/
  - source: security@huntr.dev
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/PZWIJBSQX53P7DHV77KRXJIXA4GH7XHC/
  - source: security@huntr.dev
    url: https://support.apple.com/kb/HT213670
  - source: security@huntr.dev
    url: https://support.apple.com/kb/HT213675
  - source: security@huntr.dev
    url: https://support.apple.com/kb/HT213677
  title: Heap-based Buffer Overflow in GitHub repository vim/vim prior to 9.0.1225.
- diff_content:
  - "--- a/tools/tiffcrop.c\n+++ b/tools/tiffcrop.c\n@@ -8591,7 +8591,7 @@ static\
    \ int processCropSelections(struct image_data *image,\n                     cropsize\
    \ + NUM_BUFF_OVERSIZE_BYTES);\n             else\n             {\n-          \
    \      prev_cropsize = seg_buffs[0].size;\n+                prev_cropsize = seg_buffs[i].size;\n\
    \                 if (prev_cropsize < cropsize)\n                 {\n        \
    \             next_buff = _TIFFrealloc(\n"
  identifiers:
  - CVE-2022-48281
  - CWE-787
  overview: processCropSelections in tools/tiffcrop.c in LibTIFF through 4.5.0 has
    a heap-based buffer overflow (e.g., "WRITE of size 307203") via a crafted TIFF
    image.
  references:
  - source: cve@mitre.org
    tags:
    - Patch
    - Third Party Advisory
    url: https://gitlab.com/libtiff/libtiff/-/commit/d1b6b9c1b3cae2d9e37754506c1ad8f4f7b646b5
  - source: cve@mitre.org
    tags:
    - Exploit
    - Issue Tracking
    - Patch
    - Third Party Advisory
    url: https://gitlab.com/libtiff/libtiff/-/issues/488
  - source: cve@mitre.org
    tags:
    - Mailing List
    - Third Party Advisory
    url: https://lists.debian.org/debian-lts-announce/2023/01/msg00037.html
  - source: cve@mitre.org
    url: https://security.gentoo.org/glsa/202305-31
  - source: cve@mitre.org
    url: https://security.netapp.com/advisory/ntap-20230302-0004/
  - source: cve@mitre.org
    tags:
    - Third Party Advisory
    url: https://www.debian.org/security/2023/dsa-5333
  title: processCropSelections in tools/tiffcrop.c in LibTIFF through 4.5.0 has a
    heap-based buffer overflow (e.g., "WRITE of size 307203") via a crafted TIFF image.
- diff_content:
  - "--- a/fs/io_uring.c\n+++ b/fs/io_uring.c\n@@ -1040,6 +1040,27 @@ static inline\
    \ void req_set_fail_links(struct io_kiocb *req)\n \t\treq->flags |= REQ_F_FAIL_LINK;\n\
    \ }\n \n+/*\n+ * None of these are dereferenced, they are simply used to check\
    \ if any of\n+ * them have changed. If we're under current and check they are\
    \ still the\n+ * same, we're fine to grab references to them for actual out-of-line\
    \ use.\n+ */\n+static void io_init_identity(struct io_identity *id)\n+{\n+\tid->files\
    \ = current->files;\n+\tid->mm = current->mm;\n+#ifdef CONFIG_BLK_CGROUP\n+\t\
    rcu_read_lock();\n+\tid->blkcg_css = blkcg_css();\n+\trcu_read_unlock();\n+#endif\n\
    +\tid->creds = current_cred();\n+\tid->nsproxy = current->nsproxy;\n+\tid->fs\
    \ = current->fs;\n+\tid->fsize = rlimit(RLIMIT_FSIZE);\n+\trefcount_set(&id->count,\
    \ 1);\n+}\n+\n /*\n  * Note: must call io_req_init_async() for the first time\
    \ you\n  * touch any members of io_wq_work.\n@@ -1051,6 +1072,7 @@ static inline\
    \ void io_req_init_async(struct io_kiocb *req)\n \n \tmemset(&req->work, 0, sizeof(req->work));\n\
    \ \treq->flags |= REQ_F_WORK_INITIALIZED;\n+\tio_init_identity(&req->identity);\n\
    \ \treq->work.identity = &req->identity;\n }\n \n@@ -1157,6 +1179,14 @@ static\
    \ void __io_commit_cqring(struct io_ring_ctx *ctx)\n \t}\n }\n \n+static void\
    \ io_put_identity(struct io_kiocb *req)\n+{\n+\tif (req->work.identity == &req->identity)\n\
    +\t\treturn;\n+\tif (refcount_dec_and_test(&req->work.identity->count))\n+\t\t\
    kfree(req->work.identity);\n+}\n+\n static void io_req_clean_work(struct io_kiocb\
    \ *req)\n {\n \tif (!(req->flags & REQ_F_WORK_INITIALIZED))\n@@ -1189,75 +1219,147\
    \ @@ static void io_req_clean_work(struct io_kiocb *req)\n \t\t\tfree_fs_struct(fs);\n\
    \ \t\treq->work.flags &= ~IO_WQ_WORK_FS;\n \t}\n+\n+\tio_put_identity(req);\n\
    \ }\n \n-static void io_prep_async_work(struct io_kiocb *req)\n+/*\n+ * Create\
    \ a private copy of io_identity, since some fields don't match\n+ * the current\
    \ context.\n+ */\n+static bool io_identity_cow(struct io_kiocb *req)\n+{\n+\t\
    const struct cred *creds = NULL;\n+\tstruct io_identity *id;\n+\n+\tif (req->work.flags\
    \ & IO_WQ_WORK_CREDS)\n+\t\tcreds = req->work.identity->creds;\n+\n+\tid = kmemdup(req->work.identity,\
    \ sizeof(*id), GFP_KERNEL);\n+\tif (unlikely(!id)) {\n+\t\treq->work.flags |=\
    \ IO_WQ_WORK_CANCEL;\n+\t\treturn false;\n+\t}\n+\n+\t/*\n+\t * We can safely\
    \ just re-init the creds we copied  Either the field\n+\t * matches the current\
    \ one, or we haven't grabbed it yet. The only\n+\t * exception is ->creds, through\
    \ registered personalities, so handle\n+\t * that one separately.\n+\t */\n+\t\
    io_init_identity(id);\n+\tif (creds)\n+\t\treq->work.identity->creds = creds;\n\
    +\n+\t/* add one for this request */\n+\trefcount_inc(&id->count);\n+\n+\t/* drop\
    \ old identity, assign new one. one ref for req, one for tctx */\n+\tif (req->work.identity\
    \ != &req->identity &&\n+\t    refcount_sub_and_test(2, &req->work.identity->count))\n\
    +\t\tkfree(req->work.identity);\n+\n+\treq->work.identity = id;\n+\treturn true;\n\
    +}\n+\n+static bool io_grab_identity(struct io_kiocb *req)\n {\n \tconst struct\
    \ io_op_def *def = &io_op_defs[req->opcode];\n+\tstruct io_identity *id = &req->identity;\n\
    \ \tstruct io_ring_ctx *ctx = req->ctx;\n \n-\tio_req_init_async(req);\n+\tif\
    \ (def->needs_fsize && id->fsize != rlimit(RLIMIT_FSIZE))\n+\t\treturn false;\n\
    \ \n-\tif (req->flags & REQ_F_ISREG) {\n-\t\tif (def->hash_reg_file || (ctx->flags\
    \ & IORING_SETUP_IOPOLL))\n-\t\t\tio_wq_hash_work(&req->work, file_inode(req->file));\n\
    -\t} else {\n-\t\tif (def->unbound_nonreg_file)\n-\t\t\treq->work.flags |= IO_WQ_WORK_UNBOUND;\n\
    -\t}\n \tif (!(req->work.flags & IO_WQ_WORK_FILES) &&\n-\t    (io_op_defs[req->opcode].work_flags\
    \ & IO_WQ_WORK_FILES) &&\n+\t    (def->work_flags & IO_WQ_WORK_FILES) &&\n \t\
    \    !(req->flags & REQ_F_NO_FILE_TABLE)) {\n-\t\treq->work.identity->files =\
    \ get_files_struct(current);\n-\t\tget_nsproxy(current->nsproxy);\n-\t\treq->work.identity->nsproxy\
    \ = current->nsproxy;\n+\t\tif (id->files != current->files ||\n+\t\t    id->nsproxy\
    \ != current->nsproxy)\n+\t\t\treturn false;\n+\t\tatomic_inc(&id->files->count);\n\
    +\t\tget_nsproxy(id->nsproxy);\n \t\treq->flags |= REQ_F_INFLIGHT;\n \n \t\tspin_lock_irq(&ctx->inflight_lock);\n\
    \ \t\tlist_add(&req->inflight_entry, &ctx->inflight_list);\n \t\tspin_unlock_irq(&ctx->inflight_lock);\n\
    \ \t\treq->work.flags |= IO_WQ_WORK_FILES;\n \t}\n-\tif (!(req->work.flags & IO_WQ_WORK_MM)\
    \ &&\n-\t    (def->work_flags & IO_WQ_WORK_MM)) {\n-\t\tmmgrab(current->mm);\n\
    -\t\treq->work.identity->mm = current->mm;\n-\t\treq->work.flags |= IO_WQ_WORK_MM;\n\
    -\t}\n #ifdef CONFIG_BLK_CGROUP\n \tif (!(req->work.flags & IO_WQ_WORK_BLKCG)\
    \ &&\n \t    (def->work_flags & IO_WQ_WORK_BLKCG)) {\n \t\trcu_read_lock();\n\
    -\t\treq->work.identity->blkcg_css = blkcg_css();\n+\t\tif (id->blkcg_css != blkcg_css())\
    \ {\n+\t\t\trcu_read_unlock();\n+\t\t\treturn false;\n+\t\t}\n \t\t/*\n \t\t *\
    \ This should be rare, either the cgroup is dying or the task\n \t\t * is moving\
    \ cgroups. Just punt to root for the handful of ios.\n \t\t */\n-\t\tif (css_tryget_online(req->work.identity->blkcg_css))\n\
    +\t\tif (css_tryget_online(id->blkcg_css))\n \t\t\treq->work.flags |= IO_WQ_WORK_BLKCG;\n\
    \ \t\trcu_read_unlock();\n \t}\n #endif\n \tif (!(req->work.flags & IO_WQ_WORK_CREDS))\
    \ {\n-\t\treq->work.identity->creds = get_current_cred();\n+\t\tif (id->creds\
    \ != current_cred())\n+\t\t\treturn false;\n+\t\tget_cred(id->creds);\n \t\treq->work.flags\
    \ |= IO_WQ_WORK_CREDS;\n \t}\n \tif (!(req->work.flags & IO_WQ_WORK_FS) &&\n \t\
    \    (def->work_flags & IO_WQ_WORK_FS)) {\n-\t\tspin_lock(&current->fs->lock);\n\
    -\t\tif (!current->fs->in_exec) {\n-\t\t\treq->work.identity->fs = current->fs;\n\
    -\t\t\treq->work.identity->fs->users++;\n+\t\tif (current->fs != id->fs)\n+\t\t\
    \treturn false;\n+\t\tspin_lock(&id->fs->lock);\n+\t\tif (!id->fs->in_exec) {\n\
    +\t\t\tid->fs->users++;\n \t\t\treq->work.flags |= IO_WQ_WORK_FS;\n \t\t} else\
    \ {\n \t\t\treq->work.flags |= IO_WQ_WORK_CANCEL;\n \t\t}\n \t\tspin_unlock(&current->fs->lock);\n\
    \ \t}\n-\tif (def->needs_fsize)\n-\t\treq->work.identity->fsize = rlimit(RLIMIT_FSIZE);\n\
    -\telse\n-\t\treq->work.identity->fsize = RLIM_INFINITY;\n+\n+\treturn true;\n\
    +}\n+\n+static void io_prep_async_work(struct io_kiocb *req)\n+{\n+\tconst struct\
    \ io_op_def *def = &io_op_defs[req->opcode];\n+\tstruct io_identity *id = &req->identity;\n\
    +\tstruct io_ring_ctx *ctx = req->ctx;\n+\n+\tio_req_init_async(req);\n+\n+\t\
    if (req->flags & REQ_F_ISREG) {\n+\t\tif (def->hash_reg_file || (ctx->flags &\
    \ IORING_SETUP_IOPOLL))\n+\t\t\tio_wq_hash_work(&req->work, file_inode(req->file));\n\
    +\t} else {\n+\t\tif (def->unbound_nonreg_file)\n+\t\t\treq->work.flags |= IO_WQ_WORK_UNBOUND;\n\
    +\t}\n+\n+\t/* ->mm can never change on us */\n+\tif (!(req->work.flags & IO_WQ_WORK_MM)\
    \ &&\n+\t    (def->work_flags & IO_WQ_WORK_MM)) {\n+\t\tmmgrab(id->mm);\n+\t\t\
    req->work.flags |= IO_WQ_WORK_MM;\n+\t}\n+\n+\t/* if we fail grabbing identity,\
    \ we must COW, regrab, and retry */\n+\tif (io_grab_identity(req))\n+\t\treturn;\n\
    +\n+\tif (!io_identity_cow(req))\n+\t\treturn;\n+\n+\t/* can't fail at this point\
    \ */\n+\tif (!io_grab_identity(req))\n+\t\tWARN_ON(1);\n }\n \n static void io_prep_async_link(struct\
    \ io_kiocb *req)\n@@ -1696,12 +1798,10 @@ static void io_dismantle_req(struct\
    \ io_kiocb *req)\n \n static void __io_free_req(struct io_kiocb *req)\n {\n-\t\
    struct io_uring_task *tctx;\n-\tstruct io_ring_ctx *ctx;\n+\tstruct io_uring_task\
    \ *tctx = req->task->io_uring;\n+\tstruct io_ring_ctx *ctx = req->ctx;\n \n \t\
    io_dismantle_req(req);\n-\ttctx = req->task->io_uring;\n-\tctx = req->ctx;\n \n\
    \ \tatomic_long_inc(&tctx->req_complete);\n \tif (tctx->in_idle)\n@@ -6374,11\
    \ +6474,16 @@ static int io_init_req(struct io_ring_ctx *ctx, struct io_kiocb\
    \ *req,\n \n \tid = READ_ONCE(sqe->personality);\n \tif (id) {\n+\t\tstruct io_identity\
    \ *iod;\n+\n \t\tio_req_init_async(req);\n-\t\treq->work.identity->creds = idr_find(&ctx->personality_idr,\
    \ id);\n-\t\tif (unlikely(!req->work.identity->creds))\n+\t\tiod = idr_find(&ctx->personality_idr,\
    \ id);\n+\t\tif (unlikely(!iod))\n \t\t\treturn -EINVAL;\n-\t\tget_cred(req->work.identity->creds);\n\
    +\t\trefcount_inc(&iod->count);\n+\t\tio_put_identity(req);\n+\t\tget_cred(iod->creds);\n\
    +\t\treq->work.identity = iod;\n \t\treq->work.flags |= IO_WQ_WORK_CREDS;\n \t\
    }\n \n@@ -8171,11 +8276,14 @@ static int io_uring_fasync(int fd, struct file *file,\
    \ int on)\n static int io_remove_personalities(int id, void *p, void *data)\n\
    \ {\n \tstruct io_ring_ctx *ctx = data;\n-\tconst struct cred *cred;\n+\tstruct\
    \ io_identity *iod;\n \n-\tcred = idr_remove(&ctx->personality_idr, id);\n-\t\
    if (cred)\n-\t\tput_cred(cred);\n+\tiod = idr_remove(&ctx->personality_idr, id);\n\
    +\tif (iod) {\n+\t\tput_cred(iod->creds);\n+\t\tif (refcount_dec_and_test(&iod->count))\n\
    +\t\t\tkfree(iod);\n+\t}\n \treturn 0;\n }\n \n@@ -9245,23 +9353,33 @@ static\
    \ int io_probe(struct io_ring_ctx *ctx, void __user *arg, unsigned nr_args)\n\
    \ \n static int io_register_personality(struct io_ring_ctx *ctx)\n {\n-\tconst\
    \ struct cred *creds = get_current_cred();\n-\tint id;\n+\tstruct io_identity\
    \ *id;\n+\tint ret;\n \n-\tid = idr_alloc_cyclic(&ctx->personality_idr, (void\
    \ *) creds, 1,\n-\t\t\t\tUSHRT_MAX, GFP_KERNEL);\n-\tif (id < 0)\n-\t\tput_cred(creds);\n\
    -\treturn id;\n+\tid = kmalloc(sizeof(*id), GFP_KERNEL);\n+\tif (unlikely(!id))\n\
    +\t\treturn -ENOMEM;\n+\n+\tio_init_identity(id);\n+\tid->creds = get_current_cred();\n\
    +\n+\tret = idr_alloc_cyclic(&ctx->personality_idr, id, 1, USHRT_MAX, GFP_KERNEL);\n\
    +\tif (ret < 0) {\n+\t\tput_cred(id->creds);\n+\t\tkfree(id);\n+\t}\n+\treturn\
    \ ret;\n }\n \n static int io_unregister_personality(struct io_ring_ctx *ctx,\
    \ unsigned id)\n {\n-\tconst struct cred *old_creds;\n+\tstruct io_identity *iod;\n\
    \ \n-\told_creds = idr_remove(&ctx->personality_idr, id);\n-\tif (old_creds) {\n\
    -\t\tput_cred(old_creds);\n+\tiod = idr_remove(&ctx->personality_idr, id);\n+\t\
    if (iod) {\n+\t\tput_cred(iod->creds);\n+\t\tif (refcount_dec_and_test(&iod->count))\n\
    +\t\t\tkfree(iod);\n \t\treturn 0;\n \t}\n "
  identifiers:
  - CVE-2023-0240
  - CWE-416
  overview: 'There is a logic error in io_uring''s implementation which can be used
    to trigger a use-after-free vulnerability leading to privilege escalation.


    In the io_prep_async_work function the assumption that the last io_grab_identity
    call cannot return false is not true, and in this case the function will use the
    init_cred or the previous linked requests identity to do operations instead of
    using the current identity. This can lead to reference counting issues causing
    use-after-free. We recommend upgrading past version 5.10.161.'
  references:
  - source: cve-coordination@google.com
    tags:
    - Mailing List
    - Patch
    - Vendor Advisory
    url: https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/io_uring?h=linux-5.10.y&id=788d0824269bef539fe31a785b1517882eafed93
  - source: cve-coordination@google.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/gregkh/linux/commit/1e6fa5216a0e59ef02e8b6b40d553238a3b81d49
  - source: cve-coordination@google.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://kernel.dance/#788d0824269bef539fe31a785b1517882eafed93
  title: 'There is a logic error in io_uring''s implementation which can be used to
    trigger a use-after-free vulnerability leading to privilege escalation.


    In the io_prep_async_work function the assumption that the last io_grab_identity
    call cannot return false is not true, and in this case the function will use the
    init_cred or the previous linked requests identity to do operations instead of
    using the current identity. This can lead to reference counting issues causing
    use-after-free. We recommend upgrading past version 5.10.161.'
- diff_content:
  - "--- a/sound/core/control.c\n+++ b/sound/core/control.c\n@@ -1203,14 +1203,19\
    \ @@ static int snd_ctl_elem_read(struct snd_card *card,\n \tconst u32 pattern\
    \ = 0xdeadbeef;\n \tint ret;\n \n+\tdown_read(&card->controls_rwsem);\n \tkctl\
    \ = snd_ctl_find_id(card, &control->id);\n-\tif (kctl == NULL)\n-\t\treturn -ENOENT;\n\
    +\tif (kctl == NULL) {\n+\t\tret = -ENOENT;\n+\t\tgoto unlock;\n+\t}\n \n \tindex_offset\
    \ = snd_ctl_get_ioff(kctl, &control->id);\n \tvd = &kctl->vd[index_offset];\n\
    -\tif (!(vd->access & SNDRV_CTL_ELEM_ACCESS_READ) || kctl->get == NULL)\n-\t\t\
    return -EPERM;\n+\tif (!(vd->access & SNDRV_CTL_ELEM_ACCESS_READ) || kctl->get\
    \ == NULL) {\n+\t\tret = -EPERM;\n+\t\tgoto unlock;\n+\t}\n \n \tsnd_ctl_build_ioff(&control->id,\
    \ kctl, index_offset);\n \n@@ -1220,7 +1225,7 @@ static int snd_ctl_elem_read(struct\
    \ snd_card *card,\n \tinfo.id = control->id;\n \tret = __snd_ctl_elem_info(card,\
    \ kctl, &info, NULL);\n \tif (ret < 0)\n-\t\treturn ret;\n+\t\tgoto unlock;\n\
    \ #endif\n \n \tif (!snd_ctl_skip_validation(&info))\n@@ -1230,16 +1235,19 @@\
    \ static int snd_ctl_elem_read(struct snd_card *card,\n \t\tret = kctl->get(kctl,\
    \ control);\n \tsnd_power_unref(card);\n \tif (ret < 0)\n-\t\treturn ret;\n+\t\
    \tgoto unlock;\n \tif (!snd_ctl_skip_validation(&info) &&\n \t    sanity_check_elem_value(card,\
    \ control, &info, pattern) < 0) {\n \t\tdev_err(card->dev,\n \t\t\t\"control %i:%i:%i:%s:%i:\
    \ access overflow\\n\",\n \t\t\tcontrol->id.iface, control->id.device,\n \t\t\t\
    control->id.subdevice, control->id.name,\n \t\t\tcontrol->id.index);\n-\t\treturn\
    \ -EINVAL;\n+\t\tret = -EINVAL;\n+\t\tgoto unlock;\n \t}\n+unlock:\n+\tup_read(&card->controls_rwsem);\n\
    \ \treturn ret;\n }\n \n@@ -1253,9 +1261,7 @@ static int snd_ctl_elem_read_user(struct\
    \ snd_card *card,\n \tif (IS_ERR(control))\n \t\treturn PTR_ERR(control);\n \n\
    -\tdown_read(&card->controls_rwsem);\n \tresult = snd_ctl_elem_read(card, control);\n\
    -\tup_read(&card->controls_rwsem);\n \tif (result < 0)\n \t\tgoto error;\n "
  - "--- a/sound/core/control.c\n+++ b/sound/core/control.c\n@@ -881,24 +881,18 @@\
    \ static int snd_ctl_elem_read(struct snd_card *card,\n \tstruct snd_kcontrol\
    \ *kctl;\n \tstruct snd_kcontrol_volatile *vd;\n \tunsigned int index_offset;\n\
    -\tint result;\n \n-\tdown_read(&card->controls_rwsem);\n \tkctl = snd_ctl_find_id(card,\
    \ &control->id);\n-\tif (kctl == NULL) {\n-\t\tresult = -ENOENT;\n-\t} else {\n\
    -\t\tindex_offset = snd_ctl_get_ioff(kctl, &control->id);\n-\t\tvd = &kctl->vd[index_offset];\n\
    -\t\tif ((vd->access & SNDRV_CTL_ELEM_ACCESS_READ) &&\n-\t\t    kctl->get != NULL)\
    \ {\n-\t\t\tsnd_ctl_build_ioff(&control->id, kctl, index_offset);\n-\t\t\tresult\
    \ = kctl->get(kctl, control);\n-\t\t} else\n-\t\t\tresult = -EPERM;\n-\t}\n-\t\
    up_read(&card->controls_rwsem);\n-\treturn result;\n+\tif (kctl == NULL)\n+\t\t\
    return -ENOENT;\n+\n+\tindex_offset = snd_ctl_get_ioff(kctl, &control->id);\n\
    +\tvd = &kctl->vd[index_offset];\n+\tif (!(vd->access & SNDRV_CTL_ELEM_ACCESS_READ)\
    \ && kctl->get == NULL)\n+\t\treturn -EPERM;\n+\n+\tsnd_ctl_build_ioff(&control->id,\
    \ kctl, index_offset);\n+\treturn kctl->get(kctl, control);\n }\n \n static int\
    \ snd_ctl_elem_read_user(struct snd_card *card,\n@@ -913,8 +907,11 @@ static int\
    \ snd_ctl_elem_read_user(struct snd_card *card,\n \n \tsnd_power_lock(card);\n\
    \ \tresult = snd_power_wait(card, SNDRV_CTL_POWER_D0);\n-\tif (result >= 0)\n\
    +\tif (result >= 0) {\n+\t\tdown_read(&card->controls_rwsem);\n \t\tresult = snd_ctl_elem_read(card,\
    \ control);\n+\t\tup_read(&card->controls_rwsem);\n+\t}\n \tsnd_power_unlock(card);\n\
    \ \tif (result >= 0)\n \t\tif (copy_to_user(_control, control, sizeof(*control)))\n\
    @@ -931,29 +928,28 @@ static int snd_ctl_elem_write(struct snd_card *card, struct\
    \ snd_ctl_file *file,\n \tunsigned int index_offset;\n \tint result;\n \n-\tdown_read(&card->controls_rwsem);\n\
    \ \tkctl = snd_ctl_find_id(card, &control->id);\n-\tif (kctl == NULL) {\n-\t\t\
    result = -ENOENT;\n-\t} else {\n-\t\tindex_offset = snd_ctl_get_ioff(kctl, &control->id);\n\
    -\t\tvd = &kctl->vd[index_offset];\n-\t\tif (!(vd->access & SNDRV_CTL_ELEM_ACCESS_WRITE)\
    \ ||\n-\t\t    kctl->put == NULL ||\n-\t\t    (file && vd->owner && vd->owner\
    \ != file)) {\n-\t\t\tresult = -EPERM;\n-\t\t} else {\n-\t\t\tsnd_ctl_build_ioff(&control->id,\
    \ kctl, index_offset);\n-\t\t\tresult = kctl->put(kctl, control);\n-\t\t}\n-\t\
    \tif (result > 0) {\n-\t\t\tstruct snd_ctl_elem_id id = control->id;\n-\t\t\t\
    snd_ctl_notify(card, SNDRV_CTL_EVENT_MASK_VALUE, &id);\n-\t\t\tresult = 0;\n-\t\
    \t}\n+\tif (kctl == NULL)\n+\t\treturn -ENOENT;\n+\n+\tindex_offset = snd_ctl_get_ioff(kctl,\
    \ &control->id);\n+\tvd = &kctl->vd[index_offset];\n+\tif (!(vd->access & SNDRV_CTL_ELEM_ACCESS_WRITE)\
    \ || kctl->put == NULL ||\n+\t    (file && vd->owner && vd->owner != file)) {\n\
    +\t\treturn -EPERM;\n \t}\n-\tup_read(&card->controls_rwsem);\n-\treturn result;\n\
    +\n+\tsnd_ctl_build_ioff(&control->id, kctl, index_offset);\n+\tresult = kctl->put(kctl,\
    \ control);\n+\tif (result < 0)\n+\t\treturn result;\n+\n+\tif (result > 0) {\n\
    +\t\tstruct snd_ctl_elem_id id = control->id;\n+\t\tsnd_ctl_notify(card, SNDRV_CTL_EVENT_MASK_VALUE,\
    \ &id);\n+\t}\n+\n+\treturn 0;\n }\n \n static int snd_ctl_elem_write_user(struct\
    \ snd_ctl_file *file,\n@@ -970,8 +966,11 @@ static int snd_ctl_elem_write_user(struct\
    \ snd_ctl_file *file,\n \tcard = file->card;\n \tsnd_power_lock(card);\n \tresult\
    \ = snd_power_wait(card, SNDRV_CTL_POWER_D0);\n-\tif (result >= 0)\n+\tif (result\
    \ >= 0) {\n+\t\tdown_read(&card->controls_rwsem);\n \t\tresult = snd_ctl_elem_write(card,\
    \ file, control);\n+\t\tup_read(&card->controls_rwsem);\n+\t}\n \tsnd_power_unlock(card);\n\
    \ \tif (result >= 0)\n \t\tif (copy_to_user(_control, control, sizeof(*control)))"
  identifiers:
  - CVE-2023-0266
  - CWE-416
  overview: "A use after free vulnerability exists in the ALSA PCM package in the\
    \ Linux Kernel.\_SNDRV_CTL_IOCTL_ELEM_{READ|WRITE}32 is missing locks that can\
    \ be used in a use-after-free that can result in a priviledge escalation to gain\
    \ ring0 access from the system user. We recommend upgrading past commit\_56b88b50565cd8b946a2d00b0c83927b7ebb055e\n"
  references:
  - source: cve-coordination@google.com
    tags:
    - Mailing List
    - Patch
    - Vendor Advisory
    url: https://git.kernel.org/pub/scm/linux/kernel/git/stable/stable-queue.git/tree/queue-5.10/alsa-pcm-move-rwsem-lock-inside-snd_ctl_elem_read-to-prevent-uaf.patch?id=72783cf35e6c55bca84c4bb7b776c58152856fd4
  - source: cve-coordination@google.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/torvalds/linux/commit/56b88b50565cd8b946a2d00b0c83927b7ebb055e
  - source: cve-coordination@google.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/torvalds/linux/commit/becf9e5d553c2389d857a3c178ce80fdb34a02e1
  - source: cve-coordination@google.com
    tags:
    - Mailing List
    - Third Party Advisory
    url: https://lists.debian.org/debian-lts-announce/2023/05/msg00006.html
  title: "A use after free vulnerability exists in the ALSA PCM package in the Linux\
    \ Kernel.\_SNDRV_CTL_IOCTL_ELEM_{READ|WRITE}32 is missing locks that can be used\
    \ in a use-after-free that can result in a priviledge escalation to gain ring0\
    \ access from the system user. We recommend upgrading past commit\_56b88b50565cd8b946a2d00b0c83927b7ebb055e\n"
- diff_content:
  - "--- a/src/move.c\n+++ b/src/move.c\n@@ -1933,6 +1933,9 @@ adjust_skipcol(void)\n\
    \ \treturn;\n \n     int\t    width1 = curwin->w_width - curwin_col_off();\n+\
    \    if (width1 <= 0)\n+\treturn;  // no text will be displayed\n+\n     int\t\
    \    width2 = width1 + curwin_col_off2();\n     long    so = get_scrolloff_value();\n\
    \     int\t    scrolloff_cols = so == 0 ? 0 : width1 + (so - 1) * width2;"
  - "--- a/src/version.c\n+++ b/src/version.c\n@@ -695,6 +695,8 @@ static char *(features[])\
    \ =\n \n static int included_patches[] =\n {   /* Add new patch number below this\
    \ line */\n+/**/\n+    1247,\n /**/\n     1246,\n /**/"
  identifiers:
  - CVE-2023-0512
  - CWE-369
  overview: Divide By Zero in GitHub repository vim/vim prior to 9.0.1247.
  references:
  - source: security@huntr.dev
    url: http://seclists.org/fulldisclosure/2023/Mar/17
  - source: security@huntr.dev
    url: http://seclists.org/fulldisclosure/2023/Mar/18
  - source: security@huntr.dev
    url: http://seclists.org/fulldisclosure/2023/Mar/21
  - source: security@huntr.dev
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/vim/vim/commit/870219c58c0804bdc55419b2e455c06ac715a835
  - source: security@huntr.dev
    tags:
    - Exploit
    - Patch
    - Third Party Advisory
    url: https://huntr.dev/bounties/de83736a-1936-4872-830b-f1e9b0ad2a74
  - source: security@huntr.dev
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/IE44W6WMMREYCW3GJHPSYP7NK2VT5NY6/
  - source: security@huntr.dev
    url: https://support.apple.com/kb/HT213670
  - source: security@huntr.dev
    url: https://support.apple.com/kb/HT213675
  - source: security@huntr.dev
    url: https://support.apple.com/kb/HT213677
  title: Divide By Zero in GitHub repository vim/vim prior to 9.0.1247.
- diff_content:
  - "--- a/src/lib/ec_glob.c\n+++ b/src/lib/ec_glob.c\n@@ -57,6 +57,13 @@ static const\
    \ UT_icd ut_int_pair_icd = {sizeof(int_pair),NULL,NULL,NULL};\n     p += string_len;\
    \ \\\n } while(0)\n \n+/* safely add a char to a string then move the pointer\
    \ to the end */\n+#define ADD_CHAR(string, new_chr, end)  do {    \\\n+    if\
    \ (string + 1 >= end) \\\n+        return -1; \\\n+    *(string ++) = new_chr;\
    \ \\\n+} while(0)\n+\n #define PATTERN_MAX  4097\n /*\n  * Whether the string\
    \ matches the given glob pattern. Return 0 if successful, return -1 if a PCRE\n\
    @@ -131,8 +138,8 @@ int ec_glob(const char *pattern, const char *string)\n   \
    \      case '\\\\':      /* also skip the next one */\n             if (*(c+1)\
    \ != '\\0')\n             {\n-                *(p_pcre ++) = *(c++);\n-      \
    \          *(p_pcre ++) = *c;\n+                ADD_CHAR(p_pcre, *(c++), pcre_str_end);\n\
    +                ADD_CHAR(p_pcre, *c, pcre_str_end);\n             }\n       \
    \      else\n                 STRING_CAT(p_pcre, \"\\\\\\\\\", pcre_str_end);\n\
    @@ -208,18 +215,18 @@ int ec_glob(const char *pattern, const char *string)\n \
    \                ++ c;\n             }\n             else\n-                *(p_pcre\
    \ ++) = '[';\n+                STRING_CAT(p_pcre, \"[\", pcre_str_end);\n \n \
    \            break;\n \n         case ']':\n             is_in_bracket = 0;\n\
    -            *(p_pcre ++) = *c;\n+            ADD_CHAR(p_pcre, *c, pcre_str_end);\n\
    \             break;\n \n         case '-':\n             if (is_in_bracket) \
    \     /* in brackets, - indicates range */\n-                *(p_pcre ++) = *c;\n\
    +                ADD_CHAR(p_pcre, *c, pcre_str_end);\n             else\n    \
    \             STRING_CAT(p_pcre, \"\\\\-\", pcre_str_end);\n \n@@ -302,12 +309,12\
    \ @@ int ec_glob(const char *pattern, const char *string)\n             }\n \n\
    \             -- brace_level;\n-            *(p_pcre ++) = ')';\n+           \
    \ STRING_CAT(p_pcre, \")\", pcre_str_end);\n             break;\n \n         case\
    \ ',':\n             if (brace_level > 0)  /* , inside {...} */\n-           \
    \     *(p_pcre ++) = '|';\n+                STRING_CAT(p_pcre, \"|\", pcre_str_end);\n\
    \             else\n                 STRING_CAT(p_pcre, \"\\\\,\", pcre_str_end);\n\
    \             break;\n@@ -326,9 +333,9 @@ int ec_glob(const char *pattern, const\
    \ char *string)\n \n         default:\n             if (!isalnum(*c))\n-     \
    \           *(p_pcre ++) = '\\\\';\n+                STRING_CAT(p_pcre, \"\\\\\
    \", pcre_str_end);\n \n-            *(p_pcre ++) = *c;\n+            ADD_CHAR(p_pcre,\
    \ *c, pcre_str_end);\n         }\n     }\n "
  identifiers:
  - CVE-2023-0341
  - CWE-787
  overview: A stack buffer overflow exists in the ec_glob function of editorconfig-core-c
    before v0.12.6 which allowed an attacker to arbitrarily write to the stack and
    possibly allows remote code execution. editorconfig-core-c v0.12.6 resolved this
    vulnerability by bound checking all write operations over the p_pcre buffer.
  references:
  - source: security@ubuntu.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/editorconfig/editorconfig-core-c/commit/41281ea82fbf24b060a9f69b9c5369350fb0529e
  - source: security@ubuntu.com
    url: https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/ZCFE7DXWAAKDJPRKMXHCACKGKNV37IYZ/
  - source: security@ubuntu.com
    tags:
    - Exploit
    - Patch
    - Third Party Advisory
    url: https://litios.github.io/2023/01/14/CVE-2023-0341.html
  - source: security@ubuntu.com
    url: https://ubuntu.com/security/notices/USN-5842-1
  title: A stack buffer overflow exists in the ec_glob function of editorconfig-core-c
    before v0.12.6 which allowed an attacker to arbitrarily write to the stack and
    possibly allows remote code execution. editorconfig-core-c v0.12.6 resolved this
    vulnerability by bound checking all write operations over the p_pcre buffer.
- diff_content:
  - "--- a/src/lib/certmap/sss_certmap.c\n+++ b/src/lib/certmap/sss_certmap.c\n@@\
    \ -441,10 +441,12 @@ static int expand_san(struct sss_certmap_ctx *ctx,\n static\
    \ int expand_template(struct sss_certmap_ctx *ctx,\n                         \
    \   struct parsed_template *parsed_template,\n                            struct\
    \ sss_cert_content *cert_content,\n+                           bool sanitize,\n\
    \                            char **expanded)\n {\n     int ret;\n     char *exp\
    \ = NULL;\n+    char *exp_sanitized = NULL;\n \n     if (strcmp(\"issuer_dn\"\
    , parsed_template->name) == 0) {\n         ret = rdn_list_2_dn_str(ctx, parsed_template->conversion,\n\
    @@ -455,6 +457,8 @@ static int expand_template(struct sss_certmap_ctx *ctx,\n\
    \     } else if (strncmp(\"subject_\", parsed_template->name, 8) == 0) {\n   \
    \      ret = expand_san(ctx, parsed_template, cert_content->san_list, &exp);\n\
    \     } else if (strcmp(\"cert\", parsed_template->name) == 0) {\n+        /*\
    \ cert blob is already sanitized */\n+        sanitize = false;\n         ret\
    \ = expand_cert(ctx, parsed_template, cert_content, &exp);\n     } else {\n  \
    \       CM_DEBUG(ctx, \"Unsupported template name.\");\n@@ -471,6 +475,16 @@ static\
    \ int expand_template(struct sss_certmap_ctx *ctx,\n         goto done;\n    \
    \ }\n \n+    if (sanitize) {\n+        ret = sss_filter_sanitize(ctx, exp, &exp_sanitized);\n\
    +        if (ret != EOK) {\n+            CM_DEBUG(ctx, \"Failed to sanitize expanded\
    \ template.\");\n+            goto done;\n+        }\n+        talloc_free(exp);\n\
    +        exp = exp_sanitized;\n+    }\n+\n     ret = 0;\n \n done:\n@@ -485,7\
    \ +499,7 @@ static int expand_template(struct sss_certmap_ctx *ctx,\n \n static\
    \ int get_filter(struct sss_certmap_ctx *ctx,\n                       struct ldap_mapping_rule\
    \ *parsed_mapping_rule,\n-                      struct sss_cert_content *cert_content,\n\
    +                      struct sss_cert_content *cert_content, bool sanitize,\n\
    \                       char **filter)\n {\n     struct ldap_mapping_rule_comp\
    \ *comp;\n@@ -503,7 +517,7 @@ static int get_filter(struct sss_certmap_ctx *ctx,\n\
    \             result = talloc_strdup_append(result, comp->val);\n         } else\
    \ if (comp->type == comp_template) {\n             ret = expand_template(ctx,\
    \ comp->parsed_template, cert_content,\n-                                  &expanded);\n\
    +                                  sanitize, &expanded);\n             if (ret\
    \ != 0) {\n                 CM_DEBUG(ctx, \"Failed to expanded template.\");\n\
    \                 goto done;\n@@ -791,8 +805,9 @@ int sss_certmap_match_cert(struct\
    \ sss_certmap_ctx *ctx,\n     return ret;\n }\n \n-int sss_certmap_get_search_filter(struct\
    \ sss_certmap_ctx *ctx,\n+static int expand_mapping_rule_ex(struct sss_certmap_ctx\
    \ *ctx,\n                                   const uint8_t *der_cert, size_t der_size,\n\
    +                                  bool sanitize,\n                          \
    \         char **_filter, char ***_domains)\n {\n     int ret;\n@@ -819,7 +834,8\
    \ @@ int sss_certmap_get_search_filter(struct sss_certmap_ctx *ctx,\n        \
    \     return EINVAL;\n         }\n \n-        ret = get_filter(ctx, ctx->default_mapping_rule,\
    \ cert_content, &filter);\n+        ret = get_filter(ctx, ctx->default_mapping_rule,\
    \ cert_content, sanitize,\n+                         &filter);\n         goto\
    \ done;\n     }\n \n@@ -829,7 +845,7 @@ int sss_certmap_get_search_filter(struct\
    \ sss_certmap_ctx *ctx,\n             if (ret == 0) {\n                 /* match\
    \ */\n                 ret = get_filter(ctx, r->parsed_mapping_rule, cert_content,\n\
    -                                 &filter);\n+                               \
    \  sanitize, &filter);\n                 if (ret != 0) {\n                   \
    \  CM_DEBUG(ctx, \"Failed to get filter\");\n                     goto done;\n\
    @@ -873,6 +889,22 @@ int sss_certmap_get_search_filter(struct sss_certmap_ctx\
    \ *ctx,\n     return ret;\n }\n \n+int sss_certmap_get_search_filter(struct sss_certmap_ctx\
    \ *ctx,\n+                                  const uint8_t *der_cert, size_t der_size,\n\
    +                                  char **_filter, char ***_domains)\n+{\n+  \
    \  return expand_mapping_rule_ex(ctx, der_cert, der_size, true,\n+           \
    \                       _filter, _domains);\n+}\n+\n+int sss_certmap_expand_mapping_rule(struct\
    \ sss_certmap_ctx *ctx,\n+                                    const uint8_t *der_cert,\
    \ size_t der_size,\n+                                    char **_expanded, char\
    \ ***_domains)\n+{\n+    return expand_mapping_rule_ex(ctx, der_cert, der_size,\
    \ false,\n+                                  _expanded, _domains);\n+}\n+\n int\
    \ sss_certmap_init(TALLOC_CTX *mem_ctx,\n                      sss_certmap_ext_debug\
    \ *debug, void *debug_priv,\n                      struct sss_certmap_ctx **ctx)"
  - "--- a/src/responder/pam/pamsrv_p11.c\n+++ b/src/responder/pam/pamsrv_p11.c\n\
    @@ -1049,9 +1049,10 @@ static char *get_cert_prompt(TALLOC_CTX *mem_ctx,\n   \
    \      goto done;\n     }\n \n-    ret = sss_certmap_get_search_filter(ctx, der,\
    \ der_size, &filter, &domains);\n+    ret = sss_certmap_expand_mapping_rule(ctx,\
    \ der, der_size,\n+                                          &filter, &domains);\n\
    \     if (ret != 0) {\n-        DEBUG(SSSDBG_OP_FAILURE, \"sss_certmap_get_search_filter\
    \ failed.\\n\");\n+        DEBUG(SSSDBG_OP_FAILURE, \"sss_certmap_expand_mapping_rule\
    \ failed.\\n\");\n         goto done;\n     }\n "
  - "--- a/src/tests/cmocka/test_certmap.c\n+++ b/src/tests/cmocka/test_certmap.c\n\
    @@ -1431,6 +1431,15 @@ static void test_sss_certmap_get_search_filter(void **state)\n\
    \                                         &filter, &domains);\n     assert_int_equal(ret,\
    \ 0);\n     assert_non_null(filter);\n+    assert_string_equal(filter, \"rule100=<I>CN=Certificate\\\
    \\20Authority,O=IPA.DEVEL\"\n+                                \"<S>CN=ipa-devel.ipa.devel,O=IPA.DEVEL\"\
    );\n+    assert_null(domains);\n+\n+    ret = sss_certmap_expand_mapping_rule(ctx,\
    \ discard_const(test_cert_der),\n+                                          sizeof(test_cert_der),\n\
    +                                          &filter, &domains);\n+    assert_int_equal(ret,\
    \ 0);\n+    assert_non_null(filter);\n     assert_string_equal(filter, \"rule100=<I>CN=Certificate\
    \ Authority,O=IPA.DEVEL\"\n                                 \"<S>CN=ipa-devel.ipa.devel,O=IPA.DEVEL\"\
    );\n     assert_null(domains);\n@@ -1445,6 +1454,17 @@ static void test_sss_certmap_get_search_filter(void\
    \ **state)\n                                         &filter, &domains);\n   \
    \  assert_int_equal(ret, 0);\n     assert_non_null(filter);\n+    assert_string_equal(filter,\
    \ \"rule99=<I>CN=Certificate\\\\20Authority,O=IPA.DEVEL\"\n+                 \
    \               \"<S>CN=ipa-devel.ipa.devel,O=IPA.DEVEL\");\n+    assert_non_null(domains);\n\
    +    assert_string_equal(domains[0], \"test.dom\");\n+    assert_null(domains[1]);\n\
    +\n+    ret = sss_certmap_expand_mapping_rule(ctx, discard_const(test_cert_der),\n\
    +                                          sizeof(test_cert_der),\n+         \
    \                                 &filter, &domains);\n+    assert_int_equal(ret,\
    \ 0);\n+    assert_non_null(filter);\n     assert_string_equal(filter, \"rule99=<I>CN=Certificate\
    \ Authority,O=IPA.DEVEL\"\n                                 \"<S>CN=ipa-devel.ipa.devel,O=IPA.DEVEL\"\
    );\n     assert_non_null(domains);\n@@ -1466,6 +1486,16 @@ static void test_sss_certmap_get_search_filter(void\
    \ **state)\n     assert_string_equal(domains[0], \"test.dom\");\n     assert_null(domains[1]);\n\
    \ \n+    ret = sss_certmap_expand_mapping_rule(ctx, discard_const(test_cert_der),\n\
    +                                          sizeof(test_cert_der),\n+         \
    \                                 &filter, &domains);\n+    assert_int_equal(ret,\
    \ 0);\n+    assert_non_null(filter);\n+    assert_string_equal(filter, \"rule98=userCertificate;binary=\"\
    \ TEST_CERT_BIN);\n+    assert_non_null(domains);\n+    assert_string_equal(domains[0],\
    \ \"test.dom\");\n+    assert_null(domains[1]);\n+\n     ret = sss_certmap_add_rule(ctx,\
    \ 97,\n                             \"KRB5:<ISSUER>CN=Certificate Authority,O=IPA.DEVEL\"\
    ,\n                             \"LDAP:rule97=<I>{issuer_dn!nss_x500}<S>{subject_dn}\"\
    ,\n@@ -1476,6 +1506,17 @@ static void test_sss_certmap_get_search_filter(void\
    \ **state)\n                                         &filter, &domains);\n   \
    \  assert_int_equal(ret, 0);\n     assert_non_null(filter);\n+    assert_string_equal(filter,\
    \ \"rule97=<I>O=IPA.DEVEL,CN=Certificate\\\\20Authority\"\n+                 \
    \               \"<S>CN=ipa-devel.ipa.devel,O=IPA.DEVEL\");\n+    assert_non_null(domains);\n\
    +    assert_string_equal(domains[0], \"test.dom\");\n+    assert_null(domains[1]);\n\
    +\n+    ret = sss_certmap_expand_mapping_rule(ctx, discard_const(test_cert_der),\n\
    +                                          sizeof(test_cert_der),\n+         \
    \                                 &filter, &domains);\n+    assert_int_equal(ret,\
    \ 0);\n+    assert_non_null(filter);\n     assert_string_equal(filter, \"rule97=<I>O=IPA.DEVEL,CN=Certificate\
    \ Authority\"\n                                 \"<S>CN=ipa-devel.ipa.devel,O=IPA.DEVEL\"\
    );\n     assert_non_null(domains);\n@@ -1492,6 +1533,17 @@ static void test_sss_certmap_get_search_filter(void\
    \ **state)\n                                         &filter, &domains);\n   \
    \  assert_int_equal(ret, 0);\n     assert_non_null(filter);\n+    assert_string_equal(filter,\
    \ \"rule96=<I>O=IPA.DEVEL,CN=Certificate\\\\20Authority\"\n+                 \
    \               \"<S>O=IPA.DEVEL,CN=ipa-devel.ipa.devel\");\n+    assert_non_null(domains);\n\
    +    assert_string_equal(domains[0], \"test.dom\");\n+    assert_null(domains[1]);\n\
    +\n+    ret = sss_certmap_expand_mapping_rule(ctx, discard_const(test_cert_der),\n\
    +                                          sizeof(test_cert_der),\n+         \
    \                                 &filter, &domains);\n+    assert_int_equal(ret,\
    \ 0);\n+    assert_non_null(filter);\n     assert_string_equal(filter, \"rule96=<I>O=IPA.DEVEL,CN=Certificate\
    \ Authority\"\n                                 \"<S>O=IPA.DEVEL,CN=ipa-devel.ipa.devel\"\
    );\n     assert_non_null(domains);\n@@ -1510,6 +1562,14 @@ static void test_sss_certmap_get_search_filter(void\
    \ **state)\n     assert_string_equal(filter, \"(userCertificate;binary=\" TEST_CERT_BIN\
    \ \")\");\n     assert_null(domains);\n \n+    ret = sss_certmap_expand_mapping_rule(ctx,\
    \ discard_const(test_cert_der),\n+                                          sizeof(test_cert_der),\n\
    +                                          &filter, &domains);\n+    assert_int_equal(ret,\
    \ 0);\n+    assert_non_null(filter);\n+    assert_string_equal(filter, \"(userCertificate;binary=\"\
    \ TEST_CERT_BIN \")\");\n+    assert_null(domains);\n+\n     ret = sss_certmap_add_rule(ctx,\
    \ 94,\n                       \"KRB5:<ISSUER>CN=Certificate Authority,O=IPA.DEVEL\"\
    ,\n                       \"LDAP:rule94=<I>{issuer_dn!ad_x500}<S>{subject_dn!ad_x500}\"\
    ,\n@@ -1520,12 +1580,22 @@ static void test_sss_certmap_get_search_filter(void\
    \ **state)\n                                         &filter, &domains);\n   \
    \  assert_int_equal(ret, 0);\n     assert_non_null(filter);\n-    assert_string_equal(filter,\
    \ \"rule94=<I>O=IPA.DEVEL,CN=Certificate Authority\"\n+    assert_string_equal(filter,\
    \ \"rule94=<I>O=IPA.DEVEL,CN=Certificate\\\\20Authority\"\n                  \
    \               \"<S>O=IPA.DEVEL,CN=ipa-devel.ipa.devel\");\n     assert_non_null(domains);\n\
    \     assert_string_equal(domains[0], \"test.dom\");\n     assert_null(domains[1]);\n\
    \ \n+    ret = sss_certmap_expand_mapping_rule(ctx, discard_const(test_cert_der),\n\
    +                                          sizeof(test_cert_der),\n+         \
    \                                 &filter, &domains);\n+    assert_int_equal(ret,\
    \ 0);\n+    assert_non_null(filter);\n+    assert_string_equal(filter, \"rule94=<I>O=IPA.DEVEL,CN=Certificate\
    \ Authority\"\n+                                \"<S>O=IPA.DEVEL,CN=ipa-devel.ipa.devel\"\
    );\n+    assert_non_null(domains);\n+    assert_string_equal(domains[0], \"test.dom\"\
    );\n+    assert_null(domains[1]);\n \n     ret = sss_certmap_add_rule(ctx, 89,\
    \ NULL,\n                             \"(rule89={subject_nt_principal})\",\n@@\
    \ -1539,6 +1609,14 @@ static void test_sss_certmap_get_search_filter(void **state)\n\
    \     assert_string_equal(filter, \"(rule89=tu1@ad.devel)\");\n     assert_null(domains);\n\
    \ \n+    ret = sss_certmap_expand_mapping_rule(ctx, discard_const(test_cert2_der),\n\
    +                                          sizeof(test_cert2_der),\n+        \
    \                                  &filter, &domains);\n+    assert_int_equal(ret,\
    \ 0);\n+    assert_non_null(filter);\n+    assert_string_equal(filter, \"(rule89=tu1@ad.devel)\"\
    );\n+    assert_null(domains);\n+\n     ret = sss_certmap_add_rule(ctx, 88, NULL,\n\
    \                             \"(rule88={subject_nt_principal.short_name})\",\n\
    \                             NULL);\n@@ -1560,6 +1638,15 @@ static void test_sss_certmap_get_search_filter(void\
    \ **state)\n                                         &filter, &domains);\n   \
    \  assert_int_equal(ret, 0);\n     assert_non_null(filter);\n+    assert_string_equal(filter,\
    \ \"rule87=<I>DC=devel,DC=ad,CN=ad-AD-SERVER-CA\"\n+                  \"<S>DC=devel,DC=ad,CN=Users,CN=t\\\
    \\20u,E=test.user@email.domain\");\n+    assert_null(domains);\n+\n+    ret =\
    \ sss_certmap_expand_mapping_rule(ctx, discard_const(test_cert2_der),\n+     \
    \                                     sizeof(test_cert2_der),\n+             \
    \                             &filter, &domains);\n+    assert_int_equal(ret,\
    \ 0);\n+    assert_non_null(filter);\n     assert_string_equal(filter, \"rule87=<I>DC=devel,DC=ad,CN=ad-AD-SERVER-CA\"\
    \n                   \"<S>DC=devel,DC=ad,CN=Users,CN=t u,E=test.user@email.domain\"\
    );\n     assert_null(domains);\n@@ -1573,6 +1660,15 @@ static void test_sss_certmap_get_search_filter(void\
    \ **state)\n                                         &filter, &domains);\n   \
    \  assert_int_equal(ret, 0);\n     assert_non_null(filter);\n+    assert_string_equal(filter,\
    \ \"rule86=<I>DC=devel,DC=ad,CN=ad-AD-SERVER-CA\"\n+                  \"<S>DC=devel,DC=ad,CN=Users,CN=t\\\
    \\20u,E=test.user@email.domain\");\n+    assert_null(domains);\n+\n+    ret =\
    \ sss_certmap_expand_mapping_rule(ctx, discard_const(test_cert2_der),\n+     \
    \                                     sizeof(test_cert2_der),\n+             \
    \                             &filter, &domains);\n+    assert_int_equal(ret,\
    \ 0);\n+    assert_non_null(filter);\n     assert_string_equal(filter, \"rule86=<I>DC=devel,DC=ad,CN=ad-AD-SERVER-CA\"\
    \n                   \"<S>DC=devel,DC=ad,CN=Users,CN=t u,E=test.user@email.domain\"\
    );\n     assert_null(domains);"
  - "--- a/src/util/util.c\n+++ b/src/util/util.c\n@@ -436,100 +436,6 @@ errno_t sss_hash_create(TALLOC_CTX\
    \ *mem_ctx, unsigned long count,\n     return sss_hash_create_ex(mem_ctx, count,\
    \ tbl, 0, 0, 0, 0, NULL, NULL);\n }\n \n-errno_t sss_filter_sanitize_ex(TALLOC_CTX\
    \ *mem_ctx,\n-                               const char *input,\n-           \
    \                    char **sanitized,\n-                               const\
    \ char *ignore)\n-{\n-    char *output;\n-    size_t i = 0;\n-    size_t j = 0;\n\
    -    char *allowed;\n-\n-    /* Assume the worst-case. We'll resize it later,\
    \ once */\n-    output = talloc_array(mem_ctx, char, strlen(input) * 3 + 1);\n\
    -    if (!output) {\n-        return ENOMEM;\n-    }\n-\n-    while (input[i])\
    \ {\n-        /* Even though this character might have a special meaning, if it's\n\
    -         * explicitly allowed, just copy it and move on\n-         */\n-    \
    \    if (ignore == NULL) {\n-            allowed = NULL;\n-        } else {\n\
    -            allowed = strchr(ignore, input[i]);\n-        }\n-        if (allowed)\
    \ {\n-            output[j++] = input[i++];\n-            continue;\n-       \
    \ }\n-\n-        switch(input[i]) {\n-        case '\\t':\n-            output[j++]\
    \ = '\\\\';\n-            output[j++] = '0';\n-            output[j++] = '9';\n\
    -            break;\n-        case ' ':\n-            output[j++] = '\\\\';\n\
    -            output[j++] = '2';\n-            output[j++] = '0';\n-          \
    \  break;\n-        case '*':\n-            output[j++] = '\\\\';\n-         \
    \   output[j++] = '2';\n-            output[j++] = 'a';\n-            break;\n\
    -        case '(':\n-            output[j++] = '\\\\';\n-            output[j++]\
    \ = '2';\n-            output[j++] = '8';\n-            break;\n-        case\
    \ ')':\n-            output[j++] = '\\\\';\n-            output[j++] = '2';\n\
    -            output[j++] = '9';\n-            break;\n-        case '\\\\':\n\
    -            output[j++] = '\\\\';\n-            output[j++] = '5';\n-       \
    \     output[j++] = 'c';\n-            break;\n-        case '\\r':\n-       \
    \     output[j++] = '\\\\';\n-            output[j++] = '0';\n-            output[j++]\
    \ = 'd';\n-            break;\n-        case '\\n':\n-            output[j++]\
    \ = '\\\\';\n-            output[j++] = '0';\n-            output[j++] = 'a';\n\
    -            break;\n-        default:\n-            output[j++] = input[i];\n\
    -        }\n-\n-        i++;\n-    }\n-    output[j] = '\\0';\n-    *sanitized\
    \ = talloc_realloc(mem_ctx, output, char, j+1);\n-    if (!*sanitized) {\n-  \
    \      talloc_free(output);\n-        return ENOMEM;\n-    }\n-\n-    return EOK;\n\
    -}\n-\n-errno_t sss_filter_sanitize(TALLOC_CTX *mem_ctx,\n-                  \
    \          const char *input,\n-                            char **sanitized)\n\
    -{\n-    return sss_filter_sanitize_ex(mem_ctx, input, sanitized, NULL);\n-}\n\
    -\n char *\n sss_escape_ip_address(TALLOC_CTX *mem_ctx, int family, const char\
    \ *addr)\n {"
  - "--- a/src/util/util_ext.c\n+++ b/src/util/util_ext.c\n@@ -29,6 +29,11 @@\n \n\
    \ #define EOK 0\n \n+#ifndef HAVE_ERRNO_T\n+#define HAVE_ERRNO_T\n+typedef int\
    \ errno_t;\n+#endif\n+\n int split_on_separator(TALLOC_CTX *mem_ctx, const char\
    \ *str,\n                        const char sep, bool trim, bool skip_empty,\n\
    \                        char ***_list, int *size)\n@@ -141,3 +146,97 @@ bool\
    \ string_in_list(const char *string, char **list, bool case_sensitive)\n \n  \
    \   return false;\n }\n+\n+errno_t sss_filter_sanitize_ex(TALLOC_CTX *mem_ctx,\n\
    +                               const char *input,\n+                        \
    \       char **sanitized,\n+                               const char *ignore)\n\
    +{\n+    char *output;\n+    size_t i = 0;\n+    size_t j = 0;\n+    char *allowed;\n\
    +\n+    /* Assume the worst-case. We'll resize it later, once */\n+    output\
    \ = talloc_array(mem_ctx, char, strlen(input) * 3 + 1);\n+    if (!output) {\n\
    +        return ENOMEM;\n+    }\n+\n+    while (input[i]) {\n+        /* Even\
    \ though this character might have a special meaning, if it's\n+         * explicitly\
    \ allowed, just copy it and move on\n+         */\n+        if (ignore == NULL)\
    \ {\n+            allowed = NULL;\n+        } else {\n+            allowed = strchr(ignore,\
    \ input[i]);\n+        }\n+        if (allowed) {\n+            output[j++] =\
    \ input[i++];\n+            continue;\n+        }\n+\n+        switch(input[i])\
    \ {\n+        case '\\t':\n+            output[j++] = '\\\\';\n+            output[j++]\
    \ = '0';\n+            output[j++] = '9';\n+            break;\n+        case\
    \ ' ':\n+            output[j++] = '\\\\';\n+            output[j++] = '2';\n\
    +            output[j++] = '0';\n+            break;\n+        case '*':\n+  \
    \          output[j++] = '\\\\';\n+            output[j++] = '2';\n+         \
    \   output[j++] = 'a';\n+            break;\n+        case '(':\n+           \
    \ output[j++] = '\\\\';\n+            output[j++] = '2';\n+            output[j++]\
    \ = '8';\n+            break;\n+        case ')':\n+            output[j++] =\
    \ '\\\\';\n+            output[j++] = '2';\n+            output[j++] = '9';\n\
    +            break;\n+        case '\\\\':\n+            output[j++] = '\\\\';\n\
    +            output[j++] = '5';\n+            output[j++] = 'c';\n+          \
    \  break;\n+        case '\\r':\n+            output[j++] = '\\\\';\n+       \
    \     output[j++] = '0';\n+            output[j++] = 'd';\n+            break;\n\
    +        case '\\n':\n+            output[j++] = '\\\\';\n+            output[j++]\
    \ = '0';\n+            output[j++] = 'a';\n+            break;\n+        default:\n\
    +            output[j++] = input[i];\n+        }\n+\n+        i++;\n+    }\n+\
    \    output[j] = '\\0';\n+    *sanitized = talloc_realloc(mem_ctx, output, char,\
    \ j+1);\n+    if (!*sanitized) {\n+        talloc_free(output);\n+        return\
    \ ENOMEM;\n+    }\n+\n+    return EOK;\n+}\n+\n+errno_t sss_filter_sanitize(TALLOC_CTX\
    \ *mem_ctx,\n+                            const char *input,\n+              \
    \              char **sanitized)\n+{\n+    return sss_filter_sanitize_ex(mem_ctx,\
    \ input, sanitized, NULL);\n+}"
  identifiers:
  - CVE-2022-4254
  - CWE-90
  overview: 'sssd: libsss_certmap fails to sanitise certificate data used in LDAP
    filters'
  references:
  - source: secalert@redhat.com
    tags:
    - Third Party Advisory
    url: https://access.redhat.com/security/cve/CVE-2022-4254
  - source: secalert@redhat.com
    tags:
    - Exploit
    - Issue Tracking
    - Patch
    - Third Party Advisory
    url: https://bugzilla.redhat.com/show_bug.cgi?id=2149894
  - source: secalert@redhat.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/SSSD/sssd/commit/a2b9a84460429181f2a4fa7e2bb5ab49fd561274
  - source: secalert@redhat.com
    tags:
    - Exploit
    - Issue Tracking
    - Patch
    - Third Party Advisory
    url: https://github.com/SSSD/sssd/issues/5135
  - source: secalert@redhat.com
    url: https://lists.debian.org/debian-lts-announce/2023/05/msg00028.html
  title: 'sssd: libsss_certmap fails to sanitise certificate data used in LDAP filters'
- diff_content:
  - "--- a/compat.c\n+++ b/compat.c\n@@ -1,4 +1,4 @@\n-/* $OpenBSD: compat.c,v 1.119\
    \ 2021/09/10 05:46:09 djm Exp $ */\n+/* $OpenBSD: compat.c,v 1.120 2022/07/01\
    \ 03:35:45 dtucker Exp $ */\n /*\n  * Copyright (c) 1999, 2000, 2001, 2002 Markus\
    \ Friedl.  All rights reserved.\n  *\n@@ -156,11 +156,12 @@ compat_banner(struct\
    \ ssh *ssh, const char *version)\n \tdebug_f(\"no match: %s\", version);\n }\n\
    \ \n+/* Always returns pointer to allocated memory, caller must free. */\n char\
    \ *\n compat_cipher_proposal(struct ssh *ssh, char *cipher_prop)\n {\n \tif (!(ssh->compat\
    \ & SSH_BUG_BIGENDIANAES))\n-\t\treturn cipher_prop;\n+\t\treturn xstrdup(cipher_prop);\n\
    \ \tdebug2_f(\"original cipher proposal: %s\", cipher_prop);\n \tif ((cipher_prop\
    \ = match_filter_denylist(cipher_prop, \"aes*\")) == NULL)\n \t\tfatal(\"match_filter_denylist\
    \ failed\");\n@@ -170,11 +171,12 @@ compat_cipher_proposal(struct ssh *ssh, char\
    \ *cipher_prop)\n \treturn cipher_prop;\n }\n \n+/* Always returns pointer to\
    \ allocated memory, caller must free. */\n char *\n compat_pkalg_proposal(struct\
    \ ssh *ssh, char *pkalg_prop)\n {\n \tif (!(ssh->compat & SSH_BUG_RSASIGMD5))\n\
    -\t\treturn pkalg_prop;\n+\t\treturn xstrdup(pkalg_prop);\n \tdebug2_f(\"original\
    \ public key proposal: %s\", pkalg_prop);\n \tif ((pkalg_prop = match_filter_denylist(pkalg_prop,\
    \ \"ssh-rsa\")) == NULL)\n \t\tfatal(\"match_filter_denylist failed\");\n@@ -184,21\
    \ +186,26 @@ compat_pkalg_proposal(struct ssh *ssh, char *pkalg_prop)\n \treturn\
    \ pkalg_prop;\n }\n \n+/* Always returns pointer to allocated memory, caller must\
    \ free. */\n char *\n compat_kex_proposal(struct ssh *ssh, char *p)\n {\n+\tchar\
    \ *cp = NULL;\n+\n \tif ((ssh->compat & (SSH_BUG_CURVE25519PAD|SSH_OLD_DHGEX))\
    \ == 0)\n-\t\treturn p;\n+\t\treturn xstrdup(p);\n \tdebug2_f(\"original KEX proposal:\
    \ %s\", p);\n \tif ((ssh->compat & SSH_BUG_CURVE25519PAD) != 0)\n \t\tif ((p =\
    \ match_filter_denylist(p,\n \t\t    \"curve25519-sha256@libssh.org\")) == NULL)\n\
    \ \t\t\tfatal(\"match_filter_denylist failed\");\n \tif ((ssh->compat & SSH_OLD_DHGEX)\
    \ != 0) {\n+\t\tcp = p;\n \t\tif ((p = match_filter_denylist(p,\n \t\t    \"diffie-hellman-group-exchange-sha256,\"\
    \n \t\t    \"diffie-hellman-group-exchange-sha1\")) == NULL)\n \t\t\tfatal(\"\
    match_filter_denylist failed\");\n+\t\tfree(cp);\n \t}\n \tdebug2_f(\"compat KEX\
    \ proposal: %s\", p);\n \tif (*p == '\\0')"
  identifiers:
  - CVE-2023-25136
  - CWE-415
  overview: OpenSSH server (sshd) 9.1 introduced a double-free vulnerability during
    options.kex_algorithms handling. This is fixed in OpenSSH 9.2. The double free
    can be leveraged, by an unauthenticated remote attacker in the default configuration,
    to jump to any location in the sshd address space. One third-party report states
    "remote code execution is theoretically possible."
  references:
  - source: cve@mitre.org
    tags:
    - Mailing List
    - Third Party Advisory
    url: http://www.openwall.com/lists/oss-security/2023/02/13/1
  - source: cve@mitre.org
    tags:
    - Mailing List
    - Third Party Advisory
    url: http://www.openwall.com/lists/oss-security/2023/02/22/1
  - source: cve@mitre.org
    tags:
    - Mailing List
    - Third Party Advisory
    url: http://www.openwall.com/lists/oss-security/2023/02/22/2
  - source: cve@mitre.org
    tags:
    - Mailing List
    - Third Party Advisory
    url: http://www.openwall.com/lists/oss-security/2023/02/23/3
  - source: cve@mitre.org
    tags:
    - Mailing List
    - Third Party Advisory
    url: http://www.openwall.com/lists/oss-security/2023/03/06/1
  - source: cve@mitre.org
    tags:
    - Mailing List
    - Third Party Advisory
    url: http://www.openwall.com/lists/oss-security/2023/03/09/2
  - source: cve@mitre.org
    tags:
    - Exploit
    - Issue Tracking
    - Third Party Advisory
    url: https://bugzilla.mindrot.org/show_bug.cgi?id=3522
  - source: cve@mitre.org
    tags:
    - Patch
    - Vendor Advisory
    url: https://ftp.openbsd.org/pub/OpenBSD/patches/7.2/common/017_sshd.patch.sig
  - source: cve@mitre.org
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/openssh/openssh-portable/commit/486c4dc3b83b4b67d663fb0fa62bc24138ec3946
  - source: cve@mitre.org
    tags:
    - Exploit
    - Third Party Advisory
    url: https://jfrog.com/blog/openssh-pre-auth-double-free-cve-2023-25136-writeup-and-proof-of-concept/
  - source: cve@mitre.org
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/JGAUIXJ3TEKCRKVWFQ6GDAGQFTIIGQQP/
  - source: cve@mitre.org
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/R7LKQDFZWKYHQ65TBSH2X2HJQ4V2THS3/
  - source: cve@mitre.org
    tags:
    - Issue Tracking
    - Third Party Advisory
    url: https://news.ycombinator.com/item?id=34711565
  - source: cve@mitre.org
    tags:
    - Third Party Advisory
    url: https://security.gentoo.org/glsa/202307-01
  - source: cve@mitre.org
    tags:
    - Third Party Advisory
    url: https://security.netapp.com/advisory/ntap-20230309-0003/
  - source: cve@mitre.org
    tags:
    - Exploit
    - Mailing List
    - Third Party Advisory
    url: https://www.openwall.com/lists/oss-security/2023/02/02/2
  title: OpenSSH server (sshd) 9.1 introduced a double-free vulnerability during options.kex_algorithms
    handling. This is fixed in OpenSSH 9.2. The double free can be leveraged, by an
    unauthenticated remote attacker in the default configuration, to jump to any location
    in the sshd address space. One third-party report states "remote code execution
    is theoretically possible."
- diff_content:
  - "--- a/xbmc/pictures/ExifParse.cpp\n+++ b/xbmc/pictures/ExifParse.cpp\n@@ -27,6\
    \ +27,7 @@\n #endif\n \n #include <math.h>\n+#include <stdint.h>\n #include <stdio.h>\n\
    \ \n #ifndef min\n@@ -376,7 +377,7 @@ void CExifParse::ProcessDir(const unsigned\
    \ char* const DirStart,\n       unsigned OffsetVal;\n       OffsetVal = (unsigned)Get32(DirEntry+8,\
    \ m_MotorolaOrder);\n       // If its bigger than 4 bytes, the dir entry contains\
    \ an offset.\n-      if (OffsetVal+ByteCount > ExifLength)\n+      if (OffsetVal\
    \ > UINT32_MAX - ByteCount || OffsetVal + ByteCount > ExifLength)\n       {\n\
    \         // Bogus pointer offset and / or bytecount value\n         ErrNonfatal(\"\
    Illegal value pointer for tag %04x\", Tag,0);\n@@ -787,10 +788,10 @@ bool CExifParse::Process\
    \ (const unsigned char* const ExifSection, const unsigned\n   pos += sizeof(short);\n\
    \ \n   unsigned long FirstOffset = (unsigned)Get32((const void*)pos, m_MotorolaOrder);\n\
    -  if (FirstOffset < 8 || FirstOffset > 16)\n+  if (FirstOffset < 8 || FirstOffset\
    \ + 8 >= length)\n   {\n-    // Usually set to 8, but other values valid too.\n\
    -//  CLog::Log(LOGERROR, \"ExifParse: suspicious offset of first IFD value\");\n\
    +    ErrNonfatal(\"Invalid offset of first IFD value: %u\", FirstOffset, 0);\n\
    +    return false;\n   }\n \n \n@@ -878,6 +879,13 @@ void CExifParse::ProcessGpsInfo(\n\
    \   {\n     const unsigned char* DirEntry = DIR_ENTRY_ADDR(DirStart, de);\n \n\
    +    // Fix from aosp 34a2564d3268a5ca1472c5076675782fbaf724d6\n+    if (DirEntry\
    \ + 12 > OffsetBase + ExifLength)\n+    {\n+      ErrNonfatal(\"GPS info directory\
    \ goes past end of exif\", 0, 0);\n+      return;\n+    }\n+\n     unsigned Tag\
    \        = Get16(DirEntry, m_MotorolaOrder);\n     unsigned Format     = Get16(DirEntry+2,\
    \ m_MotorolaOrder);\n     unsigned Components = (unsigned)Get32(DirEntry+4, m_MotorolaOrder);\n\
    @@ -896,7 +904,7 @@ void CExifParse::ProcessGpsInfo(\n     {\n       unsigned\
    \ OffsetVal = (unsigned)Get32(DirEntry+8, m_MotorolaOrder);\n       // If its\
    \ bigger than 4 bytes, the dir entry contains an offset.\n-      if (OffsetVal+ByteCount\
    \ > ExifLength)\n+      if (OffsetVal > UINT32_MAX - ByteCount || OffsetVal +\
    \ ByteCount > ExifLength)\n       {\n         // Bogus pointer offset and / or\
    \ bytecount value\n         ErrNonfatal(\"Illegal value pointer for tag %04x\"\
    , Tag,0);"
  identifiers:
  - CVE-2023-23082
  - CWE-787
  overview: A heap buffer overflow vulnerability in Kodi Home Theater Software up
    to 19.5 allows attackers to cause a denial of service due to an improper length
    of the value passed to the offset argument.
  references:
  - source: cve@mitre.org
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/xbmc/xbmc/commit/8c2aafb6d4987833803e037c923aaf83f9ff41e1
  - source: cve@mitre.org
    tags:
    - Exploit
    - Issue Tracking
    - Patch
    - Third Party Advisory
    url: https://github.com/xbmc/xbmc/issues/22377
  - source: cve@mitre.org
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/xbmc/xbmc/pull/22380
  - source: cve@mitre.org
    url: https://github.com/xbmc/xbmc/pull/22380/commits/00fec1dbdd1df827872c7b55ad93059636dfc076
  - source: cve@mitre.org
    url: https://github.com/xbmc/xbmc/pull/22380/commits/7e5f9fbf9aaa3540aab35e7504036855b23dcf60
  - source: cve@mitre.org
    url: https://lists.debian.org/debian-lts-announce/2024/01/msg00009.html
  title: A heap buffer overflow vulnerability in Kodi Home Theater Software up to
    19.5 allows attackers to cause a denial of service due to an improper length of
    the value passed to the offset argument.
- diff_content:
  - "--- a/pdfio-common.c\n+++ b/pdfio-common.c\n@@ -1,7 +1,7 @@\n //\n // Common\
    \ support functions for pdfio.\n //\n-// Copyright \xA9\_2021 by Michael R Sweet.\n\
    +// Copyright \xA9\_2021-2023 by Michael R Sweet.\n //\n // Licensed under Apache\
    \ License v2.0.  See the file \"LICENSE\" for more\n // information.\n@@ -38,6\
    \ +38,8 @@ _pdfioFileConsume(pdfio_file_t *pdf,\t// I - PDF file\n   else if (_pdfioFileSeek(pdf,\
    \ (off_t)bytes, SEEK_CUR) < 0)\n     return (false);\n \n+  PDFIO_DEBUG(\"_pdfioFileConsume:\
    \ pos=%ld\\n\", (long)(pdf->bufpos + pdf->bufptr - pdf->buffer));\n+\n   return\
    \ (true);\n }\n "
  - "--- a/pdfio-dict.c\n+++ b/pdfio-dict.c\n@@ -1,7 +1,7 @@\n //\n // PDF dictionary\
    \ functions for PDFio.\n //\n-// Copyright \xA9\_2021-2022 by Michael R Sweet.\n\
    +// Copyright \xA9\_2021-2023 by Michael R Sweet.\n //\n // Licensed under Apache\
    \ License v2.0.  See the file \"LICENSE\" for more\n // information.\n@@ -541,8\
    \ +541,15 @@ _pdfioDictRead(pdfio_file_t   *pdf,\t// I - PDF file\n       _pdfioFileError(pdf,\
    \ \"Invalid dictionary contents.\");\n       break;\n     }\n+    else if (_pdfioDictGetValue(dict,\
    \ key + 1))\n+    {\n+      _pdfioFileError(pdf, \"Duplicate dictionary key '%s'.\"\
    , key + 1);\n+      return (NULL);\n+    }\n \n     // Then get the next value...\n\
    +    PDFIO_DEBUG(\"_pdfioDictRead: Reading value for '%s'.\\n\", key + 1);\n+\n\
    \     if (!_pdfioValueRead(pdf, obj, tb, &value, depth))\n     {\n       _pdfioFileError(pdf,\
    \ \"Missing value for dictionary key.\");\n@@ -932,9 +939,9 @@ _pdfioDictSetValue(\n\
    \ \n #ifdef DEBUG\n   PDFIO_DEBUG(\"_pdfioDictSetValue(%p): %lu pairs\\n\", (void\
    \ *)dict, (unsigned long)dict->num_pairs);\n-  PDFIO_DEBUG(\"_pdfioDictSetValue(%p):\
    \ \", (void *)dict);\n-  PDFIO_DEBUG_DICT(dict);\n-  PDFIO_DEBUG(\"\\n\");\n+//\
    \  PDFIO_DEBUG(\"_pdfioDictSetValue(%p): \", (void *)dict);\n+//  PDFIO_DEBUG_DICT(dict);\n\
    +//  PDFIO_DEBUG(\"\\n\");\n #endif // DEBUG\n \n   return (true);"
  - "--- a/pdfio-file.c\n+++ b/pdfio-file.c\n@@ -1,7 +1,7 @@\n //\n // PDF file functions\
    \ for PDFio.\n //\n-// Copyright \xA9\_2021-2022 by Michael R Sweet.\n+// Copyright\
    \ \xA9\_2021-2023 by Michael R Sweet.\n //\n // Licensed under Apache License\
    \ v2.0.  See the file \"LICENSE\" for more\n // information.\n@@ -1984,6 +1984,8\
    \ @@ load_xref(\n \treturn (false);\n       }\n \n+      PDFIO_DEBUG(\"load_xref:\
    \ Got trailer dict.\\n\");\n+\n       _pdfioTokenFlush(&tb);\n \n       if (!pdf->trailer_dict)"
  - "--- a/pdfio-object.c\n+++ b/pdfio-object.c\n@@ -1,7 +1,7 @@\n //\n // PDF object\
    \ functions for PDFio.\n //\n-// Copyright \xA9\_2021-2022 by Michael R Sweet.\n\
    +// Copyright \xA9\_2021-2023 by Michael R Sweet.\n //\n // Licensed under Apache\
    \ License v2.0.  See the file \"LICENSE\" for more\n // information."
  - "--- a/pdfio-token.c\n+++ b/pdfio-token.c\n@@ -1,7 +1,7 @@\n //\n // PDF token\
    \ parsing functions for PDFio.\n //\n-// Copyright \xA9\_2021 by Michael R Sweet.\n\
    +// Copyright \xA9\_2021-2023 by Michael R Sweet.\n //\n // Licensed under Apache\
    \ License v2.0.  See the file \"LICENSE\" for more\n // information.\n@@ -129,9\
    \ +129,20 @@ _pdfioTokenGet(_pdfio_token_t *tb,\t// I - Token buffer/stack\n \
    \  if (tb->num_tokens > 0)\n   {\n     // Yes, return it...\n+    size_t len;\t\
    \t\t\t// Length of token\n+\n     tb->num_tokens --;\n-    strncpy(buffer, tb->tokens[tb->num_tokens],\
    \ bufsize - 1);\n-    buffer[bufsize - 1] = '\\0';\n+\n+    if ((len = strlen(tb->tokens[tb->num_tokens]))\
    \ > (bufsize - 1))\n+    {\n+      // Value too large...\n+      PDFIO_DEBUG(\"\
    _pdfioTokenGet(tb=%p, buffer=%p, bufsize=%u): Token '%s' from stack too large.\\\
    n\", tb, buffer, (unsigned)bufsize, tb->tokens[tb->num_tokens]);\n+      *buffer\
    \ = '\\0';\n+      return (false);\n+    }\n+\n+    memcpy(buffer, tb->tokens[tb->num_tokens],\
    \ len);\n+    buffer[len] = '\\0';\n \n     PDFIO_DEBUG(\"_pdfioTokenGet(tb=%p,\
    \ buffer=%p, bufsize=%u): Popping '%s' from stack.\\n\", tb, buffer, (unsigned)bufsize,\
    \ buffer);\n \n@@ -536,7 +547,7 @@ _pdfioTokenRead(_pdfio_token_t *tb,\t// I -\
    \ Token buffer/stack\n \n   *bufptr = '\\0';\n \n-  PDFIO_DEBUG(\"_pdfioTokenRead:\
    \ Read '%s'.\\n\", buffer);\n+//  PDFIO_DEBUG(\"_pdfioTokenRead: Read '%s'.\\\
    n\", buffer);\n \n   return (bufptr > buffer);\n }\n@@ -573,6 +584,7 @@ get_char(_pdfio_token_t\
    \ *tb)\t\t// I - Token buffer\n     tb->bufptr = tb->buffer;\n     tb->bufend\
    \ = tb->buffer + bytes;\n \n+#if 0\n #ifdef DEBUG\n     unsigned char *ptr;\t\t\
    \t// Pointer into buffer\n \n@@ -586,6 +598,7 @@ get_char(_pdfio_token_t *tb)\t\
    \t// I - Token buffer\n     }\n     PDFIO_DEBUG(\"'\\n\");\n #endif // DEBUG\n\
    +#endif // 0\n   }\n \n   // Return the next character..."
  - "--- a/pdfio-value.c\n+++ b/pdfio-value.c\n@@ -1,7 +1,7 @@\n //\n // PDF value\
    \ functions for PDFio.\n //\n-// Copyright \xA9\_2021 by Michael R Sweet.\n+//\
    \ Copyright \xA9\_2021-2023 by Michael R Sweet.\n //\n // Licensed under Apache\
    \ License v2.0.  See the file \"LICENSE\" for more\n // information."
  identifiers:
  - CVE-2023-24808
  - CWE-835
  overview: ' PDFio is a C library for reading and writing PDF files. In versions
    prior to 1.1.0 a denial of service (DOS) vulnerability exists in the pdfio parser.
    Crafted pdf files can cause the program to run at 100% utilization and never terminate.
    The pdf which causes this crash found in testing is about 28kb in size and was
    discovered via fuzzing. Anyone who uses this library either as a standalone binary
    or as a library can be DOSed when attempting to parse this type of file. Web servers
    or other automated processes which rely on this code to turn pdf submissions into
    plaintext can be DOSed when an attacker uploads the pdf. Please see the linked
    GHSA for an example pdf. Users are advised to upgrade. There are no known workarounds
    for this vulnerability.'
  references:
  - source: security-advisories@github.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/michaelrsweet/pdfio/commit/4f10021e7ee527c1aa24853e2947e38e154d9ccb
  - source: security-advisories@github.com
    tags:
    - Exploit
    - Third Party Advisory
    url: https://github.com/michaelrsweet/pdfio/security/advisories/GHSA-cjc4-x96x-fvgf
  title: ' PDFio is a C library for reading and writing PDF files. In versions prior
    to 1.1.0 a denial of service (DOS) vulnerability exists in the pdfio parser. Crafted
    pdf files can cause the program to run at 100% utilization and never terminate.
    The pdf which causes this crash found in testing is about 28kb in size and was
    discovered via fuzzing. Anyone who uses this library either as a standalone binary
    or as a library can be DOSed when attempting to parse this type of file. Web servers
    or other automated processes which rely on this code to turn pdf submissions into
    plaintext can be DOSed when an attacker uploads the pdf. Please see the linked
    GHSA for an example pdf. Users are advised to upgrade. There are no known workarounds
    for this vulnerability.'
- diff_content:
  - "--- a/src/wallet/wallet.cpp\n+++ b/src/wallet/wallet.cpp\n@@ -2889,20 +2889,11\
    \ @@ bool CWallet::CreateTransaction(const std::vector<CRecipient>& vecSend, CTransac\n\
    \                     nChangePosInOut = -1;\n                 }\n \n-        \
    \        // Fill vin\n+                // Dummy fill vin for maximum size estimation\n\
    \                 //\n-                // Note how the sequence number is set\
    \ to non-maxint so that\n-                // the nLockTime set above actually\
    \ works.\n-                //\n-                // BIP125 defines opt-in RBF as\
    \ any nSequence < maxint-1, so\n-                // we use the highest possible\
    \ value in that range (maxint-2)\n-                // to avoid conflicting with\
    \ other possible uses of nSequence,\n-                // and in the spirit of\
    \ \"smallest possible change from prior\n-                // behavior.\"\n-  \
    \              const uint32_t nSequence = coin_control.signalRbf ? MAX_BIP125_RBF_SEQUENCE\
    \ : (CTxIn::SEQUENCE_FINAL - 1);\n-                for (const auto& coin : setCoins)\n\
    -                    txNew.vin.push_back(CTxIn(coin.outpoint,CScript(),\n-   \
    \                                           nSequence));\n+                for\
    \ (const auto& coin : setCoins) {\n+                    txNew.vin.push_back(CTxIn(coin.outpoint,CScript()));\n\
    +                }\n \n                 nBytes = CalculateMaximumSignedTxSize(txNew,\
    \ this);\n                 if (nBytes < 0) {\n@@ -2992,11 +2983,29 @@ bool CWallet::CreateTransaction(const\
    \ std::vector<CRecipient>& vecSend, CTransac\n \n         if (nChangePosInOut\
    \ == -1) reservekey.ReturnKey(); // Return any reserved key if we don't have change\n\
    \ \n+        // Shuffle selected coins and fill in final vin\n+        txNew.vin.clear();\n\
    +        std::vector<CInputCoin> selected_coins(setCoins.begin(), setCoins.end());\n\
    +        std::shuffle(selected_coins.begin(), selected_coins.end(), FastRandomContext());\n\
    +\n+        // Note how the sequence number is set to non-maxint so that\n+  \
    \      // the nLockTime set above actually works.\n+        //\n+        // BIP125\
    \ defines opt-in RBF as any nSequence < maxint-1, so\n+        // we use the highest\
    \ possible value in that range (maxint-2)\n+        // to avoid conflicting with\
    \ other possible uses of nSequence,\n+        // and in the spirit of \"smallest\
    \ possible change from prior\n+        // behavior.\"\n+        const uint32_t\
    \ nSequence = coin_control.signalRbf ? MAX_BIP125_RBF_SEQUENCE : (CTxIn::SEQUENCE_FINAL\
    \ - 1);\n+        for (const auto& coin : selected_coins) {\n+            txNew.vin.push_back(CTxIn(coin.outpoint,\
    \ CScript(), nSequence));\n+        }\n+\n         if (sign)\n         {\n   \
    \          CTransaction txNewConst(txNew);\n             int nIn = 0;\n-     \
    \       for (const auto& coin : setCoins)\n+            for (const auto& coin\
    \ : selected_coins)\n             {\n                 const CScript& scriptPubKey\
    \ = coin.txout.scriptPubKey;\n                 SignatureData sigdata;"
  identifiers:
  - CVE-2021-37491
  - NVD-CWE-noinfo
  overview: An issue discovered in src/wallet/wallet.cpp in Dogecoin Project Dogecoin
    Core 1.14.3 and earlier allows attackers to view sensitive information via CWallet::CreateTransaction()
    function.
  references:
  - source: cve@mitre.org
    tags:
    - Product
    url: http://dogecoin.com
  - source: cve@mitre.org
    tags:
    - Exploit
    - Technical Description
    url: https://github.com/VPRLab/BlkVulnReport/blob/main/NDSS23_BlockScope.pdf
  - source: cve@mitre.org
    tags:
    - Patch
    url: https://github.com/bitcoin/bitcoin/commit/2fb9c1e6681370478e24a19172ed6d78d95d50d3
  - source: cve@mitre.org
    tags:
    - Exploit
    url: https://github.com/dogecoin/dogecoin/blob/master/src/wallet/wallet.cpp#L2628-L2640
  - source: cve@mitre.org
    tags:
    - Issue Tracking
    - Patch
    url: https://github.com/dogecoin/dogecoin/issues/2279
  title: An issue discovered in src/wallet/wallet.cpp in Dogecoin Project Dogecoin
    Core 1.14.3 and earlier allows attackers to view sensitive information via CWallet::CreateTransaction()
    function.
- diff_content:
  - "--- a/src/wallet/wallet.cpp\n+++ b/src/wallet/wallet.cpp\n@@ -2889,20 +2889,11\
    \ @@ bool CWallet::CreateTransaction(const std::vector<CRecipient>& vecSend, CTransac\n\
    \                     nChangePosInOut = -1;\n                 }\n \n-        \
    \        // Fill vin\n+                // Dummy fill vin for maximum size estimation\n\
    \                 //\n-                // Note how the sequence number is set\
    \ to non-maxint so that\n-                // the nLockTime set above actually\
    \ works.\n-                //\n-                // BIP125 defines opt-in RBF as\
    \ any nSequence < maxint-1, so\n-                // we use the highest possible\
    \ value in that range (maxint-2)\n-                // to avoid conflicting with\
    \ other possible uses of nSequence,\n-                // and in the spirit of\
    \ \"smallest possible change from prior\n-                // behavior.\"\n-  \
    \              const uint32_t nSequence = coin_control.signalRbf ? MAX_BIP125_RBF_SEQUENCE\
    \ : (CTxIn::SEQUENCE_FINAL - 1);\n-                for (const auto& coin : setCoins)\n\
    -                    txNew.vin.push_back(CTxIn(coin.outpoint,CScript(),\n-   \
    \                                           nSequence));\n+                for\
    \ (const auto& coin : setCoins) {\n+                    txNew.vin.push_back(CTxIn(coin.outpoint,CScript()));\n\
    +                }\n \n                 nBytes = CalculateMaximumSignedTxSize(txNew,\
    \ this);\n                 if (nBytes < 0) {\n@@ -2992,11 +2983,29 @@ bool CWallet::CreateTransaction(const\
    \ std::vector<CRecipient>& vecSend, CTransac\n \n         if (nChangePosInOut\
    \ == -1) reservekey.ReturnKey(); // Return any reserved key if we don't have change\n\
    \ \n+        // Shuffle selected coins and fill in final vin\n+        txNew.vin.clear();\n\
    +        std::vector<CInputCoin> selected_coins(setCoins.begin(), setCoins.end());\n\
    +        std::shuffle(selected_coins.begin(), selected_coins.end(), FastRandomContext());\n\
    +\n+        // Note how the sequence number is set to non-maxint so that\n+  \
    \      // the nLockTime set above actually works.\n+        //\n+        // BIP125\
    \ defines opt-in RBF as any nSequence < maxint-1, so\n+        // we use the highest\
    \ possible value in that range (maxint-2)\n+        // to avoid conflicting with\
    \ other possible uses of nSequence,\n+        // and in the spirit of \"smallest\
    \ possible change from prior\n+        // behavior.\"\n+        const uint32_t\
    \ nSequence = coin_control.signalRbf ? MAX_BIP125_RBF_SEQUENCE : (CTxIn::SEQUENCE_FINAL\
    \ - 1);\n+        for (const auto& coin : selected_coins) {\n+            txNew.vin.push_back(CTxIn(coin.outpoint,\
    \ CScript(), nSequence));\n+        }\n+\n         if (sign)\n         {\n   \
    \          CTransaction txNewConst(txNew);\n             int nIn = 0;\n-     \
    \       for (const auto& coin : setCoins)\n+            for (const auto& coin\
    \ : selected_coins)\n             {\n                 const CScript& scriptPubKey\
    \ = coin.txout.scriptPubKey;\n                 SignatureData sigdata;"
  identifiers:
  - CVE-2021-37492
  - NVD-CWE-noinfo
  overview: An issue discovered in src/wallet/wallet.cpp in Ravencoin Core 4.3.2.1
    and earlier allows attackers to view sensitive information via CWallet::CreateTransactionAll()
    function.
  references:
  - source: cve@mitre.org
    tags:
    - Product
    url: http://ravencoin.com
  - source: cve@mitre.org
    tags:
    - Exploit
    url: https://github.com/RavenProject/Ravencoin/blob/master/src/wallet/wallet.cpp#L3657-L3671
  - source: cve@mitre.org
    tags:
    - Issue Tracking
    url: https://github.com/RavenProject/Ravencoin/issues/1086
  - source: cve@mitre.org
    tags:
    - Not Applicable
    url: https://github.com/bitcoin/bitcoin/commit/2fb9c1e6681370478e24a19172ed6d78d95d50d3
  title: An issue discovered in src/wallet/wallet.cpp in Ravencoin Core 4.3.2.1 and
    earlier allows attackers to view sensitive information via CWallet::CreateTransactionAll()
    function.
- diff_content:
  - "--- a/line.c\n+++ b/line.c\n@@ -633,8 +633,8 @@ ansi_step(pansi, ch)\n \t\t/*\
    \ Hyperlink ends with \\7 or ESC-backslash. */\n \t\tif (ch == '\\7')\n \t\t\t\
    return ANSI_END;\n-\t\tif (pansi->prev_esc && ch == '\\\\')\n-\t\t\treturn ANSI_END;\n\
    +\t\tif (pansi->prev_esc)\n+            return (ch == '\\\\') ? ANSI_END : ANSI_ERR;\n\
    \ \t\tpansi->prev_esc = (ch == ESC);\n \t\treturn ANSI_MID;\n \t}"
  identifiers:
  - CVE-2022-46663
  - NVD-CWE-Other
  overview: In GNU Less before 609, crafted data can result in "less -R" not filtering
    ANSI escape sequences sent to the terminal.
  references:
  - source: cve@mitre.org
    tags:
    - Broken Link
    url: http://www.greenwoodsoftware.com/less/news.609.html
  - source: cve@mitre.org
    tags:
    - Mailing List
    - Third Party Advisory
    url: http://www.openwall.com/lists/oss-security/2023/02/07/7
  - source: cve@mitre.org
    tags:
    - Patch
    url: https://github.com/gwsw/less/commit/a78e1351113cef564d790a730d657a321624d79c
  - source: cve@mitre.org
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/LR7AUWB34JD4PCW3HHASBEDGGHFWPAQP/
  - source: cve@mitre.org
    tags:
    - Third Party Advisory
    url: https://security.gentoo.org/glsa/202310-11
  - source: cve@mitre.org
    tags:
    - Mailing List
    - Patch
    - Third Party Advisory
    url: https://www.openwall.com/lists/oss-security/2023/02/07/7
  title: In GNU Less before 609, crafted data can result in "less -R" not filtering
    ANSI escape sequences sent to the terminal.
- diff_content:
  - "--- a/src/isomedia/box_code_base.c\n+++ b/src/isomedia/box_code_base.c\n@@ -9983,6\
    \ +9983,9 @@ static void *sgpd_parse_entry(u32 grouping_type, GF_BitStream *bs,\
    \ s32 bytes_in_\n \t\t}\n \t\treturn ptr;\n \t}\n+\tcase 0:\n+\t\tGF_LOG(GF_LOG_WARNING,\
    \ GF_LOG_CONTAINER, (\"[iso file] sgpd entry null grouping_type is invalid\\n\"\
    ) );\n+\t\treturn NULL;\n \tdefault:\n \t\tbreak;\n \t}"
  identifiers:
  - CVE-2023-0760
  - CWE-122
  overview: Heap-based Buffer Overflow in GitHub repository gpac/gpac prior to V2.1.0-DEV.
  references:
  - source: security@huntr.dev
    tags:
    - Exploit
    - Patch
    url: https://github.com/gpac/gpac/commit/ea7395f39f601a7750d48d606e9d10ea0b7beefe
  - source: security@huntr.dev
    tags:
    - Exploit
    - Issue Tracking
    - Patch
    - Third Party Advisory
    url: https://huntr.dev/bounties/d06223df-a473-4c82-96d0-23726b844b21
  - source: security@huntr.dev
    url: https://www.debian.org/security/2023/dsa-5452
  title: Heap-based Buffer Overflow in GitHub repository gpac/gpac prior to V2.1.0-DEV.
- diff_content:
  - "--- a/src/scenegraph/vrml_proto.c\n+++ b/src/scenegraph/vrml_proto.c\n@@ -1292,7\
    \ +1292,10 @@ Bool gf_sg_proto_field_is_sftime_offset(GF_Node *node, GF_FieldInfo\
    \ *field)\n \n \t\tgf_node_get_field(r->ToNode, r->ToField.fieldIndex, &inf);\n\
    \ \t\t/*IS to another proto*/\n-\t\tif (r->ToNode->sgprivate->tag == TAG_ProtoNode)\
    \ return gf_sg_proto_field_is_sftime_offset(r->ToNode, &inf);\n+\t\tif (r->ToNode->sgprivate->tag\
    \ == TAG_ProtoNode) {\n+\t\t\tif (r->ToNode==node) continue;\n+\t\t\treturn gf_sg_proto_field_is_sftime_offset(r->ToNode,\
    \ &inf);\n+\t\t}\n \t\t/*IS to a startTime/stopTime field*/\n \t\tif (!stricmp(inf.name,\
    \ \"startTime\") || !stricmp(inf.name, \"stopTime\")) return 1;\n \t}"
  identifiers:
  - CVE-2023-0770
  - CWE-787
  overview: Stack-based Buffer Overflow in GitHub repository gpac/gpac prior to 2.2.
  references:
  - source: security@huntr.dev
    tags:
    - Patch
    url: https://github.com/gpac/gpac/commit/c31941822ee275a35bc148382bafef1c53ec1c26
  - source: security@huntr.dev
    tags:
    - Exploit
    - Issue Tracking
    - Patch
    - Third Party Advisory
    url: https://huntr.dev/bounties/e0fdeee5-7909-446e-9bd0-db80fd80e8dd
  - source: security@huntr.dev
    tags:
    - Third Party Advisory
    url: https://www.debian.org/security/2023/dsa-5411
  title: Stack-based Buffer Overflow in GitHub repository gpac/gpac prior to 2.2.
- diff_content:
  - "--- a/src/filters/reframe_mhas.c\n+++ b/src/filters/reframe_mhas.c\n@@ -198,12\
    \ +198,11 @@ static void mhas_dmx_check_dur(GF_Filter *filter, GF_MHASDmxCtx *ctx)\n\
    \ \t\t\tif (!mhas_last_cfg) mhas_sap = 0;\n \t\t//config\n \t\t} else if (mhas_type==1)\
    \ {\n-\t\t\tu32 sr = 0;\n \t\t\t/*u32 pl = */gf_bs_read_u8(bs);\n \t\t\tu32 idx\
    \ = gf_bs_read_int(bs, 5);\n \t\t\tif (idx==0x1f)\n \t\t\t\tduration.den = gf_bs_read_int(bs,\
    \ 24);\n-\t\t\telse if (sr < nb_usac_sr) {\n+\t\t\telse if (idx < nb_usac_sr)\
    \ {\n \t\t\t\tduration.den = USACSampleRates[idx];\n \t\t\t}\n \t\t\tidx = gf_bs_read_int(bs,\
    \ 3);\n@@ -621,7 +620,7 @@ GF_Err mhas_dmx_process(GF_Filter *filter)\n \t\t\t\
    u32 idx = gf_bs_read_int(ctx->bs, 5);\n \t\t\tif (idx==0x1f)\n \t\t\t\tsr = gf_bs_read_int(ctx->bs,\
    \ 24);\n-\t\t\telse if (sr < nb_usac_sr) {\n+\t\t\telse if (idx < nb_usac_sr)\
    \ {\n \t\t\t\tsr = USACSampleRates[idx];\n \t\t\t}\n \t\t\tctx->nb_unknown_pck\
    \ = 0;"
  identifiers:
  - CVE-2023-0817
  - CWE-125
  overview: Buffer Over-read in GitHub repository gpac/gpac prior to v2.3.0-DEV.
  references:
  - source: security@huntr.dev
    tags:
    - Patch
    - Vendor Advisory
    url: https://github.com/gpac/gpac/commit/be9f8d395bbd196e3812e9cd80708f06bcc206f7
  - source: security@huntr.dev
    tags:
    - Exploit
    - Patch
    - Third Party Advisory
    url: https://huntr.dev/bounties/cb730bc5-d79c-4de6-9e57-10e8c3ce2cf3
  title: Buffer Over-read in GitHub repository gpac/gpac prior to v2.3.0-DEV.
- diff_content:
  - "--- a/src/filters/load_text.c\n+++ b/src/filters/load_text.c\n@@ -315,18 +315,24\
    \ @@ char *gf_text_get_utf8_line(char *szLine, u32 lineSize, FILE *txt_in, s32\
    \ unicod\n \t\t\tif (!unicode_type && (szLine[i] & 0x80)) {\n \t\t\t\t/*non UTF8\
    \ (likely some win-CP)*/\n \t\t\t\tif ((szLine[i+1] & 0xc0) != 0x80) {\n+\t\t\t\
    \t\tif (j >= GF_ARRAY_LENGTH(szLineConv))\n+\t\t\t\t\t\tbreak;\n \t\t\t\t\tszLineConv[j]\
    \ = 0xc0 | ( (szLine[i] >> 6) & 0x3 );\n \t\t\t\t\tj++;\n \t\t\t\t\tszLine[i]\
    \ &= 0xbf;\n \t\t\t\t}\n \t\t\t\t/*UTF8 2 bytes char*/\n \t\t\t\telse if ( (szLine[i]\
    \ & 0xe0) == 0xc0) {\n+\t\t\t\t\tif (j >= GF_ARRAY_LENGTH(szLineConv))\n+\t\t\t\
    \t\t\tbreak;\n \t\t\t\t\tszLineConv[j] = szLine[i];\n \t\t\t\t\ti++;\n \t\t\t\t\
    \tj++;\n \t\t\t\t}\n \t\t\t\t/*UTF8 3 bytes char*/\n \t\t\t\telse if ( (szLine[i]\
    \ & 0xf0) == 0xe0) {\n+\t\t\t\t\tif (j+1 >= GF_ARRAY_LENGTH(szLineConv))\n+\t\t\
    \t\t\t\tbreak;\n \t\t\t\t\tszLineConv[j] = szLine[i];\n \t\t\t\t\ti++;\n \t\t\t\
    \t\tj++;\n@@ -336,6 +342,8 @@ char *gf_text_get_utf8_line(char *szLine, u32 lineSize,\
    \ FILE *txt_in, s32 unicod\n \t\t\t\t}\n \t\t\t\t/*UTF8 4 bytes char*/\n \t\t\t\
    \telse if ( (szLine[i] & 0xf8) == 0xf0) {\n+\t\t\t\t\tif (j+2 >= GF_ARRAY_LENGTH(szLineConv))\n\
    +\t\t\t\t\t\tbreak;\n \t\t\t\t\tszLineConv[j] = szLine[i];\n \t\t\t\t\ti++;\n\
    \ \t\t\t\t\tj++;\n@@ -350,14 +358,18 @@ char *gf_text_get_utf8_line(char *szLine,\
    \ u32 lineSize, FILE *txt_in, s32 unicod\n \t\t\t\t\tcontinue;\n \t\t\t\t}\n \t\
    \t\t}\n+\n+\t\t\tif (j >= GF_ARRAY_LENGTH(szLineConv))\n+\t\t\t\tbreak;\n+\n \t\
    \t\tszLineConv[j] = szLine[i];\n \t\t\tj++;\n \n-\t\t\tif (j >= GF_ARRAY_LENGTH(szLineConv)\
    \ - 1) {\n-\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_PARSER, (\"[TXTIn] Line too long\
    \ to convert to utf8 (len: %d)\\n\", len));\n-\t\t\t\tbreak;\n-\t\t\t}\n \n+\t\
    \t}\n+\t\tif ( j >= GF_ARRAY_LENGTH(szLineConv) ) {\n+\t\t\tGF_LOG(GF_LOG_DEBUG,\
    \ GF_LOG_PARSER, (\"[TXTIn] Line too long to convert to utf8 (len: %d)\\n\", len));\n\
    +\t\t\tj = GF_ARRAY_LENGTH(szLineConv) -1 ;\n \t\t}\n \t\tszLineConv[j] = 0;\n\
    \ \t\tstrcpy(szLine, szLineConv);"
  identifiers:
  - CVE-2023-0818
  - CWE-193
  overview: Off-by-one Error in GitHub repository gpac/gpac prior to v2.3.0-DEV.
  references:
  - source: security@huntr.dev
    tags:
    - Patch
    url: https://github.com/gpac/gpac/commit/377ab25f3e502db2934a9cf4b54739e1c89a02ff
  - source: security@huntr.dev
    tags:
    - Exploit
    - Third Party Advisory
    url: https://huntr.dev/bounties/038e7472-f3e9-46c2-9aea-d6dafb62a18a
  - source: security@huntr.dev
    url: https://www.debian.org/security/2023/dsa-5411
  title: Off-by-one Error in GitHub repository gpac/gpac prior to v2.3.0-DEV.
- diff_content:
  - "--- a/src/media_tools/mpegts.c\n+++ b/src/media_tools/mpegts.c\n@@ -946,6 +946,11\
    \ @@ static void gf_m2ts_process_tdt_tot(GF_M2TS_Demuxer *ts, GF_M2TS_SECTION_ES\
    \ *tdt\n \t\treturn;\n \t}\n \n+\tif (data_size < 5) {\n+\t\tGF_LOG(GF_LOG_ERROR,\
    \ GF_LOG_CONTAINER, (\"[MPEG-2 TS] Section data size too small to read date (len:\
    \ %u)\\n\", data_size));\n+\t\treturn;\n+\t}\n+\n \t/*UTC_time - see annex C of\
    \ DVB-SI ETSI EN 300468*/\n /* decodes an Modified Julian Date (MJD) into a Co-ordinated\
    \ Universal Time (UTC)\n See annex C of DVB-SI ETSI EN 300468 */"
  identifiers:
  - CVE-2023-0819
  - CWE-122
  overview: Heap-based Buffer Overflow in GitHub repository gpac/gpac prior to v2.3.0-DEV.
  references:
  - source: security@huntr.dev
    tags:
    - Patch
    url: https://github.com/gpac/gpac/commit/d067ab3ccdeaa340e8c045a0fd5bcfc22b809e8f
  - source: security@huntr.dev
    tags:
    - Exploit
    - Patch
    - Third Party Advisory
    url: https://huntr.dev/bounties/35793610-dccc-46c8-9f55-6a24c621e4ef
  - source: security@huntr.dev
    url: https://www.debian.org/security/2023/dsa-5411
  title: Heap-based Buffer Overflow in GitHub repository gpac/gpac prior to v2.3.0-DEV.
- diff_content:
  - "--- a/tools/tiffcrop.c\n+++ b/tools/tiffcrop.c\n@@ -296,7 +296,6 @@ struct region\n\
    \     uint32_t width;    /* width in pixels */\n     uint32_t length;   /* length\
    \ in pixels */\n     uint32_t buffsize; /* size of buffer needed to hold the cropped\
    \ region */\n-    unsigned char *buffptr; /* address of start of the region */\n\
    \ };\n \n /* Cropping parameters from command line and image data\n@@ -577,7 +576,7\
    \ @@ static int rotateContigSamples24bits(uint16_t, uint16_t, uint16_t, uint32_t,\n\
    \ static int rotateContigSamples32bits(uint16_t, uint16_t, uint16_t, uint32_t,\n\
    \                                      uint32_t, uint32_t, uint8_t *, uint8_t\
    \ *);\n static int rotateImage(uint16_t, struct image_data *, uint32_t *, uint32_t\
    \ *,\n-                       unsigned char **, size_t *);\n+                \
    \       unsigned char **, size_t *, int);\n static int mirrorImage(uint16_t, uint16_t,\
    \ uint16_t, uint32_t, uint32_t,\n                        unsigned char *);\n static\
    \ int invertImage(uint16_t, uint16_t, uint16_t, uint32_t, uint32_t,\n@@ -5782,7\
    \ +5781,6 @@ static void initCropMasks(struct crop_mask *cps)\n         cps->regionlist[i].width\
    \ = 0;\n         cps->regionlist[i].length = 0;\n         cps->regionlist[i].buffsize\
    \ = 0;\n-        cps->regionlist[i].buffptr = NULL;\n         cps->zonelist[i].position\
    \ = 0;\n         cps->zonelist[i].total = 0;\n     }\n@@ -7266,9 +7264,13 @@ static\
    \ int correct_orientation(struct image_data *image,\n                       (uint16_t)(image->adjustments\
    \ & ROTATE_ANY));\n             return (-1);\n         }\n-\n-        if (rotateImage(rotation,\
    \ image, &image->width, &image->length,\n-                        work_buff_ptr,\
    \ NULL))\n+        /* Dummy variable in order not to switch two times the\n+ \
    \        * image->width,->length within rotateImage(),\n+         * but switch\
    \ xres, yres there. */\n+        uint32_t width = image->width;\n+        uint32_t\
    \ length = image->length;\n+        if (rotateImage(rotation, image, &width, &length,\
    \ work_buff_ptr, NULL,\n+                        TRUE))\n         {\n        \
    \     TIFFError(\"correct_orientation\", \"Unable to rotate image\");\n      \
    \       return (-1);\n@@ -7377,7 +7379,6 @@ static int extractCompositeRegions(struct\
    \ image_data *image,\n         /* These should not be needed for composite images\
    \ */\n         crop->regionlist[i].width = crop_width;\n         crop->regionlist[i].length\
    \ = crop_length;\n-        crop->regionlist[i].buffptr = crop_buff;\n \n     \
    \    src_rowsize = ((img_width * bps * spp) + 7) / 8;\n         dst_rowsize =\
    \ (((crop_width * bps * count) + 7) / 8);\n@@ -7640,7 +7641,6 @@ static int extractSeparateRegion(struct\
    \ image_data *image,\n \n     crop->regionlist[region].width = crop_width;\n \
    \    crop->regionlist[region].length = crop_length;\n-    crop->regionlist[region].buffptr\
    \ = crop_buff;\n \n     src = read_buff;\n     dst = crop_buff;\n@@ -8635,7 +8635,8\
    \ @@ static int processCropSelections(struct image_data *image,\n            \
    \  * accordingly. */\n             size_t rot_buf_size = 0;\n             if (rotateImage(crop->rotation,\
    \ image, &crop->combined_width,\n-                            &crop->combined_length,\
    \ &crop_buff, &rot_buf_size))\n+                            &crop->combined_length,\
    \ &crop_buff, &rot_buf_size,\n+                            FALSE))\n         \
    \    {\n                 TIFFError(\"processCropSelections\",\n              \
    \             \"Failed to rotate composite regions by %\" PRIu32\n@@ -8759,9 +8760,10\
    \ @@ static int processCropSelections(struct image_data *image,\n            \
    \      * its size individually. Therefore, seg_buffs size  needs to be\n     \
    \             * updated accordingly. */\n                 size_t rot_buf_size\
    \ = 0;\n-                if (rotateImage(\n-                        crop->rotation,\
    \ image, &crop->regionlist[i].width,\n-                        &crop->regionlist[i].length,\
    \ &crop_buff, &rot_buf_size))\n+                if (rotateImage(crop->rotation,\
    \ image,\n+                                &crop->regionlist[i].width,\n+    \
    \                            &crop->regionlist[i].length, &crop_buff,\n+     \
    \                           &rot_buf_size, FALSE))\n                 {\n     \
    \                TIFFError(\"processCropSelections\",\n                      \
    \         \"Failed to rotate crop region by %\" PRIu16\n@@ -8905,7 +8907,7 @@\
    \ static int createCroppedImage(struct image_data *image, struct crop_mask *crop,\n\
    \         CROP_ROTATE) /* rotate should be last as it can reallocate the buffer\
    \ */\n     {\n         if (rotateImage(crop->rotation, image, &crop->combined_width,\n\
    -                        &crop->combined_length, crop_buff_ptr, NULL))\n+    \
    \                    &crop->combined_length, crop_buff_ptr, NULL, TRUE))\n   \
    \      {\n             TIFFError(\"createCroppedImage\",\n                   \
    \    \"Failed to rotate image or cropped selection by %\" PRIu16\n@@ -9621,7 +9623,8\
    \ @@ static int rotateContigSamples32bits(uint16_t rotation, uint16_t spp,\n /*\
    \ Rotate an image by a multiple of 90 degrees clockwise */\n static int rotateImage(uint16_t\
    \ rotation, struct image_data *image,\n                        uint32_t *img_width,\
    \ uint32_t *img_length,\n-                       unsigned char **ibuff_ptr, size_t\
    \ *rot_buf_size)\n+                       unsigned char **ibuff_ptr, size_t *rot_buf_size,\n\
    +                       int rot_image_params)\n {\n     int shift_width;\n   \
    \  uint32_t bytes_per_pixel, bytes_per_sample;\n@@ -9869,11 +9872,15 @@ static\
    \ int rotateImage(uint16_t rotation, struct image_data *image,\n \n          \
    \   *img_width = length;\n             *img_length = width;\n-            image->width\
    \ = length;\n-            image->length = width;\n-            res_temp = image->xres;\n\
    -            image->xres = image->yres;\n-            image->yres = res_temp;\n\
    +            /* Only toggle image parameters if whole input image is rotated.\
    \ */\n+            if (rot_image_params)\n+            {\n+                image->width\
    \ = length;\n+                image->length = width;\n+                res_temp\
    \ = image->xres;\n+                image->xres = image->yres;\n+             \
    \   image->yres = res_temp;\n+            }\n             break;\n \n        \
    \ case 270:\n@@ -9956,11 +9963,15 @@ static int rotateImage(uint16_t rotation,\
    \ struct image_data *image,\n \n             *img_width = length;\n          \
    \   *img_length = width;\n-            image->width = length;\n-            image->length\
    \ = width;\n-            res_temp = image->xres;\n-            image->xres = image->yres;\n\
    -            image->yres = res_temp;\n+            /* Only toggle image parameters\
    \ if whole input image is rotated. */\n+            if (rot_image_params)\n+ \
    \           {\n+                image->width = length;\n+                image->length\
    \ = width;\n+                res_temp = image->xres;\n+                image->xres\
    \ = image->yres;\n+                image->yres = res_temp;\n+            }\n \
    \            break;\n         default:\n             break;\n"
  identifiers:
  - CVE-2023-0795
  - CWE-125
  overview: LibTIFF 4.4.0 has an out-of-bounds read in tiffcrop in tools/tiffcrop.c:3488,
    allowing attackers to cause a denial-of-service via a crafted tiff file. For users
    that compile libtiff from sources, the fix is available with commit afaabc3e.
  references:
  - source: cve@gitlab.com
    tags:
    - VDB Entry
    url: https://gitlab.com/gitlab-org/cves/-/blob/master/2023/CVE-2023-0795.json
  - source: cve@gitlab.com
    tags:
    - Patch
    url: https://gitlab.com/libtiff/libtiff/-/commit/afaabc3e50d4e5d80a94143f7e3c997e7e410f68
  - source: cve@gitlab.com
    tags:
    - Exploit
    - Issue Tracking
    - Patch
    - Vendor Advisory
    url: https://gitlab.com/libtiff/libtiff/-/issues/493
  - source: cve@gitlab.com
    url: https://lists.debian.org/debian-lts-announce/2023/02/msg00026.html
  - source: cve@gitlab.com
    url: https://security.gentoo.org/glsa/202305-31
  - source: cve@gitlab.com
    url: https://security.netapp.com/advisory/ntap-20230316-0003/
  - source: cve@gitlab.com
    url: https://www.debian.org/security/2023/dsa-5361
  title: LibTIFF 4.4.0 has an out-of-bounds read in tiffcrop in tools/tiffcrop.c:3488,
    allowing attackers to cause a denial-of-service via a crafted tiff file. For users
    that compile libtiff from sources, the fix is available with commit afaabc3e.
- diff_content:
  - "--- a/tools/tiffcrop.c\n+++ b/tools/tiffcrop.c\n@@ -296,7 +296,6 @@ struct region\n\
    \     uint32_t width;    /* width in pixels */\n     uint32_t length;   /* length\
    \ in pixels */\n     uint32_t buffsize; /* size of buffer needed to hold the cropped\
    \ region */\n-    unsigned char *buffptr; /* address of start of the region */\n\
    \ };\n \n /* Cropping parameters from command line and image data\n@@ -577,7 +576,7\
    \ @@ static int rotateContigSamples24bits(uint16_t, uint16_t, uint16_t, uint32_t,\n\
    \ static int rotateContigSamples32bits(uint16_t, uint16_t, uint16_t, uint32_t,\n\
    \                                      uint32_t, uint32_t, uint8_t *, uint8_t\
    \ *);\n static int rotateImage(uint16_t, struct image_data *, uint32_t *, uint32_t\
    \ *,\n-                       unsigned char **, size_t *);\n+                \
    \       unsigned char **, size_t *, int);\n static int mirrorImage(uint16_t, uint16_t,\
    \ uint16_t, uint32_t, uint32_t,\n                        unsigned char *);\n static\
    \ int invertImage(uint16_t, uint16_t, uint16_t, uint32_t, uint32_t,\n@@ -5782,7\
    \ +5781,6 @@ static void initCropMasks(struct crop_mask *cps)\n         cps->regionlist[i].width\
    \ = 0;\n         cps->regionlist[i].length = 0;\n         cps->regionlist[i].buffsize\
    \ = 0;\n-        cps->regionlist[i].buffptr = NULL;\n         cps->zonelist[i].position\
    \ = 0;\n         cps->zonelist[i].total = 0;\n     }\n@@ -7266,9 +7264,13 @@ static\
    \ int correct_orientation(struct image_data *image,\n                       (uint16_t)(image->adjustments\
    \ & ROTATE_ANY));\n             return (-1);\n         }\n-\n-        if (rotateImage(rotation,\
    \ image, &image->width, &image->length,\n-                        work_buff_ptr,\
    \ NULL))\n+        /* Dummy variable in order not to switch two times the\n+ \
    \        * image->width,->length within rotateImage(),\n+         * but switch\
    \ xres, yres there. */\n+        uint32_t width = image->width;\n+        uint32_t\
    \ length = image->length;\n+        if (rotateImage(rotation, image, &width, &length,\
    \ work_buff_ptr, NULL,\n+                        TRUE))\n         {\n        \
    \     TIFFError(\"correct_orientation\", \"Unable to rotate image\");\n      \
    \       return (-1);\n@@ -7377,7 +7379,6 @@ static int extractCompositeRegions(struct\
    \ image_data *image,\n         /* These should not be needed for composite images\
    \ */\n         crop->regionlist[i].width = crop_width;\n         crop->regionlist[i].length\
    \ = crop_length;\n-        crop->regionlist[i].buffptr = crop_buff;\n \n     \
    \    src_rowsize = ((img_width * bps * spp) + 7) / 8;\n         dst_rowsize =\
    \ (((crop_width * bps * count) + 7) / 8);\n@@ -7640,7 +7641,6 @@ static int extractSeparateRegion(struct\
    \ image_data *image,\n \n     crop->regionlist[region].width = crop_width;\n \
    \    crop->regionlist[region].length = crop_length;\n-    crop->regionlist[region].buffptr\
    \ = crop_buff;\n \n     src = read_buff;\n     dst = crop_buff;\n@@ -8635,7 +8635,8\
    \ @@ static int processCropSelections(struct image_data *image,\n            \
    \  * accordingly. */\n             size_t rot_buf_size = 0;\n             if (rotateImage(crop->rotation,\
    \ image, &crop->combined_width,\n-                            &crop->combined_length,\
    \ &crop_buff, &rot_buf_size))\n+                            &crop->combined_length,\
    \ &crop_buff, &rot_buf_size,\n+                            FALSE))\n         \
    \    {\n                 TIFFError(\"processCropSelections\",\n              \
    \             \"Failed to rotate composite regions by %\" PRIu32\n@@ -8759,9 +8760,10\
    \ @@ static int processCropSelections(struct image_data *image,\n            \
    \      * its size individually. Therefore, seg_buffs size  needs to be\n     \
    \             * updated accordingly. */\n                 size_t rot_buf_size\
    \ = 0;\n-                if (rotateImage(\n-                        crop->rotation,\
    \ image, &crop->regionlist[i].width,\n-                        &crop->regionlist[i].length,\
    \ &crop_buff, &rot_buf_size))\n+                if (rotateImage(crop->rotation,\
    \ image,\n+                                &crop->regionlist[i].width,\n+    \
    \                            &crop->regionlist[i].length, &crop_buff,\n+     \
    \                           &rot_buf_size, FALSE))\n                 {\n     \
    \                TIFFError(\"processCropSelections\",\n                      \
    \         \"Failed to rotate crop region by %\" PRIu16\n@@ -8905,7 +8907,7 @@\
    \ static int createCroppedImage(struct image_data *image, struct crop_mask *crop,\n\
    \         CROP_ROTATE) /* rotate should be last as it can reallocate the buffer\
    \ */\n     {\n         if (rotateImage(crop->rotation, image, &crop->combined_width,\n\
    -                        &crop->combined_length, crop_buff_ptr, NULL))\n+    \
    \                    &crop->combined_length, crop_buff_ptr, NULL, TRUE))\n   \
    \      {\n             TIFFError(\"createCroppedImage\",\n                   \
    \    \"Failed to rotate image or cropped selection by %\" PRIu16\n@@ -9621,7 +9623,8\
    \ @@ static int rotateContigSamples32bits(uint16_t rotation, uint16_t spp,\n /*\
    \ Rotate an image by a multiple of 90 degrees clockwise */\n static int rotateImage(uint16_t\
    \ rotation, struct image_data *image,\n                        uint32_t *img_width,\
    \ uint32_t *img_length,\n-                       unsigned char **ibuff_ptr, size_t\
    \ *rot_buf_size)\n+                       unsigned char **ibuff_ptr, size_t *rot_buf_size,\n\
    +                       int rot_image_params)\n {\n     int shift_width;\n   \
    \  uint32_t bytes_per_pixel, bytes_per_sample;\n@@ -9869,11 +9872,15 @@ static\
    \ int rotateImage(uint16_t rotation, struct image_data *image,\n \n          \
    \   *img_width = length;\n             *img_length = width;\n-            image->width\
    \ = length;\n-            image->length = width;\n-            res_temp = image->xres;\n\
    -            image->xres = image->yres;\n-            image->yres = res_temp;\n\
    +            /* Only toggle image parameters if whole input image is rotated.\
    \ */\n+            if (rot_image_params)\n+            {\n+                image->width\
    \ = length;\n+                image->length = width;\n+                res_temp\
    \ = image->xres;\n+                image->xres = image->yres;\n+             \
    \   image->yres = res_temp;\n+            }\n             break;\n \n        \
    \ case 270:\n@@ -9956,11 +9963,15 @@ static int rotateImage(uint16_t rotation,\
    \ struct image_data *image,\n \n             *img_width = length;\n          \
    \   *img_length = width;\n-            image->width = length;\n-            image->length\
    \ = width;\n-            res_temp = image->xres;\n-            image->xres = image->yres;\n\
    -            image->yres = res_temp;\n+            /* Only toggle image parameters\
    \ if whole input image is rotated. */\n+            if (rot_image_params)\n+ \
    \           {\n+                image->width = length;\n+                image->length\
    \ = width;\n+                res_temp = image->xres;\n+                image->xres\
    \ = image->yres;\n+                image->yres = res_temp;\n+            }\n \
    \            break;\n         default:\n             break;\n"
  identifiers:
  - CVE-2023-0796
  - CWE-125
  overview: LibTIFF 4.4.0 has an out-of-bounds read in tiffcrop in tools/tiffcrop.c:3592,
    allowing attackers to cause a denial-of-service via a crafted tiff file. For users
    that compile libtiff from sources, the fix is available with commit afaabc3e.
  references:
  - source: cve@gitlab.com
    tags:
    - VDB Entry
    url: https://gitlab.com/gitlab-org/cves/-/blob/master/2023/CVE-2023-0796.json
  - source: cve@gitlab.com
    tags:
    - Patch
    url: https://gitlab.com/libtiff/libtiff/-/commit/afaabc3e50d4e5d80a94143f7e3c997e7e410f68
  - source: cve@gitlab.com
    tags:
    - Exploit
    - Issue Tracking
    - Patch
    - Vendor Advisory
    url: https://gitlab.com/libtiff/libtiff/-/issues/499
  - source: cve@gitlab.com
    url: https://lists.debian.org/debian-lts-announce/2023/02/msg00026.html
  - source: cve@gitlab.com
    url: https://security.gentoo.org/glsa/202305-31
  - source: cve@gitlab.com
    url: https://security.netapp.com/advisory/ntap-20230316-0003/
  - source: cve@gitlab.com
    url: https://www.debian.org/security/2023/dsa-5361
  title: LibTIFF 4.4.0 has an out-of-bounds read in tiffcrop in tools/tiffcrop.c:3592,
    allowing attackers to cause a denial-of-service via a crafted tiff file. For users
    that compile libtiff from sources, the fix is available with commit afaabc3e.
- diff_content:
  - "--- a/tools/tiffcrop.c\n+++ b/tools/tiffcrop.c\n@@ -296,7 +296,6 @@ struct region\n\
    \     uint32_t width;    /* width in pixels */\n     uint32_t length;   /* length\
    \ in pixels */\n     uint32_t buffsize; /* size of buffer needed to hold the cropped\
    \ region */\n-    unsigned char *buffptr; /* address of start of the region */\n\
    \ };\n \n /* Cropping parameters from command line and image data\n@@ -577,7 +576,7\
    \ @@ static int rotateContigSamples24bits(uint16_t, uint16_t, uint16_t, uint32_t,\n\
    \ static int rotateContigSamples32bits(uint16_t, uint16_t, uint16_t, uint32_t,\n\
    \                                      uint32_t, uint32_t, uint8_t *, uint8_t\
    \ *);\n static int rotateImage(uint16_t, struct image_data *, uint32_t *, uint32_t\
    \ *,\n-                       unsigned char **, size_t *);\n+                \
    \       unsigned char **, size_t *, int);\n static int mirrorImage(uint16_t, uint16_t,\
    \ uint16_t, uint32_t, uint32_t,\n                        unsigned char *);\n static\
    \ int invertImage(uint16_t, uint16_t, uint16_t, uint32_t, uint32_t,\n@@ -5782,7\
    \ +5781,6 @@ static void initCropMasks(struct crop_mask *cps)\n         cps->regionlist[i].width\
    \ = 0;\n         cps->regionlist[i].length = 0;\n         cps->regionlist[i].buffsize\
    \ = 0;\n-        cps->regionlist[i].buffptr = NULL;\n         cps->zonelist[i].position\
    \ = 0;\n         cps->zonelist[i].total = 0;\n     }\n@@ -7266,9 +7264,13 @@ static\
    \ int correct_orientation(struct image_data *image,\n                       (uint16_t)(image->adjustments\
    \ & ROTATE_ANY));\n             return (-1);\n         }\n-\n-        if (rotateImage(rotation,\
    \ image, &image->width, &image->length,\n-                        work_buff_ptr,\
    \ NULL))\n+        /* Dummy variable in order not to switch two times the\n+ \
    \        * image->width,->length within rotateImage(),\n+         * but switch\
    \ xres, yres there. */\n+        uint32_t width = image->width;\n+        uint32_t\
    \ length = image->length;\n+        if (rotateImage(rotation, image, &width, &length,\
    \ work_buff_ptr, NULL,\n+                        TRUE))\n         {\n        \
    \     TIFFError(\"correct_orientation\", \"Unable to rotate image\");\n      \
    \       return (-1);\n@@ -7377,7 +7379,6 @@ static int extractCompositeRegions(struct\
    \ image_data *image,\n         /* These should not be needed for composite images\
    \ */\n         crop->regionlist[i].width = crop_width;\n         crop->regionlist[i].length\
    \ = crop_length;\n-        crop->regionlist[i].buffptr = crop_buff;\n \n     \
    \    src_rowsize = ((img_width * bps * spp) + 7) / 8;\n         dst_rowsize =\
    \ (((crop_width * bps * count) + 7) / 8);\n@@ -7640,7 +7641,6 @@ static int extractSeparateRegion(struct\
    \ image_data *image,\n \n     crop->regionlist[region].width = crop_width;\n \
    \    crop->regionlist[region].length = crop_length;\n-    crop->regionlist[region].buffptr\
    \ = crop_buff;\n \n     src = read_buff;\n     dst = crop_buff;\n@@ -8635,7 +8635,8\
    \ @@ static int processCropSelections(struct image_data *image,\n            \
    \  * accordingly. */\n             size_t rot_buf_size = 0;\n             if (rotateImage(crop->rotation,\
    \ image, &crop->combined_width,\n-                            &crop->combined_length,\
    \ &crop_buff, &rot_buf_size))\n+                            &crop->combined_length,\
    \ &crop_buff, &rot_buf_size,\n+                            FALSE))\n         \
    \    {\n                 TIFFError(\"processCropSelections\",\n              \
    \             \"Failed to rotate composite regions by %\" PRIu32\n@@ -8759,9 +8760,10\
    \ @@ static int processCropSelections(struct image_data *image,\n            \
    \      * its size individually. Therefore, seg_buffs size  needs to be\n     \
    \             * updated accordingly. */\n                 size_t rot_buf_size\
    \ = 0;\n-                if (rotateImage(\n-                        crop->rotation,\
    \ image, &crop->regionlist[i].width,\n-                        &crop->regionlist[i].length,\
    \ &crop_buff, &rot_buf_size))\n+                if (rotateImage(crop->rotation,\
    \ image,\n+                                &crop->regionlist[i].width,\n+    \
    \                            &crop->regionlist[i].length, &crop_buff,\n+     \
    \                           &rot_buf_size, FALSE))\n                 {\n     \
    \                TIFFError(\"processCropSelections\",\n                      \
    \         \"Failed to rotate crop region by %\" PRIu16\n@@ -8905,7 +8907,7 @@\
    \ static int createCroppedImage(struct image_data *image, struct crop_mask *crop,\n\
    \         CROP_ROTATE) /* rotate should be last as it can reallocate the buffer\
    \ */\n     {\n         if (rotateImage(crop->rotation, image, &crop->combined_width,\n\
    -                        &crop->combined_length, crop_buff_ptr, NULL))\n+    \
    \                    &crop->combined_length, crop_buff_ptr, NULL, TRUE))\n   \
    \      {\n             TIFFError(\"createCroppedImage\",\n                   \
    \    \"Failed to rotate image or cropped selection by %\" PRIu16\n@@ -9621,7 +9623,8\
    \ @@ static int rotateContigSamples32bits(uint16_t rotation, uint16_t spp,\n /*\
    \ Rotate an image by a multiple of 90 degrees clockwise */\n static int rotateImage(uint16_t\
    \ rotation, struct image_data *image,\n                        uint32_t *img_width,\
    \ uint32_t *img_length,\n-                       unsigned char **ibuff_ptr, size_t\
    \ *rot_buf_size)\n+                       unsigned char **ibuff_ptr, size_t *rot_buf_size,\n\
    +                       int rot_image_params)\n {\n     int shift_width;\n   \
    \  uint32_t bytes_per_pixel, bytes_per_sample;\n@@ -9869,11 +9872,15 @@ static\
    \ int rotateImage(uint16_t rotation, struct image_data *image,\n \n          \
    \   *img_width = length;\n             *img_length = width;\n-            image->width\
    \ = length;\n-            image->length = width;\n-            res_temp = image->xres;\n\
    -            image->xres = image->yres;\n-            image->yres = res_temp;\n\
    +            /* Only toggle image parameters if whole input image is rotated.\
    \ */\n+            if (rot_image_params)\n+            {\n+                image->width\
    \ = length;\n+                image->length = width;\n+                res_temp\
    \ = image->xres;\n+                image->xres = image->yres;\n+             \
    \   image->yres = res_temp;\n+            }\n             break;\n \n        \
    \ case 270:\n@@ -9956,11 +9963,15 @@ static int rotateImage(uint16_t rotation,\
    \ struct image_data *image,\n \n             *img_width = length;\n          \
    \   *img_length = width;\n-            image->width = length;\n-            image->length\
    \ = width;\n-            res_temp = image->xres;\n-            image->xres = image->yres;\n\
    -            image->yres = res_temp;\n+            /* Only toggle image parameters\
    \ if whole input image is rotated. */\n+            if (rot_image_params)\n+ \
    \           {\n+                image->width = length;\n+                image->length\
    \ = width;\n+                res_temp = image->xres;\n+                image->xres\
    \ = image->yres;\n+                image->yres = res_temp;\n+            }\n \
    \            break;\n         default:\n             break;\n"
  identifiers:
  - CVE-2023-0797
  - CWE-125
  overview: LibTIFF 4.4.0 has an out-of-bounds read in tiffcrop in libtiff/tif_unix.c:368,
    invoked by tools/tiffcrop.c:2903 and tools/tiffcrop.c:6921, allowing attackers
    to cause a denial-of-service via a crafted tiff file. For users that compile libtiff
    from sources, the fix is available with commit afaabc3e.
  references:
  - source: cve@gitlab.com
    tags:
    - VDB Entry
    url: https://gitlab.com/gitlab-org/cves/-/blob/master/2023/CVE-2023-0797.json
  - source: cve@gitlab.com
    tags:
    - Patch
    url: https://gitlab.com/libtiff/libtiff/-/commit/afaabc3e50d4e5d80a94143f7e3c997e7e410f68
  - source: cve@gitlab.com
    tags:
    - Exploit
    - Issue Tracking
    - Patch
    - Vendor Advisory
    url: https://gitlab.com/libtiff/libtiff/-/issues/495
  - source: cve@gitlab.com
    url: https://lists.debian.org/debian-lts-announce/2023/02/msg00026.html
  - source: cve@gitlab.com
    url: https://security.gentoo.org/glsa/202305-31
  - source: cve@gitlab.com
    url: https://www.debian.org/security/2023/dsa-5361
  title: LibTIFF 4.4.0 has an out-of-bounds read in tiffcrop in libtiff/tif_unix.c:368,
    invoked by tools/tiffcrop.c:2903 and tools/tiffcrop.c:6921, allowing attackers
    to cause a denial-of-service via a crafted tiff file. For users that compile libtiff
    from sources, the fix is available with commit afaabc3e.
- diff_content:
  - "--- a/tools/tiffcrop.c\n+++ b/tools/tiffcrop.c\n@@ -296,7 +296,6 @@ struct region\n\
    \     uint32_t width;    /* width in pixels */\n     uint32_t length;   /* length\
    \ in pixels */\n     uint32_t buffsize; /* size of buffer needed to hold the cropped\
    \ region */\n-    unsigned char *buffptr; /* address of start of the region */\n\
    \ };\n \n /* Cropping parameters from command line and image data\n@@ -577,7 +576,7\
    \ @@ static int rotateContigSamples24bits(uint16_t, uint16_t, uint16_t, uint32_t,\n\
    \ static int rotateContigSamples32bits(uint16_t, uint16_t, uint16_t, uint32_t,\n\
    \                                      uint32_t, uint32_t, uint8_t *, uint8_t\
    \ *);\n static int rotateImage(uint16_t, struct image_data *, uint32_t *, uint32_t\
    \ *,\n-                       unsigned char **, size_t *);\n+                \
    \       unsigned char **, size_t *, int);\n static int mirrorImage(uint16_t, uint16_t,\
    \ uint16_t, uint32_t, uint32_t,\n                        unsigned char *);\n static\
    \ int invertImage(uint16_t, uint16_t, uint16_t, uint32_t, uint32_t,\n@@ -5782,7\
    \ +5781,6 @@ static void initCropMasks(struct crop_mask *cps)\n         cps->regionlist[i].width\
    \ = 0;\n         cps->regionlist[i].length = 0;\n         cps->regionlist[i].buffsize\
    \ = 0;\n-        cps->regionlist[i].buffptr = NULL;\n         cps->zonelist[i].position\
    \ = 0;\n         cps->zonelist[i].total = 0;\n     }\n@@ -7266,9 +7264,13 @@ static\
    \ int correct_orientation(struct image_data *image,\n                       (uint16_t)(image->adjustments\
    \ & ROTATE_ANY));\n             return (-1);\n         }\n-\n-        if (rotateImage(rotation,\
    \ image, &image->width, &image->length,\n-                        work_buff_ptr,\
    \ NULL))\n+        /* Dummy variable in order not to switch two times the\n+ \
    \        * image->width,->length within rotateImage(),\n+         * but switch\
    \ xres, yres there. */\n+        uint32_t width = image->width;\n+        uint32_t\
    \ length = image->length;\n+        if (rotateImage(rotation, image, &width, &length,\
    \ work_buff_ptr, NULL,\n+                        TRUE))\n         {\n        \
    \     TIFFError(\"correct_orientation\", \"Unable to rotate image\");\n      \
    \       return (-1);\n@@ -7377,7 +7379,6 @@ static int extractCompositeRegions(struct\
    \ image_data *image,\n         /* These should not be needed for composite images\
    \ */\n         crop->regionlist[i].width = crop_width;\n         crop->regionlist[i].length\
    \ = crop_length;\n-        crop->regionlist[i].buffptr = crop_buff;\n \n     \
    \    src_rowsize = ((img_width * bps * spp) + 7) / 8;\n         dst_rowsize =\
    \ (((crop_width * bps * count) + 7) / 8);\n@@ -7640,7 +7641,6 @@ static int extractSeparateRegion(struct\
    \ image_data *image,\n \n     crop->regionlist[region].width = crop_width;\n \
    \    crop->regionlist[region].length = crop_length;\n-    crop->regionlist[region].buffptr\
    \ = crop_buff;\n \n     src = read_buff;\n     dst = crop_buff;\n@@ -8635,7 +8635,8\
    \ @@ static int processCropSelections(struct image_data *image,\n            \
    \  * accordingly. */\n             size_t rot_buf_size = 0;\n             if (rotateImage(crop->rotation,\
    \ image, &crop->combined_width,\n-                            &crop->combined_length,\
    \ &crop_buff, &rot_buf_size))\n+                            &crop->combined_length,\
    \ &crop_buff, &rot_buf_size,\n+                            FALSE))\n         \
    \    {\n                 TIFFError(\"processCropSelections\",\n              \
    \             \"Failed to rotate composite regions by %\" PRIu32\n@@ -8759,9 +8760,10\
    \ @@ static int processCropSelections(struct image_data *image,\n            \
    \      * its size individually. Therefore, seg_buffs size  needs to be\n     \
    \             * updated accordingly. */\n                 size_t rot_buf_size\
    \ = 0;\n-                if (rotateImage(\n-                        crop->rotation,\
    \ image, &crop->regionlist[i].width,\n-                        &crop->regionlist[i].length,\
    \ &crop_buff, &rot_buf_size))\n+                if (rotateImage(crop->rotation,\
    \ image,\n+                                &crop->regionlist[i].width,\n+    \
    \                            &crop->regionlist[i].length, &crop_buff,\n+     \
    \                           &rot_buf_size, FALSE))\n                 {\n     \
    \                TIFFError(\"processCropSelections\",\n                      \
    \         \"Failed to rotate crop region by %\" PRIu16\n@@ -8905,7 +8907,7 @@\
    \ static int createCroppedImage(struct image_data *image, struct crop_mask *crop,\n\
    \         CROP_ROTATE) /* rotate should be last as it can reallocate the buffer\
    \ */\n     {\n         if (rotateImage(crop->rotation, image, &crop->combined_width,\n\
    -                        &crop->combined_length, crop_buff_ptr, NULL))\n+    \
    \                    &crop->combined_length, crop_buff_ptr, NULL, TRUE))\n   \
    \      {\n             TIFFError(\"createCroppedImage\",\n                   \
    \    \"Failed to rotate image or cropped selection by %\" PRIu16\n@@ -9621,7 +9623,8\
    \ @@ static int rotateContigSamples32bits(uint16_t rotation, uint16_t spp,\n /*\
    \ Rotate an image by a multiple of 90 degrees clockwise */\n static int rotateImage(uint16_t\
    \ rotation, struct image_data *image,\n                        uint32_t *img_width,\
    \ uint32_t *img_length,\n-                       unsigned char **ibuff_ptr, size_t\
    \ *rot_buf_size)\n+                       unsigned char **ibuff_ptr, size_t *rot_buf_size,\n\
    +                       int rot_image_params)\n {\n     int shift_width;\n   \
    \  uint32_t bytes_per_pixel, bytes_per_sample;\n@@ -9869,11 +9872,15 @@ static\
    \ int rotateImage(uint16_t rotation, struct image_data *image,\n \n          \
    \   *img_width = length;\n             *img_length = width;\n-            image->width\
    \ = length;\n-            image->length = width;\n-            res_temp = image->xres;\n\
    -            image->xres = image->yres;\n-            image->yres = res_temp;\n\
    +            /* Only toggle image parameters if whole input image is rotated.\
    \ */\n+            if (rot_image_params)\n+            {\n+                image->width\
    \ = length;\n+                image->length = width;\n+                res_temp\
    \ = image->xres;\n+                image->xres = image->yres;\n+             \
    \   image->yres = res_temp;\n+            }\n             break;\n \n        \
    \ case 270:\n@@ -9956,11 +9963,15 @@ static int rotateImage(uint16_t rotation,\
    \ struct image_data *image,\n \n             *img_width = length;\n          \
    \   *img_length = width;\n-            image->width = length;\n-            image->length\
    \ = width;\n-            res_temp = image->xres;\n-            image->xres = image->yres;\n\
    -            image->yres = res_temp;\n+            /* Only toggle image parameters\
    \ if whole input image is rotated. */\n+            if (rot_image_params)\n+ \
    \           {\n+                image->width = length;\n+                image->length\
    \ = width;\n+                res_temp = image->xres;\n+                image->xres\
    \ = image->yres;\n+                image->yres = res_temp;\n+            }\n \
    \            break;\n         default:\n             break;\n"
  identifiers:
  - CVE-2023-0798
  - CWE-125
  overview: LibTIFF 4.4.0 has an out-of-bounds read in tiffcrop in tools/tiffcrop.c:3400,
    allowing attackers to cause a denial-of-service via a crafted tiff file. For users
    that compile libtiff from sources, the fix is available with commit afaabc3e.
  references:
  - source: cve@gitlab.com
    tags:
    - VDB Entry
    url: https://gitlab.com/gitlab-org/cves/-/blob/master/2023/CVE-2023-0798.json
  - source: cve@gitlab.com
    tags:
    - Patch
    url: https://gitlab.com/libtiff/libtiff/-/commit/afaabc3e50d4e5d80a94143f7e3c997e7e410f68
  - source: cve@gitlab.com
    tags:
    - Exploit
    - Issue Tracking
    - Patch
    - Vendor Advisory
    url: https://gitlab.com/libtiff/libtiff/-/issues/492
  - source: cve@gitlab.com
    url: https://lists.debian.org/debian-lts-announce/2023/02/msg00026.html
  - source: cve@gitlab.com
    url: https://security.gentoo.org/glsa/202305-31
  - source: cve@gitlab.com
    url: https://security.netapp.com/advisory/ntap-20230316-0003/
  - source: cve@gitlab.com
    url: https://www.debian.org/security/2023/dsa-5361
  title: LibTIFF 4.4.0 has an out-of-bounds read in tiffcrop in tools/tiffcrop.c:3400,
    allowing attackers to cause a denial-of-service via a crafted tiff file. For users
    that compile libtiff from sources, the fix is available with commit afaabc3e.
- diff_content:
  - "--- a/tools/tiffcrop.c\n+++ b/tools/tiffcrop.c\n@@ -296,7 +296,6 @@ struct region\n\
    \     uint32_t width;    /* width in pixels */\n     uint32_t length;   /* length\
    \ in pixels */\n     uint32_t buffsize; /* size of buffer needed to hold the cropped\
    \ region */\n-    unsigned char *buffptr; /* address of start of the region */\n\
    \ };\n \n /* Cropping parameters from command line and image data\n@@ -577,7 +576,7\
    \ @@ static int rotateContigSamples24bits(uint16_t, uint16_t, uint16_t, uint32_t,\n\
    \ static int rotateContigSamples32bits(uint16_t, uint16_t, uint16_t, uint32_t,\n\
    \                                      uint32_t, uint32_t, uint8_t *, uint8_t\
    \ *);\n static int rotateImage(uint16_t, struct image_data *, uint32_t *, uint32_t\
    \ *,\n-                       unsigned char **, size_t *);\n+                \
    \       unsigned char **, size_t *, int);\n static int mirrorImage(uint16_t, uint16_t,\
    \ uint16_t, uint32_t, uint32_t,\n                        unsigned char *);\n static\
    \ int invertImage(uint16_t, uint16_t, uint16_t, uint32_t, uint32_t,\n@@ -5782,7\
    \ +5781,6 @@ static void initCropMasks(struct crop_mask *cps)\n         cps->regionlist[i].width\
    \ = 0;\n         cps->regionlist[i].length = 0;\n         cps->regionlist[i].buffsize\
    \ = 0;\n-        cps->regionlist[i].buffptr = NULL;\n         cps->zonelist[i].position\
    \ = 0;\n         cps->zonelist[i].total = 0;\n     }\n@@ -7266,9 +7264,13 @@ static\
    \ int correct_orientation(struct image_data *image,\n                       (uint16_t)(image->adjustments\
    \ & ROTATE_ANY));\n             return (-1);\n         }\n-\n-        if (rotateImage(rotation,\
    \ image, &image->width, &image->length,\n-                        work_buff_ptr,\
    \ NULL))\n+        /* Dummy variable in order not to switch two times the\n+ \
    \        * image->width,->length within rotateImage(),\n+         * but switch\
    \ xres, yres there. */\n+        uint32_t width = image->width;\n+        uint32_t\
    \ length = image->length;\n+        if (rotateImage(rotation, image, &width, &length,\
    \ work_buff_ptr, NULL,\n+                        TRUE))\n         {\n        \
    \     TIFFError(\"correct_orientation\", \"Unable to rotate image\");\n      \
    \       return (-1);\n@@ -7377,7 +7379,6 @@ static int extractCompositeRegions(struct\
    \ image_data *image,\n         /* These should not be needed for composite images\
    \ */\n         crop->regionlist[i].width = crop_width;\n         crop->regionlist[i].length\
    \ = crop_length;\n-        crop->regionlist[i].buffptr = crop_buff;\n \n     \
    \    src_rowsize = ((img_width * bps * spp) + 7) / 8;\n         dst_rowsize =\
    \ (((crop_width * bps * count) + 7) / 8);\n@@ -7640,7 +7641,6 @@ static int extractSeparateRegion(struct\
    \ image_data *image,\n \n     crop->regionlist[region].width = crop_width;\n \
    \    crop->regionlist[region].length = crop_length;\n-    crop->regionlist[region].buffptr\
    \ = crop_buff;\n \n     src = read_buff;\n     dst = crop_buff;\n@@ -8635,7 +8635,8\
    \ @@ static int processCropSelections(struct image_data *image,\n            \
    \  * accordingly. */\n             size_t rot_buf_size = 0;\n             if (rotateImage(crop->rotation,\
    \ image, &crop->combined_width,\n-                            &crop->combined_length,\
    \ &crop_buff, &rot_buf_size))\n+                            &crop->combined_length,\
    \ &crop_buff, &rot_buf_size,\n+                            FALSE))\n         \
    \    {\n                 TIFFError(\"processCropSelections\",\n              \
    \             \"Failed to rotate composite regions by %\" PRIu32\n@@ -8759,9 +8760,10\
    \ @@ static int processCropSelections(struct image_data *image,\n            \
    \      * its size individually. Therefore, seg_buffs size  needs to be\n     \
    \             * updated accordingly. */\n                 size_t rot_buf_size\
    \ = 0;\n-                if (rotateImage(\n-                        crop->rotation,\
    \ image, &crop->regionlist[i].width,\n-                        &crop->regionlist[i].length,\
    \ &crop_buff, &rot_buf_size))\n+                if (rotateImage(crop->rotation,\
    \ image,\n+                                &crop->regionlist[i].width,\n+    \
    \                            &crop->regionlist[i].length, &crop_buff,\n+     \
    \                           &rot_buf_size, FALSE))\n                 {\n     \
    \                TIFFError(\"processCropSelections\",\n                      \
    \         \"Failed to rotate crop region by %\" PRIu16\n@@ -8905,7 +8907,7 @@\
    \ static int createCroppedImage(struct image_data *image, struct crop_mask *crop,\n\
    \         CROP_ROTATE) /* rotate should be last as it can reallocate the buffer\
    \ */\n     {\n         if (rotateImage(crop->rotation, image, &crop->combined_width,\n\
    -                        &crop->combined_length, crop_buff_ptr, NULL))\n+    \
    \                    &crop->combined_length, crop_buff_ptr, NULL, TRUE))\n   \
    \      {\n             TIFFError(\"createCroppedImage\",\n                   \
    \    \"Failed to rotate image or cropped selection by %\" PRIu16\n@@ -9621,7 +9623,8\
    \ @@ static int rotateContigSamples32bits(uint16_t rotation, uint16_t spp,\n /*\
    \ Rotate an image by a multiple of 90 degrees clockwise */\n static int rotateImage(uint16_t\
    \ rotation, struct image_data *image,\n                        uint32_t *img_width,\
    \ uint32_t *img_length,\n-                       unsigned char **ibuff_ptr, size_t\
    \ *rot_buf_size)\n+                       unsigned char **ibuff_ptr, size_t *rot_buf_size,\n\
    +                       int rot_image_params)\n {\n     int shift_width;\n   \
    \  uint32_t bytes_per_pixel, bytes_per_sample;\n@@ -9869,11 +9872,15 @@ static\
    \ int rotateImage(uint16_t rotation, struct image_data *image,\n \n          \
    \   *img_width = length;\n             *img_length = width;\n-            image->width\
    \ = length;\n-            image->length = width;\n-            res_temp = image->xres;\n\
    -            image->xres = image->yres;\n-            image->yres = res_temp;\n\
    +            /* Only toggle image parameters if whole input image is rotated.\
    \ */\n+            if (rot_image_params)\n+            {\n+                image->width\
    \ = length;\n+                image->length = width;\n+                res_temp\
    \ = image->xres;\n+                image->xres = image->yres;\n+             \
    \   image->yres = res_temp;\n+            }\n             break;\n \n        \
    \ case 270:\n@@ -9956,11 +9963,15 @@ static int rotateImage(uint16_t rotation,\
    \ struct image_data *image,\n \n             *img_width = length;\n          \
    \   *img_length = width;\n-            image->width = length;\n-            image->length\
    \ = width;\n-            res_temp = image->xres;\n-            image->xres = image->yres;\n\
    -            image->yres = res_temp;\n+            /* Only toggle image parameters\
    \ if whole input image is rotated. */\n+            if (rot_image_params)\n+ \
    \           {\n+                image->width = length;\n+                image->length\
    \ = width;\n+                res_temp = image->xres;\n+                image->xres\
    \ = image->yres;\n+                image->yres = res_temp;\n+            }\n \
    \            break;\n         default:\n             break;\n"
  identifiers:
  - CVE-2023-0799
  - CWE-416
  overview: LibTIFF 4.4.0 has an out-of-bounds read in tiffcrop in tools/tiffcrop.c:3701,
    allowing attackers to cause a denial-of-service via a crafted tiff file. For users
    that compile libtiff from sources, the fix is available with commit afaabc3e.
  references:
  - source: cve@gitlab.com
    tags:
    - VDB Entry
    url: https://gitlab.com/gitlab-org/cves/-/blob/master/2023/CVE-2023-0799.json
  - source: cve@gitlab.com
    tags:
    - Patch
    url: https://gitlab.com/libtiff/libtiff/-/commit/afaabc3e50d4e5d80a94143f7e3c997e7e410f68
  - source: cve@gitlab.com
    tags:
    - Exploit
    - Issue Tracking
    - Patch
    - Vendor Advisory
    url: https://gitlab.com/libtiff/libtiff/-/issues/494
  - source: cve@gitlab.com
    url: https://lists.debian.org/debian-lts-announce/2023/02/msg00026.html
  - source: cve@gitlab.com
    url: https://security.gentoo.org/glsa/202305-31
  - source: cve@gitlab.com
    url: https://security.netapp.com/advisory/ntap-20230316-0003/
  - source: cve@gitlab.com
    url: https://www.debian.org/security/2023/dsa-5361
  title: LibTIFF 4.4.0 has an out-of-bounds read in tiffcrop in tools/tiffcrop.c:3701,
    allowing attackers to cause a denial-of-service via a crafted tiff file. For users
    that compile libtiff from sources, the fix is available with commit afaabc3e.
- diff_content:
  - "--- a/tools/tiffcrop.c\n+++ b/tools/tiffcrop.c\n@@ -5935,18 +5935,40 @@ static\
    \ int computeInputPixelOffsets(struct crop_mask *crop,\n \n             crop->regionlist[i].buffsize\
    \ = buffsize;\n             crop->bufftotal += buffsize;\n+\n+            /* For\
    \ composite images with more than one region, the\n+             * combined_length\
    \ or combined_width always needs to be equal,\n+             * respectively.\n\
    +             * Otherwise, even the first section/region copy\n+             *\
    \ action might cause buffer overrun. */\n             if (crop->img_mode == COMPOSITE_IMAGES)\n\
    \             {\n                 switch (crop->edge_ref)\n                 {\n\
    \                     case EDGE_LEFT:\n                     case EDGE_RIGHT:\n\
    +                        if (i > 0 && zlength != crop->combined_length)\n+   \
    \                     {\n+                            TIFFError(\n+          \
    \                      \"computeInputPixelOffsets\",\n+                      \
    \          \"Only equal length regions can be combined for \"\n+             \
    \                   \"-E left or right\");\n+                            return\
    \ (-1);\n+                        }\n                         crop->combined_length\
    \ = zlength;\n                         crop->combined_width += zwidth;\n     \
    \                    break;\n                     case EDGE_BOTTOM:\n        \
    \             case EDGE_TOP: /* width from left, length from top */\n        \
    \             default:\n+                        if (i > 0 && zwidth != crop->combined_width)\n\
    +                        {\n+                            TIFFError(\"computeInputPixelOffsets\"\
    ,\n+                                      \"Only equal width regions can be \"\
    \n+                                      \"combined for -E \"\n+             \
    \                         \"top or bottom\");\n+                            return\
    \ (-1);\n+                        }\n                         crop->combined_width\
    \ = zwidth;\n                         crop->combined_length += zlength;\n    \
    \                     break;\n@@ -7301,6 +7323,46 @@ static int extractCompositeRegions(struct\
    \ image_data *image,\n     crop->combined_width = 0;\n     crop->combined_length\
    \ = 0;\n \n+    /* If there is more than one region, check beforehand whether\
    \ all the width\n+     * and length values of the regions are the same, respectively.\
    \ */\n+    switch (crop->edge_ref)\n+    {\n+        default:\n+        case EDGE_TOP:\n\
    +        case EDGE_BOTTOM:\n+            for (i = 1; i < crop->selections; i++)\n\
    +            {\n+                uint32_t crop_width0 =\n+                   \
    \ crop->regionlist[i - 1].x2 - crop->regionlist[i - 1].x1 + 1;\n+            \
    \    uint32_t crop_width1 =\n+                    crop->regionlist[i].x2 - crop->regionlist[i].x1\
    \ + 1;\n+                if (crop_width0 != crop_width1)\n+                {\n\
    +                    TIFFError(\"extractCompositeRegions\",\n+               \
    \               \"Only equal width regions can be combined for -E \"\n+      \
    \                        \"top or bottom\");\n+                    return (1);\n\
    +                }\n+            }\n+            break;\n+        case EDGE_LEFT:\n\
    +        case EDGE_RIGHT:\n+            for (i = 1; i < crop->selections; i++)\n\
    +            {\n+                uint32_t crop_length0 =\n+                  \
    \  crop->regionlist[i - 1].y2 - crop->regionlist[i - 1].y1 + 1;\n+           \
    \     uint32_t crop_length1 =\n+                    crop->regionlist[i].y2 - crop->regionlist[i].y1\
    \ + 1;\n+                if (crop_length0 != crop_length1)\n+                {\n\
    +                    TIFFError(\"extractCompositeRegions\",\n+               \
    \               \"Only equal length regions can be combined for \"\n+        \
    \                      \"-E left or right\");\n+                    return (1);\n\
    +                }\n+            }\n+    }\n+\n     for (i = 0; i < crop->selections;\
    \ i++)\n     {\n         /* rows, columns, width, length are expressed in pixels\
    \ */\n@@ -7325,7 +7387,8 @@ static int extractCompositeRegions(struct image_data\
    \ *image,\n             default:\n             case EDGE_TOP:\n             case\
    \ EDGE_BOTTOM:\n-                if ((i > 0) && (crop_width != crop->regionlist[i\
    \ - 1].width))\n+                if ((crop->selections > i + 1) &&\n+        \
    \            (crop_width != crop->regionlist[i + 1].width))\n                \
    \ {\n                     TIFFError(\"extractCompositeRegions\",\n           \
    \                    \"Only equal width regions can be combined for -E \"\n@@\
    \ -7418,7 +7481,8 @@ static int extractCompositeRegions(struct image_data *image,\n\
    \             case EDGE_LEFT: /* splice the pieces of each row together, side\
    \ by\n                                side */\n             case EDGE_RIGHT:\n\
    -                if ((i > 0) && (crop_length != crop->regionlist[i - 1].length))\n\
    +                if ((crop->selections > i + 1) &&\n+                    (crop_length\
    \ != crop->regionlist[i + 1].length))\n                 {\n                  \
    \   TIFFError(\"extractCompositeRegions\",\n                               \"\
    Only equal length regions can be combined for \"\n"
  identifiers:
  - CVE-2023-0800
  - CWE-787
  overview: LibTIFF 4.4.0 has an out-of-bounds write in tiffcrop in tools/tiffcrop.c:3502,
    allowing attackers to cause a denial-of-service via a crafted tiff file. For users
    that compile libtiff from sources, the fix is available with commit 33aee127.
  references:
  - source: cve@gitlab.com
    tags:
    - VDB Entry
    url: https://gitlab.com/gitlab-org/cves/-/blob/master/2023/CVE-2023-0800.json
  - source: cve@gitlab.com
    tags:
    - Patch
    url: https://gitlab.com/libtiff/libtiff/-/commit/33aee1275d9d1384791d2206776eb8152d397f00
  - source: cve@gitlab.com
    tags:
    - Exploit
    - Issue Tracking
    - Patch
    - Vendor Advisory
    url: https://gitlab.com/libtiff/libtiff/-/issues/496
  - source: cve@gitlab.com
    url: https://lists.debian.org/debian-lts-announce/2023/02/msg00026.html
  - source: cve@gitlab.com
    url: https://security.gentoo.org/glsa/202305-31
  - source: cve@gitlab.com
    url: https://security.netapp.com/advisory/ntap-20230316-0002/
  - source: cve@gitlab.com
    url: https://www.debian.org/security/2023/dsa-5361
  title: LibTIFF 4.4.0 has an out-of-bounds write in tiffcrop in tools/tiffcrop.c:3502,
    allowing attackers to cause a denial-of-service via a crafted tiff file. For users
    that compile libtiff from sources, the fix is available with commit 33aee127.
- diff_content:
  - "--- a/tools/tiffcrop.c\n+++ b/tools/tiffcrop.c\n@@ -5935,18 +5935,40 @@ static\
    \ int computeInputPixelOffsets(struct crop_mask *crop,\n \n             crop->regionlist[i].buffsize\
    \ = buffsize;\n             crop->bufftotal += buffsize;\n+\n+            /* For\
    \ composite images with more than one region, the\n+             * combined_length\
    \ or combined_width always needs to be equal,\n+             * respectively.\n\
    +             * Otherwise, even the first section/region copy\n+             *\
    \ action might cause buffer overrun. */\n             if (crop->img_mode == COMPOSITE_IMAGES)\n\
    \             {\n                 switch (crop->edge_ref)\n                 {\n\
    \                     case EDGE_LEFT:\n                     case EDGE_RIGHT:\n\
    +                        if (i > 0 && zlength != crop->combined_length)\n+   \
    \                     {\n+                            TIFFError(\n+          \
    \                      \"computeInputPixelOffsets\",\n+                      \
    \          \"Only equal length regions can be combined for \"\n+             \
    \                   \"-E left or right\");\n+                            return\
    \ (-1);\n+                        }\n                         crop->combined_length\
    \ = zlength;\n                         crop->combined_width += zwidth;\n     \
    \                    break;\n                     case EDGE_BOTTOM:\n        \
    \             case EDGE_TOP: /* width from left, length from top */\n        \
    \             default:\n+                        if (i > 0 && zwidth != crop->combined_width)\n\
    +                        {\n+                            TIFFError(\"computeInputPixelOffsets\"\
    ,\n+                                      \"Only equal width regions can be \"\
    \n+                                      \"combined for -E \"\n+             \
    \                         \"top or bottom\");\n+                            return\
    \ (-1);\n+                        }\n                         crop->combined_width\
    \ = zwidth;\n                         crop->combined_length += zlength;\n    \
    \                     break;\n@@ -7301,6 +7323,46 @@ static int extractCompositeRegions(struct\
    \ image_data *image,\n     crop->combined_width = 0;\n     crop->combined_length\
    \ = 0;\n \n+    /* If there is more than one region, check beforehand whether\
    \ all the width\n+     * and length values of the regions are the same, respectively.\
    \ */\n+    switch (crop->edge_ref)\n+    {\n+        default:\n+        case EDGE_TOP:\n\
    +        case EDGE_BOTTOM:\n+            for (i = 1; i < crop->selections; i++)\n\
    +            {\n+                uint32_t crop_width0 =\n+                   \
    \ crop->regionlist[i - 1].x2 - crop->regionlist[i - 1].x1 + 1;\n+            \
    \    uint32_t crop_width1 =\n+                    crop->regionlist[i].x2 - crop->regionlist[i].x1\
    \ + 1;\n+                if (crop_width0 != crop_width1)\n+                {\n\
    +                    TIFFError(\"extractCompositeRegions\",\n+               \
    \               \"Only equal width regions can be combined for -E \"\n+      \
    \                        \"top or bottom\");\n+                    return (1);\n\
    +                }\n+            }\n+            break;\n+        case EDGE_LEFT:\n\
    +        case EDGE_RIGHT:\n+            for (i = 1; i < crop->selections; i++)\n\
    +            {\n+                uint32_t crop_length0 =\n+                  \
    \  crop->regionlist[i - 1].y2 - crop->regionlist[i - 1].y1 + 1;\n+           \
    \     uint32_t crop_length1 =\n+                    crop->regionlist[i].y2 - crop->regionlist[i].y1\
    \ + 1;\n+                if (crop_length0 != crop_length1)\n+                {\n\
    +                    TIFFError(\"extractCompositeRegions\",\n+               \
    \               \"Only equal length regions can be combined for \"\n+        \
    \                      \"-E left or right\");\n+                    return (1);\n\
    +                }\n+            }\n+    }\n+\n     for (i = 0; i < crop->selections;\
    \ i++)\n     {\n         /* rows, columns, width, length are expressed in pixels\
    \ */\n@@ -7325,7 +7387,8 @@ static int extractCompositeRegions(struct image_data\
    \ *image,\n             default:\n             case EDGE_TOP:\n             case\
    \ EDGE_BOTTOM:\n-                if ((i > 0) && (crop_width != crop->regionlist[i\
    \ - 1].width))\n+                if ((crop->selections > i + 1) &&\n+        \
    \            (crop_width != crop->regionlist[i + 1].width))\n                \
    \ {\n                     TIFFError(\"extractCompositeRegions\",\n           \
    \                    \"Only equal width regions can be combined for -E \"\n@@\
    \ -7418,7 +7481,8 @@ static int extractCompositeRegions(struct image_data *image,\n\
    \             case EDGE_LEFT: /* splice the pieces of each row together, side\
    \ by\n                                side */\n             case EDGE_RIGHT:\n\
    -                if ((i > 0) && (crop_length != crop->regionlist[i - 1].length))\n\
    +                if ((crop->selections > i + 1) &&\n+                    (crop_length\
    \ != crop->regionlist[i + 1].length))\n                 {\n                  \
    \   TIFFError(\"extractCompositeRegions\",\n                               \"\
    Only equal length regions can be combined for \"\n"
  identifiers:
  - CVE-2023-0801
  - CWE-787
  overview: LibTIFF 4.4.0 has an out-of-bounds write in tiffcrop in libtiff/tif_unix.c:368,
    invoked by tools/tiffcrop.c:2903 and tools/tiffcrop.c:6778, allowing attackers
    to cause a denial-of-service via a crafted tiff file. For users that compile libtiff
    from sources, the fix is available with commit 33aee127.
  references:
  - source: cve@gitlab.com
    tags:
    - VDB Entry
    url: https://gitlab.com/gitlab-org/cves/-/blob/master/2023/CVE-2023-0801.json
  - source: cve@gitlab.com
    tags:
    - Patch
    url: https://gitlab.com/libtiff/libtiff/-/commit/33aee1275d9d1384791d2206776eb8152d397f00
  - source: cve@gitlab.com
    tags:
    - Exploit
    - Issue Tracking
    - Patch
    - Vendor Advisory
    url: https://gitlab.com/libtiff/libtiff/-/issues/498
  - source: cve@gitlab.com
    url: https://lists.debian.org/debian-lts-announce/2023/02/msg00026.html
  - source: cve@gitlab.com
    url: https://security.gentoo.org/glsa/202305-31
  - source: cve@gitlab.com
    url: https://security.netapp.com/advisory/ntap-20230316-0002/
  - source: cve@gitlab.com
    url: https://www.debian.org/security/2023/dsa-5361
  title: LibTIFF 4.4.0 has an out-of-bounds write in tiffcrop in libtiff/tif_unix.c:368,
    invoked by tools/tiffcrop.c:2903 and tools/tiffcrop.c:6778, allowing attackers
    to cause a denial-of-service via a crafted tiff file. For users that compile libtiff
    from sources, the fix is available with commit 33aee127.
- diff_content:
  - "--- a/tools/tiffcrop.c\n+++ b/tools/tiffcrop.c\n@@ -5935,18 +5935,40 @@ static\
    \ int computeInputPixelOffsets(struct crop_mask *crop,\n \n             crop->regionlist[i].buffsize\
    \ = buffsize;\n             crop->bufftotal += buffsize;\n+\n+            /* For\
    \ composite images with more than one region, the\n+             * combined_length\
    \ or combined_width always needs to be equal,\n+             * respectively.\n\
    +             * Otherwise, even the first section/region copy\n+             *\
    \ action might cause buffer overrun. */\n             if (crop->img_mode == COMPOSITE_IMAGES)\n\
    \             {\n                 switch (crop->edge_ref)\n                 {\n\
    \                     case EDGE_LEFT:\n                     case EDGE_RIGHT:\n\
    +                        if (i > 0 && zlength != crop->combined_length)\n+   \
    \                     {\n+                            TIFFError(\n+          \
    \                      \"computeInputPixelOffsets\",\n+                      \
    \          \"Only equal length regions can be combined for \"\n+             \
    \                   \"-E left or right\");\n+                            return\
    \ (-1);\n+                        }\n                         crop->combined_length\
    \ = zlength;\n                         crop->combined_width += zwidth;\n     \
    \                    break;\n                     case EDGE_BOTTOM:\n        \
    \             case EDGE_TOP: /* width from left, length from top */\n        \
    \             default:\n+                        if (i > 0 && zwidth != crop->combined_width)\n\
    +                        {\n+                            TIFFError(\"computeInputPixelOffsets\"\
    ,\n+                                      \"Only equal width regions can be \"\
    \n+                                      \"combined for -E \"\n+             \
    \                         \"top or bottom\");\n+                            return\
    \ (-1);\n+                        }\n                         crop->combined_width\
    \ = zwidth;\n                         crop->combined_length += zlength;\n    \
    \                     break;\n@@ -7301,6 +7323,46 @@ static int extractCompositeRegions(struct\
    \ image_data *image,\n     crop->combined_width = 0;\n     crop->combined_length\
    \ = 0;\n \n+    /* If there is more than one region, check beforehand whether\
    \ all the width\n+     * and length values of the regions are the same, respectively.\
    \ */\n+    switch (crop->edge_ref)\n+    {\n+        default:\n+        case EDGE_TOP:\n\
    +        case EDGE_BOTTOM:\n+            for (i = 1; i < crop->selections; i++)\n\
    +            {\n+                uint32_t crop_width0 =\n+                   \
    \ crop->regionlist[i - 1].x2 - crop->regionlist[i - 1].x1 + 1;\n+            \
    \    uint32_t crop_width1 =\n+                    crop->regionlist[i].x2 - crop->regionlist[i].x1\
    \ + 1;\n+                if (crop_width0 != crop_width1)\n+                {\n\
    +                    TIFFError(\"extractCompositeRegions\",\n+               \
    \               \"Only equal width regions can be combined for -E \"\n+      \
    \                        \"top or bottom\");\n+                    return (1);\n\
    +                }\n+            }\n+            break;\n+        case EDGE_LEFT:\n\
    +        case EDGE_RIGHT:\n+            for (i = 1; i < crop->selections; i++)\n\
    +            {\n+                uint32_t crop_length0 =\n+                  \
    \  crop->regionlist[i - 1].y2 - crop->regionlist[i - 1].y1 + 1;\n+           \
    \     uint32_t crop_length1 =\n+                    crop->regionlist[i].y2 - crop->regionlist[i].y1\
    \ + 1;\n+                if (crop_length0 != crop_length1)\n+                {\n\
    +                    TIFFError(\"extractCompositeRegions\",\n+               \
    \               \"Only equal length regions can be combined for \"\n+        \
    \                      \"-E left or right\");\n+                    return (1);\n\
    +                }\n+            }\n+    }\n+\n     for (i = 0; i < crop->selections;\
    \ i++)\n     {\n         /* rows, columns, width, length are expressed in pixels\
    \ */\n@@ -7325,7 +7387,8 @@ static int extractCompositeRegions(struct image_data\
    \ *image,\n             default:\n             case EDGE_TOP:\n             case\
    \ EDGE_BOTTOM:\n-                if ((i > 0) && (crop_width != crop->regionlist[i\
    \ - 1].width))\n+                if ((crop->selections > i + 1) &&\n+        \
    \            (crop_width != crop->regionlist[i + 1].width))\n                \
    \ {\n                     TIFFError(\"extractCompositeRegions\",\n           \
    \                    \"Only equal width regions can be combined for -E \"\n@@\
    \ -7418,7 +7481,8 @@ static int extractCompositeRegions(struct image_data *image,\n\
    \             case EDGE_LEFT: /* splice the pieces of each row together, side\
    \ by\n                                side */\n             case EDGE_RIGHT:\n\
    -                if ((i > 0) && (crop_length != crop->regionlist[i - 1].length))\n\
    +                if ((crop->selections > i + 1) &&\n+                    (crop_length\
    \ != crop->regionlist[i + 1].length))\n                 {\n                  \
    \   TIFFError(\"extractCompositeRegions\",\n                               \"\
    Only equal length regions can be combined for \"\n"
  identifiers:
  - CVE-2023-0802
  - CWE-787
  overview: LibTIFF 4.4.0 has an out-of-bounds write in tiffcrop in tools/tiffcrop.c:3724,
    allowing attackers to cause a denial-of-service via a crafted tiff file. For users
    that compile libtiff from sources, the fix is available with commit 33aee127.
  references:
  - source: cve@gitlab.com
    tags:
    - VDB Entry
    url: https://gitlab.com/gitlab-org/cves/-/blob/master/2023/CVE-2023-0802.json
  - source: cve@gitlab.com
    tags:
    - Patch
    url: https://gitlab.com/libtiff/libtiff/-/commit/33aee1275d9d1384791d2206776eb8152d397f00
  - source: cve@gitlab.com
    tags:
    - Exploit
    - Issue Tracking
    - Patch
    - Vendor Advisory
    url: https://gitlab.com/libtiff/libtiff/-/issues/500
  - source: cve@gitlab.com
    url: https://lists.debian.org/debian-lts-announce/2023/02/msg00026.html
  - source: cve@gitlab.com
    url: https://security.gentoo.org/glsa/202305-31
  - source: cve@gitlab.com
    url: https://security.netapp.com/advisory/ntap-20230316-0002/
  - source: cve@gitlab.com
    url: https://www.debian.org/security/2023/dsa-5361
  title: LibTIFF 4.4.0 has an out-of-bounds write in tiffcrop in tools/tiffcrop.c:3724,
    allowing attackers to cause a denial-of-service via a crafted tiff file. For users
    that compile libtiff from sources, the fix is available with commit 33aee127.
- diff_content:
  - "--- a/tools/tiffcrop.c\n+++ b/tools/tiffcrop.c\n@@ -5935,18 +5935,40 @@ static\
    \ int computeInputPixelOffsets(struct crop_mask *crop,\n \n             crop->regionlist[i].buffsize\
    \ = buffsize;\n             crop->bufftotal += buffsize;\n+\n+            /* For\
    \ composite images with more than one region, the\n+             * combined_length\
    \ or combined_width always needs to be equal,\n+             * respectively.\n\
    +             * Otherwise, even the first section/region copy\n+             *\
    \ action might cause buffer overrun. */\n             if (crop->img_mode == COMPOSITE_IMAGES)\n\
    \             {\n                 switch (crop->edge_ref)\n                 {\n\
    \                     case EDGE_LEFT:\n                     case EDGE_RIGHT:\n\
    +                        if (i > 0 && zlength != crop->combined_length)\n+   \
    \                     {\n+                            TIFFError(\n+          \
    \                      \"computeInputPixelOffsets\",\n+                      \
    \          \"Only equal length regions can be combined for \"\n+             \
    \                   \"-E left or right\");\n+                            return\
    \ (-1);\n+                        }\n                         crop->combined_length\
    \ = zlength;\n                         crop->combined_width += zwidth;\n     \
    \                    break;\n                     case EDGE_BOTTOM:\n        \
    \             case EDGE_TOP: /* width from left, length from top */\n        \
    \             default:\n+                        if (i > 0 && zwidth != crop->combined_width)\n\
    +                        {\n+                            TIFFError(\"computeInputPixelOffsets\"\
    ,\n+                                      \"Only equal width regions can be \"\
    \n+                                      \"combined for -E \"\n+             \
    \                         \"top or bottom\");\n+                            return\
    \ (-1);\n+                        }\n                         crop->combined_width\
    \ = zwidth;\n                         crop->combined_length += zlength;\n    \
    \                     break;\n@@ -7301,6 +7323,46 @@ static int extractCompositeRegions(struct\
    \ image_data *image,\n     crop->combined_width = 0;\n     crop->combined_length\
    \ = 0;\n \n+    /* If there is more than one region, check beforehand whether\
    \ all the width\n+     * and length values of the regions are the same, respectively.\
    \ */\n+    switch (crop->edge_ref)\n+    {\n+        default:\n+        case EDGE_TOP:\n\
    +        case EDGE_BOTTOM:\n+            for (i = 1; i < crop->selections; i++)\n\
    +            {\n+                uint32_t crop_width0 =\n+                   \
    \ crop->regionlist[i - 1].x2 - crop->regionlist[i - 1].x1 + 1;\n+            \
    \    uint32_t crop_width1 =\n+                    crop->regionlist[i].x2 - crop->regionlist[i].x1\
    \ + 1;\n+                if (crop_width0 != crop_width1)\n+                {\n\
    +                    TIFFError(\"extractCompositeRegions\",\n+               \
    \               \"Only equal width regions can be combined for -E \"\n+      \
    \                        \"top or bottom\");\n+                    return (1);\n\
    +                }\n+            }\n+            break;\n+        case EDGE_LEFT:\n\
    +        case EDGE_RIGHT:\n+            for (i = 1; i < crop->selections; i++)\n\
    +            {\n+                uint32_t crop_length0 =\n+                  \
    \  crop->regionlist[i - 1].y2 - crop->regionlist[i - 1].y1 + 1;\n+           \
    \     uint32_t crop_length1 =\n+                    crop->regionlist[i].y2 - crop->regionlist[i].y1\
    \ + 1;\n+                if (crop_length0 != crop_length1)\n+                {\n\
    +                    TIFFError(\"extractCompositeRegions\",\n+               \
    \               \"Only equal length regions can be combined for \"\n+        \
    \                      \"-E left or right\");\n+                    return (1);\n\
    +                }\n+            }\n+    }\n+\n     for (i = 0; i < crop->selections;\
    \ i++)\n     {\n         /* rows, columns, width, length are expressed in pixels\
    \ */\n@@ -7325,7 +7387,8 @@ static int extractCompositeRegions(struct image_data\
    \ *image,\n             default:\n             case EDGE_TOP:\n             case\
    \ EDGE_BOTTOM:\n-                if ((i > 0) && (crop_width != crop->regionlist[i\
    \ - 1].width))\n+                if ((crop->selections > i + 1) &&\n+        \
    \            (crop_width != crop->regionlist[i + 1].width))\n                \
    \ {\n                     TIFFError(\"extractCompositeRegions\",\n           \
    \                    \"Only equal width regions can be combined for -E \"\n@@\
    \ -7418,7 +7481,8 @@ static int extractCompositeRegions(struct image_data *image,\n\
    \             case EDGE_LEFT: /* splice the pieces of each row together, side\
    \ by\n                                side */\n             case EDGE_RIGHT:\n\
    -                if ((i > 0) && (crop_length != crop->regionlist[i - 1].length))\n\
    +                if ((crop->selections > i + 1) &&\n+                    (crop_length\
    \ != crop->regionlist[i + 1].length))\n                 {\n                  \
    \   TIFFError(\"extractCompositeRegions\",\n                               \"\
    Only equal length regions can be combined for \"\n"
  identifiers:
  - CVE-2023-0803
  - CWE-787
  overview: LibTIFF 4.4.0 has an out-of-bounds write in tiffcrop in tools/tiffcrop.c:3516,
    allowing attackers to cause a denial-of-service via a crafted tiff file. For users
    that compile libtiff from sources, the fix is available with commit 33aee127.
  references:
  - source: cve@gitlab.com
    tags:
    - VDB Entry
    url: https://gitlab.com/gitlab-org/cves/-/blob/master/2023/CVE-2023-0803.json
  - source: cve@gitlab.com
    tags:
    - Patch
    url: https://gitlab.com/libtiff/libtiff/-/commit/33aee1275d9d1384791d2206776eb8152d397f00
  - source: cve@gitlab.com
    tags:
    - Exploit
    - Issue Tracking
    - Patch
    - Vendor Advisory
    url: https://gitlab.com/libtiff/libtiff/-/issues/501
  - source: cve@gitlab.com
    url: https://lists.debian.org/debian-lts-announce/2023/02/msg00026.html
  - source: cve@gitlab.com
    url: https://security.gentoo.org/glsa/202305-31
  - source: cve@gitlab.com
    url: https://security.netapp.com/advisory/ntap-20230316-0002/
  - source: cve@gitlab.com
    url: https://www.debian.org/security/2023/dsa-5361
  title: LibTIFF 4.4.0 has an out-of-bounds write in tiffcrop in tools/tiffcrop.c:3516,
    allowing attackers to cause a denial-of-service via a crafted tiff file. For users
    that compile libtiff from sources, the fix is available with commit 33aee127.
- diff_content:
  - "--- a/tools/tiffcrop.c\n+++ b/tools/tiffcrop.c\n@@ -5935,18 +5935,40 @@ static\
    \ int computeInputPixelOffsets(struct crop_mask *crop,\n \n             crop->regionlist[i].buffsize\
    \ = buffsize;\n             crop->bufftotal += buffsize;\n+\n+            /* For\
    \ composite images with more than one region, the\n+             * combined_length\
    \ or combined_width always needs to be equal,\n+             * respectively.\n\
    +             * Otherwise, even the first section/region copy\n+             *\
    \ action might cause buffer overrun. */\n             if (crop->img_mode == COMPOSITE_IMAGES)\n\
    \             {\n                 switch (crop->edge_ref)\n                 {\n\
    \                     case EDGE_LEFT:\n                     case EDGE_RIGHT:\n\
    +                        if (i > 0 && zlength != crop->combined_length)\n+   \
    \                     {\n+                            TIFFError(\n+          \
    \                      \"computeInputPixelOffsets\",\n+                      \
    \          \"Only equal length regions can be combined for \"\n+             \
    \                   \"-E left or right\");\n+                            return\
    \ (-1);\n+                        }\n                         crop->combined_length\
    \ = zlength;\n                         crop->combined_width += zwidth;\n     \
    \                    break;\n                     case EDGE_BOTTOM:\n        \
    \             case EDGE_TOP: /* width from left, length from top */\n        \
    \             default:\n+                        if (i > 0 && zwidth != crop->combined_width)\n\
    +                        {\n+                            TIFFError(\"computeInputPixelOffsets\"\
    ,\n+                                      \"Only equal width regions can be \"\
    \n+                                      \"combined for -E \"\n+             \
    \                         \"top or bottom\");\n+                            return\
    \ (-1);\n+                        }\n                         crop->combined_width\
    \ = zwidth;\n                         crop->combined_length += zlength;\n    \
    \                     break;\n@@ -7301,6 +7323,46 @@ static int extractCompositeRegions(struct\
    \ image_data *image,\n     crop->combined_width = 0;\n     crop->combined_length\
    \ = 0;\n \n+    /* If there is more than one region, check beforehand whether\
    \ all the width\n+     * and length values of the regions are the same, respectively.\
    \ */\n+    switch (crop->edge_ref)\n+    {\n+        default:\n+        case EDGE_TOP:\n\
    +        case EDGE_BOTTOM:\n+            for (i = 1; i < crop->selections; i++)\n\
    +            {\n+                uint32_t crop_width0 =\n+                   \
    \ crop->regionlist[i - 1].x2 - crop->regionlist[i - 1].x1 + 1;\n+            \
    \    uint32_t crop_width1 =\n+                    crop->regionlist[i].x2 - crop->regionlist[i].x1\
    \ + 1;\n+                if (crop_width0 != crop_width1)\n+                {\n\
    +                    TIFFError(\"extractCompositeRegions\",\n+               \
    \               \"Only equal width regions can be combined for -E \"\n+      \
    \                        \"top or bottom\");\n+                    return (1);\n\
    +                }\n+            }\n+            break;\n+        case EDGE_LEFT:\n\
    +        case EDGE_RIGHT:\n+            for (i = 1; i < crop->selections; i++)\n\
    +            {\n+                uint32_t crop_length0 =\n+                  \
    \  crop->regionlist[i - 1].y2 - crop->regionlist[i - 1].y1 + 1;\n+           \
    \     uint32_t crop_length1 =\n+                    crop->regionlist[i].y2 - crop->regionlist[i].y1\
    \ + 1;\n+                if (crop_length0 != crop_length1)\n+                {\n\
    +                    TIFFError(\"extractCompositeRegions\",\n+               \
    \               \"Only equal length regions can be combined for \"\n+        \
    \                      \"-E left or right\");\n+                    return (1);\n\
    +                }\n+            }\n+    }\n+\n     for (i = 0; i < crop->selections;\
    \ i++)\n     {\n         /* rows, columns, width, length are expressed in pixels\
    \ */\n@@ -7325,7 +7387,8 @@ static int extractCompositeRegions(struct image_data\
    \ *image,\n             default:\n             case EDGE_TOP:\n             case\
    \ EDGE_BOTTOM:\n-                if ((i > 0) && (crop_width != crop->regionlist[i\
    \ - 1].width))\n+                if ((crop->selections > i + 1) &&\n+        \
    \            (crop_width != crop->regionlist[i + 1].width))\n                \
    \ {\n                     TIFFError(\"extractCompositeRegions\",\n           \
    \                    \"Only equal width regions can be combined for -E \"\n@@\
    \ -7418,7 +7481,8 @@ static int extractCompositeRegions(struct image_data *image,\n\
    \             case EDGE_LEFT: /* splice the pieces of each row together, side\
    \ by\n                                side */\n             case EDGE_RIGHT:\n\
    -                if ((i > 0) && (crop_length != crop->regionlist[i - 1].length))\n\
    +                if ((crop->selections > i + 1) &&\n+                    (crop_length\
    \ != crop->regionlist[i + 1].length))\n                 {\n                  \
    \   TIFFError(\"extractCompositeRegions\",\n                               \"\
    Only equal length regions can be combined for \"\n"
  identifiers:
  - CVE-2023-0804
  - CWE-787
  overview: LibTIFF 4.4.0 has an out-of-bounds write in tiffcrop in tools/tiffcrop.c:3609,
    allowing attackers to cause a denial-of-service via a crafted tiff file. For users
    that compile libtiff from sources, the fix is available with commit 33aee127.
  references:
  - source: cve@gitlab.com
    tags:
    - VDB Entry
    url: https://gitlab.com/gitlab-org/cves/-/blob/master/2023/CVE-2023-0804.json
  - source: cve@gitlab.com
    tags:
    - Patch
    url: https://gitlab.com/libtiff/libtiff/-/commit/33aee1275d9d1384791d2206776eb8152d397f00
  - source: cve@gitlab.com
    tags:
    - Exploit
    - Issue Tracking
    - Patch
    - Vendor Advisory
    url: https://gitlab.com/libtiff/libtiff/-/issues/497
  - source: cve@gitlab.com
    url: https://lists.debian.org/debian-lts-announce/2023/02/msg00026.html
  - source: cve@gitlab.com
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/FBF3UUFSB6NB3NFTQSKOOIZGXJP3T34Z/
  - source: cve@gitlab.com
    url: https://security.gentoo.org/glsa/202305-31
  - source: cve@gitlab.com
    url: https://security.netapp.com/advisory/ntap-20230324-0009/
  - source: cve@gitlab.com
    url: https://www.debian.org/security/2023/dsa-5361
  title: LibTIFF 4.4.0 has an out-of-bounds write in tiffcrop in tools/tiffcrop.c:3609,
    allowing attackers to cause a denial-of-service via a crafted tiff file. For users
    that compile libtiff from sources, the fix is available with commit 33aee127.
- diff_content:
  - "--- a/src/ntlm.c\n+++ b/src/ntlm.c\n@@ -256,6 +255,7 @@ static int ntlm_decode_oem_str(struct\
    \ wire_field_hdr *str_hdr,\n     str_offs = le32toh(str_hdr->offset);\n     if\
    \ ((str_offs < payload_offs) ||\n         (str_offs > buffer->length) ||\n+  \
    \      (UINT32_MAX - str_offs < str_len) ||\n         (str_offs + str_len > buffer->length))\
    \ {\n         return ERR_DECODE;\n     }\n@@ -308,6 +308,7 @@ static int ntlm_decode_u16l_str_hdr(struct\
    \ ntlm_ctx *ctx,\n     str_offs = le32toh(str_hdr->offset);\n     if ((str_offs\
    \ < payload_offs) ||\n         (str_offs > buffer->length) ||\n+        (UINT32_MAX\
    \ - str_offs < str_len) ||\n         (str_offs + str_len > buffer->length)) {\n\
    \         return ERR_DECODE;\n     }\n@@ -393,6 +394,7 @@ static int ntlm_decode_field(struct\
    \ wire_field_hdr *hdr,\n     offs = le32toh(hdr->offset);\n     if ((offs < payload_offs)\
    \ ||\n         (offs > buffer->length) ||\n+        (UINT32_MAX - offs < len)\
    \ ||\n         (offs + len > buffer->length)) {\n         return ERR_DECODE;\n\
    \     }"
  identifiers:
  - CVE-2023-25563
  - CWE-125
  overview: GSS-NTLMSSP is a mechglue plugin for the GSSAPI library that implements
    NTLM authentication. Prior to version 1.2.0, multiple out-of-bounds reads when
    decoding NTLM fields can trigger a denial of service. A 32-bit integer overflow
    condition can lead to incorrect checks of consistency of length of internal buffers.
    Although most applications will error out before accepting a singe input buffer
    of 4GB in length this could theoretically happen. This vulnerability can be triggered
    via the main `gss_accept_sec_context` entry point if the application allows tokens
    greater than 4GB in length. This can lead to a large, up to 65KB, out-of-bounds
    read which could cause a denial-of-service if it reads from unmapped memory. Version
    1.2.0 contains a patch for the out-of-bounds reads.
  references:
  - source: security-advisories@github.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/gssapi/gss-ntlmssp/commit/97c62c6167299028d80765080e74d91dfc99efbd
  - source: security-advisories@github.com
    tags:
    - Third Party Advisory
    url: https://github.com/gssapi/gss-ntlmssp/releases/tag/v1.2.0
  - source: security-advisories@github.com
    tags:
    - Third Party Advisory
    url: https://github.com/gssapi/gss-ntlmssp/security/advisories/GHSA-jjjx-5qf7-9mgf
  title: GSS-NTLMSSP is a mechglue plugin for the GSSAPI library that implements NTLM
    authentication. Prior to version 1.2.0, multiple out-of-bounds reads when decoding
    NTLM fields can trigger a denial of service. A 32-bit integer overflow condition
    can lead to incorrect checks of consistency of length of internal buffers. Although
    most applications will error out before accepting a singe input buffer of 4GB
    in length this could theoretically happen. This vulnerability can be triggered
    via the main `gss_accept_sec_context` entry point if the application allows tokens
    greater than 4GB in length. This can lead to a large, up to 65KB, out-of-bounds
    read which could cause a denial-of-service if it reads from unmapped memory. Version
    1.2.0 contains a patch for the out-of-bounds reads.
- diff_content:
  - "--- a/src/ntlm.c\n+++ b/src/ntlm.c\n@@ -299,7 +299,7 @@ static int ntlm_decode_u16l_str_hdr(struct\
    \ ntlm_ctx *ctx,\n     char *in, *out = NULL;\n     uint16_t str_len;\n     uint32_t\
    \ str_offs;\n-    size_t outlen;\n+    size_t outlen = 0;\n     int ret = 0;\n\
    \ \n     str_len = le16toh(str_hdr->len);\n@@ -320,13 +320,14 @@ static int ntlm_decode_u16l_str_hdr(struct\
    \ ntlm_ctx *ctx,\n \n     ret = ntlm_str_convert(ctx->to_oem, in, out, str_len,\
    \ &outlen);\n \n-    /* make sure to terminate output string */\n-    out[outlen]\
    \ = '\\0';\n-\n done:\n     if (ret) {\n         safefree(out);\n+    } else {\n\
    +        /* make sure to terminate output string */\n+        out[outlen] = '\\\
    0';\n     }\n+\n     *str = out;\n     return ret;\n }"
  identifiers:
  - CVE-2023-25564
  - CWE-787
  overview: GSS-NTLMSSP is a mechglue plugin for the GSSAPI library that implements
    NTLM authentication. Prior to version 1.2.0, memory corruption can be triggered
    when decoding UTF16 strings. The variable `outlen` was not initialized and could
    cause writing a zero to an arbitrary place in memory if `ntlm_str_convert()` were
    to fail, which would leave `outlen` uninitialized. This can lead to a denial of
    service if the write hits unmapped memory or randomly corrupts a byte in the application
    memory space. This vulnerability can trigger an out-of-bounds write, leading to
    memory corruption. This vulnerability can be triggered via the main `gss_accept_sec_context`
    entry point. This issue is fixed in version 1.2.0.
  references:
  - source: security-advisories@github.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/gssapi/gss-ntlmssp/commit/c753000eb31835c0664e528fbc99378ae0cbe950
  - source: security-advisories@github.com
    tags:
    - Third Party Advisory
    url: https://github.com/gssapi/gss-ntlmssp/releases/tag/v1.2.0
  - source: security-advisories@github.com
    tags:
    - Third Party Advisory
    url: https://github.com/gssapi/gss-ntlmssp/security/advisories/GHSA-r85x-q5px-9xfq
  title: GSS-NTLMSSP is a mechglue plugin for the GSSAPI library that implements NTLM
    authentication. Prior to version 1.2.0, memory corruption can be triggered when
    decoding UTF16 strings. The variable `outlen` was not initialized and could cause
    writing a zero to an arbitrary place in memory if `ntlm_str_convert()` were to
    fail, which would leave `outlen` uninitialized. This can lead to a denial of service
    if the write hits unmapped memory or randomly corrupts a byte in the application
    memory space. This vulnerability can trigger an out-of-bounds write, leading to
    memory corruption. This vulnerability can be triggered via the main `gss_accept_sec_context`
    entry point. This issue is fixed in version 1.2.0.
- diff_content:
  - "--- a/src/ntlm.c\n+++ b/src/ntlm.c\n@@ -731,8 +731,6 @@ int ntlm_decode_target_info(struct\
    \ ntlm_ctx *ctx, struct ntlm_buffer *buffer,\n \n done:\n     if (ret) {\n-  \
    \      ntlm_free_buffer_data(&sh);\n-        ntlm_free_buffer_data(&cb);\n   \
    \      safefree(nb_computer);\n         safefree(nb_domain);\n         safefree(dns_computer);"
  identifiers:
  - CVE-2023-25565
  - CWE-763
  overview: GSS-NTLMSSP is a mechglue plugin for the GSSAPI library that implements
    NTLM authentication. Prior to version 1.2.0, an incorrect free when decoding target
    information can trigger a denial of service. The error condition incorrectly assumes
    the `cb` and `sh` buffers contain a copy of the data that needs to be freed. However,
    that is not the case. This vulnerability can be triggered via the main `gss_accept_sec_context`
    entry point. This will likely trigger an assertion failure in `free`, causing
    a denial-of-service. This issue is fixed in version 1.2.0.
  references:
  - source: security-advisories@github.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/gssapi/gss-ntlmssp/commit/c16100f60907a2de92bcb676f303b81facee0f64
  - source: security-advisories@github.com
    tags:
    - Third Party Advisory
    url: https://github.com/gssapi/gss-ntlmssp/releases/tag/v1.2.0
  - source: security-advisories@github.com
    tags:
    - Third Party Advisory
    url: https://github.com/gssapi/gss-ntlmssp/security/advisories/GHSA-7q7f-wqcg-mvfg
  title: GSS-NTLMSSP is a mechglue plugin for the GSSAPI library that implements NTLM
    authentication. Prior to version 1.2.0, an incorrect free when decoding target
    information can trigger a denial of service. The error condition incorrectly assumes
    the `cb` and `sh` buffers contain a copy of the data that needs to be freed. However,
    that is not the case. This vulnerability can be triggered via the main `gss_accept_sec_context`
    entry point. This will likely trigger an assertion failure in `free`, causing
    a denial-of-service. This issue is fixed in version 1.2.0.
- diff_content:
  - "--- a/src/gss_names.c\n+++ b/src/gss_names.c\n@@ -136,7 +136,6 @@ static uint32_t\
    \ parse_user_name(uint32_t *minor_status,\n         /* we may have an enterprise\
    \ name here */\n         char strbuf[len + 1];\n         char *buf = strbuf;\n\
    -        bool domain_handled = false;\n \n         /* copy buf to manipulate it\
    \ */\n         memcpy(buf, str, len);\n@@ -160,9 +159,6 @@ static uint32_t parse_user_name(uint32_t\
    \ *minor_status,\n         }\n \n         if (sep) {\n-            /* leading\
    \ domain, copy if domain name is not empty */\n-            domain_handled = true;\n\
    -\n             /* terminate and copy domain, even if empty */\n             /*\
    \ NOTE: this is important for the Windbind integration case\n              * where\
    \ we need to tell the machinery to *not* add the default\n@@ -180,7 +176,7 @@\
    \ static uint32_t parse_user_name(uint32_t *minor_status,\n \n         for (at\
    \ = strchr(buf, '@'); at != NULL; at = strchr(at, '@')) {\n             if (*(at\
    \ - 1) == '\\\\') {\n-                if (domain_handled) {\n+               \
    \ if (*domain) {\n                     /* Invalid forms like DOM\\foo\\@bar or\
    \ foo@bar\\@baz */\n                     free(*domain);\n                    \
    \ *domain = NULL;\n@@ -189,7 +185,7 @@ static uint32_t parse_user_name(uint32_t\
    \ *minor_status,\n                 }\n                 /* remove escape, moving\
    \ all including terminating '\\0' */\n                 memmove(at - 1, at, len\
    \ - (at - buf) + 1);\n-            } else if (!domain_handled) {\n+          \
    \  } else if (!*domain) {\n                 /* an '@' without escape and no previous\n\
    \                  * domain was split out.\n                  * the rest of the\
    \ string is the domain */"
  identifiers:
  - CVE-2023-25566
  - CWE-401
  overview: 'GSS-NTLMSSP is a mechglue plugin for the GSSAPI library that implements
    NTLM authentication. Prior to version 1.2.0, a memory leak can be triggered when
    parsing usernames which can trigger a denial-of-service. The domain portion of
    a username may be overridden causing an allocated memory area the size of the
    domain name to be leaked. An attacker can leak memory via the main `gss_accept_sec_context`
    entry point, potentially causing a denial-of-service. This issue is fixed in version
    1.2.0.


    '
  references:
  - source: security-advisories@github.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/gssapi/gss-ntlmssp/commit/8660fb16474054e692a596e9c79670cd4d3954f4
  - source: security-advisories@github.com
    tags:
    - Third Party Advisory
    url: https://github.com/gssapi/gss-ntlmssp/releases/tag/v1.2.0
  - source: security-advisories@github.com
    tags:
    - Third Party Advisory
    url: https://github.com/gssapi/gss-ntlmssp/security/advisories/GHSA-mfm4-6g58-jw74
  title: 'GSS-NTLMSSP is a mechglue plugin for the GSSAPI library that implements
    NTLM authentication. Prior to version 1.2.0, a memory leak can be triggered when
    parsing usernames which can trigger a denial-of-service. The domain portion of
    a username may be overridden causing an allocated memory area the size of the
    domain name to be leaked. An attacker can leak memory via the main `gss_accept_sec_context`
    entry point, potentially causing a denial-of-service. This issue is fixed in version
    1.2.0.


    '
- diff_content:
  - "--- a/src/ntlm.c\n+++ b/src/ntlm.c\n@@ -685,11 +685,19 @@ int ntlm_decode_target_info(struct\
    \ ntlm_ctx *ctx, struct ntlm_buffer *buffer,\n             break;\n         case\
    \ MSV_AV_TIMESTAMP:\n             if (!av_timestamp) continue;\n+            if\
    \ (av_len < sizeof(timestamp)) {\n+                ret = ERR_DECODE;\n+      \
    \          goto done;\n+            }\n             memcpy(&timestamp, av_pair->value,\
    \ sizeof(timestamp));\n             timestamp = le64toh(timestamp);\n        \
    \     break;\n         case MSV_AV_FLAGS:\n             if (!av_flags) continue;\n\
    +            if (av_len < sizeof(flags)) {\n+                ret = ERR_DECODE;\n\
    +                goto done;\n+            }\n             memcpy(&flags, av_pair->value,\
    \ sizeof(flags));\n             flags = le32toh(flags);\n             break;"
  identifiers:
  - CVE-2023-25567
  - CWE-125
  overview: GSS-NTLMSSP, a mechglue plugin for the GSSAPI library that implements
    NTLM authentication, has an out-of-bounds read when decoding target information
    prior to version 1.2.0. The length of the `av_pair` is not checked properly for
    two of the elements which can trigger an out-of-bound read. The out-of-bounds
    read can be triggered via the main `gss_accept_sec_context` entry point and could
    cause a denial-of-service if the memory is unmapped. The issue is fixed in version
    1.2.0.
  references:
  - source: security-advisories@github.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/gssapi/gss-ntlmssp/commit/025fbb756d44ffee8f847db4222ed6aa4bd1fbe4
  - source: security-advisories@github.com
    tags:
    - Third Party Advisory
    url: https://github.com/gssapi/gss-ntlmssp/releases/tag/v1.2.0
  - source: security-advisories@github.com
    tags:
    - Third Party Advisory
    url: https://github.com/gssapi/gss-ntlmssp/security/advisories/GHSA-24pf-6prf-24ch
  title: GSS-NTLMSSP, a mechglue plugin for the GSSAPI library that implements NTLM
    authentication, has an out-of-bounds read when decoding target information prior
    to version 1.2.0. The length of the `av_pair` is not checked properly for two
    of the elements which can trigger an out-of-bound read. The out-of-bounds read
    can be triggered via the main `gss_accept_sec_context` entry point and could cause
    a denial-of-service if the memory is unmapped. The issue is fixed in version 1.2.0.
- diff_content:
  - "--- a/apply.c\n+++ b/apply.c\n@@ -4418,6 +4418,33 @@ static int create_one_file(struct\
    \ apply_state *state,\n \tif (state->cached)\n \t\treturn 0;\n \n+\t/*\n+\t *\
    \ We already try to detect whether files are beyond a symlink in our\n+\t * up-front\
    \ checks. But in the case where symlinks are created by any\n+\t * of the intermediate\
    \ hunks it can happen that our up-front checks\n+\t * didn't yet see the symlink,\
    \ but at the point of arriving here there\n+\t * in fact is one. We thus repeat\
    \ the check for symlinks here.\n+\t *\n+\t * Note that this does not make the\
    \ up-front check obsolete as the\n+\t * failure mode is different:\n+\t *\n+\t\
    \ * - The up-front checks cause us to abort before we have written\n+\t *   anything\
    \ into the working directory. So when we exit this way the\n+\t *   working directory\
    \ remains clean.\n+\t *\n+\t * - The checks here happen in the middle of the action\
    \ where we have\n+\t *   already started to apply the patch. The end result will\
    \ be a dirty\n+\t *   working directory.\n+\t *\n+\t * Ideally, we should update\
    \ the up-front checks to catch what would\n+\t * happen when we apply the patch\
    \ before we damage the working tree.\n+\t * We have all the information necessary\
    \ to do so.  But for now, as a\n+\t * part of embargoed security work, having\
    \ this check would serve as a\n+\t * reasonable first step.\n+\t */\n+\tif (path_is_beyond_symlink(state,\
    \ path))\n+\t\treturn error(_(\"affected file '%s' is beyond a symbolic link\"\
    ), path);\n+\n \tres = try_create_file(state, path, mode, buf, size);\n \tif (res\
    \ < 0)\n \t\treturn -1;"
  - "--- a/builtin/clone.c\n+++ b/builtin/clone.c\n@@ -1170,10 +1170,6 @@ int cmd_clone(int\
    \ argc, const char **argv, const char *prefix)\n \trefspec_appendf(&remote->fetch,\
    \ \"+%s*:%s*\", src_ref_prefix,\n \t\t\tbranch_top.buf);\n \n-\ttransport = transport_get(remote,\
    \ remote->url[0]);\n-\ttransport_set_verbosity(transport, option_verbosity, option_progress);\n\
    -\ttransport->family = family;\n-\n \tpath = get_repo_path(remote->url[0], &is_bundle);\n\
    \ \tis_local = option_local != 0 && path && !is_bundle;\n \tif (is_local) {\n\
    @@ -1195,6 +1191,10 @@ int cmd_clone(int argc, const char **argv, const char *prefix)\n\
    \ \t}\n \tif (option_local > 0 && !is_local)\n \t\twarning(_(\"--local is ignored\"\
    ));\n+\n+\ttransport = transport_get(remote, path ? path : remote->url[0]);\n\
    +\ttransport_set_verbosity(transport, option_verbosity, option_progress);\n+\t\
    transport->family = family;\n \ttransport->cloning = 1;\n \n \tif (is_bundle)\
    \ {"
  - "--- a/dir-iterator.c\n+++ b/dir-iterator.c\n@@ -203,7 +203,7 @@ struct dir_iterator\
    \ *dir_iterator_begin(const char *path, unsigned int flags)\n {\n \tstruct dir_iterator_int\
    \ *iter = xcalloc(1, sizeof(*iter));\n \tstruct dir_iterator *dir_iterator = &iter->base;\n\
    -\tint saved_errno;\n+\tint saved_errno, err;\n \n \tstrbuf_init(&iter->base.path,\
    \ PATH_MAX);\n \tstrbuf_addstr(&iter->base.path, path);\n@@ -213,10 +213,15 @@\
    \ struct dir_iterator *dir_iterator_begin(const char *path, unsigned int flags)\n\
    \ \titer->flags = flags;\n \n \t/*\n-\t * Note: stat already checks for NULL or\
    \ empty strings and\n-\t * inexistent paths.\n+\t * Note: stat/lstat already checks\
    \ for NULL or empty strings and\n+\t * nonexistent paths.\n \t */\n-\tif (stat(iter->base.path.buf,\
    \ &iter->base.st) < 0) {\n+\tif (iter->flags & DIR_ITERATOR_FOLLOW_SYMLINKS)\n\
    +\t\terr = stat(iter->base.path.buf, &iter->base.st);\n+\telse\n+\t\terr = lstat(iter->base.path.buf,\
    \ &iter->base.st);\n+\n+\tif (err < 0) {\n \t\tsaved_errno = errno;\n \t\tgoto\
    \ error_out;\n \t}"
  identifiers:
  - CVE-2023-22490
  - CWE-59
  overview: 'Git is a revision control system. Using a specially-crafted repository,
    Git prior to versions 2.39.2, 2.38.4, 2.37.6, 2.36.5, 2.35.7, 2.34.7, 2.33.7,
    2.32.6, 2.31.7, and 2.30.8 can be tricked into using its local clone optimization
    even when using a non-local transport. Though Git will abort local clones whose
    source `$GIT_DIR/objects` directory contains symbolic links, the `objects` directory
    itself may still be a symbolic link. These two may be combined to include arbitrary
    files based on known paths on the victim''s filesystem within the malicious repository''s
    working copy, allowing for data exfiltration in a similar manner as CVE-2022-39253.


    A fix has been prepared and will appear in v2.39.2 v2.38.4 v2.37.6 v2.36.5 v2.35.7
    v2.34.7 v2.33.7 v2.32.6, v2.31.7 and v2.30.8. If upgrading is impractical, two
    short-term workarounds are available. Avoid cloning repositories from untrusted
    sources with `--recurse-submodules`. Instead, consider cloning repositories without
    recursively cloning their submodules, and instead run `git submodule update` at
    each layer. Before doing so, inspect each new `.gitmodules` file to ensure that
    it does not contain suspicious module URLs.'
  references:
  - source: security-advisories@github.com
    tags:
    - Patch
    url: https://github.com/git/git/commit/c867e4fa180bec4750e9b54eb10f459030dbebfd
  - source: security-advisories@github.com
    tags:
    - Vendor Advisory
    url: https://github.com/git/git/security/advisories/GHSA-3wp6-j8xr-qw85
  - source: security-advisories@github.com
    tags:
    - Vendor Advisory
    url: https://github.com/git/git/security/advisories/GHSA-gw92-x3fm-3g3q
  - source: security-advisories@github.com
    url: https://security.gentoo.org/glsa/202312-15
  title: 'Git is a revision control system. Using a specially-crafted repository,
    Git prior to versions 2.39.2, 2.38.4, 2.37.6, 2.36.5, 2.35.7, 2.34.7, 2.33.7,
    2.32.6, 2.31.7, and 2.30.8 can be tricked into using its local clone optimization
    even when using a non-local transport. Though Git will abort local clones whose
    source `$GIT_DIR/objects` directory contains symbolic links, the `objects` directory
    itself may still be a symbolic link. These two may be combined to include arbitrary
    files based on known paths on the victim''s filesystem within the malicious repository''s
    working copy, allowing for data exfiltration in a similar manner as CVE-2022-39253.


    A fix has been prepared and will appear in v2.39.2 v2.38.4 v2.37.6 v2.36.5 v2.35.7
    v2.34.7 v2.33.7 v2.32.6, v2.31.7 and v2.30.8. If upgrading is impractical, two
    short-term workarounds are available. Avoid cloning repositories from untrusted
    sources with `--recurse-submodules`. Instead, consider cloning repositories without
    recursively cloning their submodules, and instead run `git submodule update` at
    each layer. Before doing so, inspect each new `.gitmodules` file to ensure that
    it does not contain suspicious module URLs.'
- diff_content:
  - "--- a/apply.c\n+++ b/apply.c\n@@ -4418,6 +4418,33 @@ static int create_one_file(struct\
    \ apply_state *state,\n \tif (state->cached)\n \t\treturn 0;\n \n+\t/*\n+\t *\
    \ We already try to detect whether files are beyond a symlink in our\n+\t * up-front\
    \ checks. But in the case where symlinks are created by any\n+\t * of the intermediate\
    \ hunks it can happen that our up-front checks\n+\t * didn't yet see the symlink,\
    \ but at the point of arriving here there\n+\t * in fact is one. We thus repeat\
    \ the check for symlinks here.\n+\t *\n+\t * Note that this does not make the\
    \ up-front check obsolete as the\n+\t * failure mode is different:\n+\t *\n+\t\
    \ * - The up-front checks cause us to abort before we have written\n+\t *   anything\
    \ into the working directory. So when we exit this way the\n+\t *   working directory\
    \ remains clean.\n+\t *\n+\t * - The checks here happen in the middle of the action\
    \ where we have\n+\t *   already started to apply the patch. The end result will\
    \ be a dirty\n+\t *   working directory.\n+\t *\n+\t * Ideally, we should update\
    \ the up-front checks to catch what would\n+\t * happen when we apply the patch\
    \ before we damage the working tree.\n+\t * We have all the information necessary\
    \ to do so.  But for now, as a\n+\t * part of embargoed security work, having\
    \ this check would serve as a\n+\t * reasonable first step.\n+\t */\n+\tif (path_is_beyond_symlink(state,\
    \ path))\n+\t\treturn error(_(\"affected file '%s' is beyond a symbolic link\"\
    ), path);\n+\n \tres = try_create_file(state, path, mode, buf, size);\n \tif (res\
    \ < 0)\n \t\treturn -1;"
  - "--- a/builtin/clone.c\n+++ b/builtin/clone.c\n@@ -1170,10 +1170,6 @@ int cmd_clone(int\
    \ argc, const char **argv, const char *prefix)\n \trefspec_appendf(&remote->fetch,\
    \ \"+%s*:%s*\", src_ref_prefix,\n \t\t\tbranch_top.buf);\n \n-\ttransport = transport_get(remote,\
    \ remote->url[0]);\n-\ttransport_set_verbosity(transport, option_verbosity, option_progress);\n\
    -\ttransport->family = family;\n-\n \tpath = get_repo_path(remote->url[0], &is_bundle);\n\
    \ \tis_local = option_local != 0 && path && !is_bundle;\n \tif (is_local) {\n\
    @@ -1195,6 +1191,10 @@ int cmd_clone(int argc, const char **argv, const char *prefix)\n\
    \ \t}\n \tif (option_local > 0 && !is_local)\n \t\twarning(_(\"--local is ignored\"\
    ));\n+\n+\ttransport = transport_get(remote, path ? path : remote->url[0]);\n\
    +\ttransport_set_verbosity(transport, option_verbosity, option_progress);\n+\t\
    transport->family = family;\n \ttransport->cloning = 1;\n \n \tif (is_bundle)\
    \ {"
  - "--- a/dir-iterator.c\n+++ b/dir-iterator.c\n@@ -203,7 +203,7 @@ struct dir_iterator\
    \ *dir_iterator_begin(const char *path, unsigned int flags)\n {\n \tstruct dir_iterator_int\
    \ *iter = xcalloc(1, sizeof(*iter));\n \tstruct dir_iterator *dir_iterator = &iter->base;\n\
    -\tint saved_errno;\n+\tint saved_errno, err;\n \n \tstrbuf_init(&iter->base.path,\
    \ PATH_MAX);\n \tstrbuf_addstr(&iter->base.path, path);\n@@ -213,10 +213,15 @@\
    \ struct dir_iterator *dir_iterator_begin(const char *path, unsigned int flags)\n\
    \ \titer->flags = flags;\n \n \t/*\n-\t * Note: stat already checks for NULL or\
    \ empty strings and\n-\t * inexistent paths.\n+\t * Note: stat/lstat already checks\
    \ for NULL or empty strings and\n+\t * nonexistent paths.\n \t */\n-\tif (stat(iter->base.path.buf,\
    \ &iter->base.st) < 0) {\n+\tif (iter->flags & DIR_ITERATOR_FOLLOW_SYMLINKS)\n\
    +\t\terr = stat(iter->base.path.buf, &iter->base.st);\n+\telse\n+\t\terr = lstat(iter->base.path.buf,\
    \ &iter->base.st);\n+\n+\tif (err < 0) {\n \t\tsaved_errno = errno;\n \t\tgoto\
    \ error_out;\n \t}"
  identifiers:
  - CVE-2023-23946
  - CWE-22
  overview: Git, a revision control system, is vulnerable to path traversal prior
    to versions 2.39.2, 2.38.4, 2.37.6, 2.36.5, 2.35.7, 2.34.7, 2.33.7, 2.32.6, 2.31.7,
    and 2.30.8. By feeding a crafted input to `git apply`, a path outside the working
    tree can be overwritten as the user who is running `git apply`. A fix has been
    prepared and will appear in v2.39.2, v2.38.4, v2.37.6, v2.36.5, v2.35.7, v2.34.7,
    v2.33.7, v2.32.6, v2.31.7, and v2.30.8. As a workaround, use `git apply --stat`
    to inspect a patch before applying; avoid applying one that creates a symbolic
    link and then creates a file beyond the symbolic link.
  references:
  - source: security-advisories@github.com
    tags:
    - Patch
    url: https://github.com/git/git/commit/c867e4fa180bec4750e9b54eb10f459030dbebfd
  - source: security-advisories@github.com
    tags:
    - Vendor Advisory
    url: https://github.com/git/git/security/advisories/GHSA-r87m-v37r-cwfh
  - source: security-advisories@github.com
    url: https://security.gentoo.org/glsa/202312-15
  title: Git, a revision control system, is vulnerable to path traversal prior to
    versions 2.39.2, 2.38.4, 2.37.6, 2.36.5, 2.35.7, 2.34.7, 2.33.7, 2.32.6, 2.31.7,
    and 2.30.8. By feeding a crafted input to `git apply`, a path outside the working
    tree can be overwritten as the user who is running `git apply`. A fix has been
    prepared and will appear in v2.39.2, v2.38.4, v2.37.6, v2.36.5, v2.35.7, v2.34.7,
    v2.33.7, v2.32.6, v2.31.7, and v2.30.8. As a workaround, use `git apply --stat`
    to inspect a patch before applying; avoid applying one that creates a symbolic
    link and then creates a file beyond the symbolic link.
- diff_content:
  - "--- a/src/filters/reframe_adts.c\n+++ b/src/filters/reframe_adts.c\n@@ -824,6\
    \ +824,12 @@ GF_Err adts_dmx_process(GF_Filter *filter)\n \t\t}\n \n \t\tif (!ctx->in_seek)\
    \ {\n+\n+\t\t\tif (sync_pos + offset + size > remain) {\n+\t\t\t\tGF_LOG(GF_LOG_WARNING,\
    \ GF_LOG_MEDIA, (\"[ADTSDmx] truncated frame\\n\"));\n+\t\t\t\tbreak;\n+\t\t\t\
    }\n+\n \t\t\tdst_pck = gf_filter_pck_new_alloc(ctx->opid, size, &output);\n \t\
    \t\tif (!dst_pck) return GF_OUT_OF_MEM;\n \t\t\tif (ctx->src_pck) gf_filter_pck_merge_properties(ctx->src_pck,\
    \ dst_pck);"
  identifiers:
  - CVE-2023-0866
  - CWE-122
  overview: Heap-based Buffer Overflow in GitHub repository gpac/gpac prior to 2.3.0-DEV.
  references:
  - source: security@huntr.dev
    tags:
    - Patch
    url: https://github.com/gpac/gpac/commit/b964fe4226f1424cf676d5822ef898b6b01f5937
  - source: security@huntr.dev
    tags:
    - Exploit
    - Patch
    - Third Party Advisory
    url: https://huntr.dev/bounties/7d3c5792-d20b-4cb6-9c6d-bb14f3430d7f
  - source: security@huntr.dev
    url: https://www.debian.org/security/2023/dsa-5411
  title: Heap-based Buffer Overflow in GitHub repository gpac/gpac prior to 2.3.0-DEV.
- diff_content:
  - "--- a/src/libraw_datastream.cpp\n+++ b/src/libraw_datastream.cpp\n@@ -287,6 +287,7\
    \ @@ INT64 LibRaw_file_datastream::tell()\n \n char *LibRaw_file_datastream::gets(char\
    \ *str, int sz)\n {\n+  if(sz<1) return NULL;\n   LR_STREAM_CHK();\n   std::istream\
    \ is(f.get());\n   is.getline(str, sz);\n@@ -421,6 +422,7 @@ INT64 LibRaw_buffer_datastream::tell()\n\
    \ \n char *LibRaw_buffer_datastream::gets(char *s, int sz)\n {\n+  if(sz<1) return\
    \ NULL;\n   unsigned char *psrc, *pdest, *str;\n   str = (unsigned char *)s;\n\
    \   psrc = buf + streampos;\n@@ -618,6 +620,7 @@ INT64 LibRaw_bigfile_datastream::tell()\n\
    \ \n char *LibRaw_bigfile_datastream::gets(char *str, int sz)\n {\n+  if(sz<1)\
    \ return NULL;\n   LR_BF_CHK();\n   return fgets(str, sz, f);\n }"
  identifiers:
  - CVE-2021-32142
  - CWE-787
  overview: Buffer Overflow vulnerability in LibRaw linux/unix v0.20.0 allows attacker
    to escalate privileges via the LibRaw_buffer_datastream::gets(char*, int) in /src/libraw/src/libraw_datastream.cpp.
  references:
  - source: cve@mitre.org
    tags:
    - Patch
    url: https://github.com/LibRaw/LibRaw/commit/bc3aaf4223fdb70d52d470dae65c5a7923ea2a49
  - source: cve@mitre.org
    tags:
    - Exploit
    - Issue Tracking
    url: https://github.com/LibRaw/LibRaw/issues/400
  - source: cve@mitre.org
    tags:
    - Not Applicable
    url: https://github.com/gtt1995
  - source: cve@mitre.org
    url: https://lists.debian.org/debian-lts-announce/2023/05/msg00025.html
  - source: cve@mitre.org
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/5ICTVDRGBWGIFBTUWJLGX7QM5GWBWUG7/
  - source: cve@mitre.org
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/E7TEZ7CLRNYYQZJ5NJGZXK6YJU46WH2L/
  - source: cve@mitre.org
    url: https://www.debian.org/security/2023/dsa-5412
  - source: cve@mitre.org
    tags:
    - Product
    url: https://www.libraw.org/
  title: Buffer Overflow vulnerability in LibRaw linux/unix v0.20.0 allows attacker
    to escalate privileges via the LibRaw_buffer_datastream::gets(char*, int) in /src/libraw/src/libraw_datastream.cpp.
- diff_content:
  - "--- a/fmt/mtm.c\n+++ b/fmt/mtm.c\n@@ -207,7 +207,6 @@ int fmt_mtm_load_song(song_t\
    \ *song, slurp_t *fp, unsigned int lflags)\n \n \t\tsong->patterns[pat] = csf_allocate_pattern(MAX(rows,\
    \ 32));\n \t\tsong->pattern_size[pat] = song->pattern_alloc_size[pat] = 64;\n\
    -\t\ttracknote = trackdata[n];\n \t\tfor (chan = 0; chan < 32; chan++) {\n \t\t\
    \tslurp_read(fp, &tmp, 2);\n \t\t\ttmp = bswapLE16(tmp);"
  identifiers:
  - CVE-2021-32419
  - CWE-787
  overview: An issue in Schism Tracker v20200412 fixed in v.20200412 allows attacker
    to obtain sensitive information via the fmt_mtm_load_song function in fmt/mtm.c.
  references:
  - source: cve@mitre.org
    tags:
    - Patch
    url: https://github.com/schismtracker/schismtracker/commit/1e2cc389a2a058fd13d99460c11115a6f7f7a6a4
  - source: cve@mitre.org
    tags:
    - Exploit
    - Issue Tracking
    - Vendor Advisory
    url: https://github.com/schismtracker/schismtracker/issues/249
  title: An issue in Schism Tracker v20200412 fixed in v.20200412 allows attacker
    to obtain sensitive information via the fmt_mtm_load_song function in fmt/mtm.c.
- diff_content:
  - "--- a/src/lib/virtio.c\n+++ b/src/lib/virtio.c\n@@ -559,7 +559,10 @@ vi_pci_read(UNUSED\
    \ int vcpu, struct pci_devinst *pi, int baridx,\n \t\tmax = vc->vc_cfgsize ? vc->vc_cfgsize\
    \ : 0x100000000;\n \t\tif ((newoff + ((unsigned) size)) > max)\n \t\t\tgoto bad;\n\
    -\t\terror = (*vc->vc_cfgread)(DEV_SOFTC(vs), ((int) newoff), size, &value);\n\
    +\t\tif (vc->vc_cfgread != NULL)\n+\t\t\terror = (*vc->vc_cfgread)(DEV_SOFTC(vs),\
    \ ((int) newoff), size, &value);\n+\t\telse\n+\t\t\terror = 0;\n \t\tif (!error)\n\
    \ \t\t\tgoto done;\n \t}"
  identifiers:
  - CVE-2021-32843
  - CWE-476
  overview: HyperKit is a toolkit for embedding hypervisor capabilities in an application.
    In versions 0.20210107 and prior of HyperKit, `virtio.c` has is a call to `vc_cfgread`
    that does not check for null which when called makes the host crash. This issue
    may lead to a guest crashing the host causing a denial of service. This issue
    is fixed in commit df0e46c7dbfd81a957d85e449ba41b52f6f7beb4.
  references:
  - source: security-advisories@github.com
    tags:
    - Patch
    url: https://github.com/moby/hyperkit/commit/df0e46c7dbfd81a957d85e449ba41b52f6f7beb4
  - source: security-advisories@github.com
    tags:
    - Patch
    url: https://github.com/moby/hyperkit/pull/313
  - source: security-advisories@github.com
    tags:
    - Third Party Advisory
    url: https://securitylab.github.com/advisories/GHSL-2021-054_057-moby-hyperkit/
  title: HyperKit is a toolkit for embedding hypervisor capabilities in an application.
    In versions 0.20210107 and prior of HyperKit, `virtio.c` has is a call to `vc_cfgread`
    that does not check for null which when called makes the host crash. This issue
    may lead to a guest crashing the host causing a denial of service. This issue
    is fixed in commit df0e46c7dbfd81a957d85e449ba41b52f6f7beb4.
- diff_content:
  - "--- a/src/lib/virtio.c\n+++ b/src/lib/virtio.c\n@@ -681,8 +681,11 @@ vi_pci_write(UNUSED\
    \ int vcpu, struct pci_devinst *pi, int baridx,\n \t\tmax = vc->vc_cfgsize ? vc->vc_cfgsize\
    \ : 0x100000000;\n \t\tif ((newoff + ((unsigned) size)) > max)\n \t\t\tgoto bad;\n\
    -\t\terror = (*vc->vc_cfgwrite)(DEV_SOFTC(vs), ((int) newoff), size,\n-\t\t\t\
    ((uint32_t) value));\n+\t\tif (vc->vc_cfgwrite != NULL)\n+\t\t\terror = (*vc->vc_cfgwrite)(DEV_SOFTC(vs),\
    \ ((int) newoff), size,\n+\t\t\t\t((uint32_t) value));\n+\t\telse\n+\t\t\terror\
    \ = 0;\n \t\tif (!error)\n \t\t\tgoto done;\n \t}"
  identifiers:
  - CVE-2021-32844
  - CWE-476
  overview: HyperKit is a toolkit for embedding hypervisor capabilities in an application.
    In versions 0.20210107 and prior of HyperKit, ` vi_pci_write` has is a call to
    `vc_cfgwrite` that does not check for null which when called makes the host crash.
    This issue may lead to a guest crashing the host causing a denial of service.
    This issue is fixed in commit 451558fe8aaa8b24e02e34106e3bb9fe41d7ad13.
  references:
  - source: security-advisories@github.com
    tags:
    - Patch
    url: https://github.com/moby/hyperkit/commit/451558fe8aaa8b24e02e34106e3bb9fe41d7ad13
  - source: security-advisories@github.com
    tags:
    - Patch
    url: https://github.com/moby/hyperkit/pull/313
  - source: security-advisories@github.com
    tags:
    - Third Party Advisory
    url: https://securitylab.github.com/advisories/GHSL-2021-054_057-moby-hyperkit/
  title: HyperKit is a toolkit for embedding hypervisor capabilities in an application.
    In versions 0.20210107 and prior of HyperKit, ` vi_pci_write` has is a call to
    `vc_cfgwrite` that does not check for null which when called makes the host crash.
    This issue may lead to a guest crashing the host causing a denial of service.
    This issue is fixed in commit 451558fe8aaa8b24e02e34106e3bb9fe41d7ad13.
- diff_content:
  - "--- a/src/lib/pci_virtio_rnd.c\n+++ b/src/lib/pci_virtio_rnd.c\n@@ -100,7 +100,7\
    \ @@ pci_vtrnd_notify(void *vsc, struct vqueue_info *vq)\n {\n \tstruct iovec\
    \ iov;\n \tstruct pci_vtrnd_softc *sc;\n-\tint len;\n+\tint len, n;\n \tuint16_t\
    \ idx;\n \n \tsc = vsc;\n@@ -111,7 +111,11 @@ pci_vtrnd_notify(void *vsc, struct\
    \ vqueue_info *vq)\n \t}\n \n \twhile (vq_has_descs(vq)) {\n-\t\tvq_getchain(vq,\
    \ &idx, &iov, 1, NULL);\n+\t\tn = vq_getchain(vq, &idx, &iov, 1, NULL);\n+\t\t\
    if (n < 0) {\n+\t\t\tfprintf(stderr, \"vtrnd: vtrnd_notify(): n %d\\r\\n\", n);\n\
    +\t\t\treturn;\n+\t\t}\n \n \t\tlen = (int) read(sc->vrsc_fd, iov.iov_base, iov.iov_len);\n\
    \ "
  identifiers:
  - CVE-2021-32845
  - CWE-252
  overview: HyperKit is a toolkit for embedding hypervisor capabilities in an application.
    In versions 0.20210107 and prior of HyperKit, the implementation of `qnotify`
    at `pci_vtrnd_notify` fails to check the return value of `vq_getchain`. This leads
    to `struct iovec iov;` being uninitialized and used to read memory in `len = (int)
    read(sc->vrsc_fd, iov.iov_base, iov.iov_len);` when an attacker is able to make
    `vq_getchain` fail. This issue may lead to a guest crashing the host causing a
    denial of service and, under certain circumstance, memory corruption. This issue
    is fixed in commit 41272a980197917df8e58ff90642d14dec8fe948.
  references:
  - source: security-advisories@github.com
    tags:
    - Patch
    url: https://github.com/moby/hyperkit/commit/41272a980197917df8e58ff90642d14dec8fe948
  - source: security-advisories@github.com
    tags:
    - Patch
    url: https://github.com/moby/hyperkit/pull/313
  - source: security-advisories@github.com
    tags:
    - Third Party Advisory
    url: https://securitylab.github.com/advisories/GHSL-2021-054_057-moby-hyperkit/
  title: HyperKit is a toolkit for embedding hypervisor capabilities in an application.
    In versions 0.20210107 and prior of HyperKit, the implementation of `qnotify`
    at `pci_vtrnd_notify` fails to check the return value of `vq_getchain`. This leads
    to `struct iovec iov;` being uninitialized and used to read memory in `len = (int)
    read(sc->vrsc_fd, iov.iov_base, iov.iov_len);` when an attacker is able to make
    `vq_getchain` fail. This issue may lead to a guest crashing the host causing a
    denial of service and, under certain circumstance, memory corruption. This issue
    is fixed in commit 41272a980197917df8e58ff90642d14dec8fe948.
- diff_content:
  - "--- a/src/lib/pci_virtio_sock.c\n+++ b/src/lib/pci_virtio_sock.c\n@@ -1121,6\
    \ +1121,11 @@ static void pci_vtsock_proc_tx(struct pci_vtsock_softc *sc,\n \t\
    size_t pulled;\n \n \tiovec_len = vq_getchain(vq, &idx, iov, VTSOCK_MAXSEGS, flags);\n\
    +\tif (iovec_len < 0) {\n+\t\tfprintf(stderr, \"TX: failed to get chain at idx\
    \ %\"PRIx16\"\\n\", idx);\n+\t\treturn;\n+\t}\n+\n \tassert(iovec_len <= VTSOCK_MAXSEGS);\n\
    \ \n \tDPRINTF((\"TX: chain with %d buffers at idx %\"PRIx16\"\\n\","
  identifiers:
  - CVE-2021-32846
  - CWE-754
  overview: HyperKit is a toolkit for embedding hypervisor capabilities in an application.
    In versions 0.20210107, function `pci_vtsock_proc_tx` in `virtio-sock` can lead
    to to uninitialized memory use. In this situation, there is a check for the return
    value to be less or equal to `VTSOCK_MAXSEGS`, but that check is not sufficient
    because the function can return `-1` if it finds an error it cannot recover from.
    Moreover, the negative return value will be used by `iovec_pull` in a while condition
    that can further lead to more corruption because the function is not designed
    to handle a negative `iov_len`. This issue may lead to a guest crashing the host
    causing a denial of service and, under certain circumstance, memory corruption.
    This issue is fixed in commit af5eba2360a7351c08dfd9767d9be863a50ebaba.
  references:
  - source: security-advisories@github.com
    tags:
    - Patch
    url: https://github.com/moby/hyperkit/commit/af5eba2360a7351c08dfd9767d9be863a50ebaba
  - source: security-advisories@github.com
    tags:
    - Patch
    url: https://github.com/moby/hyperkit/pull/313
  - source: security-advisories@github.com
    tags:
    - Third Party Advisory
    url: https://securitylab.github.com/advisories/GHSL-2021-054_057-moby-hyperkit/
  title: HyperKit is a toolkit for embedding hypervisor capabilities in an application.
    In versions 0.20210107, function `pci_vtsock_proc_tx` in `virtio-sock` can lead
    to to uninitialized memory use. In this situation, there is a check for the return
    value to be less or equal to `VTSOCK_MAXSEGS`, but that check is not sufficient
    because the function can return `-1` if it finds an error it cannot recover from.
    Moreover, the negative return value will be used by `iovec_pull` in a while condition
    that can further lead to more corruption because the function is not designed
    to handle a negative `iov_len`. This issue may lead to a guest crashing the host
    causing a denial of service and, under certain circumstance, memory corruption.
    This issue is fixed in commit af5eba2360a7351c08dfd9767d9be863a50ebaba.
- diff_content:
  - "--- a/src/lib/pci_virtio_block.c\n+++ b/src/lib/pci_virtio_block.c\n@@ -316,7\
    \ +316,7 @@ pci_vtblk_proc(struct pci_vtblk_softc *sc, struct vqueue_info *vq)\n\
    \ \tcase VBH_OP_DISCARD:\n \t\t/* We currently limit the discard to one segment\
    \ in the initial negotiation\n \t\t   so expect exactly one correctly-sized payload\
    \ descriptor. */\n-\t\tassert(iov[1].iov_len = sizeof(struct virtio_blk_discard_write_zeroes));\n\
    +\t\tassert(iov[1].iov_len == sizeof(struct virtio_blk_discard_write_zeroes));\n\
    \ \t\tassert(n == 2);\n \t\tvbdiscard = iov[1].iov_base;\n \t\tio->io_req.br_offset\
    \ = (off_t) vbdiscard->sector * DEV_BSIZE;"
  identifiers:
  - CVE-2021-32847
  - CWE-125
  overview: HyperKit is a toolkit for embedding hypervisor capabilities in an application.
    In versions 0.20210107 and prior, a malicious guest can trigger a vulnerability
    in the host by abusing the disk driver that may lead to the disclosure of the
    host memory into the virtualized guest. This issue is fixed in commit cf60095a4d8c3cb2e182a14415467afd356e982f.
  references:
  - source: security-advisories@github.com
    tags:
    - Exploit
    - Product
    url: https://github.com/moby/hyperkit/blob/2f061e447e1435cdf1b9eda364cea6414f2c606b/src/lib/pci_virtio_block.c#L316
  - source: security-advisories@github.com
    tags:
    - Patch
    url: https://github.com/moby/hyperkit/commit/cf60095a4d8c3cb2e182a14415467afd356e982f
  - source: security-advisories@github.com
    tags:
    - Exploit
    - Third Party Advisory
    url: https://securitylab.github.com/advisories/GHSL-2021-058-moby-hyperkit/
  title: HyperKit is a toolkit for embedding hypervisor capabilities in an application.
    In versions 0.20210107 and prior, a malicious guest can trigger a vulnerability
    in the host by abusing the disk driver that may lead to the disclosure of the
    host memory into the virtualized guest. This issue is fixed in commit cf60095a4d8c3cb2e182a14415467afd356e982f.
- diff_content:
  - "--- a/code/game/ai_cast_script.c\n+++ b/code/game/ai_cast_script.c\n@@ -391,7\
    \ +391,7 @@ void AICast_ScriptLoad( void ) {\n \t\treturn;\n \t}\n \n-\tlevel.scriptAI\
    \ = G_Alloc( len );\n+\tlevel.scriptAI = trap_Alloc( len );\n \ttrap_FS_Read(\
    \ level.scriptAI, len, f );\n \n \ttrap_FS_FCloseFile( f );\n@@ -518,7 +518,7\
    \ @@ void AICast_ScriptParse( cast_state_t *cs ) {\n \t\t\t}\n \n \t\t\tif ( strlen(\
    \ params ) ) { // copy the params into the event\n-\t\t\t\tcurEvent->params =\
    \ G_Alloc( strlen( params ) + 1 );\n+\t\t\t\tcurEvent->params = trap_Alloc( strlen(\
    \ params ) + 1 );\n \t\t\t\tQ_strncpyz( curEvent->params, params, strlen( params\
    \ ) + 1 );\n \t\t\t}\n \n@@ -591,7 +591,7 @@ void AICast_ScriptParse( cast_state_t\
    \ *cs ) {\n \t\t\t\t}\n \n \t\t\t\tif ( strlen( params ) ) { // copy the params\
    \ into the event\n-\t\t\t\t\tcurEvent->stack.items[curEvent->stack.numItems].params\
    \ = G_Alloc( strlen( params ) + 1 );\n+\t\t\t\t\tcurEvent->stack.items[curEvent->stack.numItems].params\
    \ = trap_Alloc( strlen( params ) + 1 );\n \t\t\t\t\tQ_strncpyz( curEvent->stack.items[curEvent->stack.numItems].params,\
    \ params, strlen( params ) + 1 );\n \t\t\t\t}\n \n@@ -623,7 +623,7 @@ void AICast_ScriptParse(\
    \ cast_state_t *cs ) {\n \n \t// alloc and copy the events into the cast_state_t\
    \ for this cast\n \tif ( numEventItems > 0 ) {\n-\t\tcs->castScriptEvents = G_Alloc(\
    \ sizeof( cast_script_event_t ) * numEventItems );\n+\t\tcs->castScriptEvents\
    \ = trap_Alloc( sizeof( cast_script_event_t ) * numEventItems );\n \t\tmemcpy(\
    \ cs->castScriptEvents, cast_temp_events, sizeof( cast_script_event_t ) * numEventItems\
    \ );\n \t\tcs->numCastScriptEvents = numEventItems;\n "
  identifiers:
  - CVE-2019-25104
  - CWE-404
  overview: A vulnerability has been found in rtcwcoop 1.0.2 and classified as problematic.
    Affected by this vulnerability is the function AICast_ScriptLoad of the file code/game/ai_cast_script.c
    of the component Team Command Handler. The manipulation leads to denial of service.
    The identifier of the patch is f2cd18bc2e1cbca8c4b78bee9c392272bd5f42ac. It is
    recommended to apply a patch to fix this issue. The identifier VDB-221485 was
    assigned to this vulnerability.
  references:
  - source: cna@vuldb.com
    tags:
    - Patch
    url: https://github.com/rtcwcoop/rtcwcoop/commit/f2cd18bc2e1cbca8c4b78bee9c392272bd5f42ac
  - source: cna@vuldb.com
    tags:
    - Exploit
    - Patch
    url: https://github.com/rtcwcoop/rtcwcoop/pull/45
  - source: cna@vuldb.com
    tags:
    - Permissions Required
    - Third Party Advisory
    url: https://vuldb.com/?ctiid.221485
  - source: cna@vuldb.com
    tags:
    - Third Party Advisory
    url: https://vuldb.com/?id.221485
  title: A vulnerability has been found in rtcwcoop 1.0.2 and classified as problematic.
    Affected by this vulnerability is the function AICast_ScriptLoad of the file code/game/ai_cast_script.c
    of the component Team Command Handler. The manipulation leads to denial of service.
    The identifier of the patch is f2cd18bc2e1cbca8c4b78bee9c392272bd5f42ac. It is
    recommended to apply a patch to fix this issue. The identifier VDB-221485 was
    assigned to this vulnerability.
- diff_content:
  - "--- a/src/xplist.c\n+++ b/src/xplist.c\n@@ -29,6 +29,7 @@\n #include <inttypes.h>\n\
    \ #include <locale.h>\n \n+#include <libxml/xmlIO.h>\n #include <libxml/parser.h>\n\
    \ #include <libxml/tree.h>\n \n@@ -555,11 +556,22 @@ PLIST_API void plist_to_xml(plist_t\
    \ plist, char **plist_xml, uint32_t * length)\n     }\n }\n \n+static xmlParserInputPtr\
    \ plist_xml_external_entity_loader(const char *URL, const char *ID, xmlParserCtxtPtr\
    \ ctxt)\n+{\n+    return NULL;\n+}\n+\n PLIST_API void plist_from_xml(const char\
    \ *plist_xml, uint32_t length, plist_t * plist)\n {\n-    xmlDocPtr plist_doc\
    \ = xmlParseMemory(plist_xml, length);\n-    xmlNodePtr root_node = xmlDocGetRootElement(plist_doc);\n\
    +    /* CVE-2013-0339: disable external entity loading to prevent XXE vulnerability\
    \ */\n+    xmlSetExternalEntityLoader(plist_xml_external_entity_loader);\n \n\
    -    xml_to_node(root_node, plist);\n-    xmlFreeDoc(plist_doc);\n+    /* read\
    \ XML from memory and disable network access for security reasons */\n+    xmlDocPtr\
    \ plist_doc = xmlReadMemory(plist_xml, length, \"plist_from_xml:memory\", NULL,\
    \ XML_PARSE_NONET);\n+    if (plist_doc) {\n+        xmlNodePtr root_node = xmlDocGetRootElement(plist_doc);\n\
    +\n+        xml_to_node(root_node, plist);\n+        xmlFreeDoc(plist_doc);\n\
    +    }\n }"
  identifiers:
  - CVE-2015-10082
  - CWE-611
  overview: A vulnerability classified as problematic has been found in UIKit0 libplist
    1.12. This affects the function plist_from_xml of the file src/xplist.c of the
    component XML Handler. The manipulation leads to xml external entity reference.
    The patch is named c086cb139af7c82845f6d565e636073ff4b37440. It is recommended
    to apply a patch to fix this issue. The associated identifier of this vulnerability
    is VDB-221499.
  references:
  - source: cna@vuldb.com
    tags:
    - Patch
    url: https://github.com/UIKit0/libplist/commit/c086cb139af7c82845f6d565e636073ff4b37440
  - source: cna@vuldb.com
    tags:
    - Permissions Required
    url: https://vuldb.com/?ctiid.221499
  - source: cna@vuldb.com
    tags:
    - Permissions Required
    url: https://vuldb.com/?id.221499
  title: A vulnerability classified as problematic has been found in UIKit0 libplist
    1.12. This affects the function plist_from_xml of the file src/xplist.c of the
    component XML Handler. The manipulation leads to xml external entity reference.
    The patch is named c086cb139af7c82845f6d565e636073ff4b37440. It is recommended
    to apply a patch to fix this issue. The associated identifier of this vulnerability
    is VDB-221499.
- diff_content:
  - "--- a/src/gnutls_io.c\n+++ b/src/gnutls_io.c\n@@ -2,7 +2,7 @@\n  *  Copyright\
    \ 2004-2005 Paul Querna\n  *  Copyright 2008 Nikos Mavrogiannopoulos\n  *  Copyright\
    \ 2011 Dash Shendy\n- *  Copyright 2015-2020 Fiona Klute\n+ *  Copyright 2015-2022\
    \ Fiona Klute\n  *\n  *  Licensed under the Apache License, Version 2.0 (the \"\
    License\");\n  *  you may not use this file except in compliance with the License.\n\
    @@ -277,6 +277,11 @@ static apr_status_t gnutls_io_input_read(mgs_handle_t * ctxt,\n\
    \                         gnutls_alert_get_name(rc));\n                 ctxt->input_rc\
    \ = APR_EGENERAL;\n                 break;\n+            } else if (rc == GNUTLS_E_PULL_ERROR\n\
    +                       && APR_STATUS_IS_TIMEUP(ctxt->input_rc)) {\n+        \
    \        ap_log_cerror(\n+                    APLOG_MARK, APLOG_TRACE2, ctxt->input_rc,\
    \ ctxt->c,\n+                    \"%s: transport read timed out\", __func__);\n\
    \             } else {\n                 /* Some Other Error. Report it. Die.\
    \ */\n                 if (gnutls_error_is_fatal(rc)) {\n@@ -1003,7 +1008,7 @@\
    \ ssize_t mgs_transport_read(gnutls_transport_ptr_t ptr,\n             && APR_BRIGADE_EMPTY(ctxt->input_bb))\n\
    \         {\n             ctxt->input_rc = rc;\n-            gnutls_transport_set_errno(ctxt->session,\
    \ EAGAIN);\n+            gnutls_transport_set_errno(ctxt->session, ETIMEDOUT);\n\
    \             return -1;\n         }\n "
  identifiers:
  - CVE-2023-25824
  - CWE-835
  overview: "Mod_gnutls is a TLS module for Apache HTTPD based on GnuTLS. Versions\
    \ from 0.9.0 to 0.12.0 (including) did not properly fail blocking read operations\
    \ on TLS connections when the transport hit timeouts. Instead it entered an endless\
    \ loop retrying the read operation, consuming CPU resources. This could be exploited\
    \ for denial of service attacks. If trace level logging was enabled, it would\
    \ also produce an excessive amount of log output during the loop, consuming disk\
    \ space. The problem has been fixed in commit d7eec4e598158ab6a98bf505354e84352f9715ec,\
    \ please update to version 0.12.1. There are no workarounds, users who cannot\
    \ update should apply the errno fix detailed in the security advisory. \n"
  references:
  - source: security-advisories@github.com
    tags:
    - Exploit
    - Issue Tracking
    - Mailing List
    - Mitigation
    - Patch
    - Third Party Advisory
    url: https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=942737#25
  - source: security-advisories@github.com
    tags:
    - Patch
    url: https://github.com/airtower-luna/mod_gnutls/commit/d7eec4e598158ab6a98bf505354e84352f9715ec
  - source: security-advisories@github.com
    tags:
    - Patch
    - Vendor Advisory
    url: https://github.com/airtower-luna/mod_gnutls/security/advisories/GHSA-6cfv-fvgm-7pc8
  title: "Mod_gnutls is a TLS module for Apache HTTPD based on GnuTLS. Versions from\
    \ 0.9.0 to 0.12.0 (including) did not properly fail blocking read operations on\
    \ TLS connections when the transport hit timeouts. Instead it entered an endless\
    \ loop retrying the read operation, consuming CPU resources. This could be exploited\
    \ for denial of service attacks. If trace level logging was enabled, it would\
    \ also produce an excessive amount of log output during the loop, consuming disk\
    \ space. The problem has been fixed in commit d7eec4e598158ab6a98bf505354e84352f9715ec,\
    \ please update to version 0.12.1. There are no workarounds, users who cannot\
    \ update should apply the errno fix detailed in the security advisory. \n"
- diff_content:
  - "--- a/net/mpls/af_mpls.c\n+++ b/net/mpls/af_mpls.c\n@@ -1428,6 +1428,7 @@ static\
    \ int mpls_dev_sysctl_register(struct net_device *dev,\n free:\n \tkfree(table);\n\
    \ out:\n+\tmdev->sysctl = NULL;\n \treturn -ENOBUFS;\n }\n \n@@ -1437,6 +1438,9\
    \ @@ static void mpls_dev_sysctl_unregister(struct net_device *dev,\n \tstruct\
    \ net *net = dev_net(dev);\n \tstruct ctl_table *table;\n \n+\tif (!mdev->sysctl)\n\
    +\t\treturn;\n+\n \ttable = mdev->sysctl->ctl_table_arg;\n \tunregister_net_sysctl_table(mdev->sysctl);\n\
    \ \tkfree(table);"
  identifiers:
  - CVE-2023-26545
  - CWE-415
  overview: In the Linux kernel before 6.1.13, there is a double free in net/mpls/af_mpls.c
    upon an allocation failure (for registering the sysctl table under a new location)
    during the renaming of a device.
  references:
  - source: cve@mitre.org
    tags:
    - Release Notes
    url: https://cdn.kernel.org/pub/linux/kernel/v6.x/ChangeLog-6.1.13
  - source: cve@mitre.org
    tags:
    - Issue Tracking
    - Mailing List
    url: https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=fda6c89fe3d9aca073495a664e1d5aea28cd4377
  - source: cve@mitre.org
    tags:
    - Patch
    url: https://github.com/torvalds/linux/commit/fda6c89fe3d9aca073495a664e1d5aea28cd4377
  - source: cve@mitre.org
    url: https://lists.debian.org/debian-lts-announce/2023/05/msg00005.html
  - source: cve@mitre.org
    url: https://lists.debian.org/debian-lts-announce/2023/05/msg00006.html
  - source: cve@mitre.org
    tags:
    - Third Party Advisory
    url: https://security.netapp.com/advisory/ntap-20230316-0009/
  title: In the Linux kernel before 6.1.13, there is a double free in net/mpls/af_mpls.c
    upon an allocation failure (for registering the sysctl table under a new location)
    during the renaming of a device.
- diff_content:
  - "--- a/drivers/usb/dwc3/dwc3-qcom.c\n+++ b/drivers/usb/dwc3/dwc3-qcom.c\n@@ -598,8\
    \ +598,10 @@ static int dwc3_qcom_acpi_register_core(struct platform_device *pdev)\n\
    \ \tqcom->dwc3->dev.coherent_dma_mask = dev->coherent_dma_mask;\n \n \tchild_res\
    \ = kcalloc(2, sizeof(*child_res), GFP_KERNEL);\n-\tif (!child_res)\n+\tif (!child_res)\
    \ {\n+\t\tplatform_device_put(qcom->dwc3);\n \t\treturn -ENOMEM;\n+\t}\n \n \t\
    res = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n \tif (!res) {\n@@ -637,9\
    \ +639,13 @@ static int dwc3_qcom_acpi_register_core(struct platform_device *pdev)\n\
    \ \tif (ret) {\n \t\tdev_err(&pdev->dev, \"failed to add device\\n\");\n \t\t\
    device_remove_software_node(&qcom->dwc3->dev);\n+\t\tgoto out;\n \t}\n+\tkfree(child_res);\n\
    +\treturn 0;\n \n out:\n+\tplatform_device_put(qcom->dwc3);\n \tkfree(child_res);\n\
    \ \treturn ret;\n }"
  identifiers:
  - CVE-2023-22995
  - NVD-CWE-noinfo
  overview: In the Linux kernel before 5.17, an error path in dwc3_qcom_acpi_register_core
    in drivers/usb/dwc3/dwc3-qcom.c lacks certain platform_device_put and kfree calls.
  references:
  - source: cve@mitre.org
    tags:
    - Release Notes
    url: https://cdn.kernel.org/pub/linux/kernel/v5.x/ChangeLog-5.17
  - source: cve@mitre.org
    tags:
    - Patch
    url: https://github.com/torvalds/linux/commit/fa0ef93868a6062babe1144df2807a8b1d4924d2
  - source: cve@mitre.org
    url: https://security.netapp.com/advisory/ntap-20230331-0004/
  title: In the Linux kernel before 5.17, an error path in dwc3_qcom_acpi_register_core
    in drivers/usb/dwc3/dwc3-qcom.c lacks certain platform_device_put and kfree calls.
- diff_content:
  - "--- a/drivers/soc/qcom/qcom_aoss.c\n+++ b/drivers/soc/qcom/qcom_aoss.c\n@@ -451,7\
    \ +451,11 @@ struct qmp *qmp_get(struct device *dev)\n \n \tqmp = platform_get_drvdata(pdev);\n\
    \ \n-\treturn qmp ? qmp : ERR_PTR(-EPROBE_DEFER);\n+\tif (!qmp) {\n+\t\tput_device(&pdev->dev);\n\
    +\t\treturn ERR_PTR(-EPROBE_DEFER);\n+\t}\n+\treturn qmp;\n }\n EXPORT_SYMBOL(qmp_get);\n\
    \ "
  identifiers:
  - CVE-2023-22996
  - CWE-772
  overview: In the Linux kernel before 5.17.2, drivers/soc/qcom/qcom_aoss.c does not
    release an of_find_device_by_node reference after use, e.g., with put_device.
  references:
  - source: cve@mitre.org
    tags:
    - Release Notes
    url: https://cdn.kernel.org/pub/linux/kernel/v5.x/ChangeLog-5.17.2
  - source: cve@mitre.org
    tags:
    - Patch
    url: https://github.com/torvalds/linux/commit/4b41a9d0fe3db5f91078a380f62f0572c3ecf2dd
  title: In the Linux kernel before 5.17.2, drivers/soc/qcom/qcom_aoss.c does not
    release an of_find_device_by_node reference after use, e.g., with put_device.
- diff_content:
  - "--- a/kernel/module/decompress.c\n+++ b/kernel/module/decompress.c\n@@ -114,8\
    \ +114,8 @@ static ssize_t module_gzip_decompress(struct load_info *info,\n \t\
    do {\n \t\tstruct page *page = module_get_next_page(info);\n \n-\t\tif (!page)\
    \ {\n-\t\t\tretval = -ENOMEM;\n+\t\tif (IS_ERR(page)) {\n+\t\t\tretval = PTR_ERR(page);\n\
    \ \t\t\tgoto out_inflate_end;\n \t\t}\n \n@@ -173,8 +173,8 @@ static ssize_t module_xz_decompress(struct\
    \ load_info *info,\n \tdo {\n \t\tstruct page *page = module_get_next_page(info);\n\
    \ \n-\t\tif (!page) {\n-\t\t\tretval = -ENOMEM;\n+\t\tif (IS_ERR(page)) {\n+\t\
    \t\tretval = PTR_ERR(page);\n \t\t\tgoto out;\n \t\t}\n "
  identifiers:
  - CVE-2023-22997
  - CWE-476
  overview: In the Linux kernel before 6.1.2, kernel/module/decompress.c misinterprets
    the module_get_next_page return value (expects it to be NULL in the error case,
    whereas it is actually an error pointer).
  references:
  - source: cve@mitre.org
    tags:
    - Release Notes
    url: https://cdn.kernel.org/pub/linux/kernel/v6.x/ChangeLog-6.1.2
  - source: cve@mitre.org
    tags:
    - Patch
    url: https://github.com/torvalds/linux/commit/45af1d7aae7d5520d2858f8517a1342646f015db
  title: In the Linux kernel before 6.1.2, kernel/module/decompress.c misinterprets
    the module_get_next_page return value (expects it to be NULL in the error case,
    whereas it is actually an error pointer).
- diff_content:
  - "--- a/drivers/gpu/drm/virtio/virtgpu_object.c\n+++ b/drivers/gpu/drm/virtio/virtgpu_object.c\n\
    @@ -168,9 +168,9 @@ static int virtio_gpu_object_shmem_init(struct virtio_gpu_device\
    \ *vgdev,\n \t * since virtio_gpu doesn't support dma-buf import from other devices.\n\
    \ \t */\n \tshmem->pages = drm_gem_shmem_get_sg_table(&bo->base);\n-\tif (!shmem->pages)\
    \ {\n+\tif (IS_ERR(shmem->pages)) {\n \t\tdrm_gem_shmem_unpin(&bo->base);\n-\t\
    \treturn -EINVAL;\n+\t\treturn PTR_ERR(shmem->pages);\n \t}\n \n \tif (use_dma_api)\
    \ {"
  identifiers:
  - CVE-2023-22998
  - CWE-436
  overview: In the Linux kernel before 6.0.3, drivers/gpu/drm/virtio/virtgpu_object.c
    misinterprets the drm_gem_shmem_get_sg_table return value (expects it to be NULL
    in the error case, whereas it is actually an error pointer).
  references:
  - source: cve@mitre.org
    tags:
    - Release Notes
    url: https://cdn.kernel.org/pub/linux/kernel/v6.x/ChangeLog-6.0.3
  - source: cve@mitre.org
    tags:
    - Patch
    url: https://github.com/torvalds/linux/commit/c24968734abfed81c8f93dc5f44a7b7a9aecadfa
  - source: cve@mitre.org
    url: https://lists.debian.org/debian-lts-announce/2023/05/msg00005.html
  title: In the Linux kernel before 6.0.3, drivers/gpu/drm/virtio/virtgpu_object.c
    misinterprets the drm_gem_shmem_get_sg_table return value (expects it to be NULL
    in the error case, whereas it is actually an error pointer).
- diff_content:
  - "--- a/drivers/usb/dwc3/dwc3-qcom.c\n+++ b/drivers/usb/dwc3/dwc3-qcom.c\n@@ -775,9\
    \ +775,12 @@ static int dwc3_qcom_probe(struct platform_device *pdev)\n \n \t\t\
    if (qcom->acpi_pdata->is_urs) {\n \t\t\tqcom->urs_usb = dwc3_qcom_create_urs_usb_platdev(dev);\n\
    -\t\t\tif (!qcom->urs_usb) {\n+\t\t\tif (IS_ERR_OR_NULL(qcom->urs_usb)) {\n \t\
    \t\t\tdev_err(dev, \"failed to create URS USB platdev\\n\");\n-\t\t\t\treturn\
    \ -ENODEV;\n+\t\t\t\tif (!qcom->urs_usb)\n+\t\t\t\t\treturn -ENODEV;\n+\t\t\t\t\
    else\n+\t\t\t\t\treturn PTR_ERR(qcom->urs_usb);\n \t\t\t}\n \t\t}\n \t}"
  identifiers:
  - CVE-2023-22999
  - CWE-476
  overview: In the Linux kernel before 5.16.3, drivers/usb/dwc3/dwc3-qcom.c misinterprets
    the dwc3_qcom_create_urs_usb_platdev return value (expects it to be NULL in the
    error case, whereas it is actually an error pointer).
  references:
  - source: cve@mitre.org
    tags:
    - Release Notes
    url: https://cdn.kernel.org/pub/linux/kernel/v5.x/ChangeLog-5.16.3
  - source: cve@mitre.org
    tags:
    - Patch
    url: https://github.com/torvalds/linux/commit/b52fe2dbb3e655eb1483000adfab68a219549e13
  title: In the Linux kernel before 5.16.3, drivers/usb/dwc3/dwc3-qcom.c misinterprets
    the dwc3_qcom_create_urs_usb_platdev return value (expects it to be NULL in the
    error case, whereas it is actually an error pointer).
- diff_content:
  - "--- a/net/netfilter/nf_tables_api.c\n+++ b/net/netfilter/nf_tables_api.c\n@@\
    \ -153,6 +153,7 @@ static struct nft_trans *nft_trans_alloc_gfp(const struct nft_ctx\
    \ *ctx,\n \tif (trans == NULL)\n \t\treturn NULL;\n \n+\tINIT_LIST_HEAD(&trans->list);\n\
    \ \ttrans->msg_type = msg_type;\n \ttrans->ctx\t= *ctx;\n "
  identifiers:
  - CVE-2023-1095
  - CWE-476
  overview: In nf_tables_updtable, if nf_tables_table_enable returns an error, nft_trans_destroy
    is called to free the transaction object. nft_trans_destroy() calls list_del(),
    but the transaction was never placed on a list -- the list head is all zeroes,
    this results in a NULL pointer dereference.
  references:
  - source: secalert@redhat.com
    tags:
    - Issue Tracking
    - Patch
    - Third Party Advisory
    url: https://bugzilla.redhat.com/show_bug.cgi?id=2173973
  - source: secalert@redhat.com
    tags:
    - Patch
    url: https://github.com/torvalds/linux/commit/580077855a40741cf511766129702d97ff02f4d9
  title: In nf_tables_updtable, if nf_tables_table_enable returns an error, nft_trans_destroy
    is called to free the transaction object. nft_trans_destroy() calls list_del(),
    but the transaction was never placed on a list -- the list head is all zeroes,
    this results in a NULL pointer dereference.
- diff_content:
  - "--- a/Userland/Libraries/LibJS/Runtime/TypedArray.cpp\n+++ b/Userland/Libraries/LibJS/Runtime/TypedArray.cpp\n\
    @@ -54,7 +54,7 @@ static void initialize_typed_array_from_array_buffer(GlobalObject&\
    \ global_object\n     }\n     // FIXME: 8. If IsDetachedBuffer(buffer) is true,\
    \ throw a TypeError exception.\n     auto buffer_byte_length = array_buffer.byte_length();\n\
    -    size_t new_byte_length;\n+    Checked<size_t> new_byte_length;\n     if (length.is_undefined())\
    \ {\n         if (buffer_byte_length % element_size != 0) {\n             vm.throw_exception<RangeError>(global_object,\
    \ ErrorType::TypedArrayInvalidBufferLength, typed_array.class_name(), element_size,\
    \ buffer_byte_length);\n@@ -64,18 +64,34 @@ static void initialize_typed_array_from_array_buffer(GlobalObject&\
    \ global_object\n             vm.throw_exception<RangeError>(global_object, ErrorType::TypedArrayOutOfRangeByteOffset,\
    \ offset, buffer_byte_length);\n             return;\n         }\n-        new_byte_length\
    \ = buffer_byte_length - offset;\n+        new_byte_length = buffer_byte_length;\n\
    +        new_byte_length -= offset;\n     } else {\n-        new_byte_length =\
    \ new_length * element_size;\n-        if (offset + new_byte_length > buffer_byte_length)\
    \ {\n-            vm.throw_exception<RangeError>(global_object, ErrorType::TypedArrayOutOfRangeByteOffsetOrLength,\
    \ offset, offset + new_byte_length, buffer_byte_length);\n+        new_byte_length\
    \ = new_length;\n+        new_byte_length *= element_size;\n+\n+        Checked<size_t>\
    \ new_byte_end = new_byte_length;\n+        new_byte_end += offset;\n+\n+    \
    \    if (new_byte_end.has_overflow()) {\n+            vm.throw_exception<RangeError>(global_object,\
    \ ErrorType::InvalidLength, \"typed array\");\n+            return;\n+       \
    \ }\n+\n+        if (new_byte_end.value() > buffer_byte_length) {\n+         \
    \   vm.throw_exception<RangeError>(global_object, ErrorType::TypedArrayOutOfRangeByteOffsetOrLength,\
    \ offset, new_byte_end.value(), buffer_byte_length);\n             return;\n \
    \        }\n     }\n+    if (new_byte_length.has_overflow()) {\n+        vm.throw_exception<RangeError>(global_object,\
    \ ErrorType::InvalidLength, \"typed array\");\n+        return;\n+    }\n+\n \
    \    typed_array.set_viewed_array_buffer(&array_buffer);\n-    typed_array.set_byte_length(new_byte_length);\n\
    +    typed_array.set_byte_length(new_byte_length.value());\n     typed_array.set_byte_offset(offset);\n\
    -    typed_array.set_array_length(new_byte_length / element_size);\n+    typed_array.set_array_length(new_byte_length.value()\
    \ / element_size);\n }\n \n void TypedArrayBase::visit_edges(Visitor& visitor)"
  identifiers:
  - CVE-2021-4327
  - CWE-190
  overview: A vulnerability was found in SerenityOS. It has been rated as critical.
    Affected by this issue is the function initialize_typed_array_from_array_buffer
    in the library Userland/Libraries/LibJS/Runtime/TypedArray.cpp. The manipulation
    leads to integer overflow. The exploit has been disclosed to the public and may
    be used. Continious delivery with rolling releases is used by this product. Therefore,
    no version details of affected nor updated releases are available. The patch is
    identified as f6c6047e49f1517778f5565681fb64750b14bf60. It is recommended to apply
    a patch to fix this issue. VDB-222074 is the identifier assigned to this vulnerability.
  references:
  - source: cna@vuldb.com
    tags:
    - Exploit
    - Third Party Advisory
    url: https://devcraft.io/2021/02/11/serenityos-writing-a-full-chain-exploit.html
  - source: cna@vuldb.com
    tags:
    - Patch
    url: https://github.com/SerenityOS/serenity/commit/f6c6047e49f1517778f5565681fb64750b14bf60
  - source: cna@vuldb.com
    tags:
    - Permissions Required
    - Third Party Advisory
    url: https://vuldb.com/?ctiid.222074
  - source: cna@vuldb.com
    tags:
    - Permissions Required
    - Third Party Advisory
    url: https://vuldb.com/?id.222074
  title: A vulnerability was found in SerenityOS. It has been rated as critical. Affected
    by this issue is the function initialize_typed_array_from_array_buffer in the
    library Userland/Libraries/LibJS/Runtime/TypedArray.cpp. The manipulation leads
    to integer overflow. The exploit has been disclosed to the public and may be used.
    Continious delivery with rolling releases is used by this product. Therefore,
    no version details of affected nor updated releases are available. The patch is
    identified as f6c6047e49f1517778f5565681fb64750b14bf60. It is recommended to apply
    a patch to fix this issue. VDB-222074 is the identifier assigned to this vulnerability.
- diff_content:
  - "--- a/src/util.c\n+++ b/src/util.c\n@@ -53,8 +53,8 @@\n #define UNUSED(x) ((void)(x))\n\
    \ \n /* Glob-style pattern matching. */\n-int stringmatchlen(const char *pattern,\
    \ int patternLen,\n-        const char *string, int stringLen, int nocase)\n+static\
    \ int stringmatchlen_impl(const char *pattern, int patternLen,\n+        const\
    \ char *string, int stringLen, int nocase, int *skipLongerMatches)\n {\n     while(patternLen\
    \ && stringLen) {\n         switch(pattern[0]) {\n@@ -66,12 +66,25 @@ int stringmatchlen(const\
    \ char *pattern, int patternLen,\n             if (patternLen == 1)\n        \
    \         return 1; /* match */\n             while(stringLen) {\n-          \
    \      if (stringmatchlen(pattern+1, patternLen-1,\n-                        \
    \    string, stringLen, nocase))\n+                if (stringmatchlen_impl(pattern+1,\
    \ patternLen-1,\n+                            string, stringLen, nocase, skipLongerMatches))\n\
    \                     return 1; /* match */\n+                if (*skipLongerMatches)\n\
    +                    return 0; /* no match */\n                 string++;\n  \
    \               stringLen--;\n             }\n+            /* There was no match\
    \ for the rest of the pattern starting\n+             * from anywhere in the rest\
    \ of the string. If there were\n+             * any '*' earlier in the pattern,\
    \ we can terminate the\n+             * search early without trying to match them\
    \ to longer\n+             * substrings. This is because a longer match for the\n\
    +             * earlier part of the pattern would require the rest of the\n+ \
    \            * pattern to match starting later in the string, and we\n+      \
    \       * have just determined that there is no match for the rest\n+        \
    \     * of the pattern starting from anywhere in the current\n+             *\
    \ string. */\n+            *skipLongerMatches = 1;\n             return 0; /*\
    \ no match */\n             break;\n         case '?':\n@@ -173,6 +186,12 @@ int\
    \ stringmatchlen(const char *pattern, int patternLen,\n     return 0;\n }\n \n\
    +int stringmatchlen(const char *pattern, int patternLen,\n+        const char\
    \ *string, int stringLen, int nocase) {\n+    int skipLongerMatches = 0;\n+  \
    \  return stringmatchlen_impl(pattern,patternLen,string,stringLen,nocase,&skipLongerMatches);\n\
    +}\n+\n int stringmatch(const char *pattern, const char *string, int nocase) {\n\
    \     return stringmatchlen(pattern,strlen(pattern),string,strlen(string),nocase);\n\
    \ }"
  identifiers:
  - CVE-2022-36021
  - CWE-407
  overview: 'Redis is an in-memory database that persists on disk. Authenticated users
    can use string matching commands (like `SCAN` or `KEYS`) with a specially crafted
    pattern to trigger a denial-of-service attack on Redis, causing it to hang and
    consume 100% CPU time. The problem is fixed in Redis versions 6.0.18, 6.2.11,
    7.0.9.

    '
  references:
  - source: security-advisories@github.com
    tags:
    - Patch
    url: https://github.com/redis/redis/commit/dcbfcb916ca1a269b3feef86ee86835294758f84
  - source: security-advisories@github.com
    tags:
    - Vendor Advisory
    url: https://github.com/redis/redis/security/advisories/GHSA-jr7j-rfj5-8xqv
  title: 'Redis is an in-memory database that persists on disk. Authenticated users
    can use string matching commands (like `SCAN` or `KEYS`) with a specially crafted
    pattern to trigger a denial-of-service attack on Redis, causing it to hang and
    consume 100% CPU time. The problem is fixed in Redis versions 6.0.18, 6.2.11,
    7.0.9.

    '
- diff_content:
  - "--- a/src/move.c\n+++ b/src/move.c\n@@ -1734,7 +1734,7 @@ scrolldown(\n \t  \
    \  col -= width1;\n \t    ++row;\n \t}\n-\tif (col > width2)\n+\tif (col > width2\
    \ && width2 > 0)\n \t{\n \t    row += col / width2;\n \t    col = col % width2;"
  - "--- a/src/version.c\n+++ b/src/version.c\n@@ -695,6 +695,8 @@ static char *(features[])\
    \ =\n \n static int included_patches[] =\n {   /* Add new patch number below this\
    \ line */\n+/**/\n+    1367,\n /**/\n     1366,\n /**/"
  identifiers:
  - CVE-2023-1127
  - CWE-369
  overview: Divide By Zero in GitHub repository vim/vim prior to 9.0.1367.
  references:
  - source: security@huntr.dev
    tags:
    - Patch
    url: https://github.com/vim/vim/commit/e0f869196930ef5f25a0ac41c9215b09c9ce2d3c
  - source: security@huntr.dev
    tags:
    - Exploit
    - Third Party Advisory
    url: https://huntr.dev/bounties/2d4d309e-4c96-415f-9070-36d0815f1beb
  - source: security@huntr.dev
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/IE44W6WMMREYCW3GJHPSYP7NK2VT5NY6/
  - source: security@huntr.dev
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/PDVN5HSWPNVP4QXBPCEGZDLZKURLJWTE/
  - source: security@huntr.dev
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/WJ6TMKKBXHGVUHWFGM4X46VIJO7ZAG2W/
  title: Divide By Zero in GitHub repository vim/vim prior to 9.0.1367.
- diff_content:
  - "--- a/drivers/phy/tegra/xusb.c\n+++ b/drivers/phy/tegra/xusb.c\n@@ -455,7 +455,7\
    \ @@ tegra_xusb_find_port_node(struct tegra_xusb_padctl *padctl, const char *type,\n\
    \ \tname = kasprintf(GFP_KERNEL, \"%s-%u\", type, index);\n \tif (!name) {\n \t\
    \tof_node_put(ports);\n-\t\treturn ERR_PTR(-ENOMEM);\n+\t\treturn NULL;\n \t}\n\
    \ \tnp = of_get_child_by_name(ports, name);\n \tkfree(name);"
  identifiers:
  - CVE-2023-23000
  - CWE-476
  overview: In the Linux kernel before 5.17, drivers/phy/tegra/xusb.c mishandles the
    tegra_xusb_find_port_node return value. Callers expect NULL in the error case,
    but an error pointer is used.
  references:
  - source: cve@mitre.org
    tags:
    - Mailing List
    - Patch
    - Vendor Advisory
    url: https://cdn.kernel.org/pub/linux/kernel/v5.x/ChangeLog-5.17
  - source: cve@mitre.org
    tags:
    - Patch
    url: https://github.com/torvalds/linux/commit/045a31b95509c8f25f5f04ec5e0dec5cd09f2c5f
  - source: cve@mitre.org
    url: https://security.netapp.com/advisory/ntap-20230331-0004/
  title: In the Linux kernel before 5.17, drivers/phy/tegra/xusb.c mishandles the
    tegra_xusb_find_port_node return value. Callers expect NULL in the error case,
    but an error pointer is used.
- diff_content:
  - "--- a/drivers/scsi/ufs/ufs-mediatek.c\n+++ b/drivers/scsi/ufs/ufs-mediatek.c\n\
    @@ -557,7 +557,7 @@ static void ufs_mtk_init_va09_pwr_ctrl(struct ufs_hba *hba)\n\
    \ \tstruct ufs_mtk_host *host = ufshcd_get_variant(hba);\n \n \thost->reg_va09\
    \ = regulator_get(hba->dev, \"va09\");\n-\tif (!host->reg_va09)\n+\tif (IS_ERR(host->reg_va09))\n\
    \ \t\tdev_info(hba->dev, \"failed to get va09\");\n \telse\n \t\thost->caps |=\
    \ UFS_MTK_CAP_VA09_PWR_CTRL;"
  identifiers:
  - CVE-2023-23001
  - CWE-476
  overview: In the Linux kernel before 5.16.3, drivers/scsi/ufs/ufs-mediatek.c misinterprets
    the regulator_get return value (expects it to be NULL in the error case, whereas
    it is actually an error pointer).
  references:
  - source: cve@mitre.org
    tags:
    - Mailing List
    - Patch
    - Release Notes
    url: https://cdn.kernel.org/pub/linux/kernel/v5.x/ChangeLog-5.16.3
  - source: cve@mitre.org
    tags:
    - Patch
    url: https://github.com/torvalds/linux/commit/3ba880a12df5aa4488c18281701b5b1bc3d4531a
  title: In the Linux kernel before 5.16.3, drivers/scsi/ufs/ufs-mediatek.c misinterprets
    the regulator_get return value (expects it to be NULL in the error case, whereas
    it is actually an error pointer).
- diff_content:
  - "--- a/drivers/bluetooth/hci_qca.c\n+++ b/drivers/bluetooth/hci_qca.c\n@@ -2059,14\
    \ +2059,14 @@ static int qca_serdev_probe(struct serdev_device *serdev)\n \n \t\
    \tqcadev->bt_en = devm_gpiod_get_optional(&serdev->dev, \"enable\",\n \t\t\t\t\
    \t       GPIOD_OUT_LOW);\n-\t\tif (!qcadev->bt_en && data->soc_type == QCA_WCN6750)\
    \ {\n+\t\tif (IS_ERR_OR_NULL(qcadev->bt_en) && data->soc_type == QCA_WCN6750)\
    \ {\n \t\t\tdev_err(&serdev->dev, \"failed to acquire BT_EN gpio\\n\");\n \t\t\
    \tpower_ctrl_enabled = false;\n \t\t}\n \n \t\tqcadev->sw_ctrl = devm_gpiod_get_optional(&serdev->dev,\
    \ \"swctrl\",\n \t\t\t\t\t       GPIOD_IN);\n-\t\tif (!qcadev->sw_ctrl && data->soc_type\
    \ == QCA_WCN6750)\n+\t\tif (IS_ERR_OR_NULL(qcadev->sw_ctrl) && data->soc_type\
    \ == QCA_WCN6750)\n \t\t\tdev_warn(&serdev->dev, \"failed to acquire SW_CTRL gpio\\\
    n\");\n \n \t\tqcadev->susclk = devm_clk_get_optional(&serdev->dev, NULL);\n@@\
    \ -2088,7 +2088,7 @@ static int qca_serdev_probe(struct serdev_device *serdev)\n\
    \ \n \t\tqcadev->bt_en = devm_gpiod_get_optional(&serdev->dev, \"enable\",\n \t\
    \t\t\t\t       GPIOD_OUT_LOW);\n-\t\tif (!qcadev->bt_en) {\n+\t\tif (IS_ERR_OR_NULL(qcadev->bt_en))\
    \ {\n \t\t\tdev_warn(&serdev->dev, \"failed to acquire enable gpio\\n\");\n \t\
    \t\tpower_ctrl_enabled = false;\n \t\t}"
  identifiers:
  - CVE-2023-23002
  - CWE-476
  overview: In the Linux kernel before 5.16.3, drivers/bluetooth/hci_qca.c misinterprets
    the devm_gpiod_get_index_optional return value (expects it to be NULL in the error
    case, whereas it is actually an error pointer).
  references:
  - source: cve@mitre.org
    tags:
    - Mailing List
    - Patch
    - Release Notes
    url: https://cdn.kernel.org/pub/linux/kernel/v5.x/ChangeLog-5.16.3
  - source: cve@mitre.org
    tags:
    - Patch
    url: https://github.com/torvalds/linux/commit/6845667146a28c09b5dfc401c1ad112374087944
  title: In the Linux kernel before 5.16.3, drivers/bluetooth/hci_qca.c misinterprets
    the devm_gpiod_get_index_optional return value (expects it to be NULL in the error
    case, whereas it is actually an error pointer).
- diff_content:
  - "--- a/tools/perf/util/expr.c\n+++ b/tools/perf/util/expr.c\n@@ -12,6 +12,7 @@\n\
    \ #include \"expr-bison.h\"\n #include \"expr-flex.h\"\n #include \"smt.h\"\n\
    +#include <linux/err.h>\n #include <linux/kernel.h>\n #include <linux/zalloc.h>\n\
    \ #include <ctype.h>\n@@ -299,6 +300,10 @@ struct expr_parse_ctx *expr__ctx_new(void)\n\
    \ \t\treturn NULL;\n \n \tctx->ids = hashmap__new(key_hash, key_equal, NULL);\n\
    +\tif (IS_ERR(ctx->ids)) {\n+\t\tfree(ctx);\n+\t\treturn NULL;\n+\t}\n \tctx->runtime\
    \ = 0;\n \n \treturn ctx;"
  identifiers:
  - CVE-2023-23003
  - CWE-252
  overview: In the Linux kernel before 5.16, tools/perf/util/expr.c lacks a check
    for the hashmap__new return value.
  references:
  - source: cve@mitre.org
    tags:
    - Mailing List
    - Patch
    - Vendor Advisory
    url: https://cdn.kernel.org/pub/linux/kernel/v5.x/ChangeLog-5.16
  - source: cve@mitre.org
    tags:
    - Patch
    url: https://github.com/torvalds/linux/commit/0a515a06c5ebfa46fee3ac519e418f801e718da4
  - source: cve@mitre.org
    tags:
    - Third Party Advisory
    url: https://security.netapp.com/advisory/ntap-20230331-0003/
  title: In the Linux kernel before 5.16, tools/perf/util/expr.c lacks a check for
    the hashmap__new return value.
- diff_content:
  - "--- a/drivers/gpu/drm/arm/malidp_planes.c\n+++ b/drivers/gpu/drm/arm/malidp_planes.c\n\
    @@ -344,7 +344,7 @@ static bool malidp_check_pages_threshold(struct malidp_plane_state\
    \ *ms,\n \t\telse\n \t\t\tsgt = obj->funcs->get_sg_table(obj);\n \n-\t\tif (!sgt)\n\
    +\t\tif (IS_ERR(sgt))\n \t\t\treturn false;\n \n \t\tsgl = sgt->sgl;"
  identifiers:
  - CVE-2023-23004
  - CWE-476
  overview: In the Linux kernel before 5.19, drivers/gpu/drm/arm/malidp_planes.c misinterprets
    the get_sg_table return value (expects it to be NULL in the error case, whereas
    it is actually an error pointer).
  references:
  - source: cve@mitre.org
    tags:
    - Mailing List
    - Patch
    - Release Notes
    url: https://cdn.kernel.org/pub/linux/kernel/v5.x/ChangeLog-5.19
  - source: cve@mitre.org
    tags:
    - Broken Link
    - Patch
    url: https://github.com/torvalds/linux/commit/15342f930ebebcfe36f2415049736a77d7d2e045
  - source: cve@mitre.org
    url: https://lists.debian.org/debian-lts-announce/2023/05/msg00005.html
  title: In the Linux kernel before 5.19, drivers/gpu/drm/arm/malidp_planes.c misinterprets
    the get_sg_table return value (expects it to be NULL in the error case, whereas
    it is actually an error pointer).
- diff_content:
  - "--- a/mm/memory-tiers.c\n+++ b/mm/memory-tiers.c\n@@ -645,7 +645,7 @@ static\
    \ int __init memory_tier_init(void)\n \t * than default DRAM tier.\n \t */\n \t\
    default_dram_type = alloc_memory_type(MEMTIER_ADISTANCE_DRAM);\n-\tif (!default_dram_type)\n\
    +\tif (IS_ERR(default_dram_type))\n \t\tpanic(\"%s() failed to allocate default\
    \ DRAM tier\\n\", __func__);\n \n \t/*"
  identifiers:
  - CVE-2023-23005
  - CWE-476
  overview: 'In the Linux kernel before 6.2, mm/memory-tiers.c misinterprets the alloc_memory_type
    return value (expects it to be NULL in the error case, whereas it is actually
    an error pointer). NOTE: this is disputed by third parties because there are no
    realistic cases in which a user can cause the alloc_memory_type error case to
    be reached.'
  references:
  - source: cve@mitre.org
    tags:
    - Issue Tracking
    - Patch
    - Third Party Advisory
    url: https://bugzilla.suse.com/show_bug.cgi?id=1208844#c2
  - source: cve@mitre.org
    tags:
    - Mailing List
    - Patch
    - Release Notes
    url: https://cdn.kernel.org/pub/linux/kernel/v6.x/ChangeLog-6.2
  - source: cve@mitre.org
    tags:
    - Patch
    url: https://github.com/torvalds/linux/commit/4a625ceee8a0ab0273534cb6b432ce6b331db5ee
  title: 'In the Linux kernel before 6.2, mm/memory-tiers.c misinterprets the alloc_memory_type
    return value (expects it to be NULL in the error case, whereas it is actually
    an error pointer). NOTE: this is disputed by third parties because there are no
    realistic cases in which a user can cause the alloc_memory_type error case to
    be reached.'
- diff_content:
  - "--- a/drivers/net/ethernet/mellanox/mlx5/core/steering/dr_domain.c\n+++ b/drivers/net/ethernet/mellanox/mlx5/core/steering/dr_domain.c\n\
    @@ -2,6 +2,7 @@\n /* Copyright (c) 2019 Mellanox Technologies. */\n \n #include\
    \ <linux/mlx5/eswitch.h>\n+#include <linux/err.h>\n #include \"dr_types.h\"\n\
    \ \n #define DR_DOMAIN_SW_STEERING_SUPPORTED(dmn, dmn_type)\t\\\n@@ -72,9 +73,9\
    \ @@ static int dr_domain_init_resources(struct mlx5dr_domain *dmn)\n \t}\n \n\
    \ \tdmn->uar = mlx5_get_uars_page(dmn->mdev);\n-\tif (!dmn->uar) {\n+\tif (IS_ERR(dmn->uar))\
    \ {\n \t\tmlx5dr_err(dmn, \"Couldn't allocate UAR\\n\");\n-\t\tret = -ENOMEM;\n\
    +\t\tret = PTR_ERR(dmn->uar);\n \t\tgoto clean_pd;\n \t}\n "
  identifiers:
  - CVE-2023-23006
  - CWE-476
  overview: In the Linux kernel before 5.15.13, drivers/net/ethernet/mellanox/mlx5/core/steering/dr_domain.c
    misinterprets the mlx5_get_uars_page return value (expects it to be NULL in the
    error case, whereas it is actually an error pointer).
  references:
  - source: cve@mitre.org
    tags:
    - Mailing List
    - Patch
    - Release Notes
    url: https://cdn.kernel.org/pub/linux/kernel/v5.x/ChangeLog-5.15.13
  - source: cve@mitre.org
    tags:
    - Patch
    url: https://github.com/torvalds/linux/commit/6b8b42585886c59a008015083282aae434349094
  title: In the Linux kernel before 5.15.13, drivers/net/ethernet/mellanox/mlx5/core/steering/dr_domain.c
    misinterprets the mlx5_get_uars_page return value (expects it to be NULL in the
    error case, whereas it is actually an error pointer).
- diff_content:
  - "--- a/src/t_hash.c\n+++ b/src/t_hash.c\n@@ -1120,13 +1120,13 @@ void hrandfieldCommand(client\
    \ *c) {\n     listpackEntry ele;\n \n     if (c->argc >= 3) {\n-        if (getLongFromObjectOrReply(c,c->argv[2],&l,NULL)\
    \ != C_OK) return;\n+        if (getRangeLongFromObjectOrReply(c,c->argv[2],-LONG_MAX,LONG_MAX,&l,NULL)\
    \ != C_OK) return;\n         if (c->argc > 4 || (c->argc == 4 && strcasecmp(c->argv[3]->ptr,\"\
    withvalues\"))) {\n             addReplyErrorObject(c,shared.syntaxerr);\n   \
    \          return;\n         } else if (c->argc == 4) {\n             withvalues\
    \ = 1;\n-            if (l < LONG_MIN/2 || l > LONG_MAX/2) {\n+            if\
    \ (l < -LONG_MAX/2 || l > LONG_MAX/2) {\n                 addReplyError(c,\"value\
    \ is out of range\");\n                 return;\n             }"
  - "--- a/src/t_set.c\n+++ b/src/t_set.c\n@@ -665,7 +665,7 @@ void srandmemberWithCountCommand(client\
    \ *c) {\n \n     dict *d;\n \n-    if (getLongFromObjectOrReply(c,c->argv[2],&l,NULL)\
    \ != C_OK) return;\n+    if (getRangeLongFromObjectOrReply(c,c->argv[2],-LONG_MAX,LONG_MAX,&l,NULL)\
    \ != C_OK) return;\n     if (l >= 0) {\n         count = (unsigned long) l;\n\
    \     } else {"
  - "--- a/src/t_zset.c\n+++ b/src/t_zset.c\n@@ -4289,13 +4289,13 @@ void zrandmemberCommand(client\
    \ *c) {\n     listpackEntry ele;\n \n     if (c->argc >= 3) {\n-        if (getLongFromObjectOrReply(c,c->argv[2],&l,NULL)\
    \ != C_OK) return;\n+        if (getRangeLongFromObjectOrReply(c,c->argv[2],-LONG_MAX,LONG_MAX,&l,NULL)\
    \ != C_OK) return;\n         if (c->argc > 4 || (c->argc == 4 && strcasecmp(c->argv[3]->ptr,\"\
    withscores\"))) {\n             addReplyErrorObject(c,shared.syntaxerr);\n   \
    \          return;\n         } else if (c->argc == 4) {\n             withscores\
    \ = 1;\n-            if (l < LONG_MIN/2 || l > LONG_MAX/2) {\n+            if\
    \ (l < -LONG_MAX/2 || l > LONG_MAX/2) {\n                 addReplyError(c,\"value\
    \ is out of range\");\n                 return;\n             }"
  identifiers:
  - CVE-2023-25155
  - CWE-190
  overview: Redis is an in-memory database that persists on disk. Authenticated users
    issuing specially crafted `SRANDMEMBER`, `ZRANDMEMBER`, and `HRANDFIELD` commands
    can trigger an integer overflow, resulting in a runtime assertion and termination
    of the Redis server process. This problem affects all Redis versions. Patches
    were released in Redis version(s) 6.0.18, 6.2.11 and 7.0.9.
  references:
  - source: security-advisories@github.com
    tags:
    - Patch
    url: https://github.com/redis/redis/commit/2a2a582e7cd99ba3b531336b8bd41df2b566e619
  - source: security-advisories@github.com
    tags:
    - Release Notes
    url: https://github.com/redis/redis/releases/tag/6.0.18
  - source: security-advisories@github.com
    tags:
    - Release Notes
    url: https://github.com/redis/redis/releases/tag/6.2.11
  - source: security-advisories@github.com
    tags:
    - Release Notes
    url: https://github.com/redis/redis/releases/tag/7.0.9
  - source: security-advisories@github.com
    tags:
    - Vendor Advisory
    url: https://github.com/redis/redis/security/advisories/GHSA-x2r7-j9vw-3w83
  title: Redis is an in-memory database that persists on disk. Authenticated users
    issuing specially crafted `SRANDMEMBER`, `ZRANDMEMBER`, and `HRANDFIELD` commands
    can trigger an integer overflow, resulting in a runtime assertion and termination
    of the Redis server process. This problem affects all Redis versions. Patches
    were released in Redis version(s) 6.0.18, 6.2.11 and 7.0.9.
- diff_content:
  - "--- a/drivers/media/rc/ene_ir.c\n+++ b/drivers/media/rc/ene_ir.c\n@@ -1106,14\
    \ +1106,15 @@ static void ene_remove(struct pnp_dev *pnp_dev)\n \tstruct ene_device\
    \ *dev = pnp_get_drvdata(pnp_dev);\n \tunsigned long flags;\n \n+\trc_unregister_device(dev->rdev);\n\
    +\tdel_timer_sync(&dev->tx_sim_timer);\n \tspin_lock_irqsave(&dev->hw_lock, flags);\n\
    \ \tene_rx_disable(dev);\n \tene_rx_restore_hw_buffer(dev);\n \tspin_unlock_irqrestore(&dev->hw_lock,\
    \ flags);\n \n \tfree_irq(dev->irq, dev);\n \trelease_region(dev->hw_io, ENE_IO_SIZE);\n\
    -\trc_unregister_device(dev->rdev);\n \tkfree(dev);\n }\n "
  identifiers:
  - CVE-2023-1118
  - CWE-416
  overview: A flaw use after free in the Linux kernel integrated infrared receiver/transceiver
    driver was found in the way user detaching rc device. A local user could use this
    flaw to crash the system or potentially escalate their privileges on the system.
  references:
  - source: secalert@redhat.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/torvalds/linux/commit/29b0589a865b6f66d141d79b2dd1373e4e50fe17
  - source: secalert@redhat.com
    tags:
    - Mailing List
    - Third Party Advisory
    url: https://lists.debian.org/debian-lts-announce/2023/05/msg00005.html
  - source: secalert@redhat.com
    tags:
    - Mailing List
    - Third Party Advisory
    url: https://lists.debian.org/debian-lts-announce/2023/05/msg00006.html
  - source: secalert@redhat.com
    tags:
    - Third Party Advisory
    url: https://security.netapp.com/advisory/ntap-20230413-0003/
  title: A flaw use after free in the Linux kernel integrated infrared receiver/transceiver
    driver was found in the way user detaching rc device. A local user could use this
    flaw to crash the system or potentially escalate their privileges on the system.
- diff_content:
  - "--- a/libtiff/tif_dir.c\n+++ b/libtiff/tif_dir.c\n@@ -136,32 +136,30 @@ setExtraSamples(TIFF*\
    \ tif, va_list ap, uint32_t* v)\n }\n \n /*\n- * Confirm we have \"samplesperpixel\"\
    \ ink names separated by \\0.  Returns \n+ * Count ink names separated by \\0.\
    \  Returns\n  * zero if the ink names are not as expected.\n  */\n-static uint32_t\n\
    -checkInkNamesString(TIFF* tif, uint32_t slen, const char* s)\n+static uint16_t\n\
    +countInkNamesString(TIFF *tif, uint32_t slen, const char *s)\n {\n-\tTIFFDirectory*\
    \ td = &tif->tif_dir;\n-\tuint16_t i = td->td_samplesperpixel;\n+\tuint16_t i\
    \ = 0;\n+\tconst char *ep = s + slen;\n+\tconst char *cp = s;\n \n \tif (slen\
    \ > 0) {\n-\t\tconst char* ep = s+slen;\n-\t\tconst char* cp = s;\n-\t\tfor (;\
    \ i > 0; i--) {\n+\t\tdo {\n \t\t\tfor (; cp < ep && *cp != '\\0'; cp++) {}\n\
    \ \t\t\tif (cp >= ep)\n \t\t\t\tgoto bad;\n \t\t\tcp++;\t\t\t\t/* skip \\0 */\n\
    -\t\t}\n-\t\treturn ((uint32_t)(cp - s));\n+\t\t\ti++;\n+\t\t} while (cp < ep);\n\
    +\t\treturn (i);\n \t}\n bad:\n \tTIFFErrorExt(tif->tif_clientdata, \"TIFFSetField\"\
    ,\n-\t    \"%s: Invalid InkNames value; expecting %\"PRIu16\" names, found %\"\
    PRIu16,\n-\t    tif->tif_name,\n-\t    td->td_samplesperpixel,\n-\t    (uint16_t)(td->td_samplesperpixel-i));\n\
    +\t\t\"%s: Invalid InkNames value; no NUL at given buffer end location %\"PRIu32\"\
    , after %\"PRIu16\" ink\",\n+\t\ttif->tif_name, slen, i);\n \treturn (0);\n }\n\
    \ \n@@ -478,13 +476,61 @@ _TIFFVSetField(TIFF* tif, uint32_t tag, va_list ap)\n\
    \ \t\t_TIFFsetFloatArray(&td->td_refblackwhite, va_arg(ap, float*), 6);\n \t\t\
    break;\n \tcase TIFFTAG_INKNAMES:\n-\t\tv = (uint16_t) va_arg(ap, uint16_vap);\n\
    -\t\ts = va_arg(ap, char*);\n-\t\tv = checkInkNamesString(tif, v, s);\n-\t\tstatus\
    \ = v > 0;\n-\t\tif( v > 0 ) {\n-\t\t\t_TIFFsetNString(&td->td_inknames, s, v);\n\
    -\t\t\ttd->td_inknameslen = v;\n+\t\t{\n+\t\t\tv = (uint16_t) va_arg(ap, uint16_vap);\n\
    +\t\t\ts = va_arg(ap, char*);\n+\t\t\tuint16_t ninksinstring;\n+\t\t\tninksinstring\
    \ = countInkNamesString(tif, v, s);\n+\t\t\tstatus = ninksinstring > 0;\n+\t\t\
    \tif(ninksinstring > 0 ) {\n+\t\t\t\t_TIFFsetNString(&td->td_inknames, s, v);\n\
    +\t\t\t\ttd->td_inknameslen = v;\n+\t\t\t\t/* Set NumberOfInks to the value ninksinstring\
    \ */\n+\t\t\t\tif (TIFFFieldSet(tif, FIELD_NUMBEROFINKS))\n+\t\t\t\t{\n+\t\t\t\
    \t\tif (td->td_numberofinks != ninksinstring) {\n+\t\t\t\t\t\tTIFFErrorExt(tif->tif_clientdata,\
    \ module,\n+\t\t\t\t\t\t\t\"Warning %s; Tag %s:\\n  Value %\"PRIu16\" of NumberOfInks\
    \ is different from the number of inks %\"PRIu16\".\\n  -> NumberOfInks value\
    \ adapted to %\"PRIu16\"\",\n+\t\t\t\t\t\t\ttif->tif_name, fip->field_name, td->td_numberofinks,\
    \ ninksinstring, ninksinstring);\n+\t\t\t\t\t\ttd->td_numberofinks = ninksinstring;\n\
    +\t\t\t\t\t}\n+\t\t\t\t} else {\n+\t\t\t\t\ttd->td_numberofinks = ninksinstring;\n\
    +\t\t\t\t\tTIFFSetFieldBit(tif, FIELD_NUMBEROFINKS);\n+\t\t\t\t}\n+\t\t\t\tif\
    \ (TIFFFieldSet(tif, FIELD_SAMPLESPERPIXEL))\n+\t\t\t\t{\n+\t\t\t\t\tif (td->td_numberofinks\
    \ != td->td_samplesperpixel) {\n+\t\t\t\t\t\tTIFFErrorExt(tif->tif_clientdata,\
    \ module,\n+\t\t\t\t\t\t\t\"Warning %s; Tag %s:\\n  Value %\"PRIu16\" of NumberOfInks\
    \ is different from the SamplesPerPixel value %\"PRIu16\"\",\n+\t\t\t\t\t\t\t\
    tif->tif_name, fip->field_name, td->td_numberofinks, td->td_samplesperpixel);\n\
    +\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\tbreak;\n+\tcase TIFFTAG_NUMBEROFINKS:\n\
    +\t\tv = (uint16_t)va_arg(ap, uint16_vap);\n+\t\t/* If InkNames already set also\
    \ NumberOfInks is set accordingly and should be equal */\n+\t\tif (TIFFFieldSet(tif,\
    \ FIELD_INKNAMES))\n+\t\t{\n+\t\t\tif (v != td->td_numberofinks) {\n+\t\t\t\t\
    TIFFErrorExt(tif->tif_clientdata, module,\n+\t\t\t\t\t\"Error %s; Tag %s:\\n \
    \ It is not possible to set the value %\"PRIu32\" for NumberOfInks\\n  which is\
    \ different from the number of inks in the InkNames tag (%\"PRIu16\")\",\n+\t\t\
    \t\t\ttif->tif_name, fip->field_name, v, td->td_numberofinks);\n+\t\t\t\t/* Do\
    \ not set / overwrite number of inks already set by InkNames case accordingly.\
    \ */\n+\t\t\t\tstatus = 0;\n+\t\t\t}\n+\t\t} else {\n+\t\t\ttd->td_numberofinks\
    \ = (uint16_t)v;\n+\t\t\tif (TIFFFieldSet(tif, FIELD_SAMPLESPERPIXEL))\n+\t\t\t\
    {\n+\t\t\t\tif (td->td_numberofinks != td->td_samplesperpixel) {\n+\t\t\t\t\t\
    TIFFErrorExt(tif->tif_clientdata, module,\n+\t\t\t\t\t\t\"Warning %s; Tag %s:\\\
    n  Value %\"PRIu32\" of NumberOfInks is different from the SamplesPerPixel value\
    \ %\"PRIu16\"\",\n+\t\t\t\t\t\ttif->tif_name, fip->field_name, v, td->td_samplesperpixel);\n\
    +\t\t\t\t}\n+\t\t\t}\n \t\t}\n \t\tbreak;\n \tcase TIFFTAG_PERSAMPLE:\n@@ -986,34\
    \ +1032,6 @@ _TIFFVGetField(TIFF* tif, uint32_t tag, va_list ap)\n \tif (fip->field_bit\
    \ == FIELD_CUSTOM) {\n \t\tstandard_tag = 0;\n \t}\n-\t\n-        if( standard_tag\
    \ == TIFFTAG_NUMBEROFINKS )\n-        {\n-            int i;\n-            for\
    \ (i = 0; i < td->td_customValueCount; i++) {\n-                uint16_t val;\n\
    -                TIFFTagValue *tv = td->td_customValues + i;\n-              \
    \  if (tv->info->field_tag != standard_tag)\n-                    continue;\n\
    -                if( tv->value == NULL )\n-                    return 0;\n-  \
    \              val = *(uint16_t *)tv->value;\n-                /* Truncate to\
    \ SamplesPerPixel, since the */\n-                /* setting code for INKNAMES\
    \ assume that there are SamplesPerPixel */\n-                /* inknames. */\n\
    -                /* Fixes http://bugzilla.maptools.org/show_bug.cgi?id=2599 */\n\
    -                if( val > td->td_samplesperpixel )\n-                {\n-   \
    \                 TIFFWarningExt(tif->tif_clientdata,\"_TIFFVGetField\",\n-  \
    \                                 \"Truncating NumberOfInks from %u to %\"PRIu16,\n\
    -                                   val, td->td_samplesperpixel);\n-         \
    \           val = td->td_samplesperpixel;\n-                }\n-             \
    \   *va_arg(ap, uint16_t*) = val;\n-                return 1;\n-            }\n\
    -            return 0;\n-        }\n \n \tswitch (standard_tag) {\n \t\tcase TIFFTAG_SUBFILETYPE:\n\
    @@ -1195,6 +1213,9 @@ _TIFFVGetField(TIFF* tif, uint32_t tag, va_list ap)\n \t\
    \tcase TIFFTAG_INKNAMES:\n \t\t\t*va_arg(ap, const char**) = td->td_inknames;\n\
    \ \t\t\tbreak;\n+\t\tcase TIFFTAG_NUMBEROFINKS:\n+\t\t\t*va_arg(ap, uint16_t *)\
    \ = td->td_numberofinks;\n+\t\t\tbreak;\n \t\tdefault:\n \t\t\t{\n \t\t\t\tint\
    \ i;\n"
  - "--- a/libtiff/tif_dirinfo.c\n+++ b/libtiff/tif_dirinfo.c\n@@ -114,7 +114,7 @@\
    \ tiffFields[] = {\n \t{ TIFFTAG_SUBIFD, -1, -1, TIFF_IFD8, 0, TIFF_SETGET_C16_IFD8,\
    \ TIFF_SETGET_UNDEFINED, FIELD_SUBIFD, 1, 1, \"SubIFD\", (TIFFFieldArray*) &tiffFieldArray\
    \ },\n \t{ TIFFTAG_INKSET, 1, 1, TIFF_SHORT, 0, TIFF_SETGET_UINT16, TIFF_SETGET_UNDEFINED,\
    \ FIELD_CUSTOM, 0, 0, \"InkSet\", NULL },\n \t{ TIFFTAG_INKNAMES, -1, -1, TIFF_ASCII,\
    \ 0, TIFF_SETGET_C16_ASCII, TIFF_SETGET_UNDEFINED, FIELD_INKNAMES, 1, 1, \"InkNames\"\
    , NULL },\n-\t{ TIFFTAG_NUMBEROFINKS, 1, 1, TIFF_SHORT, 0, TIFF_SETGET_UINT16,\
    \ TIFF_SETGET_UNDEFINED, FIELD_CUSTOM, 1, 0, \"NumberOfInks\", NULL },\n+\t{ TIFFTAG_NUMBEROFINKS,\
    \ 1, 1, TIFF_SHORT, 0, TIFF_SETGET_UINT16, TIFF_SETGET_UNDEFINED, FIELD_NUMBEROFINKS,\
    \ 1, 0, \"NumberOfInks\", NULL },\n \t{ TIFFTAG_DOTRANGE, 2, 2, TIFF_SHORT, 0,\
    \ TIFF_SETGET_UINT16_PAIR, TIFF_SETGET_UNDEFINED, FIELD_CUSTOM, 0, 0, \"DotRange\"\
    , NULL },\n \t{ TIFFTAG_TARGETPRINTER, -1, -1, TIFF_ASCII, 0, TIFF_SETGET_ASCII,\
    \ TIFF_SETGET_UNDEFINED, FIELD_CUSTOM, 1, 0, \"TargetPrinter\", NULL },\n \t{\
    \ TIFFTAG_EXTRASAMPLES, -1, -1, TIFF_SHORT, 0, TIFF_SETGET_C16_UINT16, TIFF_SETGET_UNDEFINED,\
    \ FIELD_EXTRASAMPLES, 0, 1, \"ExtraSamples\", NULL },\n"
  - "--- a/libtiff/tif_dirwrite.c\n+++ b/libtiff/tif_dirwrite.c\n@@ -626,6 +626,11\
    \ @@ TIFFWriteDirectorySec(TIFF* tif, int isimage, int imagedone, uint64_t* pdiroff)\n\
    \ \t\t\t\tif (!TIFFWriteDirectoryTagAscii(tif,&ndir,dir,TIFFTAG_INKNAMES,tif->tif_dir.td_inknameslen,tif->tif_dir.td_inknames))\n\
    \ \t\t\t\t\tgoto bad;\n \t\t\t}\n+\t\t\tif (TIFFFieldSet(tif, FIELD_NUMBEROFINKS))\n\
    +\t\t\t{\n+\t\t\t\tif (!TIFFWriteDirectoryTagShort(tif, &ndir, dir, TIFFTAG_NUMBEROFINKS,\
    \ tif->tif_dir.td_numberofinks))\n+\t\t\t\t\tgoto bad;\n+\t\t\t}\n \t\t\tif (TIFFFieldSet(tif,FIELD_SUBIFD))\n\
    \ \t\t\t{\n \t\t\t\tif (!TIFFWriteDirectoryTagSubifd(tif,&ndir,dir))\n"
  - "--- a/libtiff/tif_print.c\n+++ b/libtiff/tif_print.c\n@@ -397,6 +397,10 @@ TIFFPrintDirectory(TIFF*\
    \ tif, FILE* fd, long flags)\n \t\t}\n                 fputs(\"\\n\", fd);\n \t\
    }\n+\tif (TIFFFieldSet(tif, FIELD_NUMBEROFINKS)) {\n+\t\tfprintf(fd, \"  NumberOfInks:\
    \ %d\\n\",\n+\t\t\ttd->td_numberofinks);\n+\t}\n \tif (TIFFFieldSet(tif,FIELD_THRESHHOLDING))\
    \ {\n \t\tfprintf(fd, \"  Thresholding: \");\n \t\tswitch (td->td_threshholding)\
    \ {\n"
  identifiers:
  - CVE-2022-4645
  - CWE-125
  overview: LibTIFF 4.4.0 has an out-of-bounds read in tiffcp in tools/tiffcp.c:948,
    allowing attackers to cause a denial-of-service via a crafted tiff file. For users
    that compile libtiff from sources, the fix is available with commit e8131125.
  references:
  - source: cve@gitlab.com
    tags:
    - Third Party Advisory
    url: https://gitlab.com/gitlab-org/cves/-/blob/master/2022/CVE-2022-4645.json
  - source: cve@gitlab.com
    tags:
    - Patch
    url: https://gitlab.com/libtiff/libtiff/-/commit/e813112545942107551433d61afd16ac094ff246
  - source: cve@gitlab.com
    tags:
    - Exploit
    - Issue Tracking
    - Vendor Advisory
    url: https://gitlab.com/libtiff/libtiff/-/issues/277
  - source: cve@gitlab.com
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/2ZTFA6GGOKFPIQNHDBMXYUR4XUXUJESE/
  - source: cve@gitlab.com
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/BA6GRCAQ7NR2OK5N44UQRGUJBIYKWJJH/
  - source: cve@gitlab.com
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/OLM763GGZVVOAXIQXG6YGTYJ5VFYNECQ/
  - source: cve@gitlab.com
    url: https://security.netapp.com/advisory/ntap-20230331-0001/
  title: LibTIFF 4.4.0 has an out-of-bounds read in tiffcp in tools/tiffcp.c:948,
    allowing attackers to cause a denial-of-service via a crafted tiff file. For users
    that compile libtiff from sources, the fix is available with commit e8131125.
- diff_content:
  - "--- a/sys/net/pf.c\n+++ b/sys/net/pf.c\n@@ -1,4 +1,4 @@\n-/*\t$OpenBSD: pf.c,v\
    \ 1.1169 2023/01/06 17:44:34 sashan Exp $ */\n+/*\t$OpenBSD: pf.c,v 1.1170 2023/01/12\
    \ 13:09:47 bluhm Exp $ */\n \n /*\n  * Copyright (c) 2001 Daniel Hartmeier\n@@\
    \ -7254,7 +7254,8 @@ pf_setup_pdesc(struct pf_pdesc *pd, sa_family_t af, int dir,\n\
    \ \t\t    NULL, reason, pd->af))\n \t\t\treturn (PF_DROP);\n \t\tpd->hdrlen =\
    \ sizeof(*th);\n-\t\tif (pd->off + (th->th_off << 2) > pd->tot_len ||\n+\t\tif\
    \ (th->th_dport == 0 ||\n+\t\t    pd->off + (th->th_off << 2) > pd->tot_len ||\n\
    \ \t\t    (th->th_off << 2) < sizeof(struct tcphdr)) {\n \t\t\tREASON_SET(reason,\
    \ PFRES_SHORT);\n \t\t\treturn (PF_DROP);"
  - "--- a/sys/netinet/tcp_input.c\n+++ b/sys/netinet/tcp_input.c\n@@ -1,4 +1,4 @@\n\
    -/*\t$OpenBSD: tcp_input.c,v 1.384 2022/12/09 00:24:44 bluhm Exp $\t*/\n+/*\t\
    $OpenBSD: tcp_input.c,v 1.385 2023/01/12 13:09:47 bluhm Exp $\t*/\n /*\t$NetBSD:\
    \ tcp_input.c,v 1.23 1996/02/13 23:43:44 christos Exp $\t*/\n \n /*\n@@ -522,6\
    \ +522,11 @@ tcp_input(struct mbuf **mp, int *offp, int proto, int af)\n \tth->th_win\
    \ = ntohs(th->th_win);\n \tth->th_urp = ntohs(th->th_urp);\n \n+\tif (th->th_dport\
    \ == 0) {\n+\t\ttcpstat_inc(tcps_noport);\n+\t\tgoto dropwithreset_ratelim;\n\
    +\t}\n+\n \t/*\n \t * Locate pcb for segment.\n \t */"
  identifiers:
  - CVE-2023-27567
  - NVD-CWE-noinfo
  overview: In OpenBSD 7.2, a TCP packet with destination port 0 that matches a pf
    divert-to rule can crash the kernel.
  references:
  - source: cve@mitre.org
    tags:
    - Patch
    url: https://ftp.openbsd.org/pub/OpenBSD/patches/7.2/common/013_tcp.patch.sig
  - source: cve@mitre.org
    url: https://github.com/openbsd/src/commit/0a543725ccdd2a01669122ce79bb67e66ede77f2
  - source: cve@mitre.org
    url: https://security.netapp.com/advisory/ntap-20230406-0001/
  title: In OpenBSD 7.2, a TCP packet with destination port 0 that matches a pf divert-to
    rule can crash the kernel.
- diff_content:
  - "--- a/src/register.c\n+++ b/src/register.c\n@@ -1928,7 +1928,7 @@ do_put(\n \t\
    \tptr += yanklen;\n \n \t\t// insert block's trailing spaces only if there's text\
    \ behind\n-\t\tif ((j < count - 1 || !shortline) && spaces)\n+\t\tif ((j < count\
    \ - 1 || !shortline) && spaces > 0)\n \t\t{\n \t\t    vim_memset(ptr, ' ', (size_t)spaces);\n\
    \ \t\t    ptr += spaces;\n@@ -2284,6 +2284,15 @@ do_put(\n     msgmore(nr_lines);\n\
    \     curwin->w_set_curswant = TRUE;\n \n+    // Make sure the cursor is not after\
    \ the NUL.\n+    int len = (int)STRLEN(ml_get_curline());\n+    if (curwin->w_cursor.col\
    \ > len)\n+    {\n+\tif (cur_ve_flags == VE_ALL)\n+\t    curwin->w_cursor.coladd\
    \ = curwin->w_cursor.col - len;\n+\tcurwin->w_cursor.col = len;\n+    }\n+\n end:\n\
    \     if (cmdmod.cmod_flags & CMOD_LOCKMARKS)\n     {"
  - "--- a/src/version.c\n+++ b/src/version.c\n@@ -695,6 +695,8 @@ static char *(features[])\
    \ =\n \n static int included_patches[] =\n {   /* Add new patch number below this\
    \ line */\n+/**/\n+    1376,\n /**/\n     1375,\n /**/"
  identifiers:
  - CVE-2023-1170
  - CWE-122
  overview: Heap-based Buffer Overflow in GitHub repository vim/vim prior to 9.0.1376.
  references:
  - source: security@huntr.dev
    tags:
    - Patch
    url: https://github.com/vim/vim/commit/1c73b65229c25e3c1fd8824ba958f7cc4d604f9c
  - source: security@huntr.dev
    tags:
    - Exploit
    - Patch
    - Third Party Advisory
    url: https://huntr.dev/bounties/286e0090-e654-46d2-ac60-29f81799d0a4
  - source: security@huntr.dev
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/DIAKPMKJ4OZ6NYRZJO7YWMNQL2BICLYV/
  - source: security@huntr.dev
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/IE44W6WMMREYCW3GJHPSYP7NK2VT5NY6/
  - source: security@huntr.dev
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/X4KDAU76Z7QNSPKZX2JAJ6O7KIEOXWTL/
  title: Heap-based Buffer Overflow in GitHub repository vim/vim prior to 9.0.1376.
- diff_content:
  - "--- a/src/register.c\n+++ b/src/register.c\n@@ -1245,6 +1245,8 @@ op_yank(oparg_T\
    \ *oap, int deleting, int mess)\n \t\t\t\t// double-count it.\n \t\t\t\tbd.startspaces\
    \ = (ce - cs + 1)\n \t\t\t\t\t\t\t  - oap->start.coladd;\n+\t\t\t\tif (bd.startspaces\
    \ < 0)\n+\t\t\t\t    bd.startspaces = 0;\n \t\t\t\tstartcol++;\n \t\t\t    }\n\
    \ \t\t\t}"
  - "--- a/src/version.c\n+++ b/src/version.c\n@@ -695,6 +695,8 @@ static char *(features[])\
    \ =\n \n static int included_patches[] =\n {   /* Add new patch number below this\
    \ line */\n+/**/\n+    1378,\n /**/\n     1377,\n /**/"
  identifiers:
  - CVE-2023-1175
  - CWE-131
  overview: Incorrect Calculation of Buffer Size in GitHub repository vim/vim prior
    to 9.0.1378.
  references:
  - source: security@huntr.dev
    tags:
    - Patch
    url: https://github.com/vim/vim/commit/c99cbf8f289bdda5d4a77d7ec415850a520330ba
  - source: security@huntr.dev
    tags:
    - Exploit
    - Patch
    - Third Party Advisory
    url: https://huntr.dev/bounties/7e93fc17-92eb-4ae7-b01a-93bb460b643e
  - source: security@huntr.dev
    url: https://lists.debian.org/debian-lts-announce/2023/06/msg00015.html
  - source: security@huntr.dev
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/DIAKPMKJ4OZ6NYRZJO7YWMNQL2BICLYV/
  - source: security@huntr.dev
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/IE44W6WMMREYCW3GJHPSYP7NK2VT5NY6/
  - source: security@huntr.dev
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/X4KDAU76Z7QNSPKZX2JAJ6O7KIEOXWTL/
  title: Incorrect Calculation of Buffer Size in GitHub repository vim/vim prior to
    9.0.1378.
- diff_content:
  - "--- a/libproxy/proxy.c\n+++ b/libproxy/proxy.c\n@@ -294,7 +294,6 @@ int http_connect(int\
    \ sockfd, const char *host, int port, AyProxyData *proxy)\n \tchar cmd[512];\n\
    \ \tchar *inputline = NULL;\n \tchar *proxy_auth = NULL;\n-\tchar debug_buff[512];\n\
    \ \tint remaining = sizeof(cmd) - 1;\n \n \tremaining -= snprintf(cmd, sizeof(cmd),\
    \ \"CONNECT %s:%d HTTP/1.1\\r\\n\", host, port);\n@@ -309,17 +308,15 @@ int http_connect(int\
    \ sockfd, const char *host, int port, AyProxyData *proxy)\n \t\tremaining -= 2;\n\
    \ \t}\n \tstrncat(cmd, \"\\r\\n\", remaining);\n-#ifndef DEBUG\n-\tsnprintf(debug_buff,\
    \ sizeof(debug_buff), \"<%s>\\n\", cmd);\n-\tdebug_print(debug_buff);\n+#ifdef\
    \ DEBUG\n+\tdebug_print(\"<%s>\\n\", cmd);\n #endif\n \tif (send(sockfd, cmd,\
    \ strlen(cmd), 0) < 0)\n \t\treturn AY_CONNECTION_REFUSED;\n \tif (ay_recv_line(sockfd,\
    \ &inputline) < 0)\n \t\treturn AY_CONNECTION_REFUSED;\n-#ifndef DEBUG\n-\tsnprintf(debug_buff,\
    \ sizeof(debug_buff), \"<%s>\\n\", inputline);\n-\tdebug_print(debug_buff);\n\
    +#ifdef DEBUG\n+\tdebug_print(\"<%s>\\n\", inputline);\n #endif\n \tif (!strstr(inputline,\
    \ \"200\")) {\n \t\t/* Check if proxy authorization needed */\n@@ -344,9 +341,8\
    \ @@ int http_connect(int sockfd, const char *host, int port, AyProxyData *proxy)\n\
    \ \t\tif (ay_recv_line(sockfd, &inputline) < 0) {\n \t\t\treturn AY_CONNECTION_REFUSED;\n\
    \ \t\t}\n-#ifndef DEBUG\n-\t\tsnprintf(debug_buff, sizeof(debug_buff), \"<%s>\\\
    n\", inputline);\n-\t\tdebug_print(debug_buff);\n+#ifdef DEBUG\n+\t\tdebug_print(\"\
    <%s>\\n\", inputline);\n #endif\n \t}\n \tfree(inputline);"
  identifiers:
  - CVE-2015-10088
  - CWE-134
  overview: A vulnerability, which was classified as critical, was found in ayttm
    up to 0.5.0.89. This affects the function http_connect in the library libproxy/proxy.c.
    The manipulation leads to format string. It is possible to initiate the attack
    remotely. The complexity of an attack is rather high. The exploitability is told
    to be difficult. The patch is named 40e04680018614a7d2b68566b261b061a0597046.
    It is recommended to apply a patch to fix this issue. The associated identifier
    of this vulnerability is VDB-222267.
  references:
  - source: cna@vuldb.com
    tags:
    - Patch
    url: https://github.com/ayttm/ayttm/commit/40e04680018614a7d2b68566b261b061a0597046
  - source: cna@vuldb.com
    tags:
    - Third Party Advisory
    url: https://sourceforge.net/p/ayttm/mailman/message/34397158/
  - source: cna@vuldb.com
    tags:
    - Permissions Required
    - Third Party Advisory
    url: https://vuldb.com/?ctiid.222267
  - source: cna@vuldb.com
    tags:
    - Third Party Advisory
    url: https://vuldb.com/?id.222267
  title: A vulnerability, which was classified as critical, was found in ayttm up
    to 0.5.0.89. This affects the function http_connect in the library libproxy/proxy.c.
    The manipulation leads to format string. It is possible to initiate the attack
    remotely. The complexity of an attack is rather high. The exploitability is told
    to be difficult. The patch is named 40e04680018614a7d2b68566b261b061a0597046.
    It is recommended to apply a patch to fix this issue. The associated identifier
    of this vulnerability is VDB-222267.
- diff_content:
  - "--- a/CoinSpend.cpp\n+++ b/CoinSpend.cpp\n@@ -29,6 +29,11 @@ CoinSpend::CoinSpend(const\
    \ Params* p, const PrivateCoin& coin,\n \t\tthrow ZerocoinException(\"Accumulator\
    \ witness does not verify\");\n \t}\n \n+\t// The serial # needs to be within\
    \ the specified range our else it can be incremented by the modulus and create\
    \ another valid proof\n+\tif (!HasValidSerial()) {\n+\t\tthrow ZerocoinException(\"\
    Invalid serial # range\");\n+\t}\n+\n \t// 1: Generate two separate commitments\
    \ to the public coin (C), each under\n \t// a different set of public parameters.\
    \ We do this because the RSA accumulator\n \t// has specific requirements for\
    \ the commitment parameters that are not\n@@ -79,4 +84,9 @@ const uint256 CoinSpend::signatureHash(const\
    \ SpendMetaData &m) const {\n \treturn h.GetHash();\n }\n \n+bool CoinSpend::HasValidSerial()\
    \ const\n+{\n+\treturn coinSerialNumber > 0 && coinSerialNumber < params->coinCommitmentGroup.groupOrder;\n\
    +}\n+\n } /* namespace libzerocoin */"
  identifiers:
  - CVE-2017-20180
  - CWE-345
  overview: A vulnerability classified as critical has been found in Zerocoin libzerocoin.
    Affected is the function CoinSpend::CoinSpend of the file CoinSpend.cpp of the
    component Proof Handler. The manipulation leads to insufficient verification of
    data authenticity. Continious delivery with rolling releases is used by this product.
    Therefore, no version details of affected nor updated releases are available.
    The patch is identified as ce103a09ec079d0a0ed95475992348bed6e860de. It is recommended
    to apply a patch to fix this issue. VDB-222318 is the identifier assigned to this
    vulnerability.
  references:
  - source: cna@vuldb.com
    tags:
    - Patch
    url: https://github.com/Zerocoin/libzerocoin/commit/ce103a09ec079d0a0ed95475992348bed6e860de
  - source: cna@vuldb.com
    tags:
    - Patch
    url: https://github.com/Zerocoin/libzerocoin/pull/16
  - source: cna@vuldb.com
    tags:
    - Permissions Required
    - Third Party Advisory
    url: https://vuldb.com/?ctiid.222318
  - source: cna@vuldb.com
    tags:
    - Third Party Advisory
    url: https://vuldb.com/?id.222318
  title: A vulnerability classified as critical has been found in Zerocoin libzerocoin.
    Affected is the function CoinSpend::CoinSpend of the file CoinSpend.cpp of the
    component Proof Handler. The manipulation leads to insufficient verification of
    data authenticity. Continious delivery with rolling releases is used by this product.
    Therefore, no version details of affected nor updated releases are available.
    The patch is identified as ce103a09ec079d0a0ed95475992348bed6e860de. It is recommended
    to apply a patch to fix this issue. VDB-222318 is the identifier assigned to this
    vulnerability.
- diff_content:
  - "--- a/drivers/misc/sgi-gru/grufault.c\n+++ b/drivers/misc/sgi-gru/grufault.c\n\
    @@ -648,6 +648,7 @@ int gru_handle_user_call_os(unsigned long cb)\n \tif ((cb\
    \ & (GRU_HANDLE_STRIDE - 1)) || ucbnum >= GRU_NUM_CB)\n \t\treturn -EINVAL;\n\
    \ \n+again:\n \tgts = gru_find_lock_gts(cb);\n \tif (!gts)\n \t\treturn -EINVAL;\n\
    @@ -656,7 +657,11 @@ int gru_handle_user_call_os(unsigned long cb)\n \tif (ucbnum\
    \ >= gts->ts_cbr_au_count * GRU_CBR_AU_SIZE)\n \t\tgoto exit;\n \n-\tgru_check_context_placement(gts);\n\
    +\tif (gru_check_context_placement(gts)) {\n+\t\tgru_unlock_gts(gts);\n+\t\tgru_unload_context(gts,\
    \ 1);\n+\t\tgoto again;\n+\t}\n \n \t/*\n \t * CCH may contain stale data if ts_force_cch_reload\
    \ is set.\n@@ -874,7 +879,11 @@ int gru_set_context_option(unsigned long arg)\n\
    \ \t\t} else {\n \t\t\tgts->ts_user_blade_id = req.val1;\n \t\t\tgts->ts_user_chiplet_id\
    \ = req.val0;\n-\t\t\tgru_check_context_placement(gts);\n+\t\t\tif (gru_check_context_placement(gts))\
    \ {\n+\t\t\t\tgru_unlock_gts(gts);\n+\t\t\t\tgru_unload_context(gts, 1);\n+\t\t\
    \t\treturn ret;\n+\t\t\t}\n \t\t}\n \t\tbreak;\n \tcase sco_gseg_owner:"
  - "--- a/drivers/misc/sgi-gru/grumain.c\n+++ b/drivers/misc/sgi-gru/grumain.c\n\
    @@ -716,25 +716,34 @@ static int gru_check_chiplet_assignment(struct gru_state\
    \ *gru,\n  * chiplet. Misassignment can occur if the process migrates to a different\n\
    \  * blade or if the user changes the selected blade/chiplet.\n  */\n-void gru_check_context_placement(struct\
    \ gru_thread_state *gts)\n+int gru_check_context_placement(struct gru_thread_state\
    \ *gts)\n {\n \tstruct gru_state *gru;\n+\tint ret = 0;\n \n \t/*\n \t * If the\
    \ current task is the context owner, verify that the\n \t * context is correctly\
    \ placed. This test is skipped for non-owner\n \t * references. Pthread apps use\
    \ non-owner references to the CBRs.\n \t */\n \tgru = gts->ts_gru;\n+\t/*\n+\t\
    \ * If gru or gts->ts_tgid_owner isn't initialized properly, return\n+\t * success\
    \ to indicate that the caller does not need to unload the\n+\t * gru context.The\
    \ caller is responsible for their inspection and\n+\t * reinitialization if needed.\n\
    +\t */\n \tif (!gru || gts->ts_tgid_owner != current->tgid)\n-\t\treturn;\n+\t\
    \treturn ret;\n \n \tif (!gru_check_chiplet_assignment(gru, gts)) {\n \t\tSTAT(check_context_unload);\n\
    -\t\tgru_unload_context(gts, 1);\n+\t\tret = -EINVAL;\n \t} else if (gru_retarget_intr(gts))\
    \ {\n \t\tSTAT(check_context_retarget_intr);\n \t}\n+\n+\treturn ret;\n }\n \n\
    \ \n@@ -934,7 +943,12 @@ vm_fault_t gru_fault(struct vm_fault *vmf)\n \tmutex_lock(&gts->ts_ctxlock);\n\
    \ \tpreempt_disable();\n \n-\tgru_check_context_placement(gts);\n+\tif (gru_check_context_placement(gts))\
    \ {\n+\t\tpreempt_enable();\n+\t\tmutex_unlock(&gts->ts_ctxlock);\n+\t\tgru_unload_context(gts,\
    \ 1);\n+\t\treturn VM_FAULT_NOPAGE;\n+\t}\n \n \tif (!gts->ts_gru) {\n \t\tSTAT(load_user_context);"
  identifiers:
  - CVE-2022-3424
  - CWE-416
  overview: "A use-after-free flaw was found in the Linux kernel\u2019s SGI GRU driver\
    \ in the way the first gru_file_unlocked_ioctl function is called by the user,\
    \ where a fail pass occurs in the gru_check_chiplet_assignment function. This\
    \ flaw allows a local user to crash or potentially escalate their privileges on\
    \ the system."
  references:
  - source: secalert@redhat.com
    tags:
    - Issue Tracking
    - Patch
    - Third Party Advisory
    url: https://bugzilla.redhat.com/show_bug.cgi?id=2132640
  - source: secalert@redhat.com
    tags:
    - Patch
    url: https://github.com/torvalds/linux/commit/643a16a0eb1d6ac23744bb6e90a00fc21148a9dc
  - source: secalert@redhat.com
    tags:
    - Mailing List
    - Third Party Advisory
    url: https://lists.debian.org/debian-lts-announce/2023/05/msg00005.html
  - source: secalert@redhat.com
    tags:
    - Mailing List
    - Third Party Advisory
    url: https://lists.debian.org/debian-lts-announce/2023/05/msg00006.html
  - source: secalert@redhat.com
    url: https://lore.kernel.org/all/20221019031445.901570-1-zyytlz.wz%40163.com/
  - source: secalert@redhat.com
    tags:
    - Third Party Advisory
    url: https://security.netapp.com/advisory/ntap-20230406-0005/
  - source: secalert@redhat.com
    tags:
    - Mailing List
    - Patch
    url: https://www.spinics.net/lists/kernel/msg4518970.html
  title: "A use-after-free flaw was found in the Linux kernel\u2019s SGI GRU driver\
    \ in the way the first gru_file_unlocked_ioctl function is called by the user,\
    \ where a fail pass occurs in the gru_check_chiplet_assignment function. This\
    \ flaw allows a local user to crash or potentially escalate their privileges on\
    \ the system."
- diff_content:
  - "--- a/test/tests/memcached/noblock.cpp\n+++ b/test/tests/memcached/noblock.cpp\n\
    @@ -23,9 +23,6 @@ TEST_CASE(\"memcached_noblock\") {\n       break;\n     case\
    \ MEMCACHED_TIMEOUT:\n     case MEMCACHED_WRITE_FAILURE:\n-      if(!timeout)\
    \ {\n-        --i;\n-      }\n       ++hit;\n       REQUIRE(true);\n       break;"
  identifiers:
  - CVE-2023-27478
  - CWE-200
  overview: 'libmemcached-awesome is an open source C/C++ client library and tools
    for the memcached server. `libmemcached` could return data for a previously requested
    key, if that previous request timed out due to a low `POLL_TIMEOUT`. This issue
    has been addressed in version 1.1.4. Users are advised to upgrade. There are several
    ways to workaround or lower the probability of this bug affecting a given deployment.
    1: use a reasonably high `POLL_TIMEOUT` setting, like the default. 2: use separate
    libmemcached connections for unrelated data. 3: do not re-use libmemcached connections
    in an unknown state.'
  references:
  - source: security-advisories@github.com
    tags:
    - Patch
    url: https://github.com/awesomized/libmemcached/commit/48dcc61a
  - source: security-advisories@github.com
    tags:
    - Release Notes
    url: https://github.com/awesomized/libmemcached/releases/tag/1.1.4
  - source: security-advisories@github.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/awesomized/libmemcached/security/advisories/GHSA-wwmh-39wj-fx59
  - source: security-advisories@github.com
    tags:
    - Exploit
    - Issue Tracking
    - Patch
    - Third Party Advisory
    url: https://github.com/php-memcached-dev/php-memcached/issues/531
  title: 'libmemcached-awesome is an open source C/C++ client library and tools for
    the memcached server. `libmemcached` could return data for a previously requested
    key, if that previous request timed out due to a low `POLL_TIMEOUT`. This issue
    has been addressed in version 1.1.4. Users are advised to upgrade. There are several
    ways to workaround or lower the probability of this bug affecting a given deployment.
    1: use a reasonably high `POLL_TIMEOUT` setting, like the default. 2: use separate
    libmemcached connections for unrelated data. 3: do not re-use libmemcached connections
    in an unknown state.'
- diff_content:
  - "--- a/src/getchar.c\n+++ b/src/getchar.c\n@@ -3107,7 +3107,7 @@ check_end_reg_executing(int\
    \ advance)\n     static int\n vgetorpeek(int advance)\n {\n-    int\t\tc, c1;\n\
    +    int\t\tc;\n     int\t\ttimedout = FALSE;\t// waited for more than 'timeoutlen'\n\
    \ \t\t\t\t\t// for mapping to complete or\n \t\t\t\t\t// 'ttimeoutlen' for complete\
    \ key code\n@@ -3474,7 +3474,7 @@ vgetorpeek(int advance)\n \t\t * to the user\
    \ with showcmd.\n \t\t */\n \t\tshowcmd_idx = 0;\n-\t\tc1 = 0;\n+\t\tint showing_partial\
    \ = FALSE;\n \t\tif (typebuf.tb_len > 0 && advance && !exmode_active)\n \t\t{\n\
    \ \t\t    if (((State & (MODE_NORMAL | MODE_INSERT))\n@@ -3489,7 +3489,7 @@ vgetorpeek(int\
    \ advance)\n \t\t\t    edit_putchar(typebuf.tb_buf[typebuf.tb_off\n \t\t\t\t\t\
    \t+ typebuf.tb_len - 1], FALSE);\n \t\t\t    setcursor(); // put cursor back where\
    \ it belongs\n-\t\t\t    c1 = 1;\n+\t\t\t    showing_partial = TRUE;\n \t\t\t\
    }\n \t\t\t// need to use the col and row from above here\n \t\t\told_wcol = curwin->w_wcol;\n\
    @@ -3506,8 +3506,10 @@ vgetorpeek(int advance)\n \t\t\tcurwin->w_wrow = old_wrow;\n\
    \ \t\t    }\n \n-\t\t    // this looks nice when typing a dead character map\n\
    +\t\t    // This looks nice when typing a dead character map.\n+\t\t    // There\
    \ is no actual command line for get_number().\n \t\t    if ((State & MODE_CMDLINE)\n\
    +\t\t\t    && get_cmdline_info()->cmdbuff != NULL\n #if defined(FEAT_CRYPT) ||\
    \ defined(FEAT_EVAL)\n \t\t\t    && cmdline_star == 0\n #endif\n@@ -3516,7 +3518,7\
    \ @@ vgetorpeek(int advance)\n \t\t    {\n \t\t\tputcmdline(typebuf.tb_buf[typebuf.tb_off\n\
    \ \t\t\t\t\t\t+ typebuf.tb_len - 1], FALSE);\n-\t\t\tc1 = 1;\n+\t\t\tshowing_partial\
    \ = TRUE;\n \t\t    }\n \t\t}\n \n@@ -3550,11 +3552,12 @@ vgetorpeek(int advance)\n\
    \ \n \t\tif (showcmd_idx != 0)\n \t\t    pop_showcmd();\n-\t\tif (c1 == 1)\n+\t\
    \tif (showing_partial)\n \t\t{\n \t\t    if (State & MODE_INSERT)\n \t\t\tedit_unputchar();\n\
    -\t\t    if (State & MODE_CMDLINE)\n+\t\t    if ((State & MODE_CMDLINE)\n+\t\t\
    \t\t\t&& get_cmdline_info()->cmdbuff != NULL)\n \t\t\tunputcmdline();\n \t\t \
    \   else\n \t\t\tsetcursor();\t// put cursor back where it belongs"
  - "--- a/src/version.c\n+++ b/src/version.c\n@@ -695,6 +695,8 @@ static char *(features[])\
    \ =\n \n static int included_patches[] =\n {   /* Add new patch number below this\
    \ line */\n+/**/\n+    1392,\n /**/\n     1391,\n /**/"
  identifiers:
  - CVE-2023-1264
  - CWE-476
  overview: NULL Pointer Dereference in GitHub repository vim/vim prior to 9.0.1392.
  references:
  - source: security@huntr.dev
    tags:
    - Patch
    url: https://github.com/vim/vim/commit/7ac5023a5f1a37baafbe1043645f97ba3443d9f6
  - source: security@huntr.dev
    tags:
    - Exploit
    - Patch
    - Third Party Advisory
    url: https://huntr.dev/bounties/b2989095-88f3-413a-9a39-c1c58a6e6815
  - source: security@huntr.dev
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/DIAKPMKJ4OZ6NYRZJO7YWMNQL2BICLYV/
  - source: security@huntr.dev
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/IE44W6WMMREYCW3GJHPSYP7NK2VT5NY6/
  - source: security@huntr.dev
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/X4KDAU76Z7QNSPKZX2JAJ6O7KIEOXWTL/
  title: NULL Pointer Dereference in GitHub repository vim/vim prior to 9.0.1392.
- diff_content:
  - "--- a/drivers/gpu/drm/nouveau/nvkm/subdev/mmu/uvmm.c\n+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/mmu/uvmm.c\n\
    @@ -134,23 +134,10 @@ nvkm_uvmm_mthd_map(struct nvkm_uvmm *uvmm, void *argv, u32\
    \ argc)\n \t\t\tgoto fail;\n \t\t}\n \n-\t\tif (vma->addr != addr) {\n-\t\t\t\
    const u64 tail = vma->size + vma->addr - addr;\n-\t\t\tif (ret = -ENOMEM, !(vma\
    \ = nvkm_vma_tail(vma, tail)))\n-\t\t\t\tgoto fail;\n-\t\t\tvma->part = true;\n\
    -\t\t\tnvkm_vmm_node_insert(vmm, vma);\n-\t\t}\n-\n-\t\tif (vma->size != size)\
    \ {\n-\t\t\tconst u64 tail = vma->size - size;\n-\t\t\tstruct nvkm_vma *tmp;\n\
    -\t\t\tif (ret = -ENOMEM, !(tmp = nvkm_vma_tail(vma, tail))) {\n-\t\t\t\tnvkm_vmm_unmap_region(vmm,\
    \ vma);\n-\t\t\t\tgoto fail;\n-\t\t\t}\n-\t\t\ttmp->part = true;\n-\t\t\tnvkm_vmm_node_insert(vmm,\
    \ tmp);\n+\t\tvma = nvkm_vmm_node_split(vmm, vma, addr, size);\n+\t\tif (!vma)\
    \ {\n+\t\t\tret = -ENOMEM;\n+\t\t\tgoto fail;\n \t\t}\n \t}\n \tvma->busy = true;"
  - "--- a/drivers/gpu/drm/nouveau/nvkm/subdev/mmu/vmm.c\n+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/mmu/vmm.c\n\
    @@ -767,6 +767,20 @@ nvkm_vma_tail(struct nvkm_vma *vma, u64 tail)\n \treturn\
    \ new;\n }\n \n+static inline void\n+nvkm_vmm_free_remove(struct nvkm_vmm *vmm,\
    \ struct nvkm_vma *vma)\n+{\n+\trb_erase(&vma->tree, &vmm->free);\n+}\n+\n+static\
    \ inline void\n+nvkm_vmm_free_delete(struct nvkm_vmm *vmm, struct nvkm_vma *vma)\n\
    +{\n+\tnvkm_vmm_free_remove(vmm, vma);\n+\tlist_del(&vma->head);\n+\tkfree(vma);\n\
    +}\n+\n static void\n nvkm_vmm_free_insert(struct nvkm_vmm *vmm, struct nvkm_vma\
    \ *vma)\n {\n@@ -795,7 +809,21 @@ nvkm_vmm_free_insert(struct nvkm_vmm *vmm, struct\
    \ nvkm_vma *vma)\n \trb_insert_color(&vma->tree, &vmm->free);\n }\n \n-void\n\
    +static inline void\n+nvkm_vmm_node_remove(struct nvkm_vmm *vmm, struct nvkm_vma\
    \ *vma)\n+{\n+\trb_erase(&vma->tree, &vmm->root);\n+}\n+\n+static inline void\n\
    +nvkm_vmm_node_delete(struct nvkm_vmm *vmm, struct nvkm_vma *vma)\n+{\n+\tnvkm_vmm_node_remove(vmm,\
    \ vma);\n+\tlist_del(&vma->head);\n+\tkfree(vma);\n+}\n+\n+static void\n nvkm_vmm_node_insert(struct\
    \ nvkm_vmm *vmm, struct nvkm_vma *vma)\n {\n \tstruct rb_node **ptr = &vmm->root.rb_node;\n\
    @@ -834,6 +862,78 @@ nvkm_vmm_node_search(struct nvkm_vmm *vmm, u64 addr)\n \t\
    return NULL;\n }\n \n+#define node(root, dir) (((root)->head.dir == &vmm->list)\
    \ ? NULL :             \\\n+\tlist_entry((root)->head.dir, struct nvkm_vma, head))\n\
    +\n+static struct nvkm_vma *\n+nvkm_vmm_node_merge(struct nvkm_vmm *vmm, struct\
    \ nvkm_vma *prev,\n+\t\t    struct nvkm_vma *vma, struct nvkm_vma *next, u64 size)\n\
    +{\n+\tif (next) {\n+\t\tif (vma->size == size) {\n+\t\t\tvma->size += next->size;\n\
    +\t\t\tnvkm_vmm_node_delete(vmm, next);\n+\t\t\tif (prev) {\n+\t\t\t\tprev->size\
    \ += vma->size;\n+\t\t\t\tnvkm_vmm_node_delete(vmm, vma);\n+\t\t\t\treturn prev;\n\
    +\t\t\t}\n+\t\t\treturn vma;\n+\t\t}\n+\t\tBUG_ON(prev);\n+\n+\t\tnvkm_vmm_node_remove(vmm,\
    \ next);\n+\t\tvma->size -= size;\n+\t\tnext->addr -= size;\n+\t\tnext->size +=\
    \ size;\n+\t\tnvkm_vmm_node_insert(vmm, next);\n+\t\treturn next;\n+\t}\n+\n+\t\
    if (prev) {\n+\t\tif (vma->size != size) {\n+\t\t\tnvkm_vmm_node_remove(vmm, vma);\n\
    +\t\t\tprev->size += size;\n+\t\t\tvma->addr += size;\n+\t\t\tvma->size -= size;\n\
    +\t\t\tnvkm_vmm_node_insert(vmm, vma);\n+\t\t} else {\n+\t\t\tprev->size += vma->size;\n\
    +\t\t\tnvkm_vmm_node_delete(vmm, vma);\n+\t\t}\n+\t\treturn prev;\n+\t}\n+\n+\t\
    return vma;\n+}\n+\n+struct nvkm_vma *\n+nvkm_vmm_node_split(struct nvkm_vmm *vmm,\n\
    +\t\t    struct nvkm_vma *vma, u64 addr, u64 size)\n+{\n+\tstruct nvkm_vma *prev\
    \ = NULL;\n+\n+\tif (vma->addr != addr) {\n+\t\tprev = vma;\n+\t\tif (!(vma =\
    \ nvkm_vma_tail(vma, vma->size + vma->addr - addr)))\n+\t\t\treturn NULL;\n+\t\
    \tvma->part = true;\n+\t\tnvkm_vmm_node_insert(vmm, vma);\n+\t}\n+\n+\tif (vma->size\
    \ != size) {\n+\t\tstruct nvkm_vma *tmp;\n+\t\tif (!(tmp = nvkm_vma_tail(vma,\
    \ vma->size - size))) {\n+\t\t\tnvkm_vmm_node_merge(vmm, prev, vma, NULL, vma->size);\n\
    +\t\t\treturn NULL;\n+\t\t}\n+\t\ttmp->part = true;\n+\t\tnvkm_vmm_node_insert(vmm,\
    \ tmp);\n+\t}\n+\n+\treturn vma;\n+}\n+\n static void\n nvkm_vmm_dtor(struct nvkm_vmm\
    \ *vmm)\n {\n@@ -954,37 +1054,20 @@ nvkm_vmm_new_(const struct nvkm_vmm_func *func,\
    \ struct nvkm_mmu *mmu,\n \treturn nvkm_vmm_ctor(func, mmu, hdr, addr, size, key,\
    \ name, *pvmm);\n }\n \n-#define node(root, dir) ((root)->head.dir == &vmm->list)\
    \ ? NULL :              \\\n-\tlist_entry((root)->head.dir, struct nvkm_vma, head)\n\
    -\n void\n nvkm_vmm_unmap_region(struct nvkm_vmm *vmm, struct nvkm_vma *vma)\n\
    \ {\n-\tstruct nvkm_vma *next;\n+\tstruct nvkm_vma *next = node(vma, next);\n\
    +\tstruct nvkm_vma *prev = NULL;\n \n \tnvkm_memory_tags_put(vma->memory, vmm->mmu->subdev.device,\
    \ &vma->tags);\n \tnvkm_memory_unref(&vma->memory);\n \n-\tif (vma->part) {\n\
    -\t\tstruct nvkm_vma *prev = node(vma, prev);\n-\t\tif (!prev->memory) {\n-\t\t\
    \tprev->size += vma->size;\n-\t\t\trb_erase(&vma->tree, &vmm->root);\n-\t\t\t\
    list_del(&vma->head);\n-\t\t\tkfree(vma);\n-\t\t\tvma = prev;\n-\t\t}\n-\t}\n\
    -\n-\tnext = node(vma, next);\n-\tif (next && next->part) {\n-\t\tif (!next->memory)\
    \ {\n-\t\t\tvma->size += next->size;\n-\t\t\trb_erase(&next->tree, &vmm->root);\n\
    -\t\t\tlist_del(&next->head);\n-\t\t\tkfree(next);\n-\t\t}\n-\t}\n+\tif (!vma->part\
    \ || ((prev = node(vma, prev)), prev->memory))\n+\t\tprev = NULL;\n+\tif (!next->part\
    \ || next->memory)\n+\t\tnext = NULL;\n+\tnvkm_vmm_node_merge(vmm, prev, vma,\
    \ next, vma->size);\n }\n \n void\n@@ -1163,18 +1246,14 @@ nvkm_vmm_put_region(struct\
    \ nvkm_vmm *vmm, struct nvkm_vma *vma)\n \tstruct nvkm_vma *prev, *next;\n \n\
    \ \tif ((prev = node(vma, prev)) && !prev->used) {\n-\t\trb_erase(&prev->tree,\
    \ &vmm->free);\n-\t\tlist_del(&prev->head);\n \t\tvma->addr  = prev->addr;\n \t\
    \tvma->size += prev->size;\n-\t\tkfree(prev);\n+\t\tnvkm_vmm_free_delete(vmm,\
    \ prev);\n \t}\n \n \tif ((next = node(vma, next)) && !next->used) {\n-\t\trb_erase(&next->tree,\
    \ &vmm->free);\n-\t\tlist_del(&next->head);\n \t\tvma->size += next->size;\n-\t\
    \tkfree(next);\n+\t\tnvkm_vmm_free_delete(vmm, next);\n \t}\n \n \tnvkm_vmm_free_insert(vmm,\
    \ vma);\n@@ -1250,7 +1329,7 @@ nvkm_vmm_put_locked(struct nvkm_vmm *vmm, struct\
    \ nvkm_vma *vma)\n \t}\n \n \t/* Remove VMA from the list of allocated nodes.\
    \ */\n-\trb_erase(&vma->tree, &vmm->root);\n+\tnvkm_vmm_node_remove(vmm, vma);\n\
    \ \n \t/* Merge VMA back into the free list. */\n \tvma->page = NVKM_VMA_PAGE_NONE;\n\
    @@ -1357,7 +1436,7 @@ nvkm_vmm_get_locked(struct nvkm_vmm *vmm, bool getref, bool\
    \ mapref, bool sparse,\n \t\t\ttail = ALIGN_DOWN(tail, vmm->func->page_block);\n\
    \ \n \t\tif (addr <= tail && tail - addr >= size) {\n-\t\t\trb_erase(&this->tree,\
    \ &vmm->free);\n+\t\t\tnvkm_vmm_free_remove(vmm, this);\n \t\t\tvma = this;\n\
    \ \t\t\tbreak;\n \t\t}"
  identifiers:
  - CVE-2023-0030
  - CWE-416
  overview: "A use-after-free flaw was found in the Linux kernel\u2019s nouveau driver\
    \ in how a user triggers a memory overflow that causes the nvkm_vma_tail function\
    \ to fail. This flaw allows a local user to crash or potentially escalate their\
    \ privileges on the system."
  references:
  - source: secalert@redhat.com
    tags:
    - Issue Tracking
    - Patch
    url: https://bugzilla.redhat.com/show_bug.cgi?id=2157270
  - source: secalert@redhat.com
    tags:
    - Broken Link
    - Patch
    url: https://github.com/torvalds/linux/commit/729eba3355674f2d9524629b73683ba1d1cd3f10
  - source: secalert@redhat.com
    url: https://security.netapp.com/advisory/ntap-20230413-0010/
  title: "A use-after-free flaw was found in the Linux kernel\u2019s nouveau driver\
    \ in how a user triggers a memory overflow that causes the nvkm_vma_tail function\
    \ to fail. This flaw allows a local user to crash or potentially escalate their\
    \ privileges on the system."
- diff_content:
  - "--- a/libr/arch/p/wasm/wasm.c\n+++ b/libr/arch/p/wasm/wasm.c\n@@ -1,11 +1,8 @@\n\
    -/* radare - LGPL - Copyright 2017-2022 - pancake, cgvwzq */\n+/* radare - LGPL\
    \ - Copyright 2017-2023 - pancake, cgvwzq */\n \n // http://webassembly.org/docs/binary-encoding/#module-structure\n\
    \ \n-#include <r_asm.h>\n-#include <r_lib.h>\n-#include <string.h>\n-\n+#include\
    \ <r_arch.h>\n #include \"wasm.h\"\n #include \"../../../bin/format/wasm/wasm.h\"\
    \n \n@@ -611,7 +608,7 @@ R_IPI int wasm_dis(WasmOp *op, const ut8 *buf, int buf_len,\
    \ bool txt) {\n \t\tcase WASM_OP_F32REINTERPRETI32:\n \t\tcase WASM_OP_F64REINTERPRETI64:\n\
    \ \t\tcase WASM_OP_END:\n-\t\t\tif (txt) {\n+\t\t\tif (txt && opdef->txt) {\n\
    \ \t\t\t\top->txt = strdup (opdef->txt);\n \t\t\t}\n \t\t\tbreak;\n@@ -624,7 +621,7\
    \ @@ R_IPI int wasm_dis(WasmOp *op, const ut8 *buf, int buf_len, bool txt) {\n\
    \ \t\t\t\tif (!(n > 0 && n < buf_len)) {\n \t\t\t\t\tgoto err;\n \t\t\t\t}\n-\t\
    \t\t\tif (txt) {\n+\t\t\t\tif (txt && opdef->txt) {\n \t\t\t\t\tswitch (val) {\n\
    \ \t\t\t\t\tcase R_BIN_WASM_VALUETYPE_VOID:\n \t\t\t\t\t\top->txt = strdup (opdef->txt);\n\
    @@ -660,7 +657,7 @@ R_IPI int wasm_dis(WasmOp *op, const ut8 *buf, int buf_len,\
    \ bool txt) {\n \t\t\t\tif (n <= 0 || n >= buf_len) {\n \t\t\t\t\tgoto err;\n\
    \ \t\t\t\t}\n-\t\t\t\tif (txt) {\n+\t\t\t\tif (txt && opdef->txt) {\n \t\t\t\t\
    \top->txt = r_str_newf (\"%s %d\", opdef->txt, op->val);\n \t\t\t\t}\n \t\t\t\t\
    op->len += n;\n@@ -693,7 +690,7 @@ R_IPI int wasm_dis(WasmOp *op, const ut8 *buf,\
    \ int buf_len, bool txt) {\n \t\t\t\t\tgoto beach;\n \t\t\t\t}\n \t\t\t\top->len\
    \ += n;\n-\t\t\t\tif (txt) {\n+\t\t\t\tif (txt && opdef->txt) {\n \t\t\t\t\tRStrBuf\
    \ *sb = r_strbuf_new (\"\");\n \t\t\t\t\tif (sb) {\n \t\t\t\t\t\tr_strbuf_setf\
    \ (sb, \"%s %d \", opdef->txt, count);\n@@ -724,7 +721,7 @@ R_IPI int wasm_dis(WasmOp\
    \ *op, const ut8 *buf, int buf_len, bool txt) {\n \t\t\t\t\tgoto err;\n \t\t\t\
    \t}\n \t\t\t\treserved &= 0x1;\n-\t\t\t\tif (txt) {\n+\t\t\t\tif (txt && opdef->txt)\
    \ {\n \t\t\t\t\top->txt = r_str_newf (\"%s %d %d\", opdef->txt, val, reserved);\n\
    \ \t\t\t\t}\n \t\t\t\top->len += n;\n@@ -741,7 +738,7 @@ R_IPI int wasm_dis(WasmOp\
    \ *op, const ut8 *buf, int buf_len, bool txt) {\n \t\t\t\tif (!(n > 0 && n < buf_len))\
    \ {\n \t\t\t\t\tgoto err;\n \t\t\t\t}\n-\t\t\t\tif (txt) {\n+\t\t\t\tif (txt &&\
    \ opdef->txt) {\n \t\t\t\t\top->txt = r_str_newf (\"%s %d\", opdef->txt, val);\n\
    \ \t\t\t\t}\n \t\t\t\top->len += n;\n@@ -781,7 +778,7 @@ R_IPI int wasm_dis(WasmOp\
    \ *op, const ut8 *buf, int buf_len, bool txt) {\n \t\t\t\tif (!(n > 0 && op->len\
    \ + n <= buf_len)) {\n \t\t\t\t\tgoto err;\n \t\t\t\t}\n-\t\t\t\tif (txt) {\n\
    +\t\t\t\tif (txt && opdef->txt) {\n \t\t\t\t\top->txt = r_str_newf (\"%s %d %d\"\
    , opdef->txt, flag, offset);\n \t\t\t\t}\n \t\t\t\top->len += n;\n@@ -796,7 +793,7\
    \ @@ R_IPI int wasm_dis(WasmOp *op, const ut8 *buf, int buf_len, bool txt) {\n\
    \ \t\t\t\t\tgoto err;\n \t\t\t\t}\n \t\t\t\treserved &= 0x1;\n-\t\t\t\tif (txt)\
    \ {\n+\t\t\t\tif (txt && opdef->txt) {\n \t\t\t\t\top->txt = r_str_newf (\"%s\
    \ %d\", opdef->txt, reserved);\n \t\t\t\t}\n \t\t\t\top->len += n;\n@@ -809,7\
    \ +806,7 @@ R_IPI int wasm_dis(WasmOp *op, const ut8 *buf, int buf_len, bool txt)\
    \ {\n \t\t\t\tif (!(n > 0 && n < buf_len)) {\n \t\t\t\t\tgoto err;\n \t\t\t\t\
    }\n-\t\t\t\tif (txt) {\n+\t\t\t\tif (txt && opdef->txt) {\n \t\t\t\t\top->txt\
    \ = r_str_newf (\"%s %\" PFMT32d, opdef->txt, val);\n \t\t\t\t}\n \t\t\t\top->len\
    \ += n;\n@@ -822,7 +819,7 @@ R_IPI int wasm_dis(WasmOp *op, const ut8 *buf, int\
    \ buf_len, bool txt) {\n \t\t\t\tif (!(n > 0 && n < buf_len)) {\n \t\t\t\t\tgoto\
    \ err;\n \t\t\t\t}\n-\t\t\t\tif (txt) {\n+\t\t\t\tif (txt && opdef->txt) {\n \t\
    \t\t\t\top->txt = r_str_newf (\"%s %\" PFMT64d, opdef->txt, val);\n \t\t\t\t}\n\
    \ \t\t\t\top->len += n;\n@@ -835,7 +832,7 @@ R_IPI int wasm_dis(WasmOp *op, const\
    \ ut8 *buf, int buf_len, bool txt) {\n \t\t\t\t\tfloat f;\n \t\t\t\t} u;\n \t\t\
    \t\tu.v = r_read_at_le32 (buf, 1);\n-\t\t\t\tif (txt) {\n+\t\t\t\tif (txt && opdef->txt)\
    \ {\n \t\t\t\t\top->txt = r_str_newf (\"%s %f\", opdef->txt, u.f);\n \t\t\t\t\
    }\n \t\t\t\top->len += 4;\n@@ -850,7 +847,7 @@ R_IPI int wasm_dis(WasmOp *op,\
    \ const ut8 *buf, int buf_len, bool txt) {\n \t\t\t\t\tdouble f;\n \t\t\t\t} u;\n\
    \ \t\t\t\tu.v = r_read_at_le64 (buf, 1);\n-\t\t\t\tif (txt) {\n+\t\t\t\tif (txt\
    \ && opdef->txt) {\n \t\t\t\t\top->txt = r_str_newf (\"%s %f\", opdef->txt, u.f);\n\
    \ \t\t\t\t}\n \t\t\t\top->len += 8;\n@@ -936,7 +933,7 @@ R_IPI int wasm_dis(WasmOp\
    \ *op, const ut8 *buf, int buf_len, bool txt) {\n \t\t\t\tif (!(n > 0 && op->len\
    \ + n <= buf_len)) {\n \t\t\t\t\tgoto err;\n \t\t\t\t}\n-\t\t\t\tif (txt) {\n\
    +\t\t\t\tif (txt && opdef->txt) {\n \t\t\t\t\top->txt = r_str_newf (\"%s %d %d\"\
    , opdef->txt, flag, offset);\n \t\t\t\t}\n \t\t\t\top->len += n;\n@@ -1108,7 +1105,7\
    \ @@ R_IPI int wasm_dis(WasmOp *op, const ut8 *buf, int buf_len, bool txt) {\n\
    \ \t\tcase WASM_OP_I8X16ABS:\n \t\tcase WASM_OP_I16X8ABS:\n \t\tcase WASM_OP_I32X4ABS:\n\
    -\t\t\tif (txt) {\n+\t\t\tif (txt && opdef->txt) {\n \t\t\t\top->txt = strdup\
    \ (opdef->txt);\n \t\t\t}\n \t\t\tbreak;\n@@ -1136,7 +1133,7 @@ R_IPI int wasm_dis(WasmOp\
    \ *op, const ut8 *buf, int buf_len, bool txt) {\n \t\t\t\tif (!(n > 0 && n < buf_len))\
    \ {\n \t\t\t\t\tgoto err;\n \t\t\t\t}\n-\t\t\t\tif (txt) {\n+\t\t\t\tif (txt &&\
    \ opdef->txt) {\n \t\t\t\t\top->txt = r_str_newf (\"%s o:%d a:2^%d\", opdef->txt,\
    \ offset, align);\n \t\t\t\t}\n \t\t\t}\n@@ -1156,7 +1153,7 @@ R_IPI int wasm_dis(WasmOp\
    \ *op, const ut8 *buf, int buf_len, bool txt) {\n \t\t\t\tif (txt) {\n \t\t\t\t\
    \top->txt = r_str_newf (\"%s %02x %02x %02x %02x %02x %02x %02x \" \\\n \t\t\t\
    \t\t\t\"%02x %02x %02x %02x %02x %02x %02x %02x %02x\",\n-\t\t\t\t\t\topdef->txt,\
    \ bytes[0], bytes[1], bytes[2], bytes[3],\n+\t\t\t\t\t\tr_str_get (opdef->txt),\
    \ bytes[0], bytes[1], bytes[2], bytes[3],\n \t\t\t\t\t\tbytes[4], bytes[5], bytes[6],\
    \ bytes[7], bytes[8],\n \t\t\t\t\t\tbytes[9], bytes[10], bytes[11], bytes[12],\
    \ bytes[13],\n \t\t\t\t\t\tbytes[14], bytes[15]);\n@@ -1183,7 +1180,7 @@ R_IPI\
    \ int wasm_dis(WasmOp *op, const ut8 *buf, int buf_len, bool txt) {\n \t\t\t\t\
    }\n \t\t\t\tunsigned char lane = buf[1 + simdop_size];\n \t\t\t\t++op->len;\n\
    -\t\t\t\tif (txt) {\n+\t\t\t\tif (txt && opdef->txt) {\n \t\t\t\t\top->txt = r_str_newf\
    \ (\"%s %d\", opdef->txt, lane);\n \t\t\t\t}\n \t\t\t}\n@@ -1192,6 +1189,9 @@\
    \ R_IPI int wasm_dis(WasmOp *op, const ut8 *buf, int buf_len, bool txt) {\n \t\
    } else {\n \t\tgoto err;\n \t}\n+\tif (txt && !op->txt) {\n+\t\top->txt = strdup\
    \ (\"incorrect\");\n+\t}\n \treturn op->len;\n \n   err:"
  identifiers:
  - CVE-2023-27114
  - CWE-476
  overview: radare2 v5.8.3 was discovered to contain a segmentation fault via the
    component wasm_dis at p/wasm/wasm.c.
  references:
  - source: cve@mitre.org
    url: https://github.com/radareorg/radare2/commit/a15067a8eaa836bcc24b0882712c14d1baa66509
  - source: cve@mitre.org
    tags:
    - Exploit
    - Issue Tracking
    url: https://github.com/radareorg/radare2/issues/21363
  title: radare2 v5.8.3 was discovered to contain a segmentation fault via the component
    wasm_dis at p/wasm/wasm.c.
- diff_content:
  - "--- a/src/subscription.c\n+++ b/src/subscription.c\n@@ -282,6 +282,7 @@ subscription_update\
    \ (subscriptionPtr subscription, guint flags)\n \t\t\tsubscription->updateState,\n\
    \ \t\t\tsubscription->updateOptions\n \t\t);\n+\t\tupdate_request_allow_commands\
    \ (request, TRUE);\n \n \t\tif (subscription_get_filter (subscription))\n \t\t\
    \trequest->filtercmd = g_strdup (subscription_get_filter (subscription));"
  - "--- a/src/update.c\n+++ b/src/update.c\n@@ -234,6 +234,13 @@ update_request_set_auth_value\
    \ (UpdateRequest *request, const gchar* authValue)\n \trequest->authValue = g_strdup\
    \ (authValue);\n }\n \n+void\n+update_request_allow_commands (UpdateRequest *request,\
    \ gboolean allowCommands)\n+{\n+\trequest->allowCommands = allowCommands;\n+}\n\
    +\n+\n /* update result object */\n \n updateResultPtr\n@@ -672,8 +679,14 @@ update_job_run\
    \ (updateJobPtr job)\n \n \t/* everything starting with '|' is a local command\
    \ */\n \tif (*(job->request->source) == '|') {\n-\t\tdebug1 (DEBUG_UPDATE, \"\
    Recognized local command: %s\", job->request->source);\n-\t\tupdate_exec_cmd (job);\n\
    +\t\tif (job->request->allowCommands) {\n+\t\t\tdebug1 (DEBUG_UPDATE, \"Recognized\
    \ local command: %s\", job->request->source);\n+\t\t\tupdate_exec_cmd (job);\n\
    +\t\t} else {\n+\t\t\tdebug1 (DEBUG_UPDATE, \"Refusing to run local command from\
    \ unexpected source: %s\", job->request->source);\n+\t\t\tjob->result->httpstatus\
    \ = 403;  /* Forbidden. */\n+\t\t\tupdate_process_finished_job (job);\n+\t\t}\n\
    \ \t\treturn;\n \t}\n "
  identifiers:
  - CVE-2023-1350
  - CWE-78
  overview: A vulnerability was found in liferea. It has been rated as critical. Affected
    by this issue is the function update_job_run of the file src/update.c of the component
    Feed Enrichment. The manipulation of the argument source with the input |date
    &gt;/tmp/bad-item-link.txt leads to os command injection. The attack may be launched
    remotely. The exploit has been disclosed to the public and may be used. The name
    of the patch is 8d8b5b963fa64c7a2122d1bbfbb0bed46e813e59. It is recommended to
    apply a patch to fix this issue. The identifier of this vulnerability is VDB-222848.
  references:
  - source: cna@vuldb.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/lwindolf/liferea/commit/8d8b5b963fa64c7a2122d1bbfbb0bed46e813e59
  - source: cna@vuldb.com
    tags:
    - Permissions Required
    - VDB Entry
    url: https://vuldb.com/?ctiid.222848
  - source: cna@vuldb.com
    tags:
    - VDB Entry
    url: https://vuldb.com/?id.222848
  title: A vulnerability was found in liferea. It has been rated as critical. Affected
    by this issue is the function update_job_run of the file src/update.c of the component
    Feed Enrichment. The manipulation of the argument source with the input |date
    &gt;/tmp/bad-item-link.txt leads to os command injection. The attack may be launched
    remotely. The exploit has been disclosed to the public and may be used. The name
    of the patch is 8d8b5b963fa64c7a2122d1bbfbb0bed46e813e59. It is recommended to
    apply a patch to fix this issue. The identifier of this vulnerability is VDB-222848.
- diff_content:
  - "--- a/src/version.c\n+++ b/src/version.c\n@@ -695,6 +695,8 @@ static char *(features[])\
    \ =\n \n static int included_patches[] =\n {   /* Add new patch number below this\
    \ line */\n+/**/\n+    1402,\n /**/\n     1401,\n /**/"
  - "--- a/src/vim9class.c\n+++ b/src/vim9class.c\n@@ -1262,6 +1262,12 @@ class_object_index(\n\
    \ \tcl = rettv->vval.v_object->obj_class;\n     }\n \n+    if (cl == NULL)\n+\
    \    {\n+\temsg(_(e_incomplete_type));\n+\treturn FAIL;\n+    }\n+\n     if (*name_end\
    \ == '(')\n     {\n \tint on_class = rettv->v_type == VAR_CLASS;"
  identifiers:
  - CVE-2023-1355
  - CWE-476
  overview: NULL Pointer Dereference in GitHub repository vim/vim prior to 9.0.1402.
  references:
  - source: security@huntr.dev
    tags:
    - Patch
    url: https://github.com/vim/vim/commit/d13dd30240e32071210f55b587182ff48757ea46
  - source: security@huntr.dev
    tags:
    - Exploit
    - Patch
    - Third Party Advisory
    url: https://huntr.dev/bounties/4d0a9615-d438-4f5c-8dd6-aa22f4b716d9
  - source: security@huntr.dev
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/IE44W6WMMREYCW3GJHPSYP7NK2VT5NY6/
  title: NULL Pointer Dereference in GitHub repository vim/vim prior to 9.0.1402.
- diff_content:
  - "--- a/pjlib-util/src/pjlib-util/dns.c\n+++ b/pjlib-util/src/pjlib-util/dns.c\n\
    @@ -127,6 +127,9 @@ static pj_status_t get_name_len(int rec_counter, const pj_uint8_t\
    \ *pkt,\n         return PJLIB_UTIL_EDNSINNAMEPTR;\n     }\n \n+    if (start\
    \ >= max)\n+        return PJLIB_UTIL_EDNSINNAMEPTR;\n+\n     *name_len = *parsed_len\
    \ = 0;\n     p = start;\n     while (*p) {\n@@ -199,6 +202,9 @@ static pj_status_t\
    \ get_name(int rec_counter, const pj_uint8_t *pkt,\n         return PJLIB_UTIL_EDNSINNAMEPTR;\n\
    \     }\n \n+    if (start >= max)\n+        return PJLIB_UTIL_EDNSINNAMEPTR;\n\
    +\n     p = start;\n     while (*p) {\n         if ((*p & 0xc0) == 0xc0) {\n@@\
    \ -359,10 +365,14 @@ static pj_status_t parse_rr(pj_dns_parsed_rr *rr, pj_pool_t\
    \ *pool,\n \n     /* Parse some well known records */\n     if (rr->type == PJ_DNS_TYPE_A)\
    \ {\n+        if (p + 4 > max)\n+            return PJLIB_UTIL_EDNSINSIZE;\n \
    \        pj_memcpy(&rr->rdata.a.ip_addr, p, 4);\n         p += 4;\n \n     } else\
    \ if (rr->type == PJ_DNS_TYPE_AAAA) {\n+        if (p + 16 > max)\n+         \
    \   return PJLIB_UTIL_EDNSINSIZE;\n         pj_memcpy(&rr->rdata.aaaa.ip_addr,\
    \ p, 16);\n         p += 16;\n \n@@ -388,6 +398,8 @@ static pj_status_t parse_rr(pj_dns_parsed_rr\
    \ *rr, pj_pool_t *pool,\n         p += name_part_len;\n \n     } else if (rr->type\
    \ == PJ_DNS_TYPE_SRV) {\n+        if (p + 6 > max)\n+            return PJLIB_UTIL_EDNSINSIZE;\n\
    \ \n         /* Priority */\n         pj_memcpy(&rr->rdata.srv.prio, p, 2);"
  identifiers:
  - CVE-2023-27585
  - CWE-120
  overview: PJSIP is a free and open source multimedia communication library written
    in C. A buffer overflow vulnerability in versions 2.13 and prior affects applications
    that use PJSIP DNS resolver. It doesn't affect PJSIP users who do not utilise
    PJSIP DNS resolver. This vulnerability is related to CVE-2022-24793. The difference
    is that this issue is in parsing the query record `parse_query()`, while the issue
    in CVE-2022-24793 is in `parse_rr()`. A patch is available as commit `d1c5e4d`
    in the `master` branch. A workaround is to disable DNS resolution in PJSIP config
    (by setting `nameserver_count` to zero) or use an external resolver implementation
    instead.
  references:
  - source: security-advisories@github.com
    tags:
    - Patch
    url: https://github.com/pjsip/pjproject/commit/d1c5e4da5bae7f220bc30719888bb389c905c0c5
  - source: security-advisories@github.com
    tags:
    - Vendor Advisory
    url: https://github.com/pjsip/pjproject/security/advisories/GHSA-p6g5-v97c-w5q4
  - source: security-advisories@github.com
    tags:
    - Patch
    - Vendor Advisory
    url: https://github.com/pjsip/pjproject/security/advisories/GHSA-q9cp-8wcq-7pfr
  - source: security-advisories@github.com
    url: https://lists.debian.org/debian-lts-announce/2023/04/msg00020.html
  - source: security-advisories@github.com
    url: https://lists.debian.org/debian-lts-announce/2023/08/msg00038.html
  - source: security-advisories@github.com
    url: https://www.debian.org/security/2023/dsa-5438
  - source: security-advisories@github.com
    tags:
    - Product
    url: https://www.pjsip.org/pjlib-util/docs/html/group__PJ__DNS__RESOLVER.htm
  title: PJSIP is a free and open source multimedia communication library written
    in C. A buffer overflow vulnerability in versions 2.13 and prior affects applications
    that use PJSIP DNS resolver. It doesn't affect PJSIP users who do not utilise
    PJSIP DNS resolver. This vulnerability is related to CVE-2022-24793. The difference
    is that this issue is in parsing the query record `parse_query()`, while the issue
    in CVE-2022-24793 is in `parse_rr()`. A patch is available as commit `d1c5e4d`
    in the `master` branch. A workaround is to disable DNS resolution in PJSIP config
    (by setting `nameserver_count` to zero) or use an external resolver implementation
    instead.
- diff_content:
  - "--- a/librz/debug/p/debug_gdb.c\n+++ b/librz/debug/p/debug_gdb.c\n@@ -15,6 +15,13\
    \ @@ typedef struct {\n #define UNSUPPORTED 0\n #define SUPPORTED   1\n \n+#define\
    \ PROC_NAME_SZ   1024\n+#define PROC_REGION_SZ 100\n+// PROC_REGION_SZ - 2 (used\
    \ for `0x`). Due to how RZ_STR_DEF works this can't be\n+// computed.\n+#define\
    \ PROC_REGION_LEFT_SZ 98\n+#define PROC_PERM_SZ        5\n+\n typedef struct rz_debug_gdb_ctx_t\
    \ {\n \tRzIOGdb **origrziogdb;\n \tlibgdbr_t *desc;\n@@ -189,7 +196,7 @@ static\
    \ RzList /*<RzDebugMap *>*/ *rz_debug_gdb_map_get(RzDebug *dbg) { // TODO\n \t\
    int unk = 0, perm, i;\n \tchar *ptr, *pos_1;\n \tsize_t line_len;\n-\tchar name[1024],\
    \ region1[100], region2[100], perms[5];\n+\tchar name[PROC_NAME_SZ + 1], region1[PROC_REGION_SZ\
    \ + 1], region2[PROC_REGION_SZ + 1], perms[PROC_PERM_SZ + 1];\n \tRzDebugMap *map\
    \ = NULL;\n \tregion1[0] = region2[0] = '0';\n \tregion1[1] = region2[1] = 'x';\n\
    @@ -213,8 +220,8 @@ static RzList /*<RzDebugMap *>*/ *rz_debug_gdb_map_get(RzDebug\
    \ *dbg) { // TODO\n \t\t}\n \t\t// We assume Linux target, for now, so -\n \t\t\
    // 7ffff7dda000-7ffff7dfd000 r-xp 00000000 08:05 265428 /usr/lib/ld-2.25.so\n\
    -\t\tret = sscanf(ptr, \"%s %s %\" PFMT64x \" %*s %*s %[^\\n]\", &region1[2],\n\
    -\t\t\tperms, &offset, name);\n+\t\tret = sscanf(ptr, \"%\" RZ_STR_DEF(PROC_REGION_LEFT_SZ)\
    \ \"s %\" RZ_STR_DEF(PROC_PERM_SZ) \"s %\" PFMT64x \" %*s %*s %\" RZ_STR_DEF(PROC_NAME_SZ)\
    \ \"[^\\n]\",\n+\t\t\t&region1[2], perms, &offset, name);\n \t\tif (ret == 3)\
    \ {\n \t\t\tname[0] = '\\0';\n \t\t} else if (ret != 4) {"
  - "--- a/librz/debug/p/debug_io.c\n+++ b/librz/debug/p/debug_io.c\n@@ -4,6 +4,9\
    \ @@\n #include <rz_io.h>\n #include <rz_debug.h>\n \n+#define IO_MAPS_PERM_SZ\
    \ 32\n+#define IO_MAPS_NAME_SZ 512\n+\n static int __io_step(RzDebug *dbg) {\n\
    \ \tfree(dbg->iob.system(dbg->iob.io, \"ds\"));\n \treturn true;\n@@ -23,8 +26,8\
    \ @@ static RzList /*<RzDebugMap *>*/ *__io_maps(RzDebug *dbg) {\n \t}\n \tchar\
    \ *ostr = str;\n \tut64 map_start, map_end;\n-\tchar perm[32];\n-\tchar name[512];\n\
    +\tchar perm[IO_MAPS_PERM_SZ + 1];\n+\tchar name[IO_MAPS_NAME_SZ + 1];\n \tfor\
    \ (;;) {\n \t\tchar *nl = strchr(str, '\\n');\n \t\tif (nl) {\n@@ -48,7 +51,7\
    \ @@ static RzList /*<RzDebugMap *>*/ *__io_maps(RzDebug *dbg) {\n \t\t\tif (_s_)\
    \ {\n \t\t\t\tmemmove(_s_, _s_ + 2, strlen(_s_));\n \t\t\t}\n-\t\t\tsscanf(str,\
    \ \"0x%\" PFMT64x \" - 0x%\" PFMT64x \" %s %s\",\n+\t\t\tsscanf(str, \"0x%\" PFMT64x\
    \ \" - 0x%\" PFMT64x \" %\" RZ_STR_DEF(IO_MAPS_PERM_SZ) \"s %\" RZ_STR_DEF(IO_MAPS_NAME_SZ)\
    \ \"s\",\n \t\t\t\t&map_start, &map_end, perm, name);\n \t\t\tif (map_end != 0LL)\
    \ {\n \t\t\t\tRzDebugMap *map = rz_debug_map_new(name, map_start, map_end, rz_str_rwx(perm),\
    \ 0);"
  - "--- a/librz/reg/profile.c\n+++ b/librz/reg/profile.c\n@@ -10,6 +10,10 @@\n #include\
    \ <rz_lib.h>\n #include <string.h>\n \n+#define GDB_NAME_SZ   16\n+#define GDB_TYPE_SZ\
    \   16\n+#define GDB_GROUPS_SZ 128\n+\n static void rz_reg_profile_def_free(RzRegProfileDef\
    \ *def) {\n \tif (!def) {\n \t\treturn;\n@@ -511,7 +515,7 @@ static char *gdb_to_rz_profile(const\
    \ char *gdb) {\n \t\treturn NULL;\n \t}\n \tchar *ptr1, *gptr, *gptr1;\n-\tchar\
    \ name[16], groups[128], type[16];\n+\tchar name[GDB_NAME_SZ + 1], groups[GDB_GROUPS_SZ\
    \ + 1], type[GDB_TYPE_SZ + 1];\n \tconst int all = 1, gpr = 2, save = 4, restore\
    \ = 8, float_ = 16,\n \t\t  sse = 32, vector = 64, system = 128, mmx = 256;\n\
    \ \tint number, rel, offset, size, type_bits, ret;\n@@ -542,8 +546,8 @@ static\
    \ char *gdb_to_rz_profile(const char *gdb) {\n \t\t\trz_strbuf_free(sb);\n \t\t\
    \treturn false;\n \t\t}\n-\t\tret = sscanf(ptr, \" %s %d %d %d %d %s %s\", name,\
    \ &number, &rel,\n-\t\t\t&offset, &size, type, groups);\n+\t\tret = sscanf(ptr,\
    \ \" %\" RZ_STR_DEF(GDB_NAME_SZ) \"s %d %d %d %d %\" RZ_STR_DEF(GDB_TYPE_SZ) \"\
    s %\" RZ_STR_DEF(GDB_GROUPS_SZ) \"s\",\n+\t\t\tname, &number, &rel, &offset, &size,\
    \ type, groups);\n \t\t// Groups is optional, others not\n \t\tif (ret < 6) {\n\
    \ \t\t\tif (*ptr != '*') {"
  identifiers:
  - CVE-2023-27590
  - CWE-120
  overview: Rizin is a UNIX-like reverse engineering framework and command-line toolset.
    In version 0.5.1 and prior, converting a GDB registers profile file into a Rizin
    register profile can result in a stack-based buffer overflow when the `name`,
    `type`, or `groups` fields have longer values than expected. Users opening untrusted
    GDB registers files (e.g. with the `drpg` or `arpg` commands) are affected by
    this flaw. Commit d6196703d89c84467b600ba2692534579dc25ed4 contains a patch for
    this issue. As a workaround, review the GDB register profiles before loading them
    with `drpg`/`arpg` commands.
  references:
  - source: security-advisories@github.com
    tags:
    - Issue Tracking
    url: https://github.com/rizinorg/rizin/blob/3a7d5116244beb678ad9950bb9dd27d28ed2691f/librz/reg/profile.c#L514
  - source: security-advisories@github.com
    tags:
    - Product
    url: https://github.com/rizinorg/rizin/blob/3a7d5116244beb678ad9950bb9dd27d28ed2691f/librz/reg/profile.c#L545
  - source: security-advisories@github.com
    tags:
    - Patch
    url: https://github.com/rizinorg/rizin/commit/d6196703d89c84467b600ba2692534579dc25ed4
  - source: security-advisories@github.com
    tags:
    - Issue Tracking
    - Patch
    url: https://github.com/rizinorg/rizin/pull/3422
  - source: security-advisories@github.com
    tags:
    - Patch
    - Vendor Advisory
    url: https://github.com/rizinorg/rizin/security/advisories/GHSA-rqcp-m8m2-jcqf
  - source: security-advisories@github.com
    url: https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/WW3JXI4TIJIR7PGFP74SN7GQYHW2F46Y/
  title: Rizin is a UNIX-like reverse engineering framework and command-line toolset.
    In version 0.5.1 and prior, converting a GDB registers profile file into a Rizin
    register profile can result in a stack-based buffer overflow when the `name`,
    `type`, or `groups` fields have longer values than expected. Users opening untrusted
    GDB registers files (e.g. with the `drpg` or `arpg` commands) are affected by
    this flaw. Commit d6196703d89c84467b600ba2692534579dc25ed4 contains a patch for
    this issue. As a workaround, review the GDB register profiles before loading them
    with `drpg`/`arpg` commands.
- diff_content:
  - "--- a/src/scripting/StelScriptOutput.cpp\n+++ b/src/scripting/StelScriptOutput.cpp\n\
    @@ -56,15 +56,15 @@ void StelScriptOutput::reset(void)\n void StelScriptOutput::saveOutputAs(const\
    \ QString &name)\n {\n \tQFile asFile;\n-\tQFileInfo outputInfo(outputFile);\n\
    -\tQDir dir=outputInfo.dir(); // will hold complete dirname\n-\tQFileInfo newFileNameInfo(name);\n\
    +\tconst QFileInfo outputInfo(outputFile);\n+\tconst QDir dir=outputInfo.dir();\
    \ // will hold complete dirname\n+\tconst QFileInfo newFileNameInfo(name);\n \n\
    -\tbool okToSaveToAbsolutePath=StelApp::getInstance().getSettings()->value(\"\
    scripts/flag_script_allow_write_absolute_path\", false).toBool();\n+\tconst bool\
    \ okToSaveToAbsolutePath=StelApp::getInstance().getSettings()->value(\"scripts/flag_script_allow_write_absolute_path\"\
    , false).toBool();\n \n-\tif (!okToSaveToAbsolutePath && (newFileNameInfo.isAbsolute()))\n\
    +\tif (!okToSaveToAbsolutePath && ((newFileNameInfo.isAbsolute() || (name.contains(\"\
    ..\"))))) // The last condition may include dangerous/malicious paths\n \t{\n\
    -\t\tqWarning() << \"SCRIPTING CONFIGURATION ISSUE: You are trying to save to\
    \ an absolute pathname.\";\n+\t\tqWarning() << \"SCRIPTING CONFIGURATION ISSUE:\
    \ You are trying to save to an absolute pathname or move up in directories.\"\
    ;\n \t\tqWarning() << \"  To enable this, edit config.ini and set [scripts]/flag_script_allow_write_absolute_path=true\"\
    ;\n \t\tasFile.setFileName(dir.absolutePath() + \"/\" + newFileNameInfo.fileName());\n\
    \ \t\tqWarning() << \"  Storing to \" << asFile.fileName() << \" instead\";"
  - "--- a/src/scripting/StelScriptMgr.cpp\n+++ b/src/scripting/StelScriptMgr.cpp\n\
    @@ -794,8 +794,10 @@ bool StelScriptMgr::runPreprocessedScript(const QString &preprocessedScript,\
    \ con\n bool StelScriptMgr::runScript(const QString& fileName, const QString&\
    \ includePath)\n {\n \tQString preprocessedScript;\n-\tprepareScript(preprocessedScript,fileName,includePath);\n\
    -\treturn runPreprocessedScript(preprocessedScript,fileName);\n+\tif (prepareScript(preprocessedScript,fileName,includePath))\n\
    +\t\treturn runPreprocessedScript(preprocessedScript,fileName);\n+\telse\n+\t\t\
    return false;\n }\n \n bool StelScriptMgr::runScriptDirect(const QString scriptId,\
    \ const QString &scriptCode, int &errLoc, const QString& includePath)\n@@ -820,9\
    \ +822,20 @@ bool StelScriptMgr::runScriptDirect(const QString& scriptCode, const\
    \ QString &in\n bool StelScriptMgr::prepareScript( QString &script, const QString\
    \ &fileName, const QString &includePath)\n {\n \tQString absPath;\n+\tconst bool\
    \ okToRunScriptFromAbsolutePath=StelApp::getInstance().getSettings()->value(\"\
    scripts/flag_script_allow_absolute_path\", false).toBool();\n \n \tif (QFileInfo(fileName).isAbsolute())\n\
    -\t\tabsPath = fileName;\n+\t{\n+\t\t// Absolute paths may bear a security risk.\
    \ We need a flag to allow them!\n+\t\tif (okToRunScriptFromAbsolutePath)\n+\t\t\
    \tabsPath = fileName;\n+\t\telse\n+\t\t{\n+\t\t\tqWarning() << \"SCRIPTING CONFIGURATION\
    \ ISSUE: You are trying to run a script from absolute pathname.\";\n+\t\t\tqWarning()\
    \ << \"  To enable this, edit config.ini and set [scripts]/flag_script_allow_absolute_path=true\"\
    ;\n+\t\t\treturn false;\n+\t\t}\n+\t}\n \telse\n \t\tabsPath = StelFileMgr::findFile(\"\
    scripts/\" + fileName);\n "
  - "--- a/src/scripting/StelScriptOutput.cpp\n+++ b/src/scripting/StelScriptOutput.cpp\n\
    @@ -62,6 +62,12 @@ void StelScriptOutput::saveOutputAs(const QString &name)\n\
    \ \n \tconst bool okToSaveToAbsolutePath=StelApp::getInstance().getSettings()->value(\"\
    scripts/flag_script_allow_write_absolute_path\", false).toBool();\n \n+\tif (name.contains(\"\
    config.ini\"))\n+\t{\n+\t\tqWarning() << \"SCRIPTING ERROR: You are trying to\
    \ overwrite config.ini. Ignoring.\";\n+\t\treturn;\n+\t}\n+\n \tif (!okToSaveToAbsolutePath\
    \ && ((newFileNameInfo.isAbsolute() || (name.contains(\"..\"))))) // The last\
    \ condition may include dangerous/malicious paths\n \t{\n \t\tqWarning() << \"\
    SCRIPTING CONFIGURATION ISSUE: You are trying to save to an absolute pathname\
    \ or move up in directories.\";"
  identifiers:
  - CVE-2023-28371
  - CWE-22
  overview: In Stellarium through 1.2, attackers can write to files that are typically
    unintended, such as ones with absolute pathnames or .. directory traversal.
  references:
  - source: cve@mitre.org
    tags:
    - Patch
    url: https://github.com/Stellarium/stellarium/commit/1261f74dc4aa6bbd01ab514343424097f8cf46b7
  - source: cve@mitre.org
    tags:
    - Patch
    url: https://github.com/Stellarium/stellarium/commit/787a894897b7872ae96e6f5804a182210edd5c78
  - source: cve@mitre.org
    tags:
    - Patch
    url: https://github.com/Stellarium/stellarium/commit/eba61df3b38605befcb43687a4c0a159dbc0c5cb
  - source: cve@mitre.org
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/KG6UNRAOYZJSMIUELY3MMJ5J6LIUZXLT/
  - source: cve@mitre.org
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/REDZB5J7WDN2P3NYWFO2NNJXSTOFUUKM/
  - source: cve@mitre.org
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/YQ4ZGY5MDDHBEOQTD4IIA2RFID3ATPXA/
  title: In Stellarium through 1.2, attackers can write to files that are typically
    unintended, such as ones with absolute pathnames or .. directory traversal.
- diff_content:
  - "--- a/src/modules/tm/t_msgbuilder.c\n+++ b/src/modules/tm/t_msgbuilder.c\n@@\
    \ -268,6 +268,7 @@ char *build_local_reparse(tm_cell_t *Trans,unsigned int branch,\n\
    \ \tstruct hdr_field *reas1, *reas_last, *hdr;\n \tint hadded = 0;\n \tsr_cfgenv_t\
    \ *cenv = NULL;\n+\thdr_flags_t hdr_flags = 0;\n \n \tinvite_buf = Trans->uac[branch].request.buffer;\n\
    \ \tinvite_len = Trans->uac[branch].request.buffer_len;\n@@ -361,6 +362,11 @@\
    \ char *build_local_reparse(tm_cell_t *Trans,unsigned int branch,\n \t\tswitch(hf_type)\
    \ {\n \t\t\tcase HDR_CSEQ_T:\n \t\t\t\t/* find the method name and replace it\
    \ */\n+\t\t\t\tif(hdr_flags &  HDR_CSEQ_F) {\n+\t\t\t\t\tLM_DBG(\"duplicate CSeq\
    \ header\\n\");\n+\t\t\t\t\tgoto errorhdr;\n+\t\t\t\t}\n+\t\t\t\thdr_flags |=\
    \  HDR_CSEQ_F;\n \t\t\t\twhile ((s < invite_buf_end)\n \t\t\t\t\t&& ((*s == ':')\
    \ || (*s == ' ') || (*s == '\\t') ||\n \t\t\t\t\t\t((*s >= '0') && (*s <= '9')))\n\
    @@ -381,6 +387,12 @@ char *build_local_reparse(tm_cell_t *Trans,unsigned int branch,\n\
    \ \t\t\t\tbreak;\n \n \t\t\tcase HDR_TO_T:\n+\t\t\t\tif(hdr_flags &  HDR_TO_F)\
    \ {\n+\t\t\t\t\tLM_DBG(\"duplicate To header\\n\");\n+\t\t\t\t\tgoto errorhdr;\n\
    +\t\t\t\t}\n+\t\t\t\thdr_flags |=  HDR_TO_F;\n+\n \t\t\t\tif (to_len == 0) {\n\
    \ \t\t\t\t\t/* there is no To tag required, just copy paste\n \t\t\t\t\t * the\
    \ header */\n@@ -395,7 +407,25 @@ char *build_local_reparse(tm_cell_t *Trans,unsigned\
    \ int branch,\n \t\t\t\tbreak;\n \n \t\t\tcase HDR_FROM_T:\n+\t\t\t\t/* copy hf\
    \ */\n+\t\t\t\tif(hdr_flags &  HDR_FROM_F) {\n+\t\t\t\t\tLM_DBG(\"duplicate From\
    \ header\\n\");\n+\t\t\t\t\tgoto errorhdr;\n+\t\t\t\t}\n+\t\t\t\thdr_flags |=\
    \  HDR_FROM_F;\n+\t\t\t\ts = lw_next_line(s, invite_buf_end);\n+\t\t\t\tappend_str(d,\
    \ s1, s - s1);\n+\t\t\t\tbreak;\n \t\t\tcase HDR_CALLID_T:\n+\t\t\t\t/* copy hf\
    \ */\n+\t\t\t\tif(hdr_flags &  HDR_CALLID_F) {\n+\t\t\t\t\tLM_DBG(\"duplicate\
    \ Call-Id header\\n\");\n+\t\t\t\t\tgoto errorhdr;\n+\t\t\t\t}\n+\t\t\t\thdr_flags\
    \ |=  HDR_CALLID_F;\n+\t\t\t\ts = lw_next_line(s, invite_buf_end);\n+\t\t\t\t\
    append_str(d, s1, s - s1);\n+\t\t\t\tbreak;\n \t\t\tcase HDR_ROUTE_T:\n \t\t\t\
    case HDR_MAXFORWARDS_T:\n \t\t\t\t/* copy hf */\n@@ -495,6 +525,7 @@ char *build_local_reparse(tm_cell_t\
    \ *Trans,unsigned int branch,\n \t/* HDR_EOH_T was not found in the buffer, the\
    \ message is corrupt */\n \tLM_ERR(\"HDR_EOH_T was not found\\n\");\n \n+errorhdr:\n\
    \ \tshm_free(cancel_buf);\n error:\n \tLM_ERR(\"cannot build %.*s request\\n\"\
    , method_len, method);"
  identifiers:
  - CVE-2020-27507
  - CWE-120
  overview: The Kamailio SIP before 5.5.0 server mishandles INVITE requests with duplicated
    fields and overlength tag, leading to a buffer overflow that crashes the server
    or possibly have unspecified other impact.
  references:
  - source: cve@mitre.org
    tags:
    - Patch
    url: https://github.com/kamailio/kamailio/commit/ada3701d22b1fd579f06b4f54fa695fa988e685f
  - source: cve@mitre.org
    tags:
    - Exploit
    - Issue Tracking
    url: https://github.com/kamailio/kamailio/issues/2503
  - source: cve@mitre.org
    url: https://lists.debian.org/debian-lts-announce/2023/05/msg00030.html
  title: The Kamailio SIP before 5.5.0 server mishandles INVITE requests with duplicated
    fields and overlength tag, leading to a buffer overflow that crashes the server
    or possibly have unspecified other impact.
- diff_content:
  - "--- a/modules/sipmsgops/codecs.c\n+++ b/modules/sipmsgops/codecs.c\n@@ -559,7\
    \ +559,7 @@ static int stream_process(struct sip_msg * msg, struct sdp_stream_cell\
    \ *cell,\n \t\t\t\t\t/* when trimming the very last payload, avoid trailing ws\
    \ */\n \t\t\t\t\tif (cur == lmp->u.value + lmp->len) {\n \t\t\t\t\t\ttmp = found.s;\n\
    -\t\t\t\t\t\twhile (*(--tmp) == ' ') {\n+\t\t\t\t\t\twhile (tmp>lmp->u.value &&\
    \ *(--tmp) == ' ') {\n \t\t\t\t\t\t\tfound.s--;\n \t\t\t\t\t\t\tfound.len++;\n\
    \ \t\t\t\t\t\t}"
  identifiers:
  - CVE-2023-27596
  - CWE-770
  overview: OpenSIPS is a Session Initiation Protocol (SIP) server implementation.
    Prior to versions 3.1.8 and 3.2.5, OpenSIPS crashes when a malformed SDP body
    is sent multiple times to an OpenSIPS configuration that makes use of the `stream_process`
    function. This issue was discovered during coverage guided fuzzing of the function
    `codec_delete_except_re`. By abusing this vulnerability, an attacker is able to
    crash the server. It affects configurations containing functions that rely on
    the affected code, such as the function `codec_delete_except_re`. This issue has
    been fixed in version 3.1.8 and 3.2.5.
  references:
  - source: security-advisories@github.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/OpenSIPS/opensips/commit/dd051f8ed5ae3347fb1d556ced3c97822c9d8450
  - source: security-advisories@github.com
    tags:
    - Third Party Advisory
    url: https://github.com/OpenSIPS/opensips/security/advisories/GHSA-3ghx-j39m-cw4f
  title: OpenSIPS is a Session Initiation Protocol (SIP) server implementation. Prior
    to versions 3.1.8 and 3.2.5, OpenSIPS crashes when a malformed SDP body is sent
    multiple times to an OpenSIPS configuration that makes use of the `stream_process`
    function. This issue was discovered during coverage guided fuzzing of the function
    `codec_delete_except_re`. By abusing this vulnerability, an attacker is able to
    crash the server. It affects configurations containing functions that rely on
    the affected code, such as the function `codec_delete_except_re`. This issue has
    been fixed in version 3.1.8 and 3.2.5.
- diff_content:
  - "--- a/parser/parse_uri.c\n+++ b/parser/parse_uri.c\n@@ -1532,7 +1532,8 @@ int\
    \ parse_uri(char* buf, int len, struct sip_uri* uri)\n \t\tcase TELS_URI_T:\n\
    \ \t\t\t/* fix tel uris, move the number in uri and empty the host */\n \t\t\t\
    uri->user=uri->host;\n-\t\t\turi->host.s=\"\";\n+\t\t\t/* TEL does not have a\
    \ host part, still most of the code expects\n+\t\t\t * one, so lets keep the pointer,\
    \ but set a 0 length */\n \t\t\turi->host.len=0;\n \t\t\tbreak;\n \t\tcase SIP_URI_T:\n\
    @@ -1543,8 +1544,7 @@ int parse_uri(char* buf, int len, struct sip_uri* uri)\n\
    \ \t\tcase URN_NENA_SERVICE_URI_T:\n \t\t\turi->user.s=0;\n \t\t\turi->user.len=0;\n\
    -\t\t\turi->host.s=\"\";\n-\t\t\turi->host.len=0;\n+\t\t\t/* keep the service\
    \ name as host part */\n \t\t\tbreak;\n \t\tcase ERROR_URI_T:\n \t\t\tLM_ERR(\"\
    unexpected error (BUG?)\\n\");"
  identifiers:
  - CVE-2023-27597
  - NVD-CWE-noinfo
  overview: OpenSIPS is a Session Initiation Protocol (SIP) server implementation.
    Prior to versions 3.1.8 and 3.2.5, when a specially crafted SIP message is processed
    by the function `rewrite_ruri`, a crash occurs due to a segmentation fault. This
    issue causes the server to crash. It affects configurations containing functions
    that make use of the affected code, such as the function `setport`. This issue
    has been fixed in version 3.1.8 and 3.2.5.
  references:
  - source: security-advisories@github.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/OpenSIPS/opensips/commit/b2dffe4b5cd81182c9c8eabb6c96aac96c7acfe3
  - source: security-advisories@github.com
    tags:
    - Third Party Advisory
    url: https://github.com/OpenSIPS/opensips/security/advisories/GHSA-358f-935m-7p9c
  title: OpenSIPS is a Session Initiation Protocol (SIP) server implementation. Prior
    to versions 3.1.8 and 3.2.5, when a specially crafted SIP message is processed
    by the function `rewrite_ruri`, a crash occurs due to a segmentation fault. This
    issue causes the server to crash. It affects configurations containing functions
    that make use of the affected code, such as the function `setport`. This issue
    has been fixed in version 3.1.8 and 3.2.5.
- diff_content:
  - "--- a/parser/parse_via.c\n+++ b/parser/parse_via.c\n@@ -1804,7 +1804,6 @@ char*\
    \ parse_via(char* buffer, char* end, struct via_body *vbody)\n \n \t\t\tcase ':':\n\
    \ \t\t\t\tswitch(state){\n-\t\t\t\t\tcase F_HOST:\n \t\t\t\t\tcase F_IP6HOST:\n\
    \ \t\t\t\t\t\tstate=P_IP6HOST;\n \t\t\t\t\t\tbreak;"
  identifiers:
  - CVE-2023-27598
  - CWE-908
  overview: OpenSIPS is a Session Initiation Protocol (SIP) server implementation.
    Prior to versions 3.1.7 and 3.2.4, sending a malformed `Via` header to OpenSIPS
    triggers a segmentation fault when the function `calc_tag_suffix` is called. A
    specially crafted `Via` header, which is deemed correct by the parser, will pass
    uninitialized strings to the function `MD5StringArray` which leads to the crash.
    Abuse of this vulnerability leads to Denial of Service due to a crash. Since the
    uninitialized string points to memory location `0x0`, no further exploitation
    appears to be possible. No special network privileges are required to perform
    this attack, as long as the OpenSIPS configuration makes use of functions such
    as `sl_send_reply` or `sl_gen_totag` that trigger the vulnerable code. This issue
    has been fixed in versions 3.1.7 and 3.2.4.
  references:
  - source: security-advisories@github.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/OpenSIPS/opensips/commit/ab611f74f69d9c42be5401c40d56ea06a58f5dd7
  - source: security-advisories@github.com
    tags:
    - Third Party Advisory
    url: https://github.com/OpenSIPS/opensips/security/advisories/GHSA-wxfg-3gwh-rhvx
  - source: security-advisories@github.com
    tags:
    - Third Party Advisory
    url: https://opensips.org/pub/audit-2022/opensips-audit-technical-report-full.pdf
  title: OpenSIPS is a Session Initiation Protocol (SIP) server implementation. Prior
    to versions 3.1.7 and 3.2.4, sending a malformed `Via` header to OpenSIPS triggers
    a segmentation fault when the function `calc_tag_suffix` is called. A specially
    crafted `Via` header, which is deemed correct by the parser, will pass uninitialized
    strings to the function `MD5StringArray` which leads to the crash. Abuse of this
    vulnerability leads to Denial of Service due to a crash. Since the uninitialized
    string points to memory location `0x0`, no further exploitation appears to be
    possible. No special network privileges are required to perform this attack, as
    long as the OpenSIPS configuration makes use of functions such as `sl_send_reply`
    or `sl_gen_totag` that trigger the vulnerable code. This issue has been fixed
    in versions 3.1.7 and 3.2.4.
- diff_content:
  - "--- a/parser/parse_to.c\n+++ b/parser/parse_to.c\n@@ -232,6 +232,8 @@ static\
    \ inline char* parse_to_param(char *buffer, char *end,\n \t\t\t\tswitch (status)\n\
    \ \t\t\t\t{\n \t\t\t\t\tcase PARA_VALUE_QUOTED:\n+\t\t\t\t\t\tif (tmp+1==end)\n\
    +\t\t\t\t\t\t\tgoto parse_error;\n \t\t\t\t\t\tswitch (*(tmp+1))\n \t\t\t\t\t\t\
    {\n \t\t\t\t\t\t\tcase '\\r':\n@@ -453,8 +455,13 @@ static inline char* parse_to_param(char\
    \ *buffer, char *end,\n \t\t}/*switch*/\n \t}/*for*/\n \n+\tif (status==PARA_VALUE_QUOTED)\
    \ {\n+\t\t\tLM_ERR(\"unexpected end of header in state %d\\n\", status);\n+\t\t\
    \tgoto parse_error;\n+\t}\n \n endofheader:\n+\tLM_DBG(\"end of header reached,\
    \ state=%d\\n\", status);\n \tif (param) {\n \t\tif (saved_status==S_EQUAL||saved_status==S_PARA_VALUE)\
    \ {\n \t\t\tsaved_status = E_PARA_VALUE;"
  identifiers:
  - CVE-2023-27599
  - NVD-CWE-noinfo
  overview: OpenSIPS is a Session Initiation Protocol (SIP) server implementation.
    Prior to versions 3.1.7 and 3.2.4, when the function `append_hf` handles a SIP
    message with a malformed To header, a call to the function `abort()` is performed,
    resulting in a crash. This is due to the following check in `data_lump.c:399`
    in the function `anchor_lump`. An attacker abusing this vulnerability will crash
    OpenSIPS leading to Denial of Service. It affects configurations containing functions
    that make use of the affected code, such as the function `append_hf`. This issue
    has been fixed in versions 3.1.7 and 3.2.4.
  references:
  - source: security-advisories@github.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/OpenSIPS/opensips/commit/cb56694d290530ac308f44b453c18120b1c1109d
  - source: security-advisories@github.com
    tags:
    - Third Party Advisory
    url: https://github.com/OpenSIPS/opensips/security/advisories/GHSA-qvj2-vqrg-f5jx
  - source: security-advisories@github.com
    tags:
    - Third Party Advisory
    url: https://opensips.org/pub/audit-2022/opensips-audit-technical-report-full.pdf
  title: OpenSIPS is a Session Initiation Protocol (SIP) server implementation. Prior
    to versions 3.1.7 and 3.2.4, when the function `append_hf` handles a SIP message
    with a malformed To header, a call to the function `abort()` is performed, resulting
    in a crash. This is due to the following check in `data_lump.c:399` in the function
    `anchor_lump`. An attacker abusing this vulnerability will crash OpenSIPS leading
    to Denial of Service. It affects configurations containing functions that make
    use of the affected code, such as the function `append_hf`. This issue has been
    fixed in versions 3.1.7 and 3.2.4.
- diff_content:
  - "--- a/modules/sipmsgops/codecs.c\n+++ b/modules/sipmsgops/codecs.c\n@@ -366,7\
    \ +366,8 @@ int delete_sdp_line( struct sip_msg * msg, char * s, struct sdp_stream_cell\
    \ *str\n \n \twhile(*end != '\\n' && end < (stream->body.s+stream->body.len) )\n\
    \ \t\tend++;\n-\tend++;\n+\tif ( *end == '\\n')\n+\t\tend++;\n \n \t/* delete\
    \ the entry */\n \tif( del_lump(msg, start - msg->buf, end - start,0) == NULL\
    \ )"
  identifiers:
  - CVE-2023-27600
  - NVD-CWE-noinfo
  overview: 'OpenSIPS is a Session Initiation Protocol (SIP) server implementation.
    Prior to versions 3.1.7 and 3.2.4, OpenSIPS crashes when a malformed SDP body
    is received and is processed by the `delete_sdp_line` function in the sipmsgops
    module. This issue can be reproduced by calling the function with an SDP body
    that does not terminate by a line feed (i.e. `\n`).


    The vulnerability was found while performing black-box fuzzing against an OpenSIPS
    server running a configuration that made use of the functions `codec_delete_except_re`
    and `codec_delete_re`. The same issue was also discovered while performing coverage
    guided fuzzing on the function `codec_delete_except_re`. The crash happens because
    the function `delete_sdp_line` expects that an SDP line is terminated by a line
    feed (`\n`).


    By abusing this vulnerability, an attacker is able to crash the server. It affects
    configurations containing functions that rely on the affected code, such as the
    function `codec_delete_except_re`. Due to the sanity check that is performed in
    the `del_lump` function, exploitation of this issue will generate an `abort` in
    the lumps processing function, resulting in a Denial of Service. This issue is
    patched in versions 3.1.7 and 3.2.4.'
  references:
  - source: security-advisories@github.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/OpenSIPS/opensips/commit/c6ab3bb406c447e30c7d33a1a8970048b4612100
  - source: security-advisories@github.com
    tags:
    - Third Party Advisory
    url: https://github.com/OpenSIPS/opensips/security/advisories/GHSA-67w7-g4j8-3wcx
  - source: security-advisories@github.com
    tags:
    - Vendor Advisory
    url: https://opensips.org/docs/modules/3.3.x/sipmsgops.html
  - source: security-advisories@github.com
    tags:
    - Vendor Advisory
    url: https://opensips.org/pub/audit-2022/opensips-audit-technical-report-full.pdf
  title: 'OpenSIPS is a Session Initiation Protocol (SIP) server implementation. Prior
    to versions 3.1.7 and 3.2.4, OpenSIPS crashes when a malformed SDP body is received
    and is processed by the `delete_sdp_line` function in the sipmsgops module. This
    issue can be reproduced by calling the function with an SDP body that does not
    terminate by a line feed (i.e. `\n`).


    The vulnerability was found while performing black-box fuzzing against an OpenSIPS
    server running a configuration that made use of the functions `codec_delete_except_re`
    and `codec_delete_re`. The same issue was also discovered while performing coverage
    guided fuzzing on the function `codec_delete_except_re`. The crash happens because
    the function `delete_sdp_line` expects that an SDP line is terminated by a line
    feed (`\n`).


    By abusing this vulnerability, an attacker is able to crash the server. It affects
    configurations containing functions that rely on the affected code, such as the
    function `codec_delete_except_re`. Due to the sanity check that is performed in
    the `del_lump` function, exploitation of this issue will generate an `abort` in
    the lumps processing function, resulting in a Denial of Service. This issue is
    patched in versions 3.1.7 and 3.2.4.'
- diff_content:
  - "--- a/modules/sipmsgops/codecs.c\n+++ b/modules/sipmsgops/codecs.c\n@@ -347,7\
    \ +347,10 @@ static int do_for_all_streams(struct sip_msg* msg, str* str1,str\
    \ * str2,\n }\n \n \n-int delete_sdp_line( struct sip_msg * msg, char * s)\n+/*\
    \ deletes a SDP line (from a stream) by giving a pointer within the line.\n+ *\
    \ The stream is used to safeguard the identification of the line boundries.\n\
    + */\n+int delete_sdp_line( struct sip_msg * msg, char * s, struct sdp_stream_cell\
    \ *stream)\n {\n \tchar * start,*end;\n \n@@ -357,11 +360,11 @@ int delete_sdp_line(\
    \ struct sip_msg * msg, char * s)\n \tstart = s;\n \tend  = s;\n \n-\twhile(*start\
    \ != '\\n')\n+\twhile(*start != '\\n' && start > stream->body.s)\n \t\tstart--;\n\
    \ \tstart++;\n \n-\twhile(*end != '\\n')\n+\twhile(*end != '\\n' && end < (stream->body.s+stream->body.len)\
    \ )\n \t\tend++;\n \tend++;\n \n@@ -530,14 +533,14 @@ static int stream_process(struct\
    \ sip_msg * msg, struct sdp_stream_cell *cell,\n \t\t\t\t{\n \t\t\t\t\t/* find\
    \ the full 'a=...' entry */\n \n-\t\t\t\t\tif( delete_sdp_line( msg, payload->rtp_enc.s)\
    \ < 0 )\n+\t\t\t\t\tif( delete_sdp_line( msg, payload->rtp_enc.s, cell) < 0 )\n\
    \ \t\t\t\t\t{\n \t\t\t\t\t\tLM_ERR(\"Unable to add delete lump for a=\\n\");\n\
    \ \t\t\t\t\t\tret = -1;\n \t\t\t\t\t\tgoto end;\n \t\t\t\t\t}\n \n-\t\t\t\t\t\
    if( delete_sdp_line( msg, payload->fmtp_string.s) < 0 )\n+\t\t\t\t\tif( delete_sdp_line(\
    \ msg, payload->fmtp_string.s, cell) < 0 )\n \t\t\t\t\t{\n \t\t\t\t\t\tLM_ERR(\"\
    Unable to add delete lump for a=\\n\");\n \t\t\t\t\t\tret = -1;"
  identifiers:
  - CVE-2023-27601
  - NVD-CWE-noinfo
  overview: 'OpenSIPS is a Session Initiation Protocol (SIP) server implementation.
    Prior to versions 3.1.7 and 3.2.4, OpenSIPS crashes when a malformed SDP body
    is received and is processed by the `delete_sdp_line` function in the sipmsgops
    module. This issue can be reproduced by calling the function with an SDP body
    that does not terminate by a line feed (i.e. `\n`).


    The vulnerability was found while performing black-box fuzzing against an OpenSIPS
    server running a configuration that made use of the functions `codec_delete_except_re`
    and `codec_delete_re`. The same issue was also discovered while performing coverage
    guided fuzzing on the function `codec_delete_except_re`. The crash happens because
    the function `delete_sdp_line` expects that an SDP line is terminated by a line
    feed (`\n`):


    By abusing this vulnerability, an attacker is able to crash the server. It affects
    configurations containing functions that rely on the affected code, such as the
    function `codec_delete_except_re`. Due to the sanity check that is performed in
    the `del_lump` function, exploitation of this issue will generate an `abort` in
    the lumps processing function, resulting in a Denial of Service. This issue has
    been fixed in versions 3.1.7 and 3.2.4.'
  references:
  - source: security-advisories@github.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/OpenSIPS/opensips/commit/8f87c7c03da55f9c79bd92e67fa2c94b2a7ce5cf
  - source: security-advisories@github.com
    tags:
    - Third Party Advisory
    url: https://github.com/OpenSIPS/opensips/security/advisories/GHSA-xj5x-g52f-548h
  - source: security-advisories@github.com
    tags:
    - Vendor Advisory
    url: https://opensips.org/docs/modules/3.3.x/sipmsgops.html
  - source: security-advisories@github.com
    tags:
    - Vendor Advisory
    url: https://opensips.org/pub/audit-2022/opensips-audit-technical-report-full.pdf
  title: 'OpenSIPS is a Session Initiation Protocol (SIP) server implementation. Prior
    to versions 3.1.7 and 3.2.4, OpenSIPS crashes when a malformed SDP body is received
    and is processed by the `delete_sdp_line` function in the sipmsgops module. This
    issue can be reproduced by calling the function with an SDP body that does not
    terminate by a line feed (i.e. `\n`).


    The vulnerability was found while performing black-box fuzzing against an OpenSIPS
    server running a configuration that made use of the functions `codec_delete_except_re`
    and `codec_delete_re`. The same issue was also discovered while performing coverage
    guided fuzzing on the function `codec_delete_except_re`. The crash happens because
    the function `delete_sdp_line` expects that an SDP line is terminated by a line
    feed (`\n`):


    By abusing this vulnerability, an attacker is able to crash the server. It affects
    configurations containing functions that rely on the affected code, such as the
    function `codec_delete_except_re`. Due to the sanity check that is performed in
    the `del_lump` function, exploitation of this issue will generate an `abort` in
    the lumps processing function, resulting in a Denial of Service. This issue has
    been fixed in versions 3.1.7 and 3.2.4.'
- diff_content:
  - "--- a/msg_translator.c\n+++ b/msg_translator.c\n@@ -134,9 +134,6 @@ int disable_503_translation\
    \ = 0;\n \t\t(_dest) += (_len) ;\\\n \t}while(0);\n \n-#define append_str_trans(_dest,_src,_len,_msg)\
    \ \\\n-\tappend_str( (_dest), (_src), (_len) );\n-\n extern char version[];\n\
    \ extern int version_len;\n \n@@ -2489,39 +2486,40 @@ char * build_res_buf_from_sip_req(\
    \ unsigned int code, const str *text ,str *new_\n \t/* first line */\n \tlen +=\
    \ SIP_VERSION_LEN + 1/*space*/ + 3/*code*/ + 1/*space*/ +\n \t\ttext->len + CRLF_LEN/*new\
    \ line*/;\n-\t/*headers that will be copied (TO, FROM, CSEQ,CALLID,VIA)*/\n-\t\
    for ( hdr=msg->headers ; hdr ; hdr=hdr->next ) {\n-\t\tswitch (hdr->type) {\n\
    -\t\t\tcase HDR_TO_T:\n-\t\t\t\tif (new_tag && new_tag->len) {\n-\t\t\t\t\tto_tag=get_to(msg)->tag_value;\n\
    -\t\t\t\t\tif (to_tag.len )\n-\t\t\t\t\t\tlen+=new_tag->len-to_tag.len;\n-\t\t\
    \t\t\telse\n-\t\t\t\t\t\tlen+=new_tag->len+TOTAG_TOKEN_LEN/*\";tag=\"*/;\n-\t\t\
    \t\t}\n-\t\t\t\tlen += hdr->len;\n-\t\t\t\tbreak;\n-\t\t\tcase HDR_VIA_T:\n-\t\
    \t\t\t/* we always add CRLF to via*/\n-\t\t\t\tlen+=(hdr->body.s+hdr->body.len)-hdr->name.s+CRLF_LEN;\n\
    -\t\t\t\tif (hdr==msg->h_via1) len += received_len+rport_len;\n-\t\t\t\tbreak;\n\
    -\t\t\tcase HDR_RECORDROUTE_T:\n-\t\t\t\t/* RR only for 1xx and 2xx replies */\n\
    -\t\t\t\tif (code<180 || code>=300)\n-\t\t\t\t\tbreak;\n-\t\t\tcase HDR_FROM_T:\n\
    -\t\t\tcase HDR_CALLID_T:\n-\t\t\tcase HDR_CSEQ_T:\n-\t\t\t\t/* we keep the original\
    \ termination for these headers*/\n-\t\t\t\tlen += hdr->len;\n-\t\t\t\tbreak;\n\
    -\t\t\tdefault:\n-\t\t\t\t/* do nothing, we are interested only in the above headers\
    \ */\n-\t\t\t\t;\n+\t/* copy the TO hdr */\n+\tif (msg->to) {\n+\t\tif (new_tag\
    \ && new_tag->len) {\n+\t\t\tto_tag=get_to(msg)->tag_value;\n+\t\t\tif (to_tag.len\
    \ )\n+\t\t\t\tlen+=new_tag->len-to_tag.len;\n+\t\t\telse\n+\t\t\t\tlen+=new_tag->len+TOTAG_TOKEN_LEN/*\"\
    ;tag=\"*/;\n \t\t}\n-\t}\n+\t\tlen += msg->to->len;\n+\t}\n+\n+\t/* copy all VIA\
    \ hdrs */\n+\tfor( hdr=msg->h_via1 ; hdr ; hdr=hdr->sibling) {\n+\t\t/* we always\
    \ add CRLF to via*/\n+\t\tlen+=(hdr->body.s+hdr->body.len)-hdr->name.s+CRLF_LEN;\n\
    +\t\tif (hdr==msg->h_via1) len += received_len+rport_len;\n+\t}\n+\t/* copy all\
    \ Record-Route hdrs */\n+\tfor( hdr=msg->record_route ; hdr ; hdr=hdr->sibling)\
    \ {\n+\t\t/* RR only for 1xx and 2xx replies */\n+\t\tif (code>=180 && code<300)\n\
    +\t\t\tlen += hdr->len;\n+\t}\n+\t/* copy the FROM hdr */\n+\tif (msg->from)\n\
    +\t\tlen += msg->from->len;\n+\t/* copy the CALLID hdr */\n+\tif (msg->callid)\n\
    +\t\tlen += msg->callid->len;\n+\t/* copy the CSEQ hdr */\n+\tif (msg->cseq)\n\
    +\t\tlen += msg->cseq->len;\n+\n \t/* lumps length */\n \tfor(lump=msg->reply_lump;lump;lump=lump->next)\
    \ {\n \t\tlen += lump->text.len;\n@@ -2570,100 +2568,103 @@ char * build_res_buf_from_sip_req(\
    \ unsigned int code, const str *text ,str *new_\n \tp += text->len;\n \tmemcpy(\
    \ p, CRLF, CRLF_LEN );\n \tp+=CRLF_LEN;\n-\t/* headers*/\n-\tfor ( hdr=msg->headers\
    \ ; hdr ; hdr=hdr->next ) {\n-\t\tswitch (hdr->type)\n-\t\t{\n-\t\t\tcase HDR_VIA_T:\n\
    -\t\t\t\tif (hdr==msg->h_via1){\n-\t\t\t\t\ti = 0;\n-\t\t\t\t\tif (received_buf)\
    \ {\n-\t\t\t\t\t\ti = msg->via1->host.s - msg->via1->hdr.s +\n-\t\t\t\t\t\t\t\
    msg->via1->host.len + (msg->via1->port?\n-\t\t\t\t\t\t\tmsg->via1->port_str.len\
    \ + 1 : 0);\n-\t\t\t\t\t\t/* copy via1 up to params */\n-\t\t\t\t\t\tappend_str(\
    \ p, hdr->name.s, i);\n-\t\t\t\t\t\t/* copy received param */\n-\t\t\t\t\t\tappend_str(\
    \ p, received_buf, received_len);\n-\t\t\t\t\t}\n-\t\t\t\t\tif (rport_buf){\n\
    -\t\t\t\t\t\tif (msg->via1->rport){ /* delete the old one */\n-\t\t\t\t\t\t\t\
    /* copy until rport */\n-\t\t\t\t\t\t\tappend_str_trans( p, hdr->name.s+i ,\n\
    -\t\t\t\t\t\t\t\tmsg->via1->rport->start-hdr->name.s-1-i,msg);\n-\t\t\t\t\t\t\t\
    /* copy new rport */\n-\t\t\t\t\t\t\tappend_str(p, rport_buf, rport_len);\n-\t\
    \t\t\t\t\t\t/* copy the rest of the via */\n-\t\t\t\t\t\t\tappend_str_trans(p,\
    \ msg->via1->rport->start+\n-\t\t\t\t\t\t\t\t\t\t\t\tmsg->via1->rport->size,\n\
    -\t\t\t\t\t\t\t\t\t\t\t\thdr->body.s+hdr->body.len-\n-\t\t\t\t\t\t\t\t\t\t\t\t\
    msg->via1->rport->start-\n-\t\t\t\t\t\t\t\t\t\t\t\tmsg->via1->rport->size, msg);\n\
    -\t\t\t\t\t\t}else{ /* just copy rport and rest of hdr */\n-\t\t\t\t\t\t\tappend_str(p,\
    \ rport_buf, rport_len);\n-\t\t\t\t\t\t\tappend_str_trans( p, hdr->name.s+i ,\n\
    -\t\t\t\t\t\t\t\t(hdr->body.s+hdr->body.len)-hdr->name.s-i,msg);\n-\t\t\t\t\t\t\
    }\n-\t\t\t\t\t}else{\n-\t\t\t\t\t\t/* normal whole via copy */\n-\t\t\t\t\t\t\
    append_str_trans( p, hdr->name.s+i ,\n-\t\t\t\t\t\t\t(hdr->body.s+hdr->body.len)-hdr->name.s-i,\
    \ msg);\n-\t\t\t\t\t}\n-\t\t\t\t}else{\n-\t\t\t\t\t/* normal whole via copy */\n\
    -\t\t\t\t\tappend_str_trans( p, hdr->name.s,\n-\t\t\t\t\t\t\t(hdr->body.s+hdr->body.len)-hdr->name.s,\
    \ msg);\n-\t\t\t\t}\n-\t\t\t\tappend_str( p, CRLF,CRLF_LEN);\n-\t\t\t\tbreak;\n\
    -\t\t\tcase HDR_RECORDROUTE_T:\n-\t\t\t\t/* RR only for 1xx and 2xx replies */\n\
    -\t\t\t\tif (code<180 || code>=300) break;\n-\t\t\t\tappend_str(p, hdr->name.s,\
    \ hdr->len);\n-\t\t\t\tbreak;\n-\t\t\tcase HDR_TO_T:\n-\t\t\t\tif (new_tag &&\
    \ new_tag->len){\n-\t\t\t\t\tif (to_tag.len ) { /* replacement */\n-\t\t\t\t\t\
    \t/* before to-tag */\n-\t\t\t\t\t\tappend_str( p, hdr->name.s, to_tag.s-hdr->name.s);\n\
    -\t\t\t\t\t\t/* to tag replacement */\n-\t\t\t\t\t\tbmark->to_tag_val.s=p;\n-\t\
    \t\t\t\t\tbmark->to_tag_val.len=new_tag->len;\n-\t\t\t\t\t\tappend_str( p, new_tag->s,new_tag->len);\n\
    -\t\t\t\t\t\t/* the rest after to-tag */\n-\t\t\t\t\t\tappend_str( p, to_tag.s+to_tag.len,\n\
    -\t\t\t\t\t\t\thdr->name.s+hdr->len-(to_tag.s+to_tag.len));\n-\t\t\t\t\t}else{\
    \ /* adding a new to-tag */\n-\t\t\t\t\t\tafter_body=hdr->body.s+hdr->body.len;\n\
    -\t\t\t\t\t\tappend_str( p, hdr->name.s, after_body-hdr->name.s);\n-\t\t\t\t\t\
    \tappend_str(p, TOTAG_TOKEN, TOTAG_TOKEN_LEN);\n-\t\t\t\t\t\tbmark->to_tag_val.s=p;\n\
    -\t\t\t\t\t\tbmark->to_tag_val.len=new_tag->len;\n-\t\t\t\t\t\tappend_str( p,\
    \ new_tag->s,new_tag->len);\n-\t\t\t\t\t\tappend_str( p, after_body,\n-\t\t\t\t\
    \t\t\t\t\t\thdr->name.s+hdr->len-after_body);\n-\t\t\t\t\t}\n-\t\t\t\t\tbreak;\n\
    -\t\t\t\t} /* no new to-tag -- proceed to 1:1 copying  */\n-\t\t\t\ttotags=((struct\
    \ to_body*)(hdr->parsed))->tag_value.s;\n-\t\t\t\tif (totags) {\n-\t\t\t\t\tbmark->to_tag_val.s=p+(totags-hdr->name.s);\n\
    -\t\t\t\t\tbmark->to_tag_val.len=\n-\t\t\t\t\t\t\t((struct to_body*)(hdr->parsed))->tag_value.len;\n\
    -\t\t\t\t} else {\n-\t\t\t\t\tbmark->to_tag_val.s = NULL;\n-\t\t\t\t\tbmark->to_tag_val.len\
    \ = 0;\n-\t\t\t\t}\n-\t\t\tcase HDR_FROM_T:\n-\t\t\tcase HDR_CALLID_T:\n-\t\t\t\
    case HDR_CSEQ_T:\n-\t\t\t\t\tappend_str(p, hdr->name.s, hdr->len);\n-\t\t\t\t\t\
    break;\n-\t\t\tdefault:\n-\t\t\t\t/* do nothing, we are interested only in the\
    \ above headers */\n-\t\t\t\t;\n-\t\t} /* end switch */\n-\t} /* end for */\n\
    +\t/* VIA headers */\n+\tif ( (hdr=msg->h_via1)!=NULL ) {\n+\t\t/* handle the\
    \ VIA1, subject to changes */\n+\t\ti = 0;\n+\t\tif (received_buf) {\n+\t\t\t\
    i = msg->via1->host.s - msg->via1->hdr.s +\n+\t\t\t\tmsg->via1->host.len + (msg->via1->port?\n\
    +\t\t\t\tmsg->via1->port_str.len + 1 : 0);\n+\t\t\t/* copy via1 up to params */\n\
    +\t\t\tappend_str( p, hdr->name.s, i);\n+\t\t\t/* copy received param */\n+\t\t\
    \tappend_str( p, received_buf, received_len);\n+\t\t}\n+\t\tif (rport_buf){\n\
    +\t\t\tif (msg->via1->rport){ /* delete the old one */\n+\t\t\t\t/* copy until\
    \ rport */\n+\t\t\t\tappend_str( p, hdr->name.s+i ,\n+\t\t\t\t\tmsg->via1->rport->start-hdr->name.s-1-i);\n\
    +\t\t\t\t/* copy new rport */\n+\t\t\t\tappend_str(p, rport_buf, rport_len);\n\
    +\t\t\t\t/* copy the rest of the via */\n+\t\t\t\tappend_str(p, msg->via1->rport->start+\n\
    +\t\t\t\t\t\t\t\t\tmsg->via1->rport->size,\n+\t\t\t\t\t\t\t\t\thdr->body.s+hdr->body.len-\n\
    +\t\t\t\t\t\t\t\t\tmsg->via1->rport->start-\n+\t\t\t\t\t\t\t\t\tmsg->via1->rport->size);\n\
    +\t\t\t}else{ /* just copy rport and rest of hdr */\n+\t\t\t\tappend_str(p, rport_buf,\
    \ rport_len);\n+\t\t\t\tappend_str( p, hdr->name.s+i ,\n+\t\t\t\t\t(hdr->body.s+hdr->body.len)-hdr->name.s-i);\n\
    +\t\t\t}\n+\t\t}else{\n+\t\t\t/* normal whole via copy */\n+\t\t\tappend_str(\
    \ p, hdr->name.s+i ,\n+\t\t\t\t(hdr->body.s+hdr->body.len)-hdr->name.s-i);\n+\t\
    \t}\n+\t\tappend_str( p, CRLF,CRLF_LEN);\n+\t\t/* and now the rest of the VIA\
    \ hdrs */\n+\t\tfor( hdr=hdr->sibling ; hdr ; hdr=hdr->sibling) {\n+\t\t\t/* normal\
    \ whole via copy */\n+\t\t\tappend_str( p, hdr->name.s,\n+\t\t\t\t\t(hdr->body.s+hdr->body.len)-hdr->name.s);\n\
    +\t\t\tappend_str( p, CRLF,CRLF_LEN);\n+\t\t}\n+\t}\n+\t/* Record-Route headers\
    \ */\n+\tfor( hdr=msg->record_route ; hdr ; hdr=hdr->sibling) {\n+\t\t/* RR only\
    \ for 1xx and 2xx replies */\n+\t\tif (code>=180 && code<300)\n+\t\t\tappend_str(p,\
    \ hdr->name.s, hdr->len);\n+\t}\n+\t/* TO hdr */\n+\tif ( (hdr=msg->to)!=NULL\
    \ ) {\n+\t\tif (new_tag && new_tag->len){\n+\t\t\tif (to_tag.len ) { /* replacement\
    \ */\n+\t\t\t\t/* before to-tag */\n+\t\t\t\tappend_str( p, hdr->name.s, to_tag.s-hdr->name.s);\n\
    +\t\t\t\t/* to tag replacement */\n+\t\t\t\tbmark->to_tag_val.s=p;\n+\t\t\t\t\
    bmark->to_tag_val.len=new_tag->len;\n+\t\t\t\tappend_str( p, new_tag->s,new_tag->len);\n\
    +\t\t\t\t/* the rest after to-tag */\n+\t\t\t\tappend_str( p, to_tag.s+to_tag.len,\n\
    +\t\t\t\t\thdr->name.s+hdr->len-(to_tag.s+to_tag.len));\n+\t\t\t}else{ /* adding\
    \ a new to-tag */\n+\t\t\t\tafter_body=hdr->body.s+hdr->body.len;\n+\t\t\t\tappend_str(\
    \ p, hdr->name.s, after_body-hdr->name.s);\n+\t\t\t\tappend_str(p, TOTAG_TOKEN,\
    \ TOTAG_TOKEN_LEN);\n+\t\t\t\tbmark->to_tag_val.s=p;\n+\t\t\t\tbmark->to_tag_val.len=new_tag->len;\n\
    +\t\t\t\tappend_str( p, new_tag->s,new_tag->len);\n+\t\t\t\tappend_str( p, after_body,\n\
    +\t\t\t\t\t\t\t\thdr->name.s+hdr->len-after_body);\n+\t\t\t}\n+\t\t} else {\n\
    +\t\t\t/* no new to-tag -- proceed to 1:1 copying  */\n+\t\t\ttotags=((struct\
    \ to_body*)(hdr->parsed))->tag_value.s;\n+\t\t\tif (totags) {\n+\t\t\t\tbmark->to_tag_val.s=p+(totags-hdr->name.s);\n\
    +\t\t\t\tbmark->to_tag_val.len=\n+\t\t\t\t\t((struct to_body*)(hdr->parsed))->tag_value.len;\n\
    +\t\t\t} else {\n+\t\t\t\tbmark->to_tag_val.s = NULL;\n+\t\t\t\tbmark->to_tag_val.len\
    \ = 0;\n+\t\t\t}\n+\t\t\tappend_str(p, hdr->name.s, hdr->len);\n+\t\t}\n+\t}\n\
    +\t/* FROM header */\n+\tif (msg->from)\n+\t\tappend_str(p, msg->from->name.s,\
    \ msg->from->len);\n+\t/* CALLID header */\n+\tif (msg->callid)\n+\t\tappend_str(p,\
    \ msg->callid->name.s, msg->callid->len);\n+\t/* copy the CSEQ hdr */\n+\tif (msg->cseq)\n\
    +\t\tappend_str(p, msg->cseq->name.s, msg->cseq->len);\n \t/* lumps */\n \tfor(lump=msg->reply_lump;lump;lump=lump->next)\n\
    \ \t\tif (lump->flags&LUMP_RPL_HDR){"
  identifiers:
  - CVE-2023-28095
  - NVD-CWE-noinfo
  overview: OpenSIPS is a Session Initiation Protocol (SIP) server implementation.
    Versions prior to 3.1.7 and 3.2.4 have a potential issue in `msg_translator.c:2628`
    which might lead to a server crash. This issue was found while fuzzing the function
    `build_res_buf_from_sip_req` but could not be reproduced against a running instance
    of OpenSIPS. This issue could not be exploited against a running instance of OpenSIPS
    since no public function was found to make use of this vulnerable code. Even in
    the case of exploitation through unknown vectors, it is highly unlikely that this
    issue would lead to anything other than Denial of Service. This issue has been
    fixed in versions 3.1.7 and 3.2.4.
  references:
  - source: security-advisories@github.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/OpenSIPS/opensips/commit/9cf3dd3398719dd91207495f76d7726701c5145c
  - source: security-advisories@github.com
    tags:
    - Third Party Advisory
    url: https://github.com/OpenSIPS/opensips/security/advisories/GHSA-7pf3-24qg-8v9h
  - source: security-advisories@github.com
    tags:
    - Vendor Advisory
    url: https://opensips.org/pub/audit-2022/opensips-audit-technical-report-full.pdf
  title: OpenSIPS is a Session Initiation Protocol (SIP) server implementation. Versions
    prior to 3.1.7 and 3.2.4 have a potential issue in `msg_translator.c:2628` which
    might lead to a server crash. This issue was found while fuzzing the function
    `build_res_buf_from_sip_req` but could not be reproduced against a running instance
    of OpenSIPS. This issue could not be exploited against a running instance of OpenSIPS
    since no public function was found to make use of this vulnerable code. Even in
    the case of exploitation through unknown vectors, it is highly unlikely that this
    issue would lead to anything other than Denial of Service. This issue has been
    fixed in versions 3.1.7 and 3.2.4.
- diff_content:
  - "--- a/lib/cJSON.c\n+++ b/lib/cJSON.c\n@@ -1483,7 +1483,7 @@ static const unsigned\
    \ char *parse_object(cJSON *item, const unsigned char *value\n fail:\n     if\
    \ (item->child != NULL)\n     {\n-        cJSON_Delete(child);\n+        cJSON_Delete(item->child);\n\
    \         item->child = NULL;\n     }\n "
  identifiers:
  - CVE-2023-28096
  - CWE-401
  overview: "OpenSIPS, a Session Initiation Protocol (SIP) server implementation,\
    \ has a memory leak starting in the 2.3 branch and priot to versions 3.1.8 and\
    \ 3.2.5. The memory leak was detected in the function `parse_mi_request` while\
    \ performing coverage-guided fuzzing. This issue can be reproduced by sending\
    \ multiple requests of the form `{\"jsonrpc\": \"2.0\",\"method\": \"log_le`.\
    \ This malformed message was tested against an instance of OpenSIPS via FIFO transport\
    \ layer and was found to increase the memory consumption over time.\n\nTo abuse\
    \ this memory leak, attackers need to reach the management interface (MI) which\
    \ typically should only be exposed on trusted interfaces. In cases where the MI\
    \ is exposed to the internet without authentication, abuse of this issue will\
    \ lead to memory exhaustion which may affect the underlying system\u2019s availability.\
    \ No authentication is typically required to reproduce this issue. On the other\
    \ hand, memory leaks may occur in other areas of OpenSIPS where the cJSON library\
    \ is used for parsing JSON objects.\n\nThe issue has been fixed in versions 3.1.8\
    \ and 3.2.5."
  references:
  - source: security-advisories@github.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/OpenSIPS/opensips/commit/417568707520af25ec5c5dd91da18e6db3649dcb
  - source: security-advisories@github.com
    tags:
    - Third Party Advisory
    url: https://github.com/OpenSIPS/opensips/security/advisories/GHSA-2mg2-g46r-j4qr
  - source: security-advisories@github.com
    tags:
    - Vendor Advisory
    url: https://opensips.org/pub/audit-2022/opensips-audit-technical-report-full.pdf
  title: "OpenSIPS, a Session Initiation Protocol (SIP) server implementation, has\
    \ a memory leak starting in the 2.3 branch and priot to versions 3.1.8 and 3.2.5.\
    \ The memory leak was detected in the function `parse_mi_request` while performing\
    \ coverage-guided fuzzing. This issue can be reproduced by sending multiple requests\
    \ of the form `{\"jsonrpc\": \"2.0\",\"method\": \"log_le`. This malformed message\
    \ was tested against an instance of OpenSIPS via FIFO transport layer and was\
    \ found to increase the memory consumption over time.\n\nTo abuse this memory\
    \ leak, attackers need to reach the management interface (MI) which typically\
    \ should only be exposed on trusted interfaces. In cases where the MI is exposed\
    \ to the internet without authentication, abuse of this issue will lead to memory\
    \ exhaustion which may affect the underlying system\u2019s availability. No authentication\
    \ is typically required to reproduce this issue. On the other hand, memory leaks\
    \ may occur in other areas of OpenSIPS where the cJSON library is used for parsing\
    \ JSON objects.\n\nThe issue has been fixed in versions 3.1.8 and 3.2.5."
- diff_content:
  - "--- a/parser/parse_content.c\n+++ b/parser/parse_content.c\n@@ -241,12 +241,14\
    \ @@ char* parse_content_length( char* buffer, char* end, int* length)\n \tsize\
    \ = 0;\n \tnumber = 0;\n \twhile (p<end && *p>='0' && *p<='9') {\n-\t\tnumber\
    \ = number*10 + (*p)-'0';\n-\t\tif (number<0) {\n-\t\t\tLM_ERR(\"number overflow\
    \ at pos %d in len number [%.*s]\\n\",\n+\t\t/* do not actually cause an integer\
    \ overflow, as it is UB! --liviu */\n+\t\tif (number > 214748363) {\n+\t\t\tLM_ERR(\"\
    integer overflow risk at pos %d in len number [%.*s]\\n\",\n \t\t\t\t(int)(p-buffer),(int)(end-buffer),\
    \ buffer);\n \t\t\treturn 0;\n \t\t}\n+\n+\t\tnumber = number*10 + (*p)-'0';\n\
    \ \t\tsize ++;\n \t\tp++;\n \t}"
  identifiers:
  - CVE-2023-28097
  - CWE-190
  overview: OpenSIPS is a Session Initiation Protocol (SIP) server implementation.
    Prior to versions 3.1.9 and 3.2.6, a malformed SIP message containing a large
    _Content-Length_ value and a specially crafted Request-URI causes a segmentation
    fault in OpenSIPS. This issue occurs when a large amount of shared memory using
    the `-m` flag was allocated to OpenSIPS, such as 10 GB of RAM. On the test system,
    this issue occurred when shared memory was set to `2362` or higher. This issue
    is fixed in versions 3.1.9 and 3.2.6. The only workaround is to guarantee that
    the Content-Length value of input messages is never larger than `2147483647`.
  references:
  - source: security-advisories@github.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/OpenSIPS/opensips/commit/7cab422e2fc648f910abba34f3f0dbb3ae171ff5
  - source: security-advisories@github.com
    tags:
    - Third Party Advisory
    url: https://github.com/OpenSIPS/opensips/security/advisories/GHSA-c6j5-f4h4-2xrq
  - source: security-advisories@github.com
    tags:
    - Vendor Advisory
    url: https://opensips.org/pub/audit-2022/opensips-audit-technical-report-full.pdf
  title: OpenSIPS is a Session Initiation Protocol (SIP) server implementation. Prior
    to versions 3.1.9 and 3.2.6, a malformed SIP message containing a large _Content-Length_
    value and a specially crafted Request-URI causes a segmentation fault in OpenSIPS.
    This issue occurs when a large amount of shared memory using the `-m` flag was
    allocated to OpenSIPS, such as 10 GB of RAM. On the test system, this issue occurred
    when shared memory was set to `2362` or higher. This issue is fixed in versions
    3.1.9 and 3.2.6. The only workaround is to guarantee that the Content-Length value
    of input messages is never larger than `2147483647`.
- diff_content:
  - "--- a/parser/digest/param_parser.c\n+++ b/parser/digest/param_parser.c\n@@ -72,6\
    \ +72,7 @@\n #define READ(val) \\\n (*(val + 0) + (*(val + 1) << 8) + (*(val +\
    \ 2) << 16) + (*(val + 3) << 24))\n \n+#define NEED(bytes) do { if (end - p <\
    \ (bytes)) goto other; } while (0)\n \n #define name_CASE                    \
    \  \\\n         switch(LOWER_DWORD(val)) {     \\\n@@ -83,28 +84,30 @@\n \n \n\
    \ #define user_CASE         \\\n-        p += 4;           \\\n+        p += 4;\
    \ NEED(4);  \\\n         val = READ(p);    \\\n         name_CASE;        \\\n\
    \         goto other;\n \n \n #define real_CASE                         \\\n-\
    \        p += 4;                           \\\n+        p += 4; NEED(1);     \
    \             \\\n         if (LOWER_BYTE(*p) == 'm') {      \\\n \t\t*_type =\
    \ PAR_REALM;       \\\n                 p++;                      \\\n \t\tgoto\
    \ end;                 \\\n-\t}\n+\t}                                 \\\n+  \
    \      goto other;\n \n \n #define nonc_CASE                         \\\n-   \
    \     p += 4;                           \\\n+        p += 4; NEED(1);        \
    \          \\\n         if (LOWER_BYTE(*p) == 'e') {      \\\n \t        *_type\
    \ = PAR_NONCE;       \\\n                 p++;                      \\\n \t\t\
    goto end;                 \\\n-\t}\n+\t}                                 \\\n\
    +        goto other;\n \n \n #define onse_CASE                      \\\n@@ -117,14\
    \ +120,14 @@\n \n \n #define resp_CASE         \\\n-        p += 4;          \
    \ \\\n+        p += 4; NEED(4);  \\\n         val = READ(p);    \\\n         onse_CASE;\
    \        \\\n         goto other;\n \n \n #define cnon_CASE                  \
    \               \\\n-        p += 4;                                   \\\n+ \
    \       p += 4; NEED(2);                          \\\n         if (LOWER_BYTE(*p)\
    \ == 'c') {              \\\n \t\tp++;                              \\\n \t\t\
    if (LOWER_BYTE(*p) == 'e') {      \\\n@@ -137,7 +140,7 @@\n \n \n #define opaq_CASE\
    \                                 \\\n-        p += 4;                       \
    \            \\\n+        p += 4; NEED(2);                          \\\n     \
    \    if (LOWER_BYTE(*p) == 'u') {              \\\n \t\tp++;                 \
    \             \\\n \t\tif (LOWER_BYTE(*p) == 'e') {      \\\n@@ -163,7 +166,7\
    \ @@\n \n \n #define algo_CASE         \\\n-        p += 4;           \\\n+  \
    \      p += 4; NEED(5);  \\\n         val = READ(p);    \\\n         rith_CASE;\
    \        \\\n         goto other"
  identifiers:
  - CVE-2023-28098
  - NVD-CWE-noinfo
  overview: 'OpenSIPS is a Session Initiation Protocol (SIP) server implementation.
    Prior to versions 3.1.7 and 3.2.4, a specially crafted Authorization header causes
    OpenSIPS to crash or behave in an unexpected way due to a bug in the function
    `parse_param_name()` . This issue was discovered while performing coverage guided
    fuzzing of the function parse_msg. The AddressSanitizer identified that the issue
    occurred in the function `q_memchr()` which is being called by the function `parse_param_name()`.
    This issue may cause erratic program behaviour or a server crash. It affects configurations
    containing

    functions that make use of the affected code, such as the function `www_authorize()`
    . Versions 3.1.7 and 3.2.4 contain a fix.'
  references:
  - source: security-advisories@github.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/OpenSIPS/opensips/commit/dd9141b6f67d7df4072f3430f628d4b73df5e102
  - source: security-advisories@github.com
    tags:
    - Third Party Advisory
    url: https://github.com/OpenSIPS/opensips/security/advisories/GHSA-jrqg-vppj-hr2h
  - source: security-advisories@github.com
    tags:
    - Third Party Advisory
    url: https://opensips.org/pub/audit-2022/opensips-audit-technical-report-full.pdf
  title: 'OpenSIPS is a Session Initiation Protocol (SIP) server implementation. Prior
    to versions 3.1.7 and 3.2.4, a specially crafted Authorization header causes OpenSIPS
    to crash or behave in an unexpected way due to a bug in the function `parse_param_name()`
    . This issue was discovered while performing coverage guided fuzzing of the function
    parse_msg. The AddressSanitizer identified that the issue occurred in the function
    `q_memchr()` which is being called by the function `parse_param_name()`. This
    issue may cause erratic program behaviour or a server crash. It affects configurations
    containing

    functions that make use of the affected code, such as the function `www_authorize()`
    . Versions 3.1.7 and 3.2.4 contain a fix.'
- diff_content:
  - "--- a/modules/dispatcher/dispatch.c\n+++ b/modules/dispatcher/dispatch.c\n@@\
    \ -2310,7 +2310,7 @@ int ds_is_in_list(struct sip_msg *_m, str *_ip, int port,\
    \ int set,\n \tchar *pattern = NULL;\n \n \tif (!(ip = str2ip(_ip)) && !(ip =\
    \ str2ip6(_ip))) {\n-\t\tLM_ERR(\"IP val is not IP <%.*s>\\n\",val.rs.len,val.rs.s);\n\
    +\t\tLM_ERR(\"IP val is not IP <%.*s>\\n\", _ip->len, _ip->s);\n \t\treturn -1;\n\
    \ \t}\n "
  identifiers:
  - CVE-2023-28099
  - NVD-CWE-noinfo
  overview: OpenSIPS is a Session Initiation Protocol (SIP) server implementation.
    Prior to versions 3.1.9 and 3.2.6, if `ds_is_in_list()` is used with an invalid
    IP address string (`NULL` is illegal input), OpenSIPS will attempt to print a
    string from a random address (stack garbage), which could lead to a crash.  All
    users of `ds_is_in_list()` without the `$si` variable as 1st parameter could be
    affected by this vulnerability to a larger, lesser or no extent at all, depending
    if the data passed to the function is a valid IPv4 or IPv6 address string or not.
    Fixes will are available starting with the 3.1.9 and 3.2.6 minor releases. There
    are no known workarounds.
  references:
  - source: security-advisories@github.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/OpenSIPS/opensips/commit/e2f13d374
  - source: security-advisories@github.com
    tags:
    - Third Party Advisory
    url: https://github.com/OpenSIPS/opensips/issues/2780
  - source: security-advisories@github.com
    tags:
    - Third Party Advisory
    url: https://github.com/OpenSIPS/opensips/security/advisories/GHSA-pfm5-6vhv-3ff3
  title: OpenSIPS is a Session Initiation Protocol (SIP) server implementation. Prior
    to versions 3.1.9 and 3.2.6, if `ds_is_in_list()` is used with an invalid IP address
    string (`NULL` is illegal input), OpenSIPS will attempt to print a string from
    a random address (stack garbage), which could lead to a crash.  All users of `ds_is_in_list()`
    without the `$si` variable as 1st parameter could be affected by this vulnerability
    to a larger, lesser or no extent at all, depending if the data passed to the function
    is a valid IPv4 or IPv6 address string or not. Fixes will are available starting
    with the 3.1.9 and 3.2.6 minor releases. There are no known workarounds.
- diff_content:
  - "--- a/lib/eventlog/eventlog.c\n+++ b/lib/eventlog/eventlog.c\n@@ -1,7 +1,7 @@\n\
    \ /*\n  * SPDX-License-Identifier: ISC\n  *\n- * Copyright (c) 1994-1996, 1998-2021\
    \ Todd C. Miller <Todd.Miller@sudo.ws>\n+ * Copyright (c) 1994-1996, 1998-2023\
    \ Todd C. Miller <Todd.Miller@sudo.ws>\n  *\n  * Permission to use, copy, modify,\
    \ and distribute this software for any\n  * purpose with or without fee is hereby\
    \ granted, provided that the above\n@@ -51,24 +51,13 @@\n #include \"sudo_compat.h\"\
    \n #include \"sudo_debug.h\"\n #include \"sudo_eventlog.h\"\n+#include \"sudo_lbuf.h\"\
    \n #include \"sudo_fatal.h\"\n #include \"sudo_gettext.h\"\n #include \"sudo_json.h\"\
    \n #include \"sudo_queue.h\"\n #include \"sudo_util.h\"\n \n-#define\tLL_HOST_STR\t\
    \"HOST=\"\n-#define\tLL_TTY_STR\t\"TTY=\"\n-#define\tLL_CHROOT_STR\t\"CHROOT=\"\
    \n-#define\tLL_CWD_STR\t\"PWD=\"\n-#define\tLL_USER_STR\t\"USER=\"\n-#define\t\
    LL_GROUP_STR\t\"GROUP=\"\n-#define\tLL_ENV_STR\t\"ENV=\"\n-#define\tLL_CMND_STR\t\
    \"COMMAND=\"\n-#define\tLL_TSID_STR\t\"TSID=\"\n-#define\tLL_EXIT_STR\t\"EXIT=\"\
    \n-#define\tLL_SIGNAL_STR\t\"SIGNAL=\"\n-\n #define IS_SESSID(s) ( \\\n     isalnum((unsigned\
    \ char)(s)[0]) && isalnum((unsigned char)(s)[1]) && \\\n     (s)[2] == '/' &&\
    \ \\\n@@ -93,26 +82,28 @@ new_logline(int event_type, int flags, struct eventlog_args\
    \ *args,\n     const struct eventlog *evlog)\n {\n     const struct eventlog_config\
    \ *evl_conf = eventlog_getconf();\n-    char *line = NULL, *evstr = NULL;\n  \
    \   const char *iolog_file;\n     const char *tty, *tsid = NULL;\n     char exit_str[(((sizeof(int)\
    \ * 8) + 2) / 3) + 2];\n     char sessid[7], offsetstr[64] = \"\";\n-    size_t\
    \ len = 0;\n+    struct sudo_lbuf lbuf;\n     int i;\n     debug_decl(new_logline,\
    \ SUDO_DEBUG_UTIL);\n \n+    sudo_lbuf_init(&lbuf, NULL, 0, NULL, 0);\n+\n   \
    \  if (ISSET(flags, EVLOG_RAW) || evlog == NULL) {\n \tif (args->reason != NULL)\
    \ {\n \t    if (args->errstr != NULL) {\n-\t\tif (asprintf(&line, \"%s: %s\",\
    \ args->reason, args->errstr) == -1)\n-\t\t    goto oom;\n+\t\tsudo_lbuf_append_esc(&lbuf,\
    \ LBUF_ESC_CNTRL, \"%s: %s\",\n+\t\t    args->reason, args->errstr);\n \t    }\
    \ else {\n-\t\tif ((line = strdup(args->reason)) == NULL)\n-\t\t    goto oom;\n\
    +\t\tsudo_lbuf_append_esc(&lbuf, LBUF_ESC_CNTRL, \"%s\", args->reason);\n \t \
    \   }\n+\t    if (sudo_lbuf_error(&lbuf))\n+\t\tgoto oom;\n \t}\n-\tdebug_return_str(line);\n\
    +\tdebug_return_str(lbuf.buf);\n     }\n \n     /* A TSID may be a sudoers-style\
    \ session ID or a free-form string. */\n@@ -150,169 +141,90 @@ new_logline(int\
    \ event_type, int flags, struct eventlog_args *args,\n     }\n \n     /*\n-  \
    \   * Compute line length\n+     * Format the log line as an lbuf, escaping control\
    \ characters in\n+     * octal form (#0nn).  Error checking (ENOMEM) is done at\
    \ the end.\n      */\n-    if (args->reason != NULL)\n-\tlen += strlen(args->reason)\
    \ + 3;\n-    if (args->errstr != NULL)\n-\tlen += strlen(args->errstr) + 3;\n\
    -    if (evlog->submithost != NULL && !evl_conf->omit_hostname)\n-\tlen += sizeof(LL_HOST_STR)\
    \ + 2 + strlen(evlog->submithost);\n-    if (tty != NULL)\n-\tlen += sizeof(LL_TTY_STR)\
    \ + 2 + strlen(tty);\n-    if (evlog->runchroot != NULL)\n-\tlen += sizeof(LL_CHROOT_STR)\
    \ + 2 + strlen(evlog->runchroot);\n-    if (evlog->runcwd != NULL)\n-\tlen +=\
    \ sizeof(LL_CWD_STR) + 2 + strlen(evlog->runcwd);\n-    if (evlog->runuser !=\
    \ NULL)\n-\tlen += sizeof(LL_USER_STR) + 2 + strlen(evlog->runuser);\n-    if\
    \ (evlog->rungroup != NULL)\n-\tlen += sizeof(LL_GROUP_STR) + 2 + strlen(evlog->rungroup);\n\
    -    if (tsid != NULL) {\n-\tlen += sizeof(LL_TSID_STR) + 2 + strlen(tsid) + strlen(offsetstr);\n\
    -    }\n-    if (evlog->env_add != NULL) {\n-\tsize_t evlen = 0;\n-\tchar * const\
    \ *ep;\n-\n-\tfor (ep = evlog->env_add; *ep != NULL; ep++)\n-\t    evlen += strlen(*ep)\
    \ + 1;\n-\tif (evlen != 0) {\n-\t    if ((evstr = malloc(evlen)) == NULL)\n-\t\
    \tgoto oom;\n-\t    ep = evlog->env_add;\n-\t    if (strlcpy(evstr, *ep, evlen)\
    \ >= evlen)\n-\t\tgoto toobig;\n-\t    while (*++ep != NULL) {\n-\t\tif (strlcat(evstr,\
    \ \" \", evlen) >= evlen ||\n-\t\t    strlcat(evstr, *ep, evlen) >= evlen)\n-\t\
    \t    goto toobig;\n-\t    }\n-\t    len += sizeof(LL_ENV_STR) + 2 + evlen;\n\
    -\t}\n-    }\n-    if (evlog->command != NULL) {\n-\tlen += sizeof(LL_CMND_STR)\
    \ - 1 + strlen(evlog->command);\n-\tif (evlog->argv != NULL && evlog->argv[0]\
    \ != NULL) {\n-\t    for (i = 1; evlog->argv[i] != NULL; i++)\n-\t\tlen += strlen(evlog->argv[i])\
    \ + 1;\n-\t}\n-\tif (event_type == EVLOG_EXIT) {\n-\t    if (evlog->signal_name\
    \ != NULL)\n-\t\tlen += sizeof(LL_SIGNAL_STR) + 2 + strlen(evlog->signal_name);\n\
    -\t    if (evlog->exit_value != -1) {\n-\t\t(void)snprintf(exit_str, sizeof(exit_str),\
    \ \"%d\", evlog->exit_value);\n-\t\tlen += sizeof(LL_EXIT_STR) + 2 + strlen(exit_str);\n\
    -\t    }\n-\t}\n-    }\n-\n-    /*\n-     * Allocate and build up the line.\n\
    -     */\n-    if ((line = malloc(++len)) == NULL)\n-\tgoto oom;\n-    line[0]\
    \ = '\\0';\n-\n     if (args->reason != NULL) {\n-\tif (strlcat(line, args->reason,\
    \ len) >= len ||\n-\t    strlcat(line, args->errstr ? \" : \" : \" ; \", len)\
    \ >= len)\n-\t    goto toobig;\n+\tsudo_lbuf_append_esc(&lbuf, LBUF_ESC_CNTRL,\
    \ \"%s%s\", args->reason,\n+\t    args->errstr ? \" : \" : \" ; \");\n     }\n\
    \     if (args->errstr != NULL) {\n-\tif (strlcat(line, args->errstr, len) >=\
    \ len ||\n-\t    strlcat(line, \" ; \", len) >= len)\n-\t    goto toobig;\n+\t\
    sudo_lbuf_append_esc(&lbuf, LBUF_ESC_CNTRL, \"%s ; \", args->errstr);\n     }\n\
    \     if (evlog->submithost != NULL && !evl_conf->omit_hostname) {\n-\tif (strlcat(line,\
    \ LL_HOST_STR, len) >= len ||\n-\t    strlcat(line, evlog->submithost, len) >=\
    \ len ||\n-\t    strlcat(line, \" ; \", len) >= len)\n-\t    goto toobig;\n+\t\
    sudo_lbuf_append_esc(&lbuf, LBUF_ESC_CNTRL, \"HOST=%s ; \",\n+\t    evlog->submithost);\n\
    \     }\n     if (tty != NULL) {\n-\tif (strlcat(line, LL_TTY_STR, len) >= len\
    \ ||\n-\t    strlcat(line, tty, len) >= len ||\n-\t    strlcat(line, \" ; \",\
    \ len) >= len)\n-\t    goto toobig;\n+\tsudo_lbuf_append_esc(&lbuf, LBUF_ESC_CNTRL,\
    \ \"TTY=%s ; \", tty);\n     }\n     if (evlog->runchroot != NULL) {\n-\tif (strlcat(line,\
    \ LL_CHROOT_STR, len) >= len ||\n-\t    strlcat(line, evlog->runchroot, len) >=\
    \ len ||\n-\t    strlcat(line, \" ; \", len) >= len)\n-\t    goto toobig;\n+\t\
    sudo_lbuf_append_esc(&lbuf, LBUF_ESC_CNTRL, \"CHROOT=%s ; \",\n+\t    evlog->runchroot);\n\
    \     }\n     if (evlog->runcwd != NULL) {\n-\tif (strlcat(line, LL_CWD_STR, len)\
    \ >= len ||\n-\t    strlcat(line, evlog->runcwd, len) >= len ||\n-\t    strlcat(line,\
    \ \" ; \", len) >= len)\n-\t    goto toobig;\n+\tsudo_lbuf_append_esc(&lbuf, LBUF_ESC_CNTRL,\
    \ \"PWD=%s ; \",\n+\t    evlog->runcwd);\n     }\n     if (evlog->runuser != NULL)\
    \ {\n-\tif (strlcat(line, LL_USER_STR, len) >= len ||\n-\t    strlcat(line, evlog->runuser,\
    \ len) >= len ||\n-\t    strlcat(line, \" ; \", len) >= len)\n-\t    goto toobig;\n\
    +\tsudo_lbuf_append_esc(&lbuf, LBUF_ESC_CNTRL, \"USER=%s ; \",\n+\t    evlog->runuser);\n\
    \     }\n     if (evlog->rungroup != NULL) {\n-\tif (strlcat(line, LL_GROUP_STR,\
    \ len) >= len ||\n-\t    strlcat(line, evlog->rungroup, len) >= len ||\n-\t  \
    \  strlcat(line, \" ; \", len) >= len)\n-\t    goto toobig;\n+\tsudo_lbuf_append_esc(&lbuf,\
    \ LBUF_ESC_CNTRL, \"GROUP=%s ; \",\n+\t    evlog->rungroup);\n     }\n     if\
    \ (tsid != NULL) {\n-\tif (strlcat(line, LL_TSID_STR, len) >= len ||\n-\t    strlcat(line,\
    \ tsid, len) >= len ||\n-\t    strlcat(line, offsetstr, len) >= len ||\n-\t  \
    \  strlcat(line, \" ; \", len) >= len)\n-\t    goto toobig;\n-    }\n-    if (evstr\
    \ != NULL) {\n-\tif (strlcat(line, LL_ENV_STR, len) >= len ||\n-\t    strlcat(line,\
    \ evstr, len) >= len ||\n-\t    strlcat(line, \" ; \", len) >= len)\n-\t    goto\
    \ toobig;\n-\tfree(evstr);\n-\tevstr = NULL;\n+\tsudo_lbuf_append_esc(&lbuf, LBUF_ESC_CNTRL,\
    \ \"TSID=%s%s ; \", tsid,\n+\t    offsetstr);\n+    }\n+    if (evlog->env_add\
    \ != NULL && evlog->env_add[0] != NULL) {\n+\tsudo_lbuf_append_esc(&lbuf, LBUF_ESC_CNTRL,\
    \ \"ENV=%s\",\n+\t    evlog->env_add[0]);\n+\tfor (i = 1; evlog->env_add[i] !=\
    \ NULL; i++) {\n+\t    sudo_lbuf_append_esc(&lbuf, LBUF_ESC_CNTRL, \" %s\",\n\
    +\t\tevlog->env_add[i]);\n+\t}\n     }\n     if (evlog->command != NULL) {\n-\t\
    if (strlcat(line, LL_CMND_STR, len) >= len)\n-\t    goto toobig;\n-\tif (strlcat(line,\
    \ evlog->command, len) >= len)\n-\t    goto toobig;\n+\tsudo_lbuf_append_esc(&lbuf,\
    \ LBUF_ESC_CNTRL|LBUF_ESC_BLANK,\n+\t    \"COMMAND=%s\", evlog->command);\n \t\
    if (evlog->argv != NULL && evlog->argv[0] != NULL) {\n \t    for (i = 1; evlog->argv[i]\
    \ != NULL; i++) {\n-\t\tif (strlcat(line, \" \", len) >= len ||\n-\t\t    strlcat(line,\
    \ evlog->argv[i], len) >= len)\n-\t\t    goto toobig;\n+\t\tsudo_lbuf_append(&lbuf,\
    \ \" \");\n+\t\tif (strchr(evlog->argv[i], ' ') != NULL) {\n+\t\t    /* Wrap args\
    \ containing spaces in single quotes. */\n+\t\t    sudo_lbuf_append(&lbuf, \"\
    '\");\n+\t\t    sudo_lbuf_append_esc(&lbuf, LBUF_ESC_CNTRL|LBUF_ESC_QUOTE,\n+\t\
    \t\t\"%s\", evlog->argv[i]);\n+\t\t    sudo_lbuf_append(&lbuf, \"'\");\n+\t\t\
    } else {\n+\t\t    /* Escape quotes here too for consistency. */\n+\t\t    sudo_lbuf_append_esc(&lbuf,\n\
    +\t\t\tLBUF_ESC_CNTRL|LBUF_ESC_BLANK|LBUF_ESC_QUOTE,\n+\t\t\t\"%s\", evlog->argv[i]);\n\
    +\t\t}\n \t    }\n \t}\n \tif (event_type == EVLOG_EXIT) {\n \t    if (evlog->signal_name\
    \ != NULL) {\n-\t\tif (strlcat(line, \" ; \", len) >= len ||\n-\t\t    strlcat(line,\
    \ LL_SIGNAL_STR, len) >= len ||\n-\t\t    strlcat(line, evlog->signal_name, len)\
    \ >= len)\n-\t\t    goto toobig;\n+\t\tsudo_lbuf_append_esc(&lbuf, LBUF_ESC_CNTRL,\
    \ \" ; SIGNAL=%s\",\n+\t\t    evlog->signal_name);\n \t    }\n \t    if (evlog->exit_value\
    \ != -1) {\n-\t\tif (strlcat(line, \" ; \", len) >= len ||\n-\t\t    strlcat(line,\
    \ LL_EXIT_STR, len) >= len ||\n-\t\t    strlcat(line, exit_str, len) >= len)\n\
    -\t\t    goto toobig;\n+\t\t(void)snprintf(exit_str, sizeof(exit_str), \"%d\"\
    ,\n+\t\t    evlog->exit_value);\n+\t\tsudo_lbuf_append_esc(&lbuf, LBUF_ESC_CNTRL,\
    \ \" ; EXIT=%s\",\n+\t\t    exit_str);\n \t    }\n \t}\n     }\n-\n-    debug_return_str(line);\n\
    +    if (!sudo_lbuf_error(&lbuf))\n+\tdebug_return_str(lbuf.buf);\n oom:\n-  \
    \  free(evstr);\n+    sudo_lbuf_destroy(&lbuf);\n     sudo_warnx(U_(\"%s: %s\"\
    ), __func__, U_(\"unable to allocate memory\"));\n     debug_return_str(NULL);\n\
    -toobig:\n-    free(evstr);\n-    free(line);\n-    sudo_warnx(U_(\"internal error,\
    \ %s overflow\"), __func__);\n-    debug_return_str(NULL);\n }\n \n static void"
  - "--- a/lib/iolog/iolog_json.c\n+++ b/lib/iolog/iolog_json.c\n@@ -551,45 +551,6\
    \ @@ iolog_parse_json_object(struct json_object *object, struct eventlog *evlog)\n\
    \ \t}\n     }\n \n-    /* Merge cmd and argv as sudoreplay expects. */\n-    if\
    \ (evlog->command != NULL && evlog->argv != NULL && evlog->argv[0] != NULL) {\n\
    -\tsize_t len, bufsize = strlen(evlog->command) + 1;\n-\tchar *cp, *buf;\n-\t\
    int ac;\n-\n-\t/* Skip argv[0], we use evlog->command instead. */\n-\tfor (ac\
    \ = 1; evlog->argv[ac] != NULL; ac++)\n-\t    bufsize += strlen(evlog->argv[ac])\
    \ + 1;\n-\n-\tif ((buf = malloc(bufsize)) == NULL) {\n-\t    sudo_warnx(U_(\"\
    %s: %s\"), __func__, U_(\"unable to allocate memory\"));\n-\t    goto done;\n\
    -\t}\n-\tcp = buf;\n-\n-\tlen = strlcpy(cp, evlog->command, bufsize);\n-\tif (len\
    \ >= bufsize)\n-\t    sudo_fatalx(U_(\"internal error, %s overflow\"), __func__);\n\
    -\tcp += len;\n-\tbufsize -= len;\n-\n-\tfor (ac = 1; evlog->argv[ac] != NULL;\
    \ ac++) {\n-\t    if (bufsize < 2)\n-\t\tsudo_fatalx(U_(\"internal error, %s overflow\"\
    ), __func__);\n-\t    *cp++ = ' ';\n-\t    bufsize--;\n-\n-\t    len = strlcpy(cp,\
    \ evlog->argv[ac], bufsize);\n-\t    if (len >= bufsize)\n-\t\tsudo_fatalx(U_(\"\
    internal error, %s overflow\"), __func__);\n-\t    cp += len;\n-\t    bufsize\
    \ -= len;\n-\t}\n-\n-\tfree(evlog->command);\n-\tevlog->command = buf;\n-    }\n\
    -\n     ret = true;\n \n done:"
  - "--- a/lib/util/lbuf.c\n+++ b/lib/util/lbuf.c\n@@ -94,6 +94,112 @@ sudo_lbuf_expand(struct\
    \ sudo_lbuf *lbuf, unsigned int extra)\n     debug_return_bool(true);\n }\n \n\
    +/*\n+ * Escape a character in octal form (#0n) and store it as a string\n+ *\
    \ in buf, which must have at least 6 bytes available.\n+ * Returns the length\
    \ of buf, not counting the terminating NUL byte.\n+ */\n+static int\n+escape(unsigned\
    \ char ch, char *buf)\n+{\n+    const int len = ch < 0100 ? (ch < 010 ? 3 : 4)\
    \ : 5;\n+\n+    /* Work backwards from the least significant digit to most significant.\
    \ */\n+    switch (len) {\n+    case 5:\n+\tbuf[4] = (ch & 7) + '0';\n+\tch >>=\
    \ 3;\n+\tFALLTHROUGH;\n+    case 4:\n+\tbuf[3] = (ch & 7) + '0';\n+\tch >>= 3;\n\
    +\tFALLTHROUGH;\n+    case 3:\n+\tbuf[2] = (ch & 7) + '0';\n+\tbuf[1] = '0';\n\
    +\tbuf[0] = '#';\n+\tbreak;\n+    }\n+    buf[len] = '\\0';\n+\n+    return len;\n\
    +}\n+\n+/*\n+ * Parse the format and append strings, only %s and %% escapes are\
    \ supported.\n+ * Any non-printable characters are escaped in octal as #0nn.\n\
    + */\n+bool\n+sudo_lbuf_append_esc_v1(struct sudo_lbuf *lbuf, int flags, const\
    \ char *fmt, ...)\n+{\n+    unsigned int saved_len = lbuf->len;\n+    bool ret\
    \ = false;\n+    const char *s;\n+    va_list ap;\n+    debug_decl(sudo_lbuf_append_esc,\
    \ SUDO_DEBUG_UTIL);\n+\n+    if (sudo_lbuf_error(lbuf))\n+\tdebug_return_bool(false);\n\
    +\n+#define should_escape(ch) \\\n+    ((ISSET(flags, LBUF_ESC_CNTRL) && iscntrl((unsigned\
    \ char)ch)) || \\\n+    (ISSET(flags, LBUF_ESC_BLANK) && isblank((unsigned char)ch)))\n\
    +#define should_quote(ch) \\\n+    (ISSET(flags, LBUF_ESC_QUOTE) && (ch == '\\\
    '' || ch == '\\\\'))\n+\n+    va_start(ap, fmt);\n+    while (*fmt != '\\0') {\n\
    +\tif (fmt[0] == '%' && fmt[1] == 's') {\n+\t    if ((s = va_arg(ap, char *))\
    \ == NULL)\n+\t\ts = \"(NULL)\";\n+\t    while (*s != '\\0') {\n+\t\tif (should_escape(*s))\
    \ {\n+\t\t    if (!sudo_lbuf_expand(lbuf, sizeof(\"#0177\") - 1))\n+\t\t\tgoto\
    \ done;\n+\t\t    lbuf->len += escape(*s++, lbuf->buf + lbuf->len);\n+\t\t   \
    \ continue;\n+\t\t}\n+\t\tif (should_quote(*s)) {\n+\t\t    if (!sudo_lbuf_expand(lbuf,\
    \ 2))\n+\t\t\tgoto done;\n+\t\t    lbuf->buf[lbuf->len++] = '\\\\';\n+\t\t   \
    \ lbuf->buf[lbuf->len++] = *s++;\n+\t\t    continue;\n+\t\t}\n+\t\tif (!sudo_lbuf_expand(lbuf,\
    \ 1))\n+\t\t    goto done;\n+\t\tlbuf->buf[lbuf->len++] = *s++;\n+\t    }\n+\t\
    \    fmt += 2;\n+\t    continue;\n+\t}\n+\tif (should_escape(*fmt)) {\n+\t   \
    \ if (!sudo_lbuf_expand(lbuf, sizeof(\"#0177\") - 1))\n+\t\tgoto done;\n+\t  \
    \  if (*fmt == '\\'') {\n+\t\tlbuf->buf[lbuf->len++] = '\\\\';\n+\t\tlbuf->buf[lbuf->len++]\
    \ = *fmt++;\n+\t    } else {\n+\t\tlbuf->len += escape(*fmt++, lbuf->buf + lbuf->len);\n\
    +\t    }\n+\t    continue;\n+\t}\n+\tif (!sudo_lbuf_expand(lbuf, 1))\n+\t    goto\
    \ done;\n+\tlbuf->buf[lbuf->len++] = *fmt++;\n+    }\n+    ret = true;\n+\n+done:\n\
    +    if (!ret)\n+\tlbuf->len = saved_len;\n+    if (lbuf->size != 0)\n+\tlbuf->buf[lbuf->len]\
    \ = '\\0';\n+    va_end(ap);\n+\n+    debug_return_bool(ret);\n+}\n+\n /*\n  *\
    \ Parse the format and append strings, only %s and %% escapes are supported.\n\
    \  * Any characters in set are quoted with a backslash."
  - "--- a/plugins/sudoers/sudoreplay.c\n+++ b/plugins/sudoers/sudoreplay.c\n@@ -62,6\
    \ +62,7 @@\n #include \"sudo_debug.h\"\n #include \"sudo_event.h\"\n #include\
    \ \"sudo_eventlog.h\"\n+#include \"sudo_lbuf.h\"\n #include \"sudo_fatal.h\"\n\
    \ #include \"sudo_gettext.h\"\n #include \"sudo_iolog.h\"\n@@ -373,6 +374,10 @@\
    \ main(int argc, char *argv[])\n     if ((evlog = iolog_parse_loginfo(iolog_dir_fd,\
    \ iolog_dir)) == NULL)\n \tgoto done;\n     printf(_(\"Replaying sudo session:\
    \ %s\"), evlog->command);\n+    if (evlog->argv != NULL && evlog->argv[0] != NULL)\
    \ {\n+\tfor (i = 1; evlog->argv[i] != NULL; i++)\n+\t    printf(\" %s\", evlog->argv[i]);\n\
    +    }\n \n     /* Setup terminal if appropriate. */\n     if (!isatty(STDIN_FILENO)\
    \ || !isatty(STDOUT_FILENO))\n@@ -1315,11 +1320,57 @@ parse_expr(struct search_node_list\
    \ *head, char *argv[], bool sub_expr)\n     debug_return_int(av - argv);\n }\n\
    \ \n+static char *\n+expand_command(struct eventlog *evlog, char **newbuf)\n+{\n\
    +    size_t len, bufsize = strlen(evlog->command) + 1;\n+    char *cp, *buf;\n\
    +    int ac;\n+    debug_decl(expand_command, SUDO_DEBUG_UTIL);\n+\n+    if (evlog->argv\
    \ == NULL || evlog->argv[0] == NULL || evlog->argv[1] == NULL) {\n+\t/* No arguments,\
    \ we can use the command as-is. */\n+\t*newbuf = NULL;\n+\tdebug_return_str(evlog->command);\n\
    +    }\n+\n+    /* Skip argv[0], we use evlog->command instead. */\n+    for (ac\
    \ = 1; evlog->argv[ac] != NULL; ac++)\n+\tbufsize += strlen(evlog->argv[ac]) +\
    \ 1;\n+\n+    if ((buf = malloc(bufsize)) == NULL)\n+\tsudo_fatalx(U_(\"%s: %s\"\
    ), __func__, U_(\"unable to allocate memory\"));\n+    cp = buf;\n+\n+    len\
    \ = strlcpy(cp, evlog->command, bufsize);\n+    if (len >= bufsize)\n+\tsudo_fatalx(U_(\"\
    internal error, %s overflow\"), __func__);\n+    cp += len;\n+    bufsize -= len;\n\
    +\n+    for (ac = 1; evlog->argv[ac] != NULL; ac++) {\n+\tif (bufsize < 2)\n+\t\
    \    sudo_fatalx(U_(\"internal error, %s overflow\"), __func__);\n+\t*cp++ = '\
    \ ';\n+\tbufsize--;\n+\n+\tlen = strlcpy(cp, evlog->argv[ac], bufsize);\n+\tif\
    \ (len >= bufsize)\n+\t    sudo_fatalx(U_(\"internal error, %s overflow\"), __func__);\n\
    +\tcp += len;\n+\tbufsize -= len;\n+    }\n+\n+    *newbuf = buf;\n+    debug_return_str(buf);\n\
    +}\n+\n static bool\n match_expr(struct search_node_list *head, struct eventlog\
    \ *evlog, bool last_match)\n {\n     struct search_node *sn;\n     bool res =\
    \ false, matched = last_match;\n+    char *tofree;\n     int rc;\n     debug_decl(match_expr,\
    \ SUDO_DEBUG_UTIL);\n \n@@ -1353,13 +1404,15 @@ match_expr(struct search_node_list\
    \ *head, struct eventlog *evlog, bool last_matc\n \t\tres = strcmp(sn->u.user,\
    \ evlog->submituser) == 0;\n \t    break;\n \tcase ST_PATTERN:\n-\t    rc = regexec(&sn->u.cmdre,\
    \ evlog->command, 0, NULL, 0);\n+\t    rc = regexec(&sn->u.cmdre, expand_command(evlog,\
    \ &tofree),\n+\t\t0, NULL, 0);\n \t    if (rc && rc != REG_NOMATCH) {\n \t\tchar\
    \ buf[BUFSIZ];\n \t\tregerror(rc, &sn->u.cmdre, buf, sizeof(buf));\n \t\tsudo_fatalx(\"\
    %s\", buf);\n \t    }\n \t    res = rc == REG_NOMATCH ? 0 : 1;\n+\t    free(tofree);\n\
    \ \t    break;\n \tcase ST_FROMDATE:\n \t    res = sudo_timespeccmp(&evlog->submit_time,\
    \ &sn->u.tstamp, >=);\n@@ -1380,12 +1433,13 @@ match_expr(struct search_node_list\
    \ *head, struct eventlog *evlog, bool last_matc\n }\n \n static int\n-list_session(char\
    \ *log_dir, regex_t *re, const char *user, const char *tty)\n+list_session(struct\
    \ sudo_lbuf *lbuf, char *log_dir, regex_t *re,\n+    const char *user, const char\
    \ *tty)\n {\n     char idbuf[7], *idstr, *cp;\n     struct eventlog *evlog = NULL;\n\
    \     const char *timestr;\n-    int ret = -1;\n+    int i, ret = -1;\n     debug_decl(list_session,\
    \ SUDO_DEBUG_UTIL);\n \n     if ((evlog = iolog_parse_loginfo(-1, log_dir)) ==\
    \ NULL)\n@@ -1417,23 +1471,71 @@ list_session(char *log_dir, regex_t *re, const\
    \ char *user, const char *tty)\n     }\n     /* XXX - print lines + cols? */\n\
    \     timestr = get_timestr(evlog->submit_time.tv_sec, 1);\n-    printf(\"%s :\
    \ %s : \", timestr ? timestr : \"invalid date\", evlog->submituser);\n-    if\
    \ (evlog->submithost != NULL)\n-\tprintf(\"HOST=%s ; \", evlog->submithost);\n\
    -    if (evlog->ttyname != NULL)\n-\tprintf(\"TTY=%s ; \", evlog->ttyname);\n\
    -    if (evlog->runchroot != NULL)\n-\tprintf(\"CHROOT=%s ; \", evlog->runchroot);\n\
    -    if (evlog->runcwd != NULL || evlog->cwd != NULL)\n-\tprintf(\"CWD=%s ; \"\
    , evlog->runcwd ? evlog->runcwd : evlog->cwd);\n-    printf(\"USER=%s ; \", evlog->runuser);\n\
    -    if (evlog->rungroup != NULL)\n-\tprintf(\"GROUP=%s ; \", evlog->rungroup);\n\
    -    printf(\"TSID=%s ; COMMAND=%s\\n\", idstr, evlog->command);\n-\n-    ret\
    \ = 0;\n+    sudo_lbuf_append_esc(lbuf, LBUF_ESC_CNTRL, \"%s : %s : \",\n+\ttimestr\
    \ ? timestr : \"invalid date\", evlog->submituser);\n+    if (evlog->submithost\
    \ != NULL) {\n+\tsudo_lbuf_append_esc(lbuf, LBUF_ESC_CNTRL, \"HOST=%s ; \",\n\
    +\t    evlog->submithost);\n+    }\n+    if (evlog->ttyname != NULL) {\n+\tsudo_lbuf_append_esc(lbuf,\
    \ LBUF_ESC_CNTRL, \"TTY=%s ; \",\n+\t    evlog->ttyname);\n+    }\n+    if (evlog->runchroot\
    \ != NULL) {\n+\tsudo_lbuf_append_esc(lbuf, LBUF_ESC_CNTRL, \"CHROOT=%s ; \",\n\
    +\t    evlog->runchroot);\n+    }\n+    if (evlog->runcwd != NULL || evlog->cwd\
    \ != NULL) {\n+\tsudo_lbuf_append_esc(lbuf, LBUF_ESC_CNTRL, \"CWD=%s ; \",\n+\t\
    \    evlog->runcwd ? evlog->runcwd : evlog->cwd);\n+    }\n+    sudo_lbuf_append_esc(lbuf,\
    \ LBUF_ESC_CNTRL, \"USER=%s ; \", evlog->runuser);\n+    if (evlog->rungroup !=\
    \ NULL) {\n+\tsudo_lbuf_append_esc(lbuf, LBUF_ESC_CNTRL, \"GROUP=%s ; \",\n+\t\
    \    evlog->rungroup);\n+    }\n+    sudo_lbuf_append_esc(lbuf, LBUF_ESC_CNTRL,\
    \ \"TSID=%s ; \", idstr);\n+\n+    /* \n+     * If we have both command and argv\
    \ from info.json we can escape\n+     * blanks in the the command and arguments.\
    \  If all we have is a\n+     * single string containing both the command and\
    \ arguments we cannot.\n+     */\n+    if (evlog->argv != NULL) {\n+\t/* Command\
    \ plus argv from the info.json file. */\n+\tsudo_lbuf_append_esc(lbuf, LBUF_ESC_CNTRL|LBUF_ESC_BLANK,\n\
    +\t    \"COMMAND=%s\", evlog->command);\n+\tif (evlog->argv[0] != NULL) {\n+\t\
    \    for (i = 1; evlog->argv[i] != NULL; i++) {\n+\t\tsudo_lbuf_append(lbuf, \"\
    \ \");\n+\t\tif (strchr(evlog->argv[i], ' ') != NULL) {\n+\t\t    /* Wrap args\
    \ containing spaces in single quotes. */\n+\t\t    sudo_lbuf_append(lbuf, \"'\"\
    );\n+\t\t    sudo_lbuf_append_esc(lbuf, LBUF_ESC_CNTRL|LBUF_ESC_QUOTE,\n+\t\t\t\
    \"%s\", evlog->argv[i]);\n+\t\t    sudo_lbuf_append(lbuf, \"'\");\n+\t\t} else\
    \ {\n+\t\t    /* Escape quotes here too for consistency. */\n+\t\t    sudo_lbuf_append_esc(lbuf,\n\
    +\t\t\tLBUF_ESC_CNTRL|LBUF_ESC_BLANK|LBUF_ESC_QUOTE,\n+\t\t\t\"%s\", evlog->argv[i]);\n\
    +\t\t}\n+\t    }\n+\t}\n+    } else {\n+\t/* Single string from the legacy info\
    \ file. */\n+\tsudo_lbuf_append_esc(lbuf, LBUF_ESC_CNTRL, \"COMMAND=%s\",\n+\t\
    \    evlog->command);\n+    }\n+\n+    if (!sudo_lbuf_error(lbuf)) {\n+\tputs(lbuf->buf);\n\
    +\tret = 0;\n+    }\n \n done:\n+    lbuf->error = 0;\n+    lbuf->len = 0;\n \
    \    eventlog_free(evlog);\n     debug_return_int(ret);\n }\n@@ -1453,6 +1555,7\
    \ @@ find_sessions(const char *dir, regex_t *re, const char *user, const char\
    \ *tty)\n     DIR *d;\n     struct dirent *dp;\n     struct stat sb;\n+    struct\
    \ sudo_lbuf lbuf;\n     size_t sdlen, sessions_len = 0, sessions_size = 0;\n \
    \    unsigned int i;\n     int len;\n@@ -1464,6 +1567,8 @@ find_sessions(const\
    \ char *dir, regex_t *re, const char *user, const char *tty)\n #endif\n     debug_decl(find_sessions,\
    \ SUDO_DEBUG_UTIL);\n \n+    sudo_lbuf_init(&lbuf, NULL, 0, NULL, 0);\n+\n   \
    \  d = opendir(dir);\n     if (d == NULL)\n \tsudo_fatal(U_(\"unable to open %s\"\
    ), dir);\n@@ -1524,7 +1629,7 @@ find_sessions(const char *dir, regex_t *re, const\
    \ char *user, const char *tty)\n \t    /* Check for dir with a log file. */\n\
    \ \t    if (lstat(pathbuf, &sb) == 0 && S_ISREG(sb.st_mode)) {\n \t\tpathbuf[sdlen\
    \ + len - 4] = '\\0';\n-\t\tlist_session(pathbuf, re, user, tty);\n+\t\tlist_session(&lbuf,\
    \ pathbuf, re, user, tty);\n \t    } else {\n \t\t/* Strip off \"/log\" and recurse\
    \ if a non-log dir. */\n \t\tpathbuf[sdlen + len - 4] = '\\0';\n@@ -1535,6 +1640,7\
    \ @@ find_sessions(const char *dir, regex_t *re, const char *user, const char\
    \ *tty)\n \t}\n \tfree(sessions);\n     }\n+    sudo_lbuf_destroy(&lbuf);\n \n\
    \     debug_return_int(0);\n }"
  identifiers:
  - CVE-2023-28486
  - CWE-116
  overview: Sudo before 1.9.13 does not escape control characters in log messages.
  references:
  - source: cve@mitre.org
    tags:
    - Patch
    url: https://github.com/sudo-project/sudo/commit/334daf92b31b79ce68ed75e2ee14fca265f029ca
  - source: cve@mitre.org
    tags:
    - Release Notes
    url: https://github.com/sudo-project/sudo/releases/tag/SUDO_1_9_13
  - source: cve@mitre.org
    url: https://lists.debian.org/debian-lts-announce/2024/02/msg00002.html
  - source: cve@mitre.org
    tags:
    - Third Party Advisory
    url: https://security.gentoo.org/glsa/202309-12
  - source: cve@mitre.org
    tags:
    - Third Party Advisory
    url: https://security.netapp.com/advisory/ntap-20230420-0002/
  title: Sudo before 1.9.13 does not escape control characters in log messages.
- diff_content:
  - "--- a/lib/eventlog/eventlog.c\n+++ b/lib/eventlog/eventlog.c\n@@ -1,7 +1,7 @@\n\
    \ /*\n  * SPDX-License-Identifier: ISC\n  *\n- * Copyright (c) 1994-1996, 1998-2021\
    \ Todd C. Miller <Todd.Miller@sudo.ws>\n+ * Copyright (c) 1994-1996, 1998-2023\
    \ Todd C. Miller <Todd.Miller@sudo.ws>\n  *\n  * Permission to use, copy, modify,\
    \ and distribute this software for any\n  * purpose with or without fee is hereby\
    \ granted, provided that the above\n@@ -51,24 +51,13 @@\n #include \"sudo_compat.h\"\
    \n #include \"sudo_debug.h\"\n #include \"sudo_eventlog.h\"\n+#include \"sudo_lbuf.h\"\
    \n #include \"sudo_fatal.h\"\n #include \"sudo_gettext.h\"\n #include \"sudo_json.h\"\
    \n #include \"sudo_queue.h\"\n #include \"sudo_util.h\"\n \n-#define\tLL_HOST_STR\t\
    \"HOST=\"\n-#define\tLL_TTY_STR\t\"TTY=\"\n-#define\tLL_CHROOT_STR\t\"CHROOT=\"\
    \n-#define\tLL_CWD_STR\t\"PWD=\"\n-#define\tLL_USER_STR\t\"USER=\"\n-#define\t\
    LL_GROUP_STR\t\"GROUP=\"\n-#define\tLL_ENV_STR\t\"ENV=\"\n-#define\tLL_CMND_STR\t\
    \"COMMAND=\"\n-#define\tLL_TSID_STR\t\"TSID=\"\n-#define\tLL_EXIT_STR\t\"EXIT=\"\
    \n-#define\tLL_SIGNAL_STR\t\"SIGNAL=\"\n-\n #define IS_SESSID(s) ( \\\n     isalnum((unsigned\
    \ char)(s)[0]) && isalnum((unsigned char)(s)[1]) && \\\n     (s)[2] == '/' &&\
    \ \\\n@@ -93,26 +82,28 @@ new_logline(int event_type, int flags, struct eventlog_args\
    \ *args,\n     const struct eventlog *evlog)\n {\n     const struct eventlog_config\
    \ *evl_conf = eventlog_getconf();\n-    char *line = NULL, *evstr = NULL;\n  \
    \   const char *iolog_file;\n     const char *tty, *tsid = NULL;\n     char exit_str[(((sizeof(int)\
    \ * 8) + 2) / 3) + 2];\n     char sessid[7], offsetstr[64] = \"\";\n-    size_t\
    \ len = 0;\n+    struct sudo_lbuf lbuf;\n     int i;\n     debug_decl(new_logline,\
    \ SUDO_DEBUG_UTIL);\n \n+    sudo_lbuf_init(&lbuf, NULL, 0, NULL, 0);\n+\n   \
    \  if (ISSET(flags, EVLOG_RAW) || evlog == NULL) {\n \tif (args->reason != NULL)\
    \ {\n \t    if (args->errstr != NULL) {\n-\t\tif (asprintf(&line, \"%s: %s\",\
    \ args->reason, args->errstr) == -1)\n-\t\t    goto oom;\n+\t\tsudo_lbuf_append_esc(&lbuf,\
    \ LBUF_ESC_CNTRL, \"%s: %s\",\n+\t\t    args->reason, args->errstr);\n \t    }\
    \ else {\n-\t\tif ((line = strdup(args->reason)) == NULL)\n-\t\t    goto oom;\n\
    +\t\tsudo_lbuf_append_esc(&lbuf, LBUF_ESC_CNTRL, \"%s\", args->reason);\n \t \
    \   }\n+\t    if (sudo_lbuf_error(&lbuf))\n+\t\tgoto oom;\n \t}\n-\tdebug_return_str(line);\n\
    +\tdebug_return_str(lbuf.buf);\n     }\n \n     /* A TSID may be a sudoers-style\
    \ session ID or a free-form string. */\n@@ -150,169 +141,90 @@ new_logline(int\
    \ event_type, int flags, struct eventlog_args *args,\n     }\n \n     /*\n-  \
    \   * Compute line length\n+     * Format the log line as an lbuf, escaping control\
    \ characters in\n+     * octal form (#0nn).  Error checking (ENOMEM) is done at\
    \ the end.\n      */\n-    if (args->reason != NULL)\n-\tlen += strlen(args->reason)\
    \ + 3;\n-    if (args->errstr != NULL)\n-\tlen += strlen(args->errstr) + 3;\n\
    -    if (evlog->submithost != NULL && !evl_conf->omit_hostname)\n-\tlen += sizeof(LL_HOST_STR)\
    \ + 2 + strlen(evlog->submithost);\n-    if (tty != NULL)\n-\tlen += sizeof(LL_TTY_STR)\
    \ + 2 + strlen(tty);\n-    if (evlog->runchroot != NULL)\n-\tlen += sizeof(LL_CHROOT_STR)\
    \ + 2 + strlen(evlog->runchroot);\n-    if (evlog->runcwd != NULL)\n-\tlen +=\
    \ sizeof(LL_CWD_STR) + 2 + strlen(evlog->runcwd);\n-    if (evlog->runuser !=\
    \ NULL)\n-\tlen += sizeof(LL_USER_STR) + 2 + strlen(evlog->runuser);\n-    if\
    \ (evlog->rungroup != NULL)\n-\tlen += sizeof(LL_GROUP_STR) + 2 + strlen(evlog->rungroup);\n\
    -    if (tsid != NULL) {\n-\tlen += sizeof(LL_TSID_STR) + 2 + strlen(tsid) + strlen(offsetstr);\n\
    -    }\n-    if (evlog->env_add != NULL) {\n-\tsize_t evlen = 0;\n-\tchar * const\
    \ *ep;\n-\n-\tfor (ep = evlog->env_add; *ep != NULL; ep++)\n-\t    evlen += strlen(*ep)\
    \ + 1;\n-\tif (evlen != 0) {\n-\t    if ((evstr = malloc(evlen)) == NULL)\n-\t\
    \tgoto oom;\n-\t    ep = evlog->env_add;\n-\t    if (strlcpy(evstr, *ep, evlen)\
    \ >= evlen)\n-\t\tgoto toobig;\n-\t    while (*++ep != NULL) {\n-\t\tif (strlcat(evstr,\
    \ \" \", evlen) >= evlen ||\n-\t\t    strlcat(evstr, *ep, evlen) >= evlen)\n-\t\
    \t    goto toobig;\n-\t    }\n-\t    len += sizeof(LL_ENV_STR) + 2 + evlen;\n\
    -\t}\n-    }\n-    if (evlog->command != NULL) {\n-\tlen += sizeof(LL_CMND_STR)\
    \ - 1 + strlen(evlog->command);\n-\tif (evlog->argv != NULL && evlog->argv[0]\
    \ != NULL) {\n-\t    for (i = 1; evlog->argv[i] != NULL; i++)\n-\t\tlen += strlen(evlog->argv[i])\
    \ + 1;\n-\t}\n-\tif (event_type == EVLOG_EXIT) {\n-\t    if (evlog->signal_name\
    \ != NULL)\n-\t\tlen += sizeof(LL_SIGNAL_STR) + 2 + strlen(evlog->signal_name);\n\
    -\t    if (evlog->exit_value != -1) {\n-\t\t(void)snprintf(exit_str, sizeof(exit_str),\
    \ \"%d\", evlog->exit_value);\n-\t\tlen += sizeof(LL_EXIT_STR) + 2 + strlen(exit_str);\n\
    -\t    }\n-\t}\n-    }\n-\n-    /*\n-     * Allocate and build up the line.\n\
    -     */\n-    if ((line = malloc(++len)) == NULL)\n-\tgoto oom;\n-    line[0]\
    \ = '\\0';\n-\n     if (args->reason != NULL) {\n-\tif (strlcat(line, args->reason,\
    \ len) >= len ||\n-\t    strlcat(line, args->errstr ? \" : \" : \" ; \", len)\
    \ >= len)\n-\t    goto toobig;\n+\tsudo_lbuf_append_esc(&lbuf, LBUF_ESC_CNTRL,\
    \ \"%s%s\", args->reason,\n+\t    args->errstr ? \" : \" : \" ; \");\n     }\n\
    \     if (args->errstr != NULL) {\n-\tif (strlcat(line, args->errstr, len) >=\
    \ len ||\n-\t    strlcat(line, \" ; \", len) >= len)\n-\t    goto toobig;\n+\t\
    sudo_lbuf_append_esc(&lbuf, LBUF_ESC_CNTRL, \"%s ; \", args->errstr);\n     }\n\
    \     if (evlog->submithost != NULL && !evl_conf->omit_hostname) {\n-\tif (strlcat(line,\
    \ LL_HOST_STR, len) >= len ||\n-\t    strlcat(line, evlog->submithost, len) >=\
    \ len ||\n-\t    strlcat(line, \" ; \", len) >= len)\n-\t    goto toobig;\n+\t\
    sudo_lbuf_append_esc(&lbuf, LBUF_ESC_CNTRL, \"HOST=%s ; \",\n+\t    evlog->submithost);\n\
    \     }\n     if (tty != NULL) {\n-\tif (strlcat(line, LL_TTY_STR, len) >= len\
    \ ||\n-\t    strlcat(line, tty, len) >= len ||\n-\t    strlcat(line, \" ; \",\
    \ len) >= len)\n-\t    goto toobig;\n+\tsudo_lbuf_append_esc(&lbuf, LBUF_ESC_CNTRL,\
    \ \"TTY=%s ; \", tty);\n     }\n     if (evlog->runchroot != NULL) {\n-\tif (strlcat(line,\
    \ LL_CHROOT_STR, len) >= len ||\n-\t    strlcat(line, evlog->runchroot, len) >=\
    \ len ||\n-\t    strlcat(line, \" ; \", len) >= len)\n-\t    goto toobig;\n+\t\
    sudo_lbuf_append_esc(&lbuf, LBUF_ESC_CNTRL, \"CHROOT=%s ; \",\n+\t    evlog->runchroot);\n\
    \     }\n     if (evlog->runcwd != NULL) {\n-\tif (strlcat(line, LL_CWD_STR, len)\
    \ >= len ||\n-\t    strlcat(line, evlog->runcwd, len) >= len ||\n-\t    strlcat(line,\
    \ \" ; \", len) >= len)\n-\t    goto toobig;\n+\tsudo_lbuf_append_esc(&lbuf, LBUF_ESC_CNTRL,\
    \ \"PWD=%s ; \",\n+\t    evlog->runcwd);\n     }\n     if (evlog->runuser != NULL)\
    \ {\n-\tif (strlcat(line, LL_USER_STR, len) >= len ||\n-\t    strlcat(line, evlog->runuser,\
    \ len) >= len ||\n-\t    strlcat(line, \" ; \", len) >= len)\n-\t    goto toobig;\n\
    +\tsudo_lbuf_append_esc(&lbuf, LBUF_ESC_CNTRL, \"USER=%s ; \",\n+\t    evlog->runuser);\n\
    \     }\n     if (evlog->rungroup != NULL) {\n-\tif (strlcat(line, LL_GROUP_STR,\
    \ len) >= len ||\n-\t    strlcat(line, evlog->rungroup, len) >= len ||\n-\t  \
    \  strlcat(line, \" ; \", len) >= len)\n-\t    goto toobig;\n+\tsudo_lbuf_append_esc(&lbuf,\
    \ LBUF_ESC_CNTRL, \"GROUP=%s ; \",\n+\t    evlog->rungroup);\n     }\n     if\
    \ (tsid != NULL) {\n-\tif (strlcat(line, LL_TSID_STR, len) >= len ||\n-\t    strlcat(line,\
    \ tsid, len) >= len ||\n-\t    strlcat(line, offsetstr, len) >= len ||\n-\t  \
    \  strlcat(line, \" ; \", len) >= len)\n-\t    goto toobig;\n-    }\n-    if (evstr\
    \ != NULL) {\n-\tif (strlcat(line, LL_ENV_STR, len) >= len ||\n-\t    strlcat(line,\
    \ evstr, len) >= len ||\n-\t    strlcat(line, \" ; \", len) >= len)\n-\t    goto\
    \ toobig;\n-\tfree(evstr);\n-\tevstr = NULL;\n+\tsudo_lbuf_append_esc(&lbuf, LBUF_ESC_CNTRL,\
    \ \"TSID=%s%s ; \", tsid,\n+\t    offsetstr);\n+    }\n+    if (evlog->env_add\
    \ != NULL && evlog->env_add[0] != NULL) {\n+\tsudo_lbuf_append_esc(&lbuf, LBUF_ESC_CNTRL,\
    \ \"ENV=%s\",\n+\t    evlog->env_add[0]);\n+\tfor (i = 1; evlog->env_add[i] !=\
    \ NULL; i++) {\n+\t    sudo_lbuf_append_esc(&lbuf, LBUF_ESC_CNTRL, \" %s\",\n\
    +\t\tevlog->env_add[i]);\n+\t}\n     }\n     if (evlog->command != NULL) {\n-\t\
    if (strlcat(line, LL_CMND_STR, len) >= len)\n-\t    goto toobig;\n-\tif (strlcat(line,\
    \ evlog->command, len) >= len)\n-\t    goto toobig;\n+\tsudo_lbuf_append_esc(&lbuf,\
    \ LBUF_ESC_CNTRL|LBUF_ESC_BLANK,\n+\t    \"COMMAND=%s\", evlog->command);\n \t\
    if (evlog->argv != NULL && evlog->argv[0] != NULL) {\n \t    for (i = 1; evlog->argv[i]\
    \ != NULL; i++) {\n-\t\tif (strlcat(line, \" \", len) >= len ||\n-\t\t    strlcat(line,\
    \ evlog->argv[i], len) >= len)\n-\t\t    goto toobig;\n+\t\tsudo_lbuf_append(&lbuf,\
    \ \" \");\n+\t\tif (strchr(evlog->argv[i], ' ') != NULL) {\n+\t\t    /* Wrap args\
    \ containing spaces in single quotes. */\n+\t\t    sudo_lbuf_append(&lbuf, \"\
    '\");\n+\t\t    sudo_lbuf_append_esc(&lbuf, LBUF_ESC_CNTRL|LBUF_ESC_QUOTE,\n+\t\
    \t\t\"%s\", evlog->argv[i]);\n+\t\t    sudo_lbuf_append(&lbuf, \"'\");\n+\t\t\
    } else {\n+\t\t    /* Escape quotes here too for consistency. */\n+\t\t    sudo_lbuf_append_esc(&lbuf,\n\
    +\t\t\tLBUF_ESC_CNTRL|LBUF_ESC_BLANK|LBUF_ESC_QUOTE,\n+\t\t\t\"%s\", evlog->argv[i]);\n\
    +\t\t}\n \t    }\n \t}\n \tif (event_type == EVLOG_EXIT) {\n \t    if (evlog->signal_name\
    \ != NULL) {\n-\t\tif (strlcat(line, \" ; \", len) >= len ||\n-\t\t    strlcat(line,\
    \ LL_SIGNAL_STR, len) >= len ||\n-\t\t    strlcat(line, evlog->signal_name, len)\
    \ >= len)\n-\t\t    goto toobig;\n+\t\tsudo_lbuf_append_esc(&lbuf, LBUF_ESC_CNTRL,\
    \ \" ; SIGNAL=%s\",\n+\t\t    evlog->signal_name);\n \t    }\n \t    if (evlog->exit_value\
    \ != -1) {\n-\t\tif (strlcat(line, \" ; \", len) >= len ||\n-\t\t    strlcat(line,\
    \ LL_EXIT_STR, len) >= len ||\n-\t\t    strlcat(line, exit_str, len) >= len)\n\
    -\t\t    goto toobig;\n+\t\t(void)snprintf(exit_str, sizeof(exit_str), \"%d\"\
    ,\n+\t\t    evlog->exit_value);\n+\t\tsudo_lbuf_append_esc(&lbuf, LBUF_ESC_CNTRL,\
    \ \" ; EXIT=%s\",\n+\t\t    exit_str);\n \t    }\n \t}\n     }\n-\n-    debug_return_str(line);\n\
    +    if (!sudo_lbuf_error(&lbuf))\n+\tdebug_return_str(lbuf.buf);\n oom:\n-  \
    \  free(evstr);\n+    sudo_lbuf_destroy(&lbuf);\n     sudo_warnx(U_(\"%s: %s\"\
    ), __func__, U_(\"unable to allocate memory\"));\n     debug_return_str(NULL);\n\
    -toobig:\n-    free(evstr);\n-    free(line);\n-    sudo_warnx(U_(\"internal error,\
    \ %s overflow\"), __func__);\n-    debug_return_str(NULL);\n }\n \n static void"
  - "--- a/lib/iolog/iolog_json.c\n+++ b/lib/iolog/iolog_json.c\n@@ -551,45 +551,6\
    \ @@ iolog_parse_json_object(struct json_object *object, struct eventlog *evlog)\n\
    \ \t}\n     }\n \n-    /* Merge cmd and argv as sudoreplay expects. */\n-    if\
    \ (evlog->command != NULL && evlog->argv != NULL && evlog->argv[0] != NULL) {\n\
    -\tsize_t len, bufsize = strlen(evlog->command) + 1;\n-\tchar *cp, *buf;\n-\t\
    int ac;\n-\n-\t/* Skip argv[0], we use evlog->command instead. */\n-\tfor (ac\
    \ = 1; evlog->argv[ac] != NULL; ac++)\n-\t    bufsize += strlen(evlog->argv[ac])\
    \ + 1;\n-\n-\tif ((buf = malloc(bufsize)) == NULL) {\n-\t    sudo_warnx(U_(\"\
    %s: %s\"), __func__, U_(\"unable to allocate memory\"));\n-\t    goto done;\n\
    -\t}\n-\tcp = buf;\n-\n-\tlen = strlcpy(cp, evlog->command, bufsize);\n-\tif (len\
    \ >= bufsize)\n-\t    sudo_fatalx(U_(\"internal error, %s overflow\"), __func__);\n\
    -\tcp += len;\n-\tbufsize -= len;\n-\n-\tfor (ac = 1; evlog->argv[ac] != NULL;\
    \ ac++) {\n-\t    if (bufsize < 2)\n-\t\tsudo_fatalx(U_(\"internal error, %s overflow\"\
    ), __func__);\n-\t    *cp++ = ' ';\n-\t    bufsize--;\n-\n-\t    len = strlcpy(cp,\
    \ evlog->argv[ac], bufsize);\n-\t    if (len >= bufsize)\n-\t\tsudo_fatalx(U_(\"\
    internal error, %s overflow\"), __func__);\n-\t    cp += len;\n-\t    bufsize\
    \ -= len;\n-\t}\n-\n-\tfree(evlog->command);\n-\tevlog->command = buf;\n-    }\n\
    -\n     ret = true;\n \n done:"
  - "--- a/lib/util/lbuf.c\n+++ b/lib/util/lbuf.c\n@@ -94,6 +94,112 @@ sudo_lbuf_expand(struct\
    \ sudo_lbuf *lbuf, unsigned int extra)\n     debug_return_bool(true);\n }\n \n\
    +/*\n+ * Escape a character in octal form (#0n) and store it as a string\n+ *\
    \ in buf, which must have at least 6 bytes available.\n+ * Returns the length\
    \ of buf, not counting the terminating NUL byte.\n+ */\n+static int\n+escape(unsigned\
    \ char ch, char *buf)\n+{\n+    const int len = ch < 0100 ? (ch < 010 ? 3 : 4)\
    \ : 5;\n+\n+    /* Work backwards from the least significant digit to most significant.\
    \ */\n+    switch (len) {\n+    case 5:\n+\tbuf[4] = (ch & 7) + '0';\n+\tch >>=\
    \ 3;\n+\tFALLTHROUGH;\n+    case 4:\n+\tbuf[3] = (ch & 7) + '0';\n+\tch >>= 3;\n\
    +\tFALLTHROUGH;\n+    case 3:\n+\tbuf[2] = (ch & 7) + '0';\n+\tbuf[1] = '0';\n\
    +\tbuf[0] = '#';\n+\tbreak;\n+    }\n+    buf[len] = '\\0';\n+\n+    return len;\n\
    +}\n+\n+/*\n+ * Parse the format and append strings, only %s and %% escapes are\
    \ supported.\n+ * Any non-printable characters are escaped in octal as #0nn.\n\
    + */\n+bool\n+sudo_lbuf_append_esc_v1(struct sudo_lbuf *lbuf, int flags, const\
    \ char *fmt, ...)\n+{\n+    unsigned int saved_len = lbuf->len;\n+    bool ret\
    \ = false;\n+    const char *s;\n+    va_list ap;\n+    debug_decl(sudo_lbuf_append_esc,\
    \ SUDO_DEBUG_UTIL);\n+\n+    if (sudo_lbuf_error(lbuf))\n+\tdebug_return_bool(false);\n\
    +\n+#define should_escape(ch) \\\n+    ((ISSET(flags, LBUF_ESC_CNTRL) && iscntrl((unsigned\
    \ char)ch)) || \\\n+    (ISSET(flags, LBUF_ESC_BLANK) && isblank((unsigned char)ch)))\n\
    +#define should_quote(ch) \\\n+    (ISSET(flags, LBUF_ESC_QUOTE) && (ch == '\\\
    '' || ch == '\\\\'))\n+\n+    va_start(ap, fmt);\n+    while (*fmt != '\\0') {\n\
    +\tif (fmt[0] == '%' && fmt[1] == 's') {\n+\t    if ((s = va_arg(ap, char *))\
    \ == NULL)\n+\t\ts = \"(NULL)\";\n+\t    while (*s != '\\0') {\n+\t\tif (should_escape(*s))\
    \ {\n+\t\t    if (!sudo_lbuf_expand(lbuf, sizeof(\"#0177\") - 1))\n+\t\t\tgoto\
    \ done;\n+\t\t    lbuf->len += escape(*s++, lbuf->buf + lbuf->len);\n+\t\t   \
    \ continue;\n+\t\t}\n+\t\tif (should_quote(*s)) {\n+\t\t    if (!sudo_lbuf_expand(lbuf,\
    \ 2))\n+\t\t\tgoto done;\n+\t\t    lbuf->buf[lbuf->len++] = '\\\\';\n+\t\t   \
    \ lbuf->buf[lbuf->len++] = *s++;\n+\t\t    continue;\n+\t\t}\n+\t\tif (!sudo_lbuf_expand(lbuf,\
    \ 1))\n+\t\t    goto done;\n+\t\tlbuf->buf[lbuf->len++] = *s++;\n+\t    }\n+\t\
    \    fmt += 2;\n+\t    continue;\n+\t}\n+\tif (should_escape(*fmt)) {\n+\t   \
    \ if (!sudo_lbuf_expand(lbuf, sizeof(\"#0177\") - 1))\n+\t\tgoto done;\n+\t  \
    \  if (*fmt == '\\'') {\n+\t\tlbuf->buf[lbuf->len++] = '\\\\';\n+\t\tlbuf->buf[lbuf->len++]\
    \ = *fmt++;\n+\t    } else {\n+\t\tlbuf->len += escape(*fmt++, lbuf->buf + lbuf->len);\n\
    +\t    }\n+\t    continue;\n+\t}\n+\tif (!sudo_lbuf_expand(lbuf, 1))\n+\t    goto\
    \ done;\n+\tlbuf->buf[lbuf->len++] = *fmt++;\n+    }\n+    ret = true;\n+\n+done:\n\
    +    if (!ret)\n+\tlbuf->len = saved_len;\n+    if (lbuf->size != 0)\n+\tlbuf->buf[lbuf->len]\
    \ = '\\0';\n+    va_end(ap);\n+\n+    debug_return_bool(ret);\n+}\n+\n /*\n  *\
    \ Parse the format and append strings, only %s and %% escapes are supported.\n\
    \  * Any characters in set are quoted with a backslash."
  - "--- a/plugins/sudoers/sudoreplay.c\n+++ b/plugins/sudoers/sudoreplay.c\n@@ -62,6\
    \ +62,7 @@\n #include \"sudo_debug.h\"\n #include \"sudo_event.h\"\n #include\
    \ \"sudo_eventlog.h\"\n+#include \"sudo_lbuf.h\"\n #include \"sudo_fatal.h\"\n\
    \ #include \"sudo_gettext.h\"\n #include \"sudo_iolog.h\"\n@@ -373,6 +374,10 @@\
    \ main(int argc, char *argv[])\n     if ((evlog = iolog_parse_loginfo(iolog_dir_fd,\
    \ iolog_dir)) == NULL)\n \tgoto done;\n     printf(_(\"Replaying sudo session:\
    \ %s\"), evlog->command);\n+    if (evlog->argv != NULL && evlog->argv[0] != NULL)\
    \ {\n+\tfor (i = 1; evlog->argv[i] != NULL; i++)\n+\t    printf(\" %s\", evlog->argv[i]);\n\
    +    }\n \n     /* Setup terminal if appropriate. */\n     if (!isatty(STDIN_FILENO)\
    \ || !isatty(STDOUT_FILENO))\n@@ -1315,11 +1320,57 @@ parse_expr(struct search_node_list\
    \ *head, char *argv[], bool sub_expr)\n     debug_return_int(av - argv);\n }\n\
    \ \n+static char *\n+expand_command(struct eventlog *evlog, char **newbuf)\n+{\n\
    +    size_t len, bufsize = strlen(evlog->command) + 1;\n+    char *cp, *buf;\n\
    +    int ac;\n+    debug_decl(expand_command, SUDO_DEBUG_UTIL);\n+\n+    if (evlog->argv\
    \ == NULL || evlog->argv[0] == NULL || evlog->argv[1] == NULL) {\n+\t/* No arguments,\
    \ we can use the command as-is. */\n+\t*newbuf = NULL;\n+\tdebug_return_str(evlog->command);\n\
    +    }\n+\n+    /* Skip argv[0], we use evlog->command instead. */\n+    for (ac\
    \ = 1; evlog->argv[ac] != NULL; ac++)\n+\tbufsize += strlen(evlog->argv[ac]) +\
    \ 1;\n+\n+    if ((buf = malloc(bufsize)) == NULL)\n+\tsudo_fatalx(U_(\"%s: %s\"\
    ), __func__, U_(\"unable to allocate memory\"));\n+    cp = buf;\n+\n+    len\
    \ = strlcpy(cp, evlog->command, bufsize);\n+    if (len >= bufsize)\n+\tsudo_fatalx(U_(\"\
    internal error, %s overflow\"), __func__);\n+    cp += len;\n+    bufsize -= len;\n\
    +\n+    for (ac = 1; evlog->argv[ac] != NULL; ac++) {\n+\tif (bufsize < 2)\n+\t\
    \    sudo_fatalx(U_(\"internal error, %s overflow\"), __func__);\n+\t*cp++ = '\
    \ ';\n+\tbufsize--;\n+\n+\tlen = strlcpy(cp, evlog->argv[ac], bufsize);\n+\tif\
    \ (len >= bufsize)\n+\t    sudo_fatalx(U_(\"internal error, %s overflow\"), __func__);\n\
    +\tcp += len;\n+\tbufsize -= len;\n+    }\n+\n+    *newbuf = buf;\n+    debug_return_str(buf);\n\
    +}\n+\n static bool\n match_expr(struct search_node_list *head, struct eventlog\
    \ *evlog, bool last_match)\n {\n     struct search_node *sn;\n     bool res =\
    \ false, matched = last_match;\n+    char *tofree;\n     int rc;\n     debug_decl(match_expr,\
    \ SUDO_DEBUG_UTIL);\n \n@@ -1353,13 +1404,15 @@ match_expr(struct search_node_list\
    \ *head, struct eventlog *evlog, bool last_matc\n \t\tres = strcmp(sn->u.user,\
    \ evlog->submituser) == 0;\n \t    break;\n \tcase ST_PATTERN:\n-\t    rc = regexec(&sn->u.cmdre,\
    \ evlog->command, 0, NULL, 0);\n+\t    rc = regexec(&sn->u.cmdre, expand_command(evlog,\
    \ &tofree),\n+\t\t0, NULL, 0);\n \t    if (rc && rc != REG_NOMATCH) {\n \t\tchar\
    \ buf[BUFSIZ];\n \t\tregerror(rc, &sn->u.cmdre, buf, sizeof(buf));\n \t\tsudo_fatalx(\"\
    %s\", buf);\n \t    }\n \t    res = rc == REG_NOMATCH ? 0 : 1;\n+\t    free(tofree);\n\
    \ \t    break;\n \tcase ST_FROMDATE:\n \t    res = sudo_timespeccmp(&evlog->submit_time,\
    \ &sn->u.tstamp, >=);\n@@ -1380,12 +1433,13 @@ match_expr(struct search_node_list\
    \ *head, struct eventlog *evlog, bool last_matc\n }\n \n static int\n-list_session(char\
    \ *log_dir, regex_t *re, const char *user, const char *tty)\n+list_session(struct\
    \ sudo_lbuf *lbuf, char *log_dir, regex_t *re,\n+    const char *user, const char\
    \ *tty)\n {\n     char idbuf[7], *idstr, *cp;\n     struct eventlog *evlog = NULL;\n\
    \     const char *timestr;\n-    int ret = -1;\n+    int i, ret = -1;\n     debug_decl(list_session,\
    \ SUDO_DEBUG_UTIL);\n \n     if ((evlog = iolog_parse_loginfo(-1, log_dir)) ==\
    \ NULL)\n@@ -1417,23 +1471,71 @@ list_session(char *log_dir, regex_t *re, const\
    \ char *user, const char *tty)\n     }\n     /* XXX - print lines + cols? */\n\
    \     timestr = get_timestr(evlog->submit_time.tv_sec, 1);\n-    printf(\"%s :\
    \ %s : \", timestr ? timestr : \"invalid date\", evlog->submituser);\n-    if\
    \ (evlog->submithost != NULL)\n-\tprintf(\"HOST=%s ; \", evlog->submithost);\n\
    -    if (evlog->ttyname != NULL)\n-\tprintf(\"TTY=%s ; \", evlog->ttyname);\n\
    -    if (evlog->runchroot != NULL)\n-\tprintf(\"CHROOT=%s ; \", evlog->runchroot);\n\
    -    if (evlog->runcwd != NULL || evlog->cwd != NULL)\n-\tprintf(\"CWD=%s ; \"\
    , evlog->runcwd ? evlog->runcwd : evlog->cwd);\n-    printf(\"USER=%s ; \", evlog->runuser);\n\
    -    if (evlog->rungroup != NULL)\n-\tprintf(\"GROUP=%s ; \", evlog->rungroup);\n\
    -    printf(\"TSID=%s ; COMMAND=%s\\n\", idstr, evlog->command);\n-\n-    ret\
    \ = 0;\n+    sudo_lbuf_append_esc(lbuf, LBUF_ESC_CNTRL, \"%s : %s : \",\n+\ttimestr\
    \ ? timestr : \"invalid date\", evlog->submituser);\n+    if (evlog->submithost\
    \ != NULL) {\n+\tsudo_lbuf_append_esc(lbuf, LBUF_ESC_CNTRL, \"HOST=%s ; \",\n\
    +\t    evlog->submithost);\n+    }\n+    if (evlog->ttyname != NULL) {\n+\tsudo_lbuf_append_esc(lbuf,\
    \ LBUF_ESC_CNTRL, \"TTY=%s ; \",\n+\t    evlog->ttyname);\n+    }\n+    if (evlog->runchroot\
    \ != NULL) {\n+\tsudo_lbuf_append_esc(lbuf, LBUF_ESC_CNTRL, \"CHROOT=%s ; \",\n\
    +\t    evlog->runchroot);\n+    }\n+    if (evlog->runcwd != NULL || evlog->cwd\
    \ != NULL) {\n+\tsudo_lbuf_append_esc(lbuf, LBUF_ESC_CNTRL, \"CWD=%s ; \",\n+\t\
    \    evlog->runcwd ? evlog->runcwd : evlog->cwd);\n+    }\n+    sudo_lbuf_append_esc(lbuf,\
    \ LBUF_ESC_CNTRL, \"USER=%s ; \", evlog->runuser);\n+    if (evlog->rungroup !=\
    \ NULL) {\n+\tsudo_lbuf_append_esc(lbuf, LBUF_ESC_CNTRL, \"GROUP=%s ; \",\n+\t\
    \    evlog->rungroup);\n+    }\n+    sudo_lbuf_append_esc(lbuf, LBUF_ESC_CNTRL,\
    \ \"TSID=%s ; \", idstr);\n+\n+    /* \n+     * If we have both command and argv\
    \ from info.json we can escape\n+     * blanks in the the command and arguments.\
    \  If all we have is a\n+     * single string containing both the command and\
    \ arguments we cannot.\n+     */\n+    if (evlog->argv != NULL) {\n+\t/* Command\
    \ plus argv from the info.json file. */\n+\tsudo_lbuf_append_esc(lbuf, LBUF_ESC_CNTRL|LBUF_ESC_BLANK,\n\
    +\t    \"COMMAND=%s\", evlog->command);\n+\tif (evlog->argv[0] != NULL) {\n+\t\
    \    for (i = 1; evlog->argv[i] != NULL; i++) {\n+\t\tsudo_lbuf_append(lbuf, \"\
    \ \");\n+\t\tif (strchr(evlog->argv[i], ' ') != NULL) {\n+\t\t    /* Wrap args\
    \ containing spaces in single quotes. */\n+\t\t    sudo_lbuf_append(lbuf, \"'\"\
    );\n+\t\t    sudo_lbuf_append_esc(lbuf, LBUF_ESC_CNTRL|LBUF_ESC_QUOTE,\n+\t\t\t\
    \"%s\", evlog->argv[i]);\n+\t\t    sudo_lbuf_append(lbuf, \"'\");\n+\t\t} else\
    \ {\n+\t\t    /* Escape quotes here too for consistency. */\n+\t\t    sudo_lbuf_append_esc(lbuf,\n\
    +\t\t\tLBUF_ESC_CNTRL|LBUF_ESC_BLANK|LBUF_ESC_QUOTE,\n+\t\t\t\"%s\", evlog->argv[i]);\n\
    +\t\t}\n+\t    }\n+\t}\n+    } else {\n+\t/* Single string from the legacy info\
    \ file. */\n+\tsudo_lbuf_append_esc(lbuf, LBUF_ESC_CNTRL, \"COMMAND=%s\",\n+\t\
    \    evlog->command);\n+    }\n+\n+    if (!sudo_lbuf_error(lbuf)) {\n+\tputs(lbuf->buf);\n\
    +\tret = 0;\n+    }\n \n done:\n+    lbuf->error = 0;\n+    lbuf->len = 0;\n \
    \    eventlog_free(evlog);\n     debug_return_int(ret);\n }\n@@ -1453,6 +1555,7\
    \ @@ find_sessions(const char *dir, regex_t *re, const char *user, const char\
    \ *tty)\n     DIR *d;\n     struct dirent *dp;\n     struct stat sb;\n+    struct\
    \ sudo_lbuf lbuf;\n     size_t sdlen, sessions_len = 0, sessions_size = 0;\n \
    \    unsigned int i;\n     int len;\n@@ -1464,6 +1567,8 @@ find_sessions(const\
    \ char *dir, regex_t *re, const char *user, const char *tty)\n #endif\n     debug_decl(find_sessions,\
    \ SUDO_DEBUG_UTIL);\n \n+    sudo_lbuf_init(&lbuf, NULL, 0, NULL, 0);\n+\n   \
    \  d = opendir(dir);\n     if (d == NULL)\n \tsudo_fatal(U_(\"unable to open %s\"\
    ), dir);\n@@ -1524,7 +1629,7 @@ find_sessions(const char *dir, regex_t *re, const\
    \ char *user, const char *tty)\n \t    /* Check for dir with a log file. */\n\
    \ \t    if (lstat(pathbuf, &sb) == 0 && S_ISREG(sb.st_mode)) {\n \t\tpathbuf[sdlen\
    \ + len - 4] = '\\0';\n-\t\tlist_session(pathbuf, re, user, tty);\n+\t\tlist_session(&lbuf,\
    \ pathbuf, re, user, tty);\n \t    } else {\n \t\t/* Strip off \"/log\" and recurse\
    \ if a non-log dir. */\n \t\tpathbuf[sdlen + len - 4] = '\\0';\n@@ -1535,6 +1640,7\
    \ @@ find_sessions(const char *dir, regex_t *re, const char *user, const char\
    \ *tty)\n \t}\n \tfree(sessions);\n     }\n+    sudo_lbuf_destroy(&lbuf);\n \n\
    \     debug_return_int(0);\n }"
  identifiers:
  - CVE-2023-28487
  - CWE-116
  overview: Sudo before 1.9.13 does not escape control characters in sudoreplay output.
  references:
  - source: cve@mitre.org
    tags:
    - Patch
    url: https://github.com/sudo-project/sudo/commit/334daf92b31b79ce68ed75e2ee14fca265f029ca
  - source: cve@mitre.org
    tags:
    - Release Notes
    url: https://github.com/sudo-project/sudo/releases/tag/SUDO_1_9_13
  - source: cve@mitre.org
    url: https://lists.debian.org/debian-lts-announce/2024/02/msg00002.html
  - source: cve@mitre.org
    tags:
    - Third Party Advisory
    url: https://security.gentoo.org/glsa/202309-12
  - source: cve@mitre.org
    tags:
    - Third Party Advisory
    url: https://security.netapp.com/advisory/ntap-20230420-0002/
  title: Sudo before 1.9.13 does not escape control characters in sudoreplay output.
- diff_content:
  - "--- a/common/flatpak-run.c\n+++ b/common/flatpak-run.c\n@@ -3220,6 +3220,10 @@\
    \ setup_seccomp (FlatpakBwrap   *bwrap,\n \n     /* Don't allow faking input to\
    \ the controlling tty (CVE-2017-5226) */\n     {SCMP_SYS (ioctl), EPERM, &SCMP_A1\
    \ (SCMP_CMP_MASKED_EQ, 0xFFFFFFFFu, (int) TIOCSTI)},\n+    /* In the unlikely\
    \ event that the controlling tty is a Linux virtual\n+     * console (/dev/tty2\
    \ or similar), copy/paste operations have an effect\n+     * similar to TIOCSTI\
    \ (CVE-2023-28100) */\n+    {SCMP_SYS (ioctl), EPERM, &SCMP_A1 (SCMP_CMP_MASKED_EQ,\
    \ 0xFFFFFFFFu, (int) TIOCLINUX)},\n \n     /* seccomp can't look into clone3()'s\
    \ struct clone_args to check whether\n      * the flags are OK, so we have no\
    \ choice but to block clone3()."
  - "--- a/tests/try-syscall.c\n+++ b/tests/try-syscall.c\n@@ -151,6 +151,15 @@ main\
    \ (int argc, char **argv)\n             }\n         }\n #endif\n+      else if\
    \ (strcmp (arg, \"ioctl TIOCLINUX\") == 0)\n+        {\n+          /* If not blocked\
    \ by seccomp, this will fail with EBADF */\n+          if (ioctl (-1, TIOCLINUX,\
    \ WRONG_POINTER) != 0)\n+            {\n+              errsv = errno;\n+     \
    \         perror (arg);\n+            }\n+        }\n      else if (strcmp (arg,\
    \ \"listen\") == 0)\n         {\n           /* If not blocked by seccomp, this\
    \ will fail with EBADF */"
  identifiers:
  - CVE-2023-28100
  - NVD-CWE-noinfo
  overview: Flatpak is a system for building, distributing, and running sandboxed
    desktop applications on Linux. Versions prior to 1.10.8, 1.12.8, 1.14.4, and 1.15.4
    contain a vulnerability similar to CVE-2017-5226, but using the `TIOCLINUX` ioctl
    command instead of `TIOCSTI`. If a Flatpak app is run on a Linux virtual console
    such as `/dev/tty1`, it can copy text from the virtual console and paste it into
    the command buffer, from which the command might be run after the Flatpak app
    has exited. Ordinary graphical terminal emulators like xterm, gnome-terminal and
    Konsole are unaffected. This vulnerability is specific to the Linux virtual consoles
    `/dev/tty1`, `/dev/tty2` and so on. A patch is available in versions 1.10.8, 1.12.8,
    1.14.4, and 1.15.4. As a workaround, don't run Flatpak on a Linux virtual console.
    Flatpak is primarily designed to be used in a Wayland or X11 graphical environment.
  references:
  - source: security-advisories@github.com
    tags:
    - Patch
    url: https://github.com/flatpak/flatpak/commit/8e63de9a7d3124f91140fc74f8ca9ed73ed53be9
  - source: security-advisories@github.com
    tags:
    - Patch
    - Vendor Advisory
    url: https://github.com/flatpak/flatpak/security/advisories/GHSA-7qpw-3vjv-xrqp
  - source: security-advisories@github.com
    tags:
    - Mailing List
    url: https://marc.info/?l=oss-security&m=167879021709955&w=2
  - source: security-advisories@github.com
    url: https://security.gentoo.org/glsa/202312-12
  title: Flatpak is a system for building, distributing, and running sandboxed desktop
    applications on Linux. Versions prior to 1.10.8, 1.12.8, 1.14.4, and 1.15.4 contain
    a vulnerability similar to CVE-2017-5226, but using the `TIOCLINUX` ioctl command
    instead of `TIOCSTI`. If a Flatpak app is run on a Linux virtual console such
    as `/dev/tty1`, it can copy text from the virtual console and paste it into the
    command buffer, from which the command might be run after the Flatpak app has
    exited. Ordinary graphical terminal emulators like xterm, gnome-terminal and Konsole
    are unaffected. This vulnerability is specific to the Linux virtual consoles `/dev/tty1`,
    `/dev/tty2` and so on. A patch is available in versions 1.10.8, 1.12.8, 1.14.4,
    and 1.15.4. As a workaround, don't run Flatpak on a Linux virtual console. Flatpak
    is primarily designed to be used in a Wayland or X11 graphical environment.
- diff_content:
  - "--- a/app/flatpak-cli-transaction.c\n+++ b/app/flatpak-cli-transaction.c\n@@\
    \ -755,6 +755,9 @@ print_eol_info_message (FlatpakDir        *dir,\n     }\n \
    \  else if (reason)\n     {\n+      g_autofree char *escaped_reason = flatpak_escape_string\
    \ (reason,\n+                                                               FLATPAK_ESCAPE_ALLOW_NEWLINES\
    \ |\n+                                                               FLATPAK_ESCAPE_DO_NOT_QUOTE);\n\
    \       if (is_pinned)\n         {\n           /* Only runtimes can be pinned\
    \ */\n@@ -770,7 +773,7 @@ print_eol_info_message (FlatpakDir        *dir,\n  \
    \           g_print (_(\"\\nInfo: app %s%s%s branch %s%s%s is end-of-life, with\
    \ reason:\\n\"),\n                      on, ref_name, off, on, ref_branch, off);\n\
    \         }\n-      g_print (\"   %s\\n\", reason);\n+      g_print (\"   %s\\\
    n\", escaped_reason);\n     }\n }\n "
  - "--- a/app/flatpak-builtins-info.c\n+++ b/app/flatpak-builtins-info.c\n@@ -400,7\
    \ +400,9 @@ flatpak_builtin_info (int argc, char **argv, GCancellable *cancellable,\
    \ GError *\n           if (!g_file_load_contents (file, cancellable, &data, &data_size,\
    \ NULL, error))\n             return FALSE;\n \n-          g_print (\"%s\", data);\n\
    +          flatpak_print_escaped_string (data,\n+                            \
    \            FLATPAK_ESCAPE_ALLOW_NEWLINES\n+                                \
    \        | FLATPAK_ESCAPE_DO_NOT_QUOTE);\n         }\n \n       if (opt_show_permissions\
    \ || opt_file_access)\n@@ -421,7 +423,9 @@ flatpak_builtin_info (int argc, char\
    \ **argv, GCancellable *cancellable, GError *\n               if (contents ==\
    \ NULL)\n                 return FALSE;\n \n-              g_print (\"%s\", contents);\n\
    +              flatpak_print_escaped_string (contents,\n+                    \
    \                        FLATPAK_ESCAPE_ALLOW_NEWLINES\n+                    \
    \                        | FLATPAK_ESCAPE_DO_NOT_QUOTE);\n             }\n \n\
    \           if (opt_file_access)"
  - "--- a/app/flatpak-builtins-remote-info.c\n+++ b/app/flatpak-builtins-remote-info.c\n\
    @@ -431,7 +431,10 @@ flatpak_builtin_remote_info (int argc, char **argv, GCancellable\
    \ *cancellable, G\n \n           if (opt_show_metadata)\n             {\n-   \
    \           g_print (\"%s\", xa_metadata ? xa_metadata : \"\");\n+           \
    \   if (xa_metadata != NULL)\n+                flatpak_print_escaped_string (xa_metadata,\n\
    +                                              FLATPAK_ESCAPE_ALLOW_NEWLINES\n\
    +                                              | FLATPAK_ESCAPE_DO_NOT_QUOTE);\n\
    \               if (xa_metadata == NULL || !g_str_has_suffix (xa_metadata, \"\\\
    n\"))\n                 g_print (\"\\n\");\n             }"
  - "--- a/app/flatpak-cli-transaction.c\n+++ b/app/flatpak-cli-transaction.c\n@@\
    \ -1121,12 +1121,16 @@ print_perm_line (int        idx,\n                  int\
    \        cols)\n {\n   g_autoptr(GString) res = g_string_new (NULL);\n+  g_autofree\
    \ char *escaped_first_perm = NULL;\n   int i;\n \n-  g_string_append_printf (res,\
    \ \"    [%d] %s\", idx, (char *) items->pdata[0]);\n+  escaped_first_perm = flatpak_escape_string\
    \ (items->pdata[0], FLATPAK_ESCAPE_DEFAULT);\n+  g_string_append_printf (res,\
    \ \"    [%d] %s\", idx, escaped_first_perm);\n \n   for (i = 1; i < items->len;\
    \ i++)\n     {\n+      g_autofree char *escaped = flatpak_escape_string (items->pdata[i],\n\
    +                                                        FLATPAK_ESCAPE_DEFAULT);\n\
    \       char *p;\n       int len;\n \n@@ -1135,10 +1139,10 @@ print_perm_line\
    \ (int        idx,\n         p = res->str;\n \n       len = (res->str + strlen\
    \ (res->str)) - p;\n-      if (len + strlen ((char *) items->pdata[i]) + 2 >=\
    \ cols)\n-        g_string_append_printf (res, \",\\n        %s\", (char *) items->pdata[i]);\n\
    +      if (len + strlen (escaped) + 2 >= cols)\n+        g_string_append_printf\
    \ (res, \",\\n        %s\", escaped);\n       else\n-        g_string_append_printf\
    \ (res, \", %s\", (char *) items->pdata[i]);\n+        g_string_append_printf\
    \ (res, \", %s\", escaped);\n     }\n \n   g_print (\"%s\\n\", res->str);"
  - "--- a/common/flatpak-utils.c\n+++ b/common/flatpak-utils.c\n@@ -9222,6 +9222,86\
    \ @@ flatpak_uri_equal (const char *uri1,\n   return g_strcmp0 (uri1_norm, uri2_norm)\
    \ == 0;\n }\n \n+static gboolean\n+is_char_safe (gunichar c)\n+{\n+  return g_unichar_isgraph\
    \ (c) || c == ' ';\n+}\n+\n+static gboolean\n+should_hex_escape (gunichar    \
    \       c,\n+                   FlatpakEscapeFlags flags)\n+{\n+  if ((flags &\
    \ FLATPAK_ESCAPE_ALLOW_NEWLINES) && c == '\\n')\n+    return FALSE;\n+\n+  return\
    \ !is_char_safe (c);\n+}\n+\n+static void\n+append_hex_escaped_character (GString\
    \ *result,\n+                              gunichar c)\n+{\n+  if (c <= 0xFF)\n\
    +    g_string_append_printf (result, \"\\\\x%02X\", c);\n+  else if (c <= 0xFFFF)\n\
    +    g_string_append_printf (result, \"\\\\u%04X\", c);\n+  else\n+    g_string_append_printf\
    \ (result, \"\\\\U%08X\", c);\n+}\n+\n+char *\n+flatpak_escape_string (const char\
    \        *s,\n+                       FlatpakEscapeFlags flags)\n+{\n+  g_autoptr(GString)\
    \ res = g_string_new (\"\");\n+  gboolean did_escape = FALSE;\n+\n+  while (*s)\n\
    +    {\n+      gunichar c = g_utf8_get_char_validated (s, -1);\n+      if (c ==\
    \ (gunichar)-2 || c == (gunichar)-1)\n+        {\n+          /* Need to convert\
    \ to unsigned first, to avoid negative chars becoming\n+             huge gunichars.\
    \ */\n+          append_hex_escaped_character (res, (unsigned char)*s++);\n+ \
    \         did_escape = TRUE;\n+          continue;\n+        }\n+      else if\
    \ (should_hex_escape (c, flags))\n+        {\n+          append_hex_escaped_character\
    \ (res, c);\n+          did_escape = TRUE;\n+        }\n+      else if (c == '\\\
    \\' || (!(flags & FLATPAK_ESCAPE_DO_NOT_QUOTE) && c == '\\''))\n+        {\n+\
    \          g_string_append_printf (res, \"\\\\%c\", (char) c);\n+          did_escape\
    \ = TRUE;\n+        }\n+      else\n+        g_string_append_unichar (res, c);\n\
    +\n+      s = g_utf8_find_next_char (s, NULL);\n+    }\n+\n+  if (did_escape &&\
    \ !(flags & FLATPAK_ESCAPE_DO_NOT_QUOTE))\n+    {\n+      g_string_prepend_c (res,\
    \ '\\'');\n+      g_string_append_c (res, '\\'');\n+    }\n+\n+  return g_string_free\
    \ (g_steal_pointer (&res), FALSE);\n+}\n+\n+void\n+flatpak_print_escaped_string\
    \ (const char        *s,\n+                              FlatpakEscapeFlags flags)\n\
    +{\n+  g_autofree char *escaped = flatpak_escape_string (s, flags);\n+  g_print\
    \ (\"%s\", escaped);\n+}\n+\n+\n gboolean\n running_under_sudo (void)\n {"
  - "--- a/tests/testcommon.c\n+++ b/tests/testcommon.c\n@@ -1837,6 +1837,44 @@ test_parse_x11_display\
    \ (void)\n     }\n }\n \n+typedef struct {\n+  const char        *in;\n+  FlatpakEscapeFlags\
    \ flags;\n+  const char        *out;\n+} EscapeData;\n+\n+static EscapeData escapes[]\
    \ = {\n+  {\"abc def\", FLATPAK_ESCAPE_DEFAULT, \"abc def\"},\n+  {\"\u3084\u3042\
    \", FLATPAK_ESCAPE_DEFAULT, \"\u3084\u3042\"},\n+  {\"\\033[;1m\", FLATPAK_ESCAPE_DEFAULT,\
    \ \"'\\\\x1B[;1m'\"},\n+  // non-printable U+061C\n+  {\"\\u061C\", FLATPAK_ESCAPE_DEFAULT,\
    \ \"'\\\\u061C'\"},\n+  // non-printable U+1343F\n+  {\"\\xF0\\x93\\x90\\xBF\"\
    , FLATPAK_ESCAPE_DEFAULT, \"'\\\\U0001343F'\"},\n+  // invalid utf-8\n+  {\"\\\
    xD8\\1\", FLATPAK_ESCAPE_DEFAULT, \"'\\\\xD8\\\\x01'\"},\n+  {\"\\b \\n abc '\
    \ \\\\\", FLATPAK_ESCAPE_DEFAULT, \"'\\\\x08 \\\\x0A abc \\\\' \\\\\\\\'\"},\n\
    +  {\"\\b \\n abc ' \\\\\", FLATPAK_ESCAPE_DO_NOT_QUOTE, \"\\\\x08 \\\\x0A abc\
    \ ' \\\\\\\\\"},\n+  {\"abc\\tdef\\n\\033[;1m ghi\\b\", FLATPAK_ESCAPE_ALLOW_NEWLINES\
    \ | FLATPAK_ESCAPE_DO_NOT_QUOTE,\n+   \"abc\\\\x09def\\n\\\\x1B[;1m ghi\\\\x08\"\
    },\n+};\n+\n+/* CVE-2023-28101 */\n+static void\n+test_string_escape (void)\n\
    +{\n+  gsize idx;\n+\n+  for (idx = 0; idx < G_N_ELEMENTS (escapes); idx++)\n\
    +    {\n+      EscapeData *data = &escapes[idx];\n+      g_autofree char *ret\
    \ = NULL;\n+\n+      ret = flatpak_escape_string (data->in, data->flags);\n+ \
    \     g_assert_cmpstr (ret, ==, data->out);\n+    }\n+}\n+\n int\n main (int argc,\
    \ char *argv[])\n {\n@@ -1870,6 +1908,7 @@ main (int argc, char *argv[])\n   g_test_add_func\
    \ (\"/common/quote-argv\", test_quote_argv);\n   g_test_add_func (\"/common/str-is-integer\"\
    , test_str_is_integer);\n   g_test_add_func (\"/common/parse-x11-display\", test_parse_x11_display);\n\
    +  g_test_add_func (\"/common/string-escape\", test_string_escape);\n \n   g_test_add_func\
    \ (\"/app/looks-like-branch\", test_looks_like_branch);\n   g_test_add_func (\"\
    /app/columns\", test_columns);"
  - "--- a/common/flatpak-context.c\n+++ b/common/flatpak-context.c\n@@ -488,11 +488,17\
    \ @@ flatpak_context_apply_generic_policy (FlatpakContext *context,\n        \
    \                g_ptr_array_free (new, FALSE));\n }\n \n-static void\n+\n+static\
    \ gboolean\n flatpak_context_set_persistent (FlatpakContext *context,\n-     \
    \                           const char     *path)\n+                         \
    \       const char     *path,\n+                                GError       \
    \ **error)\n {\n+  if (!flatpak_validate_path_characters (path, error))\n+   \
    \ return FALSE;\n+\n   g_hash_table_insert (context->persistent, g_strdup (path),\
    \ GINT_TO_POINTER (1));\n+  return TRUE;\n }\n \n static gboolean\n@@ -854,6 +860,9\
    \ @@ flatpak_context_parse_filesystem (const char             *filesystem_and_mode,\n\
    \   g_autofree char *filesystem = NULL;\n   char *slash;\n \n+  if (!flatpak_validate_path_characters\
    \ (filesystem_and_mode, error))\n+    return FALSE;\n+\n   filesystem = parse_filesystem_flags\
    \ (filesystem_and_mode, negated, mode_out, error);\n   if (filesystem == NULL)\n\
    \     return FALSE;\n@@ -1510,8 +1519,7 @@ option_persist_cb (const gchar *option_name,\n\
    \ {\n   FlatpakContext *context = data;\n \n-  flatpak_context_set_persistent\
    \ (context, value);\n-  return TRUE;\n+  return flatpak_context_set_persistent\
    \ (context, value, error);\n }\n \n static gboolean option_no_desktop_deprecated;\n\
    @@ -1703,11 +1711,24 @@ flatpak_context_load_metadata (FlatpakContext *context,\n\
    \         {\n           const char *fs = parse_negated (filesystems[i], &remove);\n\
    \           g_autofree char *filesystem = NULL;\n+          g_autoptr(GError)\
    \ local_error = NULL;\n           FlatpakFilesystemMode mode;\n \n           if\
    \ (!flatpak_context_parse_filesystem (fs, remove,\n-                         \
    \                        &filesystem, &mode, NULL))\n-            g_info (\"Unknown\
    \ filesystem type %s\", filesystems[i]);\n+                                  \
    \               &filesystem, &mode, &local_error))\n+            {\n+        \
    \      if (g_error_matches (local_error, G_IO_ERROR, G_IO_ERROR_INVALID_DATA))\n\
    +                {\n+                  /* Invalid characters, so just hard-fail.\
    \ */\n+                  g_propagate_error (error, g_steal_pointer (&local_error));\n\
    +                  return FALSE;\n+                }\n+              else\n+ \
    \               {\n+                  g_info (\"Unknown filesystem type %s\",\
    \ filesystems[i]);\n+                  g_clear_error (&local_error);\n+      \
    \          }\n+            }\n           else\n             {\n              \
    \ g_assert (mode == FLATPAK_FILESYSTEM_MODE_NONE || !remove);\n@@ -1724,7 +1745,8\
    \ @@ flatpak_context_load_metadata (FlatpakContext *context,\n         return\
    \ FALSE;\n \n       for (i = 0; persistent[i] != NULL; i++)\n-        flatpak_context_set_persistent\
    \ (context, persistent[i]);\n+        if (!flatpak_context_set_persistent (context,\
    \ persistent[i], error))\n+          return FALSE;\n     }\n \n   if (g_key_file_has_group\
    \ (metakey, FLATPAK_METADATA_GROUP_SESSION_BUS_POLICY))"
  - "--- a/common/flatpak-utils.c\n+++ b/common/flatpak-utils.c\n@@ -9250,6 +9250,14\
    \ @@ append_hex_escaped_character (GString *result,\n     g_string_append_printf\
    \ (result, \"\\\\U%08X\", c);\n }\n \n+static char *\n+escape_character (gunichar\
    \ c)\n+{\n+  g_autoptr(GString) res = g_string_new (\"\");\n+  append_hex_escaped_character\
    \ (res, c);\n+  return g_string_free (g_steal_pointer (&res), FALSE);\n+}\n+\n\
    \ char *\n flatpak_escape_string (const char        *s,\n                    \
    \    FlatpakEscapeFlags flags)\n@@ -9301,6 +9309,37 @@ flatpak_print_escaped_string\
    \ (const char        *s,\n   g_print (\"%s\", escaped);\n }\n \n+gboolean\n+flatpak_validate_path_characters\
    \ (const char *path,\n+                                  GError    **error)\n\
    +{\n+  while (*path)\n+    {\n+      gunichar c = g_utf8_get_char_validated (path,\
    \ -1);\n+      if (c == (gunichar)-1 || c == (gunichar)-2)\n+        {\n+    \
    \      /* Need to convert to unsigned first, to avoid negative chars becoming\n\
    +             huge gunichars. */\n+          g_autofree char *escaped_char = escape_character\
    \ ((unsigned char)*path);\n+          g_autofree char *escaped = flatpak_escape_string\
    \ (path, FLATPAK_ESCAPE_DEFAULT);\n+          g_set_error (error, G_IO_ERROR,\
    \ G_IO_ERROR_INVALID_DATA,\n+                       \"Non-UTF8 byte %s in path\
    \ %s\", escaped_char, escaped);\n+          return FALSE;\n+        }\n+     \
    \ else if (!is_char_safe (c))\n+        {\n+          g_autofree char *escaped_char\
    \ = escape_character (c);\n+          g_autofree char *escaped = flatpak_escape_string\
    \ (path, FLATPAK_ESCAPE_DEFAULT);\n+          g_set_error (error, G_IO_ERROR,\
    \ G_IO_ERROR_INVALID_DATA,\n+                       \"Non-graphical character\
    \ %s in path %s\", escaped_char, escaped);\n+          return FALSE;\n+      \
    \  }\n+\n+      path = g_utf8_find_next_char (path, NULL);\n+    }\n+\n+  return\
    \ TRUE;\n+}\n \n gboolean\n running_under_sudo (void)"
  - "--- a/tests/test-context.c\n+++ b/tests/test-context.c\n@@ -129,13 +129,14 @@\
    \ test_context_env_fd (void)\n }\n \n static void context_parse_args (FlatpakContext\
    \ *context,\n+                                GError        **error,\n       \
    \                          ...) G_GNUC_NULL_TERMINATED;\n \n static void\n context_parse_args\
    \ (FlatpakContext *context,\n+                    GError        **error,\n   \
    \                  ...)\n {\n-  g_autoptr(GError) local_error = NULL;\n   g_autoptr(GOptionContext)\
    \ oc = NULL;\n   g_autoptr(GOptionGroup) group = NULL;\n   g_autoptr(GPtrArray)\
    \ args = g_ptr_array_new_with_free_func (g_free);\n@@ -145,7 +146,7 @@ context_parse_args\
    \ (FlatpakContext *context,\n \n   g_ptr_array_add (args, g_strdup (\"argv[0]\"\
    ));\n \n-  va_start (ap, context);\n+  va_start (ap, error);\n \n   while ((arg\
    \ = va_arg (ap, const char *)) != NULL)\n     g_ptr_array_add (args, g_strdup\
    \ (arg));\n@@ -158,8 +159,7 @@ context_parse_args (FlatpakContext *context,\n\
    \   oc = g_option_context_new (\"\");\n   group = flatpak_context_get_options\
    \ (context);\n   g_option_context_add_group (oc, group);\n-  g_option_context_parse_strv\
    \ (oc, &argv, &local_error);\n-  g_assert_no_error (local_error);\n+  g_option_context_parse_strv\
    \ (oc, &argv, error);\n }\n \n static void\n@@ -179,19 +179,26 @@ test_context_merge_fs\
    \ (void)\n       g_autoptr(FlatpakContext) lowest = flatpak_context_new ();\n\
    \       g_autoptr(FlatpakContext) middle = flatpak_context_new ();\n       g_autoptr(FlatpakContext)\
    \ highest = flatpak_context_new ();\n+      g_autoptr(GError) local_error = NULL;\n\
    \       gpointer value;\n \n       context_parse_args (lowest,\n+            \
    \              &local_error,\n                           \"--filesystem=/one\"\
    ,\n                           NULL);\n+      g_assert_no_error (local_error);\n\
    \       context_parse_args (middle,\n+                          &local_error,\n\
    \                           \"--nofilesystem=host:reset\",\n                 \
    \          \"--filesystem=/two\",\n                           NULL);\n+      g_assert_no_error\
    \ (local_error);\n       context_parse_args (highest,\n+                     \
    \     &local_error,\n                           \"--nofilesystem=host\",\n   \
    \                        \"--filesystem=/three\",\n                          \
    \ NULL);\n+      g_assert_no_error (local_error);\n \n       g_assert_false (g_hash_table_lookup_extended\
    \ (lowest->filesystems, \"host\", NULL, NULL));\n       g_assert_false (g_hash_table_lookup_extended\
    \ (lowest->filesystems, \"host-reset\", NULL, NULL));\n@@ -273,20 +280,28 @@ test_context_merge_fs\
    \ (void)\n       gpointer value;\n \n       context_parse_args (lowest,\n+   \
    \                       &local_error,\n                           \"--filesystem=/one\"\
    ,\n                           NULL);\n+      g_assert_no_error (local_error);\n\
    \       context_parse_args (mid_low,\n+                          &local_error,\n\
    \                           \"--nofilesystem=host:reset\",\n                 \
    \          \"--filesystem=/two\",\n                           NULL);\n+      g_assert_no_error\
    \ (local_error);\n       context_parse_args (mid_high,\n+                    \
    \      &local_error,\n                           \"--filesystem=host\",\n    \
    \                       \"--filesystem=/three\",\n                           NULL);\n\
    +      g_assert_no_error (local_error);\n       context_parse_args (highest,\n\
    +                          &local_error,\n                           \"--nofilesystem=host\"\
    ,\n                           \"--filesystem=/four\",\n                      \
    \     NULL);\n+      g_assert_no_error (local_error);\n \n       g_assert_false\
    \ (g_hash_table_lookup_extended (lowest->filesystems, \"host\", NULL, NULL));\n\
    \       g_assert_false (g_hash_table_lookup_extended (lowest->filesystems, \"\
    host-reset\", NULL, NULL));\n@@ -427,6 +442,65 @@ test_context_merge_fs (void)\n\
    \     }\n }\n \n+const char *invalid_path_args[] = {\n+  \"--filesystem=/\\033[J:ro\"\
    ,\n+  \"--filesystem=/\\033[J\",\n+  \"--persist=\\033[J\",\n+};\n+\n+/* CVE-2023-28101\
    \ */\n+static void\n+test_validate_path_args (void)\n+{\n+  gsize idx;\n+\n+ \
    \ for (idx = 0; idx < G_N_ELEMENTS (invalid_path_args); idx++)\n+    {\n+    \
    \  g_autoptr(FlatpakContext) context = flatpak_context_new ();\n+      g_autoptr(GError)\
    \ local_error = NULL;\n+      const char *path = invalid_path_args[idx];\n+\n\
    +      context_parse_args (context, &local_error, path, NULL);\n+      g_assert_error\
    \ (local_error, G_IO_ERROR, G_IO_ERROR_INVALID_DATA);\n+      g_assert (strstr\
    \ (local_error->message, \"Non-graphical character\"));\n+    }\n+}\n+\n+typedef\
    \ struct {\n+  const char *key;\n+  const char *value;\n+} PathValidityData;\n\
    +\n+PathValidityData invalid_path_meta[] = {\n+  {FLATPAK_METADATA_KEY_FILESYSTEMS,\
    \ \"\\033[J\"},\n+  {FLATPAK_METADATA_KEY_PERSISTENT, \"\\033[J\"},\n+};\n+\n\
    +/* CVE-2023-28101 */\n+static void\n+test_validate_path_meta (void)\n+{\n+  gsize\
    \ idx;\n+\n+  for (idx = 0; idx < G_N_ELEMENTS (invalid_path_meta); idx++)\n+\
    \    {\n+      g_autoptr(FlatpakContext) context = flatpak_context_new ();\n+\
    \      g_autoptr(GKeyFile) metakey = g_key_file_new ();\n+      g_autoptr(GError)\
    \ local_error = NULL;\n+      PathValidityData *data = &invalid_path_meta[idx];\n\
    +      gboolean ret = FALSE;\n+\n+      g_key_file_set_string_list (metakey, FLATPAK_METADATA_GROUP_CONTEXT,\n\
    +                                  data->key, &data->value, 1);\n+\n+      ret\
    \ = flatpak_context_load_metadata (context, metakey, &local_error);\n+      g_assert_false\
    \ (ret);\n+      g_assert_error (local_error, G_IO_ERROR, G_IO_ERROR_INVALID_DATA);\n\
    +      g_assert (strstr (local_error->message, \"Non-graphical character\"));\n\
    +    }\n+\n+}\n+\n int\n main (int argc, char *argv[])\n {\n@@ -435,6 +509,8 @@\
    \ main (int argc, char *argv[])\n   g_test_add_func (\"/context/env\", test_context_env);\n\
    \   g_test_add_func (\"/context/env-fd\", test_context_env_fd);\n   g_test_add_func\
    \ (\"/context/merge-fs\", test_context_merge_fs);\n+  g_test_add_func (\"/context/validate-path-args\"\
    , test_validate_path_args);\n+  g_test_add_func (\"/context/validate-path-meta\"\
    , test_validate_path_meta);\n \n   return g_test_run ();\n }"
  - "--- a/tests/testcommon.c\n+++ b/tests/testcommon.c\n@@ -1847,11 +1847,12 @@ static\
    \ EscapeData escapes[] = {\n   {\"abc def\", FLATPAK_ESCAPE_DEFAULT, \"abc def\"\
    },\n   {\"\u3084\u3042\", FLATPAK_ESCAPE_DEFAULT, \"\u3084\u3042\"},\n   {\"\\\
    033[;1m\", FLATPAK_ESCAPE_DEFAULT, \"'\\\\x1B[;1m'\"},\n-  // non-printable U+061C\n\
    +  /* U+061C ARABIC LETTER MARK, non-printable */\n   {\"\\u061C\", FLATPAK_ESCAPE_DEFAULT,\
    \ \"'\\\\u061C'\"},\n-  // non-printable U+1343F\n+  /* U+1343F EGYPTIAN HIEROGLYPH\
    \ END WALLED ENCLOSURE, non-printable and\n+   * outside BMP */\n   {\"\\xF0\\\
    x93\\x90\\xBF\", FLATPAK_ESCAPE_DEFAULT, \"'\\\\U0001343F'\"},\n-  // invalid\
    \ utf-8\n+  /* invalid utf-8 */\n   {\"\\xD8\\1\", FLATPAK_ESCAPE_DEFAULT, \"\
    '\\\\xD8\\\\x01'\"},\n   {\"\\b \\n abc ' \\\\\", FLATPAK_ESCAPE_DEFAULT, \"'\\\
    \\x08 \\\\x0A abc \\\\' \\\\\\\\'\"},\n   {\"\\b \\n abc ' \\\\\", FLATPAK_ESCAPE_DO_NOT_QUOTE,\
    \ \"\\\\x08 \\\\x0A abc ' \\\\\\\\\"},\n@@ -1875,6 +1876,39 @@ test_string_escape\
    \ (void)\n     }\n }\n \n+typedef struct {\n+  const char *path;\n+  gboolean\
    \ ret;\n+} PathValidityData;\n+\n+static PathValidityData paths[] = {\n+  {\"\
    /a/b/../c.def\", TRUE},\n+  {\"\u3084\u3042\", TRUE},\n+  /* U+061C ARABIC LETTER\
    \ MARK, non-printable */\n+  {\"\\u061C\", FALSE},\n+  /* U+1343F EGYPTIAN HIEROGLYPH\
    \ END WALLED ENCLOSURE, non-printable and\n+   * outside BMP */\n+  {\"\\xF0\\\
    x93\\x90\\xBF\", FALSE},\n+  /* invalid utf-8 */\n+  {\"\\xD8\\1\", FALSE},\n\
    +};\n+\n+/* CVE-2023-28101 */\n+static void\n+test_validate_path_characters (void)\n\
    +{\n+  gsize idx;\n+\n+  for (idx = 0; idx < G_N_ELEMENTS (paths); idx++)\n+ \
    \   {\n+      PathValidityData *data = &paths[idx];\n+      gboolean ret = FALSE;\n\
    +\n+      ret = flatpak_validate_path_characters (data->path, NULL);\n+      g_assert_cmpint\
    \ (ret, ==, data->ret);\n+    }\n+}\n+\n int\n main (int argc, char *argv[])\n\
    \ {\n@@ -1909,6 +1943,7 @@ main (int argc, char *argv[])\n   g_test_add_func (\"\
    /common/str-is-integer\", test_str_is_integer);\n   g_test_add_func (\"/common/parse-x11-display\"\
    , test_parse_x11_display);\n   g_test_add_func (\"/common/string-escape\", test_string_escape);\n\
    +  g_test_add_func (\"/common/validate-path-characters\", test_validate_path_characters);\n\
    \ \n   g_test_add_func (\"/app/looks-like-branch\", test_looks_like_branch);\n\
    \   g_test_add_func (\"/app/columns\", test_columns);"
  identifiers:
  - CVE-2023-28101
  - CWE-116
  overview: Flatpak is a system for building, distributing, and running sandboxed
    desktop applications on Linux. In versions prior to 1.10.8, 1.12.8, 1.14.4, and
    1.15.4, if an attacker publishes a Flatpak app with elevated permissions, they
    can hide those permissions from users of the `flatpak(1)` command-line interface
    by setting other permissions to crafted values that contain non-printable control
    characters such as `ESC`. A fix is available in versions 1.10.8, 1.12.8, 1.14.4,
    and 1.15.4. As a workaround, use a GUI like GNOME Software rather than the command-line
    interface, or only install apps whose maintainers you trust.
  references:
  - source: security-advisories@github.com
    tags:
    - Patch
    url: https://github.com/flatpak/flatpak/commit/409e34187de2b2b2c4ef34c79f417be698830f6c
  - source: security-advisories@github.com
    tags:
    - Patch
    url: https://github.com/flatpak/flatpak/commit/6cac99dafe6003c8a4bd5666341c217876536869
  - source: security-advisories@github.com
    tags:
    - Patch
    url: https://github.com/flatpak/flatpak/commit/7fe63f2e8f1fd2dafc31d45154cf0b191ebec66c
  - source: security-advisories@github.com
    tags:
    - Patch
    - Vendor Advisory
    url: https://github.com/flatpak/flatpak/security/advisories/GHSA-h43h-fwqx-mpp8
  - source: security-advisories@github.com
    url: https://security.gentoo.org/glsa/202312-12
  title: Flatpak is a system for building, distributing, and running sandboxed desktop
    applications on Linux. In versions prior to 1.10.8, 1.12.8, 1.14.4, and 1.15.4,
    if an attacker publishes a Flatpak app with elevated permissions, they can hide
    those permissions from users of the `flatpak(1)` command-line interface by setting
    other permissions to crafted values that contain non-printable control characters
    such as `ESC`. A fix is available in versions 1.10.8, 1.12.8, 1.14.4, and 1.15.4.
    As a workaround, use a GUI like GNOME Software rather than the command-line interface,
    or only install apps whose maintainers you trust.
- diff_content:
  - "--- a/net/tipc/link.c\n+++ b/net/tipc/link.c\n@@ -1030,21 +1030,25 @@ void tipc_link_reset(struct\
    \ tipc_link *l)\n int tipc_link_xmit(struct tipc_link *l, struct sk_buff_head\
    \ *list,\n \t\t   struct sk_buff_head *xmitq)\n {\n-\tstruct tipc_msg *hdr = buf_msg(skb_peek(list));\n\
    \ \tstruct sk_buff_head *backlogq = &l->backlogq;\n \tstruct sk_buff_head *transmq\
    \ = &l->transmq;\n \tstruct sk_buff *skb, *_skb;\n \tu16 bc_ack = l->bc_rcvlink->rcv_nxt\
    \ - 1;\n \tu16 ack = l->rcv_nxt - 1;\n \tu16 seqno = l->snd_nxt;\n \tint pkt_cnt\
    \ = skb_queue_len(list);\n-\tint imp = msg_importance(hdr);\n \tunsigned int mss\
    \ = tipc_link_mss(l);\n \tunsigned int cwin = l->window;\n \tunsigned int mtu\
    \ = l->mtu;\n+\tstruct tipc_msg *hdr;\n \tbool new_bundle;\n \tint rc = 0;\n+\t\
    int imp;\n+\n+\tif (pkt_cnt <= 0)\n+\t\treturn 0;\n \n+\thdr = buf_msg(skb_peek(list));\n\
    \ \tif (unlikely(msg_size(hdr) > mtu)) {\n \t\tpr_warn(\"Too large msg, purging\
    \ xmit list %d %d %d %d %d!\\n\",\n \t\t\tskb_queue_len(list), msg_user(hdr),\n\
    @@ -1053,6 +1057,7 @@ int tipc_link_xmit(struct tipc_link *l, struct sk_buff_head\
    \ *list,\n \t\treturn -EMSGSIZE;\n \t}\n \n+\timp = msg_importance(hdr);\n \t\
    /* Allow oversubscription of one data msg per source at congestion */\n \tif (unlikely(l->backlog[imp].len\
    \ >= l->backlog[imp].limit)) {\n \t\tif (imp == TIPC_SYSTEM_IMPORTANCE) {"
  identifiers:
  - CVE-2023-1390
  - NVD-CWE-Other
  overview: "A remote denial of service vulnerability was found in the Linux kernel\u2019\
    s TIPC kernel module. The while loop in tipc_link_xmit() hits an unknown state\
    \ while attempting to parse SKBs, which are not in the queue. Sending two small\
    \ UDP packets to a system with a UDP bearer results in the CPU utilization for\
    \ the system to instantly spike to 100%, causing a denial of service condition."
  references:
  - source: secalert@redhat.com
    tags:
    - Third Party Advisory
    url: https://gist.github.com/netspooky/bee2d07022f6350bb88eaa48e571d9b5
  - source: secalert@redhat.com
    tags:
    - Patch
    - Vendor Advisory
    url: https://github.com/torvalds/linux/commit/b77413446408fdd256599daf00d5be72b5f3e7c6
  - source: secalert@redhat.com
    url: https://infosec.exchange/%40_mattata/109427999461122360
  - source: secalert@redhat.com
    tags:
    - Third Party Advisory
    url: https://security.netapp.com/advisory/ntap-20230420-0001/
  title: "A remote denial of service vulnerability was found in the Linux kernel\u2019\
    s TIPC kernel module. The while loop in tipc_link_xmit() hits an unknown state\
    \ while attempting to parse SKBs, which are not in the queue. Sending two small\
    \ UDP packets to a system with a UDP bearer results in the CPU utilization for\
    \ the system to instantly spike to 100%, causing a denial of service condition."
- diff_content:
  - "--- a/pdfio-stream.c\n+++ b/pdfio-stream.c\n@@ -1008,6 +1008,7 @@ stream_read(pdfio_stream_t\
    \ *st,\t\t// I - Stream\n             size_t         bytes)\t// I - Number of\
    \ bytes to read\n {\n   ssize_t\trbytes;\t\t\t// Bytes read\n+  uInt\t\tavail_in,\
    \ avail_out;\t// Previous flate values\n \n \n   if (st->filter == PDFIO_FILTER_NONE)\n\
    @@ -1060,11 +1061,19 @@ stream_read(pdfio_stream_t *st,\t\t// I - Stream\n   \
    \    st->flate.next_out  = (Bytef *)buffer;\n       st->flate.avail_out = (uInt)bytes;\n\
    \ \n+      avail_in  = st->flate.avail_in;\n+      avail_out = st->flate.avail_out;\n\
    +\n       if ((status = inflate(&(st->flate), Z_NO_FLUSH)) < Z_OK)\n       {\n\
    \ \t_pdfioFileError(st->pdf, \"Unable to decompress stream data: %s\", zstrerror(status));\n\
    \ \treturn (-1);\n       }\n+      else if (avail_in == st->flate.avail_in &&\
    \ avail_out == st->flate.avail_out)\n+      {\n+\t_pdfioFileError(st->pdf, \"\
    Corrupt stream data.\");\n+\treturn (-1);\n+      }\n \n       return (st->flate.next_out\
    \ - (Bytef *)buffer);\n     }\n@@ -1113,12 +1122,15 @@ stream_read(pdfio_stream_t\
    \ *st,\t\t// I - Stream\n \t  st->flate.avail_in = (uInt)rbytes;\n \t}\n \n+ \
    \       avail_in  = st->flate.avail_in;\n+        avail_out = st->flate.avail_out;\n\
    +\n \tif ((status = inflate(&(st->flate), Z_NO_FLUSH)) < Z_OK)\n \t{\n \t  _pdfioFileError(st->pdf,\
    \ \"Unable to decompress stream data: %s\", zstrerror(status));\n \t  return (-1);\n\
    \ \t}\n-\telse if (status == Z_STREAM_END)\n+\telse if (status == Z_STREAM_END\
    \ || (avail_in == st->flate.avail_in && avail_out == st->flate.avail_out))\n \t\
    \  break;\n       }\n \n@@ -1180,12 +1192,15 @@ stream_read(pdfio_stream_t *st,\t\
    \t// I - Stream\n \t  st->flate.avail_in = (uInt)rbytes;\n \t}\n \n+        avail_in\
    \  = st->flate.avail_in;\n+        avail_out = st->flate.avail_out;\n+\n \tif\
    \ ((status = inflate(&(st->flate), Z_NO_FLUSH)) < Z_OK)\n \t{\n \t  _pdfioFileError(st->pdf,\
    \ \"Unable to decompress stream data: %s\", zstrerror(status));\n \t  return (-1);\n\
    \ \t}\n-\telse if (status == Z_STREAM_END)\n+\telse if (status == Z_STREAM_END\
    \ || (avail_in == st->flate.avail_in && avail_out == st->flate.avail_out))\n \t\
    \  break;\n       }\n "
  identifiers:
  - CVE-2023-28428
  - CWE-770
  overview: PDFio is a C library for reading and writing PDF files. In versions 1.1.0
    and prior, a denial of service vulnerability exists in the pdfio parser. Crafted
    pdf files can cause the program to run at 100% utilization and never terminate.
    This is different from CVE-2023-24808. A patch for this issue is available in
    version 1.1.1.
  references:
  - source: security-advisories@github.com
    tags:
    - Patch
    url: https://github.com/michaelrsweet/pdfio/commit/97d4955666779dc5b0665e15dd951a5c12426a31
  - source: security-advisories@github.com
    tags:
    - Vendor Advisory
    url: https://github.com/michaelrsweet/pdfio/security/advisories/GHSA-68x8-9phf-j7jf
  title: PDFio is a C library for reading and writing PDF files. In versions 1.1.0
    and prior, a denial of service vulnerability exists in the pdfio parser. Crafted
    pdf files can cause the program to run at 100% utilization and never terminate.
    This is different from CVE-2023-24808. A patch for this issue is available in
    version 1.1.1.
- diff_content:
  - "--- a/src/t_string.c\n+++ b/src/t_string.c\n@@ -559,7 +559,6 @@ void mgetCommand(client\
    \ *c) {\n \n void msetGenericCommand(client *c, int nx) {\n     int j;\n-    int\
    \ setkey_flags = 0;\n \n     if ((c->argc % 2) == 0) {\n         addReplyErrorArity(c);\n\
    @@ -575,12 +574,11 @@ void msetGenericCommand(client *c, int nx) {\n         \
    \        return;\n             }\n         }\n-        setkey_flags |= SETKEY_DOESNT_EXIST;\n\
    \     }\n \n     for (j = 1; j < c->argc; j += 2) {\n         c->argv[j+1] = tryObjectEncoding(c->argv[j+1]);\n\
    -        setKey(c, c->db, c->argv[j], c->argv[j + 1], setkey_flags);\n+      \
    \  setKey(c, c->db, c->argv[j], c->argv[j + 1], 0);\n         notifyKeyspaceEvent(NOTIFY_STRING,\"\
    set\",c->argv[j],c->db->id);\n     }\n     server.dirty += (c->argc-1)/2;"
  identifiers:
  - CVE-2023-28425
  - CWE-77
  overview: Redis is an in-memory database that persists on disk. Starting in version
    7.0.8 and prior to version 7.0.10, authenticated users can use the MSETNX command
    to trigger a runtime assertion and termination of the Redis server process. The
    problem is fixed in Redis version 7.0.10.
  references:
  - source: security-advisories@github.com
    tags:
    - Patch
    url: https://github.com/redis/redis/commit/48e0d4788434833b47892fe9f3d91be7687f25c9
  - source: security-advisories@github.com
    tags:
    - Release Notes
    url: https://github.com/redis/redis/releases/tag/7.0.10
  - source: security-advisories@github.com
    tags:
    - Vendor Advisory
    url: https://github.com/redis/redis/security/advisories/GHSA-mvmm-4vq6-vw8c
  - source: security-advisories@github.com
    url: https://security.netapp.com/advisory/ntap-20230413-0005/
  title: Redis is an in-memory database that persists on disk. Starting in version
    7.0.8 and prior to version 7.0.10, authenticated users can use the MSETNX command
    to trigger a runtime assertion and termination of the Redis server process. The
    problem is fixed in Redis version 7.0.10.
- diff_content:
  - "--- a/lib/seq_buf.c\n+++ b/lib/seq_buf.c\n@@ -229,8 +229,10 @@ int seq_buf_putmem_hex(struct\
    \ seq_buf *s, const void *mem,\n \n \tWARN_ON(s->size == 0);\n \n+\tBUILD_BUG_ON(MAX_MEMHEX_BYTES\
    \ * 2 >= HEX_CHARS);\n+\n \twhile (len) {\n-\t\tstart_len = min(len, HEX_CHARS\
    \ - 1);\n+\t\tstart_len = min(len, MAX_MEMHEX_BYTES);\n #ifdef __BIG_ENDIAN\n\
    \ \t\tfor (i = 0, j = 0; i < start_len; i++) {\n #else"
  identifiers:
  - CVE-2023-28772
  - CWE-120
  overview: An issue was discovered in the Linux kernel before 5.13.3. lib/seq_buf.c
    has a seq_buf_putmem_hex buffer overflow.
  references:
  - source: cve@mitre.org
    tags:
    - Release Notes
    - Vendor Advisory
    url: https://cdn.kernel.org/pub/linux/kernel/v5.x/ChangeLog-5.13.3
  - source: cve@mitre.org
    tags:
    - Patch
    - Vendor Advisory
    url: https://github.com/torvalds/linux/commit/d3b16034a24a112bb83aeb669ac5b9b01f744bb7
  - source: cve@mitre.org
    url: https://lkml.kernel.org/r/20210626032156.47889-1-yun.zhou%40windriver.com
  - source: cve@mitre.org
    url: https://lore.kernel.org/lkml/20210625122453.5e2fe304%40oasis.local.home/
  - source: cve@mitre.org
    tags:
    - Third Party Advisory
    url: https://security.netapp.com/advisory/ntap-20230427-0005/
  title: An issue was discovered in the Linux kernel before 5.13.3. lib/seq_buf.c
    has a seq_buf_putmem_hex buffer overflow.
- diff_content:
  - "--- a/libr/bin/p/bin_coff.c\n+++ b/libr/bin/p/bin_coff.c\n@@ -505,11 +505,13\
    \ @@ static RList *patch_relocs(RBin *b) {\n \n \tsize_t nimports = 0;\n \tint\
    \ i;\n-\tfor (i = 0; i < bin->hdr.f_nsyms; i++) {\n-\t\tif (is_imported_symbol\
    \ (&bin->symbols[i])) {\n-\t\t\tnimports++;\n+\tif (bin->symbols) {\n+\t\tfor\
    \ (i = 0; i < bin->hdr.f_nsyms; i++) {\n+\t\t\tif (is_imported_symbol (&bin->symbols[i]))\
    \ {\n+\t\t\t\tnimports++;\n+\t\t\t}\n+\t\t\ti += bin->symbols[i].n_numaux;\n \t\
    \t}\n-\t\ti += bin->symbols[i].n_numaux;\n \t}\n \tut64 m_vaddr = UT64_MAX;\n\
    \ \tif (nimports) {"
  identifiers:
  - CVE-2023-1605
  - CWE-400
  overview: Denial of Service in GitHub repository radareorg/radare2 prior to 5.8.6.
  references:
  - source: security@huntr.dev
    tags:
    - Patch
    url: https://github.com/radareorg/radare2/commit/508a6307045441defd1bef0999a1f7052097613f
  - source: security@huntr.dev
    tags:
    - Exploit
    - Third Party Advisory
    url: https://huntr.dev/bounties/9dddcf5b-7dd4-46cc-abf9-172dce20bab2
  title: Denial of Service in GitHub repository radareorg/radare2 prior to 5.8.6.
- diff_content:
  - "--- a/MagickCore/draw.c\n+++ b/MagickCore/draw.c\n@@ -5585,7 +5585,8 @@ MagickExport\
    \ MagickBooleanType DrawPrimitive(Image *image,\n \n       if (primitive_info->text\
    \ == (char *) NULL)\n         break;\n-      clone_info=CloneImageInfo(draw_info->image_info);\n\
    +      clone_info=AcquireImageInfo();\n+      clone_info->recursion_depth=draw_info->image_info->recursion_depth;\n\
    \       composite_images=(Image *) NULL;\n       if (LocaleNCompare(primitive_info->text,\"\
    data:\",5) == 0)\n         composite_images=ReadInlineImage(clone_info,primitive_info->text,"
  identifiers:
  - CVE-2023-1289
  - CWE-20
  overview: A vulnerability was discovered in ImageMagick where a specially created
    SVG file loads itself and causes a segmentation fault. This flaw allows a remote
    attacker to pass a specially crafted SVG file that leads to a segmentation fault,
    generating many trash files in "/tmp," resulting in a denial of service. When
    ImageMagick crashes, it generates a lot of trash files. These trash files can
    be large if the SVG file contains many render actions. In a denial of service
    attack, if a remote attacker uploads an SVG file of size t, ImageMagick generates
    files of size 103*t. If an attacker uploads a 100M SVG, the server will generate
    about 10G.
  references:
  - source: secalert@redhat.com
    tags:
    - Issue Tracking
    - Patch
    url: https://bugzilla.redhat.com/show_bug.cgi?id=2176858
  - source: secalert@redhat.com
    tags:
    - Patch
    url: https://github.com/ImageMagick/ImageMagick/commit/c5b23cbf2119540725e6dc81f4deb25798ead6a4
  - source: secalert@redhat.com
    tags:
    - Exploit
    - Vendor Advisory
    url: https://github.com/ImageMagick/ImageMagick/security/advisories/GHSA-j96m-mjp6-99xr
  - source: secalert@redhat.com
    url: https://lists.debian.org/debian-lts-announce/2024/02/msg00007.html
  title: A vulnerability was discovered in ImageMagick where a specially created SVG
    file loads itself and causes a segmentation fault. This flaw allows a remote attacker
    to pass a specially crafted SVG file that leads to a segmentation fault, generating
    many trash files in "/tmp," resulting in a denial of service. When ImageMagick
    crashes, it generates a lot of trash files. These trash files can be large if
    the SVG file contains many render actions. In a denial of service attack, if a
    remote attacker uploads an SVG file of size t, ImageMagick generates files of
    size 103*t. If an attacker uploads a 100M SVG, the server will generate about
    10G.
- diff_content:
  - "--- a/arch/x86/kvm/x86.c\n+++ b/arch/x86/kvm/x86.c\n@@ -5263,12 +5263,11 @@ static\
    \ void kvm_vcpu_ioctl_x86_get_debugregs(struct kvm_vcpu *vcpu,\n {\n \tunsigned\
    \ long val;\n \n+\tmemset(dbgregs, 0, sizeof(*dbgregs));\n \tmemcpy(dbgregs->db,\
    \ vcpu->arch.db, sizeof(vcpu->arch.db));\n \tkvm_get_dr(vcpu, 6, &val);\n \tdbgregs->dr6\
    \ = val;\n \tdbgregs->dr7 = vcpu->arch.dr7;\n-\tdbgregs->flags = 0;\n-\tmemset(&dbgregs->reserved,\
    \ 0, sizeof(dbgregs->reserved));\n }\n \n static int kvm_vcpu_ioctl_x86_set_debugregs(struct\
    \ kvm_vcpu *vcpu,"
  identifiers:
  - CVE-2023-1513
  - CWE-665
  overview: A flaw was found in KVM. When calling the KVM_GET_DEBUGREGS ioctl, on
    32-bit systems, there might be some uninitialized portions of the kvm_debugregs
    structure that could be copied to userspace, causing an information leak.
  references:
  - source: secalert@redhat.com
    tags:
    - Issue Tracking
    - Patch
    - Third Party Advisory
    url: https://bugzilla.redhat.com/show_bug.cgi?id=2179892
  - source: secalert@redhat.com
    tags:
    - Patch
    url: https://github.com/torvalds/linux/commit/2c10b61421a28e95a46ab489fd56c0f442ff6952
  - source: secalert@redhat.com
    url: https://lists.debian.org/debian-lts-announce/2023/05/msg00005.html
  - source: secalert@redhat.com
    url: https://lists.debian.org/debian-lts-announce/2023/05/msg00006.html
  - source: secalert@redhat.com
    url: https://lore.kernel.org/kvm/20230214103304.3689213-1-gregkh%40linuxfoundation.org/
  title: A flaw was found in KVM. When calling the KVM_GET_DEBUGREGS ioctl, on 32-bit
    systems, there might be some uninitialized portions of the kvm_debugregs structure
    that could be copied to userspace, causing an information leak.
- diff_content:
  - "--- a/lib/nlattr.c\n+++ b/lib/nlattr.c\n@@ -44,6 +44,20 @@ static const u8 nla_attr_minlen[NLA_TYPE_MAX+1]\
    \ = {\n \t[NLA_S64]\t= sizeof(s64),\n };\n \n+/*\n+ * Nested policies might refer\
    \ back to the original\n+ * policy in some cases, and userspace could try to\n\
    + * abuse that and recurse by nesting in the right\n+ * ways. Limit recursion\
    \ to avoid this problem.\n+ */\n+#define MAX_POLICY_RECURSION_DEPTH\t10\n+\n+static\
    \ int __nla_validate_parse(const struct nlattr *head, int len, int maxtype,\n\
    +\t\t\t\tconst struct nla_policy *policy,\n+\t\t\t\tunsigned int validate,\n+\t\
    \t\t\tstruct netlink_ext_ack *extack,\n+\t\t\t\tstruct nlattr **tb, unsigned int\
    \ depth);\n+\n static int validate_nla_bitfield32(const struct nlattr *nla,\n\
    \ \t\t\t\t   const u32 valid_flags_mask)\n {\n@@ -70,7 +84,7 @@ static int validate_nla_bitfield32(const\
    \ struct nlattr *nla,\n static int nla_validate_array(const struct nlattr *head,\
    \ int len, int maxtype,\n \t\t\t      const struct nla_policy *policy,\n \t\t\t\
    \      struct netlink_ext_ack *extack,\n-\t\t\t      unsigned int validate)\n\
    +\t\t\t      unsigned int validate, unsigned int depth)\n {\n \tconst struct nlattr\
    \ *entry;\n \tint rem;\n@@ -87,8 +101,9 @@ static int nla_validate_array(const\
    \ struct nlattr *head, int len, int maxtype,\n \t\t\treturn -ERANGE;\n \t\t}\n\
    \ \n-\t\tret = __nla_validate(nla_data(entry), nla_len(entry),\n-\t\t\t\t    \
    \ maxtype, policy, validate, extack);\n+\t\tret = __nla_validate_parse(nla_data(entry),\
    \ nla_len(entry),\n+\t\t\t\t\t   maxtype, policy, validate, extack,\n+\t\t\t\t\
    \t   NULL, depth + 1);\n \t\tif (ret < 0)\n \t\t\treturn ret;\n \t}\n@@ -156,7\
    \ +171,7 @@ static int nla_validate_int_range(const struct nla_policy *pt,\n \n\
    \ static int validate_nla(const struct nlattr *nla, int maxtype,\n \t\t\tconst\
    \ struct nla_policy *policy, unsigned int validate,\n-\t\t\tstruct netlink_ext_ack\
    \ *extack)\n+\t\t\tstruct netlink_ext_ack *extack, unsigned int depth)\n {\n \t\
    u16 strict_start_type = policy[0].strict_start_type;\n \tconst struct nla_policy\
    \ *pt;\n@@ -269,9 +284,10 @@ static int validate_nla(const struct nlattr *nla,\
    \ int maxtype,\n \t\tif (attrlen < NLA_HDRLEN)\n \t\t\tgoto out_err;\n \t\tif\
    \ (pt->nested_policy) {\n-\t\t\terr = __nla_validate(nla_data(nla), nla_len(nla),\
    \ pt->len,\n-\t\t\t\t\t     pt->nested_policy, validate,\n-\t\t\t\t\t     extack);\n\
    +\t\t\terr = __nla_validate_parse(nla_data(nla), nla_len(nla),\n+\t\t\t\t\t\t\
    \   pt->len, pt->nested_policy,\n+\t\t\t\t\t\t   validate, extack, NULL,\n+\t\t\
    \t\t\t\t   depth + 1);\n \t\t\tif (err < 0) {\n \t\t\t\t/*\n \t\t\t\t * return\
    \ directly to preserve the inner\n@@ -294,7 +310,7 @@ static int validate_nla(const\
    \ struct nlattr *nla, int maxtype,\n \n \t\t\terr = nla_validate_array(nla_data(nla),\
    \ nla_len(nla),\n \t\t\t\t\t\t pt->len, pt->nested_policy,\n-\t\t\t\t\t\t extack,\
    \ validate);\n+\t\t\t\t\t\t extack, validate, depth);\n \t\t\tif (err < 0) {\n\
    \ \t\t\t\t/*\n \t\t\t\t * return directly to preserve the inner\n@@ -358,11 +374,17\
    \ @@ static int __nla_validate_parse(const struct nlattr *head, int len, int maxtype,\n\
    \ \t\t\t\tconst struct nla_policy *policy,\n \t\t\t\tunsigned int validate,\n\
    \ \t\t\t\tstruct netlink_ext_ack *extack,\n-\t\t\t\tstruct nlattr **tb)\n+\t\t\
    \t\tstruct nlattr **tb, unsigned int depth)\n {\n \tconst struct nlattr *nla;\n\
    \ \tint rem;\n \n+\tif (depth >= MAX_POLICY_RECURSION_DEPTH) {\n+\t\tNL_SET_ERR_MSG(extack,\n\
    +\t\t\t       \"allowed policy recursion depth exceeded\");\n+\t\treturn -EINVAL;\n\
    +\t}\n+\n \tif (tb)\n \t\tmemset(tb, 0, sizeof(struct nlattr *) * (maxtype + 1));\n\
    \ \n@@ -379,7 +401,7 @@ static int __nla_validate_parse(const struct nlattr *head,\
    \ int len, int maxtype,\n \t\t}\n \t\tif (policy) {\n \t\t\tint err = validate_nla(nla,\
    \ maxtype, policy,\n-\t\t\t\t\t       validate, extack);\n+\t\t\t\t\t       validate,\
    \ extack, depth);\n \n \t\t\tif (err < 0)\n \t\t\t\treturn err;\n@@ -421,7 +443,7\
    \ @@ int __nla_validate(const struct nlattr *head, int len, int maxtype,\n \t\t\
    \   struct netlink_ext_ack *extack)\n {\n \treturn __nla_validate_parse(head,\
    \ len, maxtype, policy, validate,\n-\t\t\t\t    extack, NULL);\n+\t\t\t\t    extack,\
    \ NULL, 0);\n }\n EXPORT_SYMBOL(__nla_validate);\n \n@@ -476,7 +498,7 @@ int __nla_parse(struct\
    \ nlattr **tb, int maxtype,\n \t\tstruct netlink_ext_ack *extack)\n {\n \treturn\
    \ __nla_validate_parse(head, len, maxtype, policy, validate,\n-\t\t\t\t    extack,\
    \ tb);\n+\t\t\t\t    extack, tb, 0);\n }\n EXPORT_SYMBOL(__nla_parse);\n "
  identifiers:
  - CVE-2020-36691
  - CWE-674
  overview: An issue was discovered in the Linux kernel before 5.8. lib/nlattr.c allows
    attackers to cause a denial of service (unbounded recursion) via a nested Netlink
    policy with a back reference.
  references:
  - source: cve@mitre.org
    tags:
    - Release Notes
    url: https://cdn.kernel.org/pub/linux/kernel/v5.x/ChangeLog-5.8
  - source: cve@mitre.org
    tags:
    - Patch
    url: https://github.com/torvalds/linux/commit/7690aa1cdf7c4565ad6b013b324c28b685505e24
  title: An issue was discovered in the Linux kernel before 5.8. lib/nlattr.c allows
    attackers to cause a denial of service (unbounded recursion) via a nested Netlink
    policy with a back reference.
- diff_content:
  - "--- a/src/filters/reframe_rawpcm.c\n+++ b/src/filters/reframe_rawpcm.c\n@@ -250,6\
    \ +250,7 @@ GF_Err pcmreframe_process(GF_Filter *filter)\n \n \tif (ctx->probe_wave==1)\
    \ {\n \t\tBool wav_ok = GF_TRUE;\n+\t\tBool hdr_found = GF_FALSE;\n \t\tGF_BitStream\
    \ *bs;\n \t\tif (ctx->probe_data) {\n \t\t\tctx->probe_data = gf_realloc(ctx->probe_data,\
    \ ctx->probe_data_size+pck_size);\n@@ -280,6 +281,7 @@ GF_Err pcmreframe_process(GF_Filter\
    \ *filter)\n \t\t\t\tcontinue;\n \t\t\t}\n \t\t\t//parse fmt\n+\t\t\thdr_found\
    \ = GF_TRUE;\n \t\t\tu16 atype = gf_bs_read_u16_le(bs);\n \t\t\tctx->ch = gf_bs_read_u16_le(bs);\n\
    \ \t\t\tctx->sr = gf_bs_read_u32_le(bs);\n@@ -312,11 +314,13 @@ GF_Err pcmreframe_process(GF_Filter\
    \ *filter)\n \t\t\t\tmemcpy(ctx->probe_data, data, pck_size);\n \t\t\t\tctx->probe_data_size\
    \ = pck_size;\n \t\t\t}\n-\t\t\tif (ctx->probe_data_size<=10000) {\n-\t\t\t\t\
    gf_filter_pid_drop_packet(ctx->ipid);\n-\t\t\t\treturn GF_OK;\n+\t\t\tif (!hdr_found)\
    \ {\n+\t\t\t\tif (ctx->probe_data_size<=10000) {\n+\t\t\t\t\tgf_filter_pid_drop_packet(ctx->ipid);\n\
    +\t\t\t\t\treturn GF_OK;\n+\t\t\t\t}\n+\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_MEDIA,\
    \ (\"[PCMReframe] Cannot find wave data chunk after %d bytes, aborting\\n\", ctx->probe_data_size));\n\
    \ \t\t\t}\n-\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_MEDIA, (\"[PCMReframe] Cannot\
    \ find wave data chink afetr %d bytes, aborting\\n\", ctx->probe_data_size));\n\
    \ \t\t\twav_ok = GF_FALSE;\n \t\t}\n "
  - "--- a/src/utils/bitstream.c\n+++ b/src/utils/bitstream.c\n@@ -1266,6 +1266,10\
    \ @@ void gf_bs_skip_bytes(GF_BitStream *bs, u64 nbBytes)\n \t\t\t}\n \t\t} else\
    \ {\n \t\t\tbs->position += nbBytes;\n+\t\t\tif (bs->position>bs->size) {\n+\t\
    \t\t\tbs->position = bs->size;\n+\t\t\t\tbs->overflow_state = 1;\n+\t\t\t}\n \t\
    \t}\n \t\treturn;\n \t}"
  identifiers:
  - CVE-2023-1655
  - CWE-122
  overview: Heap-based Buffer Overflow in GitHub repository gpac/gpac prior to 2.4.0.
  references:
  - source: security@huntr.dev
    tags:
    - Patch
    url: https://github.com/gpac/gpac/commit/e7f96c2d3774e4ea25f952bcdf55af1dd6e919f4
  - source: security@huntr.dev
    tags:
    - Exploit
    - Patch
    - Third Party Advisory
    url: https://huntr.dev/bounties/05f1d1de-bbfd-43fe-bdf9-7f73419ce7c9
  title: Heap-based Buffer Overflow in GitHub repository gpac/gpac prior to 2.4.0.
- diff_content:
  - "--- a/src/filter_core/filter_pid.c\n+++ b/src/filter_core/filter_pid.c\n@@ -62,13\
    \ +62,17 @@ void gf_filter_pid_inst_del(GF_FilterPidInst *pidinst)\n \tgf_list_del(pidinst->pck_reassembly);\n\
    \ \tif (pidinst->props) {\n \t\tassert(pidinst->props->reference_count);\n-\t\t\
    if (safe_int_dec(&pidinst->props->reference_count) == 0) {\n-\t\t\t//see \\ref\
    \ gf_filter_pid_merge_properties_internal for mutex\n-\t\t\tgf_mx_p(pidinst->pid->filter->tasks_mx);\n\
    -\t\t\tgf_list_del_item(pidinst->pid->properties, pidinst->props);\n-\t\t\tgf_mx_v(pidinst->pid->filter->tasks_mx);\n\
    -\t\t\tgf_props_del(pidinst->props);\n+\t\tgf_mx_p(pidinst->pid->filter->tasks_mx);\n\
    +\t\t//not in parent pid, may happen when reattaching a pid inst to a different\
    \ pid\n+\t\t//in this case do NOT delete the props\n+\t\tif (gf_list_find(pidinst->pid->properties,\
    \ pidinst->props)>=0) {\n+\t\t\tif (safe_int_dec(&pidinst->props->reference_count)\
    \ == 0) {\n+\t\t\t\t//see \\ref gf_filter_pid_merge_properties_internal for mutex\n\
    +\t\t\t\tgf_list_del_item(pidinst->pid->properties, pidinst->props);\n+\t\t\t\t\
    gf_props_del(pidinst->props);\n+\t\t\t}\n \t\t}\n+\t\tgf_mx_v(pidinst->pid->filter->tasks_mx);\n\
    \ \t}\n \tgf_free(pidinst);\n }\n@@ -1044,8 +1048,15 @@ static GF_Err gf_filter_pid_configure(GF_Filter\
    \ *filter, GF_FilterPid *pid, GF_P\n \t\t\t\t\t\tif (!target->detached_pid_inst)\
    \ {\n \t\t\t\t\t\t\ttarget->detached_pid_inst = gf_list_new();\n \t\t\t\t\t\t\
    }\n-\t\t\t\t\t\t//detach props but don't delete them\n+\t\t\t\t\t\t//detach props\n\
    \ \t\t\t\t\t\tif (filter->swap_pidinst_dst->props) {\n+\t\t\t\t\t\t\tGF_FilterPidInst\
    \ *swap_pidi = filter->swap_pidinst_dst;\n+\t\t\t\t\t\t\tif (safe_int_dec(&swap_pidi->props->reference_count)==0)\
    \ {\n+\t\t\t\t\t\t\t\tgf_mx_p(swap_pidi->pid->filter->tasks_mx);\n+\t\t\t\t\t\t\
    \t\tgf_list_del_item(swap_pidi->pid->properties, pidinst->props);\n+\t\t\t\t\t\
    \t\t\tgf_mx_v(swap_pidi->pid->filter->tasks_mx);\n+\t\t\t\t\t\t\t\tgf_props_del(pidinst->props);\n\
    +\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tfilter->swap_pidinst_dst->props = NULL;\n \t\t\
    \t\t\t\t}\n \t\t\t\t\t\tfilter->swap_pidinst_dst->pid = NULL;\n@@ -1308,7 +1319,7\
    \ @@ void gf_filter_pid_detach_task(GF_FSTask *task)\n \t//first connection of\
    \ this PID to this filter\n \tif (!pidinst) {\n \t\tGF_LOG(GF_LOG_ERROR, GF_LOG_FILTER,\
    \ (\"Trying to detach PID %s not present in filter %s inputs\\n\",  pid->name,\
    \ filter->name));\n-\t\t//assert(!new_chain_input->swap_pidinst_dst);\n+\t\t//when\
    \ swaping encoder, we may have swap_pidinst_dst not NULL so only check swap_pidinst_src\n\
    \ \t\tassert(!new_chain_input->swap_pidinst_src);\n \t\tnew_chain_input->swap_needs_init\
    \ = GF_FALSE;\n \t\treturn;\n@@ -5943,7 +5954,7 @@ static GF_Err gf_filter_pid_merge_properties_internal(GF_FilterPid\
    \ *dst_pid, GF_\n \t\t}\n \t\tsrc_props = pidi->props;\n \t}\n-\t//move to rela\
    \ pid\n+\t//move to real pid\n \tsrc_pid = src_pid->pid;\n \t//this is a copy\
    \ props on output pid\n \tif (!src_props) {"
  identifiers:
  - CVE-2023-1654
  - CWE-400
  overview: Denial of Service in GitHub repository gpac/gpac prior to 2.4.0.
  references:
  - source: security@huntr.dev
    tags:
    - Patch
    url: https://github.com/gpac/gpac/commit/2c055153d401b8c49422971e3a0159869652d3da
  - source: security@huntr.dev
    tags:
    - Patch
    url: https://huntr.dev/bounties/33652b56-128f-41a7-afcc-10641f69ff14
  - source: security@huntr.dev
    url: https://www.debian.org/security/2023/dsa-5411
  title: Denial of Service in GitHub repository gpac/gpac prior to 2.4.0.
- diff_content:
  - "--- a/auth.c\n+++ b/auth.c\n@@ -583,7 +583,8 @@ int ksmbd_decode_ntlmssp_auth_blob(struct\
    \ authenticate_message *authblob,\n \tdn_off = le32_to_cpu(authblob->DomainName.BufferOffset);\n\
    \ \tdn_len = le16_to_cpu(authblob->DomainName.Length);\n \n-\tif (blob_len < (u64)dn_off\
    \ + dn_len || blob_len < (u64)nt_off + nt_len)\n+\tif (blob_len < (u64)dn_off\
    \ + dn_len || blob_len < (u64)nt_off + nt_len ||\n+\t    nt_len < CIFS_ENCPWD_SIZE)\n\
    \ \t\treturn -EINVAL;\n \n #ifdef CONFIG_SMB_INSECURE_SERVER"
  identifiers:
  - CVE-2023-0210
  - CWE-787
  overview: "A bug affects the Linux kernel\u2019s ksmbd NTLMv2 authentication and\
    \ is known to crash the OS immediately in Linux-based systems."
  references:
  - source: secalert@redhat.com
    tags:
    - Mailing List
    - Patch
    url: https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit
  - source: secalert@redhat.com
    tags:
    - Mailing List
    - Patch
    url: https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=797805d81baa814f76cf7bdab35f86408a79d707
  - source: secalert@redhat.com
    tags:
    - Patch
    url: https://github.com/cifsd-team/ksmbd/commit/8824b7af409f51f1316e92e9887c2fd48c0b26d6
  - source: secalert@redhat.com
    tags:
    - Third Party Advisory
    url: https://security.netapp.com/advisory/ntap-20230517-0002/
  - source: secalert@redhat.com
    tags:
    - Exploit
    - Third Party Advisory
    url: https://securityonline.info/cve-2023-0210-flaw-in-linux-kernel-allows-unauthenticated-remote-dos-attacks/
  - source: secalert@redhat.com
    tags:
    - Exploit
    - Mailing List
    - Third Party Advisory
    url: https://www.openwall.com/lists/oss-security/2023/01/04/1
  - source: secalert@redhat.com
    tags:
    - Mailing List
    - Third Party Advisory
    url: https://www.openwall.com/lists/oss-security/2023/01/11/1
  title: "A bug affects the Linux kernel\u2019s ksmbd NTLMv2 authentication and is\
    \ known to crash the OS immediately in Linux-based systems."
- diff_content:
  - "--- a/qga/vss-win32/install.cpp\n+++ b/qga/vss-win32/install.cpp\n@@ -357,6 +357,15\
    \ @@ out:\n     return hr;\n }\n \n+STDAPI_(void) CALLBACK DLLCOMRegister(HWND,\
    \ HINSTANCE, LPSTR, int)\n+{\n+    COMRegister();\n+}\n+\n+STDAPI_(void) CALLBACK\
    \ DLLCOMUnregister(HWND, HINSTANCE, LPSTR, int)\n+{\n+    COMUnregister();\n+}\n\
    \ \n static BOOL CreateRegistryKey(LPCTSTR key, LPCTSTR value, LPCTSTR data)\n\
    \ {\n"
  identifiers:
  - CVE-2023-0664
  - CWE-269
  overview: A flaw was found in the QEMU Guest Agent service for Windows. A local
    unprivileged user may be able to manipulate the QEMU Guest Agent's Windows installer
    via repair custom actions to elevate their privileges on the system.
  references:
  - source: secalert@redhat.com
    tags:
    - Issue Tracking
    - Patch
    - Third Party Advisory
    url: https://bugzilla.redhat.com/show_bug.cgi?id=2167423
  - source: secalert@redhat.com
    tags:
    - Patch
    url: https://gitlab.com/qemu-project/qemu/-/commit/07ce178a2b0768eb9e712bb5ad0cf6dc7fcf0158
  - source: secalert@redhat.com
    tags:
    - Patch
    url: https://gitlab.com/qemu-project/qemu/-/commit/88288c2a51faa7c795f053fc8b31b1c16ff804c5
  - source: secalert@redhat.com
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/MURWGXDIF2WTDXV36T6HFJDBL632AO7R/
  - source: secalert@redhat.com
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/SEOC7SRJWLZSXCND2ADFW6C76ZMTZLE4/
  - source: secalert@redhat.com
    tags:
    - Mailing List
    - Third Party Advisory
    url: https://lists.nongnu.org/archive/html/qemu-devel/2023-03/msg01445.html
  - source: secalert@redhat.com
    url: https://security.netapp.com/advisory/ntap-20230517-0005/
  title: A flaw was found in the QEMU Guest Agent service for Windows. A local unprivileged
    user may be able to manipulate the QEMU Guest Agent's Windows installer via repair
    custom actions to elevate their privileges on the system.
- diff_content:
  - "--- a/src/address.c\n+++ b/src/address.c\n@@ -148,6 +148,8 @@ new_address(const\
    \ char *hostname_or_ip) {\n     if (hostname_or_ip[0] == '[' &&\n            \
    \ (port = strchr(hostname_or_ip, ']')) != NULL) {\n         len = (size_t)(port\
    \ - hostname_or_ip - 1);\n+        if (len >= INET6_ADDRSTRLEN)\n+           \
    \ return NULL;\n \n         /* inet_pton() will not parse the IP correctly unless\
    \ it is in a\n          * separate string."
  identifiers:
  - CVE-2023-25076
  - CWE-120
  overview: 'A buffer overflow vulnerability exists in the handling of wildcard backend
    hosts of SNIProxy 0.6.0-2 and the master branch (commit: 822bb80df9b7b345cc9eba55df74a07b498819ba).
    A specially crafted HTTP or TLS packet can lead to arbitrary code execution. An
    attacker could send a malicious packet to trigger this vulnerability.'
  references:
  - source: talos-cna@cisco.com
    tags:
    - Patch
    url: https://github.com/dlundquist/sniproxy/commit/f8d9a433fe22ab2fa15c00179048ab02ae23d583
  - source: talos-cna@cisco.com
    url: https://lists.debian.org/debian-lts-announce/2023/04/msg00030.html
  - source: talos-cna@cisco.com
    tags:
    - Exploit
    - Mitigation
    - Third Party Advisory
    url: https://talosintelligence.com/vulnerability_reports/TALOS-2023-1731
  - source: talos-cna@cisco.com
    url: https://www.debian.org/security/2023/dsa-5413
  title: 'A buffer overflow vulnerability exists in the handling of wildcard backend
    hosts of SNIProxy 0.6.0-2 and the master branch (commit: 822bb80df9b7b345cc9eba55df74a07b498819ba).
    A specially crafted HTTP or TLS packet can lead to arbitrary code execution. An
    attacker could send a malicious packet to trigger this vulnerability.'
- diff_content:
  - "--- a/api_test/main.c\n+++ b/api_test/main.c\n@@ -1133,6 +1133,7 @@ int main()\
    \ {\n   int retval;\n   test_batch_runner *runner = test_batch_runner_new();\n\
    \ \n+  cmark_enable_safety_checks(true);\n   version(runner);\n   constructor(runner);\n\
    \   accessors(runner);"
  - "--- a/extensions/table.c\n+++ b/extensions/table.c\n@@ -311,12 +311,18 @@ static\
    \ cmark_node *try_opening_table_header(cmark_syntax_extension *self,\n     }\n\
    \   }\n \n+  assert(cmark_node_get_type(parent_container) == CMARK_NODE_PARAGRAPH);\n\
    \   if (!cmark_node_set_type(parent_container, CMARK_NODE_TABLE)) {\n     free_table_row(parser->mem,\
    \ header_row);\n     free_table_row(parser->mem, marker_row);\n     return parent_container;\n\
    \   }\n \n+  // Update the node counts after parent_container changed type.\n\
    +  assert(parent_container->next == NULL);\n+  decr_open_block_count(parser, CMARK_NODE_PARAGRAPH);\n\
    +  incr_open_block_count(parser, CMARK_NODE_TABLE);\n+\n   if (header_row->paragraph_offset)\
    \ {\n     try_inserting_table_header_paragraph(parser, parent_container, (unsigned\
    \ char *)parent_string,\n                                          header_row->paragraph_offset);"
  - "--- a/src/blocks.c\n+++ b/src/blocks.c\n@@ -70,6 +70,22 @@ static void S_parser_feed(cmark_parser\
    \ *parser, const unsigned char *buffer,\n static void S_process_line(cmark_parser\
    \ *parser, const unsigned char *buffer,\n                            bufsize_t\
    \ bytes);\n \n+static void subtract_open_block_counts(cmark_parser *parser, cmark_node\
    \ *node) {\n+  do {\n+    decr_open_block_count(parser, S_type(node));\n+    node->flags\
    \ &= ~CMARK_NODE__OPEN_BLOCK;\n+    node = node->last_child;\n+  } while (node);\n\
    +}\n+\n+static void add_open_block_counts(cmark_parser *parser, cmark_node *node)\
    \ {\n+  do {\n+    incr_open_block_count(parser, S_type(node));\n+    node->flags\
    \ |= CMARK_NODE__OPEN_BLOCK;\n+    node = node->last_child;\n+  } while (node);\n\
    +}\n+\n static cmark_node *make_block(cmark_mem *mem, cmark_node_type tag,\n \
    \                              int start_line, int start_column) {\n   cmark_node\
    \ *e;\n@@ -129,6 +145,7 @@ static void cmark_parser_reset(cmark_parser *parser)\
    \ {\n   parser->refmap = cmark_reference_map_new(parser->mem);\n   parser->root\
    \ = document;\n   parser->current = document;\n+  add_open_block_counts(parser,\
    \ document);\n \n   parser->syntax_extensions = saved_exts;\n   parser->inline_syntax_extensions\
    \ = saved_inline_exts;\n@@ -242,15 +259,18 @@ static void remove_trailing_blank_lines(cmark_strbuf\
    \ *ln) {\n // Check to see if a node ends with a blank line, descending\n // if\
    \ needed into lists and sublists.\n static bool S_ends_with_blank_line(cmark_node\
    \ *node) {\n-  if (S_last_line_checked(node)) {\n-    return(S_last_line_blank(node));\n\
    -  } else if ((S_type(node) == CMARK_NODE_LIST ||\n-              S_type(node)\
    \ == CMARK_NODE_ITEM) && node->last_child) {\n-    S_set_last_line_checked(node);\n\
    -    return(S_ends_with_blank_line(node->last_child));\n-  } else {\n-    S_set_last_line_checked(node);\n\
    -    return (S_last_line_blank(node));\n+  while (true) {\n+    if (S_last_line_checked(node))\
    \ {\n+      return(S_last_line_blank(node));\n+    } else if ((S_type(node) ==\
    \ CMARK_NODE_LIST ||\n+                S_type(node) == CMARK_NODE_ITEM) && node->last_child)\
    \ {\n+      S_set_last_line_checked(node);\n+      node = node->last_child;\n\
    +      continue;\n+    } else {\n+      S_set_last_line_checked(node);\n+    \
    \  return (S_last_line_blank(node));\n+    }\n   }\n }\n \n@@ -310,6 +330,12 @@\
    \ static cmark_node *finalize(cmark_parser *parser, cmark_node *b) {\n     has_content\
    \ = resolve_reference_link_definitions(parser, b);\n     if (!has_content) {\n\
    \       // remove blank node (former reference def)\n+      if (b->flags & CMARK_NODE__OPEN_BLOCK)\
    \ {\n+        decr_open_block_count(parser, S_type(b));\n+        if (b->prev)\
    \ {\n+          add_open_block_counts(parser, b->prev);\n+        }\n+      }\n\
    \       cmark_node_free(b);\n     }\n     break;\n@@ -382,6 +408,17 @@ static\
    \ cmark_node *finalize(cmark_parser *parser, cmark_node *b) {\n   return parent;\n\
    \ }\n \n+// Recalculates the number of open blocks. Returns true if it matches\
    \ what's currently stored\n+// in parser. (Used to check that the counts in parser,\
    \ which are updated incrementally, are\n+// correct.)\n+bool check_open_block_counts(cmark_parser\
    \ *parser) {\n+  cmark_parser tmp_parser = {0}; // Only used for its open_block_counts\
    \ and total_open_blocks fields.\n+  add_open_block_counts(&tmp_parser, parser->root);\n\
    +  return\n+    tmp_parser.total_open_blocks == parser->total_open_blocks &&\n\
    +    memcmp(tmp_parser.open_block_counts, parser->open_block_counts, sizeof(parser->open_block_counts))\
    \ == 0;\n+}\n+\n // Add a node as child of another.  Return pointer to child.\n\
    \ static cmark_node *add_child(cmark_parser *parser, cmark_node *parent,\n   \
    \                           cmark_node_type block_type, int start_column) {\n\
    @@ -400,11 +437,14 @@ static cmark_node *add_child(cmark_parser *parser, cmark_node\
    \ *parent,\n   if (parent->last_child) {\n     parent->last_child->next = child;\n\
    \     child->prev = parent->last_child;\n+    subtract_open_block_counts(parser,\
    \ parent->last_child);\n   } else {\n     parent->first_child = child;\n     child->prev\
    \ = NULL;\n   }\n   parent->last_child = child;\n+  add_open_block_counts(parser,\
    \ child);\n+\n   return child;\n }\n \n@@ -1047,8 +1087,14 @@ static cmark_node\
    \ *check_open_blocks(cmark_parser *parser, cmark_chunk *input,\n   *all_matched\
    \ = false;\n   cmark_node *container = parser->root;\n   cmark_node_type cont_type;\n\
    +  cmark_parser tmp_parser; // Only used for its open_block_counts and total_open_blocks\
    \ fields.\n+  memcpy(tmp_parser.open_block_counts, parser->open_block_counts,\
    \ sizeof(parser->open_block_counts));\n+  tmp_parser.total_open_blocks = parser->total_open_blocks;\n\
    +\n+  assert(check_open_block_counts(parser));\n \n   while (S_last_child_is_open(container))\
    \ {\n+    decr_open_block_count(&tmp_parser, S_type(container));\n     container\
    \ = container->last_child;\n     cont_type = S_type(container);\n \n@@ -1060,6\
    \ +1106,53 @@ static cmark_node *check_open_blocks(cmark_parser *parser, cmark_chunk\
    \ *input,\n       continue;\n     }\n \n+    // This block of code is a workaround\
    \ for the quadratic performance\n+    // issue described here (issue 2):\n+  \
    \  //\n+    // https://github.com/github/cmark-gfm/security/advisories/GHSA-66g8-4hjf-77xh\n\
    +    //\n+    // If the current line is empty then we might be able to skip directly\n\
    +    // to the end of the list of open blocks. To determine whether this is\n\
    +    // possible, we have been maintaining a count of the number of\n+    // different\
    \ types of open blocks. The main criterium is that every\n+    // remaining block,\
    \ except the last element of the list, is a LIST or\n+    // ITEM. The code below\
    \ checks the conditions, and if they're ok, skips\n+    // forward to parser->current.\n\
    +    if (parser->blank && parser->indent == 0) {  // Current line is empty\n+\
    \      // Make sure that parser->current doesn't point to a closed block.\n+ \
    \     if (parser->current->flags & CMARK_NODE__OPEN_BLOCK) {\n+        if (parser->current->flags\
    \ & CMARK_NODE__OPEN) {\n+          const size_t n_list = read_open_block_count(&tmp_parser,\
    \ CMARK_NODE_LIST);\n+          const size_t n_item = read_open_block_count(&tmp_parser,\
    \ CMARK_NODE_ITEM);\n+          // At most one block can be something other than\
    \ a LIST or ITEM.\n+          if (n_list + n_item + 1 >= tmp_parser.total_open_blocks)\
    \ {\n+            // Check that parser->current is suitable for jumping to.\n\
    +            switch (S_type(parser->current)) {\n+            case CMARK_NODE_LIST:\n\
    +            case CMARK_NODE_ITEM:\n+              if (n_list + n_item != tmp_parser.total_open_blocks)\
    \ {\n+                if (parser->current->last_child == NULL) {\n+          \
    \        // There's another node type somewhere in the middle of\n+          \
    \        // the list, so don't attempt the optimization.\n+                  break;\n\
    +                }\n+              }\n+              // fall through\n+      \
    \      case CMARK_NODE_CODE_BLOCK:\n+            case CMARK_NODE_PARAGRAPH:\n\
    +            case CMARK_NODE_HTML_BLOCK:\n+              // Jump to parser->current\n\
    +              container = parser->current;\n+              cont_type = S_type(container);\n\
    +              break;\n+            default:\n+              break;\n+       \
    \     }\n+          }\n+        }\n+      }\n+    }\n+\n     switch (cont_type)\
    \ {\n     case CMARK_NODE_BLOCK_QUOTE:\n       if (!parse_block_quote_prefix(parser,\
    \ input))\n@@ -1193,8 +1286,9 @@ static void open_new_blocks(cmark_parser *parser,\
    \ cmark_node **container,\n       has_content = resolve_reference_link_definitions(parser,\
    \ *container);\n \n       if (has_content) {\n-\n-        (*container)->type =\
    \ (uint16_t)CMARK_NODE_HEADING;\n+        cmark_node_set_type(*container, CMARK_NODE_HEADING);\n\
    +        decr_open_block_count(parser, CMARK_NODE_PARAGRAPH);\n+        incr_open_block_count(parser,\
    \ CMARK_NODE_HEADING);\n         (*container)->as.heading.level = lev;\n     \
    \    (*container)->as.heading.setext = true;\n         S_advance_offset(parser,\
    \ input, input->len - 1 - parser->offset, false);\n@@ -1349,7 +1443,7 @@ static\
    \ void add_text_to_container(cmark_parser *parser, cmark_node *container,\n  \
    \ S_set_last_line_blank(container, last_line_blank);\n \n   tmp = container;\n\
    -  while (tmp->parent) {\n+  while (tmp->parent && S_last_line_blank(tmp->parent))\
    \ {\n     S_set_last_line_blank(tmp->parent, false);\n     tmp = tmp->parent;\n\
    \   }\n@@ -1478,6 +1572,7 @@ static void S_process_line(cmark_parser *parser,\
    \ const unsigned char *buffer,\n \n   parser->line_number++;\n \n+  assert(parser->current->next\
    \ == NULL);\n   last_matched_container = check_open_blocks(parser, &input, &all_matched);\n\
    \ \n   if (!last_matched_container)"
  - "--- a/src/node.c\n+++ b/src/node.c\n@@ -5,6 +5,16 @@\n #include \"node.h\"\n\
    \ #include \"syntax_extension.h\"\n \n+/**\n+ * Expensive safety checks are off\
    \ by default, but can be enabled\n+ * by calling cmark_enable_safety_checks().\n\
    + */\n+static bool enable_safety_checks = false;\n+\n+void cmark_enable_safety_checks(bool\
    \ enable) {\n+  enable_safety_checks = enable;\n+}\n+\n static void S_node_unlink(cmark_node\
    \ *node);\n \n #define NODE_MEM(node) cmark_node_mem(node)\n@@ -70,23 +80,23 @@\
    \ bool cmark_node_can_contain_type(cmark_node *node, cmark_node_type child_type)\
    \ {\n }\n \n static bool S_can_contain(cmark_node *node, cmark_node *child) {\n\
    -  cmark_node *cur;\n-\n   if (node == NULL || child == NULL) {\n     return false;\n\
    \   }\n   if (NODE_MEM(node) != NODE_MEM(child)) {\n     return 0;\n   }\n \n\
    -  // Verify that child is not an ancestor of node or equal to node.\n-  cur =\
    \ node;\n-  do {\n-    if (cur == child) {\n-      return false;\n-    }\n-  \
    \  cur = cur->parent;\n-  } while (cur != NULL);\n+  if (enable_safety_checks)\
    \ {\n+    // Verify that child is not an ancestor of node or equal to node.\n\
    +    cmark_node *cur = node;\n+    do {\n+      if (cur == child) {\n+       \
    \ return false;\n+      }\n+      cur = cur->parent;\n+    } while (cur != NULL);\n\
    +  }\n \n   return cmark_node_can_contain_type(node, (cmark_node_type) child->type);\n\
    \ }"
  - "--- a/src/syntax_extension.c\n+++ b/src/syntax_extension.c\n@@ -29,7 +29,10 @@\
    \ cmark_syntax_extension *cmark_syntax_extension_new(const char *name) {\n cmark_node_type\
    \ cmark_syntax_extension_add_node(int is_inline) {\n   cmark_node_type *ref =\
    \ !is_inline ? &CMARK_NODE_LAST_BLOCK : &CMARK_NODE_LAST_INLINE;\n \n-  if ((*ref\
    \ & CMARK_NODE_VALUE_MASK) == CMARK_NODE_VALUE_MASK) {\n+  if ((*ref & CMARK_NODE_VALUE_MASK)\
    \ >= CMARK_NODE_TYPE_BLOCK_LIMIT) {\n+    // This assertion will fail if you try\
    \ to register more extensions than\n+    // are currently allowed by CMARK_NODE_TYPE_BLOCK_MAXNUM.\
    \ Try increasing\n+    // the limit.\n     assert(false);\n     return (cmark_node_type)\
    \ 0;\n   }"
  identifiers:
  - CVE-2023-24824
  - CWE-400
  overview: cmark-gfm is GitHub's fork of cmark, a CommonMark parsing and rendering
    library and program in C. A polynomial time complexity issue in cmark-gfm may
    lead to unbounded resource exhaustion and subsequent denial of service. This CVE
    covers quadratic complexity issues when parsing text which leads with either large
    numbers of `>` or `-` characters. This issue has been addressed in version 0.29.0.gfm.10.
    Users are advised to upgrade. Users unable to upgrade should validate that their
    input comes from trusted sources.
  references:
  - source: security-advisories@github.com
    tags:
    - Patch
    url: https://github.com/github/cmark-gfm/commit/2300c1bd2c8226108885bf019655c4159cf26b59
  - source: security-advisories@github.com
    tags:
    - Exploit
    - Vendor Advisory
    url: https://github.com/github/cmark-gfm/security/advisories/GHSA-66g8-4hjf-77xh
  title: cmark-gfm is GitHub's fork of cmark, a CommonMark parsing and rendering library
    and program in C. A polynomial time complexity issue in cmark-gfm may lead to
    unbounded resource exhaustion and subsequent denial of service. This CVE covers
    quadratic complexity issues when parsing text which leads with either large numbers
    of `>` or `-` characters. This issue has been addressed in version 0.29.0.gfm.10.
    Users are advised to upgrade. Users unable to upgrade should validate that their
    input comes from trusted sources.
- diff_content:
  - "--- a/src/commonmark.c\n+++ b/src/commonmark.c\n@@ -153,23 +153,8 @@ static bool\
    \ is_autolink(cmark_node *node) {\n                   link_text->as.literal.len)\
    \ == 0);\n }\n \n-// if node is a block node, returns node.\n-// otherwise returns\
    \ first block-level node that is an ancestor of node.\n-// if there is no block-level\
    \ ancestor, returns NULL.\n-static cmark_node *get_containing_block(cmark_node\
    \ *node) {\n-  while (node) {\n-    if (CMARK_NODE_BLOCK_P(node)) {\n-      return\
    \ node;\n-    } else {\n-      node = node->parent;\n-    }\n-  }\n-  return NULL;\n\
    -}\n-\n static int S_render_node(cmark_renderer *renderer, cmark_node *node,\n\
    \                          cmark_event_type ev_type, int options) {\n-  cmark_node\
    \ *tmp;\n   int list_number;\n   cmark_delim_type list_delim;\n   int numticks;\n\
    @@ -189,14 +174,17 @@ static int S_render_node(cmark_renderer *renderer, cmark_node\
    \ *node,\n   // Don't adjust tight list status til we've started the list.\n \
    \  // Otherwise we loose the blank line between a paragraph and\n   // a following\
    \ list.\n-  if (!(node->type == CMARK_NODE_ITEM && node->prev == NULL && entering))\
    \ {\n-    tmp = get_containing_block(node);\n-    renderer->in_tight_list_item\
    \ =\n-        tmp && // tmp might be NULL if there is no containing block\n- \
    \       ((tmp->type == CMARK_NODE_ITEM &&\n-          cmark_node_get_list_tight(tmp->parent))\
    \ ||\n-         (tmp && tmp->parent && tmp->parent->type == CMARK_NODE_ITEM &&\n\
    -          cmark_node_get_list_tight(tmp->parent->parent)));\n+  if (entering)\
    \ {\n+    if (node->parent && node->parent->type == CMARK_NODE_ITEM) {\n+    \
    \  renderer->in_tight_list_item = node->parent->parent->as.list.tight;\n+    }\n\
    +  } else {\n+    if (node->type == CMARK_NODE_LIST) {\n+      renderer->in_tight_list_item\
    \ =\n+        node->parent &&\n+        node->parent->type == CMARK_NODE_ITEM\
    \ &&\n+        node->parent->parent->as.list.tight;\n+    }\n   }\n \n   if (node->extension\
    \ && node->extension->commonmark_render_func) {\n@@ -228,19 +216,15 @@ static\
    \ int S_render_node(cmark_renderer *renderer, cmark_node *node,\n       LIT(\"\
    <!-- end list -->\");\n       BLANKLINE();\n     }\n+    renderer->list_number\
    \ = cmark_node_get_list_start(node);\n     break;\n \n   case CMARK_NODE_ITEM:\n\
    \     if (cmark_node_get_list_type(node->parent) == CMARK_BULLET_LIST) {\n   \
    \    marker_width = 4;\n     } else {\n-      list_number = cmark_node_get_list_start(node->parent);\n\
    +      list_number = renderer->list_number++;\n       list_delim = cmark_node_get_list_delim(node->parent);\n\
    -      tmp = node;\n-      while (tmp->prev) {\n-        tmp = tmp->prev;\n- \
    \       list_number += 1;\n-      }\n       // we ensure a width of at least 4\
    \ so\n       // we get nice transition from single digits\n       // to double\n\
    @@ -405,10 +389,12 @@ static int S_render_node(cmark_renderer *renderer, cmark_node\
    \ *node,\n     break;\n \n   case CMARK_NODE_STRONG:\n-    if (entering) {\n-\
    \      LIT(\"**\");\n-    } else {\n-      LIT(\"**\");\n+    if (node->parent\
    \ == NULL || node->parent->type != CMARK_NODE_STRONG) {\n+      if (entering)\
    \ {\n+        LIT(\"**\");\n+      } else {\n+        LIT(\"**\");\n+      }\n\
    \     }\n     break;\n "
  - "--- a/src/html.c\n+++ b/src/html.c\n@@ -364,10 +364,12 @@ static int S_render_node(cmark_html_renderer\
    \ *renderer, cmark_node *node,\n     break;\n \n   case CMARK_NODE_STRONG:\n-\
    \    if (entering) {\n-      cmark_strbuf_puts(html, \"<strong>\");\n-    } else\
    \ {\n-      cmark_strbuf_puts(html, \"</strong>\");\n+    if (node->parent ==\
    \ NULL || node->parent->type != CMARK_NODE_STRONG) {\n+      if (entering) {\n\
    +        cmark_strbuf_puts(html, \"<strong>\");\n+      } else {\n+        cmark_strbuf_puts(html,\
    \ \"</strong>\");\n+      }\n     }\n     break;\n "
  - "--- a/src/latex.c\n+++ b/src/latex.c\n@@ -385,10 +385,12 @@ static int S_render_node(cmark_renderer\
    \ *renderer, cmark_node *node,\n     break;\n \n   case CMARK_NODE_STRONG:\n-\
    \    if (entering) {\n-      LIT(\"\\\\textbf{\");\n-    } else {\n-      LIT(\"\
    }\");\n+    if (node->parent == NULL || node->parent->type != CMARK_NODE_STRONG)\
    \ {\n+      if (entering) {\n+        LIT(\"\\\\textbf{\");\n+      } else {\n\
    +        LIT(\"}\");\n+      }\n     }\n     break;\n "
  - "--- a/src/man.c\n+++ b/src/man.c\n@@ -74,7 +74,6 @@ static void S_outc(cmark_renderer\
    \ *renderer, cmark_node *node,\n \n static int S_render_node(cmark_renderer *renderer,\
    \ cmark_node *node,\n                          cmark_event_type ev_type, int options)\
    \ {\n-  cmark_node *tmp;\n   int list_number;\n   bool entering = (ev_type ==\
    \ CMARK_EVENT_ENTER);\n   bool allow_wrap = renderer->width > 0 && !(CMARK_OPT_NOBREAKS\
    \ & options);\n@@ -114,6 +113,7 @@ static int S_render_node(cmark_renderer *renderer,\
    \ cmark_node *node,\n     break;\n \n   case CMARK_NODE_LIST:\n+    renderer->list_number\
    \ = cmark_node_get_list_start(node);\n     break;\n \n   case CMARK_NODE_ITEM:\n\
    @@ -123,12 +123,7 @@ static int S_render_node(cmark_renderer *renderer, cmark_node\
    \ *node,\n       if (cmark_node_get_list_type(node->parent) == CMARK_BULLET_LIST)\
    \ {\n         LIT(\"\\\\[bu] 2\");\n       } else {\n-        list_number = cmark_node_get_list_start(node->parent);\n\
    -        tmp = node;\n-        while (tmp->prev) {\n-          tmp = tmp->prev;\n\
    -          list_number += 1;\n-        }\n+        list_number = renderer->list_number++;\n\
    \         char list_number_s[LIST_NUMBER_SIZE];\n         snprintf(list_number_s,\
    \ LIST_NUMBER_SIZE, \"\\\"%d.\\\" 4\", list_number);\n         LIT(list_number_s);\n\
    @@ -225,10 +220,12 @@ static int S_render_node(cmark_renderer *renderer, cmark_node\
    \ *node,\n     break;\n \n   case CMARK_NODE_STRONG:\n-    if (entering) {\n-\
    \      LIT(\"\\\\f[B]\");\n-    } else {\n-      LIT(\"\\\\f[]\");\n+    if (node->parent\
    \ == NULL || node->parent->type != CMARK_NODE_STRONG) {\n+      if (entering)\
    \ {\n+        LIT(\"\\\\f[B]\");\n+      } else {\n+        LIT(\"\\\\f[]\");\n\
    +      }\n     }\n     break;\n "
  - "--- a/src/plaintext.c\n+++ b/src/plaintext.c\n@@ -16,23 +16,8 @@ static CMARK_INLINE\
    \ void outc(cmark_renderer *renderer, cmark_node *node,\n   cmark_render_code_point(renderer,\
    \ c);\n }\n \n-// if node is a block node, returns node.\n-// otherwise returns\
    \ first block-level node that is an ancestor of node.\n-// if there is no block-level\
    \ ancestor, returns NULL.\n-static cmark_node *get_containing_block(cmark_node\
    \ *node) {\n-  while (node) {\n-    if (CMARK_NODE_BLOCK_P(node)) {\n-      return\
    \ node;\n-    } else {\n-      node = node->parent;\n-    }\n-  }\n-  return NULL;\n\
    -}\n-\n static int S_render_node(cmark_renderer *renderer, cmark_node *node,\n\
    \                          cmark_event_type ev_type, int options) {\n-  cmark_node\
    \ *tmp;\n   int list_number;\n   cmark_delim_type list_delim;\n   int i;\n@@ -46,14\
    \ +31,17 @@ static int S_render_node(cmark_renderer *renderer, cmark_node *node,\n\
    \   // Don't adjust tight list status til we've started the list.\n   // Otherwise\
    \ we loose the blank line between a paragraph and\n   // a following list.\n-\
    \  if (!(node->type == CMARK_NODE_ITEM && node->prev == NULL && entering)) {\n\
    -    tmp = get_containing_block(node);\n-    renderer->in_tight_list_item =\n\
    -        tmp && // tmp might be NULL if there is no containing block\n-      \
    \  ((tmp->type == CMARK_NODE_ITEM &&\n-          cmark_node_get_list_tight(tmp->parent))\
    \ ||\n-         (tmp && tmp->parent && tmp->parent->type == CMARK_NODE_ITEM &&\n\
    -          cmark_node_get_list_tight(tmp->parent->parent)));\n+  if (entering)\
    \ {\n+    if (node->parent && node->parent->type == CMARK_NODE_ITEM) {\n+    \
    \  renderer->in_tight_list_item = node->parent->parent->as.list.tight;\n+    }\n\
    +  } else {\n+    if (node->type == CMARK_NODE_LIST) {\n+      renderer->in_tight_list_item\
    \ =\n+        node->parent &&\n+        node->parent->type == CMARK_NODE_ITEM\
    \ &&\n+        node->parent->parent->as.list.tight;\n+    }\n   }\n \n   if (node->extension\
    \ && node->extension->plaintext_render_func) {\n@@ -73,19 +61,15 @@ static int\
    \ S_render_node(cmark_renderer *renderer, cmark_node *node,\n                \
    \                     node->next->type == CMARK_NODE_LIST)) {\n       CR();\n\
    \     }\n+    renderer->list_number = cmark_node_get_list_start(node);\n     break;\n\
    \ \n   case CMARK_NODE_ITEM:\n     if (cmark_node_get_list_type(node->parent)\
    \ == CMARK_BULLET_LIST) {\n       marker_width = 4;\n     } else {\n-      list_number\
    \ = cmark_node_get_list_start(node->parent);\n+      list_number = renderer->list_number++;\n\
    \       list_delim = cmark_node_get_list_delim(node->parent);\n-      tmp = node;\n\
    -      while (tmp->prev) {\n-        tmp = tmp->prev;\n-        list_number +=\
    \ 1;\n-      }\n       // we ensure a width of at least 4 so\n       // we get\
    \ nice transition from single digits\n       // to double"
  - "--- a/src/render.c\n+++ b/src/render.c\n@@ -31,13 +31,7 @@ static void S_out(cmark_renderer\
    \ *renderer, cmark_node *node,\n   cmark_chunk remainder = cmark_chunk_literal(\"\
    \");\n   int k = renderer->buffer->size - 1;\n \n-  cmark_syntax_extension *ext\
    \ = NULL;\n-  cmark_node *n = node;\n-  while (n && !ext) {\n-    ext = n->extension;\n\
    -    if (!ext)\n-      n = n->parent;\n-  }\n+  cmark_syntax_extension *ext =\
    \ node->ancestor_extension;\n   if (ext && !ext->commonmark_escape_func)\n   \
    \  ext = NULL;\n \n@@ -177,11 +171,16 @@ char *cmark_render(cmark_mem *mem, cmark_node\
    \ *root, int options, int width,\n \n   cmark_renderer renderer = {mem,   &buf,\
    \ &pref, 0,           width,\n                              0,     0,    true,\
    \  true,        false,\n-                             false, outc, S_cr,  S_blankline,\
    \ S_out,\n-                             0};\n+                             false,\
    \ 0,    outc,  S_cr,        S_blankline,\n+                             S_out,\
    \ 0};\n \n   while ((ev_type = cmark_iter_next(iter)) != CMARK_EVENT_DONE) {\n\
    \     cur = cmark_iter_get_node(iter);\n+    if (cur->extension) {\n+      cur->ancestor_extension\
    \ = cur->extension;\n+    } else if (cur->parent) {\n+      cur->ancestor_extension\
    \ = cur->parent->ancestor_extension;\n+    }\n     if (!render_node(&renderer,\
    \ cur, ev_type, options)) {\n       // a false value causes us to skip processing\n\
    \       // the node's contents.  this is used for"
  - "--- a/src/xml.c\n+++ b/src/xml.c\n@@ -11,6 +11,7 @@\n #include \"syntax_extension.h\"\
    \n \n #define BUFFER_SIZE 100\n+#define MAX_INDENT 40\n \n // Functions to convert\
    \ cmark_nodes to XML strings.\n \n@@ -26,7 +27,7 @@ struct render_state {\n \n\
    \ static CMARK_INLINE void indent(struct render_state *state) {\n   int i;\n-\
    \  for (i = 0; i < state->indent; i++) {\n+  for (i = 0; i < state->indent &&\
    \ i < MAX_INDENT; i++) {\n     cmark_strbuf_putc(state->xml, ' ');\n   }\n }"
  identifiers:
  - CVE-2023-26485
  - CWE-400
  overview: "cmark-gfm is GitHub's fork of cmark, a CommonMark parsing and rendering\
    \ library and program in C. A polynomial time complexity issue in cmark-gfm may\
    \ lead to unbounded resource exhaustion and subsequent denial of service. This\
    \ CVE covers quadratic complexity issues when parsing text which leads with either\
    \ large numbers of `_` characters. This issue has been addressed in version 0.29.0.gfm.10.\
    \ Users are advised to upgrade. Users unable to upgrade should validate that their\
    \ input comes from trusted sources.\n\n\n\n\n### Impact\n\nA polynomial time complexity\
    \ issue in cmark-gfm may lead to unbounded resource exhaustion and subsequent\
    \ denial of service.\n\n### Proof of concept\n\n```\n$ ~/cmark-gfm$ python3 -c\
    \ 'pad = \"_\" * 100000; print(pad + \".\" + pad, end=\"\")' | time ./build/src/cmark-gfm\
    \ --to plaintext\n```\n\nIncreasing the number 10000 in the above commands causes\
    \ the running time to increase quadratically.\n\n### Patches\n\nThis vulnerability\
    \ have been patched in 0.29.0.gfm.10.\n\n### Note on cmark and cmark-gfm\n\nXXX:\
    \ TBD\n\n[cmark-gfm](https://github.com/github/cmark-gfm) is a fork of [cmark](https://github.com/commonmark/cmark)\
    \ that adds the GitHub Flavored Markdown extensions. The two codebases have diverged\
    \ over time, but share a common core. These bugs affect both `cmark` and `cmark-gfm`.\
    \ \n\n### Credit\n\nWe would like to thank @gravypod for reporting this vulnerability.\n\
    \n### References\n\nhttps://en.wikipedia.org/wiki/Time_complexity\n\n### For more\
    \ information\n\nIf you have any questions or comments about this advisory:\n\n\
    * Open an issue in [github/cmark-gfm](https://github.com/github/cmark-gfm)\n"
  references:
  - source: security-advisories@github.com
    tags:
    - Patch
    url: https://github.com/github/cmark-gfm/commit/07a66c9bc341f902878e37d7da8647d6ef150987
  - source: security-advisories@github.com
    tags:
    - Exploit
    - Vendor Advisory
    url: https://github.com/github/cmark-gfm/security/advisories/GHSA-r8vr-c48j-fcc5
  title: "cmark-gfm is GitHub's fork of cmark, a CommonMark parsing and rendering\
    \ library and program in C. A polynomial time complexity issue in cmark-gfm may\
    \ lead to unbounded resource exhaustion and subsequent denial of service. This\
    \ CVE covers quadratic complexity issues when parsing text which leads with either\
    \ large numbers of `_` characters. This issue has been addressed in version 0.29.0.gfm.10.\
    \ Users are advised to upgrade. Users unable to upgrade should validate that their\
    \ input comes from trusted sources.\n\n\n\n\n### Impact\n\nA polynomial time complexity\
    \ issue in cmark-gfm may lead to unbounded resource exhaustion and subsequent\
    \ denial of service.\n\n### Proof of concept\n\n```\n$ ~/cmark-gfm$ python3 -c\
    \ 'pad = \"_\" * 100000; print(pad + \".\" + pad, end=\"\")' | time ./build/src/cmark-gfm\
    \ --to plaintext\n```\n\nIncreasing the number 10000 in the above commands causes\
    \ the running time to increase quadratically.\n\n### Patches\n\nThis vulnerability\
    \ have been patched in 0.29.0.gfm.10.\n\n### Note on cmark and cmark-gfm\n\nXXX:\
    \ TBD\n\n[cmark-gfm](https://github.com/github/cmark-gfm) is a fork of [cmark](https://github.com/commonmark/cmark)\
    \ that adds the GitHub Flavored Markdown extensions. The two codebases have diverged\
    \ over time, but share a common core. These bugs affect both `cmark` and `cmark-gfm`.\
    \ \n\n### Credit\n\nWe would like to thank @gravypod for reporting this vulnerability.\n\
    \n### References\n\nhttps://en.wikipedia.org/wiki/Time_complexity\n\n### For more\
    \ information\n\nIf you have any questions or comments about this advisory:\n\n\
    * Open an issue in [github/cmark-gfm](https://github.com/github/cmark-gfm)\n"
- diff_content:
  - "--- a/src/normals.c\n+++ b/src/normals.c\n@@ -142,7 +142,8 @@ stl_fix_normal_directions(stl_file\
    \ *stl) {\n         }\n       }\n       /* If this edge of the facet is connected:\
    \ */\n-      if(stl->neighbors_start[facet_num].neighbor[j] != -1) {\n+      if(stl->neighbors_start[facet_num].neighbor[j]\
    \ != -1 &&\n+         stl->neighbors_start[facet_num].neighbor[j] < stl->stats.number_of_facets*sizeof(char))\
    \ {\n         /* If we haven't fixed this facet yet, add it to the list: */\n\
    \         if(norm_sw[stl->neighbors_start[facet_num].neighbor[j]] != 1) {\n  \
    \         /* Add node to beginning of list. */"
  identifiers:
  - CVE-2022-38072
  - CWE-129
  overview: An improper array index validation vulnerability exists in the stl_fix_normal_directions
    functionality of ADMesh Master Commit 767a105 and v0.98.4. A specially-crafted
    stl file can lead to a heap buffer overflow. An attacker can provide a malicious
    file to trigger this vulnerability.
  references:
  - source: talos-cna@cisco.com
    tags:
    - Patch
    url: https://github.com/admesh/admesh/commit/5fab257268a0ee6f832c18d72af89810a29fbd5f
  - source: talos-cna@cisco.com
    tags:
    - Exploit
    - Technical Description
    - Third Party Advisory
    url: https://talosintelligence.com/vulnerability_reports/TALOS-2022-1594
  title: An improper array index validation vulnerability exists in the stl_fix_normal_directions
    functionality of ADMesh Master Commit 767a105 and v0.98.4. A specially-crafted
    stl file can lead to a heap buffer overflow. An attacker can provide a malicious
    file to trigger this vulnerability.
- diff_content:
  - "--- a/fs/btrfs/ioctl.c\n+++ b/fs/btrfs/ioctl.c\n@@ -3732,7 +3732,9 @@ static\
    \ long btrfs_ioctl_qgroup_assign(struct file *file, void __user *arg)\n \t}\n\
    \ \n \t/* update qgroup status and info */\n+\tmutex_lock(&fs_info->qgroup_ioctl_lock);\n\
    \ \terr = btrfs_run_qgroups(trans);\n+\tmutex_unlock(&fs_info->qgroup_ioctl_lock);\n\
    \ \tif (err < 0)\n \t\tbtrfs_handle_fs_error(fs_info, err,\n \t\t\t\t      \"\
    failed to update qgroup status and info\");"
  - "--- a/fs/btrfs/qgroup.c\n+++ b/fs/btrfs/qgroup.c\n@@ -2828,13 +2828,22 @@ int\
    \ btrfs_qgroup_account_extents(struct btrfs_trans_handle *trans)\n }\n \n /*\n\
    - * called from commit_transaction. Writes all changed qgroups to disk.\n+ * Writes\
    \ all changed qgroups to disk.\n+ * Called by the transaction commit path and\
    \ the qgroup assign ioctl.\n  */\n int btrfs_run_qgroups(struct btrfs_trans_handle\
    \ *trans)\n {\n \tstruct btrfs_fs_info *fs_info = trans->fs_info;\n \tint ret\
    \ = 0;\n \n+\t/*\n+\t * In case we are called from the qgroup assign ioctl, assert\
    \ that we\n+\t * are holding the qgroup_ioctl_lock, otherwise we can race with\
    \ a quota\n+\t * disable operation (ioctl) and access a freed quota root.\n+\t\
    \ */\n+\tif (trans->transaction->state != TRANS_STATE_COMMIT_DOING)\n+\t\tlockdep_assert_held(&fs_info->qgroup_ioctl_lock);\n\
    +\n \tif (!fs_info->quota_root)\n \t\treturn ret;\n "
  identifiers:
  - CVE-2023-1611
  - CWE-416
  overview: A use-after-free flaw was found in btrfs_search_slot in fs/btrfs/ctree.c
    in btrfs in the Linux Kernel.This flaw allows an attacker to crash the system
    and possibly cause a kernel information lea
  references:
  - source: secalert@redhat.com
    tags:
    - Issue Tracking
    - Patch
    - Third Party Advisory
    url: https://bugzilla.redhat.com/show_bug.cgi?id=2181342
  - source: secalert@redhat.com
    tags:
    - Patch
    url: https://github.com/torvalds/linux/commit/2f1a6be12ab6c8470d5776e68644726c94257c54
  - source: secalert@redhat.com
    tags:
    - Mailing List
    - Third Party Advisory
    url: https://lists.debian.org/debian-lts-announce/2023/05/msg00005.html
  - source: secalert@redhat.com
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/5QCM6XO4HSPLGR3DFYWFRIA3GCBIHZR4/
  - source: secalert@redhat.com
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/ZWECAZ7V7EPSXMINO6Q6KWNKDY2CO6ZW/
  - source: secalert@redhat.com
    url: https://lore.kernel.org/linux-btrfs/35b9a70650ea947387cf352914a8774b4f7e8a6f.1679481128.git.fdmanana%40suse.com/
  title: A use-after-free flaw was found in btrfs_search_slot in fs/btrfs/ctree.c
    in btrfs in the Linux Kernel.This flaw allows an attacker to crash the system
    and possibly cause a kernel information lea
- diff_content:
  - "--- a/usr.sbin/smtpd/envelope.c\n+++ b/usr.sbin/smtpd/envelope.c\n@@ -1,4 +1,4\
    \ @@\n-/*\t$OpenBSD: envelope.c,v 1.50 2022/09/24 17:08:32 millert Exp $\t*/\n\
    +/*\t$OpenBSD: envelope.c,v 1.51 2023/02/06 18:35:52 semarie Exp $\t*/\n \n /*\n\
    \  * Copyright (c) 2013 Eric Faurot <eric@openbsd.org>\n@@ -270,24 +270,28 @@\
    \ ascii_load_string(char *dest, char *buf, size_t len)\n static int\n ascii_load_sockaddr(struct\
    \ sockaddr_storage *ss, char *buf)\n {\n-\tstruct sockaddr_in6 ssin6;\n-\tstruct\
    \ sockaddr_in  ssin;\n-\n-\tmemset(&ssin, 0, sizeof ssin);\n-\tmemset(&ssin6,\
    \ 0, sizeof ssin6);\n-\n \tif (!strcmp(\"local\", buf)) {\n \t\tss->ss_family\
    \ = AF_LOCAL;\n \t}\n \telse if (buf[0] == '[' && buf[strlen(buf)-1] == ']') {\n\
    +\t\tstruct addrinfo hints, *res0;\n+\t\t\n \t\tbuf[strlen(buf)-1] = '\\0';\n\
    -\t\tif (inet_pton(AF_INET6, buf+1, &ssin6.sin6_addr) != 1)\n+\n+\t\t/* getaddrinfo()\
    \ is used to support scoped addresses. */\n+\t\tmemset(&hints, 0, sizeof(hints));\n\
    +\t\thints.ai_family = AF_INET6;\n+\t\thints.ai_flags = AI_NUMERICHOST;\n+\t\t\
    if (getaddrinfo(buf+1, NULL, &hints, &res0) != 0)\n \t\t\treturn 0;\n-\t\tssin6.sin6_family\
    \ = AF_INET6;\n-\t\tmemcpy(ss, &ssin6, sizeof(ssin6));\n-\t\tss->ss_len = sizeof(struct\
    \ sockaddr_in6);\n+\t\tmemcpy(ss, res0->ai_addr, res0->ai_addrlen);\n+\t\tss->ss_len\
    \ = res0->ai_addrlen;\n+\t\tfreeaddrinfo(res0);\n \t}\n \telse {\n+\t\tstruct\
    \ sockaddr_in ssin;\n+\n+\t\tmemset(&ssin, 0, sizeof ssin);\n \t\tif (inet_pton(AF_INET,\
    \ buf, &ssin.sin_addr) != 1)\n \t\t\treturn 0;\n \t\tssin.sin_family = AF_INET;"
  identifiers:
  - CVE-2023-29323
  - NVD-CWE-noinfo
  overview: ascii_load_sockaddr in smtpd in OpenBSD before 7.1 errata 024 and 7.2
    before errata 020, and OpenSMTPD Portable before 7.0.0-portable commit f748277,
    can abort upon a connection from a local, scoped IPv6 address.
  references:
  - source: cve@mitre.org
    tags:
    - Product
    url: https://cvsweb.openbsd.org/cgi-bin/cvsweb/src/usr.sbin/smtpd/envelope.c.diff?r1=1.49&r2=1.49.4.1&f=h
  - source: cve@mitre.org
    tags:
    - Product
    url: https://cvsweb.openbsd.org/cgi-bin/cvsweb/src/usr.sbin/smtpd/envelope.c.diff?r1=1.50&r2=1.50.4.1&f=h
  - source: cve@mitre.org
    tags:
    - Product
    url: https://cvsweb.openbsd.org/cgi-bin/cvsweb/src/usr.sbin/smtpd/envelope.c.diff?r1=1.50&r2=1.51&f=h
  - source: cve@mitre.org
    tags:
    - Patch
    url: https://ftp.openbsd.org/pub/OpenBSD/patches/7.1/common/024_smtpd.patch.sig
  - source: cve@mitre.org
    tags:
    - Patch
    url: https://ftp.openbsd.org/pub/OpenBSD/patches/7.2/common/020_smtpd.patch.sig
  - source: cve@mitre.org
    tags:
    - Patch
    url: https://github.com/OpenSMTPD/OpenSMTPD/commit/41d0eae481f538956b1f1fbadfb535043454061f
  - source: cve@mitre.org
    tags:
    - Patch
    url: https://github.com/openbsd/src/commit/f748277ed1fc7065ae8998d61ed78b9ab1e55fae
  - source: cve@mitre.org
    url: https://security.netapp.com/advisory/ntap-20230526-0006/
  title: ascii_load_sockaddr in smtpd in OpenBSD before 7.1 errata 024 and 7.2 before
    errata 020, and OpenSMTPD Portable before 7.0.0-portable commit f748277, can abort
    upon a connection from a local, scoped IPv6 address.
- diff_content:
  - "--- a/drivers/hwmon/xgene-hwmon.c\n+++ b/drivers/hwmon/xgene-hwmon.c\n@@ -761,6\
    \ +761,7 @@ static int xgene_hwmon_remove(struct platform_device *pdev)\n {\n\
    \ \tstruct xgene_hwmon_dev *ctx = platform_get_drvdata(pdev);\n \n+\tcancel_work_sync(&ctx->workq);\n\
    \ \thwmon_device_unregister(ctx->hwmon_dev);\n \tkfifo_free(&ctx->async_msg_fifo);\n\
    \ \tif (acpi_disabled)"
  identifiers:
  - CVE-2023-1855
  - CWE-416
  overview: A use-after-free flaw was found in xgene_hwmon_remove in drivers/hwmon/xgene-hwmon.c
    in the Hardware Monitoring Linux Kernel Driver (xgene-hwmon). This flaw could
    allow a local attacker to crash the system due to a race problem. This vulnerability
    could even lead to a kernel information leak problem.
  references:
  - source: secalert@redhat.com
    tags:
    - Patch
    url: https://github.com/torvalds/linux/commit/cb090e64cf25602b9adaf32d5dfc9c8bec493cd1
  - source: secalert@redhat.com
    tags:
    - Mailing List
    - Third Party Advisory
    url: https://lists.debian.org/debian-lts-announce/2023/05/msg00005.html
  - source: secalert@redhat.com
    tags:
    - Mailing List
    - Third Party Advisory
    url: https://lists.debian.org/debian-lts-announce/2023/05/msg00006.html
  - source: secalert@redhat.com
    url: https://lore.kernel.org/all/20230318122758.2140868-1-linux%40roeck-us.net/
  title: A use-after-free flaw was found in xgene_hwmon_remove in drivers/hwmon/xgene-hwmon.c
    in the Hardware Monitoring Linux Kernel Driver (xgene-hwmon). This flaw could
    allow a local attacker to crash the system due to a race problem. This vulnerability
    could even lead to a kernel information leak problem.
- diff_content:
  - "--- a/src/libbz3.c\n+++ b/src/libbz3.c\n@@ -502,8 +502,8 @@ BZIP3_API struct\
    \ bz3_state * bz3_new(s32 block_size) {\n     bz3_state->cm_state = malloc(sizeof(state));\n\
    \ \n     bz3_state->swap_buffer = malloc(bz3_bound(block_size));\n-    bz3_state->sais_array\
    \ = malloc((block_size + 128) * sizeof(s32));\n-    memset(bz3_state->sais_array,\
    \ 0, sizeof(s32) * (block_size + 128));\n+    bz3_state->sais_array = malloc(BWT_BOUND(block_size)\
    \ * sizeof(s32));\n+    memset(bz3_state->sais_array, 0, sizeof(s32) * BWT_BOUND(block_size));\n\
    \ \n     bz3_state->lzp_lut = calloc(1 << LZP_DICTIONARY, sizeof(s32));\n \n@@\
    \ -682,6 +682,8 @@ BZIP3_API s32 bz3_decode_block(struct bz3_state * state, u8\
    \ * buffer, s32 data_s\n     }\n \n     // Undo BWT\n+    memset(state->sais_array,\
    \ 0, sizeof(s32) * BWT_BOUND(state->block_size));\n+    memset(b2, 0, size_src);\n\
    \     if (libsais_unbwt(b1, b2, state->sais_array, size_src, NULL, bwt_idx) <\
    \ 0) {\n         state->last_error = BZ3_ERR_BWT;\n         return -1;"
  identifiers:
  - CVE-2023-29416
  - CWE-787
  overview: An issue was discovered in libbzip3.a in bzip3 before 1.3.0. A bz3_decode_block
    out-of-bounds write can occur with a crafted archive because bzip3 does not follow
    the required procedure for interacting with libsais.
  references:
  - source: cve@mitre.org
    tags:
    - Patch
    url: https://github.com/kspalaiologos/bzip3/commit/bfa5bf82b53715dfedf048e5859a46cf248668ff
  - source: cve@mitre.org
    tags:
    - Release Notes
    url: https://github.com/kspalaiologos/bzip3/compare/1.2.3...1.3.0
  - source: cve@mitre.org
    tags:
    - Exploit
    - Issue Tracking
    - Patch
    url: https://github.com/kspalaiologos/bzip3/issues/92
  - source: cve@mitre.org
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/4JLSE25SV7K2NB6FTFT4UHJOJUHBHYHY/
  - source: cve@mitre.org
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/NA7S7HDUAINOTCSWQZ5LIW756DYY22V2/
  - source: cve@mitre.org
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/NMLFV2FJK3CM7NJLVPZI5RUAFQZICPWW/
  title: An issue was discovered in libbzip3.a in bzip3 before 1.3.0. A bz3_decode_block
    out-of-bounds write can occur with a crafted archive because bzip3 does not follow
    the required procedure for interacting with libsais.
- diff_content:
  - "--- a/src/libbz3.c\n+++ b/src/libbz3.c\n@@ -61,8 +61,15 @@ static const u32 crc32Table[256]\
    \ = {\n };\n \n static u32 crc32sum(u32 crc, u8 * RESTRICT buf, size_t size) {\n\
    -    while (size--) crc = crc32Table[(crc ^ *(buf++)) & 0xff] ^ (crc >> 8);\n\
    -    return crc;\n+    // Test endianness. The code needs to be different for\
    \ LE and BE systems.\n+    u32 test = 1;\n+    if (*(u8 *) &test) {\n+       \
    \ while (size--) crc = crc32Table[(crc ^ *(buf++)) & 0xff] ^ (crc >> 8);\n+  \
    \      return crc;\n+    } else {\n+        while (size--) crc = crc32Table[((crc\
    \ >> 24) ^ *(buf++)) & 0xff] ^ (crc << 8);\n+        return crc;\n+    }\n }\n\
    \ \n /* LZP code. These constants were manually tuned to give the best compression\
    \ ratio while using relatively"
  - "--- a/src/main.c\n+++ b/src/main.c\n@@ -242,6 +242,10 @@ static int process(FILE\
    \ * input_des, FILE * output_des, int mode, int block_size\n                 new_size\
    \ = read_neutral_s32(byteswap_buf);\n                 xread_noeof(&byteswap_buf,\
    \ 1, 4, input_des);\n                 old_size = read_neutral_s32(byteswap_buf);\n\
    +                if(old_size > block_size + 31) {\n+                    fprintf(stderr,\
    \ \"Failed to decode a block: Inconsistent headers.\\n\");\n+                \
    \    return 1;\n+                }\n                 xread_noeof(buffer, 1, new_size,\
    \ input_des);\n                 bytes_read += 8 + new_size;\n                \
    \ if (bz3_decode_block(state, buffer, new_size, old_size) == -1) {\n@@ -259,6\
    \ +263,10 @@ static int process(FILE * input_des, FILE * output_des, int mode,\
    \ int block_size\n                 new_size = read_neutral_s32(byteswap_buf);\n\
    \                 xread_noeof(&byteswap_buf, 1, 4, input_des);\n             \
    \    old_size = read_neutral_s32(byteswap_buf);\n+                if(old_size\
    \ > block_size + 31) {\n+                    fprintf(stderr, \"Failed to decode\
    \ a block: Inconsistent headers.\\n\");\n+                    return 1;\n+   \
    \             }\n                 xread_noeof(buffer, 1, new_size, input_des);\n\
    \                 bytes_read += 8 + new_size;\n                 if (bz3_decode_block(state,\
    \ buffer, new_size, old_size) == -1) {\n@@ -332,6 +340,10 @@ static int process(FILE\
    \ * input_des, FILE * output_des, int mode, int block_size\n                 \
    \    sizes[i] = read_neutral_s32(byteswap_buf);\n                     xread_noeof(&byteswap_buf,\
    \ 1, 4, input_des);\n                     old_sizes[i] = read_neutral_s32(byteswap_buf);\n\
    +                    if(old_sizes[i] > block_size + 31) {\n+                 \
    \       fprintf(stderr, \"Failed to decode a block: Inconsistent headers.\\n\"\
    );\n+                        return 1;\n+                    }\n             \
    \        xread_noeof(buffers[i], 1, sizes[i], input_des);\n                  \
    \   bytes_read += 8 + sizes[i];\n                 }\n@@ -356,6 +368,10 @@ static\
    \ int process(FILE * input_des, FILE * output_des, int mode, int block_size\n\
    \                     sizes[i] = read_neutral_s32(byteswap_buf);\n           \
    \          xread_noeof(&byteswap_buf, 1, 4, input_des);\n                    \
    \ old_sizes[i] = read_neutral_s32(byteswap_buf);\n+                    if(old_sizes[i]\
    \ > block_size + 31) {\n+                        fprintf(stderr, \"Failed to decode\
    \ a block: Inconsistent headers.\\n\");\n+                        return 1;\n\
    +                    }\n                     xread_noeof(buffers[i], 1, sizes[i],\
    \ input_des);\n                     bytes_read += 8 + sizes[i];\n            \
    \     }\n@@ -691,6 +707,9 @@ int main(int argc, char * argv[]) {\n     output_des\
    \ = mode != MODE_TEST ? open_output(output, force) : NULL;\n     input_des = open_input(input);\n\
    \ \n+    if(output != f2)\n+        free(output);\n+\n     int r = process(input_des,\
    \ output_des, mode, block_size, workers, verbose, input);\n \n     fclose(input_des);"
  identifiers:
  - CVE-2023-29418
  - CWE-125
  overview: An issue was discovered in libbzip3.a in bzip3 before 1.2.3. There is
    an xwrite out-of-bounds read.
  references:
  - source: cve@mitre.org
    tags:
    - Patch
    url: https://github.com/kspalaiologos/bzip3/commit/aae16d107f804f69000c09cd92027a140968cc9d
  - source: cve@mitre.org
    tags:
    - Release Notes
    url: https://github.com/kspalaiologos/bzip3/compare/1.2.2...1.2.3
  - source: cve@mitre.org
    tags:
    - Exploit
    - Issue Tracking
    - Patch
    url: https://github.com/kspalaiologos/bzip3/issues/92
  - source: cve@mitre.org
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/4JLSE25SV7K2NB6FTFT4UHJOJUHBHYHY/
  - source: cve@mitre.org
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/NA7S7HDUAINOTCSWQZ5LIW756DYY22V2/
  - source: cve@mitre.org
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/NMLFV2FJK3CM7NJLVPZI5RUAFQZICPWW/
  title: An issue was discovered in libbzip3.a in bzip3 before 1.2.3. There is an
    xwrite out-of-bounds read.
- diff_content:
  - "--- a/src/libbz3.c\n+++ b/src/libbz3.c\n@@ -257,28 +257,33 @@ static s32 mrlec(u8\
    \ * in, s32 inlen, u8 * out) {\n     return op;\n }\n \n-static void mrled(u8\
    \ * RESTRICT in, u8 * RESTRICT out, s32 outlen) {\n+static int mrled(u8 * RESTRICT\
    \ in, u8 * RESTRICT out, s32 outlen, s32 maxin) {\n     s32 op = 0, ip = 0;\n\
    \ \n     s32 c, pc = -1;\n     s32 t[256] = { 0 };\n     s32 run = 0;\n \n+  \
    \  if(maxin < 32)\n+        return 1;\n+\n     for (s32 i = 0; i < 32; ++i) {\n\
    \         c = in[ip++];\n         for (s32 j = 0; j < 8; ++j) t[i * 8 + j] = (c\
    \ >> j) & 1;\n     }\n \n-    while (op < outlen) {\n+    while (op < outlen &&\
    \ ip < maxin) {\n         c = in[ip++];\n         if (t[c]) {\n-            for\
    \ (run = 0; (pc = in[ip++]) == 255; run += 255)\n+            for (run = 0; (pc\
    \ = in[ip++]) == 255 && ip < maxin; run += 255)\n                 ;\n        \
    \     run += pc + 1;\n             for (; run > 0 && op < outlen; --run) out[op++]\
    \ = c;\n         } else\n             out[op++] = c;\n     }\n+\n+    return op\
    \ != outlen;\n }\n \n /* The entropy coder. Uses an arithmetic coder implementation\
    \ outlined in Matt Mahoney's DCE. */\n@@ -694,7 +699,11 @@ BZIP3_API s32 bz3_decode_block(struct\
    \ bz3_state * state, u8 * buffer, s32 data_s\n     }\n \n     if (model & 4) {\n\
    -        mrled(b1, b2, orig_size);\n+        int err = mrled(b1, b2, orig_size,\
    \ size_src);\n+        if(err) {\n+            state->last_error = BZ3_ERR_CRC;\n\
    +            return -1;\n+        }\n         size_src = orig_size;\n        \
    \ swap(b1, b2);\n     }"
  identifiers:
  - CVE-2023-29419
  - CWE-125
  overview: An issue was discovered in libbzip3.a in bzip3 before 1.2.3. There is
    a bz3_decode_block out-of-bounds read.
  references:
  - source: cve@mitre.org
    tags:
    - Patch
    url: https://github.com/kspalaiologos/bzip3/commit/8ec8ce7d3d58bf42dabc47e4cc53aa27051bd602
  - source: cve@mitre.org
    tags:
    - Release Notes
    url: https://github.com/kspalaiologos/bzip3/compare/1.2.2...1.2.3
  - source: cve@mitre.org
    tags:
    - Exploit
    - Issue Tracking
    - Patch
    url: https://github.com/kspalaiologos/bzip3/issues/92
  - source: cve@mitre.org
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/4JLSE25SV7K2NB6FTFT4UHJOJUHBHYHY/
  - source: cve@mitre.org
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/NA7S7HDUAINOTCSWQZ5LIW756DYY22V2/
  - source: cve@mitre.org
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/NMLFV2FJK3CM7NJLVPZI5RUAFQZICPWW/
  title: An issue was discovered in libbzip3.a in bzip3 before 1.2.3. There is a bz3_decode_block
    out-of-bounds read.
- diff_content:
  - "--- a/src/libbz3.c\n+++ b/src/libbz3.c\n@@ -620,7 +620,7 @@ BZIP3_API s32 bz3_decode_block(struct\
    \ bz3_state * state, u8 * buffer, s32 data_s\n     }\n \n     if (bwt_idx == -1)\
    \ {\n-        if (data_size - 8 > 64) {\n+        if (data_size - 8 > 64 || data_size\
    \ < 8) {\n             state->last_error = BZ3_ERR_MALFORMED_HEADER;\n       \
    \      return -1;\n         }"
  identifiers:
  - CVE-2023-29420
  - CWE-119
  overview: An issue was discovered in libbzip3.a in bzip3 before 1.2.3. There is
    a crash caused by an invalid memmove in bz3_decode_block.
  references:
  - source: cve@mitre.org
    tags:
    - Patch
    url: https://github.com/kspalaiologos/bzip3/commit/bb06deb85f1c249838eb938e0dab271d4194f8fa
  - source: cve@mitre.org
    tags:
    - Release Notes
    url: https://github.com/kspalaiologos/bzip3/compare/1.2.2...1.2.3
  - source: cve@mitre.org
    tags:
    - Exploit
    - Issue Tracking
    - Patch
    url: https://github.com/kspalaiologos/bzip3/issues/92
  - source: cve@mitre.org
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/4JLSE25SV7K2NB6FTFT4UHJOJUHBHYHY/
  - source: cve@mitre.org
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/NA7S7HDUAINOTCSWQZ5LIW756DYY22V2/
  - source: cve@mitre.org
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/NMLFV2FJK3CM7NJLVPZI5RUAFQZICPWW/
  title: An issue was discovered in libbzip3.a in bzip3 before 1.2.3. There is a crash
    caused by an invalid memmove in bz3_decode_block.
- diff_content:
  - "--- a/ntp.c\n+++ b/ntp.c\n@@ -54,30 +54,21 @@ p_ntp_time(netdissect_options *ndo,\n\
    \ \tif (i) {\n \t    int64_t seconds_64bit = (int64_t)i - JAN_1970;\n \t    time_t\
    \ seconds;\n-\t    struct tm *tm;\n \t    char time_buf[128];\n+\t    const char\
    \ *time_string;\n \n \t    seconds = (time_t)seconds_64bit;\n \t    if (seconds\
    \ != seconds_64bit) {\n \t\t/*\n \t\t * It doesn't fit into a time_t, so we can't\
    \ hand it\n \t\t * to gmtime.\n \t\t */\n-\t\tND_PRINT(\" (unrepresentable)\"\
    );\n+\t\ttime_string = \"[Time is too large to fit into a time_t]\";\n \t    }\
    \ else {\n-\t\ttm = gmtime(&seconds);\n-\t\tif (tm == NULL) {\n-\t\t    /*\n-\t\
    \t     * gmtime() can't handle it.\n-\t\t     * (Yes, that might happen with some\
    \ version of\n-\t\t     * Microsoft's C library.)\n-\t\t     */\n-\t\t    ND_PRINT(\"\
    \ (unrepresentable)\");\n-\t\t} else {\n-\t\t    /* use ISO 8601 (RFC3339) format\
    \ */\n-\t\t    strftime(time_buf, sizeof (time_buf), \"%Y-%m-%dT%H:%M:%SZ\", tm);\n\
    -\t\t    ND_PRINT(\" (%s)\", time_buf);\n-\t\t}\n+\t\t/* use ISO 8601 (RFC3339)\
    \ format */\n+\t\ttime_string = nd_format_time(time_buf, sizeof (time_buf),\n\
    +\t\t  \"%Y-%m-%dT%H:%M:%SZ\", gmtime(&seconds));\n \t    }\n+\t    ND_PRINT(\"\
    \ (%s)\", time_string);\n \t}\n }"
  - "--- a/print-ahcp.c\n+++ b/print-ahcp.c\n@@ -102,18 +102,14 @@ ahcp_time_print(netdissect_options\
    \ *ndo,\n                 const u_char *cp, uint8_t len)\n {\n \ttime_t t;\n-\t\
    struct tm *tm;\n-\tchar buf[BUFSIZE];\n+\tchar buf[sizeof(\"-yyyyyyyyyy-mm-dd\
    \ hh:mm:ss UTC\")];\n \n \tif (len != 4)\n \t\tgoto invalid;\n \tt = GET_BE_U_4(cp);\n\
    -\tif (NULL == (tm = gmtime(&t)))\n-\t\tND_PRINT(\": gmtime() error\");\n-\telse\
    \ if (0 == strftime(buf, sizeof(buf), \"%Y-%m-%d %H:%M:%S\", tm))\n-\t\tND_PRINT(\"\
    : strftime() error\");\n-\telse\n-\t\tND_PRINT(\": %s UTC\", buf);\n+\tND_PRINT(\"\
    : %s\",\n+\t    nd_format_time(buf, sizeof(buf), \"%Y-%m-%d %H:%M:%S UTC\",\n\
    +\t      gmtime(&t)));\n \treturn;\n \n invalid:"
  - "--- a/print-arista.c\n+++ b/print-arista.c\n@@ -10,7 +10,6 @@\n \n #include \"\
    netdissect.h\"\n #include \"extract.h\"\n-#include \"addrtoname.h\"\n \n /*\n\
    \ \n@@ -93,17 +92,13 @@ arista_print_date_hms_time(netdissect_options *ndo, uint32_t\
    \ seconds,\n \t\tuint32_t nanoseconds)\n {\n \ttime_t ts;\n-\tstruct tm *tm;\n\
    -\tchar buf[BUFSIZE];\n+\tchar buf[sizeof(\"-yyyyyyyyyy-mm-dd hh:mm:ss\")];\n\
    \ \n \tts = seconds + (nanoseconds / 1000000000);\n \tnanoseconds %= 1000000000;\n\
    -\tif (NULL == (tm = gmtime(&ts)))\n-\t\tND_PRINT(\"gmtime() error\");\n-\telse\
    \ if (0 == strftime(buf, sizeof(buf), \"%Y-%m-%d %H:%M:%S\", tm))\n-\t\tND_PRINT(\"\
    strftime() error\");\n-\telse\n-\t\tND_PRINT(\"%s.%09u\", buf, nanoseconds);\n\
    +\tND_PRINT(\"%s.%09u\",\n+\t    nd_format_time(buf, sizeof(buf), \"%Y-%m-%d %H:%M:%S\"\
    ,\n+\t       gmtime(&ts)), nanoseconds);\n }\n \n int"
  - "--- a/print-rx.c\n+++ b/print-rx.c\n@@ -794,12 +794,12 @@ rx_cache_find(netdissect_options\
    \ *ndo, const struct rx_header *rxh,\n \t\t\tND_PRINT(\" %\" PRIu64, _i); \\\n\
    \ \t\t}\n \n-#define DATEOUT() { time_t _t; struct tm *tm; char str[256]; \\\n\
    +#define DATEOUT() { time_t _t; char str[256]; \\\n \t\t\t_t = (time_t) GET_BE_S_4(bp);\
    \ \\\n \t\t\tbp += sizeof(int32_t); \\\n-\t\t\ttm = localtime(&_t); \\\n-\t\t\t\
    strftime(str, 256, \"%Y/%m/%d %H:%M:%S\", tm); \\\n-\t\t\tND_PRINT(\" %s\", str);\
    \ \\\n+\t\t\tND_PRINT(\" %s\", \\\n+\t\t\t    nd_format_time(str, sizeof(str),\
    \ \\\n+\t\t\t      \"%Y/%m/%d %H:%M:%S\", localtime(&_t))); \\\n \t\t}\n \n #define\
    \ STOREATTROUT() { uint32_t mask, _i; \\"
  - "--- a/print-zep.c\n+++ b/print-zep.c\n@@ -82,12 +82,11 @@ static void zep_print_ts(netdissect_options\
    \ *ndo, const u_char *p)\n \t */\n \tif (i) {\n \t\ttime_t seconds = i - JAN_1970;\n\
    -\t\tstruct tm *tm;\n \t\tchar time_buf[128];\n \n-\t\ttm = localtime(&seconds);\n\
    -\t\tstrftime(time_buf, sizeof (time_buf), \"%Y/%m/%d %H:%M:%S\", tm);\n-\t\t\
    ND_PRINT(\" (%s)\", time_buf);\n+\t\tND_PRINT(\" (%s)\",\n+\t\t    nd_format_time(time_buf,\
    \ sizeof (time_buf), \"%Y/%m/%d %H:%M:%S\",\n+\t\t      localtime(&seconds)));\n\
    \ \t}\n }\n "
  - "--- a/smbutil.c\n+++ b/smbutil.c\n@@ -768,9 +768,8 @@ smb_fdata1(netdissect_options\
    \ *ndo,\n \tcase 'T':\n \t  {\n \t    time_t t;\n-\t    struct tm *lt;\n \t  \
    \  const char *tstring;\n-\t    char buffer[sizeof(\"Www Mmm dd hh:mm:ss yyyyy\\\
    n\")];\n+\t    char buffer[sizeof(\"Www Mmm dd hh:mm:ss yyyyy\")];\n \t    uint32_t\
    \ x;\n \n \t    switch (atoi(fmt + 1)) {\n@@ -800,16 +799,11 @@ smb_fdata1(netdissect_options\
    \ *ndo,\n \t\tbreak;\n \t    }\n \t    if (t != 0) {\n-\t\tlt = localtime(&t);\n\
    -\t\tif (lt != NULL) {\n-\t\t    strftime(buffer, sizeof(buffer), \"%a %b %e %T\
    \ %Y%n\", lt);\n-\t\t    tstring = buffer;\n-\t\t}\n-\t\telse\n-\t\t    tstring\
    \ = \"(Can't convert time)\\n\";\n+\t\t    tstring = nd_format_time(buffer, sizeof(buffer),\
    \ \"%a %b %e %T %Y\",\n+\t\t    localtime(&t));\n \t    } else\n-\t\ttstring =\
    \ \"NULL\\n\";\n-\t    ND_PRINT(\"%s\", tstring);\n+\t\ttstring = \"NULL\";\n\
    +\t    ND_PRINT(\"%s\\n\", tstring);\n \t    fmt++;\n \t    while (ND_ASCII_ISDIGIT(*fmt))\n\
    \ \t\tfmt++;"
  - "--- a/tcpdump.c\n+++ b/tcpdump.c\n@@ -843,6 +843,8 @@ MakeFilename(char *buffer,\
    \ char *orig_name, int cnt, int max_chars)\n         char *filename = malloc(PATH_MAX\
    \ + 1);\n         if (filename == NULL)\n             error(\"%s: malloc\", __func__);\n\
    +        if (strlen(orig_name) == 0)\n+            error(\"an empty string is\
    \ not a valid file name\");\n \n         /* Process with strftime if Gflag is\
    \ set. */\n         if (Gflag != 0) {\n@@ -854,9 +856,25 @@ MakeFilename(char\
    \ *buffer, char *orig_name, int cnt, int max_chars)\n           }\n \n       \
    \    /* There's no good way to detect an error in strftime since a return\n- \
    \          * value of 0 isn't necessarily failure.\n+           * value of 0 isn't\
    \ necessarily failure; if orig_name is an empty\n+           * string, the formatted\
    \ string will be empty.\n+           *\n+           * However, the C90 standard\
    \ says that, if there *is* a\n+           * buffer overflow, the content of the\
    \ buffer is undefined,\n+           * so we must check for a buffer overflow.\n\
    +           *\n+           * So we check above for an empty orig_name, and only\
    \ call\n+           * strftime() if it's non-empty, in which case the return\n\
    +           * value will only be 0 if the formatted date doesn't fit\n+      \
    \     * in the buffer.\n+           *\n+           * (We check above because,\
    \ even if we don't use -G, we\n+           * want a better error message than\
    \ \"tcpdump: : No such\n+           * file or directory\" for this case.)\n  \
    \          */\n-          strftime(filename, PATH_MAX, orig_name, local_tm);\n\
    +          if (strftime(filename, PATH_MAX, orig_name, local_tm) == 0) {\n+  \
    \          error(\"%s: strftime\", __func__);\n+          }\n         } else {\n\
    \           strncpy(filename, orig_name, PATH_MAX);\n         }"
  - "--- a/util-print.c\n+++ b/util-print.c\n@@ -230,7 +230,8 @@ ts_date_hmsfrac_print(netdissect_options\
    \ *ndo, long sec, long usec,\n {\n \ttime_t Time = sec;\n \tstruct tm *tm;\n-\t\
    char timestr[32];\n+\tchar timebuf[32];\n+\tconst char *timestr;\n \n \tif ((unsigned)sec\
    \ & 0x80000000) {\n \t\tND_PRINT(\"[Error converting time]\");\n@@ -242,14 +243,13\
    \ @@ ts_date_hmsfrac_print(netdissect_options *ndo, long sec, long usec,\n \t\
    else\n \t\ttm = gmtime(&Time);\n \n-\tif (!tm) {\n-\t\tND_PRINT(\"[Error converting\
    \ time]\");\n-\t\treturn;\n+\tif (date_flag == WITH_DATE) {\n+\t\ttimestr = nd_format_time(timebuf,\
    \ sizeof(timebuf),\n+\t\t    \"%Y-%m-%d %H:%M:%S\", tm);\n+\t} else {\n+\t\ttimestr\
    \ = nd_format_time(timebuf, sizeof(timebuf),\n+\t\t    \"%H:%M:%S\", tm);\n \t\
    }\n-\tif (date_flag == WITH_DATE)\n-\t\tstrftime(timestr, sizeof(timestr), \"\
    %Y-%m-%d %H:%M:%S\", tm);\n-\telse\n-\t\tstrftime(timestr, sizeof(timestr), \"\
    %H:%M:%S\", tm);\n \tND_PRINT(\"%s\", timestr);\n \n \tts_frac_print(ndo, usec);\n\
    @@ -405,6 +405,26 @@ signed_relts_print(netdissect_options *ndo,\n \tunsigned_relts_print(ndo,\
    \ secs);\n }\n \n+/*\n+ * Format a struct tm with strftime().\n+ * If the pointer\
    \ to the struct tm is null, that means that the\n+ * routine to convert a time_t\
    \ to a struct tm failed; the localtime()\n+ * and gmtime() in the Microsoft Visual\
    \ Studio C library will fail,\n+ * returning null, if the value is before the\
    \ UNIX Epoch.\n+ */\n+const char *\n+nd_format_time(char *buf, size_t bufsize,\
    \ const char *format,\n+         const struct tm *timeptr)\n+{\n+\tif (timeptr\
    \ != NULL) {\n+\t\tif (strftime(buf, bufsize, format, timeptr) != 0)\n+\t\t\t\
    return (buf);\n+\t\telse\n+\t\t\treturn (\"[nd_format_time() buffer is too small]\"\
    );\n+\t} else\n+\t\treturn (\"[localtime() or gmtime() couldn't convert the date\
    \ and time]\");\n+}\n+\n /* Print the truncated string */\n void nd_print_trunc(netdissect_options\
    \ *ndo)\n {"
  - "--- a/ntp.c\n+++ b/ntp.c\n@@ -54,30 +54,21 @@ p_ntp_time(netdissect_options *ndo,\n\
    \ \tif (i) {\n \t    int64_t seconds_64bit = (int64_t)i - JAN_1970;\n \t    time_t\
    \ seconds;\n-\t    struct tm *tm;\n \t    char time_buf[128];\n+\t    const char\
    \ *time_string;\n \n \t    seconds = (time_t)seconds_64bit;\n \t    if (seconds\
    \ != seconds_64bit) {\n \t\t/*\n \t\t * It doesn't fit into a time_t, so we can't\
    \ hand it\n \t\t * to gmtime.\n \t\t */\n-\t\tND_PRINT(\" (unrepresentable)\"\
    );\n+\t\ttime_string = \"[Time is too large to fit into a time_t]\";\n \t    }\
    \ else {\n-\t\ttm = gmtime(&seconds);\n-\t\tif (tm == NULL) {\n-\t\t    /*\n-\t\
    \t     * gmtime() can't handle it.\n-\t\t     * (Yes, that might happen with some\
    \ version of\n-\t\t     * Microsoft's C library.)\n-\t\t     */\n-\t\t    ND_PRINT(\"\
    \ (unrepresentable)\");\n-\t\t} else {\n-\t\t    /* use ISO 8601 (RFC3339) format\
    \ */\n-\t\t    strftime(time_buf, sizeof (time_buf), \"%Y-%m-%dT%H:%M:%SZ\", tm);\n\
    -\t\t    ND_PRINT(\" (%s)\", time_buf);\n-\t\t}\n+\t\t/* use ISO 8601 (RFC3339)\
    \ format */\n+\t\ttime_string = nd_format_time(time_buf, sizeof (time_buf),\n\
    +\t\t  \"%Y-%m-%dT%H:%M:%SZ\", gmtime(&seconds));\n \t    }\n+\t    ND_PRINT(\"\
    \ (%s)\", time_string);\n \t}\n }"
  - "--- a/print-ahcp.c\n+++ b/print-ahcp.c\n@@ -102,18 +102,14 @@ ahcp_time_print(netdissect_options\
    \ *ndo,\n                 const u_char *cp, uint8_t len)\n {\n \ttime_t t;\n-\t\
    struct tm *tm;\n-\tchar buf[BUFSIZE];\n+\tchar buf[sizeof(\"-yyyyyyyyyy-mm-dd\
    \ hh:mm:ss UTC\")];\n \n \tif (len != 4)\n \t\tgoto invalid;\n \tt = GET_BE_U_4(cp);\n\
    -\tif (NULL == (tm = gmtime(&t)))\n-\t\tND_PRINT(\": gmtime() error\");\n-\telse\
    \ if (0 == strftime(buf, sizeof(buf), \"%Y-%m-%d %H:%M:%S\", tm))\n-\t\tND_PRINT(\"\
    : strftime() error\");\n-\telse\n-\t\tND_PRINT(\": %s UTC\", buf);\n+\tND_PRINT(\"\
    : %s\",\n+\t    nd_format_time(buf, sizeof(buf), \"%Y-%m-%d %H:%M:%S UTC\",\n\
    +\t      gmtime(&t)));\n \treturn;\n \n invalid:"
  - "--- a/print-arista.c\n+++ b/print-arista.c\n@@ -10,7 +10,6 @@\n \n #include \"\
    netdissect.h\"\n #include \"extract.h\"\n-#include \"addrtoname.h\"\n \n /*\n\
    \ \n@@ -93,17 +92,13 @@ arista_print_date_hms_time(netdissect_options *ndo, uint32_t\
    \ seconds,\n \t\tuint32_t nanoseconds)\n {\n \ttime_t ts;\n-\tstruct tm *tm;\n\
    -\tchar buf[BUFSIZE];\n+\tchar buf[sizeof(\"-yyyyyyyyyy-mm-dd hh:mm:ss\")];\n\
    \ \n \tts = seconds + (nanoseconds / 1000000000);\n \tnanoseconds %= 1000000000;\n\
    -\tif (NULL == (tm = gmtime(&ts)))\n-\t\tND_PRINT(\"gmtime() error\");\n-\telse\
    \ if (0 == strftime(buf, sizeof(buf), \"%Y-%m-%d %H:%M:%S\", tm))\n-\t\tND_PRINT(\"\
    strftime() error\");\n-\telse\n-\t\tND_PRINT(\"%s.%09u\", buf, nanoseconds);\n\
    +\tND_PRINT(\"%s.%09u\",\n+\t    nd_format_time(buf, sizeof(buf), \"%Y-%m-%d %H:%M:%S\"\
    ,\n+\t       gmtime(&ts)), nanoseconds);\n }\n \n int"
  - "--- a/print-rx.c\n+++ b/print-rx.c\n@@ -794,12 +794,12 @@ rx_cache_find(netdissect_options\
    \ *ndo, const struct rx_header *rxh,\n \t\t\tND_PRINT(\" %\" PRIu64, _i); \\\n\
    \ \t\t}\n \n-#define DATEOUT() { time_t _t; struct tm *tm; char str[256]; \\\n\
    +#define DATEOUT() { time_t _t; char str[256]; \\\n \t\t\t_t = (time_t) GET_BE_S_4(bp);\
    \ \\\n \t\t\tbp += sizeof(int32_t); \\\n-\t\t\ttm = localtime(&_t); \\\n-\t\t\t\
    strftime(str, 256, \"%Y/%m/%d %H:%M:%S\", tm); \\\n-\t\t\tND_PRINT(\" %s\", str);\
    \ \\\n+\t\t\tND_PRINT(\" %s\", \\\n+\t\t\t    nd_format_time(str, sizeof(str),\
    \ \\\n+\t\t\t      \"%Y/%m/%d %H:%M:%S\", localtime(&_t))); \\\n \t\t}\n \n #define\
    \ STOREATTROUT() { uint32_t mask, _i; \\"
  - "--- a/print-zep.c\n+++ b/print-zep.c\n@@ -82,12 +82,11 @@ static void zep_print_ts(netdissect_options\
    \ *ndo, const u_char *p)\n \t */\n \tif (i) {\n \t\ttime_t seconds = i - JAN_1970;\n\
    -\t\tstruct tm *tm;\n \t\tchar time_buf[128];\n \n-\t\ttm = localtime(&seconds);\n\
    -\t\tstrftime(time_buf, sizeof (time_buf), \"%Y/%m/%d %H:%M:%S\", tm);\n-\t\t\
    ND_PRINT(\" (%s)\", time_buf);\n+\t\tND_PRINT(\" (%s)\",\n+\t\t    nd_format_time(time_buf,\
    \ sizeof (time_buf), \"%Y/%m/%d %H:%M:%S\",\n+\t\t      localtime(&seconds)));\n\
    \ \t}\n }\n "
  - "--- a/smbutil.c\n+++ b/smbutil.c\n@@ -768,9 +768,8 @@ smb_fdata1(netdissect_options\
    \ *ndo,\n \tcase 'T':\n \t  {\n \t    time_t t;\n-\t    struct tm *lt;\n \t  \
    \  const char *tstring;\n-\t    char buffer[sizeof(\"Www Mmm dd hh:mm:ss yyyyy\\\
    n\")];\n+\t    char buffer[sizeof(\"Www Mmm dd hh:mm:ss yyyyy\")];\n \t    uint32_t\
    \ x;\n \n \t    switch (atoi(fmt + 1)) {\n@@ -800,16 +799,11 @@ smb_fdata1(netdissect_options\
    \ *ndo,\n \t\tbreak;\n \t    }\n \t    if (t != 0) {\n-\t\tlt = localtime(&t);\n\
    -\t\tif (lt != NULL) {\n-\t\t    strftime(buffer, sizeof(buffer), \"%a %b %e %T\
    \ %Y%n\", lt);\n-\t\t    tstring = buffer;\n-\t\t}\n-\t\telse\n-\t\t    tstring\
    \ = \"(Can't convert time)\\n\";\n+\t\t    tstring = nd_format_time(buffer, sizeof(buffer),\
    \ \"%a %b %e %T %Y\",\n+\t\t    localtime(&t));\n \t    } else\n-\t\ttstring =\
    \ \"NULL\\n\";\n-\t    ND_PRINT(\"%s\", tstring);\n+\t\ttstring = \"NULL\";\n\
    +\t    ND_PRINT(\"%s\\n\", tstring);\n \t    fmt++;\n \t    while (ND_ASCII_ISDIGIT(*fmt))\n\
    \ \t\tfmt++;"
  - "--- a/tcpdump.c\n+++ b/tcpdump.c\n@@ -833,6 +833,8 @@ MakeFilename(char *buffer,\
    \ char *orig_name, int cnt, int max_chars)\n         char *filename = malloc(PATH_MAX\
    \ + 1);\n         if (filename == NULL)\n             error(\"%s: malloc\", __func__);\n\
    +        if (strlen(orig_name) == 0)\n+            error(\"an empty string is\
    \ not a valid file name\");\n \n         /* Process with strftime if Gflag is\
    \ set. */\n         if (Gflag != 0) {\n@@ -844,9 +846,25 @@ MakeFilename(char\
    \ *buffer, char *orig_name, int cnt, int max_chars)\n           }\n \n       \
    \    /* There's no good way to detect an error in strftime since a return\n- \
    \          * value of 0 isn't necessarily failure.\n+           * value of 0 isn't\
    \ necessarily failure; if orig_name is an empty\n+           * string, the formatted\
    \ string will be empty.\n+           *\n+           * However, the C90 standard\
    \ says that, if there *is* a\n+           * buffer overflow, the content of the\
    \ buffer is undefined,\n+           * so we must check for a buffer overflow.\n\
    +           *\n+           * So we check above for an empty orig_name, and only\
    \ call\n+           * strftime() if it's non-empty, in which case the return\n\
    +           * value will only be 0 if the formatted date doesn't fit\n+      \
    \     * in the buffer.\n+           *\n+           * (We check above because,\
    \ even if we don't use -G, we\n+           * want a better error message than\
    \ \"tcpdump: : No such\n+           * file or directory\" for this case.)\n  \
    \          */\n-          strftime(filename, PATH_MAX, orig_name, local_tm);\n\
    +          if (strftime(filename, PATH_MAX, orig_name, local_tm) == 0) {\n+  \
    \          error(\"%s: strftime\", __func__);\n+          }\n         } else {\n\
    \           strncpy(filename, orig_name, PATH_MAX);\n         }"
  - "--- a/util-print.c\n+++ b/util-print.c\n@@ -247,7 +247,8 @@ ts_date_hmsfrac_print(netdissect_options\
    \ *ndo, long sec, long usec,\n {\n \ttime_t Time = sec;\n \tstruct tm *tm;\n-\t\
    char timestr[32];\n+\tchar timebuf[32];\n+\tconst char *timestr;\n \n \tif ((unsigned)sec\
    \ & 0x80000000) {\n \t\tND_PRINT(\"[Error converting time]\");\n@@ -259,14 +260,13\
    \ @@ ts_date_hmsfrac_print(netdissect_options *ndo, long sec, long usec,\n \t\
    else\n \t\ttm = gmtime(&Time);\n \n-\tif (!tm) {\n-\t\tND_PRINT(\"[Error converting\
    \ time]\");\n-\t\treturn;\n+\tif (date_flag == WITH_DATE) {\n+\t\ttimestr = nd_format_time(timebuf,\
    \ sizeof(timebuf),\n+\t\t    \"%Y-%m-%d %H:%M:%S\", tm);\n+\t} else {\n+\t\ttimestr\
    \ = nd_format_time(timebuf, sizeof(timebuf),\n+\t\t    \"%H:%M:%S\", tm);\n \t\
    }\n-\tif (date_flag == WITH_DATE)\n-\t\tstrftime(timestr, sizeof(timestr), \"\
    %Y-%m-%d %H:%M:%S\", tm);\n-\telse\n-\t\tstrftime(timestr, sizeof(timestr), \"\
    %H:%M:%S\", tm);\n \tND_PRINT(\"%s\", timestr);\n \n \tts_frac_print(ndo, usec);\n\
    @@ -422,6 +422,26 @@ signed_relts_print(netdissect_options *ndo,\n \tunsigned_relts_print(ndo,\
    \ secs);\n }\n \n+/*\n+ * Format a struct tm with strftime().\n+ * If the pointer\
    \ to the struct tm is null, that means that the\n+ * routine to convert a time_t\
    \ to a struct tm failed; the localtime()\n+ * and gmtime() in the Microsoft Visual\
    \ Studio C library will fail,\n+ * returning null, if the value is before the\
    \ UNIX Epoch.\n+ */\n+const char *\n+nd_format_time(char *buf, size_t bufsize,\
    \ const char *format,\n+         const struct tm *timeptr)\n+{\n+\tif (timeptr\
    \ != NULL) {\n+\t\tif (strftime(buf, bufsize, format, timeptr) != 0)\n+\t\t\t\
    return (buf);\n+\t\telse\n+\t\t\treturn (\"[nd_format_time() buffer is too small]\"\
    );\n+\t} else\n+\t\treturn (\"[localtime() or gmtime() couldn't convert the date\
    \ and time]\");\n+}\n+\n /* Print the truncated string */\n void nd_print_trunc(netdissect_options\
    \ *ndo)\n {"
  identifiers:
  - CVE-2023-1801
  - CWE-787
  overview: The SMB protocol decoder in tcpdump version 4.99.3 can perform an out-of-bounds
    write when decoding a crafted network packet.
  references:
  - source: security@tcpdump.org
    tags:
    - Patch
    url: https://github.com/the-tcpdump-group/tcpdump/commit/03c037bbd75588beba3ee09f26d17783d21e30bc
  - source: security@tcpdump.org
    tags:
    - Patch
    url: https://github.com/the-tcpdump-group/tcpdump/commit/7578e1c04ee280dda50c4c2813e7d55f539c6501
  - source: security@tcpdump.org
    url: https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/KOA2BJFERAC3VRQIRHJOWN4HZY4ZA7CH/
  - source: security@tcpdump.org
    url: https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/WYL5DEVHRJYF2CM5LTCZKEYFYDZAIZSN/
  - source: security@tcpdump.org
    url: https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/ZLLZCG23MU6O4QOG2CX3DLEL3YXP6LAI/
  - source: security@tcpdump.org
    url: https://support.apple.com/kb/HT213844
  - source: security@tcpdump.org
    url: https://support.apple.com/kb/HT213845
  title: The SMB protocol decoder in tcpdump version 4.99.3 can perform an out-of-bounds
    write when decoding a crafted network packet.
- diff_content:
  - "--- a/arch/x86/kvm/vmx/nested.c\n+++ b/arch/x86/kvm/vmx/nested.c\n@@ -3022,7\
    \ +3022,7 @@ static int nested_vmx_check_guest_state(struct kvm_vcpu *vcpu,\n\
    \ \t\t\t\t\tstruct vmcs12 *vmcs12,\n \t\t\t\t\tenum vm_entry_failure_code *entry_failure_code)\n\
    \ {\n-\tbool ia32e;\n+\tbool ia32e = !!(vmcs12->vm_entry_controls & VM_ENTRY_IA32E_MODE);\n\
    \ \n \t*entry_failure_code = ENTRY_FAIL_DEFAULT;\n \n@@ -3048,6 +3048,13 @@ static\
    \ int nested_vmx_check_guest_state(struct kvm_vcpu *vcpu,\n \t\t\t\t\t   vmcs12->guest_ia32_perf_global_ctrl)))\n\
    \ \t\treturn -EINVAL;\n \n+\tif (CC((vmcs12->guest_cr0 & (X86_CR0_PG | X86_CR0_PE))\
    \ == X86_CR0_PG))\n+\t\treturn -EINVAL;\n+\n+\tif (CC(ia32e && !(vmcs12->guest_cr4\
    \ & X86_CR4_PAE)) ||\n+\t    CC(ia32e && !(vmcs12->guest_cr0 & X86_CR0_PG)))\n\
    +\t\treturn -EINVAL;\n+\n \t/*\n \t * If the load IA32_EFER VM-entry control is\
    \ 1, the following checks\n \t * are performed on the field for the IA32_EFER\
    \ MSR:\n@@ -3059,7 +3066,6 @@ static int nested_vmx_check_guest_state(struct kvm_vcpu\
    \ *vcpu,\n \t */\n \tif (to_vmx(vcpu)->nested.nested_run_pending &&\n \t    (vmcs12->vm_entry_controls\
    \ & VM_ENTRY_LOAD_IA32_EFER)) {\n-\t\tia32e = (vmcs12->vm_entry_controls & VM_ENTRY_IA32E_MODE)\
    \ != 0;\n \t\tif (CC(!kvm_valid_efer(vcpu, vmcs12->guest_ia32_efer)) ||\n \t\t\
    \    CC(ia32e != !!(vmcs12->guest_ia32_efer & EFER_LMA)) ||\n \t\t    CC(((vmcs12->guest_cr0\
    \ & X86_CR0_PG) &&"
  identifiers:
  - CVE-2023-30456
  - NVD-CWE-noinfo
  overview: An issue was discovered in arch/x86/kvm/vmx/nested.c in the Linux kernel
    before 6.2.8. nVMX on x86_64 lacks consistency checks for CR0 and CR4.
  references:
  - source: cve@mitre.org
    url: http://packetstormsecurity.com/files/173757/Kernel-Live-Patch-Security-Notice-LSN-0096-1.html
  - source: cve@mitre.org
    tags:
    - Patch
    url: https://cdn.kernel.org/pub/linux/kernel/v6.x/ChangeLog-6.2.8
  - source: cve@mitre.org
    tags:
    - Release Notes
    url: https://github.com/torvalds/linux/commit/112e66017bff7f2837030f34c2bc19501e9212d5
  - source: cve@mitre.org
    url: https://lists.debian.org/debian-lts-announce/2023/05/msg00005.html
  - source: cve@mitre.org
    url: https://lists.debian.org/debian-lts-announce/2023/05/msg00006.html
  - source: cve@mitre.org
    url: https://security.netapp.com/advisory/ntap-20230511-0007/
  title: An issue was discovered in arch/x86/kvm/vmx/nested.c in the Linux kernel
    before 6.2.8. nVMX on x86_64 lacks consistency checks for CR0 and CR4.
- diff_content:
  - "--- a/ldo.c\n+++ b/ldo.c\n@@ -530,10 +530,10 @@ int luaD_pretailcall (lua_State\
    \ *L, CallInfo *ci, StkId func,\n       int fsize = p->maxstacksize;  /* frame\
    \ size */\n       int nfixparams = p->numparams;\n       int i;\n+      checkstackGCp(L,\
    \ fsize - delta, func);\n       ci->func -= delta;  /* restore 'func' (if vararg)\
    \ */\n       for (i = 0; i < narg1; i++)  /* move down function and arguments\
    \ */\n         setobjs2s(L, ci->func + i, func + i);\n-      checkstackGC(L, fsize);\n\
    \       func = ci->func;  /* moved-down function */\n       for (; narg1 <= nfixparams;\
    \ narg1++)\n         setnilvalue(s2v(func + narg1));  /* complete missing arguments\
    \ */"
  identifiers:
  - CVE-2021-45985
  - CWE-787
  overview: In Lua 5.4.3, an erroneous finalizer called during a tail call leads to
    a heap-based buffer over-read.
  references:
  - source: cve@mitre.org
    tags:
    - Exploit
    - Mailing List
    - Vendor Advisory
    url: http://lua-users.org/lists/lua-l/2021-12/msg00019.html
  - source: cve@mitre.org
    tags:
    - Patch
    url: https://github.com/lua/lua/commit/cf613cdc6fa367257fc61c256f63d917350858b5
  - source: cve@mitre.org
    tags:
    - Vendor Advisory
    url: https://www.lua.org/bugs.html#5.4.3-11
  title: In Lua 5.4.3, an erroneous finalizer called during a tail call leads to a
    heap-based buffer over-read.
- diff_content:
  - "--- a/lib/libcrypto/x509/x509_verify.c\n+++ b/lib/libcrypto/x509/x509_verify.c\n\
    @@ -1,4 +1,4 @@\n-/* $OpenBSD: x509_verify.c,v 1.60 2022/08/05 14:46:52 beck Exp\
    \ $ */\n+/* $OpenBSD: x509_verify.c,v 1.61 2022/10/17 18:56:54 jsing Exp $ */\n\
    \ /*\n  * Copyright (c) 2020-2021 Bob Beck <beck@openbsd.org>\n  *\n@@ -494,6\
    \ +494,15 @@ x509_verify_ctx_add_chain(struct x509_verify_ctx *ctx,\n \tif (!x509_verify_ctx_validate_legacy_chain(ctx,\
    \ chain, depth))\n \t\treturn 0;\n \n+\t/* Verify the leaf certificate and store\
    \ any resulting error. */\n+\tif (!x509_verify_cert_valid(ctx, leaf, NULL))\n\
    +\t\treturn 0;\n+\tif (!x509_verify_cert_hostname(ctx, leaf, name))\n+\t\treturn\
    \ 0;\n+\tif (ctx->error_depth == 0 &&\n+\t    ctx->error != X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY)\n\
    +\t\tchain->cert_errors[0] = ctx->error;\n+\n \t/*\n \t * In the non-legacy code,\
    \ extensions and purpose are dealt\n \t * with as the chain is built.\n@@ -508,16\
    \ +517,11 @@ x509_verify_ctx_add_chain(struct x509_verify_ctx *ctx,\n \t\treturn\
    \ x509_verify_cert_error(ctx, last, depth,\n \t\t    X509_V_ERR_OUT_OF_MEM, 0);\n\
    \ \t}\n-\n-\tif (!x509_verify_cert_valid(ctx, leaf, NULL))\n-\t\treturn 0;\n-\n\
    -\tif (!x509_verify_cert_hostname(ctx, leaf, name))\n-\t\treturn 0;\n-\n \tctx->chains_count++;\n\
    +\n \tctx->error = X509_V_OK;\n \tctx->error_depth = depth;\n+\n \treturn 1;\n\
    \ }\n "
  identifiers:
  - CVE-2022-48437
  - CWE-295
  overview: An issue was discovered in x509/x509_verify.c in LibreSSL before 3.6.1,
    and in OpenBSD before 7.2 errata 001. x509_verify_ctx_add_chain does not store
    errors that occur during leaf certificate verification, and therefore an incorrect
    error is returned. This behavior occurs when there is an installed verification
    callback that instructs the verifier to continue upon detecting an invalid certificate.
  references:
  - source: cve@mitre.org
    tags:
    - Patch
    url: https://ftp.openbsd.org/pub/OpenBSD/LibreSSL/libressl-3.6.1-relnotes.txt
  - source: cve@mitre.org
    tags:
    - Patch
    url: https://ftp.openbsd.org/pub/OpenBSD/patches/7.2/common/001_x509.patch.sig
  - source: cve@mitre.org
    tags:
    - Patch
    url: https://github.com/openbsd/src/commit/4f94258c65a918ee3d8670e93916d15bf879e6ec
  title: An issue was discovered in x509/x509_verify.c in LibreSSL before 3.6.1, and
    in OpenBSD before 7.2 errata 001. x509_verify_ctx_add_chain does not store errors
    that occur during leaf certificate verification, and therefore an incorrect error
    is returned. This behavior occurs when there is an installed verification callback
    that instructs the verifier to continue upon detecting an invalid certificate.
- diff_content:
  - "--- a/coders/tiff.c\n+++ b/coders/tiff.c\n@@ -1903,8 +1903,8 @@ static Image\
    \ *ReadTIFFImage(const ImageInfo *image_info,\n         /*\n           Convert\
    \ stripped TIFF image.\n         */\n-        extent=4*MagickMax(image->columns*(samples_per_pixel+extra_samples)*\n\
    -          (image->depth+7)/8,(size_t) TIFFStripSize(tiff));\n+        extent=MagickMax(sizeof(uint32),(samples_per_pixel+extra_samples)*\n\
    +          (image->depth+7)/8)*image->columns*rows_per_strip;\n         strip_pixels=(unsigned\
    \ char *) AcquireQuantumMemory(extent,\n           sizeof(*strip_pixels));\n \
    \        if (strip_pixels == (unsigned char *) NULL)"
  - "--- a/coders/tiff.c\n+++ b/coders/tiff.c\n@@ -1811,8 +1811,8 @@ static Image\
    \ *ReadTIFFImage(const ImageInfo *image_info,\n         /*\n           Convert\
    \ stripped TIFF image.\n         */\n-        extent=4*MagickMax(image->columns*(samples_per_pixel+extra_samples)*\n\
    -          (image->depth+7)/8,TIFFStripSize(tiff));\n+        extent=MagickMax(sizeof(uint32),(samples_per_pixel+extra_samples)*\n\
    +          (image->depth+7)/8)*image->columns*rows_per_strip;\n         strip_pixels=(unsigned\
    \ char *) AcquireQuantumMemory(extent,\n           sizeof(*strip_pixels));\n \
    \        if (strip_pixels == (unsigned char *) NULL)"
  identifiers:
  - CVE-2023-1906
  - CWE-787
  overview: A heap-based buffer overflow issue was discovered in ImageMagick's ImportMultiSpectralQuantum()
    function in MagickCore/quantum-import.c. An attacker could pass specially crafted
    file to convert, triggering an out-of-bounds read error, allowing an application
    to crash, resulting in a denial of service.
  references:
  - source: secalert@redhat.com
    tags:
    - Third Party Advisory
    url: https://access.redhat.com/security/cve/CVE-2023-1906
  - source: secalert@redhat.com
    tags:
    - Issue Tracking
    - Patch
    - Third Party Advisory
    url: https://bugzilla.redhat.com/show_bug.cgi?id=2185714
  - source: secalert@redhat.com
    tags:
    - Patch
    url: https://github.com/ImageMagick/ImageMagick/commit/d7a8bdd7bb33cf8e58bc01b4a4f2ea5466f8c6b3
  - source: secalert@redhat.com
    tags:
    - Exploit
    - Vendor Advisory
    url: https://github.com/ImageMagick/ImageMagick/security/advisories/GHSA-35q2-86c7-9247
  - source: secalert@redhat.com
    tags:
    - Patch
    url: https://github.com/ImageMagick/ImageMagick6/commit/e30c693b37c3b41723f1469d1226a2c814ca443d
  - source: secalert@redhat.com
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/6655G3GPS42WQM32DJHUCZALI2URQSCO/
  title: A heap-based buffer overflow issue was discovered in ImageMagick's ImportMultiSpectralQuantum()
    function in MagickCore/quantum-import.c. An attacker could pass specially crafted
    file to convert, triggering an out-of-bounds read error, allowing an application
    to crash, resulting in a denial of service.
- diff_content:
  - "--- a/examples/iec61850_client_example_control/client_example_control.c\n+++\
    \ b/examples/iec61850_client_example_control/client_example_control.c\n@@ -45,8\
    \ +45,10 @@ int main(int argc, char** argv) {\n \n     IedConnection_connect(con,\
    \ &error, hostname, tcpPort);\n \n-    if (error == IED_ERROR_OK) {\n-\n+    if\
    \ (error == IED_ERROR_OK)\n+    {\n+        MmsValue* ctlVal = NULL;\n+      \
    \  MmsValue* stVal = NULL;\n \n         /************************\n          *\
    \ Direct control\n@@ -55,99 +57,116 @@ int main(int argc, char** argv) {\n   \
    \      ControlObjectClient control\n             = ControlObjectClient_create(\"\
    simpleIOGenericIO/GGIO1.SPCSO1\", con);\n \n-        MmsValue* ctlVal = MmsValue_newBoolean(true);\n\
    +        if (control)\n+        {\n+            ctlVal = MmsValue_newBoolean(true);\n\
    \ \n-        ControlObjectClient_setOrigin(control, NULL, 3);\n+            ControlObjectClient_setOrigin(control,\
    \ NULL, 3);\n \n-        if (ControlObjectClient_operate(control, ctlVal, 0 /*\
    \ operate now */)) {\n-            printf(\"simpleIOGenericIO/GGIO1.SPCSO1 operated\
    \ successfully\\n\");\n-        }\n-        else {\n-            printf(\"failed\
    \ to operate simpleIOGenericIO/GGIO1.SPCSO1\\n\");\n-        }\n+            if\
    \ (ControlObjectClient_operate(control, ctlVal, 0 /* operate now */)) {\n+   \
    \             printf(\"simpleIOGenericIO/GGIO1.SPCSO1 operated successfully\\\
    n\");\n+            }\n+            else {\n+                printf(\"failed to\
    \ operate simpleIOGenericIO/GGIO1.SPCSO1\\n\");\n+            }\n+\n+        \
    \    MmsValue_delete(ctlVal);\n \n-        MmsValue_delete(ctlVal);\n+       \
    \     ControlObjectClient_destroy(control);\n \n-        ControlObjectClient_destroy(control);\n\
    +            /* Check if status value has changed */\n \n-        /* Check if\
    \ status value has changed */\n+            stVal = IedConnection_readObject(con,\
    \ &error, \"simpleIOGenericIO/GGIO1.SPCSO1.stVal\", IEC61850_FC_ST);\n \n-   \
    \     MmsValue* stVal = IedConnection_readObject(con, &error, \"simpleIOGenericIO/GGIO1.SPCSO1.stVal\"\
    , IEC61850_FC_ST);\n+            if (error == IED_ERROR_OK) {\n+             \
    \   bool state = MmsValue_getBoolean(stVal);\n+                MmsValue_delete(stVal);\n\
    \ \n-        if (error == IED_ERROR_OK) {\n-            bool state = MmsValue_getBoolean(stVal);\n\
    -            MmsValue_delete(stVal);\n+                printf(\"New status of\
    \ simpleIOGenericIO/GGIO1.SPCSO1.stVal: %i\\n\", state);\n+            }\n+  \
    \          else {\n+                printf(\"Reading status for simpleIOGenericIO/GGIO1.SPCSO1\
    \ failed!\\n\");\n+            }\n \n-            printf(\"New status of simpleIOGenericIO/GGIO1.SPCSO1.stVal:\
    \ %i\\n\", state);\n         }\n         else {\n-            printf(\"Reading\
    \ status for simpleIOGenericIO/GGIO1.SPCSO1 failed!\\n\");\n+            printf(\"\
    Control object simpleIOGenericIO/GGIO1.SPCSO1 not found in server\\n\");\n   \
    \      }\n \n-\n         /************************\n          * Select before\
    \ operate\n          ***********************/\n \n         control = ControlObjectClient_create(\"\
    simpleIOGenericIO/GGIO1.SPCSO2\", con);\n \n-        if (ControlObjectClient_select(control))\
    \ {\n+        if (control)\n+        {\n+            if (ControlObjectClient_select(control))\
    \ {\n \n-            ctlVal = MmsValue_newBoolean(true);\n+                ctlVal\
    \ = MmsValue_newBoolean(true);\n \n-            if (ControlObjectClient_operate(control,\
    \ ctlVal, 0 /* operate now */)) {\n-                printf(\"simpleIOGenericIO/GGIO1.SPCSO2\
    \ operated successfully\\n\");\n+                if (ControlObjectClient_operate(control,\
    \ ctlVal, 0 /* operate now */)) {\n+                    printf(\"simpleIOGenericIO/GGIO1.SPCSO2\
    \ operated successfully\\n\");\n+                }\n+                else {\n\
    +                    printf(\"failed to operate simpleIOGenericIO/GGIO1.SPCSO2!\\\
    n\");\n+                }\n+\n+                MmsValue_delete(ctlVal);\n    \
    \         }\n             else {\n-                printf(\"failed to operate\
    \ simpleIOGenericIO/GGIO1.SPCSO2!\\n\");\n+                printf(\"failed to\
    \ select simpleIOGenericIO/GGIO1.SPCSO2!\\n\");\n             }\n \n-        \
    \    MmsValue_delete(ctlVal);\n+            ControlObjectClient_destroy(control);\n\
    \         }\n         else {\n-            printf(\"failed to select simpleIOGenericIO/GGIO1.SPCSO2!\\\
    n\");\n+            printf(\"Control object simpleIOGenericIO/GGIO1.SPCSO2 not\
    \ found in server\\n\");\n         }\n \n-        ControlObjectClient_destroy(control);\n\
    -\n-\n         /****************************************\n          * Direct control\
    \ with enhanced security\n          ****************************************/\n\
    \ \n         control = ControlObjectClient_create(\"simpleIOGenericIO/GGIO1.SPCSO3\"\
    , con);\n \n-        ControlObjectClient_setCommandTerminationHandler(control,\
    \ commandTerminationHandler, NULL);\n+        if (control)\n+        {\n+    \
    \        ControlObjectClient_setCommandTerminationHandler(control, commandTerminationHandler,\
    \ NULL);\n \n-        ctlVal = MmsValue_newBoolean(true);\n+            ctlVal\
    \ = MmsValue_newBoolean(true);\n \n-        if (ControlObjectClient_operate(control,\
    \ ctlVal, 0 /* operate now */)) {\n-            printf(\"simpleIOGenericIO/GGIO1.SPCSO3\
    \ operated successfully\\n\");\n-        }\n-        else {\n-            printf(\"\
    failed to operate simpleIOGenericIO/GGIO1.SPCSO3\\n\");\n-        }\n+       \
    \     if (ControlObjectClient_operate(control, ctlVal, 0 /* operate now */)) {\n\
    +                printf(\"simpleIOGenericIO/GGIO1.SPCSO3 operated successfully\\\
    n\");\n+            }\n+            else {\n+                printf(\"failed to\
    \ operate simpleIOGenericIO/GGIO1.SPCSO3\\n\");\n+            }\n \n-        MmsValue_delete(ctlVal);\n\
    +            MmsValue_delete(ctlVal);\n \n-        /* Wait for command termination\
    \ message */\n-        Thread_sleep(1000);\n+            /* Wait for command termination\
    \ message */\n+            Thread_sleep(1000);\n \n-        ControlObjectClient_destroy(control);\n\
    +            ControlObjectClient_destroy(control);\n \n-        /* Check if status\
    \ value has changed */\n+            /* Check if status value has changed */\n\
    \ \n-       stVal = IedConnection_readObject(con, &error, \"simpleIOGenericIO/GGIO1.SPCSO3.stVal\"\
    , IEC61850_FC_ST);\n+            stVal = IedConnection_readObject(con, &error,\
    \ \"simpleIOGenericIO/GGIO1.SPCSO3.stVal\", IEC61850_FC_ST);\n \n-        if (error\
    \ == IED_ERROR_OK) {\n-            bool state = MmsValue_getBoolean(stVal);\n\
    +            if (error == IED_ERROR_OK) {\n+                bool state = MmsValue_getBoolean(stVal);\n\
    \ \n-            printf(\"New status of simpleIOGenericIO/GGIO1.SPCSO3.stVal:\
    \ %i\\n\", state);\n+                printf(\"New status of simpleIOGenericIO/GGIO1.SPCSO3.stVal:\
    \ %i\\n\", state);\n \n-            MmsValue_delete(stVal);\n+               \
    \ MmsValue_delete(stVal);\n+            }\n+            else {\n+            \
    \    printf(\"Reading status for simpleIOGenericIO/GGIO1.SPCSO3 failed!\\n\");\n\
    +            }\n         }\n         else {\n-            printf(\"Reading status\
    \ for simpleIOGenericIO/GGIO1.SPCSO3 failed!\\n\");\n+            printf(\"Control\
    \ object simpleIOGenericIO/GGIO1.SPCSO3 not found in server\\n\");\n         }\n\
    \ \n         /***********************************************\n@@ -156,56 +175,66\
    \ @@ int main(int argc, char** argv) {\n \n         control = ControlObjectClient_create(\"\
    simpleIOGenericIO/GGIO1.SPCSO4\", con);\n \n-        ControlObjectClient_setCommandTerminationHandler(control,\
    \ commandTerminationHandler, NULL);\n+        if (control)\n+        {\n+    \
    \        ControlObjectClient_setCommandTerminationHandler(control, commandTerminationHandler,\
    \ NULL);\n \n-        ctlVal = MmsValue_newBoolean(true);\n+            ctlVal\
    \ = MmsValue_newBoolean(true);\n \n-        if (ControlObjectClient_selectWithValue(control,\
    \ ctlVal)) {\n+            if (ControlObjectClient_selectWithValue(control, ctlVal))\
    \ {\n+\n+                if (ControlObjectClient_operate(control, ctlVal, 0 /*\
    \ operate now */)) {\n+                    printf(\"simpleIOGenericIO/GGIO1.SPCSO4\
    \ operated successfully\\n\");\n+                }\n+                else {\n\
    +                    printf(\"failed to operate simpleIOGenericIO/GGIO1.SPCSO4!\\\
    n\");\n+                }\n \n-            if (ControlObjectClient_operate(control,\
    \ ctlVal, 0 /* operate now */)) {\n-                printf(\"simpleIOGenericIO/GGIO1.SPCSO4\
    \ operated successfully\\n\");\n             }\n             else {\n-       \
    \         printf(\"failed to operate simpleIOGenericIO/GGIO1.SPCSO4!\\n\");\n\
    +                printf(\"failed to select simpleIOGenericIO/GGIO1.SPCSO4!\\n\"\
    );\n             }\n \n+            MmsValue_delete(ctlVal);\n+\n+           \
    \ /* Wait for command termination message */\n+            Thread_sleep(1000);\n\
    +\n+            ControlObjectClient_destroy(control);\n         }\n         else\
    \ {\n-            printf(\"failed to select simpleIOGenericIO/GGIO1.SPCSO4!\\\
    n\");\n+            printf(\"Control object simpleIOGenericIO/GGIO1.SPCSO4 not\
    \ found in server\\n\");\n         }\n \n-        MmsValue_delete(ctlVal);\n-\n\
    -        /* Wait for command termination message */\n-        Thread_sleep(1000);\n\
    -\n-        ControlObjectClient_destroy(control);\n-\n-\n         /*********************************************************************\n\
    \          * Direct control with enhanced security (expect CommandTermination-)\n\
    \          *********************************************************************/\n\
    \ \n         control = ControlObjectClient_create(\"simpleIOGenericIO/GGIO1.SPCSO9\"\
    , con);\n \n-        ControlObjectClient_setCommandTerminationHandler(control,\
    \ commandTerminationHandler, NULL);\n-\n-        ctlVal = MmsValue_newBoolean(true);\n\
    +        if (control)\n+        {\n+            ControlObjectClient_setCommandTerminationHandler(control,\
    \ commandTerminationHandler, NULL);\n \n-        if (ControlObjectClient_operate(control,\
    \ ctlVal, 0 /* operate now */)) {\n-            printf(\"simpleIOGenericIO/GGIO1.SPCSO9\
    \ operated successfully\\n\");\n-        }\n-        else {\n-            printf(\"\
    failed to operate simpleIOGenericIO/GGIO1.SPCSO9\\n\");\n-        }\n+       \
    \     ctlVal = MmsValue_newBoolean(true);\n \n-        MmsValue_delete(ctlVal);\n\
    +            if (ControlObjectClient_operate(control, ctlVal, 0 /* operate now\
    \ */)) {\n+                printf(\"simpleIOGenericIO/GGIO1.SPCSO9 operated successfully\\\
    n\");\n+            }\n+            else {\n+                printf(\"failed to\
    \ operate simpleIOGenericIO/GGIO1.SPCSO9\\n\");\n+            }\n \n-        /*\
    \ Wait for command termination message */\n-        Thread_sleep(1000);\n+   \
    \         MmsValue_delete(ctlVal);\n \n-        ControlObjectClient_destroy(control);\n\
    +            /* Wait for command termination message */\n+            Thread_sleep(1000);\n\
    \ \n+            ControlObjectClient_destroy(control);\n+        }\n+        else\
    \ {\n+            printf(\"Control object simpleIOGenericIO/GGIO1.SPCSO9 not found\
    \ in server\\n\");\n+        }\n \n         IedConnection_close(con);\n     }"
  identifiers:
  - CVE-2023-27772
  - CWE-754
  overview: libiec61850 v1.5.1 was discovered to contain a segmentation violation
    via the function ControlObjectClient_setOrigin() at /client/client_control.c.
  references:
  - source: cve@mitre.org
    tags:
    - Patch
    - Vendor Advisory
    url: https://github.com/mz-automation/libiec61850/commit/79a8eaf26070e02044afc4b2ffbfe777dfdf3e0b
  - source: cve@mitre.org
    tags:
    - Exploit
    - Vendor Advisory
    url: https://github.com/mz-automation/libiec61850/issues/442
  title: libiec61850 v1.5.1 was discovered to contain a segmentation violation via
    the function ControlObjectClient_setOrigin() at /client/client_control.c.
- diff_content:
  - "--- a/protobuf-c/protobuf-c.c\n+++ b/protobuf-c/protobuf-c.c\n@@ -2603,10 +2603,13\
    \ @@ parse_required_member(ScannedMember *scanned_member,\n \t\t\treturn FALSE;\n\
    \ \n \t\tdef_mess = scanned_member->field->default_value;\n-\t\tsubm = protobuf_c_message_unpack(scanned_member->field->descriptor,\n\
    -\t\t\t\t\t\t allocator,\n-\t\t\t\t\t\t len - pref_len,\n-\t\t\t\t\t\t data +\
    \ pref_len);\n+\t\tif (len >= pref_len)\n+\t\t\tsubm = protobuf_c_message_unpack(scanned_member->field->descriptor,\n\
    +\t\t\t\t\t\t\t allocator,\n+\t\t\t\t\t\t\t len - pref_len,\n+\t\t\t\t\t\t\t data\
    \ + pref_len);\n+\t\telse\n+\t\t\tsubm = NULL;\n \n \t\tif (maybe_clear &&\n \t\
    \t    *pmessage != NULL &&"
  identifiers:
  - CVE-2022-48468
  - CWE-190
  overview: protobuf-c before 1.4.1 has an unsigned integer overflow in parse_required_member.
  references:
  - source: cve@mitre.org
    tags:
    - Patch
    url: https://github.com/protobuf-c/protobuf-c/commit/ec3d900001a13ccdaa8aef996b34c61159c76217
  - source: cve@mitre.org
    tags:
    - Issue Tracking
    - Patch
    - Third Party Advisory
    url: https://github.com/protobuf-c/protobuf-c/issues/499
  - source: cve@mitre.org
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/protobuf-c/protobuf-c/pull/513
  - source: cve@mitre.org
    tags:
    - Patch
    - Release Notes
    url: https://github.com/protobuf-c/protobuf-c/releases/tag/v1.4.1
  - source: cve@mitre.org
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/EI4JZSHJXW7WOOTAQSV5SUCC5GE2GC2B/
  - source: cve@mitre.org
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/UGLZZYPOLI733DPETL444E3GY5KSS6LG/
  - source: cve@mitre.org
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/VNUEZZEPR2F6M67ANXLOPJX6AQL3TK4P/
  title: protobuf-c before 1.4.1 has an unsigned integer overflow in parse_required_member.
- diff_content:
  - "--- a/src/rcore.c\n+++ b/src/rcore.c\n@@ -1994,7 +1994,9 @@ void SetClipboardText(const\
    \ char *text)\n     glfwSetClipboardString(CORE.Window.handle, text);\n #endif\n\
    \ #if defined(PLATFORM_WEB)\n-    emscripten_run_script(TextFormat(\"navigator.clipboard.writeText('%s')\"\
    , text));\n+    // Security check to (partially) avoid malicious code\n+    if\
    \ (strchr(text, '\\'') != NULL) TRACELOG(LOG_WARNING, \"SYSTEM: Provided Clipboard\
    \ could be potentially malicious, avoid [\\'] character\");\n+    else emscripten_run_script(TextFormat(\"\
    navigator.clipboard.writeText('%s')\", text));\n #endif\n }\n \n@@ -2006,6 +2008,7\
    \ @@ const char *GetClipboardText(void)\n     return glfwGetClipboardString(CORE.Window.handle);\n\
    \ #endif\n #if defined(PLATFORM_WEB)\n+/*\n     // Accessing clipboard data from\
    \ browser is tricky due to security reasons\n     // The method to use is navigator.clipboard.readText()\
    \ but this is an asynchronous method\n     // that will return at some moment\
    \ after the function is called with the required data\n@@ -2019,7 +2022,7 @@ const\
    \ char *GetClipboardText(void)\n \n     // Another approach could be just copy\
    \ the data in a HTML text field and try to retrieve it\n     // later on if available...\
    \ and clean it for future accesses\n-\n+*/\n     return NULL;\n #endif\n     return\
    \ NULL;\n@@ -2910,6 +2913,9 @@ void SetConfigFlags(unsigned int flags)\n void\
    \ TakeScreenshot(const char *fileName)\n {\n #if defined(SUPPORT_MODULE_RTEXTURES)\n\
    +    // Security check to (partially) avoid malicious code on PLATFORM_WEB\n+\
    \    if (strchr(fileName, '\\'') != NULL) { TRACELOG(LOG_WARNING, \"SYSTEM: Provided\
    \ fileName could be potentially malicious, avoid [\\'] character\");  return;\
    \ }\n+\n     Vector2 scale = GetWindowScaleDPI();\n     unsigned char *imgData\
    \ = rlReadScreenPixels((int)((float)CORE.Window.render.width*scale.x), (int)((float)CORE.Window.render.height*scale.y));\n\
    \     Image image = { imgData, (int)((float)CORE.Window.render.width*scale.x),\
    \ (int)((float)CORE.Window.render.height*scale.y), 1, PIXELFORMAT_UNCOMPRESSED_R8G8B8A8\
    \ };\n@@ -3536,12 +3542,8 @@ unsigned char *DecodeDataBase64(const unsigned char\
    \ *data, int *outputSize)\n // Ref: https://github.com/raysan5/raylib/issues/686\n\
    \ void OpenURL(const char *url)\n {\n-    // Small security check trying to avoid\
    \ (partially) malicious code...\n-    // sorry for the inconvenience when you\
    \ hit this point...\n-    if (strchr(url, '\\'') != NULL)\n-    {\n-        TRACELOG(LOG_WARNING,\
    \ \"SYSTEM: Provided URL is not valid\");\n-    }\n+    // Security check to (aprtially)\
    \ avoid malicious code on PLATFORM_WEB\n+    if (strchr(url, '\\'') != NULL) TRACELOG(LOG_WARNING,\
    \ \"SYSTEM: Provided URL could be potentially malicious, avoid [\\'] character\"\
    );\n     else\n     {\n #if defined(PLATFORM_DESKTOP)"
  identifiers:
  - CVE-2023-26123
  - CWE-79
  overview: "Versions of the package raysan5/raylib before 4.5.0 are vulnerable to\
    \ Cross-site Scripting (XSS) such that the SetClipboardText API does not properly\
    \ escape the ' character, allowing attacker-controlled input to break out of the\
    \ string and execute arbitrary JavaScript via emscripten_run_script function.\r\
    \r**Note:** This vulnerability is present only when compiling raylib for PLATFORM_WEB.\
    \ All the other Desktop/Mobile/Embedded platforms are not affected."
  references:
  - source: report@snyk.io
    tags:
    - Patch
    url: https://github.com/raysan5/raylib/commit/b436c8d7e5346a241b00511a11585936895d959d
  - source: report@snyk.io
    tags:
    - Exploit
    - Issue Tracking
    - Third Party Advisory
    url: https://github.com/raysan5/raylib/issues/2954
  - source: report@snyk.io
    tags:
    - Release Notes
    url: https://github.com/raysan5/raylib/releases/tag/4.5.0
  - source: report@snyk.io
    tags:
    - Exploit
    - Patch
    - Third Party Advisory
    url: https://security.snyk.io/vuln/SNYK-UNMANAGED-RAYSAN5RAYLIB-5421188
  title: "Versions of the package raysan5/raylib before 4.5.0 are vulnerable to Cross-site\
    \ Scripting (XSS) such that the SetClipboardText API does not properly escape\
    \ the ' character, allowing attacker-controlled input to break out of the string\
    \ and execute arbitrary JavaScript via emscripten_run_script function.\r\r**Note:**\
    \ This vulnerability is present only when compiling raylib for PLATFORM_WEB. All\
    \ the other Desktop/Mobile/Embedded platforms are not affected."
- diff_content:
  - "--- a/drivers/dma-buf/udmabuf.c\n+++ b/drivers/dma-buf/udmabuf.c\n@@ -32,8 +32,11\
    \ @@ static vm_fault_t udmabuf_vm_fault(struct vm_fault *vmf)\n {\n \tstruct vm_area_struct\
    \ *vma = vmf->vma;\n \tstruct udmabuf *ubuf = vma->vm_private_data;\n+\tpgoff_t\
    \ pgoff = vmf->pgoff;\n \n-\tvmf->page = ubuf->pages[vmf->pgoff];\n+\tif (pgoff\
    \ >= ubuf->pagecount)\n+\t\treturn VM_FAULT_SIGBUS;\n+\tvmf->page = ubuf->pages[pgoff];\n\
    \ \tget_page(vmf->page);\n \treturn 0;\n }"
  identifiers:
  - CVE-2023-2008
  - CWE-129
  overview: A flaw was found in the Linux kernel's udmabuf device driver. The specific
    flaw exists within a fault handler. The issue results from the lack of proper
    validation of user-supplied data, which can result in a memory access past the
    end of an array. An attacker can leverage this vulnerability to escalate privileges
    and execute arbitrary code in the context of the kernel.
  references:
  - source: secalert@redhat.com
    tags:
    - Issue Tracking
    - Patch
    - Third Party Advisory
    url: https://bugzilla.redhat.com/show_bug.cgi?id=2186862
  - source: secalert@redhat.com
    tags:
    - Patch
    url: https://github.com/torvalds/linux/commit/05b252cccb2e5c3f56119d25de684b4f810ba4
  - source: secalert@redhat.com
    tags:
    - Third Party Advisory
    url: https://security.netapp.com/advisory/ntap-20230517-0007/
  - source: secalert@redhat.com
    tags:
    - Third Party Advisory
    - VDB Entry
    url: https://www.zerodayinitiative.com/advisories/ZDI-23-441/
  title: A flaw was found in the Linux kernel's udmabuf device driver. The specific
    flaw exists within a fault handler. The issue results from the lack of proper
    validation of user-supplied data, which can result in a memory access past the
    end of an array. An attacker can leverage this vulnerability to escalate privileges
    and execute arbitrary code in the context of the kernel.
- diff_content:
  - "--- a/lib/fields.c\n+++ b/lib/fields.c\n@@ -21,9 +21,9 @@\n  *\n  * The supplied\
    \ field is scanned for non-printable and other illegal\n  * characters.\n- * \
    \ + -1 is returned if an illegal character is present.\n- *  +  1 is returned\
    \ if no illegal characters are present, but the field\n- *       contains a non-printable\
    \ character.\n+ *  + -1 is returned if an illegal or control character is present.\n\
    + *  +  1 is returned if no illegal or control characters are present,\n+ *  \
    \     but the field contains a non-printable character.\n  *  +  0 is returned\
    \ otherwise.\n  */\n int valid_field (const char *field, const char *illegal)\n\
    @@ -45,10 +45,13 @@ int valid_field (const char *field, const char *illegal)\n\
    \ \t}\n \n \tif (0 == err) {\n-\t\t/* Search if there are some non-printable characters\
    \ */\n+\t\t/* Search if there are non-printable or control characters */\n \t\t\
    for (cp = field; '\\0' != *cp; cp++) {\n \t\t\tif (!isprint (*cp)) {\n \t\t\t\t\
    err = 1;\n+\t\t\t}\n+\t\t\tif (!iscntrl (*cp)) {\n+\t\t\t\terr = -1;\n \t\t\t\t\
    break;\n \t\t\t}\n \t\t}"
  identifiers:
  - CVE-2023-29383
  - CWE-74
  overview: 'In Shadow 4.13, it is possible to inject control characters into fields
    provided to the SUID program chfn (change finger). Although it is not possible
    to exploit this directly (e.g., adding a new user fails because \n is in the block
    list), it is possible to misrepresent the /etc/passwd file when viewed. Use of
    \r manipulations and Unicode characters to work around blocking of the : character
    make it possible to give the impression that a new user has been added. In other
    words, an adversary may be able to convince a system administrator to take the
    system offline (an indirect, social-engineered denial of service) by demonstrating
    that "cat /etc/passwd" shows a rogue user account.'
  references:
  - source: cve@mitre.org
    tags:
    - Patch
    url: https://github.com/shadow-maint/shadow/commit/e5905c4b84d4fb90aefcd96ee618411ebfac663d
  - source: cve@mitre.org
    tags:
    - Issue Tracking
    url: https://github.com/shadow-maint/shadow/pull/687
  - source: cve@mitre.org
    tags:
    - Exploit
    - Third Party Advisory
    url: https://www.trustwave.com/en-us/resources/blogs/spiderlabs-blog/cve-2023-29383-abusing-linux-chfn-to-misrepresent-etc-passwd/
  - source: cve@mitre.org
    tags:
    - Exploit
    - Third Party Advisory
    url: https://www.trustwave.com/en-us/resources/security-resources/security-advisories/?fid=31797
  title: 'In Shadow 4.13, it is possible to inject control characters into fields
    provided to the SUID program chfn (change finger). Although it is not possible
    to exploit this directly (e.g., adding a new user fails because \n is in the block
    list), it is possible to misrepresent the /etc/passwd file when viewed. Use of
    \r manipulations and Unicode characters to work around blocking of the : character
    make it possible to give the impression that a new user has been added. In other
    words, an adversary may be able to convince a system administrator to take the
    system offline (an indirect, social-engineered denial of service) by demonstrating
    that "cat /etc/passwd" shows a rogue user account.'
- diff_content:
  - "--- a/lib/libcrypto/x509/x509_verify.c\n+++ b/lib/libcrypto/x509/x509_verify.c\n\
    @@ -1,4 +1,4 @@\n-/* $OpenBSD: x509_verify.c,v 1.53 2021/11/14 08:21:47 jsing\
    \ Exp $ */\n+/* $OpenBSD: x509_verify.c,v 1.54 2021/11/24 05:38:12 beck Exp $\
    \ */\n /*\n  * Copyright (c) 2020-2021 Bob Beck <beck@openbsd.org>\n  *\n@@ -1164,62\
    \ +1164,99 @@ x509_verify(struct x509_verify_ctx *ctx, X509 *leaf, char *name)\n\
    \ \tx509_verify_chain_free(current_chain);\n \n \t/*\n-\t * Bring back the failure\
    \ case we wanted to the xsc if\n-\t * we saved one.\n+\t * Do the new verifier\
    \ style return, where we don't have an xsc\n+\t * that allows a crazy callback\
    \ to turn invalid things into valid.\n \t */\n-\tif (!x509_verify_ctx_restore_xsc_error(ctx))\n\
    -\t\tgoto err;\n+\tif (ctx->xsc == NULL) {\n+\t\t/*\n+\t\t * Safety net:\n+\t\t\
    \ * We could not find a validated chain, and for some reason do not\n+\t\t * have\
    \ an error set.\n+\t\t */\n+\t\tif (ctx->chains_count == 0 && ctx->error == X509_V_OK)\n\
    +\t\t\tctx->error = X509_V_ERR_UNSPECIFIED;\n+\n+\t\t/*\n+\t\t * If we are not\
    \ using an xsc, and have no possibility for the\n+\t\t * crazy OpenSSL callback\
    \ API changing the results of\n+\t\t * validation steps (because the callback\
    \ can make validation\n+\t\t * proceed in the presence of invalid certs), any\
    \ chains we\n+\t\t * have here are correctly built and verified.\n+\t\t */\n+\t\
    \tif (ctx->chains_count > 0)\n+\t\t\tctx->error = X509_V_OK;\n+\n+\t\treturn ctx->chains_count;\n\
    +\t}\n \n \t/*\n-\t * Safety net:\n-\t * We could not find a validated chain,\
    \ and for some reason do not\n-\t * have an error set.\n+\t * Otherwise we are\
    \ doing compatibility with an xsc, which means that we\n+\t * will have one chain,\
    \ which might actually be a bogus chain because\n+\t * the callback told us to\
    \ ignore errors and proceed to build an invalid\n+\t * chain. Possible return\
    \ values from this include returning 1 with an\n+\t * invalid chain and a value\
    \ of xsc->error != X509_V_OK (It's tradition\n+\t * that makes it ok).\n \t */\n\
    -\tif (ctx->chains_count == 0 && ctx->error == X509_V_OK) {\n-\t\tctx->error =\
    \ X509_V_ERR_UNSPECIFIED;\n-\t\tif (ctx->xsc != NULL && ctx->xsc->error != X509_V_OK)\n\
    -\t\t\tctx->error = ctx->xsc->error;\n-\t}\n \n-\t/* Clear whatever errors happened\
    \ if we have any validated chain */\n-\tif (ctx->chains_count > 0)\n-\t\tctx->error\
    \ = X509_V_OK;\n+\tif (ctx->chains_count > 0) {\n+\t\t/*\n+\t\t * The chain we\
    \ have using an xsc might not be a verified chain\n+\t\t * if the callback perverted\
    \ things while we built it to ignore\n+\t\t * failures and proceed with chain\
    \ building. We put this chain\n+\t\t * and the error associated with it on the\
    \ xsc.\n+\t\t */\n+\t\tif (!x509_verify_ctx_set_xsc_chain(ctx, ctx->chains[0],\
    \ 1, 1))\n+\t\t\tgoto err;\n \n-\tif (ctx->xsc != NULL) {\n-\t\tctx->xsc->error\
    \ = ctx->error;\n-\t\tif (ctx->chains_count > 0) {\n-\t\t\t/* Take the first chain\
    \ we found. */\n-\t\t\tif (!x509_verify_ctx_set_xsc_chain(ctx, ctx->chains[0],\n\
    -\t\t\t    1, 1))\n-\t\t\t\tgoto err;\n-\t\t\tctx->xsc->error = X509_V_OK;\n-\t\
    \t\t/*\n-\t\t\t * Call the callback indicating success up our already\n-\t\t\t\
    \ * verified chain. The callback could still tell us to\n-\t\t\t * fail.\n-\t\t\
    \t */\n-\t\t\tif(!x509_vfy_callback_indicate_success(ctx->xsc)) {\n-\t\t\t\t/*\
    \ The callback can change the error code */\n-\t\t\t\tctx->error = ctx->xsc->error;\n\
    -\t\t\t\tgoto err;\n-\t\t\t}\n-\t\t} else {\n-\t\t\t/*\n-\t\t\t * We had a failure,\
    \ indicate the failure, but\n-\t\t\t * allow the callback to override at depth\
    \ 0\n-\t\t\t */\n-\t\t\tif (ctx->xsc->verify_cb(0, ctx->xsc)) {\n-\t\t\t\tctx->xsc->error\
    \ = X509_V_OK;\n-\t\t\t\treturn 1;\n-\t\t\t}\n+\t\t/*\n+\t\t * Call the callback\
    \ for completion up our built\n+\t\t * chain. The callback could still tell us\
    \ to\n+\t\t * fail. Since this chain might exist as the result of\n+\t\t * callback\
    \ doing perversions, we could still return\n+\t\t * \"success\" with something\
    \ other than X509_V_OK set\n+\t\t * as the error.\n+\t\t */\n+\t\tif (!x509_vfy_callback_indicate_completion(ctx->xsc))\n\
    +\t\t\tgoto err;\n+\t} else {\n+\t\t/*\n+\t\t * We did not find a chain. Bring\
    \ back the failure\n+\t\t * case we wanted to the xsc if we saved one. If we\n\
    +\t\t * did not we should have just the leaf on the xsc.\n+\t\t */\n+\t\tif (!x509_verify_ctx_restore_xsc_error(ctx))\n\
    +\t\t\tgoto err;\n+\n+\t\t/*\n+\t\t * Safety net, ensure we have an error set\
    \ in the\n+\t\t * failing case.\n+\t\t */\n+\t\tif (ctx->xsc->error == X509_V_OK)\
    \ {\n+\t\t\tif (ctx->error == X509_V_OK)\n+\t\t\t\tctx->error = X509_V_ERR_UNSPECIFIED;\n\
    +\t\t\tctx->xsc->error = ctx->error;\n \t\t}\n+\n+\t\t/*\n+\t\t * Let the callback\
    \ override the return value\n+\t\t * at depth 0 if it chooses to\n+\t\t */\n+\t\
    \treturn ctx->xsc->verify_cb(0, ctx->xsc);\n \t}\n-\treturn (ctx->chains_count);\n\
    +\n+\t/* We only ever find one chain in compat mode with an xsc. */\n+\treturn\
    \ 1;\n \n  err:\n \tif (ctx->error == X509_V_OK)\n \t\tctx->error = X509_V_ERR_UNSPECIFIED;\n\
    -\tif (ctx->xsc != NULL)\n-\t\tctx->xsc->error = ctx->error;\n+\n+\tif (ctx->xsc\
    \ != NULL) {\n+\t\tif (ctx->xsc->error == X509_V_OK)\n+\t\t\tctx->xsc->error =\
    \ X509_V_ERR_UNSPECIFIED;\n+\t\tctx->error = ctx->xsc->error;\n+\t}\n+\n \treturn\
    \ 0;\n }\n+"
  - "--- a/lib/libcrypto/x509/x509_vfy.c\n+++ b/lib/libcrypto/x509/x509_vfy.c\n@@\
    \ -1,4 +1,4 @@\n-/* $OpenBSD: x509_vfy.c,v 1.97 2021/11/13 18:24:45 schwarze Exp\
    \ $ */\n+/* $OpenBSD: x509_vfy.c,v 1.98 2021/11/24 05:38:12 beck Exp $ */\n /*\
    \ Copyright (C) 1995-1998 Eric Young (eay@cryptsoft.com)\n  * All rights reserved.\n\
    \  *\n@@ -1989,8 +1989,12 @@ internal_verify(X509_STORE_CTX *ctx)\n \treturn x509_vfy_internal_verify(ctx,\
    \ 0);\n }\n \n+/*\n+ * Internal verify, but with a chain where the verification\n\
    + * math has already been performed.\n+ */\n int\n-x509_vfy_callback_indicate_success(X509_STORE_CTX\
    \ *ctx)\n+x509_vfy_callback_indicate_completion(X509_STORE_CTX *ctx)\n {\n \t\
    return x509_vfy_internal_verify(ctx, 1);\n }"
  identifiers:
  - CVE-2021-46880
  - CWE-295
  overview: x509/x509_verify.c in LibreSSL before 3.4.2, and OpenBSD before 7.0 errata
    006, allows authentication bypass because an error for an unverified certificate
    chain is sometimes discarded.
  references:
  - source: cve@mitre.org
    tags:
    - Release Notes
    url: https://ftp.openbsd.org/pub/OpenBSD/LibreSSL/libressl-3.4.2-relnotes.txt
  - source: cve@mitre.org
    tags:
    - Patch
    url: https://ftp.openbsd.org/pub/OpenBSD/patches/7.0/common/006_x509.patch.sig
  - source: cve@mitre.org
    tags:
    - Patch
    url: https://github.com/openbsd/src/commit/3f851282810fa0ab4b90b3b1ecec2e8717ef16f8
  - source: cve@mitre.org
    url: https://security.netapp.com/advisory/ntap-20230517-0006/
  title: x509/x509_verify.c in LibreSSL before 3.4.2, and OpenBSD before 7.0 errata
    006, allows authentication bypass because an error for an unverified certificate
    chain is sometimes discarded.
- diff_content:
  - "--- a/src/plugins/sqldrivers/odbc/qsql_odbc.cpp\n+++ b/src/plugins/sqldrivers/odbc/qsql_odbc.cpp\n\
    @@ -745,6 +745,14 @@ QChar QODBCDriverPrivate::quoteChar()\n     return quote;\n\
    \ }\n \n+static SQLRETURN qt_string_SQLSetConnectAttr(SQLHDBC handle, SQLINTEGER\
    \ attr, const QString &val)\n+{\n+    auto encoded = toSQLTCHAR(val);\n+    return\
    \ SQLSetConnectAttr(handle, attr,\n+                             encoded.data(),\n\
    +                             SQLINTEGER(encoded.size() * sizeof(SQLTCHAR)));\
    \ // size in bytes\n+}\n+\n \n bool QODBCDriverPrivate::setConnectionOptions(const\
    \ QString& connOpts)\n {\n@@ -780,10 +788,7 @@ bool QODBCDriverPrivate::setConnectionOptions(const\
    \ QString& connOpts)\n             v = val.toUInt();\n             r = SQLSetConnectAttr(hDbc,\
    \ SQL_ATTR_LOGIN_TIMEOUT, (SQLPOINTER) size_t(v), 0);\n         } else if (opt.toUpper()\
    \ == \"SQL_ATTR_CURRENT_CATALOG\"_L1) {\n-            val.utf16(); // 0 terminate\n\
    -            r = SQLSetConnectAttr(hDbc, SQL_ATTR_CURRENT_CATALOG,\n-        \
    \                            toSQLTCHAR(val).data(),\n-                      \
    \              SQLINTEGER(val.length() * sizeof(SQLTCHAR)));\n+            r =\
    \ qt_string_SQLSetConnectAttr(hDbc, SQL_ATTR_CURRENT_CATALOG, val);\n        \
    \ } else if (opt.toUpper() == \"SQL_ATTR_METADATA_ID\"_L1) {\n             if\
    \ (val.toUpper() == \"SQL_TRUE\"_L1) {\n                 v = SQL_TRUE;\n@@ -798,10\
    \ +803,7 @@ bool QODBCDriverPrivate::setConnectionOptions(const QString& connOpts)\n\
    \             v = val.toUInt();\n             r = SQLSetConnectAttr(hDbc, SQL_ATTR_PACKET_SIZE,\
    \ (SQLPOINTER) size_t(v), 0);\n         } else if (opt.toUpper() == \"SQL_ATTR_TRACEFILE\"\
    _L1) {\n-            val.utf16(); // 0 terminate\n-            r = SQLSetConnectAttr(hDbc,\
    \ SQL_ATTR_TRACEFILE,\n-                                    toSQLTCHAR(val).data(),\n\
    -                                    SQLINTEGER(val.length() * sizeof(SQLTCHAR)));\n\
    +            r = qt_string_SQLSetConnectAttr(hDbc, SQL_ATTR_TRACEFILE, val);\n\
    \         } else if (opt.toUpper() == \"SQL_ATTR_TRACE\"_L1) {\n             if\
    \ (val.toUpper() == \"SQL_OPT_TRACE_OFF\"_L1) {\n                 v = SQL_OPT_TRACE_OFF;\n\
    @@ -1004,9 +1006,12 @@ bool QODBCResult::reset (const QString& query)\n      \
    \   return false;\n     }\n \n-    r = SQLExecDirect(d->hStmt,\n-            \
    \           toSQLTCHAR(query).data(),\n-                       (SQLINTEGER) query.length());\n\
    +    {\n+        auto encoded = toSQLTCHAR(query);\n+        r = SQLExecDirect(d->hStmt,\n\
    +                          encoded.data(),\n+                          SQLINTEGER(encoded.size()));\n\
    +    }\n     if (r != SQL_SUCCESS && r != SQL_SUCCESS_WITH_INFO && r!= SQL_NO_DATA)\
    \ {\n         setLastError(qMakeError(QCoreApplication::translate(\"QODBCResult\"\
    ,\n                      \"Unable to execute statement\"), QSqlError::StatementError,\
    \ d));\n@@ -1355,9 +1360,12 @@ bool QODBCResult::prepare(const QString& query)\n\
    \         return false;\n     }\n \n-    r = SQLPrepare(d->hStmt,\n-         \
    \           toSQLTCHAR(query).data(),\n-                    (SQLINTEGER) query.length());\n\
    +    {\n+        auto encoded = toSQLTCHAR(query);\n+        r = SQLPrepare(d->hStmt,\n\
    +                       encoded.data(),\n+                       SQLINTEGER(encoded.size()));\n\
    +    }\n \n     if (r != SQL_SUCCESS) {\n         setLastError(qMakeError(QCoreApplication::translate(\"\
    QODBCResult\",\n@@ -1385,7 +1393,7 @@ bool QODBCResult::exec()\n         SQLCloseCursor(d->hStmt);\n\
    \ \n     QVariantList &values = boundValues();\n-    QByteArrayList tmpStorage(values.count(),\
    \ QByteArray()); // holds temporary buffers\n+    QByteArrayList tmpStorage(values.count(),\
    \ QByteArray()); // targets for SQLBindParameter()\n     QVarLengthArray<SQLLEN,\
    \ 32> indicators(values.count());\n     memset(indicators.data(), 0, indicators.size()\
    \ * sizeof(SQLLEN));\n \n@@ -1600,36 +1608,36 @@ bool QODBCResult::exec()\n  \
    \           case QMetaType::QString:\n                 if (d->unicode) {\n   \
    \                  QByteArray &ba = tmpStorage[i];\n-                    QString\
    \ str = val.toString();\n+                    {\n+                        const\
    \ auto encoded = toSQLTCHAR(val.toString());\n+                        ba = QByteArray(reinterpret_cast<const\
    \ char *>(encoded.data()),\n+                                        encoded.size()\
    \ * sizeof(SQLTCHAR));\n+                    }\n+\n                     if (*ind\
    \ != SQL_NULL_DATA)\n-                        *ind = str.length() * sizeof(SQLTCHAR);\n\
    -                    const qsizetype strSize = str.length() * sizeof(SQLTCHAR);\n\
    +                        *ind = ba.size();\n \n                     if (bindValueType(i)\
    \ & QSql::Out) {\n-                        const QVarLengthArray<SQLTCHAR> a(toSQLTCHAR(str));\n\
    -                        ba = QByteArray((const char *)a.constData(), int(a.size()\
    \ * sizeof(SQLTCHAR)));\n                         r = SQLBindParameter(d->hStmt,\n\
    \                                             i + 1,\n                       \
    \                      qParamType[bindValueType(i) & QSql::InOut],\n         \
    \                                    SQL_C_TCHAR,\n-                         \
    \                   strSize > 254 ? SQL_WLONGVARCHAR : SQL_WVARCHAR,\n+      \
    \                                      ba.size() > 254 ? SQL_WLONGVARCHAR : SQL_WVARCHAR,\n\
    \                                             0, // god knows... don't change\
    \ this!\n                                             0,\n-                  \
    \                          ba.data(),\n+                                     \
    \       const_cast<char *>(ba.constData()), // don't detach\n                \
    \                             ba.size(),\n                                   \
    \          ind);\n                         break;\n                     }\n- \
    \                   ba = QByteArray(reinterpret_cast<const char *>(toSQLTCHAR(str).constData()),\n\
    -                                    int(strSize));\n                     r =\
    \ SQLBindParameter(d->hStmt,\n                                           i + 1,\n\
    \                                           qParamType[bindValueType(i) & QSql::InOut],\n\
    \                                           SQL_C_TCHAR,\n-                  \
    \                        strSize > 254 ? SQL_WLONGVARCHAR : SQL_WVARCHAR,\n- \
    \                                         strSize,\n+                        \
    \                  ba.size() > 254 ? SQL_WLONGVARCHAR : SQL_WVARCHAR,\n+     \
    \                                     ba.size(),\n                           \
    \                0,\n-                                          const_cast<char\
    \ *>(ba.constData()),\n+                                          const_cast<char\
    \ *>(ba.constData()), // don't detach\n                                      \
    \     ba.size(),\n                                           ind);\n         \
    \            break;\n@@ -1991,14 +1999,16 @@ bool QODBCDriver::open(const QString\
    \ & db,\n     SQLSMALLINT cb;\n     QVarLengthArray<SQLTCHAR> connOut(1024);\n\
    \     memset(connOut.data(), 0, connOut.size() * sizeof(SQLTCHAR));\n-    r =\
    \ SQLDriverConnect(d->hDbc,\n-                          NULL,\n-             \
    \             toSQLTCHAR(connQStr).data(),\n-                          (SQLSMALLINT)connQStr.length(),\n\
    -                          connOut.data(),\n-                          1024,\n\
    -                          &cb,\n-                          /*SQL_DRIVER_NOPROMPT*/0);\n\
    +    {\n+        auto encoded = toSQLTCHAR(connQStr);\n+        r = SQLDriverConnect(d->hDbc,\n\
    +                             nullptr,\n+                             encoded.data(),\
    \ SQLSMALLINT(encoded.size()),\n+                             connOut.data(),\n\
    +                             1024,\n+                             &cb,\n+   \
    \                          /*SQL_DRIVER_NOPROMPT*/0);\n+    }\n \n     if (r !=\
    \ SQL_SUCCESS && r != SQL_SUCCESS_WITH_INFO) {\n         setLastError(qMakeError(tr(\"\
    Unable to connect\"), QSqlError::ConnectionError, d));\n@@ -2377,17 +2387,15 @@\
    \ QStringList QODBCDriver::tables(QSql::TableType type) const\n     if (tableType.isEmpty())\n\
    \         return tl;\n \n-    QString joinedTableTypeString = tableType.join(u',');\n\
    +    {\n+        auto joinedTableTypeString = toSQLTCHAR(tableType.join(u','));\n\
    \ \n-    r = SQLTables(hStmt,\n-                   NULL,\n-                  \
    \ 0,\n-                   NULL,\n-                   0,\n-                   NULL,\n\
    -                   0,\n-                   toSQLTCHAR(joinedTableTypeString).data(),\n\
    -                   joinedTableTypeString.length() /* characters, not bytes */);\n\
    +        r = SQLTables(hStmt,\n+                      nullptr, 0,\n+         \
    \             nullptr, 0,\n+                      nullptr, 0,\n+             \
    \         joinedTableTypeString.data(), joinedTableTypeString.size());\n+    }\n\
    \ \n     if (r != SQL_SUCCESS)\n         qSqlWarning(\"QODBCDriver::tables Unable\
    \ to execute table list\"_L1, d);\n@@ -2460,28 +2468,30 @@ QSqlIndex QODBCDriver::primaryIndex(const\
    \ QString& tablename) const\n                         SQL_ATTR_CURSOR_TYPE,\n\
    \                         (SQLPOINTER)SQL_CURSOR_FORWARD_ONLY,\n             \
    \            SQL_IS_UINTEGER);\n-    r = SQLPrimaryKeys(hStmt,\n-            \
    \            catalog.length() == 0 ? NULL : toSQLTCHAR(catalog).data(),\n-   \
    \                     catalog.length(),\n-                        schema.length()\
    \ == 0 ? NULL : toSQLTCHAR(schema).data(),\n-                        schema.length(),\n\
    -                        toSQLTCHAR(table).data(),\n-                        table.length()\
    \ /* in characters, not in bytes */);\n+    {\n+        auto c = toSQLTCHAR(catalog);\n\
    +        auto s = toSQLTCHAR(schema);\n+        auto t = toSQLTCHAR(table);\n\
    +        r = SQLPrimaryKeys(hStmt,\n+                           catalog.isEmpty()\
    \ ? nullptr : c.data(), c.size(),\n+                           schema.isEmpty()\
    \  ? nullptr : s.data(), s.size(),\n+                           t.data(), t.size());\n\
    +    }\n \n     // if the SQLPrimaryKeys() call does not succeed (e.g the driver\n\
    \     // does not support it) - try an alternative method to get hold of\n   \
    \  // the primary index (e.g MS Access and FoxPro)\n     if (r != SQL_SUCCESS)\
    \ {\n-            r = SQLSpecialColumns(hStmt,\n-                        SQL_BEST_ROWID,\n\
    -                        catalog.length() == 0 ? NULL : toSQLTCHAR(catalog).data(),\n\
    -                        catalog.length(),\n-                        schema.length()\
    \ == 0 ? NULL : toSQLTCHAR(schema).data(),\n-                        schema.length(),\n\
    -                        toSQLTCHAR(table).data(),\n-                        table.length(),\n\
    -                        SQL_SCOPE_CURROW,\n-                        SQL_NULLABLE);\n\
    +        auto c = toSQLTCHAR(catalog);\n+        auto s = toSQLTCHAR(schema);\n\
    +        auto t = toSQLTCHAR(table);\n+        r = SQLSpecialColumns(hStmt,\n\
    +                              SQL_BEST_ROWID,\n+                            \
    \  catalog.isEmpty() ? nullptr : c.data(), c.size(),\n+                      \
    \        schema.isEmpty()  ? nullptr : s.data(), s.size(),\n+                \
    \              t.data(), t.size(),\n+                              SQL_SCOPE_CURROW,\n\
    +                              SQL_NULLABLE);\n \n             if (r != SQL_SUCCESS)\
    \ {\n                 qSqlWarning(\"QODBCDriver::primaryIndex: Unable to execute\
    \ primary key list\"_L1, d);\n@@ -2562,15 +2572,17 @@ QSqlRecord QODBCDriver::record(const\
    \ QString& tablename) const\n                         SQL_ATTR_CURSOR_TYPE,\n\
    \                         (SQLPOINTER)SQL_CURSOR_FORWARD_ONLY,\n             \
    \            SQL_IS_UINTEGER);\n-    r =  SQLColumns(hStmt,\n-               \
    \      catalog.length() == 0 ? NULL : toSQLTCHAR(catalog).data(),\n-         \
    \            catalog.length(),\n-                     schema.length() == 0 ? NULL\
    \ : toSQLTCHAR(schema).data(),\n-                     schema.length(),\n-    \
    \                 toSQLTCHAR(table).data(),\n-                     table.length(),\n\
    -                     NULL,\n-                     0);\n+    {\n+        auto\
    \ c = toSQLTCHAR(catalog);\n+        auto s = toSQLTCHAR(schema);\n+        auto\
    \ t = toSQLTCHAR(table);\n+        r =  SQLColumns(hStmt,\n+                 \
    \       catalog.isEmpty() ? nullptr : c.data(), c.size(),\n+                 \
    \       schema.isEmpty()  ? nullptr : s.data(), s.size(),\n+                 \
    \       t.data(), t.size(),\n+                        nullptr,\n+            \
    \            0);\n+    }\n     if (r != SQL_SUCCESS)\n         qSqlWarning(\"\
    QODBCDriver::record: Unable to execute column list\"_L1, d);\n "
  identifiers:
  - CVE-2023-24607
  - NVD-CWE-noinfo
  overview: Qt before 6.4.3 allows a denial of service via a crafted string when the
    SQL ODBC driver plugin is used and the size of SQLTCHAR is 4. The affected versions
    are 5.x before 5.15.13, 6.x before 6.2.8, and 6.3.x before 6.4.3.
  references:
  - source: cve@mitre.org
    tags:
    - Issue Tracking
    url: https://codereview.qt-project.org/c/qt/qtbase/+/456216
  - source: cve@mitre.org
    tags:
    - Permissions Required
    url: https://codereview.qt-project.org/c/qt/tqtc-qtbase/+/456217
  - source: cve@mitre.org
    tags:
    - Permissions Required
    url: https://codereview.qt-project.org/c/qt/tqtc-qtbase/+/456238
  - source: cve@mitre.org
    tags:
    - Vendor Advisory
    url: https://download.qt.io/official_releases/qt/5.15/CVE-2023-24607-qtbase-5.15.diff
  - source: cve@mitre.org
    tags:
    - Patch
    - Third Party Advisory
    url: https://github.com/qt/qtbase/commit/aaf1381eab6292aa0444a5eadcc24165b6e1c02d
  - source: cve@mitre.org
    tags:
    - Product
    url: https://www.qt.io/blog/security-advisory-qt-sql-odbc-driver-plugin
  - source: cve@mitre.org
    tags:
    - Release Notes
    url: https://www.qt.io/blog/tag/security
  title: Qt before 6.4.3 allows a denial of service via a crafted string when the
    SQL ODBC driver plugin is used and the size of SQLTCHAR is 4. The affected versions
    are 5.x before 5.15.13, 6.x before 6.2.8, and 6.3.x before 6.4.3.
- diff_content:
  - "--- a/src/daemon/protocols/sonmp.c\n+++ b/src/daemon/protocols/sonmp.c\n@@ -311,7\
    \ +311,7 @@ sonmp_decode(struct lldpd *cfg, char *frame, int s,\n \n \tlength\
    \ = s;\n \tpos = (u_int8_t*)frame;\n-\tif (length < SONMP_SIZE) {\n+\tif (length\
    \ < SONMP_SIZE + 2*ETHER_ADDR_LEN + sizeof(u_int16_t)) {\n \t\tlog_warnx(\"sonmp\"\
    , \"too short SONMP frame received on %s\", hardware->h_ifname);\n \t\tgoto malformed;\n\
    \ \t}"
  - "--- a/tests/check_sonmp.c\n+++ b/tests/check_sonmp.c\n@@ -33,7 +33,7 @@ START_TEST\
    \ (test_send_sonmp)\n IEEE 802.3 Ethernet \n     Destination: Bay-Networks-(Synoptics)-autodiscovery\
    \ (01:00:81:00:01:00)\n     Source: 5e:10:8e:e7:84:ad (5e:10:8e:e7:84:ad)\n- \
    \   Length: 22\n+    Length: 19\n Logical-Link Control\n     DSAP: SNAP (0xaa)\n\
    \     IG Bit: Individual\n@@ -55,7 +55,7 @@ Nortel Networks / SynOptics Network\
    \ Management Protocol\n IEEE 802.3 Ethernet \n     Destination: Bay-Networks-(Synoptics)-autodiscovery\
    \ (01:00:81:00:01:01)\n     Source: 5e:10:8e:e7:84:ad (5e:10:8e:e7:84:ad)\n- \
    \   Length: 22\n+    Length: 19\n Logical-Link Control\n     DSAP: SNAP (0xaa)\n\
    \     IG Bit: Individual\n@@ -76,13 +76,13 @@ Nortel Networks / SynOptics Network\
    \ Management Protocol\n \t*/\n \tchar pkt1[] = {\n \t\t0x01, 0x00, 0x81, 0x00,\
    \ 0x01, 0x00, 0x5e, 0x10,\n-\t\t0x8e, 0xe7, 0x84, 0xad, 0x00, 0x16, 0xaa, 0xaa,\n\
    +\t\t0x8e, 0xe7, 0x84, 0xad, 0x00, 0x13, 0xaa, 0xaa,\n \t\t0x03, 0x00, 0x00, 0x81,\
    \ 0x01, 0xa2, 0xac, 0x11,\n \t\t0x8e, 0x25, 0x00, 0x00, 0x04, 0x01, 0x0c, 0x03,\n\
    \ \t\t0x01 };\n \tchar pkt2[] = {\n \t\t0x01, 0x00, 0x81, 0x00, 0x01, 0x01, 0x5e,\
    \ 0x10,\n-\t\t0x8e, 0xe7, 0x84, 0xad, 0x00, 0x16, 0xaa, 0xaa,\n+\t\t0x8e, 0xe7,\
    \ 0x84, 0xad, 0x00, 0x13, 0xaa, 0xaa,\n \t\t0x03, 0x00, 0x00, 0x81, 0x01, 0xa1,\
    \ 0xac, 0x11,\n \t\t0x8e, 0x25, 0x00, 0x00, 0x04, 0x01, 0x0c, 0x03,\n \t\t0x01\
    \ };"
  identifiers:
  - CVE-2021-43612
  - CWE-787
  overview: In lldpd before 1.0.13, when decoding SONMP packets in the sonmp_decode
    function, it's possible to trigger an out-of-bounds heap read via short SONMP
    packets.
  references:
  - source: cve@mitre.org
    tags:
    - Patch
    url: https://github.com/lldpd/lldpd/commit/73d42680fce8598324364dbb31b9bc3b8320adf7
  - source: cve@mitre.org
    tags:
    - Patch
    - Release Notes
    url: https://github.com/lldpd/lldpd/compare/1.0.12...1.0.13
  - source: cve@mitre.org
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/3T5XHPOGIPWCRRPJUE6P3HVC5PTSD5JS/
  - source: cve@mitre.org
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/JYA4AMJXCNF6UPFG36L2TPPT32C242SP/
  - source: cve@mitre.org
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/SKQWHG2SZJZSGC7PXVDAEJYBN7ESDR7D/
  - source: cve@mitre.org
    tags:
    - Patch
    - Third Party Advisory
    url: https://lldpd.github.io/security.html
  title: In lldpd before 1.0.13, when decoding SONMP packets in the sonmp_decode function,
    it's possible to trigger an out-of-bounds heap read via short SONMP packets.
- diff_content:
  - "--- a/dwarfdump/dwarf_names.c\n+++ b/dwarfdump/dwarf_names.c\n@@ -1,5 +1,5 @@\n\
    \ /* Generated routines, do not edit. */\n-/* Generated sourcedate  2020-10-11\
    \ 11:34:27-07:00   */\n+/* Generated sourcedate  2020-10-17 11:30:22-07:00   */\n\
    \ \n /* BEGIN FILE */\n "
  - "--- a/libdwarf/dwarf_names.c\n+++ b/libdwarf/dwarf_names.c\n@@ -1,5 +1,5 @@\n\
    \ /* Generated routines, do not edit. */\n-/* Generated sourcedate  2020-10-11\
    \ 11:34:27-07:00   */\n+/* Generated sourcedate  2020-10-17 11:30:22-07:00   */\n\
    \ \n /* BEGIN FILE */\n "
  identifiers:
  - CVE-2020-27545
  - CWE-763
  overview: libdwarf before 20201017 has a one-byte out-of-bounds read because of
    an invalid pointer dereference via an invalid line table in a crafted object.
  references:
  - source: cve@mitre.org
    tags:
    - Product
    url: http://web.archive.org/web/20190601140703/https://sourceforge.net/projects/libdwarf/
  - source: cve@mitre.org
    tags:
    - Issue Tracking
    - Permissions Required
    - Third Party Advisory
    url: https://bugzilla.redhat.com/show_bug.cgi?id=2025694
  - source: cve@mitre.org
    tags:
    - Patch
    url: https://github.com/davea42/libdwarf-code/commit/95f634808c01f1c61bbec56ed2395af997f397ea
  - source: cve@mitre.org
    tags:
    - Product
    url: https://sourceforge.net/projects/libdwarf/
  - source: cve@mitre.org
    tags:
    - Third Party Advisory
    url: https://www.prevanders.net/dwarfbug.html#DW202010-001
  title: libdwarf before 20201017 has a one-byte out-of-bounds read because of an
    invalid pointer dereference via an invalid line table in a crafted object.
- diff_content:
  - "--- a/libdwarf/dwarf_print_lines.c\n+++ b/libdwarf/dwarf_print_lines.c\n@@ -54,8\
    \ +54,10 @@ print_line_header(Dwarf_Debug dbg,\n     Dwarf_Bool is_actuals_tab)\n\
    \ {\n if (!is_single_tab) {\n-    /* Ugly indenting follows, it makes lines shorter\
    \ to see them better.\n-        Best to use a wider text window to really see\
    \ how it looks.*/\n+    /*  Ugly indenting follows, it makes lines shorter\n+\
    \        to see them better.\n+        Best to use a wider text window to really\n\
    +        see how it looks.*/\n if (is_actuals_tab) {\n _dwarf_printf(dbg,\"\\\
    nActuals Table\\n\");\n _dwarf_printf(dbg,\n@@ -102,13 +104,15 @@ print_line_detail(\n\
    \     if(!is_single_table && is_actuals_table) {\n         dwarfstring_append_printf_s(&m1,\"\
    %-15s \",(char *)prefix);\n         dwarfstring_append_printf_i(&m1,\"%3d \",opcode);\n\
    -        dwarfstring_append_printf_u(&m1,\"0x%\" DW_PR_XZEROS DW_PR_DUx ,\n+ \
    \       dwarfstring_append_printf_u(&m1,\"0x%\" DW_PR_XZEROS DW_PR_DUx,\n    \
    \         regs->lr_address);\n         dwarfstring_append_printf_u(&m1,\"/%01u\"\
    ,regs->lr_op_index);\n         dwarfstring_append_printf_u(&m1,\" %5lu\", regs->lr_line);\n\
    \         dwarfstring_append_printf_u(&m1,\" %3d\",regs->lr_isa);\n-        dwarfstring_append_printf_i(&m1,\"\
    \   %1d\", regs->lr_basic_block);\n-        dwarfstring_append_printf_i(&m1,\"\
    %1d\\n\",  regs->lr_end_sequence);\n+        dwarfstring_append_printf_i(&m1,\"\
    \   %1d\",\n+            regs->lr_basic_block);\n+        dwarfstring_append_printf_i(&m1,\"\
    %1d\\n\",\n+            regs->lr_end_sequence);\n         _dwarf_printf(dbg,dwarfstring_string(&m1));\n\
    \         dwarfstring_destructor(&m1);\n         return;\n@@ -138,9 +142,11 @@\
    \ print_line_detail(\n                 \"   x%02\" DW_PR_DUx ,\n             \
    \    regs->lr_discriminator); /* DWARF4 */\n             dwarfstring_append_printf_u(&m1,\n\
    -                \"  x%02\" DW_PR_DUx , regs->lr_call_context); /* EXPERIMENTAL\
    \ */\n+                \"  x%02\" DW_PR_DUx,\n+                regs->lr_call_context);\
    \ /* EXPERIMENTAL */\n             dwarfstring_append_printf_u(&m1,\n-       \
    \         \"  x%02\" DW_PR_DUx , regs->lr_subprogram); /* EXPERIMENTAL */\n+ \
    \               \"  x%02\" DW_PR_DUx ,\n+                regs->lr_subprogram);\
    \ /* EXPERIMENTAL */\n             dwarfstring_append_printf_i(&m1,\n        \
    \         \"  %1d\", regs->lr_is_stmt);\n             dwarfstring_append_printf_i(&m1,\n\
    @@ -236,7 +242,8 @@ print_include_directory_details(Dwarf_Debug dbg,\n       \
    \          tname = \"<unknown type>\";\n             }\n             dwarfstring_append_printf_u\
    \ (&m4,\n-                \" type 0x%\" DW_PR_XZEROS DW_PR_DUx ,valpair->up_first);\n\
    +                \" type 0x%\" DW_PR_XZEROS DW_PR_DUx,\n+                valpair->up_first);\n\
    \             dwarfstring_append_printf_s (&m4,\n                 \" %-20s\\n\"\
    ,(char *)tname);\n             res = dwarf_get_FORM_name(valpair->up_second,&fname);\n\
    @@ -327,20 +334,22 @@ print_just_file_entry_details(Dwarf_Debug dbg,\n       \
    \  if (line_context->lc_file_entry_count > 9) {\n             dwarfstring_append_printf_u(&m3,\n\
    \                 \"  file[%2u] \",fiu);\n-            dwarfstring_append_printf_s(&m3,\n\
    -                \"%-20s \",\n-                (char *) fe->fi_file_name);\n-\
    \            dwarfstring_append_printf_u(&m3,\n-                \"(file-number:\
    \ %u)\\n\",\n-                filenum);\n         } else {\n             dwarfstring_append_printf_u(&m3,\n\
    \                 \"  file[%u]  \", fiu);\n-            dwarfstring_append_printf_s(&m3,\n\
    -                \"%-20s \",(char *)fe->fi_file_name);\n-            dwarfstring_append_printf_u(&m3,\n\
    -                \"(file-number: %u)\\n\",filenum);\n         }\n+        /* \
    \ DWARF5 can have a null fi_file_name\n+            if  the format code in the\n\
    +            line table header is unknown, such\n+            as in a corrupt\
    \ object file. */\n+        dwarfstring_append_printf_s(&m3,\n+            \"\
    %-20s \",\n+            fe->fi_file_name?\n+            (char *) fe->fi_file_name:\n\
    +            \"<no file name>\");\n+        dwarfstring_append_printf_u(&m3,\n\
    +            \"(file-number: %u)\\n\",\n+            filenum);\n         _dwarf_printf(dbg,dwarfstring_string(&m3));\n\
    \         dwarfstring_reset(&m3);\n         if (fe->fi_dir_index_present) {\n\
    @@ -509,8 +518,8 @@ _dwarf_internal_printlines(Dwarf_Die die,\n     Dwarf_Small\
    \ *line_ptr = 0;\n     Dwarf_Small *orig_line_ptr = 0;\n \n-    /*  Pointer to\
    \ a DW_AT_stmt_list attribute in case it exists in the\n-        die. */\n+  \
    \  /*  Pointer to a DW_AT_stmt_list attribute in case\n+        it exists in the\
    \ die. */\n     Dwarf_Attribute stmt_list_attr = 0;\n \n     /*  Pointer to DW_AT_comp_dir\
    \ attribute in die. */\n@@ -568,7 +577,8 @@ _dwarf_internal_printlines(Dwarf_Die\
    \ die,\n     }\n \n     address_size = _dwarf_get_address_size(dbg, die);\n- \
    \   resattr = dwarf_attr(die, DW_AT_stmt_list, &stmt_list_attr, error);\n+   \
    \ resattr = dwarf_attr(die, DW_AT_stmt_list, &stmt_list_attr,\n+        error);\n\
    \     if (resattr != DW_DLV_OK) {\n         return resattr;\n     }\n@@ -600,7\
    \ +610,8 @@ _dwarf_internal_printlines(Dwarf_Die die,\n     section_start =  dbg->de_debug_line.dss_data;\n\
    \     {\n         Dwarf_Unsigned fission_size = 0;\n-        int resfis = _dwarf_get_fission_addition_die(die,\
    \ DW_SECT_LINE,\n+        int resfis = _dwarf_get_fission_addition_die(die,\n\
    +            DW_SECT_LINE,\n             &fission_offset,&fission_size,error);\n\
    \         if(resfis != DW_DLV_OK) {\n             dwarf_dealloc(dbg,stmt_list_attr,\
    \ DW_DLA_ATTR);\n@@ -612,8 +623,8 @@ _dwarf_internal_printlines(Dwarf_Die die,\n\
    \     line_ptr = orig_line_ptr;\n     dwarf_dealloc(dbg, stmt_list_attr, DW_DLA_ATTR);\n\
    \ \n-    /*  If die has DW_AT_comp_dir attribute, get the string that names\n\
    -        the compilation directory. */\n+    /*  If die has DW_AT_comp_dir attribute,\
    \ get the string\n+        that names the compilation directory. */\n     resattr\
    \ = dwarf_attr(die, DW_AT_comp_dir, &comp_dir_attr, error);\n     if (resattr\
    \ == DW_DLV_ERROR) {\n         return resattr;\n@@ -907,7 +918,8 @@ print_actuals_and_locals(Dwarf_Debug\
    \ dbg,\n                 is_actuals_table = true;\n                 /* Read Actuals\
    \ */\n \n-                print_line_header(dbg, is_single_table, is_actuals_table);\n\
    +                print_line_header(dbg, is_single_table,\n+                  \
    \  is_actuals_table);\n                 res = read_line_table_program(dbg,\n \
    \                    line_ptr_actuals, line_ptr_end, orig_line_ptr,\n        \
    \             section_start,"
  identifiers:
  - CVE-2020-28163
  - CWE-476
  overview: libdwarf before 20201201 allows a dwarf_print_lines.c NULL pointer dereference
    and application crash via a DWARF5 line-table header that has an invalid FORM
    for a pathname.
  references:
  - source: cve@mitre.org
    tags:
    - Product
    url: http://web.archive.org/web/20190601140703/https://sourceforge.net/projects/libdwarf/
  - source: cve@mitre.org
    tags:
    - Issue Tracking
    - Permissions Required
    - Third Party Advisory
    url: https://bugzilla.redhat.com/show_bug.cgi?id=2026000
  - source: cve@mitre.org
    tags:
    - Patch
    url: https://github.com/davea42/libdwarf-code/commit/faf99408e3f9f706fc3809dd400e831f989778d3
  - source: cve@mitre.org
    tags:
    - Third Party Advisory
    url: https://www.prevanders.net/dwarfbug.html#DW202010-003
  title: libdwarf before 20201201 allows a dwarf_print_lines.c NULL pointer dereference
    and application crash via a DWARF5 line-table header that has an invalid FORM
    for a pathname.
- diff_content:
  - "--- a/jsdtoa.c\n+++ b/jsdtoa.c\n@@ -691,10 +691,12 @@ js_strtod(const char *string,\
    \ char **endPtr)\n \t\t\t}\n \t\t\texpSign = FALSE;\n \t\t}\n-\t\twhile ((*p >=\
    \ '0') && (*p <= '9')) {\n+\t\twhile ((*p >= '0') && (*p <= '9') && exp < INT_MAX/10)\
    \ {\n \t\t\texp = exp * 10 + (*p - '0');\n \t\t\tp += 1;\n \t\t}\n+\t\twhile ((*p\
    \ >= '0') && (*p <= '9'))\n+\t\t\tp += 1;\n \t}\n \tif (expSign) {\n \t\texp =\
    \ fracExp - exp;"
  identifiers:
  - CVE-2021-33797
  - CWE-190
  overview: Buffer-overflow in jsdtoa.c in Artifex MuJS in versions 1.0.1 to 1.1.1.
    An integer overflow happens when js_strtod() reads in floating point exponent,
    which leads to a buffer overflow in the pointer *d.
  references:
  - source: patrick@puiterwijk.org
    tags:
    - Patch
    url: https://github.com/ccxvii/mujs/commit/833b6f1672b4f2991a63c4d05318f0b84ef4d550
  - source: patrick@puiterwijk.org
    tags:
    - Issue Tracking
    - Third Party Advisory
    url: https://github.com/ccxvii/mujs/issues/148
  title: Buffer-overflow in jsdtoa.c in Artifex MuJS in versions 1.0.1 to 1.1.1. An
    integer overflow happens when js_strtod() reads in floating point exponent, which
    leads to a buffer overflow in the pointer *d.
- diff_content:
  - "--- a/src/t_hash.c\n+++ b/src/t_hash.c\n@@ -666,6 +666,10 @@ void hincrbyfloatCommand(client\
    \ *c) {\n     unsigned int vlen;\n \n     if (getLongDoubleFromObjectOrReply(c,c->argv[3],&incr,NULL)\
    \ != C_OK) return;\n+    if (isnan(incr) || isinf(incr)) {\n+        addReplyError(c,\"\
    value is NaN or Infinity\");\n+        return;\n+    }\n     if ((o = hashTypeLookupWriteOrCreate(c,c->argv[1]))\
    \ == NULL) return;\n     if (hashTypeGetValue(o,c->argv[2]->ptr,&vstr,&vlen,&ll)\
    \ == C_OK) {\n         if (vstr) {"
  identifiers:
  - CVE-2023-28856
  - CWE-617
  overview: Redis is an open source, in-memory database that persists on disk. Authenticated
    users can use the `HINCRBYFLOAT` command to create an invalid hash field that
    will crash Redis on access in affected versions. This issue has been addressed
    in in versions 7.0.11, 6.2.12, and 6.0.19. Users are advised to upgrade. There
    are no known workarounds for this issue.
  references:
  - source: security-advisories@github.com
    tags:
    - Patch
    url: https://github.com/redis/redis/commit/bc7fe41e5857a0854d524e2a63a028e9394d2a5c
  - source: security-advisories@github.com
    tags:
    - Issue Tracking
    - Patch
    url: https://github.com/redis/redis/pull/11149
  - source: security-advisories@github.com
    tags:
    - Vendor Advisory
    url: https://github.com/redis/redis/security/advisories/GHSA-hjv8-vjf6-wcr6
  - source: security-advisories@github.com
    tags:
    - Mailing List
    - Third Party Advisory
    url: https://lists.debian.org/debian-lts-announce/2023/04/msg00023.html
  - source: security-advisories@github.com
    tags:
    - Mailing List
    - Third Party Advisory
    url: https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/EQ4DJSO4DMR55AWK6OPVJH5UTEB35R2Z/
  - source: security-advisories@github.com
    tags:
    - Mailing List
    - Third Party Advisory
    url: https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/LPUTH7NBQTZDVJWFNUD24ZCS6NDUFYS6/
  - source: security-advisories@github.com
    tags:
    - Mailing List
    - Third Party Advisory
    url: https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/OQGKMKSQE67L32HE6W5EI2I2YKW5VWHI/
  - source: security-advisories@github.com
    url: https://security.netapp.com/advisory/ntap-20230601-0007/
  title: Redis is an open source, in-memory database that persists on disk. Authenticated
    users can use the `HINCRBYFLOAT` command to create an invalid hash field that
    will crash Redis on access in affected versions. This issue has been addressed
    in in versions 7.0.11, 6.2.12, and 6.0.19. Users are advised to upgrade. There
    are no known workarounds for this issue.
- diff_content:
  - "--- a/drivers/i2c/busses/i2c-xgene-slimpro.c\n+++ b/drivers/i2c/busses/i2c-xgene-slimpro.c\n\
    @@ -308,6 +308,9 @@ static int slimpro_i2c_blkwr(struct slimpro_i2c_dev *ctx,\
    \ u32 chip,\n \tu32 msg[3];\n \tint rc;\n \n+\tif (writelen > I2C_SMBUS_BLOCK_MAX)\n\
    +\t\treturn -EINVAL;\n+\n \tmemcpy(ctx->dma_buffer, data, writelen);\n \tpaddr\
    \ = dma_map_single(ctx->dev, ctx->dma_buffer, writelen,\n \t\t\t       DMA_TO_DEVICE);"
  identifiers:
  - CVE-2023-2194
  - CWE-787
  overview: An out-of-bounds write vulnerability was found in the Linux kernel's SLIMpro
    I2C device driver. The userspace "data->block[0]" variable was not capped to a
    number between 0-255 and was used as the size of a memcpy, possibly writing beyond
    the end of dma_buffer. This flaw could allow a local privileged user to crash
    the system or potentially achieve code execution.
  references:
  - source: secalert@redhat.com
    tags:
    - Issue Tracking
    - Patch
    - Third Party Advisory
    url: https://bugzilla.redhat.com/show_bug.cgi?id=2188396
  - source: secalert@redhat.com
    tags:
    - Patch
    url: https://github.com/torvalds/linux/commit/92fbb6d1296f
  - source: secalert@redhat.com
    url: https://lists.debian.org/debian-lts-announce/2023/05/msg00005.html
  - source: secalert@redhat.com
    url: https://lists.debian.org/debian-lts-announce/2023/05/msg00006.html
  title: An out-of-bounds write vulnerability was found in the Linux kernel's SLIMpro
    I2C device driver. The userspace "data->block[0]" variable was not capped to a
    number between 0-255 and was used as the size of a memcpy, possibly writing beyond
    the end of dma_buffer. This flaw could allow a local privileged user to crash
    the system or potentially achieve code execution.
- diff_content:
  - "--- a/arch/x86/kernel/cpu/bugs.c\n+++ b/arch/x86/kernel/cpu/bugs.c\n@@ -1133,14\
    \ +1133,18 @@ spectre_v2_parse_user_cmdline(void)\n \treturn SPECTRE_V2_USER_CMD_AUTO;\n\
    \ }\n \n-static inline bool spectre_v2_in_ibrs_mode(enum spectre_v2_mitigation\
    \ mode)\n+static inline bool spectre_v2_in_eibrs_mode(enum spectre_v2_mitigation\
    \ mode)\n {\n-\treturn mode == SPECTRE_V2_IBRS ||\n-\t       mode == SPECTRE_V2_EIBRS\
    \ ||\n+\treturn mode == SPECTRE_V2_EIBRS ||\n \t       mode == SPECTRE_V2_EIBRS_RETPOLINE\
    \ ||\n \t       mode == SPECTRE_V2_EIBRS_LFENCE;\n }\n \n+static inline bool spectre_v2_in_ibrs_mode(enum\
    \ spectre_v2_mitigation mode)\n+{\n+\treturn spectre_v2_in_eibrs_mode(mode) ||\
    \ mode == SPECTRE_V2_IBRS;\n+}\n+\n static void __init\n spectre_v2_user_select_mitigation(void)\n\
    \ {\n@@ -1203,12 +1207,19 @@ spectre_v2_user_select_mitigation(void)\n \t}\n \n\
    \ \t/*\n-\t * If no STIBP, IBRS or enhanced IBRS is enabled, or SMT impossible,\n\
    -\t * STIBP is not required.\n+\t * If no STIBP, enhanced IBRS is enabled, or\
    \ SMT impossible, STIBP\n+\t * is not required.\n+\t *\n+\t * Enhanced IBRS also\
    \ protects against cross-thread branch target\n+\t * injection in user-mode as\
    \ the IBRS bit remains always set which\n+\t * implicitly enables cross-thread\
    \ protections.  However, in legacy IBRS\n+\t * mode, the IBRS bit is set only\
    \ on kernel entry and cleared on return\n+\t * to userspace. This disables the\
    \ implicit cross-thread protection,\n+\t * so allow for STIBP to be selected in\
    \ that case.\n \t */\n \tif (!boot_cpu_has(X86_FEATURE_STIBP) ||\n \t    !smt_possible\
    \ ||\n-\t    spectre_v2_in_ibrs_mode(spectre_v2_enabled))\n+\t    spectre_v2_in_eibrs_mode(spectre_v2_enabled))\n\
    \ \t\treturn;\n \n \t/*\n@@ -2340,7 +2351,7 @@ static ssize_t mmio_stale_data_show_state(char\
    \ *buf)\n \n static char *stibp_state(void)\n {\n-\tif (spectre_v2_in_ibrs_mode(spectre_v2_enabled))\n\
    +\tif (spectre_v2_in_eibrs_mode(spectre_v2_enabled))\n \t\treturn \"\";\n \n \t\
    switch (spectre_v2_user_stibp) {"
  identifiers:
  - CVE-2023-1998
  - CWE-203
  overview: 'The Linux kernel allows userspace processes to enable mitigations by
    calling prctl with PR_SET_SPECULATION_CTRL which disables the speculation feature
    as well as by using seccomp. We had noticed that on VMs of at least one major
    cloud provider, the kernel still left the victim process exposed to attacks in
    some cases even after enabling the spectre-BTI mitigation with prctl. The same
    behavior can be observed on a bare-metal machine when forcing the mitigation to
    IBRS on boot command line.


    This happened because when plain IBRS was enabled (not enhanced IBRS), the kernel
    had some logic that determined that STIBP was not needed. The IBRS bit implicitly
    protects against cross-thread branch target injection. However, with legacy IBRS,
    the IBRS bit was cleared on returning to userspace, due to performance reasons,
    which disabled the implicit STIBP and left userspace threads vulnerable to cross-thread
    branch target injection against which STIBP protects.



    '
  references:
  - source: cve-coordination@google.com
    tags:
    - Exploit
    - Third Party Advisory
    url: https://github.com/google/security-research/security/advisories/GHSA-mj4w-6495-6crx
  - source: cve-coordination@google.com
    tags:
    - Patch
    url: https://github.com/torvalds/linux/commit/6921ed9049bc7457f66c1596c5b78aec0dae4a9d
  - source: cve-coordination@google.com
    tags:
    - Not Applicable
    url: https://kernel.dance/#6921ed9049bc7457f66c1596c5b78aec0dae4a9d
  - source: cve-coordination@google.com
    tags:
    - Mailing List
    - Third Party Advisory
    url: https://lists.debian.org/debian-lts-announce/2023/05/msg00005.html
  - source: cve-coordination@google.com
    tags:
    - Mailing List
    - Third Party Advisory
    url: https://lists.debian.org/debian-lts-announce/2023/05/msg00006.html
  title: 'The Linux kernel allows userspace processes to enable mitigations by calling
    prctl with PR_SET_SPECULATION_CTRL which disables the speculation feature as well
    as by using seccomp. We had noticed that on VMs of at least one major cloud provider,
    the kernel still left the victim process exposed to attacks in some cases even
    after enabling the spectre-BTI mitigation with prctl. The same behavior can be
    observed on a bare-metal machine when forcing the mitigation to IBRS on boot command
    line.


    This happened because when plain IBRS was enabled (not enhanced IBRS), the kernel
    had some logic that determined that STIBP was not needed. The IBRS bit implicitly
    protects against cross-thread branch target injection. However, with legacy IBRS,
    the IBRS bit was cleared on returning to userspace, due to performance reasons,
    which disabled the implicit STIBP and left userspace threads vulnerable to cross-thread
    branch target injection against which STIBP protects.



    '
- diff_content:
  - "--- a/src/podofo/main/PdfXRefStreamParserObject.cpp\n+++ b/src/podofo/main/PdfXRefStreamParserObject.cpp\n\
    @@ -67,15 +67,15 @@ void PdfXRefStreamParserObject::ReadXRefTable()\n     // all\
    \ of them have to be integers\n     const PdfArray* arr;\n     if (!arrObj.TryGetArray(arr)\
    \ || arr->size() != 3)\n-        PODOFO_RAISE_ERROR_INFO(PdfErrorCode::NoXRef,\
    \ \"Invalid XRef stream /W array\");\n+        PODOFO_RAISE_ERROR_INFO(PdfErrorCode::InvalidXRefStream,\
    \ \"Invalid XRef stream /W array\");\n \n     int64_t wArray[W_ARRAY_SIZE] = {\
    \ 0, 0, 0 };\n     int64_t num;\n     for (unsigned i = 0; i < W_ARRAY_SIZE; i++)\n\
    \     {\n \n         if (!(*arr)[i].TryGetNumber(num))\n-            PODOFO_RAISE_ERROR_INFO(PdfErrorCode::NoXRef,\
    \ \"Invalid XRef stream /W array\");\n+            PODOFO_RAISE_ERROR_INFO(PdfErrorCode::InvalidXRefStream,\
    \ \"Invalid XRef stream /W array\");\n \n         wArray[i] = num;\n     }\n@@\
    \ -92,12 +92,12 @@ void PdfXRefStreamParserObject::parseStream(const int64_t wArray[W_ARRAY_SIZE],\n\
    \     {\n         if (wArray[i] < 0)\n         {\n-            PODOFO_RAISE_ERROR_INFO(PdfErrorCode::NoXRef,\n\
    +            PODOFO_RAISE_ERROR_INFO(PdfErrorCode::InvalidXRefStream,\n      \
    \           \"Negative field length in XRef stream\");\n         }\n         if\
    \ (numeric_limits<int64_t>::max() - lengthSum < wArray[i])\n         {\n-    \
    \        PODOFO_RAISE_ERROR_INFO(PdfErrorCode::NoXRef,\n+            PODOFO_RAISE_ERROR_INFO(PdfErrorCode::InvalidXRefStream,\n\
    \                 \"Invalid entry length in XRef stream\");\n         }\n    \
    \     else\n@@ -112,24 +112,24 @@ void PdfXRefStreamParserObject::parseStream(const\
    \ int64_t wArray[W_ARRAY_SIZE],\n     this->GetOrCreateStream().CopyTo(buffer);\n\
    \ \n     vector<int64_t>::const_iterator it = indices.begin();\n-    char* cursor\
    \ = buffer.data();\n+    size_t offset = 0;\n     while (it != indices.end())\n\
    \     {\n         int64_t firstObj = *it++;\n         int64_t count = *it++;\n\
    \ \n+        if ((offset + count * entryLen) > buffer.size())\n+            PODOFO_RAISE_ERROR_INFO(PdfErrorCode::InvalidXRefStream,\
    \ \"Invalid count in XRef stream\");\n+\n         m_entries->Enlarge(firstObj\
    \ + count);\n         for (unsigned index = 0; index < (unsigned)count; index++)\n\
    \         {\n-            if ((size_t)(cursor - buffer.data()) >= buffer.size())\n\
    -                PODOFO_RAISE_ERROR_INFO(PdfErrorCode::NoXRef, \"Invalid count\
    \ in XRef stream\");\n-\n             unsigned objIndex = (unsigned)firstObj +\
    \ index;\n             auto& entry = (*m_entries)[objIndex];\n             if\
    \ (objIndex < m_entries->GetSize() && !entry.Parsed)\n-                readXRefStreamEntry(entry,\
    \ cursor, wArray);\n+                readXRefStreamEntry(entry, buffer.data()\
    \ + offset, wArray);\n \n-            cursor += entryLen;\n+            offset\
    \ += entryLen;\n         }\n     }\n }\n@@ -149,15 +149,15 @@ void PdfXRefStreamParserObject::getIndices(vector<int64_t>&\
    \ indices, int64_t siz\n     {\n         const PdfArray* arr;\n         if (!indexObj->TryGetArray(arr))\n\
    -            PODOFO_RAISE_ERROR_INFO(PdfErrorCode::NoXRef, \"Invalid XRef Stream\
    \ /Index\");\n+            PODOFO_RAISE_ERROR_INFO(PdfErrorCode::InvalidXRefStream,\
    \ \"Invalid XRef Stream /Index\");\n \n         for (auto index : *arr)\n    \
    \         indices.push_back(index.GetNumber());\n     }\n \n     // indices must\
    \ be a multiple of 2\n     if (indices.size() % 2 != 0)\n-        PODOFO_RAISE_ERROR_INFO(PdfErrorCode::NoXRef,\
    \ \"Invalid XRef Stream /Index\");\n+        PODOFO_RAISE_ERROR_INFO(PdfErrorCode::InvalidXRefStream,\
    \ \"Invalid XRef Stream /Index\");\n }\n \n void PdfXRefStreamParserObject::readXRefStreamEntry(PdfXRefEntry&\
    \ entry, char* buffer, const int64_t wArray[W_ARRAY_SIZE])"
  - "--- a/test/unit/ParserTest.cpp\n+++ b/test/unit/ParserTest.cpp\n@@ -1060,7 +1060,7\
    \ @@ void testReadXRefSubsection()\n     }\n }\n \n-TEST_CASE(\"testReadXRefStreamContents\"\
    )\n+TEST_CASE(\"TestReadXRefStreamContents\")\n {\n     // test valid stream\n\
    \     try\n@@ -1157,7 +1157,7 @@ TEST_CASE(\"testReadXRefStreamContents\")\n \
    \    }\n     catch (PdfError& error)\n     {\n-        REQUIRE(error.GetCode()\
    \ == PdfErrorCode::NoXRef);\n+        REQUIRE(error.GetCode() == PdfErrorCode::InvalidXRefStream);\n\
    \     }\n     catch (exception&)\n     {\n@@ -1210,7 +1210,7 @@ TEST_CASE(\"testReadXRefStreamContents\"\
    )\n     }\n     catch (PdfError& error)\n     {\n-        REQUIRE(error.GetCode()\
    \ == PdfErrorCode::NoXRef);\n+        REQUIRE(error.GetCode() == PdfErrorCode::InvalidXRefStream);\n\
    \     }\n     catch (exception&)\n     {\n@@ -1314,7 +1314,7 @@ TEST_CASE(\"testReadXRefStreamContents\"\
    )\n     }\n     catch (PdfError& error)\n     {\n-        REQUIRE(error.GetCode()\
    \ == PdfErrorCode::InvalidXRefType);\n+        REQUIRE(error.GetCode() == PdfErrorCode::InvalidXRefStream);\n\
    \     }\n     catch (exception&)\n     {\n@@ -1363,7 +1363,7 @@ TEST_CASE(\"testReadXRefStreamContents\"\
    )\n     }\n     catch (PdfError& error)\n     {\n-        REQUIRE(error.GetCode()\
    \ == PdfErrorCode::NoXRef);\n+        REQUIRE(error.GetCode() == PdfErrorCode::InvalidXRefStream);\n\
    \     }\n     catch (exception&)\n     {\n@@ -1722,7 +1722,7 @@ TEST_CASE(\"testReadXRefStreamContents\"\
    )\n     }\n     catch (PdfError& error)\n     {\n-        REQUIRE(error.GetCode()\
    \ == PdfErrorCode::NoXRef);\n+        REQUIRE(error.GetCode() == PdfErrorCode::InvalidXRefStream);\n\
    \     }\n     catch (exception&)\n     {\n@@ -1772,7 +1772,7 @@ TEST_CASE(\"testReadXRefStreamContents\"\
    )\n     }\n     catch (PdfError& error)\n     {\n-        REQUIRE(error.GetCode()\
    \ == PdfErrorCode::NoXRef);\n+        REQUIRE(error.GetCode() == PdfErrorCode::InvalidXRefStream);\n\
    \     }\n     catch (exception&)\n     {"
  identifiers:
  - CVE-2023-2241
  - CWE-787
  overview: A vulnerability, which was classified as critical, was found in PoDoFo
    0.10.0. Affected is the function readXRefStreamEntry of the file PdfXRefStreamParserObject.cpp.
    The manipulation leads to heap-based buffer overflow. An attack has to be approached
    locally. The exploit has been disclosed to the public and may be used. The patch
    is identified as 535a786f124b739e3c857529cecc29e4eeb79778. It is recommended to
    apply a patch to fix this issue. VDB-227226 is the identifier assigned to this
    vulnerability.
  references:
  - source: cna@vuldb.com
    tags:
    - Patch
    url: https://github.com/podofo/podofo/commit/535a786f124b739e3c857529cecc29e4eeb79778
  - source: cna@vuldb.com
    tags:
    - Exploit
    url: https://github.com/podofo/podofo/files/11260976/poc-file.zip
  - source: cna@vuldb.com
    tags:
    - Exploit
    - Issue Tracking
    - Third Party Advisory
    url: https://github.com/podofo/podofo/issues/69
  - source: cna@vuldb.com
    tags:
    - Third Party Advisory
    url: https://vuldb.com/?ctiid.227226
  - source: cna@vuldb.com
    tags:
    - Third Party Advisory
    url: https://vuldb.com/?id.227226
  title: A vulnerability, which was classified as critical, was found in PoDoFo 0.10.0.
    Affected is the function readXRefStreamEntry of the file PdfXRefStreamParserObject.cpp.
    The manipulation leads to heap-based buffer overflow. An attack has to be approached
    locally. The exploit has been disclosed to the public and may be used. The patch
    is identified as 535a786f124b739e3c857529cecc29e4eeb79778. It is recommended to
    apply a patch to fix this issue. VDB-227226 is the identifier assigned to this
    vulnerability.
- diff_content:
  - "--- a/net/rxrpc/conn_client.c\n+++ b/net/rxrpc/conn_client.c\n@@ -40,6 +40,8\
    \ @@ __read_mostly unsigned long rxrpc_conn_idle_client_fast_expiry = 2 * HZ;\n\
    \ DEFINE_IDR(rxrpc_client_conn_ids);\n static DEFINE_SPINLOCK(rxrpc_conn_id_lock);\n\
    \ \n+static void rxrpc_deactivate_bundle(struct rxrpc_bundle *bundle);\n+\n /*\n\
    \  * Get a connection ID and epoch for a client connection from the global pool.\n\
    \  * The connection struct pointer is then recorded in the idr radix tree.  The\n\
    @@ -123,6 +125,7 @@ static struct rxrpc_bundle *rxrpc_alloc_bundle(struct rxrpc_conn_parameters\
    \ *cp,\n \t\tbundle->params = *cp;\n \t\trxrpc_get_peer(bundle->params.peer);\n\
    \ \t\trefcount_set(&bundle->ref, 1);\n+\t\tatomic_set(&bundle->active, 1);\n \t\
    \tspin_lock_init(&bundle->channel_lock);\n \t\tINIT_LIST_HEAD(&bundle->waiting_calls);\n\
    \ \t}\n@@ -149,7 +152,7 @@ void rxrpc_put_bundle(struct rxrpc_bundle *bundle)\n\
    \ \n \tdead = __refcount_dec_and_test(&bundle->ref, &r);\n \n-\t_debug(\"PUT B=%x\
    \ %d\", d, r);\n+\t_debug(\"PUT B=%x %d\", d, r - 1);\n \tif (dead)\n \t\trxrpc_free_bundle(bundle);\n\
    \ }\n@@ -338,6 +341,7 @@ static struct rxrpc_bundle *rxrpc_look_up_bundle(struct\
    \ rxrpc_conn_parameters *c\n \trxrpc_free_bundle(candidate);\n found_bundle:\n\
    \ \trxrpc_get_bundle(bundle);\n+\tatomic_inc(&bundle->active);\n \tspin_unlock(&local->client_bundles_lock);\n\
    \ \t_leave(\" = %u [found]\", bundle->debug_id);\n \treturn bundle;\n@@ -435,6\
    \ +439,7 @@ static void rxrpc_add_conn_to_bundle(struct rxrpc_bundle *bundle,\
    \ gfp_t gfp)\n \t\t\tif (old)\n \t\t\t\ttrace_rxrpc_client(old, -1, rxrpc_client_replace);\n\
    \ \t\t\tcandidate->bundle_shift = shift;\n+\t\t\tatomic_inc(&bundle->active);\n\
    \ \t\t\tbundle->conns[i] = candidate;\n \t\t\tfor (j = 0; j < RXRPC_MAXCALLS;\
    \ j++)\n \t\t\t\tset_bit(shift + j, &bundle->avail_chans);\n@@ -725,6 +730,7 @@\
    \ int rxrpc_connect_call(struct rxrpc_sock *rx,\n \tsmp_rmb();\n \n out_put_bundle:\n\
    +\trxrpc_deactivate_bundle(bundle);\n \trxrpc_put_bundle(bundle);\n out:\n \t\
    _leave(\" = %d\", ret);\n@@ -900,9 +906,8 @@ void rxrpc_disconnect_client_call(struct\
    \ rxrpc_bundle *bundle, struct rxrpc_call\n static void rxrpc_unbundle_conn(struct\
    \ rxrpc_connection *conn)\n {\n \tstruct rxrpc_bundle *bundle = conn->bundle;\n\
    -\tstruct rxrpc_local *local = bundle->params.local;\n \tunsigned int bindex;\n\
    -\tbool need_drop = false, need_put = false;\n+\tbool need_drop = false;\n \t\
    int i;\n \n \t_enter(\"C=%x\", conn->debug_id);\n@@ -921,15 +926,22 @@ static\
    \ void rxrpc_unbundle_conn(struct rxrpc_connection *conn)\n \t}\n \tspin_unlock(&bundle->channel_lock);\n\
    \ \n-\t/* If there are no more connections, remove the bundle */\n-\tif (!bundle->avail_chans)\
    \ {\n-\t\t_debug(\"maybe unbundle\");\n-\t\tspin_lock(&local->client_bundles_lock);\n\
    +\tif (need_drop) {\n+\t\trxrpc_deactivate_bundle(bundle);\n+\t\trxrpc_put_connection(conn);\n\
    +\t}\n+}\n \n-\t\tfor (i = 0; i < ARRAY_SIZE(bundle->conns); i++)\n-\t\t\tif (bundle->conns[i])\n\
    -\t\t\t\tbreak;\n-\t\tif (i == ARRAY_SIZE(bundle->conns) && !bundle->params.exclusive)\
    \ {\n+/*\n+ * Drop the active count on a bundle.\n+ */\n+static void rxrpc_deactivate_bundle(struct\
    \ rxrpc_bundle *bundle)\n+{\n+\tstruct rxrpc_local *local = bundle->params.local;\n\
    +\tbool need_put = false;\n+\n+\tif (atomic_dec_and_lock(&bundle->active, &local->client_bundles_lock))\
    \ {\n+\t\tif (!bundle->params.exclusive) {\n \t\t\t_debug(\"erase bundle\");\n\
    \ \t\t\trb_erase(&bundle->local_node, &local->client_bundles);\n \t\t\tneed_put\
    \ = true;\n@@ -939,10 +951,6 @@ static void rxrpc_unbundle_conn(struct rxrpc_connection\
    \ *conn)\n \t\tif (need_put)\n \t\t\trxrpc_put_bundle(bundle);\n \t}\n-\n-\tif\
    \ (need_drop)\n-\t\trxrpc_put_connection(conn);\n-\t_leave(\"\");\n }\n \n /*"
  identifiers:
  - CVE-2023-2006
  - CWE-362
  overview: A race condition was found in the Linux kernel's RxRPC network protocol,
    within the processing of RxRPC bundles. This issue results from the lack of proper
    locking when performing operations on an object. This may allow an attacker to
    escalate privileges and execute arbitrary code in the context of the kernel.
  references:
  - source: secalert@redhat.com
    tags:
    - Issue Tracking
    - Patch
    - Third Party Advisory
    url: https://bugzilla.redhat.com/show_bug.cgi?id=2189112
  - source: secalert@redhat.com
    tags:
    - Patch
    url: https://github.com/torvalds/linux/commit/3bcd6c7eaa53
  - source: secalert@redhat.com
    tags:
    - Patch
    - Third Party Advisory
    url: https://security.netapp.com/advisory/ntap-20230609-0004/
  - source: secalert@redhat.com
    tags:
    - Third Party Advisory
    - VDB Entry
    url: https://www.zerodayinitiative.com/advisories/ZDI-23-439/
  title: A race condition was found in the Linux kernel's RxRPC network protocol,
    within the processing of RxRPC bundles. This issue results from the lack of proper
    locking when performing operations on an object. This may allow an attacker to
    escalate privileges and execute arbitrary code in the context of the kernel.
- diff_content:
  - "--- a/drivers/net/netdevsim/fib.c\n+++ b/drivers/net/netdevsim/fib.c\n@@ -54,6\
    \ +54,7 @@ struct nsim_fib_data {\n \tstruct rhashtable nexthop_ht;\n \tstruct\
    \ devlink *devlink;\n \tstruct work_struct fib_event_work;\n+\tstruct work_struct\
    \ fib_flush_work;\n \tstruct list_head fib_event_queue;\n \tspinlock_t fib_event_queue_lock;\
    \ /* Protects fib event queue list */\n \tstruct mutex nh_lock; /* Protects NH\
    \ HT */\n@@ -978,7 +979,7 @@ static int nsim_fib_event_schedule_work(struct nsim_fib_data\
    \ *data,\n \n \tfib_event = kzalloc(sizeof(*fib_event), GFP_ATOMIC);\n \tif (!fib_event)\n\
    -\t\treturn NOTIFY_BAD;\n+\t\tgoto err_fib_event_alloc;\n \n \tfib_event->data\
    \ = data;\n \tfib_event->event = event;\n@@ -1006,6 +1007,9 @@ static int nsim_fib_event_schedule_work(struct\
    \ nsim_fib_data *data,\n \n err_fib_prepare_event:\n \tkfree(fib_event);\n+err_fib_event_alloc:\n\
    +\tif (event == FIB_EVENT_ENTRY_DEL)\n+\t\tschedule_work(&data->fib_flush_work);\n\
    \ \treturn NOTIFY_BAD;\n }\n \n@@ -1483,6 +1487,24 @@ static void nsim_fib_event_work(struct\
    \ work_struct *work)\n \tmutex_unlock(&data->fib_lock);\n }\n \n+static void nsim_fib_flush_work(struct\
    \ work_struct *work)\n+{\n+\tstruct nsim_fib_data *data = container_of(work, struct\
    \ nsim_fib_data,\n+\t\t\t\t\t\t  fib_flush_work);\n+\tstruct nsim_fib_rt *fib_rt,\
    \ *fib_rt_tmp;\n+\n+\t/* Process pending work. */\n+\tflush_work(&data->fib_event_work);\n\
    +\n+\tmutex_lock(&data->fib_lock);\n+\tlist_for_each_entry_safe(fib_rt, fib_rt_tmp,\
    \ &data->fib_rt_list, list) {\n+\t\trhashtable_remove_fast(&data->fib_rt_ht, &fib_rt->ht_node,\n\
    +\t\t\t\t       nsim_fib_rt_ht_params);\n+\t\tnsim_fib_rt_free(fib_rt, data);\n\
    +\t}\n+\tmutex_unlock(&data->fib_lock);\n+}\n+\n static int\n nsim_fib_debugfs_init(struct\
    \ nsim_fib_data *data, struct nsim_dev *nsim_dev)\n {\n@@ -1541,6 +1563,7 @@ struct\
    \ nsim_fib_data *nsim_fib_create(struct devlink *devlink,\n \t\tgoto err_rhashtable_nexthop_destroy;\n\
    \ \n \tINIT_WORK(&data->fib_event_work, nsim_fib_event_work);\n+\tINIT_WORK(&data->fib_flush_work,\
    \ nsim_fib_flush_work);\n \tINIT_LIST_HEAD(&data->fib_event_queue);\n \tspin_lock_init(&data->fib_event_queue_lock);\n\
    \ \n@@ -1587,6 +1610,7 @@ struct nsim_fib_data *nsim_fib_create(struct devlink\
    \ *devlink,\n err_nexthop_nb_unregister:\n \tunregister_nexthop_notifier(devlink_net(devlink),\
    \ &data->nexthop_nb);\n err_rhashtable_fib_destroy:\n+\tcancel_work_sync(&data->fib_flush_work);\n\
    \ \tflush_work(&data->fib_event_work);\n \trhashtable_free_and_destroy(&data->fib_rt_ht,\
    \ nsim_fib_rt_free,\n \t\t\t\t    data);\n@@ -1616,6 +1640,7 @@ void nsim_fib_destroy(struct\
    \ devlink *devlink, struct nsim_fib_data *data)\n \t\t\t\t\t    NSIM_RESOURCE_IPV4_FIB);\n\
    \ \tunregister_fib_notifier(devlink_net(devlink), &data->fib_nb);\n \tunregister_nexthop_notifier(devlink_net(devlink),\
    \ &data->nexthop_nb);\n+\tcancel_work_sync(&data->fib_flush_work);\n \tflush_work(&data->fib_event_work);\n\
    \ \trhashtable_free_and_destroy(&data->fib_rt_ht, nsim_fib_rt_free,\n \t\t\t\t\
    \    data);"
  identifiers:
  - CVE-2023-2019
  - NVD-CWE-Other
  overview: A flaw was found in the Linux kernel's netdevsim device driver, within
    the scheduling of events. This issue results from the improper management of a
    reference count. This may allow an attacker to create a denial of service condition
    on the system.
  references:
  - source: secalert@redhat.com
    tags:
    - Issue Tracking
    - Patch
    - Third Party Advisory
    url: https://bugzilla.redhat.com/show_bug.cgi?id=2189137
  - source: secalert@redhat.com
    tags:
    - Patch
    url: https://github.com/torvalds/linux/commit/180a6a3ee60a
  - source: secalert@redhat.com
    tags:
    - Third Party Advisory
    - VDB Entry
    url: https://www.zerodayinitiative.com/advisories/ZDI-CAN-17811/
  title: A flaw was found in the Linux kernel's netdevsim device driver, within the
    scheduling of events. This issue results from the improper management of a reference
    count. This may allow an attacker to create a denial of service condition on the
    system.
- diff_content:
  - "--- a/apply.c\n+++ b/apply.c\n@@ -4558,7 +4558,7 @@ static int write_out_one_reject(struct\
    \ apply_state *state, struct patch *patch)\n \tFILE *rej;\n \tchar namebuf[PATH_MAX];\n\
    \ \tstruct fragment *frag;\n-\tint cnt = 0;\n+\tint fd, cnt = 0;\n \tstruct strbuf\
    \ sb = STRBUF_INIT;\n \n \tfor (cnt = 0, frag = patch->fragments; frag; frag =\
    \ frag->next) {\n@@ -4598,7 +4598,17 @@ static int write_out_one_reject(struct\
    \ apply_state *state, struct patch *patch)\n \tmemcpy(namebuf, patch->new_name,\
    \ cnt);\n \tmemcpy(namebuf + cnt, \".rej\", 5);\n \n-\trej = fopen(namebuf, \"\
    w\");\n+\tfd = open(namebuf, O_CREAT | O_EXCL | O_WRONLY, 0666);\n+\tif (fd <\
    \ 0) {\n+\t\tif (errno != EEXIST)\n+\t\t\treturn error_errno(_(\"cannot open %s\"\
    ), namebuf);\n+\t\tif (unlink(namebuf))\n+\t\t\treturn error_errno(_(\"cannot\
    \ unlink '%s'\"), namebuf);\n+\t\tfd = open(namebuf, O_CREAT | O_EXCL | O_WRONLY,\
    \ 0666);\n+\t\tif (fd < 0)\n+\t\t\treturn error_errno(_(\"cannot open %s\"), namebuf);\n\
    +\t}\n+\trej = fdopen(fd, \"w\");\n \tif (!rej)\n \t\treturn error_errno(_(\"\
    cannot open %s\"), namebuf);\n "
  identifiers:
  - CVE-2023-25652
  - CWE-22
  overview: Git is a revision control system. Prior to versions 2.30.9, 2.31.8, 2.32.7,
    2.33.8, 2.34.8, 2.35.8, 2.36.6, 2.37.7, 2.38.5, 2.39.3, and 2.40.1, by feeding
    specially crafted input to `git apply --reject`, a path outside the working tree
    can be overwritten with partially controlled contents (corresponding to the rejected
    hunk(s) from the given patch). A fix is available in versions 2.30.9, 2.31.8,
    2.32.7, 2.33.8, 2.34.8, 2.35.8, 2.36.6, 2.37.7, 2.38.5, 2.39.3, and 2.40.1. As
    a workaround, avoid using `git apply` with `--reject` when applying patches from
    an untrusted source. Use `git apply --stat` to inspect a patch before applying;
    avoid applying one that create a conflict where a link corresponding to the `*.rej`
    file exists.
  references:
  - source: security-advisories@github.com
    tags:
    - Mailing List
    - Third Party Advisory
    url: http://www.openwall.com/lists/oss-security/2023/04/25/2
  - source: security-advisories@github.com
    tags:
    - Patch
    url: https://github.com/git/git/commit/18e2b1cfc80990719275d7b08e6e50f3e8cbc902
  - source: security-advisories@github.com
    tags:
    - Patch
    url: https://github.com/git/git/commit/668f2d53613ac8fd373926ebe219f2c29112d93e
  - source: security-advisories@github.com
    tags:
    - Vendor Advisory
    url: https://github.com/git/git/security/advisories/GHSA-2hvf-7c8p-28fx
  - source: security-advisories@github.com
    url: https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/BSXOGVVBJLYX26IAYX6PJSYQB36BREWH/
  - source: security-advisories@github.com
    tags:
    - Mailing List
    - Third Party Advisory
    url: https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/PI7FZ4NNR5S5J5K6AMVQBH2JFP6NE4L7/
  - source: security-advisories@github.com
    url: https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/RKOXOAZ42HLXHXTW6JZI4L5DAIYDTYCU/
  - source: security-advisories@github.com
    tags:
    - Mailing List
    - Third Party Advisory
    url: https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/YFZWGQKB6MM5MNF2DLFTD7KS2KWPICKL/
  - source: security-advisories@github.com
    url: https://security.gentoo.org/glsa/202312-15
  title: Git is a revision control system. Prior to versions 2.30.9, 2.31.8, 2.32.7,
    2.33.8, 2.34.8, 2.35.8, 2.36.6, 2.37.7, 2.38.5, 2.39.3, and 2.40.1, by feeding
    specially crafted input to `git apply --reject`, a path outside the working tree
    can be overwritten with partially controlled contents (corresponding to the rejected
    hunk(s) from the given patch). A fix is available in versions 2.30.9, 2.31.8,
    2.32.7, 2.33.8, 2.34.8, 2.35.8, 2.36.6, 2.37.7, 2.38.5, 2.39.3, and 2.40.1. As
    a workaround, avoid using `git apply` with `--reject` when applying patches from
    an untrusted source. Use `git apply --stat` to inspect a patch before applying;
    avoid applying one that create a conflict where a link corresponding to the `*.rej`
    file exists.
- diff_content:
  - "--- a/config.c\n+++ b/config.c\n@@ -3027,9 +3027,10 @@ void git_config_set_multivar(const\
    \ char *key, const char *value,\n \t\t\t\t\tflags);\n }\n \n-static int section_name_match\
    \ (const char *buf, const char *name)\n+static size_t section_name_match (const\
    \ char *buf, const char *name)\n {\n-\tint i = 0, j = 0, dot = 0;\n+\tsize_t i\
    \ = 0, j = 0;\n+\tint dot = 0;\n \tif (buf[i] != '[')\n \t\treturn 0;\n \tfor\
    \ (i = 1; buf[i] && buf[i] != ']'; i++) {\n@@ -3082,6 +3083,8 @@ static int section_name_is_ok(const\
    \ char *name)\n \treturn 1;\n }\n \n+#define GIT_CONFIG_MAX_LINE_LEN (512 * 1024)\n\
    +\n /* if new_name == NULL, the section is removed instead */\n static int git_config_copy_or_rename_section_in_file(const\
    \ char *config_filename,\n \t\t\t\t      const char *old_name,\n@@ -3091,11 +3094,12\
    \ @@ static int git_config_copy_or_rename_section_in_file(const char *config_filename\n\
    \ \tchar *filename_buf = NULL;\n \tstruct lock_file lock = LOCK_INIT;\n \tint\
    \ out_fd;\n-\tchar buf[1024];\n+\tstruct strbuf buf = STRBUF_INIT;\n \tFILE *config_file\
    \ = NULL;\n \tstruct stat st;\n \tstruct strbuf copystr = STRBUF_INIT;\n \tstruct\
    \ config_store_data store;\n+\tuint32_t line_nr = 0;\n \n \tmemset(&store, 0,\
    \ sizeof(store));\n \n@@ -3132,16 +3136,25 @@ static int git_config_copy_or_rename_section_in_file(const\
    \ char *config_filename\n \t\tgoto out;\n \t}\n \n-\twhile (fgets(buf, sizeof(buf),\
    \ config_file)) {\n-\t\tunsigned i;\n-\t\tint length;\n+\twhile (!strbuf_getwholeline(&buf,\
    \ config_file, '\\n')) {\n+\t\tsize_t i, length;\n \t\tint is_section = 0;\n-\t\
    \tchar *output = buf;\n-\t\tfor (i = 0; buf[i] && isspace(buf[i]); i++)\n+\t\t\
    char *output = buf.buf;\n+\n+\t\tline_nr++;\n+\n+\t\tif (buf.len >= GIT_CONFIG_MAX_LINE_LEN)\
    \ {\n+\t\t\tret = error(_(\"refusing to work with overly long line \"\n+\t\t\t\
    \t      \"in '%s' on line %\"PRIuMAX),\n+\t\t\t\t    config_filename, (uintmax_t)line_nr);\n\
    +\t\t\tgoto out;\n+\t\t}\n+\n+\t\tfor (i = 0; buf.buf[i] && isspace(buf.buf[i]);\
    \ i++)\n \t\t\t; /* do nothing */\n-\t\tif (buf[i] == '[') {\n+\t\tif (buf.buf[i]\
    \ == '[') {\n \t\t\t/* it's a section */\n-\t\t\tint offset;\n+\t\t\tsize_t offset;\n\
    \ \t\t\tis_section = 1;\n \n \t\t\t/*\n@@ -3158,7 +3171,7 @@ static int git_config_copy_or_rename_section_in_file(const\
    \ char *config_filename\n \t\t\t\tstrbuf_reset(&copystr);\n \t\t\t}\n \n-\t\t\t\
    offset = section_name_match(&buf[i], old_name);\n+\t\t\toffset = section_name_match(&buf.buf[i],\
    \ old_name);\n \t\t\tif (offset > 0) {\n \t\t\t\tret++;\n \t\t\t\tif (new_name\
    \ == NULL) {\n@@ -3233,6 +3246,7 @@ static int git_config_copy_or_rename_section_in_file(const\
    \ char *config_filename\n out_no_rollback:\n \tfree(filename_buf);\n \tconfig_store_data_clear(&store);\n\
    +\tstrbuf_release(&buf);\n \treturn ret;\n }\n "
  identifiers:
  - CVE-2023-29007
  - CWE-74
  overview: Git is a revision control system. Prior to versions 2.30.9, 2.31.8, 2.32.7,
    2.33.8, 2.34.8, 2.35.8, 2.36.6, 2.37.7, 2.38.5, 2.39.3, and 2.40.1, a specially
    crafted `.gitmodules` file with submodule URLs that are longer than 1024 characters
    can used to exploit a bug in `config.c::git_config_copy_or_rename_section_in_file()`.
    This bug can be used to inject arbitrary configuration into a user's `$GIT_DIR/config`
    when attempting to remove the configuration section associated with that submodule.
    When the attacker injects configuration values which specify executables to run
    (such as `core.pager`, `core.editor`, `core.sshCommand`, etc.) this can lead to
    a remote code execution. A fix A fix is available in versions 2.30.9, 2.31.8,
    2.32.7, 2.33.8, 2.34.8, 2.35.8, 2.36.6, 2.37.7, 2.38.5, 2.39.3, and 2.40.1. As
    a workaround, avoid running `git submodule deinit` on untrusted repositories or
    without prior inspection of any submodule sections in `$GIT_DIR/config`.
  references:
  - source: security-advisories@github.com
    tags:
    - Vendor Advisory
    url: https://github.com/git/git/blob/9ce9dea4e1c2419cca126d29fa7730baa078a11b/Documentation/RelNotes/2.30.9.txt
  - source: security-advisories@github.com
    tags:
    - Patch
    url: https://github.com/git/git/commit/528290f8c61222433a8cf02fb7cfffa8438432b4
  - source: security-advisories@github.com
    tags:
    - Vendor Advisory
    url: https://github.com/git/git/security/advisories/GHSA-v48j-4xgg-4844
  - source: security-advisories@github.com
    tags:
    - Mailing List
    - Third Party Advisory
    url: https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/PI7FZ4NNR5S5J5K6AMVQBH2JFP6NE4L7/
  - source: security-advisories@github.com
    tags:
    - Mailing List
    - Third Party Advisory
    url: https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/RKOXOAZ42HLXHXTW6JZI4L5DAIYDTYCU/
  - source: security-advisories@github.com
    tags:
    - Mailing List
    - Third Party Advisory
    url: https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/YFZWGQKB6MM5MNF2DLFTD7KS2KWPICKL/
  - source: security-advisories@github.com
    tags:
    - Third Party Advisory
    url: https://security.gentoo.org/glsa/202312-15
  title: Git is a revision control system. Prior to versions 2.30.9, 2.31.8, 2.32.7,
    2.33.8, 2.34.8, 2.35.8, 2.36.6, 2.37.7, 2.38.5, 2.39.3, and 2.40.1, a specially
    crafted `.gitmodules` file with submodule URLs that are longer than 1024 characters
    can used to exploit a bug in `config.c::git_config_copy_or_rename_section_in_file()`.
    This bug can be used to inject arbitrary configuration into a user's `$GIT_DIR/config`
    when attempting to remove the configuration section associated with that submodule.
    When the attacker injects configuration values which specify executables to run
    (such as `core.pager`, `core.editor`, `core.sshCommand`, etc.) this can lead to
    a remote code execution. A fix A fix is available in versions 2.30.9, 2.31.8,
    2.32.7, 2.33.8, 2.34.8, 2.35.8, 2.36.6, 2.37.7, 2.38.5, 2.39.3, and 2.40.1. As
    a workaround, avoid running `git submodule deinit` on untrusted repositories or
    without prior inspection of any submodule sections in `$GIT_DIR/config`.
- diff_content:
  - "--- a/fs/ext4/inline.c\n+++ b/fs/ext4/inline.c\n@@ -34,6 +34,7 @@ static int\
    \ get_max_inline_xattr_value_size(struct inode *inode,\n \tstruct ext4_xattr_ibody_header\
    \ *header;\n \tstruct ext4_xattr_entry *entry;\n \tstruct ext4_inode *raw_inode;\n\
    +\tvoid *end;\n \tint free, min_offs;\n \n \tif (!EXT4_INODE_HAS_XATTR_SPACE(inode))\n\
    @@ -57,14 +58,23 @@ static int get_max_inline_xattr_value_size(struct inode *inode,\n\
    \ \traw_inode = ext4_raw_inode(iloc);\n \theader = IHDR(inode, raw_inode);\n \t\
    entry = IFIRST(header);\n+\tend = (void *)raw_inode + EXT4_SB(inode->i_sb)->s_inode_size;\n\
    \ \n \t/* Compute min_offs. */\n-\tfor (; !IS_LAST_ENTRY(entry); entry = EXT4_XATTR_NEXT(entry))\
    \ {\n+\twhile (!IS_LAST_ENTRY(entry)) {\n+\t\tvoid *next = EXT4_XATTR_NEXT(entry);\n\
    +\n+\t\tif (next >= end) {\n+\t\t\tEXT4_ERROR_INODE(inode,\n+\t\t\t\t\t \"corrupt\
    \ xattr in inline inode\");\n+\t\t\treturn 0;\n+\t\t}\n \t\tif (!entry->e_value_inum\
    \ && entry->e_value_size) {\n \t\t\tsize_t offs = le16_to_cpu(entry->e_value_offs);\n\
    \ \t\t\tif (offs < min_offs)\n \t\t\t\tmin_offs = offs;\n \t\t}\n+\t\tentry =\
    \ next;\n \t}\n \tfree = min_offs -\n \t\t((void *)entry - (void *)IFIRST(header))\
    \ - sizeof(__u32);"
  - "--- a/fs/ext4/super.c\n+++ b/fs/ext4/super.c\n@@ -3240,11 +3240,9 @@ static __le16\
    \ ext4_group_desc_csum(struct super_block *sb, __u32 block_group,\n \tcrc = crc16(crc,\
    \ (__u8 *)gdp, offset);\n \toffset += sizeof(gdp->bg_checksum); /* skip checksum\
    \ */\n \t/* for checksum of struct ext4_group_desc do the rest...*/\n-\tif (ext4_has_feature_64bit(sb)\
    \ &&\n-\t    offset < le16_to_cpu(sbi->s_es->s_desc_size))\n+\tif (ext4_has_feature_64bit(sb)\
    \ && offset < sbi->s_desc_size)\n \t\tcrc = crc16(crc, (__u8 *)gdp + offset,\n\
    -\t\t\t    le16_to_cpu(sbi->s_es->s_desc_size) -\n-\t\t\t\toffset);\n+\t\t\t \
    \   sbi->s_desc_size - offset);\n \n out:\n \treturn cpu_to_le16(crc);"
  identifiers:
  - CVE-2023-30549
  - CWE-416
  overview: 'Apptainer is an open source container platform for Linux. There is an
    ext4 use-after-free flaw that is exploitable through versions of Apptainer < 1.1.0
    and installations that include apptainer-suid < 1.1.8 on older operating systems
    where that CVE has not been patched. That includes Red Hat Enterprise Linux 7,
    Debian 10 buster (unless the linux-5.10 package is installed), Ubuntu 18.04 bionic
    and Ubuntu 20.04 focal. Use-after-free flaws in the kernel can be used to attack
    the kernel for denial of service and potentially for privilege escalation.


    Apptainer 1.1.8 includes a patch that by default disables mounting of extfs filesystem
    types in setuid-root mode, while continuing to allow mounting of extfs filesystems
    in non-setuid "rootless" mode using fuse2fs.


    Some workarounds are possible. Either do not install apptainer-suid (for versions
    1.1.0 through 1.1.7) or set `allow setuid = no` in apptainer.conf.  This requires
    having unprivileged user namespaces enabled and except for apptainer 1.1.x versions
    will disallow mounting of sif files, extfs files, and squashfs files in addition
    to other, less significant impacts.  (Encrypted sif files are also not supported
    unprivileged in apptainer 1.1.x.). Alternatively, use the `limit containers` options
    in apptainer.conf/singularity.conf to limit sif files to trusted users, groups,
    and/or paths, and set `allow container extfs = no` to disallow mounting of extfs
    overlay files.  The latter option by itself does not disallow mounting of extfs
    overlay partitions inside SIF files, so that''s why the former options are also
    needed.'
  references:
  - source: security-advisories@github.com
    tags:
    - Not Applicable
    url: https://access.redhat.com/security/cve/cve-2022-1184
  - source: security-advisories@github.com
    tags:
    - Patch
    url: https://github.com/apptainer/apptainer/commit/5a4964f5ba9c8d89a0e353b97f51fd607670a9f7
  - source: security-advisories@github.com
    tags:
    - Release Notes
    url: https://github.com/apptainer/apptainer/releases/tag/v1.1.8
  - source: security-advisories@github.com
    tags:
    - Mitigation
    - Vendor Advisory
    url: https://github.com/apptainer/apptainer/security/advisories/GHSA-j4rf-7357-f4cg
  - source: security-advisories@github.com
    url: https://github.com/torvalds/linux/commit/2220eaf90992c11d888fe771055d4de3303
  - source: security-advisories@github.com
    url: https://github.com/torvalds/linux/commit/4f04351888a83e595571de672e0a4a8b74f
  - source: security-advisories@github.com
    url: https://lwn.net/Articles/932136/
  - source: security-advisories@github.com
    url: https://lwn.net/Articles/932137/
  - source: security-advisories@github.com
    tags:
    - Not Applicable
    url: https://security-tracker.debian.org/tracker/CVE-2022-1184
  - source: security-advisories@github.com
    url: https://security.gentoo.org/glsa/202311-13
  - source: security-advisories@github.com
    url: https://sylabs.io/2023/04/response-to-cve-2023-30549/
  - source: security-advisories@github.com
    tags:
    - Not Applicable
    url: https://ubuntu.com/security/CVE-2022-1184
  - source: security-advisories@github.com
    tags:
    - Not Applicable
    url: https://www.suse.com/security/cve/CVE-2022-1184.html
  title: 'Apptainer is an open source container platform for Linux. There is an ext4
    use-after-free flaw that is exploitable through versions of Apptainer < 1.1.0
    and installations that include apptainer-suid < 1.1.8 on older operating systems
    where that CVE has not been patched. That includes Red Hat Enterprise Linux 7,
    Debian 10 buster (unless the linux-5.10 package is installed), Ubuntu 18.04 bionic
    and Ubuntu 20.04 focal. Use-after-free flaws in the kernel can be used to attack
    the kernel for denial of service and potentially for privilege escalation.


    Apptainer 1.1.8 includes a patch that by default disables mounting of extfs filesystem
    types in setuid-root mode, while continuing to allow mounting of extfs filesystems
    in non-setuid "rootless" mode using fuse2fs.


    Some workarounds are possible. Either do not install apptainer-suid (for versions
    1.1.0 through 1.1.7) or set `allow setuid = no` in apptainer.conf.  This requires
    having unprivileged user namespaces enabled and except for apptainer 1.1.x versions
    will disallow mounting of sif files, extfs files, and squashfs files in addition
    to other, less significant impacts.  (Encrypted sif files are also not supported
    unprivileged in apptainer 1.1.x.). Alternatively, use the `limit containers` options
    in apptainer.conf/singularity.conf to limit sif files to trusted users, groups,
    and/or paths, and set `allow container extfs = no` to disallow mounting of extfs
    overlay files.  The latter option by itself does not disallow mounting of extfs
    overlay partitions inside SIF files, so that''s why the former options are also
    needed.'
- diff_content:
  - "--- a/kernel/sys.c\n+++ b/kernel/sys.c\n@@ -1442,6 +1442,8 @@ static int do_prlimit(struct\
    \ task_struct *tsk, unsigned int resource,\n \n \tif (resource >= RLIM_NLIMITS)\n\
    \ \t\treturn -EINVAL;\n+\tresource = array_index_nospec(resource, RLIM_NLIMITS);\n\
    +\n \tif (new_rlim) {\n \t\tif (new_rlim->rlim_cur > new_rlim->rlim_max)\n \t\t\
    \treturn -EINVAL;"
  identifiers:
  - CVE-2023-0458
  - CWE-476
  overview: "A speculative pointer dereference problem exists in the Linux Kernel\
    \ on the do_prlimit() function. The resource argument value is controlled and\
    \ is used in pointer arithmetic for the 'rlim' variable and can be used to leak\
    \ the contents. We recommend upgrading past version 6.1.8 or commit\_739790605705ddcf18f21782b9c99ad7d53a8c11"
  references:
  - source: cve-coordination@google.com
    tags:
    - Patch
    url: https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/diff/kernel/sys.c?id=v6.1.8&id2=v6.1.7
  - source: cve-coordination@google.com
    tags:
    - Patch
    url: https://github.com/torvalds/linux/commit/739790605705ddcf18f21782b9c99ad7d53a8c11
  - source: cve-coordination@google.com
    tags:
    - Mailing List
    - Third Party Advisory
    url: https://lists.debian.org/debian-lts-announce/2023/05/msg00005.html
  - source: cve-coordination@google.com
    tags:
    - Mailing List
    - Third Party Advisory
    url: https://lists.debian.org/debian-lts-announce/2023/05/msg00006.html
  title: "A speculative pointer dereference problem exists in the Linux Kernel on\
    \ the do_prlimit() function. The resource argument value is controlled and is\
    \ used in pointer arithmetic for the 'rlim' variable and can be used to leak the\
    \ contents. We recommend upgrading past version 6.1.8 or commit\_739790605705ddcf18f21782b9c99ad7d53a8c11"
- diff_content:
  - "--- a/lib/core/proxy.c\n+++ b/lib/core/proxy.c\n@@ -165,7 +165,8 @@ static void\
    \ build_request(h2o_req_t *req, h2o_iovec_t *method, h2o_url_t *url, h\n     *method\
    \ = h2o_strdup(&req->pool, req->method.base, req->method.len);\n \n     /* url\
    \ */\n-    h2o_url_init(url, origin->scheme, req->authority, h2o_strdup(&req->pool,\
    \ req->path.base, req->path.len));\n+    if (h2o_url_init(url, origin->scheme,\
    \ req->authority, h2o_strdup(&req->pool, req->path.base, req->path.len)) != 0)\n\
    +        h2o_fatal(\"h2o_url_init failed\");\n \n     if (props->connection_header\
    \ != NULL) {\n         if (upgrade_to != NULL && upgrade_to != h2o_httpclient_upgrade_to_connect)\
    \ {\n@@ -861,8 +862,10 @@ void h2o__proxy_process_request(h2o_req_t *req)\n  \
    \       if (!overrides->proxy_preserve_host)\n             target = NULL;\n  \
    \   }\n-    if (target == &target_buf)\n-        h2o_url_init(&target_buf, req->scheme,\
    \ req->authority, h2o_iovec_init(H2O_STRLIT(\"/\")));\n+    if (target == &target_buf\
    \ && h2o_url_init(&target_buf, req->scheme, req->authority, h2o_iovec_init(H2O_STRLIT(\"\
    /\"))) != 0) {\n+        h2o_send_error_400(req, \"Invalid Request\", \"Invalid\
    \ Request\", H2O_SEND_ERROR_HTTP1_CLOSE_CONNECTION);\n+        return;\n+    }\n\
    \ \n     const char *upgrade_to = NULL;\n     if (req->is_tunnel_req) {"
  identifiers:
  - CVE-2023-30847
  - CWE-824
  overview: H2O is an HTTP server. In versions 2.3.0-beta2 and prior, when the reverse
    proxy handler tries to processes a certain type of invalid HTTP request, it tries
    to build an upstream URL by reading from uninitialized pointer. This behavior
    can lead to crashes or leak of information to back end HTTP servers. Pull request  number
    3229 fixes the issue. The pull request has been merged to the `master` branch
    in commit f010336. Users should upgrade to commit f010336 or later.
  references:
  - source: security-advisories@github.com
    tags:
    - Patch
    url: https://github.com/h2o/h2o/commit/f010336bab162839df43d9e87570897466c97e33
  - source: security-advisories@github.com
    tags:
    - Vendor Advisory
    url: https://github.com/h2o/h2o/pull/3229
  - source: security-advisories@github.com
    tags:
    - Patch
    - Vendor Advisory
    url: https://github.com/h2o/h2o/security/advisories/GHSA-p5hj-phwj-hrvx
  title: H2O is an HTTP server. In versions 2.3.0-beta2 and prior, when the reverse
    proxy handler tries to processes a certain type of invalid HTTP request, it tries
    to build an upstream URL by reading from uninitialized pointer. This behavior
    can lead to crashes or leak of information to back end HTTP servers. Pull request  number
    3229 fixes the issue. The pull request has been merged to the `master` branch
    in commit f010336. Users should upgrade to commit f010336 or later.
- diff_content:
  - "--- a/net/sched/sch_qfq.c\n+++ b/net/sched/sch_qfq.c\n@@ -421,15 +421,16 @@ static\
    \ int qfq_change_class(struct Qdisc *sch, u32 classid, u32 parentid,\n \t} else\n\
    \ \t\tweight = 1;\n \n-\tif (tb[TCA_QFQ_LMAX]) {\n+\tif (tb[TCA_QFQ_LMAX])\n \t\
    \tlmax = nla_get_u32(tb[TCA_QFQ_LMAX]);\n-\t\tif (lmax < QFQ_MIN_LMAX || lmax\
    \ > (1UL << QFQ_MTU_SHIFT)) {\n-\t\t\tpr_notice(\"qfq: invalid max length %u\\\
    n\", lmax);\n-\t\t\treturn -EINVAL;\n-\t\t}\n-\t} else\n+\telse\n \t\tlmax = psched_mtu(qdisc_dev(sch));\n\
    \ \n+\tif (lmax < QFQ_MIN_LMAX || lmax > (1UL << QFQ_MTU_SHIFT)) {\n+\t\tpr_notice(\"\
    qfq: invalid max length %u\\n\", lmax);\n+\t\treturn -EINVAL;\n+\t}\n+\n \tinv_w\
    \ = ONE_FP / weight;\n \tweight = ONE_FP / inv_w;\n "
  identifiers:
  - CVE-2023-31436
  - CWE-787
  overview: qfq_change_class in net/sched/sch_qfq.c in the Linux kernel before 6.2.13
    allows an out-of-bounds write because lmax can exceed QFQ_MIN_LMAX.
  references:
  - source: cve@mitre.org
    tags:
    - Third Party Advisory
    - VDB Entry
    url: http://packetstormsecurity.com/files/173087/Kernel-Live-Patch-Security-Notice-LSN-0095-1.html
  - source: cve@mitre.org
    tags:
    - Third Party Advisory
    - VDB Entry
    url: http://packetstormsecurity.com/files/173757/Kernel-Live-Patch-Security-Notice-LSN-0096-1.html
  - source: cve@mitre.org
    url: http://packetstormsecurity.com/files/175963/Kernel-Live-Patch-Security-Notice-LSN-0099-1.html
  - source: cve@mitre.org
    tags:
    - Mailing List
    - Patch
    url: https://cdn.kernel.org/pub/linux/kernel/v6.x/ChangeLog-6.2.13
  - source: cve@mitre.org
    tags:
    - Patch
    url: https://github.com/torvalds/linux/commit/3037933448f60f9acb705997eae62013ecb81e0d
  - source: cve@mitre.org
    tags:
    - Mailing List
    - Third Party Advisory
    url: https://lists.debian.org/debian-lts-announce/2023/06/msg00008.html
  - source: cve@mitre.org
    tags:
    - Third Party Advisory
    url: https://security.netapp.com/advisory/ntap-20230609-0001/
  - source: cve@mitre.org
    tags:
    - VDB Entry
    url: https://www.debian.org/security/2023/dsa-5402
  - source: cve@mitre.org
    tags:
    - Mailing List
    - Patch
    url: https://www.spinics.net/lists/stable-commits/msg294885.html
  title: qfq_change_class in net/sched/sch_qfq.c in the Linux kernel before 6.2.13
    allows an out-of-bounds write because lmax can exceed QFQ_MIN_LMAX.
- diff_content:
  - "--- a/src/dns.c\n+++ b/src/dns.c\n@@ -274,6 +274,10 @@ static int _dns_encode_domain(struct\
    \ dns_context *context, const char *domain)\n \t\ttotal_len++;\n \t\tif (dict_offset\
    \ >= 0) {\n \t\t\tint offset = 0xc000 | dict_offset;\n+\t\t\tif (_dns_left_len(context)\
    \ < 2) {\n+\t\t\t\treturn -1;\n+\t\t\t}\n+\n \t\t\t_dns_write_short(&ptr_num,\
    \ offset);\n \t\t\tcontext->ptr++;\n \t\t\tptr_num = NULL;\n@@ -295,6 +299,10\
    \ @@ static int _dns_encode_domain(struct dns_context *context, const char *domain)\n\
    \ \t\tdomain++;\n \t}\n \n+\tif (_dns_left_len(context) < 1) {\n+\t\treturn -1;\n\
    +\t}\n+\n \t*ptr_num = num;\n \n \tif (total_len > 1) {\n@@ -575,7 +583,7 @@ struct\
    \ dns_rr_nested *dns_add_rr_nested_start(struct dns_rr_nested *rr_nested_bu\n\
    \ \treturn rr_nested_buffer;\n }\n \n-int dns_add_rr_nested_memcpy(struct dns_rr_nested\
    \ *rr_nested, void *data, int data_len)\n+int dns_add_rr_nested_memcpy(struct\
    \ dns_rr_nested *rr_nested, const void *data, int data_len)\n {\n \tif (rr_nested\
    \ == NULL || data == NULL || data_len <= 0) {\n \t\treturn -1;\n@@ -603,6 +611,12\
    \ @@ int dns_add_rr_nested_end(struct dns_rr_nested *rr_nested, dns_type_t rtype)\n\
    \ \t\treturn -1;\n \t}\n \n+\t/* NO SVC keys, reset ptr */\n+\tif (len <= 14)\
    \ {\n+\t\trr_nested->context.ptr = rr_nested->rr_start;\n+\t\treturn 0;\n+\t}\n\
    +\n \t_dns_write_short(&ptr, len - rr_nested->rr_head_len);\n \n \treturn _dns_rr_add_end(rr_nested->context.packet,\
    \ rr_nested->type, rtype, len);\n@@ -1076,7 +1090,12 @@ int dns_add_HTTPS_start(struct\
    \ dns_rr_nested *svcparam_buffer, struct dns_packet\n \t\treturn -1;\n \t}\n \n\
    -\tint target_len = strnlen(target, DNS_MAX_CNAME_LEN) + 1;\n+\tint target_len\
    \ = 0;\n+\tif (target == NULL) {\n+\t\ttarget = \"\";\n+\t}\n+\n+\ttarget_len\
    \ = strnlen(target, DNS_MAX_CNAME_LEN) + 1;\n \tif (_dns_left_len(&svcparam_buffer->context)\
    \ < 2 + target_len) {\n \t\treturn -1;\n \t}\n@@ -1117,6 +1136,22 @@ int dns_HTTPS_add_port(struct\
    \ dns_rr_nested *svcparam, unsigned short port)\n \treturn 0;\n }\n \n+int dns_HTTPS_add_alpn(struct\
    \ dns_rr_nested *svcparam, const char *alpn, int alpn_len)\n+{\n+\tif (_dns_left_len(&svcparam->context)\
    \ < 2 + 2 + alpn_len) {\n+\t\treturn -1;\n+\t}\n+\n+\tunsigned short value = DNS_HTTPS_T_ALPN;\n\
    +\tdns_add_rr_nested_memcpy(svcparam, &value, 2);\n+\n+\tvalue = alpn_len;\n+\t\
    dns_add_rr_nested_memcpy(svcparam, &value, 2);\n+\tdns_add_rr_nested_memcpy(svcparam,\
    \ alpn, alpn_len);\n+\n+\treturn 0;\n+}\n+\n int dns_HTTPS_add_ech(struct dns_rr_nested\
    \ *svcparam, void *ech, int ech_len)\n {\n \tif (_dns_left_len(&svcparam->context)\
    \ < 2 + 2 + ech_len) {\n@@ -1133,7 +1168,7 @@ int dns_HTTPS_add_ech(struct dns_rr_nested\
    \ *svcparam, void *ech, int ech_len)\n \treturn 0;\n }\n \n-int dns_HTTPS_add_ipv4hint(struct\
    \ dns_rr_nested *svcparam, unsigned char addr[][DNS_RR_A_LEN], int addr_num)\n\
    +int dns_HTTPS_add_ipv4hint(struct dns_rr_nested *svcparam, unsigned char *addr[],\
    \ int addr_num)\n {\n \tif (_dns_left_len(&svcparam->context) < 4 + addr_num *\
    \ DNS_RR_A_LEN) {\n \t\treturn -1;\n@@ -1151,7 +1186,8 @@ int dns_HTTPS_add_ipv4hint(struct\
    \ dns_rr_nested *svcparam, unsigned char addr[][\n \n \treturn 0;\n }\n-int dns_HTTPS_add_ipv6hint(struct\
    \ dns_rr_nested *svcparam, unsigned char addr[][DNS_RR_AAAA_LEN], int addr_num)\n\
    +\n+int dns_HTTPS_add_ipv6hint(struct dns_rr_nested *svcparam, unsigned char *addr[],\
    \ int addr_num)\n {\n \tif (_dns_left_len(&svcparam->context) < 4 + addr_num *\
    \ DNS_RR_AAAA_LEN) {\n \t\treturn -1;\n@@ -1175,41 +1211,48 @@ int dns_add_HTTPS_end(struct\
    \ dns_rr_nested *svcparam)\n \treturn dns_add_rr_nested_end(svcparam, DNS_T_HTTPS);\n\
    \ }\n \n-struct dns_https_param *dns_get_HTTPS_svcparm_start(struct dns_rrs *rrs,\
    \ char *domain, int maxsize, int *ttl,\n-\t\t\t\t\t\t\t\t\t\t\t\t\tint *priority,\
    \ char *target, int target_size)\n+int dns_get_HTTPS_svcparm_start(struct dns_rrs\
    \ *rrs, struct dns_https_param **https_param, char *domain, int maxsize,\n+\t\t\
    \t\t\t\t\t\tint *ttl, int *priority, char *target, int target_size)\n {\n \tint\
    \ qtype = 0;\n \tunsigned char *data = NULL;\n \tint rr_len = 0;\n \n \tdata =\
    \ dns_get_rr_nested_start(rrs, domain, maxsize, &qtype, ttl, &rr_len);\n \tif\
    \ (data == NULL) {\n-\t\treturn NULL;\n+\t\treturn -1;\n \t}\n \n \tif (qtype\
    \ != DNS_T_HTTPS) {\n-\t\treturn NULL;\n+\t\treturn -1;\n \t}\n \n \tif (rr_len\
    \ < 2) {\n-\t\treturn NULL;\n+\t\treturn -1;\n \t}\n \n \t*priority = _dns_read_short(&data);\n\
    \ \trr_len -= 2;\n \tif (rr_len <= 0) {\n-\t\treturn NULL;\n+\t\treturn -1;\n\
    \ \t}\n \n \tint len = strnlen((char *)data, rr_len);\n \tsafe_strncpy(target,\
    \ (char *)data, target_size);\n \tdata += len + 1;\n \trr_len -= len + 1;\n-\t\
    if (rr_len <= 0) {\n-\t\treturn NULL;\n+\tif (rr_len < 0) {\n+\t\treturn -1;\n\
    +\t}\n+\n+\tif (rr_len == 0) {\n+\t\t*https_param = NULL;\n+\t\treturn 0;\n \t\
    }\n \n-\treturn (struct dns_https_param *)data;\n+\t*https_param = (struct dns_https_param\
    \ *)data;\n+\n+\treturn 0;\n }\n \n struct dns_https_param *dns_get_HTTPS_svcparm_next(struct\
    \ dns_rrs *rrs, struct dns_https_param *param)\n@@ -1925,12 +1968,16 @@ static\
    \ int _dns_encode_HTTPS(struct dns_context *context, struct dns_rrs *rrs)\n \t\
    int priority = 0;\n \tstruct dns_https_param *param = NULL;\n \n-\tparam = dns_get_HTTPS_svcparm_start(rrs,\
    \ domain, DNS_MAX_CNAME_LEN, &ttl, &priority, target, DNS_MAX_CNAME_LEN);\n-\t\
    if (param == NULL) {\n-\t\ttlog(TLOG_ERROR, \"get https param failed.\");\n-\t\
    \treturn -1;\n+\tret =\n+\t\tdns_get_HTTPS_svcparm_start(rrs, &param, domain,\
    \ DNS_MAX_CNAME_LEN, &ttl, &priority, target, DNS_MAX_CNAME_LEN);\n+\tif (ret\
    \ < 0) {\n+\t\ttlog(TLOG_DEBUG, \"get https param failed.\");\n+\t\treturn 0;\n\
    \ \t}\n \n+\tqtype = DNS_T_HTTPS;\n+\tqclass = DNS_C_IN;\n+\n \tret = _dns_encode_rr_head(context,\
    \ domain, qtype, qclass, ttl, 0, &rr_len_ptr);\n \tif (ret < 0) {\n \t\treturn\
    \ -1;\n@@ -1954,6 +2001,10 @@ static int _dns_encode_HTTPS(struct dns_context\
    \ *context, struct dns_rrs *rrs)\n \t\t\treturn -1;\n \t\t}\n \n+\t\tif (param->len\
    \ + 4 > _dns_left_len(context)) {\n+\t\t\treturn -1;\n+\t\t}\n+\n \t\t_dns_write_short(&context->ptr,\
    \ param->key);\n \t\t_dns_write_short(&context->ptr, param->len);\n \t\tswitch\
    \ (param->key) {\n@@ -1974,6 +2025,10 @@ static int _dns_encode_HTTPS(struct dns_context\
    \ *context, struct dns_rrs *rrs)\n \t\t}\n \t}\n \n+\tif (_dns_left_len(context)\
    \ < 2) {\n+\t\treturn -1;\n+\t}\n+\n \t_dns_write_short(&rr_len_ptr, context->ptr\
    \ - rr_start);\n \n \treturn 0;"
  - "--- a/src/util.c\n+++ b/src/util.c\n@@ -1601,10 +1601,11 @@ static int _dns_debug_display(struct\
    \ dns_packet *packet)\n \t\t\t\tchar target[DNS_MAX_CNAME_LEN] = {0};\n \t\t\t\
    \tstruct dns_https_param *p = NULL;\n \t\t\t\tint priority = 0;\n+\t\t\t\tint\
    \ ret = 0;\n \n-\t\t\t\tp = dns_get_HTTPS_svcparm_start(rrs, name, DNS_MAX_CNAME_LEN,\
    \ &ttl, &priority, target,\n+\t\t\t\tret = dns_get_HTTPS_svcparm_start(rrs, &p,\
    \ name, DNS_MAX_CNAME_LEN, &ttl, &priority, target,\n \t\t\t\t\t\t\t\t\t\t\t\t\
    DNS_MAX_CNAME_LEN);\n-\t\t\t\tif (p == NULL) {\n+\t\t\t\tif (ret != 0) {\n \t\t\
    \t\t\tprintf(\"get HTTPS svcparm failed\\n\");\n \t\t\t\t\tbreak;\n \t\t\t\t}\n\
    @@ -1617,7 +1618,23 @@ static int _dns_debug_display(struct dns_packet *packet)\n\
    \ \t\t\t\t\t\tprintf(\"  HTTPS: mandatory: %s\\n\", p->value);\n \t\t\t\t\t} break;\n\
    \ \t\t\t\t\tcase DNS_HTTPS_T_ALPN: {\n-\t\t\t\t\t\tprintf(\"  HTTPS: alpn: %s\\\
    n\", p->value);\n+\t\t\t\t\t\tchar alph[64] = {0};\n+\t\t\t\t\t\tint total_alph_len\
    \ = 0;\n+\t\t\t\t\t\tchar *ptr = (char *)p->value;\n+\t\t\t\t\t\tdo {\n+\t\t\t\
    \t\t\t\tint alphlen = *ptr;\n+\t\t\t\t\t\t\tmemcpy(alph + total_alph_len, ptr\
    \ + 1, alphlen);\n+\t\t\t\t\t\t\ttotal_alph_len += alphlen;\n+\t\t\t\t\t\t\tptr\
    \ += alphlen + 1;\n+\t\t\t\t\t\t\talph[total_alph_len] = ',';\n+\t\t\t\t\t\t\t\
    total_alph_len++;\n+\t\t\t\t\t\t\talph[total_alph_len] = ' ';\n+\t\t\t\t\t\t\t\
    total_alph_len++;\n+\t\t\t\t\t\t} while (ptr - (char *)p->value < p->len);\n+\t\
    \t\t\t\t\tif (total_alph_len > 2) {\n+\t\t\t\t\t\t\talph[total_alph_len - 2] =\
    \ '\\0';\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\tprintf(\"  HTTPS: alpn: %s\\n\", alph);\n\
    \ \t\t\t\t\t} break;\n \t\t\t\t\tcase DNS_HTTPS_T_NO_DEFAULT_ALPN: {\n \t\t\t\t\
    \t\tprintf(\"  HTTPS: no_default_alpn: %s\\n\", p->value);"
  identifiers:
  - CVE-2023-31470
  - CWE-787
  overview: SmartDNS through 41 before 56d0332 allows an out-of-bounds write because
    of a stack-based buffer overflow in the _dns_encode_domain function in the dns.c
    file, via a crafted DNS request.
  references:
  - source: cve@mitre.org
    tags:
    - Patch
    url: https://github.com/pymumu/smartdns/commit/56d0332bf91104cfc877635f6c82e9348587df04
  - source: cve@mitre.org
    tags:
    - Exploit
    url: https://github.com/pymumu/smartdns/issues/1378
  title: SmartDNS through 41 before 56d0332 allows an out-of-bounds write because
    of a stack-based buffer overflow in the _dns_encode_domain function in the dns.c
    file, via a crafted DNS request.
- diff_content:
  - "--- a/net/netrom/af_netrom.c\n+++ b/net/netrom/af_netrom.c\n@@ -400,6 +400,11\
    \ @@ static int nr_listen(struct socket *sock, int backlog)\n \tstruct sock *sk\
    \ = sock->sk;\n \n \tlock_sock(sk);\n+\tif (sock->state != SS_UNCONNECTED) {\n\
    +\t\trelease_sock(sk);\n+\t\treturn -EINVAL;\n+\t}\n+\n \tif (sk->sk_state !=\
    \ TCP_LISTEN) {\n \t\tmemset(&nr_sk(sk)->user_addr, 0, AX25_ADDR_LEN);\n \t\t\
    sk->sk_max_ack_backlog = backlog;"
  identifiers:
  - CVE-2023-32269
  - CWE-416
  overview: An issue was discovered in the Linux kernel before 6.1.11. In net/netrom/af_netrom.c,
    there is a use-after-free because accept is also allowed for a successfully connected
    AF_NETROM socket. However, in order for an attacker to exploit this, the system
    must have netrom routing configured or the attacker must have the CAP_NET_ADMIN
    capability.
  references:
  - source: cve@mitre.org
    tags:
    - Release Notes
    url: https://cdn.kernel.org/pub/linux/kernel/v6.x/ChangeLog-6.1.11
  - source: cve@mitre.org
    tags:
    - Patch
    url: https://github.com/torvalds/linux/commit/611792920925fb088ddccbe2783c7f92fdfb6b64
  title: An issue was discovered in the Linux kernel before 6.1.11. In net/netrom/af_netrom.c,
    there is a use-after-free because accept is also allowed for a successfully connected
    AF_NETROM socket. However, in order for an attacker to exploit this, the system
    must have netrom routing configured or the attacker must have the CAP_NET_ADMIN
    capability.
- diff_content:
  - "--- a/net/netfilter/nf_tables_api.c\n+++ b/net/netfilter/nf_tables_api.c\n@@\
    \ -5127,12 +5127,24 @@ static void nf_tables_unbind_set(const struct nft_ctx *ctx,\
    \ struct nft_set *set,\n \t}\n }\n \n+void nf_tables_activate_set(const struct\
    \ nft_ctx *ctx, struct nft_set *set)\n+{\n+\tif (nft_set_is_anonymous(set))\n\
    +\t\tnft_clear(ctx->net, set);\n+\n+\tset->use++;\n+}\n+EXPORT_SYMBOL_GPL(nf_tables_activate_set);\n\
    +\n void nf_tables_deactivate_set(const struct nft_ctx *ctx, struct nft_set *set,\n\
    \ \t\t\t      struct nft_set_binding *binding,\n \t\t\t      enum nft_trans_phase\
    \ phase)\n {\n \tswitch (phase) {\n \tcase NFT_TRANS_PREPARE:\n+\t\tif (nft_set_is_anonymous(set))\n\
    +\t\t\tnft_deactivate_next(ctx->net, set);\n+\n \t\tset->use--;\n \t\treturn;\n\
    \ \tcase NFT_TRANS_ABORT:"
  - "--- a/net/netfilter/nft_dynset.c\n+++ b/net/netfilter/nft_dynset.c\n@@ -342,7\
    \ +342,7 @@ static void nft_dynset_activate(const struct nft_ctx *ctx,\n {\n \t\
    struct nft_dynset *priv = nft_expr_priv(expr);\n \n-\tpriv->set->use++;\n+\tnf_tables_activate_set(ctx,\
    \ priv->set);\n }\n \n static void nft_dynset_destroy(const struct nft_ctx *ctx,"
  - "--- a/net/netfilter/nft_lookup.c\n+++ b/net/netfilter/nft_lookup.c\n@@ -167,7\
    \ +167,7 @@ static void nft_lookup_activate(const struct nft_ctx *ctx,\n {\n \t\
    struct nft_lookup *priv = nft_expr_priv(expr);\n \n-\tpriv->set->use++;\n+\tnf_tables_activate_set(ctx,\
    \ priv->set);\n }\n \n static void nft_lookup_destroy(const struct nft_ctx *ctx,"
  - "--- a/net/netfilter/nft_objref.c\n+++ b/net/netfilter/nft_objref.c\n@@ -185,7\
    \ +185,7 @@ static void nft_objref_map_activate(const struct nft_ctx *ctx,\n {\n\
    \ \tstruct nft_objref_map *priv = nft_expr_priv(expr);\n \n-\tpriv->set->use++;\n\
    +\tnf_tables_activate_set(ctx, priv->set);\n }\n \n static void nft_objref_map_destroy(const\
    \ struct nft_ctx *ctx,"
  identifiers:
  - CVE-2023-32233
  - CWE-416
  overview: In the Linux kernel through 6.3.1, a use-after-free in Netfilter nf_tables
    when processing batch requests can be abused to perform arbitrary read and write
    operations on kernel memory. Unprivileged local users can obtain root privileges.
    This occurs because anonymous sets are mishandled.
  references:
  - source: cve@mitre.org
    tags:
    - Patch
    - Third Party Advisory
    url: http://packetstormsecurity.com/files/173087/Kernel-Live-Patch-Security-Notice-LSN-0095-1.html
  - source: cve@mitre.org
    tags:
    - Mailing List
    - Third Party Advisory
    url: http://www.openwall.com/lists/oss-security/2023/05/15/5
  - source: cve@mitre.org
    tags:
    - Issue Tracking
    - Mitigation
    - Third Party Advisory
    url: https://bugzilla.redhat.com/show_bug.cgi?id=2196105
  - source: cve@mitre.org
    tags:
    - Mailing List
    - Patch
    url: https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=c1592a89942e9678f7d9c8030efa777c0d57edab
  - source: cve@mitre.org
    tags:
    - Patch
    url: https://github.com/torvalds/linux/commit/c1592a89942e9678f7d9c8030efa777c0d57edab
  - source: cve@mitre.org
    tags:
    - Third Party Advisory
    url: https://lists.debian.org/debian-lts-announce/2023/06/msg00008.html
  - source: cve@mitre.org
    tags:
    - Mailing List
    - Third Party Advisory
    url: https://lists.debian.org/debian-lts-announce/2023/07/msg00030.html
  - source: cve@mitre.org
    tags:
    - Issue Tracking
    url: https://news.ycombinator.com/item?id=35879660
  - source: cve@mitre.org
    tags:
    - Mailing List
    - Third Party Advisory
    url: https://security.netapp.com/advisory/ntap-20230616-0002/
  - source: cve@mitre.org
    tags:
    - Mailing List
    - Third Party Advisory
    url: https://www.debian.org/security/2023/dsa-5402
  - source: cve@mitre.org
    tags:
    - Mailing List
    - Patch
    - Third Party Advisory
    url: https://www.openwall.com/lists/oss-security/2023/05/08/4
  title: In the Linux kernel through 6.3.1, a use-after-free in Netfilter nf_tables
    when processing batch requests can be abused to perform arbitrary read and write
    operations on kernel memory. Unprivileged local users can obtain root privileges.
    This occurs because anonymous sets are mishandled.
- diff_content:
  - "--- a/fs/ext4/xattr.c\n+++ b/fs/ext4/xattr.c\n@@ -2175,8 +2175,9 @@ int ext4_xattr_ibody_find(struct\
    \ inode *inode, struct ext4_xattr_info *i,\n \tstruct ext4_inode *raw_inode;\n\
    \ \tint error;\n \n-\tif (EXT4_I(inode)->i_extra_isize == 0)\n+\tif (!EXT4_INODE_HAS_XATTR_SPACE(inode))\n\
    \ \t\treturn 0;\n+\n \traw_inode = ext4_raw_inode(&is->iloc);\n \theader = IHDR(inode,\
    \ raw_inode);\n \tis->s.base = is->s.first = IFIRST(header);\n@@ -2204,8 +2205,9\
    \ @@ int ext4_xattr_ibody_set(handle_t *handle, struct inode *inode,\n \tstruct\
    \ ext4_xattr_search *s = &is->s;\n \tint error;\n \n-\tif (EXT4_I(inode)->i_extra_isize\
    \ == 0)\n+\tif (!EXT4_INODE_HAS_XATTR_SPACE(inode))\n \t\treturn -ENOSPC;\n+\n\
    \ \terror = ext4_xattr_set_entry(i, s, handle, inode, false /* is_block */);\n\
    \ \tif (error)\n \t\treturn error;"
  identifiers:
  - CVE-2023-2513
  - CWE-416
  overview: A use-after-free vulnerability was found in the Linux kernel's ext4 filesystem
    in the way it handled the extra inode size for extended attributes. This flaw
    could allow a privileged local user to cause a system crash or other undefined
    behaviors.
  references:
  - source: secalert@redhat.com
    tags:
    - Issue Tracking
    - Third Party Advisory
    url: https://bugzilla.redhat.com/show_bug.cgi?id=2193097
  - source: secalert@redhat.com
    tags:
    - Patch
    url: https://github.com/torvalds/linux/commit/67d7d8ad99be
  - source: secalert@redhat.com
    url: https://lore.kernel.org/all/20220616021358.2504451-1-libaokun1%40huawei.com/
  title: A use-after-free vulnerability was found in the Linux kernel's ext4 filesystem
    in the way it handled the extra inode size for extended attributes. This flaw
    could allow a privileged local user to cause a system crash or other undefined
    behaviors.
- diff_content:
  - "--- a/dns/Decompress.c\n+++ b/dns/Decompress.c\n@@ -1,4 +1,4 @@\n-/* Copyright\
    \ (c) 2002-2006 Sam Trenholme\n+/* Copyright (c) 2002-2023 Sam Trenholme\n  *\n\
    \  * TERMS\n  *\n@@ -884,7 +884,7 @@ int decomp_get_rddata(js_string *compressed,\
    \ js_string *out,\n             /* Variable length data (length determined by\
    \ rdlength) */\n             else if(subtype == RRSUB_VARIABLE) {\n          \
    \       len = rdlength - total;\n-                if(len == 0) {\n+          \
    \      if(len <= 0) {\n                     break;\n                     }\n \
    \                if(decomp_append_bytes(compressed,out,"
  identifiers:
  - CVE-2023-31137
  - CWE-191
  overview: 'MaraDNS is open-source software that implements the Domain Name System
    (DNS). In version 3.5.0024 and prior, a remotely exploitable integer underflow
    vulnerability in the DNS packet decompression function allows an attacker to cause
    a Denial of Service by triggering an abnormal program termination.


    The vulnerability exists in the `decomp_get_rddata` function within the `Decompress.c`
    file. When handling a DNS packet with an Answer RR of qtype 16 (TXT record) and
    any qclass, if the `rdlength` is smaller than `rdata`, the result of the line
    `Decompress.c:886` is a negative number `len = rdlength - total;`. This value
    is then passed to the `decomp_append_bytes` function without proper validation,
    causing the program to attempt to allocate a massive chunk of memory that is impossible
    to allocate. Consequently, the program exits with an error code of 64, causing
    a Denial of Service.


    One proposed fix for this vulnerability is to patch `Decompress.c:887` by breaking
    `if(len <= 0)`, which has been incorporated in version 3.5.0036 via commit bab062bde40b2ae8a91eecd522e84d8b993bab58.'
  references:
  - source: security-advisories@github.com
    tags:
    - Product
    url: https://github.com/samboy/MaraDNS/blob/08b21ea20d80cedcb74aa8f14979ec7c61846663/dns/Decompress.c#L886
  - source: security-advisories@github.com
    tags:
    - Patch
    url: https://github.com/samboy/MaraDNS/commit/bab062bde40b2ae8a91eecd522e84d8b993bab58
  - source: security-advisories@github.com
    tags:
    - Vendor Advisory
    url: https://github.com/samboy/MaraDNS/security/advisories/GHSA-58m7-826v-9c3c
  - source: security-advisories@github.com
    tags:
    - Mailing List
    - Third Party Advisory
    url: https://lists.debian.org/debian-lts-announce/2023/06/msg00019.html
  - source: security-advisories@github.com
    tags:
    - Mailing List
    - Third Party Advisory
    url: https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/3VSMLJX25MXGQ6A7UPOGK7VPUVDESPHL/
  - source: security-advisories@github.com
    tags:
    - Mailing List
    - Third Party Advisory
    url: https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/NB7LDZM5AGWC5BHHQHW6CP5OFNBBKFOQ/
  - source: security-advisories@github.com
    tags:
    - Mailing List
    - Third Party Advisory
    url: https://www.debian.org/security/2023/dsa-5441
  title: 'MaraDNS is open-source software that implements the Domain Name System (DNS).
    In version 3.5.0024 and prior, a remotely exploitable integer underflow vulnerability
    in the DNS packet decompression function allows an attacker to cause a Denial
    of Service by triggering an abnormal program termination.


    The vulnerability exists in the `decomp_get_rddata` function within the `Decompress.c`
    file. When handling a DNS packet with an Answer RR of qtype 16 (TXT record) and
    any qclass, if the `rdlength` is smaller than `rdata`, the result of the line
    `Decompress.c:886` is a negative number `len = rdlength - total;`. This value
    is then passed to the `decomp_append_bytes` function without proper validation,
    causing the program to attempt to allocate a massive chunk of memory that is impossible
    to allocate. Consequently, the program exits with an error code of 64, causing
    a Denial of Service.


    One proposed fix for this vulnerability is to patch `Decompress.c:887` by breaking
    `if(len <= 0)`, which has been incorporated in version 3.5.0036 via commit bab062bde40b2ae8a91eecd522e84d8b993bab58.'
- diff_content:
  - "--- a/src/register.c\n+++ b/src/register.c\n@@ -301,7 +301,7 @@ get_register(\n\
    \     if (copy)\n     {\n \t// If we run out of memory some or all of the lines\
    \ are empty.\n-\tif (reg->y_size == 0)\n+\tif (reg->y_size == 0 || y_current->y_array\
    \ == NULL)\n \t    reg->y_array = NULL;\n \telse\n \t    reg->y_array = ALLOC_MULT(char_u\
    \ *, reg->y_size);"
  - "--- a/src/version.c\n+++ b/src/version.c\n@@ -695,6 +695,8 @@ static char *(features[])\
    \ =\n \n static int included_patches[] =\n {   /* Add new patch number below this\
    \ line */\n+/**/\n+    1531,\n /**/\n     1530,\n /**/"
  identifiers:
  - CVE-2023-2609
  - CWE-476
  overview: NULL Pointer Dereference in GitHub repository vim/vim prior to 9.0.1531.
  references:
  - source: security@huntr.dev
    tags:
    - Patch
    url: https://github.com/vim/vim/commit/d1ae8366aff286d41e7f5bc513cc0a1af5130aad
  - source: security@huntr.dev
    tags:
    - Exploit
    - Third Party Advisory
    url: https://huntr.dev/bounties/1679be5a-565f-4a44-a430-836412a0b622
  - source: security@huntr.dev
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/PCLJN4QINITA3ZASKLEJ64C5TFNKELMO/
  - source: security@huntr.dev
    url: https://support.apple.com/kb/HT213844
  - source: security@huntr.dev
    url: https://support.apple.com/kb/HT213845
  title: NULL Pointer Dereference in GitHub repository vim/vim prior to 9.0.1531.
- diff_content:
  - "--- a/src/regexp.c\n+++ b/src/regexp.c\n@@ -1767,10 +1767,7 @@ do_Lower(int *d,\
    \ int c)\n regtilde(char_u *source, int magic)\n {\n     char_u\t*newsub = source;\n\
    -    char_u\t*tmpsub;\n     char_u\t*p;\n-    int\t\tlen;\n-    int\t\tprevlen;\n\
    \ \n     for (p = newsub; *p; ++p)\n     {\n@@ -1779,24 +1776,35 @@ regtilde(char_u\
    \ *source, int magic)\n \t    if (reg_prev_sub != NULL)\n \t    {\n \t\t// length\
    \ = len(newsub) - 1 + len(prev_sub) + 1\n-\t\tprevlen = (int)STRLEN(reg_prev_sub);\n\
    -\t\ttmpsub = alloc(STRLEN(newsub) + prevlen);\n+\t\t// Avoid making the text\
    \ longer than MAXCOL, it will cause\n+\t\t// trouble at some point.\n+\t\tsize_t\t\
    prevsublen = STRLEN(reg_prev_sub);\n+\t\tsize_t  newsublen = STRLEN(newsub);\n\
    +\t\tif (prevsublen > MAXCOL || newsublen > MAXCOL\n+\t\t\t\t\t    || newsublen\
    \ + prevsublen > MAXCOL)\n+\t\t{\n+\t\t    emsg(_(e_resulting_text_too_long));\n\
    +\t\t    break;\n+\t\t}\n+\n+\t\tchar_u *tmpsub = alloc(newsublen + prevsublen);\n\
    \ \t\tif (tmpsub != NULL)\n \t\t{\n \t\t    // copy prefix\n-\t\t    len = (int)(p\
    \ - newsub);\t// not including ~\n-\t\t    mch_memmove(tmpsub, newsub, (size_t)len);\n\
    +\t\t    size_t prefixlen = p - newsub;\t// not including ~\n+\t\t    mch_memmove(tmpsub,\
    \ newsub, prefixlen);\n \t\t    // interpret tilde\n-\t\t    mch_memmove(tmpsub\
    \ + len, reg_prev_sub, (size_t)prevlen);\n+\t\t    mch_memmove(tmpsub + prefixlen,\
    \ reg_prev_sub,\n+\t\t\t\t\t\t\t       prevsublen);\n \t\t    // copy postfix\n\
    \ \t\t    if (!magic)\n \t\t\t++p;\t\t\t// back off backslash\n-\t\t    STRCPY(tmpsub\
    \ + len + prevlen, p + 1);\n+\t\t    STRCPY(tmpsub + prefixlen + prevsublen, p\
    \ + 1);\n \n-\t\t    if (newsub != source)\t// already allocated newsub\n+\t\t\
    \    if (newsub != source)\t// allocated newsub before\n \t\t\tvim_free(newsub);\n\
    \ \t\t    newsub = tmpsub;\n-\t\t    p = newsub + len + prevlen;\n+\t\t    p =\
    \ newsub + prefixlen + prevsublen;\n \t\t}\n \t    }\n \t    else if (magic)"
  - "--- a/src/version.c\n+++ b/src/version.c\n@@ -695,6 +695,8 @@ static char *(features[])\
    \ =\n \n static int included_patches[] =\n {   /* Add new patch number below this\
    \ line */\n+/**/\n+    1532,\n /**/\n     1531,\n /**/"
  identifiers:
  - CVE-2023-2610
  - CWE-190
  overview: Integer Overflow or Wraparound in GitHub repository vim/vim prior to 9.0.1532.
  references:
  - source: security@huntr.dev
    tags:
    - Patch
    url: https://github.com/vim/vim/commit/ab9a2d884b3a4abe319606ea95a5a6d6b01cd73a
  - source: security@huntr.dev
    tags:
    - Exploit
    - Patch
    url: https://huntr.dev/bounties/31e67340-935b-4f6c-a923-f7246bc29c7d
  - source: security@huntr.dev
    url: https://lists.debian.org/debian-lts-announce/2023/06/msg00015.html
  - source: security@huntr.dev
    url: https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/PCLJN4QINITA3ZASKLEJ64C5TFNKELMO/
  - source: security@huntr.dev
    url: https://support.apple.com/kb/HT213844
  - source: security@huntr.dev
    url: https://support.apple.com/kb/HT213845
  title: Integer Overflow or Wraparound in GitHub repository vim/vim prior to 9.0.1532.
- diff_content:
  - "--- a/hphp/runtime/base/ssl-socket.cpp\n+++ b/hphp/runtime/base/ssl-socket.cpp\n\
    @@ -499,7 +499,7 @@ bool SSLSocket::setupCrypto(SSLSocket *session /* = NULL */)\
    \ {\n     break;\n   case CryptoMethod::ClientTLS:\n     m_data->m_client = true;\n\
    -    smethod = TLSv1_client_method();\n+    smethod = TLS_client_method();\n \
    \    break;\n   case CryptoMethod::ServerSSLv23:\n     m_data->m_client = false;\n\
    @@ -542,7 +542,7 @@ bool SSLSocket::setupCrypto(SSLSocket *session /* = NULL */)\
    \ {\n \n   case CryptoMethod::ServerTLS:\n     m_data->m_client = false;\n-  \
    \  smethod = TLSv1_server_method();\n+    smethod = TLS_server_method();\n   \
    \  break;\n   default:\n     return false;"
  identifiers:
  - CVE-2022-36937
  - NVD-CWE-noinfo
  overview: 'HHVM 4.172.0 and all prior versions use TLS 1.0 for secure connections
    when handling tls:// URLs in the stream extension. TLS1.0 has numerous published
    vulnerabilities and is deprecated. HHVM 4.153.4, 4.168.2, 4.169.2, 4.170.2, 4.171.1,
    4.172.1, 4.173.0 replaces TLS1.0 with TLS1.3.


    Applications that call stream_socket_server or stream_socket_client functions
    with a URL starting with tls:// are affected.'
  references:
  - source: cve-assign@fb.com
    tags:
    - Patch
    url: https://github.com/facebook/hhvm/commit/083f5ffdee661f61512909d16f9a5b98cff3cf0b
  - source: cve-assign@fb.com
    tags:
    - Vendor Advisory
    url: https://hhvm.com/blog/2023/01/20/security-update.html
  title: 'HHVM 4.172.0 and all prior versions use TLS 1.0 for secure connections when
    handling tls:// URLs in the stream extension. TLS1.0 has numerous published vulnerabilities
    and is deprecated. HHVM 4.153.4, 4.168.2, 4.169.2, 4.170.2, 4.171.1, 4.172.1,
    4.173.0 replaces TLS1.0 with TLS1.3.


    Applications that call stream_socket_server or stream_socket_client functions
    with a URL starting with tls:// are affected.'
